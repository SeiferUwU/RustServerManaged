#define UNITY_ASSERTIONS
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using JetBrains.Annotations;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Profiling;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Bindings;
using UnityEngine.Pool;
using UnityEngine.Rendering;
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;
using UnityEngine.TextCore.Text;
using UnityEngine.UIElements.Experimental;
using UnityEngine.UIElements.Internal;
using UnityEngine.UIElements.StyleSheets;
using UnityEngine.UIElements.StyleSheets.Syntax;
using UnityEngine.UIElements.UIR;
using UnityEngine.UIElements.UIR.Implementation;
using UnityEngine.Yoga;

[assembly: InternalsVisibleTo("UnityEngine.UIModule")]
[assembly: InternalsVisibleTo("UnityEngine.TilemapModule")]
[assembly: InternalsVisibleTo("UnityEngine.TerrainPhysicsModule")]
[assembly: InternalsVisibleTo("UnityEngine.TerrainModule")]
[assembly: InternalsVisibleTo("UnityEngine.SubsystemsModule")]
[assembly: InternalsVisibleTo("UnityEngine.SubstanceModule")]
[assembly: InternalsVisibleTo("UnityEngine.StreamingModule")]
[assembly: InternalsVisibleTo("UnityEngine.UIElementsModule")]
[assembly: InternalsVisibleTo("UnityEngine.SpriteShapeModule")]
[assembly: InternalsVisibleTo("UnityEngine.ScreenCaptureModule")]
[assembly: InternalsVisibleTo("UnityEngine.RuntimeInitializeOnLoadManagerInitializerModule")]
[assembly: InternalsVisibleTo("UnityEngine.PropertiesModule")]
[assembly: InternalsVisibleTo("UnityEngine.ProfilerModule")]
[assembly: InternalsVisibleTo("UnityEngine.Physics2DModule")]
[assembly: InternalsVisibleTo("UnityEngine.PerformanceReportingModule")]
[assembly: InternalsVisibleTo("UnityEngine.ParticleSystemModule")]
[assembly: InternalsVisibleTo("UnityEngine.SpriteMaskModule")]
[assembly: InternalsVisibleTo("UnityEngine.NVIDIAModule")]
[assembly: InternalsVisibleTo("UnityEngine.UmbraModule")]
[assembly: InternalsVisibleTo("UnityEngine.UnityTestProtocolModule")]
[assembly: InternalsVisibleTo("UnityEngine.PS5Module")]
[assembly: InternalsVisibleTo("UnityEngine.PS4VRModule")]
[assembly: InternalsVisibleTo("UnityEngine.PS4Module")]
[assembly: InternalsVisibleTo("UnityEngine.XboxOneModule")]
[assembly: InternalsVisibleTo("UnityEngine.SwitchModule")]
[assembly: InternalsVisibleTo("UnityEngine.WindModule")]
[assembly: InternalsVisibleTo("UnityEngine.VirtualTexturingModule")]
[assembly: InternalsVisibleTo("UnityEngine.UnityCurlModule")]
[assembly: InternalsVisibleTo("UnityEngine.VideoModule")]
[assembly: InternalsVisibleTo("UnityEngine.VRModule")]
[assembly: InternalsVisibleTo("UnityEngine.XRModule")]
[assembly: InternalsVisibleTo("UnityEngine.VFXModule")]
[assembly: InternalsVisibleTo("UnityEngine.UnityWebRequestWWWModule")]
[assembly: InternalsVisibleTo("UnityEngine.UnityWebRequestTextureModule")]
[assembly: InternalsVisibleTo("UnityEngine.UnityWebRequestAudioModule")]
[assembly: InternalsVisibleTo("UnityEngine.UnityWebRequestAssetBundleModule")]
[assembly: InternalsVisibleTo("UnityEngine.VehiclesModule")]
[assembly: InternalsVisibleTo("UnityEngine.PS5VRModule")]
[assembly: InternalsVisibleTo("UnityEngine.LocalizationModule")]
[assembly: InternalsVisibleTo("UnityEngine.TextCoreTextEngineModule")]
[assembly: InternalsVisibleTo("UnityEngine.AssetBundleModule")]
[assembly: InternalsVisibleTo("UnityEngine.HotReloadModule")]
[assembly: InternalsVisibleTo("UnityEngine.AnimationModule")]
[assembly: InternalsVisibleTo("UnityEngine.AndroidJNIModule")]
[assembly: InternalsVisibleTo("UnityEngine.AccessibilityModule")]
[assembly: InternalsVisibleTo("UnityEngine.ARModule")]
[assembly: InternalsVisibleTo("UnityEngine.InputModule")]
[assembly: InternalsVisibleTo("UnityEngine.AudioModule")]
[assembly: InternalsVisibleTo("UnityEngine.JSONSerializeModule")]
[assembly: InternalsVisibleTo("UnityEngine.AIModule")]
[assembly: InternalsVisibleTo("UnityEngine.CoreModule")]
[assembly: InternalsVisibleTo("UnityEngine.SharedInternalsModule")]
[assembly: InternalsVisibleTo("UnityEngine")]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints | DebuggableAttribute.DebuggingModes.EnableEditAndContinue)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: CompilationRelaxations(8)]
[assembly: InternalsVisibleTo("UnityEngine.PhysicsModule")]
[assembly: InternalsVisibleTo("UnityEngine.IMGUIModule")]
[assembly: InternalsVisibleTo("UnityEngine.ClothModule")]
[assembly: InternalsVisibleTo("UnityEngine.ClusterRendererModule")]
[assembly: InternalsVisibleTo("UnityEngine.TextCoreFontEngineModule")]
[assembly: InternalsVisibleTo("UnityEngine.InputLegacyModule")]
[assembly: InternalsVisibleTo("UnityEngine.TextRenderingModule")]
[assembly: InternalsVisibleTo("UnityEngine.GridModule")]
[assembly: InternalsVisibleTo("UnityEngine.GameCenterModule")]
[assembly: InternalsVisibleTo("UnityEngine.ImageConversionModule")]
[assembly: InternalsVisibleTo("UnityEngine.GIModule")]
[assembly: InternalsVisibleTo("UnityEngine.ClusterInputModule")]
[assembly: InternalsVisibleTo("UnityEngine.DirectorModule")]
[assembly: InternalsVisibleTo("UnityEngine.CrashReportingModule")]
[assembly: InternalsVisibleTo("UnityEngine.UnityAnalyticsModule")]
[assembly: InternalsVisibleTo("UnityEngine.UnityWebRequestModule")]
[assembly: InternalsVisibleTo("UnityEngine.TLSModule")]
[assembly: InternalsVisibleTo("UnityEngine.UnityAnalyticsCommonModule")]
[assembly: InternalsVisibleTo("UnityEngine.UnityConnectModule")]
[assembly: InternalsVisibleTo("UnityEngine.ContentLoadModule")]
[assembly: InternalsVisibleTo("UnityEngine.DSPGraphModule")]
[assembly: InternalsVisibleTo("UnityEngine.Networking")]
[assembly: InternalsVisibleTo("UnityEngine.Cloud")]
[assembly: InternalsVisibleTo("UnityEngine.Cloud.Service")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.010")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.009")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.008")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.007")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.006")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.005")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.004")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.011")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.003")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.001")]
[assembly: InternalsVisibleTo("UnityEngine.Core.Runtime.Tests")]
[assembly: InternalsVisibleTo("Unity.Core")]
[assembly: InternalsVisibleTo("Unity.Runtime")]
[assembly: InternalsVisibleTo("Unity.Collections")]
[assembly: InternalsVisibleTo("Unity.Entities.Tests")]
[assembly: InternalsVisibleTo("Unity.Entities")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.002")]
[assembly: InternalsVisibleTo("Unity.Logging")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.012")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.014")]
[assembly: InternalsVisibleTo("Unity.Subsystem.Registration")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridgeDev.005")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridgeDev.004")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridgeDev.003")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridgeDev.002")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridgeDev.001")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.024")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.013")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.023")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.021")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.020")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.019")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.018")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.017")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.016")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.015")]
[assembly: InternalsVisibleTo("Unity.InternalAPIEngineBridge.022")]
[assembly: InternalsVisibleTo("Unity.Services.QoS")]
[assembly: InternalsVisibleTo("Unity.ucg.QoS")]
[assembly: InternalsVisibleTo("Unity.Networking.Transport")]
[assembly: InternalsVisibleTo("Unity.RuntimeTests.Framework")]
[assembly: InternalsVisibleTo("Unity.RuntimeTests")]
[assembly: InternalsVisibleTo("Unity.IntegrationTests.Framework")]
[assembly: InternalsVisibleTo("Unity.IntegrationTests.Timeline")]
[assembly: InternalsVisibleTo("Unity.IntegrationTests.UnityAnalytics")]
[assembly: InternalsVisibleTo("Unity.IntegrationTests")]
[assembly: InternalsVisibleTo("Unity.DeploymentTests.Services")]
[assembly: InternalsVisibleTo("Unity.RuntimeTests.Framework.Tests")]
[assembly: InternalsVisibleTo("Unity.Burst.Editor")]
[assembly: InternalsVisibleTo("Unity.Automation")]
[assembly: InternalsVisibleTo("UnityEngine.TestRunner")]
[assembly: InternalsVisibleTo("UnityEngine.Purchasing")]
[assembly: InternalsVisibleTo("UnityEngine.Advertisements")]
[assembly: InternalsVisibleTo("UnityEngine.UnityAnalyticsCommon")]
[assembly: InternalsVisibleTo("UnityEngine.Analytics")]
[assembly: InternalsVisibleTo("Unity.Analytics")]
[assembly: InternalsVisibleTo("Unity.Burst")]
[assembly: InternalsVisibleTo("Unity.PerformanceTests.RuntimeTestRunner.Tests")]
[assembly: InternalsVisibleTo("Unity.RuntimeTests.AllIn1Runner")]
[assembly: InternalsVisibleTo("Unity.Timeline")]
[assembly: InternalsVisibleTo("UnityEngine.UI")]
[assembly: InternalsVisibleTo("Unity.UIElements.EditorTests")]
[assembly: InternalsVisibleTo("UnityEngine.UIElements.Tests")]
[assembly: InternalsVisibleTo("Unity.UIElements.PlayModeTests")]
[assembly: InternalsVisibleTo("Unity.UIElements.Editor")]
[assembly: InternalsVisibleTo("UnityEngine.UIElementsGameObjectsModule")]
[assembly: InternalsVisibleTo("Unity.UIElements")]
[assembly: InternalsVisibleTo("Unity.UI.Builder.EditorTests")]
[assembly: InternalsVisibleTo("UnityEditor.UIBuilderModule")]
[assembly: InternalsVisibleTo("Unity.UI.Builder.Editor")]
[assembly: InternalsVisibleTo("Unity.2D.Sprite.EditorTests")]
[assembly: InternalsVisibleTo("Unity.2D.Sprite.Editor")]
[assembly: InternalsVisibleTo("Unity.WindowsMRAutomation")]
[assembly: InternalsVisibleTo("GoogleAR.UnityNative")]
[assembly: InternalsVisibleTo("UnityEngine.SpatialTracking")]
[assembly: InternalsVisibleTo("Assembly-CSharp-firstpass-testable")]
[assembly: InternalsVisibleTo("Assembly-CSharp-testable")]
[assembly: UnityEngineModuleAssembly]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
namespace UnityEngine.Yoga
{
	internal delegate float BaselineFunction(YogaNode node, float width, float height);
	internal delegate void Logger(YogaConfig config, YogaNode node, YogaLogLevel level, string message);
	internal delegate YogaSize MeasureFunction(YogaNode node, float width, YogaMeasureMode widthMode, float height, YogaMeasureMode heightMode);
	internal class MeasureOutput
	{
		public static YogaSize Make(float width, float height)
		{
			return new YogaSize
			{
				width = width,
				height = height
			};
		}
	}
	internal enum YogaAlign
	{
		Auto,
		FlexStart,
		Center,
		FlexEnd,
		Stretch,
		Baseline,
		SpaceBetween,
		SpaceAround
	}
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	internal delegate float YogaBaselineFunc(IntPtr unmanagedNodePtr, float width, float height);
	internal class YogaConfig
	{
		internal static readonly YogaConfig Default = new YogaConfig(Native.YGConfigGetDefault());

		private IntPtr _ygConfig;

		private Logger _logger;

		internal IntPtr Handle => _ygConfig;

		public Logger Logger
		{
			get
			{
				return _logger;
			}
			set
			{
				_logger = value;
			}
		}

		public bool UseWebDefaults
		{
			get
			{
				return Native.YGConfigGetUseWebDefaults(_ygConfig);
			}
			set
			{
				Native.YGConfigSetUseWebDefaults(_ygConfig, value);
			}
		}

		public float PointScaleFactor
		{
			get
			{
				return Native.YGConfigGetPointScaleFactor(_ygConfig);
			}
			set
			{
				Native.YGConfigSetPointScaleFactor(_ygConfig, value);
			}
		}

		private YogaConfig(IntPtr ygConfig)
		{
			_ygConfig = ygConfig;
			if (_ygConfig == IntPtr.Zero)
			{
				throw new InvalidOperationException("Failed to allocate native memory");
			}
		}

		public YogaConfig()
			: this(Native.YGConfigNew())
		{
		}

		~YogaConfig()
		{
			if (Handle != Default.Handle)
			{
				Native.YGConfigFree(Handle);
			}
		}

		public void SetExperimentalFeatureEnabled(YogaExperimentalFeature feature, bool enabled)
		{
			Native.YGConfigSetExperimentalFeatureEnabled(_ygConfig, feature, enabled);
		}

		public bool IsExperimentalFeatureEnabled(YogaExperimentalFeature feature)
		{
			return Native.YGConfigIsExperimentalFeatureEnabled(_ygConfig, feature);
		}

		public static int GetInstanceCount()
		{
			return Native.YGConfigGetInstanceCount();
		}

		public static void SetDefaultLogger(Logger logger)
		{
			Default.Logger = logger;
		}
	}
	internal static class YogaConstants
	{
		public const float Undefined = float.NaN;

		public static bool IsUndefined(float value)
		{
			return float.IsNaN(value);
		}

		public static bool IsUndefined(YogaValue value)
		{
			return value.Unit == YogaUnit.Undefined;
		}
	}
	internal enum YogaDimension
	{
		Width,
		Height
	}
	internal enum YogaDirection
	{
		Inherit,
		LTR,
		RTL
	}
	internal enum YogaDisplay
	{
		Flex,
		None
	}
	internal enum YogaEdge
	{
		Left,
		Top,
		Right,
		Bottom,
		Start,
		End,
		Horizontal,
		Vertical,
		All
	}
	internal enum YogaExperimentalFeature
	{
		WebFlexBasis
	}
	internal enum YogaFlexDirection
	{
		Column,
		ColumnReverse,
		Row,
		RowReverse
	}
	internal enum YogaJustify
	{
		FlexStart,
		Center,
		FlexEnd,
		SpaceBetween,
		SpaceAround
	}
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	internal delegate void YogaLogger(IntPtr unmanagedConfigPtr, IntPtr unmanagedNotePtr, YogaLogLevel level, string message);
	internal enum YogaLogLevel
	{
		Error,
		Warn,
		Info,
		Debug,
		Verbose,
		Fatal
	}
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	internal delegate YogaSize YogaMeasureFunc(IntPtr unmanagedNodePtr, float width, YogaMeasureMode widthMode, float height, YogaMeasureMode heightMode);
	internal enum YogaMeasureMode
	{
		Undefined,
		Exactly,
		AtMost
	}
	[NativeHeader("ModuleOverrides/com.unity.ui/Core/Native/YogaNative.bindings.h")]
	internal static class Native
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		private static extern IntPtr YGNodeNew();

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern IntPtr YGNodeNewWithConfig(IntPtr config);

		public static void YGNodeFree(IntPtr ygNode)
		{
			if (!(ygNode == IntPtr.Zero))
			{
				YGNodeFreeInternal(ygNode);
			}
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction(Name = "YGNodeFree", IsThreadSafe = true)]
		private static extern void YGNodeFreeInternal(IntPtr ygNode);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeReset(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGSetManagedObject(IntPtr ygNode, YogaNode node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeSetConfig(IntPtr ygNode, IntPtr config);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction(IsThreadSafe = true)]
		public static extern IntPtr YGConfigGetDefault();

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern IntPtr YGConfigNew();

		public static void YGConfigFree(IntPtr config)
		{
			if (!(config == IntPtr.Zero))
			{
				YGConfigFreeInternal(config);
			}
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction(Name = "YGConfigFree", IsThreadSafe = true)]
		private static extern void YGConfigFreeInternal(IntPtr config);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern int YGNodeGetInstanceCount();

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern int YGConfigGetInstanceCount();

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGConfigSetExperimentalFeatureEnabled(IntPtr config, YogaExperimentalFeature feature, bool enabled);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern bool YGConfigIsExperimentalFeatureEnabled(IntPtr config, YogaExperimentalFeature feature);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGConfigSetUseWebDefaults(IntPtr config, bool useWebDefaults);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern bool YGConfigGetUseWebDefaults(IntPtr config);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGConfigSetPointScaleFactor(IntPtr config, float pixelsInPoint);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern float YGConfigGetPointScaleFactor(IntPtr config);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeInsertChild(IntPtr node, IntPtr child, uint index);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeRemoveChild(IntPtr node, IntPtr child);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeCalculateLayout(IntPtr node, float availableWidth, float availableHeight, YogaDirection parentDirection);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeMarkDirty(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern bool YGNodeIsDirty(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodePrint(IntPtr node, YogaPrintOptions options);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeCopyStyle(IntPtr dstNode, IntPtr srcNode);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction(Name = "YogaCallback::SetMeasureFunc")]
		public static extern void YGNodeSetMeasureFunc(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction(Name = "YogaCallback::RemoveMeasureFunc")]
		public static extern void YGNodeRemoveMeasureFunc(IntPtr node);

		[RequiredByNativeCode]
		public unsafe static void YGNodeMeasureInvoke(YogaNode node, float width, YogaMeasureMode widthMode, float height, YogaMeasureMode heightMode, IntPtr returnValueAddress)
		{
			*(YogaSize*)(void*)returnValueAddress = YogaNode.MeasureInternal(node, width, widthMode, height, heightMode);
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction(Name = "YogaCallback::SetBaselineFunc")]
		public static extern void YGNodeSetBaselineFunc(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction(Name = "YogaCallback::RemoveBaselineFunc")]
		public static extern void YGNodeRemoveBaselineFunc(IntPtr node);

		[RequiredByNativeCode]
		public unsafe static void YGNodeBaselineInvoke(YogaNode node, float width, float height, IntPtr returnValueAddress)
		{
			*(float*)(void*)returnValueAddress = YogaNode.BaselineInternal(node, width, height);
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeSetHasNewLayout(IntPtr node, bool hasNewLayout);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern bool YGNodeGetHasNewLayout(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetDirection(IntPtr node, YogaDirection direction);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern YogaDirection YGNodeStyleGetDirection(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetFlexDirection(IntPtr node, YogaFlexDirection flexDirection);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern YogaFlexDirection YGNodeStyleGetFlexDirection(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetJustifyContent(IntPtr node, YogaJustify justifyContent);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern YogaJustify YGNodeStyleGetJustifyContent(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetAlignContent(IntPtr node, YogaAlign alignContent);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern YogaAlign YGNodeStyleGetAlignContent(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetAlignItems(IntPtr node, YogaAlign alignItems);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern YogaAlign YGNodeStyleGetAlignItems(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetAlignSelf(IntPtr node, YogaAlign alignSelf);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern YogaAlign YGNodeStyleGetAlignSelf(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetPositionType(IntPtr node, YogaPositionType positionType);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern YogaPositionType YGNodeStyleGetPositionType(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetFlexWrap(IntPtr node, YogaWrap flexWrap);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern YogaWrap YGNodeStyleGetFlexWrap(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetOverflow(IntPtr node, YogaOverflow flexWrap);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern YogaOverflow YGNodeStyleGetOverflow(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetDisplay(IntPtr node, YogaDisplay display);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern YogaDisplay YGNodeStyleGetDisplay(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetFlex(IntPtr node, float flex);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetFlexGrow(IntPtr node, float flexGrow);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern float YGNodeStyleGetFlexGrow(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetFlexShrink(IntPtr node, float flexShrink);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern float YGNodeStyleGetFlexShrink(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetFlexBasis(IntPtr node, float flexBasis);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetFlexBasisPercent(IntPtr node, float flexBasis);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetFlexBasisAuto(IntPtr node);

		[FreeFunction]
		public static YogaValue YGNodeStyleGetFlexBasis(IntPtr node)
		{
			YGNodeStyleGetFlexBasis_Injected(node, out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern float YGNodeGetComputedFlexBasis(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetWidth(IntPtr node, float width);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetWidthPercent(IntPtr node, float width);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetWidthAuto(IntPtr node);

		[FreeFunction]
		public static YogaValue YGNodeStyleGetWidth(IntPtr node)
		{
			YGNodeStyleGetWidth_Injected(node, out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetHeight(IntPtr node, float height);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetHeightPercent(IntPtr node, float height);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetHeightAuto(IntPtr node);

		[FreeFunction]
		public static YogaValue YGNodeStyleGetHeight(IntPtr node)
		{
			YGNodeStyleGetHeight_Injected(node, out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetMinWidth(IntPtr node, float minWidth);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetMinWidthPercent(IntPtr node, float minWidth);

		[FreeFunction]
		public static YogaValue YGNodeStyleGetMinWidth(IntPtr node)
		{
			YGNodeStyleGetMinWidth_Injected(node, out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetMinHeight(IntPtr node, float minHeight);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetMinHeightPercent(IntPtr node, float minHeight);

		[FreeFunction]
		public static YogaValue YGNodeStyleGetMinHeight(IntPtr node)
		{
			YGNodeStyleGetMinHeight_Injected(node, out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetMaxWidth(IntPtr node, float maxWidth);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetMaxWidthPercent(IntPtr node, float maxWidth);

		[FreeFunction]
		public static YogaValue YGNodeStyleGetMaxWidth(IntPtr node)
		{
			YGNodeStyleGetMaxWidth_Injected(node, out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetMaxHeight(IntPtr node, float maxHeight);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetMaxHeightPercent(IntPtr node, float maxHeight);

		[FreeFunction]
		public static YogaValue YGNodeStyleGetMaxHeight(IntPtr node)
		{
			YGNodeStyleGetMaxHeight_Injected(node, out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetAspectRatio(IntPtr node, float aspectRatio);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern float YGNodeStyleGetAspectRatio(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetPosition(IntPtr node, YogaEdge edge, float position);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetPositionPercent(IntPtr node, YogaEdge edge, float position);

		[FreeFunction]
		public static YogaValue YGNodeStyleGetPosition(IntPtr node, YogaEdge edge)
		{
			YGNodeStyleGetPosition_Injected(node, edge, out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetMargin(IntPtr node, YogaEdge edge, float margin);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetMarginPercent(IntPtr node, YogaEdge edge, float margin);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetMarginAuto(IntPtr node, YogaEdge edge);

		[FreeFunction]
		public static YogaValue YGNodeStyleGetMargin(IntPtr node, YogaEdge edge)
		{
			YGNodeStyleGetMargin_Injected(node, edge, out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetPadding(IntPtr node, YogaEdge edge, float padding);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetPaddingPercent(IntPtr node, YogaEdge edge, float padding);

		[FreeFunction]
		public static YogaValue YGNodeStyleGetPadding(IntPtr node, YogaEdge edge)
		{
			YGNodeStyleGetPadding_Injected(node, edge, out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern void YGNodeStyleSetBorder(IntPtr node, YogaEdge edge, float border);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern float YGNodeStyleGetBorder(IntPtr node, YogaEdge edge);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern float YGNodeLayoutGetLeft(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern float YGNodeLayoutGetTop(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern float YGNodeLayoutGetRight(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern float YGNodeLayoutGetBottom(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern float YGNodeLayoutGetWidth(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern float YGNodeLayoutGetHeight(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern float YGNodeLayoutGetMargin(IntPtr node, YogaEdge edge);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern float YGNodeLayoutGetPadding(IntPtr node, YogaEdge edge);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern float YGNodeLayoutGetBorder(IntPtr node, YogaEdge edge);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[FreeFunction]
		public static extern YogaDirection YGNodeLayoutGetDirection(IntPtr node);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void YGNodeStyleGetFlexBasis_Injected(IntPtr node, out YogaValue ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void YGNodeStyleGetWidth_Injected(IntPtr node, out YogaValue ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void YGNodeStyleGetHeight_Injected(IntPtr node, out YogaValue ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void YGNodeStyleGetMinWidth_Injected(IntPtr node, out YogaValue ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void YGNodeStyleGetMinHeight_Injected(IntPtr node, out YogaValue ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void YGNodeStyleGetMaxWidth_Injected(IntPtr node, out YogaValue ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void YGNodeStyleGetMaxHeight_Injected(IntPtr node, out YogaValue ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void YGNodeStyleGetPosition_Injected(IntPtr node, YogaEdge edge, out YogaValue ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void YGNodeStyleGetMargin_Injected(IntPtr node, YogaEdge edge, out YogaValue ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void YGNodeStyleGetPadding_Injected(IntPtr node, YogaEdge edge, out YogaValue ret);
	}
	internal class YogaNode : IEnumerable<YogaNode>, IEnumerable
	{
		internal IntPtr _ygNode;

		private YogaConfig _config;

		private WeakReference _parent;

		private List<YogaNode> _children;

		private MeasureFunction _measureFunction;

		private BaselineFunction _baselineFunction;

		private object _data;

		internal YogaConfig Config
		{
			get
			{
				return _config;
			}
			set
			{
				_config = value ?? YogaConfig.Default;
				Native.YGNodeSetConfig(_ygNode, _config.Handle);
			}
		}

		public bool IsDirty => Native.YGNodeIsDirty(_ygNode);

		public bool HasNewLayout => Native.YGNodeGetHasNewLayout(_ygNode);

		public YogaNode Parent => (_parent != null) ? (_parent.Target as YogaNode) : null;

		public bool IsMeasureDefined => _measureFunction != null;

		public bool IsBaselineDefined => _baselineFunction != null;

		public YogaDirection StyleDirection
		{
			get
			{
				return Native.YGNodeStyleGetDirection(_ygNode);
			}
			set
			{
				Native.YGNodeStyleSetDirection(_ygNode, value);
			}
		}

		public YogaFlexDirection FlexDirection
		{
			get
			{
				return Native.YGNodeStyleGetFlexDirection(_ygNode);
			}
			set
			{
				Native.YGNodeStyleSetFlexDirection(_ygNode, value);
			}
		}

		public YogaJustify JustifyContent
		{
			get
			{
				return Native.YGNodeStyleGetJustifyContent(_ygNode);
			}
			set
			{
				Native.YGNodeStyleSetJustifyContent(_ygNode, value);
			}
		}

		public YogaDisplay Display
		{
			get
			{
				return Native.YGNodeStyleGetDisplay(_ygNode);
			}
			set
			{
				Native.YGNodeStyleSetDisplay(_ygNode, value);
			}
		}

		public YogaAlign AlignItems
		{
			get
			{
				return Native.YGNodeStyleGetAlignItems(_ygNode);
			}
			set
			{
				Native.YGNodeStyleSetAlignItems(_ygNode, value);
			}
		}

		public YogaAlign AlignSelf
		{
			get
			{
				return Native.YGNodeStyleGetAlignSelf(_ygNode);
			}
			set
			{
				Native.YGNodeStyleSetAlignSelf(_ygNode, value);
			}
		}

		public YogaAlign AlignContent
		{
			get
			{
				return Native.YGNodeStyleGetAlignContent(_ygNode);
			}
			set
			{
				Native.YGNodeStyleSetAlignContent(_ygNode, value);
			}
		}

		public YogaPositionType PositionType
		{
			get
			{
				return Native.YGNodeStyleGetPositionType(_ygNode);
			}
			set
			{
				Native.YGNodeStyleSetPositionType(_ygNode, value);
			}
		}

		public YogaWrap Wrap
		{
			get
			{
				return Native.YGNodeStyleGetFlexWrap(_ygNode);
			}
			set
			{
				Native.YGNodeStyleSetFlexWrap(_ygNode, value);
			}
		}

		public float Flex
		{
			set
			{
				Native.YGNodeStyleSetFlex(_ygNode, value);
			}
		}

		public float FlexGrow
		{
			get
			{
				return Native.YGNodeStyleGetFlexGrow(_ygNode);
			}
			set
			{
				Native.YGNodeStyleSetFlexGrow(_ygNode, value);
			}
		}

		public float FlexShrink
		{
			get
			{
				return Native.YGNodeStyleGetFlexShrink(_ygNode);
			}
			set
			{
				Native.YGNodeStyleSetFlexShrink(_ygNode, value);
			}
		}

		public YogaValue FlexBasis
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetFlexBasis(_ygNode));
			}
			set
			{
				if (value.Unit == YogaUnit.Percent)
				{
					Native.YGNodeStyleSetFlexBasisPercent(_ygNode, value.Value);
				}
				else if (value.Unit == YogaUnit.Auto)
				{
					Native.YGNodeStyleSetFlexBasisAuto(_ygNode);
				}
				else
				{
					Native.YGNodeStyleSetFlexBasis(_ygNode, value.Value);
				}
			}
		}

		public YogaValue Width
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetWidth(_ygNode));
			}
			set
			{
				if (value.Unit == YogaUnit.Percent)
				{
					Native.YGNodeStyleSetWidthPercent(_ygNode, value.Value);
				}
				else if (value.Unit == YogaUnit.Auto)
				{
					Native.YGNodeStyleSetWidthAuto(_ygNode);
				}
				else
				{
					Native.YGNodeStyleSetWidth(_ygNode, value.Value);
				}
			}
		}

		public YogaValue Height
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetHeight(_ygNode));
			}
			set
			{
				if (value.Unit == YogaUnit.Percent)
				{
					Native.YGNodeStyleSetHeightPercent(_ygNode, value.Value);
				}
				else if (value.Unit == YogaUnit.Auto)
				{
					Native.YGNodeStyleSetHeightAuto(_ygNode);
				}
				else
				{
					Native.YGNodeStyleSetHeight(_ygNode, value.Value);
				}
			}
		}

		public YogaValue MaxWidth
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetMaxWidth(_ygNode));
			}
			set
			{
				if (value.Unit == YogaUnit.Percent)
				{
					Native.YGNodeStyleSetMaxWidthPercent(_ygNode, value.Value);
				}
				else
				{
					Native.YGNodeStyleSetMaxWidth(_ygNode, value.Value);
				}
			}
		}

		public YogaValue MaxHeight
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetMaxHeight(_ygNode));
			}
			set
			{
				if (value.Unit == YogaUnit.Percent)
				{
					Native.YGNodeStyleSetMaxHeightPercent(_ygNode, value.Value);
				}
				else
				{
					Native.YGNodeStyleSetMaxHeight(_ygNode, value.Value);
				}
			}
		}

		public YogaValue MinWidth
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetMinWidth(_ygNode));
			}
			set
			{
				if (value.Unit == YogaUnit.Percent)
				{
					Native.YGNodeStyleSetMinWidthPercent(_ygNode, value.Value);
				}
				else
				{
					Native.YGNodeStyleSetMinWidth(_ygNode, value.Value);
				}
			}
		}

		public YogaValue MinHeight
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetMinHeight(_ygNode));
			}
			set
			{
				if (value.Unit == YogaUnit.Percent)
				{
					Native.YGNodeStyleSetMinHeightPercent(_ygNode, value.Value);
				}
				else
				{
					Native.YGNodeStyleSetMinHeight(_ygNode, value.Value);
				}
			}
		}

		public float AspectRatio
		{
			get
			{
				return Native.YGNodeStyleGetAspectRatio(_ygNode);
			}
			set
			{
				Native.YGNodeStyleSetAspectRatio(_ygNode, value);
			}
		}

		public float LayoutX => Native.YGNodeLayoutGetLeft(_ygNode);

		public float LayoutY => Native.YGNodeLayoutGetTop(_ygNode);

		public float LayoutRight => Native.YGNodeLayoutGetRight(_ygNode);

		public float LayoutBottom => Native.YGNodeLayoutGetBottom(_ygNode);

		public float LayoutWidth => Native.YGNodeLayoutGetWidth(_ygNode);

		public float LayoutHeight => Native.YGNodeLayoutGetHeight(_ygNode);

		public YogaDirection LayoutDirection => Native.YGNodeLayoutGetDirection(_ygNode);

		public YogaOverflow Overflow
		{
			get
			{
				return Native.YGNodeStyleGetOverflow(_ygNode);
			}
			set
			{
				Native.YGNodeStyleSetOverflow(_ygNode, value);
			}
		}

		public object Data
		{
			get
			{
				return _data;
			}
			set
			{
				_data = value;
			}
		}

		public YogaNode this[int index] => _children[index];

		public int Count => (_children != null) ? _children.Count : 0;

		public YogaValue Left
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetPosition(_ygNode, YogaEdge.Left));
			}
			set
			{
				SetStylePosition(YogaEdge.Left, value);
			}
		}

		public YogaValue Top
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetPosition(_ygNode, YogaEdge.Top));
			}
			set
			{
				SetStylePosition(YogaEdge.Top, value);
			}
		}

		public YogaValue Right
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetPosition(_ygNode, YogaEdge.Right));
			}
			set
			{
				SetStylePosition(YogaEdge.Right, value);
			}
		}

		public YogaValue Bottom
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetPosition(_ygNode, YogaEdge.Bottom));
			}
			set
			{
				SetStylePosition(YogaEdge.Bottom, value);
			}
		}

		public YogaValue Start
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetPosition(_ygNode, YogaEdge.Start));
			}
			set
			{
				SetStylePosition(YogaEdge.Start, value);
			}
		}

		public YogaValue End
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetPosition(_ygNode, YogaEdge.End));
			}
			set
			{
				SetStylePosition(YogaEdge.End, value);
			}
		}

		public YogaValue MarginLeft
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetMargin(_ygNode, YogaEdge.Left));
			}
			set
			{
				SetStyleMargin(YogaEdge.Left, value);
			}
		}

		public YogaValue MarginTop
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetMargin(_ygNode, YogaEdge.Top));
			}
			set
			{
				SetStyleMargin(YogaEdge.Top, value);
			}
		}

		public YogaValue MarginRight
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetMargin(_ygNode, YogaEdge.Right));
			}
			set
			{
				SetStyleMargin(YogaEdge.Right, value);
			}
		}

		public YogaValue MarginBottom
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetMargin(_ygNode, YogaEdge.Bottom));
			}
			set
			{
				SetStyleMargin(YogaEdge.Bottom, value);
			}
		}

		public YogaValue MarginStart
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetMargin(_ygNode, YogaEdge.Start));
			}
			set
			{
				SetStyleMargin(YogaEdge.Start, value);
			}
		}

		public YogaValue MarginEnd
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetMargin(_ygNode, YogaEdge.End));
			}
			set
			{
				SetStyleMargin(YogaEdge.End, value);
			}
		}

		public YogaValue MarginHorizontal
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetMargin(_ygNode, YogaEdge.Horizontal));
			}
			set
			{
				SetStyleMargin(YogaEdge.Horizontal, value);
			}
		}

		public YogaValue MarginVertical
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetMargin(_ygNode, YogaEdge.Vertical));
			}
			set
			{
				SetStyleMargin(YogaEdge.Vertical, value);
			}
		}

		public YogaValue Margin
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetMargin(_ygNode, YogaEdge.All));
			}
			set
			{
				SetStyleMargin(YogaEdge.All, value);
			}
		}

		public YogaValue PaddingLeft
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetPadding(_ygNode, YogaEdge.Left));
			}
			set
			{
				SetStylePadding(YogaEdge.Left, value);
			}
		}

		public YogaValue PaddingTop
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetPadding(_ygNode, YogaEdge.Top));
			}
			set
			{
				SetStylePadding(YogaEdge.Top, value);
			}
		}

		public YogaValue PaddingRight
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetPadding(_ygNode, YogaEdge.Right));
			}
			set
			{
				SetStylePadding(YogaEdge.Right, value);
			}
		}

		public YogaValue PaddingBottom
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetPadding(_ygNode, YogaEdge.Bottom));
			}
			set
			{
				SetStylePadding(YogaEdge.Bottom, value);
			}
		}

		public YogaValue PaddingStart
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetPadding(_ygNode, YogaEdge.Start));
			}
			set
			{
				SetStylePadding(YogaEdge.Start, value);
			}
		}

		public YogaValue PaddingEnd
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetPadding(_ygNode, YogaEdge.End));
			}
			set
			{
				SetStylePadding(YogaEdge.End, value);
			}
		}

		public YogaValue PaddingHorizontal
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetPadding(_ygNode, YogaEdge.Horizontal));
			}
			set
			{
				SetStylePadding(YogaEdge.Horizontal, value);
			}
		}

		public YogaValue PaddingVertical
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetPadding(_ygNode, YogaEdge.Vertical));
			}
			set
			{
				SetStylePadding(YogaEdge.Vertical, value);
			}
		}

		public YogaValue Padding
		{
			get
			{
				return YogaValue.MarshalValue(Native.YGNodeStyleGetPadding(_ygNode, YogaEdge.All));
			}
			set
			{
				SetStylePadding(YogaEdge.All, value);
			}
		}

		public float BorderLeftWidth
		{
			get
			{
				return Native.YGNodeStyleGetBorder(_ygNode, YogaEdge.Left);
			}
			set
			{
				Native.YGNodeStyleSetBorder(_ygNode, YogaEdge.Left, value);
			}
		}

		public float BorderTopWidth
		{
			get
			{
				return Native.YGNodeStyleGetBorder(_ygNode, YogaEdge.Top);
			}
			set
			{
				Native.YGNodeStyleSetBorder(_ygNode, YogaEdge.Top, value);
			}
		}

		public float BorderRightWidth
		{
			get
			{
				return Native.YGNodeStyleGetBorder(_ygNode, YogaEdge.Right);
			}
			set
			{
				Native.YGNodeStyleSetBorder(_ygNode, YogaEdge.Right, value);
			}
		}

		public float BorderBottomWidth
		{
			get
			{
				return Native.YGNodeStyleGetBorder(_ygNode, YogaEdge.Bottom);
			}
			set
			{
				Native.YGNodeStyleSetBorder(_ygNode, YogaEdge.Bottom, value);
			}
		}

		public float BorderStartWidth
		{
			get
			{
				return Native.YGNodeStyleGetBorder(_ygNode, YogaEdge.Start);
			}
			set
			{
				Native.YGNodeStyleSetBorder(_ygNode, YogaEdge.Start, value);
			}
		}

		public float BorderEndWidth
		{
			get
			{
				return Native.YGNodeStyleGetBorder(_ygNode, YogaEdge.End);
			}
			set
			{
				Native.YGNodeStyleSetBorder(_ygNode, YogaEdge.End, value);
			}
		}

		public float BorderWidth
		{
			get
			{
				return Native.YGNodeStyleGetBorder(_ygNode, YogaEdge.All);
			}
			set
			{
				Native.YGNodeStyleSetBorder(_ygNode, YogaEdge.All, value);
			}
		}

		public float LayoutMarginLeft => Native.YGNodeLayoutGetMargin(_ygNode, YogaEdge.Left);

		public float LayoutMarginTop => Native.YGNodeLayoutGetMargin(_ygNode, YogaEdge.Top);

		public float LayoutMarginRight => Native.YGNodeLayoutGetMargin(_ygNode, YogaEdge.Right);

		public float LayoutMarginBottom => Native.YGNodeLayoutGetMargin(_ygNode, YogaEdge.Bottom);

		public float LayoutMarginStart => Native.YGNodeLayoutGetMargin(_ygNode, YogaEdge.Start);

		public float LayoutMarginEnd => Native.YGNodeLayoutGetMargin(_ygNode, YogaEdge.End);

		public float LayoutPaddingLeft => Native.YGNodeLayoutGetPadding(_ygNode, YogaEdge.Left);

		public float LayoutPaddingTop => Native.YGNodeLayoutGetPadding(_ygNode, YogaEdge.Top);

		public float LayoutPaddingRight => Native.YGNodeLayoutGetPadding(_ygNode, YogaEdge.Right);

		public float LayoutPaddingBottom => Native.YGNodeLayoutGetPadding(_ygNode, YogaEdge.Bottom);

		public float LayoutBorderLeft => Native.YGNodeLayoutGetBorder(_ygNode, YogaEdge.Left);

		public float LayoutBorderTop => Native.YGNodeLayoutGetBorder(_ygNode, YogaEdge.Top);

		public float LayoutBorderRight => Native.YGNodeLayoutGetBorder(_ygNode, YogaEdge.Right);

		public float LayoutBorderBottom => Native.YGNodeLayoutGetBorder(_ygNode, YogaEdge.Bottom);

		public float LayoutPaddingStart => Native.YGNodeLayoutGetPadding(_ygNode, YogaEdge.Start);

		public float LayoutPaddingEnd => Native.YGNodeLayoutGetPadding(_ygNode, YogaEdge.End);

		public float ComputedFlexBasis => Native.YGNodeGetComputedFlexBasis(_ygNode);

		public YogaNode(YogaConfig config = null)
		{
			_config = ((config == null) ? YogaConfig.Default : config);
			_ygNode = Native.YGNodeNewWithConfig(_config.Handle);
			if (_ygNode == IntPtr.Zero)
			{
				throw new InvalidOperationException("Failed to allocate native memory");
			}
		}

		public YogaNode(YogaNode srcNode)
			: this(srcNode._config)
		{
			CopyStyle(srcNode);
		}

		~YogaNode()
		{
			Native.YGNodeFree(_ygNode);
		}

		public void Reset()
		{
			_measureFunction = null;
			_baselineFunction = null;
			_data = null;
			Native.YGSetManagedObject(_ygNode, null);
			Native.YGNodeReset(_ygNode);
		}

		public virtual void MarkDirty()
		{
			Native.YGNodeMarkDirty(_ygNode);
		}

		public void MarkHasNewLayout()
		{
			Native.YGNodeSetHasNewLayout(_ygNode, hasNewLayout: true);
		}

		public void CopyStyle(YogaNode srcNode)
		{
			Native.YGNodeCopyStyle(_ygNode, srcNode._ygNode);
		}

		public void MarkLayoutSeen()
		{
			Native.YGNodeSetHasNewLayout(_ygNode, hasNewLayout: false);
		}

		public bool ValuesEqual(float f1, float f2)
		{
			if (float.IsNaN(f1) || float.IsNaN(f2))
			{
				return float.IsNaN(f1) && float.IsNaN(f2);
			}
			return Math.Abs(f2 - f1) < float.Epsilon;
		}

		public void Insert(int index, YogaNode node)
		{
			if (_children == null)
			{
				_children = new List<YogaNode>(4);
			}
			_children.Insert(index, node);
			node._parent = new WeakReference(this);
			Native.YGNodeInsertChild(_ygNode, node._ygNode, (uint)index);
		}

		public void RemoveAt(int index)
		{
			YogaNode yogaNode = _children[index];
			yogaNode._parent = null;
			_children.RemoveAt(index);
			Native.YGNodeRemoveChild(_ygNode, yogaNode._ygNode);
		}

		public void AddChild(YogaNode child)
		{
			Insert(Count, child);
		}

		public void RemoveChild(YogaNode child)
		{
			int num = IndexOf(child);
			if (num >= 0)
			{
				RemoveAt(num);
			}
		}

		public void Clear()
		{
			if (_children != null)
			{
				while (_children.Count > 0)
				{
					RemoveAt(_children.Count - 1);
				}
			}
		}

		public int IndexOf(YogaNode node)
		{
			return (_children != null) ? _children.IndexOf(node) : (-1);
		}

		public void SetMeasureFunction(MeasureFunction measureFunction)
		{
			_measureFunction = measureFunction;
			if (measureFunction == null)
			{
				if (!IsBaselineDefined)
				{
					Native.YGSetManagedObject(_ygNode, null);
				}
				Native.YGNodeRemoveMeasureFunc(_ygNode);
			}
			else
			{
				Native.YGSetManagedObject(_ygNode, this);
				Native.YGNodeSetMeasureFunc(_ygNode);
			}
		}

		public void SetBaselineFunction(BaselineFunction baselineFunction)
		{
			_baselineFunction = baselineFunction;
			if (baselineFunction == null)
			{
				if (!IsMeasureDefined)
				{
					Native.YGSetManagedObject(_ygNode, null);
				}
				Native.YGNodeRemoveBaselineFunc(_ygNode);
			}
			else
			{
				Native.YGSetManagedObject(_ygNode, this);
				Native.YGNodeSetBaselineFunc(_ygNode);
			}
		}

		public void CalculateLayout(float width = float.NaN, float height = float.NaN)
		{
			Native.YGNodeCalculateLayout(_ygNode, width, height, Native.YGNodeStyleGetDirection(_ygNode));
		}

		public static YogaSize MeasureInternal(YogaNode node, float width, YogaMeasureMode widthMode, float height, YogaMeasureMode heightMode)
		{
			if (node == null || node._measureFunction == null)
			{
				throw new InvalidOperationException("Measure function is not defined.");
			}
			return node._measureFunction(node, width, widthMode, height, heightMode);
		}

		public static float BaselineInternal(YogaNode node, float width, float height)
		{
			if (node == null || node._baselineFunction == null)
			{
				throw new InvalidOperationException("Baseline function is not defined.");
			}
			return node._baselineFunction(node, width, height);
		}

		public string Print(YogaPrintOptions options = YogaPrintOptions.Layout | YogaPrintOptions.Style | YogaPrintOptions.Children)
		{
			StringBuilder sb = new StringBuilder();
			Logger logger = _config.Logger;
			_config.Logger = delegate(YogaConfig config, YogaNode node, YogaLogLevel level, string message)
			{
				sb.Append(message);
			};
			Native.YGNodePrint(_ygNode, options);
			_config.Logger = logger;
			return sb.ToString();
		}

		public IEnumerator<YogaNode> GetEnumerator()
		{
			return (_children != null) ? ((IEnumerable<YogaNode>)_children).GetEnumerator() : Enumerable.Empty<YogaNode>().GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return (_children != null) ? ((IEnumerable<YogaNode>)_children).GetEnumerator() : Enumerable.Empty<YogaNode>().GetEnumerator();
		}

		public static int GetInstanceCount()
		{
			return Native.YGNodeGetInstanceCount();
		}

		private void SetStylePosition(YogaEdge edge, YogaValue value)
		{
			if (value.Unit == YogaUnit.Percent)
			{
				Native.YGNodeStyleSetPositionPercent(_ygNode, edge, value.Value);
			}
			else
			{
				Native.YGNodeStyleSetPosition(_ygNode, edge, value.Value);
			}
		}

		private void SetStyleMargin(YogaEdge edge, YogaValue value)
		{
			if (value.Unit == YogaUnit.Percent)
			{
				Native.YGNodeStyleSetMarginPercent(_ygNode, edge, value.Value);
			}
			else if (value.Unit == YogaUnit.Auto)
			{
				Native.YGNodeStyleSetMarginAuto(_ygNode, edge);
			}
			else
			{
				Native.YGNodeStyleSetMargin(_ygNode, edge, value.Value);
			}
		}

		private void SetStylePadding(YogaEdge edge, YogaValue value)
		{
			if (value.Unit == YogaUnit.Percent)
			{
				Native.YGNodeStyleSetPaddingPercent(_ygNode, edge, value.Value);
			}
			else
			{
				Native.YGNodeStyleSetPadding(_ygNode, edge, value.Value);
			}
		}
	}
	internal enum YogaNodeType
	{
		Default,
		Text
	}
	internal enum YogaOverflow
	{
		Visible,
		Hidden,
		Scroll
	}
	internal enum YogaPositionType
	{
		Relative,
		Absolute
	}
	[Flags]
	internal enum YogaPrintOptions
	{
		Layout = 1,
		Style = 2,
		Children = 4
	}
	internal struct YogaSize
	{
		public float width;

		public float height;
	}
	internal enum YogaUnit
	{
		Undefined,
		Point,
		Percent,
		Auto
	}
	internal struct YogaValue
	{
		private float value;

		private YogaUnit unit;

		public YogaUnit Unit => unit;

		public float Value => value;

		public static YogaValue Point(float value)
		{
			return new YogaValue
			{
				value = value,
				unit = ((!YogaConstants.IsUndefined(value)) ? YogaUnit.Point : YogaUnit.Undefined)
			};
		}

		public bool Equals(YogaValue other)
		{
			return Unit == other.Unit && (Value.Equals(other.Value) || Unit == YogaUnit.Undefined);
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			return obj is YogaValue && Equals((YogaValue)obj);
		}

		public override int GetHashCode()
		{
			return (Value.GetHashCode() * 397) ^ (int)Unit;
		}

		public static YogaValue Undefined()
		{
			return new YogaValue
			{
				value = float.NaN,
				unit = YogaUnit.Undefined
			};
		}

		public static YogaValue Auto()
		{
			return new YogaValue
			{
				value = float.NaN,
				unit = YogaUnit.Auto
			};
		}

		public static YogaValue Percent(float value)
		{
			return new YogaValue
			{
				value = value,
				unit = ((!YogaConstants.IsUndefined(value)) ? YogaUnit.Percent : YogaUnit.Undefined)
			};
		}

		public static implicit operator YogaValue(float pointValue)
		{
			return Point(pointValue);
		}

		internal static YogaValue MarshalValue(YogaValue value)
		{
			return value;
		}
	}
	internal static class YogaValueExtensions
	{
		public static YogaValue Percent(this float value)
		{
			return YogaValue.Percent(value);
		}

		public static YogaValue Pt(this float value)
		{
			return YogaValue.Point(value);
		}

		public static YogaValue Percent(this int value)
		{
			return YogaValue.Percent(value);
		}

		public static YogaValue Pt(this int value)
		{
			return YogaValue.Point(value);
		}
	}
	internal enum YogaWrap
	{
		NoWrap,
		Wrap,
		WrapReverse
	}
}
namespace UnityEngine.UIElements
{
	internal static class AlignmentUtils
	{
		internal static float RoundToPixelGrid(float v, float pixelsPerPoint, float offset = 0.02f)
		{
			return Mathf.Floor(v * pixelsPerPoint + 0.5f + offset) / pixelsPerPoint;
		}

		internal static float CeilToPixelGrid(float v, float pixelsPerPoint, float offset = -0.02f)
		{
			return Mathf.Ceil(v * pixelsPerPoint + offset) / pixelsPerPoint;
		}

		internal static float FloorToPixelGrid(float v, float pixelsPerPoint, float offset = 0.02f)
		{
			return Mathf.Floor(v * pixelsPerPoint + offset) / pixelsPerPoint;
		}

		internal static float RoundToPanelPixelSize(this VisualElement ve, float v)
		{
			return RoundToPixelGrid(v, ve.scaledPixelsPerPoint);
		}
	}
	internal abstract class AtlasBase
	{
		internal TextureRegistry textureRegistry = TextureRegistry.instance;

		public virtual bool TryGetAtlas(VisualElement ctx, Texture2D src, out TextureId atlas, out RectInt atlasRect)
		{
			atlas = TextureId.invalid;
			atlasRect = default(RectInt);
			return false;
		}

		public virtual void ReturnAtlas(VisualElement ctx, Texture2D src, TextureId atlas)
		{
		}

		public virtual void Reset()
		{
		}

		protected virtual void OnAssignedToPanel(IPanel panel)
		{
		}

		protected virtual void OnRemovedFromPanel(IPanel panel)
		{
		}

		protected virtual void OnUpdateDynamicTextures(IPanel panel)
		{
		}

		internal void InvokeAssignedToPanel(IPanel panel)
		{
			OnAssignedToPanel(panel);
		}

		internal void InvokeRemovedFromPanel(IPanel panel)
		{
			OnRemovedFromPanel(panel);
		}

		internal void InvokeUpdateDynamicTextures(IPanel panel)
		{
			OnUpdateDynamicTextures(panel);
		}

		protected static void RepaintTexturedElements(IPanel panel)
		{
			if (((panel is Panel panel2) ? panel2.GetUpdater(VisualTreeUpdatePhase.Repaint) : null) is UIRRepaintUpdater uIRRepaintUpdater)
			{
				uIRRepaintUpdater.renderChain?.RepaintTexturedElements();
			}
		}

		protected TextureId AllocateDynamicTexture()
		{
			return textureRegistry.AllocAndAcquireDynamic();
		}

		protected void FreeDynamicTexture(TextureId id)
		{
			textureRegistry.Release(id);
		}

		protected void SetDynamicTexture(TextureId id, Texture texture)
		{
			textureRegistry.UpdateDynamic(id, texture);
		}
	}
	[Flags]
	public enum DynamicAtlasFilters
	{
		None = 0,
		Readability = 1,
		Size = 2,
		Format = 4,
		ColorSpace = 8,
		FilterMode = 0x10
	}
	public delegate bool DynamicAtlasCustomFilter(Texture2D texture, ref DynamicAtlasFilters filtersToApply);
	internal class DynamicAtlas : AtlasBase
	{
		private class TextureInfo : LinkedPoolItem<TextureInfo>
		{
			public DynamicAtlasPage page;

			public int counter;

			public Allocator2D.Alloc2D alloc;

			public RectInt rect;

			public static readonly UnityEngine.UIElements.UIR.LinkedPool<TextureInfo> pool = new UnityEngine.UIElements.UIR.LinkedPool<TextureInfo>(Create, Reset, 1024);

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			private static TextureInfo Create()
			{
				return new TextureInfo();
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			private static void Reset(TextureInfo info)
			{
				info.page = null;
				info.counter = 0;
				info.alloc = default(Allocator2D.Alloc2D);
				info.rect = default(RectInt);
			}
		}

		private Dictionary<Texture, TextureInfo> m_Database = new Dictionary<Texture, TextureInfo>();

		private DynamicAtlasPage m_PointPage;

		private DynamicAtlasPage m_BilinearPage;

		private ColorSpace m_ColorSpace;

		private List<IPanel> m_Panels = new List<IPanel>(1);

		private int m_MinAtlasSize = 64;

		private int m_MaxAtlasSize = 4096;

		private int m_MaxSubTextureSize = 64;

		private DynamicAtlasFilters m_ActiveFilters = defaultFilters;

		private DynamicAtlasCustomFilter m_CustomFilter;

		internal bool isInitialized => m_PointPage != null || m_BilinearPage != null;

		public int minAtlasSize
		{
			get
			{
				return m_MinAtlasSize;
			}
			set
			{
				if (m_MinAtlasSize != value)
				{
					m_MinAtlasSize = value;
					Reset();
				}
			}
		}

		public int maxAtlasSize
		{
			get
			{
				return m_MaxAtlasSize;
			}
			set
			{
				if (m_MaxAtlasSize != value)
				{
					m_MaxAtlasSize = value;
					Reset();
				}
			}
		}

		public static DynamicAtlasFilters defaultFilters => DynamicAtlasFilters.Readability | DynamicAtlasFilters.Size | DynamicAtlasFilters.Format | DynamicAtlasFilters.ColorSpace | DynamicAtlasFilters.FilterMode;

		public DynamicAtlasFilters activeFilters
		{
			get
			{
				return m_ActiveFilters;
			}
			set
			{
				if (m_ActiveFilters != value)
				{
					m_ActiveFilters = value;
					Reset();
				}
			}
		}

		public int maxSubTextureSize
		{
			get
			{
				return m_MaxSubTextureSize;
			}
			set
			{
				if (m_MaxSubTextureSize != value)
				{
					m_MaxSubTextureSize = value;
					Reset();
				}
			}
		}

		public DynamicAtlasCustomFilter customFilter
		{
			get
			{
				return m_CustomFilter;
			}
			set
			{
				if (m_CustomFilter != value)
				{
					m_CustomFilter = value;
					Reset();
				}
			}
		}

		protected override void OnAssignedToPanel(IPanel panel)
		{
			base.OnAssignedToPanel(panel);
			m_Panels.Add(panel);
			if (m_Panels.Count == 1)
			{
				m_ColorSpace = QualitySettings.activeColorSpace;
			}
		}

		protected override void OnRemovedFromPanel(IPanel panel)
		{
			m_Panels.Remove(panel);
			if (m_Panels.Count == 0 && isInitialized)
			{
				DestroyPages();
			}
			base.OnRemovedFromPanel(panel);
		}

		public override void Reset()
		{
			if (isInitialized)
			{
				DestroyPages();
				int i = 0;
				for (int count = m_Panels.Count; i < count; i++)
				{
					AtlasBase.RepaintTexturedElements(m_Panels[i]);
				}
			}
		}

		private void InitPages()
		{
			int value = Mathf.Max(m_MaxSubTextureSize, 1);
			value = Mathf.NextPowerOfTwo(value);
			int value2 = Mathf.Max(m_MaxAtlasSize, 1);
			value2 = Mathf.NextPowerOfTwo(value2);
			value2 = Mathf.Min(value2, SystemInfo.maxRenderTextureSize);
			int value3 = Mathf.Max(m_MinAtlasSize, 1);
			value3 = Mathf.NextPowerOfTwo(value3);
			value3 = Mathf.Min(value3, value2);
			Vector2Int minSize = new Vector2Int(value3, value3);
			Vector2Int maxSize = new Vector2Int(value2, value2);
			m_PointPage = new DynamicAtlasPage(RenderTextureFormat.ARGB32, FilterMode.Point, minSize, maxSize);
			m_BilinearPage = new DynamicAtlasPage(RenderTextureFormat.ARGB32, FilterMode.Bilinear, minSize, maxSize);
		}

		private void DestroyPages()
		{
			m_PointPage.Dispose();
			m_PointPage = null;
			m_BilinearPage.Dispose();
			m_BilinearPage = null;
			m_Database.Clear();
		}

		public override bool TryGetAtlas(VisualElement ve, Texture2D src, out TextureId atlas, out RectInt atlasRect)
		{
			if (m_Panels.Count == 0 || src == null)
			{
				atlas = TextureId.invalid;
				atlasRect = default(RectInt);
				return false;
			}
			if (!isInitialized)
			{
				InitPages();
			}
			if (m_Database.TryGetValue(src, out var value))
			{
				atlas = value.page.textureId;
				atlasRect = value.rect;
				value.counter++;
				return true;
			}
			if (IsTextureValid(src, FilterMode.Bilinear) && m_BilinearPage.TryAdd(src, out var alloc, out atlasRect))
			{
				value = TextureInfo.pool.Get();
				value.alloc = alloc;
				value.counter = 1;
				value.page = m_BilinearPage;
				value.rect = atlasRect;
				m_Database[src] = value;
				atlas = m_BilinearPage.textureId;
				return true;
			}
			if (IsTextureValid(src, FilterMode.Point) && m_PointPage.TryAdd(src, out alloc, out atlasRect))
			{
				value = TextureInfo.pool.Get();
				value.alloc = alloc;
				value.counter = 1;
				value.page = m_PointPage;
				value.rect = atlasRect;
				m_Database[src] = value;
				atlas = m_PointPage.textureId;
				return true;
			}
			atlas = TextureId.invalid;
			atlasRect = default(RectInt);
			return false;
		}

		public override void ReturnAtlas(VisualElement ve, Texture2D src, TextureId atlas)
		{
			if (m_Database.TryGetValue(src, out var value))
			{
				value.counter--;
				if (value.counter == 0)
				{
					value.page.Remove(value.alloc);
					m_Database.Remove(src);
					TextureInfo.pool.Return(value);
				}
			}
		}

		protected override void OnUpdateDynamicTextures(IPanel panel)
		{
			if (m_PointPage != null)
			{
				m_PointPage.Commit();
				SetDynamicTexture(m_PointPage.textureId, m_PointPage.atlas);
			}
			if (m_BilinearPage != null)
			{
				m_BilinearPage.Commit();
				SetDynamicTexture(m_BilinearPage.textureId, m_BilinearPage.atlas);
			}
		}

		internal static bool IsTextureFormatSupported(TextureFormat format)
		{
			switch (format)
			{
			case TextureFormat.Alpha8:
			case TextureFormat.ARGB4444:
			case TextureFormat.RGB24:
			case TextureFormat.RGBA32:
			case TextureFormat.ARGB32:
			case TextureFormat.RGB565:
			case TextureFormat.R16:
			case TextureFormat.DXT1:
			case TextureFormat.DXT5:
			case TextureFormat.RGBA4444:
			case TextureFormat.BGRA32:
			case TextureFormat.BC7:
			case TextureFormat.BC4:
			case TextureFormat.BC5:
			case TextureFormat.DXT1Crunched:
			case TextureFormat.DXT5Crunched:
			case TextureFormat.PVRTC_RGB2:
			case TextureFormat.PVRTC_RGBA2:
			case TextureFormat.PVRTC_RGB4:
			case TextureFormat.PVRTC_RGBA4:
			case TextureFormat.ETC_RGB4:
			case TextureFormat.EAC_R:
			case TextureFormat.EAC_R_SIGNED:
			case TextureFormat.EAC_RG:
			case TextureFormat.EAC_RG_SIGNED:
			case TextureFormat.ETC2_RGB:
			case TextureFormat.ETC2_RGBA1:
			case TextureFormat.ETC2_RGBA8:
			case TextureFormat.ASTC_4x4:
			case TextureFormat.ASTC_5x5:
			case TextureFormat.ASTC_6x6:
			case TextureFormat.ASTC_8x8:
			case TextureFormat.ASTC_10x10:
			case TextureFormat.ASTC_12x12:
			case TextureFormat.ASTC_RGBA_4x4:
			case TextureFormat.ASTC_RGBA_5x5:
			case TextureFormat.ASTC_RGBA_6x6:
			case TextureFormat.ASTC_RGBA_8x8:
			case TextureFormat.ASTC_RGBA_10x10:
			case TextureFormat.ASTC_RGBA_12x12:
			case TextureFormat.ETC_RGB4_3DS:
			case TextureFormat.ETC_RGBA8_3DS:
			case TextureFormat.RG16:
			case TextureFormat.R8:
			case TextureFormat.ETC_RGB4Crunched:
			case TextureFormat.ETC2_RGBA8Crunched:
				return true;
			case TextureFormat.RHalf:
			case TextureFormat.RGHalf:
			case TextureFormat.RGBAHalf:
			case TextureFormat.RFloat:
			case TextureFormat.RGFloat:
			case TextureFormat.RGBAFloat:
			case TextureFormat.YUY2:
			case TextureFormat.RGB9e5Float:
			case TextureFormat.BC6H:
			case TextureFormat.ASTC_HDR_4x4:
			case TextureFormat.ASTC_HDR_5x5:
			case TextureFormat.ASTC_HDR_6x6:
			case TextureFormat.ASTC_HDR_8x8:
			case TextureFormat.ASTC_HDR_10x10:
			case TextureFormat.ASTC_HDR_12x12:
			case TextureFormat.RG32:
			case TextureFormat.RGB48:
			case TextureFormat.RGBA64:
				return false;
			default:
				return false;
			}
		}

		public virtual bool IsTextureValid(Texture2D texture, FilterMode atlasFilterMode)
		{
			DynamicAtlasFilters filtersToApply = m_ActiveFilters;
			if (m_CustomFilter != null && !m_CustomFilter(texture, ref filtersToApply))
			{
				return false;
			}
			bool flag = (filtersToApply & DynamicAtlasFilters.Readability) != 0;
			bool flag2 = (filtersToApply & DynamicAtlasFilters.Size) != 0;
			bool flag3 = (filtersToApply & DynamicAtlasFilters.Format) != 0;
			bool flag4 = (filtersToApply & DynamicAtlasFilters.ColorSpace) != 0;
			bool flag5 = (filtersToApply & DynamicAtlasFilters.FilterMode) != 0;
			if (flag && texture.isReadable)
			{
				return false;
			}
			if (flag2 && (texture.width > maxSubTextureSize || texture.height > maxSubTextureSize))
			{
				return false;
			}
			if (flag3 && !IsTextureFormatSupported(texture.format))
			{
				return false;
			}
			if (flag4 && m_ColorSpace == ColorSpace.Linear && texture.activeTextureColorSpace != ColorSpace.Gamma)
			{
				return false;
			}
			if (flag5 && texture.filterMode != atlasFilterMode)
			{
				return false;
			}
			return true;
		}

		public void SetDirty(Texture2D tex)
		{
			if (!(tex == null) && m_Database.TryGetValue(tex, out var value))
			{
				value.page.Update(tex, value.rect);
			}
		}
	}
	public struct BackgroundPosition : IEquatable<BackgroundPosition>
	{
		public BackgroundPositionKeyword keyword;

		public Length offset;

		public BackgroundPosition(BackgroundPositionKeyword keyword)
		{
			this.keyword = keyword;
			offset = new Length(0f);
		}

		public BackgroundPosition(BackgroundPositionKeyword keyword, Length offset)
		{
			this.keyword = keyword;
			this.offset = offset;
		}

		internal static BackgroundPosition Initial()
		{
			return BackgroundPropertyHelper.ConvertScaleModeToBackgroundPosition();
		}

		public override bool Equals(object obj)
		{
			return obj is BackgroundPosition && Equals((BackgroundPosition)obj);
		}

		public bool Equals(BackgroundPosition other)
		{
			return other.offset == offset && other.keyword == keyword;
		}

		public override int GetHashCode()
		{
			int num = 1500536833;
			num = num * -1521134295 + keyword.GetHashCode();
			return num * -1521134295 + offset.GetHashCode();
		}

		public static bool operator ==(BackgroundPosition style1, BackgroundPosition style2)
		{
			return style1.Equals(style2);
		}

		public static bool operator !=(BackgroundPosition style1, BackgroundPosition style2)
		{
			return !(style1 == style2);
		}

		public override string ToString()
		{
			return $"(type:{keyword} x:{offset})";
		}
	}
	internal static class BackgroundPropertyHelper
	{
		public static BackgroundPosition ConvertScaleModeToBackgroundPosition(ScaleMode scaleMode = ScaleMode.StretchToFill)
		{
			return new BackgroundPosition(BackgroundPositionKeyword.Center);
		}

		public static BackgroundRepeat ConvertScaleModeToBackgroundRepeat(ScaleMode scaleMode = ScaleMode.StretchToFill)
		{
			return new BackgroundRepeat(Repeat.NoRepeat, Repeat.NoRepeat);
		}

		public static BackgroundSize ConvertScaleModeToBackgroundSize(ScaleMode scaleMode = ScaleMode.StretchToFill)
		{
			return scaleMode switch
			{
				ScaleMode.ScaleAndCrop => new BackgroundSize(BackgroundSizeType.Cover), 
				ScaleMode.ScaleToFit => new BackgroundSize(BackgroundSizeType.Contain), 
				_ => new BackgroundSize(Length.Percent(100f), Length.Percent(100f)), 
			};
		}

		public static ScaleMode ResolveUnityBackgroundScaleMode(BackgroundPosition backgroundPositionX, BackgroundPosition backgroundPositionY, BackgroundRepeat backgroundRepeat, BackgroundSize backgroundSize, out bool valid)
		{
			if (backgroundPositionX == ConvertScaleModeToBackgroundPosition(ScaleMode.ScaleAndCrop) && backgroundPositionY == ConvertScaleModeToBackgroundPosition(ScaleMode.ScaleAndCrop) && backgroundRepeat == ConvertScaleModeToBackgroundRepeat(ScaleMode.ScaleAndCrop) && backgroundSize == ConvertScaleModeToBackgroundSize(ScaleMode.ScaleAndCrop))
			{
				valid = true;
				return ScaleMode.ScaleAndCrop;
			}
			if (backgroundPositionX == ConvertScaleModeToBackgroundPosition(ScaleMode.ScaleToFit) && backgroundPositionY == ConvertScaleModeToBackgroundPosition(ScaleMode.ScaleToFit) && backgroundRepeat == ConvertScaleModeToBackgroundRepeat(ScaleMode.ScaleToFit) && backgroundSize == ConvertScaleModeToBackgroundSize(ScaleMode.ScaleToFit))
			{
				valid = true;
				return ScaleMode.ScaleToFit;
			}
			if (backgroundPositionX == ConvertScaleModeToBackgroundPosition() && backgroundPositionY == ConvertScaleModeToBackgroundPosition() && backgroundRepeat == ConvertScaleModeToBackgroundRepeat() && backgroundSize == ConvertScaleModeToBackgroundSize())
			{
				valid = true;
				return ScaleMode.StretchToFill;
			}
			valid = false;
			return ScaleMode.StretchToFill;
		}
	}
	public struct BackgroundRepeat : IEquatable<BackgroundRepeat>
	{
		public Repeat x;

		public Repeat y;

		public BackgroundRepeat(Repeat repeatX, Repeat repeatY)
		{
			x = repeatX;
			y = repeatY;
		}

		internal static BackgroundRepeat Initial()
		{
			return BackgroundPropertyHelper.ConvertScaleModeToBackgroundRepeat();
		}

		public override bool Equals(object obj)
		{
			return obj is BackgroundRepeat && Equals((BackgroundRepeat)obj);
		}

		public bool Equals(BackgroundRepeat other)
		{
			return other.x == x && other.y == y;
		}

		public override int GetHashCode()
		{
			int num = 1500536833;
			num = num * -1521134295 + x.GetHashCode();
			return num * -1521134295 + y.GetHashCode();
		}

		public static bool operator ==(BackgroundRepeat style1, BackgroundRepeat style2)
		{
			return style1.Equals(style2);
		}

		public static bool operator !=(BackgroundRepeat style1, BackgroundRepeat style2)
		{
			return !(style1 == style2);
		}

		public override string ToString()
		{
			return $"(x:{x}, y:{y})";
		}
	}
	public struct BackgroundSize : IEquatable<BackgroundSize>
	{
		private BackgroundSizeType m_SizeType;

		private Length m_X;

		private Length m_Y;

		public BackgroundSizeType sizeType
		{
			get
			{
				return m_SizeType;
			}
			set
			{
				m_SizeType = value;
				m_X = new Length(0f);
				m_Y = new Length(0f);
			}
		}

		public Length x
		{
			get
			{
				return m_X;
			}
			set
			{
				m_X = value;
				m_SizeType = BackgroundSizeType.Length;
			}
		}

		public Length y
		{
			get
			{
				return m_Y;
			}
			set
			{
				m_Y = value;
				m_SizeType = BackgroundSizeType.Length;
			}
		}

		public BackgroundSize(Length sizeX, Length sizeY)
		{
			m_SizeType = BackgroundSizeType.Length;
			m_X = sizeX;
			m_Y = sizeY;
		}

		public BackgroundSize(BackgroundSizeType sizeType)
		{
			m_SizeType = sizeType;
			m_X = new Length(0f);
			m_Y = new Length(0f);
		}

		internal static BackgroundSize Initial()
		{
			return BackgroundPropertyHelper.ConvertScaleModeToBackgroundSize();
		}

		public override bool Equals(object obj)
		{
			return obj is BackgroundSize && Equals((BackgroundSize)obj);
		}

		public bool Equals(BackgroundSize other)
		{
			return other.x == x && other.y == y && other.sizeType == sizeType;
		}

		public override int GetHashCode()
		{
			int num = 1500536833;
			num = num * -1521134295 + m_SizeType.GetHashCode();
			num = num * -1521134295 + m_X.GetHashCode();
			return num * -1521134295 + m_Y.GetHashCode();
		}

		public static bool operator ==(BackgroundSize style1, BackgroundSize style2)
		{
			return style1.Equals(style2);
		}

		public static bool operator !=(BackgroundSize style1, BackgroundSize style2)
		{
			return !(style1 == style2);
		}

		public override string ToString()
		{
			return $"(sizeType:{sizeType} x:{x}, y:{y})";
		}
	}
	public class BindableElement : VisualElement, IBindable
	{
		public new class UxmlFactory : UxmlFactory<BindableElement, UxmlTraits>
		{
		}

		public new class UxmlTraits : VisualElement.UxmlTraits
		{
			private UxmlStringAttributeDescription m_PropertyPath;

			public UxmlTraits()
			{
				m_PropertyPath = new UxmlStringAttributeDescription
				{
					name = "binding-path"
				};
			}

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				string valueFromBag = m_PropertyPath.GetValueFromBag(bag, cc);
				if (ve is IBindable bindable)
				{
					bindable.bindingPath = (string.IsNullOrEmpty(valueFromBag) ? string.Empty : valueFromBag);
				}
			}
		}

		public IBinding binding { get; set; }

		public string bindingPath { get; set; }
	}
	internal interface IBindingRequest
	{
		void Bind(VisualElement element);

		void Release();
	}
	internal class VisualTreeBindingsUpdater : BaseVisualTreeHierarchyTrackerUpdater
	{
		private class RequestObjectListPool : ObjectListPool<IBindingRequest>
		{
		}

		private static readonly PropertyName s_BindingRequestObjectVEPropertyName = "__unity-binding-request-object";

		private static readonly PropertyName s_AdditionalBindingObjectVEPropertyName = "__unity-additional-binding-object";

		private static readonly string s_Description = "Update Bindings";

		private static readonly ProfilerMarker s_ProfilerMarker = new ProfilerMarker(s_Description);

		private static readonly ProfilerMarker s_ProfilerBindingRequestsMarker = new ProfilerMarker("Bindings.Requests");

		private static ProfilerMarker s_MarkerUpdate = new ProfilerMarker("Bindings.Update");

		private static ProfilerMarker s_MarkerPoll = new ProfilerMarker("Bindings.PollElementsWithBindings");

		private readonly HashSet<VisualElement> m_ElementsWithBindings = new HashSet<VisualElement>();

		private readonly HashSet<VisualElement> m_ElementsToAdd = new HashSet<VisualElement>();

		private readonly HashSet<VisualElement> m_ElementsToRemove = new HashSet<VisualElement>();

		private const int k_MinUpdateDelayMs = 100;

		private const int k_MaxBindingTimeMs = 100;

		private long m_LastUpdateTime = 0L;

		private HashSet<VisualElement> m_ElementsToBind = new HashSet<VisualElement>();

		private List<IBinding> updatedBindings = new List<IBinding>();

		public override ProfilerMarker profilerMarker => s_ProfilerMarker;

		public static bool disableBindingsThrottling { get; set; } = false;

		public Dictionary<object, object> temporaryObjectCache { get; private set; } = new Dictionary<object, object>();

		private IBinding GetBindingObjectFromElement(VisualElement ve)
		{
			if (!(ve is IBindable { binding: not null, binding: var binding }))
			{
				return GetAdditionalBinding(ve);
			}
			return binding;
		}

		private void StartTracking(VisualElement ve)
		{
			m_ElementsToAdd.Add(ve);
			m_ElementsToRemove.Remove(ve);
		}

		private void StopTracking(VisualElement ve)
		{
			m_ElementsToRemove.Add(ve);
			m_ElementsToAdd.Remove(ve);
		}

		public static void SetAdditionalBinding(VisualElement ve, IBinding b)
		{
			GetAdditionalBinding(ve)?.Release();
			ve.SetProperty(s_AdditionalBindingObjectVEPropertyName, b);
			ve.IncrementVersion(VersionChangeType.Bindings);
		}

		public static void ClearAdditionalBinding(VisualElement ve)
		{
			SetAdditionalBinding(ve, null);
		}

		public static IBinding GetAdditionalBinding(VisualElement ve)
		{
			return ve.GetProperty(s_AdditionalBindingObjectVEPropertyName) as IBinding;
		}

		public static void AddBindingRequest(VisualElement ve, IBindingRequest req)
		{
			List<IBindingRequest> list = ve.GetProperty(s_BindingRequestObjectVEPropertyName) as List<IBindingRequest>;
			if (list == null)
			{
				list = ObjectListPool<IBindingRequest>.Get();
				ve.SetProperty(s_BindingRequestObjectVEPropertyName, list);
			}
			list.Add(req);
			ve.IncrementVersion(VersionChangeType.Bindings);
		}

		public static void RemoveBindingRequest(VisualElement ve, IBindingRequest req)
		{
			if (ve.GetProperty(s_BindingRequestObjectVEPropertyName) is List<IBindingRequest> list)
			{
				req.Release();
				list.Remove(req);
				if (list.Count == 0)
				{
					ObjectListPool<IBindingRequest>.Release(list);
					ve.SetProperty(s_BindingRequestObjectVEPropertyName, null);
				}
			}
		}

		public static void ClearBindingRequests(VisualElement ve)
		{
			if (!(ve.GetProperty(s_BindingRequestObjectVEPropertyName) is List<IBindingRequest> list))
			{
				return;
			}
			foreach (IBindingRequest item in list)
			{
				item.Release();
			}
			ObjectListPool<IBindingRequest>.Release(list);
			ve.SetProperty(s_BindingRequestObjectVEPropertyName, null);
		}

		private void StartTrackingRecursive(VisualElement ve)
		{
			IBinding bindingObjectFromElement = GetBindingObjectFromElement(ve);
			if (bindingObjectFromElement != null)
			{
				StartTracking(ve);
			}
			object property = ve.GetProperty(s_BindingRequestObjectVEPropertyName);
			if (property != null)
			{
				m_ElementsToBind.Add(ve);
			}
			int childCount = ve.hierarchy.childCount;
			for (int i = 0; i < childCount; i++)
			{
				VisualElement ve2 = ve.hierarchy[i];
				StartTrackingRecursive(ve2);
			}
		}

		private void StopTrackingRecursive(VisualElement ve)
		{
			StopTracking(ve);
			object property = ve.GetProperty(s_BindingRequestObjectVEPropertyName);
			if (property != null)
			{
				m_ElementsToBind.Remove(ve);
			}
			int childCount = ve.hierarchy.childCount;
			for (int i = 0; i < childCount; i++)
			{
				VisualElement ve2 = ve.hierarchy[i];
				StopTrackingRecursive(ve2);
			}
		}

		public override void OnVersionChanged(VisualElement ve, VersionChangeType versionChangeType)
		{
			base.OnVersionChanged(ve, versionChangeType);
			if ((versionChangeType & VersionChangeType.Bindings) == VersionChangeType.Bindings)
			{
				if (GetBindingObjectFromElement(ve) != null)
				{
					StartTracking(ve);
				}
				else
				{
					StopTracking(ve);
				}
				object property = ve.GetProperty(s_BindingRequestObjectVEPropertyName);
				if (property != null)
				{
					m_ElementsToBind.Add(ve);
				}
			}
		}

		protected override void OnHierarchyChange(VisualElement ve, HierarchyChangeType type)
		{
			switch (type)
			{
			case HierarchyChangeType.Add:
				StartTrackingRecursive(ve);
				break;
			case HierarchyChangeType.Remove:
				StopTrackingRecursive(ve);
				break;
			}
		}

		private static long CurrentTime()
		{
			return Panel.TimeSinceStartupMs();
		}

		public static bool ShouldThrottle(long startTime)
		{
			return !disableBindingsThrottling && CurrentTime() - startTime < 100;
		}

		public void PerformTrackingOperations()
		{
			foreach (VisualElement item in m_ElementsToAdd)
			{
				IBinding bindingObjectFromElement = GetBindingObjectFromElement(item);
				if (bindingObjectFromElement != null)
				{
					m_ElementsWithBindings.Add(item);
				}
			}
			m_ElementsToAdd.Clear();
			foreach (VisualElement item2 in m_ElementsToRemove)
			{
				m_ElementsWithBindings.Remove(item2);
			}
			m_ElementsToRemove.Clear();
		}

		public override void Update()
		{
			base.Update();
			if (m_ElementsToBind.Count > 0)
			{
				using (s_ProfilerBindingRequestsMarker.Auto())
				{
					long num = CurrentTime();
					while (m_ElementsToBind.Count > 0 && CurrentTime() - num < 100)
					{
						VisualElement visualElement = m_ElementsToBind.FirstOrDefault();
						if (visualElement == null)
						{
							break;
						}
						m_ElementsToBind.Remove(visualElement);
						if (!(visualElement.GetProperty(s_BindingRequestObjectVEPropertyName) is List<IBindingRequest> list))
						{
							continue;
						}
						visualElement.SetProperty(s_BindingRequestObjectVEPropertyName, null);
						foreach (IBindingRequest item in list)
						{
							item.Bind(visualElement);
						}
						ObjectListPool<IBindingRequest>.Release(list);
					}
				}
			}
			PerformTrackingOperations();
			if (m_ElementsWithBindings.Count > 0)
			{
				long num2 = CurrentTime();
				if (disableBindingsThrottling || m_LastUpdateTime + 100 < num2)
				{
					UpdateBindings();
					m_LastUpdateTime = num2;
				}
			}
			if (m_ElementsToBind.Count == 0)
			{
				temporaryObjectCache.Clear();
			}
		}

		private void UpdateBindings()
		{
			foreach (VisualElement elementsWithBinding in m_ElementsWithBindings)
			{
				IBinding bindingObjectFromElement = GetBindingObjectFromElement(elementsWithBinding);
				if (bindingObjectFromElement == null || elementsWithBinding.elementPanel != base.panel)
				{
					bindingObjectFromElement?.Release();
					StopTracking(elementsWithBinding);
				}
				else
				{
					updatedBindings.Add(bindingObjectFromElement);
				}
			}
			foreach (IBinding updatedBinding in updatedBindings)
			{
				updatedBinding.PreUpdate();
			}
			foreach (IBinding updatedBinding2 in updatedBindings)
			{
				updatedBinding2.Update();
			}
			updatedBindings.Clear();
		}

		internal void PollElementsWithBindings(Action<VisualElement, IBinding> callback)
		{
			PerformTrackingOperations();
			if (m_ElementsWithBindings.Count <= 0)
			{
				return;
			}
			foreach (VisualElement elementsWithBinding in m_ElementsWithBindings)
			{
				IBinding bindingObjectFromElement = GetBindingObjectFromElement(elementsWithBinding);
				if (bindingObjectFromElement == null || elementsWithBinding.elementPanel != base.panel)
				{
					bindingObjectFromElement?.Release();
					StopTracking(elementsWithBinding);
				}
				else
				{
					callback(elementsWithBinding, bindingObjectFromElement);
				}
			}
		}
	}
	internal class ClampedDragger<T> : Clickable where T : IComparable<T>
	{
		[Flags]
		public enum DragDirection
		{
			None = 0,
			LowToHigh = 1,
			HighToLow = 2,
			Free = 4
		}

		public DragDirection dragDirection { get; set; }

		private BaseSlider<T> slider { get; set; }

		public Vector2 startMousePosition { get; private set; }

		public Vector2 delta => base.lastMousePosition - startMousePosition;

		public event Action dragging;

		public event Action draggingEnded;

		public ClampedDragger(BaseSlider<T> slider, Action clickHandler, Action dragHandler)
			: base(clickHandler, 250L, 30L)
		{
			dragDirection = DragDirection.None;
			this.slider = slider;
			dragging += dragHandler;
		}

		protected override void ProcessDownEvent(EventBase evt, Vector2 localPosition, int pointerId)
		{
			startMousePosition = localPosition;
			dragDirection = DragDirection.None;
			base.ProcessDownEvent(evt, localPosition, pointerId);
			this.dragging?.Invoke();
		}

		protected override void ProcessUpEvent(EventBase evt, Vector2 localPosition, int pointerId)
		{
			base.ProcessUpEvent(evt, localPosition, pointerId);
			this.draggingEnded?.Invoke();
		}

		protected override void ProcessMoveEvent(EventBase evt, Vector2 localPosition)
		{
			base.ProcessMoveEvent(evt, localPosition);
			if (dragDirection == DragDirection.None)
			{
				dragDirection = DragDirection.Free;
			}
			if (dragDirection != DragDirection.Free)
			{
				return;
			}
			if (evt.eventTypeId == EventBase<PointerMoveEvent>.TypeId())
			{
				PointerMoveEvent pointerMoveEvent = (PointerMoveEvent)evt;
				if (pointerMoveEvent.pointerId != PointerId.mousePointerId)
				{
					pointerMoveEvent.isHandledByDraggable = true;
				}
			}
			this.dragging?.Invoke();
		}
	}
	public class Clickable : PointerManipulator
	{
		private readonly long m_Delay;

		private readonly long m_Interval;

		private int m_ActivePointerId = -1;

		private bool m_AcceptClicksIfDisabled;

		private IVisualElementScheduledItem m_Repeater;

		protected bool active { get; set; }

		public Vector2 lastMousePosition { get; private set; }

		internal bool acceptClicksIfDisabled
		{
			get
			{
				return m_AcceptClicksIfDisabled;
			}
			set
			{
				if (m_AcceptClicksIfDisabled != value)
				{
					UnregisterCallbacksFromTarget();
					m_AcceptClicksIfDisabled = value;
					RegisterCallbacksOnTarget();
				}
			}
		}

		private InvokePolicy invokePolicy => acceptClicksIfDisabled ? InvokePolicy.IncludeDisabled : InvokePolicy.Default;

		public event Action<EventBase> clickedWithEventInfo;

		public event Action clicked;

		public Clickable(Action handler, long delay, long interval)
			: this(handler)
		{
			m_Delay = delay;
			m_Interval = interval;
			active = false;
		}

		public Clickable(Action<EventBase> handler)
		{
			this.clickedWithEventInfo = handler;
			base.activators.Add(new ManipulatorActivationFilter
			{
				button = MouseButton.LeftMouse
			});
		}

		public Clickable(Action handler)
		{
			this.clicked = handler;
			base.activators.Add(new ManipulatorActivationFilter
			{
				button = MouseButton.LeftMouse
			});
			active = false;
		}

		private void OnTimer(TimerState timerState)
		{
			if ((this.clicked != null || this.clickedWithEventInfo != null) && IsRepeatable())
			{
				if (ContainsPointer(m_ActivePointerId) && (base.target.enabledInHierarchy || acceptClicksIfDisabled))
				{
					Invoke(null);
					base.target.pseudoStates |= PseudoStates.Active;
				}
				else
				{
					base.target.pseudoStates &= ~PseudoStates.Active;
				}
			}
		}

		private bool IsRepeatable()
		{
			return m_Delay > 0 || m_Interval > 0;
		}

		protected override void RegisterCallbacksOnTarget()
		{
			base.target.RegisterCallback<MouseDownEvent>(OnMouseDown, invokePolicy);
			base.target.RegisterCallback<MouseMoveEvent>(OnMouseMove, invokePolicy);
			base.target.RegisterCallback<MouseUpEvent>(OnMouseUp, InvokePolicy.IncludeDisabled);
			base.target.RegisterCallback<MouseCaptureOutEvent>(OnMouseCaptureOut, InvokePolicy.IncludeDisabled);
			base.target.RegisterCallback<PointerDownEvent>(OnPointerDown, invokePolicy);
			base.target.RegisterCallback<PointerMoveEvent>(OnPointerMove, invokePolicy);
			base.target.RegisterCallback<PointerUpEvent>(OnPointerUp, InvokePolicy.IncludeDisabled);
			base.target.RegisterCallback<PointerCancelEvent>(OnPointerCancel, InvokePolicy.IncludeDisabled);
			base.target.RegisterCallback<PointerCaptureOutEvent>(OnPointerCaptureOut, InvokePolicy.IncludeDisabled);
		}

		protected override void UnregisterCallbacksFromTarget()
		{
			base.target.UnregisterCallback<MouseDownEvent>(OnMouseDown);
			base.target.UnregisterCallback<MouseMoveEvent>(OnMouseMove);
			base.target.UnregisterCallback<MouseUpEvent>(OnMouseUp);
			base.target.UnregisterCallback<MouseCaptureOutEvent>(OnMouseCaptureOut);
			base.target.UnregisterCallback<PointerDownEvent>(OnPointerDown);
			base.target.UnregisterCallback<PointerMoveEvent>(OnPointerMove);
			base.target.UnregisterCallback<PointerUpEvent>(OnPointerUp);
			base.target.UnregisterCallback<PointerCancelEvent>(OnPointerCancel);
			base.target.UnregisterCallback<PointerCaptureOutEvent>(OnPointerCaptureOut);
		}

		protected void OnMouseDown(MouseDownEvent evt)
		{
			if (CanStartManipulation(evt))
			{
				ProcessDownEvent(evt, evt.localMousePosition, PointerId.mousePointerId);
			}
		}

		protected void OnMouseMove(MouseMoveEvent evt)
		{
			if (active)
			{
				ProcessMoveEvent(evt, evt.localMousePosition);
			}
		}

		protected void OnMouseUp(MouseUpEvent evt)
		{
			if (active && CanStopManipulation(evt))
			{
				ProcessUpEvent(evt, evt.localMousePosition, PointerId.mousePointerId);
			}
		}

		private void OnMouseCaptureOut(MouseCaptureOutEvent evt)
		{
			if (active)
			{
				ProcessCancelEvent(evt, PointerId.mousePointerId);
			}
		}

		private void OnPointerDown(PointerDownEvent evt)
		{
			if (CanStartManipulation(evt))
			{
				if (evt.pointerId != PointerId.mousePointerId)
				{
					ProcessDownEvent(evt, evt.localPosition, evt.pointerId);
					base.target.panel.PreventCompatibilityMouseEvents(evt.pointerId);
				}
				else
				{
					evt.StopImmediatePropagation();
				}
			}
		}

		private void OnPointerMove(PointerMoveEvent evt)
		{
			if (active)
			{
				if (evt.pointerId != PointerId.mousePointerId)
				{
					ProcessMoveEvent(evt, evt.localPosition);
					base.target.panel.PreventCompatibilityMouseEvents(evt.pointerId);
				}
				else
				{
					evt.StopPropagation();
				}
			}
		}

		private void OnPointerUp(PointerUpEvent evt)
		{
			if (active && CanStopManipulation(evt))
			{
				if (evt.pointerId != PointerId.mousePointerId)
				{
					ProcessUpEvent(evt, evt.localPosition, evt.pointerId);
					base.target.panel.PreventCompatibilityMouseEvents(evt.pointerId);
				}
				else
				{
					evt.StopPropagation();
				}
			}
		}

		private void OnPointerCancel(PointerCancelEvent evt)
		{
			if (active && CanStopManipulation(evt) && IsNotMouseEvent(evt.pointerId))
			{
				ProcessCancelEvent(evt, evt.pointerId);
			}
		}

		private void OnPointerCaptureOut(PointerCaptureOutEvent evt)
		{
			if (active && IsNotMouseEvent(evt.pointerId))
			{
				ProcessCancelEvent(evt, evt.pointerId);
			}
		}

		private bool ContainsPointer(int pointerId)
		{
			VisualElement topElementUnderPointer = base.target.elementPanel.GetTopElementUnderPointer(pointerId);
			return base.target == topElementUnderPointer || base.target.Contains(topElementUnderPointer);
		}

		private static bool IsNotMouseEvent(int pointerId)
		{
			return pointerId != PointerId.mousePointerId;
		}

		protected void Invoke(EventBase evt)
		{
			this.clicked?.Invoke();
			this.clickedWithEventInfo?.Invoke(evt);
		}

		internal void SimulateSingleClick(EventBase evt, int delayMs = 100)
		{
			base.target.pseudoStates |= PseudoStates.Active;
			base.target.schedule.Execute((Action)delegate
			{
				base.target.pseudoStates &= ~PseudoStates.Active;
			}).ExecuteLater(delayMs);
			Invoke(evt);
		}

		protected virtual void ProcessDownEvent(EventBase evt, Vector2 localPosition, int pointerId)
		{
			active = true;
			m_ActivePointerId = pointerId;
			base.target.CapturePointer(pointerId);
			if (!(evt is IPointerEvent))
			{
				base.target.panel.ProcessPointerCapture(pointerId);
			}
			lastMousePosition = localPosition;
			if (IsRepeatable())
			{
				if (ContainsPointer(pointerId) && (base.target.enabledInHierarchy || acceptClicksIfDisabled))
				{
					Invoke(evt);
				}
				if (m_Repeater == null)
				{
					m_Repeater = base.target.schedule.Execute(OnTimer).Every(m_Interval).StartingIn(m_Delay);
				}
				else
				{
					m_Repeater.ExecuteLater(m_Delay);
				}
			}
			base.target.pseudoStates |= PseudoStates.Active;
			evt.StopImmediatePropagation();
		}

		protected virtual void ProcessMoveEvent(EventBase evt, Vector2 localPosition)
		{
			lastMousePosition = localPosition;
			if (ContainsPointer(m_ActivePointerId))
			{
				base.target.pseudoStates |= PseudoStates.Active;
			}
			else
			{
				base.target.pseudoStates &= ~PseudoStates.Active;
			}
			evt.StopPropagation();
		}

		protected virtual void ProcessUpEvent(EventBase evt, Vector2 localPosition, int pointerId)
		{
			active = false;
			m_ActivePointerId = -1;
			base.target.ReleasePointer(pointerId);
			if (!(evt is IPointerEvent))
			{
				base.target.panel.ProcessPointerCapture(pointerId);
			}
			base.target.pseudoStates &= ~PseudoStates.Active;
			if (IsRepeatable())
			{
				m_Repeater?.Pause();
			}
			else if (ContainsPointer(pointerId) && (base.target.enabledInHierarchy || acceptClicksIfDisabled))
			{
				Invoke(evt);
			}
			evt.StopPropagation();
		}

		protected virtual void ProcessCancelEvent(EventBase evt, int pointerId)
		{
			active = false;
			m_ActivePointerId = -1;
			base.target.ReleasePointer(pointerId);
			if (!(evt is IPointerEvent))
			{
				base.target.panel.ProcessPointerCapture(pointerId);
			}
			base.target.pseudoStates &= ~PseudoStates.Active;
			if (IsRepeatable())
			{
				m_Repeater?.Pause();
			}
			evt.StopPropagation();
		}
	}
	internal class ClickDetector
	{
		private class ButtonClickStatus
		{
			public VisualElement m_Target;

			public Vector3 m_PointerDownPosition;

			public long m_LastPointerDownTime;

			public int m_ClickCount;

			public void Reset()
			{
				m_Target = null;
				m_ClickCount = 0;
				m_LastPointerDownTime = 0L;
				m_PointerDownPosition = Vector3.zero;
			}
		}

		private List<ButtonClickStatus> m_ClickStatus;

		internal static int s_DoubleClickTime { get; set; } = -1;

		public ClickDetector()
		{
			m_ClickStatus = new List<ButtonClickStatus>(PointerId.maxPointers);
			for (int i = 0; i < PointerId.maxPointers; i++)
			{
				m_ClickStatus.Add(new ButtonClickStatus());
			}
			if (s_DoubleClickTime == -1)
			{
				s_DoubleClickTime = Event.GetDoubleClickTime();
			}
		}

		private void StartClickTracking(EventBase evt)
		{
			if (evt is IPointerEvent pointerEvent)
			{
				ButtonClickStatus buttonClickStatus = m_ClickStatus[pointerEvent.pointerId];
				VisualElement visualElement = evt.target as VisualElement;
				if (visualElement != buttonClickStatus.m_Target)
				{
					buttonClickStatus.Reset();
				}
				buttonClickStatus.m_Target = visualElement;
				if (evt.timestamp - buttonClickStatus.m_LastPointerDownTime > s_DoubleClickTime)
				{
					buttonClickStatus.m_ClickCount = 1;
				}
				else
				{
					buttonClickStatus.m_ClickCount++;
				}
				buttonClickStatus.m_LastPointerDownTime = evt.timestamp;
				buttonClickStatus.m_PointerDownPosition = pointerEvent.position;
			}
		}

		private void SendClickEvent(EventBase evt)
		{
			if (!(evt is IPointerEvent pointerEvent))
			{
				return;
			}
			ButtonClickStatus buttonClickStatus = m_ClickStatus[pointerEvent.pointerId];
			if (!(evt.target is VisualElement element) || !ContainsPointer(element, pointerEvent.position) || buttonClickStatus.m_Target == null || buttonClickStatus.m_ClickCount <= 0)
			{
				return;
			}
			VisualElement visualElement = buttonClickStatus.m_Target.FindCommonAncestor(evt.target as VisualElement);
			if (visualElement == null)
			{
				return;
			}
			using ClickEvent clickEvent = ClickEvent.GetPooled(evt as PointerUpEvent, buttonClickStatus.m_ClickCount);
			clickEvent.target = visualElement;
			visualElement.SendEvent(clickEvent);
		}

		private void CancelClickTracking(EventBase evt)
		{
			if (evt is IPointerEvent pointerEvent)
			{
				ButtonClickStatus buttonClickStatus = m_ClickStatus[pointerEvent.pointerId];
				buttonClickStatus.Reset();
			}
		}

		public void ProcessEvent(EventBase evt)
		{
			if (!(evt is IPointerEvent pointerEvent))
			{
				return;
			}
			if (evt.eventTypeId == EventBase<PointerDownEvent>.TypeId() && pointerEvent.button == 0)
			{
				StartClickTracking(evt);
			}
			else if (evt.eventTypeId == EventBase<PointerMoveEvent>.TypeId())
			{
				if (pointerEvent.button == 0 && (pointerEvent.pressedButtons & 1) == 1)
				{
					StartClickTracking(evt);
					return;
				}
				if (pointerEvent.button == 0 && (pointerEvent.pressedButtons & 1) == 0)
				{
					SendClickEvent(evt);
					return;
				}
				ButtonClickStatus buttonClickStatus = m_ClickStatus[pointerEvent.pointerId];
				if (buttonClickStatus.m_Target != null)
				{
					buttonClickStatus.m_LastPointerDownTime = 0L;
				}
			}
			else if (evt.eventTypeId == EventBase<PointerCancelEvent>.TypeId())
			{
				CancelClickTracking(evt);
			}
			else if (evt.eventTypeId == EventBase<PointerUpEvent>.TypeId() && pointerEvent.button == 0)
			{
				SendClickEvent(evt);
			}
		}

		private static bool ContainsPointer(VisualElement element, Vector2 position)
		{
			if (!element.worldBound.Contains(position) || element.panel == null)
			{
				return false;
			}
			VisualElement visualElement = element.panel.Pick(position);
			return element == visualElement || element.Contains(visualElement);
		}

		internal void Cleanup(List<VisualElement> elements)
		{
			foreach (ButtonClickStatus item in m_ClickStatus)
			{
				if (item.m_Target != null && elements.Contains(item.m_Target))
				{
					item.Reset();
				}
			}
		}
	}
	public abstract class BaseListViewController : CollectionViewController
	{
		protected BaseListView baseListView => base.view as BaseListView;

		public event Action itemsSourceSizeChanged;

		public event Action<IEnumerable<int>> itemsAdded;

		public event Action<IEnumerable<int>> itemsRemoved;

		internal override void InvokeMakeItem(ReusableCollectionItem reusableItem)
		{
			if (reusableItem is ReusableListViewItem reusableListViewItem)
			{
				reusableListViewItem.Init(MakeItem(), baseListView.reorderable && baseListView.reorderMode == ListViewReorderMode.Animated);
				PostInitRegistration(reusableListViewItem);
			}
		}

		internal void PostInitRegistration(ReusableListViewItem listItem)
		{
			listItem.bindableElement.style.position = Position.Relative;
			listItem.bindableElement.style.flexBasis = StyleKeyword.Initial;
			listItem.bindableElement.style.marginTop = 0f;
			listItem.bindableElement.style.marginBottom = 0f;
			listItem.bindableElement.style.paddingTop = 0f;
			listItem.bindableElement.style.flexGrow = 0f;
			listItem.bindableElement.style.flexShrink = 0f;
		}

		internal override void InvokeBindItem(ReusableCollectionItem reusableItem, int index)
		{
			if (reusableItem is ReusableListViewItem reusableListViewItem)
			{
				bool flag = baseListView.reorderable && baseListView.reorderMode == ListViewReorderMode.Animated;
				reusableListViewItem.UpdateDragHandle(flag && NeedsDragHandle(index));
			}
			base.InvokeBindItem(reusableItem, index);
		}

		public virtual bool NeedsDragHandle(int index)
		{
			return true;
		}

		public virtual void AddItems(int itemCount)
		{
			if (itemCount <= 0)
			{
				return;
			}
			EnsureItemSourceCanBeResized();
			int count = itemsSource.Count;
			List<int> list = CollectionPool<List<int>, int>.Get();
			try
			{
				if (itemsSource.IsFixedSize)
				{
					itemsSource = AddToArray((Array)itemsSource, itemCount);
					for (int i = 0; i < itemCount; i++)
					{
						list.Add(count + i);
					}
				}
				else
				{
					Type type = itemsSource.GetType();
					Type type2 = type.GetInterfaces().FirstOrDefault(IsGenericList);
					if (type2 != null && type2.GetGenericArguments()[0].IsValueType)
					{
						Type type3 = type2.GetGenericArguments()[0];
						for (int j = 0; j < itemCount; j++)
						{
							list.Add(count + j);
							itemsSource.Add(Activator.CreateInstance(type3));
						}
					}
					else
					{
						for (int k = 0; k < itemCount; k++)
						{
							list.Add(count + k);
							itemsSource.Add(null);
						}
					}
				}
				RaiseItemsAdded(list);
			}
			finally
			{
				CollectionPool<List<int>, int>.Release(list);
			}
			RaiseOnSizeChanged();
			static bool IsGenericList(Type t)
			{
				return t.IsGenericType && t.GetGenericTypeDefinition() == typeof(IList<>);
			}
		}

		public virtual void Move(int index, int newIndex)
		{
			if (itemsSource == null || index == newIndex)
			{
				return;
			}
			int num = Mathf.Min(index, newIndex);
			int num2 = Mathf.Max(index, newIndex);
			if (num >= 0 && num2 < itemsSource.Count)
			{
				int dstIndex = newIndex;
				int num3 = ((newIndex < index) ? 1 : (-1));
				while (Mathf.Min(index, newIndex) < Mathf.Max(index, newIndex))
				{
					Swap(index, newIndex);
					newIndex += num3;
				}
				RaiseItemIndexChanged(index, dstIndex);
			}
		}

		public virtual void RemoveItem(int index)
		{
			List<int> value;
			using (CollectionPool<List<int>, int>.Get(out value))
			{
				value.Add(index);
				RemoveItems(value);
			}
		}

		public virtual void RemoveItems(List<int> indices)
		{
			EnsureItemSourceCanBeResized();
			if (indices == null)
			{
				return;
			}
			indices.Sort();
			RaiseItemsRemoved(indices);
			if (itemsSource.IsFixedSize)
			{
				itemsSource = RemoveFromArray((Array)itemsSource, indices);
			}
			else
			{
				for (int num = indices.Count - 1; num >= 0; num--)
				{
					itemsSource.RemoveAt(indices[num]);
				}
			}
			RaiseOnSizeChanged();
		}

		internal virtual void RemoveItems(int itemCount)
		{
			if (itemCount <= 0)
			{
				return;
			}
			int itemsCount = GetItemsCount();
			List<int> list = CollectionPool<List<int>, int>.Get();
			try
			{
				int num = itemsCount - itemCount;
				for (int i = num; i < itemsCount; i++)
				{
					list.Add(i);
				}
				RemoveItems(list);
			}
			finally
			{
				CollectionPool<List<int>, int>.Release(list);
			}
		}

		public virtual void ClearItems()
		{
			if (itemsSource != null)
			{
				EnsureItemSourceCanBeResized();
				IEnumerable<int> indices = Enumerable.Range(0, itemsSource.Count - 1);
				itemsSource.Clear();
				RaiseItemsRemoved(indices);
				RaiseOnSizeChanged();
			}
		}

		protected void RaiseOnSizeChanged()
		{
			this.itemsSourceSizeChanged?.Invoke();
		}

		protected void RaiseItemsAdded(IEnumerable<int> indices)
		{
			this.itemsAdded?.Invoke(indices);
		}

		protected void RaiseItemsRemoved(IEnumerable<int> indices)
		{
			this.itemsRemoved?.Invoke(indices);
		}

		private static Array AddToArray(Array source, int itemCount)
		{
			Type elementType = source.GetType().GetElementType();
			if (elementType == null)
			{
				throw new InvalidOperationException("Cannot resize source, because its size is fixed.");
			}
			Array array = Array.CreateInstance(elementType, source.Length + itemCount);
			Array.Copy(source, array, source.Length);
			return array;
		}

		private static Array RemoveFromArray(Array source, List<int> indicesToRemove)
		{
			int length = source.Length;
			int num = length - indicesToRemove.Count;
			if (num < 0)
			{
				throw new InvalidOperationException("Cannot remove more items than the current count from source.");
			}
			Type elementType = source.GetType().GetElementType();
			if (num == 0)
			{
				return Array.CreateInstance(elementType, 0);
			}
			Array array = Array.CreateInstance(elementType, num);
			int num2 = 0;
			int num3 = 0;
			for (int i = 0; i < source.Length; i++)
			{
				if (num3 < indicesToRemove.Count && indicesToRemove[num3] == i)
				{
					num3++;
					continue;
				}
				array.SetValue(source.GetValue(i), num2);
				num2++;
			}
			return array;
		}

		private void Swap(int lhs, int rhs)
		{
			IList list = itemsSource;
			IList list2 = itemsSource;
			object obj = itemsSource[rhs];
			object obj2 = itemsSource[lhs];
			object obj3 = (list[lhs] = obj);
			obj3 = (list2[rhs] = obj2);
		}

		private void EnsureItemSourceCanBeResized()
		{
			bool flag = (itemsSource?.GetType())?.IsArray ?? false;
			if (itemsSource == null || (itemsSource.IsFixedSize && !flag))
			{
				throw new InvalidOperationException("Cannot add or remove items from source, because it is null or its size is fixed.");
			}
		}
	}
	public abstract class BaseTreeViewController : CollectionViewController
	{
		private Dictionary<int, TreeItem> m_TreeItems = new Dictionary<int, TreeItem>();

		private List<int> m_RootIndices = new List<int>();

		private List<TreeViewItemWrapper> m_ItemWrappers = new List<TreeViewItemWrapper>();

		private HashSet<int> m_TreeItemIdsWithItemWrappers = new HashSet<int>();

		private List<TreeViewItemWrapper> m_WrapperInsertionList = new List<TreeViewItemWrapper>();

		private static readonly ProfilerMarker K_ExpandItemByIndex = new ProfilerMarker(ProfilerCategory.Scripts, "BaseTreeViewController.ExpandItemByIndex");

		private static readonly ProfilerMarker k_CreateWrappers = new ProfilerMarker("BaseTreeViewController.CreateWrappers");

		protected BaseTreeView baseTreeView => base.view as BaseTreeView;

		public override IList itemsSource
		{
			get
			{
				return base.itemsSource;
			}
			set
			{
				throw new InvalidOperationException("Can't set itemsSource directly. Override this controller to manage tree data.");
			}
		}

		public void RebuildTree()
		{
			m_TreeItems.Clear();
			m_RootIndices.Clear();
			foreach (int allItemId in GetAllItemIds())
			{
				int parentId = GetParentId(allItemId);
				if (parentId == -1)
				{
					m_RootIndices.Add(allItemId);
				}
				m_TreeItems.Add(allItemId, new TreeItem(allItemId, parentId, GetChildrenIds(allItemId)));
			}
			RegenerateWrappers();
		}

		public IEnumerable<int> GetRootItemIds()
		{
			return m_RootIndices;
		}

		public abstract IEnumerable<int> GetAllItemIds(IEnumerable<int> rootIds = null);

		public abstract int GetParentId(int id);

		public abstract IEnumerable<int> GetChildrenIds(int id);

		public abstract void Move(int id, int newParentId, int childIndex = -1, bool rebuildTree = true);

		public abstract bool TryRemoveItem(int id, bool rebuildTree = true);

		internal override void InvokeMakeItem(ReusableCollectionItem reusableItem)
		{
			if (reusableItem is ReusableTreeViewItem reusableTreeViewItem)
			{
				reusableTreeViewItem.Init(MakeItem());
				PostInitRegistration(reusableTreeViewItem);
			}
		}

		internal override void InvokeBindItem(ReusableCollectionItem reusableItem, int index)
		{
			if (reusableItem is ReusableTreeViewItem reusableTreeViewItem)
			{
				reusableTreeViewItem.Indent(GetIndentationDepthByIndex(index));
				reusableTreeViewItem.SetExpandedWithoutNotify(IsExpandedByIndex(index));
				reusableTreeViewItem.SetToggleVisibility(HasChildrenByIndex(index));
			}
			base.InvokeBindItem(reusableItem, index);
		}

		internal override void InvokeDestroyItem(ReusableCollectionItem reusableItem)
		{
			if (reusableItem is ReusableTreeViewItem reusableTreeViewItem)
			{
				reusableTreeViewItem.onPointerUp -= OnItemPointerUp;
				reusableTreeViewItem.onToggleValueChanged -= OnToggleValueChanged;
			}
			base.InvokeDestroyItem(reusableItem);
		}

		internal void PostInitRegistration(ReusableTreeViewItem treeItem)
		{
			treeItem.onPointerUp += OnItemPointerUp;
			treeItem.onToggleValueChanged += OnToggleValueChanged;
			if (baseTreeView.autoExpand)
			{
				baseTreeView.expandedItemIds.Remove(treeItem.id);
				baseTreeView.schedule.Execute((Action)delegate
				{
					ExpandItem(treeItem.id, expandAllChildren: true);
				});
			}
		}

		private void OnItemPointerUp(PointerUpEvent evt)
		{
			if ((evt.modifiers & EventModifiers.Alt) == 0)
			{
				return;
			}
			VisualElement e = evt.currentTarget as VisualElement;
			Toggle toggle = e.Q<Toggle>(BaseTreeView.itemToggleUssClassName);
			int index = ((ReusableTreeViewItem)toggle.userData).index;
			int idForIndex = GetIdForIndex(index);
			bool flag = IsExpandedByIndex(index);
			if (!HasChildrenByIndex(index))
			{
				return;
			}
			HashSet<int> hashSet = new HashSet<int>(baseTreeView.expandedItemIds);
			if (flag)
			{
				hashSet.Remove(idForIndex);
			}
			else
			{
				hashSet.Add(idForIndex);
			}
			IEnumerable<int> childrenIdsByIndex = GetChildrenIdsByIndex(index);
			foreach (int allItemId in GetAllItemIds(childrenIdsByIndex))
			{
				if (HasChildren(allItemId))
				{
					if (flag)
					{
						hashSet.Remove(allItemId);
					}
					else
					{
						hashSet.Add(allItemId);
					}
				}
			}
			baseTreeView.expandedItemIds = hashSet.ToList();
			RegenerateWrappers();
			baseTreeView.RefreshItems();
			evt.StopPropagation();
		}

		private void OnToggleValueChanged(ChangeEvent<bool> evt)
		{
			Toggle toggle = evt.target as Toggle;
			int index = ((ReusableTreeViewItem)toggle.userData).index;
			if (IsExpandedByIndex(index))
			{
				CollapseItemByIndex(index, collapseAllChildren: false);
			}
			else
			{
				ExpandItemByIndex(index, expandAllChildren: false);
			}
			baseTreeView.scrollView.contentContainer.Focus();
		}

		public virtual int GetTreeItemsCount()
		{
			return m_TreeItems.Count;
		}

		public override int GetIndexForId(int id)
		{
			if (m_TreeItemIdsWithItemWrappers.Contains(id))
			{
				for (int i = 0; i < m_ItemWrappers.Count; i++)
				{
					if (m_ItemWrappers[i].id == id)
					{
						return i;
					}
				}
			}
			return -1;
		}

		public override int GetIdForIndex(int index)
		{
			return IsIndexValid(index) ? m_ItemWrappers[index].id : (-1);
		}

		public virtual bool HasChildren(int id)
		{
			if (m_TreeItems.TryGetValue(id, out var value))
			{
				return value.hasChildren;
			}
			return false;
		}

		internal bool Exists(int id)
		{
			return m_TreeItems.ContainsKey(id);
		}

		public bool HasChildrenByIndex(int index)
		{
			return IsIndexValid(index) && m_ItemWrappers[index].hasChildren;
		}

		public IEnumerable<int> GetChildrenIdsByIndex(int index)
		{
			return IsIndexValid(index) ? m_ItemWrappers[index].childrenIds : null;
		}

		public int GetChildIndexForId(int id)
		{
			if (!m_TreeItems.TryGetValue(id, out var value))
			{
				return -1;
			}
			int num = 0;
			IEnumerable<int> enumerable;
			if (!m_TreeItems.TryGetValue(value.parentId, out var value2))
			{
				IEnumerable<int> rootIndices = m_RootIndices;
				enumerable = rootIndices;
			}
			else
			{
				enumerable = value2.childrenIds;
			}
			IEnumerable<int> enumerable2 = enumerable;
			foreach (int item in enumerable2)
			{
				if (item == id)
				{
					return num;
				}
				num++;
			}
			return -1;
		}

		internal int GetIndentationDepth(int id)
		{
			int num = 0;
			int parentId = GetParentId(id);
			while (parentId != -1)
			{
				parentId = GetParentId(parentId);
				num++;
			}
			return num;
		}

		internal int GetIndentationDepthByIndex(int index)
		{
			int idForIndex = GetIdForIndex(index);
			return GetIndentationDepth(idForIndex);
		}

		internal virtual bool CanChangeExpandedState(int id)
		{
			return true;
		}

		public bool IsExpanded(int id)
		{
			return baseTreeView.expandedItemIds.Contains(id);
		}

		public bool IsExpandedByIndex(int index)
		{
			if (!IsIndexValid(index))
			{
				return false;
			}
			return IsExpanded(m_ItemWrappers[index].id);
		}

		public void ExpandItemByIndex(int index, bool expandAllChildren, bool refresh = true)
		{
			using (K_ExpandItemByIndex.Auto())
			{
				if (!HasChildrenByIndex(index))
				{
					return;
				}
				int idForIndex = GetIdForIndex(index);
				if (!CanChangeExpandedState(idForIndex))
				{
					return;
				}
				if (!baseTreeView.expandedItemIds.Contains(idForIndex) || expandAllChildren)
				{
					IEnumerable<int> childrenIdsByIndex = GetChildrenIdsByIndex(index);
					List<int> list = new List<int>();
					foreach (int item in childrenIdsByIndex)
					{
						if (!m_TreeItemIdsWithItemWrappers.Contains(item))
						{
							list.Add(item);
						}
					}
					CreateWrappers(list, GetIndentationDepth(idForIndex) + 1, ref m_WrapperInsertionList);
					m_ItemWrappers.InsertRange(index + 1, m_WrapperInsertionList);
					if (!baseTreeView.expandedItemIds.Contains(m_ItemWrappers[index].id))
					{
						baseTreeView.expandedItemIds.Add(m_ItemWrappers[index].id);
					}
					m_WrapperInsertionList.Clear();
				}
				if (expandAllChildren)
				{
					IEnumerable<int> childrenIds = GetChildrenIds(idForIndex);
					foreach (int allItemId in GetAllItemIds(childrenIds))
					{
						if (!baseTreeView.expandedItemIds.Contains(allItemId))
						{
							ExpandItemByIndex(GetIndexForId(allItemId), expandAllChildren: true, refresh: false);
						}
					}
				}
				if (refresh)
				{
					baseTreeView.RefreshItems();
				}
			}
		}

		public void ExpandItem(int id, bool expandAllChildren, bool refresh = true)
		{
			if (!HasChildren(id) || !CanChangeExpandedState(id))
			{
				return;
			}
			for (int i = 0; i < m_ItemWrappers.Count; i++)
			{
				if (m_ItemWrappers[i].id == id && (expandAllChildren || !IsExpandedByIndex(i)))
				{
					ExpandItemByIndex(i, expandAllChildren, refresh);
					return;
				}
			}
			if (!baseTreeView.expandedItemIds.Contains(id))
			{
				baseTreeView.expandedItemIds.Add(id);
			}
		}

		public void CollapseItemByIndex(int index, bool collapseAllChildren)
		{
			if (!HasChildrenByIndex(index))
			{
				return;
			}
			int idForIndex = GetIdForIndex(index);
			if (!CanChangeExpandedState(idForIndex))
			{
				return;
			}
			if (collapseAllChildren)
			{
				IEnumerable<int> childrenIds = GetChildrenIds(idForIndex);
				foreach (int allItemId in GetAllItemIds(childrenIds))
				{
					baseTreeView.expandedItemIds.Remove(allItemId);
				}
			}
			baseTreeView.expandedItemIds.Remove(idForIndex);
			int num = 0;
			int i = index + 1;
			for (int indentationDepthByIndex = GetIndentationDepthByIndex(index); i < m_ItemWrappers.Count && GetIndentationDepthByIndex(i) > indentationDepthByIndex; i++)
			{
				num++;
			}
			int num2 = index + 1 + num;
			for (int j = index + 1; j < num2; j++)
			{
				m_TreeItemIdsWithItemWrappers.Remove(m_ItemWrappers[j].id);
			}
			m_ItemWrappers.RemoveRange(index + 1, num);
			baseTreeView.RefreshItems();
		}

		public void CollapseItem(int id, bool collapseAllChildren)
		{
			if (!CanChangeExpandedState(id))
			{
				return;
			}
			for (int i = 0; i < m_ItemWrappers.Count; i++)
			{
				if (m_ItemWrappers[i].id == id)
				{
					if (IsExpandedByIndex(i))
					{
						CollapseItemByIndex(i, collapseAllChildren);
						return;
					}
					break;
				}
			}
			if (baseTreeView.expandedItemIds.Contains(id))
			{
				baseTreeView.expandedItemIds.Remove(id);
			}
		}

		public void ExpandAll()
		{
			foreach (int allItemId in GetAllItemIds())
			{
				if (CanChangeExpandedState(allItemId) && !baseTreeView.expandedItemIds.Contains(allItemId))
				{
					baseTreeView.expandedItemIds.Add(allItemId);
				}
			}
			RegenerateWrappers();
			baseTreeView.RefreshItems();
		}

		public void CollapseAll()
		{
			if (baseTreeView.expandedItemIds.Count == 0)
			{
				return;
			}
			List<int> value;
			using (CollectionPool<List<int>, int>.Get(out value))
			{
				foreach (int expandedItemId in baseTreeView.expandedItemIds)
				{
					if (!CanChangeExpandedState(expandedItemId))
					{
						value.Add(expandedItemId);
					}
				}
				baseTreeView.expandedItemIds.Clear();
				baseTreeView.expandedItemIds.AddRange(value);
			}
			RegenerateWrappers();
			baseTreeView.RefreshItems();
		}

		internal void RegenerateWrappers()
		{
			m_ItemWrappers.Clear();
			m_TreeItemIdsWithItemWrappers.Clear();
			IEnumerable<int> rootItemIds = GetRootItemIds();
			if (rootItemIds != null)
			{
				CreateWrappers(rootItemIds, 0, ref m_ItemWrappers);
				SetItemsSourceWithoutNotify(m_ItemWrappers);
			}
		}

		private void CreateWrappers(IEnumerable<int> treeViewItemIds, int depth, ref List<TreeViewItemWrapper> wrappers)
		{
			using (k_CreateWrappers.Auto())
			{
				if (treeViewItemIds == null || wrappers == null || m_TreeItemIdsWithItemWrappers == null)
				{
					return;
				}
				foreach (int treeViewItemId in treeViewItemIds)
				{
					if (m_TreeItems.TryGetValue(treeViewItemId, out var value))
					{
						TreeViewItemWrapper item = new TreeViewItemWrapper(value, depth);
						wrappers.Add(item);
						m_TreeItemIdsWithItemWrappers.Add(treeViewItemId);
						if (baseTreeView?.expandedItemIds != null && baseTreeView.expandedItemIds.Contains(item.id) && item.hasChildren)
						{
							CreateWrappers(GetChildrenIds(item.id), depth + 1, ref wrappers);
						}
					}
				}
			}
		}

		private bool IsIndexValid(int index)
		{
			return index >= 0 && index < m_ItemWrappers.Count;
		}

		internal void RaiseItemParentChanged(int id, int newParentId)
		{
			RaiseItemIndexChanged(id, newParentId);
		}
	}
	public abstract class CollectionViewController : IDisposable
	{
		private BaseVerticalCollectionView m_View;

		private IList m_ItemsSource;

		public virtual IList itemsSource
		{
			get
			{
				return m_ItemsSource;
			}
			set
			{
				if (m_ItemsSource != value)
				{
					m_ItemsSource = value;
					if (m_View.GetProperty("__unity-collection-view-internal-binding") == null)
					{
						m_View.RefreshItems();
					}
					RaiseItemsSourceChanged();
				}
			}
		}

		protected BaseVerticalCollectionView view => m_View;

		public event Action itemsSourceChanged;

		public event Action<int, int> itemIndexChanged;

		protected void SetItemsSourceWithoutNotify(IList source)
		{
			m_ItemsSource = source;
		}

		public void SetView(BaseVerticalCollectionView collectionView)
		{
			m_View = collectionView;
			PrepareView();
			Assert.IsNotNull(m_View, "View must not be null.");
		}

		protected virtual void PrepareView()
		{
		}

		public virtual void Dispose()
		{
			this.itemsSourceChanged = null;
			this.itemIndexChanged = null;
			m_View = null;
		}

		public virtual int GetItemsCount()
		{
			return m_ItemsSource?.Count ?? 0;
		}

		internal virtual int GetItemsMinCount()
		{
			return GetItemsCount();
		}

		public virtual int GetIndexForId(int id)
		{
			return id;
		}

		public virtual int GetIdForIndex(int index)
		{
			return index;
		}

		public virtual object GetItemForIndex(int index)
		{
			if (m_ItemsSource == null)
			{
				return null;
			}
			if (index < 0 || index >= m_ItemsSource.Count)
			{
				return null;
			}
			return m_ItemsSource[index];
		}

		internal virtual object GetItemForId(int id)
		{
			if (m_ItemsSource == null)
			{
				return null;
			}
			int indexForId = GetIndexForId(id);
			if (indexForId < 0 || indexForId >= m_ItemsSource.Count)
			{
				return null;
			}
			return m_ItemsSource[indexForId];
		}

		internal virtual void InvokeMakeItem(ReusableCollectionItem reusableItem)
		{
			reusableItem.Init(MakeItem());
		}

		internal virtual void InvokeBindItem(ReusableCollectionItem reusableItem, int index)
		{
			BindItem(reusableItem.bindableElement, index);
			reusableItem.SetSelected(m_View.selectedIndices.Contains(index));
			reusableItem.rootElement.pseudoStates &= ~PseudoStates.Hover;
			reusableItem.index = index;
		}

		internal virtual void InvokeUnbindItem(ReusableCollectionItem reusableItem, int index)
		{
			UnbindItem(reusableItem.bindableElement, index);
			reusableItem.index = -1;
		}

		internal virtual void InvokeDestroyItem(ReusableCollectionItem reusableItem)
		{
			DestroyItem(reusableItem.bindableElement);
		}

		protected abstract VisualElement MakeItem();

		protected abstract void BindItem(VisualElement element, int index);

		protected abstract void UnbindItem(VisualElement element, int index);

		protected abstract void DestroyItem(VisualElement element);

		protected void RaiseItemsSourceChanged()
		{
			this.itemsSourceChanged?.Invoke();
		}

		protected void RaiseItemIndexChanged(int srcIndex, int dstIndex)
		{
			this.itemIndexChanged?.Invoke(srcIndex, dstIndex);
		}
	}
	internal class DefaultMultiColumnTreeViewController<T> : MultiColumnTreeViewController, IDefaultTreeViewController<T>
	{
		private TreeDataController<T> m_TreeDataController;

		private TreeDataController<T> treeDataController => m_TreeDataController ?? (m_TreeDataController = new TreeDataController<T>());

		public override IList itemsSource
		{
			get
			{
				return base.itemsSource;
			}
			set
			{
				if (value == null)
				{
					SetRootItems(null);
				}
				else if (value is IList<TreeViewItemData<T>> rootItems)
				{
					SetRootItems(rootItems);
				}
				else
				{
					Debug.LogError($"Type does not match this tree view controller's data type ({typeof(T)}).");
				}
			}
		}

		public DefaultMultiColumnTreeViewController(Columns columns, SortColumnDescriptions sortDescriptions, List<SortColumnDescription> sortedColumns)
			: base(columns, sortDescriptions, sortedColumns)
		{
		}

		public void SetRootItems(IList<TreeViewItemData<T>> items)
		{
			if (items != base.itemsSource)
			{
				treeDataController.SetRootItems(items);
				RebuildTree();
				RaiseItemsSourceChanged();
			}
		}

		public virtual void AddItem(in TreeViewItemData<T> item, int parentId, int childIndex, bool rebuildTree = true)
		{
			treeDataController.AddItem(in item, parentId, childIndex);
			if (rebuildTree)
			{
				RebuildTree();
			}
		}

		public virtual TreeViewItemData<T> GetTreeViewItemDataForId(int id)
		{
			return treeDataController.GetTreeItemDataForId(id);
		}

		public virtual TreeViewItemData<T> GetTreeViewItemDataForIndex(int index)
		{
			int idForIndex = GetIdForIndex(index);
			return treeDataController.GetTreeItemDataForId(idForIndex);
		}

		public override bool TryRemoveItem(int id, bool rebuildTree = true)
		{
			if (treeDataController.TryRemoveItem(id))
			{
				if (rebuildTree)
				{
					RebuildTree();
				}
				return true;
			}
			return false;
		}

		public T GetDataForId(int id)
		{
			return treeDataController.GetDataForId(id);
		}

		public T GetDataForIndex(int index)
		{
			return treeDataController.GetDataForId(GetIdForIndex(index));
		}

		public override object GetItemForIndex(int index)
		{
			return treeDataController.GetDataForId(GetIdForIndex(index));
		}

		public override int GetParentId(int id)
		{
			return treeDataController.GetParentId(id);
		}

		public override bool HasChildren(int id)
		{
			return treeDataController.HasChildren(id);
		}

		public override IEnumerable<int> GetChildrenIds(int id)
		{
			return treeDataController.GetChildrenIds(id);
		}

		public override void Move(int id, int newParentId, int childIndex = -1, bool rebuildTree = true)
		{
			if (id != newParentId && !IsChildOf(newParentId, id))
			{
				treeDataController.Move(id, newParentId, childIndex);
				if (rebuildTree)
				{
					RebuildTree();
					RaiseItemIndexChanged(id, newParentId);
				}
			}
		}

		private bool IsChildOf(int childId, int id)
		{
			return treeDataController.IsChildOf(childId, id);
		}

		public override IEnumerable<int> GetAllItemIds(IEnumerable<int> rootIds = null)
		{
			return treeDataController.GetAllItemIds(rootIds);
		}
	}
	internal class DefaultTreeViewController<T> : TreeViewController, IDefaultTreeViewController, IDefaultTreeViewController<T>
	{
		private TreeDataController<T> m_TreeDataController;

		private TreeDataController<T> treeDataController => m_TreeDataController ?? (m_TreeDataController = new TreeDataController<T>());

		public override IList itemsSource
		{
			get
			{
				return base.itemsSource;
			}
			set
			{
				if (value == null)
				{
					SetRootItems(null);
				}
				else if (value is IList<TreeViewItemData<T>> rootItems)
				{
					SetRootItems(rootItems);
				}
				else
				{
					Debug.LogError($"Type does not match this tree view controller's data type ({typeof(T)}).");
				}
			}
		}

		public void SetRootItems(IList<TreeViewItemData<T>> items)
		{
			if (items != base.itemsSource)
			{
				treeDataController.SetRootItems(items);
				RebuildTree();
				RaiseItemsSourceChanged();
			}
		}

		public virtual void AddItem(in TreeViewItemData<T> item, int parentId, int childIndex, bool rebuildTree = true)
		{
			treeDataController.AddItem(in item, parentId, childIndex);
			if (rebuildTree)
			{
				RebuildTree();
			}
		}

		public override bool TryRemoveItem(int id, bool rebuildTree = true)
		{
			if (treeDataController.TryRemoveItem(id))
			{
				if (rebuildTree)
				{
					RebuildTree();
				}
				return true;
			}
			return false;
		}

		public virtual object GetItemDataForId(int id)
		{
			return treeDataController.GetTreeItemDataForId(id).data;
		}

		public virtual TreeViewItemData<T> GetTreeViewItemDataForId(int id)
		{
			return treeDataController.GetTreeItemDataForId(id);
		}

		public virtual TreeViewItemData<T> GetTreeViewItemDataForIndex(int index)
		{
			int idForIndex = GetIdForIndex(index);
			return treeDataController.GetTreeItemDataForId(idForIndex);
		}

		public virtual T GetDataForId(int id)
		{
			return treeDataController.GetDataForId(id);
		}

		public virtual T GetDataForIndex(int index)
		{
			return treeDataController.GetDataForId(GetIdForIndex(index));
		}

		public override object GetItemForIndex(int index)
		{
			return treeDataController.GetDataForId(GetIdForIndex(index));
		}

		public override int GetParentId(int id)
		{
			return treeDataController.GetParentId(id);
		}

		public override bool HasChildren(int id)
		{
			return treeDataController.HasChildren(id);
		}

		public override IEnumerable<int> GetChildrenIds(int id)
		{
			return treeDataController.GetChildrenIds(id);
		}

		public override void Move(int id, int newParentId, int childIndex = -1, bool rebuildTree = true)
		{
			if (id != newParentId && !IsChildOf(newParentId, id))
			{
				treeDataController.Move(id, newParentId, childIndex);
				if (rebuildTree)
				{
					RebuildTree();
					RaiseItemParentChanged(id, newParentId);
				}
			}
		}

		private bool IsChildOf(int childId, int id)
		{
			return treeDataController.IsChildOf(childId, id);
		}

		public override IEnumerable<int> GetAllItemIds(IEnumerable<int> rootIds = null)
		{
			return treeDataController.GetAllItemIds(rootIds);
		}
	}
	internal interface IDefaultTreeViewController
	{
		object GetItemDataForId(int id);
	}
	internal interface IDefaultTreeViewController<T>
	{
		void SetRootItems(IList<TreeViewItemData<T>> items);

		void AddItem(in TreeViewItemData<T> item, int parentId, int childIndex, bool rebuildTree = true);

		TreeViewItemData<T> GetTreeViewItemDataForId(int id);

		TreeViewItemData<T> GetTreeViewItemDataForIndex(int index);

		T GetDataForId(int id);

		T GetDataForIndex(int index);
	}
	public class ListViewController : BaseListViewController
	{
		protected ListView listView => base.view as ListView;

		protected override VisualElement MakeItem()
		{
			if (listView.makeItem == null)
			{
				if (listView.bindItem != null)
				{
					throw new NotImplementedException("You must specify makeItem if bindItem is specified.");
				}
				return new Label();
			}
			return listView.makeItem();
		}

		protected override void BindItem(VisualElement element, int index)
		{
			if (listView.bindItem == null)
			{
				if (listView.makeItem != null)
				{
					throw new NotImplementedException("You must specify bindItem if makeItem is specified.");
				}
				Label label = (Label)element;
				label.text = listView.itemsSource[index]?.ToString() ?? "null";
			}
			else
			{
				listView.bindItem(element, index);
			}
		}

		protected override void UnbindItem(VisualElement element, int index)
		{
			listView.unbindItem?.Invoke(element, index);
		}

		protected override void DestroyItem(VisualElement element)
		{
			listView.destroyItem?.Invoke(element);
		}
	}
	public class MultiColumnListViewController : BaseListViewController
	{
		private MultiColumnController m_ColumnController;

		public MultiColumnController columnController => m_ColumnController;

		internal MultiColumnCollectionHeader header => m_ColumnController?.header;

		public MultiColumnListViewController(Columns columns, SortColumnDescriptions sortDescriptions, List<SortColumnDescription> sortedColumns)
		{
			m_ColumnController = new MultiColumnController(columns, sortDescriptions, sortedColumns);
		}

		internal override void InvokeMakeItem(ReusableCollectionItem reusableItem)
		{
			if (reusableItem is ReusableMultiColumnListViewItem reusableMultiColumnListViewItem)
			{
				reusableMultiColumnListViewItem.Init(MakeItem(), m_ColumnController.header.columns, base.baseListView.reorderMode == ListViewReorderMode.Animated);
				PostInitRegistration(reusableMultiColumnListViewItem);
			}
			else
			{
				base.InvokeMakeItem(reusableItem);
			}
		}

		protected override VisualElement MakeItem()
		{
			return m_ColumnController.MakeItem();
		}

		protected override void BindItem(VisualElement element, int index)
		{
			m_ColumnController.BindItem(element, index, GetItemForIndex(index));
		}

		protected override void UnbindItem(VisualElement element, int index)
		{
			m_ColumnController.UnbindItem(element, index);
		}

		protected override void DestroyItem(VisualElement element)
		{
			m_ColumnController.DestroyItem(element);
		}

		protected override void PrepareView()
		{
			m_ColumnController.PrepareView(base.view);
			base.baseListView.reorderModeChanged += UpdateReorderClassList;
		}

		public override void Dispose()
		{
			base.baseListView.reorderModeChanged -= UpdateReorderClassList;
			m_ColumnController.Dispose();
			m_ColumnController = null;
			base.Dispose();
		}

		private void UpdateReorderClassList()
		{
			m_ColumnController.header.EnableInClassList(MultiColumnCollectionHeader.reorderableUssClassName, base.baseListView.reorderable && base.baseListView.reorderMode == ListViewReorderMode.Animated);
		}
	}
	public abstract class MultiColumnTreeViewController : BaseTreeViewController
	{
		private MultiColumnController m_ColumnController;

		public MultiColumnController columnController => m_ColumnController;

		internal MultiColumnCollectionHeader header => m_ColumnController?.header;

		protected MultiColumnTreeViewController(Columns columns, SortColumnDescriptions sortDescriptions, List<SortColumnDescription> sortedColumns)
		{
			m_ColumnController = new MultiColumnController(columns, sortDescriptions, sortedColumns);
		}

		internal override void InvokeMakeItem(ReusableCollectionItem reusableItem)
		{
			if (reusableItem is ReusableMultiColumnTreeViewItem reusableMultiColumnTreeViewItem)
			{
				reusableMultiColumnTreeViewItem.Init(MakeItem(), m_ColumnController.header.columns);
				PostInitRegistration(reusableMultiColumnTreeViewItem);
			}
			else
			{
				base.InvokeMakeItem(reusableItem);
			}
		}

		protected override VisualElement MakeItem()
		{
			return m_ColumnController.MakeItem();
		}

		protected override void BindItem(VisualElement element, int index)
		{
			m_ColumnController.BindItem(element, index, GetItemForIndex(index));
		}

		protected override void UnbindItem(VisualElement element, int index)
		{
			m_ColumnController.UnbindItem(element, index);
		}

		protected override void DestroyItem(VisualElement element)
		{
			m_ColumnController.DestroyItem(element);
		}

		protected override void PrepareView()
		{
			m_ColumnController.PrepareView(base.view);
		}

		public override void Dispose()
		{
			m_ColumnController.Dispose();
			m_ColumnController = null;
			base.Dispose();
		}
	}
	internal sealed class TreeDataController<T>
	{
		private TreeData<T> m_TreeData;

		private Stack<IEnumerator<int>> m_IteratorStack = new Stack<IEnumerator<int>>();

		public void SetRootItems(IList<TreeViewItemData<T>> rootItems)
		{
			m_TreeData = new TreeData<T>(rootItems);
		}

		public void AddItem(in TreeViewItemData<T> item, int parentId, int childIndex)
		{
			m_TreeData.AddItem(item, parentId, childIndex);
		}

		public bool TryRemoveItem(int id)
		{
			return m_TreeData.TryRemove(id);
		}

		public TreeViewItemData<T> GetTreeItemDataForId(int id)
		{
			return m_TreeData.GetDataForId(id);
		}

		public T GetDataForId(int id)
		{
			return m_TreeData.GetDataForId(id).data;
		}

		public int GetParentId(int id)
		{
			return m_TreeData.GetParentId(id);
		}

		public bool HasChildren(int id)
		{
			return m_TreeData.GetDataForId(id).hasChildren;
		}

		private static IEnumerable<int> GetItemIds(IEnumerable<TreeViewItemData<T>> items)
		{
			if (items == null)
			{
				yield break;
			}
			foreach (TreeViewItemData<T> item2 in items)
			{
				yield return item2.id;
			}
		}

		public IEnumerable<int> GetChildrenIds(int id)
		{
			return GetItemIds(m_TreeData.GetDataForId(id).children);
		}

		public void Move(int id, int newParentId, int childIndex = -1)
		{
			if (id != newParentId && !IsChildOf(newParentId, id))
			{
				m_TreeData.Move(id, newParentId, childIndex);
			}
		}

		public bool IsChildOf(int childId, int id)
		{
			return m_TreeData.HasAncestor(childId, id);
		}

		public IEnumerable<int> GetAllItemIds(IEnumerable<int> rootIds = null)
		{
			m_IteratorStack.Clear();
			if (rootIds == null)
			{
				if (m_TreeData.rootItemIds == null)
				{
					yield break;
				}
				rootIds = m_TreeData.rootItemIds;
			}
			IEnumerator<int> currentIterator = rootIds.GetEnumerator();
			while (true)
			{
				if (!currentIterator.MoveNext())
				{
					if (m_IteratorStack.Count > 0)
					{
						currentIterator = m_IteratorStack.Pop();
						continue;
					}
					break;
				}
				int currentItemId = currentIterator.Current;
				yield return currentItemId;
				if (HasChildren(currentItemId))
				{
					m_IteratorStack.Push(currentIterator);
					currentIterator = GetChildrenIds(currentItemId).GetEnumerator();
				}
			}
		}
	}
	public abstract class TreeViewController : BaseTreeViewController
	{
		protected TreeView treeView => base.view as TreeView;

		protected override VisualElement MakeItem()
		{
			if (treeView.makeItem == null)
			{
				if (treeView.bindItem != null)
				{
					throw new NotImplementedException("You must specify makeItem if bindItem is specified.");
				}
				return new Label();
			}
			return treeView.makeItem();
		}

		protected override void BindItem(VisualElement element, int index)
		{
			if (treeView.bindItem == null)
			{
				if (treeView.makeItem != null)
				{
					throw new NotImplementedException("You must specify bindItem if makeItem is specified.");
				}
				Label label = (Label)element;
				label.text = GetItemForIndex(index)?.ToString() ?? "null";
			}
			else
			{
				treeView.bindItem(element, index);
			}
		}

		protected override void UnbindItem(VisualElement element, int index)
		{
			treeView.unbindItem?.Invoke(element, index);
		}

		protected override void DestroyItem(VisualElement element)
		{
			treeView.destroyItem?.Invoke(element);
		}

		internal override object GetItemForId(int id)
		{
			if (this is IDefaultTreeViewController defaultTreeViewController)
			{
				return defaultTreeViewController.GetItemDataForId(id);
			}
			return base.GetItemForId(id);
		}
	}
	internal abstract class CollectionVirtualizationController
	{
		protected readonly ScrollView m_ScrollView;

		public abstract int firstVisibleIndex { get; protected set; }

		public abstract int visibleItemCount { get; }

		public abstract IEnumerable<ReusableCollectionItem> activeItems { get; }

		protected CollectionVirtualizationController(ScrollView scrollView)
		{
			m_ScrollView = scrollView;
		}

		public abstract void Refresh(bool rebuild);

		public abstract void ScrollToItem(int id);

		public abstract void Resize(Vector2 size);

		public abstract void OnScroll(Vector2 offset);

		public abstract int GetIndexFromPosition(Vector2 position);

		public abstract float GetExpectedItemHeight(int index);

		public abstract float GetExpectedContentHeight();

		public abstract void OnFocus(VisualElement leafTarget);

		public abstract void OnBlur(VisualElement willFocus);

		public abstract void UpdateBackground();

		internal abstract void StartDragItem(ReusableCollectionItem item);

		internal abstract void EndDrag(int dropIndex);
	}
	internal class DynamicHeightVirtualizationController<T> : VerticalVirtualizationController<T> where T : ReusableCollectionItem, new()
	{
		private readonly struct ContentHeightCacheInfo
		{
			public readonly float sum;

			public readonly int count;

			public ContentHeightCacheInfo(float sum, int count)
			{
				this.sum = sum;
				this.count = count;
			}
		}

		private enum VirtualizationChange
		{
			None,
			Resize,
			Scroll,
			ForcedScroll
		}

		private enum ScrollDirection
		{
			Idle,
			Up,
			Down
		}

		private int m_HighestCachedIndex = -1;

		private readonly Dictionary<int, float> m_ItemHeightCache = new Dictionary<int, float>(32);

		private readonly Dictionary<int, ContentHeightCacheInfo> m_ContentHeightCache = new Dictionary<int, ContentHeightCacheInfo>(32);

		private readonly HashSet<int> m_WaitingCache = new HashSet<int>(32);

		private int m_ForcedFirstVisibleItem = -1;

		private int m_ForcedLastVisibleItem = -1;

		private bool m_StickToBottom;

		private VirtualizationChange m_LastChange;

		private ScrollDirection m_ScrollDirection;

		private Vector2 m_DelayedScrollOffset = Vector2.negativeInfinity;

		private float m_AccumulatedHeight;

		private float m_MinimumItemHeight = -1f;

		private Action m_FillCallback;

		private Action m_ScrollCallback;

		private Action m_ScrollResetCallback;

		private Action<ReusableCollectionItem> m_GeometryChangedCallback;

		private IVisualElementScheduledItem m_ScheduledItem;

		private IVisualElementScheduledItem m_ScrollScheduledItem;

		private IVisualElementScheduledItem m_ScrollResetScheduledItem;

		private Predicate<int> m_IndexOutOfBoundsPredicate;

		internal IReadOnlyDictionary<int, float> itemHeightCache => m_ItemHeightCache;

		private float defaultExpectedHeight
		{
			get
			{
				if (m_MinimumItemHeight > 0f)
				{
					return m_MinimumItemHeight;
				}
				if (m_CollectionView.m_ItemHeightIsInline && m_CollectionView.fixedItemHeight > 0f)
				{
					return m_CollectionView.fixedItemHeight;
				}
				return BaseVerticalCollectionView.s_DefaultItemHeight;
			}
		}

		private float contentPadding
		{
			get
			{
				return base.serializedData.contentPadding;
			}
			set
			{
				m_CollectionView.scrollView.contentContainer.style.paddingTop = value;
				base.serializedData.contentPadding = value;
				m_CollectionView.SaveViewData();
			}
		}

		private float contentHeight
		{
			get
			{
				return base.serializedData.contentHeight;
			}
			set
			{
				m_CollectionView.scrollView.contentContainer.style.height = value;
				base.serializedData.contentHeight = value;
				m_CollectionView.SaveViewData();
			}
		}

		private int anchoredIndex
		{
			get
			{
				return base.serializedData.anchoredItemIndex;
			}
			set
			{
				base.serializedData.anchoredItemIndex = value;
				m_CollectionView.SaveViewData();
			}
		}

		private float anchorOffset
		{
			get
			{
				return base.serializedData.anchorOffset;
			}
			set
			{
				base.serializedData.anchorOffset = value;
				m_CollectionView.SaveViewData();
			}
		}

		private float viewportMaxOffset => base.serializedData.scrollOffset.y + m_ScrollView.contentViewport.layout.height;

		protected override bool alwaysRebindOnRefresh => false;

		public DynamicHeightVirtualizationController(BaseVerticalCollectionView collectionView)
			: base(collectionView)
		{
			m_FillCallback = Fill;
			m_ScrollCallback = OnScrollUpdate;
			m_GeometryChangedCallback = OnRecycledItemGeometryChanged;
			m_IndexOutOfBoundsPredicate = IsIndexOutOfBounds;
			m_ScrollResetCallback = ResetScroll;
		}

		public override void Refresh(bool rebuild)
		{
			CleanItemHeightCache();
			int count = m_ActiveItems.Count;
			bool flag = false;
			if (rebuild)
			{
				m_WaitingCache.Clear();
			}
			else
			{
				flag |= m_WaitingCache.RemoveWhere(m_IndexOutOfBoundsPredicate) > 0;
			}
			base.Refresh(rebuild);
			m_ScrollDirection = ScrollDirection.Idle;
			m_LastChange = VirtualizationChange.None;
			if (m_CollectionView.HasValidDataAndBindings())
			{
				if (flag || count != m_ActiveItems.Count)
				{
					contentHeight = GetExpectedContentHeight();
					float highValueWithoutNotify = Mathf.Max(0f, contentHeight - m_ScrollView.contentViewport.layout.height);
					m_ScrollView.verticalScroller.slider.SetHighValueWithoutNotify(highValueWithoutNotify);
					m_ScrollView.verticalScroller.value = base.serializedData.scrollOffset.y;
					base.serializedData.scrollOffset.y = m_ScrollView.verticalScroller.value;
				}
				ScheduleFill();
			}
		}

		public override void ScrollToItem(int index)
		{
			if (index < -1)
			{
				return;
			}
			float height = m_ScrollView.contentContainer.layout.height;
			float height2 = m_ScrollView.contentViewport.layout.height;
			if (index == -1)
			{
				m_ForcedLastVisibleItem = base.itemsCount - 1;
				m_ForcedFirstVisibleItem = -1;
				m_StickToBottom = true;
				m_ScrollView.scrollOffset = new Vector2(0f, (height2 >= height) ? 0f : height);
				return;
			}
			if (firstVisibleIndex >= index)
			{
				m_ForcedFirstVisibleItem = index;
				m_ForcedLastVisibleItem = -1;
				m_ScrollView.scrollOffset = new Vector2(0f, GetContentHeightForIndex(index - 1));
				return;
			}
			float contentHeightForIndex = GetContentHeightForIndex(index);
			if (!(contentHeightForIndex < contentPadding + height2))
			{
				float y = contentHeightForIndex - height2 + (float)BaseVerticalCollectionView.s_DefaultItemHeight;
				m_ForcedLastVisibleItem = index;
				m_ForcedFirstVisibleItem = -1;
				m_ScrollView.scrollOffset = new Vector2(0f, y);
			}
		}

		public override void Resize(Vector2 size)
		{
			float expectedContentHeight = GetExpectedContentHeight();
			contentHeight = Mathf.Max(expectedContentHeight, contentHeight);
			float height = m_ScrollView.contentViewport.layout.height;
			float num = Mathf.Max(0f, contentHeight - height);
			float valueWithoutNotify = Mathf.Min(base.serializedData.scrollOffset.y, num);
			m_ScrollView.verticalScroller.slider.SetHighValueWithoutNotify(num);
			m_ScrollView.verticalScroller.slider.SetValueWithoutNotify(valueWithoutNotify);
			base.serializedData.scrollOffset.y = m_ScrollView.verticalScroller.value;
			float num2 = m_CollectionView.ResolveItemHeight(size.y);
			int num3 = Mathf.CeilToInt(num2 / defaultExpectedHeight);
			int num4 = num3;
			if (num4 <= 0)
			{
				return;
			}
			num4 += 2;
			int num5 = Mathf.Min(num4, base.itemsCount);
			if (m_ActiveItems.Count != num5)
			{
				int count = m_ActiveItems.Count;
				if (count > num5)
				{
					int num6 = count - num5;
					for (int i = 0; i < num6; i++)
					{
						int activeItemsIndex = m_ActiveItems.Count - 1;
						ReleaseItem(activeItemsIndex);
					}
				}
				else
				{
					int num7 = num5 - m_ActiveItems.Count;
					int num8 = ((firstVisibleIndex >= 0) ? firstVisibleIndex : 0);
					for (int j = 0; j < num7; j++)
					{
						int num9 = j + num8 + count;
						T orMakeItemAtIndex = GetOrMakeItemAtIndex();
						if (IsIndexOutOfBounds(num9))
						{
							HideItem(m_ActiveItems.Count - 1);
							continue;
						}
						Setup(orMakeItemAtIndex, num9);
						MarkWaitingForLayout(orMakeItemAtIndex);
					}
				}
			}
			ScheduleFill();
			ScheduleScrollDirectionReset();
			m_LastChange = VirtualizationChange.Resize;
		}

		public override void OnScroll(Vector2 scrollOffset)
		{
			if (m_DelayedScrollOffset == scrollOffset)
			{
				return;
			}
			m_DelayedScrollOffset = scrollOffset;
			if (m_ForcedFirstVisibleItem != -1 || m_ForcedLastVisibleItem != -1)
			{
				OnScrollUpdate();
				m_LastChange = VirtualizationChange.ForcedScroll;
				return;
			}
			if (m_ScheduledItem == null)
			{
				VirtualizationChange lastChange = m_LastChange;
				if (lastChange == VirtualizationChange.Resize || lastChange == VirtualizationChange.ForcedScroll)
				{
					m_ScheduledItem = m_CollectionView.schedule.Execute(m_FillCallback);
					float height = m_ScrollView.contentViewport.layout.height;
					float num = Mathf.Max(0f, contentHeight - height);
					float valueWithoutNotify = Mathf.Min(base.serializedData.scrollOffset.y, num);
					m_ScrollView.verticalScroller.slider.SetHighValueWithoutNotify(num);
					m_ScrollView.verticalScroller.slider.SetValueWithoutNotify(valueWithoutNotify);
					base.serializedData.scrollOffset.y = m_ScrollView.verticalScroller.value;
					return;
				}
			}
			ScheduleScroll();
		}

		private void OnScrollUpdate()
		{
			Vector2 scrollOffset = (float.IsNegativeInfinity(m_DelayedScrollOffset.y) ? base.serializedData.scrollOffset : m_DelayedScrollOffset);
			if (!float.IsNaN(m_ScrollView.contentViewport.layout.height) && !float.IsNaN(scrollOffset.y))
			{
				m_LastChange = VirtualizationChange.Scroll;
				float expectedContentHeight = GetExpectedContentHeight();
				contentHeight = Mathf.Max(expectedContentHeight, contentHeight);
				m_ScrollDirection = ((scrollOffset.y < base.serializedData.scrollOffset.y) ? ScrollDirection.Up : ScrollDirection.Down);
				float num = Mathf.Max(0f, contentHeight - m_ScrollView.contentViewport.layout.height);
				if (scrollOffset.y <= 0f)
				{
					m_ForcedFirstVisibleItem = 0;
				}
				m_StickToBottom = num > 0f && Math.Abs(scrollOffset.y - m_ScrollView.verticalScroller.highValue) < float.Epsilon;
				base.serializedData.scrollOffset = scrollOffset;
				m_CollectionView.SaveViewData();
				int num2 = ((m_ForcedFirstVisibleItem != -1) ? m_ForcedFirstVisibleItem : GetFirstVisibleItem(base.serializedData.scrollOffset.y));
				float contentHeightForIndex = GetContentHeightForIndex(num2 - 1);
				contentPadding = contentHeightForIndex;
				m_ForcedFirstVisibleItem = -1;
				if (num2 != firstVisibleIndex)
				{
					CycleItems(num2);
				}
				else
				{
					Fill();
				}
				ScheduleScrollDirectionReset();
				m_DelayedScrollOffset = Vector2.negativeInfinity;
			}
		}

		private void CycleItems(int firstIndex)
		{
			if (firstIndex == firstVisibleIndex)
			{
				return;
			}
			T val = base.firstVisibleItem;
			contentPadding = GetContentHeightForIndex(firstIndex - 1);
			firstVisibleIndex = firstIndex;
			if (m_ActiveItems.Count > 0)
			{
				if (val != null && m_ActiveItems.Count > Mathf.Abs(firstVisibleIndex - val.index))
				{
					if (firstVisibleIndex < val.index)
					{
						int num = val.index - firstVisibleIndex;
						List<T> scrollInsertionList = m_ScrollInsertionList;
						for (int i = 0; i < num; i++)
						{
							List<T> list = m_ActiveItems;
							T val2 = list[list.Count - 1];
							scrollInsertionList.Insert(0, val2);
							m_ActiveItems.RemoveAt(m_ActiveItems.Count - 1);
							val2.rootElement.SendToBack();
						}
						m_ActiveItems.InsertRange(0, scrollInsertionList);
						m_ScrollInsertionList.Clear();
					}
					else
					{
						List<T> scrollInsertionList2 = m_ScrollInsertionList;
						int num2 = 0;
						while (firstVisibleIndex > m_ActiveItems[num2].index)
						{
							T val3 = m_ActiveItems[num2];
							scrollInsertionList2.Add(val3);
							num2++;
							val3.rootElement.BringToFront();
						}
						m_ActiveItems.RemoveRange(0, num2);
						m_ActiveItems.AddRange(scrollInsertionList2);
						m_ScrollInsertionList.Clear();
					}
				}
				float num3 = contentPadding;
				for (int j = 0; j < m_ActiveItems.Count; j++)
				{
					T val4 = m_ActiveItems[j];
					int num4 = firstVisibleIndex + j;
					int index = val4.index;
					bool flag = val4.rootElement.style.display == DisplayStyle.Flex;
					m_WaitingCache.Remove(index);
					if (IsIndexOutOfBounds(num4))
					{
						HideItem(j);
						continue;
					}
					Setup(val4, num4);
					if (num3 > viewportMaxOffset)
					{
						HideItem(j);
					}
					else if (num4 != index || !flag)
					{
						MarkWaitingForLayout(val4);
					}
					num3 += GetExpectedItemHeight(num4);
				}
			}
			if (m_LastChange != VirtualizationChange.Resize)
			{
				UpdateAnchor();
			}
			ScheduleFill();
		}

		private bool NeedsFill()
		{
			if (m_LastChange != VirtualizationChange.None || anchoredIndex < 0)
			{
				return false;
			}
			int num = base.lastVisibleItem?.index ?? (-1);
			float num2 = contentPadding;
			if (num2 > base.serializedData.scrollOffset.y)
			{
				return true;
			}
			for (int i = firstVisibleIndex; i < base.itemsCount; i++)
			{
				if (num2 > viewportMaxOffset)
				{
					break;
				}
				if (num2 == viewportMaxOffset && !m_StickToBottom)
				{
					break;
				}
				num2 += GetExpectedItemHeight(i);
				if (i > num)
				{
					return true;
				}
			}
			return false;
		}

		private void Fill()
		{
			if (!m_CollectionView.HasValidDataAndBindings())
			{
				return;
			}
			if (m_ActiveItems.Count == 0)
			{
				contentHeight = 0f;
				contentPadding = 0f;
			}
			else
			{
				if (anchoredIndex < 0)
				{
					return;
				}
				if (contentPadding > contentHeight)
				{
					OnScrollUpdate();
					return;
				}
				float num = contentPadding;
				float num2 = contentPadding;
				int num3 = 0;
				for (int i = firstVisibleIndex; i < base.itemsCount; i++)
				{
					if (num2 > viewportMaxOffset)
					{
						break;
					}
					if (num2 == viewportMaxOffset && !m_StickToBottom)
					{
						break;
					}
					num2 += GetExpectedItemHeight(i);
					T val = m_ActiveItems[num3++];
					if (val.index != i || val.rootElement.style.display == DisplayStyle.None)
					{
						Setup(val, i);
						MarkWaitingForLayout(val);
					}
					if (num3 >= m_ActiveItems.Count)
					{
						break;
					}
				}
				if (firstVisibleIndex > 0 && contentPadding > base.serializedData.scrollOffset.y)
				{
					List<T> scrollInsertionList = m_ScrollInsertionList;
					int num4 = m_ActiveItems.Count - 1;
					while (num4 >= num3 && firstVisibleIndex != 0)
					{
						T val2 = m_ActiveItems[num4];
						scrollInsertionList.Insert(0, val2);
						m_ActiveItems.RemoveAt(m_ActiveItems.Count - 1);
						val2.rootElement.SendToBack();
						int num5 = --firstVisibleIndex;
						Setup(val2, num5);
						MarkWaitingForLayout(val2);
						num -= GetExpectedItemHeight(num5);
						if (num < base.serializedData.scrollOffset.y)
						{
							break;
						}
						num4--;
					}
					m_ActiveItems.InsertRange(0, scrollInsertionList);
					m_ScrollInsertionList.Clear();
				}
				contentPadding = num;
				contentHeight = GetExpectedContentHeight();
				if (m_LastChange != VirtualizationChange.Resize)
				{
					UpdateAnchor();
				}
				if (m_WaitingCache.Count == 0)
				{
					ResetScroll();
					ApplyScrollViewUpdate(dimensionsOnly: true);
				}
			}
		}

		private void UpdateScrollViewContainer(float previousHeight, float newHeight)
		{
			if (!m_StickToBottom)
			{
				if (m_ForcedLastVisibleItem >= 0)
				{
					float contentHeightForIndex = GetContentHeightForIndex(m_ForcedLastVisibleItem);
					base.serializedData.scrollOffset.y = contentHeightForIndex + (float)BaseVerticalCollectionView.s_DefaultItemHeight - m_ScrollView.contentViewport.layout.height;
				}
				else if (m_ScrollDirection == ScrollDirection.Up)
				{
					base.serializedData.scrollOffset.y += newHeight - previousHeight;
				}
			}
		}

		private void ApplyScrollViewUpdate(bool dimensionsOnly = false)
		{
			float num = contentPadding;
			float y = base.serializedData.scrollOffset.y;
			float num2 = y - num;
			if (anchoredIndex >= 0)
			{
				if (firstVisibleIndex != anchoredIndex)
				{
					CycleItems(anchoredIndex);
					ScheduleFill();
				}
				firstVisibleIndex = anchoredIndex;
				num2 = anchorOffset;
			}
			float num3 = (contentHeight = GetExpectedContentHeight());
			contentPadding = GetContentHeightForIndex(firstVisibleIndex - 1);
			float num4 = Mathf.Max(0f, m_ScrollView.RoundToPanelPixelSize(num3 - m_ScrollView.contentViewport.layout.height));
			float valueWithoutNotify = Mathf.Min(contentPadding + num2, num4);
			if (m_StickToBottom && num4 > 0f)
			{
				valueWithoutNotify = num4;
			}
			else if (m_ForcedLastVisibleItem != -1)
			{
				float contentHeightForIndex = GetContentHeightForIndex(m_ForcedLastVisibleItem);
				float num5 = contentHeightForIndex + (float)BaseVerticalCollectionView.s_DefaultItemHeight - m_ScrollView.contentViewport.layout.height;
				valueWithoutNotify = num5;
			}
			m_ScrollView.verticalScroller.slider.SetHighValueWithoutNotify(num4);
			m_ScrollView.verticalScroller.slider.SetValueWithoutNotify(valueWithoutNotify);
			base.serializedData.scrollOffset.y = m_ScrollView.verticalScroller.slider.value;
			if (dimensionsOnly || m_LastChange == VirtualizationChange.Resize)
			{
				ScheduleScrollDirectionReset();
				return;
			}
			if (NeedsFill())
			{
				Fill();
				return;
			}
			float num6 = contentPadding;
			int num7 = firstVisibleIndex;
			List<T> scrollInsertionList = m_ScrollInsertionList;
			int num8 = 0;
			for (int i = 0; i < m_ActiveItems.Count; i++)
			{
				T val = m_ActiveItems[i];
				int index = val.index;
				if (index < 0)
				{
					break;
				}
				float expectedItemHeight = GetExpectedItemHeight(index);
				if (m_ActiveItems[i].rootElement.style.display == DisplayStyle.Flex)
				{
					if (num6 + expectedItemHeight <= base.serializedData.scrollOffset.y)
					{
						val.rootElement.BringToFront();
						HideItem(i);
						scrollInsertionList.Add(val);
						num8++;
						firstVisibleIndex++;
					}
					else if (num6 > viewportMaxOffset)
					{
						HideItem(i);
					}
				}
				num6 += GetExpectedItemHeight(index);
			}
			m_ActiveItems.RemoveRange(0, num8);
			m_ActiveItems.AddRange(scrollInsertionList);
			m_ScrollInsertionList.Clear();
			if (firstVisibleIndex != num7)
			{
				contentPadding = GetContentHeightForIndex(firstVisibleIndex - 1);
				UpdateAnchor();
			}
			ScheduleScrollDirectionReset();
			m_ForcedLastVisibleItem = -1;
			m_CollectionView.SaveViewData();
		}

		private void UpdateAnchor()
		{
			anchoredIndex = firstVisibleIndex;
			anchorOffset = base.serializedData.scrollOffset.y - contentPadding;
		}

		private void ScheduleFill()
		{
			if (m_ScheduledItem == null)
			{
				m_ScheduledItem = m_CollectionView.schedule.Execute(m_FillCallback);
				return;
			}
			m_ScheduledItem.Pause();
			m_ScheduledItem.Resume();
		}

		private void ScheduleScroll()
		{
			if (m_ScrollScheduledItem == null)
			{
				m_ScrollScheduledItem = m_CollectionView.schedule.Execute(m_ScrollCallback);
				return;
			}
			m_ScrollScheduledItem.Pause();
			m_ScrollScheduledItem.Resume();
		}

		private void ScheduleScrollDirectionReset()
		{
			if (m_ScrollResetScheduledItem == null)
			{
				m_ScrollResetScheduledItem = m_CollectionView.schedule.Execute(m_ScrollResetCallback);
				return;
			}
			m_ScrollResetScheduledItem.Pause();
			m_ScrollResetScheduledItem.Resume();
		}

		private void ResetScroll()
		{
			m_ScrollDirection = ScrollDirection.Idle;
			m_LastChange = VirtualizationChange.None;
			m_ScrollView.UpdateContentViewTransform();
			UpdateAnchor();
			m_CollectionView.SaveViewData();
		}

		public override int GetIndexFromPosition(Vector2 position)
		{
			int num = 0;
			for (float num2 = 0f; num2 < position.y; num2 += GetExpectedItemHeight(num++))
			{
			}
			return num - 1;
		}

		public override float GetExpectedItemHeight(int index)
		{
			int draggedIndex = GetDraggedIndex();
			if (draggedIndex >= 0 && index == draggedIndex)
			{
				return 0f;
			}
			float value;
			return m_ItemHeightCache.TryGetValue(index, out value) ? value : defaultExpectedHeight;
		}

		private int GetFirstVisibleItem(float offset)
		{
			if (offset <= 0f)
			{
				return 0;
			}
			int num = -1;
			while (offset > 0f)
			{
				num++;
				float expectedItemHeight = GetExpectedItemHeight(num);
				offset -= expectedItemHeight;
			}
			return num;
		}

		public override float GetExpectedContentHeight()
		{
			return m_AccumulatedHeight + (float)(base.itemsCount - m_ItemHeightCache.Count) * defaultExpectedHeight;
		}

		private float GetContentHeightForIndex(int lastIndex)
		{
			if (lastIndex < 0)
			{
				return 0f;
			}
			if (m_ContentHeightCache.TryGetValue(lastIndex, out var value))
			{
				int draggedIndex = GetDraggedIndex();
				if (draggedIndex >= 0 && lastIndex >= draggedIndex)
				{
					return value.sum + (float)(lastIndex - value.count + 1) * defaultExpectedHeight - m_DraggedItem.rootElement.layout.height;
				}
				return value.sum + (float)(lastIndex - value.count + 1) * defaultExpectedHeight;
			}
			return GetContentHeightForIndex(lastIndex - 1) + GetExpectedItemHeight(lastIndex);
		}

		private ContentHeightCacheInfo GetCachedContentHeight(int index)
		{
			while (index >= 0)
			{
				if (m_ContentHeightCache.TryGetValue(index, out var value))
				{
					return value;
				}
				index--;
			}
			return default(ContentHeightCacheInfo);
		}

		private void RegisterItemHeight(int index, float height)
		{
			if (height <= 0f)
			{
				return;
			}
			float num = m_CollectionView.ResolveItemHeight(height);
			if (m_ItemHeightCache.TryGetValue(index, out var value))
			{
				m_AccumulatedHeight -= value;
			}
			m_AccumulatedHeight += num;
			m_ItemHeightCache[index] = num;
			if (index > m_HighestCachedIndex)
			{
				m_HighestCachedIndex = index;
			}
			bool flag = value == 0f;
			ContentHeightCacheInfo cachedContentHeight = GetCachedContentHeight(index - 1);
			m_ContentHeightCache[index] = new ContentHeightCacheInfo(cachedContentHeight.sum + num, cachedContentHeight.count + 1);
			foreach (KeyValuePair<int, float> item in m_ItemHeightCache)
			{
				if (item.Key > index)
				{
					ContentHeightCacheInfo contentHeightCacheInfo = m_ContentHeightCache[item.Key];
					m_ContentHeightCache[item.Key] = new ContentHeightCacheInfo(contentHeightCacheInfo.sum - value + num, flag ? (contentHeightCacheInfo.count + 1) : contentHeightCacheInfo.count);
				}
			}
		}

		private void UnregisterItemHeight(int index)
		{
			if (!m_ItemHeightCache.TryGetValue(index, out var value))
			{
				return;
			}
			m_AccumulatedHeight -= value;
			m_ItemHeightCache.Remove(index);
			m_ContentHeightCache.Remove(index);
			int num = -1;
			foreach (KeyValuePair<int, float> item in m_ItemHeightCache)
			{
				if (item.Key > index)
				{
					ContentHeightCacheInfo contentHeightCacheInfo = m_ContentHeightCache[item.Key];
					m_ContentHeightCache[item.Key] = new ContentHeightCacheInfo(contentHeightCacheInfo.sum - value, contentHeightCacheInfo.count - 1);
				}
				if (item.Key > num)
				{
					num = item.Key;
				}
			}
			m_HighestCachedIndex = num;
		}

		private void CleanItemHeightCache()
		{
			if (!IsIndexOutOfBounds(m_HighestCachedIndex))
			{
				return;
			}
			List<int> list = CollectionPool<List<int>, int>.Get();
			try
			{
				foreach (int key in m_ItemHeightCache.Keys)
				{
					if (IsIndexOutOfBounds(key))
					{
						list.Add(key);
					}
				}
				foreach (int item in list)
				{
					UnregisterItemHeight(item);
				}
			}
			finally
			{
				CollectionPool<List<int>, int>.Release(list);
			}
			m_MinimumItemHeight = -1f;
		}

		private void OnRecycledItemGeometryChanged(ReusableCollectionItem item)
		{
			if (item.index != -1 && !item.isDragGhost && !float.IsNaN(item.rootElement.layout.height) && item.rootElement.layout.height != 0f && UpdateRegisteredHeight(item))
			{
				ApplyScrollViewUpdate();
			}
		}

		private bool UpdateRegisteredHeight(ReusableCollectionItem item)
		{
			if (item.index == -1 || item.isDragGhost || float.IsNaN(item.rootElement.layout.height) || item.rootElement.layout.height == 0f)
			{
				return false;
			}
			if (item.rootElement.layout.height < defaultExpectedHeight)
			{
				m_MinimumItemHeight = item.rootElement.layout.height;
				Resize(m_ScrollView.layout.size);
			}
			float num = item.rootElement.layout.height - item.rootElement.resolvedStyle.paddingTop;
			float value;
			bool flag = m_ItemHeightCache.TryGetValue(item.index, out value);
			float num2 = (flag ? GetExpectedItemHeight(item.index) : defaultExpectedHeight);
			if (m_WaitingCache.Count == 0)
			{
				if (num > num2)
				{
					m_StickToBottom = false;
				}
				else
				{
					float num3 = num - num2;
					float num4 = Mathf.Max(0f, contentHeight - m_ScrollView.contentViewport.layout.height);
					m_StickToBottom = num4 > 0f && base.serializedData.scrollOffset.y >= m_ScrollView.verticalScroller.highValue + num3;
				}
			}
			if (!flag || !Mathf.Approximately(num, value))
			{
				RegisterItemHeight(item.index, num);
				UpdateScrollViewContainer(num2, num);
				if (m_WaitingCache.Count == 0)
				{
					return true;
				}
			}
			return m_WaitingCache.Remove(item.index) && m_WaitingCache.Count == 0;
		}

		internal override T GetOrMakeItemAtIndex(int activeItemIndex = -1, int scrollViewIndex = -1)
		{
			T orMakeItemAtIndex = base.GetOrMakeItemAtIndex(activeItemIndex, scrollViewIndex);
			orMakeItemAtIndex.onGeometryChanged += m_GeometryChangedCallback;
			return orMakeItemAtIndex;
		}

		internal override void ReleaseItem(int activeItemsIndex)
		{
			T val = m_ActiveItems[activeItemsIndex];
			val.onGeometryChanged -= m_GeometryChangedCallback;
			int index = val.index;
			UnregisterItemHeight(index);
			base.ReleaseItem(activeItemsIndex);
			m_WaitingCache.Remove(index);
		}

		internal override void StartDragItem(ReusableCollectionItem item)
		{
			m_WaitingCache.Remove(item.index);
			base.StartDragItem(item);
			m_DraggedItem.onGeometryChanged -= m_GeometryChangedCallback;
		}

		internal override void EndDrag(int dropIndex)
		{
			bool flag = m_DraggedItem.index < dropIndex;
			int index = m_DraggedItem.index;
			int num = (flag ? 1 : (-1));
			float expectedItemHeight = GetExpectedItemHeight(index);
			for (int i = index; i != dropIndex; i += num)
			{
				float expectedItemHeight2 = GetExpectedItemHeight(i);
				float expectedItemHeight3 = GetExpectedItemHeight(i + num);
				if (!Mathf.Approximately(expectedItemHeight2, expectedItemHeight3))
				{
					RegisterItemHeight(i, expectedItemHeight3);
				}
			}
			RegisterItemHeight(flag ? (dropIndex - 1) : dropIndex, expectedItemHeight);
			if (firstVisibleIndex > m_DraggedItem.index)
			{
				firstVisibleIndex = GetFirstVisibleItem(base.serializedData.scrollOffset.y);
				UpdateAnchor();
			}
			m_DraggedItem.onGeometryChanged += m_GeometryChangedCallback;
			base.EndDrag(dropIndex);
		}

		private void HideItem(int activeItemsIndex)
		{
			T val = m_ActiveItems[activeItemsIndex];
			val.rootElement.style.display = DisplayStyle.None;
			m_WaitingCache.Remove(val.index);
		}

		private void MarkWaitingForLayout(T item)
		{
			if (!item.isDragGhost)
			{
				m_WaitingCache.Add(item.index);
				item.rootElement.lastLayout = Rect.zero;
				item.rootElement.MarkDirtyRepaint();
			}
		}

		private bool IsIndexOutOfBounds(int i)
		{
			return m_CollectionView.itemsSource == null || i >= base.itemsCount;
		}
	}
	internal class FixedHeightVirtualizationController<T> : VerticalVirtualizationController<T> where T : ReusableCollectionItem, new()
	{
		private float resolvedItemHeight => m_CollectionView.ResolveItemHeight();

		protected override bool VisibleItemPredicate(T i)
		{
			return true;
		}

		public FixedHeightVirtualizationController(BaseVerticalCollectionView collectionView)
			: base(collectionView)
		{
		}

		public override int GetIndexFromPosition(Vector2 position)
		{
			return (int)(position.y / resolvedItemHeight);
		}

		public override float GetExpectedItemHeight(int index)
		{
			return resolvedItemHeight;
		}

		public override float GetExpectedContentHeight()
		{
			return (float)base.itemsCount * resolvedItemHeight;
		}

		public override void ScrollToItem(int index)
		{
			if (visibleItemCount == 0 || index < -1)
			{
				return;
			}
			float num = resolvedItemHeight;
			if (index == -1)
			{
				int num2 = (int)(base.lastHeight / num);
				if (base.itemsCount < num2)
				{
					m_ScrollView.scrollOffset = new Vector2(0f, 0f);
				}
				else
				{
					m_ScrollView.scrollOffset = new Vector2(0f, (float)(base.itemsCount + 1) * num);
				}
				return;
			}
			if (firstVisibleIndex >= index)
			{
				m_ScrollView.scrollOffset = Vector2.up * (num * (float)index);
				return;
			}
			int num3 = (int)(base.lastHeight / num);
			if (index >= firstVisibleIndex + num3)
			{
				int num4 = index - num3 + 1;
				float num5 = num - (base.lastHeight - (float)num3 * num);
				float y = num * (float)num4 + num5;
				m_ScrollView.scrollOffset = new Vector2(m_ScrollView.scrollOffset.x, y);
			}
		}

		public override void Resize(Vector2 size)
		{
			float num = resolvedItemHeight;
			float expectedContentHeight = GetExpectedContentHeight();
			m_ScrollView.contentContainer.style.height = expectedContentHeight;
			float num2 = Mathf.Max(0f, expectedContentHeight - m_ScrollView.contentViewport.layout.height);
			float num3 = Mathf.Min(base.serializedData.scrollOffset.y, num2);
			m_ScrollView.verticalScroller.slider.SetHighValueWithoutNotify(num2);
			m_ScrollView.verticalScroller.slider.SetValueWithoutNotify(num3);
			int num4 = (int)(m_CollectionView.ResolveItemHeight(size.y) / num);
			if (num4 > 0)
			{
				num4 += 2;
			}
			int num5 = Mathf.Min(num4, base.itemsCount);
			if (visibleItemCount != num5)
			{
				int num6 = visibleItemCount;
				if (visibleItemCount > num5)
				{
					int num7 = num6 - num5;
					for (int i = 0; i < num7; i++)
					{
						int activeItemsIndex = m_ActiveItems.Count - 1;
						ReleaseItem(activeItemsIndex);
					}
				}
				else
				{
					int num8 = num5 - visibleItemCount;
					for (int j = 0; j < num8; j++)
					{
						int newIndex = j + firstVisibleIndex + num6;
						T orMakeItemAtIndex = GetOrMakeItemAtIndex();
						Setup(orMakeItemAtIndex, newIndex);
					}
				}
			}
			OnScroll(new Vector2(0f, num3));
		}

		public override void OnScroll(Vector2 scrollOffset)
		{
			float num = Mathf.Max(0f, scrollOffset.y);
			float num2 = resolvedItemHeight;
			int num3 = (int)(num / num2);
			m_ScrollView.contentContainer.style.paddingTop = (float)num3 * num2;
			m_ScrollView.contentContainer.style.height = (float)base.itemsCount * num2;
			base.serializedData.scrollOffset.y = scrollOffset.y;
			if (num3 == firstVisibleIndex)
			{
				return;
			}
			firstVisibleIndex = num3;
			if (m_ActiveItems.Count <= 0)
			{
				return;
			}
			if (firstVisibleIndex < m_ActiveItems[0].index)
			{
				int num4 = m_ActiveItems[0].index - firstVisibleIndex;
				List<T> scrollInsertionList = m_ScrollInsertionList;
				for (int i = 0; i < num4; i++)
				{
					if (m_ActiveItems.Count <= 0)
					{
						break;
					}
					List<T> list = m_ActiveItems;
					T val = list[list.Count - 1];
					scrollInsertionList.Add(val);
					m_ActiveItems.RemoveAt(m_ActiveItems.Count - 1);
					val.rootElement.SendToBack();
				}
				m_ActiveItems.InsertRange(0, scrollInsertionList);
				m_ScrollInsertionList.Clear();
			}
			else
			{
				int num5 = firstVisibleIndex;
				List<T> list2 = m_ActiveItems;
				if (num5 < list2[list2.Count - 1].index)
				{
					List<T> scrollInsertionList2 = m_ScrollInsertionList;
					int num6 = 0;
					while (firstVisibleIndex > m_ActiveItems[num6].index)
					{
						T val2 = m_ActiveItems[num6];
						scrollInsertionList2.Add(val2);
						num6++;
						val2.rootElement.BringToFront();
					}
					m_ActiveItems.RemoveRange(0, num6);
					m_ActiveItems.AddRange(scrollInsertionList2);
					scrollInsertionList2.Clear();
				}
			}
			for (int j = 0; j < m_ActiveItems.Count; j++)
			{
				int newIndex = j + firstVisibleIndex;
				Setup(m_ActiveItems[j], newIndex);
			}
		}

		internal override T GetOrMakeItemAtIndex(int activeItemIndex = -1, int scrollViewIndex = -1)
		{
			T orMakeItemAtIndex = base.GetOrMakeItemAtIndex(activeItemIndex, scrollViewIndex);
			orMakeItemAtIndex.rootElement.style.height = resolvedItemHeight;
			return orMakeItemAtIndex;
		}

		internal override void EndDrag(int dropIndex)
		{
			m_DraggedItem.rootElement.style.height = resolvedItemHeight;
			if (firstVisibleIndex > m_DraggedItem.index)
			{
				m_ScrollView.verticalScroller.value = base.serializedData.scrollOffset.y - resolvedItemHeight;
			}
			base.EndDrag(dropIndex);
		}
	}
	internal class ReusableCollectionItem
	{
		public const int UndefinedIndex = -1;

		protected EventCallback<GeometryChangedEvent> m_GeometryChangedEventCallback;

		public virtual VisualElement rootElement => bindableElement;

		public VisualElement bindableElement { get; protected set; }

		public ValueAnimation<StyleValues> animator { get; set; }

		public int index { get; set; }

		public int id { get; set; }

		internal bool isDragGhost { get; private set; }

		public event Action<ReusableCollectionItem> onGeometryChanged;

		internal event Action<ReusableCollectionItem> onDestroy;

		public ReusableCollectionItem()
		{
			index = (id = -1);
			m_GeometryChangedEventCallback = OnGeometryChanged;
		}

		public virtual void Init(VisualElement item)
		{
			bindableElement = item;
		}

		public virtual void PreAttachElement()
		{
			rootElement.AddToClassList(BaseVerticalCollectionView.itemUssClassName);
			rootElement.RegisterCallback(m_GeometryChangedEventCallback);
		}

		public virtual void DetachElement()
		{
			rootElement.RemoveFromClassList(BaseVerticalCollectionView.itemUssClassName);
			rootElement.UnregisterCallback(m_GeometryChangedEventCallback);
			rootElement?.RemoveFromHierarchy();
			SetSelected(selected: false);
			SetDragGhost(dragGhost: false);
			int num = (id = -1);
			index = num;
		}

		public virtual void DestroyElement()
		{
			this.onDestroy?.Invoke(this);
		}

		public virtual void SetSelected(bool selected)
		{
			if (selected)
			{
				rootElement.AddToClassList(BaseVerticalCollectionView.itemSelectedVariantUssClassName);
				rootElement.pseudoStates |= PseudoStates.Checked;
			}
			else
			{
				rootElement.RemoveFromClassList(BaseVerticalCollectionView.itemSelectedVariantUssClassName);
				rootElement.pseudoStates &= ~PseudoStates.Checked;
			}
		}

		public virtual void SetDragGhost(bool dragGhost)
		{
			isDragGhost = dragGhost;
			rootElement.style.maxHeight = ((!isDragGhost) ? StyleKeyword.Initial : StyleKeyword.Undefined);
			bindableElement.style.display = (isDragGhost ? DisplayStyle.None : DisplayStyle.Flex);
		}

		protected void OnGeometryChanged(GeometryChangedEvent evt)
		{
			this.onGeometryChanged?.Invoke(this);
		}
	}
	internal class ReusableListViewItem : ReusableCollectionItem
	{
		private VisualElement m_Container;

		private VisualElement m_DragHandle;

		private VisualElement m_ItemContainer;

		public override VisualElement rootElement => m_Container ?? base.bindableElement;

		public void Init(VisualElement item, bool usesAnimatedDragger)
		{
			base.Init(item);
			VisualElement root = new VisualElement
			{
				name = BaseListView.reorderableItemUssClassName
			};
			UpdateHierarchy(root, base.bindableElement, usesAnimatedDragger);
		}

		protected void UpdateHierarchy(VisualElement root, VisualElement item, bool usesAnimatedDragger)
		{
			if (usesAnimatedDragger)
			{
				if (m_Container == null)
				{
					m_Container = root;
					m_Container.AddToClassList(BaseListView.reorderableItemUssClassName);
					m_DragHandle = new VisualElement
					{
						name = BaseListView.reorderableItemHandleUssClassName
					};
					m_DragHandle.AddToClassList(BaseListView.reorderableItemHandleUssClassName);
					VisualElement visualElement = new VisualElement
					{
						name = BaseListView.reorderableItemHandleBarUssClassName
					};
					visualElement.AddToClassList(BaseListView.reorderableItemHandleBarUssClassName);
					m_DragHandle.Add(visualElement);
					VisualElement visualElement2 = new VisualElement
					{
						name = BaseListView.reorderableItemHandleBarUssClassName
					};
					visualElement2.AddToClassList(BaseListView.reorderableItemHandleBarUssClassName);
					m_DragHandle.Add(visualElement2);
					m_ItemContainer = new VisualElement
					{
						name = BaseListView.reorderableItemContainerUssClassName
					};
					m_ItemContainer.AddToClassList(BaseListView.reorderableItemContainerUssClassName);
					m_ItemContainer.Add(item);
					m_Container.Add(m_DragHandle);
					m_Container.Add(m_ItemContainer);
				}
			}
			else if (m_Container != null)
			{
				m_Container.RemoveFromHierarchy();
				m_Container = null;
			}
		}

		public void UpdateDragHandle(bool needsDragHandle)
		{
			if (needsDragHandle)
			{
				if (m_DragHandle.parent == null)
				{
					rootElement.Insert(0, m_DragHandle);
					rootElement.AddToClassList(BaseListView.reorderableItemUssClassName);
				}
			}
			else if (m_DragHandle?.parent != null)
			{
				m_DragHandle.RemoveFromHierarchy();
				rootElement.RemoveFromClassList(BaseListView.reorderableItemUssClassName);
			}
		}

		public override void PreAttachElement()
		{
			base.PreAttachElement();
			rootElement.AddToClassList(BaseListView.itemUssClassName);
		}

		public override void DetachElement()
		{
			base.DetachElement();
			rootElement.RemoveFromClassList(BaseListView.itemUssClassName);
		}

		public override void SetDragGhost(bool dragGhost)
		{
			base.SetDragGhost(dragGhost);
			if (m_DragHandle != null)
			{
				m_DragHandle.EnableInClassList("unity-hidden", base.isDragGhost);
			}
		}
	}
	internal class ReusableMultiColumnListViewItem : ReusableListViewItem
	{
		public override VisualElement rootElement => base.bindableElement;

		public override void Init(VisualElement item)
		{
		}

		public void Init(VisualElement container, Columns columns, bool usesAnimatedDrag)
		{
			int num = 0;
			base.bindableElement = container;
			foreach (Column visible in columns.visibleList)
			{
				if (columns.IsPrimary(visible))
				{
					VisualElement visualElement = container[num];
					VisualElement item = visualElement.GetProperty(MultiColumnController.bindableElementPropertyName) as VisualElement;
					UpdateHierarchy(visualElement, item, usesAnimatedDrag);
					break;
				}
				num++;
			}
		}
	}
	internal class ReusableMultiColumnTreeViewItem : ReusableTreeViewItem
	{
		public override VisualElement rootElement => base.bindableElement;

		public override void Init(VisualElement item)
		{
		}

		public void Init(VisualElement container, Columns columns)
		{
			int num = 0;
			base.bindableElement = container;
			foreach (Column visible in columns.visibleList)
			{
				if (columns.IsPrimary(visible))
				{
					VisualElement visualElement = container[num];
					VisualElement item = visualElement.GetProperty(MultiColumnController.bindableElementPropertyName) as VisualElement;
					InitExpandHierarchy(visualElement, item);
					break;
				}
				num++;
			}
		}
	}
	internal class ReusableTreeViewItem : ReusableCollectionItem
	{
		private Toggle m_Toggle;

		private VisualElement m_Container;

		private VisualElement m_IndentElement;

		private VisualElement m_BindableContainer;

		private VisualElement m_Checkmark;

		private int m_Depth;

		private float m_IndentWidth;

		private EventCallback<PointerUpEvent> m_PointerUpCallback;

		private EventCallback<ChangeEvent<bool>> m_ToggleValueChangedCallback;

		private EventCallback<GeometryChangedEvent> m_ToggleGeometryChangedCallback;

		public override VisualElement rootElement => m_Container ?? base.bindableElement;

		internal float indentWidth => m_IndentWidth;

		public event Action<PointerUpEvent> onPointerUp;

		public event Action<ChangeEvent<bool>> onToggleValueChanged;

		public ReusableTreeViewItem()
		{
			m_PointerUpCallback = OnPointerUp;
			m_ToggleValueChangedCallback = OnToggleValueChanged;
			m_ToggleGeometryChangedCallback = OnToggleGeometryChanged;
		}

		public override void Init(VisualElement item)
		{
			base.Init(item);
			VisualElement visualElement = new VisualElement
			{
				name = BaseTreeView.itemUssClassName
			};
			visualElement.AddToClassList(BaseTreeView.itemUssClassName);
			InitExpandHierarchy(visualElement, item);
		}

		protected void InitExpandHierarchy(VisualElement root, VisualElement item)
		{
			m_Container = root;
			m_Container.style.flexDirection = FlexDirection.Row;
			VisualElement visualElement = new VisualElement();
			visualElement.name = BaseTreeView.itemIndentUssClassName;
			visualElement.style.flexDirection = FlexDirection.Row;
			m_IndentElement = visualElement;
			m_Container.hierarchy.Add(m_IndentElement);
			m_Toggle = new Toggle
			{
				name = BaseTreeView.itemToggleUssClassName,
				userData = this
			};
			m_Toggle.AddToClassList(Foldout.toggleUssClassName);
			m_Toggle.AddToClassList(BaseTreeView.itemToggleUssClassName);
			m_Toggle.visualInput.AddToClassList(Foldout.inputUssClassName);
			m_Checkmark = m_Toggle.visualInput.Q(null, Toggle.checkmarkUssClassName);
			m_Checkmark.AddToClassList(Foldout.checkmarkUssClassName);
			m_Container.hierarchy.Add(m_Toggle);
			VisualElement visualElement2 = new VisualElement();
			visualElement2.name = BaseTreeView.itemContentContainerUssClassName;
			visualElement2.style.flexGrow = 1f;
			m_BindableContainer = visualElement2;
			m_BindableContainer.AddToClassList(BaseTreeView.itemContentContainerUssClassName);
			m_Container.Add(m_BindableContainer);
			m_BindableContainer.Add(item);
		}

		public override void PreAttachElement()
		{
			base.PreAttachElement();
			rootElement.AddToClassList(BaseTreeView.itemUssClassName);
			m_Container?.RegisterCallback(m_PointerUpCallback);
			m_Toggle?.visualInput.Q(null, Toggle.checkmarkUssClassName).RegisterCallback(m_ToggleGeometryChangedCallback);
			m_Toggle?.RegisterValueChangedCallback(m_ToggleValueChangedCallback);
		}

		public override void DetachElement()
		{
			base.DetachElement();
			rootElement.RemoveFromClassList(BaseTreeView.itemUssClassName);
			m_Container?.UnregisterCallback(m_PointerUpCallback);
			m_Toggle?.visualInput.Q(null, Toggle.checkmarkUssClassName).UnregisterCallback(m_ToggleGeometryChangedCallback);
			m_Toggle?.UnregisterValueChangedCallback(m_ToggleValueChangedCallback);
		}

		public void Indent(int depth)
		{
			if (m_IndentElement != null)
			{
				m_Depth = depth;
				UpdateIndentLayout();
			}
		}

		public void SetExpandedWithoutNotify(bool expanded)
		{
			m_Toggle?.SetValueWithoutNotify(expanded);
		}

		public void SetToggleVisibility(bool visible)
		{
			if (m_Toggle != null)
			{
				m_Toggle.visible = visible;
			}
		}

		private void OnToggleGeometryChanged(GeometryChangedEvent evt)
		{
			float num = m_Checkmark.resolvedStyle.width + m_Checkmark.resolvedStyle.marginLeft + m_Checkmark.resolvedStyle.marginRight;
			if (!(Math.Abs(num - m_IndentWidth) < float.Epsilon))
			{
				m_IndentWidth = num;
				UpdateIndentLayout();
			}
		}

		private void UpdateIndentLayout()
		{
			m_IndentElement.style.width = m_IndentWidth * (float)m_Depth;
			m_IndentElement.EnableInClassList(BaseTreeView.itemIndentUssClassName, m_Depth > 0);
		}

		private void OnPointerUp(PointerUpEvent evt)
		{
			this.onPointerUp?.Invoke(evt);
		}

		private void OnToggleValueChanged(ChangeEvent<bool> evt)
		{
			this.onToggleValueChanged?.Invoke(evt);
		}
	}
	internal abstract class VerticalVirtualizationController<T> : CollectionVirtualizationController where T : ReusableCollectionItem, new()
	{
		private readonly UnityEngine.Pool.ObjectPool<T> m_Pool = new UnityEngine.Pool.ObjectPool<T>(() => new T(), null, delegate(T i)
		{
			i.DetachElement();
		}, delegate(T i)
		{
			i.DestroyElement();
		});

		protected BaseVerticalCollectionView m_CollectionView;

		protected const int k_ExtraVisibleItems = 2;

		protected List<T> m_ActiveItems;

		protected T m_DraggedItem;

		private int m_LastFocusedElementIndex = -1;

		private List<int> m_LastFocusedElementTreeChildIndexes = new List<int>();

		protected readonly Func<T, bool> m_VisibleItemPredicateDelegate;

		protected List<T> m_ScrollInsertionList = new List<T>();

		private VisualElement m_EmptyRows;

		public override IEnumerable<ReusableCollectionItem> activeItems => m_ActiveItems;

		internal int itemsCount => m_CollectionView.itemsSource.Count;

		internal T firstVisibleItem => m_ActiveItems.FirstOrDefault(m_VisibleItemPredicateDelegate);

		internal T lastVisibleItem => m_ActiveItems.LastOrDefault(m_VisibleItemPredicateDelegate);

		public override int visibleItemCount => m_ActiveItems.Count(m_VisibleItemPredicateDelegate);

		protected SerializedVirtualizationData serializedData => m_CollectionView.serializedVirtualizationData;

		public override int firstVisibleIndex
		{
			get
			{
				return Mathf.Min(serializedData.firstVisibleIndex, (m_CollectionView.viewController != null) ? (m_CollectionView.viewController.GetItemsCount() - 1) : serializedData.firstVisibleIndex);
			}
			protected set
			{
				serializedData.firstVisibleIndex = value;
			}
		}

		protected float lastHeight => m_CollectionView.lastHeight;

		protected virtual bool alwaysRebindOnRefresh => true;

		protected virtual bool VisibleItemPredicate(T i)
		{
			return i.rootElement.style.display == DisplayStyle.Flex;
		}

		protected VerticalVirtualizationController(BaseVerticalCollectionView collectionView)
			: base(collectionView.scrollView)
		{
			m_CollectionView = collectionView;
			m_ActiveItems = new List<T>();
			m_VisibleItemPredicateDelegate = VisibleItemPredicate;
			m_ScrollView.contentContainer.disableClipping = false;
		}

		public override void Refresh(bool rebuild)
		{
			bool flag = m_CollectionView.HasValidDataAndBindings();
			for (int i = 0; i < m_ActiveItems.Count; i++)
			{
				int num = firstVisibleIndex + i;
				T val = m_ActiveItems[i];
				bool flag2 = val.rootElement.style.display == DisplayStyle.Flex;
				if (rebuild)
				{
					if (flag)
					{
						m_CollectionView.viewController.InvokeUnbindItem(val, val.index);
					}
					m_Pool.Release(val);
				}
				else if (m_CollectionView.itemsSource != null && num >= 0 && num < itemsCount)
				{
					if (flag && (flag2 || alwaysRebindOnRefresh))
					{
						if (val.index != -1)
						{
							m_CollectionView.viewController.InvokeUnbindItem(val, val.index);
						}
						Setup(val, num);
					}
				}
				else if (flag2)
				{
					ReleaseItem(i--);
				}
			}
			if (rebuild)
			{
				m_Pool.Clear();
				m_ActiveItems.Clear();
				m_ScrollView.Clear();
			}
		}

		protected void Setup(T recycledItem, int newIndex)
		{
			bool isDragGhost = recycledItem.isDragGhost;
			if (GetDraggedIndex() == newIndex)
			{
				if (recycledItem.index != -1)
				{
					m_CollectionView.viewController.InvokeUnbindItem(recycledItem, recycledItem.index);
				}
				recycledItem.SetDragGhost(dragGhost: true);
				recycledItem.index = m_DraggedItem.index;
				recycledItem.rootElement.style.display = DisplayStyle.Flex;
				return;
			}
			if (isDragGhost)
			{
				recycledItem.SetDragGhost(dragGhost: false);
			}
			if (newIndex >= itemsCount)
			{
				recycledItem.rootElement.style.display = DisplayStyle.None;
				if (recycledItem.index >= 0 && recycledItem.index < itemsCount)
				{
					m_CollectionView.viewController.InvokeUnbindItem(recycledItem, recycledItem.index);
					recycledItem.index = -1;
				}
				return;
			}
			recycledItem.rootElement.style.display = DisplayStyle.Flex;
			int idForIndex = m_CollectionView.viewController.GetIdForIndex(newIndex);
			if (recycledItem.index != newIndex || recycledItem.id != idForIndex)
			{
				bool enable = m_CollectionView.showAlternatingRowBackgrounds != AlternatingRowBackground.None && newIndex % 2 == 1;
				recycledItem.rootElement.EnableInClassList(BaseVerticalCollectionView.itemAlternativeBackgroundUssClassName, enable);
				int index = recycledItem.index;
				if (recycledItem.index != -1)
				{
					m_CollectionView.viewController.InvokeUnbindItem(recycledItem, recycledItem.index);
				}
				recycledItem.index = newIndex;
				recycledItem.id = idForIndex;
				int num = newIndex - firstVisibleIndex;
				if (num >= m_ScrollView.contentContainer.childCount)
				{
					recycledItem.rootElement.BringToFront();
				}
				else if (num >= 0)
				{
					recycledItem.rootElement.PlaceBehind(m_ScrollView.contentContainer[num]);
				}
				else
				{
					recycledItem.rootElement.SendToBack();
				}
				m_CollectionView.viewController.InvokeBindItem(recycledItem, newIndex);
				HandleFocus(recycledItem, index);
			}
		}

		public override void OnFocus(VisualElement leafTarget)
		{
			if (leafTarget == m_ScrollView.contentContainer)
			{
				return;
			}
			m_LastFocusedElementTreeChildIndexes.Clear();
			if (m_ScrollView.contentContainer.FindElementInTree(leafTarget, m_LastFocusedElementTreeChildIndexes))
			{
				VisualElement visualElement = m_ScrollView.contentContainer[m_LastFocusedElementTreeChildIndexes[0]];
				foreach (ReusableCollectionItem activeItem in activeItems)
				{
					if (activeItem.rootElement == visualElement)
					{
						m_LastFocusedElementIndex = activeItem.index;
						break;
					}
				}
				m_LastFocusedElementTreeChildIndexes.RemoveAt(0);
			}
			else
			{
				m_LastFocusedElementIndex = -1;
			}
		}

		public override void OnBlur(VisualElement willFocus)
		{
			if (willFocus == null || willFocus != m_ScrollView.contentContainer)
			{
				m_LastFocusedElementTreeChildIndexes.Clear();
				m_LastFocusedElementIndex = -1;
			}
		}

		private void HandleFocus(ReusableCollectionItem recycledItem, int previousIndex)
		{
			if (m_LastFocusedElementIndex != -1)
			{
				if (m_LastFocusedElementIndex == recycledItem.index)
				{
					recycledItem.rootElement.ElementAtTreePath(m_LastFocusedElementTreeChildIndexes)?.Focus();
				}
				else if (m_LastFocusedElementIndex != previousIndex)
				{
					recycledItem.rootElement.ElementAtTreePath(m_LastFocusedElementTreeChildIndexes)?.Blur();
				}
				else
				{
					m_ScrollView.contentContainer.Focus();
				}
			}
		}

		public override void UpdateBackground()
		{
			float num;
			if (m_CollectionView.showAlternatingRowBackgrounds != AlternatingRowBackground.All || (num = m_ScrollView.contentViewport.resolvedStyle.height - GetExpectedContentHeight()) <= 0f)
			{
				m_EmptyRows?.RemoveFromHierarchy();
			}
			else
			{
				if (lastVisibleItem == null)
				{
					return;
				}
				if (m_EmptyRows == null)
				{
					m_EmptyRows = new VisualElement
					{
						classList = { BaseVerticalCollectionView.backgroundFillUssClassName }
					};
				}
				if (m_EmptyRows.parent == null)
				{
					m_ScrollView.contentViewport.Add(m_EmptyRows);
				}
				float expectedItemHeight = GetExpectedItemHeight(-1);
				int num2 = Mathf.FloorToInt(num / expectedItemHeight) + 1;
				if (num2 > m_EmptyRows.childCount)
				{
					int num3 = num2 - m_EmptyRows.childCount;
					for (int i = 0; i < num3; i++)
					{
						VisualElement visualElement = new VisualElement();
						visualElement.style.flexShrink = 0f;
						m_EmptyRows.Add(visualElement);
					}
				}
				int num4 = lastVisibleItem?.index ?? (-1);
				int childCount = m_EmptyRows.hierarchy.childCount;
				for (int j = 0; j < childCount; j++)
				{
					VisualElement visualElement2 = m_EmptyRows.hierarchy[j];
					num4++;
					visualElement2.style.height = expectedItemHeight;
					visualElement2.EnableInClassList(BaseVerticalCollectionView.itemAlternativeBackgroundUssClassName, num4 % 2 == 1);
				}
			}
		}

		internal override void StartDragItem(ReusableCollectionItem item)
		{
			m_DraggedItem = item as T;
			int num = m_ActiveItems.IndexOf(m_DraggedItem);
			m_ActiveItems.RemoveAt(num);
			T orMakeItemAtIndex = GetOrMakeItemAtIndex(num, num);
			Setup(orMakeItemAtIndex, m_DraggedItem.index);
		}

		internal override void EndDrag(int dropIndex)
		{
			ReusableCollectionItem recycledItemFromIndex = m_CollectionView.GetRecycledItemFromIndex(dropIndex);
			int index = ((recycledItemFromIndex != null) ? m_ScrollView.IndexOf(recycledItemFromIndex.rootElement) : m_ActiveItems.Count);
			m_ScrollView.Insert(index, m_DraggedItem.rootElement);
			m_ActiveItems.Insert(index, m_DraggedItem);
			for (int i = 0; i < m_ActiveItems.Count; i++)
			{
				T val = m_ActiveItems[i];
				if (val.isDragGhost)
				{
					val.index = -1;
					ReleaseItem(i);
					i--;
				}
			}
			if (Math.Min(dropIndex, itemsCount - 1) != m_DraggedItem.index)
			{
				if (lastVisibleItem != null)
				{
					lastVisibleItem.rootElement.style.display = DisplayStyle.None;
				}
				if (m_DraggedItem.index < dropIndex)
				{
					m_CollectionView.viewController.InvokeUnbindItem(m_DraggedItem, m_DraggedItem.index);
					m_DraggedItem.index = -1;
				}
				else if (recycledItemFromIndex != null)
				{
					m_CollectionView.viewController.InvokeUnbindItem(recycledItemFromIndex, recycledItemFromIndex.index);
					recycledItemFromIndex.index = -1;
				}
			}
			m_DraggedItem = null;
		}

		internal virtual T GetOrMakeItemAtIndex(int activeItemIndex = -1, int scrollViewIndex = -1)
		{
			T val = m_Pool.Get();
			if (val.rootElement == null)
			{
				m_CollectionView.viewController.InvokeMakeItem(val);
				val.onDestroy += OnDestroyItem;
			}
			val.PreAttachElement();
			if (activeItemIndex == -1)
			{
				m_ActiveItems.Add(val);
			}
			else
			{
				m_ActiveItems.Insert(activeItemIndex, val);
			}
			if (scrollViewIndex == -1)
			{
				m_ScrollView.Add(val.rootElement);
			}
			else
			{
				m_ScrollView.Insert(scrollViewIndex, val.rootElement);
			}
			return val;
		}

		internal virtual void ReleaseItem(int activeItemsIndex)
		{
			T val = m_ActiveItems[activeItemsIndex];
			if (val.index != -1)
			{
				m_CollectionView.viewController.InvokeUnbindItem(val, val.index);
			}
			m_Pool.Release(val);
			m_ActiveItems.Remove(val);
		}

		private void OnDestroyItem(ReusableCollectionItem item)
		{
			m_CollectionView.viewController.InvokeDestroyItem(item);
			item.onDestroy -= OnDestroyItem;
		}

		protected int GetDraggedIndex()
		{
			if (m_CollectionView.dragger is ListViewDraggerAnimated { isDragging: not false } listViewDraggerAnimated)
			{
				return listViewDraggerAnimated.draggedItem.index;
			}
			return -1;
		}
	}
	public abstract class ContextualMenuManager
	{
		internal bool displayMenuHandledOSX { get; set; }

		public abstract void DisplayMenuIfEventMatches(EventBase evt, IEventHandler eventHandler);

		public void DisplayMenu(EventBase triggerEvent, IEventHandler target)
		{
			DropdownMenu menu = new DropdownMenu();
			int pointerId;
			int button;
			using (ContextualMenuPopulateEvent contextualMenuPopulateEvent = ContextualMenuPopulateEvent.GetPooled(triggerEvent, menu, target, this))
			{
				pointerId = ((triggerEvent is IPointerEvent pointerEvent) ? pointerEvent.pointerId : PointerId.mousePointerId);
				button = contextualMenuPopulateEvent.button;
				target?.SendEvent(contextualMenuPopulateEvent);
			}
			if (Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.OSXPlayer)
			{
				displayMenuHandledOSX = true;
				if (button >= 0)
				{
					PointerDeviceState.ReleaseButton(pointerId, button);
				}
			}
		}

		protected internal abstract void DoDisplayMenu(DropdownMenu menu, EventBase triggerEvent);
	}
	public class ContextualMenuManipulator : MouseManipulator
	{
		private Action<ContextualMenuPopulateEvent> m_MenuBuilder;

		public ContextualMenuManipulator(Action<ContextualMenuPopulateEvent> menuBuilder)
		{
			m_MenuBuilder = menuBuilder;
			base.activators.Add(new ManipulatorActivationFilter
			{
				button = MouseButton.RightMouse
			});
			if (Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.OSXPlayer)
			{
				base.activators.Add(new ManipulatorActivationFilter
				{
					button = MouseButton.LeftMouse,
					modifiers = EventModifiers.Control
				});
			}
		}

		protected override void RegisterCallbacksOnTarget()
		{
			if (Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.OSXPlayer)
			{
				base.target.RegisterCallback<MouseDownEvent>(OnMouseDownEventOSX);
				base.target.RegisterCallback<MouseUpEvent>(OnMouseUpEventOSX);
			}
			else
			{
				base.target.RegisterCallback<MouseUpEvent>(OnMouseUpDownEvent);
			}
			base.target.RegisterCallback<KeyUpEvent>(OnKeyUpEvent);
			base.target.RegisterCallback<ContextualMenuPopulateEvent>(OnContextualMenuEvent);
		}

		protected override void UnregisterCallbacksFromTarget()
		{
			if (Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.OSXPlayer)
			{
				base.target.UnregisterCallback<MouseDownEvent>(OnMouseDownEventOSX);
				base.target.UnregisterCallback<MouseUpEvent>(OnMouseUpEventOSX);
			}
			else
			{
				base.target.UnregisterCallback<MouseUpEvent>(OnMouseUpDownEvent);
			}
			base.target.UnregisterCallback<KeyUpEvent>(OnKeyUpEvent);
			base.target.UnregisterCallback<ContextualMenuPopulateEvent>(OnContextualMenuEvent);
		}

		private void OnMouseUpDownEvent(IMouseEvent evt)
		{
			if (CanStartManipulation(evt))
			{
				DoDisplayMenu(evt as EventBase);
			}
		}

		private void OnMouseDownEventOSX(MouseDownEvent evt)
		{
			if (base.target.elementPanel?.contextualMenuManager != null)
			{
				base.target.elementPanel.contextualMenuManager.displayMenuHandledOSX = false;
			}
			if (!evt.isDefaultPrevented)
			{
				OnMouseUpDownEvent(evt);
			}
		}

		private void OnMouseUpEventOSX(MouseUpEvent evt)
		{
			if (base.target.elementPanel?.contextualMenuManager == null || !base.target.elementPanel.contextualMenuManager.displayMenuHandledOSX)
			{
				OnMouseUpDownEvent(evt);
			}
		}

		private void OnKeyUpEvent(KeyUpEvent evt)
		{
			if (evt.keyCode == KeyCode.Menu)
			{
				DoDisplayMenu(evt);
			}
		}

		private void DoDisplayMenu(EventBase evt)
		{
			if (base.target.elementPanel?.contextualMenuManager != null)
			{
				base.target.elementPanel.contextualMenuManager.DisplayMenu(evt, base.target);
				evt.StopPropagation();
				evt.PreventDefault();
			}
		}

		private void OnContextualMenuEvent(ContextualMenuPopulateEvent evt)
		{
			m_MenuBuilder?.Invoke(evt);
		}
	}
	public abstract class BaseBoolField : BaseField<bool>
	{
		protected Label m_Label;

		protected readonly VisualElement m_CheckMark;

		internal Clickable m_Clickable;

		private string m_OriginalText;

		internal Label boolFieldLabelElement => m_Label;

		public string text
		{
			get
			{
				return m_Label?.text;
			}
			set
			{
				if (!string.IsNullOrEmpty(value))
				{
					if (m_Label == null)
					{
						InitLabel();
					}
					m_Label.text = value;
				}
				else if (m_Label != null)
				{
					m_Label.RemoveFromHierarchy();
					m_Label = null;
				}
			}
		}

		public BaseBoolField(string label)
			: base(label, (VisualElement)null)
		{
			m_CheckMark = new VisualElement
			{
				name = "unity-checkmark",
				pickingMode = PickingMode.Ignore
			};
			base.visualInput.Add(m_CheckMark);
			base.visualInput.pickingMode = PickingMode.Position;
			text = null;
			this.AddManipulator(m_Clickable = new Clickable(OnClickEvent));
			RegisterCallback<NavigationSubmitEvent>(OnNavigationSubmit);
		}

		private void OnNavigationSubmit(NavigationSubmitEvent evt)
		{
			ToggleValue();
			evt.StopPropagation();
		}

		protected virtual void InitLabel()
		{
			m_Label = new Label();
			base.visualInput.Add(m_Label);
		}

		public override void SetValueWithoutNotify(bool newValue)
		{
			if (newValue)
			{
				base.visualInput.pseudoStates |= PseudoStates.Checked;
				base.pseudoStates |= PseudoStates.Checked;
			}
			else
			{
				base.visualInput.pseudoStates &= ~PseudoStates.Checked;
				base.pseudoStates &= ~PseudoStates.Checked;
			}
			base.SetValueWithoutNotify(newValue);
		}

		private void OnClickEvent(EventBase evt)
		{
			if (evt.eventTypeId == EventBase<MouseUpEvent>.TypeId())
			{
				IMouseEvent mouseEvent = (IMouseEvent)evt;
				if (mouseEvent.button == 0)
				{
					ToggleValue();
				}
			}
			else if (evt.eventTypeId == EventBase<PointerUpEvent>.TypeId() || evt.eventTypeId == EventBase<ClickEvent>.TypeId())
			{
				IPointerEvent pointerEvent = (IPointerEvent)evt;
				if (pointerEvent.button == 0)
				{
					ToggleValue();
				}
			}
		}

		protected virtual void ToggleValue()
		{
			value = !value;
		}

		protected override void UpdateMixedValueContent()
		{
			if (base.showMixedValue)
			{
				base.visualInput.pseudoStates &= ~PseudoStates.Checked;
				base.pseudoStates &= ~PseudoStates.Checked;
				m_CheckMark.RemoveFromHierarchy();
				base.visualInput.Add(base.mixedValueLabel);
				m_OriginalText = text;
				text = "";
			}
			else
			{
				base.mixedValueLabel.RemoveFromHierarchy();
				base.visualInput.Add(m_CheckMark);
				if (m_OriginalText != null)
				{
					text = m_OriginalText;
				}
			}
		}

		internal override void RegisterEditingCallbacks()
		{
			RegisterCallback<PointerUpEvent>(base.StartEditing);
			RegisterCallback<FocusOutEvent>(base.EndEditing);
		}

		internal override void UnregisterEditingCallbacks()
		{
			UnregisterCallback<PointerUpEvent>(base.StartEditing);
			UnregisterCallback<FocusOutEvent>(base.EndEditing);
		}
	}
	internal delegate void RegisterSerializedPropertyBindCallback<TValueType, TField, TFieldValue>(BaseCompositeField<TValueType, TField, TFieldValue> compositeField, TField field) where TField : TextValueField<TFieldValue>, new();
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public abstract class BaseCompositeField<TValueType, TField, TFieldValue> : BaseField<TValueType> where TField : TextValueField<TFieldValue>, new()
	{
		internal struct FieldDescription
		{
			public delegate void WriteDelegate(ref TValueType val, TFieldValue fieldValue);

			internal readonly string name;

			internal readonly string ussName;

			internal readonly Func<TValueType, TFieldValue> read;

			internal readonly WriteDelegate write;

			public FieldDescription(string name, string ussName, Func<TValueType, TFieldValue> read, WriteDelegate write)
			{
				this.name = name;
				this.ussName = ussName;
				this.read = read;
				this.write = write;
			}
		}

		private List<TField> m_Fields;

		private bool m_ShouldUpdateDisplay;

		private bool m_ForceUpdateDisplay;

		private int m_PropertyIndex;

		public new static readonly string ussClassName = "unity-composite-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		public static readonly string spacerUssClassName = ussClassName + "__field-spacer";

		public static readonly string multilineVariantUssClassName = ussClassName + "--multi-line";

		public static readonly string fieldGroupUssClassName = ussClassName + "__field-group";

		public static readonly string fieldUssClassName = ussClassName + "__field";

		public static readonly string firstFieldVariantUssClassName = fieldUssClassName + "--first";

		public static readonly string twoLinesVariantUssClassName = ussClassName + "--two-lines";

		internal List<TField> fields => m_Fields;

		internal int propertyIndex
		{
			get
			{
				return m_PropertyIndex;
			}
			set
			{
				m_PropertyIndex = value;
			}
		}

		internal bool forceUpdateDisplay
		{
			get
			{
				return m_ForceUpdateDisplay;
			}
			set
			{
				m_ForceUpdateDisplay = value;
			}
		}

		private VisualElement GetSpacer()
		{
			VisualElement visualElement = new VisualElement();
			visualElement.AddToClassList(spacerUssClassName);
			visualElement.visible = false;
			visualElement.focusable = false;
			return visualElement;
		}

		internal abstract FieldDescription[] DescribeFields();

		protected BaseCompositeField(string label, int fieldsByLine)
			: base(label, (VisualElement)null)
		{
			base.delegatesFocus = false;
			base.visualInput.focusable = false;
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			m_ShouldUpdateDisplay = true;
			m_Fields = new List<TField>();
			FieldDescription[] array = DescribeFields();
			int num = 1;
			if (fieldsByLine > 1)
			{
				num = array.Length / fieldsByLine;
			}
			bool flag = false;
			if (num > 1)
			{
				flag = true;
				AddToClassList(multilineVariantUssClassName);
			}
			m_PropertyIndex = 0;
			for (int i = 0; i < num; i++)
			{
				VisualElement visualElement = null;
				if (flag)
				{
					visualElement = new VisualElement();
					visualElement.AddToClassList(fieldGroupUssClassName);
				}
				bool flag2 = true;
				for (int j = i * fieldsByLine; j < i * fieldsByLine + fieldsByLine; j++)
				{
					FieldDescription desc = array[j];
					TField field = new TField
					{
						name = desc.ussName
					};
					field.delegatesFocus = true;
					field.AddToClassList(fieldUssClassName);
					if (flag2)
					{
						field.AddToClassList(firstFieldVariantUssClassName);
						flag2 = false;
					}
					field.label = desc.name;
					field.onValidateValue += delegate(TFieldValue newValue)
					{
						TValueType val = value;
						desc.write(ref val, newValue);
						TValueType arg = ValidatedValue(val);
						return desc.read(arg);
					};
					field.RegisterValueChangedCallback(delegate(ChangeEvent<TFieldValue> e)
					{
						TValueType val = value;
						desc.write(ref val, e.newValue);
						string text = e.newValue.ToString();
						string text2 = ((TField)e.currentTarget).text;
						if (text != text2 || field.CanTryParse(text2))
						{
							m_ShouldUpdateDisplay = false;
						}
						value = val;
						m_ShouldUpdateDisplay = true;
					});
					m_Fields.Add(field);
					if (flag)
					{
						visualElement.Add(field);
					}
					else
					{
						base.visualInput.hierarchy.Add(field);
					}
				}
				if (fieldsByLine < 3)
				{
					int num2 = 3 - fieldsByLine;
					for (int num3 = 0; num3 < num2; num3++)
					{
						if (flag)
						{
							visualElement.Add(GetSpacer());
						}
						else
						{
							base.visualInput.hierarchy.Add(GetSpacer());
						}
					}
				}
				if (flag)
				{
					base.visualInput.hierarchy.Add(visualElement);
				}
			}
			UpdateDisplay();
		}

		private void UpdateDisplay()
		{
			if (m_Fields.Count != 0)
			{
				int num = 0;
				FieldDescription[] array = DescribeFields();
				FieldDescription[] array2 = array;
				for (int i = 0; i < array2.Length; i++)
				{
					FieldDescription fieldDescription = array2[i];
					m_Fields[num].SetValueWithoutNotify(fieldDescription.read(base.rawValue));
					num++;
				}
			}
		}

		public override void SetValueWithoutNotify(TValueType newValue)
		{
			bool flag = m_ForceUpdateDisplay || (m_ShouldUpdateDisplay && !EqualityComparer<TValueType>.Default.Equals(base.rawValue, newValue));
			base.SetValueWithoutNotify(newValue);
			if (flag)
			{
				UpdateDisplay();
			}
			m_ForceUpdateDisplay = false;
		}

		internal override void OnViewDataReady()
		{
			m_ForceUpdateDisplay = true;
			base.OnViewDataReady();
		}

		protected override void UpdateMixedValueContent()
		{
			foreach (TField field in m_Fields)
			{
				field.showMixedValue = base.showMixedValue;
			}
		}
	}
	public enum ListViewReorderMode
	{
		Simple,
		Animated
	}
	public abstract class BaseListView : BaseVerticalCollectionView
	{
		public new class UxmlTraits : BaseVerticalCollectionView.UxmlTraits
		{
			private readonly UxmlBoolAttributeDescription m_ShowFoldoutHeader = new UxmlBoolAttributeDescription
			{
				name = "show-foldout-header",
				defaultValue = false
			};

			private readonly UxmlStringAttributeDescription m_HeaderTitle = new UxmlStringAttributeDescription
			{
				name = "header-title",
				defaultValue = string.Empty
			};

			private readonly UxmlBoolAttributeDescription m_ShowAddRemoveFooter = new UxmlBoolAttributeDescription
			{
				name = "show-add-remove-footer",
				defaultValue = false
			};

			private readonly UxmlEnumAttributeDescription<ListViewReorderMode> m_ReorderMode = new UxmlEnumAttributeDescription<ListViewReorderMode>
			{
				name = "reorder-mode",
				defaultValue = ListViewReorderMode.Simple
			};

			private readonly UxmlBoolAttributeDescription m_ShowBoundCollectionSize = new UxmlBoolAttributeDescription
			{
				name = "show-bound-collection-size",
				defaultValue = true
			};

			public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
			{
				get
				{
					yield break;
				}
			}

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				BaseListView baseListView = (BaseListView)ve;
				baseListView.reorderMode = m_ReorderMode.GetValueFromBag(bag, cc);
				baseListView.showFoldoutHeader = m_ShowFoldoutHeader.GetValueFromBag(bag, cc);
				baseListView.headerTitle = m_HeaderTitle.GetValueFromBag(bag, cc);
				baseListView.showAddRemoveFooter = m_ShowAddRemoveFooter.GetValueFromBag(bag, cc);
				baseListView.showBoundCollectionSize = m_ShowBoundCollectionSize.GetValueFromBag(bag, cc);
			}

			protected UxmlTraits()
			{
				m_PickingMode.defaultValue = PickingMode.Ignore;
			}
		}

		private static readonly string k_SizeFieldLabel = "Size";

		private const int k_FoldoutTabIndex = 10;

		private const int k_ArraySizeFieldTabIndex = 20;

		private bool m_ShowBoundCollectionSize = true;

		private bool m_ShowFoldoutHeader;

		private string m_HeaderTitle;

		private Label m_ListViewLabel;

		private Foldout m_Foldout;

		private TextField m_ArraySizeField;

		private bool m_IsOverMultiEditLimit;

		private int m_MaxMultiEditCount;

		private VisualElement m_Footer;

		private Button m_AddButton;

		private Button m_RemoveButton;

		private Action<IEnumerable<int>> m_ItemAddedCallback;

		private Action<IEnumerable<int>> m_ItemRemovedCallback;

		private Action m_ItemsSourceSizeChangedCallback;

		private ListViewReorderMode m_ReorderMode;

		public new static readonly string ussClassName = "unity-list-view";

		public new static readonly string itemUssClassName = ussClassName + "__item";

		public static readonly string emptyLabelUssClassName = ussClassName + "__empty-label";

		public static readonly string overMaxMultiEditLimitClassName = ussClassName + "__over-max-multi-edit-limit-label";

		public static readonly string reorderableUssClassName = ussClassName + "__reorderable";

		public static readonly string reorderableItemUssClassName = reorderableUssClassName + "-item";

		public static readonly string reorderableItemContainerUssClassName = reorderableItemUssClassName + "__container";

		public static readonly string reorderableItemHandleUssClassName = reorderableUssClassName + "-handle";

		public static readonly string reorderableItemHandleBarUssClassName = reorderableItemHandleUssClassName + "-bar";

		public static readonly string footerUssClassName = ussClassName + "__footer";

		public static readonly string foldoutHeaderUssClassName = ussClassName + "__foldout-header";

		public static readonly string arraySizeFieldUssClassName = ussClassName + "__size-field";

		public static readonly string arraySizeFieldWithHeaderUssClassName = arraySizeFieldUssClassName + "--with-header";

		public static readonly string arraySizeFieldWithFooterUssClassName = arraySizeFieldUssClassName + "--with-footer";

		public static readonly string listViewWithHeaderUssClassName = ussClassName + "--with-header";

		public static readonly string listViewWithFooterUssClassName = ussClassName + "--with-footer";

		public static readonly string scrollViewWithFooterUssClassName = ussClassName + "__scroll-view--with-footer";

		public static readonly string footerAddButtonName = ussClassName + "__add-button";

		public static readonly string footerRemoveButtonName = ussClassName + "__remove-button";

		private string m_MaxMultiEditStr;

		private static readonly string k_EmptyListStr = "List is empty";

		public bool showBoundCollectionSize
		{
			get
			{
				return m_ShowBoundCollectionSize;
			}
			set
			{
				if (m_ShowBoundCollectionSize != value)
				{
					m_ShowBoundCollectionSize = value;
					SetupArraySizeField();
				}
			}
		}

		public bool showFoldoutHeader
		{
			get
			{
				return m_ShowFoldoutHeader;
			}
			set
			{
				if (m_ShowFoldoutHeader == value)
				{
					return;
				}
				m_ShowFoldoutHeader = value;
				EnableInClassList(listViewWithHeaderUssClassName, value);
				if (m_ShowFoldoutHeader)
				{
					if (m_Foldout != null)
					{
						return;
					}
					m_Foldout = new Foldout
					{
						name = foldoutHeaderUssClassName,
						text = m_HeaderTitle
					};
					m_Foldout.toggle.tabIndex = 10;
					m_Foldout.toggle.m_Clickable.acceptClicksIfDisabled = true;
					m_Foldout.AddToClassList(foldoutHeaderUssClassName);
					m_Foldout.tabIndex = 1;
					base.hierarchy.Add(m_Foldout);
					m_Foldout.Add(base.scrollView);
				}
				else if (m_Foldout != null)
				{
					m_Foldout?.RemoveFromHierarchy();
					m_Foldout = null;
					base.hierarchy.Add(base.scrollView);
				}
				SetupArraySizeField();
				UpdateListViewLabel();
				if (showAddRemoveFooter)
				{
					EnableFooter(enabled: true);
				}
			}
		}

		public string headerTitle
		{
			get
			{
				return m_HeaderTitle;
			}
			set
			{
				m_HeaderTitle = value;
				if (m_Foldout != null)
				{
					m_Foldout.text = m_HeaderTitle;
				}
			}
		}

		public bool showAddRemoveFooter
		{
			get
			{
				return m_Footer != null;
			}
			set
			{
				EnableFooter(value);
			}
		}

		internal Foldout headerFoldout => m_Foldout;

		internal TextField arraySizeField => m_ArraySizeField;

		internal VisualElement footer => m_Footer;

		public new BaseListViewController viewController => base.viewController as BaseListViewController;

		public ListViewReorderMode reorderMode
		{
			get
			{
				return m_ReorderMode;
			}
			set
			{
				if (value != m_ReorderMode)
				{
					m_ReorderMode = value;
					InitializeDragAndDropController(base.reorderable);
					this.reorderModeChanged?.Invoke();
					Rebuild();
				}
			}
		}

		public event Action<IEnumerable<int>> itemsAdded;

		public event Action<IEnumerable<int>> itemsRemoved;

		internal event Action itemsSourceSizeChanged;

		internal event Action reorderModeChanged;

		internal void SetupArraySizeField()
		{
			if (!showBoundCollectionSize || (!showFoldoutHeader && GetProperty("__unity-collection-view-internal-binding") == null))
			{
				m_ArraySizeField?.RemoveFromHierarchy();
				return;
			}
			if (m_ArraySizeField == null)
			{
				m_ArraySizeField = new TextField
				{
					name = arraySizeFieldUssClassName,
					tabIndex = 20
				};
				m_ArraySizeField.AddToClassList(arraySizeFieldUssClassName);
				m_ArraySizeField.RegisterValueChangedCallback(OnArraySizeFieldChanged);
				m_ArraySizeField.isDelayed = true;
				m_ArraySizeField.focusable = true;
			}
			m_ArraySizeField.EnableInClassList(arraySizeFieldWithFooterUssClassName, showAddRemoveFooter);
			m_ArraySizeField.EnableInClassList(arraySizeFieldWithHeaderUssClassName, showFoldoutHeader);
			if (showFoldoutHeader)
			{
				m_ArraySizeField.label = string.Empty;
				base.hierarchy.Add(m_ArraySizeField);
			}
			else
			{
				m_ArraySizeField.label = k_SizeFieldLabel;
				base.hierarchy.Insert(0, m_ArraySizeField);
			}
			UpdateArraySizeField();
		}

		private void EnableFooter(bool enabled)
		{
			EnableInClassList(listViewWithFooterUssClassName, enabled);
			base.scrollView.EnableInClassList(scrollViewWithFooterUssClassName, enabled);
			if (m_ArraySizeField != null)
			{
				m_ArraySizeField.EnableInClassList(arraySizeFieldWithFooterUssClassName, enabled);
			}
			if (enabled)
			{
				if (m_Footer == null)
				{
					m_Footer = new VisualElement
					{
						name = footerUssClassName
					};
					m_Footer.AddToClassList(footerUssClassName);
					m_AddButton = new Button(OnAddClicked)
					{
						name = footerAddButtonName,
						text = "+"
					};
					m_Footer.Add(m_AddButton);
					m_RemoveButton = new Button(OnRemoveClicked)
					{
						name = footerRemoveButtonName,
						text = "-"
					};
					m_Footer.Add(m_RemoveButton);
				}
				if (m_Foldout != null)
				{
					m_Foldout.contentContainer.Add(m_Footer);
				}
				else
				{
					base.hierarchy.Add(m_Footer);
				}
			}
			else
			{
				m_RemoveButton?.RemoveFromHierarchy();
				m_AddButton?.RemoveFromHierarchy();
				m_Footer?.RemoveFromHierarchy();
				m_RemoveButton = null;
				m_AddButton = null;
				m_Footer = null;
			}
		}

		private void AddItems(int itemCount)
		{
			viewController.AddItems(itemCount);
		}

		private void RemoveItems(List<int> indices)
		{
			viewController.RemoveItems(indices);
		}

		private void OnArraySizeFieldChanged(ChangeEvent<string> evt)
		{
			if (m_ArraySizeField.showMixedValue && BaseField<string>.mixedValueString == evt.newValue)
			{
				return;
			}
			if (!int.TryParse(evt.newValue, out var result) || result < 0)
			{
				m_ArraySizeField.SetValueWithoutNotify(evt.previousValue);
				return;
			}
			int itemsCount = viewController.GetItemsCount();
			if (itemsCount != 0 || result != viewController.GetItemsMinCount())
			{
				if (result > itemsCount)
				{
					viewController.AddItems(result - itemsCount);
				}
				else if (result < itemsCount)
				{
					viewController.RemoveItems(itemsCount - result);
				}
				else if (result == 0)
				{
					viewController.ClearItems();
					m_IsOverMultiEditLimit = false;
				}
				UpdateListViewLabel();
			}
		}

		internal void UpdateArraySizeField()
		{
			if (HasValidDataAndBindings() && m_ArraySizeField != null)
			{
				if (!m_ArraySizeField.showMixedValue)
				{
					m_ArraySizeField.SetValueWithoutNotify(viewController.GetItemsMinCount().ToString());
				}
				footer?.SetEnabled(!m_IsOverMultiEditLimit);
			}
		}

		internal void UpdateListViewLabel()
		{
			if (!HasValidDataAndBindings())
			{
				return;
			}
			bool flag = base.itemsSource.Count == 0;
			if (m_IsOverMultiEditLimit)
			{
				if (m_ListViewLabel == null)
				{
					m_ListViewLabel = new Label();
				}
				m_ListViewLabel.text = m_MaxMultiEditStr;
				base.scrollView.contentViewport.Add(m_ListViewLabel);
			}
			else if (flag)
			{
				if (m_ListViewLabel == null)
				{
					m_ListViewLabel = new Label();
				}
				m_ListViewLabel.text = k_EmptyListStr;
				base.scrollView.contentViewport.Add(m_ListViewLabel);
			}
			else
			{
				m_ListViewLabel?.RemoveFromHierarchy();
				m_ListViewLabel = null;
			}
			m_ListViewLabel?.EnableInClassList(emptyLabelUssClassName, flag);
			m_ListViewLabel?.EnableInClassList(overMaxMultiEditLimitClassName, m_IsOverMultiEditLimit);
		}

		private void OnAddClicked()
		{
			AddItems(1);
			if (base.binding == null)
			{
				SetSelection(base.itemsSource.Count - 1);
				ScrollToItem(-1);
			}
			else
			{
				base.schedule.Execute((Action)delegate
				{
					SetSelection(base.itemsSource.Count - 1);
					ScrollToItem(-1);
				}).ExecuteLater(100L);
			}
			if (HasValidDataAndBindings() && m_ArraySizeField != null)
			{
				m_ArraySizeField.showMixedValue = false;
			}
		}

		private void OnRemoveClicked()
		{
			if (base.selectedIndices.Any())
			{
				viewController.RemoveItems(base.selectedIndices.ToList());
				ClearSelection();
			}
			else if (base.itemsSource.Count > 0)
			{
				int index = base.itemsSource.Count - 1;
				viewController.RemoveItem(index);
			}
			if (HasValidDataAndBindings() && m_ArraySizeField != null)
			{
				m_ArraySizeField.showMixedValue = false;
			}
		}

		internal void SetOverMaxMultiEditLimit(bool isOverLimit, int maxMultiEditCount)
		{
			m_IsOverMultiEditLimit = isOverLimit;
			m_MaxMultiEditCount = maxMultiEditCount;
			m_MaxMultiEditStr = $"This field cannot display arrays with more than {m_MaxMultiEditCount} elements when multiple objects are selected.";
		}

		private protected override void CreateVirtualizationController()
		{
			CreateVirtualizationController<ReusableListViewItem>();
		}

		public override void SetViewController(CollectionViewController controller)
		{
			if (m_ItemAddedCallback == null)
			{
				m_ItemAddedCallback = OnItemAdded;
			}
			if (m_ItemRemovedCallback == null)
			{
				m_ItemRemovedCallback = OnItemsRemoved;
			}
			if (m_ItemsSourceSizeChangedCallback == null)
			{
				m_ItemsSourceSizeChangedCallback = OnItemsSourceSizeChanged;
			}
			if (viewController != null)
			{
				viewController.itemsAdded -= m_ItemAddedCallback;
				viewController.itemsRemoved -= m_ItemRemovedCallback;
				viewController.itemsSourceSizeChanged -= m_ItemsSourceSizeChangedCallback;
			}
			base.SetViewController(controller);
			if (viewController != null)
			{
				viewController.itemsAdded += m_ItemAddedCallback;
				viewController.itemsRemoved += m_ItemRemovedCallback;
				viewController.itemsSourceSizeChanged += m_ItemsSourceSizeChangedCallback;
			}
		}

		private void OnItemAdded(IEnumerable<int> indices)
		{
			this.itemsAdded?.Invoke(indices);
		}

		private void OnItemsRemoved(IEnumerable<int> indices)
		{
			this.itemsRemoved?.Invoke(indices);
		}

		private void OnItemsSourceSizeChanged()
		{
			if (GetProperty("__unity-collection-view-internal-binding") == null)
			{
				RefreshItems();
			}
			this.itemsSourceSizeChanged?.Invoke();
		}

		internal override ListViewDragger CreateDragger()
		{
			if (m_ReorderMode == ListViewReorderMode.Simple)
			{
				return new ListViewDragger(this);
			}
			return new ListViewDraggerAnimated(this);
		}

		internal override ICollectionDragAndDropController CreateDragAndDropController()
		{
			return new ListViewReorderableDragAndDropController(this);
		}

		public BaseListView()
		{
			AddToClassList(ussClassName);
			base.pickingMode = PickingMode.Ignore;
		}

		public BaseListView(IList itemsSource, float itemHeight = -1f)
			: base(itemsSource, itemHeight)
		{
			AddToClassList(ussClassName);
			base.pickingMode = PickingMode.Ignore;
		}

		private protected override void PostRefresh()
		{
			UpdateArraySizeField();
			UpdateListViewLabel();
			base.PostRefresh();
		}

		private protected override bool HandleItemNavigation(bool moveIn, bool altPressed)
		{
			bool result = false;
			foreach (int selectedIndex in base.selectedIndices)
			{
				foreach (ReusableCollectionItem activeItem in base.activeItems)
				{
					if (activeItem.index == selectedIndex && GetProperty("__unity-collection-view-internal-binding") != null)
					{
						Foldout foldout = activeItem.bindableElement.Q<Foldout>();
						if (foldout != null)
						{
							foldout.value = moveIn;
							result = true;
						}
					}
				}
			}
			return result;
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public abstract class BasePopupField<TValueType, TValueChoice> : BaseField<TValueType>
	{
		private class PopupTextElement : TextElement
		{
			protected internal override Vector2 DoMeasure(float desiredWidth, MeasureMode widthMode, float desiredHeight, MeasureMode heightMode)
			{
				string text = this.text;
				if (string.IsNullOrEmpty(text))
				{
					text = " ";
				}
				return MeasureTextSize(text, desiredWidth, widthMode, desiredHeight, heightMode);
			}
		}

		internal List<TValueChoice> m_Choices;

		private TextElement m_TextElement;

		private VisualElement m_ArrowElement;

		internal Func<TValueChoice, string> m_FormatSelectedValueCallback;

		internal Func<TValueChoice, string> m_FormatListItemCallback;

		internal Func<IGenericMenu> createMenuCallback;

		public new static readonly string ussClassName = "unity-base-popup-field";

		public static readonly string textUssClassName = ussClassName + "__text";

		public static readonly string arrowUssClassName = ussClassName + "__arrow";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		protected TextElement textElement => m_TextElement;

		public virtual List<TValueChoice> choices
		{
			get
			{
				return m_Choices;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				m_Choices = value;
				SetValueWithoutNotify(base.rawValue);
			}
		}

		public string text => m_TextElement.text;

		internal abstract string GetValueToDisplay();

		internal abstract string GetListItemToDisplay(TValueType item);

		internal abstract void AddMenuItems(IGenericMenu menu);

		public override void SetValueWithoutNotify(TValueType newValue)
		{
			base.SetValueWithoutNotify(newValue);
			((INotifyValueChanged<string>)m_TextElement).SetValueWithoutNotify(GetValueToDisplay());
		}

		internal BasePopupField()
			: this((string)null)
		{
		}

		internal BasePopupField(string label)
			: base(label, (VisualElement)null)
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			m_TextElement = new PopupTextElement
			{
				pickingMode = PickingMode.Ignore
			};
			m_TextElement.AddToClassList(textUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			base.visualInput.Add(m_TextElement);
			m_ArrowElement = new VisualElement();
			m_ArrowElement.AddToClassList(arrowUssClassName);
			m_ArrowElement.pickingMode = PickingMode.Ignore;
			base.visualInput.Add(m_ArrowElement);
			choices = new List<TValueChoice>();
			RegisterCallback<PointerDownEvent>(OnPointerDownEvent);
			RegisterCallback<PointerMoveEvent>(OnPointerMoveEvent);
			RegisterCallback(delegate(MouseDownEvent e)
			{
				if (e.button == 0)
				{
					e.StopPropagation();
				}
			});
			RegisterCallback<NavigationSubmitEvent>(OnNavigationSubmit);
		}

		private void OnPointerDownEvent(PointerDownEvent evt)
		{
			ProcessPointerDown(evt);
		}

		private void OnPointerMoveEvent(PointerMoveEvent evt)
		{
			if (evt.button == 0 && (evt.pressedButtons & 1) != 0)
			{
				ProcessPointerDown(evt);
			}
		}

		private bool ContainsPointer(int pointerId)
		{
			VisualElement topElementUnderPointer = base.elementPanel.GetTopElementUnderPointer(pointerId);
			return this == topElementUnderPointer || base.visualInput == topElementUnderPointer;
		}

		private void ProcessPointerDown<T>(PointerEventBase<T> evt) where T : PointerEventBase<T>, new()
		{
			if (evt.button == 0 && ContainsPointer(evt.pointerId))
			{
				base.schedule.Execute(ShowMenu);
				evt.StopPropagation();
			}
		}

		private void OnNavigationSubmit(NavigationSubmitEvent evt)
		{
			ShowMenu();
			evt.StopPropagation();
		}

		internal void ShowMenu()
		{
			IGenericMenu genericMenu;
			if (createMenuCallback != null)
			{
				genericMenu = createMenuCallback();
			}
			else
			{
				BaseVisualElementPanel baseVisualElementPanel = base.elementPanel;
				IGenericMenu genericMenu2;
				if (baseVisualElementPanel == null || baseVisualElementPanel.contextType != ContextType.Player)
				{
					genericMenu2 = DropdownUtility.CreateDropdown();
				}
				else
				{
					IGenericMenu genericMenu3 = new GenericDropdownMenu();
					genericMenu2 = genericMenu3;
				}
				genericMenu = genericMenu2;
			}
			AddMenuItems(genericMenu);
			genericMenu.DropDown(base.visualInput.worldBound, this, anchored: true);
		}

		protected override void UpdateMixedValueContent()
		{
			if (base.showMixedValue)
			{
				((INotifyValueChanged<string>)m_TextElement).SetValueWithoutNotify(BaseField<TValueType>.mixedValueString);
			}
			textElement.EnableInClassList(BaseField<TValueType>.mixedValueLabelUssClassName, base.showMixedValue);
		}
	}
	public enum SliderDirection
	{
		Horizontal,
		Vertical
	}
	public abstract class BaseSlider<TValueType> : BaseField<TValueType>, IValueField<TValueType> where TValueType : IComparable<TValueType>
	{
		public new class UxmlTraits : BaseField<TValueType>.UxmlTraits
		{
			public UxmlTraits()
			{
				m_PickingMode.defaultValue = PickingMode.Ignore;
			}
		}

		internal enum SliderKey
		{
			None,
			Lowest,
			LowerPage,
			Lower,
			Higher,
			HigherPage,
			Highest
		}

		private bool m_IsEditingTextField;

		[SerializeField]
		private TValueType m_LowValue;

		[SerializeField]
		private TValueType m_HighValue;

		private float m_PageSize;

		private bool m_ShowInputField = false;

		private Rect m_DragElementStartPos;

		private SliderDirection m_Direction;

		private bool m_Inverted = false;

		internal const float kDefaultPageSize = 0f;

		internal const bool kDefaultShowInputField = false;

		internal const bool kDefaultInverted = false;

		public new static readonly string ussClassName = "unity-base-slider";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		public static readonly string horizontalVariantUssClassName = ussClassName + "--horizontal";

		public static readonly string verticalVariantUssClassName = ussClassName + "--vertical";

		public static readonly string dragContainerUssClassName = ussClassName + "__drag-container";

		public static readonly string trackerUssClassName = ussClassName + "__tracker";

		public static readonly string draggerUssClassName = ussClassName + "__dragger";

		public static readonly string draggerBorderUssClassName = ussClassName + "__dragger-border";

		public static readonly string textFieldClassName = ussClassName + "__text-field";

		internal VisualElement dragContainer { get; private set; }

		internal VisualElement dragElement { get; private set; }

		internal VisualElement trackElement { get; private set; }

		internal VisualElement dragBorderElement { get; private set; }

		internal TextField inputTextField { get; private set; }

		public TValueType lowValue
		{
			get
			{
				return m_LowValue;
			}
			set
			{
				if (!EqualityComparer<TValueType>.Default.Equals(m_LowValue, value))
				{
					m_LowValue = value;
					ClampValue();
					UpdateDragElementPosition();
					SaveViewData();
				}
			}
		}

		public TValueType highValue
		{
			get
			{
				return m_HighValue;
			}
			set
			{
				if (!EqualityComparer<TValueType>.Default.Equals(m_HighValue, value))
				{
					m_HighValue = value;
					ClampValue();
					UpdateDragElementPosition();
					SaveViewData();
				}
			}
		}

		public TValueType range => SliderRange();

		public virtual float pageSize
		{
			get
			{
				return m_PageSize;
			}
			set
			{
				m_PageSize = value;
			}
		}

		public virtual bool showInputField
		{
			get
			{
				return m_ShowInputField;
			}
			set
			{
				if (m_ShowInputField != value)
				{
					m_ShowInputField = value;
					UpdateTextFieldVisibility();
				}
			}
		}

		internal bool clamped { get; set; } = true;

		internal ClampedDragger<TValueType> clampedDragger { get; private set; }

		public override TValueType value
		{
			get
			{
				return base.value;
			}
			set
			{
				TValueType val = (clamped ? GetClampedValue(value) : value);
				base.value = val;
			}
		}

		public SliderDirection direction
		{
			get
			{
				return m_Direction;
			}
			set
			{
				m_Direction = value;
				if (m_Direction == SliderDirection.Horizontal)
				{
					RemoveFromClassList(verticalVariantUssClassName);
					AddToClassList(horizontalVariantUssClassName);
				}
				else
				{
					RemoveFromClassList(horizontalVariantUssClassName);
					AddToClassList(verticalVariantUssClassName);
				}
			}
		}

		public bool inverted
		{
			get
			{
				return m_Inverted;
			}
			set
			{
				if (m_Inverted != value)
				{
					m_Inverted = value;
					UpdateDragElementPosition();
				}
			}
		}

		internal void SetHighValueWithoutNotify(TValueType newHighValue)
		{
			m_HighValue = newHighValue;
			TValueType valueWithoutNotify = (clamped ? GetClampedValue(value) : value);
			SetValueWithoutNotify(valueWithoutNotify);
			UpdateDragElementPosition();
			SaveViewData();
		}

		private TValueType Clamp(TValueType value, TValueType lowBound, TValueType highBound)
		{
			TValueType result = value;
			if (lowBound.CompareTo(value) > 0)
			{
				result = lowBound;
			}
			else if (highBound.CompareTo(value) < 0)
			{
				result = highBound;
			}
			return result;
		}

		private TValueType GetClampedValue(TValueType newValue)
		{
			TValueType val = lowValue;
			TValueType val2 = highValue;
			if (val.CompareTo(val2) > 0)
			{
				TValueType val3 = val;
				val = val2;
				val2 = val3;
			}
			return Clamp(newValue, val, val2);
		}

		public virtual void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, TValueType startValue)
		{
		}

		void IValueField<TValueType>.StartDragging()
		{
		}

		void IValueField<TValueType>.StopDragging()
		{
		}

		public override void SetValueWithoutNotify(TValueType newValue)
		{
			TValueType valueWithoutNotify = (clamped ? GetClampedValue(newValue) : newValue);
			base.SetValueWithoutNotify(valueWithoutNotify);
			UpdateDragElementPosition();
			UpdateTextFieldValue();
		}

		internal BaseSlider(string label, TValueType start, TValueType end, SliderDirection direction = SliderDirection.Horizontal, float pageSize = 0f)
			: base(label, (VisualElement)null)
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			this.direction = direction;
			this.pageSize = pageSize;
			lowValue = start;
			highValue = end;
			base.pickingMode = PickingMode.Ignore;
			dragContainer = new VisualElement
			{
				name = "unity-drag-container"
			};
			dragContainer.AddToClassList(dragContainerUssClassName);
			dragContainer.RegisterCallback<GeometryChangedEvent>(UpdateDragElementPosition);
			base.visualInput.Add(dragContainer);
			trackElement = new VisualElement
			{
				name = "unity-tracker",
				usageHints = UsageHints.DynamicColor
			};
			trackElement.AddToClassList(trackerUssClassName);
			dragContainer.Add(trackElement);
			dragBorderElement = new VisualElement
			{
				name = "unity-dragger-border"
			};
			dragBorderElement.AddToClassList(draggerBorderUssClassName);
			dragContainer.Add(dragBorderElement);
			dragElement = new VisualElement
			{
				name = "unity-dragger",
				usageHints = UsageHints.DynamicTransform
			};
			dragElement.RegisterCallback<GeometryChangedEvent>(UpdateDragElementPosition);
			dragElement.AddToClassList(draggerUssClassName);
			dragContainer.Add(dragElement);
			clampedDragger = new ClampedDragger<TValueType>(this, SetSliderValueFromClick, SetSliderValueFromDrag);
			dragContainer.pickingMode = PickingMode.Position;
			dragContainer.AddManipulator(clampedDragger);
			RegisterCallback<KeyDownEvent>(OnKeyDown);
			RegisterCallback<NavigationMoveEvent>(OnNavigationMove);
			UpdateTextFieldVisibility();
			FieldMouseDragger<TValueType> fieldMouseDragger = new FieldMouseDragger<TValueType>(this);
			fieldMouseDragger.SetDragZone(base.labelElement);
			base.labelElement.AddToClassList(BaseField<TValueType>.labelDraggerVariantUssClassName);
		}

		protected static float GetClosestPowerOfTen(float positiveNumber)
		{
			if (positiveNumber <= 0f)
			{
				return 1f;
			}
			return Mathf.Pow(10f, Mathf.RoundToInt(Mathf.Log10(positiveNumber)));
		}

		protected static float RoundToMultipleOf(float value, float roundingValue)
		{
			if (roundingValue == 0f)
			{
				return value;
			}
			return Mathf.Round(value / roundingValue) * roundingValue;
		}

		private void ClampValue()
		{
			value = base.rawValue;
		}

		internal abstract TValueType SliderLerpUnclamped(TValueType a, TValueType b, float interpolant);

		internal abstract float SliderNormalizeValue(TValueType currentValue, TValueType lowerValue, TValueType higherValue);

		internal abstract TValueType SliderRange();

		internal abstract TValueType ParseStringToValue(string previousValue, string newValue);

		internal abstract void ComputeValueFromKey(SliderKey sliderKey, bool isShift);

		private TValueType SliderLerpDirectionalUnclamped(TValueType a, TValueType b, float positionInterpolant)
		{
			float interpolant = ((direction == SliderDirection.Vertical) ? (1f - positionInterpolant) : positionInterpolant);
			if (inverted)
			{
				return SliderLerpUnclamped(b, a, interpolant);
			}
			return SliderLerpUnclamped(a, b, interpolant);
		}

		private void SetSliderValueFromDrag()
		{
			if (clampedDragger.dragDirection == ClampedDragger<TValueType>.DragDirection.Free)
			{
				Vector2 delta = clampedDragger.delta;
				if (direction == SliderDirection.Horizontal)
				{
					ComputeValueAndDirectionFromDrag(dragContainer.resolvedStyle.width, dragElement.resolvedStyle.width, m_DragElementStartPos.x + delta.x);
				}
				else
				{
					ComputeValueAndDirectionFromDrag(dragContainer.resolvedStyle.height, dragElement.resolvedStyle.height, m_DragElementStartPos.y + delta.y);
				}
			}
		}

		private void ComputeValueAndDirectionFromDrag(float sliderLength, float dragElementLength, float dragElementPos)
		{
			float num = sliderLength - dragElementLength;
			if (!(Mathf.Abs(num) < 1E-30f))
			{
				value = SliderLerpDirectionalUnclamped(positionInterpolant: (!clamped) ? (dragElementPos / num) : (Mathf.Max(0f, Mathf.Min(dragElementPos, num)) / num), a: lowValue, b: highValue);
			}
		}

		private void SetSliderValueFromClick()
		{
			if (clampedDragger.dragDirection == ClampedDragger<TValueType>.DragDirection.Free)
			{
				return;
			}
			if (clampedDragger.dragDirection == ClampedDragger<TValueType>.DragDirection.None)
			{
				if (Mathf.Approximately(pageSize, 0f))
				{
					float num;
					float num2;
					float num3;
					float num4;
					float dragElementPos;
					if (direction == SliderDirection.Horizontal)
					{
						num = dragContainer.resolvedStyle.width;
						num2 = dragElement.resolvedStyle.width;
						float b = num - num2;
						float a = clampedDragger.startMousePosition.x - num2 / 2f;
						num3 = Mathf.Max(0f, Mathf.Min(a, b));
						num4 = dragElement.transform.position.y;
						dragElementPos = num3;
					}
					else
					{
						num = dragContainer.resolvedStyle.height;
						num2 = dragElement.resolvedStyle.height;
						float b2 = num - num2;
						float a2 = clampedDragger.startMousePosition.y - num2 / 2f;
						num3 = dragElement.transform.position.x;
						num4 = Mathf.Max(0f, Mathf.Min(a2, b2));
						dragElementPos = num4;
					}
					Vector3 position = new Vector3(num3, num4, 0f);
					dragElement.transform.position = position;
					dragBorderElement.transform.position = position;
					m_DragElementStartPos = new Rect(num3, num4, dragElement.resolvedStyle.width, dragElement.resolvedStyle.height);
					clampedDragger.dragDirection = ClampedDragger<TValueType>.DragDirection.Free;
					ComputeValueAndDirectionFromDrag(num, num2, dragElementPos);
					return;
				}
				m_DragElementStartPos = new Rect(dragElement.transform.position.x, dragElement.transform.position.y, dragElement.resolvedStyle.width, dragElement.resolvedStyle.height);
			}
			if (direction == SliderDirection.Horizontal)
			{
				ComputeValueAndDirectionFromClick(dragContainer.resolvedStyle.width, dragElement.resolvedStyle.width, dragElement.transform.position.x, clampedDragger.lastMousePosition.x);
			}
			else
			{
				ComputeValueAndDirectionFromClick(dragContainer.resolvedStyle.height, dragElement.resolvedStyle.height, dragElement.transform.position.y, clampedDragger.lastMousePosition.y);
			}
		}

		private void OnKeyDown(KeyDownEvent evt)
		{
			SliderKey sliderKey = SliderKey.None;
			bool flag = direction == SliderDirection.Horizontal;
			if ((flag && evt.keyCode == KeyCode.Home) || (!flag && evt.keyCode == KeyCode.End))
			{
				sliderKey = ((!inverted) ? SliderKey.Lowest : SliderKey.Highest);
			}
			else if ((flag && evt.keyCode == KeyCode.End) || (!flag && evt.keyCode == KeyCode.Home))
			{
				sliderKey = (inverted ? SliderKey.Lowest : SliderKey.Highest);
			}
			else if ((flag && evt.keyCode == KeyCode.PageUp) || (!flag && evt.keyCode == KeyCode.PageDown))
			{
				sliderKey = (inverted ? SliderKey.HigherPage : SliderKey.LowerPage);
			}
			else if ((flag && evt.keyCode == KeyCode.PageDown) || (!flag && evt.keyCode == KeyCode.PageUp))
			{
				sliderKey = (inverted ? SliderKey.LowerPage : SliderKey.HigherPage);
			}
			if (sliderKey != SliderKey.None)
			{
				ComputeValueFromKey(sliderKey, evt.shiftKey);
				evt.StopPropagation();
			}
		}

		private void OnNavigationMove(NavigationMoveEvent evt)
		{
			SliderKey sliderKey = SliderKey.None;
			bool flag = direction == SliderDirection.Horizontal;
			if (evt.direction == (NavigationMoveEvent.Direction)(flag ? 1 : 4))
			{
				sliderKey = (inverted ? SliderKey.Higher : SliderKey.Lower);
			}
			else if (evt.direction == (NavigationMoveEvent.Direction)(flag ? 3 : 2))
			{
				sliderKey = (inverted ? SliderKey.Lower : SliderKey.Higher);
			}
			if (sliderKey != SliderKey.None)
			{
				ComputeValueFromKey(sliderKey, evt.shiftKey);
				evt.StopPropagation();
				evt.PreventDefault();
			}
		}

		internal virtual void ComputeValueAndDirectionFromClick(float sliderLength, float dragElementLength, float dragElementPos, float dragElementLastPos)
		{
			float num = sliderLength - dragElementLength;
			if (!(Mathf.Abs(num) < 1E-30f))
			{
				bool flag = dragElementLastPos < dragElementPos;
				bool flag2 = dragElementLastPos > dragElementPos + dragElementLength;
				bool flag3 = (inverted ? flag2 : flag);
				bool flag4 = (inverted ? flag : flag2);
				float num2 = (inverted ? (0f - pageSize) : pageSize);
				if (flag3 && clampedDragger.dragDirection != ClampedDragger<TValueType>.DragDirection.LowToHigh)
				{
					clampedDragger.dragDirection = ClampedDragger<TValueType>.DragDirection.HighToLow;
					float positionInterpolant = Mathf.Max(0f, Mathf.Min(dragElementPos - num2, num)) / num;
					value = SliderLerpDirectionalUnclamped(lowValue, highValue, positionInterpolant);
				}
				else if (flag4 && clampedDragger.dragDirection != ClampedDragger<TValueType>.DragDirection.HighToLow)
				{
					clampedDragger.dragDirection = ClampedDragger<TValueType>.DragDirection.LowToHigh;
					float positionInterpolant2 = Mathf.Max(0f, Mathf.Min(dragElementPos + num2, num)) / num;
					value = SliderLerpDirectionalUnclamped(lowValue, highValue, positionInterpolant2);
				}
			}
		}

		public void AdjustDragElement(float factor)
		{
			bool flag = factor < 1f;
			dragElement.visible = flag;
			if (flag)
			{
				IStyle style = dragElement.style;
				dragElement.style.visibility = StyleKeyword.Null;
				if (direction == SliderDirection.Horizontal)
				{
					float b = ((base.resolvedStyle.minWidth == StyleKeyword.Auto) ? 0f : base.resolvedStyle.minWidth.value);
					style.width = Mathf.Round(Mathf.Max(dragContainer.layout.width * factor, b));
				}
				else
				{
					float b2 = ((base.resolvedStyle.minHeight == StyleKeyword.Auto) ? 0f : base.resolvedStyle.minHeight.value);
					style.height = Mathf.Round(Mathf.Max(dragContainer.layout.height * factor, b2));
				}
			}
			dragBorderElement.visible = dragElement.visible;
		}

		private void UpdateDragElementPosition(GeometryChangedEvent evt)
		{
			if (!(evt.oldRect.size == evt.newRect.size))
			{
				UpdateDragElementPosition();
			}
		}

		internal override void OnViewDataReady()
		{
			base.OnViewDataReady();
			UpdateDragElementPosition();
		}

		private bool SameValues(float a, float b, float epsilon)
		{
			return Mathf.Abs(b - a) < epsilon;
		}

		private void UpdateDragElementPosition()
		{
			if (base.panel == null)
			{
				return;
			}
			float num = SliderNormalizeValue(value, lowValue, highValue);
			float num2 = (inverted ? (1f - num) : num);
			float epsilon = base.scaledPixelsPerPoint * 0.5f;
			if (direction == SliderDirection.Horizontal)
			{
				float width = dragElement.resolvedStyle.width;
				float num3 = 0f - dragElement.resolvedStyle.marginLeft - dragElement.resolvedStyle.marginRight;
				float num4 = dragContainer.layout.width - width + num3;
				float num5 = num2 * num4;
				if (!float.IsNaN(num5))
				{
					float x = dragElement.transform.position.x;
					if (!SameValues(x, num5, epsilon))
					{
						Vector3 position = new Vector3(num5, 0f, 0f);
						dragElement.transform.position = position;
						dragBorderElement.transform.position = position;
					}
				}
				return;
			}
			float height = dragElement.resolvedStyle.height;
			float num6 = dragContainer.resolvedStyle.height - height;
			float num7 = (1f - num2) * num6;
			if (!float.IsNaN(num7))
			{
				float y = dragElement.transform.position.y;
				if (!SameValues(y, num7, epsilon))
				{
					Vector3 position2 = new Vector3(0f, num7, 0f);
					dragElement.transform.position = position2;
					dragBorderElement.transform.position = position2;
				}
			}
		}

		[EventInterest(new Type[] { typeof(GeometryChangedEvent) })]
		protected override void ExecuteDefaultAction(EventBase evt)
		{
			base.ExecuteDefaultAction(evt);
			if (evt != null && evt.eventTypeId == EventBase<GeometryChangedEvent>.TypeId())
			{
				UpdateDragElementPosition((GeometryChangedEvent)evt);
			}
		}

		private void UpdateTextFieldVisibility()
		{
			if (showInputField)
			{
				if (inputTextField == null)
				{
					inputTextField = new TextField
					{
						name = "unity-text-field"
					};
					inputTextField.AddToClassList(textFieldClassName);
					inputTextField.RegisterCallback<NavigationMoveEvent>(OnInputNavigationMoveEvent, TrickleDown.TrickleDown);
					inputTextField.RegisterValueChangedCallback(OnTextFieldValueChange);
					inputTextField.RegisterCallback<FocusInEvent>(OnTextFieldFocusIn);
					inputTextField.RegisterCallback<FocusOutEvent>(OnTextFieldFocusOut);
					base.visualInput.Add(inputTextField);
					UpdateTextFieldValue();
				}
			}
			else if (inputTextField != null && inputTextField.panel != null)
			{
				if (inputTextField.panel != null)
				{
					inputTextField.RemoveFromHierarchy();
				}
				inputTextField.UnregisterCallback<NavigationMoveEvent>(OnInputNavigationMoveEvent);
				inputTextField.UnregisterValueChangedCallback(OnTextFieldValueChange);
				inputTextField.UnregisterCallback<FocusInEvent>(OnTextFieldFocusIn);
				inputTextField.UnregisterCallback<FocusOutEvent>(OnTextFieldFocusOut);
				inputTextField = null;
			}
		}

		private void UpdateTextFieldValue()
		{
			if (inputTextField != null && !m_IsEditingTextField)
			{
				inputTextField.SetValueWithoutNotify(string.Format(CultureInfo.InvariantCulture, "{0:g7}", value));
			}
		}

		private void OnTextFieldFocusIn(FocusInEvent evt)
		{
			m_IsEditingTextField = true;
		}

		private void OnTextFieldFocusOut(FocusOutEvent evt)
		{
			m_IsEditingTextField = false;
			UpdateTextFieldValue();
		}

		private void OnInputNavigationMoveEvent(NavigationMoveEvent evt)
		{
			evt.StopPropagation();
		}

		private void OnTextFieldValueChange(ChangeEvent<string> evt)
		{
			TValueType clampedValue = GetClampedValue(ParseStringToValue(evt.previousValue, evt.newValue));
			if (!EqualityComparer<TValueType>.Default.Equals(clampedValue, value))
			{
				value = clampedValue;
				evt.StopPropagation();
				if (base.elementPanel != null)
				{
					OnViewDataReady();
				}
			}
		}

		protected override void UpdateMixedValueContent()
		{
			if (base.showMixedValue)
			{
				dragElement?.RemoveFromHierarchy();
			}
			else
			{
				dragContainer.Add(dragElement);
			}
		}

		internal override void RegisterEditingCallbacks()
		{
			base.labelElement.RegisterCallback<PointerDownEvent>(base.StartEditing, TrickleDown.TrickleDown);
			dragContainer.RegisterCallback<PointerDownEvent>(base.StartEditing, TrickleDown.TrickleDown);
			dragContainer.RegisterCallback<PointerUpEvent>(base.EndEditing);
		}

		internal override void UnregisterEditingCallbacks()
		{
			base.labelElement.UnregisterCallback<PointerDownEvent>(base.StartEditing, TrickleDown.TrickleDown);
			dragContainer.UnregisterCallback<PointerDownEvent>(base.StartEditing, TrickleDown.TrickleDown);
			dragContainer.UnregisterCallback<PointerUpEvent>(base.EndEditing);
		}
	}
	public abstract class BaseTreeView : BaseVerticalCollectionView
	{
		public new class UxmlTraits : BaseVerticalCollectionView.UxmlTraits
		{
			private readonly UxmlBoolAttributeDescription m_AutoExpand = new UxmlBoolAttributeDescription
			{
				name = "auto-expand",
				defaultValue = false
			};

			public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
			{
				get
				{
					yield break;
				}
			}

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				BaseTreeView baseTreeView = (BaseTreeView)ve;
				baseTreeView.autoExpand = m_AutoExpand.GetValueFromBag(bag, cc);
			}
		}

		public new static readonly string ussClassName = "unity-tree-view";

		public new static readonly string itemUssClassName = ussClassName + "__item";

		public static readonly string itemToggleUssClassName = ussClassName + "__item-toggle";

		public static readonly string itemIndentsContainerUssClassName = ussClassName + "__item-indents";

		public static readonly string itemIndentUssClassName = ussClassName + "__item-indent";

		public static readonly string itemContentContainerUssClassName = ussClassName + "__item-content";

		private bool m_AutoExpand;

		[SerializeField]
		private List<int> m_ExpandedItemIds;

		public new IList itemsSource
		{
			get
			{
				return viewController.itemsSource;
			}
			internal set
			{
				GetOrCreateViewController().itemsSource = value;
			}
		}

		public new BaseTreeViewController viewController => base.viewController as BaseTreeViewController;

		public bool autoExpand
		{
			get
			{
				return m_AutoExpand;
			}
			set
			{
				m_AutoExpand = value;
				viewController?.RegenerateWrappers();
				RefreshItems();
			}
		}

		internal List<int> expandedItemIds
		{
			get
			{
				return m_ExpandedItemIds;
			}
			set
			{
				m_ExpandedItemIds = value;
			}
		}

		public void SetRootItems<T>(IList<TreeViewItemData<T>> rootItems)
		{
			SetRootItemsInternal(rootItems);
		}

		internal abstract void SetRootItemsInternal<T>(IList<TreeViewItemData<T>> rootItems);

		public IEnumerable<int> GetRootIds()
		{
			return viewController.GetRootItemIds();
		}

		public int GetTreeCount()
		{
			return viewController.GetTreeItemsCount();
		}

		private protected override void CreateVirtualizationController()
		{
			CreateVirtualizationController<ReusableTreeViewItem>();
		}

		public override void SetViewController(CollectionViewController controller)
		{
			if (viewController != null)
			{
				viewController.itemIndexChanged -= OnItemIndexChanged;
			}
			base.SetViewController(controller);
			if (viewController != null)
			{
				viewController.itemIndexChanged += OnItemIndexChanged;
			}
		}

		private void OnItemIndexChanged(int srcIndex, int dstIndex)
		{
			RefreshItems();
		}

		internal override ICollectionDragAndDropController CreateDragAndDropController()
		{
			return new TreeViewReorderableDragAndDropController(this);
		}

		public BaseTreeView()
			: this(-1)
		{
		}

		public BaseTreeView(int itemHeight)
			: base(null, itemHeight)
		{
			m_ExpandedItemIds = new List<int>();
			AddToClassList(ussClassName);
			RegisterCallback<PointerUpEvent>(OnTreeViewPointerUp, TrickleDown.TrickleDown);
		}

		public int GetIdForIndex(int index)
		{
			return viewController.GetIdForIndex(index);
		}

		public int GetParentIdForIndex(int index)
		{
			return viewController.GetParentId(GetIdForIndex(index));
		}

		public IEnumerable<int> GetChildrenIdsForIndex(int index)
		{
			return viewController.GetChildrenIdsByIndex(index);
		}

		public IEnumerable<TreeViewItemData<T>> GetSelectedItems<T>()
		{
			return GetSelectedItemsInternal<T>();
		}

		private protected abstract IEnumerable<TreeViewItemData<T>> GetSelectedItemsInternal<T>();

		public T GetItemDataForIndex<T>(int index)
		{
			return GetItemDataForIndexInternal<T>(index);
		}

		private protected abstract T GetItemDataForIndexInternal<T>(int index);

		public T GetItemDataForId<T>(int id)
		{
			return GetItemDataForIdInternal<T>(id);
		}

		private protected abstract T GetItemDataForIdInternal<T>(int id);

		public void AddItem<T>(TreeViewItemData<T> item, int parentId = -1, int childIndex = -1, bool rebuildTree = true)
		{
			AddItemInternal(item, parentId, childIndex, rebuildTree);
		}

		private protected abstract void AddItemInternal<T>(TreeViewItemData<T> item, int parentId, int childIndex, bool rebuildTree);

		public bool TryRemoveItem(int id)
		{
			if (viewController.TryRemoveItem(id))
			{
				RefreshItems();
				return true;
			}
			return false;
		}

		internal override void OnViewDataReady()
		{
			base.OnViewDataReady();
			if (viewController != null)
			{
				viewController.RebuildTree();
				RefreshItems();
			}
		}

		private protected override bool HandleItemNavigation(bool moveIn, bool altPressed)
		{
			int num = 1;
			bool flag = false;
			foreach (int selectedId in base.selectedIds)
			{
				int indexForId = viewController.GetIndexForId(selectedId);
				if (!viewController.HasChildrenByIndex(indexForId))
				{
					break;
				}
				if (moveIn && !IsExpandedByIndex(indexForId))
				{
					ExpandItemByIndex(indexForId, altPressed);
					flag = true;
				}
				else if (!moveIn && IsExpandedByIndex(indexForId))
				{
					CollapseItemByIndex(indexForId, altPressed);
					flag = true;
				}
			}
			if (flag)
			{
				return true;
			}
			if (!moveIn)
			{
				int idForIndex = viewController.GetIdForIndex(base.selectedIndex);
				int parentId = viewController.GetParentId(idForIndex);
				if (parentId != -1)
				{
					SetSelectionById(parentId);
					ScrollToItemById(parentId);
					return true;
				}
				num = -1;
			}
			int num2 = base.selectedIndex;
			bool flag2;
			do
			{
				num2 += num;
				flag2 = viewController.HasChildrenByIndex(num2);
			}
			while (!flag2 && num2 >= 0 && num2 < itemsSource.Count);
			if (flag2)
			{
				SetSelection(num2);
				ScrollToItem(num2);
				return true;
			}
			return false;
		}

		public void SetSelectionById(int id)
		{
			SetSelectionById(new int[1] { id });
		}

		public void SetSelectionById(IEnumerable<int> ids)
		{
			SetSelectionInternalById(ids, sendNotification: true);
		}

		public void SetSelectionByIdWithoutNotify(IEnumerable<int> ids)
		{
			SetSelectionInternalById(ids, sendNotification: false);
		}

		internal void SetSelectionInternalById(IEnumerable<int> ids, bool sendNotification)
		{
			if (ids != null)
			{
				List<int> indices = ids.Select((int id) => GetItemIndex(id, expand: true)).ToList();
				SetSelectionInternal(indices, sendNotification);
			}
		}

		public void AddToSelectionById(int id)
		{
			int itemIndex = GetItemIndex(id, expand: true);
			Rebuild();
			AddToSelection(itemIndex);
		}

		public void RemoveFromSelectionById(int id)
		{
			int itemIndex = GetItemIndex(id);
			RemoveFromSelection(itemIndex);
		}

		private int GetItemIndex(int id, bool expand = false)
		{
			if (expand)
			{
				for (int parentId = viewController.GetParentId(id); parentId != -1; parentId = viewController.GetParentId(parentId))
				{
					if (!m_ExpandedItemIds.Contains(parentId))
					{
						viewController.ExpandItem(parentId, expandAllChildren: false);
					}
				}
			}
			return viewController.GetIndexForId(id);
		}

		internal void CopyExpandedStates(int sourceId, int targetId)
		{
			if (IsExpanded(sourceId))
			{
				ExpandItem(targetId);
				if (!viewController.HasChildren(sourceId))
				{
					return;
				}
				if (viewController.GetChildrenIds(sourceId).Count() != viewController.GetChildrenIds(targetId).Count())
				{
					Debug.LogWarning("Source and target hierarchies are not the same");
					return;
				}
				for (int i = 0; i < viewController.GetChildrenIds(sourceId).Count(); i++)
				{
					int sourceId2 = viewController.GetChildrenIds(sourceId).ElementAt(i);
					int targetId2 = viewController.GetChildrenIds(targetId).ElementAt(i);
					CopyExpandedStates(sourceId2, targetId2);
				}
			}
			else
			{
				CollapseItem(targetId);
			}
		}

		public bool IsExpanded(int id)
		{
			return viewController.IsExpanded(id);
		}

		public void CollapseItem(int id, bool collapseAllChildren = false)
		{
			viewController.CollapseItem(id, collapseAllChildren);
			RefreshItems();
		}

		public void ExpandItem(int id, bool expandAllChildren = false)
		{
			viewController.ExpandItem(id, expandAllChildren);
		}

		public void ExpandRootItems()
		{
			foreach (int rootItemId in viewController.GetRootItemIds())
			{
				viewController.ExpandItem(rootItemId, expandAllChildren: false, refresh: false);
			}
			RefreshItems();
		}

		public void ExpandAll()
		{
			viewController.ExpandAll();
		}

		public void CollapseAll()
		{
			viewController.CollapseAll();
		}

		private void OnTreeViewPointerUp(PointerUpEvent evt)
		{
			base.scrollView.contentContainer.Focus();
		}

		private bool IsExpandedByIndex(int index)
		{
			return viewController.IsExpandedByIndex(index);
		}

		private void CollapseItemByIndex(int index, bool collapseAll)
		{
			if (viewController.HasChildrenByIndex(index))
			{
				viewController.CollapseItemByIndex(index, collapseAll);
				RefreshItems();
				SaveViewData();
			}
		}

		private void ExpandItemByIndex(int index, bool expandAll)
		{
			if (viewController.HasChildrenByIndex(index))
			{
				viewController.ExpandItemByIndex(index, expandAll);
				RefreshItems();
				SaveViewData();
			}
		}
	}
	public enum AlternatingRowBackground
	{
		None,
		ContentOnly,
		All
	}
	public enum CollectionVirtualizationMethod
	{
		FixedHeight,
		DynamicHeight
	}
	[Serializable]
	internal class SerializedVirtualizationData
	{
		public Vector2 scrollOffset;

		public int firstVisibleIndex;

		public float contentPadding;

		public float contentHeight;

		public int anchoredItemIndex;

		public float anchorOffset;
	}
	public abstract class BaseVerticalCollectionView : BindableElement, ISerializationCallbackReceiver
	{
		public new class UxmlTraits : BindableElement.UxmlTraits
		{
			private readonly UxmlIntAttributeDescription m_FixedItemHeight = new UxmlIntAttributeDescription
			{
				name = "fixed-item-height",
				obsoleteNames = new string[1] { "itemHeight, item-height" },
				defaultValue = s_DefaultItemHeight
			};

			private readonly UxmlEnumAttributeDescription<CollectionVirtualizationMethod> m_VirtualizationMethod = new UxmlEnumAttributeDescription<CollectionVirtualizationMethod>
			{
				name = "virtualization-method",
				defaultValue = CollectionVirtualizationMethod.FixedHeight
			};

			private readonly UxmlBoolAttributeDescription m_ShowBorder = new UxmlBoolAttributeDescription
			{
				name = "show-border",
				defaultValue = false
			};

			private readonly UxmlEnumAttributeDescription<SelectionType> m_SelectionType = new UxmlEnumAttributeDescription<SelectionType>
			{
				name = "selection-type",
				defaultValue = SelectionType.Single
			};

			private readonly UxmlEnumAttributeDescription<AlternatingRowBackground> m_ShowAlternatingRowBackgrounds = new UxmlEnumAttributeDescription<AlternatingRowBackground>
			{
				name = "show-alternating-row-backgrounds",
				defaultValue = AlternatingRowBackground.None
			};

			private readonly UxmlBoolAttributeDescription m_Reorderable = new UxmlBoolAttributeDescription
			{
				name = "reorderable",
				defaultValue = false
			};

			private readonly UxmlBoolAttributeDescription m_HorizontalScrollingEnabled = new UxmlBoolAttributeDescription
			{
				name = "horizontal-scrolling",
				defaultValue = false
			};

			public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
			{
				get
				{
					yield break;
				}
			}

			public UxmlTraits()
			{
				base.focusable.defaultValue = true;
			}

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				int value = 0;
				BaseVerticalCollectionView baseVerticalCollectionView = (BaseVerticalCollectionView)ve;
				baseVerticalCollectionView.reorderable = m_Reorderable.GetValueFromBag(bag, cc);
				if (m_FixedItemHeight.TryGetValueFromBag(bag, cc, ref value))
				{
					baseVerticalCollectionView.fixedItemHeight = value;
				}
				baseVerticalCollectionView.virtualizationMethod = m_VirtualizationMethod.GetValueFromBag(bag, cc);
				baseVerticalCollectionView.showBorder = m_ShowBorder.GetValueFromBag(bag, cc);
				baseVerticalCollectionView.selectionType = m_SelectionType.GetValueFromBag(bag, cc);
				baseVerticalCollectionView.showAlternatingRowBackgrounds = m_ShowAlternatingRowBackgrounds.GetValueFromBag(bag, cc);
				baseVerticalCollectionView.horizontalScrollingEnabled = m_HorizontalScrollingEnabled.GetValueFromBag(bag, cc);
			}
		}

		private class Selection
		{
			private readonly HashSet<int> m_IndexLookup = new HashSet<int>();

			private readonly HashSet<int> m_IdLookup = new HashSet<int>();

			private int m_MinIndex = -1;

			private int m_MaxIndex = -1;

			public readonly List<int> indices = new List<int>();

			public readonly Dictionary<int, object> items = new Dictionary<int, object>();

			public List<int> selectedIds { get; set; }

			public int indexCount => indices.Count;

			public int idCount => selectedIds.Count;

			public int minIndex
			{
				get
				{
					if (m_MinIndex == -1)
					{
						m_MinIndex = indices.Min();
					}
					return m_MinIndex;
				}
			}

			public int maxIndex
			{
				get
				{
					if (m_MaxIndex == -1)
					{
						m_MaxIndex = indices.Max();
					}
					return m_MaxIndex;
				}
			}

			public int capacity
			{
				get
				{
					return indices.Capacity;
				}
				set
				{
					indices.Capacity = value;
					if (selectedIds.Capacity < value)
					{
						selectedIds.Capacity = value;
					}
				}
			}

			public int FirstIndex()
			{
				return (indices.Count > 0) ? indices[0] : (-1);
			}

			public object FirstObject()
			{
				object value;
				return items.TryGetValue(FirstIndex(), out value) ? value : null;
			}

			public bool ContainsIndex(int index)
			{
				return m_IndexLookup.Contains(index);
			}

			public bool ContainsId(int id)
			{
				return m_IdLookup.Contains(id);
			}

			public void AddId(int id)
			{
				selectedIds.Add(id);
				m_IdLookup.Add(id);
			}

			public void AddIndex(int index, object obj)
			{
				m_IndexLookup.Add(index);
				indices.Add(index);
				items[index] = obj;
				if (index < m_MinIndex)
				{
					m_MinIndex = index;
				}
				if (index > m_MaxIndex)
				{
					m_MaxIndex = index;
				}
			}

			public bool TryRemove(int index)
			{
				if (!m_IndexLookup.Remove(index))
				{
					return false;
				}
				int num = indices.IndexOf(index);
				if (num >= 0)
				{
					indices.RemoveAt(num);
					items.Remove(index);
					if (index == m_MinIndex)
					{
						m_MinIndex = -1;
					}
					if (index == m_MaxIndex)
					{
						m_MaxIndex = -1;
					}
				}
				return true;
			}

			public void RemoveId(int id)
			{
				selectedIds.Remove(id);
				m_IdLookup.Remove(id);
			}

			public void ClearItems()
			{
				items.Clear();
			}

			public void ClearIds()
			{
				m_IdLookup.Clear();
				selectedIds.Clear();
			}

			public void ClearIndices()
			{
				m_IndexLookup.Clear();
				indices.Clear();
				m_MinIndex = -1;
				m_MaxIndex = -1;
			}

			public void Clear()
			{
				ClearItems();
				ClearIds();
				ClearIndices();
			}
		}

		private static readonly ProfilerMarker k_RefreshMarker = new ProfilerMarker("BaseVerticalCollectionView.RefreshItems");

		private static readonly ProfilerMarker k_RebuildMarker = new ProfilerMarker("BaseVerticalCollectionView.Rebuild");

		internal const string internalBindingKey = "__unity-collection-view-internal-binding";

		private SelectionType m_SelectionType;

		private static readonly List<ReusableCollectionItem> k_EmptyItems = new List<ReusableCollectionItem>();

		private bool m_HorizontalScrollingEnabled;

		[SerializeField]
		private AlternatingRowBackground m_ShowAlternatingRowBackgrounds = AlternatingRowBackground.None;

		internal static readonly int s_DefaultItemHeight = 22;

		internal float m_FixedItemHeight = s_DefaultItemHeight;

		internal bool m_ItemHeightIsInline;

		private CollectionVirtualizationMethod m_VirtualizationMethod;

		private readonly ScrollView m_ScrollView;

		private CollectionViewController m_ViewController;

		private CollectionVirtualizationController m_VirtualizationController;

		private KeyboardNavigationManipulator m_NavigationManipulator;

		[SerializeField]
		internal SerializedVirtualizationData serializedVirtualizationData = new SerializedVirtualizationData();

		[SerializeField]
		private readonly List<int> m_SelectedIds = new List<int>();

		private readonly Selection m_Selection;

		private float m_LastHeight;

		private bool m_IsRangeSelectionDirectionUp;

		private ListViewDragger m_Dragger;

		internal const float ItemHeightUnset = -1f;

		internal static CustomStyleProperty<int> s_ItemHeightProperty = new CustomStyleProperty<int>("--unity-item-height");

		private Action<int, int> m_ItemIndexChangedCallback;

		private Action m_ItemsSourceChangedCallback;

		internal IVisualElementScheduledItem m_RebuildScheduled;

		public static readonly string ussClassName = "unity-collection-view";

		public static readonly string borderUssClassName = ussClassName + "--with-border";

		public static readonly string itemUssClassName = ussClassName + "__item";

		public static readonly string dragHoverBarUssClassName = ussClassName + "__drag-hover-bar";

		public static readonly string dragHoverMarkerUssClassName = ussClassName + "__drag-hover-marker";

		public static readonly string itemDragHoverUssClassName = itemUssClassName + "--drag-hover";

		public static readonly string itemSelectedVariantUssClassName = itemUssClassName + "--selected";

		public static readonly string itemAlternativeBackgroundUssClassName = itemUssClassName + "--alternative-background";

		public static readonly string listScrollViewUssClassName = ussClassName + "__scroll-view";

		internal static readonly string backgroundFillUssClassName = ussClassName + "__background-fill";

		private Vector3 m_TouchDownPosition;

		public IList itemsSource
		{
			get
			{
				return viewController?.itemsSource;
			}
			set
			{
				GetOrCreateViewController().itemsSource = value;
			}
		}

		[Obsolete("makeItem has been moved to ListView and TreeView. Use these ones instead.")]
		public Func<VisualElement> makeItem
		{
			get
			{
				throw new UnityException("makeItem has been moved to ListView and TreeView. Use these ones instead.");
			}
			set
			{
				throw new UnityException("makeItem has been moved to ListView and TreeView. Use these ones instead.");
			}
		}

		[Obsolete("bindItem has been moved to ListView and TreeView. Use these ones instead.")]
		public Action<VisualElement, int> bindItem
		{
			get
			{
				throw new UnityException("bindItem has been moved to ListView and TreeView. Use these ones instead.");
			}
			set
			{
				throw new UnityException("bindItem has been moved to ListView and TreeView. Use these ones instead.");
			}
		}

		[Obsolete("unbindItem has been moved to ListView and TreeView. Use these ones instead.")]
		public Action<VisualElement, int> unbindItem
		{
			get
			{
				throw new UnityException("unbindItem has been moved to ListView and TreeView. Use these ones instead.");
			}
			set
			{
				throw new UnityException("unbindItem has been moved to ListView and TreeView. Use these ones instead.");
			}
		}

		[Obsolete("destroyItem has been moved to ListView and TreeView. Use these ones instead.")]
		public Action<VisualElement> destroyItem
		{
			get
			{
				throw new UnityException("destroyItem has been moved to ListView and TreeView. Use these ones instead.");
			}
			set
			{
				throw new UnityException("destroyItem has been moved to ListView and TreeView. Use these ones instead.");
			}
		}

		public override VisualElement contentContainer => null;

		public SelectionType selectionType
		{
			get
			{
				return m_SelectionType;
			}
			set
			{
				m_SelectionType = value;
				if (m_SelectionType == SelectionType.None)
				{
					ClearSelection();
				}
				else if (m_SelectionType == SelectionType.Single && m_Selection.indexCount > 1)
				{
					SetSelection(m_Selection.FirstIndex());
				}
			}
		}

		public object selectedItem => m_Selection.FirstObject();

		public IEnumerable<object> selectedItems
		{
			get
			{
				foreach (int index in m_Selection.indices)
				{
					if (m_Selection.items.TryGetValue(index, out var item))
					{
						yield return item;
					}
					else
					{
						yield return null;
					}
					item = null;
				}
			}
		}

		public int selectedIndex
		{
			get
			{
				return (m_Selection.indexCount == 0) ? (-1) : m_Selection.FirstIndex();
			}
			set
			{
				SetSelection(value);
			}
		}

		public IEnumerable<int> selectedIndices => m_Selection.indices;

		internal IEnumerable<int> selectedIds => m_Selection.selectedIds;

		internal IEnumerable<ReusableCollectionItem> activeItems => m_VirtualizationController?.activeItems ?? k_EmptyItems;

		internal ScrollView scrollView => m_ScrollView;

		internal ListViewDragger dragger => m_Dragger;

		internal CollectionVirtualizationController virtualizationController => GetOrCreateVirtualizationController();

		public CollectionViewController viewController => m_ViewController;

		[Obsolete("resolvedItemHeight is deprecated and will be removed from the API.", false)]
		public float resolvedItemHeight => ResolveItemHeight();

		public bool showBorder
		{
			get
			{
				return m_ScrollView.ClassListContains(borderUssClassName);
			}
			set
			{
				m_ScrollView.EnableInClassList(borderUssClassName, value);
			}
		}

		public bool reorderable
		{
			get
			{
				return m_Dragger?.dragAndDropController?.enableReordering == true;
			}
			set
			{
				ICollectionDragAndDropController dragAndDropController = m_Dragger.dragAndDropController;
				if (dragAndDropController != null && dragAndDropController.enableReordering != value)
				{
					dragAndDropController.enableReordering = value;
					Rebuild();
				}
			}
		}

		public bool horizontalScrollingEnabled
		{
			get
			{
				return m_HorizontalScrollingEnabled;
			}
			set
			{
				if (m_HorizontalScrollingEnabled != value)
				{
					m_HorizontalScrollingEnabled = value;
					m_ScrollView.horizontalScrollerVisibility = ((!value) ? ScrollerVisibility.Hidden : ScrollerVisibility.Auto);
					m_ScrollView.mode = (value ? ScrollViewMode.VerticalAndHorizontal : ScrollViewMode.Vertical);
				}
			}
		}

		public AlternatingRowBackground showAlternatingRowBackgrounds
		{
			get
			{
				return m_ShowAlternatingRowBackgrounds;
			}
			set
			{
				if (m_ShowAlternatingRowBackgrounds != value)
				{
					m_ShowAlternatingRowBackgrounds = value;
					RefreshItems();
				}
			}
		}

		public CollectionVirtualizationMethod virtualizationMethod
		{
			get
			{
				return m_VirtualizationMethod;
			}
			set
			{
				CollectionVirtualizationMethod collectionVirtualizationMethod = m_VirtualizationMethod;
				m_VirtualizationMethod = value;
				if (collectionVirtualizationMethod != value)
				{
					CreateVirtualizationController();
					Rebuild();
				}
			}
		}

		[Obsolete("itemHeight is deprecated, use fixedItemHeight instead.", false)]
		public int itemHeight
		{
			get
			{
				return (int)fixedItemHeight;
			}
			set
			{
				fixedItemHeight = value;
			}
		}

		public float fixedItemHeight
		{
			get
			{
				return m_FixedItemHeight;
			}
			set
			{
				if (value < 0f)
				{
					throw new ArgumentOutOfRangeException("fixedItemHeight", "Value needs to be positive for virtualization.");
				}
				m_ItemHeightIsInline = true;
				if (Math.Abs(m_FixedItemHeight - value) > float.Epsilon)
				{
					m_FixedItemHeight = value;
					RefreshItems();
				}
			}
		}

		internal float lastHeight => m_LastHeight;

		[Obsolete("onItemsChosen is deprecated, use itemsChosen instead", false)]
		public event Action<IEnumerable<object>> onItemsChosen
		{
			add
			{
				itemsChosen += value;
			}
			remove
			{
				itemsChosen -= value;
			}
		}

		public event Action<IEnumerable<object>> itemsChosen;

		[Obsolete("onSelectionChange is deprecated, use selectionChanged instead", false)]
		public event Action<IEnumerable<object>> onSelectionChange
		{
			add
			{
				selectionChanged += value;
			}
			remove
			{
				selectionChanged -= value;
			}
		}

		public event Action<IEnumerable<object>> selectionChanged;

		[Obsolete("onSelectedIndicesChange is deprecated, use selectedIndicesChanged instead", false)]
		public event Action<IEnumerable<int>> onSelectedIndicesChange
		{
			add
			{
				selectedIndicesChanged += value;
			}
			remove
			{
				selectedIndicesChanged -= value;
			}
		}

		public event Action<IEnumerable<int>> selectedIndicesChanged;

		public event Action<int, int> itemIndexChanged;

		public event Action itemsSourceChanged;

		internal event Action selectionNotChanged;

		internal event Func<CanStartDragArgs, bool> canStartDrag;

		internal event Func<SetupDragAndDropArgs, StartDragArgs> setupDragAndDrop;

		internal event Func<HandleDragAndDropArgs, DragVisualMode> dragAndDropUpdate;

		internal event Func<HandleDragAndDropArgs, DragVisualMode> handleDrop;

		internal bool HasCanStartDrag()
		{
			return this.canStartDrag != null;
		}

		internal bool RaiseCanStartDrag(ReusableCollectionItem item, IEnumerable<int> ids)
		{
			return this.canStartDrag?.Invoke(new CanStartDragArgs(item?.rootElement, item?.id ?? (-1), ids)) ?? true;
		}

		internal StartDragArgs RaiseSetupDragAndDrop(ReusableCollectionItem item, IEnumerable<int> ids, StartDragArgs args)
		{
			return this.setupDragAndDrop?.Invoke(new SetupDragAndDropArgs(item?.rootElement, ids, args)) ?? args;
		}

		internal DragVisualMode RaiseHandleDragAndDrop(Vector2 pointerPosition, DragAndDropArgs dragAndDropArgs)
		{
			return this.dragAndDropUpdate?.Invoke(new HandleDragAndDropArgs(pointerPosition, dragAndDropArgs)) ?? DragVisualMode.None;
		}

		internal DragVisualMode RaiseDrop(Vector2 pointerPosition, DragAndDropArgs dragAndDropArgs)
		{
			return this.handleDrop?.Invoke(new HandleDragAndDropArgs(pointerPosition, dragAndDropArgs)) ?? DragVisualMode.None;
		}

		internal float ResolveItemHeight(float height = -1f)
		{
			float num = base.scaledPixelsPerPoint;
			height = ((height < 0f) ? fixedItemHeight : height);
			return Mathf.Round(height * num) / num;
		}

		private protected virtual void CreateVirtualizationController()
		{
			CreateVirtualizationController<ReusableCollectionItem>();
		}

		internal CollectionVirtualizationController GetOrCreateVirtualizationController()
		{
			if (m_VirtualizationController == null)
			{
				CreateVirtualizationController();
			}
			return m_VirtualizationController;
		}

		internal void CreateVirtualizationController<T>() where T : ReusableCollectionItem, new()
		{
			switch (virtualizationMethod)
			{
			case CollectionVirtualizationMethod.FixedHeight:
				m_VirtualizationController = new FixedHeightVirtualizationController<T>(this);
				break;
			case CollectionVirtualizationMethod.DynamicHeight:
				m_VirtualizationController = new DynamicHeightVirtualizationController<T>(this);
				break;
			default:
				throw new ArgumentOutOfRangeException("virtualizationMethod", virtualizationMethod, "Unsupported virtualizationMethod virtualization");
			}
		}

		internal CollectionViewController GetOrCreateViewController()
		{
			if (m_ViewController == null)
			{
				SetViewController(CreateViewController());
			}
			return m_ViewController;
		}

		protected abstract CollectionViewController CreateViewController();

		public virtual void SetViewController(CollectionViewController controller)
		{
			if (m_ViewController != null)
			{
				m_ViewController.itemIndexChanged -= m_ItemIndexChangedCallback;
				m_ViewController.itemsSourceChanged -= m_ItemsSourceChangedCallback;
				m_ViewController.Dispose();
				m_ViewController = null;
			}
			m_ViewController = controller;
			if (m_ViewController != null)
			{
				m_ViewController.SetView(this);
				m_ViewController.itemIndexChanged += m_ItemIndexChangedCallback;
				m_ViewController.itemsSourceChanged += m_ItemsSourceChangedCallback;
			}
		}

		internal virtual ListViewDragger CreateDragger()
		{
			return new ListViewDragger(this);
		}

		internal void InitializeDragAndDropController(bool enableReordering)
		{
			if (m_Dragger != null)
			{
				m_Dragger.UnregisterCallbacksFromTarget(unregisterPanelEvents: true);
				m_Dragger.dragAndDropController = null;
				m_Dragger = null;
			}
			m_Dragger = CreateDragger();
			m_Dragger.dragAndDropController = CreateDragAndDropController();
			if (m_Dragger.dragAndDropController != null)
			{
				m_Dragger.dragAndDropController.enableReordering = enableReordering;
			}
		}

		internal abstract ICollectionDragAndDropController CreateDragAndDropController();

		internal void SetDragAndDropController(ICollectionDragAndDropController dragAndDropController)
		{
			if (m_Dragger == null)
			{
				m_Dragger = CreateDragger();
			}
			m_Dragger.dragAndDropController = dragAndDropController;
		}

		public BaseVerticalCollectionView()
		{
			AddToClassList(ussClassName);
			m_Selection = new Selection
			{
				selectedIds = m_SelectedIds
			};
			selectionType = SelectionType.Single;
			m_ScrollView = new ScrollView();
			m_ScrollView.AddToClassList(listScrollViewUssClassName);
			m_ScrollView.verticalScroller.valueChanged += delegate(float v)
			{
				OnScroll(new Vector2(0f, v));
			};
			m_ScrollView.RegisterCallback<GeometryChangedEvent>(OnSizeChanged);
			RegisterCallback<CustomStyleResolvedEvent>(OnCustomStyleResolved);
			m_ScrollView.contentContainer.RegisterCallback<AttachToPanelEvent>(OnAttachToPanel);
			m_ScrollView.contentContainer.RegisterCallback<DetachFromPanelEvent>(OnDetachFromPanel);
			base.hierarchy.Add(m_ScrollView);
			m_ScrollView.contentContainer.focusable = true;
			m_ScrollView.contentContainer.usageHints &= ~UsageHints.GroupTransform;
			m_ScrollView.viewDataKey = "unity-vertical-collection-scroll-view";
			m_ScrollView.verticalScroller.viewDataKey = null;
			m_ScrollView.horizontalScroller.viewDataKey = null;
			base.focusable = true;
			base.isCompositeRoot = true;
			base.delegatesFocus = true;
			m_ItemIndexChangedCallback = OnItemIndexChanged;
			m_ItemsSourceChangedCallback = OnItemsSourceChanged;
			InitializeDragAndDropController(enableReordering: false);
		}

		public BaseVerticalCollectionView(IList itemsSource, float itemHeight = -1f)
			: this()
		{
			if (Math.Abs(itemHeight - -1f) > float.Epsilon)
			{
				m_FixedItemHeight = itemHeight;
				m_ItemHeightIsInline = true;
			}
			if (itemsSource != null)
			{
				this.itemsSource = itemsSource;
			}
		}

		[Obsolete("makeItem and bindItem are now in ListView and TreeView directly, please use a constructor without these parameters.")]
		public BaseVerticalCollectionView(IList itemsSource, float itemHeight = -1f, Func<VisualElement> makeItem = null, Action<VisualElement, int> bindItem = null)
			: this()
		{
			if (Math.Abs(itemHeight - -1f) > float.Epsilon)
			{
				m_FixedItemHeight = itemHeight;
				m_ItemHeightIsInline = true;
			}
			this.itemsSource = itemsSource;
		}

		public VisualElement GetRootElementForId(int id)
		{
			return activeItems.FirstOrDefault((ReusableCollectionItem t) => t.id == id)?.rootElement;
		}

		public VisualElement GetRootElementForIndex(int index)
		{
			return GetRootElementForId(viewController.GetIdForIndex(index));
		}

		internal virtual bool HasValidDataAndBindings()
		{
			return m_ViewController != null && itemsSource != null;
		}

		private void OnItemIndexChanged(int srcIndex, int dstIndex)
		{
			this.itemIndexChanged?.Invoke(srcIndex, dstIndex);
			RefreshItems();
		}

		private void OnItemsSourceChanged()
		{
			this.itemsSourceChanged?.Invoke();
		}

		public void RefreshItem(int index)
		{
			foreach (ReusableCollectionItem activeItem in activeItems)
			{
				int index2 = activeItem.index;
				if (index2 == index)
				{
					viewController.InvokeUnbindItem(activeItem, index2);
					viewController.InvokeBindItem(activeItem, index2);
					break;
				}
			}
		}

		public void RefreshItems()
		{
			using (k_RefreshMarker.Auto())
			{
				if (m_ViewController != null)
				{
					IVisualElementScheduledItem rebuildScheduled = m_RebuildScheduled;
					if (rebuildScheduled != null && rebuildScheduled.isActive)
					{
						Rebuild();
						return;
					}
					RefreshSelection();
					virtualizationController.Refresh(rebuild: false);
					PostRefresh();
				}
			}
		}

		[Obsolete("Refresh() has been deprecated. Use Rebuild() instead. (UnityUpgradable) -> Rebuild()", false)]
		public void Refresh()
		{
			Rebuild();
		}

		public void Rebuild()
		{
			using (k_RebuildMarker.Auto())
			{
				if (m_ViewController != null)
				{
					RefreshSelection();
					virtualizationController.Refresh(rebuild: true);
					PostRefresh();
					m_RebuildScheduled?.Pause();
				}
			}
		}

		internal void ScheduleRebuild()
		{
			if (m_RebuildScheduled == null)
			{
				m_RebuildScheduled = base.schedule.Execute(Rebuild);
			}
			else if (!m_RebuildScheduled.isActive)
			{
				m_RebuildScheduled.Resume();
			}
		}

		private void RefreshSelection()
		{
			bool selectedIndicesChanged = false;
			int previousSelectionCount = m_Selection.indexCount;
			m_Selection.items.Clear();
			if (viewController?.itemsSource == null)
			{
				m_Selection.ClearIndices();
				NotifyIfChanged();
				return;
			}
			if (m_Selection.idCount > 0)
			{
				List<int> value;
				using (CollectionPool<List<int>, int>.Get(out value))
				{
					foreach (int selectedId in m_Selection.selectedIds)
					{
						int indexForId = viewController.GetIndexForId(selectedId);
						if (indexForId < 0)
						{
							selectedIndicesChanged = true;
							continue;
						}
						if (!m_Selection.ContainsIndex(indexForId))
						{
							selectedIndicesChanged = true;
						}
						value.Add(indexForId);
					}
					m_Selection.ClearIndices();
					foreach (int item in value)
					{
						m_Selection.AddIndex(item, viewController.GetItemForIndex(item));
					}
				}
			}
			NotifyIfChanged();
			void NotifyIfChanged()
			{
				if (selectedIndicesChanged || m_Selection.indexCount != previousSelectionCount)
				{
					NotifyOfSelectionChange();
				}
			}
		}

		private protected virtual void PostRefresh()
		{
			if (HasValidDataAndBindings())
			{
				m_LastHeight = m_ScrollView.layout.height;
				if (!float.IsNaN(m_ScrollView.layout.height))
				{
					Resize(m_ScrollView.layout.size);
				}
			}
		}

		public void ScrollTo(VisualElement visualElement)
		{
			m_ScrollView.ScrollTo(visualElement);
		}

		public void ScrollToItem(int index)
		{
			if (HasValidDataAndBindings())
			{
				virtualizationController.ScrollToItem(index);
			}
		}

		[Obsolete("ScrollToId() has been deprecated. Use ScrollToItemById() instead. (UnityUpgradable) -> ScrollToItemById(*)", false)]
		public void ScrollToId(int id)
		{
			ScrollToItemById(id);
		}

		public void ScrollToItemById(int id)
		{
			if (HasValidDataAndBindings())
			{
				int indexForId = viewController.GetIndexForId(id);
				virtualizationController.ScrollToItem(indexForId);
			}
		}

		private void OnScroll(Vector2 offset)
		{
			if (HasValidDataAndBindings())
			{
				virtualizationController.OnScroll(offset);
			}
		}

		private void Resize(Vector2 size)
		{
			virtualizationController.Resize(size);
			m_LastHeight = size.y;
			virtualizationController.UpdateBackground();
		}

		private void OnAttachToPanel(AttachToPanelEvent evt)
		{
			if (evt.destinationPanel != null)
			{
				m_ScrollView.contentContainer.AddManipulator(m_NavigationManipulator = new KeyboardNavigationManipulator(Apply));
				m_ScrollView.contentContainer.RegisterCallback<PointerMoveEvent>(OnPointerMove);
				m_ScrollView.contentContainer.RegisterCallback<PointerDownEvent>(OnPointerDown);
				m_ScrollView.contentContainer.RegisterCallback<PointerCancelEvent>(OnPointerCancel);
				m_ScrollView.contentContainer.RegisterCallback<PointerUpEvent>(OnPointerUp);
			}
		}

		private void OnDetachFromPanel(DetachFromPanelEvent evt)
		{
			if (evt.originPanel != null)
			{
				m_ScrollView.contentContainer.RemoveManipulator(m_NavigationManipulator);
				m_ScrollView.contentContainer.UnregisterCallback<PointerMoveEvent>(OnPointerMove);
				m_ScrollView.contentContainer.UnregisterCallback<PointerDownEvent>(OnPointerDown);
				m_ScrollView.contentContainer.UnregisterCallback<PointerCancelEvent>(OnPointerCancel);
				m_ScrollView.contentContainer.UnregisterCallback<PointerUpEvent>(OnPointerUp);
			}
		}

		[Obsolete("OnKeyDown is obsolete and will be removed from ListView. Use the event system instead, i.e. SendEvent(EventBase e).", true)]
		public void OnKeyDown(KeyDownEvent evt)
		{
			m_NavigationManipulator.OnKeyDown(evt);
		}

		private bool Apply(KeyboardNavigationOperation op, bool shiftKey, bool altKey)
		{
			if (selectionType == SelectionType.None || !HasValidDataAndBindings())
			{
				return false;
			}
			switch (op)
			{
			case KeyboardNavigationOperation.SelectAll:
				SelectAll();
				return true;
			case KeyboardNavigationOperation.Cancel:
				ClearSelection();
				return true;
			case KeyboardNavigationOperation.Submit:
				this.itemsChosen?.Invoke(selectedItems);
				ScrollToItem(selectedIndex);
				return true;
			case KeyboardNavigationOperation.Previous:
				if (selectedIndex > 0)
				{
					HandleSelectionAndScroll(selectedIndex - 1);
					return true;
				}
				break;
			case KeyboardNavigationOperation.Next:
				if (selectedIndex + 1 < m_ViewController.itemsSource.Count)
				{
					HandleSelectionAndScroll(selectedIndex + 1);
					return true;
				}
				break;
			case KeyboardNavigationOperation.Begin:
				HandleSelectionAndScroll(0);
				return true;
			case KeyboardNavigationOperation.End:
				HandleSelectionAndScroll(m_ViewController.itemsSource.Count - 1);
				return true;
			case KeyboardNavigationOperation.PageDown:
				if (m_Selection.indexCount > 0)
				{
					int num2 = (m_IsRangeSelectionDirectionUp ? m_Selection.minIndex : m_Selection.maxIndex);
					HandleSelectionAndScroll(Mathf.Min(viewController.itemsSource.Count - 1, num2 + (virtualizationController.visibleItemCount - 1)));
				}
				return true;
			case KeyboardNavigationOperation.PageUp:
				if (m_Selection.indexCount > 0)
				{
					int num = (m_IsRangeSelectionDirectionUp ? m_Selection.minIndex : m_Selection.maxIndex);
					HandleSelectionAndScroll(Mathf.Max(0, num - (virtualizationController.visibleItemCount - 1)));
				}
				return true;
			case KeyboardNavigationOperation.MoveRight:
				if (m_Selection.indexCount > 0)
				{
					return HandleItemNavigation(moveIn: true, altKey);
				}
				break;
			case KeyboardNavigationOperation.MoveLeft:
				if (m_Selection.indexCount > 0)
				{
					return HandleItemNavigation(moveIn: false, altKey);
				}
				break;
			default:
				throw new ArgumentOutOfRangeException("op", op, null);
			}
			return false;
			void HandleSelectionAndScroll(int index)
			{
				if (index >= 0 && index < m_ViewController.itemsSource.Count)
				{
					if (selectionType == SelectionType.Multiple && shiftKey && m_Selection.indexCount != 0)
					{
						DoRangeSelection(index);
					}
					else
					{
						selectedIndex = index;
					}
					ScrollToItem(index);
				}
			}
		}

		private void Apply(KeyboardNavigationOperation op, EventBase sourceEvent)
		{
			bool flag = ((sourceEvent is KeyDownEvent { shiftKey: not false } || sourceEvent is INavigationEvent { shiftKey: not false }) ? true : false);
			bool shiftKey = flag;
			bool flag2 = ((sourceEvent is KeyDownEvent { altKey: not false } || sourceEvent is INavigationEvent { altKey: not false }) ? true : false);
			bool altKey = flag2;
			if (Apply(op, shiftKey, altKey))
			{
				sourceEvent.StopPropagation();
				sourceEvent.PreventDefault();
			}
		}

		private protected virtual bool HandleItemNavigation(bool moveIn, bool altKey)
		{
			return false;
		}

		private void OnPointerMove(PointerMoveEvent evt)
		{
			if (evt.button == 0)
			{
				if ((evt.pressedButtons & 1) == 0)
				{
					ProcessPointerUp(evt);
				}
				else
				{
					ProcessPointerDown(evt);
				}
			}
		}

		private void OnPointerDown(PointerDownEvent evt)
		{
			if (evt.pointerType != PointerType.mouse)
			{
				ProcessPointerDown(evt);
				base.panel.PreventCompatibilityMouseEvents(evt.pointerId);
			}
			else
			{
				ProcessPointerDown(evt);
			}
		}

		private void OnPointerCancel(PointerCancelEvent evt)
		{
			if (HasValidDataAndBindings() && evt.isPrimary)
			{
				ClearSelection();
			}
		}

		private void OnPointerUp(PointerUpEvent evt)
		{
			if (evt.pointerType != PointerType.mouse)
			{
				ProcessPointerUp(evt);
				base.panel.PreventCompatibilityMouseEvents(evt.pointerId);
			}
			else
			{
				ProcessPointerUp(evt);
			}
		}

		private void ProcessPointerDown(IPointerEvent evt)
		{
			if (HasValidDataAndBindings() && evt.isPrimary && evt.button == 0)
			{
				if (evt.pointerType != PointerType.mouse)
				{
					m_TouchDownPosition = evt.position;
				}
				else
				{
					DoSelect(evt.localPosition, evt.clickCount, evt.actionKey, evt.shiftKey);
				}
			}
		}

		private void ProcessPointerUp(IPointerEvent evt)
		{
			if (!HasValidDataAndBindings() || !evt.isPrimary || evt.button != 0)
			{
				return;
			}
			if (evt.pointerType != PointerType.mouse)
			{
				if ((evt.position - m_TouchDownPosition).sqrMagnitude <= 100f)
				{
					DoSelect(evt.localPosition, evt.clickCount, evt.actionKey, evt.shiftKey);
				}
				return;
			}
			int indexFromPosition = virtualizationController.GetIndexFromPosition(evt.localPosition);
			if (selectionType == SelectionType.Multiple && !evt.shiftKey && !evt.actionKey && m_Selection.indexCount > 1 && m_Selection.ContainsIndex(indexFromPosition))
			{
				ProcessSingleClick(indexFromPosition);
			}
		}

		private void DoSelect(Vector2 localPosition, int clickCount, bool actionKey, bool shiftKey)
		{
			int indexFromPosition = virtualizationController.GetIndexFromPosition(localPosition);
			int num = ((m_Selection.indexCount > 0 && m_Selection.FirstIndex() != indexFromPosition) ? 1 : ((clickCount > 2) ? 2 : clickCount));
			if (indexFromPosition > viewController.itemsSource.Count - 1 || selectionType == SelectionType.None)
			{
				return;
			}
			int idForIndex = viewController.GetIdForIndex(indexFromPosition);
			switch (num)
			{
			case 1:
				if (selectionType == SelectionType.Multiple && actionKey)
				{
					if (m_Selection.ContainsId(idForIndex))
					{
						RemoveFromSelection(indexFromPosition);
					}
					else
					{
						AddToSelection(indexFromPosition);
					}
					break;
				}
				if (selectionType == SelectionType.Multiple && shiftKey)
				{
					if (m_Selection.indexCount == 0)
					{
						SetSelection(indexFromPosition);
					}
					else
					{
						DoRangeSelection(indexFromPosition);
					}
					break;
				}
				if (selectionType == SelectionType.Multiple && m_Selection.ContainsIndex(indexFromPosition))
				{
					this.selectionNotChanged?.Invoke();
					break;
				}
				if (selectionType == SelectionType.Single && m_Selection.ContainsIndex(indexFromPosition))
				{
					this.selectionNotChanged?.Invoke();
				}
				SetSelection(indexFromPosition);
				break;
			case 2:
			{
				if (this.itemsChosen == null)
				{
					break;
				}
				bool flag = false;
				foreach (int selectedIndex in selectedIndices)
				{
					if (indexFromPosition == selectedIndex)
					{
						flag = true;
						break;
					}
				}
				ProcessSingleClick(indexFromPosition);
				if (flag)
				{
					this.itemsChosen?.Invoke(selectedItems);
				}
				break;
			}
			}
		}

		internal void DoRangeSelection(int rangeSelectionFinalIndex)
		{
			int num = (m_IsRangeSelectionDirectionUp ? m_Selection.maxIndex : m_Selection.minIndex);
			ClearSelectionWithoutValidation();
			List<int> list = new List<int>();
			m_IsRangeSelectionDirectionUp = rangeSelectionFinalIndex < num;
			if (m_IsRangeSelectionDirectionUp)
			{
				for (int i = rangeSelectionFinalIndex; i <= num; i++)
				{
					list.Add(i);
				}
			}
			else
			{
				for (int num2 = rangeSelectionFinalIndex; num2 >= num; num2--)
				{
					list.Add(num2);
				}
			}
			AddToSelection(list);
		}

		private void ProcessSingleClick(int clickedIndex)
		{
			SetSelection(clickedIndex);
		}

		internal void SelectAll()
		{
			if (!HasValidDataAndBindings() || selectionType != SelectionType.Multiple)
			{
				return;
			}
			for (int i = 0; i < m_ViewController.itemsSource.Count; i++)
			{
				int idForIndex = viewController.GetIdForIndex(i);
				object itemForIndex = viewController.GetItemForIndex(i);
				foreach (ReusableCollectionItem activeItem in activeItems)
				{
					if (activeItem.id == idForIndex)
					{
						activeItem.SetSelected(selected: true);
					}
				}
				if (!m_Selection.ContainsId(idForIndex))
				{
					m_Selection.AddId(idForIndex);
					m_Selection.AddIndex(i, itemForIndex);
				}
			}
			NotifyOfSelectionChange();
			SaveViewData();
		}

		public void AddToSelection(int index)
		{
			AddToSelection(new int[1] { index });
		}

		internal void AddToSelection(IList<int> indexes)
		{
			if (!HasValidDataAndBindings() || indexes == null || indexes.Count == 0)
			{
				return;
			}
			foreach (int index in indexes)
			{
				AddToSelectionWithoutValidation(index);
			}
			NotifyOfSelectionChange();
			SaveViewData();
		}

		private void AddToSelectionWithoutValidation(int index)
		{
			if (m_Selection.ContainsIndex(index))
			{
				return;
			}
			int idForIndex = viewController.GetIdForIndex(index);
			object itemForIndex = viewController.GetItemForIndex(index);
			foreach (ReusableCollectionItem activeItem in activeItems)
			{
				if (activeItem.id == idForIndex)
				{
					activeItem.SetSelected(selected: true);
				}
			}
			m_Selection.AddId(idForIndex);
			m_Selection.AddIndex(index, itemForIndex);
		}

		public void RemoveFromSelection(int index)
		{
			if (HasValidDataAndBindings())
			{
				RemoveFromSelectionWithoutValidation(index);
				NotifyOfSelectionChange();
				SaveViewData();
			}
		}

		private void RemoveFromSelectionWithoutValidation(int index)
		{
			if (!m_Selection.TryRemove(index))
			{
				return;
			}
			int idForIndex = viewController.GetIdForIndex(index);
			foreach (ReusableCollectionItem activeItem in activeItems)
			{
				if (activeItem.id == idForIndex)
				{
					activeItem.SetSelected(selected: false);
				}
			}
			m_Selection.RemoveId(idForIndex);
		}

		public void SetSelection(int index)
		{
			if (index < 0)
			{
				ClearSelection();
				return;
			}
			SetSelection(new int[1] { index });
		}

		public void SetSelection(IEnumerable<int> indices)
		{
			SetSelectionInternal(indices, sendNotification: true);
		}

		public void SetSelectionWithoutNotify(IEnumerable<int> indices)
		{
			SetSelectionInternal(indices, sendNotification: false);
		}

		internal void SetSelectionInternal(IEnumerable<int> indices, bool sendNotification)
		{
			if (!HasValidDataAndBindings() || indices == null || MatchesExistingSelection(indices))
			{
				return;
			}
			ClearSelectionWithoutValidation();
			if (indices is ICollection collection && m_Selection.capacity < collection.Count)
			{
				m_Selection.capacity = collection.Count;
			}
			foreach (int index in indices)
			{
				AddToSelectionWithoutValidation(index);
			}
			if (sendNotification)
			{
				NotifyOfSelectionChange();
			}
			SaveViewData();
		}

		private bool MatchesExistingSelection(IEnumerable<int> indices)
		{
			IList<int> list = indices as IList<int>;
			List<int> list2 = null;
			try
			{
				if (list == null)
				{
					list2 = CollectionPool<List<int>, int>.Get();
					list2.AddRange(indices);
					list = list2;
				}
				if (list.Count != m_Selection.indexCount)
				{
					return false;
				}
				for (int i = 0; i < list.Count; i++)
				{
					if (list[i] != m_Selection.indices[i])
					{
						return false;
					}
				}
				return true;
			}
			finally
			{
				if (list2 != null)
				{
					CollectionPool<List<int>, int>.Release(list2);
				}
			}
		}

		private void NotifyOfSelectionChange()
		{
			if (HasValidDataAndBindings())
			{
				this.selectionChanged?.Invoke(selectedItems);
				this.selectedIndicesChanged?.Invoke(m_Selection.indices);
			}
		}

		public void ClearSelection()
		{
			if (HasValidDataAndBindings() && m_Selection.idCount != 0)
			{
				ClearSelectionWithoutValidation();
				NotifyOfSelectionChange();
			}
		}

		private void ClearSelectionWithoutValidation()
		{
			foreach (ReusableCollectionItem activeItem in activeItems)
			{
				activeItem.SetSelected(selected: false);
			}
			m_Selection.Clear();
		}

		internal override void OnViewDataReady()
		{
			base.OnViewDataReady();
			string fullHierarchicalViewDataKey = GetFullHierarchicalViewDataKey();
			OverwriteFromViewData(this, fullHierarchicalViewDataKey);
			m_ScrollView.UpdateContentViewTransform();
		}

		[EventInterest(new Type[]
		{
			typeof(PointerUpEvent),
			typeof(FocusEvent),
			typeof(NavigationSubmitEvent),
			typeof(BlurEvent)
		})]
		protected override void ExecuteDefaultAction(EventBase evt)
		{
			base.ExecuteDefaultAction(evt);
			if (evt.eventTypeId == EventBase<PointerUpEvent>.TypeId())
			{
				m_Dragger?.OnPointerUpEvent((PointerUpEvent)evt);
			}
			else if (evt.eventTypeId == EventBase<FocusEvent>.TypeId())
			{
				m_VirtualizationController?.OnFocus(evt.leafTarget as VisualElement);
			}
			else if (evt.eventTypeId == EventBase<BlurEvent>.TypeId())
			{
				m_VirtualizationController?.OnBlur((evt as BlurEvent)?.relatedTarget as VisualElement);
			}
			else if (evt.eventTypeId == EventBase<NavigationSubmitEvent>.TypeId() && evt.target == this)
			{
				m_ScrollView.contentContainer.Focus();
			}
		}

		private void OnSizeChanged(GeometryChangedEvent evt)
		{
			if (HasValidDataAndBindings() && (!Mathf.Approximately(evt.newRect.width, evt.oldRect.width) || !Mathf.Approximately(evt.newRect.height, evt.oldRect.height)))
			{
				Resize(evt.newRect.size);
			}
		}

		private void OnCustomStyleResolved(CustomStyleResolvedEvent e)
		{
			if (!m_ItemHeightIsInline && e.customStyle.TryGetValue(s_ItemHeightProperty, out var value) && Math.Abs(m_FixedItemHeight - (float)value) > float.Epsilon)
			{
				m_FixedItemHeight = value;
				RefreshItems();
			}
		}

		void ISerializationCallbackReceiver.OnBeforeSerialize()
		{
		}

		void ISerializationCallbackReceiver.OnAfterDeserialize()
		{
			m_Selection.selectedIds = m_SelectedIds;
			RefreshItems();
		}
	}
	public interface IBindable
	{
		IBinding binding { get; set; }

		string bindingPath { get; set; }
	}
	public interface IBinding
	{
		void PreUpdate();

		void Update();

		void Release();
	}
	public static class IBindingExtensions
	{
		public static bool IsBound(this IBindable control)
		{
			return control?.binding != null;
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class BoundsField : BaseField<Bounds>
	{
		public new class UxmlFactory : UxmlFactory<BoundsField, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseField<Bounds>.UxmlTraits
		{
			private UxmlFloatAttributeDescription m_CenterXValue = new UxmlFloatAttributeDescription
			{
				name = "cx"
			};

			private UxmlFloatAttributeDescription m_CenterYValue = new UxmlFloatAttributeDescription
			{
				name = "cy"
			};

			private UxmlFloatAttributeDescription m_CenterZValue = new UxmlFloatAttributeDescription
			{
				name = "cz"
			};

			private UxmlFloatAttributeDescription m_ExtentsXValue = new UxmlFloatAttributeDescription
			{
				name = "ex"
			};

			private UxmlFloatAttributeDescription m_ExtentsYValue = new UxmlFloatAttributeDescription
			{
				name = "ey"
			};

			private UxmlFloatAttributeDescription m_ExtentsZValue = new UxmlFloatAttributeDescription
			{
				name = "ez"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				BoundsField boundsField = (BoundsField)ve;
				boundsField.SetValueWithoutNotify(new Bounds(new Vector3(m_CenterXValue.GetValueFromBag(bag, cc), m_CenterYValue.GetValueFromBag(bag, cc), m_CenterZValue.GetValueFromBag(bag, cc)), new Vector3(m_ExtentsXValue.GetValueFromBag(bag, cc), m_ExtentsYValue.GetValueFromBag(bag, cc), m_ExtentsZValue.GetValueFromBag(bag, cc))));
			}
		}

		public new static readonly string ussClassName = "unity-bounds-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		public static readonly string centerFieldUssClassName = ussClassName + "__center-field";

		public static readonly string extentsFieldUssClassName = ussClassName + "__extents-field";

		private Vector3Field m_CenterField;

		private Vector3Field m_ExtentsField;

		public BoundsField()
			: this(null)
		{
		}

		public BoundsField(string label)
			: base(label, (VisualElement)null)
		{
			base.delegatesFocus = false;
			base.visualInput.focusable = false;
			AddToClassList(ussClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			m_CenterField = new Vector3Field("Center");
			m_CenterField.name = "unity-m_Center-input";
			m_CenterField.delegatesFocus = true;
			m_CenterField.AddToClassList(centerFieldUssClassName);
			m_CenterField.RegisterValueChangedCallback(delegate(ChangeEvent<Vector3> e)
			{
				Bounds bounds = value;
				bounds.center = e.newValue;
				value = bounds;
			});
			base.visualInput.hierarchy.Add(m_CenterField);
			m_ExtentsField = new Vector3Field("Extents");
			m_ExtentsField.name = "unity-m_Extent-input";
			m_ExtentsField.delegatesFocus = true;
			m_ExtentsField.AddToClassList(extentsFieldUssClassName);
			m_ExtentsField.RegisterValueChangedCallback(delegate(ChangeEvent<Vector3> e)
			{
				Bounds bounds = value;
				bounds.extents = e.newValue;
				value = bounds;
			});
			base.visualInput.hierarchy.Add(m_ExtentsField);
		}

		public override void SetValueWithoutNotify(Bounds newValue)
		{
			base.SetValueWithoutNotify(newValue);
			m_CenterField.SetValueWithoutNotify(base.rawValue.center);
			m_ExtentsField.SetValueWithoutNotify(base.rawValue.extents);
		}

		protected override void UpdateMixedValueContent()
		{
			m_CenterField.showMixedValue = base.showMixedValue;
			m_ExtentsField.showMixedValue = base.showMixedValue;
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class BoundsIntField : BaseField<BoundsInt>
	{
		public new class UxmlFactory : UxmlFactory<BoundsIntField, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseField<BoundsInt>.UxmlTraits
		{
			private UxmlIntAttributeDescription m_PositionXValue = new UxmlIntAttributeDescription
			{
				name = "px"
			};

			private UxmlIntAttributeDescription m_PositionYValue = new UxmlIntAttributeDescription
			{
				name = "py"
			};

			private UxmlIntAttributeDescription m_PositionZValue = new UxmlIntAttributeDescription
			{
				name = "pz"
			};

			private UxmlIntAttributeDescription m_SizeXValue = new UxmlIntAttributeDescription
			{
				name = "sx"
			};

			private UxmlIntAttributeDescription m_SizeYValue = new UxmlIntAttributeDescription
			{
				name = "sy"
			};

			private UxmlIntAttributeDescription m_SizeZValue = new UxmlIntAttributeDescription
			{
				name = "sz"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				BoundsIntField boundsIntField = (BoundsIntField)ve;
				boundsIntField.SetValueWithoutNotify(new BoundsInt(new Vector3Int(m_PositionXValue.GetValueFromBag(bag, cc), m_PositionYValue.GetValueFromBag(bag, cc), m_PositionZValue.GetValueFromBag(bag, cc)), new Vector3Int(m_SizeXValue.GetValueFromBag(bag, cc), m_SizeYValue.GetValueFromBag(bag, cc), m_SizeZValue.GetValueFromBag(bag, cc))));
			}
		}

		private Vector3IntField m_PositionField;

		private Vector3IntField m_SizeField;

		public new static readonly string ussClassName = "unity-bounds-int-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		public static readonly string positionUssClassName = ussClassName + "__position-field";

		public static readonly string sizeUssClassName = ussClassName + "__size-field";

		public BoundsIntField()
			: this(null)
		{
		}

		public BoundsIntField(string label)
			: base(label, (VisualElement)null)
		{
			base.delegatesFocus = false;
			base.visualInput.focusable = false;
			AddToClassList(ussClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			m_PositionField = new Vector3IntField("Position");
			m_PositionField.name = "unity-m_Position-input";
			m_PositionField.delegatesFocus = true;
			m_PositionField.AddToClassList(positionUssClassName);
			m_PositionField.RegisterValueChangedCallback(delegate(ChangeEvent<Vector3Int> e)
			{
				BoundsInt boundsInt = value;
				boundsInt.position = e.newValue;
				value = boundsInt;
			});
			base.visualInput.hierarchy.Add(m_PositionField);
			m_SizeField = new Vector3IntField("Size");
			m_SizeField.name = "unity-m_Size-input";
			m_SizeField.delegatesFocus = true;
			m_SizeField.AddToClassList(sizeUssClassName);
			m_SizeField.RegisterValueChangedCallback(delegate(ChangeEvent<Vector3Int> e)
			{
				BoundsInt boundsInt = value;
				boundsInt.size = e.newValue;
				value = boundsInt;
			});
			base.visualInput.hierarchy.Add(m_SizeField);
		}

		public override void SetValueWithoutNotify(BoundsInt newValue)
		{
			base.SetValueWithoutNotify(newValue);
			m_PositionField.SetValueWithoutNotify(base.rawValue.position);
			m_SizeField.SetValueWithoutNotify(base.rawValue.size);
		}

		protected override void UpdateMixedValueContent()
		{
			m_PositionField.showMixedValue = base.showMixedValue;
			m_SizeField.showMixedValue = base.showMixedValue;
		}
	}
	public class Box : VisualElement
	{
		public new class UxmlFactory : UxmlFactory<Box>
		{
		}

		public static readonly string ussClassName = "unity-box";

		public Box()
		{
			AddToClassList(ussClassName);
		}
	}
	public class Button : TextElement
	{
		public new class UxmlFactory : UxmlFactory<Button, UxmlTraits>
		{
		}

		public new class UxmlTraits : TextElement.UxmlTraits
		{
			public UxmlTraits()
			{
				base.focusable.defaultValue = true;
			}
		}

		public new static readonly string ussClassName = "unity-button";

		private Clickable m_Clickable;

		private static readonly string NonEmptyString = " ";

		public Clickable clickable
		{
			get
			{
				return m_Clickable;
			}
			set
			{
				if (m_Clickable != null && m_Clickable.target == this)
				{
					this.RemoveManipulator(m_Clickable);
				}
				m_Clickable = value;
				if (m_Clickable != null)
				{
					this.AddManipulator(m_Clickable);
				}
			}
		}

		[Obsolete("onClick is obsolete. Use clicked instead (UnityUpgradable) -> clicked", true)]
		public event Action onClick
		{
			add
			{
				clicked += value;
			}
			remove
			{
				clicked -= value;
			}
		}

		public event Action clicked
		{
			add
			{
				if (m_Clickable == null)
				{
					clickable = new Clickable(value);
				}
				else
				{
					m_Clickable.clicked += value;
				}
			}
			remove
			{
				if (m_Clickable != null)
				{
					m_Clickable.clicked -= value;
				}
			}
		}

		public Button()
			: this(null)
		{
		}

		public Button(Action clickEvent)
		{
			AddToClassList(ussClassName);
			clickable = new Clickable(clickEvent);
			base.focusable = true;
			base.tabIndex = 0;
			RegisterCallback<NavigationSubmitEvent>(OnNavigationSubmit);
		}

		private void OnNavigationSubmit(NavigationSubmitEvent evt)
		{
			clickable?.SimulateSingleClick(evt);
			evt.StopPropagation();
		}

		protected internal override Vector2 DoMeasure(float desiredWidth, MeasureMode widthMode, float desiredHeight, MeasureMode heightMode)
		{
			string nonEmptyString = text;
			if (string.IsNullOrEmpty(nonEmptyString))
			{
				nonEmptyString = NonEmptyString;
			}
			return MeasureTextSize(nonEmptyString, desiredWidth, widthMode, desiredHeight, heightMode);
		}
	}
	internal class ButtonStripField : BaseField<int>
	{
		public new class UxmlFactory : UxmlFactory<ButtonStripField, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseField<int>.UxmlTraits
		{
		}

		public const string className = "unity-button-strip-field";

		private const string k_ButtonClass = "unity-button-strip-field__button";

		private const string k_IconClass = "unity-button-strip-field__button-icon";

		private const string k_ButtonLeftClass = "unity-button-strip-field__button--left";

		private const string k_ButtonMiddleClass = "unity-button-strip-field__button--middle";

		private const string k_ButtonRightClass = "unity-button-strip-field__button--right";

		private const string k_ButtonAloneClass = "unity-button-strip-field__button--alone";

		private List<Button> m_Buttons = new List<Button>();

		public void AddButton(string text, string name = "")
		{
			Button button = CreateButton(name);
			button.text = text;
			Add(button);
		}

		public void AddButton(Background icon, string name = "")
		{
			Button button = CreateButton(name);
			VisualElement visualElement = new VisualElement();
			visualElement.AddToClassList("unity-button-strip-field__button-icon");
			visualElement.style.backgroundImage = icon;
			button.Add(visualElement);
			Add(button);
		}

		private Button CreateButton(string name)
		{
			Button button = new Button
			{
				name = name
			};
			button.AddToClassList("unity-button-strip-field__button");
			button.RegisterCallback<DetachFromPanelEvent>(OnButtonDetachFromPanel);
			button.clicked += delegate
			{
				value = m_Buttons.IndexOf(button);
			};
			m_Buttons.Add(button);
			Add(button);
			RefreshButtonsStyling();
			return button;
		}

		private void OnButtonDetachFromPanel(DetachFromPanelEvent evt)
		{
			if (evt.currentTarget is VisualElement { parent: ButtonStripField buttonStripField })
			{
				buttonStripField.RefreshButtonsStyling();
				buttonStripField.EnsureValueIsValid();
			}
		}

		private void RefreshButtonsStyling()
		{
			for (int i = 0; i < m_Buttons.Count; i++)
			{
				Button button = m_Buttons[i];
				bool flag = m_Buttons.Count == 1;
				bool flag2 = i == 0;
				bool flag3 = i == m_Buttons.Count - 1;
				button.EnableInClassList("unity-button-strip-field__button--alone", flag);
				button.EnableInClassList("unity-button-strip-field__button--left", !flag && flag2);
				button.EnableInClassList("unity-button-strip-field__button--right", !flag && flag3);
				button.EnableInClassList("unity-button-strip-field__button--middle", !flag && !flag2 && !flag3);
			}
		}

		public ButtonStripField()
			: base((string)null)
		{
		}

		public ButtonStripField(string label)
			: base(label)
		{
			AddToClassList("unity-button-strip-field");
		}

		public override void SetValueWithoutNotify(int newValue)
		{
			newValue = Mathf.Clamp(newValue, 0, m_Buttons.Count - 1);
			base.SetValueWithoutNotify(newValue);
			RefreshButtonsState();
		}

		private void EnsureValueIsValid()
		{
			SetValueWithoutNotify(Mathf.Clamp(value, 0, m_Buttons.Count - 1));
		}

		private void RefreshButtonsState()
		{
			for (int i = 0; i < m_Buttons.Count; i++)
			{
				if (i == value)
				{
					m_Buttons[i].pseudoStates |= PseudoStates.Checked;
				}
				else
				{
					m_Buttons[i].pseudoStates &= ~PseudoStates.Checked;
				}
			}
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class RectField : BaseCompositeField<Rect, FloatField, float>
	{
		public new class UxmlFactory : UxmlFactory<RectField, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseField<Rect>.UxmlTraits
		{
			private UxmlFloatAttributeDescription m_XValue = new UxmlFloatAttributeDescription
			{
				name = "x"
			};

			private UxmlFloatAttributeDescription m_YValue = new UxmlFloatAttributeDescription
			{
				name = "y"
			};

			private UxmlFloatAttributeDescription m_WValue = new UxmlFloatAttributeDescription
			{
				name = "w"
			};

			private UxmlFloatAttributeDescription m_HValue = new UxmlFloatAttributeDescription
			{
				name = "h"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				RectField rectField = (RectField)ve;
				rectField.SetValueWithoutNotify(new Rect(m_XValue.GetValueFromBag(bag, cc), m_YValue.GetValueFromBag(bag, cc), m_WValue.GetValueFromBag(bag, cc), m_HValue.GetValueFromBag(bag, cc)));
			}
		}

		public new static readonly string ussClassName = "unity-rect-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		internal override FieldDescription[] DescribeFields()
		{
			return new FieldDescription[4]
			{
				new FieldDescription("X", "unity-x-input", (Rect r) => r.x, delegate(ref Rect r, float v)
				{
					r.x = v;
				}),
				new FieldDescription("Y", "unity-y-input", (Rect r) => r.y, delegate(ref Rect r, float v)
				{
					r.y = v;
				}),
				new FieldDescription("W", "unity-width-input", (Rect r) => r.width, delegate(ref Rect r, float v)
				{
					r.width = v;
				}),
				new FieldDescription("H", "unity-height-input", (Rect r) => r.height, delegate(ref Rect r, float v)
				{
					r.height = v;
				})
			};
		}

		public RectField()
			: this(null)
		{
		}

		public RectField(string label)
			: base(label, 2)
		{
			AddToClassList(ussClassName);
			AddToClassList(BaseCompositeField<Rect, FloatField, float>.twoLinesVariantUssClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class RectIntField : BaseCompositeField<RectInt, IntegerField, int>
	{
		public new class UxmlFactory : UxmlFactory<RectIntField, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseField<RectInt>.UxmlTraits
		{
			private UxmlIntAttributeDescription m_XValue = new UxmlIntAttributeDescription
			{
				name = "x"
			};

			private UxmlIntAttributeDescription m_YValue = new UxmlIntAttributeDescription
			{
				name = "y"
			};

			private UxmlIntAttributeDescription m_WValue = new UxmlIntAttributeDescription
			{
				name = "w"
			};

			private UxmlIntAttributeDescription m_HValue = new UxmlIntAttributeDescription
			{
				name = "h"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				RectIntField rectIntField = (RectIntField)ve;
				rectIntField.SetValueWithoutNotify(new RectInt(m_XValue.GetValueFromBag(bag, cc), m_YValue.GetValueFromBag(bag, cc), m_WValue.GetValueFromBag(bag, cc), m_HValue.GetValueFromBag(bag, cc)));
			}
		}

		public new static readonly string ussClassName = "unity-rect-int-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		internal override FieldDescription[] DescribeFields()
		{
			return new FieldDescription[4]
			{
				new FieldDescription("X", "unity-x-input", (RectInt r) => r.x, delegate(ref RectInt r, int v)
				{
					r.x = v;
				}),
				new FieldDescription("Y", "unity-y-input", (RectInt r) => r.y, delegate(ref RectInt r, int v)
				{
					r.y = v;
				}),
				new FieldDescription("W", "unity-width-input", (RectInt r) => r.width, delegate(ref RectInt r, int v)
				{
					r.width = v;
				}),
				new FieldDescription("H", "unity-height-input", (RectInt r) => r.height, delegate(ref RectInt r, int v)
				{
					r.height = v;
				})
			};
		}

		public RectIntField()
			: this(null)
		{
		}

		public RectIntField(string label)
			: base(label, 2)
		{
			AddToClassList(ussClassName);
			AddToClassList(BaseCompositeField<RectInt, IntegerField, int>.twoLinesVariantUssClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class Vector2Field : BaseCompositeField<Vector2, FloatField, float>
	{
		public new class UxmlFactory : UxmlFactory<Vector2Field, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseField<Vector2>.UxmlTraits
		{
			private UxmlFloatAttributeDescription m_XValue = new UxmlFloatAttributeDescription
			{
				name = "x"
			};

			private UxmlFloatAttributeDescription m_YValue = new UxmlFloatAttributeDescription
			{
				name = "y"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				Vector2Field vector2Field = (Vector2Field)ve;
				vector2Field.SetValueWithoutNotify(new Vector2(m_XValue.GetValueFromBag(bag, cc), m_YValue.GetValueFromBag(bag, cc)));
			}
		}

		public new static readonly string ussClassName = "unity-vector2-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		internal override FieldDescription[] DescribeFields()
		{
			return new FieldDescription[2]
			{
				new FieldDescription("X", "unity-x-input", (Vector2 r) => r.x, delegate(ref Vector2 r, float v)
				{
					r.x = v;
				}),
				new FieldDescription("Y", "unity-y-input", (Vector2 r) => r.y, delegate(ref Vector2 r, float v)
				{
					r.y = v;
				})
			};
		}

		public Vector2Field()
			: this(null)
		{
		}

		public Vector2Field(string label)
			: base(label, 2)
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class Vector3Field : BaseCompositeField<Vector3, FloatField, float>
	{
		public new class UxmlFactory : UxmlFactory<Vector3Field, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseField<Vector3>.UxmlTraits
		{
			private UxmlFloatAttributeDescription m_XValue = new UxmlFloatAttributeDescription
			{
				name = "x"
			};

			private UxmlFloatAttributeDescription m_YValue = new UxmlFloatAttributeDescription
			{
				name = "y"
			};

			private UxmlFloatAttributeDescription m_ZValue = new UxmlFloatAttributeDescription
			{
				name = "z"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				Vector3Field vector3Field = (Vector3Field)ve;
				vector3Field.SetValueWithoutNotify(new Vector3(m_XValue.GetValueFromBag(bag, cc), m_YValue.GetValueFromBag(bag, cc), m_ZValue.GetValueFromBag(bag, cc)));
			}
		}

		public new static readonly string ussClassName = "unity-vector3-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		internal override FieldDescription[] DescribeFields()
		{
			return new FieldDescription[3]
			{
				new FieldDescription("X", "unity-x-input", (Vector3 r) => r.x, delegate(ref Vector3 r, float v)
				{
					r.x = v;
				}),
				new FieldDescription("Y", "unity-y-input", (Vector3 r) => r.y, delegate(ref Vector3 r, float v)
				{
					r.y = v;
				}),
				new FieldDescription("Z", "unity-z-input", (Vector3 r) => r.z, delegate(ref Vector3 r, float v)
				{
					r.z = v;
				})
			};
		}

		public Vector3Field()
			: this(null)
		{
		}

		public Vector3Field(string label)
			: base(label, 3)
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class Vector4Field : BaseCompositeField<Vector4, FloatField, float>
	{
		public new class UxmlFactory : UxmlFactory<Vector4Field, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseField<Vector4>.UxmlTraits
		{
			private UxmlFloatAttributeDescription m_XValue = new UxmlFloatAttributeDescription
			{
				name = "x"
			};

			private UxmlFloatAttributeDescription m_YValue = new UxmlFloatAttributeDescription
			{
				name = "y"
			};

			private UxmlFloatAttributeDescription m_ZValue = new UxmlFloatAttributeDescription
			{
				name = "z"
			};

			private UxmlFloatAttributeDescription m_WValue = new UxmlFloatAttributeDescription
			{
				name = "w"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				Vector4Field vector4Field = (Vector4Field)ve;
				vector4Field.SetValueWithoutNotify(new Vector4(m_XValue.GetValueFromBag(bag, cc), m_YValue.GetValueFromBag(bag, cc), m_ZValue.GetValueFromBag(bag, cc), m_WValue.GetValueFromBag(bag, cc)));
			}
		}

		public new static readonly string ussClassName = "unity-vector4-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		internal override FieldDescription[] DescribeFields()
		{
			return new FieldDescription[4]
			{
				new FieldDescription("X", "unity-x-input", (Vector4 r) => r.x, delegate(ref Vector4 r, float v)
				{
					r.x = v;
				}),
				new FieldDescription("Y", "unity-y-input", (Vector4 r) => r.y, delegate(ref Vector4 r, float v)
				{
					r.y = v;
				}),
				new FieldDescription("Z", "unity-z-input", (Vector4 r) => r.z, delegate(ref Vector4 r, float v)
				{
					r.z = v;
				}),
				new FieldDescription("W", "unity-w-input", (Vector4 r) => r.w, delegate(ref Vector4 r, float v)
				{
					r.w = v;
				})
			};
		}

		public Vector4Field()
			: this(null)
		{
		}

		public Vector4Field(string label)
			: base(label, 4)
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class Vector2IntField : BaseCompositeField<Vector2Int, IntegerField, int>
	{
		public new class UxmlFactory : UxmlFactory<Vector2IntField, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseField<Vector2Int>.UxmlTraits
		{
			private UxmlIntAttributeDescription m_XValue = new UxmlIntAttributeDescription
			{
				name = "x"
			};

			private UxmlIntAttributeDescription m_YValue = new UxmlIntAttributeDescription
			{
				name = "y"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				Vector2IntField vector2IntField = (Vector2IntField)ve;
				vector2IntField.SetValueWithoutNotify(new Vector2Int(m_XValue.GetValueFromBag(bag, cc), m_YValue.GetValueFromBag(bag, cc)));
			}
		}

		public new static readonly string ussClassName = "unity-vector2-int-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		internal override FieldDescription[] DescribeFields()
		{
			return new FieldDescription[2]
			{
				new FieldDescription("X", "unity-x-input", (Vector2Int r) => r.x, delegate(ref Vector2Int r, int v)
				{
					r.x = v;
				}),
				new FieldDescription("Y", "unity-y-input", (Vector2Int r) => r.y, delegate(ref Vector2Int r, int v)
				{
					r.y = v;
				})
			};
		}

		public Vector2IntField()
			: this(null)
		{
		}

		public Vector2IntField(string label)
			: base(label, 2)
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class Vector3IntField : BaseCompositeField<Vector3Int, IntegerField, int>
	{
		public new class UxmlFactory : UxmlFactory<Vector3IntField, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseField<Vector3Int>.UxmlTraits
		{
			private UxmlIntAttributeDescription m_XValue = new UxmlIntAttributeDescription
			{
				name = "x"
			};

			private UxmlIntAttributeDescription m_YValue = new UxmlIntAttributeDescription
			{
				name = "y"
			};

			private UxmlIntAttributeDescription m_ZValue = new UxmlIntAttributeDescription
			{
				name = "z"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				Vector3IntField vector3IntField = (Vector3IntField)ve;
				vector3IntField.SetValueWithoutNotify(new Vector3Int(m_XValue.GetValueFromBag(bag, cc), m_YValue.GetValueFromBag(bag, cc), m_ZValue.GetValueFromBag(bag, cc)));
			}
		}

		public new static readonly string ussClassName = "unity-vector3-int-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		internal override FieldDescription[] DescribeFields()
		{
			return new FieldDescription[3]
			{
				new FieldDescription("X", "unity-x-input", (Vector3Int r) => r.x, delegate(ref Vector3Int r, int v)
				{
					r.x = v;
				}),
				new FieldDescription("Y", "unity-y-input", (Vector3Int r) => r.y, delegate(ref Vector3Int r, int v)
				{
					r.y = v;
				}),
				new FieldDescription("Z", "unity-z-input", (Vector3Int r) => r.z, delegate(ref Vector3Int r, int v)
				{
					r.z = v;
				})
			};
		}

		public Vector3IntField()
			: this(null)
		{
		}

		public Vector3IntField(string label)
			: base(label, 3)
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class DoubleField : TextValueField<double>
	{
		public new class UxmlFactory : UxmlFactory<DoubleField, UxmlTraits>
		{
		}

		public new class UxmlTraits : TextValueFieldTraits<double, UxmlDoubleAttributeDescription>
		{
		}

		private class DoubleInput : TextValueInput
		{
			private DoubleField parentDoubleField => (DoubleField)base.parent;

			protected override string allowedCharacters => UINumericFieldsUtils.k_AllowedCharactersForFloat;

			internal DoubleInput()
			{
				base.formatString = UINumericFieldsUtils.k_DoubleFieldFormatString;
			}

			public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, double startValue)
			{
				double num = NumericFieldDraggerUtility.CalculateFloatDragSensitivity(startValue);
				float acceleration = NumericFieldDraggerUtility.Acceleration(speed == DeltaSpeed.Fast, speed == DeltaSpeed.Slow);
				double num2 = StringToValue(base.text);
				num2 += (double)NumericFieldDraggerUtility.NiceDelta(delta, acceleration) * num;
				num2 = Mathf.RoundBasedOnMinimumDifference(num2, num);
				if (parentDoubleField.isDelayed)
				{
					base.text = ValueToString(num2);
				}
				else
				{
					parentDoubleField.value = num2;
				}
			}

			protected override string ValueToString(double v)
			{
				return v.ToString(base.formatString);
			}

			protected override double StringToValue(string str)
			{
				UINumericFieldsUtils.TryConvertStringToDouble(str, base.originalText, out var value);
				return value;
			}
		}

		public new static readonly string ussClassName = "unity-double-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		private DoubleInput doubleInput => (DoubleInput)base.textInputBase;

		protected override string ValueToString(double v)
		{
			return v.ToString(base.formatString, CultureInfo.InvariantCulture.NumberFormat);
		}

		protected override double StringToValue(string str)
		{
			double num;
			return UINumericFieldsUtils.TryConvertStringToDouble(str, base.textInputBase.originalText, out num) ? num : base.rawValue;
		}

		public DoubleField()
			: this(null)
		{
		}

		public DoubleField(int maxLength)
			: this(null, maxLength)
		{
		}

		public DoubleField(string label, int maxLength = 1000)
			: base(label, maxLength, (TextValueInput)new DoubleInput())
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			AddLabelDragger<double>();
		}

		internal override bool CanTryParse(string textString)
		{
			double result;
			return double.TryParse(textString, out result);
		}

		public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, double startValue)
		{
			doubleInput.ApplyInputDeviceDelta(delta, speed, startValue);
		}
	}
	public class DropdownField : PopupField<string>
	{
		public new class UxmlFactory : UxmlFactory<DropdownField, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseField<string>.UxmlTraits
		{
			private UxmlIntAttributeDescription m_Index = new UxmlIntAttributeDescription
			{
				name = "index",
				defaultValue = -1
			};

			private UxmlStringAttributeDescription m_Choices = new UxmlStringAttributeDescription
			{
				name = "choices"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				DropdownField dropdownField = (DropdownField)ve;
				List<string> list = BaseField<string>.UxmlTraits.ParseChoiceList(m_Choices.GetValueFromBag(bag, cc));
				if (list != null)
				{
					dropdownField.choices = list;
				}
				dropdownField.index = m_Index.GetValueFromBag(bag, cc);
			}
		}

		public DropdownField()
			: this(null)
		{
		}

		public DropdownField(string label)
			: base(label)
		{
		}

		public DropdownField(List<string> choices, string defaultValue, Func<string, string> formatSelectedValueCallback = null, Func<string, string> formatListItemCallback = null)
			: this(null, choices, defaultValue, formatSelectedValueCallback, formatListItemCallback)
		{
		}

		public DropdownField(string label, List<string> choices, string defaultValue, Func<string, string> formatSelectedValueCallback = null, Func<string, string> formatListItemCallback = null)
			: base(label, choices, defaultValue, formatSelectedValueCallback, formatListItemCallback)
		{
		}

		public DropdownField(List<string> choices, int defaultIndex, Func<string, string> formatSelectedValueCallback = null, Func<string, string> formatListItemCallback = null)
			: this(null, choices, defaultIndex, formatSelectedValueCallback, formatListItemCallback)
		{
		}

		public DropdownField(string label, List<string> choices, int defaultIndex, Func<string, string> formatSelectedValueCallback = null, Func<string, string> formatListItemCallback = null)
			: base(label, choices, defaultIndex, formatSelectedValueCallback, formatListItemCallback)
		{
		}
	}
	internal static class EnumFieldHelpers
	{
		internal static readonly UxmlTypeAttributeDescription<Enum> type = new UxmlTypeAttributeDescription<Enum>
		{
			name = "type"
		};

		internal static readonly UxmlStringAttributeDescription value = new UxmlStringAttributeDescription
		{
			name = "value"
		};

		internal static readonly UxmlBoolAttributeDescription includeObsoleteValues = new UxmlBoolAttributeDescription
		{
			name = "include-obsolete-values",
			defaultValue = false
		};

		internal static bool ExtractValue(IUxmlAttributes bag, CreationContext cc, out Type resEnumType, out Enum resEnumValue, out bool resIncludeObsoleteValues)
		{
			resIncludeObsoleteValues = false;
			resEnumValue = null;
			resEnumType = type.GetValueFromBag(bag, cc);
			if (resEnumType == null)
			{
				return false;
			}
			string text = null;
			object result = null;
			if (value.TryGetValueFromBag(bag, cc, ref text) && !Enum.TryParse(resEnumType, text, ignoreCase: false, out result))
			{
				Debug.LogErrorFormat("EnumField: Could not parse value of '{0}', because it isn't defined in the {1} enum.", text, resEnumType.FullName);
				return false;
			}
			resEnumValue = ((text != null && result != null) ? ((Enum)result) : ((Enum)Enum.ToObject(resEnumType, 0)));
			resIncludeObsoleteValues = includeObsoleteValues.GetValueFromBag(bag, cc);
			return true;
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class EnumField : BaseField<Enum>
	{
		public new class UxmlFactory : UxmlFactory<EnumField, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseField<Enum>.UxmlTraits
		{
			private UxmlTypeAttributeDescription<Enum> m_Type = EnumFieldHelpers.type;

			private UxmlStringAttributeDescription m_Value = EnumFieldHelpers.value;

			private UxmlBoolAttributeDescription m_IncludeObsoleteValues = EnumFieldHelpers.includeObsoleteValues;

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				if (EnumFieldHelpers.ExtractValue(bag, cc, out var resEnumType, out var resEnumValue, out var resIncludeObsoleteValues))
				{
					EnumField enumField = (EnumField)ve;
					enumField.Init(resEnumValue, resIncludeObsoleteValues);
				}
				else if (null != resEnumType)
				{
					EnumField enumField2 = (EnumField)ve;
					enumField2.m_EnumType = resEnumType;
					if (enumField2.m_EnumType != null)
					{
						enumField2.PopulateDataFromType(enumField2.m_EnumType);
					}
					enumField2.value = null;
				}
				else
				{
					EnumField enumField3 = (EnumField)ve;
					enumField3.m_EnumType = null;
					enumField3.value = null;
				}
			}
		}

		private Type m_EnumType;

		private bool m_IncludeObsoleteValues;

		private TextElement m_TextElement;

		private VisualElement m_ArrowElement;

		private EnumData m_EnumData;

		internal Func<IGenericMenu> createMenuCallback;

		public new static readonly string ussClassName = "unity-enum-field";

		public static readonly string textUssClassName = ussClassName + "__text";

		public static readonly string arrowUssClassName = ussClassName + "__arrow";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		internal Type type => m_EnumType;

		internal bool includeObsoleteValues => m_IncludeObsoleteValues;

		public string text => m_TextElement.text;

		private void Initialize(Enum defaultValue)
		{
			m_TextElement = new TextElement();
			m_TextElement.AddToClassList(textUssClassName);
			m_TextElement.pickingMode = PickingMode.Ignore;
			base.visualInput.Add(m_TextElement);
			m_ArrowElement = new VisualElement();
			m_ArrowElement.AddToClassList(arrowUssClassName);
			m_ArrowElement.pickingMode = PickingMode.Ignore;
			base.visualInput.Add(m_ArrowElement);
			if (defaultValue != null)
			{
				Init(defaultValue);
			}
		}

		public EnumField()
			: this(null, null)
		{
		}

		public EnumField(Enum defaultValue)
			: this(null, defaultValue)
		{
		}

		public EnumField(string label, Enum defaultValue = null)
			: base(label, (VisualElement)null)
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			Initialize(defaultValue);
			RegisterCallback<PointerDownEvent>(OnPointerDownEvent);
			RegisterCallback<PointerMoveEvent>(OnPointerMoveEvent);
			RegisterCallback(delegate(MouseDownEvent e)
			{
				if (e.button == 0)
				{
					e.StopPropagation();
				}
			});
			RegisterCallback<NavigationSubmitEvent>(OnNavigationSubmit);
		}

		public void Init(Enum defaultValue)
		{
			Init(defaultValue, includeObsoleteValues: false);
		}

		public void Init(Enum defaultValue, bool includeObsoleteValues)
		{
			if (defaultValue == null)
			{
				throw new ArgumentNullException("defaultValue");
			}
			m_IncludeObsoleteValues = includeObsoleteValues;
			PopulateDataFromType(defaultValue.GetType());
			if (!object.Equals(base.rawValue, defaultValue))
			{
				SetValueWithoutNotify(defaultValue);
			}
			else
			{
				UpdateValueLabel(defaultValue);
			}
		}

		internal void PopulateDataFromType(Type enumType)
		{
			m_EnumType = enumType;
			m_EnumData = EnumDataUtility.GetCachedEnumData(m_EnumType, includeObsoleteValues ? EnumDataUtility.CachedType.IncludeObsoleteExceptErrors : EnumDataUtility.CachedType.ExcludeObsolete);
		}

		public override void SetValueWithoutNotify(Enum newValue)
		{
			if (!object.Equals(base.rawValue, newValue))
			{
				base.SetValueWithoutNotify(newValue);
				if (!(m_EnumType == null))
				{
					UpdateValueLabel(newValue);
				}
			}
		}

		private void UpdateValueLabel(Enum value)
		{
			int num = Array.IndexOf(m_EnumData.values, value);
			if ((num >= 0) & (num < m_EnumData.values.Length))
			{
				m_TextElement.text = m_EnumData.displayNames[num];
			}
			else
			{
				m_TextElement.text = string.Empty;
			}
		}

		private void OnPointerDownEvent(PointerDownEvent evt)
		{
			ProcessPointerDown(evt);
		}

		private void OnPointerMoveEvent(PointerMoveEvent evt)
		{
			if (evt.button == 0 && (evt.pressedButtons & 1) != 0)
			{
				ProcessPointerDown(evt);
			}
		}

		private bool ContainsPointer(int pointerId)
		{
			VisualElement topElementUnderPointer = base.elementPanel.GetTopElementUnderPointer(pointerId);
			return this == topElementUnderPointer || base.visualInput == topElementUnderPointer;
		}

		private void ProcessPointerDown<T>(PointerEventBase<T> evt) where T : PointerEventBase<T>, new()
		{
			if (evt.button == 0 && ContainsPointer(evt.pointerId))
			{
				ShowMenu();
				evt.StopPropagation();
			}
		}

		private void OnNavigationSubmit(NavigationSubmitEvent evt)
		{
			ShowMenu();
			evt.StopPropagation();
		}

		private void ShowMenu()
		{
			if (m_EnumType == null)
			{
				return;
			}
			IGenericMenu genericMenu;
			if (createMenuCallback != null)
			{
				genericMenu = createMenuCallback();
			}
			else
			{
				BaseVisualElementPanel baseVisualElementPanel = base.elementPanel;
				IGenericMenu genericMenu2;
				if (baseVisualElementPanel == null || baseVisualElementPanel.contextType != ContextType.Player)
				{
					genericMenu2 = DropdownUtility.CreateDropdown();
				}
				else
				{
					IGenericMenu genericMenu3 = new GenericDropdownMenu();
					genericMenu2 = genericMenu3;
				}
				genericMenu = genericMenu2;
			}
			int num = Array.IndexOf(m_EnumData.values, value);
			for (int i = 0; i < m_EnumData.values.Length; i++)
			{
				bool isChecked = num == i;
				genericMenu.AddItem(m_EnumData.displayNames[i], isChecked, delegate(object contentView)
				{
					ChangeValueFromMenu(contentView);
				}, m_EnumData.values[i]);
			}
			genericMenu.DropDown(base.visualInput.worldBound, this, anchored: true);
		}

		private void ChangeValueFromMenu(object menuItem)
		{
			value = menuItem as Enum;
		}

		protected override void UpdateMixedValueContent()
		{
			if (base.showMixedValue)
			{
				m_TextElement.text = BaseField<Enum>.mixedValueString;
			}
			else
			{
				UpdateValueLabel(value);
			}
			m_TextElement.EnableInClassList(labelUssClassName, base.showMixedValue);
			m_TextElement.EnableInClassList(BaseField<Enum>.mixedValueLabelUssClassName, base.showMixedValue);
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class FloatField : TextValueField<float>
	{
		public new class UxmlFactory : UxmlFactory<FloatField, UxmlTraits>
		{
		}

		public new class UxmlTraits : TextValueFieldTraits<float, UxmlFloatAttributeDescription>
		{
		}

		private class FloatInput : TextValueInput
		{
			private FloatField parentFloatField => (FloatField)base.parent;

			protected override string allowedCharacters => UINumericFieldsUtils.k_AllowedCharactersForFloat;

			internal FloatInput()
			{
				base.formatString = UINumericFieldsUtils.k_FloatFieldFormatString;
			}

			public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, float startValue)
			{
				double num = NumericFieldDraggerUtility.CalculateFloatDragSensitivity(startValue);
				float acceleration = NumericFieldDraggerUtility.Acceleration(speed == DeltaSpeed.Fast, speed == DeltaSpeed.Slow);
				double num2 = StringToValue(base.text);
				num2 += (double)NumericFieldDraggerUtility.NiceDelta(delta, acceleration) * num;
				num2 = Mathf.RoundBasedOnMinimumDifference(num2, num);
				if (parentFloatField.isDelayed)
				{
					base.text = ValueToString(Mathf.ClampToFloat(num2));
				}
				else
				{
					parentFloatField.value = Mathf.ClampToFloat(num2);
				}
			}

			protected override string ValueToString(float v)
			{
				return v.ToString(base.formatString);
			}

			protected override float StringToValue(string str)
			{
				UINumericFieldsUtils.TryConvertStringToFloat(str, base.originalText, out var value);
				return value;
			}
		}

		public new static readonly string ussClassName = "unity-float-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		private FloatInput floatInput => (FloatInput)base.textInputBase;

		protected override string ValueToString(float v)
		{
			return v.ToString(base.formatString, CultureInfo.InvariantCulture.NumberFormat);
		}

		protected override float StringToValue(string str)
		{
			float num;
			return UINumericFieldsUtils.TryConvertStringToFloat(str, base.textInputBase.originalText, out num) ? num : base.rawValue;
		}

		public FloatField()
			: this(null)
		{
		}

		public FloatField(int maxLength)
			: this(null, maxLength)
		{
		}

		public FloatField(string label, int maxLength = 1000)
			: base(label, maxLength, (TextValueInput)new FloatInput())
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			AddLabelDragger<float>();
		}

		internal override bool CanTryParse(string textString)
		{
			float result;
			return float.TryParse(textString, out result);
		}

		public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, float startValue)
		{
			floatInput.ApplyInputDeviceDelta(delta, speed, startValue);
		}
	}
	public class Foldout : BindableElement, INotifyValueChanged<bool>
	{
		public new class UxmlFactory : UxmlFactory<Foldout, UxmlTraits>
		{
		}

		public new class UxmlTraits : BindableElement.UxmlTraits
		{
			private UxmlStringAttributeDescription m_Text = new UxmlStringAttributeDescription
			{
				name = "text"
			};

			private UxmlBoolAttributeDescription m_Value = new UxmlBoolAttributeDescription
			{
				name = "value",
				defaultValue = true
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				if (ve is Foldout foldout)
				{
					foldout.text = m_Text.GetValueFromBag(bag, cc);
					foldout.SetValueWithoutNotify(m_Value.GetValueFromBag(bag, cc));
				}
			}
		}

		private Toggle m_Toggle = new Toggle();

		private VisualElement m_Container;

		[SerializeField]
		private bool m_Value;

		public static readonly string ussClassName = "unity-foldout";

		public static readonly string toggleUssClassName = ussClassName + "__toggle";

		public static readonly string contentUssClassName = ussClassName + "__content";

		public static readonly string inputUssClassName = ussClassName + "__input";

		public static readonly string checkmarkUssClassName = ussClassName + "__checkmark";

		public static readonly string textUssClassName = ussClassName + "__text";

		internal static readonly string toggleInspectorUssClassName = toggleUssClassName + "--inspector";

		internal static readonly string ussFoldoutDepthClassName = ussClassName + "--depth-";

		internal static readonly int ussFoldoutMaxDepth = 4;

		private KeyboardNavigationManipulator m_NavigationManipulator;

		internal Toggle toggle => m_Toggle;

		public override VisualElement contentContainer => m_Container;

		public string text
		{
			get
			{
				return m_Toggle.text;
			}
			set
			{
				m_Toggle.text = value;
				m_Toggle.visualInput.Q(null, Toggle.textUssClassName)?.AddToClassList(textUssClassName);
			}
		}

		public bool value
		{
			get
			{
				return m_Value;
			}
			set
			{
				if (m_Value == value)
				{
					return;
				}
				using ChangeEvent<bool> changeEvent = ChangeEvent<bool>.GetPooled(m_Value, value);
				changeEvent.target = this;
				SetValueWithoutNotify(value);
				SendEvent(changeEvent);
				SaveViewData();
			}
		}

		public void SetValueWithoutNotify(bool newValue)
		{
			m_Value = newValue;
			m_Toggle.SetValueWithoutNotify(m_Value);
			contentContainer.style.display = ((!newValue) ? DisplayStyle.None : DisplayStyle.Flex);
			if (m_Value)
			{
				base.pseudoStates |= PseudoStates.Checked;
			}
			else
			{
				base.pseudoStates &= ~PseudoStates.Checked;
			}
		}

		internal override void OnViewDataReady()
		{
			base.OnViewDataReady();
			string fullHierarchicalViewDataKey = GetFullHierarchicalViewDataKey();
			OverwriteFromViewData(this, fullHierarchicalViewDataKey);
			SetValueWithoutNotify(m_Value);
		}

		private void Apply(KeyboardNavigationOperation op, EventBase sourceEvent)
		{
			if (Apply(op))
			{
				sourceEvent.StopPropagation();
			}
		}

		private bool Apply(KeyboardNavigationOperation op)
		{
			switch (op)
			{
			case KeyboardNavigationOperation.MoveRight:
				SetValueWithoutNotify(newValue: true);
				return true;
			case KeyboardNavigationOperation.MoveLeft:
				SetValueWithoutNotify(newValue: false);
				return true;
			default:
				throw new ArgumentOutOfRangeException("op", op, null);
			case KeyboardNavigationOperation.SelectAll:
			case KeyboardNavigationOperation.Cancel:
			case KeyboardNavigationOperation.Submit:
			case KeyboardNavigationOperation.Previous:
			case KeyboardNavigationOperation.Next:
			case KeyboardNavigationOperation.PageUp:
			case KeyboardNavigationOperation.PageDown:
			case KeyboardNavigationOperation.Begin:
			case KeyboardNavigationOperation.End:
				return false;
			}
		}

		public Foldout()
		{
			AddToClassList(ussClassName);
			base.delegatesFocus = true;
			m_Container = new VisualElement
			{
				name = "unity-content"
			};
			m_Toggle.RegisterValueChangedCallback(delegate(ChangeEvent<bool> evt)
			{
				value = m_Toggle.value;
				evt.StopPropagation();
			});
			m_Toggle.AddToClassList(toggleUssClassName);
			m_Toggle.visualInput.AddToClassList(inputUssClassName);
			m_Toggle.visualInput.Q(null, Toggle.checkmarkUssClassName).AddToClassList(checkmarkUssClassName);
			m_Toggle.AddManipulator(m_NavigationManipulator = new KeyboardNavigationManipulator(Apply));
			base.hierarchy.Add(m_Toggle);
			m_Container.AddToClassList(contentUssClassName);
			base.hierarchy.Add(m_Container);
			RegisterCallback<AttachToPanelEvent>(OnAttachToPanel);
			SetValueWithoutNotify(newValue: true);
		}

		private void OnAttachToPanel(AttachToPanelEvent evt)
		{
			for (int i = 0; i <= ussFoldoutMaxDepth; i++)
			{
				RemoveFromClassList(ussFoldoutDepthClassName + i);
			}
			RemoveFromClassList(ussFoldoutDepthClassName + "max");
			m_Toggle.AssignInspectorStyleIfNecessary(toggleInspectorUssClassName);
			int foldoutDepth = this.GetFoldoutDepth();
			if (foldoutDepth > ussFoldoutMaxDepth)
			{
				AddToClassList(ussFoldoutDepthClassName + "max");
			}
			else
			{
				AddToClassList(ussFoldoutDepthClassName + foldoutDepth);
			}
		}
	}
	internal interface IGenericMenu
	{
		void AddItem(string itemName, bool isChecked, Action action);

		void AddItem(string itemName, bool isChecked, Action<object> action, object data);

		void AddDisabledItem(string itemName, bool isChecked);

		void AddSeparator(string path);

		void DropDown(Rect position, VisualElement targetElement = null, bool anchored = false);
	}
	public class GenericDropdownMenu : IGenericMenu
	{
		internal class MenuItem
		{
			public string name;

			public VisualElement element;

			public Action action;

			public Action<object> actionUserData;
		}

		public static readonly string ussClassName = "unity-base-dropdown";

		public static readonly string itemUssClassName = ussClassName + "__item";

		public static readonly string labelUssClassName = ussClassName + "__label";

		public static readonly string containerInnerUssClassName = ussClassName + "__container-inner";

		public static readonly string containerOuterUssClassName = ussClassName + "__container-outer";

		public static readonly string checkmarkUssClassName = ussClassName + "__checkmark";

		public static readonly string separatorUssClassName = ussClassName + "__separator";

		private List<MenuItem> m_Items = new List<MenuItem>();

		private VisualElement m_MenuContainer;

		private VisualElement m_OuterContainer;

		private ScrollView m_ScrollView;

		private VisualElement m_PanelRootVisualContainer;

		private VisualElement m_TargetElement;

		private Rect m_DesiredRect;

		private KeyboardNavigationManipulator m_NavigationManipulator;

		private Vector2 m_MousePosition;

		internal List<MenuItem> items => m_Items;

		internal VisualElement menuContainer => m_MenuContainer;

		internal VisualElement outerContainer => m_OuterContainer;

		internal ScrollView scrollView => m_ScrollView;

		internal bool isSingleSelectionDropdown { get; set; }

		internal bool closeOnParentResize { get; set; }

		public VisualElement contentContainer => m_ScrollView.contentContainer;

		public GenericDropdownMenu()
		{
			m_MenuContainer = new VisualElement();
			m_MenuContainer.AddToClassList(ussClassName);
			m_OuterContainer = new VisualElement();
			m_OuterContainer.AddToClassList(containerOuterUssClassName);
			m_MenuContainer.Add(m_OuterContainer);
			m_ScrollView = new ScrollView();
			m_ScrollView.AddToClassList(containerInnerUssClassName);
			m_ScrollView.pickingMode = PickingMode.Position;
			m_ScrollView.contentContainer.focusable = true;
			m_ScrollView.touchScrollBehavior = ScrollView.TouchScrollBehavior.Clamped;
			m_OuterContainer.hierarchy.Add(m_ScrollView);
			m_MenuContainer.RegisterCallback<AttachToPanelEvent>(OnAttachToPanel);
			m_MenuContainer.RegisterCallback<DetachFromPanelEvent>(OnDetachFromPanel);
			isSingleSelectionDropdown = true;
			closeOnParentResize = true;
		}

		private void OnAttachToPanel(AttachToPanelEvent evt)
		{
			if (evt.destinationPanel != null)
			{
				contentContainer.AddManipulator(m_NavigationManipulator = new KeyboardNavigationManipulator(Apply));
				m_MenuContainer.RegisterCallback<PointerDownEvent>(OnPointerDown);
				m_MenuContainer.RegisterCallback<PointerMoveEvent>(OnPointerMove);
				m_MenuContainer.RegisterCallback<PointerUpEvent>(OnPointerUp);
				evt.destinationPanel.visualTree.RegisterCallback<GeometryChangedEvent>(OnParentResized);
				m_ScrollView.RegisterCallback<GeometryChangedEvent>(OnContainerGeometryChanged);
				m_ScrollView.RegisterCallback<FocusOutEvent>(OnFocusOut);
			}
		}

		private void OnDetachFromPanel(DetachFromPanelEvent evt)
		{
			if (evt.originPanel != null)
			{
				contentContainer.RemoveManipulator(m_NavigationManipulator);
				m_MenuContainer.UnregisterCallback<PointerDownEvent>(OnPointerDown);
				m_MenuContainer.UnregisterCallback<PointerMoveEvent>(OnPointerMove);
				m_MenuContainer.UnregisterCallback<PointerUpEvent>(OnPointerUp);
				evt.originPanel.visualTree.UnregisterCallback<GeometryChangedEvent>(OnParentResized);
				m_ScrollView.UnregisterCallback<GeometryChangedEvent>(OnContainerGeometryChanged);
				m_ScrollView.UnregisterCallback<FocusOutEvent>(OnFocusOut);
			}
		}

		private void Hide(bool giveFocusBack = false)
		{
			m_MenuContainer.RemoveFromHierarchy();
			if (m_TargetElement != null)
			{
				m_TargetElement.pseudoStates ^= PseudoStates.Active;
				if (giveFocusBack && m_TargetElement.canGrabFocus)
				{
					m_TargetElement.Focus();
				}
			}
			m_TargetElement = null;
		}

		private void Apply(KeyboardNavigationOperation op, EventBase sourceEvent)
		{
			if (Apply(op))
			{
				sourceEvent.StopPropagation();
				sourceEvent.PreventDefault();
			}
		}

		private bool Apply(KeyboardNavigationOperation op)
		{
			int selectedIndex = GetSelectedIndex();
			switch (op)
			{
			case KeyboardNavigationOperation.Cancel:
				Hide(giveFocusBack: true);
				return true;
			case KeyboardNavigationOperation.Submit:
			{
				MenuItem menuItem = m_Items[selectedIndex];
				if (selectedIndex >= 0 && menuItem.element.enabledSelf)
				{
					menuItem.action?.Invoke();
					menuItem.actionUserData?.Invoke(menuItem.element.userData);
				}
				Hide(giveFocusBack: true);
				return true;
			}
			case KeyboardNavigationOperation.Previous:
				UpdateSelectionUp((selectedIndex < 0) ? (m_Items.Count - 1) : (selectedIndex - 1));
				return true;
			case KeyboardNavigationOperation.Next:
				UpdateSelectionDown(selectedIndex + 1);
				return true;
			case KeyboardNavigationOperation.PageUp:
			case KeyboardNavigationOperation.Begin:
				UpdateSelectionDown(0);
				return true;
			case KeyboardNavigationOperation.PageDown:
			case KeyboardNavigationOperation.End:
				UpdateSelectionUp(m_Items.Count - 1);
				return true;
			default:
				return false;
			}
			void UpdateSelectionDown(int newIndex)
			{
				while (newIndex < m_Items.Count)
				{
					if (m_Items[newIndex].element.enabledSelf)
					{
						ChangeSelectedIndex(newIndex, selectedIndex);
						break;
					}
					newIndex++;
				}
			}
			void UpdateSelectionUp(int newIndex)
			{
				while (newIndex >= 0)
				{
					if (m_Items[newIndex].element.enabledSelf)
					{
						ChangeSelectedIndex(newIndex, selectedIndex);
						break;
					}
					newIndex--;
				}
			}
		}

		private void OnPointerDown(PointerDownEvent evt)
		{
			m_MousePosition = m_ScrollView.WorldToLocal(evt.position);
			UpdateSelection(evt.target as VisualElement);
			if (evt.pointerId != PointerId.mousePointerId)
			{
				m_MenuContainer.panel.PreventCompatibilityMouseEvents(evt.pointerId);
			}
			evt.StopPropagation();
		}

		private void OnPointerMove(PointerMoveEvent evt)
		{
			m_MousePosition = m_ScrollView.WorldToLocal(evt.position);
			UpdateSelection(evt.target as VisualElement);
			if (evt.pointerId != PointerId.mousePointerId)
			{
				m_MenuContainer.panel.PreventCompatibilityMouseEvents(evt.pointerId);
			}
			evt.StopPropagation();
		}

		private void OnPointerUp(PointerUpEvent evt)
		{
			int selectedIndex = GetSelectedIndex();
			if (selectedIndex != -1)
			{
				MenuItem menuItem = m_Items[selectedIndex];
				menuItem.action?.Invoke();
				menuItem.actionUserData?.Invoke(menuItem.element.userData);
				if (isSingleSelectionDropdown)
				{
					Hide(giveFocusBack: true);
				}
			}
			if (evt.pointerId != PointerId.mousePointerId)
			{
				m_MenuContainer.panel.PreventCompatibilityMouseEvents(evt.pointerId);
			}
			evt.StopPropagation();
		}

		private void OnFocusOut(FocusOutEvent evt)
		{
			if (!m_ScrollView.ContainsPoint(m_MousePosition))
			{
				Hide();
			}
			else
			{
				m_MenuContainer.schedule.Execute(contentContainer.Focus);
			}
		}

		private void OnParentResized(GeometryChangedEvent evt)
		{
			if (closeOnParentResize)
			{
				Hide(giveFocusBack: true);
			}
		}

		private void UpdateSelection(VisualElement target)
		{
			if (!m_ScrollView.ContainsPoint(m_MousePosition))
			{
				int selectedIndex = GetSelectedIndex();
				if (selectedIndex >= 0)
				{
					m_Items[selectedIndex].element.pseudoStates &= ~PseudoStates.Hover;
				}
			}
			else if (target != null && (target.pseudoStates & PseudoStates.Hover) != PseudoStates.Hover)
			{
				int selectedIndex2 = GetSelectedIndex();
				if (selectedIndex2 >= 0)
				{
					m_Items[selectedIndex2].element.pseudoStates &= ~PseudoStates.Hover;
				}
				target.pseudoStates |= PseudoStates.Hover;
			}
		}

		private void ChangeSelectedIndex(int newIndex, int previousIndex)
		{
			if (previousIndex >= 0 && previousIndex < m_Items.Count)
			{
				m_Items[previousIndex].element.pseudoStates &= ~PseudoStates.Hover;
			}
			if (newIndex >= 0 && newIndex < m_Items.Count)
			{
				m_Items[newIndex].element.pseudoStates |= PseudoStates.Hover;
				m_ScrollView.ScrollTo(m_Items[newIndex].element);
			}
		}

		private int GetSelectedIndex()
		{
			for (int i = 0; i < m_Items.Count; i++)
			{
				if ((m_Items[i].element.pseudoStates & PseudoStates.Hover) == PseudoStates.Hover)
				{
					return i;
				}
			}
			return -1;
		}

		public void AddItem(string itemName, bool isChecked, Action action)
		{
			MenuItem menuItem = AddItem(itemName, isChecked, isEnabled: true);
			if (menuItem != null)
			{
				menuItem.action = action;
			}
		}

		public void AddItem(string itemName, bool isChecked, Action<object> action, object data)
		{
			MenuItem menuItem = AddItem(itemName, isChecked, isEnabled: true, data);
			if (menuItem != null)
			{
				menuItem.actionUserData = action;
			}
		}

		public void AddDisabledItem(string itemName, bool isChecked)
		{
			AddItem(itemName, isChecked, isEnabled: false);
		}

		public void AddSeparator(string path)
		{
			VisualElement visualElement = new VisualElement();
			visualElement.AddToClassList(separatorUssClassName);
			visualElement.pickingMode = PickingMode.Ignore;
			m_ScrollView.Add(visualElement);
		}

		private MenuItem AddItem(string itemName, bool isChecked, bool isEnabled, object data = null)
		{
			if (string.IsNullOrEmpty(itemName) || itemName.EndsWith("/"))
			{
				AddSeparator(itemName);
				return null;
			}
			for (int i = 0; i < m_Items.Count; i++)
			{
				if (itemName == m_Items[i].name)
				{
					return null;
				}
			}
			VisualElement visualElement = new VisualElement();
			visualElement.AddToClassList(itemUssClassName);
			visualElement.SetEnabled(isEnabled);
			visualElement.userData = data;
			VisualElement visualElement2 = new VisualElement();
			visualElement2.AddToClassList(checkmarkUssClassName);
			visualElement2.pickingMode = PickingMode.Ignore;
			visualElement.Add(visualElement2);
			if (isChecked)
			{
				visualElement.pseudoStates |= PseudoStates.Checked;
			}
			Label label = new Label(itemName);
			label.AddToClassList(labelUssClassName);
			label.pickingMode = PickingMode.Ignore;
			visualElement.Add(label);
			m_ScrollView.Add(visualElement);
			MenuItem menuItem = new MenuItem
			{
				name = itemName,
				element = visualElement
			};
			m_Items.Add(menuItem);
			return menuItem;
		}

		internal void UpdateItem(string itemName, bool isChecked)
		{
			MenuItem menuItem = m_Items.Find((MenuItem x) => x.name == itemName);
			if (menuItem != null)
			{
				if (isChecked)
				{
					menuItem.element.pseudoStates |= PseudoStates.Checked;
				}
				else
				{
					menuItem.element.pseudoStates &= ~PseudoStates.Checked;
				}
			}
		}

		public void DropDown(Rect position, VisualElement targetElement = null, bool anchored = false)
		{
			if (targetElement == null)
			{
				Debug.LogError("VisualElement Generic Menu needs a target to find a root to attach to.");
				return;
			}
			m_TargetElement = targetElement;
			m_TargetElement.RegisterCallback<DetachFromPanelEvent>(OnTargetElementDetachFromPanel);
			m_PanelRootVisualContainer = m_TargetElement.GetRootVisualContainer();
			if (m_PanelRootVisualContainer == null)
			{
				Debug.LogError("Could not find rootVisualContainer...");
				return;
			}
			m_PanelRootVisualContainer.Add(m_MenuContainer);
			m_MenuContainer.style.left = m_PanelRootVisualContainer.layout.x;
			m_MenuContainer.style.top = m_PanelRootVisualContainer.layout.y;
			m_MenuContainer.style.width = m_PanelRootVisualContainer.layout.width;
			m_MenuContainer.style.height = m_PanelRootVisualContainer.layout.height;
			m_MenuContainer.style.fontSize = m_TargetElement.computedStyle.fontSize;
			m_MenuContainer.style.unityFont = m_TargetElement.computedStyle.unityFont;
			m_MenuContainer.style.unityFontDefinition = m_TargetElement.computedStyle.unityFontDefinition;
			Rect rect = m_PanelRootVisualContainer.WorldToLocal(position);
			m_OuterContainer.style.left = rect.x - m_PanelRootVisualContainer.layout.x;
			m_OuterContainer.style.top = rect.y + position.height - m_PanelRootVisualContainer.layout.y;
			m_DesiredRect = (anchored ? position : Rect.zero);
			m_MenuContainer.schedule.Execute(contentContainer.Focus);
			EnsureVisibilityInParent();
			if (targetElement != null)
			{
				targetElement.pseudoStates |= PseudoStates.Active;
			}
		}

		private void OnTargetElementDetachFromPanel(DetachFromPanelEvent evt)
		{
			Hide();
		}

		private void OnContainerGeometryChanged(GeometryChangedEvent evt)
		{
			EnsureVisibilityInParent();
		}

		private void EnsureVisibilityInParent()
		{
			if (m_PanelRootVisualContainer != null && !float.IsNaN(m_OuterContainer.layout.width) && !float.IsNaN(m_OuterContainer.layout.height))
			{
				if (m_DesiredRect == Rect.zero)
				{
					float num = Mathf.Min(m_OuterContainer.layout.x, m_PanelRootVisualContainer.layout.width - m_OuterContainer.layout.width);
					float num2 = Mathf.Min(m_OuterContainer.layout.y, Mathf.Max(0f, m_PanelRootVisualContainer.layout.height - m_OuterContainer.layout.height));
					m_OuterContainer.style.left = num;
					m_OuterContainer.style.top = num2;
				}
				m_OuterContainer.style.height = Mathf.Min(m_MenuContainer.layout.height - m_MenuContainer.layout.y - m_OuterContainer.layout.y, m_ScrollView.layout.height + m_OuterContainer.resolvedStyle.borderBottomWidth + m_OuterContainer.resolvedStyle.borderTopWidth);
				if (m_DesiredRect != Rect.zero)
				{
					m_OuterContainer.style.width = m_DesiredRect.width;
				}
			}
		}
	}
	public class GroupBox : BindableElement, IGroupBox
	{
		public new class UxmlFactory : UxmlFactory<GroupBox, UxmlTraits>
		{
		}

		public new class UxmlTraits : BindableElement.UxmlTraits
		{
			private UxmlStringAttributeDescription m_Text = new UxmlStringAttributeDescription
			{
				name = "text"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				((GroupBox)ve).text = m_Text.GetValueFromBag(bag, cc);
			}
		}

		public static readonly string ussClassName = "unity-group-box";

		public static readonly string labelUssClassName = ussClassName + "__label";

		private Label m_TitleLabel;

		internal Label titleLabel => m_TitleLabel;

		public string text
		{
			get
			{
				return m_TitleLabel?.text;
			}
			set
			{
				if (!string.IsNullOrEmpty(value))
				{
					if (m_TitleLabel == null)
					{
						m_TitleLabel = new Label(value);
						m_TitleLabel.AddToClassList(labelUssClassName);
						Insert(0, m_TitleLabel);
					}
					m_TitleLabel.text = value;
				}
				else if (m_TitleLabel != null)
				{
					m_TitleLabel.RemoveFromHierarchy();
					m_TitleLabel = null;
				}
			}
		}

		public GroupBox()
			: this(null)
		{
		}

		public GroupBox(string text)
		{
			AddToClassList(ussClassName);
			this.text = text;
		}

		void IGroupBox.OnOptionAdded(IGroupBoxOption option)
		{
		}

		void IGroupBox.OnOptionRemoved(IGroupBoxOption option)
		{
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class Hash128Field : TextInputBaseField<Hash128>
	{
		public new class UxmlFactory : UxmlFactory<Hash128Field, UxmlTraits>
		{
		}

		public new class UxmlTraits : TextValueFieldTraits<Hash128, UxmlHash128AttributeDescription>
		{
		}

		private class Hash128Input : TextInputBase
		{
			private Hash128Field hash128Field => (Hash128Field)base.parent;

			protected string allowedCharacters => "0123456789abcdefABCDEF";

			public string formatString => UINumericFieldsUtils.k_IntFieldFormatString;

			internal Hash128Input()
			{
				base.textEdition.AcceptCharacter = AcceptCharacter;
			}

			internal override bool AcceptCharacter(char c)
			{
				return base.AcceptCharacter(c) && c != 0 && allowedCharacters.IndexOf(c) != -1;
			}

			protected string ValueToString(Hash128 value)
			{
				return value.ToString();
			}

			protected override Hash128 StringToValue(string str)
			{
				return Parse(str);
			}

			internal static Hash128 Parse(string str)
			{
				if (str.Length == 1 && ulong.TryParse(str, out var result))
				{
					return new Hash128(result, 0uL);
				}
				return Hash128.Parse(str);
			}
		}

		internal bool m_UpdateTextFromValue;

		public new static readonly string ussClassName = "unity-hash128-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		private Hash128Input integerInput => (Hash128Input)base.textInputBase;

		public override Hash128 value
		{
			get
			{
				return base.value;
			}
			set
			{
				base.value = value;
				if (m_UpdateTextFromValue)
				{
					base.text = base.rawValue.ToString();
				}
			}
		}

		public Hash128Field()
			: this(null)
		{
		}

		public Hash128Field(int maxLength)
			: this(null, maxLength)
		{
		}

		public Hash128Field(string label, int maxLength = -1)
			: base(label, maxLength, '\0', (TextInputBase)new Hash128Input())
		{
			m_UpdateTextFromValue = true;
			SetValueWithoutNotify(default(Hash128));
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
		}

		internal override void UpdateValueFromText()
		{
			m_UpdateTextFromValue = false;
			try
			{
				value = StringToValue(base.text);
			}
			finally
			{
				m_UpdateTextFromValue = true;
			}
		}

		internal override void UpdateTextFromValue()
		{
			base.text = ValueToString(base.rawValue);
		}

		public override void SetValueWithoutNotify(Hash128 newValue)
		{
			base.SetValueWithoutNotify(newValue);
			if (m_UpdateTextFromValue)
			{
				base.text = base.rawValue.ToString();
			}
		}

		protected override string ValueToString(Hash128 value)
		{
			return value.ToString();
		}

		protected override Hash128 StringToValue(string str)
		{
			return Hash128Input.Parse(str);
		}

		[EventInterest(new Type[] { typeof(BlurEvent) })]
		protected override void ExecuteDefaultAction(EventBase evt)
		{
			base.ExecuteDefaultAction(evt);
			if (evt != null && !base.textEdition.isReadOnly && evt.eventTypeId == EventBase<BlurEvent>.TypeId())
			{
				if (string.IsNullOrEmpty(base.text))
				{
					value = default(Hash128);
					return;
				}
				base.textInputBase.UpdateValueFromText();
				base.textInputBase.UpdateTextFromValue();
			}
		}
	}
	public enum HelpBoxMessageType
	{
		None,
		Info,
		Warning,
		Error
	}
	public class HelpBox : VisualElement
	{
		public new class UxmlFactory : UxmlFactory<HelpBox, UxmlTraits>
		{
		}

		public new class UxmlTraits : VisualElement.UxmlTraits
		{
			private UxmlStringAttributeDescription m_Text = new UxmlStringAttributeDescription
			{
				name = "text"
			};

			private UxmlEnumAttributeDescription<HelpBoxMessageType> m_MessageType = new UxmlEnumAttributeDescription<HelpBoxMessageType>
			{
				name = "message-type",
				defaultValue = HelpBoxMessageType.None
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				HelpBox helpBox = ve as HelpBox;
				helpBox.text = m_Text.GetValueFromBag(bag, cc);
				helpBox.messageType = m_MessageType.GetValueFromBag(bag, cc);
			}
		}

		public static readonly string ussClassName = "unity-help-box";

		public static readonly string labelUssClassName = ussClassName + "__label";

		public static readonly string iconUssClassName = ussClassName + "__icon";

		public static readonly string iconInfoUssClassName = iconUssClassName + "--info";

		public static readonly string iconwarningUssClassName = iconUssClassName + "--warning";

		public static readonly string iconErrorUssClassName = iconUssClassName + "--error";

		private HelpBoxMessageType m_HelpBoxMessageType;

		private VisualElement m_Icon;

		private string m_IconClass;

		private Label m_Label;

		public string text
		{
			get
			{
				return m_Label.text;
			}
			set
			{
				m_Label.text = value;
			}
		}

		public HelpBoxMessageType messageType
		{
			get
			{
				return m_HelpBoxMessageType;
			}
			set
			{
				if (value != m_HelpBoxMessageType)
				{
					m_HelpBoxMessageType = value;
					UpdateIcon(value);
				}
			}
		}

		public HelpBox()
			: this(string.Empty, HelpBoxMessageType.None)
		{
		}

		public HelpBox(string text, HelpBoxMessageType messageType)
		{
			AddToClassList(ussClassName);
			m_HelpBoxMessageType = messageType;
			m_Label = new Label(text);
			m_Label.AddToClassList(labelUssClassName);
			Add(m_Label);
			m_Icon = new VisualElement();
			m_Icon.AddToClassList(iconUssClassName);
			UpdateIcon(messageType);
		}

		private string GetIconClass(HelpBoxMessageType messageType)
		{
			return messageType switch
			{
				HelpBoxMessageType.Info => iconInfoUssClassName, 
				HelpBoxMessageType.Warning => iconwarningUssClassName, 
				HelpBoxMessageType.Error => iconErrorUssClassName, 
				_ => null, 
			};
		}

		private void UpdateIcon(HelpBoxMessageType messageType)
		{
			if (!string.IsNullOrEmpty(m_IconClass))
			{
				m_Icon.RemoveFromClassList(m_IconClass);
			}
			m_IconClass = GetIconClass(messageType);
			if (m_IconClass == null)
			{
				m_Icon.RemoveFromHierarchy();
				return;
			}
			m_Icon.AddToClassList(m_IconClass);
			if (m_Icon.parent == null)
			{
				Insert(0, m_Icon);
			}
		}
	}
	public class Image : VisualElement
	{
		public new class UxmlFactory : UxmlFactory<Image, UxmlTraits>
		{
		}

		public new class UxmlTraits : VisualElement.UxmlTraits
		{
			public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
			{
				get
				{
					yield break;
				}
			}
		}

		private ScaleMode m_ScaleMode;

		private Texture m_Image;

		private Sprite m_Sprite;

		private VectorImage m_VectorImage;

		private Rect m_UV;

		private Color m_TintColor;

		internal bool m_ImageIsInline;

		private bool m_ScaleModeIsInline;

		private bool m_TintColorIsInline;

		public static readonly string ussClassName = "unity-image";

		private static CustomStyleProperty<Texture2D> s_ImageProperty = new CustomStyleProperty<Texture2D>("--unity-image");

		private static CustomStyleProperty<Sprite> s_SpriteProperty = new CustomStyleProperty<Sprite>("--unity-image");

		private static CustomStyleProperty<VectorImage> s_VectorImageProperty = new CustomStyleProperty<VectorImage>("--unity-image");

		private static CustomStyleProperty<string> s_ScaleModeProperty = new CustomStyleProperty<string>("--unity-image-size");

		private static CustomStyleProperty<Color> s_TintColorProperty = new CustomStyleProperty<Color>("--unity-image-tint-color");

		public Texture image
		{
			get
			{
				return m_Image;
			}
			set
			{
				if (!(m_Image == value) || !m_ImageIsInline)
				{
					m_ImageIsInline = value != null;
					SetProperty(value, ref m_Image, ref m_Sprite, ref m_VectorImage);
				}
			}
		}

		public Sprite sprite
		{
			get
			{
				return m_Sprite;
			}
			set
			{
				if (!(m_Sprite == value) || !m_ImageIsInline)
				{
					m_ImageIsInline = value != null;
					SetProperty(value, ref m_Sprite, ref m_Image, ref m_VectorImage);
				}
			}
		}

		public VectorImage vectorImage
		{
			get
			{
				return m_VectorImage;
			}
			set
			{
				if (!(m_VectorImage == value) || !m_ImageIsInline)
				{
					m_ImageIsInline = value != null;
					SetProperty(value, ref m_VectorImage, ref m_Image, ref m_Sprite);
				}
			}
		}

		public Rect sourceRect
		{
			get
			{
				return GetSourceRect();
			}
			set
			{
				if (!(GetSourceRect() == value))
				{
					if (sprite != null)
					{
						Debug.LogError("Cannot set sourceRect on a sprite image");
					}
					else
					{
						CalculateUV(value);
					}
				}
			}
		}

		public Rect uv
		{
			get
			{
				return m_UV;
			}
			set
			{
				if (!(m_UV == value))
				{
					m_UV = value;
				}
			}
		}

		public ScaleMode scaleMode
		{
			get
			{
				return m_ScaleMode;
			}
			set
			{
				if (m_ScaleMode != value || !m_ScaleModeIsInline)
				{
					m_ScaleModeIsInline = true;
					SetScaleMode(value);
				}
			}
		}

		public Color tintColor
		{
			get
			{
				return m_TintColor;
			}
			set
			{
				if (!(m_TintColor == value) || !m_TintColorIsInline)
				{
					m_TintColorIsInline = true;
					SetTintColor(value);
				}
			}
		}

		public Image()
		{
			AddToClassList(ussClassName);
			m_ScaleMode = ScaleMode.ScaleToFit;
			m_TintColor = Color.white;
			m_UV = new Rect(0f, 0f, 1f, 1f);
			base.requireMeasureFunction = true;
			RegisterCallback<CustomStyleResolvedEvent>(OnCustomStyleResolved);
			base.generateVisualContent = (Action<MeshGenerationContext>)Delegate.Combine(base.generateVisualContent, new Action<MeshGenerationContext>(OnGenerateVisualContent));
		}

		private Vector2 GetTextureDisplaySize(Texture texture)
		{
			Vector2 result = Vector2.zero;
			if (texture != null)
			{
				result = new Vector2(texture.width, texture.height);
			}
			return result;
		}

		private Vector2 GetTextureDisplaySize(Sprite sprite)
		{
			Vector2 result = Vector2.zero;
			if (sprite != null)
			{
				float num = UIElementsUtility.PixelsPerUnitScaleForElement(this, sprite);
				result = (Vector2)(sprite.bounds.size * sprite.pixelsPerUnit) * num;
			}
			return result;
		}

		protected internal override Vector2 DoMeasure(float desiredWidth, MeasureMode widthMode, float desiredHeight, MeasureMode heightMode)
		{
			float x = float.NaN;
			float y = float.NaN;
			if (image == null && sprite == null && vectorImage == null)
			{
				return new Vector2(x, y);
			}
			Vector2 zero = Vector2.zero;
			zero = ((image != null) ? GetTextureDisplaySize(image) : ((!(sprite != null)) ? vectorImage.size : GetTextureDisplaySize(sprite)));
			Rect rect = sourceRect;
			bool flag = rect != Rect.zero;
			x = (flag ? Mathf.Abs(rect.width) : zero.x);
			y = (flag ? Mathf.Abs(rect.height) : zero.y);
			if (widthMode == MeasureMode.AtMost)
			{
				x = Mathf.Min(x, desiredWidth);
			}
			if (heightMode == MeasureMode.AtMost)
			{
				y = Mathf.Min(y, desiredHeight);
			}
			return new Vector2(x, y);
		}

		private void OnGenerateVisualContent(MeshGenerationContext mgc)
		{
			if (!(image == null) || !(sprite == null) || !(vectorImage == null))
			{
				Rect containerRect = GUIUtility.AlignRectToDevice(base.contentRect);
				MeshGenerationContextUtils.RectangleParams rectParams = default(MeshGenerationContextUtils.RectangleParams);
				if (image != null)
				{
					rectParams = MeshGenerationContextUtils.RectangleParams.MakeTextured(containerRect, uv, image, scaleMode, base.panel.contextType);
				}
				else if (sprite != null)
				{
					Vector4 slices = Vector4.zero;
					rectParams = MeshGenerationContextUtils.RectangleParams.MakeSprite(containerRect, uv, sprite, scaleMode, base.panel.contextType, hasRadius: false, ref slices);
				}
				else if (vectorImage != null)
				{
					rectParams = MeshGenerationContextUtils.RectangleParams.MakeVectorTextured(containerRect, uv, vectorImage, scaleMode, base.panel.contextType);
				}
				rectParams.color = tintColor;
				mgc.Rectangle(rectParams);
			}
		}

		private void OnCustomStyleResolved(CustomStyleResolvedEvent e)
		{
			ReadCustomProperties(e.customStyle);
		}

		private void ReadCustomProperties(ICustomStyle customStyleProvider)
		{
			if (!m_ImageIsInline)
			{
				Sprite value2;
				VectorImage value3;
				if (customStyleProvider.TryGetValue(s_ImageProperty, out var value))
				{
					SetProperty(value, ref m_Image, ref m_Sprite, ref m_VectorImage);
				}
				else if (customStyleProvider.TryGetValue(s_SpriteProperty, out value2))
				{
					SetProperty(value2, ref m_Sprite, ref m_Image, ref m_VectorImage);
				}
				else if (customStyleProvider.TryGetValue(s_VectorImageProperty, out value3))
				{
					SetProperty(value3, ref m_VectorImage, ref m_Image, ref m_Sprite);
				}
				else
				{
					ClearProperty();
				}
			}
			if (!m_ScaleModeIsInline && customStyleProvider.TryGetValue(s_ScaleModeProperty, out var value4))
			{
				StylePropertyUtil.TryGetEnumIntValue(StyleEnumType.ScaleMode, value4, out var intValue);
				SetScaleMode((ScaleMode)intValue);
			}
			if (!m_TintColorIsInline && customStyleProvider.TryGetValue(s_TintColorProperty, out var value5))
			{
				SetTintColor(value5);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void SetProperty<T0, T1, T2>(T0 src, ref T0 dst, ref T1 alt0, ref T2 alt1) where T0 : Object where T1 : Object where T2 : Object
		{
			if (!(src == dst))
			{
				dst = src;
				if (dst != null)
				{
					alt0 = null;
					alt1 = null;
				}
				if (dst == null)
				{
					uv = new Rect(0f, 0f, 1f, 1f);
					ReadCustomProperties(base.customStyle);
				}
				IncrementVersion(VersionChangeType.Layout | VersionChangeType.Repaint);
			}
		}

		private void ClearProperty()
		{
			if (!m_ImageIsInline)
			{
				image = null;
				sprite = null;
				vectorImage = null;
			}
		}

		private void SetScaleMode(ScaleMode mode)
		{
			if (m_ScaleMode != mode)
			{
				m_ScaleMode = mode;
				IncrementVersion(VersionChangeType.Repaint);
			}
		}

		private void SetTintColor(Color color)
		{
			if (m_TintColor != color)
			{
				m_TintColor = color;
				IncrementVersion(VersionChangeType.Repaint);
			}
		}

		private void CalculateUV(Rect srcRect)
		{
			m_UV = new Rect(0f, 0f, 1f, 1f);
			Vector2 vector = Vector2.zero;
			Texture texture = image;
			if (texture != null)
			{
				vector = GetTextureDisplaySize(texture);
			}
			VectorImage vectorImage = this.vectorImage;
			if (vectorImage != null)
			{
				vector = vectorImage.size;
			}
			if (vector != Vector2.zero)
			{
				m_UV.x = srcRect.x / vector.x;
				m_UV.width = srcRect.width / vector.x;
				m_UV.height = srcRect.height / vector.y;
				m_UV.y = 1f - m_UV.height - srcRect.y / vector.y;
			}
		}

		private Rect GetSourceRect()
		{
			Rect zero = Rect.zero;
			Vector2 vector = Vector2.zero;
			Texture texture = image;
			if (texture != null)
			{
				vector = GetTextureDisplaySize(texture);
			}
			VectorImage vectorImage = this.vectorImage;
			if (vectorImage != null)
			{
				vector = vectorImage.size;
			}
			if (vector != Vector2.zero)
			{
				zero.x = uv.x * vector.x;
				zero.width = uv.width * vector.x;
				zero.y = (1f - uv.y - uv.height) * vector.y;
				zero.height = uv.height * vector.y;
			}
			return zero;
		}
	}
	public interface IMixedValueSupport
	{
		bool showMixedValue { get; set; }
	}
	public interface INotifyValueChanged<T>
	{
		T value { get; set; }

		void SetValueWithoutNotify(T newValue);
	}
	public static class INotifyValueChangedExtensions
	{
		public static bool RegisterValueChangedCallback<T>(this INotifyValueChanged<T> control, EventCallback<ChangeEvent<T>> callback)
		{
			if (control is CallbackEventHandler callbackEventHandler)
			{
				callbackEventHandler.RegisterCallback(callback);
				return true;
			}
			return false;
		}

		public static bool UnregisterValueChangedCallback<T>(this INotifyValueChanged<T> control, EventCallback<ChangeEvent<T>> callback)
		{
			if (control is CallbackEventHandler callbackEventHandler)
			{
				callbackEventHandler.UnregisterCallback(callback);
				return true;
			}
			return false;
		}
	}
	internal interface IPrefixLabel
	{
		string label { get; }

		Label labelElement { get; }
	}
	internal interface IEditableElement
	{
		internal Action editingStarted { get; set; }

		internal Action editingEnded { get; set; }
	}
	public abstract class BaseField<TValueType> : BindableElement, INotifyValueChanged<TValueType>, IMixedValueSupport, IPrefixLabel, IEditableElement
	{
		public new class UxmlTraits : BindableElement.UxmlTraits
		{
			private UxmlStringAttributeDescription m_Label = new UxmlStringAttributeDescription
			{
				name = "label"
			};

			public UxmlTraits()
			{
				base.focusIndex.defaultValue = 0;
				base.focusable.defaultValue = true;
			}

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				((BaseField<TValueType>)ve).label = m_Label.GetValueFromBag(bag, cc);
			}

			internal static List<string> ParseChoiceList(string choicesFromBag)
			{
				if (string.IsNullOrEmpty(choicesFromBag.Trim()))
				{
					return null;
				}
				string[] array = choicesFromBag.Split(',');
				if (array.Length != 0)
				{
					List<string> list = new List<string>();
					string[] array2 = array;
					foreach (string text in array2)
					{
						list.Add(text.Trim());
					}
					return list;
				}
				return null;
			}
		}

		public static readonly string ussClassName = "unity-base-field";

		public static readonly string labelUssClassName = ussClassName + "__label";

		public static readonly string inputUssClassName = ussClassName + "__input";

		public static readonly string noLabelVariantUssClassName = ussClassName + "--no-label";

		public static readonly string labelDraggerVariantUssClassName = labelUssClassName + "--with-dragger";

		public static readonly string mixedValueLabelUssClassName = labelUssClassName + "--mixed-value";

		public static readonly string alignedFieldUssClassName = ussClassName + "__aligned";

		private static readonly string inspectorFieldUssClassName = ussClassName + "__inspector-field";

		protected internal static readonly string mixedValueString = "";

		protected internal static readonly PropertyName serializedPropertyCopyName = "SerializedPropertyCopyName";

		private static CustomStyleProperty<float> s_LabelWidthRatioProperty = new CustomStyleProperty<float>("--unity-property-field-label-width-ratio");

		private static CustomStyleProperty<float> s_LabelExtraPaddingProperty = new CustomStyleProperty<float>("--unity-property-field-label-extra-padding");

		private static CustomStyleProperty<float> s_LabelBaseMinWidthProperty = new CustomStyleProperty<float>("--unity-property-field-label-base-min-width");

		private static CustomStyleProperty<float> s_LabelExtraContextWidthProperty = new CustomStyleProperty<float>("--unity-base-field-extra-context-width");

		private float m_LabelWidthRatio;

		private float m_LabelExtraPadding;

		private float m_LabelBaseMinWidth;

		private float m_LabelExtraContextWidth;

		private VisualElement m_VisualInput;

		[SerializeField]
		private TValueType m_Value;

		private bool m_ShowMixedValue;

		private Label m_MixedValueLabel;

		private bool m_SkipValidation;

		private VisualElement m_CachedContextWidthElement;

		private VisualElement m_CachedInspectorElement;

		internal VisualElement visualInput
		{
			get
			{
				return m_VisualInput;
			}
			set
			{
				if (m_VisualInput != null)
				{
					if (m_VisualInput.parent == this)
					{
						m_VisualInput.RemoveFromHierarchy();
					}
					m_VisualInput = null;
				}
				if (value != null)
				{
					m_VisualInput = value;
				}
				else
				{
					m_VisualInput = new VisualElement
					{
						pickingMode = PickingMode.Ignore
					};
				}
				m_VisualInput.focusable = true;
				m_VisualInput.AddToClassList(inputUssClassName);
				Add(m_VisualInput);
			}
		}

		protected TValueType rawValue
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = value;
			}
		}

		public virtual TValueType value
		{
			get
			{
				return m_Value;
			}
			set
			{
				if (EqualsCurrentValue(value) && !showMixedValue)
				{
					return;
				}
				TValueType previousValue = m_Value;
				SetValueWithoutNotify(value);
				showMixedValue = false;
				if (base.panel != null)
				{
					using (ChangeEvent<TValueType> changeEvent = ChangeEvent<TValueType>.GetPooled(previousValue, m_Value))
					{
						changeEvent.target = this;
						SendEvent(changeEvent);
					}
				}
			}
		}

		public Label labelElement { get; private set; }

		public string label
		{
			get
			{
				return labelElement.text;
			}
			set
			{
				if (labelElement.text != value)
				{
					labelElement.text = value;
					if (string.IsNullOrEmpty(labelElement.text))
					{
						AddToClassList(noLabelVariantUssClassName);
						labelElement.RemoveFromHierarchy();
					}
					else if (!Contains(labelElement))
					{
						base.hierarchy.Insert(0, labelElement);
						RemoveFromClassList(noLabelVariantUssClassName);
					}
				}
			}
		}

		public bool showMixedValue
		{
			get
			{
				return m_ShowMixedValue;
			}
			set
			{
				if (value != m_ShowMixedValue)
				{
					m_ShowMixedValue = value;
					UpdateMixedValueContent();
				}
			}
		}

		protected Label mixedValueLabel
		{
			get
			{
				if (m_MixedValueLabel == null)
				{
					m_MixedValueLabel = new Label(mixedValueString)
					{
						focusable = true,
						tabIndex = -1
					};
					m_MixedValueLabel.AddToClassList(labelUssClassName);
					m_MixedValueLabel.AddToClassList(mixedValueLabelUssClassName);
				}
				return m_MixedValueLabel;
			}
		}

		Action IEditableElement.editingStarted { get; set; }

		Action IEditableElement.editingEnded { get; set; }

		internal event Func<TValueType, TValueType> onValidateValue;

		internal BaseField(string label)
		{
			base.isCompositeRoot = true;
			base.focusable = true;
			base.tabIndex = 0;
			base.excludeFromFocusRing = true;
			base.delegatesFocus = true;
			AddToClassList(ussClassName);
			labelElement = new Label
			{
				focusable = true,
				tabIndex = -1
			};
			labelElement.AddToClassList(labelUssClassName);
			if (label != null)
			{
				this.label = label;
			}
			else
			{
				AddToClassList(noLabelVariantUssClassName);
			}
			RegisterCallback<AttachToPanelEvent>(OnAttachToPanel);
			RegisterCallback<DetachFromPanelEvent>(OnDetachFromPanel);
			m_VisualInput = null;
		}

		protected BaseField(string label, VisualElement visualInput)
			: this(label)
		{
			this.visualInput = visualInput;
		}

		internal virtual bool EqualsCurrentValue(TValueType value)
		{
			return EqualityComparer<TValueType>.Default.Equals(m_Value, value);
		}

		private void OnAttachToPanel(AttachToPanelEvent e)
		{
			RegisterEditingCallbacks();
			if (e.destinationPanel == null || e.destinationPanel.contextType == ContextType.Player)
			{
				return;
			}
			for (VisualElement visualElement = base.parent; visualElement != null; visualElement = visualElement.parent)
			{
				if (visualElement.ClassListContains("unity-inspector-element"))
				{
					m_CachedInspectorElement = visualElement;
				}
				if (visualElement.ClassListContains("unity-inspector-main-container"))
				{
					m_CachedContextWidthElement = visualElement;
					break;
				}
			}
			if (m_CachedInspectorElement != null)
			{
				m_LabelWidthRatio = 0.45f;
				m_LabelExtraPadding = 37f;
				m_LabelBaseMinWidth = 123f;
				m_LabelExtraContextWidth = 1f;
				RegisterCallback<CustomStyleResolvedEvent>(OnCustomStyleResolved);
				AddToClassList(inspectorFieldUssClassName);
				RegisterCallback<GeometryChangedEvent>(OnInspectorFieldGeometryChanged);
			}
		}

		private void OnDetachFromPanel(DetachFromPanelEvent e)
		{
			UnregisterEditingCallbacks();
			this.onValidateValue = null;
		}

		internal virtual void RegisterEditingCallbacks()
		{
			RegisterCallback<FocusInEvent>(StartEditing);
			RegisterCallback<FocusOutEvent>(EndEditing);
		}

		internal virtual void UnregisterEditingCallbacks()
		{
			UnregisterCallback<FocusInEvent>(StartEditing);
			UnregisterCallback<FocusOutEvent>(EndEditing);
		}

		internal void StartEditing(EventBase e)
		{
			((IEditableElement)this).editingStarted?.Invoke();
		}

		internal void EndEditing(EventBase e)
		{
			((IEditableElement)this).editingEnded?.Invoke();
		}

		private void OnCustomStyleResolved(CustomStyleResolvedEvent evt)
		{
			if (evt.customStyle.TryGetValue(s_LabelWidthRatioProperty, out var labelWidthRatio))
			{
				m_LabelWidthRatio = labelWidthRatio;
			}
			if (evt.customStyle.TryGetValue(s_LabelExtraPaddingProperty, out var labelExtraPadding))
			{
				m_LabelExtraPadding = labelExtraPadding;
			}
			if (evt.customStyle.TryGetValue(s_LabelBaseMinWidthProperty, out var labelBaseMinWidth))
			{
				m_LabelBaseMinWidth = labelBaseMinWidth;
			}
			if (evt.customStyle.TryGetValue(s_LabelExtraContextWidthProperty, out var labelExtraContextWidth))
			{
				m_LabelExtraContextWidth = labelExtraContextWidth;
			}
			AlignLabel();
		}

		private void OnInspectorFieldGeometryChanged(GeometryChangedEvent e)
		{
			AlignLabel();
		}

		private void AlignLabel()
		{
			if (ClassListContains(alignedFieldUssClassName))
			{
				float labelExtraPadding = m_LabelExtraPadding;
				float num = base.worldBound.x - m_CachedInspectorElement.worldBound.x - m_CachedInspectorElement.resolvedStyle.paddingLeft;
				labelExtraPadding += num;
				labelExtraPadding += base.resolvedStyle.paddingLeft;
				float a = m_LabelBaseMinWidth - num - base.resolvedStyle.paddingLeft;
				VisualElement visualElement = m_CachedContextWidthElement ?? m_CachedInspectorElement;
				labelElement.style.minWidth = Mathf.Max(a, 0f);
				float num2 = (visualElement.resolvedStyle.width + m_LabelExtraContextWidth) * m_LabelWidthRatio - labelExtraPadding;
				if (Mathf.Abs(labelElement.resolvedStyle.width - num2) > 1E-30f)
				{
					labelElement.style.width = Mathf.Max(0f, num2);
				}
			}
		}

		internal TValueType ValidatedValue(TValueType value)
		{
			if (this.onValidateValue != null)
			{
				return this.onValidateValue(value);
			}
			return value;
		}

		protected virtual void UpdateMixedValueContent()
		{
			throw new NotImplementedException();
		}

		public virtual void SetValueWithoutNotify(TValueType newValue)
		{
			if (m_SkipValidation)
			{
				m_Value = newValue;
			}
			else
			{
				m_Value = ValidatedValue(newValue);
			}
			if (!string.IsNullOrEmpty(base.viewDataKey))
			{
				SaveViewData();
			}
			MarkDirtyRepaint();
			if (showMixedValue)
			{
				UpdateMixedValueContent();
			}
		}

		internal void SetValueWithoutValidation(TValueType newValue)
		{
			m_SkipValidation = true;
			value = newValue;
			m_SkipValidation = false;
		}

		internal override void OnViewDataReady()
		{
			base.OnViewDataReady();
			if (m_VisualInput == null)
			{
				return;
			}
			string fullHierarchicalViewDataKey = GetFullHierarchicalViewDataKey();
			TValueType val = m_Value;
			OverwriteFromViewData(this, fullHierarchicalViewDataKey);
			if (!EqualityComparer<TValueType>.Default.Equals(val, m_Value))
			{
				using (ChangeEvent<TValueType> changeEvent = ChangeEvent<TValueType>.GetPooled(val, m_Value))
				{
					changeEvent.target = this;
					SetValueWithoutNotify(m_Value);
					SendEvent(changeEvent);
				}
			}
		}

		internal override Rect GetTooltipRect()
		{
			return (!string.IsNullOrEmpty(label)) ? labelElement.worldBound : base.worldBound;
		}
	}
	public class BaseFieldTraits<TValueType, TValueUxmlAttributeType> : BaseField<TValueType>.UxmlTraits where TValueUxmlAttributeType : TypedUxmlAttributeDescription<TValueType>, new()
	{
		private TValueUxmlAttributeType m_Value = new TValueUxmlAttributeType
		{
			name = "value"
		};

		public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
		{
			base.Init(ve, bag, cc);
			((INotifyValueChanged<TValueType>)ve).SetValueWithoutNotify(m_Value.GetValueFromBag(bag, cc));
		}
	}
	internal class KeyboardTextEditorEventHandler : TextEditorEventHandler
	{
		private readonly Event m_ImguiEvent = new Event();

		internal bool m_Changed;

		private const int k_LineFeed = 10;

		private const int k_Space = 32;

		public KeyboardTextEditorEventHandler(TextElement textElement, TextEditingUtilities editingUtilities)
			: base(textElement, editingUtilities)
		{
			editingUtilities.multiline = textElement.edition.multiline;
		}

		public override void ExecuteDefaultActionAtTarget(EventBase evt)
		{
			base.ExecuteDefaultActionAtTarget(evt);
			if (!(evt is FocusEvent _))
			{
				if (!(evt is BlurEvent _2))
				{
					if (!(evt is KeyDownEvent evt2))
					{
						if (!(evt is ValidateCommandEvent evt3))
						{
							if (!(evt is ExecuteCommandEvent evt4))
							{
								if (!(evt is NavigationMoveEvent evt5))
								{
									if (!(evt is NavigationSubmitEvent evt6))
									{
										if (evt is NavigationCancelEvent evt7)
										{
											OnNavigationEvent(evt7);
										}
									}
									else
									{
										OnNavigationEvent(evt6);
									}
								}
								else
								{
									OnNavigationEvent(evt5);
								}
							}
							else
							{
								OnExecuteCommandEvent(evt4);
							}
						}
						else
						{
							OnValidateCommandEvent(evt3);
						}
					}
					else
					{
						OnKeyDown(evt2);
					}
				}
				else
				{
					OnBlur(_2);
				}
			}
			else
			{
				OnFocus(_);
			}
		}

		private void OnFocus(FocusEvent _)
		{
			GUIUtility.imeCompositionMode = IMECompositionMode.On;
			textElement.edition.SaveValueAndText();
		}

		private void OnBlur(BlurEvent _)
		{
			GUIUtility.imeCompositionMode = IMECompositionMode.Auto;
		}

		private void OnKeyDown(KeyDownEvent evt)
		{
			if (!textElement.hasFocus)
			{
				return;
			}
			m_Changed = false;
			evt.GetEquivalentImguiEvent(m_ImguiEvent);
			if (editingUtilities.HandleKeyEvent(m_ImguiEvent))
			{
				if (textElement.text != editingUtilities.text)
				{
					m_Changed = true;
				}
				evt.StopPropagation();
				goto IL_035d;
			}
			char c = evt.character;
			if ((evt.actionKey && (!evt.altKey || c == '\0')) || (c == '\t' && evt.keyCode == KeyCode.None && evt.modifiers == EventModifiers.None))
			{
				return;
			}
			if (evt.keyCode == KeyCode.Tab || (evt.keyCode == KeyCode.Tab && evt.character == '\t' && evt.modifiers == EventModifiers.Shift))
			{
				if (!textElement.edition.multiline || evt.shiftKey)
				{
					if (evt.ShouldSendNavigationMoveEvent())
					{
						textElement.focusController.FocusNextInDirection(evt.shiftKey ? VisualElementFocusChangeDirection.left : VisualElementFocusChangeDirection.right);
						evt.StopPropagation();
					}
					return;
				}
				if (!evt.ShouldSendNavigationMoveEvent())
				{
					return;
				}
			}
			if (!textElement.edition.multiline && (evt.keyCode == KeyCode.KeypadEnter || evt.keyCode == KeyCode.Return))
			{
				textElement.edition.UpdateValueFromText?.Invoke();
			}
			evt.StopPropagation();
			bool num;
			if (!textElement.edition.multiline)
			{
				if (c == '\n' || c == '\r' || c == '\n')
				{
					num = !evt.altKey;
					goto IL_0205;
				}
			}
			else if (c == '\n')
			{
				num = evt.shiftKey;
				goto IL_0205;
			}
			goto IL_022d;
			IL_022d:
			if (evt.keyCode == KeyCode.Escape)
			{
				textElement.edition.RestoreValueAndText();
				textElement.edition.UpdateValueFromText?.Invoke();
				textElement.edition.MoveFocusToCompositeRoot?.Invoke();
			}
			if (evt.keyCode == KeyCode.Tab)
			{
				c = '\t';
			}
			if (!textElement.edition.AcceptCharacter(c))
			{
				return;
			}
			if (c >= ' ' || evt.keyCode == KeyCode.Tab || (textElement.edition.multiline && !evt.altKey && (c == '\n' || c == '\r' || c == '\n')))
			{
				editingUtilities.Insert(c);
				m_Changed = true;
			}
			else
			{
				bool isCompositionActive = editingUtilities.isCompositionActive;
				if (editingUtilities.UpdateImeState() || isCompositionActive != editingUtilities.isCompositionActive)
				{
					m_Changed = true;
				}
			}
			goto IL_035d;
			IL_0205:
			if (num)
			{
				textElement.edition.MoveFocusToCompositeRoot?.Invoke();
				return;
			}
			goto IL_022d;
			IL_035d:
			if (m_Changed)
			{
				UpdateLabel();
			}
			textElement.edition.UpdateScrollOffset?.Invoke(evt.keyCode == KeyCode.Backspace);
		}

		private void UpdateLabel()
		{
			string text = editingUtilities.text;
			bool flag = editingUtilities.UpdateImeState();
			if (flag && editingUtilities.ShouldUpdateImeWindowPosition())
			{
				editingUtilities.SetImeWindowPosition(new Vector2(textElement.worldBound.x, textElement.worldBound.y));
			}
			string value = editingUtilities.GeneratePreviewString(textElement.enableRichText);
			textElement.edition.UpdateText(value);
			if (!textElement.edition.isDelayed)
			{
				textElement.edition.UpdateValueFromText?.Invoke();
			}
			if (flag)
			{
				editingUtilities.text = text;
				editingUtilities.EnableCursorPreviewState();
			}
			textElement.uitkTextHandle.Update();
		}

		private void OnValidateCommandEvent(ValidateCommandEvent evt)
		{
			if (!textElement.hasFocus)
			{
				return;
			}
			switch (evt.commandName)
			{
			case "SelectAll":
				return;
			case "Cut":
				if (!textElement.selection.HasSelection())
				{
					return;
				}
				break;
			case "Paste":
				if (!editingUtilities.CanPaste())
				{
					return;
				}
				break;
			}
			evt.StopPropagation();
		}

		private void OnExecuteCommandEvent(ExecuteCommandEvent evt)
		{
			if (!textElement.hasFocus)
			{
				return;
			}
			m_Changed = false;
			bool flag = false;
			string text = editingUtilities.text;
			switch (evt.commandName)
			{
			case "OnLostFocus":
				evt.StopPropagation();
				return;
			case "Cut":
				editingUtilities.Cut();
				flag = true;
				evt.StopPropagation();
				break;
			case "Paste":
				editingUtilities.Paste();
				flag = true;
				evt.StopPropagation();
				break;
			case "Delete":
				editingUtilities.Cut();
				flag = true;
				evt.StopPropagation();
				break;
			}
			if (flag)
			{
				if (text != editingUtilities.text)
				{
					m_Changed = true;
				}
				evt.StopPropagation();
			}
			if (m_Changed)
			{
				UpdateLabel();
			}
			textElement.edition.UpdateScrollOffset?.Invoke(obj: false);
		}

		private void OnNavigationEvent<TEvent>(NavigationEventBase<TEvent> evt) where TEvent : NavigationEventBase<TEvent>, new()
		{
			if (evt.deviceType == NavigationDeviceType.Keyboard || evt.deviceType == NavigationDeviceType.Unknown)
			{
				evt.StopPropagation();
				evt.PreventDefault();
			}
		}
	}
	internal class TextEditorEventHandler
	{
		protected TextElement textElement;

		protected TextEditingUtilities editingUtilities;

		protected TextEditorEventHandler(TextElement textElement, TextEditingUtilities editingUtilities)
		{
			this.textElement = textElement;
			this.editingUtilities = editingUtilities;
		}

		public virtual void ExecuteDefaultActionAtTarget(EventBase evt)
		{
		}
	}
	public class TextField : TextInputBaseField<string>
	{
		public new class UxmlFactory : UxmlFactory<TextField, UxmlTraits>
		{
		}

		public new class UxmlTraits : TextInputBaseField<string>.UxmlTraits
		{
			private static readonly UxmlStringAttributeDescription k_Value = new UxmlStringAttributeDescription
			{
				name = "value",
				obsoleteNames = new string[1] { "text" }
			};

			private UxmlBoolAttributeDescription m_Multiline = new UxmlBoolAttributeDescription
			{
				name = "multiline"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				TextField textField = (TextField)ve;
				textField.multiline = m_Multiline.GetValueFromBag(bag, cc);
				base.Init(ve, bag, cc);
				string value = string.Empty;
				if (k_Value.TryGetValueFromBag(bag, cc, ref value))
				{
					textField.SetValueWithoutNotify(value);
				}
			}
		}

		private class TextInput : TextInputBase
		{
			private TextField parentTextField => (TextField)base.parent;

			public bool multiline
			{
				get
				{
					return base.textEdition.multiline;
				}
				set
				{
					if (base.textEdition.multiline != value)
					{
						base.textEdition.multiline = value;
						if (value)
						{
							SetMultiline();
							return;
						}
						base.text = base.text.Replace("\n", "");
						SetSingleLine();
					}
				}
			}

			public override bool isPasswordField
			{
				set
				{
					base.isPasswordField = value;
					if (value)
					{
						multiline = false;
					}
				}
			}

			protected override string StringToValue(string str)
			{
				return str;
			}
		}

		public new static readonly string ussClassName = "unity-text-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		private TextInput textInput => (TextInput)base.textInputBase;

		public bool multiline
		{
			get
			{
				return textInput.multiline;
			}
			set
			{
				textInput.multiline = value;
			}
		}

		public override string value
		{
			get
			{
				return base.value;
			}
			set
			{
				base.value = value;
				base.textEdition.UpdateText(base.rawValue);
			}
		}

		public TextField()
			: this(null)
		{
		}

		public TextField(int maxLength, bool multiline, bool isPasswordField, char maskChar)
			: this(null, maxLength, multiline, isPasswordField, maskChar)
		{
		}

		public TextField(string label)
			: this(label, -1, multiline: false, isPasswordField: false, '*')
		{
		}

		public TextField(string label, int maxLength, bool multiline, bool isPasswordField, char maskChar)
			: base(label, maxLength, maskChar, (TextInputBase)new TextInput())
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			base.pickingMode = PickingMode.Ignore;
			SetValueWithoutNotify("");
			this.multiline = multiline;
			base.isPasswordField = isPasswordField;
		}

		public override void SetValueWithoutNotify(string newValue)
		{
			base.SetValueWithoutNotify(newValue);
			((INotifyValueChanged<string>)textInput.textElement).SetValueWithoutNotify(base.rawValue);
		}

		internal override void UpdateTextFromValue()
		{
			SetValueWithoutNotify(base.rawValue);
		}

		[EventInterest(new Type[] { typeof(BlurEvent) })]
		protected override void ExecuteDefaultAction(EventBase evt)
		{
			base.ExecuteDefaultAction(evt);
			if (base.isDelayed && evt?.eventTypeId == EventBase<BlurEvent>.TypeId())
			{
				value = base.text;
			}
		}

		internal override void OnViewDataReady()
		{
			base.OnViewDataReady();
			string fullHierarchicalViewDataKey = GetFullHierarchicalViewDataKey();
			OverwriteFromViewData(this, fullHierarchicalViewDataKey);
			base.text = base.rawValue;
		}

		protected override string ValueToString(string value)
		{
			return value;
		}

		protected override string StringToValue(string str)
		{
			return str;
		}
	}
	public abstract class TextInputBaseField<TValueType> : BaseField<TValueType>
	{
		public new class UxmlTraits : BaseFieldTraits<string, UxmlStringAttributeDescription>
		{
			private UxmlIntAttributeDescription m_MaxLength = new UxmlIntAttributeDescription
			{
				name = "max-length",
				obsoleteNames = new string[1] { "maxLength" },
				defaultValue = -1
			};

			private UxmlBoolAttributeDescription m_Password = new UxmlBoolAttributeDescription
			{
				name = "password"
			};

			private UxmlStringAttributeDescription m_MaskCharacter = new UxmlStringAttributeDescription
			{
				name = "mask-character",
				obsoleteNames = new string[1] { "maskCharacter" },
				defaultValue = '*'.ToString()
			};

			private UxmlBoolAttributeDescription m_IsReadOnly = new UxmlBoolAttributeDescription
			{
				name = "readonly"
			};

			private UxmlBoolAttributeDescription m_IsDelayed = new UxmlBoolAttributeDescription
			{
				name = "is-delayed"
			};

			private UxmlBoolAttributeDescription m_HideMobileInput = new UxmlBoolAttributeDescription
			{
				name = "hide-mobile-input"
			};

			private UxmlEnumAttributeDescription<TouchScreenKeyboardType> m_KeyboardType = new UxmlEnumAttributeDescription<TouchScreenKeyboardType>
			{
				name = "keyboard-type"
			};

			private UxmlBoolAttributeDescription m_AutoCorrection = new UxmlBoolAttributeDescription
			{
				name = "auto-correction"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				TextInputBaseField<TValueType> textInputBaseField = (TextInputBaseField<TValueType>)ve;
				textInputBaseField.maxLength = m_MaxLength.GetValueFromBag(bag, cc);
				textInputBaseField.isPasswordField = m_Password.GetValueFromBag(bag, cc);
				textInputBaseField.isReadOnly = m_IsReadOnly.GetValueFromBag(bag, cc);
				textInputBaseField.isDelayed = m_IsDelayed.GetValueFromBag(bag, cc);
				textInputBaseField.hideMobileInput = m_HideMobileInput.GetValueFromBag(bag, cc);
				textInputBaseField.keyboardType = m_KeyboardType.GetValueFromBag(bag, cc);
				textInputBaseField.autoCorrection = m_AutoCorrection.GetValueFromBag(bag, cc);
				string valueFromBag = m_MaskCharacter.GetValueFromBag(bag, cc);
				textInputBaseField.maskChar = (string.IsNullOrEmpty(valueFromBag) ? '*' : valueFromBag[0]);
			}
		}

		protected internal abstract class TextInputBase : VisualElement
		{
			internal ScrollView scrollView;

			internal VisualElement multilineContainer;

			public static readonly string innerComponentsModifierName = "--inner-input-field-component";

			public static readonly string innerTextElementUssClassName = TextElement.ussClassName + innerComponentsModifierName;

			internal static readonly string innerTextElementWithScrollViewUssClassName = TextElement.ussClassName + innerComponentsModifierName + "--scroll-view";

			public static readonly string horizontalVariantInnerTextElementUssClassName = TextElement.ussClassName + innerComponentsModifierName + "--horizontal";

			public static readonly string verticalVariantInnerTextElementUssClassName = TextElement.ussClassName + innerComponentsModifierName + "--vertical";

			public static readonly string verticalHorizontalVariantInnerTextElementUssClassName = TextElement.ussClassName + innerComponentsModifierName + "--vertical-horizontal";

			public static readonly string innerScrollviewUssClassName = ScrollView.ussClassName + innerComponentsModifierName;

			public static readonly string innerViewportUssClassName = ScrollView.viewportUssClassName + innerComponentsModifierName;

			public static readonly string innerContentContainerUssClassName = ScrollView.contentUssClassName + innerComponentsModifierName;

			internal Vector2 scrollOffset = Vector2.zero;

			private bool m_ScrollViewWasClamped;

			private Vector2 lastCursorPos = Vector2.zero;

			private ScrollerVisibility m_VerticalScrollerVisibility = ScrollerVisibility.Hidden;

			internal TextElement textElement { get; private set; }

			public ITextSelection textSelection => textElement.selection;

			public ITextEdition textEdition => textElement.edition;

			internal string originalText => textElement.originalText;

			public bool isReadOnly
			{
				get
				{
					return textEdition.isReadOnly;
				}
				set
				{
					textEdition.isReadOnly = value;
				}
			}

			public int maxLength
			{
				get
				{
					return textEdition.maxLength;
				}
				set
				{
					textEdition.maxLength = value;
				}
			}

			public char maskChar
			{
				get
				{
					return textEdition.maskChar;
				}
				set
				{
					textEdition.maskChar = value;
				}
			}

			public virtual bool isPasswordField
			{
				get
				{
					return textEdition.isPassword;
				}
				set
				{
					textEdition.isPassword = value;
				}
			}

			internal bool isDelayed
			{
				get
				{
					return textEdition.isDelayed;
				}
				set
				{
					textEdition.isDelayed = value;
				}
			}

			internal bool isDragging { get; set; }

			public Color selectionColor
			{
				get
				{
					return textSelection.selectionColor;
				}
				set
				{
					textSelection.selectionColor = value;
				}
			}

			public Color cursorColor
			{
				get
				{
					return textSelection.cursorColor;
				}
				set
				{
					textSelection.cursorColor = value;
				}
			}

			public int cursorIndex => textSelection.cursorIndex;

			public int selectIndex => textSelection.selectIndex;

			public bool doubleClickSelectsWord
			{
				get
				{
					return textSelection.doubleClickSelectsWord;
				}
				set
				{
					textSelection.doubleClickSelectsWord = value;
				}
			}

			public bool tripleClickSelectsLine
			{
				get
				{
					return textSelection.tripleClickSelectsLine;
				}
				set
				{
					textSelection.tripleClickSelectsLine = value;
				}
			}

			public string text
			{
				get
				{
					return textElement.text;
				}
				set
				{
					if (!(textElement.text == value))
					{
						textElement.text = value;
					}
				}
			}

			public void SelectAll()
			{
				textSelection.SelectAll();
			}

			internal void SelectNone()
			{
				textSelection.SelectNone();
			}

			protected virtual TValueType StringToValue(string str)
			{
				throw new NotSupportedException();
			}

			internal void UpdateValueFromText()
			{
				TextInputBaseField<TValueType> textInputBaseField = (TextInputBaseField<TValueType>)base.parent;
				textInputBaseField.UpdateValueFromText();
			}

			internal void UpdateTextFromValue()
			{
				TextInputBaseField<TValueType> textInputBaseField = (TextInputBaseField<TValueType>)base.parent;
				textInputBaseField.UpdateTextFromValue();
			}

			internal void MoveFocusToCompositeRoot()
			{
				TextInputBaseField<TValueType> textInputBaseField = (TextInputBaseField<TValueType>)base.parent;
				textInputBaseField.Focus();
			}

			public void ResetValueAndText()
			{
				textEdition.ResetValueAndText();
			}

			internal TextInputBase()
			{
				base.delegatesFocus = true;
				textElement = new TextElement();
				textElement.parseEscapeSequences = false;
				textElement.selection.isSelectable = true;
				textEdition.isReadOnly = false;
				textEdition.keyboardType = TouchScreenKeyboardType.Default;
				textEdition.autoCorrection = false;
				textSelection.isSelectable = true;
				textElement.enableRichText = false;
				textSelection.selectAllOnFocus = true;
				textSelection.selectAllOnMouseUp = true;
				textElement.tabIndex = 0;
				ITextEdition obj = textEdition;
				obj.AcceptCharacter = (Func<char, bool>)Delegate.Combine(obj.AcceptCharacter, new Func<char, bool>(AcceptCharacter));
				ITextEdition obj2 = textEdition;
				obj2.UpdateScrollOffset = (Action<bool>)Delegate.Combine(obj2.UpdateScrollOffset, new Action<bool>(UpdateScrollOffset));
				ITextEdition obj3 = textEdition;
				obj3.UpdateValueFromText = (Action)Delegate.Combine(obj3.UpdateValueFromText, new Action(UpdateValueFromText));
				ITextEdition obj4 = textEdition;
				obj4.UpdateTextFromValue = (Action)Delegate.Combine(obj4.UpdateTextFromValue, new Action(UpdateTextFromValue));
				ITextEdition obj5 = textEdition;
				obj5.MoveFocusToCompositeRoot = (Action)Delegate.Combine(obj5.MoveFocusToCompositeRoot, new Action(MoveFocusToCompositeRoot));
				AddToClassList(TextInputBaseField<TValueType>.inputUssClassName);
				base.name = TextInputBaseField<string>.textInputUssName;
				SetSingleLine();
				RegisterCallback<CustomStyleResolvedEvent>(OnInputCustomStyleResolved);
				base.tabIndex = -1;
			}

			private void MakeSureScrollViewDoesNotLeakEvents(ChangeEvent<float> evt)
			{
				evt.StopPropagation();
			}

			internal void SetSingleLine()
			{
				base.hierarchy.Clear();
				RemoveMultilineComponents();
				Add(textElement);
				AddToClassList(TextInputBaseField<TValueType>.singleLineInputUssClassName);
				textElement.AddToClassList(innerTextElementUssClassName);
				textElement.RegisterCallback<GeometryChangedEvent>(TextElementOnGeometryChangedEvent);
				if (scrollOffset != Vector2.zero)
				{
					scrollOffset.y = 0f;
					UpdateScrollOffset();
				}
			}

			internal void SetMultiline()
			{
				if (textEdition.multiline)
				{
					RemoveSingleLineComponents();
					RemoveMultilineComponents();
					if (m_VerticalScrollerVisibility != ScrollerVisibility.Hidden && scrollView == null)
					{
						scrollView = new ScrollView();
						scrollView.Add(textElement);
						Add(scrollView);
						SetScrollViewMode();
						scrollView.horizontalScrollerVisibility = ScrollerVisibility.Hidden;
						scrollView.verticalScrollerVisibility = m_VerticalScrollerVisibility;
						scrollView.AddToClassList(innerScrollviewUssClassName);
						scrollView.contentViewport.AddToClassList(innerViewportUssClassName);
						scrollView.contentContainer.AddToClassList(innerContentContainerUssClassName);
						scrollView.contentContainer.RegisterCallback<GeometryChangedEvent>(ScrollViewOnGeometryChangedEvent);
						scrollView.verticalScroller.slider.RegisterValueChangedCallback(MakeSureScrollViewDoesNotLeakEvents);
						scrollView.verticalScroller.slider.focusable = false;
						scrollView.horizontalScroller.slider.RegisterValueChangedCallback(MakeSureScrollViewDoesNotLeakEvents);
						scrollView.horizontalScroller.slider.focusable = false;
						AddToClassList(TextInputBaseField<TValueType>.multilineInputWithScrollViewUssClassName);
						textElement.AddToClassList(innerTextElementWithScrollViewUssClassName);
					}
					else if (multilineContainer == null)
					{
						textElement.RegisterCallback<GeometryChangedEvent>(TextElementOnGeometryChangedEvent);
						multilineContainer = new VisualElement
						{
							classList = { TextInputBaseField<TValueType>.multilineContainerClassName }
						};
						multilineContainer.Add(textElement);
						Add(multilineContainer);
						SetMultilineContainerStyle();
						AddToClassList(TextInputBaseField<TValueType>.multilineInputUssClassName);
						textElement.AddToClassList(innerTextElementUssClassName);
					}
				}
			}

			private void ScrollViewOnGeometryChangedEvent(GeometryChangedEvent e)
			{
				if (!(e.oldRect.size == e.newRect.size))
				{
					UpdateScrollOffset();
				}
			}

			private void TextElementOnGeometryChangedEvent(GeometryChangedEvent e)
			{
				if (!(e.oldRect.size == e.newRect.size))
				{
					bool widthChanged = Math.Abs(e.oldRect.size.x - e.newRect.size.x) > 1E-30f;
					UpdateScrollOffset(isBackspace: false, widthChanged);
				}
			}

			internal void OnInputCustomStyleResolved(CustomStyleResolvedEvent e)
			{
				ICustomStyle customStyle = e.customStyle;
				if (customStyle.TryGetValue(TextInputBaseField<TValueType>.s_SelectionColorProperty, out var value))
				{
					textSelection.selectionColor = value;
				}
				if (customStyle.TryGetValue(TextInputBaseField<TValueType>.s_CursorColorProperty, out var value2))
				{
					textSelection.cursorColor = value2;
				}
				SetScrollViewMode();
				SetMultilineContainerStyle();
			}

			internal virtual bool AcceptCharacter(char c)
			{
				return !isReadOnly && base.enabledInHierarchy;
			}

			internal void UpdateScrollOffset(bool isBackspace = false)
			{
				UpdateScrollOffset(isBackspace, widthChanged: false);
			}

			internal void UpdateScrollOffset(bool isBackspace, bool widthChanged)
			{
				ITextSelection textSelection = this.textSelection;
				if (textSelection.cursorIndex < 0)
				{
					return;
				}
				if (scrollView != null)
				{
					scrollOffset = GetScrollOffset(scrollView.scrollOffset.x, scrollView.scrollOffset.y, scrollView.contentViewport.layout.width, isBackspace, widthChanged);
					scrollView.scrollOffset = scrollOffset;
					m_ScrollViewWasClamped = scrollOffset.x > scrollView.scrollOffset.x || scrollOffset.y > scrollView.scrollOffset.y;
					return;
				}
				Vector3 position = textElement.transform.position;
				scrollOffset = GetScrollOffset(scrollOffset.x, scrollOffset.y, base.contentRect.width, isBackspace, widthChanged);
				position.y = 0f - Mathf.Min(scrollOffset.y, Math.Abs(textElement.contentRect.height - base.contentRect.height));
				position.x = 0f - scrollOffset.x;
				if (!position.Equals(textElement.transform.position))
				{
					textElement.transform.position = position;
				}
			}

			private Vector2 GetScrollOffset(float xOffset, float yOffset, float contentViewportWidth, bool isBackspace, bool widthChanged)
			{
				Vector2 cursorPosition = textSelection.cursorPosition;
				float cursorWidth = textSelection.cursorWidth;
				float num = xOffset;
				float num2 = yOffset;
				if (Math.Abs(lastCursorPos.x - cursorPosition.x) > 0.05f || m_ScrollViewWasClamped || widthChanged)
				{
					if (cursorPosition.x > xOffset + contentViewportWidth - cursorWidth || (xOffset > 0f && widthChanged))
					{
						float a = Mathf.Ceil(cursorPosition.x + cursorWidth - contentViewportWidth);
						num = Mathf.Max(a, 0f);
					}
					else if (cursorPosition.x < xOffset + 5f)
					{
						num = Mathf.Max(cursorPosition.x - 5f, 0f);
					}
				}
				if (textEdition.multiline && (Math.Abs(lastCursorPos.y - cursorPosition.y) > 0.05f || m_ScrollViewWasClamped))
				{
					if (cursorPosition.y > base.contentRect.height + yOffset)
					{
						num2 = cursorPosition.y - base.contentRect.height;
					}
					else if (cursorPosition.y < textSelection.lineHeightAtCursorPosition + yOffset + 0.05f)
					{
						num2 = cursorPosition.y - textSelection.lineHeightAtCursorPosition;
					}
				}
				lastCursorPos = cursorPosition;
				if (Math.Abs(xOffset - num) > 0.05f || Math.Abs(yOffset - num2) > 0.05f)
				{
					return new Vector2(num, num2);
				}
				return (scrollView != null) ? scrollView.scrollOffset : scrollOffset;
			}

			internal void SetScrollViewMode()
			{
				if (scrollView != null)
				{
					textElement.RemoveFromClassList(verticalVariantInnerTextElementUssClassName);
					textElement.RemoveFromClassList(verticalHorizontalVariantInnerTextElementUssClassName);
					textElement.RemoveFromClassList(horizontalVariantInnerTextElementUssClassName);
					if (textEdition.multiline && base.computedStyle.whiteSpace == WhiteSpace.Normal)
					{
						textElement.AddToClassList(verticalVariantInnerTextElementUssClassName);
						scrollView.mode = ScrollViewMode.Vertical;
					}
					else if (textEdition.multiline)
					{
						textElement.AddToClassList(verticalHorizontalVariantInnerTextElementUssClassName);
						scrollView.mode = ScrollViewMode.VerticalAndHorizontal;
					}
					else
					{
						textElement.AddToClassList(horizontalVariantInnerTextElementUssClassName);
						scrollView.mode = ScrollViewMode.Horizontal;
					}
				}
			}

			private void SetMultilineContainerStyle()
			{
				if (multilineContainer != null)
				{
					if (base.computedStyle.whiteSpace == WhiteSpace.Normal)
					{
						base.style.overflow = Overflow.Hidden;
					}
					else
					{
						base.style.overflow = (Overflow)2;
					}
				}
			}

			private void RemoveSingleLineComponents()
			{
				RemoveFromClassList(TextInputBaseField<TValueType>.singleLineInputUssClassName);
				textElement.RemoveFromClassList(innerTextElementUssClassName);
				textElement.RemoveFromHierarchy();
				textElement.UnregisterCallback<GeometryChangedEvent>(TextElementOnGeometryChangedEvent);
			}

			private void RemoveMultilineComponents()
			{
				if (scrollView != null)
				{
					scrollView.RemoveFromHierarchy();
					scrollView.contentContainer.UnregisterCallback<GeometryChangedEvent>(ScrollViewOnGeometryChangedEvent);
					scrollView.verticalScroller.slider.UnregisterValueChangedCallback(MakeSureScrollViewDoesNotLeakEvents);
					scrollView.horizontalScroller.slider.UnregisterValueChangedCallback(MakeSureScrollViewDoesNotLeakEvents);
					scrollView = null;
					textElement.RemoveFromClassList(verticalVariantInnerTextElementUssClassName);
					textElement.RemoveFromClassList(verticalHorizontalVariantInnerTextElementUssClassName);
					textElement.RemoveFromClassList(horizontalVariantInnerTextElementUssClassName);
					RemoveFromClassList(TextInputBaseField<TValueType>.multilineInputWithScrollViewUssClassName);
					textElement.RemoveFromClassList(innerTextElementWithScrollViewUssClassName);
				}
				if (multilineContainer != null)
				{
					textElement.transform.position = Vector3.zero;
					multilineContainer.RemoveFromHierarchy();
					textElement.UnregisterCallback<GeometryChangedEvent>(TextElementOnGeometryChangedEvent);
					multilineContainer = null;
					RemoveFromClassList(TextInputBaseField<TValueType>.multilineInputUssClassName);
				}
			}

			internal bool SetVerticalScrollerVisibility(ScrollerVisibility sv)
			{
				if (textEdition.multiline)
				{
					m_VerticalScrollerVisibility = sv;
					if (scrollView == null)
					{
						SetMultiline();
					}
					else
					{
						scrollView.verticalScrollerVisibility = m_VerticalScrollerVisibility;
					}
					return true;
				}
				Debug.LogWarning("Can't SetVerticalScrollerVisibility as the field isn't multiline.");
				return false;
			}
		}

		private static CustomStyleProperty<Color> s_SelectionColorProperty = new CustomStyleProperty<Color>("--unity-selection-color");

		private static CustomStyleProperty<Color> s_CursorColorProperty = new CustomStyleProperty<Color>("--unity-cursor-color");

		private int m_VisualInputTabIndex;

		private TextInputBase m_TextInputBase;

		internal const int kMaxLengthNone = -1;

		internal const char kMaskCharDefault = '*';

		public new static readonly string ussClassName = "unity-base-text-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		internal static readonly string multilineContainerClassName = ussClassName + "__multiline-container";

		public static readonly string singleLineInputUssClassName = inputUssClassName + "--single-line";

		public static readonly string multilineInputUssClassName = inputUssClassName + "--multiline";

		internal static readonly string multilineInputWithScrollViewUssClassName = multilineInputUssClassName + "--scroll-view";

		public static readonly string textInputUssName = "unity-text-input";

		protected internal TextInputBase textInputBase => m_TextInputBase;

		public string text
		{
			get
			{
				return m_TextInputBase.text;
			}
			protected internal set
			{
				m_TextInputBase.text = value;
			}
		}

		public bool isReadOnly
		{
			get
			{
				return textEdition.isReadOnly;
			}
			set
			{
				textEdition.isReadOnly = value;
				this.onIsReadOnlyChanged?.Invoke(value);
			}
		}

		public bool isPasswordField
		{
			get
			{
				return m_TextInputBase.isPasswordField;
			}
			set
			{
				if (m_TextInputBase.isPasswordField != value)
				{
					m_TextInputBase.isPasswordField = value;
					m_TextInputBase.IncrementVersion(VersionChangeType.Repaint);
				}
			}
		}

		public bool autoCorrection
		{
			get
			{
				return textEdition.autoCorrection;
			}
			set
			{
				textEdition.autoCorrection = value;
			}
		}

		public bool hideMobileInput
		{
			get
			{
				return textEdition.hideMobileInput;
			}
			set
			{
				textEdition.hideMobileInput = value;
			}
		}

		public TouchScreenKeyboardType keyboardType
		{
			get
			{
				return textEdition.keyboardType;
			}
			set
			{
				textEdition.keyboardType = value;
			}
		}

		public TouchScreenKeyboard touchScreenKeyboard => textEdition.touchScreenKeyboard;

		public ITextSelection textSelection => m_TextInputBase.textElement.selection;

		public ITextEdition textEdition => m_TextInputBase.textElement.edition;

		public Color selectionColor => textSelection.selectionColor;

		public Color cursorColor => textSelection.cursorColor;

		public int cursorIndex
		{
			get
			{
				return textSelection.cursorIndex;
			}
			set
			{
				textSelection.cursorIndex = value;
			}
		}

		public Vector2 cursorPosition => textSelection.cursorPosition;

		public int selectIndex
		{
			get
			{
				return textSelection.selectIndex;
			}
			set
			{
				textSelection.selectIndex = value;
			}
		}

		public bool selectAllOnFocus
		{
			get
			{
				return textSelection.selectAllOnFocus;
			}
			set
			{
				textSelection.selectAllOnFocus = value;
			}
		}

		public bool selectAllOnMouseUp
		{
			get
			{
				return textSelection.selectAllOnMouseUp;
			}
			set
			{
				textSelection.selectAllOnMouseUp = value;
			}
		}

		public int maxLength
		{
			get
			{
				return textEdition.maxLength;
			}
			set
			{
				textEdition.maxLength = value;
			}
		}

		public bool doubleClickSelectsWord
		{
			get
			{
				return textSelection.doubleClickSelectsWord;
			}
			set
			{
				textSelection.doubleClickSelectsWord = value;
			}
		}

		public bool tripleClickSelectsLine
		{
			get
			{
				return textSelection.tripleClickSelectsLine;
			}
			set
			{
				textSelection.tripleClickSelectsLine = value;
			}
		}

		public bool isDelayed
		{
			get
			{
				return textEdition.isDelayed;
			}
			set
			{
				textEdition.isDelayed = value;
			}
		}

		public char maskChar
		{
			get
			{
				return textEdition.maskChar;
			}
			set
			{
				textEdition.maskChar = value;
			}
		}

		internal bool hasFocus => textInputBase.textElement.hasFocus;

		protected event Action<bool> onIsReadOnlyChanged;

		public void SelectAll()
		{
			textSelection.SelectAll();
		}

		public void SelectNone()
		{
			textSelection.SelectNone();
		}

		public void SelectRange(int cursorIndex, int selectionIndex)
		{
			textSelection.SelectRange(cursorIndex, selectionIndex);
		}

		public bool SetVerticalScrollerVisibility(ScrollerVisibility sv)
		{
			return textInputBase.SetVerticalScrollerVisibility(sv);
		}

		public Vector2 MeasureTextSize(string textToMeasure, float width, MeasureMode widthMode, float height, MeasureMode heightMode)
		{
			return TextUtilities.MeasureVisualElementTextSize(m_TextInputBase.textElement, textToMeasure, width, widthMode, height, heightMode);
		}

		protected abstract string ValueToString(TValueType value);

		protected abstract TValueType StringToValue(string str);

		protected TextInputBaseField(int maxLength, char maskChar, TextInputBase textInputBase)
			: this((string)null, maxLength, maskChar, textInputBase)
		{
		}

		protected TextInputBaseField(string label, int maxLength, char maskChar, TextInputBase textInputBase)
			: base(label, (VisualElement)textInputBase)
		{
			base.tabIndex = 0;
			base.delegatesFocus = true;
			base.labelElement.tabIndex = -1;
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			base.visualInput.AddToClassList(singleLineInputUssClassName);
			m_TextInputBase = textInputBase;
			m_TextInputBase.maxLength = maxLength;
			m_TextInputBase.maskChar = maskChar;
			RegisterCallback<CustomStyleResolvedEvent>(OnFieldCustomStyleResolved);
		}

		private void OnFieldCustomStyleResolved(CustomStyleResolvedEvent e)
		{
			m_TextInputBase.OnInputCustomStyleResolved(e);
		}

		[EventInterest(new Type[]
		{
			typeof(NavigationSubmitEvent),
			typeof(FocusInEvent),
			typeof(FocusEvent),
			typeof(BlurEvent)
		})]
		protected override void ExecuteDefaultActionAtTarget(EventBase evt)
		{
			base.ExecuteDefaultActionAtTarget(evt);
			if (textEdition.isReadOnly)
			{
				return;
			}
			if (evt.eventTypeId == EventBase<NavigationSubmitEvent>.TypeId() && evt.leafTarget != textInputBase.textElement)
			{
				textInputBase.textElement.Focus();
			}
			else if (evt.eventTypeId == EventBase<FocusInEvent>.TypeId())
			{
				if (base.showMixedValue)
				{
					((INotifyValueChanged<string>)textInputBase.textElement).SetValueWithoutNotify((string)null);
				}
				if (evt.leafTarget == this || evt.leafTarget == base.labelElement)
				{
					m_VisualInputTabIndex = textInputBase.textElement.tabIndex;
					textInputBase.textElement.tabIndex = -1;
				}
			}
			else if (evt.eventTypeId == EventBase<FocusEvent>.TypeId())
			{
				base.delegatesFocus = false;
			}
			else if (evt.eventTypeId == EventBase<BlurEvent>.TypeId())
			{
				if (base.showMixedValue)
				{
					UpdateMixedValueContent();
				}
				base.delegatesFocus = true;
				if (evt.leafTarget == this || evt.leafTarget == base.labelElement)
				{
					textInputBase.textElement.tabIndex = m_VisualInputTabIndex;
				}
			}
		}

		protected override void UpdateMixedValueContent()
		{
			if (base.showMixedValue)
			{
				((INotifyValueChanged<string>)textInputBase.textElement).SetValueWithoutNotify(BaseField<TValueType>.mixedValueString);
				AddToClassList(BaseField<TValueType>.mixedValueLabelUssClassName);
				base.visualInput?.AddToClassList(BaseField<TValueType>.mixedValueLabelUssClassName);
			}
			else
			{
				UpdateTextFromValue();
				base.visualInput?.RemoveFromClassList(BaseField<TValueType>.mixedValueLabelUssClassName);
				RemoveFromClassList(BaseField<TValueType>.mixedValueLabelUssClassName);
			}
		}

		internal virtual void UpdateValueFromText()
		{
			value = StringToValue(text);
		}

		internal virtual void UpdateTextFromValue()
		{
		}
	}
	internal class TouchScreenTextEditorEventHandler : TextEditorEventHandler
	{
		private IVisualElementScheduledItem m_TouchKeyboardPoller = null;

		private bool m_TouchKeyboardAllowsInPlaceEditing = false;

		private bool m_IsClicking = false;

		public TouchScreenTextEditorEventHandler(TextElement textElement, TextEditingUtilities editingUtilities)
			: base(textElement, editingUtilities)
		{
		}

		private void PollTouchScreenKeyboard()
		{
			m_TouchKeyboardAllowsInPlaceEditing = TouchScreenKeyboard.isInPlaceEditingAllowed;
			if (TouchScreenKeyboard.isSupported && !m_TouchKeyboardAllowsInPlaceEditing)
			{
				if (m_TouchKeyboardPoller == null)
				{
					m_TouchKeyboardPoller = textElement?.schedule.Execute(DoPollTouchScreenKeyboard).Every(100L);
				}
				else
				{
					m_TouchKeyboardPoller.Resume();
				}
			}
		}

		private void DoPollTouchScreenKeyboard()
		{
			if (editingUtilities.TouchScreenKeyboardShouldBeUsed())
			{
				if (textElement.m_TouchScreenKeyboard == null)
				{
					return;
				}
				ITextEdition edition = textElement.edition;
				TouchScreenKeyboard touchScreenKeyboard = textElement.m_TouchScreenKeyboard;
				string text = touchScreenKeyboard.text;
				if (touchScreenKeyboard.status != TouchScreenKeyboard.Status.Visible)
				{
					if (touchScreenKeyboard.status == TouchScreenKeyboard.Status.Canceled)
					{
						edition.RestoreValueAndText();
					}
					else
					{
						text = touchScreenKeyboard.text;
						if (editingUtilities.text != text)
						{
							edition.UpdateText(text);
							textElement.uitkTextHandle.Update();
						}
					}
					CloseTouchScreenKeyboard();
					if (!edition.isDelayed)
					{
						edition.UpdateValueFromText?.Invoke();
					}
					edition.UpdateTextFromValue?.Invoke();
					textElement.Blur();
				}
				else
				{
					if (editingUtilities.text == text)
					{
						return;
					}
					if (edition.hideMobileInput)
					{
						if (editingUtilities.text != text)
						{
							bool flag = false;
							editingUtilities.text = "";
							string text2 = text;
							for (int i = 0; i < text2.Length; i++)
							{
								char c = text2[i];
								if (!edition.AcceptCharacter(c))
								{
									return;
								}
								if (c != 0)
								{
									editingUtilities.text += c;
									flag = true;
								}
							}
							if (flag)
							{
								UpdateStringPositionFromKeyboard();
							}
							edition.UpdateText(editingUtilities.text);
							textElement.uitkTextHandle.Update();
						}
						else if (!m_IsClicking && touchScreenKeyboard != null && touchScreenKeyboard.canGetSelection)
						{
							UpdateStringPositionFromKeyboard();
						}
					}
					else
					{
						edition.UpdateText(text);
						textElement.uitkTextHandle.Update();
					}
					if (!edition.isDelayed)
					{
						edition.UpdateValueFromText?.Invoke();
					}
					edition.UpdateTextFromValue?.Invoke();
					textElement.edition.UpdateScrollOffset?.Invoke(obj: false);
				}
			}
			else
			{
				CloseTouchScreenKeyboard();
			}
		}

		private void UpdateStringPositionFromKeyboard()
		{
			if (textElement.m_TouchScreenKeyboard != null)
			{
				RangeInt selection = textElement.m_TouchScreenKeyboard.selection;
				int start = selection.start;
				int end = selection.end;
				if (textElement.selection.selectIndex != start)
				{
					textElement.selection.selectIndex = start;
				}
				if (textElement.selection.cursorIndex != end)
				{
					textElement.selection.cursorIndex = end;
				}
			}
		}

		private void CloseTouchScreenKeyboard()
		{
			if (textElement.m_TouchScreenKeyboard != null)
			{
				textElement.m_TouchScreenKeyboard.active = false;
				textElement.m_TouchScreenKeyboard = null;
				m_TouchKeyboardPoller?.Pause();
				TouchScreenKeyboard.hideInput = true;
			}
		}

		private void OpenTouchScreenKeyboard()
		{
			ITextEdition edition = textElement.edition;
			TouchScreenKeyboard.hideInput = edition.hideMobileInput;
			textElement.m_TouchScreenKeyboard = TouchScreenKeyboard.Open(textElement.text, edition.keyboardType, !edition.isPassword && edition.autoCorrection, edition.multiline, edition.isPassword);
			if (edition.hideMobileInput)
			{
				int selectIndex = textElement.selection.selectIndex;
				int cursorIndex = textElement.selection.cursorIndex;
				int length = ((selectIndex < cursorIndex) ? (cursorIndex - selectIndex) : (selectIndex - cursorIndex));
				int start = ((selectIndex < cursorIndex) ? selectIndex : cursorIndex);
				textElement.m_TouchScreenKeyboard.selection = new RangeInt(start, length);
			}
			else
			{
				textElement.m_TouchScreenKeyboard.selection = new RangeInt(textElement.m_TouchScreenKeyboard.text?.Length ?? 0, 0);
			}
		}

		public override void ExecuteDefaultActionAtTarget(EventBase evt)
		{
			base.ExecuteDefaultActionAtTarget(evt);
			if (!editingUtilities.TouchScreenKeyboardShouldBeUsed() || textElement.edition.isReadOnly)
			{
				return;
			}
			if (!(evt is PointerDownEvent))
			{
				if (!(evt is PointerUpEvent evt2))
				{
					if (!(evt is FocusInEvent))
					{
						if (evt is FocusOutEvent evt3)
						{
							OnFocusOutEvent(evt3);
						}
					}
					else
					{
						OnFocusInEvent();
					}
				}
				else
				{
					OnPointerUpEvent(evt2);
				}
			}
			else
			{
				OnPointerDownEvent();
			}
		}

		private void OnPointerDownEvent()
		{
			m_IsClicking = true;
			if (textElement.m_TouchScreenKeyboard != null && textElement.edition.hideMobileInput)
			{
				int num = textElement.selection.cursorIndex;
				int num2 = textElement.m_TouchScreenKeyboard.text?.Length ?? 0;
				if (num < 0)
				{
					num = 0;
				}
				if (num > num2)
				{
					num = num2;
				}
				textElement.m_TouchScreenKeyboard.selection = new RangeInt(num, 0);
			}
		}

		private void OnPointerUpEvent(PointerUpEvent evt)
		{
			m_IsClicking = false;
			evt.StopPropagation();
		}

		private void OnFocusInEvent()
		{
			if (textElement.m_TouchScreenKeyboard == null)
			{
				OpenTouchScreenKeyboard();
				if (textElement.m_TouchScreenKeyboard != null)
				{
					PollTouchScreenKeyboard();
				}
				textElement.edition.SaveValueAndText();
				textElement.edition.UpdateScrollOffset?.Invoke(obj: false);
			}
		}

		private void OnFocusOutEvent(FocusOutEvent evt)
		{
			TextElement textElement = (TextElement)evt.target;
			TextElement textElement2 = textElement.focusController.m_LastPendingFocusedElement as TextElement;
			if (textElement2 == textElement || textElement2 == null || textElement2.edition.keyboardType != textElement.edition.keyboardType || textElement2.edition.multiline != textElement.edition.multiline || textElement2.edition.hideMobileInput != textElement.edition.hideMobileInput)
			{
				CloseTouchScreenKeyboard();
				return;
			}
			base.textElement.m_TouchScreenKeyboard = null;
			m_TouchKeyboardPoller?.Pause();
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class IntegerField : TextValueField<int>
	{
		public new class UxmlFactory : UxmlFactory<IntegerField, UxmlTraits>
		{
		}

		public new class UxmlTraits : TextValueFieldTraits<int, UxmlIntAttributeDescription>
		{
		}

		private class IntegerInput : TextValueInput
		{
			private IntegerField parentIntegerField => (IntegerField)base.parent;

			protected override string allowedCharacters => UINumericFieldsUtils.k_AllowedCharactersForInt;

			internal IntegerInput()
			{
				base.formatString = UINumericFieldsUtils.k_IntFieldFormatString;
			}

			public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, int startValue)
			{
				double num = NumericFieldDraggerUtility.CalculateIntDragSensitivity(startValue);
				float acceleration = NumericFieldDraggerUtility.Acceleration(speed == DeltaSpeed.Fast, speed == DeltaSpeed.Slow);
				long num2 = StringToValue(base.text);
				num2 += (long)Math.Round((double)NumericFieldDraggerUtility.NiceDelta(delta, acceleration) * num);
				if (parentIntegerField.isDelayed)
				{
					base.text = ValueToString(Mathf.ClampToInt(num2));
				}
				else
				{
					parentIntegerField.value = Mathf.ClampToInt(num2);
				}
			}

			protected override string ValueToString(int v)
			{
				return v.ToString(base.formatString);
			}

			protected override int StringToValue(string str)
			{
				UINumericFieldsUtils.TryConvertStringToInt(str, base.originalText, out var value);
				return value;
			}
		}

		public new static readonly string ussClassName = "unity-integer-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		private IntegerInput integerInput => (IntegerInput)base.textInputBase;

		protected override string ValueToString(int v)
		{
			return v.ToString(base.formatString, CultureInfo.InvariantCulture.NumberFormat);
		}

		protected override int StringToValue(string str)
		{
			int num;
			return UINumericFieldsUtils.TryConvertStringToInt(str, base.textInputBase.originalText, out num) ? num : base.rawValue;
		}

		public IntegerField()
			: this(null)
		{
		}

		public IntegerField(int maxLength)
			: this(null, maxLength)
		{
		}

		public IntegerField(string label, int maxLength = 1000)
			: base(label, maxLength, (TextValueInput)new IntegerInput())
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			AddLabelDragger<int>();
		}

		internal override bool CanTryParse(string textString)
		{
			int result;
			return int.TryParse(textString, out result);
		}

		public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, int startValue)
		{
			integerInput.ApplyInputDeviceDelta(delta, speed, startValue);
		}
	}
	public class Label : TextElement
	{
		public new class UxmlFactory : UxmlFactory<Label, UxmlTraits>
		{
		}

		public new class UxmlTraits : TextElement.UxmlTraits
		{
		}

		public new static readonly string ussClassName = "unity-label";

		public Label()
			: this(string.Empty)
		{
		}

		public Label(string text)
		{
			AddToClassList(ussClassName);
			this.text = text;
		}
	}
	public class ListView : BaseListView
	{
		public new class UxmlFactory : UxmlFactory<ListView, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseListView.UxmlTraits
		{
		}

		private Func<VisualElement> m_MakeItem;

		private Action<VisualElement, int> m_BindItem;

		public new Func<VisualElement> makeItem
		{
			get
			{
				return m_MakeItem;
			}
			set
			{
				if (value != m_MakeItem)
				{
					m_MakeItem = value;
					Rebuild();
				}
			}
		}

		public new Action<VisualElement, int> bindItem
		{
			get
			{
				return m_BindItem;
			}
			set
			{
				if (value != m_BindItem)
				{
					m_BindItem = value;
					RefreshItems();
				}
			}
		}

		public new Action<VisualElement, int> unbindItem { get; set; }

		public new Action<VisualElement> destroyItem { get; set; }

		internal void SetMakeItemWithoutNotify(Func<VisualElement> func)
		{
			m_MakeItem = func;
		}

		internal void SetBindItemWithoutNotify(Action<VisualElement, int> callback)
		{
			m_BindItem = callback;
		}

		internal override bool HasValidDataAndBindings()
		{
			return base.HasValidDataAndBindings() && makeItem != null == (bindItem != null);
		}

		protected override CollectionViewController CreateViewController()
		{
			return new ListViewController();
		}

		public ListView()
		{
			AddToClassList(BaseListView.ussClassName);
		}

		public ListView(IList itemsSource, float itemHeight = -1f, Func<VisualElement> makeItem = null, Action<VisualElement, int> bindItem = null)
			: base(itemsSource, itemHeight)
		{
			AddToClassList(BaseListView.ussClassName);
			this.makeItem = makeItem;
			this.bindItem = bindItem;
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class LongField : TextValueField<long>
	{
		public new class UxmlFactory : UxmlFactory<LongField, UxmlTraits>
		{
		}

		public new class UxmlTraits : TextValueFieldTraits<long, UxmlLongAttributeDescription>
		{
		}

		private class LongInput : TextValueInput
		{
			private LongField parentLongField => (LongField)base.parent;

			protected override string allowedCharacters => UINumericFieldsUtils.k_AllowedCharactersForInt;

			internal LongInput()
			{
				base.formatString = UINumericFieldsUtils.k_IntFieldFormatString;
			}

			public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, long startValue)
			{
				double num = NumericFieldDraggerUtility.CalculateIntDragSensitivity(startValue);
				float acceleration = NumericFieldDraggerUtility.Acceleration(speed == DeltaSpeed.Fast, speed == DeltaSpeed.Slow);
				long value = StringToValue(base.text);
				long niceDelta = (long)Math.Round((double)NumericFieldDraggerUtility.NiceDelta(delta, acceleration) * num);
				value = ClampMinMaxLongValue(niceDelta, value);
				if (parentLongField.isDelayed)
				{
					base.text = ValueToString(value);
				}
				else
				{
					parentLongField.value = value;
				}
			}

			private long ClampMinMaxLongValue(long niceDelta, long value)
			{
				long num = Math.Abs(niceDelta);
				if (niceDelta > 0)
				{
					if (value > 0 && num > long.MaxValue - value)
					{
						return long.MaxValue;
					}
					return value + niceDelta;
				}
				if (value < 0 && value < long.MinValue + num)
				{
					return long.MinValue;
				}
				return value - num;
			}

			protected override string ValueToString(long v)
			{
				return v.ToString(base.formatString);
			}

			protected override long StringToValue(string str)
			{
				UINumericFieldsUtils.TryConvertStringToLong(str, base.originalText, out var value);
				return value;
			}
		}

		public new static readonly string ussClassName = "unity-long-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		private LongInput longInput => (LongInput)base.textInputBase;

		protected override string ValueToString(long v)
		{
			return v.ToString(base.formatString, CultureInfo.InvariantCulture.NumberFormat);
		}

		protected override long StringToValue(string str)
		{
			long num;
			return UINumericFieldsUtils.TryConvertStringToLong(str, base.textInputBase.originalText, out num) ? num : base.rawValue;
		}

		public LongField()
			: this(null)
		{
		}

		public LongField(int maxLength)
			: this(null, maxLength)
		{
		}

		public LongField(string label, int maxLength = 1000)
			: base(label, maxLength, (TextValueInput)new LongInput())
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			AddLabelDragger<long>();
		}

		internal override bool CanTryParse(string textString)
		{
			long result;
			return long.TryParse(textString, out result);
		}

		public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, long startValue)
		{
			longInput.ApplyInputDeviceDelta(delta, speed, startValue);
		}
	}
	public class MinMaxSlider : BaseField<Vector2>
	{
		public new class UxmlFactory : UxmlFactory<MinMaxSlider, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseField<Vector2>.UxmlTraits
		{
			private UxmlFloatAttributeDescription m_MinValue = new UxmlFloatAttributeDescription
			{
				name = "min-value",
				defaultValue = 0f
			};

			private UxmlFloatAttributeDescription m_MaxValue = new UxmlFloatAttributeDescription
			{
				name = "max-value",
				defaultValue = 10f
			};

			private UxmlFloatAttributeDescription m_LowLimit = new UxmlFloatAttributeDescription
			{
				name = "low-limit",
				defaultValue = float.MinValue
			};

			private UxmlFloatAttributeDescription m_HighLimit = new UxmlFloatAttributeDescription
			{
				name = "high-limit",
				defaultValue = float.MaxValue
			};

			public UxmlTraits()
			{
				m_PickingMode.defaultValue = PickingMode.Ignore;
			}

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				MinMaxSlider minMaxSlider = (MinMaxSlider)ve;
				minMaxSlider.lowLimit = m_LowLimit.GetValueFromBag(bag, cc);
				minMaxSlider.highLimit = m_HighLimit.GetValueFromBag(bag, cc);
				Vector2 value = new Vector2(m_MinValue.GetValueFromBag(bag, cc), m_MaxValue.GetValueFromBag(bag, cc));
				minMaxSlider.value = value;
			}
		}

		private enum DragState
		{
			NoThumb,
			MinThumb,
			MiddleThumb,
			MaxThumb
		}

		private Vector2 m_DragElementStartPos;

		private Vector2 m_ValueStartPos;

		private Rect m_DragMinThumbRect;

		private Rect m_DragMaxThumbRect;

		private DragState m_DragState;

		private float m_MinLimit;

		private float m_MaxLimit;

		internal const float kDefaultHighValue = 10f;

		public new static readonly string ussClassName = "unity-min-max-slider";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		public static readonly string trackerUssClassName = ussClassName + "__tracker";

		public static readonly string draggerUssClassName = ussClassName + "__dragger";

		public static readonly string minThumbUssClassName = ussClassName + "__min-thumb";

		public static readonly string maxThumbUssClassName = ussClassName + "__max-thumb";

		internal VisualElement dragElement { get; private set; }

		internal VisualElement dragMinThumb { get; private set; }

		internal VisualElement dragMaxThumb { get; private set; }

		internal ClampedDragger<float> clampedDragger { get; private set; }

		public float minValue
		{
			get
			{
				return value.x;
			}
			set
			{
				base.value = ClampValues(new Vector2(value, base.rawValue.y));
			}
		}

		public float maxValue
		{
			get
			{
				return value.y;
			}
			set
			{
				base.value = ClampValues(new Vector2(base.rawValue.x, value));
			}
		}

		public override Vector2 value
		{
			get
			{
				return base.value;
			}
			set
			{
				base.value = ClampValues(value);
			}
		}

		public float range => Math.Abs(highLimit - lowLimit);

		public float lowLimit
		{
			get
			{
				return m_MinLimit;
			}
			set
			{
				if (!Mathf.Approximately(m_MinLimit, value))
				{
					if (value > m_MaxLimit)
					{
						throw new ArgumentException("lowLimit is greater than highLimit");
					}
					m_MinLimit = value;
					this.value = base.rawValue;
					UpdateDragElementPosition();
					if (!string.IsNullOrEmpty(base.viewDataKey))
					{
						SaveViewData();
					}
				}
			}
		}

		public float highLimit
		{
			get
			{
				return m_MaxLimit;
			}
			set
			{
				if (!Mathf.Approximately(m_MaxLimit, value))
				{
					if (value < m_MinLimit)
					{
						throw new ArgumentException("highLimit is smaller than lowLimit");
					}
					m_MaxLimit = value;
					this.value = base.rawValue;
					UpdateDragElementPosition();
					if (!string.IsNullOrEmpty(base.viewDataKey))
					{
						SaveViewData();
					}
				}
			}
		}

		public override void SetValueWithoutNotify(Vector2 newValue)
		{
			base.SetValueWithoutNotify(ClampValues(newValue));
			UpdateDragElementPosition();
		}

		public MinMaxSlider()
			: this(null)
		{
		}

		public MinMaxSlider(float minValue, float maxValue, float minLimit, float maxLimit)
			: this(null, minValue, maxValue, minLimit, maxLimit)
		{
		}

		public MinMaxSlider(string label, float minValue = 0f, float maxValue = 10f, float minLimit = float.MinValue, float maxLimit = float.MaxValue)
			: base(label, (VisualElement)null)
		{
			m_MinLimit = float.MinValue;
			m_MaxLimit = float.MaxValue;
			lowLimit = minLimit;
			highLimit = maxLimit;
			Vector2 vector = ClampValues(new Vector2(minValue, maxValue));
			this.minValue = vector.x;
			this.maxValue = vector.y;
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			base.pickingMode = PickingMode.Ignore;
			m_DragState = DragState.NoThumb;
			base.visualInput.pickingMode = PickingMode.Position;
			VisualElement visualElement = new VisualElement
			{
				name = "unity-tracker"
			};
			visualElement.AddToClassList(trackerUssClassName);
			base.visualInput.Add(visualElement);
			dragElement = new VisualElement
			{
				name = "unity-dragger"
			};
			dragElement.AddToClassList(draggerUssClassName);
			dragElement.RegisterCallback<GeometryChangedEvent>(UpdateDragElementPosition);
			base.visualInput.Add(dragElement);
			dragMinThumb = new VisualElement
			{
				name = "unity-thumb-min"
			};
			dragMaxThumb = new VisualElement
			{
				name = "unity-thumb-max"
			};
			dragMinThumb.AddToClassList(minThumbUssClassName);
			dragMaxThumb.AddToClassList(maxThumbUssClassName);
			dragElement.Add(dragMinThumb);
			dragElement.Add(dragMaxThumb);
			clampedDragger = new ClampedDragger<float>(null, SetSliderValueFromClick, SetSliderValueFromDrag);
			base.visualInput.AddManipulator(clampedDragger);
			m_MinLimit = minLimit;
			m_MaxLimit = maxLimit;
			base.rawValue = ClampValues(new Vector2(minValue, maxValue));
			UpdateDragElementPosition();
		}

		private Vector2 ClampValues(Vector2 valueToClamp)
		{
			if (m_MinLimit > m_MaxLimit)
			{
				m_MinLimit = m_MaxLimit;
			}
			Vector2 result = default(Vector2);
			if (valueToClamp.y > m_MaxLimit)
			{
				valueToClamp.y = m_MaxLimit;
			}
			result.x = Mathf.Clamp(valueToClamp.x, m_MinLimit, valueToClamp.y);
			result.y = Mathf.Clamp(valueToClamp.y, valueToClamp.x, m_MaxLimit);
			return result;
		}

		private void UpdateDragElementPosition(GeometryChangedEvent evt)
		{
			if (!(evt.oldRect.size == evt.newRect.size))
			{
				UpdateDragElementPosition();
			}
		}

		private void UpdateDragElementPosition()
		{
			if (base.panel != null)
			{
				float num = 0f - dragElement.resolvedStyle.marginLeft - dragElement.resolvedStyle.marginRight;
				int num2 = dragElement.resolvedStyle.unitySliceLeft + dragElement.resolvedStyle.unitySliceRight;
				float num3 = Mathf.Round(SliderLerpUnclamped(dragElement.resolvedStyle.unitySliceLeft, base.visualInput.layout.width + num - (float)dragElement.resolvedStyle.unitySliceRight, SliderNormalizeValue(minValue, lowLimit, highLimit)) - (float)dragElement.resolvedStyle.unitySliceLeft);
				float num4 = Mathf.Round(SliderLerpUnclamped(dragElement.resolvedStyle.unitySliceLeft, base.visualInput.layout.width + num - (float)dragElement.resolvedStyle.unitySliceRight, SliderNormalizeValue(maxValue, lowLimit, highLimit)) + (float)dragElement.resolvedStyle.unitySliceRight);
				dragElement.style.width = Mathf.Max(num2, num4 - num3);
				dragElement.style.left = num3;
				UpdateDragThumbsRect();
				dragMaxThumb.style.left = dragElement.resolvedStyle.width - (float)dragElement.resolvedStyle.unitySliceRight;
				dragMaxThumb.style.top = 0f;
				dragMinThumb.style.width = m_DragMinThumbRect.width;
				dragMinThumb.style.height = m_DragMinThumbRect.height;
				dragMinThumb.style.left = 0f;
				dragMinThumb.style.top = 0f;
				dragMaxThumb.style.width = m_DragMaxThumbRect.width;
				dragMaxThumb.style.height = m_DragMaxThumbRect.height;
			}
		}

		private void UpdateDragThumbsRect()
		{
			float left = dragElement.resolvedStyle.left;
			float x = dragElement.resolvedStyle.left + (dragElement.resolvedStyle.width - (float)dragElement.resolvedStyle.unitySliceRight);
			float y = dragElement.layout.yMin + dragMinThumb.resolvedStyle.marginTop;
			float y2 = dragElement.layout.yMin + dragMaxThumb.resolvedStyle.marginTop;
			float height = Mathf.Max(dragElement.resolvedStyle.height, dragMinThumb.resolvedStyle.height);
			float height2 = Mathf.Max(dragElement.resolvedStyle.height, dragMaxThumb.resolvedStyle.height);
			m_DragMinThumbRect = new Rect(left, y, dragElement.resolvedStyle.unitySliceLeft, height);
			m_DragMaxThumbRect = new Rect(x, y2, dragElement.resolvedStyle.unitySliceRight, height2);
		}

		internal float SliderLerpUnclamped(float a, float b, float interpolant)
		{
			return Mathf.LerpUnclamped(a, b, interpolant);
		}

		internal float SliderNormalizeValue(float currentValue, float lowerValue, float higherValue)
		{
			return (currentValue - lowerValue) / (higherValue - lowerValue);
		}

		private float ComputeValueFromPosition(float positionToConvert)
		{
			float interpolant = SliderNormalizeValue(positionToConvert, dragElement.resolvedStyle.unitySliceLeft, base.visualInput.layout.width - (float)dragElement.resolvedStyle.unitySliceRight);
			return SliderLerpUnclamped(lowLimit, highLimit, interpolant);
		}

		[EventInterest(new Type[] { typeof(GeometryChangedEvent) })]
		protected override void ExecuteDefaultAction(EventBase evt)
		{
			base.ExecuteDefaultAction(evt);
			if (evt != null && evt.eventTypeId == EventBase<GeometryChangedEvent>.TypeId())
			{
				UpdateDragElementPosition((GeometryChangedEvent)evt);
			}
		}

		private void SetSliderValueFromDrag()
		{
			if (clampedDragger.dragDirection == ClampedDragger<float>.DragDirection.Free)
			{
				float x = m_DragElementStartPos.x;
				float dragElementEndPos = x + clampedDragger.delta.x;
				ComputeValueFromDraggingThumb(x, dragElementEndPos);
			}
		}

		private void SetSliderValueFromClick()
		{
			if (clampedDragger.dragDirection == ClampedDragger<float>.DragDirection.Free)
			{
				return;
			}
			UpdateDragThumbsRect();
			if (m_DragMinThumbRect.Contains(clampedDragger.startMousePosition))
			{
				m_DragState = DragState.MinThumb;
			}
			else if (m_DragMaxThumbRect.Contains(clampedDragger.startMousePosition))
			{
				m_DragState = DragState.MaxThumb;
			}
			else if (clampedDragger.startMousePosition.x > dragElement.layout.xMin && clampedDragger.startMousePosition.x < dragElement.layout.xMax)
			{
				m_DragState = DragState.MiddleThumb;
			}
			else
			{
				m_DragState = DragState.NoThumb;
			}
			if (m_DragState == DragState.NoThumb)
			{
				float num = ComputeValueFromPosition(clampedDragger.startMousePosition.x);
				if (clampedDragger.startMousePosition.x < dragElement.layout.x)
				{
					m_DragState = DragState.MinThumb;
					value = new Vector2(num, value.y);
				}
				else
				{
					m_DragState = DragState.MaxThumb;
					value = new Vector2(value.x, num);
				}
			}
			m_ValueStartPos = value;
			clampedDragger.dragDirection = ClampedDragger<float>.DragDirection.Free;
			m_DragElementStartPos = clampedDragger.startMousePosition;
		}

		private void ComputeValueFromDraggingThumb(float dragElementStartPos, float dragElementEndPos)
		{
			float num = ComputeValueFromPosition(dragElementStartPos);
			float num2 = ComputeValueFromPosition(dragElementEndPos);
			float num3 = num2 - num;
			switch (m_DragState)
			{
			case DragState.MiddleThumb:
			{
				Vector2 vector = value;
				vector.x = m_ValueStartPos.x + num3;
				vector.y = m_ValueStartPos.y + num3;
				float num5 = m_ValueStartPos.y - m_ValueStartPos.x;
				if (vector.x < lowLimit)
				{
					vector.x = lowLimit;
					vector.y = lowLimit + num5;
				}
				else if (vector.y > highLimit)
				{
					vector.y = highLimit;
					vector.x = highLimit - num5;
				}
				value = vector;
				break;
			}
			case DragState.MinThumb:
			{
				float num6 = m_ValueStartPos.x + num3;
				if (num6 > maxValue)
				{
					num6 = maxValue;
				}
				else if (num6 < lowLimit)
				{
					num6 = lowLimit;
				}
				value = new Vector2(num6, maxValue);
				break;
			}
			case DragState.MaxThumb:
			{
				float num4 = m_ValueStartPos.y + num3;
				if (num4 < minValue)
				{
					num4 = minValue;
				}
				else if (num4 > highLimit)
				{
					num4 = highLimit;
				}
				value = new Vector2(minValue, num4);
				break;
			}
			}
		}

		protected override void UpdateMixedValueContent()
		{
		}

		internal override void RegisterEditingCallbacks()
		{
			base.visualInput.RegisterCallback<PointerDownEvent>(base.StartEditing, TrickleDown.TrickleDown);
			base.visualInput.RegisterCallback<PointerUpEvent>(base.EndEditing);
		}

		internal override void UnregisterEditingCallbacks()
		{
			base.visualInput.UnregisterCallback<PointerDownEvent>(base.StartEditing, TrickleDown.TrickleDown);
			base.visualInput.UnregisterCallback<PointerUpEvent>(base.EndEditing);
		}
	}
	internal enum ColumnDataType
	{
		Name,
		Title,
		Icon,
		Visibility,
		Width,
		MaxWidth,
		MinWidth,
		Stretchable,
		Sortable,
		Optional,
		Resizable,
		HeaderTemplate,
		CellTemplate
	}
	public class Column
	{
		internal class UxmlObjectFactory<T> : UxmlObjectFactory<T, UxmlObjectTraits<T>> where T : Column, new()
		{
		}

		internal class UxmlObjectTraits<T> : UnityEngine.UIElements.UxmlObjectTraits<T> where T : Column
		{
			internal const string k_HeaderTemplateAttributeName = "header-template";

			internal const string k_CellTemplateAttributeName = "cell-template";

			private UxmlStringAttributeDescription m_Name = new UxmlStringAttributeDescription
			{
				name = "name"
			};

			private UxmlStringAttributeDescription m_Text = new UxmlStringAttributeDescription
			{
				name = "title"
			};

			private UxmlBoolAttributeDescription m_Visible = new UxmlBoolAttributeDescription
			{
				name = "visible",
				defaultValue = true
			};

			private UxmlStringAttributeDescription m_Width = new UxmlStringAttributeDescription
			{
				name = "width"
			};

			private UxmlStringAttributeDescription m_MinWidth = new UxmlStringAttributeDescription
			{
				name = "min-width"
			};

			private UxmlStringAttributeDescription m_MaxWidth = new UxmlStringAttributeDescription
			{
				name = "max-width"
			};

			private UxmlBoolAttributeDescription m_Stretch = new UxmlBoolAttributeDescription
			{
				name = "stretchable"
			};

			private UxmlBoolAttributeDescription m_Sortable = new UxmlBoolAttributeDescription
			{
				name = "sortable",
				defaultValue = true
			};

			private UxmlBoolAttributeDescription m_Optional = new UxmlBoolAttributeDescription
			{
				name = "optional",
				defaultValue = true
			};

			private UxmlBoolAttributeDescription m_Resizable = new UxmlBoolAttributeDescription
			{
				name = "resizable",
				defaultValue = true
			};

			private UxmlStringAttributeDescription m_HeaderTemplateId = new UxmlStringAttributeDescription
			{
				name = "header-template"
			};

			private UxmlStringAttributeDescription m_CellTemplateId = new UxmlStringAttributeDescription
			{
				name = "cell-template"
			};

			private static Length ParseLength(string str, Length defaultValue)
			{
				float value = defaultValue.value;
				LengthUnit unit = defaultValue.unit;
				int num = 0;
				int num2 = -1;
				for (int i = 0; i < str.Length; i++)
				{
					char c = str[i];
					if (char.IsLetter(c) || c == '%')
					{
						num2 = i;
						break;
					}
					num++;
				}
				string s = str.Substring(0, num);
				string text = string.Empty;
				if (num2 > 0)
				{
					text = str.Substring(num2, str.Length - num2).ToLowerInvariant();
				}
				if (float.TryParse(s, out var result))
				{
					value = result;
				}
				string text2 = text;
				string text3 = text2;
				if (!(text3 == "px"))
				{
					if (text3 == "%")
					{
						unit = LengthUnit.Percent;
					}
				}
				else
				{
					unit = LengthUnit.Pixel;
				}
				return new Length(value, unit);
			}

			public override void Init(ref T obj, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ref obj, bag, cc);
				string valueFromBag = m_Name.GetValueFromBag(bag, cc);
				obj.name = valueFromBag;
				string valueFromBag2 = m_Text.GetValueFromBag(bag, cc);
				obj.title = valueFromBag2;
				bool valueFromBag3 = m_Visible.GetValueFromBag(bag, cc);
				obj.visible = valueFromBag3;
				Length width = ParseLength(m_Width.GetValueFromBag(bag, cc), default(Length));
				obj.width = width;
				Length maxWidth = ParseLength(m_MaxWidth.GetValueFromBag(bag, cc), new Length(8388608f));
				obj.maxWidth = maxWidth;
				Length minWidth = ParseLength(m_MinWidth.GetValueFromBag(bag, cc), new Length(35f));
				obj.minWidth = minWidth;
				bool valueFromBag4 = m_Sortable.GetValueFromBag(bag, cc);
				obj.sortable = valueFromBag4;
				bool valueFromBag5 = m_Stretch.GetValueFromBag(bag, cc);
				obj.stretchable = valueFromBag5;
				bool valueFromBag6 = m_Optional.GetValueFromBag(bag, cc);
				obj.optional = valueFromBag6;
				bool valueFromBag7 = m_Resizable.GetValueFromBag(bag, cc);
				obj.resizable = valueFromBag7;
				string valueFromBag8 = m_HeaderTemplateId.GetValueFromBag(bag, cc);
				if (!string.IsNullOrEmpty(valueFromBag8))
				{
					VisualTreeAsset asset = cc.visualTreeAsset?.ResolveTemplate(valueFromBag8);
					Func<VisualElement> makeHeader = () => (asset != null) ? ((BindableElement)asset.Instantiate()) : ((BindableElement)new Label(k_InvalidTemplateError));
					obj.makeHeader = makeHeader;
				}
				string valueFromBag9 = m_CellTemplateId.GetValueFromBag(bag, cc);
				if (!string.IsNullOrEmpty(valueFromBag9))
				{
					VisualTreeAsset asset2 = cc.visualTreeAsset?.ResolveTemplate(valueFromBag9);
					Func<VisualElement> makeCell = () => (asset2 != null) ? ((BindableElement)asset2.Instantiate()) : ((BindableElement)new Label(k_InvalidTemplateError));
					obj.makeCell = makeCell;
				}
			}
		}

		internal const float kDefaultMinWidth = 35f;

		private static readonly string k_InvalidTemplateError = "Not Found";

		private string m_Name;

		private string m_Title;

		private Background m_Icon;

		private bool m_Visible = true;

		private Length m_Width = 0f;

		private Length m_MinWidth = 35f;

		private Length m_MaxWidth = 8388608f;

		private float m_DesiredWidth = float.NaN;

		private bool m_Stretchable;

		private bool m_Sortable = true;

		private bool m_Optional = true;

		private bool m_Resizable = true;

		private Func<VisualElement> m_MakeHeader;

		private Action<VisualElement> m_BindHeader;

		private Action<VisualElement> m_UnbindHeader;

		private Action<VisualElement> m_DestroyHeader;

		private Func<VisualElement> m_MakeCell;

		private Action<VisualElement, int> m_BindCell;

		private Action<VisualElement, int> m_UnbindCellItem;

		public string name
		{
			get
			{
				return m_Name;
			}
			set
			{
				if (!(m_Name == value))
				{
					m_Name = value;
					NotifyChange(ColumnDataType.Name);
				}
			}
		}

		public string title
		{
			get
			{
				return m_Title;
			}
			set
			{
				if (!(m_Title == value))
				{
					m_Title = value;
					NotifyChange(ColumnDataType.Title);
				}
			}
		}

		public Background icon
		{
			get
			{
				return m_Icon;
			}
			set
			{
				if (!(m_Icon == value))
				{
					m_Icon = value;
					NotifyChange(ColumnDataType.Icon);
				}
			}
		}

		internal int index => collection?.IndexOf(this) ?? (-1);

		internal int displayIndex => (collection?.displayList as List<Column>)?.IndexOf(this) ?? (-1);

		internal int visibleIndex => (collection?.visibleList as List<Column>)?.IndexOf(this) ?? (-1);

		public bool visible
		{
			get
			{
				return m_Visible;
			}
			set
			{
				if (m_Visible != value)
				{
					m_Visible = value;
					NotifyChange(ColumnDataType.Visibility);
				}
			}
		}

		public Length width
		{
			get
			{
				return m_Width;
			}
			set
			{
				if (!(m_Width == value))
				{
					m_Width = value;
					desiredWidth = float.NaN;
					NotifyChange(ColumnDataType.Width);
				}
			}
		}

		public Length minWidth
		{
			get
			{
				return m_MinWidth;
			}
			set
			{
				if (!(m_MinWidth == value))
				{
					m_MinWidth = value;
					NotifyChange(ColumnDataType.MinWidth);
				}
			}
		}

		public Length maxWidth
		{
			get
			{
				return m_MaxWidth;
			}
			set
			{
				if (!(m_MaxWidth == value))
				{
					m_MaxWidth = value;
					NotifyChange(ColumnDataType.MaxWidth);
				}
			}
		}

		internal float desiredWidth
		{
			get
			{
				return m_DesiredWidth;
			}
			set
			{
				if (m_DesiredWidth != value)
				{
					m_DesiredWidth = value;
					this.resized?.Invoke(this);
				}
			}
		}

		public bool sortable
		{
			get
			{
				return m_Sortable;
			}
			set
			{
				if (m_Sortable != value)
				{
					m_Sortable = value;
					NotifyChange(ColumnDataType.Sortable);
				}
			}
		}

		public bool stretchable
		{
			get
			{
				return m_Stretchable;
			}
			set
			{
				if (m_Stretchable != value)
				{
					m_Stretchable = value;
					NotifyChange(ColumnDataType.Stretchable);
				}
			}
		}

		public bool optional
		{
			get
			{
				return m_Optional;
			}
			set
			{
				if (m_Optional != value)
				{
					m_Optional = value;
					NotifyChange(ColumnDataType.Optional);
				}
			}
		}

		public bool resizable
		{
			get
			{
				return m_Resizable;
			}
			set
			{
				if (m_Resizable != value)
				{
					m_Resizable = value;
					NotifyChange(ColumnDataType.Resizable);
				}
			}
		}

		public Func<VisualElement> makeHeader
		{
			get
			{
				return m_MakeHeader;
			}
			set
			{
				if (m_MakeHeader != value)
				{
					m_MakeHeader = value;
					NotifyChange(ColumnDataType.HeaderTemplate);
				}
			}
		}

		public Action<VisualElement> bindHeader
		{
			get
			{
				return m_BindHeader;
			}
			set
			{
				if (m_BindHeader != value)
				{
					m_BindHeader = value;
					NotifyChange(ColumnDataType.HeaderTemplate);
				}
			}
		}

		public Action<VisualElement> unbindHeader
		{
			get
			{
				return m_UnbindHeader;
			}
			set
			{
				if (m_UnbindHeader != value)
				{
					m_UnbindHeader = value;
					NotifyChange(ColumnDataType.HeaderTemplate);
				}
			}
		}

		public Action<VisualElement> destroyHeader
		{
			get
			{
				return m_DestroyHeader;
			}
			set
			{
				if (m_DestroyHeader != value)
				{
					m_DestroyHeader = value;
					NotifyChange(ColumnDataType.HeaderTemplate);
				}
			}
		}

		public Func<VisualElement> makeCell
		{
			get
			{
				return m_MakeCell;
			}
			set
			{
				if (m_MakeCell != value)
				{
					m_MakeCell = value;
					NotifyChange(ColumnDataType.CellTemplate);
				}
			}
		}

		public Action<VisualElement, int> bindCell
		{
			get
			{
				return m_BindCell;
			}
			set
			{
				if (m_BindCell != value)
				{
					m_BindCell = value;
					NotifyChange(ColumnDataType.CellTemplate);
				}
			}
		}

		public Action<VisualElement, int> unbindCell
		{
			get
			{
				return m_UnbindCellItem;
			}
			set
			{
				if (m_UnbindCellItem != value)
				{
					m_UnbindCellItem = value;
					NotifyChange(ColumnDataType.CellTemplate);
				}
			}
		}

		public Action<VisualElement> destroyCell { get; set; }

		public Columns collection { get; internal set; }

		internal event Action<Column, ColumnDataType> changed;

		internal event Action<Column> resized;

		private void NotifyChange(ColumnDataType type)
		{
			this.changed?.Invoke(this, type);
		}

		internal float GetWidth(float layoutWidth)
		{
			return (width.unit == LengthUnit.Pixel) ? width.value : (width.value * layoutWidth / 100f);
		}

		internal float GetMaxWidth(float layoutWidth)
		{
			return (maxWidth.unit == LengthUnit.Pixel) ? maxWidth.value : (maxWidth.value * layoutWidth / 100f);
		}

		internal float GetMinWidth(float layoutWidth)
		{
			return (minWidth.unit == LengthUnit.Pixel) ? minWidth.value : (minWidth.value * layoutWidth / 100f);
		}
	}
	internal class ColumnLayout
	{
		private List<Column> m_StretchableColumns = new List<Column>();

		private List<Column> m_FixedColumns = new List<Column>();

		private List<Column> m_RelativeWidthColumns = new List<Column>();

		private List<Column> m_MixedWidthColumns = new List<Column>();

		private Columns m_Columns;

		private float m_ColumnsWidth = 0f;

		private bool m_ColumnsWidthDirty = true;

		private float m_MaxColumnsWidth = 0f;

		private float m_MinColumnsWidth = 0f;

		private bool m_IsDirty = false;

		private float m_PreviousWidth = float.NaN;

		private float m_LayoutWidth = float.NaN;

		private bool m_DragResizeInPreviewMode;

		private bool m_DragResizing = false;

		private float m_DragStartPos;

		private float m_DragLastPos;

		private float m_DragInitialColumnWidth;

		private List<Column> m_DragStretchableColumns = new List<Column>();

		private List<Column> m_DragRelativeColumns = new List<Column>();

		private List<Column> m_DragFixedColumns = new List<Column>();

		private Dictionary<Column, float> m_PreviewDesiredWidths;

		public Columns columns => m_Columns;

		public bool isDirty => m_IsDirty;

		public float columnsWidth
		{
			get
			{
				if (m_ColumnsWidthDirty)
				{
					m_ColumnsWidth = 0f;
					foreach (Column visible in m_Columns.visibleList)
					{
						m_ColumnsWidth += visible.desiredWidth;
					}
					m_ColumnsWidthDirty = false;
				}
				return m_ColumnsWidth;
			}
		}

		public float layoutWidth => m_LayoutWidth;

		public float minColumnsWidth => m_MinColumnsWidth;

		public float maxColumnsWidth => m_MaxColumnsWidth;

		public bool hasStretchableColumns => m_StretchableColumns.Count > 0;

		public bool hasRelativeWidthColumns => m_RelativeWidthColumns.Count > 0 || m_MixedWidthColumns.Count > 0;

		public event Action layoutRequested;

		public ColumnLayout(Columns columns)
		{
			m_Columns = columns;
			for (int i = 0; i < columns.Count; i++)
			{
				OnColumnAdded(columns[i], i);
			}
			columns.columnAdded += OnColumnAdded;
			columns.columnRemoved += OnColumnRemoved;
			columns.columnReordered += OnColumnReordered;
		}

		public void Dirty()
		{
			if (!m_IsDirty)
			{
				m_IsDirty = true;
				ClearCache();
				this.layoutRequested?.Invoke();
			}
		}

		private void OnColumnAdded(Column column, int index)
		{
			column.changed += OnColumnChanged;
			column.resized += OnColumnResized;
			Dirty();
		}

		private void OnColumnRemoved(Column column)
		{
			column.changed -= OnColumnChanged;
			column.resized -= OnColumnResized;
			Dirty();
		}

		private void OnColumnReordered(Column column, int from, int to)
		{
			Dirty();
		}

		private bool RequiresLayoutUpdate(ColumnDataType type)
		{
			if ((uint)(type - 3) <= 4u || (uint)(type - 11) <= 1u)
			{
				return true;
			}
			return false;
		}

		private void OnColumnChanged(Column column, ColumnDataType type)
		{
			if (!m_DragResizing && RequiresLayoutUpdate(type))
			{
				Dirty();
			}
		}

		private void OnColumnResized(Column column)
		{
			m_ColumnsWidthDirty = true;
		}

		private static bool IsClamped(float value, float min, float max)
		{
			return value >= min && value <= max;
		}

		public void DoLayout(float width)
		{
			m_LayoutWidth = width;
			if (m_IsDirty)
			{
				UpdateCache();
			}
			if (hasRelativeWidthColumns)
			{
				UpdateMinAndMaxColumnsWidth();
			}
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			List<Column> list = new List<Column>();
			List<Column> list2 = new List<Column>();
			foreach (Column column in m_Columns)
			{
				if (!column.visible)
				{
					continue;
				}
				float minWidth = column.GetMinWidth(m_LayoutWidth);
				float maxWidth = column.GetMaxWidth(m_LayoutWidth);
				float width2 = column.GetWidth(m_LayoutWidth);
				if (float.IsNaN(column.desiredWidth))
				{
					if (m_Columns.stretchMode == Columns.StretchMode.GrowAndFill && column.stretchable)
					{
						list.Add(column);
						continue;
					}
					column.desiredWidth = Mathf.Clamp(width2, minWidth, maxWidth);
				}
				else
				{
					if (m_Columns.stretchMode == Columns.StretchMode.GrowAndFill && column.stretchable)
					{
						list2.Add(column);
						num3 += GetDesiredWidth(column);
					}
					if (!IsClamped(column.desiredWidth, minWidth, maxWidth))
					{
						column.desiredWidth = Mathf.Clamp(width2, minWidth, maxWidth);
					}
					if (columns.stretchMode == Columns.StretchMode.Grow && column.width.unit == LengthUnit.Percent)
					{
						column.desiredWidth = Mathf.Clamp(width2, minWidth, maxWidth);
					}
				}
				if (!column.stretchable)
				{
					num2 += column.desiredWidth;
				}
				num += column.desiredWidth;
			}
			if (list.Count > 0)
			{
				float num4 = Math.Max(0f, width - num2);
				int num5 = m_StretchableColumns.Count;
				list.Sort((Column c1, Column c2) => c1.GetMaxWidth(m_LayoutWidth).CompareTo(c2.GetMaxWidth(m_LayoutWidth)));
				foreach (Column item in list)
				{
					float value = num4 / (float)num5;
					item.desiredWidth = Mathf.Clamp(value, item.GetMinWidth(m_LayoutWidth), item.GetMaxWidth(m_LayoutWidth));
					num4 = Math.Max(0f, num4 - item.desiredWidth);
					num5--;
				}
				list2.Sort((Column c1, Column c2) => c1.GetMaxWidth(m_LayoutWidth).CompareTo(c2.GetMaxWidth(m_LayoutWidth)));
				foreach (Column item2 in list2)
				{
					float desiredWidth = GetDesiredWidth(item2);
					float num6 = desiredWidth / num3;
					float value2 = num4 * num6;
					item2.desiredWidth = Mathf.Clamp(value2, item2.GetMinWidth(m_LayoutWidth), item2.GetMaxWidth(m_LayoutWidth));
					num4 = Math.Max(0f, num4 - item2.desiredWidth);
					num3 -= desiredWidth;
					num5--;
				}
			}
			if (hasStretchableColumns || (hasRelativeWidthColumns && m_Columns.stretchMode == Columns.StretchMode.GrowAndFill))
			{
				float delta = 0f;
				if (m_Columns.stretchMode == Columns.StretchMode.Grow)
				{
					if (!float.IsNaN(m_PreviousWidth))
					{
						delta = m_PreviousWidth - width;
					}
				}
				else
				{
					delta = columnsWidth - Mathf.Clamp(width, minColumnsWidth, maxColumnsWidth);
				}
				if (delta != 0f)
				{
					List<Column> value3;
					using (CollectionPool<List<Column>, Column>.Get(out value3))
					{
						List<Column> value4;
						using (CollectionPool<List<Column>, Column>.Get(out value4))
						{
							List<Column> value5;
							using (CollectionPool<List<Column>, Column>.Get(out value5))
							{
								value3.AddRange(m_StretchableColumns);
								value4.AddRange(m_FixedColumns);
								value5.AddRange(m_RelativeWidthColumns);
								StretchResizeColumns(value3, value4, value5, ref delta, resizeToFit: false, dragResize: false);
							}
						}
					}
				}
			}
			m_PreviousWidth = width;
			m_IsDirty = false;
		}

		public void StretchResizeColumns(List<Column> stretchableColumns, List<Column> fixedColumns, List<Column> relativeWidthColumns, ref float delta, bool resizeToFit, bool dragResize)
		{
			if (stretchableColumns.Count != 0 || relativeWidthColumns.Count != 0 || fixedColumns.Count != 0)
			{
				if (delta > 0f)
				{
					DistributeOverflow(stretchableColumns, fixedColumns, relativeWidthColumns, ref delta, resizeToFit, dragResize);
				}
				else
				{
					DistributeExcess(stretchableColumns, fixedColumns, relativeWidthColumns, ref delta, resizeToFit, dragResize);
				}
			}
		}

		private void DistributeOverflow(List<Column> stretchableColumns, List<Column> fixedColumns, List<Column> relativeWidthColumns, ref float delta, bool resizeToFit, bool dragResize)
		{
			float distributedDelta = Math.Abs(delta);
			if (!resizeToFit && !dragResize)
			{
				distributedDelta = RecomputeToDesiredWidth(fixedColumns, distributedDelta, setDesiredWidthOnly: true, distributeOverflow: true);
				distributedDelta = RecomputeToDesiredWidth(relativeWidthColumns, distributedDelta, setDesiredWidthOnly: true, distributeOverflow: true);
			}
			distributedDelta = RecomputeToMinWidthProportionally(stretchableColumns, distributedDelta, !(resizeToFit || dragResize));
			if (resizeToFit)
			{
				distributedDelta = RecomputeToMinWidthProportionally(relativeWidthColumns, distributedDelta);
				distributedDelta = RecomputeToMinWidthProportionally(fixedColumns, distributedDelta);
				distributedDelta = RecomputeToMinWidth(relativeWidthColumns, distributedDelta);
				distributedDelta = RecomputeToMinWidth(fixedColumns, distributedDelta);
			}
			else if (dragResize)
			{
				distributedDelta = RecomputeToMinWidth(relativeWidthColumns, distributedDelta, setDesiredWidthOnly: true);
				distributedDelta = RecomputeToMinWidth(fixedColumns, distributedDelta, setDesiredWidthOnly: true);
			}
			else if (distributedDelta > 0f)
			{
				distributedDelta = RecomputeToMinWidth(relativeWidthColumns, distributedDelta, setDesiredWidthOnly: true);
				distributedDelta = RecomputeToMinWidth(fixedColumns, distributedDelta, setDesiredWidthOnly: true);
			}
			delta = Math.Max(0f, delta - distributedDelta);
		}

		private void DistributeExcess(List<Column> stretchableColumns, List<Column> fixedColumns, List<Column> relativeWidthColumns, ref float delta, bool resizeToFit, bool dragResize)
		{
			float distributedDelta = Math.Abs(delta);
			if (!resizeToFit && !dragResize)
			{
				distributedDelta = RecomputeToDesiredWidth(fixedColumns, distributedDelta, setDesiredWidthOnly: true, distributeOverflow: false);
				distributedDelta = RecomputeToDesiredWidth(relativeWidthColumns, distributedDelta, setDesiredWidthOnly: true, distributeOverflow: false);
			}
			if (dragResize)
			{
				distributedDelta = RecomputeToDesiredWidth(fixedColumns, distributedDelta, setDesiredWidthOnly: true, distributeOverflow: false);
				distributedDelta = RecomputeToDesiredWidth(relativeWidthColumns, distributedDelta, setDesiredWidthOnly: true, distributeOverflow: false);
			}
			distributedDelta = RecomputeToMaxWidthProportionally(stretchableColumns, distributedDelta, !(resizeToFit || dragResize));
			if (resizeToFit)
			{
				distributedDelta = RecomputeToMaxWidthProportionally(relativeWidthColumns, distributedDelta);
				distributedDelta = RecomputeToMaxWidthProportionally(fixedColumns, distributedDelta);
				distributedDelta = RecomputeToMaxWidth(relativeWidthColumns, distributedDelta);
				distributedDelta = RecomputeToMaxWidth(fixedColumns, distributedDelta);
			}
			delta += distributedDelta;
		}

		private float RecomputeToMaxWidthProportionally(List<Column> columns, float distributedDelta, bool setDesiredWidthOnly = false)
		{
			if (distributedDelta > 0f)
			{
				columns.Sort((Column c1, Column c2) => c1.GetMaxWidth(m_LayoutWidth).CompareTo(c2.GetMaxWidth(m_LayoutWidth)));
				float totalColumnWidth = 0f;
				columns.ForEach(delegate(Column c)
				{
					totalColumnWidth += GetDesiredWidth(c);
				});
				for (int num = 0; num < columns.Count; num++)
				{
					Column column = columns[num];
					float desiredWidth = GetDesiredWidth(column);
					float num2 = GetDesiredWidth(column) / totalColumnWidth;
					float val = distributedDelta * num2;
					float num3 = 0f;
					float maxWidth = column.GetMaxWidth(m_LayoutWidth);
					if (GetDesiredWidth(column) < maxWidth)
					{
						num3 = Math.Min(val, maxWidth - GetDesiredWidth(column));
					}
					if (num3 > 0f)
					{
						ResizeColumn(column, GetDesiredWidth(column) + num3, setDesiredWidthOnly);
					}
					totalColumnWidth -= desiredWidth;
					distributedDelta -= num3;
					if (distributedDelta <= 0f)
					{
						break;
					}
				}
			}
			return distributedDelta;
		}

		private float RecomputeToMinWidthProportionally(List<Column> columns, float distributedDelta, bool setDesiredWidthOnly = false)
		{
			if (distributedDelta > 0f)
			{
				columns.Sort((Column c1, Column c2) => c2.GetMinWidth(m_LayoutWidth).CompareTo(c1.GetMinWidth(m_LayoutWidth)));
				float totalColumnsWidth = 0f;
				columns.ForEach(delegate(Column c)
				{
					totalColumnsWidth += GetDesiredWidth(c);
				});
				for (int num = 0; num < columns.Count; num++)
				{
					Column column = columns[num];
					float desiredWidth = GetDesiredWidth(column);
					float num2 = GetDesiredWidth(column) / totalColumnsWidth;
					float val = distributedDelta * num2;
					float num3 = 0f;
					if (GetDesiredWidth(column) > column.GetMinWidth(m_LayoutWidth))
					{
						num3 = Math.Min(val, GetDesiredWidth(column) - column.GetMinWidth(m_LayoutWidth));
					}
					if (num3 > 0f)
					{
						ResizeColumn(column, GetDesiredWidth(column) - num3, setDesiredWidthOnly);
					}
					totalColumnsWidth -= desiredWidth;
					distributedDelta -= num3;
					if (distributedDelta <= 0f)
					{
						break;
					}
				}
			}
			return distributedDelta;
		}

		private float RecomputeToDesiredWidth(List<Column> columns, float distributedDelta, bool setDesiredWidthOnly, bool distributeOverflow)
		{
			if (distributeOverflow)
			{
				for (int num = columns.Count - 1; num >= 0; num--)
				{
					distributedDelta = RecomputeToDesiredWidth(columns[num], distributedDelta, setDesiredWidthOnly, distributeOverflow: true);
					if (distributedDelta <= 0f)
					{
						break;
					}
				}
			}
			else
			{
				for (int i = 0; i < columns.Count; i++)
				{
					distributedDelta = RecomputeToDesiredWidth(columns[i], distributedDelta, setDesiredWidthOnly, distributeOverflow: false);
					if (distributedDelta <= 0f)
					{
						break;
					}
				}
			}
			return distributedDelta;
		}

		private float RecomputeToDesiredWidth(Column column, float distributedDelta, bool setDesiredWidthOnly, bool distributeOverflow)
		{
			float num = 0f;
			float num2 = Mathf.Clamp(column.GetWidth(m_LayoutWidth), column.GetMinWidth(m_LayoutWidth), column.GetMaxWidth(m_LayoutWidth));
			if (GetDesiredWidth(column) > num2 && distributeOverflow)
			{
				num = Math.Min(distributedDelta, Math.Abs(GetDesiredWidth(column) - num2));
			}
			if (GetDesiredWidth(column) < num2 && !distributeOverflow)
			{
				num = Math.Min(distributedDelta, Math.Abs(num2 - GetDesiredWidth(column)));
			}
			float width = (distributeOverflow ? (GetDesiredWidth(column) - num) : (GetDesiredWidth(column) + num));
			if (num > 0f)
			{
				ResizeColumn(column, width, setDesiredWidthOnly);
			}
			distributedDelta -= num;
			return distributedDelta;
		}

		private float RecomputeToMinWidth(List<Column> columns, float distributedDelta, bool setDesiredWidthOnly = false)
		{
			if (distributedDelta > 0f)
			{
				for (int num = columns.Count - 1; num >= 0; num--)
				{
					Column column = columns[num];
					float num2 = 0f;
					if (GetDesiredWidth(column) > column.GetMinWidth(m_LayoutWidth))
					{
						num2 = Math.Min(distributedDelta, GetDesiredWidth(column) - column.GetMinWidth(m_LayoutWidth));
					}
					if (num2 > 0f)
					{
						ResizeColumn(column, GetDesiredWidth(column) - num2, setDesiredWidthOnly);
					}
					distributedDelta -= num2;
					if (distributedDelta <= 0f)
					{
						break;
					}
				}
			}
			return distributedDelta;
		}

		private float RecomputeToMaxWidth(List<Column> columns, float distributedDelta, bool setDesiredWidthOnly = false)
		{
			if (distributedDelta > 0f)
			{
				for (int i = 0; i < columns.Count; i++)
				{
					Column column = columns[i];
					float num = 0f;
					if (GetDesiredWidth(column) < column.GetMaxWidth(m_LayoutWidth))
					{
						num = Math.Min(distributedDelta, Math.Abs(column.GetMaxWidth(m_LayoutWidth) - GetDesiredWidth(column)));
					}
					if (num > 0f)
					{
						ResizeColumn(column, GetDesiredWidth(column) + num, setDesiredWidthOnly);
					}
					distributedDelta -= num;
					if (distributedDelta <= 0f)
					{
						break;
					}
				}
			}
			return distributedDelta;
		}

		public void ResizeToFit(float width)
		{
			float delta = columnsWidth - Mathf.Clamp(width, minColumnsWidth, maxColumnsWidth);
			List<Column> value;
			using (CollectionPool<List<Column>, Column>.Get(out value))
			{
				List<Column> value2;
				using (CollectionPool<List<Column>, Column>.Get(out value2))
				{
					List<Column> value3;
					using (CollectionPool<List<Column>, Column>.Get(out value3))
					{
						value.AddRange(m_StretchableColumns);
						value2.AddRange(m_FixedColumns);
						value3.AddRange(m_RelativeWidthColumns);
						StretchResizeColumns(value, value2, value3, ref delta, resizeToFit: true, dragResize: false);
						if (m_IsDirty)
						{
							UpdateCache();
						}
					}
				}
			}
		}

		private void ResizeColumn(Column column, float width, bool setDesiredWidthOnly = false)
		{
			Length length = new Length(width / layoutWidth * 100f, LengthUnit.Percent);
			if (m_DragResizeInPreviewMode)
			{
				m_PreviewDesiredWidths[column] = width;
				return;
			}
			if (!setDesiredWidthOnly)
			{
				column.width = ((column.width.unit == LengthUnit.Percent) ? length : ((Length)width));
			}
			column.desiredWidth = width;
		}

		internal void BeginDragResize(Column column, float pos, bool previewMode)
		{
			if (m_IsDirty)
			{
				throw new Exception("Cannot begin resizing columns because the layout needs to be updated");
			}
			m_DragResizeInPreviewMode = previewMode;
			m_DragResizing = true;
			int visibleIndex = column.visibleIndex;
			m_DragStartPos = pos;
			m_DragLastPos = pos;
			m_DragInitialColumnWidth = column.desiredWidth;
			m_DragStretchableColumns.Clear();
			m_DragFixedColumns.Clear();
			m_DragRelativeColumns.Clear();
			if (m_DragResizeInPreviewMode)
			{
				if (m_PreviewDesiredWidths == null)
				{
					m_PreviewDesiredWidths = new Dictionary<Column, float>();
				}
				m_PreviewDesiredWidths[column] = column.desiredWidth;
			}
			for (int i = visibleIndex + 1; i < m_Columns.visibleList.Count(); i++)
			{
				Column column2 = m_Columns.visibleList.ElementAt(i);
				if (column2.visible)
				{
					if (column2.stretchable)
					{
						m_DragStretchableColumns.Add(column2);
					}
					else if (column2.width.unit == LengthUnit.Percent)
					{
						m_DragRelativeColumns.Add(column2);
					}
					else
					{
						m_DragFixedColumns.Add(column2);
					}
					if (m_DragResizeInPreviewMode)
					{
						m_PreviewDesiredWidths[column2] = column2.desiredWidth;
					}
				}
			}
		}

		public float GetDesiredPosition(Column column)
		{
			if (!column.visible)
			{
				return float.NaN;
			}
			float num = 0f;
			for (int i = 0; i < column.visibleIndex; i++)
			{
				Column c = m_Columns.visibleList.ElementAt(i);
				float desiredWidth = GetDesiredWidth(c);
				if (!float.IsNaN(desiredWidth))
				{
					num += desiredWidth;
				}
			}
			return num;
		}

		public float GetDesiredWidth(Column c)
		{
			if (m_DragResizeInPreviewMode && m_PreviewDesiredWidths.ContainsKey(c))
			{
				return m_PreviewDesiredWidths[c];
			}
			return c.desiredWidth;
		}

		public void DragResize(Column column, float pos)
		{
			float minWidth = column.GetMinWidth(m_LayoutWidth);
			float maxWidth = column.GetMaxWidth(m_LayoutWidth);
			if (m_Columns.stretchMode == Columns.StretchMode.GrowAndFill)
			{
				float num = pos - m_DragLastPos;
				float num2 = Mathf.Clamp(GetDesiredWidth(column) + num, minWidth, maxWidth);
				num = num2 - GetDesiredWidth(column);
				if (m_DragStretchableColumns.Count == 0 && num < 0f)
				{
					StretchResizeColumns(m_DragStretchableColumns, m_DragFixedColumns, m_DragRelativeColumns, ref num, resizeToFit: false, dragResize: true);
					num2 = Mathf.Clamp(GetDesiredWidth(column) + num2 - GetDesiredWidth(column), minWidth, maxWidth);
				}
				else if (num > 0f && columnsWidth + num < m_LayoutWidth)
				{
					float delta = ((num < m_LayoutWidth - columnsWidth) ? 0f : (num - (m_LayoutWidth - columnsWidth)));
					StretchResizeColumns(m_DragStretchableColumns, m_DragFixedColumns, m_DragRelativeColumns, ref delta, resizeToFit: false, dragResize: true);
					num2 = Mathf.Clamp(GetDesiredWidth(column) + num - delta, minWidth, maxWidth);
				}
				else
				{
					StretchResizeColumns(m_DragStretchableColumns, m_DragFixedColumns, m_DragRelativeColumns, ref num, resizeToFit: false, dragResize: true);
					num2 = Mathf.Clamp(GetDesiredWidth(column) + num, minWidth, maxWidth);
				}
				ResizeColumn(column, num2);
			}
			else
			{
				float num3 = pos - m_DragStartPos;
				float width = Math.Max(minWidth, Math.Min(maxWidth, m_DragInitialColumnWidth + num3));
				ResizeColumn(column, width);
			}
			m_DragLastPos = pos;
		}

		internal void EndDragResize(Column column, bool cancelled)
		{
			if (m_DragResizeInPreviewMode)
			{
				m_DragResizeInPreviewMode = false;
				if (!cancelled)
				{
					foreach (KeyValuePair<Column, float> previewDesiredWidth in m_PreviewDesiredWidths)
					{
						ResizeColumn(previewDesiredWidth.Key, previewDesiredWidth.Value, previewDesiredWidth.Key != column);
					}
				}
				m_PreviewDesiredWidths.Clear();
			}
			m_DragResizing = false;
			m_DragStretchableColumns.Clear();
			m_DragFixedColumns.Clear();
			m_DragRelativeColumns.Clear();
		}

		private void UpdateCache()
		{
			ClearCache();
			foreach (Column visible in m_Columns.visibleList)
			{
				if (visible.stretchable && columns.stretchMode == Columns.StretchMode.GrowAndFill)
				{
					m_StretchableColumns.Add(visible);
				}
				else if (visible.width.unit == LengthUnit.Pixel)
				{
					m_FixedColumns.Add(visible);
				}
				if (visible.width.unit == LengthUnit.Percent)
				{
					m_RelativeWidthColumns.Add(visible);
				}
				if (visible.width.unit == LengthUnit.Pixel && (visible.minWidth.unit == LengthUnit.Percent || visible.maxWidth.unit == LengthUnit.Percent))
				{
					m_MixedWidthColumns.Add(visible);
				}
				m_MaxColumnsWidth += visible.GetMaxWidth(m_LayoutWidth);
				m_MinColumnsWidth += visible.GetMinWidth(m_LayoutWidth);
			}
		}

		private void UpdateMinAndMaxColumnsWidth()
		{
			m_MaxColumnsWidth = 0f;
			m_MinColumnsWidth = 0f;
			foreach (Column visible in m_Columns.visibleList)
			{
				m_MaxColumnsWidth += visible.GetMaxWidth(m_LayoutWidth);
				m_MinColumnsWidth += visible.GetMinWidth(m_LayoutWidth);
			}
		}

		private void ClearCache()
		{
			m_StretchableColumns.Clear();
			m_RelativeWidthColumns.Clear();
			m_FixedColumns.Clear();
			m_MaxColumnsWidth = 0f;
			m_MinColumnsWidth = 0f;
			m_ColumnsWidthDirty = true;
		}
	}
	internal enum ColumnsDataType
	{
		PrimaryColumn,
		StretchMode,
		Reorderable,
		Resizable,
		ResizePreview
	}
	public class Columns : ICollection<Column>, IEnumerable<Column>, IEnumerable
	{
		public enum StretchMode
		{
			Grow,
			GrowAndFill
		}

		internal class UxmlObjectFactory<T> : UxmlObjectFactory<T, UxmlObjectTraits<T>> where T : Columns, new()
		{
		}

		internal class UxmlObjectTraits<T> : UnityEngine.UIElements.UxmlObjectTraits<T> where T : Columns
		{
			private readonly UxmlStringAttributeDescription m_PrimaryColumnName = new UxmlStringAttributeDescription
			{
				name = "primary-column-name"
			};

			private readonly UxmlEnumAttributeDescription<StretchMode> m_StretchMode = new UxmlEnumAttributeDescription<StretchMode>
			{
				name = "stretch-mode",
				defaultValue = StretchMode.GrowAndFill
			};

			private readonly UxmlBoolAttributeDescription m_Reorderable = new UxmlBoolAttributeDescription
			{
				name = "reorderable",
				defaultValue = true
			};

			private readonly UxmlBoolAttributeDescription m_Resizable = new UxmlBoolAttributeDescription
			{
				name = "resizable",
				defaultValue = true
			};

			private readonly UxmlBoolAttributeDescription m_ResizePreview = new UxmlBoolAttributeDescription
			{
				name = "resize-preview"
			};

			private readonly UxmlObjectListAttributeDescription<Column> m_Columns = new UxmlObjectListAttributeDescription<Column>();

			public override void Init(ref T obj, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ref obj, bag, cc);
				string valueFromBag = m_PrimaryColumnName.GetValueFromBag(bag, cc);
				obj.primaryColumnName = valueFromBag;
				StretchMode valueFromBag2 = m_StretchMode.GetValueFromBag(bag, cc);
				obj.stretchMode = valueFromBag2;
				bool valueFromBag3 = m_Reorderable.GetValueFromBag(bag, cc);
				obj.reorderable = valueFromBag3;
				bool valueFromBag4 = m_Resizable.GetValueFromBag(bag, cc);
				obj.resizable = valueFromBag4;
				bool valueFromBag5 = m_ResizePreview.GetValueFromBag(bag, cc);
				obj.resizePreview = valueFromBag5;
				List<Column> valueFromBag6 = m_Columns.GetValueFromBag(bag, cc);
				if (valueFromBag6 == null)
				{
					return;
				}
				foreach (Column item in valueFromBag6)
				{
					obj.Add(item);
				}
			}
		}

		private IList<Column> m_Columns = new List<Column>();

		private List<Column> m_DisplayColumns;

		private List<Column> m_VisibleColumns;

		private bool m_VisibleColumnsDirty = true;

		private StretchMode m_StretchMode = StretchMode.GrowAndFill;

		private bool m_Reorderable = true;

		private bool m_Resizable = true;

		private bool m_ResizePreview;

		private string m_PrimaryColumnName;

		internal IList<Column> columns => m_Columns;

		public string primaryColumnName
		{
			get
			{
				return m_PrimaryColumnName;
			}
			set
			{
				if (!(m_PrimaryColumnName == value))
				{
					m_PrimaryColumnName = value;
					NotifyChange(ColumnsDataType.PrimaryColumn);
				}
			}
		}

		public bool reorderable
		{
			get
			{
				return m_Reorderable;
			}
			set
			{
				if (m_Reorderable != value)
				{
					m_Reorderable = value;
					NotifyChange(ColumnsDataType.Reorderable);
				}
			}
		}

		public bool resizable
		{
			get
			{
				return m_Resizable;
			}
			set
			{
				if (m_Resizable != value)
				{
					m_Resizable = value;
					NotifyChange(ColumnsDataType.Resizable);
				}
			}
		}

		public bool resizePreview
		{
			get
			{
				return m_ResizePreview;
			}
			set
			{
				if (m_ResizePreview != value)
				{
					m_ResizePreview = value;
					NotifyChange(ColumnsDataType.ResizePreview);
				}
			}
		}

		internal IEnumerable<Column> displayList
		{
			get
			{
				InitOrderColumns();
				return m_DisplayColumns;
			}
		}

		internal IEnumerable<Column> visibleList
		{
			get
			{
				UpdateVisibleColumns();
				return m_VisibleColumns;
			}
		}

		public StretchMode stretchMode
		{
			get
			{
				return m_StretchMode;
			}
			set
			{
				if (m_StretchMode != value)
				{
					m_StretchMode = value;
					NotifyChange(ColumnsDataType.StretchMode);
				}
			}
		}

		public int Count => m_Columns.Count;

		public bool IsReadOnly => m_Columns.IsReadOnly;

		public Column this[int index] => m_Columns[index];

		public Column this[string name]
		{
			get
			{
				foreach (Column column in m_Columns)
				{
					if (column.name == name)
					{
						return column;
					}
				}
				return null;
			}
		}

		internal event Action<ColumnsDataType> changed;

		internal event Action<Column, int> columnAdded;

		internal event Action<Column> columnRemoved;

		internal event Action<Column, ColumnDataType> columnChanged;

		internal event Action<Column> columnResized;

		internal event Action<Column, int, int> columnReordered;

		public bool IsPrimary(Column column)
		{
			return primaryColumnName == column.name || (string.IsNullOrEmpty(primaryColumnName) && column.visibleIndex == 0);
		}

		public IEnumerator<Column> GetEnumerator()
		{
			return m_Columns.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public void Add(Column item)
		{
			Insert(m_Columns.Count, item);
		}

		public void Clear()
		{
			while (m_Columns.Count > 0)
			{
				Remove(m_Columns[m_Columns.Count - 1]);
			}
		}

		public bool Contains(Column item)
		{
			return m_Columns.Contains(item);
		}

		public bool Contains(string name)
		{
			foreach (Column column in m_Columns)
			{
				if (column.name == name)
				{
					return true;
				}
			}
			return false;
		}

		public void CopyTo(Column[] array, int arrayIndex)
		{
			m_Columns.CopyTo(array, arrayIndex);
		}

		public bool Remove(Column column)
		{
			if (column == null)
			{
				throw new ArgumentException("Cannot remove null column");
			}
			if (m_Columns.Remove(column))
			{
				m_DisplayColumns?.Remove(column);
				m_VisibleColumns?.Remove(column);
				column.collection = null;
				column.changed -= OnColumnChanged;
				column.resized -= OnColumnResized;
				this.columnRemoved?.Invoke(column);
				return true;
			}
			return false;
		}

		private void OnColumnChanged(Column column, ColumnDataType type)
		{
			if (type == ColumnDataType.Visibility)
			{
				DirtyVisibleColumns();
			}
			this.columnChanged?.Invoke(column, type);
		}

		private void OnColumnResized(Column column)
		{
			this.columnResized?.Invoke(column);
		}

		public int IndexOf(Column column)
		{
			return m_Columns.IndexOf(column);
		}

		public void Insert(int index, Column column)
		{
			if (column == null)
			{
				throw new ArgumentException("Cannot insert null column");
			}
			if (column.collection == this)
			{
				throw new ArgumentException("Already contains this column");
			}
			if (column.collection != null)
			{
				column.collection.Remove(column);
			}
			m_Columns.Insert(index, column);
			if (m_DisplayColumns != null)
			{
				m_DisplayColumns.Insert(index, column);
				DirtyVisibleColumns();
			}
			column.collection = this;
			column.changed += OnColumnChanged;
			column.resized += OnColumnResized;
			this.columnAdded?.Invoke(column, index);
		}

		public void RemoveAt(int index)
		{
			Remove(m_Columns[index]);
		}

		public void ReorderDisplay(int from, int to)
		{
			InitOrderColumns();
			Column column = m_DisplayColumns[from];
			m_DisplayColumns.RemoveAt(from);
			m_DisplayColumns.Insert(to, column);
			DirtyVisibleColumns();
			this.columnReordered?.Invoke(column, from, to);
		}

		private void InitOrderColumns()
		{
			if (m_DisplayColumns == null)
			{
				m_DisplayColumns = new List<Column>(this);
			}
		}

		private void DirtyVisibleColumns()
		{
			m_VisibleColumnsDirty = true;
			if (m_VisibleColumns != null)
			{
				m_VisibleColumns.Clear();
			}
		}

		private void UpdateVisibleColumns()
		{
			if (m_VisibleColumnsDirty)
			{
				InitOrderColumns();
				if (m_VisibleColumns == null)
				{
					m_VisibleColumns = new List<Column>(m_Columns.Count);
				}
				m_VisibleColumns.AddRange(m_DisplayColumns.FindAll((Column c) => c.visible));
				m_VisibleColumnsDirty = false;
			}
		}

		private void NotifyChange(ColumnsDataType type)
		{
			this.changed?.Invoke(type);
		}
	}
	public class MultiColumnController : IDisposable
	{
		private static readonly PropertyName k_BoundColumnVePropertyName = "__unity-multi-column-bound-column";

		internal static readonly PropertyName bindableElementPropertyName = "__unity-multi-column-bindable-element";

		internal static readonly string baseUssClassName = "unity-multi-column-view";

		private static readonly string k_HeaderContainerViewDataKey = "unity-multi-column-header-container";

		public static readonly string headerContainerUssClassName = baseUssClassName + "__header-container";

		public static readonly string rowContainerUssClassName = baseUssClassName + "__row-container";

		public static readonly string cellUssClassName = baseUssClassName + "__cell";

		public static readonly string cellLabelUssClassName = cellUssClassName + "__label";

		private static readonly string k_HeaderViewDataKey = "Header";

		private BaseVerticalCollectionView m_View;

		private VisualElement m_HeaderContainer;

		private MultiColumnCollectionHeader m_MultiColumnHeader;

		internal MultiColumnCollectionHeader header => m_MultiColumnHeader;

		public event Action columnSortingChanged;

		public event Action<ContextualMenuPopulateEvent, Column> headerContextMenuPopulateEvent;

		public MultiColumnController(Columns columns, SortColumnDescriptions sortDescriptions, List<SortColumnDescription> sortedColumns)
		{
			m_MultiColumnHeader = new MultiColumnCollectionHeader(columns, sortDescriptions, sortedColumns)
			{
				viewDataKey = k_HeaderViewDataKey
			};
			m_MultiColumnHeader.columnSortingChanged += OnColumnSortingChanged;
			m_MultiColumnHeader.contextMenuPopulateEvent += OnContextMenuPopulateEvent;
			m_MultiColumnHeader.columnResized += OnColumnResized;
			m_MultiColumnHeader.viewDataRestored += OnViewDataRestored;
			m_MultiColumnHeader.columns.columnAdded += OnColumnAdded;
			m_MultiColumnHeader.columns.columnRemoved += OnColumnRemoved;
			m_MultiColumnHeader.columns.columnReordered += OnColumnReordered;
			m_MultiColumnHeader.columns.columnChanged += OnColumnsChanged;
			m_MultiColumnHeader.columns.changed += OnColumnChanged;
		}

		private static void BindCellItem<T>(VisualElement ve, int rowIndex, Column column, T item)
		{
			if (column.bindCell != null)
			{
				column.bindCell(ve, rowIndex);
			}
			else
			{
				DefaultBindCellItem(ve, column, item);
			}
		}

		private static void UnbindCellItem(VisualElement ve, int rowIndex, Column column)
		{
			column.unbindCell?.Invoke(ve, rowIndex);
		}

		private static VisualElement DefaultMakeCellItem()
		{
			Label label = new Label();
			label.AddToClassList(cellLabelUssClassName);
			return label;
		}

		private static void DefaultBindCellItem<T>(VisualElement ve, Column column, T item)
		{
			if (ve is Label label)
			{
				label.text = item.ToString();
			}
		}

		public VisualElement MakeItem()
		{
			VisualElement visualElement = new VisualElement
			{
				name = rowContainerUssClassName
			};
			visualElement.AddToClassList(rowContainerUssClassName);
			foreach (Column visible in m_MultiColumnHeader.columns.visibleList)
			{
				VisualElement visualElement2 = new VisualElement();
				visualElement2.AddToClassList(cellUssClassName);
				VisualElement visualElement3 = visible.makeCell?.Invoke() ?? DefaultMakeCellItem();
				visualElement2.SetProperty(bindableElementPropertyName, visualElement3);
				visualElement2.Add(visualElement3);
				visualElement.Add(visualElement2);
			}
			return visualElement;
		}

		public void BindItem<T>(VisualElement element, int index, T item)
		{
			int num = 0;
			foreach (Column visible in m_MultiColumnHeader.columns.visibleList)
			{
				if (m_MultiColumnHeader.columnDataMap.TryGetValue(visible, out var value))
				{
					VisualElement visualElement = element[num++];
					VisualElement ve = visualElement.GetProperty(bindableElementPropertyName) as VisualElement;
					BindCellItem(ve, index, visible, item);
					visualElement.style.width = value.control.resolvedStyle.width;
					visualElement.SetProperty(k_BoundColumnVePropertyName, visible);
				}
			}
		}

		public void UnbindItem(VisualElement element, int index)
		{
			foreach (VisualElement item in element.Children())
			{
				if (item.GetProperty(k_BoundColumnVePropertyName) is Column column)
				{
					VisualElement ve = item.GetProperty(bindableElementPropertyName) as VisualElement;
					UnbindCellItem(ve, index, column);
				}
			}
		}

		public void DestroyItem(VisualElement element)
		{
			foreach (VisualElement item in element.Children())
			{
				if (item.GetProperty(k_BoundColumnVePropertyName) is Column column)
				{
					VisualElement obj = item.GetProperty(bindableElementPropertyName) as VisualElement;
					column.destroyCell?.Invoke(obj);
					item.SetProperty(k_BoundColumnVePropertyName, null);
				}
			}
		}

		public void PrepareView(BaseVerticalCollectionView collectionView)
		{
			if (m_View != null)
			{
				Debug.LogWarning("Trying to initialize multi column view more than once. This shouldn't happen.");
				return;
			}
			m_View = collectionView;
			m_HeaderContainer = new VisualElement
			{
				name = headerContainerUssClassName
			};
			m_HeaderContainer.AddToClassList(headerContainerUssClassName);
			m_HeaderContainer.viewDataKey = k_HeaderContainerViewDataKey;
			collectionView.scrollView.hierarchy.Insert(0, m_HeaderContainer);
			m_HeaderContainer.Add(m_MultiColumnHeader);
			m_View.scrollView.horizontalScroller.valueChanged += OnHorizontalScrollerValueChanged;
			m_View.scrollView.contentViewport.RegisterCallback<GeometryChangedEvent>(OnViewportGeometryChanged);
			m_MultiColumnHeader.columnContainer.RegisterCallback<GeometryChangedEvent>(OnColumnContainerGeometryChanged);
		}

		public void Dispose()
		{
			if (m_View != null)
			{
				m_View.scrollView.horizontalScroller.valueChanged -= OnHorizontalScrollerValueChanged;
				m_View.scrollView.contentViewport.UnregisterCallback<GeometryChangedEvent>(OnViewportGeometryChanged);
				m_View = null;
			}
			m_MultiColumnHeader.columnContainer.UnregisterCallback<GeometryChangedEvent>(OnColumnContainerGeometryChanged);
			m_MultiColumnHeader.columnSortingChanged -= OnColumnSortingChanged;
			m_MultiColumnHeader.contextMenuPopulateEvent -= OnContextMenuPopulateEvent;
			m_MultiColumnHeader.columnResized -= OnColumnResized;
			m_MultiColumnHeader.viewDataRestored -= OnViewDataRestored;
			m_MultiColumnHeader.columns.columnAdded -= OnColumnAdded;
			m_MultiColumnHeader.columns.columnRemoved -= OnColumnRemoved;
			m_MultiColumnHeader.columns.columnReordered -= OnColumnReordered;
			m_MultiColumnHeader.columns.columnChanged -= OnColumnsChanged;
			m_MultiColumnHeader.columns.changed -= OnColumnChanged;
			m_MultiColumnHeader.RemoveFromHierarchy();
			m_MultiColumnHeader.Dispose();
			m_MultiColumnHeader = null;
			m_HeaderContainer.RemoveFromHierarchy();
			m_HeaderContainer = null;
		}

		private void OnHorizontalScrollerValueChanged(float v)
		{
			m_MultiColumnHeader.ScrollHorizontally(v);
		}

		private void OnViewportGeometryChanged(GeometryChangedEvent evt)
		{
			float num = m_MultiColumnHeader.resolvedStyle.paddingLeft + m_MultiColumnHeader.resolvedStyle.paddingRight;
			m_MultiColumnHeader.style.maxWidth = evt.newRect.width - num;
			m_MultiColumnHeader.style.maxWidth = evt.newRect.width - num;
			UpdateContentContainer(m_View);
		}

		private void OnColumnContainerGeometryChanged(GeometryChangedEvent evt)
		{
			UpdateContentContainer(m_View);
		}

		private void UpdateContentContainer(BaseVerticalCollectionView collectionView)
		{
			float width = m_MultiColumnHeader.columnContainer.layout.width;
			float num = Mathf.Max(width, collectionView.scrollView.contentViewport.resolvedStyle.width);
			collectionView.scrollView.contentContainer.style.width = num;
		}

		private void OnColumnSortingChanged()
		{
			this.columnSortingChanged?.Invoke();
		}

		private void OnContextMenuPopulateEvent(ContextualMenuPopulateEvent evt, Column column)
		{
			this.headerContextMenuPopulateEvent?.Invoke(evt, column);
		}

		private void OnColumnResized(int index, float width)
		{
			foreach (ReusableCollectionItem activeItem in m_View.activeItems)
			{
				activeItem.bindableElement.ElementAt(index).style.width = width;
			}
		}

		private void OnColumnAdded(Column column, int index)
		{
			m_View.Rebuild();
		}

		private void OnColumnRemoved(Column column)
		{
			m_View.Rebuild();
		}

		private void OnColumnReordered(Column column, int from, int to)
		{
			if (!m_MultiColumnHeader.isApplyingViewState)
			{
				m_View.Rebuild();
			}
		}

		private void OnColumnsChanged(Column column, ColumnDataType type)
		{
			if (!m_MultiColumnHeader.isApplyingViewState && type == ColumnDataType.Visibility)
			{
				m_View.ScheduleRebuild();
			}
		}

		private void OnColumnChanged(ColumnsDataType type)
		{
			if (!m_MultiColumnHeader.isApplyingViewState && type == ColumnsDataType.PrimaryColumn)
			{
				m_View.ScheduleRebuild();
			}
		}

		private void OnViewDataRestored()
		{
			m_View.Rebuild();
		}
	}
	public class MultiColumnListView : BaseListView
	{
		public new class UxmlFactory : UxmlFactory<MultiColumnListView, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseListView.UxmlTraits
		{
			private readonly UxmlBoolAttributeDescription m_SortingEnabled = new UxmlBoolAttributeDescription
			{
				name = "sorting-enabled"
			};

			private readonly UxmlObjectAttributeDescription<Columns> m_Columns = new UxmlObjectAttributeDescription<Columns>();

			private readonly UxmlObjectAttributeDescription<SortColumnDescriptions> m_SortColumnDescriptions = new UxmlObjectAttributeDescription<SortColumnDescriptions>();

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				MultiColumnListView multiColumnListView = (MultiColumnListView)ve;
				multiColumnListView.sortingEnabled = m_SortingEnabled.GetValueFromBag(bag, cc);
				multiColumnListView.sortColumnDescriptions = m_SortColumnDescriptions.GetValueFromBag(bag, cc);
				multiColumnListView.columns = m_Columns.GetValueFromBag(bag, cc);
			}
		}

		private Columns m_Columns;

		private bool m_SortingEnabled;

		private SortColumnDescriptions m_SortColumnDescriptions = new SortColumnDescriptions();

		private List<SortColumnDescription> m_SortedColumns = new List<SortColumnDescription>();

		public new MultiColumnListViewController viewController => base.viewController as MultiColumnListViewController;

		public IEnumerable<SortColumnDescription> sortedColumns => m_SortedColumns;

		public Columns columns
		{
			get
			{
				return m_Columns;
			}
			private set
			{
				if (value == null)
				{
					m_Columns.Clear();
					return;
				}
				m_Columns = value;
				if (m_Columns.Count > 0)
				{
					GetOrCreateViewController();
				}
			}
		}

		public SortColumnDescriptions sortColumnDescriptions
		{
			get
			{
				return m_SortColumnDescriptions;
			}
			private set
			{
				if (value == null)
				{
					m_SortColumnDescriptions.Clear();
					return;
				}
				m_SortColumnDescriptions = value;
				if (viewController != null)
				{
					viewController.columnController.header.sortDescriptions = value;
					RaiseColumnSortingChanged();
				}
			}
		}

		public bool sortingEnabled
		{
			get
			{
				return m_SortingEnabled;
			}
			set
			{
				m_SortingEnabled = value;
				if (viewController != null)
				{
					viewController.columnController.header.sortingEnabled = value;
				}
			}
		}

		public event Action columnSortingChanged;

		public event Action<ContextualMenuPopulateEvent, Column> headerContextMenuPopulateEvent;

		public MultiColumnListView()
			: this(new Columns())
		{
		}

		public MultiColumnListView(Columns columns)
		{
			base.scrollView.viewDataKey = "unity-multi-column-scroll-view";
			this.columns = columns ?? new Columns();
		}

		protected override CollectionViewController CreateViewController()
		{
			return new MultiColumnListViewController(columns, sortColumnDescriptions, m_SortedColumns);
		}

		public override void SetViewController(CollectionViewController controller)
		{
			if (viewController != null)
			{
				viewController.columnController.columnSortingChanged -= RaiseColumnSortingChanged;
				viewController.columnController.headerContextMenuPopulateEvent -= RaiseHeaderContextMenuPopulate;
			}
			base.SetViewController(controller);
			if (viewController != null)
			{
				viewController.header.sortingEnabled = m_SortingEnabled;
				viewController.columnController.columnSortingChanged += RaiseColumnSortingChanged;
				viewController.columnController.headerContextMenuPopulateEvent += RaiseHeaderContextMenuPopulate;
			}
		}

		private protected override void CreateVirtualizationController()
		{
			CreateVirtualizationController<ReusableMultiColumnListViewItem>();
		}

		private void RaiseColumnSortingChanged()
		{
			this.columnSortingChanged?.Invoke();
		}

		private void RaiseHeaderContextMenuPopulate(ContextualMenuPopulateEvent evt, Column column)
		{
			this.headerContextMenuPopulateEvent?.Invoke(evt, column);
		}
	}
	public class MultiColumnTreeView : BaseTreeView
	{
		public new class UxmlFactory : UxmlFactory<MultiColumnTreeView, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseTreeView.UxmlTraits
		{
			private readonly UxmlBoolAttributeDescription m_SortingEnabled = new UxmlBoolAttributeDescription
			{
				name = "sorting-enabled"
			};

			private readonly UxmlObjectAttributeDescription<Columns> m_Columns = new UxmlObjectAttributeDescription<Columns>();

			private readonly UxmlObjectAttributeDescription<SortColumnDescriptions> m_SortColumnDescriptions = new UxmlObjectAttributeDescription<SortColumnDescriptions>();

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				MultiColumnTreeView multiColumnTreeView = (MultiColumnTreeView)ve;
				multiColumnTreeView.sortingEnabled = m_SortingEnabled.GetValueFromBag(bag, cc);
				multiColumnTreeView.sortColumnDescriptions = m_SortColumnDescriptions.GetValueFromBag(bag, cc);
				multiColumnTreeView.columns = m_Columns.GetValueFromBag(bag, cc);
			}
		}

		private Columns m_Columns;

		private bool m_SortingEnabled;

		private SortColumnDescriptions m_SortColumnDescriptions = new SortColumnDescriptions();

		private List<SortColumnDescription> m_SortedColumns = new List<SortColumnDescription>();

		public new MultiColumnTreeViewController viewController => base.viewController as MultiColumnTreeViewController;

		public IEnumerable<SortColumnDescription> sortedColumns => m_SortedColumns;

		public Columns columns
		{
			get
			{
				return m_Columns;
			}
			private set
			{
				if (value == null)
				{
					m_Columns.Clear();
					return;
				}
				m_Columns = value;
				if (m_Columns.Count > 0)
				{
					GetOrCreateViewController();
				}
			}
		}

		public SortColumnDescriptions sortColumnDescriptions
		{
			get
			{
				return m_SortColumnDescriptions;
			}
			private set
			{
				if (value == null)
				{
					m_SortColumnDescriptions.Clear();
					return;
				}
				m_SortColumnDescriptions = value;
				if (viewController != null)
				{
					viewController.columnController.header.sortDescriptions = value;
					RaiseColumnSortingChanged();
				}
			}
		}

		public bool sortingEnabled
		{
			get
			{
				return m_SortingEnabled;
			}
			set
			{
				m_SortingEnabled = value;
				if (viewController != null)
				{
					viewController.columnController.header.sortingEnabled = value;
				}
			}
		}

		public event Action columnSortingChanged;

		public event Action<ContextualMenuPopulateEvent, Column> headerContextMenuPopulateEvent;

		public MultiColumnTreeView()
			: this(new Columns())
		{
		}

		public MultiColumnTreeView(Columns columns)
		{
			base.scrollView.viewDataKey = "unity-multi-column-scroll-view";
			this.columns = columns ?? new Columns();
		}

		internal override void SetRootItemsInternal<T>(IList<TreeViewItemData<T>> rootItems)
		{
			TreeViewHelpers<T, DefaultMultiColumnTreeViewController<T>>.SetRootItems(this, rootItems, () => new DefaultMultiColumnTreeViewController<T>(columns, m_SortColumnDescriptions, m_SortedColumns));
		}

		private protected override IEnumerable<TreeViewItemData<T>> GetSelectedItemsInternal<T>()
		{
			return TreeViewHelpers<T, DefaultMultiColumnTreeViewController<T>>.GetSelectedItems(this);
		}

		private protected override T GetItemDataForIndexInternal<T>(int index)
		{
			return TreeViewHelpers<T, DefaultMultiColumnTreeViewController<T>>.GetItemDataForIndex(this, index);
		}

		private protected override T GetItemDataForIdInternal<T>(int id)
		{
			return TreeViewHelpers<T, DefaultMultiColumnTreeViewController<T>>.GetItemDataForId(this, id);
		}

		private protected override void AddItemInternal<T>(TreeViewItemData<T> item, int parentId, int childIndex, bool rebuildTree)
		{
			TreeViewHelpers<T, DefaultMultiColumnTreeViewController<T>>.AddItem(this, item, parentId, childIndex, rebuildTree);
		}

		protected override CollectionViewController CreateViewController()
		{
			return new DefaultMultiColumnTreeViewController<object>(columns, sortColumnDescriptions, m_SortedColumns);
		}

		public override void SetViewController(CollectionViewController controller)
		{
			if (viewController != null)
			{
				viewController.columnController.columnSortingChanged -= RaiseColumnSortingChanged;
				viewController.columnController.headerContextMenuPopulateEvent -= RaiseHeaderContextMenuPopulate;
			}
			base.SetViewController(controller);
			if (viewController != null)
			{
				viewController.header.sortingEnabled = m_SortingEnabled;
				viewController.columnController.columnSortingChanged += RaiseColumnSortingChanged;
				viewController.columnController.headerContextMenuPopulateEvent += RaiseHeaderContextMenuPopulate;
			}
		}

		private protected override void CreateVirtualizationController()
		{
			CreateVirtualizationController<ReusableMultiColumnTreeViewItem>();
		}

		private void RaiseColumnSortingChanged()
		{
			this.columnSortingChanged?.Invoke();
		}

		private void RaiseHeaderContextMenuPopulate(ContextualMenuPopulateEvent evt, Column column)
		{
			this.headerContextMenuPopulateEvent?.Invoke(evt, column);
		}
	}
	public enum SortDirection
	{
		Ascending,
		Descending
	}
	[Serializable]
	public class SortColumnDescription
	{
		internal class UxmlObjectFactory<T> : UxmlObjectFactory<T, UxmlObjectTraits<T>> where T : SortColumnDescription, new()
		{
		}

		internal class UxmlObjectTraits<T> : UnityEngine.UIElements.UxmlObjectTraits<T> where T : SortColumnDescription
		{
			private readonly UxmlStringAttributeDescription m_ColumnName = new UxmlStringAttributeDescription
			{
				name = "column-name"
			};

			private readonly UxmlIntAttributeDescription m_ColumnIndex = new UxmlIntAttributeDescription
			{
				name = "column-index",
				defaultValue = -1
			};

			private readonly UxmlEnumAttributeDescription<SortDirection> m_SortDescription = new UxmlEnumAttributeDescription<SortDirection>
			{
				name = "direction",
				defaultValue = SortDirection.Ascending
			};

			public override void Init(ref T obj, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ref obj, bag, cc);
				string valueFromBag = m_ColumnName.GetValueFromBag(bag, cc);
				obj.columnName = valueFromBag;
				int valueFromBag2 = m_ColumnIndex.GetValueFromBag(bag, cc);
				obj.columnIndex = valueFromBag2;
				SortDirection valueFromBag3 = m_SortDescription.GetValueFromBag(bag, cc);
				obj.direction = valueFromBag3;
			}
		}

		[SerializeField]
		private int m_ColumnIndex = -1;

		[SerializeField]
		private string m_ColumnName;

		[SerializeField]
		private SortDirection m_SortDirection;

		public string columnName
		{
			get
			{
				return m_ColumnName;
			}
			set
			{
				if (!(m_ColumnName == value))
				{
					m_ColumnName = value;
					this.changed?.Invoke(this);
				}
			}
		}

		public int columnIndex
		{
			get
			{
				return m_ColumnIndex;
			}
			set
			{
				if (m_ColumnIndex != value)
				{
					m_ColumnIndex = value;
					this.changed?.Invoke(this);
				}
			}
		}

		public Column column { get; internal set; }

		public SortDirection direction
		{
			get
			{
				return m_SortDirection;
			}
			set
			{
				if (m_SortDirection != value)
				{
					m_SortDirection = value;
					this.changed?.Invoke(this);
				}
			}
		}

		internal event Action<SortColumnDescription> changed;

		public SortColumnDescription()
		{
		}

		public SortColumnDescription(int columnIndex, SortDirection direction)
		{
			this.columnIndex = columnIndex;
			this.direction = direction;
		}

		public SortColumnDescription(string columnName, SortDirection direction)
		{
			this.columnName = columnName;
			this.direction = direction;
		}
	}
	[Serializable]
	public class SortColumnDescriptions : ICollection<SortColumnDescription>, IEnumerable<SortColumnDescription>, IEnumerable
	{
		internal class UxmlObjectFactory<T> : UxmlObjectFactory<T, UxmlObjectTraits<T>> where T : SortColumnDescriptions, new()
		{
		}

		internal class UxmlObjectTraits<T> : UnityEngine.UIElements.UxmlObjectTraits<T> where T : SortColumnDescriptions
		{
			private readonly UxmlObjectListAttributeDescription<SortColumnDescription> m_SortColumnDescriptions = new UxmlObjectListAttributeDescription<SortColumnDescription>();

			public override void Init(ref T obj, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ref obj, bag, cc);
				List<SortColumnDescription> valueFromBag = m_SortColumnDescriptions.GetValueFromBag(bag, cc);
				if (valueFromBag == null)
				{
					return;
				}
				foreach (SortColumnDescription item in valueFromBag)
				{
					obj.Add(item);
				}
			}
		}

		[SerializeField]
		private readonly IList<SortColumnDescription> m_Descriptions = new List<SortColumnDescription>();

		public int Count => m_Descriptions.Count;

		public bool IsReadOnly => m_Descriptions.IsReadOnly;

		public SortColumnDescription this[int index] => m_Descriptions[index];

		internal event Action changed;

		public IEnumerator<SortColumnDescription> GetEnumerator()
		{
			return m_Descriptions.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public void Add(SortColumnDescription item)
		{
			Insert(m_Descriptions.Count, item);
		}

		public void Clear()
		{
			while (m_Descriptions.Count > 0)
			{
				Remove(m_Descriptions[0]);
			}
		}

		public bool Contains(SortColumnDescription item)
		{
			return m_Descriptions.Contains(item);
		}

		public void CopyTo(SortColumnDescription[] array, int arrayIndex)
		{
			m_Descriptions.CopyTo(array, arrayIndex);
		}

		public bool Remove(SortColumnDescription desc)
		{
			if (desc == null)
			{
				throw new ArgumentException("Cannot remove null description");
			}
			if (m_Descriptions.Remove(desc))
			{
				desc.column = null;
				desc.changed -= OnDescriptionChanged;
				this.changed?.Invoke();
				return true;
			}
			return false;
		}

		private void OnDescriptionChanged(SortColumnDescription desc)
		{
			this.changed?.Invoke();
		}

		public int IndexOf(SortColumnDescription desc)
		{
			return m_Descriptions.IndexOf(desc);
		}

		public void Insert(int index, SortColumnDescription desc)
		{
			if (desc == null)
			{
				throw new ArgumentException("Cannot insert null description");
			}
			if (Contains(desc))
			{
				throw new ArgumentException("Already contains this description");
			}
			m_Descriptions.Insert(index, desc);
			desc.changed += OnDescriptionChanged;
			this.changed?.Invoke();
		}

		public void RemoveAt(int index)
		{
			Remove(m_Descriptions[index]);
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class PopupField<T> : BasePopupField<T, T>
	{
		internal const int kPopupFieldDefaultIndex = -1;

		private int m_Index = -1;

		public new static readonly string ussClassName = "unity-popup-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		public virtual Func<T, string> formatSelectedValueCallback
		{
			get
			{
				return m_FormatSelectedValueCallback;
			}
			set
			{
				m_FormatSelectedValueCallback = value;
				base.textElement.text = GetValueToDisplay();
			}
		}

		public virtual Func<T, string> formatListItemCallback
		{
			get
			{
				return m_FormatListItemCallback;
			}
			set
			{
				m_FormatListItemCallback = value;
			}
		}

		public override T value
		{
			get
			{
				return base.value;
			}
			set
			{
				m_Index = m_Choices?.IndexOf(value) ?? (-1);
				base.value = value;
			}
		}

		public int index
		{
			get
			{
				return m_Index;
			}
			set
			{
				if (value != m_Index)
				{
					m_Index = value;
					if (m_Index >= 0 && m_Index < m_Choices.Count)
					{
						this.value = m_Choices[m_Index];
					}
					else
					{
						this.value = default(T);
					}
				}
			}
		}

		internal override string GetValueToDisplay()
		{
			if (m_FormatSelectedValueCallback != null)
			{
				return m_FormatSelectedValueCallback(value);
			}
			if (value != null)
			{
				return UIElementsUtility.ParseMenuName(value.ToString());
			}
			return string.Empty;
		}

		internal override string GetListItemToDisplay(T value)
		{
			if (m_FormatListItemCallback != null)
			{
				return m_FormatListItemCallback(value);
			}
			return (value != null && m_Choices.Contains(value)) ? value.ToString() : string.Empty;
		}

		public override void SetValueWithoutNotify(T newValue)
		{
			m_Index = m_Choices?.IndexOf(newValue) ?? (-1);
			base.SetValueWithoutNotify(newValue);
		}

		public PopupField()
			: this((string)null)
		{
		}

		public PopupField(string label = null)
			: base(label)
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
		}

		public PopupField(List<T> choices, T defaultValue, Func<T, string> formatSelectedValueCallback = null, Func<T, string> formatListItemCallback = null)
			: this((string)null, choices, defaultValue, formatSelectedValueCallback, formatListItemCallback)
		{
		}

		public PopupField(string label, List<T> choices, T defaultValue, Func<T, string> formatSelectedValueCallback = null, Func<T, string> formatListItemCallback = null)
			: this(label)
		{
			if (defaultValue == null)
			{
				throw new ArgumentNullException("defaultValue");
			}
			this.choices = choices;
			if (!m_Choices.Contains(defaultValue))
			{
				throw new ArgumentException($"Default value {defaultValue} is not present in the list of possible values");
			}
			SetValueWithoutNotify(defaultValue);
			this.formatListItemCallback = formatListItemCallback;
			this.formatSelectedValueCallback = formatSelectedValueCallback;
		}

		public PopupField(List<T> choices, int defaultIndex, Func<T, string> formatSelectedValueCallback = null, Func<T, string> formatListItemCallback = null)
			: this((string)null, choices, defaultIndex, formatSelectedValueCallback, formatListItemCallback)
		{
		}

		public PopupField(string label, List<T> choices, int defaultIndex, Func<T, string> formatSelectedValueCallback = null, Func<T, string> formatListItemCallback = null)
			: this(label)
		{
			this.choices = choices;
			SetIndexWithoutNotify(defaultIndex);
			this.formatListItemCallback = formatListItemCallback;
			this.formatSelectedValueCallback = formatSelectedValueCallback;
		}

		internal override void AddMenuItems(IGenericMenu menu)
		{
			if (menu == null)
			{
				throw new ArgumentNullException("menu");
			}
			if (m_Choices == null)
			{
				return;
			}
			foreach (T item in m_Choices)
			{
				bool isChecked = EqualityComparer<T>.Default.Equals(item, value) && !base.showMixedValue;
				menu.AddItem(GetListItemToDisplay(item), isChecked, delegate
				{
					ChangeValueFromMenu(item);
				});
			}
		}

		internal void SetIndexWithoutNotify(int index)
		{
			m_Index = index;
			if (m_Index >= 0 && m_Index < m_Choices.Count)
			{
				SetValueWithoutNotify(m_Choices[m_Index]);
			}
			else
			{
				SetValueWithoutNotify(default(T));
			}
		}

		private void ChangeValueFromMenu(T menuItem)
		{
			value = menuItem;
		}
	}
	public class PopupWindow : TextElement
	{
		public new class UxmlFactory : UxmlFactory<PopupWindow, UxmlTraits>
		{
		}

		public new class UxmlTraits : TextElement.UxmlTraits
		{
			public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
			{
				get
				{
					yield return new UxmlChildElementDescription(typeof(VisualElement));
				}
			}
		}

		private VisualElement m_ContentContainer;

		public new static readonly string ussClassName = "unity-popup-window";

		public static readonly string contentUssClassName = ussClassName + "__content-container";

		public override VisualElement contentContainer => m_ContentContainer;

		public PopupWindow()
		{
			AddToClassList(ussClassName);
			m_ContentContainer = new VisualElement
			{
				name = "unity-content-container"
			};
			m_ContentContainer.AddToClassList(contentUssClassName);
			base.hierarchy.Add(m_ContentContainer);
		}
	}
	public abstract class AbstractProgressBar : BindableElement, INotifyValueChanged<float>
	{
		public new class UxmlTraits : BindableElement.UxmlTraits
		{
			private UxmlFloatAttributeDescription m_LowValue = new UxmlFloatAttributeDescription
			{
				name = "low-value",
				defaultValue = 0f
			};

			private UxmlFloatAttributeDescription m_HighValue = new UxmlFloatAttributeDescription
			{
				name = "high-value",
				defaultValue = 100f
			};

			private UxmlFloatAttributeDescription m_Value = new UxmlFloatAttributeDescription
			{
				name = "value",
				defaultValue = 0f
			};

			private UxmlStringAttributeDescription m_Title = new UxmlStringAttributeDescription
			{
				name = "title",
				defaultValue = string.Empty
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				AbstractProgressBar abstractProgressBar = ve as AbstractProgressBar;
				abstractProgressBar.lowValue = m_LowValue.GetValueFromBag(bag, cc);
				abstractProgressBar.highValue = m_HighValue.GetValueFromBag(bag, cc);
				string valueFromBag = m_Title.GetValueFromBag(bag, cc);
				abstractProgressBar.title = (string.IsNullOrEmpty(valueFromBag) ? string.Empty : valueFromBag);
				abstractProgressBar.value = m_Value.GetValueFromBag(bag, cc);
			}
		}

		public static readonly string ussClassName = "unity-progress-bar";

		public static readonly string containerUssClassName = ussClassName + "__container";

		public static readonly string titleUssClassName = ussClassName + "__title";

		public static readonly string titleContainerUssClassName = ussClassName + "__title-container";

		public static readonly string progressUssClassName = ussClassName + "__progress";

		public static readonly string backgroundUssClassName = ussClassName + "__background";

		private readonly VisualElement m_Background;

		private readonly VisualElement m_Progress;

		private readonly Label m_Title;

		private float m_LowValue;

		private float m_HighValue = 100f;

		private float m_Value;

		private const float k_MinVisibleProgress = 1f;

		public string title
		{
			get
			{
				return m_Title.text;
			}
			set
			{
				m_Title.text = value;
			}
		}

		public float lowValue
		{
			get
			{
				return m_LowValue;
			}
			set
			{
				m_LowValue = value;
				SetProgress(m_Value);
			}
		}

		public float highValue
		{
			get
			{
				return m_HighValue;
			}
			set
			{
				m_HighValue = value;
				SetProgress(m_Value);
			}
		}

		public virtual float value
		{
			get
			{
				return m_Value;
			}
			set
			{
				if (EqualityComparer<float>.Default.Equals(m_Value, value))
				{
					return;
				}
				if (base.panel != null)
				{
					using (ChangeEvent<float> changeEvent = ChangeEvent<float>.GetPooled(m_Value, value))
					{
						changeEvent.target = this;
						SetValueWithoutNotify(value);
						SendEvent(changeEvent);
						return;
					}
				}
				SetValueWithoutNotify(value);
			}
		}

		public AbstractProgressBar()
		{
			AddToClassList(ussClassName);
			VisualElement visualElement = new VisualElement
			{
				name = ussClassName
			};
			m_Background = new VisualElement();
			m_Background.AddToClassList(backgroundUssClassName);
			visualElement.Add(m_Background);
			m_Progress = new VisualElement();
			m_Progress.AddToClassList(progressUssClassName);
			m_Background.Add(m_Progress);
			VisualElement visualElement2 = new VisualElement();
			visualElement2.AddToClassList(titleContainerUssClassName);
			m_Background.Add(visualElement2);
			m_Title = new Label();
			m_Title.AddToClassList(titleUssClassName);
			visualElement2.Add(m_Title);
			visualElement.AddToClassList(containerUssClassName);
			base.hierarchy.Add(visualElement);
			RegisterCallback<GeometryChangedEvent>(OnGeometryChanged);
		}

		private void OnGeometryChanged(GeometryChangedEvent e)
		{
			SetProgress(value);
		}

		public void SetValueWithoutNotify(float newValue)
		{
			m_Value = newValue;
			SetProgress(value);
		}

		private void SetProgress(float p)
		{
			float width = ((p < lowValue) ? lowValue : ((!(p > highValue)) ? p : highValue));
			width = CalculateProgressWidth(width);
			if (width >= 0f)
			{
				m_Progress.style.right = width;
			}
		}

		private float CalculateProgressWidth(float width)
		{
			if (m_Background == null || m_Progress == null)
			{
				return 0f;
			}
			if (float.IsNaN(m_Background.layout.width))
			{
				return 0f;
			}
			float num = m_Background.layout.width - 2f;
			return num - Mathf.Max(num * width / highValue, 1f);
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class ProgressBar : AbstractProgressBar
	{
		public new class UxmlFactory : UxmlFactory<ProgressBar, UxmlTraits>
		{
		}
	}
	public class RadioButton : BaseBoolField, IGroupBoxOption
	{
		public new class UxmlFactory : UxmlFactory<RadioButton, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseFieldTraits<bool, UxmlBoolAttributeDescription>
		{
			private UxmlStringAttributeDescription m_Text = new UxmlStringAttributeDescription
			{
				name = "text"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				((RadioButton)ve).text = m_Text.GetValueFromBag(bag, cc);
			}
		}

		public new static readonly string ussClassName = "unity-radio-button";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		public static readonly string checkmarkBackgroundUssClassName = ussClassName + "__checkmark-background";

		public static readonly string checkmarkUssClassName = ussClassName + "__checkmark";

		public static readonly string textUssClassName = ussClassName + "__text";

		private VisualElement m_CheckmarkBackground;

		public override bool value
		{
			get
			{
				return base.value;
			}
			set
			{
				if (base.value != value)
				{
					base.value = value;
					UpdateCheckmark();
					if (value)
					{
						this.OnOptionSelected();
					}
				}
			}
		}

		public RadioButton()
			: this(null)
		{
		}

		public RadioButton(string label)
			: base(label)
		{
			AddToClassList(ussClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			m_CheckMark.RemoveFromHierarchy();
			m_CheckmarkBackground = new VisualElement
			{
				pickingMode = PickingMode.Ignore
			};
			m_CheckmarkBackground.Add(m_CheckMark);
			m_CheckmarkBackground.AddToClassList(checkmarkBackgroundUssClassName);
			m_CheckMark.AddToClassList(checkmarkUssClassName);
			base.visualInput.Add(m_CheckmarkBackground);
			UpdateCheckmark();
			RegisterCallback<AttachToPanelEvent>(OnOptionAttachToPanel);
			RegisterCallback<DetachFromPanelEvent>(OnOptionDetachFromPanel);
		}

		private void OnOptionAttachToPanel(AttachToPanelEvent evt)
		{
			this.RegisterGroupBoxOption();
		}

		private void OnOptionDetachFromPanel(DetachFromPanelEvent evt)
		{
			this.UnregisterGroupBoxOption();
		}

		protected override void InitLabel()
		{
			base.InitLabel();
			m_Label.AddToClassList(textUssClassName);
		}

		protected override void ToggleValue()
		{
			if (!value)
			{
				value = true;
			}
		}

		[Obsolete("[UI Toolkit] Please set the value property instead.", false)]
		public void SetSelected(bool selected)
		{
			((IGroupBoxOption)this).SetSelected(selected);
		}

		void IGroupBoxOption.SetSelected(bool selected)
		{
			value = selected;
		}

		public override void SetValueWithoutNotify(bool newValue)
		{
			base.SetValueWithoutNotify(newValue);
			UpdateCheckmark();
		}

		private void UpdateCheckmark()
		{
			m_CheckMark.style.display = ((!value) ? DisplayStyle.None : DisplayStyle.Flex);
		}

		protected override void UpdateMixedValueContent()
		{
			base.UpdateMixedValueContent();
			if (base.showMixedValue)
			{
				m_CheckmarkBackground.RemoveFromHierarchy();
				return;
			}
			m_CheckmarkBackground.Add(m_CheckMark);
			base.visualInput.Add(m_CheckmarkBackground);
		}
	}
	public class RadioButtonGroup : BaseField<int>, IGroupBox
	{
		public new class UxmlFactory : UxmlFactory<RadioButtonGroup, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseFieldTraits<int, UxmlIntAttributeDescription>
		{
			private UxmlStringAttributeDescription m_Choices = new UxmlStringAttributeDescription
			{
				name = "choices"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				RadioButtonGroup radioButtonGroup = (RadioButtonGroup)ve;
				radioButtonGroup.choices = BaseField<int>.UxmlTraits.ParseChoiceList(m_Choices.GetValueFromBag(bag, cc));
			}
		}

		public new static readonly string ussClassName = "unity-radio-button-group";

		public static readonly string containerUssClassName = ussClassName + "__container";

		private List<RadioButton> m_RadioButtons = new List<RadioButton>();

		private EventCallback<ChangeEvent<bool>> m_RadioButtonValueChangedCallback;

		private VisualElement m_RadioButtonContainer;

		public IEnumerable<string> choices
		{
			get
			{
				foreach (RadioButton radioButton in m_RadioButtons)
				{
					yield return radioButton.text;
				}
			}
			set
			{
				if (!value.HasValues())
				{
					m_RadioButtonContainer.Clear();
					if (base.panel != null)
					{
						return;
					}
					foreach (RadioButton radioButton2 in m_RadioButtons)
					{
						radioButton2.UnregisterValueChangedCallback(m_RadioButtonValueChangedCallback);
					}
					m_RadioButtons.Clear();
					return;
				}
				int num = 0;
				foreach (string item in value)
				{
					if (num < m_RadioButtons.Count)
					{
						m_RadioButtons[num].text = item;
						m_RadioButtonContainer.Insert(num, m_RadioButtons[num]);
					}
					else
					{
						RadioButton radioButton = new RadioButton
						{
							text = item
						};
						radioButton.RegisterValueChangedCallback(m_RadioButtonValueChangedCallback);
						m_RadioButtons.Add(radioButton);
						m_RadioButtonContainer.Add(radioButton);
					}
					num++;
				}
				int num2 = m_RadioButtons.Count - 1;
				for (int num3 = num2; num3 >= num; num3--)
				{
					m_RadioButtons[num3].RemoveFromHierarchy();
				}
				UpdateRadioButtons();
			}
		}

		public override VisualElement contentContainer => m_RadioButtonContainer ?? this;

		public RadioButtonGroup()
			: this(null)
		{
		}

		public RadioButtonGroup(string label, List<string> radioButtonChoices = null)
			: base(label, (VisualElement)null)
		{
			AddToClassList(ussClassName);
			VisualElement visualElement = base.visualInput;
			VisualElement obj = new VisualElement
			{
				name = containerUssClassName
			};
			VisualElement child = obj;
			m_RadioButtonContainer = obj;
			visualElement.Add(child);
			m_RadioButtonContainer.AddToClassList(containerUssClassName);
			m_RadioButtonValueChangedCallback = RadioButtonValueChangedCallback;
			choices = radioButtonChoices;
			value = -1;
			base.visualInput.focusable = false;
			base.delegatesFocus = true;
		}

		private void RadioButtonValueChangedCallback(ChangeEvent<bool> evt)
		{
			if (evt.newValue)
			{
				value = m_RadioButtons.IndexOf(evt.target as RadioButton);
				evt.StopPropagation();
			}
		}

		public override void SetValueWithoutNotify(int newValue)
		{
			base.SetValueWithoutNotify(newValue);
			UpdateRadioButtons();
		}

		private void UpdateRadioButtons()
		{
			if (value >= 0 && value < m_RadioButtons.Count)
			{
				m_RadioButtons[value].value = true;
				return;
			}
			foreach (RadioButton radioButton in m_RadioButtons)
			{
				radioButton.value = false;
			}
		}

		void IGroupBox.OnOptionAdded(IGroupBoxOption option)
		{
			if (!(option is RadioButton radioButton))
			{
				throw new ArgumentException("[UI Toolkit] Internal group box error. Expected a radio button element. Please report this using Help -> Report a bug...");
			}
			if (!m_RadioButtons.Contains(radioButton))
			{
				radioButton.RegisterValueChangedCallback(m_RadioButtonValueChangedCallback);
				int num = m_RadioButtonContainer.IndexOf(radioButton);
				if (num < 0 || num > m_RadioButtons.Count)
				{
					m_RadioButtons.Add(radioButton);
					m_RadioButtonContainer.Add(radioButton);
				}
				else
				{
					m_RadioButtons.Insert(num, radioButton);
				}
			}
		}

		void IGroupBox.OnOptionRemoved(IGroupBoxOption option)
		{
			if (!(option is RadioButton radioButton))
			{
				throw new ArgumentException("[UI Toolkit] Internal group box error. Expected a radio button element. Please report this using Help -> Report a bug...");
			}
			int num = m_RadioButtons.IndexOf(radioButton);
			radioButton.UnregisterValueChangedCallback(m_RadioButtonValueChangedCallback);
			m_RadioButtons.Remove(radioButton);
			if (value == num)
			{
				value = -1;
			}
		}
	}
	public class RepeatButton : TextElement
	{
		public new class UxmlFactory : UxmlFactory<RepeatButton, UxmlTraits>
		{
		}

		public new class UxmlTraits : TextElement.UxmlTraits
		{
			private UxmlLongAttributeDescription m_Delay = new UxmlLongAttributeDescription
			{
				name = "delay"
			};

			private UxmlLongAttributeDescription m_Interval = new UxmlLongAttributeDescription
			{
				name = "interval"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				RepeatButton repeatButton = (RepeatButton)ve;
				repeatButton.SetAction(null, m_Delay.GetValueFromBag(bag, cc), m_Interval.GetValueFromBag(bag, cc));
			}
		}

		private Clickable m_Clickable;

		public new static readonly string ussClassName = "unity-repeat-button";

		public RepeatButton()
		{
			AddToClassList(ussClassName);
		}

		public RepeatButton(Action clickEvent, long delay, long interval)
			: this()
		{
			SetAction(clickEvent, delay, interval);
		}

		public void SetAction(Action clickEvent, long delay, long interval)
		{
			this.RemoveManipulator(m_Clickable);
			m_Clickable = new Clickable(clickEvent, delay, interval);
			this.AddManipulator(m_Clickable);
		}

		internal void AddAction(Action clickEvent)
		{
			m_Clickable.clicked += clickEvent;
		}
	}
	public class Scroller : VisualElement
	{
		private class ScrollerSlider : Slider
		{
			public ScrollerSlider(float start, float end, SliderDirection direction, float pageSize)
				: base(start, end, direction, pageSize)
			{
			}

			internal override float SliderNormalizeValue(float currentValue, float lowerValue, float higherValue)
			{
				return Mathf.Clamp(base.SliderNormalizeValue(currentValue, lowerValue, higherValue), 0f, 1f);
			}
		}

		public new class UxmlFactory : UxmlFactory<Scroller, UxmlTraits>
		{
		}

		public new class UxmlTraits : VisualElement.UxmlTraits
		{
			private UxmlFloatAttributeDescription m_LowValue = new UxmlFloatAttributeDescription
			{
				name = "low-value",
				obsoleteNames = new string[1] { "lowValue" }
			};

			private UxmlFloatAttributeDescription m_HighValue = new UxmlFloatAttributeDescription
			{
				name = "high-value",
				obsoleteNames = new string[1] { "highValue" }
			};

			private UxmlEnumAttributeDescription<SliderDirection> m_Direction = new UxmlEnumAttributeDescription<SliderDirection>
			{
				name = "direction",
				defaultValue = SliderDirection.Vertical
			};

			private UxmlFloatAttributeDescription m_Value = new UxmlFloatAttributeDescription
			{
				name = "value"
			};

			public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
			{
				get
				{
					yield break;
				}
			}

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				Scroller scroller = (Scroller)ve;
				scroller.slider.lowValue = m_LowValue.GetValueFromBag(bag, cc);
				scroller.slider.highValue = m_HighValue.GetValueFromBag(bag, cc);
				scroller.direction = m_Direction.GetValueFromBag(bag, cc);
				scroller.value = m_Value.GetValueFromBag(bag, cc);
			}
		}

		internal const float kDefaultPageSize = 20f;

		public static readonly string ussClassName = "unity-scroller";

		public static readonly string horizontalVariantUssClassName = ussClassName + "--horizontal";

		public static readonly string verticalVariantUssClassName = ussClassName + "--vertical";

		public static readonly string sliderUssClassName = ussClassName + "__slider";

		public static readonly string lowButtonUssClassName = ussClassName + "__low-button";

		public static readonly string highButtonUssClassName = ussClassName + "__high-button";

		public Slider slider { get; private set; }

		public RepeatButton lowButton { get; private set; }

		public RepeatButton highButton { get; private set; }

		public float value
		{
			get
			{
				return slider.value;
			}
			set
			{
				slider.value = value;
			}
		}

		public float lowValue
		{
			get
			{
				return slider.lowValue;
			}
			set
			{
				slider.lowValue = value;
			}
		}

		public float highValue
		{
			get
			{
				return slider.highValue;
			}
			set
			{
				slider.highValue = value;
			}
		}

		public SliderDirection direction
		{
			get
			{
				return (base.resolvedStyle.flexDirection != FlexDirection.Row) ? SliderDirection.Vertical : SliderDirection.Horizontal;
			}
			set
			{
				slider.direction = value;
				slider.inverted = value == SliderDirection.Vertical;
				if (value == SliderDirection.Horizontal)
				{
					base.style.flexDirection = FlexDirection.Row;
					AddToClassList(horizontalVariantUssClassName);
					RemoveFromClassList(verticalVariantUssClassName);
				}
				else
				{
					base.style.flexDirection = FlexDirection.Column;
					AddToClassList(verticalVariantUssClassName);
					RemoveFromClassList(horizontalVariantUssClassName);
				}
			}
		}

		public event Action<float> valueChanged;

		public Scroller()
			: this(0f, 0f, null)
		{
		}

		public Scroller(float lowValue, float highValue, Action<float> valueChanged, SliderDirection direction = SliderDirection.Vertical)
		{
			AddToClassList(ussClassName);
			slider = new ScrollerSlider(lowValue, highValue, direction, 20f)
			{
				name = "unity-slider",
				viewDataKey = "Slider"
			};
			slider.AddToClassList(sliderUssClassName);
			slider.RegisterValueChangedCallback(OnSliderValueChange);
			lowButton = new RepeatButton(ScrollPageUp, 250L, 30L)
			{
				name = "unity-low-button"
			};
			lowButton.AddToClassList(lowButtonUssClassName);
			Add(lowButton);
			highButton = new RepeatButton(ScrollPageDown, 250L, 30L)
			{
				name = "unity-high-button"
			};
			highButton.AddToClassList(highButtonUssClassName);
			Add(highButton);
			Add(slider);
			this.direction = direction;
			this.valueChanged = valueChanged;
		}

		public void Adjust(float factor)
		{
			SetEnabled(factor < 1f);
			slider.AdjustDragElement(factor);
		}

		private void OnSliderValueChange(ChangeEvent<float> evt)
		{
			value = evt.newValue;
			this.valueChanged?.Invoke(slider.value);
			IncrementVersion(VersionChangeType.Repaint);
		}

		public void ScrollPageUp()
		{
			ScrollPageUp(1f);
		}

		public void ScrollPageDown()
		{
			ScrollPageDown(1f);
		}

		public void ScrollPageUp(float factor)
		{
			value -= factor * (slider.pageSize * ((slider.lowValue < slider.highValue) ? 1f : (-1f)));
		}

		public void ScrollPageDown(float factor)
		{
			value += factor * (slider.pageSize * ((slider.lowValue < slider.highValue) ? 1f : (-1f)));
		}
	}
	public enum ScrollViewMode
	{
		Vertical,
		Horizontal,
		VerticalAndHorizontal
	}
	public enum ScrollerVisibility
	{
		Auto,
		AlwaysVisible,
		Hidden
	}
	public class ScrollView : VisualElement
	{
		public new class UxmlFactory : UxmlFactory<ScrollView, UxmlTraits>
		{
		}

		public new class UxmlTraits : VisualElement.UxmlTraits
		{
			private UxmlEnumAttributeDescription<ScrollViewMode> m_ScrollViewMode = new UxmlEnumAttributeDescription<ScrollViewMode>
			{
				name = "mode",
				defaultValue = ScrollViewMode.Vertical
			};

			private UxmlEnumAttributeDescription<NestedInteractionKind> m_NestedInteractionKind = new UxmlEnumAttributeDescription<NestedInteractionKind>
			{
				name = "nested-interaction-kind",
				defaultValue = NestedInteractionKind.Default
			};

			private UxmlBoolAttributeDescription m_ShowHorizontal = new UxmlBoolAttributeDescription
			{
				name = "show-horizontal-scroller"
			};

			private UxmlBoolAttributeDescription m_ShowVertical = new UxmlBoolAttributeDescription
			{
				name = "show-vertical-scroller"
			};

			private UxmlEnumAttributeDescription<ScrollerVisibility> m_HorizontalScrollerVisibility = new UxmlEnumAttributeDescription<ScrollerVisibility>
			{
				name = "horizontal-scroller-visibility"
			};

			private UxmlEnumAttributeDescription<ScrollerVisibility> m_VerticalScrollerVisibility = new UxmlEnumAttributeDescription<ScrollerVisibility>
			{
				name = "vertical-scroller-visibility"
			};

			private UxmlFloatAttributeDescription m_HorizontalPageSize = new UxmlFloatAttributeDescription
			{
				name = "horizontal-page-size",
				defaultValue = -1f
			};

			private UxmlFloatAttributeDescription m_VerticalPageSize = new UxmlFloatAttributeDescription
			{
				name = "vertical-page-size",
				defaultValue = -1f
			};

			private UxmlFloatAttributeDescription m_MouseWheelScrollSize = new UxmlFloatAttributeDescription
			{
				name = "mouse-wheel-scroll-size",
				defaultValue = 18f
			};

			private UxmlEnumAttributeDescription<TouchScrollBehavior> m_TouchScrollBehavior = new UxmlEnumAttributeDescription<TouchScrollBehavior>
			{
				name = "touch-scroll-type",
				defaultValue = TouchScrollBehavior.Clamped
			};

			private UxmlFloatAttributeDescription m_ScrollDecelerationRate = new UxmlFloatAttributeDescription
			{
				name = "scroll-deceleration-rate",
				defaultValue = k_DefaultScrollDecelerationRate
			};

			private UxmlFloatAttributeDescription m_Elasticity = new UxmlFloatAttributeDescription
			{
				name = "elasticity",
				defaultValue = k_DefaultElasticity
			};

			private UxmlLongAttributeDescription m_ElasticAnimationIntervalMs = new UxmlLongAttributeDescription
			{
				name = "elastic-animation-interval-ms",
				defaultValue = k_DefaultElasticAnimationInterval
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				ScrollView scrollView = (ScrollView)ve;
				scrollView.mode = m_ScrollViewMode.GetValueFromBag(bag, cc);
				ScrollerVisibility value = ScrollerVisibility.Auto;
				if (m_HorizontalScrollerVisibility.TryGetValueFromBag(bag, cc, ref value))
				{
					scrollView.horizontalScrollerVisibility = value;
				}
				else
				{
					scrollView.showHorizontal = m_ShowHorizontal.GetValueFromBag(bag, cc);
				}
				ScrollerVisibility value2 = ScrollerVisibility.Auto;
				if (m_VerticalScrollerVisibility.TryGetValueFromBag(bag, cc, ref value2))
				{
					scrollView.verticalScrollerVisibility = value2;
				}
				else
				{
					scrollView.showVertical = m_ShowVertical.GetValueFromBag(bag, cc);
				}
				scrollView.nestedInteractionKind = m_NestedInteractionKind.GetValueFromBag(bag, cc);
				scrollView.horizontalPageSize = m_HorizontalPageSize.GetValueFromBag(bag, cc);
				scrollView.verticalPageSize = m_VerticalPageSize.GetValueFromBag(bag, cc);
				scrollView.mouseWheelScrollSize = m_MouseWheelScrollSize.GetValueFromBag(bag, cc);
				scrollView.scrollDecelerationRate = m_ScrollDecelerationRate.GetValueFromBag(bag, cc);
				scrollView.touchScrollBehavior = m_TouchScrollBehavior.GetValueFromBag(bag, cc);
				scrollView.elasticity = m_Elasticity.GetValueFromBag(bag, cc);
				scrollView.elasticAnimationIntervalMs = m_ElasticAnimationIntervalMs.GetValueFromBag(bag, cc);
			}
		}

		public enum TouchScrollBehavior
		{
			Unrestricted,
			Elastic,
			Clamped
		}

		public enum NestedInteractionKind
		{
			Default,
			StopScrolling,
			ForwardScrolling
		}

		internal enum TouchScrollingResult
		{
			Apply,
			Forward,
			Block
		}

		private const int k_MaxLocalLayoutPassCount = 5;

		private int m_FirstLayoutPass = -1;

		private ScrollerVisibility m_HorizontalScrollerVisibility;

		private ScrollerVisibility m_VerticalScrollerVisibility;

		private const float k_SizeThreshold = 0.001f;

		private VisualElement m_AttachedRootVisualContainer;

		private float m_SingleLineHeight = UIElementsUtility.singleLineHeight;

		private const string k_SingleLineHeightPropertyName = "--unity-metrics-single_line-height";

		private const float k_ScrollPageOverlapFactor = 0.1f;

		internal const float k_UnsetPageSizeValue = -1f;

		internal const float k_MouseWheelScrollSizeDefaultValue = 18f;

		internal const float k_MouseWheelScrollSizeUnset = -1f;

		internal bool m_MouseWheelScrollSizeIsInline;

		private float m_HorizontalPageSize;

		private float m_VerticalPageSize;

		private float m_MouseWheelScrollSize = 18f;

		private static readonly float k_DefaultScrollDecelerationRate = 0.135f;

		private float m_ScrollDecelerationRate = k_DefaultScrollDecelerationRate;

		private float k_ScaledPixelsPerPointMultiplier = 10f;

		private float k_TouchScrollInertiaBaseTimeInterval = 0.004167f;

		private static readonly float k_DefaultElasticity = 0.1f;

		private float m_Elasticity = k_DefaultElasticity;

		private TouchScrollBehavior m_TouchScrollBehavior;

		private NestedInteractionKind m_NestedInteractionKind;

		private static readonly long k_DefaultElasticAnimationInterval = 16L;

		private long m_ElasticAnimationIntervalMs = k_DefaultElasticAnimationInterval;

		private VisualElement m_ContentContainer;

		private VisualElement m_ContentAndVerticalScrollContainer;

		private float previousVerticalTouchScrollTimeStamp = 0f;

		private float previousHorizontalTouchScrollTimeStamp = 0f;

		private float elapsedTimeSinceLastVerticalTouchScroll = 0f;

		private float elapsedTimeSinceLastHorizontalTouchScroll = 0f;

		public static readonly string ussClassName = "unity-scroll-view";

		public static readonly string viewportUssClassName = ussClassName + "__content-viewport";

		public static readonly string horizontalVariantViewportUssClassName = viewportUssClassName + "--horizontal";

		public static readonly string verticalVariantViewportUssClassName = viewportUssClassName + "--vertical";

		public static readonly string verticalHorizontalVariantViewportUssClassName = viewportUssClassName + "--vertical-horizontal";

		public static readonly string contentAndVerticalScrollUssClassName = ussClassName + "__content-and-vertical-scroll-container";

		public static readonly string contentUssClassName = ussClassName + "__content-container";

		public static readonly string horizontalVariantContentUssClassName = contentUssClassName + "--horizontal";

		public static readonly string verticalVariantContentUssClassName = contentUssClassName + "--vertical";

		public static readonly string verticalHorizontalVariantContentUssClassName = contentUssClassName + "--vertical-horizontal";

		public static readonly string hScrollerUssClassName = ussClassName + "__horizontal-scroller";

		public static readonly string vScrollerUssClassName = ussClassName + "__vertical-scroller";

		public static readonly string horizontalVariantUssClassName = ussClassName + "--horizontal";

		public static readonly string verticalVariantUssClassName = ussClassName + "--vertical";

		public static readonly string verticalHorizontalVariantUssClassName = ussClassName + "--vertical-horizontal";

		public static readonly string scrollVariantUssClassName = ussClassName + "--scroll";

		private ScrollViewMode m_Mode;

		private IVisualElementScheduledItem m_ScheduledLayoutPassResetItem;

		private const float k_VelocityLerpTimeFactor = 10f;

		internal const float ScrollThresholdSquared = 100f;

		private Vector2 m_StartPosition;

		private Vector2 m_PointerStartPosition;

		private Vector2 m_Velocity;

		private Vector2 m_SpringBackVelocity;

		private Vector2 m_LowBounds;

		private Vector2 m_HighBounds;

		private float m_LastVelocityLerpTime;

		private bool m_StartedMoving;

		private bool m_TouchPointerMoveAllowed;

		private bool m_TouchStoppedVelocity;

		private VisualElement m_CapturedTarget;

		private EventCallback<PointerMoveEvent> m_CapturedTargetPointerMoveCallback;

		private EventCallback<PointerUpEvent> m_CapturedTargetPointerUpCallback;

		internal IVisualElementScheduledItem m_PostPointerUpAnimation;

		public ScrollerVisibility horizontalScrollerVisibility
		{
			get
			{
				return m_HorizontalScrollerVisibility;
			}
			set
			{
				m_HorizontalScrollerVisibility = value;
				UpdateScrollers(needsHorizontal, needsVertical);
			}
		}

		public ScrollerVisibility verticalScrollerVisibility
		{
			get
			{
				return m_VerticalScrollerVisibility;
			}
			set
			{
				m_VerticalScrollerVisibility = value;
				UpdateScrollers(needsHorizontal, needsVertical);
			}
		}

		[Obsolete("showHorizontal is obsolete. Use horizontalScrollerVisibility instead")]
		public bool showHorizontal
		{
			get
			{
				return horizontalScrollerVisibility == ScrollerVisibility.AlwaysVisible;
			}
			set
			{
				m_HorizontalScrollerVisibility = (value ? ScrollerVisibility.AlwaysVisible : ScrollerVisibility.Auto);
			}
		}

		[Obsolete("showVertical is obsolete. Use verticalScrollerVisibility instead")]
		public bool showVertical
		{
			get
			{
				return verticalScrollerVisibility == ScrollerVisibility.AlwaysVisible;
			}
			set
			{
				m_VerticalScrollerVisibility = (value ? ScrollerVisibility.AlwaysVisible : ScrollerVisibility.Auto);
			}
		}

		internal bool needsHorizontal => (mode != ScrollViewMode.Vertical && horizontalScrollerVisibility == ScrollerVisibility.AlwaysVisible) || (horizontalScrollerVisibility == ScrollerVisibility.Auto && scrollableWidth > 0.001f);

		internal bool needsVertical => (mode != ScrollViewMode.Horizontal && verticalScrollerVisibility == ScrollerVisibility.AlwaysVisible) || (verticalScrollerVisibility == ScrollerVisibility.Auto && scrollableHeight > 0.001f);

		internal bool isVerticalScrollDisplayed => verticalScroller.resolvedStyle.display == DisplayStyle.Flex;

		internal bool isHorizontalScrollDisplayed => horizontalScroller.resolvedStyle.display == DisplayStyle.Flex;

		public Vector2 scrollOffset
		{
			get
			{
				return new Vector2(horizontalScroller.value, verticalScroller.value);
			}
			set
			{
				if (value != scrollOffset)
				{
					horizontalScroller.value = value.x;
					verticalScroller.value = value.y;
					if (base.panel != null)
					{
						UpdateScrollers(needsHorizontal, needsVertical);
						UpdateContentViewTransform();
					}
				}
			}
		}

		public float horizontalPageSize
		{
			get
			{
				return m_HorizontalPageSize;
			}
			set
			{
				m_HorizontalPageSize = value;
				UpdateHorizontalSliderPageSize();
			}
		}

		public float verticalPageSize
		{
			get
			{
				return m_VerticalPageSize;
			}
			set
			{
				m_VerticalPageSize = value;
				UpdateVerticalSliderPageSize();
			}
		}

		public float mouseWheelScrollSize
		{
			get
			{
				return m_MouseWheelScrollSize;
			}
			set
			{
				float num = m_MouseWheelScrollSize;
				if (Math.Abs(m_MouseWheelScrollSize - value) > float.Epsilon)
				{
					m_MouseWheelScrollSizeIsInline = true;
					m_MouseWheelScrollSize = value;
				}
			}
		}

		internal float scrollableWidth => contentContainer.boundingBox.width - contentViewport.layout.width;

		internal float scrollableHeight => contentContainer.boundingBox.height - contentViewport.layout.height;

		private bool hasInertia => scrollDecelerationRate > 0f;

		public float scrollDecelerationRate
		{
			get
			{
				return m_ScrollDecelerationRate;
			}
			set
			{
				m_ScrollDecelerationRate = Mathf.Max(0f, value);
			}
		}

		public float elasticity
		{
			get
			{
				return m_Elasticity;
			}
			set
			{
				m_Elasticity = Mathf.Max(0f, value);
			}
		}

		public TouchScrollBehavior touchScrollBehavior
		{
			get
			{
				return m_TouchScrollBehavior;
			}
			set
			{
				m_TouchScrollBehavior = value;
				if (m_TouchScrollBehavior == TouchScrollBehavior.Clamped)
				{
					horizontalScroller.slider.clamped = true;
					verticalScroller.slider.clamped = true;
				}
				else
				{
					horizontalScroller.slider.clamped = false;
					verticalScroller.slider.clamped = false;
				}
			}
		}

		public NestedInteractionKind nestedInteractionKind
		{
			get
			{
				return m_NestedInteractionKind;
			}
			set
			{
				m_NestedInteractionKind = value;
			}
		}

		public long elasticAnimationIntervalMs
		{
			get
			{
				return m_ElasticAnimationIntervalMs;
			}
			set
			{
				long num = m_ElasticAnimationIntervalMs;
				m_ElasticAnimationIntervalMs = value;
				if (num != m_ElasticAnimationIntervalMs)
				{
					m_PostPointerUpAnimation = base.schedule.Execute(PostPointerUpAnimation).Every(m_ElasticAnimationIntervalMs);
				}
			}
		}

		public VisualElement contentViewport { get; }

		public Scroller horizontalScroller { get; }

		public Scroller verticalScroller { get; }

		public override VisualElement contentContainer => m_ContentContainer;

		public ScrollViewMode mode
		{
			get
			{
				return m_Mode;
			}
			set
			{
				if (m_Mode != value)
				{
					SetScrollViewMode(value);
				}
			}
		}

		private void OnHorizontalScrollDragElementChanged(GeometryChangedEvent evt)
		{
			if (!(evt.oldRect.size == evt.newRect.size))
			{
				UpdateHorizontalSliderPageSize();
			}
		}

		private void OnVerticalScrollDragElementChanged(GeometryChangedEvent evt)
		{
			if (!(evt.oldRect.size == evt.newRect.size))
			{
				UpdateVerticalSliderPageSize();
			}
		}

		private void UpdateHorizontalSliderPageSize()
		{
			float width = horizontalScroller.resolvedStyle.width;
			float num = m_HorizontalPageSize;
			if (width > 0f && Mathf.Approximately(m_HorizontalPageSize, -1f))
			{
				float width2 = horizontalScroller.slider.dragElement.resolvedStyle.width;
				num = width2 * 0.9f;
			}
			if (num >= 0f)
			{
				horizontalScroller.slider.pageSize = num;
			}
		}

		private void UpdateVerticalSliderPageSize()
		{
			float height = verticalScroller.resolvedStyle.height;
			float num = m_VerticalPageSize;
			if (height > 0f && Mathf.Approximately(m_VerticalPageSize, -1f))
			{
				float height2 = verticalScroller.slider.dragElement.resolvedStyle.height;
				num = height2 * 0.9f;
			}
			if (num >= 0f)
			{
				verticalScroller.slider.pageSize = num;
			}
		}

		internal void UpdateContentViewTransform()
		{
			Vector3 position = contentContainer.transform.position;
			Vector2 vector = scrollOffset;
			if (needsVertical)
			{
				vector.y += contentContainer.resolvedStyle.top;
			}
			position.x = GUIUtility.RoundToPixelGrid(0f - vector.x);
			position.y = GUIUtility.RoundToPixelGrid(0f - vector.y);
			contentContainer.transform.position = position;
			IncrementVersion(VersionChangeType.Repaint);
		}

		public void ScrollTo(VisualElement child)
		{
			if (child == null)
			{
				throw new ArgumentNullException("child");
			}
			if (!contentContainer.Contains(child))
			{
				throw new ArgumentException("Cannot scroll to a VisualElement that's not a child of the ScrollView content-container.");
			}
			m_Velocity = Vector2.zero;
			float num = 0f;
			float num2 = 0f;
			if (scrollableHeight > 0f)
			{
				num = GetYDeltaOffset(child);
				verticalScroller.value = scrollOffset.y + num;
			}
			if (scrollableWidth > 0f)
			{
				num2 = GetXDeltaOffset(child);
				horizontalScroller.value = scrollOffset.x + num2;
			}
			if (num != 0f || num2 != 0f)
			{
				UpdateContentViewTransform();
			}
		}

		private float GetXDeltaOffset(VisualElement child)
		{
			float num = contentContainer.transform.position.x * -1f;
			Rect rect = contentViewport.worldBound;
			float num2 = rect.xMin + num;
			float num3 = rect.xMax + num;
			Rect rect2 = child.worldBound;
			float num4 = rect2.xMin + num;
			float num5 = rect2.xMax + num;
			if ((num4 >= num2 && num5 <= num3) || float.IsNaN(num4) || float.IsNaN(num5))
			{
				return 0f;
			}
			float deltaDistance = GetDeltaDistance(num2, num3, num4, num5);
			return deltaDistance * horizontalScroller.highValue / scrollableWidth;
		}

		private float GetYDeltaOffset(VisualElement child)
		{
			float num = contentContainer.transform.position.y * -1f;
			Rect rect = contentViewport.worldBound;
			float num2 = rect.yMin + num;
			float num3 = rect.yMax + num;
			Rect rect2 = child.worldBound;
			float num4 = rect2.yMin + num;
			float num5 = rect2.yMax + num;
			if ((num4 >= num2 && num5 <= num3) || float.IsNaN(num4) || float.IsNaN(num5))
			{
				return 0f;
			}
			float deltaDistance = GetDeltaDistance(num2, num3, num4, num5);
			return deltaDistance * verticalScroller.highValue / scrollableHeight;
		}

		private float GetDeltaDistance(float viewMin, float viewMax, float childBoundaryMin, float childBoundaryMax)
		{
			float num = viewMax - viewMin;
			float num2 = childBoundaryMax - childBoundaryMin;
			if (num2 > num)
			{
				if (viewMin > childBoundaryMin && childBoundaryMax > viewMax)
				{
					return 0f;
				}
				return (childBoundaryMin > viewMin) ? (childBoundaryMin - viewMin) : (childBoundaryMax - viewMax);
			}
			float num3 = childBoundaryMax - viewMax;
			if (num3 < -1f)
			{
				num3 = childBoundaryMin - viewMin;
			}
			return num3;
		}

		public ScrollView()
			: this(ScrollViewMode.Vertical)
		{
		}

		public ScrollView(ScrollViewMode scrollViewMode)
		{
			AddToClassList(ussClassName);
			m_ContentAndVerticalScrollContainer = new VisualElement
			{
				name = "unity-content-and-vertical-scroll-container"
			};
			m_ContentAndVerticalScrollContainer.AddToClassList(contentAndVerticalScrollUssClassName);
			base.hierarchy.Add(m_ContentAndVerticalScrollContainer);
			contentViewport = new VisualElement
			{
				name = "unity-content-viewport"
			};
			contentViewport.AddToClassList(viewportUssClassName);
			contentViewport.RegisterCallback<GeometryChangedEvent>(OnGeometryChanged);
			contentViewport.pickingMode = PickingMode.Ignore;
			m_ContentAndVerticalScrollContainer.RegisterCallback<AttachToPanelEvent>(OnAttachToPanel);
			m_ContentAndVerticalScrollContainer.RegisterCallback<DetachFromPanelEvent>(OnDetachFromPanel);
			m_ContentAndVerticalScrollContainer.Add(contentViewport);
			m_ContentContainer = new VisualElement
			{
				name = "unity-content-container"
			};
			m_ContentContainer.disableClipping = true;
			m_ContentContainer.RegisterCallback<GeometryChangedEvent>(OnGeometryChanged);
			m_ContentContainer.AddToClassList(contentUssClassName);
			m_ContentContainer.usageHints = UsageHints.GroupTransform;
			contentViewport.Add(m_ContentContainer);
			SetScrollViewMode(scrollViewMode);
			horizontalScroller = new Scroller(0f, 2.1474836E+09f, delegate(float value)
			{
				scrollOffset = new Vector2(value, scrollOffset.y);
				UpdateContentViewTransform();
			}, SliderDirection.Horizontal)
			{
				viewDataKey = "HorizontalScroller"
			};
			horizontalScroller.AddToClassList(hScrollerUssClassName);
			horizontalScroller.style.display = DisplayStyle.None;
			base.hierarchy.Add(horizontalScroller);
			verticalScroller = new Scroller(0f, 2.1474836E+09f, delegate(float value)
			{
				scrollOffset = new Vector2(scrollOffset.x, value);
				UpdateContentViewTransform();
			})
			{
				viewDataKey = "VerticalScroller"
			};
			horizontalScroller.slider.clampedDragger.draggingEnded += UpdateElasticBehaviour;
			verticalScroller.slider.clampedDragger.draggingEnded += UpdateElasticBehaviour;
			horizontalScroller.lowButton.AddAction(UpdateElasticBehaviour);
			horizontalScroller.highButton.AddAction(UpdateElasticBehaviour);
			verticalScroller.lowButton.AddAction(UpdateElasticBehaviour);
			verticalScroller.highButton.AddAction(UpdateElasticBehaviour);
			verticalScroller.AddToClassList(vScrollerUssClassName);
			verticalScroller.style.display = DisplayStyle.None;
			m_ContentAndVerticalScrollContainer.Add(verticalScroller);
			touchScrollBehavior = TouchScrollBehavior.Clamped;
			RegisterCallback<WheelEvent>(OnScrollWheel);
			verticalScroller.RegisterCallback<GeometryChangedEvent>(OnScrollersGeometryChanged);
			horizontalScroller.RegisterCallback<GeometryChangedEvent>(OnScrollersGeometryChanged);
			horizontalPageSize = -1f;
			verticalPageSize = -1f;
			horizontalScroller.slider.dragElement.RegisterCallback<GeometryChangedEvent>(OnHorizontalScrollDragElementChanged);
			verticalScroller.slider.dragElement.RegisterCallback<GeometryChangedEvent>(OnVerticalScrollDragElementChanged);
			m_CapturedTargetPointerMoveCallback = OnPointerMove;
			m_CapturedTargetPointerUpCallback = OnPointerUp;
			scrollOffset = Vector2.zero;
		}

		private void SetScrollViewMode(ScrollViewMode mode)
		{
			m_Mode = mode;
			RemoveFromClassList(verticalVariantUssClassName);
			RemoveFromClassList(horizontalVariantUssClassName);
			RemoveFromClassList(verticalHorizontalVariantUssClassName);
			RemoveFromClassList(scrollVariantUssClassName);
			contentContainer.RemoveFromClassList(verticalVariantContentUssClassName);
			contentContainer.RemoveFromClassList(horizontalVariantContentUssClassName);
			contentContainer.RemoveFromClassList(verticalHorizontalVariantContentUssClassName);
			contentViewport.RemoveFromClassList(verticalVariantViewportUssClassName);
			contentViewport.RemoveFromClassList(horizontalVariantViewportUssClassName);
			contentViewport.RemoveFromClassList(verticalHorizontalVariantViewportUssClassName);
			switch (mode)
			{
			case ScrollViewMode.Vertical:
				AddToClassList(scrollVariantUssClassName);
				AddToClassList(verticalVariantUssClassName);
				contentViewport.AddToClassList(verticalVariantViewportUssClassName);
				contentContainer.AddToClassList(verticalVariantContentUssClassName);
				break;
			case ScrollViewMode.Horizontal:
				AddToClassList(scrollVariantUssClassName);
				AddToClassList(horizontalVariantUssClassName);
				contentViewport.AddToClassList(horizontalVariantViewportUssClassName);
				contentContainer.AddToClassList(horizontalVariantContentUssClassName);
				break;
			case ScrollViewMode.VerticalAndHorizontal:
				AddToClassList(scrollVariantUssClassName);
				AddToClassList(verticalHorizontalVariantUssClassName);
				contentViewport.AddToClassList(verticalHorizontalVariantViewportUssClassName);
				contentContainer.AddToClassList(verticalHorizontalVariantContentUssClassName);
				break;
			}
		}

		private void OnAttachToPanel(AttachToPanelEvent evt)
		{
			if (evt.destinationPanel != null)
			{
				m_AttachedRootVisualContainer = GetRootVisualContainer();
				m_AttachedRootVisualContainer?.RegisterCallback<CustomStyleResolvedEvent>(OnRootCustomStyleResolved);
				ReadSingleLineHeight();
				if (evt.destinationPanel.contextType == ContextType.Player)
				{
					m_ContentAndVerticalScrollContainer.RegisterCallback<PointerMoveEvent>(OnPointerMove);
					contentContainer.RegisterCallback<PointerDownEvent>(OnPointerDown, TrickleDown.TrickleDown);
					contentContainer.RegisterCallback<PointerCancelEvent>(OnPointerCancel);
					contentContainer.RegisterCallback<PointerUpEvent>(OnPointerUp, TrickleDown.TrickleDown);
					contentContainer.RegisterCallback<PointerCaptureEvent>(OnPointerCapture);
					contentContainer.RegisterCallback<PointerCaptureOutEvent>(OnPointerCaptureOut);
					evt.destinationPanel.visualTree.RegisterCallback<PointerUpEvent>(OnRootPointerUp, TrickleDown.TrickleDown);
				}
			}
		}

		private void OnDetachFromPanel(DetachFromPanelEvent evt)
		{
			m_ScheduledLayoutPassResetItem?.Pause();
			ResetLayoutPass();
			if (evt.originPanel != null)
			{
				m_AttachedRootVisualContainer?.UnregisterCallback<CustomStyleResolvedEvent>(OnRootCustomStyleResolved);
				m_AttachedRootVisualContainer = null;
				if (evt.originPanel.contextType == ContextType.Player)
				{
					m_ContentAndVerticalScrollContainer.UnregisterCallback<PointerMoveEvent>(OnPointerMove);
					contentContainer.UnregisterCallback<PointerDownEvent>(OnPointerDown, TrickleDown.TrickleDown);
					contentContainer.UnregisterCallback<PointerCancelEvent>(OnPointerCancel);
					contentContainer.UnregisterCallback<PointerUpEvent>(OnPointerUp, TrickleDown.TrickleDown);
					contentContainer.UnregisterCallback<PointerCaptureEvent>(OnPointerCapture);
					contentContainer.UnregisterCallback<PointerCaptureOutEvent>(OnPointerCaptureOut);
					evt.originPanel.visualTree.UnregisterCallback<PointerUpEvent>(OnRootPointerUp, TrickleDown.TrickleDown);
				}
			}
		}

		private void OnPointerCapture(PointerCaptureEvent evt)
		{
			m_CapturedTarget = evt.target as VisualElement;
			if (m_CapturedTarget != null)
			{
				m_TouchPointerMoveAllowed = true;
				m_CapturedTarget.RegisterCallback(m_CapturedTargetPointerMoveCallback);
				m_CapturedTarget.RegisterCallback(m_CapturedTargetPointerUpCallback);
			}
		}

		private void OnPointerCaptureOut(PointerCaptureOutEvent evt)
		{
			ReleaseScrolling(evt.pointerId, evt.target);
			if (m_CapturedTarget != null)
			{
				m_CapturedTarget.UnregisterCallback(m_CapturedTargetPointerMoveCallback);
				m_CapturedTarget.UnregisterCallback(m_CapturedTargetPointerUpCallback);
				m_CapturedTarget = null;
			}
		}

		private void OnGeometryChanged(GeometryChangedEvent evt)
		{
			if (!(evt.oldRect.size == evt.newRect.size))
			{
				bool flag = needsVertical;
				bool flag2 = needsHorizontal;
				if (m_FirstLayoutPass == -1)
				{
					m_FirstLayoutPass = evt.layoutPass;
				}
				else if (evt.layoutPass - m_FirstLayoutPass > 5)
				{
					flag = flag || isVerticalScrollDisplayed;
					flag2 = flag2 || isHorizontalScrollDisplayed;
				}
				UpdateScrollers(flag2, flag);
				UpdateContentViewTransform();
				ScheduleResetLayoutPass();
			}
		}

		private void ScheduleResetLayoutPass()
		{
			if (m_ScheduledLayoutPassResetItem == null)
			{
				m_ScheduledLayoutPassResetItem = base.schedule.Execute(ResetLayoutPass);
				return;
			}
			m_ScheduledLayoutPassResetItem.Pause();
			m_ScheduledLayoutPassResetItem.Resume();
		}

		private void ResetLayoutPass()
		{
			m_FirstLayoutPass = -1;
		}

		private static float ComputeElasticOffset(float deltaPointer, float initialScrollOffset, float lowLimit, float hardLowLimit, float highLimit, float hardHighLimit)
		{
			initialScrollOffset = Mathf.Max(initialScrollOffset, hardLowLimit * 0.95f);
			initialScrollOffset = Mathf.Min(initialScrollOffset, hardHighLimit * 0.95f);
			float num3;
			float num;
			if (initialScrollOffset < lowLimit && hardLowLimit < lowLimit)
			{
				num = lowLimit - hardLowLimit;
				float num2 = (lowLimit - initialScrollOffset) / num;
				num3 = num2 * num / (1f - num2);
				num3 += deltaPointer;
				initialScrollOffset = lowLimit;
			}
			else if (initialScrollOffset > highLimit && hardHighLimit > highLimit)
			{
				num = hardHighLimit - highLimit;
				float num4 = (initialScrollOffset - highLimit) / num;
				num3 = -1f * num4 * num / (1f - num4);
				num3 += deltaPointer;
				initialScrollOffset = highLimit;
			}
			else
			{
				num3 = deltaPointer;
			}
			float num5 = initialScrollOffset - num3;
			float num6;
			if (num5 < lowLimit)
			{
				num3 = lowLimit - num5;
				initialScrollOffset = lowLimit;
				num = lowLimit - hardLowLimit;
				num6 = 1f;
			}
			else
			{
				if (num5 <= highLimit)
				{
					return num5;
				}
				num3 = num5 - highLimit;
				initialScrollOffset = highLimit;
				num = hardHighLimit - highLimit;
				num6 = -1f;
			}
			if (Mathf.Abs(num3) < 1E-30f)
			{
				return initialScrollOffset;
			}
			float num7 = num3 / (num3 + num);
			num7 *= num;
			num7 *= num6;
			return initialScrollOffset - num7;
		}

		private void ComputeInitialSpringBackVelocity()
		{
			if (touchScrollBehavior != TouchScrollBehavior.Elastic)
			{
				m_SpringBackVelocity = Vector2.zero;
				return;
			}
			if (scrollOffset.x < m_LowBounds.x)
			{
				m_SpringBackVelocity.x = m_LowBounds.x - scrollOffset.x;
			}
			else if (scrollOffset.x > m_HighBounds.x)
			{
				m_SpringBackVelocity.x = m_HighBounds.x - scrollOffset.x;
			}
			else
			{
				m_SpringBackVelocity.x = 0f;
			}
			if (scrollOffset.y < m_LowBounds.y)
			{
				m_SpringBackVelocity.y = m_LowBounds.y - scrollOffset.y;
			}
			else if (scrollOffset.y > m_HighBounds.y)
			{
				m_SpringBackVelocity.y = m_HighBounds.y - scrollOffset.y;
			}
			else
			{
				m_SpringBackVelocity.y = 0f;
			}
		}

		private void SpringBack()
		{
			if (touchScrollBehavior != TouchScrollBehavior.Elastic)
			{
				m_SpringBackVelocity = Vector2.zero;
				return;
			}
			Vector2 vector = scrollOffset;
			if (vector.x < m_LowBounds.x)
			{
				vector.x = Mathf.SmoothDamp(vector.x, m_LowBounds.x, ref m_SpringBackVelocity.x, elasticity, float.PositiveInfinity, elapsedTimeSinceLastHorizontalTouchScroll);
				if (Mathf.Abs(m_SpringBackVelocity.x) < base.scaledPixelsPerPoint)
				{
					m_SpringBackVelocity.x = 0f;
				}
			}
			else if (vector.x > m_HighBounds.x)
			{
				vector.x = Mathf.SmoothDamp(vector.x, m_HighBounds.x, ref m_SpringBackVelocity.x, elasticity, float.PositiveInfinity, elapsedTimeSinceLastHorizontalTouchScroll);
				if (Mathf.Abs(m_SpringBackVelocity.x) < base.scaledPixelsPerPoint)
				{
					m_SpringBackVelocity.x = 0f;
				}
			}
			else
			{
				m_SpringBackVelocity.x = 0f;
			}
			if (vector.y < m_LowBounds.y)
			{
				vector.y = Mathf.SmoothDamp(vector.y, m_LowBounds.y, ref m_SpringBackVelocity.y, elasticity, float.PositiveInfinity, elapsedTimeSinceLastVerticalTouchScroll);
				if (Mathf.Abs(m_SpringBackVelocity.y) < base.scaledPixelsPerPoint)
				{
					m_SpringBackVelocity.y = 0f;
				}
			}
			else if (vector.y > m_HighBounds.y)
			{
				vector.y = Mathf.SmoothDamp(vector.y, m_HighBounds.y, ref m_SpringBackVelocity.y, elasticity, float.PositiveInfinity, elapsedTimeSinceLastVerticalTouchScroll);
				if (Mathf.Abs(m_SpringBackVelocity.y) < base.scaledPixelsPerPoint)
				{
					m_SpringBackVelocity.y = 0f;
				}
			}
			else
			{
				m_SpringBackVelocity.y = 0f;
			}
			scrollOffset = vector;
		}

		internal void ApplyScrollInertia()
		{
			if (hasInertia && m_Velocity != Vector2.zero)
			{
				Vector2 zero = Vector2.zero;
				float num = 0f;
				while (num < elapsedTimeSinceLastVerticalTouchScroll)
				{
					m_Velocity *= Mathf.Pow(scrollDecelerationRate, k_TouchScrollInertiaBaseTimeInterval);
					num += k_TouchScrollInertiaBaseTimeInterval;
					zero += m_Velocity * k_TouchScrollInertiaBaseTimeInterval;
				}
				float num2 = elapsedTimeSinceLastVerticalTouchScroll - num;
				if (num2 > 0f && num2 < k_TouchScrollInertiaBaseTimeInterval)
				{
					m_Velocity *= Mathf.Pow(scrollDecelerationRate, num2);
					zero += m_Velocity * num2;
				}
				float num3 = base.scaledPixelsPerPoint * k_ScaledPixelsPerPointMultiplier;
				if (Mathf.Abs(m_Velocity.x) <= num3 || (touchScrollBehavior == TouchScrollBehavior.Elastic && (scrollOffset.x < m_LowBounds.x || scrollOffset.x > m_HighBounds.x)))
				{
					m_Velocity.x = 0f;
				}
				if (Mathf.Abs(m_Velocity.y) <= num3 || (touchScrollBehavior == TouchScrollBehavior.Elastic && (scrollOffset.y < m_LowBounds.y || scrollOffset.y > m_HighBounds.y)))
				{
					m_Velocity.y = 0f;
				}
				scrollOffset += zero;
			}
			else
			{
				m_Velocity = Vector2.zero;
			}
		}

		private void PostPointerUpAnimation()
		{
			elapsedTimeSinceLastVerticalTouchScroll = Time.unscaledTime - previousVerticalTouchScrollTimeStamp;
			previousVerticalTouchScrollTimeStamp = Time.unscaledTime;
			elapsedTimeSinceLastHorizontalTouchScroll = Time.unscaledTime - previousHorizontalTouchScrollTimeStamp;
			previousHorizontalTouchScrollTimeStamp = Time.unscaledTime;
			ApplyScrollInertia();
			SpringBack();
			if (m_SpringBackVelocity == Vector2.zero && m_Velocity == Vector2.zero)
			{
				m_PostPointerUpAnimation.Pause();
				elapsedTimeSinceLastVerticalTouchScroll = 0f;
				elapsedTimeSinceLastHorizontalTouchScroll = 0f;
				previousVerticalTouchScrollTimeStamp = 0f;
				previousHorizontalTouchScrollTimeStamp = 0f;
			}
		}

		private void OnPointerDown(PointerDownEvent evt)
		{
			if (!(evt.pointerType == PointerType.mouse) && evt.isPrimary)
			{
				if (evt.pointerId != PointerId.invalidPointerId)
				{
					ReleaseScrolling(evt.pointerId, evt.target);
				}
				m_PostPointerUpAnimation?.Pause();
				bool flag = Mathf.Abs(m_Velocity.x) > 10f || Mathf.Abs(m_Velocity.y) > 10f;
				m_TouchPointerMoveAllowed = true;
				m_StartedMoving = false;
				InitTouchScrolling(evt.position);
				if (flag)
				{
					contentContainer.CapturePointer(evt.pointerId);
					contentContainer.panel.PreventCompatibilityMouseEvents(evt.pointerId);
					evt.StopPropagation();
					m_TouchStoppedVelocity = true;
				}
			}
		}

		private void OnPointerMove(PointerMoveEvent evt)
		{
			if (evt.pointerType == PointerType.mouse || !evt.isPrimary || !m_TouchPointerMoveAllowed)
			{
				return;
			}
			if (evt.isHandledByDraggable)
			{
				m_PointerStartPosition = evt.position;
				m_StartPosition = scrollOffset;
				return;
			}
			Vector2 vector = evt.position;
			Vector2 vector2 = vector - m_PointerStartPosition;
			if (mode == ScrollViewMode.Horizontal)
			{
				vector2.y = 0f;
			}
			else if (mode == ScrollViewMode.Vertical)
			{
				vector2.x = 0f;
			}
			if (!m_TouchStoppedVelocity && !m_StartedMoving && vector2.sqrMagnitude < 100f)
			{
				return;
			}
			TouchScrollingResult touchScrollingResult = ComputeTouchScrolling(evt.position);
			if (touchScrollingResult != TouchScrollingResult.Forward)
			{
				evt.isHandledByDraggable = true;
				evt.StopPropagation();
				if (!contentContainer.HasPointerCapture(evt.pointerId))
				{
					contentContainer.CapturePointer(evt.pointerId);
				}
			}
			else
			{
				m_Velocity = Vector2.zero;
			}
		}

		private void OnPointerCancel(PointerCancelEvent evt)
		{
			ReleaseScrolling(evt.pointerId, evt.target);
		}

		private void OnPointerUp(PointerUpEvent evt)
		{
			if (ReleaseScrolling(evt.pointerId, evt.target))
			{
				contentContainer.panel.PreventCompatibilityMouseEvents(evt.pointerId);
				evt.StopPropagation();
			}
		}

		internal void InitTouchScrolling(Vector2 position)
		{
			m_PointerStartPosition = position;
			m_StartPosition = scrollOffset;
			m_Velocity = Vector2.zero;
			m_SpringBackVelocity = Vector2.zero;
			m_LowBounds = new Vector2(Mathf.Min(horizontalScroller.lowValue, horizontalScroller.highValue), Mathf.Min(verticalScroller.lowValue, verticalScroller.highValue));
			m_HighBounds = new Vector2(Mathf.Max(horizontalScroller.lowValue, horizontalScroller.highValue), Mathf.Max(verticalScroller.lowValue, verticalScroller.highValue));
		}

		internal TouchScrollingResult ComputeTouchScrolling(Vector2 position)
		{
			Vector2 lhs = default(Vector2);
			if (touchScrollBehavior == TouchScrollBehavior.Clamped)
			{
				lhs = m_StartPosition - (position - m_PointerStartPosition);
				lhs = Vector2.Max(lhs, m_LowBounds);
				lhs = Vector2.Min(lhs, m_HighBounds);
			}
			else if (touchScrollBehavior == TouchScrollBehavior.Elastic)
			{
				Vector2 vector = position - m_PointerStartPosition;
				lhs.x = ComputeElasticOffset(vector.x, m_StartPosition.x, m_LowBounds.x, m_LowBounds.x - contentViewport.resolvedStyle.width, m_HighBounds.x, m_HighBounds.x + contentViewport.resolvedStyle.width);
				lhs.y = ComputeElasticOffset(vector.y, m_StartPosition.y, m_LowBounds.y, m_LowBounds.y - contentViewport.resolvedStyle.height, m_HighBounds.y, m_HighBounds.y + contentViewport.resolvedStyle.height);
				previousVerticalTouchScrollTimeStamp = Time.unscaledTime;
				previousHorizontalTouchScrollTimeStamp = Time.unscaledTime;
			}
			else
			{
				lhs = m_StartPosition - (position - m_PointerStartPosition);
			}
			if (mode == ScrollViewMode.Vertical)
			{
				lhs.x = m_LowBounds.x;
			}
			else if (mode == ScrollViewMode.Horizontal)
			{
				lhs.y = m_LowBounds.y;
			}
			if (scrollOffset != lhs)
			{
				return (!ApplyTouchScrolling(lhs)) ? TouchScrollingResult.Forward : TouchScrollingResult.Apply;
			}
			return (!m_StartedMoving || nestedInteractionKind == NestedInteractionKind.ForwardScrolling) ? TouchScrollingResult.Forward : TouchScrollingResult.Block;
		}

		private bool ApplyTouchScrolling(Vector2 newScrollOffset)
		{
			m_StartedMoving = true;
			if (hasInertia)
			{
				if (newScrollOffset == m_LowBounds || newScrollOffset == m_HighBounds)
				{
					m_Velocity = Vector2.zero;
					scrollOffset = newScrollOffset;
					return false;
				}
				if (m_LastVelocityLerpTime > 0f)
				{
					float num = Time.unscaledTime - m_LastVelocityLerpTime;
					m_Velocity = Vector2.Lerp(m_Velocity, Vector2.zero, num * 10f);
				}
				m_LastVelocityLerpTime = Time.unscaledTime;
				float num2 = k_TouchScrollInertiaBaseTimeInterval;
				Vector2 b = (newScrollOffset - scrollOffset) / num2;
				m_Velocity = Vector2.Lerp(m_Velocity, b, num2 * 10f);
			}
			bool result = scrollOffset != newScrollOffset;
			scrollOffset = newScrollOffset;
			return result;
		}

		private bool ReleaseScrolling(int pointerId, IEventHandler target)
		{
			m_TouchStoppedVelocity = false;
			m_StartedMoving = false;
			m_TouchPointerMoveAllowed = false;
			if (target != contentContainer || !contentContainer.HasPointerCapture(pointerId))
			{
				return false;
			}
			previousVerticalTouchScrollTimeStamp = Time.unscaledTime;
			previousHorizontalTouchScrollTimeStamp = Time.unscaledTime;
			if (touchScrollBehavior == TouchScrollBehavior.Elastic || hasInertia)
			{
				ExecuteElasticSpringAnimation();
			}
			contentContainer.ReleasePointer(pointerId);
			return true;
		}

		private void ExecuteElasticSpringAnimation()
		{
			ComputeInitialSpringBackVelocity();
			if (m_PostPointerUpAnimation == null)
			{
				m_PostPointerUpAnimation = base.schedule.Execute(PostPointerUpAnimation).Every(m_ElasticAnimationIntervalMs);
				return;
			}
			m_PostPointerUpAnimation.Pause();
			m_PostPointerUpAnimation.Resume();
		}

		private void AdjustScrollers()
		{
			float factor = ((contentContainer.boundingBox.width > 1E-30f) ? (contentViewport.layout.width / contentContainer.boundingBox.width) : 1f);
			float factor2 = ((contentContainer.boundingBox.height > 1E-30f) ? (contentViewport.layout.height / contentContainer.boundingBox.height) : 1f);
			horizontalScroller.Adjust(factor);
			verticalScroller.Adjust(factor2);
		}

		internal void UpdateScrollers(bool displayHorizontal, bool displayVertical)
		{
			AdjustScrollers();
			horizontalScroller.SetEnabled(contentContainer.boundingBox.width - contentViewport.layout.width > 0f);
			verticalScroller.SetEnabled(contentContainer.boundingBox.height - contentViewport.layout.height > 0f);
			bool flag = displayHorizontal && m_HorizontalScrollerVisibility != ScrollerVisibility.Hidden;
			bool flag2 = displayVertical && m_VerticalScrollerVisibility != ScrollerVisibility.Hidden;
			DisplayStyle displayStyle = ((!flag) ? DisplayStyle.None : DisplayStyle.Flex);
			DisplayStyle displayStyle2 = ((!flag2) ? DisplayStyle.None : DisplayStyle.Flex);
			if (displayStyle != horizontalScroller.style.display)
			{
				horizontalScroller.style.display = displayStyle;
			}
			if (displayStyle2 != verticalScroller.style.display)
			{
				verticalScroller.style.display = displayStyle2;
			}
			verticalScroller.lowValue = 0f;
			verticalScroller.highValue = scrollableHeight;
			horizontalScroller.lowValue = 0f;
			horizontalScroller.highValue = scrollableWidth;
		}

		private void OnScrollersGeometryChanged(GeometryChangedEvent evt)
		{
			if (!(evt.oldRect.size == evt.newRect.size))
			{
				if (needsHorizontal && m_HorizontalScrollerVisibility != ScrollerVisibility.Hidden)
				{
					horizontalScroller.style.marginRight = verticalScroller.layout.width;
				}
				AdjustScrollers();
			}
		}

		private void OnScrollWheel(WheelEvent evt)
		{
			bool flag = false;
			bool flag2 = mode != ScrollViewMode.Horizontal && contentContainer.boundingBox.height - base.layout.height > 0f;
			bool flag3 = mode != ScrollViewMode.Vertical && contentContainer.boundingBox.width - base.layout.width > 0f;
			float num = ((flag3 && !flag2) ? evt.delta.y : evt.delta.x);
			float num2 = (m_MouseWheelScrollSizeIsInline ? mouseWheelScrollSize : m_SingleLineHeight);
			if (flag2)
			{
				float value = verticalScroller.value;
				verticalScroller.value += evt.delta.y * ((verticalScroller.lowValue < verticalScroller.highValue) ? 1f : (-1f)) * num2;
				if (nestedInteractionKind == NestedInteractionKind.StopScrolling || !Mathf.Approximately(verticalScroller.value, value))
				{
					evt.StopPropagation();
					flag = true;
				}
			}
			if (flag3)
			{
				float value2 = horizontalScroller.value;
				horizontalScroller.value += num * ((horizontalScroller.lowValue < horizontalScroller.highValue) ? 1f : (-1f)) * num2;
				if (nestedInteractionKind == NestedInteractionKind.StopScrolling || !Mathf.Approximately(horizontalScroller.value, value2))
				{
					evt.StopPropagation();
					flag = true;
				}
			}
			if (flag)
			{
				UpdateElasticBehaviour();
				UpdateContentViewTransform();
			}
		}

		private void OnRootCustomStyleResolved(CustomStyleResolvedEvent evt)
		{
			ReadSingleLineHeight();
		}

		private void OnRootPointerUp(PointerUpEvent evt)
		{
			m_TouchPointerMoveAllowed = false;
		}

		private void ReadSingleLineHeight()
		{
			if (m_AttachedRootVisualContainer?.computedStyle.customProperties != null && m_AttachedRootVisualContainer.computedStyle.customProperties.TryGetValue("--unity-metrics-single_line-height", out var value))
			{
				if (value.sheet.TryReadDimension(value.handle, out var value2))
				{
					m_SingleLineHeight = value2.value;
				}
			}
			else
			{
				m_SingleLineHeight = UIElementsUtility.singleLineHeight;
			}
		}

		private void UpdateElasticBehaviour()
		{
			if (touchScrollBehavior == TouchScrollBehavior.Elastic)
			{
				m_LowBounds = new Vector2(Mathf.Min(horizontalScroller.lowValue, horizontalScroller.highValue), Mathf.Min(verticalScroller.lowValue, verticalScroller.highValue));
				m_HighBounds = new Vector2(Mathf.Max(horizontalScroller.lowValue, horizontalScroller.highValue), Mathf.Max(verticalScroller.lowValue, verticalScroller.highValue));
				ExecuteElasticSpringAnimation();
			}
		}
	}
	public class Slider : BaseSlider<float>
	{
		public new class UxmlFactory : UxmlFactory<Slider, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseSlider<float>.UxmlTraits
		{
			private UxmlFloatAttributeDescription m_LowValue = new UxmlFloatAttributeDescription
			{
				name = "low-value"
			};

			private UxmlFloatAttributeDescription m_HighValue = new UxmlFloatAttributeDescription
			{
				name = "high-value",
				defaultValue = 10f
			};

			private UxmlFloatAttributeDescription m_PageSize = new UxmlFloatAttributeDescription
			{
				name = "page-size",
				defaultValue = 0f
			};

			private UxmlBoolAttributeDescription m_ShowInputField = new UxmlBoolAttributeDescription
			{
				name = "show-input-field",
				defaultValue = false
			};

			private UxmlEnumAttributeDescription<SliderDirection> m_Direction = new UxmlEnumAttributeDescription<SliderDirection>
			{
				name = "direction",
				defaultValue = SliderDirection.Horizontal
			};

			private UxmlBoolAttributeDescription m_Inverted = new UxmlBoolAttributeDescription
			{
				name = "inverted",
				defaultValue = false
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				Slider slider = (Slider)ve;
				slider.lowValue = m_LowValue.GetValueFromBag(bag, cc);
				slider.highValue = m_HighValue.GetValueFromBag(bag, cc);
				slider.direction = m_Direction.GetValueFromBag(bag, cc);
				slider.pageSize = m_PageSize.GetValueFromBag(bag, cc);
				slider.showInputField = m_ShowInputField.GetValueFromBag(bag, cc);
				slider.inverted = m_Inverted.GetValueFromBag(bag, cc);
				base.Init(ve, bag, cc);
			}
		}

		internal const float kDefaultHighValue = 10f;

		public new static readonly string ussClassName = "unity-slider";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		public Slider()
			: this(null)
		{
		}

		public Slider(float start, float end, SliderDirection direction = SliderDirection.Horizontal, float pageSize = 0f)
			: this(null, start, end, direction, pageSize)
		{
		}

		public Slider(string label, float start = 0f, float end = 10f, SliderDirection direction = SliderDirection.Horizontal, float pageSize = 0f)
			: base(label, start, end, direction, pageSize)
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
		}

		public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, float startValue)
		{
			double num = NumericFieldDraggerUtility.CalculateFloatDragSensitivity(startValue, base.lowValue, base.highValue);
			float acceleration = NumericFieldDraggerUtility.Acceleration(speed == DeltaSpeed.Fast, speed == DeltaSpeed.Slow);
			double num2 = value;
			num2 += (double)NumericFieldDraggerUtility.NiceDelta(delta, acceleration) * num;
			value = (float)num2;
		}

		internal override float SliderLerpUnclamped(float a, float b, float interpolant)
		{
			float num = Mathf.LerpUnclamped(a, b, interpolant);
			float num2 = Mathf.Abs((base.highValue - base.lowValue) / (base.dragContainer.resolvedStyle.width - base.dragElement.resolvedStyle.width));
			int digits = ((num2 == 0f) ? Mathf.Clamp((int)(5.0 - (double)Mathf.Log10(Mathf.Abs(num2))), 0, 15) : Mathf.Clamp(-Mathf.FloorToInt(Mathf.Log10(Mathf.Abs(num2))), 0, 15));
			return (float)Math.Round(num, digits, MidpointRounding.AwayFromZero);
		}

		internal override float SliderNormalizeValue(float currentValue, float lowerValue, float higherValue)
		{
			return (currentValue - lowerValue) / (higherValue - lowerValue);
		}

		internal override float SliderRange()
		{
			return Math.Abs(base.highValue - base.lowValue);
		}

		internal override float ParseStringToValue(string previousValue, string newValue)
		{
			if (UINumericFieldsUtils.TryConvertStringToFloat(newValue, previousValue, out var result))
			{
				return result;
			}
			return 0f;
		}

		internal override void ComputeValueFromKey(SliderKey sliderKey, bool isShift)
		{
			switch (sliderKey)
			{
			case SliderKey.None:
				return;
			case SliderKey.Lowest:
				value = base.lowValue;
				return;
			case SliderKey.Highest:
				value = base.highValue;
				return;
			}
			bool flag = sliderKey == SliderKey.LowerPage || sliderKey == SliderKey.HigherPage;
			float num = BaseSlider<float>.GetClosestPowerOfTen(Mathf.Abs((base.highValue - base.lowValue) * 0.01f));
			if (flag)
			{
				num *= pageSize;
			}
			else if (isShift)
			{
				num *= 10f;
			}
			if (sliderKey == SliderKey.Lower || sliderKey == SliderKey.LowerPage)
			{
				num = 0f - num;
			}
			value = BaseSlider<float>.RoundToMultipleOf(value + num * 0.5001f, Mathf.Abs(num));
		}
	}
	public class SliderInt : BaseSlider<int>
	{
		public new class UxmlFactory : UxmlFactory<SliderInt, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseSlider<int>.UxmlTraits
		{
			private UxmlIntAttributeDescription m_LowValue = new UxmlIntAttributeDescription
			{
				name = "low-value"
			};

			private UxmlIntAttributeDescription m_HighValue = new UxmlIntAttributeDescription
			{
				name = "high-value",
				defaultValue = 10
			};

			private UxmlIntAttributeDescription m_PageSize = new UxmlIntAttributeDescription
			{
				name = "page-size",
				defaultValue = 0
			};

			private UxmlBoolAttributeDescription m_ShowInputField = new UxmlBoolAttributeDescription
			{
				name = "show-input-field",
				defaultValue = false
			};

			private UxmlEnumAttributeDescription<SliderDirection> m_Direction = new UxmlEnumAttributeDescription<SliderDirection>
			{
				name = "direction",
				defaultValue = SliderDirection.Horizontal
			};

			private UxmlBoolAttributeDescription m_Inverted = new UxmlBoolAttributeDescription
			{
				name = "inverted",
				defaultValue = false
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				SliderInt sliderInt = (SliderInt)ve;
				sliderInt.lowValue = m_LowValue.GetValueFromBag(bag, cc);
				sliderInt.highValue = m_HighValue.GetValueFromBag(bag, cc);
				sliderInt.direction = m_Direction.GetValueFromBag(bag, cc);
				sliderInt.pageSize = m_PageSize.GetValueFromBag(bag, cc);
				sliderInt.showInputField = m_ShowInputField.GetValueFromBag(bag, cc);
				sliderInt.inverted = m_Inverted.GetValueFromBag(bag, cc);
				base.Init(ve, bag, cc);
			}
		}

		internal const int kDefaultHighValue = 10;

		public new static readonly string ussClassName = "unity-slider-int";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		public override float pageSize
		{
			get
			{
				return base.pageSize;
			}
			set
			{
				base.pageSize = Mathf.RoundToInt(value);
			}
		}

		public SliderInt()
			: this(null)
		{
		}

		public SliderInt(int start, int end, SliderDirection direction = SliderDirection.Horizontal, float pageSize = 0f)
			: this(null, start, end, direction, pageSize)
		{
		}

		public SliderInt(string label, int start = 0, int end = 10, SliderDirection direction = SliderDirection.Horizontal, float pageSize = 0f)
			: base(label, start, end, direction, pageSize)
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
		}

		public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, int startValue)
		{
			double num = NumericFieldDraggerUtility.CalculateIntDragSensitivity(startValue, base.lowValue, base.highValue);
			float acceleration = NumericFieldDraggerUtility.Acceleration(speed == DeltaSpeed.Fast, speed == DeltaSpeed.Slow);
			long num2 = value;
			num2 += (long)Math.Round((double)NumericFieldDraggerUtility.NiceDelta(delta, acceleration) * num);
			value = (int)num2;
		}

		internal override int SliderLerpUnclamped(int a, int b, float interpolant)
		{
			return Mathf.RoundToInt(Mathf.LerpUnclamped(a, b, interpolant));
		}

		internal override float SliderNormalizeValue(int currentValue, int lowerValue, int higherValue)
		{
			return ((float)currentValue - (float)lowerValue) / ((float)higherValue - (float)lowerValue);
		}

		internal override int SliderRange()
		{
			return Math.Abs(base.highValue - base.lowValue);
		}

		internal override int ParseStringToValue(string previousValue, string newValue)
		{
			if (UINumericFieldsUtils.TryConvertStringToInt(newValue, previousValue, out var result))
			{
				return result;
			}
			return 0;
		}

		internal override void ComputeValueAndDirectionFromClick(float sliderLength, float dragElementLength, float dragElementPos, float dragElementLastPos)
		{
			if (Mathf.Approximately(pageSize, 0f))
			{
				base.ComputeValueAndDirectionFromClick(sliderLength, dragElementLength, dragElementPos, dragElementLastPos);
				return;
			}
			float f = sliderLength - dragElementLength;
			if (!(Mathf.Abs(f) < 1E-30f))
			{
				int num = (int)pageSize;
				if ((base.lowValue > base.highValue && !base.inverted) || (base.lowValue < base.highValue && base.inverted) || (base.direction == SliderDirection.Vertical && !base.inverted))
				{
					num = -num;
				}
				bool flag = dragElementLastPos < dragElementPos;
				bool flag2 = dragElementLastPos > dragElementPos + dragElementLength;
				bool flag3 = (base.inverted ? flag2 : flag);
				bool flag4 = (base.inverted ? flag : flag2);
				if (flag3 && base.clampedDragger.dragDirection != ClampedDragger<int>.DragDirection.LowToHigh)
				{
					base.clampedDragger.dragDirection = ClampedDragger<int>.DragDirection.HighToLow;
					value -= num;
				}
				else if (flag4 && base.clampedDragger.dragDirection != ClampedDragger<int>.DragDirection.HighToLow)
				{
					base.clampedDragger.dragDirection = ClampedDragger<int>.DragDirection.LowToHigh;
					value += num;
				}
			}
		}

		internal override void ComputeValueFromKey(SliderKey sliderKey, bool isShift)
		{
			switch (sliderKey)
			{
			case SliderKey.None:
				return;
			case SliderKey.Lowest:
				value = base.lowValue;
				return;
			case SliderKey.Highest:
				value = base.highValue;
				return;
			}
			bool flag = sliderKey == SliderKey.LowerPage || sliderKey == SliderKey.HigherPage;
			float num = BaseSlider<int>.GetClosestPowerOfTen(Mathf.Abs((float)(base.highValue - base.lowValue) * 0.01f));
			if (num < 1f)
			{
				num = 1f;
			}
			if (flag)
			{
				num *= pageSize;
			}
			else if (isShift)
			{
				num *= 10f;
			}
			if (sliderKey == SliderKey.Lower || sliderKey == SliderKey.LowerPage)
			{
				num = 0f - num;
			}
			value = Mathf.RoundToInt(BaseSlider<int>.RoundToMultipleOf((float)value + num * 0.5001f, Mathf.Abs(num)));
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public enum DeltaSpeed
	{
		Fast,
		Normal,
		Slow
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public interface IValueField<T>
	{
		T value { get; set; }

		void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, T startValue);

		void StartDragging();

		void StopDragging();
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public abstract class TextValueField<TValueType> : TextInputBaseField<TValueType>, IValueField<TValueType>
	{
		protected abstract class TextValueInput : TextInputBase
		{
			private TextValueField<TValueType> textValueFieldParent => (TextValueField<TValueType>)base.parent;

			protected abstract string allowedCharacters { get; }

			public string formatString { get; set; }

			protected TextValueInput()
			{
				base.textEdition.AcceptCharacter = AcceptCharacter;
			}

			internal override bool AcceptCharacter(char c)
			{
				return base.AcceptCharacter(c) && c != 0 && allowedCharacters.IndexOf(c) != -1;
			}

			public abstract void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, TValueType startValue);

			public void StartDragging()
			{
				base.isDragging = true;
				SelectNone();
				MarkDirtyRepaint();
			}

			public void StopDragging()
			{
				if (textValueFieldParent.isDelayed)
				{
					UpdateValueFromText();
				}
				base.isDragging = false;
				SelectAll();
				MarkDirtyRepaint();
			}

			protected abstract string ValueToString(TValueType value);

			protected override TValueType StringToValue(string str)
			{
				return base.StringToValue(str);
			}
		}

		private BaseFieldMouseDragger m_Dragger;

		internal bool m_UpdateTextFromValue;

		private bool m_ForceUpdateDisplay;

		internal const int kMaxValueFieldLength = 1000;

		private TextValueInput textValueInput => (TextValueInput)base.textInputBase;

		public string formatString
		{
			get
			{
				return textValueInput.formatString;
			}
			set
			{
				if (textValueInput.formatString != value)
				{
					textValueInput.formatString = value;
					base.textEdition.UpdateText(ValueToString(base.rawValue));
				}
			}
		}

		public override TValueType value
		{
			get
			{
				return base.value;
			}
			set
			{
				base.value = value;
			}
		}

		protected TextValueField(int maxLength, TextValueInput textValueInput)
			: this((string)null, maxLength, textValueInput)
		{
		}

		protected TextValueField(string label, int maxLength, TextValueInput textValueInput)
			: base(label, maxLength, '\0', (TextInputBase)textValueInput)
		{
			m_UpdateTextFromValue = true;
			base.textEdition.UpdateText(ValueToString(base.rawValue));
			base.onIsReadOnlyChanged += OnIsReadOnlyChanged;
		}

		public abstract void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, TValueType startValue);

		public void StartDragging()
		{
			if (base.showMixedValue)
			{
				value = default(TValueType);
			}
			textValueInput.StartDragging();
		}

		public void StopDragging()
		{
			textValueInput.StopDragging();
		}

		internal override void UpdateValueFromText()
		{
			m_UpdateTextFromValue = false;
			try
			{
				value = StringToValue(base.text);
			}
			finally
			{
				m_UpdateTextFromValue = true;
			}
		}

		internal override void UpdateTextFromValue()
		{
			base.text = ValueToString(base.rawValue);
		}

		private void OnIsReadOnlyChanged(bool newValue)
		{
			EnableLabelDragger(!newValue);
		}

		internal virtual bool CanTryParse(string textString)
		{
			return false;
		}

		protected void AddLabelDragger<TDraggerType>()
		{
			m_Dragger = new FieldMouseDragger<TDraggerType>((IValueField<TDraggerType>)this);
			EnableLabelDragger(!base.isReadOnly);
		}

		private void EnableLabelDragger(bool enable)
		{
			if (m_Dragger != null)
			{
				m_Dragger.SetDragZone(enable ? base.labelElement : null);
				base.labelElement.EnableInClassList(BaseField<TValueType>.labelDraggerVariantUssClassName, enable);
			}
		}

		public override void SetValueWithoutNotify(TValueType newValue)
		{
			bool flag = m_ForceUpdateDisplay || (m_UpdateTextFromValue && !EqualityComparer<TValueType>.Default.Equals(base.rawValue, newValue));
			base.SetValueWithoutNotify(newValue);
			if (flag)
			{
				base.textEdition.UpdateText(ValueToString(base.rawValue));
			}
			m_ForceUpdateDisplay = false;
		}

		[EventInterest(new Type[]
		{
			typeof(BlurEvent),
			typeof(FocusEvent)
		})]
		protected override void ExecuteDefaultAction(EventBase evt)
		{
			base.ExecuteDefaultAction(evt);
			if (evt == null)
			{
				return;
			}
			if (evt.eventTypeId == EventBase<BlurEvent>.TypeId())
			{
				if (base.showMixedValue)
				{
					UpdateMixedValueContent();
					return;
				}
				if (string.IsNullOrEmpty(base.text))
				{
					base.textInputBase.UpdateTextFromValue();
					return;
				}
				base.textInputBase.UpdateValueFromText();
				base.textInputBase.UpdateTextFromValue();
			}
			else if (evt.eventTypeId == EventBase<FocusEvent>.TypeId() && base.showMixedValue)
			{
				base.textInputBase.text = "";
			}
		}

		internal override void OnViewDataReady()
		{
			m_ForceUpdateDisplay = true;
			base.OnViewDataReady();
		}

		internal override void RegisterEditingCallbacks()
		{
			base.RegisterEditingCallbacks();
			base.labelElement.RegisterCallback<PointerDownEvent>(base.StartEditing, TrickleDown.TrickleDown);
			base.labelElement.RegisterCallback<PointerUpEvent>(base.EndEditing);
		}

		internal override void UnregisterEditingCallbacks()
		{
			base.UnregisterEditingCallbacks();
			base.labelElement.UnregisterCallback<PointerDownEvent>(base.StartEditing, TrickleDown.TrickleDown);
			base.labelElement.UnregisterCallback<PointerUpEvent>(base.EndEditing);
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class TextValueFieldTraits<TValueType, TValueUxmlAttributeType> : BaseFieldTraits<TValueType, TValueUxmlAttributeType> where TValueUxmlAttributeType : TypedUxmlAttributeDescription<TValueType>, new()
	{
		private UxmlBoolAttributeDescription m_IsReadOnly = new UxmlBoolAttributeDescription
		{
			name = "readonly"
		};

		private UxmlBoolAttributeDescription m_IsDelayed = new UxmlBoolAttributeDescription
		{
			name = "is-delayed"
		};

		public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
		{
			base.Init(ve, bag, cc);
			TextInputBaseField<TValueType> textInputBaseField = (TextInputBaseField<TValueType>)ve;
			if (textInputBaseField != null)
			{
				textInputBaseField.isReadOnly = m_IsReadOnly.GetValueFromBag(bag, cc);
				textInputBaseField.isDelayed = m_IsDelayed.GetValueFromBag(bag, cc);
			}
		}
	}
	public class Toggle : BaseBoolField
	{
		public new class UxmlFactory : UxmlFactory<Toggle, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseFieldTraits<bool, UxmlBoolAttributeDescription>
		{
			private UxmlStringAttributeDescription m_Text = new UxmlStringAttributeDescription
			{
				name = "text"
			};

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				((Toggle)ve).text = m_Text.GetValueFromBag(bag, cc);
			}
		}

		public new static readonly string ussClassName = "unity-toggle";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		[Obsolete]
		public static readonly string noTextVariantUssClassName = ussClassName + "--no-text";

		public static readonly string checkmarkUssClassName = ussClassName + "__checkmark";

		public static readonly string textUssClassName = ussClassName + "__text";

		public static readonly string mixedValuesUssClassName = ussClassName + "__mixed-values";

		public Toggle()
			: this(null)
		{
		}

		public Toggle(string label)
			: base(label)
		{
			AddToClassList(ussClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			m_CheckMark.AddToClassList(checkmarkUssClassName);
		}

		protected override void InitLabel()
		{
			base.InitLabel();
			m_Label.AddToClassList(textUssClassName);
		}

		protected override void UpdateMixedValueContent()
		{
			if (base.showMixedValue)
			{
				base.visualInput.pseudoStates &= ~PseudoStates.Checked;
				base.pseudoStates &= ~PseudoStates.Checked;
				m_CheckMark.AddToClassList(mixedValuesUssClassName);
				return;
			}
			m_CheckMark.RemoveFromClassList(mixedValuesUssClassName);
			if (value)
			{
				base.visualInput.pseudoStates |= PseudoStates.Checked;
				base.pseudoStates |= PseudoStates.Checked;
			}
			else
			{
				base.visualInput.pseudoStates &= ~PseudoStates.Checked;
				base.pseudoStates &= ~PseudoStates.Checked;
			}
		}
	}
	public class TreeView : BaseTreeView
	{
		public new class UxmlFactory : UxmlFactory<TreeView, UxmlTraits>
		{
		}

		public new class UxmlTraits : BaseTreeView.UxmlTraits
		{
		}

		private Func<VisualElement> m_MakeItem;

		private Action<VisualElement, int> m_BindItem;

		public new Func<VisualElement> makeItem
		{
			get
			{
				return m_MakeItem;
			}
			set
			{
				if (value != m_MakeItem)
				{
					m_MakeItem = value;
					Rebuild();
				}
			}
		}

		public new Action<VisualElement, int> bindItem
		{
			get
			{
				return m_BindItem;
			}
			set
			{
				if (value != m_BindItem)
				{
					m_BindItem = value;
					RefreshItems();
				}
			}
		}

		public new Action<VisualElement, int> unbindItem { get; set; }

		public new Action<VisualElement> destroyItem { get; set; }

		public new TreeViewController viewController => base.viewController as TreeViewController;

		internal override void SetRootItemsInternal<T>(IList<TreeViewItemData<T>> rootItems)
		{
			TreeViewHelpers<T, DefaultTreeViewController<T>>.SetRootItems(this, rootItems, () => new DefaultTreeViewController<T>());
		}

		internal override bool HasValidDataAndBindings()
		{
			return base.HasValidDataAndBindings() && makeItem != null == (bindItem != null);
		}

		protected override CollectionViewController CreateViewController()
		{
			return new DefaultTreeViewController<object>();
		}

		public TreeView()
			: this(null, null)
		{
		}

		public TreeView(Func<VisualElement> makeItem, Action<VisualElement, int> bindItem)
			: base(-1)
		{
			this.makeItem = makeItem;
			this.bindItem = bindItem;
		}

		public TreeView(int itemHeight, Func<VisualElement> makeItem, Action<VisualElement, int> bindItem)
			: this(makeItem, bindItem)
		{
			base.fixedItemHeight = itemHeight;
		}

		private protected override IEnumerable<TreeViewItemData<T>> GetSelectedItemsInternal<T>()
		{
			return TreeViewHelpers<T, DefaultTreeViewController<T>>.GetSelectedItems(this);
		}

		private protected override T GetItemDataForIndexInternal<T>(int index)
		{
			return TreeViewHelpers<T, DefaultTreeViewController<T>>.GetItemDataForIndex(this, index);
		}

		private protected override T GetItemDataForIdInternal<T>(int id)
		{
			return TreeViewHelpers<T, DefaultTreeViewController<T>>.GetItemDataForId(this, id);
		}

		private protected override void AddItemInternal<T>(TreeViewItemData<T> item, int parentId, int childIndex, bool rebuildTree)
		{
			TreeViewHelpers<T, DefaultTreeViewController<T>>.AddItem(this, item, parentId, childIndex, rebuildTree);
		}
	}
	internal static class TreeViewHelpers<T, TDefaultController> where TDefaultController : BaseTreeViewController, IDefaultTreeViewController<T>
	{
		internal static void SetRootItems(BaseTreeView treeView, IList<TreeViewItemData<T>> rootItems, Func<TDefaultController> createController)
		{
			if (treeView.viewController is TDefaultController val)
			{
				val.SetRootItems(rootItems);
				return;
			}
			TDefaultController val2 = createController();
			treeView.SetViewController(val2);
			val2.SetRootItems(rootItems);
		}

		internal static IEnumerable<TreeViewItemData<T>> GetSelectedItems(BaseTreeView treeView)
		{
			BaseTreeViewController viewController = treeView.viewController;
			if (viewController is TDefaultController defaultController)
			{
				foreach (int index in treeView.selectedIndices)
				{
					yield return defaultController.GetTreeViewItemDataForIndex(index);
				}
				yield break;
			}
			if (treeView.viewController?.GetType().GetGenericTypeDefinition() == typeof(TDefaultController).GetGenericTypeDefinition())
			{
				BaseTreeViewController viewController2 = treeView.viewController;
				throw new ArgumentException(string.Format(arg1: (viewController2 != null) ? viewController2.GetType().GetGenericArguments()[0] : null, format: "Type parameter ({0}) differs from data source ({1}) and is not recognized by the controller.", arg0: typeof(T)));
			}
			throw new ArgumentException("GetSelectedItems<T>() only works when using the default controller. Use your controller along with the selectedIndices enumerable instead.");
		}

		internal static T GetItemDataForIndex(BaseTreeView treeView, int index)
		{
			if (treeView.viewController is TDefaultController val)
			{
				return val.GetDataForIndex(index);
			}
			object obj = treeView.viewController?.GetItemForIndex(index);
			Type type = obj?.GetType();
			if (type == typeof(T))
			{
				return (T)obj;
			}
			if (type == null && treeView.viewController?.GetType().GetGenericTypeDefinition() == typeof(TDefaultController).GetGenericTypeDefinition())
			{
				BaseTreeViewController viewController = treeView.viewController;
				type = ((viewController != null) ? viewController.GetType().GetGenericArguments()[0] : null);
			}
			throw new ArgumentException($"Type parameter ({typeof(T)}) differs from data source ({type}) and is not recognized by the controller.");
		}

		internal static T GetItemDataForId(BaseTreeView treeView, int id)
		{
			if (treeView.viewController is TDefaultController val)
			{
				return val.GetDataForId(id);
			}
			object obj = treeView.viewController?.GetItemForIndex(treeView.viewController.GetIndexForId(id));
			Type type = obj?.GetType();
			if (type == typeof(T))
			{
				return (T)obj;
			}
			if (type == null && treeView.viewController?.GetType().GetGenericTypeDefinition() == typeof(TDefaultController).GetGenericTypeDefinition())
			{
				BaseTreeViewController viewController = treeView.viewController;
				type = ((viewController != null) ? viewController.GetType().GetGenericArguments()[0] : null);
			}
			throw new ArgumentException($"Type parameter ({typeof(T)}) differs from data source ({type}) and is not recognized by the controller.");
		}

		internal static void AddItem(BaseTreeView treeView, TreeViewItemData<T> item, int parentId = -1, int childIndex = -1, bool rebuildTree = true)
		{
			if (treeView.viewController is TDefaultController val)
			{
				val.AddItem(in item, parentId, childIndex, rebuildTree);
				if (rebuildTree)
				{
					treeView.RefreshItems();
				}
				return;
			}
			Type arg = null;
			if (treeView.viewController?.GetType().GetGenericTypeDefinition() == typeof(TDefaultController).GetGenericTypeDefinition())
			{
				BaseTreeViewController viewController = treeView.viewController;
				arg = ((viewController != null) ? viewController.GetType().GetGenericArguments()[0] : null);
			}
			throw new ArgumentException($"Type parameter ({typeof(T)}) differs from data source ({arg})and is not recognized by the controller.");
		}
	}
	internal readonly struct TreeData<T>
	{
		private readonly IList<int> m_RootItemIds;

		private readonly Dictionary<int, TreeViewItemData<T>> m_Tree;

		private readonly Dictionary<int, int> m_ParentIds;

		private readonly Dictionary<int, List<int>> m_ChildrenIds;

		public IEnumerable<int> rootItemIds => m_RootItemIds;

		public TreeData(IList<TreeViewItemData<T>> rootItems)
		{
			m_RootItemIds = new List<int>();
			m_Tree = new Dictionary<int, TreeViewItemData<T>>();
			m_ParentIds = new Dictionary<int, int>();
			m_ChildrenIds = new Dictionary<int, List<int>>();
			RefreshTree(rootItems);
		}

		public TreeViewItemData<T> GetDataForId(int id)
		{
			if (m_Tree.TryGetValue(id, out var value))
			{
				return value;
			}
			return default(TreeViewItemData<T>);
		}

		public int GetParentId(int id)
		{
			if (m_ParentIds.TryGetValue(id, out var value))
			{
				return value;
			}
			return -1;
		}

		public void AddItem(TreeViewItemData<T> item, int parentId, int childIndex)
		{
			List<TreeViewItemData<T>> list = CollectionPool<List<TreeViewItemData<T>>, TreeViewItemData<T>>.Get();
			list.Add(item);
			BuildTree(list, isRoot: false);
			AddItemToParent(item, parentId, childIndex);
			CollectionPool<List<TreeViewItemData<T>>, TreeViewItemData<T>>.Release(list);
		}

		public bool TryRemove(int id)
		{
			if (m_ParentIds.TryGetValue(id, out var value))
			{
				RemoveFromParent(id, value);
			}
			else
			{
				m_RootItemIds.Remove(id);
			}
			return TryRemoveChildrenIds(id);
		}

		public void Move(int id, int newParentId, int childIndex)
		{
			if (!m_Tree.TryGetValue(id, out var value))
			{
				return;
			}
			if (m_ParentIds.TryGetValue(id, out var value2))
			{
				if (value2 == newParentId)
				{
					int childIndex2 = m_Tree[value2].GetChildIndex(id);
					if (childIndex2 < childIndex)
					{
						childIndex--;
					}
				}
				RemoveFromParent(value.id, value2);
			}
			else
			{
				int num = m_RootItemIds.IndexOf(id);
				if (newParentId == -1 && num < childIndex)
				{
					childIndex--;
				}
				m_RootItemIds.Remove(id);
			}
			AddItemToParent(value, newParentId, childIndex);
		}

		public bool HasAncestor(int childId, int ancestorId)
		{
			if (childId == -1 || ancestorId == -1)
			{
				return false;
			}
			int id = childId;
			int parentId;
			while ((parentId = GetParentId(id)) != -1)
			{
				if (ancestorId == parentId)
				{
					return true;
				}
				id = parentId;
			}
			return false;
		}

		private void AddItemToParent(TreeViewItemData<T> item, int parentId, int childIndex)
		{
			if (parentId == -1)
			{
				m_ParentIds.Remove(item.id);
				if (childIndex < 0 || childIndex >= m_RootItemIds.Count)
				{
					m_RootItemIds.Add(item.id);
				}
				else
				{
					m_RootItemIds.Insert(childIndex, item.id);
				}
			}
			else
			{
				TreeViewItemData<T> treeViewItemData = m_Tree[parentId];
				treeViewItemData.InsertChild(item, childIndex);
				m_Tree[parentId] = treeViewItemData;
				m_ParentIds[item.id] = parentId;
				UpdateParentTree(treeViewItemData);
			}
		}

		private void RemoveFromParent(int id, int parentId)
		{
			TreeViewItemData<T> treeViewItemData = m_Tree[parentId];
			treeViewItemData.RemoveChild(id);
			m_Tree[parentId] = treeViewItemData;
			if (m_ChildrenIds.TryGetValue(parentId, out var value))
			{
				value.Remove(id);
			}
			UpdateParentTree(treeViewItemData);
		}

		private void UpdateParentTree(TreeViewItemData<T> current)
		{
			int value;
			while (m_ParentIds.TryGetValue(current.id, out value))
			{
				TreeViewItemData<T> treeViewItemData = m_Tree[value];
				treeViewItemData.ReplaceChild(current);
				m_Tree[value] = treeViewItemData;
				current = treeViewItemData;
			}
		}

		private bool TryRemoveChildrenIds(int id)
		{
			if (m_Tree.TryGetValue(id, out var value) && value.children != null)
			{
				foreach (TreeViewItemData<T> child in value.children)
				{
					TryRemoveChildrenIds(child.id);
				}
			}
			if (m_ChildrenIds.TryGetValue(id, out var value2))
			{
				CollectionPool<List<int>, int>.Release(value2);
			}
			bool flag = false;
			flag |= m_RootItemIds.Remove(id);
			flag |= m_ChildrenIds.Remove(id);
			flag |= m_ParentIds.Remove(id);
			flag |= m_Tree.Remove(id);
			return flag | m_RootItemIds.Remove(id);
		}

		private void RefreshTree(IList<TreeViewItemData<T>> rootItems)
		{
			m_Tree.Clear();
			m_ParentIds.Clear();
			m_ChildrenIds.Clear();
			m_RootItemIds.Clear();
			BuildTree(rootItems, isRoot: true);
		}

		private void BuildTree(IEnumerable<TreeViewItemData<T>> items, bool isRoot)
		{
			if (items == null)
			{
				return;
			}
			foreach (TreeViewItemData<T> item in items)
			{
				m_Tree.Add(item.id, item);
				if (isRoot)
				{
					m_RootItemIds.Add(item.id);
				}
				if (item.children == null)
				{
					continue;
				}
				if (!m_ChildrenIds.TryGetValue(item.id, out var value))
				{
					m_ChildrenIds.Add(item.id, value = CollectionPool<List<int>, int>.Get());
				}
				foreach (TreeViewItemData<T> child in item.children)
				{
					m_ParentIds.Add(child.id, item.id);
					value.Add(child.id);
				}
				BuildTree(item.children, isRoot: false);
			}
		}
	}
	internal readonly struct TreeItem
	{
		public const int invalidId = -1;

		public int id { get; }

		public int parentId { get; }

		public IEnumerable<int> childrenIds { get; }

		public bool hasChildren => childrenIds != null && childrenIds.Any();

		public TreeItem(int id, int parentId = -1, IEnumerable<int> childrenIds = null)
		{
			this.id = id;
			this.parentId = parentId;
			this.childrenIds = childrenIds;
		}
	}
	internal readonly struct TreeViewItemWrapper
	{
		public readonly TreeItem item;

		public readonly int depth;

		public int id => item.id;

		public int parentId => item.parentId;

		public IEnumerable<int> childrenIds => item.childrenIds;

		public bool hasChildren => item.hasChildren;

		public TreeViewItemWrapper(TreeItem item, int depth)
		{
			this.item = item;
			this.depth = depth;
		}
	}
	public readonly struct TreeViewItemData<T>
	{
		private readonly T m_Data;

		private readonly IList<TreeViewItemData<T>> m_Children;

		public int id { get; }

		public T data => m_Data;

		public IEnumerable<TreeViewItemData<T>> children => m_Children;

		public bool hasChildren => m_Children != null && m_Children.Count > 0;

		public TreeViewItemData(int id, T data, List<TreeViewItemData<T>> children = null)
		{
			this.id = id;
			m_Data = data;
			m_Children = children ?? new List<TreeViewItemData<T>>();
		}

		internal void AddChild(TreeViewItemData<T> child)
		{
			m_Children.Add(child);
		}

		internal void AddChildren(IList<TreeViewItemData<T>> children)
		{
			foreach (TreeViewItemData<T> child in children)
			{
				AddChild(child);
			}
		}

		internal void InsertChild(TreeViewItemData<T> child, int index)
		{
			if (index < 0 || index >= m_Children.Count)
			{
				m_Children.Add(child);
			}
			else
			{
				m_Children.Insert(index, child);
			}
		}

		internal void RemoveChild(int childId)
		{
			if (m_Children == null)
			{
				return;
			}
			for (int i = 0; i < m_Children.Count; i++)
			{
				if (childId == m_Children[i].id)
				{
					m_Children.RemoveAt(i);
					break;
				}
			}
		}

		internal int GetChildIndex(int itemId)
		{
			int num = 0;
			foreach (TreeViewItemData<T> child in m_Children)
			{
				if (child.id == itemId)
				{
					return num;
				}
				num++;
			}
			return -1;
		}

		internal void ReplaceChild(TreeViewItemData<T> newChild)
		{
			if (!hasChildren)
			{
				return;
			}
			int num = 0;
			foreach (TreeViewItemData<T> child in m_Children)
			{
				if (child.id == newChild.id)
				{
					m_Children.RemoveAt(num);
					m_Children.Insert(num, newChild);
					break;
				}
				num++;
			}
		}
	}
	public class TwoPaneSplitView : VisualElement
	{
		public new class UxmlFactory : UxmlFactory<TwoPaneSplitView, UxmlTraits>
		{
		}

		public new class UxmlTraits : VisualElement.UxmlTraits
		{
			private UxmlIntAttributeDescription m_FixedPaneIndex = new UxmlIntAttributeDescription
			{
				name = "fixed-pane-index",
				defaultValue = 0
			};

			private UxmlIntAttributeDescription m_FixedPaneInitialDimension = new UxmlIntAttributeDescription
			{
				name = "fixed-pane-initial-dimension",
				defaultValue = 100
			};

			private UxmlEnumAttributeDescription<TwoPaneSplitViewOrientation> m_Orientation = new UxmlEnumAttributeDescription<TwoPaneSplitViewOrientation>
			{
				name = "orientation",
				defaultValue = TwoPaneSplitViewOrientation.Horizontal
			};

			public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
			{
				get
				{
					yield break;
				}
			}

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				int valueFromBag = m_FixedPaneIndex.GetValueFromBag(bag, cc);
				int valueFromBag2 = m_FixedPaneInitialDimension.GetValueFromBag(bag, cc);
				TwoPaneSplitViewOrientation valueFromBag3 = m_Orientation.GetValueFromBag(bag, cc);
				((TwoPaneSplitView)ve).Init(valueFromBag, valueFromBag2, valueFromBag3);
			}
		}

		private static readonly string s_UssClassName = "unity-two-pane-split-view";

		private static readonly string s_ContentContainerClassName = "unity-two-pane-split-view__content-container";

		private static readonly string s_HandleDragLineClassName = "unity-two-pane-split-view__dragline";

		private static readonly string s_HandleDragLineVerticalClassName = s_HandleDragLineClassName + "--vertical";

		private static readonly string s_HandleDragLineHorizontalClassName = s_HandleDragLineClassName + "--horizontal";

		private static readonly string s_HandleDragLineAnchorClassName = "unity-two-pane-split-view__dragline-anchor";

		private static readonly string s_HandleDragLineAnchorVerticalClassName = s_HandleDragLineAnchorClassName + "--vertical";

		private static readonly string s_HandleDragLineAnchorHorizontalClassName = s_HandleDragLineAnchorClassName + "--horizontal";

		private static readonly string s_VerticalClassName = "unity-two-pane-split-view--vertical";

		private static readonly string s_HorizontalClassName = "unity-two-pane-split-view--horizontal";

		private VisualElement m_LeftPane;

		private VisualElement m_RightPane;

		private VisualElement m_FixedPane;

		private VisualElement m_FlexedPane;

		[SerializeField]
		private float m_FixedPaneDimension = -1f;

		private VisualElement m_DragLine;

		private VisualElement m_DragLineAnchor;

		private bool m_CollapseMode;

		private bool m_CollapseChildCalledBeforeSetupComplete;

		private int m_CollapsedChildIndex = -1;

		private VisualElement m_Content;

		private TwoPaneSplitViewOrientation m_Orientation;

		private int m_FixedPaneIndex;

		private float m_FixedPaneInitialDimension;

		internal TwoPaneSplitViewResizer m_Resizer;

		public VisualElement fixedPane => m_FixedPane;

		public VisualElement flexedPane => m_FlexedPane;

		internal VisualElement dragLine => m_DragLine;

		public int fixedPaneIndex
		{
			get
			{
				return m_FixedPaneIndex;
			}
			set
			{
				if (value != m_FixedPaneIndex)
				{
					Init(value, m_FixedPaneInitialDimension, m_Orientation);
				}
			}
		}

		public float fixedPaneInitialDimension
		{
			get
			{
				return m_FixedPaneInitialDimension;
			}
			set
			{
				if (value != m_FixedPaneInitialDimension)
				{
					Init(m_FixedPaneIndex, value, m_Orientation);
				}
			}
		}

		public TwoPaneSplitViewOrientation orientation
		{
			get
			{
				return m_Orientation;
			}
			set
			{
				if (value != m_Orientation)
				{
					Init(m_FixedPaneIndex, m_FixedPaneInitialDimension, value);
				}
			}
		}

		internal float fixedPaneDimension
		{
			get
			{
				return string.IsNullOrEmpty(base.viewDataKey) ? m_FixedPaneInitialDimension : m_FixedPaneDimension;
			}
			set
			{
				if (value != m_FixedPaneDimension)
				{
					m_FixedPaneDimension = value;
					SaveViewData();
				}
			}
		}

		public override VisualElement contentContainer => m_Content;

		public TwoPaneSplitView()
		{
			AddToClassList(s_UssClassName);
			m_Content = new VisualElement();
			m_Content.name = "unity-content-container";
			m_Content.AddToClassList(s_ContentContainerClassName);
			base.hierarchy.Add(m_Content);
			m_DragLineAnchor = new VisualElement();
			m_DragLineAnchor.name = "unity-dragline-anchor";
			m_DragLineAnchor.AddToClassList(s_HandleDragLineAnchorClassName);
			base.hierarchy.Add(m_DragLineAnchor);
			m_DragLine = new VisualElement();
			m_DragLine.name = "unity-dragline";
			m_DragLine.AddToClassList(s_HandleDragLineClassName);
			m_DragLineAnchor.Add(m_DragLine);
		}

		public TwoPaneSplitView(int fixedPaneIndex, float fixedPaneStartDimension, TwoPaneSplitViewOrientation orientation)
			: this()
		{
			Init(fixedPaneIndex, fixedPaneStartDimension, orientation);
		}

		public void CollapseChild(int index)
		{
			if (index != 0 && index != 1)
			{
				return;
			}
			if (m_LeftPane == null)
			{
				m_CollapseChildCalledBeforeSetupComplete = true;
				m_CollapsedChildIndex = index;
				return;
			}
			m_DragLine.style.display = DisplayStyle.None;
			m_DragLineAnchor.style.display = DisplayStyle.None;
			if (index == 0)
			{
				m_RightPane.style.width = StyleKeyword.Initial;
				m_RightPane.style.height = StyleKeyword.Initial;
				m_RightPane.style.flexGrow = 1f;
				m_LeftPane.style.display = DisplayStyle.None;
			}
			else
			{
				m_LeftPane.style.width = StyleKeyword.Initial;
				m_LeftPane.style.height = StyleKeyword.Initial;
				m_LeftPane.style.flexGrow = 1f;
				m_RightPane.style.display = DisplayStyle.None;
			}
			m_CollapseMode = true;
		}

		public void UnCollapse()
		{
			if (m_LeftPane != null)
			{
				VisualElement visualElement = null;
				if (m_LeftPane.style.display == DisplayStyle.None)
				{
					visualElement = m_LeftPane;
				}
				else if (m_RightPane.style.display == DisplayStyle.None)
				{
					visualElement = m_RightPane;
				}
				if (visualElement != null)
				{
					m_LeftPane.style.display = DisplayStyle.Flex;
					m_RightPane.style.display = DisplayStyle.Flex;
					m_DragLine.style.display = DisplayStyle.Flex;
					m_DragLineAnchor.style.display = DisplayStyle.Flex;
					m_LeftPane.style.flexGrow = 0f;
					m_RightPane.style.flexGrow = 0f;
					m_CollapseMode = false;
					m_CollapseChildCalledBeforeSetupComplete = false;
					m_CollapsedChildIndex = -1;
					Init(m_FixedPaneIndex, m_FixedPaneInitialDimension, m_Orientation);
					visualElement.RegisterCallback<GeometryChangedEvent>(OnUncollapsedPaneResized);
				}
			}
		}

		private void OnUncollapsedPaneResized(GeometryChangedEvent evt)
		{
			UpdateDragLineAnchorOffset();
			(evt.target as VisualElement).UnregisterCallback<GeometryChangedEvent>(OnUncollapsedPaneResized);
		}

		internal void Init(int fixedPaneIndex, float fixedPaneInitialDimension, TwoPaneSplitViewOrientation orientation)
		{
			m_Orientation = orientation;
			m_FixedPaneIndex = fixedPaneIndex;
			m_FixedPaneInitialDimension = fixedPaneInitialDimension;
			m_Content.RemoveFromClassList(s_HorizontalClassName);
			m_Content.RemoveFromClassList(s_VerticalClassName);
			if (m_Orientation == TwoPaneSplitViewOrientation.Horizontal)
			{
				m_Content.AddToClassList(s_HorizontalClassName);
			}
			else
			{
				m_Content.AddToClassList(s_VerticalClassName);
			}
			m_DragLineAnchor.RemoveFromClassList(s_HandleDragLineAnchorHorizontalClassName);
			m_DragLineAnchor.RemoveFromClassList(s_HandleDragLineAnchorVerticalClassName);
			if (m_Orientation == TwoPaneSplitViewOrientation.Horizontal)
			{
				m_DragLineAnchor.AddToClassList(s_HandleDragLineAnchorHorizontalClassName);
			}
			else
			{
				m_DragLineAnchor.AddToClassList(s_HandleDragLineAnchorVerticalClassName);
			}
			m_DragLine.RemoveFromClassList(s_HandleDragLineHorizontalClassName);
			m_DragLine.RemoveFromClassList(s_HandleDragLineVerticalClassName);
			if (m_Orientation == TwoPaneSplitViewOrientation.Horizontal)
			{
				m_DragLine.AddToClassList(s_HandleDragLineHorizontalClassName);
			}
			else
			{
				m_DragLine.AddToClassList(s_HandleDragLineVerticalClassName);
			}
			if (m_Resizer != null)
			{
				m_DragLineAnchor.RemoveManipulator(m_Resizer);
				m_Resizer = null;
			}
			if (m_Content.childCount != 2)
			{
				RegisterCallback<GeometryChangedEvent>(OnPostDisplaySetup);
			}
			else
			{
				PostDisplaySetup();
			}
			m_DragLineAnchor.RegisterCallback<GeometryChangedEvent>(OnAnchorPostDisplaySetup);
		}

		private void OnPostDisplaySetup(GeometryChangedEvent evt)
		{
			if (m_Content.childCount != 2)
			{
				Debug.LogError("TwoPaneSplitView needs exactly 2 children.");
				return;
			}
			bool flag = m_LeftPane == null;
			PostDisplaySetup();
			if (flag && m_CollapseChildCalledBeforeSetupComplete)
			{
				CollapseChild(m_CollapsedChildIndex);
				m_CollapseChildCalledBeforeSetupComplete = false;
			}
			UnregisterCallback<GeometryChangedEvent>(OnPostDisplaySetup);
			ReplacePanesBasedOnAnchor();
		}

		private void ReplacePanesBasedOnAnchor()
		{
			if (m_Orientation == TwoPaneSplitViewOrientation.Horizontal)
			{
				m_RightPane.style.left = m_DragLineAnchor.worldBound.width;
			}
			else
			{
				m_RightPane.style.top = m_DragLineAnchor.worldBound.height;
			}
		}

		private void OnAnchorPostDisplaySetup(GeometryChangedEvent evt)
		{
			if (!Mathf.Approximately(evt.newRect.width, evt.oldRect.width) || !Mathf.Approximately(evt.newRect.height, evt.oldRect.height))
			{
				IdentifyLeftAndRightPane();
				ReplacePanesBasedOnAnchor();
			}
		}

		private void IdentifyLeftAndRightPane()
		{
			m_LeftPane = m_Content[0];
			if (m_FixedPaneIndex == 0)
			{
				m_FixedPane = m_LeftPane;
			}
			else
			{
				m_FlexedPane = m_LeftPane;
			}
			m_RightPane = m_Content[1];
			if (m_FixedPaneIndex == 1)
			{
				m_FixedPane = m_RightPane;
			}
			else
			{
				m_FlexedPane = m_RightPane;
			}
		}

		private void PostDisplaySetup()
		{
			if (m_Content.childCount != 2)
			{
				Debug.LogError("TwoPaneSplitView needs exactly 2 children.");
				return;
			}
			m_DragLineAnchor.UnregisterCallback<GeometryChangedEvent>(OnAnchorPostDisplaySetup);
			if (fixedPaneDimension < 0f)
			{
				fixedPaneDimension = m_FixedPaneInitialDimension;
			}
			float num = fixedPaneDimension;
			IdentifyLeftAndRightPane();
			m_FixedPane.style.flexBasis = StyleKeyword.Null;
			m_FixedPane.style.flexShrink = StyleKeyword.Null;
			m_FixedPane.style.flexGrow = StyleKeyword.Null;
			m_FlexedPane.style.flexGrow = StyleKeyword.Null;
			m_FlexedPane.style.flexShrink = StyleKeyword.Null;
			m_FlexedPane.style.flexBasis = StyleKeyword.Null;
			m_FixedPane.style.width = StyleKeyword.Null;
			m_FixedPane.style.height = StyleKeyword.Null;
			m_FlexedPane.style.width = StyleKeyword.Null;
			m_FlexedPane.style.height = StyleKeyword.Null;
			if (m_Orientation == TwoPaneSplitViewOrientation.Horizontal)
			{
				m_FixedPane.style.width = num;
				m_FixedPane.style.height = StyleKeyword.Null;
			}
			else
			{
				m_FixedPane.style.width = StyleKeyword.Null;
				m_FixedPane.style.height = num;
			}
			m_FixedPane.style.flexShrink = 0f;
			m_FixedPane.style.flexGrow = 0f;
			m_FlexedPane.style.flexGrow = 1f;
			m_FlexedPane.style.flexShrink = 0f;
			m_FlexedPane.style.flexBasis = 0f;
			m_DragLineAnchor.style.left = 0f;
			m_DragLineAnchor.style.top = 0f;
			if (m_Orientation == TwoPaneSplitViewOrientation.Horizontal)
			{
				float num2 = m_FixedPane.resolvedStyle.marginLeft + m_FixedPane.resolvedStyle.marginRight;
				if (m_FixedPaneIndex == 0)
				{
					m_DragLineAnchor.style.left = num2 + m_FixedPaneInitialDimension;
				}
				else
				{
					m_DragLineAnchor.style.left = base.resolvedStyle.width - num2 - m_FixedPaneInitialDimension - m_DragLineAnchor.resolvedStyle.width;
				}
			}
			else
			{
				float num3 = m_FixedPane.resolvedStyle.marginTop + m_FixedPane.resolvedStyle.marginBottom;
				if (m_FixedPaneIndex == 0)
				{
					m_DragLineAnchor.style.top = num3 + m_FixedPaneInitialDimension;
				}
				else
				{
					m_DragLineAnchor.style.top = base.resolvedStyle.height - num3 - m_FixedPaneInitialDimension - m_DragLineAnchor.resolvedStyle.height;
				}
			}
			int num4 = 1;
			num4 = ((m_FixedPaneIndex == 0) ? 1 : (-1));
			if (m_Resizer != null)
			{
				m_DragLineAnchor.RemoveManipulator(m_Resizer);
			}
			m_Resizer = new TwoPaneSplitViewResizer(this, num4);
			m_DragLineAnchor.AddManipulator(m_Resizer);
			RegisterCallback<GeometryChangedEvent>(OnSizeChange);
			m_DragLineAnchor.RegisterCallback<GeometryChangedEvent>(OnAnchorPostDisplaySetup);
		}

		private void OnSizeChange(GeometryChangedEvent evt)
		{
			UpdateLayout(updateFixedPane: true, updateDragLine: true);
		}

		private void UpdateDragLineAnchorOffset()
		{
			UpdateLayout(updateFixedPane: false, updateDragLine: true);
		}

		private void UpdateLayout(bool updateFixedPane, bool updateDragLine)
		{
			if (m_CollapseMode || base.resolvedStyle.display == DisplayStyle.None || base.resolvedStyle.visibility == Visibility.Hidden)
			{
				return;
			}
			float num = base.resolvedStyle.width;
			float num2 = m_FixedPane.resolvedStyle.width;
			float num3 = m_FixedPane.resolvedStyle.marginLeft + m_FixedPane.resolvedStyle.marginRight;
			float value = m_FixedPane.resolvedStyle.minWidth.value;
			float num4 = m_FlexedPane.resolvedStyle.marginLeft + m_FlexedPane.resolvedStyle.marginRight;
			float value2 = m_FlexedPane.resolvedStyle.minWidth.value;
			if (m_Orientation == TwoPaneSplitViewOrientation.Vertical)
			{
				num = base.resolvedStyle.height;
				num2 = m_FixedPane.resolvedStyle.height;
				num3 = m_FixedPane.resolvedStyle.marginTop + m_FixedPane.resolvedStyle.marginBottom;
				value = m_FixedPane.resolvedStyle.minHeight.value;
				num4 = m_FlexedPane.resolvedStyle.marginTop + m_FlexedPane.resolvedStyle.marginBottom;
				value2 = m_FlexedPane.resolvedStyle.minHeight.value;
			}
			if (num >= num2 + num3 + value2 + num4)
			{
				if (updateDragLine)
				{
					SetDragLineOffset((m_FixedPaneIndex == 0) ? (num2 + num3) : (num - num2 - num3));
				}
			}
			else if (num >= value + num3 + value2 + num4)
			{
				float num5 = num - value2 - num4 - num3;
				float num6 = 0f;
				num6 = ((m_Orientation == TwoPaneSplitViewOrientation.Horizontal) ? Math.Abs(m_DragLineAnchor.worldBound.width - (m_DragLine.resolvedStyle.width - Math.Abs(m_DragLine.resolvedStyle.left))) : Math.Abs(m_DragLineAnchor.worldBound.height - (m_DragLine.resolvedStyle.height - Math.Abs(m_DragLine.resolvedStyle.top))));
				num5 -= num6;
				if (updateFixedPane)
				{
					SetFixedPaneDimension(num5);
				}
				if (updateDragLine)
				{
					SetDragLineOffset((m_FixedPaneIndex == 0) ? (num5 + num3 + num6) : (value2 + num4));
				}
			}
			else
			{
				if (updateFixedPane)
				{
					SetFixedPaneDimension(value);
				}
				if (updateDragLine)
				{
					SetDragLineOffset((m_FixedPaneIndex == 0) ? (value + num3) : (value2 + num4));
				}
			}
		}

		internal override void OnViewDataReady()
		{
			base.OnViewDataReady();
			string fullHierarchicalViewDataKey = GetFullHierarchicalViewDataKey();
			OverwriteFromViewData(this, fullHierarchicalViewDataKey);
			PostDisplaySetup();
		}

		private void SetDragLineOffset(float offset)
		{
			if (m_Orientation == TwoPaneSplitViewOrientation.Horizontal)
			{
				m_DragLineAnchor.style.left = offset;
			}
			else
			{
				m_DragLineAnchor.style.top = offset;
			}
		}

		private void SetFixedPaneDimension(float dimension)
		{
			if (m_Orientation == TwoPaneSplitViewOrientation.Horizontal)
			{
				m_FixedPane.style.width = dimension;
			}
			else
			{
				m_FixedPane.style.height = dimension;
			}
		}
	}
	public enum TwoPaneSplitViewOrientation
	{
		Horizontal,
		Vertical
	}
	internal class TwoPaneSplitViewResizer : PointerManipulator
	{
		private const float k_DragLineTolerance = 1f;

		private Vector3 m_Start;

		protected bool m_Active;

		private TwoPaneSplitView m_SplitView;

		private int m_Direction;

		private TwoPaneSplitViewOrientation orientation => m_SplitView.orientation;

		private VisualElement fixedPane => m_SplitView.fixedPane;

		private VisualElement flexedPane => m_SplitView.flexedPane;

		private float fixedPaneMinDimension
		{
			get
			{
				if (orientation == TwoPaneSplitViewOrientation.Horizontal)
				{
					return fixedPane.resolvedStyle.minWidth.value;
				}
				return fixedPane.resolvedStyle.minHeight.value;
			}
		}

		private float fixedPaneMargins
		{
			get
			{
				if (orientation == TwoPaneSplitViewOrientation.Horizontal)
				{
					return fixedPane.resolvedStyle.marginLeft + fixedPane.resolvedStyle.marginRight;
				}
				return fixedPane.resolvedStyle.marginTop + fixedPane.resolvedStyle.marginBottom;
			}
		}

		private float flexedPaneMinDimension
		{
			get
			{
				if (orientation == TwoPaneSplitViewOrientation.Horizontal)
				{
					return flexedPane.resolvedStyle.minWidth.value;
				}
				return flexedPane.resolvedStyle.minHeight.value;
			}
		}

		private float flexedPaneMargin
		{
			get
			{
				if (orientation == TwoPaneSplitViewOrientation.Horizontal)
				{
					return flexedPane.resolvedStyle.marginLeft + flexedPane.resolvedStyle.marginRight;
				}
				return flexedPane.resolvedStyle.marginTop + flexedPane.resolvedStyle.marginBottom;
			}
		}

		public TwoPaneSplitViewResizer(TwoPaneSplitView splitView, int dir)
		{
			m_SplitView = splitView;
			m_Direction = dir;
			base.activators.Add(new ManipulatorActivationFilter
			{
				button = MouseButton.LeftMouse
			});
			m_Active = false;
		}

		protected override void RegisterCallbacksOnTarget()
		{
			base.target.RegisterCallback<PointerDownEvent>(OnPointerDown);
			base.target.RegisterCallback<PointerMoveEvent>(OnPointerMove);
			base.target.RegisterCallback<PointerUpEvent>(OnPointerUp);
		}

		protected override void UnregisterCallbacksFromTarget()
		{
			base.target.UnregisterCallback<PointerDownEvent>(OnPointerDown);
			base.target.UnregisterCallback<PointerMoveEvent>(OnPointerMove);
			base.target.UnregisterCallback<PointerUpEvent>(OnPointerUp);
		}

		public void ApplyDelta(float delta)
		{
			float num = ((orientation == TwoPaneSplitViewOrientation.Horizontal) ? fixedPane.resolvedStyle.width : fixedPane.resolvedStyle.height);
			float num2 = num + delta;
			float num3 = fixedPaneMinDimension;
			if (m_SplitView.fixedPaneIndex == 1)
			{
				num3 += ((orientation == TwoPaneSplitViewOrientation.Horizontal) ? (base.target.worldBound.width + Math.Abs(m_SplitView.dragLine.resolvedStyle.left)) : (base.target.worldBound.height + Math.Abs(m_SplitView.dragLine.resolvedStyle.top)));
			}
			if (num2 < num && num2 < num3)
			{
				num2 = num3;
			}
			float num4 = ((orientation == TwoPaneSplitViewOrientation.Horizontal) ? m_SplitView.resolvedStyle.width : m_SplitView.resolvedStyle.height);
			num4 -= flexedPaneMinDimension + flexedPaneMargin + fixedPaneMargins;
			if (m_SplitView.fixedPaneIndex == 0)
			{
				num4 -= ((orientation == TwoPaneSplitViewOrientation.Horizontal) ? Math.Abs(base.target.worldBound.width - (m_SplitView.dragLine.resolvedStyle.width - Math.Abs(m_SplitView.dragLine.resolvedStyle.left))) : Math.Abs(base.target.worldBound.height - (m_SplitView.dragLine.resolvedStyle.height - Math.Abs(m_SplitView.dragLine.resolvedStyle.top))));
			}
			if (num2 > num && num2 > num4)
			{
				num2 = num4;
			}
			if (orientation == TwoPaneSplitViewOrientation.Horizontal)
			{
				fixedPane.style.width = num2;
				if (m_SplitView.fixedPaneIndex == 0)
				{
					base.target.style.left = num2 + fixedPaneMargins;
				}
				else
				{
					float num5 = m_SplitView.resolvedStyle.width - num2 - fixedPaneMargins;
					if (num5 >= flexedPaneMinDimension + flexedPaneMargin)
					{
						base.target.style.left = num5;
					}
				}
			}
			else
			{
				fixedPane.style.height = num2;
				if (m_SplitView.fixedPaneIndex == 0)
				{
					base.target.style.top = num2 + fixedPaneMargins;
				}
				else
				{
					float num6 = m_SplitView.resolvedStyle.height - num2 - fixedPaneMargins;
					if (num6 >= flexedPaneMinDimension + flexedPaneMargin)
					{
						base.target.style.top = num6;
					}
				}
			}
			m_SplitView.fixedPaneDimension = num2;
		}

		protected void OnPointerDown(PointerDownEvent e)
		{
			if (m_Active)
			{
				e.StopImmediatePropagation();
			}
			else if (CanStartManipulation(e))
			{
				m_Start = e.localPosition;
				m_Active = true;
				base.target.CapturePointer(e.pointerId);
				e.StopPropagation();
			}
		}

		protected void OnPointerMove(PointerMoveEvent e)
		{
			if (!m_Active || !base.target.HasPointerCapture(e.pointerId))
			{
				return;
			}
			bool flag = ((orientation == TwoPaneSplitViewOrientation.Horizontal) ? (m_SplitView.dragLine.worldBound.x < base.target.worldBound.x) : (m_SplitView.dragLine.worldBound.y < base.target.worldBound.y));
			float num = ((orientation == TwoPaneSplitViewOrientation.Horizontal) ? Math.Abs(base.target.worldBound.x - m_SplitView.dragLine.worldBound.x) : Math.Abs(base.target.worldBound.y - m_SplitView.dragLine.worldBound.y));
			float value = ((orientation == TwoPaneSplitViewOrientation.Horizontal) ? m_SplitView.dragLine.resolvedStyle.left : m_SplitView.dragLine.resolvedStyle.top);
			if (flag && Math.Abs(value) + 1f <= num)
			{
				InterruptPointerMove(e);
				return;
			}
			Vector2 vector = e.localPosition - m_Start;
			float num2 = vector.x;
			if (orientation == TwoPaneSplitViewOrientation.Vertical)
			{
				num2 = vector.y;
			}
			float delta = (float)m_Direction * num2;
			ApplyDelta(delta);
			e.StopPropagation();
		}

		protected void OnPointerUp(PointerUpEvent e)
		{
			if (m_Active && base.target.HasPointerCapture(e.pointerId) && CanStopManipulation(e))
			{
				m_Active = false;
				base.target.ReleasePointer(e.pointerId);
				e.StopPropagation();
			}
		}

		protected void InterruptPointerMove(PointerMoveEvent e)
		{
			if (CanStopManipulation(e))
			{
				m_Active = false;
				base.target.ReleasePointer(e.pointerId);
				e.StopPropagation();
			}
		}
	}
	public class UnsignedIntegerField : TextValueField<uint>
	{
		public new class UxmlFactory : UxmlFactory<UnsignedIntegerField, UxmlTraits>
		{
		}

		public new class UxmlTraits : TextValueFieldTraits<uint, UxmlUnsignedIntAttributeDescription>
		{
		}

		private class UnsignedIntegerInput : TextValueInput
		{
			private UnsignedIntegerField parentUnsignedIntegerField => (UnsignedIntegerField)base.parent;

			protected override string allowedCharacters => UINumericFieldsUtils.k_AllowedCharactersForInt;

			internal UnsignedIntegerInput()
			{
				base.formatString = UINumericFieldsUtils.k_IntFieldFormatString;
			}

			public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, uint startValue)
			{
				double num = NumericFieldDraggerUtility.CalculateIntDragSensitivity(startValue);
				float acceleration = NumericFieldDraggerUtility.Acceleration(speed == DeltaSpeed.Fast, speed == DeltaSpeed.Slow);
				long num2 = StringToValue(base.text);
				num2 += (long)Math.Round((double)NumericFieldDraggerUtility.NiceDelta(delta, acceleration) * num);
				if (parentUnsignedIntegerField.isDelayed)
				{
					base.text = ValueToString(Mathf.ClampToUInt(num2));
				}
				else
				{
					parentUnsignedIntegerField.value = Mathf.ClampToUInt(num2);
				}
			}

			protected override string ValueToString(uint v)
			{
				return v.ToString(base.formatString);
			}

			protected override uint StringToValue(string str)
			{
				UINumericFieldsUtils.TryConvertStringToUInt(str, base.originalText, out var value);
				return value;
			}
		}

		public new static readonly string ussClassName = "unity-unsigned-integer-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		private UnsignedIntegerInput integerInput => (UnsignedIntegerInput)base.textInputBase;

		protected override string ValueToString(uint v)
		{
			return v.ToString(base.formatString, CultureInfo.InvariantCulture.NumberFormat);
		}

		protected override uint StringToValue(string str)
		{
			uint num;
			return UINumericFieldsUtils.TryConvertStringToUInt(str, base.textInputBase.originalText, out num) ? num : base.rawValue;
		}

		public UnsignedIntegerField()
			: this(null)
		{
		}

		public UnsignedIntegerField(int maxLength)
			: this(null, maxLength)
		{
		}

		public UnsignedIntegerField(string label, int maxLength = 1000)
			: base(label, maxLength, (TextValueInput)new UnsignedIntegerInput())
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			AddLabelDragger<uint>();
		}

		internal override bool CanTryParse(string textString)
		{
			uint result;
			return uint.TryParse(textString, out result);
		}

		public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, uint startValue)
		{
			integerInput.ApplyInputDeviceDelta(delta, speed, startValue);
		}
	}
	public class UnsignedLongField : TextValueField<ulong>
	{
		public new class UxmlFactory : UxmlFactory<UnsignedLongField, UxmlTraits>
		{
		}

		public new class UxmlTraits : TextValueFieldTraits<ulong, UxmlUnsignedLongAttributeDescription>
		{
		}

		private class UnsignedLongInput : TextValueInput
		{
			private UnsignedLongField parentUnsignedLongField => (UnsignedLongField)base.parent;

			protected override string allowedCharacters => UINumericFieldsUtils.k_AllowedCharactersForInt;

			internal UnsignedLongInput()
			{
				base.formatString = UINumericFieldsUtils.k_IntFieldFormatString;
			}

			public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, ulong startValue)
			{
				double num = NumericFieldDraggerUtility.CalculateIntDragSensitivity(startValue);
				float acceleration = NumericFieldDraggerUtility.Acceleration(speed == DeltaSpeed.Fast, speed == DeltaSpeed.Slow);
				ulong value = StringToValue(base.text);
				long niceDelta = (long)Math.Round((double)NumericFieldDraggerUtility.NiceDelta(delta, acceleration) * num);
				value = ClampToMinMaxULongValue(niceDelta, value);
				if (parentUnsignedLongField.isDelayed)
				{
					base.text = ValueToString(value);
				}
				else
				{
					parentUnsignedLongField.value = value;
				}
			}

			private ulong ClampToMinMaxULongValue(long niceDelta, ulong value)
			{
				ulong num = (ulong)Math.Abs(niceDelta);
				if (niceDelta > 0)
				{
					if (num > (ulong)(-1L - (long)value))
					{
						return ulong.MaxValue;
					}
					return value + num;
				}
				if (num > value)
				{
					return 0uL;
				}
				return value - num;
			}

			protected override string ValueToString(ulong v)
			{
				return v.ToString(base.formatString);
			}

			protected override ulong StringToValue(string str)
			{
				UINumericFieldsUtils.TryConvertStringToULong(str, base.originalText, out var value);
				return value;
			}
		}

		public new static readonly string ussClassName = "unity-unsigned-long-field";

		public new static readonly string labelUssClassName = ussClassName + "__label";

		public new static readonly string inputUssClassName = ussClassName + "__input";

		private UnsignedLongInput unsignedLongInput => (UnsignedLongInput)base.textInputBase;

		protected override string ValueToString(ulong v)
		{
			return v.ToString(base.formatString, CultureInfo.InvariantCulture.NumberFormat);
		}

		protected override ulong StringToValue(string str)
		{
			ulong num;
			return UINumericFieldsUtils.TryConvertStringToULong(str, base.textInputBase.originalText, out num) ? num : base.rawValue;
		}

		public UnsignedLongField()
			: this(null)
		{
		}

		public UnsignedLongField(int maxLength)
			: this(null, maxLength)
		{
		}

		public UnsignedLongField(string label, int maxLength = 1000)
			: base(label, maxLength, (TextValueInput)new UnsignedLongInput())
		{
			AddToClassList(ussClassName);
			base.labelElement.AddToClassList(labelUssClassName);
			base.visualInput.AddToClassList(inputUssClassName);
			AddLabelDragger<ulong>();
		}

		internal override bool CanTryParse(string textString)
		{
			ulong result;
			return ulong.TryParse(textString, out result);
		}

		public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, ulong startValue)
		{
			unsignedLongInput.ApplyInputDeviceDelta(delta, speed, startValue);
		}
	}
	internal struct CountingBloomFilter
	{
		private const int KEY_SIZE = 14;

		private const uint ARRAY_SIZE = 16384u;

		private const int KEY_MASK = 16383;

		private unsafe fixed byte m_Counters[16384];

		private unsafe void AdjustSlot(uint index, bool increment)
		{
			if (increment)
			{
				if (m_Counters[index] != byte.MaxValue)
				{
					ref byte reference = ref m_Counters[index];
					reference++;
				}
			}
			else if (m_Counters[index] != 0)
			{
				ref byte reference2 = ref m_Counters[index];
				reference2--;
			}
		}

		private uint Hash1(uint hash)
		{
			return hash & 0x3FFF;
		}

		private uint Hash2(uint hash)
		{
			return (hash >> 14) & 0x3FFF;
		}

		private unsafe bool IsSlotEmpty(uint index)
		{
			return m_Counters[index] == 0;
		}

		public void InsertHash(uint hash)
		{
			AdjustSlot(Hash1(hash), increment: true);
			AdjustSlot(Hash2(hash), increment: true);
		}

		public void RemoveHash(uint hash)
		{
			AdjustSlot(Hash1(hash), increment: false);
			AdjustSlot(Hash2(hash), increment: false);
		}

		public bool ContainsHash(uint hash)
		{
			return !IsSlotEmpty(Hash1(hash)) && !IsSlotEmpty(Hash2(hash));
		}
	}
	internal class AncestorFilter
	{
		private CountingBloomFilter m_CountingBloomFilter;

		private Stack<int> m_HashStack = new Stack<int>(100);

		private void AddHash(int hash)
		{
			m_HashStack.Push(hash);
			m_CountingBloomFilter.InsertHash((uint)hash);
		}

		public unsafe bool IsCandidate(StyleComplexSelector complexSel)
		{
			for (int i = 0; i < 4; i++)
			{
				if (complexSel.ancestorHashes.hashes[i] == 0)
				{
					return true;
				}
				if (!m_CountingBloomFilter.ContainsHash((uint)complexSel.ancestorHashes.hashes[i]))
				{
					return false;
				}
			}
			return true;
		}

		public void PushElement(VisualElement element)
		{
			int count = m_HashStack.Count;
			AddHash(element.typeName.GetHashCode() * 13);
			if (!string.IsNullOrEmpty(element.name))
			{
				AddHash(element.name.GetHashCode() * 17);
			}
			foreach (string @class in element.classList)
			{
				AddHash(@class.GetHashCode() * 19);
			}
			m_HashStack.Push(m_HashStack.Count - count);
		}

		public void PopElement()
		{
			int num = m_HashStack.Peek();
			m_HashStack.Pop();
			while (num > 0)
			{
				int hash = m_HashStack.Peek();
				m_CountingBloomFilter.RemoveHash((uint)hash);
				m_HashStack.Pop();
				num--;
			}
		}
	}
	public struct Cursor : IEquatable<Cursor>
	{
		public Texture2D texture { get; set; }

		public Vector2 hotspot { get; set; }

		internal int defaultCursorId { get; set; }

		internal static IEnumerable<Type> allowedAssetTypes
		{
			get
			{
				yield return typeof(Texture2D);
			}
		}

		public override bool Equals(object obj)
		{
			return obj is Cursor && Equals((Cursor)obj);
		}

		public bool Equals(Cursor other)
		{
			return EqualityComparer<Texture2D>.Default.Equals(texture, other.texture) && hotspot.Equals(other.hotspot) && defaultCursorId == other.defaultCursorId;
		}

		public override int GetHashCode()
		{
			int num = 1500536833;
			num = num * -1521134295 + EqualityComparer<Texture2D>.Default.GetHashCode(texture);
			num = num * -1521134295 + EqualityComparer<Vector2>.Default.GetHashCode(hotspot);
			return num * -1521134295 + defaultCursorId.GetHashCode();
		}

		public static bool operator ==(Cursor style1, Cursor style2)
		{
			return style1.Equals(style2);
		}

		public static bool operator !=(Cursor style1, Cursor style2)
		{
			return !(style1 == style2);
		}

		public override string ToString()
		{
			return $"texture={texture}, hotspot={hotspot}";
		}
	}
	internal interface ICursorManager
	{
		void SetCursor(Cursor cursor);

		void ResetCursor();
	}
	internal class CursorManager : ICursorManager
	{
		public bool isCursorOverriden { get; private set; }

		public void SetCursor(Cursor cursor)
		{
			if (cursor.texture != null)
			{
				UnityEngine.Cursor.SetCursor(cursor.texture, cursor.hotspot, CursorMode.Auto);
				isCursorOverriden = true;
				return;
			}
			if (cursor.defaultCursorId != 0)
			{
				Debug.LogWarning("Runtime cursors other than the default cursor need to be defined using a texture.");
			}
			ResetCursor();
		}

		public void ResetCursor()
		{
			if (isCursorOverriden)
			{
				UnityEngine.Cursor.SetCursor(null, Vector2.zero, CursorMode.Auto);
			}
			isCursorOverriden = false;
		}
	}
	internal class DefaultEventSystem
	{
		public enum UpdateMode
		{
			Always,
			IgnoreIfAppNotFocused
		}

		internal struct FocusBasedEventSequenceContext : IDisposable
		{
			private DefaultEventSystem es;

			public FocusBasedEventSequenceContext(DefaultEventSystem es)
			{
				this.es = es;
				es.m_PreviousFocusedPanel = es.focusedPanel;
				es.m_PreviousFocusedElement = es.focusedPanel?.focusController.GetLeafFocusedElement();
			}

			public void Dispose()
			{
				es.m_PreviousFocusedPanel = null;
				es.m_PreviousFocusedElement = null;
			}
		}

		internal interface IInput
		{
			int penEventCount { get; }

			int touchCount { get; }

			bool mousePresent { get; }

			Vector3 mousePosition { get; }

			Vector2 mouseScrollDelta { get; }

			int mouseButtonCount { get; }

			bool anyKey { get; }

			float unscaledTime { get; }

			float doubleClickTime { get; }

			bool GetButtonDown(string button);

			float GetAxisRaw(string axis);

			void ResetPenEvents();

			void ClearLastPenContactEvent();

			PenData GetPenEvent(int index);

			PenData GetLastPenContactEvent();

			Touch GetTouch(int index);

			bool GetMouseButtonDown(int button);

			bool GetMouseButtonUp(int button);
		}

		private class Input : IInput
		{
			public int penEventCount => UnityEngine.Input.penEventCount;

			public int touchCount => UnityEngine.Input.touchCount;

			public bool mousePresent => UnityEngine.Input.mousePresent;

			public Vector3 mousePosition => UnityEngine.Input.mousePosition;

			public Vector2 mouseScrollDelta => UnityEngine.Input.mouseScrollDelta;

			public int mouseButtonCount => 3;

			public bool anyKey => UnityEngine.Input.anyKey;

			public float unscaledTime => Time.unscaledTime;

			public float doubleClickTime => (float)Event.GetDoubleClickTime() * 0.001f;

			public bool GetButtonDown(string button)
			{
				return UnityEngine.Input.GetButtonDown(button);
			}

			public float GetAxisRaw(string axis)
			{
				return UnityEngine.Input.GetAxis(axis);
			}

			public void ResetPenEvents()
			{
				UnityEngine.Input.ResetPenEvents();
			}

			public void ClearLastPenContactEvent()
			{
				UnityEngine.Input.ClearLastPenContactEvent();
			}

			public PenData GetPenEvent(int index)
			{
				return UnityEngine.Input.GetPenEvent(index);
			}

			public PenData GetLastPenContactEvent()
			{
				return UnityEngine.Input.GetLastPenContactEvent();
			}

			public Touch GetTouch(int index)
			{
				return UnityEngine.Input.GetTouch(index);
			}

			public bool GetMouseButtonDown(int button)
			{
				return UnityEngine.Input.GetMouseButtonDown(button);
			}

			public bool GetMouseButtonUp(int button)
			{
				return UnityEngine.Input.GetMouseButtonUp(button);
			}
		}

		private class NoInput : IInput
		{
			public int touchCount => 0;

			public int penEventCount => 0;

			public bool mousePresent => false;

			public Vector3 mousePosition => default(Vector3);

			public Vector2 mouseScrollDelta => default(Vector2);

			public int mouseButtonCount => 0;

			public bool anyKey => false;

			public float unscaledTime => 0f;

			public float doubleClickTime => float.PositiveInfinity;

			public bool GetButtonDown(string button)
			{
				return false;
			}

			public float GetAxisRaw(string axis)
			{
				return 0f;
			}

			public Touch GetTouch(int index)
			{
				return default(Touch);
			}

			public void ResetPenEvents()
			{
			}

			public void ClearLastPenContactEvent()
			{
			}

			public PenData GetPenEvent(int index)
			{
				return default(PenData);
			}

			public PenData GetLastPenContactEvent()
			{
				return default(PenData);
			}

			public bool GetMouseButtonDown(int button)
			{
				return false;
			}

			public bool GetMouseButtonUp(int button)
			{
				return false;
			}
		}

		internal static Func<bool> IsEditorRemoteConnected = () => false;

		private IInput m_Input;

		private readonly string m_HorizontalAxis = "Horizontal";

		private readonly string m_VerticalAxis = "Vertical";

		private readonly string m_SubmitButton = "Submit";

		private readonly string m_CancelButton = "Cancel";

		private readonly float m_InputActionsPerSecond = 10f;

		private readonly float m_RepeatDelay = 0.5f;

		private bool m_SendingTouchEvents;

		private bool m_SendingPenEvent;

		private Event m_Event = new Event();

		private BaseRuntimePanel m_FocusedPanel;

		private BaseRuntimePanel m_PreviousFocusedPanel;

		private Focusable m_PreviousFocusedElement;

		private EventModifiers m_CurrentModifiers;

		private int m_LastMousePressButton = -1;

		private float m_NextMousePressTime = 0f;

		private int m_LastMouseClickCount = 0;

		private Vector2 m_LastMousePosition = Vector2.zero;

		private bool m_MouseProcessedAtLeastOnce;

		private int m_ConsecutiveMoveCount;

		private Vector2 m_LastMoveVector;

		private float m_PrevActionTime;

		private bool m_IsMoveFromKeyboard;

		private bool isAppFocused => Application.isFocused;

		internal IInput input
		{
			get
			{
				return m_Input ?? (m_Input = GetDefaultInput());
			}
			set
			{
				m_Input = value;
			}
		}

		public BaseRuntimePanel focusedPanel
		{
			get
			{
				return m_FocusedPanel;
			}
			set
			{
				if (m_FocusedPanel != value)
				{
					m_FocusedPanel?.Blur();
					m_FocusedPanel = value;
					m_FocusedPanel?.Focus();
				}
			}
		}

		private IInput GetDefaultInput()
		{
			IInput input = new Input();
			try
			{
				input.GetAxisRaw(m_HorizontalAxis);
			}
			catch (InvalidOperationException)
			{
				input = new NoInput();
				Debug.LogWarning("UI Toolkit is currently relying on the legacy Input Manager for its active input source, but the legacy Input Manager is not available using your current Project Settings. Some UI Toolkit functionality might be missing or not working properly as a result. To fix this problem, you can enable \"Input Manager (old)\" or \"Both\" in the Active Input Source setting of the Player section. UI Toolkit is using its internal default event system to process input. Alternatively, you may activate new Input System support with UI Toolkit by adding an EventSystem component to your active scene.");
			}
			return input;
		}

		private bool ShouldIgnoreEventsOnAppNotFocused()
		{
			OperatingSystemFamily operatingSystemFamily = SystemInfo.operatingSystemFamily;
			OperatingSystemFamily operatingSystemFamily2 = operatingSystemFamily;
			if ((uint)(operatingSystemFamily2 - 1) <= 2u)
			{
				return true;
			}
			return false;
		}

		public void Reset()
		{
			m_LastMousePressButton = -1;
			m_NextMousePressTime = 0f;
			m_LastMouseClickCount = 0;
			m_LastMousePosition = Vector2.zero;
			m_MouseProcessedAtLeastOnce = false;
			m_ConsecutiveMoveCount = 0;
			m_IsMoveFromKeyboard = false;
			m_FocusedPanel = null;
		}

		public void Update(UpdateMode updateMode = UpdateMode.Always)
		{
			if (!isAppFocused && ShouldIgnoreEventsOnAppNotFocused() && updateMode == UpdateMode.IgnoreIfAppNotFocused)
			{
				return;
			}
			m_SendingPenEvent = ProcessPenEvents();
			if (!m_SendingPenEvent)
			{
				m_SendingTouchEvents = ProcessTouchEvents();
			}
			if (!m_SendingPenEvent && !m_SendingTouchEvents)
			{
				ProcessMouseEvents();
			}
			else
			{
				m_MouseProcessedAtLeastOnce = false;
			}
			using (FocusBasedEventSequence())
			{
				SendIMGUIEvents();
				SendInputEvents();
			}
		}

		internal FocusBasedEventSequenceContext FocusBasedEventSequence()
		{
			return new FocusBasedEventSequenceContext(this);
		}

		private void SendIMGUIEvents()
		{
			bool flag = true;
			while (Event.PopEvent(m_Event))
			{
				if (m_Event.type == EventType.Ignore || m_Event.type == EventType.Repaint || m_Event.type == EventType.Layout)
				{
					continue;
				}
				m_CurrentModifiers = (flag ? m_Event.modifiers : (m_CurrentModifiers | m_Event.modifiers));
				flag = false;
				if (m_Event.type == EventType.KeyUp || m_Event.type == EventType.KeyDown)
				{
					SendFocusBasedEvent((DefaultEventSystem self) => UIElementsRuntimeUtility.CreateEvent(self.m_Event), this);
					ProcessTabEvent(m_Event, m_CurrentModifiers);
				}
				else if (m_Event.type == EventType.ScrollWheel)
				{
					int? targetDisplay;
					Vector2 vector = UIElementsRuntimeUtility.MultiDisplayBottomLeftToPanelPosition(input.mousePosition, out targetDisplay);
					Vector2 vector2 = vector - m_LastMousePosition;
					Vector2 delta = m_Event.delta;
					SendPositionBasedEvent(vector, vector2, PointerId.mousePointerId, targetDisplay, (Vector3 panelPosition, Vector3 _, (EventModifiers modifiers, Vector2 scrollDelta) t) => WheelEvent.GetPooled(t.scrollDelta, panelPosition, t.modifiers), (m_CurrentModifiers, delta));
				}
				else if ((!m_SendingTouchEvents && !m_SendingPenEvent && m_Event.pointerType != UnityEngine.PointerType.Mouse) || m_Event.type == EventType.MouseEnterWindow || m_Event.type == EventType.MouseLeaveWindow)
				{
					int pointerId = ((m_Event.pointerType == UnityEngine.PointerType.Mouse) ? PointerId.mousePointerId : ((m_Event.pointerType == UnityEngine.PointerType.Touch) ? PointerId.touchPointerIdBase : PointerId.penPointerIdBase));
					int? targetDisplay2;
					Vector3 mousePosition = UIElementsRuntimeUtility.MultiDisplayToLocalScreenPosition(m_Event.mousePosition, out targetDisplay2);
					Vector2 delta2 = m_Event.delta;
					SendPositionBasedEvent(mousePosition, delta2, pointerId, targetDisplay2, delegate(Vector3 panelPosition, Vector3 panelDelta, Event evt)
					{
						evt.mousePosition = panelPosition;
						evt.delta = panelDelta;
						return UIElementsRuntimeUtility.CreateEvent(evt);
					}, m_Event, m_Event.type == EventType.MouseDown || m_Event.type == EventType.TouchDown);
				}
			}
		}

		private void ProcessMouseEvents()
		{
			if (!input.mousePresent)
			{
				return;
			}
			int? targetDisplay;
			Vector2 vector = UIElementsRuntimeUtility.MultiDisplayBottomLeftToPanelPosition(input.mousePosition, out targetDisplay);
			Vector2 vector2 = vector - m_LastMousePosition;
			if (!m_MouseProcessedAtLeastOnce)
			{
				vector2 = Vector2.zero;
				m_LastMousePosition = vector;
				m_MouseProcessedAtLeastOnce = true;
			}
			else if (!Mathf.Approximately(vector2.x, 0f) || !Mathf.Approximately(vector2.y, 0f))
			{
				m_LastMousePosition = vector;
				SendPositionBasedEvent(vector, vector2, PointerId.mousePointerId, targetDisplay, (Vector3 panelPosition, Vector3 panelDelta, DefaultEventSystem self) => PointerEventBase<PointerMoveEvent>.GetPooled(EventType.MouseMove, panelPosition, panelDelta, -1, 0, self.m_CurrentModifiers), this);
			}
			int mouseButtonCount = input.mouseButtonCount;
			for (int num = 0; num < mouseButtonCount; num++)
			{
				if (input.GetMouseButtonDown(num))
				{
					if (m_LastMousePressButton != num || input.unscaledTime >= m_NextMousePressTime)
					{
						m_LastMousePressButton = num;
						m_LastMouseClickCount = 0;
					}
					int item = ++m_LastMouseClickCount;
					m_NextMousePressTime = input.unscaledTime + input.doubleClickTime;
					SendPositionBasedEvent(vector, vector2, PointerId.mousePointerId, targetDisplay, (Vector3 panelPosition, Vector3 panelDelta, (int button, int clickCount, EventModifiers modifiers) t) => PointerEventHelper.GetPooled(EventType.MouseDown, panelPosition, panelDelta, t.button, t.clickCount, t.modifiers), (num, item, m_CurrentModifiers), deselectIfNoTarget: true);
				}
				if (input.GetMouseButtonUp(num))
				{
					int lastMouseClickCount = m_LastMouseClickCount;
					SendPositionBasedEvent(vector, vector2, PointerId.mousePointerId, targetDisplay, (Vector3 panelPosition, Vector3 panelDelta, (int button, int clickCount, EventModifiers modifiers) t) => PointerEventHelper.GetPooled(EventType.MouseUp, panelPosition, panelDelta, t.button, t.clickCount, t.modifiers), (num, lastMouseClickCount, m_CurrentModifiers));
				}
			}
		}

		private void SendInputEvents()
		{
			if (ShouldSendMoveFromInput())
			{
				SendFocusBasedEvent((DefaultEventSystem self) => NavigationMoveEvent.GetPooled(self.GetRawMoveVector(), self.m_IsMoveFromKeyboard ? NavigationDeviceType.Keyboard : NavigationDeviceType.NonKeyboard, self.m_CurrentModifiers), this);
			}
			if (input.GetButtonDown(m_SubmitButton))
			{
				SendFocusBasedEvent((DefaultEventSystem self) => NavigationEventBase<NavigationSubmitEvent>.GetPooled(self.input.anyKey ? NavigationDeviceType.Keyboard : NavigationDeviceType.NonKeyboard, self.m_CurrentModifiers), this);
			}
			if (input.GetButtonDown(m_CancelButton))
			{
				SendFocusBasedEvent((DefaultEventSystem self) => NavigationEventBase<NavigationCancelEvent>.GetPooled(self.input.anyKey ? NavigationDeviceType.Keyboard : NavigationDeviceType.NonKeyboard, self.m_CurrentModifiers), this);
			}
		}

		internal void OnFocusEvent(RuntimePanel panel, FocusEvent evt)
		{
			focusedPanel = panel;
		}

		internal void SendFocusBasedEvent<TArg>(Func<TArg, EventBase> evtFactory, TArg arg)
		{
			if (m_PreviousFocusedPanel != null)
			{
				using (EventBase eventBase = evtFactory(arg))
				{
					eventBase.target = m_PreviousFocusedElement ?? m_PreviousFocusedPanel.visualTree;
					m_PreviousFocusedPanel.visualTree.SendEvent(eventBase);
					UpdateFocusedPanel(m_PreviousFocusedPanel);
					return;
				}
			}
			List<Panel> sortedPlayerPanels = UIElementsRuntimeUtility.GetSortedPlayerPanels();
			for (int num = sortedPlayerPanels.Count - 1; num >= 0; num--)
			{
				Panel panel = sortedPlayerPanels[num];
				if (panel is BaseRuntimePanel baseRuntimePanel)
				{
					using EventBase eventBase2 = evtFactory(arg);
					eventBase2.target = baseRuntimePanel.visualTree;
					baseRuntimePanel.visualTree.SendEvent(eventBase2);
					if (baseRuntimePanel.focusController.focusedElement != null)
					{
						focusedPanel = baseRuntimePanel;
						break;
					}
					if (eventBase2.isPropagationStopped)
					{
						break;
					}
				}
			}
		}

		internal void SendPositionBasedEvent<TArg>(Vector3 mousePosition, Vector3 delta, int pointerId, Func<Vector3, Vector3, TArg, EventBase> evtFactory, TArg arg, bool deselectIfNoTarget = false)
		{
			SendPositionBasedEvent(mousePosition, delta, pointerId, null, evtFactory, arg, deselectIfNoTarget);
		}

		private void SendPositionBasedEvent<TArg>(Vector3 mousePosition, Vector3 delta, int pointerId, int? targetDisplay, Func<Vector3, Vector3, TArg, EventBase> evtFactory, TArg arg, bool deselectIfNoTarget = false)
		{
			if (focusedPanel != null)
			{
				UpdateFocusedPanel(focusedPanel);
			}
			IPanel panel = PointerDeviceState.GetPlayerPanelWithSoftPointerCapture(pointerId);
			IEventHandler capturingElement = RuntimePanel.s_EventDispatcher.pointerState.GetCapturingElement(pointerId);
			if (capturingElement is VisualElement visualElement)
			{
				panel = visualElement.panel;
			}
			BaseRuntimePanel baseRuntimePanel = null;
			Vector2 panelPosition = Vector2.zero;
			Vector2 panelDelta = Vector2.zero;
			if (panel is BaseRuntimePanel baseRuntimePanel2)
			{
				baseRuntimePanel = baseRuntimePanel2;
				baseRuntimePanel.ScreenToPanel(mousePosition, delta, out panelPosition, out panelDelta);
			}
			else
			{
				List<Panel> sortedPlayerPanels = UIElementsRuntimeUtility.GetSortedPlayerPanels();
				for (int num = sortedPlayerPanels.Count - 1; num >= 0; num--)
				{
					if (sortedPlayerPanels[num] is BaseRuntimePanel baseRuntimePanel3 && (!targetDisplay.HasValue || baseRuntimePanel3.targetDisplay == targetDisplay) && baseRuntimePanel3.ScreenToPanel(mousePosition, delta, out panelPosition, out panelDelta) && baseRuntimePanel3.Pick(panelPosition) != null)
					{
						baseRuntimePanel = baseRuntimePanel3;
						break;
					}
				}
			}
			BaseRuntimePanel baseRuntimePanel4 = PointerDeviceState.GetPanel(pointerId, ContextType.Player) as BaseRuntimePanel;
			if (baseRuntimePanel4 != baseRuntimePanel)
			{
				baseRuntimePanel4?.PointerLeavesPanel(pointerId, baseRuntimePanel4.ScreenToPanel(mousePosition));
				baseRuntimePanel?.PointerEntersPanel(pointerId, panelPosition);
			}
			if (baseRuntimePanel != null)
			{
				using (EventBase eventBase = evtFactory(panelPosition, panelDelta, arg))
				{
					baseRuntimePanel.visualTree.SendEvent(eventBase);
					if (eventBase.processedByFocusController)
					{
						UpdateFocusedPanel(baseRuntimePanel);
					}
					if (eventBase.eventTypeId == EventBase<PointerDownEvent>.TypeId())
					{
						PointerDeviceState.SetPlayerPanelWithSoftPointerCapture(pointerId, baseRuntimePanel);
					}
					else if (eventBase.eventTypeId == EventBase<PointerUpEvent>.TypeId() && ((PointerUpEvent)eventBase).pressedButtons == 0)
					{
						PointerDeviceState.SetPlayerPanelWithSoftPointerCapture(pointerId, null);
					}
					return;
				}
			}
			if (deselectIfNoTarget)
			{
				focusedPanel = null;
			}
		}

		private void UpdateFocusedPanel(BaseRuntimePanel runtimePanel)
		{
			if (runtimePanel.focusController.focusedElement != null)
			{
				focusedPanel = runtimePanel;
			}
			else if (focusedPanel == runtimePanel)
			{
				focusedPanel = null;
			}
		}

		private static EventBase MakeTouchEvent(Touch touch, EventModifiers modifiers)
		{
			return touch.phase switch
			{
				TouchPhase.Began => PointerEventBase<PointerDownEvent>.GetPooled(touch, modifiers), 
				TouchPhase.Moved => PointerEventBase<PointerMoveEvent>.GetPooled(touch, modifiers), 
				TouchPhase.Stationary => PointerEventBase<PointerStationaryEvent>.GetPooled(touch, modifiers), 
				TouchPhase.Ended => PointerEventBase<PointerUpEvent>.GetPooled(touch, modifiers), 
				TouchPhase.Canceled => PointerEventBase<PointerCancelEvent>.GetPooled(touch, modifiers), 
				_ => null, 
			};
		}

		private static EventBase MakePenEvent(PenData pen, EventModifiers modifiers)
		{
			return pen.contactType switch
			{
				PenEventType.PenDown => PointerEventBase<PointerDownEvent>.GetPooled(pen, modifiers), 
				PenEventType.PenUp => PointerEventBase<PointerUpEvent>.GetPooled(pen, modifiers), 
				_ => null, 
			};
		}

		private bool ProcessTouchEvents()
		{
			for (int i = 0; i < input.touchCount; i++)
			{
				Touch touch = input.GetTouch(i);
				if (touch.type != TouchType.Indirect)
				{
					touch.position = UIElementsRuntimeUtility.MultiDisplayBottomLeftToPanelPosition(touch.position, out var targetDisplay);
					touch.rawPosition = UIElementsRuntimeUtility.MultiDisplayBottomLeftToPanelPosition(touch.rawPosition, out var _);
					touch.deltaPosition = UIElementsRuntimeUtility.ScreenBottomLeftToPanelDelta(touch.deltaPosition);
					SendPositionBasedEvent(touch.position, touch.deltaPosition, PointerId.touchPointerIdBase + touch.fingerId, targetDisplay, delegate(Vector3 panelPosition, Vector3 panelDelta, Touch _touch)
					{
						_touch.position = panelPosition;
						_touch.deltaPosition = panelDelta;
						return MakeTouchEvent(_touch, EventModifiers.None);
					}, touch);
				}
			}
			return input.touchCount > 0;
		}

		private bool ProcessPenEvents()
		{
			PenData lastPenContactEvent = input.GetLastPenContactEvent();
			if (lastPenContactEvent.contactType == PenEventType.NoContact)
			{
				return false;
			}
			SendPositionBasedEvent(lastPenContactEvent.position, lastPenContactEvent.deltaPos, PointerId.penPointerIdBase, null, delegate(Vector3 panelPosition, Vector3 panelDelta, PenData _pen)
			{
				_pen.position = panelPosition;
				_pen.deltaPos = panelDelta;
				return MakePenEvent(_pen, EventModifiers.None);
			}, lastPenContactEvent);
			input.ClearLastPenContactEvent();
			return true;
		}

		private Vector2 GetRawMoveVector()
		{
			Vector2 zero = Vector2.zero;
			zero.x = input.GetAxisRaw(m_HorizontalAxis);
			zero.y = input.GetAxisRaw(m_VerticalAxis);
			if (input.GetButtonDown(m_HorizontalAxis))
			{
				if (zero.x < 0f)
				{
					zero.x = -1f;
				}
				if (zero.x > 0f)
				{
					zero.x = 1f;
				}
			}
			if (input.GetButtonDown(m_VerticalAxis))
			{
				if (zero.y < 0f)
				{
					zero.y = -1f;
				}
				if (zero.y > 0f)
				{
					zero.y = 1f;
				}
			}
			return zero;
		}

		private bool ShouldSendMoveFromInput()
		{
			float unscaledTime = input.unscaledTime;
			Vector2 rawMoveVector = GetRawMoveVector();
			if (Mathf.Approximately(rawMoveVector.x, 0f) && Mathf.Approximately(rawMoveVector.y, 0f))
			{
				m_ConsecutiveMoveCount = 0;
				m_IsMoveFromKeyboard = false;
				return false;
			}
			bool flag = input.GetButtonDown(m_HorizontalAxis) || input.GetButtonDown(m_VerticalAxis);
			bool flag2 = Vector2.Dot(rawMoveVector, m_LastMoveVector) > 0f;
			if (!flag)
			{
				flag = ((!flag2 || m_ConsecutiveMoveCount != 1) ? (unscaledTime > m_PrevActionTime + 1f / m_InputActionsPerSecond) : (unscaledTime > m_PrevActionTime + m_RepeatDelay));
			}
			if (!flag)
			{
				return false;
			}
			NavigationMoveEvent.Direction direction = NavigationMoveEvent.DetermineMoveDirection(rawMoveVector.x, rawMoveVector.y);
			if (direction != NavigationMoveEvent.Direction.None)
			{
				if (!flag2)
				{
					m_ConsecutiveMoveCount = 0;
				}
				m_ConsecutiveMoveCount++;
				m_PrevActionTime = unscaledTime;
				m_LastMoveVector = rawMoveVector;
				m_IsMoveFromKeyboard |= input.anyKey;
			}
			else
			{
				m_ConsecutiveMoveCount = 0;
				m_IsMoveFromKeyboard = false;
			}
			return direction != NavigationMoveEvent.Direction.None;
		}

		private void ProcessTabEvent(Event e, EventModifiers modifiers)
		{
			if (e.ShouldSendNavigationMoveEventRuntime())
			{
				NavigationMoveEvent.Direction item = (e.shift ? NavigationMoveEvent.Direction.Previous : NavigationMoveEvent.Direction.Next);
				SendFocusBasedEvent(((NavigationMoveEvent.Direction direction, EventModifiers modifiers, IInput input) t) => NavigationMoveEvent.GetPooled(t.direction, t.input.anyKey ? NavigationDeviceType.Keyboard : NavigationDeviceType.NonKeyboard, t.modifiers), (item, modifiers, input));
			}
		}
	}
	internal class DisposeHelper
	{
		[Conditional("UNITY_UIELEMENTS_DEBUG_DISPOSE")]
		public static void NotifyMissingDispose(IDisposable disposable)
		{
			if (disposable != null)
			{
				Debug.LogError("An IDisposable instance of type '" + disposable.GetType().FullName + "' has not been disposed.");
			}
		}

		public static void NotifyDisposedUsed(IDisposable disposable)
		{
			Debug.LogError("An instance of type '" + disposable.GetType().FullName + "' is being used although it has been disposed.");
		}
	}
	internal abstract class BaseReorderableDragAndDropController : ICollectionDragAndDropController, IDragAndDropController<IListDragAndDropArgs>, IReorderable
	{
		protected readonly BaseVerticalCollectionView m_View;

		protected List<int> m_SortedSelectedIds = new List<int>();

		public virtual bool enableReordering { get; set; } = true;

		public IEnumerable<int> GetSortedSelectedIds()
		{
			return m_SortedSelectedIds;
		}

		protected BaseReorderableDragAndDropController(BaseVerticalCollectionView view)
		{
			m_View = view;
		}

		public virtual bool CanStartDrag(IEnumerable<int> itemIds)
		{
			return enableReordering;
		}

		public virtual StartDragArgs SetupDragAndDrop(IEnumerable<int> itemIds, bool skipText = false)
		{
			m_SortedSelectedIds.Clear();
			string text = string.Empty;
			if (itemIds != null)
			{
				foreach (int itemId in itemIds)
				{
					m_SortedSelectedIds.Add(itemId);
					if (!skipText)
					{
						if (string.IsNullOrEmpty(text))
						{
							Label label = m_View.GetRecycledItemFromId(itemId)?.rootElement.Q<Label>();
							text = ((label != null) ? label.text : $"Item {itemId}");
						}
						else
						{
							text = "<Multiple>";
							skipText = true;
						}
					}
				}
			}
			m_SortedSelectedIds.Sort(CompareId);
			return new StartDragArgs(text, DragVisualMode.Move);
		}

		protected virtual int CompareId(int id1, int id2)
		{
			return id1.CompareTo(id2);
		}

		public abstract DragVisualMode HandleDragAndDrop(IListDragAndDropArgs args);

		public abstract void OnDrop(IListDragAndDropArgs args);

		public virtual void DragCleanup()
		{
		}

		public virtual void HandleAutoExpand(ReusableCollectionItem item, Vector2 pointerPosition)
		{
		}
	}
	internal static class DragAndDropUtility
	{
		private static Func<IDragAndDrop> s_MakeDragAndDropClientFunc;

		private static IDragAndDrop s_DragAndDropEditor;

		private static IDragAndDrop s_DragAndDropPlayMode;

		internal static IDragAndDrop GetDragAndDrop(IPanel panel)
		{
			if (panel.contextType == ContextType.Player)
			{
				return s_DragAndDropPlayMode ?? (s_DragAndDropPlayMode = new DefaultDragAndDropClient());
			}
			IDragAndDrop dragAndDrop = s_DragAndDropEditor;
			if (dragAndDrop == null)
			{
				if (s_MakeDragAndDropClientFunc == null)
				{
					IDragAndDrop dragAndDrop2 = new DefaultDragAndDropClient();
					dragAndDrop = dragAndDrop2;
				}
				else
				{
					dragAndDrop = s_MakeDragAndDropClientFunc();
				}
				s_DragAndDropEditor = dragAndDrop;
			}
			return dragAndDrop;
		}

		internal static void RegisterMakeClientFunc(Func<IDragAndDrop> makeClient)
		{
			s_MakeDragAndDropClientFunc = makeClient;
			s_DragAndDropEditor = null;
		}
	}
	internal class DefaultDragAndDropClient : DragAndDropData, IDragAndDrop
	{
		private readonly Hashtable m_GenericData = new Hashtable();

		private Label m_DraggedInfoLabel;

		private DragVisualMode m_VisualMode;

		private IEnumerable<Object> m_UnityObjectReferences;

		public override DragVisualMode visualMode => m_VisualMode;

		public override object source => GetGenericData("__unity-drag-and-drop__source-view");

		public override IEnumerable<Object> unityObjectReferences => m_UnityObjectReferences;

		public DragAndDropData data => this;

		public override object GetGenericData(string key)
		{
			return m_GenericData.ContainsKey(key) ? m_GenericData[key] : null;
		}

		public override void SetGenericData(string key, object value)
		{
			m_GenericData[key] = value;
		}

		public void StartDrag(StartDragArgs args, Vector3 pointerPosition)
		{
			if (args.unityObjectReferences != null)
			{
				m_UnityObjectReferences = args.unityObjectReferences.ToArray();
			}
			m_VisualMode = args.visualMode;
			foreach (DictionaryEntry genericDatum in args.genericData)
			{
				m_GenericData[(string)genericDatum.Key] = genericDatum.Value;
			}
			if (string.IsNullOrWhiteSpace(args.title))
			{
				return;
			}
			VisualElement visualElement = ((source is VisualElement visualElement2) ? visualElement2.panel.visualTree : null);
			if (visualElement != null)
			{
				if (m_DraggedInfoLabel == null)
				{
					Label label = new Label();
					label.pickingMode = PickingMode.Ignore;
					label.style.position = Position.Absolute;
					m_DraggedInfoLabel = label;
				}
				m_DraggedInfoLabel.text = args.title;
				m_DraggedInfoLabel.style.top = pointerPosition.y;
				m_DraggedInfoLabel.style.left = pointerPosition.x;
				visualElement.Add(m_DraggedInfoLabel);
			}
		}

		public void UpdateDrag(Vector3 pointerPosition)
		{
			if (m_DraggedInfoLabel != null)
			{
				m_DraggedInfoLabel.style.top = pointerPosition.y;
				m_DraggedInfoLabel.style.left = pointerPosition.x;
			}
		}

		public void AcceptDrag()
		{
		}

		public void SetVisualMode(DragVisualMode mode)
		{
			m_VisualMode = mode;
		}

		public void DragCleanup()
		{
			m_UnityObjectReferences = null;
			m_GenericData?.Clear();
			SetVisualMode(DragVisualMode.None);
			m_DraggedInfoLabel?.RemoveFromHierarchy();
		}
	}
	internal abstract class DragEventsProcessor
	{
		internal enum DragState
		{
			None,
			CanStartDrag,
			Dragging
		}

		private bool m_IsRegistered;

		private DragState m_DragState;

		private Vector3 m_Start;

		protected readonly VisualElement m_Target;

		internal bool isRegistered => m_IsRegistered;

		internal DragState dragState => m_DragState;

		protected virtual bool supportsDragEvents => true;

		private bool useDragEvents => isEditorContext && supportsDragEvents;

		protected IDragAndDrop dragAndDrop => DragAndDropUtility.GetDragAndDrop(m_Target.panel);

		internal virtual bool isEditorContext
		{
			get
			{
				Assert.IsNotNull(m_Target);
				Assert.IsNotNull(m_Target.parent);
				return m_Target.panel.contextType == ContextType.Editor;
			}
		}

		internal DragEventsProcessor(VisualElement target)
		{
			m_Target = target;
			m_Target.RegisterCallback<AttachToPanelEvent>(RegisterCallbacksFromTarget);
			m_Target.RegisterCallback<DetachFromPanelEvent>(UnregisterCallbacksFromTarget);
			RegisterCallbacksFromTarget();
		}

		private void RegisterCallbacksFromTarget(AttachToPanelEvent evt)
		{
			RegisterCallbacksFromTarget();
		}

		private void RegisterCallbacksFromTarget()
		{
			if (!m_IsRegistered)
			{
				m_IsRegistered = true;
				m_Target.RegisterCallback<PointerDownEvent>(OnPointerDownEvent);
				m_Target.RegisterCallback<PointerUpEvent>(OnPointerUpEvent, TrickleDown.TrickleDown);
				m_Target.RegisterCallback<PointerLeaveEvent>(OnPointerLeaveEvent);
				m_Target.RegisterCallback<PointerMoveEvent>(OnPointerMoveEvent);
				m_Target.RegisterCallback<PointerCancelEvent>(OnPointerCancelEvent);
				m_Target.RegisterCallback<PointerCaptureOutEvent>(OnPointerCapturedOut);
			}
		}

		private void UnregisterCallbacksFromTarget(DetachFromPanelEvent evt)
		{
			UnregisterCallbacksFromTarget();
		}

		internal void UnregisterCallbacksFromTarget(bool unregisterPanelEvents = false)
		{
			m_IsRegistered = false;
			m_Target.UnregisterCallback<PointerDownEvent>(OnPointerDownEvent);
			m_Target.UnregisterCallback<PointerUpEvent>(OnPointerUpEvent, TrickleDown.TrickleDown);
			m_Target.UnregisterCallback<PointerLeaveEvent>(OnPointerLeaveEvent);
			m_Target.UnregisterCallback<PointerMoveEvent>(OnPointerMoveEvent);
			m_Target.UnregisterCallback<PointerCancelEvent>(OnPointerCancelEvent);
			m_Target.UnregisterCallback<PointerCaptureOutEvent>(OnPointerCapturedOut);
			if (unregisterPanelEvents)
			{
				m_Target.UnregisterCallback<AttachToPanelEvent>(RegisterCallbacksFromTarget);
				m_Target.UnregisterCallback<DetachFromPanelEvent>(UnregisterCallbacksFromTarget);
			}
		}

		protected abstract bool CanStartDrag(Vector3 pointerPosition);

		protected internal abstract StartDragArgs StartDrag(Vector3 pointerPosition);

		protected internal abstract void UpdateDrag(Vector3 pointerPosition);

		protected internal abstract void OnDrop(Vector3 pointerPosition);

		protected abstract void ClearDragAndDropUI(bool dragCancelled);

		private void OnPointerDownEvent(PointerDownEvent evt)
		{
			if (evt.button != 0 || evt.leafTarget is VisualElement { isIMGUIContainer: not false })
			{
				m_DragState = DragState.None;
			}
			else if (CanStartDrag(evt.position))
			{
				m_DragState = DragState.CanStartDrag;
				m_Start = evt.position;
			}
		}

		internal void OnPointerUpEvent(PointerUpEvent evt)
		{
			if (!useDragEvents && m_DragState == DragState.Dragging)
			{
				DragEventsProcessor dragEventsProcessor = GetDropTarget(evt.position) ?? this;
				dragEventsProcessor.UpdateDrag(evt.position);
				dragEventsProcessor.OnDrop(evt.position);
				dragEventsProcessor.ClearDragAndDropUI(dragCancelled: false);
				evt.StopPropagation();
			}
			m_Target.ReleasePointer(evt.pointerId);
			ClearDragAndDropUI(m_DragState == DragState.Dragging);
			dragAndDrop.DragCleanup();
			m_DragState = DragState.None;
		}

		private void OnPointerLeaveEvent(PointerLeaveEvent evt)
		{
			ClearDragAndDropUI(dragCancelled: false);
		}

		private void OnPointerCancelEvent(PointerCancelEvent evt)
		{
			if (!useDragEvents)
			{
				ClearDragAndDropUI(dragCancelled: true);
			}
			m_Target.ReleasePointer(evt.pointerId);
			ClearDragAndDropUI(m_DragState == DragState.Dragging);
			dragAndDrop.DragCleanup();
			m_DragState = DragState.None;
		}

		private void OnPointerCapturedOut(PointerCaptureOutEvent evt)
		{
			if (!useDragEvents)
			{
				ClearDragAndDropUI(dragCancelled: true);
			}
			ClearDragAndDropUI(m_DragState == DragState.Dragging);
			dragAndDrop.DragCleanup();
			m_DragState = DragState.None;
		}

		private void OnPointerMoveEvent(PointerMoveEvent evt)
		{
			if (evt.isHandledByDraggable)
			{
				return;
			}
			if (!useDragEvents && m_DragState == DragState.Dragging)
			{
				DragEventsProcessor dragEventsProcessor = GetDropTarget(evt.position) ?? this;
				dragEventsProcessor.UpdateDrag(evt.position);
			}
			else
			{
				if (m_DragState != DragState.CanStartDrag || !((m_Start - evt.position).sqrMagnitude >= 100f))
				{
					return;
				}
				StartDragArgs args = StartDrag(m_Start);
				if (args.visualMode == DragVisualMode.Rejected)
				{
					m_DragState = DragState.None;
					return;
				}
				if (!useDragEvents)
				{
					if (supportsDragEvents)
					{
						dragAndDrop.StartDrag(args, evt.position);
					}
				}
				else
				{
					if (Event.current != null && Event.current.type != EventType.MouseDown && Event.current.type != EventType.MouseDrag)
					{
						return;
					}
					dragAndDrop.StartDrag(args, evt.position);
				}
				m_DragState = DragState.Dragging;
				m_Target.CapturePointer(evt.pointerId);
				evt.isHandledByDraggable = true;
				evt.StopPropagation();
			}
		}

		private DragEventsProcessor GetDropTarget(Vector2 position)
		{
			DragEventsProcessor result = null;
			if (m_Target.worldBound.Contains(position))
			{
				result = this;
			}
			else if (supportsDragEvents)
			{
				result = (m_Target.elementPanel.Pick(position)?.GetFirstOfType<BaseVerticalCollectionView>())?.dragger;
			}
			return result;
		}
	}
	internal interface ICollectionDragAndDropController : IDragAndDropController<IListDragAndDropArgs>, IReorderable
	{
	}
	internal interface IDragAndDrop
	{
		DragAndDropData data { get; }

		void StartDrag(StartDragArgs args, Vector3 pointerPosition);

		void UpdateDrag(Vector3 pointerPosition);

		void AcceptDrag();

		void DragCleanup();

		void SetVisualMode(DragVisualMode visualMode);
	}
	internal interface IDragAndDropData
	{
		object userData { get; }

		IEnumerable<Object> unityObjectReferences { get; }

		object GetGenericData(string key);
	}
	internal abstract class DragAndDropData : IDragAndDropData
	{
		internal const string dragSourceKey = "__unity-drag-and-drop__source-view";

		object IDragAndDropData.userData => GetGenericData("__unity-drag-and-drop__source-view");

		public abstract object source { get; }

		public abstract DragVisualMode visualMode { get; }

		public abstract IEnumerable<Object> unityObjectReferences { get; }

		public abstract object GetGenericData(string key);

		public abstract void SetGenericData(string key, object data);
	}
	internal interface IListDragAndDropArgs
	{
		object target { get; }

		int insertAtIndex { get; }

		int parentId { get; }

		int childIndex { get; }

		DragAndDropData dragAndDropData { get; }

		DragAndDropPosition dragAndDropPosition { get; }
	}
	internal struct DragAndDropArgs : IListDragAndDropArgs
	{
		public object target { get; set; }

		public int insertAtIndex { get; set; }

		public int parentId { get; set; }

		public int childIndex { get; set; }

		public DragAndDropPosition dragAndDropPosition { get; set; }

		public DragAndDropData dragAndDropData { get; set; }
	}
	internal enum DragAndDropPosition
	{
		OverItem,
		BetweenItems,
		OutsideItems
	}
	internal interface IDragAndDropController<in TArgs>
	{
		bool CanStartDrag(IEnumerable<int> itemIds);

		StartDragArgs SetupDragAndDrop(IEnumerable<int> itemIds, bool skipText = false);

		DragVisualMode HandleDragAndDrop(TArgs args);

		void OnDrop(TArgs args);

		void DragCleanup()
		{
		}

		void HandleAutoExpand(ReusableCollectionItem item, Vector2 pointerPosition)
		{
		}

		IEnumerable<int> GetSortedSelectedIds()
		{
			return Enumerable.Empty<int>();
		}
	}
	internal enum DragVisualMode
	{
		None,
		Copy,
		Move,
		Rejected
	}
	internal readonly struct CanStartDragArgs
	{
		public readonly VisualElement draggedElement;

		public readonly int id;

		public readonly IEnumerable<int> selectedIds;

		internal CanStartDragArgs(VisualElement draggedElement, int id, IEnumerable<int> selectedIds)
		{
			this.draggedElement = draggedElement;
			this.id = id;
			this.selectedIds = selectedIds;
		}
	}
	internal readonly struct SetupDragAndDropArgs
	{
		public readonly VisualElement draggedElement;

		public readonly IEnumerable<int> selectedIds;

		public readonly StartDragArgs startDragArgs;

		internal SetupDragAndDropArgs(VisualElement draggedElement, IEnumerable<int> selectedIds, StartDragArgs startDragArgs)
		{
			this.draggedElement = draggedElement;
			this.selectedIds = selectedIds;
			this.startDragArgs = startDragArgs;
		}
	}
	internal readonly struct HandleDragAndDropArgs
	{
		private readonly DragAndDropArgs m_DragAndDropArgs;

		public Vector2 position { get; }

		public object target => m_DragAndDropArgs.target;

		public int insertAtIndex => m_DragAndDropArgs.insertAtIndex;

		public int parentId => m_DragAndDropArgs.parentId;

		public int childIndex => m_DragAndDropArgs.childIndex;

		public DragAndDropPosition dropPosition => m_DragAndDropArgs.dragAndDropPosition;

		public DragAndDropData dragAndDropData => m_DragAndDropArgs.dragAndDropData;

		internal HandleDragAndDropArgs(Vector2 position, DragAndDropArgs dragAndDropArgs)
		{
			this.position = position;
			m_DragAndDropArgs = dragAndDropArgs;
		}
	}
	internal struct StartDragArgs
	{
		public string title { get; }

		public DragVisualMode visualMode { get; }

		internal Hashtable genericData { get; private set; }

		internal IEnumerable<Object> unityObjectReferences { get; private set; }

		public StartDragArgs(string title, DragVisualMode visualMode)
		{
			this.title = title;
			this.visualMode = visualMode;
			genericData = null;
			unityObjectReferences = null;
		}

		internal StartDragArgs(string title, object target)
		{
			this.title = title;
			visualMode = DragVisualMode.Move;
			genericData = null;
			unityObjectReferences = null;
			SetGenericData("__unity-drag-and-drop__source-view", target);
		}

		public void SetGenericData(string key, object data)
		{
			if (genericData == null)
			{
				Hashtable hashtable = (genericData = new Hashtable());
			}
			genericData[key] = data;
		}

		public void SetUnityObjectReferences(IEnumerable<Object> references)
		{
			unityObjectReferences = references;
		}
	}
	internal interface IReorderable
	{
		bool enableReordering { get; set; }
	}
	internal class ListViewDragger : DragEventsProcessor
	{
		internal struct DragPosition : IEquatable<DragPosition>
		{
			public int insertAtIndex;

			public int parentId;

			public int childIndex;

			public ReusableCollectionItem recycledItem;

			public DragAndDropPosition dropPosition;

			public bool Equals(DragPosition other)
			{
				return insertAtIndex == other.insertAtIndex && parentId == other.parentId && childIndex == other.childIndex && object.Equals(recycledItem, other.recycledItem) && dropPosition == other.dropPosition;
			}

			public override bool Equals(object obj)
			{
				return obj is DragPosition other && Equals(other);
			}

			public override int GetHashCode()
			{
				int num = insertAtIndex;
				num = (num * 397) ^ parentId;
				num = (num * 397) ^ childIndex;
				num = (num * 397) ^ (recycledItem?.GetHashCode() ?? 0);
				return (num * 397) ^ (int)dropPosition;
			}
		}

		private DragPosition m_LastDragPosition;

		private VisualElement m_DragHoverBar;

		private VisualElement m_DragHoverItemMarker;

		private VisualElement m_DragHoverSiblingMarker;

		private float m_LeftIndentation = -1f;

		private float m_SiblingBottom = -1f;

		private const int k_AutoScrollAreaSize = 5;

		private const int k_BetweenElementsAreaSize = 5;

		private const int k_PanSpeed = 20;

		private const int k_DragHoverBarHeight = 2;

		protected BaseVerticalCollectionView targetView => m_Target as BaseVerticalCollectionView;

		protected ScrollView targetScrollView => targetView.scrollView;

		public ICollectionDragAndDropController dragAndDropController { get; set; }

		public ListViewDragger(BaseVerticalCollectionView listView)
			: base(listView)
		{
		}

		protected override bool CanStartDrag(Vector3 pointerPosition)
		{
			if (dragAndDropController == null)
			{
				return false;
			}
			if (!targetScrollView.contentContainer.worldBound.Contains(pointerPosition))
			{
				return false;
			}
			ReusableCollectionItem recycledItem = GetRecycledItem(pointerPosition);
			if (recycledItem != null && targetView.HasCanStartDrag())
			{
				IEnumerable<int> enumerable2;
				if (!targetView.selectedIds.Any())
				{
					IEnumerable<int> enumerable = new int[1] { recycledItem.id };
					enumerable2 = enumerable;
				}
				else
				{
					enumerable2 = targetView.selectedIds;
				}
				IEnumerable<int> ids = enumerable2;
				return targetView.RaiseCanStartDrag(recycledItem, ids);
			}
			if (targetView.selectedIds.Any())
			{
				return dragAndDropController.CanStartDrag(targetView.selectedIds);
			}
			return recycledItem != null && dragAndDropController.CanStartDrag(new int[1] { recycledItem.id });
		}

		protected internal override StartDragArgs StartDrag(Vector3 pointerPosition)
		{
			ReusableCollectionItem recycledItem = GetRecycledItem(pointerPosition);
			IEnumerable<int> itemIds;
			if (recycledItem != null)
			{
				if (!targetView.selectedIndices.Contains(recycledItem.index))
				{
					targetView.SetSelection(recycledItem.index);
				}
				itemIds = targetView.selectedIds;
			}
			else
			{
				itemIds = (targetView.selectedIds.Any() ? targetView.selectedIds : Enumerable.Empty<int>());
			}
			StartDragArgs args = dragAndDropController.SetupDragAndDrop(itemIds);
			args = targetView.RaiseSetupDragAndDrop(recycledItem, dragAndDropController.GetSortedSelectedIds(), args);
			args.SetGenericData("__unity-drag-and-drop__source-view", targetView);
			return args;
		}

		protected internal override void UpdateDrag(Vector3 pointerPosition)
		{
			DragPosition dragPosition = default(DragPosition);
			DragVisualMode visualMode = GetVisualMode(pointerPosition, ref dragPosition);
			if (visualMode == DragVisualMode.Rejected)
			{
				ClearDragAndDropUI(dragCancelled: false);
			}
			else
			{
				HandleDragAndScroll(pointerPosition);
				HandleAutoExpansion(pointerPosition);
				ApplyDragAndDropUI(dragPosition);
			}
			base.dragAndDrop.SetVisualMode(visualMode);
			base.dragAndDrop.UpdateDrag(pointerPosition);
		}

		private DragVisualMode GetVisualMode(Vector3 pointerPosition, ref DragPosition dragPosition)
		{
			if (dragAndDropController == null)
			{
				return DragVisualMode.Rejected;
			}
			bool flag = TryGetDragPosition(pointerPosition, ref dragPosition);
			DragAndDropArgs dragAndDropArgs = MakeDragAndDropArgs(dragPosition);
			DragVisualMode dragVisualMode = targetView.RaiseHandleDragAndDrop(pointerPosition, dragAndDropArgs);
			if (dragVisualMode != DragVisualMode.None)
			{
				return dragVisualMode;
			}
			return flag ? dragAndDropController.HandleDragAndDrop(dragAndDropArgs) : DragVisualMode.Rejected;
		}

		protected internal override void OnDrop(Vector3 pointerPosition)
		{
			DragPosition dragPosition = default(DragPosition);
			if (!TryGetDragPosition(pointerPosition, ref dragPosition))
			{
				return;
			}
			DragAndDropArgs dragAndDropArgs = MakeDragAndDropArgs(dragPosition);
			switch (targetView.RaiseDrop(pointerPosition, dragAndDropArgs))
			{
			default:
				base.dragAndDrop.AcceptDrag();
				break;
			case DragVisualMode.Rejected:
				dragAndDropController.DragCleanup();
				break;
			case DragVisualMode.None:
				if (dragAndDropController.HandleDragAndDrop(dragAndDropArgs) != DragVisualMode.Rejected)
				{
					dragAndDropController.OnDrop(dragAndDropArgs);
					base.dragAndDrop.AcceptDrag();
				}
				else
				{
					dragAndDropController.DragCleanup();
				}
				break;
			}
		}

		internal void HandleDragAndScroll(Vector2 pointerPosition)
		{
			bool flag = pointerPosition.y < targetScrollView.worldBound.yMin + 5f;
			bool flag2 = pointerPosition.y > targetScrollView.worldBound.yMax - 5f;
			if (flag || flag2)
			{
				Vector2 scrollOffset = targetScrollView.scrollOffset + (flag ? Vector2.down : Vector2.up) * 20f;
				scrollOffset.y = Mathf.Clamp(scrollOffset.y, 0f, Mathf.Max(0f, targetScrollView.contentContainer.worldBound.height - targetScrollView.contentViewport.worldBound.height));
				targetScrollView.scrollOffset = scrollOffset;
			}
		}

		private void HandleAutoExpansion(Vector2 pointerPosition)
		{
			ReusableCollectionItem recycledItem = GetRecycledItem(pointerPosition);
			if (recycledItem != null)
			{
				dragAndDropController.HandleAutoExpand(recycledItem, pointerPosition);
			}
		}

		private void ApplyDragAndDropUI(DragPosition dragPosition)
		{
			if (m_LastDragPosition.Equals(dragPosition))
			{
				return;
			}
			if (m_DragHoverBar == null)
			{
				m_DragHoverBar = new VisualElement();
				m_DragHoverBar.AddToClassList(BaseVerticalCollectionView.dragHoverBarUssClassName);
				m_DragHoverBar.style.width = targetView.localBound.width;
				m_DragHoverBar.style.visibility = Visibility.Hidden;
				m_DragHoverBar.pickingMode = PickingMode.Ignore;
				targetView.RegisterCallback<GeometryChangedEvent>(GeometryChangedCallback);
				targetScrollView.contentViewport.Add(m_DragHoverBar);
			}
			if (m_DragHoverItemMarker == null && targetView is BaseTreeView)
			{
				m_DragHoverItemMarker = new VisualElement();
				m_DragHoverItemMarker.AddToClassList(BaseVerticalCollectionView.dragHoverMarkerUssClassName);
				m_DragHoverItemMarker.style.visibility = Visibility.Hidden;
				m_DragHoverItemMarker.pickingMode = PickingMode.Ignore;
				m_DragHoverBar.Add(m_DragHoverItemMarker);
				m_DragHoverSiblingMarker = new VisualElement();
				m_DragHoverSiblingMarker.AddToClassList(BaseVerticalCollectionView.dragHoverMarkerUssClassName);
				m_DragHoverSiblingMarker.style.visibility = Visibility.Hidden;
				m_DragHoverSiblingMarker.pickingMode = PickingMode.Ignore;
				targetScrollView.contentViewport.Add(m_DragHoverSiblingMarker);
			}
			ClearDragAndDropUI(dragCancelled: false);
			m_LastDragPosition = dragPosition;
			switch (dragPosition.dropPosition)
			{
			case DragAndDropPosition.OverItem:
				dragPosition.recycledItem.rootElement.AddToClassList(BaseVerticalCollectionView.itemDragHoverUssClassName);
				break;
			case DragAndDropPosition.BetweenItems:
			{
				if (dragPosition.insertAtIndex == 0)
				{
					PlaceHoverBarAt(0f);
					break;
				}
				ReusableCollectionItem recycledItemFromIndex2 = targetView.GetRecycledItemFromIndex(dragPosition.insertAtIndex - 1);
				ReusableCollectionItem recycledItemFromIndex3 = targetView.GetRecycledItemFromIndex(dragPosition.insertAtIndex);
				PlaceHoverBarAtElement(recycledItemFromIndex2 ?? recycledItemFromIndex3);
				break;
			}
			case DragAndDropPosition.OutsideItems:
			{
				ReusableCollectionItem recycledItemFromIndex = targetView.GetRecycledItemFromIndex(targetView.itemsSource.Count - 1);
				if (recycledItemFromIndex != null)
				{
					PlaceHoverBarAtElement(recycledItemFromIndex);
				}
				else
				{
					PlaceHoverBarAt(0f);
				}
				break;
			}
			default:
				throw new ArgumentOutOfRangeException("dropPosition", dragPosition.dropPosition, "Unsupported dropPosition value");
			}
			void GeometryChangedCallback(GeometryChangedEvent e)
			{
				m_DragHoverBar.style.width = targetView.localBound.width;
			}
		}

		protected virtual bool TryGetDragPosition(Vector2 pointerPosition, ref DragPosition dragPosition)
		{
			ReusableCollectionItem recycledItem = GetRecycledItem(pointerPosition);
			if (recycledItem == null)
			{
				if (!targetView.worldBound.Contains(pointerPosition))
				{
					return false;
				}
				dragPosition.dropPosition = DragAndDropPosition.OutsideItems;
				if (pointerPosition.y >= targetScrollView.contentContainer.worldBound.yMax)
				{
					dragPosition.insertAtIndex = targetView.itemsSource.Count;
				}
				else
				{
					dragPosition.insertAtIndex = 0;
				}
				HandleTreePosition(pointerPosition, ref dragPosition);
				return true;
			}
			if (recycledItem.rootElement.worldBound.yMax - pointerPosition.y < 5f)
			{
				dragPosition.insertAtIndex = recycledItem.index + 1;
				dragPosition.dropPosition = DragAndDropPosition.BetweenItems;
			}
			else if (pointerPosition.y - recycledItem.rootElement.worldBound.yMin > 5f)
			{
				Vector2 scrollOffset = targetScrollView.scrollOffset;
				targetScrollView.ScrollTo(recycledItem.rootElement);
				if (!Mathf.Approximately(scrollOffset.x, targetScrollView.scrollOffset.x) || !Mathf.Approximately(scrollOffset.y, targetScrollView.scrollOffset.y))
				{
					return TryGetDragPosition(pointerPosition, ref dragPosition);
				}
				dragPosition.recycledItem = recycledItem;
				dragPosition.insertAtIndex = recycledItem.index;
				dragPosition.dropPosition = DragAndDropPosition.OverItem;
			}
			else
			{
				dragPosition.insertAtIndex = recycledItem.index;
				dragPosition.dropPosition = DragAndDropPosition.BetweenItems;
			}
			HandleTreePosition(pointerPosition, ref dragPosition);
			return true;
		}

		private void HandleTreePosition(Vector2 pointerPosition, ref DragPosition dragPosition)
		{
			dragPosition.parentId = -1;
			dragPosition.childIndex = -1;
			m_LeftIndentation = -1f;
			m_SiblingBottom = -1f;
			if (targetView is BaseTreeView baseTreeView && dragPosition.insertAtIndex >= 0)
			{
				BaseTreeViewController viewController = baseTreeView.viewController;
				if (dragPosition.dropPosition == DragAndDropPosition.OverItem)
				{
					dragPosition.parentId = viewController.GetIdForIndex(dragPosition.insertAtIndex);
					dragPosition.childIndex = -1;
				}
				else if (dragPosition.insertAtIndex <= 0)
				{
					dragPosition.childIndex = 0;
				}
				else
				{
					HandleSiblingInsertionAtAvailableDepthsAndChangeTargetIfNeeded(ref dragPosition, pointerPosition);
				}
			}
		}

		private void HandleSiblingInsertionAtAvailableDepthsAndChangeTargetIfNeeded(ref DragPosition dragPosition, Vector2 pointerPosition)
		{
			if (!(targetView is BaseTreeView { viewController: var viewController } baseTreeView))
			{
				return;
			}
			int insertAtIndex = dragPosition.insertAtIndex;
			int idForIndex = viewController.GetIdForIndex(insertAtIndex);
			GetPreviousAndNextItemsIgnoringDraggedItems(dragPosition.insertAtIndex, out var previousItemId, out var nextItemId);
			if (previousItemId == -1)
			{
				return;
			}
			bool flag = viewController.HasChildren(previousItemId) && baseTreeView.IsExpanded(previousItemId);
			int indentationDepth = viewController.GetIndentationDepth(previousItemId);
			int indentationDepth2 = viewController.GetIndentationDepth(nextItemId);
			int num = ((nextItemId != -1) ? indentationDepth2 : 0);
			int num2 = viewController.GetIndentationDepth(previousItemId) + (flag ? 1 : 0);
			int num3 = previousItemId;
			float num4 = 15f;
			float num5 = 15f;
			if (indentationDepth > 0)
			{
				VisualElement rootElementForId = baseTreeView.GetRootElementForId(previousItemId);
				VisualElement visualElement = rootElementForId.Q(BaseTreeView.itemIndentUssClassName);
				VisualElement visualElement2 = rootElementForId.Q(BaseTreeView.itemToggleUssClassName);
				num4 = visualElement2.layout.width;
				num5 = visualElement.layout.width / (float)indentationDepth;
			}
			else
			{
				int indentationDepth3 = baseTreeView.viewController.GetIndentationDepth(idForIndex);
				if (indentationDepth3 > 0)
				{
					VisualElement rootElementForId2 = baseTreeView.GetRootElementForId(idForIndex);
					VisualElement visualElement3 = rootElementForId2.Q(BaseTreeView.itemIndentUssClassName);
					VisualElement visualElement4 = rootElementForId2.Q(BaseTreeView.itemToggleUssClassName);
					num4 = visualElement4.layout.width;
					num5 = visualElement3.layout.width / (float)indentationDepth3;
				}
			}
			if (num2 <= num)
			{
				m_LeftIndentation = num4 + num5 * (float)num;
				if (flag)
				{
					dragPosition.parentId = previousItemId;
					dragPosition.childIndex = 0;
				}
				else
				{
					dragPosition.parentId = viewController.GetParentId(previousItemId);
					dragPosition.childIndex = viewController.GetChildIndexForId(nextItemId);
				}
				return;
			}
			int num6 = Mathf.FloorToInt((baseTreeView.scrollView.contentContainer.WorldToLocal(pointerPosition).x - num4) / num5);
			if (num6 >= num2)
			{
				m_LeftIndentation = num4 + num5 * (float)num2;
				if (flag)
				{
					dragPosition.parentId = previousItemId;
					dragPosition.childIndex = 0;
				}
				else
				{
					dragPosition.parentId = viewController.GetParentId(previousItemId);
					dragPosition.childIndex = viewController.GetChildIndexForId(previousItemId) + 1;
				}
				return;
			}
			int num7 = viewController.GetIndentationDepth(num3);
			while (num7 > num && num7 != num6)
			{
				num3 = viewController.GetParentId(num3);
				num7--;
			}
			if (num3 != idForIndex)
			{
				VisualElement rootElementForId3 = baseTreeView.GetRootElementForId(num3);
				if (rootElementForId3 != null)
				{
					VisualElement contentViewport = targetScrollView.contentViewport;
					Rect rect = contentViewport.WorldToLocal(rootElementForId3.worldBound);
					if (contentViewport.localBound.yMin < rect.yMax && rect.yMax < contentViewport.localBound.yMax)
					{
						m_SiblingBottom = rect.yMax;
					}
				}
			}
			dragPosition.parentId = viewController.GetParentId(num3);
			dragPosition.childIndex = viewController.GetChildIndexForId(num3) + 1;
			m_LeftIndentation = num4 + num5 * (float)num7;
		}

		private void GetPreviousAndNextItemsIgnoringDraggedItems(int insertAtIndex, out int previousItemId, out int nextItemId)
		{
			previousItemId = (nextItemId = -1);
			int num = insertAtIndex - 1;
			int i = insertAtIndex;
			while (num >= 0)
			{
				int idForIndex = targetView.viewController.GetIdForIndex(num);
				if (!dragAndDropController.GetSortedSelectedIds().Contains(idForIndex))
				{
					previousItemId = idForIndex;
					break;
				}
				num--;
			}
			for (; i < targetView.itemsSource.Count; i++)
			{
				int idForIndex2 = targetView.viewController.GetIdForIndex(i);
				if (!dragAndDropController.GetSortedSelectedIds().Contains(idForIndex2))
				{
					nextItemId = idForIndex2;
					break;
				}
			}
		}

		protected DragAndDropArgs MakeDragAndDropArgs(DragPosition dragPosition)
		{
			object target = null;
			ReusableCollectionItem recycledItem = dragPosition.recycledItem;
			if (recycledItem != null)
			{
				target = targetView.viewController.GetItemForIndex(recycledItem.index);
			}
			return new DragAndDropArgs
			{
				target = target,
				insertAtIndex = dragPosition.insertAtIndex,
				parentId = dragPosition.parentId,
				childIndex = dragPosition.childIndex,
				dragAndDropPosition = dragPosition.dropPosition,
				dragAndDropData = DragAndDropUtility.GetDragAndDrop(m_Target.panel).data
			};
		}

		private float GetHoverBarTopPosition(ReusableCollectionItem item)
		{
			VisualElement contentViewport = targetScrollView.contentViewport;
			return Mathf.Min(contentViewport.WorldToLocal(item.rootElement.worldBound).yMax, contentViewport.localBound.yMax - 2f);
		}

		private void PlaceHoverBarAtElement(ReusableCollectionItem item)
		{
			PlaceHoverBarAt(GetHoverBarTopPosition(item), m_LeftIndentation, m_SiblingBottom);
		}

		private void PlaceHoverBarAt(float top, float indentationPadding = -1f, float siblingBottom = -1f)
		{
			m_DragHoverBar.style.top = top;
			m_DragHoverBar.style.visibility = Visibility.Visible;
			if (m_DragHoverItemMarker != null)
			{
				m_DragHoverItemMarker.style.visibility = Visibility.Visible;
			}
			if (indentationPadding >= 0f)
			{
				m_DragHoverBar.style.marginLeft = indentationPadding;
				m_DragHoverBar.style.width = targetView.localBound.width - indentationPadding;
				if (siblingBottom > 0f && m_DragHoverSiblingMarker != null)
				{
					m_DragHoverSiblingMarker.style.top = siblingBottom;
					m_DragHoverSiblingMarker.style.visibility = Visibility.Visible;
					m_DragHoverSiblingMarker.style.marginLeft = indentationPadding;
				}
			}
			else
			{
				m_DragHoverBar.style.marginLeft = 0f;
				m_DragHoverBar.style.width = targetView.localBound.width;
			}
		}

		protected override void ClearDragAndDropUI(bool dragCancelled)
		{
			if (dragCancelled)
			{
				dragAndDropController.DragCleanup();
			}
			targetView.elementPanel.cursorManager.ResetCursor();
			m_LastDragPosition = default(DragPosition);
			foreach (ReusableCollectionItem activeItem in targetView.activeItems)
			{
				activeItem.rootElement.RemoveFromClassList(BaseVerticalCollectionView.itemDragHoverUssClassName);
			}
			if (m_DragHoverBar != null)
			{
				m_DragHoverBar.style.visibility = Visibility.Hidden;
			}
			if (m_DragHoverItemMarker != null)
			{
				m_DragHoverItemMarker.style.visibility = Visibility.Hidden;
			}
			if (m_DragHoverSiblingMarker != null)
			{
				m_DragHoverSiblingMarker.style.visibility = Visibility.Hidden;
			}
		}

		protected ReusableCollectionItem GetRecycledItem(Vector3 pointerPosition)
		{
			foreach (ReusableCollectionItem activeItem in targetView.activeItems)
			{
				if (activeItem.rootElement.worldBound.Contains(pointerPosition))
				{
					return activeItem;
				}
			}
			return null;
		}
	}
	internal static class ListViewDraggerExtension
	{
		public static ReusableCollectionItem GetRecycledItemFromId(this BaseVerticalCollectionView listView, int id)
		{
			foreach (ReusableCollectionItem activeItem in listView.activeItems)
			{
				if (activeItem.id.Equals(id))
				{
					return activeItem;
				}
			}
			return null;
		}

		public static ReusableCollectionItem GetRecycledItemFromIndex(this BaseVerticalCollectionView listView, int index)
		{
			foreach (ReusableCollectionItem activeItem in listView.activeItems)
			{
				if (activeItem.index.Equals(index))
				{
					return activeItem;
				}
			}
			return null;
		}
	}
	internal class ListViewDraggerAnimated : ListViewDragger
	{
		private int m_DragStartIndex;

		private int m_CurrentIndex;

		private float m_SelectionHeight;

		private float m_LocalOffsetOnStart;

		private Vector3 m_CurrentPointerPosition;

		private ReusableCollectionItem m_Item;

		private ReusableCollectionItem m_OffsetItem;

		public bool isDragging { get; private set; }

		public ReusableCollectionItem draggedItem => m_Item;

		protected override bool supportsDragEvents => false;

		public ListViewDraggerAnimated(BaseVerticalCollectionView listView)
			: base(listView)
		{
		}

		protected internal override StartDragArgs StartDrag(Vector3 pointerPosition)
		{
			base.targetView.ClearSelection();
			ReusableCollectionItem recycledItem = GetRecycledItem(pointerPosition);
			if (recycledItem == null)
			{
				return new StartDragArgs(string.Empty, DragVisualMode.Rejected);
			}
			base.targetView.SetSelection(recycledItem.index);
			isDragging = true;
			m_Item = recycledItem;
			base.targetView.virtualizationController.StartDragItem(m_Item);
			float y = m_Item.rootElement.layout.y;
			m_SelectionHeight = m_Item.rootElement.layout.height;
			m_Item.rootElement.style.position = Position.Absolute;
			m_Item.rootElement.style.height = m_Item.rootElement.layout.height;
			m_Item.rootElement.style.width = m_Item.rootElement.layout.width;
			m_Item.rootElement.style.top = y;
			m_DragStartIndex = m_Item.index;
			m_CurrentIndex = m_DragStartIndex;
			m_CurrentPointerPosition = pointerPosition;
			m_LocalOffsetOnStart = base.targetScrollView.contentContainer.WorldToLocal(pointerPosition).y - y;
			ReusableCollectionItem recycledItemFromIndex = base.targetView.GetRecycledItemFromIndex(m_CurrentIndex + 1);
			if (recycledItemFromIndex != null)
			{
				m_OffsetItem = recycledItemFromIndex;
				Animate(m_OffsetItem, m_SelectionHeight);
				m_OffsetItem.rootElement.style.paddingTop = m_SelectionHeight;
				if (base.targetView.virtualizationMethod == CollectionVirtualizationMethod.FixedHeight)
				{
					m_OffsetItem.rootElement.style.height = base.targetView.fixedItemHeight + m_SelectionHeight;
				}
			}
			return base.dragAndDropController.SetupDragAndDrop(new int[1] { m_Item.index }, skipText: true);
		}

		protected internal override void UpdateDrag(Vector3 pointerPosition)
		{
			if (m_Item == null)
			{
				return;
			}
			HandleDragAndScroll(pointerPosition);
			m_CurrentPointerPosition = pointerPosition;
			Vector2 vector = base.targetScrollView.contentContainer.WorldToLocal(m_CurrentPointerPosition);
			Rect layout = m_Item.rootElement.layout;
			float height = base.targetScrollView.contentContainer.layout.height;
			layout.y = Mathf.Clamp(vector.y - m_LocalOffsetOnStart, 0f, height - m_SelectionHeight);
			float num = base.targetScrollView.contentContainer.resolvedStyle.paddingTop;
			m_CurrentIndex = -1;
			foreach (ReusableCollectionItem activeItem in base.targetView.activeItems)
			{
				if (activeItem.index < 0 || (activeItem.rootElement.style.display == DisplayStyle.None && !activeItem.isDragGhost))
				{
					continue;
				}
				if (activeItem.index == m_Item.index && activeItem.index < base.targetView.itemsSource.Count - 1)
				{
					float expectedItemHeight = base.targetView.virtualizationController.GetExpectedItemHeight(activeItem.index + 1);
					if (layout.y <= num + expectedItemHeight * 0.5f)
					{
						m_CurrentIndex = activeItem.index;
					}
					continue;
				}
				float expectedItemHeight2 = base.targetView.virtualizationController.GetExpectedItemHeight(activeItem.index);
				if (layout.y <= num + expectedItemHeight2 * 0.5f)
				{
					if (m_CurrentIndex == -1)
					{
						m_CurrentIndex = activeItem.index;
					}
					if (m_OffsetItem != activeItem)
					{
						Animate(m_OffsetItem, 0f);
						Animate(activeItem, m_SelectionHeight);
						m_OffsetItem = activeItem;
					}
					break;
				}
				num += expectedItemHeight2;
			}
			if (m_CurrentIndex == -1)
			{
				m_CurrentIndex = base.targetView.itemsSource.Count;
				Animate(m_OffsetItem, 0f);
				m_OffsetItem = null;
			}
			m_Item.rootElement.layout = layout;
			m_Item.rootElement.BringToFront();
		}

		private void Animate(ReusableCollectionItem element, float paddingTop)
		{
			if (element != null && (element.animator == null || ((!element.animator.isRunning || element.animator.to.paddingTop != paddingTop) && (element.animator.isRunning || !(element.rootElement.style.paddingTop == paddingTop)))))
			{
				element.animator?.Stop();
				element.animator?.Recycle();
				StyleValues to = ((base.targetView.virtualizationMethod == CollectionVirtualizationMethod.FixedHeight) ? new StyleValues
				{
					paddingTop = paddingTop,
					height = base.targetView.ResolveItemHeight() + paddingTop
				} : new StyleValues
				{
					paddingTop = paddingTop
				});
				element.animator = element.rootElement.experimental.animation.Start(to, 500);
				element.animator.KeepAlive();
			}
		}

		protected internal override void OnDrop(Vector3 pointerPosition)
		{
			if (m_Item == null)
			{
				return;
			}
			isDragging = false;
			m_Item.rootElement.ClearManualLayout();
			base.targetView.virtualizationController.EndDrag(m_CurrentIndex);
			if (m_OffsetItem != null)
			{
				m_OffsetItem.animator?.Stop();
				m_OffsetItem.animator?.Recycle();
				m_OffsetItem.animator = null;
				m_OffsetItem.rootElement.style.paddingTop = 0f;
				if (base.targetView.virtualizationMethod == CollectionVirtualizationMethod.FixedHeight)
				{
					m_OffsetItem.rootElement.style.height = base.targetView.ResolveItemHeight();
				}
			}
			DragPosition dragPosition = new DragPosition
			{
				recycledItem = m_Item,
				insertAtIndex = m_CurrentIndex,
				dropPosition = DragAndDropPosition.BetweenItems
			};
			DragAndDropArgs dragAndDropArgs = MakeDragAndDropArgs(dragPosition);
			base.dragAndDropController.OnDrop(dragAndDropArgs);
			base.dragAndDrop.AcceptDrag();
			m_Item = null;
			m_OffsetItem = null;
		}

		protected override void ClearDragAndDropUI(bool dragCancelled)
		{
		}

		protected override bool TryGetDragPosition(Vector2 pointerPosition, ref DragPosition dragPosition)
		{
			dragPosition.recycledItem = m_Item;
			dragPosition.insertAtIndex = m_CurrentIndex;
			dragPosition.dropPosition = DragAndDropPosition.BetweenItems;
			return true;
		}
	}
	internal class ListViewReorderableDragAndDropController : BaseReorderableDragAndDropController
	{
		protected readonly BaseListView m_ListView;

		public ListViewReorderableDragAndDropController(BaseListView view)
			: base(view)
		{
			m_ListView = view;
		}

		public override DragVisualMode HandleDragAndDrop(IListDragAndDropArgs args)
		{
			if (args.dragAndDropPosition == DragAndDropPosition.OverItem || !enableReordering)
			{
				return DragVisualMode.Rejected;
			}
			return (args.dragAndDropData.source == m_ListView) ? DragVisualMode.Move : DragVisualMode.Rejected;
		}

		public override void OnDrop(IListDragAndDropArgs args)
		{
			int insertAtIndex = args.insertAtIndex;
			int num = 0;
			int num2 = 0;
			for (int num3 = m_SortedSelectedIds.Count - 1; num3 >= 0; num3--)
			{
				int id = m_SortedSelectedIds[num3];
				int num4 = m_View.viewController.GetIndexForId(id);
				if (num4 >= 0)
				{
					int num5 = insertAtIndex - num;
					if (num4 >= insertAtIndex)
					{
						num4 += num2;
						num2++;
					}
					else if (num4 < num5)
					{
						num++;
						num5--;
					}
					m_ListView.viewController.Move(num4, num5);
				}
			}
			if (m_ListView.selectionType != SelectionType.None)
			{
				List<int> list = new List<int>();
				for (int i = 0; i < m_SortedSelectedIds.Count; i++)
				{
					list.Add(insertAtIndex - num + i);
				}
				m_ListView.SetSelectionWithoutNotify(list);
			}
			else
			{
				m_ListView.ClearSelection();
			}
		}
	}
	internal class TreeViewReorderableDragAndDropController : BaseReorderableDragAndDropController
	{
		protected class DropData
		{
			public int[] expandedIdsBeforeDrag;

			public int[] draggedIds;

			public int lastItemId = -1;

			public float expandItemBeginTimerMs;

			public Vector2 expandItemBeginPosition;
		}

		private const long k_ExpandUpdateIntervalMs = 10L;

		private const float k_DropExpandTimeoutMs = 700f;

		private const float k_DropDeltaPosition = 100f;

		private const float k_HalfDropBetweenHeight = 4f;

		protected DropData m_DropData = new DropData();

		protected readonly BaseTreeView m_TreeView;

		private IVisualElementScheduledItem m_ExpandDropItemScheduledItem;

		private Action m_ExpandDropItemCallback;

		public TreeViewReorderableDragAndDropController(BaseTreeView view)
			: base(view)
		{
			m_TreeView = view;
			m_ExpandDropItemCallback = ExpandDropItem;
		}

		protected override int CompareId(int id1, int id2)
		{
			if (id1 == id2)
			{
				return id1.CompareTo(id2);
			}
			int num = id1;
			int num2 = id2;
			List<int> value;
			using (CollectionPool<List<int>, int>.Get(out value))
			{
				while (num != -1)
				{
					value.Add(num);
					num = m_TreeView.viewController.GetParentId(num);
				}
				List<int> value2;
				using (CollectionPool<List<int>, int>.Get(out value2))
				{
					while (num2 != -1)
					{
						value2.Add(num2);
						num2 = m_TreeView.viewController.GetParentId(num2);
					}
					value.Add(-1);
					value2.Add(-1);
					for (int i = 0; i < value.Count; i++)
					{
						int item = value[i];
						int num3 = value2.IndexOf(item);
						if (num3 >= 0)
						{
							if (i == 0)
							{
								return -1;
							}
							int id3 = ((i > 0) ? value[i - 1] : id1);
							int id4 = ((num3 > 0) ? value2[num3 - 1] : id2);
							int childIndexForId = m_TreeView.viewController.GetChildIndexForId(id3);
							int childIndexForId2 = m_TreeView.viewController.GetChildIndexForId(id4);
							return childIndexForId.CompareTo(childIndexForId2);
						}
					}
					throw new ArgumentOutOfRangeException("[UI Toolkit] Trying to reorder ids that are not in the same tree.");
				}
			}
		}

		public override StartDragArgs SetupDragAndDrop(IEnumerable<int> itemIds, bool skipText = false)
		{
			StartDragArgs result = base.SetupDragAndDrop(itemIds, skipText);
			m_DropData.draggedIds = GetSortedSelectedIds().ToArray();
			return result;
		}

		public override DragVisualMode HandleDragAndDrop(IListDragAndDropArgs args)
		{
			if (!enableReordering)
			{
				return DragVisualMode.Rejected;
			}
			return (args.dragAndDropData.source == m_TreeView) ? DragVisualMode.Move : DragVisualMode.Rejected;
		}

		public override void OnDrop(IListDragAndDropArgs args)
		{
			int parentId = args.parentId;
			int childIndex = args.childIndex;
			int num = 0;
			bool flag = args.dragAndDropPosition == DragAndDropPosition.OverItem || (parentId == -1 && childIndex == -1);
			List<(int, int)> value;
			using (CollectionPool<List<(int, int)>, (int, int)>.Get(out value))
			{
				int[] draggedIds = m_DropData.draggedIds;
				foreach (int id in draggedIds)
				{
					int parentId2 = m_TreeView.viewController.GetParentId(id);
					int childIndexForId = m_TreeView.viewController.GetChildIndexForId(id);
					value.Add((parentId2, childIndexForId));
					if (flag)
					{
						m_TreeView.viewController.Move(id, parentId, -1, rebuildTree: false);
						continue;
					}
					int childIndex2 = childIndex + num;
					if (parentId2 != parentId || childIndexForId >= childIndex)
					{
						num++;
					}
					m_TreeView.viewController.Move(id, parentId, childIndex2, rebuildTree: false);
				}
				if (args.dragAndDropPosition == DragAndDropPosition.OverItem)
				{
					m_TreeView.viewController.ExpandItem(parentId, expandAllChildren: false, refresh: false);
				}
				m_ExpandDropItemScheduledItem?.Pause();
				m_TreeView.viewController.RebuildTree();
				m_TreeView.RefreshItems();
				for (int j = 0; j < m_DropData.draggedIds.Length; j++)
				{
					int id2 = m_DropData.draggedIds[j];
					(int, int) tuple = value[j];
					int parentId3 = m_TreeView.viewController.GetParentId(id2);
					int childIndexForId2 = m_TreeView.viewController.GetChildIndexForId(id2);
					if (tuple.Item1 != parentId3 || tuple.Item2 != childIndexForId2)
					{
						m_TreeView.viewController.RaiseItemParentChanged(id2, parentId);
					}
				}
			}
		}

		public override void DragCleanup()
		{
			if (m_DropData != null)
			{
				if (m_DropData.expandedIdsBeforeDrag != null)
				{
					RestoreExpanded(new List<int>(m_DropData.expandedIdsBeforeDrag));
				}
				m_DropData = new DropData();
			}
			m_ExpandDropItemScheduledItem?.Pause();
		}

		private void RestoreExpanded(List<int> ids)
		{
			foreach (int allItemId in m_TreeView.viewController.GetAllItemIds())
			{
				if (!ids.Contains(allItemId))
				{
					m_TreeView.CollapseItem(allItemId);
				}
			}
		}

		public override void HandleAutoExpand(ReusableCollectionItem item, Vector2 pointerPosition)
		{
			int id = item.id;
			Rect worldBound = item.bindableElement.worldBound;
			bool flag = new Rect(worldBound.x, worldBound.y + 4f, worldBound.width, worldBound.height - 8f).Contains(pointerPosition);
			Vector2 vector = m_DropData.expandItemBeginPosition - pointerPosition;
			if (id != m_DropData.lastItemId || !flag || vector.sqrMagnitude >= 100f)
			{
				m_DropData.lastItemId = id;
				m_DropData.expandItemBeginTimerMs = Panel.TimeSinceStartupMs();
				m_DropData.expandItemBeginPosition = pointerPosition;
				DelayExpandDropItem();
			}
		}

		private void DelayExpandDropItem()
		{
			if (m_ExpandDropItemScheduledItem == null)
			{
				m_ExpandDropItemScheduledItem = m_TreeView.schedule.Execute(m_ExpandDropItemCallback).Every(10L);
				return;
			}
			m_ExpandDropItemScheduledItem.Pause();
			m_ExpandDropItemScheduledItem.Resume();
		}

		private void ExpandDropItem()
		{
			bool flag = (float)Panel.TimeSinceStartupMs() - m_DropData.expandItemBeginTimerMs > 700f;
			bool flag2 = flag;
			int lastItemId = m_DropData.lastItemId;
			if (!(m_TreeView.viewController.Exists(lastItemId) && flag2))
			{
				return;
			}
			bool flag3 = m_TreeView.viewController.HasChildren(lastItemId);
			bool flag4 = m_TreeView.IsExpanded(lastItemId);
			if (!(!flag3 || flag4))
			{
				DropData dropData = m_DropData;
				if (dropData.expandedIdsBeforeDrag == null)
				{
					dropData.expandedIdsBeforeDrag = m_TreeView.expandedItemIds.ToArray();
				}
				m_DropData.expandItemBeginTimerMs = Panel.TimeSinceStartupMs();
				m_DropData.lastItemId = 0;
				m_TreeView.ExpandItem(lastItemId);
			}
		}
	}
	public class DropdownMenuEventInfo
	{
		public EventModifiers modifiers { get; }

		public Vector2 mousePosition { get; }

		public Vector2 localMousePosition { get; }

		private char character { get; }

		private KeyCode keyCode { get; }

		public DropdownMenuEventInfo(EventBase e)
		{
			if (e is IMouseEvent mouseEvent)
			{
				mousePosition = mouseEvent.mousePosition;
				localMousePosition = mouseEvent.localMousePosition;
				modifiers = mouseEvent.modifiers;
				character = '\0';
				keyCode = KeyCode.None;
			}
			else if (e is IKeyboardEvent keyboardEvent)
			{
				character = keyboardEvent.character;
				keyCode = keyboardEvent.keyCode;
				modifiers = keyboardEvent.modifiers;
				mousePosition = Vector2.zero;
				localMousePosition = Vector2.zero;
			}
		}
	}
	public abstract class DropdownMenuItem
	{
	}
	public class DropdownMenuSeparator : DropdownMenuItem
	{
		public string subMenuPath { get; }

		public DropdownMenuSeparator(string subMenuPath)
		{
			this.subMenuPath = subMenuPath;
		}
	}
	public class DropdownMenuAction : DropdownMenuItem
	{
		[Flags]
		public enum Status
		{
			None = 0,
			Normal = 1,
			Disabled = 2,
			Checked = 4,
			Hidden = 8
		}

		private readonly Action<DropdownMenuAction> actionCallback;

		private readonly Func<DropdownMenuAction, Status> actionStatusCallback;

		public string name { get; }

		public Status status { get; private set; }

		public DropdownMenuEventInfo eventInfo { get; private set; }

		public object userData { get; private set; }

		public static Status AlwaysEnabled(DropdownMenuAction a)
		{
			return Status.Normal;
		}

		public static Status AlwaysDisabled(DropdownMenuAction a)
		{
			return Status.Disabled;
		}

		public DropdownMenuAction(string actionName, Action<DropdownMenuAction> actionCallback, Func<DropdownMenuAction, Status> actionStatusCallback, object userData = null)
		{
			name = actionName;
			this.actionCallback = actionCallback;
			this.actionStatusCallback = actionStatusCallback;
			this.userData = userData;
		}

		public void UpdateActionStatus(DropdownMenuEventInfo eventInfo)
		{
			this.eventInfo = eventInfo;
			status = actionStatusCallback?.Invoke(this) ?? Status.Hidden;
		}

		public void Execute()
		{
			actionCallback?.Invoke(this);
		}
	}
	public class DropdownMenu
	{
		private List<DropdownMenuItem> m_MenuItems = new List<DropdownMenuItem>();

		private DropdownMenuEventInfo m_DropdownMenuEventInfo;

		public List<DropdownMenuItem> MenuItems()
		{
			return m_MenuItems;
		}

		public void AppendAction(string actionName, Action<DropdownMenuAction> action, Func<DropdownMenuAction, DropdownMenuAction.Status> actionStatusCallback, object userData = null)
		{
			DropdownMenuAction item = new DropdownMenuAction(actionName, action, actionStatusCallback, userData);
			m_MenuItems.Add(item);
		}

		public void AppendAction(string actionName, Action<DropdownMenuAction> action, DropdownMenuAction.Status status = DropdownMenuAction.Status.Normal)
		{
			if (status == DropdownMenuAction.Status.Normal)
			{
				AppendAction(actionName, action, DropdownMenuAction.AlwaysEnabled);
				return;
			}
			if (status == DropdownMenuAction.Status.Disabled)
			{
				AppendAction(actionName, action, DropdownMenuAction.AlwaysDisabled);
				return;
			}
			AppendAction(actionName, action, (DropdownMenuAction e) => status);
		}

		public void InsertAction(int atIndex, string actionName, Action<DropdownMenuAction> action, Func<DropdownMenuAction, DropdownMenuAction.Status> actionStatusCallback, object userData = null)
		{
			DropdownMenuAction item = new DropdownMenuAction(actionName, action, actionStatusCallback, userData);
			m_MenuItems.Insert(atIndex, item);
		}

		public void InsertAction(int atIndex, string actionName, Action<DropdownMenuAction> action, DropdownMenuAction.Status status = DropdownMenuAction.Status.Normal)
		{
			if (status == DropdownMenuAction.Status.Normal)
			{
				InsertAction(atIndex, actionName, action, DropdownMenuAction.AlwaysEnabled);
				return;
			}
			if (status == DropdownMenuAction.Status.Disabled)
			{
				InsertAction(atIndex, actionName, action, DropdownMenuAction.AlwaysDisabled);
				return;
			}
			InsertAction(atIndex, actionName, action, (DropdownMenuAction e) => status);
		}

		public void AppendSeparator(string subMenuPath = null)
		{
			if (m_MenuItems.Count > 0 && !(m_MenuItems[m_MenuItems.Count - 1] is DropdownMenuSeparator))
			{
				DropdownMenuSeparator item = new DropdownMenuSeparator(subMenuPath ?? string.Empty);
				m_MenuItems.Add(item);
			}
		}

		public void InsertSeparator(string subMenuPath, int atIndex)
		{
			if (atIndex > 0 && atIndex <= m_MenuItems.Count && !(m_MenuItems[atIndex - 1] is DropdownMenuSeparator))
			{
				DropdownMenuSeparator item = new DropdownMenuSeparator(subMenuPath ?? string.Empty);
				m_MenuItems.Insert(atIndex, item);
			}
		}

		public void RemoveItemAt(int index)
		{
			m_MenuItems.RemoveAt(index);
		}

		public void ClearItems()
		{
			m_MenuItems.Clear();
		}

		public void PrepareForDisplay(EventBase e)
		{
			m_DropdownMenuEventInfo = ((e != null) ? new DropdownMenuEventInfo(e) : null);
			if (m_MenuItems.Count == 0)
			{
				return;
			}
			foreach (DropdownMenuItem menuItem in m_MenuItems)
			{
				if (menuItem is DropdownMenuAction dropdownMenuAction)
				{
					dropdownMenuAction.UpdateActionStatus(m_DropdownMenuEventInfo);
				}
			}
			if (m_MenuItems[m_MenuItems.Count - 1] is DropdownMenuSeparator)
			{
				m_MenuItems.RemoveAt(m_MenuItems.Count - 1);
			}
		}
	}
	internal static class DropdownUtility
	{
		internal static Func<IGenericMenu> MakeDropdownFunc;

		internal static IGenericMenu CreateDropdown()
		{
			IGenericMenu result;
			if (MakeDropdownFunc == null)
			{
				IGenericMenu genericMenu = new GenericDropdownMenu();
				result = genericMenu;
			}
			else
			{
				result = MakeDropdownFunc();
			}
			return result;
		}
	}
	internal enum DispatchMode
	{
		Default = 1,
		Queued = 1,
		Immediate = 2
	}
	public struct EventDispatcherGate : IDisposable, IEquatable<EventDispatcherGate>
	{
		private readonly EventDispatcher m_Dispatcher;

		public EventDispatcherGate(EventDispatcher d)
		{
			if (d == null)
			{
				throw new ArgumentNullException("d");
			}
			m_Dispatcher = d;
			m_Dispatcher.CloseGate();
		}

		public void Dispose()
		{
			m_Dispatcher.OpenGate();
		}

		public bool Equals(EventDispatcherGate other)
		{
			return object.Equals(m_Dispatcher, other.m_Dispatcher);
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			return obj is EventDispatcherGate && Equals((EventDispatcherGate)obj);
		}

		public override int GetHashCode()
		{
			return (m_Dispatcher != null) ? m_Dispatcher.GetHashCode() : 0;
		}

		public static bool operator ==(EventDispatcherGate left, EventDispatcherGate right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(EventDispatcherGate left, EventDispatcherGate right)
		{
			return !left.Equals(right);
		}
	}
	public sealed class EventDispatcher
	{
		private struct EventRecord
		{
			public EventBase m_Event;

			public IPanel m_Panel;
		}

		private struct DispatchContext
		{
			public uint m_GateCount;

			public Queue<EventRecord> m_Queue;
		}

		internal ClickDetector m_ClickDetector = new ClickDetector();

		private List<IEventDispatchingStrategy> m_DispatchingStrategies;

		private static readonly ObjectPool<Queue<EventRecord>> k_EventQueuePool = new ObjectPool<Queue<EventRecord>>(() => new Queue<EventRecord>());

		private Queue<EventRecord> m_Queue;

		private uint m_GateCount;

		private uint m_GateDepth = 0u;

		internal const int k_MaxGateDepth = 500;

		internal const int k_NumberOfEventsWithStackInfo = 10;

		internal const int k_NumberOfEventsWithEventInfo = 100;

		private int m_DispatchStackFrame = 0;

		private EventBase m_CurrentEvent;

		private Stack<DispatchContext> m_DispatchContexts = new Stack<DispatchContext>();

		private static readonly IEventDispatchingStrategy[] s_EditorStrategies = new IEventDispatchingStrategy[9]
		{
			new PointerCaptureDispatchingStrategy(),
			new MouseCaptureDispatchingStrategy(),
			new KeyboardEventDispatchingStrategy(),
			new PointerEventDispatchingStrategy(),
			new MouseEventDispatchingStrategy(),
			new NavigationEventDispatchingStrategy(),
			new CommandEventDispatchingStrategy(),
			new IMGUIEventDispatchingStrategy(),
			new DefaultDispatchingStrategy()
		};

		private bool m_Immediate = false;

		internal PointerDispatchState pointerState { get; } = new PointerDispatchState();

		internal uint GateDepth => m_GateDepth;

		private bool dispatchImmediately => m_Immediate || m_GateCount == 0;

		internal bool processingEvents { get; private set; }

		internal static EventDispatcher CreateDefault()
		{
			return new EventDispatcher(s_EditorStrategies);
		}

		internal static EventDispatcher CreateForRuntime(IList<IEventDispatchingStrategy> strategies)
		{
			return new EventDispatcher(strategies);
		}

		[Obsolete("Please use EventDispatcher.CreateDefault().")]
		internal EventDispatcher()
			: this(s_EditorStrategies)
		{
		}

		private EventDispatcher(IList<IEventDispatchingStrategy> strategies)
		{
			m_DispatchingStrategies = new List<IEventDispatchingStrategy>();
			m_DispatchingStrategies.AddRange(strategies);
			m_Queue = k_EventQueuePool.Get();
		}

		internal void Dispatch(EventBase evt, [JetBrains.Annotations.NotNull] IPanel panel, DispatchMode dispatchMode)
		{
			evt.MarkReceivedByDispatcher();
			if (evt.eventTypeId == EventBase<IMGUIEvent>.TypeId())
			{
				Event imguiEvent = evt.imguiEvent;
				if (imguiEvent.rawType == EventType.Repaint)
				{
					return;
				}
			}
			if (dispatchImmediately || dispatchMode == DispatchMode.Immediate)
			{
				ProcessEvent(evt, panel);
			}
			else if (!HandleRecursiveState(evt))
			{
				evt.Acquire();
				m_Queue.Enqueue(new EventRecord
				{
					m_Event = evt,
					m_Panel = panel
				});
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private bool HandleRecursiveState(EventBase evt)
		{
			if (m_GateDepth <= 400)
			{
				return false;
			}
			if (m_DispatchStackFrame != 0)
			{
				StackTrace stackTrace = new StackTrace(1, fNeedFileInfo: true);
				StringBuilder stringBuilder = new StringBuilder();
				int num = stackTrace.FrameCount - m_DispatchStackFrame;
				stringBuilder.AppendLine($"Recursively dispatching event {evt} from another event {m_CurrentEvent} (depth = {m_GateDepth})");
				for (int i = 0; i < num; i++)
				{
					StackFrame frame = stackTrace.GetFrame(i);
					stringBuilder.Append(frame.GetMethod()).AppendFormat("({0}:{1}", frame.GetFileName(), frame.GetFileLineNumber()).AppendLine(")");
				}
				Debug.LogFormat(LogType.Error, LogOption.NoStacktrace, null, stringBuilder.ToString());
			}
			else
			{
				Debug.LogFormat(LogType.Error, LogOption.NoStacktrace, null, $"Recursively dispatching event {evt} from another event {m_CurrentEvent} (depth = {m_GateDepth})");
			}
			if (m_GateDepth > 500)
			{
				Debug.LogErrorFormat("Ignoring event {0}: too many events dispatched recurively", evt);
				return true;
			}
			return false;
		}

		internal void PushDispatcherContext()
		{
			ProcessEventQueue();
			m_DispatchContexts.Push(new DispatchContext
			{
				m_GateCount = m_GateCount,
				m_Queue = m_Queue
			});
			m_GateCount = 0u;
			m_Queue = k_EventQueuePool.Get();
		}

		internal void PopDispatcherContext()
		{
			Debug.Assert(m_GateCount == 0, "All gates should have been opened before popping dispatch context.");
			Debug.Assert(m_Queue.Count == 0, "Queue should be empty when popping dispatch context.");
			k_EventQueuePool.Release(m_Queue);
			m_GateCount = m_DispatchContexts.Peek().m_GateCount;
			m_Queue = m_DispatchContexts.Peek().m_Queue;
			m_DispatchContexts.Pop();
		}

		internal void CloseGate()
		{
			m_GateCount++;
			m_GateDepth++;
		}

		internal void OpenGate()
		{
			Debug.Assert(m_GateCount != 0);
			if (m_GateCount != 0)
			{
				m_GateCount--;
			}
			try
			{
				if (m_GateCount == 0)
				{
					ProcessEventQueue();
				}
			}
			finally
			{
				Debug.Assert(m_GateDepth != 0, "m_GateDepth > 0");
				if (m_GateDepth != 0)
				{
					m_GateDepth--;
				}
			}
		}

		private void ProcessEventQueue()
		{
			Queue<EventRecord> queue = m_Queue;
			m_Queue = k_EventQueuePool.Get();
			ExitGUIException ex = null;
			try
			{
				processingEvents = true;
				while (queue.Count > 0)
				{
					EventRecord eventRecord = queue.Dequeue();
					EventBase eventBase = eventRecord.m_Event;
					IPanel panel = eventRecord.m_Panel;
					try
					{
						ProcessEvent(eventBase, panel);
					}
					catch (ExitGUIException ex2)
					{
						Debug.Assert(ex == null);
						ex = ex2;
					}
					finally
					{
						eventBase.Dispose();
					}
				}
			}
			finally
			{
				processingEvents = false;
				k_EventQueuePool.Release(queue);
			}
			if (ex != null)
			{
				throw ex;
			}
		}

		private void ProcessEvent(EventBase evt, [JetBrains.Annotations.NotNull] IPanel panel)
		{
			Event imguiEvent = evt.imguiEvent;
			bool flag = imguiEvent != null && imguiEvent.rawType == EventType.Used;
			using (new EventDispatcherGate(this))
			{
				evt.PreDispatch(panel);
				try
				{
					m_CurrentEvent = evt;
					m_DispatchStackFrame = ((m_GateDepth > 490) ? new StackTrace().FrameCount : 0);
					if (!evt.stopDispatch && !evt.isPropagationStopped)
					{
						ApplyDispatchingStrategies(evt, panel, flag);
					}
					PropagationPaths propagationPaths = evt.path;
					if (propagationPaths == null && evt.bubblesOrTricklesDown && evt.leafTarget is VisualElement elem)
					{
						propagationPaths = (evt.path = PropagationPaths.Build(elem, evt));
						EventDebugger.LogPropagationPaths(evt, propagationPaths);
					}
					if (propagationPaths != null)
					{
						foreach (VisualElement targetElement in propagationPaths.targetElements)
						{
							if (targetElement.panel == panel)
							{
								evt.target = targetElement;
								EventDispatchUtilities.ExecuteDefaultAction(evt);
							}
						}
						evt.target = evt.leafTarget;
					}
					else
					{
						VisualElement visualElement = evt.target as VisualElement;
						if (visualElement == null)
						{
							visualElement = (VisualElement)(evt.target = panel.visualTree);
						}
						if (visualElement.panel == panel)
						{
							EventDispatchUtilities.ExecuteDefaultAction(evt);
						}
					}
				}
				finally
				{
					m_CurrentEvent = null;
				}
				evt.PostDispatch(panel);
				m_ClickDetector.ProcessEvent(evt);
				Debug.Assert(flag || evt.isPropagationStopped || imguiEvent == null || imguiEvent.rawType != EventType.Used, "Event is used but not stopped.");
			}
		}

		private void ApplyDispatchingStrategies(EventBase evt, IPanel panel, bool imguiEventIsInitiallyUsed)
		{
			foreach (IEventDispatchingStrategy dispatchingStrategy in m_DispatchingStrategies)
			{
				if (dispatchingStrategy.CanDispatchEvent(evt))
				{
					dispatchingStrategy.DispatchEvent(evt, panel);
					Debug.Assert(imguiEventIsInitiallyUsed || evt.isPropagationStopped || evt.imguiEvent == null || evt.imguiEvent.rawType != EventType.Used, "Unexpected condition: !evt.isPropagationStopped && evt.imguiEvent.rawType == EventType.Used.");
					if (evt.stopDispatch || evt.isPropagationStopped)
					{
						break;
					}
				}
			}
		}
	}
	public interface IPointerCaptureEvent
	{
	}
	internal interface IPointerCaptureEventInternal
	{
		int pointerId { get; }
	}
	[EventCategory(EventCategory.Pointer)]
	public abstract class PointerCaptureEventBase<T> : EventBase<T>, IPointerCaptureEvent, IPointerCaptureEventInternal where T : PointerCaptureEventBase<T>, new()
	{
		public IEventHandler relatedTarget { get; private set; }

		public int pointerId { get; private set; }

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown;
			relatedTarget = null;
			pointerId = PointerId.invalidPointerId;
		}

		public static T GetPooled(IEventHandler target, IEventHandler relatedTarget, int pointerId)
		{
			T val = EventBase<T>.GetPooled();
			val.target = target;
			val.relatedTarget = relatedTarget;
			val.pointerId = pointerId;
			return val;
		}

		protected PointerCaptureEventBase()
		{
			LocalInit();
		}
	}
	public class PointerCaptureOutEvent : PointerCaptureEventBase<PointerCaptureOutEvent>
	{
		static PointerCaptureOutEvent()
		{
			EventBase<PointerCaptureOutEvent>.SetCreateFunction(() => new PointerCaptureOutEvent());
		}
	}
	public class PointerCaptureEvent : PointerCaptureEventBase<PointerCaptureEvent>
	{
		static PointerCaptureEvent()
		{
			EventBase<PointerCaptureEvent>.SetCreateFunction(() => new PointerCaptureEvent());
		}
	}
	public interface IMouseCaptureEvent
	{
	}
	public abstract class MouseCaptureEventBase<T> : PointerCaptureEventBase<T>, IMouseCaptureEvent where T : MouseCaptureEventBase<T>, new()
	{
		public new IEventHandler relatedTarget => base.relatedTarget;

		public static T GetPooled(IEventHandler target, IEventHandler relatedTarget)
		{
			return PointerCaptureEventBase<T>.GetPooled(target, relatedTarget, 0);
		}

		protected override void Init()
		{
			base.Init();
		}
	}
	public class MouseCaptureOutEvent : MouseCaptureEventBase<MouseCaptureOutEvent>
	{
		static MouseCaptureOutEvent()
		{
			EventBase<MouseCaptureOutEvent>.SetCreateFunction(() => new MouseCaptureOutEvent());
		}
	}
	public class MouseCaptureEvent : MouseCaptureEventBase<MouseCaptureEvent>
	{
		static MouseCaptureEvent()
		{
			EventBase<MouseCaptureEvent>.SetCreateFunction(() => new MouseCaptureEvent());
		}
	}
	public interface IChangeEvent
	{
	}
	[EventCategory(EventCategory.ChangeValue)]
	public class ChangeEvent<T> : EventBase<ChangeEvent<T>>, IChangeEvent
	{
		public T previousValue { get; protected set; }

		public T newValue { get; protected set; }

		static ChangeEvent()
		{
			EventBase<ChangeEvent<T>>.SetCreateFunction(() => new ChangeEvent<T>());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown;
			previousValue = default(T);
			newValue = default(T);
		}

		public static ChangeEvent<T> GetPooled(T previousValue, T newValue)
		{
			ChangeEvent<T> changeEvent = EventBase<ChangeEvent<T>>.GetPooled();
			changeEvent.previousValue = previousValue;
			changeEvent.newValue = newValue;
			return changeEvent;
		}

		public ChangeEvent()
		{
			LocalInit();
		}
	}
	internal class CommandEventDispatchingStrategy : IEventDispatchingStrategy
	{
		public bool CanDispatchEvent(EventBase evt)
		{
			return evt is ICommandEvent;
		}

		public void DispatchEvent(EventBase evt, IPanel panel)
		{
			if (panel != null)
			{
				Focusable leafFocusedElement = panel.focusController.GetLeafFocusedElement();
				if (leafFocusedElement != null)
				{
					if (leafFocusedElement.isIMGUIContainer)
					{
						IMGUIContainer iMGUIContainer = (IMGUIContainer)leafFocusedElement;
						if (!evt.Skip(iMGUIContainer) && iMGUIContainer.SendEventToIMGUI(evt))
						{
							evt.StopPropagation();
							evt.PreventDefault();
						}
						if (!evt.isPropagationStopped && evt.propagateToIMGUI)
						{
							evt.skipElements.Add(iMGUIContainer);
							EventDispatchUtilities.PropagateToIMGUIContainer(panel.visualTree, evt);
						}
					}
					else
					{
						evt.target = leafFocusedElement;
						EventDispatchUtilities.PropagateEvent(evt);
						if (!evt.isPropagationStopped && evt.propagateToIMGUI)
						{
							EventDispatchUtilities.PropagateToIMGUIContainer(panel.visualTree, evt);
						}
					}
				}
				else
				{
					EventDispatchUtilities.PropagateToIMGUIContainer(panel.visualTree, evt);
				}
			}
			evt.propagateToIMGUI = false;
			evt.stopDispatch = true;
		}
	}
	public interface ICommandEvent
	{
		string commandName { get; }
	}
	[EventCategory(EventCategory.Command)]
	public abstract class CommandEventBase<T> : EventBase<T>, ICommandEvent where T : CommandEventBase<T>, new()
	{
		private string m_CommandName;

		public string commandName
		{
			get
			{
				if (m_CommandName == null && base.imguiEvent != null)
				{
					return base.imguiEvent.commandName;
				}
				return m_CommandName;
			}
			protected set
			{
				m_CommandName = value;
			}
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.Cancellable;
			commandName = null;
		}

		public static T GetPooled(Event systemEvent)
		{
			T val = EventBase<T>.GetPooled();
			val.imguiEvent = systemEvent;
			return val;
		}

		public static T GetPooled(string commandName)
		{
			T val = EventBase<T>.GetPooled();
			val.commandName = commandName;
			return val;
		}

		protected CommandEventBase()
		{
			LocalInit();
		}
	}
	public class ValidateCommandEvent : CommandEventBase<ValidateCommandEvent>
	{
		static ValidateCommandEvent()
		{
			EventBase<ValidateCommandEvent>.SetCreateFunction(() => new ValidateCommandEvent());
		}
	}
	public class ExecuteCommandEvent : CommandEventBase<ExecuteCommandEvent>
	{
		static ExecuteCommandEvent()
		{
			EventBase<ExecuteCommandEvent>.SetCreateFunction(() => new ExecuteCommandEvent());
		}
	}
	internal class DebuggerEventDispatchingStrategy : IEventDispatchingStrategy
	{
		public bool CanDispatchEvent(EventBase evt)
		{
			return false;
		}

		public void DispatchEvent(EventBase evt, IPanel panel)
		{
		}

		public void PostDispatch(EventBase evt, IPanel panel)
		{
		}
	}
	internal class DefaultDispatchingStrategy : IEventDispatchingStrategy
	{
		public bool CanDispatchEvent(EventBase evt)
		{
			return !(evt is IMGUIEvent);
		}

		public void DispatchEvent(EventBase evt, IPanel panel)
		{
			if (evt.target is VisualElement visualElement && visualElement.panel == panel)
			{
				evt.propagateToIMGUI = visualElement.isIMGUIContainer;
				EventDispatchUtilities.PropagateEvent(evt);
			}
			else if (!evt.isPropagationStopped && panel != null && (evt.propagateToIMGUI || evt.eventTypeId == EventBase<MouseEnterWindowEvent>.TypeId() || evt.eventTypeId == EventBase<MouseLeaveWindowEvent>.TypeId()))
			{
				EventDispatchUtilities.PropagateToIMGUIContainer(panel.visualTree, evt);
			}
			evt.stopDispatch = true;
		}
	}
	internal class ElementUnderPointer
	{
		private VisualElement[] m_PendingTopElementUnderPointer = new VisualElement[PointerId.maxPointers];

		private VisualElement[] m_TopElementUnderPointer = new VisualElement[PointerId.maxPointers];

		private IPointerEvent[] m_TriggerPointerEvent = new IPointerEvent[PointerId.maxPointers];

		private IMouseEvent[] m_TriggerMouseEvent = new IMouseEvent[PointerId.maxPointers];

		private Vector2[] m_PickingPointerPositions = new Vector2[PointerId.maxPointers];

		private bool[] m_IsPickingPointerTemporaries = new bool[PointerId.maxPointers];

		internal VisualElement GetTopElementUnderPointer(int pointerId, out Vector2 pickPosition, out bool isTemporary)
		{
			pickPosition = m_PickingPointerPositions[pointerId];
			isTemporary = m_IsPickingPointerTemporaries[pointerId];
			return m_PendingTopElementUnderPointer[pointerId];
		}

		internal VisualElement GetTopElementUnderPointer(int pointerId)
		{
			return m_PendingTopElementUnderPointer[pointerId];
		}

		internal void SetElementUnderPointer(VisualElement newElementUnderPointer, int pointerId, Vector2 pointerPos)
		{
			Debug.Assert(pointerId >= 0);
			VisualElement visualElement = m_TopElementUnderPointer[pointerId];
			m_IsPickingPointerTemporaries[pointerId] = false;
			m_PickingPointerPositions[pointerId] = pointerPos;
			if (newElementUnderPointer != visualElement)
			{
				m_PendingTopElementUnderPointer[pointerId] = newElementUnderPointer;
				m_TriggerPointerEvent[pointerId] = null;
				m_TriggerMouseEvent[pointerId] = null;
			}
		}

		private Vector2 GetEventPointerPosition(EventBase triggerEvent)
		{
			if (triggerEvent is IPointerEvent pointerEvent)
			{
				return new Vector2(pointerEvent.position.x, pointerEvent.position.y);
			}
			if (!(triggerEvent is IMouseEvent { mousePosition: var mousePosition }))
			{
				return new Vector2(float.MinValue, float.MinValue);
			}
			return mousePosition;
		}

		internal void SetTemporaryElementUnderPointer(VisualElement newElementUnderPointer, int pointerId, EventBase triggerEvent)
		{
			SetElementUnderPointer(newElementUnderPointer, pointerId, triggerEvent, temporary: true);
		}

		internal void SetElementUnderPointer(VisualElement newElementUnderPointer, int pointerId, EventBase triggerEvent)
		{
			SetElementUnderPointer(newElementUnderPointer, pointerId, triggerEvent, temporary: false);
		}

		private void SetElementUnderPointer(VisualElement newElementUnderPointer, int pointerId, EventBase triggerEvent, bool temporary)
		{
			Debug.Assert(pointerId >= 0);
			m_IsPickingPointerTemporaries[pointerId] = temporary;
			m_PickingPointerPositions[pointerId] = GetEventPointerPosition(triggerEvent);
			VisualElement visualElement = m_TopElementUnderPointer[pointerId];
			if (newElementUnderPointer != visualElement)
			{
				m_PendingTopElementUnderPointer[pointerId] = newElementUnderPointer;
				if (m_TriggerPointerEvent[pointerId] == null && triggerEvent is IPointerEvent)
				{
					m_TriggerPointerEvent[pointerId] = triggerEvent as IPointerEvent;
				}
				if (m_TriggerMouseEvent[pointerId] == null && triggerEvent is IMouseEvent)
				{
					m_TriggerMouseEvent[pointerId] = triggerEvent as IMouseEvent;
				}
			}
		}

		internal void CommitElementUnderPointers(EventDispatcher dispatcher, ContextType contextType)
		{
			for (int i = 0; i < m_TopElementUnderPointer.Length; i++)
			{
				IPointerEvent pointerEvent = m_TriggerPointerEvent[i];
				VisualElement visualElement = m_TopElementUnderPointer[i];
				VisualElement visualElement2 = m_PendingTopElementUnderPointer[i];
				if (visualElement2 == visualElement)
				{
					if (pointerEvent != null)
					{
						Vector3 position = pointerEvent.position;
						m_PickingPointerPositions[i] = new Vector2(position.x, position.y);
					}
					else if (m_TriggerMouseEvent[i] != null)
					{
						m_PickingPointerPositions[i] = m_TriggerMouseEvent[i].mousePosition;
					}
					continue;
				}
				m_TopElementUnderPointer[i] = visualElement2;
				if (pointerEvent == null && m_TriggerMouseEvent[i] == null)
				{
					using (new EventDispatcherGate(dispatcher))
					{
						Vector2 pointerPosition = PointerDeviceState.GetPointerPosition(i, contextType);
						PointerEventsHelper.SendOverOut(visualElement, visualElement2, null, pointerPosition, i);
						PointerEventsHelper.SendEnterLeave<PointerLeaveEvent, PointerEnterEvent>(visualElement, visualElement2, null, pointerPosition, i);
						m_PickingPointerPositions[i] = pointerPosition;
						if (i == PointerId.mousePointerId)
						{
							MouseEventsHelper.SendMouseOverMouseOut(visualElement, visualElement2, null, pointerPosition);
							MouseEventsHelper.SendEnterLeave<MouseLeaveEvent, MouseEnterEvent>(visualElement, visualElement2, null, pointerPosition);
						}
					}
				}
				if (pointerEvent != null)
				{
					Vector3 position2 = pointerEvent.position;
					m_PickingPointerPositions[i] = new Vector2(position2.x, position2.y);
					if (pointerEvent is EventBase eventBase && (eventBase.eventTypeId == EventBase<PointerMoveEvent>.TypeId() || eventBase.eventTypeId == EventBase<PointerDownEvent>.TypeId() || eventBase.eventTypeId == EventBase<PointerUpEvent>.TypeId() || eventBase.eventTypeId == EventBase<PointerCancelEvent>.TypeId()))
					{
						using (new EventDispatcherGate(dispatcher))
						{
							PointerEventsHelper.SendOverOut(visualElement, visualElement2, pointerEvent, position2, i);
							PointerEventsHelper.SendEnterLeave<PointerLeaveEvent, PointerEnterEvent>(visualElement, visualElement2, pointerEvent, position2, i);
						}
					}
				}
				m_TriggerPointerEvent[i] = null;
				IMouseEvent mouseEvent = m_TriggerMouseEvent[i];
				if (mouseEvent == null)
				{
					continue;
				}
				Vector2 mousePosition = mouseEvent.mousePosition;
				m_PickingPointerPositions[i] = mousePosition;
				if (mouseEvent is EventBase eventBase2)
				{
					if (eventBase2.eventTypeId == EventBase<MouseMoveEvent>.TypeId() || eventBase2.eventTypeId == EventBase<MouseDownEvent>.TypeId() || eventBase2.eventTypeId == EventBase<MouseUpEvent>.TypeId() || eventBase2.eventTypeId == EventBase<WheelEvent>.TypeId())
					{
						using (new EventDispatcherGate(dispatcher))
						{
							MouseEventsHelper.SendMouseOverMouseOut(visualElement, visualElement2, mouseEvent, mousePosition);
							MouseEventsHelper.SendEnterLeave<MouseLeaveEvent, MouseEnterEvent>(visualElement, visualElement2, mouseEvent, mousePosition);
						}
					}
					else if (eventBase2.eventTypeId == EventBase<MouseEnterWindowEvent>.TypeId() || eventBase2.eventTypeId == EventBase<MouseLeaveWindowEvent>.TypeId())
					{
						using (new EventDispatcherGate(dispatcher))
						{
							PointerEventsHelper.SendOverOut(visualElement, visualElement2, null, mousePosition, i);
							PointerEventsHelper.SendEnterLeave<PointerLeaveEvent, PointerEnterEvent>(visualElement, visualElement2, null, mousePosition, i);
							if (i == PointerId.mousePointerId)
							{
								MouseEventsHelper.SendMouseOverMouseOut(visualElement, visualElement2, mouseEvent, mousePosition);
								MouseEventsHelper.SendEnterLeave<MouseLeaveEvent, MouseEnterEvent>(visualElement, visualElement2, mouseEvent, mousePosition);
							}
						}
					}
				}
				m_TriggerMouseEvent[i] = null;
			}
		}
	}
	public abstract class EventBase : IDisposable
	{
		[Flags]
		internal enum EventPropagation
		{
			None = 0,
			Bubbles = 1,
			TricklesDown = 2,
			Cancellable = 4,
			SkipDisabledElements = 8,
			IgnoreCompositeRoots = 0x10
		}

		[Flags]
		private enum LifeCycleStatus
		{
			None = 0,
			PropagationStopped = 1,
			ImmediatePropagationStopped = 2,
			DefaultPrevented = 4,
			Dispatching = 8,
			Pooled = 0x10,
			IMGUIEventIsValid = 0x20,
			StopDispatch = 0x40,
			PropagateToIMGUI = 0x80,
			Dispatched = 0x200,
			Processed = 0x400,
			ProcessedByFocusController = 0x800
		}

		private static long s_LastTypeId;

		private static ulong s_NextEventId;

		private IEventHandler m_Target;

		private IEventHandler m_CurrentTarget;

		private Event m_ImguiEvent;

		public virtual long eventTypeId => -1L;

		internal EventCategory eventCategory { get; }

		public long timestamp { get; private set; }

		internal ulong eventId { get; private set; }

		internal ulong triggerEventId { get; private set; }

		internal EventPropagation propagation { get; set; }

		internal PropagationPaths path { get; set; }

		private LifeCycleStatus lifeCycleStatus { get; set; }

		public bool bubbles
		{
			get
			{
				return (propagation & EventPropagation.Bubbles) != 0;
			}
			protected set
			{
				if (value)
				{
					propagation |= EventPropagation.Bubbles;
				}
				else
				{
					propagation &= ~EventPropagation.Bubbles;
				}
			}
		}

		public bool tricklesDown
		{
			get
			{
				return (propagation & EventPropagation.TricklesDown) != 0;
			}
			protected set
			{
				if (value)
				{
					propagation |= EventPropagation.TricklesDown;
				}
				else
				{
					propagation &= ~EventPropagation.TricklesDown;
				}
			}
		}

		internal bool bubblesOrTricklesDown => (propagation & (EventPropagation.Bubbles | EventPropagation.TricklesDown)) != 0;

		internal bool skipDisabledElements
		{
			get
			{
				return (propagation & EventPropagation.SkipDisabledElements) != 0;
			}
			set
			{
				if (value)
				{
					propagation |= EventPropagation.SkipDisabledElements;
				}
				else
				{
					propagation &= ~EventPropagation.SkipDisabledElements;
				}
			}
		}

		internal bool ignoreCompositeRoots
		{
			get
			{
				return (propagation & EventPropagation.IgnoreCompositeRoots) != 0;
			}
			set
			{
				if (value)
				{
					propagation |= EventPropagation.IgnoreCompositeRoots;
				}
				else
				{
					propagation &= ~EventPropagation.IgnoreCompositeRoots;
				}
			}
		}

		internal IEventHandler leafTarget { get; private set; }

		public IEventHandler target
		{
			get
			{
				return m_Target;
			}
			set
			{
				m_Target = value;
				if (leafTarget == null)
				{
					leafTarget = value;
				}
			}
		}

		internal List<IEventHandler> skipElements { get; } = new List<IEventHandler>();

		public bool isPropagationStopped
		{
			get
			{
				return (lifeCycleStatus & LifeCycleStatus.PropagationStopped) != 0;
			}
			private set
			{
				if (value)
				{
					lifeCycleStatus |= LifeCycleStatus.PropagationStopped;
				}
				else
				{
					lifeCycleStatus &= ~LifeCycleStatus.PropagationStopped;
				}
			}
		}

		public bool isImmediatePropagationStopped
		{
			get
			{
				return (lifeCycleStatus & LifeCycleStatus.ImmediatePropagationStopped) != 0;
			}
			private set
			{
				if (value)
				{
					lifeCycleStatus |= LifeCycleStatus.ImmediatePropagationStopped;
				}
				else
				{
					lifeCycleStatus &= ~LifeCycleStatus.ImmediatePropagationStopped;
				}
			}
		}

		public bool isDefaultPrevented
		{
			get
			{
				return (lifeCycleStatus & LifeCycleStatus.DefaultPrevented) != 0;
			}
			private set
			{
				if (value)
				{
					lifeCycleStatus |= LifeCycleStatus.DefaultPrevented;
				}
				else
				{
					lifeCycleStatus &= ~LifeCycleStatus.DefaultPrevented;
				}
			}
		}

		public PropagationPhase propagationPhase { get; internal set; }

		public virtual IEventHandler currentTarget
		{
			get
			{
				return m_CurrentTarget;
			}
			internal set
			{
				m_CurrentTarget = value;
				if (imguiEvent != null)
				{
					if (currentTarget is VisualElement ele)
					{
						imguiEvent.mousePosition = ele.WorldToLocal(originalMousePosition);
					}
					else
					{
						imguiEvent.mousePosition = originalMousePosition;
					}
				}
			}
		}

		public bool dispatch
		{
			get
			{
				return (lifeCycleStatus & LifeCycleStatus.Dispatching) != 0;
			}
			internal set
			{
				if (value)
				{
					lifeCycleStatus |= LifeCycleStatus.Dispatching;
					dispatched = true;
				}
				else
				{
					lifeCycleStatus &= ~LifeCycleStatus.Dispatching;
				}
			}
		}

		private bool dispatched
		{
			get
			{
				return (lifeCycleStatus & LifeCycleStatus.Dispatched) != 0;
			}
			set
			{
				if (value)
				{
					lifeCycleStatus |= LifeCycleStatus.Dispatched;
				}
				else
				{
					lifeCycleStatus &= ~LifeCycleStatus.Dispatched;
				}
			}
		}

		internal bool processed
		{
			get
			{
				return (lifeCycleStatus & LifeCycleStatus.Processed) != 0;
			}
			private set
			{
				if (value)
				{
					lifeCycleStatus |= LifeCycleStatus.Processed;
				}
				else
				{
					lifeCycleStatus &= ~LifeCycleStatus.Processed;
				}
			}
		}

		internal bool processedByFocusController
		{
			get
			{
				return (lifeCycleStatus & LifeCycleStatus.ProcessedByFocusController) != 0;
			}
			set
			{
				if (value)
				{
					lifeCycleStatus |= LifeCycleStatus.ProcessedByFocusController;
				}
				else
				{
					lifeCycleStatus &= ~LifeCycleStatus.ProcessedByFocusController;
				}
			}
		}

		internal bool stopDispatch
		{
			get
			{
				return (lifeCycleStatus & LifeCycleStatus.StopDispatch) != 0;
			}
			set
			{
				if (value)
				{
					lifeCycleStatus |= LifeCycleStatus.StopDispatch;
				}
				else
				{
					lifeCycleStatus &= ~LifeCycleStatus.StopDispatch;
				}
			}
		}

		internal bool propagateToIMGUI
		{
			get
			{
				return (lifeCycleStatus & LifeCycleStatus.PropagateToIMGUI) != 0;
			}
			set
			{
				if (value)
				{
					lifeCycleStatus |= LifeCycleStatus.PropagateToIMGUI;
				}
				else
				{
					lifeCycleStatus &= ~LifeCycleStatus.PropagateToIMGUI;
				}
			}
		}

		private bool imguiEventIsValid
		{
			get
			{
				return (lifeCycleStatus & LifeCycleStatus.IMGUIEventIsValid) != 0;
			}
			set
			{
				if (value)
				{
					lifeCycleStatus |= LifeCycleStatus.IMGUIEventIsValid;
				}
				else
				{
					lifeCycleStatus &= ~LifeCycleStatus.IMGUIEventIsValid;
				}
			}
		}

		public Event imguiEvent
		{
			get
			{
				return imguiEventIsValid ? m_ImguiEvent : null;
			}
			protected set
			{
				if (m_ImguiEvent == null)
				{
					m_ImguiEvent = new Event();
				}
				if (value != null)
				{
					m_ImguiEvent.CopyFrom(value);
					imguiEventIsValid = true;
					originalMousePosition = value.mousePosition;
				}
				else
				{
					imguiEventIsValid = false;
				}
			}
		}

		public Vector2 originalMousePosition { get; private set; }

		protected bool pooled
		{
			get
			{
				return (lifeCycleStatus & LifeCycleStatus.Pooled) != 0;
			}
			set
			{
				if (value)
				{
					lifeCycleStatus |= LifeCycleStatus.Pooled;
				}
				else
				{
					lifeCycleStatus &= ~LifeCycleStatus.Pooled;
				}
			}
		}

		protected static long RegisterEventType()
		{
			return ++s_LastTypeId;
		}

		internal void SetTriggerEventId(ulong id)
		{
			triggerEventId = id;
		}

		[Obsolete("Override PreDispatch(IPanel panel) instead.")]
		protected virtual void PreDispatch()
		{
		}

		protected internal virtual void PreDispatch(IPanel panel)
		{
			PreDispatch();
		}

		[Obsolete("Override PostDispatch(IPanel panel) instead.")]
		protected virtual void PostDispatch()
		{
		}

		protected internal virtual void PostDispatch(IPanel panel)
		{
			PostDispatch();
			processed = true;
		}

		internal bool Skip(IEventHandler h)
		{
			return skipElements.Contains(h);
		}

		public void StopPropagation()
		{
			isPropagationStopped = true;
		}

		public void StopImmediatePropagation()
		{
			isPropagationStopped = true;
			isImmediatePropagationStopped = true;
		}

		public void PreventDefault()
		{
			if ((propagation & EventPropagation.Cancellable) == EventPropagation.Cancellable)
			{
				isDefaultPrevented = true;
			}
		}

		internal void MarkReceivedByDispatcher()
		{
			Debug.Assert(!dispatched, "Events cannot be dispatched more than once.");
			dispatched = true;
		}

		protected virtual void Init()
		{
			LocalInit();
		}

		private void LocalInit()
		{
			timestamp = Panel.TimeSinceStartupMs();
			triggerEventId = 0uL;
			eventId = s_NextEventId++;
			propagation = EventPropagation.None;
			path?.Release();
			path = null;
			leafTarget = null;
			target = null;
			skipElements.Clear();
			isPropagationStopped = false;
			isImmediatePropagationStopped = false;
			isDefaultPrevented = false;
			propagationPhase = PropagationPhase.None;
			originalMousePosition = Vector2.zero;
			m_CurrentTarget = null;
			dispatch = false;
			stopDispatch = false;
			propagateToIMGUI = true;
			dispatched = false;
			processed = false;
			processedByFocusController = false;
			imguiEventIsValid = false;
			pooled = false;
		}

		protected EventBase()
			: this(EventCategory.Default)
		{
		}

		internal EventBase(EventCategory category)
		{
			eventCategory = category;
			m_ImguiEvent = null;
			LocalInit();
		}

		internal abstract void Acquire();

		public abstract void Dispose();
	}
	[EventCategory(EventCategory.Default)]
	public abstract class EventBase<T> : EventBase where T : EventBase<T>, new()
	{
		private static readonly long s_TypeId = EventBase.RegisterEventType();

		private static readonly ObjectPool<T> s_Pool = new ObjectPool<T>(() => new T());

		private int m_RefCount;

		internal static readonly EventCategory EventCategory = EventInterestReflectionUtils.GetEventCategory(typeof(T));

		public override long eventTypeId => s_TypeId;

		internal static void SetCreateFunction(Func<T> createMethod)
		{
			s_Pool.CreateFunc = createMethod;
		}

		protected EventBase()
			: base(EventCategory)
		{
			m_RefCount = 0;
		}

		public static long TypeId()
		{
			return s_TypeId;
		}

		protected override void Init()
		{
			base.Init();
			if (m_RefCount != 0)
			{
				Debug.Log("Event improperly released.");
				m_RefCount = 0;
			}
		}

		public static T GetPooled()
		{
			T val = s_Pool.Get();
			val.Init();
			val.pooled = true;
			val.Acquire();
			return val;
		}

		internal static T GetPooled(EventBase e)
		{
			T val = GetPooled();
			if (e != null)
			{
				val.SetTriggerEventId(e.eventId);
			}
			return val;
		}

		private static void ReleasePooled(T evt)
		{
			if (evt.pooled)
			{
				evt.Init();
				s_Pool.Release(evt);
				evt.pooled = false;
			}
		}

		internal override void Acquire()
		{
			m_RefCount++;
		}

		public sealed override void Dispose()
		{
			if (--m_RefCount == 0)
			{
				ReleasePooled((T)this);
			}
		}
	}
	public delegate void EventCallback<in TEventType>(TEventType evt);
	public delegate void EventCallback<in TEventType, in TCallbackArgs>(TEventType evt, TCallbackArgs userArgs);
	internal abstract class EventCallbackFunctorBase
	{
		public CallbackPhase phase { get; }

		public InvokePolicy invokePolicy { get; }

		protected EventCallbackFunctorBase(CallbackPhase phase, InvokePolicy invokePolicy)
		{
			this.phase = phase;
			this.invokePolicy = invokePolicy;
		}

		public abstract void Invoke(EventBase evt, PropagationPhase propagationPhase);

		public abstract bool IsEquivalentTo(long eventTypeId, Delegate callback, CallbackPhase phase);

		protected bool PhaseMatches(PropagationPhase propagationPhase)
		{
			switch (phase)
			{
			case CallbackPhase.TrickleDownAndTarget:
				if (propagationPhase != PropagationPhase.TrickleDown && propagationPhase != PropagationPhase.AtTarget)
				{
					return false;
				}
				break;
			case CallbackPhase.TargetAndBubbleUp:
				if (propagationPhase != PropagationPhase.AtTarget && propagationPhase != PropagationPhase.BubbleUp)
				{
					return false;
				}
				break;
			}
			return true;
		}
	}
	internal class EventCallbackFunctor<TEventType> : EventCallbackFunctorBase where TEventType : EventBase<TEventType>, new()
	{
		private readonly EventCallback<TEventType> m_Callback;

		private readonly long m_EventTypeId;

		public EventCallbackFunctor(EventCallback<TEventType> callback, CallbackPhase phase, InvokePolicy invokePolicy = InvokePolicy.Default)
			: base(phase, invokePolicy)
		{
			m_Callback = callback;
			m_EventTypeId = EventBase<TEventType>.TypeId();
		}

		public override void Invoke(EventBase evt, PropagationPhase propagationPhase)
		{
			if (evt == null)
			{
				throw new ArgumentNullException("evt");
			}
			if (evt.eventTypeId != m_EventTypeId || !PhaseMatches(propagationPhase))
			{
				return;
			}
			using (new EventDebuggerLogCall(m_Callback, evt))
			{
				m_Callback(evt as TEventType);
			}
		}

		public override bool IsEquivalentTo(long eventTypeId, Delegate callback, CallbackPhase phase)
		{
			return m_EventTypeId == eventTypeId && m_Callback == callback && base.phase == phase;
		}
	}
	internal class EventCallbackFunctor<TEventType, TCallbackArgs> : EventCallbackFunctorBase where TEventType : EventBase<TEventType>, new()
	{
		private readonly EventCallback<TEventType, TCallbackArgs> m_Callback;

		private readonly long m_EventTypeId;

		internal TCallbackArgs userArgs { get; set; }

		public EventCallbackFunctor(EventCallback<TEventType, TCallbackArgs> callback, TCallbackArgs userArgs, CallbackPhase phase, InvokePolicy invokePolicy)
			: base(phase, invokePolicy)
		{
			this.userArgs = userArgs;
			m_Callback = callback;
			m_EventTypeId = EventBase<TEventType>.TypeId();
		}

		public override void Invoke(EventBase evt, PropagationPhase propagationPhase)
		{
			if (evt == null)
			{
				throw new ArgumentNullException("evt");
			}
			if (evt.eventTypeId != m_EventTypeId || !PhaseMatches(propagationPhase))
			{
				return;
			}
			using (new EventDebuggerLogCall(m_Callback, evt))
			{
				m_Callback(evt as TEventType, userArgs);
			}
		}

		public override bool IsEquivalentTo(long eventTypeId, Delegate callback, CallbackPhase phase)
		{
			return m_EventTypeId == eventTypeId && m_Callback == callback && base.phase == phase;
		}
	}
	public enum TrickleDown
	{
		NoTrickleDown,
		TrickleDown
	}
	internal enum CallbackPhase
	{
		TargetAndBubbleUp = 1,
		TrickleDownAndTarget
	}
	internal enum InvokePolicy
	{
		Default,
		IncludeDisabled
	}
	internal class EventCallbackListPool
	{
		private readonly Stack<EventCallbackList> m_Stack = new Stack<EventCallbackList>();

		public EventCallbackList Get(EventCallbackList initializer)
		{
			EventCallbackList eventCallbackList;
			if (m_Stack.Count == 0)
			{
				eventCallbackList = ((initializer == null) ? new EventCallbackList() : new EventCallbackList(initializer));
			}
			else
			{
				eventCallbackList = m_Stack.Pop();
				if (initializer != null)
				{
					eventCallbackList.AddRange(initializer);
				}
			}
			return eventCallbackList;
		}

		public void Release(EventCallbackList element)
		{
			element.Clear();
			m_Stack.Push(element);
		}
	}
	internal class EventCallbackList
	{
		private List<EventCallbackFunctorBase> m_List;

		public int trickleDownCallbackCount { get; private set; }

		public int bubbleUpCallbackCount { get; private set; }

		public int Count => m_List.Count;

		public EventCallbackFunctorBase this[int i]
		{
			get
			{
				return m_List[i];
			}
			set
			{
				m_List[i] = value;
			}
		}

		public EventCallbackList()
		{
			m_List = new List<EventCallbackFunctorBase>();
			trickleDownCallbackCount = 0;
			bubbleUpCallbackCount = 0;
		}

		public EventCallbackList(EventCallbackList source)
		{
			m_List = new List<EventCallbackFunctorBase>(source.m_List);
			trickleDownCallbackCount = 0;
			bubbleUpCallbackCount = 0;
		}

		public bool Contains(long eventTypeId, Delegate callback, CallbackPhase phase)
		{
			return Find(eventTypeId, callback, phase) != null;
		}

		public EventCallbackFunctorBase Find(long eventTypeId, Delegate callback, CallbackPhase phase)
		{
			for (int i = 0; i < m_List.Count; i++)
			{
				if (m_List[i].IsEquivalentTo(eventTypeId, callback, phase))
				{
					return m_List[i];
				}
			}
			return null;
		}

		public bool Remove(long eventTypeId, Delegate callback, CallbackPhase phase)
		{
			for (int i = 0; i < m_List.Count; i++)
			{
				if (m_List[i].IsEquivalentTo(eventTypeId, callback, phase))
				{
					m_List.RemoveAt(i);
					switch (phase)
					{
					case CallbackPhase.TrickleDownAndTarget:
						trickleDownCallbackCount--;
						break;
					case CallbackPhase.TargetAndBubbleUp:
						bubbleUpCallbackCount--;
						break;
					}
					return true;
				}
			}
			return false;
		}

		public void Add(EventCallbackFunctorBase item)
		{
			m_List.Add(item);
			if (item.phase == CallbackPhase.TrickleDownAndTarget)
			{
				trickleDownCallbackCount++;
			}
			else if (item.phase == CallbackPhase.TargetAndBubbleUp)
			{
				bubbleUpCallbackCount++;
			}
		}

		public void AddRange(EventCallbackList list)
		{
			m_List.AddRange(list.m_List);
			foreach (EventCallbackFunctorBase item in list.m_List)
			{
				if (item.phase == CallbackPhase.TrickleDownAndTarget)
				{
					trickleDownCallbackCount++;
				}
				else if (item.phase == CallbackPhase.TargetAndBubbleUp)
				{
					bubbleUpCallbackCount++;
				}
			}
		}

		public void Clear()
		{
			m_List.Clear();
			trickleDownCallbackCount = 0;
			bubbleUpCallbackCount = 0;
		}
	}
	internal class EventCallbackRegistry
	{
		private static readonly EventCallbackListPool s_ListPool = new EventCallbackListPool();

		private EventCallbackList m_Callbacks;

		private EventCallbackList m_TemporaryCallbacks;

		private int m_IsInvoking;

		private static EventCallbackList GetCallbackList(EventCallbackList initializer = null)
		{
			return s_ListPool.Get(initializer);
		}

		private static void ReleaseCallbackList(EventCallbackList toRelease)
		{
			s_ListPool.Release(toRelease);
		}

		public EventCallbackRegistry()
		{
			m_IsInvoking = 0;
		}

		private EventCallbackList GetCallbackListForWriting()
		{
			if (m_IsInvoking > 0)
			{
				if (m_TemporaryCallbacks == null)
				{
					if (m_Callbacks != null)
					{
						m_TemporaryCallbacks = GetCallbackList(m_Callbacks);
					}
					else
					{
						m_TemporaryCallbacks = GetCallbackList();
					}
				}
				return m_TemporaryCallbacks;
			}
			if (m_Callbacks == null)
			{
				m_Callbacks = GetCallbackList();
			}
			return m_Callbacks;
		}

		private EventCallbackList GetCallbackListForReading()
		{
			if (m_TemporaryCallbacks != null)
			{
				return m_TemporaryCallbacks;
			}
			return m_Callbacks;
		}

		private bool ShouldRegisterCallback(long eventTypeId, Delegate callback, CallbackPhase phase)
		{
			if ((object)callback == null)
			{
				return false;
			}
			EventCallbackList callbackListForReading = GetCallbackListForReading();
			if (callbackListForReading != null)
			{
				return !callbackListForReading.Contains(eventTypeId, callback, phase);
			}
			return true;
		}

		private bool UnregisterCallback(long eventTypeId, Delegate callback, TrickleDown useTrickleDown)
		{
			if ((object)callback == null)
			{
				return false;
			}
			EventCallbackList callbackListForWriting = GetCallbackListForWriting();
			CallbackPhase phase = ((useTrickleDown != TrickleDown.TrickleDown) ? CallbackPhase.TargetAndBubbleUp : CallbackPhase.TrickleDownAndTarget);
			return callbackListForWriting.Remove(eventTypeId, callback, phase);
		}

		public void RegisterCallback<TEventType>(EventCallback<TEventType> callback, TrickleDown useTrickleDown = TrickleDown.NoTrickleDown, InvokePolicy invokePolicy = InvokePolicy.Default) where TEventType : EventBase<TEventType>, new()
		{
			if (callback == null)
			{
				throw new ArgumentException("callback parameter is null");
			}
			long eventTypeId = EventBase<TEventType>.TypeId();
			CallbackPhase phase = ((useTrickleDown != TrickleDown.TrickleDown) ? CallbackPhase.TargetAndBubbleUp : CallbackPhase.TrickleDownAndTarget);
			EventCallbackList callbackListForReading = GetCallbackListForReading();
			if (callbackListForReading == null || !callbackListForReading.Contains(eventTypeId, callback, phase))
			{
				callbackListForReading = GetCallbackListForWriting();
				callbackListForReading.Add(new EventCallbackFunctor<TEventType>(callback, phase, invokePolicy));
			}
		}

		public void RegisterCallback<TEventType, TCallbackArgs>(EventCallback<TEventType, TCallbackArgs> callback, TCallbackArgs userArgs, TrickleDown useTrickleDown = TrickleDown.NoTrickleDown, InvokePolicy invokePolicy = InvokePolicy.Default) where TEventType : EventBase<TEventType>, new()
		{
			if (callback == null)
			{
				throw new ArgumentException("callback parameter is null");
			}
			long eventTypeId = EventBase<TEventType>.TypeId();
			CallbackPhase phase = ((useTrickleDown != TrickleDown.TrickleDown) ? CallbackPhase.TargetAndBubbleUp : CallbackPhase.TrickleDownAndTarget);
			EventCallbackList callbackListForReading = GetCallbackListForReading();
			if (callbackListForReading != null && callbackListForReading.Find(eventTypeId, callback, phase) is EventCallbackFunctor<TEventType, TCallbackArgs> eventCallbackFunctor)
			{
				eventCallbackFunctor.userArgs = userArgs;
				return;
			}
			callbackListForReading = GetCallbackListForWriting();
			callbackListForReading.Add(new EventCallbackFunctor<TEventType, TCallbackArgs>(callback, userArgs, phase, invokePolicy));
		}

		public bool UnregisterCallback<TEventType>(EventCallback<TEventType> callback, TrickleDown useTrickleDown = TrickleDown.NoTrickleDown) where TEventType : EventBase<TEventType>, new()
		{
			long eventTypeId = EventBase<TEventType>.TypeId();
			return UnregisterCallback(eventTypeId, callback, useTrickleDown);
		}

		public bool UnregisterCallback<TEventType, TCallbackArgs>(EventCallback<TEventType, TCallbackArgs> callback, TrickleDown useTrickleDown = TrickleDown.NoTrickleDown) where TEventType : EventBase<TEventType>, new()
		{
			long eventTypeId = EventBase<TEventType>.TypeId();
			return UnregisterCallback(eventTypeId, callback, useTrickleDown);
		}

		internal bool TryGetUserArgs<TEventType, TCallbackArgs>(EventCallback<TEventType, TCallbackArgs> callback, TrickleDown useTrickleDown, out TCallbackArgs userArgs) where TEventType : EventBase<TEventType>, new()
		{
			userArgs = default(TCallbackArgs);
			if (callback == null)
			{
				return false;
			}
			EventCallbackList callbackListForReading = GetCallbackListForReading();
			long eventTypeId = EventBase<TEventType>.TypeId();
			CallbackPhase phase = ((useTrickleDown != TrickleDown.TrickleDown) ? CallbackPhase.TargetAndBubbleUp : CallbackPhase.TrickleDownAndTarget);
			if (!(callbackListForReading.Find(eventTypeId, callback, phase) is EventCallbackFunctor<TEventType, TCallbackArgs> eventCallbackFunctor))
			{
				return false;
			}
			userArgs = eventCallbackFunctor.userArgs;
			return true;
		}

		public void InvokeCallbacks(EventBase evt, PropagationPhase propagationPhase)
		{
			if (m_Callbacks == null)
			{
				return;
			}
			m_IsInvoking++;
			bool flag = evt.skipDisabledElements && evt.currentTarget is VisualElement visualElement && !visualElement.enabledInHierarchy;
			for (int i = 0; i < m_Callbacks.Count; i++)
			{
				if (evt.isImmediatePropagationStopped)
				{
					break;
				}
				if (!flag || m_Callbacks[i].invokePolicy == InvokePolicy.IncludeDisabled)
				{
					m_Callbacks[i].Invoke(evt, propagationPhase);
				}
			}
			m_IsInvoking--;
			if (m_IsInvoking == 0 && m_TemporaryCallbacks != null)
			{
				ReleaseCallbackList(m_Callbacks);
				m_Callbacks = GetCallbackList(m_TemporaryCallbacks);
				ReleaseCallbackList(m_TemporaryCallbacks);
				m_TemporaryCallbacks = null;
			}
		}

		public bool HasTrickleDownHandlers()
		{
			return m_Callbacks != null && m_Callbacks.trickleDownCallbackCount > 0;
		}

		public bool HasBubbleHandlers()
		{
			return m_Callbacks != null && m_Callbacks.bubbleUpCallbackCount > 0;
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	internal struct EventDebuggerLogCall : IDisposable
	{
		public EventDebuggerLogCall(Delegate callback, EventBase evt)
		{
		}

		public void Dispose()
		{
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	internal struct EventDebuggerLogIMGUICall : IDisposable
	{
		public EventDebuggerLogIMGUICall(EventBase evt)
		{
		}

		public void Dispose()
		{
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	internal struct EventDebuggerLogExecuteDefaultAction : IDisposable
	{
		public EventDebuggerLogExecuteDefaultAction(EventBase evt)
		{
		}

		public void Dispose()
		{
		}
	}
	internal class EventDebugger
	{
		internal struct HistogramRecord
		{
			public long count;

			public long duration;
		}

		private Dictionary<IPanel, List<EventDebuggerCallTrace>> m_EventCalledObjects;

		private Dictionary<IPanel, List<EventDebuggerDefaultActionTrace>> m_EventDefaultActionObjects;

		private Dictionary<IPanel, List<EventDebuggerPathTrace>> m_EventPathObjects;

		private Dictionary<IPanel, List<EventDebuggerTrace>> m_EventProcessedEvents;

		private Dictionary<IPanel, Stack<EventDebuggerTrace>> m_StackOfProcessedEvent;

		private Dictionary<IPanel, Dictionary<long, int>> m_EventTypeProcessedCount;

		private readonly Dictionary<IPanel, long> m_ModificationCount;

		private readonly bool m_Log;

		public IPanel panel { get; set; }

		public bool isReplaying { get; private set; }

		public float playbackSpeed { get; set; } = 1f;

		public bool isPlaybackPaused { get; set; }

		public Dictionary<long, int> eventTypeProcessedCount
		{
			get
			{
				Dictionary<long, int> value;
				return m_EventTypeProcessedCount.TryGetValue(panel, out value) ? value : null;
			}
		}

		public bool suspended { get; set; }

		public void UpdateModificationCount()
		{
			if (panel != null)
			{
				if (!m_ModificationCount.TryGetValue(panel, out var value))
				{
					value = 0L;
				}
				value++;
				m_ModificationCount[panel] = value;
			}
		}

		public void BeginProcessEvent(EventBase evt, IEventHandler mouseCapture)
		{
			AddBeginProcessEvent(evt, mouseCapture);
			UpdateModificationCount();
		}

		public void EndProcessEvent(EventBase evt, long duration, IEventHandler mouseCapture)
		{
			AddEndProcessEvent(evt, duration, mouseCapture);
			UpdateModificationCount();
		}

		public void LogCall(int cbHashCode, string cbName, EventBase evt, bool propagationHasStopped, bool immediatePropagationHasStopped, bool defaultHasBeenPrevented, long duration, IEventHandler mouseCapture)
		{
			AddCallObject(cbHashCode, cbName, evt, propagationHasStopped, immediatePropagationHasStopped, defaultHasBeenPrevented, duration, mouseCapture);
			UpdateModificationCount();
		}

		public void LogIMGUICall(EventBase evt, long duration, IEventHandler mouseCapture)
		{
			AddIMGUICall(evt, duration, mouseCapture);
			UpdateModificationCount();
		}

		public void LogExecuteDefaultAction(EventBase evt, PropagationPhase phase, long duration, IEventHandler mouseCapture)
		{
			AddExecuteDefaultAction(evt, phase, duration, mouseCapture);
			UpdateModificationCount();
		}

		public static void LogPropagationPaths(EventBase evt, PropagationPaths paths)
		{
		}

		private void LogPropagationPathsInternal(EventBase evt, PropagationPaths paths)
		{
			PropagationPaths paths2 = ((paths == null) ? new PropagationPaths() : new PropagationPaths(paths));
			AddPropagationPaths(evt, paths2);
			UpdateModificationCount();
		}

		public List<EventDebuggerCallTrace> GetCalls(IPanel panel, EventDebuggerEventRecord evt = null)
		{
			if (!m_EventCalledObjects.TryGetValue(panel, out var value))
			{
				return null;
			}
			if (evt != null && value != null)
			{
				List<EventDebuggerCallTrace> list = new List<EventDebuggerCallTrace>();
				foreach (EventDebuggerCallTrace item in value)
				{
					if (item.eventBase.eventId == evt.eventId)
					{
						list.Add(item);
					}
				}
				value = list;
			}
			return value;
		}

		public List<EventDebuggerDefaultActionTrace> GetDefaultActions(IPanel panel, EventDebuggerEventRecord evt = null)
		{
			if (!m_EventDefaultActionObjects.TryGetValue(panel, out var value))
			{
				return null;
			}
			if (evt != null && value != null)
			{
				List<EventDebuggerDefaultActionTrace> list = new List<EventDebuggerDefaultActionTrace>();
				foreach (EventDebuggerDefaultActionTrace item in value)
				{
					if (item.eventBase.eventId == evt.eventId)
					{
						list.Add(item);
					}
				}
				value = list;
			}
			return value;
		}

		public List<EventDebuggerPathTrace> GetPropagationPaths(IPanel panel, EventDebuggerEventRecord evt = null)
		{
			if (!m_EventPathObjects.TryGetValue(panel, out var value))
			{
				return null;
			}
			if (evt != null && value != null)
			{
				List<EventDebuggerPathTrace> list = new List<EventDebuggerPathTrace>();
				foreach (EventDebuggerPathTrace item in value)
				{
					if (item.eventBase.eventId == evt.eventId)
					{
						list.Add(item);
					}
				}
				value = list;
			}
			return value;
		}

		public List<EventDebuggerTrace> GetBeginEndProcessedEvents(IPanel panel, EventDebuggerEventRecord evt = null)
		{
			if (!m_EventProcessedEvents.TryGetValue(panel, out var value))
			{
				return null;
			}
			if (evt != null && value != null)
			{
				List<EventDebuggerTrace> list = new List<EventDebuggerTrace>();
				foreach (EventDebuggerTrace item in value)
				{
					if (item.eventBase.eventId == evt.eventId)
					{
						list.Add(item);
					}
				}
				value = list;
			}
			return value;
		}

		public long GetModificationCount(IPanel panel)
		{
			if (panel == null)
			{
				return -1L;
			}
			if (!m_ModificationCount.TryGetValue(panel, out var value))
			{
				value = -1L;
			}
			return value;
		}

		public void ClearLogs()
		{
			UpdateModificationCount();
			if (panel == null)
			{
				m_EventCalledObjects.Clear();
				m_EventDefaultActionObjects.Clear();
				m_EventPathObjects.Clear();
				m_EventProcessedEvents.Clear();
				m_StackOfProcessedEvent.Clear();
				m_EventTypeProcessedCount.Clear();
				return;
			}
			m_EventCalledObjects.Remove(panel);
			m_EventDefaultActionObjects.Remove(panel);
			m_EventPathObjects.Remove(panel);
			m_EventProcessedEvents.Remove(panel);
			m_StackOfProcessedEvent.Remove(panel);
			if (m_EventTypeProcessedCount.TryGetValue(panel, out var value))
			{
				value.Clear();
			}
		}

		public void SaveReplaySessionFromSelection(string path, List<EventDebuggerEventRecord> eventList)
		{
			if (!string.IsNullOrEmpty(path))
			{
				EventDebuggerRecordList obj = new EventDebuggerRecordList
				{
					eventList = eventList
				};
				string contents = JsonUtility.ToJson(obj);
				File.WriteAllText(path, contents);
				Debug.Log("Saved under: " + path);
			}
		}

		public EventDebuggerRecordList LoadReplaySession(string path)
		{
			if (string.IsNullOrEmpty(path))
			{
				return null;
			}
			string json = File.ReadAllText(path);
			return JsonUtility.FromJson<EventDebuggerRecordList>(json);
		}

		public IEnumerator ReplayEvents(IEnumerable<EventDebuggerEventRecord> eventBases, Action<int, int> refreshList)
		{
			if (eventBases != null)
			{
				isReplaying = true;
				IEnumerator doReplay = DoReplayEvents(eventBases, refreshList);
				while (doReplay.MoveNext())
				{
					yield return null;
				}
			}
		}

		public void StopPlayback()
		{
			isReplaying = false;
			isPlaybackPaused = false;
		}

		private IEnumerator DoReplayEvents(IEnumerable<EventDebuggerEventRecord> eventBases, Action<int, int> refreshList)
		{
			List<EventDebuggerEventRecord> sortedEvents = eventBases.OrderBy((EventDebuggerEventRecord e) => e.timestamp).ToList();
			int sortedEventsCount = sortedEvents.Count;
			for (int i = 0; i < sortedEventsCount && isReplaying; i++)
			{
				EventDebuggerEventRecord eventBase = sortedEvents[i];
				Event newEvent = new Event
				{
					button = eventBase.button,
					clickCount = eventBase.clickCount,
					modifiers = eventBase.modifiers,
					mousePosition = eventBase.mousePosition
				};
				if (eventBase.eventTypeId == EventBase<MouseMoveEvent>.TypeId() && eventBase.hasUnderlyingPhysicalEvent)
				{
					newEvent.type = EventType.MouseMove;
					panel.dispatcher.Dispatch(UIElementsUtility.CreateEvent(newEvent, EventType.MouseMove), panel, DispatchMode.Default);
				}
				else if (eventBase.eventTypeId == EventBase<MouseDownEvent>.TypeId() && eventBase.hasUnderlyingPhysicalEvent)
				{
					newEvent.type = EventType.MouseDown;
					panel.dispatcher.Dispatch(UIElementsUtility.CreateEvent(newEvent, EventType.MouseDown), panel, DispatchMode.Default);
				}
				else if (eventBase.eventTypeId == EventBase<MouseUpEvent>.TypeId() && eventBase.hasUnderlyingPhysicalEvent)
				{
					newEvent.type = EventType.MouseUp;
					panel.dispatcher.Dispatch(UIElementsUtility.CreateEvent(newEvent, EventType.MouseUp), panel, DispatchMode.Default);
				}
				else if (eventBase.eventTypeId == EventBase<ContextClickEvent>.TypeId() && eventBase.hasUnderlyingPhysicalEvent)
				{
					newEvent.type = EventType.ContextClick;
					panel.dispatcher.Dispatch(UIElementsUtility.CreateEvent(newEvent, EventType.ContextClick), panel, DispatchMode.Default);
				}
				else if (eventBase.eventTypeId == EventBase<MouseEnterWindowEvent>.TypeId() && eventBase.hasUnderlyingPhysicalEvent)
				{
					newEvent.type = EventType.MouseEnterWindow;
					panel.dispatcher.Dispatch(UIElementsUtility.CreateEvent(newEvent, EventType.MouseEnterWindow), panel, DispatchMode.Default);
				}
				else if (eventBase.eventTypeId == EventBase<MouseLeaveWindowEvent>.TypeId() && eventBase.hasUnderlyingPhysicalEvent)
				{
					newEvent.type = EventType.MouseLeaveWindow;
					panel.dispatcher.Dispatch(UIElementsUtility.CreateEvent(newEvent, EventType.MouseLeaveWindow), panel, DispatchMode.Default);
				}
				else if (eventBase.eventTypeId == EventBase<PointerMoveEvent>.TypeId() && eventBase.hasUnderlyingPhysicalEvent)
				{
					newEvent.type = EventType.MouseMove;
					panel.dispatcher.Dispatch(UIElementsUtility.CreateEvent(newEvent, EventType.MouseMove), panel, DispatchMode.Default);
				}
				else if (eventBase.eventTypeId == EventBase<PointerDownEvent>.TypeId() && eventBase.hasUnderlyingPhysicalEvent)
				{
					newEvent.type = EventType.MouseDown;
					panel.dispatcher.Dispatch(UIElementsUtility.CreateEvent(newEvent, EventType.MouseDown), panel, DispatchMode.Default);
				}
				else if (eventBase.eventTypeId == EventBase<PointerUpEvent>.TypeId() && eventBase.hasUnderlyingPhysicalEvent)
				{
					newEvent.type = EventType.MouseUp;
					panel.dispatcher.Dispatch(UIElementsUtility.CreateEvent(newEvent, EventType.MouseUp), panel, DispatchMode.Default);
				}
				else if (eventBase.eventTypeId == EventBase<WheelEvent>.TypeId() && eventBase.hasUnderlyingPhysicalEvent)
				{
					newEvent.type = EventType.ScrollWheel;
					newEvent.delta = eventBase.delta;
					panel.dispatcher.Dispatch(UIElementsUtility.CreateEvent(newEvent, EventType.ScrollWheel), panel, DispatchMode.Default);
				}
				else if (eventBase.eventTypeId == EventBase<KeyDownEvent>.TypeId())
				{
					newEvent.type = EventType.KeyDown;
					newEvent.character = eventBase.character;
					newEvent.keyCode = eventBase.keyCode;
					panel.dispatcher.Dispatch(UIElementsUtility.CreateEvent(newEvent, EventType.KeyDown), panel, DispatchMode.Default);
				}
				else if (eventBase.eventTypeId == EventBase<KeyUpEvent>.TypeId())
				{
					newEvent.type = EventType.KeyUp;
					newEvent.character = eventBase.character;
					newEvent.keyCode = eventBase.keyCode;
					panel.dispatcher.Dispatch(UIElementsUtility.CreateEvent(newEvent, EventType.KeyUp), panel, DispatchMode.Default);
				}
				else if (eventBase.eventTypeId == EventBase<NavigationMoveEvent>.TypeId())
				{
					panel.dispatcher.Dispatch(NavigationMoveEvent.GetPooled(eventBase.navigationDirection, eventBase.deviceType, eventBase.modifiers), panel, DispatchMode.Default);
				}
				else if (eventBase.eventTypeId == EventBase<NavigationSubmitEvent>.TypeId())
				{
					panel.dispatcher.Dispatch(NavigationEventBase<NavigationSubmitEvent>.GetPooled(eventBase.deviceType, eventBase.modifiers), panel, DispatchMode.Default);
				}
				else if (eventBase.eventTypeId == EventBase<NavigationCancelEvent>.TypeId())
				{
					panel.dispatcher.Dispatch(NavigationEventBase<NavigationCancelEvent>.GetPooled(eventBase.deviceType, eventBase.modifiers), panel, DispatchMode.Default);
				}
				else if (eventBase.eventTypeId == EventBase<ValidateCommandEvent>.TypeId())
				{
					newEvent.type = EventType.ValidateCommand;
					newEvent.commandName = eventBase.commandName;
					panel.dispatcher.Dispatch(UIElementsUtility.CreateEvent(newEvent, EventType.ValidateCommand), panel, DispatchMode.Default);
				}
				else
				{
					if (eventBase.eventTypeId != EventBase<ExecuteCommandEvent>.TypeId())
					{
						if (eventBase.eventTypeId == EventBase<IMGUIEvent>.TypeId())
						{
							Debug.Log("Skipped IMGUI event (" + eventBase.eventBaseName + "): " + eventBase);
							IEnumerator awaitSkipped = AwaitForNextEvent(i);
							while (awaitSkipped.MoveNext())
							{
								yield return null;
							}
						}
						else
						{
							Debug.Log("Skipped event (" + eventBase.eventBaseName + "): " + eventBase);
							IEnumerator awaitSkipped2 = AwaitForNextEvent(i);
							while (awaitSkipped2.MoveNext())
							{
								yield return null;
							}
						}
						continue;
					}
					newEvent.type = EventType.ExecuteCommand;
					newEvent.commandName = eventBase.commandName;
					panel.dispatcher.Dispatch(UIElementsUtility.CreateEvent(newEvent, EventType.ExecuteCommand), panel, DispatchMode.Default);
				}
				refreshList?.Invoke(i, sortedEventsCount);
				Debug.Log($"Replayed event {eventBase.eventId.ToString()} ({eventBase.eventBaseName}): {newEvent}");
				IEnumerator await = AwaitForNextEvent(i);
				while (await.MoveNext())
				{
					yield return null;
				}
			}
			isReplaying = false;
			IEnumerator AwaitForNextEvent(int currentIndex)
			{
				if (currentIndex != sortedEvents.Count - 1)
				{
					long deltaTimestampMs = sortedEvents[currentIndex + 1].timestamp - sortedEvents[currentIndex].timestamp;
					float timeMs = 0f;
					while (timeMs < (float)deltaTimestampMs)
					{
						if (isPlaybackPaused)
						{
							yield return null;
						}
						else
						{
							long time = Panel.TimeSinceStartupMs();
							yield return null;
							long delta = Panel.TimeSinceStartupMs() - time;
							timeMs += (float)delta * playbackSpeed;
						}
					}
				}
			}
		}

		public Dictionary<string, HistogramRecord> ComputeHistogram(List<EventDebuggerEventRecord> eventBases)
		{
			if (panel == null || !m_EventProcessedEvents.TryGetValue(panel, out var value))
			{
				return null;
			}
			if (value == null)
			{
				return null;
			}
			Dictionary<string, HistogramRecord> dictionary = new Dictionary<string, HistogramRecord>();
			foreach (EventDebuggerTrace item in value)
			{
				if (eventBases == null || eventBases.Count == 0 || eventBases.Contains(item.eventBase))
				{
					string eventBaseName = item.eventBase.eventBaseName;
					long num = item.duration;
					long num2 = 1L;
					if (dictionary.TryGetValue(eventBaseName, out var value2))
					{
						num += value2.duration;
						num2 += value2.count;
					}
					dictionary[eventBaseName] = new HistogramRecord
					{
						count = num2,
						duration = num
					};
				}
			}
			return dictionary;
		}

		public EventDebugger()
		{
			m_EventCalledObjects = new Dictionary<IPanel, List<EventDebuggerCallTrace>>();
			m_EventDefaultActionObjects = new Dictionary<IPanel, List<EventDebuggerDefaultActionTrace>>();
			m_EventPathObjects = new Dictionary<IPanel, List<EventDebuggerPathTrace>>();
			m_StackOfProcessedEvent = new Dictionary<IPanel, Stack<EventDebuggerTrace>>();
			m_EventProcessedEvents = new Dictionary<IPanel, List<EventDebuggerTrace>>();
			m_EventTypeProcessedCount = new Dictionary<IPanel, Dictionary<long, int>>();
			m_ModificationCount = new Dictionary<IPanel, long>();
			m_Log = true;
		}

		private void AddCallObject(int cbHashCode, string cbName, EventBase evt, bool propagationHasStopped, bool immediatePropagationHasStopped, bool defaultHasBeenPrevented, long duration, IEventHandler mouseCapture)
		{
			if (!suspended && m_Log)
			{
				EventDebuggerCallTrace item = new EventDebuggerCallTrace(panel, evt, cbHashCode, cbName, propagationHasStopped, immediatePropagationHasStopped, defaultHasBeenPrevented, duration, mouseCapture);
				if (!m_EventCalledObjects.TryGetValue(panel, out var value))
				{
					value = new List<EventDebuggerCallTrace>();
					m_EventCalledObjects.Add(panel, value);
				}
				value.Add(item);
			}
		}

		private void AddExecuteDefaultAction(EventBase evt, PropagationPhase phase, long duration, IEventHandler mouseCapture)
		{
			if (!suspended && m_Log)
			{
				EventDebuggerDefaultActionTrace item = new EventDebuggerDefaultActionTrace(panel, evt, phase, duration, mouseCapture);
				if (!m_EventDefaultActionObjects.TryGetValue(panel, out var value))
				{
					value = new List<EventDebuggerDefaultActionTrace>();
					m_EventDefaultActionObjects.Add(panel, value);
				}
				value.Add(item);
			}
		}

		private void AddPropagationPaths(EventBase evt, PropagationPaths paths)
		{
			if (!suspended && m_Log)
			{
				EventDebuggerPathTrace item = new EventDebuggerPathTrace(panel, evt, paths);
				if (!m_EventPathObjects.TryGetValue(panel, out var value))
				{
					value = new List<EventDebuggerPathTrace>();
					m_EventPathObjects.Add(panel, value);
				}
				value.Add(item);
			}
		}

		private void AddIMGUICall(EventBase evt, long duration, IEventHandler mouseCapture)
		{
			if (!suspended && m_Log)
			{
				EventDebuggerCallTrace item = new EventDebuggerCallTrace(panel, evt, 0, "OnGUI", propagationHasStopped: false, immediatePropagationHasStopped: false, defaultHasBeenPrevented: false, duration, mouseCapture);
				if (!m_EventCalledObjects.TryGetValue(panel, out var value))
				{
					value = new List<EventDebuggerCallTrace>();
					m_EventCalledObjects.Add(panel, value);
				}
				value.Add(item);
			}
		}

		private void AddBeginProcessEvent(EventBase evt, IEventHandler mouseCapture)
		{
			if (suspended)
			{
				return;
			}
			EventDebuggerTrace eventDebuggerTrace = new EventDebuggerTrace(panel, evt, -1L, mouseCapture);
			if (!m_StackOfProcessedEvent.TryGetValue(panel, out var value))
			{
				value = new Stack<EventDebuggerTrace>();
				m_StackOfProcessedEvent.Add(panel, value);
			}
			if (!m_EventProcessedEvents.TryGetValue(panel, out var value2))
			{
				value2 = new List<EventDebuggerTrace>();
				m_EventProcessedEvents.Add(panel, value2);
			}
			value2.Add(eventDebuggerTrace);
			value.Push(eventDebuggerTrace);
			if (m_EventTypeProcessedCount.TryGetValue(panel, out var value3))
			{
				if (!value3.TryGetValue(eventDebuggerTrace.eventBase.eventTypeId, out var value4))
				{
					value4 = 0;
				}
				value3[eventDebuggerTrace.eventBase.eventTypeId] = value4 + 1;
			}
		}

		private void AddEndProcessEvent(EventBase evt, long duration, IEventHandler mouseCapture)
		{
			if (suspended)
			{
				return;
			}
			bool flag = false;
			if (m_StackOfProcessedEvent.TryGetValue(panel, out var value) && value.Count > 0)
			{
				EventDebuggerTrace eventDebuggerTrace = value.Peek();
				if (eventDebuggerTrace.eventBase.eventId == evt.eventId)
				{
					value.Pop();
					eventDebuggerTrace.duration = duration;
					if (eventDebuggerTrace.eventBase.target == null)
					{
						eventDebuggerTrace.eventBase.target = evt.target;
					}
					flag = true;
				}
			}
			if (flag)
			{
				return;
			}
			EventDebuggerTrace eventDebuggerTrace2 = new EventDebuggerTrace(panel, evt, duration, mouseCapture);
			if (!m_EventProcessedEvents.TryGetValue(panel, out var value2))
			{
				value2 = new List<EventDebuggerTrace>();
				m_EventProcessedEvents.Add(panel, value2);
			}
			value2.Add(eventDebuggerTrace2);
			if (m_EventTypeProcessedCount.TryGetValue(panel, out var value3))
			{
				if (!value3.TryGetValue(eventDebuggerTrace2.eventBase.eventTypeId, out var value4))
				{
					value4 = 0;
				}
				value3[eventDebuggerTrace2.eventBase.eventTypeId] = value4 + 1;
			}
		}

		public static string GetObjectDisplayName(object obj, bool withHashCode = true)
		{
			if (obj == null)
			{
				return string.Empty;
			}
			Type type = obj.GetType();
			string text = GetTypeDisplayName(type);
			if (obj is VisualElement)
			{
				VisualElement visualElement = obj as VisualElement;
				if (!string.IsNullOrEmpty(visualElement.name))
				{
					text = text + "#" + visualElement.name;
				}
			}
			if (withHashCode)
			{
				text = text + " (" + obj.GetHashCode().ToString("x8") + ")";
			}
			return text;
		}

		public static string GetTypeDisplayName(Type type)
		{
			return type.IsGenericType ? (type.Name.TrimEnd('`', '1') + "<" + type.GetGenericArguments()[0].Name + ">") : type.Name;
		}
	}
	[Serializable]
	internal class EventDebuggerRecordList
	{
		public List<EventDebuggerEventRecord> eventList;
	}
	[Serializable]
	internal class EventDebuggerEventRecord
	{
		[field: SerializeField]
		public string eventBaseName { get; private set; }

		[field: SerializeField]
		public long eventTypeId { get; private set; }

		[field: SerializeField]
		public ulong eventId { get; private set; }

		[field: SerializeField]
		private ulong triggerEventId { get; set; }

		[field: SerializeField]
		internal long timestamp { get; private set; }

		public IEventHandler target { get; set; }

		private List<IEventHandler> skipElements { get; set; }

		[field: SerializeField]
		public bool hasUnderlyingPhysicalEvent { get; private set; }

		private bool isPropagationStopped { get; set; }

		private bool isImmediatePropagationStopped { get; set; }

		private bool isDefaultPrevented { get; set; }

		public PropagationPhase propagationPhase { get; private set; }

		private IEventHandler currentTarget { get; set; }

		private bool dispatch { get; set; }

		private Vector2 originalMousePosition { get; set; }

		public EventModifiers modifiers { get; private set; }

		[field: SerializeField]
		public Vector2 mousePosition { get; private set; }

		[field: SerializeField]
		public int clickCount { get; private set; }

		[field: SerializeField]
		public int button { get; private set; }

		[field: SerializeField]
		public int pressedButtons { get; private set; }

		[field: SerializeField]
		public Vector3 delta { get; private set; }

		[field: SerializeField]
		public char character { get; private set; }

		[field: SerializeField]
		public KeyCode keyCode { get; private set; }

		[field: SerializeField]
		public string commandName { get; private set; }

		[field: SerializeField]
		public NavigationDeviceType deviceType { get; private set; }

		[field: SerializeField]
		public NavigationMoveEvent.Direction navigationDirection { get; private set; }

		private void Init(EventBase evt)
		{
			Type type = evt.GetType();
			eventBaseName = EventDebugger.GetTypeDisplayName(type);
			eventTypeId = evt.eventTypeId;
			eventId = evt.eventId;
			triggerEventId = evt.triggerEventId;
			timestamp = evt.timestamp;
			target = evt.target;
			skipElements = evt.skipElements;
			isPropagationStopped = evt.isPropagationStopped;
			isImmediatePropagationStopped = evt.isImmediatePropagationStopped;
			isDefaultPrevented = evt.isDefaultPrevented;
			IMouseEvent mouseEvent = evt as IMouseEvent;
			IMouseEventInternal mouseEventInternal = evt as IMouseEventInternal;
			hasUnderlyingPhysicalEvent = mouseEvent != null && mouseEventInternal != null && mouseEventInternal.triggeredByOS;
			propagationPhase = evt.propagationPhase;
			originalMousePosition = evt.originalMousePosition;
			currentTarget = evt.currentTarget;
			dispatch = evt.dispatch;
			if (mouseEvent != null)
			{
				modifiers = mouseEvent.modifiers;
				mousePosition = mouseEvent.mousePosition;
				button = mouseEvent.button;
				pressedButtons = mouseEvent.pressedButtons;
				clickCount = mouseEvent.clickCount;
				if (mouseEvent is WheelEvent wheelEvent)
				{
					delta = wheelEvent.delta;
				}
			}
			if (evt is IPointerEvent pointerEvent)
			{
				IPointerEventInternal pointerEventInternal = evt as IPointerEventInternal;
				hasUnderlyingPhysicalEvent = pointerEvent != null && pointerEventInternal != null && pointerEventInternal.triggeredByOS;
				modifiers = pointerEvent.modifiers;
				mousePosition = pointerEvent.position;
				button = pointerEvent.button;
				pressedButtons = pointerEvent.pressedButtons;
				clickCount = pointerEvent.clickCount;
			}
			if (evt is IKeyboardEvent keyboardEvent)
			{
				modifiers = keyboardEvent.modifiers;
				character = keyboardEvent.character;
				keyCode = keyboardEvent.keyCode;
			}
			if (evt is ICommandEvent commandEvent)
			{
				commandName = commandEvent.commandName;
			}
			if (evt is INavigationEvent navigationEvent)
			{
				deviceType = navigationEvent.deviceType;
				if (evt is NavigationMoveEvent navigationMoveEvent)
				{
					navigationDirection = navigationMoveEvent.direction;
				}
			}
		}

		public EventDebuggerEventRecord(EventBase evt)
		{
			Init(evt);
		}

		public string TimestampString()
		{
			long ticks = (long)((float)timestamp / 1000f * 10000000f);
			return new DateTime(ticks).ToString("HH:mm:ss.ffffff");
		}
	}
	internal class EventDebuggerTrace
	{
		public EventDebuggerEventRecord eventBase { get; }

		public IEventHandler focusedElement { get; }

		public IEventHandler mouseCapture { get; }

		public long duration { get; set; }

		public EventDebuggerTrace(IPanel panel, EventBase evt, long duration, IEventHandler mouseCapture)
		{
			eventBase = new EventDebuggerEventRecord(evt);
			focusedElement = panel?.focusController?.focusedElement;
			this.mouseCapture = mouseCapture;
			this.duration = duration;
		}
	}
	internal class EventDebuggerCallTrace : EventDebuggerTrace
	{
		public int callbackHashCode { get; }

		public string callbackName { get; }

		public bool propagationHasStopped { get; }

		public bool immediatePropagationHasStopped { get; }

		public bool defaultHasBeenPrevented { get; }

		public EventDebuggerCallTrace(IPanel panel, EventBase evt, int cbHashCode, string cbName, bool propagationHasStopped, bool immediatePropagationHasStopped, bool defaultHasBeenPrevented, long duration, IEventHandler mouseCapture)
			: base(panel, evt, duration, mouseCapture)
		{
			callbackHashCode = cbHashCode;
			callbackName = cbName;
			this.propagationHasStopped = propagationHasStopped;
			this.immediatePropagationHasStopped = immediatePropagationHasStopped;
			this.defaultHasBeenPrevented = defaultHasBeenPrevented;
		}
	}
	internal class EventDebuggerDefaultActionTrace : EventDebuggerTrace
	{
		public PropagationPhase phase { get; }

		public string targetName => base.eventBase.target.GetType().FullName;

		public EventDebuggerDefaultActionTrace(IPanel panel, EventBase evt, PropagationPhase phase, long duration, IEventHandler mouseCapture)
			: base(panel, evt, duration, mouseCapture)
		{
			this.phase = phase;
		}
	}
	internal class EventDebuggerPathTrace : EventDebuggerTrace
	{
		public PropagationPaths paths { get; }

		public EventDebuggerPathTrace(IPanel panel, EventBase evt, PropagationPaths paths)
			: base(panel, evt, -1L, null)
		{
			this.paths = paths;
		}
	}
	public interface IEventHandler
	{
		void SendEvent(EventBase e);

		void HandleEvent(EventBase evt);

		bool HasTrickleDownHandlers();

		bool HasBubbleUpHandlers();
	}
	public abstract class CallbackEventHandler : IEventHandler
	{
		internal bool isIMGUIContainer = false;

		private EventCallbackRegistry m_CallbackRegistry;

		internal const string ExecuteDefaultActionName = "ExecuteDefaultAction";

		internal const string ExecuteDefaultActionAtTargetName = "ExecuteDefaultActionAtTarget";

		public void RegisterCallback<TEventType>(EventCallback<TEventType> callback, TrickleDown useTrickleDown = TrickleDown.NoTrickleDown) where TEventType : EventBase<TEventType>, new()
		{
			if (m_CallbackRegistry == null)
			{
				m_CallbackRegistry = new EventCallbackRegistry();
			}
			m_CallbackRegistry.RegisterCallback(callback, useTrickleDown);
			AddEventCategories<TEventType>();
		}

		private void AddEventCategories<TEventType>() where TEventType : EventBase<TEventType>, new()
		{
			if (this is VisualElement visualElement)
			{
				visualElement.eventCallbackCategories |= 1 << (int)EventBase<TEventType>.EventCategory;
			}
		}

		public void RegisterCallback<TEventType, TUserArgsType>(EventCallback<TEventType, TUserArgsType> callback, TUserArgsType userArgs, TrickleDown useTrickleDown = TrickleDown.NoTrickleDown) where TEventType : EventBase<TEventType>, new()
		{
			if (m_CallbackRegistry == null)
			{
				m_CallbackRegistry = new EventCallbackRegistry();
			}
			m_CallbackRegistry.RegisterCallback(callback, userArgs, useTrickleDown);
			AddEventCategories<TEventType>();
		}

		internal void RegisterCallback<TEventType>(EventCallback<TEventType> callback, InvokePolicy invokePolicy, TrickleDown useTrickleDown = TrickleDown.NoTrickleDown) where TEventType : EventBase<TEventType>, new()
		{
			if (m_CallbackRegistry == null)
			{
				m_CallbackRegistry = new EventCallbackRegistry();
			}
			m_CallbackRegistry.RegisterCallback(callback, useTrickleDown, invokePolicy);
			AddEventCategories<TEventType>();
		}

		public void UnregisterCallback<TEventType>(EventCallback<TEventType> callback, TrickleDown useTrickleDown = TrickleDown.NoTrickleDown) where TEventType : EventBase<TEventType>, new()
		{
			if (m_CallbackRegistry != null)
			{
				m_CallbackRegistry.UnregisterCallback(callback, useTrickleDown);
			}
		}

		public void UnregisterCallback<TEventType, TUserArgsType>(EventCallback<TEventType, TUserArgsType> callback, TrickleDown useTrickleDown = TrickleDown.NoTrickleDown) where TEventType : EventBase<TEventType>, new()
		{
			if (m_CallbackRegistry != null)
			{
				m_CallbackRegistry.UnregisterCallback(callback, useTrickleDown);
			}
		}

		internal bool TryGetUserArgs<TEventType, TCallbackArgs>(EventCallback<TEventType, TCallbackArgs> callback, TrickleDown useTrickleDown, out TCallbackArgs userData) where TEventType : EventBase<TEventType>, new()
		{
			userData = default(TCallbackArgs);
			if (m_CallbackRegistry != null)
			{
				return m_CallbackRegistry.TryGetUserArgs(callback, useTrickleDown, out userData);
			}
			return false;
		}

		public abstract void SendEvent(EventBase e);

		internal abstract void SendEvent(EventBase e, DispatchMode dispatchMode);

		internal void HandleEventAtTargetPhase(EventBase evt)
		{
			evt.currentTarget = evt.target;
			evt.propagationPhase = PropagationPhase.AtTarget;
			HandleEventAtCurrentTargetAndPhase(evt);
			evt.propagationPhase = PropagationPhase.DefaultActionAtTarget;
			HandleEventAtCurrentTargetAndPhase(evt);
		}

		internal void HandleEventAtTargetAndDefaultPhase(EventBase evt)
		{
			HandleEventAtTargetPhase(evt);
			evt.propagationPhase = PropagationPhase.DefaultAction;
			HandleEventAtCurrentTargetAndPhase(evt);
		}

		internal void HandleEventAtCurrentTargetAndPhase(EventBase evt)
		{
			HandleEvent(evt);
		}

		void IEventHandler.HandleEvent(EventBase evt)
		{
			HandleEventAtCurrentTargetAndPhase(evt);
		}

		[Obsolete("The virtual method CallbackEventHandler.HandleEvent is deprecated and will be removed in a future release. Please override ExecuteDefaultAction instead.")]
		public virtual void HandleEvent(EventBase evt)
		{
			if (evt == null)
			{
				return;
			}
			switch (evt.propagationPhase)
			{
			case PropagationPhase.TrickleDown:
			case PropagationPhase.BubbleUp:
				if (!evt.isPropagationStopped)
				{
					m_CallbackRegistry?.InvokeCallbacks(evt, evt.propagationPhase);
				}
				if (isIMGUIContainer && !evt.isPropagationStopped)
				{
					((IMGUIContainer)this).ProcessEvent(evt);
				}
				break;
			case PropagationPhase.AtTarget:
				if (!evt.isPropagationStopped)
				{
					m_CallbackRegistry?.InvokeCallbacks(evt, PropagationPhase.TrickleDown);
				}
				if (!evt.isPropagationStopped)
				{
					m_CallbackRegistry?.InvokeCallbacks(evt, PropagationPhase.BubbleUp);
				}
				if (isIMGUIContainer && !evt.isPropagationStopped)
				{
					((IMGUIContainer)this).ProcessEvent(evt);
				}
				break;
			case PropagationPhase.DefaultActionAtTarget:
				if (evt.isDefaultPrevented)
				{
					break;
				}
				using (new EventDebuggerLogExecuteDefaultAction(evt))
				{
					if (evt.skipDisabledElements && this is VisualElement { enabledInHierarchy: false })
					{
						ExecuteDefaultActionDisabledAtTarget(evt);
					}
					else
					{
						ExecuteDefaultActionAtTarget(evt);
					}
					break;
				}
			case PropagationPhase.DefaultAction:
				if (evt.isDefaultPrevented)
				{
					break;
				}
				using (new EventDebuggerLogExecuteDefaultAction(evt))
				{
					if (evt.skipDisabledElements && this is VisualElement { enabledInHierarchy: false })
					{
						ExecuteDefaultActionDisabled(evt);
					}
					else
					{
						ExecuteDefaultAction(evt);
					}
					break;
				}
			}
		}

		public bool HasTrickleDownHandlers()
		{
			return m_CallbackRegistry != null && m_CallbackRegistry.HasTrickleDownHandlers();
		}

		public bool HasBubbleUpHandlers()
		{
			return m_CallbackRegistry != null && m_CallbackRegistry.HasBubbleHandlers();
		}

		[EventInterest(EventInterestOptions.Inherit)]
		protected virtual void ExecuteDefaultActionAtTarget(EventBase evt)
		{
		}

		[EventInterest(EventInterestOptions.Inherit)]
		protected virtual void ExecuteDefaultAction(EventBase evt)
		{
		}

		[EventInterest(EventInterestOptions.Inherit)]
		internal virtual void ExecuteDefaultActionDisabledAtTarget(EventBase evt)
		{
		}

		[EventInterest(EventInterestOptions.Inherit)]
		internal virtual void ExecuteDefaultActionDisabled(EventBase evt)
		{
		}
	}
	public interface IFocusEvent
	{
		Focusable relatedTarget { get; }

		FocusChangeDirection direction { get; }
	}
	[EventCategory(EventCategory.Focus)]
	public abstract class FocusEventBase<T> : EventBase<T>, IFocusEvent where T : FocusEventBase<T>, new()
	{
		public Focusable relatedTarget { get; private set; }

		public FocusChangeDirection direction { get; private set; }

		protected FocusController focusController { get; private set; }

		internal bool IsFocusDelegated { get; private set; }

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.TricklesDown;
			relatedTarget = null;
			direction = FocusChangeDirection.unspecified;
			focusController = null;
		}

		public static T GetPooled(IEventHandler target, Focusable relatedTarget, FocusChangeDirection direction, FocusController focusController, bool bIsFocusDelegated = false)
		{
			T val = EventBase<T>.GetPooled();
			val.target = target;
			val.relatedTarget = relatedTarget;
			val.direction = direction;
			val.focusController = focusController;
			val.IsFocusDelegated = bIsFocusDelegated;
			return val;
		}

		protected FocusEventBase()
		{
			LocalInit();
		}
	}
	public class FocusOutEvent : FocusEventBase<FocusOutEvent>
	{
		static FocusOutEvent()
		{
			EventBase<FocusOutEvent>.SetCreateFunction(() => new FocusOutEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown;
		}

		public FocusOutEvent()
		{
			LocalInit();
		}
	}
	public class BlurEvent : FocusEventBase<BlurEvent>
	{
		static BlurEvent()
		{
			EventBase<BlurEvent>.SetCreateFunction(() => new BlurEvent());
		}

		protected internal override void PreDispatch(IPanel panel)
		{
			base.PreDispatch(panel);
			if (base.relatedTarget == null)
			{
				base.focusController.ProcessPendingFocusChange(null);
			}
		}
	}
	public class FocusInEvent : FocusEventBase<FocusInEvent>
	{
		static FocusInEvent()
		{
			EventBase<FocusInEvent>.SetCreateFunction(() => new FocusInEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown;
		}

		public FocusInEvent()
		{
			LocalInit();
		}
	}
	public class FocusEvent : FocusEventBase<FocusEvent>
	{
		static FocusEvent()
		{
			EventBase<FocusEvent>.SetCreateFunction(() => new FocusEvent());
		}

		protected internal override void PreDispatch(IPanel panel)
		{
			base.PreDispatch(panel);
			base.focusController.ProcessPendingFocusChange(base.target as Focusable);
		}
	}
	public enum PropagationPhase
	{
		None = 0,
		TrickleDown = 1,
		AtTarget = 2,
		DefaultActionAtTarget = 5,
		BubbleUp = 3,
		DefaultAction = 4
	}
	internal interface IEventDispatchingStrategy
	{
		bool CanDispatchEvent(EventBase evt);

		void DispatchEvent(EventBase evt, IPanel panel);
	}
	internal static class EventDispatchUtilities
	{
		public static void PropagateEvent(EventBase evt)
		{
			if (!(evt.target is VisualElement visualElement))
			{
				return;
			}
			Debug.Assert(!evt.dispatch, "Event is being dispatched recursively.");
			evt.dispatch = true;
			if (!evt.bubblesOrTricklesDown)
			{
				if (visualElement.HasEventCallbacksOrDefaultActionAtTarget(evt.eventCategory))
				{
					visualElement.HandleEventAtTargetPhase(evt);
				}
			}
			else if (visualElement.HasParentEventCallbacksOrDefaultActionAtTarget(evt.eventCategory))
			{
				HandleEventAcrossPropagationPath(evt);
			}
			evt.dispatch = false;
		}

		private static void HandleEventAcrossPropagationPath(EventBase evt)
		{
			VisualElement visualElement = (VisualElement)evt.leafTarget;
			PropagationPaths propagationPaths = (evt.path = PropagationPaths.Build(visualElement, evt));
			EventDebugger.LogPropagationPaths(evt, propagationPaths);
			IPanel panel = visualElement.panel;
			if (evt.tricklesDown)
			{
				evt.propagationPhase = PropagationPhase.TrickleDown;
				int num = propagationPaths.trickleDownPath.Count - 1;
				while (num >= 0 && !evt.isPropagationStopped)
				{
					VisualElement visualElement2 = propagationPaths.trickleDownPath[num];
					if (!evt.Skip(visualElement2) && visualElement2.panel == panel)
					{
						evt.currentTarget = visualElement2;
						evt.currentTarget.HandleEvent(evt);
					}
					num--;
				}
			}
			evt.propagationPhase = PropagationPhase.AtTarget;
			foreach (VisualElement targetElement in propagationPaths.targetElements)
			{
				if (!evt.Skip(targetElement) && targetElement.panel == panel)
				{
					evt.target = targetElement;
					evt.currentTarget = evt.target;
					evt.currentTarget.HandleEvent(evt);
				}
			}
			evt.propagationPhase = PropagationPhase.DefaultActionAtTarget;
			foreach (VisualElement targetElement2 in propagationPaths.targetElements)
			{
				if (!evt.Skip(targetElement2) && targetElement2.panel == panel)
				{
					evt.target = targetElement2;
					evt.currentTarget = evt.target;
					evt.currentTarget.HandleEvent(evt);
				}
			}
			evt.target = evt.leafTarget;
			if (evt.bubbles)
			{
				evt.propagationPhase = PropagationPhase.BubbleUp;
				foreach (VisualElement item in propagationPaths.bubbleUpPath)
				{
					if (!evt.Skip(item) && item.panel == panel)
					{
						evt.currentTarget = item;
						evt.currentTarget.HandleEvent(evt);
					}
				}
			}
			evt.propagationPhase = PropagationPhase.None;
			evt.currentTarget = null;
		}

		internal static void PropagateToIMGUIContainer(VisualElement root, EventBase evt)
		{
			if (evt.imguiEvent == null || root.elementPanel.contextType == ContextType.Player)
			{
				return;
			}
			if (root.isIMGUIContainer)
			{
				IMGUIContainer iMGUIContainer = root as IMGUIContainer;
				if (evt.Skip(iMGUIContainer))
				{
					return;
				}
				bool flag = (evt.target as Focusable)?.focusable ?? false;
				if (iMGUIContainer.SendEventToIMGUI(evt, !flag))
				{
					evt.StopPropagation();
					evt.PreventDefault();
				}
				if (evt.imguiEvent.rawType == EventType.Used)
				{
					Debug.Assert(evt.isPropagationStopped);
				}
			}
			if (root.imguiContainerDescendantCount <= 0)
			{
				return;
			}
			List<VisualElement> value;
			using (CollectionPool<List<VisualElement>, VisualElement>.Get(out value))
			{
				value.AddRange(root.hierarchy.children);
				foreach (VisualElement item in value)
				{
					if (item.hierarchy.parent == root)
					{
						PropagateToIMGUIContainer(item, evt);
						if (evt.isPropagationStopped)
						{
							break;
						}
					}
				}
			}
		}

		public static void ExecuteDefaultAction(EventBase evt)
		{
			if (evt.target is VisualElement visualElement && visualElement.HasDefaultAction(evt.eventCategory))
			{
				evt.dispatch = true;
				evt.currentTarget = evt.target;
				evt.propagationPhase = PropagationPhase.DefaultAction;
				evt.currentTarget.HandleEvent(evt);
				evt.propagationPhase = PropagationPhase.None;
				evt.currentTarget = null;
				evt.dispatch = false;
			}
		}
	}
	internal class IMGUIEventDispatchingStrategy : IEventDispatchingStrategy
	{
		public bool CanDispatchEvent(EventBase evt)
		{
			return evt is IMGUIEvent;
		}

		public void DispatchEvent(EventBase evt, IPanel panel)
		{
			if (panel != null)
			{
				EventDispatchUtilities.PropagateToIMGUIContainer(panel.visualTree, evt);
			}
			evt.propagateToIMGUI = false;
			evt.stopDispatch = true;
		}
	}
	public class InputEvent : EventBase<InputEvent>
	{
		public string previousData { get; protected set; }

		public string newData { get; protected set; }

		static InputEvent()
		{
			EventBase<InputEvent>.SetCreateFunction(() => new InputEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown;
			previousData = null;
			newData = null;
		}

		public static InputEvent GetPooled(string previousData, string newData)
		{
			InputEvent inputEvent = EventBase<InputEvent>.GetPooled();
			inputEvent.previousData = previousData;
			inputEvent.newData = newData;
			return inputEvent;
		}

		public InputEvent()
		{
			LocalInit();
		}
	}
	internal class KeyboardEventDispatchingStrategy : IEventDispatchingStrategy
	{
		public bool CanDispatchEvent(EventBase evt)
		{
			return evt is IKeyboardEvent;
		}

		public void DispatchEvent(EventBase evt, IPanel panel)
		{
			if (panel != null)
			{
				Focusable leafFocusedElement = panel.focusController.GetLeafFocusedElement();
				if (leafFocusedElement != null)
				{
					evt.target = leafFocusedElement;
					if (leafFocusedElement.isIMGUIContainer)
					{
						IMGUIContainer iMGUIContainer = (IMGUIContainer)leafFocusedElement;
						if (!evt.Skip(iMGUIContainer) && iMGUIContainer.SendEventToIMGUI(evt))
						{
							evt.StopPropagation();
							evt.PreventDefault();
						}
					}
					else
					{
						EventDispatchUtilities.PropagateEvent(evt);
					}
				}
				else
				{
					evt.target = panel.visualTree;
					EventDispatchUtilities.PropagateEvent(evt);
					if (!evt.isPropagationStopped)
					{
						EventDispatchUtilities.PropagateToIMGUIContainer(panel.visualTree, evt);
					}
				}
			}
			evt.propagateToIMGUI = false;
			evt.stopDispatch = true;
		}
	}
	public interface IKeyboardEvent
	{
		EventModifiers modifiers { get; }

		char character { get; }

		KeyCode keyCode { get; }

		bool shiftKey { get; }

		bool ctrlKey { get; }

		bool commandKey { get; }

		bool altKey { get; }

		bool actionKey { get; }
	}
	[EventCategory(EventCategory.Keyboard)]
	public abstract class KeyboardEventBase<T> : EventBase<T>, IKeyboardEvent where T : KeyboardEventBase<T>, new()
	{
		public EventModifiers modifiers { get; protected set; }

		public char character { get; protected set; }

		public KeyCode keyCode { get; protected set; }

		public bool shiftKey => (modifiers & EventModifiers.Shift) != 0;

		public bool ctrlKey => (modifiers & EventModifiers.Control) != 0;

		public bool commandKey => (modifiers & EventModifiers.Command) != 0;

		public bool altKey => (modifiers & EventModifiers.Alt) != 0;

		internal bool functionKey => (modifiers & EventModifiers.FunctionKey) != 0;

		public bool actionKey
		{
			get
			{
				if (Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.OSXPlayer)
				{
					return commandKey;
				}
				return ctrlKey;
			}
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.Cancellable | EventPropagation.SkipDisabledElements;
			modifiers = EventModifiers.None;
			character = '\0';
			keyCode = KeyCode.None;
		}

		public static T GetPooled(char c, KeyCode keyCode, EventModifiers modifiers)
		{
			T val = EventBase<T>.GetPooled();
			val.modifiers = modifiers;
			val.character = c;
			val.keyCode = keyCode;
			return val;
		}

		public static T GetPooled(Event systemEvent)
		{
			T val = EventBase<T>.GetPooled();
			val.imguiEvent = systemEvent;
			if (systemEvent != null)
			{
				val.modifiers = systemEvent.modifiers;
				val.character = systemEvent.character;
				val.keyCode = systemEvent.keyCode;
			}
			return val;
		}

		protected KeyboardEventBase()
		{
			LocalInit();
		}
	}
	public class KeyDownEvent : KeyboardEventBase<KeyDownEvent>
	{
		static KeyDownEvent()
		{
			EventBase<KeyDownEvent>.SetCreateFunction(() => new KeyDownEvent());
		}

		internal void GetEquivalentImguiEvent(Event outImguiEvent)
		{
			if (base.imguiEvent != null)
			{
				outImguiEvent.CopyFrom(base.imguiEvent);
				return;
			}
			outImguiEvent.type = EventType.KeyDown;
			outImguiEvent.modifiers = base.modifiers;
			outImguiEvent.character = base.character;
			outImguiEvent.keyCode = base.keyCode;
		}

		protected internal override void PostDispatch(IPanel panel)
		{
			base.PostDispatch(panel);
			if (panel.contextType == ContextType.Editor)
			{
				Event obj = base.imguiEvent;
				if (obj == null || obj.type != EventType.Used)
				{
					SendEquivalentNavigationEventIfAny(panel);
				}
			}
		}

		private void SendEquivalentNavigationEventIfAny(IPanel panel)
		{
			if (base.character == '\n' || base.character == '\u0003' || base.character == '\n' || base.character == ' ')
			{
				using (NavigationSubmitEvent navigationSubmitEvent = NavigationEventBase<NavigationSubmitEvent>.GetPooled(NavigationDeviceType.Keyboard, base.modifiers))
				{
					navigationSubmitEvent.target = base.leafTarget;
					panel.visualTree.SendEvent(navigationSubmitEvent);
					return;
				}
			}
			if (base.keyCode == KeyCode.Escape)
			{
				using (NavigationCancelEvent navigationCancelEvent = NavigationEventBase<NavigationCancelEvent>.GetPooled(NavigationDeviceType.Keyboard, base.modifiers))
				{
					navigationCancelEvent.target = base.leafTarget;
					panel.visualTree.SendEvent(navigationCancelEvent);
					return;
				}
			}
			if (this.ShouldSendNavigationMoveEvent())
			{
				using (NavigationMoveEvent navigationMoveEvent = NavigationMoveEvent.GetPooled(base.shiftKey ? NavigationMoveEvent.Direction.Previous : NavigationMoveEvent.Direction.Next, NavigationDeviceType.Keyboard, base.modifiers))
				{
					navigationMoveEvent.target = base.leafTarget;
					panel.visualTree.SendEvent(navigationMoveEvent);
					return;
				}
			}
			if (base.keyCode == KeyCode.RightArrow || base.keyCode == KeyCode.LeftArrow || base.keyCode == KeyCode.UpArrow || base.keyCode == KeyCode.DownArrow)
			{
				Vector2 moveVector = ((base.keyCode == KeyCode.RightArrow) ? Vector2.right : ((base.keyCode == KeyCode.LeftArrow) ? Vector2.left : ((base.keyCode == KeyCode.UpArrow) ? Vector2.up : Vector2.down)));
				using NavigationMoveEvent navigationMoveEvent2 = NavigationMoveEvent.GetPooled(moveVector, NavigationDeviceType.Keyboard, base.modifiers);
				navigationMoveEvent2.target = base.leafTarget;
				panel.visualTree.SendEvent(navigationMoveEvent2);
			}
		}
	}
	internal static class KeyboardEventExtensions
	{
		internal static bool ShouldSendNavigationMoveEvent(this KeyDownEvent e)
		{
			return e.keyCode == KeyCode.Tab && !e.ctrlKey && !e.altKey && !e.commandKey && !e.functionKey;
		}

		internal static bool ShouldSendNavigationMoveEventRuntime(this Event e)
		{
			return e.type == EventType.KeyDown && e.keyCode == KeyCode.Tab;
		}
	}
	public class KeyUpEvent : KeyboardEventBase<KeyUpEvent>
	{
		static KeyUpEvent()
		{
			EventBase<KeyUpEvent>.SetCreateFunction(() => new KeyUpEvent());
		}
	}
	[EventCategory(EventCategory.Geometry)]
	public class GeometryChangedEvent : EventBase<GeometryChangedEvent>
	{
		public Rect oldRect { get; private set; }

		public Rect newRect { get; private set; }

		internal int layoutPass { get; set; }

		static GeometryChangedEvent()
		{
			EventBase<GeometryChangedEvent>.SetCreateFunction(() => new GeometryChangedEvent());
		}

		public static GeometryChangedEvent GetPooled(Rect oldRect, Rect newRect)
		{
			GeometryChangedEvent geometryChangedEvent = EventBase<GeometryChangedEvent>.GetPooled();
			geometryChangedEvent.oldRect = oldRect;
			geometryChangedEvent.newRect = newRect;
			return geometryChangedEvent;
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			oldRect = Rect.zero;
			newRect = Rect.zero;
			layoutPass = 0;
		}

		public GeometryChangedEvent()
		{
			LocalInit();
		}
	}
	internal class MouseCaptureDispatchingStrategy : IEventDispatchingStrategy
	{
		[Flags]
		private enum EventBehavior
		{
			None = 0,
			IsCapturable = 1,
			IsSentExclusivelyToCapturingElement = 2
		}

		public bool CanDispatchEvent(EventBase evt)
		{
			return evt is IMouseEvent || evt.imguiEvent != null;
		}

		public void DispatchEvent(EventBase evt, IPanel panel)
		{
			EventBehavior eventBehavior = EventBehavior.None;
			IEventHandler eventHandler = panel?.GetCapturingElement(PointerId.mousePointerId);
			if (eventHandler == null)
			{
				return;
			}
			VisualElement visualElement = eventHandler as VisualElement;
			if (evt.eventTypeId != EventBase<MouseCaptureOutEvent>.TypeId() && visualElement != null && visualElement.panel == null)
			{
				visualElement.ReleaseMouse();
			}
			else
			{
				if (panel != null && visualElement != null && visualElement.panel != panel)
				{
					return;
				}
				IMouseEvent mouseEvent = evt as IMouseEvent;
				if (mouseEvent != null && (evt.target == null || evt.target == eventHandler))
				{
					eventBehavior = EventBehavior.IsCapturable;
					eventBehavior |= EventBehavior.IsSentExclusivelyToCapturingElement;
				}
				else if (evt.imguiEvent != null && evt.target == null)
				{
					eventBehavior = EventBehavior.IsCapturable;
				}
				if (evt.eventTypeId == EventBase<MouseEnterWindowEvent>.TypeId() || evt.eventTypeId == EventBase<MouseLeaveWindowEvent>.TypeId() || evt.eventTypeId == EventBase<WheelEvent>.TypeId())
				{
					eventBehavior = EventBehavior.None;
				}
				if ((eventBehavior & EventBehavior.IsCapturable) != EventBehavior.IsCapturable)
				{
					return;
				}
				BaseVisualElementPanel baseVisualElementPanel = panel as BaseVisualElementPanel;
				if (mouseEvent != null && baseVisualElementPanel != null)
				{
					IMouseEventInternal obj = mouseEvent as IMouseEventInternal;
					if (obj == null || obj.recomputeTopElementUnderMouse)
					{
						baseVisualElementPanel.RecomputeTopElementUnderPointer(PointerId.mousePointerId, mouseEvent.mousePosition, evt);
					}
				}
				evt.dispatch = true;
				evt.target = eventHandler;
				bool skipDisabledElements = evt.skipDisabledElements;
				evt.skipDisabledElements = false;
				(eventHandler as CallbackEventHandler)?.HandleEventAtTargetPhase(evt);
				if ((eventBehavior & EventBehavior.IsSentExclusivelyToCapturingElement) != EventBehavior.IsSentExclusivelyToCapturingElement)
				{
					evt.target = null;
					evt.skipDisabledElements = skipDisabledElements;
				}
				evt.currentTarget = null;
				evt.propagationPhase = PropagationPhase.None;
				evt.dispatch = false;
				evt.skipElements.Add(eventHandler);
				evt.stopDispatch = (eventBehavior & EventBehavior.IsSentExclusivelyToCapturingElement) == EventBehavior.IsSentExclusivelyToCapturingElement;
				if (evt.target is IMGUIContainer)
				{
					evt.propagateToIMGUI = true;
					evt.skipElements.Add(evt.target);
				}
				else
				{
					evt.propagateToIMGUI = false;
				}
			}
		}
	}
	internal class MouseEventDispatchingStrategy : IEventDispatchingStrategy
	{
		public bool CanDispatchEvent(EventBase evt)
		{
			return evt is IMouseEvent;
		}

		public void DispatchEvent(EventBase evt, IPanel iPanel)
		{
			if (iPanel != null)
			{
				Assert.IsTrue(iPanel is BaseVisualElementPanel);
				BaseVisualElementPanel panel = (BaseVisualElementPanel)iPanel;
				SetBestTargetForEvent(evt, panel);
				SendEventToTarget(evt, panel);
			}
			evt.stopDispatch = true;
		}

		private static bool SendEventToTarget(EventBase evt, BaseVisualElementPanel panel)
		{
			return SendEventToRegularTarget(evt, panel) || SendEventToIMGUIContainer(evt, panel);
		}

		private static bool SendEventToRegularTarget(EventBase evt, BaseVisualElementPanel panel)
		{
			if (!(evt.target is VisualElement visualElement))
			{
				return false;
			}
			if (visualElement.panel == panel)
			{
				EventDispatchUtilities.PropagateEvent(evt);
			}
			return IsDone(evt);
		}

		private static bool SendEventToIMGUIContainer(EventBase evt, BaseVisualElementPanel panel)
		{
			if (evt.imguiEvent == null)
			{
				return false;
			}
			IMGUIContainer rootIMGUIContainer = panel.rootIMGUIContainer;
			if (rootIMGUIContainer == null)
			{
				return false;
			}
			if (evt.propagateToIMGUI || evt.eventTypeId == EventBase<MouseEnterWindowEvent>.TypeId() || evt.eventTypeId == EventBase<MouseLeaveWindowEvent>.TypeId())
			{
				evt.skipElements.Add(evt.target);
				EventDispatchUtilities.PropagateToIMGUIContainer(panel.visualTree, evt);
			}
			return IsDone(evt);
		}

		private static void SetBestTargetForEvent(EventBase evt, BaseVisualElementPanel panel)
		{
			UpdateElementUnderMouse(evt, panel, out var elementUnderMouse);
			if (evt.target != null)
			{
				evt.propagateToIMGUI = false;
			}
			else if (elementUnderMouse != null)
			{
				evt.propagateToIMGUI = false;
				evt.target = elementUnderMouse;
			}
			else
			{
				evt.target = panel?.visualTree;
			}
		}

		private static void UpdateElementUnderMouse(EventBase evt, BaseVisualElementPanel panel, out VisualElement elementUnderMouse)
		{
			bool flag = (evt as IMouseEventInternal)?.recomputeTopElementUnderMouse ?? true;
			elementUnderMouse = (flag ? panel.RecomputeTopElementUnderPointer(PointerId.mousePointerId, ((IMouseEvent)evt).mousePosition, evt) : panel.GetTopElementUnderPointer(PointerId.mousePointerId));
			if (evt.eventTypeId == EventBase<MouseLeaveWindowEvent>.TypeId() && (evt as MouseLeaveWindowEvent).pressedButtons == 0)
			{
				panel.ClearCachedElementUnderPointer(PointerId.mousePointerId, evt);
			}
		}

		private static bool IsDone(EventBase evt)
		{
			Event imguiEvent = evt.imguiEvent;
			if (imguiEvent != null && imguiEvent.rawType == EventType.Used)
			{
				evt.StopPropagation();
			}
			return evt.isPropagationStopped;
		}
	}
	public interface IMouseEvent
	{
		EventModifiers modifiers { get; }

		Vector2 mousePosition { get; }

		Vector2 localMousePosition { get; }

		Vector2 mouseDelta { get; }

		int clickCount { get; }

		int button { get; }

		int pressedButtons { get; }

		bool shiftKey { get; }

		bool ctrlKey { get; }

		bool commandKey { get; }

		bool altKey { get; }

		bool actionKey { get; }
	}
	internal interface IMouseEventInternal
	{
		bool triggeredByOS { get; set; }

		bool recomputeTopElementUnderMouse { get; set; }

		IPointerEvent sourcePointerEvent { get; set; }
	}
	[EventCategory(EventCategory.Pointer)]
	public abstract class MouseEventBase<T> : EventBase<T>, IMouseEvent, IMouseEventInternal where T : MouseEventBase<T>, new()
	{
		public EventModifiers modifiers { get; protected set; }

		public Vector2 mousePosition { get; protected set; }

		public Vector2 localMousePosition { get; internal set; }

		public Vector2 mouseDelta { get; protected set; }

		public int clickCount { get; protected set; }

		public int button { get; protected set; }

		public int pressedButtons { get; protected set; }

		public bool shiftKey => (modifiers & EventModifiers.Shift) != 0;

		public bool ctrlKey => (modifiers & EventModifiers.Control) != 0;

		public bool commandKey => (modifiers & EventModifiers.Command) != 0;

		public bool altKey => (modifiers & EventModifiers.Alt) != 0;

		public bool actionKey
		{
			get
			{
				if (Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.OSXPlayer)
				{
					return commandKey;
				}
				return ctrlKey;
			}
		}

		bool IMouseEventInternal.triggeredByOS { get; set; }

		bool IMouseEventInternal.recomputeTopElementUnderMouse { get; set; }

		IPointerEvent IMouseEventInternal.sourcePointerEvent { get; set; }

		public override IEventHandler currentTarget
		{
			get
			{
				return base.currentTarget;
			}
			internal set
			{
				base.currentTarget = value;
				if (currentTarget is VisualElement ele)
				{
					localMousePosition = ele.WorldToLocal(mousePosition);
				}
				else
				{
					localMousePosition = mousePosition;
				}
			}
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.Cancellable;
			modifiers = EventModifiers.None;
			mousePosition = Vector2.zero;
			localMousePosition = Vector2.zero;
			mouseDelta = Vector2.zero;
			clickCount = 0;
			button = 0;
			pressedButtons = 0;
			((IMouseEventInternal)this).triggeredByOS = false;
			((IMouseEventInternal)this).recomputeTopElementUnderMouse = true;
			((IMouseEventInternal)this).sourcePointerEvent = null;
		}

		protected internal override void PreDispatch(IPanel panel)
		{
			base.PreDispatch(panel);
			if (((IMouseEventInternal)this).triggeredByOS)
			{
				PointerDeviceState.SavePointerPosition(PointerId.mousePointerId, mousePosition, panel, panel.contextType);
			}
		}

		protected internal override void PostDispatch(IPanel panel)
		{
			if (((IMouseEventInternal)this).sourcePointerEvent is EventBase eventBase)
			{
				Debug.Assert(eventBase.processed);
				(panel as BaseVisualElementPanel)?.CommitElementUnderPointers();
				if (base.isPropagationStopped)
				{
					eventBase.StopPropagation();
				}
				if (base.isImmediatePropagationStopped)
				{
					eventBase.StopImmediatePropagation();
				}
				if (base.isDefaultPrevented)
				{
					eventBase.PreventDefault();
				}
				eventBase.processedByFocusController |= base.processedByFocusController;
			}
			base.PostDispatch(panel);
		}

		public static T GetPooled(Event systemEvent)
		{
			T val = EventBase<T>.GetPooled();
			val.imguiEvent = systemEvent;
			if (systemEvent != null)
			{
				val.modifiers = systemEvent.modifiers;
				val.mousePosition = systemEvent.mousePosition;
				val.localMousePosition = systemEvent.mousePosition;
				val.mouseDelta = systemEvent.delta;
				val.button = systemEvent.button;
				val.pressedButtons = PointerDeviceState.GetPressedButtons(PointerId.mousePointerId);
				val.clickCount = systemEvent.clickCount;
				((IMouseEventInternal)val).triggeredByOS = true;
				((IMouseEventInternal)val).recomputeTopElementUnderMouse = true;
			}
			return val;
		}

		public static T GetPooled(Vector2 position, int button, int clickCount, Vector2 delta, EventModifiers modifiers = EventModifiers.None)
		{
			return GetPooled(position, button, clickCount, delta, modifiers, fromOS: false);
		}

		internal static T GetPooled(Vector2 position, int button, int clickCount, Vector2 delta, EventModifiers modifiers, bool fromOS)
		{
			T val = EventBase<T>.GetPooled();
			val.modifiers = modifiers;
			val.mousePosition = position;
			val.localMousePosition = position;
			val.mouseDelta = delta;
			val.button = button;
			val.pressedButtons = PointerDeviceState.GetPressedButtons(PointerId.mousePointerId);
			val.clickCount = clickCount;
			((IMouseEventInternal)val).triggeredByOS = fromOS;
			((IMouseEventInternal)val).recomputeTopElementUnderMouse = true;
			return val;
		}

		internal static T GetPooled(IMouseEvent triggerEvent, Vector2 mousePosition, bool recomputeTopElementUnderMouse)
		{
			if (triggerEvent != null)
			{
				return GetPooled(triggerEvent);
			}
			T val = EventBase<T>.GetPooled();
			val.mousePosition = mousePosition;
			val.localMousePosition = mousePosition;
			((IMouseEventInternal)val).recomputeTopElementUnderMouse = recomputeTopElementUnderMouse;
			return val;
		}

		public static T GetPooled(IMouseEvent triggerEvent)
		{
			T val = EventBase<T>.GetPooled(triggerEvent as EventBase);
			if (triggerEvent != null)
			{
				val.modifiers = triggerEvent.modifiers;
				val.mousePosition = triggerEvent.mousePosition;
				val.localMousePosition = triggerEvent.mousePosition;
				val.mouseDelta = triggerEvent.mouseDelta;
				val.button = triggerEvent.button;
				val.pressedButtons = triggerEvent.pressedButtons;
				val.clickCount = triggerEvent.clickCount;
				if (triggerEvent is IMouseEventInternal mouseEventInternal)
				{
					((IMouseEventInternal)val).triggeredByOS = mouseEventInternal.triggeredByOS;
					((IMouseEventInternal)val).recomputeTopElementUnderMouse = false;
				}
			}
			return val;
		}

		protected static T GetPooled(IPointerEvent pointerEvent)
		{
			T val = EventBase<T>.GetPooled();
			val.target = (pointerEvent as EventBase)?.target;
			val.imguiEvent = (pointerEvent as EventBase)?.imguiEvent;
			val.modifiers = pointerEvent.modifiers;
			val.mousePosition = pointerEvent.position;
			val.localMousePosition = pointerEvent.position;
			val.mouseDelta = pointerEvent.deltaPosition;
			val.button = ((pointerEvent.button != -1) ? pointerEvent.button : 0);
			val.pressedButtons = pointerEvent.pressedButtons;
			val.clickCount = pointerEvent.clickCount;
			if (pointerEvent is IPointerEventInternal pointerEventInternal)
			{
				((IMouseEventInternal)val).triggeredByOS = pointerEventInternal.triggeredByOS;
				((IMouseEventInternal)val).recomputeTopElementUnderMouse = true;
				((IMouseEventInternal)val).sourcePointerEvent = pointerEvent;
			}
			return val;
		}

		protected MouseEventBase()
		{
			LocalInit();
		}
	}
	public class MouseDownEvent : MouseEventBase<MouseDownEvent>
	{
		static MouseDownEvent()
		{
			EventBase<MouseDownEvent>.SetCreateFunction(() => new MouseDownEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.Cancellable | EventPropagation.SkipDisabledElements;
		}

		public MouseDownEvent()
		{
			LocalInit();
		}

		public new static MouseDownEvent GetPooled(Event systemEvent)
		{
			if (systemEvent != null)
			{
				PointerDeviceState.PressButton(PointerId.mousePointerId, systemEvent.button);
			}
			return MouseEventBase<MouseDownEvent>.GetPooled(systemEvent);
		}

		private static MouseDownEvent MakeFromPointerEvent(IPointerEvent pointerEvent)
		{
			if (pointerEvent != null && pointerEvent.button >= 0)
			{
				PointerDeviceState.PressButton(PointerId.mousePointerId, pointerEvent.button);
			}
			return MouseEventBase<MouseDownEvent>.GetPooled(pointerEvent);
		}

		internal static MouseDownEvent GetPooled(PointerDownEvent pointerEvent)
		{
			return MakeFromPointerEvent(pointerEvent);
		}

		internal static MouseDownEvent GetPooled(PointerMoveEvent pointerEvent)
		{
			return MakeFromPointerEvent(pointerEvent);
		}
	}
	public class MouseUpEvent : MouseEventBase<MouseUpEvent>
	{
		static MouseUpEvent()
		{
			EventBase<MouseUpEvent>.SetCreateFunction(() => new MouseUpEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.Cancellable | EventPropagation.SkipDisabledElements;
		}

		public MouseUpEvent()
		{
			LocalInit();
		}

		public new static MouseUpEvent GetPooled(Event systemEvent)
		{
			if (systemEvent != null)
			{
				PointerDeviceState.ReleaseButton(PointerId.mousePointerId, systemEvent.button);
			}
			return MouseEventBase<MouseUpEvent>.GetPooled(systemEvent);
		}

		private static MouseUpEvent MakeFromPointerEvent(IPointerEvent pointerEvent)
		{
			if (pointerEvent != null && pointerEvent.button >= 0)
			{
				PointerDeviceState.ReleaseButton(PointerId.mousePointerId, pointerEvent.button);
			}
			return MouseEventBase<MouseUpEvent>.GetPooled(pointerEvent);
		}

		internal static MouseUpEvent GetPooled(PointerUpEvent pointerEvent)
		{
			return MakeFromPointerEvent(pointerEvent);
		}

		internal static MouseUpEvent GetPooled(PointerMoveEvent pointerEvent)
		{
			return MakeFromPointerEvent(pointerEvent);
		}

		internal static MouseUpEvent GetPooled(PointerCancelEvent pointerEvent)
		{
			return MakeFromPointerEvent(pointerEvent);
		}
	}
	[EventCategory(EventCategory.PointerMove)]
	public class MouseMoveEvent : MouseEventBase<MouseMoveEvent>
	{
		static MouseMoveEvent()
		{
			EventBase<MouseMoveEvent>.SetCreateFunction(() => new MouseMoveEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.Cancellable;
		}

		public MouseMoveEvent()
		{
			LocalInit();
		}

		public new static MouseMoveEvent GetPooled(Event systemEvent)
		{
			MouseMoveEvent mouseMoveEvent = MouseEventBase<MouseMoveEvent>.GetPooled(systemEvent);
			mouseMoveEvent.button = 0;
			return mouseMoveEvent;
		}

		internal static MouseMoveEvent GetPooled(PointerMoveEvent pointerEvent)
		{
			return MouseEventBase<MouseMoveEvent>.GetPooled(pointerEvent);
		}
	}
	public class ContextClickEvent : MouseEventBase<ContextClickEvent>
	{
		static ContextClickEvent()
		{
			EventBase<ContextClickEvent>.SetCreateFunction(() => new ContextClickEvent());
		}
	}
	public class WheelEvent : MouseEventBase<WheelEvent>
	{
		public Vector3 delta { get; private set; }

		static WheelEvent()
		{
			EventBase<WheelEvent>.SetCreateFunction(() => new WheelEvent());
		}

		public new static WheelEvent GetPooled(Event systemEvent)
		{
			WheelEvent wheelEvent = MouseEventBase<WheelEvent>.GetPooled(systemEvent);
			wheelEvent.imguiEvent = systemEvent;
			if (systemEvent != null)
			{
				wheelEvent.delta = systemEvent.delta;
			}
			return wheelEvent;
		}

		internal static WheelEvent GetPooled(Vector3 delta, Vector3 mousePosition, EventModifiers modifiers = EventModifiers.None)
		{
			WheelEvent wheelEvent = EventBase<WheelEvent>.GetPooled();
			wheelEvent.delta = delta;
			wheelEvent.mousePosition = mousePosition;
			wheelEvent.modifiers = modifiers;
			return wheelEvent;
		}

		internal static WheelEvent GetPooled(Vector3 delta, IPointerEvent pointerEvent)
		{
			WheelEvent wheelEvent = MouseEventBase<WheelEvent>.GetPooled(pointerEvent);
			wheelEvent.delta = delta;
			return wheelEvent;
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.Cancellable | EventPropagation.SkipDisabledElements;
			delta = Vector3.zero;
		}

		public WheelEvent()
		{
			LocalInit();
		}
	}
	[EventCategory(EventCategory.EnterLeave)]
	public class MouseEnterEvent : MouseEventBase<MouseEnterEvent>
	{
		static MouseEnterEvent()
		{
			EventBase<MouseEnterEvent>.SetCreateFunction(() => new MouseEnterEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.TricklesDown | EventPropagation.Cancellable | EventPropagation.IgnoreCompositeRoots;
		}

		public MouseEnterEvent()
		{
			LocalInit();
		}
	}
	[EventCategory(EventCategory.EnterLeave)]
	public class MouseLeaveEvent : MouseEventBase<MouseLeaveEvent>
	{
		static MouseLeaveEvent()
		{
			EventBase<MouseLeaveEvent>.SetCreateFunction(() => new MouseLeaveEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.TricklesDown | EventPropagation.Cancellable | EventPropagation.IgnoreCompositeRoots;
		}

		public MouseLeaveEvent()
		{
			LocalInit();
		}
	}
	[EventCategory(EventCategory.EnterLeaveWindow)]
	public class MouseEnterWindowEvent : MouseEventBase<MouseEnterWindowEvent>
	{
		static MouseEnterWindowEvent()
		{
			EventBase<MouseEnterWindowEvent>.SetCreateFunction(() => new MouseEnterWindowEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Cancellable;
		}

		public MouseEnterWindowEvent()
		{
			LocalInit();
		}

		protected internal override void PostDispatch(IPanel panel)
		{
			EventBase eventBase = ((IMouseEventInternal)this).sourcePointerEvent as EventBase;
			if (eventBase == null)
			{
				(panel as BaseVisualElementPanel)?.CommitElementUnderPointers();
			}
			base.PostDispatch(panel);
		}
	}
	[EventCategory(EventCategory.EnterLeaveWindow)]
	public class MouseLeaveWindowEvent : MouseEventBase<MouseLeaveWindowEvent>
	{
		static MouseLeaveWindowEvent()
		{
			EventBase<MouseLeaveWindowEvent>.SetCreateFunction(() => new MouseLeaveWindowEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Cancellable;
			((IMouseEventInternal)this).recomputeTopElementUnderMouse = false;
		}

		public MouseLeaveWindowEvent()
		{
			LocalInit();
		}

		public new static MouseLeaveWindowEvent GetPooled(Event systemEvent)
		{
			if (systemEvent != null)
			{
				PointerDeviceState.ReleaseAllButtons(PointerId.mousePointerId);
			}
			return MouseEventBase<MouseLeaveWindowEvent>.GetPooled(systemEvent);
		}

		protected internal override void PostDispatch(IPanel panel)
		{
			EventBase eventBase = ((IMouseEventInternal)this).sourcePointerEvent as EventBase;
			if (eventBase == null)
			{
				(panel as BaseVisualElementPanel)?.CommitElementUnderPointers();
			}
			base.PostDispatch(panel);
		}
	}
	[EventCategory(EventCategory.EnterLeave)]
	public class MouseOverEvent : MouseEventBase<MouseOverEvent>
	{
		static MouseOverEvent()
		{
			EventBase<MouseOverEvent>.SetCreateFunction(() => new MouseOverEvent());
		}
	}
	[EventCategory(EventCategory.EnterLeave)]
	public class MouseOutEvent : MouseEventBase<MouseOutEvent>
	{
		static MouseOutEvent()
		{
			EventBase<MouseOutEvent>.SetCreateFunction(() => new MouseOutEvent());
		}
	}
	public class ContextualMenuPopulateEvent : MouseEventBase<ContextualMenuPopulateEvent>
	{
		private ContextualMenuManager m_ContextualMenuManager;

		public DropdownMenu menu { get; private set; }

		public EventBase triggerEvent { get; private set; }

		static ContextualMenuPopulateEvent()
		{
			EventBase<ContextualMenuPopulateEvent>.SetCreateFunction(() => new ContextualMenuPopulateEvent());
		}

		public static ContextualMenuPopulateEvent GetPooled(EventBase triggerEvent, DropdownMenu menu, IEventHandler target, ContextualMenuManager menuManager)
		{
			ContextualMenuPopulateEvent contextualMenuPopulateEvent = EventBase<ContextualMenuPopulateEvent>.GetPooled(triggerEvent);
			if (triggerEvent != null)
			{
				triggerEvent.Acquire();
				contextualMenuPopulateEvent.triggerEvent = triggerEvent;
				if (triggerEvent is IMouseEvent mouseEvent)
				{
					contextualMenuPopulateEvent.modifiers = mouseEvent.modifiers;
					contextualMenuPopulateEvent.mousePosition = mouseEvent.mousePosition;
					contextualMenuPopulateEvent.localMousePosition = mouseEvent.mousePosition;
					contextualMenuPopulateEvent.mouseDelta = mouseEvent.mouseDelta;
					contextualMenuPopulateEvent.button = mouseEvent.button;
					contextualMenuPopulateEvent.clickCount = mouseEvent.clickCount;
				}
				else if (triggerEvent is IPointerEvent pointerEvent)
				{
					contextualMenuPopulateEvent.modifiers = pointerEvent.modifiers;
					contextualMenuPopulateEvent.mousePosition = pointerEvent.position;
					contextualMenuPopulateEvent.localMousePosition = pointerEvent.position;
					contextualMenuPopulateEvent.mouseDelta = pointerEvent.deltaPosition;
					contextualMenuPopulateEvent.button = pointerEvent.button;
					contextualMenuPopulateEvent.clickCount = pointerEvent.clickCount;
				}
				if (triggerEvent is IMouseEventInternal mouseEventInternal)
				{
					((IMouseEventInternal)contextualMenuPopulateEvent).triggeredByOS = mouseEventInternal.triggeredByOS;
				}
				else if (triggerEvent is IPointerEventInternal pointerEventInternal)
				{
					((IMouseEventInternal)contextualMenuPopulateEvent).triggeredByOS = pointerEventInternal.triggeredByOS;
				}
			}
			contextualMenuPopulateEvent.target = target;
			contextualMenuPopulateEvent.menu = menu;
			contextualMenuPopulateEvent.m_ContextualMenuManager = menuManager;
			return contextualMenuPopulateEvent;
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			menu = null;
			m_ContextualMenuManager = null;
			if (triggerEvent != null)
			{
				triggerEvent.Dispose();
				triggerEvent = null;
			}
		}

		public ContextualMenuPopulateEvent()
		{
			LocalInit();
		}

		protected internal override void PostDispatch(IPanel panel)
		{
			if (!base.isDefaultPrevented && m_ContextualMenuManager != null)
			{
				menu.PrepareForDisplay(triggerEvent);
				m_ContextualMenuManager.DoDisplayMenu(menu, triggerEvent);
			}
			base.PostDispatch(panel);
		}
	}
	internal static class MouseEventsHelper
	{
		internal static void SendEnterLeave<TLeaveEvent, TEnterEvent>(VisualElement previousTopElementUnderMouse, VisualElement currentTopElementUnderMouse, IMouseEvent triggerEvent, Vector2 mousePosition) where TLeaveEvent : MouseEventBase<TLeaveEvent>, new() where TEnterEvent : MouseEventBase<TEnterEvent>, new()
		{
			if (previousTopElementUnderMouse != null && previousTopElementUnderMouse.panel == null)
			{
				previousTopElementUnderMouse = null;
			}
			int num = 0;
			VisualElement visualElement;
			for (visualElement = previousTopElementUnderMouse; visualElement != null; visualElement = visualElement.hierarchy.parent)
			{
				num++;
			}
			int num2 = 0;
			VisualElement visualElement2;
			for (visualElement2 = currentTopElementUnderMouse; visualElement2 != null; visualElement2 = visualElement2.hierarchy.parent)
			{
				num2++;
			}
			visualElement = previousTopElementUnderMouse;
			visualElement2 = currentTopElementUnderMouse;
			while (num > num2)
			{
				using (TLeaveEvent val = MouseEventBase<TLeaveEvent>.GetPooled(triggerEvent, mousePosition, recomputeTopElementUnderMouse: false))
				{
					val.target = visualElement;
					visualElement.SendEvent(val);
				}
				num--;
				visualElement = visualElement.hierarchy.parent;
			}
			List<VisualElement> list = VisualElementListPool.Get(num2);
			while (num2 > num)
			{
				list.Add(visualElement2);
				num2--;
				visualElement2 = visualElement2.hierarchy.parent;
			}
			while (visualElement != visualElement2)
			{
				using (TLeaveEvent val2 = MouseEventBase<TLeaveEvent>.GetPooled(triggerEvent, mousePosition, recomputeTopElementUnderMouse: false))
				{
					val2.target = visualElement;
					visualElement.SendEvent(val2);
				}
				list.Add(visualElement2);
				visualElement = visualElement.hierarchy.parent;
				visualElement2 = visualElement2.hierarchy.parent;
			}
			for (int num3 = list.Count - 1; num3 >= 0; num3--)
			{
				using TEnterEvent val3 = MouseEventBase<TEnterEvent>.GetPooled(triggerEvent, mousePosition, recomputeTopElementUnderMouse: false);
				val3.target = list[num3];
				list[num3].SendEvent(val3);
			}
			VisualElementListPool.Release(list);
		}

		internal static void SendMouseOverMouseOut(VisualElement previousTopElementUnderMouse, VisualElement currentTopElementUnderMouse, IMouseEvent triggerEvent, Vector2 mousePosition)
		{
			if (previousTopElementUnderMouse != null && previousTopElementUnderMouse.panel != null)
			{
				using MouseOutEvent mouseOutEvent = MouseEventBase<MouseOutEvent>.GetPooled(triggerEvent, mousePosition, recomputeTopElementUnderMouse: false);
				mouseOutEvent.target = previousTopElementUnderMouse;
				previousTopElementUnderMouse.SendEvent(mouseOutEvent);
			}
			if (currentTopElementUnderMouse != null)
			{
				using (MouseOverEvent mouseOverEvent = MouseEventBase<MouseOverEvent>.GetPooled(triggerEvent, mousePosition, recomputeTopElementUnderMouse: false))
				{
					mouseOverEvent.target = currentTopElementUnderMouse;
					currentTopElementUnderMouse.SendEvent(mouseOverEvent);
				}
			}
		}
	}
	internal static class PointerEventsHelper
	{
		internal static void SendEnterLeave<TLeaveEvent, TEnterEvent>(VisualElement previousTopElementUnderPointer, VisualElement currentTopElementUnderPointer, IPointerEvent triggerEvent, Vector2 position, int pointerId) where TLeaveEvent : PointerEventBase<TLeaveEvent>, new() where TEnterEvent : PointerEventBase<TEnterEvent>, new()
		{
			if (previousTopElementUnderPointer != null && previousTopElementUnderPointer.panel == null)
			{
				previousTopElementUnderPointer = null;
			}
			int num = 0;
			VisualElement visualElement;
			for (visualElement = previousTopElementUnderPointer; visualElement != null; visualElement = visualElement.hierarchy.parent)
			{
				num++;
			}
			int num2 = 0;
			VisualElement visualElement2;
			for (visualElement2 = currentTopElementUnderPointer; visualElement2 != null; visualElement2 = visualElement2.hierarchy.parent)
			{
				num2++;
			}
			visualElement = previousTopElementUnderPointer;
			visualElement2 = currentTopElementUnderPointer;
			while (num > num2)
			{
				using (TLeaveEvent val = PointerEventBase<TLeaveEvent>.GetPooled(triggerEvent, position, pointerId))
				{
					val.target = visualElement;
					visualElement.SendEvent(val);
				}
				num--;
				visualElement = visualElement.hierarchy.parent;
			}
			List<VisualElement> list = VisualElementListPool.Get(num2);
			while (num2 > num)
			{
				list.Add(visualElement2);
				num2--;
				visualElement2 = visualElement2.hierarchy.parent;
			}
			while (visualElement != visualElement2)
			{
				using (TLeaveEvent val2 = PointerEventBase<TLeaveEvent>.GetPooled(triggerEvent, position, pointerId))
				{
					val2.target = visualElement;
					visualElement.SendEvent(val2);
				}
				list.Add(visualElement2);
				visualElement = visualElement.hierarchy.parent;
				visualElement2 = visualElement2.hierarchy.parent;
			}
			for (int num3 = list.Count - 1; num3 >= 0; num3--)
			{
				using TEnterEvent val3 = PointerEventBase<TEnterEvent>.GetPooled(triggerEvent, position, pointerId);
				val3.target = list[num3];
				list[num3].SendEvent(val3);
			}
			VisualElementListPool.Release(list);
		}

		internal static void SendOverOut(VisualElement previousTopElementUnderPointer, VisualElement currentTopElementUnderPointer, IPointerEvent triggerEvent, Vector2 position, int pointerId)
		{
			if (previousTopElementUnderPointer != null && previousTopElementUnderPointer.panel != null)
			{
				using PointerOutEvent pointerOutEvent = PointerEventBase<PointerOutEvent>.GetPooled(triggerEvent, position, pointerId);
				pointerOutEvent.target = previousTopElementUnderPointer;
				previousTopElementUnderPointer.SendEvent(pointerOutEvent);
			}
			if (currentTopElementUnderPointer != null)
			{
				using (PointerOverEvent pointerOverEvent = PointerEventBase<PointerOverEvent>.GetPooled(triggerEvent, position, pointerId))
				{
					pointerOverEvent.target = currentTopElementUnderPointer;
					currentTopElementUnderPointer.SendEvent(pointerOverEvent);
				}
			}
		}
	}
	internal class NavigationEventDispatchingStrategy : IEventDispatchingStrategy
	{
		public bool CanDispatchEvent(EventBase evt)
		{
			return evt is INavigationEvent;
		}

		public void DispatchEvent(EventBase evt, IPanel panel)
		{
			if (panel != null)
			{
				if (evt.target == null)
				{
					Focusable obj = panel.focusController.GetLeafFocusedElement() ?? panel.visualTree;
					IEventHandler eventHandler = obj;
					evt.target = obj;
				}
				EventDispatchUtilities.PropagateEvent(evt);
			}
			evt.propagateToIMGUI = false;
			evt.stopDispatch = true;
		}
	}
	public interface INavigationEvent
	{
		EventModifiers modifiers { get; }

		internal NavigationDeviceType deviceType { get; }

		bool shiftKey { get; }

		bool ctrlKey { get; }

		bool commandKey { get; }

		bool altKey { get; }

		bool actionKey { get; }
	}
	internal enum NavigationDeviceType
	{
		Unknown,
		Keyboard,
		NonKeyboard
	}
	[EventCategory(EventCategory.Navigation)]
	public abstract class NavigationEventBase<T> : EventBase<T>, INavigationEvent where T : NavigationEventBase<T>, new()
	{
		public EventModifiers modifiers { get; protected set; }

		public bool shiftKey => (modifiers & EventModifiers.Shift) != 0;

		public bool ctrlKey => (modifiers & EventModifiers.Control) != 0;

		public bool commandKey => (modifiers & EventModifiers.Command) != 0;

		public bool altKey => (modifiers & EventModifiers.Alt) != 0;

		public bool actionKey
		{
			get
			{
				if (Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.OSXPlayer)
				{
					return commandKey;
				}
				return ctrlKey;
			}
		}

		NavigationDeviceType INavigationEvent.deviceType => deviceType;

		internal NavigationDeviceType deviceType { get; private set; }

		protected NavigationEventBase()
		{
			LocalInit();
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.Cancellable | EventPropagation.SkipDisabledElements;
			base.propagateToIMGUI = false;
			modifiers = EventModifiers.None;
			deviceType = NavigationDeviceType.Unknown;
		}

		public static T GetPooled(EventModifiers modifiers = EventModifiers.None)
		{
			T val = EventBase<T>.GetPooled();
			val.modifiers = modifiers;
			val.deviceType = NavigationDeviceType.Unknown;
			return val;
		}

		internal static T GetPooled(NavigationDeviceType deviceType, EventModifiers modifiers = EventModifiers.None)
		{
			T val = EventBase<T>.GetPooled();
			val.modifiers = modifiers;
			val.deviceType = deviceType;
			return val;
		}
	}
	public class NavigationMoveEvent : NavigationEventBase<NavigationMoveEvent>
	{
		public enum Direction
		{
			None,
			Left,
			Up,
			Right,
			Down,
			Next,
			Previous
		}

		public Direction direction { get; private set; }

		public Vector2 move { get; private set; }

		static NavigationMoveEvent()
		{
			EventBase<NavigationMoveEvent>.SetCreateFunction(() => new NavigationMoveEvent());
		}

		internal static Direction DetermineMoveDirection(float x, float y, float deadZone = 0.6f)
		{
			if (new Vector2(x, y).sqrMagnitude < deadZone * deadZone)
			{
				return Direction.None;
			}
			if (Mathf.Abs(x) > Mathf.Abs(y))
			{
				if (x > 0f)
				{
					return Direction.Right;
				}
				return Direction.Left;
			}
			if (y > 0f)
			{
				return Direction.Up;
			}
			return Direction.Down;
		}

		public static NavigationMoveEvent GetPooled(Vector2 moveVector, EventModifiers modifiers = EventModifiers.None)
		{
			NavigationMoveEvent navigationMoveEvent = NavigationEventBase<NavigationMoveEvent>.GetPooled(NavigationDeviceType.Unknown, modifiers);
			navigationMoveEvent.direction = DetermineMoveDirection(moveVector.x, moveVector.y);
			navigationMoveEvent.move = moveVector;
			return navigationMoveEvent;
		}

		internal static NavigationMoveEvent GetPooled(Vector2 moveVector, NavigationDeviceType deviceType, EventModifiers modifiers = EventModifiers.None)
		{
			NavigationMoveEvent navigationMoveEvent = NavigationEventBase<NavigationMoveEvent>.GetPooled(deviceType, modifiers);
			navigationMoveEvent.direction = DetermineMoveDirection(moveVector.x, moveVector.y);
			navigationMoveEvent.move = moveVector;
			return navigationMoveEvent;
		}

		public static NavigationMoveEvent GetPooled(Direction direction, EventModifiers modifiers = EventModifiers.None)
		{
			NavigationMoveEvent navigationMoveEvent = NavigationEventBase<NavigationMoveEvent>.GetPooled(NavigationDeviceType.Unknown, modifiers);
			navigationMoveEvent.direction = direction;
			navigationMoveEvent.move = Vector2.zero;
			return navigationMoveEvent;
		}

		internal static NavigationMoveEvent GetPooled(Direction direction, NavigationDeviceType deviceType, EventModifiers modifiers = EventModifiers.None)
		{
			NavigationMoveEvent navigationMoveEvent = NavigationEventBase<NavigationMoveEvent>.GetPooled(deviceType, modifiers);
			navigationMoveEvent.direction = direction;
			navigationMoveEvent.move = Vector2.zero;
			return navigationMoveEvent;
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		public NavigationMoveEvent()
		{
			LocalInit();
		}

		private void LocalInit()
		{
			direction = Direction.None;
			move = Vector2.zero;
		}
	}
	public class NavigationCancelEvent : NavigationEventBase<NavigationCancelEvent>
	{
		static NavigationCancelEvent()
		{
			EventBase<NavigationCancelEvent>.SetCreateFunction(() => new NavigationCancelEvent());
		}
	}
	public class NavigationSubmitEvent : NavigationEventBase<NavigationSubmitEvent>
	{
		static NavigationSubmitEvent()
		{
			EventBase<NavigationSubmitEvent>.SetCreateFunction(() => new NavigationSubmitEvent());
		}
	}
	public interface IPanelChangedEvent
	{
	}
	[EventCategory(EventCategory.ChangePanel)]
	public abstract class PanelChangedEventBase<T> : EventBase<T>, IPanelChangedEvent where T : PanelChangedEventBase<T>, new()
	{
		public IPanel originPanel { get; private set; }

		public IPanel destinationPanel { get; private set; }

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			originPanel = null;
			destinationPanel = null;
		}

		public static T GetPooled(IPanel originPanel, IPanel destinationPanel)
		{
			T val = EventBase<T>.GetPooled();
			val.originPanel = originPanel;
			val.destinationPanel = destinationPanel;
			return val;
		}

		protected PanelChangedEventBase()
		{
			LocalInit();
		}
	}
	public class AttachToPanelEvent : PanelChangedEventBase<AttachToPanelEvent>
	{
		static AttachToPanelEvent()
		{
			EventBase<AttachToPanelEvent>.SetCreateFunction(() => new AttachToPanelEvent());
		}
	}
	public class DetachFromPanelEvent : PanelChangedEventBase<DetachFromPanelEvent>
	{
		static DetachFromPanelEvent()
		{
			EventBase<DetachFromPanelEvent>.SetCreateFunction(() => new DetachFromPanelEvent());
		}
	}
	internal class PointerCaptureDispatchingStrategy : IEventDispatchingStrategy
	{
		public bool CanDispatchEvent(EventBase evt)
		{
			return evt is IPointerEvent;
		}

		public void DispatchEvent(EventBase evt, IPanel panel)
		{
			if (!(evt is IPointerEvent pointerEvent))
			{
				return;
			}
			IEventHandler capturingElement = panel.GetCapturingElement(pointerEvent.pointerId);
			if (capturingElement == null)
			{
				return;
			}
			VisualElement visualElement = capturingElement as VisualElement;
			if (evt.eventTypeId != EventBase<PointerCaptureOutEvent>.TypeId() && visualElement != null && visualElement.panel == null)
			{
				panel.ReleasePointer(pointerEvent.pointerId);
			}
			else
			{
				if ((evt.target != null && evt.target != capturingElement) || (panel != null && visualElement != null && visualElement.panel != panel))
				{
					return;
				}
				if (evt.eventTypeId != EventBase<PointerCaptureEvent>.TypeId() && evt.eventTypeId != EventBase<PointerCaptureOutEvent>.TypeId())
				{
					panel.ProcessPointerCapture(pointerEvent.pointerId);
				}
				if (panel is BaseVisualElementPanel baseVisualElementPanel)
				{
					IPointerEventInternal obj = pointerEvent as IPointerEventInternal;
					if (obj == null || obj.recomputeTopElementUnderPointer)
					{
						baseVisualElementPanel.RecomputeTopElementUnderPointer(pointerEvent.pointerId, pointerEvent.position, evt);
					}
				}
				evt.dispatch = true;
				evt.target = capturingElement;
				evt.skipDisabledElements = false;
				(capturingElement as CallbackEventHandler)?.HandleEventAtTargetPhase(evt);
				evt.currentTarget = null;
				evt.propagationPhase = PropagationPhase.None;
				evt.dispatch = false;
				evt.stopDispatch = true;
				evt.propagateToIMGUI = false;
			}
		}
	}
	internal static class PointerDeviceState
	{
		[Flags]
		internal enum LocationFlag
		{
			None = 0,
			OutsidePanel = 1
		}

		private struct PointerLocation
		{
			internal Vector2 Position { get; private set; }

			internal IPanel Panel { get; private set; }

			internal LocationFlag Flags { get; private set; }

			internal void SetLocation(Vector2 position, IPanel panel)
			{
				Position = position;
				Panel = panel;
				Flags = LocationFlag.None;
				if (panel == null || !panel.visualTree.layout.Contains(position))
				{
					Flags |= LocationFlag.OutsidePanel;
				}
			}
		}

		private static PointerLocation[] s_PlayerPointerLocations = new PointerLocation[PointerId.maxPointers];

		private static int[] s_PressedButtons = new int[PointerId.maxPointers];

		private static readonly IPanel[] s_PlayerPanelWithSoftPointerCapture = new IPanel[PointerId.maxPointers];

		internal static void Reset()
		{
			for (int i = 0; i < PointerId.maxPointers; i++)
			{
				s_PlayerPointerLocations[i].SetLocation(Vector2.zero, null);
				s_PressedButtons[i] = 0;
				s_PlayerPanelWithSoftPointerCapture[i] = null;
			}
		}

		internal static void RemovePanelData(IPanel panel)
		{
			for (int i = 0; i < PointerId.maxPointers; i++)
			{
				if (s_PlayerPointerLocations[i].Panel == panel)
				{
					s_PlayerPointerLocations[i].SetLocation(Vector2.zero, null);
				}
				if (s_PlayerPanelWithSoftPointerCapture[i] == panel)
				{
					s_PlayerPanelWithSoftPointerCapture[i] = null;
				}
			}
		}

		public static void SavePointerPosition(int pointerId, Vector2 position, IPanel panel, ContextType contextType)
		{
			if ((uint)contextType > 1u)
			{
			}
			s_PlayerPointerLocations[pointerId].SetLocation(position, panel);
		}

		public static void PressButton(int pointerId, int buttonId)
		{
			Debug.Assert(buttonId >= 0);
			Debug.Assert(buttonId < 32);
			s_PressedButtons[pointerId] |= 1 << buttonId;
		}

		public static void ReleaseButton(int pointerId, int buttonId)
		{
			Debug.Assert(buttonId >= 0);
			Debug.Assert(buttonId < 32);
			s_PressedButtons[pointerId] &= ~(1 << buttonId);
		}

		public static void ReleaseAllButtons(int pointerId)
		{
			s_PressedButtons[pointerId] = 0;
		}

		public static Vector2 GetPointerPosition(int pointerId, ContextType contextType)
		{
			if ((uint)contextType > 1u)
			{
			}
			return s_PlayerPointerLocations[pointerId].Position;
		}

		public static IPanel GetPanel(int pointerId, ContextType contextType)
		{
			if ((uint)contextType > 1u)
			{
			}
			return s_PlayerPointerLocations[pointerId].Panel;
		}

		private static bool HasFlagFast(LocationFlag flagSet, LocationFlag flag)
		{
			return (flagSet & flag) == flag;
		}

		public static bool HasLocationFlag(int pointerId, ContextType contextType, LocationFlag flag)
		{
			if ((uint)contextType > 1u)
			{
			}
			return HasFlagFast(s_PlayerPointerLocations[pointerId].Flags, flag);
		}

		public static int GetPressedButtons(int pointerId)
		{
			return s_PressedButtons[pointerId];
		}

		internal static bool HasAdditionalPressedButtons(int pointerId, int exceptButtonId)
		{
			return (s_PressedButtons[pointerId] & ~(1 << exceptButtonId)) != 0;
		}

		internal static void SetPlayerPanelWithSoftPointerCapture(int pointerId, IPanel panel)
		{
			s_PlayerPanelWithSoftPointerCapture[pointerId] = panel;
		}

		internal static IPanel GetPlayerPanelWithSoftPointerCapture(int pointerId)
		{
			return s_PlayerPanelWithSoftPointerCapture[pointerId];
		}
	}
	internal class PointerEventDispatchingStrategy : IEventDispatchingStrategy
	{
		public bool CanDispatchEvent(EventBase evt)
		{
			return evt is IPointerEvent;
		}

		public virtual void DispatchEvent(EventBase evt, IPanel panel)
		{
			SetBestTargetForEvent(evt, panel);
			SendEventToTarget(evt, panel);
			evt.stopDispatch = true;
		}

		private static void SendEventToTarget(EventBase evt, IPanel panel)
		{
			if (evt.target is VisualElement visualElement && visualElement.panel == panel)
			{
				EventDispatchUtilities.PropagateEvent(evt);
			}
		}

		private static void SetBestTargetForEvent(EventBase evt, IPanel panel)
		{
			UpdateElementUnderPointer(evt, panel, out var elementUnderPointer);
			if (evt.target == null && elementUnderPointer != null)
			{
				evt.propagateToIMGUI = false;
				evt.target = elementUnderPointer;
			}
			else if (evt.target == null && elementUnderPointer == null)
			{
				if (panel != null && panel.contextType == ContextType.Editor && evt.eventTypeId == EventBase<PointerUpEvent>.TypeId())
				{
					evt.target = (panel as Panel)?.rootIMGUIContainer;
				}
				else
				{
					evt.target = panel?.visualTree;
				}
			}
			else if (evt.target != null)
			{
				evt.propagateToIMGUI = false;
			}
		}

		private static void UpdateElementUnderPointer(EventBase evt, IPanel panel, out VisualElement elementUnderPointer)
		{
			IPointerEvent pointerEvent = evt as IPointerEvent;
			BaseVisualElementPanel baseVisualElementPanel = panel as BaseVisualElementPanel;
			bool flag = (evt as IPointerEventInternal)?.recomputeTopElementUnderPointer ?? true;
			elementUnderPointer = ((!flag) ? baseVisualElementPanel?.GetTopElementUnderPointer(pointerEvent.pointerId) : baseVisualElementPanel?.RecomputeTopElementUnderPointer(pointerEvent.pointerId, pointerEvent.position, evt));
		}
	}
	public static class PointerType
	{
		public static readonly string mouse = "mouse";

		public static readonly string touch = "touch";

		public static readonly string pen = "pen";

		public static readonly string unknown = "";

		internal static string GetPointerType(int pointerId)
		{
			if (pointerId == PointerId.mousePointerId)
			{
				return mouse;
			}
			if (pointerId == PointerId.penPointerIdBase)
			{
				return pen;
			}
			return touch;
		}

		internal static bool IsDirectManipulationDevice(string pointerType)
		{
			return (object)pointerType == touch || (object)pointerType == pen;
		}
	}
	public static class PointerId
	{
		public static readonly int maxPointers = 32;

		public static readonly int invalidPointerId = -1;

		public static readonly int mousePointerId = 0;

		public static readonly int touchPointerIdBase = 1;

		public static readonly int touchPointerCount = 20;

		public static readonly int penPointerIdBase = touchPointerIdBase + touchPointerCount;

		public static readonly int penPointerCount = 2;

		internal static readonly int[] hoveringPointers = new int[1] { mousePointerId };
	}
	public interface IPointerEvent
	{
		int pointerId { get; }

		string pointerType { get; }

		bool isPrimary { get; }

		int button { get; }

		int pressedButtons { get; }

		Vector3 position { get; }

		Vector3 localPosition { get; }

		Vector3 deltaPosition { get; }

		float deltaTime { get; }

		int clickCount { get; }

		float pressure { get; }

		float tangentialPressure { get; }

		float altitudeAngle { get; }

		float azimuthAngle { get; }

		float twist { get; }

		Vector2 tilt { get; }

		PenStatus penStatus { get; }

		Vector2 radius { get; }

		Vector2 radiusVariance { get; }

		EventModifiers modifiers { get; }

		bool shiftKey { get; }

		bool ctrlKey { get; }

		bool commandKey { get; }

		bool altKey { get; }

		bool actionKey { get; }
	}
	internal interface IPointerEventInternal
	{
		bool triggeredByOS { get; set; }

		bool recomputeTopElementUnderPointer { get; set; }
	}
	internal static class PointerEventHelper
	{
		public static EventBase GetPooled(EventType eventType, Vector3 mousePosition, Vector2 delta, int button, int clickCount, EventModifiers modifiers)
		{
			if (eventType == EventType.MouseDown && !PointerDeviceState.HasAdditionalPressedButtons(PointerId.mousePointerId, button))
			{
				return PointerEventBase<PointerDownEvent>.GetPooled(eventType, mousePosition, delta, button, clickCount, modifiers);
			}
			if (eventType == EventType.MouseUp && !PointerDeviceState.HasAdditionalPressedButtons(PointerId.mousePointerId, button))
			{
				return PointerEventBase<PointerUpEvent>.GetPooled(eventType, mousePosition, delta, button, clickCount, modifiers);
			}
			return PointerEventBase<PointerMoveEvent>.GetPooled(eventType, mousePosition, delta, button, clickCount, modifiers);
		}
	}
	[EventCategory(EventCategory.Pointer)]
	public abstract class PointerEventBase<T> : EventBase<T>, IPointerEvent, IPointerEventInternal where T : PointerEventBase<T>, new()
	{
		private const float k_DefaultButtonPressure = 0.5f;

		private bool m_AltitudeNeedsConversion = true;

		private bool m_AzimuthNeedsConversion = true;

		private float m_AltitudeAngle = 0f;

		private float m_AzimuthAngle = 0f;

		private bool m_TiltNeeded = true;

		private Vector2 m_Tilt = new Vector2(0f, 0f);

		public int pointerId { get; protected set; }

		public string pointerType { get; protected set; }

		public bool isPrimary { get; protected set; }

		public int button { get; protected set; }

		public int pressedButtons { get; protected set; }

		public Vector3 position { get; protected set; }

		public Vector3 localPosition { get; protected set; }

		public Vector3 deltaPosition { get; protected set; }

		public float deltaTime { get; protected set; }

		public int clickCount { get; protected set; }

		public float pressure { get; protected set; }

		public float tangentialPressure { get; protected set; }

		public float altitudeAngle
		{
			get
			{
				if (m_AltitudeNeedsConversion)
				{
					m_AltitudeAngle = TiltToAltitude(tilt);
					m_AltitudeNeedsConversion = false;
				}
				return m_AltitudeAngle;
			}
			protected set
			{
				m_AltitudeNeedsConversion = true;
				m_AltitudeAngle = value;
			}
		}

		public float azimuthAngle
		{
			get
			{
				if (m_AzimuthNeedsConversion)
				{
					m_AzimuthAngle = TiltToAzimuth(tilt);
					m_AzimuthNeedsConversion = false;
				}
				return m_AzimuthAngle;
			}
			protected set
			{
				m_AzimuthNeedsConversion = true;
				m_AzimuthAngle = value;
			}
		}

		public float twist { get; protected set; }

		public Vector2 tilt
		{
			get
			{
				if (Application.platform != RuntimePlatform.WindowsEditor && Application.platform != RuntimePlatform.WindowsPlayer && pointerType == PointerType.touch && m_TiltNeeded)
				{
					m_Tilt = AzimuthAndAlitutudeToTilt(m_AltitudeAngle, m_AzimuthAngle);
					m_TiltNeeded = false;
				}
				return m_Tilt;
			}
			protected set
			{
				m_TiltNeeded = true;
				m_Tilt = value;
			}
		}

		public PenStatus penStatus { get; protected set; }

		public Vector2 radius { get; protected set; }

		public Vector2 radiusVariance { get; protected set; }

		public EventModifiers modifiers { get; protected set; }

		public bool shiftKey => (modifiers & EventModifiers.Shift) != 0;

		public bool ctrlKey => (modifiers & EventModifiers.Control) != 0;

		public bool commandKey => (modifiers & EventModifiers.Command) != 0;

		public bool altKey => (modifiers & EventModifiers.Alt) != 0;

		public bool actionKey
		{
			get
			{
				if (Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.OSXPlayer)
				{
					return commandKey;
				}
				return ctrlKey;
			}
		}

		bool IPointerEventInternal.triggeredByOS { get; set; }

		bool IPointerEventInternal.recomputeTopElementUnderPointer { get; set; }

		public override IEventHandler currentTarget
		{
			get
			{
				return base.currentTarget;
			}
			internal set
			{
				base.currentTarget = value;
				if (currentTarget is VisualElement ele)
				{
					localPosition = ele.WorldToLocal(position);
				}
				else
				{
					localPosition = position;
				}
			}
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.Cancellable;
			base.propagateToIMGUI = false;
			pointerId = 0;
			pointerType = PointerType.unknown;
			isPrimary = false;
			button = -1;
			pressedButtons = 0;
			position = Vector3.zero;
			localPosition = Vector3.zero;
			deltaPosition = Vector3.zero;
			deltaTime = 0f;
			clickCount = 0;
			pressure = 0f;
			tangentialPressure = 0f;
			altitudeAngle = 0f;
			azimuthAngle = 0f;
			tilt = new Vector2(0f, 0f);
			twist = 0f;
			penStatus = PenStatus.None;
			radius = Vector2.zero;
			radiusVariance = Vector2.zero;
			modifiers = EventModifiers.None;
			((IPointerEventInternal)this).triggeredByOS = false;
			((IPointerEventInternal)this).recomputeTopElementUnderPointer = false;
		}

		private static bool IsMouse(Event systemEvent)
		{
			EventType rawType = systemEvent.rawType;
			return rawType == EventType.MouseMove || rawType == EventType.MouseDown || rawType == EventType.MouseUp || rawType == EventType.MouseDrag || rawType == EventType.ContextClick || rawType == EventType.MouseEnterWindow || rawType == EventType.MouseLeaveWindow;
		}

		private static bool IsTouch(Event systemEvent)
		{
			EventType rawType = systemEvent.rawType;
			return rawType == EventType.TouchMove || rawType == EventType.TouchDown || rawType == EventType.TouchUp || rawType == EventType.TouchStationary || rawType == EventType.TouchEnter || rawType == EventType.TouchLeave;
		}

		private static float TiltToAzimuth(Vector2 tilt)
		{
			float result = 0f;
			if (tilt.x != 0f)
			{
				result = MathF.PI / 2f - Mathf.Atan2((0f - Mathf.Cos(tilt.x)) * Mathf.Sin(tilt.y), Mathf.Cos(tilt.y) * Mathf.Sin(tilt.x));
				if (result < 0f)
				{
					result += MathF.PI * 2f;
				}
				result = ((!(result >= MathF.PI / 2f)) ? (result + 4.712389f) : (result - MathF.PI / 2f));
			}
			return result;
		}

		private static Vector2 AzimuthAndAlitutudeToTilt(float altitude, float azimuth)
		{
			Vector2 result = new Vector2(0f, 0f);
			result.x = Mathf.Atan(Mathf.Cos(azimuth) * Mathf.Cos(altitude) / Mathf.Sin(azimuth));
			result.y = Mathf.Atan(Mathf.Cos(azimuth) * Mathf.Sin(altitude) / Mathf.Sin(azimuth));
			return result;
		}

		private static float TiltToAltitude(Vector2 tilt)
		{
			return MathF.PI / 2f - Mathf.Acos(Mathf.Cos(tilt.x) * Mathf.Cos(tilt.y));
		}

		public static T GetPooled(Event systemEvent)
		{
			T val = EventBase<T>.GetPooled();
			if (!IsMouse(systemEvent) && !IsTouch(systemEvent) && systemEvent.rawType != EventType.DragUpdated)
			{
				Debug.Assert(condition: false, "Unexpected event type: " + systemEvent.rawType.ToString() + " (" + systemEvent.type.ToString() + ")");
			}
			switch (systemEvent.pointerType)
			{
			default:
				val.pointerType = PointerType.mouse;
				val.pointerId = PointerId.mousePointerId;
				break;
			case UnityEngine.PointerType.Touch:
				val.pointerType = PointerType.touch;
				val.pointerId = PointerId.touchPointerIdBase;
				break;
			case UnityEngine.PointerType.Pen:
				val.pointerType = PointerType.pen;
				val.pointerId = PointerId.penPointerIdBase;
				if (systemEvent.penStatus == PenStatus.Barrel)
				{
					PointerDeviceState.PressButton(val.pointerId, 1);
				}
				else
				{
					PointerDeviceState.ReleaseButton(val.pointerId, 1);
				}
				if (systemEvent.penStatus == PenStatus.Eraser)
				{
					PointerDeviceState.PressButton(val.pointerId, 5);
				}
				else
				{
					PointerDeviceState.ReleaseButton(val.pointerId, 5);
				}
				break;
			}
			val.isPrimary = true;
			val.altitudeAngle = 0f;
			val.azimuthAngle = 0f;
			val.radius = Vector2.zero;
			val.radiusVariance = Vector2.zero;
			val.imguiEvent = systemEvent;
			if (systemEvent.rawType == EventType.MouseDown || systemEvent.rawType == EventType.TouchDown)
			{
				PointerDeviceState.PressButton(val.pointerId, systemEvent.button);
				val.button = systemEvent.button;
			}
			else if (systemEvent.rawType == EventType.MouseUp || systemEvent.rawType == EventType.TouchUp)
			{
				PointerDeviceState.ReleaseButton(val.pointerId, systemEvent.button);
				val.button = systemEvent.button;
			}
			else if (systemEvent.rawType == EventType.MouseMove || systemEvent.rawType == EventType.TouchMove)
			{
				val.button = -1;
			}
			val.pressedButtons = PointerDeviceState.GetPressedButtons(val.pointerId);
			val.position = systemEvent.mousePosition;
			val.localPosition = systemEvent.mousePosition;
			val.deltaPosition = systemEvent.delta;
			val.clickCount = systemEvent.clickCount;
			val.modifiers = systemEvent.modifiers;
			val.tilt = systemEvent.tilt;
			val.penStatus = systemEvent.penStatus;
			val.twist = systemEvent.twist;
			switch (systemEvent.pointerType)
			{
			default:
				val.pressure = ((val.pressedButtons == 0) ? 0f : 0.5f);
				break;
			case UnityEngine.PointerType.Touch:
				val.pressure = systemEvent.pressure;
				break;
			case UnityEngine.PointerType.Pen:
				val.pressure = systemEvent.pressure;
				break;
			}
			val.tangentialPressure = 0f;
			((IPointerEventInternal)val).triggeredByOS = true;
			return val;
		}

		internal static T GetPooled(EventType eventType, Vector3 mousePosition, Vector2 delta, int button, int clickCount, EventModifiers modifiers)
		{
			T val = EventBase<T>.GetPooled();
			val.pointerId = PointerId.mousePointerId;
			val.pointerType = PointerType.mouse;
			val.isPrimary = true;
			switch (eventType)
			{
			case EventType.MouseDown:
				PointerDeviceState.PressButton(val.pointerId, button);
				val.button = button;
				break;
			case EventType.MouseUp:
				PointerDeviceState.ReleaseButton(val.pointerId, button);
				val.button = button;
				break;
			default:
				val.button = -1;
				break;
			}
			val.pressedButtons = PointerDeviceState.GetPressedButtons(val.pointerId);
			val.position = mousePosition;
			val.localPosition = mousePosition;
			val.deltaPosition = delta;
			val.clickCount = clickCount;
			val.modifiers = modifiers;
			val.pressure = ((val.pressedButtons == 0) ? 0f : 0.5f);
			((IPointerEventInternal)val).triggeredByOS = true;
			return val;
		}

		public static T GetPooled(Touch touch, EventModifiers modifiers = EventModifiers.None)
		{
			T val = EventBase<T>.GetPooled();
			val.pointerId = touch.fingerId + PointerId.touchPointerIdBase;
			val.pointerType = PointerType.touch;
			bool flag = false;
			for (int i = PointerId.touchPointerIdBase; i < PointerId.touchPointerIdBase + PointerId.touchPointerCount; i++)
			{
				if (i != val.pointerId && PointerDeviceState.GetPressedButtons(i) != 0)
				{
					flag = true;
					break;
				}
			}
			val.isPrimary = !flag;
			if (touch.phase == TouchPhase.Began)
			{
				PointerDeviceState.PressButton(val.pointerId, 0);
				val.button = 0;
			}
			else if (touch.phase == TouchPhase.Ended || touch.phase == TouchPhase.Canceled)
			{
				PointerDeviceState.ReleaseButton(val.pointerId, 0);
				val.button = 0;
			}
			else
			{
				val.button = -1;
			}
			val.pressedButtons = PointerDeviceState.GetPressedButtons(val.pointerId);
			val.position = touch.position;
			val.localPosition = touch.position;
			val.deltaPosition = touch.deltaPosition;
			val.deltaTime = touch.deltaTime;
			val.clickCount = touch.tapCount;
			val.pressure = ((Mathf.Abs(touch.maximumPossiblePressure) > 1E-30f) ? (touch.pressure / touch.maximumPossiblePressure) : 1f);
			val.tangentialPressure = 0f;
			val.altitudeAngle = touch.altitudeAngle;
			val.azimuthAngle = touch.azimuthAngle;
			val.twist = 0f;
			val.tilt = new Vector2(0f, 0f);
			val.penStatus = PenStatus.None;
			val.radius = new Vector2(touch.radius, touch.radius);
			val.radiusVariance = new Vector2(touch.radiusVariance, touch.radiusVariance);
			val.modifiers = modifiers;
			((IPointerEventInternal)val).triggeredByOS = true;
			return val;
		}

		public static T GetPooled(PenData pen, EventModifiers modifiers = EventModifiers.None)
		{
			T val = EventBase<T>.GetPooled();
			val.pointerId = PointerId.penPointerIdBase;
			val.pointerType = PointerType.pen;
			val.isPrimary = true;
			if (pen.contactType == PenEventType.PenDown)
			{
				PointerDeviceState.PressButton(val.pointerId, 0);
				val.button = 0;
			}
			else if (pen.contactType == PenEventType.PenUp)
			{
				PointerDeviceState.ReleaseButton(val.pointerId, 0);
				val.button = 0;
			}
			else
			{
				val.button = -1;
			}
			if (pen.penStatus == PenStatus.Barrel)
			{
				PointerDeviceState.PressButton(val.pointerId, 1);
			}
			else
			{
				PointerDeviceState.ReleaseButton(val.pointerId, 1);
			}
			if (pen.penStatus == PenStatus.Eraser)
			{
				PointerDeviceState.PressButton(val.pointerId, 5);
			}
			else
			{
				PointerDeviceState.ReleaseButton(val.pointerId, 5);
			}
			val.pressedButtons = PointerDeviceState.GetPressedButtons(val.pointerId);
			val.position = pen.position;
			val.localPosition = pen.position;
			val.deltaPosition = pen.deltaPos;
			val.clickCount = 0;
			val.pressure = pen.pressure;
			val.tangentialPressure = 0f;
			val.twist = pen.twist;
			val.tilt = pen.tilt;
			val.penStatus = pen.penStatus;
			val.radius = Vector2.zero;
			val.radiusVariance = Vector2.zero;
			val.modifiers = modifiers;
			((IPointerEventInternal)val).triggeredByOS = true;
			return val;
		}

		internal static T GetPooled(IPointerEvent triggerEvent, Vector2 position, int pointerId)
		{
			if (triggerEvent != null)
			{
				return GetPooled(triggerEvent);
			}
			T val = EventBase<T>.GetPooled();
			val.position = position;
			val.localPosition = position;
			val.pointerId = pointerId;
			val.pointerType = PointerType.GetPointerType(pointerId);
			return val;
		}

		public static T GetPooled(IPointerEvent triggerEvent)
		{
			T val = EventBase<T>.GetPooled();
			if (triggerEvent != null)
			{
				val.pointerId = triggerEvent.pointerId;
				val.pointerType = triggerEvent.pointerType;
				val.isPrimary = triggerEvent.isPrimary;
				val.button = triggerEvent.button;
				val.pressedButtons = triggerEvent.pressedButtons;
				val.position = triggerEvent.position;
				val.localPosition = triggerEvent.localPosition;
				val.deltaPosition = triggerEvent.deltaPosition;
				val.deltaTime = triggerEvent.deltaTime;
				val.clickCount = triggerEvent.clickCount;
				val.pressure = triggerEvent.pressure;
				val.tangentialPressure = triggerEvent.tangentialPressure;
				val.altitudeAngle = triggerEvent.altitudeAngle;
				val.azimuthAngle = triggerEvent.azimuthAngle;
				val.twist = triggerEvent.twist;
				val.tilt = triggerEvent.tilt;
				val.penStatus = triggerEvent.penStatus;
				val.radius = triggerEvent.radius;
				val.radiusVariance = triggerEvent.radiusVariance;
				val.modifiers = triggerEvent.modifiers;
				if (triggerEvent is IPointerEventInternal pointerEventInternal)
				{
					((IPointerEventInternal)val).triggeredByOS |= pointerEventInternal.triggeredByOS;
				}
			}
			return val;
		}

		protected internal override void PreDispatch(IPanel panel)
		{
			base.PreDispatch(panel);
			if (((IPointerEventInternal)this).triggeredByOS)
			{
				PointerDeviceState.SavePointerPosition(pointerId, position, panel, panel.contextType);
			}
		}

		protected internal override void PostDispatch(IPanel panel)
		{
			for (int i = 0; i < PointerId.maxPointers; i++)
			{
				panel.ProcessPointerCapture(i);
			}
			if (!panel.ShouldSendCompatibilityMouseEvents(this) && ((IPointerEventInternal)this).triggeredByOS)
			{
				(panel as BaseVisualElementPanel)?.CommitElementUnderPointers();
			}
			base.PostDispatch(panel);
		}

		protected PointerEventBase()
		{
			LocalInit();
		}
	}
	public sealed class PointerDownEvent : PointerEventBase<PointerDownEvent>
	{
		static PointerDownEvent()
		{
			EventBase<PointerDownEvent>.SetCreateFunction(() => new PointerDownEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.Cancellable | EventPropagation.SkipDisabledElements;
			((IPointerEventInternal)this).triggeredByOS = true;
			((IPointerEventInternal)this).recomputeTopElementUnderPointer = true;
		}

		public PointerDownEvent()
		{
			LocalInit();
		}

		protected internal override void PostDispatch(IPanel panel)
		{
			if (!base.isDefaultPrevented)
			{
				if (panel.ShouldSendCompatibilityMouseEvents(this))
				{
					using MouseDownEvent mouseDownEvent = MouseDownEvent.GetPooled(this);
					mouseDownEvent.target = base.target;
					mouseDownEvent.target.SendEvent(mouseDownEvent);
				}
			}
			else
			{
				panel.PreventCompatibilityMouseEvents(base.pointerId);
			}
			base.PostDispatch(panel);
		}
	}
	[EventCategory(EventCategory.PointerMove)]
	public sealed class PointerMoveEvent : PointerEventBase<PointerMoveEvent>
	{
		internal bool isHandledByDraggable { get; set; }

		static PointerMoveEvent()
		{
			EventBase<PointerMoveEvent>.SetCreateFunction(() => new PointerMoveEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.Cancellable;
			((IPointerEventInternal)this).triggeredByOS = true;
			((IPointerEventInternal)this).recomputeTopElementUnderPointer = true;
			isHandledByDraggable = false;
		}

		public PointerMoveEvent()
		{
			LocalInit();
		}

		protected internal override void PostDispatch(IPanel panel)
		{
			if (panel.ShouldSendCompatibilityMouseEvents(this))
			{
				if (base.imguiEvent != null && base.imguiEvent.rawType == EventType.MouseDown)
				{
					using MouseDownEvent mouseDownEvent = MouseDownEvent.GetPooled(this);
					mouseDownEvent.target = base.target;
					mouseDownEvent.target.SendEvent(mouseDownEvent);
				}
				else if (base.imguiEvent != null && base.imguiEvent.rawType == EventType.MouseUp)
				{
					using MouseUpEvent mouseUpEvent = MouseUpEvent.GetPooled(this);
					mouseUpEvent.target = base.target;
					mouseUpEvent.target.SendEvent(mouseUpEvent);
				}
				else
				{
					using MouseMoveEvent mouseMoveEvent = MouseMoveEvent.GetPooled(this);
					mouseMoveEvent.target = base.target;
					mouseMoveEvent.target.SendEvent(mouseMoveEvent);
				}
			}
			base.PostDispatch(panel);
		}
	}
	public sealed class PointerStationaryEvent : PointerEventBase<PointerStationaryEvent>
	{
		static PointerStationaryEvent()
		{
			EventBase<PointerStationaryEvent>.SetCreateFunction(() => new PointerStationaryEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.Cancellable;
			((IPointerEventInternal)this).triggeredByOS = true;
			((IPointerEventInternal)this).recomputeTopElementUnderPointer = true;
		}

		public PointerStationaryEvent()
		{
			LocalInit();
		}
	}
	public sealed class PointerUpEvent : PointerEventBase<PointerUpEvent>
	{
		static PointerUpEvent()
		{
			EventBase<PointerUpEvent>.SetCreateFunction(() => new PointerUpEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.Cancellable | EventPropagation.SkipDisabledElements;
			((IPointerEventInternal)this).triggeredByOS = true;
			((IPointerEventInternal)this).recomputeTopElementUnderPointer = true;
		}

		public PointerUpEvent()
		{
			LocalInit();
		}

		protected internal override void PostDispatch(IPanel panel)
		{
			if (PointerType.IsDirectManipulationDevice(base.pointerType))
			{
				panel.ReleasePointer(base.pointerId);
				if (panel is BaseVisualElementPanel baseVisualElementPanel)
				{
					baseVisualElementPanel.ClearCachedElementUnderPointer(base.pointerId, this);
				}
			}
			if (panel.ShouldSendCompatibilityMouseEvents(this))
			{
				using MouseUpEvent mouseUpEvent = MouseUpEvent.GetPooled(this);
				mouseUpEvent.target = base.target;
				mouseUpEvent.target.SendEvent(mouseUpEvent);
			}
			base.PostDispatch(panel);
			panel.ActivateCompatibilityMouseEvents(base.pointerId);
		}
	}
	public sealed class PointerCancelEvent : PointerEventBase<PointerCancelEvent>
	{
		static PointerCancelEvent()
		{
			EventBase<PointerCancelEvent>.SetCreateFunction(() => new PointerCancelEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.SkipDisabledElements;
			((IPointerEventInternal)this).triggeredByOS = true;
			((IPointerEventInternal)this).recomputeTopElementUnderPointer = true;
		}

		public PointerCancelEvent()
		{
			LocalInit();
		}

		protected internal override void PostDispatch(IPanel panel)
		{
			if (PointerType.IsDirectManipulationDevice(base.pointerType))
			{
				panel.ReleasePointer(base.pointerId);
				if (panel is BaseVisualElementPanel baseVisualElementPanel)
				{
					baseVisualElementPanel.ClearCachedElementUnderPointer(base.pointerId, this);
				}
			}
			if (panel.ShouldSendCompatibilityMouseEvents(this))
			{
				using MouseUpEvent mouseUpEvent = MouseUpEvent.GetPooled(this);
				mouseUpEvent.target = base.target;
				base.target.SendEvent(mouseUpEvent);
			}
			base.PostDispatch(panel);
			panel.ActivateCompatibilityMouseEvents(base.pointerId);
		}
	}
	public sealed class ClickEvent : PointerEventBase<ClickEvent>
	{
		static ClickEvent()
		{
			EventBase<ClickEvent>.SetCreateFunction(() => new ClickEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.Cancellable | EventPropagation.SkipDisabledElements;
		}

		public ClickEvent()
		{
			LocalInit();
		}

		internal static ClickEvent GetPooled(PointerUpEvent pointerEvent, int clickCount)
		{
			ClickEvent clickEvent = PointerEventBase<ClickEvent>.GetPooled(pointerEvent);
			clickEvent.clickCount = clickCount;
			return clickEvent;
		}
	}
	[EventCategory(EventCategory.EnterLeave)]
	public sealed class PointerEnterEvent : PointerEventBase<PointerEnterEvent>
	{
		static PointerEnterEvent()
		{
			EventBase<PointerEnterEvent>.SetCreateFunction(() => new PointerEnterEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.TricklesDown | EventPropagation.IgnoreCompositeRoots;
		}

		public PointerEnterEvent()
		{
			LocalInit();
		}
	}
	[EventCategory(EventCategory.EnterLeave)]
	public sealed class PointerLeaveEvent : PointerEventBase<PointerLeaveEvent>
	{
		static PointerLeaveEvent()
		{
			EventBase<PointerLeaveEvent>.SetCreateFunction(() => new PointerLeaveEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.TricklesDown | EventPropagation.IgnoreCompositeRoots;
		}

		public PointerLeaveEvent()
		{
			LocalInit();
		}
	}
	[EventCategory(EventCategory.EnterLeave)]
	public sealed class PointerOverEvent : PointerEventBase<PointerOverEvent>
	{
		static PointerOverEvent()
		{
			EventBase<PointerOverEvent>.SetCreateFunction(() => new PointerOverEvent());
		}
	}
	[EventCategory(EventCategory.EnterLeave)]
	public sealed class PointerOutEvent : PointerEventBase<PointerOutEvent>
	{
		static PointerOutEvent()
		{
			EventBase<PointerOutEvent>.SetCreateFunction(() => new PointerOutEvent());
		}
	}
	internal class PropagationPaths
	{
		[Flags]
		public enum Type
		{
			None = 0,
			TrickleDown = 1,
			BubbleUp = 2
		}

		private static readonly ObjectPool<PropagationPaths> s_Pool = new ObjectPool<PropagationPaths>(() => new PropagationPaths());

		public readonly List<VisualElement> trickleDownPath;

		public readonly List<VisualElement> targetElements;

		public readonly List<VisualElement> bubbleUpPath;

		private const int k_DefaultPropagationDepth = 16;

		private const int k_DefaultTargetCount = 4;

		public PropagationPaths()
		{
			trickleDownPath = new List<VisualElement>(16);
			targetElements = new List<VisualElement>(4);
			bubbleUpPath = new List<VisualElement>(16);
		}

		public PropagationPaths(PropagationPaths paths)
		{
			trickleDownPath = new List<VisualElement>(paths.trickleDownPath);
			targetElements = new List<VisualElement>(paths.targetElements);
			bubbleUpPath = new List<VisualElement>(paths.bubbleUpPath);
		}

		internal static PropagationPaths Copy(PropagationPaths paths)
		{
			PropagationPaths propagationPaths = s_Pool.Get();
			propagationPaths.trickleDownPath.AddRange(paths.trickleDownPath);
			propagationPaths.targetElements.AddRange(paths.targetElements);
			propagationPaths.bubbleUpPath.AddRange(paths.bubbleUpPath);
			return propagationPaths;
		}

		public static PropagationPaths Build(VisualElement elem, EventBase evt)
		{
			PropagationPaths propagationPaths = s_Pool.Get();
			EventCategory eventCategory = evt.eventCategory;
			if (elem.HasEventCallbacksOrDefaultActions(eventCategory))
			{
				propagationPaths.targetElements.Add(elem);
			}
			for (VisualElement nextParentWithEventCallback = elem.nextParentWithEventCallback; nextParentWithEventCallback != null; nextParentWithEventCallback = nextParentWithEventCallback.nextParentWithEventCallback)
			{
				if (nextParentWithEventCallback.isCompositeRoot && !evt.ignoreCompositeRoots)
				{
					if (nextParentWithEventCallback.HasEventCallbacksOrDefaultActions(eventCategory))
					{
						propagationPaths.targetElements.Add(nextParentWithEventCallback);
					}
				}
				else if (nextParentWithEventCallback.HasEventCallbacks(eventCategory))
				{
					if (evt.tricklesDown && nextParentWithEventCallback.HasTrickleDownHandlers())
					{
						propagationPaths.trickleDownPath.Add(nextParentWithEventCallback);
					}
					if (evt.bubbles && nextParentWithEventCallback.HasBubbleUpHandlers())
					{
						propagationPaths.bubbleUpPath.Add(nextParentWithEventCallback);
					}
				}
			}
			return propagationPaths;
		}

		public void Release()
		{
			bubbleUpPath.Clear();
			targetElements.Clear();
			trickleDownPath.Clear();
			s_Pool.Release(this);
		}
	}
	[EventCategory(EventCategory.Style)]
	public class CustomStyleResolvedEvent : EventBase<CustomStyleResolvedEvent>
	{
		public ICustomStyle customStyle => (base.target as VisualElement)?.customStyle;

		static CustomStyleResolvedEvent()
		{
			EventBase<CustomStyleResolvedEvent>.SetCreateFunction(() => new CustomStyleResolvedEvent());
		}
	}
	[EventCategory(EventCategory.Tooltip)]
	public class TooltipEvent : EventBase<TooltipEvent>
	{
		public string tooltip { get; set; }

		public Rect rect { get; set; }

		static TooltipEvent()
		{
			EventBase<TooltipEvent>.SetCreateFunction(() => new TooltipEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown;
			rect = default(Rect);
			tooltip = string.Empty;
			base.ignoreCompositeRoots = true;
		}

		internal static TooltipEvent GetPooled(string tooltip, Rect rect)
		{
			TooltipEvent tooltipEvent = EventBase<TooltipEvent>.GetPooled();
			tooltipEvent.tooltip = tooltip;
			tooltipEvent.rect = rect;
			return tooltipEvent;
		}

		public TooltipEvent()
		{
			LocalInit();
		}
	}
	public interface ITransitionEvent
	{
		StylePropertyNameCollection stylePropertyNames { get; }

		double elapsedTime { get; }
	}
	public struct StylePropertyNameCollection : IEnumerable<StylePropertyName>, IEnumerable
	{
		public struct Enumerator : IEnumerator<StylePropertyName>, IEnumerator, IDisposable
		{
			private List<StylePropertyName>.Enumerator m_Enumerator;

			public StylePropertyName Current => m_Enumerator.Current;

			object IEnumerator.Current => Current;

			internal Enumerator(List<StylePropertyName>.Enumerator enumerator)
			{
				m_Enumerator = enumerator;
			}

			public bool MoveNext()
			{
				return m_Enumerator.MoveNext();
			}

			public void Reset()
			{
			}

			public void Dispose()
			{
				m_Enumerator.Dispose();
			}
		}

		internal List<StylePropertyName> propertiesList;

		internal StylePropertyNameCollection(List<StylePropertyName> list)
		{
			propertiesList = list;
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(propertiesList.GetEnumerator());
		}

		IEnumerator<StylePropertyName> IEnumerable<StylePropertyName>.GetEnumerator()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public bool Contains(StylePropertyName stylePropertyName)
		{
			foreach (StylePropertyName properties in propertiesList)
			{
				if (properties == stylePropertyName)
				{
					return true;
				}
			}
			return false;
		}
	}
	[EventCategory(EventCategory.StyleTransition)]
	public abstract class TransitionEventBase<T> : EventBase<T>, ITransitionEvent where T : TransitionEventBase<T>, new()
	{
		public StylePropertyNameCollection stylePropertyNames { get; }

		public double elapsedTime { get; protected set; }

		protected TransitionEventBase()
		{
			stylePropertyNames = new StylePropertyNameCollection(new List<StylePropertyName>());
			LocalInit();
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles;
			base.propagateToIMGUI = false;
			stylePropertyNames.propertiesList.Clear();
			elapsedTime = 0.0;
		}

		public static T GetPooled(StylePropertyName stylePropertyName, double elapsedTime)
		{
			T val = EventBase<T>.GetPooled();
			val.stylePropertyNames.propertiesList.Add(stylePropertyName);
			val.elapsedTime = elapsedTime;
			return val;
		}

		public bool AffectsProperty(StylePropertyName stylePropertyName)
		{
			return stylePropertyNames.Contains(stylePropertyName);
		}
	}
	public sealed class TransitionRunEvent : TransitionEventBase<TransitionRunEvent>
	{
		static TransitionRunEvent()
		{
			EventBase<TransitionRunEvent>.SetCreateFunction(() => new TransitionRunEvent());
		}
	}
	public sealed class TransitionStartEvent : TransitionEventBase<TransitionStartEvent>
	{
		static TransitionStartEvent()
		{
			EventBase<TransitionStartEvent>.SetCreateFunction(() => new TransitionStartEvent());
		}
	}
	public sealed class TransitionEndEvent : TransitionEventBase<TransitionEndEvent>
	{
		static TransitionEndEvent()
		{
			EventBase<TransitionEndEvent>.SetCreateFunction(() => new TransitionEndEvent());
		}
	}
	public sealed class TransitionCancelEvent : TransitionEventBase<TransitionCancelEvent>
	{
		static TransitionCancelEvent()
		{
			EventBase<TransitionCancelEvent>.SetCreateFunction(() => new TransitionCancelEvent());
		}
	}
	[EventCategory(EventCategory.IMGUI)]
	public class IMGUIEvent : EventBase<IMGUIEvent>
	{
		static IMGUIEvent()
		{
			EventBase<IMGUIEvent>.SetCreateFunction(() => new IMGUIEvent());
		}

		public static IMGUIEvent GetPooled(Event systemEvent)
		{
			IMGUIEvent iMGUIEvent = EventBase<IMGUIEvent>.GetPooled();
			iMGUIEvent.imguiEvent = systemEvent;
			return iMGUIEvent;
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown | EventPropagation.Cancellable;
		}

		public IMGUIEvent()
		{
			LocalInit();
		}
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public abstract class BaseFieldMouseDragger
	{
		public void SetDragZone(VisualElement dragElement)
		{
			SetDragZone(dragElement, new Rect(0f, 0f, -1f, -1f));
		}

		public abstract void SetDragZone(VisualElement dragElement, Rect hotZone);
	}
	[MovedFrom(true, "UnityEditor.UIElements", "UnityEditor.UIElementsModule", null)]
	public class FieldMouseDragger<T> : BaseFieldMouseDragger
	{
		private readonly IValueField<T> m_DrivenField;

		private VisualElement m_DragElement;

		private Rect m_DragHotZone;

		public bool dragging { get; set; }

		public T startValue { get; set; }

		public FieldMouseDragger(IValueField<T> drivenField)
		{
			m_DrivenField = drivenField;
			m_DragElement = null;
			m_DragHotZone = new Rect(0f, 0f, -1f, -1f);
			dragging = false;
		}

		public sealed override void SetDragZone(VisualElement dragElement, Rect hotZone)
		{
			if (m_DragElement != null)
			{
				m_DragElement.UnregisterCallback<PointerDownEvent>(UpdateValueOnPointerDown);
				m_DragElement.UnregisterCallback<PointerUpEvent>(UpdateValueOnPointerUp);
				m_DragElement.UnregisterCallback<KeyDownEvent>(UpdateValueOnKeyDown);
			}
			m_DragElement = dragElement;
			m_DragHotZone = hotZone;
			if (m_DragElement != null)
			{
				dragging = false;
				m_DragElement.RegisterCallback<PointerDownEvent>(UpdateValueOnPointerDown);
				m_DragElement.RegisterCallback<PointerUpEvent>(UpdateValueOnPointerUp);
				m_DragElement.RegisterCallback<KeyDownEvent>(UpdateValueOnKeyDown);
			}
		}

		private bool CanStartDrag(int button, Vector2 localPosition)
		{
			return button == 0 && (m_DragHotZone.width < 0f || m_DragHotZone.height < 0f || m_DragHotZone.Contains(m_DragElement.WorldToLocal(localPosition)));
		}

		private void UpdateValueOnPointerDown(PointerDownEvent evt)
		{
			if (CanStartDrag(evt.button, evt.localPosition))
			{
				if (evt.pointerType == PointerType.mouse)
				{
					m_DragElement.CaptureMouse();
					ProcessDownEvent(evt);
				}
				else if (m_DragElement.panel.contextType == ContextType.Editor)
				{
					evt.PreventDefault();
					m_DragElement.CapturePointer(evt.pointerId);
					ProcessDownEvent(evt);
				}
			}
		}

		private void ProcessDownEvent(EventBase evt)
		{
			evt.StopPropagation();
			dragging = true;
			m_DragElement.RegisterCallback<PointerMoveEvent>(UpdateValueOnPointerMove);
			startValue = m_DrivenField.value;
			m_DrivenField.StartDragging();
			(m_DragElement.panel as BaseVisualElementPanel)?.uiElementsBridge?.SetWantsMouseJumping(1);
		}

		private void UpdateValueOnPointerMove(PointerMoveEvent evt)
		{
			ProcessMoveEvent(evt.shiftKey, evt.altKey, evt.deltaPosition);
		}

		private void ProcessMoveEvent(bool shiftKey, bool altKey, Vector2 deltaPosition)
		{
			if (dragging)
			{
				DeltaSpeed speed = ((!shiftKey) ? ((!altKey) ? DeltaSpeed.Normal : DeltaSpeed.Slow) : DeltaSpeed.Fast);
				m_DrivenField.ApplyInputDeviceDelta(deltaPosition, speed, startValue);
			}
		}

		private void UpdateValueOnPointerUp(PointerUpEvent evt)
		{
			ProcessUpEvent(evt, evt.pointerId);
		}

		private void ProcessUpEvent(EventBase evt, int pointerId)
		{
			if (dragging)
			{
				dragging = false;
				m_DragElement.UnregisterCallback<PointerMoveEvent>(UpdateValueOnPointerMove);
				m_DragElement.ReleasePointer(pointerId);
				if (evt is IMouseEvent)
				{
					m_DragElement.panel.ProcessPointerCapture(PointerId.mousePointerId);
				}
				(m_DragElement.panel as BaseVisualElementPanel)?.uiElementsBridge?.SetWantsMouseJumping(0);
				m_DrivenField.StopDragging();
			}
		}

		private void UpdateValueOnKeyDown(KeyDownEvent evt)
		{
			if (dragging && evt.keyCode == KeyCode.Escape)
			{
				dragging = false;
				m_DrivenField.value = startValue;
				m_DrivenField.StopDragging();
				IPanel panel = (evt.target as VisualElement)?.panel;
				panel.ReleasePointer(PointerId.mousePointerId);
				(panel as BaseVisualElementPanel)?.uiElementsBridge?.SetWantsMouseJumping(0);
			}
		}
	}
	public abstract class Focusable : CallbackEventHandler
	{
		private bool m_DelegatesFocus;

		private bool m_ExcludeFromFocusRing;

		public abstract FocusController focusController { get; }

		public bool focusable { get; set; }

		public int tabIndex { get; set; }

		public bool delegatesFocus
		{
			get
			{
				return m_DelegatesFocus;
			}
			set
			{
				m_DelegatesFocus = value;
			}
		}

		internal bool excludeFromFocusRing
		{
			get
			{
				return m_ExcludeFromFocusRing;
			}
			set
			{
				if (!((VisualElement)this).isCompositeRoot)
				{
					throw new InvalidOperationException("excludeFromFocusRing should only be set on composite roots.");
				}
				m_ExcludeFromFocusRing = value;
			}
		}

		public virtual bool canGrabFocus => focusable;

		protected Focusable()
		{
			focusable = true;
			tabIndex = 0;
		}

		public virtual void Focus()
		{
			if (focusController != null)
			{
				if (canGrabFocus)
				{
					Focusable focusDelegate = GetFocusDelegate();
					focusController.SwitchFocus(focusDelegate, this != focusDelegate);
				}
				else
				{
					focusController.SwitchFocus(null);
				}
			}
		}

		public virtual void Blur()
		{
			focusController?.Blur(this);
		}

		internal void BlurImmediately()
		{
			focusController?.Blur(this, bIsFocusDelegated: false, DispatchMode.Immediate);
		}

		private Focusable GetFocusDelegate()
		{
			Focusable focusable = this;
			while (focusable != null && focusable.delegatesFocus)
			{
				focusable = GetFirstFocusableChild(focusable as VisualElement);
			}
			return focusable;
		}

		private static Focusable GetFirstFocusableChild(VisualElement ve)
		{
			int childCount = ve.hierarchy.childCount;
			for (int i = 0; i < childCount; i++)
			{
				VisualElement visualElement = ve.hierarchy[i];
				if (visualElement.canGrabFocus && visualElement.tabIndex >= 0)
				{
					return visualElement;
				}
				bool flag = visualElement.hierarchy.parent != null && visualElement == visualElement.hierarchy.parent.contentContainer;
				if (!visualElement.isCompositeRoot && !flag)
				{
					Focusable firstFocusableChild = GetFirstFocusableChild(visualElement);
					if (firstFocusableChild != null)
					{
						return firstFocusableChild;
					}
				}
			}
			return null;
		}

		[EventInterest(new Type[]
		{
			typeof(PointerDownEvent),
			typeof(NavigationMoveEvent)
		})]
		protected override void ExecuteDefaultAction(EventBase evt)
		{
			base.ExecuteDefaultAction(evt);
			ProcessEvent(evt);
		}

		[EventInterest(new Type[]
		{
			typeof(PointerDownEvent),
			typeof(NavigationMoveEvent)
		})]
		internal override void ExecuteDefaultActionDisabled(EventBase evt)
		{
			base.ExecuteDefaultActionDisabled(evt);
			ProcessEvent(evt);
		}

		private void ProcessEvent(EventBase evt)
		{
			if (evt != null && evt.target == evt.leafTarget)
			{
				focusController?.SwitchFocusOnEvent(evt);
			}
		}
	}
	public class FocusChangeDirection : IDisposable
	{
		private readonly int m_Value;

		public static FocusChangeDirection unspecified { get; } = new FocusChangeDirection(-1);

		public static FocusChangeDirection none { get; } = new FocusChangeDirection(0);

		protected static FocusChangeDirection lastValue { get; } = none;

		protected FocusChangeDirection(int value)
		{
			m_Value = value;
		}

		public static implicit operator int(FocusChangeDirection fcd)
		{
			return fcd?.m_Value ?? 0;
		}

		void IDisposable.Dispose()
		{
			Dispose();
		}

		protected virtual void Dispose()
		{
		}

		internal virtual void ApplyTo(FocusController focusController, Focusable f)
		{
			focusController.SwitchFocus(f, this);
		}
	}
	public interface IFocusRing
	{
		FocusChangeDirection GetFocusChangeDirection(Focusable currentFocusable, EventBase e);

		Focusable GetNextFocusable(Focusable currentFocusable, FocusChangeDirection direction);
	}
	public class FocusController
	{
		private struct FocusedElement
		{
			public VisualElement m_SubTreeRoot;

			public Focusable m_FocusedElement;
		}

		private TextElement m_SelectedTextElement;

		private List<FocusedElement> m_FocusedElements = new List<FocusedElement>();

		private Focusable m_LastFocusedElement;

		internal Focusable m_LastPendingFocusedElement;

		private int m_PendingFocusCount = 0;

		private IFocusRing focusRing { get; }

		internal TextElement selectedTextElement
		{
			get
			{
				return m_SelectedTextElement;
			}
			set
			{
				if (m_SelectedTextElement != value)
				{
					m_SelectedTextElement?.selection.SelectNone();
					m_SelectedTextElement = value;
				}
			}
		}

		public Focusable focusedElement
		{
			get
			{
				Focusable retargetedFocusedElement = GetRetargetedFocusedElement(null);
				return IsLocalElement(retargetedFocusedElement) ? retargetedFocusedElement : null;
			}
		}

		internal int imguiKeyboardControl { get; set; }

		public FocusController(IFocusRing focusRing)
		{
			this.focusRing = focusRing;
			imguiKeyboardControl = 0;
		}

		internal bool IsFocused(Focusable f)
		{
			if (!IsLocalElement(f))
			{
				return false;
			}
			foreach (FocusedElement focusedElement in m_FocusedElements)
			{
				if (focusedElement.m_FocusedElement == f)
				{
					return true;
				}
			}
			return false;
		}

		internal Focusable GetRetargetedFocusedElement(VisualElement retargetAgainst)
		{
			VisualElement visualElement = retargetAgainst?.hierarchy.parent;
			if (visualElement == null)
			{
				if (m_FocusedElements.Count > 0)
				{
					return m_FocusedElements[m_FocusedElements.Count - 1].m_FocusedElement;
				}
			}
			else
			{
				while (!visualElement.isCompositeRoot && visualElement.hierarchy.parent != null)
				{
					visualElement = visualElement.hierarchy.parent;
				}
				foreach (FocusedElement focusedElement in m_FocusedElements)
				{
					if (focusedElement.m_SubTreeRoot == visualElement)
					{
						return focusedElement.m_FocusedElement;
					}
				}
			}
			return null;
		}

		internal Focusable GetLeafFocusedElement()
		{
			if (m_FocusedElements.Count > 0)
			{
				Focusable focusable = m_FocusedElements[0].m_FocusedElement;
				return IsLocalElement(focusable) ? focusable : null;
			}
			return null;
		}

		private bool IsLocalElement(Focusable f)
		{
			return f?.focusController == this;
		}

		internal void ClearPendingFocusEvents()
		{
			m_PendingFocusCount = 0;
			m_LastPendingFocusedElement = null;
		}

		internal bool IsPendingFocus(Focusable f)
		{
			for (VisualElement visualElement = m_LastPendingFocusedElement as VisualElement; visualElement != null; visualElement = visualElement.hierarchy.parent)
			{
				if (f == visualElement)
				{
					return true;
				}
			}
			return false;
		}

		internal void SetFocusToLastFocusedElement()
		{
			if (m_LastFocusedElement != null && !(m_LastFocusedElement is IMGUIContainer))
			{
				m_LastFocusedElement.Focus();
			}
		}

		internal void BlurLastFocusedElement()
		{
			selectedTextElement = null;
			if (m_LastFocusedElement != null && !(m_LastFocusedElement is IMGUIContainer))
			{
				Focusable lastFocusedElement = m_LastFocusedElement;
				m_LastFocusedElement.Blur();
				m_LastFocusedElement = lastFocusedElement;
			}
		}

		internal void DoFocusChange(Focusable f)
		{
			m_FocusedElements.Clear();
			for (VisualElement visualElement = f as VisualElement; visualElement != null; visualElement = visualElement.hierarchy.parent)
			{
				if (visualElement.hierarchy.parent == null || visualElement.isCompositeRoot)
				{
					m_FocusedElements.Add(new FocusedElement
					{
						m_SubTreeRoot = visualElement,
						m_FocusedElement = f
					});
					f = visualElement;
				}
			}
		}

		internal void ProcessPendingFocusChange(Focusable f)
		{
			m_PendingFocusCount--;
			if (m_PendingFocusCount == 0)
			{
				m_LastPendingFocusedElement = null;
			}
			DoFocusChange(f);
		}

		internal Focusable FocusNextInDirection(FocusChangeDirection direction)
		{
			Focusable nextFocusable = focusRing.GetNextFocusable(GetLeafFocusedElement(), direction);
			direction.ApplyTo(this, nextFocusable);
			return nextFocusable;
		}

		private void AboutToReleaseFocus(Focusable focusable, Focusable willGiveFocusTo, FocusChangeDirection direction, DispatchMode dispatchMode)
		{
			using FocusOutEvent e = FocusEventBase<FocusOutEvent>.GetPooled(focusable, willGiveFocusTo, direction, this);
			focusable.SendEvent(e, dispatchMode);
		}

		private void ReleaseFocus(Focusable focusable, Focusable willGiveFocusTo, FocusChangeDirection direction, DispatchMode dispatchMode)
		{
			using BlurEvent e = FocusEventBase<BlurEvent>.GetPooled(focusable, willGiveFocusTo, direction, this);
			focusable.SendEvent(e, dispatchMode);
		}

		private void AboutToGrabFocus(Focusable focusable, Focusable willTakeFocusFrom, FocusChangeDirection direction, DispatchMode dispatchMode)
		{
			using FocusInEvent e = FocusEventBase<FocusInEvent>.GetPooled(focusable, willTakeFocusFrom, direction, this);
			focusable.SendEvent(e, dispatchMode);
		}

		private void GrabFocus(Focusable focusable, Focusable willTakeFocusFrom, FocusChangeDirection direction, bool bIsFocusDelegated, DispatchMode dispatchMode)
		{
			using FocusEvent e = FocusEventBase<FocusEvent>.GetPooled(focusable, willTakeFocusFrom, direction, this, bIsFocusDelegated);
			focusable.SendEvent(e, dispatchMode);
		}

		internal void Blur(Focusable focusable, bool bIsFocusDelegated = false, DispatchMode dispatchMode = DispatchMode.Default)
		{
			if ((m_PendingFocusCount > 0) ? IsPendingFocus(focusable) : IsFocused(focusable))
			{
				SwitchFocus(null, bIsFocusDelegated, dispatchMode);
			}
		}

		internal void SwitchFocus(Focusable newFocusedElement, bool bIsFocusDelegated = false, DispatchMode dispatchMode = DispatchMode.Default)
		{
			SwitchFocus(newFocusedElement, FocusChangeDirection.unspecified, bIsFocusDelegated, dispatchMode);
		}

		internal void SwitchFocus(Focusable newFocusedElement, FocusChangeDirection direction, bool bIsFocusDelegated = false, DispatchMode dispatchMode = DispatchMode.Default)
		{
			m_LastFocusedElement = newFocusedElement;
			Focusable focusable = ((m_PendingFocusCount > 0) ? m_LastPendingFocusedElement : GetLeafFocusedElement());
			if (focusable == newFocusedElement)
			{
				return;
			}
			if (newFocusedElement == null || !newFocusedElement.canGrabFocus)
			{
				if (focusable != null)
				{
					m_LastPendingFocusedElement = null;
					m_PendingFocusCount++;
					AboutToReleaseFocus(focusable, null, direction, dispatchMode);
					ReleaseFocus(focusable, null, direction, dispatchMode);
				}
			}
			else if (newFocusedElement != focusable)
			{
				Focusable willGiveFocusTo = (newFocusedElement as VisualElement)?.RetargetElement(focusable as VisualElement) ?? newFocusedElement;
				Focusable willTakeFocusFrom = (focusable as VisualElement)?.RetargetElement(newFocusedElement as VisualElement) ?? focusable;
				m_LastPendingFocusedElement = newFocusedElement;
				m_PendingFocusCount++;
				if (focusable != null)
				{
					AboutToReleaseFocus(focusable, willGiveFocusTo, direction, dispatchMode);
				}
				AboutToGrabFocus(newFocusedElement, willTakeFocusFrom, direction, dispatchMode);
				if (focusable != null)
				{
					ReleaseFocus(focusable, willGiveFocusTo, direction, dispatchMode);
				}
				GrabFocus(newFocusedElement, willTakeFocusFrom, direction, bIsFocusDelegated, dispatchMode);
			}
		}

		internal void SwitchFocusOnEvent(EventBase e)
		{
			if (e.processedByFocusController)
			{
				return;
			}
			using FocusChangeDirection focusChangeDirection = focusRing.GetFocusChangeDirection(GetLeafFocusedElement(), e);
			if (focusChangeDirection != FocusChangeDirection.none)
			{
				FocusNextInDirection(focusChangeDirection);
				e.processedByFocusController = true;
			}
		}

		internal void ReevaluateFocus()
		{
			if (focusedElement is VisualElement visualElement && (!visualElement.isHierarchyDisplayed || !visualElement.visible))
			{
				visualElement.Blur();
			}
		}

		internal bool GetFocusableParentForPointerEvent(Focusable target, out Focusable effectiveTarget)
		{
			if (target == null || !target.focusable)
			{
				effectiveTarget = target;
				return target != null;
			}
			effectiveTarget = target;
			while (effectiveTarget is VisualElement visualElement && (!visualElement.enabledInHierarchy || !visualElement.focusable) && visualElement.hierarchy.parent != null)
			{
				effectiveTarget = visualElement.hierarchy.parent;
			}
			return !IsFocused(effectiveTarget);
		}

		internal void SyncIMGUIFocus(int imguiKeyboardControlID, Focusable imguiContainerHavingKeyboardControl, bool forceSwitch)
		{
			imguiKeyboardControl = imguiKeyboardControlID;
			if (forceSwitch || imguiKeyboardControl != 0)
			{
				SwitchFocus(imguiContainerHavingKeyboardControl, FocusChangeDirection.unspecified);
			}
			else
			{
				SwitchFocus(null, FocusChangeDirection.unspecified);
			}
		}
	}
	[Serializable]
	public class DynamicAtlasSettings
	{
		[SerializeField]
		[HideInInspector]
		private int m_MinAtlasSize;

		[HideInInspector]
		[SerializeField]
		private int m_MaxAtlasSize;

		[HideInInspector]
		[SerializeField]
		private int m_MaxSubTextureSize;

		[SerializeField]
		[HideInInspector]
		private DynamicAtlasFilters m_ActiveFilters;

		private DynamicAtlasCustomFilter m_CustomFilter;

		public int minAtlasSize
		{
			get
			{
				return m_MinAtlasSize;
			}
			set
			{
				m_MinAtlasSize = value;
			}
		}

		public int maxAtlasSize
		{
			get
			{
				return m_MaxAtlasSize;
			}
			set
			{
				m_MaxAtlasSize = value;
			}
		}

		public int maxSubTextureSize
		{
			get
			{
				return m_MaxSubTextureSize;
			}
			set
			{
				m_MaxSubTextureSize = value;
			}
		}

		public DynamicAtlasFilters activeFilters
		{
			get
			{
				return m_ActiveFilters;
			}
			set
			{
				m_ActiveFilters = value;
			}
		}

		public static DynamicAtlasFilters defaultFilters => DynamicAtlas.defaultFilters;

		public DynamicAtlasCustomFilter customFilter
		{
			get
			{
				return m_CustomFilter;
			}
			set
			{
				m_CustomFilter = value;
			}
		}

		public static DynamicAtlasSettings defaults => new DynamicAtlasSettings
		{
			minAtlasSize = 64,
			maxAtlasSize = 4096,
			maxSubTextureSize = 64,
			activeFilters = defaultFilters,
			customFilter = null
		};
	}
	internal class NavigateFocusRing : IFocusRing
	{
		public class ChangeDirection : FocusChangeDirection
		{
			public ChangeDirection(int i)
				: base(i)
			{
			}
		}

		private struct FocusableHierarchyTraversal
		{
			public VisualElement currentFocusable;

			public Rect validRect;

			public bool firstPass;

			public ChangeDirection direction;

			private bool ValidateHierarchyTraversal(VisualElement v)
			{
				return IsActive(v) && v.worldBoundingBox.Overlaps(validRect);
			}

			private bool ValidateElement(VisualElement v)
			{
				return IsNavigable(v) && v.worldBound.Overlaps(validRect);
			}

			private int Order(VisualElement a, VisualElement b)
			{
				Rect worldBound = a.worldBound;
				Rect worldBound2 = b.worldBound;
				int num = StrictOrder(worldBound, worldBound2);
				return (num != 0) ? num : TieBreaker(worldBound, worldBound2);
			}

			private int StrictOrder(VisualElement a, VisualElement b)
			{
				return StrictOrder(a.worldBound, b.worldBound);
			}

			private int StrictOrder(Rect ra, Rect rb)
			{
				float num = 0f;
				if (direction == Up)
				{
					num = rb.yMax - ra.yMax;
				}
				else if (direction == Down)
				{
					num = ra.yMin - rb.yMin;
				}
				else if (direction == Left)
				{
					num = rb.xMax - ra.xMax;
				}
				else if (direction == Right)
				{
					num = ra.xMin - rb.xMin;
				}
				if (!Mathf.Approximately(num, 0f))
				{
					return (num > 0f) ? 1 : (-1);
				}
				return 0;
			}

			private int TieBreaker(Rect ra, Rect rb)
			{
				Rect worldBound = currentFocusable.worldBound;
				float num = (ra.min - worldBound.min).sqrMagnitude - (rb.min - worldBound.min).sqrMagnitude;
				if (!Mathf.Approximately(num, 0f))
				{
					return (num > 0f) ? 1 : (-1);
				}
				return 0;
			}

			public VisualElement GetBestOverall(VisualElement candidate, VisualElement bestSoFar = null)
			{
				if (!ValidateHierarchyTraversal(candidate))
				{
					return bestSoFar;
				}
				if (ValidateElement(candidate))
				{
					if ((!firstPass || StrictOrder(candidate, currentFocusable) > 0) && (bestSoFar == null || Order(bestSoFar, candidate) > 0))
					{
						bestSoFar = candidate;
					}
					return bestSoFar;
				}
				int childCount = candidate.hierarchy.childCount;
				for (int i = 0; i < childCount; i++)
				{
					VisualElement candidate2 = candidate.hierarchy[i];
					bestSoFar = GetBestOverall(candidate2, bestSoFar);
				}
				return bestSoFar;
			}
		}

		public static readonly ChangeDirection Left = new ChangeDirection(1);

		public static readonly ChangeDirection Right = new ChangeDirection(2);

		public static readonly ChangeDirection Up = new ChangeDirection(3);

		public static readonly ChangeDirection Down = new ChangeDirection(4);

		public static readonly FocusChangeDirection Next = VisualElementFocusChangeDirection.right;

		public static readonly FocusChangeDirection Previous = VisualElementFocusChangeDirection.left;

		private readonly VisualElement m_Root;

		private readonly VisualElementFocusRing m_Ring;

		private FocusController focusController => m_Root.focusController;

		public NavigateFocusRing(VisualElement root)
		{
			m_Root = root;
			m_Ring = new VisualElementFocusRing(root);
		}

		public FocusChangeDirection GetFocusChangeDirection(Focusable currentFocusable, EventBase e)
		{
			if (e.eventTypeId == EventBase<PointerDownEvent>.TypeId() && focusController.GetFocusableParentForPointerEvent(e.target as Focusable, out var effectiveTarget))
			{
				return VisualElementFocusChangeTarget.GetPooled(effectiveTarget);
			}
			if (e.eventTypeId == EventBase<NavigationMoveEvent>.TypeId())
			{
				switch (((NavigationMoveEvent)e).direction)
				{
				case NavigationMoveEvent.Direction.Left:
					return Left;
				case NavigationMoveEvent.Direction.Up:
					return Up;
				case NavigationMoveEvent.Direction.Right:
					return Right;
				case NavigationMoveEvent.Direction.Down:
					return Down;
				case NavigationMoveEvent.Direction.Next:
					return Next;
				case NavigationMoveEvent.Direction.Previous:
					return Previous;
				}
			}
			return FocusChangeDirection.none;
		}

		public virtual Focusable GetNextFocusable(Focusable currentFocusable, FocusChangeDirection direction)
		{
			if (direction == Up || direction == Down || direction == Right || direction == Left)
			{
				return GetNextFocusable2D(currentFocusable, (ChangeDirection)direction);
			}
			return m_Ring.GetNextFocusable(currentFocusable, direction);
		}

		private Focusable GetNextFocusable2D(Focusable currentFocusable, ChangeDirection direction)
		{
			VisualElement visualElement = currentFocusable as VisualElement;
			if (visualElement == null)
			{
				visualElement = m_Root;
			}
			Rect worldBoundingBox = m_Root.worldBoundingBox;
			Rect rect = new Rect(worldBoundingBox.position - Vector2.one, worldBoundingBox.size + Vector2.one * 2f);
			Rect worldBound = visualElement.worldBound;
			Rect validRect = new Rect(worldBound.position - Vector2.one, worldBound.size + Vector2.one * 2f);
			if (direction == Up)
			{
				validRect.yMin = rect.yMin;
			}
			else if (direction == Down)
			{
				validRect.yMax = rect.yMax;
			}
			else if (direction == Left)
			{
				validRect.xMin = rect.xMin;
			}
			else if (direction == Right)
			{
				validRect.xMax = rect.xMax;
			}
			Focusable bestOverall = new FocusableHierarchyTraversal
			{
				currentFocusable = visualElement,
				direction = direction,
				validRect = validRect,
				firstPass = true
			}.GetBestOverall(m_Root);
			if (bestOverall != null)
			{
				return bestOverall;
			}
			validRect = new Rect(worldBound.position - Vector2.one, worldBound.size + Vector2.one * 2f);
			if (direction == Down)
			{
				validRect.yMin = rect.yMin;
			}
			else if (direction == Up)
			{
				validRect.yMax = rect.yMax;
			}
			else if (direction == Right)
			{
				validRect.xMin = rect.xMin;
			}
			else if (direction == Left)
			{
				validRect.xMax = rect.xMax;
			}
			bestOverall = new FocusableHierarchyTraversal
			{
				currentFocusable = visualElement,
				direction = direction,
				validRect = validRect,
				firstPass = false
			}.GetBestOverall(m_Root);
			if (bestOverall != null)
			{
				return bestOverall;
			}
			return currentFocusable;
		}

		private static bool IsActive(VisualElement v)
		{
			return v.resolvedStyle.display != DisplayStyle.None && v.enabledInHierarchy;
		}

		private static bool IsNavigable(Focusable focusable)
		{
			return focusable.canGrabFocus && focusable.tabIndex >= 0 && !focusable.delegatesFocus && !focusable.excludeFromFocusRing;
		}
	}
	public enum PanelScaleMode
	{
		ConstantPixelSize,
		ConstantPhysicalSize,
		ScaleWithScreenSize
	}
	public enum PanelScreenMatchMode
	{
		MatchWidthOrHeight,
		Shrink,
		Expand
	}
	[HelpURL("UIE-Runtime-Panel-Settings")]
	public class PanelSettings : ScriptableObject
	{
		private class RuntimePanelAccess
		{
			private readonly PanelSettings m_Settings;

			private BaseRuntimePanel m_RuntimePanel;

			internal bool isInitialized => m_RuntimePanel != null;

			internal BaseRuntimePanel panel
			{
				get
				{
					if (m_RuntimePanel == null)
					{
						m_RuntimePanel = CreateRelatedRuntimePanel();
						m_RuntimePanel.sortingPriority = m_Settings.m_SortingOrder;
						m_RuntimePanel.targetDisplay = m_Settings.m_TargetDisplay;
						VisualElement visualTree = m_RuntimePanel.visualTree;
						visualTree.name = m_Settings.name;
						m_Settings.ApplyThemeStyleSheet(visualTree);
						if (m_Settings.m_TargetTexture != null)
						{
							m_RuntimePanel.targetTexture = m_Settings.m_TargetTexture;
						}
						if (m_Settings.m_AssignedScreenToPanel != null)
						{
							m_Settings.SetScreenToPanelSpaceFunction(m_Settings.m_AssignedScreenToPanel);
						}
					}
					return m_RuntimePanel;
				}
			}

			internal RuntimePanelAccess(PanelSettings settings)
			{
				m_Settings = settings;
			}

			internal void DisposePanel()
			{
				if (m_RuntimePanel != null)
				{
					DisposeRelatedPanel();
					m_RuntimePanel = null;
				}
			}

			internal void SetTargetTexture()
			{
				if (m_RuntimePanel != null)
				{
					m_RuntimePanel.targetTexture = m_Settings.targetTexture;
				}
			}

			internal void SetSortingPriority()
			{
				if (m_RuntimePanel != null)
				{
					m_RuntimePanel.sortingPriority = m_Settings.m_SortingOrder;
				}
			}

			internal void SetTargetDisplay()
			{
				if (m_RuntimePanel != null)
				{
					m_RuntimePanel.targetDisplay = m_Settings.m_TargetDisplay;
				}
			}

			private BaseRuntimePanel CreateRelatedRuntimePanel()
			{
				return (RuntimePanel)UIElementsRuntimeUtility.FindOrCreateRuntimePanel(m_Settings, RuntimePanel.Create);
			}

			private void DisposeRelatedPanel()
			{
				UIElementsRuntimeUtility.DisposeRuntimePanel(m_Settings);
			}

			internal void MarkPotentiallyEmpty()
			{
				UIElementsRuntimeUtility.MarkPotentiallyEmpty(m_Settings);
			}
		}

		private const int k_DefaultSortingOrder = 0;

		private const float k_DefaultScaleValue = 1f;

		internal const string k_DefaultStyleSheetPath = "Packages/com.unity.ui/PackageResources/StyleSheets/Generated/Default.tss.asset";

		[SerializeField]
		private ThemeStyleSheet themeUss;

		[SerializeField]
		private RenderTexture m_TargetTexture;

		[SerializeField]
		private PanelScaleMode m_ScaleMode = PanelScaleMode.ConstantPhysicalSize;

		[SerializeField]
		private float m_ReferenceSpritePixelsPerUnit = 100f;

		[SerializeField]
		private float m_Scale = 1f;

		private const float DefaultDpi = 96f;

		[SerializeField]
		private float m_ReferenceDpi = 96f;

		[SerializeField]
		private float m_FallbackDpi = 96f;

		[SerializeField]
		private Vector2Int m_ReferenceResolution = new Vector2Int(1200, 800);

		[SerializeField]
		private PanelScreenMatchMode m_ScreenMatchMode = PanelScreenMatchMode.MatchWidthOrHeight;

		[SerializeField]
		[Range(0f, 1f)]
		private float m_Match = 0f;

		[SerializeField]
		private float m_SortingOrder = 0f;

		[SerializeField]
		private int m_TargetDisplay = 0;

		[SerializeField]
		private bool m_ClearDepthStencil = true;

		[SerializeField]
		private bool m_ClearColor;

		[SerializeField]
		private Color m_ColorClearValue = Color.clear;

		private RuntimePanelAccess m_PanelAccess;

		internal UIDocumentList m_AttachedUIDocumentsList;

		[HideInInspector]
		[SerializeField]
		private DynamicAtlasSettings m_DynamicAtlasSettings = DynamicAtlasSettings.defaults;

		[SerializeField]
		[HideInInspector]
		private Shader m_AtlasBlitShader;

		[SerializeField]
		[HideInInspector]
		private Shader m_RuntimeShader;

		[SerializeField]
		[HideInInspector]
		private Shader m_RuntimeWorldShader;

		[SerializeField]
		public PanelTextSettings textSettings;

		private Rect m_TargetRect;

		private float m_ResolvedScale;

		private StyleSheet m_OldThemeUss;

		private Func<Vector2, Vector2> m_AssignedScreenToPanel;

		public ThemeStyleSheet themeStyleSheet
		{
			get
			{
				return themeUss;
			}
			set
			{
				themeUss = value;
				ApplyThemeStyleSheet();
			}
		}

		public RenderTexture targetTexture
		{
			get
			{
				return m_TargetTexture;
			}
			set
			{
				m_TargetTexture = value;
				m_PanelAccess.SetTargetTexture();
			}
		}

		public PanelScaleMode scaleMode
		{
			get
			{
				return m_ScaleMode;
			}
			set
			{
				m_ScaleMode = value;
			}
		}

		public float referenceSpritePixelsPerUnit
		{
			get
			{
				return m_ReferenceSpritePixelsPerUnit;
			}
			set
			{
				m_ReferenceSpritePixelsPerUnit = value;
			}
		}

		public float scale
		{
			get
			{
				return m_Scale;
			}
			set
			{
				m_Scale = value;
			}
		}

		public float referenceDpi
		{
			get
			{
				return m_ReferenceDpi;
			}
			set
			{
				m_ReferenceDpi = ((value >= 1f) ? value : 96f);
			}
		}

		public float fallbackDpi
		{
			get
			{
				return m_FallbackDpi;
			}
			set
			{
				m_FallbackDpi = ((value >= 1f) ? value : 96f);
			}
		}

		public Vector2Int referenceResolution
		{
			get
			{
				return m_ReferenceResolution;
			}
			set
			{
				m_ReferenceResolution = value;
			}
		}

		public PanelScreenMatchMode screenMatchMode
		{
			get
			{
				return m_ScreenMatchMode;
			}
			set
			{
				m_ScreenMatchMode = value;
			}
		}

		public float match
		{
			get
			{
				return m_Match;
			}
			set
			{
				m_Match = value;
			}
		}

		public float sortingOrder
		{
			get
			{
				return m_SortingOrder;
			}
			set
			{
				m_SortingOrder = value;
				ApplySortingOrder();
			}
		}

		public int targetDisplay
		{
			get
			{
				return m_TargetDisplay;
			}
			set
			{
				m_TargetDisplay = value;
				m_PanelAccess.SetTargetDisplay();
			}
		}

		public bool clearDepthStencil
		{
			get
			{
				return m_ClearDepthStencil;
			}
			set
			{
				m_ClearDepthStencil = value;
			}
		}

		public float depthClearValue => 0.99f;

		public bool clearColor
		{
			get
			{
				return m_ClearColor;
			}
			set
			{
				m_ClearColor = value;
			}
		}

		public Color colorClearValue
		{
			get
			{
				return m_ColorClearValue;
			}
			set
			{
				m_ColorClearValue = value;
			}
		}

		internal BaseRuntimePanel panel => m_PanelAccess.panel;

		internal bool isInitialized => m_PanelAccess?.isInitialized ?? false;

		internal VisualElement visualTree => m_PanelAccess.panel.visualTree;

		public DynamicAtlasSettings dynamicAtlasSettings
		{
			get
			{
				return m_DynamicAtlasSettings;
			}
			set
			{
				m_DynamicAtlasSettings = value;
			}
		}

		private float ScreenDPI { get; set; }

		internal void ApplySortingOrder()
		{
			m_PanelAccess.SetSortingPriority();
		}

		private PanelSettings()
		{
			m_PanelAccess = new RuntimePanelAccess(this);
		}

		private void Reset()
		{
		}

		private void OnEnable()
		{
			if (themeUss == null)
			{
				Debug.LogWarning("No Theme Style Sheet set to PanelSettings " + base.name + ", UI will not render properly", this);
			}
			UpdateScreenDPI();
			InitializeShaders();
		}

		private void OnDisable()
		{
			m_PanelAccess.DisposePanel();
		}

		internal void DisposePanel()
		{
			m_PanelAccess.DisposePanel();
		}

		internal void UpdateScreenDPI()
		{
			ScreenDPI = Screen.dpi;
		}

		private void ApplyThemeStyleSheet(VisualElement root = null)
		{
			if (m_PanelAccess.isInitialized)
			{
				if (root == null)
				{
					root = visualTree;
				}
				if (m_OldThemeUss != themeUss && m_OldThemeUss != null)
				{
					root?.styleSheets.Remove(m_OldThemeUss);
				}
				if (themeUss != null)
				{
					themeUss.isDefaultStyleSheet = true;
					root?.styleSheets.Add(themeUss);
				}
				m_OldThemeUss = themeUss;
			}
		}

		private void InitializeShaders()
		{
			if (m_AtlasBlitShader == null)
			{
				m_AtlasBlitShader = Shader.Find(Shaders.k_AtlasBlit);
			}
			if (m_RuntimeShader == null)
			{
				m_RuntimeShader = Shader.Find(Shaders.k_Runtime);
			}
			if (m_RuntimeWorldShader == null)
			{
				m_RuntimeWorldShader = Shader.Find(Shaders.k_RuntimeWorld);
			}
			m_PanelAccess.SetTargetTexture();
		}

		internal void ApplyPanelSettings()
		{
			Rect targetRect = m_TargetRect;
			float resolvedScale = m_ResolvedScale;
			UpdateScreenDPI();
			m_TargetRect = GetDisplayRect();
			m_ResolvedScale = ResolveScale(m_TargetRect, ScreenDPI);
			if (visualTree.style.width.value == 0f || m_ResolvedScale != resolvedScale || m_TargetRect.width != targetRect.width || m_TargetRect.height != targetRect.height)
			{
				panel.scale = ((m_ResolvedScale == 0f) ? 0f : (1f / m_ResolvedScale));
				visualTree.style.left = 0f;
				visualTree.style.top = 0f;
				visualTree.style.width = m_TargetRect.width * m_ResolvedScale;
				visualTree.style.height = m_TargetRect.height * m_ResolvedScale;
			}
			panel.targetTexture = targetTexture;
			panel.targetDisplay = targetDisplay;
			panel.drawToCameras = false;
			panel.clearSettings = new PanelClearSettings
			{
				clearColor = m_ClearColor,
				clearDepthStencil = m_ClearDepthStencil,
				color = m_ColorClearValue
			};
			panel.referenceSpritePixelsPerUnit = referenceSpritePixelsPerUnit;
			if (panel.atlas is DynamicAtlas dynamicAtlas)
			{
				dynamicAtlas.minAtlasSize = dynamicAtlasSettings.minAtlasSize;
				dynamicAtlas.maxAtlasSize = dynamicAtlasSettings.maxAtlasSize;
				dynamicAtlas.maxSubTextureSize = dynamicAtlasSettings.maxSubTextureSize;
				dynamicAtlas.activeFilters = dynamicAtlasSettings.activeFilters;
				dynamicAtlas.customFilter = dynamicAtlasSettings.customFilter;
			}
		}

		public void SetScreenToPanelSpaceFunction(Func<Vector2, Vector2> screentoPanelSpaceFunction)
		{
			m_AssignedScreenToPanel = screentoPanelSpaceFunction;
			panel.screenToPanelSpace = m_AssignedScreenToPanel;
		}

		internal float ResolveScale(Rect targetRect, float screenDpi)
		{
			float num = 1f;
			switch (scaleMode)
			{
			case PanelScaleMode.ConstantPhysicalSize:
			{
				float num3 = ((screenDpi == 0f) ? fallbackDpi : screenDpi);
				if (num3 != 0f)
				{
					num = referenceDpi / num3;
				}
				break;
			}
			case PanelScaleMode.ScaleWithScreenSize:
				if (referenceResolution.x * referenceResolution.y != 0)
				{
					Vector2 vector = referenceResolution;
					Vector2 vector2 = new Vector2(targetRect.width / vector.x, targetRect.height / vector.y);
					float num2 = 0f;
					switch (screenMatchMode)
					{
					case PanelScreenMatchMode.Expand:
						num2 = Mathf.Min(vector2.x, vector2.y);
						break;
					case PanelScreenMatchMode.Shrink:
						num2 = Mathf.Max(vector2.x, vector2.y);
						break;
					default:
					{
						float t = Mathf.Clamp01(match);
						num2 = Mathf.Lerp(vector2.x, vector2.y, t);
						break;
					}
					}
					if (num2 != 0f)
					{
						num = 1f / num2;
					}
				}
				break;
			}
			if (scale > 0f)
			{
				return num / scale;
			}
			return 0f;
		}

		internal Rect GetDisplayRect()
		{
			if (m_TargetTexture != null)
			{
				return new Rect(0f, 0f, m_TargetTexture.width, m_TargetTexture.height);
			}
			return new Rect(0f, 0f, BaseRuntimePanel.getScreenRenderingWidth(targetDisplay), BaseRuntimePanel.getScreenRenderingHeight(targetDisplay));
		}

		internal void AttachAndInsertUIDocumentToVisualTree(UIDocument uiDocument)
		{
			if (m_AttachedUIDocumentsList == null)
			{
				m_AttachedUIDocumentsList = new UIDocumentList();
			}
			else
			{
				m_AttachedUIDocumentsList.RemoveFromListAndFromVisualTree(uiDocument);
			}
			m_AttachedUIDocumentsList.AddToListAndToVisualTree(uiDocument, visualTree);
		}

		internal void DetachUIDocument(UIDocument uiDocument)
		{
			if (m_AttachedUIDocumentsList != null)
			{
				m_AttachedUIDocumentsList.RemoveFromListAndFromVisualTree(uiDocument);
				if (m_AttachedUIDocumentsList.m_AttachedUIDocuments.Count == 0)
				{
					m_PanelAccess.MarkPotentiallyEmpty();
				}
			}
		}
	}
	internal static class RuntimeEventDispatcher
	{
		public static EventDispatcher Create()
		{
			return EventDispatcher.CreateForRuntime(new List<IEventDispatchingStrategy>
			{
				new PointerCaptureDispatchingStrategy(),
				new MouseCaptureDispatchingStrategy(),
				new KeyboardEventDispatchingStrategy(),
				new PointerEventDispatchingStrategy(),
				new MouseEventDispatchingStrategy(),
				new NavigationEventDispatchingStrategy(),
				new DefaultDispatchingStrategy()
			});
		}
	}
	internal interface IRuntimePanel
	{
		PanelSettings panelSettings { get; }

		GameObject selectableGameObject { get; set; }
	}
	internal class RuntimePanel : BaseRuntimePanel, IRuntimePanel
	{
		internal static readonly EventDispatcher s_EventDispatcher = RuntimeEventDispatcher.Create();

		private readonly PanelSettings m_PanelSettings;

		public PanelSettings panelSettings => m_PanelSettings;

		public static RuntimePanel Create(ScriptableObject ownerObject)
		{
			return new RuntimePanel(ownerObject);
		}

		private RuntimePanel(ScriptableObject ownerObject)
			: base(ownerObject, s_EventDispatcher)
		{
			focusController = new FocusController(new NavigateFocusRing(visualTree));
			m_PanelSettings = ownerObject as PanelSettings;
			base.name = ((m_PanelSettings != null) ? m_PanelSettings.name : "RuntimePanel");
			visualTree.RegisterCallback(delegate(FocusEvent e, RuntimePanel p)
			{
				p.OnElementFocus(e);
			}, this, TrickleDown.TrickleDown);
		}

		public override void Update()
		{
			if (m_PanelSettings != null)
			{
				m_PanelSettings.ApplyPanelSettings();
			}
			base.Update();
		}

		private void OnElementFocus(FocusEvent evt)
		{
			UIElementsRuntimeUtility.defaultEventSystem.OnFocusEvent(this, evt);
		}
	}
	public static class RuntimePanelUtils
	{
		public static Vector2 ScreenToPanel(IPanel panel, Vector2 screenPosition)
		{
			return ((BaseRuntimePanel)panel).ScreenToPanel(screenPosition);
		}

		public static Vector2 CameraTransformWorldToPanel(IPanel panel, Vector3 worldPosition, Camera camera)
		{
			Vector2 screen = camera.WorldToScreenPoint(worldPosition);
			screen.y = (float)Screen.height - screen.y;
			return ((BaseRuntimePanel)panel).ScreenToPanel(screen);
		}

		public static Rect CameraTransformWorldToPanelRect(IPanel panel, Vector3 worldPosition, Vector2 worldSize, Camera camera)
		{
			worldSize.y = 0f - worldSize.y;
			Vector2 vector = CameraTransformWorldToPanel(panel, worldPosition, camera);
			Vector3 worldPosition2 = worldPosition + camera.worldToCameraMatrix.MultiplyVector(worldSize);
			Vector2 vector2 = CameraTransformWorldToPanel(panel, worldPosition2, camera);
			return new Rect(vector, vector2 - vector);
		}

		public static void ResetDynamicAtlas(this IPanel panel)
		{
			if (panel is BaseVisualElementPanel { atlas: DynamicAtlas atlas })
			{
				atlas.Reset();
			}
		}

		public static void SetTextureDirty(this IPanel panel, Texture2D texture)
		{
			if (panel is BaseVisualElementPanel { atlas: DynamicAtlas atlas })
			{
				atlas.SetDirty(texture);
			}
		}
	}
	internal class UIDocumentList
	{
		internal List<UIDocument> m_AttachedUIDocuments = new List<UIDocument>();

		internal void RemoveFromListAndFromVisualTree(UIDocument uiDocument)
		{
			m_AttachedUIDocuments.Remove(uiDocument);
			uiDocument.rootVisualElement?.RemoveFromHierarchy();
		}

		internal void AddToListAndToVisualTree(UIDocument uiDocument, VisualElement visualTree, int firstInsertIndex = 0)
		{
			int num = 0;
			foreach (UIDocument attachedUIDocument in m_AttachedUIDocuments)
			{
				if (uiDocument.sortingOrder > attachedUIDocument.sortingOrder)
				{
					num++;
					continue;
				}
				if (!(uiDocument.sortingOrder < attachedUIDocument.sortingOrder) && uiDocument.m_UIDocumentCreationIndex > attachedUIDocument.m_UIDocumentCreationIndex)
				{
					num++;
					continue;
				}
				break;
			}
			if (num < m_AttachedUIDocuments.Count)
			{
				m_AttachedUIDocuments.Insert(num, uiDocument);
				if (visualTree == null || uiDocument.rootVisualElement == null)
				{
					return;
				}
				if (num > 0)
				{
					VisualElement visualElement = null;
					int num2 = 1;
					while (visualElement == null && num - num2 >= 0)
					{
						UIDocument uIDocument = m_AttachedUIDocuments[num - num2++];
						visualElement = uIDocument.rootVisualElement;
					}
					if (visualElement != null)
					{
						num = visualTree.IndexOf(visualElement) + 1;
					}
				}
				if (num > visualTree.childCount)
				{
					num = visualTree.childCount;
				}
			}
			else
			{
				m_AttachedUIDocuments.Add(uiDocument);
			}
			if (visualTree != null && uiDocument.rootVisualElement != null)
			{
				int num3 = firstInsertIndex + num;
				if (num3 < visualTree.childCount)
				{
					visualTree.Insert(num3, uiDocument.rootVisualElement);
				}
				else
				{
					visualTree.Add(uiDocument.rootVisualElement);
				}
			}
		}
	}
	[AddComponentMenu("UI Toolkit/UI Document")]
	[ExecuteAlways]
	[DefaultExecutionOrder(-100)]
	[HelpURL("UIE-get-started-with-runtime-ui")]
	[DisallowMultipleComponent]
	public sealed class UIDocument : MonoBehaviour
	{
		internal const string k_RootStyleClassName = "unity-ui-document__root";

		internal const string k_VisualElementNameSuffix = "-container";

		private const int k_DefaultSortingOrder = 0;

		private static int s_CurrentUIDocumentCounter;

		internal readonly int m_UIDocumentCreationIndex;

		[SerializeField]
		private PanelSettings m_PanelSettings;

		private PanelSettings m_PreviousPanelSettings = null;

		[SerializeField]
		private UIDocument m_ParentUI;

		private UIDocumentList m_ChildrenContent = null;

		private List<UIDocument> m_ChildrenContentCopy = null;

		[SerializeField]
		private VisualTreeAsset sourceAsset;

		private VisualElement m_RootVisualElement;

		private int m_FirstChildInsertIndex;

		[SerializeField]
		private float m_SortingOrder = 0f;

		public PanelSettings panelSettings
		{
			get
			{
				return m_PanelSettings;
			}
			set
			{
				if (parentUI == null)
				{
					if (m_PanelSettings == value)
					{
						m_PreviousPanelSettings = m_PanelSettings;
						return;
					}
					if (m_PanelSettings != null)
					{
						m_PanelSettings.DetachUIDocument(this);
					}
					m_PanelSettings = value;
					if (m_PanelSettings != null)
					{
						m_PanelSettings.AttachAndInsertUIDocumentToVisualTree(this);
					}
				}
				else
				{
					Assert.AreEqual(parentUI.m_PanelSettings, value);
					m_PanelSettings = parentUI.m_PanelSettings;
				}
				if (m_ChildrenContent != null)
				{
					foreach (UIDocument attachedUIDocument in m_ChildrenContent.m_AttachedUIDocuments)
					{
						attachedUIDocument.panelSettings = m_PanelSettings;
					}
				}
				m_PreviousPanelSettings = m_PanelSettings;
			}
		}

		public UIDocument parentUI
		{
			get
			{
				return m_ParentUI;
			}
			private set
			{
				m_ParentUI = value;
			}
		}

		public VisualTreeAsset visualTreeAsset
		{
			get
			{
				return sourceAsset;
			}
			set
			{
				sourceAsset = value;
				RecreateUI();
			}
		}

		public VisualElement rootVisualElement => m_RootVisualElement;

		internal int firstChildInserIndex => m_FirstChildInsertIndex;

		public float sortingOrder
		{
			get
			{
				return m_SortingOrder;
			}
			set
			{
				if (m_SortingOrder != value)
				{
					m_SortingOrder = value;
					ApplySortingOrder();
				}
			}
		}

		internal void ApplySortingOrder()
		{
			AddRootVisualElementToTree();
		}

		private UIDocument()
		{
			m_UIDocumentCreationIndex = s_CurrentUIDocumentCounter++;
		}

		private void Awake()
		{
			SetupFromHierarchy();
		}

		private void OnEnable()
		{
			if (parentUI != null && m_PanelSettings == null)
			{
				m_PanelSettings = parentUI.m_PanelSettings;
			}
			if (m_RootVisualElement == null)
			{
				RecreateUI();
			}
			else
			{
				AddRootVisualElementToTree();
			}
		}

		private void SetupFromHierarchy()
		{
			if (parentUI != null)
			{
				parentUI.RemoveChild(this);
			}
			parentUI = FindUIDocumentParent();
		}

		private UIDocument FindUIDocumentParent()
		{
			Transform transform = base.transform;
			Transform parent = transform.parent;
			if (parent != null)
			{
				UIDocument[] componentsInParent = parent.GetComponentsInParent<UIDocument>(includeInactive: true);
				if (componentsInParent != null && componentsInParent.Length != 0)
				{
					return componentsInParent[0];
				}
			}
			return null;
		}

		internal void Reset()
		{
			if (parentUI == null)
			{
				m_PreviousPanelSettings?.DetachUIDocument(this);
				panelSettings = null;
			}
			SetupFromHierarchy();
			if (parentUI != null)
			{
				m_PanelSettings = parentUI.m_PanelSettings;
				AddRootVisualElementToTree();
			}
			else if (m_PanelSettings != null)
			{
				AddRootVisualElementToTree();
			}
		}

		private void AddChildAndInsertContentToVisualTree(UIDocument child)
		{
			if (m_ChildrenContent == null)
			{
				m_ChildrenContent = new UIDocumentList();
			}
			else
			{
				m_ChildrenContent.RemoveFromListAndFromVisualTree(child);
			}
			m_ChildrenContent.AddToListAndToVisualTree(child, m_RootVisualElement, m_FirstChildInsertIndex);
		}

		private void RemoveChild(UIDocument child)
		{
			m_ChildrenContent?.RemoveFromListAndFromVisualTree(child);
		}

		private void RecreateUI()
		{
			if (m_RootVisualElement != null)
			{
				RemoveFromHierarchy();
				m_RootVisualElement = null;
			}
			if (sourceAsset != null)
			{
				m_RootVisualElement = sourceAsset.Instantiate();
				if (m_RootVisualElement == null)
				{
					Debug.LogError("The UXML file set for the UIDocument could not be cloned.");
				}
			}
			if (m_RootVisualElement == null)
			{
				m_RootVisualElement = new TemplateContainer
				{
					name = base.gameObject.name + "-container"
				};
			}
			else
			{
				m_RootVisualElement.name = base.gameObject.name + "-container";
			}
			m_RootVisualElement.pickingMode = PickingMode.Ignore;
			if (base.isActiveAndEnabled)
			{
				AddRootVisualElementToTree();
			}
			m_FirstChildInsertIndex = m_RootVisualElement.childCount;
			if (m_ChildrenContent != null)
			{
				if (m_ChildrenContentCopy == null)
				{
					m_ChildrenContentCopy = new List<UIDocument>(m_ChildrenContent.m_AttachedUIDocuments);
				}
				else
				{
					m_ChildrenContentCopy.AddRange(m_ChildrenContent.m_AttachedUIDocuments);
				}
				foreach (UIDocument item in m_ChildrenContentCopy)
				{
					if (item.isActiveAndEnabled)
					{
						if (item.m_RootVisualElement == null)
						{
							item.RecreateUI();
						}
						else
						{
							AddChildAndInsertContentToVisualTree(item);
						}
					}
				}
				m_ChildrenContentCopy.Clear();
			}
			SetupRootClassList();
		}

		private void SetupRootClassList()
		{
			m_RootVisualElement?.EnableInClassList("unity-ui-document__root", parentUI == null);
		}

		private void AddRootVisualElementToTree()
		{
			if (base.enabled)
			{
				if (parentUI != null)
				{
					parentUI.AddChildAndInsertContentToVisualTree(this);
				}
				else if (m_PanelSettings != null)
				{
					m_PanelSettings.AttachAndInsertUIDocumentToVisualTree(this);
				}
			}
		}

		private void RemoveFromHierarchy()
		{
			if (parentUI != null)
			{
				parentUI.RemoveChild(this);
			}
			else if (m_PanelSettings != null)
			{
				m_PanelSettings.DetachUIDocument(this);
			}
		}

		private void OnDisable()
		{
			if (m_RootVisualElement != null)
			{
				RemoveFromHierarchy();
				m_RootVisualElement = null;
			}
		}

		private void OnTransformChildrenChanged()
		{
			if (m_ChildrenContent == null)
			{
				return;
			}
			if (m_ChildrenContentCopy == null)
			{
				m_ChildrenContentCopy = new List<UIDocument>(m_ChildrenContent.m_AttachedUIDocuments);
			}
			else
			{
				m_ChildrenContentCopy.AddRange(m_ChildrenContent.m_AttachedUIDocuments);
			}
			foreach (UIDocument item in m_ChildrenContentCopy)
			{
				item.ReactToHierarchyChanged();
			}
			m_ChildrenContentCopy.Clear();
		}

		private void OnTransformParentChanged()
		{
			ReactToHierarchyChanged();
		}

		internal void ReactToHierarchyChanged()
		{
			SetupFromHierarchy();
			if (parentUI != null)
			{
				panelSettings = parentUI.m_PanelSettings;
			}
			m_RootVisualElement?.RemoveFromHierarchy();
			AddRootVisualElementToTree();
			SetupRootClassList();
		}
	}
	internal static class UIDocumentHierarchyUtil
	{
		internal static UIDocumentHierarchicalIndexComparer indexComparer = new UIDocumentHierarchicalIndexComparer();

		internal static int FindHierarchicalSortedIndex(SortedDictionary<UIDocumentHierarchicalIndex, UIDocument> children, UIDocument child)
		{
			int num = 0;
			foreach (UIDocument value in children.Values)
			{
				if (value == child)
				{
					return num;
				}
				if (value.rootVisualElement != null && value.rootVisualElement.parent != null)
				{
					num++;
				}
			}
			return num;
		}

		internal static void SetHierarchicalIndex(Transform childTransform, Transform directParentTransform, Transform mainParentTransform, out UIDocumentHierarchicalIndex hierarchicalIndex)
		{
			if (mainParentTransform == null || childTransform == null)
			{
				hierarchicalIndex.pathToParent = null;
				return;
			}
			if (directParentTransform == mainParentTransform)
			{
				hierarchicalIndex.pathToParent = new int[1] { childTransform.GetSiblingIndex() };
				return;
			}
			List<int> list = new List<int>();
			while (mainParentTransform != childTransform && childTransform != null)
			{
				list.Add(childTransform.GetSiblingIndex());
				childTransform = childTransform.parent;
			}
			list.Reverse();
			hierarchicalIndex.pathToParent = list.ToArray();
		}

		internal static void SetGlobalIndex(Transform objectTransform, Transform directParentTransform, out UIDocumentHierarchicalIndex globalIndex)
		{
			if (objectTransform == null)
			{
				globalIndex.pathToParent = null;
				return;
			}
			if (directParentTransform == null)
			{
				globalIndex.pathToParent = new int[1] { objectTransform.GetSiblingIndex() };
				return;
			}
			List<int> list = new List<int> { objectTransform.GetSiblingIndex() };
			while (directParentTransform != null)
			{
				list.Add(directParentTransform.GetSiblingIndex());
				directParentTransform = directParentTransform.parent;
			}
			list.Reverse();
			globalIndex.pathToParent = list.ToArray();
		}
	}
	internal class UIDocumentHierarchicalIndexComparer : IComparer<UIDocumentHierarchicalIndex>
	{
		public int Compare(UIDocumentHierarchicalIndex x, UIDocumentHierarchicalIndex y)
		{
			return x.CompareTo(y);
		}
	}
	internal struct UIDocumentHierarchicalIndex : IComparable<UIDocumentHierarchicalIndex>
	{
		internal int[] pathToParent;

		public int CompareTo(UIDocumentHierarchicalIndex other)
		{
			if (pathToParent == null)
			{
				if (other.pathToParent == null)
				{
					return 0;
				}
				return 1;
			}
			if (other.pathToParent == null)
			{
				return -1;
			}
			int num = pathToParent.Length;
			int num2 = other.pathToParent.Length;
			for (int i = 0; i < num && i < num2; i++)
			{
				if (pathToParent[i] < other.pathToParent[i])
				{
					return -1;
				}
				if (pathToParent[i] > other.pathToParent[i])
				{
					return 1;
				}
			}
			if (num > num2)
			{
				return 1;
			}
			if (num < num2)
			{
				return -1;
			}
			return 0;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder("pathToParent = [");
			if (pathToParent != null)
			{
				int num = pathToParent.Length;
				for (int i = 0; i < num; i++)
				{
					stringBuilder.Append(pathToParent[i]);
					if (i < num - 1)
					{
						stringBuilder.Append(", ");
					}
				}
			}
			stringBuilder.Append("]");
			return stringBuilder.ToString();
		}
	}
	internal static class GroupBoxUtility
	{
		private static Dictionary<IGroupBox, IGroupManager> s_GroupManagers = new Dictionary<IGroupBox, IGroupManager>();

		private static Dictionary<IGroupBoxOption, IGroupManager> s_GroupOptionManagerCache = new Dictionary<IGroupBoxOption, IGroupManager>();

		private static readonly Type k_GenericGroupBoxType = typeof(IGroupBox<>);

		public static void RegisterGroupBoxOption<T>(this T option) where T : VisualElement, IGroupBoxOption
		{
			IGroupBox groupBox = null;
			for (VisualElement parent = option.hierarchy.parent; parent != null; parent = parent.hierarchy.parent)
			{
				if (parent is IGroupBox groupBox2)
				{
					groupBox = groupBox2;
					break;
				}
			}
			IGroupBox groupBox3 = groupBox ?? option.elementPanel;
			IGroupManager groupManager = FindOrCreateGroupManager(groupBox3);
			groupManager.RegisterOption(option);
			s_GroupOptionManagerCache[option] = groupManager;
		}

		public static void UnregisterGroupBoxOption<T>(this T option) where T : VisualElement, IGroupBoxOption
		{
			if (s_GroupOptionManagerCache.ContainsKey(option))
			{
				s_GroupOptionManagerCache[option].UnregisterOption(option);
				s_GroupOptionManagerCache.Remove(option);
			}
		}

		public static void OnOptionSelected<T>(this T selectedOption) where T : VisualElement, IGroupBoxOption
		{
			if (s_GroupOptionManagerCache.ContainsKey(selectedOption))
			{
				s_GroupOptionManagerCache[selectedOption].OnOptionSelectionChanged(selectedOption);
			}
		}

		public static IGroupBoxOption GetSelectedOption(this IGroupBox groupBox)
		{
			return (!s_GroupManagers.ContainsKey(groupBox)) ? null : s_GroupManagers[groupBox].GetSelectedOption();
		}

		public static IGroupManager GetGroupManager(this IGroupBox groupBox)
		{
			return s_GroupManagers.ContainsKey(groupBox) ? s_GroupManagers[groupBox] : null;
		}

		private static IGroupManager FindOrCreateGroupManager(IGroupBox groupBox)
		{
			if (s_GroupManagers.ContainsKey(groupBox))
			{
				return s_GroupManagers[groupBox];
			}
			Type type = null;
			Type[] interfaces = groupBox.GetType().GetInterfaces();
			foreach (Type type2 in interfaces)
			{
				if (type2.IsGenericType && k_GenericGroupBoxType.IsAssignableFrom(type2.GetGenericTypeDefinition()))
				{
					type = type2.GetGenericArguments()[0];
					break;
				}
			}
			object obj;
			if (!(type != null))
			{
				IGroupManager groupManager = new DefaultGroupManager();
				obj = groupManager;
			}
			else
			{
				obj = (IGroupManager)Activator.CreateInstance(type);
			}
			IGroupManager groupManager2 = (IGroupManager)obj;
			groupManager2.Init(groupBox);
			if (groupBox is BaseVisualElementPanel baseVisualElementPanel)
			{
				baseVisualElementPanel.panelDisposed += OnPanelDestroyed;
			}
			else if (groupBox is VisualElement visualElement)
			{
				visualElement.RegisterCallback<DetachFromPanelEvent>(OnGroupBoxDetachedFromPanel);
			}
			s_GroupManagers[groupBox] = groupManager2;
			return groupManager2;
		}

		private static void OnGroupBoxDetachedFromPanel(DetachFromPanelEvent evt)
		{
			s_GroupManagers.Remove(evt.currentTarget as IGroupBox);
		}

		private static void OnPanelDestroyed(BaseVisualElementPanel panel)
		{
			s_GroupManagers.Remove(panel);
			panel.panelDisposed -= OnPanelDestroyed;
		}
	}
	[Obsolete("IDataWatchHandle is no longer supported and will be removed soon", true)]
	internal interface IDataWatchHandle : IDisposable
	{
		Object watched { get; }

		bool disposed { get; }
	}
	[Obsolete("IDataWatchService is no longer supported and will be removed soon", true)]
	internal interface IDataWatchService
	{
		IDataWatchHandle AddWatch(Object watched, Action<Object> onDataChanged);

		void RemoveWatch(IDataWatchHandle handle);

		void ForceDirtyNextPoll(Object obj);
	}
	internal static class IEnumerableExtensions
	{
		internal static bool HasValues(this IEnumerable<string> collection)
		{
			if (collection == null)
			{
				return false;
			}
			using (IEnumerator<string> enumerator = collection.GetEnumerator())
			{
				if (enumerator.MoveNext())
				{
					string current = enumerator.Current;
					return true;
				}
			}
			return false;
		}
	}
	internal interface IGroupBoxOption
	{
		void SetSelected(bool selected);
	}
	internal interface IGroupBox
	{
		void OnOptionAdded(IGroupBoxOption option);

		void OnOptionRemoved(IGroupBoxOption option);
	}
	internal interface IGroupBox<T> : IGroupBox where T : IGroupManager
	{
	}
	internal interface IGroupManager
	{
		void Init(IGroupBox groupBox);

		IGroupBoxOption GetSelectedOption();

		void OnOptionSelectionChanged(IGroupBoxOption selectedOption);

		void RegisterOption(IGroupBoxOption option);

		void UnregisterOption(IGroupBoxOption option);
	}
	internal class DefaultGroupManager : IGroupManager
	{
		private List<IGroupBoxOption> m_GroupOptions = new List<IGroupBoxOption>();

		private IGroupBoxOption m_SelectedOption;

		private IGroupBox m_GroupBox;

		public void Init(IGroupBox groupBox)
		{
			m_GroupBox = groupBox;
		}

		public IGroupBoxOption GetSelectedOption()
		{
			return m_SelectedOption;
		}

		public void OnOptionSelectionChanged(IGroupBoxOption selectedOption)
		{
			if (m_SelectedOption == selectedOption)
			{
				return;
			}
			m_SelectedOption = selectedOption;
			foreach (IGroupBoxOption groupOption in m_GroupOptions)
			{
				groupOption.SetSelected(groupOption == m_SelectedOption);
			}
		}

		public void RegisterOption(IGroupBoxOption option)
		{
			if (!m_GroupOptions.Contains(option))
			{
				m_GroupOptions.Add(option);
				m_GroupBox.OnOptionAdded(option);
			}
		}

		public void UnregisterOption(IGroupBoxOption option)
		{
			m_GroupOptions.Remove(option);
			m_GroupBox.OnOptionRemoved(option);
		}
	}
	internal interface ILiveReloadAssetTracker<T> where T : ScriptableObject
	{
		int StartTrackingAsset(T asset);

		void StopTrackingAsset(T asset);

		bool IsTrackingAsset(T asset);

		bool IsTrackingAssets();

		bool CheckTrackedAssetsDirty();

		void UpdateAssetTrackerCounts(T asset, int newDirtyCount, int newElementCount, int newInlinePropertiesCount, int newAttributePropertiesDirtyCount);

		bool OnAssetsImported(HashSet<T> changedAssets, HashSet<string> deletedAssets);

		void OnTrackedAssetChanged();
	}
	public class IMGUIContainer : VisualElement, IDisposable
	{
		public new class UxmlFactory : UxmlFactory<IMGUIContainer, UxmlTraits>
		{
		}

		public new class UxmlTraits : VisualElement.UxmlTraits
		{
			public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
			{
				get
				{
					yield break;
				}
			}

			public UxmlTraits()
			{
				base.focusIndex.defaultValue = 0;
				base.focusable.defaultValue = true;
			}
		}

		private struct GUIGlobals
		{
			public Matrix4x4 matrix;

			public Color color;

			public Color contentColor;

			public Color backgroundColor;

			public bool enabled;

			public bool changed;

			public int displayIndex;
		}

		private Action m_OnGUIHandler;

		private ObjectGUIState m_ObjectGUIState;

		internal bool useOwnerObjectGUIState;

		private bool m_CullingEnabled = false;

		private bool m_IsFocusDelegated = false;

		private bool m_RefreshCachedLayout = true;

		private GUILayoutUtility.LayoutCache m_Cache = null;

		private Rect m_CachedClippingRect = Rect.zero;

		private Matrix4x4 m_CachedTransform = Matrix4x4.identity;

		private bool lostFocus = false;

		private bool receivedFocus = false;

		private FocusChangeDirection focusChangeDirection = FocusChangeDirection.unspecified;

		private bool hasFocusableControls = false;

		private int newKeyboardFocusControlID = 0;

		public static readonly string ussClassName;

		internal static readonly string ussFoldoutChildDepthClassName;

		internal static readonly List<string> ussFoldoutChildDepthClassNames;

		private GUIGlobals m_GUIGlobals;

		private static readonly ProfilerMarker k_OnGUIMarker;

		private static readonly ProfilerMarker k_ImmediateCallbackMarker;

		private static Event s_DefaultMeasureEvent;

		private static Event s_MeasureEvent;

		private static Event s_CurrentEvent;

		public Action onGUIHandler
		{
			get
			{
				return m_OnGUIHandler;
			}
			set
			{
				if (m_OnGUIHandler != value)
				{
					m_OnGUIHandler = value;
					IncrementVersion(VersionChangeType.Layout);
					IncrementVersion(VersionChangeType.Repaint);
				}
			}
		}

		internal ObjectGUIState guiState
		{
			get
			{
				Debug.Assert(!useOwnerObjectGUIState);
				if (m_ObjectGUIState == null)
				{
					m_ObjectGUIState = new ObjectGUIState();
				}
				return m_ObjectGUIState;
			}
		}

		internal Rect lastWorldClip { get; set; }

		public bool cullingEnabled
		{
			get
			{
				return m_CullingEnabled;
			}
			set
			{
				m_CullingEnabled = value;
				IncrementVersion(VersionChangeType.Repaint);
			}
		}

		private GUILayoutUtility.LayoutCache cache
		{
			get
			{
				if (m_Cache == null)
				{
					m_Cache = new GUILayoutUtility.LayoutCache();
				}
				return m_Cache;
			}
		}

		private float layoutMeasuredWidth => Mathf.Ceil(cache.topLevel.maxWidth);

		private float layoutMeasuredHeight => Mathf.Ceil(cache.topLevel.maxHeight);

		public ContextType contextType { get; set; }

		internal bool focusOnlyIfHasFocusableControls { get; set; } = true;

		public override bool canGrabFocus => (!focusOnlyIfHasFocusableControls) ? base.canGrabFocus : (hasFocusableControls && base.canGrabFocus);

		static IMGUIContainer()
		{
			ussClassName = "unity-imgui-container";
			ussFoldoutChildDepthClassName = Foldout.ussClassName + "__" + ussClassName + "--depth-";
			k_OnGUIMarker = new ProfilerMarker("OnGUI");
			k_ImmediateCallbackMarker = new ProfilerMarker("IMGUIContainer");
			s_DefaultMeasureEvent = new Event
			{
				type = EventType.Layout
			};
			s_MeasureEvent = new Event
			{
				type = EventType.Layout
			};
			s_CurrentEvent = new Event
			{
				type = EventType.Layout
			};
			ussFoldoutChildDepthClassNames = new List<string>(Foldout.ussFoldoutMaxDepth + 1);
			for (int i = 0; i <= Foldout.ussFoldoutMaxDepth; i++)
			{
				ussFoldoutChildDepthClassNames.Add(ussFoldoutChildDepthClassName + i);
			}
			ussFoldoutChildDepthClassNames.Add(ussFoldoutChildDepthClassName + "max");
		}

		public IMGUIContainer()
			: this(null)
		{
		}

		public IMGUIContainer(Action onGUIHandler)
		{
			isIMGUIContainer = true;
			base.eventCallbackCategories |= 90166;
			AddToClassList(ussClassName);
			this.onGUIHandler = onGUIHandler;
			contextType = ContextType.Editor;
			base.focusable = true;
			base.requireMeasureFunction = true;
			base.generateVisualContent = (Action<MeshGenerationContext>)Delegate.Combine(base.generateVisualContent, new Action<MeshGenerationContext>(OnGenerateVisualContent));
		}

		private void OnGenerateVisualContent(MeshGenerationContext mgc)
		{
			lastWorldClip = base.elementPanel.repaintData.currentWorldClip;
			mgc.painter.DrawImmediate(DoIMGUIRepaint, cullingEnabled);
		}

		private void SaveGlobals()
		{
			m_GUIGlobals.matrix = GUI.matrix;
			m_GUIGlobals.color = GUI.color;
			m_GUIGlobals.contentColor = GUI.contentColor;
			m_GUIGlobals.backgroundColor = GUI.backgroundColor;
			m_GUIGlobals.enabled = GUI.enabled;
			m_GUIGlobals.changed = GUI.changed;
			if (Event.current != null)
			{
				m_GUIGlobals.displayIndex = Event.current.displayIndex;
			}
		}

		private void RestoreGlobals()
		{
			GUI.matrix = m_GUIGlobals.matrix;
			GUI.color = m_GUIGlobals.color;
			GUI.contentColor = m_GUIGlobals.contentColor;
			GUI.backgroundColor = m_GUIGlobals.backgroundColor;
			GUI.enabled = m_GUIGlobals.enabled;
			GUI.changed = m_GUIGlobals.changed;
			if (Event.current != null)
			{
				Event.current.displayIndex = m_GUIGlobals.displayIndex;
			}
		}

		private void DoOnGUI(Event evt, Matrix4x4 parentTransform, Rect clippingRect, bool isComputingLayout, Rect layoutSize, Action onGUIHandler, bool canAffectFocus = true)
		{
			if (onGUIHandler == null || base.panel == null)
			{
				return;
			}
			int num = GUIClip.Internal_GetCount();
			SaveGlobals();
			float a = layoutMeasuredWidth;
			float a2 = layoutMeasuredHeight;
			UIElementsUtility.BeginContainerGUI(cache, evt, this);
			GUI.color = UIElementsUtility.editorPlayModeTintColor;
			if (Event.current.type != EventType.Layout)
			{
				if (lostFocus)
				{
					if (focusController != null && GUIUtility.OwnsId(GUIUtility.keyboardControl))
					{
						GUIUtility.keyboardControl = 0;
						focusController.imguiKeyboardControl = 0;
					}
					lostFocus = false;
				}
				if (receivedFocus)
				{
					if (hasFocusableControls)
					{
						if (focusChangeDirection != FocusChangeDirection.unspecified && focusChangeDirection != FocusChangeDirection.none)
						{
							if (Event.current.type == EventType.KeyDown)
							{
								char character = Event.current.character;
								if (character == '\t' || character == '\u0019')
								{
									Event.current.Use();
								}
							}
							if (focusChangeDirection == VisualElementFocusChangeDirection.left)
							{
								GUIUtility.SetKeyboardControlToLastControlId();
							}
							else if (focusChangeDirection == VisualElementFocusChangeDirection.right)
							{
								GUIUtility.SetKeyboardControlToFirstControlId();
							}
						}
						else if (GUIUtility.keyboardControl == 0 && m_IsFocusDelegated)
						{
							GUIUtility.SetKeyboardControlToFirstControlId();
						}
					}
					if (focusController != null)
					{
						if (focusController.imguiKeyboardControl != GUIUtility.keyboardControl && focusChangeDirection != FocusChangeDirection.unspecified)
						{
							newKeyboardFocusControlID = GUIUtility.keyboardControl;
						}
						focusController.imguiKeyboardControl = GUIUtility.keyboardControl;
					}
					receivedFocus = false;
					focusChangeDirection = FocusChangeDirection.unspecified;
				}
			}
			EventType type = Event.current.type;
			bool flag = false;
			try
			{
				using (new GUIClip.ParentClipScope(parentTransform, clippingRect))
				{
					using (k_OnGUIMarker.Auto())
					{
						onGUIHandler();
					}
				}
			}
			catch (Exception exception)
			{
				if (type != EventType.Layout)
				{
					throw;
				}
				flag = GUIUtility.IsExitGUIException(exception);
				if (!flag)
				{
					Debug.LogException(exception);
				}
			}
			finally
			{
				if (Event.current.type != EventType.Layout && canAffectFocus)
				{
					bool flag2 = Event.current.type == EventType.Used;
					int keyboardControl = GUIUtility.keyboardControl;
					int num2 = GUIUtility.CheckForTabEvent(Event.current);
					if (focusController != null)
					{
						if (num2 < 0 && !flag2)
						{
							Focusable leafFocusedElement = focusController.GetLeafFocusedElement();
							Focusable focusable = focusController.FocusNextInDirection((num2 == -1) ? VisualElementFocusChangeDirection.right : VisualElementFocusChangeDirection.left);
							if (leafFocusedElement == this)
							{
								if (focusable == this)
								{
									switch (num2)
									{
									case -2:
										GUIUtility.SetKeyboardControlToLastControlId();
										break;
									case -1:
										GUIUtility.SetKeyboardControlToFirstControlId();
										break;
									}
									newKeyboardFocusControlID = GUIUtility.keyboardControl;
									focusController.imguiKeyboardControl = GUIUtility.keyboardControl;
								}
								else
								{
									GUIUtility.keyboardControl = 0;
									focusController.imguiKeyboardControl = 0;
								}
							}
						}
						else if (num2 > 0 && !flag2)
						{
							focusController.imguiKeyboardControl = GUIUtility.keyboardControl;
							newKeyboardFocusControlID = GUIUtility.keyboardControl;
						}
						else if (num2 == 0)
						{
							if (type == EventType.MouseDown && !focusOnlyIfHasFocusableControls)
							{
								focusController.SyncIMGUIFocus(GUIUtility.keyboardControl, this, forceSwitch: true);
							}
							else if (keyboardControl != GUIUtility.keyboardControl || type == EventType.MouseDown)
							{
								focusController.SyncIMGUIFocus(GUIUtility.keyboardControl, this, forceSwitch: false);
							}
							else if (GUIUtility.keyboardControl != focusController.imguiKeyboardControl)
							{
								newKeyboardFocusControlID = GUIUtility.keyboardControl;
								if (focusController.GetLeafFocusedElement() == this)
								{
									focusController.imguiKeyboardControl = GUIUtility.keyboardControl;
								}
								else
								{
									focusController.SyncIMGUIFocus(GUIUtility.keyboardControl, this, forceSwitch: false);
								}
							}
						}
					}
					hasFocusableControls = GUIUtility.HasFocusableControls();
				}
			}
			UIElementsUtility.EndContainerGUI(evt, layoutSize);
			RestoreGlobals();
			if (evt.type == EventType.Layout && (!Mathf.Approximately(a, layoutMeasuredWidth) || !Mathf.Approximately(a2, layoutMeasuredHeight)))
			{
				if (isComputingLayout && clippingRect == Rect.zero)
				{
					base.schedule.Execute((Action)delegate
					{
						IncrementVersion(VersionChangeType.Layout);
					});
				}
				else
				{
					IncrementVersion(VersionChangeType.Layout);
				}
			}
			if (!flag && evt.type != EventType.Ignore && evt.type != EventType.Used)
			{
				int num3 = GUIClip.Internal_GetCount();
				if (num3 > num)
				{
					Debug.LogError("GUI Error: You are pushing more GUIClips than you are popping. Make sure they are balanced.");
				}
				else if (num3 < num)
				{
					Debug.LogError("GUI Error: You are popping more GUIClips than you are pushing. Make sure they are balanced.");
				}
			}
			while (GUIClip.Internal_GetCount() > num)
			{
				GUIClip.Internal_Pop();
			}
			if (evt.type == EventType.Used)
			{
				IncrementVersion(VersionChangeType.Repaint);
			}
		}

		public void MarkDirtyLayout()
		{
			m_RefreshCachedLayout = true;
			IncrementVersion(VersionChangeType.Layout);
		}

		internal void ProcessEvent(EventBase evt)
		{
			if ((evt.imguiEvent != null && SendEventToIMGUI(evt)) || evt.eventTypeId == EventBase<NavigationMoveEvent>.TypeId() || evt.eventTypeId == EventBase<NavigationSubmitEvent>.TypeId() || evt.eventTypeId == EventBase<NavigationCancelEvent>.TypeId())
			{
				evt.StopPropagation();
				evt.PreventDefault();
			}
		}

		private void DoIMGUIRepaint()
		{
			using (k_ImmediateCallbackMarker.Auto())
			{
				Matrix4x4 currentOffset = base.elementPanel.repaintData.currentOffset;
				m_CachedClippingRect = VisualElement.ComputeAAAlignedBound(base.worldClip, currentOffset);
				m_CachedTransform = currentOffset * base.worldTransform;
				HandleIMGUIEvent(base.elementPanel.repaintData.repaintEvent, m_CachedTransform, m_CachedClippingRect, onGUIHandler, canAffectFocus: true);
			}
		}

		internal bool SendEventToIMGUI(EventBase evt, bool canAffectFocus = true, bool verifyBounds = true)
		{
			if (evt is IPointerEvent)
			{
				if (evt.imguiEvent != null && evt.imguiEvent.isDirectManipulationDevice)
				{
					bool flag = false;
					EventType rawType = evt.imguiEvent.rawType;
					if (evt is PointerDownEvent)
					{
						flag = true;
						evt.imguiEvent.type = EventType.TouchDown;
					}
					else if (evt is PointerUpEvent)
					{
						flag = true;
						evt.imguiEvent.type = EventType.TouchUp;
					}
					else if (evt is PointerMoveEvent && evt.imguiEvent.rawType == EventType.MouseDrag)
					{
						flag = true;
						evt.imguiEvent.type = EventType.TouchMove;
					}
					else if (evt is PointerLeaveEvent)
					{
						flag = true;
						evt.imguiEvent.type = EventType.TouchLeave;
					}
					else if (evt is PointerEnterEvent)
					{
						flag = true;
						evt.imguiEvent.type = EventType.TouchEnter;
					}
					else if (evt is PointerStationaryEvent)
					{
						flag = true;
						evt.imguiEvent.type = EventType.TouchStationary;
					}
					if (flag)
					{
						bool result = SendEventToIMGUIRaw(evt, canAffectFocus, verifyBounds);
						evt.imguiEvent.type = rawType;
						return result;
					}
				}
				return false;
			}
			return SendEventToIMGUIRaw(evt, canAffectFocus, verifyBounds);
		}

		private bool SendEventToIMGUIRaw(EventBase evt, bool canAffectFocus, bool verifyBounds)
		{
			if (verifyBounds && !VerifyBounds(evt))
			{
				return false;
			}
			bool result;
			using (new EventDebuggerLogIMGUICall(evt))
			{
				result = HandleIMGUIEvent(evt.imguiEvent, canAffectFocus);
			}
			return result;
		}

		private bool VerifyBounds(EventBase evt)
		{
			return IsContainerCapturingTheMouse() || !IsLocalEvent(evt) || IsEventInsideLocalWindow(evt) || IsDockAreaMouseUp(evt);
		}

		private bool IsContainerCapturingTheMouse()
		{
			return this == base.panel?.dispatcher?.pointerState.GetCapturingElement(PointerId.mousePointerId);
		}

		private bool IsLocalEvent(EventBase evt)
		{
			long eventTypeId = evt.eventTypeId;
			return eventTypeId == EventBase<MouseDownEvent>.TypeId() || eventTypeId == EventBase<MouseUpEvent>.TypeId() || eventTypeId == EventBase<MouseMoveEvent>.TypeId() || eventTypeId == EventBase<PointerDownEvent>.TypeId() || eventTypeId == EventBase<PointerUpEvent>.TypeId() || eventTypeId == EventBase<PointerMoveEvent>.TypeId();
		}

		private bool IsEventInsideLocalWindow(EventBase evt)
		{
			Rect currentClipRect = GetCurrentClipRect();
			string text = (evt as IPointerEvent)?.pointerType;
			bool isDirectManipulationDevice = text == PointerType.touch || text == PointerType.pen;
			return GUIUtility.HitTest(currentClipRect, evt.originalMousePosition, isDirectManipulationDevice);
		}

		private static bool IsDockAreaMouseUp(EventBase evt)
		{
			return evt.eventTypeId == EventBase<MouseUpEvent>.TypeId() && evt.target == (evt.target as VisualElement)?.elementPanel.rootIMGUIContainer;
		}

		private bool HandleIMGUIEvent(Event e, bool canAffectFocus)
		{
			return HandleIMGUIEvent(e, onGUIHandler, canAffectFocus);
		}

		internal bool HandleIMGUIEvent(Event e, Action onGUIHandler, bool canAffectFocus)
		{
			GetCurrentTransformAndClip(this, e, out m_CachedTransform, out m_CachedClippingRect);
			return HandleIMGUIEvent(e, m_CachedTransform, m_CachedClippingRect, onGUIHandler, canAffectFocus);
		}

		private bool HandleIMGUIEvent(Event e, Matrix4x4 worldTransform, Rect clippingRect, Action onGUIHandler, bool canAffectFocus)
		{
			if (e == null || onGUIHandler == null || base.elementPanel == null || !base.elementPanel.IMGUIEventInterests.WantsEvent(e.rawType))
			{
				return false;
			}
			EventType rawType = e.rawType;
			if (rawType != EventType.Layout)
			{
				if (m_RefreshCachedLayout || base.elementPanel.IMGUIEventInterests.WantsLayoutPass(e.rawType))
				{
					e.type = EventType.Layout;
					DoOnGUI(e, worldTransform, clippingRect, isComputingLayout: false, base.layout, onGUIHandler, canAffectFocus);
					m_RefreshCachedLayout = false;
					e.type = rawType;
				}
				else
				{
					cache.ResetCursor();
				}
			}
			DoOnGUI(e, worldTransform, clippingRect, isComputingLayout: false, base.layout, onGUIHandler, canAffectFocus);
			if (newKeyboardFocusControlID > 0)
			{
				newKeyboardFocusControlID = 0;
				Event e2 = new Event
				{
					type = EventType.ExecuteCommand,
					commandName = "NewKeyboardFocus"
				};
				HandleIMGUIEvent(e2, canAffectFocus: true);
			}
			if (e.rawType == EventType.Used)
			{
				return true;
			}
			if (e.rawType == EventType.MouseUp && this.HasMouseCapture())
			{
				GUIUtility.hotControl = 0;
			}
			if (base.elementPanel == null)
			{
				GUIUtility.ExitGUI();
			}
			return false;
		}

		[EventInterest(new Type[]
		{
			typeof(BlurEvent),
			typeof(FocusEvent),
			typeof(DetachFromPanelEvent),
			typeof(AttachToPanelEvent)
		})]
		protected override void ExecuteDefaultAction(EventBase evt)
		{
			if (evt == null)
			{
				return;
			}
			if (evt.eventTypeId == EventBase<BlurEvent>.TypeId())
			{
				lostFocus = true;
				IncrementVersion(VersionChangeType.Repaint);
			}
			else if (evt.eventTypeId == EventBase<FocusEvent>.TypeId())
			{
				FocusEvent focusEvent = evt as FocusEvent;
				receivedFocus = true;
				focusChangeDirection = focusEvent.direction;
				m_IsFocusDelegated = focusEvent.IsFocusDelegated;
			}
			else if (evt.eventTypeId == EventBase<DetachFromPanelEvent>.TypeId())
			{
				if (base.elementPanel != null)
				{
					base.elementPanel.IMGUIContainersCount--;
				}
			}
			else if (evt.eventTypeId == EventBase<AttachToPanelEvent>.TypeId() && base.elementPanel != null)
			{
				base.elementPanel.IMGUIContainersCount++;
				SetFoldoutDepthClass();
			}
		}

		private void SetFoldoutDepthClass()
		{
			for (int i = 0; i < ussFoldoutChildDepthClassNames.Count; i++)
			{
				RemoveFromClassList(ussFoldoutChildDepthClassNames[i]);
			}
			int foldoutDepth = this.GetFoldoutDepth();
			if (foldoutDepth != 0)
			{
				foldoutDepth = Mathf.Min(foldoutDepth, ussFoldoutChildDepthClassNames.Count - 1);
				AddToClassList(ussFoldoutChildDepthClassNames[foldoutDepth]);
			}
		}

		protected internal override Vector2 DoMeasure(float desiredWidth, MeasureMode widthMode, float desiredHeight, MeasureMode heightMode)
		{
			float num = float.NaN;
			float num2 = float.NaN;
			bool flag = false;
			if (widthMode != MeasureMode.Exactly || heightMode != MeasureMode.Exactly)
			{
				if (Event.current != null)
				{
					s_CurrentEvent.CopyFrom(Event.current);
					flag = true;
				}
				s_MeasureEvent.CopyFrom(s_DefaultMeasureEvent);
				Rect layoutSize = base.layout;
				if (widthMode == MeasureMode.Exactly)
				{
					layoutSize.width = desiredWidth;
				}
				if (heightMode == MeasureMode.Exactly)
				{
					layoutSize.height = desiredHeight;
				}
				DoOnGUI(s_MeasureEvent, m_CachedTransform, m_CachedClippingRect, isComputingLayout: true, layoutSize, onGUIHandler);
				num = layoutMeasuredWidth;
				num2 = layoutMeasuredHeight;
				if (flag)
				{
					Event.current.CopyFrom(s_CurrentEvent);
				}
			}
			switch (widthMode)
			{
			case MeasureMode.Exactly:
				num = desiredWidth;
				break;
			case MeasureMode.AtMost:
				num = Mathf.Min(num, desiredWidth);
				break;
			}
			switch (heightMode)
			{
			case MeasureMode.Exactly:
				num2 = desiredHeight;
				break;
			case MeasureMode.AtMost:
				num2 = Mathf.Min(num2, desiredHeight);
				break;
			}
			return new Vector2(num, num2);
		}

		private Rect GetCurrentClipRect()
		{
			Rect result = lastWorldClip;
			if (result.width == 0f || result.height == 0f)
			{
				result = base.worldBound;
			}
			return result;
		}

		private static void GetCurrentTransformAndClip(IMGUIContainer container, Event evt, out Matrix4x4 transform, out Rect clipRect)
		{
			clipRect = container.GetCurrentClipRect();
			transform = container.worldTransform;
			if (evt != null && evt.rawType == EventType.Repaint && container.elementPanel != null)
			{
				transform = container.elementPanel.repaintData.currentOffset * container.worldTransform;
			}
		}

		public void Dispose()
		{
			Dispose(disposeManaged: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposeManaged)
		{
			if (disposeManaged)
			{
				m_ObjectGUIState?.Dispose();
			}
		}
	}
	public abstract class ImmediateModeElement : VisualElement
	{
		private static readonly Dictionary<Type, ProfilerMarker> s_Markers = new Dictionary<Type, ProfilerMarker>();

		private readonly ProfilerMarker m_ImmediateRepaintMarker;

		private bool m_CullingEnabled = false;

		public bool cullingEnabled
		{
			get
			{
				return m_CullingEnabled;
			}
			set
			{
				m_CullingEnabled = value;
				IncrementVersion(VersionChangeType.Repaint);
			}
		}

		public ImmediateModeElement()
		{
			base.generateVisualContent = (Action<MeshGenerationContext>)Delegate.Combine(base.generateVisualContent, new Action<MeshGenerationContext>(OnGenerateVisualContent));
			Type type = GetType();
			if (!s_Markers.TryGetValue(type, out m_ImmediateRepaintMarker))
			{
				m_ImmediateRepaintMarker = new ProfilerMarker(base.typeName + ".ImmediateRepaint");
				s_Markers[type] = m_ImmediateRepaintMarker;
			}
		}

		private void OnGenerateVisualContent(MeshGenerationContext mgc)
		{
			mgc.painter.DrawImmediate(CallImmediateRepaint, cullingEnabled);
		}

		private void CallImmediateRepaint()
		{
			using (m_ImmediateRepaintMarker.Auto())
			{
				ImmediateRepaint();
			}
		}

		protected abstract void ImmediateRepaint();
	}
	internal class ImmediateModeException : Exception
	{
		public ImmediateModeException(Exception inner)
			: base("", inner)
		{
		}
	}
	public enum SelectionType
	{
		None,
		Single,
		Multiple
	}
	internal interface ISerializableJsonDictionary
	{
		void Set<T>(string key, T value) where T : class;

		T Get<T>(string key) where T : class;

		T GetScriptable<T>(string key) where T : ScriptableObject;

		void Overwrite(object obj, string key);

		bool ContainsKey(string key);

		void OnBeforeSerialize();

		void OnAfterDeserialize();
	}
	public interface ITransform
	{
		Vector3 position { get; set; }

		Quaternion rotation { get; set; }

		Vector3 scale { get; set; }

		Matrix4x4 matrix { get; }
	}
	public enum KeyboardNavigationOperation
	{
		None,
		SelectAll,
		Cancel,
		Submit,
		Previous,
		Next,
		MoveRight,
		MoveLeft,
		PageUp,
		PageDown,
		Begin,
		End
	}
	public class KeyboardNavigationManipulator : Manipulator
	{
		private readonly Action<KeyboardNavigationOperation, EventBase> m_Action;

		public KeyboardNavigationManipulator(Action<KeyboardNavigationOperation, EventBase> action)
		{
			m_Action = action;
		}

		protected override void RegisterCallbacksOnTarget()
		{
			base.target.RegisterCallback<NavigationMoveEvent>(OnNavigationMove);
			base.target.RegisterCallback<NavigationSubmitEvent>(OnNavigationSubmit);
			base.target.RegisterCallback<NavigationCancelEvent>(OnNavigationCancel);
			base.target.RegisterCallback<KeyDownEvent>(OnKeyDown);
		}

		protected override void UnregisterCallbacksFromTarget()
		{
			base.target.UnregisterCallback<NavigationMoveEvent>(OnNavigationMove);
			base.target.UnregisterCallback<NavigationSubmitEvent>(OnNavigationSubmit);
			base.target.UnregisterCallback<NavigationCancelEvent>(OnNavigationCancel);
			base.target.UnregisterCallback<KeyDownEvent>(OnKeyDown);
		}

		internal void OnKeyDown(KeyDownEvent evt)
		{
			KeyboardNavigationOperation keyboardNavigationOperation = GetOperation();
			if (keyboardNavigationOperation != KeyboardNavigationOperation.None)
			{
				Invoke(keyboardNavigationOperation, evt);
			}
			KeyboardNavigationOperation GetOperation()
			{
				switch (evt.keyCode)
				{
				case KeyCode.A:
					if (evt.actionKey)
					{
						return KeyboardNavigationOperation.SelectAll;
					}
					break;
				case KeyCode.Home:
					return KeyboardNavigationOperation.Begin;
				case KeyCode.End:
					return KeyboardNavigationOperation.End;
				case KeyCode.PageUp:
					return KeyboardNavigationOperation.PageUp;
				case KeyCode.PageDown:
					return KeyboardNavigationOperation.PageDown;
				case KeyCode.UpArrow:
				case KeyCode.DownArrow:
				case KeyCode.RightArrow:
				case KeyCode.LeftArrow:
					evt.StopPropagation();
					break;
				}
				return KeyboardNavigationOperation.None;
			}
		}

		private void OnNavigationCancel(NavigationCancelEvent evt)
		{
			Invoke(KeyboardNavigationOperation.Cancel, evt);
		}

		private void OnNavigationSubmit(NavigationSubmitEvent evt)
		{
			Invoke(KeyboardNavigationOperation.Submit, evt);
		}

		private void OnNavigationMove(NavigationMoveEvent evt)
		{
			switch (evt.direction)
			{
			case NavigationMoveEvent.Direction.Up:
				Invoke(KeyboardNavigationOperation.Previous, evt);
				break;
			case NavigationMoveEvent.Direction.Down:
				Invoke(KeyboardNavigationOperation.Next, evt);
				break;
			case NavigationMoveEvent.Direction.Left:
				Invoke(KeyboardNavigationOperation.MoveLeft, evt);
				break;
			case NavigationMoveEvent.Direction.Right:
				Invoke(KeyboardNavigationOperation.MoveRight, evt);
				break;
			}
		}

		private void Invoke(KeyboardNavigationOperation operation, EventBase evt)
		{
			m_Action?.Invoke(operation, evt);
		}
	}
	public struct ManipulatorActivationFilter : IEquatable<ManipulatorActivationFilter>
	{
		public MouseButton button { get; set; }

		public EventModifiers modifiers { get; set; }

		public int clickCount { get; set; }

		public override bool Equals(object obj)
		{
			return obj is ManipulatorActivationFilter && Equals((ManipulatorActivationFilter)obj);
		}

		public bool Equals(ManipulatorActivationFilter other)
		{
			return button == other.button && modifiers == other.modifiers && clickCount == other.clickCount;
		}

		public override int GetHashCode()
		{
			int num = 390957112;
			num = num * -1521134295 + button.GetHashCode();
			num = num * -1521134295 + modifiers.GetHashCode();
			return num * -1521134295 + clickCount.GetHashCode();
		}

		public bool Matches(IMouseEvent e)
		{
			if (e == null)
			{
				return false;
			}
			bool flag = clickCount == 0 || e.clickCount >= clickCount;
			return button == (MouseButton)e.button && HasModifiers(e) && flag;
		}

		private bool HasModifiers(IMouseEvent e)
		{
			if (e == null)
			{
				return false;
			}
			return MatchModifiers(e.altKey, e.ctrlKey, e.shiftKey, e.commandKey);
		}

		public bool Matches(IPointerEvent e)
		{
			if (e == null)
			{
				return false;
			}
			bool flag = clickCount == 0 || e.clickCount >= clickCount;
			return button == (MouseButton)e.button && HasModifiers(e) && flag;
		}

		private bool HasModifiers(IPointerEvent e)
		{
			if (e == null)
			{
				return false;
			}
			return MatchModifiers(e.altKey, e.ctrlKey, e.shiftKey, e.commandKey);
		}

		private bool MatchModifiers(bool alt, bool ctrl, bool shift, bool command)
		{
			if (((modifiers & EventModifiers.Alt) != EventModifiers.None && !alt) || ((modifiers & EventModifiers.Alt) == 0 && alt))
			{
				return false;
			}
			if (((modifiers & EventModifiers.Control) != EventModifiers.None && !ctrl) || ((modifiers & EventModifiers.Control) == 0 && ctrl))
			{
				return false;
			}
			if (((modifiers & EventModifiers.Shift) != EventModifiers.None && !shift) || ((modifiers & EventModifiers.Shift) == 0 && shift))
			{
				return false;
			}
			return ((modifiers & EventModifiers.Command) == 0 || command) && ((modifiers & EventModifiers.Command) != EventModifiers.None || !command);
		}

		public static bool operator ==(ManipulatorActivationFilter filter1, ManipulatorActivationFilter filter2)
		{
			return filter1.Equals(filter2);
		}

		public static bool operator !=(ManipulatorActivationFilter filter1, ManipulatorActivationFilter filter2)
		{
			return !(filter1 == filter2);
		}
	}
	public interface IManipulator
	{
		VisualElement target { get; set; }
	}
	public abstract class Manipulator : IManipulator
	{
		private VisualElement m_Target;

		public VisualElement target
		{
			get
			{
				return m_Target;
			}
			set
			{
				if (target != null)
				{
					UnregisterCallbacksFromTarget();
				}
				m_Target = value;
				if (target != null)
				{
					RegisterCallbacksOnTarget();
				}
			}
		}

		protected abstract void RegisterCallbacksOnTarget();

		protected abstract void UnregisterCallbacksFromTarget();
	}
	public enum MouseButton
	{
		LeftMouse,
		RightMouse,
		MiddleMouse
	}
	public static class MouseCaptureController
	{
		private static bool m_IsMouseCapturedWarningEmitted;

		private static bool m_ReleaseMouseWarningEmitted;

		public static bool IsMouseCaptured()
		{
			if (!m_IsMouseCapturedWarningEmitted)
			{
				Debug.LogError("MouseCaptureController.IsMouseCaptured() can not be used in playmode. Please use PointerCaptureHelper.GetCapturingElement() instead.");
				m_IsMouseCapturedWarningEmitted = true;
			}
			return false;
		}

		public static bool HasMouseCapture(this IEventHandler handler)
		{
			VisualElement handler2 = handler as VisualElement;
			return handler2.HasPointerCapture(PointerId.mousePointerId);
		}

		public static void CaptureMouse(this IEventHandler handler)
		{
			if (handler is VisualElement visualElement)
			{
				visualElement.CapturePointer(PointerId.mousePointerId);
				visualElement.panel.ProcessPointerCapture(PointerId.mousePointerId);
			}
		}

		public static void ReleaseMouse(this IEventHandler handler)
		{
			if (handler is VisualElement visualElement)
			{
				visualElement.ReleasePointer(PointerId.mousePointerId);
				visualElement.panel.ProcessPointerCapture(PointerId.mousePointerId);
			}
		}

		public static void ReleaseMouse()
		{
			if (!m_ReleaseMouseWarningEmitted)
			{
				Debug.LogError("MouseCaptureController.ReleaseMouse() can not be used in playmode. Please use PointerCaptureHelper.GetCapturingElement() instead.");
				m_ReleaseMouseWarningEmitted = true;
			}
		}
	}
	public abstract class MouseManipulator : Manipulator
	{
		private ManipulatorActivationFilter m_currentActivator;

		public List<ManipulatorActivationFilter> activators { get; private set; }

		protected MouseManipulator()
		{
			activators = new List<ManipulatorActivationFilter>();
		}

		protected bool CanStartManipulation(IMouseEvent e)
		{
			foreach (ManipulatorActivationFilter activator in activators)
			{
				if (activator.Matches(e))
				{
					m_currentActivator = activator;
					return true;
				}
			}
			return false;
		}

		protected bool CanStopManipulation(IMouseEvent e)
		{
			if (e == null)
			{
				return false;
			}
			return e.button == (int)m_currentActivator.button;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	[NativeHeader("ModuleOverrides/com.unity.ui/Core/Native/ImmediateStylePainter.h")]
	internal class ImmediateStylePainter
	{
		internal static void DrawRect(Rect screenRect, Color color, Vector4 borderWidths, Vector4 borderRadiuses)
		{
			DrawRect_Injected(ref screenRect, ref color, ref borderWidths, ref borderRadiuses);
		}

		internal static void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, Color color, Vector4 borderWidths, Vector4 borderRadiuses, int leftBorder, int topBorder, int rightBorder, int bottomBorder, bool usePremultiplyAlpha)
		{
			DrawTexture_Injected(ref screenRect, texture, ref sourceRect, ref color, ref borderWidths, ref borderRadiuses, leftBorder, topBorder, rightBorder, bottomBorder, usePremultiplyAlpha);
		}

		internal static void DrawText(Rect screenRect, string text, Font font, int fontSize, FontStyle fontStyle, Color fontColor, TextAnchor anchor, bool wordWrap, float wordWrapWidth, bool richText, TextClipping textClipping)
		{
			DrawText_Injected(ref screenRect, text, font, fontSize, fontStyle, ref fontColor, anchor, wordWrap, wordWrapWidth, richText, textClipping);
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void DrawRect_Injected(ref Rect screenRect, ref Color color, ref Vector4 borderWidths, ref Vector4 borderRadiuses);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void DrawTexture_Injected(ref Rect screenRect, Texture texture, ref Rect sourceRect, ref Color color, ref Vector4 borderWidths, ref Vector4 borderRadiuses, int leftBorder, int topBorder, int rightBorder, int bottomBorder, bool usePremultiplyAlpha);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void DrawText_Injected(ref Rect screenRect, string text, Font font, int fontSize, FontStyle fontStyle, ref Color fontColor, TextAnchor anchor, bool wordWrap, float wordWrapWidth, bool richText, TextClipping textClipping);
	}
	internal struct MeshWriteDataInterface
	{
		public IntPtr vertices;

		public IntPtr indices;

		public int vertexCount;

		public int indexCount;

		public unsafe static MeshWriteDataInterface FromMeshWriteData(MeshWriteData data)
		{
			return new MeshWriteDataInterface
			{
				vertices = new IntPtr(data.m_Vertices.GetUnsafePtr()),
				indices = new IntPtr(data.m_Indices.GetUnsafePtr()),
				vertexCount = data.m_Vertices.Length,
				indexCount = data.m_Indices.Length
			};
		}
	}
	[NativeHeader("ModuleOverrides/com.unity.ui/Core/Native/Renderer/UIPainter2D.bindings.h")]
	internal static class UIPainter2D
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern IntPtr Create(bool computeBBox = false);

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern void Destroy(IntPtr handle);

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern void Reset(IntPtr handle);

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern float GetLineWidth(IntPtr handle);

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern void SetLineWidth(IntPtr handle, float value);

		public static Color GetStrokeColor(IntPtr handle)
		{
			GetStrokeColor_Injected(handle, out var ret);
			return ret;
		}

		public static void SetStrokeColor(IntPtr handle, Color value)
		{
			SetStrokeColor_Injected(handle, ref value);
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[NativeName("GetStrokeGradientCopy")]
		public static extern Gradient GetStrokeGradient(IntPtr handle);

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern void SetStrokeGradient(IntPtr handle, Gradient gradient);

		public static Color GetFillColor(IntPtr handle)
		{
			GetFillColor_Injected(handle, out var ret);
			return ret;
		}

		public static void SetFillColor(IntPtr handle, Color value)
		{
			SetFillColor_Injected(handle, ref value);
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern LineJoin GetLineJoin(IntPtr handle);

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern void SetLineJoin(IntPtr handle, LineJoin value);

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern LineCap GetLineCap(IntPtr handle);

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern void SetLineCap(IntPtr handle, LineCap value);

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern float GetMiterLimit(IntPtr handle);

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern void SetMiterLimit(IntPtr handle, float value);

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern void BeginPath(IntPtr handle);

		public static void MoveTo(IntPtr handle, Vector2 pos)
		{
			MoveTo_Injected(handle, ref pos);
		}

		public static void LineTo(IntPtr handle, Vector2 pos)
		{
			LineTo_Injected(handle, ref pos);
		}

		public static void ArcTo(IntPtr handle, Vector2 p1, Vector2 p2, float radius)
		{
			ArcTo_Injected(handle, ref p1, ref p2, radius);
		}

		public static void Arc(IntPtr handle, Vector2 center, float radius, float startAngleRads, float endAngleRads, ArcDirection direction)
		{
			Arc_Injected(handle, ref center, radius, startAngleRads, endAngleRads, direction);
		}

		public static void BezierCurveTo(IntPtr handle, Vector2 p1, Vector2 p2, Vector2 p3)
		{
			BezierCurveTo_Injected(handle, ref p1, ref p2, ref p3);
		}

		public static void QuadraticCurveTo(IntPtr handle, Vector2 p1, Vector2 p2)
		{
			QuadraticCurveTo_Injected(handle, ref p1, ref p2);
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern void ClosePath(IntPtr handle);

		public static Rect GetBBox(IntPtr handle)
		{
			GetBBox_Injected(handle, out var ret);
			return ret;
		}

		public static MeshWriteDataInterface Stroke(IntPtr handle)
		{
			Stroke_Injected(handle, out var ret);
			return ret;
		}

		public static MeshWriteDataInterface Fill(IntPtr handle, FillRule fillRule)
		{
			Fill_Injected(handle, fillRule, out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void GetStrokeColor_Injected(IntPtr handle, out Color ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void SetStrokeColor_Injected(IntPtr handle, ref Color value);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void GetFillColor_Injected(IntPtr handle, out Color ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void SetFillColor_Injected(IntPtr handle, ref Color value);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void MoveTo_Injected(IntPtr handle, ref Vector2 pos);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void LineTo_Injected(IntPtr handle, ref Vector2 pos);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void ArcTo_Injected(IntPtr handle, ref Vector2 p1, ref Vector2 p2, float radius);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void Arc_Injected(IntPtr handle, ref Vector2 center, float radius, float startAngleRads, float endAngleRads, ArcDirection direction);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void BezierCurveTo_Injected(IntPtr handle, ref Vector2 p1, ref Vector2 p2, ref Vector2 p3);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void QuadraticCurveTo_Injected(IntPtr handle, ref Vector2 p1, ref Vector2 p2);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void GetBBox_Injected(IntPtr handle, out Rect ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void Stroke_Injected(IntPtr handle, out MeshWriteDataInterface ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void Fill_Injected(IntPtr handle, FillRule fillRule, out MeshWriteDataInterface ret);
	}
	public enum FillRule
	{
		NonZero,
		OddEven
	}
	public enum LineJoin
	{
		Miter,
		Bevel,
		Round
	}
	public enum LineCap
	{
		Butt,
		Round
	}
	public enum ArcDirection
	{
		Clockwise,
		CounterClockwise
	}
	[NativeHeader("ModuleOverrides/com.unity.ui/Core/Native/Renderer/UIRMeshBuilder.bindings.h")]
	internal static class MeshBuilderNative
	{
		public struct NativeColorPage
		{
			public int isValid;

			public Color32 pageAndID;
		}

		public struct NativeBorderParams
		{
			public Rect rect;

			public Color leftColor;

			public Color topColor;

			public Color rightColor;

			public Color bottomColor;

			public float leftWidth;

			public float topWidth;

			public float rightWidth;

			public float bottomWidth;

			public Vector2 topLeftRadius;

			public Vector2 topRightRadius;

			public Vector2 bottomRightRadius;

			public Vector2 bottomLeftRadius;

			internal NativeColorPage leftColorPage;

			internal NativeColorPage topColorPage;

			internal NativeColorPage rightColorPage;

			internal NativeColorPage bottomColorPage;
		}

		public struct NativeRectParams
		{
			public Rect rect;

			public Rect subRect;

			public Rect uv;

			public Rect uvRegion;

			public Color color;

			public ScaleMode scaleMode;

			public Vector2 topLeftRadius;

			public Vector2 topRightRadius;

			public Vector2 bottomRightRadius;

			public Vector2 bottomLeftRadius;

			public Vector2 contentSize;

			public Vector2 textureSize;

			public float texturePixelsPerPoint;

			public int leftSlice;

			public int topSlice;

			public int rightSlice;

			public int bottomSlice;

			public float sliceScale;

			public Vector4 rectInset;

			public NativeColorPage colorPage;
		}

		public const float kEpsilon = 0.001f;

		public static MeshWriteDataInterface MakeBorder(NativeBorderParams borderParams, float posZ)
		{
			MakeBorder_Injected(ref borderParams, posZ, out var ret);
			return ret;
		}

		public static MeshWriteDataInterface MakeSolidRect(NativeRectParams rectParams, float posZ)
		{
			MakeSolidRect_Injected(ref rectParams, posZ, out var ret);
			return ret;
		}

		public static MeshWriteDataInterface MakeTexturedRect(NativeRectParams rectParams, float posZ)
		{
			MakeTexturedRect_Injected(ref rectParams, posZ, out var ret);
			return ret;
		}

		public static MeshWriteDataInterface MakeVectorGraphicsStretchBackground(Vertex[] svgVertices, ushort[] svgIndices, float svgWidth, float svgHeight, Rect targetRect, Rect sourceUV, ScaleMode scaleMode, Color tint, NativeColorPage colorPage, int settingIndexOffset, ref int finalVertexCount, ref int finalIndexCount)
		{
			MakeVectorGraphicsStretchBackground_Injected(svgVertices, svgIndices, svgWidth, svgHeight, ref targetRect, ref sourceUV, scaleMode, ref tint, ref colorPage, settingIndexOffset, ref finalVertexCount, ref finalIndexCount, out var ret);
			return ret;
		}

		public static MeshWriteDataInterface MakeVectorGraphics9SliceBackground(Vertex[] svgVertices, ushort[] svgIndices, float svgWidth, float svgHeight, Rect targetRect, Vector4 sliceLTRB, Color tint, NativeColorPage colorPage, int settingIndexOffset)
		{
			MakeVectorGraphics9SliceBackground_Injected(svgVertices, svgIndices, svgWidth, svgHeight, ref targetRect, ref sliceLTRB, ref tint, ref colorPage, settingIndexOffset, out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void MakeBorder_Injected(ref NativeBorderParams borderParams, float posZ, out MeshWriteDataInterface ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void MakeSolidRect_Injected(ref NativeRectParams rectParams, float posZ, out MeshWriteDataInterface ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void MakeTexturedRect_Injected(ref NativeRectParams rectParams, float posZ, out MeshWriteDataInterface ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void MakeVectorGraphicsStretchBackground_Injected(Vertex[] svgVertices, ushort[] svgIndices, float svgWidth, float svgHeight, ref Rect targetRect, ref Rect sourceUV, ScaleMode scaleMode, ref Color tint, ref NativeColorPage colorPage, int settingIndexOffset, ref int finalVertexCount, ref int finalIndexCount, out MeshWriteDataInterface ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void MakeVectorGraphics9SliceBackground_Injected(Vertex[] svgVertices, ushort[] svgIndices, float svgWidth, float svgHeight, ref Rect targetRect, ref Vector4 sliceLTRB, ref Color tint, ref NativeColorPage colorPage, int settingIndexOffset, out MeshWriteDataInterface ret);
	}
	internal struct TextNativeSettings
	{
		public string text;

		public Font font;

		public int size;

		public float scaling;

		public FontStyle style;

		public Color color;

		public TextAnchor anchor;

		public bool wordWrap;

		public float wordWrapWidth;

		public bool richText;
	}
	internal struct TextVertex
	{
		public Vector3 position;

		public Color32 color;

		public Vector2 uv0;
	}
	[NativeHeader("ModuleOverrides/com.unity.ui/Core/Native/TextNative.bindings.h")]
	internal static class TextNative
	{
		public static Vector2 GetCursorPosition(TextNativeSettings settings, Rect rect, int cursorIndex)
		{
			if (settings.font == null)
			{
				Debug.LogError("Cannot process a null font.");
				return Vector2.zero;
			}
			return DoGetCursorPosition(settings, rect, cursorIndex);
		}

		public static float ComputeTextWidth(TextNativeSettings settings)
		{
			if (settings.font == null)
			{
				Debug.LogError("Cannot process a null font.");
				return 0f;
			}
			if (string.IsNullOrEmpty(settings.text))
			{
				return 0f;
			}
			return DoComputeTextWidth(settings);
		}

		public static float ComputeTextHeight(TextNativeSettings settings)
		{
			if (settings.font == null)
			{
				Debug.LogError("Cannot process a null font.");
				return 0f;
			}
			if (string.IsNullOrEmpty(settings.text))
			{
				return 0f;
			}
			return DoComputeTextHeight(settings);
		}

		public unsafe static NativeArray<TextVertex> GetVertices(TextNativeSettings settings)
		{
			int vertexCount = 0;
			GetVertices(settings, IntPtr.Zero, UnsafeUtility.SizeOf<TextVertex>(), ref vertexCount);
			NativeArray<TextVertex> nativeArray = new NativeArray<TextVertex>(vertexCount, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
			if (vertexCount > 0)
			{
				GetVertices(settings, (IntPtr)nativeArray.GetUnsafePtr(), UnsafeUtility.SizeOf<TextVertex>(), ref vertexCount);
				Debug.Assert(vertexCount == nativeArray.Length);
			}
			return nativeArray;
		}

		public static Vector2 GetOffset(TextNativeSettings settings, Rect screenRect)
		{
			if (settings.font == null)
			{
				Debug.LogError("Cannot process a null font.");
				return new Vector2(0f, 0f);
			}
			settings.text = settings.text ?? "";
			return DoGetOffset(settings, screenRect);
		}

		public static float ComputeTextScaling(Matrix4x4 worldMatrix, float pixelsPerPoint)
		{
			Vector3 vector = new Vector3(worldMatrix.m00, worldMatrix.m10, worldMatrix.m20);
			Vector3 vector2 = new Vector3(worldMatrix.m01, worldMatrix.m11, worldMatrix.m21);
			float num = (vector.magnitude + vector2.magnitude) / 2f;
			return num * pixelsPerPoint;
		}

		[FreeFunction(Name = "TextNative::ComputeTextWidth")]
		private static float DoComputeTextWidth(TextNativeSettings settings)
		{
			return DoComputeTextWidth_Injected(ref settings);
		}

		[FreeFunction(Name = "TextNative::ComputeTextHeight")]
		private static float DoComputeTextHeight(TextNativeSettings settings)
		{
			return DoComputeTextHeight_Injected(ref settings);
		}

		[FreeFunction(Name = "TextNative::GetCursorPosition")]
		private static Vector2 DoGetCursorPosition(TextNativeSettings settings, Rect rect, int cursorPosition)
		{
			DoGetCursorPosition_Injected(ref settings, ref rect, cursorPosition, out var ret);
			return ret;
		}

		[FreeFunction(Name = "TextNative::GetVertices")]
		private static void GetVertices(TextNativeSettings settings, IntPtr buffer, int vertexSize, ref int vertexCount)
		{
			GetVertices_Injected(ref settings, buffer, vertexSize, ref vertexCount);
		}

		[FreeFunction(Name = "TextNative::GetOffset")]
		private static Vector2 DoGetOffset(TextNativeSettings settings, Rect rect)
		{
			DoGetOffset_Injected(ref settings, ref rect, out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern float DoComputeTextWidth_Injected(ref TextNativeSettings settings);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern float DoComputeTextHeight_Injected(ref TextNativeSettings settings);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void DoGetCursorPosition_Injected(ref TextNativeSettings settings, ref Rect rect, int cursorPosition, out Vector2 ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void GetVertices_Injected(ref TextNativeSettings settings, IntPtr buffer, int vertexSize, ref int vertexCount);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void DoGetOffset_Injected(ref TextNativeSettings settings, ref Rect rect, out Vector2 ret);
	}
	[VisibleToOtherModules(new string[] { "Unity.UIElements" })]
	[NativeHeader("ModuleOverrides/com.unity.ui/Core/Native/UIElementsRuntimeUtilityNative.h")]
	internal static class UIElementsRuntimeUtilityNative
	{
		internal static Action RepaintOverlayPanelsCallback;

		internal static Action UpdateRuntimePanelsCallback;

		internal static Action RepaintOffscreenPanelsCallback;

		[RequiredByNativeCode]
		public static void RepaintOverlayPanels()
		{
			RepaintOverlayPanelsCallback?.Invoke();
		}

		[RequiredByNativeCode]
		public static void UpdateRuntimePanels()
		{
			UpdateRuntimePanelsCallback?.Invoke();
		}

		[RequiredByNativeCode]
		public static void RepaintOffscreenPanels()
		{
			RepaintOffscreenPanelsCallback?.Invoke();
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern void RegisterPlayerloopCallback();

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern void UnregisterPlayerloopCallback();

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern void VisualElementCreation();
	}
	internal class ObjectPool<T> where T : new()
	{
		private readonly Stack<T> m_Stack = new Stack<T>();

		private int m_MaxSize;

		internal Func<T> CreateFunc;

		public int maxSize
		{
			get
			{
				return m_MaxSize;
			}
			set
			{
				m_MaxSize = Math.Max(0, value);
				while (Size() > m_MaxSize)
				{
					Get();
				}
			}
		}

		public ObjectPool(Func<T> CreateFunc, int maxSize = 100)
		{
			this.maxSize = maxSize;
			if (CreateFunc == null)
			{
				this.CreateFunc = () => new T();
			}
			else
			{
				this.CreateFunc = CreateFunc;
			}
		}

		public int Size()
		{
			return m_Stack.Count;
		}

		public void Clear()
		{
			m_Stack.Clear();
		}

		public T Get()
		{
			return (m_Stack.Count == 0) ? CreateFunc() : m_Stack.Pop();
		}

		public void Release(T element)
		{
			if (m_Stack.Count > 0 && (object)m_Stack.Peek() == (object)element)
			{
				Debug.LogError("Internal error. Trying to destroy object that is already released to pool.");
			}
			if (m_Stack.Count < maxSize)
			{
				m_Stack.Push(element);
			}
		}
	}
	public enum ContextType
	{
		Player,
		Editor
	}
	[Flags]
	internal enum VersionChangeType
	{
		Bindings = 1,
		ViewData = 2,
		Hierarchy = 4,
		Layout = 8,
		StyleSheet = 0x10,
		Styles = 0x20,
		Overflow = 0x40,
		BorderRadius = 0x80,
		BorderWidth = 0x100,
		Transform = 0x200,
		Size = 0x400,
		Repaint = 0x800,
		Opacity = 0x1000,
		Color = 0x2000,
		RenderHints = 0x4000,
		TransitionProperty = 0x8000,
		EventCallbackCategories = 0x10000,
		Picking = 0x100000
	}
	[Flags]
	public enum UsageHints
	{
		None = 0,
		DynamicTransform = 1,
		GroupTransform = 2,
		MaskContainer = 4,
		DynamicColor = 8
	}
	[Flags]
	internal enum RenderHints
	{
		None = 0,
		GroupTransform = 1,
		BoneTransform = 2,
		ClipWithScissors = 4,
		MaskContainer = 8,
		DynamicColor = 0x10,
		DirtyOffset = 5,
		DirtyGroupTransform = 0x20,
		DirtyBoneTransform = 0x40,
		DirtyClipWithScissors = 0x80,
		DirtyMaskContainer = 0x100,
		DirtyDynamicColor = 0x200,
		DirtyAll = 0x3E0
	}
	internal enum PanelClearFlags
	{
		None,
		Color,
		Depth,
		All
	}
	internal struct PanelClearSettings
	{
		public bool clearDepthStencil;

		public bool clearColor;

		public Color color;
	}
	internal class RepaintData
	{
		public Matrix4x4 currentOffset { get; set; } = Matrix4x4.identity;

		public Vector2 mousePosition { get; set; }

		public Rect currentWorldClip { get; set; }

		public Event repaintEvent { get; set; }
	}
	internal delegate void HierarchyEvent(VisualElement ve, HierarchyChangeType changeType);
	public interface IPanel : IDisposable
	{
		VisualElement visualTree { get; }

		EventDispatcher dispatcher { get; }

		ContextType contextType { get; }

		FocusController focusController { get; }

		ContextualMenuManager contextualMenuManager { get; }

		bool isDirty { get; }

		VisualElement Pick(Vector2 point);

		VisualElement PickAll(Vector2 point, List<VisualElement> picked);
	}
	internal abstract class BaseVisualElementPanel : IPanel, IDisposable, IGroupBox
	{
		private UIElementsBridge m_UIElementsBridge;

		private float m_Scale = 1f;

		internal YogaConfig yogaConfig;

		private float m_PixelsPerPoint = 1f;

		internal ElementUnderPointer m_TopElementUnderPointers = new ElementUnderPointer();

		public abstract EventInterests IMGUIEventInterests { get; set; }

		public abstract ScriptableObject ownerObject { get; protected set; }

		public abstract SavePersistentViewData saveViewData { get; set; }

		public abstract GetViewDataDictionary getViewDataDictionary { get; set; }

		public abstract int IMGUIContainersCount { get; set; }

		public abstract FocusController focusController { get; set; }

		public abstract IMGUIContainer rootIMGUIContainer { get; set; }

		internal UIElementsBridge uiElementsBridge
		{
			get
			{
				if (m_UIElementsBridge != null)
				{
					return m_UIElementsBridge;
				}
				throw new Exception("Panel has no UIElementsBridge.");
			}
			set
			{
				m_UIElementsBridge = value;
			}
		}

		internal float scale
		{
			get
			{
				return m_Scale;
			}
			set
			{
				if (!Mathf.Approximately(m_Scale, value))
				{
					m_Scale = value;
					visualTree.IncrementVersion(VersionChangeType.Layout);
					yogaConfig.PointScaleFactor = scaledPixelsPerPoint;
					visualTree.IncrementVersion(VersionChangeType.StyleSheet);
				}
			}
		}

		internal float pixelsPerPoint
		{
			get
			{
				return m_PixelsPerPoint;
			}
			set
			{
				if (!Mathf.Approximately(m_PixelsPerPoint, value))
				{
					m_PixelsPerPoint = value;
					visualTree.IncrementVersion(VersionChangeType.Layout);
					yogaConfig.PointScaleFactor = scaledPixelsPerPoint;
					visualTree.IncrementVersion(VersionChangeType.StyleSheet);
				}
			}
		}

		public float scaledPixelsPerPoint => m_PixelsPerPoint * m_Scale;

		public float referenceSpritePixelsPerUnit { get; set; } = 100f;

		public PanelClearFlags clearFlags
		{
			get
			{
				PanelClearFlags panelClearFlags = PanelClearFlags.None;
				if (clearSettings.clearColor)
				{
					panelClearFlags |= PanelClearFlags.Color;
				}
				if (clearSettings.clearDepthStencil)
				{
					panelClearFlags |= PanelClearFlags.Depth;
				}
				return panelClearFlags;
			}
			set
			{
				PanelClearSettings panelClearSettings = clearSettings;
				panelClearSettings.clearColor = (value & PanelClearFlags.Color) == PanelClearFlags.Color;
				panelClearSettings.clearDepthStencil = (value & PanelClearFlags.Depth) == PanelClearFlags.Depth;
				clearSettings = panelClearSettings;
			}
		}

		internal PanelClearSettings clearSettings { get; set; } = new PanelClearSettings
		{
			clearDepthStencil = true,
			clearColor = true,
			color = Color.clear
		};

		internal bool duringLayoutPhase { get; set; }

		public bool isDirty => version != repaintVersion;

		internal abstract uint version { get; }

		internal abstract uint repaintVersion { get; }

		internal abstract uint hierarchyVersion { get; }

		internal virtual RepaintData repaintData { get; set; }

		internal virtual ICursorManager cursorManager { get; set; }

		public ContextualMenuManager contextualMenuManager { get; internal set; }

		public abstract VisualElement visualTree { get; }

		public abstract EventDispatcher dispatcher { get; set; }

		internal abstract IScheduler scheduler { get; }

		internal abstract IStylePropertyAnimationSystem styleAnimationSystem { get; set; }

		public abstract ContextType contextType { get; protected set; }

		internal bool disposed { get; private set; }

		internal abstract Shader standardShader { get; set; }

		internal virtual Shader standardWorldSpaceShader
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public abstract AtlasBase atlas { get; set; }

		internal event Action<BaseVisualElementPanel> panelDisposed;

		internal event Action standardShaderChanged;

		internal event Action standardWorldSpaceShaderChanged;

		internal event Action atlasChanged;

		internal event Action<Material> updateMaterial;

		internal event HierarchyEvent hierarchyChanged;

		internal event Action<IPanel> beforeUpdate;

		protected BaseVisualElementPanel()
		{
			yogaConfig = new YogaConfig();
			yogaConfig.UseWebDefaults = YogaConfig.Default.UseWebDefaults;
			m_UIElementsBridge = new RuntimeUIElementsBridge();
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (disposed)
			{
				return;
			}
			if (disposing)
			{
				if (ownerObject != null)
				{
					UIElementsUtility.RemoveCachedPanel(ownerObject.GetInstanceID());
				}
				PointerDeviceState.RemovePanelData(this);
			}
			this.panelDisposed?.Invoke(this);
			yogaConfig = null;
			disposed = true;
		}

		public abstract void Repaint(Event e);

		public abstract void ValidateFocus();

		public abstract void ValidateLayout();

		public abstract void UpdateAnimations();

		public abstract void UpdateBindings();

		public abstract void ApplyStyles();

		internal abstract void OnVersionChanged(VisualElement ele, VersionChangeType changeTypeFlag);

		internal abstract void SetUpdater(IVisualTreeUpdater updater, VisualTreeUpdatePhase phase);

		internal void SendEvent(EventBase e, DispatchMode dispatchMode = DispatchMode.Default)
		{
			Debug.Assert(dispatcher != null);
			dispatcher?.Dispatch(e, this, dispatchMode);
		}

		public abstract VisualElement Pick(Vector2 point);

		public abstract VisualElement PickAll(Vector2 point, List<VisualElement> picked);

		internal abstract IVisualTreeUpdater GetUpdater(VisualTreeUpdatePhase phase);

		internal VisualElement GetTopElementUnderPointer(int pointerId)
		{
			return m_TopElementUnderPointers.GetTopElementUnderPointer(pointerId);
		}

		internal VisualElement RecomputeTopElementUnderPointer(int pointerId, Vector2 pointerPos, EventBase triggerEvent)
		{
			VisualElement visualElement = null;
			if (PointerDeviceState.GetPanel(pointerId, contextType) == this && !PointerDeviceState.HasLocationFlag(pointerId, contextType, PointerDeviceState.LocationFlag.OutsidePanel))
			{
				visualElement = Pick(pointerPos);
			}
			m_TopElementUnderPointers.SetElementUnderPointer(visualElement, pointerId, triggerEvent);
			return visualElement;
		}

		internal void ClearCachedElementUnderPointer(int pointerId, EventBase triggerEvent)
		{
			m_TopElementUnderPointers.SetTemporaryElementUnderPointer(null, pointerId, triggerEvent);
		}

		internal void CommitElementUnderPointers()
		{
			m_TopElementUnderPointers.CommitElementUnderPointers(dispatcher, contextType);
		}

		protected void InvokeStandardShaderChanged()
		{
			if (this.standardShaderChanged != null)
			{
				this.standardShaderChanged();
			}
		}

		protected void InvokeStandardWorldSpaceShaderChanged()
		{
			if (this.standardWorldSpaceShaderChanged != null)
			{
				this.standardWorldSpaceShaderChanged();
			}
		}

		protected void InvokeAtlasChanged()
		{
			this.atlasChanged?.Invoke();
		}

		internal void InvokeUpdateMaterial(Material mat)
		{
			this.updateMaterial?.Invoke(mat);
		}

		internal void InvokeHierarchyChanged(VisualElement ve, HierarchyChangeType changeType)
		{
			if (this.hierarchyChanged != null)
			{
				this.hierarchyChanged(ve, changeType);
			}
		}

		internal void InvokeBeforeUpdate()
		{
			this.beforeUpdate?.Invoke(this);
		}

		internal void UpdateElementUnderPointers()
		{
			int[] hoveringPointers = PointerId.hoveringPointers;
			foreach (int pointerId in hoveringPointers)
			{
				if (PointerDeviceState.GetPanel(pointerId, contextType) != this || PointerDeviceState.HasLocationFlag(pointerId, contextType, PointerDeviceState.LocationFlag.OutsidePanel))
				{
					m_TopElementUnderPointers.SetElementUnderPointer(null, pointerId, new Vector2(float.MinValue, float.MinValue));
					continue;
				}
				Vector2 pointerPosition = PointerDeviceState.GetPointerPosition(pointerId, contextType);
				VisualElement newElementUnderPointer = PickAll(pointerPosition, null);
				m_TopElementUnderPointers.SetElementUnderPointer(newElementUnderPointer, pointerId, pointerPosition);
			}
			CommitElementUnderPointers();
		}

		void IGroupBox.OnOptionAdded(IGroupBoxOption option)
		{
		}

		void IGroupBox.OnOptionRemoved(IGroupBoxOption option)
		{
		}

		public virtual void Update()
		{
			scheduler.UpdateScheduledEvents();
			ValidateFocus();
			ValidateLayout();
			UpdateAnimations();
			UpdateBindings();
		}
	}
	internal delegate Object LoadResourceFunction(string pathName, Type type, float dpiScaling);
	internal delegate long TimeMsFunction();
	internal delegate ISerializableJsonDictionary GetViewDataDictionary();
	internal delegate void SavePersistentViewData();
	internal class Panel : BaseVisualElementPanel
	{
		private VisualElement m_RootContainer;

		private VisualTreeUpdater m_VisualTreeUpdater;

		private IStylePropertyAnimationSystem m_StylePropertyAnimationSystem;

		private string m_PanelName;

		private uint m_Version = 0u;

		private uint m_RepaintVersion = 0u;

		private uint m_HierarchyVersion = 0u;

		private ProfilerMarker m_MarkerBeforeUpdate;

		private ProfilerMarker m_MarkerUpdate;

		private ProfilerMarker m_MarkerLayout;

		private ProfilerMarker m_MarkerBindings;

		private ProfilerMarker m_MarkerAnimations;

		private static ProfilerMarker s_MarkerPickAll = new ProfilerMarker("Panel.PickAll");

		private TimerEventScheduler m_Scheduler;

		private bool m_JustReceivedFocus;

		private Shader m_StandardShader;

		private AtlasBase m_Atlas;

		private bool m_ValidatingLayout = false;

		public sealed override VisualElement visualTree => m_RootContainer;

		public sealed override EventDispatcher dispatcher { get; set; }

		public TimerEventScheduler timerEventScheduler => m_Scheduler ?? (m_Scheduler = new TimerEventScheduler());

		internal override IScheduler scheduler => timerEventScheduler;

		internal VisualTreeUpdater visualTreeUpdater => m_VisualTreeUpdater;

		internal override IStylePropertyAnimationSystem styleAnimationSystem
		{
			get
			{
				return m_StylePropertyAnimationSystem;
			}
			set
			{
				if (m_StylePropertyAnimationSystem != value)
				{
					m_StylePropertyAnimationSystem?.CancelAllAnimations();
					m_StylePropertyAnimationSystem = value;
				}
			}
		}

		public override ScriptableObject ownerObject { get; protected set; }

		public override ContextType contextType { get; protected set; }

		public override SavePersistentViewData saveViewData { get; set; }

		public override GetViewDataDictionary getViewDataDictionary { get; set; }

		public sealed override FocusController focusController { get; set; }

		public override EventInterests IMGUIEventInterests { get; set; }

		internal static LoadResourceFunction loadResourceFunc { private get; set; }

		internal string name
		{
			get
			{
				return m_PanelName;
			}
			set
			{
				m_PanelName = value;
				CreateMarkers();
			}
		}

		internal static TimeMsFunction TimeSinceStartup { private get; set; }

		public override int IMGUIContainersCount { get; set; }

		public override IMGUIContainer rootIMGUIContainer { get; set; }

		internal override uint version => m_Version;

		internal override uint repaintVersion => m_RepaintVersion;

		internal override uint hierarchyVersion => m_HierarchyVersion;

		internal override Shader standardShader
		{
			get
			{
				return m_StandardShader;
			}
			set
			{
				if (m_StandardShader != value)
				{
					m_StandardShader = value;
					InvokeStandardShaderChanged();
				}
			}
		}

		public override AtlasBase atlas
		{
			get
			{
				return m_Atlas;
			}
			set
			{
				if (m_Atlas != value)
				{
					m_Atlas?.InvokeRemovedFromPanel(this);
					m_Atlas = value;
					InvokeAtlasChanged();
					m_Atlas?.InvokeAssignedToPanel(this);
				}
			}
		}

		internal static event Action<Panel> beforeAnyRepaint;

		internal static Object LoadResource(string pathName, Type type, float dpiScaling)
		{
			Object obj = null;
			if (loadResourceFunc != null)
			{
				return loadResourceFunc(pathName, type, dpiScaling);
			}
			return Resources.Load(pathName, type);
		}

		internal void Focus()
		{
			m_JustReceivedFocus = true;
		}

		internal void Blur()
		{
			focusController?.BlurLastFocusedElement();
		}

		public override void ValidateFocus()
		{
			if (m_JustReceivedFocus)
			{
				m_JustReceivedFocus = false;
				focusController?.SetFocusToLastFocusedElement();
			}
		}

		private void CreateMarkers()
		{
			if (!string.IsNullOrEmpty(m_PanelName))
			{
				m_MarkerBeforeUpdate = new ProfilerMarker("Panel.BeforeUpdate." + m_PanelName);
				m_MarkerUpdate = new ProfilerMarker("Panel.Update." + m_PanelName);
				m_MarkerLayout = new ProfilerMarker("Panel.Layout." + m_PanelName);
				m_MarkerBindings = new ProfilerMarker("Panel.Bindings." + m_PanelName);
				m_MarkerAnimations = new ProfilerMarker("Panel.Animations." + m_PanelName);
			}
			else
			{
				m_MarkerBeforeUpdate = new ProfilerMarker("Panel.BeforeUpdate");
				m_MarkerUpdate = new ProfilerMarker("Panel.Update");
				m_MarkerLayout = new ProfilerMarker("Panel.Layout");
				m_MarkerBindings = new ProfilerMarker("Panel.Bindings");
				m_MarkerAnimations = new ProfilerMarker("Panel.Animations");
			}
		}

		internal static Panel CreateEditorPanel(ScriptableObject ownerObject)
		{
			return new Panel(ownerObject, ContextType.Editor, EventDispatcher.CreateDefault());
		}

		public Panel(ScriptableObject ownerObject, ContextType contextType, EventDispatcher dispatcher)
		{
			this.ownerObject = ownerObject;
			this.contextType = contextType;
			this.dispatcher = dispatcher;
			repaintData = new RepaintData();
			cursorManager = new CursorManager();
			base.contextualMenuManager = null;
			m_VisualTreeUpdater = new VisualTreeUpdater(this);
			m_RootContainer = new VisualElement
			{
				name = VisualElementUtils.GetUniqueName("unity-panel-container"),
				viewDataKey = "PanelContainer",
				pickingMode = ((contextType != ContextType.Editor) ? PickingMode.Ignore : PickingMode.Position),
				eventCallbackCategories = int.MinValue
			};
			visualTree.SetPanel(this);
			focusController = new FocusController(new VisualElementFocusRing(visualTree));
			styleAnimationSystem = new StylePropertyAnimationSystem();
			CreateMarkers();
			InvokeHierarchyChanged(visualTree, HierarchyChangeType.Add);
			atlas = new DynamicAtlas();
		}

		protected override void Dispose(bool disposing)
		{
			if (!base.disposed)
			{
				if (disposing)
				{
					atlas = null;
					m_VisualTreeUpdater.Dispose();
				}
				base.Dispose(disposing);
			}
		}

		public static long TimeSinceStartupMs()
		{
			return TimeSinceStartup?.Invoke() ?? DefaultTimeSinceStartupMs();
		}

		internal static long DefaultTimeSinceStartupMs()
		{
			return (long)(Time.realtimeSinceStartup * 1000f);
		}

		internal static VisualElement PickAllWithoutValidatingLayout(VisualElement root, Vector2 point)
		{
			return PickAll(root, point);
		}

		private static VisualElement PickAll(VisualElement root, Vector2 point, List<VisualElement> picked = null, bool includeIgnoredElement = false)
		{
			return PerformPick(root, point, picked, includeIgnoredElement);
		}

		private static VisualElement PerformPick(VisualElement root, Vector2 point, List<VisualElement> picked = null, bool includeIgnoredElement = false)
		{
			if (root.resolvedStyle.display == DisplayStyle.None)
			{
				return null;
			}
			if (root.pickingMode == PickingMode.Ignore && root.hierarchy.childCount == 0 && !includeIgnoredElement)
			{
				return null;
			}
			if (!root.worldBoundingBox.Contains(point))
			{
				return null;
			}
			Vector2 localPoint = root.WorldToLocal(point);
			bool flag = root.ContainsPoint(localPoint);
			if (!flag && root.ShouldClip())
			{
				return null;
			}
			VisualElement visualElement = null;
			int childCount = root.hierarchy.childCount;
			for (int num = childCount - 1; num >= 0; num--)
			{
				VisualElement root2 = root.hierarchy[num];
				VisualElement visualElement2 = PerformPick(root2, point, picked, includeIgnoredElement);
				if (visualElement == null && visualElement2 != null)
				{
					if (picked == null)
					{
						return visualElement2;
					}
					visualElement = visualElement2;
				}
			}
			if (root.visible && (root.pickingMode == PickingMode.Position || includeIgnoredElement) && flag)
			{
				picked?.Add(root);
				if (visualElement == null)
				{
					visualElement = root;
				}
			}
			return visualElement;
		}

		public override VisualElement PickAll(Vector2 point, List<VisualElement> picked)
		{
			ValidateLayout();
			picked?.Clear();
			return PickAll(visualTree, point, picked);
		}

		public override VisualElement Pick(Vector2 point)
		{
			ValidateLayout();
			Vector2 pickPosition;
			bool isTemporary;
			VisualElement topElementUnderPointer = m_TopElementUnderPointers.GetTopElementUnderPointer(PointerId.mousePointerId, out pickPosition, out isTemporary);
			if (!isTemporary && PixelOf(pickPosition) == PixelOf(point))
			{
				return topElementUnderPointer;
			}
			return PickAll(visualTree, point);
			static Vector2Int PixelOf(Vector2 p)
			{
				return Vector2Int.FloorToInt(p);
			}
		}

		public override void ValidateLayout()
		{
			if (!m_ValidatingLayout)
			{
				m_ValidatingLayout = true;
				m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.Styles);
				m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.Layout);
				m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.TransformClip);
				m_ValidatingLayout = false;
			}
		}

		public override void UpdateAnimations()
		{
			m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.Animation);
		}

		public override void UpdateBindings()
		{
			m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.Bindings);
		}

		public override void ApplyStyles()
		{
			m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.Styles);
		}

		private void UpdateForRepaint()
		{
			m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.ViewData);
			m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.Styles);
			m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.Layout);
			m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.TransformClip);
			m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.Repaint);
		}

		internal void UpdateWithoutRepaint()
		{
			m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.ViewData);
			m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.Bindings);
			m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.Animation);
			m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.Styles);
			m_VisualTreeUpdater.UpdateVisualTreePhase(VisualTreeUpdatePhase.Layout);
		}

		public override void Repaint(Event e)
		{
			m_RepaintVersion = version;
			if (contextType == ContextType.Editor)
			{
				base.pixelsPerPoint = GUIUtility.pixelsPerPoint;
			}
			repaintData.repaintEvent = e;
			using (m_MarkerBeforeUpdate.Auto())
			{
				InvokeBeforeUpdate();
			}
			Panel.beforeAnyRepaint?.Invoke(this);
			using (m_MarkerUpdate.Auto())
			{
				UpdateForRepaint();
			}
		}

		internal override void OnVersionChanged(VisualElement ve, VersionChangeType versionChangeType)
		{
			m_Version++;
			m_VisualTreeUpdater.OnVersionChanged(ve, versionChangeType);
			if ((versionChangeType & VersionChangeType.Hierarchy) == VersionChangeType.Hierarchy)
			{
				m_HierarchyVersion++;
			}
		}

		internal override void SetUpdater(IVisualTreeUpdater updater, VisualTreeUpdatePhase phase)
		{
			m_VisualTreeUpdater.SetUpdater(updater, phase);
		}

		internal override IVisualTreeUpdater GetUpdater(VisualTreeUpdatePhase phase)
		{
			return m_VisualTreeUpdater.GetUpdater(phase);
		}
	}
	internal abstract class BaseRuntimePanel : Panel
	{
		private GameObject m_SelectableGameObject;

		private static int s_CurrentRuntimePanelCounter = 0;

		internal readonly int m_RuntimePanelCreationIndex;

		private float m_SortingPriority = 0f;

		internal int resolvedSortingIndex = 0;

		private Shader m_StandardWorldSpaceShader;

		private bool m_DrawToCameras;

		internal RenderTexture targetTexture = null;

		internal Matrix4x4 panelToWorld = Matrix4x4.identity;

		internal static readonly Func<Vector2, Vector2> DefaultScreenToPanelSpace = (Vector2 p) => p;

		private Func<Vector2, Vector2> m_ScreenToPanelSpace = DefaultScreenToPanelSpace;

		public GameObject selectableGameObject
		{
			get
			{
				return m_SelectableGameObject;
			}
			set
			{
				if (m_SelectableGameObject != value)
				{
					AssignPanelToComponents(null);
					m_SelectableGameObject = value;
					AssignPanelToComponents(this);
				}
			}
		}

		public float sortingPriority
		{
			get
			{
				return m_SortingPriority;
			}
			set
			{
				if (!Mathf.Approximately(m_SortingPriority, value))
				{
					m_SortingPriority = value;
					if (contextType == ContextType.Player)
					{
						UIElementsRuntimeUtility.SetPanelOrderingDirty();
					}
				}
			}
		}

		internal override Shader standardWorldSpaceShader
		{
			get
			{
				return m_StandardWorldSpaceShader;
			}
			set
			{
				if (m_StandardWorldSpaceShader != value)
				{
					m_StandardWorldSpaceShader = value;
					InvokeStandardWorldSpaceShaderChanged();
				}
			}
		}

		internal bool drawToCameras
		{
			get
			{
				return m_DrawToCameras;
			}
			set
			{
				if (m_DrawToCameras != value)
				{
					m_DrawToCameras = value;
					(GetUpdater(VisualTreeUpdatePhase.Repaint) as UIRRepaintUpdater)?.DestroyRenderChain();
				}
			}
		}

		internal int targetDisplay { get; set; }

		internal int screenRenderingWidth => getScreenRenderingWidth(targetDisplay);

		internal int screenRenderingHeight => getScreenRenderingHeight(targetDisplay);

		public Func<Vector2, Vector2> screenToPanelSpace
		{
			get
			{
				return m_ScreenToPanelSpace;
			}
			set
			{
				m_ScreenToPanelSpace = value ?? DefaultScreenToPanelSpace;
			}
		}

		public event Action destroyed;

		protected BaseRuntimePanel(ScriptableObject ownerObject, EventDispatcher dispatcher = null)
			: base(ownerObject, ContextType.Player, dispatcher)
		{
			m_RuntimePanelCreationIndex = s_CurrentRuntimePanelCounter++;
		}

		protected override void Dispose(bool disposing)
		{
			if (!base.disposed)
			{
				if (disposing)
				{
					this.destroyed?.Invoke();
				}
				base.Dispose(disposing);
			}
		}

		internal static int getScreenRenderingHeight(int display)
		{
			return (display >= 0 && display < Display.displays.Length) ? Display.displays[display].renderingHeight : Screen.height;
		}

		internal static int getScreenRenderingWidth(int display)
		{
			return (display >= 0 && display < Display.displays.Length) ? Display.displays[display].renderingWidth : Screen.width;
		}

		public override void Repaint(Event e)
		{
			if (targetTexture == null)
			{
				RenderTexture active = RenderTexture.active;
				int num = ((active != null) ? active.width : screenRenderingWidth);
				int num2 = ((active != null) ? active.height : screenRenderingHeight);
				GL.Viewport(new Rect(0f, 0f, num, num2));
				base.Repaint(e);
			}
			else
			{
				Camera current = Camera.current;
				RenderTexture active2 = RenderTexture.active;
				Camera.SetupCurrent(null);
				RenderTexture.active = targetTexture;
				GL.Viewport(new Rect(0f, 0f, targetTexture.width, targetTexture.height));
				base.Repaint(e);
				Camera.SetupCurrent(current);
				RenderTexture.active = active2;
			}
		}

		internal Vector2 ScreenToPanel(Vector2 screen)
		{
			return screenToPanelSpace(screen) / base.scale;
		}

		internal bool ScreenToPanel(Vector2 screenPosition, Vector2 screenDelta, out Vector2 panelPosition, out Vector2 panelDelta, bool allowOutside = false)
		{
			panelPosition = ScreenToPanel(screenPosition);
			Vector2 vector;
			if (!allowOutside)
			{
				Rect layout = visualTree.layout;
				if (!layout.Contains(panelPosition))
				{
					panelDelta = screenDelta;
					return false;
				}
				vector = ScreenToPanel(screenPosition - screenDelta);
				if (!layout.Contains(vector))
				{
					panelDelta = screenDelta;
					return true;
				}
			}
			else
			{
				vector = ScreenToPanel(screenPosition - screenDelta);
			}
			panelDelta = panelPosition - vector;
			return true;
		}

		private void AssignPanelToComponents(BaseRuntimePanel panel)
		{
			if (selectableGameObject == null)
			{
				return;
			}
			List<IRuntimePanelComponent> list = ObjectListPool<IRuntimePanelComponent>.Get();
			try
			{
				selectableGameObject.GetComponents(list);
				foreach (IRuntimePanelComponent item in list)
				{
					item.panel = panel;
				}
			}
			finally
			{
				ObjectListPool<IRuntimePanelComponent>.Release(list);
			}
		}

		internal void PointerLeavesPanel(int pointerId, Vector2 position)
		{
			ClearCachedElementUnderPointer(pointerId, null);
			CommitElementUnderPointers();
			PointerDeviceState.SavePointerPosition(pointerId, position, null, contextType);
		}

		internal void PointerEntersPanel(int pointerId, Vector2 position)
		{
			PointerDeviceState.SavePointerPosition(pointerId, position, this, contextType);
		}
	}
	internal interface IRuntimePanelComponent
	{
		IPanel panel { get; set; }
	}
	public enum PenButton
	{
		PenContact = 0,
		PenBarrel = 1,
		PenEraser = 5
	}
	public static class PointerCaptureHelper
	{
		private static PointerDispatchState GetStateFor(IEventHandler handler)
		{
			return (!(handler is VisualElement visualElement)) ? null : visualElement.panel?.dispatcher?.pointerState;
		}

		public static bool HasPointerCapture(this IEventHandler handler, int pointerId)
		{
			return GetStateFor(handler)?.HasPointerCapture(handler, pointerId) ?? false;
		}

		public static void CapturePointer(this IEventHandler handler, int pointerId)
		{
			GetStateFor(handler)?.CapturePointer(handler, pointerId);
		}

		public static void ReleasePointer(this IEventHandler handler, int pointerId)
		{
			GetStateFor(handler)?.ReleasePointer(handler, pointerId);
		}

		public static IEventHandler GetCapturingElement(this IPanel panel, int pointerId)
		{
			return panel?.dispatcher?.pointerState.GetCapturingElement(pointerId);
		}

		public static void ReleasePointer(this IPanel panel, int pointerId)
		{
			panel?.dispatcher?.pointerState.ReleasePointer(pointerId);
		}

		internal static void ActivateCompatibilityMouseEvents(this IPanel panel, int pointerId)
		{
			panel?.dispatcher?.pointerState.ActivateCompatibilityMouseEvents(pointerId);
		}

		internal static void PreventCompatibilityMouseEvents(this IPanel panel, int pointerId)
		{
			panel?.dispatcher?.pointerState.PreventCompatibilityMouseEvents(pointerId);
		}

		internal static bool ShouldSendCompatibilityMouseEvents(this IPanel panel, IPointerEvent evt)
		{
			return panel?.dispatcher?.pointerState.ShouldSendCompatibilityMouseEvents(evt) ?? true;
		}

		internal static void ProcessPointerCapture(this IPanel panel, int pointerId)
		{
			panel?.dispatcher?.pointerState.ProcessPointerCapture(pointerId);
		}

		internal static void ResetPointerDispatchState(this IPanel panel)
		{
			panel?.dispatcher?.pointerState.Reset();
		}
	}
	internal class PointerDispatchState
	{
		private IEventHandler[] m_PendingPointerCapture = new IEventHandler[PointerId.maxPointers];

		private IEventHandler[] m_PointerCapture = new IEventHandler[PointerId.maxPointers];

		private bool[] m_ShouldSendCompatibilityMouseEvents = new bool[PointerId.maxPointers];

		public PointerDispatchState()
		{
			Reset();
		}

		internal void Reset()
		{
			for (int i = 0; i < m_PointerCapture.Length; i++)
			{
				m_PendingPointerCapture[i] = null;
				m_PointerCapture[i] = null;
				m_ShouldSendCompatibilityMouseEvents[i] = true;
			}
		}

		public IEventHandler GetCapturingElement(int pointerId)
		{
			return m_PendingPointerCapture[pointerId];
		}

		public bool HasPointerCapture(IEventHandler handler, int pointerId)
		{
			return m_PendingPointerCapture[pointerId] == handler;
		}

		public void CapturePointer(IEventHandler handler, int pointerId)
		{
			if (pointerId == PointerId.mousePointerId && m_PendingPointerCapture[pointerId] != handler && GUIUtility.hotControl != 0)
			{
				GUIUtility.hotControl = 0;
			}
			m_PendingPointerCapture[pointerId] = handler;
		}

		public void ReleasePointer(int pointerId)
		{
			m_PendingPointerCapture[pointerId] = null;
		}

		public void ReleasePointer(IEventHandler handler, int pointerId)
		{
			if (handler == m_PendingPointerCapture[pointerId])
			{
				m_PendingPointerCapture[pointerId] = null;
			}
		}

		public void ProcessPointerCapture(int pointerId)
		{
			if (m_PointerCapture[pointerId] == m_PendingPointerCapture[pointerId])
			{
				return;
			}
			if (m_PointerCapture[pointerId] != null)
			{
				using (PointerCaptureOutEvent e = PointerCaptureEventBase<PointerCaptureOutEvent>.GetPooled(m_PointerCapture[pointerId], m_PendingPointerCapture[pointerId], pointerId))
				{
					m_PointerCapture[pointerId].SendEvent(e);
				}
				if (pointerId == PointerId.mousePointerId)
				{
					using MouseCaptureOutEvent e2 = PointerCaptureEventBase<MouseCaptureOutEvent>.GetPooled(m_PointerCapture[pointerId], m_PendingPointerCapture[pointerId], pointerId);
					m_PointerCapture[pointerId].SendEvent(e2);
				}
			}
			if (m_PendingPointerCapture[pointerId] != null)
			{
				using (PointerCaptureEvent e3 = PointerCaptureEventBase<PointerCaptureEvent>.GetPooled(m_PendingPointerCapture[pointerId], m_PointerCapture[pointerId], pointerId))
				{
					m_PendingPointerCapture[pointerId].SendEvent(e3);
				}
				if (pointerId == PointerId.mousePointerId)
				{
					using MouseCaptureEvent e4 = PointerCaptureEventBase<MouseCaptureEvent>.GetPooled(m_PendingPointerCapture[pointerId], m_PointerCapture[pointerId], pointerId);
					m_PendingPointerCapture[pointerId].SendEvent(e4);
				}
			}
			m_PointerCapture[pointerId] = m_PendingPointerCapture[pointerId];
		}

		public void ActivateCompatibilityMouseEvents(int pointerId)
		{
			m_ShouldSendCompatibilityMouseEvents[pointerId] = true;
		}

		public void PreventCompatibilityMouseEvents(int pointerId)
		{
			m_ShouldSendCompatibilityMouseEvents[pointerId] = false;
		}

		public bool ShouldSendCompatibilityMouseEvents(IPointerEvent evt)
		{
			return evt.isPrimary && m_ShouldSendCompatibilityMouseEvents[evt.pointerId];
		}
	}
	public abstract class PointerManipulator : MouseManipulator
	{
		private int m_CurrentPointerId;

		protected bool CanStartManipulation(IPointerEvent e)
		{
			foreach (ManipulatorActivationFilter activator in base.activators)
			{
				if (activator.Matches(e))
				{
					m_CurrentPointerId = e.pointerId;
					return true;
				}
			}
			return false;
		}

		protected bool CanStopManipulation(IPointerEvent e)
		{
			if (e == null)
			{
				return false;
			}
			return e.pointerId == m_CurrentPointerId;
		}
	}
	internal static class ProjectionUtils
	{
		public static Matrix4x4 Ortho(float left, float right, float bottom, float top, float near, float far)
		{
			Matrix4x4 result = default(Matrix4x4);
			float num = right - left;
			float num2 = top - bottom;
			float num3 = far - near;
			result.m00 = 2f / num;
			result.m11 = 2f / num2;
			result.m22 = 2f / num3;
			result.m03 = (0f - (right + left)) / num;
			result.m13 = (0f - (top + bottom)) / num2;
			result.m23 = (0f - (far + near)) / num3;
			result.m33 = 1f;
			return result;
		}
	}
	internal struct SafeHandleAccess
	{
		private IntPtr m_Handle;

		public SafeHandleAccess(IntPtr ptr)
		{
			m_Handle = ptr;
		}

		public bool IsNull()
		{
			return m_Handle == IntPtr.Zero;
		}

		public static implicit operator IntPtr(SafeHandleAccess a)
		{
			if (a.m_Handle == IntPtr.Zero)
			{
				throw new ArgumentNullException();
			}
			return a.m_Handle;
		}
	}
	internal class UIRAtlasAllocator : IDisposable
	{
		private class Row
		{
			private static ObjectPool<Row> s_Pool = new ObjectPool<Row>(() => new Row());

			public int Cursor;

			public int offsetX { get; private set; }

			public int offsetY { get; private set; }

			public int width { get; private set; }

			public int height { get; private set; }

			public static Row Acquire(int offsetX, int offsetY, int width, int height)
			{
				Row row = s_Pool.Get();
				row.offsetX = offsetX;
				row.offsetY = offsetY;
				row.width = width;
				row.height = height;
				row.Cursor = 0;
				return row;
			}

			public void Release()
			{
				s_Pool.Release(this);
				offsetX = -1;
				offsetY = -1;
				width = -1;
				height = -1;
				Cursor = -1;
			}
		}

		private class AreaNode
		{
			private static ObjectPool<AreaNode> s_Pool = new ObjectPool<AreaNode>(() => new AreaNode());

			public RectInt rect;

			public AreaNode previous;

			public AreaNode next;

			public static AreaNode Acquire(RectInt rect)
			{
				AreaNode areaNode = s_Pool.Get();
				areaNode.rect = rect;
				areaNode.previous = null;
				areaNode.next = null;
				return areaNode;
			}

			public void Release()
			{
				s_Pool.Release(this);
			}

			public void RemoveFromChain()
			{
				if (previous != null)
				{
					previous.next = next;
				}
				if (next != null)
				{
					next.previous = previous;
				}
				previous = null;
				next = null;
			}

			public void AddAfter(AreaNode previous)
			{
				Assert.IsNull(this.previous);
				Assert.IsNull(next);
				this.previous = previous;
				if (previous != null)
				{
					next = previous.next;
					previous.next = this;
				}
				if (next != null)
				{
					next.previous = this;
				}
			}
		}

		private AreaNode m_FirstUnpartitionedArea;

		private Row[] m_OpenRows;

		private int m_1SidePadding;

		private int m_2SidePadding;

		private static ProfilerMarker s_MarkerTryAllocate = new ProfilerMarker("UIRAtlasAllocator.TryAllocate");

		public int maxAtlasSize { get; }

		public int maxImageWidth { get; }

		public int maxImageHeight { get; }

		public int virtualWidth { get; private set; }

		public int virtualHeight { get; private set; }

		public int physicalWidth { get; private set; }

		public int physicalHeight { get; private set; }

		protected bool disposed { get; private set; }

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (disposed)
			{
				return;
			}
			if (disposing)
			{
				for (int i = 0; i < m_OpenRows.Length; i++)
				{
					m_OpenRows[i]?.Release();
				}
				m_OpenRows = null;
				AreaNode areaNode = m_FirstUnpartitionedArea;
				while (areaNode != null)
				{
					AreaNode next = areaNode.next;
					areaNode.Release();
					areaNode = next;
				}
				m_FirstUnpartitionedArea = null;
			}
			disposed = true;
		}

		private static int GetLog2OfNextPower(int n)
		{
			float f = Mathf.NextPowerOfTwo(n);
			float f2 = Mathf.Log(f, 2f);
			return Mathf.RoundToInt(f2);
		}

		public UIRAtlasAllocator(int initialAtlasSize, int maxAtlasSize, int sidePadding = 1)
		{
			Assert.IsTrue(initialAtlasSize > 0 && initialAtlasSize <= maxAtlasSize);
			Assert.IsTrue(initialAtlasSize == Mathf.NextPowerOfTwo(initialAtlasSize));
			Assert.IsTrue(maxAtlasSize == Mathf.NextPowerOfTwo(maxAtlasSize));
			m_1SidePadding = sidePadding;
			m_2SidePadding = sidePadding << 1;
			this.maxAtlasSize = maxAtlasSize;
			maxImageWidth = maxAtlasSize;
			maxImageHeight = ((initialAtlasSize == maxAtlasSize) ? (maxAtlasSize / 2 + m_2SidePadding) : (maxAtlasSize / 4 + m_2SidePadding));
			virtualWidth = initialAtlasSize;
			virtualHeight = initialAtlasSize;
			int num = GetLog2OfNextPower(maxAtlasSize) + 1;
			m_OpenRows = new Row[num];
			RectInt rect = new RectInt(0, 0, initialAtlasSize, initialAtlasSize);
			m_FirstUnpartitionedArea = AreaNode.Acquire(rect);
			BuildAreas();
		}

		public bool TryAllocate(int width, int height, out RectInt location)
		{
			using (s_MarkerTryAllocate.Auto())
			{
				location = default(RectInt);
				if (disposed)
				{
					return false;
				}
				if (width < 1 || height < 1)
				{
					return false;
				}
				if (width > maxImageWidth || height > maxImageHeight)
				{
					return false;
				}
				int log2OfNextPower = GetLog2OfNextPower(Mathf.Max(height - m_2SidePadding, 1));
				int rowHeight = (1 << log2OfNextPower) + m_2SidePadding;
				Row row = m_OpenRows[log2OfNextPower];
				if (row != null && row.width - row.Cursor < width)
				{
					row = null;
				}
				if (row == null)
				{
					for (AreaNode areaNode = m_FirstUnpartitionedArea; areaNode != null; areaNode = areaNode.next)
					{
						if (TryPartitionArea(areaNode, log2OfNextPower, rowHeight, width))
						{
							row = m_OpenRows[log2OfNextPower];
							break;
						}
					}
					if (row == null)
					{
						return false;
					}
				}
				location = new RectInt(row.offsetX + row.Cursor, row.offsetY, width, height);
				row.Cursor += width;
				Assert.IsTrue(row.Cursor <= row.width);
				physicalWidth = Mathf.NextPowerOfTwo(Mathf.Max(physicalWidth, location.xMax));
				physicalHeight = Mathf.NextPowerOfTwo(Mathf.Max(physicalHeight, location.yMax));
				return true;
			}
		}

		private bool TryPartitionArea(AreaNode areaNode, int rowIndex, int rowHeight, int minWidth)
		{
			RectInt rect = areaNode.rect;
			if (rect.height < rowHeight || rect.width < minWidth)
			{
				return false;
			}
			m_OpenRows[rowIndex]?.Release();
			Row row = Row.Acquire(rect.x, rect.y, rect.width, rowHeight);
			m_OpenRows[rowIndex] = row;
			rect.y += rowHeight;
			rect.height -= rowHeight;
			if (rect.height == 0)
			{
				if (areaNode == m_FirstUnpartitionedArea)
				{
					m_FirstUnpartitionedArea = areaNode.next;
				}
				areaNode.RemoveFromChain();
				areaNode.Release();
			}
			else
			{
				areaNode.rect = rect;
			}
			return true;
		}

		private void BuildAreas()
		{
			AreaNode previous = m_FirstUnpartitionedArea;
			while (virtualWidth < maxAtlasSize || virtualHeight < maxAtlasSize)
			{
				RectInt rect;
				if (virtualWidth > virtualHeight)
				{
					rect = new RectInt(0, virtualHeight, virtualWidth, virtualHeight);
					virtualHeight *= 2;
				}
				else
				{
					rect = new RectInt(virtualWidth, 0, virtualWidth, virtualHeight);
					virtualWidth *= 2;
				}
				AreaNode areaNode = AreaNode.Acquire(rect);
				areaNode.AddAfter(previous);
				previous = areaNode;
			}
		}
	}
	internal class DynamicAtlasCore : IDisposable
	{
		private int m_InitialSize;

		private UIRAtlasAllocator m_Allocator;

		private Dictionary<Texture2D, RectInt> m_UVs;

		private bool m_ForceReblitAll;

		private FilterMode m_FilterMode;

		private ColorSpace m_ColorSpace;

		private TextureBlitter m_Blitter;

		private int m_2SidePadding;

		private int m_1SidePadding;

		private int m_MaxAtlasSize;

		private static ProfilerMarker s_MarkerReset = new ProfilerMarker("UIR.AtlasManager.Reset");

		private static int s_TextureCounter;

		public int maxImageSize { get; }

		public RenderTextureFormat format { get; }

		public RenderTexture atlas { get; private set; }

		protected bool disposed { get; private set; }

		public DynamicAtlasCore(RenderTextureFormat format = RenderTextureFormat.ARGB32, FilterMode filterMode = FilterMode.Bilinear, int maxImageSize = 64, int initialSize = 64, int maxAtlasSize = 4096)
		{
			Debug.Assert(filterMode == FilterMode.Bilinear || filterMode == FilterMode.Point);
			Debug.Assert(maxAtlasSize <= SystemInfo.maxRenderTextureSize);
			Debug.Assert(initialSize <= maxAtlasSize);
			Debug.Assert(Mathf.IsPowerOfTwo(maxImageSize));
			Debug.Assert(Mathf.IsPowerOfTwo(initialSize));
			Debug.Assert(Mathf.IsPowerOfTwo(maxAtlasSize));
			m_MaxAtlasSize = maxAtlasSize;
			this.format = format;
			this.maxImageSize = maxImageSize;
			m_FilterMode = filterMode;
			m_UVs = new Dictionary<Texture2D, RectInt>(64);
			m_Blitter = new TextureBlitter(64);
			m_InitialSize = initialSize;
			m_2SidePadding = ((filterMode != FilterMode.Point) ? 2 : 0);
			m_1SidePadding = ((filterMode != FilterMode.Point) ? 1 : 0);
			m_Allocator = new UIRAtlasAllocator(m_InitialSize, m_MaxAtlasSize, m_1SidePadding);
			m_ColorSpace = QualitySettings.activeColorSpace;
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (disposed)
			{
				return;
			}
			if (disposing)
			{
				UIRUtility.Destroy(atlas);
				atlas = null;
				if (m_Allocator != null)
				{
					m_Allocator.Dispose();
					m_Allocator = null;
				}
				if (m_Blitter != null)
				{
					m_Blitter.Dispose();
					m_Blitter = null;
				}
			}
			disposed = true;
		}

		private static void LogDisposeError()
		{
			Debug.LogError("An attempt to use a disposed atlas manager has been detected.");
		}

		public bool IsReleased()
		{
			return atlas != null && !atlas.IsCreated();
		}

		public bool TryGetRect(Texture2D image, out RectInt uvs, Func<Texture2D, bool> filter = null)
		{
			uvs = default(RectInt);
			if (disposed)
			{
				LogDisposeError();
				return false;
			}
			if (image == null)
			{
				return false;
			}
			if (m_UVs.TryGetValue(image, out uvs))
			{
				return true;
			}
			if (filter != null && !filter(image))
			{
				return false;
			}
			if (!AllocateRect(image.width, image.height, out uvs))
			{
				return false;
			}
			m_UVs[image] = uvs;
			m_Blitter.QueueBlit(image, new RectInt(0, 0, image.width, image.height), new Vector2Int(uvs.x, uvs.y), addBorder: true, Color.white);
			return true;
		}

		public void UpdateTexture(Texture2D image)
		{
			RectInt value;
			if (disposed)
			{
				LogDisposeError();
			}
			else if (m_UVs.TryGetValue(image, out value))
			{
				m_Blitter.QueueBlit(image, new RectInt(0, 0, image.width, image.height), new Vector2Int(value.x, value.y), addBorder: true, Color.white);
			}
		}

		public bool AllocateRect(int width, int height, out RectInt uvs)
		{
			if (!m_Allocator.TryAllocate(width + m_2SidePadding, height + m_2SidePadding, out uvs))
			{
				return false;
			}
			uvs = new RectInt(uvs.x + m_1SidePadding, uvs.y + m_1SidePadding, width, height);
			return true;
		}

		public void EnqueueBlit(Texture image, RectInt srcRect, int x, int y, bool addBorder, Color tint)
		{
			m_Blitter.QueueBlit(image, srcRect, new Vector2Int(x, y), addBorder, tint);
		}

		public void Commit()
		{
			if (disposed)
			{
				LogDisposeError();
				return;
			}
			UpdateAtlasTexture();
			if (m_ForceReblitAll)
			{
				m_ForceReblitAll = false;
				m_Blitter.Reset();
				foreach (KeyValuePair<Texture2D, RectInt> uV in m_UVs)
				{
					m_Blitter.QueueBlit(uV.Key, new RectInt(0, 0, uV.Key.width, uV.Key.height), new Vector2Int(uV.Value.x, uV.Value.y), addBorder: true, Color.white);
				}
			}
			m_Blitter.Commit(atlas);
		}

		private void UpdateAtlasTexture()
		{
			if (atlas == null)
			{
				if (m_UVs.Count > m_Blitter.queueLength)
				{
					m_ForceReblitAll = true;
				}
				atlas = CreateAtlasTexture();
			}
			else if (atlas.width != m_Allocator.physicalWidth || atlas.height != m_Allocator.physicalHeight)
			{
				RenderTexture renderTexture = CreateAtlasTexture();
				if (renderTexture == null)
				{
					Debug.LogErrorFormat("Failed to allocate a render texture for the dynamic atlas. Current Size = {0}x{1}. Requested Size = {2}x{3}.", atlas.width, atlas.height, m_Allocator.physicalWidth, m_Allocator.physicalHeight);
				}
				else
				{
					m_Blitter.BlitOneNow(renderTexture, atlas, new RectInt(0, 0, atlas.width, atlas.height), new Vector2Int(0, 0), addBorder: false, Color.white);
				}
				UIRUtility.Destroy(atlas);
				atlas = renderTexture;
			}
		}

		private RenderTexture CreateAtlasTexture()
		{
			if (m_Allocator.physicalWidth == 0 || m_Allocator.physicalHeight == 0)
			{
				return null;
			}
			return new RenderTexture(m_Allocator.physicalWidth, m_Allocator.physicalHeight, 0, format)
			{
				hideFlags = HideFlags.HideAndDontSave,
				name = "UIR Dynamic Atlas " + s_TextureCounter++,
				filterMode = m_FilterMode
			};
		}
	}
	internal class DynamicAtlasPage : IDisposable
	{
		private readonly int m_1Padding = 1;

		private readonly int m_2Padding = 2;

		private Allocator2D m_Allocator;

		private TextureBlitter m_Blitter;

		private Vector2Int m_CurrentSize;

		private static int s_TextureCounter;

		public TextureId textureId { get; private set; }

		public RenderTexture atlas { get; private set; }

		public RenderTextureFormat format { get; }

		public FilterMode filterMode { get; }

		public Vector2Int minSize { get; }

		public Vector2Int maxSize { get; }

		public Vector2Int currentSize => m_CurrentSize;

		protected bool disposed { get; private set; }

		public DynamicAtlasPage(RenderTextureFormat format, FilterMode filterMode, Vector2Int minSize, Vector2Int maxSize)
		{
			textureId = TextureRegistry.instance.AllocAndAcquireDynamic();
			this.format = format;
			this.filterMode = filterMode;
			this.minSize = minSize;
			this.maxSize = maxSize;
			m_Allocator = new Allocator2D(minSize, maxSize, m_2Padding);
			m_Blitter = new TextureBlitter(64);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (disposed)
			{
				return;
			}
			if (disposing)
			{
				if (atlas != null)
				{
					UIRUtility.Destroy(atlas);
					atlas = null;
				}
				if (m_Allocator != null)
				{
					m_Allocator = null;
				}
				if (m_Blitter != null)
				{
					m_Blitter.Dispose();
					m_Blitter = null;
				}
				if (textureId != TextureId.invalid)
				{
					TextureRegistry.instance.Release(textureId);
					textureId = TextureId.invalid;
				}
			}
			disposed = true;
		}

		public bool TryAdd(Texture2D image, out Allocator2D.Alloc2D alloc, out RectInt rect)
		{
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
				alloc = default(Allocator2D.Alloc2D);
				rect = default(RectInt);
				return false;
			}
			if (!m_Allocator.TryAllocate(image.width + m_2Padding, image.height + m_2Padding, out alloc))
			{
				rect = default(RectInt);
				return false;
			}
			m_CurrentSize.x = Mathf.Max(m_CurrentSize.x, UIRUtility.GetNextPow2(alloc.rect.xMax));
			m_CurrentSize.y = Mathf.Max(m_CurrentSize.y, UIRUtility.GetNextPow2(alloc.rect.yMax));
			rect = new RectInt(alloc.rect.xMin + m_1Padding, alloc.rect.yMin + m_1Padding, image.width, image.height);
			Update(image, rect);
			return true;
		}

		public void Update(Texture2D image, RectInt rect)
		{
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
				return;
			}
			Debug.Assert(image != null && rect.width > 0 && rect.height > 0);
			m_Blitter.QueueBlit(image, new RectInt(0, 0, image.width, image.height), new Vector2Int(rect.x, rect.y), addBorder: true, Color.white);
		}

		public void Remove(Allocator2D.Alloc2D alloc)
		{
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
				return;
			}
			Debug.Assert(alloc.rect.width > 0 && alloc.rect.height > 0);
			m_Allocator.Free(alloc);
		}

		public void Commit()
		{
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
				return;
			}
			UpdateAtlasTexture();
			m_Blitter.Commit(atlas);
		}

		private void UpdateAtlasTexture()
		{
			if (atlas == null)
			{
				atlas = CreateAtlasTexture();
			}
			else if (atlas.width != m_CurrentSize.x || atlas.height != m_CurrentSize.y)
			{
				RenderTexture renderTexture = CreateAtlasTexture();
				if (renderTexture == null)
				{
					Debug.LogErrorFormat("Failed to allocate a render texture for the dynamic atlas. Current Size = {0}x{1}. Requested Size = {2}x{3}.", atlas.width, atlas.height, m_CurrentSize.x, m_CurrentSize.y);
				}
				else
				{
					m_Blitter.BlitOneNow(renderTexture, atlas, new RectInt(0, 0, atlas.width, atlas.height), new Vector2Int(0, 0), addBorder: false, Color.white);
				}
				UIRUtility.Destroy(atlas);
				atlas = renderTexture;
			}
		}

		private RenderTexture CreateAtlasTexture()
		{
			if (m_CurrentSize.x == 0 || m_CurrentSize.y == 0)
			{
				return null;
			}
			return new RenderTexture(m_CurrentSize.x, m_CurrentSize.y, 0, format)
			{
				hideFlags = HideFlags.HideAndDontSave,
				name = "UIR Dynamic Atlas Page " + s_TextureCounter++,
				filterMode = filterMode
			};
		}
	}
	internal class UIRLayoutUpdater : BaseVisualTreeUpdater
	{
		private const int kMaxValidateLayoutCount = 10;

		private static readonly string s_Description = "Update Layout";

		private static readonly ProfilerMarker s_ProfilerMarker = new ProfilerMarker(s_Description);

		private List<KeyValuePair<Rect, VisualElement>> changeEventsList = new List<KeyValuePair<Rect, VisualElement>>();

		public override ProfilerMarker profilerMarker => s_ProfilerMarker;

		public override void OnVersionChanged(VisualElement ve, VersionChangeType versionChangeType)
		{
			if ((versionChangeType & (VersionChangeType.Hierarchy | VersionChangeType.Layout)) != 0)
			{
				YogaNode yogaNode = ve.yogaNode;
				if (yogaNode != null && yogaNode.IsMeasureDefined)
				{
					yogaNode.MarkDirty();
				}
			}
		}

		public override void Update()
		{
			int num = 0;
			while (base.visualTree.yogaNode.IsDirty)
			{
				changeEventsList.Clear();
				if (num > 0)
				{
					base.panel.ApplyStyles();
				}
				base.panel.duringLayoutPhase = true;
				base.visualTree.yogaNode.CalculateLayout();
				base.panel.duringLayoutPhase = false;
				UpdateSubTree(base.visualTree, isDisplayed: true, changeEventsList);
				DispatchChangeEvents(changeEventsList, num);
				if (num++ >= 10)
				{
					Debug.LogError("Layout update is struggling to process current layout (consider simplifying to avoid recursive layout): " + base.visualTree);
					break;
				}
			}
			base.visualTree.focusController.ReevaluateFocus();
		}

		private void UpdateSubTree(VisualElement ve, bool isDisplayed, List<KeyValuePair<Rect, VisualElement>> changeEvents)
		{
			Rect lastLayout = new Rect(ve.yogaNode.LayoutX, ve.yogaNode.LayoutY, ve.yogaNode.LayoutWidth, ve.yogaNode.LayoutHeight);
			Rect rect = new Rect(ve.yogaNode.LayoutPaddingLeft, ve.yogaNode.LayoutPaddingLeft, ve.yogaNode.LayoutPaddingRight, ve.yogaNode.LayoutPaddingBottom);
			Rect lastPseudoPadding = new Rect(rect.x, rect.y, lastLayout.width - (rect.x + rect.width), lastLayout.height - (rect.y + rect.height));
			Rect lastLayout2 = ve.lastLayout;
			Rect lastPseudoPadding2 = ve.lastPseudoPadding;
			bool isHierarchyDisplayed = ve.isHierarchyDisplayed;
			VersionChangeType versionChangeType = (VersionChangeType)0;
			bool flag = lastLayout2.size != lastLayout.size;
			bool flag2 = lastPseudoPadding2.size != lastPseudoPadding.size;
			if (flag || flag2)
			{
				versionChangeType |= VersionChangeType.Size | VersionChangeType.Repaint;
			}
			bool flag3 = lastLayout.position != lastLayout2.position;
			bool flag4 = lastPseudoPadding.position != lastPseudoPadding2.position;
			if (flag3 || flag4)
			{
				versionChangeType |= VersionChangeType.Transform;
			}
			if ((versionChangeType & VersionChangeType.Size) != 0 && (versionChangeType & VersionChangeType.Transform) == 0 && !ve.hasDefaultRotationAndScale && (!Mathf.Approximately(ve.resolvedStyle.transformOrigin.x, 0f) || !Mathf.Approximately(ve.resolvedStyle.transformOrigin.y, 0f)))
			{
				versionChangeType |= VersionChangeType.Transform;
			}
			isDisplayed &= ve.resolvedStyle.display != DisplayStyle.None;
			ve.isHierarchyDisplayed = isDisplayed;
			if (versionChangeType != 0)
			{
				ve.IncrementVersion(versionChangeType);
			}
			ve.lastLayout = lastLayout;
			ve.lastPseudoPadding = lastPseudoPadding;
			bool hasNewLayout = ve.yogaNode.HasNewLayout;
			if (hasNewLayout)
			{
				int childCount = ve.hierarchy.childCount;
				for (int i = 0; i < childCount; i++)
				{
					VisualElement visualElement = ve.hierarchy[i];
					if (visualElement.yogaNode.HasNewLayout)
					{
						UpdateSubTree(visualElement, isDisplayed, changeEvents);
					}
				}
			}
			if ((flag || flag3) && ve.HasEventCallbacksOrDefaultActions(EventBase<GeometryChangedEvent>.EventCategory))
			{
				changeEvents.Add(new KeyValuePair<Rect, VisualElement>(lastLayout2, ve));
			}
			if (hasNewLayout)
			{
				ve.yogaNode.MarkLayoutSeen();
			}
		}

		private void DispatchChangeEvents(List<KeyValuePair<Rect, VisualElement>> changeEvents, int currentLayoutPass)
		{
			foreach (KeyValuePair<Rect, VisualElement> changeEvent in changeEvents)
			{
				VisualElement value = changeEvent.Value;
				using GeometryChangedEvent geometryChangedEvent = GeometryChangedEvent.GetPooled(changeEvent.Key, value.lastLayout);
				geometryChangedEvent.layoutPass = currentLayoutPass;
				geometryChangedEvent.target = value;
				value.HandleEventAtTargetAndDefaultPhase(geometryChangedEvent);
			}
		}
	}
	public struct Vertex
	{
		public static readonly float nearZ;

		public Vector3 position;

		public Color32 tint;

		public Vector2 uv;

		internal Color32 xformClipPages;

		internal Color32 ids;

		internal Color32 flags;

		internal Color32 opacityColorPages;

		internal Color32 settingIndex;

		internal Vector4 circle;

		internal float textureId;
	}
	public class MeshWriteData
	{
		internal NativeSlice<Vertex> m_Vertices;

		internal NativeSlice<ushort> m_Indices;

		internal Rect m_UVRegion;

		internal int currentIndex;

		internal int currentVertex;

		public int vertexCount => m_Vertices.Length;

		public int indexCount => m_Indices.Length;

		public Rect uvRegion => m_UVRegion;

		internal MeshWriteData()
		{
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void SetNextVertex(Vertex vertex)
		{
			m_Vertices[currentVertex++] = vertex;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void SetNextIndex(ushort index)
		{
			m_Indices[currentIndex++] = index;
		}

		public void SetAllVertices(Vertex[] vertices)
		{
			if (currentVertex == 0)
			{
				m_Vertices.CopyFrom(vertices);
				currentVertex = m_Vertices.Length;
				return;
			}
			throw new InvalidOperationException("SetAllVertices may not be called after using SetNextVertex");
		}

		public void SetAllVertices(NativeSlice<Vertex> vertices)
		{
			if (currentVertex == 0)
			{
				m_Vertices.CopyFrom(vertices);
				currentVertex = m_Vertices.Length;
				return;
			}
			throw new InvalidOperationException("SetAllVertices may not be called after using SetNextVertex");
		}

		public void SetAllIndices(ushort[] indices)
		{
			if (currentIndex == 0)
			{
				m_Indices.CopyFrom(indices);
				currentIndex = m_Indices.Length;
				return;
			}
			throw new InvalidOperationException("SetAllIndices may not be called after using SetNextIndex");
		}

		public void SetAllIndices(NativeSlice<ushort> indices)
		{
			if (currentIndex == 0)
			{
				m_Indices.CopyFrom(indices);
				currentIndex = m_Indices.Length;
				return;
			}
			throw new InvalidOperationException("SetAllIndices may not be called after using SetNextIndex");
		}

		internal void Reset(NativeSlice<Vertex> vertices, NativeSlice<ushort> indices)
		{
			m_Vertices = vertices;
			m_Indices = indices;
			m_UVRegion = new Rect(0f, 0f, 1f, 1f);
			currentIndex = (currentVertex = 0);
		}

		internal void Reset(NativeSlice<Vertex> vertices, NativeSlice<ushort> indices, Rect uvRegion)
		{
			m_Vertices = vertices;
			m_Indices = indices;
			m_UVRegion = uvRegion;
			currentIndex = (currentVertex = 0);
		}
	}
	internal struct ColorPage
	{
		public bool isValid;

		public Color32 pageAndID;

		public static ColorPage Init(RenderChain renderChain, BMPAlloc alloc)
		{
			bool flag = alloc.IsValid();
			return new ColorPage
			{
				isValid = flag,
				pageAndID = (flag ? renderChain.shaderInfoAllocator.ColorAllocToVertexData(alloc) : default(Color32))
			};
		}

		public MeshBuilderNative.NativeColorPage ToNativeColorPage()
		{
			return new MeshBuilderNative.NativeColorPage
			{
				isValid = (isValid ? 1 : 0),
				pageAndID = pageAndID
			};
		}
	}
	internal static class MeshGenerationContextUtils
	{
		public struct BorderParams
		{
			public Rect rect;

			public Color playmodeTintColor;

			public Color leftColor;

			public Color topColor;

			public Color rightColor;

			public Color bottomColor;

			public float leftWidth;

			public float topWidth;

			public float rightWidth;

			public float bottomWidth;

			public Vector2 topLeftRadius;

			public Vector2 topRightRadius;

			public Vector2 bottomRightRadius;

			public Vector2 bottomLeftRadius;

			public Material material;

			internal ColorPage leftColorPage;

			internal ColorPage topColorPage;

			internal ColorPage rightColorPage;

			internal ColorPage bottomColorPage;

			internal MeshBuilderNative.NativeBorderParams ToNativeParams()
			{
				return new MeshBuilderNative.NativeBorderParams
				{
					rect = rect,
					leftColor = leftColor,
					topColor = topColor,
					rightColor = rightColor,
					bottomColor = bottomColor,
					leftWidth = leftWidth,
					topWidth = topWidth,
					rightWidth = rightWidth,
					bottomWidth = bottomWidth,
					topLeftRadius = topLeftRadius,
					topRightRadius = topRightRadius,
					bottomRightRadius = bottomRightRadius,
					bottomLeftRadius = bottomLeftRadius,
					leftColorPage = leftColorPage.ToNativeColorPage(),
					topColorPage = topColorPage.ToNativeColorPage(),
					rightColorPage = rightColorPage.ToNativeColorPage(),
					bottomColorPage = bottomColorPage.ToNativeColorPage()
				};
			}
		}

		public struct RectangleParams
		{
			public Rect rect;

			public Rect uv;

			public Color color;

			public Rect subRect;

			public BackgroundPosition backgroundPositionX;

			public BackgroundPosition backgroundPositionY;

			public BackgroundRepeat backgroundRepeat;

			public BackgroundSize backgroundSize;

			public Texture texture;

			public Sprite sprite;

			public VectorImage vectorImage;

			public Material material;

			public ScaleMode scaleMode;

			public Color playmodeTintColor;

			public Vector2 topLeftRadius;

			public Vector2 topRightRadius;

			public Vector2 bottomRightRadius;

			public Vector2 bottomLeftRadius;

			public Vector2 contentSize;

			public Vector2 textureSize;

			public int leftSlice;

			public int topSlice;

			public int rightSlice;

			public int bottomSlice;

			public float sliceScale;

			internal Rect spriteGeomRect;

			public Vector4 rectInset;

			internal ColorPage colorPage;

			internal MeshGenerationContext.MeshFlags meshFlags;

			public static RectangleParams MakeSolid(Rect rect, Color color, ContextType panelContext)
			{
				Color color2 = ((panelContext == ContextType.Editor) ? UIElementsUtility.editorPlayModeTintColor : Color.white);
				return new RectangleParams
				{
					rect = rect,
					color = color,
					uv = new Rect(0f, 0f, 1f, 1f),
					playmodeTintColor = color2
				};
			}

			private static void AdjustUVsForScaleMode(Rect rect, Rect uv, Texture texture, ScaleMode scaleMode, out Rect rectOut, out Rect uvOut)
			{
				float num = Mathf.Abs((float)texture.width * uv.width / ((float)texture.height * uv.height));
				float num2 = rect.width / rect.height;
				switch (scaleMode)
				{
				case ScaleMode.ScaleAndCrop:
					if (num2 > num)
					{
						float num5 = uv.height * (num / num2);
						float num6 = (uv.height - num5) * 0.5f;
						uv = new Rect(uv.x, uv.y + num6, uv.width, num5);
					}
					else
					{
						float num7 = uv.width * (num2 / num);
						float num8 = (uv.width - num7) * 0.5f;
						uv = new Rect(uv.x + num8, uv.y, num7, uv.height);
					}
					break;
				case ScaleMode.ScaleToFit:
					if (num2 > num)
					{
						float num3 = num / num2;
						rect = new Rect(rect.xMin + rect.width * (1f - num3) * 0.5f, rect.yMin, num3 * rect.width, rect.height);
					}
					else
					{
						float num4 = num2 / num;
						rect = new Rect(rect.xMin, rect.yMin + rect.height * (1f - num4) * 0.5f, rect.width, num4 * rect.height);
					}
					break;
				default:
					throw new NotImplementedException();
				case ScaleMode.StretchToFill:
					break;
				}
				rectOut = rect;
				uvOut = uv;
			}

			private static void AdjustSpriteUVsForScaleMode(Rect containerRect, Rect srcRect, Rect spriteGeomRect, Sprite sprite, ScaleMode scaleMode, out Rect rectOut, out Rect uvOut)
			{
				float num = sprite.rect.width / sprite.rect.height;
				float num2 = containerRect.width / containerRect.height;
				Rect rect = spriteGeomRect;
				rect.position -= (Vector2)sprite.bounds.min;
				rect.position /= (Vector2)sprite.bounds.size;
				rect.size /= (Vector2)sprite.bounds.size;
				Vector2 position = rect.position;
				position.y = 1f - rect.size.y - position.y;
				rect.position = position;
				switch (scaleMode)
				{
				case ScaleMode.StretchToFill:
				{
					Vector2 size2 = containerRect.size;
					containerRect.position = rect.position * size2;
					containerRect.size = rect.size * size2;
					break;
				}
				case ScaleMode.ScaleAndCrop:
				{
					Rect b = containerRect;
					if (num2 > num)
					{
						b.height = b.width / num;
						b.position = new Vector2(b.position.x, (0f - (b.height - containerRect.height)) / 2f);
					}
					else
					{
						b.width = b.height * num;
						b.position = new Vector2((0f - (b.width - containerRect.width)) / 2f, b.position.y);
					}
					Vector2 size = b.size;
					b.position += rect.position * size;
					b.size = rect.size * size;
					Rect rect2 = RectIntersection(containerRect, b);
					if (rect2.width < 1E-30f || rect2.height < 1E-30f)
					{
						rect2 = Rect.zero;
					}
					else
					{
						Rect rect3 = rect2;
						rect3.position -= b.position;
						rect3.position /= b.size;
						rect3.size /= b.size;
						Vector2 position2 = rect3.position;
						position2.y = 1f - rect3.size.y - position2.y;
						rect3.position = position2;
						srcRect.position += rect3.position * srcRect.size;
						srcRect.size *= rect3.size;
					}
					containerRect = rect2;
					break;
				}
				case ScaleMode.ScaleToFit:
					if (num2 > num)
					{
						float num3 = num / num2;
						containerRect = new Rect(containerRect.xMin + containerRect.width * (1f - num3) * 0.5f, containerRect.yMin, num3 * containerRect.width, containerRect.height);
					}
					else
					{
						float num4 = num2 / num;
						containerRect = new Rect(containerRect.xMin, containerRect.yMin + containerRect.height * (1f - num4) * 0.5f, containerRect.width, num4 * containerRect.height);
					}
					containerRect.position += rect.position * containerRect.size;
					containerRect.size *= rect.size;
					break;
				default:
					throw new NotImplementedException();
				}
				rectOut = containerRect;
				uvOut = srcRect;
			}

			internal static Rect RectIntersection(Rect a, Rect b)
			{
				Rect zero = Rect.zero;
				zero.min = Vector2.Max(a.min, b.min);
				zero.max = Vector2.Min(a.max, b.max);
				zero.size = Vector2.Max(zero.size, Vector2.zero);
				return zero;
			}

			private static Rect ComputeGeomRect(Sprite sprite)
			{
				Vector2 vector = new Vector2(float.MaxValue, float.MaxValue);
				Vector2 vector2 = new Vector2(float.MinValue, float.MinValue);
				Vector2[] vertices = sprite.vertices;
				foreach (Vector2 rhs in vertices)
				{
					vector = Vector2.Min(vector, rhs);
					vector2 = Vector2.Max(vector2, rhs);
				}
				return new Rect(vector, vector2 - vector);
			}

			private static Rect ComputeUVRect(Sprite sprite)
			{
				Vector2 vector = new Vector2(float.MaxValue, float.MaxValue);
				Vector2 vector2 = new Vector2(float.MinValue, float.MinValue);
				Vector2[] array = sprite.uv;
				foreach (Vector2 rhs in array)
				{
					vector = Vector2.Min(vector, rhs);
					vector2 = Vector2.Max(vector2, rhs);
				}
				return new Rect(vector, vector2 - vector);
			}

			private static Rect ApplyPackingRotation(Rect uv, SpritePackingRotation rotation)
			{
				switch (rotation)
				{
				case SpritePackingRotation.FlipHorizontal:
				{
					uv.position += new Vector2(uv.size.x, 0f);
					Vector2 size2 = uv.size;
					size2.x = 0f - size2.x;
					uv.size = size2;
					break;
				}
				case SpritePackingRotation.FlipVertical:
				{
					uv.position += new Vector2(0f, uv.size.y);
					Vector2 size = uv.size;
					size.y = 0f - size.y;
					uv.size = size;
					break;
				}
				case SpritePackingRotation.Rotate180:
					uv.position += uv.size;
					uv.size = -uv.size;
					break;
				}
				return uv;
			}

			public static RectangleParams MakeTextured(Rect rect, Rect uv, Texture texture, ScaleMode scaleMode, ContextType panelContext)
			{
				Color color = ((panelContext == ContextType.Editor) ? UIElementsUtility.editorPlayModeTintColor : Color.white);
				AdjustUVsForScaleMode(rect, uv, texture, scaleMode, out rect, out uv);
				Vector2 vector = new Vector2(texture.width, texture.height);
				return new RectangleParams
				{
					rect = rect,
					subRect = new Rect(0f, 0f, 1f, 1f),
					uv = uv,
					color = Color.white,
					texture = texture,
					contentSize = vector,
					textureSize = vector,
					scaleMode = scaleMode,
					playmodeTintColor = color
				};
			}

			public static RectangleParams MakeSprite(Rect containerRect, Rect subRect, Sprite sprite, ScaleMode scaleMode, ContextType panelContext, bool hasRadius, ref Vector4 slices, bool useForRepeat = false)
			{
				if (sprite == null || sprite.bounds.size.x < 1E-30f || sprite.bounds.size.y < 1E-30f)
				{
					return default(RectangleParams);
				}
				if (sprite.texture == null)
				{
					Debug.LogWarning("Ignoring textureless sprite named \"" + sprite.name + "\", please import as a VectorImage instead");
					return default(RectangleParams);
				}
				Color color = ((panelContext == ContextType.Editor) ? UIElementsUtility.editorPlayModeTintColor : Color.white);
				Rect rect = ComputeGeomRect(sprite);
				Rect rect2 = ComputeUVRect(sprite);
				Vector4 border = sprite.border;
				bool flag = border != Vector4.zero || slices != Vector4.zero;
				bool flag2 = subRect != new Rect(0f, 0f, 1f, 1f);
				bool flag3 = scaleMode == ScaleMode.ScaleAndCrop || flag || hasRadius || useForRepeat || flag2;
				if (flag3 && sprite.packed && sprite.packingRotation != SpritePackingRotation.None)
				{
					rect2 = ApplyPackingRotation(rect2, sprite.packingRotation);
				}
				Rect srcRect;
				if (flag2)
				{
					srcRect = subRect;
					srcRect.position *= rect2.size;
					srcRect.position += rect2.position;
					srcRect.size *= rect2.size;
				}
				else
				{
					srcRect = rect2;
				}
				AdjustSpriteUVsForScaleMode(containerRect, srcRect, rect, sprite, scaleMode, out var rectOut, out var uvOut);
				Rect rect3 = rect;
				rect3.size /= (Vector2)sprite.bounds.size;
				rect3.position -= (Vector2)sprite.bounds.min;
				rect3.position /= (Vector2)sprite.bounds.size;
				rect3.position = new Vector2(rect3.position.x, 1f - (rect3.position.y + rect3.height));
				RectangleParams result = new RectangleParams
				{
					rect = rectOut,
					uv = uvOut,
					subRect = rect3,
					color = Color.white,
					texture = (flag3 ? sprite.texture : null),
					sprite = (flag3 ? null : sprite),
					contentSize = sprite.rect.size,
					textureSize = new Vector2(sprite.texture.width, sprite.texture.height),
					spriteGeomRect = rect,
					scaleMode = scaleMode,
					playmodeTintColor = color,
					meshFlags = (sprite.packed ? MeshGenerationContext.MeshFlags.SkipDynamicAtlas : MeshGenerationContext.MeshFlags.None)
				};
				Vector4 vector = new Vector4(border.x, border.w, border.z, border.y);
				if (slices != Vector4.zero && vector != Vector4.zero && vector != slices)
				{
					Debug.LogWarning($"Sprite \"{sprite.name}\" borders {vector} are overridden by style slices {slices}");
				}
				else if (slices == Vector4.zero)
				{
					slices = vector;
				}
				return result;
			}

			public static RectangleParams MakeVectorTextured(Rect rect, Rect uv, VectorImage vectorImage, ScaleMode scaleMode, ContextType panelContext)
			{
				Color color = ((panelContext == ContextType.Editor) ? UIElementsUtility.editorPlayModeTintColor : Color.white);
				return new RectangleParams
				{
					rect = rect,
					subRect = new Rect(0f, 0f, 1f, 1f),
					uv = uv,
					color = Color.white,
					vectorImage = vectorImage,
					contentSize = new Vector2(vectorImage.width, vectorImage.height),
					scaleMode = scaleMode,
					playmodeTintColor = color
				};
			}

			internal bool HasRadius(float epsilon)
			{
				return (topLeftRadius.x > epsilon && topLeftRadius.y > epsilon) || (topRightRadius.x > epsilon && topRightRadius.y > epsilon) || (bottomRightRadius.x > epsilon && bottomRightRadius.y > epsilon) || (bottomLeftRadius.x > epsilon && bottomLeftRadius.y > epsilon);
			}

			internal bool HasSlices(float epsilon)
			{
				return (float)leftSlice > epsilon || (float)topSlice > epsilon || (float)rightSlice > epsilon || (float)bottomSlice > epsilon;
			}

			internal MeshBuilderNative.NativeRectParams ToNativeParams(Rect uvRegion)
			{
				return new MeshBuilderNative.NativeRectParams
				{
					rect = rect,
					subRect = subRect,
					uv = uv,
					uvRegion = uvRegion,
					color = color,
					scaleMode = scaleMode,
					topLeftRadius = topLeftRadius,
					topRightRadius = topRightRadius,
					bottomRightRadius = bottomRightRadius,
					bottomLeftRadius = bottomLeftRadius,
					contentSize = contentSize,
					textureSize = textureSize,
					texturePixelsPerPoint = 1f,
					leftSlice = leftSlice,
					topSlice = topSlice,
					rightSlice = rightSlice,
					bottomSlice = bottomSlice,
					sliceScale = sliceScale,
					rectInset = rectInset,
					colorPage = colorPage.ToNativeColorPage()
				};
			}
		}

		public static void Rectangle(this MeshGenerationContext mgc, RectangleParams rectParams)
		{
			mgc.painter.DrawRectangle(rectParams);
		}

		public static void Border(this MeshGenerationContext mgc, BorderParams borderParams)
		{
			mgc.painter.DrawBorder(borderParams);
		}

		public static void Text(this MeshGenerationContext mgc, TextElement te)
		{
			if (TextUtilities.IsFontAssigned(te))
			{
				mgc.painter.DrawText(te);
			}
		}

		private static Vector2 ConvertBorderRadiusPercentToPoints(Vector2 borderRectSize, Length length)
		{
			float a = length.value;
			float a2 = length.value;
			if (length.unit == LengthUnit.Percent)
			{
				a = borderRectSize.x * length.value / 100f;
				a2 = borderRectSize.y * length.value / 100f;
			}
			a = Mathf.Max(a, 0f);
			a2 = Mathf.Max(a2, 0f);
			return new Vector2(a, a2);
		}

		public static void GetVisualElementRadii(VisualElement ve, out Vector2 topLeft, out Vector2 bottomLeft, out Vector2 topRight, out Vector2 bottomRight)
		{
			IResolvedStyle resolvedStyle = ve.resolvedStyle;
			Vector2 borderRectSize = new Vector2(resolvedStyle.width, resolvedStyle.height);
			ComputedStyle computedStyle = ve.computedStyle;
			topLeft = ConvertBorderRadiusPercentToPoints(borderRectSize, computedStyle.borderTopLeftRadius);
			bottomLeft = ConvertBorderRadiusPercentToPoints(borderRectSize, computedStyle.borderBottomLeftRadius);
			topRight = ConvertBorderRadiusPercentToPoints(borderRectSize, computedStyle.borderTopRightRadius);
			bottomRight = ConvertBorderRadiusPercentToPoints(borderRectSize, computedStyle.borderBottomRightRadius);
		}

		public static void AdjustBackgroundSizeForBorders(VisualElement visualElement, ref RectangleParams rectParams)
		{
			IResolvedStyle resolvedStyle = visualElement.resolvedStyle;
			Vector4 zero = Vector4.zero;
			if (resolvedStyle.borderLeftWidth >= 1f && resolvedStyle.borderLeftColor.a >= 1f)
			{
				zero.x = 0.5f;
			}
			if (resolvedStyle.borderTopWidth >= 1f && resolvedStyle.borderTopColor.a >= 1f)
			{
				zero.y = 0.5f;
			}
			if (resolvedStyle.borderRightWidth >= 1f && resolvedStyle.borderRightColor.a >= 1f)
			{
				zero.z = 0.5f;
			}
			if (resolvedStyle.borderBottomWidth >= 1f && resolvedStyle.borderBottomColor.a >= 1f)
			{
				zero.w = 0.5f;
			}
			rectParams.rectInset = zero;
		}
	}
	public class MeshGenerationContext
	{
		[Flags]
		internal enum MeshFlags
		{
			None = 0,
			UVisDisplacement = 1,
			SkipDynamicAtlas = 2
		}

		private Painter2D m_Painter2D;

		private static readonly ProfilerMarker s_AllocateMarker = new ProfilerMarker("UIR.MeshGenerationContext.Allocate");

		private static readonly ProfilerMarker s_DrawVectorImageMarker = new ProfilerMarker("UIR.MeshGenerationContext.DrawVectorImage");

		internal IStylePainter painter;

		public VisualElement visualElement => painter.visualElement;

		public Painter2D painter2D
		{
			get
			{
				if (m_Painter2D == null)
				{
					m_Painter2D = new Painter2D(this);
				}
				return m_Painter2D;
			}
		}

		internal bool hasPainter2D => m_Painter2D != null;

		internal MeshGenerationContext(IStylePainter painter)
		{
			this.painter = painter;
		}

		public MeshWriteData Allocate(int vertexCount, int indexCount, Texture texture = null)
		{
			using (s_AllocateMarker.Auto())
			{
				return painter.DrawMesh(vertexCount, indexCount, texture, null, MeshFlags.None);
			}
		}

		internal MeshWriteData Allocate(int vertexCount, int indexCount, Texture texture, Material material, MeshFlags flags)
		{
			using (s_AllocateMarker.Auto())
			{
				return painter.DrawMesh(vertexCount, indexCount, texture, material, flags);
			}
		}

		public void DrawVectorImage(VectorImage vectorImage, Vector2 offset, Angle rotationAngle, Vector2 scale)
		{
			using (s_DrawVectorImageMarker.Auto())
			{
				painter.DrawVectorImage(vectorImage, offset, rotationAngle, scale);
			}
		}

		public void DrawText(string text, Vector2 pos, float fontSize, Color color, FontAsset font = null)
		{
			if (font == null)
			{
				font = TextUtilities.GetFontAsset(visualElement);
			}
			painter.DrawText(text, pos, fontSize, color, font);
		}
	}
	public class Painter2D : IDisposable
	{
		private MeshGenerationContext m_Ctx;

		internal DetachedAllocator m_DetachedAllocator;

		internal SafeHandleAccess m_Handle;

		private bool m_Disposed;

		private static float s_MaxArcRadius = -1f;

		private static readonly ProfilerMarker s_StrokeMarker = new ProfilerMarker("Painter2D.Stroke");

		private static readonly ProfilerMarker s_FillMarker = new ProfilerMarker("Painter2D.Fill");

		internal bool isDetached => m_DetachedAllocator != null;

		public float lineWidth
		{
			get
			{
				return UIPainter2D.GetLineWidth(m_Handle);
			}
			set
			{
				UIPainter2D.SetLineWidth(m_Handle, value);
			}
		}

		public Color strokeColor
		{
			get
			{
				return UIPainter2D.GetStrokeColor(m_Handle);
			}
			set
			{
				UIPainter2D.SetStrokeColor(m_Handle, value);
			}
		}

		public Gradient strokeGradient
		{
			get
			{
				return UIPainter2D.GetStrokeGradient(m_Handle);
			}
			set
			{
				UIPainter2D.SetStrokeGradient(m_Handle, value);
			}
		}

		public Color fillColor
		{
			get
			{
				return UIPainter2D.GetFillColor(m_Handle);
			}
			set
			{
				UIPainter2D.SetFillColor(m_Handle, value);
			}
		}

		public LineJoin lineJoin
		{
			get
			{
				return UIPainter2D.GetLineJoin(m_Handle);
			}
			set
			{
				UIPainter2D.SetLineJoin(m_Handle, value);
			}
		}

		public LineCap lineCap
		{
			get
			{
				return UIPainter2D.GetLineCap(m_Handle);
			}
			set
			{
				UIPainter2D.SetLineCap(m_Handle, value);
			}
		}

		public float miterLimit
		{
			get
			{
				return UIPainter2D.GetMiterLimit(m_Handle);
			}
			set
			{
				UIPainter2D.SetMiterLimit(m_Handle, value);
			}
		}

		internal static bool isPainterActive { get; set; }

		private static float maxArcRadius
		{
			get
			{
				if (s_MaxArcRadius < 0f)
				{
					if (!UIRenderDevice.vertexTexturingIsAvailable)
					{
						s_MaxArcRadius = 1000f;
					}
					else
					{
						s_MaxArcRadius = 100000f;
					}
				}
				return s_MaxArcRadius;
			}
		}

		internal Painter2D(MeshGenerationContext ctx)
		{
			m_Handle = new SafeHandleAccess(UIPainter2D.Create());
			m_Ctx = ctx;
			Reset();
		}

		public Painter2D()
		{
			m_Handle = new SafeHandleAccess(UIPainter2D.Create(computeBBox: true));
			m_DetachedAllocator = new DetachedAllocator();
			isPainterActive = true;
			Reset();
		}

		internal void Reset()
		{
			UIPainter2D.Reset(m_Handle);
		}

		internal MeshWriteData Allocate(int vertexCount, int indexCount)
		{
			if (isDetached)
			{
				return m_DetachedAllocator.Alloc(vertexCount, indexCount);
			}
			return m_Ctx.Allocate(vertexCount, indexCount);
		}

		public void Clear()
		{
			if (!isDetached)
			{
				Debug.LogError("Clear() cannot be called on a Painter2D associated with a MeshGenerationContext. You should create your own instance of Painter2D instead.");
				return;
			}
			m_DetachedAllocator.Clear();
			Reset();
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (m_Disposed)
			{
				return;
			}
			if (disposing)
			{
				if (!m_Handle.IsNull())
				{
					UIPainter2D.Destroy(m_Handle);
					m_Handle = new SafeHandleAccess(IntPtr.Zero);
				}
				if (m_DetachedAllocator != null)
				{
					m_DetachedAllocator.Dispose();
				}
			}
			m_Disposed = true;
		}

		private bool ValidateState()
		{
			bool flag = isDetached || isPainterActive;
			if (!flag)
			{
				Debug.LogError("Cannot issue vector graphics commands outside of generateVisualContent callback");
			}
			return flag;
		}

		public void BeginPath()
		{
			if (ValidateState())
			{
				UIPainter2D.BeginPath(m_Handle);
			}
		}

		public void ClosePath()
		{
			if (ValidateState())
			{
				UIPainter2D.ClosePath(m_Handle);
			}
		}

		public void MoveTo(Vector2 pos)
		{
			if (ValidateState())
			{
				UIPainter2D.MoveTo(m_Handle, pos);
			}
		}

		public void LineTo(Vector2 pos)
		{
			if (ValidateState())
			{
				UIPainter2D.LineTo(m_Handle, pos);
			}
		}

		public void ArcTo(Vector2 p1, Vector2 p2, float radius)
		{
			if (ValidateState())
			{
				UIPainter2D.ArcTo(m_Handle, p1, p2, radius);
			}
		}

		public void Arc(Vector2 center, float radius, Angle startAngle, Angle endAngle, ArcDirection direction = ArcDirection.Clockwise)
		{
			if (ValidateState())
			{
				UIPainter2D.Arc(m_Handle, center, radius, startAngle.ToRadians(), endAngle.ToRadians(), direction);
			}
		}

		public void BezierCurveTo(Vector2 p1, Vector2 p2, Vector2 p3)
		{
			if (ValidateState())
			{
				UIPainter2D.BezierCurveTo(m_Handle, p1, p2, p3);
			}
		}

		public void QuadraticCurveTo(Vector2 p1, Vector2 p2)
		{
			if (ValidateState())
			{
				UIPainter2D.QuadraticCurveTo(m_Handle, p1, p2);
			}
		}

		public unsafe void Stroke()
		{
			using (s_StrokeMarker.Auto())
			{
				if (ValidateState())
				{
					MeshWriteDataInterface meshWriteDataInterface = UIPainter2D.Stroke(m_Handle);
					if (meshWriteDataInterface.vertexCount != 0)
					{
						MeshWriteData meshWriteData = Allocate(meshWriteDataInterface.vertexCount, meshWriteDataInterface.indexCount);
						NativeSlice<Vertex> allVertices = UIRenderDevice.PtrToSlice<Vertex>((void*)meshWriteDataInterface.vertices, meshWriteDataInterface.vertexCount);
						NativeSlice<ushort> allIndices = UIRenderDevice.PtrToSlice<ushort>((void*)meshWriteDataInterface.indices, meshWriteDataInterface.indexCount);
						meshWriteData.SetAllVertices(allVertices);
						meshWriteData.SetAllIndices(allIndices);
					}
				}
			}
		}

		public unsafe void Fill(FillRule fillRule = FillRule.NonZero)
		{
			using (s_FillMarker.Auto())
			{
				if (ValidateState())
				{
					MeshWriteDataInterface meshWriteDataInterface = UIPainter2D.Fill(m_Handle, fillRule);
					if (meshWriteDataInterface.vertexCount != 0)
					{
						MeshWriteData meshWriteData = Allocate(meshWriteDataInterface.vertexCount, meshWriteDataInterface.indexCount);
						NativeSlice<Vertex> allVertices = UIRenderDevice.PtrToSlice<Vertex>((void*)meshWriteDataInterface.vertices, meshWriteDataInterface.vertexCount);
						NativeSlice<ushort> allIndices = UIRenderDevice.PtrToSlice<ushort>((void*)meshWriteDataInterface.indices, meshWriteDataInterface.indexCount);
						meshWriteData.SetAllVertices(allVertices);
						meshWriteData.SetAllIndices(allIndices);
					}
				}
			}
		}

		public bool SaveToVectorImage(VectorImage vectorImage)
		{
			if (!isDetached)
			{
				Debug.LogError("SaveToVectorImage cannot be called on a Painter2D associated with a MeshGenerationContext. You should create your own instance of Painter2D instead.");
				return false;
			}
			if (vectorImage == null)
			{
				throw new NullReferenceException("The provided vectorImage is null");
			}
			List<MeshWriteData> meshes = m_DetachedAllocator.meshes;
			int num = 0;
			int num2 = 0;
			foreach (MeshWriteData item in meshes)
			{
				num += item.m_Vertices.Length;
				num2 += item.m_Indices.Length;
			}
			Rect bBox = UIPainter2D.GetBBox(m_Handle);
			VectorImageVertex[] array = new VectorImageVertex[num];
			ushort[] array2 = new ushort[num2];
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			foreach (MeshWriteData item2 in meshes)
			{
				NativeSlice<Vertex> vertices = item2.m_Vertices;
				for (int i = 0; i < vertices.Length; i++)
				{
					Vertex vertex = vertices[i];
					Vector3 position = vertex.position;
					position.x -= bBox.x;
					position.y -= bBox.y;
					array[num3++] = new VectorImageVertex
					{
						position = new Vector3(position.x, position.y, Vertex.nearZ),
						tint = vertex.tint,
						uv = vertex.uv,
						flags = vertex.flags,
						circle = vertex.circle
					};
				}
				NativeSlice<ushort> indices = item2.m_Indices;
				for (int j = 0; j < indices.Length; j++)
				{
					array2[num4++] = (ushort)(indices[j] + num5);
				}
				num5 += vertices.Length;
			}
			vectorImage.version = 0;
			vectorImage.vertices = array;
			vectorImage.indices = array2;
			vectorImage.size = bBox.size;
			return true;
		}
	}
	internal class UIRRepaintUpdater : BaseVisualTreeUpdater
	{
		private BaseVisualElementPanel attachedPanel;

		internal RenderChain renderChain;

		private static readonly string s_Description;

		private static readonly ProfilerMarker s_ProfilerMarker;

		public override ProfilerMarker profilerMarker => s_ProfilerMarker;

		public bool drawStats { get; set; }

		public bool breakBatches { get; set; }

		protected bool disposed { get; private set; }

		public UIRRepaintUpdater()
		{
			base.panelChanged += OnPanelChanged;
		}

		public override void OnVersionChanged(VisualElement ve, VersionChangeType versionChangeType)
		{
			if (renderChain != null)
			{
				bool flag = (versionChangeType & VersionChangeType.Transform) != 0;
				bool flag2 = (versionChangeType & VersionChangeType.Size) != 0;
				bool flag3 = (versionChangeType & VersionChangeType.Overflow) != 0;
				bool flag4 = (versionChangeType & VersionChangeType.BorderRadius) != 0;
				bool flag5 = (versionChangeType & VersionChangeType.BorderWidth) != 0;
				if ((versionChangeType & VersionChangeType.RenderHints) != 0)
				{
					renderChain.UIEOnRenderHintsChanged(ve);
				}
				if (flag || flag2 || flag5)
				{
					renderChain.UIEOnTransformOrSizeChanged(ve, flag, flag2 || flag5);
				}
				if (flag3 || flag4)
				{
					renderChain.UIEOnClippingChanged(ve, hierarchical: false);
				}
				if ((versionChangeType & VersionChangeType.Opacity) != 0)
				{
					renderChain.UIEOnOpacityChanged(ve);
				}
				if ((versionChangeType & VersionChangeType.Color) != 0)
				{
					renderChain.UIEOnColorChanged(ve);
				}
				if ((versionChangeType & VersionChangeType.Repaint) != 0)
				{
					renderChain.UIEOnVisualsChanged(ve, hierarchical: false);
				}
			}
		}

		public override void Update()
		{
			if (renderChain == null)
			{
				InitRenderChain();
			}
			if (renderChain != null && renderChain.device != null)
			{
				renderChain.ProcessChanges();
				PanelClearSettings clearSettings = base.panel.clearSettings;
				if (clearSettings.clearColor || clearSettings.clearDepthStencil)
				{
					Color color = clearSettings.color;
					color = color.RGBMultiplied(color.a);
					GL.Clear(clearSettings.clearDepthStencil, clearSettings.clearColor, color, 0.99f);
				}
				renderChain.drawStats = drawStats;
				renderChain.device.breakBatches = breakBatches;
				renderChain.Render();
			}
		}

		protected virtual RenderChain CreateRenderChain()
		{
			return new RenderChain(base.panel);
		}

		static UIRRepaintUpdater()
		{
			s_Description = "Update Rendering";
			s_ProfilerMarker = new ProfilerMarker(s_Description);
			Utility.GraphicsResourcesRecreate += OnGraphicsResourcesRecreate;
		}

		private static void OnGraphicsResourcesRecreate(bool recreate)
		{
			if (!recreate)
			{
				UIRenderDevice.PrepareForGfxDeviceRecreate();
			}
			Dictionary<int, Panel>.Enumerator panelsIterator = UIElementsUtility.GetPanelsIterator();
			while (panelsIterator.MoveNext())
			{
				if (recreate)
				{
					panelsIterator.Current.Value.atlas?.Reset();
				}
				else
				{
					(panelsIterator.Current.Value.GetUpdater(VisualTreeUpdatePhase.Repaint) as UIRRepaintUpdater)?.DestroyRenderChain();
				}
			}
			if (!recreate)
			{
				UIRenderDevice.FlushAllPendingDeviceDisposes();
			}
			else
			{
				UIRenderDevice.WrapUpGfxDeviceRecreate();
			}
		}

		private void OnPanelChanged(BaseVisualElementPanel obj)
		{
			DetachFromPanel();
			AttachToPanel();
		}

		private void AttachToPanel()
		{
			Debug.Assert(attachedPanel == null);
			if (base.panel != null)
			{
				attachedPanel = base.panel;
				attachedPanel.atlasChanged += OnPanelAtlasChanged;
				attachedPanel.standardShaderChanged += OnPanelStandardShaderChanged;
				attachedPanel.standardWorldSpaceShaderChanged += OnPanelStandardWorldSpaceShaderChanged;
				attachedPanel.hierarchyChanged += OnPanelHierarchyChanged;
			}
		}

		private void DetachFromPanel()
		{
			if (attachedPanel != null)
			{
				DestroyRenderChain();
				attachedPanel.atlasChanged -= OnPanelAtlasChanged;
				attachedPanel.standardShaderChanged -= OnPanelStandardShaderChanged;
				attachedPanel.standardWorldSpaceShaderChanged -= OnPanelStandardWorldSpaceShaderChanged;
				attachedPanel.hierarchyChanged -= OnPanelHierarchyChanged;
				attachedPanel = null;
			}
		}

		private void InitRenderChain()
		{
			renderChain = CreateRenderChain();
			if (attachedPanel?.visualTree != null)
			{
				renderChain.UIEOnChildAdded(attachedPanel.visualTree);
			}
			OnPanelStandardShaderChanged();
			if (base.panel.contextType == ContextType.Player)
			{
				OnPanelStandardWorldSpaceShaderChanged();
			}
		}

		internal void DestroyRenderChain()
		{
			if (renderChain != null)
			{
				renderChain.Dispose();
				renderChain = null;
				ResetAllElementsDataRecursive(attachedPanel.visualTree);
			}
		}

		private void OnPanelAtlasChanged()
		{
			DestroyRenderChain();
		}

		private void OnPanelHierarchyChanged(VisualElement ve, HierarchyChangeType changeType)
		{
			if (renderChain != null)
			{
				switch (changeType)
				{
				case HierarchyChangeType.Add:
					renderChain.UIEOnChildAdded(ve);
					break;
				case HierarchyChangeType.Remove:
					renderChain.UIEOnChildRemoving(ve);
					break;
				case HierarchyChangeType.Move:
					renderChain.UIEOnChildrenReordered(ve);
					break;
				}
			}
		}

		private void OnPanelStandardShaderChanged()
		{
			if (renderChain == null)
			{
				return;
			}
			Shader shader = base.panel.standardShader;
			if (shader == null)
			{
				shader = Shader.Find(UIRUtility.k_DefaultShaderName);
				Debug.Assert(shader != null, "Failed to load UIElements default shader");
				if (shader != null)
				{
					shader.hideFlags |= HideFlags.DontSaveInEditor;
				}
			}
			renderChain.defaultShader = shader;
		}

		private void OnPanelStandardWorldSpaceShaderChanged()
		{
			if (renderChain == null)
			{
				return;
			}
			Shader shader = base.panel.standardWorldSpaceShader;
			if (shader == null)
			{
				shader = Shader.Find(UIRUtility.k_DefaultWorldSpaceShaderName);
				Debug.Assert(shader != null, "Failed to load UIElements default world-space shader");
				if (shader != null)
				{
					shader.hideFlags |= HideFlags.DontSaveInEditor;
				}
			}
			renderChain.defaultWorldSpaceShader = shader;
		}

		private void ResetAllElementsDataRecursive(VisualElement ve)
		{
			ve.renderChainData = default(RenderChainVEData);
			int num = ve.hierarchy.childCount - 1;
			while (num >= 0)
			{
				ResetAllElementsDataRecursive(ve.hierarchy[num--]);
			}
		}

		protected override void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (disposing)
				{
					DetachFromPanel();
				}
				disposed = true;
			}
		}
	}
	internal struct TextureId
	{
		private readonly int m_Index;

		public static readonly TextureId invalid = new TextureId(-1);

		public int index => m_Index - 1;

		public TextureId(int index)
		{
			m_Index = index + 1;
		}

		public bool IsValid()
		{
			return m_Index > 0;
		}

		public float ConvertToGpu()
		{
			return index;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is TextureId))
			{
				return false;
			}
			return (TextureId)obj == this;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public bool Equals(TextureId other)
		{
			return m_Index == other.m_Index;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public override int GetHashCode()
		{
			return m_Index.GetHashCode();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool operator ==(TextureId left, TextureId right)
		{
			return left.m_Index == right.m_Index;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool operator !=(TextureId left, TextureId right)
		{
			return !(left == right);
		}
	}
	internal class TextureRegistry
	{
		private struct TextureInfo
		{
			public Texture texture;

			public bool dynamic;

			public int refCount;
		}

		public struct Statistics
		{
			public int freeIdsCount;

			public int createdIdsCount;

			public int allocatedIdsTotalCount;

			public int allocatedIdsDynamicCount;

			public int allocatedIdsStaticCount;

			public int availableIdsCount;
		}

		private List<TextureInfo> m_Textures = new List<TextureInfo>(128);

		private Dictionary<Texture, TextureId> m_TextureToId = new Dictionary<Texture, TextureId>(128);

		private Stack<TextureId> m_FreeIds = new Stack<TextureId>();

		internal const int maxTextures = 2048;

		public static TextureRegistry instance { get; } = new TextureRegistry();

		public Texture GetTexture(TextureId id)
		{
			if (id.index < 0 || id.index >= m_Textures.Count)
			{
				Debug.LogError($"Attempted to get an invalid texture (index={id.index}).");
				return null;
			}
			TextureInfo textureInfo = m_Textures[id.index];
			if (textureInfo.refCount < 1)
			{
				Debug.LogError($"Attempted to get a texture (index={id.index}) that is not allocated.");
				return null;
			}
			return textureInfo.texture;
		}

		public TextureId AllocAndAcquireDynamic()
		{
			return AllocAndAcquire(null, dynamic: true);
		}

		public void UpdateDynamic(TextureId id, Texture texture)
		{
			if (id.index < 0 || id.index >= m_Textures.Count)
			{
				Debug.LogError($"Attempted to update an invalid dynamic texture (index={id.index}).");
				return;
			}
			TextureInfo value = m_Textures[id.index];
			if (!value.dynamic)
			{
				Debug.LogError($"Attempted to update a texture (index={id.index}) that is not dynamic.");
				return;
			}
			if (value.refCount < 1)
			{
				Debug.LogError($"Attempted to update a dynamic texture (index={id.index}) that is not allocated.");
				return;
			}
			value.texture = texture;
			m_Textures[id.index] = value;
		}

		private TextureId AllocAndAcquire(Texture texture, bool dynamic)
		{
			TextureInfo textureInfo = new TextureInfo
			{
				texture = texture,
				dynamic = dynamic,
				refCount = 1
			};
			TextureId textureId;
			if (m_FreeIds.Count > 0)
			{
				textureId = m_FreeIds.Pop();
				m_Textures[textureId.index] = textureInfo;
			}
			else
			{
				if (m_Textures.Count == 2048)
				{
					Debug.LogError(string.Format("Failed to allocate a {0} because the limit of {1} textures is reached.", "TextureId", 2048));
					return TextureId.invalid;
				}
				textureId = new TextureId(m_Textures.Count);
				m_Textures.Add(textureInfo);
			}
			if (!dynamic)
			{
				m_TextureToId[texture] = textureId;
			}
			return textureId;
		}

		public TextureId Acquire(Texture tex)
		{
			if (m_TextureToId.TryGetValue(tex, out var value))
			{
				TextureInfo value2 = m_Textures[value.index];
				Debug.Assert(value2.refCount > 0);
				Debug.Assert(!value2.dynamic);
				value2.refCount++;
				m_Textures[value.index] = value2;
				return value;
			}
			return AllocAndAcquire(tex, dynamic: false);
		}

		public void Acquire(TextureId id)
		{
			if (id.index < 0 || id.index >= m_Textures.Count)
			{
				Debug.LogError($"Attempted to acquire an invalid texture (index={id.index}).");
				return;
			}
			TextureInfo value = m_Textures[id.index];
			if (value.refCount < 1)
			{
				Debug.LogError($"Attempted to acquire a texture (index={id.index}) that is not allocated.");
				return;
			}
			value.refCount++;
			m_Textures[id.index] = value;
		}

		public void Release(TextureId id)
		{
			if (id.index < 0 || id.index >= m_Textures.Count)
			{
				Debug.LogError($"Attempted to release an invalid texture (index={id.index}).");
				return;
			}
			TextureInfo value = m_Textures[id.index];
			if (value.refCount < 1)
			{
				Debug.LogError($"Attempted to release a texture (index={id.index}) that is not allocated.");
				return;
			}
			value.refCount--;
			if (value.refCount == 0)
			{
				if (!value.dynamic)
				{
					m_TextureToId.Remove(value.texture);
				}
				value.texture = null;
				value.dynamic = false;
				m_FreeIds.Push(id);
			}
			m_Textures[id.index] = value;
		}

		public TextureId TextureToId(Texture texture)
		{
			if (m_TextureToId.TryGetValue(texture, out var value))
			{
				return value;
			}
			return TextureId.invalid;
		}

		public Statistics GatherStatistics()
		{
			Statistics result = default(Statistics);
			result.freeIdsCount = m_FreeIds.Count;
			result.createdIdsCount = m_Textures.Count;
			result.allocatedIdsTotalCount = m_Textures.Count - m_FreeIds.Count;
			result.allocatedIdsDynamicCount = result.allocatedIdsTotalCount - m_TextureToId.Count;
			result.allocatedIdsStaticCount = result.allocatedIdsTotalCount - result.allocatedIdsDynamicCount;
			result.availableIdsCount = 2048 - result.allocatedIdsTotalCount;
			return result;
		}
	}
	internal static class UIRUtility
	{
		public static readonly string k_DefaultShaderName = Shaders.k_Runtime;

		public static readonly string k_DefaultWorldSpaceShaderName = Shaders.k_RuntimeWorld;

		public const float k_Epsilon = 1E-30f;

		public const float k_ClearZ = 0.99f;

		public const float k_MeshPosZ = 0f;

		public const float k_MaskPosZ = 1f;

		public const int k_MaxMaskDepth = 7;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool ShapeWindingIsClockwise(int maskDepth, int stencilRef)
		{
			Debug.Assert(maskDepth == stencilRef || maskDepth == stencilRef + 1);
			return maskDepth == stencilRef;
		}

		public static Vector4 ToVector4(Rect rc)
		{
			return new Vector4(rc.xMin, rc.yMin, rc.xMax, rc.yMax);
		}

		public static bool IsRoundRect(VisualElement ve)
		{
			IResolvedStyle resolvedStyle = ve.resolvedStyle;
			return !(resolvedStyle.borderTopLeftRadius < 1E-30f) || !(resolvedStyle.borderTopRightRadius < 1E-30f) || !(resolvedStyle.borderBottomLeftRadius < 1E-30f) || !(resolvedStyle.borderBottomRightRadius < 1E-30f);
		}

		public static void Multiply2D(this Quaternion rotation, ref Vector2 point)
		{
			float num = rotation.z * 2f;
			float num2 = 1f - rotation.z * num;
			float num3 = rotation.w * num;
			point = new Vector2(num2 * point.x - num3 * point.y, num3 * point.x + num2 * point.y);
		}

		public static bool IsVectorImageBackground(VisualElement ve)
		{
			return ve.computedStyle.backgroundImage.vectorImage != null;
		}

		public static bool IsElementSelfHidden(VisualElement ve)
		{
			return ve.resolvedStyle.visibility == Visibility.Hidden;
		}

		public static void Destroy(Object obj)
		{
			if (!(obj == null))
			{
				if (Application.isPlaying)
				{
					Object.Destroy(obj);
				}
				else
				{
					Object.DestroyImmediate(obj);
				}
			}
		}

		public static int GetPrevPow2(int n)
		{
			int num = 0;
			while (n > 1)
			{
				n >>= 1;
				num++;
			}
			return 1 << num;
		}

		public static int GetNextPow2(int n)
		{
			int num;
			for (num = 1; num < n; num <<= 1)
			{
			}
			return num;
		}

		public static int GetNextPow2Exp(int n)
		{
			int num = 1;
			int num2 = 0;
			while (num < n)
			{
				num <<= 1;
				num2++;
			}
			return num2;
		}
	}
	public struct TimerState : IEquatable<TimerState>
	{
		public long start { get; set; }

		public long now { get; set; }

		public long deltaTime => now - start;

		public override bool Equals(object obj)
		{
			return obj is TimerState && Equals((TimerState)obj);
		}

		public bool Equals(TimerState other)
		{
			return start == other.start && now == other.now && deltaTime == other.deltaTime;
		}

		public override int GetHashCode()
		{
			int num = 540054806;
			num = num * -1521134295 + start.GetHashCode();
			num = num * -1521134295 + now.GetHashCode();
			return num * -1521134295 + deltaTime.GetHashCode();
		}

		public static bool operator ==(TimerState state1, TimerState state2)
		{
			return state1.Equals(state2);
		}

		public static bool operator !=(TimerState state1, TimerState state2)
		{
			return !(state1 == state2);
		}
	}
	internal interface IScheduler
	{
		ScheduledItem ScheduleOnce(Action<TimerState> timerUpdateEvent, long delayMs);

		ScheduledItem ScheduleUntil(Action<TimerState> timerUpdateEvent, long delayMs, long intervalMs, Func<bool> stopCondition = null);

		ScheduledItem ScheduleForDuration(Action<TimerState> timerUpdateEvent, long delayMs, long intervalMs, long durationMs);

		void Unschedule(ScheduledItem item);

		void Schedule(ScheduledItem item);

		void UpdateScheduledEvents();
	}
	internal abstract class ScheduledItem
	{
		public Func<bool> timerUpdateStopCondition;

		public static readonly Func<bool> OnceCondition = () => true;

		public static readonly Func<bool> ForeverCondition = () => false;

		public long startMs { get; set; }

		public long delayMs { get; set; }

		public long intervalMs { get; set; }

		public long endTimeMs { get; private set; }

		public ScheduledItem()
		{
			ResetStartTime();
			timerUpdateStopCondition = OnceCondition;
		}

		protected void ResetStartTime()
		{
			startMs = Panel.TimeSinceStartupMs();
		}

		public void SetDuration(long durationMs)
		{
			endTimeMs = startMs + durationMs;
		}

		public abstract void PerformTimerUpdate(TimerState state);

		internal virtual void OnItemUnscheduled()
		{
		}

		public virtual bool ShouldUnschedule()
		{
			if (timerUpdateStopCondition != null)
			{
				return timerUpdateStopCondition();
			}
			return false;
		}
	}
	internal class TimerEventScheduler : IScheduler
	{
		private class TimerEventSchedulerItem : ScheduledItem
		{
			private readonly Action<TimerState> m_TimerUpdateEvent;

			public TimerEventSchedulerItem(Action<TimerState> updateEvent)
			{
				m_TimerUpdateEvent = updateEvent;
			}

			public override void PerformTimerUpdate(TimerState state)
			{
				m_TimerUpdateEvent?.Invoke(state);
			}

			public override string ToString()
			{
				return m_TimerUpdateEvent.ToString();
			}
		}

		private readonly List<ScheduledItem> m_ScheduledItems = new List<ScheduledItem>();

		private bool m_TransactionMode;

		private readonly List<ScheduledItem> m_ScheduleTransactions = new List<ScheduledItem>();

		private readonly HashSet<ScheduledItem> m_UnscheduleTransactions = new HashSet<ScheduledItem>();

		internal bool disableThrottling = false;

		private int m_LastUpdatedIndex = -1;

		public void Schedule(ScheduledItem item)
		{
			if (item == null)
			{
				return;
			}
			if (item == null)
			{
				throw new NotSupportedException("Scheduled Item type is not supported by this scheduler");
			}
			if (m_TransactionMode)
			{
				if (!m_UnscheduleTransactions.Remove(item))
				{
					if (m_ScheduledItems.Contains(item) || m_ScheduleTransactions.Contains(item))
					{
						throw new ArgumentException(string.Concat("Cannot schedule function ", item, " more than once"));
					}
					m_ScheduleTransactions.Add(item);
				}
			}
			else
			{
				if (m_ScheduledItems.Contains(item))
				{
					throw new ArgumentException(string.Concat("Cannot schedule function ", item, " more than once"));
				}
				m_ScheduledItems.Add(item);
			}
		}

		public ScheduledItem ScheduleOnce(Action<TimerState> timerUpdateEvent, long delayMs)
		{
			TimerEventSchedulerItem timerEventSchedulerItem = new TimerEventSchedulerItem(timerUpdateEvent)
			{
				delayMs = delayMs
			};
			Schedule(timerEventSchedulerItem);
			return timerEventSchedulerItem;
		}

		public ScheduledItem ScheduleUntil(Action<TimerState> timerUpdateEvent, long delayMs, long intervalMs, Func<bool> stopCondition)
		{
			TimerEventSchedulerItem timerEventSchedulerItem = new TimerEventSchedulerItem(timerUpdateEvent)
			{
				delayMs = delayMs,
				intervalMs = intervalMs,
				timerUpdateStopCondition = stopCondition
			};
			Schedule(timerEventSchedulerItem);
			return timerEventSchedulerItem;
		}

		public ScheduledItem ScheduleForDuration(Action<TimerState> timerUpdateEvent, long delayMs, long intervalMs, long durationMs)
		{
			TimerEventSchedulerItem timerEventSchedulerItem = new TimerEventSchedulerItem(timerUpdateEvent)
			{
				delayMs = delayMs,
				intervalMs = intervalMs,
				timerUpdateStopCondition = null
			};
			timerEventSchedulerItem.SetDuration(durationMs);
			Schedule(timerEventSchedulerItem);
			return timerEventSchedulerItem;
		}

		private bool RemovedScheduledItemAt(int index)
		{
			if (index >= 0)
			{
				if (index <= m_LastUpdatedIndex)
				{
					m_LastUpdatedIndex--;
				}
				m_ScheduledItems.RemoveAt(index);
				return true;
			}
			return false;
		}

		public void Unschedule(ScheduledItem item)
		{
			if (item == null)
			{
				return;
			}
			if (m_TransactionMode)
			{
				if (m_UnscheduleTransactions.Contains(item))
				{
					throw new ArgumentException("Cannot unschedule scheduled function twice" + item);
				}
				if (!m_ScheduleTransactions.Remove(item))
				{
					if (!m_ScheduledItems.Contains(item))
					{
						throw new ArgumentException("Cannot unschedule unknown scheduled function " + item);
					}
					m_UnscheduleTransactions.Add(item);
				}
			}
			else if (!PrivateUnSchedule(item))
			{
				throw new ArgumentException("Cannot unschedule unknown scheduled function " + item);
			}
			item.OnItemUnscheduled();
		}

		private bool PrivateUnSchedule(ScheduledItem sItem)
		{
			return m_ScheduleTransactions.Remove(sItem) || RemovedScheduledItemAt(m_ScheduledItems.IndexOf(sItem));
		}

		public void UpdateScheduledEvents()
		{
			try
			{
				m_TransactionMode = true;
				long num = Panel.TimeSinceStartupMs();
				int count = m_ScheduledItems.Count;
				int num2 = m_LastUpdatedIndex + 1;
				if (num2 >= count)
				{
					num2 = 0;
				}
				for (int i = 0; i < count; i++)
				{
					int num3 = num2 + i;
					if (num3 >= count)
					{
						num3 -= count;
					}
					ScheduledItem scheduledItem = m_ScheduledItems[num3];
					bool flag = false;
					if (num - scheduledItem.delayMs >= scheduledItem.startMs)
					{
						TimerState state = new TimerState
						{
							start = scheduledItem.startMs,
							now = num
						};
						if (!m_UnscheduleTransactions.Contains(scheduledItem))
						{
							scheduledItem.PerformTimerUpdate(state);
						}
						scheduledItem.startMs = num;
						scheduledItem.delayMs = scheduledItem.intervalMs;
						if (scheduledItem.ShouldUnschedule())
						{
							flag = true;
						}
					}
					if ((flag || (scheduledItem.endTimeMs > 0 && num > scheduledItem.endTimeMs)) && !m_UnscheduleTransactions.Contains(scheduledItem))
					{
						Unschedule(scheduledItem);
					}
					m_LastUpdatedIndex = num3;
				}
			}
			finally
			{
				m_TransactionMode = false;
				foreach (ScheduledItem unscheduleTransaction in m_UnscheduleTransactions)
				{
					PrivateUnSchedule(unscheduleTransaction);
				}
				m_UnscheduleTransactions.Clear();
				foreach (ScheduledItem scheduleTransaction in m_ScheduleTransactions)
				{
					Schedule(scheduleTransaction);
				}
				m_ScheduleTransactions.Clear();
			}
		}
	}
	internal struct Spacing
	{
		public float left;

		public float top;

		public float right;

		public float bottom;

		public float horizontal => left + right;

		public float vertical => top + bottom;

		public Spacing(float left, float top, float right, float bottom)
		{
			this.left = left;
			this.top = top;
			this.right = right;
			this.bottom = bottom;
		}

		public static Rect operator +(Rect r, Spacing a)
		{
			r.x -= a.left;
			r.y -= a.top;
			r.width += a.horizontal;
			r.height += a.vertical;
			return r;
		}

		public static Rect operator -(Rect r, Spacing a)
		{
			r.x += a.left;
			r.y += a.top;
			r.width = Mathf.Max(0f, r.width - a.horizontal);
			r.height = Mathf.Max(0f, r.height - a.vertical);
			return r;
		}
	}
	internal static class StringUtils
	{
		public unsafe static int LevenshteinDistance(string s, string t)
		{
			int length = s.Length;
			int length2 = t.Length;
			if (length == 0)
			{
				return length2;
			}
			if (length2 == 0)
			{
				return length;
			}
			int num = length + 1;
			int num2 = length2 + 1;
			int* ptr = stackalloc int[num * num2];
			for (int i = 0; i <= length; i++)
			{
				ptr[num2 * i] = i;
			}
			for (int j = 0; j <= length2; j++)
			{
				ptr[j] = j;
			}
			for (int k = 1; k <= length2; k++)
			{
				for (int l = 1; l <= length; l++)
				{
					if (s[l - 1] == t[k - 1])
					{
						ptr[num2 * l + k] = ptr[num2 * (l - 1) + k - 1];
					}
					else
					{
						ptr[num2 * l + k] = Math.Min(Math.Min(ptr[num2 * (l - 1) + k] + 1, ptr[num2 * l + k - 1] + 1), ptr[num2 * (l - 1) + k - 1] + 1);
					}
				}
			}
			return ptr[num2 * length + length2];
		}
	}
	internal static class StringUtilsExtensions
	{
		private static readonly char NoDelimiter = '\0';

		private static readonly char[] WordDelimiters = new char[3] { ' ', '-', '_' };

		public static string ToPascalCase(this string text)
		{
			return ConvertCase(text, NoDelimiter, char.ToUpperInvariant, char.ToUpperInvariant);
		}

		public static string ToCamelCase(this string text)
		{
			return ConvertCase(text, NoDelimiter, char.ToLowerInvariant, char.ToUpperInvariant);
		}

		public static string ToKebabCase(this string text)
		{
			return ConvertCase(text, '-', char.ToLowerInvariant, char.ToLowerInvariant);
		}

		public static string ToTrainCase(this string text)
		{
			return ConvertCase(text, '-', char.ToUpperInvariant, char.ToUpperInvariant);
		}

		public static string ToSnakeCase(this string text)
		{
			return ConvertCase(text, '_', char.ToLowerInvariant, char.ToLowerInvariant);
		}

		private static string ConvertCase(string text, char outputWordDelimiter, Func<char, char> startOfStringCaseHandler, Func<char, char> middleStringCaseHandler)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = true;
			bool flag2 = true;
			bool flag3 = true;
			foreach (char c in text)
			{
				if (WordDelimiters.Contains(c))
				{
					if (c == outputWordDelimiter)
					{
						stringBuilder.Append(outputWordDelimiter);
						flag3 = false;
					}
					flag2 = true;
				}
				else if (!char.IsLetterOrDigit(c))
				{
					flag = true;
					flag2 = true;
				}
				else if (flag2 || char.IsUpper(c))
				{
					if (flag)
					{
						stringBuilder.Append(startOfStringCaseHandler(c));
					}
					else
					{
						if (flag3 && outputWordDelimiter != NoDelimiter)
						{
							stringBuilder.Append(outputWordDelimiter);
						}
						stringBuilder.Append(middleStringCaseHandler(c));
						flag3 = true;
					}
					flag = false;
					flag2 = false;
				}
				else
				{
					stringBuilder.Append(c);
				}
			}
			return stringBuilder.ToString();
		}

		public static bool EndsWithIgnoreCaseFast(this string a, string b)
		{
			int num = a.Length - 1;
			int num2 = b.Length - 1;
			CultureInfo invariantCulture = CultureInfo.InvariantCulture;
			while (num >= 0 && num2 >= 0 && (a[num] == b[num2] || char.ToLower(a[num], invariantCulture) == char.ToLower(b[num2], invariantCulture)))
			{
				num--;
				num2--;
			}
			return num2 < 0;
		}

		public static bool StartsWithIgnoreCaseFast(this string a, string b)
		{
			int length = a.Length;
			int length2 = b.Length;
			int num = 0;
			int num2 = 0;
			CultureInfo invariantCulture = CultureInfo.InvariantCulture;
			while (num < length && num2 < length2 && (a[num] == b[num2] || char.ToLower(a[num], invariantCulture) == char.ToLower(b[num2], invariantCulture)))
			{
				num++;
				num2++;
			}
			return num2 == length2;
		}
	}
	public enum AngleUnit
	{
		Degree,
		Gradian,
		Radian,
		Turn
	}
	public struct Angle : IEquatable<Angle>
	{
		private enum Unit
		{
			Degree,
			Gradian,
			Radian,
			Turn,
			None
		}

		private float m_Value;

		private Unit m_Unit;

		public float value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = value;
			}
		}

		public AngleUnit unit
		{
			get
			{
				return (AngleUnit)m_Unit;
			}
			set
			{
				m_Unit = (Unit)value;
			}
		}

		public static Angle Degrees(float value)
		{
			return new Angle(value, AngleUnit.Degree);
		}

		public static Angle Gradians(float value)
		{
			return new Angle(value, AngleUnit.Gradian);
		}

		public static Angle Radians(float value)
		{
			return new Angle(value, AngleUnit.Radian);
		}

		public static Angle Turns(float value)
		{
			return new Angle(value, AngleUnit.Turn);
		}

		internal static Angle None()
		{
			return new Angle(0f, Unit.None);
		}

		internal bool IsNone()
		{
			return m_Unit == Unit.None;
		}

		public Angle(float value)
			: this(value, Unit.Degree)
		{
		}

		public Angle(float value, AngleUnit unit)
			: this(value, (Unit)unit)
		{
		}

		private Angle(float value, Unit unit)
		{
			m_Value = value;
			m_Unit = unit;
		}

		public float ToDegrees()
		{
			return m_Unit switch
			{
				Unit.Degree => m_Value, 
				Unit.Gradian => m_Value * 360f / 400f, 
				Unit.Radian => m_Value * 180f / MathF.PI, 
				Unit.Turn => m_Value * 360f, 
				Unit.None => 0f, 
				_ => 0f, 
			};
		}

		public float ToGradians()
		{
			return m_Unit switch
			{
				Unit.Degree => m_Value * 10f / 9f, 
				Unit.Gradian => m_Value, 
				Unit.Radian => m_Value * 200f / MathF.PI, 
				Unit.Turn => m_Value * 400f, 
				Unit.None => 0f, 
				_ => 0f, 
			};
		}

		public float ToRadians()
		{
			return m_Unit switch
			{
				Unit.Degree => m_Value * MathF.PI / 180f, 
				Unit.Gradian => m_Value * MathF.PI / 200f, 
				Unit.Radian => m_Value, 
				Unit.Turn => m_Value * MathF.PI * 2f, 
				Unit.None => 0f, 
				_ => 0f, 
			};
		}

		public float ToTurns()
		{
			return m_Unit switch
			{
				Unit.Degree => m_Value / 360f, 
				Unit.Gradian => m_Value / 400f, 
				Unit.Radian => m_Value / (MathF.PI * 2f), 
				Unit.Turn => m_Value, 
				Unit.None => 0f, 
				_ => 0f, 
			};
		}

		internal void ConvertTo(AngleUnit newUnit)
		{
			if (1 == 0)
			{
			}
			float num = newUnit switch
			{
				AngleUnit.Degree => ToDegrees(), 
				AngleUnit.Turn => ToTurns(), 
				AngleUnit.Radian => ToRadians(), 
				AngleUnit.Gradian => ToGradians(), 
				_ => throw new NotImplementedException(), 
			};
			if (1 == 0)
			{
			}
			m_Value = num;
			m_Unit = (Unit)newUnit;
		}

		public static implicit operator Angle(float value)
		{
			return new Angle(value, AngleUnit.Degree);
		}

		public static bool operator ==(Angle lhs, Angle rhs)
		{
			return lhs.m_Value == rhs.m_Value && lhs.m_Unit == rhs.m_Unit;
		}

		public static bool operator !=(Angle lhs, Angle rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(Angle other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is Angle other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value.GetHashCode() * 397) ^ (int)m_Unit;
		}

		public override string ToString()
		{
			string text = value.ToString(CultureInfo.InvariantCulture.NumberFormat);
			string text2 = string.Empty;
			switch (m_Unit)
			{
			case Unit.Degree:
				if (!Mathf.Approximately(0f, value))
				{
					text2 = "deg";
				}
				break;
			case Unit.Gradian:
				text2 = "grad";
				break;
			case Unit.Radian:
				text2 = "rad";
				break;
			case Unit.Turn:
				text2 = "turn";
				break;
			case Unit.None:
				text = "";
				break;
			}
			return text + text2;
		}
	}
	public struct Background : IEquatable<Background>
	{
		private Texture2D m_Texture;

		private Sprite m_Sprite;

		private RenderTexture m_RenderTexture;

		private VectorImage m_VectorImage;

		public Texture2D texture
		{
			get
			{
				return m_Texture;
			}
			set
			{
				if (!(m_Texture == value))
				{
					m_Texture = value;
					m_Sprite = null;
					m_RenderTexture = null;
					m_VectorImage = null;
				}
			}
		}

		public Sprite sprite
		{
			get
			{
				return m_Sprite;
			}
			set
			{
				if (!(m_Sprite == value))
				{
					m_Texture = null;
					m_Sprite = value;
					m_RenderTexture = null;
					m_VectorImage = null;
				}
			}
		}

		public RenderTexture renderTexture
		{
			get
			{
				return m_RenderTexture;
			}
			set
			{
				if (!(m_RenderTexture == value))
				{
					m_Texture = null;
					m_Sprite = null;
					m_RenderTexture = value;
					m_VectorImage = null;
				}
			}
		}

		public VectorImage vectorImage
		{
			get
			{
				return m_VectorImage;
			}
			set
			{
				if (!(vectorImage == value))
				{
					m_Texture = null;
					m_Sprite = null;
					m_RenderTexture = null;
					m_VectorImage = value;
				}
			}
		}

		internal static IEnumerable<Type> allowedAssetTypes
		{
			get
			{
				yield return typeof(Texture2D);
				yield return typeof(RenderTexture);
				yield return typeof(Sprite);
				yield return typeof(VectorImage);
			}
		}

		[Obsolete("Use Background.FromTexture2D instead")]
		public Background(Texture2D t)
		{
			m_Texture = t;
			m_Sprite = null;
			m_RenderTexture = null;
			m_VectorImage = null;
		}

		public static Background FromTexture2D(Texture2D t)
		{
			return new Background
			{
				texture = t
			};
		}

		public static Background FromRenderTexture(RenderTexture rt)
		{
			return new Background
			{
				renderTexture = rt
			};
		}

		public static Background FromSprite(Sprite s)
		{
			return new Background
			{
				sprite = s
			};
		}

		public static Background FromVectorImage(VectorImage vi)
		{
			return new Background
			{
				vectorImage = vi
			};
		}

		internal static Background FromObject(object obj)
		{
			Texture2D texture2D = obj as Texture2D;
			if (texture2D != null)
			{
				return FromTexture2D(texture2D);
			}
			RenderTexture renderTexture = obj as RenderTexture;
			if (renderTexture != null)
			{
				return FromRenderTexture(renderTexture);
			}
			Sprite sprite = obj as Sprite;
			if (sprite != null)
			{
				return FromSprite(sprite);
			}
			VectorImage vectorImage = obj as VectorImage;
			if (vectorImage != null)
			{
				return FromVectorImage(vectorImage);
			}
			return default(Background);
		}

		public static bool operator ==(Background lhs, Background rhs)
		{
			return lhs.texture == rhs.texture && lhs.sprite == rhs.sprite && lhs.renderTexture == rhs.renderTexture && lhs.vectorImage == rhs.vectorImage;
		}

		public static bool operator !=(Background lhs, Background rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator Background(Texture2D v)
		{
			return FromTexture2D(v);
		}

		public bool Equals(Background other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is Background background))
			{
				return false;
			}
			return background == this;
		}

		public override int GetHashCode()
		{
			int num = 851985039;
			if ((object)texture != null)
			{
				num = num * -1521134295 + texture.GetHashCode();
			}
			if ((object)sprite != null)
			{
				num = num * -1521134295 + sprite.GetHashCode();
			}
			if ((object)renderTexture != null)
			{
				num = num * -1521134295 + renderTexture.GetHashCode();
			}
			if ((object)vectorImage != null)
			{
				num = num * -1521134295 + vectorImage.GetHashCode();
			}
			return num;
		}

		public override string ToString()
		{
			if (texture != null)
			{
				return texture.ToString();
			}
			if (sprite != null)
			{
				return sprite.ToString();
			}
			if (renderTexture != null)
			{
				return renderTexture.ToString();
			}
			if (vectorImage != null)
			{
				return vectorImage.ToString();
			}
			return "";
		}
	}
	internal struct ComputedStyle
	{
		public StyleDataRef<InheritedData> inheritedData;

		public StyleDataRef<LayoutData> layoutData;

		public StyleDataRef<RareData> rareData;

		public StyleDataRef<TransformData> transformData;

		public StyleDataRef<TransitionData> transitionData;

		public StyleDataRef<VisualData> visualData;

		public YogaNode yogaNode;

		public Dictionary<string, StylePropertyValue> customProperties;

		public long matchingRulesHash;

		public float dpiScaling;

		public ComputedTransitionProperty[] computedTransitions;

		public int customPropertiesCount => customProperties?.Count ?? 0;

		public bool hasTransition
		{
			get
			{
				ComputedTransitionProperty[] array = computedTransitions;
				return array != null && array.Length != 0;
			}
		}

		public Align alignContent => layoutData.Read().alignContent;

		public Align alignItems => layoutData.Read().alignItems;

		public Align alignSelf => layoutData.Read().alignSelf;

		public Color backgroundColor => visualData.Read().backgroundColor;

		public Background backgroundImage => visualData.Read().backgroundImage;

		public BackgroundPosition backgroundPositionX => visualData.Read().backgroundPositionX;

		public BackgroundPosition backgroundPositionY => visualData.Read().backgroundPositionY;

		public BackgroundRepeat backgroundRepeat => visualData.Read().backgroundRepeat;

		public BackgroundSize backgroundSize => visualData.Read().backgroundSize;

		public Color borderBottomColor => visualData.Read().borderBottomColor;

		public Length borderBottomLeftRadius => visualData.Read().borderBottomLeftRadius;

		public Length borderBottomRightRadius => visualData.Read().borderBottomRightRadius;

		public float borderBottomWidth => layoutData.Read().borderBottomWidth;

		public Color borderLeftColor => visualData.Read().borderLeftColor;

		public float borderLeftWidth => layoutData.Read().borderLeftWidth;

		public Color borderRightColor => visualData.Read().borderRightColor;

		public float borderRightWidth => layoutData.Read().borderRightWidth;

		public Color borderTopColor => visualData.Read().borderTopColor;

		public Length borderTopLeftRadius => visualData.Read().borderTopLeftRadius;

		public Length borderTopRightRadius => visualData.Read().borderTopRightRadius;

		public float borderTopWidth => layoutData.Read().borderTopWidth;

		public Length bottom => layoutData.Read().bottom;

		public Color color => inheritedData.Read().color;

		public Cursor cursor => rareData.Read().cursor;

		public DisplayStyle display => layoutData.Read().display;

		public Length flexBasis => layoutData.Read().flexBasis;

		public FlexDirection flexDirection => layoutData.Read().flexDirection;

		public float flexGrow => layoutData.Read().flexGrow;

		public float flexShrink => layoutData.Read().flexShrink;

		public Wrap flexWrap => layoutData.Read().flexWrap;

		public Length fontSize => inheritedData.Read().fontSize;

		public Length height => layoutData.Read().height;

		public Justify justifyContent => layoutData.Read().justifyContent;

		public Length left => layoutData.Read().left;

		public Length letterSpacing => inheritedData.Read().letterSpacing;

		public Length marginBottom => layoutData.Read().marginBottom;

		public Length marginLeft => layoutData.Read().marginLeft;

		public Length marginRight => layoutData.Read().marginRight;

		public Length marginTop => layoutData.Read().marginTop;

		public Length maxHeight => layoutData.Read().maxHeight;

		public Length maxWidth => layoutData.Read().maxWidth;

		public Length minHeight => layoutData.Read().minHeight;

		public Length minWidth => layoutData.Read().minWidth;

		public float opacity => visualData.Read().opacity;

		public OverflowInternal overflow => visualData.Read().overflow;

		public Length paddingBottom => layoutData.Read().paddingBottom;

		public Length paddingLeft => layoutData.Read().paddingLeft;

		public Length paddingRight => layoutData.Read().paddingRight;

		public Length paddingTop => layoutData.Read().paddingTop;

		public Position position => layoutData.Read().position;

		public Length right => layoutData.Read().right;

		public Rotate rotate => transformData.Read().rotate;

		public Scale scale => transformData.Read().scale;

		public TextOverflow textOverflow => rareData.Read().textOverflow;

		public TextShadow textShadow => inheritedData.Read().textShadow;

		public Length top => layoutData.Read().top;

		public TransformOrigin transformOrigin => transformData.Read().transformOrigin;

		public List<TimeValue> transitionDelay => transitionData.Read().transitionDelay;

		public List<TimeValue> transitionDuration => transitionData.Read().transitionDuration;

		public List<StylePropertyName> transitionProperty => transitionData.Read().transitionProperty;

		public List<EasingFunction> transitionTimingFunction => transitionData.Read().transitionTimingFunction;

		public Translate translate => transformData.Read().translate;

		public Color unityBackgroundImageTintColor => rareData.Read().unityBackgroundImageTintColor;

		public Font unityFont => inheritedData.Read().unityFont;

		public FontDefinition unityFontDefinition => inheritedData.Read().unityFontDefinition;

		public FontStyle unityFontStyleAndWeight => inheritedData.Read().unityFontStyleAndWeight;

		public OverflowClipBox unityOverflowClipBox => rareData.Read().unityOverflowClipBox;

		public Length unityParagraphSpacing => inheritedData.Read().unityParagraphSpacing;

		public int unitySliceBottom => rareData.Read().unitySliceBottom;

		public int unitySliceLeft => rareData.Read().unitySliceLeft;

		public int unitySliceRight => rareData.Read().unitySliceRight;

		public float unitySliceScale => rareData.Read().unitySliceScale;

		public int unitySliceTop => rareData.Read().unitySliceTop;

		public TextAnchor unityTextAlign => inheritedData.Read().unityTextAlign;

		public Color unityTextOutlineColor => inheritedData.Read().unityTextOutlineColor;

		public float unityTextOutlineWidth => inheritedData.Read().unityTextOutlineWidth;

		public TextOverflowPosition unityTextOverflowPosition => rareData.Read().unityTextOverflowPosition;

		public Visibility visibility => inheritedData.Read().visibility;

		public WhiteSpace whiteSpace => inheritedData.Read().whiteSpace;

		public Length width => layoutData.Read().width;

		public Length wordSpacing => inheritedData.Read().wordSpacing;

		public static ComputedStyle Create()
		{
			return InitialStyle.Acquire();
		}

		public void FinalizeApply(ref ComputedStyle parentStyle)
		{
			if (yogaNode == null)
			{
				yogaNode = new YogaNode();
			}
			if (fontSize.unit == LengthUnit.Percent)
			{
				float value = parentStyle.fontSize.value;
				float value2 = value * fontSize.value / 100f;
				inheritedData.Write().fontSize = new Length(value2);
			}
			SyncWithLayout(yogaNode);
		}

		public void SyncWithLayout(YogaNode targetNode)
		{
			targetNode.Flex = float.NaN;
			targetNode.FlexGrow = flexGrow;
			targetNode.FlexShrink = flexShrink;
			targetNode.FlexBasis = flexBasis.ToYogaValue();
			targetNode.Left = left.ToYogaValue();
			targetNode.Top = top.ToYogaValue();
			targetNode.Right = right.ToYogaValue();
			targetNode.Bottom = bottom.ToYogaValue();
			targetNode.MarginLeft = marginLeft.ToYogaValue();
			targetNode.MarginTop = marginTop.ToYogaValue();
			targetNode.MarginRight = marginRight.ToYogaValue();
			targetNode.MarginBottom = marginBottom.ToYogaValue();
			targetNode.PaddingLeft = paddingLeft.ToYogaValue();
			targetNode.PaddingTop = paddingTop.ToYogaValue();
			targetNode.PaddingRight = paddingRight.ToYogaValue();
			targetNode.PaddingBottom = paddingBottom.ToYogaValue();
			targetNode.BorderLeftWidth = borderLeftWidth;
			targetNode.BorderTopWidth = borderTopWidth;
			targetNode.BorderRightWidth = borderRightWidth;
			targetNode.BorderBottomWidth = borderBottomWidth;
			targetNode.Width = width.ToYogaValue();
			targetNode.Height = height.ToYogaValue();
			targetNode.PositionType = (YogaPositionType)position;
			targetNode.Overflow = (YogaOverflow)overflow;
			targetNode.AlignSelf = (YogaAlign)alignSelf;
			targetNode.MaxWidth = maxWidth.ToYogaValue();
			targetNode.MaxHeight = maxHeight.ToYogaValue();
			targetNode.MinWidth = minWidth.ToYogaValue();
			targetNode.MinHeight = minHeight.ToYogaValue();
			targetNode.FlexDirection = (YogaFlexDirection)flexDirection;
			targetNode.AlignContent = (YogaAlign)alignContent;
			targetNode.AlignItems = (YogaAlign)alignItems;
			targetNode.JustifyContent = (YogaJustify)justifyContent;
			targetNode.Wrap = (YogaWrap)flexWrap;
			targetNode.Display = (YogaDisplay)display;
		}

		private bool ApplyGlobalKeyword(StylePropertyReader reader, ref ComputedStyle parentStyle)
		{
			StyleValueHandle handle = reader.GetValue(0).handle;
			if (handle.valueType == StyleValueType.Keyword)
			{
				switch ((StyleValueKeyword)handle.valueIndex)
				{
				case StyleValueKeyword.Initial:
					ApplyInitialValue(reader);
					return true;
				case StyleValueKeyword.Unset:
					ApplyUnsetValue(reader, ref parentStyle);
					return true;
				}
			}
			return false;
		}

		private bool ApplyGlobalKeyword(StylePropertyId id, StyleKeyword keyword, ref ComputedStyle parentStyle)
		{
			if (keyword == StyleKeyword.Initial)
			{
				ApplyInitialValue(id);
				return true;
			}
			return false;
		}

		private void RemoveCustomStyleProperty(StylePropertyReader reader)
		{
			string name = reader.property.name;
			if (customProperties != null && customProperties.ContainsKey(name))
			{
				customProperties.Remove(name);
			}
		}

		private void ApplyCustomStyleProperty(StylePropertyReader reader)
		{
			dpiScaling = reader.dpiScaling;
			if (customProperties == null)
			{
				customProperties = new Dictionary<string, StylePropertyValue>();
			}
			StyleProperty property = reader.property;
			StylePropertyValue value = reader.GetValue(0);
			customProperties[property.name] = value;
		}

		private void ApplyAllPropertyInitial()
		{
			CopyFrom(ref InitialStyle.Get());
		}

		private void ResetComputedTransitions()
		{
			computedTransitions = null;
		}

		public static bool StartAnimationInlineTextShadow(VisualElement element, ref ComputedStyle computedStyle, StyleTextShadow textShadow, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			TextShadow to = ((textShadow.keyword == StyleKeyword.Initial) ? InitialStyle.textShadow : textShadow.value);
			return element.styleAnimation.Start(StylePropertyId.TextShadow, computedStyle.inheritedData.Read().textShadow, to, durationMs, delayMs, easingCurve);
		}

		public static bool StartAnimationInlineRotate(VisualElement element, ref ComputedStyle computedStyle, StyleRotate rotate, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			Rotate to = ((rotate.keyword == StyleKeyword.Initial) ? InitialStyle.rotate : rotate.value);
			bool flag = element.styleAnimation.Start(StylePropertyId.Rotate, computedStyle.transformData.Read().rotate, to, durationMs, delayMs, easingCurve);
			if (flag && (element.usageHints & UsageHints.DynamicTransform) == 0)
			{
				element.usageHints |= UsageHints.DynamicTransform;
			}
			return flag;
		}

		public static bool StartAnimationInlineTranslate(VisualElement element, ref ComputedStyle computedStyle, StyleTranslate translate, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			Translate to = ((translate.keyword == StyleKeyword.Initial) ? InitialStyle.translate : translate.value);
			bool flag = element.styleAnimation.Start(StylePropertyId.Translate, computedStyle.transformData.Read().translate, to, durationMs, delayMs, easingCurve);
			if (flag && (element.usageHints & UsageHints.DynamicTransform) == 0)
			{
				element.usageHints |= UsageHints.DynamicTransform;
			}
			return flag;
		}

		public static bool StartAnimationInlineScale(VisualElement element, ref ComputedStyle computedStyle, StyleScale scale, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			Scale to = ((scale.keyword == StyleKeyword.Initial) ? InitialStyle.scale : scale.value);
			bool flag = element.styleAnimation.Start(StylePropertyId.Scale, computedStyle.transformData.Read().scale, to, durationMs, delayMs, easingCurve);
			if (flag && (element.usageHints & UsageHints.DynamicTransform) == 0)
			{
				element.usageHints |= UsageHints.DynamicTransform;
			}
			return flag;
		}

		public static bool StartAnimationInlineTransformOrigin(VisualElement element, ref ComputedStyle computedStyle, StyleTransformOrigin transformOrigin, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			TransformOrigin to = ((transformOrigin.keyword == StyleKeyword.Initial) ? InitialStyle.transformOrigin : transformOrigin.value);
			bool flag = element.styleAnimation.Start(StylePropertyId.TransformOrigin, computedStyle.transformData.Read().transformOrigin, to, durationMs, delayMs, easingCurve);
			if (flag && (element.usageHints & UsageHints.DynamicTransform) == 0)
			{
				element.usageHints |= UsageHints.DynamicTransform;
			}
			return flag;
		}

		public static bool StartAnimationInlineBackgroundSize(VisualElement element, ref ComputedStyle computedStyle, StyleBackgroundSize backgroundSize, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			BackgroundSize to = ((backgroundSize.keyword == StyleKeyword.Initial) ? InitialStyle.backgroundSize : backgroundSize.value);
			return element.styleAnimation.Start(StylePropertyId.BackgroundSize, computedStyle.visualData.Read().backgroundSize, to, durationMs, delayMs, easingCurve);
		}

		public static ComputedStyle Create(ref ComputedStyle parentStyle)
		{
			ref ComputedStyle reference = ref InitialStyle.Get();
			ComputedStyle result = new ComputedStyle
			{
				dpiScaling = 1f
			};
			result.inheritedData = parentStyle.inheritedData.Acquire();
			result.layoutData = reference.layoutData.Acquire();
			result.rareData = reference.rareData.Acquire();
			result.transformData = reference.transformData.Acquire();
			result.transitionData = reference.transitionData.Acquire();
			result.visualData = reference.visualData.Acquire();
			return result;
		}

		public static ComputedStyle CreateInitial()
		{
			ComputedStyle result = new ComputedStyle
			{
				dpiScaling = 1f
			};
			result.inheritedData = StyleDataRef<InheritedData>.Create();
			result.layoutData = StyleDataRef<LayoutData>.Create();
			result.rareData = StyleDataRef<RareData>.Create();
			result.transformData = StyleDataRef<TransformData>.Create();
			result.transitionData = StyleDataRef<TransitionData>.Create();
			result.visualData = StyleDataRef<VisualData>.Create();
			return result;
		}

		public ComputedStyle Acquire()
		{
			inheritedData.Acquire();
			layoutData.Acquire();
			rareData.Acquire();
			transformData.Acquire();
			transitionData.Acquire();
			visualData.Acquire();
			return this;
		}

		public void Release()
		{
			inheritedData.Release();
			layoutData.Release();
			rareData.Release();
			transformData.Release();
			transitionData.Release();
			visualData.Release();
		}

		public void CopyFrom(ref ComputedStyle other)
		{
			inheritedData.CopyFrom(other.inheritedData);
			layoutData.CopyFrom(other.layoutData);
			rareData.CopyFrom(other.rareData);
			transformData.CopyFrom(other.transformData);
			transitionData.CopyFrom(other.transitionData);
			visualData.CopyFrom(other.visualData);
			yogaNode = other.yogaNode;
			customProperties = other.customProperties;
			matchingRulesHash = other.matchingRulesHash;
			dpiScaling = other.dpiScaling;
			computedTransitions = other.computedTransitions;
		}

		public void ApplyProperties(StylePropertyReader reader, ref ComputedStyle parentStyle)
		{
			StylePropertyId stylePropertyId = reader.propertyId;
			while (reader.property != null)
			{
				if (!ApplyGlobalKeyword(reader, ref parentStyle))
				{
					switch (stylePropertyId)
					{
					case StylePropertyId.AlignContent:
						layoutData.Write().alignContent = (Align)reader.ReadEnum(StyleEnumType.Align, 0);
						break;
					case StylePropertyId.AlignItems:
						layoutData.Write().alignItems = (Align)reader.ReadEnum(StyleEnumType.Align, 0);
						break;
					case StylePropertyId.AlignSelf:
						layoutData.Write().alignSelf = (Align)reader.ReadEnum(StyleEnumType.Align, 0);
						break;
					case StylePropertyId.BackgroundColor:
						visualData.Write().backgroundColor = reader.ReadColor(0);
						break;
					case StylePropertyId.BackgroundImage:
						visualData.Write().backgroundImage = reader.ReadBackground(0);
						break;
					case StylePropertyId.BackgroundPosition:
						ShorthandApplicator.ApplyBackgroundPosition(reader, ref this);
						break;
					case StylePropertyId.BackgroundPositionX:
						visualData.Write().backgroundPositionX = reader.ReadBackgroundPositionX(0);
						break;
					case StylePropertyId.BackgroundPositionY:
						visualData.Write().backgroundPositionY = reader.ReadBackgroundPositionY(0);
						break;
					case StylePropertyId.BackgroundRepeat:
						visualData.Write().backgroundRepeat = reader.ReadBackgroundRepeat(0);
						break;
					case StylePropertyId.BackgroundSize:
						visualData.Write().backgroundSize = reader.ReadBackgroundSize(0);
						break;
					case StylePropertyId.BorderBottomColor:
						visualData.Write().borderBottomColor = reader.ReadColor(0);
						break;
					case StylePropertyId.BorderBottomLeftRadius:
						visualData.Write().borderBottomLeftRadius = reader.ReadLength(0);
						break;
					case StylePropertyId.BorderBottomRightRadius:
						visualData.Write().borderBottomRightRadius = reader.ReadLength(0);
						break;
					case StylePropertyId.BorderBottomWidth:
						layoutData.Write().borderBottomWidth = reader.ReadFloat(0);
						break;
					case StylePropertyId.BorderColor:
						ShorthandApplicator.ApplyBorderColor(reader, ref this);
						break;
					case StylePropertyId.BorderLeftColor:
						visualData.Write().borderLeftColor = reader.ReadColor(0);
						break;
					case StylePropertyId.BorderLeftWidth:
						layoutData.Write().borderLeftWidth = reader.ReadFloat(0);
						break;
					case StylePropertyId.BorderRadius:
						ShorthandApplicator.ApplyBorderRadius(reader, ref this);
						break;
					case StylePropertyId.BorderRightColor:
						visualData.Write().borderRightColor = reader.ReadColor(0);
						break;
					case StylePropertyId.BorderRightWidth:
						layoutData.Write().borderRightWidth = reader.ReadFloat(0);
						break;
					case StylePropertyId.BorderTopColor:
						visualData.Write().borderTopColor = reader.ReadColor(0);
						break;
					case StylePropertyId.BorderTopLeftRadius:
						visualData.Write().borderTopLeftRadius = reader.ReadLength(0);
						break;
					case StylePropertyId.BorderTopRightRadius:
						visualData.Write().borderTopRightRadius = reader.ReadLength(0);
						break;
					case StylePropertyId.BorderTopWidth:
						layoutData.Write().borderTopWidth = reader.ReadFloat(0);
						break;
					case StylePropertyId.BorderWidth:
						ShorthandApplicator.ApplyBorderWidth(reader, ref this);
						break;
					case StylePropertyId.Bottom:
						layoutData.Write().bottom = reader.ReadLength(0);
						break;
					case StylePropertyId.Color:
						inheritedData.Write().color = reader.ReadColor(0);
						break;
					case StylePropertyId.Cursor:
						rareData.Write().cursor = reader.ReadCursor(0);
						break;
					case StylePropertyId.Display:
						layoutData.Write().display = (DisplayStyle)reader.ReadEnum(StyleEnumType.DisplayStyle, 0);
						break;
					case StylePropertyId.Flex:
						ShorthandApplicator.ApplyFlex(reader, ref this);
						break;
					case StylePropertyId.FlexBasis:
						layoutData.Write().flexBasis = reader.ReadLength(0);
						break;
					case StylePropertyId.FlexDirection:
						layoutData.Write().flexDirection = (FlexDirection)reader.ReadEnum(StyleEnumType.FlexDirection, 0);
						break;
					case StylePropertyId.FlexGrow:
						layoutData.Write().flexGrow = reader.ReadFloat(0);
						break;
					case StylePropertyId.FlexShrink:
						layoutData.Write().flexShrink = reader.ReadFloat(0);
						break;
					case StylePropertyId.FlexWrap:
						layoutData.Write().flexWrap = (Wrap)reader.ReadEnum(StyleEnumType.Wrap, 0);
						break;
					case StylePropertyId.FontSize:
						inheritedData.Write().fontSize = reader.ReadLength(0);
						break;
					case StylePropertyId.Height:
						layoutData.Write().height = reader.ReadLength(0);
						break;
					case StylePropertyId.JustifyContent:
						layoutData.Write().justifyContent = (Justify)reader.ReadEnum(StyleEnumType.Justify, 0);
						break;
					case StylePropertyId.Left:
						layoutData.Write().left = reader.ReadLength(0);
						break;
					case StylePropertyId.LetterSpacing:
						inheritedData.Write().letterSpacing = reader.ReadLength(0);
						break;
					case StylePropertyId.Margin:
						ShorthandApplicator.ApplyMargin(reader, ref this);
						break;
					case StylePropertyId.MarginBottom:
						layoutData.Write().marginBottom = reader.ReadLength(0);
						break;
					case StylePropertyId.MarginLeft:
						layoutData.Write().marginLeft = reader.ReadLength(0);
						break;
					case StylePropertyId.MarginRight:
						layoutData.Write().marginRight = reader.ReadLength(0);
						break;
					case StylePropertyId.MarginTop:
						layoutData.Write().marginTop = reader.ReadLength(0);
						break;
					case StylePropertyId.MaxHeight:
						layoutData.Write().maxHeight = reader.ReadLength(0);
						break;
					case StylePropertyId.MaxWidth:
						layoutData.Write().maxWidth = reader.ReadLength(0);
						break;
					case StylePropertyId.MinHeight:
						layoutData.Write().minHeight = reader.ReadLength(0);
						break;
					case StylePropertyId.MinWidth:
						layoutData.Write().minWidth = reader.ReadLength(0);
						break;
					case StylePropertyId.Opacity:
						visualData.Write().opacity = reader.ReadFloat(0);
						break;
					case StylePropertyId.Overflow:
						visualData.Write().overflow = (OverflowInternal)reader.ReadEnum(StyleEnumType.OverflowInternal, 0);
						break;
					case StylePropertyId.Padding:
						ShorthandApplicator.ApplyPadding(reader, ref this);
						break;
					case StylePropertyId.PaddingBottom:
						layoutData.Write().paddingBottom = reader.ReadLength(0);
						break;
					case StylePropertyId.PaddingLeft:
						layoutData.Write().paddingLeft = reader.ReadLength(0);
						break;
					case StylePropertyId.PaddingRight:
						layoutData.Write().paddingRight = reader.ReadLength(0);
						break;
					case StylePropertyId.PaddingTop:
						layoutData.Write().paddingTop = reader.ReadLength(0);
						break;
					case StylePropertyId.Position:
						layoutData.Write().position = (Position)reader.ReadEnum(StyleEnumType.Position, 0);
						break;
					case StylePropertyId.Right:
						layoutData.Write().right = reader.ReadLength(0);
						break;
					case StylePropertyId.Rotate:
						transformData.Write().rotate = reader.ReadRotate(0);
						break;
					case StylePropertyId.Scale:
						transformData.Write().scale = reader.ReadScale(0);
						break;
					case StylePropertyId.TextOverflow:
						rareData.Write().textOverflow = (TextOverflow)reader.ReadEnum(StyleEnumType.TextOverflow, 0);
						break;
					case StylePropertyId.TextShadow:
						inheritedData.Write().textShadow = reader.ReadTextShadow(0);
						break;
					case StylePropertyId.Top:
						layoutData.Write().top = reader.ReadLength(0);
						break;
					case StylePropertyId.TransformOrigin:
						transformData.Write().transformOrigin = reader.ReadTransformOrigin(0);
						break;
					case StylePropertyId.Transition:
						ShorthandApplicator.ApplyTransition(reader, ref this);
						break;
					case StylePropertyId.TransitionDelay:
						reader.ReadListTimeValue(transitionData.Write().transitionDelay, 0);
						ResetComputedTransitions();
						break;
					case StylePropertyId.TransitionDuration:
						reader.ReadListTimeValue(transitionData.Write().transitionDuration, 0);
						ResetComputedTransitions();
						break;
					case StylePropertyId.TransitionProperty:
						reader.ReadListStylePropertyName(transitionData.Write().transitionProperty, 0);
						ResetComputedTransitions();
						break;
					case StylePropertyId.TransitionTimingFunction:
						reader.ReadListEasingFunction(transitionData.Write().transitionTimingFunction, 0);
						ResetComputedTransitions();
						break;
					case StylePropertyId.Translate:
						transformData.Write().translate = reader.ReadTranslate(0);
						break;
					case StylePropertyId.UnityBackgroundImageTintColor:
						rareData.Write().unityBackgroundImageTintColor = reader.ReadColor(0);
						break;
					case StylePropertyId.UnityBackgroundScaleMode:
						ShorthandApplicator.ApplyUnityBackgroundScaleMode(reader, ref this);
						break;
					case StylePropertyId.UnityFont:
						inheritedData.Write().unityFont = reader.ReadFont(0);
						break;
					case StylePropertyId.UnityFontDefinition:
						inheritedData.Write().unityFontDefinition = reader.ReadFontDefinition(0);
						break;
					case StylePropertyId.UnityFontStyleAndWeight:
						inheritedData.Write().unityFontStyleAndWeight = (FontStyle)reader.ReadEnum(StyleEnumType.FontStyle, 0);
						break;
					case StylePropertyId.UnityOverflowClipBox:
						rareData.Write().unityOverflowClipBox = (OverflowClipBox)reader.ReadEnum(StyleEnumType.OverflowClipBox, 0);
						break;
					case StylePropertyId.UnityParagraphSpacing:
						inheritedData.Write().unityParagraphSpacing = reader.ReadLength(0);
						break;
					case StylePropertyId.UnitySliceBottom:
						rareData.Write().unitySliceBottom = reader.ReadInt(0);
						break;
					case StylePropertyId.UnitySliceLeft:
						rareData.Write().unitySliceLeft = reader.ReadInt(0);
						break;
					case StylePropertyId.UnitySliceRight:
						rareData.Write().unitySliceRight = reader.ReadInt(0);
						break;
					case StylePropertyId.UnitySliceScale:
						rareData.Write().unitySliceScale = reader.ReadFloat(0);
						break;
					case StylePropertyId.UnitySliceTop:
						rareData.Write().unitySliceTop = reader.ReadInt(0);
						break;
					case StylePropertyId.UnityTextAlign:
						inheritedData.Write().unityTextAlign = (TextAnchor)reader.ReadEnum(StyleEnumType.TextAnchor, 0);
						break;
					case StylePropertyId.UnityTextOutline:
						ShorthandApplicator.ApplyUnityTextOutline(reader, ref this);
						break;
					case StylePropertyId.UnityTextOutlineColor:
						inheritedData.Write().unityTextOutlineColor = reader.ReadColor(0);
						break;
					case StylePropertyId.UnityTextOutlineWidth:
						inheritedData.Write().unityTextOutlineWidth = reader.ReadFloat(0);
						break;
					case StylePropertyId.UnityTextOverflowPosition:
						rareData.Write().unityTextOverflowPosition = (TextOverflowPosition)reader.ReadEnum(StyleEnumType.TextOverflowPosition, 0);
						break;
					case StylePropertyId.Visibility:
						inheritedData.Write().visibility = (Visibility)reader.ReadEnum(StyleEnumType.Visibility, 0);
						break;
					case StylePropertyId.WhiteSpace:
						inheritedData.Write().whiteSpace = (WhiteSpace)reader.ReadEnum(StyleEnumType.WhiteSpace, 0);
						break;
					case StylePropertyId.Width:
						layoutData.Write().width = reader.ReadLength(0);
						break;
					case StylePropertyId.WordSpacing:
						inheritedData.Write().wordSpacing = reader.ReadLength(0);
						break;
					case StylePropertyId.Custom:
						ApplyCustomStyleProperty(reader);
						break;
					default:
						Debug.LogAssertion($"Unknown property id {stylePropertyId}");
						break;
					case StylePropertyId.Unknown:
					case StylePropertyId.All:
						break;
					}
				}
				stylePropertyId = reader.MoveNextProperty();
			}
		}

		public void ApplyStyleValue(StyleValue sv, ref ComputedStyle parentStyle)
		{
			if (ApplyGlobalKeyword(sv.id, sv.keyword, ref parentStyle))
			{
				return;
			}
			switch (sv.id)
			{
			case StylePropertyId.AlignContent:
				layoutData.Write().alignContent = (Align)sv.number;
				if (sv.keyword == StyleKeyword.Auto)
				{
					layoutData.Write().alignContent = Align.Auto;
				}
				break;
			case StylePropertyId.AlignItems:
				layoutData.Write().alignItems = (Align)sv.number;
				if (sv.keyword == StyleKeyword.Auto)
				{
					layoutData.Write().alignItems = Align.Auto;
				}
				break;
			case StylePropertyId.AlignSelf:
				layoutData.Write().alignSelf = (Align)sv.number;
				if (sv.keyword == StyleKeyword.Auto)
				{
					layoutData.Write().alignSelf = Align.Auto;
				}
				break;
			case StylePropertyId.BackgroundColor:
				visualData.Write().backgroundColor = sv.color;
				break;
			case StylePropertyId.BackgroundImage:
				visualData.Write().backgroundImage = (sv.resource.IsAllocated ? Background.FromObject(sv.resource.Target) : default(Background));
				break;
			case StylePropertyId.BackgroundPositionX:
				visualData.Write().backgroundPositionX = sv.position;
				break;
			case StylePropertyId.BackgroundPositionY:
				visualData.Write().backgroundPositionY = sv.position;
				break;
			case StylePropertyId.BackgroundRepeat:
				visualData.Write().backgroundRepeat = sv.repeat;
				break;
			case StylePropertyId.BorderBottomColor:
				visualData.Write().borderBottomColor = sv.color;
				break;
			case StylePropertyId.BorderBottomLeftRadius:
				visualData.Write().borderBottomLeftRadius = sv.length;
				break;
			case StylePropertyId.BorderBottomRightRadius:
				visualData.Write().borderBottomRightRadius = sv.length;
				break;
			case StylePropertyId.BorderBottomWidth:
				layoutData.Write().borderBottomWidth = sv.number;
				break;
			case StylePropertyId.BorderLeftColor:
				visualData.Write().borderLeftColor = sv.color;
				break;
			case StylePropertyId.BorderLeftWidth:
				layoutData.Write().borderLeftWidth = sv.number;
				break;
			case StylePropertyId.BorderRightColor:
				visualData.Write().borderRightColor = sv.color;
				break;
			case StylePropertyId.BorderRightWidth:
				layoutData.Write().borderRightWidth = sv.number;
				break;
			case StylePropertyId.BorderTopColor:
				visualData.Write().borderTopColor = sv.color;
				break;
			case StylePropertyId.BorderTopLeftRadius:
				visualData.Write().borderTopLeftRadius = sv.length;
				break;
			case StylePropertyId.BorderTopRightRadius:
				visualData.Write().borderTopRightRadius = sv.length;
				break;
			case StylePropertyId.BorderTopWidth:
				layoutData.Write().borderTopWidth = sv.number;
				break;
			case StylePropertyId.Bottom:
				layoutData.Write().bottom = sv.length;
				break;
			case StylePropertyId.Color:
				inheritedData.Write().color = sv.color;
				break;
			case StylePropertyId.Display:
				layoutData.Write().display = (DisplayStyle)sv.number;
				if (sv.keyword == StyleKeyword.None)
				{
					layoutData.Write().display = DisplayStyle.None;
				}
				break;
			case StylePropertyId.FlexBasis:
				layoutData.Write().flexBasis = sv.length;
				break;
			case StylePropertyId.FlexDirection:
				layoutData.Write().flexDirection = (FlexDirection)sv.number;
				break;
			case StylePropertyId.FlexGrow:
				layoutData.Write().flexGrow = sv.number;
				break;
			case StylePropertyId.FlexShrink:
				layoutData.Write().flexShrink = sv.number;
				break;
			case StylePropertyId.FlexWrap:
				layoutData.Write().flexWrap = (Wrap)sv.number;
				break;
			case StylePropertyId.FontSize:
				inheritedData.Write().fontSize = sv.length;
				break;
			case StylePropertyId.Height:
				layoutData.Write().height = sv.length;
				break;
			case StylePropertyId.JustifyContent:
				layoutData.Write().justifyContent = (Justify)sv.number;
				break;
			case StylePropertyId.Left:
				layoutData.Write().left = sv.length;
				break;
			case StylePropertyId.LetterSpacing:
				inheritedData.Write().letterSpacing = sv.length;
				break;
			case StylePropertyId.MarginBottom:
				layoutData.Write().marginBottom = sv.length;
				break;
			case StylePropertyId.MarginLeft:
				layoutData.Write().marginLeft = sv.length;
				break;
			case StylePropertyId.MarginRight:
				layoutData.Write().marginRight = sv.length;
				break;
			case StylePropertyId.MarginTop:
				layoutData.Write().marginTop = sv.length;
				break;
			case StylePropertyId.MaxHeight:
				layoutData.Write().maxHeight = sv.length;
				break;
			case StylePropertyId.MaxWidth:
				layoutData.Write().maxWidth = sv.length;
				break;
			case StylePropertyId.MinHeight:
				layoutData.Write().minHeight = sv.length;
				break;
			case StylePropertyId.MinWidth:
				layoutData.Write().minWidth = sv.length;
				break;
			case StylePropertyId.Opacity:
				visualData.Write().opacity = sv.number;
				break;
			case StylePropertyId.Overflow:
				visualData.Write().overflow = (OverflowInternal)sv.number;
				break;
			case StylePropertyId.PaddingBottom:
				layoutData.Write().paddingBottom = sv.length;
				break;
			case StylePropertyId.PaddingLeft:
				layoutData.Write().paddingLeft = sv.length;
				break;
			case StylePropertyId.PaddingRight:
				layoutData.Write().paddingRight = sv.length;
				break;
			case StylePropertyId.PaddingTop:
				layoutData.Write().paddingTop = sv.length;
				break;
			case StylePropertyId.Position:
				layoutData.Write().position = (Position)sv.number;
				break;
			case StylePropertyId.Right:
				layoutData.Write().right = sv.length;
				break;
			case StylePropertyId.TextOverflow:
				rareData.Write().textOverflow = (TextOverflow)sv.number;
				break;
			case StylePropertyId.Top:
				layoutData.Write().top = sv.length;
				break;
			case StylePropertyId.UnityBackgroundImageTintColor:
				rareData.Write().unityBackgroundImageTintColor = sv.color;
				break;
			case StylePropertyId.UnityFont:
				inheritedData.Write().unityFont = (sv.resource.IsAllocated ? (sv.resource.Target as Font) : null);
				break;
			case StylePropertyId.UnityFontDefinition:
				inheritedData.Write().unityFontDefinition = (sv.resource.IsAllocated ? FontDefinition.FromObject(sv.resource.Target) : default(FontDefinition));
				break;
			case StylePropertyId.UnityFontStyleAndWeight:
				inheritedData.Write().unityFontStyleAndWeight = (FontStyle)sv.number;
				break;
			case StylePropertyId.UnityOverflowClipBox:
				rareData.Write().unityOverflowClipBox = (OverflowClipBox)sv.number;
				break;
			case StylePropertyId.UnityParagraphSpacing:
				inheritedData.Write().unityParagraphSpacing = sv.length;
				break;
			case StylePropertyId.UnitySliceBottom:
				rareData.Write().unitySliceBottom = (int)sv.number;
				break;
			case StylePropertyId.UnitySliceLeft:
				rareData.Write().unitySliceLeft = (int)sv.number;
				break;
			case StylePropertyId.UnitySliceRight:
				rareData.Write().unitySliceRight = (int)sv.number;
				break;
			case StylePropertyId.UnitySliceScale:
				rareData.Write().unitySliceScale = sv.number;
				break;
			case StylePropertyId.UnitySliceTop:
				rareData.Write().unitySliceTop = (int)sv.number;
				break;
			case StylePropertyId.UnityTextAlign:
				inheritedData.Write().unityTextAlign = (TextAnchor)sv.number;
				break;
			case StylePropertyId.UnityTextOutlineColor:
				inheritedData.Write().unityTextOutlineColor = sv.color;
				break;
			case StylePropertyId.UnityTextOutlineWidth:
				inheritedData.Write().unityTextOutlineWidth = sv.number;
				break;
			case StylePropertyId.UnityTextOverflowPosition:
				rareData.Write().unityTextOverflowPosition = (TextOverflowPosition)sv.number;
				break;
			case StylePropertyId.Visibility:
				inheritedData.Write().visibility = (Visibility)sv.number;
				break;
			case StylePropertyId.WhiteSpace:
				inheritedData.Write().whiteSpace = (WhiteSpace)sv.number;
				break;
			case StylePropertyId.Width:
				layoutData.Write().width = sv.length;
				break;
			case StylePropertyId.WordSpacing:
				inheritedData.Write().wordSpacing = sv.length;
				break;
			default:
				Debug.LogAssertion($"Unexpected property id {sv.id}");
				break;
			}
		}

		public void ApplyStyleValueManaged(StyleValueManaged sv, ref ComputedStyle parentStyle)
		{
			if (ApplyGlobalKeyword(sv.id, sv.keyword, ref parentStyle))
			{
				return;
			}
			switch (sv.id)
			{
			case StylePropertyId.TransitionDelay:
				if (sv.value == null)
				{
					transitionData.Write().transitionDelay.CopyFrom(InitialStyle.transitionDelay);
				}
				else
				{
					transitionData.Write().transitionDelay = sv.value as List<TimeValue>;
				}
				ResetComputedTransitions();
				break;
			case StylePropertyId.TransitionDuration:
				if (sv.value == null)
				{
					transitionData.Write().transitionDuration.CopyFrom(InitialStyle.transitionDuration);
				}
				else
				{
					transitionData.Write().transitionDuration = sv.value as List<TimeValue>;
				}
				ResetComputedTransitions();
				break;
			case StylePropertyId.TransitionProperty:
				if (sv.value == null)
				{
					transitionData.Write().transitionProperty.CopyFrom(InitialStyle.transitionProperty);
				}
				else
				{
					transitionData.Write().transitionProperty = sv.value as List<StylePropertyName>;
				}
				ResetComputedTransitions();
				break;
			case StylePropertyId.TransitionTimingFunction:
				if (sv.value == null)
				{
					transitionData.Write().transitionTimingFunction.CopyFrom(InitialStyle.transitionTimingFunction);
				}
				else
				{
					transitionData.Write().transitionTimingFunction = sv.value as List<EasingFunction>;
				}
				ResetComputedTransitions();
				break;
			default:
				Debug.LogAssertion($"Unexpected property id {sv.id}");
				break;
			}
		}

		public void ApplyStyleCursor(Cursor cursor)
		{
			rareData.Write().cursor = cursor;
		}

		public void ApplyStyleTextShadow(TextShadow st)
		{
			inheritedData.Write().textShadow = st;
		}

		public void ApplyFromComputedStyle(StylePropertyId id, ref ComputedStyle other)
		{
			switch (id)
			{
			case StylePropertyId.AlignContent:
				layoutData.Write().alignContent = other.layoutData.Read().alignContent;
				break;
			case StylePropertyId.AlignItems:
				layoutData.Write().alignItems = other.layoutData.Read().alignItems;
				break;
			case StylePropertyId.AlignSelf:
				layoutData.Write().alignSelf = other.layoutData.Read().alignSelf;
				break;
			case StylePropertyId.BackgroundColor:
				visualData.Write().backgroundColor = other.visualData.Read().backgroundColor;
				break;
			case StylePropertyId.BackgroundImage:
				visualData.Write().backgroundImage = other.visualData.Read().backgroundImage;
				break;
			case StylePropertyId.BackgroundPositionX:
				visualData.Write().backgroundPositionX = other.visualData.Read().backgroundPositionX;
				break;
			case StylePropertyId.BackgroundPositionY:
				visualData.Write().backgroundPositionY = other.visualData.Read().backgroundPositionY;
				break;
			case StylePropertyId.BackgroundRepeat:
				visualData.Write().backgroundRepeat = other.visualData.Read().backgroundRepeat;
				break;
			case StylePropertyId.BackgroundSize:
				visualData.Write().backgroundSize = other.visualData.Read().backgroundSize;
				break;
			case StylePropertyId.BorderBottomColor:
				visualData.Write().borderBottomColor = other.visualData.Read().borderBottomColor;
				break;
			case StylePropertyId.BorderBottomLeftRadius:
				visualData.Write().borderBottomLeftRadius = other.visualData.Read().borderBottomLeftRadius;
				break;
			case StylePropertyId.BorderBottomRightRadius:
				visualData.Write().borderBottomRightRadius = other.visualData.Read().borderBottomRightRadius;
				break;
			case StylePropertyId.BorderBottomWidth:
				layoutData.Write().borderBottomWidth = other.layoutData.Read().borderBottomWidth;
				break;
			case StylePropertyId.BorderLeftColor:
				visualData.Write().borderLeftColor = other.visualData.Read().borderLeftColor;
				break;
			case StylePropertyId.BorderLeftWidth:
				layoutData.Write().borderLeftWidth = other.layoutData.Read().borderLeftWidth;
				break;
			case StylePropertyId.BorderRightColor:
				visualData.Write().borderRightColor = other.visualData.Read().borderRightColor;
				break;
			case StylePropertyId.BorderRightWidth:
				layoutData.Write().borderRightWidth = other.layoutData.Read().borderRightWidth;
				break;
			case StylePropertyId.BorderTopColor:
				visualData.Write().borderTopColor = other.visualData.Read().borderTopColor;
				break;
			case StylePropertyId.BorderTopLeftRadius:
				visualData.Write().borderTopLeftRadius = other.visualData.Read().borderTopLeftRadius;
				break;
			case StylePropertyId.BorderTopRightRadius:
				visualData.Write().borderTopRightRadius = other.visualData.Read().borderTopRightRadius;
				break;
			case StylePropertyId.BorderTopWidth:
				layoutData.Write().borderTopWidth = other.layoutData.Read().borderTopWidth;
				break;
			case StylePropertyId.Bottom:
				layoutData.Write().bottom = other.layoutData.Read().bottom;
				break;
			case StylePropertyId.Color:
				inheritedData.Write().color = other.inheritedData.Read().color;
				break;
			case StylePropertyId.Cursor:
				rareData.Write().cursor = other.rareData.Read().cursor;
				break;
			case StylePropertyId.Display:
				layoutData.Write().display = other.layoutData.Read().display;
				break;
			case StylePropertyId.FlexBasis:
				layoutData.Write().flexBasis = other.layoutData.Read().flexBasis;
				break;
			case StylePropertyId.FlexDirection:
				layoutData.Write().flexDirection = other.layoutData.Read().flexDirection;
				break;
			case StylePropertyId.FlexGrow:
				layoutData.Write().flexGrow = other.layoutData.Read().flexGrow;
				break;
			case StylePropertyId.FlexShrink:
				layoutData.Write().flexShrink = other.layoutData.Read().flexShrink;
				break;
			case StylePropertyId.FlexWrap:
				layoutData.Write().flexWrap = other.layoutData.Read().flexWrap;
				break;
			case StylePropertyId.FontSize:
				inheritedData.Write().fontSize = other.inheritedData.Read().fontSize;
				break;
			case StylePropertyId.Height:
				layoutData.Write().height = other.layoutData.Read().height;
				break;
			case StylePropertyId.JustifyContent:
				layoutData.Write().justifyContent = other.layoutData.Read().justifyContent;
				break;
			case StylePropertyId.Left:
				layoutData.Write().left = other.layoutData.Read().left;
				break;
			case StylePropertyId.LetterSpacing:
				inheritedData.Write().letterSpacing = other.inheritedData.Read().letterSpacing;
				break;
			case StylePropertyId.MarginBottom:
				layoutData.Write().marginBottom = other.layoutData.Read().marginBottom;
				break;
			case StylePropertyId.MarginLeft:
				layoutData.Write().marginLeft = other.layoutData.Read().marginLeft;
				break;
			case StylePropertyId.MarginRight:
				layoutData.Write().marginRight = other.layoutData.Read().marginRight;
				break;
			case StylePropertyId.MarginTop:
				layoutData.Write().marginTop = other.layoutData.Read().marginTop;
				break;
			case StylePropertyId.MaxHeight:
				layoutData.Write().maxHeight = other.layoutData.Read().maxHeight;
				break;
			case StylePropertyId.MaxWidth:
				layoutData.Write().maxWidth = other.layoutData.Read().maxWidth;
				break;
			case StylePropertyId.MinHeight:
				layoutData.Write().minHeight = other.layoutData.Read().minHeight;
				break;
			case StylePropertyId.MinWidth:
				layoutData.Write().minWidth = other.layoutData.Read().minWidth;
				break;
			case StylePropertyId.Opacity:
				visualData.Write().opacity = other.visualData.Read().opacity;
				break;
			case StylePropertyId.Overflow:
				visualData.Write().overflow = other.visualData.Read().overflow;
				break;
			case StylePropertyId.PaddingBottom:
				layoutData.Write().paddingBottom = other.layoutData.Read().paddingBottom;
				break;
			case StylePropertyId.PaddingLeft:
				layoutData.Write().paddingLeft = other.layoutData.Read().paddingLeft;
				break;
			case StylePropertyId.PaddingRight:
				layoutData.Write().paddingRight = other.layoutData.Read().paddingRight;
				break;
			case StylePropertyId.PaddingTop:
				layoutData.Write().paddingTop = other.layoutData.Read().paddingTop;
				break;
			case StylePropertyId.Position:
				layoutData.Write().position = other.layoutData.Read().position;
				break;
			case StylePropertyId.Right:
				layoutData.Write().right = other.layoutData.Read().right;
				break;
			case StylePropertyId.Rotate:
				transformData.Write().rotate = other.transformData.Read().rotate;
				break;
			case StylePropertyId.Scale:
				transformData.Write().scale = other.transformData.Read().scale;
				break;
			case StylePropertyId.TextOverflow:
				rareData.Write().textOverflow = other.rareData.Read().textOverflow;
				break;
			case StylePropertyId.TextShadow:
				inheritedData.Write().textShadow = other.inheritedData.Read().textShadow;
				break;
			case StylePropertyId.Top:
				layoutData.Write().top = other.layoutData.Read().top;
				break;
			case StylePropertyId.TransformOrigin:
				transformData.Write().transformOrigin = other.transformData.Read().transformOrigin;
				break;
			case StylePropertyId.TransitionDelay:
				transitionData.Write().transitionDelay.CopyFrom(other.transitionData.Read().transitionDelay);
				ResetComputedTransitions();
				break;
			case StylePropertyId.TransitionDuration:
				transitionData.Write().transitionDuration.CopyFrom(other.transitionData.Read().transitionDuration);
				ResetComputedTransitions();
				break;
			case StylePropertyId.TransitionProperty:
				transitionData.Write().transitionProperty.CopyFrom(other.transitionData.Read().transitionProperty);
				ResetComputedTransitions();
				break;
			case StylePropertyId.TransitionTimingFunction:
				transitionData.Write().transitionTimingFunction.CopyFrom(other.transitionData.Read().transitionTimingFunction);
				ResetComputedTransitions();
				break;
			case StylePropertyId.Translate:
				transformData.Write().translate = other.transformData.Read().translate;
				break;
			case StylePropertyId.UnityBackgroundImageTintColor:
				rareData.Write().unityBackgroundImageTintColor = other.rareData.Read().unityBackgroundImageTintColor;
				break;
			case StylePropertyId.UnityFont:
				inheritedData.Write().unityFont = other.inheritedData.Read().unityFont;
				break;
			case StylePropertyId.UnityFontDefinition:
				inheritedData.Write().unityFontDefinition = other.inheritedData.Read().unityFontDefinition;
				break;
			case StylePropertyId.UnityFontStyleAndWeight:
				inheritedData.Write().unityFontStyleAndWeight = other.inheritedData.Read().unityFontStyleAndWeight;
				break;
			case StylePropertyId.UnityOverflowClipBox:
				rareData.Write().unityOverflowClipBox = other.rareData.Read().unityOverflowClipBox;
				break;
			case StylePropertyId.UnityParagraphSpacing:
				inheritedData.Write().unityParagraphSpacing = other.inheritedData.Read().unityParagraphSpacing;
				break;
			case StylePropertyId.UnitySliceBottom:
				rareData.Write().unitySliceBottom = other.rareData.Read().unitySliceBottom;
				break;
			case StylePropertyId.UnitySliceLeft:
				rareData.Write().unitySliceLeft = other.rareData.Read().unitySliceLeft;
				break;
			case StylePropertyId.UnitySliceRight:
				rareData.Write().unitySliceRight = other.rareData.Read().unitySliceRight;
				break;
			case StylePropertyId.UnitySliceScale:
				rareData.Write().unitySliceScale = other.rareData.Read().unitySliceScale;
				break;
			case StylePropertyId.UnitySliceTop:
				rareData.Write().unitySliceTop = other.rareData.Read().unitySliceTop;
				break;
			case StylePropertyId.UnityTextAlign:
				inheritedData.Write().unityTextAlign = other.inheritedData.Read().unityTextAlign;
				break;
			case StylePropertyId.UnityTextOutlineColor:
				inheritedData.Write().unityTextOutlineColor = other.inheritedData.Read().unityTextOutlineColor;
				break;
			case StylePropertyId.UnityTextOutlineWidth:
				inheritedData.Write().unityTextOutlineWidth = other.inheritedData.Read().unityTextOutlineWidth;
				break;
			case StylePropertyId.UnityTextOverflowPosition:
				rareData.Write().unityTextOverflowPosition = other.rareData.Read().unityTextOverflowPosition;
				break;
			case StylePropertyId.Visibility:
				inheritedData.Write().visibility = other.inheritedData.Read().visibility;
				break;
			case StylePropertyId.WhiteSpace:
				inheritedData.Write().whiteSpace = other.inheritedData.Read().whiteSpace;
				break;
			case StylePropertyId.Width:
				layoutData.Write().width = other.layoutData.Read().width;
				break;
			case StylePropertyId.WordSpacing:
				inheritedData.Write().wordSpacing = other.inheritedData.Read().wordSpacing;
				break;
			default:
				Debug.LogAssertion($"Unexpected property id {id}");
				break;
			}
		}

		public void ApplyPropertyAnimation(VisualElement ve, StylePropertyId id, Length newValue)
		{
			switch (id)
			{
			case StylePropertyId.BorderBottomLeftRadius:
				visualData.Write().borderBottomLeftRadius = newValue;
				ve.IncrementVersion(VersionChangeType.BorderRadius | VersionChangeType.Repaint);
				break;
			case StylePropertyId.BorderBottomRightRadius:
				visualData.Write().borderBottomRightRadius = newValue;
				ve.IncrementVersion(VersionChangeType.BorderRadius | VersionChangeType.Repaint);
				break;
			case StylePropertyId.BorderTopLeftRadius:
				visualData.Write().borderTopLeftRadius = newValue;
				ve.IncrementVersion(VersionChangeType.BorderRadius | VersionChangeType.Repaint);
				break;
			case StylePropertyId.BorderTopRightRadius:
				visualData.Write().borderTopRightRadius = newValue;
				ve.IncrementVersion(VersionChangeType.BorderRadius | VersionChangeType.Repaint);
				break;
			case StylePropertyId.Bottom:
				layoutData.Write().bottom = newValue;
				ve.yogaNode.Bottom = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.FlexBasis:
				layoutData.Write().flexBasis = newValue;
				ve.yogaNode.FlexBasis = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.FontSize:
				inheritedData.Write().fontSize = newValue;
				ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Repaint);
				break;
			case StylePropertyId.Height:
				layoutData.Write().height = newValue;
				ve.yogaNode.Height = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.Left:
				layoutData.Write().left = newValue;
				ve.yogaNode.Left = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.LetterSpacing:
				inheritedData.Write().letterSpacing = newValue;
				ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Repaint);
				break;
			case StylePropertyId.MarginBottom:
				layoutData.Write().marginBottom = newValue;
				ve.yogaNode.MarginBottom = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.MarginLeft:
				layoutData.Write().marginLeft = newValue;
				ve.yogaNode.MarginLeft = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.MarginRight:
				layoutData.Write().marginRight = newValue;
				ve.yogaNode.MarginRight = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.MarginTop:
				layoutData.Write().marginTop = newValue;
				ve.yogaNode.MarginTop = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.MaxHeight:
				layoutData.Write().maxHeight = newValue;
				ve.yogaNode.MaxHeight = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.MaxWidth:
				layoutData.Write().maxWidth = newValue;
				ve.yogaNode.MaxWidth = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.MinHeight:
				layoutData.Write().minHeight = newValue;
				ve.yogaNode.MinHeight = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.MinWidth:
				layoutData.Write().minWidth = newValue;
				ve.yogaNode.MinWidth = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.PaddingBottom:
				layoutData.Write().paddingBottom = newValue;
				ve.yogaNode.PaddingBottom = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.PaddingLeft:
				layoutData.Write().paddingLeft = newValue;
				ve.yogaNode.PaddingLeft = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.PaddingRight:
				layoutData.Write().paddingRight = newValue;
				ve.yogaNode.PaddingRight = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.PaddingTop:
				layoutData.Write().paddingTop = newValue;
				ve.yogaNode.PaddingTop = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.Right:
				layoutData.Write().right = newValue;
				ve.yogaNode.Right = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.Top:
				layoutData.Write().top = newValue;
				ve.yogaNode.Top = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.UnityParagraphSpacing:
				inheritedData.Write().unityParagraphSpacing = newValue;
				ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Repaint);
				break;
			case StylePropertyId.Width:
				layoutData.Write().width = newValue;
				ve.yogaNode.Width = newValue.ToYogaValue();
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.WordSpacing:
				inheritedData.Write().wordSpacing = newValue;
				ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Repaint);
				break;
			default:
				throw new ArgumentException("Invalid animation property id. Can't apply value of type 'Length' to property '" + id.ToString() + "'. Please make sure that this property is animatable.", "id");
			}
		}

		public void ApplyPropertyAnimation(VisualElement ve, StylePropertyId id, float newValue)
		{
			switch (id)
			{
			case StylePropertyId.BorderBottomWidth:
				layoutData.Write().borderBottomWidth = newValue;
				ve.yogaNode.BorderBottomWidth = newValue;
				ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.BorderWidth | VersionChangeType.Repaint);
				break;
			case StylePropertyId.BorderLeftWidth:
				layoutData.Write().borderLeftWidth = newValue;
				ve.yogaNode.BorderLeftWidth = newValue;
				ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.BorderWidth | VersionChangeType.Repaint);
				break;
			case StylePropertyId.BorderRightWidth:
				layoutData.Write().borderRightWidth = newValue;
				ve.yogaNode.BorderRightWidth = newValue;
				ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.BorderWidth | VersionChangeType.Repaint);
				break;
			case StylePropertyId.BorderTopWidth:
				layoutData.Write().borderTopWidth = newValue;
				ve.yogaNode.BorderTopWidth = newValue;
				ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.BorderWidth | VersionChangeType.Repaint);
				break;
			case StylePropertyId.FlexGrow:
				layoutData.Write().flexGrow = newValue;
				ve.yogaNode.FlexGrow = newValue;
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.FlexShrink:
				layoutData.Write().flexShrink = newValue;
				ve.yogaNode.FlexShrink = newValue;
				ve.IncrementVersion(VersionChangeType.Layout);
				break;
			case StylePropertyId.Opacity:
				visualData.Write().opacity = newValue;
				ve.IncrementVersion(VersionChangeType.Opacity);
				break;
			case StylePropertyId.UnitySliceScale:
				rareData.Write().unitySliceScale = newValue;
				ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Repaint);
				break;
			case StylePropertyId.UnityTextOutlineWidth:
				inheritedData.Write().unityTextOutlineWidth = newValue;
				ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Repaint);
				break;
			default:
				throw new ArgumentException("Invalid animation property id. Can't apply value of type 'float' to property '" + id.ToString() + "'. Please make sure that this property is animatable.", "id");
			}
		}

		public void ApplyPropertyAnimation(VisualElement ve, StylePropertyId id, int newValue)
		{
			switch (id)
			{
			case StylePropertyId.AlignContent:
				if (layoutData.Read().alignContent != (Align)newValue)
				{
					layoutData.Write().alignContent = (Align)newValue;
					ve.yogaNode.AlignContent = (YogaAlign)newValue;
					ve.IncrementVersion(VersionChangeType.Layout);
				}
				break;
			case StylePropertyId.AlignItems:
				if (layoutData.Read().alignItems != (Align)newValue)
				{
					layoutData.Write().alignItems = (Align)newValue;
					ve.yogaNode.AlignItems = (YogaAlign)newValue;
					ve.IncrementVersion(VersionChangeType.Layout);
				}
				break;
			case StylePropertyId.AlignSelf:
				if (layoutData.Read().alignSelf != (Align)newValue)
				{
					layoutData.Write().alignSelf = (Align)newValue;
					ve.yogaNode.AlignSelf = (YogaAlign)newValue;
					ve.IncrementVersion(VersionChangeType.Layout);
				}
				break;
			case StylePropertyId.Display:
				if (layoutData.Read().display != (DisplayStyle)newValue)
				{
					layoutData.Write().display = (DisplayStyle)newValue;
					ve.yogaNode.Display = (YogaDisplay)newValue;
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Repaint);
				}
				break;
			case StylePropertyId.FlexDirection:
				if (layoutData.Read().flexDirection != (FlexDirection)newValue)
				{
					layoutData.Write().flexDirection = (FlexDirection)newValue;
					ve.yogaNode.FlexDirection = (YogaFlexDirection)newValue;
					ve.IncrementVersion(VersionChangeType.Layout);
				}
				break;
			case StylePropertyId.FlexWrap:
				if (layoutData.Read().flexWrap != (Wrap)newValue)
				{
					layoutData.Write().flexWrap = (Wrap)newValue;
					ve.yogaNode.Wrap = (YogaWrap)newValue;
					ve.IncrementVersion(VersionChangeType.Layout);
				}
				break;
			case StylePropertyId.JustifyContent:
				if (layoutData.Read().justifyContent != (Justify)newValue)
				{
					layoutData.Write().justifyContent = (Justify)newValue;
					ve.yogaNode.JustifyContent = (YogaJustify)newValue;
					ve.IncrementVersion(VersionChangeType.Layout);
				}
				break;
			case StylePropertyId.Overflow:
				if (visualData.Read().overflow != (OverflowInternal)newValue)
				{
					visualData.Write().overflow = (OverflowInternal)newValue;
					ve.yogaNode.Overflow = (YogaOverflow)newValue;
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Overflow);
				}
				break;
			case StylePropertyId.Position:
				if (layoutData.Read().position != (Position)newValue)
				{
					layoutData.Write().position = (Position)newValue;
					ve.yogaNode.PositionType = (YogaPositionType)newValue;
					ve.IncrementVersion(VersionChangeType.Layout);
				}
				break;
			case StylePropertyId.TextOverflow:
				if (rareData.Read().textOverflow != (TextOverflow)newValue)
				{
					rareData.Write().textOverflow = (TextOverflow)newValue;
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Repaint);
				}
				break;
			case StylePropertyId.UnityFontStyleAndWeight:
				if (inheritedData.Read().unityFontStyleAndWeight != (FontStyle)newValue)
				{
					inheritedData.Write().unityFontStyleAndWeight = (FontStyle)newValue;
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Repaint);
				}
				break;
			case StylePropertyId.UnityOverflowClipBox:
				if (rareData.Read().unityOverflowClipBox != (OverflowClipBox)newValue)
				{
					rareData.Write().unityOverflowClipBox = (OverflowClipBox)newValue;
					ve.IncrementVersion(VersionChangeType.Repaint);
				}
				break;
			case StylePropertyId.UnitySliceBottom:
				rareData.Write().unitySliceBottom = newValue;
				ve.IncrementVersion(VersionChangeType.Repaint);
				break;
			case StylePropertyId.UnitySliceLeft:
				rareData.Write().unitySliceLeft = newValue;
				ve.IncrementVersion(VersionChangeType.Repaint);
				break;
			case StylePropertyId.UnitySliceRight:
				rareData.Write().unitySliceRight = newValue;
				ve.IncrementVersion(VersionChangeType.Repaint);
				break;
			case StylePropertyId.UnitySliceTop:
				rareData.Write().unitySliceTop = newValue;
				ve.IncrementVersion(VersionChangeType.Repaint);
				break;
			case StylePropertyId.UnityTextAlign:
				if (inheritedData.Read().unityTextAlign != (TextAnchor)newValue)
				{
					inheritedData.Write().unityTextAlign = (TextAnchor)newValue;
					ve.IncrementVersion(VersionChangeType.StyleSheet | VersionChangeType.Repaint);
				}
				break;
			case StylePropertyId.UnityTextOverflowPosition:
				if (rareData.Read().unityTextOverflowPosition != (TextOverflowPosition)newValue)
				{
					rareData.Write().unityTextOverflowPosition = (TextOverflowPosition)newValue;
					ve.IncrementVersion(VersionChangeType.Repaint);
				}
				break;
			case StylePropertyId.Visibility:
				if (inheritedData.Read().visibility != (Visibility)newValue)
				{
					inheritedData.Write().visibility = (Visibility)newValue;
					ve.IncrementVersion(VersionChangeType.StyleSheet | VersionChangeType.Repaint | VersionChangeType.Picking);
				}
				break;
			case StylePropertyId.WhiteSpace:
				if (inheritedData.Read().whiteSpace != (WhiteSpace)newValue)
				{
					inheritedData.Write().whiteSpace = (WhiteSpace)newValue;
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet);
				}
				break;
			default:
				throw new ArgumentException("Invalid animation property id. Can't apply value of type 'int' to property '" + id.ToString() + "'. Please make sure that this property is animatable.", "id");
			}
		}

		public void ApplyPropertyAnimation(VisualElement ve, StylePropertyId id, BackgroundPosition newValue)
		{
			switch (id)
			{
			case StylePropertyId.BackgroundPositionX:
				if (visualData.Read().backgroundPositionX != newValue)
				{
					visualData.Write().backgroundPositionX = newValue;
					ve.IncrementVersion(VersionChangeType.Repaint);
				}
				break;
			case StylePropertyId.BackgroundPositionY:
				if (visualData.Read().backgroundPositionY != newValue)
				{
					visualData.Write().backgroundPositionY = newValue;
					ve.IncrementVersion(VersionChangeType.Repaint);
				}
				break;
			default:
				throw new ArgumentException("Invalid animation property id. Can't apply value of type 'BackgroundPosition' to property '" + id.ToString() + "'. Please make sure that this property is animatable.", "id");
			}
		}

		public void ApplyPropertyAnimation(VisualElement ve, StylePropertyId id, BackgroundRepeat newValue)
		{
			StylePropertyId stylePropertyId = id;
			StylePropertyId stylePropertyId2 = stylePropertyId;
			if (stylePropertyId2 == StylePropertyId.BackgroundRepeat)
			{
				if (visualData.Read().backgroundRepeat != newValue)
				{
					visualData.Write().backgroundRepeat = newValue;
					ve.IncrementVersion(VersionChangeType.Repaint);
				}
				return;
			}
			throw new ArgumentException("Invalid animation property id. Can't apply value of type 'BackgroundRepeat' to property '" + id.ToString() + "'. Please make sure that this property is animatable.", "id");
		}

		public void ApplyPropertyAnimation(VisualElement ve, StylePropertyId id, BackgroundSize newValue)
		{
			StylePropertyId stylePropertyId = id;
			StylePropertyId stylePropertyId2 = stylePropertyId;
			if (stylePropertyId2 == StylePropertyId.BackgroundSize)
			{
				visualData.Write().backgroundSize = newValue;
				ve.IncrementVersion(VersionChangeType.Repaint);
				return;
			}
			throw new ArgumentException("Invalid animation property id. Can't apply value of type 'BackgroundSize' to property '" + id.ToString() + "'. Please make sure that this property is animatable.", "id");
		}

		public void ApplyPropertyAnimation(VisualElement ve, StylePropertyId id, Color newValue)
		{
			switch (id)
			{
			case StylePropertyId.BackgroundColor:
				visualData.Write().backgroundColor = newValue;
				ve.IncrementVersion(VersionChangeType.Color);
				break;
			case StylePropertyId.BorderBottomColor:
				visualData.Write().borderBottomColor = newValue;
				ve.IncrementVersion(VersionChangeType.Color);
				break;
			case StylePropertyId.BorderLeftColor:
				visualData.Write().borderLeftColor = newValue;
				ve.IncrementVersion(VersionChangeType.Color);
				break;
			case StylePropertyId.BorderRightColor:
				visualData.Write().borderRightColor = newValue;
				ve.IncrementVersion(VersionChangeType.Color);
				break;
			case StylePropertyId.BorderTopColor:
				visualData.Write().borderTopColor = newValue;
				ve.IncrementVersion(VersionChangeType.Color);
				break;
			case StylePropertyId.Color:
				inheritedData.Write().color = newValue;
				ve.IncrementVersion(VersionChangeType.StyleSheet | VersionChangeType.Color);
				break;
			case StylePropertyId.UnityBackgroundImageTintColor:
				rareData.Write().unityBackgroundImageTintColor = newValue;
				ve.IncrementVersion(VersionChangeType.Color);
				break;
			case StylePropertyId.UnityTextOutlineColor:
				inheritedData.Write().unityTextOutlineColor = newValue;
				ve.IncrementVersion(VersionChangeType.StyleSheet | VersionChangeType.Repaint);
				break;
			default:
				throw new ArgumentException("Invalid animation property id. Can't apply value of type 'Color' to property '" + id.ToString() + "'. Please make sure that this property is animatable.", "id");
			}
		}

		public void ApplyPropertyAnimation(VisualElement ve, StylePropertyId id, Background newValue)
		{
			StylePropertyId stylePropertyId = id;
			StylePropertyId stylePropertyId2 = stylePropertyId;
			if (stylePropertyId2 == StylePropertyId.BackgroundImage)
			{
				if (visualData.Read().backgroundImage != newValue)
				{
					visualData.Write().backgroundImage = newValue;
					ve.IncrementVersion(VersionChangeType.Repaint);
				}
				return;
			}
			throw new ArgumentException("Invalid animation property id. Can't apply value of type 'Background' to property '" + id.ToString() + "'. Please make sure that this property is animatable.", "id");
		}

		public void ApplyPropertyAnimation(VisualElement ve, StylePropertyId id, Font newValue)
		{
			StylePropertyId stylePropertyId = id;
			StylePropertyId stylePropertyId2 = stylePropertyId;
			if (stylePropertyId2 == StylePropertyId.UnityFont)
			{
				if (inheritedData.Read().unityFont != newValue)
				{
					inheritedData.Write().unityFont = newValue;
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Repaint);
				}
				return;
			}
			throw new ArgumentException("Invalid animation property id. Can't apply value of type 'Font' to property '" + id.ToString() + "'. Please make sure that this property is animatable.", "id");
		}

		public void ApplyPropertyAnimation(VisualElement ve, StylePropertyId id, FontDefinition newValue)
		{
			StylePropertyId stylePropertyId = id;
			StylePropertyId stylePropertyId2 = stylePropertyId;
			if (stylePropertyId2 == StylePropertyId.UnityFontDefinition)
			{
				if (inheritedData.Read().unityFontDefinition != newValue)
				{
					inheritedData.Write().unityFontDefinition = newValue;
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Repaint);
				}
				return;
			}
			throw new ArgumentException("Invalid animation property id. Can't apply value of type 'FontDefinition' to property '" + id.ToString() + "'. Please make sure that this property is animatable.", "id");
		}

		public void ApplyPropertyAnimation(VisualElement ve, StylePropertyId id, TextShadow newValue)
		{
			StylePropertyId stylePropertyId = id;
			StylePropertyId stylePropertyId2 = stylePropertyId;
			if (stylePropertyId2 == StylePropertyId.TextShadow)
			{
				inheritedData.Write().textShadow = newValue;
				ve.IncrementVersion(VersionChangeType.StyleSheet | VersionChangeType.Repaint);
				return;
			}
			throw new ArgumentException("Invalid animation property id. Can't apply value of type 'TextShadow' to property '" + id.ToString() + "'. Please make sure that this property is animatable.", "id");
		}

		public void ApplyPropertyAnimation(VisualElement ve, StylePropertyId id, Translate newValue)
		{
			StylePropertyId stylePropertyId = id;
			StylePropertyId stylePropertyId2 = stylePropertyId;
			if (stylePropertyId2 == StylePropertyId.Translate)
			{
				transformData.Write().translate = newValue;
				ve.IncrementVersion(VersionChangeType.Transform);
				return;
			}
			throw new ArgumentException("Invalid animation property id. Can't apply value of type 'Translate' to property '" + id.ToString() + "'. Please make sure that this property is animatable.", "id");
		}

		public void ApplyPropertyAnimation(VisualElement ve, StylePropertyId id, TransformOrigin newValue)
		{
			StylePropertyId stylePropertyId = id;
			StylePropertyId stylePropertyId2 = stylePropertyId;
			if (stylePropertyId2 == StylePropertyId.TransformOrigin)
			{
				transformData.Write().transformOrigin = newValue;
				ve.IncrementVersion(VersionChangeType.Transform);
				return;
			}
			throw new ArgumentException("Invalid animation property id. Can't apply value of type 'TransformOrigin' to property '" + id.ToString() + "'. Please make sure that this property is animatable.", "id");
		}

		public void ApplyPropertyAnimation(VisualElement ve, StylePropertyId id, Rotate newValue)
		{
			StylePropertyId stylePropertyId = id;
			StylePropertyId stylePropertyId2 = stylePropertyId;
			if (stylePropertyId2 == StylePropertyId.Rotate)
			{
				transformData.Write().rotate = newValue;
				ve.IncrementVersion(VersionChangeType.Transform);
				return;
			}
			throw new ArgumentException("Invalid animation property id. Can't apply value of type 'Rotate' to property '" + id.ToString() + "'. Please make sure that this property is animatable.", "id");
		}

		public void ApplyPropertyAnimation(VisualElement ve, StylePropertyId id, Scale newValue)
		{
			StylePropertyId stylePropertyId = id;
			StylePropertyId stylePropertyId2 = stylePropertyId;
			if (stylePropertyId2 == StylePropertyId.Scale)
			{
				transformData.Write().scale = newValue;
				ve.IncrementVersion(VersionChangeType.Transform);
				return;
			}
			throw new ArgumentException("Invalid animation property id. Can't apply value of type 'Scale' to property '" + id.ToString() + "'. Please make sure that this property is animatable.", "id");
		}

		public static bool StartAnimation(VisualElement element, StylePropertyId id, ref ComputedStyle oldStyle, ref ComputedStyle newStyle, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			switch (id)
			{
			case StylePropertyId.AlignContent:
				return element.styleAnimation.StartEnum(StylePropertyId.AlignContent, (int)oldStyle.layoutData.Read().alignContent, (int)newStyle.layoutData.Read().alignContent, durationMs, delayMs, easingCurve);
			case StylePropertyId.AlignItems:
				return element.styleAnimation.StartEnum(StylePropertyId.AlignItems, (int)oldStyle.layoutData.Read().alignItems, (int)newStyle.layoutData.Read().alignItems, durationMs, delayMs, easingCurve);
			case StylePropertyId.AlignSelf:
				return element.styleAnimation.StartEnum(StylePropertyId.AlignSelf, (int)oldStyle.layoutData.Read().alignSelf, (int)newStyle.layoutData.Read().alignSelf, durationMs, delayMs, easingCurve);
			case StylePropertyId.All:
				return StartAnimationAllProperty(element, ref oldStyle, ref newStyle, durationMs, delayMs, easingCurve);
			case StylePropertyId.BackgroundColor:
			{
				bool flag13 = element.styleAnimation.Start(StylePropertyId.BackgroundColor, oldStyle.visualData.Read().backgroundColor, newStyle.visualData.Read().backgroundColor, durationMs, delayMs, easingCurve);
				if (flag13 && (element.usageHints & UsageHints.DynamicColor) == 0)
				{
					element.usageHints |= UsageHints.DynamicColor;
				}
				return flag13;
			}
			case StylePropertyId.BackgroundImage:
				return element.styleAnimation.Start(StylePropertyId.BackgroundImage, oldStyle.visualData.Read().backgroundImage, newStyle.visualData.Read().backgroundImage, durationMs, delayMs, easingCurve);
			case StylePropertyId.BackgroundPosition:
			{
				bool flag11 = false;
				flag11 |= element.styleAnimation.Start(StylePropertyId.BackgroundPositionX, oldStyle.visualData.Read().backgroundPositionX, newStyle.visualData.Read().backgroundPositionX, durationMs, delayMs, easingCurve);
				return flag11 | element.styleAnimation.Start(StylePropertyId.BackgroundPositionY, oldStyle.visualData.Read().backgroundPositionY, newStyle.visualData.Read().backgroundPositionY, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.BackgroundPositionX:
				return element.styleAnimation.Start(StylePropertyId.BackgroundPositionX, oldStyle.visualData.Read().backgroundPositionX, newStyle.visualData.Read().backgroundPositionX, durationMs, delayMs, easingCurve);
			case StylePropertyId.BackgroundPositionY:
				return element.styleAnimation.Start(StylePropertyId.BackgroundPositionY, oldStyle.visualData.Read().backgroundPositionY, newStyle.visualData.Read().backgroundPositionY, durationMs, delayMs, easingCurve);
			case StylePropertyId.BackgroundRepeat:
				return element.styleAnimation.Start(StylePropertyId.BackgroundRepeat, oldStyle.visualData.Read().backgroundRepeat, newStyle.visualData.Read().backgroundRepeat, durationMs, delayMs, easingCurve);
			case StylePropertyId.BackgroundSize:
				return element.styleAnimation.Start(StylePropertyId.BackgroundSize, oldStyle.visualData.Read().backgroundSize, newStyle.visualData.Read().backgroundSize, durationMs, delayMs, easingCurve);
			case StylePropertyId.BorderBottomColor:
			{
				bool flag20 = element.styleAnimation.Start(StylePropertyId.BorderBottomColor, oldStyle.visualData.Read().borderBottomColor, newStyle.visualData.Read().borderBottomColor, durationMs, delayMs, easingCurve);
				if (flag20 && (element.usageHints & UsageHints.DynamicColor) == 0)
				{
					element.usageHints |= UsageHints.DynamicColor;
				}
				return flag20;
			}
			case StylePropertyId.BorderBottomLeftRadius:
				return element.styleAnimation.Start(StylePropertyId.BorderBottomLeftRadius, oldStyle.visualData.Read().borderBottomLeftRadius, newStyle.visualData.Read().borderBottomLeftRadius, durationMs, delayMs, easingCurve);
			case StylePropertyId.BorderBottomRightRadius:
				return element.styleAnimation.Start(StylePropertyId.BorderBottomRightRadius, oldStyle.visualData.Read().borderBottomRightRadius, newStyle.visualData.Read().borderBottomRightRadius, durationMs, delayMs, easingCurve);
			case StylePropertyId.BorderBottomWidth:
				return element.styleAnimation.Start(StylePropertyId.BorderBottomWidth, oldStyle.layoutData.Read().borderBottomWidth, newStyle.layoutData.Read().borderBottomWidth, durationMs, delayMs, easingCurve);
			case StylePropertyId.BorderColor:
			{
				bool flag10 = false;
				flag10 |= element.styleAnimation.Start(StylePropertyId.BorderTopColor, oldStyle.visualData.Read().borderTopColor, newStyle.visualData.Read().borderTopColor, durationMs, delayMs, easingCurve);
				flag10 |= element.styleAnimation.Start(StylePropertyId.BorderRightColor, oldStyle.visualData.Read().borderRightColor, newStyle.visualData.Read().borderRightColor, durationMs, delayMs, easingCurve);
				flag10 |= element.styleAnimation.Start(StylePropertyId.BorderBottomColor, oldStyle.visualData.Read().borderBottomColor, newStyle.visualData.Read().borderBottomColor, durationMs, delayMs, easingCurve);
				flag10 |= element.styleAnimation.Start(StylePropertyId.BorderLeftColor, oldStyle.visualData.Read().borderLeftColor, newStyle.visualData.Read().borderLeftColor, durationMs, delayMs, easingCurve);
				if (flag10 && (element.usageHints & UsageHints.DynamicColor) == 0)
				{
					element.usageHints |= UsageHints.DynamicColor;
				}
				return flag10;
			}
			case StylePropertyId.BorderLeftColor:
			{
				bool flag8 = element.styleAnimation.Start(StylePropertyId.BorderLeftColor, oldStyle.visualData.Read().borderLeftColor, newStyle.visualData.Read().borderLeftColor, durationMs, delayMs, easingCurve);
				if (flag8 && (element.usageHints & UsageHints.DynamicColor) == 0)
				{
					element.usageHints |= UsageHints.DynamicColor;
				}
				return flag8;
			}
			case StylePropertyId.BorderLeftWidth:
				return element.styleAnimation.Start(StylePropertyId.BorderLeftWidth, oldStyle.layoutData.Read().borderLeftWidth, newStyle.layoutData.Read().borderLeftWidth, durationMs, delayMs, easingCurve);
			case StylePropertyId.BorderRadius:
			{
				bool flag6 = false;
				flag6 |= element.styleAnimation.Start(StylePropertyId.BorderTopLeftRadius, oldStyle.visualData.Read().borderTopLeftRadius, newStyle.visualData.Read().borderTopLeftRadius, durationMs, delayMs, easingCurve);
				flag6 |= element.styleAnimation.Start(StylePropertyId.BorderTopRightRadius, oldStyle.visualData.Read().borderTopRightRadius, newStyle.visualData.Read().borderTopRightRadius, durationMs, delayMs, easingCurve);
				flag6 |= element.styleAnimation.Start(StylePropertyId.BorderBottomRightRadius, oldStyle.visualData.Read().borderBottomRightRadius, newStyle.visualData.Read().borderBottomRightRadius, durationMs, delayMs, easingCurve);
				return flag6 | element.styleAnimation.Start(StylePropertyId.BorderBottomLeftRadius, oldStyle.visualData.Read().borderBottomLeftRadius, newStyle.visualData.Read().borderBottomLeftRadius, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.BorderRightColor:
			{
				bool flag4 = element.styleAnimation.Start(StylePropertyId.BorderRightColor, oldStyle.visualData.Read().borderRightColor, newStyle.visualData.Read().borderRightColor, durationMs, delayMs, easingCurve);
				if (flag4 && (element.usageHints & UsageHints.DynamicColor) == 0)
				{
					element.usageHints |= UsageHints.DynamicColor;
				}
				return flag4;
			}
			case StylePropertyId.BorderRightWidth:
				return element.styleAnimation.Start(StylePropertyId.BorderRightWidth, oldStyle.layoutData.Read().borderRightWidth, newStyle.layoutData.Read().borderRightWidth, durationMs, delayMs, easingCurve);
			case StylePropertyId.BorderTopColor:
			{
				bool flag19 = element.styleAnimation.Start(StylePropertyId.BorderTopColor, oldStyle.visualData.Read().borderTopColor, newStyle.visualData.Read().borderTopColor, durationMs, delayMs, easingCurve);
				if (flag19 && (element.usageHints & UsageHints.DynamicColor) == 0)
				{
					element.usageHints |= UsageHints.DynamicColor;
				}
				return flag19;
			}
			case StylePropertyId.BorderTopLeftRadius:
				return element.styleAnimation.Start(StylePropertyId.BorderTopLeftRadius, oldStyle.visualData.Read().borderTopLeftRadius, newStyle.visualData.Read().borderTopLeftRadius, durationMs, delayMs, easingCurve);
			case StylePropertyId.BorderTopRightRadius:
				return element.styleAnimation.Start(StylePropertyId.BorderTopRightRadius, oldStyle.visualData.Read().borderTopRightRadius, newStyle.visualData.Read().borderTopRightRadius, durationMs, delayMs, easingCurve);
			case StylePropertyId.BorderTopWidth:
				return element.styleAnimation.Start(StylePropertyId.BorderTopWidth, oldStyle.layoutData.Read().borderTopWidth, newStyle.layoutData.Read().borderTopWidth, durationMs, delayMs, easingCurve);
			case StylePropertyId.BorderWidth:
			{
				bool flag18 = false;
				flag18 |= element.styleAnimation.Start(StylePropertyId.BorderTopWidth, oldStyle.layoutData.Read().borderTopWidth, newStyle.layoutData.Read().borderTopWidth, durationMs, delayMs, easingCurve);
				flag18 |= element.styleAnimation.Start(StylePropertyId.BorderRightWidth, oldStyle.layoutData.Read().borderRightWidth, newStyle.layoutData.Read().borderRightWidth, durationMs, delayMs, easingCurve);
				flag18 |= element.styleAnimation.Start(StylePropertyId.BorderBottomWidth, oldStyle.layoutData.Read().borderBottomWidth, newStyle.layoutData.Read().borderBottomWidth, durationMs, delayMs, easingCurve);
				return flag18 | element.styleAnimation.Start(StylePropertyId.BorderLeftWidth, oldStyle.layoutData.Read().borderLeftWidth, newStyle.layoutData.Read().borderLeftWidth, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.Bottom:
				return element.styleAnimation.Start(StylePropertyId.Bottom, oldStyle.layoutData.Read().bottom, newStyle.layoutData.Read().bottom, durationMs, delayMs, easingCurve);
			case StylePropertyId.Color:
			{
				bool flag17 = element.styleAnimation.Start(StylePropertyId.Color, oldStyle.inheritedData.Read().color, newStyle.inheritedData.Read().color, durationMs, delayMs, easingCurve);
				if (flag17 && (element.usageHints & UsageHints.DynamicColor) == 0)
				{
					element.usageHints |= UsageHints.DynamicColor;
				}
				return flag17;
			}
			case StylePropertyId.Display:
				return element.styleAnimation.StartEnum(StylePropertyId.Display, (int)oldStyle.layoutData.Read().display, (int)newStyle.layoutData.Read().display, durationMs, delayMs, easingCurve);
			case StylePropertyId.Flex:
			{
				bool flag16 = false;
				flag16 |= element.styleAnimation.Start(StylePropertyId.FlexGrow, oldStyle.layoutData.Read().flexGrow, newStyle.layoutData.Read().flexGrow, durationMs, delayMs, easingCurve);
				flag16 |= element.styleAnimation.Start(StylePropertyId.FlexShrink, oldStyle.layoutData.Read().flexShrink, newStyle.layoutData.Read().flexShrink, durationMs, delayMs, easingCurve);
				return flag16 | element.styleAnimation.Start(StylePropertyId.FlexBasis, oldStyle.layoutData.Read().flexBasis, newStyle.layoutData.Read().flexBasis, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.FlexBasis:
				return element.styleAnimation.Start(StylePropertyId.FlexBasis, oldStyle.layoutData.Read().flexBasis, newStyle.layoutData.Read().flexBasis, durationMs, delayMs, easingCurve);
			case StylePropertyId.FlexDirection:
				return element.styleAnimation.StartEnum(StylePropertyId.FlexDirection, (int)oldStyle.layoutData.Read().flexDirection, (int)newStyle.layoutData.Read().flexDirection, durationMs, delayMs, easingCurve);
			case StylePropertyId.FlexGrow:
				return element.styleAnimation.Start(StylePropertyId.FlexGrow, oldStyle.layoutData.Read().flexGrow, newStyle.layoutData.Read().flexGrow, durationMs, delayMs, easingCurve);
			case StylePropertyId.FlexShrink:
				return element.styleAnimation.Start(StylePropertyId.FlexShrink, oldStyle.layoutData.Read().flexShrink, newStyle.layoutData.Read().flexShrink, durationMs, delayMs, easingCurve);
			case StylePropertyId.FlexWrap:
				return element.styleAnimation.StartEnum(StylePropertyId.FlexWrap, (int)oldStyle.layoutData.Read().flexWrap, (int)newStyle.layoutData.Read().flexWrap, durationMs, delayMs, easingCurve);
			case StylePropertyId.FontSize:
				return element.styleAnimation.Start(StylePropertyId.FontSize, oldStyle.inheritedData.Read().fontSize, newStyle.inheritedData.Read().fontSize, durationMs, delayMs, easingCurve);
			case StylePropertyId.Height:
				return element.styleAnimation.Start(StylePropertyId.Height, oldStyle.layoutData.Read().height, newStyle.layoutData.Read().height, durationMs, delayMs, easingCurve);
			case StylePropertyId.JustifyContent:
				return element.styleAnimation.StartEnum(StylePropertyId.JustifyContent, (int)oldStyle.layoutData.Read().justifyContent, (int)newStyle.layoutData.Read().justifyContent, durationMs, delayMs, easingCurve);
			case StylePropertyId.Left:
				return element.styleAnimation.Start(StylePropertyId.Left, oldStyle.layoutData.Read().left, newStyle.layoutData.Read().left, durationMs, delayMs, easingCurve);
			case StylePropertyId.LetterSpacing:
				return element.styleAnimation.Start(StylePropertyId.LetterSpacing, oldStyle.inheritedData.Read().letterSpacing, newStyle.inheritedData.Read().letterSpacing, durationMs, delayMs, easingCurve);
			case StylePropertyId.Margin:
			{
				bool flag15 = false;
				flag15 |= element.styleAnimation.Start(StylePropertyId.MarginTop, oldStyle.layoutData.Read().marginTop, newStyle.layoutData.Read().marginTop, durationMs, delayMs, easingCurve);
				flag15 |= element.styleAnimation.Start(StylePropertyId.MarginRight, oldStyle.layoutData.Read().marginRight, newStyle.layoutData.Read().marginRight, durationMs, delayMs, easingCurve);
				flag15 |= element.styleAnimation.Start(StylePropertyId.MarginBottom, oldStyle.layoutData.Read().marginBottom, newStyle.layoutData.Read().marginBottom, durationMs, delayMs, easingCurve);
				return flag15 | element.styleAnimation.Start(StylePropertyId.MarginLeft, oldStyle.layoutData.Read().marginLeft, newStyle.layoutData.Read().marginLeft, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.MarginBottom:
				return element.styleAnimation.Start(StylePropertyId.MarginBottom, oldStyle.layoutData.Read().marginBottom, newStyle.layoutData.Read().marginBottom, durationMs, delayMs, easingCurve);
			case StylePropertyId.MarginLeft:
				return element.styleAnimation.Start(StylePropertyId.MarginLeft, oldStyle.layoutData.Read().marginLeft, newStyle.layoutData.Read().marginLeft, durationMs, delayMs, easingCurve);
			case StylePropertyId.MarginRight:
				return element.styleAnimation.Start(StylePropertyId.MarginRight, oldStyle.layoutData.Read().marginRight, newStyle.layoutData.Read().marginRight, durationMs, delayMs, easingCurve);
			case StylePropertyId.MarginTop:
				return element.styleAnimation.Start(StylePropertyId.MarginTop, oldStyle.layoutData.Read().marginTop, newStyle.layoutData.Read().marginTop, durationMs, delayMs, easingCurve);
			case StylePropertyId.MaxHeight:
				return element.styleAnimation.Start(StylePropertyId.MaxHeight, oldStyle.layoutData.Read().maxHeight, newStyle.layoutData.Read().maxHeight, durationMs, delayMs, easingCurve);
			case StylePropertyId.MaxWidth:
				return element.styleAnimation.Start(StylePropertyId.MaxWidth, oldStyle.layoutData.Read().maxWidth, newStyle.layoutData.Read().maxWidth, durationMs, delayMs, easingCurve);
			case StylePropertyId.MinHeight:
				return element.styleAnimation.Start(StylePropertyId.MinHeight, oldStyle.layoutData.Read().minHeight, newStyle.layoutData.Read().minHeight, durationMs, delayMs, easingCurve);
			case StylePropertyId.MinWidth:
				return element.styleAnimation.Start(StylePropertyId.MinWidth, oldStyle.layoutData.Read().minWidth, newStyle.layoutData.Read().minWidth, durationMs, delayMs, easingCurve);
			case StylePropertyId.Opacity:
				return element.styleAnimation.Start(StylePropertyId.Opacity, oldStyle.visualData.Read().opacity, newStyle.visualData.Read().opacity, durationMs, delayMs, easingCurve);
			case StylePropertyId.Overflow:
				return element.styleAnimation.StartEnum(StylePropertyId.Overflow, (int)oldStyle.visualData.Read().overflow, (int)newStyle.visualData.Read().overflow, durationMs, delayMs, easingCurve);
			case StylePropertyId.Padding:
			{
				bool flag14 = false;
				flag14 |= element.styleAnimation.Start(StylePropertyId.PaddingTop, oldStyle.layoutData.Read().paddingTop, newStyle.layoutData.Read().paddingTop, durationMs, delayMs, easingCurve);
				flag14 |= element.styleAnimation.Start(StylePropertyId.PaddingRight, oldStyle.layoutData.Read().paddingRight, newStyle.layoutData.Read().paddingRight, durationMs, delayMs, easingCurve);
				flag14 |= element.styleAnimation.Start(StylePropertyId.PaddingBottom, oldStyle.layoutData.Read().paddingBottom, newStyle.layoutData.Read().paddingBottom, durationMs, delayMs, easingCurve);
				return flag14 | element.styleAnimation.Start(StylePropertyId.PaddingLeft, oldStyle.layoutData.Read().paddingLeft, newStyle.layoutData.Read().paddingLeft, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.PaddingBottom:
				return element.styleAnimation.Start(StylePropertyId.PaddingBottom, oldStyle.layoutData.Read().paddingBottom, newStyle.layoutData.Read().paddingBottom, durationMs, delayMs, easingCurve);
			case StylePropertyId.PaddingLeft:
				return element.styleAnimation.Start(StylePropertyId.PaddingLeft, oldStyle.layoutData.Read().paddingLeft, newStyle.layoutData.Read().paddingLeft, durationMs, delayMs, easingCurve);
			case StylePropertyId.PaddingRight:
				return element.styleAnimation.Start(StylePropertyId.PaddingRight, oldStyle.layoutData.Read().paddingRight, newStyle.layoutData.Read().paddingRight, durationMs, delayMs, easingCurve);
			case StylePropertyId.PaddingTop:
				return element.styleAnimation.Start(StylePropertyId.PaddingTop, oldStyle.layoutData.Read().paddingTop, newStyle.layoutData.Read().paddingTop, durationMs, delayMs, easingCurve);
			case StylePropertyId.Position:
				return element.styleAnimation.StartEnum(StylePropertyId.Position, (int)oldStyle.layoutData.Read().position, (int)newStyle.layoutData.Read().position, durationMs, delayMs, easingCurve);
			case StylePropertyId.Right:
				return element.styleAnimation.Start(StylePropertyId.Right, oldStyle.layoutData.Read().right, newStyle.layoutData.Read().right, durationMs, delayMs, easingCurve);
			case StylePropertyId.Rotate:
			{
				bool flag12 = element.styleAnimation.Start(StylePropertyId.Rotate, oldStyle.transformData.Read().rotate, newStyle.transformData.Read().rotate, durationMs, delayMs, easingCurve);
				if (flag12 && (element.usageHints & UsageHints.DynamicTransform) == 0)
				{
					element.usageHints |= UsageHints.DynamicTransform;
				}
				return flag12;
			}
			case StylePropertyId.Scale:
			{
				bool flag9 = element.styleAnimation.Start(StylePropertyId.Scale, oldStyle.transformData.Read().scale, newStyle.transformData.Read().scale, durationMs, delayMs, easingCurve);
				if (flag9 && (element.usageHints & UsageHints.DynamicTransform) == 0)
				{
					element.usageHints |= UsageHints.DynamicTransform;
				}
				return flag9;
			}
			case StylePropertyId.TextOverflow:
				return element.styleAnimation.StartEnum(StylePropertyId.TextOverflow, (int)oldStyle.rareData.Read().textOverflow, (int)newStyle.rareData.Read().textOverflow, durationMs, delayMs, easingCurve);
			case StylePropertyId.TextShadow:
				return element.styleAnimation.Start(StylePropertyId.TextShadow, oldStyle.inheritedData.Read().textShadow, newStyle.inheritedData.Read().textShadow, durationMs, delayMs, easingCurve);
			case StylePropertyId.Top:
				return element.styleAnimation.Start(StylePropertyId.Top, oldStyle.layoutData.Read().top, newStyle.layoutData.Read().top, durationMs, delayMs, easingCurve);
			case StylePropertyId.TransformOrigin:
			{
				bool flag7 = element.styleAnimation.Start(StylePropertyId.TransformOrigin, oldStyle.transformData.Read().transformOrigin, newStyle.transformData.Read().transformOrigin, durationMs, delayMs, easingCurve);
				if (flag7 && (element.usageHints & UsageHints.DynamicTransform) == 0)
				{
					element.usageHints |= UsageHints.DynamicTransform;
				}
				return flag7;
			}
			case StylePropertyId.Translate:
			{
				bool flag5 = element.styleAnimation.Start(StylePropertyId.Translate, oldStyle.transformData.Read().translate, newStyle.transformData.Read().translate, durationMs, delayMs, easingCurve);
				if (flag5 && (element.usageHints & UsageHints.DynamicTransform) == 0)
				{
					element.usageHints |= UsageHints.DynamicTransform;
				}
				return flag5;
			}
			case StylePropertyId.UnityBackgroundImageTintColor:
			{
				bool flag3 = element.styleAnimation.Start(StylePropertyId.UnityBackgroundImageTintColor, oldStyle.rareData.Read().unityBackgroundImageTintColor, newStyle.rareData.Read().unityBackgroundImageTintColor, durationMs, delayMs, easingCurve);
				if (flag3 && (element.usageHints & UsageHints.DynamicColor) == 0)
				{
					element.usageHints |= UsageHints.DynamicColor;
				}
				return flag3;
			}
			case StylePropertyId.UnityBackgroundScaleMode:
			{
				bool flag2 = false;
				flag2 |= element.styleAnimation.Start(StylePropertyId.BackgroundPositionX, oldStyle.visualData.Read().backgroundPositionX, newStyle.visualData.Read().backgroundPositionX, durationMs, delayMs, easingCurve);
				flag2 |= element.styleAnimation.Start(StylePropertyId.BackgroundPositionY, oldStyle.visualData.Read().backgroundPositionY, newStyle.visualData.Read().backgroundPositionY, durationMs, delayMs, easingCurve);
				flag2 |= element.styleAnimation.Start(StylePropertyId.BackgroundRepeat, oldStyle.visualData.Read().backgroundRepeat, newStyle.visualData.Read().backgroundRepeat, durationMs, delayMs, easingCurve);
				return flag2 | element.styleAnimation.Start(StylePropertyId.BackgroundSize, oldStyle.visualData.Read().backgroundSize, newStyle.visualData.Read().backgroundSize, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnityFont:
				return element.styleAnimation.Start(StylePropertyId.UnityFont, oldStyle.inheritedData.Read().unityFont, newStyle.inheritedData.Read().unityFont, durationMs, delayMs, easingCurve);
			case StylePropertyId.UnityFontDefinition:
				return element.styleAnimation.Start(StylePropertyId.UnityFontDefinition, oldStyle.inheritedData.Read().unityFontDefinition, newStyle.inheritedData.Read().unityFontDefinition, durationMs, delayMs, easingCurve);
			case StylePropertyId.UnityFontStyleAndWeight:
				return element.styleAnimation.StartEnum(StylePropertyId.UnityFontStyleAndWeight, (int)oldStyle.inheritedData.Read().unityFontStyleAndWeight, (int)newStyle.inheritedData.Read().unityFontStyleAndWeight, durationMs, delayMs, easingCurve);
			case StylePropertyId.UnityOverflowClipBox:
				return element.styleAnimation.StartEnum(StylePropertyId.UnityOverflowClipBox, (int)oldStyle.rareData.Read().unityOverflowClipBox, (int)newStyle.rareData.Read().unityOverflowClipBox, durationMs, delayMs, easingCurve);
			case StylePropertyId.UnityParagraphSpacing:
				return element.styleAnimation.Start(StylePropertyId.UnityParagraphSpacing, oldStyle.inheritedData.Read().unityParagraphSpacing, newStyle.inheritedData.Read().unityParagraphSpacing, durationMs, delayMs, easingCurve);
			case StylePropertyId.UnitySliceBottom:
				return element.styleAnimation.Start(StylePropertyId.UnitySliceBottom, oldStyle.rareData.Read().unitySliceBottom, newStyle.rareData.Read().unitySliceBottom, durationMs, delayMs, easingCurve);
			case StylePropertyId.UnitySliceLeft:
				return element.styleAnimation.Start(StylePropertyId.UnitySliceLeft, oldStyle.rareData.Read().unitySliceLeft, newStyle.rareData.Read().unitySliceLeft, durationMs, delayMs, easingCurve);
			case StylePropertyId.UnitySliceRight:
				return element.styleAnimation.Start(StylePropertyId.UnitySliceRight, oldStyle.rareData.Read().unitySliceRight, newStyle.rareData.Read().unitySliceRight, durationMs, delayMs, easingCurve);
			case StylePropertyId.UnitySliceScale:
				return element.styleAnimation.Start(StylePropertyId.UnitySliceScale, oldStyle.rareData.Read().unitySliceScale, newStyle.rareData.Read().unitySliceScale, durationMs, delayMs, easingCurve);
			case StylePropertyId.UnitySliceTop:
				return element.styleAnimation.Start(StylePropertyId.UnitySliceTop, oldStyle.rareData.Read().unitySliceTop, newStyle.rareData.Read().unitySliceTop, durationMs, delayMs, easingCurve);
			case StylePropertyId.UnityTextAlign:
				return element.styleAnimation.StartEnum(StylePropertyId.UnityTextAlign, (int)oldStyle.inheritedData.Read().unityTextAlign, (int)newStyle.inheritedData.Read().unityTextAlign, durationMs, delayMs, easingCurve);
			case StylePropertyId.UnityTextOutline:
			{
				bool flag = false;
				flag |= element.styleAnimation.Start(StylePropertyId.UnityTextOutlineColor, oldStyle.inheritedData.Read().unityTextOutlineColor, newStyle.inheritedData.Read().unityTextOutlineColor, durationMs, delayMs, easingCurve);
				return flag | element.styleAnimation.Start(StylePropertyId.UnityTextOutlineWidth, oldStyle.inheritedData.Read().unityTextOutlineWidth, newStyle.inheritedData.Read().unityTextOutlineWidth, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnityTextOutlineColor:
				return element.styleAnimation.Start(StylePropertyId.UnityTextOutlineColor, oldStyle.inheritedData.Read().unityTextOutlineColor, newStyle.inheritedData.Read().unityTextOutlineColor, durationMs, delayMs, easingCurve);
			case StylePropertyId.UnityTextOutlineWidth:
				return element.styleAnimation.Start(StylePropertyId.UnityTextOutlineWidth, oldStyle.inheritedData.Read().unityTextOutlineWidth, newStyle.inheritedData.Read().unityTextOutlineWidth, durationMs, delayMs, easingCurve);
			case StylePropertyId.UnityTextOverflowPosition:
				return element.styleAnimation.StartEnum(StylePropertyId.UnityTextOverflowPosition, (int)oldStyle.rareData.Read().unityTextOverflowPosition, (int)newStyle.rareData.Read().unityTextOverflowPosition, durationMs, delayMs, easingCurve);
			case StylePropertyId.Visibility:
				return element.styleAnimation.StartEnum(StylePropertyId.Visibility, (int)oldStyle.inheritedData.Read().visibility, (int)newStyle.inheritedData.Read().visibility, durationMs, delayMs, easingCurve);
			case StylePropertyId.WhiteSpace:
				return element.styleAnimation.StartEnum(StylePropertyId.WhiteSpace, (int)oldStyle.inheritedData.Read().whiteSpace, (int)newStyle.inheritedData.Read().whiteSpace, durationMs, delayMs, easingCurve);
			case StylePropertyId.Width:
				return element.styleAnimation.Start(StylePropertyId.Width, oldStyle.layoutData.Read().width, newStyle.layoutData.Read().width, durationMs, delayMs, easingCurve);
			case StylePropertyId.WordSpacing:
				return element.styleAnimation.Start(StylePropertyId.WordSpacing, oldStyle.inheritedData.Read().wordSpacing, newStyle.inheritedData.Read().wordSpacing, durationMs, delayMs, easingCurve);
			default:
				return false;
			}
		}

		public static bool StartAnimationAllProperty(VisualElement element, ref ComputedStyle oldStyle, ref ComputedStyle newStyle, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			bool flag = false;
			UsageHints usageHints = UsageHints.None;
			if (!oldStyle.inheritedData.Equals(newStyle.inheritedData))
			{
				ref readonly InheritedData reference = ref oldStyle.inheritedData.Read();
				ref readonly InheritedData reference2 = ref newStyle.inheritedData.Read();
				if (reference.color != reference2.color)
				{
					bool flag2 = element.styleAnimation.Start(StylePropertyId.Color, reference.color, reference2.color, durationMs, delayMs, easingCurve);
					if (flag2)
					{
						usageHints |= UsageHints.DynamicColor;
					}
					flag = flag || flag2;
				}
				if (reference.fontSize != reference2.fontSize)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.FontSize, reference.fontSize, reference2.fontSize, durationMs, delayMs, easingCurve);
				}
				if (reference.letterSpacing != reference2.letterSpacing)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.LetterSpacing, reference.letterSpacing, reference2.letterSpacing, durationMs, delayMs, easingCurve);
				}
				if (reference.textShadow != reference2.textShadow)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.TextShadow, reference.textShadow, reference2.textShadow, durationMs, delayMs, easingCurve);
				}
				if (reference.unityFont != reference2.unityFont)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.UnityFont, reference.unityFont, reference2.unityFont, durationMs, delayMs, easingCurve);
				}
				if (reference.unityFontDefinition != reference2.unityFontDefinition)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.UnityFontDefinition, reference.unityFontDefinition, reference2.unityFontDefinition, durationMs, delayMs, easingCurve);
				}
				if (reference.unityFontStyleAndWeight != reference2.unityFontStyleAndWeight)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.UnityFontStyleAndWeight, (int)reference.unityFontStyleAndWeight, (int)reference2.unityFontStyleAndWeight, durationMs, delayMs, easingCurve);
				}
				if (reference.unityParagraphSpacing != reference2.unityParagraphSpacing)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.UnityParagraphSpacing, reference.unityParagraphSpacing, reference2.unityParagraphSpacing, durationMs, delayMs, easingCurve);
				}
				if (reference.unityTextAlign != reference2.unityTextAlign)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.UnityTextAlign, (int)reference.unityTextAlign, (int)reference2.unityTextAlign, durationMs, delayMs, easingCurve);
				}
				if (reference.unityTextOutlineColor != reference2.unityTextOutlineColor)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.UnityTextOutlineColor, reference.unityTextOutlineColor, reference2.unityTextOutlineColor, durationMs, delayMs, easingCurve);
				}
				if (reference.unityTextOutlineWidth != reference2.unityTextOutlineWidth)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.UnityTextOutlineWidth, reference.unityTextOutlineWidth, reference2.unityTextOutlineWidth, durationMs, delayMs, easingCurve);
				}
				if (reference.visibility != reference2.visibility)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.Visibility, (int)reference.visibility, (int)reference2.visibility, durationMs, delayMs, easingCurve);
				}
				if (reference.whiteSpace != reference2.whiteSpace)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.WhiteSpace, (int)reference.whiteSpace, (int)reference2.whiteSpace, durationMs, delayMs, easingCurve);
				}
				if (reference.wordSpacing != reference2.wordSpacing)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.WordSpacing, reference.wordSpacing, reference2.wordSpacing, durationMs, delayMs, easingCurve);
				}
			}
			if (!oldStyle.layoutData.Equals(newStyle.layoutData))
			{
				ref readonly LayoutData reference3 = ref oldStyle.layoutData.Read();
				ref readonly LayoutData reference4 = ref newStyle.layoutData.Read();
				if (reference3.alignContent != reference4.alignContent)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.AlignContent, (int)reference3.alignContent, (int)reference4.alignContent, durationMs, delayMs, easingCurve);
				}
				if (reference3.alignItems != reference4.alignItems)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.AlignItems, (int)reference3.alignItems, (int)reference4.alignItems, durationMs, delayMs, easingCurve);
				}
				if (reference3.alignSelf != reference4.alignSelf)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.AlignSelf, (int)reference3.alignSelf, (int)reference4.alignSelf, durationMs, delayMs, easingCurve);
				}
				if (reference3.borderBottomWidth != reference4.borderBottomWidth)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.BorderBottomWidth, reference3.borderBottomWidth, reference4.borderBottomWidth, durationMs, delayMs, easingCurve);
				}
				if (reference3.borderLeftWidth != reference4.borderLeftWidth)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.BorderLeftWidth, reference3.borderLeftWidth, reference4.borderLeftWidth, durationMs, delayMs, easingCurve);
				}
				if (reference3.borderRightWidth != reference4.borderRightWidth)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.BorderRightWidth, reference3.borderRightWidth, reference4.borderRightWidth, durationMs, delayMs, easingCurve);
				}
				if (reference3.borderTopWidth != reference4.borderTopWidth)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.BorderTopWidth, reference3.borderTopWidth, reference4.borderTopWidth, durationMs, delayMs, easingCurve);
				}
				if (reference3.bottom != reference4.bottom)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.Bottom, reference3.bottom, reference4.bottom, durationMs, delayMs, easingCurve);
				}
				if (reference3.display != reference4.display)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.Display, (int)reference3.display, (int)reference4.display, durationMs, delayMs, easingCurve);
				}
				if (reference3.flexBasis != reference4.flexBasis)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.FlexBasis, reference3.flexBasis, reference4.flexBasis, durationMs, delayMs, easingCurve);
				}
				if (reference3.flexDirection != reference4.flexDirection)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.FlexDirection, (int)reference3.flexDirection, (int)reference4.flexDirection, durationMs, delayMs, easingCurve);
				}
				if (reference3.flexGrow != reference4.flexGrow)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.FlexGrow, reference3.flexGrow, reference4.flexGrow, durationMs, delayMs, easingCurve);
				}
				if (reference3.flexShrink != reference4.flexShrink)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.FlexShrink, reference3.flexShrink, reference4.flexShrink, durationMs, delayMs, easingCurve);
				}
				if (reference3.flexWrap != reference4.flexWrap)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.FlexWrap, (int)reference3.flexWrap, (int)reference4.flexWrap, durationMs, delayMs, easingCurve);
				}
				if (reference3.height != reference4.height)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.Height, reference3.height, reference4.height, durationMs, delayMs, easingCurve);
				}
				if (reference3.justifyContent != reference4.justifyContent)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.JustifyContent, (int)reference3.justifyContent, (int)reference4.justifyContent, durationMs, delayMs, easingCurve);
				}
				if (reference3.left != reference4.left)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.Left, reference3.left, reference4.left, durationMs, delayMs, easingCurve);
				}
				if (reference3.marginBottom != reference4.marginBottom)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.MarginBottom, reference3.marginBottom, reference4.marginBottom, durationMs, delayMs, easingCurve);
				}
				if (reference3.marginLeft != reference4.marginLeft)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.MarginLeft, reference3.marginLeft, reference4.marginLeft, durationMs, delayMs, easingCurve);
				}
				if (reference3.marginRight != reference4.marginRight)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.MarginRight, reference3.marginRight, reference4.marginRight, durationMs, delayMs, easingCurve);
				}
				if (reference3.marginTop != reference4.marginTop)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.MarginTop, reference3.marginTop, reference4.marginTop, durationMs, delayMs, easingCurve);
				}
				if (reference3.maxHeight != reference4.maxHeight)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.MaxHeight, reference3.maxHeight, reference4.maxHeight, durationMs, delayMs, easingCurve);
				}
				if (reference3.maxWidth != reference4.maxWidth)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.MaxWidth, reference3.maxWidth, reference4.maxWidth, durationMs, delayMs, easingCurve);
				}
				if (reference3.minHeight != reference4.minHeight)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.MinHeight, reference3.minHeight, reference4.minHeight, durationMs, delayMs, easingCurve);
				}
				if (reference3.minWidth != reference4.minWidth)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.MinWidth, reference3.minWidth, reference4.minWidth, durationMs, delayMs, easingCurve);
				}
				if (reference3.paddingBottom != reference4.paddingBottom)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.PaddingBottom, reference3.paddingBottom, reference4.paddingBottom, durationMs, delayMs, easingCurve);
				}
				if (reference3.paddingLeft != reference4.paddingLeft)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.PaddingLeft, reference3.paddingLeft, reference4.paddingLeft, durationMs, delayMs, easingCurve);
				}
				if (reference3.paddingRight != reference4.paddingRight)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.PaddingRight, reference3.paddingRight, reference4.paddingRight, durationMs, delayMs, easingCurve);
				}
				if (reference3.paddingTop != reference4.paddingTop)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.PaddingTop, reference3.paddingTop, reference4.paddingTop, durationMs, delayMs, easingCurve);
				}
				if (reference3.position != reference4.position)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.Position, (int)reference3.position, (int)reference4.position, durationMs, delayMs, easingCurve);
				}
				if (reference3.right != reference4.right)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.Right, reference3.right, reference4.right, durationMs, delayMs, easingCurve);
				}
				if (reference3.top != reference4.top)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.Top, reference3.top, reference4.top, durationMs, delayMs, easingCurve);
				}
				if (reference3.width != reference4.width)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.Width, reference3.width, reference4.width, durationMs, delayMs, easingCurve);
				}
			}
			if (!oldStyle.rareData.Equals(newStyle.rareData))
			{
				ref readonly RareData reference5 = ref oldStyle.rareData.Read();
				ref readonly RareData reference6 = ref newStyle.rareData.Read();
				if (reference5.textOverflow != reference6.textOverflow)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.TextOverflow, (int)reference5.textOverflow, (int)reference6.textOverflow, durationMs, delayMs, easingCurve);
				}
				if (reference5.unityBackgroundImageTintColor != reference6.unityBackgroundImageTintColor)
				{
					bool flag3 = element.styleAnimation.Start(StylePropertyId.UnityBackgroundImageTintColor, reference5.unityBackgroundImageTintColor, reference6.unityBackgroundImageTintColor, durationMs, delayMs, easingCurve);
					if (flag3)
					{
						usageHints |= UsageHints.DynamicColor;
					}
					flag = flag || flag3;
				}
				if (reference5.unityOverflowClipBox != reference6.unityOverflowClipBox)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.UnityOverflowClipBox, (int)reference5.unityOverflowClipBox, (int)reference6.unityOverflowClipBox, durationMs, delayMs, easingCurve);
				}
				if (reference5.unitySliceBottom != reference6.unitySliceBottom)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.UnitySliceBottom, reference5.unitySliceBottom, reference6.unitySliceBottom, durationMs, delayMs, easingCurve);
				}
				if (reference5.unitySliceLeft != reference6.unitySliceLeft)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.UnitySliceLeft, reference5.unitySliceLeft, reference6.unitySliceLeft, durationMs, delayMs, easingCurve);
				}
				if (reference5.unitySliceRight != reference6.unitySliceRight)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.UnitySliceRight, reference5.unitySliceRight, reference6.unitySliceRight, durationMs, delayMs, easingCurve);
				}
				if (reference5.unitySliceScale != reference6.unitySliceScale)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.UnitySliceScale, reference5.unitySliceScale, reference6.unitySliceScale, durationMs, delayMs, easingCurve);
				}
				if (reference5.unitySliceTop != reference6.unitySliceTop)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.UnitySliceTop, reference5.unitySliceTop, reference6.unitySliceTop, durationMs, delayMs, easingCurve);
				}
				if (reference5.unityTextOverflowPosition != reference6.unityTextOverflowPosition)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.UnityTextOverflowPosition, (int)reference5.unityTextOverflowPosition, (int)reference6.unityTextOverflowPosition, durationMs, delayMs, easingCurve);
				}
			}
			if (!oldStyle.transformData.Equals(newStyle.transformData))
			{
				ref readonly TransformData reference7 = ref oldStyle.transformData.Read();
				ref readonly TransformData reference8 = ref newStyle.transformData.Read();
				if (reference7.rotate != reference8.rotate)
				{
					bool flag4 = element.styleAnimation.Start(StylePropertyId.Rotate, reference7.rotate, reference8.rotate, durationMs, delayMs, easingCurve);
					if (flag4)
					{
						usageHints |= UsageHints.DynamicTransform;
					}
					flag = flag || flag4;
				}
				if (reference7.scale != reference8.scale)
				{
					bool flag5 = element.styleAnimation.Start(StylePropertyId.Scale, reference7.scale, reference8.scale, durationMs, delayMs, easingCurve);
					if (flag5)
					{
						usageHints |= UsageHints.DynamicTransform;
					}
					flag = flag || flag5;
				}
				if (reference7.transformOrigin != reference8.transformOrigin)
				{
					bool flag6 = element.styleAnimation.Start(StylePropertyId.TransformOrigin, reference7.transformOrigin, reference8.transformOrigin, durationMs, delayMs, easingCurve);
					if (flag6)
					{
						usageHints |= UsageHints.DynamicTransform;
					}
					flag = flag || flag6;
				}
				if (reference7.translate != reference8.translate)
				{
					bool flag7 = element.styleAnimation.Start(StylePropertyId.Translate, reference7.translate, reference8.translate, durationMs, delayMs, easingCurve);
					if (flag7)
					{
						usageHints |= UsageHints.DynamicTransform;
					}
					flag = flag || flag7;
				}
			}
			if (!oldStyle.visualData.Equals(newStyle.visualData))
			{
				ref readonly VisualData reference9 = ref oldStyle.visualData.Read();
				ref readonly VisualData reference10 = ref newStyle.visualData.Read();
				if (reference9.backgroundColor != reference10.backgroundColor)
				{
					bool flag8 = element.styleAnimation.Start(StylePropertyId.BackgroundColor, reference9.backgroundColor, reference10.backgroundColor, durationMs, delayMs, easingCurve);
					if (flag8)
					{
						usageHints |= UsageHints.DynamicColor;
					}
					flag = flag || flag8;
				}
				if (reference9.backgroundImage != reference10.backgroundImage)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.BackgroundImage, reference9.backgroundImage, reference10.backgroundImage, durationMs, delayMs, easingCurve);
				}
				if (reference9.backgroundPositionX != reference10.backgroundPositionX)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.BackgroundPositionX, reference9.backgroundPositionX, reference10.backgroundPositionX, durationMs, delayMs, easingCurve);
				}
				if (reference9.backgroundPositionY != reference10.backgroundPositionY)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.BackgroundPositionY, reference9.backgroundPositionY, reference10.backgroundPositionY, durationMs, delayMs, easingCurve);
				}
				if (reference9.backgroundRepeat != reference10.backgroundRepeat)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.BackgroundRepeat, reference9.backgroundRepeat, reference10.backgroundRepeat, durationMs, delayMs, easingCurve);
				}
				if (reference9.backgroundSize != reference10.backgroundSize)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.BackgroundSize, reference9.backgroundSize, reference10.backgroundSize, durationMs, delayMs, easingCurve);
				}
				if (reference9.borderBottomColor != reference10.borderBottomColor)
				{
					bool flag9 = element.styleAnimation.Start(StylePropertyId.BorderBottomColor, reference9.borderBottomColor, reference10.borderBottomColor, durationMs, delayMs, easingCurve);
					if (flag9)
					{
						usageHints |= UsageHints.DynamicColor;
					}
					flag = flag || flag9;
				}
				if (reference9.borderBottomLeftRadius != reference10.borderBottomLeftRadius)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.BorderBottomLeftRadius, reference9.borderBottomLeftRadius, reference10.borderBottomLeftRadius, durationMs, delayMs, easingCurve);
				}
				if (reference9.borderBottomRightRadius != reference10.borderBottomRightRadius)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.BorderBottomRightRadius, reference9.borderBottomRightRadius, reference10.borderBottomRightRadius, durationMs, delayMs, easingCurve);
				}
				if (reference9.borderLeftColor != reference10.borderLeftColor)
				{
					bool flag10 = element.styleAnimation.Start(StylePropertyId.BorderLeftColor, reference9.borderLeftColor, reference10.borderLeftColor, durationMs, delayMs, easingCurve);
					if (flag10)
					{
						usageHints |= UsageHints.DynamicColor;
					}
					flag = flag || flag10;
				}
				if (reference9.borderRightColor != reference10.borderRightColor)
				{
					bool flag11 = element.styleAnimation.Start(StylePropertyId.BorderRightColor, reference9.borderRightColor, reference10.borderRightColor, durationMs, delayMs, easingCurve);
					if (flag11)
					{
						usageHints |= UsageHints.DynamicColor;
					}
					flag = flag || flag11;
				}
				if (reference9.borderTopColor != reference10.borderTopColor)
				{
					bool flag12 = element.styleAnimation.Start(StylePropertyId.BorderTopColor, reference9.borderTopColor, reference10.borderTopColor, durationMs, delayMs, easingCurve);
					if (flag12)
					{
						usageHints |= UsageHints.DynamicColor;
					}
					flag = flag || flag12;
				}
				if (reference9.borderTopLeftRadius != reference10.borderTopLeftRadius)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.BorderTopLeftRadius, reference9.borderTopLeftRadius, reference10.borderTopLeftRadius, durationMs, delayMs, easingCurve);
				}
				if (reference9.borderTopRightRadius != reference10.borderTopRightRadius)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.BorderTopRightRadius, reference9.borderTopRightRadius, reference10.borderTopRightRadius, durationMs, delayMs, easingCurve);
				}
				if (reference9.opacity != reference10.opacity)
				{
					flag |= element.styleAnimation.Start(StylePropertyId.Opacity, reference9.opacity, reference10.opacity, durationMs, delayMs, easingCurve);
				}
				if (reference9.overflow != reference10.overflow)
				{
					flag |= element.styleAnimation.StartEnum(StylePropertyId.Overflow, (int)reference9.overflow, (int)reference10.overflow, durationMs, delayMs, easingCurve);
				}
			}
			if (usageHints != UsageHints.None)
			{
				element.usageHints |= usageHints;
			}
			return flag;
		}

		public static bool StartAnimationInline(VisualElement element, StylePropertyId id, ref ComputedStyle computedStyle, StyleValue sv, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			switch (id)
			{
			case StylePropertyId.AlignContent:
			{
				Align to31 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.alignContent : ((Align)sv.number));
				if (sv.keyword == StyleKeyword.Auto)
				{
					to31 = Align.Auto;
				}
				return element.styleAnimation.StartEnum(StylePropertyId.AlignContent, (int)computedStyle.layoutData.Read().alignContent, (int)to31, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.AlignItems:
			{
				Align to60 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.alignItems : ((Align)sv.number));
				if (sv.keyword == StyleKeyword.Auto)
				{
					to60 = Align.Auto;
				}
				return element.styleAnimation.StartEnum(StylePropertyId.AlignItems, (int)computedStyle.layoutData.Read().alignItems, (int)to60, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.AlignSelf:
			{
				Align to70 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.alignSelf : ((Align)sv.number));
				if (sv.keyword == StyleKeyword.Auto)
				{
					to70 = Align.Auto;
				}
				return element.styleAnimation.StartEnum(StylePropertyId.AlignSelf, (int)computedStyle.layoutData.Read().alignSelf, (int)to70, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.BackgroundColor:
			{
				Color to54 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.backgroundColor : sv.color);
				bool flag6 = element.styleAnimation.Start(StylePropertyId.BackgroundColor, computedStyle.visualData.Read().backgroundColor, to54, durationMs, delayMs, easingCurve);
				if (flag6 && (element.usageHints & UsageHints.DynamicColor) == 0)
				{
					element.usageHints |= UsageHints.DynamicColor;
				}
				return flag6;
			}
			case StylePropertyId.BackgroundImage:
			{
				Background to68 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.backgroundImage : (sv.resource.IsAllocated ? Background.FromObject(sv.resource.Target) : default(Background)));
				return element.styleAnimation.Start(StylePropertyId.BackgroundImage, computedStyle.visualData.Read().backgroundImage, to68, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.BackgroundPositionX:
			{
				BackgroundPosition to24 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.backgroundPositionX : sv.position);
				return element.styleAnimation.Start(StylePropertyId.BackgroundPositionX, computedStyle.visualData.Read().backgroundPositionX, to24, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.BackgroundPositionY:
			{
				BackgroundPosition to10 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.backgroundPositionY : sv.position);
				return element.styleAnimation.Start(StylePropertyId.BackgroundPositionY, computedStyle.visualData.Read().backgroundPositionY, to10, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.BackgroundRepeat:
			{
				BackgroundRepeat to16 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.backgroundRepeat : sv.repeat);
				return element.styleAnimation.Start(StylePropertyId.BackgroundRepeat, computedStyle.visualData.Read().backgroundRepeat, to16, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.BorderBottomColor:
			{
				Color to46 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.borderBottomColor : sv.color);
				bool flag5 = element.styleAnimation.Start(StylePropertyId.BorderBottomColor, computedStyle.visualData.Read().borderBottomColor, to46, durationMs, delayMs, easingCurve);
				if (flag5 && (element.usageHints & UsageHints.DynamicColor) == 0)
				{
					element.usageHints |= UsageHints.DynamicColor;
				}
				return flag5;
			}
			case StylePropertyId.BorderBottomLeftRadius:
			{
				Length to6 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.borderBottomLeftRadius : sv.length);
				return element.styleAnimation.Start(StylePropertyId.BorderBottomLeftRadius, computedStyle.visualData.Read().borderBottomLeftRadius, to6, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.BorderBottomRightRadius:
			{
				Length to35 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.borderBottomRightRadius : sv.length);
				return element.styleAnimation.Start(StylePropertyId.BorderBottomRightRadius, computedStyle.visualData.Read().borderBottomRightRadius, to35, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.BorderBottomWidth:
			{
				float to36 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.borderBottomWidth : sv.number);
				return element.styleAnimation.Start(StylePropertyId.BorderBottomWidth, computedStyle.layoutData.Read().borderBottomWidth, to36, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.BorderLeftColor:
			{
				Color to56 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.borderLeftColor : sv.color);
				bool flag7 = element.styleAnimation.Start(StylePropertyId.BorderLeftColor, computedStyle.visualData.Read().borderLeftColor, to56, durationMs, delayMs, easingCurve);
				if (flag7 && (element.usageHints & UsageHints.DynamicColor) == 0)
				{
					element.usageHints |= UsageHints.DynamicColor;
				}
				return flag7;
			}
			case StylePropertyId.BorderLeftWidth:
			{
				float to30 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.borderLeftWidth : sv.number);
				return element.styleAnimation.Start(StylePropertyId.BorderLeftWidth, computedStyle.layoutData.Read().borderLeftWidth, to30, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.BorderRightColor:
			{
				Color to2 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.borderRightColor : sv.color);
				bool flag = element.styleAnimation.Start(StylePropertyId.BorderRightColor, computedStyle.visualData.Read().borderRightColor, to2, durationMs, delayMs, easingCurve);
				if (flag && (element.usageHints & UsageHints.DynamicColor) == 0)
				{
					element.usageHints |= UsageHints.DynamicColor;
				}
				return flag;
			}
			case StylePropertyId.BorderRightWidth:
			{
				float to52 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.borderRightWidth : sv.number);
				return element.styleAnimation.Start(StylePropertyId.BorderRightWidth, computedStyle.layoutData.Read().borderRightWidth, to52, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.BorderTopColor:
			{
				Color to28 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.borderTopColor : sv.color);
				bool flag4 = element.styleAnimation.Start(StylePropertyId.BorderTopColor, computedStyle.visualData.Read().borderTopColor, to28, durationMs, delayMs, easingCurve);
				if (flag4 && (element.usageHints & UsageHints.DynamicColor) == 0)
				{
					element.usageHints |= UsageHints.DynamicColor;
				}
				return flag4;
			}
			case StylePropertyId.BorderTopLeftRadius:
			{
				Length to22 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.borderTopLeftRadius : sv.length);
				return element.styleAnimation.Start(StylePropertyId.BorderTopLeftRadius, computedStyle.visualData.Read().borderTopLeftRadius, to22, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.BorderTopRightRadius:
			{
				Length to63 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.borderTopRightRadius : sv.length);
				return element.styleAnimation.Start(StylePropertyId.BorderTopRightRadius, computedStyle.visualData.Read().borderTopRightRadius, to63, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.BorderTopWidth:
			{
				float to58 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.borderTopWidth : sv.number);
				return element.styleAnimation.Start(StylePropertyId.BorderTopWidth, computedStyle.layoutData.Read().borderTopWidth, to58, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.Bottom:
			{
				Length to40 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.bottom : sv.length);
				return element.styleAnimation.Start(StylePropertyId.Bottom, computedStyle.layoutData.Read().bottom, to40, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.Color:
			{
				Color to15 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.color : sv.color);
				bool flag3 = element.styleAnimation.Start(StylePropertyId.Color, computedStyle.inheritedData.Read().color, to15, durationMs, delayMs, easingCurve);
				if (flag3 && (element.usageHints & UsageHints.DynamicColor) == 0)
				{
					element.usageHints |= UsageHints.DynamicColor;
				}
				return flag3;
			}
			case StylePropertyId.Display:
			{
				DisplayStyle to3 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.display : ((DisplayStyle)sv.number));
				if (sv.keyword == StyleKeyword.None)
				{
					to3 = DisplayStyle.None;
				}
				return element.styleAnimation.StartEnum(StylePropertyId.Display, (int)computedStyle.layoutData.Read().display, (int)to3, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.FlexBasis:
			{
				Length to69 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.flexBasis : sv.length);
				return element.styleAnimation.Start(StylePropertyId.FlexBasis, computedStyle.layoutData.Read().flexBasis, to69, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.FlexDirection:
			{
				FlexDirection to51 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.flexDirection : ((FlexDirection)sv.number));
				return element.styleAnimation.StartEnum(StylePropertyId.FlexDirection, (int)computedStyle.layoutData.Read().flexDirection, (int)to51, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.FlexGrow:
			{
				float to42 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.flexGrow : sv.number);
				return element.styleAnimation.Start(StylePropertyId.FlexGrow, computedStyle.layoutData.Read().flexGrow, to42, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.FlexShrink:
			{
				float to43 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.flexShrink : sv.number);
				return element.styleAnimation.Start(StylePropertyId.FlexShrink, computedStyle.layoutData.Read().flexShrink, to43, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.FlexWrap:
			{
				Wrap to27 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.flexWrap : ((Wrap)sv.number));
				return element.styleAnimation.StartEnum(StylePropertyId.FlexWrap, (int)computedStyle.layoutData.Read().flexWrap, (int)to27, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.FontSize:
			{
				Length to14 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.fontSize : sv.length);
				return element.styleAnimation.Start(StylePropertyId.FontSize, computedStyle.inheritedData.Read().fontSize, to14, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.Height:
			{
				Length to11 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.height : sv.length);
				return element.styleAnimation.Start(StylePropertyId.Height, computedStyle.layoutData.Read().height, to11, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.JustifyContent:
			{
				Justify to67 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.justifyContent : ((Justify)sv.number));
				return element.styleAnimation.StartEnum(StylePropertyId.JustifyContent, (int)computedStyle.layoutData.Read().justifyContent, (int)to67, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.Left:
			{
				Length to62 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.left : sv.length);
				return element.styleAnimation.Start(StylePropertyId.Left, computedStyle.layoutData.Read().left, to62, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.LetterSpacing:
			{
				Length to59 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.letterSpacing : sv.length);
				return element.styleAnimation.Start(StylePropertyId.LetterSpacing, computedStyle.inheritedData.Read().letterSpacing, to59, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.MarginBottom:
			{
				Length to47 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.marginBottom : sv.length);
				return element.styleAnimation.Start(StylePropertyId.MarginBottom, computedStyle.layoutData.Read().marginBottom, to47, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.MarginLeft:
			{
				Length to44 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.marginLeft : sv.length);
				return element.styleAnimation.Start(StylePropertyId.MarginLeft, computedStyle.layoutData.Read().marginLeft, to44, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.MarginRight:
			{
				Length to38 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.marginRight : sv.length);
				return element.styleAnimation.Start(StylePropertyId.MarginRight, computedStyle.layoutData.Read().marginRight, to38, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.MarginTop:
			{
				Length to26 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.marginTop : sv.length);
				return element.styleAnimation.Start(StylePropertyId.MarginTop, computedStyle.layoutData.Read().marginTop, to26, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.MaxHeight:
			{
				Length to19 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.maxHeight : sv.length);
				return element.styleAnimation.Start(StylePropertyId.MaxHeight, computedStyle.layoutData.Read().maxHeight, to19, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.MaxWidth:
			{
				Length to20 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.maxWidth : sv.length);
				return element.styleAnimation.Start(StylePropertyId.MaxWidth, computedStyle.layoutData.Read().maxWidth, to20, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.MinHeight:
			{
				Length to8 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.minHeight : sv.length);
				return element.styleAnimation.Start(StylePropertyId.MinHeight, computedStyle.layoutData.Read().minHeight, to8, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.MinWidth:
			{
				Length to7 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.minWidth : sv.length);
				return element.styleAnimation.Start(StylePropertyId.MinWidth, computedStyle.layoutData.Read().minWidth, to7, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.Opacity:
			{
				float to66 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.opacity : sv.number);
				return element.styleAnimation.Start(StylePropertyId.Opacity, computedStyle.visualData.Read().opacity, to66, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.Overflow:
			{
				OverflowInternal to64 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.overflow : ((OverflowInternal)sv.number));
				return element.styleAnimation.StartEnum(StylePropertyId.Overflow, (int)computedStyle.visualData.Read().overflow, (int)to64, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.PaddingBottom:
			{
				Length to55 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.paddingBottom : sv.length);
				return element.styleAnimation.Start(StylePropertyId.PaddingBottom, computedStyle.layoutData.Read().paddingBottom, to55, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.PaddingLeft:
			{
				Length to50 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.paddingLeft : sv.length);
				return element.styleAnimation.Start(StylePropertyId.PaddingLeft, computedStyle.layoutData.Read().paddingLeft, to50, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.PaddingRight:
			{
				Length to48 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.paddingRight : sv.length);
				return element.styleAnimation.Start(StylePropertyId.PaddingRight, computedStyle.layoutData.Read().paddingRight, to48, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.PaddingTop:
			{
				Length to39 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.paddingTop : sv.length);
				return element.styleAnimation.Start(StylePropertyId.PaddingTop, computedStyle.layoutData.Read().paddingTop, to39, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.Position:
			{
				Position to34 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.position : ((Position)sv.number));
				return element.styleAnimation.StartEnum(StylePropertyId.Position, (int)computedStyle.layoutData.Read().position, (int)to34, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.Right:
			{
				Length to32 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.right : sv.length);
				return element.styleAnimation.Start(StylePropertyId.Right, computedStyle.layoutData.Read().right, to32, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.TextOverflow:
			{
				TextOverflow to23 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.textOverflow : ((TextOverflow)sv.number));
				return element.styleAnimation.StartEnum(StylePropertyId.TextOverflow, (int)computedStyle.rareData.Read().textOverflow, (int)to23, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.Top:
			{
				Length to18 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.top : sv.length);
				return element.styleAnimation.Start(StylePropertyId.Top, computedStyle.layoutData.Read().top, to18, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnityBackgroundImageTintColor:
			{
				Color to12 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.unityBackgroundImageTintColor : sv.color);
				bool flag2 = element.styleAnimation.Start(StylePropertyId.UnityBackgroundImageTintColor, computedStyle.rareData.Read().unityBackgroundImageTintColor, to12, durationMs, delayMs, easingCurve);
				if (flag2 && (element.usageHints & UsageHints.DynamicColor) == 0)
				{
					element.usageHints |= UsageHints.DynamicColor;
				}
				return flag2;
			}
			case StylePropertyId.UnityFont:
			{
				Font to4 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.unityFont : (sv.resource.IsAllocated ? (sv.resource.Target as Font) : null));
				return element.styleAnimation.Start(StylePropertyId.UnityFont, computedStyle.inheritedData.Read().unityFont, to4, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnityFontDefinition:
			{
				FontDefinition to65 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.unityFontDefinition : (sv.resource.IsAllocated ? FontDefinition.FromObject(sv.resource.Target) : default(FontDefinition)));
				return element.styleAnimation.Start(StylePropertyId.UnityFontDefinition, computedStyle.inheritedData.Read().unityFontDefinition, to65, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnityFontStyleAndWeight:
			{
				FontStyle to61 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.unityFontStyleAndWeight : ((FontStyle)sv.number));
				return element.styleAnimation.StartEnum(StylePropertyId.UnityFontStyleAndWeight, (int)computedStyle.inheritedData.Read().unityFontStyleAndWeight, (int)to61, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnityOverflowClipBox:
			{
				OverflowClipBox to57 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.unityOverflowClipBox : ((OverflowClipBox)sv.number));
				return element.styleAnimation.StartEnum(StylePropertyId.UnityOverflowClipBox, (int)computedStyle.rareData.Read().unityOverflowClipBox, (int)to57, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnityParagraphSpacing:
			{
				Length to53 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.unityParagraphSpacing : sv.length);
				return element.styleAnimation.Start(StylePropertyId.UnityParagraphSpacing, computedStyle.inheritedData.Read().unityParagraphSpacing, to53, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnitySliceBottom:
			{
				int to49 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.unitySliceBottom : ((int)sv.number));
				return element.styleAnimation.Start(StylePropertyId.UnitySliceBottom, computedStyle.rareData.Read().unitySliceBottom, to49, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnitySliceLeft:
			{
				int to45 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.unitySliceLeft : ((int)sv.number));
				return element.styleAnimation.Start(StylePropertyId.UnitySliceLeft, computedStyle.rareData.Read().unitySliceLeft, to45, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnitySliceRight:
			{
				int to41 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.unitySliceRight : ((int)sv.number));
				return element.styleAnimation.Start(StylePropertyId.UnitySliceRight, computedStyle.rareData.Read().unitySliceRight, to41, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnitySliceScale:
			{
				float to37 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.unitySliceScale : sv.number);
				return element.styleAnimation.Start(StylePropertyId.UnitySliceScale, computedStyle.rareData.Read().unitySliceScale, to37, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnitySliceTop:
			{
				int to33 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.unitySliceTop : ((int)sv.number));
				return element.styleAnimation.Start(StylePropertyId.UnitySliceTop, computedStyle.rareData.Read().unitySliceTop, to33, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnityTextAlign:
			{
				TextAnchor to29 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.unityTextAlign : ((TextAnchor)sv.number));
				return element.styleAnimation.StartEnum(StylePropertyId.UnityTextAlign, (int)computedStyle.inheritedData.Read().unityTextAlign, (int)to29, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnityTextOutlineColor:
			{
				Color to25 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.unityTextOutlineColor : sv.color);
				return element.styleAnimation.Start(StylePropertyId.UnityTextOutlineColor, computedStyle.inheritedData.Read().unityTextOutlineColor, to25, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnityTextOutlineWidth:
			{
				float to21 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.unityTextOutlineWidth : sv.number);
				return element.styleAnimation.Start(StylePropertyId.UnityTextOutlineWidth, computedStyle.inheritedData.Read().unityTextOutlineWidth, to21, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.UnityTextOverflowPosition:
			{
				TextOverflowPosition to17 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.unityTextOverflowPosition : ((TextOverflowPosition)sv.number));
				return element.styleAnimation.StartEnum(StylePropertyId.UnityTextOverflowPosition, (int)computedStyle.rareData.Read().unityTextOverflowPosition, (int)to17, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.Visibility:
			{
				Visibility to13 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.visibility : ((Visibility)sv.number));
				return element.styleAnimation.StartEnum(StylePropertyId.Visibility, (int)computedStyle.inheritedData.Read().visibility, (int)to13, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.WhiteSpace:
			{
				WhiteSpace to9 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.whiteSpace : ((WhiteSpace)sv.number));
				return element.styleAnimation.StartEnum(StylePropertyId.WhiteSpace, (int)computedStyle.inheritedData.Read().whiteSpace, (int)to9, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.Width:
			{
				Length to5 = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.width : sv.length);
				return element.styleAnimation.Start(StylePropertyId.Width, computedStyle.layoutData.Read().width, to5, durationMs, delayMs, easingCurve);
			}
			case StylePropertyId.WordSpacing:
			{
				Length to = ((sv.keyword == StyleKeyword.Initial) ? InitialStyle.wordSpacing : sv.length);
				return element.styleAnimation.Start(StylePropertyId.WordSpacing, computedStyle.inheritedData.Read().wordSpacing, to, durationMs, delayMs, easingCurve);
			}
			default:
				return false;
			}
		}

		public void ApplyStyleTransformOrigin(TransformOrigin st)
		{
			transformData.Write().transformOrigin = st;
		}

		public void ApplyStyleTranslate(Translate translateValue)
		{
			transformData.Write().translate = translateValue;
		}

		public void ApplyStyleRotate(Rotate rotateValue)
		{
			transformData.Write().rotate = rotateValue;
		}

		public void ApplyStyleScale(Scale scaleValue)
		{
			transformData.Write().scale = scaleValue;
		}

		public void ApplyStyleBackgroundSize(BackgroundSize backgroundSizeValue)
		{
			visualData.Write().backgroundSize = backgroundSizeValue;
		}

		public void ApplyInitialValue(StylePropertyReader reader)
		{
			switch (reader.propertyId)
			{
			case StylePropertyId.Custom:
				RemoveCustomStyleProperty(reader);
				break;
			case StylePropertyId.All:
				ApplyAllPropertyInitial();
				break;
			default:
				ApplyInitialValue(reader.propertyId);
				break;
			}
		}

		public void ApplyInitialValue(StylePropertyId id)
		{
			switch (id)
			{
			case StylePropertyId.AlignContent:
				layoutData.Write().alignContent = InitialStyle.alignContent;
				break;
			case StylePropertyId.AlignItems:
				layoutData.Write().alignItems = InitialStyle.alignItems;
				break;
			case StylePropertyId.AlignSelf:
				layoutData.Write().alignSelf = InitialStyle.alignSelf;
				break;
			case StylePropertyId.All:
				break;
			case StylePropertyId.BackgroundColor:
				visualData.Write().backgroundColor = InitialStyle.backgroundColor;
				break;
			case StylePropertyId.BackgroundImage:
				visualData.Write().backgroundImage = InitialStyle.backgroundImage;
				break;
			case StylePropertyId.BackgroundPosition:
				visualData.Write().backgroundPositionX = InitialStyle.backgroundPositionX;
				visualData.Write().backgroundPositionY = InitialStyle.backgroundPositionY;
				break;
			case StylePropertyId.BackgroundPositionX:
				visualData.Write().backgroundPositionX = InitialStyle.backgroundPositionX;
				break;
			case StylePropertyId.BackgroundPositionY:
				visualData.Write().backgroundPositionY = InitialStyle.backgroundPositionY;
				break;
			case StylePropertyId.BackgroundRepeat:
				visualData.Write().backgroundRepeat = InitialStyle.backgroundRepeat;
				break;
			case StylePropertyId.BackgroundSize:
				visualData.Write().backgroundSize = InitialStyle.backgroundSize;
				break;
			case StylePropertyId.BorderBottomColor:
				visualData.Write().borderBottomColor = InitialStyle.borderBottomColor;
				break;
			case StylePropertyId.BorderBottomLeftRadius:
				visualData.Write().borderBottomLeftRadius = InitialStyle.borderBottomLeftRadius;
				break;
			case StylePropertyId.BorderBottomRightRadius:
				visualData.Write().borderBottomRightRadius = InitialStyle.borderBottomRightRadius;
				break;
			case StylePropertyId.BorderBottomWidth:
				layoutData.Write().borderBottomWidth = InitialStyle.borderBottomWidth;
				break;
			case StylePropertyId.BorderColor:
				visualData.Write().borderTopColor = InitialStyle.borderTopColor;
				visualData.Write().borderRightColor = InitialStyle.borderRightColor;
				visualData.Write().borderBottomColor = InitialStyle.borderBottomColor;
				visualData.Write().borderLeftColor = InitialStyle.borderLeftColor;
				break;
			case StylePropertyId.BorderLeftColor:
				visualData.Write().borderLeftColor = InitialStyle.borderLeftColor;
				break;
			case StylePropertyId.BorderLeftWidth:
				layoutData.Write().borderLeftWidth = InitialStyle.borderLeftWidth;
				break;
			case StylePropertyId.BorderRadius:
				visualData.Write().borderTopLeftRadius = InitialStyle.borderTopLeftRadius;
				visualData.Write().borderTopRightRadius = InitialStyle.borderTopRightRadius;
				visualData.Write().borderBottomRightRadius = InitialStyle.borderBottomRightRadius;
				visualData.Write().borderBottomLeftRadius = InitialStyle.borderBottomLeftRadius;
				break;
			case StylePropertyId.BorderRightColor:
				visualData.Write().borderRightColor = InitialStyle.borderRightColor;
				break;
			case StylePropertyId.BorderRightWidth:
				layoutData.Write().borderRightWidth = InitialStyle.borderRightWidth;
				break;
			case StylePropertyId.BorderTopColor:
				visualData.Write().borderTopColor = InitialStyle.borderTopColor;
				break;
			case StylePropertyId.BorderTopLeftRadius:
				visualData.Write().borderTopLeftRadius = InitialStyle.borderTopLeftRadius;
				break;
			case StylePropertyId.BorderTopRightRadius:
				visualData.Write().borderTopRightRadius = InitialStyle.borderTopRightRadius;
				break;
			case StylePropertyId.BorderTopWidth:
				layoutData.Write().borderTopWidth = InitialStyle.borderTopWidth;
				break;
			case StylePropertyId.BorderWidth:
				layoutData.Write().borderTopWidth = InitialStyle.borderTopWidth;
				layoutData.Write().borderRightWidth = InitialStyle.borderRightWidth;
				layoutData.Write().borderBottomWidth = InitialStyle.borderBottomWidth;
				layoutData.Write().borderLeftWidth = InitialStyle.borderLeftWidth;
				break;
			case StylePropertyId.Bottom:
				layoutData.Write().bottom = InitialStyle.bottom;
				break;
			case StylePropertyId.Color:
				inheritedData.Write().color = InitialStyle.color;
				break;
			case StylePropertyId.Cursor:
				rareData.Write().cursor = InitialStyle.cursor;
				break;
			case StylePropertyId.Display:
				layoutData.Write().display = InitialStyle.display;
				break;
			case StylePropertyId.Flex:
				layoutData.Write().flexGrow = InitialStyle.flexGrow;
				layoutData.Write().flexShrink = InitialStyle.flexShrink;
				layoutData.Write().flexBasis = InitialStyle.flexBasis;
				break;
			case StylePropertyId.FlexBasis:
				layoutData.Write().flexBasis = InitialStyle.flexBasis;
				break;
			case StylePropertyId.FlexDirection:
				layoutData.Write().flexDirection = InitialStyle.flexDirection;
				break;
			case StylePropertyId.FlexGrow:
				layoutData.Write().flexGrow = InitialStyle.flexGrow;
				break;
			case StylePropertyId.FlexShrink:
				layoutData.Write().flexShrink = InitialStyle.flexShrink;
				break;
			case StylePropertyId.FlexWrap:
				layoutData.Write().flexWrap = InitialStyle.flexWrap;
				break;
			case StylePropertyId.FontSize:
				inheritedData.Write().fontSize = InitialStyle.fontSize;
				break;
			case StylePropertyId.Height:
				layoutData.Write().height = InitialStyle.height;
				break;
			case StylePropertyId.JustifyContent:
				layoutData.Write().justifyContent = InitialStyle.justifyContent;
				break;
			case StylePropertyId.Left:
				layoutData.Write().left = InitialStyle.left;
				break;
			case StylePropertyId.LetterSpacing:
				inheritedData.Write().letterSpacing = InitialStyle.letterSpacing;
				break;
			case StylePropertyId.Margin:
				layoutData.Write().marginTop = InitialStyle.marginTop;
				layoutData.Write().marginRight = InitialStyle.marginRight;
				layoutData.Write().marginBottom = InitialStyle.marginBottom;
				layoutData.Write().marginLeft = InitialStyle.marginLeft;
				break;
			case StylePropertyId.MarginBottom:
				layoutData.Write().marginBottom = InitialStyle.marginBottom;
				break;
			case StylePropertyId.MarginLeft:
				layoutData.Write().marginLeft = InitialStyle.marginLeft;
				break;
			case StylePropertyId.MarginRight:
				layoutData.Write().marginRight = InitialStyle.marginRight;
				break;
			case StylePropertyId.MarginTop:
				layoutData.Write().marginTop = InitialStyle.marginTop;
				break;
			case StylePropertyId.MaxHeight:
				layoutData.Write().maxHeight = InitialStyle.maxHeight;
				break;
			case StylePropertyId.MaxWidth:
				layoutData.Write().maxWidth = InitialStyle.maxWidth;
				break;
			case StylePropertyId.MinHeight:
				layoutData.Write().minHeight = InitialStyle.minHeight;
				break;
			case StylePropertyId.MinWidth:
				layoutData.Write().minWidth = InitialStyle.minWidth;
				break;
			case StylePropertyId.Opacity:
				visualData.Write().opacity = InitialStyle.opacity;
				break;
			case StylePropertyId.Overflow:
				visualData.Write().overflow = InitialStyle.overflow;
				break;
			case StylePropertyId.Padding:
				layoutData.Write().paddingTop = InitialStyle.paddingTop;
				layoutData.Write().paddingRight = InitialStyle.paddingRight;
				layoutData.Write().paddingBottom = InitialStyle.paddingBottom;
				layoutData.Write().paddingLeft = InitialStyle.paddingLeft;
				break;
			case StylePropertyId.PaddingBottom:
				layoutData.Write().paddingBottom = InitialStyle.paddingBottom;
				break;
			case StylePropertyId.PaddingLeft:
				layoutData.Write().paddingLeft = InitialStyle.paddingLeft;
				break;
			case StylePropertyId.PaddingRight:
				layoutData.Write().paddingRight = InitialStyle.paddingRight;
				break;
			case StylePropertyId.PaddingTop:
				layoutData.Write().paddingTop = InitialStyle.paddingTop;
				break;
			case StylePropertyId.Position:
				layoutData.Write().position = InitialStyle.position;
				break;
			case StylePropertyId.Right:
				layoutData.Write().right = InitialStyle.right;
				break;
			case StylePropertyId.Rotate:
				transformData.Write().rotate = InitialStyle.rotate;
				break;
			case StylePropertyId.Scale:
				transformData.Write().scale = InitialStyle.scale;
				break;
			case StylePropertyId.TextOverflow:
				rareData.Write().textOverflow = InitialStyle.textOverflow;
				break;
			case StylePropertyId.TextShadow:
				inheritedData.Write().textShadow = InitialStyle.textShadow;
				break;
			case StylePropertyId.Top:
				layoutData.Write().top = InitialStyle.top;
				break;
			case StylePropertyId.TransformOrigin:
				transformData.Write().transformOrigin = InitialStyle.transformOrigin;
				break;
			case StylePropertyId.Transition:
				transitionData.Write().transitionDelay.CopyFrom(InitialStyle.transitionDelay);
				transitionData.Write().transitionDuration.CopyFrom(InitialStyle.transitionDuration);
				transitionData.Write().transitionProperty.CopyFrom(InitialStyle.transitionProperty);
				transitionData.Write().transitionTimingFunction.CopyFrom(InitialStyle.transitionTimingFunction);
				ResetComputedTransitions();
				break;
			case StylePropertyId.TransitionDelay:
				transitionData.Write().transitionDelay.CopyFrom(InitialStyle.transitionDelay);
				ResetComputedTransitions();
				break;
			case StylePropertyId.TransitionDuration:
				transitionData.Write().transitionDuration.CopyFrom(InitialStyle.transitionDuration);
				ResetComputedTransitions();
				break;
			case StylePropertyId.TransitionProperty:
				transitionData.Write().transitionProperty.CopyFrom(InitialStyle.transitionProperty);
				ResetComputedTransitions();
				break;
			case StylePropertyId.TransitionTimingFunction:
				transitionData.Write().transitionTimingFunction.CopyFrom(InitialStyle.transitionTimingFunction);
				ResetComputedTransitions();
				break;
			case StylePropertyId.Translate:
				transformData.Write().translate = InitialStyle.translate;
				break;
			case StylePropertyId.UnityBackgroundImageTintColor:
				rareData.Write().unityBackgroundImageTintColor = InitialStyle.unityBackgroundImageTintColor;
				break;
			case StylePropertyId.UnityBackgroundScaleMode:
				visualData.Write().backgroundPositionX = InitialStyle.backgroundPositionX;
				visualData.Write().backgroundPositionY = InitialStyle.backgroundPositionY;
				visualData.Write().backgroundRepeat = InitialStyle.backgroundRepeat;
				visualData.Write().backgroundSize = InitialStyle.backgroundSize;
				break;
			case StylePropertyId.UnityFont:
				inheritedData.Write().unityFont = InitialStyle.unityFont;
				break;
			case StylePropertyId.UnityFontDefinition:
				inheritedData.Write().unityFontDefinition = InitialStyle.unityFontDefinition;
				break;
			case StylePropertyId.UnityFontStyleAndWeight:
				inheritedData.Write().unityFontStyleAndWeight = InitialStyle.unityFontStyleAndWeight;
				break;
			case StylePropertyId.UnityOverflowClipBox:
				rareData.Write().unityOverflowClipBox = InitialStyle.unityOverflowClipBox;
				break;
			case StylePropertyId.UnityParagraphSpacing:
				inheritedData.Write().unityParagraphSpacing = InitialStyle.unityParagraphSpacing;
				break;
			case StylePropertyId.UnitySliceBottom:
				rareData.Write().unitySliceBottom = InitialStyle.unitySliceBottom;
				break;
			case StylePropertyId.UnitySliceLeft:
				rareData.Write().unitySliceLeft = InitialStyle.unitySliceLeft;
				break;
			case StylePropertyId.UnitySliceRight:
				rareData.Write().unitySliceRight = InitialStyle.unitySliceRight;
				break;
			case StylePropertyId.UnitySliceScale:
				rareData.Write().unitySliceScale = InitialStyle.unitySliceScale;
				break;
			case StylePropertyId.UnitySliceTop:
				rareData.Write().unitySliceTop = InitialStyle.unitySliceTop;
				break;
			case StylePropertyId.UnityTextAlign:
				inheritedData.Write().unityTextAlign = InitialStyle.unityTextAlign;
				break;
			case StylePropertyId.UnityTextOutline:
				inheritedData.Write().unityTextOutlineColor = InitialStyle.unityTextOutlineColor;
				inheritedData.Write().unityTextOutlineWidth = InitialStyle.unityTextOutlineWidth;
				break;
			case StylePropertyId.UnityTextOutlineColor:
				inheritedData.Write().unityTextOutlineColor = InitialStyle.unityTextOutlineColor;
				break;
			case StylePropertyId.UnityTextOutlineWidth:
				inheritedData.Write().unityTextOutlineWidth = InitialStyle.unityTextOutlineWidth;
				break;
			case StylePropertyId.UnityTextOverflowPosition:
				rareData.Write().unityTextOverflowPosition = InitialStyle.unityTextOverflowPosition;
				break;
			case StylePropertyId.Visibility:
				inheritedData.Write().visibility = InitialStyle.visibility;
				break;
			case StylePropertyId.WhiteSpace:
				inheritedData.Write().whiteSpace = InitialStyle.whiteSpace;
				break;
			case StylePropertyId.Width:
				layoutData.Write().width = InitialStyle.width;
				break;
			case StylePropertyId.WordSpacing:
				inheritedData.Write().wordSpacing = InitialStyle.wordSpacing;
				break;
			default:
				Debug.LogAssertion($"Unexpected property id {id}");
				break;
			}
		}

		public void ApplyUnsetValue(StylePropertyReader reader, ref ComputedStyle parentStyle)
		{
			StylePropertyId propertyId = reader.propertyId;
			StylePropertyId stylePropertyId = propertyId;
			if (stylePropertyId == StylePropertyId.Custom)
			{
				RemoveCustomStyleProperty(reader);
			}
			else
			{
				ApplyUnsetValue(reader.propertyId, ref parentStyle);
			}
		}

		public void ApplyUnsetValue(StylePropertyId id, ref ComputedStyle parentStyle)
		{
			switch (id)
			{
			case StylePropertyId.Color:
				inheritedData.Write().color = parentStyle.color;
				break;
			case StylePropertyId.FontSize:
				inheritedData.Write().fontSize = parentStyle.fontSize;
				break;
			case StylePropertyId.LetterSpacing:
				inheritedData.Write().letterSpacing = parentStyle.letterSpacing;
				break;
			case StylePropertyId.TextShadow:
				inheritedData.Write().textShadow = parentStyle.textShadow;
				break;
			case StylePropertyId.UnityFont:
				inheritedData.Write().unityFont = parentStyle.unityFont;
				break;
			case StylePropertyId.UnityFontDefinition:
				inheritedData.Write().unityFontDefinition = parentStyle.unityFontDefinition;
				break;
			case StylePropertyId.UnityFontStyleAndWeight:
				inheritedData.Write().unityFontStyleAndWeight = parentStyle.unityFontStyleAndWeight;
				break;
			case StylePropertyId.UnityParagraphSpacing:
				inheritedData.Write().unityParagraphSpacing = parentStyle.unityParagraphSpacing;
				break;
			case StylePropertyId.UnityTextAlign:
				inheritedData.Write().unityTextAlign = parentStyle.unityTextAlign;
				break;
			case StylePropertyId.UnityTextOutlineColor:
				inheritedData.Write().unityTextOutlineColor = parentStyle.unityTextOutlineColor;
				break;
			case StylePropertyId.UnityTextOutlineWidth:
				inheritedData.Write().unityTextOutlineWidth = parentStyle.unityTextOutlineWidth;
				break;
			case StylePropertyId.Visibility:
				inheritedData.Write().visibility = parentStyle.visibility;
				break;
			case StylePropertyId.WhiteSpace:
				inheritedData.Write().whiteSpace = parentStyle.whiteSpace;
				break;
			case StylePropertyId.WordSpacing:
				inheritedData.Write().wordSpacing = parentStyle.wordSpacing;
				break;
			default:
				ApplyInitialValue(id);
				break;
			}
		}

		public static VersionChangeType CompareChanges(ref ComputedStyle x, ref ComputedStyle y)
		{
			VersionChangeType versionChangeType = VersionChangeType.Styles;
			if (!x.layoutData.ReferenceEquals(y.layoutData))
			{
				if (x.flexGrow != y.flexGrow || x.flexShrink != y.flexShrink || x.flexWrap != y.flexWrap || x.flexDirection != y.flexDirection || x.justifyContent != y.justifyContent || x.bottom != y.bottom || x.left != y.left || x.right != y.right || x.top != y.top || x.height != y.height || x.width != y.width || x.paddingBottom != y.paddingBottom || x.paddingLeft != y.paddingLeft || x.paddingRight != y.paddingRight || x.paddingTop != y.paddingTop || x.marginBottom != y.marginBottom || x.marginLeft != y.marginLeft || x.marginRight != y.marginRight || x.marginTop != y.marginTop || x.position != y.position || x.alignContent != y.alignContent || x.alignItems != y.alignItems || x.alignSelf != y.alignSelf || x.flexBasis != y.flexBasis || x.maxHeight != y.maxHeight || x.maxWidth != y.maxWidth || x.minHeight != y.minHeight || x.minWidth != y.minWidth)
				{
					versionChangeType |= VersionChangeType.Layout;
				}
				if (x.borderBottomWidth != y.borderBottomWidth || x.borderLeftWidth != y.borderLeftWidth || x.borderRightWidth != y.borderRightWidth || x.borderTopWidth != y.borderTopWidth)
				{
					versionChangeType |= VersionChangeType.Layout | VersionChangeType.BorderWidth | VersionChangeType.Repaint;
				}
				if (x.display != y.display)
				{
					versionChangeType |= VersionChangeType.Layout | VersionChangeType.Repaint;
				}
			}
			if (!x.inheritedData.ReferenceEquals(y.inheritedData))
			{
				if (x.color != y.color)
				{
					versionChangeType |= VersionChangeType.Color;
				}
				if ((versionChangeType & (VersionChangeType.Layout | VersionChangeType.Repaint)) == 0 && (x.unityFont != y.unityFont || x.fontSize != y.fontSize || x.unityFontDefinition != y.unityFontDefinition || x.unityFontStyleAndWeight != y.unityFontStyleAndWeight || x.unityTextOutlineWidth != y.unityTextOutlineWidth || x.letterSpacing != y.letterSpacing || x.wordSpacing != y.wordSpacing || x.unityParagraphSpacing != y.unityParagraphSpacing))
				{
					versionChangeType |= VersionChangeType.Layout | VersionChangeType.Repaint;
				}
				if ((versionChangeType & VersionChangeType.Repaint) == 0 && (x.textShadow != y.textShadow || x.unityTextAlign != y.unityTextAlign || x.unityTextOutlineColor != y.unityTextOutlineColor))
				{
					versionChangeType |= VersionChangeType.Repaint;
				}
				if (x.visibility != y.visibility)
				{
					versionChangeType |= VersionChangeType.Repaint | VersionChangeType.Picking;
				}
				if (x.whiteSpace != y.whiteSpace)
				{
					versionChangeType |= VersionChangeType.Layout;
				}
			}
			if (!x.transformData.ReferenceEquals(y.transformData) && (x.scale != y.scale || x.rotate != y.rotate || x.translate != y.translate || x.transformOrigin != y.transformOrigin))
			{
				versionChangeType |= VersionChangeType.Transform;
			}
			if (!x.transitionData.ReferenceEquals(y.transitionData) && !ComputedTransitionUtils.SameTransitionProperty(ref x, ref y))
			{
				versionChangeType |= VersionChangeType.TransitionProperty;
			}
			if (!x.visualData.ReferenceEquals(y.visualData))
			{
				if ((versionChangeType & VersionChangeType.Color) == 0 && (x.backgroundColor != y.backgroundColor || x.borderBottomColor != y.borderBottomColor || x.borderLeftColor != y.borderLeftColor || x.borderRightColor != y.borderRightColor || x.borderTopColor != y.borderTopColor))
				{
					versionChangeType |= VersionChangeType.Color;
				}
				if ((versionChangeType & VersionChangeType.Repaint) == 0 && (x.backgroundImage != y.backgroundImage || x.backgroundPositionX != y.backgroundPositionX || x.backgroundPositionY != y.backgroundPositionY || x.backgroundRepeat != y.backgroundRepeat || x.backgroundSize != y.backgroundSize))
				{
					versionChangeType |= VersionChangeType.Repaint;
				}
				if (x.borderBottomLeftRadius != y.borderBottomLeftRadius || x.borderBottomRightRadius != y.borderBottomRightRadius || x.borderTopLeftRadius != y.borderTopLeftRadius || x.borderTopRightRadius != y.borderTopRightRadius)
				{
					versionChangeType |= VersionChangeType.BorderRadius | VersionChangeType.Repaint;
				}
				if (x.opacity != y.opacity)
				{
					versionChangeType |= VersionChangeType.Opacity;
				}
				if (x.overflow != y.overflow)
				{
					versionChangeType |= VersionChangeType.Layout | VersionChangeType.Overflow;
				}
			}
			if (!x.rareData.ReferenceEquals(y.rareData))
			{
				if (x.textOverflow != y.textOverflow || x.unitySliceScale != y.unitySliceScale)
				{
					versionChangeType |= VersionChangeType.Layout | VersionChangeType.Repaint;
				}
				if (x.unityBackgroundImageTintColor != y.unityBackgroundImageTintColor)
				{
					versionChangeType |= VersionChangeType.Color;
				}
				if ((versionChangeType & VersionChangeType.Repaint) == 0 && (x.unityOverflowClipBox != y.unityOverflowClipBox || x.unitySliceBottom != y.unitySliceBottom || x.unitySliceLeft != y.unitySliceLeft || x.unitySliceRight != y.unitySliceRight || x.unitySliceTop != y.unitySliceTop || x.unityTextOverflowPosition != y.unityTextOverflowPosition))
				{
					versionChangeType |= VersionChangeType.Repaint;
				}
			}
			return versionChangeType;
		}
	}
	internal struct ComputedTransitionProperty
	{
		public StylePropertyId id;

		public int durationMs;

		public int delayMs;

		public Func<float, float> easingCurve;
	}
	internal static class ComputedTransitionUtils
	{
		private static List<ComputedTransitionProperty> s_ComputedTransitionsBuffer = new List<ComputedTransitionProperty>();

		internal static void UpdateComputedTransitions(ref ComputedStyle computedStyle)
		{
			if (computedStyle.computedTransitions == null)
			{
				computedStyle.computedTransitions = GetOrComputeTransitionPropertyData(ref computedStyle);
			}
		}

		internal static bool HasTransitionProperty(this ref ComputedStyle computedStyle, StylePropertyId id)
		{
			for (int num = computedStyle.computedTransitions.Length - 1; num >= 0; num--)
			{
				ComputedTransitionProperty computedTransitionProperty = computedStyle.computedTransitions[num];
				if (computedTransitionProperty.id == id || StylePropertyUtil.IsMatchingShorthand(computedTransitionProperty.id, id))
				{
					return true;
				}
			}
			return false;
		}

		internal static bool GetTransitionProperty(this ref ComputedStyle computedStyle, StylePropertyId id, out ComputedTransitionProperty result)
		{
			for (int num = computedStyle.computedTransitions.Length - 1; num >= 0; num--)
			{
				ComputedTransitionProperty computedTransitionProperty = computedStyle.computedTransitions[num];
				if (computedTransitionProperty.id == id || StylePropertyUtil.IsMatchingShorthand(computedTransitionProperty.id, id))
				{
					result = computedTransitionProperty;
					return true;
				}
			}
			result = default(ComputedTransitionProperty);
			return false;
		}

		private static ComputedTransitionProperty[] GetOrComputeTransitionPropertyData(ref ComputedStyle computedStyle)
		{
			int transitionHashCode = GetTransitionHashCode(ref computedStyle);
			if (!StyleCache.TryGetValue(transitionHashCode, out ComputedTransitionProperty[] data))
			{
				ComputeTransitionPropertyData(ref computedStyle, s_ComputedTransitionsBuffer);
				data = new ComputedTransitionProperty[s_ComputedTransitionsBuffer.Count];
				s_ComputedTransitionsBuffer.CopyTo(data);
				s_ComputedTransitionsBuffer.Clear();
				StyleCache.SetValue(transitionHashCode, data);
			}
			return data;
		}

		private static int GetTransitionHashCode(ref ComputedStyle cs)
		{
			int num = 0;
			foreach (TimeValue item in cs.transitionDelay)
			{
				num = (num * 397) ^ item.GetHashCode();
			}
			foreach (TimeValue item2 in cs.transitionDuration)
			{
				num = (num * 397) ^ item2.GetHashCode();
			}
			foreach (StylePropertyName item3 in cs.transitionProperty)
			{
				num = (num * 397) ^ item3.GetHashCode();
			}
			foreach (EasingFunction item4 in cs.transitionTimingFunction)
			{
				num = (num * 397) ^ item4.GetHashCode();
			}
			return num;
		}

		internal static bool SameTransitionProperty(ref ComputedStyle x, ref ComputedStyle y)
		{
			if (x.computedTransitions == y.computedTransitions && x.computedTransitions != null)
			{
				return true;
			}
			return SameTransitionProperty(x.transitionProperty, y.transitionProperty) && SameTransitionProperty(x.transitionDuration, y.transitionDuration) && SameTransitionProperty(x.transitionDelay, y.transitionDelay);
		}

		private static bool SameTransitionProperty(List<StylePropertyName> a, List<StylePropertyName> b)
		{
			if (a == b)
			{
				return true;
			}
			if (a == null || b == null)
			{
				return false;
			}
			if (a.Count != b.Count)
			{
				return false;
			}
			int count = a.Count;
			for (int i = 0; i < count; i++)
			{
				if (a[i] != b[i])
				{
					return false;
				}
			}
			return true;
		}

		private static bool SameTransitionProperty(List<TimeValue> a, List<TimeValue> b)
		{
			if (a == b)
			{
				return true;
			}
			if (a == null || b == null)
			{
				return false;
			}
			if (a.Count != b.Count)
			{
				return false;
			}
			int count = a.Count;
			for (int i = 0; i < count; i++)
			{
				if (a[i] != b[i])
				{
					return false;
				}
			}
			return true;
		}

		private static void ComputeTransitionPropertyData(ref ComputedStyle computedStyle, List<ComputedTransitionProperty> outData)
		{
			List<StylePropertyName> transitionProperty = computedStyle.transitionProperty;
			if (transitionProperty == null || transitionProperty.Count == 0)
			{
				return;
			}
			List<TimeValue> transitionDuration = computedStyle.transitionDuration;
			List<TimeValue> transitionDelay = computedStyle.transitionDelay;
			List<EasingFunction> transitionTimingFunction = computedStyle.transitionTimingFunction;
			int count = transitionProperty.Count;
			for (int i = 0; i < count; i++)
			{
				StylePropertyId id = transitionProperty[i].id;
				if (id != StylePropertyId.Unknown && StylePropertyUtil.IsAnimatable(id))
				{
					int num = ConvertTransitionTime(GetWrappingTransitionData(transitionDuration, i, new TimeValue(0f)));
					int num2 = ConvertTransitionTime(GetWrappingTransitionData(transitionDelay, i, new TimeValue(0f)));
					float num3 = Mathf.Max(0, num) + num2;
					if (!(num3 <= 0f))
					{
						EasingFunction wrappingTransitionData = GetWrappingTransitionData(transitionTimingFunction, i, EasingMode.Ease);
						outData.Add(new ComputedTransitionProperty
						{
							id = id,
							durationMs = num,
							delayMs = num2,
							easingCurve = ConvertTransitionFunction(wrappingTransitionData.mode)
						});
					}
				}
			}
		}

		private static T GetWrappingTransitionData<T>(List<T> list, int i, T defaultValue)
		{
			return (list.Count == 0) ? defaultValue : list[i % list.Count];
		}

		private static int ConvertTransitionTime(TimeValue time)
		{
			return Mathf.RoundToInt((time.unit == TimeUnit.Millisecond) ? time.value : (time.value * 1000f));
		}

		private static Func<float, float> ConvertTransitionFunction(EasingMode mode)
		{
			return mode switch
			{
				EasingMode.EaseIn => (float t) => Easing.InQuad(t), 
				EasingMode.EaseOut => (float t) => Easing.OutQuad(t), 
				EasingMode.EaseInOut => (float t) => Easing.InOutQuad(t), 
				EasingMode.Linear => (float t) => Easing.Linear(t), 
				EasingMode.EaseInSine => (float t) => Easing.InSine(t), 
				EasingMode.EaseOutSine => (float t) => Easing.OutSine(t), 
				EasingMode.EaseInOutSine => (float t) => Easing.InOutSine(t), 
				EasingMode.EaseInCubic => (float t) => Easing.InCubic(t), 
				EasingMode.EaseOutCubic => (float t) => Easing.OutCubic(t), 
				EasingMode.EaseInOutCubic => (float t) => Easing.InOutCubic(t), 
				EasingMode.EaseInCirc => (float t) => Easing.InCirc(t), 
				EasingMode.EaseOutCirc => (float t) => Easing.OutCirc(t), 
				EasingMode.EaseInOutCirc => (float t) => Easing.InOutCirc(t), 
				EasingMode.EaseInElastic => (float t) => Easing.InElastic(t), 
				EasingMode.EaseOutElastic => (float t) => Easing.OutElastic(t), 
				EasingMode.EaseInOutElastic => (float t) => Easing.InOutElastic(t), 
				EasingMode.EaseInBack => (float t) => Easing.InBack(t), 
				EasingMode.EaseOutBack => (float t) => Easing.OutBack(t), 
				EasingMode.EaseInOutBack => (float t) => Easing.InOutBack(t), 
				EasingMode.EaseInBounce => (float t) => Easing.InBounce(t), 
				EasingMode.EaseOutBounce => (float t) => Easing.OutBounce(t), 
				EasingMode.EaseInOutBounce => (float t) => Easing.InOutBounce(t), 
				_ => (float t) => t * (1.8f + t * (-0.6f + t * -0.2f)), 
			};
		}
	}
	public struct CustomStyleProperty<T> : IEquatable<CustomStyleProperty<T>>
	{
		public string name { get; private set; }

		public CustomStyleProperty(string propertyName)
		{
			if (!string.IsNullOrEmpty(propertyName) && !propertyName.StartsWith("--"))
			{
				throw new ArgumentException("Custom style property \"" + propertyName + "\" must start with \"--\" prefix.");
			}
			name = propertyName;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is CustomStyleProperty<T>))
			{
				return false;
			}
			return Equals((CustomStyleProperty<T>)obj);
		}

		public bool Equals(CustomStyleProperty<T> other)
		{
			return name == other.name;
		}

		public override int GetHashCode()
		{
			return name.GetHashCode();
		}

		public static bool operator ==(CustomStyleProperty<T> a, CustomStyleProperty<T> b)
		{
			return a.Equals(b);
		}

		public static bool operator !=(CustomStyleProperty<T> a, CustomStyleProperty<T> b)
		{
			return !(a == b);
		}
	}
	public interface ICustomStyle
	{
		bool TryGetValue(CustomStyleProperty<float> property, out float value);

		bool TryGetValue(CustomStyleProperty<int> property, out int value);

		bool TryGetValue(CustomStyleProperty<bool> property, out bool value);

		bool TryGetValue(CustomStyleProperty<Color> property, out Color value);

		bool TryGetValue(CustomStyleProperty<Texture2D> property, out Texture2D value);

		bool TryGetValue(CustomStyleProperty<Sprite> property, out Sprite value);

		bool TryGetValue(CustomStyleProperty<VectorImage> property, out VectorImage value);

		bool TryGetValue<T>(CustomStyleProperty<T> property, out T value) where T : Object;

		bool TryGetValue(CustomStyleProperty<string> property, out string value);
	}
	public enum EasingMode
	{
		Ease,
		EaseIn,
		EaseOut,
		EaseInOut,
		Linear,
		EaseInSine,
		EaseOutSine,
		EaseInOutSine,
		EaseInCubic,
		EaseOutCubic,
		EaseInOutCubic,
		EaseInCirc,
		EaseOutCirc,
		EaseInOutCirc,
		EaseInElastic,
		EaseOutElastic,
		EaseInOutElastic,
		EaseInBack,
		EaseOutBack,
		EaseInOutBack,
		EaseInBounce,
		EaseOutBounce,
		EaseInOutBounce
	}
	public struct EasingFunction : IEquatable<EasingFunction>
	{
		private EasingMode m_Mode;

		public EasingMode mode
		{
			get
			{
				return m_Mode;
			}
			set
			{
				m_Mode = value;
			}
		}

		public EasingFunction(EasingMode mode)
		{
			m_Mode = mode;
		}

		public static implicit operator EasingFunction(EasingMode easingMode)
		{
			return new EasingFunction(easingMode);
		}

		public static bool operator ==(EasingFunction lhs, EasingFunction rhs)
		{
			return lhs.m_Mode == rhs.m_Mode;
		}

		public static bool operator !=(EasingFunction lhs, EasingFunction rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(EasingFunction other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is EasingFunction other && Equals(other);
		}

		public override string ToString()
		{
			return m_Mode.ToString();
		}

		public override int GetHashCode()
		{
			return (int)m_Mode;
		}
	}
	public struct FontDefinition : IEquatable<FontDefinition>
	{
		private Font m_Font;

		private FontAsset m_FontAsset;

		public Font font
		{
			get
			{
				return m_Font;
			}
			set
			{
				if (value != null && fontAsset != null)
				{
					throw new InvalidOperationException("Cannot set both Font and FontAsset on FontDefinition");
				}
				m_Font = value;
			}
		}

		public FontAsset fontAsset
		{
			get
			{
				return m_FontAsset;
			}
			set
			{
				if (value != null && font != null)
				{
					throw new InvalidOperationException("Cannot set both Font and FontAsset on FontDefinition");
				}
				m_FontAsset = value;
			}
		}

		internal static IEnumerable<Type> allowedAssetTypes
		{
			get
			{
				yield return typeof(Font);
				yield return typeof(FontAsset);
			}
		}

		public static FontDefinition FromFont(Font f)
		{
			return new FontDefinition
			{
				m_Font = f
			};
		}

		public static FontDefinition FromSDFFont(FontAsset f)
		{
			return new FontDefinition
			{
				m_FontAsset = f
			};
		}

		internal static FontDefinition FromObject(object obj)
		{
			Font font = obj as Font;
			if (font != null)
			{
				return FromFont(font);
			}
			FontAsset fontAsset = obj as FontAsset;
			if (fontAsset != null)
			{
				return FromSDFFont(fontAsset);
			}
			return default(FontDefinition);
		}

		internal bool IsEmpty()
		{
			return m_Font == null && m_FontAsset == null;
		}

		public override string ToString()
		{
			if (font != null)
			{
				return $"{font}";
			}
			return $"{fontAsset}";
		}

		public bool Equals(FontDefinition other)
		{
			return object.Equals(m_Font, other.m_Font) && object.Equals(m_FontAsset, other.m_FontAsset);
		}

		public override bool Equals(object obj)
		{
			return obj is FontDefinition other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (((m_Font != null) ? m_Font.GetHashCode() : 0) * 397) ^ ((m_FontAsset != null) ? m_FontAsset.GetHashCode() : 0);
		}

		public static bool operator ==(FontDefinition left, FontDefinition right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(FontDefinition left, FontDefinition right)
		{
			return !left.Equals(right);
		}
	}
	internal class InlineStyleAccess : StyleValueCollection, IStyle
	{
		internal struct InlineRule
		{
			public StyleSheet sheet;

			public StyleRule rule;

			public StylePropertyId[] propertyIds;

			public StyleProperty[] properties => rule.properties;
		}

		private static StylePropertyReader s_StylePropertyReader = new StylePropertyReader();

		private List<StyleValueManaged> m_ValuesManaged;

		private bool m_HasInlineCursor;

		private StyleCursor m_InlineCursor;

		private bool m_HasInlineTextShadow;

		private StyleTextShadow m_InlineTextShadow;

		private bool m_HasInlineTransformOrigin;

		private StyleTransformOrigin m_InlineTransformOrigin;

		private bool m_HasInlineTranslate;

		private StyleTranslate m_InlineTranslateOperation;

		private bool m_HasInlineRotate;

		private StyleRotate m_InlineRotateOperation;

		private bool m_HasInlineScale;

		private StyleScale m_InlineScale;

		private bool m_HasInlineBackgroundSize;

		public StyleBackgroundSize m_InlineBackgroundSize;

		private InlineRule m_InlineRule;

		StyleEnum<Align> IStyle.alignContent
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.AlignContent);
				return new StyleEnum<Align>((Align)styleInt.value, styleInt.keyword);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.AlignContent, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.AlignContent = (YogaAlign)ve.computedStyle.alignContent;
				}
			}
		}

		StyleEnum<Align> IStyle.alignItems
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.AlignItems);
				return new StyleEnum<Align>((Align)styleInt.value, styleInt.keyword);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.AlignItems, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.AlignItems = (YogaAlign)ve.computedStyle.alignItems;
				}
			}
		}

		StyleEnum<Align> IStyle.alignSelf
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.AlignSelf);
				return new StyleEnum<Align>((Align)styleInt.value, styleInt.keyword);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.AlignSelf, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.AlignSelf = (YogaAlign)ve.computedStyle.alignSelf;
				}
			}
		}

		StyleColor IStyle.backgroundColor
		{
			get
			{
				return GetStyleColor(StylePropertyId.BackgroundColor);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BackgroundColor, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Color);
				}
			}
		}

		StyleBackground IStyle.backgroundImage
		{
			get
			{
				return GetStyleBackground(StylePropertyId.BackgroundImage);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BackgroundImage, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleBackgroundPosition IStyle.backgroundPositionX
		{
			get
			{
				return GetStyleBackgroundPosition(StylePropertyId.BackgroundPositionX);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BackgroundPositionX, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleBackgroundPosition IStyle.backgroundPositionY
		{
			get
			{
				return GetStyleBackgroundPosition(StylePropertyId.BackgroundPositionY);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BackgroundPositionY, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleBackgroundRepeat IStyle.backgroundRepeat
		{
			get
			{
				return GetStyleBackgroundRepeat(StylePropertyId.BackgroundRepeat);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BackgroundRepeat, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleColor IStyle.borderBottomColor
		{
			get
			{
				return GetStyleColor(StylePropertyId.BorderBottomColor);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BorderBottomColor, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Color);
				}
			}
		}

		StyleLength IStyle.borderBottomLeftRadius
		{
			get
			{
				return GetStyleLength(StylePropertyId.BorderBottomLeftRadius);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BorderBottomLeftRadius, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.BorderRadius | VersionChangeType.Repaint);
				}
			}
		}

		StyleLength IStyle.borderBottomRightRadius
		{
			get
			{
				return GetStyleLength(StylePropertyId.BorderBottomRightRadius);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BorderBottomRightRadius, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.BorderRadius | VersionChangeType.Repaint);
				}
			}
		}

		StyleFloat IStyle.borderBottomWidth
		{
			get
			{
				return GetStyleFloat(StylePropertyId.BorderBottomWidth);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BorderBottomWidth, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles | VersionChangeType.BorderWidth | VersionChangeType.Repaint);
					ve.yogaNode.BorderBottomWidth = ve.computedStyle.borderBottomWidth;
				}
			}
		}

		StyleColor IStyle.borderLeftColor
		{
			get
			{
				return GetStyleColor(StylePropertyId.BorderLeftColor);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BorderLeftColor, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Color);
				}
			}
		}

		StyleFloat IStyle.borderLeftWidth
		{
			get
			{
				return GetStyleFloat(StylePropertyId.BorderLeftWidth);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BorderLeftWidth, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles | VersionChangeType.BorderWidth | VersionChangeType.Repaint);
					ve.yogaNode.BorderLeftWidth = ve.computedStyle.borderLeftWidth;
				}
			}
		}

		StyleColor IStyle.borderRightColor
		{
			get
			{
				return GetStyleColor(StylePropertyId.BorderRightColor);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BorderRightColor, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Color);
				}
			}
		}

		StyleFloat IStyle.borderRightWidth
		{
			get
			{
				return GetStyleFloat(StylePropertyId.BorderRightWidth);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BorderRightWidth, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles | VersionChangeType.BorderWidth | VersionChangeType.Repaint);
					ve.yogaNode.BorderRightWidth = ve.computedStyle.borderRightWidth;
				}
			}
		}

		StyleColor IStyle.borderTopColor
		{
			get
			{
				return GetStyleColor(StylePropertyId.BorderTopColor);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BorderTopColor, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Color);
				}
			}
		}

		StyleLength IStyle.borderTopLeftRadius
		{
			get
			{
				return GetStyleLength(StylePropertyId.BorderTopLeftRadius);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BorderTopLeftRadius, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.BorderRadius | VersionChangeType.Repaint);
				}
			}
		}

		StyleLength IStyle.borderTopRightRadius
		{
			get
			{
				return GetStyleLength(StylePropertyId.BorderTopRightRadius);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BorderTopRightRadius, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.BorderRadius | VersionChangeType.Repaint);
				}
			}
		}

		StyleFloat IStyle.borderTopWidth
		{
			get
			{
				return GetStyleFloat(StylePropertyId.BorderTopWidth);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.BorderTopWidth, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles | VersionChangeType.BorderWidth | VersionChangeType.Repaint);
					ve.yogaNode.BorderTopWidth = ve.computedStyle.borderTopWidth;
				}
			}
		}

		StyleLength IStyle.bottom
		{
			get
			{
				return GetStyleLength(StylePropertyId.Bottom);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.Bottom, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.Bottom = ve.computedStyle.bottom.ToYogaValue();
				}
			}
		}

		StyleColor IStyle.color
		{
			get
			{
				return GetStyleColor(StylePropertyId.Color);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.Color, value))
				{
					ve.IncrementVersion(VersionChangeType.StyleSheet | VersionChangeType.Styles | VersionChangeType.Color);
				}
			}
		}

		StyleEnum<DisplayStyle> IStyle.display
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.Display);
				return new StyleEnum<DisplayStyle>((DisplayStyle)styleInt.value, styleInt.keyword);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.Display, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles | VersionChangeType.Repaint);
					ve.yogaNode.Display = (YogaDisplay)ve.computedStyle.display;
				}
			}
		}

		StyleLength IStyle.flexBasis
		{
			get
			{
				return GetStyleLength(StylePropertyId.FlexBasis);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.FlexBasis, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.FlexBasis = ve.computedStyle.flexBasis.ToYogaValue();
				}
			}
		}

		StyleEnum<FlexDirection> IStyle.flexDirection
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.FlexDirection);
				return new StyleEnum<FlexDirection>((FlexDirection)styleInt.value, styleInt.keyword);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.FlexDirection, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.FlexDirection = (YogaFlexDirection)ve.computedStyle.flexDirection;
				}
			}
		}

		StyleFloat IStyle.flexGrow
		{
			get
			{
				return GetStyleFloat(StylePropertyId.FlexGrow);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.FlexGrow, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.FlexGrow = ve.computedStyle.flexGrow;
				}
			}
		}

		StyleFloat IStyle.flexShrink
		{
			get
			{
				return GetStyleFloat(StylePropertyId.FlexShrink);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.FlexShrink, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.FlexShrink = ve.computedStyle.flexShrink;
				}
			}
		}

		StyleEnum<Wrap> IStyle.flexWrap
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.FlexWrap);
				return new StyleEnum<Wrap>((Wrap)styleInt.value, styleInt.keyword);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.FlexWrap, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.Wrap = (YogaWrap)ve.computedStyle.flexWrap;
				}
			}
		}

		StyleLength IStyle.fontSize
		{
			get
			{
				return GetStyleLength(StylePropertyId.FontSize);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.FontSize, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleLength IStyle.height
		{
			get
			{
				return GetStyleLength(StylePropertyId.Height);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.Height, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.Height = ve.computedStyle.height.ToYogaValue();
				}
			}
		}

		StyleEnum<Justify> IStyle.justifyContent
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.JustifyContent);
				return new StyleEnum<Justify>((Justify)styleInt.value, styleInt.keyword);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.JustifyContent, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.JustifyContent = (YogaJustify)ve.computedStyle.justifyContent;
				}
			}
		}

		StyleLength IStyle.left
		{
			get
			{
				return GetStyleLength(StylePropertyId.Left);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.Left, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.Left = ve.computedStyle.left.ToYogaValue();
				}
			}
		}

		StyleLength IStyle.letterSpacing
		{
			get
			{
				return GetStyleLength(StylePropertyId.LetterSpacing);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.LetterSpacing, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleLength IStyle.marginBottom
		{
			get
			{
				return GetStyleLength(StylePropertyId.MarginBottom);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.MarginBottom, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.MarginBottom = ve.computedStyle.marginBottom.ToYogaValue();
				}
			}
		}

		StyleLength IStyle.marginLeft
		{
			get
			{
				return GetStyleLength(StylePropertyId.MarginLeft);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.MarginLeft, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.MarginLeft = ve.computedStyle.marginLeft.ToYogaValue();
				}
			}
		}

		StyleLength IStyle.marginRight
		{
			get
			{
				return GetStyleLength(StylePropertyId.MarginRight);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.MarginRight, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.MarginRight = ve.computedStyle.marginRight.ToYogaValue();
				}
			}
		}

		StyleLength IStyle.marginTop
		{
			get
			{
				return GetStyleLength(StylePropertyId.MarginTop);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.MarginTop, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.MarginTop = ve.computedStyle.marginTop.ToYogaValue();
				}
			}
		}

		StyleLength IStyle.maxHeight
		{
			get
			{
				return GetStyleLength(StylePropertyId.MaxHeight);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.MaxHeight, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.MaxHeight = ve.computedStyle.maxHeight.ToYogaValue();
				}
			}
		}

		StyleLength IStyle.maxWidth
		{
			get
			{
				return GetStyleLength(StylePropertyId.MaxWidth);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.MaxWidth, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.MaxWidth = ve.computedStyle.maxWidth.ToYogaValue();
				}
			}
		}

		StyleLength IStyle.minHeight
		{
			get
			{
				return GetStyleLength(StylePropertyId.MinHeight);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.MinHeight, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.MinHeight = ve.computedStyle.minHeight.ToYogaValue();
				}
			}
		}

		StyleLength IStyle.minWidth
		{
			get
			{
				return GetStyleLength(StylePropertyId.MinWidth);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.MinWidth, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.MinWidth = ve.computedStyle.minWidth.ToYogaValue();
				}
			}
		}

		StyleFloat IStyle.opacity
		{
			get
			{
				return GetStyleFloat(StylePropertyId.Opacity);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.Opacity, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Opacity);
				}
			}
		}

		StyleEnum<Overflow> IStyle.overflow
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.Overflow);
				return new StyleEnum<Overflow>((Overflow)styleInt.value, styleInt.keyword);
			}
			set
			{
				StyleEnum<OverflowInternal> inlineValue = new StyleEnum<OverflowInternal>((OverflowInternal)value.value, value.keyword);
				if (SetStyleValue(StylePropertyId.Overflow, inlineValue))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles | VersionChangeType.Overflow);
					ve.yogaNode.Overflow = (YogaOverflow)ve.computedStyle.overflow;
				}
			}
		}

		StyleLength IStyle.paddingBottom
		{
			get
			{
				return GetStyleLength(StylePropertyId.PaddingBottom);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.PaddingBottom, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.PaddingBottom = ve.computedStyle.paddingBottom.ToYogaValue();
				}
			}
		}

		StyleLength IStyle.paddingLeft
		{
			get
			{
				return GetStyleLength(StylePropertyId.PaddingLeft);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.PaddingLeft, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.PaddingLeft = ve.computedStyle.paddingLeft.ToYogaValue();
				}
			}
		}

		StyleLength IStyle.paddingRight
		{
			get
			{
				return GetStyleLength(StylePropertyId.PaddingRight);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.PaddingRight, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.PaddingRight = ve.computedStyle.paddingRight.ToYogaValue();
				}
			}
		}

		StyleLength IStyle.paddingTop
		{
			get
			{
				return GetStyleLength(StylePropertyId.PaddingTop);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.PaddingTop, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.PaddingTop = ve.computedStyle.paddingTop.ToYogaValue();
				}
			}
		}

		StyleEnum<Position> IStyle.position
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.Position);
				return new StyleEnum<Position>((Position)styleInt.value, styleInt.keyword);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.Position, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.PositionType = (YogaPositionType)ve.computedStyle.position;
				}
			}
		}

		StyleLength IStyle.right
		{
			get
			{
				return GetStyleLength(StylePropertyId.Right);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.Right, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.Right = ve.computedStyle.right.ToYogaValue();
				}
			}
		}

		StyleEnum<TextOverflow> IStyle.textOverflow
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.TextOverflow);
				return new StyleEnum<TextOverflow>((TextOverflow)styleInt.value, styleInt.keyword);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.TextOverflow, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleLength IStyle.top
		{
			get
			{
				return GetStyleLength(StylePropertyId.Top);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.Top, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.Top = ve.computedStyle.top.ToYogaValue();
				}
			}
		}

		StyleList<TimeValue> IStyle.transitionDelay
		{
			get
			{
				return GetStyleList<TimeValue>(StylePropertyId.TransitionDelay);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.TransitionDelay, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.TransitionProperty);
				}
			}
		}

		StyleList<TimeValue> IStyle.transitionDuration
		{
			get
			{
				return GetStyleList<TimeValue>(StylePropertyId.TransitionDuration);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.TransitionDuration, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.TransitionProperty);
				}
			}
		}

		StyleList<StylePropertyName> IStyle.transitionProperty
		{
			get
			{
				return GetStyleList<StylePropertyName>(StylePropertyId.TransitionProperty);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.TransitionProperty, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.TransitionProperty);
				}
			}
		}

		StyleList<EasingFunction> IStyle.transitionTimingFunction
		{
			get
			{
				return GetStyleList<EasingFunction>(StylePropertyId.TransitionTimingFunction);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.TransitionTimingFunction, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles);
				}
			}
		}

		StyleColor IStyle.unityBackgroundImageTintColor
		{
			get
			{
				return GetStyleColor(StylePropertyId.UnityBackgroundImageTintColor);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.UnityBackgroundImageTintColor, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Color);
				}
			}
		}

		StyleFont IStyle.unityFont
		{
			get
			{
				return GetStyleFont(StylePropertyId.UnityFont);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.UnityFont, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleFontDefinition IStyle.unityFontDefinition
		{
			get
			{
				return GetStyleFontDefinition(StylePropertyId.UnityFontDefinition);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.UnityFontDefinition, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleEnum<FontStyle> IStyle.unityFontStyleAndWeight
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.UnityFontStyleAndWeight);
				return new StyleEnum<FontStyle>((FontStyle)styleInt.value, styleInt.keyword);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.UnityFontStyleAndWeight, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleEnum<OverflowClipBox> IStyle.unityOverflowClipBox
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.UnityOverflowClipBox);
				return new StyleEnum<OverflowClipBox>((OverflowClipBox)styleInt.value, styleInt.keyword);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.UnityOverflowClipBox, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleLength IStyle.unityParagraphSpacing
		{
			get
			{
				return GetStyleLength(StylePropertyId.UnityParagraphSpacing);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.UnityParagraphSpacing, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleInt IStyle.unitySliceBottom
		{
			get
			{
				return GetStyleInt(StylePropertyId.UnitySliceBottom);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.UnitySliceBottom, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleInt IStyle.unitySliceLeft
		{
			get
			{
				return GetStyleInt(StylePropertyId.UnitySliceLeft);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.UnitySliceLeft, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleInt IStyle.unitySliceRight
		{
			get
			{
				return GetStyleInt(StylePropertyId.UnitySliceRight);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.UnitySliceRight, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleFloat IStyle.unitySliceScale
		{
			get
			{
				return GetStyleFloat(StylePropertyId.UnitySliceScale);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.UnitySliceScale, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleInt IStyle.unitySliceTop
		{
			get
			{
				return GetStyleInt(StylePropertyId.UnitySliceTop);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.UnitySliceTop, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleEnum<TextAnchor> IStyle.unityTextAlign
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.UnityTextAlign);
				return new StyleEnum<TextAnchor>((TextAnchor)styleInt.value, styleInt.keyword);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.UnityTextAlign, value))
				{
					ve.IncrementVersion(VersionChangeType.StyleSheet | VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleColor IStyle.unityTextOutlineColor
		{
			get
			{
				return GetStyleColor(StylePropertyId.UnityTextOutlineColor);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.UnityTextOutlineColor, value))
				{
					ve.IncrementVersion(VersionChangeType.StyleSheet | VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleFloat IStyle.unityTextOutlineWidth
		{
			get
			{
				return GetStyleFloat(StylePropertyId.UnityTextOutlineWidth);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.UnityTextOutlineWidth, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleEnum<TextOverflowPosition> IStyle.unityTextOverflowPosition
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.UnityTextOverflowPosition);
				return new StyleEnum<TextOverflowPosition>((TextOverflowPosition)styleInt.value, styleInt.keyword);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.UnityTextOverflowPosition, value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleEnum<Visibility> IStyle.visibility
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.Visibility);
				return new StyleEnum<Visibility>((Visibility)styleInt.value, styleInt.keyword);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.Visibility, value))
				{
					ve.IncrementVersion(VersionChangeType.StyleSheet | VersionChangeType.Styles | VersionChangeType.Repaint | VersionChangeType.Picking);
				}
			}
		}

		StyleEnum<WhiteSpace> IStyle.whiteSpace
		{
			get
			{
				StyleInt styleInt = GetStyleInt(StylePropertyId.WhiteSpace);
				return new StyleEnum<WhiteSpace>((WhiteSpace)styleInt.value, styleInt.keyword);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.WhiteSpace, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Styles);
				}
			}
		}

		StyleLength IStyle.width
		{
			get
			{
				return GetStyleLength(StylePropertyId.Width);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.Width, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles);
					ve.yogaNode.Width = ve.computedStyle.width.ToYogaValue();
				}
			}
		}

		StyleLength IStyle.wordSpacing
		{
			get
			{
				return GetStyleLength(StylePropertyId.WordSpacing);
			}
			set
			{
				if (SetStyleValue(StylePropertyId.WordSpacing, value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		private VisualElement ve { get; set; }

		public InlineRule inlineRule => m_InlineRule;

		StyleCursor IStyle.cursor
		{
			get
			{
				StyleCursor value = default(StyleCursor);
				if (TryGetInlineCursor(ref value))
				{
					return value;
				}
				return StyleKeyword.Null;
			}
			set
			{
				if (SetInlineCursor(value))
				{
					ve.IncrementVersion(VersionChangeType.Styles);
				}
			}
		}

		StyleTextShadow IStyle.textShadow
		{
			get
			{
				StyleTextShadow value = default(StyleTextShadow);
				if (TryGetInlineTextShadow(ref value))
				{
					return value;
				}
				return StyleKeyword.Null;
			}
			set
			{
				if (SetInlineTextShadow(value))
				{
					ve.IncrementVersion(VersionChangeType.Layout | VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleBackgroundSize IStyle.backgroundSize
		{
			get
			{
				StyleBackgroundSize value = default(StyleBackgroundSize);
				if (TryGetInlineBackgroundSize(ref value))
				{
					return value;
				}
				return StyleKeyword.Null;
			}
			set
			{
				if (SetInlineBackgroundSize(value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Repaint);
				}
			}
		}

		StyleTransformOrigin IStyle.transformOrigin
		{
			get
			{
				StyleTransformOrigin value = default(StyleTransformOrigin);
				if (TryGetInlineTransformOrigin(ref value))
				{
					return value;
				}
				return StyleKeyword.Null;
			}
			set
			{
				if (SetInlineTransformOrigin(value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Transform);
				}
			}
		}

		StyleTranslate IStyle.translate
		{
			get
			{
				StyleTranslate value = default(StyleTranslate);
				if (TryGetInlineTranslate(ref value))
				{
					return value;
				}
				return StyleKeyword.Null;
			}
			set
			{
				if (SetInlineTranslate(value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Transform);
				}
			}
		}

		StyleRotate IStyle.rotate
		{
			get
			{
				StyleRotate value = default(StyleRotate);
				if (TryGetInlineRotate(ref value))
				{
					return value;
				}
				return StyleKeyword.Null;
			}
			set
			{
				if (SetInlineRotate(value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Transform);
				}
			}
		}

		StyleScale IStyle.scale
		{
			get
			{
				StyleScale value = default(StyleScale);
				if (TryGetInlineScale(ref value))
				{
					return value;
				}
				return StyleKeyword.Null;
			}
			set
			{
				if (SetInlineScale(value))
				{
					ve.IncrementVersion(VersionChangeType.Styles | VersionChangeType.Transform);
				}
			}
		}

		StyleEnum<ScaleMode> IStyle.unityBackgroundScaleMode
		{
			get
			{
				bool valid;
				return new StyleEnum<ScaleMode>(BackgroundPropertyHelper.ResolveUnityBackgroundScaleMode(ve.style.backgroundPositionX.value, ve.style.backgroundPositionY.value, ve.style.backgroundRepeat.value, ve.style.backgroundSize.value, out valid));
			}
			set
			{
				ve.style.backgroundPositionX = BackgroundPropertyHelper.ConvertScaleModeToBackgroundPosition(value.value);
				ve.style.backgroundPositionY = BackgroundPropertyHelper.ConvertScaleModeToBackgroundPosition(value.value);
				ve.style.backgroundRepeat = BackgroundPropertyHelper.ConvertScaleModeToBackgroundRepeat(value.value);
				ve.style.backgroundSize = BackgroundPropertyHelper.ConvertScaleModeToBackgroundSize(value.value);
			}
		}

		public InlineStyleAccess(VisualElement ve)
		{
			this.ve = ve;
		}

		~InlineStyleAccess()
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(StylePropertyId.BackgroundImage, ref value) && value.resource.IsAllocated)
			{
				value.resource.Free();
			}
			if (TryGetStyleValue(StylePropertyId.UnityFont, ref value) && value.resource.IsAllocated)
			{
				value.resource.Free();
			}
		}

		public void SetInlineRule(StyleSheet sheet, StyleRule rule)
		{
			m_InlineRule.sheet = sheet;
			m_InlineRule.rule = rule;
			m_InlineRule.propertyIds = StyleSheetCache.GetPropertyIds(rule);
			ApplyInlineStyles(ref ve.computedStyle);
		}

		public bool IsValueSet(StylePropertyId id)
		{
			foreach (StyleValue value in m_Values)
			{
				if (value.id == id)
				{
					return true;
				}
			}
			if (m_ValuesManaged != null)
			{
				foreach (StyleValueManaged item in m_ValuesManaged)
				{
					if (item.id == id)
					{
						return true;
					}
				}
			}
			return id switch
			{
				StylePropertyId.Cursor => m_HasInlineCursor, 
				StylePropertyId.TextShadow => m_HasInlineTextShadow, 
				StylePropertyId.TransformOrigin => m_HasInlineTransformOrigin, 
				StylePropertyId.Translate => m_HasInlineTranslate, 
				StylePropertyId.Rotate => m_HasInlineRotate, 
				StylePropertyId.Scale => m_HasInlineScale, 
				StylePropertyId.BackgroundSize => m_HasInlineBackgroundSize, 
				_ => false, 
			};
		}

		public void ApplyInlineStyles(ref ComputedStyle computedStyle)
		{
			VisualElement parent = ve.hierarchy.parent;
			ref ComputedStyle reference;
			if (parent != null)
			{
				_ = ref parent.computedStyle;
				reference = ref parent.computedStyle;
			}
			else
			{
				reference = ref InitialStyle.Get();
			}
			ref ComputedStyle parentStyle = ref reference;
			if (m_InlineRule.sheet != null)
			{
				s_StylePropertyReader.SetInlineContext(m_InlineRule.sheet, m_InlineRule.rule.properties, m_InlineRule.propertyIds);
				computedStyle.ApplyProperties(s_StylePropertyReader, ref parentStyle);
			}
			foreach (StyleValue value in m_Values)
			{
				computedStyle.ApplyStyleValue(value, ref parentStyle);
			}
			if (m_ValuesManaged != null)
			{
				foreach (StyleValueManaged item in m_ValuesManaged)
				{
					computedStyle.ApplyStyleValueManaged(item, ref parentStyle);
				}
			}
			if (ve.style.cursor.keyword != StyleKeyword.Null)
			{
				computedStyle.ApplyStyleCursor(ve.style.cursor.value);
			}
			if (ve.style.textShadow.keyword != StyleKeyword.Null)
			{
				computedStyle.ApplyStyleTextShadow(ve.style.textShadow.value);
			}
			if (m_HasInlineTransformOrigin)
			{
				computedStyle.ApplyStyleTransformOrigin(ve.style.transformOrigin.value);
			}
			if (m_HasInlineTranslate)
			{
				computedStyle.ApplyStyleTranslate(ve.style.translate.value);
			}
			if (m_HasInlineScale)
			{
				computedStyle.ApplyStyleScale(ve.style.scale.value);
			}
			if (m_HasInlineRotate)
			{
				computedStyle.ApplyStyleRotate(ve.style.rotate.value);
			}
			if (m_HasInlineBackgroundSize)
			{
				computedStyle.ApplyStyleBackgroundSize(ve.style.backgroundSize.value);
			}
		}

		private StyleList<T> GetStyleList<T>(StylePropertyId id)
		{
			StyleValueManaged value = default(StyleValueManaged);
			if (TryGetStyleValueManaged(id, ref value))
			{
				return new StyleList<T>(value.value as List<T>, value.keyword);
			}
			return StyleKeyword.Null;
		}

		private void SetStyleValueManaged(StyleValueManaged value)
		{
			if (m_ValuesManaged == null)
			{
				m_ValuesManaged = new List<StyleValueManaged>();
			}
			for (int i = 0; i < m_ValuesManaged.Count; i++)
			{
				if (m_ValuesManaged[i].id == value.id)
				{
					if (value.keyword == StyleKeyword.Null)
					{
						m_ValuesManaged.RemoveAt(i);
					}
					else
					{
						m_ValuesManaged[i] = value;
					}
					return;
				}
			}
			m_ValuesManaged.Add(value);
		}

		private bool TryGetStyleValueManaged(StylePropertyId id, ref StyleValueManaged value)
		{
			value.id = StylePropertyId.Unknown;
			if (m_ValuesManaged == null)
			{
				return false;
			}
			foreach (StyleValueManaged item in m_ValuesManaged)
			{
				if (item.id == id)
				{
					value = item;
					return true;
				}
			}
			return false;
		}

		private bool SetStyleValue(StylePropertyId id, StyleBackgroundPosition inlineValue)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				if (value.position == inlineValue.value && value.keyword == inlineValue.keyword)
				{
					return false;
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			value.id = id;
			value.keyword = inlineValue.keyword;
			value.position = inlineValue.value;
			SetStyleValue(value);
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				return RemoveInlineStyle(id);
			}
			ApplyStyleValue(value);
			return true;
		}

		private bool SetStyleValue(StylePropertyId id, StyleBackgroundRepeat inlineValue)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				if (value.repeat == inlineValue.value && value.keyword == inlineValue.keyword)
				{
					return false;
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			value.id = id;
			value.keyword = inlineValue.keyword;
			value.repeat = inlineValue.value;
			SetStyleValue(value);
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				return RemoveInlineStyle(id);
			}
			ApplyStyleValue(value);
			return true;
		}

		private bool SetStyleValue(StylePropertyId id, StyleLength inlineValue)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				if (value.length == inlineValue.ToLength() && value.keyword == inlineValue.keyword)
				{
					return false;
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			value.id = id;
			value.keyword = inlineValue.keyword;
			value.length = inlineValue.ToLength();
			SetStyleValue(value);
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				return RemoveInlineStyle(id);
			}
			ApplyStyleValue(value);
			return true;
		}

		private bool SetStyleValue(StylePropertyId id, StyleFloat inlineValue)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				if (value.number == inlineValue.value && value.keyword == inlineValue.keyword)
				{
					return false;
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			value.id = id;
			value.keyword = inlineValue.keyword;
			value.number = inlineValue.value;
			SetStyleValue(value);
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				return RemoveInlineStyle(id);
			}
			ApplyStyleValue(value);
			return true;
		}

		private bool SetStyleValue(StylePropertyId id, StyleInt inlineValue)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				if (value.number == (float)inlineValue.value && value.keyword == inlineValue.keyword)
				{
					return false;
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			value.id = id;
			value.keyword = inlineValue.keyword;
			value.number = inlineValue.value;
			SetStyleValue(value);
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				return RemoveInlineStyle(id);
			}
			ApplyStyleValue(value);
			return true;
		}

		private bool SetStyleValue(StylePropertyId id, StyleColor inlineValue)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				if (value.color == inlineValue.value && value.keyword == inlineValue.keyword)
				{
					return false;
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			value.id = id;
			value.keyword = inlineValue.keyword;
			value.color = inlineValue.value;
			SetStyleValue(value);
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				return RemoveInlineStyle(id);
			}
			ApplyStyleValue(value);
			return true;
		}

		private bool SetStyleValue<T>(StylePropertyId id, StyleEnum<T> inlineValue) where T : struct, IConvertible
		{
			StyleValue value = default(StyleValue);
			int num = UnsafeUtility.EnumToInt(inlineValue.value);
			if (TryGetStyleValue(id, ref value))
			{
				if (value.number == (float)num && value.keyword == inlineValue.keyword)
				{
					return false;
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			value.id = id;
			value.keyword = inlineValue.keyword;
			value.number = num;
			SetStyleValue(value);
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				return RemoveInlineStyle(id);
			}
			ApplyStyleValue(value);
			return true;
		}

		private bool SetStyleValue(StylePropertyId id, StyleBackground inlineValue)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				VectorImage vectorImage = (value.resource.IsAllocated ? (value.resource.Target as VectorImage) : null);
				Sprite sprite = (value.resource.IsAllocated ? (value.resource.Target as Sprite) : null);
				Texture2D texture2D = (value.resource.IsAllocated ? (value.resource.Target as Texture2D) : null);
				RenderTexture renderTexture = (value.resource.IsAllocated ? (value.resource.Target as RenderTexture) : null);
				if (vectorImage == inlineValue.value.vectorImage && texture2D == inlineValue.value.texture && sprite == inlineValue.value.sprite && renderTexture == inlineValue.value.renderTexture && value.keyword == inlineValue.keyword)
				{
					return false;
				}
				if (value.resource.IsAllocated)
				{
					value.resource.Free();
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			value.id = id;
			value.keyword = inlineValue.keyword;
			if (inlineValue.value.vectorImage != null)
			{
				value.resource = GCHandle.Alloc(inlineValue.value.vectorImage);
			}
			else if (inlineValue.value.sprite != null)
			{
				value.resource = GCHandle.Alloc(inlineValue.value.sprite);
			}
			else if (inlineValue.value.texture != null)
			{
				value.resource = GCHandle.Alloc(inlineValue.value.texture);
			}
			else if (inlineValue.value.renderTexture != null)
			{
				value.resource = GCHandle.Alloc(inlineValue.value.renderTexture);
			}
			else
			{
				value.resource = default(GCHandle);
			}
			SetStyleValue(value);
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				return RemoveInlineStyle(id);
			}
			ApplyStyleValue(value);
			return true;
		}

		private bool SetStyleValue(StylePropertyId id, StyleFontDefinition inlineValue)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				Font font = (value.resource.IsAllocated ? (value.resource.Target as Font) : null);
				FontAsset fontAsset = (value.resource.IsAllocated ? (value.resource.Target as FontAsset) : null);
				if (font == inlineValue.value.font && fontAsset == inlineValue.value.fontAsset && value.keyword == inlineValue.keyword)
				{
					return false;
				}
				if (value.resource.IsAllocated)
				{
					value.resource.Free();
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			value.id = id;
			value.keyword = inlineValue.keyword;
			if (inlineValue.value.font != null)
			{
				value.resource = GCHandle.Alloc(inlineValue.value.font);
			}
			else if (inlineValue.value.fontAsset != null)
			{
				value.resource = GCHandle.Alloc(inlineValue.value.fontAsset);
			}
			else
			{
				value.resource = default(GCHandle);
			}
			SetStyleValue(value);
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				return RemoveInlineStyle(id);
			}
			ApplyStyleValue(value);
			return true;
		}

		private bool SetStyleValue(StylePropertyId id, StyleFont inlineValue)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				Font font = (value.resource.IsAllocated ? (value.resource.Target as Font) : null);
				if (font == inlineValue.value && value.keyword == inlineValue.keyword)
				{
					return false;
				}
				if (value.resource.IsAllocated)
				{
					value.resource.Free();
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			value.id = id;
			value.keyword = inlineValue.keyword;
			value.resource = ((inlineValue.value != null) ? GCHandle.Alloc(inlineValue.value) : default(GCHandle));
			SetStyleValue(value);
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				return RemoveInlineStyle(id);
			}
			ApplyStyleValue(value);
			return true;
		}

		private bool SetStyleValue<T>(StylePropertyId id, StyleList<T> inlineValue)
		{
			StyleValueManaged value = default(StyleValueManaged);
			if (TryGetStyleValueManaged(id, ref value))
			{
				if (value.keyword == inlineValue.keyword)
				{
					if (value.value == null && inlineValue.value == null)
					{
						return false;
					}
					if (value.value is List<T> first && inlineValue.value != null && first.SequenceEqual(inlineValue.value))
					{
						return false;
					}
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			value.id = id;
			value.keyword = inlineValue.keyword;
			if (inlineValue.value != null)
			{
				if (value.value == null)
				{
					value.value = new List<T>(inlineValue.value);
				}
				else
				{
					List<T> list = (List<T>)value.value;
					list.Clear();
					list.AddRange(inlineValue.value);
				}
			}
			else
			{
				value.value = null;
			}
			SetStyleValueManaged(value);
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				return RemoveInlineStyle(id);
			}
			ApplyStyleValue(value);
			return true;
		}

		private bool SetInlineCursor(StyleCursor inlineValue)
		{
			StyleCursor value = default(StyleCursor);
			if (TryGetInlineCursor(ref value))
			{
				if (value.value == inlineValue.value && value.keyword == inlineValue.keyword)
				{
					return false;
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			value.value = inlineValue.value;
			value.keyword = inlineValue.keyword;
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				m_HasInlineCursor = false;
				return RemoveInlineStyle(StylePropertyId.Cursor);
			}
			m_InlineCursor = value;
			m_HasInlineCursor = true;
			ApplyStyleCursor(value);
			return true;
		}

		private void ApplyStyleCursor(StyleCursor cursor)
		{
			ve.computedStyle.ApplyStyleCursor(cursor.value);
			if (ve.elementPanel?.GetTopElementUnderPointer(PointerId.mousePointerId) == ve)
			{
				ve.elementPanel.cursorManager.SetCursor(cursor.value);
			}
		}

		private bool SetInlineTextShadow(StyleTextShadow inlineValue)
		{
			StyleTextShadow value = default(StyleTextShadow);
			if (TryGetInlineTextShadow(ref value))
			{
				if (value.value == inlineValue.value && value.keyword == inlineValue.keyword)
				{
					return false;
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			value.value = inlineValue.value;
			value.keyword = inlineValue.keyword;
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				m_HasInlineTextShadow = false;
				return RemoveInlineStyle(StylePropertyId.TextShadow);
			}
			m_InlineTextShadow = value;
			m_HasInlineTextShadow = true;
			ApplyStyleTextShadow(value);
			return true;
		}

		private void ApplyStyleTextShadow(StyleTextShadow textShadow)
		{
			ComputedTransitionUtils.UpdateComputedTransitions(ref ve.computedStyle);
			bool flag = false;
			if (ve.computedStyle.hasTransition && ve.styleInitialized && ve.computedStyle.GetTransitionProperty(StylePropertyId.TextShadow, out var result))
			{
				flag = ComputedStyle.StartAnimationInlineTextShadow(ve, ref ve.computedStyle, textShadow, result.durationMs, result.delayMs, result.easingCurve);
			}
			else
			{
				ve.styleAnimation.CancelAnimation(StylePropertyId.TextShadow);
			}
			if (!flag)
			{
				ve.computedStyle.ApplyStyleTextShadow(textShadow.value);
			}
		}

		private bool SetInlineTransformOrigin(StyleTransformOrigin inlineValue)
		{
			StyleTransformOrigin value = default(StyleTransformOrigin);
			if (TryGetInlineTransformOrigin(ref value))
			{
				if (value.value == inlineValue.value && value.keyword == inlineValue.keyword)
				{
					return false;
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				m_HasInlineTransformOrigin = false;
				return RemoveInlineStyle(StylePropertyId.TransformOrigin);
			}
			m_InlineTransformOrigin = inlineValue;
			m_HasInlineTransformOrigin = true;
			ApplyStyleTransformOrigin(inlineValue);
			return true;
		}

		private void ApplyStyleTransformOrigin(StyleTransformOrigin transformOrigin)
		{
			ComputedTransitionUtils.UpdateComputedTransitions(ref ve.computedStyle);
			bool flag = false;
			if (ve.computedStyle.hasTransition && ve.styleInitialized && ve.computedStyle.GetTransitionProperty(StylePropertyId.TransformOrigin, out var result))
			{
				flag = ComputedStyle.StartAnimationInlineTransformOrigin(ve, ref ve.computedStyle, transformOrigin, result.durationMs, result.delayMs, result.easingCurve);
			}
			else
			{
				ve.styleAnimation.CancelAnimation(StylePropertyId.TransformOrigin);
			}
			if (!flag)
			{
				ve.computedStyle.ApplyStyleTransformOrigin(transformOrigin.value);
			}
		}

		private bool SetInlineTranslate(StyleTranslate inlineValue)
		{
			StyleTranslate value = default(StyleTranslate);
			if (TryGetInlineTranslate(ref value))
			{
				if (value.value == inlineValue.value && value.keyword == inlineValue.keyword)
				{
					return false;
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				m_HasInlineTranslate = false;
				return RemoveInlineStyle(StylePropertyId.Translate);
			}
			m_InlineTranslateOperation = inlineValue;
			m_HasInlineTranslate = true;
			ApplyStyleTranslate(inlineValue);
			return true;
		}

		private void ApplyStyleTranslate(StyleTranslate translate)
		{
			ComputedTransitionUtils.UpdateComputedTransitions(ref ve.computedStyle);
			bool flag = false;
			if (ve.computedStyle.hasTransition && ve.styleInitialized && ve.computedStyle.GetTransitionProperty(StylePropertyId.Translate, out var result))
			{
				flag = ComputedStyle.StartAnimationInlineTranslate(ve, ref ve.computedStyle, translate, result.durationMs, result.delayMs, result.easingCurve);
			}
			else
			{
				ve.styleAnimation.CancelAnimation(StylePropertyId.Translate);
			}
			if (!flag)
			{
				ve.computedStyle.ApplyStyleTranslate(translate.value);
			}
		}

		private bool SetInlineScale(StyleScale inlineValue)
		{
			StyleScale value = default(StyleScale);
			if (TryGetInlineScale(ref value))
			{
				if (value.value == inlineValue.value && value.keyword == inlineValue.keyword)
				{
					return false;
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				m_HasInlineScale = false;
				return RemoveInlineStyle(StylePropertyId.Scale);
			}
			m_InlineScale = inlineValue;
			m_HasInlineScale = true;
			ApplyStyleScale(inlineValue);
			return true;
		}

		private void ApplyStyleScale(StyleScale scale)
		{
			ComputedTransitionUtils.UpdateComputedTransitions(ref ve.computedStyle);
			bool flag = false;
			if (ve.computedStyle.hasTransition && ve.styleInitialized && ve.computedStyle.GetTransitionProperty(StylePropertyId.Scale, out var result))
			{
				flag = ComputedStyle.StartAnimationInlineScale(ve, ref ve.computedStyle, scale, result.durationMs, result.delayMs, result.easingCurve);
			}
			else
			{
				ve.styleAnimation.CancelAnimation(StylePropertyId.Scale);
			}
			if (!flag)
			{
				ve.computedStyle.ApplyStyleScale(scale.value);
			}
		}

		private bool SetInlineRotate(StyleRotate inlineValue)
		{
			StyleRotate value = default(StyleRotate);
			if (TryGetInlineRotate(ref value))
			{
				if (value.value == inlineValue.value && value.keyword == inlineValue.keyword)
				{
					return false;
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				m_HasInlineRotate = false;
				return RemoveInlineStyle(StylePropertyId.Rotate);
			}
			m_InlineRotateOperation = inlineValue;
			m_HasInlineRotate = true;
			ApplyStyleRotate(inlineValue);
			return true;
		}

		private void ApplyStyleRotate(StyleRotate rotate)
		{
			VisualElement parent = ve.hierarchy.parent;
			ref ComputedStyle reference;
			if (parent != null)
			{
				_ = ref parent.computedStyle;
				reference = ref parent.computedStyle;
			}
			else
			{
				reference = ref InitialStyle.Get();
			}
			ref ComputedStyle reference2 = ref reference;
			ComputedTransitionUtils.UpdateComputedTransitions(ref ve.computedStyle);
			bool flag = false;
			if (ve.computedStyle.hasTransition && ve.styleInitialized && ve.computedStyle.GetTransitionProperty(StylePropertyId.Rotate, out var result))
			{
				flag = ComputedStyle.StartAnimationInlineRotate(ve, ref ve.computedStyle, rotate, result.durationMs, result.delayMs, result.easingCurve);
			}
			else
			{
				ve.styleAnimation.CancelAnimation(StylePropertyId.Rotate);
			}
			if (!flag)
			{
				ve.computedStyle.ApplyStyleRotate(rotate.value);
			}
		}

		private bool SetInlineBackgroundSize(StyleBackgroundSize inlineValue)
		{
			StyleBackgroundSize value = default(StyleBackgroundSize);
			if (TryGetInlineBackgroundSize(ref value))
			{
				if (value.value == inlineValue.value && value.keyword == inlineValue.keyword)
				{
					return false;
				}
			}
			else if (inlineValue.keyword == StyleKeyword.Null)
			{
				return false;
			}
			if (inlineValue.keyword == StyleKeyword.Null)
			{
				m_HasInlineBackgroundSize = false;
				return RemoveInlineStyle(StylePropertyId.BackgroundSize);
			}
			m_InlineBackgroundSize = inlineValue;
			m_HasInlineBackgroundSize = true;
			ApplyStyleBackgroundSize(inlineValue);
			return true;
		}

		private void ApplyStyleBackgroundSize(StyleBackgroundSize backgroundSize)
		{
			ComputedTransitionUtils.UpdateComputedTransitions(ref ve.computedStyle);
			bool flag = false;
			if (ve.computedStyle.hasTransition && ve.styleInitialized && ve.computedStyle.GetTransitionProperty(StylePropertyId.BackgroundSize, out var result))
			{
				flag = ComputedStyle.StartAnimationInlineBackgroundSize(ve, ref ve.computedStyle, backgroundSize, result.durationMs, result.delayMs, result.easingCurve);
			}
			else
			{
				ve.styleAnimation.CancelAnimation(StylePropertyId.TransformOrigin);
			}
			if (!flag)
			{
				ve.computedStyle.ApplyStyleBackgroundSize(backgroundSize.value);
			}
		}

		private void ApplyStyleValue(StyleValue value)
		{
			VisualElement parent = ve.hierarchy.parent;
			ref ComputedStyle reference;
			if (parent != null)
			{
				_ = ref parent.computedStyle;
				reference = ref parent.computedStyle;
			}
			else
			{
				reference = ref InitialStyle.Get();
			}
			ref ComputedStyle parentStyle = ref reference;
			bool flag = false;
			if (StylePropertyUtil.IsAnimatable(value.id))
			{
				ComputedTransitionUtils.UpdateComputedTransitions(ref ve.computedStyle);
				if (ve.computedStyle.hasTransition && ve.styleInitialized && ve.computedStyle.GetTransitionProperty(value.id, out var result))
				{
					flag = ComputedStyle.StartAnimationInline(ve, value.id, ref ve.computedStyle, value, result.durationMs, result.delayMs, result.easingCurve);
				}
				else
				{
					ve.styleAnimation.CancelAnimation(value.id);
				}
			}
			if (!flag)
			{
				ve.computedStyle.ApplyStyleValue(value, ref parentStyle);
			}
		}

		private void ApplyStyleValue(StyleValueManaged value)
		{
			VisualElement parent = ve.hierarchy.parent;
			ref ComputedStyle parentStyle;
			if (parent != null)
			{
				_ = ref parent.computedStyle;
				parentStyle = ref parent.computedStyle;
			}
			else
			{
				parentStyle = ref InitialStyle.Get();
			}
			ve.computedStyle.ApplyStyleValueManaged(value, ref parentStyle);
		}

		private bool RemoveInlineStyle(StylePropertyId id)
		{
			long matchingRulesHash = ve.computedStyle.matchingRulesHash;
			if (matchingRulesHash == 0)
			{
				ApplyFromComputedStyle(id, ref InitialStyle.Get());
				return true;
			}
			if (StyleCache.TryGetValue(matchingRulesHash, out var data))
			{
				ApplyFromComputedStyle(id, ref data);
				return true;
			}
			return false;
		}

		private void ApplyFromComputedStyle(StylePropertyId id, ref ComputedStyle newStyle)
		{
			bool flag = false;
			if (StylePropertyUtil.IsAnimatable(id))
			{
				ComputedTransitionUtils.UpdateComputedTransitions(ref ve.computedStyle);
				if (ve.computedStyle.hasTransition && ve.styleInitialized && ve.computedStyle.GetTransitionProperty(id, out var result))
				{
					flag = ComputedStyle.StartAnimation(ve, id, ref ve.computedStyle, ref newStyle, result.durationMs, result.delayMs, result.easingCurve);
				}
				else
				{
					ve.styleAnimation.CancelAnimation(id);
				}
			}
			if (!flag)
			{
				ve.computedStyle.ApplyFromComputedStyle(id, ref newStyle);
			}
		}

		public bool TryGetInlineCursor(ref StyleCursor value)
		{
			if (m_HasInlineCursor)
			{
				value = m_InlineCursor;
				return true;
			}
			return false;
		}

		public bool TryGetInlineTextShadow(ref StyleTextShadow value)
		{
			if (m_HasInlineTextShadow)
			{
				value = m_InlineTextShadow;
				return true;
			}
			return false;
		}

		public bool TryGetInlineTransformOrigin(ref StyleTransformOrigin value)
		{
			if (m_HasInlineTransformOrigin)
			{
				value = m_InlineTransformOrigin;
				return true;
			}
			return false;
		}

		public bool TryGetInlineTranslate(ref StyleTranslate value)
		{
			if (m_HasInlineTranslate)
			{
				value = m_InlineTranslateOperation;
				return true;
			}
			return false;
		}

		public bool TryGetInlineRotate(ref StyleRotate value)
		{
			if (m_HasInlineRotate)
			{
				value = m_InlineRotateOperation;
				return true;
			}
			return false;
		}

		public bool TryGetInlineScale(ref StyleScale value)
		{
			if (m_HasInlineScale)
			{
				value = m_InlineScale;
				return true;
			}
			return false;
		}

		public bool TryGetInlineBackgroundSize(ref StyleBackgroundSize value)
		{
			if (m_HasInlineBackgroundSize)
			{
				value = m_InlineBackgroundSize;
				return true;
			}
			return false;
		}
	}
	public interface IResolvedStyle
	{
		Align alignContent { get; }

		Align alignItems { get; }

		Align alignSelf { get; }

		Color backgroundColor { get; }

		Background backgroundImage { get; }

		BackgroundPosition backgroundPositionX { get; }

		BackgroundPosition backgroundPositionY { get; }

		BackgroundRepeat backgroundRepeat { get; }

		BackgroundSize backgroundSize { get; }

		Color borderBottomColor { get; }

		float borderBottomLeftRadius { get; }

		float borderBottomRightRadius { get; }

		float borderBottomWidth { get; }

		Color borderLeftColor { get; }

		float borderLeftWidth { get; }

		Color borderRightColor { get; }

		float borderRightWidth { get; }

		Color borderTopColor { get; }

		float borderTopLeftRadius { get; }

		float borderTopRightRadius { get; }

		float borderTopWidth { get; }

		float bottom { get; }

		Color color { get; }

		DisplayStyle display { get; }

		StyleFloat flexBasis { get; }

		FlexDirection flexDirection { get; }

		float flexGrow { get; }

		float flexShrink { get; }

		Wrap flexWrap { get; }

		float fontSize { get; }

		float height { get; }

		Justify justifyContent { get; }

		float left { get; }

		float letterSpacing { get; }

		float marginBottom { get; }

		float marginLeft { get; }

		float marginRight { get; }

		float marginTop { get; }

		StyleFloat maxHeight { get; }

		StyleFloat maxWidth { get; }

		StyleFloat minHeight { get; }

		StyleFloat minWidth { get; }

		float opacity { get; }

		float paddingBottom { get; }

		float paddingLeft { get; }

		float paddingRight { get; }

		float paddingTop { get; }

		Position position { get; }

		float right { get; }

		Rotate rotate { get; }

		Scale scale { get; }

		TextOverflow textOverflow { get; }

		float top { get; }

		Vector3 transformOrigin { get; }

		IEnumerable<TimeValue> transitionDelay { get; }

		IEnumerable<TimeValue> transitionDuration { get; }

		IEnumerable<StylePropertyName> transitionProperty { get; }

		IEnumerable<EasingFunction> transitionTimingFunction { get; }

		Vector3 translate { get; }

		Color unityBackgroundImageTintColor { get; }

		Font unityFont { get; }

		FontDefinition unityFontDefinition { get; }

		FontStyle unityFontStyleAndWeight { get; }

		float unityParagraphSpacing { get; }

		int unitySliceBottom { get; }

		int unitySliceLeft { get; }

		int unitySliceRight { get; }

		float unitySliceScale { get; }

		int unitySliceTop { get; }

		TextAnchor unityTextAlign { get; }

		Color unityTextOutlineColor { get; }

		float unityTextOutlineWidth { get; }

		TextOverflowPosition unityTextOverflowPosition { get; }

		Visibility visibility { get; }

		WhiteSpace whiteSpace { get; }

		float width { get; }

		float wordSpacing { get; }

		[Obsolete("unityBackgroundScaleMode is deprecated. Use background-* properties instead.")]
		StyleEnum<ScaleMode> unityBackgroundScaleMode { get; }
	}
	public interface IStyle
	{
		StyleEnum<Align> alignContent { get; set; }

		StyleEnum<Align> alignItems { get; set; }

		StyleEnum<Align> alignSelf { get; set; }

		StyleColor backgroundColor { get; set; }

		StyleBackground backgroundImage { get; set; }

		StyleBackgroundPosition backgroundPositionX { get; set; }

		StyleBackgroundPosition backgroundPositionY { get; set; }

		StyleBackgroundRepeat backgroundRepeat { get; set; }

		StyleBackgroundSize backgroundSize { get; set; }

		StyleColor borderBottomColor { get; set; }

		StyleLength borderBottomLeftRadius { get; set; }

		StyleLength borderBottomRightRadius { get; set; }

		StyleFloat borderBottomWidth { get; set; }

		StyleColor borderLeftColor { get; set; }

		StyleFloat borderLeftWidth { get; set; }

		StyleColor borderRightColor { get; set; }

		StyleFloat borderRightWidth { get; set; }

		StyleColor borderTopColor { get; set; }

		StyleLength borderTopLeftRadius { get; set; }

		StyleLength borderTopRightRadius { get; set; }

		StyleFloat borderTopWidth { get; set; }

		StyleLength bottom { get; set; }

		StyleColor color { get; set; }

		StyleCursor cursor { get; set; }

		StyleEnum<DisplayStyle> display { get; set; }

		StyleLength flexBasis { get; set; }

		StyleEnum<FlexDirection> flexDirection { get; set; }

		StyleFloat flexGrow { get; set; }

		StyleFloat flexShrink { get; set; }

		StyleEnum<Wrap> flexWrap { get; set; }

		StyleLength fontSize { get; set; }

		StyleLength height { get; set; }

		StyleEnum<Justify> justifyContent { get; set; }

		StyleLength left { get; set; }

		StyleLength letterSpacing { get; set; }

		StyleLength marginBottom { get; set; }

		StyleLength marginLeft { get; set; }

		StyleLength marginRight { get; set; }

		StyleLength marginTop { get; set; }

		StyleLength maxHeight { get; set; }

		StyleLength maxWidth { get; set; }

		StyleLength minHeight { get; set; }

		StyleLength minWidth { get; set; }

		StyleFloat opacity { get; set; }

		StyleEnum<Overflow> overflow { get; set; }

		StyleLength paddingBottom { get; set; }

		StyleLength paddingLeft { get; set; }

		StyleLength paddingRight { get; set; }

		StyleLength paddingTop { get; set; }

		StyleEnum<Position> position { get; set; }

		StyleLength right { get; set; }

		StyleRotate rotate { get; set; }

		StyleScale scale { get; set; }

		StyleEnum<TextOverflow> textOverflow { get; set; }

		StyleTextShadow textShadow { get; set; }

		StyleLength top { get; set; }

		StyleTransformOrigin transformOrigin { get; set; }

		StyleList<TimeValue> transitionDelay { get; set; }

		StyleList<TimeValue> transitionDuration { get; set; }

		StyleList<StylePropertyName> transitionProperty { get; set; }

		StyleList<EasingFunction> transitionTimingFunction { get; set; }

		StyleTranslate translate { get; set; }

		StyleColor unityBackgroundImageTintColor { get; set; }

		StyleFont unityFont { get; set; }

		StyleFontDefinition unityFontDefinition { get; set; }

		StyleEnum<FontStyle> unityFontStyleAndWeight { get; set; }

		StyleEnum<OverflowClipBox> unityOverflowClipBox { get; set; }

		StyleLength unityParagraphSpacing { get; set; }

		StyleInt unitySliceBottom { get; set; }

		StyleInt unitySliceLeft { get; set; }

		StyleInt unitySliceRight { get; set; }

		StyleFloat unitySliceScale { get; set; }

		StyleInt unitySliceTop { get; set; }

		StyleEnum<TextAnchor> unityTextAlign { get; set; }

		StyleColor unityTextOutlineColor { get; set; }

		StyleFloat unityTextOutlineWidth { get; set; }

		StyleEnum<TextOverflowPosition> unityTextOverflowPosition { get; set; }

		StyleEnum<Visibility> visibility { get; set; }

		StyleEnum<WhiteSpace> whiteSpace { get; set; }

		StyleLength width { get; set; }

		StyleLength wordSpacing { get; set; }

		[Obsolete("unityBackgroundScaleMode is deprecated. Use background-* properties instead.")]
		StyleEnum<ScaleMode> unityBackgroundScaleMode { get; set; }
	}
	public class VisualElement : Focusable, IResolvedStyle, IStylePropertyAnimations, ITransform, ITransitionAnimations, IExperimentalFeatures, IVisualElementScheduler
	{
		public class UxmlFactory : UxmlFactory<VisualElement, UxmlTraits>
		{
		}

		public class UxmlTraits : UnityEngine.UIElements.UxmlTraits
		{
			protected UxmlStringAttributeDescription m_Name = new UxmlStringAttributeDescription
			{
				name = "name"
			};

			private UxmlStringAttributeDescription m_ViewDataKey = new UxmlStringAttributeDescription
			{
				name = "view-data-key"
			};

			protected UxmlEnumAttributeDescription<PickingMode> m_PickingMode = new UxmlEnumAttributeDescription<PickingMode>
			{
				name = "picking-mode",
				obsoleteNames = new string[1] { "pickingMode" }
			};

			private UxmlStringAttributeDescription m_Tooltip = new UxmlStringAttributeDescription
			{
				name = "tooltip"
			};

			private UxmlEnumAttributeDescription<UsageHints> m_UsageHints = new UxmlEnumAttributeDescription<UsageHints>
			{
				name = "usage-hints"
			};

			private UxmlIntAttributeDescription m_TabIndex = new UxmlIntAttributeDescription
			{
				name = "tabindex",
				defaultValue = 0
			};

			private UxmlStringAttributeDescription m_Class = new UxmlStringAttributeDescription
			{
				name = "class"
			};

			private UxmlStringAttributeDescription m_ContentContainer = new UxmlStringAttributeDescription
			{
				name = "content-container",
				obsoleteNames = new string[1] { "contentContainer" }
			};

			private UxmlStringAttributeDescription m_Style = new UxmlStringAttributeDescription
			{
				name = "style"
			};

			protected UxmlIntAttributeDescription focusIndex { get; set; } = new UxmlIntAttributeDescription
			{
				name = null,
				obsoleteNames = new string[2] { "focus-index", "focusIndex" },
				defaultValue = -1
			};

			protected UxmlBoolAttributeDescription focusable { get; set; } = new UxmlBoolAttributeDescription
			{
				name = "focusable",
				defaultValue = false
			};

			public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
			{
				get
				{
					yield return new UxmlChildElementDescription(typeof(VisualElement));
				}
			}

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				if (ve == null)
				{
					throw new ArgumentNullException("ve");
				}
				ve.name = m_Name.GetValueFromBag(bag, cc);
				ve.viewDataKey = m_ViewDataKey.GetValueFromBag(bag, cc);
				ve.pickingMode = m_PickingMode.GetValueFromBag(bag, cc);
				ve.usageHints = m_UsageHints.GetValueFromBag(bag, cc);
				ve.tooltip = m_Tooltip.GetValueFromBag(bag, cc);
				int value = 0;
				if (focusIndex.TryGetValueFromBag(bag, cc, ref value))
				{
					ve.tabIndex = ((value >= 0) ? value : 0);
					ve.focusable = value >= 0;
				}
				ve.tabIndex = m_TabIndex.GetValueFromBag(bag, cc);
				ve.focusable = focusable.GetValueFromBag(bag, cc);
			}
		}

		public enum MeasureMode
		{
			Undefined,
			Exactly,
			AtMost
		}

		internal enum RenderTargetMode
		{
			None,
			NoColorConversion,
			LinearToGamma,
			GammaToLinear
		}

		public struct Hierarchy
		{
			private const string k_InvalidHierarchyChangeMsg = "Cannot modify VisualElement hierarchy during layout calculation";

			private readonly VisualElement m_Owner;

			public VisualElement parent => m_Owner.m_PhysicalParent;

			internal List<VisualElement> children => m_Owner.m_Children;

			public int childCount => m_Owner.m_Children.Count;

			public VisualElement this[int key] => m_Owner.m_Children[key];

			internal Hierarchy(VisualElement element)
			{
				m_Owner = element;
			}

			public void Add(VisualElement child)
			{
				if (child == null)
				{
					throw new ArgumentException("Cannot add null child");
				}
				Insert(childCount, child);
			}

			public void Insert(int index, VisualElement child)
			{
				if (child == null)
				{
					throw new ArgumentException("Cannot insert null child");
				}
				if (index > childCount)
				{
					throw new ArgumentOutOfRangeException("Index out of range: " + index);
				}
				if (child == m_Owner)
				{
					throw new ArgumentException("Cannot insert element as its own child");
				}
				if (m_Owner.elementPanel != null && m_Owner.elementPanel.duringLayoutPhase)
				{
					throw new InvalidOperationException("Cannot modify VisualElement hierarchy during layout calculation");
				}
				child.RemoveFromHierarchy();
				if (m_Owner.m_Children == s_EmptyList)
				{
					m_Owner.m_Children = VisualElementListPool.Get();
				}
				if (m_Owner.yogaNode.IsMeasureDefined)
				{
					m_Owner.RemoveMeasureFunction();
				}
				PutChildAtIndex(child, index);
				int num = child.imguiContainerDescendantCount + (child.isIMGUIContainer ? 1 : 0);
				if (num > 0)
				{
					m_Owner.ChangeIMGUIContainerCount(num);
				}
				child.hierarchy.SetParent(m_Owner);
				child.PropagateEnabledToChildren(m_Owner.enabledInHierarchy);
				if (child.languageDirection == LanguageDirection.Inherit)
				{
					child.localLanguageDirection = m_Owner.localLanguageDirection;
				}
				child.InvokeHierarchyChanged(HierarchyChangeType.Add);
				child.IncrementVersion(VersionChangeType.Hierarchy);
				m_Owner.IncrementVersion(VersionChangeType.Hierarchy);
			}

			public void Remove(VisualElement child)
			{
				if (child == null)
				{
					throw new ArgumentException("Cannot remove null child");
				}
				if (child.hierarchy.parent != m_Owner)
				{
					throw new ArgumentException("This VisualElement is not my child");
				}
				int index = m_Owner.m_Children.IndexOf(child);
				RemoveAt(index);
			}

			public void RemoveAt(int index)
			{
				if (m_Owner.elementPanel != null && m_Owner.elementPanel.duringLayoutPhase)
				{
					throw new InvalidOperationException("Cannot modify VisualElement hierarchy during layout calculation");
				}
				if (index < 0 || index >= childCount)
				{
					throw new ArgumentOutOfRangeException("Index out of range: " + index);
				}
				VisualElement visualElement = m_Owner.m_Children[index];
				visualElement.InvokeHierarchyChanged(HierarchyChangeType.Remove);
				RemoveChildAtIndex(index);
				int num = visualElement.imguiContainerDescendantCount + (visualElement.isIMGUIContainer ? 1 : 0);
				if (num > 0)
				{
					m_Owner.ChangeIMGUIContainerCount(-num);
				}
				visualElement.hierarchy.SetParent(null);
				if (childCount == 0)
				{
					ReleaseChildList();
					if (m_Owner.requireMeasureFunction)
					{
						m_Owner.AssignMeasureFunction();
					}
				}
				m_Owner.elementPanel?.OnVersionChanged(visualElement, VersionChangeType.Hierarchy);
				m_Owner.IncrementVersion(VersionChangeType.Hierarchy);
			}

			public void Clear()
			{
				if (m_Owner.elementPanel != null && m_Owner.elementPanel.duringLayoutPhase)
				{
					throw new InvalidOperationException("Cannot modify VisualElement hierarchy during layout calculation");
				}
				if (childCount <= 0)
				{
					return;
				}
				List<VisualElement> list = VisualElementListPool.Copy(m_Owner.m_Children);
				ReleaseChildList();
				m_Owner.yogaNode.Clear();
				if (m_Owner.requireMeasureFunction)
				{
					m_Owner.AssignMeasureFunction();
				}
				foreach (VisualElement item in list)
				{
					item.InvokeHierarchyChanged(HierarchyChangeType.Remove);
					item.hierarchy.SetParent(null);
					item.m_LogicalParent = null;
					m_Owner.elementPanel?.OnVersionChanged(item, VersionChangeType.Hierarchy);
				}
				if (m_Owner.imguiContainerDescendantCount > 0)
				{
					int num = m_Owner.imguiContainerDescendantCount;
					if (m_Owner.isIMGUIContainer)
					{
						num--;
					}
					m_Owner.ChangeIMGUIContainerCount(-num);
				}
				VisualElementListPool.Release(list);
				m_Owner.IncrementVersion(VersionChangeType.Hierarchy);
			}

			internal void BringToFront(VisualElement child)
			{
				if (childCount > 1)
				{
					int num = m_Owner.m_Children.IndexOf(child);
					if (num >= 0 && num < childCount - 1)
					{
						MoveChildElement(child, num, childCount);
					}
				}
			}

			internal void SendToBack(VisualElement child)
			{
				if (childCount > 1)
				{
					int num = m_Owner.m_Children.IndexOf(child);
					if (num > 0)
					{
						MoveChildElement(child, num, 0);
					}
				}
			}

			internal void PlaceBehind(VisualElement child, VisualElement over)
			{
				if (childCount <= 0)
				{
					return;
				}
				int num = m_Owner.m_Children.IndexOf(child);
				if (num >= 0)
				{
					int num2 = m_Owner.m_Children.IndexOf(over);
					if (num2 > 0 && num < num2)
					{
						num2--;
					}
					MoveChildElement(child, num, num2);
				}
			}

			internal void PlaceInFront(VisualElement child, VisualElement under)
			{
				if (childCount <= 0)
				{
					return;
				}
				int num = m_Owner.m_Children.IndexOf(child);
				if (num >= 0)
				{
					int num2 = m_Owner.m_Children.IndexOf(under);
					if (num > num2)
					{
						num2++;
					}
					MoveChildElement(child, num, num2);
				}
			}

			private void MoveChildElement(VisualElement child, int currentIndex, int nextIndex)
			{
				if (m_Owner.elementPanel != null && m_Owner.elementPanel.duringLayoutPhase)
				{
					throw new InvalidOperationException("Cannot modify VisualElement hierarchy during layout calculation");
				}
				child.InvokeHierarchyChanged(HierarchyChangeType.Remove);
				RemoveChildAtIndex(currentIndex);
				PutChildAtIndex(child, nextIndex);
				child.InvokeHierarchyChanged(HierarchyChangeType.Add);
				m_Owner.IncrementVersion(VersionChangeType.Hierarchy);
			}

			public int IndexOf(VisualElement element)
			{
				return m_Owner.m_Children.IndexOf(element);
			}

			public VisualElement ElementAt(int index)
			{
				return this[index];
			}

			public IEnumerable<VisualElement> Children()
			{
				return m_Owner.m_Children;
			}

			private void SetParent(VisualElement value)
			{
				m_Owner.m_PhysicalParent = value;
				m_Owner.m_LogicalParent = value;
				m_Owner.DirtyNextParentWithEventCallback();
				m_Owner.SetPanel(value?.elementPanel);
			}

			public void Sort(Comparison<VisualElement> comp)
			{
				if (m_Owner.elementPanel != null && m_Owner.elementPanel.duringLayoutPhase)
				{
					throw new InvalidOperationException("Cannot modify VisualElement hierarchy during layout calculation");
				}
				if (childCount > 1)
				{
					m_Owner.m_Children.Sort(comp);
					m_Owner.yogaNode.Clear();
					for (int i = 0; i < m_Owner.m_Children.Count; i++)
					{
						m_Owner.yogaNode.Insert(i, m_Owner.m_Children[i].yogaNode);
					}
					m_Owner.InvokeHierarchyChanged(HierarchyChangeType.Move);
					m_Owner.IncrementVersion(VersionChangeType.Hierarchy);
				}
			}

			private void PutChildAtIndex(VisualElement child, int index)
			{
				if (index >= childCount)
				{
					m_Owner.m_Children.Add(child);
					m_Owner.yogaNode.Insert(m_Owner.yogaNode.Count, child.yogaNode);
				}
				else
				{
					m_Owner.m_Children.Insert(index, child);
					m_Owner.yogaNode.Insert(index, child.yogaNode);
				}
			}

			private void RemoveChildAtIndex(int index)
			{
				m_Owner.m_Children.RemoveAt(index);
				m_Owner.yogaNode.RemoveAt(index);
			}

			private void ReleaseChildList()
			{
				if (m_Owner.m_Children != s_EmptyList)
				{
					List<VisualElement> elements = m_Owner.m_Children;
					m_Owner.m_Children = s_EmptyList;
					VisualElementListPool.Release(elements);
				}
			}

			public bool Equals(Hierarchy other)
			{
				return other == this;
			}

			public override bool Equals(object obj)
			{
				if (obj == null)
				{
					return false;
				}
				return obj is Hierarchy && Equals((Hierarchy)obj);
			}

			public override int GetHashCode()
			{
				return (m_Owner != null) ? m_Owner.GetHashCode() : 0;
			}

			public static bool operator ==(Hierarchy x, Hierarchy y)
			{
				return x.m_Owner == y.m_Owner;
			}

			public static bool operator !=(Hierarchy x, Hierarchy y)
			{
				return !(x == y);
			}
		}

		private abstract class BaseVisualElementScheduledItem : ScheduledItem, IVisualElementScheduledItem, IVisualElementPanelActivatable
		{
			public bool isScheduled = false;

			private VisualElementPanelActivator m_Activator;

			public VisualElement element { get; private set; }

			public bool isActive => m_Activator.isActive;

			protected BaseVisualElementScheduledItem(VisualElement handler)
			{
				element = handler;
				m_Activator = new VisualElementPanelActivator(this);
			}

			public IVisualElementScheduledItem StartingIn(long delayMs)
			{
				base.delayMs = delayMs;
				return this;
			}

			public IVisualElementScheduledItem Until(Func<bool> stopCondition)
			{
				if (stopCondition == null)
				{
					stopCondition = ScheduledItem.ForeverCondition;
				}
				timerUpdateStopCondition = stopCondition;
				return this;
			}

			public IVisualElementScheduledItem ForDuration(long durationMs)
			{
				SetDuration(durationMs);
				return this;
			}

			public IVisualElementScheduledItem Every(long intervalMs)
			{
				base.intervalMs = intervalMs;
				if (timerUpdateStopCondition == ScheduledItem.OnceCondition)
				{
					timerUpdateStopCondition = ScheduledItem.ForeverCondition;
				}
				return this;
			}

			internal override void OnItemUnscheduled()
			{
				base.OnItemUnscheduled();
				isScheduled = false;
				if (!m_Activator.isDetaching)
				{
					m_Activator.SetActive(action: false);
				}
			}

			public void Resume()
			{
				m_Activator.SetActive(action: true);
			}

			public void Pause()
			{
				m_Activator.SetActive(action: false);
			}

			public void ExecuteLater(long delayMs)
			{
				if (!isScheduled)
				{
					Resume();
				}
				ResetStartTime();
				StartingIn(delayMs);
			}

			public void OnPanelActivate()
			{
				if (!isScheduled)
				{
					isScheduled = true;
					ResetStartTime();
					element.elementPanel.scheduler.Schedule(this);
				}
			}

			public void OnPanelDeactivate()
			{
				if (isScheduled)
				{
					isScheduled = false;
					element.elementPanel.scheduler.Unschedule(this);
				}
			}

			public bool CanBeActivated()
			{
				return element != null && element.elementPanel != null && element.elementPanel.scheduler != null;
			}
		}

		private abstract class VisualElementScheduledItem<ActionType> : BaseVisualElementScheduledItem
		{
			public ActionType updateEvent;

			public VisualElementScheduledItem(VisualElement handler, ActionType upEvent)
				: base(handler)
			{
				updateEvent = upEvent;
			}

			public static bool Matches(ScheduledItem item, ActionType updateEvent)
			{
				if (item is VisualElementScheduledItem<ActionType> visualElementScheduledItem)
				{
					return EqualityComparer<ActionType>.Default.Equals(visualElementScheduledItem.updateEvent, updateEvent);
				}
				return false;
			}
		}

		private class TimerStateScheduledItem : VisualElementScheduledItem<Action<TimerState>>
		{
			public TimerStateScheduledItem(VisualElement handler, Action<TimerState> updateEvent)
				: base(handler, updateEvent)
			{
			}

			public override void PerformTimerUpdate(TimerState state)
			{
				if (isScheduled)
				{
					updateEvent(state);
				}
			}
		}

		private class SimpleScheduledItem : VisualElementScheduledItem<Action>
		{
			public SimpleScheduledItem(VisualElement handler, Action updateEvent)
				: base(handler, updateEvent)
			{
			}

			public override void PerformTimerUpdate(TimerState state)
			{
				if (isScheduled)
				{
					updateEvent();
				}
			}
		}

		internal class CustomStyleAccess : ICustomStyle
		{
			private Dictionary<string, StylePropertyValue> m_CustomProperties;

			private float m_DpiScaling;

			public void SetContext(Dictionary<string, StylePropertyValue> customProperties, float dpiScaling)
			{
				m_CustomProperties = customProperties;
				m_DpiScaling = dpiScaling;
			}

			public bool TryGetValue(CustomStyleProperty<float> property, out float value)
			{
				if (TryGetValue(property.name, StyleValueType.Float, out var customProp) && customProp.sheet.TryReadFloat(customProp.handle, out value))
				{
					return true;
				}
				value = 0f;
				return false;
			}

			public bool TryGetValue(CustomStyleProperty<int> property, out int value)
			{
				if (TryGetValue(property.name, StyleValueType.Float, out var customProp) && customProp.sheet.TryReadFloat(customProp.handle, out var value2))
				{
					value = (int)value2;
					return true;
				}
				value = 0;
				return false;
			}

			public bool TryGetValue(CustomStyleProperty<bool> property, out bool value)
			{
				if (m_CustomProperties != null && m_CustomProperties.TryGetValue(property.name, out var value2))
				{
					value = value2.sheet.ReadKeyword(value2.handle) == StyleValueKeyword.True;
					return true;
				}
				value = false;
				return false;
			}

			public bool TryGetValue(CustomStyleProperty<Color> property, out Color value)
			{
				if (m_CustomProperties != null && m_CustomProperties.TryGetValue(property.name, out var value2))
				{
					StyleValueHandle handle = value2.handle;
					switch (handle.valueType)
					{
					case StyleValueType.Enum:
					{
						string text = value2.sheet.ReadAsString(handle);
						return StyleSheetColor.TryGetColor(text.ToLowerInvariant(), out value);
					}
					case StyleValueType.Color:
						if (value2.sheet.TryReadColor(value2.handle, out value))
						{
							return true;
						}
						break;
					default:
						LogCustomPropertyWarning(property.name, StyleValueType.Color, value2);
						break;
					}
				}
				value = Color.clear;
				return false;
			}

			public bool TryGetValue(CustomStyleProperty<Texture2D> property, out Texture2D value)
			{
				if (m_CustomProperties != null && m_CustomProperties.TryGetValue(property.name, out var value2))
				{
					ImageSource source = default(ImageSource);
					if (StylePropertyReader.TryGetImageSourceFromValue(value2, m_DpiScaling, out source) && source.texture != null)
					{
						value = source.texture;
						return true;
					}
				}
				value = null;
				return false;
			}

			public bool TryGetValue(CustomStyleProperty<Sprite> property, out Sprite value)
			{
				if (m_CustomProperties != null && m_CustomProperties.TryGetValue(property.name, out var value2))
				{
					ImageSource source = default(ImageSource);
					if (StylePropertyReader.TryGetImageSourceFromValue(value2, m_DpiScaling, out source) && source.sprite != null)
					{
						value = source.sprite;
						return true;
					}
				}
				value = null;
				return false;
			}

			public bool TryGetValue(CustomStyleProperty<VectorImage> property, out VectorImage value)
			{
				if (m_CustomProperties != null && m_CustomProperties.TryGetValue(property.name, out var value2))
				{
					ImageSource source = default(ImageSource);
					if (StylePropertyReader.TryGetImageSourceFromValue(value2, m_DpiScaling, out source) && source.vectorImage != null)
					{
						value = source.vectorImage;
						return true;
					}
				}
				value = null;
				return false;
			}

			public bool TryGetValue<T>(CustomStyleProperty<T> property, out T value) where T : Object
			{
				if (m_CustomProperties != null && m_CustomProperties.TryGetValue(property.name, out var value2) && value2.sheet.TryReadAssetReference(value2.handle, out var value3))
				{
					value = value3 as T;
					return value != null;
				}
				value = null;
				return false;
			}

			public bool TryGetValue(CustomStyleProperty<string> property, out string value)
			{
				if (m_CustomProperties != null && m_CustomProperties.TryGetValue(property.name, out var value2))
				{
					value = value2.sheet.ReadAsString(value2.handle);
					return true;
				}
				value = string.Empty;
				return false;
			}

			private bool TryGetValue(string propertyName, StyleValueType valueType, out StylePropertyValue customProp)
			{
				customProp = default(StylePropertyValue);
				if (m_CustomProperties != null && m_CustomProperties.TryGetValue(propertyName, out customProp))
				{
					StyleValueHandle handle = customProp.handle;
					if (handle.valueType != valueType)
					{
						LogCustomPropertyWarning(propertyName, valueType, customProp);
						return false;
					}
					return true;
				}
				return false;
			}

			private static void LogCustomPropertyWarning(string propertyName, StyleValueType valueType, StylePropertyValue customProp)
			{
				Debug.LogWarning($"Trying to read custom property {propertyName} value as {valueType} while parsed type is {customProp.handle.valueType}");
			}
		}

		internal class TypeData
		{
			private string m_FullTypeName = string.Empty;

			private string m_TypeName = string.Empty;

			private string m_TypeNamespace = string.Empty;

			public Type type { get; }

			public string fullTypeName
			{
				get
				{
					if (string.IsNullOrEmpty(m_FullTypeName))
					{
						m_FullTypeName = type.FullName;
					}
					return m_FullTypeName;
				}
			}

			public string typeName
			{
				get
				{
					if (string.IsNullOrEmpty(m_TypeName))
					{
						bool isGenericType = type.IsGenericType;
						m_TypeName = type.Name;
						if (isGenericType)
						{
							int num = m_TypeName.IndexOf('`');
							if (num >= 0)
							{
								m_TypeName = m_TypeName.Remove(num);
							}
						}
					}
					return m_TypeName;
				}
			}

			public string typeNamespace
			{
				get
				{
					if (string.IsNullOrEmpty(m_TypeNamespace))
					{
						m_TypeNamespace = type.Namespace;
					}
					return m_TypeNamespace;
				}
			}

			public TypeData(Type type)
			{
				this.type = type;
			}
		}

		private static uint s_NextId;

		private static List<string> s_EmptyClassList = new List<string>(0);

		internal static readonly PropertyName userDataPropertyKey = new PropertyName("--unity-user-data");

		public static readonly string disabledUssClassName = "unity-disabled";

		private string m_Name;

		private List<string> m_ClassList;

		private List<KeyValuePair<PropertyName, object>> m_PropertyBag;

		internal VisualElementFlags m_Flags;

		private string m_ViewDataKey;

		private RenderHints m_RenderHints;

		internal Rect lastLayout;

		internal Rect lastPseudoPadding;

		internal RenderChainVEData renderChainData;

		private Rect m_Layout;

		private Rect m_BoundingBox;

		private const VisualElementFlags worldBoundingBoxDirtyDependencies = VisualElementFlags.WorldTransformDirty | VisualElementFlags.BoundingBoxDirty | VisualElementFlags.WorldBoundingBoxDirty;

		private Rect m_WorldBoundingBox;

		private const VisualElementFlags worldTransformInverseDirtyDependencies = VisualElementFlags.WorldTransformDirty | VisualElementFlags.WorldTransformInverseDirty;

		private Matrix4x4 m_WorldTransformCache = Matrix4x4.identity;

		private Matrix4x4 m_WorldTransformInverseCache = Matrix4x4.identity;

		private Rect m_WorldClip = Rect.zero;

		private Rect m_WorldClipMinusGroup = Rect.zero;

		private bool m_WorldClipIsInfinite = false;

		internal static readonly Rect s_InfiniteRect = new Rect(-10000f, -10000f, 40000f, 40000f);

		internal PseudoStates triggerPseudoMask;

		internal PseudoStates dependencyPseudoMask;

		private PseudoStates m_PseudoStates;

		private PickingMode m_PickingMode;

		internal ComputedStyle m_Style = InitialStyle.Acquire();

		internal StyleVariableContext variableContext = StyleVariableContext.none;

		internal int inheritedStylesHash = 0;

		internal readonly uint controlid;

		internal int imguiContainerDescendantCount = 0;

		private LanguageDirection m_LanguageDirection;

		private LanguageDirection m_LocalLanguageDirection;

		private static readonly ProfilerMarker k_GenerateVisualContentMarker = new ProfilerMarker("GenerateVisualContent");

		private RenderTargetMode m_SubRenderTargetMode = RenderTargetMode.None;

		private static Material s_runtimeMaterial;

		private Material m_defaultMaterial;

		private List<IValueAnimationUpdate> m_RunningAnimations;

		private static uint s_NextParentVersion;

		private uint m_NextParentCachedVersion;

		private uint m_NextParentRequiredVersion;

		private VisualElement m_CachedNextParentWithEventCallback;

		private int m_EventCallbackCategories = 0;

		private int m_CachedEventCallbackParentCategories = 0;

		private readonly int m_DefaultActionEventCategories;

		private readonly int m_DefaultActionAtTargetEventCategories;

		internal const string k_RootVisualContainerName = "rootVisualContainer";

		private VisualElement m_PhysicalParent;

		private VisualElement m_LogicalParent;

		private static readonly List<VisualElement> s_EmptyList = new List<VisualElement>();

		private List<VisualElement> m_Children;

		private VisualTreeAsset m_VisualTreeAssetSource = null;

		internal static CustomStyleAccess s_CustomStyleAccess = new CustomStyleAccess();

		internal InlineStyleAccess inlineStyleAccess;

		internal List<StyleSheet> styleSheetList;

		private static readonly Regex s_InternalStyleSheetPath = new Regex("^instanceId:[-0-9]+$", RegexOptions.Compiled);

		internal static readonly PropertyName tooltipPropertyKey = new PropertyName("--unity-tooltip");

		private static readonly Dictionary<Type, TypeData> s_TypeData = new Dictionary<Type, TypeData>();

		private TypeData m_TypeData;

		public IResolvedStyle resolvedStyle => this;

		Align IResolvedStyle.alignContent => computedStyle.alignContent;

		Align IResolvedStyle.alignItems => computedStyle.alignItems;

		Align IResolvedStyle.alignSelf => computedStyle.alignSelf;

		Color IResolvedStyle.backgroundColor => computedStyle.backgroundColor;

		Background IResolvedStyle.backgroundImage => computedStyle.backgroundImage;

		BackgroundPosition IResolvedStyle.backgroundPositionX => computedStyle.backgroundPositionX;

		BackgroundPosition IResolvedStyle.backgroundPositionY => computedStyle.backgroundPositionY;

		BackgroundRepeat IResolvedStyle.backgroundRepeat => computedStyle.backgroundRepeat;

		BackgroundSize IResolvedStyle.backgroundSize => computedStyle.backgroundSize;

		Color IResolvedStyle.borderBottomColor => computedStyle.borderBottomColor;

		float IResolvedStyle.borderBottomLeftRadius => computedStyle.borderBottomLeftRadius.value;

		float IResolvedStyle.borderBottomRightRadius => computedStyle.borderBottomRightRadius.value;

		float IResolvedStyle.borderBottomWidth => yogaNode.LayoutBorderBottom;

		Color IResolvedStyle.borderLeftColor => computedStyle.borderLeftColor;

		float IResolvedStyle.borderLeftWidth => yogaNode.LayoutBorderLeft;

		Color IResolvedStyle.borderRightColor => computedStyle.borderRightColor;

		float IResolvedStyle.borderRightWidth => yogaNode.LayoutBorderRight;

		Color IResolvedStyle.borderTopColor => computedStyle.borderTopColor;

		float IResolvedStyle.borderTopLeftRadius => computedStyle.borderTopLeftRadius.value;

		float IResolvedStyle.borderTopRightRadius => computedStyle.borderTopRightRadius.value;

		float IResolvedStyle.borderTopWidth => yogaNode.LayoutBorderTop;

		float IResolvedStyle.bottom => yogaNode.LayoutBottom;

		Color IResolvedStyle.color => computedStyle.color;

		DisplayStyle IResolvedStyle.display => computedStyle.display;

		StyleFloat IResolvedStyle.flexBasis => new StyleFloat(yogaNode.ComputedFlexBasis);

		FlexDirection IResolvedStyle.flexDirection => computedStyle.flexDirection;

		float IResolvedStyle.flexGrow => computedStyle.flexGrow;

		float IResolvedStyle.flexShrink => computedStyle.flexShrink;

		Wrap IResolvedStyle.flexWrap => computedStyle.flexWrap;

		float IResolvedStyle.fontSize => computedStyle.fontSize.value;

		float IResolvedStyle.height => yogaNode.LayoutHeight;

		Justify IResolvedStyle.justifyContent => computedStyle.justifyContent;

		float IResolvedStyle.left => yogaNode.LayoutX;

		float IResolvedStyle.letterSpacing => computedStyle.letterSpacing.value;

		float IResolvedStyle.marginBottom => yogaNode.LayoutMarginBottom;

		float IResolvedStyle.marginLeft => yogaNode.LayoutMarginLeft;

		float IResolvedStyle.marginRight => yogaNode.LayoutMarginRight;

		float IResolvedStyle.marginTop => yogaNode.LayoutMarginTop;

		StyleFloat IResolvedStyle.maxHeight => ResolveLengthValue(computedStyle.maxHeight, isRow: false);

		StyleFloat IResolvedStyle.maxWidth => ResolveLengthValue(computedStyle.maxWidth, isRow: true);

		StyleFloat IResolvedStyle.minHeight => ResolveLengthValue(computedStyle.minHeight, isRow: false);

		StyleFloat IResolvedStyle.minWidth => ResolveLengthValue(computedStyle.minWidth, isRow: true);

		float IResolvedStyle.opacity => computedStyle.opacity;

		float IResolvedStyle.paddingBottom => yogaNode.LayoutPaddingBottom;

		float IResolvedStyle.paddingLeft => yogaNode.LayoutPaddingLeft;

		float IResolvedStyle.paddingRight => yogaNode.LayoutPaddingRight;

		float IResolvedStyle.paddingTop => yogaNode.LayoutPaddingTop;

		Position IResolvedStyle.position => computedStyle.position;

		float IResolvedStyle.right => yogaNode.LayoutRight;

		Rotate IResolvedStyle.rotate => computedStyle.rotate;

		Scale IResolvedStyle.scale => computedStyle.scale;

		TextOverflow IResolvedStyle.textOverflow => computedStyle.textOverflow;

		float IResolvedStyle.top => yogaNode.LayoutY;

		Vector3 IResolvedStyle.transformOrigin => ResolveTransformOrigin();

		IEnumerable<TimeValue> IResolvedStyle.transitionDelay => computedStyle.transitionDelay;

		IEnumerable<TimeValue> IResolvedStyle.transitionDuration => computedStyle.transitionDuration;

		IEnumerable<StylePropertyName> IResolvedStyle.transitionProperty => computedStyle.transitionProperty;

		IEnumerable<EasingFunction> IResolvedStyle.transitionTimingFunction => computedStyle.transitionTimingFunction;

		Vector3 IResolvedStyle.translate => ResolveTranslate();

		Color IResolvedStyle.unityBackgroundImageTintColor => computedStyle.unityBackgroundImageTintColor;

		Font IResolvedStyle.unityFont => computedStyle.unityFont;

		FontDefinition IResolvedStyle.unityFontDefinition => computedStyle.unityFontDefinition;

		FontStyle IResolvedStyle.unityFontStyleAndWeight => computedStyle.unityFontStyleAndWeight;

		float IResolvedStyle.unityParagraphSpacing => computedStyle.unityParagraphSpacing.value;

		int IResolvedStyle.unitySliceBottom => computedStyle.unitySliceBottom;

		int IResolvedStyle.unitySliceLeft => computedStyle.unitySliceLeft;

		int IResolvedStyle.unitySliceRight => computedStyle.unitySliceRight;

		float IResolvedStyle.unitySliceScale => computedStyle.unitySliceScale;

		int IResolvedStyle.unitySliceTop => computedStyle.unitySliceTop;

		TextAnchor IResolvedStyle.unityTextAlign => computedStyle.unityTextAlign;

		Color IResolvedStyle.unityTextOutlineColor => computedStyle.unityTextOutlineColor;

		float IResolvedStyle.unityTextOutlineWidth => computedStyle.unityTextOutlineWidth;

		TextOverflowPosition IResolvedStyle.unityTextOverflowPosition => computedStyle.unityTextOverflowPosition;

		Visibility IResolvedStyle.visibility => computedStyle.visibility;

		WhiteSpace IResolvedStyle.whiteSpace => computedStyle.whiteSpace;

		float IResolvedStyle.width => yogaNode.LayoutWidth;

		float IResolvedStyle.wordSpacing => computedStyle.wordSpacing.value;

		internal bool hasRunningAnimations => styleAnimation.runningAnimationCount > 0;

		internal bool hasCompletedAnimations => styleAnimation.completedAnimationCount > 0;

		int IStylePropertyAnimations.runningAnimationCount { get; set; }

		int IStylePropertyAnimations.completedAnimationCount { get; set; }

		internal IStylePropertyAnimations styleAnimation => this;

		internal bool isCompositeRoot
		{
			get
			{
				return (m_Flags & VisualElementFlags.CompositeRoot) == VisualElementFlags.CompositeRoot;
			}
			set
			{
				m_Flags = (value ? (m_Flags | VisualElementFlags.CompositeRoot) : (m_Flags & ~VisualElementFlags.CompositeRoot));
				if (value)
				{
					SetAsNextParentWithEventCallback();
				}
			}
		}

		internal bool isHierarchyDisplayed
		{
			get
			{
				return (m_Flags & VisualElementFlags.HierarchyDisplayed) == VisualElementFlags.HierarchyDisplayed;
			}
			set
			{
				m_Flags = (value ? (m_Flags | VisualElementFlags.HierarchyDisplayed) : (m_Flags & ~VisualElementFlags.HierarchyDisplayed));
			}
		}

		public string viewDataKey
		{
			get
			{
				return m_ViewDataKey;
			}
			set
			{
				if (m_ViewDataKey != value)
				{
					m_ViewDataKey = value;
					if (!string.IsNullOrEmpty(value))
					{
						IncrementVersion(VersionChangeType.ViewData);
					}
				}
			}
		}

		internal bool enableViewDataPersistence
		{
			get
			{
				return (m_Flags & VisualElementFlags.EnableViewDataPersistence) == VisualElementFlags.EnableViewDataPersistence;
			}
			private set
			{
				m_Flags = (value ? (m_Flags | VisualElementFlags.EnableViewDataPersistence) : (m_Flags & ~VisualElementFlags.EnableViewDataPersistence));
			}
		}

		public object userData
		{
			get
			{
				TryGetPropertyInternal(userDataPropertyKey, out var value);
				return value;
			}
			set
			{
				SetPropertyInternal(userDataPropertyKey, value);
			}
		}

		public override bool canGrabFocus
		{
			get
			{
				bool flag = false;
				for (VisualElement visualElement = hierarchy.parent; visualElement != null; visualElement = visualElement.parent)
				{
					if (visualElement.isCompositeRoot)
					{
						flag |= !visualElement.canGrabFocus;
						break;
					}
				}
				return !flag && visible && resolvedStyle.display != DisplayStyle.None && enabledInHierarchy && base.canGrabFocus;
			}
		}

		public override FocusController focusController => panel?.focusController;

		public UsageHints usageHints
		{
			get
			{
				return (UsageHints)((((renderHints & RenderHints.GroupTransform) != RenderHints.None) ? 2 : 0) | (((renderHints & RenderHints.BoneTransform) != RenderHints.None) ? 1 : 0) | (((renderHints & RenderHints.MaskContainer) != RenderHints.None) ? 4 : 0) | (((renderHints & RenderHints.DynamicColor) != RenderHints.None) ? 8 : 0));
			}
			set
			{
				if ((value & UsageHints.GroupTransform) != UsageHints.None)
				{
					renderHints |= RenderHints.GroupTransform;
				}
				else
				{
					renderHints &= ~RenderHints.GroupTransform;
				}
				if ((value & UsageHints.DynamicTransform) != UsageHints.None)
				{
					renderHints |= RenderHints.BoneTransform;
				}
				else
				{
					renderHints &= ~RenderHints.BoneTransform;
				}
				if ((value & UsageHints.MaskContainer) != UsageHints.None)
				{
					renderHints |= RenderHints.MaskContainer;
				}
				else
				{
					renderHints &= ~RenderHints.MaskContainer;
				}
				if ((value & UsageHints.DynamicColor) != UsageHints.None)
				{
					renderHints |= RenderHints.DynamicColor;
				}
				else
				{
					renderHints &= ~RenderHints.DynamicColor;
				}
			}
		}

		internal RenderHints renderHints
		{
			get
			{
				return m_RenderHints;
			}
			set
			{
				RenderHints renderHints = m_RenderHints & ~RenderHints.DirtyAll;
				RenderHints renderHints2 = value & ~RenderHints.DirtyAll;
				RenderHints renderHints3 = renderHints ^ renderHints2;
				if (renderHints3 != RenderHints.None)
				{
					RenderHints renderHints4 = m_RenderHints & RenderHints.DirtyAll;
					RenderHints renderHints5 = (RenderHints)((int)renderHints3 << 5);
					m_RenderHints = renderHints2 | renderHints4 | renderHints5;
					IncrementVersion(VersionChangeType.RenderHints);
				}
			}
		}

		public ITransform transform => this;

		Vector3 ITransform.position
		{
			get
			{
				return resolvedStyle.translate;
			}
			set
			{
				style.translate = new Translate(value.x, value.y, value.z);
			}
		}

		Quaternion ITransform.rotation
		{
			get
			{
				return resolvedStyle.rotate.ToQuaternion();
			}
			set
			{
				value.ToAngleAxis(out var angle, out var axis);
				style.rotate = new Rotate(angle, axis);
			}
		}

		Vector3 ITransform.scale
		{
			get
			{
				return resolvedStyle.scale.value;
			}
			set
			{
				style.scale = new Scale((Vector2)value);
			}
		}

		Matrix4x4 ITransform.matrix => Matrix4x4.TRS(resolvedStyle.translate, resolvedStyle.rotate.ToQuaternion(), resolvedStyle.scale.value);

		internal bool isLayoutManual
		{
			get
			{
				return (m_Flags & VisualElementFlags.LayoutManual) == VisualElementFlags.LayoutManual;
			}
			private set
			{
				m_Flags = (value ? (m_Flags | VisualElementFlags.LayoutManual) : (m_Flags & ~VisualElementFlags.LayoutManual));
			}
		}

		internal float scaledPixelsPerPoint => elementPanel?.scaledPixelsPerPoint ?? GUIUtility.pixelsPerPoint;

		StyleEnum<ScaleMode> IResolvedStyle.unityBackgroundScaleMode
		{
			get
			{
				bool valid;
				return BackgroundPropertyHelper.ResolveUnityBackgroundScaleMode(computedStyle.backgroundPositionX, computedStyle.backgroundPositionY, computedStyle.backgroundRepeat, computedStyle.backgroundSize, out valid);
			}
		}

		public Rect layout
		{
			get
			{
				Rect result = m_Layout;
				if (yogaNode != null && !isLayoutManual)
				{
					result.x = yogaNode.LayoutX;
					result.y = yogaNode.LayoutY;
					result.width = yogaNode.LayoutWidth;
					result.height = yogaNode.LayoutHeight;
				}
				return result;
			}
			internal set
			{
				if (yogaNode == null)
				{
					yogaNode = new YogaNode();
				}
				if (!isLayoutManual || !(m_Layout == value))
				{
					Rect rect = layout;
					VersionChangeType versionChangeType = (VersionChangeType)0;
					if (!Mathf.Approximately(rect.x, value.x) || !Mathf.Approximately(rect.y, value.y))
					{
						versionChangeType |= VersionChangeType.Transform;
					}
					if (!Mathf.Approximately(rect.width, value.width) || !Mathf.Approximately(rect.height, value.height))
					{
						versionChangeType |= VersionChangeType.Size;
					}
					m_Layout = value;
					isLayoutManual = true;
					IStyle style = this.style;
					style.position = Position.Absolute;
					style.marginLeft = 0f;
					style.marginRight = 0f;
					style.marginBottom = 0f;
					style.marginTop = 0f;
					style.left = value.x;
					style.top = value.y;
					style.right = float.NaN;
					style.bottom = float.NaN;
					style.width = value.width;
					style.height = value.height;
					if (versionChangeType != 0)
					{
						IncrementVersion(versionChangeType);
					}
				}
			}
		}

		public Rect contentRect
		{
			get
			{
				Spacing spacing = new Spacing(resolvedStyle.paddingLeft, resolvedStyle.paddingTop, resolvedStyle.paddingRight, resolvedStyle.paddingBottom);
				return paddingRect - spacing;
			}
		}

		protected Rect paddingRect
		{
			get
			{
				Spacing spacing = new Spacing(resolvedStyle.borderLeftWidth, resolvedStyle.borderTopWidth, resolvedStyle.borderRightWidth, resolvedStyle.borderBottomWidth);
				return rect - spacing;
			}
		}

		internal bool isBoundingBoxDirty
		{
			get
			{
				return (m_Flags & VisualElementFlags.BoundingBoxDirty) == VisualElementFlags.BoundingBoxDirty;
			}
			set
			{
				m_Flags = (value ? (m_Flags | VisualElementFlags.BoundingBoxDirty) : (m_Flags & ~VisualElementFlags.BoundingBoxDirty));
			}
		}

		internal bool isWorldBoundingBoxDirty
		{
			get
			{
				return (m_Flags & VisualElementFlags.WorldBoundingBoxDirty) == VisualElementFlags.WorldBoundingBoxDirty;
			}
			set
			{
				m_Flags = (value ? (m_Flags | VisualElementFlags.WorldBoundingBoxDirty) : (m_Flags & ~VisualElementFlags.WorldBoundingBoxDirty));
			}
		}

		internal bool isWorldBoundingBoxOrDependenciesDirty => (m_Flags & (VisualElementFlags.WorldTransformDirty | VisualElementFlags.BoundingBoxDirty | VisualElementFlags.WorldBoundingBoxDirty)) != 0;

		internal Rect boundingBox
		{
			get
			{
				if (isBoundingBoxDirty)
				{
					UpdateBoundingBox();
					isBoundingBoxDirty = false;
				}
				return m_BoundingBox;
			}
		}

		internal Rect worldBoundingBox
		{
			get
			{
				if (isWorldBoundingBoxOrDependenciesDirty)
				{
					UpdateWorldBoundingBox();
					isWorldBoundingBoxDirty = false;
				}
				return m_WorldBoundingBox;
			}
		}

		private Rect boundingBoxInParentSpace
		{
			get
			{
				Rect result = boundingBox;
				TransformAlignedRectToParentSpace(ref result);
				return result;
			}
		}

		public Rect worldBound
		{
			get
			{
				Rect result = rect;
				TransformAlignedRect(ref worldTransformRef, ref result);
				return result;
			}
		}

		public Rect localBound
		{
			get
			{
				Rect result = rect;
				TransformAlignedRectToParentSpace(ref result);
				return result;
			}
		}

		internal Rect rect
		{
			get
			{
				Rect rect = layout;
				return new Rect(0f, 0f, rect.width, rect.height);
			}
		}

		internal bool isWorldTransformDirty
		{
			get
			{
				return (m_Flags & VisualElementFlags.WorldTransformDirty) == VisualElementFlags.WorldTransformDirty;
			}
			set
			{
				m_Flags = (value ? (m_Flags | VisualElementFlags.WorldTransformDirty) : (m_Flags & ~VisualElementFlags.WorldTransformDirty));
			}
		}

		internal bool isWorldTransformInverseDirty
		{
			get
			{
				return (m_Flags & VisualElementFlags.WorldTransformInverseDirty) == VisualElementFlags.WorldTransformInverseDirty;
			}
			set
			{
				m_Flags = (value ? (m_Flags | VisualElementFlags.WorldTransformInverseDirty) : (m_Flags & ~VisualElementFlags.WorldTransformInverseDirty));
			}
		}

		internal bool isWorldTransformInverseOrDependenciesDirty => (m_Flags & (VisualElementFlags.WorldTransformDirty | VisualElementFlags.WorldTransformInverseDirty)) != 0;

		public Matrix4x4 worldTransform
		{
			get
			{
				if (isWorldTransformDirty)
				{
					UpdateWorldTransform();
				}
				return m_WorldTransformCache;
			}
		}

		internal ref Matrix4x4 worldTransformRef
		{
			get
			{
				if (isWorldTransformDirty)
				{
					UpdateWorldTransform();
				}
				return ref m_WorldTransformCache;
			}
		}

		internal ref Matrix4x4 worldTransformInverse
		{
			get
			{
				if (isWorldTransformInverseOrDependenciesDirty)
				{
					UpdateWorldTransformInverse();
				}
				return ref m_WorldTransformInverseCache;
			}
		}

		internal bool isWorldClipDirty
		{
			get
			{
				return (m_Flags & VisualElementFlags.WorldClipDirty) == VisualElementFlags.WorldClipDirty;
			}
			set
			{
				m_Flags = (value ? (m_Flags | VisualElementFlags.WorldClipDirty) : (m_Flags & ~VisualElementFlags.WorldClipDirty));
			}
		}

		internal Rect worldClip
		{
			get
			{
				if (isWorldClipDirty)
				{
					UpdateWorldClip();
					isWorldClipDirty = false;
				}
				return m_WorldClip;
			}
		}

		internal Rect worldClipMinusGroup
		{
			get
			{
				if (isWorldClipDirty)
				{
					UpdateWorldClip();
					isWorldClipDirty = false;
				}
				return m_WorldClipMinusGroup;
			}
		}

		internal bool worldClipIsInfinite
		{
			get
			{
				if (isWorldClipDirty)
				{
					UpdateWorldClip();
					isWorldClipDirty = false;
				}
				return m_WorldClipIsInfinite;
			}
		}

		internal PseudoStates pseudoStates
		{
			get
			{
				return m_PseudoStates;
			}
			set
			{
				PseudoStates pseudoStates = m_PseudoStates ^ value;
				if (pseudoStates <= (PseudoStates)0)
				{
					return;
				}
				if ((value & PseudoStates.Root) == PseudoStates.Root)
				{
					isRootVisualContainer = true;
				}
				if (pseudoStates != PseudoStates.Root)
				{
					PseudoStates pseudoStates2 = pseudoStates & value;
					PseudoStates pseudoStates3 = pseudoStates & m_PseudoStates;
					if ((triggerPseudoMask & pseudoStates2) != 0 || (dependencyPseudoMask & pseudoStates3) != 0)
					{
						IncrementVersion(VersionChangeType.StyleSheet);
					}
				}
				m_PseudoStates = value;
			}
		}

		internal int containedPointerIds { get; private set; }

		public PickingMode pickingMode
		{
			get
			{
				return m_PickingMode;
			}
			set
			{
				if (m_PickingMode != value)
				{
					m_PickingMode = value;
					IncrementVersion(VersionChangeType.Picking);
				}
			}
		}

		public string name
		{
			get
			{
				return m_Name;
			}
			set
			{
				if (!(m_Name == value))
				{
					m_Name = value;
					IncrementVersion(VersionChangeType.StyleSheet);
				}
			}
		}

		internal List<string> classList
		{
			get
			{
				if (m_ClassList == s_EmptyClassList)
				{
					m_ClassList = ObjectListPool<string>.Get();
				}
				return m_ClassList;
			}
		}

		internal string fullTypeName => typeData.fullTypeName;

		internal string typeName => typeData.typeName;

		internal YogaNode yogaNode { get; private set; }

		internal ref ComputedStyle computedStyle => ref m_Style;

		internal bool hasInlineStyle => inlineStyleAccess != null;

		internal bool styleInitialized
		{
			get
			{
				return (m_Flags & VisualElementFlags.StyleInitialized) == VisualElementFlags.StyleInitialized;
			}
			set
			{
				m_Flags = (value ? (m_Flags | VisualElementFlags.StyleInitialized) : (m_Flags & ~VisualElementFlags.StyleInitialized));
			}
		}

		internal float opacity
		{
			get
			{
				return resolvedStyle.opacity;
			}
			set
			{
				style.opacity = value;
			}
		}

		private bool isParentEnabledInHierarchy => hierarchy.parent == null || hierarchy.parent.enabledInHierarchy;

		public bool enabledInHierarchy => (pseudoStates & PseudoStates.Disabled) != PseudoStates.Disabled;

		public bool enabledSelf { get; private set; }

		public LanguageDirection languageDirection
		{
			get
			{
				return m_LanguageDirection;
			}
			set
			{
				if (m_LanguageDirection != value)
				{
					m_LanguageDirection = value;
					localLanguageDirection = m_LanguageDirection;
				}
			}
		}

		internal LanguageDirection localLanguageDirection
		{
			get
			{
				return m_LocalLanguageDirection;
			}
			set
			{
				if (m_LocalLanguageDirection == value)
				{
					return;
				}
				m_LocalLanguageDirection = value;
				IncrementVersion(VersionChangeType.Layout);
				int count = m_Children.Count;
				for (int i = 0; i < count; i++)
				{
					if (m_Children[i].languageDirection == LanguageDirection.Inherit)
					{
						m_Children[i].localLanguageDirection = m_LocalLanguageDirection;
					}
				}
			}
		}

		public bool visible
		{
			get
			{
				return resolvedStyle.visibility == Visibility.Visible;
			}
			set
			{
				style.visibility = ((!value) ? Visibility.Hidden : Visibility.Visible);
			}
		}

		public Action<MeshGenerationContext> generateVisualContent { get; set; }

		internal bool requireMeasureFunction
		{
			get
			{
				return (m_Flags & VisualElementFlags.RequireMeasureFunction) == VisualElementFlags.RequireMeasureFunction;
			}
			set
			{
				m_Flags = (value ? (m_Flags | VisualElementFlags.RequireMeasureFunction) : (m_Flags & ~VisualElementFlags.RequireMeasureFunction));
				if (value && !yogaNode.IsMeasureDefined)
				{
					AssignMeasureFunction();
				}
				else if (!value && yogaNode.IsMeasureDefined)
				{
					RemoveMeasureFunction();
				}
			}
		}

		internal RenderTargetMode subRenderTargetMode
		{
			get
			{
				return m_SubRenderTargetMode;
			}
			set
			{
				if (m_SubRenderTargetMode != value)
				{
					Debug.Assert(Application.isEditor, "subRenderTargetMode is not supported on runtime yet");
					m_SubRenderTargetMode = value;
					IncrementVersion(VersionChangeType.Repaint);
				}
			}
		}

		internal Material defaultMaterial
		{
			get
			{
				return m_defaultMaterial;
			}
			private set
			{
				if (!(m_defaultMaterial == value))
				{
					m_defaultMaterial = value;
					IncrementVersion(VersionChangeType.Layout | VersionChangeType.Repaint);
				}
			}
		}

		internal VisualElement nextParentWithEventCallback
		{
			get
			{
				if (GetCachedNextParentWithEventCallback(out var nextParent))
				{
					return nextParent;
				}
				for (VisualElement visualElement = hierarchy.parent; visualElement != null; visualElement = visualElement.hierarchy.parent)
				{
					if (visualElement.m_NextParentRequiredVersion != 0)
					{
						PropagateCachedNextParentWithEventCallback(visualElement, visualElement);
						return visualElement;
					}
					if (visualElement.GetCachedNextParentWithEventCallback(out var nextParent2))
					{
						PropagateCachedNextParentWithEventCallback(nextParent2, visualElement);
						return nextParent2;
					}
				}
				m_CachedNextParentWithEventCallback = null;
				return null;
			}
		}

		internal int eventCallbackCategories
		{
			get
			{
				return m_EventCallbackCategories;
			}
			set
			{
				if (m_EventCallbackCategories != value)
				{
					int num = m_EventCallbackCategories ^ value;
					if ((num & -2769) != 0)
					{
						SetAsNextParentWithEventCallback();
						IncrementVersion(VersionChangeType.EventCallbackCategories);
					}
					else
					{
						m_CachedEventCallbackParentCategories |= value;
					}
					m_EventCallbackCategories = value;
				}
			}
		}

		internal int eventCallbackParentCategories
		{
			get
			{
				if (elementPanel == null)
				{
					return -1;
				}
				if (isEventCallbackParentCategoriesDirty)
				{
					UpdateCallbackParentCategories();
					isEventCallbackParentCategoriesDirty = false;
				}
				return m_CachedEventCallbackParentCategories;
			}
		}

		internal bool isEventCallbackParentCategoriesDirty
		{
			get
			{
				return (m_Flags & VisualElementFlags.EventCallbackParentCategoriesDirty) == VisualElementFlags.EventCallbackParentCategoriesDirty;
			}
			set
			{
				m_Flags = (value ? (m_Flags | VisualElementFlags.EventCallbackParentCategoriesDirty) : (m_Flags & ~VisualElementFlags.EventCallbackParentCategoriesDirty));
			}
		}

		public IExperimentalFeatures experimental => this;

		ITransitionAnimations IExperimentalFeatures.animation => this;

		public Hierarchy hierarchy { get; private set; }

		internal bool isRootVisualContainer { get; set; }

		[Obsolete("VisualElement.cacheAsBitmap is deprecated and has no effect")]
		public bool cacheAsBitmap { get; set; }

		internal bool disableClipping
		{
			get
			{
				return (m_Flags & VisualElementFlags.DisableClipping) == VisualElementFlags.DisableClipping;
			}
			set
			{
				m_Flags = (value ? (m_Flags | VisualElementFlags.DisableClipping) : (m_Flags & ~VisualElementFlags.DisableClipping));
			}
		}

		public VisualElement parent => m_LogicalParent;

		internal BaseVisualElementPanel elementPanel { get; private set; }

		public IPanel panel => elementPanel;

		public virtual VisualElement contentContainer => this;

		public VisualTreeAsset visualTreeAssetSource
		{
			get
			{
				return m_VisualTreeAssetSource;
			}
			internal set
			{
				m_VisualTreeAssetSource = value;
			}
		}

		public VisualElement this[int key]
		{
			get
			{
				if (contentContainer == this)
				{
					return hierarchy[key];
				}
				return contentContainer?[key];
			}
		}

		public int childCount
		{
			get
			{
				if (contentContainer == this)
				{
					return hierarchy.childCount;
				}
				return contentContainer?.childCount ?? 0;
			}
		}

		private Vector3 positionWithLayout => ResolveTranslate() + (Vector3)layout.min;

		internal bool hasDefaultRotationAndScale
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return computedStyle.rotate.angle.value == 0f && computedStyle.scale.value == Vector3.one;
			}
		}

		public IVisualElementScheduler schedule => this;

		public IStyle style
		{
			get
			{
				if (inlineStyleAccess == null)
				{
					inlineStyleAccess = new InlineStyleAccess(this);
				}
				return inlineStyleAccess;
			}
		}

		public ICustomStyle customStyle
		{
			get
			{
				s_CustomStyleAccess.SetContext(computedStyle.customProperties, computedStyle.dpiScaling);
				return s_CustomStyleAccess;
			}
		}

		public VisualElementStyleSheetSet styleSheets => new VisualElementStyleSheetSet(this);

		public string tooltip
		{
			get
			{
				string text = GetProperty(tooltipPropertyKey) as string;
				return text ?? string.Empty;
			}
			set
			{
				if (!HasProperty(tooltipPropertyKey))
				{
					if (string.IsNullOrEmpty(value))
					{
						return;
					}
					RegisterCallback<TooltipEvent>(SetTooltip);
				}
				SetProperty(tooltipPropertyKey, value);
			}
		}

		private TypeData typeData
		{
			get
			{
				if (m_TypeData == null)
				{
					Type type = GetType();
					if (!s_TypeData.TryGetValue(type, out m_TypeData))
					{
						m_TypeData = new TypeData(type);
						s_TypeData.Add(type, m_TypeData);
					}
				}
				return m_TypeData;
			}
		}

		private IStylePropertyAnimationSystem GetStylePropertyAnimationSystem()
		{
			return elementPanel?.styleAnimationSystem;
		}

		bool IStylePropertyAnimations.Start(StylePropertyId id, float from, float to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		bool IStylePropertyAnimations.Start(StylePropertyId id, int from, int to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		bool IStylePropertyAnimations.Start(StylePropertyId id, Length from, Length to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		bool IStylePropertyAnimations.Start(StylePropertyId id, Color from, Color to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		bool IStylePropertyAnimations.StartEnum(StylePropertyId id, int from, int to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		bool IStylePropertyAnimations.Start(StylePropertyId id, Background from, Background to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		bool IStylePropertyAnimations.Start(StylePropertyId id, FontDefinition from, FontDefinition to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		bool IStylePropertyAnimations.Start(StylePropertyId id, Font from, Font to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		bool IStylePropertyAnimations.Start(StylePropertyId id, TextShadow from, TextShadow to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		bool IStylePropertyAnimations.Start(StylePropertyId id, Scale from, Scale to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		bool IStylePropertyAnimations.Start(StylePropertyId id, Translate from, Translate to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		bool IStylePropertyAnimations.Start(StylePropertyId id, Rotate from, Rotate to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		bool IStylePropertyAnimations.Start(StylePropertyId id, TransformOrigin from, TransformOrigin to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		bool IStylePropertyAnimations.Start(StylePropertyId id, BackgroundPosition from, BackgroundPosition to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		bool IStylePropertyAnimations.Start(StylePropertyId id, BackgroundRepeat from, BackgroundRepeat to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		bool IStylePropertyAnimations.Start(StylePropertyId id, BackgroundSize from, BackgroundSize to, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return GetStylePropertyAnimationSystem().StartTransition(this, id, from, to, durationMs, delayMs, easingCurve);
		}

		void IStylePropertyAnimations.CancelAnimation(StylePropertyId id)
		{
			GetStylePropertyAnimationSystem()?.CancelAnimation(this, id);
		}

		void IStylePropertyAnimations.CancelAllAnimations()
		{
			if (hasRunningAnimations || hasCompletedAnimations)
			{
				GetStylePropertyAnimationSystem()?.CancelAllAnimations(this);
			}
		}

		bool IStylePropertyAnimations.HasRunningAnimation(StylePropertyId id)
		{
			return hasRunningAnimations && GetStylePropertyAnimationSystem().HasRunningAnimation(this, id);
		}

		void IStylePropertyAnimations.UpdateAnimation(StylePropertyId id)
		{
			GetStylePropertyAnimationSystem().UpdateAnimation(this, id);
		}

		void IStylePropertyAnimations.GetAllAnimations(List<StylePropertyId> outPropertyIds)
		{
			if (hasRunningAnimations || hasCompletedAnimations)
			{
				GetStylePropertyAnimationSystem().GetAllAnimations(this, outPropertyIds);
			}
		}

		internal bool TryConvertLengthUnits(StylePropertyId id, ref Length from, ref Length to, int subPropertyIndex = 0)
		{
			if (from.IsAuto() || from.IsNone() || to.IsAuto() || to.IsNone())
			{
				return false;
			}
			if (float.IsNaN(from.value) || float.IsNaN(to.value))
			{
				return false;
			}
			if (from.unit == to.unit)
			{
				return true;
			}
			if (to.unit == LengthUnit.Pixel)
			{
				if (Mathf.Approximately(from.value, 0f))
				{
					from = new Length(0f, LengthUnit.Pixel);
					return true;
				}
				float? parentSizeForLengthConversion = GetParentSizeForLengthConversion(id, subPropertyIndex);
				if (!parentSizeForLengthConversion.HasValue || !(parentSizeForLengthConversion.Value >= 0f))
				{
					return false;
				}
				from = new Length(from.value * parentSizeForLengthConversion.Value / 100f, LengthUnit.Pixel);
			}
			else
			{
				Assert.AreEqual(LengthUnit.Percent, to.unit);
				float? parentSizeForLengthConversion2 = GetParentSizeForLengthConversion(id, subPropertyIndex);
				if (!parentSizeForLengthConversion2.HasValue || !(parentSizeForLengthConversion2.Value > 0f))
				{
					return false;
				}
				from = new Length(from.value * 100f / parentSizeForLengthConversion2.Value, LengthUnit.Percent);
			}
			return true;
		}

		internal bool TryConvertTransformOriginUnits(ref TransformOrigin from, ref TransformOrigin to)
		{
			Length from2 = from.x;
			Length from3 = from.y;
			Length to2 = to.x;
			Length to3 = to.y;
			if (!TryConvertLengthUnits(StylePropertyId.TransformOrigin, ref from2, ref to2))
			{
				return false;
			}
			if (!TryConvertLengthUnits(StylePropertyId.TransformOrigin, ref from3, ref to3, 1))
			{
				return false;
			}
			from.x = from2;
			from.y = from3;
			return true;
		}

		internal bool TryConvertTranslateUnits(ref Translate from, ref Translate to)
		{
			Length from2 = from.x;
			Length from3 = from.y;
			Length to2 = to.x;
			Length to3 = to.y;
			if (!TryConvertLengthUnits(StylePropertyId.Translate, ref from2, ref to2))
			{
				return false;
			}
			if (!TryConvertLengthUnits(StylePropertyId.Translate, ref from3, ref to3, 1))
			{
				return false;
			}
			from.x = from2;
			from.y = from3;
			return true;
		}

		internal bool TryConvertBackgroundPositionUnits(ref BackgroundPosition from, ref BackgroundPosition to)
		{
			Length from2 = from.offset;
			Length to2 = to.offset;
			if (!TryConvertLengthUnits(StylePropertyId.BackgroundPosition, ref from2, ref to2))
			{
				return false;
			}
			from.offset = from2;
			return true;
		}

		internal bool TryConvertBackgroundSizeUnits(ref BackgroundSize from, ref BackgroundSize to)
		{
			Length from2 = from.x;
			Length from3 = from.y;
			Length to2 = to.x;
			Length to3 = to.y;
			if (!TryConvertLengthUnits(StylePropertyId.BackgroundSize, ref from2, ref to2))
			{
				return false;
			}
			if (!TryConvertLengthUnits(StylePropertyId.BackgroundSize, ref from3, ref to3, 1))
			{
				return false;
			}
			from.x = from2;
			from.y = from3;
			return true;
		}

		private float? GetParentSizeForLengthConversion(StylePropertyId id, int subPropertyIndex = 0)
		{
			switch (id)
			{
			case StylePropertyId.Bottom:
			case StylePropertyId.Height:
			case StylePropertyId.MaxHeight:
			case StylePropertyId.MinHeight:
			case StylePropertyId.Top:
				return hierarchy.parent?.resolvedStyle.height;
			case StylePropertyId.Left:
			case StylePropertyId.MarginBottom:
			case StylePropertyId.MarginLeft:
			case StylePropertyId.MarginRight:
			case StylePropertyId.MarginTop:
			case StylePropertyId.MaxWidth:
			case StylePropertyId.MinWidth:
			case StylePropertyId.PaddingBottom:
			case StylePropertyId.PaddingLeft:
			case StylePropertyId.PaddingRight:
			case StylePropertyId.PaddingTop:
			case StylePropertyId.Right:
			case StylePropertyId.Width:
				return hierarchy.parent?.resolvedStyle.width;
			case StylePropertyId.FlexBasis:
			{
				if (hierarchy.parent == null)
				{
					return null;
				}
				FlexDirection flexDirection = hierarchy.parent.resolvedStyle.flexDirection;
				FlexDirection flexDirection2 = flexDirection;
				if ((uint)flexDirection2 <= 1u)
				{
					return hierarchy.parent.resolvedStyle.height;
				}
				return hierarchy.parent.resolvedStyle.width;
			}
			case StylePropertyId.BorderBottomLeftRadius:
			case StylePropertyId.BorderBottomRightRadius:
			case StylePropertyId.BorderTopLeftRadius:
			case StylePropertyId.BorderTopRightRadius:
				return resolvedStyle.width;
			case StylePropertyId.FontSize:
			case StylePropertyId.LetterSpacing:
			case StylePropertyId.UnityParagraphSpacing:
			case StylePropertyId.WordSpacing:
				return null;
			case StylePropertyId.TransformOrigin:
			case StylePropertyId.Translate:
				return (subPropertyIndex == 0) ? resolvedStyle.width : resolvedStyle.height;
			default:
				return null;
			}
		}

		internal void MarkRenderHintsClean()
		{
			m_RenderHints &= ~RenderHints.DirtyAll;
		}

		internal void ClearManualLayout()
		{
			isLayoutManual = false;
			IStyle style = this.style;
			style.position = StyleKeyword.Null;
			style.marginLeft = StyleKeyword.Null;
			style.marginRight = StyleKeyword.Null;
			style.marginBottom = StyleKeyword.Null;
			style.marginTop = StyleKeyword.Null;
			style.left = StyleKeyword.Null;
			style.top = StyleKeyword.Null;
			style.right = StyleKeyword.Null;
			style.bottom = StyleKeyword.Null;
			style.width = StyleKeyword.Null;
			style.height = StyleKeyword.Null;
		}

		internal void UpdateBoundingBox()
		{
			if (float.IsNaN(this.rect.x) || float.IsNaN(this.rect.y) || float.IsNaN(this.rect.width) || float.IsNaN(this.rect.height))
			{
				m_BoundingBox = Rect.zero;
			}
			else
			{
				m_BoundingBox = this.rect;
				if (!ShouldClip())
				{
					int count = m_Children.Count;
					for (int i = 0; i < count; i++)
					{
						Rect rect = m_Children[i].boundingBoxInParentSpace;
						m_BoundingBox.xMin = Math.Min(m_BoundingBox.xMin, rect.xMin);
						m_BoundingBox.xMax = Math.Max(m_BoundingBox.xMax, rect.xMax);
						m_BoundingBox.yMin = Math.Min(m_BoundingBox.yMin, rect.yMin);
						m_BoundingBox.yMax = Math.Max(m_BoundingBox.yMax, rect.yMax);
					}
				}
			}
			isWorldBoundingBoxDirty = true;
		}

		internal void UpdateWorldBoundingBox()
		{
			m_WorldBoundingBox = boundingBox;
			TransformAlignedRect(ref worldTransformRef, ref m_WorldBoundingBox);
		}

		internal void UpdateWorldTransform()
		{
			if (elementPanel != null && !elementPanel.duringLayoutPhase)
			{
				isWorldTransformDirty = false;
			}
			if (hierarchy.parent != null)
			{
				if (hasDefaultRotationAndScale)
				{
					TranslateMatrix34(ref hierarchy.parent.worldTransformRef, positionWithLayout, out m_WorldTransformCache);
				}
				else
				{
					GetPivotedMatrixWithLayout(out var result);
					MultiplyMatrix34(ref hierarchy.parent.worldTransformRef, ref result, out m_WorldTransformCache);
				}
			}
			else
			{
				GetPivotedMatrixWithLayout(out m_WorldTransformCache);
			}
			isWorldTransformInverseDirty = true;
			isWorldBoundingBoxDirty = true;
		}

		internal void UpdateWorldTransformInverse()
		{
			Matrix4x4.Inverse3DAffine(worldTransform, ref m_WorldTransformInverseCache);
			isWorldTransformInverseDirty = false;
		}

		internal void EnsureWorldTransformAndClipUpToDate()
		{
			if (isWorldTransformDirty)
			{
				UpdateWorldTransform();
			}
			if (isWorldClipDirty)
			{
				UpdateWorldClip();
				isWorldClipDirty = false;
			}
		}

		private void UpdateWorldClip()
		{
			if (hierarchy.parent != null)
			{
				m_WorldClip = hierarchy.parent.worldClip;
				bool flag = hierarchy.parent.worldClipIsInfinite;
				if (hierarchy.parent != renderChainData.groupTransformAncestor)
				{
					m_WorldClipMinusGroup = hierarchy.parent.worldClipMinusGroup;
				}
				else
				{
					flag = true;
					m_WorldClipMinusGroup = s_InfiniteRect;
				}
				if (ShouldClip())
				{
					Rect rect = SubstractBorderPadding(worldBound);
					m_WorldClip = CombineClipRects(rect, m_WorldClip);
					m_WorldClipMinusGroup = (flag ? rect : CombineClipRects(rect, m_WorldClipMinusGroup));
					m_WorldClipIsInfinite = false;
				}
				else
				{
					m_WorldClipIsInfinite = flag;
				}
			}
			else
			{
				m_WorldClipMinusGroup = (m_WorldClip = ((panel != null) ? panel.visualTree.rect : s_InfiniteRect));
				m_WorldClipIsInfinite = true;
			}
		}

		private Rect CombineClipRects(Rect rect, Rect parentRect)
		{
			float num = Mathf.Max(rect.xMin, parentRect.xMin);
			float num2 = Mathf.Min(rect.xMax, parentRect.xMax);
			float num3 = Mathf.Max(rect.yMin, parentRect.yMin);
			float num4 = Mathf.Min(rect.yMax, parentRect.yMax);
			float width = Mathf.Max(num2 - num, 0f);
			float height = Mathf.Max(num4 - num3, 0f);
			return new Rect(num, num3, width, height);
		}

		private Rect SubstractBorderPadding(Rect worldRect)
		{
			float m = worldTransform.m00;
			float m2 = worldTransform.m11;
			worldRect.x += resolvedStyle.borderLeftWidth * m;
			worldRect.y += resolvedStyle.borderTopWidth * m2;
			worldRect.width -= (resolvedStyle.borderLeftWidth + resolvedStyle.borderRightWidth) * m;
			worldRect.height -= (resolvedStyle.borderTopWidth + resolvedStyle.borderBottomWidth) * m2;
			if (computedStyle.unityOverflowClipBox == OverflowClipBox.ContentBox)
			{
				worldRect.x += resolvedStyle.paddingLeft * m;
				worldRect.y += resolvedStyle.paddingTop * m2;
				worldRect.width -= (resolvedStyle.paddingLeft + resolvedStyle.paddingRight) * m;
				worldRect.height -= (resolvedStyle.paddingTop + resolvedStyle.paddingBottom) * m2;
			}
			return worldRect;
		}

		internal static Rect ComputeAAAlignedBound(Rect position, Matrix4x4 mat)
		{
			Rect rect = position;
			Vector3 vector = mat.MultiplyPoint3x4(new Vector3(rect.x, rect.y, 0f));
			Vector3 vector2 = mat.MultiplyPoint3x4(new Vector3(rect.x + rect.width, rect.y, 0f));
			Vector3 vector3 = mat.MultiplyPoint3x4(new Vector3(rect.x, rect.y + rect.height, 0f));
			Vector3 vector4 = mat.MultiplyPoint3x4(new Vector3(rect.x + rect.width, rect.y + rect.height, 0f));
			return Rect.MinMaxRect(Mathf.Min(vector.x, Mathf.Min(vector2.x, Mathf.Min(vector3.x, vector4.x))), Mathf.Min(vector.y, Mathf.Min(vector2.y, Mathf.Min(vector3.y, vector4.y))), Mathf.Max(vector.x, Mathf.Max(vector2.x, Mathf.Max(vector3.x, vector4.x))), Mathf.Max(vector.y, Mathf.Max(vector2.y, Mathf.Max(vector3.y, vector4.y))));
		}

		private void UpdateHoverPseudoState()
		{
			if (containedPointerIds == 0 || panel == null)
			{
				pseudoStates &= ~PseudoStates.Hover;
				return;
			}
			bool flag = false;
			for (int i = 0; i < PointerId.maxPointers; i++)
			{
				if ((containedPointerIds & (1 << i)) != 0 && IsPartOfCapturedChain(this, panel.GetCapturingElement(i)))
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				pseudoStates |= PseudoStates.Hover;
			}
			else
			{
				pseudoStates &= ~PseudoStates.Hover;
			}
		}

		private static bool IsPartOfCapturedChain(VisualElement self, in IEventHandler capturingElement)
		{
			if (self == null)
			{
				return false;
			}
			if (capturingElement == null)
			{
				return true;
			}
			if (capturingElement == self)
			{
				return true;
			}
			return self.Contains(capturingElement as VisualElement);
		}

		private void ChangeIMGUIContainerCount(int delta)
		{
			for (VisualElement visualElement = this; visualElement != null; visualElement = visualElement.hierarchy.parent)
			{
				visualElement.imguiContainerDescendantCount += delta;
			}
		}

		public VisualElement()
		{
			UIElementsRuntimeUtilityNative.VisualElementCreation();
			m_Children = s_EmptyList;
			controlid = ++s_NextId;
			hierarchy = new Hierarchy(this);
			m_ClassList = s_EmptyClassList;
			m_Flags = VisualElementFlags.Init;
			SetEnabled(value: true);
			base.focusable = false;
			name = string.Empty;
			yogaNode = new YogaNode();
			renderHints = RenderHints.None;
			EventInterestReflectionUtils.GetDefaultEventInterests(GetType(), out m_DefaultActionEventCategories, out m_DefaultActionAtTargetEventCategories);
		}

		[EventInterest(new Type[]
		{
			typeof(MouseOverEvent),
			typeof(MouseOutEvent),
			typeof(MouseCaptureOutEvent),
			typeof(PointerEnterEvent),
			typeof(PointerLeaveEvent),
			typeof(PointerCaptureEvent),
			typeof(PointerCaptureOutEvent),
			typeof(BlurEvent),
			typeof(FocusEvent),
			typeof(TooltipEvent)
		})]
		protected override void ExecuteDefaultAction(EventBase evt)
		{
			base.ExecuteDefaultAction(evt);
			if (evt == null)
			{
				return;
			}
			if (evt.eventTypeId == EventBase<MouseOverEvent>.TypeId() || evt.eventTypeId == EventBase<MouseOutEvent>.TypeId() || evt.eventTypeId == EventBase<MouseCaptureOutEvent>.TypeId())
			{
				UpdateCursorStyle(evt.eventTypeId);
			}
			else if (evt.eventTypeId == EventBase<PointerEnterEvent>.TypeId())
			{
				containedPointerIds |= 1 << ((IPointerEvent)evt).pointerId;
				UpdateHoverPseudoState();
			}
			else if (evt.eventTypeId == EventBase<PointerLeaveEvent>.TypeId())
			{
				containedPointerIds &= ~(1 << ((IPointerEvent)evt).pointerId);
				UpdateHoverPseudoState();
			}
			else if (evt.eventTypeId == EventBase<PointerCaptureEvent>.TypeId() || evt.eventTypeId == EventBase<PointerCaptureOutEvent>.TypeId())
			{
				for (VisualElement visualElement = this; visualElement != null; visualElement = visualElement.parent)
				{
					visualElement.UpdateHoverPseudoState();
				}
				VisualElement visualElement2 = elementPanel?.GetTopElementUnderPointer(((IPointerCaptureEventInternal)evt).pointerId);
				VisualElement visualElement3 = visualElement2;
				while (visualElement3 != null && visualElement3 != this)
				{
					visualElement3.UpdateHoverPseudoState();
					visualElement3 = visualElement3.parent;
				}
			}
			else if (evt.eventTypeId == EventBase<BlurEvent>.TypeId())
			{
				pseudoStates &= ~PseudoStates.Focus;
			}
			else if (evt.eventTypeId == EventBase<FocusEvent>.TypeId())
			{
				pseudoStates |= PseudoStates.Focus;
			}
			else if (evt.eventTypeId == EventBase<TooltipEvent>.TypeId())
			{
				SetTooltip((TooltipEvent)evt);
			}
		}

		internal virtual Rect GetTooltipRect()
		{
			return worldBound;
		}

		private void SetTooltip(TooltipEvent e)
		{
			if (e.currentTarget is VisualElement visualElement && !string.IsNullOrEmpty(visualElement.tooltip))
			{
				e.rect = visualElement.GetTooltipRect();
				e.tooltip = visualElement.tooltip;
				e.StopImmediatePropagation();
			}
		}

		public sealed override void Focus()
		{
			if (!canGrabFocus && hierarchy.parent != null)
			{
				hierarchy.parent.Focus();
			}
			else
			{
				base.Focus();
			}
		}

		internal void SetPanel(BaseVisualElementPanel p)
		{
			if (panel == p)
			{
				return;
			}
			List<VisualElement> list = VisualElementListPool.Get();
			try
			{
				list.Add(this);
				GatherAllChildren(list);
				EventDispatcherGate? eventDispatcherGate = null;
				if (p?.dispatcher != null)
				{
					eventDispatcherGate = new EventDispatcherGate(p.dispatcher);
				}
				EventDispatcherGate? eventDispatcherGate2 = null;
				if (panel?.dispatcher != null && panel.dispatcher != p?.dispatcher)
				{
					eventDispatcherGate2 = new EventDispatcherGate(panel.dispatcher);
				}
				BaseVisualElementPanel baseVisualElementPanel = elementPanel;
				uint num = baseVisualElementPanel?.hierarchyVersion ?? 0;
				using (eventDispatcherGate)
				{
					using (eventDispatcherGate2)
					{
						panel?.dispatcher?.m_ClickDetector.Cleanup(list);
						foreach (VisualElement item in list)
						{
							item.WillChangePanel(p);
						}
						uint num2 = baseVisualElementPanel?.hierarchyVersion ?? 0;
						if (num != num2)
						{
							list.Clear();
							list.Add(this);
							GatherAllChildren(list);
						}
						VisualElementFlags visualElementFlags = ((p != null) ? VisualElementFlags.NeedsAttachToPanelEvent : ((VisualElementFlags)0));
						foreach (VisualElement item2 in list)
						{
							item2.elementPanel = p;
							item2.m_Flags |= visualElementFlags;
							item2.m_CachedNextParentWithEventCallback = null;
						}
						foreach (VisualElement item3 in list)
						{
							item3.HasChangedPanel(baseVisualElementPanel);
						}
					}
				}
			}
			finally
			{
				VisualElementListPool.Release(list);
			}
		}

		private void WillChangePanel(BaseVisualElementPanel destinationPanel)
		{
			if (panel == null)
			{
				return;
			}
			UnregisterRunningAnimations();
			if ((m_Flags & VisualElementFlags.NeedsAttachToPanelEvent) == 0 && HasEventCallbacksOrDefaultActions(EventBase<DetachFromPanelEvent>.EventCategory))
			{
				using DetachFromPanelEvent detachFromPanelEvent = PanelChangedEventBase<DetachFromPanelEvent>.GetPooled(panel, destinationPanel);
				detachFromPanelEvent.target = this;
				HandleEventAtTargetAndDefaultPhase(detachFromPanelEvent);
			}
			UnregisterRunningAnimations();
		}

		private void HasChangedPanel(BaseVisualElementPanel prevPanel)
		{
			if (panel != null)
			{
				yogaNode.Config = elementPanel.yogaConfig;
				RegisterRunningAnimations();
				pseudoStates &= ~(PseudoStates.Active | PseudoStates.Hover | PseudoStates.Focus);
				if ((m_Flags & VisualElementFlags.NeedsAttachToPanelEvent) == VisualElementFlags.NeedsAttachToPanelEvent)
				{
					if (HasEventCallbacksOrDefaultActions(EventBase<AttachToPanelEvent>.EventCategory))
					{
						using AttachToPanelEvent attachToPanelEvent = PanelChangedEventBase<AttachToPanelEvent>.GetPooled(prevPanel, panel);
						attachToPanelEvent.target = this;
						HandleEventAtTargetAndDefaultPhase(attachToPanelEvent);
					}
					m_Flags &= ~VisualElementFlags.NeedsAttachToPanelEvent;
				}
			}
			else
			{
				yogaNode.Config = YogaConfig.Default;
			}
			styleInitialized = false;
			IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Transform);
			if (!string.IsNullOrEmpty(viewDataKey))
			{
				IncrementVersion(VersionChangeType.ViewData);
			}
		}

		public sealed override void SendEvent(EventBase e)
		{
			elementPanel?.SendEvent(e);
		}

		internal sealed override void SendEvent(EventBase e, DispatchMode dispatchMode)
		{
			elementPanel?.SendEvent(e, dispatchMode);
		}

		internal void IncrementVersion(VersionChangeType changeType)
		{
			elementPanel?.OnVersionChanged(this, changeType);
		}

		internal void InvokeHierarchyChanged(HierarchyChangeType changeType)
		{
			elementPanel?.InvokeHierarchyChanged(this, changeType);
		}

		[Obsolete("SetEnabledFromHierarchy is deprecated and will be removed in a future release. Please use SetEnabled instead.")]
		protected internal bool SetEnabledFromHierarchy(bool state)
		{
			return SetEnabledFromHierarchyPrivate(state);
		}

		private bool SetEnabledFromHierarchyPrivate(bool state)
		{
			bool flag = enabledInHierarchy;
			bool flag2 = false;
			if (state)
			{
				if (isParentEnabledInHierarchy)
				{
					if (enabledSelf)
					{
						RemoveFromClassList(disabledUssClassName);
					}
					else
					{
						flag2 = true;
						AddToClassList(disabledUssClassName);
					}
				}
				else
				{
					flag2 = true;
					RemoveFromClassList(disabledUssClassName);
				}
			}
			else
			{
				flag2 = true;
				EnableInClassList(disabledUssClassName, isParentEnabledInHierarchy);
			}
			if (flag2)
			{
				if (focusController != null && focusController.IsFocused(this))
				{
					EventDispatcherGate? eventDispatcherGate = null;
					if (panel?.dispatcher != null)
					{
						eventDispatcherGate = new EventDispatcherGate(panel.dispatcher);
					}
					using (eventDispatcherGate)
					{
						BlurImmediately();
					}
				}
				pseudoStates |= PseudoStates.Disabled;
			}
			else
			{
				pseudoStates &= ~PseudoStates.Disabled;
			}
			return flag != enabledInHierarchy;
		}

		public void SetEnabled(bool value)
		{
			if (enabledSelf != value)
			{
				enabledSelf = value;
				PropagateEnabledToChildren(value);
			}
		}

		private void PropagateEnabledToChildren(bool value)
		{
			if (SetEnabledFromHierarchyPrivate(value))
			{
				int count = m_Children.Count;
				for (int i = 0; i < count; i++)
				{
					m_Children[i].PropagateEnabledToChildren(value);
				}
			}
		}

		public void MarkDirtyRepaint()
		{
			IncrementVersion(VersionChangeType.Repaint);
		}

		internal void InvokeGenerateVisualContent(MeshGenerationContext mgc)
		{
			if (generateVisualContent == null)
			{
				return;
			}
			try
			{
				using (k_GenerateVisualContentMarker.Auto())
				{
					generateVisualContent(mgc);
				}
			}
			catch (Exception exception)
			{
				Debug.LogException(exception);
			}
		}

		internal void GetFullHierarchicalViewDataKey(StringBuilder key)
		{
			if (parent != null)
			{
				parent.GetFullHierarchicalViewDataKey(key);
			}
			if (!string.IsNullOrEmpty(viewDataKey))
			{
				key.Append("__");
				key.Append(viewDataKey);
			}
		}

		internal string GetFullHierarchicalViewDataKey()
		{
			StringBuilder stringBuilder = new StringBuilder();
			GetFullHierarchicalViewDataKey(stringBuilder);
			return stringBuilder.ToString();
		}

		internal T GetOrCreateViewData<T>(object existing, string key) where T : class, new()
		{
			Debug.Assert(elementPanel != null, "VisualElement.elementPanel is null! Cannot load persistent data.");
			ISerializableJsonDictionary serializableJsonDictionary = ((elementPanel == null || elementPanel.getViewDataDictionary == null) ? null : elementPanel.getViewDataDictionary());
			if (serializableJsonDictionary == null || string.IsNullOrEmpty(viewDataKey) || !enableViewDataPersistence)
			{
				if (existing != null)
				{
					return existing as T;
				}
				return new T();
			}
			string key2 = key + "__" + typeof(T);
			if (!serializableJsonDictionary.ContainsKey(key2))
			{
				serializableJsonDictionary.Set(key2, new T());
			}
			return serializableJsonDictionary.Get<T>(key2);
		}

		internal T GetOrCreateViewData<T>(ScriptableObject existing, string key) where T : ScriptableObject
		{
			Debug.Assert(elementPanel != null, "VisualElement.elementPanel is null! Cannot load view data.");
			ISerializableJsonDictionary serializableJsonDictionary = ((elementPanel == null || elementPanel.getViewDataDictionary == null) ? null : elementPanel.getViewDataDictionary());
			if (serializableJsonDictionary == null || string.IsNullOrEmpty(viewDataKey) || !enableViewDataPersistence)
			{
				if (existing != null)
				{
					return existing as T;
				}
				return ScriptableObject.CreateInstance<T>();
			}
			string key2 = key + "__" + typeof(T);
			if (!serializableJsonDictionary.ContainsKey(key2))
			{
				serializableJsonDictionary.Set(key2, ScriptableObject.CreateInstance<T>());
			}
			return serializableJsonDictionary.GetScriptable<T>(key2);
		}

		internal void OverwriteFromViewData(object obj, string key)
		{
			if (obj == null)
			{
				throw new ArgumentNullException("obj");
			}
			Debug.Assert(elementPanel != null, "VisualElement.elementPanel is null! Cannot load view data.");
			ISerializableJsonDictionary serializableJsonDictionary = ((elementPanel == null || elementPanel.getViewDataDictionary == null) ? null : elementPanel.getViewDataDictionary());
			if (serializableJsonDictionary != null && !string.IsNullOrEmpty(viewDataKey) && enableViewDataPersistence)
			{
				string key2 = key + "__" + obj.GetType();
				if (!serializableJsonDictionary.ContainsKey(key2))
				{
					serializableJsonDictionary.Set(key2, obj);
				}
				else
				{
					serializableJsonDictionary.Overwrite(obj, key2);
				}
			}
		}

		internal void SaveViewData()
		{
			if (elementPanel != null && elementPanel.saveViewData != null && !string.IsNullOrEmpty(viewDataKey) && enableViewDataPersistence)
			{
				elementPanel.saveViewData();
			}
		}

		internal bool IsViewDataPersitenceSupportedOnChildren(bool existingState)
		{
			bool result = existingState;
			if (string.IsNullOrEmpty(viewDataKey) && this != contentContainer)
			{
				result = false;
			}
			if (parent != null && this == parent.contentContainer)
			{
				result = true;
			}
			return result;
		}

		internal void OnViewDataReady(bool enablePersistence)
		{
			enableViewDataPersistence = enablePersistence;
			OnViewDataReady();
		}

		internal virtual void OnViewDataReady()
		{
		}

		public virtual bool ContainsPoint(Vector2 localPoint)
		{
			return rect.Contains(localPoint);
		}

		public virtual bool Overlaps(Rect rectangle)
		{
			return rect.Overlaps(rectangle, allowInverse: true);
		}

		private void AssignMeasureFunction()
		{
			yogaNode.SetMeasureFunction((YogaNode node, float f, YogaMeasureMode mode, float f1, YogaMeasureMode heightMode) => Measure(node, f, mode, f1, heightMode));
		}

		private void RemoveMeasureFunction()
		{
			yogaNode.SetMeasureFunction(null);
		}

		protected internal virtual Vector2 DoMeasure(float desiredWidth, MeasureMode widthMode, float desiredHeight, MeasureMode heightMode)
		{
			return new Vector2(float.NaN, float.NaN);
		}

		internal YogaSize Measure(YogaNode node, float width, YogaMeasureMode widthMode, float height, YogaMeasureMode heightMode)
		{
			Debug.Assert(node == yogaNode, "YogaNode instance mismatch");
			Vector2 vector = DoMeasure(width, (MeasureMode)widthMode, height, (MeasureMode)heightMode);
			float pixelsPerPoint = scaledPixelsPerPoint;
			return MeasureOutput.Make(AlignmentUtils.RoundToPixelGrid(vector.x, pixelsPerPoint), AlignmentUtils.RoundToPixelGrid(vector.y, pixelsPerPoint));
		}

		internal void SetSize(Vector2 size)
		{
			Rect rect = layout;
			rect.width = size.x;
			rect.height = size.y;
			layout = rect;
		}

		private void FinalizeLayout()
		{
			if (hasInlineStyle || hasRunningAnimations)
			{
				computedStyle.SyncWithLayout(yogaNode);
			}
			else
			{
				yogaNode.CopyStyle(computedStyle.yogaNode);
			}
		}

		internal void SetInlineRule(StyleSheet sheet, StyleRule rule)
		{
			if (inlineStyleAccess == null)
			{
				inlineStyleAccess = new InlineStyleAccess(this);
			}
			inlineStyleAccess.SetInlineRule(sheet, rule);
		}

		internal void UpdateInlineRule(StyleSheet sheet, StyleRule rule)
		{
			ComputedStyle x = computedStyle.Acquire();
			long matchingRulesHash = computedStyle.matchingRulesHash;
			if (!StyleCache.TryGetValue(matchingRulesHash, out var data))
			{
				data = InitialStyle.Get();
			}
			m_Style.CopyFrom(ref data);
			SetInlineRule(sheet, rule);
			FinalizeLayout();
			VersionChangeType changeType = ComputedStyle.CompareChanges(ref x, ref computedStyle);
			x.Release();
			IncrementVersion(changeType);
		}

		internal void SetComputedStyle(ref ComputedStyle newStyle)
		{
			if (m_Style.matchingRulesHash != newStyle.matchingRulesHash)
			{
				VersionChangeType changeType = ComputedStyle.CompareChanges(ref m_Style, ref newStyle);
				m_Style.CopyFrom(ref newStyle);
				FinalizeLayout();
				if (elementPanel?.GetTopElementUnderPointer(PointerId.mousePointerId) == this)
				{
					elementPanel.cursorManager.SetCursor(m_Style.cursor);
				}
				IncrementVersion(changeType);
			}
		}

		internal void ResetPositionProperties()
		{
			if (hasInlineStyle)
			{
				style.position = StyleKeyword.Null;
				style.marginLeft = StyleKeyword.Null;
				style.marginRight = StyleKeyword.Null;
				style.marginBottom = StyleKeyword.Null;
				style.marginTop = StyleKeyword.Null;
				style.left = StyleKeyword.Null;
				style.top = StyleKeyword.Null;
				style.right = StyleKeyword.Null;
				style.bottom = StyleKeyword.Null;
				style.width = StyleKeyword.Null;
				style.height = StyleKeyword.Null;
			}
		}

		public override string ToString()
		{
			return GetType().Name + " " + name + " " + layout.ToString() + " world rect: " + worldBound.ToString();
		}

		public IEnumerable<string> GetClasses()
		{
			return m_ClassList;
		}

		internal List<string> GetClassesForIteration()
		{
			return m_ClassList;
		}

		public void ClearClassList()
		{
			if (m_ClassList.Count > 0)
			{
				ObjectListPool<string>.Release(m_ClassList);
				m_ClassList = s_EmptyClassList;
				IncrementVersion(VersionChangeType.StyleSheet);
			}
		}

		public void AddToClassList(string className)
		{
			if (string.IsNullOrEmpty(className))
			{
				return;
			}
			if (m_ClassList == s_EmptyClassList)
			{
				m_ClassList = ObjectListPool<string>.Get();
			}
			else
			{
				if (m_ClassList.Contains(className))
				{
					return;
				}
				if (m_ClassList.Capacity == m_ClassList.Count)
				{
					m_ClassList.Capacity++;
				}
			}
			m_ClassList.Add(className);
			IncrementVersion(VersionChangeType.StyleSheet);
		}

		public void RemoveFromClassList(string className)
		{
			if (m_ClassList.Remove(className))
			{
				if (m_ClassList.Count == 0)
				{
					ObjectListPool<string>.Release(m_ClassList);
					m_ClassList = s_EmptyClassList;
				}
				IncrementVersion(VersionChangeType.StyleSheet);
			}
		}

		public void ToggleInClassList(string className)
		{
			if (ClassListContains(className))
			{
				RemoveFromClassList(className);
			}
			else
			{
				AddToClassList(className);
			}
		}

		public void EnableInClassList(string className, bool enable)
		{
			if (enable)
			{
				AddToClassList(className);
			}
			else
			{
				RemoveFromClassList(className);
			}
		}

		public bool ClassListContains(string cls)
		{
			for (int i = 0; i < m_ClassList.Count; i++)
			{
				if (m_ClassList[i].Equals(cls, StringComparison.Ordinal))
				{
					return true;
				}
			}
			return false;
		}

		public object FindAncestorUserData()
		{
			for (VisualElement visualElement = parent; visualElement != null; visualElement = visualElement.parent)
			{
				if (visualElement.userData != null)
				{
					return visualElement.userData;
				}
			}
			return null;
		}

		internal object GetProperty(PropertyName key)
		{
			CheckUserKeyArgument(key);
			TryGetPropertyInternal(key, out var value);
			return value;
		}

		internal void SetProperty(PropertyName key, object value)
		{
			CheckUserKeyArgument(key);
			SetPropertyInternal(key, value);
		}

		internal bool HasProperty(PropertyName key)
		{
			CheckUserKeyArgument(key);
			object value;
			return TryGetPropertyInternal(key, out value);
		}

		private bool TryGetPropertyInternal(PropertyName key, out object value)
		{
			value = null;
			if (m_PropertyBag != null)
			{
				for (int i = 0; i < m_PropertyBag.Count; i++)
				{
					if (m_PropertyBag[i].Key == key)
					{
						value = m_PropertyBag[i].Value;
						return true;
					}
				}
			}
			return false;
		}

		private static void CheckUserKeyArgument(PropertyName key)
		{
			if (PropertyName.IsNullOrEmpty(key))
			{
				throw new ArgumentNullException("key");
			}
			if (key == userDataPropertyKey)
			{
				throw new InvalidOperationException($"The {userDataPropertyKey} key is reserved by the system");
			}
		}

		private void SetPropertyInternal(PropertyName key, object value)
		{
			KeyValuePair<PropertyName, object> keyValuePair = new KeyValuePair<PropertyName, object>(key, value);
			if (m_PropertyBag == null)
			{
				m_PropertyBag = new List<KeyValuePair<PropertyName, object>>(1);
				m_PropertyBag.Add(keyValuePair);
				return;
			}
			for (int i = 0; i < m_PropertyBag.Count; i++)
			{
				if (m_PropertyBag[i].Key == key)
				{
					m_PropertyBag[i] = keyValuePair;
					return;
				}
			}
			if (m_PropertyBag.Capacity == m_PropertyBag.Count)
			{
				m_PropertyBag.Capacity++;
			}
			m_PropertyBag.Add(keyValuePair);
		}

		private void UpdateCursorStyle(long eventType)
		{
			if (elementPanel == null)
			{
				return;
			}
			if (eventType == EventBase<MouseCaptureOutEvent>.TypeId())
			{
				VisualElement topElementUnderPointer = elementPanel.GetTopElementUnderPointer(PointerId.mousePointerId);
				if (topElementUnderPointer != null)
				{
					elementPanel.cursorManager.SetCursor(topElementUnderPointer.computedStyle.cursor);
				}
				else
				{
					elementPanel.cursorManager.ResetCursor();
				}
				return;
			}
			IEventHandler capturingElement = elementPanel.GetCapturingElement(PointerId.mousePointerId);
			if (capturingElement == null || capturingElement == this)
			{
				if (eventType == EventBase<MouseOverEvent>.TypeId() && elementPanel.GetTopElementUnderPointer(PointerId.mousePointerId) == this)
				{
					elementPanel.cursorManager.SetCursor(computedStyle.cursor);
				}
				else if (eventType == EventBase<MouseOutEvent>.TypeId() && capturingElement == null)
				{
					elementPanel.cursorManager.ResetCursor();
				}
			}
		}

		private Material getRuntimeMaterial()
		{
			if (s_runtimeMaterial != null)
			{
				return s_runtimeMaterial;
			}
			Shader shader = Shader.Find(UIRUtility.k_DefaultShaderName);
			Debug.Assert(shader != null, "Failed to load UIElements default shader");
			if (shader != null)
			{
				shader.hideFlags |= HideFlags.DontSaveInEditor;
				Material material = new Material(shader);
				material.hideFlags |= HideFlags.DontSaveInEditor;
				return s_runtimeMaterial = material;
			}
			return null;
		}

		private VisualElementAnimationSystem GetAnimationSystem()
		{
			if (elementPanel != null)
			{
				return elementPanel.GetUpdater(VisualTreeUpdatePhase.Animation) as VisualElementAnimationSystem;
			}
			return null;
		}

		internal void RegisterAnimation(IValueAnimationUpdate anim)
		{
			if (m_RunningAnimations == null)
			{
				m_RunningAnimations = new List<IValueAnimationUpdate>();
			}
			m_RunningAnimations.Add(anim);
			GetAnimationSystem()?.RegisterAnimation(anim);
		}

		internal void UnregisterAnimation(IValueAnimationUpdate anim)
		{
			if (m_RunningAnimations != null)
			{
				m_RunningAnimations.Remove(anim);
			}
			GetAnimationSystem()?.UnregisterAnimation(anim);
		}

		private void UnregisterRunningAnimations()
		{
			if (m_RunningAnimations != null && m_RunningAnimations.Count > 0)
			{
				GetAnimationSystem()?.UnregisterAnimations(m_RunningAnimations);
			}
			styleAnimation.CancelAllAnimations();
		}

		private void RegisterRunningAnimations()
		{
			if (m_RunningAnimations != null && m_RunningAnimations.Count > 0)
			{
				GetAnimationSystem()?.RegisterAnimations(m_RunningAnimations);
			}
		}

		ValueAnimation<float> ITransitionAnimations.Start(float from, float to, int durationMs, Action<VisualElement, float> onValueChanged)
		{
			return experimental.animation.Start((VisualElement e) => from, to, durationMs, onValueChanged);
		}

		ValueAnimation<Rect> ITransitionAnimations.Start(Rect from, Rect to, int durationMs, Action<VisualElement, Rect> onValueChanged)
		{
			return experimental.animation.Start((VisualElement e) => from, to, durationMs, onValueChanged);
		}

		ValueAnimation<Color> ITransitionAnimations.Start(Color from, Color to, int durationMs, Action<VisualElement, Color> onValueChanged)
		{
			return experimental.animation.Start((VisualElement e) => from, to, durationMs, onValueChanged);
		}

		ValueAnimation<Vector3> ITransitionAnimations.Start(Vector3 from, Vector3 to, int durationMs, Action<VisualElement, Vector3> onValueChanged)
		{
			return experimental.animation.Start((VisualElement e) => from, to, durationMs, onValueChanged);
		}

		ValueAnimation<Vector2> ITransitionAnimations.Start(Vector2 from, Vector2 to, int durationMs, Action<VisualElement, Vector2> onValueChanged)
		{
			return experimental.animation.Start((VisualElement e) => from, to, durationMs, onValueChanged);
		}

		ValueAnimation<Quaternion> ITransitionAnimations.Start(Quaternion from, Quaternion to, int durationMs, Action<VisualElement, Quaternion> onValueChanged)
		{
			return experimental.animation.Start((VisualElement e) => from, to, durationMs, onValueChanged);
		}

		ValueAnimation<StyleValues> ITransitionAnimations.Start(StyleValues from, StyleValues to, int durationMs)
		{
			if (from.m_StyleValues == null)
			{
				from.Values();
			}
			if (to.m_StyleValues == null)
			{
				to.Values();
			}
			return Start((VisualElement e) => from, to, durationMs);
		}

		ValueAnimation<float> ITransitionAnimations.Start(Func<VisualElement, float> fromValueGetter, float to, int durationMs, Action<VisualElement, float> onValueChanged)
		{
			return StartAnimation(ValueAnimation<float>.Create(this, Lerp.Interpolate), fromValueGetter, to, durationMs, onValueChanged);
		}

		ValueAnimation<Rect> ITransitionAnimations.Start(Func<VisualElement, Rect> fromValueGetter, Rect to, int durationMs, Action<VisualElement, Rect> onValueChanged)
		{
			return StartAnimation(ValueAnimation<Rect>.Create(this, Lerp.Interpolate), fromValueGetter, to, durationMs, onValueChanged);
		}

		ValueAnimation<Color> ITransitionAnimations.Start(Func<VisualElement, Color> fromValueGetter, Color to, int durationMs, Action<VisualElement, Color> onValueChanged)
		{
			return StartAnimation(ValueAnimation<Color>.Create(this, Lerp.Interpolate), fromValueGetter, to, durationMs, onValueChanged);
		}

		ValueAnimation<Vector3> ITransitionAnimations.Start(Func<VisualElement, Vector3> fromValueGetter, Vector3 to, int durationMs, Action<VisualElement, Vector3> onValueChanged)
		{
			return StartAnimation(ValueAnimation<Vector3>.Create(this, Lerp.Interpolate), fromValueGetter, to, durationMs, onValueChanged);
		}

		ValueAnimation<Vector2> ITransitionAnimations.Start(Func<VisualElement, Vector2> fromValueGetter, Vector2 to, int durationMs, Action<VisualElement, Vector2> onValueChanged)
		{
			return StartAnimation(ValueAnimation<Vector2>.Create(this, Lerp.Interpolate), fromValueGetter, to, durationMs, onValueChanged);
		}

		ValueAnimation<Quaternion> ITransitionAnimations.Start(Func<VisualElement, Quaternion> fromValueGetter, Quaternion to, int durationMs, Action<VisualElement, Quaternion> onValueChanged)
		{
			return StartAnimation(ValueAnimation<Quaternion>.Create(this, Lerp.Interpolate), fromValueGetter, to, durationMs, onValueChanged);
		}

		private static ValueAnimation<T> StartAnimation<T>(ValueAnimation<T> anim, Func<VisualElement, T> fromValueGetter, T to, int durationMs, Action<VisualElement, T> onValueChanged)
		{
			anim.initialValue = fromValueGetter;
			anim.to = to;
			anim.durationMs = durationMs;
			anim.valueUpdated = onValueChanged;
			anim.Start();
			return anim;
		}

		private static void AssignStyleValues(VisualElement ve, StyleValues src)
		{
			IStyle style = ve.style;
			if (src.m_StyleValues == null)
			{
				return;
			}
			foreach (StyleValue value in src.m_StyleValues.m_Values)
			{
				switch (value.id)
				{
				case StylePropertyId.MarginLeft:
					style.marginLeft = value.number;
					break;
				case StylePropertyId.MarginTop:
					style.marginTop = value.number;
					break;
				case StylePropertyId.MarginRight:
					style.marginRight = value.number;
					break;
				case StylePropertyId.MarginBottom:
					style.marginBottom = value.number;
					break;
				case StylePropertyId.PaddingLeft:
					style.paddingLeft = value.number;
					break;
				case StylePropertyId.PaddingTop:
					style.paddingTop = value.number;
					break;
				case StylePropertyId.PaddingRight:
					style.paddingRight = value.number;
					break;
				case StylePropertyId.PaddingBottom:
					style.paddingBottom = value.number;
					break;
				case StylePropertyId.Left:
					style.left = value.number;
					break;
				case StylePropertyId.Top:
					style.top = value.number;
					break;
				case StylePropertyId.Right:
					style.right = value.number;
					break;
				case StylePropertyId.Bottom:
					style.bottom = value.number;
					break;
				case StylePropertyId.Width:
					style.width = value.number;
					break;
				case StylePropertyId.Height:
					style.height = value.number;
					break;
				case StylePropertyId.FlexGrow:
					style.flexGrow = value.number;
					break;
				case StylePropertyId.FlexShrink:
					style.flexShrink = value.number;
					break;
				case StylePropertyId.BorderLeftWidth:
					style.borderLeftWidth = value.number;
					break;
				case StylePropertyId.BorderTopWidth:
					style.borderTopWidth = value.number;
					break;
				case StylePropertyId.BorderRightWidth:
					style.borderRightWidth = value.number;
					break;
				case StylePropertyId.BorderBottomWidth:
					style.borderBottomWidth = value.number;
					break;
				case StylePropertyId.BorderTopLeftRadius:
					style.borderTopLeftRadius = value.number;
					break;
				case StylePropertyId.BorderTopRightRadius:
					style.borderTopRightRadius = value.number;
					break;
				case StylePropertyId.BorderBottomRightRadius:
					style.borderBottomRightRadius = value.number;
					break;
				case StylePropertyId.BorderBottomLeftRadius:
					style.borderBottomLeftRadius = value.number;
					break;
				case StylePropertyId.FontSize:
					style.fontSize = value.number;
					break;
				case StylePropertyId.Color:
					style.color = value.color;
					break;
				case StylePropertyId.BackgroundColor:
					style.backgroundColor = value.color;
					break;
				case StylePropertyId.BorderColor:
					style.borderLeftColor = value.color;
					style.borderTopColor = value.color;
					style.borderRightColor = value.color;
					style.borderBottomColor = value.color;
					break;
				case StylePropertyId.UnityBackgroundImageTintColor:
					style.unityBackgroundImageTintColor = value.color;
					break;
				case StylePropertyId.Opacity:
					style.opacity = value.number;
					break;
				}
			}
		}

		private StyleValues ReadCurrentValues(VisualElement ve, StyleValues targetValuesToRead)
		{
			StyleValues result = default(StyleValues);
			IResolvedStyle resolvedStyle = ve.resolvedStyle;
			if (targetValuesToRead.m_StyleValues != null)
			{
				using List<StyleValue>.Enumerator enumerator = targetValuesToRead.m_StyleValues.m_Values.GetEnumerator();
				while (enumerator.MoveNext())
				{
					switch (enumerator.Current.id)
					{
					case StylePropertyId.MarginLeft:
						result.marginLeft = resolvedStyle.marginLeft;
						break;
					case StylePropertyId.MarginTop:
						result.marginTop = resolvedStyle.marginTop;
						break;
					case StylePropertyId.MarginRight:
						result.marginRight = resolvedStyle.marginRight;
						break;
					case StylePropertyId.MarginBottom:
						result.marginBottom = resolvedStyle.marginBottom;
						break;
					case StylePropertyId.PaddingLeft:
						result.paddingLeft = resolvedStyle.paddingLeft;
						break;
					case StylePropertyId.PaddingTop:
						result.paddingTop = resolvedStyle.paddingTop;
						break;
					case StylePropertyId.PaddingRight:
						result.paddingRight = resolvedStyle.paddingRight;
						break;
					case StylePropertyId.PaddingBottom:
						result.paddingBottom = resolvedStyle.paddingBottom;
						break;
					case StylePropertyId.Left:
						result.left = resolvedStyle.left;
						break;
					case StylePropertyId.Top:
						result.top = resolvedStyle.top;
						break;
					case StylePropertyId.Right:
						result.right = resolvedStyle.right;
						break;
					case StylePropertyId.Bottom:
						result.bottom = resolvedStyle.bottom;
						break;
					case StylePropertyId.Width:
						result.width = resolvedStyle.width;
						break;
					case StylePropertyId.Height:
						result.height = resolvedStyle.height;
						break;
					case StylePropertyId.FlexGrow:
						result.flexGrow = resolvedStyle.flexGrow;
						break;
					case StylePropertyId.FlexShrink:
						result.flexShrink = resolvedStyle.flexShrink;
						break;
					case StylePropertyId.BorderLeftWidth:
						result.borderLeftWidth = resolvedStyle.borderLeftWidth;
						break;
					case StylePropertyId.BorderTopWidth:
						result.borderTopWidth = resolvedStyle.borderTopWidth;
						break;
					case StylePropertyId.BorderRightWidth:
						result.borderRightWidth = resolvedStyle.borderRightWidth;
						break;
					case StylePropertyId.BorderBottomWidth:
						result.borderBottomWidth = resolvedStyle.borderBottomWidth;
						break;
					case StylePropertyId.BorderTopLeftRadius:
						result.borderTopLeftRadius = resolvedStyle.borderTopLeftRadius;
						break;
					case StylePropertyId.BorderTopRightRadius:
						result.borderTopRightRadius = resolvedStyle.borderTopRightRadius;
						break;
					case StylePropertyId.BorderBottomRightRadius:
						result.borderBottomRightRadius = resolvedStyle.borderBottomRightRadius;
						break;
					case StylePropertyId.BorderBottomLeftRadius:
						result.borderBottomLeftRadius = resolvedStyle.borderBottomLeftRadius;
						break;
					case StylePropertyId.Color:
						result.color = resolvedStyle.color;
						break;
					case StylePropertyId.BackgroundColor:
						result.backgroundColor = resolvedStyle.backgroundColor;
						break;
					case StylePropertyId.BorderColor:
						result.borderColor = resolvedStyle.borderLeftColor;
						break;
					case StylePropertyId.UnityBackgroundImageTintColor:
						result.unityBackgroundImageTintColor = resolvedStyle.unityBackgroundImageTintColor;
						break;
					case StylePropertyId.Opacity:
						result.opacity = resolvedStyle.opacity;
						break;
					}
				}
			}
			return result;
		}

		ValueAnimation<StyleValues> ITransitionAnimations.Start(StyleValues to, int durationMs)
		{
			if (to.m_StyleValues == null)
			{
				to.Values();
			}
			return Start((VisualElement e) => ReadCurrentValues(e, to), to, durationMs);
		}

		private ValueAnimation<StyleValues> Start(Func<VisualElement, StyleValues> fromValueGetter, StyleValues to, int durationMs)
		{
			return StartAnimation(ValueAnimation<StyleValues>.Create(this, Lerp.Interpolate), fromValueGetter, to, durationMs, AssignStyleValues);
		}

		ValueAnimation<Rect> ITransitionAnimations.Layout(Rect to, int durationMs)
		{
			return experimental.animation.Start((VisualElement e) => new Rect(e.resolvedStyle.left, e.resolvedStyle.top, e.resolvedStyle.width, e.resolvedStyle.height), to, durationMs, delegate(VisualElement e, Rect c)
			{
				e.style.left = c.x;
				e.style.top = c.y;
				e.style.width = c.width;
				e.style.height = c.height;
			});
		}

		ValueAnimation<Vector2> ITransitionAnimations.TopLeft(Vector2 to, int durationMs)
		{
			return experimental.animation.Start((VisualElement e) => new Vector2(e.resolvedStyle.left, e.resolvedStyle.top), to, durationMs, delegate(VisualElement e, Vector2 c)
			{
				e.style.left = c.x;
				e.style.top = c.y;
			});
		}

		ValueAnimation<Vector2> ITransitionAnimations.Size(Vector2 to, int durationMs)
		{
			return experimental.animation.Start((VisualElement e) => e.layout.size, to, durationMs, delegate(VisualElement e, Vector2 c)
			{
				e.style.width = c.x;
				e.style.height = c.y;
			});
		}

		ValueAnimation<float> ITransitionAnimations.Scale(float to, int durationMs)
		{
			return experimental.animation.Start((VisualElement e) => e.transform.scale.x, to, durationMs, delegate(VisualElement e, float c)
			{
				e.transform.scale = new Vector3(c, c, c);
			});
		}

		ValueAnimation<Vector3> ITransitionAnimations.Position(Vector3 to, int durationMs)
		{
			return experimental.animation.Start((VisualElement e) => e.transform.position, to, durationMs, delegate(VisualElement e, Vector3 c)
			{
				e.transform.position = c;
			});
		}

		ValueAnimation<Quaternion> ITransitionAnimations.Rotation(Quaternion to, int durationMs)
		{
			return experimental.animation.Start((VisualElement e) => e.transform.rotation, to, durationMs, delegate(VisualElement e, Quaternion c)
			{
				e.transform.rotation = c;
			});
		}

		private void DirtyNextParentWithEventCallback()
		{
			if (m_CachedNextParentWithEventCallback != null && m_NextParentCachedVersion == m_CachedNextParentWithEventCallback.m_NextParentRequiredVersion)
			{
				m_CachedNextParentWithEventCallback.m_NextParentRequiredVersion = ++s_NextParentVersion;
			}
		}

		private void SetAsNextParentWithEventCallback()
		{
			if (m_NextParentRequiredVersion == 0)
			{
				m_NextParentRequiredVersion = ++s_NextParentVersion;
				if (m_CachedNextParentWithEventCallback != null && m_NextParentCachedVersion == m_CachedNextParentWithEventCallback.m_NextParentRequiredVersion)
				{
					m_CachedNextParentWithEventCallback.m_NextParentRequiredVersion = ++s_NextParentVersion;
				}
			}
		}

		internal bool GetCachedNextParentWithEventCallback(out VisualElement nextParent)
		{
			nextParent = m_CachedNextParentWithEventCallback;
			return nextParent != null && nextParent.m_NextParentRequiredVersion == m_NextParentCachedVersion;
		}

		private void PropagateCachedNextParentWithEventCallback(VisualElement nextParent, VisualElement stopParent)
		{
			for (VisualElement visualElement = this; visualElement != stopParent; visualElement = visualElement.hierarchy.parent)
			{
				visualElement.m_CachedNextParentWithEventCallback = nextParent;
				visualElement.m_NextParentCachedVersion = nextParent.m_NextParentRequiredVersion;
			}
		}

		private void UpdateCallbackParentCategories()
		{
			m_CachedEventCallbackParentCategories = m_EventCallbackCategories;
			if (isCompositeRoot)
			{
				m_CachedEventCallbackParentCategories |= m_DefaultActionEventCategories;
			}
			VisualElement visualElement = nextParentWithEventCallback;
			if (visualElement == null)
			{
				return;
			}
			m_CachedEventCallbackParentCategories |= visualElement.eventCallbackParentCategories;
			if (hierarchy.parent != null)
			{
				for (VisualElement visualElement2 = hierarchy.parent; visualElement2 != visualElement; visualElement2 = visualElement2.hierarchy.parent)
				{
					visualElement2.m_CachedEventCallbackParentCategories = m_CachedEventCallbackParentCategories;
					visualElement2.isEventCallbackParentCategoriesDirty = false;
				}
			}
		}

		internal bool HasEventCallbacks(EventCategory eventCategory)
		{
			return (eventCallbackCategories & (1 << (int)eventCategory)) != 0;
		}

		internal bool HasParentEventCallbacks(EventCategory eventCategory)
		{
			return (eventCallbackParentCategories & (1 << (int)eventCategory)) != 0;
		}

		internal bool HasParentEventCallbacksOrDefaultActions(EventCategory eventCategory)
		{
			return ((m_DefaultActionEventCategories | m_DefaultActionAtTargetEventCategories | eventCallbackParentCategories) & (1 << (int)eventCategory)) != 0;
		}

		internal bool HasEventCallbacksOrDefaultActions(EventCategory eventCategory)
		{
			return ((m_DefaultActionEventCategories | m_DefaultActionAtTargetEventCategories | eventCallbackCategories) & (1 << (int)eventCategory)) != 0;
		}

		internal bool HasParentEventCallbacksOrDefaultActionAtTarget(EventCategory eventCategory)
		{
			return ((m_DefaultActionAtTargetEventCategories | eventCallbackParentCategories) & (1 << (int)eventCategory)) != 0;
		}

		internal bool HasEventCallbacksOrDefaultActionAtTarget(EventCategory eventCategory)
		{
			return ((m_DefaultActionAtTargetEventCategories | eventCallbackCategories) & (1 << (int)eventCategory)) != 0;
		}

		internal bool HasDefaultAction(EventCategory eventCategory)
		{
			return (m_DefaultActionEventCategories & (1 << (int)eventCategory)) != 0;
		}

		internal bool ShouldClip()
		{
			return computedStyle.overflow != OverflowInternal.Visible && !disableClipping;
		}

		public void Add(VisualElement child)
		{
			if (child != null)
			{
				VisualElement visualElement = contentContainer;
				if (visualElement == null)
				{
					throw new InvalidOperationException("You can't add directly to this VisualElement. Use hierarchy.Add() if you know what you're doing.");
				}
				if (visualElement == this)
				{
					hierarchy.Add(child);
				}
				else
				{
					visualElement?.Add(child);
				}
				child.m_LogicalParent = this;
			}
		}

		public void Insert(int index, VisualElement element)
		{
			if (element != null)
			{
				if (contentContainer == this)
				{
					hierarchy.Insert(index, element);
				}
				else
				{
					contentContainer?.Insert(index, element);
				}
				element.m_LogicalParent = this;
			}
		}

		public void Remove(VisualElement element)
		{
			if (contentContainer == this)
			{
				hierarchy.Remove(element);
			}
			else
			{
				contentContainer?.Remove(element);
			}
		}

		public void RemoveAt(int index)
		{
			if (contentContainer == this)
			{
				hierarchy.RemoveAt(index);
			}
			else
			{
				contentContainer?.RemoveAt(index);
			}
		}

		public void Clear()
		{
			if (contentContainer == this)
			{
				hierarchy.Clear();
			}
			else
			{
				contentContainer?.Clear();
			}
		}

		public VisualElement ElementAt(int index)
		{
			return this[index];
		}

		public int IndexOf(VisualElement element)
		{
			if (contentContainer == this)
			{
				return hierarchy.IndexOf(element);
			}
			return contentContainer?.IndexOf(element) ?? (-1);
		}

		internal VisualElement ElementAtTreePath(List<int> childIndexes)
		{
			VisualElement visualElement = this;
			foreach (int childIndex in childIndexes)
			{
				if (childIndex >= 0 && childIndex < visualElement.hierarchy.childCount)
				{
					visualElement = visualElement.hierarchy[childIndex];
					continue;
				}
				return null;
			}
			return visualElement;
		}

		internal bool FindElementInTree(VisualElement element, List<int> outChildIndexes)
		{
			VisualElement visualElement = element;
			for (VisualElement visualElement2 = visualElement.hierarchy.parent; visualElement2 != null; visualElement2 = visualElement2.hierarchy.parent)
			{
				outChildIndexes.Insert(0, visualElement2.hierarchy.IndexOf(visualElement));
				if (visualElement2 == this)
				{
					return true;
				}
				visualElement = visualElement2;
			}
			outChildIndexes.Clear();
			return false;
		}

		public IEnumerable<VisualElement> Children()
		{
			if (contentContainer == this)
			{
				return hierarchy.Children();
			}
			return contentContainer?.Children() ?? s_EmptyList;
		}

		public void Sort(Comparison<VisualElement> comp)
		{
			if (contentContainer == this)
			{
				hierarchy.Sort(comp);
			}
			else
			{
				contentContainer?.Sort(comp);
			}
		}

		public void BringToFront()
		{
			if (hierarchy.parent != null)
			{
				hierarchy.parent.hierarchy.BringToFront(this);
			}
		}

		public void SendToBack()
		{
			if (hierarchy.parent != null)
			{
				hierarchy.parent.hierarchy.SendToBack(this);
			}
		}

		public void PlaceBehind(VisualElement sibling)
		{
			if (sibling == null)
			{
				throw new ArgumentNullException("sibling");
			}
			if (hierarchy.parent == null || sibling.hierarchy.parent != hierarchy.parent)
			{
				throw new ArgumentException("VisualElements are not siblings");
			}
			hierarchy.parent.hierarchy.PlaceBehind(this, sibling);
		}

		public void PlaceInFront(VisualElement sibling)
		{
			if (sibling == null)
			{
				throw new ArgumentNullException("sibling");
			}
			if (hierarchy.parent == null || sibling.hierarchy.parent != hierarchy.parent)
			{
				throw new ArgumentException("VisualElements are not siblings");
			}
			hierarchy.parent.hierarchy.PlaceInFront(this, sibling);
		}

		public void RemoveFromHierarchy()
		{
			if (hierarchy.parent != null)
			{
				hierarchy.parent.hierarchy.Remove(this);
			}
		}

		public T GetFirstOfType<T>() where T : class
		{
			if (this is T result)
			{
				return result;
			}
			return GetFirstAncestorOfType<T>();
		}

		public T GetFirstAncestorOfType<T>() where T : class
		{
			for (VisualElement visualElement = hierarchy.parent; visualElement != null; visualElement = visualElement.hierarchy.parent)
			{
				if (visualElement is T result)
				{
					return result;
				}
			}
			return null;
		}

		internal VisualElement GetFirstAncestorWhere(Predicate<VisualElement> predicate)
		{
			for (VisualElement visualElement = hierarchy.parent; visualElement != null; visualElement = visualElement.hierarchy.parent)
			{
				if (predicate(visualElement))
				{
					return visualElement;
				}
			}
			return null;
		}

		public bool Contains(VisualElement child)
		{
			while (child != null)
			{
				if (child.hierarchy.parent == this)
				{
					return true;
				}
				child = child.hierarchy.parent;
			}
			return false;
		}

		private void GatherAllChildren(List<VisualElement> elements)
		{
			if (m_Children.Count > 0)
			{
				int i = elements.Count;
				elements.AddRange(m_Children);
				for (; i < elements.Count; i++)
				{
					VisualElement visualElement = elements[i];
					elements.AddRange(visualElement.m_Children);
				}
			}
		}

		public VisualElement FindCommonAncestor(VisualElement other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (panel != other.panel)
			{
				return null;
			}
			VisualElement visualElement = this;
			int num = 0;
			while (visualElement != null)
			{
				num++;
				visualElement = visualElement.hierarchy.parent;
			}
			VisualElement visualElement2 = other;
			int num2 = 0;
			while (visualElement2 != null)
			{
				num2++;
				visualElement2 = visualElement2.hierarchy.parent;
			}
			visualElement = this;
			visualElement2 = other;
			while (num > num2)
			{
				num--;
				visualElement = visualElement.hierarchy.parent;
			}
			while (num2 > num)
			{
				num2--;
				visualElement2 = visualElement2.hierarchy.parent;
			}
			while (visualElement != visualElement2)
			{
				visualElement = visualElement.hierarchy.parent;
				visualElement2 = visualElement2.hierarchy.parent;
			}
			return visualElement;
		}

		internal VisualElement GetRoot()
		{
			if (panel != null)
			{
				return panel.visualTree;
			}
			VisualElement visualElement = this;
			while (visualElement.m_PhysicalParent != null)
			{
				visualElement = visualElement.m_PhysicalParent;
			}
			return visualElement;
		}

		internal VisualElement GetRootVisualContainer()
		{
			VisualElement result = null;
			for (VisualElement visualElement = this; visualElement != null; visualElement = visualElement.hierarchy.parent)
			{
				if (visualElement.isRootVisualContainer)
				{
					result = visualElement;
				}
			}
			return result;
		}

		internal VisualElement GetNextElementDepthFirst()
		{
			if (m_Children.Count > 0)
			{
				return m_Children[0];
			}
			VisualElement physicalParent = m_PhysicalParent;
			VisualElement visualElement = this;
			while (physicalParent != null)
			{
				int i;
				for (i = 0; i < physicalParent.m_Children.Count && physicalParent.m_Children[i] != visualElement; i++)
				{
				}
				if (i < physicalParent.m_Children.Count - 1)
				{
					return physicalParent.m_Children[i + 1];
				}
				visualElement = physicalParent;
				physicalParent = physicalParent.m_PhysicalParent;
			}
			return null;
		}

		internal VisualElement GetPreviousElementDepthFirst()
		{
			if (m_PhysicalParent != null)
			{
				int i;
				for (i = 0; i < m_PhysicalParent.m_Children.Count && m_PhysicalParent.m_Children[i] != this; i++)
				{
				}
				if (i > 0)
				{
					VisualElement visualElement = m_PhysicalParent.m_Children[i - 1];
					while (visualElement.m_Children.Count > 0)
					{
						visualElement = visualElement.m_Children[visualElement.m_Children.Count - 1];
					}
					return visualElement;
				}
				return m_PhysicalParent;
			}
			return null;
		}

		internal VisualElement RetargetElement(VisualElement retargetAgainst)
		{
			if (retargetAgainst == null)
			{
				return this;
			}
			VisualElement visualElement = retargetAgainst.m_PhysicalParent ?? retargetAgainst;
			while (visualElement.m_PhysicalParent != null && !visualElement.isCompositeRoot)
			{
				visualElement = visualElement.m_PhysicalParent;
			}
			VisualElement result = this;
			VisualElement physicalParent = m_PhysicalParent;
			while (physicalParent != null)
			{
				physicalParent = physicalParent.m_PhysicalParent;
				if (physicalParent == visualElement)
				{
					return result;
				}
				if (physicalParent != null && physicalParent.isCompositeRoot)
				{
					result = physicalParent;
				}
			}
			return this;
		}

		internal void GetPivotedMatrixWithLayout(out Matrix4x4 result)
		{
			Vector3 vector = ResolveTransformOrigin();
			result = Matrix4x4.TRS(positionWithLayout + vector, ResolveRotation(), ResolveScale());
			TranslateMatrix34InPlace(ref result, -vector);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float Min(float a, float b, float c, float d)
		{
			return Mathf.Min(Mathf.Min(a, b), Mathf.Min(c, d));
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float Max(float a, float b, float c, float d)
		{
			return Mathf.Max(Mathf.Max(a, b), Mathf.Max(c, d));
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void TransformAlignedRectToParentSpace(ref Rect rect)
		{
			if (hasDefaultRotationAndScale)
			{
				rect.position += (Vector2)positionWithLayout;
				return;
			}
			GetPivotedMatrixWithLayout(out var result);
			rect = CalculateConservativeRect(ref result, rect);
		}

		internal static Rect CalculateConservativeRect(ref Matrix4x4 matrix, Rect rect)
		{
			if (float.IsNaN(rect.height) | float.IsNaN(rect.width) | float.IsNaN(rect.x) | float.IsNaN(rect.y))
			{
				rect = new Rect(MultiplyMatrix44Point2(ref matrix, rect.position), MultiplyVector2(ref matrix, rect.size));
				OrderMinMaxRect(ref rect);
				return rect;
			}
			Vector2 vector = new Vector2(rect.xMin, rect.yMin);
			Vector2 vector2 = new Vector2(rect.xMax, rect.yMax);
			Vector2 vector3 = new Vector2(rect.xMax, rect.yMin);
			Vector2 vector4 = new Vector2(rect.xMin, rect.yMax);
			Vector3 vector5 = matrix.MultiplyPoint3x4(vector);
			Vector3 vector6 = matrix.MultiplyPoint3x4(vector2);
			Vector3 vector7 = matrix.MultiplyPoint3x4(vector3);
			Vector3 vector8 = matrix.MultiplyPoint3x4(vector4);
			Vector2 vector9 = new Vector2(Min(vector5.x, vector6.x, vector7.x, vector8.x), Min(vector5.y, vector6.y, vector7.y, vector8.y));
			Vector2 vector10 = new Vector2(Max(vector5.x, vector6.x, vector7.x, vector8.x), Max(vector5.y, vector6.y, vector7.y, vector8.y));
			return new Rect(vector9.x, vector9.y, vector10.x - vector9.x, vector10.y - vector9.y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TransformAlignedRect(ref Matrix4x4 matrix, ref Rect rect)
		{
			rect = CalculateConservativeRect(ref matrix, rect);
		}

		internal static void OrderMinMaxRect(ref Rect rect)
		{
			if (rect.width < 0f)
			{
				rect.x += rect.width;
				rect.width = 0f - rect.width;
			}
			if (rect.height < 0f)
			{
				rect.y += rect.height;
				rect.height = 0f - rect.height;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 MultiplyMatrix44Point2(ref Matrix4x4 lhs, Vector2 point)
		{
			Vector2 result = default(Vector2);
			result.x = lhs.m00 * point.x + lhs.m01 * point.y + lhs.m03;
			result.y = lhs.m10 * point.x + lhs.m11 * point.y + lhs.m13;
			return result;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 MultiplyVector2(ref Matrix4x4 lhs, Vector2 vector)
		{
			Vector2 result = default(Vector2);
			result.x = lhs.m00 * vector.x + lhs.m01 * vector.y;
			result.y = lhs.m10 * vector.x + lhs.m11 * vector.y;
			return result;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Rect MultiplyMatrix44Rect2(ref Matrix4x4 lhs, Rect r)
		{
			r.position = MultiplyMatrix44Point2(ref lhs, r.position);
			r.size = MultiplyVector2(ref lhs, r.size);
			return r;
		}

		internal static void MultiplyMatrix34(ref Matrix4x4 lhs, ref Matrix4x4 rhs, out Matrix4x4 res)
		{
			res.m00 = lhs.m00 * rhs.m00 + lhs.m01 * rhs.m10 + lhs.m02 * rhs.m20;
			res.m01 = lhs.m00 * rhs.m01 + lhs.m01 * rhs.m11 + lhs.m02 * rhs.m21;
			res.m02 = lhs.m00 * rhs.m02 + lhs.m01 * rhs.m12 + lhs.m02 * rhs.m22;
			res.m03 = lhs.m00 * rhs.m03 + lhs.m01 * rhs.m13 + lhs.m02 * rhs.m23 + lhs.m03;
			res.m10 = lhs.m10 * rhs.m00 + lhs.m11 * rhs.m10 + lhs.m12 * rhs.m20;
			res.m11 = lhs.m10 * rhs.m01 + lhs.m11 * rhs.m11 + lhs.m12 * rhs.m21;
			res.m12 = lhs.m10 * rhs.m02 + lhs.m11 * rhs.m12 + lhs.m12 * rhs.m22;
			res.m13 = lhs.m10 * rhs.m03 + lhs.m11 * rhs.m13 + lhs.m12 * rhs.m23 + lhs.m13;
			res.m20 = lhs.m20 * rhs.m00 + lhs.m21 * rhs.m10 + lhs.m22 * rhs.m20;
			res.m21 = lhs.m20 * rhs.m01 + lhs.m21 * rhs.m11 + lhs.m22 * rhs.m21;
			res.m22 = lhs.m20 * rhs.m02 + lhs.m21 * rhs.m12 + lhs.m22 * rhs.m22;
			res.m23 = lhs.m20 * rhs.m03 + lhs.m21 * rhs.m13 + lhs.m22 * rhs.m23 + lhs.m23;
			res.m30 = 0f;
			res.m31 = 0f;
			res.m32 = 0f;
			res.m33 = 1f;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static void TranslateMatrix34(ref Matrix4x4 lhs, Vector3 rhs, out Matrix4x4 res)
		{
			res = lhs;
			TranslateMatrix34InPlace(ref res, rhs);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static void TranslateMatrix34InPlace(ref Matrix4x4 lhs, Vector3 rhs)
		{
			lhs.m03 += lhs.m00 * rhs.x + lhs.m01 * rhs.y + lhs.m02 * rhs.z;
			lhs.m13 += lhs.m10 * rhs.x + lhs.m11 * rhs.y + lhs.m12 * rhs.z;
			lhs.m23 += lhs.m20 * rhs.x + lhs.m21 * rhs.y + lhs.m22 * rhs.z;
		}

		IVisualElementScheduledItem IVisualElementScheduler.Execute(Action<TimerState> timerUpdateEvent)
		{
			TimerStateScheduledItem timerStateScheduledItem = new TimerStateScheduledItem(this, timerUpdateEvent)
			{
				timerUpdateStopCondition = ScheduledItem.OnceCondition
			};
			timerStateScheduledItem.Resume();
			return timerStateScheduledItem;
		}

		IVisualElementScheduledItem IVisualElementScheduler.Execute(Action updateEvent)
		{
			SimpleScheduledItem simpleScheduledItem = new SimpleScheduledItem(this, updateEvent)
			{
				timerUpdateStopCondition = ScheduledItem.OnceCondition
			};
			simpleScheduledItem.Resume();
			return simpleScheduledItem;
		}

		internal void AddStyleSheetPath(string sheetPath)
		{
			StyleSheet styleSheet = Panel.LoadResource(sheetPath, typeof(StyleSheet), scaledPixelsPerPoint) as StyleSheet;
			if (styleSheet == null)
			{
				if (!s_InternalStyleSheetPath.IsMatch(sheetPath))
				{
					Debug.LogWarning($"Style sheet not found for path \"{sheetPath}\"");
				}
			}
			else
			{
				styleSheets.Add(styleSheet);
			}
		}

		internal bool HasStyleSheetPath(string sheetPath)
		{
			StyleSheet styleSheet = Panel.LoadResource(sheetPath, typeof(StyleSheet), scaledPixelsPerPoint) as StyleSheet;
			if (styleSheet == null)
			{
				Debug.LogWarning($"Style sheet not found for path \"{sheetPath}\"");
				return false;
			}
			return styleSheets.Contains(styleSheet);
		}

		internal void RemoveStyleSheetPath(string sheetPath)
		{
			StyleSheet styleSheet = Panel.LoadResource(sheetPath, typeof(StyleSheet), scaledPixelsPerPoint) as StyleSheet;
			if (styleSheet == null)
			{
				Debug.LogWarning($"Style sheet not found for path \"{sheetPath}\"");
			}
			else
			{
				styleSheets.Remove(styleSheet);
			}
		}

		private StyleFloat ResolveLengthValue(Length length, bool isRow)
		{
			if (length.IsAuto())
			{
				return new StyleFloat(StyleKeyword.Auto);
			}
			if (length.IsNone())
			{
				return new StyleFloat(StyleKeyword.None);
			}
			if (length.unit != LengthUnit.Percent)
			{
				return new StyleFloat(length.value);
			}
			VisualElement visualElement = hierarchy.parent;
			if (visualElement == null)
			{
				return 0f;
			}
			float num = (isRow ? visualElement.resolvedStyle.width : visualElement.resolvedStyle.height);
			return length.value * num / 100f;
		}

		private Vector3 ResolveTranslate()
		{
			Translate translate = computedStyle.translate;
			Length x = translate.x;
			float x2;
			if (x.unit == LengthUnit.Percent)
			{
				float width = resolvedStyle.width;
				x2 = (float.IsNaN(width) ? 0f : (width * x.value / 100f));
			}
			else
			{
				x2 = x.value;
				x2 = (float.IsNaN(x2) ? 0f : x2);
			}
			Length y = translate.y;
			float y2;
			if (y.unit == LengthUnit.Percent)
			{
				float height = resolvedStyle.height;
				y2 = (float.IsNaN(height) ? 0f : (height * y.value / 100f));
			}
			else
			{
				y2 = y.value;
				y2 = (float.IsNaN(y2) ? 0f : y2);
			}
			float z = translate.z;
			z = (float.IsNaN(z) ? 0f : z);
			return new Vector3(x2, y2, z);
		}

		private Vector3 ResolveTransformOrigin()
		{
			TransformOrigin transformOrigin = computedStyle.transformOrigin;
			float num = float.NaN;
			Length x = transformOrigin.x;
			if (x.IsNone())
			{
				float width = resolvedStyle.width;
				num = (float.IsNaN(width) ? 0f : (width / 2f));
			}
			else if (x.unit == LengthUnit.Percent)
			{
				float width2 = resolvedStyle.width;
				num = (float.IsNaN(width2) ? 0f : (width2 * x.value / 100f));
			}
			else
			{
				num = x.value;
			}
			float num2 = float.NaN;
			Length y = transformOrigin.y;
			if (y.IsNone())
			{
				float height = resolvedStyle.height;
				num2 = (float.IsNaN(height) ? 0f : (height / 2f));
			}
			else if (y.unit == LengthUnit.Percent)
			{
				float height2 = resolvedStyle.height;
				num2 = (float.IsNaN(height2) ? 0f : (height2 * y.value / 100f));
			}
			else
			{
				num2 = y.value;
			}
			float z = transformOrigin.z;
			return new Vector3(num, num2, z);
		}

		private Quaternion ResolveRotation()
		{
			Rotate rotate = computedStyle.rotate;
			Vector3 axis = rotate.axis;
			if (float.IsNaN(rotate.angle.value) || float.IsNaN(axis.x) || float.IsNaN(axis.y) || float.IsNaN(axis.z))
			{
				rotate = Rotate.Initial();
			}
			return rotate.ToQuaternion();
		}

		private Vector3 ResolveScale()
		{
			Vector3 value = computedStyle.scale.value;
			return (float.IsNaN(value.x) || float.IsNaN(value.y) || float.IsNaN(value.z)) ? Vector3.one : value;
		}

		internal static TypeData GetOrCreateTypeData(Type t)
		{
			if (!s_TypeData.TryGetValue(t, out var value))
			{
				value = new TypeData(t);
				s_TypeData.Add(t, value);
			}
			return value;
		}
	}
	internal interface IStyleDataGroup<T>
	{
		T Copy();

		void CopyFrom(ref T other);
	}
	internal struct InheritedData : IStyleDataGroup<InheritedData>, IEquatable<InheritedData>
	{
		public Color color;

		public Length fontSize;

		public Length letterSpacing;

		public TextShadow textShadow;

		public Font unityFont;

		public FontDefinition unityFontDefinition;

		public FontStyle unityFontStyleAndWeight;

		public Length unityParagraphSpacing;

		public TextAnchor unityTextAlign;

		public Color unityTextOutlineColor;

		public float unityTextOutlineWidth;

		public Visibility visibility;

		public WhiteSpace whiteSpace;

		public Length wordSpacing;

		public InheritedData Copy()
		{
			return this;
		}

		public void CopyFrom(ref InheritedData other)
		{
			this = other;
		}

		public static bool operator ==(InheritedData lhs, InheritedData rhs)
		{
			return lhs.color == rhs.color && lhs.fontSize == rhs.fontSize && lhs.letterSpacing == rhs.letterSpacing && lhs.textShadow == rhs.textShadow && lhs.unityFont == rhs.unityFont && lhs.unityFontDefinition == rhs.unityFontDefinition && lhs.unityFontStyleAndWeight == rhs.unityFontStyleAndWeight && lhs.unityParagraphSpacing == rhs.unityParagraphSpacing && lhs.unityTextAlign == rhs.unityTextAlign && lhs.unityTextOutlineColor == rhs.unityTextOutlineColor && lhs.unityTextOutlineWidth == rhs.unityTextOutlineWidth && lhs.visibility == rhs.visibility && lhs.whiteSpace == rhs.whiteSpace && lhs.wordSpacing == rhs.wordSpacing;
		}

		public static bool operator !=(InheritedData lhs, InheritedData rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(InheritedData other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			return obj is InheritedData && Equals((InheritedData)obj);
		}

		public override int GetHashCode()
		{
			int hashCode = color.GetHashCode();
			hashCode = (hashCode * 397) ^ fontSize.GetHashCode();
			hashCode = (hashCode * 397) ^ letterSpacing.GetHashCode();
			hashCode = (hashCode * 397) ^ textShadow.GetHashCode();
			hashCode = (hashCode * 397) ^ ((!(unityFont == null)) ? unityFont.GetHashCode() : 0);
			hashCode = (hashCode * 397) ^ unityFontDefinition.GetHashCode();
			hashCode = (hashCode * 397) ^ (int)unityFontStyleAndWeight;
			hashCode = (hashCode * 397) ^ unityParagraphSpacing.GetHashCode();
			hashCode = (hashCode * 397) ^ (int)unityTextAlign;
			hashCode = (hashCode * 397) ^ unityTextOutlineColor.GetHashCode();
			hashCode = (hashCode * 397) ^ unityTextOutlineWidth.GetHashCode();
			hashCode = (hashCode * 397) ^ (int)visibility;
			hashCode = (hashCode * 397) ^ (int)whiteSpace;
			return (hashCode * 397) ^ wordSpacing.GetHashCode();
		}
	}
	internal struct LayoutData : IStyleDataGroup<LayoutData>, IEquatable<LayoutData>
	{
		public Align alignContent;

		public Align alignItems;

		public Align alignSelf;

		public float borderBottomWidth;

		public float borderLeftWidth;

		public float borderRightWidth;

		public float borderTopWidth;

		public Length bottom;

		public DisplayStyle display;

		public Length flexBasis;

		public FlexDirection flexDirection;

		public float flexGrow;

		public float flexShrink;

		public Wrap flexWrap;

		public Length height;

		public Justify justifyContent;

		public Length left;

		public Length marginBottom;

		public Length marginLeft;

		public Length marginRight;

		public Length marginTop;

		public Length maxHeight;

		public Length maxWidth;

		public Length minHeight;

		public Length minWidth;

		public Length paddingBottom;

		public Length paddingLeft;

		public Length paddingRight;

		public Length paddingTop;

		public Position position;

		public Length right;

		public Length top;

		public Length width;

		public LayoutData Copy()
		{
			return this;
		}

		public void CopyFrom(ref LayoutData other)
		{
			this = other;
		}

		public static bool operator ==(LayoutData lhs, LayoutData rhs)
		{
			return lhs.alignContent == rhs.alignContent && lhs.alignItems == rhs.alignItems && lhs.alignSelf == rhs.alignSelf && lhs.borderBottomWidth == rhs.borderBottomWidth && lhs.borderLeftWidth == rhs.borderLeftWidth && lhs.borderRightWidth == rhs.borderRightWidth && lhs.borderTopWidth == rhs.borderTopWidth && lhs.bottom == rhs.bottom && lhs.display == rhs.display && lhs.flexBasis == rhs.flexBasis && lhs.flexDirection == rhs.flexDirection && lhs.flexGrow == rhs.flexGrow && lhs.flexShrink == rhs.flexShrink && lhs.flexWrap == rhs.flexWrap && lhs.height == rhs.height && lhs.justifyContent == rhs.justifyContent && lhs.left == rhs.left && lhs.marginBottom == rhs.marginBottom && lhs.marginLeft == rhs.marginLeft && lhs.marginRight == rhs.marginRight && lhs.marginTop == rhs.marginTop && lhs.maxHeight == rhs.maxHeight && lhs.maxWidth == rhs.maxWidth && lhs.minHeight == rhs.minHeight && lhs.minWidth == rhs.minWidth && lhs.paddingBottom == rhs.paddingBottom && lhs.paddingLeft == rhs.paddingLeft && lhs.paddingRight == rhs.paddingRight && lhs.paddingTop == rhs.paddingTop && lhs.position == rhs.position && lhs.right == rhs.right && lhs.top == rhs.top && lhs.width == rhs.width;
		}

		public static bool operator !=(LayoutData lhs, LayoutData rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(LayoutData other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			return obj is LayoutData && Equals((LayoutData)obj);
		}

		public override int GetHashCode()
		{
			int num = (int)alignContent;
			num = (num * 397) ^ (int)alignItems;
			num = (num * 397) ^ (int)alignSelf;
			num = (num * 397) ^ borderBottomWidth.GetHashCode();
			num = (num * 397) ^ borderLeftWidth.GetHashCode();
			num = (num * 397) ^ borderRightWidth.GetHashCode();
			num = (num * 397) ^ borderTopWidth.GetHashCode();
			num = (num * 397) ^ bottom.GetHashCode();
			num = (num * 397) ^ (int)display;
			num = (num * 397) ^ flexBasis.GetHashCode();
			num = (num * 397) ^ (int)flexDirection;
			num = (num * 397) ^ flexGrow.GetHashCode();
			num = (num * 397) ^ flexShrink.GetHashCode();
			num = (num * 397) ^ (int)flexWrap;
			num = (num * 397) ^ height.GetHashCode();
			num = (num * 397) ^ (int)justifyContent;
			num = (num * 397) ^ left.GetHashCode();
			num = (num * 397) ^ marginBottom.GetHashCode();
			num = (num * 397) ^ marginLeft.GetHashCode();
			num = (num * 397) ^ marginRight.GetHashCode();
			num = (num * 397) ^ marginTop.GetHashCode();
			num = (num * 397) ^ maxHeight.GetHashCode();
			num = (num * 397) ^ maxWidth.GetHashCode();
			num = (num * 397) ^ minHeight.GetHashCode();
			num = (num * 397) ^ minWidth.GetHashCode();
			num = (num * 397) ^ paddingBottom.GetHashCode();
			num = (num * 397) ^ paddingLeft.GetHashCode();
			num = (num * 397) ^ paddingRight.GetHashCode();
			num = (num * 397) ^ paddingTop.GetHashCode();
			num = (num * 397) ^ (int)position;
			num = (num * 397) ^ right.GetHashCode();
			num = (num * 397) ^ top.GetHashCode();
			return (num * 397) ^ width.GetHashCode();
		}
	}
	internal struct RareData : IStyleDataGroup<RareData>, IEquatable<RareData>
	{
		public Cursor cursor;

		public TextOverflow textOverflow;

		public Color unityBackgroundImageTintColor;

		public OverflowClipBox unityOverflowClipBox;

		public int unitySliceBottom;

		public int unitySliceLeft;

		public int unitySliceRight;

		public float unitySliceScale;

		public int unitySliceTop;

		public TextOverflowPosition unityTextOverflowPosition;

		public RareData Copy()
		{
			return this;
		}

		public void CopyFrom(ref RareData other)
		{
			this = other;
		}

		public static bool operator ==(RareData lhs, RareData rhs)
		{
			return lhs.cursor == rhs.cursor && lhs.textOverflow == rhs.textOverflow && lhs.unityBackgroundImageTintColor == rhs.unityBackgroundImageTintColor && lhs.unityOverflowClipBox == rhs.unityOverflowClipBox && lhs.unitySliceBottom == rhs.unitySliceBottom && lhs.unitySliceLeft == rhs.unitySliceLeft && lhs.unitySliceRight == rhs.unitySliceRight && lhs.unitySliceScale == rhs.unitySliceScale && lhs.unitySliceTop == rhs.unitySliceTop && lhs.unityTextOverflowPosition == rhs.unityTextOverflowPosition;
		}

		public static bool operator !=(RareData lhs, RareData rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(RareData other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			return obj is RareData && Equals((RareData)obj);
		}

		public override int GetHashCode()
		{
			int hashCode = cursor.GetHashCode();
			hashCode = (hashCode * 397) ^ (int)textOverflow;
			hashCode = (hashCode * 397) ^ unityBackgroundImageTintColor.GetHashCode();
			hashCode = (hashCode * 397) ^ (int)unityOverflowClipBox;
			hashCode = (hashCode * 397) ^ unitySliceBottom;
			hashCode = (hashCode * 397) ^ unitySliceLeft;
			hashCode = (hashCode * 397) ^ unitySliceRight;
			hashCode = (hashCode * 397) ^ unitySliceScale.GetHashCode();
			hashCode = (hashCode * 397) ^ unitySliceTop;
			return (hashCode * 397) ^ (int)unityTextOverflowPosition;
		}
	}
	internal struct TransformData : IStyleDataGroup<TransformData>, IEquatable<TransformData>
	{
		public Rotate rotate;

		public Scale scale;

		public TransformOrigin transformOrigin;

		public Translate translate;

		public TransformData Copy()
		{
			return this;
		}

		public void CopyFrom(ref TransformData other)
		{
			this = other;
		}

		public static bool operator ==(TransformData lhs, TransformData rhs)
		{
			return lhs.rotate == rhs.rotate && lhs.scale == rhs.scale && lhs.transformOrigin == rhs.transformOrigin && lhs.translate == rhs.translate;
		}

		public static bool operator !=(TransformData lhs, TransformData rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(TransformData other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			return obj is TransformData && Equals((TransformData)obj);
		}

		public override int GetHashCode()
		{
			int hashCode = rotate.GetHashCode();
			hashCode = (hashCode * 397) ^ scale.GetHashCode();
			hashCode = (hashCode * 397) ^ transformOrigin.GetHashCode();
			return (hashCode * 397) ^ translate.GetHashCode();
		}
	}
	internal struct TransitionData : IStyleDataGroup<TransitionData>, IEquatable<TransitionData>
	{
		public List<TimeValue> transitionDelay;

		public List<TimeValue> transitionDuration;

		public List<StylePropertyName> transitionProperty;

		public List<EasingFunction> transitionTimingFunction;

		public TransitionData Copy()
		{
			return new TransitionData
			{
				transitionDelay = new List<TimeValue>(transitionDelay),
				transitionDuration = new List<TimeValue>(transitionDuration),
				transitionProperty = new List<StylePropertyName>(transitionProperty),
				transitionTimingFunction = new List<EasingFunction>(transitionTimingFunction)
			};
		}

		public void CopyFrom(ref TransitionData other)
		{
			if (transitionDelay != other.transitionDelay)
			{
				transitionDelay.Clear();
				transitionDelay.AddRange(other.transitionDelay);
			}
			if (transitionDuration != other.transitionDuration)
			{
				transitionDuration.Clear();
				transitionDuration.AddRange(other.transitionDuration);
			}
			if (transitionProperty != other.transitionProperty)
			{
				transitionProperty.Clear();
				transitionProperty.AddRange(other.transitionProperty);
			}
			if (transitionTimingFunction != other.transitionTimingFunction)
			{
				transitionTimingFunction.Clear();
				transitionTimingFunction.AddRange(other.transitionTimingFunction);
			}
		}

		public static bool operator ==(TransitionData lhs, TransitionData rhs)
		{
			return lhs.transitionDelay == rhs.transitionDelay && lhs.transitionDuration == rhs.transitionDuration && lhs.transitionProperty == rhs.transitionProperty && lhs.transitionTimingFunction == rhs.transitionTimingFunction;
		}

		public static bool operator !=(TransitionData lhs, TransitionData rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(TransitionData other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			return obj is TransitionData && Equals((TransitionData)obj);
		}

		public override int GetHashCode()
		{
			int hashCode = transitionDelay.GetHashCode();
			hashCode = (hashCode * 397) ^ transitionDuration.GetHashCode();
			hashCode = (hashCode * 397) ^ transitionProperty.GetHashCode();
			return (hashCode * 397) ^ transitionTimingFunction.GetHashCode();
		}
	}
	internal struct VisualData : IStyleDataGroup<VisualData>, IEquatable<VisualData>
	{
		public Color backgroundColor;

		public Background backgroundImage;

		public BackgroundPosition backgroundPositionX;

		public BackgroundPosition backgroundPositionY;

		public BackgroundRepeat backgroundRepeat;

		public BackgroundSize backgroundSize;

		public Color borderBottomColor;

		public Length borderBottomLeftRadius;

		public Length borderBottomRightRadius;

		public Color borderLeftColor;

		public Color borderRightColor;

		public Color borderTopColor;

		public Length borderTopLeftRadius;

		public Length borderTopRightRadius;

		public float opacity;

		public OverflowInternal overflow;

		public VisualData Copy()
		{
			return this;
		}

		public void CopyFrom(ref VisualData other)
		{
			this = other;
		}

		public static bool operator ==(VisualData lhs, VisualData rhs)
		{
			return lhs.backgroundColor == rhs.backgroundColor && lhs.backgroundImage == rhs.backgroundImage && lhs.backgroundPositionX == rhs.backgroundPositionX && lhs.backgroundPositionY == rhs.backgroundPositionY && lhs.backgroundRepeat == rhs.backgroundRepeat && lhs.backgroundSize == rhs.backgroundSize && lhs.borderBottomColor == rhs.borderBottomColor && lhs.borderBottomLeftRadius == rhs.borderBottomLeftRadius && lhs.borderBottomRightRadius == rhs.borderBottomRightRadius && lhs.borderLeftColor == rhs.borderLeftColor && lhs.borderRightColor == rhs.borderRightColor && lhs.borderTopColor == rhs.borderTopColor && lhs.borderTopLeftRadius == rhs.borderTopLeftRadius && lhs.borderTopRightRadius == rhs.borderTopRightRadius && lhs.opacity == rhs.opacity && lhs.overflow == rhs.overflow;
		}

		public static bool operator !=(VisualData lhs, VisualData rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(VisualData other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			return obj is VisualData && Equals((VisualData)obj);
		}

		public override int GetHashCode()
		{
			int hashCode = backgroundColor.GetHashCode();
			hashCode = (hashCode * 397) ^ backgroundImage.GetHashCode();
			hashCode = (hashCode * 397) ^ backgroundPositionX.GetHashCode();
			hashCode = (hashCode * 397) ^ backgroundPositionY.GetHashCode();
			hashCode = (hashCode * 397) ^ backgroundRepeat.GetHashCode();
			hashCode = (hashCode * 397) ^ backgroundSize.GetHashCode();
			hashCode = (hashCode * 397) ^ borderBottomColor.GetHashCode();
			hashCode = (hashCode * 397) ^ borderBottomLeftRadius.GetHashCode();
			hashCode = (hashCode * 397) ^ borderBottomRightRadius.GetHashCode();
			hashCode = (hashCode * 397) ^ borderLeftColor.GetHashCode();
			hashCode = (hashCode * 397) ^ borderRightColor.GetHashCode();
			hashCode = (hashCode * 397) ^ borderTopColor.GetHashCode();
			hashCode = (hashCode * 397) ^ borderTopLeftRadius.GetHashCode();
			hashCode = (hashCode * 397) ^ borderTopRightRadius.GetHashCode();
			hashCode = (hashCode * 397) ^ opacity.GetHashCode();
			return (hashCode * 397) ^ (int)overflow;
		}
	}
	internal static class StyleDebug
	{
		internal const int UnitySpecificity = -1;

		internal const int UndefinedSpecificity = 0;

		internal const int InheritedSpecificity = 2147483646;

		internal const int InlineSpecificity = int.MaxValue;

		public static object GetComputedStyleValue(in ComputedStyle computedStyle, StylePropertyId id)
		{
			switch (id)
			{
			case StylePropertyId.AlignContent:
				return computedStyle.alignContent;
			case StylePropertyId.AlignItems:
				return computedStyle.alignItems;
			case StylePropertyId.AlignSelf:
				return computedStyle.alignSelf;
			case StylePropertyId.BackgroundColor:
				return computedStyle.backgroundColor;
			case StylePropertyId.BackgroundImage:
				return computedStyle.backgroundImage;
			case StylePropertyId.BackgroundPositionX:
				return computedStyle.backgroundPositionX;
			case StylePropertyId.BackgroundPositionY:
				return computedStyle.backgroundPositionY;
			case StylePropertyId.BackgroundRepeat:
				return computedStyle.backgroundRepeat;
			case StylePropertyId.BackgroundSize:
				return computedStyle.backgroundSize;
			case StylePropertyId.BorderBottomColor:
				return computedStyle.borderBottomColor;
			case StylePropertyId.BorderBottomLeftRadius:
				return computedStyle.borderBottomLeftRadius;
			case StylePropertyId.BorderBottomRightRadius:
				return computedStyle.borderBottomRightRadius;
			case StylePropertyId.BorderBottomWidth:
				return computedStyle.borderBottomWidth;
			case StylePropertyId.BorderLeftColor:
				return computedStyle.borderLeftColor;
			case StylePropertyId.BorderLeftWidth:
				return computedStyle.borderLeftWidth;
			case StylePropertyId.BorderRightColor:
				return computedStyle.borderRightColor;
			case StylePropertyId.BorderRightWidth:
				return computedStyle.borderRightWidth;
			case StylePropertyId.BorderTopColor:
				return computedStyle.borderTopColor;
			case StylePropertyId.BorderTopLeftRadius:
				return computedStyle.borderTopLeftRadius;
			case StylePropertyId.BorderTopRightRadius:
				return computedStyle.borderTopRightRadius;
			case StylePropertyId.BorderTopWidth:
				return computedStyle.borderTopWidth;
			case StylePropertyId.Bottom:
				return computedStyle.bottom;
			case StylePropertyId.Color:
				return computedStyle.color;
			case StylePropertyId.Cursor:
				return computedStyle.cursor;
			case StylePropertyId.Display:
				return computedStyle.display;
			case StylePropertyId.FlexBasis:
				return computedStyle.flexBasis;
			case StylePropertyId.FlexDirection:
				return computedStyle.flexDirection;
			case StylePropertyId.FlexGrow:
				return computedStyle.flexGrow;
			case StylePropertyId.FlexShrink:
				return computedStyle.flexShrink;
			case StylePropertyId.FlexWrap:
				return computedStyle.flexWrap;
			case StylePropertyId.FontSize:
				return computedStyle.fontSize;
			case StylePropertyId.Height:
				return computedStyle.height;
			case StylePropertyId.JustifyContent:
				return computedStyle.justifyContent;
			case StylePropertyId.Left:
				return computedStyle.left;
			case StylePropertyId.LetterSpacing:
				return computedStyle.letterSpacing;
			case StylePropertyId.MarginBottom:
				return computedStyle.marginBottom;
			case StylePropertyId.MarginLeft:
				return computedStyle.marginLeft;
			case StylePropertyId.MarginRight:
				return computedStyle.marginRight;
			case StylePropertyId.MarginTop:
				return computedStyle.marginTop;
			case StylePropertyId.MaxHeight:
				return computedStyle.maxHeight;
			case StylePropertyId.MaxWidth:
				return computedStyle.maxWidth;
			case StylePropertyId.MinHeight:
				return computedStyle.minHeight;
			case StylePropertyId.MinWidth:
				return computedStyle.minWidth;
			case StylePropertyId.Opacity:
				return computedStyle.opacity;
			case StylePropertyId.Overflow:
				return computedStyle.overflow;
			case StylePropertyId.PaddingBottom:
				return computedStyle.paddingBottom;
			case StylePropertyId.PaddingLeft:
				return computedStyle.paddingLeft;
			case StylePropertyId.PaddingRight:
				return computedStyle.paddingRight;
			case StylePropertyId.PaddingTop:
				return computedStyle.paddingTop;
			case StylePropertyId.Position:
				return computedStyle.position;
			case StylePropertyId.Right:
				return computedStyle.right;
			case StylePropertyId.Rotate:
				return computedStyle.rotate;
			case StylePropertyId.Scale:
				return computedStyle.scale;
			case StylePropertyId.TextOverflow:
				return computedStyle.textOverflow;
			case StylePropertyId.TextShadow:
				return computedStyle.textShadow;
			case StylePropertyId.Top:
				return computedStyle.top;
			case StylePropertyId.TransformOrigin:
				return computedStyle.transformOrigin;
			case StylePropertyId.TransitionDelay:
				return computedStyle.transitionDelay;
			case StylePropertyId.TransitionDuration:
				return computedStyle.transitionDuration;
			case StylePropertyId.TransitionProperty:
				return computedStyle.transitionProperty;
			case StylePropertyId.TransitionTimingFunction:
				return computedStyle.transitionTimingFunction;
			case StylePropertyId.Translate:
				return computedStyle.translate;
			case StylePropertyId.UnityBackgroundImageTintColor:
				return computedStyle.unityBackgroundImageTintColor;
			case StylePropertyId.UnityFont:
				return computedStyle.unityFont;
			case StylePropertyId.UnityFontDefinition:
				return computedStyle.unityFontDefinition;
			case StylePropertyId.UnityFontStyleAndWeight:
				return computedStyle.unityFontStyleAndWeight;
			case StylePropertyId.UnityOverflowClipBox:
				return computedStyle.unityOverflowClipBox;
			case StylePropertyId.UnityParagraphSpacing:
				return computedStyle.unityParagraphSpacing;
			case StylePropertyId.UnitySliceBottom:
				return computedStyle.unitySliceBottom;
			case StylePropertyId.UnitySliceLeft:
				return computedStyle.unitySliceLeft;
			case StylePropertyId.UnitySliceRight:
				return computedStyle.unitySliceRight;
			case StylePropertyId.UnitySliceScale:
				return computedStyle.unitySliceScale;
			case StylePropertyId.UnitySliceTop:
				return computedStyle.unitySliceTop;
			case StylePropertyId.UnityTextAlign:
				return computedStyle.unityTextAlign;
			case StylePropertyId.UnityTextOutlineColor:
				return computedStyle.unityTextOutlineColor;
			case StylePropertyId.UnityTextOutlineWidth:
				return computedStyle.unityTextOutlineWidth;
			case StylePropertyId.UnityTextOverflowPosition:
				return computedStyle.unityTextOverflowPosition;
			case StylePropertyId.Visibility:
				return computedStyle.visibility;
			case StylePropertyId.WhiteSpace:
				return computedStyle.whiteSpace;
			case StylePropertyId.Width:
				return computedStyle.width;
			case StylePropertyId.WordSpacing:
				return computedStyle.wordSpacing;
			default:
				Debug.LogAssertion($"Cannot get computed style value for property id {id}");
				return null;
			}
		}

		public static Type GetComputedStyleType(StylePropertyId id)
		{
			switch (id)
			{
			case StylePropertyId.AlignContent:
				return typeof(Align);
			case StylePropertyId.AlignItems:
				return typeof(Align);
			case StylePropertyId.AlignSelf:
				return typeof(Align);
			case StylePropertyId.BackgroundColor:
				return typeof(Color);
			case StylePropertyId.BackgroundImage:
				return typeof(Background);
			case StylePropertyId.BackgroundPositionX:
				return typeof(BackgroundPosition);
			case StylePropertyId.BackgroundPositionY:
				return typeof(BackgroundPosition);
			case StylePropertyId.BackgroundRepeat:
				return typeof(BackgroundRepeat);
			case StylePropertyId.BackgroundSize:
				return typeof(BackgroundSize);
			case StylePropertyId.BorderBottomColor:
				return typeof(Color);
			case StylePropertyId.BorderBottomLeftRadius:
				return typeof(Length);
			case StylePropertyId.BorderBottomRightRadius:
				return typeof(Length);
			case StylePropertyId.BorderBottomWidth:
				return typeof(float);
			case StylePropertyId.BorderLeftColor:
				return typeof(Color);
			case StylePropertyId.BorderLeftWidth:
				return typeof(float);
			case StylePropertyId.BorderRightColor:
				return typeof(Color);
			case StylePropertyId.BorderRightWidth:
				return typeof(float);
			case StylePropertyId.BorderTopColor:
				return typeof(Color);
			case StylePropertyId.BorderTopLeftRadius:
				return typeof(Length);
			case StylePropertyId.BorderTopRightRadius:
				return typeof(Length);
			case StylePropertyId.BorderTopWidth:
				return typeof(float);
			case StylePropertyId.Bottom:
				return typeof(Length);
			case StylePropertyId.Color:
				return typeof(Color);
			case StylePropertyId.Cursor:
				return typeof(Cursor);
			case StylePropertyId.Display:
				return typeof(DisplayStyle);
			case StylePropertyId.FlexBasis:
				return typeof(Length);
			case StylePropertyId.FlexDirection:
				return typeof(FlexDirection);
			case StylePropertyId.FlexGrow:
				return typeof(float);
			case StylePropertyId.FlexShrink:
				return typeof(float);
			case StylePropertyId.FlexWrap:
				return typeof(Wrap);
			case StylePropertyId.FontSize:
				return typeof(Length);
			case StylePropertyId.Height:
				return typeof(Length);
			case StylePropertyId.JustifyContent:
				return typeof(Justify);
			case StylePropertyId.Left:
				return typeof(Length);
			case StylePropertyId.LetterSpacing:
				return typeof(Length);
			case StylePropertyId.MarginBottom:
				return typeof(Length);
			case StylePropertyId.MarginLeft:
				return typeof(Length);
			case StylePropertyId.MarginRight:
				return typeof(Length);
			case StylePropertyId.MarginTop:
				return typeof(Length);
			case StylePropertyId.MaxHeight:
				return typeof(Length);
			case StylePropertyId.MaxWidth:
				return typeof(Length);
			case StylePropertyId.MinHeight:
				return typeof(Length);
			case StylePropertyId.MinWidth:
				return typeof(Length);
			case StylePropertyId.Opacity:
				return typeof(float);
			case StylePropertyId.Overflow:
				return typeof(OverflowInternal);
			case StylePropertyId.PaddingBottom:
				return typeof(Length);
			case StylePropertyId.PaddingLeft:
				return typeof(Length);
			case StylePropertyId.PaddingRight:
				return typeof(Length);
			case StylePropertyId.PaddingTop:
				return typeof(Length);
			case StylePropertyId.Position:
				return typeof(Position);
			case StylePropertyId.Right:
				return typeof(Length);
			case StylePropertyId.Rotate:
				return typeof(Rotate);
			case StylePropertyId.Scale:
				return typeof(Scale);
			case StylePropertyId.TextOverflow:
				return typeof(TextOverflow);
			case StylePropertyId.TextShadow:
				return typeof(TextShadow);
			case StylePropertyId.Top:
				return typeof(Length);
			case StylePropertyId.TransformOrigin:
				return typeof(TransformOrigin);
			case StylePropertyId.TransitionDelay:
				return typeof(List<TimeValue>);
			case StylePropertyId.TransitionDuration:
				return typeof(List<TimeValue>);
			case StylePropertyId.TransitionProperty:
				return typeof(List<StylePropertyName>);
			case StylePropertyId.TransitionTimingFunction:
				return typeof(List<EasingFunction>);
			case StylePropertyId.Translate:
				return typeof(Translate);
			case StylePropertyId.UnityBackgroundImageTintColor:
				return typeof(Color);
			case StylePropertyId.UnityFont:
				return typeof(Font);
			case StylePropertyId.UnityFontDefinition:
				return typeof(FontDefinition);
			case StylePropertyId.UnityFontStyleAndWeight:
				return typeof(FontStyle);
			case StylePropertyId.UnityOverflowClipBox:
				return typeof(OverflowClipBox);
			case StylePropertyId.UnityParagraphSpacing:
				return typeof(Length);
			case StylePropertyId.UnitySliceBottom:
				return typeof(int);
			case StylePropertyId.UnitySliceLeft:
				return typeof(int);
			case StylePropertyId.UnitySliceRight:
				return typeof(int);
			case StylePropertyId.UnitySliceScale:
				return typeof(float);
			case StylePropertyId.UnitySliceTop:
				return typeof(int);
			case StylePropertyId.UnityTextAlign:
				return typeof(TextAnchor);
			case StylePropertyId.UnityTextOutlineColor:
				return typeof(Color);
			case StylePropertyId.UnityTextOutlineWidth:
				return typeof(float);
			case StylePropertyId.UnityTextOverflowPosition:
				return typeof(TextOverflowPosition);
			case StylePropertyId.Visibility:
				return typeof(Visibility);
			case StylePropertyId.WhiteSpace:
				return typeof(WhiteSpace);
			case StylePropertyId.Width:
				return typeof(Length);
			case StylePropertyId.WordSpacing:
				return typeof(Length);
			default:
				Debug.LogAssertion($"Cannot get computed style type for property id {id}");
				return null;
			}
		}

		public static Type GetShorthandStyleType(StylePropertyId id)
		{
			switch (id)
			{
			case StylePropertyId.BackgroundPosition:
				return typeof(BackgroundPosition);
			case StylePropertyId.BorderColor:
				return typeof(Color);
			case StylePropertyId.BorderRadius:
				return typeof(Length);
			case StylePropertyId.BorderWidth:
				return typeof(float);
			case StylePropertyId.Margin:
				return typeof(Length);
			case StylePropertyId.Padding:
				return typeof(Length);
			default:
				Debug.LogAssertion($"Cannot get shorthand style type for property id {id}");
				return null;
			}
		}

		public static object GetInlineStyleValue(IStyle style, StylePropertyId id)
		{
			switch (id)
			{
			case StylePropertyId.AlignContent:
				return style.alignContent;
			case StylePropertyId.AlignItems:
				return style.alignItems;
			case StylePropertyId.AlignSelf:
				return style.alignSelf;
			case StylePropertyId.BackgroundColor:
				return style.backgroundColor;
			case StylePropertyId.BackgroundImage:
				return style.backgroundImage;
			case StylePropertyId.BackgroundPositionX:
				return style.backgroundPositionX;
			case StylePropertyId.BackgroundPositionY:
				return style.backgroundPositionY;
			case StylePropertyId.BackgroundRepeat:
				return style.backgroundRepeat;
			case StylePropertyId.BackgroundSize:
				return style.backgroundSize;
			case StylePropertyId.BorderBottomColor:
				return style.borderBottomColor;
			case StylePropertyId.BorderBottomLeftRadius:
				return style.borderBottomLeftRadius;
			case StylePropertyId.BorderBottomRightRadius:
				return style.borderBottomRightRadius;
			case StylePropertyId.BorderBottomWidth:
				return style.borderBottomWidth;
			case StylePropertyId.BorderLeftColor:
				return style.borderLeftColor;
			case StylePropertyId.BorderLeftWidth:
				return style.borderLeftWidth;
			case StylePropertyId.BorderRightColor:
				return style.borderRightColor;
			case StylePropertyId.BorderRightWidth:
				return style.borderRightWidth;
			case StylePropertyId.BorderTopColor:
				return style.borderTopColor;
			case StylePropertyId.BorderTopLeftRadius:
				return style.borderTopLeftRadius;
			case StylePropertyId.BorderTopRightRadius:
				return style.borderTopRightRadius;
			case StylePropertyId.BorderTopWidth:
				return style.borderTopWidth;
			case StylePropertyId.Bottom:
				return style.bottom;
			case StylePropertyId.Color:
				return style.color;
			case StylePropertyId.Cursor:
				return style.cursor;
			case StylePropertyId.Display:
				return style.display;
			case StylePropertyId.FlexBasis:
				return style.flexBasis;
			case StylePropertyId.FlexDirection:
				return style.flexDirection;
			case StylePropertyId.FlexGrow:
				return style.flexGrow;
			case StylePropertyId.FlexShrink:
				return style.flexShrink;
			case StylePropertyId.FlexWrap:
				return style.flexWrap;
			case StylePropertyId.FontSize:
				return style.fontSize;
			case StylePropertyId.Height:
				return style.height;
			case StylePropertyId.JustifyContent:
				return style.justifyContent;
			case StylePropertyId.Left:
				return style.left;
			case StylePropertyId.LetterSpacing:
				return style.letterSpacing;
			case StylePropertyId.MarginBottom:
				return style.marginBottom;
			case StylePropertyId.MarginLeft:
				return style.marginLeft;
			case StylePropertyId.MarginRight:
				return style.marginRight;
			case StylePropertyId.MarginTop:
				return style.marginTop;
			case StylePropertyId.MaxHeight:
				return style.maxHeight;
			case StylePropertyId.MaxWidth:
				return style.maxWidth;
			case StylePropertyId.MinHeight:
				return style.minHeight;
			case StylePropertyId.MinWidth:
				return style.minWidth;
			case StylePropertyId.Opacity:
				return style.opacity;
			case StylePropertyId.Overflow:
				return style.overflow;
			case StylePropertyId.PaddingBottom:
				return style.paddingBottom;
			case StylePropertyId.PaddingLeft:
				return style.paddingLeft;
			case StylePropertyId.PaddingRight:
				return style.paddingRight;
			case StylePropertyId.PaddingTop:
				return style.paddingTop;
			case StylePropertyId.Position:
				return style.position;
			case StylePropertyId.Right:
				return style.right;
			case StylePropertyId.Rotate:
				return style.rotate;
			case StylePropertyId.Scale:
				return style.scale;
			case StylePropertyId.TextOverflow:
				return style.textOverflow;
			case StylePropertyId.TextShadow:
				return style.textShadow;
			case StylePropertyId.Top:
				return style.top;
			case StylePropertyId.TransformOrigin:
				return style.transformOrigin;
			case StylePropertyId.TransitionDelay:
				return style.transitionDelay;
			case StylePropertyId.TransitionDuration:
				return style.transitionDuration;
			case StylePropertyId.TransitionProperty:
				return style.transitionProperty;
			case StylePropertyId.TransitionTimingFunction:
				return style.transitionTimingFunction;
			case StylePropertyId.Translate:
				return style.translate;
			case StylePropertyId.UnityBackgroundImageTintColor:
				return style.unityBackgroundImageTintColor;
			case StylePropertyId.UnityFont:
				return style.unityFont;
			case StylePropertyId.UnityFontDefinition:
				return style.unityFontDefinition;
			case StylePropertyId.UnityFontStyleAndWeight:
				return style.unityFontStyleAndWeight;
			case StylePropertyId.UnityOverflowClipBox:
				return style.unityOverflowClipBox;
			case StylePropertyId.UnityParagraphSpacing:
				return style.unityParagraphSpacing;
			case StylePropertyId.UnitySliceBottom:
				return style.unitySliceBottom;
			case StylePropertyId.UnitySliceLeft:
				return style.unitySliceLeft;
			case StylePropertyId.UnitySliceRight:
				return style.unitySliceRight;
			case StylePropertyId.UnitySliceScale:
				return style.unitySliceScale;
			case StylePropertyId.UnitySliceTop:
				return style.unitySliceTop;
			case StylePropertyId.UnityTextAlign:
				return style.unityTextAlign;
			case StylePropertyId.UnityTextOutlineColor:
				return style.unityTextOutlineColor;
			case StylePropertyId.UnityTextOutlineWidth:
				return style.unityTextOutlineWidth;
			case StylePropertyId.UnityTextOverflowPosition:
				return style.unityTextOverflowPosition;
			case StylePropertyId.Visibility:
				return style.visibility;
			case StylePropertyId.WhiteSpace:
				return style.whiteSpace;
			case StylePropertyId.Width:
				return style.width;
			case StylePropertyId.WordSpacing:
				return style.wordSpacing;
			default:
				Debug.LogAssertion($"Cannot get inline style value for property id {id}");
				return null;
			}
		}

		public static void SetInlineStyleValue(IStyle style, StylePropertyId id, object value)
		{
			switch (id)
			{
			case StylePropertyId.AlignContent:
				style.alignContent = (StyleEnum<Align>)value;
				break;
			case StylePropertyId.AlignItems:
				style.alignItems = (StyleEnum<Align>)value;
				break;
			case StylePropertyId.AlignSelf:
				style.alignSelf = (StyleEnum<Align>)value;
				break;
			case StylePropertyId.BackgroundColor:
				style.backgroundColor = (StyleColor)value;
				break;
			case StylePropertyId.BackgroundImage:
				style.backgroundImage = (StyleBackground)value;
				break;
			case StylePropertyId.BackgroundPositionX:
				style.backgroundPositionX = (StyleBackgroundPosition)value;
				break;
			case StylePropertyId.BackgroundPositionY:
				style.backgroundPositionY = (StyleBackgroundPosition)value;
				break;
			case StylePropertyId.BackgroundRepeat:
				style.backgroundRepeat = (StyleBackgroundRepeat)value;
				break;
			case StylePropertyId.BackgroundSize:
				style.backgroundSize = (StyleBackgroundSize)value;
				break;
			case StylePropertyId.BorderBottomColor:
				style.borderBottomColor = (StyleColor)value;
				break;
			case StylePropertyId.BorderBottomLeftRadius:
				style.borderBottomLeftRadius = (StyleLength)value;
				break;
			case StylePropertyId.BorderBottomRightRadius:
				style.borderBottomRightRadius = (StyleLength)value;
				break;
			case StylePropertyId.BorderBottomWidth:
				style.borderBottomWidth = (StyleFloat)value;
				break;
			case StylePropertyId.BorderLeftColor:
				style.borderLeftColor = (StyleColor)value;
				break;
			case StylePropertyId.BorderLeftWidth:
				style.borderLeftWidth = (StyleFloat)value;
				break;
			case StylePropertyId.BorderRightColor:
				style.borderRightColor = (StyleColor)value;
				break;
			case StylePropertyId.BorderRightWidth:
				style.borderRightWidth = (StyleFloat)value;
				break;
			case StylePropertyId.BorderTopColor:
				style.borderTopColor = (StyleColor)value;
				break;
			case StylePropertyId.BorderTopLeftRadius:
				style.borderTopLeftRadius = (StyleLength)value;
				break;
			case StylePropertyId.BorderTopRightRadius:
				style.borderTopRightRadius = (StyleLength)value;
				break;
			case StylePropertyId.BorderTopWidth:
				style.borderTopWidth = (StyleFloat)value;
				break;
			case StylePropertyId.Bottom:
				style.bottom = (StyleLength)value;
				break;
			case StylePropertyId.Color:
				style.color = (StyleColor)value;
				break;
			case StylePropertyId.Cursor:
				style.cursor = (StyleCursor)value;
				break;
			case StylePropertyId.Display:
				style.display = (StyleEnum<DisplayStyle>)value;
				break;
			case StylePropertyId.FlexBasis:
				style.flexBasis = (StyleLength)value;
				break;
			case StylePropertyId.FlexDirection:
				style.flexDirection = (StyleEnum<FlexDirection>)value;
				break;
			case StylePropertyId.FlexGrow:
				style.flexGrow = (StyleFloat)value;
				break;
			case StylePropertyId.FlexShrink:
				style.flexShrink = (StyleFloat)value;
				break;
			case StylePropertyId.FlexWrap:
				style.flexWrap = (StyleEnum<Wrap>)value;
				break;
			case StylePropertyId.FontSize:
				style.fontSize = (StyleLength)value;
				break;
			case StylePropertyId.Height:
				style.height = (StyleLength)value;
				break;
			case StylePropertyId.JustifyContent:
				style.justifyContent = (StyleEnum<Justify>)value;
				break;
			case StylePropertyId.Left:
				style.left = (StyleLength)value;
				break;
			case StylePropertyId.LetterSpacing:
				style.letterSpacing = (StyleLength)value;
				break;
			case StylePropertyId.MarginBottom:
				style.marginBottom = (StyleLength)value;
				break;
			case StylePropertyId.MarginLeft:
				style.marginLeft = (StyleLength)value;
				break;
			case StylePropertyId.MarginRight:
				style.marginRight = (StyleLength)value;
				break;
			case StylePropertyId.MarginTop:
				style.marginTop = (StyleLength)value;
				break;
			case StylePropertyId.MaxHeight:
				style.maxHeight = (StyleLength)value;
				break;
			case StylePropertyId.MaxWidth:
				style.maxWidth = (StyleLength)value;
				break;
			case StylePropertyId.MinHeight:
				style.minHeight = (StyleLength)value;
				break;
			case StylePropertyId.MinWidth:
				style.minWidth = (StyleLength)value;
				break;
			case StylePropertyId.Opacity:
				style.opacity = (StyleFloat)value;
				break;
			case StylePropertyId.Overflow:
				style.overflow = (StyleEnum<Overflow>)value;
				break;
			case StylePropertyId.PaddingBottom:
				style.paddingBottom = (StyleLength)value;
				break;
			case StylePropertyId.PaddingLeft:
				style.paddingLeft = (StyleLength)value;
				break;
			case StylePropertyId.PaddingRight:
				style.paddingRight = (StyleLength)value;
				break;
			case StylePropertyId.PaddingTop:
				style.paddingTop = (StyleLength)value;
				break;
			case StylePropertyId.Position:
				style.position = (StyleEnum<Position>)value;
				break;
			case StylePropertyId.Right:
				style.right = (StyleLength)value;
				break;
			case StylePropertyId.Rotate:
				style.rotate = (StyleRotate)value;
				break;
			case StylePropertyId.Scale:
				style.scale = (StyleScale)value;
				break;
			case StylePropertyId.TextOverflow:
				style.textOverflow = (StyleEnum<TextOverflow>)value;
				break;
			case StylePropertyId.TextShadow:
				style.textShadow = (StyleTextShadow)value;
				break;
			case StylePropertyId.Top:
				style.top = (StyleLength)value;
				break;
			case StylePropertyId.TransformOrigin:
				style.transformOrigin = (StyleTransformOrigin)value;
				break;
			case StylePropertyId.TransitionDelay:
				style.transitionDelay = (StyleList<TimeValue>)value;
				break;
			case StylePropertyId.TransitionDuration:
				style.transitionDuration = (StyleList<TimeValue>)value;
				break;
			case StylePropertyId.TransitionProperty:
				style.transitionProperty = (StyleList<StylePropertyName>)value;
				break;
			case StylePropertyId.TransitionTimingFunction:
				style.transitionTimingFunction = (StyleList<EasingFunction>)value;
				break;
			case StylePropertyId.Translate:
				style.translate = (StyleTranslate)value;
				break;
			case StylePropertyId.UnityBackgroundImageTintColor:
				style.unityBackgroundImageTintColor = (StyleColor)value;
				break;
			case StylePropertyId.UnityFont:
				style.unityFont = (StyleFont)value;
				break;
			case StylePropertyId.UnityFontDefinition:
				style.unityFontDefinition = (StyleFontDefinition)value;
				break;
			case StylePropertyId.UnityFontStyleAndWeight:
				style.unityFontStyleAndWeight = (StyleEnum<FontStyle>)value;
				break;
			case StylePropertyId.UnityOverflowClipBox:
				style.unityOverflowClipBox = (StyleEnum<OverflowClipBox>)value;
				break;
			case StylePropertyId.UnityParagraphSpacing:
				style.unityParagraphSpacing = (StyleLength)value;
				break;
			case StylePropertyId.UnitySliceBottom:
				style.unitySliceBottom = (StyleInt)value;
				break;
			case StylePropertyId.UnitySliceLeft:
				style.unitySliceLeft = (StyleInt)value;
				break;
			case StylePropertyId.UnitySliceRight:
				style.unitySliceRight = (StyleInt)value;
				break;
			case StylePropertyId.UnitySliceScale:
				style.unitySliceScale = (StyleFloat)value;
				break;
			case StylePropertyId.UnitySliceTop:
				style.unitySliceTop = (StyleInt)value;
				break;
			case StylePropertyId.UnityTextAlign:
				style.unityTextAlign = (StyleEnum<TextAnchor>)value;
				break;
			case StylePropertyId.UnityTextOutlineColor:
				style.unityTextOutlineColor = (StyleColor)value;
				break;
			case StylePropertyId.UnityTextOutlineWidth:
				style.unityTextOutlineWidth = (StyleFloat)value;
				break;
			case StylePropertyId.UnityTextOverflowPosition:
				style.unityTextOverflowPosition = (StyleEnum<TextOverflowPosition>)value;
				break;
			case StylePropertyId.Visibility:
				style.visibility = (StyleEnum<Visibility>)value;
				break;
			case StylePropertyId.WhiteSpace:
				style.whiteSpace = (StyleEnum<WhiteSpace>)value;
				break;
			case StylePropertyId.Width:
				style.width = (StyleLength)value;
				break;
			case StylePropertyId.WordSpacing:
				style.wordSpacing = (StyleLength)value;
				break;
			default:
				Debug.LogAssertion($"Cannot set inline style value for property id {id}");
				break;
			}
		}

		public static void SetInlineKeyword(IStyle style, StylePropertyId id, StyleKeyword keyword)
		{
			switch (id)
			{
			case StylePropertyId.AlignContent:
				style.alignContent = keyword;
				break;
			case StylePropertyId.AlignItems:
				style.alignItems = keyword;
				break;
			case StylePropertyId.AlignSelf:
				style.alignSelf = keyword;
				break;
			case StylePropertyId.BackgroundColor:
				style.backgroundColor = keyword;
				break;
			case StylePropertyId.BackgroundImage:
				style.backgroundImage = keyword;
				break;
			case StylePropertyId.BackgroundPositionX:
				style.backgroundPositionX = keyword;
				break;
			case StylePropertyId.BackgroundPositionY:
				style.backgroundPositionY = keyword;
				break;
			case StylePropertyId.BackgroundRepeat:
				style.backgroundRepeat = keyword;
				break;
			case StylePropertyId.BackgroundSize:
				style.backgroundSize = keyword;
				break;
			case StylePropertyId.BorderBottomColor:
				style.borderBottomColor = keyword;
				break;
			case StylePropertyId.BorderBottomLeftRadius:
				style.borderBottomLeftRadius = keyword;
				break;
			case StylePropertyId.BorderBottomRightRadius:
				style.borderBottomRightRadius = keyword;
				break;
			case StylePropertyId.BorderBottomWidth:
				style.borderBottomWidth = keyword;
				break;
			case StylePropertyId.BorderLeftColor:
				style.borderLeftColor = keyword;
				break;
			case StylePropertyId.BorderLeftWidth:
				style.borderLeftWidth = keyword;
				break;
			case StylePropertyId.BorderRightColor:
				style.borderRightColor = keyword;
				break;
			case StylePropertyId.BorderRightWidth:
				style.borderRightWidth = keyword;
				break;
			case StylePropertyId.BorderTopColor:
				style.borderTopColor = keyword;
				break;
			case StylePropertyId.BorderTopLeftRadius:
				style.borderTopLeftRadius = keyword;
				break;
			case StylePropertyId.BorderTopRightRadius:
				style.borderTopRightRadius = keyword;
				break;
			case StylePropertyId.BorderTopWidth:
				style.borderTopWidth = keyword;
				break;
			case StylePropertyId.Bottom:
				style.bottom = keyword;
				break;
			case StylePropertyId.Color:
				style.color = keyword;
				break;
			case StylePropertyId.Cursor:
				style.cursor = keyword;
				break;
			case StylePropertyId.Display:
				style.display = keyword;
				break;
			case StylePropertyId.FlexBasis:
				style.flexBasis = keyword;
				break;
			case StylePropertyId.FlexDirection:
				style.flexDirection = keyword;
				break;
			case StylePropertyId.FlexGrow:
				style.flexGrow = keyword;
				break;
			case StylePropertyId.FlexShrink:
				style.flexShrink = keyword;
				break;
			case StylePropertyId.FlexWrap:
				style.flexWrap = keyword;
				break;
			case StylePropertyId.FontSize:
				style.fontSize = keyword;
				break;
			case StylePropertyId.Height:
				style.height = keyword;
				break;
			case StylePropertyId.JustifyContent:
				style.justifyContent = keyword;
				break;
			case StylePropertyId.Left:
				style.left = keyword;
				break;
			case StylePropertyId.LetterSpacing:
				style.letterSpacing = keyword;
				break;
			case StylePropertyId.MarginBottom:
				style.marginBottom = keyword;
				break;
			case StylePropertyId.MarginLeft:
				style.marginLeft = keyword;
				break;
			case StylePropertyId.MarginRight:
				style.marginRight = keyword;
				break;
			case StylePropertyId.MarginTop:
				style.marginTop = keyword;
				break;
			case StylePropertyId.MaxHeight:
				style.maxHeight = keyword;
				break;
			case StylePropertyId.MaxWidth:
				style.maxWidth = keyword;
				break;
			case StylePropertyId.MinHeight:
				style.minHeight = keyword;
				break;
			case StylePropertyId.MinWidth:
				style.minWidth = keyword;
				break;
			case StylePropertyId.Opacity:
				style.opacity = keyword;
				break;
			case StylePropertyId.Overflow:
				style.overflow = keyword;
				break;
			case StylePropertyId.PaddingBottom:
				style.paddingBottom = keyword;
				break;
			case StylePropertyId.PaddingLeft:
				style.paddingLeft = keyword;
				break;
			case StylePropertyId.PaddingRight:
				style.paddingRight = keyword;
				break;
			case StylePropertyId.PaddingTop:
				style.paddingTop = keyword;
				break;
			case StylePropertyId.Position:
				style.position = keyword;
				break;
			case StylePropertyId.Right:
				style.right = keyword;
				break;
			case StylePropertyId.Rotate:
				style.rotate = keyword;
				break;
			case StylePropertyId.Scale:
				style.scale = keyword;
				break;
			case StylePropertyId.TextOverflow:
				style.textOverflow = keyword;
				break;
			case StylePropertyId.TextShadow:
				style.textShadow = keyword;
				break;
			case StylePropertyId.Top:
				style.top = keyword;
				break;
			case StylePropertyId.TransformOrigin:
				style.transformOrigin = keyword;
				break;
			case StylePropertyId.TransitionDelay:
				style.transitionDelay = keyword;
				break;
			case StylePropertyId.TransitionDuration:
				style.transitionDuration = keyword;
				break;
			case StylePropertyId.TransitionProperty:
				style.transitionProperty = keyword;
				break;
			case StylePropertyId.TransitionTimingFunction:
				style.transitionTimingFunction = keyword;
				break;
			case StylePropertyId.Translate:
				style.translate = keyword;
				break;
			case StylePropertyId.UnityBackgroundImageTintColor:
				style.unityBackgroundImageTintColor = keyword;
				break;
			case StylePropertyId.UnityFont:
				style.unityFont = keyword;
				break;
			case StylePropertyId.UnityFontDefinition:
				style.unityFontDefinition = keyword;
				break;
			case StylePropertyId.UnityFontStyleAndWeight:
				style.unityFontStyleAndWeight = keyword;
				break;
			case StylePropertyId.UnityOverflowClipBox:
				style.unityOverflowClipBox = keyword;
				break;
			case StylePropertyId.UnityParagraphSpacing:
				style.unityParagraphSpacing = keyword;
				break;
			case StylePropertyId.UnitySliceBottom:
				style.unitySliceBottom = keyword;
				break;
			case StylePropertyId.UnitySliceLeft:
				style.unitySliceLeft = keyword;
				break;
			case StylePropertyId.UnitySliceRight:
				style.unitySliceRight = keyword;
				break;
			case StylePropertyId.UnitySliceScale:
				style.unitySliceScale = keyword;
				break;
			case StylePropertyId.UnitySliceTop:
				style.unitySliceTop = keyword;
				break;
			case StylePropertyId.UnityTextAlign:
				style.unityTextAlign = keyword;
				break;
			case StylePropertyId.UnityTextOutlineColor:
				style.unityTextOutlineColor = keyword;
				break;
			case StylePropertyId.UnityTextOutlineWidth:
				style.unityTextOutlineWidth = keyword;
				break;
			case StylePropertyId.UnityTextOverflowPosition:
				style.unityTextOverflowPosition = keyword;
				break;
			case StylePropertyId.Visibility:
				style.visibility = keyword;
				break;
			case StylePropertyId.WhiteSpace:
				style.whiteSpace = keyword;
				break;
			case StylePropertyId.Width:
				style.width = keyword;
				break;
			case StylePropertyId.WordSpacing:
				style.wordSpacing = keyword;
				break;
			default:
				Debug.LogAssertion($"Cannot set inline keyword value for property id {id}");
				break;
			}
		}

		public static List<StyleKeyword> GetValidKeyword(StylePropertyId id)
		{
			switch (id)
			{
			case StylePropertyId.AlignContent:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.AlignItems:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.AlignSelf:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.BackgroundColor:
				return new List<StyleKeyword>();
			case StylePropertyId.BackgroundImage:
				return new List<StyleKeyword> { StyleKeyword.None };
			case StylePropertyId.BackgroundPositionX:
				return new List<StyleKeyword>();
			case StylePropertyId.BackgroundPositionY:
				return new List<StyleKeyword>();
			case StylePropertyId.BackgroundRepeat:
				return new List<StyleKeyword>();
			case StylePropertyId.BackgroundSize:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.BorderBottomColor:
				return new List<StyleKeyword>();
			case StylePropertyId.BorderBottomLeftRadius:
				return new List<StyleKeyword>();
			case StylePropertyId.BorderBottomRightRadius:
				return new List<StyleKeyword>();
			case StylePropertyId.BorderBottomWidth:
				return new List<StyleKeyword>();
			case StylePropertyId.BorderLeftColor:
				return new List<StyleKeyword>();
			case StylePropertyId.BorderLeftWidth:
				return new List<StyleKeyword>();
			case StylePropertyId.BorderRightColor:
				return new List<StyleKeyword>();
			case StylePropertyId.BorderRightWidth:
				return new List<StyleKeyword>();
			case StylePropertyId.BorderTopColor:
				return new List<StyleKeyword>();
			case StylePropertyId.BorderTopLeftRadius:
				return new List<StyleKeyword>();
			case StylePropertyId.BorderTopRightRadius:
				return new List<StyleKeyword>();
			case StylePropertyId.BorderTopWidth:
				return new List<StyleKeyword>();
			case StylePropertyId.Bottom:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.Color:
				return new List<StyleKeyword>();
			case StylePropertyId.Cursor:
				return new List<StyleKeyword>();
			case StylePropertyId.Display:
				return new List<StyleKeyword> { StyleKeyword.None };
			case StylePropertyId.FlexBasis:
				return new List<StyleKeyword>();
			case StylePropertyId.FlexDirection:
				return new List<StyleKeyword>();
			case StylePropertyId.FlexGrow:
				return new List<StyleKeyword>();
			case StylePropertyId.FlexShrink:
				return new List<StyleKeyword>();
			case StylePropertyId.FlexWrap:
				return new List<StyleKeyword>();
			case StylePropertyId.FontSize:
				return new List<StyleKeyword>();
			case StylePropertyId.Height:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.JustifyContent:
				return new List<StyleKeyword>();
			case StylePropertyId.Left:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.LetterSpacing:
				return new List<StyleKeyword>();
			case StylePropertyId.MarginBottom:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.MarginLeft:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.MarginRight:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.MarginTop:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.MaxHeight:
				return new List<StyleKeyword> { StyleKeyword.None };
			case StylePropertyId.MaxWidth:
				return new List<StyleKeyword> { StyleKeyword.None };
			case StylePropertyId.MinHeight:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.MinWidth:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.Opacity:
				return new List<StyleKeyword>();
			case StylePropertyId.Overflow:
				return new List<StyleKeyword>();
			case StylePropertyId.PaddingBottom:
				return new List<StyleKeyword>();
			case StylePropertyId.PaddingLeft:
				return new List<StyleKeyword>();
			case StylePropertyId.PaddingRight:
				return new List<StyleKeyword>();
			case StylePropertyId.PaddingTop:
				return new List<StyleKeyword>();
			case StylePropertyId.Position:
				return new List<StyleKeyword>();
			case StylePropertyId.Right:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.Rotate:
				return new List<StyleKeyword> { StyleKeyword.None };
			case StylePropertyId.Scale:
				return new List<StyleKeyword> { StyleKeyword.None };
			case StylePropertyId.TextOverflow:
				return new List<StyleKeyword>();
			case StylePropertyId.TextShadow:
				return new List<StyleKeyword>();
			case StylePropertyId.Top:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.TransformOrigin:
				return new List<StyleKeyword>();
			case StylePropertyId.TransitionDelay:
				return new List<StyleKeyword>();
			case StylePropertyId.TransitionDuration:
				return new List<StyleKeyword>();
			case StylePropertyId.TransitionProperty:
				return new List<StyleKeyword> { StyleKeyword.None };
			case StylePropertyId.TransitionTimingFunction:
				return new List<StyleKeyword>();
			case StylePropertyId.Translate:
				return new List<StyleKeyword> { StyleKeyword.None };
			case StylePropertyId.UnityBackgroundImageTintColor:
				return new List<StyleKeyword>();
			case StylePropertyId.UnityFont:
				return new List<StyleKeyword>();
			case StylePropertyId.UnityFontDefinition:
				return new List<StyleKeyword>();
			case StylePropertyId.UnityFontStyleAndWeight:
				return new List<StyleKeyword>();
			case StylePropertyId.UnityOverflowClipBox:
				return new List<StyleKeyword>();
			case StylePropertyId.UnityParagraphSpacing:
				return new List<StyleKeyword>();
			case StylePropertyId.UnitySliceBottom:
				return new List<StyleKeyword>();
			case StylePropertyId.UnitySliceLeft:
				return new List<StyleKeyword>();
			case StylePropertyId.UnitySliceRight:
				return new List<StyleKeyword>();
			case StylePropertyId.UnitySliceScale:
				return new List<StyleKeyword>();
			case StylePropertyId.UnitySliceTop:
				return new List<StyleKeyword>();
			case StylePropertyId.UnityTextAlign:
				return new List<StyleKeyword>();
			case StylePropertyId.UnityTextOutlineColor:
				return new List<StyleKeyword>();
			case StylePropertyId.UnityTextOutlineWidth:
				return new List<StyleKeyword>();
			case StylePropertyId.UnityTextOverflowPosition:
				return new List<StyleKeyword>();
			case StylePropertyId.Visibility:
				return new List<StyleKeyword>();
			case StylePropertyId.WhiteSpace:
				return new List<StyleKeyword>();
			case StylePropertyId.Width:
				return new List<StyleKeyword> { StyleKeyword.Auto };
			case StylePropertyId.WordSpacing:
				return new List<StyleKeyword>();
			default:
				Debug.LogAssertion($"Cannot get valid keyword value for property id {id}");
				return null;
			}
		}

		public static object ConvertComputedToInlineStyleValue(StylePropertyId id, object value)
		{
			switch (id)
			{
			case StylePropertyId.AlignContent:
				return (StyleEnum<Align>)(Align)value;
			case StylePropertyId.AlignItems:
				return (StyleEnum<Align>)(Align)value;
			case StylePropertyId.AlignSelf:
				return (StyleEnum<Align>)(Align)value;
			case StylePropertyId.BackgroundColor:
				return (StyleColor)(Color)value;
			case StylePropertyId.BackgroundImage:
				return (StyleBackground)(Background)value;
			case StylePropertyId.BackgroundPositionX:
				return (StyleBackgroundPosition)(BackgroundPosition)value;
			case StylePropertyId.BackgroundPositionY:
				return (StyleBackgroundPosition)(BackgroundPosition)value;
			case StylePropertyId.BackgroundRepeat:
				return (StyleBackgroundRepeat)(BackgroundRepeat)value;
			case StylePropertyId.BackgroundSize:
				return (StyleBackgroundSize)(BackgroundSize)value;
			case StylePropertyId.BorderBottomColor:
				return (StyleColor)(Color)value;
			case StylePropertyId.BorderBottomLeftRadius:
				return (StyleLength)(Length)value;
			case StylePropertyId.BorderBottomRightRadius:
				return (StyleLength)(Length)value;
			case StylePropertyId.BorderBottomWidth:
				return (StyleFloat)(float)value;
			case StylePropertyId.BorderLeftColor:
				return (StyleColor)(Color)value;
			case StylePropertyId.BorderLeftWidth:
				return (StyleFloat)(float)value;
			case StylePropertyId.BorderRightColor:
				return (StyleColor)(Color)value;
			case StylePropertyId.BorderRightWidth:
				return (StyleFloat)(float)value;
			case StylePropertyId.BorderTopColor:
				return (StyleColor)(Color)value;
			case StylePropertyId.BorderTopLeftRadius:
				return (StyleLength)(Length)value;
			case StylePropertyId.BorderTopRightRadius:
				return (StyleLength)(Length)value;
			case StylePropertyId.BorderTopWidth:
				return (StyleFloat)(float)value;
			case StylePropertyId.Bottom:
				return (StyleLength)(Length)value;
			case StylePropertyId.Color:
				return (StyleColor)(Color)value;
			case StylePropertyId.Cursor:
				return (StyleCursor)(Cursor)value;
			case StylePropertyId.Display:
				return (StyleEnum<DisplayStyle>)(DisplayStyle)value;
			case StylePropertyId.FlexBasis:
				return (StyleLength)(Length)value;
			case StylePropertyId.FlexDirection:
				return (StyleEnum<FlexDirection>)(FlexDirection)value;
			case StylePropertyId.FlexGrow:
				return (StyleFloat)(float)value;
			case StylePropertyId.FlexShrink:
				return (StyleFloat)(float)value;
			case StylePropertyId.FlexWrap:
				return (StyleEnum<Wrap>)(Wrap)value;
			case StylePropertyId.FontSize:
				return (StyleLength)(Length)value;
			case StylePropertyId.Height:
				return (StyleLength)(Length)value;
			case StylePropertyId.JustifyContent:
				return (StyleEnum<Justify>)(Justify)value;
			case StylePropertyId.Left:
				return (StyleLength)(Length)value;
			case StylePropertyId.LetterSpacing:
				return (StyleLength)(Length)value;
			case StylePropertyId.MarginBottom:
				return (StyleLength)(Length)value;
			case StylePropertyId.MarginLeft:
				return (StyleLength)(Length)value;
			case StylePropertyId.MarginRight:
				return (StyleLength)(Length)value;
			case StylePropertyId.MarginTop:
				return (StyleLength)(Length)value;
			case StylePropertyId.MaxHeight:
				return (StyleLength)(Length)value;
			case StylePropertyId.MaxWidth:
				return (StyleLength)(Length)value;
			case StylePropertyId.MinHeight:
				return (StyleLength)(Length)value;
			case StylePropertyId.MinWidth:
				return (StyleLength)(Length)value;
			case StylePropertyId.Opacity:
				return (StyleFloat)(float)value;
			case StylePropertyId.Overflow:
				return (StyleEnum<Overflow>)(Overflow)(OverflowInternal)value;
			case StylePropertyId.PaddingBottom:
				return (StyleLength)(Length)value;
			case StylePropertyId.PaddingLeft:
				return (StyleLength)(Length)value;
			case StylePropertyId.PaddingRight:
				return (StyleLength)(Length)value;
			case StylePropertyId.PaddingTop:
				return (StyleLength)(Length)value;
			case StylePropertyId.Position:
				return (StyleEnum<Position>)(Position)value;
			case StylePropertyId.Right:
				return (StyleLength)(Length)value;
			case StylePropertyId.Rotate:
				return (StyleRotate)(Rotate)value;
			case StylePropertyId.Scale:
				return (StyleScale)(Scale)value;
			case StylePropertyId.TextOverflow:
				return (StyleEnum<TextOverflow>)(TextOverflow)value;
			case StylePropertyId.TextShadow:
				return (StyleTextShadow)(TextShadow)value;
			case StylePropertyId.Top:
				return (StyleLength)(Length)value;
			case StylePropertyId.TransformOrigin:
				return (StyleTransformOrigin)(TransformOrigin)value;
			case StylePropertyId.TransitionDelay:
				return (StyleList<TimeValue>)(List<TimeValue>)value;
			case StylePropertyId.TransitionDuration:
				return (StyleList<TimeValue>)(List<TimeValue>)value;
			case StylePropertyId.TransitionProperty:
				return (StyleList<StylePropertyName>)(List<StylePropertyName>)value;
			case StylePropertyId.TransitionTimingFunction:
				return (StyleList<EasingFunction>)(List<EasingFunction>)value;
			case StylePropertyId.Translate:
				return (StyleTranslate)(Translate)value;
			case StylePropertyId.UnityBackgroundImageTintColor:
				return (StyleColor)(Color)value;
			case StylePropertyId.UnityFont:
				return (StyleFont)(Font)value;
			case StylePropertyId.UnityFontDefinition:
				return (StyleFontDefinition)(FontDefinition)value;
			case StylePropertyId.UnityFontStyleAndWeight:
				return (StyleEnum<FontStyle>)(FontStyle)value;
			case StylePropertyId.UnityOverflowClipBox:
				return (StyleEnum<OverflowClipBox>)(OverflowClipBox)value;
			case StylePropertyId.UnityParagraphSpacing:
				return (StyleLength)(Length)value;
			case StylePropertyId.UnitySliceBottom:
				return (StyleInt)(int)value;
			case StylePropertyId.UnitySliceLeft:
				return (StyleInt)(int)value;
			case StylePropertyId.UnitySliceRight:
				return (StyleInt)(int)value;
			case StylePropertyId.UnitySliceScale:
				return (StyleFloat)(float)value;
			case StylePropertyId.UnitySliceTop:
				return (StyleInt)(int)value;
			case StylePropertyId.UnityTextAlign:
				return (StyleEnum<TextAnchor>)(TextAnchor)value;
			case StylePropertyId.UnityTextOutlineColor:
				return (StyleColor)(Color)value;
			case StylePropertyId.UnityTextOutlineWidth:
				return (StyleFloat)(float)value;
			case StylePropertyId.UnityTextOverflowPosition:
				return (StyleEnum<TextOverflowPosition>)(TextOverflowPosition)value;
			case StylePropertyId.Visibility:
				return (StyleEnum<Visibility>)(Visibility)value;
			case StylePropertyId.WhiteSpace:
				return (StyleEnum<WhiteSpace>)(WhiteSpace)value;
			case StylePropertyId.Width:
				return (StyleLength)(Length)value;
			case StylePropertyId.WordSpacing:
				return (StyleLength)(Length)value;
			default:
				Debug.LogAssertion($"Cannot convert computed style value to inline style value for property id {id}");
				return null;
			}
		}

		public static Type GetInlineStyleType(StylePropertyId id)
		{
			switch (id)
			{
			case StylePropertyId.AlignContent:
				return typeof(StyleEnum<Align>);
			case StylePropertyId.AlignItems:
				return typeof(StyleEnum<Align>);
			case StylePropertyId.AlignSelf:
				return typeof(StyleEnum<Align>);
			case StylePropertyId.BackgroundColor:
				return typeof(StyleColor);
			case StylePropertyId.BackgroundImage:
				return typeof(StyleBackground);
			case StylePropertyId.BackgroundPositionX:
				return typeof(StyleBackgroundPosition);
			case StylePropertyId.BackgroundPositionY:
				return typeof(StyleBackgroundPosition);
			case StylePropertyId.BackgroundRepeat:
				return typeof(StyleBackgroundRepeat);
			case StylePropertyId.BackgroundSize:
				return typeof(StyleBackgroundSize);
			case StylePropertyId.BorderBottomColor:
				return typeof(StyleColor);
			case StylePropertyId.BorderBottomLeftRadius:
				return typeof(StyleLength);
			case StylePropertyId.BorderBottomRightRadius:
				return typeof(StyleLength);
			case StylePropertyId.BorderBottomWidth:
				return typeof(StyleFloat);
			case StylePropertyId.BorderLeftColor:
				return typeof(StyleColor);
			case StylePropertyId.BorderLeftWidth:
				return typeof(StyleFloat);
			case StylePropertyId.BorderRightColor:
				return typeof(StyleColor);
			case StylePropertyId.BorderRightWidth:
				return typeof(StyleFloat);
			case StylePropertyId.BorderTopColor:
				return typeof(StyleColor);
			case StylePropertyId.BorderTopLeftRadius:
				return typeof(StyleLength);
			case StylePropertyId.BorderTopRightRadius:
				return typeof(StyleLength);
			case StylePropertyId.BorderTopWidth:
				return typeof(StyleFloat);
			case StylePropertyId.Bottom:
				return typeof(StyleLength);
			case StylePropertyId.Color:
				return typeof(StyleColor);
			case StylePropertyId.Cursor:
				return typeof(StyleCursor);
			case StylePropertyId.Display:
				return typeof(StyleEnum<DisplayStyle>);
			case StylePropertyId.FlexBasis:
				return typeof(StyleLength);
			case StylePropertyId.FlexDirection:
				return typeof(StyleEnum<FlexDirection>);
			case StylePropertyId.FlexGrow:
				return typeof(StyleFloat);
			case StylePropertyId.FlexShrink:
				return typeof(StyleFloat);
			case StylePropertyId.FlexWrap:
				return typeof(StyleEnum<Wrap>);
			case StylePropertyId.FontSize:
				return typeof(StyleLength);
			case StylePropertyId.Height:
				return typeof(StyleLength);
			case StylePropertyId.JustifyContent:
				return typeof(StyleEnum<Justify>);
			case StylePropertyId.Left:
				return typeof(StyleLength);
			case StylePropertyId.LetterSpacing:
				return typeof(StyleLength);
			case StylePropertyId.MarginBottom:
				return typeof(StyleLength);
			case StylePropertyId.MarginLeft:
				return typeof(StyleLength);
			case StylePropertyId.MarginRight:
				return typeof(StyleLength);
			case StylePropertyId.MarginTop:
				return typeof(StyleLength);
			case StylePropertyId.MaxHeight:
				return typeof(StyleLength);
			case StylePropertyId.MaxWidth:
				return typeof(StyleLength);
			case StylePropertyId.MinHeight:
				return typeof(StyleLength);
			case StylePropertyId.MinWidth:
				return typeof(StyleLength);
			case StylePropertyId.Opacity:
				return typeof(StyleFloat);
			case StylePropertyId.Overflow:
				return typeof(StyleEnum<Overflow>);
			case StylePropertyId.PaddingBottom:
				return typeof(StyleLength);
			case StylePropertyId.PaddingLeft:
				return typeof(StyleLength);
			case StylePropertyId.PaddingRight:
				return typeof(StyleLength);
			case StylePropertyId.PaddingTop:
				return typeof(StyleLength);
			case StylePropertyId.Position:
				return typeof(StyleEnum<Position>);
			case StylePropertyId.Right:
				return typeof(StyleLength);
			case StylePropertyId.Rotate:
				return typeof(StyleRotate);
			case StylePropertyId.Scale:
				return typeof(StyleScale);
			case StylePropertyId.TextOverflow:
				return typeof(StyleEnum<TextOverflow>);
			case StylePropertyId.TextShadow:
				return typeof(StyleTextShadow);
			case StylePropertyId.Top:
				return typeof(StyleLength);
			case StylePropertyId.TransformOrigin:
				return typeof(StyleTransformOrigin);
			case StylePropertyId.TransitionDelay:
				return typeof(StyleList<TimeValue>);
			case StylePropertyId.TransitionDuration:
				return typeof(StyleList<TimeValue>);
			case StylePropertyId.TransitionProperty:
				return typeof(StyleList<StylePropertyName>);
			case StylePropertyId.TransitionTimingFunction:
				return typeof(StyleList<EasingFunction>);
			case StylePropertyId.Translate:
				return typeof(StyleTranslate);
			case StylePropertyId.UnityBackgroundImageTintColor:
				return typeof(StyleColor);
			case StylePropertyId.UnityFont:
				return typeof(StyleFont);
			case StylePropertyId.UnityFontDefinition:
				return typeof(StyleFontDefinition);
			case StylePropertyId.UnityFontStyleAndWeight:
				return typeof(StyleEnum<FontStyle>);
			case StylePropertyId.UnityOverflowClipBox:
				return typeof(StyleEnum<OverflowClipBox>);
			case StylePropertyId.UnityParagraphSpacing:
				return typeof(StyleLength);
			case StylePropertyId.UnitySliceBottom:
				return typeof(StyleInt);
			case StylePropertyId.UnitySliceLeft:
				return typeof(StyleInt);
			case StylePropertyId.UnitySliceRight:
				return typeof(StyleInt);
			case StylePropertyId.UnitySliceScale:
				return typeof(StyleFloat);
			case StylePropertyId.UnitySliceTop:
				return typeof(StyleInt);
			case StylePropertyId.UnityTextAlign:
				return typeof(StyleEnum<TextAnchor>);
			case StylePropertyId.UnityTextOutlineColor:
				return typeof(StyleColor);
			case StylePropertyId.UnityTextOutlineWidth:
				return typeof(StyleFloat);
			case StylePropertyId.UnityTextOverflowPosition:
				return typeof(StyleEnum<TextOverflowPosition>);
			case StylePropertyId.Visibility:
				return typeof(StyleEnum<Visibility>);
			case StylePropertyId.WhiteSpace:
				return typeof(StyleEnum<WhiteSpace>);
			case StylePropertyId.Width:
				return typeof(StyleLength);
			case StylePropertyId.WordSpacing:
				return typeof(StyleLength);
			default:
				Debug.LogAssertion($"Cannot get computed style type for property id {id}");
				return null;
			}
		}

		public static string[] GetLonghandPropertyNames(StylePropertyId id)
		{
			switch (id)
			{
			case StylePropertyId.All:
				return new string[0];
			case StylePropertyId.BackgroundPosition:
				return new string[2] { "background-position-x", "background-position-y" };
			case StylePropertyId.BorderColor:
				return new string[4] { "border-top-color", "border-right-color", "border-bottom-color", "border-left-color" };
			case StylePropertyId.BorderRadius:
				return new string[4] { "border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius" };
			case StylePropertyId.BorderWidth:
				return new string[4] { "border-top-width", "border-right-width", "border-bottom-width", "border-left-width" };
			case StylePropertyId.Flex:
				return new string[3] { "flex-grow", "flex-shrink", "flex-basis" };
			case StylePropertyId.Margin:
				return new string[4] { "margin-top", "margin-right", "margin-bottom", "margin-left" };
			case StylePropertyId.Padding:
				return new string[4] { "padding-top", "padding-right", "padding-bottom", "padding-left" };
			case StylePropertyId.Transition:
				return new string[4] { "transition-delay", "transition-duration", "transition-property", "transition-timing-function" };
			case StylePropertyId.UnityBackgroundScaleMode:
				return new string[4] { "background-position-x", "background-position-y", "background-repeat", "background-size" };
			case StylePropertyId.UnityTextOutline:
				return new string[2] { "-unity-text-outline-color", "-unity-text-outline-width" };
			default:
				Debug.LogAssertion($"Cannot get longhand property names for property id {id}");
				return null;
			}
		}

		public static bool IsShorthandProperty(StylePropertyId id)
		{
			return id switch
			{
				StylePropertyId.All => true, 
				StylePropertyId.BackgroundPosition => true, 
				StylePropertyId.BorderColor => true, 
				StylePropertyId.BorderRadius => true, 
				StylePropertyId.BorderWidth => true, 
				StylePropertyId.Flex => true, 
				StylePropertyId.Margin => true, 
				StylePropertyId.Padding => true, 
				StylePropertyId.Transition => true, 
				StylePropertyId.UnityBackgroundScaleMode => true, 
				StylePropertyId.UnityTextOutline => true, 
				_ => false, 
			};
		}

		public static bool IsInheritedProperty(StylePropertyId id)
		{
			return id switch
			{
				StylePropertyId.Color => true, 
				StylePropertyId.FontSize => true, 
				StylePropertyId.LetterSpacing => true, 
				StylePropertyId.TextShadow => true, 
				StylePropertyId.UnityFont => true, 
				StylePropertyId.UnityFontDefinition => true, 
				StylePropertyId.UnityFontStyleAndWeight => true, 
				StylePropertyId.UnityParagraphSpacing => true, 
				StylePropertyId.UnityTextAlign => true, 
				StylePropertyId.UnityTextOutlineColor => true, 
				StylePropertyId.UnityTextOutlineWidth => true, 
				StylePropertyId.Visibility => true, 
				StylePropertyId.WhiteSpace => true, 
				StylePropertyId.WordSpacing => true, 
				_ => false, 
			};
		}

		public static StylePropertyId[] GetInheritedProperties()
		{
			return new StylePropertyId[14]
			{
				StylePropertyId.Color,
				StylePropertyId.FontSize,
				StylePropertyId.LetterSpacing,
				StylePropertyId.TextShadow,
				StylePropertyId.UnityFont,
				StylePropertyId.UnityFontDefinition,
				StylePropertyId.UnityFontStyleAndWeight,
				StylePropertyId.UnityParagraphSpacing,
				StylePropertyId.UnityTextAlign,
				StylePropertyId.UnityTextOutlineColor,
				StylePropertyId.UnityTextOutlineWidth,
				StylePropertyId.Visibility,
				StylePropertyId.WhiteSpace,
				StylePropertyId.WordSpacing
			};
		}

		public static bool IsDiscreteTypeProperty(StylePropertyId id)
		{
			return id switch
			{
				StylePropertyId.AlignContent => true, 
				StylePropertyId.AlignItems => true, 
				StylePropertyId.AlignSelf => true, 
				StylePropertyId.BackgroundImage => true, 
				StylePropertyId.BackgroundPositionX => true, 
				StylePropertyId.BackgroundPositionY => true, 
				StylePropertyId.BackgroundRepeat => true, 
				StylePropertyId.Display => true, 
				StylePropertyId.FlexDirection => true, 
				StylePropertyId.FlexWrap => true, 
				StylePropertyId.JustifyContent => true, 
				StylePropertyId.Overflow => true, 
				StylePropertyId.Position => true, 
				StylePropertyId.TextOverflow => true, 
				StylePropertyId.UnityFont => true, 
				StylePropertyId.UnityFontDefinition => true, 
				StylePropertyId.UnityFontStyleAndWeight => true, 
				StylePropertyId.UnityOverflowClipBox => true, 
				StylePropertyId.UnityTextAlign => true, 
				StylePropertyId.UnityTextOverflowPosition => true, 
				StylePropertyId.Visibility => true, 
				StylePropertyId.WhiteSpace => true, 
				_ => false, 
			};
		}

		public static string[] GetStylePropertyNames()
		{
			List<string> list = StylePropertyUtil.s_NameToId.Keys.ToList();
			list.Sort();
			return list.ToArray();
		}

		public static string[] GetLonghandPropertyNames(string shorthandName)
		{
			if (StylePropertyUtil.s_NameToId.TryGetValue(shorthandName, out var value) && IsShorthandProperty(value))
			{
				return GetLonghandPropertyNames(value);
			}
			return null;
		}

		public static StylePropertyId GetStylePropertyIdFromName(string name)
		{
			if (string.IsNullOrEmpty(name))
			{
				return StylePropertyId.Unknown;
			}
			if (StylePropertyUtil.s_NameToId.TryGetValue(name, out var value))
			{
				return value;
			}
			return StylePropertyId.Unknown;
		}

		public static object GetComputedStyleValue(in ComputedStyle computedStyle, string name)
		{
			if (string.IsNullOrEmpty(name))
			{
				return null;
			}
			if (StylePropertyUtil.s_NameToId.TryGetValue(name, out var value))
			{
				bool valid;
				if (value == StylePropertyId.UnityBackgroundScaleMode)
				{
					return BackgroundPropertyHelper.ResolveUnityBackgroundScaleMode(computedStyle.backgroundPositionX, computedStyle.backgroundPositionY, computedStyle.backgroundRepeat, computedStyle.backgroundSize, out valid);
				}
				return GetComputedStyleValue(in computedStyle, value);
			}
			return null;
		}

		public static object GetInlineStyleValue(IStyle style, string name)
		{
			if (string.IsNullOrEmpty(name))
			{
				return null;
			}
			if (StylePropertyUtil.s_NameToId.TryGetValue(name, out var value))
			{
				if (value == StylePropertyId.UnityBackgroundScaleMode)
				{
					return style.unityBackgroundScaleMode;
				}
				return GetInlineStyleValue(style, value);
			}
			return null;
		}

		public static void SetInlineStyleValue(IStyle style, string name, object value)
		{
			if (StylePropertyUtil.s_NameToId.TryGetValue(name, out var value2))
			{
				SetInlineStyleValue(style, value2, value);
			}
		}

		public static Type GetInlineStyleType(string name)
		{
			if (string.IsNullOrEmpty(name))
			{
				return null;
			}
			if (StylePropertyUtil.s_NameToId.TryGetValue(name, out var value))
			{
				if (value == StylePropertyId.UnityBackgroundScaleMode)
				{
					return typeof(StyleEnum<ScaleMode>);
				}
				if (!IsShorthandProperty(value))
				{
					return GetInlineStyleType(value);
				}
			}
			return null;
		}

		public static Type GetComputedStyleType(string name)
		{
			if (string.IsNullOrEmpty(name))
			{
				return null;
			}
			if (StylePropertyUtil.s_NameToId.TryGetValue(name, out var value))
			{
				if (value == StylePropertyId.UnityBackgroundScaleMode)
				{
					return typeof(ScaleMode);
				}
				if (!IsShorthandProperty(value))
				{
					return GetComputedStyleType(value);
				}
			}
			return null;
		}

		public static void FindSpecifiedStyles(in ComputedStyle computedStyle, IEnumerable<SelectorMatchRecord> matchRecords, Dictionary<StylePropertyId, int> result)
		{
			result.Clear();
			foreach (SelectorMatchRecord matchRecord in matchRecords)
			{
				int value = matchRecord.complexSelector.specificity;
				if (matchRecord.sheet.isDefaultStyleSheet)
				{
					value = -1;
				}
				StyleProperty[] properties = matchRecord.complexSelector.rule.properties;
				StyleProperty[] array = properties;
				foreach (StyleProperty styleProperty in array)
				{
					if (!StylePropertyUtil.s_NameToId.TryGetValue(styleProperty.name, out var value2))
					{
						continue;
					}
					if (IsShorthandProperty(value2))
					{
						string[] longhandPropertyNames = GetLonghandPropertyNames(value2);
						string[] array2 = longhandPropertyNames;
						foreach (string name in array2)
						{
							StylePropertyId stylePropertyIdFromName = GetStylePropertyIdFromName(name);
							result[stylePropertyIdFromName] = value;
						}
					}
					else
					{
						result[value2] = value;
					}
				}
			}
			StylePropertyId[] inheritedProperties = GetInheritedProperties();
			StylePropertyId[] array3 = inheritedProperties;
			foreach (StylePropertyId stylePropertyId in array3)
			{
				if (!result.ContainsKey(stylePropertyId))
				{
					object computedStyleValue = GetComputedStyleValue(in computedStyle, stylePropertyId);
					object computedStyleValue2 = GetComputedStyleValue(in InitialStyle.Get(), stylePropertyId);
					if (computedStyleValue != null && !computedStyleValue.Equals(computedStyleValue2))
					{
						result[stylePropertyId] = 2147483646;
					}
				}
			}
		}
	}
	internal class StyleValueCollection
	{
		internal List<StyleValue> m_Values = new List<StyleValue>();

		public StyleLength GetStyleLength(StylePropertyId id)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				return new StyleLength(value.length, value.keyword);
			}
			return StyleKeyword.Null;
		}

		public StyleFloat GetStyleFloat(StylePropertyId id)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				return new StyleFloat(value.number, value.keyword);
			}
			return StyleKeyword.Null;
		}

		public StyleInt GetStyleInt(StylePropertyId id)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				return new StyleInt((int)value.number, value.keyword);
			}
			return StyleKeyword.Null;
		}

		public StyleColor GetStyleColor(StylePropertyId id)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				return new StyleColor(value.color, value.keyword);
			}
			return StyleKeyword.Null;
		}

		public StyleBackground GetStyleBackground(StylePropertyId id)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				Texture2D texture2D = (value.resource.IsAllocated ? (value.resource.Target as Texture2D) : null);
				if (texture2D != null)
				{
					return new StyleBackground(texture2D, value.keyword);
				}
				Sprite sprite = (value.resource.IsAllocated ? (value.resource.Target as Sprite) : null);
				if (sprite != null)
				{
					return new StyleBackground(sprite, value.keyword);
				}
				VectorImage vectorImage = (value.resource.IsAllocated ? (value.resource.Target as VectorImage) : null);
				if (vectorImage != null)
				{
					return new StyleBackground(vectorImage, value.keyword);
				}
			}
			return StyleKeyword.Null;
		}

		public StyleBackgroundPosition GetStyleBackgroundPosition(StylePropertyId id)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				return new StyleBackgroundPosition(value.position);
			}
			return StyleKeyword.Null;
		}

		public StyleBackgroundRepeat GetStyleBackgroundRepeat(StylePropertyId id)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				return new StyleBackgroundRepeat(value.repeat);
			}
			return StyleKeyword.Null;
		}

		public StyleFont GetStyleFont(StylePropertyId id)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				Font v = (value.resource.IsAllocated ? (value.resource.Target as Font) : null);
				return new StyleFont(v, value.keyword);
			}
			return StyleKeyword.Null;
		}

		public StyleFontDefinition GetStyleFontDefinition(StylePropertyId id)
		{
			StyleValue value = default(StyleValue);
			if (TryGetStyleValue(id, ref value))
			{
				object obj = (value.resource.IsAllocated ? value.resource.Target : null);
				return new StyleFontDefinition(obj, value.keyword);
			}
			return StyleKeyword.Null;
		}

		public bool TryGetStyleValue(StylePropertyId id, ref StyleValue value)
		{
			value.id = StylePropertyId.Unknown;
			foreach (StyleValue value2 in m_Values)
			{
				if (value2.id == id)
				{
					value = value2;
					return true;
				}
			}
			return false;
		}

		public void SetStyleValue(StyleValue value)
		{
			for (int i = 0; i < m_Values.Count; i++)
			{
				if (m_Values[i].id == value.id)
				{
					if (value.keyword == StyleKeyword.Null)
					{
						m_Values.RemoveAt(i);
					}
					else
					{
						m_Values[i] = value;
					}
					return;
				}
			}
			m_Values.Add(value);
		}
	}
	public enum LengthUnit
	{
		Pixel,
		Percent
	}
	[Serializable]
	public struct Length : IEquatable<Length>
	{
		private enum Unit
		{
			Pixel,
			Percent,
			Auto,
			None
		}

		internal const float k_MaxValue = 8388608f;

		[SerializeField]
		private float m_Value;

		[SerializeField]
		private Unit m_Unit;

		public float value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = Mathf.Clamp(value, -8388608f, 8388608f);
			}
		}

		public LengthUnit unit
		{
			get
			{
				return (LengthUnit)m_Unit;
			}
			set
			{
				m_Unit = (Unit)value;
			}
		}

		public static Length Percent(float value)
		{
			return new Length(value, LengthUnit.Percent);
		}

		public static Length Auto()
		{
			return new Length(0f, Unit.Auto);
		}

		public static Length None()
		{
			return new Length(0f, Unit.None);
		}

		public bool IsAuto()
		{
			return m_Unit == Unit.Auto;
		}

		public bool IsNone()
		{
			return m_Unit == Unit.None;
		}

		public Length(float value)
			: this(value, Unit.Pixel)
		{
		}

		public Length(float value, LengthUnit unit)
			: this(value, (Unit)unit)
		{
		}

		private Length(float value, Unit unit)
		{
			this = default(Length);
			this.value = value;
			m_Unit = unit;
		}

		public static implicit operator Length(float value)
		{
			return new Length(value, LengthUnit.Pixel);
		}

		public static bool operator ==(Length lhs, Length rhs)
		{
			return lhs.m_Value == rhs.m_Value && lhs.m_Unit == rhs.m_Unit;
		}

		public static bool operator !=(Length lhs, Length rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(Length other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is Length other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value.GetHashCode() * 397) ^ (int)m_Unit;
		}

		public override string ToString()
		{
			string text = value.ToString(CultureInfo.InvariantCulture.NumberFormat);
			string text2 = string.Empty;
			switch (m_Unit)
			{
			case Unit.Pixel:
				if (!Mathf.Approximately(0f, value))
				{
					text2 = "px";
				}
				break;
			case Unit.Percent:
				text2 = "%";
				break;
			case Unit.Auto:
				text = "auto";
				break;
			case Unit.None:
				text = "none";
				break;
			}
			return text + text2;
		}
	}
	public struct Rotate : IEquatable<Rotate>
	{
		private Angle m_Angle;

		private Vector3 m_Axis;

		private bool m_IsNone;

		public Angle angle
		{
			get
			{
				return m_Angle;
			}
			set
			{
				m_Angle = value;
			}
		}

		internal Vector3 axis
		{
			get
			{
				return m_Axis;
			}
			set
			{
				m_Axis = value;
			}
		}

		internal Rotate(Angle angle, Vector3 axis)
		{
			m_Angle = angle;
			m_Axis = axis;
			m_IsNone = false;
		}

		public Rotate(Angle angle)
		{
			m_Angle = angle;
			m_Axis = Vector3.forward;
			m_IsNone = false;
		}

		internal static Rotate Initial()
		{
			return new Rotate(0f);
		}

		public static Rotate None()
		{
			Rotate result = Initial();
			result.m_IsNone = true;
			return result;
		}

		internal bool IsNone()
		{
			return m_IsNone;
		}

		public static bool operator ==(Rotate lhs, Rotate rhs)
		{
			return lhs.m_Angle == rhs.m_Angle && lhs.m_Axis == rhs.m_Axis && lhs.m_IsNone == rhs.m_IsNone;
		}

		public static bool operator !=(Rotate lhs, Rotate rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(Rotate other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is Rotate other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Angle.GetHashCode() * 793) ^ (m_Axis.GetHashCode() * 791) ^ (m_IsNone.GetHashCode() * 197);
		}

		public override string ToString()
		{
			return m_Angle.ToString() + " " + m_Axis.ToString();
		}

		internal Quaternion ToQuaternion()
		{
			return Quaternion.AngleAxis(m_Angle.ToDegrees(), m_Axis);
		}
	}
	public struct Scale : IEquatable<Scale>
	{
		private Vector3 m_Scale;

		private bool m_IsNone;

		public Vector3 value
		{
			get
			{
				return m_Scale;
			}
			set
			{
				m_Scale = value;
			}
		}

		public Scale(Vector2 scale)
		{
			m_Scale = new Vector3(scale.x, scale.y, 1f);
			m_IsNone = false;
		}

		public Scale(Vector3 scale)
		{
			if (!Mathf.Approximately(1f, scale.z))
			{
				Debug.LogWarning("Assigning Z scale different than 1.0f, this is not yet supported. Forcing the value to 1.0f.");
				scale.z = 1f;
			}
			m_Scale = scale;
			m_IsNone = false;
		}

		internal static Scale Initial()
		{
			return new Scale(Vector3.one);
		}

		public static Scale None()
		{
			Scale result = Initial();
			result.m_IsNone = true;
			return result;
		}

		internal bool IsNone()
		{
			return m_IsNone;
		}

		public static implicit operator Scale(Vector2 scale)
		{
			return new Scale(scale);
		}

		public static bool operator ==(Scale lhs, Scale rhs)
		{
			return lhs.m_Scale == rhs.m_Scale;
		}

		public static bool operator !=(Scale lhs, Scale rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(Scale other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is Scale other && Equals(other);
		}

		public override int GetHashCode()
		{
			return m_Scale.GetHashCode() * 793;
		}

		public override string ToString()
		{
			return m_Scale.ToString();
		}
	}
	public struct StyleBackground : IStyleValue<Background>, IEquatable<StyleBackground>
	{
		private Background m_Value;

		private StyleKeyword m_Keyword;

		public Background value
		{
			get
			{
				return (m_Keyword == StyleKeyword.Undefined) ? m_Value : default(Background);
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleBackground(Background v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleBackground(Texture2D v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleBackground(Sprite v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleBackground(VectorImage v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleBackground(StyleKeyword keyword)
			: this(default(Background), keyword)
		{
		}

		internal StyleBackground(Texture2D v, StyleKeyword keyword)
			: this(Background.FromTexture2D(v), keyword)
		{
		}

		internal StyleBackground(Sprite v, StyleKeyword keyword)
			: this(Background.FromSprite(v), keyword)
		{
		}

		internal StyleBackground(VectorImage v, StyleKeyword keyword)
			: this(Background.FromVectorImage(v), keyword)
		{
		}

		internal StyleBackground(Background v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static bool operator ==(StyleBackground lhs, StyleBackground rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && lhs.m_Value == rhs.m_Value;
		}

		public static bool operator !=(StyleBackground lhs, StyleBackground rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleBackground(StyleKeyword keyword)
		{
			return new StyleBackground(keyword);
		}

		public static implicit operator StyleBackground(Background v)
		{
			return new StyleBackground(v);
		}

		public static implicit operator StyleBackground(Texture2D v)
		{
			return new StyleBackground(v);
		}

		public bool Equals(StyleBackground other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleBackground other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value.GetHashCode() * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	public struct StyleBackgroundPosition : IStyleValue<BackgroundPosition>, IEquatable<StyleBackgroundPosition>
	{
		private BackgroundPosition m_Value;

		private StyleKeyword m_Keyword;

		public BackgroundPosition value
		{
			get
			{
				return (m_Keyword == StyleKeyword.Undefined) ? m_Value : default(BackgroundPosition);
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleBackgroundPosition(BackgroundPosition v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleBackgroundPosition(StyleKeyword keyword)
			: this(default(BackgroundPosition), keyword)
		{
		}

		internal StyleBackgroundPosition(BackgroundPosition v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static bool operator ==(StyleBackgroundPosition lhs, StyleBackgroundPosition rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && lhs.m_Value == rhs.m_Value;
		}

		public static bool operator !=(StyleBackgroundPosition lhs, StyleBackgroundPosition rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleBackgroundPosition(StyleKeyword keyword)
		{
			return new StyleBackgroundPosition(keyword);
		}

		public static implicit operator StyleBackgroundPosition(BackgroundPosition v)
		{
			return new StyleBackgroundPosition(v);
		}

		public bool Equals(StyleBackgroundPosition other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleBackgroundPosition other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value.GetHashCode() * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	public struct StyleBackgroundRepeat : IStyleValue<BackgroundRepeat>, IEquatable<StyleBackgroundRepeat>
	{
		private BackgroundRepeat m_Value;

		private StyleKeyword m_Keyword;

		public BackgroundRepeat value
		{
			get
			{
				return (m_Keyword == StyleKeyword.Undefined) ? m_Value : default(BackgroundRepeat);
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleBackgroundRepeat(BackgroundRepeat v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleBackgroundRepeat(StyleKeyword keyword)
			: this(default(BackgroundRepeat), keyword)
		{
		}

		internal StyleBackgroundRepeat(BackgroundRepeat v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static bool operator ==(StyleBackgroundRepeat lhs, StyleBackgroundRepeat rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && lhs.m_Value == rhs.m_Value;
		}

		public static bool operator !=(StyleBackgroundRepeat lhs, StyleBackgroundRepeat rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleBackgroundRepeat(StyleKeyword keyword)
		{
			return new StyleBackgroundRepeat(keyword);
		}

		public static implicit operator StyleBackgroundRepeat(BackgroundRepeat v)
		{
			return new StyleBackgroundRepeat(v);
		}

		public bool Equals(StyleBackgroundRepeat other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleBackgroundRepeat other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value.GetHashCode() * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	public struct StyleBackgroundSize : IStyleValue<BackgroundSize>, IEquatable<StyleBackgroundSize>
	{
		private BackgroundSize m_Value;

		private StyleKeyword m_Keyword;

		public BackgroundSize value
		{
			get
			{
				return (m_Keyword == StyleKeyword.Undefined) ? m_Value : default(BackgroundSize);
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleBackgroundSize(BackgroundSize v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleBackgroundSize(StyleKeyword keyword)
			: this(default(BackgroundSize), keyword)
		{
		}

		internal StyleBackgroundSize(BackgroundSize v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static bool operator ==(StyleBackgroundSize lhs, StyleBackgroundSize rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && lhs.m_Value == rhs.m_Value;
		}

		public static bool operator !=(StyleBackgroundSize lhs, StyleBackgroundSize rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleBackgroundSize(StyleKeyword keyword)
		{
			return new StyleBackgroundSize(keyword);
		}

		public static implicit operator StyleBackgroundSize(BackgroundSize v)
		{
			return new StyleBackgroundSize(v);
		}

		public bool Equals(StyleBackgroundSize other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleBackgroundSize other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value.GetHashCode() * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	public struct StyleColor : IStyleValue<Color>, IEquatable<StyleColor>
	{
		private Color m_Value;

		private StyleKeyword m_Keyword;

		public Color value
		{
			get
			{
				return (m_Keyword == StyleKeyword.Undefined) ? m_Value : Color.clear;
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleColor(Color v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleColor(StyleKeyword keyword)
			: this(Color.clear, keyword)
		{
		}

		internal StyleColor(Color v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static bool operator ==(StyleColor lhs, StyleColor rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && lhs.m_Value == rhs.m_Value;
		}

		public static bool operator !=(StyleColor lhs, StyleColor rhs)
		{
			return !(lhs == rhs);
		}

		public static bool operator ==(StyleColor lhs, Color rhs)
		{
			StyleColor styleColor = new StyleColor(rhs);
			return lhs == styleColor;
		}

		public static bool operator !=(StyleColor lhs, Color rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleColor(StyleKeyword keyword)
		{
			return new StyleColor(keyword);
		}

		public static implicit operator StyleColor(Color v)
		{
			return new StyleColor(v);
		}

		public bool Equals(StyleColor other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleColor other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value.GetHashCode() * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	public struct StyleCursor : IStyleValue<Cursor>, IEquatable<StyleCursor>
	{
		private Cursor m_Value;

		private StyleKeyword m_Keyword;

		public Cursor value
		{
			get
			{
				return (m_Keyword == StyleKeyword.Undefined) ? m_Value : default(Cursor);
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleCursor(Cursor v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleCursor(StyleKeyword keyword)
			: this(default(Cursor), keyword)
		{
		}

		internal StyleCursor(Cursor v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static bool operator ==(StyleCursor lhs, StyleCursor rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && lhs.m_Value == rhs.m_Value;
		}

		public static bool operator !=(StyleCursor lhs, StyleCursor rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleCursor(StyleKeyword keyword)
		{
			return new StyleCursor(keyword);
		}

		public static implicit operator StyleCursor(Cursor v)
		{
			return new StyleCursor(v);
		}

		public bool Equals(StyleCursor other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleCursor other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value.GetHashCode() * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	internal struct StyleDataRef<T> : IEquatable<StyleDataRef<T>> where T : struct, IEquatable<T>, IStyleDataGroup<T>
	{
		private class RefCounted
		{
			private static uint m_NextId = 1u;

			private int m_RefCount;

			private readonly uint m_Id;

			public T value;

			public int refCount => m_RefCount;

			public uint id => m_Id;

			public RefCounted()
			{
				m_RefCount = 1;
				m_Id = ++m_NextId;
			}

			public void Acquire()
			{
				m_RefCount++;
			}

			public void Release()
			{
				m_RefCount--;
			}

			public RefCounted Copy()
			{
				return new RefCounted
				{
					value = value.Copy()
				};
			}
		}

		private RefCounted m_Ref;

		public int refCount => m_Ref?.refCount ?? 0;

		public uint id => m_Ref?.id ?? 0;

		public StyleDataRef<T> Acquire()
		{
			m_Ref.Acquire();
			return this;
		}

		public void Release()
		{
			m_Ref.Release();
			m_Ref = null;
		}

		public void CopyFrom(StyleDataRef<T> other)
		{
			if (m_Ref.refCount == 1)
			{
				m_Ref.value.CopyFrom(ref other.m_Ref.value);
				return;
			}
			m_Ref.Release();
			m_Ref = other.m_Ref;
			m_Ref.Acquire();
		}

		public ref readonly T Read()
		{
			return ref m_Ref.value;
		}

		public ref T Write()
		{
			if (m_Ref.refCount == 1)
			{
				return ref m_Ref.value;
			}
			RefCounted refCounted = m_Ref;
			m_Ref = m_Ref.Copy();
			refCounted.Release();
			return ref m_Ref.value;
		}

		public static StyleDataRef<T> Create()
		{
			return new StyleDataRef<T>
			{
				m_Ref = new RefCounted()
			};
		}

		public override int GetHashCode()
		{
			return (m_Ref != null) ? m_Ref.value.GetHashCode() : 0;
		}

		public static bool operator ==(StyleDataRef<T> lhs, StyleDataRef<T> rhs)
		{
			return lhs.m_Ref == rhs.m_Ref || lhs.m_Ref.value.Equals(rhs.m_Ref.value);
		}

		public static bool operator !=(StyleDataRef<T> lhs, StyleDataRef<T> rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(StyleDataRef<T> other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleDataRef<T> other && Equals(other);
		}

		public bool ReferenceEquals(StyleDataRef<T> other)
		{
			return m_Ref == other.m_Ref;
		}
	}
	public struct StyleEnum<T> : IStyleValue<T>, IEquatable<StyleEnum<T>> where T : struct, IConvertible
	{
		private T m_Value;

		private StyleKeyword m_Keyword;

		public T value
		{
			get
			{
				return (m_Keyword == StyleKeyword.Undefined) ? m_Value : default(T);
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleEnum(T v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleEnum(StyleKeyword keyword)
			: this(default(T), keyword)
		{
		}

		internal StyleEnum(T v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static bool operator ==(StyleEnum<T> lhs, StyleEnum<T> rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && UnsafeUtility.EnumEquals(lhs.m_Value, rhs.m_Value);
		}

		public static bool operator !=(StyleEnum<T> lhs, StyleEnum<T> rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleEnum<T>(StyleKeyword keyword)
		{
			return new StyleEnum<T>(keyword);
		}

		public static implicit operator StyleEnum<T>(T v)
		{
			return new StyleEnum<T>(v);
		}

		public bool Equals(StyleEnum<T> other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleEnum<T> other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (UnsafeUtility.EnumToInt(m_Value) * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	public struct StyleFloat : IStyleValue<float>, IEquatable<StyleFloat>
	{
		private float m_Value;

		private StyleKeyword m_Keyword;

		public float value
		{
			get
			{
				return (m_Keyword == StyleKeyword.Undefined) ? m_Value : 0f;
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleFloat(float v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleFloat(StyleKeyword keyword)
			: this(0f, keyword)
		{
		}

		internal StyleFloat(float v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static bool operator ==(StyleFloat lhs, StyleFloat rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && lhs.m_Value == rhs.m_Value;
		}

		public static bool operator !=(StyleFloat lhs, StyleFloat rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleFloat(StyleKeyword keyword)
		{
			return new StyleFloat(keyword);
		}

		public static implicit operator StyleFloat(float v)
		{
			return new StyleFloat(v);
		}

		public bool Equals(StyleFloat other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleFloat other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value.GetHashCode() * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	public struct StyleFont : IStyleValue<Font>, IEquatable<StyleFont>
	{
		private Font m_Value;

		private StyleKeyword m_Keyword;

		public Font value
		{
			get
			{
				return (m_Keyword == StyleKeyword.Undefined) ? m_Value : null;
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleFont(Font v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleFont(StyleKeyword keyword)
			: this(null, keyword)
		{
		}

		internal StyleFont(Font v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static bool operator ==(StyleFont lhs, StyleFont rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && lhs.m_Value == rhs.m_Value;
		}

		public static bool operator !=(StyleFont lhs, StyleFont rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleFont(StyleKeyword keyword)
		{
			return new StyleFont(keyword);
		}

		public static implicit operator StyleFont(Font v)
		{
			return new StyleFont(v);
		}

		public bool Equals(StyleFont other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleFont other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (((m_Value != null) ? m_Value.GetHashCode() : 0) * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	public struct StyleFontDefinition : IStyleValue<FontDefinition>, IEquatable<StyleFontDefinition>
	{
		private StyleKeyword m_Keyword;

		private FontDefinition m_Value;

		public FontDefinition value
		{
			get
			{
				return (m_Keyword == StyleKeyword.Undefined) ? m_Value : default(FontDefinition);
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleFontDefinition(FontDefinition f)
			: this(f, StyleKeyword.Undefined)
		{
		}

		public StyleFontDefinition(FontAsset f)
			: this(f, StyleKeyword.Undefined)
		{
		}

		public StyleFontDefinition(Font f)
			: this(f, StyleKeyword.Undefined)
		{
		}

		public StyleFontDefinition(StyleKeyword keyword)
			: this(default(FontDefinition), keyword)
		{
		}

		internal StyleFontDefinition(object obj, StyleKeyword keyword)
			: this(FontDefinition.FromObject(obj), keyword)
		{
		}

		internal StyleFontDefinition(object obj)
			: this(FontDefinition.FromObject(obj), StyleKeyword.Undefined)
		{
		}

		internal StyleFontDefinition(FontAsset f, StyleKeyword keyword)
			: this(FontDefinition.FromSDFFont(f), keyword)
		{
		}

		internal StyleFontDefinition(Font f, StyleKeyword keyword)
			: this(FontDefinition.FromFont(f), keyword)
		{
		}

		internal StyleFontDefinition(GCHandle gcHandle, StyleKeyword keyword)
			: this(gcHandle.IsAllocated ? FontDefinition.FromObject(gcHandle.Target) : default(FontDefinition), keyword)
		{
		}

		internal StyleFontDefinition(FontDefinition f, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = f;
		}

		internal StyleFontDefinition(StyleFontDefinition sfd)
		{
			m_Keyword = sfd.keyword;
			m_Value = sfd.value;
		}

		public static implicit operator StyleFontDefinition(StyleKeyword keyword)
		{
			return new StyleFontDefinition(keyword);
		}

		public static implicit operator StyleFontDefinition(FontDefinition f)
		{
			return new StyleFontDefinition(f);
		}

		public bool Equals(StyleFontDefinition other)
		{
			return m_Keyword == other.m_Keyword && m_Value.Equals(other.m_Value);
		}

		public override bool Equals(object obj)
		{
			return obj is StyleFontDefinition other && Equals(other);
		}

		public override int GetHashCode()
		{
			return ((int)m_Keyword * 397) ^ m_Value.GetHashCode();
		}

		public static bool operator ==(StyleFontDefinition left, StyleFontDefinition right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(StyleFontDefinition left, StyleFontDefinition right)
		{
			return !left.Equals(right);
		}
	}
	public struct StyleInt : IStyleValue<int>, IEquatable<StyleInt>
	{
		private int m_Value;

		private StyleKeyword m_Keyword;

		public int value
		{
			get
			{
				return (m_Keyword == StyleKeyword.Undefined) ? m_Value : 0;
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleInt(int v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleInt(StyleKeyword keyword)
			: this(0, keyword)
		{
		}

		internal StyleInt(int v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static bool operator ==(StyleInt lhs, StyleInt rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && lhs.m_Value == rhs.m_Value;
		}

		public static bool operator !=(StyleInt lhs, StyleInt rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleInt(StyleKeyword keyword)
		{
			return new StyleInt(keyword);
		}

		public static implicit operator StyleInt(int v)
		{
			return new StyleInt(v);
		}

		public bool Equals(StyleInt other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleInt other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	public struct StyleLength : IStyleValue<Length>, IEquatable<StyleLength>
	{
		private Length m_Value;

		private StyleKeyword m_Keyword;

		public Length value
		{
			get
			{
				if (m_Keyword == StyleKeyword.Auto || m_Keyword == StyleKeyword.None || m_Keyword == StyleKeyword.Undefined)
				{
					return m_Value;
				}
				return default(Length);
			}
			set
			{
				if (value.IsAuto())
				{
					m_Keyword = StyleKeyword.Auto;
				}
				else if (value.IsNone())
				{
					m_Keyword = StyleKeyword.None;
				}
				else
				{
					m_Keyword = StyleKeyword.Undefined;
				}
				m_Value = value;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
				if (m_Keyword == StyleKeyword.Auto)
				{
					m_Value = Length.Auto();
				}
				else if (m_Keyword == StyleKeyword.None)
				{
					m_Value = Length.None();
				}
				else if (m_Keyword != StyleKeyword.Undefined)
				{
					m_Value = default(Length);
				}
			}
		}

		public StyleLength(float v)
			: this(new Length(v, LengthUnit.Pixel), StyleKeyword.Undefined)
		{
		}

		public StyleLength(Length v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleLength(StyleKeyword keyword)
			: this(default(Length), keyword)
		{
		}

		internal StyleLength(Length v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
			if (v.IsAuto())
			{
				m_Keyword = StyleKeyword.Auto;
			}
			else if (v.IsNone())
			{
				m_Keyword = StyleKeyword.None;
			}
		}

		public static bool operator ==(StyleLength lhs, StyleLength rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && lhs.m_Value == rhs.m_Value;
		}

		public static bool operator !=(StyleLength lhs, StyleLength rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleLength(StyleKeyword keyword)
		{
			return new StyleLength(keyword);
		}

		public static implicit operator StyleLength(float v)
		{
			return new StyleLength(v);
		}

		public static implicit operator StyleLength(Length v)
		{
			return new StyleLength(v);
		}

		public bool Equals(StyleLength other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleLength other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value.GetHashCode() * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	public struct StyleList<T> : IStyleValue<List<T>>, IEquatable<StyleList<T>>
	{
		private StyleKeyword m_Keyword;

		private List<T> m_Value;

		public List<T> value
		{
			get
			{
				return (m_Keyword == StyleKeyword.Undefined) ? m_Value : null;
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleList(List<T> v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleList(StyleKeyword keyword)
			: this(null, keyword)
		{
		}

		internal StyleList(List<T> v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static bool operator ==(StyleList<T> lhs, StyleList<T> rhs)
		{
			if (lhs.m_Keyword != rhs.m_Keyword)
			{
				return false;
			}
			List<T> list = lhs.m_Value;
			List<T> list2 = rhs.m_Value;
			if (list == list2)
			{
				return true;
			}
			if (list == null || list2 == null)
			{
				return false;
			}
			return list.Count == list2.Count && list.SequenceEqual(list2);
		}

		public static bool operator !=(StyleList<T> lhs, StyleList<T> rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleList<T>(StyleKeyword keyword)
		{
			return new StyleList<T>(keyword);
		}

		public static implicit operator StyleList<T>(List<T> v)
		{
			return new StyleList<T>(v);
		}

		public bool Equals(StyleList<T> other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleList<T> other && Equals(other);
		}

		public override int GetHashCode()
		{
			int num = 0;
			if (m_Value != null && m_Value.Count > 0)
			{
				num = EqualityComparer<T>.Default.GetHashCode(m_Value[0]);
				for (int i = 1; i < m_Value.Count; i++)
				{
					num = (num * 397) ^ EqualityComparer<T>.Default.GetHashCode(m_Value[i]);
				}
			}
			return (num * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	public struct StyleRotate : IStyleValue<Rotate>, IEquatable<StyleRotate>
	{
		private Rotate m_Value;

		private StyleKeyword m_Keyword;

		public Rotate value
		{
			get
			{
				StyleKeyword styleKeyword = m_Keyword;
				if (1 == 0)
				{
				}
				Rotate result = styleKeyword switch
				{
					StyleKeyword.Undefined => m_Value, 
					StyleKeyword.Null => Rotate.None(), 
					StyleKeyword.None => Rotate.None(), 
					StyleKeyword.Initial => Rotate.Initial(), 
					_ => throw new NotImplementedException(), 
				};
				if (1 == 0)
				{
				}
				return result;
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleRotate(Rotate v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleRotate(StyleKeyword keyword)
			: this(default(Rotate), keyword)
		{
		}

		internal StyleRotate(Rotate v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static bool operator ==(StyleRotate lhs, StyleRotate rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && lhs.m_Value == rhs.m_Value;
		}

		public static bool operator !=(StyleRotate lhs, StyleRotate rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleRotate(StyleKeyword keyword)
		{
			return new StyleRotate(keyword);
		}

		public static implicit operator StyleRotate(Rotate v)
		{
			return new StyleRotate(v);
		}

		public bool Equals(StyleRotate other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleRotate other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value.GetHashCode() * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	public struct StyleScale : IStyleValue<Scale>, IEquatable<StyleScale>
	{
		private Scale m_Value;

		private StyleKeyword m_Keyword;

		public Scale value
		{
			get
			{
				StyleKeyword styleKeyword = m_Keyword;
				if (1 == 0)
				{
				}
				Scale result = styleKeyword switch
				{
					StyleKeyword.Undefined => m_Value, 
					StyleKeyword.Null => Scale.None(), 
					StyleKeyword.None => Scale.None(), 
					StyleKeyword.Initial => Scale.Initial(), 
					_ => throw new NotImplementedException(), 
				};
				if (1 == 0)
				{
				}
				return result;
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleScale(Scale v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleScale(StyleKeyword keyword)
			: this(default(Scale), keyword)
		{
		}

		public StyleScale(Vector2 scale)
			: this(new Scale(scale))
		{
		}

		internal StyleScale(Scale v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static implicit operator StyleScale(Vector2 scale)
		{
			return new Scale(scale);
		}

		public static bool operator ==(StyleScale lhs, StyleScale rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && lhs.m_Value == rhs.m_Value;
		}

		public static bool operator !=(StyleScale lhs, StyleScale rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleScale(StyleKeyword keyword)
		{
			return new StyleScale(keyword);
		}

		public static implicit operator StyleScale(Scale v)
		{
			return new StyleScale(v);
		}

		public bool Equals(StyleScale other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleScale other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value.GetHashCode() * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	public struct StyleTranslate : IStyleValue<Translate>, IEquatable<StyleTranslate>
	{
		private Translate m_Value;

		private StyleKeyword m_Keyword;

		public Translate value
		{
			get
			{
				StyleKeyword styleKeyword = m_Keyword;
				if (1 == 0)
				{
				}
				Translate result = styleKeyword switch
				{
					StyleKeyword.Undefined => m_Value, 
					StyleKeyword.Null => Translate.None(), 
					StyleKeyword.None => Translate.None(), 
					StyleKeyword.Initial => Translate.None(), 
					_ => throw new NotImplementedException(), 
				};
				if (1 == 0)
				{
				}
				return result;
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleTranslate(Translate v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleTranslate(StyleKeyword keyword)
			: this(default(Translate), keyword)
		{
		}

		internal StyleTranslate(Translate v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static bool operator ==(StyleTranslate lhs, StyleTranslate rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && lhs.m_Value == rhs.m_Value;
		}

		public static bool operator !=(StyleTranslate lhs, StyleTranslate rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleTranslate(StyleKeyword keyword)
		{
			return new StyleTranslate(keyword);
		}

		public static implicit operator StyleTranslate(Translate v)
		{
			return new StyleTranslate(v);
		}

		public bool Equals(StyleTranslate other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleTranslate other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value.GetHashCode() * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	public struct StyleTextShadow : IStyleValue<TextShadow>, IEquatable<StyleTextShadow>
	{
		private StyleKeyword m_Keyword;

		private TextShadow m_Value;

		public TextShadow value
		{
			get
			{
				return (m_Keyword == StyleKeyword.Undefined) ? m_Value : default(TextShadow);
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleTextShadow(TextShadow v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleTextShadow(StyleKeyword keyword)
			: this(default(TextShadow), keyword)
		{
		}

		internal StyleTextShadow(TextShadow v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static bool operator ==(StyleTextShadow lhs, StyleTextShadow rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && lhs.m_Value == rhs.m_Value;
		}

		public static bool operator !=(StyleTextShadow lhs, StyleTextShadow rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleTextShadow(StyleKeyword keyword)
		{
			return new StyleTextShadow(keyword);
		}

		public static implicit operator StyleTextShadow(TextShadow v)
		{
			return new StyleTextShadow(v);
		}

		public bool Equals(StyleTextShadow other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is StyleTextShadow styleTextShadow))
			{
				return false;
			}
			return styleTextShadow == this;
		}

		public override int GetHashCode()
		{
			int num = 917506989;
			num = num * -1521134295 + m_Keyword.GetHashCode();
			return num * -1521134295 + m_Value.GetHashCode();
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	public struct StyleTransformOrigin : IStyleValue<TransformOrigin>, IEquatable<StyleTransformOrigin>
	{
		private TransformOrigin m_Value;

		private StyleKeyword m_Keyword;

		public TransformOrigin value
		{
			get
			{
				StyleKeyword styleKeyword = m_Keyword;
				if (1 == 0)
				{
				}
				TransformOrigin result = styleKeyword switch
				{
					StyleKeyword.Undefined => m_Value, 
					StyleKeyword.Null => TransformOrigin.Initial(), 
					StyleKeyword.None => TransformOrigin.Initial(), 
					StyleKeyword.Initial => TransformOrigin.Initial(), 
					_ => throw new NotImplementedException(), 
				};
				if (1 == 0)
				{
				}
				return result;
			}
			set
			{
				m_Value = value;
				m_Keyword = StyleKeyword.Undefined;
			}
		}

		public StyleKeyword keyword
		{
			get
			{
				return m_Keyword;
			}
			set
			{
				m_Keyword = value;
			}
		}

		public StyleTransformOrigin(TransformOrigin v)
			: this(v, StyleKeyword.Undefined)
		{
		}

		public StyleTransformOrigin(StyleKeyword keyword)
			: this(default(TransformOrigin), keyword)
		{
		}

		internal StyleTransformOrigin(TransformOrigin v, StyleKeyword keyword)
		{
			m_Keyword = keyword;
			m_Value = v;
		}

		public static bool operator ==(StyleTransformOrigin lhs, StyleTransformOrigin rhs)
		{
			return lhs.m_Keyword == rhs.m_Keyword && lhs.m_Value == rhs.m_Value;
		}

		public static bool operator !=(StyleTransformOrigin lhs, StyleTransformOrigin rhs)
		{
			return !(lhs == rhs);
		}

		public static implicit operator StyleTransformOrigin(StyleKeyword keyword)
		{
			return new StyleTransformOrigin(keyword);
		}

		public static implicit operator StyleTransformOrigin(TransformOrigin v)
		{
			return new StyleTransformOrigin(v);
		}

		public bool Equals(StyleTransformOrigin other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is StyleTransformOrigin other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value.GetHashCode() * 397) ^ (int)m_Keyword;
		}

		public override string ToString()
		{
			return this.DebugString();
		}
	}
	internal interface IStyleValue<T>
	{
		T value { get; set; }

		StyleKeyword keyword { get; set; }
	}
	public enum StyleKeyword
	{
		Undefined,
		Null,
		Auto,
		None,
		Initial
	}
	internal static class StyleValueExtensions
	{
		internal static string DebugString<T>(this IStyleValue<T> styleValue)
		{
			return (styleValue.keyword != StyleKeyword.Undefined) ? $"{styleValue.keyword}" : $"{styleValue.value}";
		}

		internal static YogaValue ToYogaValue(this Length length)
		{
			if (length.IsAuto())
			{
				return YogaValue.Auto();
			}
			if (length.IsNone())
			{
				return float.NaN;
			}
			switch (length.unit)
			{
			case LengthUnit.Pixel:
				return YogaValue.Point(length.value);
			case LengthUnit.Percent:
				return YogaValue.Percent(length.value);
			default:
				Debug.LogAssertion($"Unexpected unit '{length.unit}'");
				return float.NaN;
			}
		}

		internal static Length ToLength(this StyleKeyword keyword)
		{
			switch (keyword)
			{
			case StyleKeyword.Auto:
				return Length.Auto();
			case StyleKeyword.None:
				return Length.None();
			default:
				Debug.LogAssertion("Unexpected StyleKeyword '" + keyword.ToString() + "'");
				return default(Length);
			}
		}

		internal static Rotate ToRotate(this StyleKeyword keyword)
		{
			StyleKeyword styleKeyword = keyword;
			StyleKeyword styleKeyword2 = styleKeyword;
			if (styleKeyword2 == StyleKeyword.None)
			{
				return Rotate.None();
			}
			Debug.LogAssertion("Unexpected StyleKeyword '" + keyword.ToString() + "'");
			return default(Rotate);
		}

		internal static Scale ToScale(this StyleKeyword keyword)
		{
			StyleKeyword styleKeyword = keyword;
			StyleKeyword styleKeyword2 = styleKeyword;
			if (styleKeyword2 == StyleKeyword.None)
			{
				return Scale.None();
			}
			Debug.LogAssertion("Unexpected StyleKeyword '" + keyword.ToString() + "'");
			return default(Scale);
		}

		internal static Translate ToTranslate(this StyleKeyword keyword)
		{
			StyleKeyword styleKeyword = keyword;
			StyleKeyword styleKeyword2 = styleKeyword;
			if (styleKeyword2 == StyleKeyword.None)
			{
				return Translate.None();
			}
			Debug.LogAssertion("Unexpected StyleKeyword '" + keyword.ToString() + "'");
			return default(Translate);
		}

		internal static Length ToLength(this StyleLength styleLength)
		{
			StyleKeyword keyword = styleLength.keyword;
			StyleKeyword styleKeyword = keyword;
			if ((uint)(styleKeyword - 2) <= 1u)
			{
				return styleLength.keyword.ToLength();
			}
			return styleLength.value;
		}

		internal static void CopyFrom<T>(this List<T> list, List<T> other)
		{
			list.Clear();
			list.AddRange(other);
		}
	}
	public enum TimeUnit
	{
		Second,
		Millisecond
	}
	public struct TimeValue : IEquatable<TimeValue>
	{
		private float m_Value;

		private TimeUnit m_Unit;

		public float value
		{
			get
			{
				return m_Value;
			}
			set
			{
				m_Value = value;
			}
		}

		public TimeUnit unit
		{
			get
			{
				return m_Unit;
			}
			set
			{
				m_Unit = value;
			}
		}

		public TimeValue(float value)
			: this(value, TimeUnit.Second)
		{
		}

		public TimeValue(float value, TimeUnit unit)
		{
			m_Value = value;
			m_Unit = unit;
		}

		public static implicit operator TimeValue(float value)
		{
			return new TimeValue(value, TimeUnit.Second);
		}

		public static bool operator ==(TimeValue lhs, TimeValue rhs)
		{
			return lhs.m_Value == rhs.m_Value && lhs.m_Unit == rhs.m_Unit;
		}

		public static bool operator !=(TimeValue lhs, TimeValue rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(TimeValue other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is TimeValue other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_Value.GetHashCode() * 397) ^ (int)m_Unit;
		}

		public override string ToString()
		{
			string text = value.ToString(CultureInfo.InvariantCulture.NumberFormat);
			string text2 = string.Empty;
			switch (unit)
			{
			case TimeUnit.Second:
				text2 = "s";
				break;
			case TimeUnit.Millisecond:
				text2 = "ms";
				break;
			}
			return text + text2;
		}
	}
	public struct TransformOrigin : IEquatable<TransformOrigin>
	{
		private Length m_X;

		private Length m_Y;

		private float m_Z;

		public Length x
		{
			get
			{
				return m_X;
			}
			set
			{
				m_X = value;
			}
		}

		public Length y
		{
			get
			{
				return m_Y;
			}
			set
			{
				m_Y = value;
			}
		}

		public float z
		{
			get
			{
				return m_Z;
			}
			set
			{
				m_Z = value;
			}
		}

		public TransformOrigin(Length x, Length y, float z)
		{
			m_X = x;
			m_Y = y;
			m_Z = z;
		}

		public TransformOrigin(Length x, Length y)
			: this(x, y, 0f)
		{
		}

		public static TransformOrigin Initial()
		{
			return new TransformOrigin(Length.Percent(50f), Length.Percent(50f), 0f);
		}

		public static bool operator ==(TransformOrigin lhs, TransformOrigin rhs)
		{
			return lhs.m_X == rhs.m_X && lhs.m_Y == rhs.m_Y && lhs.m_Z == rhs.m_Z;
		}

		public static bool operator !=(TransformOrigin lhs, TransformOrigin rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(TransformOrigin other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is TransformOrigin other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_X.GetHashCode() * 793) ^ (m_Y.GetHashCode() * 791) ^ (m_Z.GetHashCode() * 571);
		}

		public override string ToString()
		{
			string text = m_Z.ToString(CultureInfo.InvariantCulture.NumberFormat);
			return m_X.ToString() + " " + m_Y.ToString() + " " + text;
		}
	}
	public struct Translate : IEquatable<Translate>
	{
		private Length m_X;

		private Length m_Y;

		private float m_Z;

		private bool m_isNone;

		public Length x
		{
			get
			{
				return m_X;
			}
			set
			{
				m_X = value;
			}
		}

		public Length y
		{
			get
			{
				return m_Y;
			}
			set
			{
				m_Y = value;
			}
		}

		public float z
		{
			get
			{
				return m_Z;
			}
			set
			{
				m_Z = value;
			}
		}

		public Translate(Length x, Length y, float z)
		{
			m_X = x;
			m_Y = y;
			m_Z = z;
			m_isNone = false;
		}

		public Translate(Length x, Length y)
			: this(x, y, 0f)
		{
		}

		public static Translate None()
		{
			return new Translate
			{
				m_isNone = true
			};
		}

		internal bool IsNone()
		{
			return m_isNone;
		}

		public static bool operator ==(Translate lhs, Translate rhs)
		{
			return lhs.m_X == rhs.m_X && lhs.m_Y == rhs.m_Y && lhs.m_Z == rhs.m_Z && lhs.m_isNone == rhs.m_isNone;
		}

		public static bool operator !=(Translate lhs, Translate rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(Translate other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			return obj is Translate other && Equals(other);
		}

		public override int GetHashCode()
		{
			return (m_X.GetHashCode() * 793) ^ (m_Y.GetHashCode() * 791) ^ (m_Z.GetHashCode() * 571);
		}

		public override string ToString()
		{
			string text = m_Z.ToString(CultureInfo.InvariantCulture.NumberFormat);
			return m_X.ToString() + " " + m_Y.ToString() + " " + text;
		}
	}
	public enum Position
	{
		Relative,
		Absolute
	}
	public enum Overflow
	{
		Visible,
		Hidden
	}
	internal enum OverflowInternal
	{
		Visible,
		Hidden,
		Scroll
	}
	public enum OverflowClipBox
	{
		PaddingBox,
		ContentBox
	}
	public enum FlexDirection
	{
		Column,
		ColumnReverse,
		Row,
		RowReverse
	}
	public enum Wrap
	{
		NoWrap,
		Wrap,
		WrapReverse
	}
	public enum Align
	{
		Auto,
		FlexStart,
		Center,
		FlexEnd,
		Stretch
	}
	public enum Justify
	{
		FlexStart,
		Center,
		FlexEnd,
		SpaceBetween,
		SpaceAround
	}
	public enum TextOverflowPosition
	{
		End,
		Start,
		Middle
	}
	public enum TextOverflow
	{
		Clip,
		Ellipsis
	}
	public enum TransformOriginOffset
	{
		Left = 1,
		Right,
		Top,
		Bottom,
		Center
	}
	public enum Visibility
	{
		Visible,
		Hidden
	}
	public enum WhiteSpace
	{
		Normal,
		NoWrap
	}
	public enum DisplayStyle
	{
		Flex,
		None
	}
	public enum BackgroundPositionKeyword
	{
		Center,
		Top,
		Bottom,
		Left,
		Right
	}
	public enum Repeat
	{
		NoRepeat,
		Space,
		Round,
		Repeat
	}
	internal enum RepeatXY
	{
		RepeatX,
		RepeatY
	}
	public enum BackgroundSizeType
	{
		Length,
		Cover,
		Contain
	}
	internal interface IStylePainter
	{
		VisualElement visualElement { get; }

		MeshWriteData DrawMesh(int vertexCount, int indexCount, Texture texture, Material material, MeshGenerationContext.MeshFlags flags);

		void DrawText(TextElement te);

		void DrawText(string text, Vector2 pos, float fontSize, Color color, FontAsset font);

		void DrawRectangle(MeshGenerationContextUtils.RectangleParams rectParams);

		void DrawBorder(MeshGenerationContextUtils.BorderParams borderParams);

		void DrawImmediate(Action callback, bool cullingEnabled);

		void DrawVectorImage(VectorImage vectorImage, Vector2 pos, Angle rotationAngle, Vector2 scale);
	}
	internal struct CursorPositionStylePainterParameters
	{
		public Rect rect;

		public string text;

		public Font font;

		public int fontSize;

		public FontStyle fontStyle;

		public TextAnchor anchor;

		public float wordWrapWidth;

		public bool richText;

		public int cursorIndex;

		public static CursorPositionStylePainterParameters GetDefault(VisualElement ve, string text)
		{
			ComputedStyle computedStyle = ve.computedStyle;
			return new CursorPositionStylePainterParameters
			{
				rect = ve.contentRect,
				text = text,
				font = TextUtilities.GetFont(ve),
				fontSize = (int)computedStyle.fontSize.value,
				fontStyle = computedStyle.unityFontStyleAndWeight,
				anchor = computedStyle.unityTextAlign,
				wordWrapWidth = ((computedStyle.whiteSpace == WhiteSpace.Normal) ? ve.contentRect.width : 0f),
				richText = false,
				cursorIndex = 0
			};
		}

		internal TextNativeSettings GetTextNativeSettings(float scaling)
		{
			return new TextNativeSettings
			{
				text = text,
				font = font,
				size = fontSize,
				scaling = scaling,
				style = fontStyle,
				color = Color.white,
				anchor = anchor,
				wordWrap = true,
				wordWrapWidth = wordWrapWidth,
				richText = richText
			};
		}
	}
	internal interface IStylePropertyAnimations
	{
		int runningAnimationCount { get; set; }

		int completedAnimationCount { get; set; }

		bool Start(StylePropertyId id, float from, float to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool Start(StylePropertyId id, int from, int to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool Start(StylePropertyId id, Length from, Length to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool Start(StylePropertyId id, Color from, Color to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool StartEnum(StylePropertyId id, int from, int to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool Start(StylePropertyId id, Background from, Background to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool Start(StylePropertyId id, FontDefinition from, FontDefinition to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool Start(StylePropertyId id, Font from, Font to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool Start(StylePropertyId id, TextShadow from, TextShadow to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool Start(StylePropertyId id, Scale from, Scale to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool Start(StylePropertyId id, Translate from, Translate to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool Start(StylePropertyId id, Rotate from, Rotate to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool Start(StylePropertyId id, TransformOrigin from, TransformOrigin to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool Start(StylePropertyId id, BackgroundPosition from, BackgroundPosition to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool Start(StylePropertyId id, BackgroundRepeat from, BackgroundRepeat to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool Start(StylePropertyId id, BackgroundSize from, BackgroundSize to, int durationMs, int delayMs, Func<float, float> easingCurve);

		bool HasRunningAnimation(StylePropertyId id);

		void UpdateAnimation(StylePropertyId id);

		void GetAllAnimations(List<StylePropertyId> outPropertyIds);

		void CancelAnimation(StylePropertyId id);

		void CancelAllAnimations();
	}
	internal interface IStylePropertyAnimationSystem
	{
		bool StartTransition(VisualElement owner, StylePropertyId prop, float startValue, float endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		bool StartTransition(VisualElement owner, StylePropertyId prop, int startValue, int endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		bool StartTransition(VisualElement owner, StylePropertyId prop, Length startValue, Length endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		bool StartTransition(VisualElement owner, StylePropertyId prop, Color startValue, Color endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		bool StartAnimationEnum(VisualElement owner, StylePropertyId prop, int startValue, int endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		bool StartTransition(VisualElement owner, StylePropertyId prop, Background startValue, Background endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		bool StartTransition(VisualElement owner, StylePropertyId prop, FontDefinition startValue, FontDefinition endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		bool StartTransition(VisualElement owner, StylePropertyId prop, Font startValue, Font endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		bool StartTransition(VisualElement owner, StylePropertyId prop, TextShadow startValue, TextShadow endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		bool StartTransition(VisualElement owner, StylePropertyId prop, Scale startValue, Scale endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		bool StartTransition(VisualElement owner, StylePropertyId prop, TransformOrigin startValue, TransformOrigin endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		bool StartTransition(VisualElement owner, StylePropertyId prop, Translate startValue, Translate endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		bool StartTransition(VisualElement owner, StylePropertyId prop, Rotate startValue, Rotate endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		bool StartTransition(VisualElement owner, StylePropertyId prop, BackgroundPosition startValue, BackgroundPosition endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		bool StartTransition(VisualElement owner, StylePropertyId prop, BackgroundRepeat startValue, BackgroundRepeat endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		bool StartTransition(VisualElement owner, StylePropertyId prop, BackgroundSize startValue, BackgroundSize endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve);

		void CancelAllAnimations();

		void CancelAllAnimations(VisualElement owner);

		void CancelAnimation(VisualElement owner, StylePropertyId id);

		bool HasRunningAnimation(VisualElement owner, StylePropertyId id);

		void UpdateAnimation(VisualElement owner, StylePropertyId id);

		void GetAllAnimations(VisualElement owner, List<StylePropertyId> propertyIds);

		void Update();
	}
	internal class StylePropertyAnimationSystem : IStylePropertyAnimationSystem
	{
		[Flags]
		private enum TransitionState
		{
			None = 0,
			Running = 1,
			Started = 2,
			Ended = 4,
			Canceled = 8
		}

		private struct AnimationDataSet<TTimingData, TStyleData>
		{
			private const int InitialSize = 2;

			public VisualElement[] elements;

			public StylePropertyId[] properties;

			public TTimingData[] timing;

			public TStyleData[] style;

			public int count;

			private Dictionary<ElementPropertyPair, int> indices;

			private int capacity
			{
				get
				{
					return elements.Length;
				}
				set
				{
					Array.Resize(ref elements, value);
					Array.Resize(ref properties, value);
					Array.Resize(ref timing, value);
					Array.Resize(ref style, value);
				}
			}

			private void LocalInit()
			{
				elements = new VisualElement[2];
				properties = new StylePropertyId[2];
				timing = new TTimingData[2];
				style = new TStyleData[2];
				indices = new Dictionary<ElementPropertyPair, int>(ElementPropertyPair.Comparer);
			}

			public static AnimationDataSet<TTimingData, TStyleData> Create()
			{
				AnimationDataSet<TTimingData, TStyleData> result = default(AnimationDataSet<TTimingData, TStyleData>);
				result.LocalInit();
				return result;
			}

			public bool IndexOf(VisualElement ve, StylePropertyId prop, out int index)
			{
				return indices.TryGetValue(new ElementPropertyPair(ve, prop), out index);
			}

			public void Add(VisualElement owner, StylePropertyId prop, TTimingData timingData, TStyleData styleData)
			{
				if (count >= capacity)
				{
					capacity *= 2;
				}
				int num = count++;
				elements[num] = owner;
				properties[num] = prop;
				timing[num] = timingData;
				style[num] = styleData;
				indices.Add(new ElementPropertyPair(owner, prop), num);
			}

			public void Remove(int cancelledIndex)
			{
				int num = --count;
				indices.Remove(new ElementPropertyPair(elements[cancelledIndex], properties[cancelledIndex]));
				if (cancelledIndex != num)
				{
					VisualElement element = (elements[cancelledIndex] = elements[num]);
					StylePropertyId property = (properties[cancelledIndex] = properties[num]);
					timing[cancelledIndex] = timing[num];
					style[cancelledIndex] = style[num];
					indices[new ElementPropertyPair(element, property)] = cancelledIndex;
				}
				elements[num] = null;
				properties[num] = StylePropertyId.Unknown;
				timing[num] = default(TTimingData);
				style[num] = default(TStyleData);
			}

			public void Replace(int index, TTimingData timingData, TStyleData styleData)
			{
				timing[index] = timingData;
				style[index] = styleData;
			}

			public void RemoveAll(VisualElement ve)
			{
				int num = count;
				for (int num2 = num - 1; num2 >= 0; num2--)
				{
					if (elements[num2] == ve)
					{
						Remove(num2);
					}
				}
			}

			public void RemoveAll()
			{
				capacity = 2;
				int length = Mathf.Min(count, capacity);
				Array.Clear(elements, 0, length);
				Array.Clear(properties, 0, length);
				Array.Clear(timing, 0, length);
				Array.Clear(style, 0, length);
				count = 0;
				indices.Clear();
			}

			public void GetActivePropertiesForElement(VisualElement ve, List<StylePropertyId> outProperties)
			{
				int num = count;
				for (int num2 = num - 1; num2 >= 0; num2--)
				{
					if (elements[num2] == ve)
					{
						outProperties.Add(properties[num2]);
					}
				}
			}
		}

		private struct ElementPropertyPair
		{
			private class EqualityComparer : IEqualityComparer<ElementPropertyPair>
			{
				public bool Equals(ElementPropertyPair x, ElementPropertyPair y)
				{
					return x.element == y.element && x.property == y.property;
				}

				public int GetHashCode(ElementPropertyPair obj)
				{
					return (obj.element.GetHashCode() * 397) ^ (int)obj.property;
				}
			}

			public static readonly IEqualityComparer<ElementPropertyPair> Comparer = new EqualityComparer();

			public readonly VisualElement element;

			public readonly StylePropertyId property;

			public ElementPropertyPair(VisualElement element, StylePropertyId property)
			{
				this.element = element;
				this.property = property;
			}
		}

		private abstract class Values
		{
			public abstract void CancelAllAnimations();

			public abstract void CancelAllAnimations(VisualElement ve);

			public abstract void CancelAnimation(VisualElement ve, StylePropertyId id);

			public abstract bool HasRunningAnimation(VisualElement ve, StylePropertyId id);

			public abstract void UpdateAnimation(VisualElement ve, StylePropertyId id);

			public abstract void GetAllAnimations(VisualElement ve, List<StylePropertyId> outPropertyIds);

			public abstract void Update(long currentTimeMs);

			protected abstract void UpdateValues();

			protected abstract void UpdateComputedStyle();

			protected abstract void UpdateComputedStyle(int i);
		}

		private abstract class Values<T> : Values
		{
			private class TransitionEventsFrameState
			{
				private static readonly UnityEngine.Pool.ObjectPool<Queue<EventBase>> k_EventQueuePool = new UnityEngine.Pool.ObjectPool<Queue<EventBase>>(() => new Queue<EventBase>(4));

				public readonly Dictionary<ElementPropertyPair, TransitionState> elementPropertyStateDelta = new Dictionary<ElementPropertyPair, TransitionState>(ElementPropertyPair.Comparer);

				public readonly Dictionary<ElementPropertyPair, Queue<EventBase>> elementPropertyQueuedEvents = new Dictionary<ElementPropertyPair, Queue<EventBase>>(ElementPropertyPair.Comparer);

				public IPanel panel;

				private int m_ChangesCount;

				public static Queue<EventBase> GetPooledQueue()
				{
					return k_EventQueuePool.Get();
				}

				public void RegisterChange()
				{
					m_ChangesCount++;
				}

				public void UnregisterChange()
				{
					m_ChangesCount--;
				}

				public bool StateChanged()
				{
					return m_ChangesCount > 0;
				}

				public void Clear()
				{
					foreach (KeyValuePair<ElementPropertyPair, Queue<EventBase>> elementPropertyQueuedEvent in elementPropertyQueuedEvents)
					{
						elementPropertyQueuedEvent.Value.Clear();
						k_EventQueuePool.Release(elementPropertyQueuedEvent.Value);
					}
					elementPropertyQueuedEvents.Clear();
					elementPropertyStateDelta.Clear();
					panel = null;
					m_ChangesCount = 0;
				}
			}

			public struct TimingData
			{
				public long startTimeMs;

				public int durationMs;

				public Func<float, float> easingCurve;

				public float easedProgress;

				public float reversingShorteningFactor;

				public bool isStarted;

				public int delayMs;
			}

			public struct StyleData
			{
				public T startValue;

				public T endValue;

				public T reversingAdjustedStartValue;

				public T currentValue;
			}

			[StructLayout(LayoutKind.Sequential, Size = 1)]
			public struct EmptyData
			{
				public static EmptyData Default = default(EmptyData);
			}

			private long m_CurrentTimeMs = 0L;

			private TransitionEventsFrameState m_CurrentFrameEventsState = new TransitionEventsFrameState();

			private TransitionEventsFrameState m_NextFrameEventsState = new TransitionEventsFrameState();

			public AnimationDataSet<TimingData, StyleData> running;

			public AnimationDataSet<EmptyData, T> completed;

			public bool isEmpty => running.count + completed.count == 0;

			public abstract Func<T, T, bool> SameFunc { get; }

			protected virtual bool ConvertUnits(VisualElement owner, StylePropertyId prop, ref T a, ref T b)
			{
				return true;
			}

			protected Values()
			{
				running = AnimationDataSet<TimingData, StyleData>.Create();
				completed = AnimationDataSet<EmptyData, T>.Create();
				m_CurrentTimeMs = Panel.TimeSinceStartupMs();
			}

			private void SwapFrameStates()
			{
				TransitionEventsFrameState currentFrameEventsState = m_CurrentFrameEventsState;
				m_CurrentFrameEventsState = m_NextFrameEventsState;
				m_NextFrameEventsState = currentFrameEventsState;
			}

			private void QueueEvent(EventBase evt, ElementPropertyPair epp)
			{
				evt.target = epp.element;
				if (!m_NextFrameEventsState.elementPropertyQueuedEvents.TryGetValue(epp, out var value))
				{
					value = TransitionEventsFrameState.GetPooledQueue();
					m_NextFrameEventsState.elementPropertyQueuedEvents.Add(epp, value);
				}
				value.Enqueue(evt);
				if (m_NextFrameEventsState.panel == null)
				{
					m_NextFrameEventsState.panel = epp.element.panel;
				}
				m_NextFrameEventsState.RegisterChange();
			}

			private void ClearEventQueue(ElementPropertyPair epp)
			{
				if (m_NextFrameEventsState.elementPropertyQueuedEvents.TryGetValue(epp, out var value))
				{
					while (value.Count > 0)
					{
						value.Dequeue().Dispose();
						m_NextFrameEventsState.UnregisterChange();
					}
				}
			}

			private void QueueTransitionRunEvent(VisualElement ve, int runningIndex)
			{
				if (ve.HasParentEventCallbacksOrDefaultActions(EventCategory.StyleTransition))
				{
					StylePropertyId stylePropertyId = running.properties[runningIndex];
					ElementPropertyPair elementPropertyPair = new ElementPropertyPair(ve, stylePropertyId);
					if (m_NextFrameEventsState.elementPropertyStateDelta.TryGetValue(elementPropertyPair, out var value))
					{
						m_NextFrameEventsState.elementPropertyStateDelta[elementPropertyPair] = value | TransitionState.Running;
					}
					else
					{
						m_NextFrameEventsState.elementPropertyStateDelta.Add(elementPropertyPair, TransitionState.Running);
					}
					ref TimingData reference = ref running.timing[runningIndex];
					int num = ((reference.delayMs < 0) ? Mathf.Min(Mathf.Max(-reference.delayMs, 0), reference.durationMs) : 0);
					TransitionRunEvent pooled = TransitionEventBase<TransitionRunEvent>.GetPooled(new StylePropertyName(stylePropertyId), (float)num / 1000f);
					QueueEvent(pooled, elementPropertyPair);
				}
			}

			private void QueueTransitionStartEvent(VisualElement ve, int runningIndex)
			{
				if (ve.HasParentEventCallbacksOrDefaultActions(EventCategory.StyleTransition))
				{
					StylePropertyId stylePropertyId = running.properties[runningIndex];
					ElementPropertyPair elementPropertyPair = new ElementPropertyPair(ve, stylePropertyId);
					if (m_NextFrameEventsState.elementPropertyStateDelta.TryGetValue(elementPropertyPair, out var value))
					{
						m_NextFrameEventsState.elementPropertyStateDelta[elementPropertyPair] = value | TransitionState.Started;
					}
					else
					{
						m_NextFrameEventsState.elementPropertyStateDelta.Add(elementPropertyPair, TransitionState.Started);
					}
					ref TimingData reference = ref running.timing[runningIndex];
					int num = ((reference.delayMs < 0) ? Mathf.Min(Mathf.Max(-reference.delayMs, 0), reference.durationMs) : 0);
					TransitionStartEvent pooled = TransitionEventBase<TransitionStartEvent>.GetPooled(new StylePropertyName(stylePropertyId), (float)num / 1000f);
					QueueEvent(pooled, elementPropertyPair);
				}
			}

			private void QueueTransitionEndEvent(VisualElement ve, int runningIndex)
			{
				if (ve.HasParentEventCallbacksOrDefaultActions(EventCategory.StyleTransition))
				{
					StylePropertyId stylePropertyId = running.properties[runningIndex];
					ElementPropertyPair elementPropertyPair = new ElementPropertyPair(ve, stylePropertyId);
					if (m_NextFrameEventsState.elementPropertyStateDelta.TryGetValue(elementPropertyPair, out var value))
					{
						m_NextFrameEventsState.elementPropertyStateDelta[elementPropertyPair] = value | TransitionState.Ended;
					}
					else
					{
						m_NextFrameEventsState.elementPropertyStateDelta.Add(elementPropertyPair, TransitionState.Ended);
					}
					ref TimingData reference = ref running.timing[runningIndex];
					TransitionEndEvent pooled = TransitionEventBase<TransitionEndEvent>.GetPooled(new StylePropertyName(stylePropertyId), (float)reference.durationMs / 1000f);
					QueueEvent(pooled, elementPropertyPair);
				}
			}

			private void QueueTransitionCancelEvent(VisualElement ve, int runningIndex, long panelElapsedMs)
			{
				if (!ve.HasParentEventCallbacksOrDefaultActions(EventCategory.StyleTransition))
				{
					return;
				}
				StylePropertyId stylePropertyId = running.properties[runningIndex];
				ElementPropertyPair elementPropertyPair = new ElementPropertyPair(ve, stylePropertyId);
				bool flag;
				if (m_NextFrameEventsState.elementPropertyStateDelta.TryGetValue(elementPropertyPair, out var value))
				{
					if (value == TransitionState.None || (value & TransitionState.Canceled) == TransitionState.Canceled)
					{
						m_NextFrameEventsState.elementPropertyStateDelta[elementPropertyPair] = TransitionState.Canceled;
						ClearEventQueue(elementPropertyPair);
						flag = true;
					}
					else
					{
						m_NextFrameEventsState.elementPropertyStateDelta[elementPropertyPair] = TransitionState.None;
						ClearEventQueue(elementPropertyPair);
						flag = false;
					}
				}
				else
				{
					m_NextFrameEventsState.elementPropertyStateDelta.Add(elementPropertyPair, TransitionState.Canceled);
					flag = true;
				}
				if (flag)
				{
					ref TimingData reference = ref running.timing[runningIndex];
					long num = (reference.isStarted ? (panelElapsedMs - reference.startTimeMs) : 0);
					if (reference.delayMs < 0)
					{
						num = -reference.delayMs + num;
					}
					TransitionCancelEvent pooled = TransitionEventBase<TransitionCancelEvent>.GetPooled(new StylePropertyName(stylePropertyId), (float)num / 1000f);
					QueueEvent(pooled, elementPropertyPair);
				}
			}

			private void SendTransitionCancelEvent(VisualElement ve, int runningIndex, long panelElapsedMs)
			{
				if (!ve.HasParentEventCallbacksOrDefaultActions(EventBase<TransitionCancelEvent>.EventCategory))
				{
					return;
				}
				ref TimingData reference = ref running.timing[runningIndex];
				StylePropertyId stylePropertyId = running.properties[runningIndex];
				long num = (reference.isStarted ? (panelElapsedMs - reference.startTimeMs) : 0);
				if (reference.delayMs < 0)
				{
					num = -reference.delayMs + num;
				}
				using TransitionCancelEvent transitionCancelEvent = TransitionEventBase<TransitionCancelEvent>.GetPooled(new StylePropertyName(stylePropertyId), (float)num / 1000f);
				transitionCancelEvent.target = ve;
				ve.SendEvent(transitionCancelEvent);
			}

			public sealed override void CancelAllAnimations()
			{
				int count = running.count;
				if (count > 0)
				{
					using (new EventDispatcherGate(running.elements[0].panel.dispatcher))
					{
						for (int i = 0; i < count; i++)
						{
							VisualElement visualElement = running.elements[i];
							SendTransitionCancelEvent(visualElement, i, m_CurrentTimeMs);
							ForceComputedStyleEndValue(i);
							visualElement.styleAnimation.runningAnimationCount--;
						}
					}
					running.RemoveAll();
				}
				int count2 = completed.count;
				for (int j = 0; j < count2; j++)
				{
					VisualElement visualElement2 = completed.elements[j];
					visualElement2.styleAnimation.completedAnimationCount--;
				}
				completed.RemoveAll();
			}

			public sealed override void CancelAllAnimations(VisualElement ve)
			{
				int count = running.count;
				if (count > 0)
				{
					using (new EventDispatcherGate(running.elements[0].panel.dispatcher))
					{
						for (int i = 0; i < count; i++)
						{
							if (running.elements[i] == ve)
							{
								SendTransitionCancelEvent(ve, i, m_CurrentTimeMs);
								ForceComputedStyleEndValue(i);
								running.elements[i].styleAnimation.runningAnimationCount--;
							}
						}
					}
				}
				running.RemoveAll(ve);
				int count2 = completed.count;
				for (int j = 0; j < count2; j++)
				{
					if (completed.elements[j] == ve)
					{
						completed.elements[j].styleAnimation.completedAnimationCount--;
					}
				}
				completed.RemoveAll(ve);
			}

			public sealed override void CancelAnimation(VisualElement ve, StylePropertyId id)
			{
				if (running.IndexOf(ve, id, out var index))
				{
					QueueTransitionCancelEvent(ve, index, m_CurrentTimeMs);
					ForceComputedStyleEndValue(index);
					running.Remove(index);
					ve.styleAnimation.runningAnimationCount--;
				}
				if (completed.IndexOf(ve, id, out var index2))
				{
					completed.Remove(index2);
					ve.styleAnimation.completedAnimationCount--;
				}
			}

			public sealed override bool HasRunningAnimation(VisualElement ve, StylePropertyId id)
			{
				int index;
				return running.IndexOf(ve, id, out index);
			}

			public sealed override void UpdateAnimation(VisualElement ve, StylePropertyId id)
			{
				if (running.IndexOf(ve, id, out var index))
				{
					UpdateComputedStyle(index);
				}
			}

			public sealed override void GetAllAnimations(VisualElement ve, List<StylePropertyId> outPropertyIds)
			{
				running.GetActivePropertiesForElement(ve, outPropertyIds);
				completed.GetActivePropertiesForElement(ve, outPropertyIds);
			}

			private float ComputeReversingShorteningFactor(int oldIndex)
			{
				ref TimingData reference = ref running.timing[oldIndex];
				return Mathf.Clamp01(Mathf.Abs(1f - (1f - reference.easedProgress) * reference.reversingShorteningFactor));
			}

			private int ComputeReversingDuration(int newTransitionDurationMs, float newReversingShorteningFactor)
			{
				return Mathf.RoundToInt((float)newTransitionDurationMs * newReversingShorteningFactor);
			}

			private int ComputeReversingDelay(int delayMs, float newReversingShorteningFactor)
			{
				return (delayMs < 0) ? Mathf.RoundToInt((float)delayMs * newReversingShorteningFactor) : delayMs;
			}

			public bool StartTransition(VisualElement owner, StylePropertyId prop, T startValue, T endValue, int durationMs, int delayMs, Func<float, float> easingCurve, long currentTimeMs)
			{
				long startTimeMs = currentTimeMs + delayMs;
				TimingData timingData = new TimingData
				{
					startTimeMs = startTimeMs,
					durationMs = durationMs,
					easingCurve = easingCurve,
					reversingShorteningFactor = 1f,
					delayMs = delayMs
				};
				StyleData styleData = new StyleData
				{
					startValue = startValue,
					endValue = endValue,
					currentValue = startValue,
					reversingAdjustedStartValue = startValue
				};
				int num = Mathf.Max(0, durationMs) + delayMs;
				if (!ConvertUnits(owner, prop, ref styleData.startValue, ref styleData.endValue))
				{
					return false;
				}
				if (completed.IndexOf(owner, prop, out var index))
				{
					if (SameFunc(endValue, completed.style[index]))
					{
						return false;
					}
					if (num <= 0)
					{
						return false;
					}
					completed.Remove(index);
					owner.styleAnimation.completedAnimationCount--;
				}
				if (running.IndexOf(owner, prop, out var index2))
				{
					if (SameFunc(endValue, running.style[index2].endValue))
					{
						return false;
					}
					if (SameFunc(endValue, running.style[index2].currentValue))
					{
						QueueTransitionCancelEvent(owner, index2, currentTimeMs);
						running.Remove(index2);
						owner.styleAnimation.runningAnimationCount--;
						return false;
					}
					if (num <= 0)
					{
						QueueTransitionCancelEvent(owner, index2, currentTimeMs);
						running.Remove(index2);
						owner.styleAnimation.runningAnimationCount--;
						return false;
					}
					styleData.startValue = running.style[index2].currentValue;
					if (!ConvertUnits(owner, prop, ref styleData.startValue, ref styleData.endValue))
					{
						QueueTransitionCancelEvent(owner, index2, currentTimeMs);
						running.Remove(index2);
						owner.styleAnimation.runningAnimationCount--;
						return false;
					}
					styleData.currentValue = styleData.startValue;
					if (SameFunc(endValue, running.style[index2].reversingAdjustedStartValue))
					{
						float newReversingShorteningFactor = (timingData.reversingShorteningFactor = ComputeReversingShorteningFactor(index2));
						timingData.startTimeMs = currentTimeMs + ComputeReversingDelay(delayMs, newReversingShorteningFactor);
						timingData.durationMs = ComputeReversingDuration(durationMs, newReversingShorteningFactor);
						styleData.reversingAdjustedStartValue = running.style[index2].endValue;
					}
					running.timing[index2].isStarted = false;
					QueueTransitionCancelEvent(owner, index2, currentTimeMs);
					QueueTransitionRunEvent(owner, index2);
					running.Replace(index2, timingData, styleData);
					return true;
				}
				if (num <= 0)
				{
					return false;
				}
				if (SameFunc(startValue, endValue))
				{
					return false;
				}
				running.Add(owner, prop, timingData, styleData);
				owner.styleAnimation.runningAnimationCount++;
				QueueTransitionRunEvent(owner, running.count - 1);
				return true;
			}

			private void ForceComputedStyleEndValue(int runningIndex)
			{
				ref StyleData reference = ref running.style[runningIndex];
				reference.currentValue = reference.endValue;
				UpdateComputedStyle(runningIndex);
			}

			public sealed override void Update(long currentTimeMs)
			{
				m_CurrentTimeMs = currentTimeMs;
				UpdateProgress(currentTimeMs);
				UpdateValues();
				UpdateComputedStyle();
				if (m_NextFrameEventsState.StateChanged())
				{
					ProcessEventQueue();
				}
			}

			private void ProcessEventQueue()
			{
				SwapFrameStates();
				EventDispatcher d = m_CurrentFrameEventsState.panel?.dispatcher;
				using (new EventDispatcherGate(d))
				{
					foreach (KeyValuePair<ElementPropertyPair, Queue<EventBase>> elementPropertyQueuedEvent in m_CurrentFrameEventsState.elementPropertyQueuedEvents)
					{
						ElementPropertyPair key = elementPropertyQueuedEvent.Key;
						Queue<EventBase> value = elementPropertyQueuedEvent.Value;
						VisualElement element = elementPropertyQueuedEvent.Key.element;
						while (value.Count > 0)
						{
							EventBase eventBase = value.Dequeue();
							element.SendEvent(eventBase);
							eventBase.Dispose();
						}
					}
					m_CurrentFrameEventsState.Clear();
				}
			}

			private void UpdateProgress(long currentTimeMs)
			{
				int num = running.count;
				if (num <= 0)
				{
					return;
				}
				for (int i = 0; i < num; i++)
				{
					ref TimingData reference = ref running.timing[i];
					if (currentTimeMs < reference.startTimeMs)
					{
						reference.easedProgress = 0f;
					}
					else if (currentTimeMs >= reference.startTimeMs + reference.durationMs)
					{
						ref StyleData reference2 = ref running.style[i];
						ref VisualElement reference3 = ref running.elements[i];
						reference2.currentValue = reference2.endValue;
						UpdateComputedStyle(i);
						completed.Add(reference3, running.properties[i], EmptyData.Default, reference2.endValue);
						reference3.styleAnimation.runningAnimationCount--;
						reference3.styleAnimation.completedAnimationCount++;
						QueueTransitionEndEvent(reference3, i);
						running.Remove(i);
						i--;
						num--;
					}
					else
					{
						if (!reference.isStarted)
						{
							reference.isStarted = true;
							QueueTransitionStartEvent(running.elements[i], i);
						}
						float arg = (float)(currentTimeMs - reference.startTimeMs) / (float)reference.durationMs;
						reference.easedProgress = reference.easingCurve(arg);
					}
				}
			}
		}

		private class ValuesFloat : Values<float>
		{
			public override Func<float, float, bool> SameFunc { get; } = IsSame;

			private static bool IsSame(float a, float b)
			{
				return Mathf.Approximately(a, b);
			}

			private static float Lerp(float a, float b, float t)
			{
				return Mathf.LerpUnclamped(a, b, t);
			}

			protected sealed override void UpdateValues()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					ref TimingData reference = ref running.timing[i];
					ref StyleData reference2 = ref running.style[i];
					reference2.currentValue = Lerp(reference2.startValue, reference2.endValue, reference.easedProgress);
				}
			}

			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}
		}

		private class ValuesInt : Values<int>
		{
			public override Func<int, int, bool> SameFunc { get; } = IsSame;

			private static bool IsSame(int a, int b)
			{
				return a == b;
			}

			private static int Lerp(int a, int b, float t)
			{
				return Mathf.RoundToInt(Mathf.LerpUnclamped(a, b, t));
			}

			protected sealed override void UpdateValues()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					ref TimingData reference = ref running.timing[i];
					ref StyleData reference2 = ref running.style[i];
					reference2.currentValue = Lerp(reference2.startValue, reference2.endValue, reference.easedProgress);
				}
			}

			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}
		}

		private class ValuesLength : Values<Length>
		{
			public override Func<Length, Length, bool> SameFunc { get; } = IsSame;

			private static bool IsSame(Length a, Length b)
			{
				return a.unit == b.unit && Mathf.Approximately(a.value, b.value);
			}

			protected sealed override bool ConvertUnits(VisualElement owner, StylePropertyId prop, ref Length a, ref Length b)
			{
				return owner.TryConvertLengthUnits(prop, ref a, ref b);
			}

			internal static Length Lerp(Length a, Length b, float t)
			{
				return new Length(Mathf.LerpUnclamped(a.value, b.value, t), b.unit);
			}

			protected sealed override void UpdateValues()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					ref TimingData reference = ref running.timing[i];
					ref StyleData reference2 = ref running.style[i];
					reference2.currentValue = Lerp(reference2.startValue, reference2.endValue, reference.easedProgress);
				}
			}

			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}
		}

		private class ValuesColor : Values<Color>
		{
			public override Func<Color, Color, bool> SameFunc { get; } = IsSame;

			private static bool IsSame(Color c, Color d)
			{
				return Mathf.Approximately(c.r, d.r) && Mathf.Approximately(c.g, d.g) && Mathf.Approximately(c.b, d.b) && Mathf.Approximately(c.a, d.a);
			}

			private static Color Lerp(Color a, Color b, float t)
			{
				return Color.LerpUnclamped(a, b, t);
			}

			protected sealed override void UpdateValues()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					ref TimingData reference = ref running.timing[i];
					ref StyleData reference2 = ref running.style[i];
					reference2.currentValue = Lerp(reference2.startValue, reference2.endValue, reference.easedProgress);
				}
			}

			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}
		}

		private abstract class ValuesDiscrete<T> : Values<T>
		{
			public override Func<T, T, bool> SameFunc { get; } = IsSame;

			private static bool IsSame(T a, T b)
			{
				return EqualityComparer<T>.Default.Equals(a, b);
			}

			private static T Lerp(T a, T b, float t)
			{
				return (t < 0.5f) ? a : b;
			}

			protected sealed override void UpdateValues()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					ref TimingData reference = ref running.timing[i];
					ref StyleData reference2 = ref running.style[i];
					reference2.currentValue = Lerp(reference2.startValue, reference2.endValue, reference.easedProgress);
				}
			}
		}

		private class ValuesEnum : ValuesDiscrete<int>
		{
			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}
		}

		private class ValuesBackground : ValuesDiscrete<Background>
		{
			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}
		}

		private class ValuesFontDefinition : ValuesDiscrete<FontDefinition>
		{
			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}
		}

		private class ValuesFont : ValuesDiscrete<Font>
		{
			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}
		}

		private class ValuesTextShadow : Values<TextShadow>
		{
			public override Func<TextShadow, TextShadow, bool> SameFunc { get; } = IsSame;

			private static bool IsSame(TextShadow a, TextShadow b)
			{
				return a == b;
			}

			private static TextShadow Lerp(TextShadow a, TextShadow b, float t)
			{
				return TextShadow.LerpUnclamped(a, b, t);
			}

			protected sealed override void UpdateValues()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					ref TimingData reference = ref running.timing[i];
					ref StyleData reference2 = ref running.style[i];
					reference2.currentValue = Lerp(reference2.startValue, reference2.endValue, reference.easedProgress);
				}
			}

			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}
		}

		private class ValuesScale : Values<Scale>
		{
			public override Func<Scale, Scale, bool> SameFunc { get; } = IsSame;

			private static bool IsSame(Scale a, Scale b)
			{
				return a == b;
			}

			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}

			private static Scale Lerp(Scale a, Scale b, float t)
			{
				return new Scale(Vector3.LerpUnclamped(a.value, b.value, t));
			}

			protected sealed override void UpdateValues()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					ref TimingData reference = ref running.timing[i];
					ref StyleData reference2 = ref running.style[i];
					reference2.currentValue = Lerp(reference2.startValue, reference2.endValue, reference.easedProgress);
				}
			}
		}

		private class ValuesRotate : Values<Rotate>
		{
			public override Func<Rotate, Rotate, bool> SameFunc { get; } = IsSame;

			private static bool IsSame(Rotate a, Rotate b)
			{
				return a == b;
			}

			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}

			private static Rotate Lerp(Rotate a, Rotate b, float t)
			{
				return new Rotate(Mathf.LerpUnclamped(a.angle.ToDegrees(), b.angle.ToDegrees(), t));
			}

			protected sealed override void UpdateValues()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					ref TimingData reference = ref running.timing[i];
					ref StyleData reference2 = ref running.style[i];
					reference2.currentValue = Lerp(reference2.startValue, reference2.endValue, reference.easedProgress);
				}
			}
		}

		private class ValuesTranslate : Values<Translate>
		{
			public override Func<Translate, Translate, bool> SameFunc { get; } = IsSame;

			private static bool IsSame(Translate a, Translate b)
			{
				return a == b;
			}

			protected sealed override bool ConvertUnits(VisualElement owner, StylePropertyId prop, ref Translate a, ref Translate b)
			{
				return owner.TryConvertTranslateUnits(ref a, ref b);
			}

			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}

			private static Translate Lerp(Translate a, Translate b, float t)
			{
				return new Translate(ValuesLength.Lerp(a.x, b.x, t), ValuesLength.Lerp(a.y, b.y, t), Mathf.Lerp(a.z, b.z, t));
			}

			protected sealed override void UpdateValues()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					ref TimingData reference = ref running.timing[i];
					ref StyleData reference2 = ref running.style[i];
					reference2.currentValue = Lerp(reference2.startValue, reference2.endValue, reference.easedProgress);
				}
			}
		}

		private class ValuesTransformOrigin : Values<TransformOrigin>
		{
			public override Func<TransformOrigin, TransformOrigin, bool> SameFunc { get; } = IsSame;

			private static bool IsSame(TransformOrigin a, TransformOrigin b)
			{
				return a == b;
			}

			protected sealed override bool ConvertUnits(VisualElement owner, StylePropertyId prop, ref TransformOrigin a, ref TransformOrigin b)
			{
				return owner.TryConvertTransformOriginUnits(ref a, ref b);
			}

			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}

			private static TransformOrigin Lerp(TransformOrigin a, TransformOrigin b, float t)
			{
				return new TransformOrigin(ValuesLength.Lerp(a.x, b.x, t), ValuesLength.Lerp(a.y, b.y, t), Mathf.Lerp(a.z, b.z, t));
			}

			protected sealed override void UpdateValues()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					ref TimingData reference = ref running.timing[i];
					ref StyleData reference2 = ref running.style[i];
					reference2.currentValue = Lerp(reference2.startValue, reference2.endValue, reference.easedProgress);
				}
			}
		}

		private class ValuesBackgroundPosition : ValuesDiscrete<BackgroundPosition>
		{
			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}
		}

		private class ValuesBackgroundRepeat : ValuesDiscrete<BackgroundRepeat>
		{
			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}
		}

		private class ValuesBackgroundSize : Values<BackgroundSize>
		{
			public override Func<BackgroundSize, BackgroundSize, bool> SameFunc { get; } = IsSame;

			private static bool IsSame(BackgroundSize a, BackgroundSize b)
			{
				return a == b;
			}

			protected sealed override bool ConvertUnits(VisualElement owner, StylePropertyId prop, ref BackgroundSize a, ref BackgroundSize b)
			{
				return owner.TryConvertBackgroundSizeUnits(ref a, ref b);
			}

			protected sealed override void UpdateComputedStyle()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
				}
			}

			protected sealed override void UpdateComputedStyle(int i)
			{
				running.elements[i].computedStyle.ApplyPropertyAnimation(running.elements[i], running.properties[i], running.style[i].currentValue);
			}

			private static BackgroundSize Lerp(BackgroundSize a, BackgroundSize b, float t)
			{
				return new BackgroundSize(ValuesLength.Lerp(a.x, b.x, t), ValuesLength.Lerp(a.y, b.y, t));
			}

			protected sealed override void UpdateValues()
			{
				int count = running.count;
				for (int i = 0; i < count; i++)
				{
					ref TimingData reference = ref running.timing[i];
					ref StyleData reference2 = ref running.style[i];
					reference2.currentValue = Lerp(reference2.startValue, reference2.endValue, reference.easedProgress);
				}
			}
		}

		private long m_CurrentTimeMs = 0L;

		private ValuesFloat m_Floats;

		private ValuesInt m_Ints;

		private ValuesLength m_Lengths;

		private ValuesColor m_Colors;

		private ValuesEnum m_Enums;

		private ValuesBackground m_Backgrounds;

		private ValuesFontDefinition m_FontDefinitions;

		private ValuesFont m_Fonts;

		private ValuesTextShadow m_TextShadows;

		private ValuesScale m_Scale;

		private ValuesRotate m_Rotate;

		private ValuesTranslate m_Translate;

		private ValuesTransformOrigin m_TransformOrigin;

		private ValuesBackgroundPosition m_BackgroundPosition;

		private ValuesBackgroundRepeat m_BackgroundRepeat;

		private ValuesBackgroundSize m_BackgroundSize;

		private readonly List<Values> m_AllValues = new List<Values>();

		private readonly Dictionary<StylePropertyId, Values> m_PropertyToValues = new Dictionary<StylePropertyId, Values>();

		public StylePropertyAnimationSystem()
		{
			m_CurrentTimeMs = Panel.TimeSinceStartupMs();
		}

		private T GetOrCreate<T>(ref T values) where T : new()
		{
			T val = values;
			return (val != null) ? val : (values = new T());
		}

		private bool StartTransition<T>(VisualElement owner, StylePropertyId prop, T startValue, T endValue, int durationMs, int delayMs, Func<float, float> easingCurve, Values<T> values)
		{
			m_PropertyToValues[prop] = values;
			bool result = values.StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, CurrentTimeMs());
			UpdateTracking(values);
			return result;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, float startValue, float endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_Floats));
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, int startValue, int endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_Ints));
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, Length startValue, Length endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_Lengths));
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, Color startValue, Color endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_Colors));
		}

		public bool StartAnimationEnum(VisualElement owner, StylePropertyId prop, int startValue, int endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_Enums));
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, Background startValue, Background endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_Backgrounds));
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, FontDefinition startValue, FontDefinition endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_FontDefinitions));
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, Font startValue, Font endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_Fonts));
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, TextShadow startValue, TextShadow endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_TextShadows));
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, Scale startValue, Scale endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_Scale));
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, Rotate startValue, Rotate endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_Rotate));
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, Translate startValue, Translate endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_Translate));
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, TransformOrigin startValue, TransformOrigin endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_TransformOrigin));
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, BackgroundPosition startValue, BackgroundPosition endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_BackgroundPosition));
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, BackgroundRepeat startValue, BackgroundRepeat endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_BackgroundRepeat));
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, BackgroundSize startValue, BackgroundSize endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return StartTransition(owner, prop, startValue, endValue, durationMs, delayMs, easingCurve, GetOrCreate(ref m_BackgroundSize));
		}

		public void CancelAllAnimations()
		{
			foreach (Values allValue in m_AllValues)
			{
				allValue.CancelAllAnimations();
			}
		}

		public void CancelAllAnimations(VisualElement owner)
		{
			foreach (Values allValue in m_AllValues)
			{
				allValue.CancelAllAnimations(owner);
			}
			Assert.AreEqual(0, owner.styleAnimation.runningAnimationCount);
			Assert.AreEqual(0, owner.styleAnimation.completedAnimationCount);
		}

		public void CancelAnimation(VisualElement owner, StylePropertyId id)
		{
			if (m_PropertyToValues.TryGetValue(id, out var value))
			{
				value.CancelAnimation(owner, id);
			}
		}

		public bool HasRunningAnimation(VisualElement owner, StylePropertyId id)
		{
			Values value;
			return m_PropertyToValues.TryGetValue(id, out value) && value.HasRunningAnimation(owner, id);
		}

		public void UpdateAnimation(VisualElement owner, StylePropertyId id)
		{
			if (m_PropertyToValues.TryGetValue(id, out var value))
			{
				value.UpdateAnimation(owner, id);
			}
		}

		public void GetAllAnimations(VisualElement owner, List<StylePropertyId> propertyIds)
		{
			foreach (Values allValue in m_AllValues)
			{
				allValue.GetAllAnimations(owner, propertyIds);
			}
		}

		private void UpdateTracking<T>(Values<T> values)
		{
			if (!values.isEmpty && !m_AllValues.Contains(values))
			{
				m_AllValues.Add(values);
			}
		}

		private long CurrentTimeMs()
		{
			return m_CurrentTimeMs;
		}

		public void Update()
		{
			m_CurrentTimeMs = Panel.TimeSinceStartupMs();
			int count = m_AllValues.Count;
			for (int i = 0; i < count; i++)
			{
				m_AllValues[i].Update(m_CurrentTimeMs);
			}
		}
	}
	internal class EmptyStylePropertyAnimationSystem : IStylePropertyAnimationSystem
	{
		public bool StartTransition(VisualElement owner, StylePropertyId prop, float startValue, float endValue, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, int startValue, int endValue, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, Length startValue, Length endValue, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, Color startValue, Color endValue, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartAnimationEnum(VisualElement owner, StylePropertyId prop, int startValue, int endValue, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, Background startValue, Background endValue, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, FontDefinition startValue, FontDefinition endValue, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, Font startValue, Font endValue, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, Cursor startValue, Cursor endValue, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, TextShadow startValue, TextShadow endValue, int durationMs, int delayMs, Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, Scale startValue, Scale endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, TransformOrigin startValue, TransformOrigin endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, Translate startValue, Translate endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, Rotate startValue, Rotate endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, BackgroundPosition startValue, BackgroundPosition endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, BackgroundRepeat startValue, BackgroundRepeat endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return false;
		}

		public bool StartTransition(VisualElement owner, StylePropertyId prop, BackgroundSize startValue, BackgroundSize endValue, int durationMs, int delayMs, [JetBrains.Annotations.NotNull] Func<float, float> easingCurve)
		{
			return false;
		}

		public void CancelAllAnimations()
		{
		}

		public void CancelAllAnimations(VisualElement owner)
		{
		}

		public void CancelAnimation(VisualElement owner, StylePropertyId id)
		{
		}

		public bool HasRunningAnimation(VisualElement owner, StylePropertyId id)
		{
			return false;
		}

		public void UpdateAnimation(VisualElement owner, StylePropertyId id)
		{
		}

		public void GetAllAnimations(VisualElement owner, List<StylePropertyId> propertyIds)
		{
		}

		public void Update()
		{
		}
	}
	public struct StylePropertyName : IEquatable<StylePropertyName>
	{
		internal StylePropertyId id { get; }

		private string name { get; }

		internal static StylePropertyId StylePropertyIdFromString(string name)
		{
			if (StylePropertyUtil.s_NameToId.TryGetValue(name, out var value))
			{
				return value;
			}
			return StylePropertyId.Unknown;
		}

		internal StylePropertyName(StylePropertyId stylePropertyId)
		{
			id = stylePropertyId;
			name = null;
			if (StylePropertyUtil.s_IdToName.TryGetValue(stylePropertyId, out var value))
			{
				name = value;
			}
		}

		public StylePropertyName(string name)
		{
			id = StylePropertyIdFromString(name);
			this.name = null;
			if (id != StylePropertyId.Unknown)
			{
				this.name = name;
			}
		}

		public static bool IsNullOrEmpty(StylePropertyName propertyName)
		{
			return propertyName.id == StylePropertyId.Unknown;
		}

		public static bool operator ==(StylePropertyName lhs, StylePropertyName rhs)
		{
			return lhs.id == rhs.id;
		}

		public static bool operator !=(StylePropertyName lhs, StylePropertyName rhs)
		{
			return lhs.id != rhs.id;
		}

		public static implicit operator StylePropertyName(string name)
		{
			return new StylePropertyName(name);
		}

		public override int GetHashCode()
		{
			return (int)id;
		}

		public override bool Equals(object other)
		{
			return other is StylePropertyName && Equals((StylePropertyName)other);
		}

		public bool Equals(StylePropertyName other)
		{
			return this == other;
		}

		public override string ToString()
		{
			return name;
		}
	}
	internal enum Salt
	{
		TagNameSalt = 13,
		IdSalt = 17,
		ClassSalt = 19
	}
	internal struct Hashes
	{
		public const int kSize = 4;

		public unsafe fixed int hashes[4];
	}
	[Serializable]
	internal class StyleComplexSelector : ISerializationCallbackReceiver
	{
		private struct PseudoStateData
		{
			public readonly PseudoStates state;

			public readonly bool negate;

			public PseudoStateData(PseudoStates state, bool negate)
			{
				this.state = state;
				this.negate = negate;
			}
		}

		[NonSerialized]
		public Hashes ancestorHashes;

		[SerializeField]
		private int m_Specificity;

		[NonSerialized]
		private bool m_isSimple;

		[SerializeField]
		private StyleSelector[] m_Selectors;

		[SerializeField]
		internal int ruleIndex;

		[NonSerialized]
		internal StyleComplexSelector nextInTable;

		[NonSerialized]
		internal int orderInStyleSheet;

		private static Dictionary<string, PseudoStateData> s_PseudoStates;

		private static List<StyleSelectorPart> m_HashList = new List<StyleSelectorPart>();

		public int specificity
		{
			get
			{
				return m_Specificity;
			}
			internal set
			{
				m_Specificity = value;
			}
		}

		public StyleRule rule { get; internal set; }

		public bool isSimple => m_isSimple;

		public StyleSelector[] selectors
		{
			get
			{
				return m_Selectors;
			}
			internal set
			{
				m_Selectors = value;
				m_isSimple = m_Selectors.Length == 1;
			}
		}

		public void OnBeforeSerialize()
		{
		}

		public virtual void OnAfterDeserialize()
		{
			m_isSimple = m_Selectors.Length == 1;
		}

		internal void CachePseudoStateMasks()
		{
			if (s_PseudoStates == null)
			{
				s_PseudoStates = new Dictionary<string, PseudoStateData>();
				s_PseudoStates["active"] = new PseudoStateData(PseudoStates.Active, negate: false);
				s_PseudoStates["hover"] = new PseudoStateData(PseudoStates.Hover, negate: false);
				s_PseudoStates["checked"] = new PseudoStateData(PseudoStates.Checked, negate: false);
				s_PseudoStates["selected"] = new PseudoStateData(PseudoStates.Checked, negate: false);
				s_PseudoStates["disabled"] = new PseudoStateData(PseudoStates.Disabled, negate: false);
				s_PseudoStates["focus"] = new PseudoStateData(PseudoStates.Focus, negate: false);
				s_PseudoStates["root"] = new PseudoStateData(PseudoStates.Root, negate: false);
				s_PseudoStates["inactive"] = new PseudoStateData(PseudoStates.Active, negate: true);
				s_PseudoStates["enabled"] = new PseudoStateData(PseudoStates.Disabled, negate: true);
			}
			int i = 0;
			for (int num = selectors.Length; i < num; i++)
			{
				StyleSelector styleSelector = selectors[i];
				StyleSelectorPart[] parts = styleSelector.parts;
				PseudoStates pseudoStates = (PseudoStates)0;
				PseudoStates pseudoStates2 = (PseudoStates)0;
				for (int j = 0; j < styleSelector.parts.Length; j++)
				{
					if (styleSelector.parts[j].type != StyleSelectorType.PseudoClass)
					{
						continue;
					}
					if (s_PseudoStates.TryGetValue(parts[j].value, out var value))
					{
						if (!value.negate)
						{
							pseudoStates |= value.state;
						}
						else
						{
							pseudoStates2 |= value.state;
						}
					}
					else
					{
						Debug.LogWarningFormat("Unknown pseudo class \"{0}\"", parts[j].value);
					}
				}
				styleSelector.pseudoStateMask = (int)pseudoStates;
				styleSelector.negatedPseudoStateMask = (int)pseudoStates2;
			}
		}

		public override string ToString()
		{
			return string.Format("[{0}]", string.Join(", ", m_Selectors.Select((StyleSelector x) => x.ToString()).ToArray()));
		}

		private static int StyleSelectorPartCompare(StyleSelectorPart x, StyleSelectorPart y)
		{
			if (y.type < x.type)
			{
				return -1;
			}
			if (y.type > x.type)
			{
				return 1;
			}
			return y.value.CompareTo(x.value);
		}

		internal unsafe void CalculateHashes()
		{
			if (isSimple)
			{
				return;
			}
			for (int num = selectors.Length - 2; num > -1; num--)
			{
				m_HashList.AddRange(selectors[num].parts);
			}
			m_HashList.RemoveAll((StyleSelectorPart p) => p.type != StyleSelectorType.Class && p.type != StyleSelectorType.ID && p.type != StyleSelectorType.Type);
			m_HashList.Sort(StyleSelectorPartCompare);
			bool flag = true;
			StyleSelectorType styleSelectorType = StyleSelectorType.Unknown;
			string text = "";
			int num2 = 0;
			int num3 = Math.Min(4, m_HashList.Count);
			for (int num4 = 0; num4 < num3; num4++)
			{
				if (flag)
				{
					flag = false;
				}
				else
				{
					for (; num2 < m_HashList.Count && m_HashList[num2].type == styleSelectorType && m_HashList[num2].value == text; num2++)
					{
					}
					if (num2 == m_HashList.Count)
					{
						break;
					}
				}
				styleSelectorType = m_HashList[num2].type;
				text = m_HashList[num2].value;
				ancestorHashes.hashes[num4] = text.GetHashCode() * styleSelectorType switch
				{
					StyleSelectorType.ID => 17, 
					StyleSelectorType.Class => 19, 
					_ => 13, 
				};
			}
			m_HashList.Clear();
		}
	}
	[Serializable]
	internal class StyleProperty
	{
		[SerializeField]
		private string m_Name;

		[SerializeField]
		private int m_Line;

		[SerializeField]
		private StyleValueHandle[] m_Values;

		[NonSerialized]
		internal bool isCustomProperty;

		[NonSerialized]
		internal bool requireVariableResolve;

		public string name
		{
			get
			{
				return m_Name;
			}
			internal set
			{
				m_Name = value;
			}
		}

		public int line
		{
			get
			{
				return m_Line;
			}
			internal set
			{
				m_Line = value;
			}
		}

		public StyleValueHandle[] values
		{
			get
			{
				return m_Values;
			}
			internal set
			{
				m_Values = value;
			}
		}
	}
	[Serializable]
	internal class StyleRule
	{
		[SerializeField]
		private StyleProperty[] m_Properties;

		[SerializeField]
		internal int line;

		[NonSerialized]
		internal int customPropertiesCount;

		public StyleProperty[] properties
		{
			get
			{
				return m_Properties;
			}
			internal set
			{
				m_Properties = value;
			}
		}
	}
	[Serializable]
	internal class StyleSelector
	{
		[SerializeField]
		private StyleSelectorPart[] m_Parts;

		[SerializeField]
		private StyleSelectorRelationship m_PreviousRelationship;

		internal int pseudoStateMask = -1;

		internal int negatedPseudoStateMask = -1;

		public StyleSelectorPart[] parts
		{
			get
			{
				return m_Parts;
			}
			internal set
			{
				m_Parts = value;
			}
		}

		public StyleSelectorRelationship previousRelationship
		{
			get
			{
				return m_PreviousRelationship;
			}
			internal set
			{
				m_PreviousRelationship = value;
			}
		}

		public override string ToString()
		{
			return string.Join(", ", parts.Select((StyleSelectorPart p) => p.ToString()).ToArray());
		}
	}
	[Serializable]
	internal struct StyleSelectorPart
	{
		[SerializeField]
		private string m_Value;

		[SerializeField]
		private StyleSelectorType m_Type;

		internal object tempData;

		public string value
		{
			get
			{
				return m_Value;
			}
			internal set
			{
				m_Value = value;
			}
		}

		public StyleSelectorType type
		{
			get
			{
				return m_Type;
			}
			internal set
			{
				m_Type = value;
			}
		}

		public override string ToString()
		{
			return UnityString.Format("[StyleSelectorPart: value={0}, type={1}]", value, type);
		}

		public static StyleSelectorPart CreateClass(string className)
		{
			return new StyleSelectorPart
			{
				m_Type = StyleSelectorType.Class,
				m_Value = className
			};
		}

		public static StyleSelectorPart CreatePseudoClass(string className)
		{
			return new StyleSelectorPart
			{
				m_Type = StyleSelectorType.PseudoClass,
				m_Value = className
			};
		}

		public static StyleSelectorPart CreateId(string Id)
		{
			return new StyleSelectorPart
			{
				m_Type = StyleSelectorType.ID,
				m_Value = Id
			};
		}

		public static StyleSelectorPart CreateType(Type t)
		{
			return new StyleSelectorPart
			{
				m_Type = StyleSelectorType.Type,
				m_Value = t.Name
			};
		}

		public static StyleSelectorPart CreateType(string typeName)
		{
			return new StyleSelectorPart
			{
				m_Type = StyleSelectorType.Type,
				m_Value = typeName
			};
		}

		public static StyleSelectorPart CreatePredicate(object predicate)
		{
			return new StyleSelectorPart
			{
				m_Type = StyleSelectorType.Predicate,
				tempData = predicate
			};
		}

		public static StyleSelectorPart CreateWildCard()
		{
			return new StyleSelectorPart
			{
				m_Type = StyleSelectorType.Wildcard
			};
		}
	}
	internal enum StyleSelectorRelationship
	{
		None,
		Child,
		Descendent
	}
	internal enum StyleSelectorType
	{
		Unknown,
		Wildcard,
		Type,
		Class,
		PseudoClass,
		RecursivePseudoClass,
		ID,
		Predicate
	}
	[Serializable]
	[HelpURL("UIE-USS")]
	public class StyleSheet : ScriptableObject
	{
		[Serializable]
		internal struct ImportStruct
		{
			public StyleSheet styleSheet;

			public string[] mediaQueries;
		}

		[SerializeField]
		private bool m_ImportedWithErrors;

		[SerializeField]
		private bool m_ImportedWithWarnings;

		[SerializeField]
		private StyleRule[] m_Rules;

		[SerializeField]
		private StyleComplexSelector[] m_ComplexSelectors;

		[SerializeField]
		internal float[] floats;

		[SerializeField]
		internal Dimension[] dimensions;

		[SerializeField]
		internal Color[] colors;

		[SerializeField]
		internal string[] strings;

		[SerializeField]
		internal Object[] assets;

		[SerializeField]
		internal ImportStruct[] imports;

		[SerializeField]
		private List<StyleSheet> m_FlattenedImportedStyleSheets;

		[SerializeField]
		private int m_ContentHash;

		[SerializeField]
		internal ScalableImage[] scalableImages;

		[NonSerialized]
		internal Dictionary<string, StyleComplexSelector> orderedNameSelectors;

		[NonSerialized]
		internal Dictionary<string, StyleComplexSelector> orderedTypeSelectors;

		[NonSerialized]
		internal Dictionary<string, StyleComplexSelector> orderedClassSelectors;

		[NonSerialized]
		private bool m_IsDefaultStyleSheet;

		private static string kCustomPropertyMarker = "--";

		public bool importedWithErrors
		{
			get
			{
				return m_ImportedWithErrors;
			}
			internal set
			{
				m_ImportedWithErrors = value;
			}
		}

		public bool importedWithWarnings
		{
			get
			{
				return m_ImportedWithWarnings;
			}
			internal set
			{
				m_ImportedWithWarnings = value;
			}
		}

		internal StyleRule[] rules
		{
			get
			{
				return m_Rules;
			}
			set
			{
				m_Rules = value;
				SetupReferences();
			}
		}

		internal StyleComplexSelector[] complexSelectors
		{
			get
			{
				return m_ComplexSelectors;
			}
			set
			{
				m_ComplexSelectors = value;
				SetupReferences();
			}
		}

		internal List<StyleSheet> flattenedRecursiveImports => m_FlattenedImportedStyleSheets;

		public int contentHash
		{
			get
			{
				return m_ContentHash;
			}
			set
			{
				m_ContentHash = value;
			}
		}

		internal bool isDefaultStyleSheet
		{
			get
			{
				return m_IsDefaultStyleSheet;
			}
			set
			{
				m_IsDefaultStyleSheet = value;
				if (flattenedRecursiveImports == null)
				{
					return;
				}
				foreach (StyleSheet flattenedRecursiveImport in flattenedRecursiveImports)
				{
					flattenedRecursiveImport.isDefaultStyleSheet = value;
				}
			}
		}

		private bool TryCheckAccess<T>(T[] list, StyleValueType type, StyleValueHandle handle, out T value)
		{
			bool result = false;
			value = default(T);
			if (handle.valueType == type && handle.valueIndex >= 0 && handle.valueIndex < list.Length)
			{
				value = list[handle.valueIndex];
				result = true;
			}
			else
			{
				Debug.LogErrorFormat(this, "Trying to read value of type {0} while reading a value of type {1}", type, handle.valueType);
			}
			return result;
		}

		private T CheckAccess<T>(T[] list, StyleValueType type, StyleValueHandle handle)
		{
			T result = default(T);
			if (handle.valueType != type)
			{
				Debug.LogErrorFormat(this, "Trying to read value of type {0} while reading a value of type {1}", type, handle.valueType);
			}
			else
			{
				if (list != null && handle.valueIndex >= 0 && handle.valueIndex < list.Length)
				{
					return list[handle.valueIndex];
				}
				Debug.LogError("Accessing invalid property", this);
			}
			return result;
		}

		internal virtual void OnEnable()
		{
			SetupReferences();
		}

		internal void FlattenImportedStyleSheetsRecursive()
		{
			m_FlattenedImportedStyleSheets = new List<StyleSheet>();
			FlattenImportedStyleSheetsRecursive(this);
		}

		private void FlattenImportedStyleSheetsRecursive(StyleSheet sheet)
		{
			if (sheet.imports == null)
			{
				return;
			}
			for (int i = 0; i < sheet.imports.Length; i++)
			{
				StyleSheet styleSheet = sheet.imports[i].styleSheet;
				if (!(styleSheet == null))
				{
					styleSheet.isDefaultStyleSheet = isDefaultStyleSheet;
					FlattenImportedStyleSheetsRecursive(styleSheet);
					m_FlattenedImportedStyleSheets.Add(styleSheet);
				}
			}
		}

		private void SetupReferences()
		{
			if (complexSelectors == null || rules == null)
			{
				return;
			}
			StyleRule[] array = rules;
			foreach (StyleRule styleRule in array)
			{
				StyleProperty[] properties = styleRule.properties;
				foreach (StyleProperty styleProperty in properties)
				{
					if (CustomStartsWith(styleProperty.name, kCustomPropertyMarker))
					{
						styleRule.customPropertiesCount++;
						styleProperty.isCustomProperty = true;
					}
					StyleValueHandle[] values = styleProperty.values;
					foreach (StyleValueHandle handle in values)
					{
						if (handle.IsVarFunction())
						{
							styleProperty.requireVariableResolve = true;
							break;
						}
					}
				}
			}
			int l = 0;
			for (int num = complexSelectors.Length; l < num; l++)
			{
				complexSelectors[l].CachePseudoStateMasks();
			}
			orderedClassSelectors = new Dictionary<string, StyleComplexSelector>(StringComparer.Ordinal);
			orderedNameSelectors = new Dictionary<string, StyleComplexSelector>(StringComparer.Ordinal);
			orderedTypeSelectors = new Dictionary<string, StyleComplexSelector>(StringComparer.Ordinal);
			for (int m = 0; m < complexSelectors.Length; m++)
			{
				StyleComplexSelector styleComplexSelector = complexSelectors[m];
				if (styleComplexSelector.ruleIndex < rules.Length)
				{
					styleComplexSelector.rule = rules[styleComplexSelector.ruleIndex];
				}
				styleComplexSelector.CalculateHashes();
				styleComplexSelector.orderInStyleSheet = m;
				StyleSelector styleSelector = styleComplexSelector.selectors[styleComplexSelector.selectors.Length - 1];
				StyleSelectorPart styleSelectorPart = styleSelector.parts[0];
				string key = styleSelectorPart.value;
				Dictionary<string, StyleComplexSelector> dictionary = null;
				switch (styleSelectorPart.type)
				{
				case StyleSelectorType.Class:
					dictionary = orderedClassSelectors;
					break;
				case StyleSelectorType.ID:
					dictionary = orderedNameSelectors;
					break;
				case StyleSelectorType.Wildcard:
				case StyleSelectorType.Type:
					key = styleSelectorPart.value ?? "*";
					dictionary = orderedTypeSelectors;
					break;
				case StyleSelectorType.PseudoClass:
					key = "*";
					dictionary = orderedTypeSelectors;
					break;
				default:
					Debug.LogError($"Invalid first part type {styleSelectorPart.type}", this);
					break;
				}
				if (dictionary != null)
				{
					if (dictionary.TryGetValue(key, out var value))
					{
						styleComplexSelector.nextInTable = value;
					}
					dictionary[key] = styleComplexSelector;
				}
			}
		}

		internal StyleValueKeyword ReadKeyword(StyleValueHandle handle)
		{
			return (StyleValueKeyword)handle.valueIndex;
		}

		internal float ReadFloat(StyleValueHandle handle)
		{
			if (handle.valueType == StyleValueType.Dimension)
			{
				return CheckAccess(dimensions, StyleValueType.Dimension, handle).value;
			}
			return CheckAccess(floats, StyleValueType.Float, handle);
		}

		internal bool TryReadFloat(StyleValueHandle handle, out float value)
		{
			if (TryCheckAccess(floats, StyleValueType.Float, handle, out value))
			{
				return true;
			}
			Dimension value2;
			bool result = TryCheckAccess(dimensions, StyleValueType.Float, handle, out value2);
			value = value2.value;
			return result;
		}

		internal Dimension ReadDimension(StyleValueHandle handle)
		{
			if (handle.valueType == StyleValueType.Float)
			{
				float value = CheckAccess(floats, StyleValueType.Float, handle);
				return new Dimension(value, Dimension.Unit.Unitless);
			}
			return CheckAccess(dimensions, StyleValueType.Dimension, handle);
		}

		internal bool TryReadDimension(StyleValueHandle handle, out Dimension value)
		{
			if (TryCheckAccess(dimensions, StyleValueType.Dimension, handle, out value))
			{
				return true;
			}
			float value2 = 0f;
			bool result = TryCheckAccess(floats, StyleValueType.Float, handle, out value2);
			value = new Dimension(value2, Dimension.Unit.Unitless);
			return result;
		}

		internal Color ReadColor(StyleValueHandle handle)
		{
			return CheckAccess(colors, StyleValueType.Color, handle);
		}

		internal bool TryReadColor(StyleValueHandle handle, out Color value)
		{
			return TryCheckAccess(colors, StyleValueType.Color, handle, out value);
		}

		internal string ReadString(StyleValueHandle handle)
		{
			return CheckAccess(strings, StyleValueType.String, handle);
		}

		internal bool TryReadString(StyleValueHandle handle, out string value)
		{
			return TryCheckAccess(strings, StyleValueType.String, handle, out value);
		}

		internal string ReadEnum(StyleValueHandle handle)
		{
			return CheckAccess(strings, StyleValueType.Enum, handle);
		}

		internal bool TryReadEnum(StyleValueHandle handle, out string value)
		{
			return TryCheckAccess(strings, StyleValueType.Enum, handle, out value);
		}

		internal string ReadVariable(StyleValueHandle handle)
		{
			return CheckAccess(strings, StyleValueType.Variable, handle);
		}

		internal bool TryReadVariable(StyleValueHandle handle, out string value)
		{
			return TryCheckAccess(strings, StyleValueType.Variable, handle, out value);
		}

		internal string ReadResourcePath(StyleValueHandle handle)
		{
			return CheckAccess(strings, StyleValueType.ResourcePath, handle);
		}

		internal bool TryReadResourcePath(StyleValueHandle handle, out string value)
		{
			return TryCheckAccess(strings, StyleValueType.ResourcePath, handle, out value);
		}

		internal Object ReadAssetReference(StyleValueHandle handle)
		{
			return CheckAccess(assets, StyleValueType.AssetReference, handle);
		}

		internal string ReadMissingAssetReferenceUrl(StyleValueHandle handle)
		{
			return CheckAccess(strings, StyleValueType.MissingAssetReference, handle);
		}

		internal bool TryReadAssetReference(StyleValueHandle handle, out Object value)
		{
			return TryCheckAccess(assets, StyleValueType.AssetReference, handle, out value);
		}

		internal StyleValueFunction ReadFunction(StyleValueHandle handle)
		{
			return (StyleValueFunction)handle.valueIndex;
		}

		internal string ReadFunctionName(StyleValueHandle handle)
		{
			if (handle.valueType != StyleValueType.Function)
			{
				Debug.LogErrorFormat(this, $"Trying to read value of type {StyleValueType.Function} while reading a value of type {handle.valueType}");
				return string.Empty;
			}
			StyleValueFunction valueIndex = (StyleValueFunction)handle.valueIndex;
			return valueIndex.ToUssString();
		}

		internal ScalableImage ReadScalableImage(StyleValueHandle handle)
		{
			return CheckAccess(scalableImages, StyleValueType.ScalableImage, handle);
		}

		private static bool CustomStartsWith(string originalString, string pattern)
		{
			int length = originalString.Length;
			int length2 = pattern.Length;
			int num = 0;
			int num2 = 0;
			while (num < length && num2 < length2 && originalString[num] == pattern[num2])
			{
				num++;
				num2++;
			}
			return (num2 == length2 && length >= length2) || (num == length && length2 >= length);
		}
	}
	internal enum StyleValueFunction
	{
		Unknown,
		Var,
		Env,
		LinearGradient
	}
	internal static class StyleValueFunctionExtension
	{
		public const string k_Var = "var";

		public const string k_Env = "env";

		public const string k_LinearGradient = "linear-gradient";

		public static StyleValueFunction FromUssString(string ussValue)
		{
			ussValue = ussValue.ToLowerInvariant();
			return ussValue switch
			{
				"var" => StyleValueFunction.Var, 
				"env" => StyleValueFunction.Env, 
				"linear-gradient" => StyleValueFunction.LinearGradient, 
				_ => throw new ArgumentOutOfRangeException("ussValue", ussValue, "Unknown function name"), 
			};
		}

		public static string ToUssString(this StyleValueFunction svf)
		{
			return svf switch
			{
				StyleValueFunction.Var => "var", 
				StyleValueFunction.Env => "env", 
				StyleValueFunction.LinearGradient => "linear-gradient", 
				_ => throw new ArgumentOutOfRangeException("svf", svf, "Unknown StyleValueFunction"), 
			};
		}
	}
	[Serializable]
	internal struct StyleValueHandle
	{
		[SerializeField]
		private StyleValueType m_ValueType;

		[SerializeField]
		internal int valueIndex;

		public StyleValueType valueType
		{
			get
			{
				return m_ValueType;
			}
			internal set
			{
				m_ValueType = value;
			}
		}

		internal StyleValueHandle(int valueIndex, StyleValueType valueType)
		{
			this.valueIndex = valueIndex;
			m_ValueType = valueType;
		}
	}
	internal enum StyleValueKeyword
	{
		Inherit,
		Initial,
		Auto,
		Unset,
		True,
		False,
		None
	}
	internal static class StyleValueKeywordExtension
	{
		public static string ToUssString(this StyleValueKeyword svk)
		{
			return svk switch
			{
				StyleValueKeyword.Inherit => "inherit", 
				StyleValueKeyword.Initial => "initial", 
				StyleValueKeyword.Auto => "auto", 
				StyleValueKeyword.Unset => "unset", 
				StyleValueKeyword.True => "true", 
				StyleValueKeyword.False => "false", 
				StyleValueKeyword.None => "none", 
				_ => throw new ArgumentOutOfRangeException("svk", svk, "Unknown StyleValueKeyword"), 
			};
		}
	}
	internal enum StyleValueType
	{
		Invalid,
		Keyword,
		Float,
		Dimension,
		Color,
		ResourcePath,
		AssetReference,
		Enum,
		Variable,
		String,
		Function,
		CommaSeparator,
		ScalableImage,
		MissingAssetReference
	}
	internal struct StyleVariable
	{
		public readonly string name;

		public readonly StyleSheet sheet;

		public readonly StyleValueHandle[] handles;

		public StyleVariable(string name, StyleSheet sheet, StyleValueHandle[] handles)
		{
			this.name = name;
			this.sheet = sheet;
			this.handles = handles;
		}

		public override int GetHashCode()
		{
			int hashCode = name.GetHashCode();
			hashCode = (hashCode * 397) ^ sheet.GetHashCode();
			return (hashCode * 397) ^ handles.GetHashCode();
		}
	}
	internal class StyleVariableContext
	{
		public static readonly StyleVariableContext none = new StyleVariableContext();

		private int m_VariableHash;

		private List<StyleVariable> m_Variables;

		private List<int> m_SortedHash;

		private List<int> m_UnsortedHash;

		public List<StyleVariable> variables => m_Variables;

		public void Add(StyleVariable sv)
		{
			int hash = sv.GetHashCode();
			int num = m_SortedHash.BinarySearch(hash);
			if (num >= 0)
			{
				int num2 = m_Variables.Count - 1;
				if (m_UnsortedHash[num2] == hash)
				{
					return;
				}
				for (num2--; num2 >= 0; num2--)
				{
					if (m_UnsortedHash[num2] == hash)
					{
						m_VariableHash ^= ComputeOrderSensitiveHash(num2);
						m_Variables.RemoveAt(num2);
						m_UnsortedHash.RemoveAt(num2);
						break;
					}
				}
			}
			else
			{
				m_SortedHash.Insert(~num, hash);
			}
			m_VariableHash ^= ComputeOrderSensitiveHash(m_Variables.Count);
			m_Variables.Add(sv);
			m_UnsortedHash.Add(hash);
			int ComputeOrderSensitiveHash(int index)
			{
				return (index + 1) * hash;
			}
		}

		public void AddInitialRange(StyleVariableContext other)
		{
			if (other.m_Variables.Count > 0)
			{
				Debug.Assert(m_Variables.Count == 0);
				m_VariableHash = other.m_VariableHash;
				m_Variables.AddRange(other.m_Variables);
				m_SortedHash.AddRange(other.m_SortedHash);
				m_UnsortedHash.AddRange(other.m_UnsortedHash);
			}
		}

		public void Clear()
		{
			if (m_Variables.Count > 0)
			{
				m_Variables.Clear();
				m_VariableHash = 0;
				m_SortedHash.Clear();
				m_UnsortedHash.Clear();
			}
		}

		public StyleVariableContext()
		{
			m_Variables = new List<StyleVariable>();
			m_VariableHash = 0;
			m_SortedHash = new List<int>();
			m_UnsortedHash = new List<int>();
		}

		public StyleVariableContext(StyleVariableContext other)
		{
			m_Variables = new List<StyleVariable>(other.m_Variables);
			m_VariableHash = other.m_VariableHash;
			m_SortedHash = new List<int>(other.m_SortedHash);
			m_UnsortedHash = new List<int>(other.m_UnsortedHash);
		}

		public bool TryFindVariable(string name, out StyleVariable v)
		{
			for (int num = m_Variables.Count - 1; num >= 0; num--)
			{
				if (m_Variables[num].name == name)
				{
					v = m_Variables[num];
					return true;
				}
			}
			v = default(StyleVariable);
			return false;
		}

		public int GetVariableHash()
		{
			return m_VariableHash;
		}
	}
	internal class StyleVariableResolver
	{
		private enum Result
		{
			Valid,
			Invalid,
			NotFound
		}

		private struct ResolveContext
		{
			public StyleSheet sheet;

			public StyleValueHandle[] handles;
		}

		internal const int kMaxResolves = 100;

		private static StyleSyntaxParser s_SyntaxParser = new StyleSyntaxParser();

		private StylePropertyValueMatcher m_Matcher = new StylePropertyValueMatcher();

		private List<StylePropertyValue> m_ResolvedValues = new List<StylePropertyValue>();

		private Stack<string> m_ResolvedVarStack = new Stack<string>();

		private StyleProperty m_Property;

		private Stack<ResolveContext> m_ContextStack = new Stack<ResolveContext>();

		private ResolveContext m_CurrentContext;

		private StyleSheet currentSheet => m_CurrentContext.sheet;

		private StyleValueHandle[] currentHandles => m_CurrentContext.handles;

		public List<StylePropertyValue> resolvedValues => m_ResolvedValues;

		public StyleVariableContext variableContext { get; set; }

		public void Init(StyleProperty property, StyleSheet sheet, StyleValueHandle[] handles)
		{
			m_ResolvedValues.Clear();
			m_ContextStack.Clear();
			m_Property = property;
			PushContext(sheet, handles);
		}

		private void PushContext(StyleSheet sheet, StyleValueHandle[] handles)
		{
			m_CurrentContext = new ResolveContext
			{
				sheet = sheet,
				handles = handles
			};
			m_ContextStack.Push(m_CurrentContext);
		}

		private void PopContext()
		{
			m_ContextStack.Pop();
			m_CurrentContext = m_ContextStack.Peek();
		}

		public void AddValue(StyleValueHandle handle)
		{
			m_ResolvedValues.Add(new StylePropertyValue
			{
				sheet = currentSheet,
				handle = handle
			});
		}

		public bool ResolveVarFunction(ref int index)
		{
			m_ResolvedVarStack.Clear();
			ParseVarFunction(currentSheet, currentHandles, ref index, out var argCount, out var variableName);
			Result result = ResolveVarFunction(ref index, argCount, variableName);
			return result == Result.Valid;
		}

		private Result ResolveVarFunction(ref int index, int argc, string varName)
		{
			Result result = ResolveVariable(varName);
			if (result == Result.NotFound && argc > 1)
			{
				StyleValueHandle styleValueHandle = currentHandles[++index];
				Debug.Assert(styleValueHandle.valueType == StyleValueType.CommaSeparator, $"Unexpected value type {styleValueHandle.valueType} in var function");
				if (styleValueHandle.valueType == StyleValueType.CommaSeparator && index + 1 < currentHandles.Length)
				{
					index++;
					result = ResolveFallback(ref index);
				}
			}
			return result;
		}

		public bool ValidateResolvedValues()
		{
			if (m_Property.isCustomProperty)
			{
				return true;
			}
			if (!StylePropertyCache.TryGetSyntax(m_Property.name, out var syntax))
			{
				Debug.LogAssertion("Unknown style property " + m_Property.name);
				return false;
			}
			Expression exp = s_SyntaxParser.Parse(syntax);
			return m_Matcher.Match(exp, m_ResolvedValues).success;
		}

		private Result ResolveVariable(string variableName)
		{
			if (!variableContext.TryFindVariable(variableName, out var v))
			{
				return Result.NotFound;
			}
			if (m_ResolvedVarStack.Contains(v.name))
			{
				return Result.NotFound;
			}
			m_ResolvedVarStack.Push(v.name);
			Result result = Result.Valid;
			for (int i = 0; i < v.handles.Length; i++)
			{
				if (result != Result.Valid)
				{
					break;
				}
				if (m_ResolvedValues.Count + 1 > 100)
				{
					return Result.Invalid;
				}
				StyleValueHandle handle = v.handles[i];
				if (handle.IsVarFunction())
				{
					PushContext(v.sheet, v.handles);
					ParseVarFunction(v.sheet, v.handles, ref i, out var argCount, out var variableName2);
					result = ResolveVarFunction(ref i, argCount, variableName2);
					PopContext();
				}
				else
				{
					m_ResolvedValues.Add(new StylePropertyValue
					{
						sheet = v.sheet,
						handle = handle
					});
				}
			}
			m_ResolvedVarStack.Pop();
			return result;
		}

		private Result ResolveFallback(ref int index)
		{
			Result result = Result.Valid;
			while (index < currentHandles.Length && result == Result.Valid)
			{
				StyleValueHandle handle = currentHandles[index];
				if (handle.IsVarFunction())
				{
					ParseVarFunction(currentSheet, currentHandles, ref index, out var argCount, out var variableName);
					result = ResolveVariable(variableName);
					if (result == Result.NotFound && argCount > 1)
					{
						handle = currentHandles[++index];
						Debug.Assert(handle.valueType == StyleValueType.CommaSeparator, $"Unexpected value type {handle.valueType} in var function");
						if (handle.valueType == StyleValueType.CommaSeparator && index + 1 < currentHandles.Length)
						{
							index++;
							result = ResolveFallback(ref index);
						}
					}
				}
				else
				{
					m_ResolvedValues.Add(new StylePropertyValue
					{
						sheet = currentSheet,
						handle = handle
					});
				}
				index++;
			}
			return result;
		}

		private static void ParseVarFunction(StyleSheet sheet, StyleValueHandle[] handles, ref int index, out int argCount, out string variableName)
		{
			argCount = (int)sheet.ReadFloat(handles[++index]);
			variableName = sheet.ReadVariable(handles[++index]);
		}
	}
	[Serializable]
	[HelpURL("UIE-tss")]
	public class ThemeStyleSheet : StyleSheet
	{
		internal override void OnEnable()
		{
			base.isDefaultStyleSheet = true;
			base.OnEnable();
		}
	}
	public class TemplateContainer : BindableElement
	{
		public new class UxmlFactory : UxmlFactory<TemplateContainer, UxmlTraits>
		{
			internal const string k_ElementName = "Instance";

			public override string uxmlName => "Instance";

			public override string uxmlQualifiedName => uxmlNamespace + "." + uxmlName;
		}

		public new class UxmlTraits : BindableElement.UxmlTraits
		{
			internal const string k_TemplateAttributeName = "template";

			private UxmlStringAttributeDescription m_Template = new UxmlStringAttributeDescription
			{
				name = "template",
				use = UxmlAttributeDescription.Use.Required
			};

			public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
			{
				get
				{
					yield break;
				}
			}

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				TemplateContainer templateContainer = (TemplateContainer)ve;
				templateContainer.templateId = m_Template.GetValueFromBag(bag, cc);
				VisualTreeAsset visualTreeAsset = cc.visualTreeAsset?.ResolveTemplate(templateContainer.templateId);
				if (visualTreeAsset == null)
				{
					templateContainer.Add(new Label($"Unknown Template: '{templateContainer.templateId}'"));
				}
				else
				{
					List<TemplateAsset.AttributeOverride> list = (bag as TemplateAsset)?.attributeOverrides;
					List<TemplateAsset.AttributeOverride> attributeOverrides = cc.attributeOverrides;
					List<TemplateAsset.AttributeOverride> list2 = null;
					if (list != null || attributeOverrides != null)
					{
						list2 = new List<TemplateAsset.AttributeOverride>();
						if (attributeOverrides != null)
						{
							list2.AddRange(attributeOverrides);
						}
						if (list != null)
						{
							list2.AddRange(list);
						}
					}
					visualTreeAsset.CloneTree(ve, cc.slotInsertionPoints, list2);
				}
				if (visualTreeAsset == null)
				{
					Debug.LogErrorFormat("Could not resolve template with name '{0}'", templateContainer.templateId);
				}
			}
		}

		private VisualElement m_ContentContainer;

		private VisualTreeAsset m_TemplateSource;

		public string templateId { get; private set; }

		public VisualTreeAsset templateSource
		{
			get
			{
				return m_TemplateSource;
			}
			internal set
			{
				m_TemplateSource = value;
			}
		}

		public override VisualElement contentContainer => m_ContentContainer;

		public TemplateContainer()
			: this(null)
		{
		}

		public TemplateContainer(string templateId)
		{
			this.templateId = templateId;
			m_ContentContainer = this;
		}

		internal void SetContentContainer(VisualElement content)
		{
			m_ContentContainer = content;
		}
	}
	public class PanelTextSettings : TextSettings
	{
		private static PanelTextSettings s_DefaultPanelTextSettings;

		internal static Func<string, Object> EditorGUIUtilityLoad;

		internal static Func<SystemLanguage> GetCurrentLanguage;

		internal static readonly string s_DefaultEditorPanelTextSettingPath = "UIPackageResources/Default Editor Text Settings.asset";

		internal static PanelTextSettings defaultPanelTextSettings
		{
			get
			{
				if (s_DefaultPanelTextSettings == null && s_DefaultPanelTextSettings == null)
				{
					s_DefaultPanelTextSettings = ScriptableObject.CreateInstance<PanelTextSettings>();
				}
				return s_DefaultPanelTextSettings;
			}
		}

		internal static void UpdateLocalizationFontAsset()
		{
			string text = " - Linux";
			Dictionary<SystemLanguage, string> dictionary = new Dictionary<SystemLanguage, string>
			{
				{
					SystemLanguage.English,
					Path.Combine(UIElementsPackageUtility.EditorResourcesBasePath, "UIPackageResources/FontAssets/DynamicOSFontAssets/Localization/English" + text + ".asset")
				},
				{
					SystemLanguage.Japanese,
					Path.Combine(UIElementsPackageUtility.EditorResourcesBasePath, "UIPackageResources/FontAssets/DynamicOSFontAssets/Localization/Japanese" + text + ".asset")
				},
				{
					SystemLanguage.ChineseSimplified,
					Path.Combine(UIElementsPackageUtility.EditorResourcesBasePath, "UIPackageResources/FontAssets/DynamicOSFontAssets/Localization/ChineseSimplified" + text + ".asset")
				},
				{
					SystemLanguage.ChineseTraditional,
					Path.Combine(UIElementsPackageUtility.EditorResourcesBasePath, "UIPackageResources/FontAssets/DynamicOSFontAssets/Localization/ChineseTraditional" + text + ".asset")
				},
				{
					SystemLanguage.Korean,
					Path.Combine(UIElementsPackageUtility.EditorResourcesBasePath, "UIPackageResources/FontAssets/DynamicOSFontAssets/Localization/Korean" + text + ".asset")
				}
			};
			string arg = Path.Combine(UIElementsPackageUtility.EditorResourcesBasePath, "UIPackageResources/FontAssets/DynamicOSFontAssets/GlobalFallback/GlobalFallback" + text + ".asset");
			FontAsset value = EditorGUIUtilityLoad(dictionary[GetCurrentLanguage()]) as FontAsset;
			FontAsset value2 = EditorGUIUtilityLoad(arg) as FontAsset;
			defaultPanelTextSettings.fallbackFontAssets[0] = value;
			defaultPanelTextSettings.fallbackFontAssets[defaultPanelTextSettings.fallbackFontAssets.Count - 1] = value2;
		}

		internal FontAsset GetCachedFontAsset(Font font)
		{
			return GetCachedFontAssetInternal(font);
		}
	}
	internal class TextEditingManipulator
	{
		private TextElement m_TextElement;

		internal TextEditorEventHandler editingEventHandler;

		internal TextEditingUtilities editingUtilities;

		private bool m_TouchScreenTextFieldInitialized;

		private IVisualElementScheduledItem m_HardwareKeyboardPoller = null;

		private bool touchScreenTextFieldChanged => m_TouchScreenTextFieldInitialized != editingUtilities?.TouchScreenKeyboardShouldBeUsed();

		public TextEditingManipulator(TextElement textElement)
		{
			m_TextElement = textElement;
			editingUtilities = new TextEditingUtilities(textElement.selectingManipulator.m_SelectingUtilities, textElement.uitkTextHandle, textElement.text);
			InitTextEditorEventHandler();
		}

		private void InitTextEditorEventHandler()
		{
			m_TouchScreenTextFieldInitialized = editingUtilities?.TouchScreenKeyboardShouldBeUsed() ?? false;
			if (m_TouchScreenTextFieldInitialized)
			{
				editingEventHandler = new TouchScreenTextEditorEventHandler(m_TextElement, editingUtilities);
			}
			else
			{
				editingEventHandler = new KeyboardTextEditorEventHandler(m_TextElement, editingUtilities);
			}
		}

		internal void ExecuteDefaultActionAtTarget(EventBase evt)
		{
			if (m_TextElement.edition.isReadOnly)
			{
				return;
			}
			if (!(evt is FocusInEvent _))
			{
				if (evt is FocusOutEvent _2)
				{
					OnFocusOutEvent(_2);
				}
			}
			else
			{
				OnFocusInEvent(_);
			}
			editingEventHandler?.ExecuteDefaultActionAtTarget(evt);
		}

		private void OnFocusInEvent(FocusInEvent _)
		{
			m_TextElement.edition.SaveValueAndText();
			m_TextElement.focusController.selectedTextElement = m_TextElement;
			if (touchScreenTextFieldChanged)
			{
				InitTextEditorEventHandler();
			}
			if (m_HardwareKeyboardPoller == null)
			{
				m_HardwareKeyboardPoller = m_TextElement.schedule.Execute((Action)delegate
				{
					if (touchScreenTextFieldChanged)
					{
						InitTextEditorEventHandler();
						m_TextElement.Blur();
					}
				}).Every(250L);
			}
			else
			{
				m_HardwareKeyboardPoller.Resume();
			}
		}

		private void OnFocusOutEvent(FocusOutEvent _)
		{
			m_HardwareKeyboardPoller?.Pause();
			editingUtilities.OnBlur();
		}
	}
	internal class TextSelectingManipulator
	{
		internal TextSelectingUtilities m_SelectingUtilities;

		private bool selectAllOnMouseUp;

		private TextElement m_TextElement;

		private Vector2 m_ClickStartPosition;

		private bool m_Dragged;

		private bool m_IsClicking;

		private const int k_DragThresholdSqr = 16;

		private int m_ConsecutiveMouseDownCount;

		private long m_LastMouseDownTimeStamp = 0L;

		private readonly Event m_ImguiEvent = new Event();

		internal bool isClicking
		{
			get
			{
				return m_IsClicking;
			}
			set
			{
				if (m_IsClicking != value)
				{
					m_IsClicking = value;
				}
			}
		}

		internal int cursorIndex
		{
			get
			{
				return m_SelectingUtilities?.cursorIndex ?? (-1);
			}
			set
			{
				m_SelectingUtilities.cursorIndex = value;
			}
		}

		internal int selectIndex
		{
			get
			{
				return m_SelectingUtilities?.selectIndex ?? (-1);
			}
			set
			{
				m_SelectingUtilities.selectIndex = value;
			}
		}

		public TextSelectingManipulator(TextElement textElement)
		{
			m_TextElement = textElement;
			m_SelectingUtilities = new TextSelectingUtilities(m_TextElement.uitkTextHandle);
			TextSelectingUtilities selectingUtilities = m_SelectingUtilities;
			selectingUtilities.OnCursorIndexChange = (Action)Delegate.Combine(selectingUtilities.OnCursorIndexChange, new Action(OnCursorIndexChange));
			TextSelectingUtilities selectingUtilities2 = m_SelectingUtilities;
			selectingUtilities2.OnSelectIndexChange = (Action)Delegate.Combine(selectingUtilities2.OnSelectIndexChange, new Action(OnSelectIndexChange));
			TextSelectingUtilities selectingUtilities3 = m_SelectingUtilities;
			selectingUtilities3.OnRevealCursorChange = (Action)Delegate.Combine(selectingUtilities3.OnRevealCursorChange, new Action(OnRevealCursor));
		}

		private void OnRevealCursor()
		{
			m_TextElement.IncrementVersion(VersionChangeType.Repaint);
		}

		private void OnSelectIndexChange()
		{
			m_TextElement.IncrementVersion(VersionChangeType.Repaint);
			if (HasSelection() && m_TextElement.focusController != null)
			{
				m_TextElement.focusController.selectedTextElement = m_TextElement;
			}
			if (m_SelectingUtilities.revealCursor)
			{
				m_TextElement.edition.UpdateScrollOffset?.Invoke(obj: false);
			}
		}

		private void OnCursorIndexChange()
		{
			m_TextElement.IncrementVersion(VersionChangeType.Repaint);
			if (HasSelection() && m_TextElement.focusController != null)
			{
				m_TextElement.focusController.selectedTextElement = m_TextElement;
			}
			if (m_SelectingUtilities.revealCursor)
			{
				m_TextElement.edition.UpdateScrollOffset?.Invoke(obj: false);
			}
		}

		internal bool RevealCursor()
		{
			return m_SelectingUtilities.revealCursor;
		}

		internal bool HasSelection()
		{
			return m_SelectingUtilities.hasSelection;
		}

		internal bool HasFocus()
		{
			return m_TextElement.hasFocus;
		}

		internal void ExecuteDefaultActionAtTarget(EventBase evt)
		{
			if (!(evt is FocusEvent evt2))
			{
				if (!(evt is BlurEvent evt3))
				{
					if (!(evt is PointerDownEvent evt4))
					{
						if (!(evt is KeyDownEvent evt5))
						{
							if (!(evt is PointerMoveEvent evt6))
							{
								if (!(evt is PointerUpEvent evt7))
								{
									if (!(evt is ValidateCommandEvent evt8))
									{
										if (evt is ExecuteCommandEvent evt9)
										{
											OnExecuteCommandEvent(evt9);
										}
									}
									else
									{
										OnValidateCommandEvent(evt8);
									}
								}
								else
								{
									OnPointerUpEvent(evt7);
								}
							}
							else
							{
								OnPointerMoveEvent(evt6);
							}
						}
						else
						{
							OnKeyDown(evt5);
						}
					}
					else
					{
						OnPointerDownEvent(evt4);
					}
				}
				else
				{
					OnBlurEvent(evt3);
				}
			}
			else
			{
				OnFocusEvent(evt2);
			}
		}

		private void OnFocusEvent(FocusEvent evt)
		{
			selectAllOnMouseUp = false;
			if (PointerDeviceState.GetPressedButtons(PointerId.mousePointerId) != 0 || (m_TextElement.panel.contextType == ContextType.Editor && Event.current == null))
			{
				selectAllOnMouseUp = m_TextElement.selection.selectAllOnMouseUp;
			}
			m_SelectingUtilities.OnFocus(m_TextElement.selection.selectAllOnFocus);
		}

		private void OnBlurEvent(BlurEvent evt)
		{
			selectAllOnMouseUp = m_TextElement.selection.selectAllOnMouseUp;
		}

		private void OnKeyDown(KeyDownEvent evt)
		{
			if (m_TextElement.hasFocus)
			{
				evt.GetEquivalentImguiEvent(m_ImguiEvent);
				if (m_SelectingUtilities.HandleKeyEvent(m_ImguiEvent))
				{
					evt.StopPropagation();
				}
			}
		}

		private void OnPointerDownEvent(PointerDownEvent evt)
		{
			Vector3 vector = evt.localPosition - (Vector3)m_TextElement.contentRect.min;
			if (evt.button != 0)
			{
				return;
			}
			if (evt.timestamp - m_LastMouseDownTimeStamp < Event.GetDoubleClickTime())
			{
				m_ConsecutiveMouseDownCount++;
			}
			else
			{
				m_ConsecutiveMouseDownCount = 1;
			}
			if (m_ConsecutiveMouseDownCount == 2 && m_TextElement.selection.doubleClickSelectsWord)
			{
				if (cursorIndex == 0 && cursorIndex != selectIndex)
				{
					m_SelectingUtilities.MoveCursorToPosition_Internal(vector, evt.shiftKey);
				}
				m_SelectingUtilities.SelectCurrentWord();
				m_SelectingUtilities.MouseDragSelectsWholeWords(on: true);
				m_SelectingUtilities.DblClickSnap(TextEditor.DblClickSnapping.WORDS);
			}
			else if (m_ConsecutiveMouseDownCount == 3 && m_TextElement.selection.tripleClickSelectsLine)
			{
				m_SelectingUtilities.SelectCurrentParagraph();
				m_SelectingUtilities.MouseDragSelectsWholeWords(on: true);
				m_SelectingUtilities.DblClickSnap(TextEditor.DblClickSnapping.PARAGRAPHS);
			}
			else
			{
				m_SelectingUtilities.MoveCursorToPosition_Internal(vector, evt.shiftKey);
				m_TextElement.edition.UpdateScrollOffset?.Invoke(obj: false);
				m_SelectingUtilities.MouseDragSelectsWholeWords(on: false);
				m_SelectingUtilities.DblClickSnap(TextEditor.DblClickSnapping.WORDS);
			}
			m_LastMouseDownTimeStamp = evt.timestamp;
			isClicking = true;
			m_TextElement.CapturePointer(evt.pointerId);
			m_ClickStartPosition = vector;
		}

		private void OnPointerMoveEvent(PointerMoveEvent evt)
		{
			if (isClicking)
			{
				Vector3 vector = evt.localPosition - (Vector3)m_TextElement.contentRect.min;
				m_Dragged = m_Dragged || MoveDistanceQualifiesForDrag(m_ClickStartPosition, vector);
				if (m_Dragged)
				{
					m_SelectingUtilities.SelectToPosition(vector);
					m_TextElement.edition.UpdateScrollOffset?.Invoke(obj: false);
					selectAllOnMouseUp = m_TextElement.selection.selectAllOnMouseUp && !m_SelectingUtilities.hasSelection;
				}
				evt.StopPropagation();
			}
		}

		private void OnPointerUpEvent(PointerUpEvent evt)
		{
			if (evt.button == 0 && isClicking)
			{
				if (selectAllOnMouseUp)
				{
					m_SelectingUtilities.SelectAll();
				}
				selectAllOnMouseUp = false;
				m_Dragged = false;
				isClicking = false;
				m_TextElement.ReleasePointer(evt.pointerId);
				evt.StopPropagation();
			}
		}

		private void OnValidateCommandEvent(ValidateCommandEvent evt)
		{
			if (!m_TextElement.hasFocus)
			{
				return;
			}
			switch (evt.commandName)
			{
			case "Paste":
				return;
			case "Delete":
				return;
			case "UndoRedoPerformed":
				return;
			case "Copy":
				if (!m_SelectingUtilities.hasSelection)
				{
					return;
				}
				break;
			}
			evt.StopPropagation();
		}

		private void OnExecuteCommandEvent(ExecuteCommandEvent evt)
		{
			if (m_TextElement.hasFocus)
			{
				switch (evt.commandName)
				{
				case "OnLostFocus":
					evt.StopPropagation();
					break;
				case "Copy":
					m_SelectingUtilities.Copy();
					evt.StopPropagation();
					break;
				case "SelectAll":
					m_SelectingUtilities.SelectAll();
					evt.StopPropagation();
					break;
				}
			}
		}

		private bool MoveDistanceQualifiesForDrag(Vector2 start, Vector2 current)
		{
			return (start - current).sqrMagnitude >= 16f;
		}
	}
	internal class UITKTextHandle : TextHandle
	{
		private TextElement m_TextElement;

		internal bool isOverridingCursor = false;

		internal int currentLinkIDHash = -1;

		internal bool hasLinkTag = false;

		internal bool hasATag = false;

		internal static readonly float k_MinPadding = 6f;

		public Vector2 MeasuredSizes { get; set; }

		public Vector2 RoundedSizes { get; set; }

		public UITKTextHandle(TextElement te)
		{
			m_TextElement = te;
		}

		public float ComputeTextWidth(string textToMeasure, bool wordWrap, float width, float height)
		{
			ConvertUssToTextGenerationSettings(TextHandle.s_LayoutSettings);
			TextHandle.s_LayoutSettings.text = textToMeasure;
			TextHandle.s_LayoutSettings.screenRect = new Rect(0f, 0f, width, height);
			TextHandle.s_LayoutSettings.wordWrap = wordWrap;
			return ComputeTextWidth(TextHandle.s_LayoutSettings);
		}

		public float ComputeTextHeight(string textToMeasure, float width, float height)
		{
			ConvertUssToTextGenerationSettings(TextHandle.s_LayoutSettings);
			TextHandle.s_LayoutSettings.text = textToMeasure;
			TextHandle.s_LayoutSettings.screenRect = new Rect(0f, 0f, width, height);
			return ComputeTextHeight(TextHandle.s_LayoutSettings);
		}

		public UnityEngine.TextCore.Text.TextInfo Update()
		{
			ConvertUssToTextGenerationSettings(textGenerationSettings);
			Vector2 vector = m_TextElement.contentRect.size;
			if (Mathf.Abs(vector.x - RoundedSizes.x) < 0.01f && Mathf.Abs(vector.y - RoundedSizes.y) < 0.01f)
			{
				vector = MeasuredSizes;
			}
			else
			{
				RoundedSizes = vector;
				MeasuredSizes = vector;
			}
			textGenerationSettings.screenRect = new Rect(Vector2.zero, vector);
			Update(textGenerationSettings);
			HandleATag();
			HandleLinkTag();
			return base.textInfo;
		}

		private void ATagOnPointerUp(PointerUpEvent pue)
		{
			Vector3 position = pue.localPosition - new Vector3(m_TextElement.contentRect.min.x, m_TextElement.contentRect.min.y);
			int num = FindIntersectingLink(position);
			if (num < 0)
			{
				return;
			}
			LinkInfo linkInfo = base.textInfo.linkInfo[num];
			if (linkInfo.hashCode == 2535353 && linkInfo.linkId != null && linkInfo.linkIdLength > 0)
			{
				string linkId = linkInfo.GetLinkId();
				if (Uri.IsWellFormedUriString(linkId, UriKind.Absolute))
				{
					Application.OpenURL(linkId);
				}
			}
		}

		private void ATagOnPointerOver(PointerOverEvent _)
		{
			isOverridingCursor = false;
		}

		private void ATagOnPointerMove(PointerMoveEvent pme)
		{
			Vector3 position = pme.localPosition - new Vector3(m_TextElement.contentRect.min.x, m_TextElement.contentRect.min.y);
			int num = FindIntersectingLink(position);
			ICursorManager cursorManager = (m_TextElement.panel as BaseVisualElementPanel)?.cursorManager;
			if (num >= 0)
			{
				LinkInfo linkInfo = base.textInfo.linkInfo[num];
				if (linkInfo.hashCode == 2535353)
				{
					if (!isOverridingCursor)
					{
						isOverridingCursor = true;
						cursorManager?.SetCursor(new Cursor
						{
							defaultCursorId = 4
						});
					}
					return;
				}
			}
			if (isOverridingCursor)
			{
				cursorManager?.SetCursor(m_TextElement.computedStyle.cursor);
				isOverridingCursor = false;
			}
		}

		private void ATagOnPointerOut(PointerOutEvent _)
		{
			isOverridingCursor = false;
		}

		internal void LinkTagOnPointerDown(PointerDownEvent pde)
		{
			Vector3 position = pde.localPosition - new Vector3(m_TextElement.contentRect.min.x, m_TextElement.contentRect.min.y);
			int num = FindIntersectingLink(position);
			if (num < 0)
			{
				return;
			}
			LinkInfo linkInfo = base.textInfo.linkInfo[num];
			if (linkInfo.hashCode == 2535353 || linkInfo.linkId == null || linkInfo.linkIdLength <= 0)
			{
				return;
			}
			using PointerDownLinkTagEvent pointerDownLinkTagEvent = PointerDownLinkTagEvent.GetPooled(pde, linkInfo.GetLinkId(), linkInfo.GetLinkText(base.textInfo));
			pointerDownLinkTagEvent.target = m_TextElement;
			m_TextElement.SendEvent(pointerDownLinkTagEvent);
		}

		internal void LinkTagOnPointerUp(PointerUpEvent pue)
		{
			Vector3 position = pue.localPosition - new Vector3(m_TextElement.contentRect.min.x, m_TextElement.contentRect.min.y);
			int num = FindIntersectingLink(position);
			if (num < 0)
			{
				return;
			}
			LinkInfo linkInfo = base.textInfo.linkInfo[num];
			if (linkInfo.hashCode == 2535353 || linkInfo.linkId == null || linkInfo.linkIdLength <= 0)
			{
				return;
			}
			using PointerUpLinkTagEvent pointerUpLinkTagEvent = PointerUpLinkTagEvent.GetPooled(pue, linkInfo.GetLinkId(), linkInfo.GetLinkText(base.textInfo));
			pointerUpLinkTagEvent.target = m_TextElement;
			m_TextElement.SendEvent(pointerUpLinkTagEvent);
		}

		internal void LinkTagOnPointerMove(PointerMoveEvent pme)
		{
			Vector3 position = pme.localPosition - new Vector3(m_TextElement.contentRect.min.x, m_TextElement.contentRect.min.y);
			int num = FindIntersectingLink(position);
			if (num >= 0)
			{
				LinkInfo linkInfo = base.textInfo.linkInfo[num];
				if (linkInfo.hashCode != 2535353)
				{
					if (currentLinkIDHash == -1)
					{
						currentLinkIDHash = linkInfo.hashCode;
						using PointerOverLinkTagEvent pointerOverLinkTagEvent = PointerOverLinkTagEvent.GetPooled(pme, linkInfo.GetLinkId(), linkInfo.GetLinkText(base.textInfo));
						pointerOverLinkTagEvent.target = m_TextElement;
						m_TextElement.SendEvent(pointerOverLinkTagEvent);
						return;
					}
					if (currentLinkIDHash == linkInfo.hashCode)
					{
						using (PointerMoveLinkTagEvent pointerMoveLinkTagEvent = PointerMoveLinkTagEvent.GetPooled(pme, linkInfo.GetLinkId(), linkInfo.GetLinkText(base.textInfo)))
						{
							pointerMoveLinkTagEvent.target = m_TextElement;
							m_TextElement.SendEvent(pointerMoveLinkTagEvent);
							return;
						}
					}
				}
			}
			if (currentLinkIDHash != -1)
			{
				currentLinkIDHash = -1;
				using PointerOutLinkTagEvent pointerOutLinkTagEvent = PointerOutLinkTagEvent.GetPooled(pme, string.Empty);
				pointerOutLinkTagEvent.target = m_TextElement;
				m_TextElement.SendEvent(pointerOutLinkTagEvent);
			}
		}

		private void LinkTagOnPointerOut(PointerOutEvent poe)
		{
			if (currentLinkIDHash != -1)
			{
				using (PointerOutLinkTagEvent pointerOutLinkTagEvent = PointerOutLinkTagEvent.GetPooled(poe, string.Empty))
				{
					pointerOutLinkTagEvent.target = m_TextElement;
					m_TextElement.SendEvent(pointerOutLinkTagEvent);
				}
				currentLinkIDHash = -1;
			}
		}

		private void HandleLinkTag()
		{
			for (int i = 0; i < base.textInfo.linkCount; i++)
			{
				LinkInfo linkInfo = base.textInfo.linkInfo[i];
				if (linkInfo.hashCode != 2535353)
				{
					m_TextElement.RegisterCallback<PointerDownEvent>(LinkTagOnPointerDown, TrickleDown.TrickleDown);
					m_TextElement.RegisterCallback<PointerUpEvent>(LinkTagOnPointerUp, TrickleDown.TrickleDown);
					m_TextElement.RegisterCallback<PointerMoveEvent>(LinkTagOnPointerMove, TrickleDown.TrickleDown);
					m_TextElement.RegisterCallback<PointerOutEvent>(LinkTagOnPointerOut, TrickleDown.TrickleDown);
					hasLinkTag = true;
					return;
				}
			}
			if (hasLinkTag)
			{
				hasLinkTag = false;
				m_TextElement.UnregisterCallback<PointerDownEvent>(LinkTagOnPointerDown, TrickleDown.TrickleDown);
				m_TextElement.UnregisterCallback<PointerUpEvent>(LinkTagOnPointerUp, TrickleDown.TrickleDown);
				m_TextElement.UnregisterCallback<PointerMoveEvent>(LinkTagOnPointerMove, TrickleDown.TrickleDown);
				m_TextElement.UnregisterCallback<PointerOutEvent>(LinkTagOnPointerOut, TrickleDown.TrickleDown);
			}
		}

		private void HandleATag()
		{
			for (int i = 0; i < base.textInfo.linkCount; i++)
			{
				LinkInfo linkInfo = base.textInfo.linkInfo[i];
				if (linkInfo.hashCode == 2535353)
				{
					m_TextElement.RegisterCallback<PointerUpEvent>(ATagOnPointerUp, TrickleDown.TrickleDown);
					if (m_TextElement.panel.contextType == ContextType.Editor)
					{
						m_TextElement.RegisterCallback<PointerMoveEvent>(ATagOnPointerMove, TrickleDown.TrickleDown);
						m_TextElement.RegisterCallback<PointerOverEvent>(ATagOnPointerOver, TrickleDown.TrickleDown);
						m_TextElement.RegisterCallback<PointerOutEvent>(ATagOnPointerOut, TrickleDown.TrickleDown);
					}
					hasATag = true;
					return;
				}
			}
			if (hasATag)
			{
				hasATag = false;
				m_TextElement.UnregisterCallback<PointerUpEvent>(ATagOnPointerUp, TrickleDown.TrickleDown);
				if (m_TextElement.panel.contextType == ContextType.Editor)
				{
					m_TextElement.UnregisterCallback<PointerMoveEvent>(ATagOnPointerMove, TrickleDown.TrickleDown);
					m_TextElement.UnregisterCallback<PointerOverEvent>(ATagOnPointerOver, TrickleDown.TrickleDown);
					m_TextElement.UnregisterCallback<PointerOutEvent>(ATagOnPointerOut, TrickleDown.TrickleDown);
				}
			}
		}

		private TextOverflowMode GetTextOverflowMode()
		{
			ComputedStyle computedStyle = m_TextElement.computedStyle;
			if (computedStyle.textOverflow == TextOverflow.Clip)
			{
				return TextOverflowMode.Masking;
			}
			if (computedStyle.textOverflow != TextOverflow.Ellipsis)
			{
				return TextOverflowMode.Overflow;
			}
			if (!TextLibraryCanElide())
			{
				return TextOverflowMode.Masking;
			}
			if (computedStyle.overflow == OverflowInternal.Hidden)
			{
				return TextOverflowMode.Ellipsis;
			}
			return TextOverflowMode.Overflow;
		}

		internal void ConvertUssToTextGenerationSettings(UnityEngine.TextCore.Text.TextGenerationSettings tgs)
		{
			ComputedStyle computedStyle = m_TextElement.computedStyle;
			tgs.textSettings = TextUtilities.GetTextSettingsFrom(m_TextElement);
			if (!(tgs.textSettings == null))
			{
				tgs.fontAsset = TextUtilities.GetFontAsset(m_TextElement);
				if (!(tgs.fontAsset == null))
				{
					tgs.material = tgs.fontAsset.material;
					tgs.screenRect = new Rect(0f, 0f, m_TextElement.contentRect.width, m_TextElement.contentRect.height);
					tgs.extraPadding = GetTextEffectPadding(tgs.fontAsset);
					tgs.text = ((m_TextElement.isElided && !TextLibraryCanElide()) ? m_TextElement.elidedText : m_TextElement.renderedText);
					tgs.fontSize = ((computedStyle.fontSize.value > 0f) ? computedStyle.fontSize.value : ((float)tgs.fontAsset.faceInfo.pointSize));
					tgs.fontStyle = TextGeneratorUtilities.LegacyStyleToNewStyle(computedStyle.unityFontStyleAndWeight);
					tgs.textAlignment = TextGeneratorUtilities.LegacyAlignmentToNewAlignment(computedStyle.unityTextAlign);
					tgs.wordWrap = computedStyle.whiteSpace == WhiteSpace.Normal;
					tgs.wordWrappingRatio = 0.4f;
					tgs.richText = m_TextElement.enableRichText;
					tgs.overflowMode = GetTextOverflowMode();
					tgs.characterSpacing = computedStyle.letterSpacing.value;
					tgs.wordSpacing = computedStyle.wordSpacing.value;
					tgs.paragraphSpacing = computedStyle.unityParagraphSpacing.value;
					tgs.color = computedStyle.color;
					tgs.shouldConvertToLinearSpace = false;
					tgs.isRightToLeft = m_TextElement.localLanguageDirection == LanguageDirection.RTL;
					tgs.parseControlCharacters = m_TextElement.parseEscapeSequences;
					tgs.inverseYAxis = true;
				}
			}
		}

		internal bool TextLibraryCanElide()
		{
			return m_TextElement.computedStyle.unityTextOverflowPosition == TextOverflowPosition.End;
		}

		internal float GetTextEffectPadding(FontAsset fontAsset)
		{
			ComputedStyle computedStyle = m_TextElement.computedStyle;
			float num = computedStyle.unityTextOutlineWidth / 2f;
			float num2 = Mathf.Abs(computedStyle.textShadow.offset.x);
			float num3 = Mathf.Abs(computedStyle.textShadow.offset.y);
			float num4 = Mathf.Abs(computedStyle.textShadow.blurRadius);
			if (num <= 0f && num2 <= 0f && num3 <= 0f && num4 <= 0f)
			{
				return k_MinPadding;
			}
			float a = Mathf.Max(num2 + num4, num);
			float b = Mathf.Max(num3 + num4, num);
			float num5 = Mathf.Max(a, b) + k_MinPadding;
			float num6 = TextUtilities.ConvertPixelUnitsToTextCoreRelativeUnits(m_TextElement, fontAsset);
			int num7 = fontAsset.atlasPadding + 1;
			return Mathf.Min(num5 * num6 * (float)num7, num7);
		}
	}
	internal static class TextUtilities
	{
		internal static Vector2 MeasureVisualElementTextSize(TextElement te, string textToMeasure, float width, VisualElement.MeasureMode widthMode, float height, VisualElement.MeasureMode heightMode)
		{
			float x = float.NaN;
			float y = float.NaN;
			if (textToMeasure == null || !IsFontAssigned(te))
			{
				return new Vector2(x, y);
			}
			float scaledPixelsPerPoint = te.scaledPixelsPerPoint;
			if (scaledPixelsPerPoint <= 0f)
			{
				return Vector2.zero;
			}
			if (widthMode == VisualElement.MeasureMode.Exactly)
			{
				x = width;
			}
			else
			{
				x = te.uitkTextHandle.ComputeTextWidth(textToMeasure, wordWrap: false, width, height);
				if (widthMode == VisualElement.MeasureMode.AtMost)
				{
					x = Mathf.Min(x, width);
				}
			}
			if (heightMode == VisualElement.MeasureMode.Exactly)
			{
				y = height;
			}
			else
			{
				y = te.uitkTextHandle.ComputeTextHeight(textToMeasure, width, height);
				if (heightMode == VisualElement.MeasureMode.AtMost)
				{
					y = Mathf.Min(y, height);
				}
			}
			float x2 = AlignmentUtils.CeilToPixelGrid(x, scaledPixelsPerPoint, 0f);
			float y2 = AlignmentUtils.CeilToPixelGrid(y, scaledPixelsPerPoint, 0f);
			Vector2 vector = new Vector2(x2, y2);
			te.uitkTextHandle.MeasuredSizes = new Vector2(x, y);
			te.uitkTextHandle.RoundedSizes = vector;
			return vector;
		}

		internal static FontAsset GetFontAsset(VisualElement ve)
		{
			if (ve.computedStyle.unityFontDefinition.fontAsset != null)
			{
				return ve.computedStyle.unityFontDefinition.fontAsset;
			}
			PanelTextSettings textSettingsFrom = GetTextSettingsFrom(ve);
			if (ve.computedStyle.unityFontDefinition.font != null)
			{
				return textSettingsFrom.GetCachedFontAsset(ve.computedStyle.unityFontDefinition.font);
			}
			if (ve.computedStyle.unityFont != null)
			{
				return textSettingsFrom.GetCachedFontAsset(ve.computedStyle.unityFont);
			}
			return null;
		}

		internal static Font GetFont(VisualElement ve)
		{
			ComputedStyle computedStyle = ve.computedStyle;
			if (computedStyle.unityFontDefinition.font != null)
			{
				return computedStyle.unityFontDefinition.font;
			}
			if (computedStyle.unityFont != null)
			{
				return computedStyle.unityFont;
			}
			return computedStyle.unityFontDefinition.fontAsset?.sourceFontFile;
		}

		internal static bool IsFontAssigned(VisualElement ve)
		{
			return ve.computedStyle.unityFont != null || !ve.computedStyle.unityFontDefinition.IsEmpty();
		}

		internal static PanelTextSettings GetTextSettingsFrom(VisualElement ve)
		{
			if (ve.panel is RuntimePanel runtimePanel)
			{
				return runtimePanel.panelSettings.textSettings ?? PanelTextSettings.defaultPanelTextSettings;
			}
			return PanelTextSettings.defaultPanelTextSettings;
		}

		internal static float ConvertPixelUnitsToTextCoreRelativeUnits(VisualElement ve, FontAsset fontAsset)
		{
			float num = 1f / (float)fontAsset.atlasPadding;
			float num2 = (float)fontAsset.faceInfo.pointSize / ve.computedStyle.fontSize.value;
			return num * num2;
		}

		internal static TextCoreSettings GetTextCoreSettingsForElement(VisualElement ve)
		{
			FontAsset fontAsset = GetFontAsset(ve);
			if (fontAsset == null)
			{
				return default(TextCoreSettings);
			}
			IResolvedStyle resolvedStyle = ve.resolvedStyle;
			ComputedStyle computedStyle = ve.computedStyle;
			float num = ConvertPixelUnitsToTextCoreRelativeUnits(ve, fontAsset);
			float num2 = Mathf.Clamp(resolvedStyle.unityTextOutlineWidth * num, 0f, 1f);
			float underlaySoftness = Mathf.Clamp(computedStyle.textShadow.blurRadius * num, 0f, 1f);
			float x = ((computedStyle.textShadow.offset.x < 0f) ? Mathf.Max(computedStyle.textShadow.offset.x * num, -1f) : Mathf.Min(computedStyle.textShadow.offset.x * num, 1f));
			float y = ((computedStyle.textShadow.offset.y < 0f) ? Mathf.Max(computedStyle.textShadow.offset.y * num, -1f) : Mathf.Min(computedStyle.textShadow.offset.y * num, 1f));
			Vector2 underlayOffset = new Vector2(x, y);
			Color color = resolvedStyle.color;
			Color unityTextOutlineColor = resolvedStyle.unityTextOutlineColor;
			if (num2 < 1E-30f)
			{
				unityTextOutlineColor.a = 0f;
			}
			return new TextCoreSettings
			{
				faceColor = color,
				outlineColor = unityTextOutlineColor,
				outlineWidth = num2,
				underlayColor = computedStyle.textShadow.color,
				underlayOffset = underlayOffset,
				underlaySoftness = underlaySoftness
			};
		}
	}
	internal interface ITextElement
	{
		string text { get; set; }
	}
	public class TextElement : BindableElement, ITextElement, INotifyValueChanged<string>, ITextEdition, ITextElementExperimentalFeatures, IExperimentalFeatures, ITextSelection
	{
		public new class UxmlFactory : UxmlFactory<TextElement, UxmlTraits>
		{
		}

		public new class UxmlTraits : BindableElement.UxmlTraits
		{
			private UxmlStringAttributeDescription m_Text = new UxmlStringAttributeDescription
			{
				name = "text"
			};

			private UxmlBoolAttributeDescription m_EnableRichText = new UxmlBoolAttributeDescription
			{
				name = "enable-rich-text",
				defaultValue = true
			};

			private UxmlBoolAttributeDescription m_ParseEscapeSequences = new UxmlBoolAttributeDescription
			{
				name = "parse-escape-sequences",
				defaultValue = false
			};

			private UxmlBoolAttributeDescription m_DisplayTooltipWhenElided = new UxmlBoolAttributeDescription
			{
				name = "display-tooltip-when-elided"
			};

			public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
			{
				get
				{
					yield break;
				}
			}

			public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
			{
				base.Init(ve, bag, cc);
				TextElement textElement = (TextElement)ve;
				textElement.text = m_Text.GetValueFromBag(bag, cc);
				textElement.enableRichText = m_EnableRichText.GetValueFromBag(bag, cc);
				textElement.parseEscapeSequences = m_ParseEscapeSequences.GetValueFromBag(bag, cc);
				textElement.displayTooltipWhenElided = m_DisplayTooltipWhenElided.GetValueFromBag(bag, cc);
			}
		}

		public static readonly string ussClassName = "unity-text-element";

		private string m_Text = string.Empty;

		private bool m_EnableRichText = true;

		private bool m_ParseEscapeSequences = true;

		private bool m_DisplayTooltipWhenElided = true;

		internal static readonly string k_EllipsisText = "...";

		internal string elidedText;

		private bool m_WasElided;

		internal TextEditingManipulator editingManipulator;

		private bool m_Multiline;

		internal TouchScreenKeyboard m_TouchScreenKeyboard;

		internal TouchScreenKeyboardType m_KeyboardType = TouchScreenKeyboardType.Default;

		private bool m_HideMobileInput;

		private bool m_IsReadOnly = true;

		private int m_MaxLength = -1;

		private string m_RenderedText;

		private string m_OriginalText;

		private char m_MaskChar;

		private bool m_IsPassword;

		private bool m_AutoCorrection;

		private TextSelectingManipulator m_SelectingManipulator;

		private bool m_IsSelectable;

		private Color m_SelectionColor = new Color(0.239f, 0.502f, 0.875f, 0.65f);

		private Color m_CursorColor = new Color(0.706f, 0.706f, 0.706f, 1f);

		private float m_CursorWidth = 1f;

		internal UITKTextHandle uitkTextHandle { get; set; }

		public virtual string text
		{
			get
			{
				return ((INotifyValueChanged<string>)this).value;
			}
			set
			{
				((INotifyValueChanged<string>)this).value = value;
			}
		}

		public bool enableRichText
		{
			get
			{
				return m_EnableRichText;
			}
			set
			{
				if (m_EnableRichText != value)
				{
					m_EnableRichText = value;
					MarkDirtyRepaint();
				}
			}
		}

		public bool parseEscapeSequences
		{
			get
			{
				return m_ParseEscapeSequences;
			}
			set
			{
				if (m_ParseEscapeSequences != value)
				{
					m_ParseEscapeSequences = value;
					MarkDirtyRepaint();
				}
			}
		}

		public bool displayTooltipWhenElided
		{
			get
			{
				return m_DisplayTooltipWhenElided;
			}
			set
			{
				if (m_DisplayTooltipWhenElided != value)
				{
					m_DisplayTooltipWhenElided = value;
					UpdateVisibleText();
					MarkDirtyRepaint();
				}
			}
		}

		public bool isElided { get; private set; }

		internal bool hasFocus => base.elementPanel != null && base.elementPanel.focusController?.GetLeafFocusedElement() == this;

		string INotifyValueChanged<string>.value
		{
			get
			{
				return m_Text ?? string.Empty;
			}
			set
			{
				if (!(m_Text != value))
				{
					return;
				}
				if (base.panel != null)
				{
					using (ChangeEvent<string> changeEvent = ChangeEvent<string>.GetPooled(text, value))
					{
						changeEvent.target = this;
						((INotifyValueChanged<string>)this).SetValueWithoutNotify(value);
						SendEvent(changeEvent);
						return;
					}
				}
				((INotifyValueChanged<string>)this).SetValueWithoutNotify(value);
			}
		}

		internal ITextEdition edition => this;

		bool ITextEdition.multiline
		{
			get
			{
				return m_Multiline;
			}
			set
			{
				if (value != m_Multiline)
				{
					if (!edition.isReadOnly)
					{
						editingManipulator.editingUtilities.multiline = value;
					}
					m_Multiline = value;
				}
			}
		}

		TouchScreenKeyboard ITextEdition.touchScreenKeyboard => m_TouchScreenKeyboard;

		TouchScreenKeyboardType ITextEdition.keyboardType
		{
			get
			{
				return m_KeyboardType;
			}
			set
			{
				m_KeyboardType = value;
			}
		}

		bool ITextEdition.hideMobileInput
		{
			get
			{
				switch (Application.platform)
				{
				case RuntimePlatform.IPhonePlayer:
				case RuntimePlatform.Android:
				case RuntimePlatform.WebGLPlayer:
				case RuntimePlatform.tvOS:
					return m_HideMobileInput;
				default:
					return true;
				}
			}
			set
			{
				switch (Application.platform)
				{
				case RuntimePlatform.IPhonePlayer:
				case RuntimePlatform.Android:
				case RuntimePlatform.WebGLPlayer:
				case RuntimePlatform.tvOS:
					m_HideMobileInput = value;
					break;
				default:
					m_HideMobileInput = true;
					break;
				}
			}
		}

		bool ITextEdition.isReadOnly
		{
			get
			{
				return m_IsReadOnly || !base.enabledInHierarchy;
			}
			set
			{
				if (value != m_IsReadOnly)
				{
					editingManipulator = (value ? null : new TextEditingManipulator(this));
					m_IsReadOnly = value;
				}
			}
		}

		int ITextEdition.maxLength
		{
			get
			{
				return m_MaxLength;
			}
			set
			{
				m_MaxLength = value;
				text = edition.CullString(text);
			}
		}

		bool ITextEdition.isDelayed { get; set; }

		Func<char, bool> ITextEdition.AcceptCharacter { get; set; }

		Action<bool> ITextEdition.UpdateScrollOffset { get; set; }

		Action ITextEdition.UpdateValueFromText { get; set; }

		Action ITextEdition.UpdateTextFromValue { get; set; }

		Action ITextEdition.MoveFocusToCompositeRoot { get; set; }

		char ITextEdition.maskChar
		{
			get
			{
				return m_MaskChar;
			}
			set
			{
				if (m_MaskChar != value)
				{
					m_MaskChar = value;
					if (edition.isPassword)
					{
						IncrementVersion(VersionChangeType.Repaint);
					}
				}
			}
		}

		private char effectiveMaskChar => edition.isPassword ? m_MaskChar : '\0';

		bool ITextEdition.isPassword
		{
			get
			{
				return m_IsPassword;
			}
			set
			{
				if (m_IsPassword != value)
				{
					m_IsPassword = value;
					IncrementVersion(VersionChangeType.Repaint);
				}
			}
		}

		bool ITextEdition.autoCorrection
		{
			get
			{
				return m_AutoCorrection;
			}
			set
			{
				m_AutoCorrection = value;
			}
		}

		internal string renderedText
		{
			get
			{
				if (effectiveMaskChar != 0)
				{
					return "".PadLeft(text.Length, effectiveMaskChar) + "\u200b";
				}
				return string.IsNullOrEmpty(m_RenderedText) ? "\u200b" : m_RenderedText;
			}
			set
			{
				m_RenderedText = value + "\u200b";
			}
		}

		internal string originalText => m_OriginalText;

		public new ITextElementExperimentalFeatures experimental => this;

		public ITextSelection selection => this;

		bool ITextSelection.isSelectable
		{
			get
			{
				return m_IsSelectable && base.focusable;
			}
			set
			{
				if (value != m_IsSelectable)
				{
					base.focusable = value;
					m_IsSelectable = value;
				}
			}
		}

		int ITextSelection.cursorIndex
		{
			get
			{
				return selection.isSelectable ? selectingManipulator.cursorIndex : (-1);
			}
			set
			{
				if (selection.isSelectable)
				{
					selectingManipulator.cursorIndex = value;
				}
			}
		}

		int ITextSelection.selectIndex
		{
			get
			{
				return selection.isSelectable ? selectingManipulator.selectIndex : (-1);
			}
			set
			{
				if (selection.isSelectable)
				{
					selectingManipulator.selectIndex = value;
				}
			}
		}

		bool ITextSelection.doubleClickSelectsWord { get; set; } = true;

		bool ITextSelection.tripleClickSelectsLine { get; set; } = true;

		bool ITextSelection.selectAllOnFocus { get; set; } = false;

		bool ITextSelection.selectAllOnMouseUp { get; set; } = false;

		Vector2 ITextSelection.cursorPosition => uitkTextHandle.GetCursorPositionFromStringIndexUsingLineHeight(selection.cursorIndex) + base.contentRect.min;

		float ITextSelection.lineHeightAtCursorPosition => uitkTextHandle.GetLineHeightFromCharacterIndex(selection.cursorIndex);

		Color ITextSelection.selectionColor
		{
			get
			{
				return m_SelectionColor;
			}
			set
			{
				if (!(m_SelectionColor == value))
				{
					m_SelectionColor = value;
					MarkDirtyRepaint();
				}
			}
		}

		Color ITextSelection.cursorColor
		{
			get
			{
				return m_CursorColor;
			}
			set
			{
				if (!(m_CursorColor == value))
				{
					m_CursorColor = value;
					MarkDirtyRepaint();
				}
			}
		}

		private Color cursorColor
		{
			get
			{
				return selection.cursorColor;
			}
			set
			{
				selection.cursorColor = value;
			}
		}

		float ITextSelection.cursorWidth
		{
			get
			{
				return m_CursorWidth;
			}
			set
			{
				if (!Mathf.Approximately(m_CursorWidth, value))
				{
					m_CursorWidth = value;
					MarkDirtyRepaint();
				}
			}
		}

		internal TextSelectingManipulator selectingManipulator => m_SelectingManipulator ?? (m_SelectingManipulator = new TextSelectingManipulator(this));

		public TextElement()
		{
			base.requireMeasureFunction = true;
			base.tabIndex = -1;
			uitkTextHandle = new UITKTextHandle(this);
			AddToClassList(ussClassName);
			base.generateVisualContent = (Action<MeshGenerationContext>)Delegate.Combine(base.generateVisualContent, new Action<MeshGenerationContext>(OnGenerateVisualContent));
			RegisterCallback<GeometryChangedEvent>(OnGeometryChanged);
		}

		private void OnGeometryChanged(GeometryChangedEvent e)
		{
			UpdateVisibleText();
		}

		internal void OnGenerateVisualContent(MeshGenerationContext mgc)
		{
			UpdateVisibleText();
			mgc.Text(this);
			if (ShouldElide() && uitkTextHandle.TextLibraryCanElide())
			{
				isElided = uitkTextHandle.IsElided();
			}
			UpdateTooltip();
			if (selection.HasSelection() && selectingManipulator.HasFocus())
			{
				DrawHighlighting(mgc);
			}
			else if (!edition.isReadOnly && selection.isSelectable && selectingManipulator.RevealCursor())
			{
				DrawCaret(mgc);
			}
		}

		internal string ElideText(string drawText, string ellipsisText, float width, TextOverflowPosition textOverflowPosition)
		{
			float num = base.resolvedStyle.paddingRight;
			if (float.IsNaN(num))
			{
				num = 0f;
			}
			float num2 = Mathf.Clamp(num, 1f / base.scaledPixelsPerPoint, 1f);
			if (MeasureTextSize(drawText, 0f, MeasureMode.Undefined, 0f, MeasureMode.Undefined).x <= width + num2 || string.IsNullOrEmpty(ellipsisText))
			{
				return drawText;
			}
			string text = ((drawText.Length > 1) ? ellipsisText : drawText);
			if (MeasureTextSize(text, 0f, MeasureMode.Undefined, 0f, MeasureMode.Undefined).x >= width)
			{
				return text;
			}
			int num3 = drawText.Length - 1;
			int num4 = -1;
			string text2 = drawText;
			int num5 = ((textOverflowPosition == TextOverflowPosition.Start) ? 1 : 0);
			int num6 = ((textOverflowPosition == TextOverflowPosition.Start || textOverflowPosition == TextOverflowPosition.Middle) ? num3 : (num3 - 1));
			for (int num7 = (num5 + num6) / 2; num5 <= num6; num7 = (num5 + num6) / 2)
			{
				switch (textOverflowPosition)
				{
				case TextOverflowPosition.Start:
					text2 = ellipsisText + drawText.Substring(num7, num3 - (num7 - 1));
					break;
				case TextOverflowPosition.End:
					text2 = drawText.Substring(0, num7) + ellipsisText;
					break;
				case TextOverflowPosition.Middle:
					text2 = ((num7 - 1 <= 0) ? "" : drawText.Substring(0, num7 - 1)) + ellipsisText + ((num3 - (num7 - 1) <= 0) ? "" : drawText.Substring(num3 - (num7 - 1)));
					break;
				}
				Vector2 vector = MeasureTextSize(text2, 0f, MeasureMode.Undefined, 0f, MeasureMode.Undefined);
				if (Math.Abs(vector.x - width) < 1E-30f)
				{
					return text2;
				}
				switch (textOverflowPosition)
				{
				case TextOverflowPosition.Start:
					if (vector.x > width)
					{
						if (num4 == num7 - 1)
						{
							return ellipsisText + drawText.Substring(num4, num3 - (num4 - 1));
						}
						num5 = num7 + 1;
					}
					else
					{
						num6 = num7 - 1;
						num4 = num7;
					}
					continue;
				default:
					if (textOverflowPosition != TextOverflowPosition.Middle)
					{
						continue;
					}
					break;
				case TextOverflowPosition.End:
					break;
				}
				if (vector.x > width)
				{
					if (num4 == num7 - 1)
					{
						if (textOverflowPosition == TextOverflowPosition.End)
						{
							return drawText.Substring(0, num4) + ellipsisText;
						}
						return drawText.Substring(0, Mathf.Max(num4 - 1, 0)) + ellipsisText + drawText.Substring(num3 - Mathf.Max(num4 - 1, 0));
					}
					num6 = num7 - 1;
				}
				else
				{
					num5 = num7 + 1;
					num4 = num7;
				}
			}
			return text2;
		}

		private void UpdateTooltip()
		{
			if (displayTooltipWhenElided && isElided)
			{
				base.tooltip = text;
				m_WasElided = true;
			}
			else if (m_WasElided)
			{
				base.tooltip = null;
				m_WasElided = false;
			}
		}

		private void UpdateVisibleText()
		{
			bool flag = ShouldElide();
			if (!flag || !uitkTextHandle.TextLibraryCanElide())
			{
				if (flag)
				{
					elidedText = ElideText(text, k_EllipsisText, base.contentRect.width, base.computedStyle.unityTextOverflowPosition);
					isElided = flag && elidedText != text;
				}
				else
				{
					isElided = false;
				}
			}
		}

		private bool ShouldElide()
		{
			return base.computedStyle.textOverflow == TextOverflow.Ellipsis && base.computedStyle.overflow == OverflowInternal.Hidden;
		}

		public Vector2 MeasureTextSize(string textToMeasure, float width, MeasureMode widthMode, float height, MeasureMode heightMode)
		{
			return TextUtilities.MeasureVisualElementTextSize(this, textToMeasure, width, widthMode, height, heightMode);
		}

		protected internal override Vector2 DoMeasure(float desiredWidth, MeasureMode widthMode, float desiredHeight, MeasureMode heightMode)
		{
			return MeasureTextSize(renderedText, desiredWidth, widthMode, desiredHeight, heightMode);
		}

		void INotifyValueChanged<string>.SetValueWithoutNotify(string newValue)
		{
			newValue = ((ITextEdition)this).CullString(newValue);
			if (m_Text != newValue)
			{
				renderedText = newValue;
				m_Text = newValue;
				IncrementVersion(VersionChangeType.Layout | VersionChangeType.Repaint);
				if (!string.IsNullOrEmpty(base.viewDataKey))
				{
					SaveViewData();
				}
			}
			if (editingManipulator != null)
			{
				editingManipulator.editingUtilities.text = newValue;
			}
		}

		private void ProcessMenuCommand(string command)
		{
			using ExecuteCommandEvent executeCommandEvent = CommandEventBase<ExecuteCommandEvent>.GetPooled(command);
			executeCommandEvent.target = this;
			SendEvent(executeCommandEvent);
		}

		private void Cut(DropdownMenuAction a)
		{
			ProcessMenuCommand("Cut");
		}

		private void Copy(DropdownMenuAction a)
		{
			ProcessMenuCommand("Copy");
		}

		private void Paste(DropdownMenuAction a)
		{
			ProcessMenuCommand("Paste");
		}

		private void BuildContextualMenu(ContextualMenuPopulateEvent evt)
		{
			if (evt?.target is TextElement)
			{
				if (!edition.isReadOnly)
				{
					evt.menu.AppendAction("Cut", Cut, CutActionStatus);
					evt.menu.AppendAction("Copy", Copy, CopyActionStatus);
					evt.menu.AppendAction("Paste", Paste, PasteActionStatus);
				}
				else
				{
					evt.menu.AppendAction("Copy", Copy, CopyActionStatus);
				}
			}
		}

		private DropdownMenuAction.Status CutActionStatus(DropdownMenuAction a)
		{
			return (base.enabledInHierarchy && selection.HasSelection() && !edition.isPassword) ? DropdownMenuAction.Status.Normal : DropdownMenuAction.Status.Disabled;
		}

		private DropdownMenuAction.Status CopyActionStatus(DropdownMenuAction a)
		{
			return ((!base.enabledInHierarchy || selection.HasSelection()) && !edition.isPassword) ? DropdownMenuAction.Status.Normal : DropdownMenuAction.Status.Disabled;
		}

		private DropdownMenuAction.Status PasteActionStatus(DropdownMenuAction a)
		{
			bool flag = editingManipulator.editingUtilities.CanPaste();
			return (!base.enabledInHierarchy) ? DropdownMenuAction.Status.Hidden : (flag ? DropdownMenuAction.Status.Normal : DropdownMenuAction.Status.Disabled);
		}

		[EventInterest(new Type[]
		{
			typeof(ContextualMenuPopulateEvent),
			typeof(FocusInEvent),
			typeof(FocusOutEvent),
			typeof(KeyDownEvent),
			typeof(KeyUpEvent),
			typeof(FocusEvent),
			typeof(BlurEvent),
			typeof(ValidateCommandEvent),
			typeof(ExecuteCommandEvent),
			typeof(PointerDownEvent),
			typeof(PointerUpEvent),
			typeof(PointerMoveEvent),
			typeof(NavigationMoveEvent),
			typeof(NavigationSubmitEvent),
			typeof(NavigationCancelEvent)
		})]
		protected override void ExecuteDefaultActionAtTarget(EventBase evt)
		{
			if (!selection.isSelectable)
			{
				return;
			}
			bool flag = editingManipulator?.editingUtilities.TouchScreenKeyboardShouldBeUsed() ?? false;
			if (!flag || (flag && edition.hideMobileInput))
			{
				selectingManipulator?.ExecuteDefaultActionAtTarget(evt);
			}
			if (!edition.isReadOnly)
			{
				editingManipulator?.ExecuteDefaultActionAtTarget(evt);
			}
			base.elementPanel?.contextualMenuManager?.DisplayMenuIfEventMatches(evt, this);
			if (evt?.eventTypeId == EventBase<ContextualMenuPopulateEvent>.TypeId())
			{
				ContextualMenuPopulateEvent contextualMenuPopulateEvent = evt as ContextualMenuPopulateEvent;
				int count = contextualMenuPopulateEvent.menu.MenuItems().Count;
				BuildContextualMenu(contextualMenuPopulateEvent);
				if (count > 0 && contextualMenuPopulateEvent.menu.MenuItems().Count > count)
				{
					contextualMenuPopulateEvent.menu.InsertSeparator(null, count);
				}
			}
		}

		void ITextEdition.ResetValueAndText()
		{
			string text = (this.text = null);
			m_OriginalText = text;
		}

		void ITextEdition.SaveValueAndText()
		{
			m_OriginalText = text;
		}

		void ITextEdition.RestoreValueAndText()
		{
			text = m_OriginalText;
		}

		void ITextEdition.UpdateText(string value)
		{
			if (m_TouchScreenKeyboard != null && m_TouchScreenKeyboard.text != value)
			{
				m_TouchScreenKeyboard.text = value;
			}
			if (text != value)
			{
				using (InputEvent inputEvent = InputEvent.GetPooled(text, value))
				{
					inputEvent.target = base.parent;
					((INotifyValueChanged<string>)this).SetValueWithoutNotify(value);
					base.parent?.SendEvent(inputEvent);
				}
			}
		}

		string ITextEdition.CullString(string s)
		{
			int maxLength = edition.maxLength;
			if (maxLength >= 0 && s != null && s.Length > maxLength)
			{
				return s.Substring(0, maxLength);
			}
			return s;
		}

		void ITextElementExperimentalFeatures.SetRenderedText(string renderedText)
		{
			this.renderedText = renderedText;
		}

		void ITextSelection.SelectAll()
		{
			if (selection.isSelectable)
			{
				selectingManipulator.m_SelectingUtilities.SelectAll();
			}
		}

		void ITextSelection.SelectNone()
		{
			if (selection.isSelectable)
			{
				selectingManipulator.m_SelectingUtilities.SelectNone();
			}
		}

		void ITextSelection.SelectRange(int cursorIndex, int selectionIndex)
		{
			if (selection.isSelectable)
			{
				selectingManipulator.m_SelectingUtilities.cursorIndex = cursorIndex;
				selectingManipulator.m_SelectingUtilities.selectIndex = selectionIndex;
			}
		}

		bool ITextSelection.HasSelection()
		{
			return selection.isSelectable && selectingManipulator.HasSelection();
		}

		void ITextSelection.MoveTextEnd()
		{
			if (selection.isSelectable)
			{
				selectingManipulator.m_SelectingUtilities.MoveTextEnd();
			}
		}

		private void DrawHighlighting(MeshGenerationContext mgc)
		{
			Color playmodeTintColor = ((base.panel.contextType == ContextType.Editor) ? UIElementsUtility.editorPlayModeTintColor : Color.white);
			int index = Math.Min(selection.cursorIndex, selection.selectIndex);
			int index2 = Math.Max(selection.cursorIndex, selection.selectIndex);
			Vector2 cursorPositionFromStringIndexUsingLineHeight = uitkTextHandle.GetCursorPositionFromStringIndexUsingLineHeight(index);
			Vector2 cursorPositionFromStringIndexUsingLineHeight2 = uitkTextHandle.GetCursorPositionFromStringIndexUsingLineHeight(index2);
			int lineNumber = uitkTextHandle.GetLineNumber(index);
			int lineNumber2 = uitkTextHandle.GetLineNumber(index2);
			float lineHeight = uitkTextHandle.GetLineHeight(lineNumber);
			Vector2 min = base.contentRect.min;
			if (m_TouchScreenKeyboard != null && m_HideMobileInput)
			{
				UnityEngine.TextCore.Text.TextInfo textInfo = uitkTextHandle.textInfo;
				int num = ((selection.selectIndex < selection.cursorIndex) ? textInfo.textElementInfo[selection.selectIndex].index : textInfo.textElementInfo[selection.cursorIndex].index);
				int length = ((selection.selectIndex < selection.cursorIndex) ? (selection.cursorIndex - num) : (selection.selectIndex - num));
				m_TouchScreenKeyboard.selection = new RangeInt(num, length);
			}
			if (lineNumber == lineNumber2)
			{
				cursorPositionFromStringIndexUsingLineHeight += min;
				cursorPositionFromStringIndexUsingLineHeight2 += min;
				mgc.Rectangle(new MeshGenerationContextUtils.RectangleParams
				{
					rect = new Rect(cursorPositionFromStringIndexUsingLineHeight.x, cursorPositionFromStringIndexUsingLineHeight.y - lineHeight, cursorPositionFromStringIndexUsingLineHeight2.x - cursorPositionFromStringIndexUsingLineHeight.x, lineHeight),
					color = selection.selectionColor,
					playmodeTintColor = playmodeTintColor
				});
				return;
			}
			for (int i = lineNumber; i <= lineNumber2; i++)
			{
				if (i == lineNumber)
				{
					int lastCharacterAt = GetLastCharacterAt(i);
					cursorPositionFromStringIndexUsingLineHeight2 = uitkTextHandle.GetCursorPositionFromStringIndexUsingLineHeight(lastCharacterAt, useXAdvance: true);
				}
				else if (i == lineNumber2)
				{
					int firstCharacterIndex = uitkTextHandle.textInfo.lineInfo[i].firstCharacterIndex;
					cursorPositionFromStringIndexUsingLineHeight = uitkTextHandle.GetCursorPositionFromStringIndexUsingLineHeight(firstCharacterIndex);
					cursorPositionFromStringIndexUsingLineHeight2 = uitkTextHandle.GetCursorPositionFromStringIndexUsingLineHeight(index2, useXAdvance: true);
				}
				else if (i != lineNumber && i != lineNumber2)
				{
					int firstCharacterIndex = uitkTextHandle.textInfo.lineInfo[i].firstCharacterIndex;
					cursorPositionFromStringIndexUsingLineHeight = uitkTextHandle.GetCursorPositionFromStringIndexUsingLineHeight(firstCharacterIndex);
					int lastCharacterAt = GetLastCharacterAt(i);
					cursorPositionFromStringIndexUsingLineHeight2 = uitkTextHandle.GetCursorPositionFromStringIndexUsingLineHeight(lastCharacterAt, useXAdvance: true);
				}
				cursorPositionFromStringIndexUsingLineHeight += min;
				cursorPositionFromStringIndexUsingLineHeight2 += min;
				mgc.Rectangle(new MeshGenerationContextUtils.RectangleParams
				{
					rect = new Rect(cursorPositionFromStringIndexUsingLineHeight.x, cursorPositionFromStringIndexUsingLineHeight.y - lineHeight, cursorPositionFromStringIndexUsingLineHeight2.x - cursorPositionFromStringIndexUsingLineHeight.x, lineHeight),
					color = selection.selectionColor,
					playmodeTintColor = playmodeTintColor
				});
			}
		}

		internal void DrawCaret(MeshGenerationContext mgc)
		{
			Color playmodeTintColor = ((base.panel.contextType == ContextType.Editor) ? UIElementsUtility.editorPlayModeTintColor : Color.white);
			float characterHeightFromIndex = uitkTextHandle.GetCharacterHeightFromIndex(selection.cursorIndex);
			float width = AlignmentUtils.CeilToPixelGrid(selection.cursorWidth, base.scaledPixelsPerPoint);
			mgc.Rectangle(new MeshGenerationContextUtils.RectangleParams
			{
				rect = new Rect(selection.cursorPosition.x, selection.cursorPosition.y - characterHeightFromIndex, width, characterHeightFromIndex),
				color = selection.cursorColor,
				playmodeTintColor = playmodeTintColor
			});
		}

		private int GetLastCharacterAt(int lineIndex)
		{
			int num = uitkTextHandle.textInfo.lineInfo[lineIndex].lastCharacterIndex;
			int firstCharacterIndex = uitkTextHandle.textInfo.lineInfo[lineIndex].firstCharacterIndex;
			TextElementInfo textElementInfo = uitkTextHandle.textInfo.textElementInfo[num];
			while ((textElementInfo.character == '\n' || textElementInfo.character == '\r') && num > firstCharacterIndex)
			{
				num--;
				textElementInfo = uitkTextHandle.textInfo.textElementInfo[num];
			}
			return num;
		}
	}
	public interface ITextEdition
	{
		internal bool multiline { get; set; }

		bool isReadOnly { get; set; }

		int maxLength { get; set; }

		bool isDelayed { get; set; }

		internal Func<char, bool> AcceptCharacter { get; set; }

		internal Action<bool> UpdateScrollOffset { get; set; }

		internal Action UpdateValueFromText { get; set; }

		internal Action UpdateTextFromValue { get; set; }

		internal Action MoveFocusToCompositeRoot { get; set; }

		char maskChar { get; set; }

		bool isPassword { get; set; }

		bool autoCorrection
		{
			get
			{
				Debug.Log("Type " + GetType().Name + " implementing interface ITextEdition is missing the implementation for autoCorrection. Calling ITextEdition.autoCorrection of this type will always return false.");
				return false;
			}
			set
			{
				Debug.Log("Type " + GetType().Name + " implementing interface ITextEdition is missing the implementation for autoCorrection. Assigning a value to ITextEdition.autoCorrection will not update its value.");
			}
		}

		bool hideMobileInput
		{
			get
			{
				Debug.Log("Type " + GetType().Name + " implementing interface ITextEdition is missing the implementation for hideMobileInput. Calling ITextEdition.hideMobileInput of this type will always return false.");
				return false;
			}
			set
			{
				Debug.Log("Type " + GetType().Name + " implementing interface ITextEdition is missing the implementation for hideMobileInput. Assigning a value to ITextEdition.hideMobileInput will not update its value.");
			}
		}

		TouchScreenKeyboard touchScreenKeyboard
		{
			get
			{
				Debug.Log("Type " + GetType().Name + " implementing interface ITextEdition is missing the implementation for touchScreenKeyboard. Calling ITextEdition.touchScreenKeyboard of this type will always return null.");
				return null;
			}
		}

		TouchScreenKeyboardType keyboardType
		{
			get
			{
				Debug.Log("Type " + GetType().Name + " implementing interface ITextEdition is missing the implementation for keyboardType. Calling ITextEdition.keyboardType of this type will always return Default.");
				return TouchScreenKeyboardType.Default;
			}
			set
			{
				Debug.Log("Type " + GetType().Name + " implementing interface ITextEdition is missing the implementation for keyboardType. Assigning a value to ITextEdition.keyboardType will not update its value.");
			}
		}

		internal void ResetValueAndText();

		internal void SaveValueAndText();

		internal void RestoreValueAndText();

		internal void UpdateText(string value);

		internal string CullString(string s);
	}
	public interface ITextElementExperimentalFeatures : IExperimentalFeatures
	{
		void SetRenderedText(string renderedText);
	}
	public interface ITextSelection
	{
		bool isSelectable { get; set; }

		Color cursorColor { get; set; }

		int cursorIndex { get; set; }

		bool doubleClickSelectsWord { get; set; }

		int selectIndex { get; set; }

		Color selectionColor { get; set; }

		bool tripleClickSelectsLine { get; set; }

		internal bool selectAllOnFocus { get; set; }

		internal bool selectAllOnMouseUp { get; set; }

		Vector2 cursorPosition { get; }

		internal float lineHeightAtCursorPosition { get; }

		internal float cursorWidth { get; set; }

		bool HasSelection();

		void SelectAll();

		void SelectNone();

		void SelectRange(int cursorIndex, int selectionIndex);

		internal void MoveTextEnd();
	}
	public struct TextShadow : IEquatable<TextShadow>
	{
		public Vector2 offset;

		public float blurRadius;

		public Color color;

		public override bool Equals(object obj)
		{
			return obj is TextShadow && Equals((TextShadow)obj);
		}

		public bool Equals(TextShadow other)
		{
			return other.offset == offset && other.blurRadius == blurRadius && other.color == color;
		}

		public override int GetHashCode()
		{
			int num = 1500536833;
			num = num * -1521134295 + offset.GetHashCode();
			num = num * -1521134295 + blurRadius.GetHashCode();
			return num * -1521134295 + color.GetHashCode();
		}

		public static bool operator ==(TextShadow style1, TextShadow style2)
		{
			return style1.Equals(style2);
		}

		public static bool operator !=(TextShadow style1, TextShadow style2)
		{
			return !(style1 == style2);
		}

		public override string ToString()
		{
			return $"offset={offset}, blurRadius={blurRadius}, color={color}";
		}

		internal static TextShadow LerpUnclamped(TextShadow a, TextShadow b, float t)
		{
			return new TextShadow
			{
				offset = Vector2.LerpUnclamped(a.offset, b.offset, t),
				blurRadius = Mathf.LerpUnclamped(a.blurRadius, b.blurRadius, t),
				color = Color.LerpUnclamped(a.color, b.color, t)
			};
		}
	}
	internal abstract class UIElementsBridge
	{
		public abstract void SetWantsMouseJumping(int value);
	}
	internal class RuntimeUIElementsBridge : UIElementsBridge
	{
		public override void SetWantsMouseJumping(int value)
		{
		}
	}
	internal static class UIElementsPackageUtility
	{
		internal static bool IsUIEPackageLoaded { get; private set; }

		internal static string EditorResourcesBasePath { get; private set; }

		static UIElementsPackageUtility()
		{
			Refresh();
		}

		internal static void Refresh()
		{
			EditorResourcesBasePath = "";
			IsUIEPackageLoaded = false;
		}
	}
	internal static class UIElementsRuntimeUtility
	{
		public delegate BaseRuntimePanel CreateRuntimePanelDelegate(ScriptableObject ownerObject);

		private static bool s_RegisteredPlayerloopCallback;

		private static List<Panel> s_SortedRuntimePanels;

		private static bool s_PanelOrderingDirty;

		internal static int s_ResolvedSortingIndexMax;

		internal static readonly string s_RepaintProfilerMarkerName;

		private static readonly ProfilerMarker s_RepaintProfilerMarker;

		private static int currentOverlayIndex;

		private static DefaultEventSystem s_DefaultEventSystem;

		private static List<PanelSettings> s_PotentiallyEmptyPanelSettings;

		internal static Object activeEventSystem { get; private set; }

		internal static bool useDefaultEventSystem => activeEventSystem == null;

		internal static DefaultEventSystem defaultEventSystem => s_DefaultEventSystem ?? (s_DefaultEventSystem = new DefaultEventSystem());

		private static event Action s_onRepaintOverlayPanels;

		internal static event Action onRepaintOverlayPanels
		{
			add
			{
				if (UIElementsRuntimeUtility.s_onRepaintOverlayPanels == null)
				{
					RegisterPlayerloopCallback();
				}
				s_onRepaintOverlayPanels += value;
			}
			remove
			{
				s_onRepaintOverlayPanels -= value;
				if (UIElementsRuntimeUtility.s_onRepaintOverlayPanels == null)
				{
					UnregisterPlayerloopCallback();
				}
			}
		}

		public static event Action<BaseRuntimePanel> onCreatePanel;

		static UIElementsRuntimeUtility()
		{
			s_RegisteredPlayerloopCallback = false;
			s_SortedRuntimePanels = new List<Panel>();
			s_PanelOrderingDirty = true;
			s_ResolvedSortingIndexMax = 0;
			s_RepaintProfilerMarkerName = "UIElementsRuntimeUtility.DoDispatch(Repaint Event)";
			s_RepaintProfilerMarker = new ProfilerMarker(s_RepaintProfilerMarkerName);
			currentOverlayIndex = -1;
			s_PotentiallyEmptyPanelSettings = new List<PanelSettings>();
			UIElementsRuntimeUtilityNative.RepaintOverlayPanelsCallback = delegate
			{
			};
			UIElementsRuntimeUtilityNative.RepaintOffscreenPanelsCallback = RepaintOffscreenPanels;
			Canvas.externBeginRenderOverlays = BeginRenderOverlays;
			Canvas.externRenderOverlaysBefore = delegate(int displayIndex, int sortOrder)
			{
				RenderOverlaysBeforePriority(displayIndex, sortOrder);
			};
			Canvas.externEndRenderOverlays = EndRenderOverlays;
		}

		public static EventBase CreateEvent(Event systemEvent)
		{
			return UIElementsUtility.CreateEvent(systemEvent, systemEvent.rawType);
		}

		public static BaseRuntimePanel FindOrCreateRuntimePanel(ScriptableObject ownerObject, CreateRuntimePanelDelegate createDelegate)
		{
			if (UIElementsUtility.TryGetPanel(ownerObject.GetInstanceID(), out var panel))
			{
				if (panel is BaseRuntimePanel result)
				{
					return result;
				}
				RemoveCachedPanelInternal(ownerObject.GetInstanceID());
			}
			BaseRuntimePanel baseRuntimePanel = createDelegate(ownerObject);
			baseRuntimePanel.IMGUIEventInterests = new EventInterests
			{
				wantsMouseMove = true,
				wantsMouseEnterLeaveWindow = true
			};
			RegisterCachedPanelInternal(ownerObject.GetInstanceID(), baseRuntimePanel);
			UIElementsRuntimeUtility.onCreatePanel?.Invoke(baseRuntimePanel);
			return baseRuntimePanel;
		}

		public static void DisposeRuntimePanel(ScriptableObject ownerObject)
		{
			if (UIElementsUtility.TryGetPanel(ownerObject.GetInstanceID(), out var panel))
			{
				panel.Dispose();
				RemoveCachedPanelInternal(ownerObject.GetInstanceID());
			}
		}

		private static void RegisterCachedPanelInternal(int instanceID, IPanel panel)
		{
			UIElementsUtility.RegisterCachedPanel(instanceID, panel as Panel);
			s_PanelOrderingDirty = true;
			if (!s_RegisteredPlayerloopCallback)
			{
				s_RegisteredPlayerloopCallback = true;
				RegisterPlayerloopCallback();
				Canvas.SetExternalCanvasEnabled(enabled: true);
			}
		}

		private static void RemoveCachedPanelInternal(int instanceID)
		{
			UIElementsUtility.RemoveCachedPanel(instanceID);
			s_PanelOrderingDirty = true;
			s_SortedRuntimePanels.Clear();
			UIElementsUtility.GetAllPanels(s_SortedRuntimePanels, ContextType.Player);
			if (s_SortedRuntimePanels.Count == 0)
			{
				s_RegisteredPlayerloopCallback = false;
				UnregisterPlayerloopCallback();
				Canvas.SetExternalCanvasEnabled(enabled: false);
			}
		}

		public static void RepaintOverlayPanels()
		{
			foreach (BaseRuntimePanel sortedPlayerPanel in GetSortedPlayerPanels())
			{
				if (!sortedPlayerPanel.drawToCameras)
				{
					RepaintOverlayPanel(sortedPlayerPanel);
				}
			}
			if (UIElementsRuntimeUtility.s_onRepaintOverlayPanels != null)
			{
				UIElementsRuntimeUtility.s_onRepaintOverlayPanels();
			}
		}

		public static void RepaintOffscreenPanels()
		{
			foreach (BaseRuntimePanel sortedPlayerPanel in GetSortedPlayerPanels())
			{
				if (sortedPlayerPanel.targetTexture != null)
				{
					RepaintOverlayPanel(sortedPlayerPanel);
				}
			}
		}

		public static void RepaintOverlayPanel(BaseRuntimePanel panel)
		{
			Camera current = Camera.current;
			RenderTexture active = RenderTexture.active;
			using (s_RepaintProfilerMarker.Auto())
			{
				panel.Repaint(Event.current);
			}
			Camera.SetupCurrent(current);
			RenderTexture.active = active;
		}

		internal static void BeginRenderOverlays(int displayIndex)
		{
			currentOverlayIndex = 0;
		}

		internal static void RenderOverlaysBeforePriority(int displayIndex, float maxPriority)
		{
			if (currentOverlayIndex < 0)
			{
				return;
			}
			List<Panel> sortedPlayerPanels = GetSortedPlayerPanels();
			while (currentOverlayIndex < sortedPlayerPanels.Count)
			{
				if (sortedPlayerPanels[currentOverlayIndex] is BaseRuntimePanel baseRuntimePanel)
				{
					if (baseRuntimePanel.sortingPriority >= maxPriority)
					{
						break;
					}
					if (baseRuntimePanel.targetDisplay == displayIndex)
					{
						RepaintOverlayPanel(baseRuntimePanel);
					}
				}
				currentOverlayIndex++;
			}
		}

		internal static void EndRenderOverlays(int displayIndex)
		{
			RenderOverlaysBeforePriority(displayIndex, float.MaxValue);
			currentOverlayIndex = -1;
		}

		public static void RegisterEventSystem(Object eventSystem)
		{
			if (activeEventSystem != null && activeEventSystem != eventSystem && eventSystem.GetType().Name == "EventSystem")
			{
				Debug.LogWarning("There can be only one active Event System.");
			}
			activeEventSystem = eventSystem;
		}

		public static void UnregisterEventSystem(Object eventSystem)
		{
			if (activeEventSystem == eventSystem)
			{
				activeEventSystem = null;
			}
		}

		public static void UpdateRuntimePanels()
		{
			RemoveUnusedPanels();
			foreach (BaseRuntimePanel sortedPlayerPanel in GetSortedPlayerPanels())
			{
				sortedPlayerPanel.Update();
			}
			if (Application.isPlaying && useDefaultEventSystem)
			{
				defaultEventSystem.Update(DefaultEventSystem.UpdateMode.IgnoreIfAppNotFocused);
			}
		}

		internal static void MarkPotentiallyEmpty(PanelSettings settings)
		{
			if (!s_PotentiallyEmptyPanelSettings.Contains(settings))
			{
				s_PotentiallyEmptyPanelSettings.Add(settings);
			}
		}

		internal static void RemoveUnusedPanels()
		{
			foreach (PanelSettings s_PotentiallyEmptyPanelSetting in s_PotentiallyEmptyPanelSettings)
			{
				UIDocumentList attachedUIDocumentsList = s_PotentiallyEmptyPanelSetting.m_AttachedUIDocumentsList;
				if (attachedUIDocumentsList == null || attachedUIDocumentsList.m_AttachedUIDocuments.Count == 0)
				{
					s_PotentiallyEmptyPanelSetting.DisposePanel();
				}
			}
			s_PotentiallyEmptyPanelSettings.Clear();
		}

		public static void RegisterPlayerloopCallback()
		{
			UIElementsRuntimeUtilityNative.RegisterPlayerloopCallback();
			UIElementsRuntimeUtilityNative.UpdateRuntimePanelsCallback = UpdateRuntimePanels;
		}

		public static void UnregisterPlayerloopCallback()
		{
			UIElementsRuntimeUtilityNative.UnregisterPlayerloopCallback();
			UIElementsRuntimeUtilityNative.UpdateRuntimePanelsCallback = null;
		}

		internal static void SetPanelOrderingDirty()
		{
			s_PanelOrderingDirty = true;
		}

		internal static List<Panel> GetSortedPlayerPanels()
		{
			if (s_PanelOrderingDirty)
			{
				SortPanels();
			}
			return s_SortedRuntimePanels;
		}

		private static void SortPanels()
		{
			s_SortedRuntimePanels.Clear();
			UIElementsUtility.GetAllPanels(s_SortedRuntimePanels, ContextType.Player);
			s_SortedRuntimePanels.Sort(delegate(Panel a, Panel b)
			{
				BaseRuntimePanel baseRuntimePanel2 = a as BaseRuntimePanel;
				BaseRuntimePanel baseRuntimePanel3 = b as BaseRuntimePanel;
				if (baseRuntimePanel2 == null || baseRuntimePanel3 == null)
				{
					return 0;
				}
				float num2 = baseRuntimePanel2.sortingPriority - baseRuntimePanel3.sortingPriority;
				return Mathf.Approximately(0f, num2) ? baseRuntimePanel2.m_RuntimePanelCreationIndex.CompareTo(baseRuntimePanel3.m_RuntimePanelCreationIndex) : ((!(num2 < 0f)) ? 1 : (-1));
			});
			for (int num = 0; num < s_SortedRuntimePanels.Count; num++)
			{
				if (s_SortedRuntimePanels[num] is BaseRuntimePanel baseRuntimePanel)
				{
					baseRuntimePanel.resolvedSortingIndex = num;
				}
			}
			s_ResolvedSortingIndexMax = s_SortedRuntimePanels.Count - 1;
			s_PanelOrderingDirty = false;
		}

		internal static Vector2 MultiDisplayBottomLeftToPanelPosition(Vector2 position, out int? targetDisplay)
		{
			Vector2 position2 = MultiDisplayToLocalScreenPosition(position, out targetDisplay);
			return ScreenBottomLeftToPanelPosition(position2, targetDisplay.GetValueOrDefault());
		}

		internal static Vector2 MultiDisplayToLocalScreenPosition(Vector2 position, out int? targetDisplay)
		{
			Vector3 vector = Display.RelativeMouseAt(position);
			if (vector != Vector3.zero)
			{
				targetDisplay = (int)vector.z;
				return vector;
			}
			targetDisplay = null;
			return position;
		}

		internal static Vector2 ScreenBottomLeftToPanelPosition(Vector2 position, int targetDisplay)
		{
			int num = Screen.height;
			if (targetDisplay > 0 && targetDisplay < Display.displays.Length)
			{
				num = Display.displays[targetDisplay].systemHeight;
			}
			position.y = (float)num - position.y;
			return position;
		}

		internal static Vector2 ScreenBottomLeftToPanelDelta(Vector2 delta)
		{
			delta.y = 0f - delta.y;
			return delta;
		}
	}
	internal interface IUIElementsUtility
	{
		bool TakeCapture();

		bool ReleaseCapture();

		bool ProcessEvent(int instanceID, IntPtr nativeEventPtr, ref bool eventHandled);

		bool CleanupRoots();

		bool EndContainerGUIFromException(Exception exception);

		bool MakeCurrentIMGUIContainerDirty();

		void UpdateSchedulers();

		void RequestRepaintForPanels(Action<ScriptableObject> repaintCallback);
	}
	internal static class UIEventRegistration
	{
		private static List<IUIElementsUtility> s_Utilities;

		static UIEventRegistration()
		{
			s_Utilities = new List<IUIElementsUtility>();
			GUIUtility.takeCapture = (Action)Delegate.Combine(GUIUtility.takeCapture, (Action)delegate
			{
				TakeCapture();
			});
			GUIUtility.releaseCapture = (Action)Delegate.Combine(GUIUtility.releaseCapture, (Action)delegate
			{
				ReleaseCapture();
			});
			GUIUtility.processEvent = (Func<int, IntPtr, bool>)Delegate.Combine(GUIUtility.processEvent, (Func<int, IntPtr, bool>)((int i, IntPtr ptr) => ProcessEvent(i, ptr)));
			GUIUtility.cleanupRoots = (Action)Delegate.Combine(GUIUtility.cleanupRoots, (Action)delegate
			{
				CleanupRoots();
			});
			GUIUtility.endContainerGUIFromException = (Func<Exception, bool>)Delegate.Combine(GUIUtility.endContainerGUIFromException, (Func<Exception, bool>)((Exception exception) => EndContainerGUIFromException(exception)));
			GUIUtility.guiChanged = (Action)Delegate.Combine(GUIUtility.guiChanged, (Action)delegate
			{
				MakeCurrentIMGUIContainerDirty();
			});
		}

		internal static void RegisterUIElementSystem(IUIElementsUtility utility)
		{
			s_Utilities.Insert(0, utility);
		}

		private static void TakeCapture()
		{
			foreach (IUIElementsUtility s_Utility in s_Utilities)
			{
				if (s_Utility.TakeCapture())
				{
					break;
				}
			}
		}

		private static void ReleaseCapture()
		{
			foreach (IUIElementsUtility s_Utility in s_Utilities)
			{
				if (s_Utility.ReleaseCapture())
				{
					break;
				}
			}
		}

		private static bool EndContainerGUIFromException(Exception exception)
		{
			foreach (IUIElementsUtility s_Utility in s_Utilities)
			{
				if (s_Utility.EndContainerGUIFromException(exception))
				{
					return true;
				}
			}
			return GUIUtility.ShouldRethrowException(exception);
		}

		private static bool ProcessEvent(int instanceID, IntPtr nativeEventPtr)
		{
			bool eventHandled = false;
			foreach (IUIElementsUtility s_Utility in s_Utilities)
			{
				if (s_Utility.ProcessEvent(instanceID, nativeEventPtr, ref eventHandled))
				{
					return eventHandled;
				}
			}
			return false;
		}

		private static void CleanupRoots()
		{
			foreach (IUIElementsUtility s_Utility in s_Utilities)
			{
				if (s_Utility.CleanupRoots())
				{
					break;
				}
			}
		}

		internal static void MakeCurrentIMGUIContainerDirty()
		{
			foreach (IUIElementsUtility s_Utility in s_Utilities)
			{
				if (s_Utility.MakeCurrentIMGUIContainerDirty())
				{
					break;
				}
			}
		}

		internal static void UpdateSchedulers()
		{
			foreach (IUIElementsUtility s_Utility in s_Utilities)
			{
				s_Utility.UpdateSchedulers();
			}
		}

		internal static void RequestRepaintForPanels(Action<ScriptableObject> repaintCallback)
		{
			foreach (IUIElementsUtility s_Utility in s_Utilities)
			{
				s_Utility.RequestRepaintForPanels(repaintCallback);
			}
		}
	}
	internal class UIElementsUtility : IUIElementsUtility
	{
		private static Stack<IMGUIContainer> s_ContainerStack = new Stack<IMGUIContainer>();

		private static Dictionary<int, Panel> s_UIElementsCache = new Dictionary<int, Panel>();

		private static Event s_EventInstance = new Event();

		internal static Color editorPlayModeTintColor = Color.white;

		internal static float singleLineHeight = 18f;

		public const string hiddenClassName = "unity-hidden";

		private static UIElementsUtility s_Instance = new UIElementsUtility();

		internal static List<Panel> s_PanelsIterationList = new List<Panel>();

		internal static readonly string s_RepaintProfilerMarkerName = "UIElementsUtility.DoDispatch(Repaint Event)";

		internal static readonly string s_EventProfilerMarkerName = "UIElementsUtility.DoDispatch(Non Repaint Event)";

		private static readonly ProfilerMarker s_RepaintProfilerMarker = new ProfilerMarker(s_RepaintProfilerMarkerName);

		private static readonly ProfilerMarker s_EventProfilerMarker = new ProfilerMarker(s_EventProfilerMarkerName);

		internal static char[] s_Modifiers = new char[5] { '&', '%', '^', '#', '_' };

		private UIElementsUtility()
		{
			UIEventRegistration.RegisterUIElementSystem(this);
		}

		internal static IMGUIContainer GetCurrentIMGUIContainer()
		{
			if (s_ContainerStack.Count > 0)
			{
				return s_ContainerStack.Peek();
			}
			return null;
		}

		bool IUIElementsUtility.MakeCurrentIMGUIContainerDirty()
		{
			if (s_ContainerStack.Count > 0)
			{
				s_ContainerStack.Peek().MarkDirtyLayout();
				return true;
			}
			return false;
		}

		bool IUIElementsUtility.TakeCapture()
		{
			if (s_ContainerStack.Count > 0)
			{
				IMGUIContainer handler = s_ContainerStack.Peek();
				handler.CaptureMouse();
				return true;
			}
			return false;
		}

		bool IUIElementsUtility.ReleaseCapture()
		{
			return false;
		}

		bool IUIElementsUtility.ProcessEvent(int instanceID, IntPtr nativeEventPtr, ref bool eventHandled)
		{
			if (nativeEventPtr != IntPtr.Zero && s_UIElementsCache.TryGetValue(instanceID, out var value))
			{
				if (value.contextType == ContextType.Editor)
				{
					s_EventInstance.CopyFromPtr(nativeEventPtr);
					eventHandled = DoDispatch(value);
				}
				return true;
			}
			return false;
		}

		bool IUIElementsUtility.CleanupRoots()
		{
			s_EventInstance = null;
			s_UIElementsCache = null;
			s_ContainerStack = null;
			return false;
		}

		bool IUIElementsUtility.EndContainerGUIFromException(Exception exception)
		{
			if (s_ContainerStack.Count > 0)
			{
				GUIUtility.EndContainer();
				s_ContainerStack.Pop();
			}
			return false;
		}

		void IUIElementsUtility.UpdateSchedulers()
		{
			s_PanelsIterationList.Clear();
			GetAllPanels(s_PanelsIterationList, ContextType.Editor);
			foreach (Panel s_PanelsIteration in s_PanelsIterationList)
			{
				s_PanelsIteration.timerEventScheduler.UpdateScheduledEvents();
				s_PanelsIteration.ValidateFocus();
				s_PanelsIteration.UpdateAnimations();
				s_PanelsIteration.UpdateBindings();
			}
		}

		void IUIElementsUtility.RequestRepaintForPanels(Action<ScriptableObject> repaintCallback)
		{
			Dictionary<int, Panel>.Enumerator panelsIterator = GetPanelsIterator();
			while (panelsIterator.MoveNext())
			{
				Panel value = panelsIterator.Current.Value;
				if (value.contextType == ContextType.Editor && value.isDirty)
				{
					repaintCallback(value.ownerObject);
				}
			}
		}

		public static void RegisterCachedPanel(int instanceID, Panel panel)
		{
			s_UIElementsCache.Add(instanceID, panel);
		}

		public static void RemoveCachedPanel(int instanceID)
		{
			s_UIElementsCache.Remove(instanceID);
		}

		public static bool TryGetPanel(int instanceID, out Panel panel)
		{
			return s_UIElementsCache.TryGetValue(instanceID, out panel);
		}

		internal static void BeginContainerGUI(GUILayoutUtility.LayoutCache cache, Event evt, IMGUIContainer container)
		{
			if (container.useOwnerObjectGUIState)
			{
				GUIUtility.BeginContainerFromOwner(container.elementPanel.ownerObject);
			}
			else
			{
				GUIUtility.BeginContainer(container.guiState);
			}
			s_ContainerStack.Push(container);
			GUIUtility.s_SkinMode = (int)container.contextType;
			GUIUtility.s_OriginalID = container.elementPanel.ownerObject.GetInstanceID();
			if (Event.current == null)
			{
				Event.current = evt;
			}
			else
			{
				Event.current.CopyFrom(evt);
			}
			GUI.enabled = container.enabledInHierarchy;
			GUILayoutUtility.BeginContainer(cache);
			GUIUtility.ResetGlobalState();
		}

		internal static void EndContainerGUI(Event evt, Rect layoutSize)
		{
			if (Event.current.type == EventType.Layout && s_ContainerStack.Count > 0)
			{
				GUILayoutUtility.LayoutFromContainer(layoutSize.width, layoutSize.height);
			}
			GUILayoutUtility.SelectIDList(GUIUtility.s_OriginalID, isWindow: false);
			GUIContent.ClearStaticCache();
			if (s_ContainerStack.Count > 0)
			{
			}
			evt.CopyFrom(Event.current);
			if (s_ContainerStack.Count > 0)
			{
				GUIUtility.EndContainer();
				s_ContainerStack.Pop();
			}
		}

		internal static EventBase CreateEvent(Event systemEvent)
		{
			return CreateEvent(systemEvent, systemEvent.rawType);
		}

		internal static EventBase CreateEvent(Event systemEvent, EventType eventType)
		{
			switch (eventType)
			{
			case EventType.MouseMove:
			case EventType.TouchMove:
				return PointerEventBase<PointerMoveEvent>.GetPooled(systemEvent);
			case EventType.MouseDrag:
				return PointerEventBase<PointerMoveEvent>.GetPooled(systemEvent);
			case EventType.MouseDown:
			case EventType.TouchDown:
				if (PointerDeviceState.HasAdditionalPressedButtons(PointerId.mousePointerId, systemEvent.button))
				{
					return PointerEventBase<PointerMoveEvent>.GetPooled(systemEvent);
				}
				return PointerEventBase<PointerDownEvent>.GetPooled(systemEvent);
			case EventType.MouseUp:
			case EventType.TouchUp:
				if (PointerDeviceState.HasAdditionalPressedButtons(PointerId.mousePointerId, systemEvent.button))
				{
					return PointerEventBase<PointerMoveEvent>.GetPooled(systemEvent);
				}
				return PointerEventBase<PointerUpEvent>.GetPooled(systemEvent);
			case EventType.ContextClick:
				return MouseEventBase<ContextClickEvent>.GetPooled(systemEvent);
			case EventType.MouseEnterWindow:
				return MouseEventBase<MouseEnterWindowEvent>.GetPooled(systemEvent);
			case EventType.MouseLeaveWindow:
				return MouseLeaveWindowEvent.GetPooled(systemEvent);
			case EventType.ScrollWheel:
				return WheelEvent.GetPooled(systemEvent);
			case EventType.KeyDown:
				return KeyboardEventBase<KeyDownEvent>.GetPooled(systemEvent);
			case EventType.KeyUp:
				return KeyboardEventBase<KeyUpEvent>.GetPooled(systemEvent);
			case EventType.ValidateCommand:
				return CommandEventBase<ValidateCommandEvent>.GetPooled(systemEvent);
			case EventType.ExecuteCommand:
				return CommandEventBase<ExecuteCommandEvent>.GetPooled(systemEvent);
			default:
				return IMGUIEvent.GetPooled(systemEvent);
			}
		}

		private static bool DoDispatch(BaseVisualElementPanel panel)
		{
			Debug.Assert(panel.contextType == ContextType.Editor);
			bool result = false;
			if (s_EventInstance.type == EventType.Repaint)
			{
				Camera current = Camera.current;
				RenderTexture active = RenderTexture.active;
				Camera.SetupCurrent(null);
				RenderTexture.active = null;
				using (s_RepaintProfilerMarker.Auto())
				{
					panel.Repaint(s_EventInstance);
				}
				result = panel.IMGUIContainersCount > 0;
				Camera.SetupCurrent(current);
				RenderTexture.active = active;
			}
			else
			{
				panel.ValidateLayout();
				using EventBase eventBase = CreateEvent(s_EventInstance);
				bool flag = s_EventInstance.type == EventType.Used || s_EventInstance.type == EventType.Layout || s_EventInstance.type == EventType.ExecuteCommand || s_EventInstance.type == EventType.ValidateCommand;
				using (s_EventProfilerMarker.Auto())
				{
					panel.SendEvent(eventBase, (!flag) ? DispatchMode.Default : DispatchMode.Immediate);
				}
				if (eventBase.isPropagationStopped)
				{
					panel.visualTree.IncrementVersion(VersionChangeType.Repaint);
					result = true;
				}
			}
			return result;
		}

		internal static void GetAllPanels(List<Panel> panels, ContextType contextType)
		{
			Dictionary<int, Panel>.Enumerator panelsIterator = GetPanelsIterator();
			while (panelsIterator.MoveNext())
			{
				if (panelsIterator.Current.Value.contextType == contextType)
				{
					panels.Add(panelsIterator.Current.Value);
				}
			}
		}

		internal static Dictionary<int, Panel>.Enumerator GetPanelsIterator()
		{
			return s_UIElementsCache.GetEnumerator();
		}

		internal static Panel FindOrCreateEditorPanel(ScriptableObject ownerObject)
		{
			if (!s_UIElementsCache.TryGetValue(ownerObject.GetInstanceID(), out var value))
			{
				value = Panel.CreateEditorPanel(ownerObject);
				RegisterCachedPanel(ownerObject.GetInstanceID(), value);
			}
			else
			{
				Debug.Assert(ContextType.Editor == value.contextType, "Panel is not an editor panel.");
			}
			return value;
		}

		internal static float PixelsPerUnitScaleForElement(VisualElement ve, Sprite sprite)
		{
			if (ve == null || ve.elementPanel == null || sprite == null)
			{
				return 1f;
			}
			float referenceSpritePixelsPerUnit = ve.elementPanel.referenceSpritePixelsPerUnit;
			float pixelsPerUnit = sprite.pixelsPerUnit;
			pixelsPerUnit = Mathf.Max(0.01f, pixelsPerUnit);
			return referenceSpritePixelsPerUnit / pixelsPerUnit;
		}

		internal static string ParseMenuName(string menuName)
		{
			if (string.IsNullOrEmpty(menuName))
			{
				return string.Empty;
			}
			string text = menuName.TrimEnd();
			int num = text.LastIndexOf(' ');
			if (num > -1)
			{
				int num2 = Array.IndexOf(s_Modifiers, text[num + 1]);
				if (text.Length > num + 1 && num2 > -1)
				{
					text = text.Substring(0, num).TrimEnd();
				}
			}
			return text;
		}
	}
	internal class UpgradeConstants
	{
		public const string EditorNamespace = "UnityEditor.UIElements";

		public const string EditorAssembly = "UnityEditor.UIElementsModule";
	}
	internal struct RuleMatcher
	{
		public StyleSheet sheet;

		public StyleComplexSelector complexSelector;

		public RuleMatcher(StyleSheet sheet, StyleComplexSelector complexSelector, int styleSheetIndexInStack)
		{
			this.sheet = sheet;
			this.complexSelector = complexSelector;
		}

		public override string ToString()
		{
			return complexSelector.ToString();
		}
	}
	public static class UQuery
	{
		internal interface IVisualPredicateWrapper
		{
			bool Predicate(object e);
		}

		internal class IsOfType<T> : IVisualPredicateWrapper where T : VisualElement
		{
			public static IsOfType<T> s_Instance = new IsOfType<T>();

			public bool Predicate(object e)
			{
				return e is T;
			}
		}

		internal class PredicateWrapper<T> : IVisualPredicateWrapper where T : VisualElement
		{
			private Func<T, bool> predicate;

			public PredicateWrapper(Func<T, bool> p)
			{
				predicate = p;
			}

			public bool Predicate(object e)
			{
				if (e is T arg)
				{
					return predicate(arg);
				}
				return false;
			}
		}

		internal abstract class UQueryMatcher : HierarchyTraversal
		{
			internal List<RuleMatcher> m_Matchers;

			public override void Traverse(VisualElement element)
			{
				base.Traverse(element);
			}

			protected virtual bool OnRuleMatchedElement(RuleMatcher matcher, VisualElement element)
			{
				return false;
			}

			private static void NoProcessResult(VisualElement e, MatchResultInfo i)
			{
			}

			public override void TraverseRecursive(VisualElement element, int depth)
			{
				int count = m_Matchers.Count;
				int count2 = m_Matchers.Count;
				for (int i = 0; i < count2; i++)
				{
					RuleMatcher matcher = m_Matchers[i];
					if (StyleSelectorHelper.MatchRightToLeft(element, matcher.complexSelector, delegate(VisualElement e, MatchResultInfo i2)
					{
						NoProcessResult(e, i2);
					}) && OnRuleMatchedElement(matcher, element))
					{
						return;
					}
				}
				Recurse(element, depth);
				if (m_Matchers.Count > count)
				{
					m_Matchers.RemoveRange(count, m_Matchers.Count - count);
				}
			}

			public virtual void Run(VisualElement root, List<RuleMatcher> matchers)
			{
				m_Matchers = matchers;
				Traverse(root);
			}
		}

		internal abstract class SingleQueryMatcher : UQueryMatcher
		{
			public VisualElement match { get; set; }

			public override void Run(VisualElement root, List<RuleMatcher> matchers)
			{
				match = null;
				base.Run(root, matchers);
				m_Matchers = null;
			}

			public bool IsInUse()
			{
				return m_Matchers != null;
			}

			public abstract SingleQueryMatcher CreateNew();
		}

		internal class FirstQueryMatcher : SingleQueryMatcher
		{
			public static readonly FirstQueryMatcher Instance = new FirstQueryMatcher();

			protected override bool OnRuleMatchedElement(RuleMatcher matcher, VisualElement element)
			{
				if (base.match == null)
				{
					base.match = element;
				}
				return true;
			}

			public override SingleQueryMatcher CreateNew()
			{
				return new FirstQueryMatcher();
			}
		}

		internal class LastQueryMatcher : SingleQueryMatcher
		{
			public static readonly LastQueryMatcher Instance = new LastQueryMatcher();

			protected override bool OnRuleMatchedElement(RuleMatcher matcher, VisualElement element)
			{
				base.match = element;
				return false;
			}

			public override SingleQueryMatcher CreateNew()
			{
				return new LastQueryMatcher();
			}
		}

		internal class IndexQueryMatcher : SingleQueryMatcher
		{
			public static readonly IndexQueryMatcher Instance = new IndexQueryMatcher();

			private int matchCount = -1;

			private int _matchIndex;

			public int matchIndex
			{
				get
				{
					return _matchIndex;
				}
				set
				{
					matchCount = -1;
					_matchIndex = value;
				}
			}

			public override void Run(VisualElement root, List<RuleMatcher> matchers)
			{
				matchCount = -1;
				base.Run(root, matchers);
			}

			protected override bool OnRuleMatchedElement(RuleMatcher matcher, VisualElement element)
			{
				matchCount++;
				if (matchCount == _matchIndex)
				{
					base.match = element;
				}
				return matchCount >= _matchIndex;
			}

			public override SingleQueryMatcher CreateNew()
			{
				return new IndexQueryMatcher();
			}
		}
	}
	public struct UQueryState<T> : IEnumerable<T>, IEnumerable, IEquatable<UQueryState<T>> where T : VisualElement
	{
		private class ListQueryMatcher<TElement> : UQuery.UQueryMatcher where TElement : VisualElement
		{
			public List<TElement> matches { get; set; }

			protected override bool OnRuleMatchedElement(RuleMatcher matcher, VisualElement element)
			{
				matches.Add(element as TElement);
				return false;
			}

			public void Reset()
			{
				matches = null;
			}
		}

		private class ActionQueryMatcher : UQuery.UQueryMatcher
		{
			internal Action<T> callBack { get; set; }

			protected override bool OnRuleMatchedElement(RuleMatcher matcher, VisualElement element)
			{
				if (element is T obj)
				{
					callBack(obj);
				}
				return false;
			}
		}

		private class DelegateQueryMatcher<TReturnType> : UQuery.UQueryMatcher
		{
			public static DelegateQueryMatcher<TReturnType> s_Instance = new DelegateQueryMatcher<TReturnType>();

			public Func<T, TReturnType> callBack { get; set; }

			public List<TReturnType> result { get; set; }

			protected override bool OnRuleMatchedElement(RuleMatcher matcher, VisualElement element)
			{
				if (element is T arg)
				{
					result.Add(callBack(arg));
				}
				return false;
			}
		}

		public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
		{
			private List<VisualElement> iterationList;

			private int currentIndex;

			public T Current => (T)iterationList[currentIndex];

			object IEnumerator.Current => Current;

			internal Enumerator(UQueryState<T> queryState)
			{
				iterationList = VisualElementListPool.Get();
				UQueryState<T>.s_EnumerationList.matches = iterationList;
				UQueryState<T>.s_EnumerationList.Run(queryState.m_Element, queryState.m_Matchers);
				UQueryState<T>.s_EnumerationList.Reset();
				currentIndex = -1;
			}

			public bool MoveNext()
			{
				return ++currentIndex < iterationList.Count;
			}

			public void Reset()
			{
				currentIndex = -1;
			}

			public void Dispose()
			{
				VisualElementListPool.Release(iterationList);
				iterationList = null;
			}
		}

		private static ActionQueryMatcher s_Action = new ActionQueryMatcher();

		private readonly VisualElement m_Element;

		internal readonly List<RuleMatcher> m_Matchers;

		private static readonly ListQueryMatcher<T> s_List = new ListQueryMatcher<T>();

		private static readonly ListQueryMatcher<VisualElement> s_EnumerationList = new ListQueryMatcher<VisualElement>();

		internal UQueryState(VisualElement element, List<RuleMatcher> matchers)
		{
			m_Element = element;
			m_Matchers = matchers;
		}

		public UQueryState<T> RebuildOn(VisualElement element)
		{
			return new UQueryState<T>(element, m_Matchers);
		}

		private T Single(UQuery.SingleQueryMatcher matcher)
		{
			if (matcher.IsInUse())
			{
				matcher = matcher.CreateNew();
			}
			matcher.Run(m_Element, m_Matchers);
			T result = matcher.match as T;
			matcher.match = null;
			return result;
		}

		public T First()
		{
			return Single(UQuery.FirstQueryMatcher.Instance);
		}

		public T Last()
		{
			return Single(UQuery.LastQueryMatcher.Instance);
		}

		public void ToList(List<T> results)
		{
			s_List.matches = results;
			s_List.Run(m_Element, m_Matchers);
			s_List.Reset();
		}

		public List<T> ToList()
		{
			List<T> list = new List<T>();
			ToList(list);
			return list;
		}

		public T AtIndex(int index)
		{
			UQuery.IndexQueryMatcher instance = UQuery.IndexQueryMatcher.Instance;
			instance.matchIndex = index;
			return Single(instance);
		}

		public void ForEach(Action<T> funcCall)
		{
			ActionQueryMatcher actionQueryMatcher = s_Action;
			if (actionQueryMatcher.callBack != null)
			{
				actionQueryMatcher = new ActionQueryMatcher();
			}
			try
			{
				actionQueryMatcher.callBack = funcCall;
				actionQueryMatcher.Run(m_Element, m_Matchers);
			}
			finally
			{
				actionQueryMatcher.callBack = null;
			}
		}

		public void ForEach<T2>(List<T2> result, Func<T, T2> funcCall)
		{
			DelegateQueryMatcher<T2> delegateQueryMatcher = DelegateQueryMatcher<T2>.s_Instance;
			if (delegateQueryMatcher.callBack != null)
			{
				delegateQueryMatcher = new DelegateQueryMatcher<T2>();
			}
			try
			{
				delegateQueryMatcher.callBack = funcCall;
				delegateQueryMatcher.result = result;
				delegateQueryMatcher.Run(m_Element, m_Matchers);
			}
			finally
			{
				delegateQueryMatcher.callBack = null;
				delegateQueryMatcher.result = null;
			}
		}

		public List<T2> ForEach<T2>(Func<T, T2> funcCall)
		{
			List<T2> result = new List<T2>();
			ForEach(result, funcCall);
			return result;
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public bool Equals(UQueryState<T> other)
		{
			return m_Element == other.m_Element && EqualityComparer<List<RuleMatcher>>.Default.Equals(m_Matchers, other.m_Matchers);
		}

		public override bool Equals(object obj)
		{
			if (!(obj is UQueryState<T>))
			{
				return false;
			}
			return Equals((UQueryState<T>)obj);
		}

		public override int GetHashCode()
		{
			int num = 488160421;
			num = num * -1521134295 + EqualityComparer<VisualElement>.Default.GetHashCode(m_Element);
			return num * -1521134295 + EqualityComparer<List<RuleMatcher>>.Default.GetHashCode(m_Matchers);
		}

		public static bool operator ==(UQueryState<T> state1, UQueryState<T> state2)
		{
			return state1.Equals(state2);
		}

		public static bool operator !=(UQueryState<T> state1, UQueryState<T> state2)
		{
			return !(state1 == state2);
		}
	}
	public struct UQueryBuilder<T> : IEquatable<UQueryBuilder<T>> where T : VisualElement
	{
		private List<StyleSelector> m_StyleSelectors;

		private List<StyleSelectorPart> m_Parts;

		private VisualElement m_Element;

		private List<RuleMatcher> m_Matchers;

		private StyleSelectorRelationship m_Relationship;

		private int pseudoStatesMask;

		private int negatedPseudoStatesMask;

		private List<StyleSelector> styleSelectors => m_StyleSelectors ?? (m_StyleSelectors = new List<StyleSelector>());

		private List<StyleSelectorPart> parts => m_Parts ?? (m_Parts = new List<StyleSelectorPart>());

		public UQueryBuilder(VisualElement visualElement)
		{
			this = default(UQueryBuilder<T>);
			m_Element = visualElement;
			m_Parts = null;
			m_StyleSelectors = null;
			m_Relationship = StyleSelectorRelationship.None;
			m_Matchers = new List<RuleMatcher>();
			pseudoStatesMask = (negatedPseudoStatesMask = 0);
		}

		public UQueryBuilder<T> Class(string classname)
		{
			AddClass(classname);
			return this;
		}

		public UQueryBuilder<T> Name(string id)
		{
			AddName(id);
			return this;
		}

		public UQueryBuilder<T2> Descendents<T2>(string name = null, params string[] classNames) where T2 : VisualElement
		{
			FinishCurrentSelector();
			AddType<T2>();
			AddName(name);
			AddClasses(classNames);
			return AddRelationship<T2>(StyleSelectorRelationship.Descendent);
		}

		public UQueryBuilder<T2> Descendents<T2>(string name = null, string classname = null) where T2 : VisualElement
		{
			FinishCurrentSelector();
			AddType<T2>();
			AddName(name);
			AddClass(classname);
			return AddRelationship<T2>(StyleSelectorRelationship.Descendent);
		}

		public UQueryBuilder<T2> Children<T2>(string name = null, params string[] classes) where T2 : VisualElement
		{
			FinishCurrentSelector();
			AddType<T2>();
			AddName(name);
			AddClasses(classes);
			return AddRelationship<T2>(StyleSelectorRelationship.Child);
		}

		public UQueryBuilder<T2> Children<T2>(string name = null, string className = null) where T2 : VisualElement
		{
			FinishCurrentSelector();
			AddType<T2>();
			AddName(name);
			AddClass(className);
			return AddRelationship<T2>(StyleSelectorRelationship.Child);
		}

		public UQueryBuilder<T2> OfType<T2>(string name = null, params string[] classes) where T2 : VisualElement
		{
			AddType<T2>();
			AddName(name);
			AddClasses(classes);
			return AddRelationship<T2>(StyleSelectorRelationship.None);
		}

		public UQueryBuilder<T2> OfType<T2>(string name = null, string className = null) where T2 : VisualElement
		{
			AddType<T2>();
			AddName(name);
			AddClass(className);
			return AddRelationship<T2>(StyleSelectorRelationship.None);
		}

		internal UQueryBuilder<T> SingleBaseType()
		{
			parts.Add(StyleSelectorPart.CreatePredicate(UQuery.IsOfType<T>.s_Instance));
			return this;
		}

		public UQueryBuilder<T> Where(Func<T, bool> selectorPredicate)
		{
			parts.Add(StyleSelectorPart.CreatePredicate(new UQuery.PredicateWrapper<T>(selectorPredicate)));
			return this;
		}

		private void AddClass(string c)
		{
			if (c != null)
			{
				parts.Add(StyleSelectorPart.CreateClass(c));
			}
		}

		private void AddClasses(params string[] classes)
		{
			if (classes != null)
			{
				for (int i = 0; i < classes.Length; i++)
				{
					AddClass(classes[i]);
				}
			}
		}

		private void AddName(string id)
		{
			if (id != null)
			{
				parts.Add(StyleSelectorPart.CreateId(id));
			}
		}

		private void AddType<T2>() where T2 : VisualElement
		{
			if (typeof(T2) != typeof(VisualElement))
			{
				parts.Add(StyleSelectorPart.CreatePredicate(UQuery.IsOfType<T2>.s_Instance));
			}
		}

		private UQueryBuilder<T> AddPseudoState(PseudoStates s)
		{
			pseudoStatesMask |= (int)s;
			return this;
		}

		private UQueryBuilder<T> AddNegativePseudoState(PseudoStates s)
		{
			negatedPseudoStatesMask |= (int)s;
			return this;
		}

		public UQueryBuilder<T> Active()
		{
			return AddPseudoState(PseudoStates.Active);
		}

		public UQueryBuilder<T> NotActive()
		{
			return AddNegativePseudoState(PseudoStates.Active);
		}

		public UQueryBuilder<T> Visible()
		{
			return Where((T e) => e.visible);
		}

		public UQueryBuilder<T> NotVisible()
		{
			return Where((T e) => !e.visible);
		}

		public UQueryBuilder<T> Hovered()
		{
			return AddPseudoState(PseudoStates.Hover);
		}

		public UQueryBuilder<T> NotHovered()
		{
			return AddNegativePseudoState(PseudoStates.Hover);
		}

		public UQueryBuilder<T> Checked()
		{
			return AddPseudoState(PseudoStates.Checked);
		}

		public UQueryBuilder<T> NotChecked()
		{
			return AddNegativePseudoState(PseudoStates.Checked);
		}

		[Obsolete("Use Checked() instead")]
		public UQueryBuilder<T> Selected()
		{
			return AddPseudoState(PseudoStates.Checked);
		}

		[Obsolete("Use NotChecked() instead")]
		public UQueryBuilder<T> NotSelected()
		{
			return AddNegativePseudoState(PseudoStates.Checked);
		}

		public UQueryBuilder<T> Enabled()
		{
			return AddNegativePseudoState(PseudoStates.Disabled);
		}

		public UQueryBuilder<T> NotEnabled()
		{
			return AddPseudoState(PseudoStates.Disabled);
		}

		public UQueryBuilder<T> Focused()
		{
			return AddPseudoState(PseudoStates.Focus);
		}

		public UQueryBuilder<T> NotFocused()
		{
			return AddNegativePseudoState(PseudoStates.Focus);
		}

		private UQueryBuilder<T2> AddRelationship<T2>(StyleSelectorRelationship relationship) where T2 : VisualElement
		{
			UQueryBuilder<T2> result = new UQueryBuilder<T2>(m_Element);
			result.m_Matchers = m_Matchers;
			result.m_Parts = m_Parts;
			result.m_StyleSelectors = m_StyleSelectors;
			result.m_Relationship = ((relationship == StyleSelectorRelationship.None) ? m_Relationship : relationship);
			result.pseudoStatesMask = pseudoStatesMask;
			result.negatedPseudoStatesMask = negatedPseudoStatesMask;
			return result;
		}

		private void AddPseudoStatesRuleIfNecessasy()
		{
			if (pseudoStatesMask != 0 || negatedPseudoStatesMask != 0)
			{
				parts.Add(new StyleSelectorPart
				{
					type = StyleSelectorType.PseudoClass
				});
			}
		}

		private void FinishSelector()
		{
			FinishCurrentSelector();
			if (styleSelectors.Count > 0)
			{
				StyleComplexSelector styleComplexSelector = new StyleComplexSelector();
				styleComplexSelector.selectors = styleSelectors.ToArray();
				styleSelectors.Clear();
				m_Matchers.Add(new RuleMatcher
				{
					complexSelector = styleComplexSelector
				});
			}
		}

		private bool CurrentSelectorEmpty()
		{
			return parts.Count == 0 && m_Relationship == StyleSelectorRelationship.None && pseudoStatesMask == 0 && negatedPseudoStatesMask == 0;
		}

		private void FinishCurrentSelector()
		{
			if (!CurrentSelectorEmpty())
			{
				StyleSelector styleSelector = new StyleSelector();
				styleSelector.previousRelationship = m_Relationship;
				AddPseudoStatesRuleIfNecessasy();
				styleSelector.parts = m_Parts.ToArray();
				styleSelector.pseudoStateMask = pseudoStatesMask;
				styleSelector.negatedPseudoStateMask = negatedPseudoStatesMask;
				styleSelectors.Add(styleSelector);
				m_Parts.Clear();
				pseudoStatesMask = (negatedPseudoStatesMask = 0);
			}
		}

		public UQueryState<T> Build()
		{
			FinishSelector();
			if (m_Matchers.Count == 0)
			{
				parts.Add(new StyleSelectorPart
				{
					type = StyleSelectorType.Wildcard
				});
				FinishSelector();
			}
			return new UQueryState<T>(m_Element, m_Matchers);
		}

		public static implicit operator T(UQueryBuilder<T> s)
		{
			return s.First();
		}

		public static bool operator ==(UQueryBuilder<T> builder1, UQueryBuilder<T> builder2)
		{
			return builder1.Equals(builder2);
		}

		public static bool operator !=(UQueryBuilder<T> builder1, UQueryBuilder<T> builder2)
		{
			return !(builder1 == builder2);
		}

		public T First()
		{
			return Build().First();
		}

		public T Last()
		{
			return Build().Last();
		}

		public List<T> ToList()
		{
			return Build().ToList();
		}

		public void ToList(List<T> results)
		{
			Build().ToList(results);
		}

		public T AtIndex(int index)
		{
			return Build().AtIndex(index);
		}

		public void ForEach<T2>(List<T2> result, Func<T, T2> funcCall)
		{
			Build().ForEach(result, funcCall);
		}

		public List<T2> ForEach<T2>(Func<T, T2> funcCall)
		{
			return Build().ForEach(funcCall);
		}

		public void ForEach(Action<T> funcCall)
		{
			Build().ForEach(funcCall);
		}

		public bool Equals(UQueryBuilder<T> other)
		{
			return EqualityComparer<List<StyleSelector>>.Default.Equals(m_StyleSelectors, other.m_StyleSelectors) && EqualityComparer<List<StyleSelector>>.Default.Equals(styleSelectors, other.styleSelectors) && EqualityComparer<List<StyleSelectorPart>>.Default.Equals(m_Parts, other.m_Parts) && EqualityComparer<List<StyleSelectorPart>>.Default.Equals(parts, other.parts) && m_Element == other.m_Element && EqualityComparer<List<RuleMatcher>>.Default.Equals(m_Matchers, other.m_Matchers) && m_Relationship == other.m_Relationship && pseudoStatesMask == other.pseudoStatesMask && negatedPseudoStatesMask == other.negatedPseudoStatesMask;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is UQueryBuilder<T>))
			{
				return false;
			}
			return Equals((UQueryBuilder<T>)obj);
		}

		public override int GetHashCode()
		{
			int num = -949812380;
			num = num * -1521134295 + EqualityComparer<List<StyleSelector>>.Default.GetHashCode(m_StyleSelectors);
			num = num * -1521134295 + EqualityComparer<List<StyleSelector>>.Default.GetHashCode(styleSelectors);
			num = num * -1521134295 + EqualityComparer<List<StyleSelectorPart>>.Default.GetHashCode(m_Parts);
			num = num * -1521134295 + EqualityComparer<List<StyleSelectorPart>>.Default.GetHashCode(parts);
			num = num * -1521134295 + EqualityComparer<VisualElement>.Default.GetHashCode(m_Element);
			num = num * -1521134295 + EqualityComparer<List<RuleMatcher>>.Default.GetHashCode(m_Matchers);
			num = num * -1521134295 + m_Relationship.GetHashCode();
			num = num * -1521134295 + pseudoStatesMask.GetHashCode();
			return num * -1521134295 + negatedPseudoStatesMask.GetHashCode();
		}
	}
	public static class UQueryExtensions
	{
		private class MissingVisualElementException : Exception
		{
			public MissingVisualElementException()
			{
			}

			public MissingVisualElementException(string message)
				: base(message)
			{
			}
		}

		private static UQueryState<VisualElement> SingleElementEmptyQuery = new UQueryBuilder<VisualElement>(null).Build();

		private static UQueryState<VisualElement> SingleElementNameQuery = new UQueryBuilder<VisualElement>(null).Name(string.Empty).Build();

		private static UQueryState<VisualElement> SingleElementClassQuery = new UQueryBuilder<VisualElement>(null).Class(string.Empty).Build();

		private static UQueryState<VisualElement> SingleElementNameAndClassQuery = new UQueryBuilder<VisualElement>(null).Name(string.Empty).Class(string.Empty).Build();

		private static UQueryState<VisualElement> SingleElementTypeQuery = new UQueryBuilder<VisualElement>(null).SingleBaseType().Build();

		private static UQueryState<VisualElement> SingleElementTypeAndNameQuery = new UQueryBuilder<VisualElement>(null).SingleBaseType().Name(string.Empty).Build();

		private static UQueryState<VisualElement> SingleElementTypeAndClassQuery = new UQueryBuilder<VisualElement>(null).SingleBaseType().Class(string.Empty).Build();

		private static UQueryState<VisualElement> SingleElementTypeAndNameAndClassQuery = new UQueryBuilder<VisualElement>(null).SingleBaseType().Name(string.Empty).Class(string.Empty)
			.Build();

		public static T Q<T>(this VisualElement e, string name = null, params string[] classes) where T : VisualElement
		{
			return e.Query<T>(name, classes).Build().First();
		}

		public static VisualElement Q(this VisualElement e, string name = null, params string[] classes)
		{
			return e.Query<VisualElement>(name, classes).Build().First();
		}

		public static T Q<T>(this VisualElement e, string name = null, string className = null) where T : VisualElement
		{
			if (typeof(T) == typeof(VisualElement))
			{
				return e.Q(name, className) as T;
			}
			UQueryState<VisualElement> uQueryState;
			if (name == null)
			{
				if (className == null)
				{
					uQueryState = SingleElementTypeQuery.RebuildOn(e);
					uQueryState.m_Matchers[0].complexSelector.selectors[0].parts[0] = StyleSelectorPart.CreatePredicate(UQuery.IsOfType<T>.s_Instance);
					return uQueryState.First() as T;
				}
				uQueryState = SingleElementTypeAndClassQuery.RebuildOn(e);
				uQueryState.m_Matchers[0].complexSelector.selectors[0].parts[0] = StyleSelectorPart.CreatePredicate(UQuery.IsOfType<T>.s_Instance);
				uQueryState.m_Matchers[0].complexSelector.selectors[0].parts[1] = StyleSelectorPart.CreateClass(className);
				return uQueryState.First() as T;
			}
			if (className == null)
			{
				uQueryState = SingleElementTypeAndNameQuery.RebuildOn(e);
				uQueryState.m_Matchers[0].complexSelector.selectors[0].parts[0] = StyleSelectorPart.CreatePredicate(UQuery.IsOfType<T>.s_Instance);
				uQueryState.m_Matchers[0].complexSelector.selectors[0].parts[1] = StyleSelectorPart.CreateId(name);
				return uQueryState.First() as T;
			}
			uQueryState = SingleElementTypeAndNameAndClassQuery.RebuildOn(e);
			uQueryState.m_Matchers[0].complexSelector.selectors[0].parts[0] = StyleSelectorPart.CreatePredicate(UQuery.IsOfType<T>.s_Instance);
			uQueryState.m_Matchers[0].complexSelector.selectors[0].parts[1] = StyleSelectorPart.CreateId(name);
			uQueryState.m_Matchers[0].complexSelector.selectors[0].parts[2] = StyleSelectorPart.CreateClass(className);
			return uQueryState.First() as T;
		}

		internal static T MandatoryQ<T>(this VisualElement e, string name, string className = null) where T : VisualElement
		{
			T val = e.Q<T>(name, className);
			if (val == null)
			{
				throw new MissingVisualElementException("Element not found: " + name);
			}
			return val;
		}

		public static VisualElement Q(this VisualElement e, string name = null, string className = null)
		{
			if (e == null)
			{
				throw new ArgumentNullException("e");
			}
			UQueryState<VisualElement> uQueryState;
			if (name == null)
			{
				if (className == null)
				{
					return SingleElementEmptyQuery.RebuildOn(e).First();
				}
				uQueryState = SingleElementClassQuery.RebuildOn(e);
				uQueryState.m_Matchers[0].complexSelector.selectors[0].parts[0] = StyleSelectorPart.CreateClass(className);
				return uQueryState.First();
			}
			if (className == null)
			{
				uQueryState = SingleElementNameQuery.RebuildOn(e);
				uQueryState.m_Matchers[0].complexSelector.selectors[0].parts[0] = StyleSelectorPart.CreateId(name);
				return uQueryState.First();
			}
			uQueryState = SingleElementNameAndClassQuery.RebuildOn(e);
			uQueryState.m_Matchers[0].complexSelector.selectors[0].parts[0] = StyleSelectorPart.CreateId(name);
			uQueryState.m_Matchers[0].complexSelector.selectors[0].parts[1] = StyleSelectorPart.CreateClass(className);
			return uQueryState.First();
		}

		internal static VisualElement MandatoryQ(this VisualElement e, string name, string className = null)
		{
			VisualElement visualElement = e.Q<VisualElement>(name, className);
			if (visualElement == null)
			{
				throw new MissingVisualElementException("Element not found: " + name);
			}
			return visualElement;
		}

		public static UQueryBuilder<VisualElement> Query(this VisualElement e, string name = null, params string[] classes)
		{
			return e.Query<VisualElement>(name, classes);
		}

		public static UQueryBuilder<VisualElement> Query(this VisualElement e, string name = null, string className = null)
		{
			return e.Query<VisualElement>(name, className);
		}

		public static UQueryBuilder<T> Query<T>(this VisualElement e, string name = null, params string[] classes) where T : VisualElement
		{
			if (e == null)
			{
				throw new ArgumentNullException("e");
			}
			return new UQueryBuilder<VisualElement>(e).OfType<T>(name, classes);
		}

		public static UQueryBuilder<T> Query<T>(this VisualElement e, string name = null, string className = null) where T : VisualElement
		{
			if (e == null)
			{
				throw new ArgumentNullException("e");
			}
			return new UQueryBuilder<VisualElement>(e).OfType<T>(name, className);
		}

		public static UQueryBuilder<VisualElement> Query(this VisualElement e)
		{
			if (e == null)
			{
				throw new ArgumentNullException("e");
			}
			return new UQueryBuilder<VisualElement>(e);
		}
	}
	public interface IUxmlAttributes
	{
		bool TryGetAttributeValue(string attributeName, out string value);
	}
	internal class UxmlGenericAttributeNames
	{
		internal const string k_NameAttributeName = "name";

		internal const string k_PathAttributeName = "path";

		internal const string k_SrcAttributeName = "src";
	}
	public class UxmlRootElementFactory : UxmlFactory<VisualElement, UxmlRootElementTraits>
	{
		internal const string k_ElementName = "UXML";

		public override string uxmlName => "UXML";

		public override string uxmlQualifiedName => uxmlNamespace + "." + uxmlName;

		public override string substituteForTypeName => string.Empty;

		public override string substituteForTypeNamespace => string.Empty;

		public override string substituteForTypeQualifiedName => string.Empty;

		public override VisualElement Create(IUxmlAttributes bag, CreationContext cc)
		{
			return null;
		}
	}
	public class UxmlRootElementTraits : UxmlTraits
	{
		protected UxmlStringAttributeDescription m_Name = new UxmlStringAttributeDescription
		{
			name = "name"
		};

		private UxmlStringAttributeDescription m_Class = new UxmlStringAttributeDescription
		{
			name = "class"
		};

		public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
		{
			get
			{
				yield return new UxmlChildElementDescription(typeof(VisualElement));
			}
		}
	}
	public class UxmlStyleFactory : UxmlFactory<VisualElement, UxmlStyleTraits>
	{
		internal const string k_ElementName = "Style";

		public override string uxmlName => "Style";

		public override string uxmlQualifiedName => uxmlNamespace + "." + uxmlName;

		public override string substituteForTypeName => typeof(VisualElement).Name;

		public override string substituteForTypeNamespace => typeof(VisualElement).Namespace ?? string.Empty;

		public override string substituteForTypeQualifiedName => typeof(VisualElement).FullName;

		public override VisualElement Create(IUxmlAttributes bag, CreationContext cc)
		{
			return null;
		}
	}
	public class UxmlStyleTraits : UxmlTraits
	{
		private UxmlStringAttributeDescription m_Name = new UxmlStringAttributeDescription
		{
			name = "name"
		};

		private UxmlStringAttributeDescription m_Path = new UxmlStringAttributeDescription
		{
			name = "path"
		};

		private UxmlStringAttributeDescription m_Src = new UxmlStringAttributeDescription
		{
			name = "src"
		};

		public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
		{
			get
			{
				yield break;
			}
		}
	}
	public class UxmlTemplateFactory : UxmlFactory<VisualElement, UxmlTemplateTraits>
	{
		internal const string k_ElementName = "Template";

		public override string uxmlName => "Template";

		public override string uxmlQualifiedName => uxmlNamespace + "." + uxmlName;

		public override string substituteForTypeName => typeof(VisualElement).Name;

		public override string substituteForTypeNamespace => typeof(VisualElement).Namespace ?? string.Empty;

		public override string substituteForTypeQualifiedName => typeof(VisualElement).FullName;

		public override VisualElement Create(IUxmlAttributes bag, CreationContext cc)
		{
			return null;
		}
	}
	public class UxmlTemplateTraits : UxmlTraits
	{
		private UxmlStringAttributeDescription m_Name = new UxmlStringAttributeDescription
		{
			name = "name",
			use = UxmlAttributeDescription.Use.Required
		};

		private UxmlStringAttributeDescription m_Path = new UxmlStringAttributeDescription
		{
			name = "path"
		};

		private UxmlStringAttributeDescription m_Src = new UxmlStringAttributeDescription
		{
			name = "src"
		};

		public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
		{
			get
			{
				yield break;
			}
		}
	}
	public class UxmlAttributeOverridesFactory : UxmlFactory<VisualElement, UxmlAttributeOverridesTraits>
	{
		internal const string k_ElementName = "AttributeOverrides";

		public override string uxmlName => "AttributeOverrides";

		public override string uxmlQualifiedName => uxmlNamespace + "." + uxmlName;

		public override string substituteForTypeName => typeof(VisualElement).Name;

		public override string substituteForTypeNamespace => typeof(VisualElement).Namespace ?? string.Empty;

		public override string substituteForTypeQualifiedName => typeof(VisualElement).FullName;

		public override VisualElement Create(IUxmlAttributes bag, CreationContext cc)
		{
			return null;
		}
	}
	public class UxmlAttributeOverridesTraits : UxmlTraits
	{
		internal const string k_ElementNameAttributeName = "element-name";

		private UxmlStringAttributeDescription m_ElementName = new UxmlStringAttributeDescription
		{
			name = "element-name",
			use = UxmlAttributeDescription.Use.Required
		};

		public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
		{
			get
			{
				yield break;
			}
		}
	}
	[Serializable]
	internal class TemplateAsset : VisualElementAsset
	{
		[Serializable]
		public struct AttributeOverride
		{
			public string m_ElementName;

			public string m_AttributeName;

			public string m_Value;
		}

		[SerializeField]
		private string m_TemplateAlias;

		[SerializeField]
		private List<AttributeOverride> m_AttributeOverrides;

		[SerializeField]
		private List<VisualTreeAsset.SlotUsageEntry> m_SlotUsages;

		public string templateAlias
		{
			get
			{
				return m_TemplateAlias;
			}
			set
			{
				m_TemplateAlias = value;
			}
		}

		public List<AttributeOverride> attributeOverrides
		{
			get
			{
				return (m_AttributeOverrides == null) ? (m_AttributeOverrides = new List<AttributeOverride>()) : m_AttributeOverrides;
			}
			set
			{
				m_AttributeOverrides = value;
			}
		}

		internal List<VisualTreeAsset.SlotUsageEntry> slotUsages
		{
			get
			{
				return m_SlotUsages;
			}
			set
			{
				m_SlotUsages = value;
			}
		}

		public TemplateAsset(string templateAlias, string fullTypeName)
			: base(fullTypeName)
		{
			Assert.IsFalse(string.IsNullOrEmpty(templateAlias), "Template alias must not be null or empty");
			m_TemplateAlias = templateAlias;
		}

		public void AddSlotUsage(string slotName, int resId)
		{
			if (m_SlotUsages == null)
			{
				m_SlotUsages = new List<VisualTreeAsset.SlotUsageEntry>();
			}
			m_SlotUsages.Add(new VisualTreeAsset.SlotUsageEntry(slotName, resId));
		}
	}
	internal class UxmlAssetAttributeDescription<T> : TypedUxmlAttributeDescription<T> where T : Object
	{
		public override string defaultValueAsString => base.defaultValue?.ToString() ?? "null";

		public UxmlAssetAttributeDescription()
		{
			base.type = "string";
			base.typeNamespace = "http://www.w3.org/2001/XMLSchema";
			base.defaultValue = null;
		}

		public override T GetValueFromBag(IUxmlAttributes bag, CreationContext cc)
		{
			string value = null;
			if (TryGetValueFromBag(bag, cc, (string s, string t) => s, null, ref value))
			{
				VisualTreeAsset visualTreeAsset = cc.visualTreeAsset;
				return ((object)visualTreeAsset != null) ? visualTreeAsset.GetAsset<T>(value) : null;
			}
			return null;
		}
	}
	public abstract class UxmlAttributeDescription
	{
		public enum Use
		{
			None,
			Optional,
			Prohibited,
			Required
		}

		protected const string xmlSchemaNamespace = "http://www.w3.org/2001/XMLSchema";

		private string[] m_ObsoleteNames;

		public string name { get; set; }

		public IEnumerable<string> obsoleteNames
		{
			get
			{
				return m_ObsoleteNames;
			}
			set
			{
				m_ObsoleteNames = value.ToArray();
			}
		}

		public string type { get; protected set; }

		public string typeNamespace { get; protected set; }

		public abstract string defaultValueAsString { get; }

		public Use use { get; set; }

		public UxmlTypeRestriction restriction { get; set; }

		protected UxmlAttributeDescription()
		{
			use = Use.Optional;
			restriction = null;
		}

		internal bool TryGetValueFromBagAsString(IUxmlAttributes bag, CreationContext cc, out string value)
		{
			if (name == null && (m_ObsoleteNames == null || m_ObsoleteNames.Length == 0))
			{
				Debug.LogError("Attribute description has no name.");
				value = null;
				return false;
			}
			bag.TryGetAttributeValue("name", out var value2);
			if (!string.IsNullOrEmpty(value2) && cc.attributeOverrides != null)
			{
				for (int i = 0; i < cc.attributeOverrides.Count; i++)
				{
					if (cc.attributeOverrides[i].m_ElementName != value2)
					{
						continue;
					}
					if (cc.attributeOverrides[i].m_AttributeName != name)
					{
						if (m_ObsoleteNames == null)
						{
							continue;
						}
						bool flag = false;
						for (int j = 0; j < m_ObsoleteNames.Length; j++)
						{
							if (cc.attributeOverrides[i].m_AttributeName == m_ObsoleteNames[j])
							{
								flag = true;
								break;
							}
						}
						if (!flag)
						{
							continue;
						}
					}
					value = cc.attributeOverrides[i].m_Value;
					return true;
				}
			}
			if (name == null)
			{
				for (int k = 0; k < m_ObsoleteNames.Length; k++)
				{
					if (bag.TryGetAttributeValue(m_ObsoleteNames[k], out value))
					{
						if (cc.visualTreeAsset != null)
						{
						}
						return true;
					}
				}
				value = null;
				return false;
			}
			if (!bag.TryGetAttributeValue(name, out value))
			{
				if (m_ObsoleteNames != null)
				{
					for (int l = 0; l < m_ObsoleteNames.Length; l++)
					{
						if (bag.TryGetAttributeValue(m_ObsoleteNames[l], out value))
						{
							if (cc.visualTreeAsset != null)
							{
							}
							return true;
						}
					}
				}
				value = null;
				return false;
			}
			return true;
		}

		protected bool TryGetValueFromBag<T>(IUxmlAttributes bag, CreationContext cc, Func<string, T, T> converterFunc, T defaultValue, ref T value)
		{
			if (TryGetValueFromBagAsString(bag, cc, out var value2))
			{
				if (converterFunc != null)
				{
					value = converterFunc(value2, defaultValue);
				}
				else
				{
					value = defaultValue;
				}
				return true;
			}
			return false;
		}

		protected T GetValueFromBag<T>(IUxmlAttributes bag, CreationContext cc, Func<string, T, T> converterFunc, T defaultValue)
		{
			if (converterFunc == null)
			{
				throw new ArgumentNullException("converterFunc");
			}
			if (TryGetValueFromBagAsString(bag, cc, out var value))
			{
				return converterFunc(value, defaultValue);
			}
			return defaultValue;
		}
	}
	public abstract class TypedUxmlAttributeDescription<T> : UxmlAttributeDescription
	{
		public T defaultValue { get; set; }

		public override string defaultValueAsString => defaultValue.ToString();

		public abstract T GetValueFromBag(IUxmlAttributes bag, CreationContext cc);
	}
	public class UxmlStringAttributeDescription : TypedUxmlAttributeDescription<string>
	{
		public override string defaultValueAsString => base.defaultValue;

		public UxmlStringAttributeDescription()
		{
			base.type = "string";
			base.typeNamespace = "http://www.w3.org/2001/XMLSchema";
			base.defaultValue = "";
		}

		public override string GetValueFromBag(IUxmlAttributes bag, CreationContext cc)
		{
			return GetValueFromBag(bag, cc, (string s, string t) => s, base.defaultValue);
		}

		public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref string value)
		{
			return TryGetValueFromBag(bag, cc, (string s, string t) => s, base.defaultValue, ref value);
		}
	}
	public class UxmlFloatAttributeDescription : TypedUxmlAttributeDescription<float>
	{
		public override string defaultValueAsString => base.defaultValue.ToString(CultureInfo.InvariantCulture.NumberFormat);

		public UxmlFloatAttributeDescription()
		{
			base.type = "float";
			base.typeNamespace = "http://www.w3.org/2001/XMLSchema";
			base.defaultValue = 0f;
		}

		public override float GetValueFromBag(IUxmlAttributes bag, CreationContext cc)
		{
			return GetValueFromBag(bag, cc, (string s, float f) => ConvertValueToFloat(s, f), base.defaultValue);
		}

		public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref float value)
		{
			return TryGetValueFromBag(bag, cc, (string s, float f) => ConvertValueToFloat(s, f), base.defaultValue, ref value);
		}

		private static float ConvertValueToFloat(string v, float defaultValue)
		{
			if (v == null || !float.TryParse(v, NumberStyles.Float, CultureInfo.InvariantCulture, out var result))
			{
				return defaultValue;
			}
			return result;
		}
	}
	public class UxmlDoubleAttributeDescription : TypedUxmlAttributeDescription<double>
	{
		public override string defaultValueAsString => base.defaultValue.ToString(CultureInfo.InvariantCulture.NumberFormat);

		public UxmlDoubleAttributeDescription()
		{
			base.type = "double";
			base.typeNamespace = "http://www.w3.org/2001/XMLSchema";
			base.defaultValue = 0.0;
		}

		public override double GetValueFromBag(IUxmlAttributes bag, CreationContext cc)
		{
			return GetValueFromBag(bag, cc, (string s, double d) => ConvertValueToDouble(s, d), base.defaultValue);
		}

		public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref double value)
		{
			return TryGetValueFromBag(bag, cc, (string s, double d) => ConvertValueToDouble(s, d), base.defaultValue, ref value);
		}

		private static double ConvertValueToDouble(string v, double defaultValue)
		{
			if (v == null || !double.TryParse(v, NumberStyles.Float, CultureInfo.InvariantCulture, out var result))
			{
				return defaultValue;
			}
			return result;
		}
	}
	public class UxmlIntAttributeDescription : TypedUxmlAttributeDescription<int>
	{
		public override string defaultValueAsString => base.defaultValue.ToString(CultureInfo.InvariantCulture.NumberFormat);

		public UxmlIntAttributeDescription()
		{
			base.type = "int";
			base.typeNamespace = "http://www.w3.org/2001/XMLSchema";
			base.defaultValue = 0;
		}

		public override int GetValueFromBag(IUxmlAttributes bag, CreationContext cc)
		{
			return GetValueFromBag(bag, cc, (string s, int i) => ConvertValueToInt(s, i), base.defaultValue);
		}

		public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref int value)
		{
			return TryGetValueFromBag(bag, cc, (string s, int i) => ConvertValueToInt(s, i), base.defaultValue, ref value);
		}

		private static int ConvertValueToInt(string v, int defaultValue)
		{
			if (v == null || !int.TryParse(v, out var result))
			{
				return defaultValue;
			}
			return result;
		}
	}
	public class UxmlUnsignedIntAttributeDescription : TypedUxmlAttributeDescription<uint>
	{
		public override string defaultValueAsString => base.defaultValue.ToString(CultureInfo.InvariantCulture.NumberFormat);

		public UxmlUnsignedIntAttributeDescription()
		{
			base.type = "unsignedInt";
			base.typeNamespace = "http://www.w3.org/2001/XMLSchema";
			base.defaultValue = 0u;
		}

		public override uint GetValueFromBag(IUxmlAttributes bag, CreationContext cc)
		{
			return GetValueFromBag(bag, cc, (string s, uint i) => ConvertValueToUInt(s, i), base.defaultValue);
		}

		public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref uint value)
		{
			return TryGetValueFromBag(bag, cc, (string s, uint i) => ConvertValueToUInt(s, i), base.defaultValue, ref value);
		}

		private static uint ConvertValueToUInt(string v, uint defaultValue)
		{
			if (v == null || !uint.TryParse(v, out var result))
			{
				return defaultValue;
			}
			return result;
		}
	}
	public class UxmlUnsignedLongAttributeDescription : TypedUxmlAttributeDescription<ulong>
	{
		public override string defaultValueAsString => base.defaultValue.ToString(CultureInfo.InvariantCulture.NumberFormat);

		public UxmlUnsignedLongAttributeDescription()
		{
			base.type = "unsignedLong";
			base.typeNamespace = "http://www.w3.org/2001/XMLSchema";
			base.defaultValue = 0uL;
		}

		public override ulong GetValueFromBag(IUxmlAttributes bag, CreationContext cc)
		{
			return GetValueFromBag(bag, cc, (string s, ulong l) => ConvertValueToUlong(s, l), base.defaultValue);
		}

		public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref ulong value)
		{
			return TryGetValueFromBag(bag, cc, (string s, ulong l) => ConvertValueToUlong(s, l), base.defaultValue, ref value);
		}

		private static ulong ConvertValueToUlong(string v, ulong defaultValue)
		{
			if (v == null || !ulong.TryParse(v, out var result))
			{
				return defaultValue;
			}
			return result;
		}
	}
	public class UxmlLongAttributeDescription : TypedUxmlAttributeDescription<long>
	{
		public override string defaultValueAsString => base.defaultValue.ToString(CultureInfo.InvariantCulture.NumberFormat);

		public UxmlLongAttributeDescription()
		{
			base.type = "long";
			base.typeNamespace = "http://www.w3.org/2001/XMLSchema";
			base.defaultValue = 0L;
		}

		public override long GetValueFromBag(IUxmlAttributes bag, CreationContext cc)
		{
			return GetValueFromBag(bag, cc, (string s, long l) => ConvertValueToLong(s, l), base.defaultValue);
		}

		public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref long value)
		{
			return TryGetValueFromBag(bag, cc, (string s, long l) => ConvertValueToLong(s, l), base.defaultValue, ref value);
		}

		private static long ConvertValueToLong(string v, long defaultValue)
		{
			if (v == null || !long.TryParse(v, out var result))
			{
				return defaultValue;
			}
			return result;
		}
	}
	public class UxmlBoolAttributeDescription : TypedUxmlAttributeDescription<bool>
	{
		public override string defaultValueAsString => base.defaultValue.ToString().ToLowerInvariant();

		public UxmlBoolAttributeDescription()
		{
			base.type = "boolean";
			base.typeNamespace = "http://www.w3.org/2001/XMLSchema";
			base.defaultValue = false;
		}

		public override bool GetValueFromBag(IUxmlAttributes bag, CreationContext cc)
		{
			return GetValueFromBag(bag, cc, (string s, bool b) => ConvertValueToBool(s, b), base.defaultValue);
		}

		public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref bool value)
		{
			return TryGetValueFromBag(bag, cc, (string s, bool b) => ConvertValueToBool(s, b), base.defaultValue, ref value);
		}

		private static bool ConvertValueToBool(string v, bool defaultValue)
		{
			if (v == null || !bool.TryParse(v, out var result))
			{
				return defaultValue;
			}
			return result;
		}
	}
	public class UxmlColorAttributeDescription : TypedUxmlAttributeDescription<Color>
	{
		public override string defaultValueAsString => base.defaultValue.ToString();

		public UxmlColorAttributeDescription()
		{
			base.type = "string";
			base.typeNamespace = "http://www.w3.org/2001/XMLSchema";
			base.defaultValue = new Color(0f, 0f, 0f, 1f);
		}

		public override Color GetValueFromBag(IUxmlAttributes bag, CreationContext cc)
		{
			return GetValueFromBag(bag, cc, (string s, Color color) => ConvertValueToColor(s, color), base.defaultValue);
		}

		public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref Color value)
		{
			return TryGetValueFromBag(bag, cc, (string s, Color color) => ConvertValueToColor(s, color), base.defaultValue, ref value);
		}

		private static Color ConvertValueToColor(string v, Color defaultValue)
		{
			if (v == null || !ColorUtility.TryParseHtmlString(v, out var color))
			{
				return defaultValue;
			}
			return color;
		}
	}
	public class UxmlTypeAttributeDescription<TBase> : TypedUxmlAttributeDescription<Type>
	{
		public override string defaultValueAsString => (base.defaultValue == null) ? "null" : base.defaultValue.FullName;

		public UxmlTypeAttributeDescription()
		{
			base.type = "string";
			base.typeNamespace = "http://www.w3.org/2001/XMLSchema";
			base.defaultValue = null;
		}

		public override Type GetValueFromBag(IUxmlAttributes bag, CreationContext cc)
		{
			return GetValueFromBag(bag, cc, (string s, Type type1) => ConvertValueToType(s, type1), base.defaultValue);
		}

		public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref Type value)
		{
			return TryGetValueFromBag(bag, cc, (string s, Type type1) => ConvertValueToType(s, type1), base.defaultValue, ref value);
		}

		private Type ConvertValueToType(string v, Type defaultValue)
		{
			if (string.IsNullOrEmpty(v))
			{
				return defaultValue;
			}
			try
			{
				Type type = Type.GetType(v, throwOnError: true);
				if (typeof(TBase).IsAssignableFrom(type))
				{
					return type;
				}
				Debug.LogError("Type: Invalid type \"" + v + "\". Type must derive from " + typeof(TBase).FullName + ".");
			}
			catch (Exception exception)
			{
				Debug.LogException(exception);
			}
			return defaultValue;
		}
	}
	public class UxmlEnumAttributeDescription<T> : TypedUxmlAttributeDescription<T> where T : struct, IConvertible
	{
		public override string defaultValueAsString => base.defaultValue.ToString(CultureInfo.InvariantCulture.NumberFormat);

		public UxmlEnumAttributeDescription()
		{
			if (!typeof(T).IsEnum)
			{
				throw new ArgumentException("T must be an enumerated type");
			}
			base.type = "string";
			base.typeNamespace = "http://www.w3.org/2001/XMLSchema";
			base.defaultValue = new T();
			UxmlEnumeration uxmlEnumeration = new UxmlEnumeration();
			List<string> list = new List<string>();
			foreach (T value in Enum.GetValues(typeof(T)))
			{
				list.Add(value.ToString(CultureInfo.InvariantCulture));
			}
			uxmlEnumeration.values = list;
			base.restriction = uxmlEnumeration;
		}

		public override T GetValueFromBag(IUxmlAttributes bag, CreationContext cc)
		{
			return GetValueFromBag(bag, cc, (string s, T convertible) => ConvertValueToEnum(s, convertible), base.defaultValue);
		}

		public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref T value)
		{
			return TryGetValueFromBag(bag, cc, (string s, T convertible) => ConvertValueToEnum(s, convertible), base.defaultValue, ref value);
		}

		private static U ConvertValueToEnum<U>(string v, U defaultValue) where U : struct
		{
			try
			{
				if (string.IsNullOrEmpty(v))
				{
					return defaultValue;
				}
				return (U)Enum.Parse(typeof(U), v, ignoreCase: true);
			}
			catch (ArgumentException)
			{
				Debug.LogError(GetEnumNameErrorMessage(v, typeof(U)));
			}
			catch (OverflowException)
			{
				Debug.LogError(GetEnumRangeErrorMessage(v, typeof(U)));
			}
			return defaultValue;
		}

		private static string GetEnumNameErrorMessage(string v, Type enumType)
		{
			return "The " + enumType.Name + " enum does not contain the value `" + v + "`. Value must be in range [" + string.Join(" | ", Enum.GetNames(enumType)) + "].";
		}

		private static string GetEnumRangeErrorMessage(string v, Type enumType)
		{
			return v + " is outside of the range of possible values for the " + enumType.Name + " enum.";
		}
	}
	public class UxmlHash128AttributeDescription : TypedUxmlAttributeDescription<Hash128>
	{
		public override string defaultValueAsString => base.defaultValue.ToString();

		public UxmlHash128AttributeDescription()
		{
			base.type = "string";
			base.typeNamespace = "http://www.w3.org/2001/XMLSchema";
			base.defaultValue = default(Hash128);
		}

		public override Hash128 GetValueFromBag(IUxmlAttributes bag, CreationContext cc)
		{
			return GetValueFromBag(bag, cc, (string s, Hash128 i) => i = Hash128.Parse(s), base.defaultValue);
		}

		public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref Hash128 value)
		{
			return TryGetValueFromBag(bag, cc, (string s, Hash128 i) => i = Hash128.Parse(s), base.defaultValue, ref value);
		}
	}
	internal class UxmlObjectAttributeDescription<T> where T : new()
	{
		public T defaultValue { get; set; }

		public virtual T GetValueFromBag(IUxmlAttributes bag, CreationContext cc)
		{
			List<T> list = cc.visualTreeAsset?.GetUxmlObjects<T>(bag, cc);
			if (list != null)
			{
				using List<T>.Enumerator enumerator = list.GetEnumerator();
				if (enumerator.MoveNext())
				{
					return enumerator.Current;
				}
			}
			return defaultValue;
		}
	}
	internal class UxmlObjectListAttributeDescription<T> : UxmlObjectAttributeDescription<List<T>> where T : new()
	{
		public override List<T> GetValueFromBag(IUxmlAttributes bag, CreationContext cc)
		{
			List<T> list = cc.visualTreeAsset?.GetUxmlObjects<T>(bag, cc);
			if (list != null)
			{
				List<T> list2 = null;
				foreach (T item in list)
				{
					if (list2 == null)
					{
						list2 = new List<T>();
					}
					list2.Add(item);
				}
				return list2;
			}
			return base.defaultValue;
		}
	}
	public class UxmlChildElementDescription
	{
		public string elementName { get; protected set; }

		public string elementNamespace { get; protected set; }

		public UxmlChildElementDescription(Type t)
		{
			if (t == null)
			{
				throw new ArgumentNullException("t");
			}
			elementName = t.Name;
			elementNamespace = t.Namespace;
		}
	}
	public abstract class BaseUxmlTraits
	{
		public bool canHaveAnyAttribute { get; protected set; }

		public virtual IEnumerable<UxmlAttributeDescription> uxmlAttributesDescription
		{
			get
			{
				foreach (UxmlAttributeDescription item in GetAllAttributeDescriptionForType(GetType()))
				{
					yield return item;
				}
			}
		}

		public virtual IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription
		{
			get
			{
				yield break;
			}
		}

		protected BaseUxmlTraits()
		{
			canHaveAnyAttribute = true;
		}

		private IEnumerable<UxmlAttributeDescription> GetAllAttributeDescriptionForType(Type t)
		{
			Type baseType = t.BaseType;
			if (baseType != null)
			{
				foreach (UxmlAttributeDescription item in GetAllAttributeDescriptionForType(baseType))
				{
					yield return item;
				}
			}
			foreach (FieldInfo fieldInfo in from f in t.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
				where typeof(UxmlAttributeDescription).IsAssignableFrom(f.FieldType)
				select f)
			{
				yield return (UxmlAttributeDescription)fieldInfo.GetValue(this);
			}
		}
	}
	public abstract class UxmlTraits : BaseUxmlTraits
	{
		public virtual void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc)
		{
		}
	}
	internal abstract class UxmlObjectTraits<T> : BaseUxmlTraits
	{
		public virtual void Init(ref T obj, IUxmlAttributes bag, CreationContext cc)
		{
		}
	}
	public interface IBaseUxmlFactory
	{
		string uxmlName { get; }

		string uxmlNamespace { get; }

		string uxmlQualifiedName { get; }

		Type uxmlType { get; }

		bool canHaveAnyAttribute { get; }

		IEnumerable<UxmlAttributeDescription> uxmlAttributesDescription { get; }

		IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }

		string substituteForTypeName { get; }

		string substituteForTypeNamespace { get; }

		string substituteForTypeQualifiedName { get; }

		bool AcceptsAttributeBag(IUxmlAttributes bag, CreationContext cc);
	}
	public interface IUxmlFactory : IBaseUxmlFactory
	{
		VisualElement Create(IUxmlAttributes bag, CreationContext cc);
	}
	internal interface IBaseUxmlObjectFactory : IBaseUxmlFactory
	{
	}
	internal interface IUxmlObjectFactory<out T> : IBaseUxmlObjectFactory, IBaseUxmlFactory where T : new()
	{
		T CreateObject(IUxmlAttributes bag, CreationContext cc);
	}
	public abstract class BaseUxmlFactory<TCreatedType, TTraits> where TCreatedType : new() where TTraits : BaseUxmlTraits, new()
	{
		internal TTraits m_Traits;

		public virtual string uxmlName => typeof(TCreatedType).Name;

		public virtual string uxmlNamespace => typeof(TCreatedType).Namespace ?? string.Empty;

		public virtual string uxmlQualifiedName => typeof(TCreatedType).FullName;

		public virtual Type uxmlType => typeof(TCreatedType);

		public bool canHaveAnyAttribute => m_Traits.canHaveAnyAttribute;

		public virtual IEnumerable<UxmlAttributeDescription> uxmlAttributesDescription => m_Traits.uxmlAttributesDescription;

		public virtual IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription => m_Traits.uxmlChildElementsDescription;

		public virtual string substituteForTypeName
		{
			get
			{
				if (typeof(TCreatedType) == typeof(VisualElement))
				{
					return string.Empty;
				}
				return typeof(VisualElement).Name;
			}
		}

		public virtual string substituteForTypeNamespace
		{
			get
			{
				if (typeof(TCreatedType) == typeof(VisualElement))
				{
					return string.Empty;
				}
				return typeof(VisualElement).Namespace ?? string.Empty;
			}
		}

		public virtual string substituteForTypeQualifiedName
		{
			get
			{
				if (typeof(TCreatedType) == typeof(VisualElement))
				{
					return string.Empty;
				}
				return typeof(VisualElement).FullName;
			}
		}

		protected BaseUxmlFactory()
		{
			m_Traits = new TTraits();
		}

		public virtual bool AcceptsAttributeBag(IUxmlAttributes bag, CreationContext cc)
		{
			return true;
		}
	}
	public class UxmlFactory<TCreatedType, TTraits> : BaseUxmlFactory<TCreatedType, TTraits>, IUxmlFactory, IBaseUxmlFactory where TCreatedType : VisualElement, new() where TTraits : UxmlTraits, new()
	{
		public virtual VisualElement Create(IUxmlAttributes bag, CreationContext cc)
		{
			TCreatedType val = new TCreatedType();
			m_Traits.Init(val, bag, cc);
			return val;
		}
	}
	internal class UxmlObjectFactory<TCreatedType, TTraits> : BaseUxmlFactory<TCreatedType, TTraits>, IUxmlObjectFactory<TCreatedType>, IBaseUxmlObjectFactory, IBaseUxmlFactory where TCreatedType : new() where TTraits : UxmlObjectTraits<TCreatedType>, new()
	{
		public virtual TCreatedType CreateObject(IUxmlAttributes bag, CreationContext cc)
		{
			TCreatedType obj = new TCreatedType();
			m_Traits.Init(ref obj, bag, cc);
			return obj;
		}
	}
	public class UxmlFactory<TCreatedType> : UxmlFactory<TCreatedType, VisualElement.UxmlTraits> where TCreatedType : VisualElement, new()
	{
	}
	[Serializable]
	internal class UxmlAsset : IUxmlAttributes
	{
		[SerializeField]
		private string m_FullTypeName;

		[SerializeField]
		private int m_Id;

		[SerializeField]
		private int m_OrderInDocument;

		[SerializeField]
		private int m_ParentId;

		[SerializeField]
		protected List<string> m_Properties;

		public string fullTypeName
		{
			get
			{
				return m_FullTypeName;
			}
			set
			{
				m_FullTypeName = value;
			}
		}

		public int id
		{
			get
			{
				return m_Id;
			}
			set
			{
				m_Id = value;
			}
		}

		public int orderInDocument
		{
			get
			{
				return m_OrderInDocument;
			}
			set
			{
				m_OrderInDocument = value;
			}
		}

		public int parentId
		{
			get
			{
				return m_ParentId;
			}
			set
			{
				m_ParentId = value;
			}
		}

		public UxmlAsset(string fullTypeName)
		{
			m_FullTypeName = fullTypeName;
		}

		public List<string> GetProperties()
		{
			return m_Properties;
		}

		public bool HasParent()
		{
			return m_ParentId != 0;
		}

		public bool HasAttribute(string attributeName)
		{
			if (m_Properties == null || m_Properties.Count <= 0)
			{
				return false;
			}
			for (int i = 0; i < m_Properties.Count; i += 2)
			{
				string text = m_Properties[i];
				if (text == attributeName)
				{
					return true;
				}
			}
			return false;
		}

		public string GetAttributeValue(string attributeName)
		{
			TryGetAttributeValue(attributeName, out var value);
			return value;
		}

		public bool TryGetAttributeValue(string propertyName, out string value)
		{
			if (m_Properties == null)
			{
				value = null;
				return false;
			}
			for (int i = 0; i < m_Properties.Count - 1; i += 2)
			{
				if (m_Properties[i] == propertyName)
				{
					value = m_Properties[i + 1];
					return true;
				}
			}
			value = null;
			return false;
		}

		public void SetAttribute(string name, string value)
		{
			SetOrAddProperty(name, value);
		}

		public void RemoveAttribute(string attributeName)
		{
			if (m_Properties == null || m_Properties.Count <= 0)
			{
				return;
			}
			for (int i = 0; i < m_Properties.Count; i += 2)
			{
				string text = m_Properties[i];
				if (!(text != attributeName))
				{
					m_Properties.RemoveAt(i);
					m_Properties.RemoveAt(i);
					break;
				}
			}
		}

		private void SetOrAddProperty(string propertyName, string propertyValue)
		{
			if (m_Properties == null)
			{
				m_Properties = new List<string>();
			}
			for (int i = 0; i < m_Properties.Count - 1; i += 2)
			{
				if (m_Properties[i] == propertyName)
				{
					m_Properties[i + 1] = propertyValue;
					return;
				}
			}
			m_Properties.Add(propertyName);
			m_Properties.Add(propertyValue);
		}
	}
	[Serializable]
	internal sealed class UxmlObjectAsset : UxmlAsset
	{
		public UxmlObjectAsset(string fullTypeName)
			: base(fullTypeName)
		{
		}
	}
	internal class UxmlObjectFactoryRegistry
	{
		private static Dictionary<string, List<IBaseUxmlObjectFactory>> s_Factories;

		internal static Dictionary<string, List<IBaseUxmlObjectFactory>> factories
		{
			get
			{
				if (s_Factories == null)
				{
					s_Factories = new Dictionary<string, List<IBaseUxmlObjectFactory>>();
					RegisterEngineFactories();
					RegisterUserFactories();
				}
				return s_Factories;
			}
		}

		protected static void RegisterFactory(IBaseUxmlObjectFactory factory)
		{
			if (factories.TryGetValue(factory.uxmlQualifiedName, out var value))
			{
				foreach (IBaseUxmlObjectFactory item in value)
				{
					if (item.GetType() == factory.GetType())
					{
						throw new ArgumentException("A factory for the type " + factory.GetType().FullName + " was already registered");
					}
				}
				value.Add(factory);
			}
			else
			{
				value = new List<IBaseUxmlObjectFactory> { factory };
				factories.Add(factory.uxmlQualifiedName, value);
			}
		}

		internal static bool TryGetFactories(string fullTypeName, out List<IBaseUxmlObjectFactory> factoryList)
		{
			return factories.TryGetValue(fullTypeName, out factoryList);
		}

		private static void RegisterEngineFactories()
		{
			IBaseUxmlObjectFactory[] array = new IBaseUxmlObjectFactory[4]
			{
				new Columns.UxmlObjectFactory<Columns>(),
				new Column.UxmlObjectFactory<Column>(),
				new SortColumnDescriptions.UxmlObjectFactory<SortColumnDescriptions>(),
				new SortColumnDescription.UxmlObjectFactory<SortColumnDescription>()
			};
			IBaseUxmlObjectFactory[] array2 = array;
			foreach (IBaseUxmlObjectFactory factory in array2)
			{
				RegisterFactory(factory);
			}
		}

		private static void RegisterUserFactories()
		{
			HashSet<string> hashSet = new HashSet<string>(ScriptingRuntime.GetAllUserAssemblies());
			Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
			Assembly[] array = assemblies;
			foreach (Assembly assembly in array)
			{
				if (!hashSet.Contains(assembly.GetName().Name + ".dll") || assembly.GetName().Name == "UnityEngine.UIElementsModule")
				{
					continue;
				}
				Type[] types = assembly.GetTypes();
				Type[] array2 = types;
				foreach (Type type in array2)
				{
					if (typeof(IBaseUxmlObjectFactory).IsAssignableFrom(type) && !type.IsInterface && !type.IsAbstract && !type.IsGenericType)
					{
						IBaseUxmlObjectFactory factory = (IBaseUxmlObjectFactory)Activator.CreateInstance(type);
						RegisterFactory(factory);
					}
				}
			}
		}
	}
	public abstract class UxmlTypeRestriction : IEquatable<UxmlTypeRestriction>
	{
		public virtual bool Equals(UxmlTypeRestriction other)
		{
			return this == other;
		}
	}
	public class UxmlValueMatches : UxmlTypeRestriction
	{
		public string regex { get; set; }

		public override bool Equals(UxmlTypeRestriction other)
		{
			if (!(other is UxmlValueMatches uxmlValueMatches))
			{
				return false;
			}
			return regex == uxmlValueMatches.regex;
		}
	}
	public class UxmlValueBounds : UxmlTypeRestriction
	{
		public string min { get; set; }

		public string max { get; set; }

		public bool excludeMin { get; set; }

		public bool excludeMax { get; set; }

		public override bool Equals(UxmlTypeRestriction other)
		{
			if (!(other is UxmlValueBounds uxmlValueBounds))
			{
				return false;
			}
			return min == uxmlValueBounds.min && max == uxmlValueBounds.max && excludeMin == uxmlValueBounds.excludeMin && excludeMax == uxmlValueBounds.excludeMax;
		}
	}
	public class UxmlEnumeration : UxmlTypeRestriction
	{
		private List<string> m_Values = new List<string>();

		public IEnumerable<string> values
		{
			get
			{
				return m_Values;
			}
			set
			{
				m_Values = value.ToList();
			}
		}

		public override bool Equals(UxmlTypeRestriction other)
		{
			if (!(other is UxmlEnumeration uxmlEnumeration))
			{
				return false;
			}
			return values.All(uxmlEnumeration.values.Contains<string>) && values.Count() == uxmlEnumeration.values.Count();
		}
	}
	[Serializable]
	internal class VisualElementAsset : UxmlAsset, ISerializationCallbackReceiver
	{
		[SerializeField]
		private string m_Name;

		[SerializeField]
		private int m_RuleIndex = -1;

		[SerializeField]
		private string m_Text;

		[SerializeField]
		private PickingMode m_PickingMode;

		[SerializeField]
		private string[] m_Classes;

		[SerializeField]
		private List<string> m_StylesheetPaths;

		[SerializeField]
		private List<StyleSheet> m_Stylesheets;

		[SerializeField]
		private bool m_SkipClone;

		public int ruleIndex
		{
			get
			{
				return m_RuleIndex;
			}
			set
			{
				m_RuleIndex = value;
			}
		}

		public string[] classes
		{
			get
			{
				return m_Classes;
			}
			set
			{
				m_Classes = value;
			}
		}

		public List<string> stylesheetPaths
		{
			get
			{
				return m_StylesheetPaths ?? (m_StylesheetPaths = new List<string>());
			}
			set
			{
				m_StylesheetPaths = value;
			}
		}

		public bool hasStylesheetPaths => m_StylesheetPaths != null;

		public List<StyleSheet> stylesheets
		{
			get
			{
				return m_Stylesheets ?? (m_Stylesheets = new List<StyleSheet>());
			}
			set
			{
				m_Stylesheets = value;
			}
		}

		public bool hasStylesheets => m_Stylesheets != null;

		internal bool skipClone
		{
			get
			{
				return m_SkipClone;
			}
			set
			{
				m_SkipClone = value;
			}
		}

		public VisualElementAsset(string fullTypeName)
			: base(fullTypeName)
		{
			m_Name = string.Empty;
			m_Text = string.Empty;
			m_PickingMode = PickingMode.Position;
		}

		public void OnBeforeSerialize()
		{
		}

		public void OnAfterDeserialize()
		{
			if (!string.IsNullOrEmpty(m_Name) && !m_Properties.Contains("name"))
			{
				SetAttribute("name", m_Name);
			}
			if (!string.IsNullOrEmpty(m_Text) && !m_Properties.Contains("text"))
			{
				SetAttribute("text", m_Text);
			}
			if (m_PickingMode != PickingMode.Position && !m_Properties.Contains("picking-mode") && !m_Properties.Contains("pickingMode"))
			{
				SetAttribute("picking-mode", m_PickingMode.ToString());
			}
		}
	}
	internal class VisualElementFactoryRegistry
	{
		private static Dictionary<string, List<IUxmlFactory>> s_Factories;

		private static Dictionary<string, List<IUxmlFactory>> s_MovedTypesFactories;

		internal static Dictionary<string, List<IUxmlFactory>> factories
		{
			get
			{
				if (s_Factories == null)
				{
					s_Factories = new Dictionary<string, List<IUxmlFactory>>();
					s_MovedTypesFactories = new Dictionary<string, List<IUxmlFactory>>(50);
					RegisterEngineFactories();
					RegisterUserFactories();
				}
				return s_Factories;
			}
		}

		private static string GetMovedUIControlTypeName(Type type, MovedFromAttribute attr)
		{
			if (type == null)
			{
				return string.Empty;
			}
			MovedFromAttributeData data = attr.data;
			string text = (data.nameSpaceHasChanged ? data.nameSpace : VisualElement.GetOrCreateTypeData(type).typeNamespace);
			string text2 = (data.classHasChanged ? data.className : VisualElement.GetOrCreateTypeData(type).typeName);
			return text + "." + text2;
		}

		protected static void RegisterFactory(IUxmlFactory factory)
		{
			if (factories.TryGetValue(factory.uxmlQualifiedName, out var value))
			{
				foreach (IUxmlFactory item in value)
				{
					if (item.GetType() == factory.GetType())
					{
						throw new ArgumentException("A factory for the type " + factory.GetType().FullName + " was already registered");
					}
				}
				value.Add(factory);
				return;
			}
			value = new List<IUxmlFactory>();
			value.Add(factory);
			factories.Add(factory.uxmlQualifiedName, value);
			Type uxmlType = factory.uxmlType;
			MovedFromAttribute movedFromAttribute = uxmlType?.GetCustomAttribute<MovedFromAttribute>(inherit: false);
			if (movedFromAttribute != null && typeof(VisualElement).IsAssignableFrom(uxmlType))
			{
				string movedUIControlTypeName = GetMovedUIControlTypeName(uxmlType, movedFromAttribute);
				if (!string.IsNullOrEmpty(movedUIControlTypeName))
				{
					s_MovedTypesFactories.Add(movedUIControlTypeName, value);
				}
			}
		}

		internal static bool TryGetValue(string fullTypeName, out List<IUxmlFactory> factoryList)
		{
			bool flag = factories.TryGetValue(fullTypeName, out factoryList);
			if (!flag)
			{
				flag = s_MovedTypesFactories.TryGetValue(fullTypeName, out factoryList);
			}
			return flag;
		}

		internal static bool TryGetValue(Type type, out List<IUxmlFactory> factoryList)
		{
			foreach (List<IUxmlFactory> value in factories.Values)
			{
				if (value[0].uxmlType == type)
				{
					factoryList = value;
					return true;
				}
			}
			factoryList = null;
			return false;
		}

		private static void RegisterEngineFactories()
		{
			IUxmlFactory[] array = new IUxmlFactory[52]
			{
				new UxmlRootElementFactory(),
				new UxmlTemplateFactory(),
				new UxmlStyleFactory(),
				new UxmlAttributeOverridesFactory(),
				new Button.UxmlFactory(),
				new VisualElement.UxmlFactory(),
				new IMGUIContainer.UxmlFactory(),
				new Image.UxmlFactory(),
				new Label.UxmlFactory(),
				new RepeatButton.UxmlFactory(),
				new ScrollView.UxmlFactory(),
				new Scroller.UxmlFactory(),
				new Slider.UxmlFactory(),
				new SliderInt.UxmlFactory(),
				new MinMaxSlider.UxmlFactory(),
				new GroupBox.UxmlFactory(),
				new RadioButton.UxmlFactory(),
				new RadioButtonGroup.UxmlFactory(),
				new Toggle.UxmlFactory(),
				new TextField.UxmlFactory(),
				new TemplateContainer.UxmlFactory(),
				new Box.UxmlFactory(),
				new EnumField.UxmlFactory(),
				new DropdownField.UxmlFactory(),
				new HelpBox.UxmlFactory(),
				new PopupWindow.UxmlFactory(),
				new ProgressBar.UxmlFactory(),
				new ListView.UxmlFactory(),
				new TwoPaneSplitView.UxmlFactory(),
				new TreeView.UxmlFactory(),
				new Foldout.UxmlFactory(),
				new MultiColumnListView.UxmlFactory(),
				new MultiColumnTreeView.UxmlFactory(),
				new BindableElement.UxmlFactory(),
				new TextElement.UxmlFactory(),
				new ButtonStripField.UxmlFactory(),
				new FloatField.UxmlFactory(),
				new DoubleField.UxmlFactory(),
				new Hash128Field.UxmlFactory(),
				new IntegerField.UxmlFactory(),
				new LongField.UxmlFactory(),
				new UnsignedIntegerField.UxmlFactory(),
				new UnsignedLongField.UxmlFactory(),
				new RectField.UxmlFactory(),
				new Vector2Field.UxmlFactory(),
				new RectIntField.UxmlFactory(),
				new Vector3Field.UxmlFactory(),
				new Vector4Field.UxmlFactory(),
				new Vector2IntField.UxmlFactory(),
				new Vector3IntField.UxmlFactory(),
				new BoundsField.UxmlFactory(),
				new BoundsIntField.UxmlFactory()
			};
			IUxmlFactory[] array2 = array;
			foreach (IUxmlFactory factory in array2)
			{
				RegisterFactory(factory);
			}
		}

		internal static void RegisterUserFactories()
		{
			HashSet<string> hashSet = new HashSet<string>(ScriptingRuntime.GetAllUserAssemblies());
			Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
			Assembly[] array = assemblies;
			foreach (Assembly assembly in array)
			{
				if (!hashSet.Contains(assembly.GetName().Name + ".dll") || assembly.GetName().Name == "UnityEngine.UIElementsModule")
				{
					continue;
				}
				Type[] types = assembly.GetTypes();
				Type[] array2 = types;
				foreach (Type type in array2)
				{
					if (typeof(IUxmlFactory).IsAssignableFrom(type) && !type.IsInterface && !type.IsAbstract && !type.IsGenericType)
					{
						IUxmlFactory factory = (IUxmlFactory)Activator.CreateInstance(type);
						RegisterFactory(factory);
					}
				}
			}
		}
	}
	[Serializable]
	[HelpURL("UIE-VisualTree-landing")]
	public class VisualTreeAsset : ScriptableObject
	{
		[Serializable]
		internal struct UsingEntry
		{
			internal static readonly IComparer<UsingEntry> comparer = new UsingEntryComparer();

			[SerializeField]
			public string alias;

			[SerializeField]
			public string path;

			[SerializeField]
			public VisualTreeAsset asset;

			public UsingEntry(string alias, string path)
			{
				this.alias = alias;
				this.path = path;
				asset = null;
			}

			public UsingEntry(string alias, VisualTreeAsset asset)
			{
				this.alias = alias;
				path = null;
				this.asset = asset;
			}
		}

		private class UsingEntryComparer : IComparer<UsingEntry>
		{
			public int Compare(UsingEntry x, UsingEntry y)
			{
				return string.CompareOrdinal(x.alias, y.alias);
			}
		}

		[Serializable]
		internal struct SlotDefinition
		{
			[SerializeField]
			public string name;

			[SerializeField]
			public int insertionPointId;
		}

		[Serializable]
		internal struct SlotUsageEntry
		{
			[SerializeField]
			public string slotName;

			[SerializeField]
			public int assetId;

			public SlotUsageEntry(string slotName, int assetId)
			{
				this.slotName = slotName;
				this.assetId = assetId;
			}
		}

		[Serializable]
		internal struct UxmlObjectEntry
		{
			[SerializeField]
			public int parentId;

			[SerializeField]
			public List<UxmlObjectAsset> uxmlObjectAssets;

			public UxmlObjectEntry(int parentId, List<UxmlObjectAsset> uxmlObjectAssets)
			{
				this.parentId = parentId;
				this.uxmlObjectAssets = uxmlObjectAssets;
			}
		}

		[Serializable]
		private struct AssetEntry
		{
			[SerializeField]
			public string path;

			[SerializeField]
			public string typeFullName;

			[SerializeField]
			public Object asset;

			private Type m_CachedType;

			public Type type => m_CachedType ?? (m_CachedType = Type.GetType(typeFullName));

			public AssetEntry(string path, Type type, Object asset)
			{
				this.path = path;
				typeFullName = type.AssemblyQualifiedName;
				this.asset = asset;
				m_CachedType = type;
			}
		}

		internal static string LinkedVEAInTemplatePropertyName = "--unity-linked-vea-in-template";

		[SerializeField]
		private bool m_ImportedWithErrors;

		[SerializeField]
		private bool m_ImportedWithWarnings;

		private static readonly Dictionary<string, VisualElement> s_TemporarySlotInsertionPoints = new Dictionary<string, VisualElement>();

		[SerializeField]
		private List<UsingEntry> m_Usings;

		[SerializeField]
		internal StyleSheet inlineSheet;

		[SerializeField]
		private List<VisualElementAsset> m_VisualElementAssets;

		[SerializeField]
		private List<TemplateAsset> m_TemplateAssets;

		[SerializeField]
		private List<UxmlObjectEntry> m_UxmlObjectEntries;

		[SerializeField]
		private List<int> m_UxmlObjectIds;

		[SerializeField]
		private List<AssetEntry> m_AssetEntries;

		[SerializeField]
		private List<SlotDefinition> m_Slots;

		[SerializeField]
		private int m_ContentContainerId;

		[SerializeField]
		private int m_ContentHash;

		public bool importedWithErrors
		{
			get
			{
				return m_ImportedWithErrors;
			}
			internal set
			{
				m_ImportedWithErrors = value;
			}
		}

		public bool importedWithWarnings
		{
			get
			{
				return m_ImportedWithWarnings;
			}
			internal set
			{
				m_ImportedWithWarnings = value;
			}
		}

		public IEnumerable<VisualTreeAsset> templateDependencies
		{
			get
			{
				if (m_Usings == null || m_Usings.Count == 0)
				{
					yield break;
				}
				HashSet<VisualTreeAsset> sent = new HashSet<VisualTreeAsset>();
				foreach (UsingEntry entry in m_Usings)
				{
					if (entry.asset != null && !sent.Contains(entry.asset))
					{
						sent.Add(entry.asset);
						yield return entry.asset;
					}
					else if (!string.IsNullOrEmpty(entry.path))
					{
						VisualTreeAsset vta = Panel.LoadResource(entry.path, typeof(VisualTreeAsset), GUIUtility.pixelsPerPoint) as VisualTreeAsset;
						if (vta != null && !sent.Contains(entry.asset))
						{
							sent.Add(entry.asset);
							yield return vta;
						}
					}
				}
			}
		}

		public IEnumerable<StyleSheet> stylesheets
		{
			get
			{
				HashSet<StyleSheet> sent = new HashSet<StyleSheet>();
				foreach (VisualElementAsset vea in m_VisualElementAssets)
				{
					if (vea.hasStylesheets)
					{
						foreach (StyleSheet stylesheet in vea.stylesheets)
						{
							if (!sent.Contains(stylesheet))
							{
								sent.Add(stylesheet);
								yield return stylesheet;
							}
						}
					}
					if (!vea.hasStylesheetPaths)
					{
						continue;
					}
					foreach (string stylesheetPath in vea.stylesheetPaths)
					{
						StyleSheet stylesheet2 = Panel.LoadResource(stylesheetPath, typeof(StyleSheet), GUIUtility.pixelsPerPoint) as StyleSheet;
						if (stylesheet2 != null && !sent.Contains(stylesheet2))
						{
							sent.Add(stylesheet2);
							yield return stylesheet2;
						}
					}
				}
			}
		}

		internal List<VisualElementAsset> visualElementAssets
		{
			get
			{
				return m_VisualElementAssets;
			}
			set
			{
				m_VisualElementAssets = value;
			}
		}

		internal List<TemplateAsset> templateAssets
		{
			get
			{
				return m_TemplateAssets;
			}
			set
			{
				m_TemplateAssets = value;
			}
		}

		internal List<UxmlObjectEntry> uxmlObjectEntries => m_UxmlObjectEntries;

		internal List<int> uxmlObjectIds => m_UxmlObjectIds;

		internal List<SlotDefinition> slots
		{
			get
			{
				return m_Slots;
			}
			set
			{
				m_Slots = value;
			}
		}

		internal int contentContainerId
		{
			get
			{
				return m_ContentContainerId;
			}
			set
			{
				m_ContentContainerId = value;
			}
		}

		public int contentHash
		{
			get
			{
				return m_ContentHash;
			}
			set
			{
				m_ContentHash = value;
			}
		}

		internal int GetNextChildSerialNumber()
		{
			int num = m_VisualElementAssets?.Count ?? 0;
			num += m_TemplateAssets?.Count ?? 0;
			return num + (m_UxmlObjectEntries?.Count ?? 0);
		}

		internal void RegisterUxmlObject(UxmlObjectAsset uxmlObjectAsset)
		{
			if (m_UxmlObjectEntries == null)
			{
				m_UxmlObjectEntries = new List<UxmlObjectEntry>();
			}
			if (m_UxmlObjectIds == null)
			{
				m_UxmlObjectIds = new List<int>();
			}
			UxmlObjectEntry uxmlObjectEntry = GetUxmlObjectEntry(uxmlObjectAsset.parentId);
			if (uxmlObjectEntry.uxmlObjectAssets != null)
			{
				uxmlObjectEntry.uxmlObjectAssets.Add(uxmlObjectAsset);
				return;
			}
			m_UxmlObjectEntries.Add(new UxmlObjectEntry(uxmlObjectAsset.parentId, new List<UxmlObjectAsset> { uxmlObjectAsset }));
			m_UxmlObjectIds.Add(uxmlObjectAsset.id);
		}

		internal List<T> GetUxmlObjects<T>(IUxmlAttributes asset, CreationContext cc) where T : new()
		{
			if (m_UxmlObjectEntries == null)
			{
				return null;
			}
			if (asset is UxmlAsset uxmlAsset)
			{
				UxmlObjectEntry uxmlObjectEntry = GetUxmlObjectEntry(uxmlAsset.id);
				if (uxmlObjectEntry.uxmlObjectAssets != null)
				{
					List<T> list = null;
					foreach (UxmlObjectAsset uxmlObjectAsset in uxmlObjectEntry.uxmlObjectAssets)
					{
						IBaseUxmlObjectFactory uxmlObjectFactory = GetUxmlObjectFactory(uxmlObjectAsset);
						if (uxmlObjectFactory is IUxmlObjectFactory<T> uxmlObjectFactory2)
						{
							T item = uxmlObjectFactory2.CreateObject(uxmlObjectAsset, cc);
							if (list == null)
							{
								list = new List<T> { item };
							}
							else
							{
								list.Add(item);
							}
						}
					}
					return list;
				}
			}
			return null;
		}

		internal bool AssetEntryExists(string path, Type type)
		{
			if (m_AssetEntries == null)
			{
				return false;
			}
			foreach (AssetEntry assetEntry in m_AssetEntries)
			{
				if (assetEntry.path == path && assetEntry.type == type)
				{
					return true;
				}
			}
			return false;
		}

		internal void RegisterAssetEntry(string path, Type type, Object asset)
		{
			if (m_AssetEntries == null)
			{
				m_AssetEntries = new List<AssetEntry>();
			}
			m_AssetEntries.Add(new AssetEntry(path, type, asset));
		}

		internal T GetAsset<T>(string path) where T : Object
		{
			foreach (AssetEntry assetEntry in m_AssetEntries)
			{
				if (assetEntry.path.Equals(path) && assetEntry.type == typeof(T))
				{
					return assetEntry.asset as T;
				}
			}
			return null;
		}

		internal UxmlObjectEntry GetUxmlObjectEntry(int id)
		{
			if (m_UxmlObjectEntries != null)
			{
				foreach (UxmlObjectEntry uxmlObjectEntry in m_UxmlObjectEntries)
				{
					if (uxmlObjectEntry.parentId == id)
					{
						return uxmlObjectEntry;
					}
				}
			}
			return default(UxmlObjectEntry);
		}

		private IBaseUxmlObjectFactory GetUxmlObjectFactory(UxmlObjectAsset uxmlObjectAsset)
		{
			if (!UxmlObjectFactoryRegistry.TryGetFactories(uxmlObjectAsset.fullTypeName, out var factoryList))
			{
				Debug.LogErrorFormat("Element '{0}' has no registered factory method.", uxmlObjectAsset.fullTypeName);
				return null;
			}
			IBaseUxmlObjectFactory baseUxmlObjectFactory = null;
			CreationContext cc = new CreationContext(null, this, null);
			foreach (IBaseUxmlObjectFactory item in factoryList)
			{
				if (item.AcceptsAttributeBag(uxmlObjectAsset, cc))
				{
					baseUxmlObjectFactory = item;
					break;
				}
			}
			if (baseUxmlObjectFactory == null)
			{
				Debug.LogErrorFormat("Element '{0}' has a no factory that accept the set of XML attributes specified.", uxmlObjectAsset.fullTypeName);
				return null;
			}
			return baseUxmlObjectFactory;
		}

		public TemplateContainer Instantiate()
		{
			TemplateContainer templateContainer = new TemplateContainer(base.name);
			try
			{
				CloneTree(templateContainer, s_TemporarySlotInsertionPoints, null);
			}
			finally
			{
				s_TemporarySlotInsertionPoints.Clear();
			}
			return templateContainer;
		}

		public TemplateContainer Instantiate(string bindingPath)
		{
			TemplateContainer templateContainer = Instantiate();
			templateContainer.bindingPath = bindingPath;
			return templateContainer;
		}

		public TemplateContainer CloneTree()
		{
			return Instantiate();
		}

		public TemplateContainer CloneTree(string bindingPath)
		{
			return Instantiate(bindingPath);
		}

		public void CloneTree(VisualElement target)
		{
			CloneTree(target, out var _, out var _);
		}

		public void CloneTree(VisualElement target, out int firstElementIndex, out int elementAddedCount)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			firstElementIndex = target.childCount;
			try
			{
				CloneTree(target, s_TemporarySlotInsertionPoints, null);
			}
			finally
			{
				elementAddedCount = target.childCount - firstElementIndex;
				s_TemporarySlotInsertionPoints.Clear();
			}
		}

		internal void CloneTree(VisualElement target, Dictionary<string, VisualElement> slotInsertionPoints, List<TemplateAsset.AttributeOverride> attributeOverrides)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if ((visualElementAssets == null || visualElementAssets.Count <= 0) && (templateAssets == null || templateAssets.Count <= 0))
			{
				return;
			}
			if (target is TemplateContainer templateContainer)
			{
				templateContainer.templateSource = this;
			}
			Dictionary<int, List<VisualElementAsset>> dictionary = new Dictionary<int, List<VisualElementAsset>>();
			int num = ((visualElementAssets != null) ? visualElementAssets.Count : 0);
			int num2 = ((templateAssets != null) ? templateAssets.Count : 0);
			for (int i = 0; i < num + num2; i++)
			{
				VisualElementAsset visualElementAsset = ((i < num) ? visualElementAssets[i] : templateAssets[i - num]);
				if (!dictionary.TryGetValue(visualElementAsset.parentId, out var value))
				{
					value = new List<VisualElementAsset>();
					dictionary.Add(visualElementAsset.parentId, value);
				}
				value.Add(visualElementAsset);
			}
			dictionary.TryGetValue(0, out var value2);
			if (value2 == null || value2.Count == 0)
			{
				return;
			}
			Debug.Assert(value2.Count == 1);
			VisualElementAsset visualElementAsset2 = value2[0];
			AssignClassListFromAssetToElement(visualElementAsset2, target);
			AssignStyleSheetFromAssetToElement(visualElementAsset2, target);
			value2.Clear();
			dictionary.TryGetValue(visualElementAsset2.id, out value2);
			if (value2 == null || value2.Count == 0)
			{
				return;
			}
			value2.Sort(CompareForOrder);
			foreach (VisualElementAsset item in value2)
			{
				Assert.IsNotNull(item);
				VisualElement visualElement = CloneSetupRecursively(item, dictionary, new CreationContext(slotInsertionPoints, attributeOverrides, this, target));
				if (visualElement != null)
				{
					visualElement.visualTreeAssetSource = this;
					target.hierarchy.Add(visualElement);
				}
			}
		}

		private VisualElement CloneSetupRecursively(VisualElementAsset root, Dictionary<int, List<VisualElementAsset>> idToChildren, CreationContext context)
		{
			if (root.skipClone)
			{
				return null;
			}
			VisualElement visualElement = Create(root, context);
			if (visualElement == null)
			{
				return null;
			}
			if (root.id == context.visualTreeAsset.contentContainerId)
			{
				if (context.target is TemplateContainer)
				{
					((TemplateContainer)context.target).SetContentContainer(visualElement);
				}
				else
				{
					Debug.LogError("Trying to clone a VisualTreeAsset with a custom content container into a element which is not a template container");
				}
			}
			if (context.slotInsertionPoints != null && TryGetSlotInsertionPoint(root.id, out var slotName))
			{
				context.slotInsertionPoints.Add(slotName, visualElement);
			}
			if (root.ruleIndex != -1)
			{
				if (inlineSheet == null)
				{
					Debug.LogWarning("VisualElementAsset has a RuleIndex but no inlineStyleSheet");
				}
				else
				{
					StyleRule rule = inlineSheet.rules[root.ruleIndex];
					visualElement.SetInlineRule(inlineSheet, rule);
				}
			}
			if (root.ruleIndex != -1)
			{
				if (inlineSheet == null)
				{
					Debug.LogWarning("VisualElementAsset has a RuleIndex but no inlineStyleSheet");
				}
				else
				{
					StyleRule rule2 = inlineSheet.rules[root.ruleIndex];
					visualElement.SetInlineRule(inlineSheet, rule2);
				}
			}
			TemplateAsset templateAsset = root as TemplateAsset;
			if (idToChildren.TryGetValue(root.id, out var value))
			{
				value.Sort(CompareForOrder);
				foreach (VisualElementAsset childVea in value)
				{
					VisualElement visualElement2 = CloneSetupRecursively(childVea, idToChildren, context);
					if (visualElement2 == null)
					{
						continue;
					}
					if (templateAsset == null)
					{
						visualElement.Add(visualElement2);
						continue;
					}
					int num = ((templateAsset.slotUsages == null) ? (-1) : templateAsset.slotUsages.FindIndex((SlotUsageEntry u) => u.assetId == childVea.id));
					if (num != -1)
					{
						string slotName2 = templateAsset.slotUsages[num].slotName;
						Assert.IsFalse(string.IsNullOrEmpty(slotName2), "a lost name should not be null or empty, this probably points to an importer or serialization bug");
						if (context.slotInsertionPoints == null || !context.slotInsertionPoints.TryGetValue(slotName2, out var value2))
						{
							Debug.LogErrorFormat("Slot '{0}' was not found. Existing slots: {1}", slotName2, (context.slotInsertionPoints == null) ? string.Empty : string.Join(", ", context.slotInsertionPoints.Keys.ToArray()));
							visualElement.Add(visualElement2);
						}
						else
						{
							value2.Add(visualElement2);
						}
					}
					else
					{
						visualElement.Add(visualElement2);
					}
				}
			}
			if (templateAsset != null && context.slotInsertionPoints != null)
			{
				context.slotInsertionPoints.Clear();
			}
			return visualElement;
		}

		private static int CompareForOrder(VisualElementAsset a, VisualElementAsset b)
		{
			return a.orderInDocument.CompareTo(b.orderInDocument);
		}

		internal bool TryGetSlotInsertionPoint(int insertionPointId, out string slotName)
		{
			if (m_Slots == null)
			{
				slotName = null;
				return false;
			}
			for (int i = 0; i < m_Slots.Count; i++)
			{
				SlotDefinition slotDefinition = m_Slots[i];
				if (slotDefinition.insertionPointId == insertionPointId)
				{
					slotName = slotDefinition.name;
					return true;
				}
			}
			slotName = null;
			return false;
		}

		internal VisualTreeAsset ResolveTemplate(string templateName)
		{
			if (m_Usings == null || m_Usings.Count == 0)
			{
				return null;
			}
			int num = m_Usings.BinarySearch(new UsingEntry(templateName, string.Empty), UsingEntry.comparer);
			if (num < 0)
			{
				return null;
			}
			if ((bool)m_Usings[num].asset)
			{
				return m_Usings[num].asset;
			}
			string path = m_Usings[num].path;
			return Panel.LoadResource(path, typeof(VisualTreeAsset), GUIUtility.pixelsPerPoint) as VisualTreeAsset;
		}

		internal static VisualElement Create(VisualElementAsset asset, CreationContext ctx)
		{
			if (!VisualElementFactoryRegistry.TryGetValue(asset.fullTypeName, out var factoryList))
			{
				if (asset.fullTypeName.StartsWith("UnityEngine.Experimental.UIElements.") || asset.fullTypeName.StartsWith("UnityEditor.Experimental.UIElements."))
				{
					string fullTypeName = asset.fullTypeName.Replace(".Experimental.UIElements", ".UIElements");
					if (!VisualElementFactoryRegistry.TryGetValue(fullTypeName, out factoryList))
					{
						return CreateError();
					}
				}
				else
				{
					if (!(asset.fullTypeName == "UXML"))
					{
						return CreateError();
					}
					VisualElementFactoryRegistry.TryGetValue(typeof(UxmlRootElementFactory).Namespace + "." + asset.fullTypeName, out factoryList);
				}
			}
			IUxmlFactory uxmlFactory = null;
			foreach (IUxmlFactory item in factoryList)
			{
				if (item.AcceptsAttributeBag(asset, ctx))
				{
					uxmlFactory = item;
					break;
				}
			}
			if (uxmlFactory == null)
			{
				Debug.LogErrorFormat("Element '{0}' has a no factory that accept the set of XML attributes specified.", asset.fullTypeName);
				return new Label($"Type with no factory: '{asset.fullTypeName}'");
			}
			VisualElement visualElement = uxmlFactory.Create(asset, ctx);
			if (visualElement != null)
			{
				AssignClassListFromAssetToElement(asset, visualElement);
				AssignStyleSheetFromAssetToElement(asset, visualElement);
			}
			return visualElement;
			VisualElement CreateError()
			{
				Debug.LogErrorFormat("Element '{0}' has no registered factory method.", asset.fullTypeName);
				return new Label($"Unknown type: '{asset.fullTypeName}'");
			}
		}

		private static void AssignClassListFromAssetToElement(VisualElementAsset asset, VisualElement element)
		{
			if (asset.classes != null)
			{
				for (int i = 0; i < asset.classes.Length; i++)
				{
					element.AddToClassList(asset.classes[i]);
				}
			}
		}

		private static void AssignStyleSheetFromAssetToElement(VisualElementAsset asset, VisualElement element)
		{
			if (asset.hasStylesheetPaths)
			{
				for (int i = 0; i < asset.stylesheetPaths.Count; i++)
				{
					element.AddStyleSheetPath(asset.stylesheetPaths[i]);
				}
			}
			if (!asset.hasStylesheets)
			{
				return;
			}
			for (int j = 0; j < asset.stylesheets.Count; j++)
			{
				if (asset.stylesheets[j] != null)
				{
					element.styleSheets.Add(asset.stylesheets[j]);
				}
			}
		}
	}
	public struct CreationContext : IEquatable<CreationContext>
	{
		public static readonly CreationContext Default = default(CreationContext);

		public VisualElement target { get; private set; }

		public VisualTreeAsset visualTreeAsset { get; private set; }

		public Dictionary<string, VisualElement> slotInsertionPoints { get; private set; }

		internal List<TemplateAsset.AttributeOverride> attributeOverrides { get; private set; }

		internal CreationContext(Dictionary<string, VisualElement> slotInsertionPoints, VisualTreeAsset vta, VisualElement target)
			: this(slotInsertionPoints, null, vta, target)
		{
		}

		internal CreationContext(Dictionary<string, VisualElement> slotInsertionPoints, List<TemplateAsset.AttributeOverride> attributeOverrides, VisualTreeAsset vta, VisualElement target)
		{
			this.target = target;
			this.slotInsertionPoints = slotInsertionPoints;
			this.attributeOverrides = attributeOverrides;
			visualTreeAsset = vta;
		}

		public override bool Equals(object obj)
		{
			return obj is CreationContext && Equals((CreationContext)obj);
		}

		public bool Equals(CreationContext other)
		{
			return EqualityComparer<VisualElement>.Default.Equals(target, other.target) && EqualityComparer<VisualTreeAsset>.Default.Equals(visualTreeAsset, other.visualTreeAsset) && EqualityComparer<Dictionary<string, VisualElement>>.Default.Equals(slotInsertionPoints, other.slotInsertionPoints);
		}

		public override int GetHashCode()
		{
			int num = -2123482148;
			num = num * -1521134295 + EqualityComparer<VisualElement>.Default.GetHashCode(target);
			num = num * -1521134295 + EqualityComparer<VisualTreeAsset>.Default.GetHashCode(visualTreeAsset);
			return num * -1521134295 + EqualityComparer<Dictionary<string, VisualElement>>.Default.GetHashCode(slotInsertionPoints);
		}

		public static bool operator ==(CreationContext context1, CreationContext context2)
		{
			return context1.Equals(context2);
		}

		public static bool operator !=(CreationContext context1, CreationContext context2)
		{
			return !(context1 == context2);
		}
	}
	internal enum GradientType
	{
		Linear,
		Radial
	}
	internal enum AddressMode
	{
		Wrap,
		Clamp,
		Mirror
	}
	[Serializable]
	internal struct VectorImageVertex
	{
		public Vector3 position;

		public Color32 tint;

		public Vector2 uv;

		public uint settingIndex;

		public Color32 flags;

		public Vector4 circle;
	}
	[Serializable]
	internal struct GradientSettings
	{
		public GradientType gradientType;

		public AddressMode addressMode;

		public Vector2 radialFocus;

		public RectInt location;
	}
	[Serializable]
	public class VectorImage : ScriptableObject
	{
		[SerializeField]
		internal int version = 0;

		[SerializeField]
		internal Texture2D atlas = null;

		[SerializeField]
		internal VectorImageVertex[] vertices = null;

		[SerializeField]
		internal ushort[] indices = null;

		[SerializeField]
		internal GradientSettings[] settings = null;

		[SerializeField]
		internal Vector2 size = Vector2.zero;

		public float width => size.x;

		public float height => size.y;
	}
	[Flags]
	internal enum PseudoStates
	{
		Active = 1,
		Hover = 2,
		Checked = 8,
		Disabled = 0x20,
		Focus = 0x40,
		Root = 0x80
	}
	[Flags]
	internal enum VisualElementFlags
	{
		WorldTransformDirty = 1,
		WorldTransformInverseDirty = 2,
		WorldClipDirty = 4,
		BoundingBoxDirty = 8,
		WorldBoundingBoxDirty = 0x10,
		EventCallbackParentCategoriesDirty = 0x20,
		LayoutManual = 0x40,
		CompositeRoot = 0x80,
		RequireMeasureFunction = 0x100,
		EnableViewDataPersistence = 0x200,
		DisableClipping = 0x400,
		NeedsAttachToPanelEvent = 0x800,
		HierarchyDisplayed = 0x1000,
		StyleInitialized = 0x2000,
		Init = 0x103F
	}
	public enum PickingMode
	{
		Position,
		Ignore
	}
	public enum LanguageDirection
	{
		Inherit,
		LTR,
		RTL
	}
	internal static class VisualElementListPool
	{
		private static ObjectPool<List<VisualElement>> pool = new ObjectPool<List<VisualElement>>(() => new List<VisualElement>(), 20);

		public static List<VisualElement> Copy(List<VisualElement> elements)
		{
			List<VisualElement> list = pool.Get();
			list.AddRange(elements);
			return list;
		}

		public static List<VisualElement> Get(int initialCapacity = 0)
		{
			List<VisualElement> list = pool.Get();
			if (initialCapacity > 0 && list.Capacity < initialCapacity)
			{
				list.Capacity = initialCapacity;
			}
			return list;
		}

		public static void Release(List<VisualElement> elements)
		{
			elements.Clear();
			pool.Release(elements);
		}
	}
	internal class ObjectListPool<T>
	{
		private static ObjectPool<List<T>> pool = new ObjectPool<List<T>>(() => new List<T>(), 20);

		public static List<T> Get()
		{
			return pool.Get();
		}

		public static void Release(List<T> elements)
		{
			elements.Clear();
			pool.Release(elements);
		}
	}
	internal class StringObjectListPool : ObjectListPool<string>
	{
	}
	public static class VisualElementExtensions
	{
		public static void StretchToParentSize(this VisualElement elem)
		{
			if (elem == null)
			{
				throw new ArgumentNullException("elem");
			}
			IStyle style = elem.style;
			style.position = Position.Absolute;
			style.left = 0f;
			style.top = 0f;
			style.right = 0f;
			style.bottom = 0f;
		}

		public static void StretchToParentWidth(this VisualElement elem)
		{
			if (elem == null)
			{
				throw new ArgumentNullException("elem");
			}
			IStyle style = elem.style;
			style.position = Position.Absolute;
			style.left = 0f;
			style.right = 0f;
		}

		public static void AddManipulator(this VisualElement ele, IManipulator manipulator)
		{
			if (manipulator != null)
			{
				manipulator.target = ele;
			}
		}

		public static void RemoveManipulator(this VisualElement ele, IManipulator manipulator)
		{
			if (manipulator != null)
			{
				manipulator.target = null;
			}
		}

		public static Vector2 WorldToLocal(this VisualElement ele, Vector2 p)
		{
			if (ele == null)
			{
				throw new ArgumentNullException("ele");
			}
			return VisualElement.MultiplyMatrix44Point2(ref ele.worldTransformInverse, p);
		}

		public static Vector2 LocalToWorld(this VisualElement ele, Vector2 p)
		{
			if (ele == null)
			{
				throw new ArgumentNullException("ele");
			}
			return VisualElement.MultiplyMatrix44Point2(ref ele.worldTransformRef, p);
		}

		public static Rect WorldToLocal(this VisualElement ele, Rect r)
		{
			if (ele == null)
			{
				throw new ArgumentNullException("ele");
			}
			return VisualElement.CalculateConservativeRect(ref ele.worldTransformInverse, r);
		}

		public static Rect LocalToWorld(this VisualElement ele, Rect r)
		{
			if (ele == null)
			{
				throw new ArgumentNullException("ele");
			}
			return VisualElement.CalculateConservativeRect(ref ele.worldTransformRef, r);
		}

		public static Vector2 ChangeCoordinatesTo(this VisualElement src, VisualElement dest, Vector2 point)
		{
			return dest.WorldToLocal(src.LocalToWorld(point));
		}

		public static Rect ChangeCoordinatesTo(this VisualElement src, VisualElement dest, Rect rect)
		{
			return dest.WorldToLocal(src.LocalToWorld(rect));
		}
	}
	internal static class VisualElementDebugExtensions
	{
		public static string GetDisplayName(this VisualElement ve, bool withHashCode = true)
		{
			if (ve == null)
			{
				return string.Empty;
			}
			string text = ve.GetType().Name;
			if (!string.IsNullOrEmpty(ve.name))
			{
				text = text + "#" + ve.name;
			}
			if (withHashCode)
			{
				text = text + " (" + ve.GetHashCode().ToString("x8") + ")";
			}
			return text;
		}
	}
	internal static class EventInterestReflectionUtils
	{
		private struct DefaultEventInterests
		{
			public int DefaultActionCategories;

			public int DefaultActionAtTargetCategories;
		}

		private static readonly Dictionary<Type, DefaultEventInterests> s_DefaultEventInterests = new Dictionary<Type, DefaultEventInterests>();

		private static readonly Dictionary<Type, EventCategory> s_EventCategories = new Dictionary<Type, EventCategory>();

		internal static void GetDefaultEventInterests(Type elementType, out int defaultActionCategories, out int defaultActionAtTargetCategories)
		{
			if (!s_DefaultEventInterests.TryGetValue(elementType, out var value))
			{
				Type baseType = elementType.BaseType;
				if (baseType != null)
				{
					GetDefaultEventInterests(baseType, out value.DefaultActionCategories, out value.DefaultActionAtTargetCategories);
				}
				value.DefaultActionCategories |= ComputeDefaultEventInterests(elementType, "ExecuteDefaultAction") | ComputeDefaultEventInterests(elementType, "ExecuteDefaultActionDisabled");
				value.DefaultActionAtTargetCategories |= ComputeDefaultEventInterests(elementType, "ExecuteDefaultActionAtTarget") | ComputeDefaultEventInterests(elementType, "ExecuteDefaultActionDisabledAtTarget");
				s_DefaultEventInterests.Add(elementType, value);
			}
			defaultActionCategories = value.DefaultActionCategories;
			defaultActionAtTargetCategories = value.DefaultActionAtTargetCategories;
		}

		private static int ComputeDefaultEventInterests(Type elementType, string methodName)
		{
			MethodInfo method = elementType.GetMethod(methodName, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			if (method == null)
			{
				return 0;
			}
			bool flag = false;
			int num = 0;
			object[] customAttributes = method.GetCustomAttributes(typeof(EventInterestAttribute), inherit: false);
			object[] array = customAttributes;
			for (int i = 0; i < array.Length; i++)
			{
				EventInterestAttribute eventInterestAttribute = (EventInterestAttribute)array[i];
				flag = true;
				if (eventInterestAttribute.eventTypes != null)
				{
					Type[] eventTypes = eventInterestAttribute.eventTypes;
					foreach (Type eventType in eventTypes)
					{
						num |= 1 << (int)GetEventCategory(eventType);
					}
				}
				num |= (int)eventInterestAttribute.categoryFlags;
			}
			return flag ? num : (-1);
		}

		internal static EventCategory GetEventCategory(Type eventType)
		{
			if (s_EventCategories.TryGetValue(eventType, out var value))
			{
				return value;
			}
			object[] customAttributes = eventType.GetCustomAttributes(typeof(EventCategoryAttribute), inherit: true);
			object[] array = customAttributes;
			int num = 0;
			if (num < array.Length)
			{
				EventCategoryAttribute eventCategoryAttribute = (EventCategoryAttribute)array[num];
				value = eventCategoryAttribute.category;
				s_EventCategories.Add(eventType, value);
				return value;
			}
			throw new ArgumentOutOfRangeException("eventType", "Type must derive from EventBase<T>");
		}
	}
	internal enum EventCategory
	{
		Default = 0,
		Pointer = 1,
		PointerMove = 2,
		EnterLeave = 3,
		EnterLeaveWindow = 4,
		Keyboard = 5,
		Geometry = 6,
		Style = 7,
		ChangeValue = 8,
		Bind = 9,
		Focus = 10,
		ChangePanel = 11,
		StyleTransition = 12,
		Navigation = 13,
		Command = 14,
		Tooltip = 15,
		IMGUI = 16,
		Reserved = 31
	}
	[Flags]
	internal enum EventCategoryFlags
	{
		None = 0,
		All = -1,
		TriggeredByOS = 0x14036,
		TargetOnly = 0xAD0
	}
	public enum EventInterestOptions
	{
		Inherit = 0,
		AllEventTypes = -1
	}
	internal enum EventInterestOptionsInternal
	{
		TriggeredByOS = 81974
	}
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
	public class EventInterestAttribute : Attribute
	{
		internal Type[] eventTypes;

		internal EventCategoryFlags categoryFlags = EventCategoryFlags.None;

		public EventInterestAttribute(params Type[] eventTypes)
		{
			this.eventTypes = eventTypes;
		}

		public EventInterestAttribute(EventInterestOptions interests)
		{
			categoryFlags = (EventCategoryFlags)interests;
		}

		internal EventInterestAttribute(EventInterestOptionsInternal interests)
		{
			categoryFlags = (EventCategoryFlags)interests;
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	internal class EventCategoryAttribute : Attribute
	{
		internal EventCategory category;

		public EventCategoryAttribute(EventCategory category)
		{
			this.category = category;
		}
	}
	public interface IExperimentalFeatures
	{
		ITransitionAnimations animation { get; }
	}
	public class VisualElementFocusChangeDirection : FocusChangeDirection
	{
		private static readonly VisualElementFocusChangeDirection s_Left = new VisualElementFocusChangeDirection((int)FocusChangeDirection.lastValue + 1);

		private static readonly VisualElementFocusChangeDirection s_Right = new VisualElementFocusChangeDirection((int)FocusChangeDirection.lastValue + 2);

		public static FocusChangeDirection left => s_Left;

		public static FocusChangeDirection right => s_Right;

		protected new static VisualElementFocusChangeDirection lastValue => s_Right;

		protected VisualElementFocusChangeDirection(int value)
			: base(value)
		{
		}
	}
	internal class VisualElementFocusChangeTarget : FocusChangeDirection
	{
		private static readonly ObjectPool<VisualElementFocusChangeTarget> Pool = new ObjectPool<VisualElementFocusChangeTarget>(() => new VisualElementFocusChangeTarget());

		public Focusable target { get; private set; }

		public static VisualElementFocusChangeTarget GetPooled(Focusable target)
		{
			VisualElementFocusChangeTarget visualElementFocusChangeTarget = Pool.Get();
			visualElementFocusChangeTarget.target = target;
			return visualElementFocusChangeTarget;
		}

		protected override void Dispose()
		{
			target = null;
			Pool.Release(this);
		}

		internal override void ApplyTo(FocusController focusController, Focusable f)
		{
			focusController.selectedTextElement = null;
			f.Focus();
		}

		public VisualElementFocusChangeTarget()
			: base(FocusChangeDirection.unspecified)
		{
		}
	}
	public class VisualElementFocusRing : IFocusRing
	{
		public enum DefaultFocusOrder
		{
			ChildOrder,
			PositionXY,
			PositionYX
		}

		private class FocusRingRecord
		{
			public int m_AutoIndex;

			public Focusable m_Focusable;

			public bool m_IsSlot;

			public List<FocusRingRecord> m_ScopeNavigationOrder;
		}

		private readonly VisualElement root;

		private List<FocusRingRecord> m_FocusRing;

		private FocusController focusController => root.focusController;

		public DefaultFocusOrder defaultFocusOrder { get; set; }

		public VisualElementFocusRing(VisualElement root, DefaultFocusOrder dfo = DefaultFocusOrder.ChildOrder)
		{
			defaultFocusOrder = dfo;
			this.root = root;
			m_FocusRing = new List<FocusRingRecord>();
		}

		private int FocusRingAutoIndexSort(FocusRingRecord a, FocusRingRecord b)
		{
			switch (defaultFocusOrder)
			{
			default:
				return Comparer<int>.Default.Compare(a.m_AutoIndex, b.m_AutoIndex);
			case DefaultFocusOrder.PositionXY:
			{
				VisualElement visualElement3 = a.m_Focusable as VisualElement;
				VisualElement visualElement4 = b.m_Focusable as VisualElement;
				if (visualElement3 != null && visualElement4 != null)
				{
					if (visualElement3.layout.position.x < visualElement4.layout.position.x)
					{
						return -1;
					}
					if (visualElement3.layout.position.x > visualElement4.layout.position.x)
					{
						return 1;
					}
					if (visualElement3.layout.position.y < visualElement4.layout.position.y)
					{
						return -1;
					}
					if (visualElement3.layout.position.y > visualElement4.layout.position.y)
					{
						return 1;
					}
				}
				return Comparer<int>.Default.Compare(a.m_AutoIndex, b.m_AutoIndex);
			}
			case DefaultFocusOrder.PositionYX:
			{
				VisualElement visualElement = a.m_Focusable as VisualElement;
				VisualElement visualElement2 = b.m_Focusable as VisualElement;
				if (visualElement != null && visualElement2 != null)
				{
					if (visualElement.layout.position.y < visualElement2.layout.position.y)
					{
						return -1;
					}
					if (visualElement.layout.position.y > visualElement2.layout.position.y)
					{
						return 1;
					}
					if (visualElement.layout.position.x < visualElement2.layout.position.x)
					{
						return -1;
					}
					if (visualElement.layout.position.x > visualElement2.layout.position.x)
					{
						return 1;
					}
				}
				return Comparer<int>.Default.Compare(a.m_AutoIndex, b.m_AutoIndex);
			}
			}
		}

		private int FocusRingSort(FocusRingRecord a, FocusRingRecord b)
		{
			if (a.m_Focusable.tabIndex == 0 && b.m_Focusable.tabIndex == 0)
			{
				return FocusRingAutoIndexSort(a, b);
			}
			if (a.m_Focusable.tabIndex == 0)
			{
				return 1;
			}
			if (b.m_Focusable.tabIndex == 0)
			{
				return -1;
			}
			int num = Comparer<int>.Default.Compare(a.m_Focusable.tabIndex, b.m_Focusable.tabIndex);
			if (num == 0)
			{
				num = FocusRingAutoIndexSort(a, b);
			}
			return num;
		}

		private void DoUpdate()
		{
			m_FocusRing.Clear();
			if (root != null)
			{
				List<FocusRingRecord> list = new List<FocusRingRecord>();
				int scopeIndex = 0;
				BuildRingForScopeRecursive(root, ref scopeIndex, list);
				SortAndFlattenScopeLists(list);
			}
		}

		private void BuildRingForScopeRecursive(VisualElement ve, ref int scopeIndex, List<FocusRingRecord> scopeList)
		{
			int childCount = ve.hierarchy.childCount;
			for (int i = 0; i < childCount; i++)
			{
				VisualElement visualElement = ve.hierarchy[i];
				bool flag = visualElement.parent != null && visualElement == visualElement.parent.contentContainer;
				if (visualElement.isCompositeRoot || flag)
				{
					FocusRingRecord focusRingRecord = new FocusRingRecord
					{
						m_AutoIndex = scopeIndex++,
						m_Focusable = visualElement,
						m_IsSlot = flag,
						m_ScopeNavigationOrder = new List<FocusRingRecord>()
					};
					scopeList.Add(focusRingRecord);
					int scopeIndex2 = 0;
					BuildRingForScopeRecursive(visualElement, ref scopeIndex2, focusRingRecord.m_ScopeNavigationOrder);
				}
				else
				{
					if (visualElement.canGrabFocus && visualElement.isHierarchyDisplayed && visualElement.tabIndex >= 0)
					{
						scopeList.Add(new FocusRingRecord
						{
							m_AutoIndex = scopeIndex++,
							m_Focusable = visualElement,
							m_IsSlot = false,
							m_ScopeNavigationOrder = null
						});
					}
					BuildRingForScopeRecursive(visualElement, ref scopeIndex, scopeList);
				}
			}
		}

		private void SortAndFlattenScopeLists(List<FocusRingRecord> rootScopeList)
		{
			if (rootScopeList == null)
			{
				return;
			}
			rootScopeList.Sort(FocusRingSort);
			foreach (FocusRingRecord rootScope in rootScopeList)
			{
				if (rootScope.m_Focusable.canGrabFocus && rootScope.m_Focusable.tabIndex >= 0)
				{
					if (!rootScope.m_Focusable.excludeFromFocusRing)
					{
						m_FocusRing.Add(rootScope);
					}
					SortAndFlattenScopeLists(rootScope.m_ScopeNavigationOrder);
				}
				else if (rootScope.m_IsSlot)
				{
					SortAndFlattenScopeLists(rootScope.m_ScopeNavigationOrder);
				}
				rootScope.m_ScopeNavigationOrder = null;
			}
		}

		private int GetFocusableInternalIndex(Focusable f)
		{
			if (f != null)
			{
				for (int i = 0; i < m_FocusRing.Count; i++)
				{
					if (f == m_FocusRing[i].m_Focusable)
					{
						return i;
					}
				}
			}
			return -1;
		}

		public FocusChangeDirection GetFocusChangeDirection(Focusable currentFocusable, EventBase e)
		{
			if (e == null)
			{
				throw new ArgumentNullException("e");
			}
			if (e.eventTypeId == EventBase<PointerDownEvent>.TypeId() && focusController.GetFocusableParentForPointerEvent(e.target as Focusable, out var effectiveTarget))
			{
				return VisualElementFocusChangeTarget.GetPooled(effectiveTarget);
			}
			if (currentFocusable is IMGUIContainer)
			{
				return FocusChangeDirection.none;
			}
			if (e.eventTypeId == EventBase<NavigationMoveEvent>.TypeId())
			{
				return ((NavigationMoveEvent)e).direction switch
				{
					NavigationMoveEvent.Direction.Previous => VisualElementFocusChangeDirection.left, 
					NavigationMoveEvent.Direction.Next => VisualElementFocusChangeDirection.right, 
					_ => FocusChangeDirection.none, 
				};
			}
			return FocusChangeDirection.none;
		}

		public Focusable GetNextFocusable(Focusable currentFocusable, FocusChangeDirection direction)
		{
			if (direction == FocusChangeDirection.none || direction == FocusChangeDirection.unspecified)
			{
				return currentFocusable;
			}
			if (!(direction is VisualElementFocusChangeTarget { target: var target }))
			{
				DoUpdate();
				if (m_FocusRing.Count == 0)
				{
					return null;
				}
				int num = 0;
				if (direction == VisualElementFocusChangeDirection.right)
				{
					num = GetFocusableInternalIndex(currentFocusable) + 1;
					if (currentFocusable != null && num == 0)
					{
						return GetNextFocusableInTree(currentFocusable as VisualElement);
					}
					if (num == m_FocusRing.Count)
					{
						num = 0;
					}
					while (m_FocusRing[num].m_Focusable.delegatesFocus)
					{
						num++;
						if (num == m_FocusRing.Count)
						{
							return null;
						}
					}
				}
				else if (direction == VisualElementFocusChangeDirection.left)
				{
					num = GetFocusableInternalIndex(currentFocusable) - 1;
					if (currentFocusable != null && num == -2)
					{
						return GetPreviousFocusableInTree(currentFocusable as VisualElement);
					}
					if (num < 0)
					{
						num = m_FocusRing.Count - 1;
					}
					while (m_FocusRing[num].m_Focusable.delegatesFocus)
					{
						num--;
						if (num == -1)
						{
							return null;
						}
					}
				}
				return m_FocusRing[num].m_Focusable;
			}
			return target;
		}

		internal static Focusable GetNextFocusableInTree(VisualElement currentFocusable)
		{
			if (currentFocusable == null)
			{
				return null;
			}
			VisualElement nextElementDepthFirst = currentFocusable.GetNextElementDepthFirst();
			while (!nextElementDepthFirst.canGrabFocus || nextElementDepthFirst.tabIndex < 0 || nextElementDepthFirst.excludeFromFocusRing)
			{
				nextElementDepthFirst = nextElementDepthFirst.GetNextElementDepthFirst();
				if (nextElementDepthFirst == null)
				{
					nextElementDepthFirst = currentFocusable.GetRoot();
				}
				if (nextElementDepthFirst == currentFocusable)
				{
					return currentFocusable;
				}
			}
			return nextElementDepthFirst;
		}

		internal static Focusable GetPreviousFocusableInTree(VisualElement currentFocusable)
		{
			if (currentFocusable == null)
			{
				return null;
			}
			VisualElement visualElement = currentFocusable.GetPreviousElementDepthFirst();
			while (!visualElement.canGrabFocus || visualElement.tabIndex < 0 || visualElement.excludeFromFocusRing)
			{
				visualElement = visualElement.GetPreviousElementDepthFirst();
				if (visualElement == null)
				{
					visualElement = currentFocusable.GetRoot();
					while (visualElement.childCount > 0)
					{
						visualElement = visualElement.hierarchy.ElementAt(visualElement.childCount - 1);
					}
				}
				if (visualElement == currentFocusable)
				{
					return currentFocusable;
				}
			}
			return visualElement;
		}
	}
	public interface IVisualElementScheduledItem
	{
		VisualElement element { get; }

		bool isActive { get; }

		void Resume();

		void Pause();

		void ExecuteLater(long delayMs);

		IVisualElementScheduledItem StartingIn(long delayMs);

		IVisualElementScheduledItem Every(long intervalMs);

		IVisualElementScheduledItem Until(Func<bool> stopCondition);

		IVisualElementScheduledItem ForDuration(long durationMs);
	}
	public interface IVisualElementScheduler
	{
		IVisualElementScheduledItem Execute(Action<TimerState> timerUpdateEvent);

		IVisualElementScheduledItem Execute(Action updateEvent);
	}
	internal interface IVisualElementPanelActivatable
	{
		VisualElement element { get; }

		bool CanBeActivated();

		void OnPanelActivate();

		void OnPanelDeactivate();
	}
	internal class VisualElementPanelActivator
	{
		private IVisualElementPanelActivatable m_Activatable;

		private EventCallback<AttachToPanelEvent> m_OnAttachToPanelCallback;

		private EventCallback<DetachFromPanelEvent> m_OnDetachFromPanelCallback;

		public bool isActive { get; private set; }

		public bool isDetaching { get; private set; }

		public VisualElementPanelActivator(IVisualElementPanelActivatable activatable)
		{
			m_Activatable = activatable;
			m_OnAttachToPanelCallback = OnEnter;
			m_OnDetachFromPanelCallback = OnLeave;
		}

		public void SetActive(bool action)
		{
			if (isActive != action)
			{
				isActive = action;
				if (isActive)
				{
					m_Activatable.element.RegisterCallback(m_OnAttachToPanelCallback);
					m_Activatable.element.RegisterCallback(m_OnDetachFromPanelCallback);
					SendActivation();
				}
				else
				{
					m_Activatable.element.UnregisterCallback(m_OnAttachToPanelCallback);
					m_Activatable.element.UnregisterCallback(m_OnDetachFromPanelCallback);
					SendDeactivation();
				}
			}
		}

		public void SendActivation()
		{
			if (m_Activatable.CanBeActivated())
			{
				m_Activatable.OnPanelActivate();
			}
		}

		public void SendDeactivation()
		{
			if (m_Activatable.CanBeActivated())
			{
				m_Activatable.OnPanelDeactivate();
			}
		}

		private void OnEnter(AttachToPanelEvent evt)
		{
			if (isActive)
			{
				SendActivation();
			}
		}

		private void OnLeave(DetachFromPanelEvent evt)
		{
			if (isActive)
			{
				isDetaching = true;
				try
				{
					SendDeactivation();
				}
				finally
				{
					isDetaching = false;
				}
			}
		}
	}
	public struct VisualElementStyleSheetSet : IEquatable<VisualElementStyleSheetSet>
	{
		private readonly VisualElement m_Element;

		public int count
		{
			get
			{
				if (m_Element.styleSheetList == null)
				{
					return 0;
				}
				return m_Element.styleSheetList.Count;
			}
		}

		public StyleSheet this[int index]
		{
			get
			{
				if (m_Element.styleSheetList == null)
				{
					throw new ArgumentOutOfRangeException("index");
				}
				return m_Element.styleSheetList[index];
			}
		}

		internal VisualElementStyleSheetSet(VisualElement element)
		{
			m_Element = element;
		}

		public void Add(StyleSheet styleSheet)
		{
			if (styleSheet == null)
			{
				throw new ArgumentNullException("styleSheet");
			}
			if (m_Element.styleSheetList == null)
			{
				m_Element.styleSheetList = new List<StyleSheet>();
			}
			else if (m_Element.styleSheetList.Contains(styleSheet))
			{
				return;
			}
			m_Element.styleSheetList.Add(styleSheet);
			m_Element.IncrementVersion(VersionChangeType.StyleSheet);
		}

		public void Clear()
		{
			if (m_Element.styleSheetList != null)
			{
				m_Element.styleSheetList = null;
				m_Element.IncrementVersion(VersionChangeType.StyleSheet);
			}
		}

		public bool Remove(StyleSheet styleSheet)
		{
			if (styleSheet == null)
			{
				throw new ArgumentNullException("styleSheet");
			}
			if (m_Element.styleSheetList != null && m_Element.styleSheetList.Remove(styleSheet))
			{
				if (m_Element.styleSheetList.Count == 0)
				{
					m_Element.styleSheetList = null;
				}
				m_Element.IncrementVersion(VersionChangeType.StyleSheet);
				return true;
			}
			return false;
		}

		internal void Swap(StyleSheet old, StyleSheet @new)
		{
			if (old == null)
			{
				throw new ArgumentNullException("old");
			}
			if (@new == null)
			{
				throw new ArgumentNullException("new");
			}
			if (m_Element.styleSheetList != null)
			{
				int num = m_Element.styleSheetList.IndexOf(old);
				if (num >= 0)
				{
					m_Element.IncrementVersion(VersionChangeType.StyleSheet);
					m_Element.styleSheetList[num] = @new;
				}
			}
		}

		public bool Contains(StyleSheet styleSheet)
		{
			if (styleSheet == null)
			{
				throw new ArgumentNullException("styleSheet");
			}
			if (m_Element.styleSheetList != null)
			{
				return m_Element.styleSheetList.Contains(styleSheet);
			}
			return false;
		}

		public bool Equals(VisualElementStyleSheetSet other)
		{
			return object.Equals(m_Element, other.m_Element);
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			return obj is VisualElementStyleSheetSet && Equals((VisualElementStyleSheetSet)obj);
		}

		public override int GetHashCode()
		{
			return (m_Element != null) ? m_Element.GetHashCode() : 0;
		}

		public static bool operator ==(VisualElementStyleSheetSet left, VisualElementStyleSheetSet right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(VisualElementStyleSheetSet left, VisualElementStyleSheetSet right)
		{
			return !left.Equals(right);
		}
	}
	internal static class VisualElementUtils
	{
		private static readonly HashSet<string> s_usedNames = new HashSet<string>();

		private static readonly Type s_FoldoutType = typeof(Foldout);

		private static readonly string s_InspectorElementUssClassName = "unity-inspector-element";

		public static string GetUniqueName(string nameBase)
		{
			string text = nameBase;
			int num = 2;
			while (s_usedNames.Contains(text))
			{
				text = nameBase + num;
				num++;
			}
			s_usedNames.Add(text);
			return text;
		}

		internal static int GetFoldoutDepth(this VisualElement element)
		{
			int num = 0;
			if (element.parent != null)
			{
				for (VisualElement parent = element.parent; parent != null; parent = parent.parent)
				{
					if (s_FoldoutType.IsAssignableFrom(parent.GetType()))
					{
						num++;
					}
				}
			}
			return num;
		}

		internal static void AssignInspectorStyleIfNecessary(this VisualElement element, string classNameToEnable)
		{
			VisualElement firstAncestorWhere = element.GetFirstAncestorWhere((VisualElement i) => i.ClassListContains(s_InspectorElementUssClassName));
			element.EnableInClassList(classNameToEnable, firstAncestorWhere != null);
		}
	}
	internal class VisualElementAnimationSystem : BaseVisualTreeUpdater
	{
		private HashSet<IValueAnimationUpdate> m_Animations = new HashSet<IValueAnimationUpdate>();

		private List<IValueAnimationUpdate> m_IterationList = new List<IValueAnimationUpdate>();

		private bool m_HasNewAnimations = false;

		private bool m_IterationListDirty = false;

		private static readonly string s_Description = "Animation Update";

		private static readonly ProfilerMarker s_ProfilerMarker = new ProfilerMarker(s_Description);

		private static readonly string s_StylePropertyAnimationDescription = "StylePropertyAnimation Update";

		private static readonly ProfilerMarker s_StylePropertyAnimationProfilerMarker = new ProfilerMarker(s_StylePropertyAnimationDescription);

		private long lastUpdate;

		public override ProfilerMarker profilerMarker => s_ProfilerMarker;

		private static ProfilerMarker stylePropertyAnimationProfilerMarker => s_StylePropertyAnimationProfilerMarker;

		private long CurrentTimeMs()
		{
			return Panel.TimeSinceStartupMs();
		}

		public void UnregisterAnimation(IValueAnimationUpdate anim)
		{
			m_Animations.Remove(anim);
			m_IterationListDirty = true;
		}

		public void UnregisterAnimations(List<IValueAnimationUpdate> anims)
		{
			foreach (IValueAnimationUpdate anim in anims)
			{
				m_Animations.Remove(anim);
			}
			m_IterationListDirty = true;
		}

		public void RegisterAnimation(IValueAnimationUpdate anim)
		{
			m_Animations.Add(anim);
			m_HasNewAnimations = true;
			m_IterationListDirty = true;
		}

		public void RegisterAnimations(List<IValueAnimationUpdate> anims)
		{
			foreach (IValueAnimationUpdate anim in anims)
			{
				m_Animations.Add(anim);
			}
			m_HasNewAnimations = true;
			m_IterationListDirty = true;
		}

		public override void Update()
		{
			long num = Panel.TimeSinceStartupMs();
			if (m_IterationListDirty)
			{
				m_IterationList = m_Animations.ToList();
				m_IterationListDirty = false;
			}
			if (m_HasNewAnimations || lastUpdate != num)
			{
				foreach (IValueAnimationUpdate iteration in m_IterationList)
				{
					iteration.Tick(num);
				}
				m_HasNewAnimations = false;
				lastUpdate = num;
			}
			IStylePropertyAnimationSystem styleAnimationSystem = base.panel.styleAnimationSystem;
			using (stylePropertyAnimationProfilerMarker.Auto())
			{
				styleAnimationSystem.Update();
			}
		}

		public override void OnVersionChanged(VisualElement ve, VersionChangeType versionChangeType)
		{
		}
	}
	internal class VisualTreeHierarchyFlagsUpdater : BaseVisualTreeUpdater
	{
		private uint m_Version = 0u;

		private uint m_LastVersion = 0u;

		private static readonly string s_Description = "Update Hierarchy Flags";

		private static readonly ProfilerMarker s_ProfilerMarker = new ProfilerMarker(s_Description);

		public override ProfilerMarker profilerMarker => s_ProfilerMarker;

		public override void OnVersionChanged(VisualElement ve, VersionChangeType versionChangeType)
		{
			if ((versionChangeType & (VersionChangeType.Hierarchy | VersionChangeType.Overflow | VersionChangeType.BorderWidth | VersionChangeType.Transform | VersionChangeType.Size | VersionChangeType.EventCallbackCategories | VersionChangeType.Picking)) != 0)
			{
				bool flag = (versionChangeType & VersionChangeType.Transform) != 0;
				bool flag2 = (versionChangeType & (VersionChangeType.Overflow | VersionChangeType.BorderWidth | VersionChangeType.Transform | VersionChangeType.Size)) != 0;
				bool flag3 = (versionChangeType & (VersionChangeType.Hierarchy | VersionChangeType.EventCallbackCategories)) != 0;
				VisualElementFlags visualElementFlags = (VisualElementFlags)((flag ? 17 : 0) | (flag2 ? 4 : 0) | (flag3 ? 32 : 0));
				VisualElementFlags visualElementFlags2 = visualElementFlags & ~ve.m_Flags;
				if (visualElementFlags2 != 0)
				{
					DirtyHierarchy(ve, visualElementFlags2);
				}
				DirtyBoundingBoxHierarchy(ve);
				m_Version++;
			}
		}

		private static void DirtyHierarchy(VisualElement ve, VisualElementFlags mustDirtyFlags)
		{
			ve.m_Flags |= mustDirtyFlags;
			int childCount = ve.hierarchy.childCount;
			for (int i = 0; i < childCount; i++)
			{
				VisualElement visualElement = ve.hierarchy[i];
				VisualElementFlags visualElementFlags = mustDirtyFlags & ~visualElement.m_Flags;
				if (visualElementFlags != 0)
				{
					DirtyHierarchy(visualElement, visualElementFlags);
				}
			}
		}

		private static void DirtyBoundingBoxHierarchy(VisualElement ve)
		{
			ve.isBoundingBoxDirty = true;
			ve.isWorldBoundingBoxDirty = true;
			VisualElement parent = ve.hierarchy.parent;
			while (parent != null && !parent.isBoundingBoxDirty)
			{
				parent.isBoundingBoxDirty = true;
				parent.isWorldBoundingBoxDirty = true;
				parent = parent.hierarchy.parent;
			}
		}

		public override void Update()
		{
			if (m_Version != m_LastVersion)
			{
				m_LastVersion = m_Version;
				base.panel.UpdateElementUnderPointers();
				base.panel.visualTree.UpdateBoundingBox();
			}
		}
	}
	internal enum HierarchyChangeType
	{
		Add,
		Remove,
		Move
	}
	internal abstract class BaseVisualTreeHierarchyTrackerUpdater : BaseVisualTreeUpdater
	{
		private enum State
		{
			Waiting,
			TrackingAddOrMove,
			TrackingRemove
		}

		private State m_State = State.Waiting;

		private VisualElement m_CurrentChangeElement;

		private VisualElement m_CurrentChangeParent;

		protected abstract void OnHierarchyChange(VisualElement ve, HierarchyChangeType type);

		public override void OnVersionChanged(VisualElement ve, VersionChangeType versionChangeType)
		{
			if ((versionChangeType & VersionChangeType.Hierarchy) == VersionChangeType.Hierarchy)
			{
				switch (m_State)
				{
				case State.Waiting:
					ProcessNewChange(ve);
					break;
				case State.TrackingRemove:
					ProcessRemove(ve);
					break;
				case State.TrackingAddOrMove:
					ProcessAddOrMove(ve);
					break;
				}
			}
		}

		public override void Update()
		{
			Debug.Assert(m_State == State.TrackingAddOrMove || m_State == State.Waiting);
			if (m_State == State.TrackingAddOrMove)
			{
				OnHierarchyChange(m_CurrentChangeElement, HierarchyChangeType.Move);
				m_State = State.Waiting;
			}
			m_CurrentChangeElement = null;
			m_CurrentChangeParent = null;
		}

		private void ProcessNewChange(VisualElement ve)
		{
			m_CurrentChangeElement = ve;
			m_CurrentChangeParent = ve.parent;
			if (m_CurrentChangeParent == null && ve.panel != null)
			{
				OnHierarchyChange(m_CurrentChangeElement, HierarchyChangeType.Move);
				m_State = State.Waiting;
			}
			else
			{
				m_State = ((m_CurrentChangeParent != null) ? State.TrackingAddOrMove : State.TrackingRemove);
			}
		}

		private void ProcessAddOrMove(VisualElement ve)
		{
			Debug.Assert(m_CurrentChangeParent != null);
			if (m_CurrentChangeParent == ve)
			{
				OnHierarchyChange(m_CurrentChangeElement, HierarchyChangeType.Add);
				m_State = State.Waiting;
			}
			else
			{
				OnHierarchyChange(m_CurrentChangeElement, HierarchyChangeType.Move);
				ProcessNewChange(ve);
			}
		}

		private void ProcessRemove(VisualElement ve)
		{
			OnHierarchyChange(m_CurrentChangeElement, HierarchyChangeType.Remove);
			if (ve.panel != null)
			{
				m_CurrentChangeParent = null;
				m_CurrentChangeElement = null;
				m_State = State.Waiting;
			}
			else
			{
				m_CurrentChangeElement = ve;
			}
		}
	}
	internal static class StyleCache
	{
		private static Dictionary<long, ComputedStyle> s_ComputedStyleCache = new Dictionary<long, ComputedStyle>();

		private static Dictionary<int, StyleVariableContext> s_StyleVariableContextCache = new Dictionary<int, StyleVariableContext>();

		private static Dictionary<int, ComputedTransitionProperty[]> s_ComputedTransitionsCache = new Dictionary<int, ComputedTransitionProperty[]>();

		public static bool TryGetValue(long hash, out ComputedStyle data)
		{
			return s_ComputedStyleCache.TryGetValue(hash, out data);
		}

		public static void SetValue(long hash, ref ComputedStyle data)
		{
			s_ComputedStyleCache[hash] = data;
		}

		public static bool TryGetValue(int hash, out StyleVariableContext data)
		{
			return s_StyleVariableContextCache.TryGetValue(hash, out data);
		}

		public static void SetValue(int hash, StyleVariableContext data)
		{
			s_StyleVariableContextCache[hash] = data;
		}

		public static bool TryGetValue(int hash, out ComputedTransitionProperty[] data)
		{
			return s_ComputedTransitionsCache.TryGetValue(hash, out data);
		}

		public static void SetValue(int hash, ComputedTransitionProperty[] data)
		{
			s_ComputedTransitionsCache[hash] = data;
		}

		public static void ClearStyleCache()
		{
			foreach (KeyValuePair<long, ComputedStyle> item in s_ComputedStyleCache)
			{
				item.Value.Release();
			}
			s_ComputedStyleCache.Clear();
			s_StyleVariableContextCache.Clear();
			s_ComputedTransitionsCache.Clear();
		}
	}
	internal class VisualTreeStyleUpdater : BaseVisualTreeUpdater
	{
		private HashSet<VisualElement> m_ApplyStyleUpdateList = new HashSet<VisualElement>();

		private HashSet<VisualElement> m_TransitionPropertyUpdateList = new HashSet<VisualElement>();

		private bool m_IsApplyingStyles = false;

		private uint m_Version = 0u;

		private uint m_LastVersion = 0u;

		private VisualTreeStyleUpdaterTraversal m_StyleContextHierarchyTraversal = new VisualTreeStyleUpdaterTraversal();

		private static readonly string s_Description = "Update Style";

		private static readonly ProfilerMarker s_ProfilerMarker = new ProfilerMarker(s_Description);

		public VisualTreeStyleUpdaterTraversal traversal
		{
			get
			{
				return m_StyleContextHierarchyTraversal;
			}
			set
			{
				m_StyleContextHierarchyTraversal = value;
				base.panel?.visualTree.IncrementVersion(VersionChangeType.Layout | VersionChangeType.StyleSheet | VersionChangeType.Styles | VersionChangeType.Transform);
			}
		}

		public override ProfilerMarker profilerMarker => s_ProfilerMarker;

		protected bool disposed { get; private set; }

		public override void OnVersionChanged(VisualElement ve, VersionChangeType versionChangeType)
		{
			if ((versionChangeType & (VersionChangeType.StyleSheet | VersionChangeType.TransitionProperty)) == 0)
			{
				return;
			}
			m_Version++;
			if ((versionChangeType & VersionChangeType.StyleSheet) != 0)
			{
				if (m_IsApplyingStyles)
				{
					m_ApplyStyleUpdateList.Add(ve);
				}
				else
				{
					m_StyleContextHierarchyTraversal.AddChangedElement(ve, versionChangeType);
				}
			}
			if ((versionChangeType & VersionChangeType.TransitionProperty) != 0)
			{
				m_TransitionPropertyUpdateList.Add(ve);
			}
		}

		public override void Update()
		{
			if (m_Version == m_LastVersion)
			{
				return;
			}
			m_LastVersion = m_Version;
			ApplyStyles();
			m_StyleContextHierarchyTraversal.Clear();
			foreach (VisualElement applyStyleUpdate in m_ApplyStyleUpdateList)
			{
				m_StyleContextHierarchyTraversal.AddChangedElement(applyStyleUpdate, VersionChangeType.StyleSheet);
			}
			m_ApplyStyleUpdateList.Clear();
			foreach (VisualElement transitionPropertyUpdate in m_TransitionPropertyUpdateList)
			{
				if (transitionPropertyUpdate.hasRunningAnimations || transitionPropertyUpdate.hasCompletedAnimations)
				{
					ComputedTransitionUtils.UpdateComputedTransitions(ref transitionPropertyUpdate.computedStyle);
					m_StyleContextHierarchyTraversal.CancelAnimationsWithNoTransitionProperty(transitionPropertyUpdate, ref transitionPropertyUpdate.computedStyle);
				}
			}
			m_TransitionPropertyUpdateList.Clear();
		}

		protected override void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (disposing)
				{
					m_StyleContextHierarchyTraversal.Clear();
				}
				disposed = true;
			}
		}

		private void ApplyStyles()
		{
			Debug.Assert(base.visualTree.panel != null);
			m_IsApplyingStyles = true;
			m_StyleContextHierarchyTraversal.PrepareTraversal(base.panel.scaledPixelsPerPoint);
			m_StyleContextHierarchyTraversal.Traverse(base.visualTree);
			m_IsApplyingStyles = false;
		}
	}
	internal class StyleMatchingContext
	{
		private List<StyleSheet> m_StyleSheetStack;

		public StyleVariableContext variableContext;

		public VisualElement currentElement;

		public Action<VisualElement, MatchResultInfo> processResult;

		public AncestorFilter ancestorFilter = new AncestorFilter();

		public int styleSheetCount => m_StyleSheetStack.Count;

		public StyleMatchingContext(Action<VisualElement, MatchResultInfo> processResult)
		{
			m_StyleSheetStack = new List<StyleSheet>();
			variableContext = StyleVariableContext.none;
			currentElement = null;
			this.processResult = processResult;
		}

		public void AddStyleSheet(StyleSheet sheet)
		{
			if (!(sheet == null))
			{
				m_StyleSheetStack.Add(sheet);
			}
		}

		public void RemoveStyleSheetRange(int index, int count)
		{
			m_StyleSheetStack.RemoveRange(index, count);
		}

		public StyleSheet GetStyleSheetAt(int index)
		{
			return m_StyleSheetStack[index];
		}
	}
	internal class VisualTreeStyleUpdaterTraversal : HierarchyTraversal
	{
		private StyleVariableContext m_ProcessVarContext = new StyleVariableContext();

		private HashSet<VisualElement> m_UpdateList = new HashSet<VisualElement>();

		private HashSet<VisualElement> m_ParentList = new HashSet<VisualElement>();

		private List<SelectorMatchRecord> m_TempMatchResults = new List<SelectorMatchRecord>();

		private StyleMatchingContext m_StyleMatchingContext = new StyleMatchingContext(OnProcessMatchResult);

		private StylePropertyReader m_StylePropertyReader = new StylePropertyReader();

		private readonly List<StylePropertyId> m_AnimatedProperties = new List<StylePropertyId>();

		private float currentPixelsPerPoint { get; set; } = 1f;

		public StyleMatchingContext styleMatchingContext => m_StyleMatchingContext;

		public void PrepareTraversal(float pixelsPerPoint)
		{
			currentPixelsPerPoint = pixelsPerPoint;
		}

		public void AddChangedElement(VisualElement ve, VersionChangeType versionChangeType)
		{
			m_UpdateList.Add(ve);
			if ((versionChangeType & VersionChangeType.StyleSheet) == VersionChangeType.StyleSheet)
			{
				PropagateToChildren(ve);
			}
			PropagateToParents(ve);
		}

		public void Clear()
		{
			m_UpdateList.Clear();
			m_ParentList.Clear();
			m_TempMatchResults.Clear();
		}

		private void PropagateToChildren(VisualElement ve)
		{
			int childCount = ve.hierarchy.childCount;
			for (int i = 0; i < childCount; i++)
			{
				VisualElement visualElement = ve.hierarchy[i];
				if (m_UpdateList.Add(visualElement))
				{
					PropagateToChildren(visualElement);
				}
			}
		}

		private void PropagateToParents(VisualElement ve)
		{
			VisualElement parent = ve.hierarchy.parent;
			while (parent != null && m_ParentList.Add(parent))
			{
				parent = parent.hierarchy.parent;
			}
		}

		private static void OnProcessMatchResult(VisualElement current, MatchResultInfo info)
		{
			current.triggerPseudoMask |= info.triggerPseudoMask;
			current.dependencyPseudoMask |= info.dependencyPseudoMask;
		}

		public override void TraverseRecursive(VisualElement element, int depth)
		{
			if (ShouldSkipElement(element))
			{
				return;
			}
			bool flag = m_UpdateList.Contains(element);
			if (flag)
			{
				element.triggerPseudoMask = (PseudoStates)0;
				element.dependencyPseudoMask = (PseudoStates)0;
			}
			int styleSheetCount = m_StyleMatchingContext.styleSheetCount;
			if (element.styleSheetList != null)
			{
				for (int i = 0; i < element.styleSheetList.Count; i++)
				{
					StyleSheet styleSheet = element.styleSheetList[i];
					if (styleSheet.flattenedRecursiveImports != null)
					{
						for (int j = 0; j < styleSheet.flattenedRecursiveImports.Count; j++)
						{
							m_StyleMatchingContext.AddStyleSheet(styleSheet.flattenedRecursiveImports[j]);
						}
					}
					m_StyleMatchingContext.AddStyleSheet(styleSheet);
				}
			}
			StyleVariableContext variableContext = m_StyleMatchingContext.variableContext;
			int customPropertiesCount = element.computedStyle.customPropertiesCount;
			if (flag)
			{
				m_StyleMatchingContext.currentElement = element;
				StyleSelectorHelper.FindMatches(m_StyleMatchingContext, m_TempMatchResults, styleSheetCount - 1);
				ComputedStyle computedStyle = ProcessMatchedRules(element, m_TempMatchResults);
				computedStyle.Acquire();
				if (element.hasInlineStyle)
				{
					element.inlineStyleAccess.ApplyInlineStyles(ref computedStyle);
				}
				ComputedTransitionUtils.UpdateComputedTransitions(ref computedStyle);
				if (element.hasRunningAnimations && !ComputedTransitionUtils.SameTransitionProperty(ref element.computedStyle, ref computedStyle))
				{
					CancelAnimationsWithNoTransitionProperty(element, ref computedStyle);
				}
				if (computedStyle.hasTransition && element.styleInitialized)
				{
					ProcessTransitions(element, ref element.computedStyle, ref computedStyle);
					element.SetComputedStyle(ref computedStyle);
					ForceUpdateTransitions(element);
				}
				else
				{
					element.SetComputedStyle(ref computedStyle);
				}
				computedStyle.Release();
				element.styleInitialized = true;
				element.inheritedStylesHash = element.computedStyle.inheritedData.GetHashCode();
				m_StyleMatchingContext.currentElement = null;
				m_TempMatchResults.Clear();
			}
			else
			{
				m_StyleMatchingContext.variableContext = element.variableContext;
			}
			if (flag && (customPropertiesCount > 0 || element.computedStyle.customPropertiesCount > 0) && element.HasEventCallbacksOrDefaultActions(EventBase<CustomStyleResolvedEvent>.EventCategory))
			{
				using CustomStyleResolvedEvent customStyleResolvedEvent = EventBase<CustomStyleResolvedEvent>.GetPooled();
				customStyleResolvedEvent.target = element;
				element.HandleEventAtTargetAndDefaultPhase(customStyleResolvedEvent);
			}
			m_StyleMatchingContext.ancestorFilter.PushElement(element);
			Recurse(element, depth);
			m_StyleMatchingContext.ancestorFilter.PopElement();
			m_StyleMatchingContext.variableContext = variableContext;
			if (m_StyleMatchingContext.styleSheetCount > styleSheetCount)
			{
				m_StyleMatchingContext.RemoveStyleSheetRange(styleSheetCount, m_StyleMatchingContext.styleSheetCount - styleSheetCount);
			}
		}

		private void ProcessTransitions(VisualElement element, ref ComputedStyle oldStyle, ref ComputedStyle newStyle)
		{
			for (int num = newStyle.computedTransitions.Length - 1; num >= 0; num--)
			{
				ComputedTransitionProperty computedTransitionProperty = newStyle.computedTransitions[num];
				if (!element.hasInlineStyle || !element.inlineStyleAccess.IsValueSet(computedTransitionProperty.id))
				{
					ComputedStyle.StartAnimation(element, computedTransitionProperty.id, ref oldStyle, ref newStyle, computedTransitionProperty.durationMs, computedTransitionProperty.delayMs, computedTransitionProperty.easingCurve);
				}
			}
		}

		private void ForceUpdateTransitions(VisualElement element)
		{
			element.styleAnimation.GetAllAnimations(m_AnimatedProperties);
			if (m_AnimatedProperties.Count <= 0)
			{
				return;
			}
			foreach (StylePropertyId animatedProperty in m_AnimatedProperties)
			{
				element.styleAnimation.UpdateAnimation(animatedProperty);
			}
			m_AnimatedProperties.Clear();
		}

		internal void CancelAnimationsWithNoTransitionProperty(VisualElement element, ref ComputedStyle newStyle)
		{
			element.styleAnimation.GetAllAnimations(m_AnimatedProperties);
			foreach (StylePropertyId animatedProperty in m_AnimatedProperties)
			{
				if (!newStyle.HasTransitionProperty(animatedProperty))
				{
					element.styleAnimation.CancelAnimation(animatedProperty);
				}
			}
			m_AnimatedProperties.Clear();
		}

		protected bool ShouldSkipElement(VisualElement element)
		{
			return !m_ParentList.Contains(element) && !m_UpdateList.Contains(element);
		}

		private ComputedStyle ProcessMatchedRules(VisualElement element, List<SelectorMatchRecord> matchingSelectors)
		{
			matchingSelectors.Sort((SelectorMatchRecord a, SelectorMatchRecord b) => SelectorMatchRecord.Compare(a, b));
			long num = element.fullTypeName.GetHashCode();
			num = (num * 397) ^ currentPixelsPerPoint.GetHashCode();
			int variableHash = m_StyleMatchingContext.variableContext.GetVariableHash();
			int num2 = 0;
			foreach (SelectorMatchRecord matchingSelector in matchingSelectors)
			{
				num2 += matchingSelector.complexSelector.rule.customPropertiesCount;
			}
			if (num2 > 0)
			{
				m_ProcessVarContext.AddInitialRange(m_StyleMatchingContext.variableContext);
			}
			foreach (SelectorMatchRecord matchingSelector2 in matchingSelectors)
			{
				StyleSheet sheet = matchingSelector2.sheet;
				StyleRule rule = matchingSelector2.complexSelector.rule;
				int specificity = matchingSelector2.complexSelector.specificity;
				num = (num * 397) ^ sheet.contentHash;
				num = (num * 397) ^ rule.GetHashCode();
				num = (num * 397) ^ specificity;
				if (rule.customPropertiesCount > 0)
				{
					ProcessMatchedVariables(matchingSelector2.sheet, rule);
				}
			}
			VisualElement parent = element.hierarchy.parent;
			int num3 = parent?.inheritedStylesHash ?? 0;
			num = (num * 397) ^ num3;
			int num4 = variableHash;
			if (num2 > 0)
			{
				num4 = m_ProcessVarContext.GetVariableHash();
			}
			num = (num * 397) ^ num4;
			if (variableHash != num4)
			{
				if (!StyleCache.TryGetValue(num4, out StyleVariableContext data))
				{
					data = new StyleVariableContext(m_ProcessVarContext);
					StyleCache.SetValue(num4, data);
				}
				m_StyleMatchingContext.variableContext = data;
			}
			element.variableContext = m_StyleMatchingContext.variableContext;
			m_ProcessVarContext.Clear();
			if (!StyleCache.TryGetValue(num, out var data2))
			{
				ref ComputedStyle reference;
				if (parent != null)
				{
					_ = ref parent.computedStyle;
					reference = ref parent.computedStyle;
				}
				else
				{
					reference = ref InitialStyle.Get();
				}
				ref ComputedStyle parentStyle = ref reference;
				data2 = ComputedStyle.Create(ref parentStyle);
				data2.matchingRulesHash = num;
				float scaledPixelsPerPoint = element.scaledPixelsPerPoint;
				foreach (SelectorMatchRecord matchingSelector3 in matchingSelectors)
				{
					m_StylePropertyReader.SetContext(matchingSelector3.sheet, matchingSelector3.complexSelector, m_StyleMatchingContext.variableContext, scaledPixelsPerPoint);
					data2.ApplyProperties(m_StylePropertyReader, ref parentStyle);
				}
				data2.FinalizeApply(ref parentStyle);
				StyleCache.SetValue(num, ref data2);
			}
			return data2;
		}

		private void ProcessMatchedVariables(StyleSheet sheet, StyleRule rule)
		{
			StyleProperty[] properties = rule.properties;
			foreach (StyleProperty styleProperty in properties)
			{
				if (styleProperty.isCustomProperty)
				{
					StyleVariable sv = new StyleVariable(styleProperty.name, sheet, styleProperty.values);
					m_ProcessVarContext.Add(sv);
				}
			}
		}
	}
	internal enum VisualTreeUpdatePhase
	{
		ViewData,
		Bindings,
		Animation,
		Styles,
		Layout,
		TransformClip,
		Repaint,
		Count
	}
	internal sealed class VisualTreeUpdater : IDisposable
	{
		private class UpdaterArray
		{
			private IVisualTreeUpdater[] m_VisualTreeUpdaters;

			public IVisualTreeUpdater this[VisualTreeUpdatePhase phase]
			{
				get
				{
					return m_VisualTreeUpdaters[(int)phase];
				}
				set
				{
					m_VisualTreeUpdaters[(int)phase] = value;
				}
			}

			public IVisualTreeUpdater this[int index]
			{
				get
				{
					return m_VisualTreeUpdaters[index];
				}
				set
				{
					m_VisualTreeUpdaters[index] = value;
				}
			}

			public UpdaterArray()
			{
				m_VisualTreeUpdaters = new IVisualTreeUpdater[7];
			}
		}

		private BaseVisualElementPanel m_Panel;

		private UpdaterArray m_UpdaterArray;

		public VisualTreeUpdater(BaseVisualElementPanel panel)
		{
			m_Panel = panel;
			m_UpdaterArray = new UpdaterArray();
			SetDefaultUpdaters();
		}

		public void Dispose()
		{
			for (int i = 0; i < 7; i++)
			{
				IVisualTreeUpdater visualTreeUpdater = m_UpdaterArray[i];
				visualTreeUpdater.Dispose();
			}
		}

		public void UpdateVisualTree()
		{
			for (int i = 0; i < 7; i++)
			{
				IVisualTreeUpdater visualTreeUpdater = m_UpdaterArray[i];
				using (visualTreeUpdater.profilerMarker.Auto())
				{
					visualTreeUpdater.Update();
				}
			}
		}

		public void UpdateVisualTreePhase(VisualTreeUpdatePhase phase)
		{
			IVisualTreeUpdater visualTreeUpdater = m_UpdaterArray[phase];
			using (visualTreeUpdater.profilerMarker.Auto())
			{
				visualTreeUpdater.Update();
			}
		}

		public void OnVersionChanged(VisualElement ve, VersionChangeType versionChangeType)
		{
			for (int i = 0; i < 7; i++)
			{
				IVisualTreeUpdater visualTreeUpdater = m_UpdaterArray[i];
				visualTreeUpdater.OnVersionChanged(ve, versionChangeType);
			}
		}

		public void SetUpdater(IVisualTreeUpdater updater, VisualTreeUpdatePhase phase)
		{
			m_UpdaterArray[phase]?.Dispose();
			updater.panel = m_Panel;
			m_UpdaterArray[phase] = updater;
		}

		public void SetUpdater<T>(VisualTreeUpdatePhase phase) where T : IVisualTreeUpdater, new()
		{
			m_UpdaterArray[phase]?.Dispose();
			T val = new T
			{
				panel = m_Panel
			};
			m_UpdaterArray[phase] = val;
		}

		public IVisualTreeUpdater GetUpdater(VisualTreeUpdatePhase phase)
		{
			return m_UpdaterArray[phase];
		}

		private void SetDefaultUpdaters()
		{
			SetUpdater<VisualTreeViewDataUpdater>(VisualTreeUpdatePhase.ViewData);
			SetUpdater<VisualTreeBindingsUpdater>(VisualTreeUpdatePhase.Bindings);
			SetUpdater<VisualElementAnimationSystem>(VisualTreeUpdatePhase.Animation);
			SetUpdater<VisualTreeStyleUpdater>(VisualTreeUpdatePhase.Styles);
			SetUpdater<UIRLayoutUpdater>(VisualTreeUpdatePhase.Layout);
			SetUpdater<VisualTreeHierarchyFlagsUpdater>(VisualTreeUpdatePhase.TransformClip);
			SetUpdater<UIRRepaintUpdater>(VisualTreeUpdatePhase.Repaint);
		}
	}
	internal interface IVisualTreeUpdater : IDisposable
	{
		BaseVisualElementPanel panel { get; set; }

		ProfilerMarker profilerMarker { get; }

		void Update();

		void OnVersionChanged(VisualElement ve, VersionChangeType versionChangeType);
	}
	internal abstract class BaseVisualTreeUpdater : IVisualTreeUpdater, IDisposable
	{
		private BaseVisualElementPanel m_Panel;

		public BaseVisualElementPanel panel
		{
			get
			{
				return m_Panel;
			}
			set
			{
				m_Panel = value;
				if (this.panelChanged != null)
				{
					this.panelChanged(value);
				}
			}
		}

		public VisualElement visualTree => panel.visualTree;

		public abstract ProfilerMarker profilerMarker { get; }

		public event Action<BaseVisualElementPanel> panelChanged;

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
		}

		public abstract void Update();

		public abstract void OnVersionChanged(VisualElement ve, VersionChangeType versionChangeType);
	}
	internal class VisualTreeViewDataUpdater : BaseVisualTreeUpdater
	{
		private HashSet<VisualElement> m_UpdateList = new HashSet<VisualElement>();

		private HashSet<VisualElement> m_ParentList = new HashSet<VisualElement>();

		private const int kMaxValidatePersistentDataCount = 5;

		private uint m_Version = 0u;

		private uint m_LastVersion = 0u;

		private static readonly string s_Description = "Update ViewData";

		private static readonly ProfilerMarker s_ProfilerMarker = new ProfilerMarker(s_Description);

		public override ProfilerMarker profilerMarker => s_ProfilerMarker;

		public override void OnVersionChanged(VisualElement ve, VersionChangeType versionChangeType)
		{
			if ((versionChangeType & VersionChangeType.ViewData) == VersionChangeType.ViewData)
			{
				m_Version++;
				m_UpdateList.Add(ve);
				PropagateToParents(ve);
			}
		}

		public override void Update()
		{
			if (m_Version == m_LastVersion)
			{
				return;
			}
			int num = 0;
			while (m_LastVersion != m_Version)
			{
				m_LastVersion = m_Version;
				ValidateViewDataOnSubTree(base.visualTree, enablePersistence: true);
				num++;
				if (num > 5)
				{
					Debug.LogError("UIElements: Too many children recursively added that rely on persistent view data: " + base.visualTree);
					break;
				}
			}
			m_UpdateList.Clear();
			m_ParentList.Clear();
		}

		private void ValidateViewDataOnSubTree(VisualElement ve, bool enablePersistence)
		{
			enablePersistence = ve.IsViewDataPersitenceSupportedOnChildren(enablePersistence);
			if (m_UpdateList.Contains(ve))
			{
				m_UpdateList.Remove(ve);
				ve.OnViewDataReady(enablePersistence);
			}
			if (m_ParentList.Contains(ve))
			{
				m_ParentList.Remove(ve);
				int childCount = ve.hierarchy.childCount;
				for (int i = 0; i < childCount; i++)
				{
					ValidateViewDataOnSubTree(ve.hierarchy[i], enablePersistence);
				}
			}
		}

		private void PropagateToParents(VisualElement ve)
		{
			VisualElement parent = ve.hierarchy.parent;
			while (parent != null && m_ParentList.Add(parent))
			{
				parent = parent.hierarchy.parent;
			}
		}
	}
}
namespace UnityEngine.UIElements.UIR
{
	internal struct GfxUpdateBufferRange
	{
		public uint offsetFromWriteStart;

		public uint size;

		public UIntPtr source;
	}
	internal struct DrawBufferRange
	{
		public int firstIndex;

		public int indexCount;

		public int minIndexVal;

		public int vertsReferenced;
	}
	[VisibleToOtherModules(new string[] { "Unity.UIElements" })]
	[NativeHeader("ModuleOverrides/com.unity.ui/Core/Native/Renderer/UIRendererUtility.h")]
	internal class Utility
	{
		[Flags]
		internal enum RendererCallbacks
		{
			RendererCallback_Init = 1,
			RendererCallback_Exec = 2,
			RendererCallback_Cleanup = 4
		}

		internal enum GPUBufferType
		{
			Vertex,
			Index
		}

		public class GPUBuffer<T> : IDisposable where T : struct
		{
			private IntPtr buffer;

			private int elemCount;

			private int elemStride;

			public int ElementStride => elemStride;

			public int Count => elemCount;

			internal IntPtr BufferPointer => buffer;

			public GPUBuffer(int elementCount, GPUBufferType type)
			{
				elemCount = elementCount;
				elemStride = UnsafeUtility.SizeOf<T>();
				buffer = AllocateBuffer(elementCount, elemStride, type == GPUBufferType.Vertex);
			}

			public void Dispose()
			{
				FreeBuffer(buffer);
			}

			public unsafe void UpdateRanges(NativeSlice<GfxUpdateBufferRange> ranges, int rangesMin, int rangesMax)
			{
				UpdateBufferRanges(buffer, new IntPtr(ranges.GetUnsafePtr()), ranges.Length, rangesMin, rangesMax);
			}
		}

		private static ProfilerMarker s_MarkerRaiseEngineUpdate = new ProfilerMarker("UIR.RaiseEngineUpdate");

		public static event Action<bool> GraphicsResourcesRecreate;

		public static event Action EngineUpdate;

		public static event Action FlushPendingResources;

		public static event Action<Camera> RegisterIntermediateRenderers;

		public static event Action<IntPtr> RenderNodeAdd;

		public static event Action<IntPtr> RenderNodeExecute;

		public static event Action<IntPtr> RenderNodeCleanup;

		public unsafe static void SetVectorArray<T>(MaterialPropertyBlock props, int name, NativeSlice<T> vector4s) where T : struct
		{
			int count = vector4s.Length * vector4s.Stride / 16;
			SetVectorArray(props, name, new IntPtr(vector4s.GetUnsafePtr()), count);
		}

		[RequiredByNativeCode]
		internal static void RaiseGraphicsResourcesRecreate(bool recreate)
		{
			Utility.GraphicsResourcesRecreate?.Invoke(recreate);
		}

		[RequiredByNativeCode]
		internal static void RaiseEngineUpdate()
		{
			if (Utility.EngineUpdate != null)
			{
				Utility.EngineUpdate();
			}
		}

		[RequiredByNativeCode]
		internal static void RaiseFlushPendingResources()
		{
			Utility.FlushPendingResources?.Invoke();
		}

		[RequiredByNativeCode]
		internal static void RaiseRegisterIntermediateRenderers(Camera camera)
		{
			Utility.RegisterIntermediateRenderers?.Invoke(camera);
		}

		[RequiredByNativeCode]
		internal static void RaiseRenderNodeAdd(IntPtr userData)
		{
			Utility.RenderNodeAdd?.Invoke(userData);
		}

		[RequiredByNativeCode]
		internal static void RaiseRenderNodeExecute(IntPtr userData)
		{
			Utility.RenderNodeExecute?.Invoke(userData);
		}

		[RequiredByNativeCode]
		internal static void RaiseRenderNodeCleanup(IntPtr userData)
		{
			Utility.RenderNodeCleanup?.Invoke(userData);
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		private static extern IntPtr AllocateBuffer(int elementCount, int elementStride, bool vertexBuffer);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		private static extern void FreeBuffer(IntPtr buffer);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		private static extern void UpdateBufferRanges(IntPtr buffer, IntPtr ranges, int rangeCount, int writeRangeStart, int writeRangeEnd);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		private static extern void SetVectorArray(MaterialPropertyBlock props, int name, IntPtr vector4s, int count);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		public static extern IntPtr GetVertexDeclaration(VertexAttributeDescriptor[] vertexAttributes);

		public static void RegisterIntermediateRenderer(Camera camera, Material material, Matrix4x4 transform, Bounds aabb, int renderLayer, int shadowCasting, bool receiveShadows, int sameDistanceSortPriority, ulong sceneCullingMask, int rendererCallbackFlags, IntPtr userData, int userDataSize)
		{
			RegisterIntermediateRenderer_Injected(camera, material, ref transform, ref aabb, renderLayer, shadowCasting, receiveShadows, sameDistanceSortPriority, sceneCullingMask, rendererCallbackFlags, userData, userDataSize);
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		public unsafe static extern void DrawRanges(IntPtr ib, IntPtr* vertexStreams, int streamCount, IntPtr ranges, int rangeCount, IntPtr vertexDecl);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		public static extern void SetPropertyBlock(MaterialPropertyBlock props);

		[ThreadSafe]
		public static void SetScissorRect(RectInt scissorRect)
		{
			SetScissorRect_Injected(ref scissorRect);
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		public static extern void DisableScissor();

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		public static extern bool IsScissorEnabled();

		[ThreadSafe]
		public static IntPtr CreateStencilState(StencilState stencilState)
		{
			return CreateStencilState_Injected(ref stencilState);
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		public static extern void SetStencilState(IntPtr stencilState, int stencilRef);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		public static extern bool HasMappedBufferRange();

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		public static extern uint InsertCPUFence();

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		public static extern bool CPUFencePassed(uint fence);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		public static extern void WaitForCPUFencePassed(uint fence);

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		public static extern void SyncRenderThread();

		[ThreadSafe]
		public static RectInt GetActiveViewport()
		{
			GetActiveViewport_Injected(out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		public static extern void ProfileDrawChainBegin();

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		public static extern void ProfileDrawChainEnd();

		[MethodImpl(MethodImplOptions.InternalCall)]
		public static extern void NotifyOfUIREvents(bool subscribe);

		[ThreadSafe]
		public static Matrix4x4 GetUnityProjectionMatrix()
		{
			GetUnityProjectionMatrix_Injected(out var ret);
			return ret;
		}

		[ThreadSafe]
		public static Matrix4x4 GetDeviceProjectionMatrix()
		{
			GetDeviceProjectionMatrix_Injected(out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		[ThreadSafe]
		public static extern bool DebugIsMainThread();

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void RegisterIntermediateRenderer_Injected(Camera camera, Material material, ref Matrix4x4 transform, ref Bounds aabb, int renderLayer, int shadowCasting, bool receiveShadows, int sameDistanceSortPriority, ulong sceneCullingMask, int rendererCallbackFlags, IntPtr userData, int userDataSize);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void SetScissorRect_Injected(ref RectInt scissorRect);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern IntPtr CreateStencilState_Injected(ref StencilState stencilState);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void GetActiveViewport_Injected(out RectInt ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void GetUnityProjectionMatrix_Injected(out Matrix4x4 ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void GetDeviceProjectionMatrix_Injected(out Matrix4x4 ret);
	}
	[NativeHeader("ModuleOverrides/com.unity.ui/Core/Native/Renderer/UIRendererJobProcessor.h")]
	internal static class JobProcessor
	{
		internal static JobHandle ScheduleNudgeJobs(IntPtr buffer, int jobCount)
		{
			ScheduleNudgeJobs_Injected(buffer, jobCount, out var ret);
			return ret;
		}

		internal static JobHandle ScheduleConvertMeshJobs(IntPtr buffer, int jobCount)
		{
			ScheduleConvertMeshJobs_Injected(buffer, jobCount, out var ret);
			return ret;
		}

		internal static JobHandle ScheduleCopyClosingMeshJobs(IntPtr buffer, int jobCount)
		{
			ScheduleCopyClosingMeshJobs_Injected(buffer, jobCount, out var ret);
			return ret;
		}

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void ScheduleNudgeJobs_Injected(IntPtr buffer, int jobCount, out JobHandle ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void ScheduleConvertMeshJobs_Injected(IntPtr buffer, int jobCount, out JobHandle ret);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern void ScheduleCopyClosingMeshJobs_Injected(IntPtr buffer, int jobCount, out JobHandle ret);
	}
	internal class Allocator2D
	{
		public class Area
		{
			public RectInt rect;

			public BestFitAllocator allocator;

			public Area(RectInt rect)
			{
				this.rect = rect;
				allocator = new BestFitAllocator((uint)rect.height);
			}
		}

		public class Row : LinkedPoolItem<Row>
		{
			public RectInt rect;

			public Area area;

			public BestFitAllocator allocator;

			public Alloc alloc;

			public Row next;

			public static readonly LinkedPool<Row> pool = new LinkedPool<Row>(Create, Reset, 256);

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			private static Row Create()
			{
				return new Row();
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			private static void Reset(Row row)
			{
				row.rect = default(RectInt);
				row.area = null;
				row.allocator = null;
				row.alloc = default(Alloc);
				row.next = null;
			}
		}

		public struct Alloc2D
		{
			public RectInt rect;

			public Row row;

			public Alloc alloc;

			public Alloc2D(Row row, Alloc alloc, int width, int height)
			{
				this.alloc = alloc;
				this.row = row;
				rect = new RectInt(row.rect.xMin + (int)alloc.start, row.rect.yMin, width, height);
			}
		}

		private readonly Vector2Int m_MinSize;

		private readonly Vector2Int m_MaxSize;

		private readonly Vector2Int m_MaxAllocSize;

		private readonly int m_RowHeightBias;

		private readonly Row[] m_Rows;

		private readonly List<Area> m_Areas = new List<Area>();

		public Vector2Int minSize => m_MinSize;

		public Vector2Int maxSize => m_MaxSize;

		public Vector2Int maxAllocSize => m_MaxAllocSize;

		public Allocator2D(int minSize, int maxSize, int rowHeightBias)
			: this(new Vector2Int(minSize, minSize), new Vector2Int(maxSize, maxSize), rowHeightBias)
		{
		}

		public Allocator2D(Vector2Int minSize, Vector2Int maxSize, int rowHeightBias)
		{
			Debug.Assert(minSize.x > 0 && minSize.x <= maxSize.x && minSize.y > 0 && minSize.y <= maxSize.y);
			Debug.Assert(minSize.x == UIRUtility.GetNextPow2(minSize.x) && minSize.y == UIRUtility.GetNextPow2(minSize.y) && maxSize.x == UIRUtility.GetNextPow2(maxSize.x) && maxSize.y == UIRUtility.GetNextPow2(maxSize.y));
			Debug.Assert(rowHeightBias >= 0);
			m_MinSize = minSize;
			m_MaxSize = maxSize;
			m_RowHeightBias = rowHeightBias;
			BuildAreas(m_Areas, minSize, maxSize);
			m_MaxAllocSize = ComputeMaxAllocSize(m_Areas, rowHeightBias);
			m_Rows = BuildRowArray(m_MaxAllocSize.y, rowHeightBias);
		}

		public bool TryAllocate(int width, int height, out Alloc2D alloc2D)
		{
			if (width < 1 || width > m_MaxAllocSize.x || height < 1 || height > m_MaxAllocSize.y)
			{
				alloc2D = default(Alloc2D);
				return false;
			}
			int nextPow2Exp = UIRUtility.GetNextPow2Exp(Mathf.Max(height - m_RowHeightBias, 1));
			for (Row row = m_Rows[nextPow2Exp]; row != null; row = row.next)
			{
				if (row.rect.width >= width)
				{
					Alloc alloc = row.allocator.Allocate((uint)width);
					if (alloc.size != 0)
					{
						alloc2D = new Alloc2D(row, alloc, width, height);
						return true;
					}
				}
			}
			int num = (1 << nextPow2Exp) + m_RowHeightBias;
			Debug.Assert(num >= height);
			for (int i = 0; i < m_Areas.Count; i++)
			{
				Area area = m_Areas[i];
				if (area.rect.height >= num && area.rect.width >= width)
				{
					Alloc alloc2 = area.allocator.Allocate((uint)num);
					if (alloc2.size != 0)
					{
						Row row = Row.pool.Get();
						row.alloc = alloc2;
						row.allocator = new BestFitAllocator((uint)area.rect.width);
						row.area = area;
						row.next = m_Rows[nextPow2Exp];
						row.rect = new RectInt(area.rect.xMin, area.rect.yMin + (int)alloc2.start, area.rect.width, num);
						m_Rows[nextPow2Exp] = row;
						Alloc alloc3 = row.allocator.Allocate((uint)width);
						Debug.Assert(alloc3.size != 0);
						alloc2D = new Alloc2D(row, alloc3, width, height);
						return true;
					}
				}
			}
			alloc2D = default(Alloc2D);
			return false;
		}

		public void Free(Alloc2D alloc2D)
		{
			if (alloc2D.alloc.size == 0)
			{
				return;
			}
			Row row = alloc2D.row;
			row.allocator.Free(alloc2D.alloc);
			if (row.allocator.highWatermark != 0)
			{
				return;
			}
			row.area.allocator.Free(row.alloc);
			int nextPow2Exp = UIRUtility.GetNextPow2Exp(row.rect.height - m_RowHeightBias);
			Row row2 = m_Rows[nextPow2Exp];
			if (row2 == row)
			{
				m_Rows[nextPow2Exp] = row.next;
			}
			else
			{
				Row row3 = row2;
				while (row3.next != row)
				{
					row3 = row3.next;
				}
				row3.next = row.next;
			}
			Row.pool.Return(row);
		}

		private static void BuildAreas(List<Area> areas, Vector2Int minSize, Vector2Int maxSize)
		{
			int num = Mathf.Min(minSize.x, minSize.y);
			int num2 = num;
			areas.Add(new Area(new RectInt(0, 0, num, num2)));
			while (num < maxSize.x || num2 < maxSize.y)
			{
				if (num < maxSize.x)
				{
					areas.Add(new Area(new RectInt(num, 0, num, num2)));
					num *= 2;
				}
				if (num2 < maxSize.y)
				{
					areas.Add(new Area(new RectInt(0, num2, num, num2)));
					num2 *= 2;
				}
			}
		}

		private static Vector2Int ComputeMaxAllocSize(List<Area> areas, int rowHeightBias)
		{
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < areas.Count; i++)
			{
				Area area = areas[i];
				num = Mathf.Max(area.rect.width, num);
				num2 = Mathf.Max(area.rect.height, num2);
			}
			return new Vector2Int(num, UIRUtility.GetPrevPow2(num2 - rowHeightBias) + rowHeightBias);
		}

		private static Row[] BuildRowArray(int maxRowHeight, int rowHeightBias)
		{
			int num = UIRUtility.GetNextPow2Exp(maxRowHeight - rowHeightBias) + 1;
			return new Row[num];
		}
	}
	internal class DetachedAllocator : IDisposable
	{
		private TempAllocator<Vertex> m_VertsPool;

		private TempAllocator<ushort> m_IndexPool;

		private List<MeshWriteData> m_MeshWriteDataPool;

		private int m_MeshWriteDataCount;

		private bool m_Disposed;

		public List<MeshWriteData> meshes => m_MeshWriteDataPool.GetRange(0, m_MeshWriteDataCount);

		public DetachedAllocator()
		{
			m_MeshWriteDataPool = new List<MeshWriteData>(16);
			m_MeshWriteDataCount = 0;
			m_VertsPool = new TempAllocator<Vertex>(8192, 2048, 65536);
			m_IndexPool = new TempAllocator<ushort>(16384, 4096, 131072);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected void Dispose(bool disposing)
		{
			if (!m_Disposed)
			{
				if (disposing)
				{
					m_VertsPool.Dispose();
					m_IndexPool.Dispose();
				}
				m_Disposed = true;
			}
		}

		public MeshWriteData Alloc(int vertexCount, int indexCount)
		{
			MeshWriteData meshWriteData = null;
			if (m_MeshWriteDataCount < m_MeshWriteDataPool.Count)
			{
				meshWriteData = m_MeshWriteDataPool[m_MeshWriteDataCount];
			}
			else
			{
				meshWriteData = new MeshWriteData();
				m_MeshWriteDataPool.Add(meshWriteData);
			}
			m_MeshWriteDataCount++;
			if (vertexCount == 0 || indexCount == 0)
			{
				meshWriteData.Reset(default(NativeSlice<Vertex>), default(NativeSlice<ushort>));
				return meshWriteData;
			}
			meshWriteData.Reset(m_VertsPool.Alloc(vertexCount), m_IndexPool.Alloc(indexCount));
			return meshWriteData;
		}

		public void Clear()
		{
			m_VertsPool.Reset();
			m_IndexPool.Reset();
			m_MeshWriteDataCount = 0;
		}
	}
	internal struct Transform3x4
	{
		public Vector4 v0;

		public Vector4 v1;

		public Vector4 v2;
	}
	internal class MeshHandle : LinkedPoolItem<MeshHandle>
	{
		internal Alloc allocVerts;

		internal Alloc allocIndices;

		internal uint triangleCount;

		internal Page allocPage;

		internal uint allocTime;

		internal uint updateAllocID;
	}
	internal class UIRenderDevice : IDisposable
	{
		internal struct AllocToUpdate
		{
			public uint id;

			public uint allocTime;

			public MeshHandle meshHandle;

			public Alloc permAllocVerts;

			public Alloc permAllocIndices;

			public Page permPage;

			public bool copyBackIndices;
		}

		private struct AllocToFree
		{
			public Alloc alloc;

			public Page page;

			public bool vertices;
		}

		private struct DeviceToFree
		{
			public uint handle;

			public Page page;

			public void Dispose()
			{
				while (this.page != null)
				{
					Page page = this.page;
					this.page = this.page.next;
					page.Dispose();
				}
			}
		}

		private struct EvaluationState
		{
			public MaterialPropertyBlock stateMatProps;

			public Material defaultMat;

			public State curState;

			public Page curPage;

			public bool mustApplyMaterial;

			public bool mustApplyCommonBlock;

			public bool mustApplyStateBlock;

			public bool mustApplyStencil;
		}

		internal struct AllocationStatistics
		{
			public struct PageStatistics
			{
				internal HeapStatistics vertices;

				internal HeapStatistics indices;
			}

			public PageStatistics[] pages;

			public int[] freesDeferred;

			public bool completeInit;
		}

		internal struct DrawStatistics
		{
			public int currentFrameIndex;

			public uint totalIndices;

			public uint commandCount;

			public uint drawCommandCount;

			public uint materialSetCount;

			public uint drawRangeCount;

			public uint drawRangeCallCount;

			public uint immediateDraws;

			public uint stencilRefChanges;
		}

		internal const uint k_MaxQueuedFrameCount = 4u;

		internal const int k_PruneEmptyPageFrameCount = 60;

		private readonly bool m_MockDevice;

		private IntPtr m_DefaultStencilState;

		private IntPtr m_VertexDecl;

		private Page m_FirstPage;

		private uint m_NextPageVertexCount;

		private uint m_LargeMeshVertexCount;

		private float m_IndexToVertexCountRatio;

		private List<List<AllocToFree>> m_DeferredFrees;

		private List<List<AllocToUpdate>> m_Updates;

		private uint[] m_Fences;

		private MaterialPropertyBlock m_StandardMatProps;

		private uint m_FrameIndex;

		private uint m_NextUpdateID = 1u;

		private DrawStatistics m_DrawStats;

		private readonly LinkedPool<MeshHandle> m_MeshHandles = new LinkedPool<MeshHandle>(() => new MeshHandle(), delegate
		{
		});

		private readonly DrawParams m_DrawParams = new DrawParams();

		private readonly TextureSlotManager m_TextureSlotManager = new TextureSlotManager();

		private static LinkedList<DeviceToFree> m_DeviceFreeQueue;

		private static int m_ActiveDeviceCount;

		private static bool m_SubscribedToNotifications;

		private static bool m_SynchronousFree;

		private static readonly int s_GradientSettingsTexID;

		private static readonly int s_ShaderInfoTexID;

		private static readonly int s_TransformsPropID;

		private static readonly int s_ClipRectsPropID;

		private static ProfilerMarker s_MarkerAllocate;

		private static ProfilerMarker s_MarkerFree;

		private static ProfilerMarker s_MarkerAdvanceFrame;

		private static ProfilerMarker s_MarkerFence;

		private static ProfilerMarker s_MarkerBeforeDraw;

		private static bool? s_VertexTexturingIsAvailable;

		private const string k_VertexTexturingIsAvailableTag = "UIE_VertexTexturingIsAvailable";

		private const string k_VertexTexturingIsAvailableTrue = "1";

		private static bool? s_ShaderModelIs35;

		private const string k_ShaderModelIs35Tag = "UIE_ShaderModelIs35";

		private const string k_ShaderModelIs35True = "1";

		private static Texture2D s_DefaultShaderInfoTexFloat;

		private static Texture2D s_DefaultShaderInfoTexARGB8;

		internal uint maxVerticesPerPage { get; } = 65535u;

		internal bool breakBatches { get; set; }

		internal static Texture2D defaultShaderInfoTexFloat
		{
			get
			{
				if (s_DefaultShaderInfoTexFloat == null)
				{
					s_DefaultShaderInfoTexFloat = new Texture2D(64, 64, TextureFormat.RGBAFloat, mipChain: false);
					s_DefaultShaderInfoTexFloat.name = "DefaultShaderInfoTexFloat";
					s_DefaultShaderInfoTexFloat.hideFlags = HideFlags.HideAndDontSave;
					s_DefaultShaderInfoTexFloat.filterMode = FilterMode.Point;
					s_DefaultShaderInfoTexFloat.SetPixel(UIRVEShaderInfoAllocator.identityTransformTexel.x, UIRVEShaderInfoAllocator.identityTransformTexel.y, UIRVEShaderInfoAllocator.identityTransformRow0Value);
					s_DefaultShaderInfoTexFloat.SetPixel(UIRVEShaderInfoAllocator.identityTransformTexel.x, UIRVEShaderInfoAllocator.identityTransformTexel.y + 1, UIRVEShaderInfoAllocator.identityTransformRow1Value);
					s_DefaultShaderInfoTexFloat.SetPixel(UIRVEShaderInfoAllocator.identityTransformTexel.x, UIRVEShaderInfoAllocator.identityTransformTexel.y + 2, UIRVEShaderInfoAllocator.identityTransformRow2Value);
					s_DefaultShaderInfoTexFloat.SetPixel(UIRVEShaderInfoAllocator.infiniteClipRectTexel.x, UIRVEShaderInfoAllocator.infiniteClipRectTexel.y, UIRVEShaderInfoAllocator.infiniteClipRectValue);
					s_DefaultShaderInfoTexFloat.SetPixel(UIRVEShaderInfoAllocator.fullOpacityTexel.x, UIRVEShaderInfoAllocator.fullOpacityTexel.y, UIRVEShaderInfoAllocator.fullOpacityValue);
					s_DefaultShaderInfoTexFloat.SetPixel(UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.x, UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.y, Color.white);
					s_DefaultShaderInfoTexFloat.SetPixel(UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.x, UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.y + 1, Color.clear);
					s_DefaultShaderInfoTexFloat.SetPixel(UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.x, UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.y + 2, Color.clear);
					s_DefaultShaderInfoTexFloat.SetPixel(UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.x, UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.y + 3, Color.clear);
					s_DefaultShaderInfoTexFloat.Apply(updateMipmaps: false, makeNoLongerReadable: true);
				}
				return s_DefaultShaderInfoTexFloat;
			}
		}

		internal static Texture2D defaultShaderInfoTexARGB8
		{
			get
			{
				if (s_DefaultShaderInfoTexARGB8 == null)
				{
					s_DefaultShaderInfoTexARGB8 = new Texture2D(64, 64, TextureFormat.RGBA32, mipChain: false);
					s_DefaultShaderInfoTexARGB8.name = "DefaultShaderInfoTexARGB8";
					s_DefaultShaderInfoTexARGB8.hideFlags = HideFlags.HideAndDontSave;
					s_DefaultShaderInfoTexARGB8.filterMode = FilterMode.Point;
					s_DefaultShaderInfoTexARGB8.SetPixel(UIRVEShaderInfoAllocator.fullOpacityTexel.x, UIRVEShaderInfoAllocator.fullOpacityTexel.y, UIRVEShaderInfoAllocator.fullOpacityValue);
					s_DefaultShaderInfoTexARGB8.SetPixel(UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.x, UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.y, Color.white);
					s_DefaultShaderInfoTexARGB8.SetPixel(UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.x, UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.y + 1, Color.clear);
					s_DefaultShaderInfoTexARGB8.SetPixel(UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.x, UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.y + 2, Color.clear);
					s_DefaultShaderInfoTexARGB8.SetPixel(UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.x, UIRVEShaderInfoAllocator.defaultTextCoreSettingsTexel.y + 3, Color.clear);
					s_DefaultShaderInfoTexARGB8.Apply(updateMipmaps: false, makeNoLongerReadable: true);
				}
				return s_DefaultShaderInfoTexARGB8;
			}
		}

		internal static bool vertexTexturingIsAvailable
		{
			get
			{
				if (!s_VertexTexturingIsAvailable.HasValue)
				{
					Shader shader = Shader.Find(UIRUtility.k_DefaultShaderName);
					Material material = new Material(shader);
					material.hideFlags |= HideFlags.DontSaveInEditor;
					string tag = material.GetTag("UIE_VertexTexturingIsAvailable", searchFallbacks: false);
					UIRUtility.Destroy(material);
					s_VertexTexturingIsAvailable = tag == "1";
				}
				return s_VertexTexturingIsAvailable.Value;
			}
		}

		internal static bool shaderModelIs35
		{
			get
			{
				if (!s_ShaderModelIs35.HasValue)
				{
					Shader shader = Shader.Find(UIRUtility.k_DefaultShaderName);
					Material material = new Material(shader);
					material.hideFlags |= HideFlags.DontSaveInEditor;
					string tag = material.GetTag("UIE_ShaderModelIs35", searchFallbacks: false);
					UIRUtility.Destroy(material);
					s_ShaderModelIs35 = tag == "1";
				}
				return s_ShaderModelIs35.Value;
			}
		}

		private bool fullyCreated => m_Fences != null;

		protected bool disposed { get; private set; }

		static UIRenderDevice()
		{
			m_DeviceFreeQueue = new LinkedList<DeviceToFree>();
			m_ActiveDeviceCount = 0;
			s_GradientSettingsTexID = Shader.PropertyToID("_GradientSettingsTex");
			s_ShaderInfoTexID = Shader.PropertyToID("_ShaderInfoTex");
			s_TransformsPropID = Shader.PropertyToID("_Transforms");
			s_ClipRectsPropID = Shader.PropertyToID("_ClipRects");
			s_MarkerAllocate = new ProfilerMarker("UIR.Allocate");
			s_MarkerFree = new ProfilerMarker("UIR.Free");
			s_MarkerAdvanceFrame = new ProfilerMarker("UIR.AdvanceFrame");
			s_MarkerFence = new ProfilerMarker("UIR.WaitOnFence");
			s_MarkerBeforeDraw = new ProfilerMarker("UIR.BeforeDraw");
			Utility.EngineUpdate += OnEngineUpdateGlobal;
			Utility.FlushPendingResources += OnFlushPendingResources;
		}

		public UIRenderDevice(uint initialVertexCapacity = 0u, uint initialIndexCapacity = 0u)
			: this(initialVertexCapacity, initialIndexCapacity, mockDevice: false)
		{
		}

		protected UIRenderDevice(uint initialVertexCapacity, uint initialIndexCapacity, bool mockDevice)
		{
			m_MockDevice = mockDevice;
			Debug.Assert(!m_SynchronousFree);
			Debug.Assert(condition: true);
			if (m_ActiveDeviceCount++ == 0 && !m_SubscribedToNotifications && !m_MockDevice)
			{
				Utility.NotifyOfUIREvents(subscribe: true);
				m_SubscribedToNotifications = true;
			}
			m_NextPageVertexCount = Math.Max(initialVertexCapacity, 2048u);
			m_LargeMeshVertexCount = m_NextPageVertexCount;
			m_IndexToVertexCountRatio = (float)initialIndexCapacity / (float)initialVertexCapacity;
			m_IndexToVertexCountRatio = Mathf.Max(m_IndexToVertexCountRatio, 2f);
			m_DeferredFrees = new List<List<AllocToFree>>(4);
			m_Updates = new List<List<AllocToUpdate>>(4);
			for (int num = 0; (long)num < 4L; num++)
			{
				m_DeferredFrees.Add(new List<AllocToFree>());
				m_Updates.Add(new List<AllocToUpdate>());
			}
		}

		private void InitVertexDeclaration()
		{
			VertexAttributeDescriptor[] vertexAttributes = new VertexAttributeDescriptor[10]
			{
				new VertexAttributeDescriptor(VertexAttribute.Position, VertexAttributeFormat.Float32, 3, 0),
				new VertexAttributeDescriptor(VertexAttribute.Color, VertexAttributeFormat.UNorm8, 4),
				new VertexAttributeDescriptor(VertexAttribute.TexCoord0, VertexAttributeFormat.Float32, 2),
				new VertexAttributeDescriptor(VertexAttribute.TexCoord1, VertexAttributeFormat.UNorm8, 4),
				new VertexAttributeDescriptor(VertexAttribute.TexCoord2, VertexAttributeFormat.UNorm8, 4),
				new VertexAttributeDescriptor(VertexAttribute.TexCoord3, VertexAttributeFormat.UNorm8, 4),
				new VertexAttributeDescriptor(VertexAttribute.TexCoord4, VertexAttributeFormat.UNorm8, 4),
				new VertexAttributeDescriptor(VertexAttribute.TexCoord5, VertexAttributeFormat.UNorm8, 4),
				new VertexAttributeDescriptor(VertexAttribute.TexCoord6, VertexAttributeFormat.Float32, 4),
				new VertexAttributeDescriptor(VertexAttribute.TexCoord7, VertexAttributeFormat.Float32, 1)
			};
			m_VertexDecl = Utility.GetVertexDeclaration(vertexAttributes);
		}

		private void CompleteCreation()
		{
			if (!m_MockDevice && !fullyCreated)
			{
				InitVertexDeclaration();
				m_Fences = new uint[4];
				m_StandardMatProps = new MaterialPropertyBlock();
				m_DefaultStencilState = Utility.CreateStencilState(new StencilState
				{
					enabled = true,
					readMask = byte.MaxValue,
					writeMask = byte.MaxValue,
					compareFunctionFront = CompareFunction.Equal,
					passOperationFront = StencilOp.Keep,
					failOperationFront = StencilOp.Keep,
					zFailOperationFront = StencilOp.IncrementSaturate,
					compareFunctionBack = CompareFunction.Less,
					passOperationBack = StencilOp.Keep,
					failOperationBack = StencilOp.Keep,
					zFailOperationBack = StencilOp.DecrementSaturate
				});
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		internal void DisposeImmediate()
		{
			Debug.Assert(!m_SynchronousFree);
			m_SynchronousFree = true;
			Dispose();
			m_SynchronousFree = false;
		}

		protected virtual void Dispose(bool disposing)
		{
			if (disposed)
			{
				return;
			}
			m_ActiveDeviceCount--;
			if (disposing)
			{
				DeviceToFree value = new DeviceToFree
				{
					handle = ((!m_MockDevice) ? Utility.InsertCPUFence() : 0u),
					page = m_FirstPage
				};
				if (value.handle == 0)
				{
					value.Dispose();
				}
				else
				{
					m_DeviceFreeQueue.AddLast(value);
					if (m_SynchronousFree)
					{
						ProcessDeviceFreeQueue();
					}
				}
			}
			disposed = true;
		}

		public MeshHandle Allocate(uint vertexCount, uint indexCount, out NativeSlice<Vertex> vertexData, out NativeSlice<ushort> indexData, out ushort indexOffset)
		{
			MeshHandle meshHandle = m_MeshHandles.Get();
			meshHandle.triangleCount = indexCount / 3;
			Allocate(meshHandle, vertexCount, indexCount, out vertexData, out indexData, shortLived: false);
			indexOffset = (ushort)meshHandle.allocVerts.start;
			return meshHandle;
		}

		public void Update(MeshHandle mesh, uint vertexCount, out NativeSlice<Vertex> vertexData)
		{
			Debug.Assert(mesh.allocVerts.size >= vertexCount);
			if (mesh.allocTime == m_FrameIndex)
			{
				vertexData = mesh.allocPage.vertices.cpuData.Slice((int)mesh.allocVerts.start, (int)vertexCount);
				return;
			}
			uint start = mesh.allocVerts.start;
			NativeSlice<ushort> nativeSlice = new NativeSlice<ushort>(mesh.allocPage.indices.cpuData, (int)mesh.allocIndices.start, (int)mesh.allocIndices.size);
			UpdateAfterGPUUsedData(mesh, vertexCount, mesh.allocIndices.size, out vertexData, out var indexData, out var indexOffset, out var _, copyBackIndices: false);
			int size = (int)mesh.allocIndices.size;
			int num = (int)(indexOffset - start);
			for (int i = 0; i < size; i++)
			{
				indexData[i] = (ushort)(nativeSlice[i] + num);
			}
		}

		public void Update(MeshHandle mesh, uint vertexCount, uint indexCount, out NativeSlice<Vertex> vertexData, out NativeSlice<ushort> indexData, out ushort indexOffset)
		{
			Debug.Assert(mesh.allocVerts.size >= vertexCount);
			Debug.Assert(mesh.allocIndices.size >= indexCount);
			if (mesh.allocTime == m_FrameIndex)
			{
				vertexData = mesh.allocPage.vertices.cpuData.Slice((int)mesh.allocVerts.start, (int)vertexCount);
				indexData = mesh.allocPage.indices.cpuData.Slice((int)mesh.allocIndices.start, (int)indexCount);
				indexOffset = (ushort)mesh.allocVerts.start;
				UpdateCopyBackIndices(mesh, copyBackIndices: true);
			}
			else
			{
				UpdateAfterGPUUsedData(mesh, vertexCount, indexCount, out vertexData, out indexData, out indexOffset, out var _, copyBackIndices: true);
			}
		}

		private void UpdateCopyBackIndices(MeshHandle mesh, bool copyBackIndices)
		{
			if (mesh.updateAllocID != 0)
			{
				int index = (int)(mesh.updateAllocID - 1);
				List<AllocToUpdate> list = ActiveUpdatesForMeshHandle(mesh);
				AllocToUpdate value = list[index];
				value.copyBackIndices = true;
				list[index] = value;
			}
		}

		internal List<AllocToUpdate> ActiveUpdatesForMeshHandle(MeshHandle mesh)
		{
			return m_Updates[(int)mesh.allocTime % m_Updates.Count];
		}

		private bool TryAllocFromPage(Page page, uint vertexCount, uint indexCount, ref Alloc va, ref Alloc ia, bool shortLived)
		{
			va = page.vertices.allocator.Allocate(vertexCount, shortLived);
			if (va.size != 0)
			{
				ia = page.indices.allocator.Allocate(indexCount, shortLived);
				if (ia.size != 0)
				{
					return true;
				}
				page.vertices.allocator.Free(va);
				va.size = 0u;
			}
			return false;
		}

		private void Allocate(MeshHandle meshHandle, uint vertexCount, uint indexCount, out NativeSlice<Vertex> vertexData, out NativeSlice<ushort> indexData, bool shortLived)
		{
			Page page = null;
			Alloc va = default(Alloc);
			Alloc ia = default(Alloc);
			if (vertexCount <= m_LargeMeshVertexCount)
			{
				if (m_FirstPage != null)
				{
					page = m_FirstPage;
					while (!TryAllocFromPage(page, vertexCount, indexCount, ref va, ref ia, shortLived) && page.next != null)
					{
						page = page.next;
					}
				}
				else
				{
					CompleteCreation();
				}
				if (ia.size == 0)
				{
					m_NextPageVertexCount <<= 1;
					m_NextPageVertexCount = Math.Max(m_NextPageVertexCount, vertexCount * 2);
					m_NextPageVertexCount = Math.Min(m_NextPageVertexCount, maxVerticesPerPage);
					uint val = (uint)((float)m_NextPageVertexCount * m_IndexToVertexCountRatio + 0.5f);
					val = Math.Max(val, indexCount * 2);
					Debug.Assert(page?.next == null);
					page = new Page(m_NextPageVertexCount, val, 4u, m_MockDevice);
					page.next = m_FirstPage;
					m_FirstPage = page;
					va = page.vertices.allocator.Allocate(vertexCount, shortLived);
					ia = page.indices.allocator.Allocate(indexCount, shortLived);
					Debug.Assert(va.size != 0);
					Debug.Assert(ia.size != 0);
				}
			}
			else
			{
				CompleteCreation();
				Page page2 = m_FirstPage;
				Page page3 = m_FirstPage;
				int num = int.MaxValue;
				while (page2 != null)
				{
					int num2 = page2.vertices.cpuData.Length - (int)vertexCount;
					int num3 = page2.indices.cpuData.Length - (int)indexCount;
					if (page2.isEmpty && num2 >= 0 && num3 >= 0 && num2 < num)
					{
						page = page2;
						num = num2;
					}
					page3 = page2;
					page2 = page2.next;
				}
				if (page == null)
				{
					uint vertexMaxCount = ((vertexCount > maxVerticesPerPage) ? 2u : vertexCount);
					Debug.Assert(vertexCount <= maxVerticesPerPage, "Requested Vertex count is above the limit. Alloc will fail.");
					page = new Page(vertexMaxCount, indexCount, 4u, m_MockDevice);
					if (page3 != null)
					{
						page3.next = page;
					}
					else
					{
						m_FirstPage = page;
					}
				}
				va = page.vertices.allocator.Allocate(vertexCount, shortLived);
				ia = page.indices.allocator.Allocate(indexCount, shortLived);
			}
			Debug.Assert(va.size == vertexCount, "Vertices allocated != Vertices requested");
			Debug.Assert(ia.size == indexCount, "Indices allocated != Indices requested");
			if (va.size != vertexCount || ia.size != indexCount)
			{
				if (va.handle != null)
				{
					page.vertices.allocator.Free(va);
				}
				if (ia.handle != null)
				{
					page.vertices.allocator.Free(ia);
				}
				ia = default(Alloc);
				va = default(Alloc);
			}
			page.vertices.RegisterUpdate(va.start, va.size);
			page.indices.RegisterUpdate(ia.start, ia.size);
			vertexData = new NativeSlice<Vertex>(page.vertices.cpuData, (int)va.start, (int)va.size);
			indexData = new NativeSlice<ushort>(page.indices.cpuData, (int)ia.start, (int)ia.size);
			meshHandle.allocPage = page;
			meshHandle.allocVerts = va;
			meshHandle.allocIndices = ia;
			meshHandle.allocTime = m_FrameIndex;
		}

		private void UpdateAfterGPUUsedData(MeshHandle mesh, uint vertexCount, uint indexCount, out NativeSlice<Vertex> vertexData, out NativeSlice<ushort> indexData, out ushort indexOffset, out AllocToUpdate allocToUpdate, bool copyBackIndices)
		{
			allocToUpdate = new AllocToUpdate
			{
				id = m_NextUpdateID++,
				allocTime = m_FrameIndex,
				meshHandle = mesh,
				copyBackIndices = copyBackIndices
			};
			Debug.Assert(m_NextUpdateID != 0);
			if (mesh.updateAllocID == 0)
			{
				allocToUpdate.permAllocVerts = mesh.allocVerts;
				allocToUpdate.permAllocIndices = mesh.allocIndices;
				allocToUpdate.permPage = mesh.allocPage;
			}
			else
			{
				int index = (int)(mesh.updateAllocID - 1);
				List<AllocToUpdate> list = m_Updates[(int)mesh.allocTime % m_Updates.Count];
				AllocToUpdate value = list[index];
				Debug.Assert(value.id == mesh.updateAllocID);
				allocToUpdate.copyBackIndices |= value.copyBackIndices;
				allocToUpdate.permAllocVerts = value.permAllocVerts;
				allocToUpdate.permAllocIndices = value.permAllocIndices;
				allocToUpdate.permPage = value.permPage;
				value.allocTime = uint.MaxValue;
				list[index] = value;
				List<AllocToFree> list2 = m_DeferredFrees[(int)(m_FrameIndex % (uint)m_DeferredFrees.Count)];
				list2.Add(new AllocToFree
				{
					alloc = mesh.allocVerts,
					page = mesh.allocPage,
					vertices = true
				});
				list2.Add(new AllocToFree
				{
					alloc = mesh.allocIndices,
					page = mesh.allocPage,
					vertices = false
				});
			}
			if (TryAllocFromPage(mesh.allocPage, vertexCount, indexCount, ref mesh.allocVerts, ref mesh.allocIndices, shortLived: true))
			{
				mesh.allocPage.vertices.RegisterUpdate(mesh.allocVerts.start, mesh.allocVerts.size);
				mesh.allocPage.indices.RegisterUpdate(mesh.allocIndices.start, mesh.allocIndices.size);
			}
			else
			{
				Allocate(mesh, vertexCount, indexCount, out vertexData, out indexData, shortLived: true);
			}
			mesh.triangleCount = indexCount / 3;
			mesh.updateAllocID = allocToUpdate.id;
			mesh.allocTime = allocToUpdate.allocTime;
			m_Updates[(int)(m_FrameIndex % m_Updates.Count)].Add(allocToUpdate);
			vertexData = new NativeSlice<Vertex>(mesh.allocPage.vertices.cpuData, (int)mesh.allocVerts.start, (int)vertexCount);
			indexData = new NativeSlice<ushort>(mesh.allocPage.indices.cpuData, (int)mesh.allocIndices.start, (int)indexCount);
			indexOffset = (ushort)mesh.allocVerts.start;
		}

		public void Free(MeshHandle mesh)
		{
			if (mesh.updateAllocID != 0)
			{
				int index = (int)(mesh.updateAllocID - 1);
				List<AllocToUpdate> list = m_Updates[(int)mesh.allocTime % m_Updates.Count];
				AllocToUpdate value = list[index];
				Debug.Assert(value.id == mesh.updateAllocID);
				List<AllocToFree> list2 = m_DeferredFrees[(int)(m_FrameIndex % (uint)m_DeferredFrees.Count)];
				list2.Add(new AllocToFree
				{
					alloc = value.permAllocVerts,
					page = value.permPage,
					vertices = true
				});
				list2.Add(new AllocToFree
				{
					alloc = value.permAllocIndices,
					page = value.permPage,
					vertices = false
				});
				list2.Add(new AllocToFree
				{
					alloc = mesh.allocVerts,
					page = mesh.allocPage,
					vertices = true
				});
				list2.Add(new AllocToFree
				{
					alloc = mesh.allocIndices,
					page = mesh.allocPage,
					vertices = false
				});
				value.allocTime = uint.MaxValue;
				list[index] = value;
			}
			else if (mesh.allocTime != m_FrameIndex)
			{
				int index2 = (int)(m_FrameIndex % (uint)m_DeferredFrees.Count);
				m_DeferredFrees[index2].Add(new AllocToFree
				{
					alloc = mesh.allocVerts,
					page = mesh.allocPage,
					vertices = true
				});
				m_DeferredFrees[index2].Add(new AllocToFree
				{
					alloc = mesh.allocIndices,
					page = mesh.allocPage,
					vertices = false
				});
			}
			else
			{
				mesh.allocPage.vertices.allocator.Free(mesh.allocVerts);
				mesh.allocPage.indices.allocator.Free(mesh.allocIndices);
			}
			mesh.allocVerts = default(Alloc);
			mesh.allocIndices = default(Alloc);
			mesh.allocPage = null;
			mesh.updateAllocID = 0u;
			m_MeshHandles.Return(mesh);
		}

		public void OnFrameRenderingBegin()
		{
			AdvanceFrame();
			m_DrawStats = default(DrawStatistics);
			m_DrawStats.currentFrameIndex = (int)m_FrameIndex;
			for (Page page = m_FirstPage; page != null; page = page.next)
			{
				page.vertices.SendUpdates();
				page.indices.SendUpdates();
			}
		}

		internal unsafe static NativeSlice<T> PtrToSlice<T>(void* p, int count) where T : struct
		{
			return NativeSliceUnsafeUtility.ConvertExistingDataToNativeSlice<T>(p, UnsafeUtility.SizeOf<T>(), count);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void ApplyDrawCommandState(RenderChainCommand cmd, int textureSlot, Material newMat, bool newMatDiffers, ref EvaluationState st)
		{
			if (newMatDiffers)
			{
				st.curState.material = newMat;
				st.mustApplyMaterial = true;
			}
			st.curPage = cmd.mesh.allocPage;
			if (cmd.state.texture != TextureId.invalid)
			{
				if (textureSlot < 0)
				{
					textureSlot = m_TextureSlotManager.FindOldestSlot();
					m_TextureSlotManager.Bind(cmd.state.texture, cmd.state.sdfScale, textureSlot, st.stateMatProps);
					st.mustApplyStateBlock = true;
				}
				else
				{
					m_TextureSlotManager.MarkUsed(textureSlot);
				}
			}
			if (cmd.state.stencilRef != st.curState.stencilRef)
			{
				st.curState.stencilRef = cmd.state.stencilRef;
				st.mustApplyStencil = true;
			}
		}

		private void ApplyBatchState(ref EvaluationState st, bool allowMaterialChange)
		{
			if (!m_MockDevice)
			{
				if (st.mustApplyMaterial)
				{
					if (!allowMaterialChange)
					{
						Debug.LogError("Attempted to change material when it is not allowed to do so.");
						return;
					}
					m_DrawStats.materialSetCount++;
					st.curState.material.SetPass(0);
					if (m_StandardMatProps != null)
					{
						Utility.SetPropertyBlock(m_StandardMatProps);
					}
					st.mustApplyCommonBlock = true;
					st.mustApplyStateBlock = true;
					st.mustApplyStencil = true;
				}
				if (st.mustApplyStateBlock)
				{
					Utility.SetPropertyBlock(st.stateMatProps);
				}
				if (st.mustApplyStencil)
				{
					m_DrawStats.stencilRefChanges++;
					Utility.SetStencilState(m_DefaultStencilState, st.curState.stencilRef);
				}
			}
			st.mustApplyMaterial = false;
			st.mustApplyCommonBlock = false;
			st.mustApplyStateBlock = false;
			st.mustApplyStencil = false;
			m_TextureSlotManager.StartNewBatch();
		}

		public unsafe void EvaluateChain(RenderChainCommand head, Material initialMat, Material defaultMat, Texture gradientSettings, Texture shaderInfo, float pixelsPerPoint, NativeSlice<Transform3x4> transforms, NativeSlice<Vector4> clipRects, MaterialPropertyBlock stateMatProps, bool allowMaterialChange, ref Exception immediateException)
		{
			Utility.ProfileDrawChainBegin();
			bool flag = breakBatches;
			DrawParams drawParams = m_DrawParams;
			drawParams.Reset();
			drawParams.renderTexture.Add(RenderTexture.active);
			stateMatProps.Clear();
			m_TextureSlotManager.Reset();
			if (fullyCreated)
			{
				if (gradientSettings != null)
				{
					m_StandardMatProps.SetTexture(s_GradientSettingsTexID, gradientSettings);
				}
				if (shaderInfo != null)
				{
					m_StandardMatProps.SetTexture(s_ShaderInfoTexID, shaderInfo);
				}
				if (transforms.Length > 0)
				{
					Utility.SetVectorArray(m_StandardMatProps, s_TransformsPropID, transforms);
				}
				if (clipRects.Length > 0)
				{
					Utility.SetVectorArray(m_StandardMatProps, s_ClipRectsPropID, clipRects);
				}
				Utility.SetPropertyBlock(m_StandardMatProps);
			}
			int num = 1024;
			DrawBufferRange* ptr = stackalloc DrawBufferRange[num];
			int num2 = num - 1;
			int rangesStart = 0;
			int rangesReady = 0;
			DrawBufferRange drawBufferRange = default(DrawBufferRange);
			int num3 = -1;
			EvaluationState st = new EvaluationState
			{
				stateMatProps = stateMatProps,
				defaultMat = defaultMat,
				curState = new State
				{
					material = initialMat
				},
				mustApplyCommonBlock = true,
				mustApplyStateBlock = true,
				mustApplyStencil = true
			};
			while (head != null)
			{
				m_DrawStats.commandCount++;
				m_DrawStats.drawCommandCount += ((head.type == CommandType.Draw) ? 1u : 0u);
				bool flag2 = drawBufferRange.indexCount > 0 && rangesReady == num - 1;
				bool flag3 = false;
				bool flag4 = false;
				bool flag5 = false;
				int num4 = -1;
				Material material = null;
				bool newMatDiffers = false;
				if (head.type == CommandType.Draw)
				{
					material = ((head.state.material != null) ? head.state.material : defaultMat);
					if (material != st.curState.material)
					{
						flag5 = true;
						newMatDiffers = true;
						flag3 = true;
						flag4 = true;
					}
					if (head.mesh.allocPage != st.curPage)
					{
						flag5 = true;
						flag3 = true;
						flag4 = true;
					}
					else if (num3 != head.mesh.allocIndices.start + head.indexOffset)
					{
						flag3 = true;
					}
					if (head.state.texture != TextureId.invalid)
					{
						flag5 = true;
						num4 = m_TextureSlotManager.IndexOf(head.state.texture);
						if (num4 < 0 && m_TextureSlotManager.FreeSlots < 1)
						{
							flag3 = true;
							flag4 = true;
						}
					}
					if (head.state.stencilRef != st.curState.stencilRef)
					{
						flag5 = true;
						flag3 = true;
						flag4 = true;
					}
					if (flag3 && flag2)
					{
						flag4 = true;
					}
				}
				else
				{
					flag3 = true;
					flag4 = true;
				}
				if (flag)
				{
					flag3 = true;
					flag4 = true;
				}
				if (flag3)
				{
					if (drawBufferRange.indexCount > 0)
					{
						int num5 = (rangesStart + rangesReady++) & num2;
						ptr[num5] = drawBufferRange;
						Debug.Assert(rangesReady < num || flag4);
						drawBufferRange = default(DrawBufferRange);
						m_DrawStats.drawRangeCount++;
					}
					if (head.type == CommandType.Draw)
					{
						drawBufferRange.firstIndex = (int)head.mesh.allocIndices.start + head.indexOffset;
						drawBufferRange.indexCount = head.indexCount;
						drawBufferRange.vertsReferenced = (int)head.mesh.allocVerts.size;
						drawBufferRange.minIndexVal = (int)head.mesh.allocVerts.start;
						num3 = drawBufferRange.firstIndex + head.indexCount;
						m_DrawStats.totalIndices += (uint)head.indexCount;
					}
					if (flag4)
					{
						if (rangesReady > 0)
						{
							ApplyBatchState(ref st, allowMaterialChange);
							KickRanges(ptr, ref rangesReady, ref rangesStart, num, st.curPage);
						}
						if (head.type != CommandType.Draw)
						{
							if (!m_MockDevice)
							{
								head.ExecuteNonDrawMesh(drawParams, pixelsPerPoint, ref immediateException);
							}
							if (head.type == CommandType.Immediate || head.type == CommandType.ImmediateCull || head.type == CommandType.BlitToPreviousRT || head.type == CommandType.PushRenderTexture || head.type == CommandType.PopDefaultMaterial || head.type == CommandType.PushDefaultMaterial)
							{
								st.curState.material = null;
								st.mustApplyMaterial = false;
								m_DrawStats.immediateDraws++;
								if (head.type == CommandType.PopDefaultMaterial)
								{
									int index = drawParams.defaultMaterial.Count - 1;
									defaultMat = drawParams.defaultMaterial[index];
									drawParams.defaultMaterial.RemoveAt(index);
								}
								if (head.type == CommandType.PushDefaultMaterial)
								{
									drawParams.defaultMaterial.Add(defaultMat);
									defaultMat = head.state.material;
								}
							}
						}
					}
					if (head.type == CommandType.Draw && flag5)
					{
						ApplyDrawCommandState(head, num4, material, newMatDiffers, ref st);
					}
					head = head.next;
				}
				else
				{
					if (drawBufferRange.indexCount == 0)
					{
						num3 = (drawBufferRange.firstIndex = (int)head.mesh.allocIndices.start + head.indexOffset);
					}
					drawBufferRange.indexCount += head.indexCount;
					int minIndexVal = drawBufferRange.minIndexVal;
					int start = (int)head.mesh.allocVerts.start;
					int a = drawBufferRange.minIndexVal + drawBufferRange.vertsReferenced;
					int b = (int)(head.mesh.allocVerts.start + head.mesh.allocVerts.size);
					drawBufferRange.minIndexVal = Mathf.Min(minIndexVal, start);
					drawBufferRange.vertsReferenced = Mathf.Max(a, b) - drawBufferRange.minIndexVal;
					num3 += head.indexCount;
					m_DrawStats.totalIndices += (uint)head.indexCount;
					if (flag5)
					{
						ApplyDrawCommandState(head, num4, material, newMatDiffers, ref st);
					}
					head = head.next;
				}
			}
			if (drawBufferRange.indexCount > 0)
			{
				int num6 = (rangesStart + rangesReady++) & num2;
				ptr[num6] = drawBufferRange;
			}
			if (rangesReady > 0)
			{
				ApplyBatchState(ref st, allowMaterialChange);
				KickRanges(ptr, ref rangesReady, ref rangesStart, num, st.curPage);
			}
			UpdateFenceValue();
			Utility.ProfileDrawChainEnd();
		}

		private unsafe void UpdateFenceValue()
		{
			if (m_Fences == null)
			{
				return;
			}
			uint num = Utility.InsertCPUFence();
			fixed (uint* ptr = &m_Fences[(int)(m_FrameIndex % m_Fences.Length)])
			{
				uint num2;
				int num3;
				do
				{
					num2 = *ptr;
					if ((int)(num - num2) <= 0)
					{
						break;
					}
					num3 = Interlocked.CompareExchange(ref *(int*)ptr, (int)num, (int)num2);
				}
				while (num3 != num2);
			}
		}

		private unsafe void KickRanges(DrawBufferRange* ranges, ref int rangesReady, ref int rangesStart, int rangesCount, Page curPage)
		{
			Debug.Assert(rangesReady > 0);
			if (rangesStart + rangesReady <= rangesCount)
			{
				if (!m_MockDevice)
				{
					DrawRanges(curPage.indices.gpuData, curPage.vertices.gpuData, PtrToSlice<DrawBufferRange>(ranges + rangesStart, rangesReady));
				}
				m_DrawStats.drawRangeCallCount++;
			}
			else
			{
				int num = rangesCount - rangesStart;
				int count = rangesReady - num;
				if (!m_MockDevice)
				{
					DrawRanges(curPage.indices.gpuData, curPage.vertices.gpuData, PtrToSlice<DrawBufferRange>(ranges + rangesStart, num));
					DrawRanges(curPage.indices.gpuData, curPage.vertices.gpuData, PtrToSlice<DrawBufferRange>(ranges, count));
				}
				m_DrawStats.drawRangeCallCount += 2u;
			}
			rangesStart = (rangesStart + rangesReady) & (rangesCount - 1);
			rangesReady = 0;
		}

		private unsafe void DrawRanges<I, T>(Utility.GPUBuffer<I> ib, Utility.GPUBuffer<T> vb, NativeSlice<DrawBufferRange> ranges) where I : struct where T : struct
		{
			IntPtr* ptr = stackalloc IntPtr[1];
			*ptr = vb.BufferPointer;
			Utility.DrawRanges(ib.BufferPointer, ptr, 1, new IntPtr(ranges.GetUnsafePtr()), ranges.Length, m_VertexDecl);
		}

		internal void WaitOnAllCpuFences()
		{
			for (int i = 0; i < m_Fences.Length; i++)
			{
				WaitOnCpuFence(m_Fences[i]);
			}
		}

		private void WaitOnCpuFence(uint fence)
		{
			if (fence != 0 && !Utility.CPUFencePassed(fence))
			{
				Utility.WaitForCPUFencePassed(fence);
			}
		}

		public void AdvanceFrame()
		{
			m_FrameIndex++;
			m_DrawStats.currentFrameIndex = (int)m_FrameIndex;
			if (m_Fences != null)
			{
				int num = (int)(m_FrameIndex % m_Fences.Length);
				uint fence = m_Fences[num];
				WaitOnCpuFence(fence);
				m_Fences[num] = 0u;
			}
			m_NextUpdateID = 1u;
			List<AllocToFree> list = m_DeferredFrees[(int)(m_FrameIndex % (uint)m_DeferredFrees.Count)];
			foreach (AllocToFree item in list)
			{
				if (item.vertices)
				{
					item.page.vertices.allocator.Free(item.alloc);
				}
				else
				{
					item.page.indices.allocator.Free(item.alloc);
				}
			}
			list.Clear();
			List<AllocToUpdate> list2 = m_Updates[(int)(m_FrameIndex % (uint)m_DeferredFrees.Count)];
			foreach (AllocToUpdate item2 in list2)
			{
				if (item2.meshHandle.updateAllocID != item2.id || item2.meshHandle.allocTime != item2.allocTime)
				{
					continue;
				}
				NativeSlice<Vertex> slice = new NativeSlice<Vertex>(item2.meshHandle.allocPage.vertices.cpuData, (int)item2.meshHandle.allocVerts.start, (int)item2.meshHandle.allocVerts.size);
				new NativeSlice<Vertex>(item2.permPage.vertices.cpuData, (int)item2.permAllocVerts.start, (int)item2.meshHandle.allocVerts.size).CopyFrom(slice);
				item2.permPage.vertices.RegisterUpdate(item2.permAllocVerts.start, item2.meshHandle.allocVerts.size);
				if (item2.copyBackIndices)
				{
					NativeSlice<ushort> nativeSlice = new NativeSlice<ushort>(item2.meshHandle.allocPage.indices.cpuData, (int)item2.meshHandle.allocIndices.start, (int)item2.meshHandle.allocIndices.size);
					NativeSlice<ushort> nativeSlice2 = new NativeSlice<ushort>(item2.permPage.indices.cpuData, (int)item2.permAllocIndices.start, (int)item2.meshHandle.allocIndices.size);
					int length = nativeSlice2.Length;
					int num2 = (int)(item2.permAllocVerts.start - item2.meshHandle.allocVerts.start);
					for (int i = 0; i < length; i++)
					{
						nativeSlice2[i] = (ushort)(nativeSlice[i] + num2);
					}
					item2.permPage.indices.RegisterUpdate(item2.permAllocIndices.start, item2.meshHandle.allocIndices.size);
				}
				list.Add(new AllocToFree
				{
					alloc = item2.meshHandle.allocVerts,
					page = item2.meshHandle.allocPage,
					vertices = true
				});
				list.Add(new AllocToFree
				{
					alloc = item2.meshHandle.allocIndices,
					page = item2.meshHandle.allocPage,
					vertices = false
				});
				item2.meshHandle.allocVerts = item2.permAllocVerts;
				item2.meshHandle.allocIndices = item2.permAllocIndices;
				item2.meshHandle.allocPage = item2.permPage;
				item2.meshHandle.updateAllocID = 0u;
			}
			list2.Clear();
			PruneUnusedPages();
		}

		private void PruneUnusedPages()
		{
			Page page2;
			Page page3;
			Page page4;
			Page page = (page2 = (page3 = (page4 = null)));
			Page page5 = m_FirstPage;
			while (page5 != null)
			{
				if (!page5.isEmpty)
				{
					page5.framesEmpty = 0;
				}
				else
				{
					page5.framesEmpty++;
				}
				if (page5.framesEmpty < 60)
				{
					if (page != null)
					{
						page2.next = page5;
					}
					else
					{
						page = page5;
					}
					page2 = page5;
				}
				else
				{
					if (page3 != null)
					{
						page4.next = page5;
					}
					else
					{
						page3 = page5;
					}
					page4 = page5;
				}
				Page next = page5.next;
				page5.next = null;
				page5 = next;
			}
			m_FirstPage = page;
			page5 = page3;
			while (page5 != null)
			{
				Page next2 = page5.next;
				page5.next = null;
				page5.Dispose();
				page5 = next2;
			}
		}

		internal static void PrepareForGfxDeviceRecreate()
		{
			m_ActiveDeviceCount++;
			if (s_DefaultShaderInfoTexFloat != null)
			{
				UIRUtility.Destroy(s_DefaultShaderInfoTexFloat);
				s_DefaultShaderInfoTexFloat = null;
			}
			if (s_DefaultShaderInfoTexARGB8 != null)
			{
				UIRUtility.Destroy(s_DefaultShaderInfoTexARGB8);
				s_DefaultShaderInfoTexARGB8 = null;
			}
		}

		internal static void WrapUpGfxDeviceRecreate()
		{
			m_ActiveDeviceCount--;
		}

		internal static void FlushAllPendingDeviceDisposes()
		{
			Utility.SyncRenderThread();
			ProcessDeviceFreeQueue();
		}

		internal AllocationStatistics GatherAllocationStatistics()
		{
			AllocationStatistics result = new AllocationStatistics
			{
				completeInit = fullyCreated,
				freesDeferred = new int[m_DeferredFrees.Count]
			};
			for (int i = 0; i < m_DeferredFrees.Count; i++)
			{
				result.freesDeferred[i] = m_DeferredFrees[i].Count;
			}
			int num = 0;
			for (Page page = m_FirstPage; page != null; page = page.next)
			{
				num++;
			}
			result.pages = new AllocationStatistics.PageStatistics[num];
			num = 0;
			for (Page page = m_FirstPage; page != null; page = page.next)
			{
				result.pages[num].vertices = page.vertices.allocator.GatherStatistics();
				result.pages[num].indices = page.indices.allocator.GatherStatistics();
				num++;
			}
			return result;
		}

		internal DrawStatistics GatherDrawStatistics()
		{
			return m_DrawStats;
		}

		private static void ProcessDeviceFreeQueue()
		{
			if (m_SynchronousFree)
			{
				Utility.SyncRenderThread();
			}
			LinkedListNode<DeviceToFree> first = m_DeviceFreeQueue.First;
			while (first != null && Utility.CPUFencePassed(first.Value.handle))
			{
				first.Value.Dispose();
				m_DeviceFreeQueue.RemoveFirst();
				first = m_DeviceFreeQueue.First;
			}
			Debug.Assert(!m_SynchronousFree || m_DeviceFreeQueue.Count == 0);
			if (m_ActiveDeviceCount == 0 && m_SubscribedToNotifications)
			{
				if (s_DefaultShaderInfoTexFloat != null)
				{
					UIRUtility.Destroy(s_DefaultShaderInfoTexFloat);
					s_DefaultShaderInfoTexFloat = null;
				}
				if (s_DefaultShaderInfoTexARGB8 != null)
				{
					UIRUtility.Destroy(s_DefaultShaderInfoTexARGB8);
					s_DefaultShaderInfoTexARGB8 = null;
				}
				Utility.NotifyOfUIREvents(subscribe: false);
				m_SubscribedToNotifications = false;
			}
		}

		private static void OnEngineUpdateGlobal()
		{
			ProcessDeviceFreeQueue();
		}

		private static void OnFlushPendingResources()
		{
			m_SynchronousFree = true;
			ProcessDeviceFreeQueue();
		}
	}
	internal struct Alloc
	{
		public uint start;

		public uint size;

		internal object handle;

		internal bool shortLived;
	}
	internal struct HeapStatistics
	{
		public uint numAllocs;

		public uint totalSize;

		public uint allocatedSize;

		public uint freeSize;

		public uint largestAvailableBlock;

		public uint availableBlocksCount;

		public uint blockCount;

		public uint highWatermark;

		public float fragmentation;

		public HeapStatistics[] subAllocators;
	}
	internal class BestFitAllocator
	{
		private class BlockPool : LinkedPool<Block>
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			private static Block CreateBlock()
			{
				return new Block();
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			private static void ResetBlock(Block block)
			{
			}

			public BlockPool()
				: base((Func<Block>)CreateBlock, (Action<Block>)ResetBlock, 10000)
			{
			}
		}

		private class Block : LinkedPoolItem<Block>
		{
			public uint start;

			public uint end;

			public Block prev;

			public Block next;

			public Block prevAvailable;

			public Block nextAvailable;

			public bool allocated;

			public uint size => end - start;
		}

		private Block m_FirstBlock;

		private Block m_FirstAvailableBlock;

		private BlockPool m_BlockPool = new BlockPool();

		private uint m_HighWatermark;

		public uint totalSize { get; }

		public uint highWatermark => m_HighWatermark;

		public BestFitAllocator(uint size)
		{
			totalSize = size;
			m_FirstBlock = (m_FirstAvailableBlock = m_BlockPool.Get());
			m_FirstAvailableBlock.end = size;
		}

		public Alloc Allocate(uint size)
		{
			Block block = BestFitFindAvailableBlock(size);
			if (block == null)
			{
				return default(Alloc);
			}
			Debug.Assert(block.size >= size);
			Debug.Assert(!block.allocated);
			if (size != block.size)
			{
				SplitBlock(block, size);
			}
			Debug.Assert(block.size == size);
			if (block.end > m_HighWatermark)
			{
				m_HighWatermark = block.end;
			}
			if (block == m_FirstAvailableBlock)
			{
				m_FirstAvailableBlock = m_FirstAvailableBlock.nextAvailable;
			}
			if (block.prevAvailable != null)
			{
				block.prevAvailable.nextAvailable = block.nextAvailable;
			}
			if (block.nextAvailable != null)
			{
				block.nextAvailable.prevAvailable = block.prevAvailable;
			}
			block.allocated = true;
			block.prevAvailable = (block.nextAvailable = null);
			return new Alloc
			{
				start = block.start,
				size = block.size,
				handle = block
			};
		}

		public void Free(Alloc alloc)
		{
			Block block = (Block)alloc.handle;
			if (!block.allocated)
			{
				Debug.Assert(condition: false, "Severe error: UIR allocation double-free");
				return;
			}
			Debug.Assert(block.allocated);
			Debug.Assert(block.start == alloc.start);
			Debug.Assert(block.size == alloc.size);
			if (block.end == m_HighWatermark)
			{
				if (block.prev != null)
				{
					m_HighWatermark = (block.prev.allocated ? block.prev.end : block.prev.start);
				}
				else
				{
					m_HighWatermark = 0u;
				}
			}
			block.allocated = false;
			Block block2 = m_FirstAvailableBlock;
			Block block3 = null;
			while (block2 != null && block2.start < block.start)
			{
				block3 = block2;
				block2 = block2.nextAvailable;
			}
			if (block3 == null)
			{
				Debug.Assert(block.prevAvailable == null);
				block.nextAvailable = m_FirstAvailableBlock;
				m_FirstAvailableBlock = block;
			}
			else
			{
				block.prevAvailable = block3;
				block.nextAvailable = block3.nextAvailable;
				block3.nextAvailable = block;
			}
			if (block.nextAvailable != null)
			{
				block.nextAvailable.prevAvailable = block;
			}
			if (block.prevAvailable == block.prev && block.prev != null)
			{
				block = CoalesceBlockWithPrevious(block);
			}
			if (block.nextAvailable == block.next && block.next != null)
			{
				block = CoalesceBlockWithPrevious(block.next);
			}
		}

		private Block CoalesceBlockWithPrevious(Block block)
		{
			Debug.Assert(block.prevAvailable.end == block.start);
			Debug.Assert(block.prev.nextAvailable == block);
			Block prev = block.prev;
			prev.next = block.next;
			if (block.next != null)
			{
				block.next.prev = prev;
			}
			prev.nextAvailable = block.nextAvailable;
			if (block.nextAvailable != null)
			{
				block.nextAvailable.prevAvailable = block.prevAvailable;
			}
			prev.end = block.end;
			m_BlockPool.Return(block);
			return prev;
		}

		internal HeapStatistics GatherStatistics()
		{
			HeapStatistics result = default(HeapStatistics);
			for (Block block = m_FirstBlock; block != null; block = block.next)
			{
				if (block.allocated)
				{
					result.numAllocs++;
					result.allocatedSize += block.size;
				}
				else
				{
					result.freeSize += block.size;
					result.availableBlocksCount++;
					result.largestAvailableBlock = Math.Max(result.largestAvailableBlock, block.size);
				}
				result.blockCount++;
			}
			result.totalSize = totalSize;
			result.highWatermark = m_HighWatermark;
			if (result.freeSize != 0)
			{
				result.fragmentation = (float)((double)(result.freeSize - result.largestAvailableBlock) / (double)result.freeSize) * 100f;
			}
			return result;
		}

		private Block BestFitFindAvailableBlock(uint size)
		{
			Block block = m_FirstAvailableBlock;
			Block result = null;
			uint num = uint.MaxValue;
			while (block != null)
			{
				if (block.size >= size && num > block.size)
				{
					result = block;
					num = block.size;
				}
				block = block.nextAvailable;
			}
			return result;
		}

		private void SplitBlock(Block block, uint size)
		{
			Debug.Assert(block.size > size);
			Block block2 = m_BlockPool.Get();
			block2.next = block.next;
			block2.nextAvailable = block.nextAvailable;
			block2.prev = block;
			block2.prevAvailable = block;
			block2.start = block.start + size;
			block2.end = block.end;
			if (block2.next != null)
			{
				block2.next.prev = block2;
			}
			if (block2.nextAvailable != null)
			{
				block2.nextAvailable.prevAvailable = block2;
			}
			block.next = block2;
			block.nextAvailable = block2;
			block.end = block2.start;
		}
	}
	internal class GPUBufferAllocator
	{
		private BestFitAllocator m_Low;

		private BestFitAllocator m_High;

		public bool isEmpty => m_Low.highWatermark == 0 && m_High.highWatermark == 0;

		public GPUBufferAllocator(uint maxSize)
		{
			m_Low = new BestFitAllocator(maxSize);
			m_High = new BestFitAllocator(maxSize);
		}

		public Alloc Allocate(uint size, bool shortLived)
		{
			Alloc alloc;
			if (!shortLived)
			{
				alloc = m_Low.Allocate(size);
			}
			else
			{
				alloc = m_High.Allocate(size);
				alloc.start = m_High.totalSize - alloc.start - alloc.size;
			}
			alloc.shortLived = shortLived;
			if (HighLowCollide() && alloc.size != 0)
			{
				Free(alloc);
				return default(Alloc);
			}
			return alloc;
		}

		public void Free(Alloc alloc)
		{
			if (!alloc.shortLived)
			{
				m_Low.Free(alloc);
				return;
			}
			alloc.start = m_High.totalSize - alloc.start - alloc.size;
			m_High.Free(alloc);
		}

		public HeapStatistics GatherStatistics()
		{
			HeapStatistics result = new HeapStatistics
			{
				subAllocators = new HeapStatistics[2]
				{
					m_Low.GatherStatistics(),
					m_High.GatherStatistics()
				},
				largestAvailableBlock = uint.MaxValue
			};
			for (int i = 0; i < 2; i++)
			{
				result.numAllocs += result.subAllocators[i].numAllocs;
				result.totalSize = Math.Max(result.totalSize, result.subAllocators[i].totalSize);
				result.allocatedSize += result.subAllocators[i].allocatedSize;
				result.largestAvailableBlock = Math.Min(result.largestAvailableBlock, result.subAllocators[i].largestAvailableBlock);
				result.availableBlocksCount += result.subAllocators[i].availableBlocksCount;
				result.blockCount += result.subAllocators[i].blockCount;
				result.highWatermark = Math.Max(result.highWatermark, result.subAllocators[i].highWatermark);
				result.fragmentation = Math.Max(result.fragmentation, result.subAllocators[i].fragmentation);
			}
			result.freeSize = result.totalSize - result.allocatedSize;
			return result;
		}

		private bool HighLowCollide()
		{
			return m_Low.highWatermark + m_High.highWatermark > m_Low.totalSize;
		}
	}
	internal class Page : IDisposable
	{
		public class DataSet<T> : IDisposable where T : struct
		{
			public Utility.GPUBuffer<T> gpuData;

			public NativeArray<T> cpuData;

			public NativeArray<GfxUpdateBufferRange> updateRanges;

			public GPUBufferAllocator allocator;

			private readonly uint m_UpdateRangePoolSize;

			private uint m_ElemStride;

			private uint m_UpdateRangeMin;

			private uint m_UpdateRangeMax;

			private uint m_UpdateRangesEnqueued;

			private uint m_UpdateRangesBatchStart;

			private bool m_UpdateRangesSaturated;

			protected bool disposed { get; private set; }

			public DataSet(Utility.GPUBufferType bufferType, uint totalCount, uint maxQueuedFrameCount, uint updateRangePoolSize, bool mockBuffer)
			{
				if (!mockBuffer)
				{
					gpuData = new Utility.GPUBuffer<T>((int)totalCount, bufferType);
				}
				cpuData = new NativeArray<T>((int)totalCount, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);
				allocator = new GPUBufferAllocator(totalCount);
				if (!mockBuffer)
				{
					m_ElemStride = (uint)gpuData.ElementStride;
				}
				m_UpdateRangePoolSize = updateRangePoolSize;
				uint length = m_UpdateRangePoolSize * maxQueuedFrameCount;
				updateRanges = new NativeArray<GfxUpdateBufferRange>((int)length, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);
				m_UpdateRangeMin = uint.MaxValue;
				m_UpdateRangeMax = 0u;
				m_UpdateRangesEnqueued = 0u;
				m_UpdateRangesBatchStart = 0u;
			}

			public void Dispose()
			{
				Dispose(disposing: true);
				GC.SuppressFinalize(this);
			}

			public void Dispose(bool disposing)
			{
				if (!disposed)
				{
					if (disposing)
					{
						gpuData?.Dispose();
						cpuData.Dispose();
						updateRanges.Dispose();
					}
					disposed = true;
				}
			}

			public unsafe void RegisterUpdate(uint start, uint size)
			{
				Debug.Assert(start + size <= cpuData.Length);
				int num = (int)(m_UpdateRangesBatchStart + m_UpdateRangesEnqueued);
				if (m_UpdateRangesEnqueued != 0)
				{
					int index = num - 1;
					GfxUpdateBufferRange gfxUpdateBufferRange = updateRanges[index];
					uint num2 = start * m_ElemStride;
					if (gfxUpdateBufferRange.offsetFromWriteStart + gfxUpdateBufferRange.size == num2)
					{
						updateRanges[index] = new GfxUpdateBufferRange
						{
							source = gfxUpdateBufferRange.source,
							offsetFromWriteStart = gfxUpdateBufferRange.offsetFromWriteStart,
							size = gfxUpdateBufferRange.size + size * m_ElemStride
						};
						m_UpdateRangeMax = Math.Max(m_UpdateRangeMax, start + size);
						return;
					}
				}
				m_UpdateRangeMin = Math.Min(m_UpdateRangeMin, start);
				m_UpdateRangeMax = Math.Max(m_UpdateRangeMax, start + size);
				if (m_UpdateRangesEnqueued == m_UpdateRangePoolSize)
				{
					m_UpdateRangesSaturated = true;
					return;
				}
				UIntPtr source = new UIntPtr(cpuData.Slice((int)start, (int)size).GetUnsafeReadOnlyPtr());
				updateRanges[num] = new GfxUpdateBufferRange
				{
					source = source,
					offsetFromWriteStart = start * m_ElemStride,
					size = size * m_ElemStride
				};
				m_UpdateRangesEnqueued++;
			}

			private bool HasMappedBufferRange()
			{
				return Utility.HasMappedBufferRange();
			}

			public void SendUpdates()
			{
				if (HasMappedBufferRange())
				{
					SendPartialRanges();
				}
				else
				{
					SendFullRange();
				}
			}

			public unsafe void SendFullRange()
			{
				uint num = (uint)(cpuData.Length * m_ElemStride);
				updateRanges[(int)m_UpdateRangesBatchStart] = new GfxUpdateBufferRange
				{
					source = new UIntPtr(cpuData.GetUnsafeReadOnlyPtr()),
					offsetFromWriteStart = 0u,
					size = num
				};
				gpuData?.UpdateRanges(updateRanges.Slice((int)m_UpdateRangesBatchStart, 1), 0, (int)num);
				ResetUpdateState();
			}

			public unsafe void SendPartialRanges()
			{
				if (m_UpdateRangesEnqueued == 0)
				{
					return;
				}
				if (m_UpdateRangesSaturated)
				{
					uint num = m_UpdateRangeMax - m_UpdateRangeMin;
					m_UpdateRangesEnqueued = 1u;
					updateRanges[(int)m_UpdateRangesBatchStart] = new GfxUpdateBufferRange
					{
						source = new UIntPtr(cpuData.Slice((int)m_UpdateRangeMin, (int)num).GetUnsafeReadOnlyPtr()),
						offsetFromWriteStart = m_UpdateRangeMin * m_ElemStride,
						size = num * m_ElemStride
					};
				}
				uint num2 = m_UpdateRangeMin * m_ElemStride;
				uint rangesMax = m_UpdateRangeMax * m_ElemStride;
				if (num2 != 0)
				{
					for (uint num3 = 0u; num3 < m_UpdateRangesEnqueued; num3++)
					{
						int index = (int)(num3 + m_UpdateRangesBatchStart);
						updateRanges[index] = new GfxUpdateBufferRange
						{
							source = updateRanges[index].source,
							offsetFromWriteStart = updateRanges[index].offsetFromWriteStart - num2,
							size = updateRanges[index].size
						};
					}
				}
				gpuData?.UpdateRanges(updateRanges.Slice((int)m_UpdateRangesBatchStart, (int)m_UpdateRangesEnqueued), (int)num2, (int)rangesMax);
				ResetUpdateState();
			}

			private void ResetUpdateState()
			{
				m_UpdateRangeMin = uint.MaxValue;
				m_UpdateRangeMax = 0u;
				m_UpdateRangesEnqueued = 0u;
				m_UpdateRangesBatchStart += m_UpdateRangePoolSize;
				if (m_UpdateRangesBatchStart >= updateRanges.Length)
				{
					m_UpdateRangesBatchStart = 0u;
				}
				m_UpdateRangesSaturated = false;
			}
		}

		public DataSet<Vertex> vertices;

		public DataSet<ushort> indices;

		public Page next;

		public int framesEmpty;

		protected bool disposed { get; private set; }

		public bool isEmpty => vertices.allocator.isEmpty && indices.allocator.isEmpty;

		public Page(uint vertexMaxCount, uint indexMaxCount, uint maxQueuedFrameCount, bool mockPage)
		{
			vertexMaxCount = Math.Min(vertexMaxCount, 65536u);
			vertices = new DataSet<Vertex>(Utility.GPUBufferType.Vertex, vertexMaxCount, maxQueuedFrameCount, 32u, mockPage);
			indices = new DataSet<ushort>(Utility.GPUBufferType.Index, indexMaxCount, maxQueuedFrameCount, 32u, mockPage);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (disposing)
				{
					indices.Dispose();
					vertices.Dispose();
				}
				disposed = true;
			}
		}
	}
	internal enum VertexFlags
	{
		IsSolid = 0,
		IsText = 1,
		IsTextured = 2,
		IsDynamic = 3,
		IsSvgGradients = 4,
		[Obsolete("Enum member VertexFlags.LastType has been deprecated. Use VertexFlags.IsGraphViewEdge instead.")]
		LastType = 10,
		IsGraphViewEdge = 10
	}
	internal struct State
	{
		public Material material;

		public TextureId texture;

		public int stencilRef;

		public float sdfScale;
	}
	internal enum CommandType
	{
		Draw,
		ImmediateCull,
		Immediate,
		PushView,
		PopView,
		PushScissor,
		PopScissor,
		PushRenderTexture,
		PopRenderTexture,
		BlitToPreviousRT,
		PushDefaultMaterial,
		PopDefaultMaterial
	}
	internal class DrawParams
	{
		internal static readonly Rect k_UnlimitedRect = new Rect(-100000f, -100000f, 200000f, 200000f);

		internal static readonly Rect k_FullNormalizedRect = new Rect(-1f, -1f, 2f, 2f);

		internal readonly Stack<Matrix4x4> view = new Stack<Matrix4x4>(8);

		internal readonly Stack<Rect> scissor = new Stack<Rect>(8);

		internal readonly List<RenderTexture> renderTexture = new List<RenderTexture>(8);

		internal readonly List<Material> defaultMaterial = new List<Material>(8);

		public void Reset()
		{
			view.Clear();
			view.Push(Matrix4x4.identity);
			scissor.Clear();
			scissor.Push(k_UnlimitedRect);
			renderTexture.Clear();
			defaultMaterial.Clear();
		}
	}
	internal class RenderChainCommand : LinkedPoolItem<RenderChainCommand>
	{
		internal VisualElement owner;

		internal RenderChainCommand prev;

		internal RenderChainCommand next;

		internal bool closing;

		internal CommandType type;

		internal State state;

		internal MeshHandle mesh;

		internal int indexOffset;

		internal int indexCount;

		internal Action callback;

		private static readonly int k_ID_MainTex = Shader.PropertyToID("_MainTex");

		private static ProfilerMarker s_ImmediateOverheadMarker = new ProfilerMarker("UIR.ImmediateOverhead");

		internal void Reset()
		{
			owner = null;
			prev = (next = null);
			closing = false;
			type = CommandType.Draw;
			state = default(State);
			mesh = null;
			indexOffset = (indexCount = 0);
			callback = null;
		}

		internal void ExecuteNonDrawMesh(DrawParams drawParams, float pixelsPerPoint, ref Exception immediateException)
		{
			switch (type)
			{
			case CommandType.ImmediateCull:
				if (!RectPointsToPixelsAndFlipYAxis(owner.worldBound, pixelsPerPoint).Overlaps(Utility.GetActiveViewport()))
				{
					break;
				}
				goto case CommandType.Immediate;
			case CommandType.Immediate:
			{
				if (immediateException != null)
				{
					break;
				}
				Matrix4x4 unityProjectionMatrix = Utility.GetUnityProjectionMatrix();
				Camera current = Camera.current;
				RenderTexture active = RenderTexture.active;
				bool flag = drawParams.scissor.Count > 1;
				if (flag)
				{
					Utility.DisableScissor();
				}
				using (new GUIClip.ParentClipScope(owner.worldTransform, owner.worldClip))
				{
					try
					{
						callback();
					}
					catch (Exception ex)
					{
						immediateException = ex;
					}
				}
				Camera.SetupCurrent(current);
				RenderTexture.active = active;
				GL.modelview = drawParams.view.Peek();
				GL.LoadProjectionMatrix(unityProjectionMatrix);
				if (flag)
				{
					Utility.SetScissorRect(RectPointsToPixelsAndFlipYAxis(drawParams.scissor.Peek(), pixelsPerPoint));
				}
				break;
			}
			case CommandType.PushView:
			{
				drawParams.view.Push(owner.worldTransform);
				GL.modelview = owner.worldTransform;
				Rect rect3 = owner.hierarchy.parent?.worldClip ?? DrawParams.k_FullNormalizedRect;
				drawParams.scissor.Push(rect3);
				Utility.SetScissorRect(RectPointsToPixelsAndFlipYAxis(rect3, pixelsPerPoint));
				break;
			}
			case CommandType.PopView:
			{
				drawParams.view.Pop();
				GL.modelview = drawParams.view.Peek();
				drawParams.scissor.Pop();
				Rect rect = drawParams.scissor.Peek();
				if (rect.x == DrawParams.k_UnlimitedRect.x)
				{
					Utility.DisableScissor();
				}
				else
				{
					Utility.SetScissorRect(RectPointsToPixelsAndFlipYAxis(rect, pixelsPerPoint));
				}
				break;
			}
			case CommandType.PushScissor:
			{
				Rect rect4 = CombineScissorRects(owner.worldClip, drawParams.scissor.Peek());
				drawParams.scissor.Push(rect4);
				Utility.SetScissorRect(RectPointsToPixelsAndFlipYAxis(rect4, pixelsPerPoint));
				break;
			}
			case CommandType.PopScissor:
			{
				drawParams.scissor.Pop();
				Rect rect2 = drawParams.scissor.Peek();
				if (rect2.x == DrawParams.k_UnlimitedRect.x)
				{
					Utility.DisableScissor();
				}
				else
				{
					Utility.SetScissorRect(RectPointsToPixelsAndFlipYAxis(rect2, pixelsPerPoint));
				}
				break;
			}
			case CommandType.PushRenderTexture:
			{
				RectInt activeViewport = Utility.GetActiveViewport();
				RenderTexture temporary = RenderTexture.GetTemporary(activeViewport.width, activeViewport.height, 24, RenderTextureFormat.ARGBHalf);
				RenderTexture.active = temporary;
				GL.Clear(clearDepth: true, clearColor: true, new Color(0f, 0f, 0f, 0f), 0.99f);
				drawParams.renderTexture.Add(RenderTexture.active);
				break;
			}
			case CommandType.PopRenderTexture:
			{
				int num = drawParams.renderTexture.Count - 1;
				Debug.Assert(num > 0);
				Debug.Assert(drawParams.renderTexture[num - 1] == RenderTexture.active, "Content of previous render texture was probably not blitted");
				RenderTexture renderTexture2 = drawParams.renderTexture[num];
				if (renderTexture2 != null)
				{
					RenderTexture.ReleaseTemporary(renderTexture2);
				}
				drawParams.renderTexture.RemoveAt(num);
				break;
			}
			case CommandType.BlitToPreviousRT:
			{
				RenderTexture renderTexture = drawParams.renderTexture[drawParams.renderTexture.Count - 1];
				RenderTexture destination = drawParams.renderTexture[drawParams.renderTexture.Count - 2];
				Debug.Assert(renderTexture == RenderTexture.active, "Unexpected render target change: Current renderTarget is not the one on the top of the stack");
				Blit(renderTexture, destination, 0f);
				break;
			}
			case CommandType.PushDefaultMaterial:
				break;
			case CommandType.PopDefaultMaterial:
				break;
			}
		}

		private void Blit(Texture source, RenderTexture destination, float depth)
		{
			GL.PushMatrix();
			GL.LoadOrtho();
			RenderTexture.active = destination;
			state.material.SetTexture(k_ID_MainTex, source);
			state.material.SetPass(0);
			GL.Begin(7);
			GL.TexCoord2(0f, 0f);
			GL.Vertex3(0f, 0f, depth);
			GL.TexCoord2(0f, 1f);
			GL.Vertex3(0f, 1f, depth);
			GL.TexCoord2(1f, 1f);
			GL.Vertex3(1f, 1f, depth);
			GL.TexCoord2(1f, 0f);
			GL.Vertex3(1f, 0f, depth);
			GL.End();
			GL.PopMatrix();
		}

		private static Vector4 RectToClipSpace(Rect rc)
		{
			Matrix4x4 deviceProjectionMatrix = Utility.GetDeviceProjectionMatrix();
			Vector3 vector = deviceProjectionMatrix.MultiplyPoint(new Vector3(rc.xMin, rc.yMin, 0f));
			Vector3 vector2 = deviceProjectionMatrix.MultiplyPoint(new Vector3(rc.xMax, rc.yMax, 0f));
			return new Vector4(Mathf.Min(vector.x, vector2.x), Mathf.Min(vector.y, vector2.y), Mathf.Max(vector.x, vector2.x), Mathf.Max(vector.y, vector2.y));
		}

		private static Rect CombineScissorRects(Rect r0, Rect r1)
		{
			Rect result = new Rect(0f, 0f, 0f, 0f);
			result.x = Math.Max(r0.x, r1.x);
			result.y = Math.Max(r0.y, r1.y);
			result.xMax = Math.Max(result.x, Math.Min(r0.xMax, r1.xMax));
			result.yMax = Math.Max(result.y, Math.Min(r0.yMax, r1.yMax));
			return result;
		}

		private static RectInt RectPointsToPixelsAndFlipYAxis(Rect rect, float pixelsPerPoint)
		{
			float num = Utility.GetActiveViewport().height;
			RectInt result = new RectInt(0, 0, 0, 0);
			result.x = Mathf.RoundToInt(rect.x * pixelsPerPoint);
			result.y = Mathf.RoundToInt(num - rect.yMax * pixelsPerPoint);
			result.width = Mathf.RoundToInt(rect.width * pixelsPerPoint);
			result.height = Mathf.RoundToInt(rect.height * pixelsPerPoint);
			return result;
		}
	}
	internal class GradientSettingsAtlas : IDisposable
	{
		private struct RawTexture
		{
			public Color32[] rgba;

			public int width;

			public int height;

			public void WriteRawInt2Packed(int v0, int v1, int destX, int destY)
			{
				byte b = (byte)(v0 / 255);
				byte g = (byte)(v0 - b * 255);
				byte b2 = (byte)(v1 / 255);
				byte a = (byte)(v1 - b2 * 255);
				int num = destY * width + destX;
				rgba[num] = new Color32(b, g, b2, a);
			}

			public void WriteRawFloat4Packed(float f0, float f1, float f2, float f3, int destX, int destY)
			{
				byte r = (byte)(f0 * 255f + 0.5f);
				byte g = (byte)(f1 * 255f + 0.5f);
				byte b = (byte)(f2 * 255f + 0.5f);
				byte a = (byte)(f3 * 255f + 0.5f);
				int num = destY * width + destX;
				rgba[num] = new Color32(r, g, b, a);
			}
		}

		private static ProfilerMarker s_MarkerWrite = new ProfilerMarker("UIR.GradientSettingsAtlas.Write");

		private static ProfilerMarker s_MarkerCommit = new ProfilerMarker("UIR.GradientSettingsAtlas.Commit");

		private readonly int m_Length;

		private readonly int m_ElemWidth;

		private BestFitAllocator m_Allocator;

		private Texture2D m_Atlas;

		private RawTexture m_RawAtlas;

		private static int s_TextureCounter;

		internal int length => m_Length;

		protected bool disposed { get; private set; }

		public Texture2D atlas => m_Atlas;

		public bool MustCommit { get; private set; }

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (disposing)
				{
					UIRUtility.Destroy(m_Atlas);
				}
				disposed = true;
			}
		}

		public GradientSettingsAtlas(int length = 4096)
		{
			m_Length = length;
			m_ElemWidth = 3;
			Reset();
		}

		public void Reset()
		{
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
				return;
			}
			m_Allocator = new BestFitAllocator((uint)m_Length);
			UIRUtility.Destroy(m_Atlas);
			m_RawAtlas = default(RawTexture);
			MustCommit = false;
		}

		public Alloc Add(int count)
		{
			Debug.Assert(count > 0);
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
				return default(Alloc);
			}
			return m_Allocator.Allocate((uint)count);
		}

		public void Remove(Alloc alloc)
		{
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
			}
			else
			{
				m_Allocator.Free(alloc);
			}
		}

		public void Write(Alloc alloc, GradientSettings[] settings, GradientRemap remap)
		{
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
				return;
			}
			if (m_RawAtlas.rgba == null)
			{
				m_RawAtlas = new RawTexture
				{
					rgba = new Color32[m_ElemWidth * m_Length],
					width = m_ElemWidth,
					height = m_Length
				};
				int num = m_ElemWidth * m_Length;
				for (int i = 0; i < num; i++)
				{
					m_RawAtlas.rgba[i] = Color.black;
				}
			}
			int num2 = (int)alloc.start;
			int j = 0;
			for (int num3 = settings.Length; j < num3; j++)
			{
				int num4 = 0;
				GradientSettings gradientSettings = settings[j];
				Debug.Assert(remap == null || num2 == remap.destIndex);
				if (gradientSettings.gradientType == GradientType.Radial)
				{
					Vector2 radialFocus = gradientSettings.radialFocus;
					radialFocus += Vector2.one;
					radialFocus /= 2f;
					radialFocus.y = 1f - radialFocus.y;
					m_RawAtlas.WriteRawFloat4Packed(0.003921569f, (float)gradientSettings.addressMode / 255f, radialFocus.x, radialFocus.y, num4++, num2);
				}
				else if (gradientSettings.gradientType == GradientType.Linear)
				{
					m_RawAtlas.WriteRawFloat4Packed(0f, (float)gradientSettings.addressMode / 255f, 0f, 0f, num4++, num2);
				}
				Vector2Int vector2Int = new Vector2Int(gradientSettings.location.x, gradientSettings.location.y);
				Vector2 vector = new Vector2(gradientSettings.location.width - 1, gradientSettings.location.height - 1);
				if (remap != null)
				{
					vector2Int = new Vector2Int(remap.location.x, remap.location.y);
					vector = new Vector2(remap.location.width - 1, remap.location.height - 1);
				}
				m_RawAtlas.WriteRawInt2Packed(vector2Int.x, vector2Int.y, num4++, num2);
				m_RawAtlas.WriteRawInt2Packed((int)vector.x, (int)vector.y, num4++, num2);
				remap = remap?.next;
				num2++;
			}
			MustCommit = true;
		}

		public void Commit()
		{
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
			}
			else if (MustCommit)
			{
				PrepareAtlas();
				m_Atlas.SetPixels32(m_RawAtlas.rgba);
				m_Atlas.Apply();
				MustCommit = false;
			}
		}

		private void PrepareAtlas()
		{
			if (!(m_Atlas != null))
			{
				m_Atlas = new Texture2D(m_ElemWidth, m_Length, TextureFormat.ARGB32, 0, linear: true)
				{
					hideFlags = HideFlags.HideAndDontSave,
					name = "GradientSettings " + s_TextureCounter++,
					filterMode = FilterMode.Point
				};
			}
		}
	}
	internal class JobManager : IDisposable
	{
		private NativePagedList<NudgeJobData> m_NudgeJobs = new NativePagedList<NudgeJobData>(64);

		private NativePagedList<ConvertMeshJobData> m_ConvertMeshJobs = new NativePagedList<ConvertMeshJobData>(64);

		private NativePagedList<CopyClosingMeshJobData> m_CopyClosingMeshJobs = new NativePagedList<CopyClosingMeshJobData>(64);

		private JobMerger m_JobMerger = new JobMerger(128);

		protected bool disposed { get; private set; }

		public void Add(ref NudgeJobData job)
		{
			m_NudgeJobs.Add(ref job);
		}

		public void Add(ref ConvertMeshJobData job)
		{
			m_ConvertMeshJobs.Add(ref job);
		}

		public void Add(ref CopyClosingMeshJobData job)
		{
			m_CopyClosingMeshJobs.Add(ref job);
		}

		public unsafe void CompleteNudgeJobs()
		{
			foreach (NativeSlice<NudgeJobData> page in m_NudgeJobs.GetPages())
			{
				m_JobMerger.Add(JobProcessor.ScheduleNudgeJobs((IntPtr)page.GetUnsafePtr(), page.Length));
			}
			m_JobMerger.MergeAndReset().Complete();
			m_NudgeJobs.Reset();
		}

		public unsafe void CompleteConvertMeshJobs()
		{
			foreach (NativeSlice<ConvertMeshJobData> page in m_ConvertMeshJobs.GetPages())
			{
				m_JobMerger.Add(JobProcessor.ScheduleConvertMeshJobs((IntPtr)page.GetUnsafePtr(), page.Length));
			}
			m_JobMerger.MergeAndReset().Complete();
			m_ConvertMeshJobs.Reset();
		}

		public unsafe void CompleteClosingMeshJobs()
		{
			foreach (NativeSlice<CopyClosingMeshJobData> page in m_CopyClosingMeshJobs.GetPages())
			{
				m_JobMerger.Add(JobProcessor.ScheduleCopyClosingMeshJobs((IntPtr)page.GetUnsafePtr(), page.Length));
			}
			m_JobMerger.MergeAndReset().Complete();
			m_CopyClosingMeshJobs.Reset();
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (disposing)
				{
					m_NudgeJobs.Dispose();
					m_ConvertMeshJobs.Dispose();
					m_CopyClosingMeshJobs.Dispose();
					m_JobMerger.Dispose();
				}
				disposed = true;
			}
		}
	}
	internal struct NudgeJobData
	{
		public IntPtr src;

		public IntPtr dst;

		public int count;

		public IntPtr closingSrc;

		public IntPtr closingDst;

		public int closingCount;

		public Matrix4x4 transform;

		public int vertsBeforeUVDisplacement;

		public int vertsAfterUVDisplacement;
	}
	internal struct ConvertMeshJobData
	{
		public IntPtr vertSrc;

		public IntPtr vertDst;

		public int vertCount;

		public Matrix4x4 transform;

		public int transformUVs;

		public Color32 xformClipPages;

		public Color32 ids;

		public Color32 addFlags;

		public Color32 opacityPage;

		public Color32 textCoreSettingsPage;

		public int isText;

		public float textureId;

		public IntPtr indexSrc;

		public IntPtr indexDst;

		public int indexCount;

		public int indexOffset;

		public int flipIndices;
	}
	internal struct CopyClosingMeshJobData
	{
		public IntPtr vertSrc;

		public IntPtr vertDst;

		public int vertCount;

		public IntPtr indexSrc;

		public IntPtr indexDst;

		public int indexCount;

		public int indexOffset;
	}
	internal class JobMerger : IDisposable
	{
		private NativeArray<JobHandle> m_Jobs;

		private int m_JobCount;

		protected bool disposed { get; private set; }

		public JobMerger(int capacity)
		{
			Debug.Assert(capacity > 1);
			m_Jobs = new NativeArray<JobHandle>(capacity, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);
		}

		public void Add(JobHandle job)
		{
			if (m_JobCount < m_Jobs.Length)
			{
				m_Jobs[m_JobCount++] = job;
				return;
			}
			m_Jobs[0] = JobHandle.CombineDependencies(m_Jobs);
			m_Jobs[1] = job;
			m_JobCount = 2;
		}

		public JobHandle MergeAndReset()
		{
			JobHandle result = default(JobHandle);
			if (m_JobCount > 1)
			{
				result = JobHandle.CombineDependencies(m_Jobs.Slice(0, m_JobCount));
			}
			else if (m_JobCount == 1)
			{
				result = m_Jobs[0];
			}
			m_JobCount = 0;
			return result;
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (disposing)
				{
					m_Jobs.Dispose();
				}
				disposed = true;
			}
		}
	}
	internal class LinkedPoolItem<T>
	{
		internal T poolNext;
	}
	internal class LinkedPool<T> where T : LinkedPoolItem<T>
	{
		private readonly Func<T> m_CreateFunc;

		private readonly Action<T> m_ResetAction;

		private readonly int m_Limit;

		private T m_PoolFirst;

		public int Count { get; private set; }

		public LinkedPool(Func<T> createFunc, Action<T> resetAction, int limit = 10000)
		{
			Debug.Assert(createFunc != null);
			m_CreateFunc = createFunc;
			Debug.Assert(resetAction != null);
			m_ResetAction = resetAction;
			Debug.Assert(limit > 0);
			m_Limit = limit;
		}

		public void Clear()
		{
			m_PoolFirst = null;
			Count = 0;
		}

		public T Get()
		{
			T val = m_PoolFirst;
			if (m_PoolFirst != null)
			{
				int count = Count - 1;
				Count = count;
				m_PoolFirst = val.poolNext;
				m_ResetAction(val);
			}
			else
			{
				val = m_CreateFunc();
			}
			return val;
		}

		public void Return(T item)
		{
			if (Count < m_Limit)
			{
				item.poolNext = m_PoolFirst;
				m_PoolFirst = item;
				int count = Count + 1;
				Count = count;
			}
		}
	}
	internal class BasicNode<T> : LinkedPoolItem<BasicNode<T>>
	{
		public BasicNode<T> next;

		public T data;

		public void AppendTo(ref BasicNode<T> first)
		{
			if (first == null)
			{
				first = this;
				return;
			}
			BasicNode<T> basicNode = first;
			while (basicNode.next != null)
			{
				basicNode = basicNode.next;
			}
			basicNode.next = this;
		}
	}
	internal class BasicNodePool<T> : LinkedPool<BasicNode<T>>
	{
		private static void Reset(BasicNode<T> node)
		{
			node.next = null;
			node.data = default(T);
		}

		private static BasicNode<T> Create()
		{
			return new BasicNode<T>();
		}

		public BasicNodePool()
			: base((Func<BasicNode<T>>)Create, (Action<BasicNode<T>>)Reset, 10000)
		{
		}
	}
	internal static class MeshBuilder
	{
		internal struct AllocMeshData
		{
			internal delegate MeshWriteData Allocator(uint vertexCount, uint indexCount, ref AllocMeshData allocatorData);

			internal Allocator alloc;

			internal Texture texture;

			internal TextureId svgTexture;

			internal Material material;

			internal MeshGenerationContext.MeshFlags flags;

			internal BMPAlloc colorAlloc;

			internal MeshWriteData Allocate(uint vertexCount, uint indexCount)
			{
				return alloc(vertexCount, indexCount, ref this);
			}
		}

		private static ProfilerMarker s_VectorGraphics9Slice = new ProfilerMarker("UIR.MakeVector9Slice");

		private static ProfilerMarker s_VectorGraphicsSplitTriangle = new ProfilerMarker("UIR.SplitTriangle");

		private static ProfilerMarker s_VectorGraphicsScaleTriangle = new ProfilerMarker("UIR.ScaleTriangle");

		private static ProfilerMarker s_VectorGraphicsStretch = new ProfilerMarker("UIR.MakeVectorStretch");

		internal static readonly int s_MaxTextMeshVertices = 49152;

		private static Vertex ConvertTextVertexToUIRVertex(MeshInfo info, int index, Vector2 offset, VertexFlags flags = VertexFlags.IsText, bool isDynamicColor = false)
		{
			float num = 0f;
			if (info.uvs2[index].y < 0f)
			{
				num = 1f;
			}
			return new Vertex
			{
				position = new Vector3(info.vertices[index].x + offset.x, info.vertices[index].y + offset.y, 0f),
				uv = new Vector2(info.uvs0[index].x, info.uvs0[index].y),
				tint = info.colors32[index],
				flags = new Color32((byte)flags, (byte)(num * 255f), 0, (byte)(isDynamicColor ? 1 : 0))
			};
		}

		private static Vertex ConvertTextVertexToUIRVertex(TextVertex textVertex, Vector2 offset)
		{
			return new Vertex
			{
				position = new Vector3(textVertex.position.x + offset.x, textVertex.position.y + offset.y, 0f),
				uv = textVertex.uv0,
				tint = textVertex.color,
				flags = new Color32(1, 0, 0, 0)
			};
		}

		private static int LimitTextVertices(int vertexCount, bool logTruncation = true)
		{
			if (vertexCount <= s_MaxTextMeshVertices)
			{
				return vertexCount;
			}
			if (logTruncation)
			{
				Debug.LogWarning($"Generated text will be truncated because it exceeds {s_MaxTextMeshVertices} vertices.");
			}
			return s_MaxTextMeshVertices;
		}

		internal static void MakeText(MeshInfo meshInfo, Vector2 offset, AllocMeshData meshAlloc, VertexFlags flags = VertexFlags.IsText, bool isDynamicColor = false)
		{
			int num = LimitTextVertices(meshInfo.vertexCount);
			int num2 = num / 4;
			MeshWriteData meshWriteData = meshAlloc.Allocate((uint)(num2 * 4), (uint)(num2 * 6));
			int num3 = 0;
			int num4 = 0;
			while (num3 < num2)
			{
				meshWriteData.SetNextVertex(ConvertTextVertexToUIRVertex(meshInfo, num4, offset, flags, isDynamicColor));
				meshWriteData.SetNextVertex(ConvertTextVertexToUIRVertex(meshInfo, num4 + 1, offset, flags, isDynamicColor));
				meshWriteData.SetNextVertex(ConvertTextVertexToUIRVertex(meshInfo, num4 + 2, offset, flags, isDynamicColor));
				meshWriteData.SetNextVertex(ConvertTextVertexToUIRVertex(meshInfo, num4 + 3, offset, flags, isDynamicColor));
				meshWriteData.SetNextIndex((ushort)num4);
				meshWriteData.SetNextIndex((ushort)(num4 + 1));
				meshWriteData.SetNextIndex((ushort)(num4 + 2));
				meshWriteData.SetNextIndex((ushort)(num4 + 2));
				meshWriteData.SetNextIndex((ushort)(num4 + 3));
				meshWriteData.SetNextIndex((ushort)num4);
				num3++;
				num4 += 4;
			}
		}

		internal static void MakeText(NativeArray<TextVertex> uiVertices, Vector2 offset, AllocMeshData meshAlloc)
		{
			int num = LimitTextVertices(uiVertices.Length);
			int num2 = num / 4;
			MeshWriteData meshWriteData = meshAlloc.Allocate((uint)(num2 * 4), (uint)(num2 * 6));
			int num3 = 0;
			int num4 = 0;
			while (num3 < num2)
			{
				meshWriteData.SetNextVertex(ConvertTextVertexToUIRVertex(uiVertices[num4], offset));
				meshWriteData.SetNextVertex(ConvertTextVertexToUIRVertex(uiVertices[num4 + 1], offset));
				meshWriteData.SetNextVertex(ConvertTextVertexToUIRVertex(uiVertices[num4 + 2], offset));
				meshWriteData.SetNextVertex(ConvertTextVertexToUIRVertex(uiVertices[num4 + 3], offset));
				meshWriteData.SetNextIndex((ushort)num4);
				meshWriteData.SetNextIndex((ushort)(num4 + 1));
				meshWriteData.SetNextIndex((ushort)(num4 + 2));
				meshWriteData.SetNextIndex((ushort)(num4 + 2));
				meshWriteData.SetNextIndex((ushort)(num4 + 3));
				meshWriteData.SetNextIndex((ushort)num4);
				num3++;
				num4 += 4;
			}
		}
	}
	internal class NativePagedList<T> : IDisposable where T : struct
	{
		private readonly int k_PoolCapacity;

		private List<NativeArray<T>> m_Pages = new List<NativeArray<T>>(8);

		private NativeArray<T> m_CurrentPage;

		private int m_CurrentPageCount;

		private List<NativeSlice<T>> m_Enumerator = new List<NativeSlice<T>>(8);

		protected bool disposed { get; private set; }

		public NativePagedList(int poolCapacity)
		{
			Debug.Assert(poolCapacity > 0);
			k_PoolCapacity = Mathf.NextPowerOfTwo(poolCapacity);
		}

		public void Add(ref T data)
		{
			if (m_CurrentPageCount < m_CurrentPage.Length)
			{
				m_CurrentPage[m_CurrentPageCount++] = data;
				return;
			}
			int length = ((m_Pages.Count > 0) ? (m_CurrentPage.Length << 1) : k_PoolCapacity);
			m_CurrentPage = new NativeArray<T>(length, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);
			m_Pages.Add(m_CurrentPage);
			m_CurrentPage[0] = data;
			m_CurrentPageCount = 1;
		}

		public void Add(T data)
		{
			Add(ref data);
		}

		public List<NativeSlice<T>> GetPages()
		{
			m_Enumerator.Clear();
			if (m_Pages.Count > 0)
			{
				int num = m_Pages.Count - 1;
				for (int i = 0; i < num; i++)
				{
					m_Enumerator.Add(m_Pages[i]);
				}
				if (m_CurrentPageCount > 0)
				{
					m_Enumerator.Add(m_CurrentPage.Slice(0, m_CurrentPageCount));
				}
			}
			return m_Enumerator;
		}

		public void Reset()
		{
			if (m_Pages.Count > 1)
			{
				m_CurrentPage = m_Pages[0];
				for (int i = 1; i < m_Pages.Count; i++)
				{
					m_Pages[i].Dispose();
				}
				m_Pages.Clear();
				m_Pages.Add(m_CurrentPage);
			}
			m_CurrentPageCount = 0;
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected void Dispose(bool disposing)
		{
			if (disposed)
			{
				return;
			}
			if (disposing)
			{
				for (int i = 0; i < m_Pages.Count; i++)
				{
					m_Pages[i].Dispose();
				}
				m_Pages.Clear();
				m_CurrentPageCount = 0;
			}
			disposed = true;
		}
	}
	internal class OpacityIdAccelerator : IDisposable
	{
		private struct OpacityIdUpdateJob : IJobParallelFor
		{
			[NativeDisableContainerSafetyRestriction]
			public NativeSlice<Vertex> oldVerts;

			[NativeDisableContainerSafetyRestriction]
			public NativeSlice<Vertex> newVerts;

			public Color32 opacityData;

			public void Execute(int i)
			{
				Vertex value = oldVerts[i];
				value.opacityColorPages.r = opacityData.r;
				value.opacityColorPages.g = opacityData.g;
				value.ids.b = opacityData.b;
				newVerts[i] = value;
			}
		}

		private const int k_VerticesPerBatch = 128;

		private const int k_JobLimit = 256;

		private NativeArray<JobHandle> m_Jobs = new NativeArray<JobHandle>(256, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);

		private int m_NextJobIndex;

		protected bool disposed { get; private set; }

		public void CreateJob(NativeSlice<Vertex> oldVerts, NativeSlice<Vertex> newVerts, Color32 opacityData, int vertexCount)
		{
			JobHandle value = new OpacityIdUpdateJob
			{
				oldVerts = oldVerts,
				newVerts = newVerts,
				opacityData = opacityData
			}.Schedule(vertexCount, 128);
			if (m_NextJobIndex == m_Jobs.Length)
			{
				m_Jobs[0] = JobHandle.CombineDependencies(m_Jobs);
				m_NextJobIndex = 1;
				JobHandle.ScheduleBatchedJobs();
			}
			m_Jobs[m_NextJobIndex++] = value;
		}

		public void CompleteJobs()
		{
			if (m_NextJobIndex > 0)
			{
				if (m_NextJobIndex > 1)
				{
					JobHandle.CombineDependencies(m_Jobs.Slice(0, m_NextJobIndex)).Complete();
				}
				else
				{
					m_Jobs[0].Complete();
				}
			}
			m_NextJobIndex = 0;
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (disposing)
				{
					m_Jobs.Dispose();
				}
				disposed = true;
			}
		}
	}
	internal struct ChainBuilderStats
	{
		public uint elementsAdded;

		public uint elementsRemoved;

		public uint recursiveClipUpdates;

		public uint recursiveClipUpdatesExpanded;

		public uint nonRecursiveClipUpdates;

		public uint recursiveTransformUpdates;

		public uint recursiveTransformUpdatesExpanded;

		public uint recursiveOpacityUpdates;

		public uint recursiveOpacityUpdatesExpanded;

		public uint opacityIdUpdates;

		public uint colorUpdates;

		public uint colorUpdatesExpanded;

		public uint recursiveVisualUpdates;

		public uint recursiveVisualUpdatesExpanded;

		public uint nonRecursiveVisualUpdates;

		public uint dirtyProcessed;

		public uint nudgeTransformed;

		public uint boneTransformed;

		public uint skipTransformed;

		public uint visualUpdateTransformed;

		public uint updatedMeshAllocations;

		public uint newMeshAllocations;

		public uint groupTransformElementsChanged;

		public uint immedateRenderersActive;
	}
	internal class RenderChain : IDisposable
	{
		private struct DepthOrderedDirtyTracking
		{
			public List<VisualElement> heads;

			public List<VisualElement> tails;

			public int[] minDepths;

			public int[] maxDepths;

			public uint dirtyID;

			public void EnsureFits(int maxDepth)
			{
				while (heads.Count <= maxDepth)
				{
					heads.Add(null);
					tails.Add(null);
				}
			}

			public void RegisterDirty(VisualElement ve, RenderDataDirtyTypes dirtyTypes, RenderDataDirtyTypeClasses dirtyTypeClass)
			{
				Debug.Assert(dirtyTypes != RenderDataDirtyTypes.None);
				int hierarchyDepth = ve.renderChainData.hierarchyDepth;
				minDepths[(int)dirtyTypeClass] = ((hierarchyDepth < minDepths[(int)dirtyTypeClass]) ? hierarchyDepth : minDepths[(int)dirtyTypeClass]);
				maxDepths[(int)dirtyTypeClass] = ((hierarchyDepth > maxDepths[(int)dirtyTypeClass]) ? hierarchyDepth : maxDepths[(int)dirtyTypeClass]);
				if (ve.renderChainData.dirtiedValues != RenderDataDirtyTypes.None)
				{
					ve.renderChainData.dirtiedValues |= dirtyTypes;
					return;
				}
				ve.renderChainData.dirtiedValues = dirtyTypes;
				if (tails[hierarchyDepth] != null)
				{
					tails[hierarchyDepth].renderChainData.nextDirty = ve;
					ve.renderChainData.prevDirty = tails[hierarchyDepth];
					tails[hierarchyDepth] = ve;
				}
				else
				{
					List<VisualElement> list = heads;
					VisualElement value = (tails[hierarchyDepth] = ve);
					list[hierarchyDepth] = value;
				}
			}

			public void ClearDirty(VisualElement ve, RenderDataDirtyTypes dirtyTypesInverse)
			{
				Debug.Assert(ve.renderChainData.dirtiedValues != RenderDataDirtyTypes.None);
				ve.renderChainData.dirtiedValues &= dirtyTypesInverse;
				if (ve.renderChainData.dirtiedValues == RenderDataDirtyTypes.None)
				{
					if (ve.renderChainData.prevDirty != null)
					{
						ve.renderChainData.prevDirty.renderChainData.nextDirty = ve.renderChainData.nextDirty;
					}
					if (ve.renderChainData.nextDirty != null)
					{
						ve.renderChainData.nextDirty.renderChainData.prevDirty = ve.renderChainData.prevDirty;
					}
					if (tails[ve.renderChainData.hierarchyDepth] == ve)
					{
						Debug.Assert(ve.renderChainData.nextDirty == null);
						tails[ve.renderChainData.hierarchyDepth] = ve.renderChainData.prevDirty;
					}
					if (heads[ve.renderChainData.hierarchyDepth] == ve)
					{
						Debug.Assert(ve.renderChainData.prevDirty == null);
						heads[ve.renderChainData.hierarchyDepth] = ve.renderChainData.nextDirty;
					}
					ve.renderChainData.prevDirty = (ve.renderChainData.nextDirty = null);
				}
			}

			public void Reset()
			{
				for (int i = 0; i < minDepths.Length; i++)
				{
					minDepths[i] = int.MaxValue;
					maxDepths[i] = int.MinValue;
				}
			}
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct RenderChainStaticIndexAllocator
		{
			private static List<RenderChain> renderChains = new List<RenderChain>(4);

			public static int AllocateIndex(RenderChain renderChain)
			{
				int num = renderChains.IndexOf(null);
				if (num >= 0)
				{
					renderChains[num] = renderChain;
				}
				else
				{
					num = renderChains.Count;
					renderChains.Add(renderChain);
				}
				return num;
			}

			public static void FreeIndex(int index)
			{
				renderChains[index] = null;
			}

			public static RenderChain AccessIndex(int index)
			{
				return renderChains[index];
			}
		}

		private struct RenderNodeData
		{
			public Material standardMaterial;

			public Material initialMaterial;

			public MaterialPropertyBlock matPropBlock;

			public RenderChainCommand firstCommand;

			public UIRenderDevice device;

			public Texture vectorAtlas;

			public Texture shaderInfoAtlas;

			public float dpiScale;

			public NativeSlice<Transform3x4> transformConstants;

			public NativeSlice<Vector4> clipRectConstants;
		}

		private RenderChainCommand m_FirstCommand;

		private DepthOrderedDirtyTracking m_DirtyTracker;

		private LinkedPool<RenderChainCommand> m_CommandPool = new LinkedPool<RenderChainCommand>(() => new RenderChainCommand(), delegate
		{
		});

		private BasicNodePool<TextureEntry> m_TexturePool = new BasicNodePool<TextureEntry>();

		private List<RenderNodeData> m_RenderNodesData = new List<RenderNodeData>();

		private Shader m_DefaultShader;

		private Shader m_DefaultWorldSpaceShader;

		private Material m_DefaultMat;

		private Material m_DefaultWorldSpaceMat;

		private bool m_BlockDirtyRegistration;

		private int m_StaticIndex = -1;

		private int m_ActiveRenderNodes = 0;

		private int m_CustomMaterialCommands = 0;

		private ChainBuilderStats m_Stats;

		private uint m_StatsElementsAdded;

		private uint m_StatsElementsRemoved;

		private TextureRegistry m_TextureRegistry = TextureRegistry.instance;

		private static ProfilerMarker s_MarkerProcess;

		private static ProfilerMarker s_MarkerClipProcessing;

		private static ProfilerMarker s_MarkerOpacityProcessing;

		private static ProfilerMarker s_MarkerColorsProcessing;

		private static ProfilerMarker s_MarkerTransformProcessing;

		private static ProfilerMarker s_MarkerVisualsProcessing;

		private static ProfilerMarker s_MarkerTextRegen;

		internal static Action OnPreRender;

		internal UIRVEShaderInfoAllocator shaderInfoAllocator;

		internal RenderChainCommand firstCommand => m_FirstCommand;

		public OpacityIdAccelerator opacityIdAccelerator { get; private set; }

		protected bool disposed { get; private set; }

		internal ChainBuilderStats stats => m_Stats;

		internal BaseVisualElementPanel panel { get; private set; }

		internal UIRenderDevice device { get; private set; }

		internal AtlasBase atlas { get; private set; }

		internal VectorImageManager vectorImageManager { get; private set; }

		internal TempAllocator<Vertex> vertsPool { get; private set; }

		internal TempAllocator<ushort> indicesPool { get; private set; }

		internal JobManager jobManager { get; private set; }

		internal UIRStylePainter painter { get; private set; }

		internal bool drawStats { get; set; }

		internal bool drawInCameras { get; private set; }

		internal Shader defaultShader
		{
			get
			{
				return m_DefaultShader;
			}
			set
			{
				if (!(m_DefaultShader == value))
				{
					m_DefaultShader = value;
					UIRUtility.Destroy(m_DefaultMat);
					m_DefaultMat = null;
				}
			}
		}

		internal Shader defaultWorldSpaceShader
		{
			get
			{
				return m_DefaultWorldSpaceShader;
			}
			set
			{
				if (!(m_DefaultWorldSpaceShader == value))
				{
					m_DefaultWorldSpaceShader = value;
					UIRUtility.Destroy(m_DefaultWorldSpaceMat);
					m_DefaultWorldSpaceMat = null;
				}
			}
		}

		static RenderChain()
		{
			s_MarkerProcess = new ProfilerMarker("RenderChain.Process");
			s_MarkerClipProcessing = new ProfilerMarker("RenderChain.UpdateClips");
			s_MarkerOpacityProcessing = new ProfilerMarker("RenderChain.UpdateOpacity");
			s_MarkerColorsProcessing = new ProfilerMarker("RenderChain.UpdateColors");
			s_MarkerTransformProcessing = new ProfilerMarker("RenderChain.UpdateTransforms");
			s_MarkerVisualsProcessing = new ProfilerMarker("RenderChain.UpdateVisuals");
			s_MarkerTextRegen = new ProfilerMarker("RenderChain.RegenText");
			OnPreRender = null;
			Utility.RegisterIntermediateRenderers += OnRegisterIntermediateRenderers;
			Utility.RenderNodeExecute += OnRenderNodeExecute;
		}

		public RenderChain(BaseVisualElementPanel panel)
		{
			Constructor(panel, new UIRenderDevice(), panel.atlas, new VectorImageManager(panel.atlas));
		}

		protected RenderChain(BaseVisualElementPanel panel, UIRenderDevice device, AtlasBase atlas, VectorImageManager vectorImageManager)
		{
			Constructor(panel, device, atlas, vectorImageManager);
		}

		private void Constructor(BaseVisualElementPanel panelObj, UIRenderDevice deviceObj, AtlasBase atlas, VectorImageManager vectorImageMan)
		{
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
			}
			m_DirtyTracker.heads = new List<VisualElement>(8);
			m_DirtyTracker.tails = new List<VisualElement>(8);
			m_DirtyTracker.minDepths = new int[5];
			m_DirtyTracker.maxDepths = new int[5];
			m_DirtyTracker.Reset();
			if (m_RenderNodesData.Count < 1)
			{
				m_RenderNodesData.Add(new RenderNodeData
				{
					matPropBlock = new MaterialPropertyBlock()
				});
			}
			panel = panelObj;
			device = deviceObj;
			this.atlas = atlas;
			vectorImageManager = vectorImageMan;
			vertsPool = new TempAllocator<Vertex>(8192, 2048, 65536);
			indicesPool = new TempAllocator<ushort>(16384, 4096, 131072);
			jobManager = new JobManager();
			shaderInfoAllocator.Construct();
			opacityIdAccelerator = new OpacityIdAccelerator();
			painter = new UIRStylePainter(this);
			if (panel is BaseRuntimePanel { drawToCameras: not false })
			{
				drawInCameras = true;
				m_StaticIndex = RenderChainStaticIndexAllocator.AllocateIndex(this);
			}
		}

		private void Destructor()
		{
			if (m_StaticIndex >= 0)
			{
				RenderChainStaticIndexAllocator.FreeIndex(m_StaticIndex);
			}
			m_StaticIndex = -1;
			for (VisualElement visualElement = GetFirstElementInPanel(m_FirstCommand?.owner); visualElement != null; visualElement = visualElement.renderChainData.next)
			{
				ResetTextures(visualElement);
			}
			UIRUtility.Destroy(m_DefaultMat);
			UIRUtility.Destroy(m_DefaultWorldSpaceMat);
			m_DefaultMat = (m_DefaultWorldSpaceMat = null);
			vertsPool.Dispose();
			indicesPool.Dispose();
			jobManager.Dispose();
			vectorImageManager?.Dispose();
			shaderInfoAllocator.Dispose();
			device?.Dispose();
			opacityIdAccelerator?.Dispose();
			if (painter != null)
			{
				if (painter.meshGenerationContext.hasPainter2D)
				{
					painter.meshGenerationContext.painter2D.Dispose();
				}
				painter = null;
			}
			atlas = null;
			shaderInfoAllocator = default(UIRVEShaderInfoAllocator);
			device = null;
			m_ActiveRenderNodes = 0;
			m_RenderNodesData.Clear();
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (disposing)
				{
					Destructor();
				}
				disposed = true;
			}
		}

		public void ProcessChanges()
		{
			m_Stats = default(ChainBuilderStats);
			m_Stats.elementsAdded += m_StatsElementsAdded;
			m_Stats.elementsRemoved += m_StatsElementsRemoved;
			m_StatsElementsAdded = (m_StatsElementsRemoved = 0u);
			m_DirtyTracker.dirtyID++;
			int num = 0;
			RenderDataDirtyTypes renderDataDirtyTypes = RenderDataDirtyTypes.Clipping | RenderDataDirtyTypes.ClippingHierarchy;
			RenderDataDirtyTypes dirtyTypesInverse = ~renderDataDirtyTypes;
			for (int i = m_DirtyTracker.minDepths[num]; i <= m_DirtyTracker.maxDepths[num]; i++)
			{
				VisualElement visualElement = m_DirtyTracker.heads[i];
				while (visualElement != null)
				{
					VisualElement nextDirty = visualElement.renderChainData.nextDirty;
					if ((visualElement.renderChainData.dirtiedValues & renderDataDirtyTypes) != RenderDataDirtyTypes.None)
					{
						if (visualElement.renderChainData.isInChain && visualElement.renderChainData.dirtyID != m_DirtyTracker.dirtyID)
						{
							RenderEvents.ProcessOnClippingChanged(this, visualElement, m_DirtyTracker.dirtyID, ref m_Stats);
						}
						m_DirtyTracker.ClearDirty(visualElement, dirtyTypesInverse);
					}
					visualElement = nextDirty;
					m_Stats.dirtyProcessed++;
				}
			}
			m_DirtyTracker.dirtyID++;
			num = 1;
			renderDataDirtyTypes = RenderDataDirtyTypes.Opacity | RenderDataDirtyTypes.OpacityHierarchy;
			dirtyTypesInverse = ~renderDataDirtyTypes;
			for (int j = m_DirtyTracker.minDepths[num]; j <= m_DirtyTracker.maxDepths[num]; j++)
			{
				VisualElement visualElement2 = m_DirtyTracker.heads[j];
				while (visualElement2 != null)
				{
					VisualElement nextDirty2 = visualElement2.renderChainData.nextDirty;
					if ((visualElement2.renderChainData.dirtiedValues & renderDataDirtyTypes) != RenderDataDirtyTypes.None)
					{
						if (visualElement2.renderChainData.isInChain && visualElement2.renderChainData.dirtyID != m_DirtyTracker.dirtyID)
						{
							RenderEvents.ProcessOnOpacityChanged(this, visualElement2, m_DirtyTracker.dirtyID, ref m_Stats);
						}
						m_DirtyTracker.ClearDirty(visualElement2, dirtyTypesInverse);
					}
					visualElement2 = nextDirty2;
					m_Stats.dirtyProcessed++;
				}
			}
			m_DirtyTracker.dirtyID++;
			num = 2;
			renderDataDirtyTypes = RenderDataDirtyTypes.Color;
			dirtyTypesInverse = ~renderDataDirtyTypes;
			for (int k = m_DirtyTracker.minDepths[num]; k <= m_DirtyTracker.maxDepths[num]; k++)
			{
				VisualElement visualElement3 = m_DirtyTracker.heads[k];
				while (visualElement3 != null)
				{
					VisualElement nextDirty3 = visualElement3.renderChainData.nextDirty;
					if ((visualElement3.renderChainData.dirtiedValues & renderDataDirtyTypes) != RenderDataDirtyTypes.None)
					{
						if (visualElement3.renderChainData.isInChain && visualElement3.renderChainData.dirtyID != m_DirtyTracker.dirtyID)
						{
							RenderEvents.ProcessOnColorChanged(this, visualElement3, m_DirtyTracker.dirtyID, ref m_Stats);
						}
						m_DirtyTracker.ClearDirty(visualElement3, dirtyTypesInverse);
					}
					visualElement3 = nextDirty3;
					m_Stats.dirtyProcessed++;
				}
			}
			m_DirtyTracker.dirtyID++;
			num = 3;
			renderDataDirtyTypes = RenderDataDirtyTypes.Transform | RenderDataDirtyTypes.ClipRectSize;
			dirtyTypesInverse = ~renderDataDirtyTypes;
			for (int l = m_DirtyTracker.minDepths[num]; l <= m_DirtyTracker.maxDepths[num]; l++)
			{
				VisualElement visualElement4 = m_DirtyTracker.heads[l];
				while (visualElement4 != null)
				{
					VisualElement nextDirty4 = visualElement4.renderChainData.nextDirty;
					if ((visualElement4.renderChainData.dirtiedValues & renderDataDirtyTypes) != RenderDataDirtyTypes.None)
					{
						if (visualElement4.renderChainData.isInChain && visualElement4.renderChainData.dirtyID != m_DirtyTracker.dirtyID)
						{
							RenderEvents.ProcessOnTransformOrSizeChanged(this, visualElement4, m_DirtyTracker.dirtyID, ref m_Stats);
						}
						m_DirtyTracker.ClearDirty(visualElement4, dirtyTypesInverse);
					}
					visualElement4 = nextDirty4;
					m_Stats.dirtyProcessed++;
				}
			}
			jobManager.CompleteNudgeJobs();
			m_BlockDirtyRegistration = true;
			m_DirtyTracker.dirtyID++;
			num = 4;
			renderDataDirtyTypes = RenderDataDirtyTypes.AllVisuals;
			dirtyTypesInverse = ~renderDataDirtyTypes;
			for (int m = m_DirtyTracker.minDepths[num]; m <= m_DirtyTracker.maxDepths[num]; m++)
			{
				VisualElement visualElement5 = m_DirtyTracker.heads[m];
				while (visualElement5 != null)
				{
					VisualElement nextDirty5 = visualElement5.renderChainData.nextDirty;
					if ((visualElement5.renderChainData.dirtiedValues & renderDataDirtyTypes) != RenderDataDirtyTypes.None)
					{
						if (visualElement5.renderChainData.isInChain && visualElement5.renderChainData.dirtyID != m_DirtyTracker.dirtyID)
						{
							RenderEvents.ProcessOnVisualsChanged(this, visualElement5, m_DirtyTracker.dirtyID, ref m_Stats);
						}
						m_DirtyTracker.ClearDirty(visualElement5, dirtyTypesInverse);
					}
					visualElement5 = nextDirty5;
					m_Stats.dirtyProcessed++;
				}
			}
			jobManager.CompleteConvertMeshJobs();
			jobManager.CompleteClosingMeshJobs();
			opacityIdAccelerator.CompleteJobs();
			m_BlockDirtyRegistration = false;
			vertsPool.Reset();
			indicesPool.Reset();
			m_DirtyTracker.Reset();
			atlas?.InvokeUpdateDynamicTextures(panel);
			vectorImageManager?.Commit();
			shaderInfoAllocator.IssuePendingStorageChanges();
			device?.OnFrameRenderingBegin();
		}

		public void Render()
		{
			Material standardMaterial = GetStandardMaterial();
			panel.InvokeUpdateMaterial(standardMaterial);
			Exception immediateException = null;
			if (m_FirstCommand != null && !drawInCameras)
			{
				Rect layout = panel.visualTree.layout;
				standardMaterial?.SetPass(0);
				Matrix4x4 mat = ProjectionUtils.Ortho(layout.xMin, layout.xMax, layout.yMax, layout.yMin, -0.001f, 1.001f);
				GL.LoadProjectionMatrix(mat);
				GL.modelview = Matrix4x4.identity;
				device.EvaluateChain(m_FirstCommand, standardMaterial, standardMaterial, vectorImageManager?.atlas, shaderInfoAllocator.atlas, panel.scaledPixelsPerPoint, shaderInfoAllocator.transformConstants, shaderInfoAllocator.clipRectConstants, m_RenderNodesData[0].matPropBlock, allowMaterialChange: true, ref immediateException);
			}
			if (immediateException != null)
			{
				if (GUIUtility.IsExitGUIException(immediateException))
				{
					throw immediateException;
				}
				throw new ImmediateModeException(immediateException);
			}
			if (drawStats)
			{
				DrawStats();
			}
		}

		public void UIEOnChildAdded(VisualElement ve)
		{
			VisualElement parent = ve.hierarchy.parent;
			int index = parent?.hierarchy.IndexOf(ve) ?? 0;
			if (m_BlockDirtyRegistration)
			{
				throw new InvalidOperationException("VisualElements cannot be added to an active visual tree during generateVisualContent callback execution nor during visual tree rendering");
			}
			if (parent == null || parent.renderChainData.isInChain)
			{
				uint num = RenderEvents.DepthFirstOnChildAdded(this, parent, ve, index, resetState: true);
				Debug.Assert(ve.renderChainData.isInChain);
				Debug.Assert(ve.panel == panel);
				UIEOnClippingChanged(ve, hierarchical: true);
				UIEOnOpacityChanged(ve);
				UIEOnVisualsChanged(ve, hierarchical: true);
				m_StatsElementsAdded += num;
			}
		}

		public void UIEOnChildrenReordered(VisualElement ve)
		{
			if (m_BlockDirtyRegistration)
			{
				throw new InvalidOperationException("VisualElements cannot be moved under an active visual tree during generateVisualContent callback execution nor during visual tree rendering");
			}
			int childCount = ve.hierarchy.childCount;
			for (int i = 0; i < childCount; i++)
			{
				RenderEvents.DepthFirstOnChildRemoving(this, ve.hierarchy[i]);
			}
			for (int j = 0; j < childCount; j++)
			{
				RenderEvents.DepthFirstOnChildAdded(this, ve, ve.hierarchy[j], j, resetState: false);
			}
			UIEOnClippingChanged(ve, hierarchical: true);
			UIEOnOpacityChanged(ve, hierarchical: true);
			UIEOnVisualsChanged(ve, hierarchical: true);
		}

		public void UIEOnChildRemoving(VisualElement ve)
		{
			if (m_BlockDirtyRegistration)
			{
				throw new InvalidOperationException("VisualElements cannot be removed from an active visual tree during generateVisualContent callback execution nor during visual tree rendering");
			}
			m_StatsElementsRemoved += RenderEvents.DepthFirstOnChildRemoving(this, ve);
			Debug.Assert(!ve.renderChainData.isInChain);
		}

		public void UIEOnRenderHintsChanged(VisualElement ve)
		{
			if (ve.renderChainData.isInChain)
			{
				if (m_BlockDirtyRegistration)
				{
					throw new InvalidOperationException("Render Hints cannot change under an active visual tree during generateVisualContent callback execution nor during visual tree rendering");
				}
				if ((ve.renderHints & RenderHints.DirtyAll) == RenderHints.DirtyDynamicColor)
				{
					UIEOnVisualsChanged(ve, hierarchical: false);
				}
				else
				{
					UIEOnChildRemoving(ve);
					UIEOnChildAdded(ve);
				}
				ve.MarkRenderHintsClean();
			}
		}

		public void UIEOnClippingChanged(VisualElement ve, bool hierarchical)
		{
			if (ve.renderChainData.isInChain)
			{
				if (m_BlockDirtyRegistration)
				{
					throw new InvalidOperationException("VisualElements cannot change clipping state under an active visual tree during generateVisualContent callback execution nor during visual tree rendering");
				}
				m_DirtyTracker.RegisterDirty(ve, (RenderDataDirtyTypes)(4 | (hierarchical ? 8 : 0)), RenderDataDirtyTypeClasses.Clipping);
			}
		}

		public void UIEOnOpacityChanged(VisualElement ve, bool hierarchical = false)
		{
			if (ve.renderChainData.isInChain)
			{
				if (m_BlockDirtyRegistration)
				{
					throw new InvalidOperationException("VisualElements cannot change opacity under an active visual tree during generateVisualContent callback execution nor during visual tree rendering");
				}
				m_DirtyTracker.RegisterDirty(ve, (RenderDataDirtyTypes)(0x80 | (hierarchical ? 256 : 0)), RenderDataDirtyTypeClasses.Opacity);
			}
		}

		public void UIEOnColorChanged(VisualElement ve)
		{
			if (ve.renderChainData.isInChain)
			{
				if (m_BlockDirtyRegistration)
				{
					throw new InvalidOperationException("VisualElements cannot change background color under an active visual tree during generateVisualContent callback execution nor during visual tree rendering");
				}
				m_DirtyTracker.RegisterDirty(ve, RenderDataDirtyTypes.Color, RenderDataDirtyTypeClasses.Color);
			}
		}

		public void UIEOnTransformOrSizeChanged(VisualElement ve, bool transformChanged, bool clipRectSizeChanged)
		{
			if (ve.renderChainData.isInChain)
			{
				if (m_BlockDirtyRegistration)
				{
					throw new InvalidOperationException("VisualElements cannot change size or transform under an active visual tree during generateVisualContent callback execution nor during visual tree rendering");
				}
				RenderDataDirtyTypes dirtyTypes = (RenderDataDirtyTypes)((transformChanged ? 1 : 0) | (clipRectSizeChanged ? 2 : 0));
				m_DirtyTracker.RegisterDirty(ve, dirtyTypes, RenderDataDirtyTypeClasses.TransformSize);
			}
		}

		public void UIEOnVisualsChanged(VisualElement ve, bool hierarchical)
		{
			if (ve.renderChainData.isInChain)
			{
				if (m_BlockDirtyRegistration)
				{
					throw new InvalidOperationException("VisualElements cannot be marked for dirty repaint under an active visual tree during generateVisualContent callback execution nor during visual tree rendering");
				}
				m_DirtyTracker.RegisterDirty(ve, (RenderDataDirtyTypes)(0x10 | (hierarchical ? 32 : 0)), RenderDataDirtyTypeClasses.Visuals);
			}
		}

		public void UIEOnOpacityIdChanged(VisualElement ve)
		{
			if (ve.renderChainData.isInChain)
			{
				if (m_BlockDirtyRegistration)
				{
					throw new InvalidOperationException("VisualElements cannot for opacity id change under an active visual tree during generateVisualContent callback execution nor during visual tree rendering");
				}
				m_DirtyTracker.RegisterDirty(ve, RenderDataDirtyTypes.VisualsOpacityId, RenderDataDirtyTypeClasses.Visuals);
			}
		}

		internal Material GetStandardMaterial()
		{
			if (m_DefaultMat == null && m_DefaultShader != null)
			{
				m_DefaultMat = new Material(m_DefaultShader);
				m_DefaultMat.hideFlags |= HideFlags.DontSaveInEditor;
			}
			return m_DefaultMat;
		}

		internal Material GetStandardWorldSpaceMaterial()
		{
			if (m_DefaultWorldSpaceMat == null && m_DefaultWorldSpaceShader != null)
			{
				m_DefaultWorldSpaceMat = new Material(m_DefaultWorldSpaceShader);
				m_DefaultWorldSpaceMat.hideFlags |= HideFlags.DontSaveInEditor;
			}
			return m_DefaultWorldSpaceMat;
		}

		internal void EnsureFitsDepth(int depth)
		{
			m_DirtyTracker.EnsureFits(depth);
		}

		internal void ChildWillBeRemoved(VisualElement ve)
		{
			if (ve.renderChainData.dirtiedValues != RenderDataDirtyTypes.None)
			{
				m_DirtyTracker.ClearDirty(ve, ~ve.renderChainData.dirtiedValues);
			}
			Debug.Assert(ve.renderChainData.dirtiedValues == RenderDataDirtyTypes.None);
			Debug.Assert(ve.renderChainData.prevDirty == null);
			Debug.Assert(ve.renderChainData.nextDirty == null);
		}

		internal RenderChainCommand AllocCommand()
		{
			RenderChainCommand renderChainCommand = m_CommandPool.Get();
			renderChainCommand.Reset();
			return renderChainCommand;
		}

		internal void FreeCommand(RenderChainCommand cmd)
		{
			if (cmd.state.material != null)
			{
				m_CustomMaterialCommands--;
			}
			cmd.Reset();
			m_CommandPool.Return(cmd);
		}

		internal void OnRenderCommandAdded(RenderChainCommand command)
		{
			if (command.prev == null)
			{
				m_FirstCommand = command;
			}
			if (command.state.material != null)
			{
				m_CustomMaterialCommands++;
			}
		}

		internal void OnRenderCommandsRemoved(RenderChainCommand firstCommand, RenderChainCommand lastCommand)
		{
			if (firstCommand.prev == null)
			{
				m_FirstCommand = lastCommand.next;
			}
		}

		private unsafe static RenderNodeData AccessRenderNodeData(IntPtr obj)
		{
			int* ptr = (int*)obj.ToPointer();
			RenderChain renderChain = RenderChainStaticIndexAllocator.AccessIndex(*ptr);
			return renderChain.m_RenderNodesData[ptr[1]];
		}

		private static void OnRenderNodeExecute(IntPtr obj)
		{
			RenderNodeData renderNodeData = AccessRenderNodeData(obj);
			Exception immediateException = null;
			renderNodeData.device.EvaluateChain(renderNodeData.firstCommand, renderNodeData.initialMaterial, renderNodeData.standardMaterial, renderNodeData.vectorAtlas, renderNodeData.shaderInfoAtlas, renderNodeData.dpiScale, renderNodeData.transformConstants, renderNodeData.clipRectConstants, renderNodeData.matPropBlock, allowMaterialChange: false, ref immediateException);
		}

		private static void OnRegisterIntermediateRenderers(Camera camera)
		{
			int num = 0;
			Dictionary<int, Panel>.Enumerator panelsIterator = UIElementsUtility.GetPanelsIterator();
			while (panelsIterator.MoveNext())
			{
				Panel value = panelsIterator.Current.Value;
				RenderChain renderChain = (value.GetUpdater(VisualTreeUpdatePhase.Repaint) as UIRRepaintUpdater)?.renderChain;
				if (renderChain == null || renderChain.m_StaticIndex < 0 || renderChain.m_FirstCommand == null)
				{
					continue;
				}
				BaseRuntimePanel baseRuntimePanel = (BaseRuntimePanel)value;
				Material standardWorldSpaceMaterial = renderChain.GetStandardWorldSpaceMaterial();
				RenderNodeData rnd = new RenderNodeData
				{
					device = renderChain.device,
					standardMaterial = standardWorldSpaceMaterial,
					vectorAtlas = renderChain.vectorImageManager?.atlas,
					shaderInfoAtlas = renderChain.shaderInfoAllocator.atlas,
					dpiScale = baseRuntimePanel.scaledPixelsPerPoint,
					transformConstants = renderChain.shaderInfoAllocator.transformConstants,
					clipRectConstants = renderChain.shaderInfoAllocator.clipRectConstants
				};
				if (renderChain.m_CustomMaterialCommands == 0)
				{
					rnd.initialMaterial = standardWorldSpaceMaterial;
					rnd.firstCommand = renderChain.m_FirstCommand;
					OnRegisterIntermediateRendererMat(baseRuntimePanel, renderChain, ref rnd, camera, num++);
					continue;
				}
				Material material = null;
				RenderChainCommand next = renderChain.m_FirstCommand;
				RenderChainCommand renderChainCommand = next;
				while (next != null)
				{
					if (next.type != CommandType.Draw)
					{
						next = next.next;
						continue;
					}
					Material material2 = ((next.state.material == null) ? standardWorldSpaceMaterial : next.state.material);
					if (material2 != material)
					{
						if (material != null)
						{
							rnd.initialMaterial = material;
							rnd.firstCommand = renderChainCommand;
							OnRegisterIntermediateRendererMat(baseRuntimePanel, renderChain, ref rnd, camera, num++);
							renderChainCommand = next;
						}
						material = material2;
					}
					next = next.next;
				}
				if (renderChainCommand != null)
				{
					rnd.initialMaterial = material;
					rnd.firstCommand = renderChainCommand;
					OnRegisterIntermediateRendererMat(baseRuntimePanel, renderChain, ref rnd, camera, num++);
				}
			}
		}

		private unsafe static void OnRegisterIntermediateRendererMat(BaseRuntimePanel rtp, RenderChain renderChain, ref RenderNodeData rnd, Camera camera, int sameDistanceSortPriority)
		{
			int num = renderChain.m_ActiveRenderNodes++;
			if (num < renderChain.m_RenderNodesData.Count)
			{
				rnd.matPropBlock = renderChain.m_RenderNodesData[num].matPropBlock;
				renderChain.m_RenderNodesData[num] = rnd;
			}
			else
			{
				rnd.matPropBlock = new MaterialPropertyBlock();
				num = renderChain.m_RenderNodesData.Count;
				renderChain.m_RenderNodesData.Add(rnd);
			}
			int* ptr = stackalloc int[2];
			*ptr = renderChain.m_StaticIndex;
			ptr[1] = num;
			Utility.RegisterIntermediateRenderer(camera, rnd.initialMaterial, rtp.panelToWorld, new Bounds(Vector3.zero, new Vector3(float.MaxValue, float.MaxValue, float.MaxValue)), 3, 0, receiveShadows: false, sameDistanceSortPriority, (ulong)camera.cullingMask, 2, new IntPtr(ptr), 8);
		}

		internal void RepaintTexturedElements()
		{
			for (VisualElement visualElement = GetFirstElementInPanel(m_FirstCommand?.owner); visualElement != null; visualElement = visualElement.renderChainData.next)
			{
				if (visualElement.renderChainData.textures != null)
				{
					UIEOnVisualsChanged(visualElement, hierarchical: false);
				}
			}
			UIEOnOpacityChanged(panel.visualTree);
		}

		public void AppendTexture(VisualElement ve, Texture src, TextureId id, bool isAtlas)
		{
			BasicNode<TextureEntry> basicNode = m_TexturePool.Get();
			basicNode.data.source = src;
			basicNode.data.actual = id;
			basicNode.data.replaced = isAtlas;
			basicNode.AppendTo(ref ve.renderChainData.textures);
		}

		public void ResetTextures(VisualElement ve)
		{
			AtlasBase atlasBase = atlas;
			TextureRegistry textureRegistry = m_TextureRegistry;
			BasicNodePool<TextureEntry> texturePool = m_TexturePool;
			BasicNode<TextureEntry> basicNode = ve.renderChainData.textures;
			ve.renderChainData.textures = null;
			while (basicNode != null)
			{
				BasicNode<TextureEntry> next = basicNode.next;
				if (basicNode.data.replaced)
				{
					atlasBase.ReturnAtlas(ve, basicNode.data.source as Texture2D, basicNode.data.actual);
				}
				else
				{
					textureRegistry.Release(basicNode.data.actual);
				}
				texturePool.Return(basicNode);
				basicNode = next;
			}
		}

		private void DrawStats()
		{
			bool flag = device != null;
			float num = 12f;
			Rect position = new Rect(30f, 60f, 1000f, 100f);
			GUI.Box(new Rect(20f, 40f, 200f, flag ? 380 : 256), "UI Toolkit Draw Stats");
			GUI.Label(position, "Elements added\t: " + m_Stats.elementsAdded);
			position.y += num;
			GUI.Label(position, "Elements removed\t: " + m_Stats.elementsRemoved);
			position.y += num;
			GUI.Label(position, "Mesh allocs allocated\t: " + m_Stats.newMeshAllocations);
			position.y += num;
			GUI.Label(position, "Mesh allocs updated\t: " + m_Stats.updatedMeshAllocations);
			position.y += num;
			GUI.Label(position, "Clip update roots\t: " + m_Stats.recursiveClipUpdates);
			position.y += num;
			GUI.Label(position, "Clip update total\t: " + m_Stats.recursiveClipUpdatesExpanded);
			position.y += num;
			GUI.Label(position, "Opacity update roots\t: " + m_Stats.recursiveOpacityUpdates);
			position.y += num;
			GUI.Label(position, "Opacity update total\t: " + m_Stats.recursiveOpacityUpdatesExpanded);
			position.y += num;
			GUI.Label(position, "Opacity ID update\t: " + m_Stats.opacityIdUpdates);
			position.y += num;
			GUI.Label(position, "Xform update roots\t: " + m_Stats.recursiveTransformUpdates);
			position.y += num;
			GUI.Label(position, "Xform update total\t: " + m_Stats.recursiveTransformUpdatesExpanded);
			position.y += num;
			GUI.Label(position, "Xformed by bone\t: " + m_Stats.boneTransformed);
			position.y += num;
			GUI.Label(position, "Xformed by skipping\t: " + m_Stats.skipTransformed);
			position.y += num;
			GUI.Label(position, "Xformed by nudging\t: " + m_Stats.nudgeTransformed);
			position.y += num;
			GUI.Label(position, "Xformed by repaint\t: " + m_Stats.visualUpdateTransformed);
			position.y += num;
			GUI.Label(position, "Visual update roots\t: " + m_Stats.recursiveVisualUpdates);
			position.y += num;
			GUI.Label(position, "Visual update total\t: " + m_Stats.recursiveVisualUpdatesExpanded);
			position.y += num;
			GUI.Label(position, "Visual update flats\t: " + m_Stats.nonRecursiveVisualUpdates);
			position.y += num;
			GUI.Label(position, "Dirty processed\t: " + m_Stats.dirtyProcessed);
			position.y += num;
			GUI.Label(position, "Group-xform updates\t: " + m_Stats.groupTransformElementsChanged);
			position.y += num;
			if (flag)
			{
				position.y += num;
				UIRenderDevice.DrawStatistics drawStatistics = device.GatherDrawStatistics();
				GUI.Label(position, "Frame index\t: " + drawStatistics.currentFrameIndex);
				position.y += num;
				GUI.Label(position, "Command count\t: " + drawStatistics.commandCount);
				position.y += num;
				GUI.Label(position, "Draw commands\t: " + drawStatistics.drawCommandCount);
				position.y += num;
				GUI.Label(position, "Draw ranges\t: " + drawStatistics.drawRangeCount);
				position.y += num;
				GUI.Label(position, "Draw range calls\t: " + drawStatistics.drawRangeCallCount);
				position.y += num;
				GUI.Label(position, "Material sets\t: " + drawStatistics.materialSetCount);
				position.y += num;
				GUI.Label(position, "Stencil changes\t: " + drawStatistics.stencilRefChanges);
				position.y += num;
				GUI.Label(position, "Immediate draws\t: " + drawStatistics.immediateDraws);
				position.y += num;
				GUI.Label(position, "Total triangles\t: " + drawStatistics.totalIndices / 3);
				position.y += num;
			}
		}

		private static VisualElement GetFirstElementInPanel(VisualElement ve)
		{
			while (ve != null)
			{
				VisualElement prev = ve.renderChainData.prev;
				if (prev == null || !prev.renderChainData.isInChain)
				{
					break;
				}
				ve = ve.renderChainData.prev;
			}
			return ve;
		}
	}
	[Flags]
	internal enum RenderDataDirtyTypes
	{
		None = 0,
		Transform = 1,
		ClipRectSize = 2,
		Clipping = 4,
		ClippingHierarchy = 8,
		Visuals = 0x10,
		VisualsHierarchy = 0x20,
		VisualsOpacityId = 0x40,
		Opacity = 0x80,
		OpacityHierarchy = 0x100,
		Color = 0x200,
		AllVisuals = 0x70
	}
	internal enum RenderDataDirtyTypeClasses
	{
		Clipping,
		Opacity,
		Color,
		TransformSize,
		Visuals,
		Count
	}
	[Flags]
	internal enum RenderDataFlags
	{
		IsIgnoringDynamicColorHint = 1
	}
	internal struct RenderChainVEData
	{
		internal VisualElement prev;

		internal VisualElement next;

		internal VisualElement groupTransformAncestor;

		internal VisualElement boneTransformAncestor;

		internal VisualElement prevDirty;

		internal VisualElement nextDirty;

		internal RenderDataFlags flags;

		internal int hierarchyDepth;

		internal RenderDataDirtyTypes dirtiedValues;

		internal uint dirtyID;

		internal RenderChainCommand firstCommand;

		internal RenderChainCommand lastCommand;

		internal RenderChainCommand firstClosingCommand;

		internal RenderChainCommand lastClosingCommand;

		internal bool isInChain;

		internal bool isHierarchyHidden;

		internal bool localFlipsWinding;

		internal bool localTransformScaleZero;

		internal bool worldFlipsWinding;

		public bool worldTransformScaleZero;

		internal ClipMethod clipMethod;

		internal int childrenStencilRef;

		internal int childrenMaskDepth;

		internal bool disableNudging;

		internal MeshHandle data;

		internal MeshHandle closingData;

		internal Matrix4x4 verticesSpace;

		internal int displacementUVStart;

		internal int displacementUVEnd;

		internal BMPAlloc transformID;

		internal BMPAlloc clipRectID;

		internal BMPAlloc opacityID;

		internal BMPAlloc textCoreSettingsID;

		internal BMPAlloc colorID;

		internal BMPAlloc backgroundColorID;

		internal BMPAlloc borderLeftColorID;

		internal BMPAlloc borderTopColorID;

		internal BMPAlloc borderRightColorID;

		internal BMPAlloc borderBottomColorID;

		internal BMPAlloc tintColorID;

		internal float compositeOpacity;

		internal Color backgroundColor;

		internal BasicNode<TextureEntry> textures;

		internal RenderChainCommand lastClosingOrLastCommand => lastClosingCommand ?? lastCommand;

		public bool isIgnoringDynamicColorHint
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return (flags & RenderDataFlags.IsIgnoringDynamicColorHint) == RenderDataFlags.IsIgnoringDynamicColorHint;
			}
		}

		internal static bool AllocatesID(BMPAlloc alloc)
		{
			return alloc.ownedState == OwnedState.Owned && alloc.IsValid();
		}

		internal static bool InheritsID(BMPAlloc alloc)
		{
			return alloc.ownedState == OwnedState.Inherited && alloc.IsValid();
		}
	}
	internal struct TextureEntry
	{
		public Texture source;

		public TextureId actual;

		public bool replaced;
	}
	internal abstract class BaseShaderInfoStorage : IDisposable
	{
		protected static int s_TextureCounter;

		internal static ProfilerMarker s_MarkerCopyTexture = new ProfilerMarker("UIR.ShaderInfoStorage.CopyTexture");

		internal static ProfilerMarker s_MarkerGetTextureData = new ProfilerMarker("UIR.ShaderInfoStorage.GetTextureData");

		internal static ProfilerMarker s_MarkerUpdateTexture = new ProfilerMarker("UIR.ShaderInfoStorage.UpdateTexture");

		public abstract Texture2D texture { get; }

		protected bool disposed { get; private set; }

		public abstract bool AllocateRect(int width, int height, out RectInt uvs);

		public abstract void SetTexel(int x, int y, Color color);

		public abstract void UpdateTexture();

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (!disposing)
				{
				}
				disposed = true;
			}
		}
	}
	internal class ShaderInfoStorage<T> : BaseShaderInfoStorage where T : struct
	{
		private readonly int m_InitialSize;

		private readonly int m_MaxSize;

		private readonly TextureFormat m_Format;

		private readonly Func<Color, T> m_Convert;

		private UIRAtlasAllocator m_Allocator;

		private Texture2D m_Texture;

		private NativeArray<T> m_Texels;

		public override Texture2D texture => m_Texture;

		public ShaderInfoStorage(TextureFormat format, Func<Color, T> convert, int initialSize = 64, int maxSize = 4096)
		{
			Debug.Assert(maxSize <= SystemInfo.maxTextureSize);
			Debug.Assert(initialSize <= maxSize);
			Debug.Assert(Mathf.IsPowerOfTwo(initialSize));
			Debug.Assert(Mathf.IsPowerOfTwo(maxSize));
			Debug.Assert(convert != null);
			m_InitialSize = initialSize;
			m_MaxSize = maxSize;
			m_Format = format;
			m_Convert = convert;
		}

		protected override void Dispose(bool disposing)
		{
			if (!base.disposed && disposing)
			{
				UIRUtility.Destroy(m_Texture);
				m_Texture = null;
				m_Texels = default(NativeArray<T>);
				m_Allocator?.Dispose();
				m_Allocator = null;
			}
			base.Dispose(disposing);
		}

		public override bool AllocateRect(int width, int height, out RectInt uvs)
		{
			if (base.disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
				uvs = default(RectInt);
				return false;
			}
			if (m_Allocator == null)
			{
				m_Allocator = new UIRAtlasAllocator(m_InitialSize, m_MaxSize, 0);
			}
			if (!m_Allocator.TryAllocate(width, height, out uvs))
			{
				return false;
			}
			uvs = new RectInt(uvs.x, uvs.y, width, height);
			CreateOrExpandTexture();
			return true;
		}

		public override void SetTexel(int x, int y, Color color)
		{
			if (base.disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
				return;
			}
			if (!m_Texels.IsCreated)
			{
				m_Texels = m_Texture.GetRawTextureData<T>();
			}
			m_Texels[x + y * m_Texture.width] = m_Convert(color);
		}

		public override void UpdateTexture()
		{
			if (base.disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
			}
			else if (!(m_Texture == null) && m_Texels.IsCreated)
			{
				m_Texture.Apply(updateMipmaps: false, makeNoLongerReadable: false);
				m_Texels = default(NativeArray<T>);
			}
		}

		private void CreateOrExpandTexture()
		{
			int physicalWidth = m_Allocator.physicalWidth;
			int physicalHeight = m_Allocator.physicalHeight;
			bool flag = false;
			if (m_Texture != null)
			{
				if (m_Texture.width == physicalWidth && m_Texture.height == physicalHeight)
				{
					return;
				}
				flag = true;
			}
			Texture2D texture2D = new Texture2D(m_Allocator.physicalWidth, m_Allocator.physicalHeight, m_Format, mipChain: false)
			{
				name = "UIR Shader Info " + BaseShaderInfoStorage.s_TextureCounter++,
				hideFlags = HideFlags.HideAndDontSave,
				filterMode = FilterMode.Point
			};
			if (flag)
			{
				NativeArray<T> src = (m_Texels.IsCreated ? m_Texels : m_Texture.GetRawTextureData<T>());
				NativeArray<T> rawTextureData = texture2D.GetRawTextureData<T>();
				CpuBlit(src, m_Texture.width, m_Texture.height, rawTextureData, texture2D.width, texture2D.height);
				m_Texels = rawTextureData;
			}
			else
			{
				m_Texels = default(NativeArray<T>);
			}
			UIRUtility.Destroy(m_Texture);
			m_Texture = texture2D;
		}

		private static void CpuBlit(NativeArray<T> src, int srcWidth, int srcHeight, NativeArray<T> dst, int dstWidth, int dstHeight)
		{
			Debug.Assert(dstWidth >= srcWidth && dstHeight >= srcHeight);
			int num = dstWidth - srcWidth;
			int num2 = dstHeight - srcHeight;
			int num3 = srcWidth * srcHeight;
			int i = 0;
			int num4 = 0;
			int num5 = srcWidth;
			while (i < num3)
			{
				for (; i < num5; i++)
				{
					dst[num4] = src[i];
					num4++;
				}
				num5 += srcWidth;
				num4 += num;
			}
		}
	}
	internal class ShaderInfoStorageRGBA32 : ShaderInfoStorage<Color32>
	{
		private static readonly Func<Color, Color32> s_Convert = (Color c) => c;

		public ShaderInfoStorageRGBA32(int initialSize = 64, int maxSize = 4096)
			: base(TextureFormat.RGBA32, s_Convert, initialSize, maxSize)
		{
		}
	}
	internal class ShaderInfoStorageRGBAFloat : ShaderInfoStorage<Color>
	{
		private static readonly Func<Color, Color> s_Convert = (Color c) => c;

		public ShaderInfoStorageRGBAFloat(int initialSize = 64, int maxSize = 4096)
			: base(TextureFormat.RGBAFloat, s_Convert, initialSize, maxSize)
		{
		}
	}
	internal static class Shaders
	{
		public static readonly string k_AtlasBlit;

		public static readonly string k_Editor;

		public static readonly string k_Runtime;

		public static readonly string k_RuntimeWorld;

		public static readonly string k_GraphView;

		public static readonly string k_ColorConversionBlit;

		static Shaders()
		{
			if (UIElementsPackageUtility.IsUIEPackageLoaded)
			{
				k_AtlasBlit = "Hidden/UIE-AtlasBlit";
				k_Editor = "Hidden/UIE-Editor";
				k_Runtime = "Hidden/UIE-Runtime";
				k_RuntimeWorld = "Hidden/UIE-RuntimeWorld";
				k_GraphView = "Hidden/UIE-GraphView";
				k_ColorConversionBlit = "Hidden/UIE-ColorConversionBlit";
			}
			else
			{
				k_AtlasBlit = "Hidden/Internal-UIRAtlasBlitCopy";
				k_Editor = "Hidden/UIElements/EditorUIE";
				k_Runtime = "Hidden/Internal-UIRDefault";
				k_RuntimeWorld = "Hidden/Internal-UIRDefaultWorld";
				k_GraphView = "Hidden/GraphView/GraphViewUIE";
				k_ColorConversionBlit = "Hidden/Internal-UIE-ColorConversionBlit";
			}
		}
	}
	internal class TempAllocator<T> : IDisposable where T : struct
	{
		private struct Page
		{
			public NativeArray<T> array;

			public int used;
		}

		public struct Statistics
		{
			public PageStatistics pool;

			public PageStatistics[] excess;
		}

		public struct PageStatistics
		{
			public int size;

			public int used;
		}

		private readonly int m_ExcessMinCapacity;

		private readonly int m_ExcessMaxCapacity;

		private Page m_Pool;

		private List<Page> m_Excess;

		private int m_NextExcessSize;

		protected bool disposed { get; private set; }

		public TempAllocator(int poolCapacity, int excessMinCapacity, int excessMaxCapacity)
		{
			Debug.Assert(poolCapacity >= 1);
			Debug.Assert(excessMinCapacity >= 1);
			Debug.Assert(excessMinCapacity <= excessMaxCapacity);
			m_ExcessMinCapacity = excessMinCapacity;
			m_ExcessMaxCapacity = excessMaxCapacity;
			m_NextExcessSize = m_ExcessMinCapacity;
			m_Pool = default(Page);
			m_Pool.array = new NativeArray<T>(poolCapacity, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);
			m_Excess = new List<Page>(8);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (disposing)
				{
					ReleaseExcess();
					m_Pool.array.Dispose();
					m_Pool.used = 0;
				}
				disposed = true;
			}
		}

		public NativeSlice<T> Alloc(int count)
		{
			Debug.Assert(!disposed);
			int num = m_Pool.used + count;
			if (num <= m_Pool.array.Length)
			{
				NativeSlice<T> result = m_Pool.array.Slice(m_Pool.used, count);
				m_Pool.used = num;
				return result;
			}
			if (count > m_ExcessMaxCapacity)
			{
				Page item = new Page
				{
					array = new NativeArray<T>(count, Allocator.Persistent, NativeArrayOptions.UninitializedMemory),
					used = count
				};
				m_Excess.Add(item);
				return item.array.Slice(0, count);
			}
			for (int num2 = m_Excess.Count - 1; num2 >= 0; num2--)
			{
				Page value = m_Excess[num2];
				num = value.used + count;
				if (num <= value.array.Length)
				{
					NativeSlice<T> result2 = value.array.Slice(value.used, count);
					value.used = num;
					m_Excess[num2] = value;
					return result2;
				}
			}
			while (count > m_NextExcessSize)
			{
				m_NextExcessSize <<= 1;
			}
			Page item2 = new Page
			{
				array = new NativeArray<T>(m_NextExcessSize, Allocator.Persistent, NativeArrayOptions.UninitializedMemory),
				used = count
			};
			m_Excess.Add(item2);
			m_NextExcessSize = Mathf.Min(m_NextExcessSize << 1, m_ExcessMaxCapacity);
			return item2.array.Slice(0, count);
		}

		public void Reset()
		{
			ReleaseExcess();
			m_Pool.used = 0;
			m_NextExcessSize = m_ExcessMinCapacity;
		}

		private void ReleaseExcess()
		{
			foreach (Page item in m_Excess)
			{
				item.array.Dispose();
			}
			m_Excess.Clear();
		}

		public Statistics GatherStatistics()
		{
			Statistics result = new Statistics
			{
				pool = new PageStatistics
				{
					size = m_Pool.array.Length,
					used = m_Pool.used
				},
				excess = new PageStatistics[m_Excess.Count]
			};
			for (int i = 0; i < m_Excess.Count; i++)
			{
				result.excess[i] = new PageStatistics
				{
					size = m_Excess[i].array.Length,
					used = m_Excess[i].used
				};
			}
			return result;
		}
	}
	internal struct TextCoreSettings : IEquatable<TextCoreSettings>
	{
		public Color faceColor;

		public Color outlineColor;

		public float outlineWidth;

		public Color underlayColor;

		public Vector2 underlayOffset;

		public float underlaySoftness;

		public override bool Equals(object obj)
		{
			return obj is TextCoreSettings && Equals((TextCoreSettings)obj);
		}

		public bool Equals(TextCoreSettings other)
		{
			return other.faceColor == faceColor && other.outlineColor == outlineColor && other.outlineWidth == outlineWidth && other.underlayColor == underlayColor && other.underlayOffset == underlayOffset && other.underlaySoftness == underlaySoftness;
		}

		public override int GetHashCode()
		{
			int num = 75905159;
			num = num * -1521134295 + faceColor.GetHashCode();
			num = num * -1521134295 + outlineColor.GetHashCode();
			num = num * -1521134295 + outlineWidth.GetHashCode();
			num = num * -1521134295 + underlayColor.GetHashCode();
			num = num * -1521134295 + underlayOffset.x.GetHashCode();
			num = num * -1521134295 + underlayOffset.y.GetHashCode();
			return num * -1521134295 + underlaySoftness.GetHashCode();
		}
	}
	internal class TextureBlitter : IDisposable
	{
		private struct BlitInfo
		{
			public Texture src;

			public RectInt srcRect;

			public Vector2Int dstPos;

			public int border;

			public Color tint;
		}

		private const int k_TextureSlotCount = 8;

		private static readonly int[] k_TextureIds;

		private static ProfilerMarker s_CommitSampler;

		private BlitInfo[] m_SingleBlit = new BlitInfo[1];

		private Material m_BlitMaterial;

		private MaterialPropertyBlock m_Properties;

		private RectInt m_Viewport;

		private RenderTexture m_PrevRT;

		private List<BlitInfo> m_PendingBlits;

		protected bool disposed { get; private set; }

		public int queueLength => m_PendingBlits.Count;

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (disposing)
				{
					UIRUtility.Destroy(m_BlitMaterial);
					m_BlitMaterial = null;
				}
				disposed = true;
			}
		}

		static TextureBlitter()
		{
			s_CommitSampler = new ProfilerMarker("UIR.TextureBlitter.Commit");
			k_TextureIds = new int[8];
			for (int i = 0; i < 8; i++)
			{
				k_TextureIds[i] = Shader.PropertyToID("_MainTex" + i);
			}
		}

		public TextureBlitter(int capacity = 512)
		{
			m_PendingBlits = new List<BlitInfo>(capacity);
		}

		public void QueueBlit(Texture src, RectInt srcRect, Vector2Int dstPos, bool addBorder, Color tint)
		{
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
				return;
			}
			m_PendingBlits.Add(new BlitInfo
			{
				src = src,
				srcRect = srcRect,
				dstPos = dstPos,
				border = (addBorder ? 1 : 0),
				tint = tint
			});
		}

		public void BlitOneNow(RenderTexture dst, Texture src, RectInt srcRect, Vector2Int dstPos, bool addBorder, Color tint)
		{
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
				return;
			}
			m_SingleBlit[0] = new BlitInfo
			{
				src = src,
				srcRect = srcRect,
				dstPos = dstPos,
				border = (addBorder ? 1 : 0),
				tint = tint
			};
			BeginBlit(dst);
			DoBlit(m_SingleBlit, 0);
			EndBlit();
		}

		public void Commit(RenderTexture dst)
		{
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
			}
			else if (m_PendingBlits.Count != 0)
			{
				BeginBlit(dst);
				for (int i = 0; i < m_PendingBlits.Count; i += 8)
				{
					DoBlit(m_PendingBlits, i);
				}
				EndBlit();
				m_PendingBlits.Clear();
			}
		}

		public void Reset()
		{
			m_PendingBlits.Clear();
		}

		private void BeginBlit(RenderTexture dst)
		{
			if (m_BlitMaterial == null)
			{
				Shader shader = Shader.Find(Shaders.k_AtlasBlit);
				m_BlitMaterial = new Material(shader);
				m_BlitMaterial.hideFlags |= HideFlags.DontSaveInEditor;
			}
			if (m_Properties == null)
			{
				m_Properties = new MaterialPropertyBlock();
			}
			m_Viewport = Utility.GetActiveViewport();
			m_PrevRT = RenderTexture.active;
			GL.LoadPixelMatrix(0f, dst.width, 0f, dst.height);
			Graphics.SetRenderTarget(dst);
			m_BlitMaterial.SetPass(0);
		}

		private void DoBlit(IList<BlitInfo> blitInfos, int startIndex)
		{
			int num = Mathf.Min(blitInfos.Count - startIndex, 8);
			int num2 = startIndex + num;
			int num3 = startIndex;
			int num4 = 0;
			while (num3 < num2)
			{
				Texture src = blitInfos[num3].src;
				if (src != null)
				{
					m_Properties.SetTexture(k_TextureIds[num4], src);
				}
				num3++;
				num4++;
			}
			Utility.SetPropertyBlock(m_Properties);
			GL.Begin(7);
			int num5 = startIndex;
			int num6 = 0;
			while (num5 < num2)
			{
				BlitInfo blitInfo = blitInfos[num5];
				float num7 = 1f / (float)blitInfo.src.width;
				float num8 = 1f / (float)blitInfo.src.height;
				float x = blitInfo.dstPos.x - blitInfo.border;
				float y = blitInfo.dstPos.y - blitInfo.border;
				float x2 = blitInfo.dstPos.x + blitInfo.srcRect.width + blitInfo.border;
				float y2 = blitInfo.dstPos.y + blitInfo.srcRect.height + blitInfo.border;
				float x3 = (float)(blitInfo.srcRect.x - blitInfo.border) * num7;
				float y3 = (float)(blitInfo.srcRect.y - blitInfo.border) * num8;
				float x4 = (float)(blitInfo.srcRect.xMax + blitInfo.border) * num7;
				float y4 = (float)(blitInfo.srcRect.yMax + blitInfo.border) * num8;
				GL.Color(blitInfo.tint);
				GL.TexCoord3(x3, y3, num6);
				GL.Vertex3(x, y, 0f);
				GL.Color(blitInfo.tint);
				GL.TexCoord3(x3, y4, num6);
				GL.Vertex3(x, y2, 0f);
				GL.Color(blitInfo.tint);
				GL.TexCoord3(x4, y4, num6);
				GL.Vertex3(x2, y2, 0f);
				GL.Color(blitInfo.tint);
				GL.TexCoord3(x4, y3, num6);
				GL.Vertex3(x2, y, 0f);
				num5++;
				num6++;
			}
			GL.End();
		}

		private void EndBlit()
		{
			Graphics.SetRenderTarget(m_PrevRT);
			GL.Viewport(new Rect(m_Viewport.x, m_Viewport.y, m_Viewport.width, m_Viewport.height));
		}
	}
	internal class TextureSlotManager
	{
		internal static readonly int k_SlotCount;

		internal static readonly int k_SlotSize;

		internal static readonly int[] slotIds;

		internal static readonly int textureTableId;

		private TextureId[] m_Textures;

		private int[] m_Tickets;

		private int m_CurrentTicket;

		private int m_FirstUsedTicket;

		private Vector4[] m_GpuTextures;

		internal TextureRegistry textureRegistry = TextureRegistry.instance;

		public int FreeSlots { get; private set; } = k_SlotCount;

		static TextureSlotManager()
		{
			k_SlotSize = 2;
			textureTableId = Shader.PropertyToID("_TextureInfo");
			k_SlotCount = (UIRenderDevice.shaderModelIs35 ? 8 : 4);
			slotIds = new int[k_SlotCount];
			for (int i = 0; i < k_SlotCount; i++)
			{
				slotIds[i] = Shader.PropertyToID($"_Texture{i}");
			}
		}

		public TextureSlotManager()
		{
			m_Textures = new TextureId[k_SlotCount];
			m_Tickets = new int[k_SlotCount];
			m_GpuTextures = new Vector4[k_SlotCount * k_SlotSize];
			Reset();
		}

		public void Reset()
		{
			m_CurrentTicket = 0;
			m_FirstUsedTicket = 0;
			for (int i = 0; i < k_SlotCount; i++)
			{
				m_Textures[i] = TextureId.invalid;
				m_Tickets[i] = -1;
				SetGpuData(i, TextureId.invalid, 1, 1, 0f);
			}
		}

		public void StartNewBatch()
		{
			m_FirstUsedTicket = ++m_CurrentTicket;
			FreeSlots = k_SlotCount;
		}

		public int IndexOf(TextureId id)
		{
			for (int i = 0; i < k_SlotCount; i++)
			{
				if (m_Textures[i].index == id.index)
				{
					return i;
				}
			}
			return -1;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void MarkUsed(int slotIndex)
		{
			int num = m_Tickets[slotIndex];
			if (num < m_FirstUsedTicket)
			{
				int freeSlots = FreeSlots - 1;
				FreeSlots = freeSlots;
			}
			m_Tickets[slotIndex] = ++m_CurrentTicket;
		}

		public int FindOldestSlot()
		{
			int num = m_Tickets[0];
			int result = 0;
			for (int i = 1; i < k_SlotCount; i++)
			{
				if (m_Tickets[i] < num)
				{
					num = m_Tickets[i];
					result = i;
				}
			}
			return result;
		}

		public void Bind(TextureId id, float sdfScale, int slot, MaterialPropertyBlock mat)
		{
			Texture texture = textureRegistry.GetTexture(id);
			if (texture == null)
			{
				texture = Texture2D.whiteTexture;
			}
			m_Textures[slot] = id;
			MarkUsed(slot);
			SetGpuData(slot, id, texture.width, texture.height, sdfScale);
			mat.SetTexture(slotIds[slot], texture);
			mat.SetVectorArray(textureTableId, m_GpuTextures);
		}

		public void SetGpuData(int slotIndex, TextureId id, int textureWidth, int textureHeight, float sdfScale)
		{
			int num = slotIndex * k_SlotSize;
			float y = 1f / (float)textureWidth;
			float z = 1f / (float)textureHeight;
			m_GpuTextures[num] = new Vector4(id.ConvertToGpu(), y, z, sdfScale);
			m_GpuTextures[num + 1] = new Vector4(textureWidth, textureHeight, 0f, 0f);
		}
	}
	internal class VectorImageRenderInfoPool : LinkedPool<VectorImageRenderInfo>
	{
		public VectorImageRenderInfoPool()
			: base((Func<VectorImageRenderInfo>)(() => new VectorImageRenderInfo()), (Action<VectorImageRenderInfo>)delegate(VectorImageRenderInfo vectorImageInfo)
			{
				vectorImageInfo.Reset();
			}, 10000)
		{
		}
	}
	internal class VectorImageRenderInfo : LinkedPoolItem<VectorImageRenderInfo>
	{
		public int useCount;

		public GradientRemap firstGradientRemap;

		public Alloc gradientSettingsAlloc;

		public void Reset()
		{
			useCount = 0;
			firstGradientRemap = null;
			gradientSettingsAlloc = default(Alloc);
		}
	}
	internal class GradientRemapPool : LinkedPool<GradientRemap>
	{
		public GradientRemapPool()
			: base((Func<GradientRemap>)(() => new GradientRemap()), (Action<GradientRemap>)delegate(GradientRemap gradientRemap)
			{
				gradientRemap.Reset();
			}, 10000)
		{
		}
	}
	internal class GradientRemap : LinkedPoolItem<GradientRemap>
	{
		public int origIndex;

		public int destIndex;

		public RectInt location;

		public GradientRemap next;

		public TextureId atlas;

		public void Reset()
		{
			origIndex = 0;
			destIndex = 0;
			location = default(RectInt);
			atlas = TextureId.invalid;
		}
	}
	internal class VectorImageManager : IDisposable
	{
		public static List<VectorImageManager> instances = new List<VectorImageManager>(16);

		private static ProfilerMarker s_MarkerRegister = new ProfilerMarker("UIR.VectorImageManager.Register");

		private static ProfilerMarker s_MarkerUnregister = new ProfilerMarker("UIR.VectorImageManager.Unregister");

		private readonly AtlasBase m_Atlas;

		private Dictionary<VectorImage, VectorImageRenderInfo> m_Registered;

		private VectorImageRenderInfoPool m_RenderInfoPool;

		private GradientRemapPool m_GradientRemapPool;

		private GradientSettingsAtlas m_GradientSettingsAtlas;

		private bool m_LoggedExhaustedSettingsAtlas;

		public Texture2D atlas => m_GradientSettingsAtlas?.atlas;

		protected bool disposed { get; private set; }

		public VectorImageManager(AtlasBase atlas)
		{
			instances.Add(this);
			m_Atlas = atlas;
			m_Registered = new Dictionary<VectorImage, VectorImageRenderInfo>(32);
			m_RenderInfoPool = new VectorImageRenderInfoPool();
			m_GradientRemapPool = new GradientRemapPool();
			m_GradientSettingsAtlas = new GradientSettingsAtlas();
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (disposing)
				{
					m_Registered.Clear();
					m_RenderInfoPool.Clear();
					m_GradientRemapPool.Clear();
					m_GradientSettingsAtlas.Dispose();
					instances.Remove(this);
				}
				disposed = true;
			}
		}

		public void Reset()
		{
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
				return;
			}
			m_Registered.Clear();
			m_RenderInfoPool.Clear();
			m_GradientRemapPool.Clear();
			m_GradientSettingsAtlas.Reset();
		}

		public void Commit()
		{
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
			}
			else
			{
				m_GradientSettingsAtlas.Commit();
			}
		}

		public GradientRemap AddUser(VectorImage vi, VisualElement context)
		{
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
				return null;
			}
			if (vi == null)
			{
				return null;
			}
			if (m_Registered.TryGetValue(vi, out var value))
			{
				value.useCount++;
			}
			else
			{
				value = Register(vi, context);
			}
			return value.firstGradientRemap;
		}

		public void RemoveUser(VectorImage vi)
		{
			VectorImageRenderInfo value;
			if (disposed)
			{
				DisposeHelper.NotifyDisposedUsed(this);
			}
			else if (!(vi == null) && m_Registered.TryGetValue(vi, out value))
			{
				value.useCount--;
				if (value.useCount == 0)
				{
					Unregister(vi, value);
				}
			}
		}

		private VectorImageRenderInfo Register(VectorImage vi, VisualElement context)
		{
			VectorImageRenderInfo vectorImageRenderInfo = m_RenderInfoPool.Get();
			vectorImageRenderInfo.useCount = 1;
			m_Registered[vi] = vectorImageRenderInfo;
			GradientSettings[] settings = vi.settings;
			if (settings != null && settings.Length != 0)
			{
				int num = vi.settings.Length;
				Alloc alloc = m_GradientSettingsAtlas.Add(num);
				if (alloc.size != 0)
				{
					if (m_Atlas.TryGetAtlas(context, vi.atlas, out var textureId, out var atlasRect))
					{
						GradientRemap gradientRemap = null;
						for (int i = 0; i < num; i++)
						{
							GradientRemap gradientRemap2 = m_GradientRemapPool.Get();
							if (i > 0)
							{
								gradientRemap.next = gradientRemap2;
							}
							else
							{
								vectorImageRenderInfo.firstGradientRemap = gradientRemap2;
							}
							gradientRemap = gradientRemap2;
							gradientRemap2.origIndex = i;
							gradientRemap2.destIndex = (int)alloc.start + i;
							GradientSettings gradientSettings = vi.settings[i];
							RectInt location = gradientSettings.location;
							location.x += atlasRect.x;
							location.y += atlasRect.y;
							gradientRemap2.location = location;
							gradientRemap2.atlas = textureId;
						}
						m_GradientSettingsAtlas.Write(alloc, vi.settings, vectorImageRenderInfo.firstGradientRemap);
					}
					else
					{
						GradientRemap gradientRemap3 = null;
						for (int j = 0; j < num; j++)
						{
							GradientRemap gradientRemap4 = m_GradientRemapPool.Get();
							if (j > 0)
							{
								gradientRemap3.next = gradientRemap4;
							}
							else
							{
								vectorImageRenderInfo.firstGradientRemap = gradientRemap4;
							}
							gradientRemap3 = gradientRemap4;
							gradientRemap4.origIndex = j;
							gradientRemap4.destIndex = (int)alloc.start + j;
							gradientRemap4.atlas = TextureId.invalid;
						}
						m_GradientSettingsAtlas.Write(alloc, vi.settings, null);
					}
				}
				else if (!m_LoggedExhaustedSettingsAtlas)
				{
					Debug.LogError("Exhausted max gradient settings (" + m_GradientSettingsAtlas.length + ") for atlas: " + m_GradientSettingsAtlas.atlas?.name);
					m_LoggedExhaustedSettingsAtlas = true;
				}
			}
			return vectorImageRenderInfo;
		}

		private void Unregister(VectorImage vi, VectorImageRenderInfo renderInfo)
		{
			if (renderInfo.gradientSettingsAlloc.size != 0)
			{
				m_GradientSettingsAtlas.Remove(renderInfo.gradientSettingsAlloc);
			}
			GradientRemap gradientRemap = renderInfo.firstGradientRemap;
			while (gradientRemap != null)
			{
				GradientRemap next = gradientRemap.next;
				m_GradientRemapPool.Return(gradientRemap);
				gradientRemap = next;
			}
			m_Registered.Remove(vi);
			m_RenderInfoPool.Return(renderInfo);
		}
	}
	internal enum OwnedState : byte
	{
		Inherited,
		Owned
	}
	internal struct BMPAlloc
	{
		public static readonly BMPAlloc Invalid = new BMPAlloc
		{
			page = -1
		};

		public int page;

		public ushort pageLine;

		public byte bitIndex;

		public OwnedState ownedState;

		public bool Equals(BMPAlloc other)
		{
			return page == other.page && pageLine == other.pageLine && bitIndex == other.bitIndex;
		}

		public bool IsValid()
		{
			return page >= 0;
		}

		public override string ToString()
		{
			return $"{page},{pageLine},{bitIndex}";
		}
	}
	internal struct BitmapAllocator32
	{
		private struct Page
		{
			public ushort x;

			public ushort y;

			public int freeSlots;
		}

		public const int kPageWidth = 32;

		private int m_PageHeight;

		private List<Page> m_Pages;

		private List<uint> m_AllocMap;

		private int m_EntryWidth;

		private int m_EntryHeight;

		public int entryWidth => m_EntryWidth;

		public int entryHeight => m_EntryHeight;

		public void Construct(int pageHeight, int entryWidth = 1, int entryHeight = 1)
		{
			m_PageHeight = pageHeight;
			m_Pages = new List<Page>(1);
			m_AllocMap = new List<uint>(m_PageHeight * m_Pages.Capacity);
			m_EntryWidth = entryWidth;
			m_EntryHeight = entryHeight;
		}

		public void ForceFirstAlloc(ushort firstPageX, ushort firstPageY)
		{
			m_AllocMap.Add(4294967294u);
			for (int i = 1; i < m_PageHeight; i++)
			{
				m_AllocMap.Add(uint.MaxValue);
			}
			m_Pages.Add(new Page
			{
				x = firstPageX,
				y = firstPageY,
				freeSlots = 32 * m_PageHeight - 1
			});
		}

		public BMPAlloc Allocate(BaseShaderInfoStorage storage)
		{
			int count = m_Pages.Count;
			for (int i = 0; i < count; i++)
			{
				Page value = m_Pages[i];
				if (value.freeSlots == 0)
				{
					continue;
				}
				int j = i * m_PageHeight;
				for (int num = j + m_PageHeight; j < num; j++)
				{
					uint num2 = m_AllocMap[j];
					if (num2 != 0)
					{
						byte b = CountTrailingZeroes(num2);
						m_AllocMap[j] = num2 & (uint)(~(1 << (int)b));
						value.freeSlots--;
						m_Pages[i] = value;
						return new BMPAlloc
						{
							page = i,
							pageLine = (ushort)(j - i * m_PageHeight),
							bitIndex = b,
							ownedState = OwnedState.Owned
						};
					}
				}
			}
			if (storage == null || !storage.AllocateRect(32 * m_EntryWidth, m_PageHeight * m_EntryHeight, out var uvs))
			{
				return BMPAlloc.Invalid;
			}
			m_AllocMap.Capacity += m_PageHeight;
			m_AllocMap.Add(4294967294u);
			for (int k = 1; k < m_PageHeight; k++)
			{
				m_AllocMap.Add(uint.MaxValue);
			}
			m_Pages.Add(new Page
			{
				x = (ushort)uvs.xMin,
				y = (ushort)uvs.yMin,
				freeSlots = 32 * m_PageHeight - 1
			});
			return new BMPAlloc
			{
				page = m_Pages.Count - 1,
				ownedState = OwnedState.Owned
			};
		}

		public void Free(BMPAlloc alloc)
		{
			Debug.Assert(alloc.ownedState == OwnedState.Owned);
			int index = alloc.page * m_PageHeight + alloc.pageLine;
			m_AllocMap[index] |= (uint)(1 << (int)alloc.bitIndex);
			Page value = m_Pages[alloc.page];
			value.freeSlots++;
			m_Pages[alloc.page] = value;
		}

		internal void GetAllocPageAtlasLocation(int page, out ushort x, out ushort y)
		{
			Page page2 = m_Pages[page];
			x = page2.x;
			y = page2.y;
		}

		private static byte CountTrailingZeroes(uint val)
		{
			byte b = 0;
			if ((val & 0xFFFF) == 0)
			{
				val >>= 16;
				b = 16;
			}
			if ((val & 0xFF) == 0)
			{
				val >>= 8;
				b += 8;
			}
			if ((val & 0xF) == 0)
			{
				val >>= 4;
				b += 4;
			}
			if ((val & 3) == 0)
			{
				val >>= 2;
				b += 2;
			}
			if ((val & 1) == 0)
			{
				b++;
			}
			return b;
		}
	}
	internal struct UIRVEShaderInfoAllocator
	{
		private BaseShaderInfoStorage m_Storage;

		private BitmapAllocator32 m_TransformAllocator;

		private BitmapAllocator32 m_ClipRectAllocator;

		private BitmapAllocator32 m_OpacityAllocator;

		private BitmapAllocator32 m_ColorAllocator;

		private BitmapAllocator32 m_TextSettingsAllocator;

		private bool m_StorageReallyCreated;

		private bool m_VertexTexturingEnabled;

		private NativeArray<Transform3x4> m_Transforms;

		private NativeArray<Vector4> m_ClipRects;

		internal static readonly Vector2Int identityTransformTexel = new Vector2Int(0, 0);

		internal static readonly Vector2Int infiniteClipRectTexel = new Vector2Int(0, 32);

		internal static readonly Vector2Int fullOpacityTexel = new Vector2Int(32, 32);

		internal static readonly Vector2Int clearColorTexel = new Vector2Int(0, 40);

		internal static readonly Vector2Int defaultTextCoreSettingsTexel = new Vector2Int(32, 0);

		internal static readonly Matrix4x4 identityTransformValue = Matrix4x4.identity;

		internal static readonly Vector4 identityTransformRow0Value = identityTransformValue.GetRow(0);

		internal static readonly Vector4 identityTransformRow1Value = identityTransformValue.GetRow(1);

		internal static readonly Vector4 identityTransformRow2Value = identityTransformValue.GetRow(2);

		internal static readonly Vector4 infiniteClipRectValue = new Vector4(0f, 0f, 0f, 0f);

		internal static readonly Vector4 fullOpacityValue = new Vector4(1f, 1f, 1f, 1f);

		internal static readonly Vector4 clearColorValue = new Vector4(0f, 0f, 0f, 0f);

		internal static readonly TextCoreSettings defaultTextCoreSettingsValue = new TextCoreSettings
		{
			faceColor = Color.white,
			outlineColor = Color.clear,
			outlineWidth = 0f,
			underlayColor = Color.clear,
			underlayOffset = Vector2.zero,
			underlaySoftness = 0f
		};

		public static readonly BMPAlloc identityTransform;

		public static readonly BMPAlloc infiniteClipRect;

		public static readonly BMPAlloc fullOpacity;

		public static readonly BMPAlloc clearColor;

		public static readonly BMPAlloc defaultTextCoreSettings;

		private static int pageWidth => 32;

		private static int pageHeight => 8;

		public NativeSlice<Transform3x4> transformConstants => m_Transforms;

		public NativeSlice<Vector4> clipRectConstants => m_ClipRects;

		public Texture atlas
		{
			get
			{
				if (m_StorageReallyCreated)
				{
					return m_Storage.texture;
				}
				return m_VertexTexturingEnabled ? UIRenderDevice.defaultShaderInfoTexFloat : UIRenderDevice.defaultShaderInfoTexARGB8;
			}
		}

		public bool internalAtlasCreated => m_StorageReallyCreated;

		private static Vector2Int AllocToTexelCoord(ref BitmapAllocator32 allocator, BMPAlloc alloc)
		{
			allocator.GetAllocPageAtlasLocation(alloc.page, out var x, out var y);
			return new Vector2Int(alloc.bitIndex * allocator.entryWidth + x, alloc.pageLine * allocator.entryHeight + y);
		}

		private static int AllocToConstantBufferIndex(BMPAlloc alloc)
		{
			return alloc.pageLine * pageWidth + alloc.bitIndex;
		}

		private static bool AtlasRectMatchesPage(ref BitmapAllocator32 allocator, BMPAlloc defAlloc, RectInt atlasRect)
		{
			allocator.GetAllocPageAtlasLocation(defAlloc.page, out var x, out var y);
			return x == atlasRect.xMin && y == atlasRect.yMin && allocator.entryWidth * pageWidth == atlasRect.width && allocator.entryHeight * pageHeight == atlasRect.height;
		}

		public void Construct()
		{
			m_OpacityAllocator = (m_ColorAllocator = (m_ClipRectAllocator = (m_TransformAllocator = (m_TextSettingsAllocator = default(BitmapAllocator32)))));
			m_TransformAllocator.Construct(pageHeight, 1, 3);
			m_TransformAllocator.ForceFirstAlloc((ushort)identityTransformTexel.x, (ushort)identityTransformTexel.y);
			m_ClipRectAllocator.Construct(pageHeight);
			m_ClipRectAllocator.ForceFirstAlloc((ushort)infiniteClipRectTexel.x, (ushort)infiniteClipRectTexel.y);
			m_OpacityAllocator.Construct(pageHeight);
			m_OpacityAllocator.ForceFirstAlloc((ushort)fullOpacityTexel.x, (ushort)fullOpacityTexel.y);
			m_ColorAllocator.Construct(pageHeight);
			m_ColorAllocator.ForceFirstAlloc((ushort)clearColorTexel.x, (ushort)clearColorTexel.y);
			m_TextSettingsAllocator.Construct(pageHeight, 1, 4);
			m_TextSettingsAllocator.ForceFirstAlloc((ushort)defaultTextCoreSettingsTexel.x, (ushort)defaultTextCoreSettingsTexel.y);
			m_VertexTexturingEnabled = UIRenderDevice.vertexTexturingIsAvailable;
			if (!m_VertexTexturingEnabled)
			{
				int length = 20;
				m_Transforms = new NativeArray<Transform3x4>(length, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);
				m_ClipRects = new NativeArray<Vector4>(length, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);
				m_Transforms[0] = new Transform3x4
				{
					v0 = identityTransformRow0Value,
					v1 = identityTransformRow1Value,
					v2 = identityTransformRow2Value
				};
				m_ClipRects[0] = infiniteClipRectValue;
			}
		}

		private void ReallyCreateStorage()
		{
			if (m_VertexTexturingEnabled)
			{
				m_Storage = new ShaderInfoStorageRGBAFloat();
			}
			else
			{
				m_Storage = new ShaderInfoStorageRGBA32();
			}
			m_Storage.AllocateRect(pageWidth * m_TransformAllocator.entryWidth, pageHeight * m_TransformAllocator.entryHeight, out var uvs);
			m_Storage.AllocateRect(pageWidth * m_ClipRectAllocator.entryWidth, pageHeight * m_ClipRectAllocator.entryHeight, out var uvs2);
			m_Storage.AllocateRect(pageWidth * m_OpacityAllocator.entryWidth, pageHeight * m_OpacityAllocator.entryHeight, out var uvs3);
			m_Storage.AllocateRect(pageWidth * m_ColorAllocator.entryWidth, pageHeight * m_ColorAllocator.entryHeight, out var uvs4);
			m_Storage.AllocateRect(pageWidth * m_TextSettingsAllocator.entryWidth, pageHeight * m_TextSettingsAllocator.entryHeight, out var uvs5);
			if (!AtlasRectMatchesPage(ref m_TransformAllocator, identityTransform, uvs))
			{
				throw new Exception("Atlas identity transform allocation failed unexpectedly");
			}
			if (!AtlasRectMatchesPage(ref m_ClipRectAllocator, infiniteClipRect, uvs2))
			{
				throw new Exception("Atlas infinite clip rect allocation failed unexpectedly");
			}
			if (!AtlasRectMatchesPage(ref m_OpacityAllocator, fullOpacity, uvs3))
			{
				throw new Exception("Atlas full opacity allocation failed unexpectedly");
			}
			if (!AtlasRectMatchesPage(ref m_ColorAllocator, clearColor, uvs4))
			{
				throw new Exception("Atlas clear color allocation failed unexpectedly");
			}
			if (!AtlasRectMatchesPage(ref m_TextSettingsAllocator, defaultTextCoreSettings, uvs5))
			{
				throw new Exception("Atlas text setting allocation failed unexpectedly");
			}
			SetTransformValue(identityTransform, identityTransformValue);
			SetClipRectValue(infiniteClipRect, infiniteClipRectValue);
			SetOpacityValue(fullOpacity, fullOpacityValue.w);
			SetColorValue(clearColor, clearColorValue, isEditorContext: false);
			SetTextCoreSettingValue(defaultTextCoreSettings, defaultTextCoreSettingsValue, isEditorContext: false);
			m_StorageReallyCreated = true;
		}

		public void Dispose()
		{
			if (m_Storage != null)
			{
				m_Storage.Dispose();
			}
			m_Storage = null;
			if (m_ClipRects.IsCreated)
			{
				m_ClipRects.Dispose();
			}
			if (m_Transforms.IsCreated)
			{
				m_Transforms.Dispose();
			}
			m_StorageReallyCreated = false;
		}

		public void IssuePendingStorageChanges()
		{
			m_Storage?.UpdateTexture();
		}

		public BMPAlloc AllocTransform()
		{
			if (!m_StorageReallyCreated)
			{
				ReallyCreateStorage();
			}
			if (m_VertexTexturingEnabled)
			{
				return m_TransformAllocator.Allocate(m_Storage);
			}
			BMPAlloc bMPAlloc = m_TransformAllocator.Allocate(null);
			if (AllocToConstantBufferIndex(bMPAlloc) < m_Transforms.Length)
			{
				return bMPAlloc;
			}
			m_TransformAllocator.Free(bMPAlloc);
			return BMPAlloc.Invalid;
		}

		public BMPAlloc AllocClipRect()
		{
			if (!m_StorageReallyCreated)
			{
				ReallyCreateStorage();
			}
			if (m_VertexTexturingEnabled)
			{
				return m_ClipRectAllocator.Allocate(m_Storage);
			}
			BMPAlloc bMPAlloc = m_ClipRectAllocator.Allocate(null);
			if (AllocToConstantBufferIndex(bMPAlloc) < m_ClipRects.Length)
			{
				return bMPAlloc;
			}
			m_ClipRectAllocator.Free(bMPAlloc);
			return BMPAlloc.Invalid;
		}

		public BMPAlloc AllocOpacity()
		{
			if (!m_StorageReallyCreated)
			{
				ReallyCreateStorage();
			}
			return m_OpacityAllocator.Allocate(m_Storage);
		}

		public BMPAlloc AllocColor()
		{
			if (!m_StorageReallyCreated)
			{
				ReallyCreateStorage();
			}
			return m_ColorAllocator.Allocate(m_Storage);
		}

		public BMPAlloc AllocTextCoreSettings(TextCoreSettings settings)
		{
			if (!m_StorageReallyCreated)
			{
				ReallyCreateStorage();
			}
			return m_TextSettingsAllocator.Allocate(m_Storage);
		}

		public void SetTransformValue(BMPAlloc alloc, Matrix4x4 xform)
		{
			Debug.Assert(alloc.IsValid());
			if (m_VertexTexturingEnabled)
			{
				Vector2Int vector2Int = AllocToTexelCoord(ref m_TransformAllocator, alloc);
				m_Storage.SetTexel(vector2Int.x, vector2Int.y, xform.GetRow(0));
				m_Storage.SetTexel(vector2Int.x, vector2Int.y + 1, xform.GetRow(1));
				m_Storage.SetTexel(vector2Int.x, vector2Int.y + 2, xform.GetRow(2));
			}
			else
			{
				m_Transforms[AllocToConstantBufferIndex(alloc)] = new Transform3x4
				{
					v0 = xform.GetRow(0),
					v1 = xform.GetRow(1),
					v2 = xform.GetRow(2)
				};
			}
		}

		public void SetClipRectValue(BMPAlloc alloc, Vector4 clipRect)
		{
			Debug.Assert(alloc.IsValid());
			if (m_VertexTexturingEnabled)
			{
				Vector2Int vector2Int = AllocToTexelCoord(ref m_ClipRectAllocator, alloc);
				m_Storage.SetTexel(vector2Int.x, vector2Int.y, clipRect);
			}
			else
			{
				m_ClipRects[AllocToConstantBufferIndex(alloc)] = clipRect;
			}
		}

		public void SetOpacityValue(BMPAlloc alloc, float opacity)
		{
			Debug.Assert(alloc.IsValid());
			Vector2Int vector2Int = AllocToTexelCoord(ref m_OpacityAllocator, alloc);
			m_Storage.SetTexel(vector2Int.x, vector2Int.y, new Color(1f, 1f, 1f, opacity));
		}

		public void SetColorValue(BMPAlloc alloc, Color color, bool isEditorContext)
		{
			Debug.Assert(alloc.IsValid());
			Vector2Int vector2Int = AllocToTexelCoord(ref m_ColorAllocator, alloc);
			if (QualitySettings.activeColorSpace == ColorSpace.Linear && !isEditorContext)
			{
				m_Storage.SetTexel(vector2Int.x, vector2Int.y, color.linear);
			}
			else
			{
				m_Storage.SetTexel(vector2Int.x, vector2Int.y, color);
			}
		}

		public void SetTextCoreSettingValue(BMPAlloc alloc, TextCoreSettings settings, bool isEditorContext)
		{
			Debug.Assert(alloc.IsValid());
			Vector2Int vector2Int = AllocToTexelCoord(ref m_TextSettingsAllocator, alloc);
			Color color = new Color(0f - settings.underlayOffset.x, settings.underlayOffset.y, settings.underlaySoftness, settings.outlineWidth);
			if (QualitySettings.activeColorSpace == ColorSpace.Linear && !isEditorContext)
			{
				m_Storage.SetTexel(vector2Int.x, vector2Int.y, settings.faceColor.linear);
				m_Storage.SetTexel(vector2Int.x, vector2Int.y + 1, settings.outlineColor.linear);
				m_Storage.SetTexel(vector2Int.x, vector2Int.y + 2, settings.underlayColor.linear);
			}
			else
			{
				m_Storage.SetTexel(vector2Int.x, vector2Int.y, settings.faceColor);
				m_Storage.SetTexel(vector2Int.x, vector2Int.y + 1, settings.outlineColor);
				m_Storage.SetTexel(vector2Int.x, vector2Int.y + 2, settings.underlayColor);
			}
			m_Storage.SetTexel(vector2Int.x, vector2Int.y + 3, color);
		}

		public void FreeTransform(BMPAlloc alloc)
		{
			Debug.Assert(alloc.IsValid());
			m_TransformAllocator.Free(alloc);
		}

		public void FreeClipRect(BMPAlloc alloc)
		{
			Debug.Assert(alloc.IsValid());
			m_ClipRectAllocator.Free(alloc);
		}

		public void FreeOpacity(BMPAlloc alloc)
		{
			Debug.Assert(alloc.IsValid());
			m_OpacityAllocator.Free(alloc);
		}

		public void FreeColor(BMPAlloc alloc)
		{
			Debug.Assert(alloc.IsValid());
			m_ColorAllocator.Free(alloc);
		}

		public void FreeTextCoreSettings(BMPAlloc alloc)
		{
			Debug.Assert(alloc.IsValid());
			m_TextSettingsAllocator.Free(alloc);
		}

		public Color32 TransformAllocToVertexData(BMPAlloc alloc)
		{
			Debug.Assert(pageWidth == 32 && pageHeight == 8);
			ushort x = 0;
			ushort y = 0;
			if (m_VertexTexturingEnabled)
			{
				m_TransformAllocator.GetAllocPageAtlasLocation(alloc.page, out x, out y);
			}
			return new Color32((byte)(x >> 5), (byte)(y >> 3), (byte)(alloc.pageLine * pageWidth + alloc.bitIndex), 0);
		}

		public Color32 ClipRectAllocToVertexData(BMPAlloc alloc)
		{
			Debug.Assert(pageWidth == 32 && pageHeight == 8);
			ushort x = 0;
			ushort y = 0;
			if (m_VertexTexturingEnabled)
			{
				m_ClipRectAllocator.GetAllocPageAtlasLocation(alloc.page, out x, out y);
			}
			return new Color32((byte)(x >> 5), (byte)(y >> 3), (byte)(alloc.pageLine * pageWidth + alloc.bitIndex), 0);
		}

		public Color32 OpacityAllocToVertexData(BMPAlloc alloc)
		{
			Debug.Assert(pageWidth == 32 && pageHeight == 8);
			m_OpacityAllocator.GetAllocPageAtlasLocation(alloc.page, out var x, out var y);
			return new Color32((byte)(x >> 5), (byte)(y >> 3), (byte)(alloc.pageLine * pageWidth + alloc.bitIndex), 0);
		}

		public Color32 ColorAllocToVertexData(BMPAlloc alloc)
		{
			Debug.Assert(pageWidth == 32 && pageHeight == 8);
			m_ColorAllocator.GetAllocPageAtlasLocation(alloc.page, out var x, out var y);
			return new Color32((byte)(x >> 5), (byte)(y >> 3), (byte)(alloc.pageLine * pageWidth + alloc.bitIndex), 0);
		}

		public Color32 TextCoreSettingsToVertexData(BMPAlloc alloc)
		{
			Debug.Assert(pageWidth == 32 && pageHeight == 8);
			m_TextSettingsAllocator.GetAllocPageAtlasLocation(alloc.page, out var x, out var y);
			return new Color32((byte)(x >> 5), (byte)(y >> 3), (byte)(alloc.pageLine * pageWidth + alloc.bitIndex), 0);
		}
	}
}
namespace UnityEngine.UIElements.UIR.Implementation
{
	internal static class CommandGenerator
	{
		private static readonly ProfilerMarker k_GenerateEntries = new ProfilerMarker("UIR.GenerateEntries");

		private static readonly ProfilerMarker k_ConvertEntriesToCommandsMarker = new ProfilerMarker("UIR.ConvertEntriesToCommands");

		private static readonly ProfilerMarker k_GenerateClosingCommandsMarker = new ProfilerMarker("UIR.GenerateClosingCommands");

		private static readonly ProfilerMarker k_NudgeVerticesMarker = new ProfilerMarker("UIR.NudgeVertices");

		private static readonly ProfilerMarker k_UpdateOpacityIdMarker = new ProfilerMarker("UIR.UpdateOpacityId");

		private static readonly ProfilerMarker k_ComputeTransformMatrixMarker = new ProfilerMarker("UIR.ComputeTransformMatrix");

		private static Material s_blitMaterial_LinearToGamma;

		private static Material s_blitMaterial_GammaToLinear;

		private static Material s_blitMaterial_NoChange;

		private static Shader s_blitShader;

		private static void GetVerticesTransformInfo(VisualElement ve, out Matrix4x4 transform)
		{
			if (RenderChainVEData.AllocatesID(ve.renderChainData.transformID) || (ve.renderHints & RenderHints.GroupTransform) != RenderHints.None)
			{
				transform = Matrix4x4.identity;
			}
			else if (ve.renderChainData.boneTransformAncestor != null)
			{
				if (ve.renderChainData.boneTransformAncestor.renderChainData.worldTransformScaleZero)
				{
					ComputeTransformMatrix(ve, ve.renderChainData.boneTransformAncestor, out transform);
				}
				else
				{
					VisualElement.MultiplyMatrix34(ref ve.renderChainData.boneTransformAncestor.worldTransformInverse, ref ve.worldTransformRef, out transform);
				}
			}
			else if (ve.renderChainData.groupTransformAncestor != null)
			{
				if (ve.renderChainData.groupTransformAncestor.renderChainData.worldTransformScaleZero)
				{
					ComputeTransformMatrix(ve, ve.renderChainData.groupTransformAncestor, out transform);
				}
				else
				{
					VisualElement.MultiplyMatrix34(ref ve.renderChainData.groupTransformAncestor.worldTransformInverse, ref ve.worldTransformRef, out transform);
				}
			}
			else
			{
				transform = ve.worldTransform;
			}
			transform.m22 = 1f;
		}

		internal static void ComputeTransformMatrix(VisualElement ve, VisualElement ancestor, out Matrix4x4 result)
		{
			ve.GetPivotedMatrixWithLayout(out result);
			VisualElement parent = ve.parent;
			if (parent == null || ancestor == parent)
			{
				return;
			}
			Matrix4x4 rhs = default(Matrix4x4);
			bool flag = true;
			do
			{
				parent.GetPivotedMatrixWithLayout(out var result2);
				if (flag)
				{
					VisualElement.MultiplyMatrix34(ref result2, ref result, out rhs);
				}
				else
				{
					VisualElement.MultiplyMatrix34(ref result2, ref rhs, out result);
				}
				parent = parent.parent;
				flag = !flag;
			}
			while (parent != null && ancestor != parent);
			if (!flag)
			{
				result = rhs;
			}
		}

		private static bool IsParentOrAncestorOf(this VisualElement ve, VisualElement child)
		{
			while (child.hierarchy.parent != null)
			{
				if (child.hierarchy.parent == ve)
				{
					return true;
				}
				child = child.hierarchy.parent;
			}
			return false;
		}

		public unsafe static UIRStylePainter.ClosingInfo PaintElement(RenderChain renderChain, VisualElement ve, ref ChainBuilderStats stats)
		{
			UIRenderDevice device = renderChain.device;
			bool flag = ve.renderChainData.clipMethod == ClipMethod.Stencil;
			bool flag2 = ve.renderChainData.clipMethod == ClipMethod.Scissor;
			bool flag3 = (ve.renderHints & RenderHints.GroupTransform) != 0;
			if ((UIRUtility.IsElementSelfHidden(ve) && !flag && !flag2 && !flag3) || ve.renderChainData.isHierarchyHidden)
			{
				if (ve.renderChainData.data != null)
				{
					device.Free(ve.renderChainData.data);
					ve.renderChainData.data = null;
				}
				if (ve.renderChainData.firstCommand != null)
				{
					ResetCommands(renderChain, ve);
				}
				renderChain.ResetTextures(ve);
				return default(UIRStylePainter.ClosingInfo);
			}
			RenderChainCommand renderChainCommand = ve.renderChainData.firstCommand?.prev;
			RenderChainCommand renderChainCommand2 = ve.renderChainData.lastCommand?.next;
			bool flag4 = ve.renderChainData.firstClosingCommand != null && renderChainCommand2 == ve.renderChainData.firstClosingCommand;
			RenderChainCommand renderChainCommand3;
			RenderChainCommand renderChainCommand4;
			if (flag4)
			{
				renderChainCommand2 = ve.renderChainData.lastClosingCommand.next;
				renderChainCommand3 = (renderChainCommand4 = null);
			}
			else
			{
				renderChainCommand3 = ve.renderChainData.firstClosingCommand?.prev;
				renderChainCommand4 = ve.renderChainData.lastClosingCommand?.next;
			}
			Debug.Assert(renderChainCommand?.owner != ve);
			Debug.Assert(renderChainCommand2?.owner != ve);
			Debug.Assert(renderChainCommand3?.owner != ve);
			Debug.Assert(renderChainCommand4?.owner != ve);
			ResetCommands(renderChain, ve);
			renderChain.ResetTextures(ve);
			UIRStylePainter painter = renderChain.painter;
			painter.Begin(ve);
			if (ve.visible)
			{
				painter.DrawVisualElementBackground();
				painter.DrawVisualElementBorder();
				painter.ApplyVisualElementClipping();
				InvokeGenerateVisualContent(ve, painter.meshGenerationContext);
			}
			else if (flag2 || flag)
			{
				painter.ApplyVisualElementClipping();
			}
			MeshHandle data = ve.renderChainData.data;
			if (painter.totalVertices > device.maxVerticesPerPage)
			{
				Debug.LogError(string.Format("A {0} must not allocate more than {1} vertices.", "VisualElement", device.maxVerticesPerPage));
				if (data != null)
				{
					device.Free(data);
					data = null;
				}
				renderChain.ResetTextures(ve);
				painter.Reset();
				painter.Begin(ve);
			}
			List<UIRStylePainter.Entry> entries = painter.entries;
			if (entries.Count > 0)
			{
				NativeSlice<Vertex> verts = default(NativeSlice<Vertex>);
				NativeSlice<ushort> indices = default(NativeSlice<ushort>);
				ushort indexOffset = 0;
				if (painter.totalVertices > 0)
				{
					UpdateOrAllocate(ref data, painter.totalVertices, painter.totalIndices, device, out verts, out indices, out indexOffset, ref stats);
				}
				int num = 0;
				int num2 = 0;
				RenderChainCommand prev = renderChainCommand;
				RenderChainCommand next = renderChainCommand2;
				if (renderChainCommand == null && renderChainCommand2 == null)
				{
					FindCommandInsertionPoint(ve, out prev, out next);
				}
				bool flag5 = false;
				Matrix4x4 transform = Matrix4x4.identity;
				Color32 xformClipPages = new Color32(0, 0, 0, 0);
				Color32 ids = new Color32(0, 0, 0, 0);
				Color32 addFlags = new Color32(0, 0, 0, 0);
				Color32 opacityPage = new Color32(0, 0, 0, 0);
				Color32 textCoreSettingsPage = new Color32(0, 0, 0, 0);
				int num3 = -1;
				int num4 = -1;
				foreach (UIRStylePainter.Entry entry in painter.entries)
				{
					NativeSlice<Vertex> vertices = entry.vertices;
					if (vertices.Length > 0)
					{
						NativeSlice<ushort> indices2 = entry.indices;
						if (indices2.Length > 0)
						{
							if (!flag5)
							{
								flag5 = true;
								GetVerticesTransformInfo(ve, out transform);
								ve.renderChainData.verticesSpace = transform;
							}
							Color32 color = renderChain.shaderInfoAllocator.TransformAllocToVertexData(ve.renderChainData.transformID);
							Color32 color2 = renderChain.shaderInfoAllocator.OpacityAllocToVertexData(ve.renderChainData.opacityID);
							Color32 color3 = renderChain.shaderInfoAllocator.TextCoreSettingsToVertexData(ve.renderChainData.textCoreSettingsID);
							xformClipPages.r = color.r;
							xformClipPages.g = color.g;
							ids.r = color.b;
							opacityPage.r = color2.r;
							opacityPage.g = color2.g;
							ids.b = color2.b;
							if (entry.isTextEntry)
							{
								textCoreSettingsPage.r = color3.r;
								textCoreSettingsPage.g = color3.g;
								ids.a = color3.b;
							}
							Color32 color4 = renderChain.shaderInfoAllocator.ClipRectAllocToVertexData(entry.clipRectID);
							xformClipPages.b = color4.r;
							xformClipPages.a = color4.g;
							ids.g = color4.b;
							addFlags.r = (byte)entry.addFlags;
							TextureId texture = entry.texture;
							float textureId = texture.ConvertToGpu();
							NativeSlice<Vertex> thisSlice = verts;
							int start = num;
							vertices = entry.vertices;
							NativeSlice<Vertex> nativeSlice = thisSlice.Slice(start, vertices.Length);
							if (entry.uvIsDisplacement)
							{
								if (num3 < 0)
								{
									num3 = num;
									int num5 = num;
									vertices = entry.vertices;
									num4 = num5 + vertices.Length;
								}
								else if (num4 == num)
								{
									int num6 = num4;
									vertices = entry.vertices;
									num4 = num6 + vertices.Length;
								}
								else
								{
									ve.renderChainData.disableNudging = true;
								}
							}
							indices2 = entry.indices;
							int length = indices2.Length;
							int indexOffset2 = num + indexOffset;
							NativeSlice<ushort> nativeSlice2 = indices.Slice(num2, length);
							bool flag6 = UIRUtility.ShapeWindingIsClockwise(entry.maskDepth, entry.stencilRef);
							bool worldFlipsWinding = ve.renderChainData.worldFlipsWinding;
							ConvertMeshJobData job = new ConvertMeshJobData
							{
								vertSrc = (IntPtr)entry.vertices.GetUnsafePtr(),
								vertDst = (IntPtr)nativeSlice.GetUnsafePtr(),
								vertCount = nativeSlice.Length,
								transform = transform,
								transformUVs = (entry.uvIsDisplacement ? 1 : 0),
								xformClipPages = xformClipPages,
								ids = ids,
								addFlags = addFlags,
								opacityPage = opacityPage,
								textCoreSettingsPage = textCoreSettingsPage,
								isText = (entry.isTextEntry ? 1 : 0),
								textureId = textureId,
								indexSrc = (IntPtr)entry.indices.GetUnsafePtr(),
								indexDst = (IntPtr)nativeSlice2.GetUnsafePtr(),
								indexCount = nativeSlice2.Length,
								indexOffset = indexOffset2,
								flipIndices = ((flag6 == worldFlipsWinding) ? 1 : 0)
							};
							renderChain.jobManager.Add(ref job);
							if (entry.isClipRegisterEntry)
							{
								painter.LandClipRegisterMesh(nativeSlice, nativeSlice2, indexOffset2);
							}
							RenderChainCommand renderChainCommand5 = InjectMeshDrawCommand(renderChain, ve, ref prev, ref next, data, length, num2, entry.material, entry.texture, entry.stencilRef);
							if (entry.isTextEntry)
							{
								renderChainCommand5.state.sdfScale = entry.fontTexSDFScale;
							}
							int num7 = num;
							vertices = entry.vertices;
							num = num7 + vertices.Length;
							num2 += length;
							continue;
						}
					}
					if (entry.customCommand != null)
					{
						InjectCommandInBetween(renderChain, entry.customCommand, ref prev, ref next);
					}
					else
					{
						Debug.Assert(condition: false);
					}
				}
				if (!ve.renderChainData.disableNudging && num3 >= 0)
				{
					ve.renderChainData.displacementUVStart = num3;
					ve.renderChainData.displacementUVEnd = num4;
				}
			}
			else if (data != null)
			{
				device.Free(data);
				data = null;
			}
			ve.renderChainData.data = data;
			if (painter.closingInfo.clipperRegisterIndices.Length == 0 && ve.renderChainData.closingData != null)
			{
				device.Free(ve.renderChainData.closingData);
				ve.renderChainData.closingData = null;
			}
			if (painter.closingInfo.needsClosing)
			{
				RenderChainCommand prev2 = renderChainCommand3;
				RenderChainCommand next2 = renderChainCommand4;
				if (flag4)
				{
					prev2 = ve.renderChainData.lastCommand;
					next2 = prev2.next;
				}
				else if (prev2 == null && next2 == null)
				{
					FindClosingCommandInsertionPoint(ve, out prev2, out next2);
				}
				if (painter.closingInfo.PopDefaultMaterial)
				{
					RenderChainCommand renderChainCommand6 = renderChain.AllocCommand();
					renderChainCommand6.type = CommandType.PopDefaultMaterial;
					renderChainCommand6.closing = true;
					renderChainCommand6.owner = ve;
					InjectClosingCommandInBetween(renderChain, renderChainCommand6, ref prev2, ref next2);
				}
				if (painter.closingInfo.blitAndPopRenderTexture)
				{
					RenderChainCommand renderChainCommand7 = renderChain.AllocCommand();
					renderChainCommand7.type = CommandType.BlitToPreviousRT;
					renderChainCommand7.closing = true;
					renderChainCommand7.owner = ve;
					renderChainCommand7.state.material = GetBlitMaterial(ve.subRenderTargetMode);
					Debug.Assert(renderChainCommand7.state.material != null);
					InjectClosingCommandInBetween(renderChain, renderChainCommand7, ref prev2, ref next2);
					RenderChainCommand renderChainCommand8 = renderChain.AllocCommand();
					renderChainCommand8.type = CommandType.PopRenderTexture;
					renderChainCommand8.closing = true;
					renderChainCommand8.owner = ve;
					InjectClosingCommandInBetween(renderChain, renderChainCommand8, ref prev2, ref next2);
				}
				if (painter.closingInfo.clipperRegisterIndices.Length > 0)
				{
					RenderChainCommand cmd = InjectClosingMeshDrawCommand(renderChain, ve, ref prev2, ref next2, null, 0, 0, null, TextureId.invalid, painter.closingInfo.maskStencilRef);
					painter.LandClipUnregisterMeshDrawCommand(cmd);
				}
				if (painter.closingInfo.popViewMatrix)
				{
					RenderChainCommand renderChainCommand9 = renderChain.AllocCommand();
					renderChainCommand9.type = CommandType.PopView;
					renderChainCommand9.closing = true;
					renderChainCommand9.owner = ve;
					InjectClosingCommandInBetween(renderChain, renderChainCommand9, ref prev2, ref next2);
				}
				if (painter.closingInfo.popScissorClip)
				{
					RenderChainCommand renderChainCommand10 = renderChain.AllocCommand();
					renderChainCommand10.type = CommandType.PopScissor;
					renderChainCommand10.closing = true;
					renderChainCommand10.owner = ve;
					InjectClosingCommandInBetween(renderChain, renderChainCommand10, ref prev2, ref next2);
				}
			}
			Debug.Assert(ve.renderChainData.closingData == null || ve.renderChainData.data != null);
			UIRStylePainter.ClosingInfo closingInfo = painter.closingInfo;
			painter.Reset();
			return closingInfo;
		}

		private static void InvokeGenerateVisualContent(VisualElement ve, MeshGenerationContext ctx)
		{
			Painter2D.isPainterActive = true;
			ve.InvokeGenerateVisualContent(ctx);
			Painter2D.isPainterActive = false;
		}

		private static Material CreateBlitShader(float colorConversion)
		{
			if (s_blitShader == null)
			{
				s_blitShader = Shader.Find(Shaders.k_ColorConversionBlit);
			}
			Debug.Assert(s_blitShader != null, "UI Tollkit Render Event: Shader Not found");
			Material material = new Material(s_blitShader);
			material.hideFlags |= HideFlags.DontSaveInEditor;
			material.SetFloat("_ColorConversion", colorConversion);
			return material;
		}

		private static Material GetBlitMaterial(VisualElement.RenderTargetMode mode)
		{
			switch (mode)
			{
			case VisualElement.RenderTargetMode.GammaToLinear:
				if (s_blitMaterial_GammaToLinear == null)
				{
					s_blitMaterial_GammaToLinear = CreateBlitShader(-1f);
				}
				return s_blitMaterial_GammaToLinear;
			case VisualElement.RenderTargetMode.LinearToGamma:
				if (s_blitMaterial_LinearToGamma == null)
				{
					s_blitMaterial_LinearToGamma = CreateBlitShader(1f);
				}
				return s_blitMaterial_LinearToGamma;
			case VisualElement.RenderTargetMode.NoColorConversion:
				if (s_blitMaterial_NoChange == null)
				{
					s_blitMaterial_NoChange = CreateBlitShader(0f);
				}
				return s_blitMaterial_NoChange;
			default:
				Debug.LogError($"No Shader for Unsupported RenderTargetMode: {mode}");
				return null;
			}
		}

		public unsafe static void ClosePaintElement(VisualElement ve, UIRStylePainter.ClosingInfo closingInfo, RenderChain renderChain, ref ChainBuilderStats stats)
		{
			if (closingInfo.clipperRegisterIndices.Length > 0)
			{
				NativeSlice<Vertex> verts = default(NativeSlice<Vertex>);
				NativeSlice<ushort> indices = default(NativeSlice<ushort>);
				ushort indexOffset = 0;
				UpdateOrAllocate(ref ve.renderChainData.closingData, closingInfo.clipperRegisterVertices.Length, closingInfo.clipperRegisterIndices.Length, renderChain.device, out verts, out indices, out indexOffset, ref stats);
				CopyClosingMeshJobData job = new CopyClosingMeshJobData
				{
					vertSrc = (IntPtr)closingInfo.clipperRegisterVertices.GetUnsafePtr(),
					vertDst = (IntPtr)verts.GetUnsafePtr(),
					vertCount = verts.Length,
					indexSrc = (IntPtr)closingInfo.clipperRegisterIndices.GetUnsafePtr(),
					indexDst = (IntPtr)indices.GetUnsafePtr(),
					indexCount = indices.Length,
					indexOffset = indexOffset - closingInfo.clipperRegisterIndexOffset
				};
				renderChain.jobManager.Add(ref job);
				closingInfo.clipUnregisterDrawCommand.mesh = ve.renderChainData.closingData;
				closingInfo.clipUnregisterDrawCommand.indexCount = indices.Length;
			}
		}

		private static void UpdateOrAllocate(ref MeshHandle data, int vertexCount, int indexCount, UIRenderDevice device, out NativeSlice<Vertex> verts, out NativeSlice<ushort> indices, out ushort indexOffset, ref ChainBuilderStats stats)
		{
			if (data != null)
			{
				if (data.allocVerts.size >= vertexCount && data.allocIndices.size >= indexCount)
				{
					device.Update(data, (uint)vertexCount, (uint)indexCount, out verts, out indices, out indexOffset);
					stats.updatedMeshAllocations++;
				}
				else
				{
					device.Free(data);
					data = device.Allocate((uint)vertexCount, (uint)indexCount, out verts, out indices, out indexOffset);
					stats.newMeshAllocations++;
				}
			}
			else
			{
				data = device.Allocate((uint)vertexCount, (uint)indexCount, out verts, out indices, out indexOffset);
				stats.newMeshAllocations++;
			}
		}

		private static void CopyTriangleIndicesFlipWindingOrder(NativeSlice<ushort> source, NativeSlice<ushort> target, int indexOffset)
		{
			Debug.Assert(source != target);
			int length = source.Length;
			for (int i = 0; i < length; i += 3)
			{
				ushort value = (ushort)(source[i] + indexOffset);
				target[i] = (ushort)(source[i + 1] + indexOffset);
				target[i + 1] = value;
				target[i + 2] = (ushort)(source[i + 2] + indexOffset);
			}
		}

		private static void CopyTriangleIndices(NativeSlice<ushort> source, NativeSlice<ushort> target, int indexOffset)
		{
			int length = source.Length;
			for (int i = 0; i < length; i++)
			{
				target[i] = (ushort)(source[i] + indexOffset);
			}
		}

		public static void UpdateOpacityId(VisualElement ve, RenderChain renderChain)
		{
			if (ve.renderChainData.data != null)
			{
				DoUpdateOpacityId(ve, renderChain, ve.renderChainData.data);
			}
			if (ve.renderChainData.closingData != null)
			{
				DoUpdateOpacityId(ve, renderChain, ve.renderChainData.closingData);
			}
		}

		private static void DoUpdateOpacityId(VisualElement ve, RenderChain renderChain, MeshHandle mesh)
		{
			int size = (int)mesh.allocVerts.size;
			NativeSlice<Vertex> oldVerts = mesh.allocPage.vertices.cpuData.Slice((int)mesh.allocVerts.start, size);
			renderChain.device.Update(mesh, (uint)size, out var vertexData);
			Color32 opacityData = renderChain.shaderInfoAllocator.OpacityAllocToVertexData(ve.renderChainData.opacityID);
			renderChain.opacityIdAccelerator.CreateJob(oldVerts, vertexData, opacityData, size);
		}

		public static bool NudgeVerticesToNewSpace(VisualElement ve, RenderChain renderChain, UIRenderDevice device)
		{
			Debug.Assert(!ve.renderChainData.disableNudging);
			GetVerticesTransformInfo(ve, out var transform);
			Matrix4x4 matrix4x = transform * ve.renderChainData.verticesSpace.inverse;
			Matrix4x4 matrix4x2 = matrix4x * ve.renderChainData.verticesSpace;
			float num = Mathf.Abs(transform.m00 - matrix4x2.m00);
			num += Mathf.Abs(transform.m01 - matrix4x2.m01);
			num += Mathf.Abs(transform.m02 - matrix4x2.m02);
			num += Mathf.Abs(transform.m03 - matrix4x2.m03);
			num += Mathf.Abs(transform.m10 - matrix4x2.m10);
			num += Mathf.Abs(transform.m11 - matrix4x2.m11);
			num += Mathf.Abs(transform.m12 - matrix4x2.m12);
			num += Mathf.Abs(transform.m13 - matrix4x2.m13);
			num += Mathf.Abs(transform.m20 - matrix4x2.m20);
			num += Mathf.Abs(transform.m21 - matrix4x2.m21);
			num += Mathf.Abs(transform.m22 - matrix4x2.m22);
			num += Mathf.Abs(transform.m23 - matrix4x2.m23);
			if (num > 0.0001f)
			{
				return false;
			}
			ve.renderChainData.verticesSpace = transform;
			NudgeJobData job = new NudgeJobData
			{
				vertsBeforeUVDisplacement = ve.renderChainData.displacementUVStart,
				vertsAfterUVDisplacement = ve.renderChainData.displacementUVEnd,
				transform = matrix4x
			};
			PrepareNudgeVertices(ve, device, ve.renderChainData.data, out job.src, out job.dst, out job.count);
			if (ve.renderChainData.closingData != null)
			{
				PrepareNudgeVertices(ve, device, ve.renderChainData.closingData, out job.closingSrc, out job.closingDst, out job.closingCount);
			}
			renderChain.jobManager.Add(ref job);
			return true;
		}

		private unsafe static void PrepareNudgeVertices(VisualElement ve, UIRenderDevice device, MeshHandle mesh, out IntPtr src, out IntPtr dst, out int count)
		{
			int size = (int)mesh.allocVerts.size;
			NativeSlice<Vertex> nativeSlice = mesh.allocPage.vertices.cpuData.Slice((int)mesh.allocVerts.start, size);
			device.Update(mesh, (uint)size, out var vertexData);
			src = (IntPtr)nativeSlice.GetUnsafePtr();
			dst = (IntPtr)vertexData.GetUnsafePtr();
			count = size;
		}

		private static RenderChainCommand InjectMeshDrawCommand(RenderChain renderChain, VisualElement ve, ref RenderChainCommand cmdPrev, ref RenderChainCommand cmdNext, MeshHandle mesh, int indexCount, int indexOffset, Material material, TextureId texture, int stencilRef)
		{
			RenderChainCommand renderChainCommand = renderChain.AllocCommand();
			renderChainCommand.type = CommandType.Draw;
			renderChainCommand.state = new State
			{
				material = material,
				texture = texture,
				stencilRef = stencilRef
			};
			renderChainCommand.mesh = mesh;
			renderChainCommand.indexOffset = indexOffset;
			renderChainCommand.indexCount = indexCount;
			renderChainCommand.owner = ve;
			InjectCommandInBetween(renderChain, renderChainCommand, ref cmdPrev, ref cmdNext);
			return renderChainCommand;
		}

		private static RenderChainCommand InjectClosingMeshDrawCommand(RenderChain renderChain, VisualElement ve, ref RenderChainCommand cmdPrev, ref RenderChainCommand cmdNext, MeshHandle mesh, int indexCount, int indexOffset, Material material, TextureId texture, int stencilRef)
		{
			RenderChainCommand renderChainCommand = renderChain.AllocCommand();
			renderChainCommand.type = CommandType.Draw;
			renderChainCommand.closing = true;
			renderChainCommand.state = new State
			{
				material = material,
				texture = texture,
				stencilRef = stencilRef
			};
			renderChainCommand.mesh = mesh;
			renderChainCommand.indexOffset = indexOffset;
			renderChainCommand.indexCount = indexCount;
			renderChainCommand.owner = ve;
			InjectClosingCommandInBetween(renderChain, renderChainCommand, ref cmdPrev, ref cmdNext);
			return renderChainCommand;
		}

		private static void FindCommandInsertionPoint(VisualElement ve, out RenderChainCommand prev, out RenderChainCommand next)
		{
			VisualElement prev2 = ve.renderChainData.prev;
			while (prev2 != null && prev2.renderChainData.lastCommand == null)
			{
				prev2 = prev2.renderChainData.prev;
			}
			if (prev2 != null && prev2.renderChainData.lastCommand != null)
			{
				if (prev2.hierarchy.parent == ve.hierarchy.parent)
				{
					prev = prev2.renderChainData.lastClosingOrLastCommand;
				}
				else if (prev2.IsParentOrAncestorOf(ve))
				{
					prev = prev2.renderChainData.lastCommand;
				}
				else
				{
					RenderChainCommand renderChainCommand = prev2.renderChainData.lastClosingOrLastCommand;
					do
					{
						prev = renderChainCommand;
						renderChainCommand = renderChainCommand.next;
					}
					while (renderChainCommand != null && renderChainCommand.owner != ve && renderChainCommand.closing && !renderChainCommand.owner.IsParentOrAncestorOf(ve));
				}
				next = prev.next;
			}
			else
			{
				VisualElement next2 = ve.renderChainData.next;
				while (next2 != null && next2.renderChainData.firstCommand == null)
				{
					next2 = next2.renderChainData.next;
				}
				next = next2?.renderChainData.firstCommand;
				prev = null;
				Debug.Assert(next == null || next.prev == null);
			}
		}

		private static void FindClosingCommandInsertionPoint(VisualElement ve, out RenderChainCommand prev, out RenderChainCommand next)
		{
			VisualElement visualElement = ve.renderChainData.next;
			while (visualElement != null && visualElement.renderChainData.firstCommand == null)
			{
				visualElement = visualElement.renderChainData.next;
			}
			if (visualElement != null && visualElement.renderChainData.firstCommand != null)
			{
				if (visualElement.hierarchy.parent == ve.hierarchy.parent)
				{
					next = visualElement.renderChainData.firstCommand;
					prev = next.prev;
				}
				else if (ve.IsParentOrAncestorOf(visualElement))
				{
					do
					{
						prev = visualElement.renderChainData.lastClosingOrLastCommand;
						visualElement = prev.next?.owner;
					}
					while (visualElement != null && ve.IsParentOrAncestorOf(visualElement));
					next = prev.next;
				}
				else
				{
					prev = ve.renderChainData.lastCommand;
					next = prev.next;
				}
			}
			else
			{
				prev = ve.renderChainData.lastCommand;
				next = prev.next;
			}
		}

		private static void InjectCommandInBetween(RenderChain renderChain, RenderChainCommand cmd, ref RenderChainCommand prev, ref RenderChainCommand next)
		{
			if (prev != null)
			{
				cmd.prev = prev;
				prev.next = cmd;
			}
			if (next != null)
			{
				cmd.next = next;
				next.prev = cmd;
			}
			VisualElement owner = cmd.owner;
			owner.renderChainData.lastCommand = cmd;
			if (owner.renderChainData.firstCommand == null)
			{
				owner.renderChainData.firstCommand = cmd;
			}
			renderChain.OnRenderCommandAdded(cmd);
			prev = cmd;
			next = cmd.next;
		}

		private static void InjectClosingCommandInBetween(RenderChain renderChain, RenderChainCommand cmd, ref RenderChainCommand prev, ref RenderChainCommand next)
		{
			Debug.Assert(cmd.closing);
			if (prev != null)
			{
				cmd.prev = prev;
				prev.next = cmd;
			}
			if (next != null)
			{
				cmd.next = next;
				next.prev = cmd;
			}
			VisualElement owner = cmd.owner;
			owner.renderChainData.lastClosingCommand = cmd;
			if (owner.renderChainData.firstClosingCommand == null)
			{
				owner.renderChainData.firstClosingCommand = cmd;
			}
			renderChain.OnRenderCommandAdded(cmd);
			prev = cmd;
			next = cmd.next;
		}

		public static void ResetCommands(RenderChain renderChain, VisualElement ve)
		{
			if (ve.renderChainData.firstCommand != null)
			{
				renderChain.OnRenderCommandsRemoved(ve.renderChainData.firstCommand, ve.renderChainData.lastCommand);
			}
			RenderChainCommand renderChainCommand = ((ve.renderChainData.firstCommand != null) ? ve.renderChainData.firstCommand.prev : null);
			RenderChainCommand renderChainCommand2 = ((ve.renderChainData.lastCommand != null) ? ve.renderChainData.lastCommand.next : null);
			Debug.Assert(renderChainCommand == null || renderChainCommand.owner != ve);
			Debug.Assert(renderChainCommand2 == null || renderChainCommand2 == ve.renderChainData.firstClosingCommand || renderChainCommand2.owner != ve);
			if (renderChainCommand != null)
			{
				renderChainCommand.next = renderChainCommand2;
			}
			if (renderChainCommand2 != null)
			{
				renderChainCommand2.prev = renderChainCommand;
			}
			if (ve.renderChainData.firstCommand != null)
			{
				RenderChainCommand renderChainCommand3 = ve.renderChainData.firstCommand;
				while (renderChainCommand3 != ve.renderChainData.lastCommand)
				{
					RenderChainCommand next = renderChainCommand3.next;
					renderChain.FreeCommand(renderChainCommand3);
					renderChainCommand3 = next;
				}
				renderChain.FreeCommand(renderChainCommand3);
			}
			ve.renderChainData.firstCommand = (ve.renderChainData.lastCommand = null);
			renderChainCommand = ((ve.renderChainData.firstClosingCommand != null) ? ve.renderChainData.firstClosingCommand.prev : null);
			renderChainCommand2 = ((ve.renderChainData.lastClosingCommand != null) ? ve.renderChainData.lastClosingCommand.next : null);
			Debug.Assert(renderChainCommand == null || renderChainCommand.owner != ve);
			Debug.Assert(renderChainCommand2 == null || renderChainCommand2.owner != ve);
			if (renderChainCommand != null)
			{
				renderChainCommand.next = renderChainCommand2;
			}
			if (renderChainCommand2 != null)
			{
				renderChainCommand2.prev = renderChainCommand;
			}
			if (ve.renderChainData.firstClosingCommand != null)
			{
				renderChain.OnRenderCommandsRemoved(ve.renderChainData.firstClosingCommand, ve.renderChainData.lastClosingCommand);
				RenderChainCommand renderChainCommand4 = ve.renderChainData.firstClosingCommand;
				while (renderChainCommand4 != ve.renderChainData.lastClosingCommand)
				{
					RenderChainCommand next2 = renderChainCommand4.next;
					renderChain.FreeCommand(renderChainCommand4);
					renderChainCommand4 = next2;
				}
				renderChain.FreeCommand(renderChainCommand4);
			}
			ve.renderChainData.firstClosingCommand = (ve.renderChainData.lastClosingCommand = null);
		}
	}
	internal enum ClipMethod
	{
		Undetermined,
		NotClipped,
		Scissor,
		ShaderDiscard,
		Stencil
	}
	internal static class RenderEvents
	{
		private static readonly float VisibilityTreshold = 1E-30f;

		internal static void ProcessOnClippingChanged(RenderChain renderChain, VisualElement ve, uint dirtyID, ref ChainBuilderStats stats)
		{
			bool flag = (ve.renderChainData.dirtiedValues & RenderDataDirtyTypes.ClippingHierarchy) != 0;
			if (flag)
			{
				stats.recursiveClipUpdates++;
			}
			else
			{
				stats.nonRecursiveClipUpdates++;
			}
			DepthFirstOnClippingChanged(renderChain, ve.hierarchy.parent, ve, dirtyID, flag, isRootOfChange: true, isPendingHierarchicalRepaint: false, inheritedClipRectIDChanged: false, inheritedMaskingChanged: false, renderChain.device, ref stats);
		}

		internal static void ProcessOnOpacityChanged(RenderChain renderChain, VisualElement ve, uint dirtyID, ref ChainBuilderStats stats)
		{
			bool hierarchical = (ve.renderChainData.dirtiedValues & RenderDataDirtyTypes.OpacityHierarchy) != 0;
			stats.recursiveOpacityUpdates++;
			DepthFirstOnOpacityChanged(renderChain, (ve.hierarchy.parent != null) ? ve.hierarchy.parent.renderChainData.compositeOpacity : 1f, ve, dirtyID, hierarchical, ref stats);
		}

		internal static void ProcessOnColorChanged(RenderChain renderChain, VisualElement ve, uint dirtyID, ref ChainBuilderStats stats)
		{
			stats.colorUpdates++;
			OnColorChanged(renderChain, ve, dirtyID, ref stats);
		}

		internal static void ProcessOnTransformOrSizeChanged(RenderChain renderChain, VisualElement ve, uint dirtyID, ref ChainBuilderStats stats)
		{
			stats.recursiveTransformUpdates++;
			DepthFirstOnTransformOrSizeChanged(renderChain, ve.hierarchy.parent, ve, dirtyID, renderChain.device, isAncestorOfChangeSkinned: false, transformChanged: false, ref stats);
		}

		internal static void ProcessOnVisualsChanged(RenderChain renderChain, VisualElement ve, uint dirtyID, ref ChainBuilderStats stats)
		{
			bool flag = (ve.renderChainData.dirtiedValues & RenderDataDirtyTypes.VisualsHierarchy) != 0;
			if (flag)
			{
				stats.recursiveVisualUpdates++;
			}
			else
			{
				stats.nonRecursiveVisualUpdates++;
			}
			VisualElement parent = ve.hierarchy.parent;
			bool parentHierarchyHidden = parent != null && (parent.renderChainData.isHierarchyHidden || IsElementHierarchyHidden(parent));
			DepthFirstOnVisualsChanged(renderChain, ve, dirtyID, parentHierarchyHidden, flag, ref stats);
		}

		private static Matrix4x4 GetTransformIDTransformInfo(VisualElement ve)
		{
			Debug.Assert(RenderChainVEData.AllocatesID(ve.renderChainData.transformID) || (ve.renderHints & RenderHints.GroupTransform) != 0);
			Matrix4x4 res;
			if (ve.renderChainData.groupTransformAncestor != null)
			{
				VisualElement.MultiplyMatrix34(ref ve.renderChainData.groupTransformAncestor.worldTransformInverse, ref ve.worldTransformRef, out res);
			}
			else
			{
				res = ve.worldTransform;
			}
			res.m22 = 1f;
			return res;
		}

		private static Vector4 GetClipRectIDClipInfo(VisualElement ve)
		{
			Debug.Assert(RenderChainVEData.AllocatesID(ve.renderChainData.clipRectID));
			Rect rect;
			if (ve.renderChainData.groupTransformAncestor == null)
			{
				rect = ve.worldClip;
			}
			else
			{
				rect = ve.worldClipMinusGroup;
				VisualElement.TransformAlignedRect(ref ve.renderChainData.groupTransformAncestor.worldTransformInverse, ref rect);
			}
			Vector2 min = rect.min;
			Vector2 max = rect.max;
			Vector2 vector = max - min;
			Vector2 vector2 = new Vector2(1f / (vector.x + 0.0001f), 1f / (vector.y + 0.0001f));
			Vector2 vector3 = 2f * vector2;
			Vector2 vector4 = -(min + max) * vector2;
			return new Vector4(vector3.x, vector3.y, vector4.x, vector4.y);
		}

		internal static uint DepthFirstOnChildAdded(RenderChain renderChain, VisualElement parent, VisualElement ve, int index, bool resetState)
		{
			Debug.Assert(ve.panel != null);
			if (ve.renderChainData.isInChain)
			{
				return 0u;
			}
			if (resetState)
			{
				ve.renderChainData = default(RenderChainVEData);
			}
			ve.renderChainData.isInChain = true;
			ve.renderChainData.verticesSpace = Matrix4x4.identity;
			ve.renderChainData.transformID = UIRVEShaderInfoAllocator.identityTransform;
			ve.renderChainData.clipRectID = UIRVEShaderInfoAllocator.infiniteClipRect;
			ve.renderChainData.opacityID = UIRVEShaderInfoAllocator.fullOpacity;
			ve.renderChainData.colorID = BMPAlloc.Invalid;
			ve.renderChainData.backgroundColorID = BMPAlloc.Invalid;
			ve.renderChainData.borderLeftColorID = BMPAlloc.Invalid;
			ve.renderChainData.borderTopColorID = BMPAlloc.Invalid;
			ve.renderChainData.borderRightColorID = BMPAlloc.Invalid;
			ve.renderChainData.borderBottomColorID = BMPAlloc.Invalid;
			ve.renderChainData.tintColorID = BMPAlloc.Invalid;
			ve.renderChainData.textCoreSettingsID = UIRVEShaderInfoAllocator.defaultTextCoreSettings;
			ve.renderChainData.compositeOpacity = float.MaxValue;
			UpdateLocalFlipsWinding(ve);
			if (parent != null)
			{
				if ((parent.renderHints & RenderHints.GroupTransform) != RenderHints.None)
				{
					ve.renderChainData.groupTransformAncestor = parent;
				}
				else
				{
					ve.renderChainData.groupTransformAncestor = parent.renderChainData.groupTransformAncestor;
				}
				ve.renderChainData.hierarchyDepth = parent.renderChainData.hierarchyDepth + 1;
			}
			else
			{
				ve.renderChainData.groupTransformAncestor = null;
				ve.renderChainData.hierarchyDepth = 0;
			}
			renderChain.EnsureFitsDepth(ve.renderChainData.hierarchyDepth);
			if (index > 0)
			{
				Debug.Assert(parent != null);
				ve.renderChainData.prev = GetLastDeepestChild(parent.hierarchy[index - 1]);
			}
			else
			{
				ve.renderChainData.prev = parent;
			}
			ve.renderChainData.next = ((ve.renderChainData.prev != null) ? ve.renderChainData.prev.renderChainData.next : null);
			if (ve.renderChainData.prev != null)
			{
				ve.renderChainData.prev.renderChainData.next = ve;
			}
			if (ve.renderChainData.next != null)
			{
				ve.renderChainData.next.renderChainData.prev = ve;
			}
			Debug.Assert(!RenderChainVEData.AllocatesID(ve.renderChainData.transformID));
			if (NeedsTransformID(ve))
			{
				ve.renderChainData.transformID = renderChain.shaderInfoAllocator.AllocTransform();
			}
			else
			{
				ve.renderChainData.transformID = BMPAlloc.Invalid;
			}
			ve.renderChainData.boneTransformAncestor = null;
			if (NeedsColorID(ve))
			{
				InitColorIDs(renderChain, ve);
				SetColorValues(renderChain, ve);
			}
			if (!RenderChainVEData.AllocatesID(ve.renderChainData.transformID))
			{
				if (parent != null && (ve.renderHints & RenderHints.GroupTransform) == 0)
				{
					if (RenderChainVEData.AllocatesID(parent.renderChainData.transformID))
					{
						ve.renderChainData.boneTransformAncestor = parent;
					}
					else
					{
						ve.renderChainData.boneTransformAncestor = parent.renderChainData.boneTransformAncestor;
					}
					ve.renderChainData.transformID = parent.renderChainData.transformID;
					ve.renderChainData.transformID.ownedState = OwnedState.Inherited;
				}
				else
				{
					ve.renderChainData.transformID = UIRVEShaderInfoAllocator.identityTransform;
				}
			}
			else
			{
				renderChain.shaderInfoAllocator.SetTransformValue(ve.renderChainData.transformID, GetTransformIDTransformInfo(ve));
			}
			int childCount = ve.hierarchy.childCount;
			uint num = 0u;
			for (int i = 0; i < childCount; i++)
			{
				num += DepthFirstOnChildAdded(renderChain, ve, ve.hierarchy[i], i, resetState);
			}
			return 1 + num;
		}

		internal static uint DepthFirstOnChildRemoving(RenderChain renderChain, VisualElement ve)
		{
			int num = ve.hierarchy.childCount - 1;
			uint num2 = 0u;
			while (num >= 0)
			{
				num2 += DepthFirstOnChildRemoving(renderChain, ve.hierarchy[num--]);
			}
			if (ve.renderChainData.isInChain)
			{
				renderChain.ChildWillBeRemoved(ve);
				CommandGenerator.ResetCommands(renderChain, ve);
				renderChain.ResetTextures(ve);
				ve.renderChainData.isInChain = false;
				ve.renderChainData.clipMethod = ClipMethod.Undetermined;
				if (ve.renderChainData.next != null)
				{
					ve.renderChainData.next.renderChainData.prev = ve.renderChainData.prev;
				}
				if (ve.renderChainData.prev != null)
				{
					ve.renderChainData.prev.renderChainData.next = ve.renderChainData.next;
				}
				if (RenderChainVEData.AllocatesID(ve.renderChainData.textCoreSettingsID))
				{
					renderChain.shaderInfoAllocator.FreeTextCoreSettings(ve.renderChainData.textCoreSettingsID);
					ve.renderChainData.textCoreSettingsID = UIRVEShaderInfoAllocator.defaultTextCoreSettings;
				}
				if (RenderChainVEData.AllocatesID(ve.renderChainData.opacityID))
				{
					renderChain.shaderInfoAllocator.FreeOpacity(ve.renderChainData.opacityID);
					ve.renderChainData.opacityID = UIRVEShaderInfoAllocator.fullOpacity;
				}
				if (RenderChainVEData.AllocatesID(ve.renderChainData.colorID))
				{
					renderChain.shaderInfoAllocator.FreeColor(ve.renderChainData.colorID);
					ve.renderChainData.colorID = BMPAlloc.Invalid;
				}
				if (RenderChainVEData.AllocatesID(ve.renderChainData.backgroundColorID))
				{
					renderChain.shaderInfoAllocator.FreeColor(ve.renderChainData.backgroundColorID);
					ve.renderChainData.backgroundColorID = BMPAlloc.Invalid;
				}
				if (RenderChainVEData.AllocatesID(ve.renderChainData.borderLeftColorID))
				{
					renderChain.shaderInfoAllocator.FreeColor(ve.renderChainData.borderLeftColorID);
					ve.renderChainData.borderLeftColorID = BMPAlloc.Invalid;
				}
				if (RenderChainVEData.AllocatesID(ve.renderChainData.borderTopColorID))
				{
					renderChain.shaderInfoAllocator.FreeColor(ve.renderChainData.borderTopColorID);
					ve.renderChainData.borderTopColorID = BMPAlloc.Invalid;
				}
				if (RenderChainVEData.AllocatesID(ve.renderChainData.borderRightColorID))
				{
					renderChain.shaderInfoAllocator.FreeColor(ve.renderChainData.borderRightColorID);
					ve.renderChainData.borderRightColorID = BMPAlloc.Invalid;
				}
				if (RenderChainVEData.AllocatesID(ve.renderChainData.borderBottomColorID))
				{
					renderChain.shaderInfoAllocator.FreeColor(ve.renderChainData.borderBottomColorID);
					ve.renderChainData.borderBottomColorID = BMPAlloc.Invalid;
				}
				if (RenderChainVEData.AllocatesID(ve.renderChainData.tintColorID))
				{
					renderChain.shaderInfoAllocator.FreeColor(ve.renderChainData.tintColorID);
					ve.renderChainData.tintColorID = BMPAlloc.Invalid;
				}
				if (RenderChainVEData.AllocatesID(ve.renderChainData.clipRectID))
				{
					renderChain.shaderInfoAllocator.FreeClipRect(ve.renderChainData.clipRectID);
					ve.renderChainData.clipRectID = UIRVEShaderInfoAllocator.infiniteClipRect;
				}
				if (RenderChainVEData.AllocatesID(ve.renderChainData.transformID))
				{
					renderChain.shaderInfoAllocator.FreeTransform(ve.renderChainData.transformID);
					ve.renderChainData.transformID = UIRVEShaderInfoAllocator.identityTransform;
				}
				ve.renderChainData.boneTransformAncestor = (ve.renderChainData.groupTransformAncestor = null);
				if (ve.renderChainData.closingData != null)
				{
					renderChain.device.Free(ve.renderChainData.closingData);
					ve.renderChainData.closingData = null;
				}
				if (ve.renderChainData.data != null)
				{
					renderChain.device.Free(ve.renderChainData.data);
					ve.renderChainData.data = null;
				}
			}
			ve.renderChainData.prev = null;
			ve.renderChainData.next = null;
			return num2 + 1;
		}

		private static void DepthFirstOnClippingChanged(RenderChain renderChain, VisualElement parent, VisualElement ve, uint dirtyID, bool hierarchical, bool isRootOfChange, bool isPendingHierarchicalRepaint, bool inheritedClipRectIDChanged, bool inheritedMaskingChanged, UIRenderDevice device, ref ChainBuilderStats stats)
		{
			if (dirtyID == ve.renderChainData.dirtyID && !inheritedClipRectIDChanged && !inheritedMaskingChanged)
			{
				return;
			}
			ve.renderChainData.dirtyID = dirtyID;
			if (!isRootOfChange)
			{
				stats.recursiveClipUpdatesExpanded++;
			}
			isPendingHierarchicalRepaint |= (ve.renderChainData.dirtiedValues & RenderDataDirtyTypes.VisualsHierarchy) != 0;
			bool flag = hierarchical || isRootOfChange || inheritedClipRectIDChanged;
			bool flag2 = hierarchical || isRootOfChange;
			bool flag3 = hierarchical || isRootOfChange || inheritedMaskingChanged;
			bool flag4 = false;
			bool flag5 = false;
			bool flag6 = false;
			bool flag7 = hierarchical;
			ClipMethod clipMethod = ve.renderChainData.clipMethod;
			ClipMethod clipMethod2 = (flag2 ? DetermineSelfClipMethod(renderChain, ve) : clipMethod);
			bool flag8 = false;
			if (flag)
			{
				BMPAlloc bMPAlloc = ve.renderChainData.clipRectID;
				if (clipMethod2 == ClipMethod.ShaderDiscard)
				{
					if (!RenderChainVEData.AllocatesID(ve.renderChainData.clipRectID))
					{
						bMPAlloc = renderChain.shaderInfoAllocator.AllocClipRect();
						if (!bMPAlloc.IsValid())
						{
							clipMethod2 = ClipMethod.Scissor;
							bMPAlloc = UIRVEShaderInfoAllocator.infiniteClipRect;
						}
					}
				}
				else
				{
					if (RenderChainVEData.AllocatesID(ve.renderChainData.clipRectID))
					{
						renderChain.shaderInfoAllocator.FreeClipRect(ve.renderChainData.clipRectID);
					}
					if ((ve.renderHints & RenderHints.GroupTransform) == 0)
					{
						bMPAlloc = ((clipMethod2 != ClipMethod.Scissor && parent != null) ? parent.renderChainData.clipRectID : UIRVEShaderInfoAllocator.infiniteClipRect);
						bMPAlloc.ownedState = OwnedState.Inherited;
					}
				}
				flag8 = !ve.renderChainData.clipRectID.Equals(bMPAlloc);
				Debug.Assert((ve.renderHints & RenderHints.GroupTransform) == 0 || !flag8);
				ve.renderChainData.clipRectID = bMPAlloc;
			}
			bool flag9 = false;
			if (clipMethod != clipMethod2)
			{
				ve.renderChainData.clipMethod = clipMethod2;
				if (clipMethod == ClipMethod.Stencil || clipMethod2 == ClipMethod.Stencil)
				{
					flag9 = true;
					flag3 = true;
				}
				if (clipMethod == ClipMethod.Scissor || clipMethod2 == ClipMethod.Scissor)
				{
					flag4 = true;
				}
				if (clipMethod2 == ClipMethod.ShaderDiscard || (clipMethod == ClipMethod.ShaderDiscard && RenderChainVEData.AllocatesID(ve.renderChainData.clipRectID)))
				{
					flag6 = true;
				}
			}
			if (flag8)
			{
				flag7 = true;
				flag5 = true;
			}
			if (flag3)
			{
				int num = 0;
				int num2 = 0;
				if (parent != null)
				{
					num = parent.renderChainData.childrenMaskDepth;
					num2 = parent.renderChainData.childrenStencilRef;
					if (clipMethod2 == ClipMethod.Stencil)
					{
						if (num > num2)
						{
							num2++;
						}
						num++;
					}
					if ((ve.renderHints & RenderHints.MaskContainer) == RenderHints.MaskContainer && num < 7)
					{
						num2 = num;
					}
				}
				if (ve.renderChainData.childrenMaskDepth != num || ve.renderChainData.childrenStencilRef != num2)
				{
					flag9 = true;
				}
				ve.renderChainData.childrenMaskDepth = num;
				ve.renderChainData.childrenStencilRef = num2;
			}
			if (flag9)
			{
				flag7 = true;
				flag5 = true;
			}
			if ((flag4 || flag5) && !isPendingHierarchicalRepaint)
			{
				renderChain.UIEOnVisualsChanged(ve, flag5);
				isPendingHierarchicalRepaint = true;
			}
			if (flag6)
			{
				renderChain.UIEOnTransformOrSizeChanged(ve, transformChanged: false, clipRectSizeChanged: true);
			}
			if (flag7)
			{
				int childCount = ve.hierarchy.childCount;
				for (int i = 0; i < childCount; i++)
				{
					DepthFirstOnClippingChanged(renderChain, ve, ve.hierarchy[i], dirtyID, hierarchical, isRootOfChange: false, isPendingHierarchicalRepaint, flag8, flag9, device, ref stats);
				}
			}
		}

		private static void DepthFirstOnOpacityChanged(RenderChain renderChain, float parentCompositeOpacity, VisualElement ve, uint dirtyID, bool hierarchical, ref ChainBuilderStats stats, bool isDoingFullVertexRegeneration = false)
		{
			if (dirtyID == ve.renderChainData.dirtyID)
			{
				return;
			}
			ve.renderChainData.dirtyID = dirtyID;
			stats.recursiveOpacityUpdatesExpanded++;
			float compositeOpacity = ve.renderChainData.compositeOpacity;
			float num = ve.resolvedStyle.opacity * parentCompositeOpacity;
			bool flag = (compositeOpacity < VisibilityTreshold) ^ (num < VisibilityTreshold);
			bool flag2 = Mathf.Abs(compositeOpacity - num) > 0.0001f || flag;
			if (flag2)
			{
				ve.renderChainData.compositeOpacity = num;
			}
			bool flag3 = false;
			if (num < parentCompositeOpacity - 0.0001f)
			{
				if (ve.renderChainData.opacityID.ownedState == OwnedState.Inherited)
				{
					flag3 = true;
					ve.renderChainData.opacityID = renderChain.shaderInfoAllocator.AllocOpacity();
				}
				if ((flag3 || flag2) && ve.renderChainData.opacityID.IsValid())
				{
					renderChain.shaderInfoAllocator.SetOpacityValue(ve.renderChainData.opacityID, num);
				}
			}
			else if (ve.renderChainData.opacityID.ownedState == OwnedState.Inherited)
			{
				if (ve.hierarchy.parent != null && !ve.renderChainData.opacityID.Equals(ve.hierarchy.parent.renderChainData.opacityID))
				{
					flag3 = true;
					ve.renderChainData.opacityID = ve.hierarchy.parent.renderChainData.opacityID;
					ve.renderChainData.opacityID.ownedState = OwnedState.Inherited;
				}
			}
			else if (flag2 && ve.renderChainData.opacityID.IsValid())
			{
				renderChain.shaderInfoAllocator.SetOpacityValue(ve.renderChainData.opacityID, num);
			}
			if (!isDoingFullVertexRegeneration && flag3 && (ve.renderChainData.dirtiedValues & RenderDataDirtyTypes.Visuals) == 0 && (ve.renderChainData.data != null || ve.renderChainData.closingData != null))
			{
				renderChain.UIEOnOpacityIdChanged(ve);
			}
			if (flag2 || flag3 || hierarchical)
			{
				int childCount = ve.hierarchy.childCount;
				for (int i = 0; i < childCount; i++)
				{
					DepthFirstOnOpacityChanged(renderChain, num, ve.hierarchy[i], dirtyID, hierarchical, ref stats, isDoingFullVertexRegeneration);
				}
			}
		}

		private static void OnColorChanged(RenderChain renderChain, VisualElement ve, uint dirtyID, ref ChainBuilderStats stats)
		{
			if (dirtyID == ve.renderChainData.dirtyID)
			{
				return;
			}
			ve.renderChainData.dirtyID = dirtyID;
			stats.colorUpdatesExpanded++;
			Color backgroundColor = ve.resolvedStyle.backgroundColor;
			if (ve.renderChainData.backgroundColor.a == 0f && backgroundColor.a > 0f)
			{
				renderChain.UIEOnVisualsChanged(ve, hierarchical: false);
			}
			ve.renderChainData.backgroundColor = backgroundColor;
			bool flag = false;
			if ((ve.renderHints & RenderHints.DynamicColor) == RenderHints.DynamicColor && !ve.renderChainData.isIgnoringDynamicColorHint)
			{
				if (InitColorIDs(renderChain, ve))
				{
					flag = true;
				}
				SetColorValues(renderChain, ve);
				if (ve is TextElement && !UpdateTextCoreSettings(renderChain, ve))
				{
					flag = true;
				}
			}
			else
			{
				flag = true;
			}
			if (flag)
			{
				renderChain.UIEOnVisualsChanged(ve, hierarchical: false);
			}
		}

		private static void DepthFirstOnTransformOrSizeChanged(RenderChain renderChain, VisualElement parent, VisualElement ve, uint dirtyID, UIRenderDevice device, bool isAncestorOfChangeSkinned, bool transformChanged, ref ChainBuilderStats stats)
		{
			if (dirtyID == ve.renderChainData.dirtyID)
			{
				return;
			}
			stats.recursiveTransformUpdatesExpanded++;
			transformChanged |= (ve.renderChainData.dirtiedValues & RenderDataDirtyTypes.Transform) != 0;
			if (RenderChainVEData.AllocatesID(ve.renderChainData.clipRectID))
			{
				renderChain.shaderInfoAllocator.SetClipRectValue(ve.renderChainData.clipRectID, GetClipRectIDClipInfo(ve));
			}
			if (transformChanged && UpdateLocalFlipsWinding(ve))
			{
				renderChain.UIEOnVisualsChanged(ve, hierarchical: true);
			}
			if (transformChanged)
			{
				UpdateZeroScaling(ve);
			}
			bool flag = true;
			if (RenderChainVEData.AllocatesID(ve.renderChainData.transformID))
			{
				renderChain.shaderInfoAllocator.SetTransformValue(ve.renderChainData.transformID, GetTransformIDTransformInfo(ve));
				isAncestorOfChangeSkinned = true;
				stats.boneTransformed++;
			}
			else if (transformChanged)
			{
				if ((ve.renderHints & RenderHints.GroupTransform) != RenderHints.None)
				{
					stats.groupTransformElementsChanged++;
				}
				else if (isAncestorOfChangeSkinned)
				{
					Debug.Assert(RenderChainVEData.InheritsID(ve.renderChainData.transformID));
					flag = false;
					stats.skipTransformed++;
				}
				else if ((ve.renderChainData.dirtiedValues & (RenderDataDirtyTypes.Visuals | RenderDataDirtyTypes.VisualsHierarchy)) == 0 && ve.renderChainData.data != null)
				{
					if (!ve.renderChainData.disableNudging && CommandGenerator.NudgeVerticesToNewSpace(ve, renderChain, device))
					{
						stats.nudgeTransformed++;
					}
					else
					{
						renderChain.UIEOnVisualsChanged(ve, hierarchical: false);
						stats.visualUpdateTransformed++;
					}
				}
			}
			if (flag)
			{
				ve.renderChainData.dirtyID = dirtyID;
			}
			if (renderChain.drawInCameras)
			{
				ve.EnsureWorldTransformAndClipUpToDate();
			}
			if ((ve.renderHints & RenderHints.GroupTransform) == 0)
			{
				int childCount = ve.hierarchy.childCount;
				for (int i = 0; i < childCount; i++)
				{
					DepthFirstOnTransformOrSizeChanged(renderChain, ve, ve.hierarchy[i], dirtyID, device, isAncestorOfChangeSkinned, transformChanged, ref stats);
				}
			}
		}

		private static void DepthFirstOnVisualsChanged(RenderChain renderChain, VisualElement ve, uint dirtyID, bool parentHierarchyHidden, bool hierarchical, ref ChainBuilderStats stats)
		{
			if (dirtyID == ve.renderChainData.dirtyID)
			{
				return;
			}
			ve.renderChainData.dirtyID = dirtyID;
			if (hierarchical)
			{
				stats.recursiveVisualUpdatesExpanded++;
			}
			bool isHierarchyHidden = ve.renderChainData.isHierarchyHidden;
			ve.renderChainData.isHierarchyHidden = parentHierarchyHidden || IsElementHierarchyHidden(ve);
			if (isHierarchyHidden != ve.renderChainData.isHierarchyHidden)
			{
				hierarchical = true;
			}
			if (!hierarchical && (ve.renderChainData.dirtiedValues & RenderDataDirtyTypes.AllVisuals) == RenderDataDirtyTypes.VisualsOpacityId)
			{
				stats.opacityIdUpdates++;
				CommandGenerator.UpdateOpacityId(ve, renderChain);
				return;
			}
			UpdateWorldFlipsWinding(ve);
			Debug.Assert(ve.renderChainData.clipMethod != ClipMethod.Undetermined);
			Debug.Assert(RenderChainVEData.AllocatesID(ve.renderChainData.transformID) || ve.hierarchy.parent == null || ve.renderChainData.transformID.Equals(ve.hierarchy.parent.renderChainData.transformID) || (ve.renderHints & RenderHints.GroupTransform) != 0);
			if (ve is TextElement)
			{
				UpdateTextCoreSettings(renderChain, ve);
			}
			if ((ve.renderHints & RenderHints.DynamicColor) == RenderHints.DynamicColor)
			{
				SetColorValues(renderChain, ve);
			}
			UIRStylePainter.ClosingInfo closingInfo = CommandGenerator.PaintElement(renderChain, ve, ref stats);
			if (hierarchical)
			{
				int childCount = ve.hierarchy.childCount;
				for (int i = 0; i < childCount; i++)
				{
					DepthFirstOnVisualsChanged(renderChain, ve.hierarchy[i], dirtyID, ve.renderChainData.isHierarchyHidden, hierarchical: true, ref stats);
				}
			}
			if (closingInfo.needsClosing)
			{
				CommandGenerator.ClosePaintElement(ve, closingInfo, renderChain, ref stats);
			}
		}

		private static bool UpdateTextCoreSettings(RenderChain renderChain, VisualElement ve)
		{
			if (ve == null || !TextUtilities.IsFontAssigned(ve))
			{
				return false;
			}
			bool flag = RenderChainVEData.AllocatesID(ve.renderChainData.textCoreSettingsID);
			TextCoreSettings textCoreSettingsForElement = TextUtilities.GetTextCoreSettingsForElement(ve);
			if (!NeedsColorID(ve) && !NeedsTextCoreSettings(ve) && !flag)
			{
				ve.renderChainData.textCoreSettingsID = UIRVEShaderInfoAllocator.defaultTextCoreSettings;
				return true;
			}
			if (!flag)
			{
				ve.renderChainData.textCoreSettingsID = renderChain.shaderInfoAllocator.AllocTextCoreSettings(textCoreSettingsForElement);
			}
			if (RenderChainVEData.AllocatesID(ve.renderChainData.textCoreSettingsID))
			{
				if (ve.panel.contextType == ContextType.Editor)
				{
					textCoreSettingsForElement.faceColor *= UIElementsUtility.editorPlayModeTintColor;
					textCoreSettingsForElement.outlineColor *= UIElementsUtility.editorPlayModeTintColor;
					textCoreSettingsForElement.underlayColor *= UIElementsUtility.editorPlayModeTintColor;
				}
				renderChain.shaderInfoAllocator.SetTextCoreSettingValue(ve.renderChainData.textCoreSettingsID, textCoreSettingsForElement, ve.panel.contextType == ContextType.Editor);
			}
			return true;
		}

		private static bool IsElementHierarchyHidden(VisualElement ve)
		{
			return ve.resolvedStyle.display == DisplayStyle.None;
		}

		private static VisualElement GetLastDeepestChild(VisualElement ve)
		{
			for (int childCount = ve.hierarchy.childCount; childCount > 0; childCount = ve.hierarchy.childCount)
			{
				ve = ve.hierarchy[childCount - 1];
			}
			return ve;
		}

		private static VisualElement GetNextDepthFirst(VisualElement ve)
		{
			for (VisualElement parent = ve.hierarchy.parent; parent != null; parent = parent.hierarchy.parent)
			{
				int num = parent.hierarchy.IndexOf(ve);
				int childCount = parent.hierarchy.childCount;
				if (num < childCount - 1)
				{
					return parent.hierarchy[num + 1];
				}
				ve = parent;
			}
			return null;
		}

		private static ClipMethod DetermineSelfClipMethod(RenderChain renderChain, VisualElement ve)
		{
			if (!ve.ShouldClip())
			{
				return ClipMethod.NotClipped;
			}
			ClipMethod clipMethod = (((ve.renderHints & RenderHints.DirtyOffset) != RenderHints.None) ? ClipMethod.Scissor : ClipMethod.ShaderDiscard);
			if (!UIRUtility.IsRoundRect(ve) && !UIRUtility.IsVectorImageBackground(ve))
			{
				return clipMethod;
			}
			int num = 0;
			VisualElement parent = ve.hierarchy.parent;
			if (parent != null)
			{
				num = parent.renderChainData.childrenMaskDepth;
			}
			if (num == 7)
			{
				return clipMethod;
			}
			return renderChain.drawInCameras ? clipMethod : ClipMethod.Stencil;
		}

		private static bool UpdateLocalFlipsWinding(VisualElement ve)
		{
			bool localFlipsWinding = ve.renderChainData.localFlipsWinding;
			Vector3 scale = ve.transform.scale;
			float num = scale.x * scale.y;
			if (Math.Abs(num) < 0.001f)
			{
				return false;
			}
			bool flag = num < 0f;
			if (localFlipsWinding != flag)
			{
				ve.renderChainData.localFlipsWinding = flag;
				return true;
			}
			return false;
		}

		private static void UpdateWorldFlipsWinding(VisualElement ve)
		{
			bool localFlipsWinding = ve.renderChainData.localFlipsWinding;
			bool flag = false;
			VisualElement parent = ve.hierarchy.parent;
			if (parent != null)
			{
				flag = parent.renderChainData.worldFlipsWinding;
			}
			ve.renderChainData.worldFlipsWinding = flag ^ localFlipsWinding;
		}

		private static void UpdateZeroScaling(VisualElement ve)
		{
			bool flag = Math.Abs(ve.transform.scale.x * ve.transform.scale.y) < 0.001f;
			ve.renderChainData.localTransformScaleZero = flag;
			bool flag2 = false;
			VisualElement parent = ve.hierarchy.parent;
			if (parent != null)
			{
				flag2 = parent.renderChainData.worldTransformScaleZero;
			}
			ve.renderChainData.worldTransformScaleZero = flag2 || flag;
		}

		private static bool NeedsTransformID(VisualElement ve)
		{
			return (ve.renderHints & RenderHints.GroupTransform) == 0 && (ve.renderHints & RenderHints.BoneTransform) == RenderHints.BoneTransform;
		}

		private static bool TransformIDHasChanged(Alloc before, Alloc after)
		{
			if (before.size == 0 && after.size == 0)
			{
				return false;
			}
			if (before.size != after.size || before.start != after.start)
			{
				return true;
			}
			return false;
		}

		internal static bool NeedsColorID(VisualElement ve)
		{
			return (ve.renderHints & RenderHints.DynamicColor) == RenderHints.DynamicColor;
		}

		internal static bool NeedsTextCoreSettings(VisualElement ve)
		{
			TextCoreSettings textCoreSettingsForElement = TextUtilities.GetTextCoreSettingsForElement(ve);
			if (textCoreSettingsForElement.outlineWidth != 0f || textCoreSettingsForElement.underlayOffset != Vector2.zero || textCoreSettingsForElement.underlaySoftness != 0f)
			{
				return true;
			}
			return false;
		}

		private static bool InitColorIDs(RenderChain renderChain, VisualElement ve)
		{
			IResolvedStyle resolvedStyle = ve.resolvedStyle;
			bool result = false;
			if (!ve.renderChainData.colorID.IsValid() && resolvedStyle.color != Color.white)
			{
				ve.renderChainData.colorID = renderChain.shaderInfoAllocator.AllocColor();
				result = true;
			}
			if (!ve.renderChainData.backgroundColorID.IsValid() && resolvedStyle.backgroundColor != Color.clear)
			{
				ve.renderChainData.backgroundColorID = renderChain.shaderInfoAllocator.AllocColor();
				result = true;
			}
			if (!ve.renderChainData.borderLeftColorID.IsValid() && resolvedStyle.borderLeftWidth > 0f)
			{
				ve.renderChainData.borderLeftColorID = renderChain.shaderInfoAllocator.AllocColor();
				result = true;
			}
			if (!ve.renderChainData.borderTopColorID.IsValid() && resolvedStyle.borderTopWidth > 0f)
			{
				ve.renderChainData.borderTopColorID = renderChain.shaderInfoAllocator.AllocColor();
				result = true;
			}
			if (!ve.renderChainData.borderRightColorID.IsValid() && resolvedStyle.borderRightWidth > 0f)
			{
				ve.renderChainData.borderRightColorID = renderChain.shaderInfoAllocator.AllocColor();
				result = true;
			}
			if (!ve.renderChainData.borderBottomColorID.IsValid() && resolvedStyle.borderBottomWidth > 0f)
			{
				ve.renderChainData.borderBottomColorID = renderChain.shaderInfoAllocator.AllocColor();
				result = true;
			}
			if (!ve.renderChainData.tintColorID.IsValid() && resolvedStyle.unityBackgroundImageTintColor != Color.white)
			{
				ve.renderChainData.tintColorID = renderChain.shaderInfoAllocator.AllocColor();
				result = true;
			}
			return result;
		}

		private static void ResetColorIDs(VisualElement ve)
		{
			ve.renderChainData.colorID = BMPAlloc.Invalid;
			ve.renderChainData.backgroundColorID = BMPAlloc.Invalid;
			ve.renderChainData.borderLeftColorID = BMPAlloc.Invalid;
			ve.renderChainData.borderTopColorID = BMPAlloc.Invalid;
			ve.renderChainData.borderRightColorID = BMPAlloc.Invalid;
			ve.renderChainData.borderBottomColorID = BMPAlloc.Invalid;
			ve.renderChainData.tintColorID = BMPAlloc.Invalid;
		}

		private static void SetColorValues(RenderChain renderChain, VisualElement ve)
		{
			bool isEditorContext = ve.panel.contextType == ContextType.Editor;
			IResolvedStyle resolvedStyle = ve.resolvedStyle;
			if (ve.renderChainData.colorID.IsValid())
			{
				renderChain.shaderInfoAllocator.SetColorValue(ve.renderChainData.colorID, resolvedStyle.color, isEditorContext);
			}
			if (ve.renderChainData.backgroundColorID.IsValid())
			{
				renderChain.shaderInfoAllocator.SetColorValue(ve.renderChainData.backgroundColorID, resolvedStyle.backgroundColor, isEditorContext);
			}
			if (ve.renderChainData.borderLeftColorID.IsValid())
			{
				renderChain.shaderInfoAllocator.SetColorValue(ve.renderChainData.borderLeftColorID, resolvedStyle.borderLeftColor, isEditorContext);
			}
			if (ve.renderChainData.borderTopColorID.IsValid())
			{
				renderChain.shaderInfoAllocator.SetColorValue(ve.renderChainData.borderTopColorID, resolvedStyle.borderTopColor, isEditorContext);
			}
			if (ve.renderChainData.borderRightColorID.IsValid())
			{
				renderChain.shaderInfoAllocator.SetColorValue(ve.renderChainData.borderRightColorID, resolvedStyle.borderRightColor, isEditorContext);
			}
			if (ve.renderChainData.borderBottomColorID.IsValid())
			{
				renderChain.shaderInfoAllocator.SetColorValue(ve.renderChainData.borderBottomColorID, resolvedStyle.borderBottomColor, isEditorContext);
			}
			if (ve.renderChainData.tintColorID.IsValid())
			{
				renderChain.shaderInfoAllocator.SetColorValue(ve.renderChainData.tintColorID, resolvedStyle.unityBackgroundImageTintColor, isEditorContext);
			}
		}
	}
	internal class UIRStylePainter : IStylePainter
	{
		internal struct Entry
		{
			public NativeSlice<Vertex> vertices;

			public NativeSlice<ushort> indices;

			public Material material;

			public float fontTexSDFScale;

			public TextureId texture;

			public RenderChainCommand customCommand;

			public BMPAlloc clipRectID;

			public VertexFlags addFlags;

			public bool uvIsDisplacement;

			public bool isTextEntry;

			public bool isClipRegisterEntry;

			public int stencilRef;

			public int maskDepth;
		}

		internal struct ClosingInfo
		{
			public bool needsClosing;

			public bool popViewMatrix;

			public bool popScissorClip;

			public bool blitAndPopRenderTexture;

			public bool PopDefaultMaterial;

			public RenderChainCommand clipUnregisterDrawCommand;

			public NativeSlice<Vertex> clipperRegisterVertices;

			public NativeSlice<ushort> clipperRegisterIndices;

			public int clipperRegisterIndexOffset;

			public int maskStencilRef;
		}

		private struct RepeatRectUV
		{
			public Rect rect;

			public Rect uv;
		}

		private RenderChain m_Owner;

		private List<Entry> m_Entries = new List<Entry>();

		private AtlasBase m_Atlas;

		private VectorImageManager m_VectorImageManager;

		private Entry m_CurrentEntry;

		private ClosingInfo m_ClosingInfo;

		private int m_MaskDepth;

		private int m_StencilRef;

		private BMPAlloc m_ClipRectID = UIRVEShaderInfoAllocator.infiniteClipRect;

		private int m_SVGBackgroundEntryIndex = -1;

		private TempAllocator<Vertex> m_VertsPool;

		private TempAllocator<ushort> m_IndicesPool;

		private List<MeshWriteData> m_MeshWriteDataPool;

		private int m_NextMeshWriteDataPoolItem;

		private List<RepeatRectUV>[] m_RepeatRectUVList = null;

		private MeshBuilder.AllocMeshData.Allocator m_AllocRawVertsIndicesDelegate;

		private MeshBuilder.AllocMeshData.Allocator m_AllocThroughDrawMeshDelegate;

		private UnityEngine.TextCore.Text.TextInfo m_TextInfo = new UnityEngine.TextCore.Text.TextInfo();

		public MeshGenerationContext meshGenerationContext { get; }

		public VisualElement currentElement { get; private set; }

		public List<Entry> entries => m_Entries;

		public ClosingInfo closingInfo => m_ClosingInfo;

		public int totalVertices { get; private set; }

		public int totalIndices { get; private set; }

		public VisualElement visualElement => currentElement;

		private MeshWriteData GetPooledMeshWriteData()
		{
			if (m_NextMeshWriteDataPoolItem == m_MeshWriteDataPool.Count)
			{
				m_MeshWriteDataPool.Add(new MeshWriteData());
			}
			return m_MeshWriteDataPool[m_NextMeshWriteDataPoolItem++];
		}

		private MeshWriteData AllocRawVertsIndices(uint vertexCount, uint indexCount, ref MeshBuilder.AllocMeshData allocatorData)
		{
			m_CurrentEntry.vertices = m_VertsPool.Alloc((int)vertexCount);
			m_CurrentEntry.indices = m_IndicesPool.Alloc((int)indexCount);
			MeshWriteData pooledMeshWriteData = GetPooledMeshWriteData();
			pooledMeshWriteData.Reset(m_CurrentEntry.vertices, m_CurrentEntry.indices);
			return pooledMeshWriteData;
		}

		private MeshWriteData AllocThroughDrawMesh(uint vertexCount, uint indexCount, ref MeshBuilder.AllocMeshData allocatorData)
		{
			return DrawMesh((int)vertexCount, (int)indexCount, allocatorData.texture, allocatorData.material, allocatorData.flags);
		}

		public UIRStylePainter(RenderChain renderChain)
		{
			m_Owner = renderChain;
			meshGenerationContext = new MeshGenerationContext(this);
			m_Atlas = renderChain.atlas;
			m_VectorImageManager = renderChain.vectorImageManager;
			m_AllocRawVertsIndicesDelegate = AllocRawVertsIndices;
			m_AllocThroughDrawMeshDelegate = AllocThroughDrawMesh;
			int num = 32;
			m_MeshWriteDataPool = new List<MeshWriteData>(num);
			for (int i = 0; i < num; i++)
			{
				m_MeshWriteDataPool.Add(new MeshWriteData());
			}
			m_VertsPool = renderChain.vertsPool;
			m_IndicesPool = renderChain.indicesPool;
		}

		public void Begin(VisualElement ve)
		{
			currentElement = ve;
			m_NextMeshWriteDataPoolItem = 0;
			m_SVGBackgroundEntryIndex = -1;
			currentElement.renderChainData.displacementUVStart = (currentElement.renderChainData.displacementUVEnd = 0);
			m_MaskDepth = 0;
			m_StencilRef = 0;
			VisualElement parent = currentElement.hierarchy.parent;
			if (parent != null)
			{
				m_MaskDepth = parent.renderChainData.childrenMaskDepth;
				m_StencilRef = parent.renderChainData.childrenStencilRef;
			}
			bool flag = (currentElement.renderHints & RenderHints.GroupTransform) != 0;
			if (flag)
			{
				RenderChainCommand renderChainCommand = m_Owner.AllocCommand();
				renderChainCommand.owner = currentElement;
				renderChainCommand.type = CommandType.PushView;
				m_Entries.Add(new Entry
				{
					customCommand = renderChainCommand
				});
				m_ClosingInfo.needsClosing = (m_ClosingInfo.popViewMatrix = true);
			}
			if (parent != null)
			{
				m_ClipRectID = (flag ? UIRVEShaderInfoAllocator.infiniteClipRect : parent.renderChainData.clipRectID);
			}
			else
			{
				m_ClipRectID = UIRVEShaderInfoAllocator.infiniteClipRect;
			}
			if (ve.subRenderTargetMode != VisualElement.RenderTargetMode.None)
			{
				RenderChainCommand renderChainCommand2 = m_Owner.AllocCommand();
				renderChainCommand2.owner = currentElement;
				renderChainCommand2.type = CommandType.PushRenderTexture;
				m_Entries.Add(new Entry
				{
					customCommand = renderChainCommand2
				});
				m_ClosingInfo.needsClosing = (m_ClosingInfo.blitAndPopRenderTexture = true);
				if (m_MaskDepth > 0 || m_StencilRef > 0)
				{
					Debug.LogError("The RenderTargetMode feature must not be used within a stencil mask.");
				}
			}
			if (ve.defaultMaterial != null)
			{
				RenderChainCommand renderChainCommand3 = m_Owner.AllocCommand();
				renderChainCommand3.owner = currentElement;
				renderChainCommand3.type = CommandType.PushDefaultMaterial;
				renderChainCommand3.state.material = ve.defaultMaterial;
				m_Entries.Add(new Entry
				{
					customCommand = renderChainCommand3
				});
				m_ClosingInfo.needsClosing = (m_ClosingInfo.PopDefaultMaterial = true);
			}
			if (meshGenerationContext.hasPainter2D)
			{
				meshGenerationContext.painter2D.Reset();
			}
		}

		public void LandClipUnregisterMeshDrawCommand(RenderChainCommand cmd)
		{
			Debug.Assert(m_ClosingInfo.needsClosing);
			m_ClosingInfo.clipUnregisterDrawCommand = cmd;
		}

		public void LandClipRegisterMesh(NativeSlice<Vertex> vertices, NativeSlice<ushort> indices, int indexOffset)
		{
			Debug.Assert(m_ClosingInfo.needsClosing);
			m_ClosingInfo.clipperRegisterVertices = vertices;
			m_ClosingInfo.clipperRegisterIndices = indices;
			m_ClosingInfo.clipperRegisterIndexOffset = indexOffset;
		}

		public MeshWriteData AddGradientsEntry(int vertexCount, int indexCount, TextureId texture, Material material, MeshGenerationContext.MeshFlags flags)
		{
			MeshWriteData pooledMeshWriteData = GetPooledMeshWriteData();
			if (vertexCount == 0 || indexCount == 0)
			{
				pooledMeshWriteData.Reset(default(NativeSlice<Vertex>), default(NativeSlice<ushort>));
				return pooledMeshWriteData;
			}
			m_CurrentEntry = new Entry
			{
				vertices = m_VertsPool.Alloc(vertexCount),
				indices = m_IndicesPool.Alloc(indexCount),
				material = material,
				texture = texture,
				clipRectID = m_ClipRectID,
				stencilRef = m_StencilRef,
				maskDepth = m_MaskDepth,
				addFlags = VertexFlags.IsSvgGradients
			};
			Debug.Assert(m_CurrentEntry.vertices.Length == vertexCount);
			Debug.Assert(m_CurrentEntry.indices.Length == indexCount);
			pooledMeshWriteData.Reset(m_CurrentEntry.vertices, m_CurrentEntry.indices, new Rect(0f, 0f, 1f, 1f));
			m_Entries.Add(m_CurrentEntry);
			totalVertices += m_CurrentEntry.vertices.Length;
			totalIndices += m_CurrentEntry.indices.Length;
			m_CurrentEntry = default(Entry);
			return pooledMeshWriteData;
		}

		public MeshWriteData DrawMesh(int vertexCount, int indexCount, Texture texture, Material material, MeshGenerationContext.MeshFlags flags)
		{
			MeshWriteData pooledMeshWriteData = GetPooledMeshWriteData();
			if (vertexCount == 0 || indexCount == 0)
			{
				pooledMeshWriteData.Reset(default(NativeSlice<Vertex>), default(NativeSlice<ushort>));
				return pooledMeshWriteData;
			}
			m_CurrentEntry = new Entry
			{
				vertices = m_VertsPool.Alloc(vertexCount),
				indices = m_IndicesPool.Alloc(indexCount),
				material = material,
				uvIsDisplacement = ((flags & MeshGenerationContext.MeshFlags.UVisDisplacement) == MeshGenerationContext.MeshFlags.UVisDisplacement),
				clipRectID = m_ClipRectID,
				stencilRef = m_StencilRef,
				maskDepth = m_MaskDepth,
				addFlags = VertexFlags.IsSolid
			};
			Debug.Assert(m_CurrentEntry.vertices.Length == vertexCount);
			Debug.Assert(m_CurrentEntry.indices.Length == indexCount);
			Rect uvRegion = new Rect(0f, 0f, 1f, 1f);
			if (texture != null)
			{
				if ((flags & MeshGenerationContext.MeshFlags.SkipDynamicAtlas) != MeshGenerationContext.MeshFlags.SkipDynamicAtlas && m_Atlas != null && m_Atlas.TryGetAtlas(currentElement, texture as Texture2D, out var atlas, out var atlasRect))
				{
					m_CurrentEntry.addFlags = VertexFlags.IsDynamic;
					uvRegion = new Rect(atlasRect.x, atlasRect.y, atlasRect.width, atlasRect.height);
					m_CurrentEntry.texture = atlas;
					m_Owner.AppendTexture(currentElement, texture, atlas, isAtlas: true);
				}
				else
				{
					TextureId textureId = TextureRegistry.instance.Acquire(texture);
					m_CurrentEntry.addFlags = VertexFlags.IsTextured;
					m_CurrentEntry.texture = textureId;
					m_Owner.AppendTexture(currentElement, texture, textureId, isAtlas: false);
				}
			}
			pooledMeshWriteData.Reset(m_CurrentEntry.vertices, m_CurrentEntry.indices, uvRegion);
			m_Entries.Add(m_CurrentEntry);
			totalVertices += m_CurrentEntry.vertices.Length;
			totalIndices += m_CurrentEntry.indices.Length;
			m_CurrentEntry = default(Entry);
			return pooledMeshWriteData;
		}

		internal void TryAtlasTexture(Texture texture, MeshGenerationContext.MeshFlags flags, out Rect outUVRegion, out bool outIsAtlas, out TextureId outTextureId, out VertexFlags outAddFlags)
		{
			outUVRegion = new Rect(0f, 0f, 1f, 1f);
			outIsAtlas = false;
			outTextureId = default(TextureId);
			outAddFlags = VertexFlags.IsSolid;
			if (!(texture == null))
			{
				if ((flags & MeshGenerationContext.MeshFlags.SkipDynamicAtlas) != MeshGenerationContext.MeshFlags.SkipDynamicAtlas && m_Atlas != null && m_Atlas.TryGetAtlas(currentElement, texture as Texture2D, out var atlas, out var atlasRect))
				{
					outAddFlags = VertexFlags.IsDynamic;
					outUVRegion = new Rect(atlasRect.x, atlasRect.y, atlasRect.width, atlasRect.height);
					outIsAtlas = true;
					outTextureId = atlas;
				}
				else
				{
					outAddFlags = VertexFlags.IsTextured;
					outTextureId = TextureRegistry.instance.Acquire(texture);
				}
			}
		}

		internal unsafe void BuildEntryFromNativeMesh(MeshWriteDataInterface meshData, Texture texture, TextureId textureId, bool isAtlas, Material material, MeshGenerationContext.MeshFlags flags, Rect uvRegion, VertexFlags addFlags)
		{
			if (meshData.vertexCount == 0 || meshData.indexCount == 0)
			{
				return;
			}
			NativeSlice<Vertex> slice = UIRenderDevice.PtrToSlice<Vertex>((void*)meshData.vertices, meshData.vertexCount);
			NativeSlice<ushort> slice2 = UIRenderDevice.PtrToSlice<ushort>((void*)meshData.indices, meshData.indexCount);
			if (slice.Length != 0 && slice2.Length != 0)
			{
				m_CurrentEntry = new Entry
				{
					vertices = m_VertsPool.Alloc(slice.Length),
					indices = m_IndicesPool.Alloc(slice2.Length),
					material = material,
					uvIsDisplacement = ((flags & MeshGenerationContext.MeshFlags.UVisDisplacement) == MeshGenerationContext.MeshFlags.UVisDisplacement),
					clipRectID = m_ClipRectID,
					stencilRef = m_StencilRef,
					maskDepth = m_MaskDepth,
					addFlags = VertexFlags.IsSolid
				};
				if (textureId.index >= 0)
				{
					m_CurrentEntry.addFlags = addFlags;
					m_CurrentEntry.texture = textureId;
					m_Owner.AppendTexture(currentElement, texture, textureId, isAtlas);
				}
				Debug.Assert(m_CurrentEntry.vertices.Length == slice.Length);
				Debug.Assert(m_CurrentEntry.indices.Length == slice2.Length);
				m_CurrentEntry.vertices.CopyFrom(slice);
				m_CurrentEntry.indices.CopyFrom(slice2);
				m_Entries.Add(m_CurrentEntry);
				totalVertices += m_CurrentEntry.vertices.Length;
				totalIndices += m_CurrentEntry.indices.Length;
				m_CurrentEntry = default(Entry);
			}
		}

		internal unsafe void BuildGradientEntryFromNativeMesh(MeshWriteDataInterface meshData, TextureId svgTextureId)
		{
			if (meshData.vertexCount != 0 && meshData.indexCount != 0)
			{
				NativeSlice<Vertex> slice = UIRenderDevice.PtrToSlice<Vertex>((void*)meshData.vertices, meshData.vertexCount);
				NativeSlice<ushort> slice2 = UIRenderDevice.PtrToSlice<ushort>((void*)meshData.indices, meshData.indexCount);
				if (slice.Length != 0 && slice2.Length != 0)
				{
					m_CurrentEntry = new Entry
					{
						vertices = m_VertsPool.Alloc(slice.Length),
						indices = m_IndicesPool.Alloc(slice2.Length),
						texture = svgTextureId,
						clipRectID = m_ClipRectID,
						stencilRef = m_StencilRef,
						maskDepth = m_MaskDepth,
						addFlags = VertexFlags.IsSvgGradients
					};
					Debug.Assert(m_CurrentEntry.vertices.Length == slice.Length);
					Debug.Assert(m_CurrentEntry.indices.Length == slice2.Length);
					m_CurrentEntry.vertices.CopyFrom(slice);
					m_CurrentEntry.indices.CopyFrom(slice2);
					m_Entries.Add(m_CurrentEntry);
					totalVertices += m_CurrentEntry.vertices.Length;
					totalIndices += m_CurrentEntry.indices.Length;
					m_CurrentEntry = default(Entry);
				}
			}
		}

		public unsafe void BuildRawEntryFromNativeMesh(MeshWriteDataInterface meshData)
		{
			if (meshData.vertexCount != 0 && meshData.indexCount != 0)
			{
				NativeSlice<Vertex> slice = UIRenderDevice.PtrToSlice<Vertex>((void*)meshData.vertices, meshData.vertexCount);
				NativeSlice<ushort> slice2 = UIRenderDevice.PtrToSlice<ushort>((void*)meshData.indices, meshData.indexCount);
				if (slice.Length != 0 && slice2.Length != 0)
				{
					m_CurrentEntry.vertices = m_VertsPool.Alloc(meshData.vertexCount);
					m_CurrentEntry.indices = m_IndicesPool.Alloc(meshData.indexCount);
					m_CurrentEntry.vertices.CopyFrom(slice);
					m_CurrentEntry.indices.CopyFrom(slice2);
				}
			}
		}

		public void DrawText(TextElement te)
		{
			if (TextUtilities.IsFontAssigned(te))
			{
				UnityEngine.TextCore.Text.TextInfo textInfo = te.uitkTextHandle.Update();
				bool hasMultipleColors = textInfo.hasMultipleColors;
				if (hasMultipleColors)
				{
					te.renderChainData.flags |= RenderDataFlags.IsIgnoringDynamicColorHint;
				}
				else
				{
					te.renderChainData.flags &= ~RenderDataFlags.IsIgnoringDynamicColorHint;
				}
				DrawTextInfo(textInfo, te.contentRect.min, !hasMultipleColors);
			}
		}

		public void DrawText(string text, Vector2 pos, float fontSize, Color color, FontAsset font)
		{
			PanelTextSettings textSettingsFrom = TextUtilities.GetTextSettingsFrom(currentElement);
			m_TextInfo.Clear();
			UnityEngine.TextCore.Text.TextGenerationSettings settings = new UnityEngine.TextCore.Text.TextGenerationSettings
			{
				text = text,
				screenRect = Rect.zero,
				fontAsset = font,
				textSettings = textSettingsFrom,
				fontSize = fontSize,
				color = color,
				material = font.material,
				inverseYAxis = true
			};
			UnityEngine.TextCore.Text.TextGenerator.GenerateText(settings, m_TextInfo);
			DrawTextInfo(m_TextInfo, pos, useHints: false);
		}

		private void DrawTextInfo(UnityEngine.TextCore.Text.TextInfo textInfo, Vector2 offset, bool useHints)
		{
			for (int i = 0; i < textInfo.materialCount; i++)
			{
				if (textInfo.meshInfo[i].vertexCount == 0)
				{
					continue;
				}
				m_CurrentEntry.clipRectID = m_ClipRectID;
				m_CurrentEntry.stencilRef = m_StencilRef;
				m_CurrentEntry.maskDepth = m_MaskDepth;
				if (((Texture2D)textInfo.meshInfo[i].material.mainTexture).format != TextureFormat.Alpha8)
				{
					Texture mainTexture = textInfo.meshInfo[i].material.mainTexture;
					TextureId textureId = TextureRegistry.instance.Acquire(mainTexture);
					m_CurrentEntry.texture = textureId;
					m_Owner.AppendTexture(currentElement, mainTexture, textureId, isAtlas: false);
					MeshBuilder.MakeText(textInfo.meshInfo[i], offset, new MeshBuilder.AllocMeshData
					{
						alloc = m_AllocRawVertsIndicesDelegate
					}, VertexFlags.IsTextured);
				}
				else
				{
					Texture mainTexture2 = textInfo.meshInfo[i].material.mainTexture;
					float fontTexSDFScale = 0f;
					if (!TextGeneratorUtilities.IsBitmapRendering(textInfo.meshInfo[i].glyphRenderMode))
					{
						fontTexSDFScale = textInfo.meshInfo[i].material.GetFloat(TextShaderUtilities.ID_GradientScale);
					}
					m_CurrentEntry.isTextEntry = true;
					m_CurrentEntry.fontTexSDFScale = fontTexSDFScale;
					m_CurrentEntry.texture = TextureRegistry.instance.Acquire(mainTexture2);
					m_Owner.AppendTexture(currentElement, mainTexture2, m_CurrentEntry.texture, isAtlas: false);
					bool isDynamicColor = useHints && RenderEvents.NeedsColorID(currentElement);
					MeshBuilder.MakeText(textInfo.meshInfo[i], offset, new MeshBuilder.AllocMeshData
					{
						alloc = m_AllocRawVertsIndicesDelegate
					}, VertexFlags.IsText, isDynamicColor);
				}
				m_Entries.Add(m_CurrentEntry);
				totalVertices += m_CurrentEntry.vertices.Length;
				totalIndices += m_CurrentEntry.indices.Length;
				m_CurrentEntry = default(Entry);
			}
		}

		public void DrawRectangle(MeshGenerationContextUtils.RectangleParams rectParams)
		{
			if (!(rectParams.rect.width < 1E-30f) && !(rectParams.rect.height < 1E-30f))
			{
				if (rectParams.vectorImage != null)
				{
					DrawVectorImage(rectParams);
					return;
				}
				if (rectParams.sprite != null)
				{
					DrawSprite(rectParams);
					return;
				}
				TryAtlasTexture(rectParams.texture, rectParams.meshFlags, out var outUVRegion, out var outIsAtlas, out var outTextureId, out var outAddFlags);
				MeshBuilderNative.NativeRectParams rectParams2 = rectParams.ToNativeParams(outUVRegion);
				ApplyInset(ref rectParams2, rectParams.texture);
				MeshWriteDataInterface meshData = ((!(rectParams.texture != null)) ? MeshBuilderNative.MakeSolidRect(rectParams2, 0f) : MeshBuilderNative.MakeTexturedRect(rectParams2, 0f));
				BuildEntryFromNativeMesh(meshData, rectParams.texture, outTextureId, outIsAtlas, rectParams.material, rectParams.meshFlags, outUVRegion, outAddFlags);
			}
		}

		public void DrawBorder(MeshGenerationContextUtils.BorderParams borderParams)
		{
			MeshWriteDataInterface meshData = MeshBuilderNative.MakeBorder(borderParams.ToNativeParams(), 0f);
			BuildEntryFromNativeMesh(meshData, null, default(TextureId), isAtlas: false, null, MeshGenerationContext.MeshFlags.None, new Rect(0f, 0f, 1f, 1f), VertexFlags.IsSolid);
		}

		public void DrawImmediate(Action callback, bool cullingEnabled)
		{
			RenderChainCommand renderChainCommand = m_Owner.AllocCommand();
			renderChainCommand.type = (cullingEnabled ? CommandType.ImmediateCull : CommandType.Immediate);
			renderChainCommand.owner = currentElement;
			renderChainCommand.callback = callback;
			m_Entries.Add(new Entry
			{
				customCommand = renderChainCommand
			});
		}

		public void DrawVectorImage(VectorImage vectorImage, Vector2 offset, Angle rotationAngle, Vector2 scale)
		{
			if (vectorImage == null)
			{
				return;
			}
			int settingIndexOffset = 0;
			TextureId texture = default(TextureId);
			MeshWriteData meshWriteData;
			if (vectorImage.atlas != null)
			{
				RegisterVectorImageGradient(vectorImage, out settingIndexOffset, out texture);
				meshWriteData = AddGradientsEntry(vectorImage.vertices.Length, vectorImage.indices.Length, texture, null, MeshGenerationContext.MeshFlags.None);
			}
			else
			{
				meshWriteData = DrawMesh(vectorImage.vertices.Length, vectorImage.indices.Length, null, null, MeshGenerationContext.MeshFlags.None);
			}
			Matrix4x4 matrix4x = Matrix4x4.TRS(offset, Quaternion.AngleAxis(rotationAngle.ToDegrees(), Vector3.forward), new Vector3(scale.x, scale.y, 1f));
			bool flag = (scale.x < 0f) ^ (scale.y < 0f);
			int num = vectorImage.vertices.Length;
			for (int i = 0; i < num; i++)
			{
				VectorImageVertex vectorImageVertex = vectorImage.vertices[i];
				Vector3 position = matrix4x.MultiplyPoint3x4(vectorImageVertex.position);
				position.z = Vertex.nearZ;
				uint num2 = (uint)(vectorImageVertex.settingIndex + settingIndexOffset);
				Color32 settingIndex = new Color32((byte)(num2 >> 8), (byte)num2, 0, 0);
				meshWriteData.SetNextVertex(new Vertex
				{
					position = position,
					tint = vectorImageVertex.tint,
					uv = vectorImageVertex.uv,
					settingIndex = settingIndex,
					flags = vectorImageVertex.flags,
					circle = vectorImageVertex.circle
				});
			}
			if (!flag)
			{
				meshWriteData.SetAllIndices(vectorImage.indices);
				return;
			}
			ushort[] indices = vectorImage.indices;
			for (int j = 0; j < indices.Length; j += 3)
			{
				meshWriteData.SetNextIndex(indices[j]);
				meshWriteData.SetNextIndex(indices[j + 2]);
				meshWriteData.SetNextIndex(indices[j + 1]);
			}
		}

		public void DrawVisualElementBackground()
		{
			if (currentElement.layout.width <= 1E-30f || currentElement.layout.height <= 1E-30f)
			{
				return;
			}
			ComputedStyle computedStyle = currentElement.computedStyle;
			if (computedStyle.backgroundColor.a > 1E-30f)
			{
				MeshGenerationContextUtils.RectangleParams rectParams = new MeshGenerationContextUtils.RectangleParams
				{
					rect = currentElement.rect,
					color = computedStyle.backgroundColor,
					colorPage = ColorPage.Init(m_Owner, currentElement.renderChainData.backgroundColorID),
					playmodeTintColor = ((currentElement.panel.contextType == ContextType.Editor) ? UIElementsUtility.editorPlayModeTintColor : Color.white)
				};
				MeshGenerationContextUtils.GetVisualElementRadii(currentElement, out rectParams.topLeftRadius, out rectParams.bottomLeftRadius, out rectParams.topRightRadius, out rectParams.bottomRightRadius);
				MeshGenerationContextUtils.AdjustBackgroundSizeForBorders(currentElement, ref rectParams);
				DrawRectangle(rectParams);
			}
			Vector4 slices = new Vector4(computedStyle.unitySliceLeft, computedStyle.unitySliceTop, computedStyle.unitySliceRight, computedStyle.unitySliceBottom);
			MeshGenerationContextUtils.RectangleParams rectangleParams = default(MeshGenerationContextUtils.RectangleParams);
			MeshGenerationContextUtils.GetVisualElementRadii(currentElement, out rectangleParams.topLeftRadius, out rectangleParams.bottomLeftRadius, out rectangleParams.topRightRadius, out rectangleParams.bottomRightRadius);
			Background backgroundImage = computedStyle.backgroundImage;
			if (!(backgroundImage.texture != null) && !(backgroundImage.sprite != null) && !(backgroundImage.vectorImage != null) && !(backgroundImage.renderTexture != null))
			{
				return;
			}
			MeshGenerationContextUtils.RectangleParams rectParams2 = default(MeshGenerationContextUtils.RectangleParams);
			float num = visualElement.resolvedStyle.unitySliceScale;
			if (backgroundImage.texture != null)
			{
				rectParams2 = MeshGenerationContextUtils.RectangleParams.MakeTextured(currentElement.rect, new Rect(0f, 0f, 1f, 1f), backgroundImage.texture, ScaleMode.ScaleToFit, currentElement.panel.contextType);
				rectParams2.rect = new Rect(0f, 0f, rectParams2.texture.width, rectParams2.texture.height);
			}
			else if (backgroundImage.sprite != null)
			{
				bool valid;
				ScaleMode scaleMode = BackgroundPropertyHelper.ResolveUnityBackgroundScaleMode(computedStyle.backgroundPositionX, computedStyle.backgroundPositionY, computedStyle.backgroundRepeat, computedStyle.backgroundSize, out valid);
				bool flag = !valid || scaleMode == ScaleMode.ScaleAndCrop;
				rectParams2 = MeshGenerationContextUtils.RectangleParams.MakeSprite(currentElement.rect, new Rect(0f, 0f, 1f, 1f), backgroundImage.sprite, (!flag) ? scaleMode : ScaleMode.StretchToFill, currentElement.panel.contextType, rectangleParams.HasRadius(0.001f), ref slices, flag);
				if (rectParams2.texture != null)
				{
					rectParams2.rect = new Rect(0f, 0f, backgroundImage.sprite.rect.width, backgroundImage.sprite.rect.height);
				}
				num *= UIElementsUtility.PixelsPerUnitScaleForElement(visualElement, backgroundImage.sprite);
			}
			else if (backgroundImage.renderTexture != null)
			{
				rectParams2 = MeshGenerationContextUtils.RectangleParams.MakeTextured(currentElement.rect, new Rect(0f, 0f, 1f, 1f), backgroundImage.renderTexture, ScaleMode.ScaleToFit, currentElement.panel.contextType);
				rectParams2.rect = new Rect(0f, 0f, rectParams2.texture.width, rectParams2.texture.height);
			}
			else if (backgroundImage.vectorImage != null)
			{
				bool valid2;
				ScaleMode scaleMode2 = BackgroundPropertyHelper.ResolveUnityBackgroundScaleMode(computedStyle.backgroundPositionX, computedStyle.backgroundPositionY, computedStyle.backgroundRepeat, computedStyle.backgroundSize, out valid2);
				bool flag2 = !valid2 || scaleMode2 == ScaleMode.ScaleAndCrop;
				rectParams2 = MeshGenerationContextUtils.RectangleParams.MakeVectorTextured(currentElement.rect, new Rect(0f, 0f, 1f, 1f), backgroundImage.vectorImage, (!flag2) ? scaleMode2 : ScaleMode.StretchToFill, currentElement.panel.contextType);
				rectParams2.rect = new Rect(0f, 0f, rectParams2.vectorImage.size.x, rectParams2.vectorImage.size.y);
			}
			rectParams2.topLeftRadius = rectangleParams.topLeftRadius;
			rectParams2.topRightRadius = rectangleParams.topRightRadius;
			rectParams2.bottomRightRadius = rectangleParams.bottomRightRadius;
			rectParams2.bottomLeftRadius = rectangleParams.bottomLeftRadius;
			if (slices != Vector4.zero)
			{
				rectParams2.leftSlice = Mathf.RoundToInt(slices.x);
				rectParams2.topSlice = Mathf.RoundToInt(slices.y);
				rectParams2.rightSlice = Mathf.RoundToInt(slices.z);
				rectParams2.bottomSlice = Mathf.RoundToInt(slices.w);
				rectParams2.sliceScale = num;
			}
			rectParams2.color = computedStyle.unityBackgroundImageTintColor;
			rectParams2.colorPage = ColorPage.Init(m_Owner, currentElement.renderChainData.tintColorID);
			rectParams2.backgroundPositionX = computedStyle.backgroundPositionX;
			rectParams2.backgroundPositionY = computedStyle.backgroundPositionY;
			rectParams2.backgroundRepeat = computedStyle.backgroundRepeat;
			rectParams2.backgroundSize = computedStyle.backgroundSize;
			MeshGenerationContextUtils.AdjustBackgroundSizeForBorders(currentElement, ref rectParams2);
			if (rectParams2.texture != null)
			{
				DrawRectangleRepeat(rectParams2, currentElement.rect, currentElement.scaledPixelsPerPoint);
			}
			else if (rectParams2.vectorImage != null)
			{
				DrawRectangleRepeat(rectParams2, currentElement.rect, currentElement.scaledPixelsPerPoint);
			}
			else
			{
				DrawRectangle(rectParams2);
			}
		}

		private void DrawRectangleRepeat(MeshGenerationContextUtils.RectangleParams rectParams, Rect totalRect, float scaledPixelsPerPoint)
		{
			Rect rect = new Rect(0f, 0f, 1f, 1f);
			if (m_RepeatRectUVList == null)
			{
				m_RepeatRectUVList = new List<RepeatRectUV>[2];
				m_RepeatRectUVList[0] = new List<RepeatRectUV>();
				m_RepeatRectUVList[1] = new List<RepeatRectUV>();
			}
			else
			{
				m_RepeatRectUVList[0].Clear();
				m_RepeatRectUVList[1].Clear();
			}
			Rect rect2 = rectParams.rect;
			if (rectParams.backgroundSize.sizeType != BackgroundSizeType.Length)
			{
				if (rectParams.backgroundSize.sizeType == BackgroundSizeType.Contain)
				{
					float num = totalRect.width / rect2.width;
					float num2 = totalRect.height / rect2.height;
					Rect rect3 = rect2;
					if (num < num2)
					{
						rect3.width = totalRect.width;
						rect3.height = rect2.height * totalRect.width / rect2.width;
					}
					else
					{
						rect3.width = rect2.width * totalRect.height / rect2.height;
						rect3.height = totalRect.height;
					}
					rect2 = rect3;
				}
				else if (rectParams.backgroundSize.sizeType == BackgroundSizeType.Cover)
				{
					float num3 = totalRect.width / rect2.width;
					float num4 = totalRect.height / rect2.height;
					Rect rect4 = rect2;
					if (num3 > num4)
					{
						rect4.width = totalRect.width;
						rect4.height = rect2.height * totalRect.width / rect2.width;
					}
					else
					{
						rect4.width = rect2.width * totalRect.height / rect2.height;
						rect4.height = totalRect.height;
					}
					rect2 = rect4;
				}
			}
			else if (!rectParams.backgroundSize.x.IsNone() || !rectParams.backgroundSize.y.IsNone())
			{
				if (!rectParams.backgroundSize.x.IsNone() && rectParams.backgroundSize.y.IsAuto())
				{
					Rect rect5 = rect2;
					if (rectParams.backgroundSize.x.unit == LengthUnit.Percent)
					{
						rect5.width = totalRect.width * rectParams.backgroundSize.x.value / 100f;
						rect5.height = rect5.width * rect2.height / rect2.width;
					}
					else if (rectParams.backgroundSize.x.unit == LengthUnit.Pixel)
					{
						rect5.width = rectParams.backgroundSize.x.value;
						rect5.height = rect5.width * rect2.height / rect2.width;
					}
					rect2 = rect5;
				}
				else if (!rectParams.backgroundSize.x.IsNone() && !rectParams.backgroundSize.y.IsNone())
				{
					Rect rect6 = rect2;
					if (!rectParams.backgroundSize.x.IsAuto())
					{
						if (rectParams.backgroundSize.x.unit == LengthUnit.Percent)
						{
							rect6.width = totalRect.width * rectParams.backgroundSize.x.value / 100f;
						}
						else if (rectParams.backgroundSize.x.unit == LengthUnit.Pixel)
						{
							rect6.width = rectParams.backgroundSize.x.value;
						}
					}
					if (!rectParams.backgroundSize.y.IsAuto())
					{
						if (rectParams.backgroundSize.y.unit == LengthUnit.Percent)
						{
							rect6.height = totalRect.height * rectParams.backgroundSize.y.value / 100f;
						}
						else if (rectParams.backgroundSize.y.unit == LengthUnit.Pixel)
						{
							rect6.height = rectParams.backgroundSize.y.value;
						}
						if (rectParams.backgroundSize.x.IsAuto())
						{
							rect6.width = rect6.height * rect2.width / rect2.height;
						}
					}
					rect2 = rect6;
				}
			}
			if (rect2.size.x <= 1E-30f || rect2.size.y <= 1E-30f || totalRect.size.x <= 1E-30f || totalRect.size.y <= 1E-30f)
			{
				return;
			}
			if (rectParams.backgroundSize.x.IsAuto() && rectParams.backgroundRepeat.y == Repeat.Round)
			{
				float num5 = 1f / rect2.height;
				int val = (int)(totalRect.height * num5 + 0.5f);
				val = Math.Max(val, 1);
				Rect rect7 = default(Rect);
				rect7.height = totalRect.height / (float)val;
				rect7.width = rect7.height * rect2.width * num5;
				rect2 = rect7;
			}
			else if (rectParams.backgroundSize.y.IsAuto() && rectParams.backgroundRepeat.x == Repeat.Round)
			{
				float num6 = 1f / rect2.width;
				int val2 = (int)(totalRect.width * num6 + 0.5f);
				val2 = Math.Max(val2, 1);
				Rect rect8 = default(Rect);
				rect8.width = totalRect.width / (float)val2;
				rect8.height = rect8.width * rect2.height * num6;
				rect2 = rect8;
			}
			RepeatRectUV item2 = default(RepeatRectUV);
			RepeatRectUV item6 = default(RepeatRectUV);
			RepeatRectUV item3 = default(RepeatRectUV);
			RepeatRectUV item4 = default(RepeatRectUV);
			RepeatRectUV item5 = default(RepeatRectUV);
			RepeatRectUV item = default(RepeatRectUV);
			for (int i = 0; i < 2; i++)
			{
				Repeat repeat = ((i == 0) ? rectParams.backgroundRepeat.x : rectParams.backgroundRepeat.y);
				BackgroundPosition backgroundPosition = ((i == 0) ? rectParams.backgroundPositionX : rectParams.backgroundPositionY);
				float num7 = 0f;
				switch (repeat)
				{
				case Repeat.NoRepeat:
				{
					Rect rect10 = rect2;
					item2.uv = rect;
					item2.rect = rect10;
					num7 = rect10.size[i];
					m_RepeatRectUVList[i].Add(item2);
					break;
				}
				case Repeat.Repeat:
				{
					Rect rect12 = rect2;
					int num11 = (int)((totalRect.size[i] + 1f / scaledPixelsPerPoint) / rect2.size[i]);
					num11 = ((backgroundPosition.keyword != BackgroundPositionKeyword.Center) ? (num11 + 2) : (((num11 & 1) != 1) ? (num11 + 1) : (num11 + 2)));
					for (int l = 0; l < num11; l++)
					{
						Vector2 position4 = rect12.position;
						position4[i] = (float)l * rect2.size[i];
						rect12.position = position4;
						item6.rect = rect12;
						item6.uv = rect;
						num7 += item6.rect.size[i];
						m_RepeatRectUVList[i].Add(item6);
					}
					break;
				}
				case Repeat.Space:
				{
					Rect rect11 = rect2;
					int num9 = (int)(totalRect.size[i] / rect2.size[i]);
					if (num9 >= 0)
					{
						item3.rect = rect11;
						item3.uv = rect;
						m_RepeatRectUVList[i].Add(item3);
						num7 = rect2.size[i];
					}
					if (num9 >= 2)
					{
						Vector2 position2 = rect11.position;
						position2[i] = totalRect.size[i] - rect2.size[i];
						rect11.position = position2;
						item4.rect = rect11;
						item4.uv = rect;
						m_RepeatRectUVList[i].Add(item4);
						num7 = totalRect.size[i];
					}
					if (num9 > 2)
					{
						float num10 = (totalRect.size[i] - rect2.size[i] * (float)num9) / (float)(num9 - 1);
						for (int k = 0; k < num9 - 2; k++)
						{
							Vector2 position3 = rect11.position;
							position3[i] = (rect2.size[i] + num10) * (float)(1 + k);
							rect11.position = position3;
							item5.rect = rect11;
							item5.uv = rect;
							m_RepeatRectUVList[i].Add(item5);
						}
					}
					break;
				}
				case Repeat.Round:
				{
					int val3 = (int)((totalRect.size[i] + rect2.size[i] * 0.5f) / rect2.size[i]);
					val3 = Math.Max(val3, 1);
					float num8 = totalRect.size[i] / (float)val3;
					val3 = ((backgroundPosition.keyword != BackgroundPositionKeyword.Center) ? (val3 + 1) : (((val3 & 1) != 1) ? (val3 + 1) : (val3 + 2)));
					Rect rect9 = rect2;
					Vector2 size = rect9.size;
					size[i] = num8;
					rect9.size = size;
					for (int j = 0; j < val3; j++)
					{
						Vector2 position = rect9.position;
						position[i] = num8 * (float)j;
						rect9.position = position;
						item.rect = rect9;
						item.uv = rect;
						m_RepeatRectUVList[i].Add(item);
						num7 += item.rect.size[i];
					}
					break;
				}
				}
				float num12 = 0f;
				bool flag = false;
				if (backgroundPosition.keyword == BackgroundPositionKeyword.Center)
				{
					num12 = (totalRect.size[i] - num7) * 0.5f;
					flag = true;
				}
				else if (repeat != Repeat.Space)
				{
					if (backgroundPosition.offset.unit == LengthUnit.Percent)
					{
						num12 = (totalRect.size[i] - rect2.size[i]) * backgroundPosition.offset.value / 100f;
						flag = true;
					}
					else if (backgroundPosition.offset.unit == LengthUnit.Pixel)
					{
						num12 = backgroundPosition.offset.value;
					}
					if (backgroundPosition.keyword == BackgroundPositionKeyword.Right || backgroundPosition.keyword == BackgroundPositionKeyword.Bottom)
					{
						num12 = totalRect.size[i] - num7 - num12;
					}
				}
				if (flag && rectParams.sprite == null && rectParams.vectorImage == null)
				{
					float num13 = rect2.size[i] * scaledPixelsPerPoint;
					if (Mathf.Abs(Mathf.Round(num13) - num13) < 0.001f)
					{
						num12 = AlignmentUtils.CeilToPixelGrid(num12, scaledPixelsPerPoint);
					}
				}
				if (repeat == Repeat.Repeat || repeat == Repeat.Round)
				{
					float num14 = rect2.size[i];
					if (num14 > 1E-30f)
					{
						if (num12 < 0f - num14)
						{
							int num15 = (int)((0f - num12) / num14);
							num12 += (float)num15 * num14;
						}
						if (num12 > 0f)
						{
							int num16 = (int)(num12 / num14);
							num12 -= (float)(1 + num16) * num14;
						}
					}
				}
				for (int m = 0; m < m_RepeatRectUVList[i].Count; m++)
				{
					RepeatRectUV value = m_RepeatRectUVList[i][m];
					Vector2 position5 = value.rect.position;
					position5[i] += num12;
					value.rect.position = position5;
					m_RepeatRectUVList[i][m] = value;
				}
			}
			Rect rect13 = new Rect(rect);
			foreach (RepeatRectUV item7 in m_RepeatRectUVList[1])
			{
				Rect rect14 = item7.rect;
				rect2.y = rect14.y;
				rect14 = item7.rect;
				rect2.height = rect14.height;
				rect14 = item7.uv;
				rect.y = rect14.y;
				rect14 = item7.uv;
				rect.height = rect14.height;
				if (rect2.y < totalRect.y)
				{
					float num17 = totalRect.y - rect2.y;
					float num18 = rect2.height - num17;
					float num19 = num17 + num18;
					float height = rect13.height * num18 / num19;
					float num20 = rect13.height * num17 / num19;
					rect.y = num20 + rect13.y;
					rect.height = height;
					rect2.y = totalRect.y;
					rect2.height = num18;
				}
				if (rect2.yMax > totalRect.yMax)
				{
					float num21 = rect2.yMax - totalRect.yMax;
					float num22 = rect2.height - num21;
					float num23 = num22 + num21;
					float num24 = (rect.height = rect.height * num22 / num23);
					rect.y = rect.yMax - num24;
					rect2.height = num22;
				}
				if (rectParams.vectorImage == null)
				{
					float num26 = rect.y - rect13.y;
					float num27 = rect13.yMax - rect.yMax;
					rect.y += num27 - num26;
				}
				foreach (RepeatRectUV item8 in m_RepeatRectUVList[0])
				{
					rect14 = item8.rect;
					rect2.x = rect14.x;
					rect14 = item8.rect;
					rect2.width = rect14.width;
					rect14 = item8.uv;
					rect.x = rect14.x;
					rect14 = item8.uv;
					rect.width = rect14.width;
					if (rect2.x < totalRect.x)
					{
						float num28 = totalRect.x - rect2.x;
						float num29 = rect2.width - num28;
						float num30 = num28 + num29;
						float width = rect.width * num29 / num30;
						float x = rect13.x + rect13.width * num28 / num30;
						rect.x = x;
						rect.width = width;
						rect2.x = totalRect.x;
						rect2.width = num29;
					}
					if (rect2.xMax > totalRect.xMax)
					{
						float num31 = rect2.xMax - totalRect.xMax;
						float num32 = rect2.width - num31;
						float num33 = num32 + num31;
						float width2 = rect.width * num32 / num33;
						rect.width = width2;
						rect2.width = num32;
					}
					StampRectangleWithSubRect(rectParams, rect2, rect);
				}
			}
		}

		private void StampRectangleWithSubRect(MeshGenerationContextUtils.RectangleParams rectParams, Rect targetRect, Rect targetUV)
		{
			if (targetRect.width < 1E-30f || targetRect.height < 1E-30f)
			{
				return;
			}
			Rect rect = targetRect;
			rect.size /= targetUV.size;
			rect.position -= new Vector2(targetUV.position.x, 1f - targetUV.position.y - targetUV.size.y) * rect.size;
			Rect subRect = rectParams.subRect;
			subRect.position *= rect.size;
			subRect.position += rect.position;
			subRect.size *= rect.size;
			if (rectParams.HasSlices(1E-30f))
			{
				rectParams.rect = targetRect;
			}
			else
			{
				Rect rect2 = MeshGenerationContextUtils.RectangleParams.RectIntersection(subRect, targetRect);
				if (rect2.size.x < 1E-30f || rect2.size.y < 1E-30f)
				{
					return;
				}
				if (rect2.size != subRect.size)
				{
					Vector2 vector = rect2.size / subRect.size;
					Vector2 vector2 = rectParams.uv.size * vector;
					Vector2 vector3 = rectParams.uv.size - vector2;
					if (rect2.x > subRect.x)
					{
						float num = (subRect.xMax - rect2.xMax) / subRect.width * rectParams.uv.size.x;
						rectParams.uv.x += vector3.x - num;
					}
					if (rect2.yMax < subRect.yMax)
					{
						float num2 = (rect2.y - subRect.y) / subRect.height * rectParams.uv.size.y;
						rectParams.uv.y += vector3.y - num2;
					}
					rectParams.uv.size = vector2;
				}
				rectParams.rect = rect2;
			}
			DrawRectangle(rectParams);
		}

		public void DrawVisualElementBorder()
		{
			if (currentElement.layout.width >= 1E-30f && currentElement.layout.height >= 1E-30f)
			{
				IResolvedStyle resolvedStyle = currentElement.resolvedStyle;
				if ((resolvedStyle.borderLeftColor != Color.clear && resolvedStyle.borderLeftWidth > 0f) || (resolvedStyle.borderTopColor != Color.clear && resolvedStyle.borderTopWidth > 0f) || (resolvedStyle.borderRightColor != Color.clear && resolvedStyle.borderRightWidth > 0f) || (resolvedStyle.borderBottomColor != Color.clear && resolvedStyle.borderBottomWidth > 0f))
				{
					MeshGenerationContextUtils.BorderParams borderParams = new MeshGenerationContextUtils.BorderParams
					{
						rect = currentElement.rect,
						leftColor = resolvedStyle.borderLeftColor,
						topColor = resolvedStyle.borderTopColor,
						rightColor = resolvedStyle.borderRightColor,
						bottomColor = resolvedStyle.borderBottomColor,
						leftWidth = resolvedStyle.borderLeftWidth,
						topWidth = resolvedStyle.borderTopWidth,
						rightWidth = resolvedStyle.borderRightWidth,
						bottomWidth = resolvedStyle.borderBottomWidth,
						leftColorPage = ColorPage.Init(m_Owner, currentElement.renderChainData.borderLeftColorID),
						topColorPage = ColorPage.Init(m_Owner, currentElement.renderChainData.borderTopColorID),
						rightColorPage = ColorPage.Init(m_Owner, currentElement.renderChainData.borderRightColorID),
						bottomColorPage = ColorPage.Init(m_Owner, currentElement.renderChainData.borderBottomColorID),
						playmodeTintColor = ((currentElement.panel.contextType == ContextType.Editor) ? UIElementsUtility.editorPlayModeTintColor : Color.white)
					};
					MeshGenerationContextUtils.GetVisualElementRadii(currentElement, out borderParams.topLeftRadius, out borderParams.bottomLeftRadius, out borderParams.topRightRadius, out borderParams.bottomRightRadius);
					DrawBorder(borderParams);
				}
			}
		}

		public void ApplyVisualElementClipping()
		{
			if (currentElement.renderChainData.clipMethod == ClipMethod.Scissor)
			{
				RenderChainCommand renderChainCommand = m_Owner.AllocCommand();
				renderChainCommand.type = CommandType.PushScissor;
				renderChainCommand.owner = currentElement;
				m_Entries.Add(new Entry
				{
					customCommand = renderChainCommand
				});
				m_ClosingInfo.needsClosing = (m_ClosingInfo.popScissorClip = true);
			}
			else if (currentElement.renderChainData.clipMethod == ClipMethod.Stencil)
			{
				if (m_MaskDepth > m_StencilRef)
				{
					m_StencilRef++;
					Debug.Assert(m_MaskDepth == m_StencilRef);
				}
				m_ClosingInfo.maskStencilRef = m_StencilRef;
				if (UIRUtility.IsVectorImageBackground(currentElement))
				{
					GenerateStencilClipEntryForSVGBackground();
				}
				else
				{
					GenerateStencilClipEntryForRoundedRectBackground();
				}
				m_MaskDepth++;
			}
			m_ClipRectID = currentElement.renderChainData.clipRectID;
		}

		private ushort[] AdjustSpriteWinding(Vector2[] vertices, ushort[] indices)
		{
			ushort[] array = new ushort[indices.Length];
			for (int i = 0; i < indices.Length; i += 3)
			{
				Vector3 vector = vertices[indices[i]];
				Vector3 vector2 = vertices[indices[i + 1]];
				Vector3 vector3 = vertices[indices[i + 2]];
				Vector3 normalized = (vector2 - vector).normalized;
				Vector3 normalized2 = (vector3 - vector).normalized;
				if (Vector3.Cross(normalized, normalized2).z >= 0f)
				{
					array[i] = indices[i + 1];
					array[i + 1] = indices[i];
					array[i + 2] = indices[i + 2];
				}
				else
				{
					array[i] = indices[i];
					array[i + 1] = indices[i + 1];
					array[i + 2] = indices[i + 2];
				}
			}
			return array;
		}

		public void DrawSprite(MeshGenerationContextUtils.RectangleParams rectParams)
		{
			Sprite sprite = rectParams.sprite;
			if (!(sprite.texture == null) && sprite.triangles.Length != 0)
			{
				MeshBuilder.AllocMeshData allocMeshData = new MeshBuilder.AllocMeshData
				{
					alloc = m_AllocThroughDrawMeshDelegate,
					texture = sprite.texture,
					flags = rectParams.meshFlags
				};
				Vector2[] vertices = sprite.vertices;
				ushort[] triangles = sprite.triangles;
				Vector2[] uv = sprite.uv;
				int num = sprite.vertices.Length;
				Vertex[] array = new Vertex[num];
				ushort[] array2 = AdjustSpriteWinding(vertices, triangles);
				MeshWriteData meshWriteData = allocMeshData.Allocate((uint)array.Length, (uint)array2.Length);
				Rect uvRegion = meshWriteData.uvRegion;
				ColorPage colorPage = rectParams.colorPage;
				Color32 pageAndID = colorPage.pageAndID;
				Color32 flags = new Color32(0, 0, 0, (byte)(colorPage.isValid ? 1 : 0));
				Color32 opacityColorPages = new Color32(0, 0, colorPage.pageAndID.r, colorPage.pageAndID.g);
				Color32 ids = new Color32(0, 0, 0, colorPage.pageAndID.b);
				for (int i = 0; i < num; i++)
				{
					Vector2 vector = vertices[i];
					vector -= rectParams.spriteGeomRect.position;
					vector /= rectParams.spriteGeomRect.size;
					vector.y = 1f - vector.y;
					vector *= rectParams.rect.size;
					vector += rectParams.rect.position;
					Vector2 uv2 = uv[i];
					uv2 *= uvRegion.size;
					uv2 += uvRegion.position;
					array[i] = new Vertex
					{
						position = new Vector3(vector.x, vector.y, Vertex.nearZ),
						tint = rectParams.color,
						uv = uv2,
						flags = flags,
						opacityColorPages = opacityColorPages,
						ids = ids
					};
				}
				meshWriteData.SetAllVertices(array);
				meshWriteData.SetAllIndices(array2);
			}
		}

		private void ApplyInset(ref MeshBuilderNative.NativeRectParams rectParams, Texture tex)
		{
			Rect rect = rectParams.rect;
			Vector4 rectInset = rectParams.rectInset;
			if (!Mathf.Approximately(rect.size.x, 0f) && !Mathf.Approximately(rect.size.y, 0f) && !(rectInset == Vector4.zero))
			{
				Rect rect2 = rect;
				rect.x += rectInset.x;
				rect.y += rectInset.y;
				rect.width -= rectInset.x + rectInset.z;
				rect.height -= rectInset.y + rectInset.w;
				rectParams.rect = rect;
				Rect uv = rectParams.uv;
				if (tex != null && uv.width > 1E-30f && uv.height > 1E-30f)
				{
					Vector2 vector = new Vector2(1f / rect2.width, 1f / rect2.height);
					uv.x += rectInset.x * vector.x;
					uv.y += rectInset.w * vector.y;
					uv.width -= (rectInset.x + rectInset.z) * vector.x;
					uv.height -= (rectInset.y + rectInset.w) * vector.y;
					rectParams.uv = uv;
				}
			}
		}

		public void RegisterVectorImageGradient(VectorImage vi, out int settingIndexOffset, out TextureId texture)
		{
			texture = default(TextureId);
			GradientRemap gradientRemap = m_VectorImageManager.AddUser(vi, currentElement);
			settingIndexOffset = gradientRemap.destIndex;
			if (gradientRemap.atlas != TextureId.invalid)
			{
				texture = gradientRemap.atlas;
				return;
			}
			texture = TextureRegistry.instance.Acquire(vi.atlas);
			m_Owner.AppendTexture(currentElement, vi.atlas, texture, isAtlas: false);
		}

		public void DrawVectorImage(MeshGenerationContextUtils.RectangleParams rectParams)
		{
			VectorImage vectorImage = rectParams.vectorImage;
			Debug.Assert(vectorImage != null);
			int settingIndexOffset = 0;
			TextureId textureId = default(TextureId);
			bool flag = vectorImage.atlas != null && m_VectorImageManager != null;
			if (flag)
			{
				GradientRemap gradientRemap = m_VectorImageManager.AddUser(vectorImage, currentElement);
				settingIndexOffset = gradientRemap.destIndex;
				if (gradientRemap.atlas != TextureId.invalid)
				{
					textureId = gradientRemap.atlas;
				}
				else
				{
					textureId = TextureRegistry.instance.Acquire(vectorImage.atlas);
					m_Owner.AppendTexture(currentElement, vectorImage.atlas, textureId, isAtlas: false);
				}
			}
			int count = m_Entries.Count;
			MakeVectorGraphics(rectParams, flag, textureId, settingIndexOffset, out var finalVertexCount, out var finalIndexCount);
			Debug.Assert(count <= m_Entries.Count + 1);
			if (count != m_Entries.Count)
			{
				m_SVGBackgroundEntryIndex = m_Entries.Count - 1;
				if (finalVertexCount != 0 && finalIndexCount != 0)
				{
					Entry value = m_Entries[m_SVGBackgroundEntryIndex];
					value.vertices = value.vertices.Slice(0, finalVertexCount);
					value.indices = value.indices.Slice(0, finalIndexCount);
					m_Entries[m_SVGBackgroundEntryIndex] = value;
				}
			}
		}

		private void MakeVectorGraphics(MeshGenerationContextUtils.RectangleParams rectParams, bool isUsingGradients, TextureId svgTexture, int settingIndexOffset, out int finalVertexCount, out int finalIndexCount)
		{
			VectorImage vectorImage = rectParams.vectorImage;
			Debug.Assert(vectorImage != null);
			finalVertexCount = 0;
			finalIndexCount = 0;
			int num = vectorImage.vertices.Length;
			Vertex[] array = new Vertex[num];
			for (int i = 0; i < num; i++)
			{
				VectorImageVertex vectorImageVertex = vectorImage.vertices[i];
				array[i] = new Vertex
				{
					position = vectorImageVertex.position,
					tint = vectorImageVertex.tint,
					uv = vectorImageVertex.uv,
					settingIndex = new Color32((byte)(vectorImageVertex.settingIndex >> 8), (byte)vectorImageVertex.settingIndex, 0, 0),
					flags = vectorImageVertex.flags,
					circle = vectorImageVertex.circle
				};
			}
			MeshWriteDataInterface meshData = ((!((float)rectParams.leftSlice <= 1E-30f) || !((float)rectParams.topSlice <= 1E-30f) || !((float)rectParams.rightSlice <= 1E-30f) || !((float)rectParams.bottomSlice <= 1E-30f)) ? MeshBuilderNative.MakeVectorGraphics9SliceBackground(sliceLTRB: new Vector4(rectParams.leftSlice, rectParams.topSlice, rectParams.rightSlice, rectParams.bottomSlice), svgVertices: array, svgIndices: vectorImage.indices, svgWidth: vectorImage.size.x, svgHeight: vectorImage.size.y, targetRect: rectParams.rect, tint: rectParams.color, colorPage: rectParams.colorPage.ToNativeColorPage(), settingIndexOffset: settingIndexOffset) : MeshBuilderNative.MakeVectorGraphicsStretchBackground(array, vectorImage.indices, vectorImage.size.x, vectorImage.size.y, rectParams.rect, rectParams.uv, rectParams.scaleMode, rectParams.color, rectParams.colorPage.ToNativeColorPage(), settingIndexOffset, ref finalVertexCount, ref finalIndexCount));
			if (isUsingGradients)
			{
				BuildGradientEntryFromNativeMesh(meshData, svgTexture);
			}
			else
			{
				BuildEntryFromNativeMesh(meshData, null, default(TextureId), isAtlas: false, null, MeshGenerationContext.MeshFlags.None, new Rect(0f, 0f, 1f, 1f), VertexFlags.IsSolid);
			}
		}

		internal void Reset()
		{
			ValidateMeshWriteData();
			m_Entries.Clear();
			m_ClosingInfo = default(ClosingInfo);
			m_NextMeshWriteDataPoolItem = 0;
			currentElement = null;
			int num = (totalIndices = 0);
			totalVertices = num;
		}

		private void ValidateMeshWriteData()
		{
			for (int i = 0; i < m_NextMeshWriteDataPoolItem; i++)
			{
				MeshWriteData meshWriteData = m_MeshWriteDataPool[i];
				if (meshWriteData.vertexCount > 0 && meshWriteData.currentVertex < meshWriteData.vertexCount)
				{
					Debug.LogError("Not enough vertices written in generateVisualContent callback (asked for " + meshWriteData.vertexCount + " but only wrote " + meshWriteData.currentVertex + ")");
					Vertex nextVertex = meshWriteData.m_Vertices[0];
					while (meshWriteData.currentVertex < meshWriteData.vertexCount)
					{
						meshWriteData.SetNextVertex(nextVertex);
					}
				}
				if (meshWriteData.indexCount > 0 && meshWriteData.currentIndex < meshWriteData.indexCount)
				{
					Debug.LogError("Not enough indices written in generateVisualContent callback (asked for " + meshWriteData.indexCount + " but only wrote " + meshWriteData.currentIndex + ")");
					while (meshWriteData.currentIndex < meshWriteData.indexCount)
					{
						meshWriteData.SetNextIndex(0);
					}
				}
			}
		}

		private void GenerateStencilClipEntryForRoundedRectBackground()
		{
			if (!(currentElement.layout.width <= 1E-30f) && !(currentElement.layout.height <= 1E-30f))
			{
				IResolvedStyle resolvedStyle = currentElement.resolvedStyle;
				MeshGenerationContextUtils.GetVisualElementRadii(currentElement, out var topLeft, out var bottomLeft, out var topRight, out var bottomRight);
				float borderTopWidth = resolvedStyle.borderTopWidth;
				float borderLeftWidth = resolvedStyle.borderLeftWidth;
				float borderBottomWidth = resolvedStyle.borderBottomWidth;
				float borderRightWidth = resolvedStyle.borderRightWidth;
				MeshGenerationContextUtils.RectangleParams rectangleParams = new MeshGenerationContextUtils.RectangleParams
				{
					rect = currentElement.rect,
					color = Color.white,
					topLeftRadius = Vector2.Max(Vector2.zero, topLeft - new Vector2(borderLeftWidth, borderTopWidth)),
					topRightRadius = Vector2.Max(Vector2.zero, topRight - new Vector2(borderRightWidth, borderTopWidth)),
					bottomLeftRadius = Vector2.Max(Vector2.zero, bottomLeft - new Vector2(borderLeftWidth, borderBottomWidth)),
					bottomRightRadius = Vector2.Max(Vector2.zero, bottomRight - new Vector2(borderRightWidth, borderBottomWidth)),
					playmodeTintColor = ((currentElement.panel.contextType == ContextType.Editor) ? UIElementsUtility.editorPlayModeTintColor : Color.white)
				};
				rectangleParams.rect.x += borderLeftWidth;
				rectangleParams.rect.y += borderTopWidth;
				rectangleParams.rect.width -= borderLeftWidth + borderRightWidth;
				rectangleParams.rect.height -= borderTopWidth + borderBottomWidth;
				if (currentElement.computedStyle.unityOverflowClipBox == OverflowClipBox.ContentBox)
				{
					rectangleParams.rect.x += resolvedStyle.paddingLeft;
					rectangleParams.rect.y += resolvedStyle.paddingTop;
					rectangleParams.rect.width -= resolvedStyle.paddingLeft + resolvedStyle.paddingRight;
					rectangleParams.rect.height -= resolvedStyle.paddingTop + resolvedStyle.paddingBottom;
				}
				m_CurrentEntry.clipRectID = m_ClipRectID;
				m_CurrentEntry.stencilRef = m_StencilRef;
				m_CurrentEntry.maskDepth = m_MaskDepth;
				m_CurrentEntry.isClipRegisterEntry = true;
				MeshBuilderNative.NativeRectParams rectParams = rectangleParams.ToNativeParams(new Rect(0f, 0f, 1f, 1f));
				MeshWriteDataInterface meshData = MeshBuilderNative.MakeSolidRect(rectParams, 1f);
				if (meshData.vertexCount > 0 && meshData.indexCount > 0)
				{
					BuildRawEntryFromNativeMesh(meshData);
					m_Entries.Add(m_CurrentEntry);
					totalVertices += m_CurrentEntry.vertices.Length;
					totalIndices += m_CurrentEntry.indices.Length;
					m_ClosingInfo.needsClosing = true;
				}
				m_CurrentEntry = default(Entry);
			}
		}

		private void GenerateStencilClipEntryForSVGBackground()
		{
			if (m_SVGBackgroundEntryIndex != -1)
			{
				Entry entry = m_Entries[m_SVGBackgroundEntryIndex];
				Debug.Assert(entry.vertices.Length > 0);
				Debug.Assert(entry.indices.Length > 0);
				m_CurrentEntry.vertices = entry.vertices;
				m_CurrentEntry.indices = entry.indices;
				m_CurrentEntry.uvIsDisplacement = entry.uvIsDisplacement;
				m_CurrentEntry.clipRectID = m_ClipRectID;
				m_CurrentEntry.stencilRef = m_StencilRef;
				m_CurrentEntry.maskDepth = m_MaskDepth;
				m_CurrentEntry.isClipRegisterEntry = true;
				m_ClosingInfo.needsClosing = true;
				int length = m_CurrentEntry.vertices.Length;
				NativeSlice<Vertex> vertices = m_VertsPool.Alloc(length);
				for (int i = 0; i < length; i++)
				{
					Vertex value = m_CurrentEntry.vertices[i];
					value.position.z = 1f;
					vertices[i] = value;
				}
				m_CurrentEntry.vertices = vertices;
				totalVertices += m_CurrentEntry.vertices.Length;
				totalIndices += m_CurrentEntry.indices.Length;
				m_Entries.Add(m_CurrentEntry);
				m_CurrentEntry = default(Entry);
			}
		}
	}
}
namespace UnityEngine.UIElements.StyleSheets
{
	internal abstract class HierarchyTraversal
	{
		public virtual void Traverse(VisualElement element)
		{
			TraverseRecursive(element, 0);
		}

		public abstract void TraverseRecursive(VisualElement element, int depth);

		protected void Recurse(VisualElement element, int depth)
		{
			int num = 0;
			while (num < element.hierarchy.childCount)
			{
				VisualElement visualElement = element.hierarchy[num];
				TraverseRecursive(visualElement, depth + 1);
				if (visualElement.hierarchy.parent == element)
				{
					num++;
				}
			}
		}
	}
	internal static class InitialStyle
	{
		private static ComputedStyle s_InitialStyle;

		public static Align alignContent => s_InitialStyle.layoutData.Read().alignContent;

		public static Align alignItems => s_InitialStyle.layoutData.Read().alignItems;

		public static Align alignSelf => s_InitialStyle.layoutData.Read().alignSelf;

		public static Color backgroundColor => s_InitialStyle.visualData.Read().backgroundColor;

		public static Background backgroundImage => s_InitialStyle.visualData.Read().backgroundImage;

		public static BackgroundPosition backgroundPositionX => s_InitialStyle.visualData.Read().backgroundPositionX;

		public static BackgroundPosition backgroundPositionY => s_InitialStyle.visualData.Read().backgroundPositionY;

		public static BackgroundRepeat backgroundRepeat => s_InitialStyle.visualData.Read().backgroundRepeat;

		public static BackgroundSize backgroundSize => s_InitialStyle.visualData.Read().backgroundSize;

		public static Color borderBottomColor => s_InitialStyle.visualData.Read().borderBottomColor;

		public static Length borderBottomLeftRadius => s_InitialStyle.visualData.Read().borderBottomLeftRadius;

		public static Length borderBottomRightRadius => s_InitialStyle.visualData.Read().borderBottomRightRadius;

		public static float borderBottomWidth => s_InitialStyle.layoutData.Read().borderBottomWidth;

		public static Color borderLeftColor => s_InitialStyle.visualData.Read().borderLeftColor;

		public static float borderLeftWidth => s_InitialStyle.layoutData.Read().borderLeftWidth;

		public static Color borderRightColor => s_InitialStyle.visualData.Read().borderRightColor;

		public static float borderRightWidth => s_InitialStyle.layoutData.Read().borderRightWidth;

		public static Color borderTopColor => s_InitialStyle.visualData.Read().borderTopColor;

		public static Length borderTopLeftRadius => s_InitialStyle.visualData.Read().borderTopLeftRadius;

		public static Length borderTopRightRadius => s_InitialStyle.visualData.Read().borderTopRightRadius;

		public static float borderTopWidth => s_InitialStyle.layoutData.Read().borderTopWidth;

		public static Length bottom => s_InitialStyle.layoutData.Read().bottom;

		public static Color color => s_InitialStyle.inheritedData.Read().color;

		public static Cursor cursor => s_InitialStyle.rareData.Read().cursor;

		public static DisplayStyle display => s_InitialStyle.layoutData.Read().display;

		public static Length flexBasis => s_InitialStyle.layoutData.Read().flexBasis;

		public static FlexDirection flexDirection => s_InitialStyle.layoutData.Read().flexDirection;

		public static float flexGrow => s_InitialStyle.layoutData.Read().flexGrow;

		public static float flexShrink => s_InitialStyle.layoutData.Read().flexShrink;

		public static Wrap flexWrap => s_InitialStyle.layoutData.Read().flexWrap;

		public static Length fontSize => s_InitialStyle.inheritedData.Read().fontSize;

		public static Length height => s_InitialStyle.layoutData.Read().height;

		public static Justify justifyContent => s_InitialStyle.layoutData.Read().justifyContent;

		public static Length left => s_InitialStyle.layoutData.Read().left;

		public static Length letterSpacing => s_InitialStyle.inheritedData.Read().letterSpacing;

		public static Length marginBottom => s_InitialStyle.layoutData.Read().marginBottom;

		public static Length marginLeft => s_InitialStyle.layoutData.Read().marginLeft;

		public static Length marginRight => s_InitialStyle.layoutData.Read().marginRight;

		public static Length marginTop => s_InitialStyle.layoutData.Read().marginTop;

		public static Length maxHeight => s_InitialStyle.layoutData.Read().maxHeight;

		public static Length maxWidth => s_InitialStyle.layoutData.Read().maxWidth;

		public static Length minHeight => s_InitialStyle.layoutData.Read().minHeight;

		public static Length minWidth => s_InitialStyle.layoutData.Read().minWidth;

		public static float opacity => s_InitialStyle.visualData.Read().opacity;

		public static OverflowInternal overflow => s_InitialStyle.visualData.Read().overflow;

		public static Length paddingBottom => s_InitialStyle.layoutData.Read().paddingBottom;

		public static Length paddingLeft => s_InitialStyle.layoutData.Read().paddingLeft;

		public static Length paddingRight => s_InitialStyle.layoutData.Read().paddingRight;

		public static Length paddingTop => s_InitialStyle.layoutData.Read().paddingTop;

		public static Position position => s_InitialStyle.layoutData.Read().position;

		public static Length right => s_InitialStyle.layoutData.Read().right;

		public static Rotate rotate => s_InitialStyle.transformData.Read().rotate;

		public static Scale scale => s_InitialStyle.transformData.Read().scale;

		public static TextOverflow textOverflow => s_InitialStyle.rareData.Read().textOverflow;

		public static TextShadow textShadow => s_InitialStyle.inheritedData.Read().textShadow;

		public static Length top => s_InitialStyle.layoutData.Read().top;

		public static TransformOrigin transformOrigin => s_InitialStyle.transformData.Read().transformOrigin;

		public static List<TimeValue> transitionDelay => s_InitialStyle.transitionData.Read().transitionDelay;

		public static List<TimeValue> transitionDuration => s_InitialStyle.transitionData.Read().transitionDuration;

		public static List<StylePropertyName> transitionProperty => s_InitialStyle.transitionData.Read().transitionProperty;

		public static List<EasingFunction> transitionTimingFunction => s_InitialStyle.transitionData.Read().transitionTimingFunction;

		public static Translate translate => s_InitialStyle.transformData.Read().translate;

		public static Color unityBackgroundImageTintColor => s_InitialStyle.rareData.Read().unityBackgroundImageTintColor;

		public static Font unityFont => s_InitialStyle.inheritedData.Read().unityFont;

		public static FontDefinition unityFontDefinition => s_InitialStyle.inheritedData.Read().unityFontDefinition;

		public static FontStyle unityFontStyleAndWeight => s_InitialStyle.inheritedData.Read().unityFontStyleAndWeight;

		public static OverflowClipBox unityOverflowClipBox => s_InitialStyle.rareData.Read().unityOverflowClipBox;

		public static Length unityParagraphSpacing => s_InitialStyle.inheritedData.Read().unityParagraphSpacing;

		public static int unitySliceBottom => s_InitialStyle.rareData.Read().unitySliceBottom;

		public static int unitySliceLeft => s_InitialStyle.rareData.Read().unitySliceLeft;

		public static int unitySliceRight => s_InitialStyle.rareData.Read().unitySliceRight;

		public static float unitySliceScale => s_InitialStyle.rareData.Read().unitySliceScale;

		public static int unitySliceTop => s_InitialStyle.rareData.Read().unitySliceTop;

		public static TextAnchor unityTextAlign => s_InitialStyle.inheritedData.Read().unityTextAlign;

		public static Color unityTextOutlineColor => s_InitialStyle.inheritedData.Read().unityTextOutlineColor;

		public static float unityTextOutlineWidth => s_InitialStyle.inheritedData.Read().unityTextOutlineWidth;

		public static TextOverflowPosition unityTextOverflowPosition => s_InitialStyle.rareData.Read().unityTextOverflowPosition;

		public static Visibility visibility => s_InitialStyle.inheritedData.Read().visibility;

		public static WhiteSpace whiteSpace => s_InitialStyle.inheritedData.Read().whiteSpace;

		public static Length width => s_InitialStyle.layoutData.Read().width;

		public static Length wordSpacing => s_InitialStyle.inheritedData.Read().wordSpacing;

		public static ref ComputedStyle Get()
		{
			return ref s_InitialStyle;
		}

		public static ComputedStyle Acquire()
		{
			return s_InitialStyle.Acquire();
		}

		static InitialStyle()
		{
			s_InitialStyle = ComputedStyle.CreateInitial();
			s_InitialStyle.layoutData.Write().alignContent = Align.FlexStart;
			s_InitialStyle.layoutData.Write().alignItems = Align.Stretch;
			s_InitialStyle.layoutData.Write().alignSelf = Align.Auto;
			s_InitialStyle.visualData.Write().backgroundColor = Color.clear;
			s_InitialStyle.visualData.Write().backgroundImage = default(Background);
			s_InitialStyle.visualData.Write().backgroundPositionX = BackgroundPosition.Initial();
			s_InitialStyle.visualData.Write().backgroundPositionY = BackgroundPosition.Initial();
			s_InitialStyle.visualData.Write().backgroundRepeat = BackgroundRepeat.Initial();
			s_InitialStyle.visualData.Write().backgroundSize = BackgroundSize.Initial();
			s_InitialStyle.visualData.Write().borderBottomColor = Color.clear;
			s_InitialStyle.visualData.Write().borderBottomLeftRadius = 0f;
			s_InitialStyle.visualData.Write().borderBottomRightRadius = 0f;
			s_InitialStyle.layoutData.Write().borderBottomWidth = 0f;
			s_InitialStyle.visualData.Write().borderLeftColor = Color.clear;
			s_InitialStyle.layoutData.Write().borderLeftWidth = 0f;
			s_InitialStyle.visualData.Write().borderRightColor = Color.clear;
			s_InitialStyle.layoutData.Write().borderRightWidth = 0f;
			s_InitialStyle.visualData.Write().borderTopColor = Color.clear;
			s_InitialStyle.visualData.Write().borderTopLeftRadius = 0f;
			s_InitialStyle.visualData.Write().borderTopRightRadius = 0f;
			s_InitialStyle.layoutData.Write().borderTopWidth = 0f;
			s_InitialStyle.layoutData.Write().bottom = StyleKeyword.Auto.ToLength();
			s_InitialStyle.inheritedData.Write().color = Color.black;
			s_InitialStyle.rareData.Write().cursor = default(Cursor);
			s_InitialStyle.layoutData.Write().display = DisplayStyle.Flex;
			s_InitialStyle.layoutData.Write().flexBasis = StyleKeyword.Auto.ToLength();
			s_InitialStyle.layoutData.Write().flexDirection = FlexDirection.Column;
			s_InitialStyle.layoutData.Write().flexGrow = 0f;
			s_InitialStyle.layoutData.Write().flexShrink = 1f;
			s_InitialStyle.layoutData.Write().flexWrap = Wrap.NoWrap;
			s_InitialStyle.inheritedData.Write().fontSize = 0f;
			s_InitialStyle.layoutData.Write().height = StyleKeyword.Auto.ToLength();
			s_InitialStyle.layoutData.Write().justifyContent = Justify.FlexStart;
			s_InitialStyle.layoutData.Write().left = StyleKeyword.Auto.ToLength();
			s_InitialStyle.inheritedData.Write().letterSpacing = 0f;
			s_InitialStyle.layoutData.Write().marginBottom = 0f;
			s_InitialStyle.layoutData.Write().marginLeft = 0f;
			s_InitialStyle.layoutData.Write().marginRight = 0f;
			s_InitialStyle.layoutData.Write().marginTop = 0f;
			s_InitialStyle.layoutData.Write().maxHeight = StyleKeyword.None.ToLength();
			s_InitialStyle.layoutData.Write().maxWidth = StyleKeyword.None.ToLength();
			s_InitialStyle.layoutData.Write().minHeight = StyleKeyword.Auto.ToLength();
			s_InitialStyle.layoutData.Write().minWidth = StyleKeyword.Auto.ToLength();
			s_InitialStyle.visualData.Write().opacity = 1f;
			s_InitialStyle.visualData.Write().overflow = OverflowInternal.Visible;
			s_InitialStyle.layoutData.Write().paddingBottom = 0f;
			s_InitialStyle.layoutData.Write().paddingLeft = 0f;
			s_InitialStyle.layoutData.Write().paddingRight = 0f;
			s_InitialStyle.layoutData.Write().paddingTop = 0f;
			s_InitialStyle.layoutData.Write().position = Position.Relative;
			s_InitialStyle.layoutData.Write().right = StyleKeyword.Auto.ToLength();
			s_InitialStyle.transformData.Write().rotate = StyleKeyword.None.ToRotate();
			s_InitialStyle.transformData.Write().scale = StyleKeyword.None.ToScale();
			s_InitialStyle.rareData.Write().textOverflow = TextOverflow.Clip;
			s_InitialStyle.inheritedData.Write().textShadow = default(TextShadow);
			s_InitialStyle.layoutData.Write().top = StyleKeyword.Auto.ToLength();
			s_InitialStyle.transformData.Write().transformOrigin = TransformOrigin.Initial();
			s_InitialStyle.transitionData.Write().transitionDelay = new List<TimeValue> { 0f };
			s_InitialStyle.transitionData.Write().transitionDuration = new List<TimeValue> { 0f };
			s_InitialStyle.transitionData.Write().transitionProperty = new List<StylePropertyName> { "all" };
			s_InitialStyle.transitionData.Write().transitionTimingFunction = new List<EasingFunction> { EasingMode.Ease };
			s_InitialStyle.transformData.Write().translate = StyleKeyword.None.ToTranslate();
			s_InitialStyle.rareData.Write().unityBackgroundImageTintColor = Color.white;
			s_InitialStyle.inheritedData.Write().unityFont = null;
			s_InitialStyle.inheritedData.Write().unityFontDefinition = default(FontDefinition);
			s_InitialStyle.inheritedData.Write().unityFontStyleAndWeight = FontStyle.Normal;
			s_InitialStyle.rareData.Write().unityOverflowClipBox = OverflowClipBox.PaddingBox;
			s_InitialStyle.inheritedData.Write().unityParagraphSpacing = 0f;
			s_InitialStyle.rareData.Write().unitySliceBottom = 0;
			s_InitialStyle.rareData.Write().unitySliceLeft = 0;
			s_InitialStyle.rareData.Write().unitySliceRight = 0;
			s_InitialStyle.rareData.Write().unitySliceScale = 1f;
			s_InitialStyle.rareData.Write().unitySliceTop = 0;
			s_InitialStyle.inheritedData.Write().unityTextAlign = TextAnchor.UpperLeft;
			s_InitialStyle.inheritedData.Write().unityTextOutlineColor = Color.clear;
			s_InitialStyle.inheritedData.Write().unityTextOutlineWidth = 0f;
			s_InitialStyle.rareData.Write().unityTextOverflowPosition = TextOverflowPosition.End;
			s_InitialStyle.inheritedData.Write().visibility = Visibility.Visible;
			s_InitialStyle.inheritedData.Write().whiteSpace = WhiteSpace.Normal;
			s_InitialStyle.layoutData.Write().width = StyleKeyword.Auto.ToLength();
			s_InitialStyle.inheritedData.Write().wordSpacing = 0f;
		}
	}
	internal static class ShorthandApplicator
	{
		private static List<TimeValue> s_TransitionDelayList = new List<TimeValue>();

		private static List<TimeValue> s_TransitionDurationList = new List<TimeValue>();

		private static List<StylePropertyName> s_TransitionPropertyList = new List<StylePropertyName>();

		private static List<EasingFunction> s_TransitionTimingFunctionList = new List<EasingFunction>();

		public static void ApplyBackgroundPosition(StylePropertyReader reader, ref ComputedStyle computedStyle)
		{
			CompileBackgroundPosition(reader, out var backgroundPositionX, out var backgroundPositionY);
			computedStyle.visualData.Write().backgroundPositionX = backgroundPositionX;
			computedStyle.visualData.Write().backgroundPositionY = backgroundPositionY;
		}

		public static void ApplyBorderColor(StylePropertyReader reader, ref ComputedStyle computedStyle)
		{
			CompileBoxArea(reader, out Color top, out Color right, out Color bottom, out Color left);
			computedStyle.visualData.Write().borderTopColor = top;
			computedStyle.visualData.Write().borderRightColor = right;
			computedStyle.visualData.Write().borderBottomColor = bottom;
			computedStyle.visualData.Write().borderLeftColor = left;
		}

		public static void ApplyBorderRadius(StylePropertyReader reader, ref ComputedStyle computedStyle)
		{
			CompileBorderRadius(reader, out var top, out var right, out var bottom, out var left);
			computedStyle.visualData.Write().borderTopLeftRadius = top;
			computedStyle.visualData.Write().borderTopRightRadius = right;
			computedStyle.visualData.Write().borderBottomRightRadius = bottom;
			computedStyle.visualData.Write().borderBottomLeftRadius = left;
		}

		public static void ApplyBorderWidth(StylePropertyReader reader, ref ComputedStyle computedStyle)
		{
			CompileBoxArea(reader, out float top, out float right, out float bottom, out float left);
			computedStyle.layoutData.Write().borderTopWidth = top;
			computedStyle.layoutData.Write().borderRightWidth = right;
			computedStyle.layoutData.Write().borderBottomWidth = bottom;
			computedStyle.layoutData.Write().borderLeftWidth = left;
		}

		public static void ApplyFlex(StylePropertyReader reader, ref ComputedStyle computedStyle)
		{
			CompileFlexShorthand(reader, out var grow, out var shrink, out var basis);
			computedStyle.layoutData.Write().flexGrow = grow;
			computedStyle.layoutData.Write().flexShrink = shrink;
			computedStyle.layoutData.Write().flexBasis = basis;
		}

		public static void ApplyMargin(StylePropertyReader reader, ref ComputedStyle computedStyle)
		{
			CompileBoxArea(reader, out Length top, out Length right, out Length bottom, out Length left);
			computedStyle.layoutData.Write().marginTop = top;
			computedStyle.layoutData.Write().marginRight = right;
			computedStyle.layoutData.Write().marginBottom = bottom;
			computedStyle.layoutData.Write().marginLeft = left;
		}

		public static void ApplyPadding(StylePropertyReader reader, ref ComputedStyle computedStyle)
		{
			CompileBoxArea(reader, out Length top, out Length right, out Length bottom, out Length left);
			computedStyle.layoutData.Write().paddingTop = top;
			computedStyle.layoutData.Write().paddingRight = right;
			computedStyle.layoutData.Write().paddingBottom = bottom;
			computedStyle.layoutData.Write().paddingLeft = left;
		}

		public static void ApplyTransition(StylePropertyReader reader, ref ComputedStyle computedStyle)
		{
			CompileTransition(reader, out var outDelay, out var outDuration, out var outProperty, out var outTimingFunction);
			computedStyle.transitionData.Write().transitionDelay.CopyFrom(outDelay);
			computedStyle.transitionData.Write().transitionDuration.CopyFrom(outDuration);
			computedStyle.transitionData.Write().transitionProperty.CopyFrom(outProperty);
			computedStyle.transitionData.Write().transitionTimingFunction.CopyFrom(outTimingFunction);
		}

		public static void ApplyUnityBackgroundScaleMode(StylePropertyReader reader, ref ComputedStyle computedStyle)
		{
			CompileUnityBackgroundScaleMode(reader, out var backgroundPositionX, out var backgroundPositionY, out var backgroundRepeat, out var backgroundSize);
			computedStyle.visualData.Write().backgroundPositionX = backgroundPositionX;
			computedStyle.visualData.Write().backgroundPositionY = backgroundPositionY;
			computedStyle.visualData.Write().backgroundRepeat = backgroundRepeat;
			computedStyle.visualData.Write().backgroundSize = backgroundSize;
		}

		public static void ApplyUnityTextOutline(StylePropertyReader reader, ref ComputedStyle computedStyle)
		{
			CompileTextOutline(reader, out var outlineColor, out var outlineWidth);
			computedStyle.inheritedData.Write().unityTextOutlineColor = outlineColor;
			computedStyle.inheritedData.Write().unityTextOutlineWidth = outlineWidth;
		}

		private static bool CompileFlexShorthand(StylePropertyReader reader, out float grow, out float shrink, out Length basis)
		{
			grow = 0f;
			shrink = 1f;
			basis = Length.Auto();
			bool flag = false;
			int valueCount = reader.valueCount;
			if (valueCount == 1 && reader.IsValueType(0, StyleValueType.Keyword))
			{
				if (reader.IsKeyword(0, StyleValueKeyword.None))
				{
					flag = true;
					grow = 0f;
					shrink = 0f;
					basis = Length.Auto();
				}
				else if (reader.IsKeyword(0, StyleValueKeyword.Auto))
				{
					flag = true;
					grow = 1f;
					shrink = 1f;
					basis = Length.Auto();
				}
			}
			else if (valueCount <= 3)
			{
				flag = true;
				grow = 0f;
				shrink = 1f;
				basis = Length.Percent(0f);
				bool flag2 = false;
				bool flag3 = false;
				for (int i = 0; i < valueCount && flag; i++)
				{
					StyleValueType valueType = reader.GetValueType(i);
					if (valueType == StyleValueType.Dimension || valueType == StyleValueType.Keyword)
					{
						if (flag3)
						{
							flag = false;
							break;
						}
						flag3 = true;
						switch (valueType)
						{
						case StyleValueType.Keyword:
							if (reader.IsKeyword(i, StyleValueKeyword.Auto))
							{
								basis = Length.Auto();
							}
							break;
						case StyleValueType.Dimension:
							basis = reader.ReadLength(i);
							break;
						}
						if (flag2 && i != valueCount - 1)
						{
							flag = false;
						}
					}
					else if (valueType == StyleValueType.Float)
					{
						float num = reader.ReadFloat(i);
						if (!flag2)
						{
							flag2 = true;
							grow = num;
						}
						else
						{
							shrink = num;
						}
					}
					else
					{
						flag = false;
					}
				}
			}
			return flag;
		}

		private static void CompileBorderRadius(StylePropertyReader reader, out Length top, out Length right, out Length bottom, out Length left)
		{
			CompileBoxArea(reader, out top, out right, out bottom, out left);
			if (top.IsAuto() || top.IsNone())
			{
				top = 0f;
			}
			if (right.IsAuto() || right.IsNone())
			{
				right = 0f;
			}
			if (bottom.IsAuto() || bottom.IsNone())
			{
				bottom = 0f;
			}
			if (left.IsAuto() || left.IsNone())
			{
				left = 0f;
			}
		}

		private static void CompileBackgroundPosition(StylePropertyReader reader, out BackgroundPosition backgroundPositionX, out BackgroundPosition backgroundPositionY)
		{
			int valueCount = reader.valueCount;
			StylePropertyValue value = reader.GetValue(0);
			StylePropertyValue stylePropertyValue = ((valueCount > 1) ? reader.GetValue(1) : default(StylePropertyValue));
			StylePropertyValue stylePropertyValue2 = ((valueCount > 2) ? reader.GetValue(2) : default(StylePropertyValue));
			StylePropertyValue stylePropertyValue3 = ((valueCount > 3) ? reader.GetValue(3) : default(StylePropertyValue));
			backgroundPositionX = default(BackgroundPosition);
			backgroundPositionY = default(BackgroundPosition);
			switch (valueCount)
			{
			case 1:
				switch ((BackgroundPositionKeyword)reader.ReadEnum(StyleEnumType.BackgroundPositionKeyword, 0))
				{
				case BackgroundPositionKeyword.Left:
					backgroundPositionX = new BackgroundPosition(BackgroundPositionKeyword.Left);
					backgroundPositionY = BackgroundPosition.Initial();
					break;
				case BackgroundPositionKeyword.Right:
					backgroundPositionX = new BackgroundPosition(BackgroundPositionKeyword.Right);
					backgroundPositionY = BackgroundPosition.Initial();
					break;
				case BackgroundPositionKeyword.Top:
					backgroundPositionX = BackgroundPosition.Initial();
					backgroundPositionY = new BackgroundPosition(BackgroundPositionKeyword.Top);
					break;
				case BackgroundPositionKeyword.Bottom:
					backgroundPositionX = BackgroundPosition.Initial();
					backgroundPositionY = new BackgroundPosition(BackgroundPositionKeyword.Bottom);
					break;
				case BackgroundPositionKeyword.Center:
					backgroundPositionX = new BackgroundPosition(BackgroundPositionKeyword.Center);
					backgroundPositionY = new BackgroundPosition(BackgroundPositionKeyword.Center);
					break;
				}
				break;
			case 2:
				if ((value.handle.valueType == StyleValueType.Dimension || value.handle.valueType == StyleValueType.Float) && (value.handle.valueType == StyleValueType.Dimension || value.handle.valueType == StyleValueType.Float))
				{
					backgroundPositionX = new BackgroundPosition(BackgroundPositionKeyword.Left, value.sheet.ReadDimension(value.handle).ToLength());
					backgroundPositionY = new BackgroundPosition(BackgroundPositionKeyword.Top, stylePropertyValue.sheet.ReadDimension(stylePropertyValue.handle).ToLength());
				}
				else if (value.handle.valueType == StyleValueType.Enum && stylePropertyValue.handle.valueType == StyleValueType.Enum)
				{
					BackgroundPositionKeyword a = (BackgroundPositionKeyword)reader.ReadEnum(StyleEnumType.BackgroundPositionKeyword, 0);
					BackgroundPositionKeyword b = (BackgroundPositionKeyword)reader.ReadEnum(StyleEnumType.BackgroundPositionKeyword, 1);
					if (b == BackgroundPositionKeyword.Left)
					{
						SwapKeyword(ref a, ref b);
					}
					if (b == BackgroundPositionKeyword.Right)
					{
						SwapKeyword(ref a, ref b);
					}
					if (a == BackgroundPositionKeyword.Top)
					{
						SwapKeyword(ref a, ref b);
					}
					if (a == BackgroundPositionKeyword.Bottom)
					{
						SwapKeyword(ref a, ref b);
					}
					backgroundPositionX = new BackgroundPosition(a);
					backgroundPositionY = new BackgroundPosition(b);
				}
				break;
			case 3:
				if (value.handle.valueType == StyleValueType.Enum && stylePropertyValue.handle.valueType == StyleValueType.Enum && stylePropertyValue2.handle.valueType == StyleValueType.Dimension)
				{
					backgroundPositionX = new BackgroundPosition((BackgroundPositionKeyword)reader.ReadEnum(StyleEnumType.BackgroundPositionKeyword, 0));
					backgroundPositionY = new BackgroundPosition((BackgroundPositionKeyword)reader.ReadEnum(StyleEnumType.BackgroundPositionKeyword, 1), reader.ReadLength(2));
				}
				else if (value.handle.valueType == StyleValueType.Enum && stylePropertyValue.handle.valueType == StyleValueType.Dimension && stylePropertyValue2.handle.valueType == StyleValueType.Enum)
				{
					backgroundPositionX = new BackgroundPosition((BackgroundPositionKeyword)reader.ReadEnum(StyleEnumType.BackgroundPositionKeyword, 0), reader.ReadLength(1));
					backgroundPositionY = new BackgroundPosition((BackgroundPositionKeyword)reader.ReadEnum(StyleEnumType.BackgroundPositionKeyword, 2));
				}
				break;
			case 4:
				if (value.handle.valueType == StyleValueType.Enum && stylePropertyValue.handle.valueType == StyleValueType.Dimension && stylePropertyValue2.handle.valueType == StyleValueType.Enum && stylePropertyValue3.handle.valueType == StyleValueType.Dimension)
				{
					backgroundPositionX = new BackgroundPosition((BackgroundPositionKeyword)reader.ReadEnum(StyleEnumType.BackgroundPositionKeyword, 0), reader.ReadLength(1));
					backgroundPositionY = new BackgroundPosition((BackgroundPositionKeyword)reader.ReadEnum(StyleEnumType.BackgroundPositionKeyword, 2), reader.ReadLength(3));
				}
				break;
			}
			static void SwapKeyword(ref BackgroundPositionKeyword reference, ref BackgroundPositionKeyword reference2)
			{
				BackgroundPositionKeyword backgroundPositionKeyword = reference;
				reference = reference2;
				reference2 = backgroundPositionKeyword;
			}
		}

		public static void CompileUnityBackgroundScaleMode(StylePropertyReader reader, out BackgroundPosition backgroundPositionX, out BackgroundPosition backgroundPositionY, out BackgroundRepeat backgroundRepeat, out BackgroundSize backgroundSize)
		{
			ScaleMode scaleMode = (ScaleMode)reader.ReadEnum(StyleEnumType.ScaleMode, 0);
			backgroundPositionX = BackgroundPropertyHelper.ConvertScaleModeToBackgroundPosition(scaleMode);
			backgroundPositionY = BackgroundPropertyHelper.ConvertScaleModeToBackgroundPosition(scaleMode);
			backgroundRepeat = BackgroundPropertyHelper.ConvertScaleModeToBackgroundRepeat(scaleMode);
			backgroundSize = BackgroundPropertyHelper.ConvertScaleModeToBackgroundSize(scaleMode);
		}

		private static void CompileBoxArea(StylePropertyReader reader, out Length top, out Length right, out Length bottom, out Length left)
		{
			top = 0f;
			right = 0f;
			bottom = 0f;
			left = 0f;
			switch (reader.valueCount)
			{
			case 0:
				break;
			case 1:
				top = (right = (bottom = (left = reader.ReadLength(0))));
				break;
			case 2:
				top = (bottom = reader.ReadLength(0));
				left = (right = reader.ReadLength(1));
				break;
			case 3:
				top = reader.ReadLength(0);
				left = (right = reader.ReadLength(1));
				bottom = reader.ReadLength(2);
				break;
			default:
				top = reader.ReadLength(0);
				right = reader.ReadLength(1);
				bottom = reader.ReadLength(2);
				left = reader.ReadLength(3);
				break;
			}
		}

		private static void CompileBoxArea(StylePropertyReader reader, out float top, out float right, out float bottom, out float left)
		{
			CompileBoxArea(reader, out Length top2, out Length right2, out Length bottom2, out Length left2);
			top = top2.value;
			right = right2.value;
			bottom = bottom2.value;
			left = left2.value;
		}

		private static void CompileBoxArea(StylePropertyReader reader, out Color top, out Color right, out Color bottom, out Color left)
		{
			top = Color.clear;
			right = Color.clear;
			bottom = Color.clear;
			left = Color.clear;
			switch (reader.valueCount)
			{
			case 0:
				break;
			case 1:
				top = (right = (bottom = (left = reader.ReadColor(0))));
				break;
			case 2:
				top = (bottom = reader.ReadColor(0));
				left = (right = reader.ReadColor(1));
				break;
			case 3:
				top = reader.ReadColor(0);
				left = (right = reader.ReadColor(1));
				bottom = reader.ReadColor(2);
				break;
			default:
				top = reader.ReadColor(0);
				right = reader.ReadColor(1);
				bottom = reader.ReadColor(2);
				left = reader.ReadColor(3);
				break;
			}
		}

		private static void CompileTextOutline(StylePropertyReader reader, out Color outlineColor, out float outlineWidth)
		{
			outlineColor = Color.clear;
			outlineWidth = 0f;
			int valueCount = reader.valueCount;
			for (int i = 0; i < valueCount; i++)
			{
				StyleValueType valueType = reader.GetValueType(i);
				switch (valueType)
				{
				case StyleValueType.Dimension:
					outlineWidth = reader.ReadFloat(i);
					continue;
				default:
					if (valueType != StyleValueType.Color)
					{
						continue;
					}
					break;
				case StyleValueType.Enum:
					break;
				}
				outlineColor = reader.ReadColor(i);
			}
		}

		private static void CompileTransition(StylePropertyReader reader, out List<TimeValue> outDelay, out List<TimeValue> outDuration, out List<StylePropertyName> outProperty, out List<EasingFunction> outTimingFunction)
		{
			s_TransitionDelayList.Clear();
			s_TransitionDurationList.Clear();
			s_TransitionPropertyList.Clear();
			s_TransitionTimingFunctionList.Clear();
			bool flag = true;
			bool flag2 = false;
			int valueCount = reader.valueCount;
			int num = 0;
			int i = 0;
			do
			{
				if (flag2)
				{
					flag = false;
					break;
				}
				StylePropertyName item = InitialStyle.transitionProperty[0];
				TimeValue item2 = InitialStyle.transitionDuration[0];
				TimeValue item3 = InitialStyle.transitionDelay[0];
				EasingFunction item4 = InitialStyle.transitionTimingFunction[0];
				bool flag3 = false;
				bool flag4 = false;
				bool flag5 = false;
				bool flag6 = false;
				bool flag7 = false;
				for (; i < valueCount; i++)
				{
					if (flag7)
					{
						break;
					}
					switch (reader.GetValueType(i))
					{
					case StyleValueType.Keyword:
						if (reader.IsKeyword(i, StyleValueKeyword.None) && num == 0)
						{
							flag2 = true;
							flag5 = true;
							item = new StylePropertyName("none");
						}
						else
						{
							flag = false;
						}
						break;
					case StyleValueType.Dimension:
					{
						TimeValue timeValue = reader.ReadTimeValue(i);
						if (!flag3)
						{
							flag3 = true;
							item2 = timeValue;
						}
						else if (!flag4)
						{
							flag4 = true;
							item3 = timeValue;
						}
						else
						{
							flag = false;
						}
						break;
					}
					case StyleValueType.Enum:
					{
						string text = reader.ReadAsString(i);
						if (!flag6 && StylePropertyUtil.TryGetEnumIntValue(StyleEnumType.EasingMode, text, out var intValue))
						{
							flag6 = true;
							item4 = (EasingMode)intValue;
						}
						else if (!flag5)
						{
							flag5 = true;
							item = new StylePropertyName(text);
						}
						else
						{
							flag = false;
						}
						break;
					}
					case StyleValueType.CommaSeparator:
						flag7 = true;
						num++;
						break;
					default:
						flag = false;
						break;
					}
				}
				s_TransitionDelayList.Add(item3);
				s_TransitionDurationList.Add(item2);
				s_TransitionPropertyList.Add(item);
				s_TransitionTimingFunctionList.Add(item4);
			}
			while (i < valueCount && flag);
			if (flag)
			{
				outProperty = s_TransitionPropertyList;
				outDelay = s_TransitionDelayList;
				outDuration = s_TransitionDurationList;
				outTimingFunction = s_TransitionTimingFunctionList;
			}
			else
			{
				outProperty = InitialStyle.transitionProperty;
				outDelay = InitialStyle.transitionDelay;
				outDuration = InitialStyle.transitionDuration;
				outTimingFunction = InitialStyle.transitionTimingFunction;
			}
		}
	}
	internal static class StylePropertyCache
	{
		internal static readonly Dictionary<string, string> s_PropertySyntaxCache = new Dictionary<string, string>
		{
			{ "align-content", "flex-start | flex-end | center | stretch | auto" },
			{ "align-items", "flex-start | flex-end | center | stretch | auto" },
			{ "align-self", "flex-start | flex-end | center | stretch | auto" },
			{ "all", "initial" },
			{ "background-color", "<color>" },
			{ "background-image", "<resource> | <url> | none" },
			{ "background-position", "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]" },
			{ "background-position-x", "[ center | [ [ left | right ]? <length-percentage>? ] ]" },
			{ "background-position-y", "[ center | [ [ top | bottom ]? <length-percentage>? ] ]" },
			{ "background-repeat", "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}" },
			{ "background-size", "[ <length-percentage> | auto ]{1,2} | cover | contain" },
			{ "border-bottom-color", "<color>" },
			{ "border-bottom-left-radius", "<length-percentage>" },
			{ "border-bottom-right-radius", "<length-percentage>" },
			{ "border-bottom-width", "<length>" },
			{ "border-color", "<color>{1,4}" },
			{ "border-left-color", "<color>" },
			{ "border-left-width", "<length>" },
			{ "border-radius", "[ <length-percentage> ]{1,4}" },
			{ "border-right-color", "<color>" },
			{ "border-right-width", "<length>" },
			{ "border-top-color", "<color>" },
			{ "border-top-left-radius", "<length-percentage>" },
			{ "border-top-right-radius", "<length-percentage>" },
			{ "border-top-width", "<length>" },
			{ "border-width", "<length>{1,4}" },
			{ "bottom", "<length-percentage> | auto" },
			{ "color", "<color>" },
			{ "cursor", "[ [ <resource> | <url> ] [ <integer> <integer> ]? ] | [ arrow | text | resize-vertical | resize-horizontal | link | slide-arrow | resize-up-right | resize-up-left | move-arrow | rotate-arrow | scale-arrow | arrow-plus | arrow-minus | pan | orbit | zoom | fps | split-resize-up-down | split-resize-left-right ]" },
			{ "display", "flex | none" },
			{ "flex", "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]" },
			{ "flex-basis", "<'width'>" },
			{ "flex-direction", "column | row | column-reverse | row-reverse" },
			{ "flex-grow", "<number>" },
			{ "flex-shrink", "<number>" },
			{ "flex-wrap", "nowrap | wrap | wrap-reverse" },
			{ "font-size", "<length-percentage>" },
			{ "height", "<length-percentage> | auto" },
			{ "justify-content", "flex-start | flex-end | center | space-between | space-around" },
			{ "left", "<length-percentage> | auto" },
			{ "letter-spacing", "<length>" },
			{ "margin", "[ <length-percentage> | auto ]{1,4}" },
			{ "margin-bottom", "<length-percentage> | auto" },
			{ "margin-left", "<length-percentage> | auto" },
			{ "margin-right", "<length-percentage> | auto" },
			{ "margin-top", "<length-percentage> | auto" },
			{ "max-height", "<length-percentage> | none" },
			{ "max-width", "<length-percentage> | none" },
			{ "min-height", "<length-percentage> | auto" },
			{ "min-width", "<length-percentage> | auto" },
			{ "opacity", "<number>" },
			{ "overflow", "visible | hidden | scroll" },
			{ "padding", "[ <length-percentage> ]{1,4}" },
			{ "padding-bottom", "<length-percentage>" },
			{ "padding-left", "<length-percentage>" },
			{ "padding-right", "<length-percentage>" },
			{ "padding-top", "<length-percentage>" },
			{ "position", "relative | absolute" },
			{ "right", "<length-percentage> | auto" },
			{ "rotate", "none | <angle>" },
			{ "scale", "none | <number>{1,3}" },
			{ "text-overflow", "clip | ellipsis" },
			{ "text-shadow", "<length>{2,3} && <color>?" },
			{ "top", "<length-percentage> | auto" },
			{ "transform-origin", "[ <length> | <percentage> | left | center | right | top | bottom ] | [ [ <length> | <percentage>  | left | center | right ] && [ <length> | <percentage>  | top | center | bottom ] ] <length>?" },
			{ "transition", "<single-transition>#" },
			{ "transition-delay", "<time>#" },
			{ "transition-duration", "<time>#" },
			{ "transition-property", "none | <single-transition-property>#" },
			{ "transition-timing-function", "<easing-function>#" },
			{ "translate", "none | [<length> | <percentage>] [ [<length> | <percentage>] <length>? ]?" },
			{ "-unity-background-image-tint-color", "<color>" },
			{ "-unity-background-scale-mode", "stretch-to-fill | scale-and-crop | scale-to-fit" },
			{ "-unity-font", "<resource> | <url>" },
			{ "-unity-font-definition", "<resource> | <url>" },
			{ "-unity-font-style", "normal | italic | bold | bold-and-italic" },
			{ "-unity-overflow-clip-box", "padding-box | content-box" },
			{ "-unity-paragraph-spacing", "<length>" },
			{ "-unity-slice-bottom", "<integer>" },
			{ "-unity-slice-left", "<integer>" },
			{ "-unity-slice-right", "<integer>" },
			{ "-unity-slice-scale", "<length>" },
			{ "-unity-slice-top", "<integer>" },
			{ "-unity-text-align", "upper-left | middle-left | lower-left | upper-center | middle-center | lower-center | upper-right | middle-right | lower-right" },
			{ "-unity-text-outline", "<length> || <color>" },
			{ "-unity-text-outline-color", "<color>" },
			{ "-unity-text-outline-width", "<length>" },
			{ "-unity-text-overflow-position", "start | middle | end" },
			{ "visibility", "visible | hidden" },
			{ "white-space", "normal | nowrap" },
			{ "width", "<length-percentage> | auto" },
			{ "word-spacing", "<length>" }
		};

		internal static readonly Dictionary<string, string> s_NonTerminalValues = new Dictionary<string, string>
		{
			{ "easing-function", "linear | <timing-function>" },
			{ "length-percentage", "<length> | <percentage>" },
			{ "single-transition", "[ none | <single-transition-property> ] || <time> || <easing-function> || <time>" },
			{ "single-transition-property", "all | <custom-ident>" },
			{ "timing-function", "ease | ease-in | ease-out | ease-in-out | ease-in-sine | ease-out-sine | ease-in-out-sine | ease-in-cubic | ease-out-cubic | ease-in-out-cubic | ease-in-circ | ease-out-circ | ease-in-out-circ | ease-in-elastic | ease-out-elastic | ease-in-out-elastic | ease-in-back | ease-out-back | ease-in-out-back | ease-in-bounce | ease-out-bounce | ease-in-out-bounce" }
		};

		public static bool TryGetSyntax(string name, out string syntax)
		{
			return s_PropertySyntaxCache.TryGetValue(name, out syntax);
		}

		public static bool TryGetNonTerminalValue(string name, out string syntax)
		{
			return s_NonTerminalValues.TryGetValue(name, out syntax);
		}

		public static string FindClosestPropertyName(string name)
		{
			float num = float.MaxValue;
			string result = null;
			foreach (string key in s_PropertySyntaxCache.Keys)
			{
				float num2 = 1f;
				if (key.Contains(name))
				{
					num2 = 0.1f;
				}
				float num3 = (float)StringUtils.LevenshteinDistance(name, key) * num2;
				if (num3 < num)
				{
					num = num3;
					result = key;
				}
			}
			return result;
		}
	}
	internal enum StylePropertyGroup
	{
		Inherited = 1,
		Layout,
		Rare,
		Shorthand,
		Transform,
		Transition,
		Visual
	}
	internal enum StyleEnumType
	{
		Align,
		BackgroundPositionKeyword,
		BackgroundSizeType,
		DisplayStyle,
		EasingMode,
		FlexDirection,
		FontStyle,
		Justify,
		Overflow,
		OverflowClipBox,
		OverflowInternal,
		Position,
		Repeat,
		RepeatXY,
		ScaleMode,
		TextAnchor,
		TextOverflow,
		TextOverflowPosition,
		TransformOriginOffset,
		Visibility,
		WhiteSpace,
		Wrap
	}
	internal enum StylePropertyId
	{
		Unknown = 0,
		Custom = -1,
		AlignContent = 131072,
		AlignItems = 131073,
		AlignSelf = 131074,
		All = 262144,
		BackgroundColor = 458752,
		BackgroundImage = 458753,
		BackgroundPosition = 262145,
		BackgroundPositionX = 458754,
		BackgroundPositionY = 458755,
		BackgroundRepeat = 458756,
		BackgroundSize = 458757,
		BorderBottomColor = 458758,
		BorderBottomLeftRadius = 458759,
		BorderBottomRightRadius = 458760,
		BorderBottomWidth = 131075,
		BorderColor = 262146,
		BorderLeftColor = 458761,
		BorderLeftWidth = 131076,
		BorderRadius = 262147,
		BorderRightColor = 458762,
		BorderRightWidth = 131077,
		BorderTopColor = 458763,
		BorderTopLeftRadius = 458764,
		BorderTopRightRadius = 458765,
		BorderTopWidth = 131078,
		BorderWidth = 262148,
		Bottom = 131079,
		Color = 65536,
		Cursor = 196608,
		Display = 131080,
		Flex = 262149,
		FlexBasis = 131081,
		FlexDirection = 131082,
		FlexGrow = 131083,
		FlexShrink = 131084,
		FlexWrap = 131085,
		FontSize = 65537,
		Height = 131086,
		JustifyContent = 131087,
		Left = 131088,
		LetterSpacing = 65538,
		Margin = 262150,
		MarginBottom = 131089,
		MarginLeft = 131090,
		MarginRight = 131091,
		MarginTop = 131092,
		MaxHeight = 131093,
		MaxWidth = 131094,
		MinHeight = 131095,
		MinWidth = 131096,
		Opacity = 458766,
		Overflow = 458767,
		Padding = 262151,
		PaddingBottom = 131097,
		PaddingLeft = 131098,
		PaddingRight = 131099,
		PaddingTop = 131100,
		Position = 131101,
		Right = 131102,
		Rotate = 327680,
		Scale = 327681,
		TextOverflow = 196609,
		TextShadow = 65539,
		Top = 131103,
		TransformOrigin = 327682,
		Transition = 262152,
		TransitionDelay = 393216,
		TransitionDuration = 393217,
		TransitionProperty = 393218,
		TransitionTimingFunction = 393219,
		Translate = 327683,
		UnityBackgroundImageTintColor = 196610,
		UnityBackgroundScaleMode = 262153,
		UnityFont = 65540,
		UnityFontDefinition = 65541,
		UnityFontStyleAndWeight = 65542,
		UnityOverflowClipBox = 196611,
		UnityParagraphSpacing = 65543,
		UnitySliceBottom = 196612,
		UnitySliceLeft = 196613,
		UnitySliceRight = 196614,
		UnitySliceScale = 196615,
		UnitySliceTop = 196616,
		UnityTextAlign = 65544,
		UnityTextOutline = 262154,
		UnityTextOutlineColor = 65545,
		UnityTextOutlineWidth = 65546,
		UnityTextOverflowPosition = 196617,
		Visibility = 65547,
		WhiteSpace = 65548,
		Width = 131104,
		WordSpacing = 65549
	}
	internal static class StylePropertyUtil
	{
		public const int k_GroupOffset = 16;

		internal static readonly Dictionary<string, StylePropertyId> s_NameToId = new Dictionary<string, StylePropertyId>
		{
			{
				"align-content",
				StylePropertyId.AlignContent
			},
			{
				"align-items",
				StylePropertyId.AlignItems
			},
			{
				"align-self",
				StylePropertyId.AlignSelf
			},
			{
				"all",
				StylePropertyId.All
			},
			{
				"background-color",
				StylePropertyId.BackgroundColor
			},
			{
				"background-image",
				StylePropertyId.BackgroundImage
			},
			{
				"background-position",
				StylePropertyId.BackgroundPosition
			},
			{
				"background-position-x",
				StylePropertyId.BackgroundPositionX
			},
			{
				"background-position-y",
				StylePropertyId.BackgroundPositionY
			},
			{
				"background-repeat",
				StylePropertyId.BackgroundRepeat
			},
			{
				"background-size",
				StylePropertyId.BackgroundSize
			},
			{
				"border-bottom-color",
				StylePropertyId.BorderBottomColor
			},
			{
				"border-bottom-left-radius",
				StylePropertyId.BorderBottomLeftRadius
			},
			{
				"border-bottom-right-radius",
				StylePropertyId.BorderBottomRightRadius
			},
			{
				"border-bottom-width",
				StylePropertyId.BorderBottomWidth
			},
			{
				"border-color",
				StylePropertyId.BorderColor
			},
			{
				"border-left-color",
				StylePropertyId.BorderLeftColor
			},
			{
				"border-left-width",
				StylePropertyId.BorderLeftWidth
			},
			{
				"border-radius",
				StylePropertyId.BorderRadius
			},
			{
				"border-right-color",
				StylePropertyId.BorderRightColor
			},
			{
				"border-right-width",
				StylePropertyId.BorderRightWidth
			},
			{
				"border-top-color",
				StylePropertyId.BorderTopColor
			},
			{
				"border-top-left-radius",
				StylePropertyId.BorderTopLeftRadius
			},
			{
				"border-top-right-radius",
				StylePropertyId.BorderTopRightRadius
			},
			{
				"border-top-width",
				StylePropertyId.BorderTopWidth
			},
			{
				"border-width",
				StylePropertyId.BorderWidth
			},
			{
				"bottom",
				StylePropertyId.Bottom
			},
			{
				"color",
				StylePropertyId.Color
			},
			{
				"cursor",
				StylePropertyId.Cursor
			},
			{
				"display",
				StylePropertyId.Display
			},
			{
				"flex",
				StylePropertyId.Flex
			},
			{
				"flex-basis",
				StylePropertyId.FlexBasis
			},
			{
				"flex-direction",
				StylePropertyId.FlexDirection
			},
			{
				"flex-grow",
				StylePropertyId.FlexGrow
			},
			{
				"flex-shrink",
				StylePropertyId.FlexShrink
			},
			{
				"flex-wrap",
				StylePropertyId.FlexWrap
			},
			{
				"font-size",
				StylePropertyId.FontSize
			},
			{
				"height",
				StylePropertyId.Height
			},
			{
				"justify-content",
				StylePropertyId.JustifyContent
			},
			{
				"left",
				StylePropertyId.Left
			},
			{
				"letter-spacing",
				StylePropertyId.LetterSpacing
			},
			{
				"margin",
				StylePropertyId.Margin
			},
			{
				"margin-bottom",
				StylePropertyId.MarginBottom
			},
			{
				"margin-left",
				StylePropertyId.MarginLeft
			},
			{
				"margin-right",
				StylePropertyId.MarginRight
			},
			{
				"margin-top",
				StylePropertyId.MarginTop
			},
			{
				"max-height",
				StylePropertyId.MaxHeight
			},
			{
				"max-width",
				StylePropertyId.MaxWidth
			},
			{
				"min-height",
				StylePropertyId.MinHeight
			},
			{
				"min-width",
				StylePropertyId.MinWidth
			},
			{
				"opacity",
				StylePropertyId.Opacity
			},
			{
				"overflow",
				StylePropertyId.Overflow
			},
			{
				"padding",
				StylePropertyId.Padding
			},
			{
				"padding-bottom",
				StylePropertyId.PaddingBottom
			},
			{
				"padding-left",
				StylePropertyId.PaddingLeft
			},
			{
				"padding-right",
				StylePropertyId.PaddingRight
			},
			{
				"padding-top",
				StylePropertyId.PaddingTop
			},
			{
				"position",
				StylePropertyId.Position
			},
			{
				"right",
				StylePropertyId.Right
			},
			{
				"rotate",
				StylePropertyId.Rotate
			},
			{
				"scale",
				StylePropertyId.Scale
			},
			{
				"text-overflow",
				StylePropertyId.TextOverflow
			},
			{
				"text-shadow",
				StylePropertyId.TextShadow
			},
			{
				"top",
				StylePropertyId.Top
			},
			{
				"transform-origin",
				StylePropertyId.TransformOrigin
			},
			{
				"transition",
				StylePropertyId.Transition
			},
			{
				"transition-delay",
				StylePropertyId.TransitionDelay
			},
			{
				"transition-duration",
				StylePropertyId.TransitionDuration
			},
			{
				"transition-property",
				StylePropertyId.TransitionProperty
			},
			{
				"transition-timing-function",
				StylePropertyId.TransitionTimingFunction
			},
			{
				"translate",
				StylePropertyId.Translate
			},
			{
				"-unity-background-image-tint-color",
				StylePropertyId.UnityBackgroundImageTintColor
			},
			{
				"-unity-background-scale-mode",
				StylePropertyId.UnityBackgroundScaleMode
			},
			{
				"-unity-font",
				StylePropertyId.UnityFont
			},
			{
				"-unity-font-definition",
				StylePropertyId.UnityFontDefinition
			},
			{
				"-unity-font-style",
				StylePropertyId.UnityFontStyleAndWeight
			},
			{
				"-unity-overflow-clip-box",
				StylePropertyId.UnityOverflowClipBox
			},
			{
				"-unity-paragraph-spacing",
				StylePropertyId.UnityParagraphSpacing
			},
			{
				"-unity-slice-bottom",
				StylePropertyId.UnitySliceBottom
			},
			{
				"-unity-slice-left",
				StylePropertyId.UnitySliceLeft
			},
			{
				"-unity-slice-right",
				StylePropertyId.UnitySliceRight
			},
			{
				"-unity-slice-scale",
				StylePropertyId.UnitySliceScale
			},
			{
				"-unity-slice-top",
				StylePropertyId.UnitySliceTop
			},
			{
				"-unity-text-align",
				StylePropertyId.UnityTextAlign
			},
			{
				"-unity-text-outline",
				StylePropertyId.UnityTextOutline
			},
			{
				"-unity-text-outline-color",
				StylePropertyId.UnityTextOutlineColor
			},
			{
				"-unity-text-outline-width",
				StylePropertyId.UnityTextOutlineWidth
			},
			{
				"-unity-text-overflow-position",
				StylePropertyId.UnityTextOverflowPosition
			},
			{
				"visibility",
				StylePropertyId.Visibility
			},
			{
				"white-space",
				StylePropertyId.WhiteSpace
			},
			{
				"width",
				StylePropertyId.Width
			},
			{
				"word-spacing",
				StylePropertyId.WordSpacing
			}
		};

		internal static readonly Dictionary<StylePropertyId, string> s_IdToName = new Dictionary<StylePropertyId, string>
		{
			{
				StylePropertyId.AlignContent,
				"align-content"
			},
			{
				StylePropertyId.AlignItems,
				"align-items"
			},
			{
				StylePropertyId.AlignSelf,
				"align-self"
			},
			{
				StylePropertyId.All,
				"all"
			},
			{
				StylePropertyId.BackgroundColor,
				"background-color"
			},
			{
				StylePropertyId.BackgroundImage,
				"background-image"
			},
			{
				StylePropertyId.BackgroundPosition,
				"background-position"
			},
			{
				StylePropertyId.BackgroundPositionX,
				"background-position-x"
			},
			{
				StylePropertyId.BackgroundPositionY,
				"background-position-y"
			},
			{
				StylePropertyId.BackgroundRepeat,
				"background-repeat"
			},
			{
				StylePropertyId.BackgroundSize,
				"background-size"
			},
			{
				StylePropertyId.BorderBottomColor,
				"border-bottom-color"
			},
			{
				StylePropertyId.BorderBottomLeftRadius,
				"border-bottom-left-radius"
			},
			{
				StylePropertyId.BorderBottomRightRadius,
				"border-bottom-right-radius"
			},
			{
				StylePropertyId.BorderBottomWidth,
				"border-bottom-width"
			},
			{
				StylePropertyId.BorderColor,
				"border-color"
			},
			{
				StylePropertyId.BorderLeftColor,
				"border-left-color"
			},
			{
				StylePropertyId.BorderLeftWidth,
				"border-left-width"
			},
			{
				StylePropertyId.BorderRadius,
				"border-radius"
			},
			{
				StylePropertyId.BorderRightColor,
				"border-right-color"
			},
			{
				StylePropertyId.BorderRightWidth,
				"border-right-width"
			},
			{
				StylePropertyId.BorderTopColor,
				"border-top-color"
			},
			{
				StylePropertyId.BorderTopLeftRadius,
				"border-top-left-radius"
			},
			{
				StylePropertyId.BorderTopRightRadius,
				"border-top-right-radius"
			},
			{
				StylePropertyId.BorderTopWidth,
				"border-top-width"
			},
			{
				StylePropertyId.BorderWidth,
				"border-width"
			},
			{
				StylePropertyId.Bottom,
				"bottom"
			},
			{
				StylePropertyId.Color,
				"color"
			},
			{
				StylePropertyId.Cursor,
				"cursor"
			},
			{
				StylePropertyId.Display,
				"display"
			},
			{
				StylePropertyId.Flex,
				"flex"
			},
			{
				StylePropertyId.FlexBasis,
				"flex-basis"
			},
			{
				StylePropertyId.FlexDirection,
				"flex-direction"
			},
			{
				StylePropertyId.FlexGrow,
				"flex-grow"
			},
			{
				StylePropertyId.FlexShrink,
				"flex-shrink"
			},
			{
				StylePropertyId.FlexWrap,
				"flex-wrap"
			},
			{
				StylePropertyId.FontSize,
				"font-size"
			},
			{
				StylePropertyId.Height,
				"height"
			},
			{
				StylePropertyId.JustifyContent,
				"justify-content"
			},
			{
				StylePropertyId.Left,
				"left"
			},
			{
				StylePropertyId.LetterSpacing,
				"letter-spacing"
			},
			{
				StylePropertyId.Margin,
				"margin"
			},
			{
				StylePropertyId.MarginBottom,
				"margin-bottom"
			},
			{
				StylePropertyId.MarginLeft,
				"margin-left"
			},
			{
				StylePropertyId.MarginRight,
				"margin-right"
			},
			{
				StylePropertyId.MarginTop,
				"margin-top"
			},
			{
				StylePropertyId.MaxHeight,
				"max-height"
			},
			{
				StylePropertyId.MaxWidth,
				"max-width"
			},
			{
				StylePropertyId.MinHeight,
				"min-height"
			},
			{
				StylePropertyId.MinWidth,
				"min-width"
			},
			{
				StylePropertyId.Opacity,
				"opacity"
			},
			{
				StylePropertyId.Overflow,
				"overflow"
			},
			{
				StylePropertyId.Padding,
				"padding"
			},
			{
				StylePropertyId.PaddingBottom,
				"padding-bottom"
			},
			{
				StylePropertyId.PaddingLeft,
				"padding-left"
			},
			{
				StylePropertyId.PaddingRight,
				"padding-right"
			},
			{
				StylePropertyId.PaddingTop,
				"padding-top"
			},
			{
				StylePropertyId.Position,
				"position"
			},
			{
				StylePropertyId.Right,
				"right"
			},
			{
				StylePropertyId.Rotate,
				"rotate"
			},
			{
				StylePropertyId.Scale,
				"scale"
			},
			{
				StylePropertyId.TextOverflow,
				"text-overflow"
			},
			{
				StylePropertyId.TextShadow,
				"text-shadow"
			},
			{
				StylePropertyId.Top,
				"top"
			},
			{
				StylePropertyId.TransformOrigin,
				"transform-origin"
			},
			{
				StylePropertyId.Transition,
				"transition"
			},
			{
				StylePropertyId.TransitionDelay,
				"transition-delay"
			},
			{
				StylePropertyId.TransitionDuration,
				"transition-duration"
			},
			{
				StylePropertyId.TransitionProperty,
				"transition-property"
			},
			{
				StylePropertyId.TransitionTimingFunction,
				"transition-timing-function"
			},
			{
				StylePropertyId.Translate,
				"translate"
			},
			{
				StylePropertyId.UnityBackgroundImageTintColor,
				"-unity-background-image-tint-color"
			},
			{
				StylePropertyId.UnityBackgroundScaleMode,
				"-unity-background-scale-mode"
			},
			{
				StylePropertyId.UnityFont,
				"-unity-font"
			},
			{
				StylePropertyId.UnityFontDefinition,
				"-unity-font-definition"
			},
			{
				StylePropertyId.UnityFontStyleAndWeight,
				"-unity-font-style"
			},
			{
				StylePropertyId.UnityOverflowClipBox,
				"-unity-overflow-clip-box"
			},
			{
				StylePropertyId.UnityParagraphSpacing,
				"-unity-paragraph-spacing"
			},
			{
				StylePropertyId.UnitySliceBottom,
				"-unity-slice-bottom"
			},
			{
				StylePropertyId.UnitySliceLeft,
				"-unity-slice-left"
			},
			{
				StylePropertyId.UnitySliceRight,
				"-unity-slice-right"
			},
			{
				StylePropertyId.UnitySliceScale,
				"-unity-slice-scale"
			},
			{
				StylePropertyId.UnitySliceTop,
				"-unity-slice-top"
			},
			{
				StylePropertyId.UnityTextAlign,
				"-unity-text-align"
			},
			{
				StylePropertyId.UnityTextOutline,
				"-unity-text-outline"
			},
			{
				StylePropertyId.UnityTextOutlineColor,
				"-unity-text-outline-color"
			},
			{
				StylePropertyId.UnityTextOutlineWidth,
				"-unity-text-outline-width"
			},
			{
				StylePropertyId.UnityTextOverflowPosition,
				"-unity-text-overflow-position"
			},
			{
				StylePropertyId.Visibility,
				"visibility"
			},
			{
				StylePropertyId.WhiteSpace,
				"white-space"
			},
			{
				StylePropertyId.Width,
				"width"
			},
			{
				StylePropertyId.WordSpacing,
				"word-spacing"
			}
		};

		internal static readonly HashSet<StylePropertyId> s_AnimatableProperties = new HashSet<StylePropertyId>
		{
			StylePropertyId.AlignContent,
			StylePropertyId.AlignItems,
			StylePropertyId.AlignSelf,
			StylePropertyId.All,
			StylePropertyId.BackgroundColor,
			StylePropertyId.BackgroundImage,
			StylePropertyId.BackgroundPosition,
			StylePropertyId.BackgroundPositionX,
			StylePropertyId.BackgroundPositionY,
			StylePropertyId.BackgroundRepeat,
			StylePropertyId.BackgroundSize,
			StylePropertyId.BorderBottomColor,
			StylePropertyId.BorderBottomLeftRadius,
			StylePropertyId.BorderBottomRightRadius,
			StylePropertyId.BorderBottomWidth,
			StylePropertyId.BorderColor,
			StylePropertyId.BorderLeftColor,
			StylePropertyId.BorderLeftWidth,
			StylePropertyId.BorderRadius,
			StylePropertyId.BorderRightColor,
			StylePropertyId.BorderRightWidth,
			StylePropertyId.BorderTopColor,
			StylePropertyId.BorderTopLeftRadius,
			StylePropertyId.BorderTopRightRadius,
			StylePropertyId.BorderTopWidth,
			StylePropertyId.BorderWidth,
			StylePropertyId.Bottom,
			StylePropertyId.Color,
			StylePropertyId.Display,
			StylePropertyId.Flex,
			StylePropertyId.FlexBasis,
			StylePropertyId.FlexDirection,
			StylePropertyId.FlexGrow,
			StylePropertyId.FlexShrink,
			StylePropertyId.FlexWrap,
			StylePropertyId.FontSize,
			StylePropertyId.Height,
			StylePropertyId.JustifyContent,
			StylePropertyId.Left,
			StylePropertyId.LetterSpacing,
			StylePropertyId.Margin,
			StylePropertyId.MarginBottom,
			StylePropertyId.MarginLeft,
			StylePropertyId.MarginRight,
			StylePropertyId.MarginTop,
			StylePropertyId.MaxHeight,
			StylePropertyId.MaxWidth,
			StylePropertyId.MinHeight,
			StylePropertyId.MinWidth,
			StylePropertyId.Opacity,
			StylePropertyId.Overflow,
			StylePropertyId.Padding,
			StylePropertyId.PaddingBottom,
			StylePropertyId.PaddingLeft,
			StylePropertyId.PaddingRight,
			StylePropertyId.PaddingTop,
			StylePropertyId.Position,
			StylePropertyId.Right,
			StylePropertyId.Rotate,
			StylePropertyId.Scale,
			StylePropertyId.TextOverflow,
			StylePropertyId.TextShadow,
			StylePropertyId.Top,
			StylePropertyId.TransformOrigin,
			StylePropertyId.Translate,
			StylePropertyId.UnityBackgroundImageTintColor,
			StylePropertyId.UnityBackgroundScaleMode,
			StylePropertyId.UnityFont,
			StylePropertyId.UnityFontDefinition,
			StylePropertyId.UnityFontStyleAndWeight,
			StylePropertyId.UnityOverflowClipBox,
			StylePropertyId.UnityParagraphSpacing,
			StylePropertyId.UnitySliceBottom,
			StylePropertyId.UnitySliceLeft,
			StylePropertyId.UnitySliceRight,
			StylePropertyId.UnitySliceScale,
			StylePropertyId.UnitySliceTop,
			StylePropertyId.UnityTextAlign,
			StylePropertyId.UnityTextOutline,
			StylePropertyId.UnityTextOutlineColor,
			StylePropertyId.UnityTextOutlineWidth,
			StylePropertyId.UnityTextOverflowPosition,
			StylePropertyId.Visibility,
			StylePropertyId.WhiteSpace,
			StylePropertyId.Width,
			StylePropertyId.WordSpacing
		};

		internal static readonly Dictionary<StylePropertyId, UsageHints> s_AnimatableWithUsageHintProperties = new Dictionary<StylePropertyId, UsageHints>
		{
			{
				StylePropertyId.BackgroundColor,
				UsageHints.DynamicColor
			},
			{
				StylePropertyId.BorderBottomColor,
				UsageHints.DynamicColor
			},
			{
				StylePropertyId.BorderColor,
				UsageHints.DynamicColor
			},
			{
				StylePropertyId.BorderLeftColor,
				UsageHints.DynamicColor
			},
			{
				StylePropertyId.BorderRightColor,
				UsageHints.DynamicColor
			},
			{
				StylePropertyId.BorderTopColor,
				UsageHints.DynamicColor
			},
			{
				StylePropertyId.Color,
				UsageHints.DynamicColor
			},
			{
				StylePropertyId.Rotate,
				UsageHints.DynamicTransform
			},
			{
				StylePropertyId.Scale,
				UsageHints.DynamicTransform
			},
			{
				StylePropertyId.TransformOrigin,
				UsageHints.DynamicTransform
			},
			{
				StylePropertyId.Translate,
				UsageHints.DynamicTransform
			},
			{
				StylePropertyId.UnityBackgroundImageTintColor,
				UsageHints.DynamicColor
			}
		};

		public static bool TryGetEnumIntValue(StyleEnumType enumType, string value, out int intValue)
		{
			intValue = 0;
			switch (enumType)
			{
			case StyleEnumType.Align:
				if (string.Equals(value, "auto", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "flex-start", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				if (string.Equals(value, "center", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 2;
					return true;
				}
				if (string.Equals(value, "flex-end", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 3;
					return true;
				}
				if (string.Equals(value, "stretch", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 4;
					return true;
				}
				break;
			case StyleEnumType.BackgroundPositionKeyword:
				if (string.Equals(value, "center", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "top", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				if (string.Equals(value, "bottom", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 2;
					return true;
				}
				if (string.Equals(value, "left", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 3;
					return true;
				}
				if (string.Equals(value, "right", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 4;
					return true;
				}
				break;
			case StyleEnumType.BackgroundSizeType:
				if (string.Equals(value, "cover", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				if (string.Equals(value, "contain", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 2;
					return true;
				}
				break;
			case StyleEnumType.DisplayStyle:
				if (string.Equals(value, "flex", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "none", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				break;
			case StyleEnumType.EasingMode:
				if (string.Equals(value, "ease", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "ease-in", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				if (string.Equals(value, "ease-out", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 2;
					return true;
				}
				if (string.Equals(value, "ease-in-out", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 3;
					return true;
				}
				if (string.Equals(value, "linear", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 4;
					return true;
				}
				if (string.Equals(value, "ease-in-sine", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 5;
					return true;
				}
				if (string.Equals(value, "ease-out-sine", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 6;
					return true;
				}
				if (string.Equals(value, "ease-in-out-sine", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 7;
					return true;
				}
				if (string.Equals(value, "ease-in-cubic", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 8;
					return true;
				}
				if (string.Equals(value, "ease-out-cubic", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 9;
					return true;
				}
				if (string.Equals(value, "ease-in-out-cubic", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 10;
					return true;
				}
				if (string.Equals(value, "ease-in-circ", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 11;
					return true;
				}
				if (string.Equals(value, "ease-out-circ", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 12;
					return true;
				}
				if (string.Equals(value, "ease-in-out-circ", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 13;
					return true;
				}
				if (string.Equals(value, "ease-in-elastic", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 14;
					return true;
				}
				if (string.Equals(value, "ease-out-elastic", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 15;
					return true;
				}
				if (string.Equals(value, "ease-in-out-elastic", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 16;
					return true;
				}
				if (string.Equals(value, "ease-in-back", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 17;
					return true;
				}
				if (string.Equals(value, "ease-out-back", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 18;
					return true;
				}
				if (string.Equals(value, "ease-in-out-back", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 19;
					return true;
				}
				if (string.Equals(value, "ease-in-bounce", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 20;
					return true;
				}
				if (string.Equals(value, "ease-out-bounce", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 21;
					return true;
				}
				if (string.Equals(value, "ease-in-out-bounce", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 22;
					return true;
				}
				break;
			case StyleEnumType.FlexDirection:
				if (string.Equals(value, "column", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "column-reverse", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				if (string.Equals(value, "row", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 2;
					return true;
				}
				if (string.Equals(value, "row-reverse", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 3;
					return true;
				}
				break;
			case StyleEnumType.FontStyle:
				if (string.Equals(value, "normal", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "bold", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				if (string.Equals(value, "italic", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 2;
					return true;
				}
				if (string.Equals(value, "bold-and-italic", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 3;
					return true;
				}
				break;
			case StyleEnumType.Justify:
				if (string.Equals(value, "flex-start", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "center", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				if (string.Equals(value, "flex-end", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 2;
					return true;
				}
				if (string.Equals(value, "space-between", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 3;
					return true;
				}
				if (string.Equals(value, "space-around", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 4;
					return true;
				}
				break;
			case StyleEnumType.Overflow:
				if (string.Equals(value, "visible", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "hidden", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				break;
			case StyleEnumType.OverflowClipBox:
				if (string.Equals(value, "padding-box", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "content-box", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				break;
			case StyleEnumType.OverflowInternal:
				if (string.Equals(value, "visible", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "hidden", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				if (string.Equals(value, "scroll", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 2;
					return true;
				}
				break;
			case StyleEnumType.Position:
				if (string.Equals(value, "relative", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "absolute", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				break;
			case StyleEnumType.Repeat:
				if (string.Equals(value, "no-repeat", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "repeat", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 3;
					return true;
				}
				if (string.Equals(value, "space", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				if (string.Equals(value, "round", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 2;
					return true;
				}
				break;
			case StyleEnumType.RepeatXY:
				if (string.Equals(value, "repeat-x", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "repeat-y", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				break;
			case StyleEnumType.ScaleMode:
				if (string.Equals(value, "stretch-to-fill", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "scale-and-crop", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				if (string.Equals(value, "scale-to-fit", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 2;
					return true;
				}
				break;
			case StyleEnumType.TextAnchor:
				if (string.Equals(value, "upper-left", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "upper-center", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				if (string.Equals(value, "upper-right", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 2;
					return true;
				}
				if (string.Equals(value, "middle-left", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 3;
					return true;
				}
				if (string.Equals(value, "middle-center", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 4;
					return true;
				}
				if (string.Equals(value, "middle-right", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 5;
					return true;
				}
				if (string.Equals(value, "lower-left", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 6;
					return true;
				}
				if (string.Equals(value, "lower-center", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 7;
					return true;
				}
				if (string.Equals(value, "lower-right", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 8;
					return true;
				}
				break;
			case StyleEnumType.TextOverflow:
				if (string.Equals(value, "clip", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "ellipsis", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				break;
			case StyleEnumType.TextOverflowPosition:
				if (string.Equals(value, "start", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				if (string.Equals(value, "middle", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 2;
					return true;
				}
				if (string.Equals(value, "end", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				break;
			case StyleEnumType.TransformOriginOffset:
				if (string.Equals(value, "left", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				if (string.Equals(value, "right", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 2;
					return true;
				}
				if (string.Equals(value, "top", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 3;
					return true;
				}
				if (string.Equals(value, "bottom", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 4;
					return true;
				}
				if (string.Equals(value, "center", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 5;
					return true;
				}
				break;
			case StyleEnumType.Visibility:
				if (string.Equals(value, "visible", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "hidden", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				break;
			case StyleEnumType.WhiteSpace:
				if (string.Equals(value, "normal", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "nowrap", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				break;
			case StyleEnumType.Wrap:
				if (string.Equals(value, "nowrap", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 0;
					return true;
				}
				if (string.Equals(value, "wrap", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 1;
					return true;
				}
				if (string.Equals(value, "wrap-reverse", StringComparison.OrdinalIgnoreCase))
				{
					intValue = 2;
					return true;
				}
				break;
			}
			return false;
		}

		public static bool IsMatchingShorthand(StylePropertyId shorthand, StylePropertyId id)
		{
			return shorthand switch
			{
				StylePropertyId.All => true, 
				StylePropertyId.BackgroundPosition => id == StylePropertyId.BackgroundPositionX || id == StylePropertyId.BackgroundPositionY, 
				StylePropertyId.BorderColor => id == StylePropertyId.BorderTopColor || id == StylePropertyId.BorderRightColor || id == StylePropertyId.BorderBottomColor || id == StylePropertyId.BorderLeftColor, 
				StylePropertyId.BorderRadius => id == StylePropertyId.BorderTopLeftRadius || id == StylePropertyId.BorderTopRightRadius || id == StylePropertyId.BorderBottomRightRadius || id == StylePropertyId.BorderBottomLeftRadius, 
				StylePropertyId.BorderWidth => id == StylePropertyId.BorderTopWidth || id == StylePropertyId.BorderRightWidth || id == StylePropertyId.BorderBottomWidth || id == StylePropertyId.BorderLeftWidth, 
				StylePropertyId.Flex => id == StylePropertyId.FlexGrow || id == StylePropertyId.FlexShrink || id == StylePropertyId.FlexBasis, 
				StylePropertyId.Margin => id == StylePropertyId.MarginTop || id == StylePropertyId.MarginRight || id == StylePropertyId.MarginBottom || id == StylePropertyId.MarginLeft, 
				StylePropertyId.Padding => id == StylePropertyId.PaddingTop || id == StylePropertyId.PaddingRight || id == StylePropertyId.PaddingBottom || id == StylePropertyId.PaddingLeft, 
				StylePropertyId.UnityBackgroundScaleMode => id == StylePropertyId.BackgroundPositionX || id == StylePropertyId.BackgroundPositionY || id == StylePropertyId.BackgroundRepeat || id == StylePropertyId.BackgroundSize, 
				StylePropertyId.UnityTextOutline => id == StylePropertyId.UnityTextOutlineColor || id == StylePropertyId.UnityTextOutlineWidth, 
				_ => false, 
			};
		}

		public static IEnumerable<Type> GetAllowedAssetTypesForProperty(StylePropertyId id)
		{
			return id switch
			{
				StylePropertyId.BackgroundImage => Background.allowedAssetTypes, 
				StylePropertyId.Cursor => Cursor.allowedAssetTypes, 
				StylePropertyId.UnityFont => new Type[1] { typeof(Font) }, 
				StylePropertyId.UnityFontDefinition => FontDefinition.allowedAssetTypes, 
				StylePropertyId.Custom => new Type[1] { typeof(Object) }, 
				_ => Enumerable.Empty<Type>(), 
			};
		}

		public static bool IsAnimatable(StylePropertyId id)
		{
			return s_AnimatableProperties.Contains(id);
		}

		public static IEnumerable<StylePropertyId> AllPropertyIds()
		{
			return s_IdToName.Keys;
		}
	}
	internal static class CSSSpec
	{
		private static readonly Regex rgx = new Regex("(?<id>#[-]?\\w[\\w-]*)|(?<class>\\.[\\w-]+)|(?<pseudoclass>:[\\w-]+(\\((?<param>.+)\\))?)|(?<type>([^\\-]\\w+|\\w+))|(?<wildcard>\\*)|\\s+", RegexOptions.IgnoreCase | RegexOptions.Compiled);

		private const int typeSelectorWeight = 1;

		private const int classSelectorWeight = 10;

		private const int idSelectorWeight = 100;

		public static int GetSelectorSpecificity(string selector)
		{
			int result = 0;
			if (ParseSelector(selector, out var parts))
			{
				result = GetSelectorSpecificity(parts);
			}
			return result;
		}

		public static int GetSelectorSpecificity(StyleSelectorPart[] parts)
		{
			int num = 1;
			for (int i = 0; i < parts.Length; i++)
			{
				switch (parts[i].type)
				{
				case StyleSelectorType.Type:
					num++;
					break;
				case StyleSelectorType.Class:
				case StyleSelectorType.PseudoClass:
					num += 10;
					break;
				case StyleSelectorType.RecursivePseudoClass:
					throw new ArgumentException("Recursive pseudo classes are not supported");
				case StyleSelectorType.ID:
					num += 100;
					break;
				}
			}
			return num;
		}

		public static bool ParseSelector(string selector, out StyleSelectorPart[] parts)
		{
			MatchCollection matchCollection = rgx.Matches(selector);
			int count = matchCollection.Count;
			if (count < 1)
			{
				parts = null;
				return false;
			}
			parts = new StyleSelectorPart[count];
			for (int i = 0; i < count; i++)
			{
				Match match = matchCollection[i];
				StyleSelectorType type = StyleSelectorType.Unknown;
				string value = string.Empty;
				if (!string.IsNullOrEmpty(match.Groups["wildcard"].Value))
				{
					value = "*";
					type = StyleSelectorType.Wildcard;
				}
				else if (!string.IsNullOrEmpty(match.Groups["id"].Value))
				{
					value = match.Groups["id"].Value.Substring(1);
					type = StyleSelectorType.ID;
				}
				else if (!string.IsNullOrEmpty(match.Groups["class"].Value))
				{
					value = match.Groups["class"].Value.Substring(1);
					type = StyleSelectorType.Class;
				}
				else if (!string.IsNullOrEmpty(match.Groups["pseudoclass"].Value))
				{
					string value2 = match.Groups["param"].Value;
					if (!string.IsNullOrEmpty(value2))
					{
						value = value2;
						type = StyleSelectorType.RecursivePseudoClass;
					}
					else
					{
						value = match.Groups["pseudoclass"].Value.Substring(1);
						type = StyleSelectorType.PseudoClass;
					}
				}
				else if (!string.IsNullOrEmpty(match.Groups["type"].Value))
				{
					value = match.Groups["type"].Value;
					type = StyleSelectorType.Type;
				}
				parts[i] = new StyleSelectorPart
				{
					type = type,
					value = value
				};
			}
			return true;
		}
	}
	[Serializable]
	internal struct Dimension : IEquatable<Dimension>
	{
		public enum Unit
		{
			Unitless,
			Pixel,
			Percent,
			Second,
			Millisecond,
			Degree,
			Gradian,
			Radian,
			Turn
		}

		public Unit unit;

		public float value;

		public Dimension(float value, Unit unit)
		{
			this.unit = unit;
			this.value = value;
		}

		public Length ToLength()
		{
			LengthUnit lengthUnit = ((unit == Unit.Percent) ? LengthUnit.Percent : LengthUnit.Pixel);
			return new Length(value, lengthUnit);
		}

		public TimeValue ToTime()
		{
			TimeUnit timeUnit = ((unit == Unit.Millisecond) ? TimeUnit.Millisecond : TimeUnit.Second);
			return new TimeValue(value, timeUnit);
		}

		public Angle ToAngle()
		{
			return unit switch
			{
				Unit.Degree => new Angle(value, AngleUnit.Degree), 
				Unit.Gradian => new Angle(value, AngleUnit.Gradian), 
				Unit.Radian => new Angle(value, AngleUnit.Radian), 
				Unit.Turn => new Angle(value, AngleUnit.Turn), 
				_ => new Angle(value, AngleUnit.Degree), 
			};
		}

		public static bool operator ==(Dimension lhs, Dimension rhs)
		{
			return lhs.value == rhs.value && lhs.unit == rhs.unit;
		}

		public static bool operator !=(Dimension lhs, Dimension rhs)
		{
			return !(lhs == rhs);
		}

		public bool Equals(Dimension other)
		{
			return other == this;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is Dimension dimension))
			{
				return false;
			}
			return dimension == this;
		}

		public override int GetHashCode()
		{
			int num = -799583767;
			num = num * -1521134295 + unit.GetHashCode();
			return num * -1521134295 + value.GetHashCode();
		}

		public override string ToString()
		{
			string text = string.Empty;
			switch (unit)
			{
			case Unit.Pixel:
				text = "px";
				break;
			case Unit.Percent:
				text = "%";
				break;
			case Unit.Second:
				text = "s";
				break;
			case Unit.Millisecond:
				text = "ms";
				break;
			case Unit.Degree:
				text = "deg";
				break;
			case Unit.Gradian:
				text = "grad";
				break;
			case Unit.Radian:
				text = "rad";
				break;
			case Unit.Turn:
				text = "turn";
				break;
			case Unit.Unitless:
				text = string.Empty;
				break;
			}
			return value.ToString(CultureInfo.InvariantCulture.NumberFormat) + text;
		}
	}
	[Serializable]
	internal struct ScalableImage
	{
		public Texture2D normalImage;

		public Texture2D highResolutionImage;

		public override string ToString()
		{
			return string.Format("{0}: {1}, {2}: {3}", "normalImage", normalImage, "highResolutionImage", highResolutionImage);
		}
	}
	internal struct StylePropertyValue
	{
		public StyleSheet sheet;

		public StyleValueHandle handle;
	}
	internal struct ImageSource
	{
		public Texture2D texture;

		public Sprite sprite;

		public VectorImage vectorImage;

		public RenderTexture renderTexture;

		public bool IsNull()
		{
			return texture == null && sprite == null && vectorImage == null && renderTexture == null;
		}
	}
	internal class StylePropertyReader
	{
		internal delegate int GetCursorIdFunction(StyleSheet sheet, StyleValueHandle handle);

		internal static GetCursorIdFunction getCursorIdFunc;

		private List<StylePropertyValue> m_Values = new List<StylePropertyValue>();

		private List<int> m_ValueCount = new List<int>();

		private StyleVariableResolver m_Resolver = new StyleVariableResolver();

		private StyleSheet m_Sheet;

		private StyleProperty[] m_Properties;

		private StylePropertyId[] m_PropertyIds;

		private int m_CurrentValueIndex;

		private int m_CurrentPropertyIndex;

		public StyleProperty property { get; private set; }

		public StylePropertyId propertyId { get; private set; }

		public int valueCount { get; private set; }

		public float dpiScaling { get; private set; }

		public void SetContext(StyleSheet sheet, StyleComplexSelector selector, StyleVariableContext varContext, float dpiScaling = 1f)
		{
			m_Sheet = sheet;
			m_Properties = selector.rule.properties;
			m_PropertyIds = StyleSheetCache.GetPropertyIds(sheet, selector.ruleIndex);
			m_Resolver.variableContext = varContext;
			this.dpiScaling = dpiScaling;
			LoadProperties();
		}

		public void SetInlineContext(StyleSheet sheet, StyleProperty[] properties, StylePropertyId[] propertyIds, float dpiScaling = 1f)
		{
			m_Sheet = sheet;
			m_Properties = properties;
			m_PropertyIds = propertyIds;
			this.dpiScaling = dpiScaling;
			LoadProperties();
		}

		public StylePropertyId MoveNextProperty()
		{
			m_CurrentPropertyIndex++;
			m_CurrentValueIndex += valueCount;
			SetCurrentProperty();
			return propertyId;
		}

		public StylePropertyValue GetValue(int index)
		{
			return m_Values[m_CurrentValueIndex + index];
		}

		public StyleValueType GetValueType(int index)
		{
			return m_Values[m_CurrentValueIndex + index].handle.valueType;
		}

		public bool IsValueType(int index, StyleValueType type)
		{
			return m_Values[m_CurrentValueIndex + index].handle.valueType == type;
		}

		public bool IsKeyword(int index, StyleValueKeyword keyword)
		{
			StylePropertyValue stylePropertyValue = m_Values[m_CurrentValueIndex + index];
			return stylePropertyValue.handle.valueType == StyleValueType.Keyword && stylePropertyValue.handle.valueIndex == (int)keyword;
		}

		public string ReadAsString(int index)
		{
			StylePropertyValue stylePropertyValue = m_Values[m_CurrentValueIndex + index];
			return stylePropertyValue.sheet.ReadAsString(stylePropertyValue.handle);
		}

		public Length ReadLength(int index)
		{
			StylePropertyValue stylePropertyValue = m_Values[m_CurrentValueIndex + index];
			if (stylePropertyValue.handle.valueType == StyleValueType.Keyword)
			{
				return (StyleValueKeyword)stylePropertyValue.handle.valueIndex switch
				{
					StyleValueKeyword.Auto => Length.Auto(), 
					StyleValueKeyword.None => Length.None(), 
					_ => default(Length), 
				};
			}
			return stylePropertyValue.sheet.ReadDimension(stylePropertyValue.handle).ToLength();
		}

		public TimeValue ReadTimeValue(int index)
		{
			StylePropertyValue stylePropertyValue = m_Values[m_CurrentValueIndex + index];
			return stylePropertyValue.sheet.ReadDimension(stylePropertyValue.handle).ToTime();
		}

		public Translate ReadTranslate(int index)
		{
			StylePropertyValue val = m_Values[m_CurrentValueIndex + index];
			StylePropertyValue val2 = ((valueCount > 1) ? m_Values[m_CurrentValueIndex + index + 1] : default(StylePropertyValue));
			StylePropertyValue val3 = ((valueCount > 2) ? m_Values[m_CurrentValueIndex + index + 2] : default(StylePropertyValue));
			return ReadTranslate(valueCount, val, val2, val3);
		}

		public TransformOrigin ReadTransformOrigin(int index)
		{
			StylePropertyValue val = m_Values[m_CurrentValueIndex + index];
			StylePropertyValue val2 = ((valueCount > 1) ? m_Values[m_CurrentValueIndex + index + 1] : default(StylePropertyValue));
			StylePropertyValue zVvalue = ((valueCount > 2) ? m_Values[m_CurrentValueIndex + index + 2] : default(StylePropertyValue));
			return ReadTransformOrigin(valueCount, val, val2, zVvalue);
		}

		public Rotate ReadRotate(int index)
		{
			StylePropertyValue val = m_Values[m_CurrentValueIndex + index];
			StylePropertyValue val2 = ((valueCount > 1) ? m_Values[m_CurrentValueIndex + index + 1] : default(StylePropertyValue));
			StylePropertyValue val3 = ((valueCount > 2) ? m_Values[m_CurrentValueIndex + index + 2] : default(StylePropertyValue));
			StylePropertyValue val4 = ((valueCount > 3) ? m_Values[m_CurrentValueIndex + index + 3] : default(StylePropertyValue));
			return ReadRotate(valueCount, val, val2, val3, val4);
		}

		public Scale ReadScale(int index)
		{
			StylePropertyValue val = m_Values[m_CurrentValueIndex + index];
			StylePropertyValue val2 = ((valueCount > 1) ? m_Values[m_CurrentValueIndex + index + 1] : default(StylePropertyValue));
			StylePropertyValue val3 = ((valueCount > 2) ? m_Values[m_CurrentValueIndex + index + 2] : default(StylePropertyValue));
			return ReadScale(valueCount, val, val2, val3);
		}

		public float ReadFloat(int index)
		{
			StylePropertyValue stylePropertyValue = m_Values[m_CurrentValueIndex + index];
			return stylePropertyValue.sheet.ReadFloat(stylePropertyValue.handle);
		}

		public int ReadInt(int index)
		{
			StylePropertyValue stylePropertyValue = m_Values[m_CurrentValueIndex + index];
			return (int)stylePropertyValue.sheet.ReadFloat(stylePropertyValue.handle);
		}

		public Color ReadColor(int index)
		{
			StylePropertyValue stylePropertyValue = m_Values[m_CurrentValueIndex + index];
			Color color = Color.clear;
			if (stylePropertyValue.handle.valueType == StyleValueType.Enum)
			{
				string text = stylePropertyValue.sheet.ReadAsString(stylePropertyValue.handle);
				StyleSheetColor.TryGetColor(text.ToLowerInvariant(), out color);
			}
			else
			{
				color = stylePropertyValue.sheet.ReadColor(stylePropertyValue.handle);
			}
			return color;
		}

		public int ReadEnum(StyleEnumType enumType, int index)
		{
			string text = null;
			StylePropertyValue stylePropertyValue = m_Values[m_CurrentValueIndex + index];
			StyleValueHandle handle = stylePropertyValue.handle;
			if (handle.valueType == StyleValueType.Keyword)
			{
				StyleValueKeyword svk = stylePropertyValue.sheet.ReadKeyword(handle);
				text = svk.ToUssString();
			}
			else
			{
				text = stylePropertyValue.sheet.ReadEnum(handle);
			}
			StylePropertyUtil.TryGetEnumIntValue(enumType, text, out var intValue);
			return intValue;
		}

		public FontDefinition ReadFontDefinition(int index)
		{
			FontAsset fontAsset = null;
			Font font = null;
			StylePropertyValue stylePropertyValue = m_Values[m_CurrentValueIndex + index];
			switch (stylePropertyValue.handle.valueType)
			{
			case StyleValueType.ResourcePath:
			{
				string text = stylePropertyValue.sheet.ReadResourcePath(stylePropertyValue.handle);
				if (!string.IsNullOrEmpty(text))
				{
					font = Panel.LoadResource(text, typeof(Font), dpiScaling) as Font;
					if (font == null)
					{
						fontAsset = Panel.LoadResource(text, typeof(FontAsset), dpiScaling) as FontAsset;
					}
				}
				if (fontAsset == null && font == null)
				{
					Debug.LogWarning($"Font not found for path: {text}");
				}
				break;
			}
			case StyleValueType.AssetReference:
				font = stylePropertyValue.sheet.ReadAssetReference(stylePropertyValue.handle) as Font;
				if (font == null)
				{
					fontAsset = stylePropertyValue.sheet.ReadAssetReference(stylePropertyValue.handle) as FontAsset;
				}
				break;
			case StyleValueType.Keyword:
				if (stylePropertyValue.handle.valueIndex != 6)
				{
					Debug.LogWarning("Invalid keyword for font " + (StyleValueKeyword)stylePropertyValue.handle.valueIndex/*cast due to .constrained prefix*/);
				}
				break;
			default:
				Debug.LogWarning("Invalid value for font " + stylePropertyValue.handle.valueType);
				break;
			}
			if (font != null)
			{
				return FontDefinition.FromFont(font);
			}
			if (fontAsset != null)
			{
				return FontDefinition.FromSDFFont(fontAsset);
			}
			return default(FontDefinition);
		}

		public Font ReadFont(int index)
		{
			Font font = null;
			StylePropertyValue stylePropertyValue = m_Values[m_CurrentValueIndex + index];
			switch (stylePropertyValue.handle.valueType)
			{
			case StyleValueType.ResourcePath:
			{
				string text = stylePropertyValue.sheet.ReadResourcePath(stylePropertyValue.handle);
				if (!string.IsNullOrEmpty(text))
				{
					font = Panel.LoadResource(text, typeof(Font), dpiScaling) as Font;
				}
				if (font == null)
				{
					Debug.LogWarning($"Font not found for path: {text}");
				}
				break;
			}
			case StyleValueType.AssetReference:
				font = stylePropertyValue.sheet.ReadAssetReference(stylePropertyValue.handle) as Font;
				break;
			case StyleValueType.Keyword:
				if (stylePropertyValue.handle.valueIndex != 6)
				{
					Debug.LogWarning("Invalid keyword for font " + (StyleValueKeyword)stylePropertyValue.handle.valueIndex/*cast due to .constrained prefix*/);
				}
				break;
			default:
				Debug.LogWarning("Invalid value for font " + stylePropertyValue.handle.valueType);
				break;
			}
			return font;
		}

		public Background ReadBackground(int index)
		{
			ImageSource source = default(ImageSource);
			StylePropertyValue propertyValue = m_Values[m_CurrentValueIndex + index];
			if (propertyValue.handle.valueType == StyleValueType.Keyword)
			{
				if (propertyValue.handle.valueIndex != 6)
				{
					Debug.LogWarning("Invalid keyword for image source " + (StyleValueKeyword)propertyValue.handle.valueIndex/*cast due to .constrained prefix*/);
				}
			}
			else if (TryGetImageSourceFromValue(propertyValue, dpiScaling, out source))
			{
			}
			if (source.texture != null)
			{
				return Background.FromTexture2D(source.texture);
			}
			if (source.sprite != null)
			{
				return Background.FromSprite(source.sprite);
			}
			if (source.vectorImage != null)
			{
				return Background.FromVectorImage(source.vectorImage);
			}
			if (source.renderTexture != null)
			{
				return Background.FromRenderTexture(source.renderTexture);
			}
			return default(Background);
		}

		public Cursor ReadCursor(int index)
		{
			float x = 0f;
			float y = 0f;
			int defaultCursorId = 0;
			Texture2D texture = null;
			StyleValueType valueType = GetValueType(index);
			if (valueType == StyleValueType.ResourcePath || valueType == StyleValueType.AssetReference || valueType == StyleValueType.ScalableImage || valueType == StyleValueType.MissingAssetReference)
			{
				if (valueCount < 1)
				{
					Debug.LogWarning($"USS 'cursor' has invalid value at {index}.");
				}
				else
				{
					ImageSource source = default(ImageSource);
					StylePropertyValue value = GetValue(index);
					if (TryGetImageSourceFromValue(value, dpiScaling, out source))
					{
						texture = source.texture;
						if (valueCount >= 3)
						{
							StylePropertyValue value2 = GetValue(index + 1);
							StylePropertyValue value3 = GetValue(index + 2);
							if (value2.handle.valueType != StyleValueType.Float || value3.handle.valueType != StyleValueType.Float)
							{
								Debug.LogWarning("USS 'cursor' property requires two integers for the hot spot value.");
							}
							else
							{
								x = value2.sheet.ReadFloat(value2.handle);
								y = value3.sheet.ReadFloat(value3.handle);
							}
						}
					}
				}
			}
			else if (getCursorIdFunc != null)
			{
				StylePropertyValue value4 = GetValue(index);
				defaultCursorId = getCursorIdFunc(value4.sheet, value4.handle);
			}
			return new Cursor
			{
				texture = texture,
				hotspot = new Vector2(x, y),
				defaultCursorId = defaultCursorId
			};
		}

		public TextShadow ReadTextShadow(int index)
		{
			float x = 0f;
			float y = 0f;
			float blurRadius = 0f;
			Color color = Color.clear;
			if (valueCount >= 2)
			{
				int num = index;
				StyleValueType valueType = GetValueType(num);
				bool flag = false;
				if (valueType == StyleValueType.Color || valueType == StyleValueType.Enum)
				{
					color = ReadColor(num++);
					flag = true;
				}
				if (num + 1 < valueCount)
				{
					valueType = GetValueType(num);
					StyleValueType valueType2 = GetValueType(num + 1);
					if ((valueType == StyleValueType.Dimension || valueType == StyleValueType.Float) && (valueType2 == StyleValueType.Dimension || valueType2 == StyleValueType.Float))
					{
						StylePropertyValue value = GetValue(num++);
						StylePropertyValue value2 = GetValue(num++);
						x = value.sheet.ReadDimension(value.handle).value;
						y = value2.sheet.ReadDimension(value2.handle).value;
					}
				}
				if (num < valueCount)
				{
					valueType = GetValueType(num);
					if (valueType == StyleValueType.Dimension || valueType == StyleValueType.Float)
					{
						StylePropertyValue value3 = GetValue(num++);
						blurRadius = value3.sheet.ReadDimension(value3.handle).value;
					}
					else if ((valueType == StyleValueType.Color || valueType == StyleValueType.Enum) && !flag)
					{
						color = ReadColor(num);
					}
				}
				if (num < valueCount)
				{
					valueType = GetValueType(num);
					if ((valueType == StyleValueType.Color || valueType == StyleValueType.Enum) && !flag)
					{
						color = ReadColor(num);
					}
				}
			}
			return new TextShadow
			{
				offset = new Vector2(x, y),
				blurRadius = blurRadius,
				color = color
			};
		}

		public BackgroundPosition ReadBackgroundPositionX(int index)
		{
			return ReadBackgroundPosition(index, BackgroundPositionKeyword.Left);
		}

		public BackgroundPosition ReadBackgroundPositionY(int index)
		{
			return ReadBackgroundPosition(index, BackgroundPositionKeyword.Top);
		}

		private BackgroundPosition ReadBackgroundPosition(int index, BackgroundPositionKeyword keyword)
		{
			StylePropertyValue val = m_Values[m_CurrentValueIndex + index];
			StylePropertyValue val2 = ((valueCount > 1) ? m_Values[m_CurrentValueIndex + index + 1] : default(StylePropertyValue));
			return ReadBackgroundPosition(valueCount, val, val2, keyword);
		}

		public BackgroundRepeat ReadBackgroundRepeat(int index)
		{
			StylePropertyValue val = m_Values[m_CurrentValueIndex + index];
			StylePropertyValue val2 = ((valueCount > 1) ? m_Values[m_CurrentValueIndex + index + 1] : default(StylePropertyValue));
			return ReadBackgroundRepeat(valueCount, val, val2);
		}

		public BackgroundSize ReadBackgroundSize(int index)
		{
			StylePropertyValue val = m_Values[m_CurrentValueIndex + index];
			StylePropertyValue val2 = ((valueCount > 1) ? m_Values[m_CurrentValueIndex + index + 1] : default(StylePropertyValue));
			return ReadBackgroundSize(valueCount, val, val2);
		}

		public void ReadListEasingFunction(List<EasingFunction> list, int index)
		{
			list.Clear();
			do
			{
				StylePropertyValue stylePropertyValue = m_Values[m_CurrentValueIndex + index];
				StyleValueHandle handle = stylePropertyValue.handle;
				if (handle.valueType == StyleValueType.Enum)
				{
					string value = stylePropertyValue.sheet.ReadEnum(handle);
					StylePropertyUtil.TryGetEnumIntValue(StyleEnumType.EasingMode, value, out var intValue);
					list.Add(new EasingFunction((EasingMode)intValue));
					index++;
				}
				if (index < valueCount && m_Values[m_CurrentValueIndex + index].handle.valueType == StyleValueType.CommaSeparator)
				{
					index++;
				}
			}
			while (index < valueCount);
		}

		public void ReadListTimeValue(List<TimeValue> list, int index)
		{
			list.Clear();
			do
			{
				StylePropertyValue stylePropertyValue = m_Values[m_CurrentValueIndex + index];
				TimeValue item = stylePropertyValue.sheet.ReadDimension(stylePropertyValue.handle).ToTime();
				list.Add(item);
				index++;
				if (index < valueCount && m_Values[m_CurrentValueIndex + index].handle.valueType == StyleValueType.CommaSeparator)
				{
					index++;
				}
			}
			while (index < valueCount);
		}

		public void ReadListStylePropertyName(List<StylePropertyName> list, int index)
		{
			list.Clear();
			do
			{
				StylePropertyValue stylePropertyValue = m_Values[m_CurrentValueIndex + index];
				string name = stylePropertyValue.sheet.ReadAsString(stylePropertyValue.handle);
				list.Add(new StylePropertyName(name));
				index++;
				if (index < valueCount && m_Values[m_CurrentValueIndex + index].handle.valueType == StyleValueType.CommaSeparator)
				{
					index++;
				}
			}
			while (index < valueCount);
		}

		public void ReadListString(List<string> list, int index)
		{
			list.Clear();
			do
			{
				StylePropertyValue stylePropertyValue = m_Values[m_CurrentValueIndex + index];
				string item = stylePropertyValue.sheet.ReadAsString(stylePropertyValue.handle);
				list.Add(item);
				index++;
				if (index < valueCount && m_Values[m_CurrentValueIndex + index].handle.valueType == StyleValueType.CommaSeparator)
				{
					index++;
				}
			}
			while (index < valueCount);
		}

		private void LoadProperties()
		{
			m_CurrentPropertyIndex = 0;
			m_CurrentValueIndex = 0;
			m_Values.Clear();
			m_ValueCount.Clear();
			StyleProperty[] properties = m_Properties;
			foreach (StyleProperty styleProperty in properties)
			{
				int num = 0;
				bool flag = true;
				if (styleProperty.requireVariableResolve)
				{
					m_Resolver.Init(styleProperty, m_Sheet, styleProperty.values);
					for (int j = 0; j < styleProperty.values.Length && flag; j++)
					{
						StyleValueHandle handle = styleProperty.values[j];
						if (handle.IsVarFunction())
						{
							flag = m_Resolver.ResolveVarFunction(ref j);
						}
						else
						{
							m_Resolver.AddValue(handle);
						}
					}
					if (flag && m_Resolver.ValidateResolvedValues())
					{
						m_Values.AddRange(m_Resolver.resolvedValues);
						num += m_Resolver.resolvedValues.Count;
					}
					else
					{
						StyleValueHandle handle2 = new StyleValueHandle
						{
							valueType = StyleValueType.Keyword,
							valueIndex = 3
						};
						m_Values.Add(new StylePropertyValue
						{
							sheet = m_Sheet,
							handle = handle2
						});
						num++;
					}
				}
				else
				{
					num = styleProperty.values.Length;
					for (int k = 0; k < num; k++)
					{
						m_Values.Add(new StylePropertyValue
						{
							sheet = m_Sheet,
							handle = styleProperty.values[k]
						});
					}
				}
				m_ValueCount.Add(num);
			}
			SetCurrentProperty();
		}

		private void SetCurrentProperty()
		{
			if (m_CurrentPropertyIndex < m_PropertyIds.Length)
			{
				property = m_Properties[m_CurrentPropertyIndex];
				propertyId = m_PropertyIds[m_CurrentPropertyIndex];
				valueCount = m_ValueCount[m_CurrentPropertyIndex];
			}
			else
			{
				property = null;
				propertyId = StylePropertyId.Unknown;
				valueCount = 0;
			}
		}

		public static TransformOrigin ReadTransformOrigin(int valCount, StylePropertyValue val1, StylePropertyValue val2, StylePropertyValue zVvalue)
		{
			Length x = Length.Percent(50f);
			Length y = Length.Percent(50f);
			float z = 0f;
			switch (valCount)
			{
			case 1:
			{
				bool isVertical;
				bool isHorizontal;
				Length length = ReadTransformOriginEnum(val1, out isVertical, out isHorizontal);
				if (isHorizontal)
				{
					x = length;
				}
				else
				{
					y = length;
				}
				break;
			}
			case 2:
			{
				bool isVertical2;
				bool isHorizontal2;
				Length length2 = ReadTransformOriginEnum(val1, out isVertical2, out isHorizontal2);
				bool isVertical3;
				bool isHorizontal3;
				Length length3 = ReadTransformOriginEnum(val2, out isVertical3, out isHorizontal3);
				if (!isHorizontal2 || !isVertical3)
				{
					if (isHorizontal3 && isVertical2)
					{
						x = length3;
						y = length2;
					}
				}
				else
				{
					x = length2;
					y = length3;
				}
				break;
			}
			case 3:
				if (zVvalue.handle.valueType == StyleValueType.Dimension || zVvalue.handle.valueType == StyleValueType.Float)
				{
					z = zVvalue.sheet.ReadDimension(zVvalue.handle).value;
				}
				goto case 2;
			}
			return new TransformOrigin(x, y, z);
		}

		private static Length ReadTransformOriginEnum(StylePropertyValue value, out bool isVertical, out bool isHorizontal)
		{
			if (value.handle.valueType == StyleValueType.Enum)
			{
				switch ((TransformOriginOffset)ReadEnum(StyleEnumType.TransformOriginOffset, value))
				{
				case TransformOriginOffset.Left:
					isVertical = false;
					isHorizontal = true;
					return Length.Percent(0f);
				case TransformOriginOffset.Top:
					isVertical = true;
					isHorizontal = false;
					return Length.Percent(0f);
				case TransformOriginOffset.Center:
					isVertical = true;
					isHorizontal = true;
					return Length.Percent(50f);
				case TransformOriginOffset.Right:
					isVertical = false;
					isHorizontal = true;
					return Length.Percent(100f);
				case TransformOriginOffset.Bottom:
					isVertical = true;
					isHorizontal = false;
					return Length.Percent(100f);
				}
			}
			else if (value.handle.valueType == StyleValueType.Dimension || value.handle.valueType == StyleValueType.Float)
			{
				isVertical = true;
				isHorizontal = true;
				return value.sheet.ReadDimension(value.handle).ToLength();
			}
			isVertical = false;
			isHorizontal = false;
			return Length.Percent(50f);
		}

		public static Translate ReadTranslate(int valCount, StylePropertyValue val1, StylePropertyValue val2, StylePropertyValue val3)
		{
			if (val1.handle.valueType == StyleValueType.Keyword && val1.handle.valueIndex == 6)
			{
				return Translate.None();
			}
			Length x = 0f;
			Length y = 0f;
			float z = 0f;
			switch (valCount)
			{
			case 1:
				if (val1.handle.valueType == StyleValueType.Dimension || val1.handle.valueType == StyleValueType.Float)
				{
					x = val1.sheet.ReadDimension(val1.handle).ToLength();
					y = val1.sheet.ReadDimension(val1.handle).ToLength();
				}
				break;
			case 2:
				if (val1.handle.valueType == StyleValueType.Dimension || val1.handle.valueType == StyleValueType.Float)
				{
					x = val1.sheet.ReadDimension(val1.handle).ToLength();
				}
				if (val2.handle.valueType == StyleValueType.Dimension || val2.handle.valueType == StyleValueType.Float)
				{
					y = val2.sheet.ReadDimension(val2.handle).ToLength();
				}
				break;
			case 3:
				if (val3.handle.valueType == StyleValueType.Dimension || val3.handle.valueType == StyleValueType.Float)
				{
					Dimension dimension = val3.sheet.ReadDimension(val3.handle);
					if (dimension.unit != Dimension.Unit.Pixel && dimension.unit != Dimension.Unit.Unitless)
					{
						z = dimension.value;
					}
				}
				goto case 2;
			}
			return new Translate(x, y, z);
		}

		public static Scale ReadScale(int valCount, StylePropertyValue val1, StylePropertyValue val2, StylePropertyValue val3)
		{
			if (val1.handle.valueType == StyleValueType.Keyword && val1.handle.valueIndex == 6)
			{
				return Scale.None();
			}
			Vector3 one = Vector3.one;
			switch (valCount)
			{
			case 1:
				if (val1.handle.valueType == StyleValueType.Dimension || val1.handle.valueType == StyleValueType.Float)
				{
					one.x = val1.sheet.ReadFloat(val1.handle);
					one.y = one.x;
				}
				break;
			case 2:
				if (val1.handle.valueType == StyleValueType.Dimension || val1.handle.valueType == StyleValueType.Float)
				{
					one.x = val1.sheet.ReadFloat(val1.handle);
				}
				if (val2.handle.valueType == StyleValueType.Dimension || val2.handle.valueType == StyleValueType.Float)
				{
					one.y = val2.sheet.ReadFloat(val2.handle);
				}
				break;
			case 3:
				if (val3.handle.valueType == StyleValueType.Dimension || val3.handle.valueType == StyleValueType.Float)
				{
					one.z = val3.sheet.ReadFloat(val3.handle);
				}
				goto case 2;
			}
			return new Scale(one);
		}

		public static Rotate ReadRotate(int valCount, StylePropertyValue val1, StylePropertyValue val2, StylePropertyValue val3, StylePropertyValue val4)
		{
			if (val1.handle.valueType == StyleValueType.Keyword && val1.handle.valueIndex == 6)
			{
				return Rotate.None();
			}
			Rotate result = Rotate.Initial();
			if (valCount == 1 && val1.handle.valueType == StyleValueType.Dimension)
			{
				result.angle = ReadAngle(val1);
			}
			return result;
		}

		private static bool TryReadEnum(StyleEnumType enumType, StylePropertyValue value, out int intValue)
		{
			string text = null;
			StyleValueHandle handle = value.handle;
			if (handle.valueType == StyleValueType.Keyword)
			{
				StyleValueKeyword svk = value.sheet.ReadKeyword(handle);
				text = svk.ToUssString();
			}
			else
			{
				text = value.sheet.ReadEnum(handle);
			}
			return StylePropertyUtil.TryGetEnumIntValue(enumType, text, out intValue);
		}

		private static int ReadEnum(StyleEnumType enumType, StylePropertyValue value)
		{
			string text = null;
			StyleValueHandle handle = value.handle;
			if (handle.valueType == StyleValueType.Keyword)
			{
				StyleValueKeyword svk = value.sheet.ReadKeyword(handle);
				text = svk.ToUssString();
			}
			else
			{
				text = value.sheet.ReadEnum(handle);
			}
			StylePropertyUtil.TryGetEnumIntValue(enumType, text, out var intValue);
			return intValue;
		}

		public static Angle ReadAngle(StylePropertyValue value)
		{
			if (value.handle.valueType == StyleValueType.Keyword)
			{
				StyleValueKeyword valueIndex = (StyleValueKeyword)value.handle.valueIndex;
				StyleValueKeyword styleValueKeyword = valueIndex;
				StyleValueKeyword styleValueKeyword2 = styleValueKeyword;
				if (styleValueKeyword2 == StyleValueKeyword.None)
				{
					return Angle.None();
				}
				return default(Angle);
			}
			return value.sheet.ReadDimension(value.handle).ToAngle();
		}

		public static BackgroundPosition ReadBackgroundPosition(int valCount, StylePropertyValue val1, StylePropertyValue val2, BackgroundPositionKeyword keyword)
		{
			switch (valCount)
			{
			case 1:
				if (val1.handle.valueType == StyleValueType.Enum)
				{
					return new BackgroundPosition((BackgroundPositionKeyword)ReadEnum(StyleEnumType.BackgroundPositionKeyword, val1));
				}
				if (val1.handle.valueType == StyleValueType.Dimension || val1.handle.valueType == StyleValueType.Float)
				{
					return new BackgroundPosition(keyword, val1.sheet.ReadDimension(val1.handle).ToLength());
				}
				break;
			case 2:
				if (val1.handle.valueType == StyleValueType.Enum && (val2.handle.valueType == StyleValueType.Dimension || val2.handle.valueType == StyleValueType.Float))
				{
					return new BackgroundPosition((BackgroundPositionKeyword)ReadEnum(StyleEnumType.BackgroundPositionKeyword, val1), val1.sheet.ReadDimension(val2.handle).ToLength());
				}
				break;
			}
			return default(BackgroundPosition);
		}

		public static BackgroundRepeat ReadBackgroundRepeat(int valCount, StylePropertyValue val1, StylePropertyValue val2)
		{
			BackgroundRepeat result = default(BackgroundRepeat);
			if (valCount == 1)
			{
				if (TryReadEnum(StyleEnumType.RepeatXY, val1, out var intValue))
				{
					switch (intValue)
					{
					case 0:
						result.x = Repeat.Repeat;
						result.y = Repeat.NoRepeat;
						break;
					case 1:
						result.x = Repeat.NoRepeat;
						result.y = Repeat.Repeat;
						break;
					}
				}
				else
				{
					result.x = (Repeat)ReadEnum(StyleEnumType.Repeat, val1);
					result.y = result.x;
				}
			}
			else
			{
				result.x = (Repeat)ReadEnum(StyleEnumType.Repeat, val1);
				result.y = (Repeat)ReadEnum(StyleEnumType.Repeat, val2);
			}
			return result;
		}

		public static BackgroundSize ReadBackgroundSize(int valCount, StylePropertyValue val1, StylePropertyValue val2)
		{
			BackgroundSize result = default(BackgroundSize);
			switch (valCount)
			{
			case 1:
				if (val1.handle.valueType == StyleValueType.Keyword)
				{
					if (val1.handle.valueIndex == 2)
					{
						result.x = Length.Auto();
						result.y = Length.Auto();
					}
				}
				else if (val1.handle.valueType == StyleValueType.Enum)
				{
					result.sizeType = (BackgroundSizeType)ReadEnum(StyleEnumType.BackgroundSizeType, val1);
				}
				else if (val1.handle.valueType == StyleValueType.Dimension)
				{
					result.x = val1.sheet.ReadDimension(val1.handle).ToLength();
					result.y = Length.Auto();
				}
				break;
			case 2:
				if (val1.handle.valueType == StyleValueType.Keyword)
				{
					if (val1.handle.valueIndex == 2)
					{
						result.x = Length.Auto();
					}
				}
				else if (val1.handle.valueType == StyleValueType.Dimension)
				{
					result.x = val1.sheet.ReadDimension(val1.handle).ToLength();
				}
				if (val2.handle.valueType == StyleValueType.Keyword)
				{
					if (val2.handle.valueIndex == 2)
					{
						result.y = Length.Auto();
					}
				}
				else if (val2.handle.valueType == StyleValueType.Dimension)
				{
					result.y = val2.sheet.ReadDimension(val2.handle).ToLength();
				}
				break;
			}
			return result;
		}

		internal static bool TryGetImageSourceFromValue(StylePropertyValue propertyValue, float dpiScaling, out ImageSource source)
		{
			source = default(ImageSource);
			switch (propertyValue.handle.valueType)
			{
			case StyleValueType.ResourcePath:
			{
				string text = propertyValue.sheet.ReadResourcePath(propertyValue.handle);
				if (!string.IsNullOrEmpty(text))
				{
					source.sprite = Panel.LoadResource(text, typeof(Sprite), dpiScaling) as Sprite;
					if (source.IsNull())
					{
						source.texture = Panel.LoadResource(text, typeof(Texture2D), dpiScaling) as Texture2D;
					}
					if (source.IsNull())
					{
						source.vectorImage = Panel.LoadResource(text, typeof(VectorImage), dpiScaling) as VectorImage;
					}
					if (source.IsNull())
					{
						source.renderTexture = Panel.LoadResource(text, typeof(RenderTexture), dpiScaling) as RenderTexture;
					}
				}
				if (source.IsNull())
				{
					Debug.LogWarning($"Image not found for path: {text}");
					return false;
				}
				break;
			}
			case StyleValueType.AssetReference:
			{
				Object obj = propertyValue.sheet.ReadAssetReference(propertyValue.handle);
				source.texture = obj as Texture2D;
				source.sprite = obj as Sprite;
				source.vectorImage = obj as VectorImage;
				source.renderTexture = obj as RenderTexture;
				if (source.IsNull())
				{
					Debug.LogWarning("Invalid image specified");
					return false;
				}
				break;
			}
			case StyleValueType.MissingAssetReference:
				return false;
			case StyleValueType.ScalableImage:
			{
				ScalableImage scalableImage = propertyValue.sheet.ReadScalableImage(propertyValue.handle);
				if (scalableImage.normalImage == null && scalableImage.highResolutionImage == null)
				{
					Debug.LogWarning("Invalid scalable image specified");
					return false;
				}
				source.texture = scalableImage.normalImage;
				if (!Mathf.Approximately(dpiScaling % 1f, 0f))
				{
					source.texture.filterMode = FilterMode.Bilinear;
				}
				break;
			}
			default:
				Debug.LogWarning("Invalid value for image texture " + propertyValue.handle.valueType);
				return false;
			}
			return true;
		}
	}
	internal struct MatchResultInfo
	{
		public readonly bool success;

		public readonly PseudoStates triggerPseudoMask;

		public readonly PseudoStates dependencyPseudoMask;

		public MatchResultInfo(bool success, PseudoStates triggerPseudoMask, PseudoStates dependencyPseudoMask)
		{
			this.success = success;
			this.triggerPseudoMask = triggerPseudoMask;
			this.dependencyPseudoMask = dependencyPseudoMask;
		}
	}
	internal struct SelectorMatchRecord
	{
		public StyleSheet sheet;

		public int styleSheetIndexInStack;

		public StyleComplexSelector complexSelector;

		public SelectorMatchRecord(StyleSheet sheet, int styleSheetIndexInStack)
		{
			this = default(SelectorMatchRecord);
			this.sheet = sheet;
			this.styleSheetIndexInStack = styleSheetIndexInStack;
		}

		public static int Compare(SelectorMatchRecord a, SelectorMatchRecord b)
		{
			if (a.sheet.isDefaultStyleSheet != b.sheet.isDefaultStyleSheet)
			{
				return (!a.sheet.isDefaultStyleSheet) ? 1 : (-1);
			}
			int num = a.complexSelector.specificity.CompareTo(b.complexSelector.specificity);
			if (num == 0)
			{
				num = a.styleSheetIndexInStack.CompareTo(b.styleSheetIndexInStack);
			}
			if (num == 0)
			{
				num = a.complexSelector.orderInStyleSheet.CompareTo(b.complexSelector.orderInStyleSheet);
			}
			return num;
		}
	}
	internal static class StyleSelectorHelper
	{
		public static MatchResultInfo MatchesSelector(VisualElement element, StyleSelector selector)
		{
			bool flag = true;
			StyleSelectorPart[] parts = selector.parts;
			int num = parts.Length;
			for (int i = 0; i < num && flag; i++)
			{
				switch (parts[i].type)
				{
				case StyleSelectorType.Class:
					flag = element.ClassListContains(parts[i].value);
					break;
				case StyleSelectorType.ID:
					flag = string.Equals(element.name, parts[i].value, StringComparison.Ordinal);
					break;
				case StyleSelectorType.Type:
					flag = string.Equals(element.typeName, parts[i].value, StringComparison.Ordinal);
					break;
				case StyleSelectorType.Predicate:
					flag = parts[i].tempData is UQuery.IVisualPredicateWrapper visualPredicateWrapper && visualPredicateWrapper.Predicate(element);
					break;
				default:
					flag = false;
					break;
				case StyleSelectorType.Wildcard:
				case StyleSelectorType.PseudoClass:
					break;
				}
			}
			int num2 = 0;
			int num3 = 0;
			bool flag2 = flag;
			if (flag2 && selector.pseudoStateMask != 0)
			{
				flag = ((uint)selector.pseudoStateMask & (uint)element.pseudoStates) == (uint)selector.pseudoStateMask;
				if (flag)
				{
					num3 = selector.pseudoStateMask;
				}
				else
				{
					num2 = selector.pseudoStateMask;
				}
			}
			if (flag2 && selector.negatedPseudoStateMask != 0)
			{
				flag &= ((uint)selector.negatedPseudoStateMask & (uint)(~element.pseudoStates)) == (uint)selector.negatedPseudoStateMask;
				if (flag)
				{
					num2 |= selector.negatedPseudoStateMask;
				}
				else
				{
					num3 |= selector.negatedPseudoStateMask;
				}
			}
			return new MatchResultInfo(flag, (PseudoStates)num2, (PseudoStates)num3);
		}

		public static bool MatchRightToLeft(VisualElement element, StyleComplexSelector complexSelector, Action<VisualElement, MatchResultInfo> processResult)
		{
			VisualElement visualElement = element;
			int num = complexSelector.selectors.Length - 1;
			VisualElement visualElement2 = null;
			int num2 = -1;
			while (num >= 0 && visualElement != null)
			{
				MatchResultInfo arg = MatchesSelector(visualElement, complexSelector.selectors[num]);
				processResult(visualElement, arg);
				if (!arg.success)
				{
					if (num < complexSelector.selectors.Length - 1 && complexSelector.selectors[num + 1].previousRelationship == StyleSelectorRelationship.Descendent)
					{
						visualElement = visualElement.parent;
						continue;
					}
					if (visualElement2 != null)
					{
						visualElement = visualElement2;
						num = num2;
						continue;
					}
					break;
				}
				if (num < complexSelector.selectors.Length - 1 && complexSelector.selectors[num + 1].previousRelationship == StyleSelectorRelationship.Descendent)
				{
					visualElement2 = visualElement.parent;
					num2 = num;
				}
				if (--num < 0)
				{
					return true;
				}
				visualElement = visualElement.parent;
			}
			return false;
		}

		private static void FastLookup(IDictionary<string, StyleComplexSelector> table, List<SelectorMatchRecord> matchedSelectors, StyleMatchingContext context, string input, ref SelectorMatchRecord record)
		{
			if (!table.TryGetValue(input, out var value))
			{
				return;
			}
			while (value != null)
			{
				bool flag = true;
				bool flag2 = false;
				if (!value.isSimple)
				{
					flag = context.ancestorFilter.IsCandidate(value);
				}
				if (flag)
				{
					flag2 = MatchRightToLeft(context.currentElement, value, context.processResult);
				}
				if (flag2)
				{
					record.complexSelector = value;
					matchedSelectors.Add(record);
				}
				value = value.nextInTable;
			}
		}

		public static void FindMatches(StyleMatchingContext context, List<SelectorMatchRecord> matchedSelectors)
		{
			VisualElement currentElement = context.currentElement;
			int num = context.styleSheetCount - 1;
			if (currentElement.styleSheetList != null)
			{
				int num2 = currentElement.styleSheetList.Count;
				for (int i = 0; i < currentElement.styleSheetList.Count; i++)
				{
					StyleSheet styleSheet = currentElement.styleSheetList[i];
					if (styleSheet.flattenedRecursiveImports != null)
					{
						num2 += styleSheet.flattenedRecursiveImports.Count;
					}
				}
				num -= num2;
			}
			FindMatches(context, matchedSelectors, num);
		}

		public static void FindMatches(StyleMatchingContext context, List<SelectorMatchRecord> matchedSelectors, int parentSheetIndex)
		{
			Debug.Assert(matchedSelectors.Count == 0);
			Debug.Assert(context.currentElement != null, "context.currentElement != null");
			bool flag = false;
			HashSet<StyleSheet> hashSet = CollectionPool<HashSet<StyleSheet>, StyleSheet>.Get();
			try
			{
				VisualElement currentElement = context.currentElement;
				for (int num = context.styleSheetCount - 1; num >= 0; num--)
				{
					StyleSheet styleSheetAt = context.GetStyleSheetAt(num);
					if (hashSet.Add(styleSheetAt))
					{
						if (num > parentSheetIndex)
						{
							currentElement.pseudoStates |= PseudoStates.Root;
							flag = true;
						}
						else
						{
							currentElement.pseudoStates &= ~PseudoStates.Root;
						}
						SelectorMatchRecord record = new SelectorMatchRecord(styleSheetAt, num);
						FastLookup(styleSheetAt.orderedTypeSelectors, matchedSelectors, context, currentElement.typeName, ref record);
						FastLookup(styleSheetAt.orderedTypeSelectors, matchedSelectors, context, "*", ref record);
						if (!string.IsNullOrEmpty(currentElement.name))
						{
							FastLookup(styleSheetAt.orderedNameSelectors, matchedSelectors, context, currentElement.name, ref record);
						}
						foreach (string item in currentElement.GetClassesForIteration())
						{
							FastLookup(styleSheetAt.orderedClassSelectors, matchedSelectors, context, item, ref record);
						}
					}
				}
				if (flag)
				{
					currentElement.pseudoStates &= ~PseudoStates.Root;
				}
			}
			finally
			{
				CollectionPool<HashSet<StyleSheet>, StyleSheet>.Release(hashSet);
			}
		}
	}
	internal class StyleSheetBuilder
	{
		public struct ComplexSelectorScope : IDisposable
		{
			private StyleSheetBuilder m_Builder;

			public ComplexSelectorScope(StyleSheetBuilder builder)
			{
				m_Builder = builder;
			}

			public void Dispose()
			{
				m_Builder.EndComplexSelector();
			}
		}

		private enum BuilderState
		{
			Init,
			Rule,
			ComplexSelector,
			Property
		}

		private BuilderState m_BuilderState;

		private List<float> m_Floats = new List<float>();

		private List<Dimension> m_Dimensions = new List<Dimension>();

		private List<Color> m_Colors = new List<Color>();

		private List<string> m_Strings = new List<string>();

		private List<StyleRule> m_Rules = new List<StyleRule>();

		private List<Object> m_Assets = new List<Object>();

		private List<ScalableImage> m_ScalableImages = new List<ScalableImage>();

		private List<StyleComplexSelector> m_ComplexSelectors = new List<StyleComplexSelector>();

		private List<StyleProperty> m_CurrentProperties = new List<StyleProperty>();

		private List<StyleValueHandle> m_CurrentValues = new List<StyleValueHandle>();

		private StyleComplexSelector m_CurrentComplexSelector;

		private List<StyleSelector> m_CurrentSelectors = new List<StyleSelector>();

		private StyleProperty m_CurrentProperty;

		private StyleRule m_CurrentRule;

		private List<StyleSheet.ImportStruct> m_Imports = new List<StyleSheet.ImportStruct>();

		public StyleProperty currentProperty => m_CurrentProperty;

		public StyleRule BeginRule(int ruleLine)
		{
			Log("Beginning rule");
			Debug.Assert(m_BuilderState == BuilderState.Init);
			m_BuilderState = BuilderState.Rule;
			m_CurrentRule = new StyleRule
			{
				line = ruleLine
			};
			return m_CurrentRule;
		}

		public ComplexSelectorScope BeginComplexSelector(int specificity)
		{
			Log("Begin complex selector with specificity " + specificity);
			Debug.Assert(m_BuilderState == BuilderState.Rule);
			m_BuilderState = BuilderState.ComplexSelector;
			m_CurrentComplexSelector = new StyleComplexSelector();
			m_CurrentComplexSelector.specificity = specificity;
			m_CurrentComplexSelector.ruleIndex = m_Rules.Count;
			return new ComplexSelectorScope(this);
		}

		public void AddSimpleSelector(StyleSelectorPart[] parts, StyleSelectorRelationship previousRelationsip)
		{
			Debug.Assert(m_BuilderState == BuilderState.ComplexSelector);
			StyleSelector styleSelector = new StyleSelector();
			styleSelector.parts = parts;
			styleSelector.previousRelationship = previousRelationsip;
			Log("Add simple selector " + styleSelector);
			m_CurrentSelectors.Add(styleSelector);
		}

		public void EndComplexSelector()
		{
			Log("Ending complex selector");
			Debug.Assert(m_BuilderState == BuilderState.ComplexSelector);
			m_BuilderState = BuilderState.Rule;
			if (m_CurrentSelectors.Count > 0)
			{
				m_CurrentComplexSelector.selectors = m_CurrentSelectors.ToArray();
				m_ComplexSelectors.Add(m_CurrentComplexSelector);
				m_CurrentSelectors.Clear();
			}
			m_CurrentComplexSelector = null;
		}

		public StyleProperty BeginProperty(string name, int line = -1)
		{
			Log("Begin property named " + name);
			Debug.Assert(m_BuilderState == BuilderState.Rule);
			m_BuilderState = BuilderState.Property;
			m_CurrentProperty = new StyleProperty
			{
				name = name,
				line = line
			};
			m_CurrentProperties.Add(m_CurrentProperty);
			return m_CurrentProperty;
		}

		public void AddImport(StyleSheet.ImportStruct importStruct)
		{
			m_Imports.Add(importStruct);
		}

		public void AddValue(float value)
		{
			RegisterValue(m_Floats, StyleValueType.Float, value);
		}

		public void AddValue(Dimension value)
		{
			RegisterValue(m_Dimensions, StyleValueType.Dimension, value);
		}

		public void AddValue(StyleValueKeyword keyword)
		{
			m_CurrentValues.Add(new StyleValueHandle((int)keyword, StyleValueType.Keyword));
		}

		public void AddValue(StyleValueFunction function)
		{
			m_CurrentValues.Add(new StyleValueHandle((int)function, StyleValueType.Function));
		}

		public void AddCommaSeparator()
		{
			m_CurrentValues.Add(new StyleValueHandle(0, StyleValueType.CommaSeparator));
		}

		public void AddValue(string value, StyleValueType type)
		{
			if (type == StyleValueType.Variable)
			{
				RegisterVariable(value);
			}
			else
			{
				RegisterValue(m_Strings, type, value);
			}
		}

		public void AddValue(Color value)
		{
			RegisterValue(m_Colors, StyleValueType.Color, value);
		}

		public void AddValue(Object value)
		{
			RegisterValue(m_Assets, StyleValueType.AssetReference, value);
		}

		public void AddValue(ScalableImage value)
		{
			RegisterValue(m_ScalableImages, StyleValueType.ScalableImage, value);
		}

		public void EndProperty()
		{
			Log("Ending property");
			Debug.Assert(m_BuilderState == BuilderState.Property);
			m_BuilderState = BuilderState.Rule;
			m_CurrentProperty.values = m_CurrentValues.ToArray();
			m_CurrentProperty = null;
			m_CurrentValues.Clear();
		}

		public int EndRule()
		{
			Log("Ending rule");
			Debug.Assert(m_BuilderState == BuilderState.Rule);
			m_BuilderState = BuilderState.Init;
			m_CurrentRule.properties = m_CurrentProperties.ToArray();
			m_Rules.Add(m_CurrentRule);
			m_CurrentRule = null;
			m_CurrentProperties.Clear();
			return m_Rules.Count - 1;
		}

		public void BuildTo(StyleSheet writeTo)
		{
			Debug.Assert(m_BuilderState == BuilderState.Init);
			writeTo.floats = m_Floats.ToArray();
			writeTo.dimensions = m_Dimensions.ToArray();
			writeTo.colors = m_Colors.ToArray();
			writeTo.strings = m_Strings.ToArray();
			writeTo.rules = m_Rules.ToArray();
			writeTo.assets = m_Assets.ToArray();
			writeTo.scalableImages = m_ScalableImages.ToArray();
			writeTo.complexSelectors = m_ComplexSelectors.ToArray();
			writeTo.imports = m_Imports.ToArray();
			if (writeTo.imports.Length != 0)
			{
				writeTo.FlattenImportedStyleSheetsRecursive();
			}
		}

		private void RegisterVariable(string value)
		{
			Log("Add variable : " + value);
			Debug.Assert(m_BuilderState == BuilderState.Property);
			int num = m_Strings.IndexOf(value);
			if (num < 0)
			{
				m_Strings.Add(value);
				num = m_Strings.Count - 1;
			}
			m_CurrentValues.Add(new StyleValueHandle(num, StyleValueType.Variable));
		}

		private void RegisterValue<T>(List<T> list, StyleValueType type, T value)
		{
			string text = type.ToString();
			T val = value;
			Log("Add value of type " + text + " : " + val);
			Debug.Assert(m_BuilderState == BuilderState.Property);
			list.Add(value);
			m_CurrentValues.Add(new StyleValueHandle(list.Count - 1, type));
		}

		private static void Log(string msg)
		{
		}
	}
	internal static class StyleSheetCache
	{
		private struct SheetHandleKey
		{
			public readonly int sheetInstanceID;

			public readonly int index;

			public SheetHandleKey(StyleSheet sheet, int index)
			{
				sheetInstanceID = sheet.GetInstanceID();
				this.index = index;
			}
		}

		private class SheetHandleKeyComparer : IEqualityComparer<SheetHandleKey>
		{
			public bool Equals(SheetHandleKey x, SheetHandleKey y)
			{
				return x.sheetInstanceID == y.sheetInstanceID && x.index == y.index;
			}

			public int GetHashCode(SheetHandleKey key)
			{
				return key.sheetInstanceID.GetHashCode() ^ key.index.GetHashCode();
			}
		}

		private static SheetHandleKeyComparer s_Comparer = new SheetHandleKeyComparer();

		private static Dictionary<SheetHandleKey, StylePropertyId[]> s_RulePropertyIdsCache = new Dictionary<SheetHandleKey, StylePropertyId[]>(s_Comparer);

		internal static void ClearCaches()
		{
			s_RulePropertyIdsCache.Clear();
		}

		internal static StylePropertyId[] GetPropertyIds(StyleSheet sheet, int ruleIndex)
		{
			SheetHandleKey key = new SheetHandleKey(sheet, ruleIndex);
			if (!s_RulePropertyIdsCache.TryGetValue(key, out var value))
			{
				StyleRule styleRule = sheet.rules[ruleIndex];
				value = new StylePropertyId[styleRule.properties.Length];
				for (int i = 0; i < value.Length; i++)
				{
					value[i] = GetPropertyId(styleRule, i);
				}
				s_RulePropertyIdsCache.Add(key, value);
			}
			return value;
		}

		internal static StylePropertyId[] GetPropertyIds(StyleRule rule)
		{
			StylePropertyId[] array = new StylePropertyId[rule.properties.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = GetPropertyId(rule, i);
			}
			return array;
		}

		private static StylePropertyId GetPropertyId(StyleRule rule, int index)
		{
			StyleProperty styleProperty = rule.properties[index];
			string name = styleProperty.name;
			if (!StylePropertyUtil.s_NameToId.TryGetValue(name, out var value))
			{
				return styleProperty.isCustomProperty ? StylePropertyId.Custom : StylePropertyId.Unknown;
			}
			return value;
		}
	}
	internal static class StyleSheetColor
	{
		private static Dictionary<string, Color32> s_NameToColor = new Dictionary<string, Color32>
		{
			{
				"aliceblue",
				HexToColor32(15792383u)
			},
			{
				"antiquewhite",
				HexToColor32(16444375u)
			},
			{
				"aqua",
				HexToColor32(65535u)
			},
			{
				"aquamarine",
				HexToColor32(8388564u)
			},
			{
				"azure",
				HexToColor32(15794175u)
			},
			{
				"beige",
				HexToColor32(16119260u)
			},
			{
				"bisque",
				HexToColor32(16770244u)
			},
			{
				"black",
				HexToColor32(0u)
			},
			{
				"blanchedalmond",
				HexToColor32(16772045u)
			},
			{
				"blue",
				HexToColor32(255u)
			},
			{
				"blueviolet",
				HexToColor32(9055202u)
			},
			{
				"brown",
				HexToColor32(10824234u)
			},
			{
				"burlywood",
				HexToColor32(14596231u)
			},
			{
				"cadetblue",
				HexToColor32(6266528u)
			},
			{
				"chartreuse",
				HexToColor32(8388352u)
			},
			{
				"chocolate",
				HexToColor32(13789470u)
			},
			{
				"coral",
				HexToColor32(16744272u)
			},
			{
				"cornflowerblue",
				HexToColor32(6591981u)
			},
			{
				"cornsilk",
				HexToColor32(16775388u)
			},
			{
				"crimson",
				HexToColor32(14423100u)
			},
			{
				"cyan",
				HexToColor32(65535u)
			},
			{
				"darkblue",
				HexToColor32(139u)
			},
			{
				"darkcyan",
				HexToColor32(35723u)
			},
			{
				"darkgoldenrod",
				HexToColor32(12092939u)
			},
			{
				"darkgray",
				HexToColor32(11119017u)
			},
			{
				"darkgreen",
				HexToColor32(25600u)
			},
			{
				"darkgrey",
				HexToColor32(11119017u)
			},
			{
				"darkkhaki",
				HexToColor32(12433259u)
			},
			{
				"darkmagenta",
				HexToColor32(9109643u)
			},
			{
				"darkolivegreen",
				HexToColor32(5597999u)
			},
			{
				"darkorange",
				HexToColor32(16747520u)
			},
			{
				"darkorchid",
				HexToColor32(10040012u)
			},
			{
				"darkred",
				HexToColor32(9109504u)
			},
			{
				"darksalmon",
				HexToColor32(15308410u)
			},
			{
				"darkseagreen",
				HexToColor32(9419919u)
			},
			{
				"darkslateblue",
				HexToColor32(4734347u)
			},
			{
				"darkslategray",
				HexToColor32(3100495u)
			},
			{
				"darkslategrey",
				HexToColor32(3100495u)
			},
			{
				"darkturquoise",
				HexToColor32(52945u)
			},
			{
				"darkviolet",
				HexToColor32(9699539u)
			},
			{
				"deeppink",
				HexToColor32(16716947u)
			},
			{
				"deepskyblue",
				HexToColor32(49151u)
			},
			{
				"dimgray",
				HexToColor32(6908265u)
			},
			{
				"dimgrey",
				HexToColor32(6908265u)
			},
			{
				"dodgerblue",
				HexToColor32(2003199u)
			},
			{
				"firebrick",
				HexToColor32(11674146u)
			},
			{
				"floralwhite",
				HexToColor32(16775920u)
			},
			{
				"forestgreen",
				HexToColor32(2263842u)
			},
			{
				"fuchsia",
				HexToColor32(16711935u)
			},
			{
				"gainsboro",
				HexToColor32(14474460u)
			},
			{
				"ghostwhite",
				HexToColor32(16316671u)
			},
			{
				"goldenrod",
				HexToColor32(14329120u)
			},
			{
				"gold",
				HexToColor32(16766720u)
			},
			{
				"gray",
				HexToColor32(8421504u)
			},
			{
				"green",
				HexToColor32(32768u)
			},
			{
				"greenyellow",
				HexToColor32(11403055u)
			},
			{
				"grey",
				HexToColor32(8421504u)
			},
			{
				"honeydew",
				HexToColor32(15794160u)
			},
			{
				"hotpink",
				HexToColor32(16738740u)
			},
			{
				"indianred",
				HexToColor32(13458524u)
			},
			{
				"indigo",
				HexToColor32(4915330u)
			},
			{
				"ivory",
				HexToColor32(16777200u)
			},
			{
				"khaki",
				HexToColor32(15787660u)
			},
			{
				"lavenderblush",
				HexToColor32(16773365u)
			},
			{
				"lavender",
				HexToColor32(15132410u)
			},
			{
				"lawngreen",
				HexToColor32(8190976u)
			},
			{
				"lemonchiffon",
				HexToColor32(16775885u)
			},
			{
				"lightblue",
				HexToColor32(11393254u)
			},
			{
				"lightcoral",
				HexToColor32(15761536u)
			},
			{
				"lightcyan",
				HexToColor32(14745599u)
			},
			{
				"lightgoldenrodyellow",
				HexToColor32(16448210u)
			},
			{
				"lightgray",
				HexToColor32(13882323u)
			},
			{
				"lightgreen",
				HexToColor32(9498256u)
			},
			{
				"lightgrey",
				HexToColor32(13882323u)
			},
			{
				"lightpink",
				HexToColor32(16758465u)
			},
			{
				"lightsalmon",
				HexToColor32(16752762u)
			},
			{
				"lightseagreen",
				HexToColor32(2142890u)
			},
			{
				"lightskyblue",
				HexToColor32(8900346u)
			},
			{
				"lightslategray",
				HexToColor32(7833753u)
			},
			{
				"lightslategrey",
				HexToColor32(7833753u)
			},
			{
				"lightsteelblue",
				HexToColor32(11584734u)
			},
			{
				"lightyellow",
				HexToColor32(16777184u)
			},
			{
				"lime",
				HexToColor32(65280u)
			},
			{
				"limegreen",
				HexToColor32(3329330u)
			},
			{
				"linen",
				HexToColor32(16445670u)
			},
			{
				"magenta",
				HexToColor32(16711935u)
			},
			{
				"maroon",
				HexToColor32(8388608u)
			},
			{
				"mediumaquamarine",
				HexToColor32(6737322u)
			},
			{
				"mediumblue",
				HexToColor32(205u)
			},
			{
				"mediumorchid",
				HexToColor32(12211667u)
			},
			{
				"mediumpurple",
				HexToColor32(9662683u)
			},
			{
				"mediumseagreen",
				HexToColor32(3978097u)
			},
			{
				"mediumslateblue",
				HexToColor32(8087790u)
			},
			{
				"mediumspringgreen",
				HexToColor32(64154u)
			},
			{
				"mediumturquoise",
				HexToColor32(4772300u)
			},
			{
				"mediumvioletred",
				HexToColor32(13047173u)
			},
			{
				"midnightblue",
				HexToColor32(1644912u)
			},
			{
				"mintcream",
				HexToColor32(16121850u)
			},
			{
				"mistyrose",
				HexToColor32(16770273u)
			},
			{
				"moccasin",
				HexToColor32(16770229u)
			},
			{
				"navajowhite",
				HexToColor32(16768685u)
			},
			{
				"navy",
				HexToColor32(128u)
			},
			{
				"oldlace",
				HexToColor32(16643558u)
			},
			{
				"olive",
				HexToColor32(8421376u)
			},
			{
				"olivedrab",
				HexToColor32(7048739u)
			},
			{
				"orange",
				HexToColor32(16753920u)
			},
			{
				"orangered",
				HexToColor32(16729344u)
			},
			{
				"orchid",
				HexToColor32(14315734u)
			},
			{
				"palegoldenrod",
				HexToColor32(15657130u)
			},
			{
				"palegreen",
				HexToColor32(10025880u)
			},
			{
				"paleturquoise",
				HexToColor32(11529966u)
			},
			{
				"palevioletred",
				HexToColor32(14381203u)
			},
			{
				"papayawhip",
				HexToColor32(16773077u)
			},
			{
				"peachpuff",
				HexToColor32(16767673u)
			},
			{
				"peru",
				HexToColor32(13468991u)
			},
			{
				"pink",
				HexToColor32(16761035u)
			},
			{
				"plum",
				HexToColor32(14524637u)
			},
			{
				"powderblue",
				HexToColor32(11591910u)
			},
			{
				"purple",
				HexToColor32(8388736u)
			},
			{
				"rebeccapurple",
				HexToColor32(6697881u)
			},
			{
				"red",
				HexToColor32(16711680u)
			},
			{
				"rosybrown",
				HexToColor32(12357519u)
			},
			{
				"royalblue",
				HexToColor32(4286945u)
			},
			{
				"saddlebrown",
				HexToColor32(9127187u)
			},
			{
				"salmon",
				HexToColor32(16416882u)
			},
			{
				"sandybrown",
				HexToColor32(16032864u)
			},
			{
				"seagreen",
				HexToColor32(3050327u)
			},
			{
				"seashell",
				HexToColor32(16774638u)
			},
			{
				"sienna",
				HexToColor32(10506797u)
			},
			{
				"silver",
				HexToColor32(12632256u)
			},
			{
				"skyblue",
				HexToColor32(8900331u)
			},
			{
				"slateblue",
				HexToColor32(6970061u)
			},
			{
				"slategray",
				HexToColor32(7372944u)
			},
			{
				"slategrey",
				HexToColor32(7372944u)
			},
			{
				"snow",
				HexToColor32(16775930u)
			},
			{
				"springgreen",
				HexToColor32(65407u)
			},
			{
				"steelblue",
				HexToColor32(4620980u)
			},
			{
				"tan",
				HexToColor32(13808780u)
			},
			{
				"teal",
				HexToColor32(32896u)
			},
			{
				"thistle",
				HexToColor32(14204888u)
			},
			{
				"tomato",
				HexToColor32(16737095u)
			},
			{
				"transparent",
				new Color32(0, 0, 0, 0)
			},
			{
				"turquoise",
				HexToColor32(4251856u)
			},
			{
				"violet",
				HexToColor32(15631086u)
			},
			{
				"wheat",
				HexToColor32(16113331u)
			},
			{
				"white",
				HexToColor32(16777215u)
			},
			{
				"whitesmoke",
				HexToColor32(16119285u)
			},
			{
				"yellow",
				HexToColor32(16776960u)
			},
			{
				"yellowgreen",
				HexToColor32(10145074u)
			}
		};

		public static bool TryGetColor(string name, out Color color)
		{
			Color32 value;
			bool result = s_NameToColor.TryGetValue(name, out value);
			color = value;
			return result;
		}

		private static Color32 HexToColor32(uint color)
		{
			byte b = (byte)(color & 0xFF);
			byte g = (byte)((color >> 8) & 0xFF);
			byte r = (byte)((color >> 16) & 0xFF);
			return new Color32(r, g, b, byte.MaxValue);
		}
	}
	internal static class StyleSheetExtensions
	{
		public static string ReadAsString(this StyleSheet sheet, StyleValueHandle handle)
		{
			string empty = string.Empty;
			return handle.valueType switch
			{
				StyleValueType.Float => sheet.ReadFloat(handle).ToString(CultureInfo.InvariantCulture.NumberFormat), 
				StyleValueType.Dimension => sheet.ReadDimension(handle).ToString(), 
				StyleValueType.Color => sheet.ReadColor(handle).ToString(), 
				StyleValueType.ResourcePath => sheet.ReadResourcePath(handle), 
				StyleValueType.String => sheet.ReadString(handle), 
				StyleValueType.Enum => sheet.ReadEnum(handle), 
				StyleValueType.Variable => sheet.ReadVariable(handle), 
				StyleValueType.Keyword => sheet.ReadKeyword(handle).ToUssString(), 
				StyleValueType.AssetReference => sheet.ReadAssetReference(handle).ToString(), 
				StyleValueType.Function => sheet.ReadFunctionName(handle), 
				StyleValueType.CommaSeparator => ",", 
				StyleValueType.ScalableImage => sheet.ReadScalableImage(handle).ToString(), 
				_ => "Error reading value type (" + handle.valueType.ToString() + ") at index " + handle.valueIndex, 
			};
		}

		public static bool IsVarFunction(this StyleValueHandle handle)
		{
			return handle.valueType == StyleValueType.Function && handle.valueIndex == 1;
		}
	}
	[StructLayout(LayoutKind.Explicit)]
	[DebuggerDisplay("id = {id}, keyword = {keyword}, number = {number}, boolean = {boolean}, color = {color}, object = {resource}")]
	internal struct StyleValue
	{
		[FieldOffset(0)]
		public StylePropertyId id;

		[FieldOffset(4)]
		public StyleKeyword keyword;

		[FieldOffset(8)]
		public float number;

		[FieldOffset(8)]
		public Length length;

		[FieldOffset(8)]
		public Color color;

		[FieldOffset(8)]
		public GCHandle resource;

		[FieldOffset(8)]
		public BackgroundPosition position;

		[FieldOffset(8)]
		public BackgroundRepeat repeat;
	}
	internal struct StyleValueManaged
	{
		public StylePropertyId id;

		public StyleKeyword keyword;

		public object value;
	}
	internal enum MatchResultErrorCode
	{
		None,
		Syntax,
		EmptyValue,
		ExpectedEndOfValue
	}
	internal struct MatchResult
	{
		public MatchResultErrorCode errorCode;

		public string errorValue;

		public bool success => errorCode == MatchResultErrorCode.None;
	}
	internal abstract class BaseStyleMatcher
	{
		private struct MatchContext
		{
			public int valueIndex;

			public int matchedVariableCount;
		}

		protected static readonly Regex s_CustomIdentRegex = new Regex("^-?[_a-z][_a-z0-9-]*", RegexOptions.IgnoreCase | RegexOptions.Compiled);

		private Stack<MatchContext> m_ContextStack = new Stack<MatchContext>();

		private MatchContext m_CurrentContext;

		public abstract int valueCount { get; }

		public abstract bool isCurrentVariable { get; }

		public abstract bool isCurrentComma { get; }

		public bool hasCurrent => m_CurrentContext.valueIndex < valueCount;

		public int currentIndex
		{
			get
			{
				return m_CurrentContext.valueIndex;
			}
			set
			{
				m_CurrentContext.valueIndex = value;
			}
		}

		public int matchedVariableCount
		{
			get
			{
				return m_CurrentContext.matchedVariableCount;
			}
			set
			{
				m_CurrentContext.matchedVariableCount = value;
			}
		}

		protected abstract bool MatchKeyword(string keyword);

		protected abstract bool MatchNumber();

		protected abstract bool MatchInteger();

		protected abstract bool MatchLength();

		protected abstract bool MatchPercentage();

		protected abstract bool MatchColor();

		protected abstract bool MatchResource();

		protected abstract bool MatchUrl();

		protected abstract bool MatchTime();

		protected abstract bool MatchAngle();

		protected abstract bool MatchCustomIdent();

		protected void Initialize()
		{
			m_CurrentContext = default(MatchContext);
			m_ContextStack.Clear();
		}

		public void MoveNext()
		{
			if (currentIndex + 1 <= valueCount)
			{
				currentIndex++;
			}
		}

		public void SaveContext()
		{
			m_ContextStack.Push(m_CurrentContext);
		}

		public void RestoreContext()
		{
			m_CurrentContext = m_ContextStack.Pop();
		}

		public void DropContext()
		{
			m_ContextStack.Pop();
		}

		protected bool Match(Expression exp)
		{
			bool flag = true;
			if (exp.multiplier.type == ExpressionMultiplierType.None)
			{
				return MatchExpression(exp);
			}
			Debug.Assert(exp.multiplier.type != ExpressionMultiplierType.GroupAtLeastOne, "'!' multiplier in syntax expression is not supported");
			return MatchExpressionWithMultiplier(exp);
		}

		private bool MatchExpression(Expression exp)
		{
			bool flag = false;
			if (exp.type == ExpressionType.Combinator)
			{
				flag = MatchCombinator(exp);
			}
			else
			{
				if (isCurrentVariable)
				{
					flag = true;
					matchedVariableCount++;
				}
				else if (exp.type == ExpressionType.Data)
				{
					flag = MatchDataType(exp);
				}
				else if (exp.type == ExpressionType.Keyword)
				{
					flag = MatchKeyword(exp.keyword);
				}
				if (flag)
				{
					MoveNext();
				}
			}
			if (!flag && !hasCurrent && matchedVariableCount > 0)
			{
				flag = true;
			}
			return flag;
		}

		private bool MatchExpressionWithMultiplier(Expression exp)
		{
			bool flag = exp.multiplier.type == ExpressionMultiplierType.OneOrMoreComma;
			bool flag2 = true;
			int min = exp.multiplier.min;
			int max = exp.multiplier.max;
			int num = 0;
			int num2 = 0;
			while (flag2 && hasCurrent && num2 < max)
			{
				flag2 = MatchExpression(exp);
				if (flag2)
				{
					num++;
					if (flag)
					{
						if (!isCurrentComma)
						{
							break;
						}
						MoveNext();
					}
				}
				num2++;
			}
			flag2 = num >= min && num <= max;
			if (!flag2 && num <= max && matchedVariableCount > 0)
			{
				flag2 = true;
			}
			return flag2;
		}

		private bool MatchGroup(Expression exp)
		{
			Debug.Assert(exp.subExpressions.Length == 1, "Group has invalid number of sub expressions");
			Expression exp2 = exp.subExpressions[0];
			return Match(exp2);
		}

		private bool MatchCombinator(Expression exp)
		{
			SaveContext();
			bool flag = false;
			switch (exp.combinator)
			{
			case ExpressionCombinator.Or:
				flag = MatchOr(exp);
				break;
			case ExpressionCombinator.OrOr:
				flag = MatchOrOr(exp);
				break;
			case ExpressionCombinator.AndAnd:
				flag = MatchAndAnd(exp);
				break;
			case ExpressionCombinator.Juxtaposition:
				flag = MatchJuxtaposition(exp);
				break;
			case ExpressionCombinator.Group:
				flag = MatchGroup(exp);
				break;
			}
			if (flag)
			{
				DropContext();
			}
			else
			{
				RestoreContext();
			}
			return flag;
		}

		private bool MatchOr(Expression exp)
		{
			MatchContext currentContext = default(MatchContext);
			int num = 0;
			for (int i = 0; i < exp.subExpressions.Length; i++)
			{
				SaveContext();
				int num2 = currentIndex;
				bool flag = Match(exp.subExpressions[i]);
				int num3 = currentIndex - num2;
				if (flag && num3 > num)
				{
					num = num3;
					currentContext = m_CurrentContext;
				}
				RestoreContext();
			}
			if (num > 0)
			{
				m_CurrentContext = currentContext;
				return true;
			}
			return false;
		}

		private bool MatchOrOr(Expression exp)
		{
			int num = MatchMany(exp);
			return num > 0;
		}

		private bool MatchAndAnd(Expression exp)
		{
			int num = MatchMany(exp);
			int num2 = exp.subExpressions.Length;
			return num == num2;
		}

		private unsafe int MatchMany(Expression exp)
		{
			MatchContext currentContext = default(MatchContext);
			int num = 0;
			int num2 = -1;
			int num3 = exp.subExpressions.Length;
			int* ptr = stackalloc int[num3];
			do
			{
				SaveContext();
				num2++;
				for (int i = 0; i < num3; i++)
				{
					int num4 = ((num2 > 0) ? ((num2 + i) % num3) : i);
					ptr[i] = num4;
				}
				int num5 = MatchManyByOrder(exp, ptr);
				if (num5 > num)
				{
					num = num5;
					currentContext = m_CurrentContext;
				}
				RestoreContext();
			}
			while (num < num3 && num2 < num3);
			if (num > 0)
			{
				m_CurrentContext = currentContext;
			}
			return num;
		}

		private unsafe int MatchManyByOrder(Expression exp, int* matchOrder)
		{
			int num = exp.subExpressions.Length;
			int* ptr = stackalloc int[num];
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			while (num4 < num && num2 + num3 < num)
			{
				int num5 = matchOrder[num4];
				bool flag = false;
				for (int i = 0; i < num2; i++)
				{
					if (ptr[i] == num5)
					{
						flag = true;
						break;
					}
				}
				bool flag2 = false;
				if (!flag)
				{
					flag2 = Match(exp.subExpressions[num5]);
				}
				if (flag2)
				{
					if (num3 == matchedVariableCount)
					{
						ptr[num2] = num5;
						num2++;
					}
					else
					{
						num3 = matchedVariableCount;
					}
					num4 = 0;
				}
				else
				{
					num4++;
				}
			}
			return num2 + num3;
		}

		private bool MatchJuxtaposition(Expression exp)
		{
			bool flag = true;
			int num = 0;
			while (flag && num < exp.subExpressions.Length)
			{
				flag = Match(exp.subExpressions[num]);
				num++;
			}
			return flag;
		}

		private bool MatchDataType(Expression exp)
		{
			bool result = false;
			if (hasCurrent)
			{
				switch (exp.dataType)
				{
				case DataType.Number:
					result = MatchNumber();
					break;
				case DataType.Integer:
					result = MatchInteger();
					break;
				case DataType.Length:
					result = MatchLength();
					break;
				case DataType.Percentage:
					result = MatchPercentage();
					break;
				case DataType.Color:
					result = MatchColor();
					break;
				case DataType.Resource:
					result = MatchResource();
					break;
				case DataType.Url:
					result = MatchUrl();
					break;
				case DataType.Time:
					result = MatchTime();
					break;
				case DataType.Angle:
					result = MatchAngle();
					break;
				case DataType.CustomIdent:
					result = MatchCustomIdent();
					break;
				}
			}
			return result;
		}
	}
	internal class StyleMatcher : BaseStyleMatcher
	{
		private StylePropertyValueParser m_Parser = new StylePropertyValueParser();

		private string[] m_PropertyParts;

		private static readonly Regex s_NumberRegex = new Regex("^[+-]?\\d+(?:\\.\\d+)?$", RegexOptions.Compiled);

		private static readonly Regex s_IntegerRegex = new Regex("^[+-]?\\d+$", RegexOptions.Compiled);

		private static readonly Regex s_ZeroRegex = new Regex("^0(?:\\.0+)?$", RegexOptions.Compiled);

		private static readonly Regex s_LengthRegex = new Regex("^[+-]?\\d+(?:\\.\\d+)?(?:px)$", RegexOptions.Compiled);

		private static readonly Regex s_PercentRegex = new Regex("^[+-]?\\d+(?:\\.\\d+)?(?:%)$", RegexOptions.Compiled);

		private static readonly Regex s_HexColorRegex = new Regex("^#[a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?$", RegexOptions.Compiled);

		private static readonly Regex s_RgbRegex = new Regex("^rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$", RegexOptions.Compiled);

		private static readonly Regex s_RgbaRegex = new Regex("rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([\\d.]+)\\s*\\)$", RegexOptions.Compiled);

		private static readonly Regex s_VarFunctionRegex = new Regex("^var\\(.+\\)$", RegexOptions.Compiled);

		private static readonly Regex s_ResourceRegex = new Regex("^resource\\((.+)\\)$", RegexOptions.Compiled);

		private static readonly Regex s_UrlRegex = new Regex("^url\\((.+)\\)$", RegexOptions.Compiled);

		private static readonly Regex s_TimeRegex = new Regex("^[+-]?\\.?\\d+(?:\\.\\d+)?(?:s|ms)$", RegexOptions.Compiled);

		private static readonly Regex s_AngleRegex = new Regex("^[+-]?\\d+(?:\\.\\d+)?(?:deg|grad|rad|turn)$", RegexOptions.Compiled);

		private string current => base.hasCurrent ? m_PropertyParts[base.currentIndex] : null;

		public override int valueCount => m_PropertyParts.Length;

		public override bool isCurrentVariable => base.hasCurrent && current.StartsWith("var(");

		public override bool isCurrentComma => base.hasCurrent && current == ",";

		private void Initialize(string propertyValue)
		{
			Initialize();
			m_PropertyParts = m_Parser.Parse(propertyValue);
		}

		public MatchResult Match(Expression exp, string propertyValue)
		{
			MatchResult result = new MatchResult
			{
				errorCode = MatchResultErrorCode.None
			};
			if (string.IsNullOrEmpty(propertyValue))
			{
				result.errorCode = MatchResultErrorCode.EmptyValue;
				return result;
			}
			bool flag = false;
			Initialize(propertyValue);
			string text = current;
			if (text == "initial" || text.StartsWith("env("))
			{
				MoveNext();
				flag = true;
			}
			else
			{
				flag = Match(exp);
			}
			if (!flag)
			{
				result.errorCode = MatchResultErrorCode.Syntax;
				result.errorValue = current;
			}
			else if (base.hasCurrent)
			{
				result.errorCode = MatchResultErrorCode.ExpectedEndOfValue;
				result.errorValue = current;
			}
			return result;
		}

		protected override bool MatchKeyword(string keyword)
		{
			return string.Compare(current, keyword, StringComparison.OrdinalIgnoreCase) == 0;
		}

		protected override bool MatchNumber()
		{
			string input = current;
			Match match = s_NumberRegex.Match(input);
			return match.Success;
		}

		protected override bool MatchInteger()
		{
			string input = current;
			Match match = s_IntegerRegex.Match(input);
			return match.Success;
		}

		protected override bool MatchLength()
		{
			string input = current;
			Match match = s_LengthRegex.Match(input);
			if (match.Success)
			{
				return true;
			}
			match = s_ZeroRegex.Match(input);
			return match.Success;
		}

		protected override bool MatchPercentage()
		{
			string input = current;
			Match match = s_PercentRegex.Match(input);
			if (match.Success)
			{
				return true;
			}
			match = s_ZeroRegex.Match(input);
			return match.Success;
		}

		protected override bool MatchColor()
		{
			string text = current;
			Match match = s_HexColorRegex.Match(text);
			if (match.Success)
			{
				return true;
			}
			match = s_RgbRegex.Match(text);
			if (match.Success)
			{
				return true;
			}
			match = s_RgbaRegex.Match(text);
			if (match.Success)
			{
				return true;
			}
			Color color = Color.clear;
			if (StyleSheetColor.TryGetColor(text, out color))
			{
				return true;
			}
			return false;
		}

		protected override bool MatchResource()
		{
			string input = current;
			Match match = s_ResourceRegex.Match(input);
			if (!match.Success)
			{
				return false;
			}
			string input2 = match.Groups[1].Value.Trim();
			match = s_VarFunctionRegex.Match(input2);
			return !match.Success;
		}

		protected override bool MatchUrl()
		{
			string input = current;
			Match match = s_UrlRegex.Match(input);
			if (!match.Success)
			{
				return false;
			}
			string input2 = match.Groups[1].Value.Trim();
			match = s_VarFunctionRegex.Match(input2);
			return !match.Success;
		}

		protected override bool MatchTime()
		{
			string input = current;
			Match match = s_TimeRegex.Match(input);
			return match.Success;
		}

		protected override bool MatchAngle()
		{
			string input = current;
			Match match = s_AngleRegex.Match(input);
			if (match.Success)
			{
				return true;
			}
			match = s_ZeroRegex.Match(input);
			return match.Success;
		}

		protected override bool MatchCustomIdent()
		{
			string text = current;
			Match match = BaseStyleMatcher.s_CustomIdentRegex.Match(text);
			return match.Success && match.Length == text.Length;
		}
	}
	internal class StylePropertyValueMatcher : BaseStyleMatcher
	{
		private List<StylePropertyValue> m_Values;

		private StylePropertyValue current => base.hasCurrent ? m_Values[base.currentIndex] : default(StylePropertyValue);

		public override int valueCount => m_Values.Count;

		public override bool isCurrentVariable => false;

		public override bool isCurrentComma => base.hasCurrent && m_Values[base.currentIndex].handle.valueType == StyleValueType.CommaSeparator;

		public MatchResult Match(Expression exp, List<StylePropertyValue> values)
		{
			MatchResult result = new MatchResult
			{
				errorCode = MatchResultErrorCode.None
			};
			if (values == null || values.Count == 0)
			{
				result.errorCode = MatchResultErrorCode.EmptyValue;
				return result;
			}
			Initialize();
			m_Values = values;
			bool flag = false;
			StyleValueHandle handle = m_Values[0].handle;
			if (handle.valueType == StyleValueType.Keyword && handle.valueIndex == 1)
			{
				MoveNext();
				flag = true;
			}
			else
			{
				flag = Match(exp);
			}
			if (!flag)
			{
				StyleSheet sheet = current.sheet;
				result.errorCode = MatchResultErrorCode.Syntax;
				result.errorValue = sheet.ReadAsString(current.handle);
			}
			else if (base.hasCurrent)
			{
				StyleSheet sheet2 = current.sheet;
				result.errorCode = MatchResultErrorCode.ExpectedEndOfValue;
				result.errorValue = sheet2.ReadAsString(current.handle);
			}
			return result;
		}

		protected override bool MatchKeyword(string keyword)
		{
			StylePropertyValue stylePropertyValue = current;
			if (stylePropertyValue.handle.valueType == StyleValueType.Keyword)
			{
				StyleValueKeyword valueIndex = (StyleValueKeyword)stylePropertyValue.handle.valueIndex;
				return valueIndex.ToUssString() == keyword.ToLowerInvariant();
			}
			if (stylePropertyValue.handle.valueType == StyleValueType.Enum)
			{
				string text = stylePropertyValue.sheet.ReadEnum(stylePropertyValue.handle);
				return text == keyword.ToLowerInvariant();
			}
			return false;
		}

		protected override bool MatchNumber()
		{
			return current.handle.valueType == StyleValueType.Float;
		}

		protected override bool MatchInteger()
		{
			return current.handle.valueType == StyleValueType.Float;
		}

		protected override bool MatchLength()
		{
			StylePropertyValue stylePropertyValue = current;
			if (stylePropertyValue.handle.valueType == StyleValueType.Dimension)
			{
				return stylePropertyValue.sheet.ReadDimension(stylePropertyValue.handle).unit == Dimension.Unit.Pixel;
			}
			if (stylePropertyValue.handle.valueType == StyleValueType.Float)
			{
				float b = stylePropertyValue.sheet.ReadFloat(stylePropertyValue.handle);
				return Mathf.Approximately(0f, b);
			}
			return false;
		}

		protected override bool MatchPercentage()
		{
			StylePropertyValue stylePropertyValue = current;
			if (stylePropertyValue.handle.valueType == StyleValueType.Dimension)
			{
				return stylePropertyValue.sheet.ReadDimension(stylePropertyValue.handle).unit == Dimension.Unit.Percent;
			}
			if (stylePropertyValue.handle.valueType == StyleValueType.Float)
			{
				float b = stylePropertyValue.sheet.ReadFloat(stylePropertyValue.handle);
				return Mathf.Approximately(0f, b);
			}
			return false;
		}

		protected override bool MatchColor()
		{
			StylePropertyValue stylePropertyValue = current;
			if (stylePropertyValue.handle.valueType == StyleValueType.Color)
			{
				return true;
			}
			if (stylePropertyValue.handle.valueType == StyleValueType.Enum)
			{
				Color color = Color.clear;
				string text = stylePropertyValue.sheet.ReadAsString(stylePropertyValue.handle);
				if (StyleSheetColor.TryGetColor(text.ToLowerInvariant(), out color))
				{
					return true;
				}
			}
			return false;
		}

		protected override bool MatchResource()
		{
			return current.handle.valueType == StyleValueType.ResourcePath;
		}

		protected override bool MatchUrl()
		{
			StyleValueType valueType = current.handle.valueType;
			return valueType == StyleValueType.AssetReference || valueType == StyleValueType.ScalableImage;
		}

		protected override bool MatchTime()
		{
			StylePropertyValue stylePropertyValue = current;
			if (stylePropertyValue.handle.valueType == StyleValueType.Dimension)
			{
				Dimension dimension = stylePropertyValue.sheet.ReadDimension(stylePropertyValue.handle);
				return dimension.unit == Dimension.Unit.Second || dimension.unit == Dimension.Unit.Millisecond;
			}
			return false;
		}

		protected override bool MatchCustomIdent()
		{
			StylePropertyValue stylePropertyValue = current;
			if (stylePropertyValue.handle.valueType == StyleValueType.Enum)
			{
				string text = stylePropertyValue.sheet.ReadAsString(stylePropertyValue.handle);
				Match match = BaseStyleMatcher.s_CustomIdentRegex.Match(text);
				return match.Success && match.Length == text.Length;
			}
			return false;
		}

		protected override bool MatchAngle()
		{
			StylePropertyValue stylePropertyValue = current;
			if (stylePropertyValue.handle.valueType == StyleValueType.Dimension)
			{
				Dimension.Unit unit = stylePropertyValue.sheet.ReadDimension(stylePropertyValue.handle).unit;
				Dimension.Unit unit2 = unit;
				if ((uint)(unit2 - 5) <= 3u)
				{
					return true;
				}
			}
			if (stylePropertyValue.handle.valueType == StyleValueType.Float)
			{
				float b = stylePropertyValue.sheet.ReadFloat(stylePropertyValue.handle);
				return Mathf.Approximately(0f, b);
			}
			return false;
		}
	}
	internal class StylePropertyValueParser
	{
		private string m_PropertyValue;

		private List<string> m_ValueList = new List<string>();

		private StringBuilder m_StringBuilder = new StringBuilder();

		private int m_ParseIndex = 0;

		public string[] Parse(string propertyValue)
		{
			m_PropertyValue = propertyValue;
			m_ValueList.Clear();
			m_StringBuilder.Remove(0, m_StringBuilder.Length);
			for (m_ParseIndex = 0; m_ParseIndex < m_PropertyValue.Length; m_ParseIndex++)
			{
				char c = m_PropertyValue[m_ParseIndex];
				switch (c)
				{
				case ' ':
					EatSpace();
					AddValuePart();
					break;
				case ',':
					EatSpace();
					AddValuePart();
					m_ValueList.Add(",");
					break;
				case '(':
					AppendFunction();
					break;
				default:
					m_StringBuilder.Append(c);
					break;
				}
			}
			string text = m_StringBuilder.ToString();
			if (!string.IsNullOrEmpty(text))
			{
				m_ValueList.Add(text);
			}
			return m_ValueList.ToArray();
		}

		private void AddValuePart()
		{
			string item = m_StringBuilder.ToString();
			m_StringBuilder.Remove(0, m_StringBuilder.Length);
			m_ValueList.Add(item);
		}

		private void AppendFunction()
		{
			while (m_ParseIndex < m_PropertyValue.Length && m_PropertyValue[m_ParseIndex] != ')')
			{
				m_StringBuilder.Append(m_PropertyValue[m_ParseIndex]);
				m_ParseIndex++;
			}
			m_StringBuilder.Append(m_PropertyValue[m_ParseIndex]);
		}

		private void EatSpace()
		{
			while (m_ParseIndex + 1 < m_PropertyValue.Length && m_PropertyValue[m_ParseIndex + 1] == ' ')
			{
				m_ParseIndex++;
			}
		}
	}
	internal enum StyleValidationStatus
	{
		Ok,
		Error,
		Warning
	}
	internal struct StyleValidationResult
	{
		public StyleValidationStatus status;

		public string message;

		public string errorValue;

		public string hint;

		public bool success => status == StyleValidationStatus.Ok;
	}
	internal class StyleValidator
	{
		private StyleSyntaxParser m_SyntaxParser;

		private StyleMatcher m_StyleMatcher;

		public StyleValidator()
		{
			m_SyntaxParser = new StyleSyntaxParser();
			m_StyleMatcher = new StyleMatcher();
		}

		public StyleValidationResult ValidateProperty(string name, string value)
		{
			StyleValidationResult result = new StyleValidationResult
			{
				status = StyleValidationStatus.Ok
			};
			if (name.StartsWith("--"))
			{
				return result;
			}
			if (!StylePropertyCache.TryGetSyntax(name, out var syntax))
			{
				string text = StylePropertyCache.FindClosestPropertyName(name);
				result.status = StyleValidationStatus.Error;
				result.message = "Unknown property '" + name + "'";
				if (!string.IsNullOrEmpty(text))
				{
					result.message = result.message + " (did you mean '" + text + "'?)";
				}
				return result;
			}
			Expression expression = m_SyntaxParser.Parse(syntax);
			if (expression == null)
			{
				result.status = StyleValidationStatus.Error;
				result.message = "Invalid '" + name + "' property syntax '" + syntax + "'";
				return result;
			}
			MatchResult matchResult = m_StyleMatcher.Match(expression, value);
			if (!matchResult.success)
			{
				result.errorValue = matchResult.errorValue;
				switch (matchResult.errorCode)
				{
				case MatchResultErrorCode.Syntax:
				{
					result.status = StyleValidationStatus.Error;
					if (IsUnitMissing(syntax, value, out var unitHint))
					{
						result.hint = "Property expects a unit. Did you forget to add " + unitHint + "?";
					}
					else if (IsUnsupportedColor(syntax))
					{
						result.hint = "Unsupported color '" + value + "'.";
					}
					result.message = "Expected (" + syntax + ") but found '" + matchResult.errorValue + "'";
					break;
				}
				case MatchResultErrorCode.EmptyValue:
					result.status = StyleValidationStatus.Error;
					result.message = "Expected (" + syntax + ") but found empty value";
					break;
				case MatchResultErrorCode.ExpectedEndOfValue:
					result.status = StyleValidationStatus.Warning;
					result.message = "Expected end of value but found '" + matchResult.errorValue + "'";
					break;
				default:
					Debug.LogAssertion($"Unexpected error code '{matchResult.errorCode}'");
					break;
				}
			}
			return result;
		}

		private bool IsUnitMissing(string propertySyntax, string propertyValue, out string unitHint)
		{
			unitHint = null;
			if (!float.TryParse(propertyValue, out var _))
			{
				return false;
			}
			if (propertySyntax.Contains("<length>") || propertySyntax.Contains("<length-percentage>"))
			{
				unitHint = "px or %";
			}
			else if (propertySyntax.Contains("<time>"))
			{
				unitHint = "s or ms";
			}
			return !string.IsNullOrEmpty(unitHint);
		}

		private bool IsUnsupportedColor(string propertySyntax)
		{
			return propertySyntax.StartsWith("<color>");
		}
	}
}
namespace UnityEngine.UIElements.StyleSheets.Syntax
{
	internal class Expression
	{
		public ExpressionType type;

		public ExpressionMultiplier multiplier;

		public DataType dataType;

		public ExpressionCombinator combinator;

		public Expression[] subExpressions;

		public string keyword;

		public Expression(ExpressionType type)
		{
			this.type = type;
			combinator = ExpressionCombinator.None;
			multiplier = new ExpressionMultiplier(ExpressionMultiplierType.None);
			subExpressions = null;
			keyword = null;
		}
	}
	internal enum ExpressionType
	{
		Unknown,
		Data,
		Keyword,
		Combinator
	}
	internal enum DataType
	{
		None,
		Number,
		Integer,
		Length,
		Percentage,
		Color,
		Resource,
		Url,
		Time,
		Angle,
		CustomIdent
	}
	internal enum ExpressionCombinator
	{
		None,
		Or,
		OrOr,
		AndAnd,
		Juxtaposition,
		Group
	}
	internal enum ExpressionMultiplierType
	{
		None,
		ZeroOrMore,
		OneOrMore,
		ZeroOrOne,
		Ranges,
		OneOrMoreComma,
		GroupAtLeastOne
	}
	internal struct ExpressionMultiplier
	{
		public const int Infinity = 100;

		private ExpressionMultiplierType m_Type;

		public int min;

		public int max;

		public ExpressionMultiplierType type
		{
			get
			{
				return m_Type;
			}
			set
			{
				SetType(value);
			}
		}

		public ExpressionMultiplier(ExpressionMultiplierType type = ExpressionMultiplierType.None)
		{
			m_Type = type;
			min = (max = 1);
			SetType(type);
		}

		private void SetType(ExpressionMultiplierType value)
		{
			m_Type = value;
			switch (value)
			{
			case ExpressionMultiplierType.ZeroOrMore:
				min = 0;
				max = 100;
				break;
			case ExpressionMultiplierType.ZeroOrOne:
				min = 0;
				max = 1;
				break;
			case ExpressionMultiplierType.OneOrMore:
			case ExpressionMultiplierType.OneOrMoreComma:
			case ExpressionMultiplierType.GroupAtLeastOne:
				min = 1;
				max = 100;
				break;
			default:
				min = (max = 1);
				break;
			}
		}
	}
	internal class StyleSyntaxParser
	{
		private List<Expression> m_ProcessExpressionList = new List<Expression>();

		private Stack<Expression> m_ExpressionStack = new Stack<Expression>();

		private Stack<ExpressionCombinator> m_CombinatorStack = new Stack<ExpressionCombinator>();

		private Dictionary<string, Expression> m_ParsedExpressionCache = new Dictionary<string, Expression>();

		public Expression Parse(string syntax)
		{
			if (string.IsNullOrEmpty(syntax))
			{
				return null;
			}
			Expression value = null;
			if (!m_ParsedExpressionCache.TryGetValue(syntax, out value))
			{
				StyleSyntaxTokenizer styleSyntaxTokenizer = new StyleSyntaxTokenizer();
				styleSyntaxTokenizer.Tokenize(syntax);
				try
				{
					value = ParseExpression(styleSyntaxTokenizer);
				}
				catch (Exception exception)
				{
					Debug.LogException(exception);
				}
				m_ParsedExpressionCache[syntax] = value;
			}
			return value;
		}

		private Expression ParseExpression(StyleSyntaxTokenizer tokenizer)
		{
			StyleSyntaxToken current = tokenizer.current;
			while (!IsExpressionEnd(current))
			{
				Expression expression = null;
				if (current.type == StyleSyntaxTokenType.String || current.type == StyleSyntaxTokenType.LessThan)
				{
					expression = ParseTerm(tokenizer);
				}
				else
				{
					if (current.type != StyleSyntaxTokenType.OpenBracket)
					{
						throw new Exception($"Unexpected token '{current.type}' in expression");
					}
					expression = ParseGroup(tokenizer);
				}
				m_ExpressionStack.Push(expression);
				ExpressionCombinator expressionCombinator = ParseCombinatorType(tokenizer);
				if (expressionCombinator != ExpressionCombinator.None)
				{
					if (m_CombinatorStack.Count > 0)
					{
						ExpressionCombinator expressionCombinator2 = m_CombinatorStack.Peek();
						int num = (int)expressionCombinator2;
						int num2 = (int)expressionCombinator;
						while (num > num2 && expressionCombinator2 != ExpressionCombinator.Group)
						{
							ProcessCombinatorStack();
							expressionCombinator2 = ((m_CombinatorStack.Count > 0) ? m_CombinatorStack.Peek() : ExpressionCombinator.None);
							num = (int)expressionCombinator2;
						}
					}
					m_CombinatorStack.Push(expressionCombinator);
				}
				current = tokenizer.current;
			}
			while (m_CombinatorStack.Count > 0)
			{
				ExpressionCombinator expressionCombinator3 = m_CombinatorStack.Peek();
				if (expressionCombinator3 == ExpressionCombinator.Group)
				{
					m_CombinatorStack.Pop();
					break;
				}
				ProcessCombinatorStack();
			}
			return m_ExpressionStack.Pop();
		}

		private void ProcessCombinatorStack()
		{
			ExpressionCombinator expressionCombinator = m_CombinatorStack.Pop();
			Expression item = m_ExpressionStack.Pop();
			Expression item2 = m_ExpressionStack.Pop();
			m_ProcessExpressionList.Clear();
			m_ProcessExpressionList.Add(item2);
			m_ProcessExpressionList.Add(item);
			while (m_CombinatorStack.Count > 0 && expressionCombinator == m_CombinatorStack.Peek())
			{
				Expression item3 = m_ExpressionStack.Pop();
				m_ProcessExpressionList.Insert(0, item3);
				m_CombinatorStack.Pop();
			}
			Expression expression = new Expression(ExpressionType.Combinator);
			expression.combinator = expressionCombinator;
			expression.subExpressions = m_ProcessExpressionList.ToArray();
			m_ExpressionStack.Push(expression);
		}

		private Expression ParseTerm(StyleSyntaxTokenizer tokenizer)
		{
			Expression expression = null;
			StyleSyntaxToken current = tokenizer.current;
			if (current.type == StyleSyntaxTokenType.LessThan)
			{
				expression = ParseDataType(tokenizer);
			}
			else
			{
				if (current.type != StyleSyntaxTokenType.String)
				{
					throw new Exception($"Unexpected token '{current.type}' in expression. Expected term token");
				}
				expression = new Expression(ExpressionType.Keyword);
				expression.keyword = current.text.ToLower();
				tokenizer.MoveNext();
			}
			ParseMultiplier(tokenizer, ref expression.multiplier);
			return expression;
		}

		private ExpressionCombinator ParseCombinatorType(StyleSyntaxTokenizer tokenizer)
		{
			ExpressionCombinator expressionCombinator = ExpressionCombinator.None;
			StyleSyntaxToken token = tokenizer.current;
			while (!IsExpressionEnd(token) && expressionCombinator == ExpressionCombinator.None)
			{
				StyleSyntaxToken token2 = tokenizer.PeekNext();
				switch (token.type)
				{
				case StyleSyntaxTokenType.Space:
					if (!IsCombinator(token2) && token2.type != StyleSyntaxTokenType.CloseBracket)
					{
						expressionCombinator = ExpressionCombinator.Juxtaposition;
					}
					break;
				case StyleSyntaxTokenType.SingleBar:
					expressionCombinator = ExpressionCombinator.Or;
					break;
				case StyleSyntaxTokenType.DoubleBar:
					expressionCombinator = ExpressionCombinator.OrOr;
					break;
				case StyleSyntaxTokenType.DoubleAmpersand:
					expressionCombinator = ExpressionCombinator.AndAnd;
					break;
				default:
					throw new Exception($"Unexpected token '{token.type}' in expression. Expected combinator token");
				}
				token = tokenizer.MoveNext();
			}
			EatSpace(tokenizer);
			return expressionCombinator;
		}

		private Expression ParseGroup(StyleSyntaxTokenizer tokenizer)
		{
			StyleSyntaxToken current = tokenizer.current;
			if (current.type != StyleSyntaxTokenType.OpenBracket)
			{
				throw new Exception($"Unexpected token '{current.type}' in group expression. Expected '[' token");
			}
			m_CombinatorStack.Push(ExpressionCombinator.Group);
			tokenizer.MoveNext();
			EatSpace(tokenizer);
			Expression expression = ParseExpression(tokenizer);
			current = tokenizer.current;
			if (current.type != StyleSyntaxTokenType.CloseBracket)
			{
				throw new Exception($"Unexpected token '{current.type}' in group expression. Expected ']' token");
			}
			tokenizer.MoveNext();
			Expression expression2 = new Expression(ExpressionType.Combinator);
			expression2.combinator = ExpressionCombinator.Group;
			expression2.subExpressions = new Expression[1] { expression };
			ParseMultiplier(tokenizer, ref expression2.multiplier);
			return expression2;
		}

		private Expression ParseDataType(StyleSyntaxTokenizer tokenizer)
		{
			Expression expression = null;
			StyleSyntaxToken current = tokenizer.current;
			if (current.type != StyleSyntaxTokenType.LessThan)
			{
				throw new Exception($"Unexpected token '{current.type}' in data type expression. Expected '<' token");
			}
			current = tokenizer.MoveNext();
			switch (current.type)
			{
			case StyleSyntaxTokenType.String:
			{
				if (StylePropertyCache.TryGetNonTerminalValue(current.text, out var syntax))
				{
					expression = ParseNonTerminalValue(syntax);
				}
				else
				{
					DataType dataType = DataType.None;
					try
					{
						object obj = Enum.Parse(typeof(DataType), current.text.Replace("-", ""), ignoreCase: true);
						if (obj != null)
						{
							dataType = (DataType)obj;
						}
					}
					catch (Exception)
					{
						throw new Exception("Unknown data type '" + current.text + "'");
					}
					expression = new Expression(ExpressionType.Data);
					expression.dataType = dataType;
				}
				tokenizer.MoveNext();
				break;
			}
			case StyleSyntaxTokenType.SingleQuote:
				expression = ParseProperty(tokenizer);
				break;
			default:
				throw new Exception($"Unexpected token '{current.type}' in data type expression");
			}
			current = tokenizer.current;
			if (current.type != StyleSyntaxTokenType.GreaterThan)
			{
				throw new Exception($"Unexpected token '{current.type}' in data type expression. Expected '>' token");
			}
			tokenizer.MoveNext();
			return expression;
		}

		private Expression ParseNonTerminalValue(string syntax)
		{
			Expression value = null;
			if (!m_ParsedExpressionCache.TryGetValue(syntax, out value))
			{
				m_CombinatorStack.Push(ExpressionCombinator.Group);
				value = Parse(syntax);
			}
			Expression expression = new Expression(ExpressionType.Combinator);
			expression.combinator = ExpressionCombinator.Group;
			expression.subExpressions = new Expression[1] { value };
			return expression;
		}

		private Expression ParseProperty(StyleSyntaxTokenizer tokenizer)
		{
			Expression value = null;
			StyleSyntaxToken current = tokenizer.current;
			if (current.type != StyleSyntaxTokenType.SingleQuote)
			{
				throw new Exception($"Unexpected token '{current.type}' in property expression. Expected ''' token");
			}
			current = tokenizer.MoveNext();
			if (current.type != StyleSyntaxTokenType.String)
			{
				throw new Exception($"Unexpected token '{current.type}' in property expression. Expected 'string' token");
			}
			string text = current.text;
			if (!StylePropertyCache.TryGetSyntax(text, out var syntax))
			{
				throw new Exception("Unknown property '" + text + "' <''> expression.");
			}
			if (!m_ParsedExpressionCache.TryGetValue(syntax, out value))
			{
				m_CombinatorStack.Push(ExpressionCombinator.Group);
				value = Parse(syntax);
			}
			current = tokenizer.MoveNext();
			if (current.type != StyleSyntaxTokenType.SingleQuote)
			{
				throw new Exception($"Unexpected token '{current.type}' in property expression. Expected ''' token");
			}
			current = tokenizer.MoveNext();
			if (current.type != StyleSyntaxTokenType.GreaterThan)
			{
				throw new Exception($"Unexpected token '{current.type}' in property expression. Expected '>' token");
			}
			Expression expression = new Expression(ExpressionType.Combinator);
			expression.combinator = ExpressionCombinator.Group;
			expression.subExpressions = new Expression[1] { value };
			return expression;
		}

		private void ParseMultiplier(StyleSyntaxTokenizer tokenizer, ref ExpressionMultiplier multiplier)
		{
			StyleSyntaxToken current = tokenizer.current;
			if (IsMultiplier(current))
			{
				switch (current.type)
				{
				case StyleSyntaxTokenType.Asterisk:
					multiplier.type = ExpressionMultiplierType.ZeroOrMore;
					break;
				case StyleSyntaxTokenType.Plus:
					multiplier.type = ExpressionMultiplierType.OneOrMore;
					break;
				case StyleSyntaxTokenType.QuestionMark:
					multiplier.type = ExpressionMultiplierType.ZeroOrOne;
					break;
				case StyleSyntaxTokenType.HashMark:
					multiplier.type = ExpressionMultiplierType.OneOrMoreComma;
					break;
				case StyleSyntaxTokenType.ExclamationPoint:
					multiplier.type = ExpressionMultiplierType.GroupAtLeastOne;
					break;
				case StyleSyntaxTokenType.OpenBrace:
					multiplier.type = ExpressionMultiplierType.Ranges;
					break;
				default:
					throw new Exception($"Unexpected token '{current.type}' in expression. Expected multiplier token");
				}
				current = tokenizer.MoveNext();
			}
			if (multiplier.type == ExpressionMultiplierType.Ranges)
			{
				ParseRanges(tokenizer, out multiplier.min, out multiplier.max);
			}
		}

		private void ParseRanges(StyleSyntaxTokenizer tokenizer, out int min, out int max)
		{
			min = -1;
			max = -1;
			StyleSyntaxToken styleSyntaxToken = tokenizer.current;
			bool flag = false;
			while (styleSyntaxToken.type != StyleSyntaxTokenType.CloseBrace)
			{
				switch (styleSyntaxToken.type)
				{
				case StyleSyntaxTokenType.Number:
					if (!flag)
					{
						min = styleSyntaxToken.number;
					}
					else
					{
						max = styleSyntaxToken.number;
					}
					break;
				case StyleSyntaxTokenType.Comma:
					flag = true;
					break;
				default:
					throw new Exception($"Unexpected token '{styleSyntaxToken.type}' in expression. Expected ranges token");
				}
				styleSyntaxToken = tokenizer.MoveNext();
			}
			tokenizer.MoveNext();
		}

		private static void EatSpace(StyleSyntaxTokenizer tokenizer)
		{
			if (tokenizer.current.type == StyleSyntaxTokenType.Space)
			{
				tokenizer.MoveNext();
			}
		}

		private static bool IsExpressionEnd(StyleSyntaxToken token)
		{
			StyleSyntaxTokenType type = token.type;
			StyleSyntaxTokenType styleSyntaxTokenType = type;
			if (styleSyntaxTokenType == StyleSyntaxTokenType.CloseBracket || styleSyntaxTokenType == StyleSyntaxTokenType.End)
			{
				return true;
			}
			return false;
		}

		private static bool IsCombinator(StyleSyntaxToken token)
		{
			StyleSyntaxTokenType type = token.type;
			StyleSyntaxTokenType styleSyntaxTokenType = type;
			if ((uint)(styleSyntaxTokenType - 3) <= 3u)
			{
				return true;
			}
			return false;
		}

		private static bool IsMultiplier(StyleSyntaxToken token)
		{
			StyleSyntaxTokenType type = token.type;
			StyleSyntaxTokenType styleSyntaxTokenType = type;
			if ((uint)(styleSyntaxTokenType - 9) <= 4u || styleSyntaxTokenType == StyleSyntaxTokenType.OpenBrace)
			{
				return true;
			}
			return false;
		}
	}
	internal enum StyleSyntaxTokenType
	{
		Unknown,
		String,
		Number,
		Space,
		SingleBar,
		DoubleBar,
		DoubleAmpersand,
		Comma,
		SingleQuote,
		Asterisk,
		Plus,
		QuestionMark,
		HashMark,
		ExclamationPoint,
		OpenBracket,
		CloseBracket,
		OpenBrace,
		CloseBrace,
		LessThan,
		GreaterThan,
		End
	}
	internal struct StyleSyntaxToken
	{
		public StyleSyntaxTokenType type;

		public string text;

		public int number;

		public StyleSyntaxToken(StyleSyntaxTokenType t)
		{
			type = t;
			text = null;
			number = 0;
		}

		public StyleSyntaxToken(StyleSyntaxTokenType type, string text)
		{
			this.type = type;
			this.text = text;
			number = 0;
		}

		public StyleSyntaxToken(StyleSyntaxTokenType type, int number)
		{
			this.type = type;
			text = null;
			this.number = number;
		}
	}
	internal class StyleSyntaxTokenizer
	{
		private List<StyleSyntaxToken> m_Tokens = new List<StyleSyntaxToken>();

		private int m_CurrentTokenIndex = -1;

		public StyleSyntaxToken current
		{
			get
			{
				if (m_CurrentTokenIndex < 0 || m_CurrentTokenIndex >= m_Tokens.Count)
				{
					return new StyleSyntaxToken(StyleSyntaxTokenType.Unknown);
				}
				return m_Tokens[m_CurrentTokenIndex];
			}
		}

		public StyleSyntaxToken MoveNext()
		{
			StyleSyntaxToken result = current;
			if (result.type == StyleSyntaxTokenType.Unknown)
			{
				return result;
			}
			m_CurrentTokenIndex++;
			result = current;
			if (m_CurrentTokenIndex == m_Tokens.Count)
			{
				m_CurrentTokenIndex = -1;
			}
			return result;
		}

		public StyleSyntaxToken PeekNext()
		{
			int num = m_CurrentTokenIndex + 1;
			if (m_CurrentTokenIndex < 0 || num >= m_Tokens.Count)
			{
				return new StyleSyntaxToken(StyleSyntaxTokenType.Unknown);
			}
			return m_Tokens[num];
		}

		public void Tokenize(string syntax)
		{
			m_Tokens.Clear();
			m_CurrentTokenIndex = 0;
			syntax = syntax.Trim(' ').ToLowerInvariant();
			for (int i = 0; i < syntax.Length; i++)
			{
				char c = syntax[i];
				switch (c)
				{
				case ' ':
					i = GlobCharacter(syntax, i, ' ');
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.Space));
					continue;
				case '|':
					if (IsNextCharacter(syntax, i, '|'))
					{
						m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.DoubleBar));
						i++;
					}
					else
					{
						m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.SingleBar));
					}
					continue;
				case '&':
					if (!IsNextCharacter(syntax, i, '&'))
					{
						string text = ((i + 1 < syntax.Length) ? syntax[i + 1].ToString() : "EOF");
						Debug.LogAssertionFormat("Expected '&' got '{0}'", text);
						m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.Unknown));
					}
					else
					{
						m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.DoubleAmpersand));
						i++;
					}
					continue;
				case ',':
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.Comma));
					continue;
				case '\'':
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.SingleQuote));
					continue;
				case '*':
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.Asterisk));
					continue;
				case '+':
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.Plus));
					continue;
				case '?':
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.QuestionMark));
					continue;
				case '#':
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.HashMark));
					continue;
				case '!':
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.ExclamationPoint));
					continue;
				case '[':
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.OpenBracket));
					continue;
				case ']':
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.CloseBracket));
					continue;
				case '{':
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.OpenBrace));
					continue;
				case '}':
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.CloseBrace));
					continue;
				case '<':
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.LessThan));
					continue;
				case '>':
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.GreaterThan));
					continue;
				}
				if (char.IsNumber(c))
				{
					int startIndex = i;
					int num = 1;
					while (IsNextNumber(syntax, i))
					{
						i++;
						num++;
					}
					string s = syntax.Substring(startIndex, num);
					int number = int.Parse(s);
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.Number, number));
				}
				else if (char.IsLetter(c))
				{
					int startIndex2 = i;
					int num2 = 1;
					while (IsNextLetterOrDash(syntax, i))
					{
						i++;
						num2++;
					}
					string text2 = syntax.Substring(startIndex2, num2);
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.String, text2));
				}
				else
				{
					Debug.LogAssertionFormat("Expected letter or number got '{0}'", c);
					m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.Unknown));
				}
			}
			m_Tokens.Add(new StyleSyntaxToken(StyleSyntaxTokenType.End));
		}

		private static bool IsNextCharacter(string s, int index, char c)
		{
			return index + 1 < s.Length && s[index + 1] == c;
		}

		private static bool IsNextLetterOrDash(string s, int index)
		{
			return index + 1 < s.Length && (char.IsLetter(s[index + 1]) || s[index + 1] == '-');
		}

		private static bool IsNextNumber(string s, int index)
		{
			return index + 1 < s.Length && char.IsNumber(s[index + 1]);
		}

		private static int GlobCharacter(string s, int index, char c)
		{
			while (IsNextCharacter(s, index, c))
			{
				index++;
			}
			return index;
		}
	}
}
namespace UnityEngine.UIElements.Experimental
{
	public static class Easing
	{
		private const float HalfPi = MathF.PI / 2f;

		public static float Step(float t)
		{
			return (!(t < 0.5f)) ? 1 : 0;
		}

		public static float Linear(float t)
		{
			return t;
		}

		public static float InSine(float t)
		{
			return Mathf.Sin(MathF.PI / 2f * (t - 1f)) + 1f;
		}

		public static float OutSine(float t)
		{
			return Mathf.Sin(t * (MathF.PI / 2f));
		}

		public static float InOutSine(float t)
		{
			return (Mathf.Sin(MathF.PI * (t - 0.5f)) + 1f) * 0.5f;
		}

		public static float InQuad(float t)
		{
			return t * t;
		}

		public static float OutQuad(float t)
		{
			return t * (2f - t);
		}

		public static float InOutQuad(float t)
		{
			t *= 2f;
			if (t < 1f)
			{
				return t * t * 0.5f;
			}
			return -0.5f * ((t - 1f) * (t - 3f) - 1f);
		}

		public static float InCubic(float t)
		{
			return InPower(t, 3);
		}

		public static float OutCubic(float t)
		{
			return OutPower(t, 3);
		}

		public static float InOutCubic(float t)
		{
			return InOutPower(t, 3);
		}

		public static float InPower(float t, int power)
		{
			return Mathf.Pow(t, power);
		}

		public static float OutPower(float t, int power)
		{
			int num = ((power % 2 != 0) ? 1 : (-1));
			return (float)num * (Mathf.Pow(t - 1f, power) + (float)num);
		}

		public static float InOutPower(float t, int power)
		{
			t *= 2f;
			if (t < 1f)
			{
				return InPower(t, power) * 0.5f;
			}
			int num = ((power % 2 != 0) ? 1 : (-1));
			return (float)num * 0.5f * (Mathf.Pow(t - 2f, power) + (float)(num * 2));
		}

		public static float InBounce(float t)
		{
			return 1f - OutBounce(1f - t);
		}

		public static float OutBounce(float t)
		{
			if (t < 0.36363637f)
			{
				return 7.5625f * t * t;
			}
			if (t < 0.72727275f)
			{
				float num = (t -= 0.54545456f);
				return 7.5625f * num * t + 0.75f;
			}
			if (t < 0.90909094f)
			{
				float num2 = (t -= 0.8181818f);
				return 7.5625f * num2 * t + 0.9375f;
			}
			float num3 = (t -= 21f / 22f);
			return 7.5625f * num3 * t + 63f / 64f;
		}

		public static float InOutBounce(float t)
		{
			if (t < 0.5f)
			{
				return InBounce(t * 2f) * 0.5f;
			}
			return OutBounce((t - 0.5f) * 2f) * 0.5f + 0.5f;
		}

		public static float InElastic(float t)
		{
			if (t == 0f)
			{
				return 0f;
			}
			if (t == 1f)
			{
				return 1f;
			}
			float num = 0.3f;
			float num2 = num / 4f;
			float num3 = Mathf.Pow(2f, 10f * (t -= 1f));
			return 0f - num3 * Mathf.Sin((t - num2) * (MathF.PI * 2f) / num);
		}

		public static float OutElastic(float t)
		{
			if (t == 0f)
			{
				return 0f;
			}
			if (t == 1f)
			{
				return 1f;
			}
			float num = 0.3f;
			float num2 = num / 4f;
			return Mathf.Pow(2f, -10f * t) * Mathf.Sin((t - num2) * (MathF.PI * 2f) / num) + 1f;
		}

		public static float InOutElastic(float t)
		{
			if (t < 0.5f)
			{
				return InElastic(t * 2f) * 0.5f;
			}
			return OutElastic((t - 0.5f) * 2f) * 0.5f + 0.5f;
		}

		public static float InBack(float t)
		{
			float num = 1.70158f;
			return t * t * ((num + 1f) * t - num);
		}

		public static float OutBack(float t)
		{
			return 1f - InBack(1f - t);
		}

		public static float InOutBack(float t)
		{
			if (t < 0.5f)
			{
				return InBack(t * 2f) * 0.5f;
			}
			return OutBack((t - 0.5f) * 2f) * 0.5f + 0.5f;
		}

		public static float InBack(float t, float s)
		{
			return t * t * ((s + 1f) * t - s);
		}

		public static float OutBack(float t, float s)
		{
			return 1f - InBack(1f - t, s);
		}

		public static float InOutBack(float t, float s)
		{
			if (t < 0.5f)
			{
				return InBack(t * 2f, s) * 0.5f;
			}
			return OutBack((t - 0.5f) * 2f, s) * 0.5f + 0.5f;
		}

		public static float InCirc(float t)
		{
			return 0f - (Mathf.Sqrt(1f - t * t) - 1f);
		}

		public static float OutCirc(float t)
		{
			t -= 1f;
			return Mathf.Sqrt(1f - t * t);
		}

		public static float InOutCirc(float t)
		{
			t *= 2f;
			if (t < 1f)
			{
				return -0.5f * (Mathf.Sqrt(1f - t * t) - 1f);
			}
			t -= 2f;
			return 0.5f * (Mathf.Sqrt(1f - t * t) + 1f);
		}
	}
	[EventCategory(EventCategory.EnterLeave)]
	public class PointerOverLinkTagEvent : PointerEventBase<PointerOverLinkTagEvent>
	{
		public string linkID { get; private set; }

		public string linkText { get; private set; }

		static PointerOverLinkTagEvent()
		{
			EventBase<PointerOverLinkTagEvent>.SetCreateFunction(() => new PointerOverLinkTagEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown;
		}

		public static PointerOverLinkTagEvent GetPooled(IPointerEvent evt, string linkID, string linkText)
		{
			PointerOverLinkTagEvent pointerOverLinkTagEvent = PointerEventBase<PointerOverLinkTagEvent>.GetPooled(evt);
			pointerOverLinkTagEvent.linkID = linkID;
			pointerOverLinkTagEvent.linkText = linkText;
			return pointerOverLinkTagEvent;
		}

		public PointerOverLinkTagEvent()
		{
			LocalInit();
		}
	}
	[EventCategory(EventCategory.PointerMove)]
	public class PointerMoveLinkTagEvent : PointerEventBase<PointerMoveLinkTagEvent>
	{
		public string linkID { get; private set; }

		public string linkText { get; private set; }

		static PointerMoveLinkTagEvent()
		{
			EventBase<PointerMoveLinkTagEvent>.SetCreateFunction(() => new PointerMoveLinkTagEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown;
		}

		public static PointerMoveLinkTagEvent GetPooled(IPointerEvent evt, string linkID, string linkText)
		{
			PointerMoveLinkTagEvent pointerMoveLinkTagEvent = PointerEventBase<PointerMoveLinkTagEvent>.GetPooled(evt);
			pointerMoveLinkTagEvent.linkID = linkID;
			pointerMoveLinkTagEvent.linkText = linkText;
			return pointerMoveLinkTagEvent;
		}

		public PointerMoveLinkTagEvent()
		{
			LocalInit();
		}
	}
	[EventCategory(EventCategory.EnterLeave)]
	public class PointerOutLinkTagEvent : PointerEventBase<PointerOutLinkTagEvent>
	{
		static PointerOutLinkTagEvent()
		{
			EventBase<PointerOutLinkTagEvent>.SetCreateFunction(() => new PointerOutLinkTagEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown;
		}

		public static PointerOutLinkTagEvent GetPooled(IPointerEvent evt, string linkID)
		{
			return PointerEventBase<PointerOutLinkTagEvent>.GetPooled(evt);
		}

		public PointerOutLinkTagEvent()
		{
			LocalInit();
		}
	}
	public sealed class PointerDownLinkTagEvent : PointerEventBase<PointerDownLinkTagEvent>
	{
		public string linkID { get; private set; }

		public string linkText { get; private set; }

		static PointerDownLinkTagEvent()
		{
			EventBase<PointerDownLinkTagEvent>.SetCreateFunction(() => new PointerDownLinkTagEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown;
		}

		public static PointerDownLinkTagEvent GetPooled(IPointerEvent evt, string linkID, string linkText)
		{
			PointerDownLinkTagEvent pointerDownLinkTagEvent = PointerEventBase<PointerDownLinkTagEvent>.GetPooled(evt);
			pointerDownLinkTagEvent.linkID = linkID;
			pointerDownLinkTagEvent.linkText = linkText;
			return pointerDownLinkTagEvent;
		}

		public PointerDownLinkTagEvent()
		{
			LocalInit();
		}
	}
	public class PointerUpLinkTagEvent : PointerEventBase<PointerUpLinkTagEvent>
	{
		public string linkID { get; private set; }

		public string linkText { get; private set; }

		static PointerUpLinkTagEvent()
		{
			EventBase<PointerUpLinkTagEvent>.SetCreateFunction(() => new PointerUpLinkTagEvent());
		}

		protected override void Init()
		{
			base.Init();
			LocalInit();
		}

		private void LocalInit()
		{
			base.propagation = EventPropagation.Bubbles | EventPropagation.TricklesDown;
		}

		public static PointerUpLinkTagEvent GetPooled(IPointerEvent evt, string linkID, string linkText)
		{
			PointerUpLinkTagEvent pointerUpLinkTagEvent = PointerEventBase<PointerUpLinkTagEvent>.GetPooled(evt);
			pointerUpLinkTagEvent.linkID = linkID;
			pointerUpLinkTagEvent.linkText = linkText;
			return pointerUpLinkTagEvent;
		}

		public PointerUpLinkTagEvent()
		{
			LocalInit();
		}
	}
	public struct StyleValues
	{
		internal StyleValueCollection m_StyleValues;

		public float top
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.Top).value;
			}
			set
			{
				SetValue(StylePropertyId.Top, value);
			}
		}

		public float left
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.Left).value;
			}
			set
			{
				SetValue(StylePropertyId.Left, value);
			}
		}

		public float width
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.Width).value;
			}
			set
			{
				SetValue(StylePropertyId.Width, value);
			}
		}

		public float height
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.Height).value;
			}
			set
			{
				SetValue(StylePropertyId.Height, value);
			}
		}

		public float right
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.Right).value;
			}
			set
			{
				SetValue(StylePropertyId.Right, value);
			}
		}

		public float bottom
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.Bottom).value;
			}
			set
			{
				SetValue(StylePropertyId.Bottom, value);
			}
		}

		public Color color
		{
			get
			{
				return Values().GetStyleColor(StylePropertyId.Color).value;
			}
			set
			{
				SetValue(StylePropertyId.Color, value);
			}
		}

		public Color backgroundColor
		{
			get
			{
				return Values().GetStyleColor(StylePropertyId.BackgroundColor).value;
			}
			set
			{
				SetValue(StylePropertyId.BackgroundColor, value);
			}
		}

		public Color unityBackgroundImageTintColor
		{
			get
			{
				return Values().GetStyleColor(StylePropertyId.UnityBackgroundImageTintColor).value;
			}
			set
			{
				SetValue(StylePropertyId.UnityBackgroundImageTintColor, value);
			}
		}

		public Color borderColor
		{
			get
			{
				return Values().GetStyleColor(StylePropertyId.BorderColor).value;
			}
			set
			{
				SetValue(StylePropertyId.BorderColor, value);
			}
		}

		public float marginLeft
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.MarginLeft).value;
			}
			set
			{
				SetValue(StylePropertyId.MarginLeft, value);
			}
		}

		public float marginTop
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.MarginTop).value;
			}
			set
			{
				SetValue(StylePropertyId.MarginTop, value);
			}
		}

		public float marginRight
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.MarginRight).value;
			}
			set
			{
				SetValue(StylePropertyId.MarginRight, value);
			}
		}

		public float marginBottom
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.MarginBottom).value;
			}
			set
			{
				SetValue(StylePropertyId.MarginBottom, value);
			}
		}

		public float paddingLeft
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.PaddingLeft).value;
			}
			set
			{
				SetValue(StylePropertyId.PaddingLeft, value);
			}
		}

		public float paddingTop
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.PaddingTop).value;
			}
			set
			{
				SetValue(StylePropertyId.PaddingTop, value);
			}
		}

		public float paddingRight
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.PaddingRight).value;
			}
			set
			{
				SetValue(StylePropertyId.PaddingRight, value);
			}
		}

		public float paddingBottom
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.PaddingBottom).value;
			}
			set
			{
				SetValue(StylePropertyId.PaddingBottom, value);
			}
		}

		public float borderLeftWidth
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.BorderLeftWidth).value;
			}
			set
			{
				SetValue(StylePropertyId.BorderLeftWidth, value);
			}
		}

		public float borderRightWidth
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.BorderRightWidth).value;
			}
			set
			{
				SetValue(StylePropertyId.BorderRightWidth, value);
			}
		}

		public float borderTopWidth
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.BorderTopWidth).value;
			}
			set
			{
				SetValue(StylePropertyId.BorderTopWidth, value);
			}
		}

		public float borderBottomWidth
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.BorderBottomWidth).value;
			}
			set
			{
				SetValue(StylePropertyId.BorderBottomWidth, value);
			}
		}

		public float borderTopLeftRadius
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.BorderTopLeftRadius).value;
			}
			set
			{
				SetValue(StylePropertyId.BorderTopLeftRadius, value);
			}
		}

		public float borderTopRightRadius
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.BorderTopRightRadius).value;
			}
			set
			{
				SetValue(StylePropertyId.BorderTopRightRadius, value);
			}
		}

		public float borderBottomLeftRadius
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.BorderBottomLeftRadius).value;
			}
			set
			{
				SetValue(StylePropertyId.BorderBottomLeftRadius, value);
			}
		}

		public float borderBottomRightRadius
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.BorderBottomRightRadius).value;
			}
			set
			{
				SetValue(StylePropertyId.BorderBottomRightRadius, value);
			}
		}

		public float opacity
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.Opacity).value;
			}
			set
			{
				SetValue(StylePropertyId.Opacity, value);
			}
		}

		public float flexGrow
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.FlexGrow).value;
			}
			set
			{
				SetValue(StylePropertyId.FlexGrow, value);
			}
		}

		public float flexShrink
		{
			get
			{
				return Values().GetStyleFloat(StylePropertyId.FlexShrink).value;
			}
			set
			{
				SetValue(StylePropertyId.FlexGrow, value);
			}
		}

		internal void SetValue(StylePropertyId id, float value)
		{
			StyleValue styleValue = new StyleValue
			{
				id = id,
				number = value
			};
			Values().SetStyleValue(styleValue);
		}

		internal void SetValue(StylePropertyId id, Color value)
		{
			StyleValue styleValue = new StyleValue
			{
				id = id,
				color = value
			};
			Values().SetStyleValue(styleValue);
		}

		internal StyleValueCollection Values()
		{
			if (m_StyleValues == null)
			{
				m_StyleValues = new StyleValueCollection();
			}
			return m_StyleValues;
		}
	}
	public interface ITransitionAnimations
	{
		ValueAnimation<float> Start(float from, float to, int durationMs, Action<VisualElement, float> onValueChanged);

		ValueAnimation<Rect> Start(Rect from, Rect to, int durationMs, Action<VisualElement, Rect> onValueChanged);

		ValueAnimation<Color> Start(Color from, Color to, int durationMs, Action<VisualElement, Color> onValueChanged);

		ValueAnimation<Vector3> Start(Vector3 from, Vector3 to, int durationMs, Action<VisualElement, Vector3> onValueChanged);

		ValueAnimation<Vector2> Start(Vector2 from, Vector2 to, int durationMs, Action<VisualElement, Vector2> onValueChanged);

		ValueAnimation<Quaternion> Start(Quaternion from, Quaternion to, int durationMs, Action<VisualElement, Quaternion> onValueChanged);

		ValueAnimation<StyleValues> Start(StyleValues from, StyleValues to, int durationMs);

		ValueAnimation<StyleValues> Start(StyleValues to, int durationMs);

		ValueAnimation<float> Start(Func<VisualElement, float> fromValueGetter, float to, int durationMs, Action<VisualElement, float> onValueChanged);

		ValueAnimation<Rect> Start(Func<VisualElement, Rect> fromValueGetter, Rect to, int durationMs, Action<VisualElement, Rect> onValueChanged);

		ValueAnimation<Color> Start(Func<VisualElement, Color> fromValueGetter, Color to, int durationMs, Action<VisualElement, Color> onValueChanged);

		ValueAnimation<Vector3> Start(Func<VisualElement, Vector3> fromValueGetter, Vector3 to, int durationMs, Action<VisualElement, Vector3> onValueChanged);

		ValueAnimation<Vector2> Start(Func<VisualElement, Vector2> fromValueGetter, Vector2 to, int durationMs, Action<VisualElement, Vector2> onValueChanged);

		ValueAnimation<Quaternion> Start(Func<VisualElement, Quaternion> fromValueGetter, Quaternion to, int durationMs, Action<VisualElement, Quaternion> onValueChanged);

		ValueAnimation<Rect> Layout(Rect to, int durationMs);

		ValueAnimation<Vector2> TopLeft(Vector2 to, int durationMs);

		ValueAnimation<Vector2> Size(Vector2 to, int durationMs);

		ValueAnimation<float> Scale(float to, int duration);

		ValueAnimation<Vector3> Position(Vector3 to, int duration);

		ValueAnimation<Quaternion> Rotation(Quaternion to, int duration);
	}
	internal static class Lerp
	{
		public static float Interpolate(float start, float end, float ratio)
		{
			return Mathf.LerpUnclamped(start, end, ratio);
		}

		public static int Interpolate(int start, int end, float ratio)
		{
			return Mathf.RoundToInt(Mathf.LerpUnclamped(start, end, ratio));
		}

		public static Rect Interpolate(Rect r1, Rect r2, float ratio)
		{
			return new Rect(Mathf.LerpUnclamped(r1.x, r2.x, ratio), Mathf.LerpUnclamped(r1.y, r2.y, ratio), Mathf.LerpUnclamped(r1.width, r2.width, ratio), Mathf.LerpUnclamped(r1.height, r2.height, ratio));
		}

		public static Color Interpolate(Color start, Color end, float ratio)
		{
			return Color.LerpUnclamped(start, end, ratio);
		}

		public static Vector2 Interpolate(Vector2 start, Vector2 end, float ratio)
		{
			return Vector2.LerpUnclamped(start, end, ratio);
		}

		public static Vector3 Interpolate(Vector3 start, Vector3 end, float ratio)
		{
			return Vector3.LerpUnclamped(start, end, ratio);
		}

		public static Quaternion Interpolate(Quaternion start, Quaternion end, float ratio)
		{
			return Quaternion.SlerpUnclamped(start, end, ratio);
		}

		internal static StyleValues Interpolate(StyleValues start, StyleValues end, float ratio)
		{
			StyleValues result = default(StyleValues);
			if (end.m_StyleValues != null)
			{
				foreach (StyleValue value2 in end.m_StyleValues.m_Values)
				{
					StyleValue value = default(StyleValue);
					if (!start.m_StyleValues.TryGetStyleValue(value2.id, ref value))
					{
						throw new ArgumentException("Start StyleValues must contain the same values as end values. Missing property:" + value2.id);
					}
					switch (value2.id)
					{
					case StylePropertyId.FontSize:
					case StylePropertyId.BorderBottomWidth:
					case StylePropertyId.BorderLeftWidth:
					case StylePropertyId.BorderRightWidth:
					case StylePropertyId.BorderTopWidth:
					case StylePropertyId.Bottom:
					case StylePropertyId.FlexBasis:
					case StylePropertyId.FlexGrow:
					case StylePropertyId.FlexShrink:
					case StylePropertyId.Height:
					case StylePropertyId.Left:
					case StylePropertyId.MarginBottom:
					case StylePropertyId.MarginLeft:
					case StylePropertyId.MarginRight:
					case StylePropertyId.MarginTop:
					case StylePropertyId.MaxHeight:
					case StylePropertyId.MaxWidth:
					case StylePropertyId.MinHeight:
					case StylePropertyId.MinWidth:
					case StylePropertyId.PaddingBottom:
					case StylePropertyId.PaddingLeft:
					case StylePropertyId.PaddingRight:
					case StylePropertyId.PaddingTop:
					case StylePropertyId.Right:
					case StylePropertyId.Top:
					case StylePropertyId.Width:
					case StylePropertyId.BorderBottomLeftRadius:
					case StylePropertyId.BorderBottomRightRadius:
					case StylePropertyId.BorderTopLeftRadius:
					case StylePropertyId.BorderTopRightRadius:
					case StylePropertyId.Opacity:
						result.SetValue(value2.id, Interpolate(value.number, value2.number, ratio));
						break;
					case StylePropertyId.Color:
					case StylePropertyId.UnityBackgroundImageTintColor:
					case StylePropertyId.BorderColor:
					case StylePropertyId.BackgroundColor:
						result.SetValue(value2.id, Interpolate(value.color, value2.color, ratio));
						break;
					default:
						throw new ArgumentException("Style Value can't be animated");
					}
				}
			}
			return result;
		}
	}
	internal interface IValueAnimationUpdate
	{
		void Tick(long currentTimeMs);
	}
	public interface IValueAnimation
	{
		bool isRunning { get; }

		int durationMs { get; set; }

		void Start();

		void Stop();

		void Recycle();
	}
	public sealed class ValueAnimation<T> : IValueAnimationUpdate, IValueAnimation
	{
		private const int k_DefaultDurationMs = 400;

		private const int k_DefaultMaxPoolSize = 100;

		private long m_StartTimeMs;

		private int m_DurationMs;

		private static ObjectPool<ValueAnimation<T>> sObjectPool = new ObjectPool<ValueAnimation<T>>(() => new ValueAnimation<T>());

		private T _from;

		private bool fromValueSet = false;

		public int durationMs
		{
			get
			{
				return m_DurationMs;
			}
			set
			{
				if (value < 1)
				{
					value = 1;
				}
				m_DurationMs = value;
			}
		}

		public Func<float, float> easingCurve { get; set; }

		public bool isRunning { get; private set; }

		public Action onAnimationCompleted { get; set; }

		public bool autoRecycle { get; set; }

		private bool recycled { get; set; }

		private VisualElement owner { get; set; }

		public Action<VisualElement, T> valueUpdated { get; set; }

		public Func<VisualElement, T> initialValue { get; set; }

		public Func<T, T, float, T> interpolator { get; set; }

		public T from
		{
			get
			{
				if (!fromValueSet && initialValue != null)
				{
					from = initialValue(owner);
				}
				return _from;
			}
			set
			{
				fromValueSet = true;
				_from = value;
			}
		}

		public T to { get; set; }

		public ValueAnimation()
		{
			SetDefaultValues();
		}

		public void Start()
		{
			CheckNotRecycled();
			if (owner != null)
			{
				m_StartTimeMs = Panel.TimeSinceStartupMs();
				Register();
				isRunning = true;
			}
		}

		public void Stop()
		{
			CheckNotRecycled();
			if (isRunning)
			{
				Unregister();
				isRunning = false;
				onAnimationCompleted?.Invoke();
				if (autoRecycle && !recycled)
				{
					Recycle();
				}
			}
		}

		public void Recycle()
		{
			CheckNotRecycled();
			if (isRunning)
			{
				if (autoRecycle)
				{
					Stop();
					return;
				}
				Stop();
			}
			SetDefaultValues();
			recycled = true;
			sObjectPool.Release(this);
		}

		void IValueAnimationUpdate.Tick(long currentTimeMs)
		{
			CheckNotRecycled();
			long num = currentTimeMs - m_StartTimeMs;
			float num2 = (float)num / (float)durationMs;
			bool flag = false;
			if (num2 >= 1f)
			{
				num2 = 1f;
				flag = true;
			}
			num2 = easingCurve?.Invoke(num2) ?? num2;
			if (interpolator != null)
			{
				T arg = interpolator(from, to, num2);
				valueUpdated?.Invoke(owner, arg);
			}
			if (flag)
			{
				Stop();
			}
		}

		private void SetDefaultValues()
		{
			m_DurationMs = 400;
			autoRecycle = true;
			owner = null;
			m_StartTimeMs = 0L;
			onAnimationCompleted = null;
			valueUpdated = null;
			initialValue = null;
			interpolator = null;
			to = default(T);
			from = default(T);
			fromValueSet = false;
			easingCurve = Easing.OutQuad;
		}

		private void Unregister()
		{
			if (owner != null)
			{
				owner.UnregisterAnimation(this);
			}
		}

		private void Register()
		{
			if (owner != null)
			{
				owner.RegisterAnimation(this);
			}
		}

		internal void SetOwner(VisualElement e)
		{
			if (isRunning)
			{
				Unregister();
			}
			owner = e;
			if (isRunning)
			{
				Register();
			}
		}

		private void CheckNotRecycled()
		{
			if (recycled)
			{
				throw new InvalidOperationException("Animation object has been recycled. Use KeepAlive() to keep a reference to an animation after it has been stopped.");
			}
		}

		public static ValueAnimation<T> Create(VisualElement e, Func<T, T, float, T> interpolator)
		{
			ValueAnimation<T> valueAnimation = sObjectPool.Get();
			valueAnimation.recycled = false;
			valueAnimation.SetOwner(e);
			valueAnimation.interpolator = interpolator;
			return valueAnimation;
		}

		public ValueAnimation<T> Ease(Func<float, float> easing)
		{
			easingCurve = easing;
			return this;
		}

		public ValueAnimation<T> OnCompleted(Action callback)
		{
			onAnimationCompleted = callback;
			return this;
		}

		public ValueAnimation<T> KeepAlive()
		{
			autoRecycle = false;
			return this;
		}
	}
}
namespace UnityEngine.UIElements.Internal
{
	internal class MultiColumnHeaderColumnMovePreview : VisualElement
	{
		public static readonly string ussClassName = MultiColumnHeaderColumn.ussClassName + "__move-preview";

		public MultiColumnHeaderColumnMovePreview()
		{
			AddToClassList(ussClassName);
			base.pickingMode = PickingMode.Ignore;
		}
	}
	internal class MultiColumnHeaderColumnMoveLocationPreview : VisualElement
	{
		public static readonly string ussClassName = MultiColumnHeaderColumn.ussClassName + "__move-location-preview";

		public static readonly string visualUssClassName = ussClassName + "__visual";

		public MultiColumnHeaderColumnMoveLocationPreview()
		{
			AddToClassList(ussClassName);
			base.pickingMode = PickingMode.Ignore;
			VisualElement visualElement = new VisualElement();
			visualElement.AddToClassList(visualUssClassName);
			visualElement.pickingMode = PickingMode.Ignore;
			Add(visualElement);
		}
	}
	internal class ColumnMover : PointerManipulator
	{
		private const float k_StartDragDistance = 5f;

		private float m_StartPos;

		private float m_LastPos;

		private bool m_Active;

		private bool m_Moving;

		private bool m_Cancelled;

		private MultiColumnCollectionHeader m_Header;

		private VisualElement m_PreviewElement;

		private MultiColumnHeaderColumnMoveLocationPreview m_LocationPreviewElement;

		private Column m_ColumnToMove;

		private float m_ColumnToMovePos;

		private float m_ColumnToMoveWidth;

		private Column m_DestinationColumn;

		private bool m_MoveBeforeDestination;

		public ColumnLayout columnLayout { get; set; }

		public bool active
		{
			get
			{
				return m_Active;
			}
			set
			{
				if (m_Active != value)
				{
					m_Active = value;
					this.activeChanged?.Invoke(this);
				}
			}
		}

		public bool moving
		{
			get
			{
				return m_Moving;
			}
			set
			{
				if (m_Moving != value)
				{
					m_Moving = value;
					this.movingChanged?.Invoke(this);
				}
			}
		}

		public event Action<ColumnMover> activeChanged;

		public event Action<ColumnMover> movingChanged;

		public ColumnMover()
		{
			base.activators.Add(new ManipulatorActivationFilter
			{
				button = MouseButton.LeftMouse
			});
		}

		protected override void RegisterCallbacksOnTarget()
		{
			base.target.RegisterCallback<MouseDownEvent>(OnMouseDown);
			base.target.RegisterCallback<MouseMoveEvent>(OnMouseMove);
			base.target.RegisterCallback<MouseUpEvent>(OnMouseUp);
			base.target.RegisterCallback<MouseCaptureOutEvent>(OnMouseCaptureOut);
			base.target.RegisterCallback<PointerDownEvent>(OnPointerDown);
			base.target.RegisterCallback<PointerMoveEvent>(OnPointerMove);
			base.target.RegisterCallback<PointerUpEvent>(OnPointerUp);
			base.target.RegisterCallback<PointerCancelEvent>(OnPointerCancel);
			base.target.RegisterCallback<PointerCaptureOutEvent>(OnPointerCaptureOut);
			base.target.RegisterCallback<KeyDownEvent>(OnKeyDown);
		}

		protected override void UnregisterCallbacksFromTarget()
		{
			base.target.UnregisterCallback<MouseDownEvent>(OnMouseDown);
			base.target.UnregisterCallback<MouseMoveEvent>(OnMouseMove);
			base.target.UnregisterCallback<MouseUpEvent>(OnMouseUp);
			base.target.UnregisterCallback<MouseCaptureOutEvent>(OnMouseCaptureOut);
			base.target.UnregisterCallback<PointerDownEvent>(OnPointerDown);
			base.target.UnregisterCallback<PointerMoveEvent>(OnPointerMove);
			base.target.UnregisterCallback<PointerUpEvent>(OnPointerUp);
			base.target.UnregisterCallback<PointerCancelEvent>(OnPointerCancel);
			base.target.UnregisterCallback<PointerCaptureOutEvent>(OnPointerCaptureOut);
			base.target.UnregisterCallback<KeyDownEvent>(OnKeyDown);
		}

		protected void OnMouseDown(MouseDownEvent evt)
		{
			if (CanStartManipulation(evt))
			{
				ProcessDownEvent(evt, evt.localMousePosition, PointerId.mousePointerId);
			}
		}

		protected void OnMouseMove(MouseMoveEvent evt)
		{
			if (active)
			{
				ProcessMoveEvent(evt, evt.localMousePosition);
			}
		}

		protected void OnMouseUp(MouseUpEvent evt)
		{
			if (active && CanStopManipulation(evt))
			{
				ProcessUpEvent(evt, evt.localMousePosition, PointerId.mousePointerId);
			}
		}

		private void OnMouseCaptureOut(MouseCaptureOutEvent evt)
		{
			if (active)
			{
				ProcessCancelEvent(evt, PointerId.mousePointerId);
			}
		}

		private void OnPointerDown(PointerDownEvent evt)
		{
			if (CanStartManipulation(evt))
			{
				if (evt.pointerId != PointerId.mousePointerId)
				{
					ProcessDownEvent(evt, evt.localPosition, evt.pointerId);
					base.target.panel.PreventCompatibilityMouseEvents(evt.pointerId);
				}
				else
				{
					evt.StopImmediatePropagation();
				}
			}
		}

		private void OnPointerMove(PointerMoveEvent evt)
		{
			if (active)
			{
				if (evt.pointerId != PointerId.mousePointerId)
				{
					ProcessMoveEvent(evt, evt.localPosition);
					base.target.panel.PreventCompatibilityMouseEvents(evt.pointerId);
				}
				else
				{
					evt.StopPropagation();
				}
			}
		}

		private void OnPointerUp(PointerUpEvent evt)
		{
			if (active && CanStopManipulation(evt))
			{
				if (evt.pointerId != PointerId.mousePointerId)
				{
					ProcessUpEvent(evt, evt.localPosition, evt.pointerId);
					base.target.panel.PreventCompatibilityMouseEvents(evt.pointerId);
				}
				else
				{
					evt.StopPropagation();
				}
			}
		}

		private void OnPointerCancel(PointerCancelEvent evt)
		{
			if (active && CanStopManipulation(evt) && IsNotMouseEvent(evt.pointerId))
			{
				ProcessCancelEvent(evt, evt.pointerId);
			}
		}

		private void OnPointerCaptureOut(PointerCaptureOutEvent evt)
		{
			if (active && IsNotMouseEvent(evt.pointerId))
			{
				ProcessCancelEvent(evt, evt.pointerId);
			}
		}

		private static bool IsNotMouseEvent(int pointerId)
		{
			return pointerId != PointerId.mousePointerId;
		}

		protected void ProcessCancelEvent(EventBase evt, int pointerId)
		{
			active = false;
			base.target.ReleasePointer(pointerId);
			if (!(evt is IPointerEvent))
			{
				base.target.panel.ProcessPointerCapture(pointerId);
			}
			if (moving)
			{
				EndDragMove(cancelled: true);
			}
			evt.StopPropagation();
		}

		private void OnKeyDown(KeyDownEvent e)
		{
			if (e.keyCode == KeyCode.Escape && moving)
			{
				EndDragMove(cancelled: true);
			}
		}

		private void ProcessDownEvent(EventBase evt, Vector2 localPosition, int pointerId)
		{
			if (active)
			{
				evt.StopImmediatePropagation();
				return;
			}
			base.target.CapturePointer(pointerId);
			if (!(evt is IPointerEvent))
			{
				base.target.panel.ProcessPointerCapture(pointerId);
			}
			VisualElement visualElement = evt.currentTarget as VisualElement;
			MultiColumnCollectionHeader firstAncestorOfType = visualElement.GetFirstAncestorOfType<MultiColumnCollectionHeader>();
			if (firstAncestorOfType.columns.reorderable)
			{
				m_Header = firstAncestorOfType;
				Vector2 vector = visualElement.ChangeCoordinatesTo(m_Header, localPosition);
				columnLayout = m_Header.columnLayout;
				m_Cancelled = false;
				m_StartPos = vector.x;
				active = true;
				evt.StopPropagation();
			}
		}

		private void ProcessMoveEvent(EventBase e, Vector2 localPosition)
		{
			if (!m_Cancelled)
			{
				VisualElement src = e.currentTarget as VisualElement;
				Vector2 vector = src.ChangeCoordinatesTo(m_Header, localPosition);
				if (!moving && Mathf.Abs(m_StartPos - vector.x) > 5f)
				{
					BeginDragMove(m_StartPos);
				}
				if (moving)
				{
					DragMove(vector.x);
				}
				e.StopPropagation();
			}
		}

		private void ProcessUpEvent(EventBase evt, Vector2 localPosition, int pointerId)
		{
			active = false;
			base.target.ReleasePointer(pointerId);
			if (!(evt is IPointerEvent))
			{
				base.target.panel.ProcessPointerCapture(pointerId);
			}
			bool flag = moving || m_Cancelled;
			EndDragMove(cancelled: false);
			if (flag)
			{
				evt.StopImmediatePropagation();
			}
			else
			{
				evt.StopPropagation();
			}
		}

		private void BeginDragMove(float pos)
		{
			float num = 0f;
			Columns columns = columnLayout.columns;
			foreach (Column visible in columns.visibleList)
			{
				num += columnLayout.GetDesiredWidth(visible);
				if (m_ColumnToMove == null && num > pos)
				{
					m_ColumnToMove = visible;
				}
			}
			moving = true;
			m_LastPos = pos;
			m_PreviewElement = new MultiColumnHeaderColumnMovePreview();
			m_LocationPreviewElement = new MultiColumnHeaderColumnMoveLocationPreview();
			m_Header.hierarchy.Add(m_PreviewElement);
			VisualElement visualElement = m_Header.GetFirstAncestorOfType<ScrollView>()?.parent ?? m_Header;
			visualElement.hierarchy.Add(m_LocationPreviewElement);
			m_ColumnToMovePos = columnLayout.GetDesiredPosition(m_ColumnToMove);
			m_ColumnToMoveWidth = columnLayout.GetDesiredWidth(m_ColumnToMove);
			UpdateMoveLocation();
		}

		internal void DragMove(float pos)
		{
			m_LastPos = pos;
			UpdateMoveLocation();
		}

		private void UpdatePreviewPosition()
		{
			m_PreviewElement.style.left = m_ColumnToMovePos + m_LastPos - m_StartPos;
			m_PreviewElement.style.width = m_ColumnToMoveWidth;
			if (m_DestinationColumn != null)
			{
				m_LocationPreviewElement.style.left = columnLayout.GetDesiredPosition(m_DestinationColumn) + ((!m_MoveBeforeDestination) ? columnLayout.GetDesiredWidth(m_DestinationColumn) : 0f);
			}
		}

		private void UpdateMoveLocation()
		{
			float num = 0f;
			m_DestinationColumn = null;
			m_MoveBeforeDestination = false;
			foreach (Column visible in columnLayout.columns.visibleList)
			{
				m_DestinationColumn = visible;
				float desiredWidth = columnLayout.GetDesiredWidth(m_DestinationColumn);
				float num2 = num + desiredWidth / 2f;
				num += desiredWidth;
				if (num > m_LastPos)
				{
					m_MoveBeforeDestination = m_LastPos < num2;
					break;
				}
			}
			UpdatePreviewPosition();
		}

		private void EndDragMove(bool cancelled)
		{
			if (!moving || m_Cancelled)
			{
				return;
			}
			m_Cancelled = cancelled;
			if (!cancelled)
			{
				int num = m_DestinationColumn.displayIndex;
				if (!m_MoveBeforeDestination)
				{
					num++;
				}
				if (m_ColumnToMove.displayIndex < num)
				{
					num--;
				}
				if (m_ColumnToMove.displayIndex != num)
				{
					columnLayout.columns.ReorderDisplay(m_ColumnToMove.displayIndex, num);
				}
			}
			m_PreviewElement?.RemoveFromHierarchy();
			m_PreviewElement = null;
			m_LocationPreviewElement?.RemoveFromHierarchy();
			m_LocationPreviewElement = null;
			m_ColumnToMove = null;
			moving = false;
		}
	}
	internal class MultiColumnHeaderColumnResizePreview : VisualElement
	{
		public static readonly string ussClassName = MultiColumnHeaderColumn.ussClassName + "__resize-preview";

		public static readonly string visualUssClassName = ussClassName + "__visual";

		public MultiColumnHeaderColumnResizePreview()
		{
			AddToClassList(ussClassName);
			base.pickingMode = PickingMode.Ignore;
			VisualElement visualElement = new VisualElement
			{
				pickingMode = PickingMode.Ignore
			};
			visualElement.AddToClassList(visualUssClassName);
			Add(visualElement);
		}
	}
	internal class ColumnResizer : PointerManipulator
	{
		private Vector2 m_Start;

		protected bool m_Active;

		private bool m_Resizing;

		private MultiColumnCollectionHeader m_Header;

		private Column m_Column;

		private VisualElement m_PreviewElement;

		public ColumnLayout columnLayout { get; set; }

		public bool preview { get; set; }

		public ColumnResizer(Column column)
		{
			m_Column = column;
			base.activators.Add(new ManipulatorActivationFilter
			{
				button = MouseButton.LeftMouse
			});
			m_Active = false;
		}

		protected override void RegisterCallbacksOnTarget()
		{
			base.target.RegisterCallback<PointerDownEvent>(OnPointerDown);
			base.target.RegisterCallback<PointerMoveEvent>(OnPointerMove);
			base.target.RegisterCallback<PointerUpEvent>(OnPointerUp);
			base.target.RegisterCallback<KeyDownEvent>(OnKeyDown);
		}

		protected override void UnregisterCallbacksFromTarget()
		{
			base.target.UnregisterCallback<KeyDownEvent>(OnKeyDown);
			base.target.UnregisterCallback<PointerDownEvent>(OnPointerDown);
			base.target.UnregisterCallback<PointerMoveEvent>(OnPointerMove);
			base.target.UnregisterCallback<PointerUpEvent>(OnPointerUp);
		}

		private void OnKeyDown(KeyDownEvent e)
		{
			if (e.keyCode == KeyCode.Escape && m_Resizing && preview)
			{
				EndDragResize(0f, cancelled: true);
			}
		}

		private void OnPointerDown(PointerDownEvent e)
		{
			if (m_Active)
			{
				e.StopImmediatePropagation();
			}
			else
			{
				if (!CanStartManipulation(e))
				{
					return;
				}
				VisualElement visualElement = e.currentTarget as VisualElement;
				m_Header = visualElement.GetFirstAncestorOfType<MultiColumnCollectionHeader>();
				preview = m_Column.collection.resizePreview;
				if (preview)
				{
					if (m_PreviewElement == null)
					{
						m_PreviewElement = new MultiColumnHeaderColumnResizePreview();
					}
					VisualElement visualElement2 = m_Header.GetFirstAncestorOfType<ScrollView>()?.parent ?? m_Header.parent;
					visualElement2.hierarchy.Add(m_PreviewElement);
				}
				columnLayout = m_Header.columnLayout;
				m_Start = visualElement.ChangeCoordinatesTo(m_Header, e.localPosition);
				BeginDragResize(m_Start.x);
				m_Active = true;
				base.target.CaptureMouse();
				e.StopPropagation();
			}
		}

		private void OnPointerMove(PointerMoveEvent e)
		{
			if (m_Active && base.target.HasPointerCapture(e.pointerId))
			{
				VisualElement src = e.currentTarget as VisualElement;
				DragResize(src.ChangeCoordinatesTo(m_Header, e.localPosition).x);
				e.StopPropagation();
			}
		}

		private void OnPointerUp(PointerUpEvent e)
		{
			if (m_Active && base.target.HasPointerCapture(e.pointerId) && CanStopManipulation(e))
			{
				VisualElement src = e.currentTarget as VisualElement;
				EndDragResize(src.ChangeCoordinatesTo(m_Header, e.localPosition).x, cancelled: false);
				m_Active = false;
				base.target.ReleasePointer(e.pointerId);
				e.StopPropagation();
			}
		}

		private void BeginDragResize(float pos)
		{
			m_Resizing = true;
			columnLayout?.BeginDragResize(m_Column, m_Start.x, preview);
			if (preview)
			{
				UpdatePreviewPosition();
			}
		}

		private void DragResize(float pos)
		{
			if (m_Resizing)
			{
				columnLayout?.DragResize(m_Column, pos);
				if (preview)
				{
					UpdatePreviewPosition();
				}
			}
		}

		private void UpdatePreviewPosition()
		{
			m_PreviewElement.style.left = columnLayout.GetDesiredPosition(m_Column) + columnLayout.GetDesiredWidth(m_Column);
		}

		private void EndDragResize(float pos, bool cancelled)
		{
			if (m_Resizing)
			{
				if (preview)
				{
					m_PreviewElement?.RemoveFromHierarchy();
					m_PreviewElement = null;
				}
				columnLayout?.EndDragResize(m_Column, cancelled);
				m_Resizing = false;
			}
		}
	}
	internal class MultiColumnCollectionHeader : VisualElement, IDisposable
	{
		[Serializable]
		private class ViewState
		{
			[Serializable]
			private struct ColumnState
			{
				public int index;

				public string name;

				public float actualWidth;

				public Length width;

				public bool visible;
			}

			[SerializeField]
			private bool m_HasPersistedData;

			[SerializeField]
			private List<SortColumnDescription> m_SortDescriptions = new List<SortColumnDescription>();

			[SerializeField]
			private List<ColumnState> m_OrderedColumnStates = new List<ColumnState>();

			internal void Save(MultiColumnCollectionHeader header)
			{
				m_SortDescriptions.Clear();
				m_OrderedColumnStates.Clear();
				foreach (SortColumnDescription sortDescription in header.sortDescriptions)
				{
					m_SortDescriptions.Add(sortDescription);
				}
				foreach (Column display in header.columns.displayList)
				{
					ColumnState item = new ColumnState
					{
						index = display.index,
						name = display.name,
						actualWidth = display.desiredWidth,
						width = display.width,
						visible = display.visible
					};
					m_OrderedColumnStates.Add(item);
				}
				m_HasPersistedData = true;
			}

			internal void Apply(MultiColumnCollectionHeader header)
			{
				if (!m_HasPersistedData)
				{
					return;
				}
				int num = Math.Min(m_OrderedColumnStates.Count, header.columns.Count);
				int num2 = 0;
				for (int i = 0; i < m_OrderedColumnStates.Count && num2 < num; i++)
				{
					ColumnState columnState = m_OrderedColumnStates[i];
					Column column = null;
					if (!string.IsNullOrEmpty(columnState.name))
					{
						if (header.columns.Contains(columnState.name))
						{
							column = header.columns[columnState.name];
						}
					}
					else
					{
						if (columnState.index > header.columns.Count - 1)
						{
							continue;
						}
						column = header.columns[columnState.index];
						if (!string.IsNullOrEmpty(column.name))
						{
							column = null;
						}
					}
					if (column != null)
					{
						header.columns.ReorderDisplay(column.displayIndex, num2++);
						column.visible = columnState.visible;
						column.width = columnState.width;
						column.desiredWidth = columnState.actualWidth;
					}
				}
				header.sortDescriptions.Clear();
				foreach (SortColumnDescription sortDescription in m_SortDescriptions)
				{
					header.sortDescriptions.Add(sortDescription);
				}
			}
		}

		internal class ColumnData
		{
			public MultiColumnHeaderColumn control { get; set; }

			public MultiColumnHeaderColumnResizeHandle resizeHandle { get; set; }
		}

		private struct SortedColumnState
		{
			public SortColumnDescription columnDesc;

			public SortDirection direction;

			public SortedColumnState(SortColumnDescription desc, SortDirection dir)
			{
				columnDesc = desc;
				direction = dir;
			}
		}

		private const int kMaxStableLayoutPassCount = 2;

		public static readonly string ussClassName = "unity-multi-column-header";

		public static readonly string columnContainerUssClassName = ussClassName + "__column-container";

		public static readonly string handleContainerUssClassName = ussClassName + "__resize-handle-container";

		public static readonly string reorderableUssClassName = ussClassName + "__header";

		private bool m_SortingEnabled;

		private List<SortColumnDescription> m_SortedColumns;

		private SortColumnDescriptions m_SortDescriptions;

		private List<SortedColumnState> m_OldSortedColumnStates = new List<SortedColumnState>();

		private bool m_SortingUpdatesTemporarilyDisabled;

		private ViewState m_ViewState;

		private bool m_ApplyingViewState;

		private bool m_DoLayoutScheduled;

		internal bool isApplyingViewState => m_ApplyingViewState;

		public Dictionary<Column, ColumnData> columnDataMap { get; } = new Dictionary<Column, ColumnData>();

		public ColumnLayout columnLayout { get; }

		public VisualElement columnContainer { get; }

		public VisualElement resizeHandleContainer { get; }

		public IEnumerable<SortColumnDescription> sortedColumns => m_SortedColumns;

		public SortColumnDescriptions sortDescriptions
		{
			get
			{
				return m_SortDescriptions;
			}
			protected internal set
			{
				m_SortDescriptions = value;
				m_SortDescriptions.changed += UpdateSortedColumns;
				UpdateSortedColumns();
			}
		}

		public Columns columns { get; }

		public bool sortingEnabled
		{
			get
			{
				return m_SortingEnabled;
			}
			set
			{
				if (m_SortingEnabled != value)
				{
					m_SortingEnabled = value;
					UpdateSortingStatus();
					UpdateSortedColumns();
				}
			}
		}

		public event Action<int, float> columnResized;

		public event Action columnSortingChanged;

		public event Action<ContextualMenuPopulateEvent, Column> contextMenuPopulateEvent;

		internal event Action viewDataRestored;

		public MultiColumnCollectionHeader()
			: this(new Columns(), new SortColumnDescriptions(), new List<SortColumnDescription>())
		{
		}

		public MultiColumnCollectionHeader(Columns columns, SortColumnDescriptions sortDescriptions, List<SortColumnDescription> sortedColumns)
		{
			AddToClassList(ussClassName);
			this.columns = columns;
			m_SortedColumns = sortedColumns;
			this.sortDescriptions = sortDescriptions;
			columnContainer = new VisualElement
			{
				pickingMode = PickingMode.Ignore
			};
			columnContainer.AddToClassList(columnContainerUssClassName);
			Add(columnContainer);
			resizeHandleContainer = new VisualElement
			{
				pickingMode = PickingMode.Ignore
			};
			resizeHandleContainer.AddToClassList(handleContainerUssClassName);
			resizeHandleContainer.StretchToParentSize();
			Add(resizeHandleContainer);
			columnLayout = new ColumnLayout(columns);
			columnLayout.layoutRequested += ScheduleDoLayout;
			foreach (Column visible in columns.visibleList)
			{
				OnColumnAdded(visible);
			}
			this.columns.columnAdded += OnColumnAdded;
			this.columns.columnRemoved += OnColumnRemoved;
			this.columns.columnChanged += OnColumnChanged;
			this.columns.columnReordered += OnColumnReordered;
			this.columns.columnResized += OnColumnResized;
			this.AddManipulator(new ContextualMenuManipulator(OnContextualMenuManipulator));
			RegisterCallback<GeometryChangedEvent>(OnGeometryChanged);
		}

		private void ScheduleDoLayout()
		{
			if (!m_DoLayoutScheduled)
			{
				base.schedule.Execute(DoLayout);
				m_DoLayoutScheduled = true;
			}
		}

		private void ResizeToFit()
		{
			columnLayout.ResizeToFit(base.layout.width);
		}

		private void UpdateSortedColumns()
		{
			if (m_SortingUpdatesTemporarilyDisabled)
			{
				return;
			}
			List<SortedColumnState> value;
			using (CollectionPool<List<SortedColumnState>, SortedColumnState>.Get(out value))
			{
				if (sortingEnabled)
				{
					foreach (SortColumnDescription sortDescription in sortDescriptions)
					{
						Column column = null;
						if (sortDescription.columnIndex != -1)
						{
							column = columns[sortDescription.columnIndex];
						}
						else if (!string.IsNullOrEmpty(sortDescription.columnName))
						{
							column = columns[sortDescription.columnName];
						}
						if (column != null && column.sortable)
						{
							sortDescription.column = column;
							value.Add(new SortedColumnState(sortDescription, sortDescription.direction));
						}
						else
						{
							sortDescription.column = null;
						}
					}
				}
				if (m_OldSortedColumnStates.SequenceEqual(value))
				{
					return;
				}
				m_SortedColumns.Clear();
				foreach (SortedColumnState item in value)
				{
					m_SortedColumns.Add(item.columnDesc);
				}
				m_OldSortedColumnStates.CopyFrom(value);
			}
			SaveViewState();
			RaiseColumnSortingChanged();
		}

		private void UpdateColumnControls()
		{
			bool flag = false;
			Column key = null;
			foreach (Column visible in columns.visibleList)
			{
				flag |= visible.stretchable;
				ColumnData value = null;
				if (columnDataMap.TryGetValue(visible, out value))
				{
					value.control.style.minWidth = visible.minWidth;
					value.control.style.maxWidth = visible.maxWidth;
					value.resizeHandle.style.display = ((!columns.resizable || !visible.resizable) ? DisplayStyle.None : DisplayStyle.Flex);
				}
				key = visible;
			}
			if (flag)
			{
				columnContainer.style.flexGrow = 1f;
				if (columns.stretchMode == Columns.StretchMode.GrowAndFill && columnDataMap.TryGetValue(key, out var value2))
				{
					value2.resizeHandle.style.display = DisplayStyle.None;
				}
			}
			else
			{
				columnContainer.style.flexGrow = 0f;
			}
			UpdateSortingStatus();
		}

		private void OnColumnAdded(Column column, int index)
		{
			OnColumnAdded(column);
		}

		private void OnColumnAdded(Column column)
		{
			if (!columnDataMap.ContainsKey(column))
			{
				MultiColumnHeaderColumn multiColumnHeaderColumn = new MultiColumnHeaderColumn(column);
				MultiColumnHeaderColumnResizeHandle multiColumnHeaderColumnResizeHandle = new MultiColumnHeaderColumnResizeHandle();
				multiColumnHeaderColumn.RegisterCallback<GeometryChangedEvent>(OnColumnControlGeometryChanged);
				multiColumnHeaderColumn.clickable.clickedWithEventInfo += OnColumnClicked;
				multiColumnHeaderColumn.mover.activeChanged += OnMoveManipulatorActivated;
				multiColumnHeaderColumnResizeHandle.dragArea.AddManipulator(new ColumnResizer(column));
				columnDataMap[column] = new ColumnData
				{
					control = multiColumnHeaderColumn,
					resizeHandle = multiColumnHeaderColumnResizeHandle
				};
				if (column.visible)
				{
					columnContainer.Insert(column.visibleIndex, multiColumnHeaderColumn);
					resizeHandleContainer.Insert(column.visibleIndex, multiColumnHeaderColumnResizeHandle);
				}
				else
				{
					OnColumnRemoved(column);
				}
				UpdateColumnControls();
				SaveViewState();
			}
		}

		private void OnColumnRemoved(Column column)
		{
			if (columnDataMap.ContainsKey(column))
			{
				ColumnData columnData = columnDataMap[column];
				columnData.control.UnregisterCallback<GeometryChangedEvent>(OnColumnControlGeometryChanged);
				columnData.control.clickable.clickedWithEventInfo -= OnColumnClicked;
				columnData.control.mover.activeChanged -= OnMoveManipulatorActivated;
				columnData.control.RemoveFromHierarchy();
				columnData.resizeHandle.RemoveFromHierarchy();
				columnDataMap.Remove(column);
				UpdateColumnControls();
				SaveViewState();
			}
		}

		private void OnColumnChanged(Column column, ColumnDataType type)
		{
			if (type == ColumnDataType.Visibility)
			{
				if (column.visible)
				{
					OnColumnAdded(column);
				}
				else
				{
					OnColumnRemoved(column);
				}
				ApplyColumnSorting();
			}
			UpdateColumnControls();
			if (type == ColumnDataType.Visibility)
			{
				SaveViewState();
			}
		}

		private void OnColumnReordered(Column column, int from, int to)
		{
			if (!column.visible || from == to)
			{
				return;
			}
			if (columnDataMap.TryGetValue(column, out var value))
			{
				int num = column.visibleIndex;
				if (num == columns.visibleList.Count() - 1)
				{
					value.control.BringToFront();
				}
				else
				{
					if (to > from)
					{
						num++;
					}
					value.control.PlaceBehind(columnContainer[num]);
					value.resizeHandle.PlaceBehind(resizeHandleContainer[num]);
				}
			}
			UpdateColumnControls();
			SaveViewState();
		}

		private void OnColumnResized(Column column)
		{
			SaveViewState();
		}

		private void OnContextualMenuManipulator(ContextualMenuPopulateEvent evt)
		{
			Column column = null;
			bool flag = columns.visibleList.Count() > 0;
			foreach (Column visible in columns.visibleList)
			{
				if (columns.stretchMode == Columns.StretchMode.GrowAndFill && flag && visible.stretchable)
				{
					flag = false;
				}
				if (column == null && columnDataMap.TryGetValue(visible, out var value) && value.control.layout.Contains(evt.localMousePosition))
				{
					column = visible;
				}
			}
			evt.menu.AppendAction("Resize To Fit", delegate
			{
				ResizeToFit();
			}, flag ? DropdownMenuAction.Status.Normal : DropdownMenuAction.Status.Disabled);
			evt.menu.AppendSeparator();
			foreach (Column column2 in columns)
			{
				string text = column2.title;
				if (string.IsNullOrEmpty(text))
				{
					text = column2.name;
				}
				if (string.IsNullOrEmpty(text))
				{
					text = "Unnamed Column_" + column2.index;
				}
				evt.menu.AppendAction(text, delegate
				{
					column2.visible = !column2.visible;
				}, delegate
				{
					if (!string.IsNullOrEmpty(column2.name) && columns.primaryColumnName == column2.name)
					{
						return DropdownMenuAction.Status.Disabled;
					}
					if (!column2.optional)
					{
						return DropdownMenuAction.Status.Disabled;
					}
					return (!column2.visible) ? DropdownMenuAction.Status.Normal : DropdownMenuAction.Status.Checked;
				});
			}
			this.contextMenuPopulateEvent?.Invoke(evt, column);
		}

		private void OnMoveManipulatorActivated(ColumnMover mover)
		{
			resizeHandleContainer.style.display = (mover.active ? DisplayStyle.None : DisplayStyle.Flex);
		}

		private void OnGeometryChanged(GeometryChangedEvent e)
		{
			if (!float.IsNaN(e.newRect.width) && !float.IsNaN(e.newRect.height))
			{
				columnLayout.Dirty();
				if (e.layoutPass > 2)
				{
					ScheduleDoLayout();
				}
				else
				{
					DoLayout();
				}
			}
		}

		private void DoLayout()
		{
			columnLayout.DoLayout(base.layout.width);
			m_DoLayoutScheduled = false;
		}

		private void OnColumnControlGeometryChanged(GeometryChangedEvent evt)
		{
			if (evt.target is MultiColumnHeaderColumn multiColumnHeaderColumn)
			{
				ColumnData columnData = columnDataMap[multiColumnHeaderColumn.column];
				columnData.resizeHandle.style.left = multiColumnHeaderColumn.layout.xMax;
				if (!(Math.Abs(evt.newRect.width - evt.oldRect.width) < float.Epsilon))
				{
					RaiseColumnResized(columnContainer.IndexOf(evt.target as VisualElement));
				}
			}
		}

		private void OnColumnClicked(EventBase evt)
		{
			if (!sortingEnabled || !(evt.currentTarget is MultiColumnHeaderColumn multiColumnHeaderColumn) || !multiColumnHeaderColumn.column.sortable)
			{
				return;
			}
			EventModifiers modifiers;
			if (evt is IPointerEvent pointerEvent)
			{
				modifiers = pointerEvent.modifiers;
			}
			else
			{
				if (!(evt is IMouseEvent mouseEvent))
				{
					return;
				}
				modifiers = mouseEvent.modifiers;
			}
			m_SortingUpdatesTemporarilyDisabled = true;
			try
			{
				UpdateSortColumnDescriptionsOnClick(multiColumnHeaderColumn.column, modifiers);
			}
			finally
			{
				m_SortingUpdatesTemporarilyDisabled = false;
			}
			UpdateSortedColumns();
		}

		private void UpdateSortColumnDescriptionsOnClick(Column column, EventModifiers modifiers)
		{
			SortColumnDescription sortColumnDescription = sortDescriptions.FirstOrDefault((SortColumnDescription d) => d.column == column || (!string.IsNullOrEmpty(column.name) && d.columnName == column.name) || d.columnIndex == column.index);
			if (sortColumnDescription != null)
			{
				if (modifiers == EventModifiers.Shift)
				{
					sortDescriptions.Remove(sortColumnDescription);
					return;
				}
				sortColumnDescription.direction = ((sortColumnDescription.direction == SortDirection.Ascending) ? SortDirection.Descending : SortDirection.Ascending);
			}
			else
			{
				sortColumnDescription = (string.IsNullOrEmpty(column.name) ? new SortColumnDescription(column.index, SortDirection.Ascending) : new SortColumnDescription(column.name, SortDirection.Ascending));
			}
			EventModifiers eventModifiers = EventModifiers.Control;
			RuntimePlatform platform = Application.platform;
			if (platform == RuntimePlatform.OSXEditor || platform == RuntimePlatform.OSXPlayer)
			{
				eventModifiers = EventModifiers.Command;
			}
			if (modifiers != eventModifiers)
			{
				sortDescriptions.Clear();
			}
			if (!sortDescriptions.Contains(sortColumnDescription))
			{
				sortDescriptions.Add(sortColumnDescription);
			}
		}

		public void ScrollHorizontally(float horizontalOffset)
		{
			base.transform.position = new Vector3(0f - horizontalOffset, base.transform.position.y, base.transform.position.z);
		}

		private void RaiseColumnResized(int columnIndex)
		{
			this.columnResized?.Invoke(columnIndex, columnContainer[columnIndex].resolvedStyle.width);
		}

		private void RaiseColumnSortingChanged()
		{
			ApplyColumnSorting();
			if (!m_ApplyingViewState)
			{
				this.columnSortingChanged?.Invoke();
			}
		}

		private void ApplyColumnSorting()
		{
			foreach (Column visible in columns.visibleList)
			{
				if (columnDataMap.TryGetValue(visible, out var value))
				{
					value.control.sortOrderLabel = "";
					value.control.RemoveFromClassList(MultiColumnHeaderColumn.sortedAscendingUssClassName);
					value.control.RemoveFromClassList(MultiColumnHeaderColumn.sortedDescendingUssClassName);
				}
			}
			List<ColumnData> list = new List<ColumnData>();
			foreach (SortColumnDescription sortedColumn in sortedColumns)
			{
				if (columnDataMap.TryGetValue(sortedColumn.column, out var value2))
				{
					list.Add(value2);
					if (sortedColumn.direction == SortDirection.Ascending)
					{
						value2.control.AddToClassList(MultiColumnHeaderColumn.sortedAscendingUssClassName);
					}
					else
					{
						value2.control.AddToClassList(MultiColumnHeaderColumn.sortedDescendingUssClassName);
					}
				}
			}
			if (list.Count > 1)
			{
				for (int i = 0; i < list.Count; i++)
				{
					list[i].control.sortOrderLabel = (i + 1).ToString();
				}
			}
		}

		private void UpdateSortingStatus()
		{
			bool flag = false;
			foreach (Column visible in columns.visibleList)
			{
				if (columnDataMap.TryGetValue(visible, out var _) && sortingEnabled && visible.sortable)
				{
					flag = true;
				}
			}
			foreach (Column visible2 in columns.visibleList)
			{
				if (columnDataMap.TryGetValue(visible2, out var value2))
				{
					if (flag)
					{
						value2.control.AddToClassList(MultiColumnHeaderColumn.sortableUssClassName);
					}
					else
					{
						value2.control.RemoveFromClassList(MultiColumnHeaderColumn.sortableUssClassName);
					}
				}
			}
		}

		internal override void OnViewDataReady()
		{
			try
			{
				m_ApplyingViewState = true;
				base.OnViewDataReady();
				string fullHierarchicalViewDataKey = GetFullHierarchicalViewDataKey();
				m_ViewState = GetOrCreateViewData<ViewState>(m_ViewState, fullHierarchicalViewDataKey);
				m_ViewState.Apply(this);
				this.viewDataRestored?.Invoke();
			}
			finally
			{
				m_ApplyingViewState = false;
			}
		}

		private void SaveViewState()
		{
			if (!m_ApplyingViewState)
			{
				m_ViewState?.Save(this);
				SaveViewData();
			}
		}

		public void Dispose()
		{
			sortDescriptions.changed -= UpdateSortedColumns;
			columnLayout.layoutRequested -= ScheduleDoLayout;
			columns.columnAdded -= OnColumnAdded;
			columns.columnRemoved -= OnColumnRemoved;
			columns.columnChanged -= OnColumnChanged;
			columns.columnReordered -= OnColumnReordered;
			columns.columnResized -= OnColumnResized;
			foreach (ColumnData value in columnDataMap.Values)
			{
				value.control.clickable.clickedWithEventInfo -= OnColumnClicked;
				value.control.mover.activeChanged -= OnMoveManipulatorActivated;
			}
		}
	}
	internal class MultiColumnHeaderColumnSortIndicator : VisualElement
	{
		public static readonly string ussClassName = MultiColumnHeaderColumn.ussClassName + "__sort-indicator";

		public static readonly string arrowUssClassName = ussClassName + "__arrow";

		public static readonly string indexLabelUssClassName = ussClassName + "__index-label";

		private Label m_IndexLabel;

		public string sortOrderLabel
		{
			get
			{
				return m_IndexLabel.text;
			}
			set
			{
				m_IndexLabel.text = value;
			}
		}

		public MultiColumnHeaderColumnSortIndicator()
		{
			AddToClassList(ussClassName);
			base.pickingMode = PickingMode.Ignore;
			VisualElement visualElement = new VisualElement
			{
				pickingMode = PickingMode.Ignore
			};
			visualElement.AddToClassList(arrowUssClassName);
			Add(visualElement);
			m_IndexLabel = new Label
			{
				pickingMode = PickingMode.Ignore
			};
			m_IndexLabel.AddToClassList(indexLabelUssClassName);
			Add(m_IndexLabel);
		}
	}
	internal class MultiColumnHeaderColumnIcon : Image
	{
		public new static readonly string ussClassName = MultiColumnHeaderColumn.ussClassName + "__icon";

		public bool isImageInline { get; set; }

		public MultiColumnHeaderColumnIcon()
		{
			AddToClassList(ussClassName);
			RegisterCallback<CustomStyleResolvedEvent>(delegate
			{
				UpdateClassList();
			});
		}

		public void UpdateClassList()
		{
			base.parent.RemoveFromClassList(MultiColumnHeaderColumn.hasIconUssClassName);
			if (base.image != null || base.sprite != null || base.vectorImage != null)
			{
				base.parent.AddToClassList(MultiColumnHeaderColumn.hasIconUssClassName);
			}
		}
	}
	internal class MultiColumnHeaderColumn : VisualElement
	{
		public static readonly string ussClassName = MultiColumnCollectionHeader.ussClassName + "__column";

		public static readonly string sortableUssClassName = ussClassName + "--sortable";

		public static readonly string sortedAscendingUssClassName = ussClassName + "--sorted-ascending";

		public static readonly string sortedDescendingUssClassName = ussClassName + "--sorted-descending";

		public static readonly string movingUssClassName = ussClassName + "--moving";

		public static readonly string contentContainerUssClassName = ussClassName + "__content-container";

		public static readonly string contentUssClassName = ussClassName + "__content";

		public static readonly string defaultContentUssClassName = ussClassName + "__default-content";

		public static readonly string hasIconUssClassName = contentUssClassName + "--has-icon";

		public static readonly string hasTitleUssClassName = contentUssClassName + "--has-title";

		public static readonly string titleUssClassName = ussClassName + "__title";

		public static readonly string iconElementName = "unity-multi-column-header-column-icon";

		public static readonly string titleElementName = "unity-multi-column-header-column-title";

		private static readonly string s_BoundVEPropertyName = "__bound";

		private static readonly string s_BindingCallbackVEPropertyName = "__binding-callback";

		private static readonly string s_UnbindingCallbackVEPropertyName = "__unbinding-callback";

		private static readonly string s_DestroyCallbackVEPropertyName = "__destroy-callback";

		private VisualElement m_ContentContainer;

		private VisualElement m_Content;

		private MultiColumnHeaderColumnSortIndicator m_SortIndicatorContainer;

		private IVisualElementScheduledItem m_ScheduledHeaderTemplateUpdate;

		public Clickable clickable { get; private set; }

		public ColumnMover mover { get; private set; }

		public string sortOrderLabel
		{
			get
			{
				return m_SortIndicatorContainer.sortOrderLabel;
			}
			set
			{
				m_SortIndicatorContainer.sortOrderLabel = value;
			}
		}

		public Column column { get; set; }

		internal Label title => content?.Q<Label>(titleElementName);

		public VisualElement content
		{
			get
			{
				return m_Content;
			}
			set
			{
				if (m_Content != null)
				{
					if (m_Content.parent == m_ContentContainer)
					{
						m_Content.RemoveFromHierarchy();
					}
					DestroyHeaderContent();
					m_Content = null;
				}
				m_Content = value;
				if (m_Content != null)
				{
					m_Content.AddToClassList(contentUssClassName);
					m_ContentContainer.Add(m_Content);
				}
			}
		}

		private bool isContentBound
		{
			get
			{
				return m_Content != null && (bool)m_Content.GetProperty(s_BoundVEPropertyName);
			}
			set
			{
				m_Content?.SetProperty(s_BoundVEPropertyName, value);
			}
		}

		public MultiColumnHeaderColumn()
			: this(new Column())
		{
		}

		public MultiColumnHeaderColumn(Column column)
		{
			this.column = column;
			column.changed += delegate(Column c, ColumnDataType role)
			{
				if (role == ColumnDataType.HeaderTemplate)
				{
					m_ScheduledHeaderTemplateUpdate?.Pause();
					m_ScheduledHeaderTemplateUpdate = base.schedule.Execute(UpdateHeaderTemplate);
				}
				else
				{
					UpdateDataFromColumn();
				}
			};
			column.resized += delegate
			{
				UpdateGeometryFromColumn();
			};
			AddToClassList(ussClassName);
			base.style.marginLeft = 0f;
			base.style.marginTop = 0f;
			base.style.marginRight = 0f;
			base.style.marginBottom = 0f;
			base.style.paddingLeft = 0f;
			base.style.paddingTop = 0f;
			base.style.paddingRight = 0f;
			base.style.paddingBottom = 0f;
			Add(m_SortIndicatorContainer = new MultiColumnHeaderColumnSortIndicator());
			m_ContentContainer = new VisualElement();
			m_ContentContainer.style.flexGrow = 1f;
			m_ContentContainer.style.flexShrink = 1f;
			m_ContentContainer.AddToClassList(contentContainerUssClassName);
			Add(m_ContentContainer);
			UpdateHeaderTemplate();
			UpdateGeometryFromColumn();
			InitManipulators();
		}

		private void InitManipulators()
		{
			ColumnMover manipulator = (mover = new ColumnMover());
			this.AddManipulator(manipulator);
			mover.movingChanged += delegate
			{
				if (mover.moving)
				{
					AddToClassList(movingUssClassName);
				}
				else
				{
					RemoveFromClassList(movingUssClassName);
				}
			};
			Clickable manipulator2 = (this.clickable = new Clickable((Action)null));
			this.AddManipulator(manipulator2);
			this.clickable.activators.Add(new ManipulatorActivationFilter
			{
				button = MouseButton.LeftMouse,
				modifiers = EventModifiers.Shift
			});
			EventModifiers modifiers = EventModifiers.Control;
			RuntimePlatform platform = Application.platform;
			if (platform == RuntimePlatform.OSXEditor || platform == RuntimePlatform.OSXPlayer)
			{
				modifiers = EventModifiers.Command;
			}
			this.clickable.activators.Add(new ManipulatorActivationFilter
			{
				button = MouseButton.LeftMouse,
				modifiers = modifiers
			});
		}

		private void UpdateDataFromColumn()
		{
			base.name = column.name;
			UnbindHeaderContent();
			BindHeaderContent();
		}

		private void BindHeaderContent()
		{
			if (!isContentBound)
			{
				if (content.GetProperty(s_BindingCallbackVEPropertyName) is Action<VisualElement> action)
				{
					action(content);
				}
				isContentBound = true;
			}
		}

		private void UnbindHeaderContent()
		{
			if (isContentBound)
			{
				if (content.GetProperty(s_UnbindingCallbackVEPropertyName) is Action<VisualElement> action)
				{
					action(content);
				}
				isContentBound = false;
			}
		}

		private void DestroyHeaderContent()
		{
			UnbindHeaderContent();
			if (content.GetProperty(s_DestroyCallbackVEPropertyName) is Action<VisualElement> action)
			{
				action(content);
			}
		}

		private VisualElement CreateDefaultHeaderContent()
		{
			VisualElement visualElement = new VisualElement
			{
				pickingMode = PickingMode.Ignore
			};
			visualElement.AddToClassList(defaultContentUssClassName);
			MultiColumnHeaderColumnIcon child = new MultiColumnHeaderColumnIcon
			{
				name = iconElementName,
				pickingMode = PickingMode.Ignore
			};
			Label label = new Label
			{
				name = titleElementName,
				pickingMode = PickingMode.Ignore
			};
			label.AddToClassList(titleUssClassName);
			visualElement.Add(child);
			visualElement.Add(label);
			return visualElement;
		}

		private void DefaultBindHeaderContent(VisualElement ve)
		{
			Label label = ve.Q<Label>(titleElementName);
			MultiColumnHeaderColumnIcon multiColumnHeaderColumnIcon = ve.Q<MultiColumnHeaderColumnIcon>();
			ve.RemoveFromClassList(hasTitleUssClassName);
			if (label != null)
			{
				label.text = column.title;
			}
			if (!string.IsNullOrEmpty(column.title))
			{
				ve.AddToClassList(hasTitleUssClassName);
			}
			if (multiColumnHeaderColumnIcon != null)
			{
				if (column.icon.texture != null || column.icon.sprite != null || column.icon.vectorImage != null)
				{
					multiColumnHeaderColumnIcon.isImageInline = true;
					multiColumnHeaderColumnIcon.image = column.icon.texture;
					multiColumnHeaderColumnIcon.sprite = column.icon.sprite;
					multiColumnHeaderColumnIcon.vectorImage = column.icon.vectorImage;
				}
				else if (multiColumnHeaderColumnIcon.isImageInline)
				{
					multiColumnHeaderColumnIcon.image = null;
					multiColumnHeaderColumnIcon.sprite = null;
					multiColumnHeaderColumnIcon.vectorImage = null;
				}
				multiColumnHeaderColumnIcon.UpdateClassList();
			}
		}

		private void UpdateHeaderTemplate()
		{
			Func<VisualElement> func = column.makeHeader;
			Action<VisualElement> value = column.bindHeader;
			Action<VisualElement> value2 = column.unbindHeader;
			Action<VisualElement> value3 = column.destroyHeader;
			if (func == null)
			{
				func = CreateDefaultHeaderContent;
				value = DefaultBindHeaderContent;
				value2 = null;
				value3 = null;
			}
			content = func();
			content.SetProperty(s_BindingCallbackVEPropertyName, value);
			content.SetProperty(s_UnbindingCallbackVEPropertyName, value2);
			content.SetProperty(s_DestroyCallbackVEPropertyName, value3);
			isContentBound = false;
			m_ScheduledHeaderTemplateUpdate = null;
			UpdateDataFromColumn();
		}

		private void UpdateGeometryFromColumn()
		{
			if (!float.IsNaN(column.desiredWidth))
			{
				base.style.width = column.desiredWidth;
			}
		}
	}
	internal class MultiColumnHeaderColumnResizeHandle : VisualElement
	{
		public static readonly string ussClassName = MultiColumnCollectionHeader.ussClassName + "__column-resize-handle";

		public static readonly string dragAreaUssClassName = ussClassName + "__drag-area";

		public VisualElement dragArea { get; }

		public MultiColumnHeaderColumnResizeHandle()
		{
			AddToClassList(ussClassName);
			dragArea = new VisualElement
			{
				focusable = true
			};
			dragArea.AddToClassList(dragAreaUssClassName);
			Add(dragArea);
		}
	}
}
namespace UnityEngine.UIElements.Collections
{
	internal static class DictionaryExtensions
	{
		public static TValue Get<TKey, TValue>(this IDictionary<TKey, TValue> dict, TKey key, TValue fallbackValue = default(TValue))
		{
			TValue value;
			return dict.TryGetValue(key, out value) ? value : fallbackValue;
		}
	}
}
