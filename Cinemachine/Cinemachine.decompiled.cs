#define UNITY_ASSERTIONS
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using Cinemachine;
using Cinemachine.Utility;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Events;
using UnityEngine.Playables;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.Timeline;
using UnityEngine.UI;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: InternalsVisibleTo("com.unity.cinemachine.editor")]
[assembly: InternalsVisibleTo("Cinemachine.Runtime.Tests")]
[assembly: AssemblyVersion("0.0.0.0")]
[AddComponentMenu("")]
[ExecuteAlways]
[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/api/Cinemachine.CinemachineCameraOffset.html")]
[SaveDuringPlay]
public class CinemachineCameraOffset : CinemachineExtension
{
	[Tooltip("Offset the camera's position by this much (camera space)")]
	public Vector3 m_Offset = Vector3.zero;

	[Tooltip("When to apply the offset")]
	public CinemachineCore.Stage m_ApplyAfter = CinemachineCore.Stage.Aim;

	[Tooltip("If applying offset after aim, re-adjust the aim to preserve the screen position of the LookAt target as much as possible")]
	public bool m_PreserveComposition;

	protected override void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, CinemachineCore.Stage stage, ref CameraState state, float deltaTime)
	{
		if (stage == m_ApplyAfter)
		{
			bool num = m_PreserveComposition && state.HasLookAt && stage > CinemachineCore.Stage.Body;
			Vector3 vector = Vector2.zero;
			if (num)
			{
				vector = state.RawOrientation.GetCameraRotationToTarget(state.ReferenceLookAt - state.CorrectedPosition, state.ReferenceUp);
			}
			Vector3 vector2 = state.RawOrientation * m_Offset;
			state.PositionCorrection += vector2;
			if (!num)
			{
				state.ReferenceLookAt += vector2;
				return;
			}
			Quaternion orient = Quaternion.LookRotation(state.ReferenceLookAt - state.CorrectedPosition, state.ReferenceUp);
			orient = orient.ApplyCameraRotation(-vector, state.ReferenceUp);
			state.RawOrientation = orient;
		}
	}
}
[AddComponentMenu("")]
[ExecuteAlways]
[SaveDuringPlay]
[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineRecomposer.html")]
public class CinemachineRecomposer : CinemachineExtension
{
	[Tooltip("When to apply the adjustment")]
	public CinemachineCore.Stage m_ApplyAfter;

	[Tooltip("Tilt the camera by this much")]
	public float m_Tilt;

	[Tooltip("Pan the camera by this much")]
	public float m_Pan;

	[Tooltip("Roll the camera by this much")]
	public float m_Dutch;

	[Tooltip("Scale the zoom by this amount (normal = 1)")]
	public float m_ZoomScale;

	[Range(0f, 1f)]
	[Tooltip("Lowering this value relaxes the camera's attention to the Follow target (normal = 1)")]
	public float m_FollowAttachment;

	[Range(0f, 1f)]
	[Tooltip("Lowering this value relaxes the camera's attention to the LookAt target (normal = 1)")]
	public float m_LookAtAttachment;

	private void Reset()
	{
		m_ApplyAfter = CinemachineCore.Stage.Finalize;
		m_Tilt = 0f;
		m_Pan = 0f;
		m_Dutch = 0f;
		m_ZoomScale = 1f;
		m_FollowAttachment = 1f;
		m_LookAtAttachment = 1f;
	}

	private void OnValidate()
	{
		m_ZoomScale = Mathf.Max(0.01f, m_ZoomScale);
		m_FollowAttachment = Mathf.Clamp01(m_FollowAttachment);
		m_LookAtAttachment = Mathf.Clamp01(m_LookAtAttachment);
	}

	public override void PrePipelineMutateCameraStateCallback(CinemachineVirtualCameraBase vcam, ref CameraState curState, float deltaTime)
	{
		vcam.FollowTargetAttachment = m_FollowAttachment;
		vcam.LookAtTargetAttachment = m_LookAtAttachment;
	}

	protected override void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, CinemachineCore.Stage stage, ref CameraState state, float deltaTime)
	{
		if (stage == m_ApplyAfter)
		{
			LensSettings lens = state.Lens;
			Quaternion quaternion = state.RawOrientation * Quaternion.AngleAxis(m_Tilt, Vector3.right);
			Quaternion quaternion2 = Quaternion.AngleAxis(m_Pan, state.ReferenceUp) * quaternion;
			state.OrientationCorrection = Quaternion.Inverse(state.CorrectedOrientation) * quaternion2;
			lens.Dutch += m_Dutch;
			if (m_ZoomScale != 1f)
			{
				lens.OrthographicSize *= m_ZoomScale;
				lens.FieldOfView *= m_ZoomScale;
			}
			state.Lens = lens;
		}
	}
}
public class CinemachineTouchInputMapper : MonoBehaviour
{
	[Tooltip("Sensitivity multiplier for x-axis")]
	public float TouchSensitivityX = 10f;

	[Tooltip("Sensitivity multiplier for y-axis")]
	public float TouchSensitivityY = 10f;

	[Tooltip("Input channel to spoof for X axis")]
	public string TouchXInputMapTo = "Mouse X";

	[Tooltip("Input channel to spoof for Y axis")]
	public string TouchYInputMapTo = "Mouse Y";

	private void Start()
	{
		CinemachineCore.GetInputAxis = GetInputAxis;
	}

	private float GetInputAxis(string axisName)
	{
		if (Input.touchCount > 0)
		{
			if (axisName == TouchXInputMapTo)
			{
				return Input.touches[0].deltaPosition.x / TouchSensitivityX;
			}
			if (axisName == TouchYInputMapTo)
			{
				return Input.touches[0].deltaPosition.y / TouchSensitivityY;
			}
		}
		return Input.GetAxis(axisName);
	}
}
internal sealed class CinemachineMixer : PlayableBehaviour
{
	public delegate PlayableDirector MasterDirectorDelegate();

	public static MasterDirectorDelegate GetMasterPlayableDirector;

	private ICameraOverrideStack m_BrainOverrideStack;

	private int m_BrainOverrideId = -1;

	private bool m_PreviewPlay;

	public override void OnPlayableDestroy(Playable playable)
	{
		if (m_BrainOverrideStack != null)
		{
			m_BrainOverrideStack.ReleaseCameraOverride(m_BrainOverrideId);
		}
		m_BrainOverrideId = -1;
	}

	public override void PrepareFrame(Playable playable, FrameData info)
	{
		m_PreviewPlay = false;
	}

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		base.ProcessFrame(playable, info, playerData);
		m_BrainOverrideStack = playerData as ICameraOverrideStack;
		if (m_BrainOverrideStack == null)
		{
			return;
		}
		int num = 0;
		int num2 = -1;
		int num3 = -1;
		bool flag = false;
		float num4 = 1f;
		for (int i = 0; i < playable.GetInputCount(); i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			ScriptPlayable<CinemachineShotPlayable> playable2 = (ScriptPlayable<CinemachineShotPlayable>)playable.GetInput(i);
			CinemachineShotPlayable behaviour = playable2.GetBehaviour();
			if (behaviour == null || !behaviour.IsValid || playable.GetPlayState() != PlayState.Playing || !(inputWeight > 0f))
			{
				continue;
			}
			num2 = num3;
			num3 = i;
			num4 = inputWeight;
			if (++num == 2)
			{
				Playable input = playable.GetInput(num2);
				flag = playable2.GetTime() >= input.GetTime();
				if (playable2.GetTime() == input.GetTime())
				{
					flag = playable2.GetDuration() < input.GetDuration();
				}
				break;
			}
		}
		if (num == 1 && num4 < 1f && playable.GetInput(num3).GetTime() > playable.GetInput(num3).GetDuration() / 2.0)
		{
			flag = true;
		}
		if (flag)
		{
			int num5 = num3;
			int num6 = num2;
			num2 = num5;
			num3 = num6;
			num4 = 1f - num4;
		}
		ICinemachineCamera camA = null;
		if (num2 >= 0)
		{
			camA = ((ScriptPlayable<CinemachineShotPlayable>)playable.GetInput(num2)).GetBehaviour().VirtualCamera;
		}
		ICinemachineCamera camB = null;
		if (num3 >= 0)
		{
			camB = ((ScriptPlayable<CinemachineShotPlayable>)playable.GetInput(num3)).GetBehaviour().VirtualCamera;
		}
		m_BrainOverrideId = m_BrainOverrideStack.SetCameraOverride(m_BrainOverrideId, camA, camB, num4, GetDeltaTime(info.deltaTime));
	}

	private float GetDeltaTime(float deltaTime)
	{
		if (m_PreviewPlay || Application.isPlaying)
		{
			return deltaTime;
		}
		if (TargetPositionCache.CacheMode == TargetPositionCache.Mode.Playback && TargetPositionCache.HasCurrentTime)
		{
			return 0f;
		}
		return -1f;
	}
}
public sealed class CinemachineShot : PlayableAsset, IPropertyPreview
{
	public string DisplayName;

	public ExposedReference<CinemachineVirtualCameraBase> VirtualCamera;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		ScriptPlayable<CinemachineShotPlayable> scriptPlayable = ScriptPlayable<CinemachineShotPlayable>.Create(graph);
		scriptPlayable.GetBehaviour().VirtualCamera = VirtualCamera.Resolve(graph.GetResolver());
		return scriptPlayable;
	}

	public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		driver.AddFromName<Transform>("m_LocalPosition.x");
		driver.AddFromName<Transform>("m_LocalPosition.y");
		driver.AddFromName<Transform>("m_LocalPosition.z");
		driver.AddFromName<Transform>("m_LocalRotation.x");
		driver.AddFromName<Transform>("m_LocalRotation.y");
		driver.AddFromName<Transform>("m_LocalRotation.z");
		driver.AddFromName<Transform>("m_LocalRotation.w");
		driver.AddFromName<Camera>("field of view");
		driver.AddFromName<Camera>("near clip plane");
		driver.AddFromName<Camera>("far clip plane");
	}
}
internal sealed class CinemachineShotPlayable : PlayableBehaviour
{
	public CinemachineVirtualCameraBase VirtualCamera;

	public bool IsValid => VirtualCamera != null;
}
[Serializable]
[TrackClipType(typeof(CinemachineShot))]
[TrackBindingType(typeof(CinemachineBrain), TrackBindingFlags.None)]
[TrackColor(0.53f, 0f, 0.08f)]
public class CinemachineTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		ScriptPlayable<CinemachineMixer> scriptPlayable = ScriptPlayable<CinemachineMixer>.Create(graph);
		scriptPlayable.SetInputCount(inputCount);
		return scriptPlayable;
	}
}
[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		return new MonoScriptData
		{
			FilePathsData = new byte[7574]
			{
				0, 0, 0, 1, 0, 0, 0, 96, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 64, 50, 46, 49, 48, 46, 51, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 66, 101, 104,
				97, 118, 105, 111, 117, 114, 115, 92, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 51,
				114, 100, 80, 101, 114, 115, 111, 110, 65, 105,
				109, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 99, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 99, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 64, 50, 46, 49, 48,
				46, 51, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 66, 101, 104, 97, 118, 105, 111, 117, 114,
				115, 92, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 66, 108, 101, 110, 100, 76, 105,
				115, 116, 67, 97, 109, 101, 114, 97, 46, 99,
				115, 0, 0, 0, 5, 0, 0, 0, 89, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 99, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 64, 50, 46, 49, 48, 46, 51, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 66, 101,
				104, 97, 118, 105, 111, 117, 114, 115, 92, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				66, 114, 97, 105, 110, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 96, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 99, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 64,
				50, 46, 49, 48, 46, 51, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 66, 101, 104, 97, 118,
				105, 111, 117, 114, 115, 92, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 67, 97, 109,
				101, 114, 97, 79, 102, 102, 115, 101, 116, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 93,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 99, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 64, 50, 46, 49, 48, 46, 51,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 66,
				101, 104, 97, 118, 105, 111, 117, 114, 115, 92,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 67, 108, 101, 97, 114, 83, 104, 111, 116,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				92, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 64, 50, 46, 49, 48, 46,
				51, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				66, 101, 104, 97, 118, 105, 111, 117, 114, 115,
				92, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 67, 111, 108, 108, 105, 100, 101, 114,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				92, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 64, 50, 46, 49, 48, 46,
				51, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				66, 101, 104, 97, 118, 105, 111, 117, 114, 115,
				92, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 67, 111, 110, 102, 105, 110, 101, 114,
				46, 99, 115, 0, 0, 0, 3, 0, 0, 0,
				94, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 64, 50, 46, 49, 48, 46,
				51, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				66, 101, 104, 97, 118, 105, 111, 117, 114, 115,
				92, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 67, 111, 110, 102, 105, 110, 101, 114,
				50, 68, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 93, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 64, 50, 46, 49,
				48, 46, 51, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 66, 101, 104, 97, 118, 105, 111, 117,
				114, 115, 92, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 68, 111, 108, 108, 121, 67,
				97, 114, 116, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 98, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 99, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 64, 50, 46,
				49, 48, 46, 51, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 66, 101, 104, 97, 118, 105, 111,
				117, 114, 115, 92, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 69, 120, 116, 101, 114,
				110, 97, 108, 67, 97, 109, 101, 114, 97, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 94,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 99, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 64, 50, 46, 49, 48, 46, 51,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 66,
				101, 104, 97, 118, 105, 111, 117, 114, 115, 92,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 70, 111, 108, 108, 111, 119, 90, 111, 111,
				109, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 92, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 99, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 64, 50, 46, 49, 48,
				46, 51, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 66, 101, 104, 97, 118, 105, 111, 117, 114,
				115, 92, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 70, 114, 101, 101, 76, 111, 111,
				107, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 96, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 99, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 64, 50, 46, 49, 48,
				46, 51, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 66, 101, 104, 97, 118, 105, 111, 117, 114,
				115, 92, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 77, 105, 120, 105, 110, 103, 67,
				97, 109, 101, 114, 97, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 88, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 99, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 64,
				50, 46, 49, 48, 46, 51, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 66, 101, 104, 97, 118,
				105, 111, 117, 114, 115, 92, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 80, 97, 116,
				104, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 92, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 99, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 64, 50, 46, 49, 48,
				46, 51, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 66, 101, 104, 97, 118, 105, 111, 117, 114,
				115, 92, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 80, 105, 112, 101, 108, 105, 110,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 96, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 99, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 64, 50, 46, 49, 48,
				46, 51, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 66, 101, 104, 97, 118, 105, 111, 117, 114,
				115, 92, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 80, 105, 120, 101, 108, 80, 101,
				114, 102, 101, 99, 116, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 94, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 99, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 64,
				50, 46, 49, 48, 46, 51, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 66, 101, 104, 97, 118,
				105, 111, 117, 114, 115, 92, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 82, 101, 99,
				111, 109, 112, 111, 115, 101, 114, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 94, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 64, 50, 46, 49, 48, 46, 51, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 66, 101, 104,
				97, 118, 105, 111, 117, 114, 115, 92, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 83,
				109, 111, 111, 116, 104, 80, 97, 116, 104, 46,
				99, 115, 0, 0, 0, 4, 0, 0, 0, 101,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 99, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 64, 50, 46, 49, 48, 46, 51,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 66,
				101, 104, 97, 118, 105, 111, 117, 114, 115, 92,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 83, 116, 97, 116, 101, 68, 114, 105, 118,
				101, 110, 67, 97, 109, 101, 114, 97, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 94, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 99, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 64, 50, 46, 49, 48, 46, 51, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 66, 101,
				104, 97, 118, 105, 111, 117, 114, 115, 92, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				83, 116, 111, 114, 121, 98, 111, 97, 114, 100,
				46, 99, 115, 0, 0, 0, 3, 0, 0, 0,
				95, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 64, 50, 46, 49, 48, 46,
				51, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				66, 101, 104, 97, 118, 105, 111, 117, 114, 115,
				92, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 84, 97, 114, 103, 101, 116, 71, 114,
				111, 117, 112, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 97, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 99, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 64, 50, 46,
				49, 48, 46, 51, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 66, 101, 104, 97, 118, 105, 111,
				117, 114, 115, 92, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 86, 105, 114, 116, 117,
				97, 108, 67, 97, 109, 101, 114, 97, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 99, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 99, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 64, 50, 46, 49, 48, 46, 51, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 67, 111,
				109, 112, 111, 110, 101, 110, 116, 115, 92, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				51, 114, 100, 80, 101, 114, 115, 111, 110, 70,
				111, 108, 108, 111, 119, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 107, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 99, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 64,
				50, 46, 49, 48, 46, 51, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 67, 111, 109, 112, 111,
				110, 101, 110, 116, 115, 92, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 66, 97, 115,
				105, 99, 77, 117, 108, 116, 105, 67, 104, 97,
				110, 110, 101, 108, 80, 101, 114, 108, 105, 110,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				92, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 64, 50, 46, 49, 48, 46,
				51, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				67, 111, 109, 112, 111, 110, 101, 110, 116, 115,
				92, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 67, 111, 109, 112, 111, 115, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				101, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 64, 50, 46, 49, 48, 46,
				51, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				67, 111, 109, 112, 111, 110, 101, 110, 116, 115,
				92, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 70, 114, 97, 109, 105, 110, 103, 84,
				114, 97, 110, 115, 112, 111, 115, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 97,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 99, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 64, 50, 46, 49, 48, 46, 51,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 67,
				111, 109, 112, 111, 110, 101, 110, 116, 115, 92,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 71, 114, 111, 117, 112, 67, 111, 109, 112,
				111, 115, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 100, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 99, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 64, 50,
				46, 49, 48, 46, 51, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 67, 111, 109, 112, 111, 110,
				101, 110, 116, 115, 92, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 72, 97, 114, 100,
				76, 111, 99, 107, 84, 111, 84, 97, 114, 103,
				101, 116, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 94, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 64, 50, 46, 49,
				48, 46, 51, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 67, 111, 109, 112, 111, 110, 101, 110,
				116, 115, 92, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 72, 97, 114, 100, 76, 111,
				111, 107, 65, 116, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 101, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 99, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 64, 50,
				46, 49, 48, 46, 51, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 67, 111, 109, 112, 111, 110,
				101, 110, 116, 115, 92, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 79, 114, 98, 105,
				116, 97, 108, 84, 114, 97, 110, 115, 112, 111,
				115, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 87, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 99, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 64, 50, 46,
				49, 48, 46, 51, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 67, 111, 109, 112, 111, 110, 101,
				110, 116, 115, 92, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 80, 79, 86, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 102, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 99, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 64, 50, 46, 49, 48, 46, 51, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 67, 111,
				109, 112, 111, 110, 101, 110, 116, 115, 92, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				83, 97, 109, 101, 65, 115, 70, 111, 108, 108,
				111, 119, 84, 97, 114, 103, 101, 116, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 96, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 99, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 64, 50, 46, 49, 48, 46, 51, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 67, 111,
				109, 112, 111, 110, 101, 110, 116, 115, 92, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				84, 114, 97, 99, 107, 101, 100, 68, 111, 108,
				108, 121, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 94, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 64, 50, 46, 49,
				48, 46, 51, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 67, 111, 109, 112, 111, 110, 101, 110,
				116, 115, 92, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 84, 114, 97, 110, 115, 112,
				111, 115, 101, 114, 46, 99, 115, 0, 0, 0,
				3, 0, 0, 0, 76, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 99, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 64, 50,
				46, 49, 48, 46, 51, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 67, 111, 114, 101, 92, 65,
				120, 105, 115, 83, 116, 97, 116, 101, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 78, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 99, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 64, 50, 46, 49, 48, 46, 51, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 67, 111,
				114, 101, 92, 67, 97, 109, 101, 114, 97, 83,
				116, 97, 116, 101, 46, 99, 115, 0, 0, 0,
				4, 0, 0, 0, 83, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 99, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 64, 50,
				46, 49, 48, 46, 51, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 67, 111, 114, 101, 92, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				66, 108, 101, 110, 100, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 93, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 99, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 64,
				50, 46, 49, 48, 46, 51, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 67, 111, 114, 101, 92,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 66, 108, 101, 110, 100, 101, 114, 83, 101,
				116, 116, 105, 110, 103, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 91, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				64, 50, 46, 49, 48, 46, 51, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 67, 111, 114, 101,
				92, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 67, 111, 109, 112, 111, 110, 101, 110,
				116, 66, 97, 115, 101, 46, 99, 115, 0, 0,
				0, 3, 0, 0, 0, 82, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 99, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 64,
				50, 46, 49, 48, 46, 51, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 67, 111, 114, 101, 92,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 67, 111, 114, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 83, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 99, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 64,
				50, 46, 49, 48, 46, 51, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 67, 111, 114, 101, 92,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 68, 101, 98, 117, 103, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 87, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				64, 50, 46, 49, 48, 46, 51, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 67, 111, 114, 101,
				92, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 69, 120, 116, 101, 110, 115, 105, 111,
				110, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 93, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 99, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 64, 50, 46, 49, 48,
				46, 51, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 67, 111, 114, 101, 92, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 73, 110, 112,
				117, 116, 65, 120, 105, 115, 68, 114, 105, 118,
				101, 114, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 86, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 64, 50, 46, 49,
				48, 46, 51, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 67, 111, 114, 101, 92, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 80, 97,
				116, 104, 66, 97, 115, 101, 46, 99, 115, 0,
				0, 0, 11, 0, 0, 0, 95, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				64, 50, 46, 49, 48, 46, 51, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 67, 111, 114, 101,
				92, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 80, 114, 111, 112, 101, 114, 116, 121,
				65, 116, 116, 114, 105, 98, 117, 116, 101, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 95,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 99, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 64, 50, 46, 49, 48, 46, 51,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 67,
				111, 114, 101, 92, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 86, 105, 114, 116, 117,
				97, 108, 67, 97, 109, 101, 114, 97, 66, 97,
				115, 101, 46, 99, 115, 0, 0, 0, 5, 0,
				0, 0, 79, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 64, 50, 46, 49,
				48, 46, 51, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 67, 111, 114, 101, 92, 67, 111, 110,
				102, 105, 110, 101, 114, 79, 118, 101, 110, 46,
				99, 115, 0, 0, 0, 4, 0, 0, 0, 81,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 99, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 64, 50, 46, 49, 48, 46, 51,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 67,
				111, 114, 101, 92, 71, 97, 117, 115, 115, 105,
				97, 110, 70, 105, 108, 116, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 85, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 99, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 64, 50, 46, 49, 48, 46, 51, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 67, 111,
				114, 101, 92, 73, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 67, 97, 109, 101, 114,
				97, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 79, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 99, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 64, 50, 46, 49, 48,
				46, 51, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 67, 111, 114, 101, 92, 76, 101, 110, 115,
				83, 101, 116, 116, 105, 110, 103, 115, 46, 99,
				115, 0, 0, 0, 3, 0, 0, 0, 80, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 99, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 64, 50, 46, 49, 48, 46, 51, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 67, 111,
				114, 101, 92, 78, 111, 105, 115, 101, 83, 101,
				116, 116, 105, 110, 103, 115, 46, 99, 115, 0,
				0, 0, 4, 0, 0, 0, 76, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				64, 50, 46, 49, 48, 46, 51, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 67, 111, 114, 101,
				92, 80, 114, 101, 100, 105, 99, 116, 111, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				81, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 64, 50, 46, 49, 48, 46,
				51, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				67, 111, 114, 101, 92, 82, 117, 110, 116, 105,
				109, 101, 85, 116, 105, 108, 105, 116, 121, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 84,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 99, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 64, 50, 46, 49, 48, 46, 51,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 67,
				111, 114, 101, 92, 83, 105, 103, 110, 97, 108,
				83, 111, 117, 114, 99, 101, 65, 115, 115, 101,
				116, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 80, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 99, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 64, 50, 46, 49, 48,
				46, 51, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 67, 111, 114, 101, 92, 83, 112, 108, 105,
				110, 101, 72, 101, 108, 112, 101, 114, 115, 46,
				99, 115, 0, 0, 0, 6, 0, 0, 0, 86,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 99, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 64, 50, 46, 49, 48, 46, 51,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 67,
				111, 114, 101, 92, 84, 97, 114, 103, 101, 116,
				80, 111, 115, 105, 116, 105, 111, 110, 67, 97,
				99, 104, 101, 46, 99, 115, 0, 0, 0, 3,
				0, 0, 0, 88, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 99, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 64, 50, 46,
				49, 48, 46, 51, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 67, 111, 114, 101, 92, 85, 110,
				105, 116, 121, 86, 101, 99, 116, 111, 114, 69,
				120, 116, 101, 110, 115, 105, 111, 110, 115, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 80,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 99, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 64, 50, 46, 49, 48, 46, 51,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 67,
				111, 114, 101, 92, 85, 112, 100, 97, 116, 101,
				84, 114, 97, 99, 107, 101, 114, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 94, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 64, 50, 46, 49, 48, 46, 51, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 72, 101, 108,
				112, 101, 114, 115, 92, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 73, 110, 112, 117,
				116, 80, 114, 111, 118, 105, 100, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 97,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 99, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 64, 50, 46, 49, 48, 46, 51,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 72,
				101, 108, 112, 101, 114, 115, 92, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 84, 111,
				117, 99, 104, 73, 110, 112, 117, 116, 77, 97,
				112, 112, 101, 114, 46, 99, 115, 0, 0, 0,
				3, 0, 0, 0, 94, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 99, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 64, 50,
				46, 49, 48, 46, 51, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 72, 101, 108, 112, 101, 114,
				115, 92, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 84, 114, 105, 103, 103, 101, 114,
				65, 99, 116, 105, 111, 110, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 92, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				64, 50, 46, 49, 48, 46, 51, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 72, 101, 108, 112,
				101, 114, 115, 92, 71, 114, 111, 117, 112, 87,
				101, 105, 103, 104, 116, 77, 97, 110, 105, 112,
				117, 108, 97, 116, 111, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 103, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				64, 50, 46, 49, 48, 46, 51, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 73, 109, 112, 117,
				108, 115, 101, 92, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 67, 111, 108, 108, 105,
				115, 105, 111, 110, 73, 109, 112, 117, 108, 115,
				101, 83, 111, 117, 114, 99, 101, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 92, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 64, 50, 46, 49, 48, 46, 51, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 73, 109, 112,
				117, 108, 115, 101, 92, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 70, 105, 120, 101,
				100, 83, 105, 103, 110, 97, 108, 46, 99, 115,
				0, 0, 0, 4, 0, 0, 0, 98, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 64, 50, 46, 49, 48, 46, 51, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 73, 109, 112,
				117, 108, 115, 101, 92, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 73, 109, 112, 117,
				108, 115, 101, 68, 101, 102, 105, 110, 105, 116,
				105, 111, 110, 46, 99, 115, 0, 0, 0, 2,
				0, 0, 0, 96, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 99, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 64, 50, 46,
				49, 48, 46, 51, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 73, 109, 112, 117, 108, 115, 101,
				92, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 73, 109, 112, 117, 108, 115, 101, 76,
				105, 115, 116, 101, 110, 101, 114, 46, 99, 115,
				0, 0, 0, 5, 0, 0, 0, 95, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 64, 50, 46, 49, 48, 46, 51, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 73, 109, 112,
				117, 108, 115, 101, 92, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 73, 109, 112, 117,
				108, 115, 101, 77, 97, 110, 97, 103, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				94, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 64, 50, 46, 49, 48, 46,
				51, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				73, 109, 112, 117, 108, 115, 101, 92, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 73,
				109, 112, 117, 108, 115, 101, 83, 111, 117, 114,
				99, 101, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 107, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 64, 50, 46, 49,
				48, 46, 51, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 73, 109, 112, 117, 108, 115, 101, 92,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 73, 110, 100, 101, 112, 101, 110, 100, 101,
				110, 116, 73, 109, 112, 117, 108, 115, 101, 76,
				105, 115, 116, 101, 110, 101, 114, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 102, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 64, 50, 46, 49, 48, 46, 51, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 80, 111, 115,
				116, 80, 114, 111, 99, 101, 115, 115, 105, 110,
				103, 92, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 80, 111, 115, 116, 80, 114, 111,
				99, 101, 115, 115, 105, 110, 103, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 102, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 64, 50, 46, 49, 48, 46, 51, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 80, 111, 115,
				116, 80, 114, 111, 99, 101, 115, 115, 105, 110,
				103, 92, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 86, 111, 108, 117, 109, 101, 83,
				101, 116, 116, 105, 110, 103, 115, 46, 99, 115,
				0, 0, 0, 20, 0, 0, 0, 80, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 64, 50, 46, 49, 48, 46, 51, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 84, 104, 105,
				114, 100, 80, 97, 114, 116, 121, 92, 99, 108,
				105, 112, 112, 101, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 87, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 99, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 64,
				50, 46, 49, 48, 46, 51, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 84, 105, 109, 101, 108,
				105, 110, 101, 92, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 77, 105, 120, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				86, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 64, 50, 46, 49, 48, 46,
				51, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				84, 105, 109, 101, 108, 105, 110, 101, 92, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				83, 104, 111, 116, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 94, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 99, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 64, 50,
				46, 49, 48, 46, 51, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 84, 105, 109, 101, 108, 105,
				110, 101, 92, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 83, 104, 111, 116, 80, 108,
				97, 121, 97, 98, 108, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 87, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				64, 50, 46, 49, 48, 46, 51, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 84, 105, 109, 101,
				108, 105, 110, 101, 92, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 84, 114, 97, 99,
				107, 46, 99, 115
			},
			TypesData = new byte[7206]
			{
				0, 0, 0, 0, 35, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 124, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 51, 114,
				100, 80, 101, 114, 115, 111, 110, 65, 105, 109,
				0, 0, 0, 0, 38, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 124, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 66, 108,
				101, 110, 100, 76, 105, 115, 116, 67, 97, 109,
				101, 114, 97, 0, 0, 0, 0, 50, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 46,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 66, 108, 101, 110, 100, 76, 105, 115, 116,
				67, 97, 109, 101, 114, 97, 124, 73, 110, 115,
				116, 114, 117, 99, 116, 105, 111, 110, 0, 0,
				0, 0, 32, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 124, 73, 67, 97, 109, 101,
				114, 97, 79, 118, 101, 114, 114, 105, 100, 101,
				83, 116, 97, 99, 107, 0, 0, 0, 0, 28,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 124, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 66, 114, 97, 105, 110, 0, 0,
				0, 0, 39, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 46, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 66, 114, 97, 105,
				110, 124, 66, 114, 97, 105, 110, 69, 118, 101,
				110, 116, 0, 0, 0, 0, 47, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 46, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				66, 114, 97, 105, 110, 124, 86, 99, 97, 109,
				65, 99, 116, 105, 118, 97, 116, 101, 100, 69,
				118, 101, 110, 116, 0, 0, 0, 0, 39, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				46, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 66, 114, 97, 105, 110, 124, 66, 114,
				97, 105, 110, 70, 114, 97, 109, 101, 0, 0,
				0, 0, 24, 124, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 67, 97, 109, 101, 114,
				97, 79, 102, 102, 115, 101, 116, 0, 0, 0,
				0, 32, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 124, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 67, 108, 101, 97, 114,
				83, 104, 111, 116, 0, 0, 0, 0, 37, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				46, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 67, 108, 101, 97, 114, 83, 104, 111,
				116, 124, 80, 97, 105, 114, 0, 0, 0, 0,
				31, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 124, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 67, 111, 108, 108, 105, 100,
				101, 114, 0, 0, 0, 0, 46, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 46, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				67, 111, 108, 108, 105, 100, 101, 114, 124, 86,
				99, 97, 109, 69, 120, 116, 114, 97, 83, 116,
				97, 116, 101, 0, 0, 0, 0, 31, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 124,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 67, 111, 110, 102, 105, 110, 101, 114, 0,
				0, 0, 0, 46, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 46, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 67, 111, 110,
				102, 105, 110, 101, 114, 124, 86, 99, 97, 109,
				69, 120, 116, 114, 97, 83, 116, 97, 116, 101,
				0, 0, 0, 0, 33, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 124, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 67, 111,
				110, 102, 105, 110, 101, 114, 50, 68, 0, 0,
				0, 0, 48, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 46, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 67, 111, 110, 102,
				105, 110, 101, 114, 50, 68, 124, 86, 99, 97,
				109, 69, 120, 116, 114, 97, 83, 116, 97, 116,
				101, 0, 0, 0, 0, 44, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 46, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 67,
				111, 110, 102, 105, 110, 101, 114, 50, 68, 124,
				83, 104, 97, 112, 101, 67, 97, 99, 104, 101,
				0, 0, 0, 0, 32, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 124, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 68, 111,
				108, 108, 121, 67, 97, 114, 116, 0, 0, 0,
				0, 37, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 124, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 69, 120, 116, 101, 114,
				110, 97, 108, 67, 97, 109, 101, 114, 97, 0,
				0, 0, 0, 33, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 124, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 70, 111, 108,
				108, 111, 119, 90, 111, 111, 109, 0, 0, 0,
				0, 48, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 46, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 70, 111, 108, 108, 111,
				119, 90, 111, 111, 109, 124, 86, 99, 97, 109,
				69, 120, 116, 114, 97, 83, 116, 97, 116, 101,
				0, 0, 0, 0, 31, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 124, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 70, 114,
				101, 101, 76, 111, 111, 107, 0, 0, 0, 0,
				37, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 46, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 70, 114, 101, 101, 76, 111,
				111, 107, 124, 79, 114, 98, 105, 116, 0, 0,
				0, 0, 35, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 124, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 77, 105, 120, 105,
				110, 103, 67, 97, 109, 101, 114, 97, 0, 0,
				0, 0, 27, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 124, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 80, 97, 116, 104,
				0, 0, 0, 0, 36, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 46, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 80, 97,
				116, 104, 124, 87, 97, 121, 112, 111, 105, 110,
				116, 0, 0, 0, 0, 31, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 124, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 80,
				105, 112, 101, 108, 105, 110, 101, 0, 0, 0,
				0, 35, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 124, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 80, 105, 120, 101, 108,
				80, 101, 114, 102, 101, 99, 116, 0, 0, 0,
				0, 22, 124, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 82, 101, 99, 111, 109, 112,
				111, 115, 101, 114, 0, 0, 0, 0, 33, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				124, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 83, 109, 111, 111, 116, 104, 80, 97,
				116, 104, 0, 0, 0, 0, 42, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 46, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				83, 109, 111, 111, 116, 104, 80, 97, 116, 104,
				124, 87, 97, 121, 112, 111, 105, 110, 116, 0,
				0, 0, 0, 40, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 124, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 83, 116, 97,
				116, 101, 68, 114, 105, 118, 101, 110, 67, 97,
				109, 101, 114, 97, 0, 0, 0, 0, 52, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				46, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 83, 116, 97, 116, 101, 68, 114, 105,
				118, 101, 110, 67, 97, 109, 101, 114, 97, 124,
				73, 110, 115, 116, 114, 117, 99, 116, 105, 111,
				110, 0, 0, 0, 0, 51, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 46, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 83,
				116, 97, 116, 101, 68, 114, 105, 118, 101, 110,
				67, 97, 109, 101, 114, 97, 124, 80, 97, 114,
				101, 110, 116, 72, 97, 115, 104, 0, 0, 0,
				0, 49, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 46, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 83, 116, 97, 116, 101,
				68, 114, 105, 118, 101, 110, 67, 97, 109, 101,
				114, 97, 124, 72, 97, 115, 104, 80, 97, 105,
				114, 0, 0, 0, 0, 33, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 124, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 83,
				116, 111, 114, 121, 98, 111, 97, 114, 100, 0,
				0, 0, 0, 44, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 46, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 83, 116, 111,
				114, 121, 98, 111, 97, 114, 100, 124, 67, 97,
				110, 118, 97, 115, 73, 110, 102, 111, 0, 0,
				0, 0, 35, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 124, 73, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 84, 97, 114,
				103, 101, 116, 71, 114, 111, 117, 112, 0, 0,
				0, 0, 34, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 124, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 84, 97, 114, 103,
				101, 116, 71, 114, 111, 117, 112, 0, 0, 0,
				0, 41, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 46, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 84, 97, 114, 103, 101,
				116, 71, 114, 111, 117, 112, 124, 84, 97, 114,
				103, 101, 116, 0, 0, 0, 0, 36, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 124,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 86, 105, 114, 116, 117, 97, 108, 67, 97,
				109, 101, 114, 97, 0, 0, 0, 0, 38, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				124, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 51, 114, 100, 80, 101, 114, 115, 111,
				110, 70, 111, 108, 108, 111, 119, 0, 0, 0,
				0, 46, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 124, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 66, 97, 115, 105, 99,
				77, 117, 108, 116, 105, 67, 104, 97, 110, 110,
				101, 108, 80, 101, 114, 108, 105, 110, 0, 0,
				0, 0, 31, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 124, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 67, 111, 109, 112,
				111, 115, 101, 114, 0, 0, 0, 0, 40, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				46, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 67, 111, 109, 112, 111, 115, 101, 114,
				124, 70, 111, 118, 67, 97, 99, 104, 101, 0,
				0, 0, 0, 40, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 124, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 70, 114, 97,
				109, 105, 110, 103, 84, 114, 97, 110, 115, 112,
				111, 115, 101, 114, 0, 0, 0, 0, 36, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				124, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 71, 114, 111, 117, 112, 67, 111, 109,
				112, 111, 115, 101, 114, 0, 0, 0, 0, 39,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 124, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 72, 97, 114, 100, 76, 111, 99,
				107, 84, 111, 84, 97, 114, 103, 101, 116, 0,
				0, 0, 0, 33, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 124, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 72, 97, 114,
				100, 76, 111, 111, 107, 65, 116, 0, 0, 0,
				0, 40, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 124, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 79, 114, 98, 105, 116,
				97, 108, 84, 114, 97, 110, 115, 112, 111, 115,
				101, 114, 0, 0, 0, 0, 48, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 46, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				79, 114, 98, 105, 116, 97, 108, 84, 114, 97,
				110, 115, 112, 111, 115, 101, 114, 124, 72, 101,
				97, 100, 105, 110, 103, 0, 0, 0, 0, 26,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 124, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 80, 79, 86, 0, 0, 0, 0,
				41, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 124, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 83, 97, 109, 101, 65, 115,
				70, 111, 108, 108, 111, 119, 84, 97, 114, 103,
				101, 116, 0, 0, 0, 0, 35, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 124, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				84, 114, 97, 99, 107, 101, 100, 68, 111, 108,
				108, 121, 0, 0, 0, 0, 45, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 46, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				84, 114, 97, 99, 107, 101, 100, 68, 111, 108,
				108, 121, 124, 65, 117, 116, 111, 68, 111, 108,
				108, 121, 0, 0, 0, 0, 33, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 124, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				84, 114, 97, 110, 115, 112, 111, 115, 101, 114,
				0, 0, 0, 0, 21, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 124, 65, 120, 105,
				115, 83, 116, 97, 116, 101, 0, 0, 0, 0,
				31, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 46, 124, 73, 73, 110, 112, 117, 116,
				65, 120, 105, 115, 80, 114, 111, 118, 105, 100,
				101, 114, 0, 0, 0, 0, 24, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 46, 124,
				82, 101, 99, 101, 110, 116, 101, 114, 105, 110,
				103, 0, 0, 0, 0, 23, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 124, 67, 97,
				109, 101, 114, 97, 83, 116, 97, 116, 101, 0,
				0, 0, 0, 28, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 46, 124, 67, 117, 115,
				116, 111, 109, 66, 108, 101, 110, 100, 97, 98,
				108, 101, 0, 0, 0, 0, 28, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 124, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				66, 108, 101, 110, 100, 0, 0, 0, 0, 38,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 124, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 66, 108, 101, 110, 100, 68, 101,
				102, 105, 110, 105, 116, 105, 111, 110, 0, 0,
				0, 0, 36, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 124, 83, 116, 97, 116, 105,
				99, 80, 111, 105, 110, 116, 86, 105, 114, 116,
				117, 97, 108, 67, 97, 109, 101, 114, 97, 0,
				0, 0, 0, 36, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 124, 66, 108, 101, 110,
				100, 83, 111, 117, 114, 99, 101, 86, 105, 114,
				116, 117, 97, 108, 67, 97, 109, 101, 114, 97,
				0, 0, 0, 0, 38, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 124, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 66, 108,
				101, 110, 100, 101, 114, 83, 101, 116, 116, 105,
				110, 103, 115, 0, 0, 0, 0, 50, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 46,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 66, 108, 101, 110, 100, 101, 114, 83, 101,
				116, 116, 105, 110, 103, 115, 124, 67, 117, 115,
				116, 111, 109, 66, 108, 101, 110, 100, 0, 0,
				0, 0, 36, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 124, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 67, 111, 109, 112,
				111, 110, 101, 110, 116, 66, 97, 115, 101, 0,
				0, 0, 0, 25, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 124, 68, 111, 99, 117,
				109, 101, 110, 116, 97, 116, 105, 111, 110, 0,
				0, 0, 0, 27, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 124, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 67, 111, 114,
				101, 0, 0, 0, 0, 40, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 46, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 67,
				111, 114, 101, 124, 85, 112, 100, 97, 116, 101,
				83, 116, 97, 116, 117, 115, 0, 0, 0, 0,
				36, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 46, 85, 116, 105, 108, 105, 116, 121,
				124, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 68, 101, 98, 117, 103, 0, 0, 0,
				0, 32, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 124, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 69, 120, 116, 101, 110,
				115, 105, 111, 110, 0, 0, 0, 0, 20, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				124, 65, 120, 105, 115, 66, 97, 115, 101, 0,
				0, 0, 0, 38, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 124, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 73, 110, 112,
				117, 116, 65, 120, 105, 115, 68, 114, 105, 118,
				101, 114, 0, 0, 0, 0, 31, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 124, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				80, 97, 116, 104, 66, 97, 115, 101, 0, 0,
				0, 0, 42, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 46, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 80, 97, 116, 104,
				66, 97, 115, 101, 124, 65, 112, 112, 101, 97,
				114, 97, 110, 99, 101, 0, 0, 0, 0, 38,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 124, 65, 120, 105, 115, 83, 116, 97, 116,
				101, 80, 114, 111, 112, 101, 114, 116, 121, 65,
				116, 116, 114, 105, 98, 117, 116, 101, 0, 0,
				0, 0, 53, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 124, 79, 114, 98, 105, 116,
				97, 108, 84, 114, 97, 110, 115, 112, 111, 115,
				101, 114, 72, 101, 97, 100, 105, 110, 103, 80,
				114, 111, 112, 101, 114, 116, 121, 65, 116, 116,
				114, 105, 98, 117, 116, 101, 0, 0, 0, 0,
				41, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 124, 76, 101, 110, 115, 83, 101, 116,
				116, 105, 110, 103, 115, 80, 114, 111, 112, 101,
				114, 116, 121, 65, 116, 116, 114, 105, 98, 117,
				116, 101, 0, 0, 0, 0, 39, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 124, 86,
				99, 97, 109, 84, 97, 114, 103, 101, 116, 80,
				114, 111, 112, 101, 114, 116, 121, 65, 116, 116,
				114, 105, 98, 117, 116, 101, 0, 0, 0, 0,
				55, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 124, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 66, 108, 101, 110, 100, 68,
				101, 102, 105, 110, 105, 116, 105, 111, 110, 80,
				114, 111, 112, 101, 114, 116, 121, 65, 116, 116,
				114, 105, 98, 117, 116, 101, 0, 0, 0, 0,
				35, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 124, 83, 97, 118, 101, 68, 117, 114,
				105, 110, 103, 80, 108, 97, 121, 65, 116, 116,
				114, 105, 98, 117, 116, 101, 0, 0, 0, 0,
				37, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 124, 78, 111, 83, 97, 118, 101, 68,
				117, 114, 105, 110, 103, 80, 108, 97, 121, 65,
				116, 116, 114, 105, 98, 117, 116, 101, 0, 0,
				0, 0, 29, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 124, 84, 97, 103, 70, 105,
				101, 108, 100, 65, 116, 116, 114, 105, 98, 117,
				116, 101, 0, 0, 0, 0, 42, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 124, 78,
				111, 105, 115, 101, 83, 101, 116, 116, 105, 110,
				103, 115, 80, 114, 111, 112, 101, 114, 116, 121,
				65, 116, 116, 114, 105, 98, 117, 116, 101, 0,
				0, 0, 0, 53, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 124, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 69, 109, 98,
				101, 100, 100, 101, 100, 65, 115, 115, 101, 116,
				80, 114, 111, 112, 101, 114, 116, 121, 65, 116,
				116, 114, 105, 98, 117, 116, 101, 0, 0, 0,
				0, 41, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 124, 68, 111, 99, 117, 109, 101,
				110, 116, 97, 116, 105, 111, 110, 83, 111, 114,
				116, 105, 110, 103, 65, 116, 116, 114, 105, 98,
				117, 116, 101, 0, 0, 0, 0, 40, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 124,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 86, 105, 114, 116, 117, 97, 108, 67, 97,
				109, 101, 114, 97, 66, 97, 115, 101, 0, 0,
				0, 0, 57, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 46, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 86, 105, 114, 116,
				117, 97, 108, 67, 97, 109, 101, 114, 97, 66,
				97, 115, 101, 124, 84, 114, 97, 110, 115, 105,
				116, 105, 111, 110, 80, 97, 114, 97, 109, 115,
				0, 0, 0, 0, 24, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 124, 67, 111, 110,
				102, 105, 110, 101, 114, 79, 118, 101, 110, 0,
				0, 0, 0, 38, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 46, 67, 111, 110, 102,
				105, 110, 101, 114, 79, 118, 101, 110, 124, 66,
				97, 107, 101, 100, 83, 111, 108, 117, 116, 105,
				111, 110, 0, 0, 0, 0, 40, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 46, 67,
				111, 110, 102, 105, 110, 101, 114, 79, 118, 101,
				110, 124, 65, 115, 112, 101, 99, 116, 83, 116,
				114, 101, 116, 99, 104, 101, 114, 0, 0, 0,
				0, 40, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 46, 67, 111, 110, 102, 105, 110,
				101, 114, 79, 118, 101, 110, 124, 80, 111, 108,
				121, 103, 111, 110, 83, 111, 108, 117, 116, 105,
				111, 110, 0, 0, 0, 0, 41, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 46, 67,
				111, 110, 102, 105, 110, 101, 114, 79, 118, 101,
				110, 124, 66, 97, 107, 105, 110, 103, 83, 116,
				97, 116, 101, 67, 97, 99, 104, 101, 0, 0,
				0, 0, 36, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 46, 85, 116, 105, 108, 105,
				116, 121, 124, 71, 97, 117, 115, 115, 105, 97,
				110, 87, 105, 110, 100, 111, 119, 49, 100, 0,
				0, 0, 0, 44, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 46, 85, 116, 105, 108,
				105, 116, 121, 124, 71, 97, 117, 115, 115, 105,
				97, 110, 87, 105, 110, 100, 111, 119, 49, 68,
				95, 86, 101, 99, 116, 111, 114, 51, 0, 0,
				0, 0, 47, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 46, 85, 116, 105, 108, 105,
				116, 121, 124, 71, 97, 117, 115, 115, 105, 97,
				110, 87, 105, 110, 100, 111, 119, 49, 68, 95,
				81, 117, 97, 116, 101, 114, 110, 105, 111, 110,
				0, 0, 0, 0, 51, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 46, 85, 116, 105,
				108, 105, 116, 121, 124, 71, 97, 117, 115, 115,
				105, 97, 110, 87, 105, 110, 100, 111, 119, 49,
				68, 95, 67, 97, 109, 101, 114, 97, 82, 111,
				116, 97, 116, 105, 111, 110, 0, 0, 0, 0,
				30, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 124, 73, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 67, 97, 109, 101, 114,
				97, 0, 0, 0, 0, 24, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 124, 76, 101,
				110, 115, 83, 101, 116, 116, 105, 110, 103, 115,
				0, 0, 0, 0, 25, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 124, 78, 111, 105,
				115, 101, 83, 101, 116, 116, 105, 110, 103, 115,
				0, 0, 0, 0, 37, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 46, 78, 111, 105,
				115, 101, 83, 101, 116, 116, 105, 110, 103, 115,
				124, 78, 111, 105, 115, 101, 80, 97, 114, 97,
				109, 115, 0, 0, 0, 0, 46, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 46, 78,
				111, 105, 115, 101, 83, 101, 116, 116, 105, 110,
				103, 115, 124, 84, 114, 97, 110, 115, 102, 111,
				114, 109, 78, 111, 105, 115, 101, 80, 97, 114,
				97, 109, 115, 0, 0, 0, 0, 37, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 46,
				85, 116, 105, 108, 105, 116, 121, 124, 80, 111,
				115, 105, 116, 105, 111, 110, 80, 114, 101, 100,
				105, 99, 116, 111, 114, 0, 0, 0, 0, 26,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 46, 85, 116, 105, 108, 105, 116, 121, 124,
				68, 97, 109, 112, 101, 114, 0, 0, 0, 0,
				34, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 46, 85, 116, 105, 108, 105, 116, 121,
				124, 72, 101, 97, 100, 105, 110, 103, 84, 114,
				97, 99, 107, 101, 114, 0, 0, 0, 0, 39,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 46, 85, 116, 105, 108, 105, 116, 121, 46,
				72, 101, 97, 100, 105, 110, 103, 84, 114, 97,
				99, 107, 101, 114, 124, 73, 116, 101, 109, 0,
				0, 0, 0, 26, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 124, 82, 117, 110, 116,
				105, 109, 101, 85, 116, 105, 108, 105, 116, 121,
				0, 0, 0, 0, 27, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 124, 73, 83, 105,
				103, 110, 97, 108, 83, 111, 117, 114, 99, 101,
				54, 68, 0, 0, 0, 0, 29, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 124, 83,
				105, 103, 110, 97, 108, 83, 111, 117, 114, 99,
				101, 65, 115, 115, 101, 116, 0, 0, 0, 0,
				33, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 46, 85, 116, 105, 108, 105, 116, 121,
				124, 83, 112, 108, 105, 110, 101, 72, 101, 108,
				112, 101, 114, 115, 0, 0, 0, 0, 31, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				124, 84, 97, 114, 103, 101, 116, 80, 111, 115,
				105, 116, 105, 111, 110, 67, 97, 99, 104, 101,
				0, 0, 0, 0, 42, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 46, 84, 97, 114,
				103, 101, 116, 80, 111, 115, 105, 116, 105, 111,
				110, 67, 97, 99, 104, 101, 124, 67, 97, 99,
				104, 101, 67, 117, 114, 118, 101, 0, 0, 0,
				0, 47, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 46, 84, 97, 114, 103, 101, 116,
				80, 111, 115, 105, 116, 105, 111, 110, 67, 97,
				99, 104, 101, 43, 67, 97, 99, 104, 101, 67,
				117, 114, 118, 101, 124, 73, 116, 101, 109, 0,
				0, 0, 0, 42, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 46, 84, 97, 114, 103,
				101, 116, 80, 111, 115, 105, 116, 105, 111, 110,
				67, 97, 99, 104, 101, 124, 67, 97, 99, 104,
				101, 69, 110, 116, 114, 121, 0, 0, 0, 0,
				56, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 46, 84, 97, 114, 103, 101, 116, 80,
				111, 115, 105, 116, 105, 111, 110, 67, 97, 99,
				104, 101, 43, 67, 97, 99, 104, 101, 69, 110,
				116, 114, 121, 124, 82, 101, 99, 111, 114, 100,
				105, 110, 103, 73, 116, 101, 109, 0, 0, 0,
				0, 41, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 46, 84, 97, 114, 103, 101, 116,
				80, 111, 115, 105, 116, 105, 111, 110, 67, 97,
				99, 104, 101, 124, 84, 105, 109, 101, 82, 97,
				110, 103, 101, 0, 0, 0, 0, 41, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 46,
				85, 116, 105, 108, 105, 116, 121, 124, 85, 110,
				105, 116, 121, 86, 101, 99, 116, 111, 114, 69,
				120, 116, 101, 110, 115, 105, 111, 110, 115, 0,
				0, 0, 0, 45, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 46, 85, 116, 105, 108,
				105, 116, 121, 124, 85, 110, 105, 116, 121, 81,
				117, 97, 116, 101, 114, 110, 105, 111, 110, 69,
				120, 116, 101, 110, 115, 105, 111, 110, 115, 0,
				0, 0, 0, 39, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 46, 85, 116, 105, 108,
				105, 116, 121, 124, 85, 110, 105, 116, 121, 82,
				101, 99, 116, 69, 120, 116, 101, 110, 115, 105,
				111, 110, 115, 0, 0, 0, 0, 25, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 124,
				85, 112, 100, 97, 116, 101, 84, 114, 97, 99,
				107, 101, 114, 0, 0, 0, 0, 38, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 46,
				85, 112, 100, 97, 116, 101, 84, 114, 97, 99,
				107, 101, 114, 124, 85, 112, 100, 97, 116, 101,
				83, 116, 97, 116, 117, 115, 0, 0, 0, 0,
				36, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 124, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 73, 110, 112, 117, 116, 80,
				114, 111, 118, 105, 100, 101, 114, 0, 0, 0,
				0, 28, 124, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 84, 111, 117, 99, 104, 73,
				110, 112, 117, 116, 77, 97, 112, 112, 101, 114,
				0, 0, 0, 0, 36, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 124, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 84, 114,
				105, 103, 103, 101, 114, 65, 99, 116, 105, 111,
				110, 0, 0, 0, 0, 51, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 46, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 84,
				114, 105, 103, 103, 101, 114, 65, 99, 116, 105,
				111, 110, 124, 65, 99, 116, 105, 111, 110, 83,
				101, 116, 116, 105, 110, 103, 115, 0, 0, 0,
				0, 50, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 46, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 84, 114, 105, 103, 103,
				101, 114, 65, 99, 116, 105, 111, 110, 43, 124,
				84, 114, 105, 103, 103, 101, 114, 69, 118, 101,
				110, 116, 0, 0, 0, 0, 34, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 124, 71,
				114, 111, 117, 112, 87, 101, 105, 103, 104, 116,
				77, 97, 110, 105, 112, 117, 108, 97, 116, 111,
				114, 0, 0, 0, 0, 45, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 124, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 67,
				111, 108, 108, 105, 115, 105, 111, 110, 73, 109,
				112, 117, 108, 115, 101, 83, 111, 117, 114, 99,
				101, 0, 0, 0, 0, 34, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 124, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 70,
				105, 120, 101, 100, 83, 105, 103, 110, 97, 108,
				0, 0, 0, 0, 57, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 124, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 73, 109,
				112, 117, 108, 115, 101, 68, 101, 102, 105, 110,
				105, 116, 105, 111, 110, 80, 114, 111, 112, 101,
				114, 116, 121, 65, 116, 116, 114, 105, 98, 117,
				116, 101, 0, 0, 0, 0, 40, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 124, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				73, 109, 112, 117, 108, 115, 101, 68, 101, 102,
				105, 110, 105, 116, 105, 111, 110, 0, 0, 0,
				0, 53, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 46, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 73, 109, 112, 117, 108,
				115, 101, 68, 101, 102, 105, 110, 105, 116, 105,
				111, 110, 124, 83, 105, 103, 110, 97, 108, 83,
				111, 117, 114, 99, 101, 0, 0, 0, 0, 59,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 46, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 73, 109, 112, 117, 108, 115, 101,
				68, 101, 102, 105, 110, 105, 116, 105, 111, 110,
				124, 76, 101, 103, 97, 99, 121, 83, 105, 103,
				110, 97, 108, 83, 111, 117, 114, 99, 101, 0,
				0, 0, 0, 38, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 124, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 73, 109, 112,
				117, 108, 115, 101, 76, 105, 115, 116, 101, 110,
				101, 114, 0, 0, 0, 0, 54, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 46, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				73, 109, 112, 117, 108, 115, 101, 76, 105, 115,
				116, 101, 110, 101, 114, 124, 73, 109, 112, 117,
				108, 115, 101, 82, 101, 97, 99, 116, 105, 111,
				110, 0, 0, 0, 0, 55, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 124, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 73,
				109, 112, 117, 108, 115, 101, 69, 110, 118, 101,
				108, 111, 112, 101, 80, 114, 111, 112, 101, 114,
				116, 121, 65, 116, 116, 114, 105, 98, 117, 116,
				101, 0, 0, 0, 0, 54, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 124, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 73,
				109, 112, 117, 108, 115, 101, 67, 104, 97, 110,
				110, 101, 108, 80, 114, 111, 112, 101, 114, 116,
				121, 65, 116, 116, 114, 105, 98, 117, 116, 101,
				0, 0, 0, 0, 37, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 124, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 73, 109,
				112, 117, 108, 115, 101, 77, 97, 110, 97, 103,
				101, 114, 0, 0, 0, 0, 56, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 46, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				73, 109, 112, 117, 108, 115, 101, 77, 97, 110,
				97, 103, 101, 114, 124, 69, 110, 118, 101, 108,
				111, 112, 101, 68, 101, 102, 105, 110, 105, 116,
				105, 111, 110, 0, 0, 0, 0, 50, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 46,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 73, 109, 112, 117, 108, 115, 101, 77, 97,
				110, 97, 103, 101, 114, 124, 73, 109, 112, 117,
				108, 115, 101, 69, 118, 101, 110, 116, 0, 0,
				0, 0, 36, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 124, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 73, 109, 112, 117,
				108, 115, 101, 83, 111, 117, 114, 99, 101, 0,
				0, 0, 0, 49, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 124, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 73, 110, 100,
				101, 112, 101, 110, 100, 101, 110, 116, 73, 109,
				112, 117, 108, 115, 101, 76, 105, 115, 116, 101,
				110, 101, 114, 0, 0, 0, 0, 44, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 46,
				80, 111, 115, 116, 70, 88, 124, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 80, 111,
				115, 116, 80, 114, 111, 99, 101, 115, 115, 105,
				110, 103, 0, 0, 0, 0, 44, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 46, 80,
				111, 115, 116, 70, 88, 124, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 86, 111, 108,
				117, 109, 101, 83, 101, 116, 116, 105, 110, 103,
				115, 0, 0, 0, 0, 22, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 124, 67, 108,
				105, 112, 112, 101, 114, 76, 105, 98, 0, 0,
				0, 0, 34, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 46, 67, 108, 105, 112, 112,
				101, 114, 76, 105, 98, 124, 68, 111, 117, 98,
				108, 101, 80, 111, 105, 110, 116, 0, 0, 0,
				0, 31, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 46, 67, 108, 105, 112, 112, 101,
				114, 76, 105, 98, 124, 80, 111, 108, 121, 84,
				114, 101, 101, 0, 0, 0, 0, 31, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 46,
				67, 108, 105, 112, 112, 101, 114, 76, 105, 98,
				124, 80, 111, 108, 121, 78, 111, 100, 101, 0,
				0, 0, 0, 29, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 46, 67, 108, 105, 112,
				112, 101, 114, 76, 105, 98, 124, 73, 110, 116,
				49, 50, 56, 0, 0, 0, 0, 31, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 46,
				67, 108, 105, 112, 112, 101, 114, 76, 105, 98,
				124, 73, 110, 116, 80, 111, 105, 110, 116, 0,
				0, 0, 0, 30, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 46, 67, 108, 105, 112,
				112, 101, 114, 76, 105, 98, 124, 73, 110, 116,
				82, 101, 99, 116, 0, 0, 0, 0, 28, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				46, 67, 108, 105, 112, 112, 101, 114, 76, 105,
				98, 124, 84, 69, 100, 103, 101, 0, 0, 0,
				0, 36, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 46, 67, 108, 105, 112, 112, 101,
				114, 76, 105, 98, 124, 73, 110, 116, 101, 114,
				115, 101, 99, 116, 78, 111, 100, 101, 0, 0,
				0, 0, 42, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 46, 67, 108, 105, 112, 112,
				101, 114, 76, 105, 98, 124, 77, 121, 73, 110,
				116, 101, 114, 115, 101, 99, 116, 78, 111, 100,
				101, 83, 111, 114, 116, 0, 0, 0, 0, 34,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 46, 67, 108, 105, 112, 112, 101, 114, 76,
				105, 98, 124, 76, 111, 99, 97, 108, 77, 105,
				110, 105, 109, 97, 0, 0, 0, 0, 31, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				46, 67, 108, 105, 112, 112, 101, 114, 76, 105,
				98, 124, 83, 99, 97, 110, 98, 101, 97, 109,
				0, 0, 0, 0, 29, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 46, 67, 108, 105,
				112, 112, 101, 114, 76, 105, 98, 124, 77, 97,
				120, 105, 109, 97, 0, 0, 0, 0, 29, 67,
				105, 110, 101, 109, 97, 99, 104, 105, 110, 101,
				46, 67, 108, 105, 112, 112, 101, 114, 76, 105,
				98, 124, 79, 117, 116, 82, 101, 99, 0, 0,
				0, 0, 28, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 46, 67, 108, 105, 112, 112,
				101, 114, 76, 105, 98, 124, 79, 117, 116, 80,
				116, 0, 0, 0, 0, 27, 67, 105, 110, 101,
				109, 97, 99, 104, 105, 110, 101, 46, 67, 108,
				105, 112, 112, 101, 114, 76, 105, 98, 124, 74,
				111, 105, 110, 0, 0, 0, 0, 34, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 46,
				67, 108, 105, 112, 112, 101, 114, 76, 105, 98,
				124, 67, 108, 105, 112, 112, 101, 114, 66, 97,
				115, 101, 0, 0, 0, 0, 30, 67, 105, 110,
				101, 109, 97, 99, 104, 105, 110, 101, 46, 67,
				108, 105, 112, 112, 101, 114, 76, 105, 98, 124,
				67, 108, 105, 112, 112, 101, 114, 0, 0, 0,
				0, 36, 67, 105, 110, 101, 109, 97, 99, 104,
				105, 110, 101, 46, 67, 108, 105, 112, 112, 101,
				114, 76, 105, 98, 124, 67, 108, 105, 112, 112,
				101, 114, 79, 102, 102, 115, 101, 116, 0, 0,
				0, 0, 39, 67, 105, 110, 101, 109, 97, 99,
				104, 105, 110, 101, 46, 67, 108, 105, 112, 112,
				101, 114, 76, 105, 98, 124, 67, 108, 105, 112,
				112, 101, 114, 69, 120, 99, 101, 112, 116, 105,
				111, 110, 0, 0, 0, 0, 17, 124, 67, 105,
				110, 101, 109, 97, 99, 104, 105, 110, 101, 77,
				105, 120, 101, 114, 0, 0, 0, 0, 16, 124,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 83, 104, 111, 116, 0, 0, 0, 0, 24,
				124, 67, 105, 110, 101, 109, 97, 99, 104, 105,
				110, 101, 83, 104, 111, 116, 80, 108, 97, 121,
				97, 98, 108, 101, 0, 0, 0, 0, 17, 124,
				67, 105, 110, 101, 109, 97, 99, 104, 105, 110,
				101, 84, 114, 97, 99, 107
			},
			TotalFiles = 76,
			TotalTypes = 171,
			IsEditorOnly = false
		};
	}
}
namespace Cinemachine
{
	[AddComponentMenu("")]
	[ExecuteAlways]
	[SaveDuringPlay]
	[DisallowMultipleComponent]
	public class Cinemachine3rdPersonAim : CinemachineExtension
	{
		[Header("Aim Target Detection")]
		[Tooltip("Objects on these layers will be detected")]
		public LayerMask AimCollisionFilter;

		[TagField]
		[Tooltip("Objects with this tag will be ignored.  It is a good idea to set this field to the target's tag")]
		public string IgnoreTag = string.Empty;

		[Tooltip("How far to project the object detection ray")]
		public float AimDistance;

		[Tooltip("This 2D object will be positioned in the game view over the raycast hit point, if any, or will remain in the center of the screen if no hit point is detected.  May be null, in which case no on-screen indicator will appear")]
		public RectTransform AimTargetReticle;

		public Vector3 AimTarget { get; private set; }

		private void OnValidate()
		{
			AimDistance = Mathf.Max(1f, AimDistance);
		}

		private void Reset()
		{
			AimCollisionFilter = 1;
			IgnoreTag = string.Empty;
			AimDistance = 200f;
			AimTargetReticle = null;
		}

		public override bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
		{
			CinemachineCore.CameraUpdatedEvent.RemoveListener(DrawReticle);
			CinemachineCore.CameraUpdatedEvent.AddListener(DrawReticle);
			return false;
		}

		private void DrawReticle(CinemachineBrain brain)
		{
			if (!brain.IsLive(base.VirtualCamera) || brain.OutputCamera == null)
			{
				CinemachineCore.CameraUpdatedEvent.RemoveListener(DrawReticle);
			}
			else if (AimTargetReticle != null)
			{
				AimTargetReticle.position = brain.OutputCamera.WorldToScreenPoint(AimTarget);
			}
		}

		private Vector3 ComputeLookAtPoint(Vector3 camPos, Transform player)
		{
			float num = AimDistance;
			Quaternion rotation = player.rotation;
			Vector3 vector = rotation * Vector3.forward;
			Vector3 vector2 = Quaternion.Inverse(rotation) * (player.position - camPos);
			if (vector2.z > 0f)
			{
				camPos += vector * vector2.z;
				num -= vector2.z;
			}
			num = Mathf.Max(1f, num);
			if (!RuntimeUtility.RaycastIgnoreTag(new Ray(camPos, vector), out var hitInfo, num, AimCollisionFilter, in IgnoreTag))
			{
				return camPos + vector * num;
			}
			return hitInfo.point;
		}

		private Vector3 ComputeAimTarget(Vector3 cameraLookAt, Transform player)
		{
			Vector3 position = player.position;
			Vector3 direction = cameraLookAt - position;
			if (RuntimeUtility.RaycastIgnoreTag(new Ray(position, direction), out var hitInfo, direction.magnitude, AimCollisionFilter, in IgnoreTag))
			{
				return hitInfo.point;
			}
			return cameraLookAt;
		}

		protected override void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, CinemachineCore.Stage stage, ref CameraState state, float deltaTime)
		{
			if (stage == CinemachineCore.Stage.Body)
			{
				Transform follow = vcam.Follow;
				if (follow != null)
				{
					state.ReferenceLookAt = ComputeLookAtPoint(state.CorrectedPosition, follow);
					AimTarget = ComputeAimTarget(state.ReferenceLookAt, follow);
				}
			}
			if (stage == CinemachineCore.Stage.Finalize)
			{
				Vector3 forward = state.ReferenceLookAt - state.FinalPosition;
				if (forward.sqrMagnitude > 0.01f)
				{
					state.RawOrientation = Quaternion.LookRotation(forward, state.ReferenceUp);
					state.OrientationCorrection = Quaternion.identity;
				}
			}
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[DisallowMultipleComponent]
	[ExecuteAlways]
	[ExcludeFromPreset]
	[AddComponentMenu("Cinemachine/CinemachineBlendListCamera")]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineBlendListCamera.html")]
	public class CinemachineBlendListCamera : CinemachineVirtualCameraBase
	{
		[Serializable]
		public struct Instruction
		{
			[Tooltip("The virtual camera to activate when this instruction becomes active")]
			public CinemachineVirtualCameraBase m_VirtualCamera;

			[Tooltip("How long to wait (in seconds) before activating the next virtual camera in the list (if any)")]
			public float m_Hold;

			[CinemachineBlendDefinitionProperty]
			[Tooltip("How to blend to the next virtual camera in the list (if any)")]
			public CinemachineBlendDefinition m_Blend;
		}

		[Tooltip("Default object for the camera children to look at (the aim target), if not specified in a child camera.  May be empty if all of the children define targets of their own.")]
		[NoSaveDuringPlay]
		[VcamTargetProperty]
		public Transform m_LookAt;

		[Tooltip("Default object for the camera children wants to move with (the body target), if not specified in a child camera.  May be empty if all of the children define targets of their own.")]
		[NoSaveDuringPlay]
		[VcamTargetProperty]
		public Transform m_Follow;

		[Tooltip("When enabled, the current child camera and blend will be indicated in the game window, for debugging")]
		public bool m_ShowDebugText;

		[Tooltip("When enabled, the child vcams will cycle indefinitely instead of just stopping at the last one")]
		public bool m_Loop;

		[SerializeField]
		[HideInInspector]
		[NoSaveDuringPlay]
		internal CinemachineVirtualCameraBase[] m_ChildCameras;

		[Tooltip("The set of instructions for enabling child cameras.")]
		public Instruction[] m_Instructions;

		private ICinemachineCamera m_TransitioningFrom;

		private CameraState m_State = CameraState.Default;

		private float mActivationTime = -1f;

		private int mCurrentInstruction;

		private CinemachineBlend mActiveBlend;

		public override string Description
		{
			get
			{
				if (mActiveBlend != null)
				{
					return mActiveBlend.Description;
				}
				ICinemachineCamera liveChild = LiveChild;
				if (liveChild == null)
				{
					return "(none)";
				}
				StringBuilder stringBuilder = CinemachineDebug.SBFromPool();
				stringBuilder.Append("[");
				stringBuilder.Append(liveChild.Name);
				stringBuilder.Append("]");
				string result = stringBuilder.ToString();
				CinemachineDebug.ReturnToPool(stringBuilder);
				return result;
			}
		}

		public ICinemachineCamera LiveChild { get; set; }

		public override CameraState State => m_State;

		public override Transform LookAt
		{
			get
			{
				return ResolveLookAt(m_LookAt);
			}
			set
			{
				m_LookAt = value;
			}
		}

		public override Transform Follow
		{
			get
			{
				return ResolveFollow(m_Follow);
			}
			set
			{
				m_Follow = value;
			}
		}

		public CinemachineVirtualCameraBase[] ChildCameras
		{
			get
			{
				UpdateListOfChildren();
				return m_ChildCameras;
			}
		}

		public bool IsBlending => mActiveBlend != null;

		private void Reset()
		{
			m_LookAt = null;
			m_Follow = null;
			m_ShowDebugText = false;
			m_Loop = false;
			m_Instructions = null;
			m_ChildCameras = null;
		}

		public override bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly = false)
		{
			if (vcam != LiveChild)
			{
				if (mActiveBlend != null)
				{
					return mActiveBlend.Uses(vcam);
				}
				return false;
			}
			return true;
		}

		public override void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
			UpdateListOfChildren();
			CinemachineVirtualCameraBase[] childCameras = m_ChildCameras;
			for (int i = 0; i < childCameras.Length; i++)
			{
				childCameras[i].OnTargetObjectWarped(target, positionDelta);
			}
			base.OnTargetObjectWarped(target, positionDelta);
		}

		public override void ForceCameraPosition(Vector3 pos, Quaternion rot)
		{
			UpdateListOfChildren();
			CinemachineVirtualCameraBase[] childCameras = m_ChildCameras;
			for (int i = 0; i < childCameras.Length; i++)
			{
				childCameras[i].ForceCameraPosition(pos, rot);
			}
			base.ForceCameraPosition(pos, rot);
		}

		public override void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
		{
			base.OnTransitionFromCamera(fromCam, worldUp, deltaTime);
			InvokeOnTransitionInExtensions(fromCam, worldUp, deltaTime);
			mActivationTime = CinemachineCore.CurrentTime;
			mCurrentInstruction = 0;
			LiveChild = null;
			mActiveBlend = null;
			m_TransitioningFrom = fromCam;
			InternalUpdateCameraState(worldUp, deltaTime);
		}

		public override void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
		{
			if (!PreviousStateIsValid)
			{
				mCurrentInstruction = -1;
				mActiveBlend = null;
			}
			UpdateListOfChildren();
			AdvanceCurrentInstruction(deltaTime);
			CinemachineVirtualCameraBase cinemachineVirtualCameraBase = null;
			if (mCurrentInstruction >= 0 && mCurrentInstruction < m_Instructions.Length)
			{
				cinemachineVirtualCameraBase = m_Instructions[mCurrentInstruction].m_VirtualCamera;
			}
			if (cinemachineVirtualCameraBase != null)
			{
				if (!cinemachineVirtualCameraBase.gameObject.activeInHierarchy)
				{
					cinemachineVirtualCameraBase.gameObject.SetActive(value: true);
					cinemachineVirtualCameraBase.UpdateCameraState(worldUp, deltaTime);
				}
				ICinemachineCamera liveChild = LiveChild;
				LiveChild = cinemachineVirtualCameraBase;
				if (liveChild != LiveChild && LiveChild != null)
				{
					LiveChild.OnTransitionFromCamera(liveChild, worldUp, deltaTime);
					CinemachineCore.Instance.GenerateCameraActivationEvent(LiveChild, liveChild);
					if (liveChild != null)
					{
						mActiveBlend = CreateBlend(liveChild, LiveChild, m_Instructions[mCurrentInstruction].m_Blend, mActiveBlend);
						if (mActiveBlend == null || !mActiveBlend.Uses(liveChild))
						{
							CinemachineCore.Instance.GenerateCameraCutEvent(LiveChild);
						}
					}
				}
			}
			if (mActiveBlend != null)
			{
				mActiveBlend.TimeInBlend += ((deltaTime >= 0f) ? deltaTime : mActiveBlend.Duration);
				if (mActiveBlend.IsComplete)
				{
					mActiveBlend = null;
				}
			}
			if (mActiveBlend != null)
			{
				mActiveBlend.UpdateCameraState(worldUp, deltaTime);
				m_State = mActiveBlend.State;
			}
			else if (LiveChild != null)
			{
				if (m_TransitioningFrom != null)
				{
					LiveChild.OnTransitionFromCamera(m_TransitioningFrom, worldUp, deltaTime);
				}
				m_State = LiveChild.State;
			}
			m_TransitioningFrom = null;
			InvokePostPipelineStageCallback(this, CinemachineCore.Stage.Finalize, ref m_State, deltaTime);
			PreviousStateIsValid = true;
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			InvalidateListOfChildren();
			LiveChild = null;
			mActiveBlend = null;
			CinemachineDebug.OnGUIHandlers = (CinemachineDebug.OnGUIDelegate)Delegate.Remove(CinemachineDebug.OnGUIHandlers, new CinemachineDebug.OnGUIDelegate(OnGuiHandler));
			CinemachineDebug.OnGUIHandlers = (CinemachineDebug.OnGUIDelegate)Delegate.Combine(CinemachineDebug.OnGUIHandlers, new CinemachineDebug.OnGUIDelegate(OnGuiHandler));
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			CinemachineDebug.OnGUIHandlers = (CinemachineDebug.OnGUIDelegate)Delegate.Remove(CinemachineDebug.OnGUIHandlers, new CinemachineDebug.OnGUIDelegate(OnGuiHandler));
		}

		private void OnTransformChildrenChanged()
		{
			InvalidateListOfChildren();
		}

		private void OnGuiHandler()
		{
			if (!m_ShowDebugText)
			{
				CinemachineDebug.ReleaseScreenPos(this);
				return;
			}
			StringBuilder stringBuilder = CinemachineDebug.SBFromPool();
			stringBuilder.Append(base.Name);
			stringBuilder.Append(": ");
			stringBuilder.Append(Description);
			string text = stringBuilder.ToString();
			GUI.Label(CinemachineDebug.GetScreenPos(this, text, GUI.skin.box), text, GUI.skin.box);
			CinemachineDebug.ReturnToPool(stringBuilder);
		}

		private void InvalidateListOfChildren()
		{
			m_ChildCameras = null;
			LiveChild = null;
		}

		private void UpdateListOfChildren()
		{
			if (m_ChildCameras != null)
			{
				return;
			}
			List<CinemachineVirtualCameraBase> list = new List<CinemachineVirtualCameraBase>();
			CinemachineVirtualCameraBase[] componentsInChildren = GetComponentsInChildren<CinemachineVirtualCameraBase>(includeInactive: true);
			foreach (CinemachineVirtualCameraBase cinemachineVirtualCameraBase in componentsInChildren)
			{
				if (cinemachineVirtualCameraBase.transform.parent == base.transform)
				{
					list.Add(cinemachineVirtualCameraBase);
				}
			}
			m_ChildCameras = list.ToArray();
			ValidateInstructions();
		}

		internal void ValidateInstructions()
		{
			if (m_Instructions == null)
			{
				m_Instructions = Array.Empty<Instruction>();
			}
			for (int i = 0; i < m_Instructions.Length; i++)
			{
				if (m_Instructions[i].m_VirtualCamera != null && m_Instructions[i].m_VirtualCamera.transform.parent != base.transform)
				{
					m_Instructions[i].m_VirtualCamera = null;
				}
			}
			mActiveBlend = null;
		}

		private void AdvanceCurrentInstruction(float deltaTime)
		{
			if (m_ChildCameras == null || m_ChildCameras.Length == 0 || mActivationTime < 0f || m_Instructions.Length == 0)
			{
				mActivationTime = -1f;
				mCurrentInstruction = -1;
				mActiveBlend = null;
				return;
			}
			float currentTime = CinemachineCore.CurrentTime;
			if (mCurrentInstruction < 0 || deltaTime < 0f)
			{
				mActivationTime = currentTime;
				mCurrentInstruction = 0;
			}
			if (mCurrentInstruction > m_Instructions.Length - 1)
			{
				mActivationTime = currentTime;
				mCurrentInstruction = m_Instructions.Length - 1;
			}
			float b = m_Instructions[mCurrentInstruction].m_Hold + m_Instructions[mCurrentInstruction].m_Blend.BlendTime;
			float a = ((mCurrentInstruction < m_Instructions.Length - 1 || m_Loop) ? 0f : float.MaxValue);
			if (currentTime - mActivationTime > Mathf.Max(a, b))
			{
				mActivationTime = currentTime;
				mCurrentInstruction++;
				if (m_Loop && mCurrentInstruction == m_Instructions.Length)
				{
					mCurrentInstruction = 0;
				}
			}
		}
	}
	public interface ICameraOverrideStack
	{
		Vector3 DefaultWorldUp { get; }

		int SetCameraOverride(int overrideId, ICinemachineCamera camA, ICinemachineCamera camB, float weightB, float deltaTime);

		void ReleaseCameraOverride(int overrideId);
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[DisallowMultipleComponent]
	[ExecuteAlways]
	[AddComponentMenu("Cinemachine/CinemachineBrain")]
	[SaveDuringPlay]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineBrainProperties.html")]
	public class CinemachineBrain : MonoBehaviour, ICameraOverrideStack
	{
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public enum UpdateMethod
		{
			FixedUpdate,
			LateUpdate,
			SmartUpdate,
			ManualUpdate
		}

		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public enum BrainUpdateMethod
		{
			FixedUpdate,
			LateUpdate
		}

		[Serializable]
		public class BrainEvent : UnityEvent<CinemachineBrain>
		{
		}

		[Serializable]
		public class VcamActivatedEvent : UnityEvent<ICinemachineCamera, ICinemachineCamera>
		{
		}

		private class BrainFrame
		{
			public int id;

			public CinemachineBlend blend = new CinemachineBlend(null, null, null, 0f, 0f);

			public CinemachineBlend workingBlend = new CinemachineBlend(null, null, null, 0f, 0f);

			public BlendSourceVirtualCamera workingBlendSource = new BlendSourceVirtualCamera(null);

			public float deltaTimeOverride;

			public float blendStartPosition;

			public bool Active => blend.IsValid;
		}

		[Tooltip("When enabled, the current camera and blend will be indicated in the game window, for debugging")]
		public bool m_ShowDebugText;

		[Tooltip("When enabled, the camera's frustum will be shown at all times in the scene view")]
		public bool m_ShowCameraFrustum = true;

		[Tooltip("When enabled, the cameras will always respond in real-time to user input and damping, even if the game is running in slow motion")]
		public bool m_IgnoreTimeScale;

		[Tooltip("If set, this object's Y axis will define the worldspace Up vector for all the virtual cameras.  This is useful for instance in top-down game environments.  If not set, Up is worldspace Y.  Setting this appropriately is important, because Virtual Cameras don't like looking straight up or straight down.")]
		public Transform m_WorldUpOverride;

		[Tooltip("The update time for the vcams.  Use FixedUpdate if all your targets are animated during FixedUpdate (e.g. RigidBodies), LateUpdate if all your targets are animated during the normal Update loop, and SmartUpdate if you want Cinemachine to do the appropriate thing on a per-target basis.  SmartUpdate is the recommended setting")]
		public UpdateMethod m_UpdateMethod = UpdateMethod.SmartUpdate;

		[Tooltip("The update time for the Brain, i.e. when the blends are evaluated and the brain's transform is updated")]
		public BrainUpdateMethod m_BlendUpdateMethod = BrainUpdateMethod.LateUpdate;

		[CinemachineBlendDefinitionProperty]
		[Tooltip("The blend that is used in cases where you haven't explicitly defined a blend between two Virtual Cameras")]
		public CinemachineBlendDefinition m_DefaultBlend = new CinemachineBlendDefinition(CinemachineBlendDefinition.Style.EaseInOut, 2f);

		[Tooltip("This is the asset that contains custom settings for blends between specific virtual cameras in your scene")]
		public CinemachineBlenderSettings m_CustomBlends;

		private Camera m_OutputCamera;

		private GameObject m_TargetOverride;

		[Tooltip("This event will fire whenever a virtual camera goes live and there is no blend")]
		public BrainEvent m_CameraCutEvent = new BrainEvent();

		[Tooltip("This event will fire whenever a virtual camera goes live.  If a blend is involved, then the event will fire on the first frame of the blend.")]
		public VcamActivatedEvent m_CameraActivatedEvent = new VcamActivatedEvent();

		private static ICinemachineCamera mSoloCamera;

		private Coroutine mPhysicsCoroutine;

		private int m_LastFrameUpdated;

		private WaitForFixedUpdate mWaitForFixedUpdate = new WaitForFixedUpdate();

		private List<BrainFrame> mFrameStack = new List<BrainFrame>();

		private int mNextFrameId = 1;

		private CinemachineBlend mCurrentLiveCameras = new CinemachineBlend(null, null, null, 0f, 0f);

		private static readonly AnimationCurve mDefaultLinearAnimationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		private ICinemachineCamera mActiveCameraPreviousFrame;

		private GameObject mActiveCameraPreviousFrameGameObject;

		public Camera OutputCamera
		{
			get
			{
				if (m_OutputCamera == null && !Application.isPlaying)
				{
					ControlledObject.TryGetComponent<Camera>(out m_OutputCamera);
				}
				return m_OutputCamera;
			}
		}

		public GameObject ControlledObject
		{
			get
			{
				if (!(m_TargetOverride == null))
				{
					return m_TargetOverride;
				}
				return base.gameObject;
			}
			set
			{
				if ((object)m_TargetOverride != value)
				{
					m_TargetOverride = value;
					ControlledObject.TryGetComponent<Camera>(out m_OutputCamera);
				}
			}
		}

		public static ICinemachineCamera SoloCamera
		{
			get
			{
				return mSoloCamera;
			}
			set
			{
				if (value != null && !CinemachineCore.Instance.IsLive(value))
				{
					value.OnTransitionFromCamera(null, Vector3.up, CinemachineCore.DeltaTime);
				}
				mSoloCamera = value;
			}
		}

		public Vector3 DefaultWorldUp
		{
			get
			{
				if (!(m_WorldUpOverride != null))
				{
					return Vector3.up;
				}
				return m_WorldUpOverride.transform.up;
			}
		}

		public ICinemachineCamera ActiveVirtualCamera
		{
			get
			{
				if (SoloCamera != null)
				{
					return SoloCamera;
				}
				return DeepCamBFromBlend(mCurrentLiveCameras);
			}
		}

		public bool IsBlending => ActiveBlend != null;

		public CinemachineBlend ActiveBlend
		{
			get
			{
				if (SoloCamera != null)
				{
					return null;
				}
				if (mCurrentLiveCameras.CamA == null || mCurrentLiveCameras.Equals(null) || mCurrentLiveCameras.IsComplete)
				{
					return null;
				}
				return mCurrentLiveCameras;
			}
			set
			{
				if (value == null)
				{
					mFrameStack[0].blend.Duration = 0f;
				}
				else
				{
					mFrameStack[0].blend = value;
				}
			}
		}

		public CameraState CurrentCameraState { get; private set; }

		public static Color GetSoloGUIColor()
		{
			return Color.Lerp(Color.red, Color.yellow, 0.8f);
		}

		private void OnEnable()
		{
			if (mFrameStack.Count == 0)
			{
				mFrameStack.Add(new BrainFrame());
			}
			CinemachineCore.Instance.AddActiveBrain(this);
			CinemachineDebug.OnGUIHandlers = (CinemachineDebug.OnGUIDelegate)Delegate.Remove(CinemachineDebug.OnGUIHandlers, new CinemachineDebug.OnGUIDelegate(OnGuiHandler));
			CinemachineDebug.OnGUIHandlers = (CinemachineDebug.OnGUIDelegate)Delegate.Combine(CinemachineDebug.OnGUIHandlers, new CinemachineDebug.OnGUIDelegate(OnGuiHandler));
			mPhysicsCoroutine = StartCoroutine(AfterPhysics());
			SceneManager.sceneLoaded += OnSceneLoaded;
			SceneManager.sceneUnloaded += OnSceneUnloaded;
		}

		private void OnDisable()
		{
			SceneManager.sceneLoaded -= OnSceneLoaded;
			SceneManager.sceneUnloaded -= OnSceneUnloaded;
			CinemachineDebug.OnGUIHandlers = (CinemachineDebug.OnGUIDelegate)Delegate.Remove(CinemachineDebug.OnGUIHandlers, new CinemachineDebug.OnGUIDelegate(OnGuiHandler));
			CinemachineCore.Instance.RemoveActiveBrain(this);
			mFrameStack.Clear();
			StopCoroutine(mPhysicsCoroutine);
		}

		private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
		{
			if (Time.frameCount == m_LastFrameUpdated && mFrameStack.Count > 0)
			{
				ManualUpdate();
			}
		}

		private void OnSceneUnloaded(Scene scene)
		{
			if (Time.frameCount == m_LastFrameUpdated && mFrameStack.Count > 0)
			{
				ManualUpdate();
			}
		}

		private void Awake()
		{
			ControlledObject.TryGetComponent<Camera>(out m_OutputCamera);
		}

		private void Start()
		{
			m_LastFrameUpdated = -1;
			UpdateVirtualCameras(CinemachineCore.UpdateFilter.Late, -1f);
		}

		private void OnGuiHandler()
		{
			if (!m_ShowDebugText)
			{
				CinemachineDebug.ReleaseScreenPos(this);
				return;
			}
			StringBuilder stringBuilder = CinemachineDebug.SBFromPool();
			Color color = GUI.color;
			stringBuilder.Length = 0;
			stringBuilder.Append("CM ");
			stringBuilder.Append(base.gameObject.name);
			stringBuilder.Append(": ");
			if (SoloCamera != null)
			{
				stringBuilder.Append("SOLO ");
				GUI.color = GetSoloGUIColor();
			}
			if (IsBlending)
			{
				stringBuilder.Append(ActiveBlend.Description);
			}
			else
			{
				ICinemachineCamera activeVirtualCamera = ActiveVirtualCamera;
				if (activeVirtualCamera == null)
				{
					stringBuilder.Append("(none)");
				}
				else
				{
					stringBuilder.Append("[");
					stringBuilder.Append(activeVirtualCamera.Name);
					stringBuilder.Append("]");
				}
			}
			string text = stringBuilder.ToString();
			GUI.Label(CinemachineDebug.GetScreenPos(this, text, GUI.skin.box), text, GUI.skin.box);
			GUI.color = color;
			CinemachineDebug.ReturnToPool(stringBuilder);
		}

		private IEnumerator AfterPhysics()
		{
			while (true)
			{
				yield return mWaitForFixedUpdate;
				if (m_UpdateMethod == UpdateMethod.FixedUpdate || m_UpdateMethod == UpdateMethod.SmartUpdate)
				{
					CinemachineCore.UpdateFilter updateFilter = CinemachineCore.UpdateFilter.Fixed;
					if (m_UpdateMethod == UpdateMethod.SmartUpdate)
					{
						UpdateTracker.OnUpdate(UpdateTracker.UpdateClock.Fixed);
						updateFilter = CinemachineCore.UpdateFilter.Smart;
					}
					UpdateVirtualCameras(updateFilter, GetEffectiveDeltaTime(fixedDelta: true));
				}
				if (m_BlendUpdateMethod == BrainUpdateMethod.FixedUpdate)
				{
					UpdateFrame0(Time.fixedDeltaTime);
					ProcessActiveCamera(Time.fixedDeltaTime);
				}
			}
		}

		private void LateUpdate()
		{
			if (m_UpdateMethod != UpdateMethod.ManualUpdate)
			{
				ManualUpdate();
			}
		}

		public void ManualUpdate()
		{
			m_LastFrameUpdated = Time.frameCount;
			float effectiveDeltaTime = GetEffectiveDeltaTime(fixedDelta: false);
			if (!Application.isPlaying || m_BlendUpdateMethod != BrainUpdateMethod.FixedUpdate)
			{
				UpdateFrame0(effectiveDeltaTime);
			}
			ComputeCurrentBlend(ref mCurrentLiveCameras, 0);
			if (Application.isPlaying && m_UpdateMethod == UpdateMethod.FixedUpdate)
			{
				if (m_BlendUpdateMethod != BrainUpdateMethod.FixedUpdate)
				{
					CinemachineCore.Instance.m_CurrentUpdateFilter = CinemachineCore.UpdateFilter.Fixed;
					if (SoloCamera == null)
					{
						mCurrentLiveCameras.UpdateCameraState(DefaultWorldUp, GetEffectiveDeltaTime(fixedDelta: true));
					}
				}
			}
			else
			{
				CinemachineCore.UpdateFilter updateFilter = CinemachineCore.UpdateFilter.Late;
				if (m_UpdateMethod == UpdateMethod.SmartUpdate)
				{
					UpdateTracker.OnUpdate(UpdateTracker.UpdateClock.Late);
					updateFilter = CinemachineCore.UpdateFilter.SmartLate;
				}
				UpdateVirtualCameras(updateFilter, effectiveDeltaTime);
			}
			if (!Application.isPlaying || m_BlendUpdateMethod != BrainUpdateMethod.FixedUpdate)
			{
				ProcessActiveCamera(effectiveDeltaTime);
			}
		}

		private float GetEffectiveDeltaTime(bool fixedDelta)
		{
			if (CinemachineCore.UniformDeltaTimeOverride >= 0f)
			{
				return CinemachineCore.UniformDeltaTimeOverride;
			}
			if (SoloCamera != null)
			{
				return Time.unscaledDeltaTime;
			}
			if (!Application.isPlaying)
			{
				for (int num = mFrameStack.Count - 1; num > 0; num--)
				{
					BrainFrame brainFrame = mFrameStack[num];
					if (brainFrame.Active)
					{
						return brainFrame.deltaTimeOverride;
					}
				}
				return -1f;
			}
			if (m_IgnoreTimeScale)
			{
				if (!fixedDelta)
				{
					return Time.unscaledDeltaTime;
				}
				return Time.fixedDeltaTime;
			}
			if (!fixedDelta)
			{
				return Time.deltaTime;
			}
			return Time.fixedDeltaTime;
		}

		private void UpdateVirtualCameras(CinemachineCore.UpdateFilter updateFilter, float deltaTime)
		{
			CinemachineCore.Instance.m_CurrentUpdateFilter = updateFilter;
			Camera outputCamera = OutputCamera;
			CinemachineCore.Instance.UpdateAllActiveVirtualCameras((outputCamera == null) ? (-1) : outputCamera.cullingMask, DefaultWorldUp, deltaTime);
			if (SoloCamera != null)
			{
				SoloCamera.UpdateCameraState(DefaultWorldUp, deltaTime);
			}
			mCurrentLiveCameras.UpdateCameraState(DefaultWorldUp, deltaTime);
			updateFilter = CinemachineCore.UpdateFilter.Late;
			if (Application.isPlaying)
			{
				if (m_UpdateMethod == UpdateMethod.SmartUpdate)
				{
					updateFilter |= CinemachineCore.UpdateFilter.Smart;
				}
				else if (m_UpdateMethod == UpdateMethod.FixedUpdate)
				{
					updateFilter = CinemachineCore.UpdateFilter.Fixed;
				}
			}
			CinemachineCore.Instance.m_CurrentUpdateFilter = updateFilter;
		}

		private static ICinemachineCamera DeepCamBFromBlend(CinemachineBlend blend)
		{
			ICinemachineCamera camB;
			for (camB = blend.CamB; camB != null; camB = blendSourceVirtualCamera.Blend.CamB)
			{
				if (!camB.IsValid)
				{
					return null;
				}
				if (!(camB is BlendSourceVirtualCamera blendSourceVirtualCamera))
				{
					break;
				}
			}
			return camB;
		}

		public bool IsLiveInBlend(ICinemachineCamera vcam)
		{
			if (vcam == mCurrentLiveCameras.CamA)
			{
				return true;
			}
			if (mCurrentLiveCameras.CamA is BlendSourceVirtualCamera blendSourceVirtualCamera && blendSourceVirtualCamera.Blend.Uses(vcam))
			{
				return true;
			}
			ICinemachineCamera parentCamera = vcam.ParentCamera;
			if (parentCamera != null && parentCamera.IsLiveChild(vcam))
			{
				return IsLiveInBlend(parentCamera);
			}
			return false;
		}

		private int GetBrainFrame(int withId)
		{
			for (int num = mFrameStack.Count - 1; num > 0; num--)
			{
				if (mFrameStack[num].id == withId)
				{
					return num;
				}
			}
			mFrameStack.Add(new BrainFrame
			{
				id = withId
			});
			return mFrameStack.Count - 1;
		}

		public int SetCameraOverride(int overrideId, ICinemachineCamera camA, ICinemachineCamera camB, float weightB, float deltaTime)
		{
			if (overrideId < 0)
			{
				overrideId = mNextFrameId++;
			}
			BrainFrame brainFrame = mFrameStack[GetBrainFrame(overrideId)];
			brainFrame.deltaTimeOverride = deltaTime;
			brainFrame.blend.CamA = camA;
			brainFrame.blend.CamB = camB;
			brainFrame.blend.BlendCurve = mDefaultLinearAnimationCurve;
			brainFrame.blend.Duration = 1f;
			brainFrame.blend.TimeInBlend = weightB;
			CinemachineVirtualCameraBase cinemachineVirtualCameraBase = camA as CinemachineVirtualCameraBase;
			if (cinemachineVirtualCameraBase != null)
			{
				cinemachineVirtualCameraBase.EnsureStarted();
			}
			cinemachineVirtualCameraBase = camB as CinemachineVirtualCameraBase;
			if (cinemachineVirtualCameraBase != null)
			{
				cinemachineVirtualCameraBase.EnsureStarted();
			}
			return overrideId;
		}

		public void ReleaseCameraOverride(int overrideId)
		{
			for (int num = mFrameStack.Count - 1; num > 0; num--)
			{
				if (mFrameStack[num].id == overrideId)
				{
					mFrameStack.RemoveAt(num);
					break;
				}
			}
		}

		private void ProcessActiveCamera(float deltaTime)
		{
			ICinemachineCamera activeVirtualCamera = ActiveVirtualCamera;
			if (SoloCamera != null)
			{
				CameraState state = SoloCamera.State;
				PushStateToUnityCamera(ref state);
			}
			else if (activeVirtualCamera == null)
			{
				CameraState state2 = CameraState.Default;
				Transform transform = ControlledObject.transform;
				state2.RawPosition = transform.position;
				state2.RawOrientation = transform.rotation;
				state2.Lens = LensSettings.FromCamera(m_OutputCamera);
				state2.BlendHint |= (CameraState.BlendHintValue)67;
				PushStateToUnityCamera(ref state2);
			}
			else
			{
				if (mActiveCameraPreviousFrameGameObject == null)
				{
					mActiveCameraPreviousFrame = null;
				}
				if (activeVirtualCamera != mActiveCameraPreviousFrame)
				{
					activeVirtualCamera.OnTransitionFromCamera(mActiveCameraPreviousFrame, DefaultWorldUp, deltaTime);
					if (m_CameraActivatedEvent != null)
					{
						m_CameraActivatedEvent.Invoke(activeVirtualCamera, mActiveCameraPreviousFrame);
					}
					if (!IsBlending || (mActiveCameraPreviousFrame != null && !ActiveBlend.Uses(mActiveCameraPreviousFrame)))
					{
						if (m_CameraCutEvent != null)
						{
							m_CameraCutEvent.Invoke(this);
						}
						if (CinemachineCore.CameraCutEvent != null)
						{
							CinemachineCore.CameraCutEvent.Invoke(this);
						}
					}
					activeVirtualCamera.UpdateCameraState(DefaultWorldUp, deltaTime);
				}
				CameraState state3 = mCurrentLiveCameras.State;
				PushStateToUnityCamera(ref state3);
			}
			mActiveCameraPreviousFrame = activeVirtualCamera;
			mActiveCameraPreviousFrameGameObject = activeVirtualCamera?.VirtualCameraGameObject;
		}

		private void UpdateFrame0(float deltaTime)
		{
			if (mFrameStack.Count == 0)
			{
				mFrameStack.Add(new BrainFrame());
			}
			BrainFrame brainFrame = mFrameStack[0];
			ICinemachineCamera cinemachineCamera = TopCameraFromPriorityQueue();
			ICinemachineCamera camB = brainFrame.blend.CamB;
			if (cinemachineCamera != camB)
			{
				if ((UnityEngine.Object)cinemachineCamera != null && (UnityEngine.Object)camB != null && deltaTime >= 0f)
				{
					CinemachineBlendDefinition cinemachineBlendDefinition = LookupBlend(camB, cinemachineCamera);
					float num = cinemachineBlendDefinition.BlendTime;
					float blendStartPosition = 0f;
					if (cinemachineBlendDefinition.BlendCurve != null && num > 0.0001f)
					{
						if (brainFrame.blend.IsComplete)
						{
							brainFrame.blend.CamA = camB;
						}
						else
						{
							if ((brainFrame.blend.CamA == cinemachineCamera || (brainFrame.blend.CamA as BlendSourceVirtualCamera)?.Blend.CamB == cinemachineCamera) && brainFrame.blend.CamB == camB)
							{
								float num2 = brainFrame.blendStartPosition + (1f - brainFrame.blendStartPosition) * brainFrame.blend.TimeInBlend / brainFrame.blend.Duration;
								num *= num2;
								blendStartPosition = 1f - num2;
							}
							brainFrame.blend.CamA = new BlendSourceVirtualCamera(new CinemachineBlend(brainFrame.blend.CamA, brainFrame.blend.CamB, brainFrame.blend.BlendCurve, brainFrame.blend.Duration, brainFrame.blend.TimeInBlend));
						}
					}
					brainFrame.blend.BlendCurve = cinemachineBlendDefinition.BlendCurve;
					brainFrame.blend.Duration = num;
					brainFrame.blend.TimeInBlend = 0f;
					brainFrame.blendStartPosition = blendStartPosition;
				}
				brainFrame.blend.CamB = cinemachineCamera;
			}
			if (brainFrame.blend.CamA != null)
			{
				brainFrame.blend.TimeInBlend += ((deltaTime >= 0f) ? deltaTime : brainFrame.blend.Duration);
				if (brainFrame.blend.IsComplete)
				{
					brainFrame.blend.CamA = null;
					brainFrame.blend.BlendCurve = null;
					brainFrame.blend.Duration = 0f;
					brainFrame.blend.TimeInBlend = 0f;
				}
			}
		}

		public void ComputeCurrentBlend(ref CinemachineBlend outputBlend, int numTopLayersToExclude)
		{
			if (mFrameStack.Count == 0)
			{
				mFrameStack.Add(new BrainFrame());
			}
			int index = 0;
			int num = Mathf.Max(1, mFrameStack.Count - numTopLayersToExclude);
			for (int i = 0; i < num; i++)
			{
				BrainFrame brainFrame = mFrameStack[i];
				if (i != 0 && !brainFrame.Active)
				{
					continue;
				}
				brainFrame.workingBlend.CamA = brainFrame.blend.CamA;
				brainFrame.workingBlend.CamB = brainFrame.blend.CamB;
				brainFrame.workingBlend.BlendCurve = brainFrame.blend.BlendCurve;
				brainFrame.workingBlend.Duration = brainFrame.blend.Duration;
				brainFrame.workingBlend.TimeInBlend = brainFrame.blend.TimeInBlend;
				if (i > 0 && !brainFrame.blend.IsComplete)
				{
					if (brainFrame.workingBlend.CamA == null)
					{
						if (mFrameStack[index].blend.IsComplete)
						{
							brainFrame.workingBlend.CamA = mFrameStack[index].blend.CamB;
						}
						else
						{
							brainFrame.workingBlendSource.Blend = mFrameStack[index].workingBlend;
							brainFrame.workingBlend.CamA = brainFrame.workingBlendSource;
						}
					}
					else if (brainFrame.workingBlend.CamB == null)
					{
						if (mFrameStack[index].blend.IsComplete)
						{
							brainFrame.workingBlend.CamB = mFrameStack[index].blend.CamB;
						}
						else
						{
							brainFrame.workingBlendSource.Blend = mFrameStack[index].workingBlend;
							brainFrame.workingBlend.CamB = brainFrame.workingBlendSource;
						}
					}
				}
				index = i;
			}
			CinemachineBlend workingBlend = mFrameStack[index].workingBlend;
			outputBlend.CamA = workingBlend.CamA;
			outputBlend.CamB = workingBlend.CamB;
			outputBlend.BlendCurve = workingBlend.BlendCurve;
			outputBlend.Duration = workingBlend.Duration;
			outputBlend.TimeInBlend = workingBlend.TimeInBlend;
		}

		public bool IsLive(ICinemachineCamera vcam, bool dominantChildOnly = false)
		{
			if (SoloCamera == vcam)
			{
				return true;
			}
			if (mCurrentLiveCameras.Uses(vcam))
			{
				return true;
			}
			ICinemachineCamera parentCamera = vcam.ParentCamera;
			while (parentCamera != null && parentCamera.IsLiveChild(vcam, dominantChildOnly))
			{
				if (SoloCamera == parentCamera || mCurrentLiveCameras.Uses(parentCamera))
				{
					return true;
				}
				vcam = parentCamera;
				parentCamera = vcam.ParentCamera;
			}
			return false;
		}

		protected virtual ICinemachineCamera TopCameraFromPriorityQueue()
		{
			CinemachineCore instance = CinemachineCore.Instance;
			Camera outputCamera = OutputCamera;
			int num = ((outputCamera == null) ? (-1) : outputCamera.cullingMask);
			int virtualCameraCount = instance.VirtualCameraCount;
			for (int i = 0; i < virtualCameraCount; i++)
			{
				CinemachineVirtualCameraBase virtualCamera = instance.GetVirtualCamera(i);
				GameObject gameObject = ((virtualCamera != null) ? virtualCamera.gameObject : null);
				if (gameObject != null && (num & (1 << gameObject.layer)) != 0)
				{
					return virtualCamera;
				}
			}
			return null;
		}

		private CinemachineBlendDefinition LookupBlend(ICinemachineCamera fromKey, ICinemachineCamera toKey)
		{
			CinemachineBlendDefinition cinemachineBlendDefinition = m_DefaultBlend;
			if (m_CustomBlends != null)
			{
				string fromCameraName = ((fromKey != null) ? fromKey.Name : string.Empty);
				string toCameraName = ((toKey != null) ? toKey.Name : string.Empty);
				cinemachineBlendDefinition = m_CustomBlends.GetBlendForVirtualCameras(fromCameraName, toCameraName, cinemachineBlendDefinition);
			}
			if (CinemachineCore.GetBlendOverride != null)
			{
				cinemachineBlendDefinition = CinemachineCore.GetBlendOverride(fromKey, toKey, cinemachineBlendDefinition, this);
			}
			return cinemachineBlendDefinition;
		}

		private void PushStateToUnityCamera(ref CameraState state)
		{
			CurrentCameraState = state;
			Transform obj = ControlledObject.transform;
			Vector3 pos = obj.position;
			Quaternion rot = obj.rotation;
			if ((state.BlendHint & CameraState.BlendHintValue.NoPosition) == 0)
			{
				pos = state.FinalPosition;
			}
			if ((state.BlendHint & CameraState.BlendHintValue.NoOrientation) == 0)
			{
				rot = state.FinalOrientation;
			}
			obj.ConservativeSetPositionAndRotation(pos, rot);
			if ((state.BlendHint & CameraState.BlendHintValue.NoLens) == 0)
			{
				Camera outputCamera = OutputCamera;
				if (outputCamera != null)
				{
					outputCamera.nearClipPlane = state.Lens.NearClipPlane;
					outputCamera.farClipPlane = state.Lens.FarClipPlane;
					outputCamera.orthographicSize = state.Lens.OrthographicSize;
					outputCamera.fieldOfView = state.Lens.FieldOfView;
					outputCamera.lensShift = state.Lens.LensShift;
					if (state.Lens.ModeOverride != LensSettings.OverrideModes.None)
					{
						outputCamera.orthographic = state.Lens.Orthographic;
					}
					bool flag = (outputCamera.usePhysicalProperties = ((state.Lens.ModeOverride == LensSettings.OverrideModes.None) ? outputCamera.usePhysicalProperties : state.Lens.IsPhysicalCamera));
					if (flag && state.Lens.IsPhysicalCamera)
					{
						outputCamera.sensorSize = state.Lens.SensorSize;
						outputCamera.gateFit = state.Lens.GateFit;
						outputCamera.focalLength = Camera.FieldOfViewToFocalLength(state.Lens.FieldOfView, state.Lens.SensorSize.y);
						outputCamera.focusDistance = state.Lens.FocusDistance;
					}
				}
			}
			if (CinemachineCore.CameraUpdatedEvent != null)
			{
				CinemachineCore.CameraUpdatedEvent.Invoke(this);
			}
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[DisallowMultipleComponent]
	[ExecuteAlways]
	[ExcludeFromPreset]
	[AddComponentMenu("Cinemachine/CinemachineClearShot")]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineClearShot.html")]
	public class CinemachineClearShot : CinemachineVirtualCameraBase
	{
		private struct Pair
		{
			public int a;

			public float b;
		}

		[Tooltip("Default object for the camera children to look at (the aim target), if not specified in a child camera.  May be empty if all children specify targets of their own.")]
		[NoSaveDuringPlay]
		[VcamTargetProperty]
		public Transform m_LookAt;

		[Tooltip("Default object for the camera children wants to move with (the body target), if not specified in a child camera.  May be empty if all children specify targets of their own.")]
		[NoSaveDuringPlay]
		[VcamTargetProperty]
		public Transform m_Follow;

		[Tooltip("When enabled, the current child camera and blend will be indicated in the game window, for debugging")]
		[NoSaveDuringPlay]
		public bool m_ShowDebugText;

		[SerializeField]
		[HideInInspector]
		[NoSaveDuringPlay]
		internal CinemachineVirtualCameraBase[] m_ChildCameras;

		[Tooltip("Wait this many seconds before activating a new child camera")]
		public float m_ActivateAfter;

		[Tooltip("An active camera must be active for at least this many seconds")]
		public float m_MinDuration;

		[Tooltip("If checked, camera choice will be randomized if multiple cameras are equally desirable.  Otherwise, child list order and child camera priority will be used.")]
		public bool m_RandomizeChoice;

		[CinemachineBlendDefinitionProperty]
		[Tooltip("The blend which is used if you don't explicitly define a blend between two Virtual Cameras")]
		public CinemachineBlendDefinition m_DefaultBlend = new CinemachineBlendDefinition(CinemachineBlendDefinition.Style.Cut, 0f);

		[HideInInspector]
		public CinemachineBlenderSettings m_CustomBlends;

		private CameraState m_State = CameraState.Default;

		private float mActivationTime;

		private float mPendingActivationTime;

		private ICinemachineCamera mPendingCamera;

		private CinemachineBlend mActiveBlend;

		private bool mRandomizeNow;

		private CinemachineVirtualCameraBase[] m_RandomizedChilden;

		private ICinemachineCamera m_TransitioningFrom;

		public override string Description
		{
			get
			{
				if (mActiveBlend != null)
				{
					return mActiveBlend.Description;
				}
				ICinemachineCamera liveChild = LiveChild;
				if (liveChild == null)
				{
					return "(none)";
				}
				StringBuilder stringBuilder = CinemachineDebug.SBFromPool();
				stringBuilder.Append("[");
				stringBuilder.Append(liveChild.Name);
				stringBuilder.Append("]");
				string result = stringBuilder.ToString();
				CinemachineDebug.ReturnToPool(stringBuilder);
				return result;
			}
		}

		public ICinemachineCamera LiveChild { get; set; }

		public override CameraState State => m_State;

		public override Transform LookAt
		{
			get
			{
				return ResolveLookAt(m_LookAt);
			}
			set
			{
				m_LookAt = value;
			}
		}

		public override Transform Follow
		{
			get
			{
				return ResolveFollow(m_Follow);
			}
			set
			{
				m_Follow = value;
			}
		}

		public bool IsBlending => mActiveBlend != null;

		public CinemachineBlend ActiveBlend => mActiveBlend;

		public CinemachineVirtualCameraBase[] ChildCameras
		{
			get
			{
				UpdateListOfChildren();
				return m_ChildCameras;
			}
		}

		public override bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly = false)
		{
			if (vcam != LiveChild)
			{
				if (mActiveBlend != null)
				{
					return mActiveBlend.Uses(vcam);
				}
				return false;
			}
			return true;
		}

		public override void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
			UpdateListOfChildren();
			CinemachineVirtualCameraBase[] childCameras = m_ChildCameras;
			for (int i = 0; i < childCameras.Length; i++)
			{
				childCameras[i].OnTargetObjectWarped(target, positionDelta);
			}
			base.OnTargetObjectWarped(target, positionDelta);
		}

		public override void ForceCameraPosition(Vector3 pos, Quaternion rot)
		{
			UpdateListOfChildren();
			CinemachineVirtualCameraBase[] childCameras = m_ChildCameras;
			for (int i = 0; i < childCameras.Length; i++)
			{
				childCameras[i].ForceCameraPosition(pos, rot);
			}
			base.ForceCameraPosition(pos, rot);
		}

		public override void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
		{
			UpdateListOfChildren();
			ICinemachineCamera liveChild = LiveChild;
			LiveChild = ChooseCurrentCamera(worldUp);
			if (liveChild != LiveChild && LiveChild != null)
			{
				LiveChild.OnTransitionFromCamera(liveChild, worldUp, deltaTime);
				CinemachineCore.Instance.GenerateCameraActivationEvent(LiveChild, liveChild);
				if (liveChild != null)
				{
					mActiveBlend = CreateBlend(liveChild, LiveChild, LookupBlend(liveChild, LiveChild), mActiveBlend);
					if (mActiveBlend == null || !mActiveBlend.Uses(liveChild))
					{
						CinemachineCore.Instance.GenerateCameraCutEvent(LiveChild);
					}
				}
			}
			if (mActiveBlend != null)
			{
				mActiveBlend.TimeInBlend += ((deltaTime >= 0f) ? deltaTime : mActiveBlend.Duration);
				if (mActiveBlend.IsComplete)
				{
					mActiveBlend = null;
				}
			}
			if (mActiveBlend != null)
			{
				mActiveBlend.UpdateCameraState(worldUp, deltaTime);
				m_State = mActiveBlend.State;
			}
			else if (LiveChild != null)
			{
				if (m_TransitioningFrom != null)
				{
					LiveChild.OnTransitionFromCamera(m_TransitioningFrom, worldUp, deltaTime);
				}
				m_State = LiveChild.State;
			}
			m_TransitioningFrom = null;
			InvokePostPipelineStageCallback(this, CinemachineCore.Stage.Finalize, ref m_State, deltaTime);
			PreviousStateIsValid = true;
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			InvalidateListOfChildren();
			mActiveBlend = null;
			CinemachineDebug.OnGUIHandlers = (CinemachineDebug.OnGUIDelegate)Delegate.Remove(CinemachineDebug.OnGUIHandlers, new CinemachineDebug.OnGUIDelegate(OnGuiHandler));
			CinemachineDebug.OnGUIHandlers = (CinemachineDebug.OnGUIDelegate)Delegate.Combine(CinemachineDebug.OnGUIHandlers, new CinemachineDebug.OnGUIDelegate(OnGuiHandler));
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			CinemachineDebug.OnGUIHandlers = (CinemachineDebug.OnGUIDelegate)Delegate.Remove(CinemachineDebug.OnGUIHandlers, new CinemachineDebug.OnGUIDelegate(OnGuiHandler));
		}

		public void OnTransformChildrenChanged()
		{
			InvalidateListOfChildren();
			UpdateListOfChildren();
		}

		private void OnGuiHandler()
		{
			if (!m_ShowDebugText)
			{
				CinemachineDebug.ReleaseScreenPos(this);
				return;
			}
			StringBuilder stringBuilder = CinemachineDebug.SBFromPool();
			stringBuilder.Append(base.Name);
			stringBuilder.Append(": ");
			stringBuilder.Append(Description);
			string text = stringBuilder.ToString();
			GUI.Label(CinemachineDebug.GetScreenPos(this, text, GUI.skin.box), text, GUI.skin.box);
			CinemachineDebug.ReturnToPool(stringBuilder);
		}

		private void InvalidateListOfChildren()
		{
			m_ChildCameras = null;
			m_RandomizedChilden = null;
			LiveChild = null;
		}

		public void ResetRandomization()
		{
			m_RandomizedChilden = null;
			mRandomizeNow = true;
		}

		private void UpdateListOfChildren()
		{
			if (m_ChildCameras != null)
			{
				return;
			}
			List<CinemachineVirtualCameraBase> list = new List<CinemachineVirtualCameraBase>();
			CinemachineVirtualCameraBase[] componentsInChildren = GetComponentsInChildren<CinemachineVirtualCameraBase>(includeInactive: true);
			foreach (CinemachineVirtualCameraBase cinemachineVirtualCameraBase in componentsInChildren)
			{
				if (cinemachineVirtualCameraBase.transform.parent == base.transform)
				{
					list.Add(cinemachineVirtualCameraBase);
				}
			}
			m_ChildCameras = list.ToArray();
			mActivationTime = (mPendingActivationTime = 0f);
			mPendingCamera = null;
			LiveChild = null;
			mActiveBlend = null;
		}

		private ICinemachineCamera ChooseCurrentCamera(Vector3 worldUp)
		{
			if (m_ChildCameras == null || m_ChildCameras.Length == 0)
			{
				mActivationTime = 0f;
				return null;
			}
			CinemachineVirtualCameraBase[] array = m_ChildCameras;
			if (!m_RandomizeChoice)
			{
				m_RandomizedChilden = null;
			}
			else if (m_ChildCameras.Length > 1)
			{
				if (m_RandomizedChilden == null)
				{
					m_RandomizedChilden = Randomize(m_ChildCameras);
				}
				array = m_RandomizedChilden;
			}
			if (LiveChild != null && !LiveChild.VirtualCameraGameObject.activeSelf)
			{
				LiveChild = null;
			}
			ICinemachineCamera cinemachineCamera = LiveChild;
			foreach (CinemachineVirtualCameraBase cinemachineVirtualCameraBase in array)
			{
				if (cinemachineVirtualCameraBase != null && cinemachineVirtualCameraBase.gameObject.activeInHierarchy && (cinemachineCamera == null || cinemachineVirtualCameraBase.State.ShotQuality > cinemachineCamera.State.ShotQuality || (cinemachineVirtualCameraBase.State.ShotQuality == cinemachineCamera.State.ShotQuality && cinemachineVirtualCameraBase.Priority > cinemachineCamera.Priority) || (m_RandomizeChoice && mRandomizeNow && cinemachineVirtualCameraBase != LiveChild && cinemachineVirtualCameraBase.State.ShotQuality == cinemachineCamera.State.ShotQuality && cinemachineVirtualCameraBase.Priority == cinemachineCamera.Priority)))
				{
					cinemachineCamera = cinemachineVirtualCameraBase;
				}
			}
			mRandomizeNow = false;
			float currentTime = CinemachineCore.CurrentTime;
			if (mActivationTime != 0f)
			{
				if (LiveChild == cinemachineCamera)
				{
					mPendingActivationTime = 0f;
					mPendingCamera = null;
					return cinemachineCamera;
				}
				if (PreviousStateIsValid && mPendingActivationTime != 0f && mPendingCamera == cinemachineCamera)
				{
					if (currentTime - mPendingActivationTime > m_ActivateAfter && currentTime - mActivationTime > m_MinDuration)
					{
						m_RandomizedChilden = null;
						mActivationTime = currentTime;
						mPendingActivationTime = 0f;
						mPendingCamera = null;
						return cinemachineCamera;
					}
					return LiveChild;
				}
			}
			mPendingActivationTime = 0f;
			mPendingCamera = null;
			if (PreviousStateIsValid && mActivationTime > 0f && (m_ActivateAfter > 0f || currentTime - mActivationTime < m_MinDuration))
			{
				mPendingCamera = cinemachineCamera;
				mPendingActivationTime = currentTime;
				return LiveChild;
			}
			m_RandomizedChilden = null;
			mActivationTime = currentTime;
			return cinemachineCamera;
		}

		private CinemachineVirtualCameraBase[] Randomize(CinemachineVirtualCameraBase[] src)
		{
			List<Pair> list = new List<Pair>();
			for (int i = 0; i < src.Length; i++)
			{
				list.Add(new Pair
				{
					a = i,
					b = UnityEngine.Random.Range(0f, 1000f)
				});
			}
			list.Sort((Pair p1, Pair p2) => (int)p1.b - (int)p2.b);
			CinemachineVirtualCameraBase[] array = new CinemachineVirtualCameraBase[src.Length];
			Pair[] array2 = list.ToArray();
			for (int num = 0; num < src.Length; num++)
			{
				array[num] = src[array2[num].a];
			}
			return array;
		}

		private CinemachineBlendDefinition LookupBlend(ICinemachineCamera fromKey, ICinemachineCamera toKey)
		{
			CinemachineBlendDefinition cinemachineBlendDefinition = m_DefaultBlend;
			if (m_CustomBlends != null)
			{
				string fromCameraName = ((fromKey != null) ? fromKey.Name : string.Empty);
				string toCameraName = ((toKey != null) ? toKey.Name : string.Empty);
				cinemachineBlendDefinition = m_CustomBlends.GetBlendForVirtualCameras(fromCameraName, toCameraName, cinemachineBlendDefinition);
			}
			if (CinemachineCore.GetBlendOverride != null)
			{
				cinemachineBlendDefinition = CinemachineCore.GetBlendOverride(fromKey, toKey, cinemachineBlendDefinition, this);
			}
			return cinemachineBlendDefinition;
		}

		public override void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
		{
			base.OnTransitionFromCamera(fromCam, worldUp, deltaTime);
			InvokeOnTransitionInExtensions(fromCam, worldUp, deltaTime);
			m_TransitioningFrom = fromCam;
			if (m_RandomizeChoice && mActiveBlend == null)
			{
				m_RandomizedChilden = null;
				LiveChild = null;
			}
			InternalUpdateCameraState(worldUp, deltaTime);
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("")]
	[SaveDuringPlay]
	[ExecuteAlways]
	[DisallowMultipleComponent]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineCollider.html")]
	public class CinemachineCollider : CinemachineExtension
	{
		public enum ResolutionStrategy
		{
			PullCameraForward,
			PreserveCameraHeight,
			PreserveCameraDistance
		}

		private class VcamExtraState
		{
			public Vector3 previousDisplacement;

			public Vector3 previousCameraOffset;

			public Vector3 previousCameraPosition;

			public float previousDampTime;

			public bool targetObscured;

			public float occlusionStartTime;

			public List<Vector3> debugResolutionPath;

			private float m_SmoothedDistance;

			private float m_SmoothedTime;

			public void AddPointToDebugPath(Vector3 p)
			{
			}

			public float ApplyDistanceSmoothing(float distance, float smoothingTime)
			{
				if (m_SmoothedTime != 0f && smoothingTime > 0.0001f && CinemachineCore.CurrentTime - m_SmoothedTime < smoothingTime)
				{
					return Mathf.Min(distance, m_SmoothedDistance);
				}
				return distance;
			}

			public void UpdateDistanceSmoothing(float distance)
			{
				if (m_SmoothedDistance == 0f || distance < m_SmoothedDistance)
				{
					m_SmoothedDistance = distance;
					m_SmoothedTime = CinemachineCore.CurrentTime;
				}
			}

			public void ResetDistanceSmoothing(float smoothingTime)
			{
				if (CinemachineCore.CurrentTime - m_SmoothedTime >= smoothingTime)
				{
					m_SmoothedDistance = (m_SmoothedTime = 0f);
				}
			}
		}

		[Header("Obstacle Detection")]
		[Tooltip("Objects on these layers will be detected")]
		public LayerMask m_CollideAgainst = 1;

		[TagField]
		[Tooltip("Obstacles with this tag will be ignored.  It is a good idea to set this field to the target's tag")]
		public string m_IgnoreTag = string.Empty;

		[Tooltip("Objects on these layers will never obstruct view of the target")]
		public LayerMask m_TransparentLayers = 0;

		[Tooltip("Obstacles closer to the target than this will be ignored")]
		public float m_MinimumDistanceFromTarget = 0.1f;

		[Space]
		[Tooltip("When enabled, will attempt to resolve situations where the line of sight to the target is blocked by an obstacle")]
		[FormerlySerializedAs("m_PreserveLineOfSight")]
		public bool m_AvoidObstacles = true;

		[Tooltip("The maximum raycast distance when checking if the line of sight to this camera's target is clear.  If the setting is 0 or less, the current actual distance to target will be used.")]
		[FormerlySerializedAs("m_LineOfSightFeelerDistance")]
		public float m_DistanceLimit;

		[Tooltip("Don't take action unless occlusion has lasted at least this long.")]
		public float m_MinimumOcclusionTime;

		[Tooltip("Camera will try to maintain this distance from any obstacle.  Try to keep this value small.  Increase it if you are seeing inside obstacles due to a large FOV on the camera.")]
		public float m_CameraRadius = 0.1f;

		[Tooltip("The way in which the Collider will attempt to preserve sight of the target.")]
		public ResolutionStrategy m_Strategy = ResolutionStrategy.PreserveCameraHeight;

		[Range(1f, 10f)]
		[Tooltip("Upper limit on how many obstacle hits to process.  Higher numbers may impact performance.  In most environments, 4 is enough.")]
		public int m_MaximumEffort = 4;

		[Range(0f, 2f)]
		[Tooltip("Smoothing to apply to obstruction resolution.  Nearest camera point is held for at least this long")]
		public float m_SmoothingTime;

		[Range(0f, 10f)]
		[Tooltip("How gradually the camera returns to its normal position after having been corrected.  Higher numbers will move the camera more gradually back to normal.")]
		[FormerlySerializedAs("m_Smoothing")]
		public float m_Damping;

		[Range(0f, 10f)]
		[Tooltip("How gradually the camera moves to resolve an occlusion.  Higher numbers will move the camera more gradually.")]
		public float m_DampingWhenOccluded;

		[Header("Shot Evaluation")]
		[Tooltip("If greater than zero, a higher score will be given to shots when the target is closer to this distance.  Set this to zero to disable this feature.")]
		public float m_OptimalTargetDistance;

		private const float k_PrecisionSlush = 0.001f;

		private RaycastHit[] m_CornerBuffer = new RaycastHit[4];

		private const float k_AngleThreshold = 0.1f;

		private static Collider[] s_ColliderBuffer = new Collider[5];

		public List<List<Vector3>> DebugPaths
		{
			get
			{
				List<List<Vector3>> list = new List<List<Vector3>>();
				foreach (VcamExtraState allExtraState in GetAllExtraStates<VcamExtraState>())
				{
					if (allExtraState.debugResolutionPath != null && allExtraState.debugResolutionPath.Count > 0)
					{
						list.Add(allExtraState.debugResolutionPath);
					}
				}
				return list;
			}
		}

		public bool IsTargetObscured(ICinemachineCamera vcam)
		{
			return GetExtraState<VcamExtraState>(vcam).targetObscured;
		}

		public bool CameraWasDisplaced(ICinemachineCamera vcam)
		{
			return GetCameraDisplacementDistance(vcam) > 0f;
		}

		public float GetCameraDisplacementDistance(ICinemachineCamera vcam)
		{
			return GetExtraState<VcamExtraState>(vcam).previousDisplacement.magnitude;
		}

		private void OnValidate()
		{
			m_DistanceLimit = Mathf.Max(0f, m_DistanceLimit);
			m_MinimumOcclusionTime = Mathf.Max(0f, m_MinimumOcclusionTime);
			m_CameraRadius = Mathf.Max(0f, m_CameraRadius);
			m_MinimumDistanceFromTarget = Mathf.Max(0.01f, m_MinimumDistanceFromTarget);
			m_OptimalTargetDistance = Mathf.Max(0f, m_OptimalTargetDistance);
		}

		protected override void OnDestroy()
		{
			RuntimeUtility.DestroyScratchCollider();
			base.OnDestroy();
		}

		public override float GetMaxDampTime()
		{
			return Mathf.Max(m_Damping, Mathf.Max(m_DampingWhenOccluded, m_SmoothingTime));
		}

		public override void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
			List<VcamExtraState> allExtraStates = GetAllExtraStates<VcamExtraState>();
			for (int i = 0; i < allExtraStates.Count; i++)
			{
				allExtraStates[i].previousCameraPosition += positionDelta;
			}
		}

		protected override void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, CinemachineCore.Stage stage, ref CameraState state, float deltaTime)
		{
			if (stage == CinemachineCore.Stage.Body)
			{
				VcamExtraState extra = GetExtraState<VcamExtraState>(vcam);
				extra.targetObscured = false;
				extra.debugResolutionPath?.RemoveRange(0, extra.debugResolutionPath.Count);
				if (m_AvoidObstacles)
				{
					Vector3 correctedPosition = state.CorrectedPosition;
					Quaternion quaternion = Quaternion.Euler(state.PositionDampingBypass);
					extra.previousDisplacement = quaternion * extra.previousDisplacement;
					Vector3 vector = PreserveLineOfSight(ref state, ref extra);
					if (m_MinimumOcclusionTime > 0.0001f)
					{
						float currentTime = CinemachineCore.CurrentTime;
						if (vector.AlmostZero())
						{
							extra.occlusionStartTime = 0f;
						}
						else
						{
							if (extra.occlusionStartTime <= 0f)
							{
								extra.occlusionStartTime = currentTime;
							}
							if (currentTime - extra.occlusionStartTime < m_MinimumOcclusionTime)
							{
								vector = extra.previousDisplacement;
							}
						}
					}
					if (m_SmoothingTime > 0.0001f && state.HasLookAt)
					{
						Vector3 vector2 = correctedPosition + vector;
						Vector3 vector3 = vector2 - state.ReferenceLookAt;
						float magnitude = vector3.magnitude;
						if (magnitude > 0.0001f)
						{
							vector3 /= magnitude;
							if (!vector.AlmostZero())
							{
								extra.UpdateDistanceSmoothing(magnitude);
							}
							magnitude = extra.ApplyDistanceSmoothing(magnitude, m_SmoothingTime);
							vector += state.ReferenceLookAt + vector3 * magnitude - vector2;
						}
					}
					if (vector.AlmostZero())
					{
						extra.ResetDistanceSmoothing(m_SmoothingTime);
					}
					Vector3 vector4 = correctedPosition + vector;
					Vector3 vector5 = (state.HasLookAt ? state.ReferenceLookAt : vector4);
					vector += RespectCameraRadius(vector4, vector5);
					float num = m_DampingWhenOccluded;
					if (deltaTime >= 0f && base.VirtualCamera.PreviousStateIsValid && m_DampingWhenOccluded + m_Damping > 0.0001f)
					{
						float sqrMagnitude = vector.sqrMagnitude;
						num = ((sqrMagnitude > extra.previousDisplacement.sqrMagnitude) ? m_DampingWhenOccluded : m_Damping);
						if (sqrMagnitude < 0.0001f)
						{
							num = extra.previousDampTime - Damper.Damp(extra.previousDampTime, num, deltaTime);
						}
						if (num > 0f)
						{
							bool flag = false;
							if (vcam is CinemachineVirtualCamera)
							{
								CinemachineComponentBase cinemachineComponent = (vcam as CinemachineVirtualCamera).GetCinemachineComponent(CinemachineCore.Stage.Body);
								flag = cinemachineComponent != null && cinemachineComponent.BodyAppliesAfterAim;
							}
							Vector3 vector6 = (flag ? extra.previousDisplacement : (vector5 + quaternion * extra.previousCameraOffset - correctedPosition));
							vector = vector6 + Damper.Damp(vector - vector6, num, deltaTime);
						}
					}
					state.PositionCorrection += vector;
					vector4 = state.CorrectedPosition;
					if (state.HasLookAt && base.VirtualCamera.PreviousStateIsValid)
					{
						Vector3 v = extra.previousCameraPosition - state.ReferenceLookAt;
						Vector3 v2 = vector4 - state.ReferenceLookAt;
						if (v.sqrMagnitude > 0.0001f && v2.sqrMagnitude > 0.0001f)
						{
							state.PositionDampingBypass = UnityVectorExtensions.SafeFromToRotation(v, v2, state.ReferenceUp).eulerAngles;
						}
					}
					extra.previousDisplacement = vector;
					extra.previousCameraOffset = vector4 - vector5;
					extra.previousCameraPosition = vector4;
					extra.previousDampTime = num;
				}
			}
			if (stage != CinemachineCore.Stage.Aim)
			{
				return;
			}
			VcamExtraState extraState = GetExtraState<VcamExtraState>(vcam);
			extraState.targetObscured = IsTargetOffscreen(state) || CheckForTargetObstructions(state);
			if (extraState.targetObscured)
			{
				state.ShotQuality *= 0.2f;
			}
			if (!extraState.previousDisplacement.AlmostZero())
			{
				state.ShotQuality *= 0.8f;
			}
			float num2 = 0f;
			if (!(m_OptimalTargetDistance > 0f) || !state.HasLookAt)
			{
				return;
			}
			float num3 = Vector3.Magnitude(state.ReferenceLookAt - state.FinalPosition);
			if (num3 <= m_OptimalTargetDistance)
			{
				float num4 = m_OptimalTargetDistance / 2f;
				if (num3 >= num4)
				{
					num2 = 0.2f * (num3 - num4) / (m_OptimalTargetDistance - num4);
				}
			}
			else
			{
				num3 -= m_OptimalTargetDistance;
				float num5 = m_OptimalTargetDistance * 3f;
				if (num3 < num5)
				{
					num2 = 0.2f * (1f - num3 / num5);
				}
			}
			state.ShotQuality *= 1f + num2;
		}

		private Vector3 PreserveLineOfSight(ref CameraState state, ref VcamExtraState extra)
		{
			Vector3 result = Vector3.zero;
			if (state.HasLookAt && (int)m_CollideAgainst != 0 && (int)m_CollideAgainst != (int)m_TransparentLayers)
			{
				Vector3 correctedPosition = state.CorrectedPosition;
				Vector3 referenceLookAt = state.ReferenceLookAt;
				RaycastHit hitInfo = default(RaycastHit);
				result = PullCameraInFrontOfNearestObstacle(correctedPosition, referenceLookAt, (int)m_CollideAgainst & ~(int)m_TransparentLayers, ref hitInfo);
				Vector3 vector = correctedPosition + result;
				if (hitInfo.collider != null)
				{
					extra.AddPointToDebugPath(vector);
					if (m_Strategy != ResolutionStrategy.PullCameraForward)
					{
						Vector3 pushDir = correctedPosition - referenceLookAt;
						vector = PushCameraBack(vector, pushDir, hitInfo, referenceLookAt, new Plane(state.ReferenceUp, correctedPosition), pushDir.magnitude, m_MaximumEffort, ref extra);
					}
				}
				result = vector - correctedPosition;
			}
			return result;
		}

		private Vector3 PullCameraInFrontOfNearestObstacle(Vector3 cameraPos, Vector3 lookAtPos, int layerMask, ref RaycastHit hitInfo)
		{
			Vector3 result = Vector3.zero;
			Vector3 vector = cameraPos - lookAtPos;
			float magnitude = vector.magnitude;
			if (magnitude > 0.0001f)
			{
				vector /= magnitude;
				float num = Mathf.Max(m_MinimumDistanceFromTarget, 0.0001f);
				if (magnitude < num + 0.0001f)
				{
					result = vector * (num - magnitude);
				}
				else
				{
					float num2 = magnitude - num;
					if (m_DistanceLimit > 0.0001f)
					{
						num2 = Mathf.Min(m_DistanceLimit, num2);
					}
					Ray ray = new Ray(cameraPos - num2 * vector, vector);
					num2 += 0.001f;
					if (num2 > 0.0001f)
					{
						if (m_Strategy == ResolutionStrategy.PullCameraForward && m_CameraRadius >= 0.0001f)
						{
							if (RuntimeUtility.SphereCastIgnoreTag(lookAtPos + vector * m_CameraRadius, m_CameraRadius, vector, out hitInfo, num2 - m_CameraRadius, layerMask, in m_IgnoreTag))
							{
								result = hitInfo.point + hitInfo.normal * m_CameraRadius - cameraPos;
							}
						}
						else if (RuntimeUtility.RaycastIgnoreTag(ray, out hitInfo, num2, layerMask, in m_IgnoreTag))
						{
							float distance = Mathf.Max(0f, hitInfo.distance - 0.001f);
							result = ray.GetPoint(distance) - cameraPos;
						}
					}
				}
			}
			return result;
		}

		private Vector3 PushCameraBack(Vector3 currentPos, Vector3 pushDir, RaycastHit obstacle, Vector3 lookAtPos, Plane startPlane, float targetDistance, int iterations, ref VcamExtraState extra)
		{
			Vector3 vector = currentPos;
			Vector3 outDir = Vector3.zero;
			if (!GetWalkingDirection(vector, pushDir, obstacle, ref outDir))
			{
				return vector;
			}
			Ray ray = new Ray(vector, outDir);
			float pushBackDistance = GetPushBackDistance(ray, startPlane, targetDistance, lookAtPos);
			if (pushBackDistance <= 0.0001f)
			{
				return vector;
			}
			float num = ClampRayToBounds(ray, pushBackDistance, obstacle.collider.bounds);
			pushBackDistance = Mathf.Min(pushBackDistance, num + 0.001f);
			if (RuntimeUtility.RaycastIgnoreTag(ray, out var hitInfo, pushBackDistance, (int)m_CollideAgainst & ~(int)m_TransparentLayers, in m_IgnoreTag))
			{
				float distance = hitInfo.distance - 0.001f;
				vector = ray.GetPoint(distance);
				extra.AddPointToDebugPath(vector);
				if (iterations > 1)
				{
					vector = PushCameraBack(vector, outDir, hitInfo, lookAtPos, startPlane, targetDistance, iterations - 1, ref extra);
				}
				return vector;
			}
			vector = ray.GetPoint(pushBackDistance);
			outDir = vector - lookAtPos;
			float magnitude = outDir.magnitude;
			if (magnitude < 0.0001f || RuntimeUtility.RaycastIgnoreTag(new Ray(lookAtPos, outDir), out var _, magnitude - 0.001f, (int)m_CollideAgainst & ~(int)m_TransparentLayers, in m_IgnoreTag))
			{
				return currentPos;
			}
			ray = new Ray(vector, outDir);
			extra.AddPointToDebugPath(vector);
			pushBackDistance = GetPushBackDistance(ray, startPlane, targetDistance, lookAtPos);
			if (pushBackDistance > 0.0001f)
			{
				if (!RuntimeUtility.RaycastIgnoreTag(ray, out hitInfo, pushBackDistance, (int)m_CollideAgainst & ~(int)m_TransparentLayers, in m_IgnoreTag))
				{
					vector = ray.GetPoint(pushBackDistance);
					extra.AddPointToDebugPath(vector);
				}
				else
				{
					float distance2 = hitInfo.distance - 0.001f;
					vector = ray.GetPoint(distance2);
					extra.AddPointToDebugPath(vector);
					if (iterations > 1)
					{
						vector = PushCameraBack(vector, outDir, hitInfo, lookAtPos, startPlane, targetDistance, iterations - 1, ref extra);
					}
				}
			}
			return vector;
		}

		private bool GetWalkingDirection(Vector3 pos, Vector3 pushDir, RaycastHit obstacle, ref Vector3 outDir)
		{
			Vector3 normal = obstacle.normal;
			float num = 0.0050000004f;
			int num2 = Physics.SphereCastNonAlloc(pos, num, pushDir.normalized, m_CornerBuffer, 0f, (int)m_CollideAgainst & ~(int)m_TransparentLayers, QueryTriggerInteraction.Ignore);
			if (num2 > 1)
			{
				for (int i = 0; i < num2; i++)
				{
					if (m_CornerBuffer[i].collider == null || (m_IgnoreTag.Length > 0 && m_CornerBuffer[i].collider.CompareTag(m_IgnoreTag)))
					{
						continue;
					}
					Type type = m_CornerBuffer[i].collider.GetType();
					if (!(type == typeof(BoxCollider)) && !(type == typeof(SphereCollider)) && !(type == typeof(CapsuleCollider)))
					{
						continue;
					}
					Vector3 direction = m_CornerBuffer[i].collider.ClosestPoint(pos) - pos;
					if (direction.magnitude > 1E-05f && m_CornerBuffer[i].collider.Raycast(new Ray(pos, direction), out m_CornerBuffer[i], num))
					{
						if (!(m_CornerBuffer[i].normal - obstacle.normal).AlmostZero())
						{
							normal = m_CornerBuffer[i].normal;
						}
						break;
					}
				}
			}
			Vector3 vector = Vector3.Cross(obstacle.normal, normal);
			if (vector.AlmostZero())
			{
				vector = Vector3.ProjectOnPlane(pushDir, obstacle.normal);
			}
			else
			{
				float num3 = Vector3.Dot(vector, pushDir);
				if (Mathf.Abs(num3) < 0.0001f)
				{
					return false;
				}
				if (num3 < 0f)
				{
					vector = -vector;
				}
			}
			if (vector.AlmostZero())
			{
				return false;
			}
			outDir = vector.normalized;
			return true;
		}

		private float GetPushBackDistance(Ray ray, Plane startPlane, float targetDistance, Vector3 lookAtPos)
		{
			float num = targetDistance - (ray.origin - lookAtPos).magnitude;
			if (num < 0.0001f)
			{
				return 0f;
			}
			if (m_Strategy == ResolutionStrategy.PreserveCameraDistance)
			{
				return num;
			}
			if (!startPlane.Raycast(ray, out var enter))
			{
				enter = 0f;
			}
			enter = Mathf.Min(num, enter);
			if (enter < 0.0001f)
			{
				return 0f;
			}
			float num2 = Mathf.Abs(UnityVectorExtensions.Angle(startPlane.normal, ray.direction) - 90f);
			if (num2 < 0.1f)
			{
				enter = Mathf.Lerp(0f, enter, num2 / 0.1f);
			}
			return enter;
		}

		private static float ClampRayToBounds(Ray ray, float distance, Bounds bounds)
		{
			float enter;
			if (Vector3.Dot(ray.direction, Vector3.up) > 0f)
			{
				if (new Plane(Vector3.down, bounds.max).Raycast(ray, out enter) && enter > 0.0001f)
				{
					distance = Mathf.Min(distance, enter);
				}
			}
			else if (Vector3.Dot(ray.direction, Vector3.down) > 0f && new Plane(Vector3.up, bounds.min).Raycast(ray, out enter) && enter > 0.0001f)
			{
				distance = Mathf.Min(distance, enter);
			}
			if (Vector3.Dot(ray.direction, Vector3.right) > 0f)
			{
				if (new Plane(Vector3.left, bounds.max).Raycast(ray, out enter) && enter > 0.0001f)
				{
					distance = Mathf.Min(distance, enter);
				}
			}
			else if (Vector3.Dot(ray.direction, Vector3.left) > 0f && new Plane(Vector3.right, bounds.min).Raycast(ray, out enter) && enter > 0.0001f)
			{
				distance = Mathf.Min(distance, enter);
			}
			if (Vector3.Dot(ray.direction, Vector3.forward) > 0f)
			{
				if (new Plane(Vector3.back, bounds.max).Raycast(ray, out enter) && enter > 0.0001f)
				{
					distance = Mathf.Min(distance, enter);
				}
			}
			else if (Vector3.Dot(ray.direction, Vector3.back) > 0f && new Plane(Vector3.forward, bounds.min).Raycast(ray, out enter) && enter > 0.0001f)
			{
				distance = Mathf.Min(distance, enter);
			}
			return distance;
		}

		private Vector3 RespectCameraRadius(Vector3 cameraPos, Vector3 lookAtPos)
		{
			Vector3 vector = Vector3.zero;
			if (m_CameraRadius < 0.0001f || (int)m_CollideAgainst == 0)
			{
				return vector;
			}
			Vector3 vector2 = cameraPos - lookAtPos;
			float magnitude = vector2.magnitude;
			if (magnitude > 0.0001f)
			{
				vector2 /= magnitude;
			}
			int num = Physics.OverlapSphereNonAlloc(cameraPos, m_CameraRadius, s_ColliderBuffer, m_CollideAgainst, QueryTriggerInteraction.Ignore);
			RaycastHit hitInfo;
			if (num == 0 && (int)m_TransparentLayers != 0 && magnitude > m_MinimumDistanceFromTarget + 0.0001f)
			{
				float num2 = magnitude - m_MinimumDistanceFromTarget;
				if (RuntimeUtility.RaycastIgnoreTag(new Ray(lookAtPos + vector2 * m_MinimumDistanceFromTarget, vector2), out hitInfo, num2, m_CollideAgainst, in m_IgnoreTag))
				{
					Collider collider = hitInfo.collider;
					if (!collider.Raycast(new Ray(cameraPos, -vector2), out hitInfo, num2))
					{
						s_ColliderBuffer[num++] = collider;
					}
				}
			}
			if ((num > 0 && magnitude == 0f) || magnitude > m_MinimumDistanceFromTarget)
			{
				SphereCollider scratchCollider = RuntimeUtility.GetScratchCollider();
				scratchCollider.radius = m_CameraRadius;
				Vector3 vector3 = cameraPos;
				for (int i = 0; i < num; i++)
				{
					Collider collider2 = s_ColliderBuffer[i];
					if (m_IgnoreTag.Length > 0 && collider2.CompareTag(m_IgnoreTag))
					{
						continue;
					}
					if (magnitude > m_MinimumDistanceFromTarget)
					{
						vector2 = vector3 - lookAtPos;
						float magnitude2 = vector2.magnitude;
						if (magnitude2 > 0.0001f)
						{
							vector2 /= magnitude2;
							Ray ray = new Ray(lookAtPos, vector2);
							if (collider2.Raycast(ray, out hitInfo, magnitude2 + m_CameraRadius))
							{
								vector3 = ray.GetPoint(hitInfo.distance) - vector2 * 0.001f;
							}
						}
					}
					if (Physics.ComputePenetration(scratchCollider, vector3, Quaternion.identity, collider2, collider2.transform.position, collider2.transform.rotation, out var direction, out var distance))
					{
						vector3 += direction * distance;
					}
				}
				vector = vector3 - cameraPos;
			}
			if (magnitude > 0.0001f && m_MinimumDistanceFromTarget > 0.0001f)
			{
				float num3 = Mathf.Max(m_MinimumDistanceFromTarget, m_CameraRadius) + 0.001f;
				if ((cameraPos + vector - lookAtPos).magnitude < num3)
				{
					vector = lookAtPos - cameraPos + vector2 * num3;
				}
			}
			return vector;
		}

		private bool CheckForTargetObstructions(CameraState state)
		{
			if (state.HasLookAt)
			{
				Vector3 referenceLookAt = state.ReferenceLookAt;
				Vector3 correctedPosition = state.CorrectedPosition;
				Vector3 vector = referenceLookAt - correctedPosition;
				float magnitude = vector.magnitude;
				if (magnitude < Mathf.Max(m_MinimumDistanceFromTarget, 0.0001f))
				{
					return true;
				}
				if (RuntimeUtility.RaycastIgnoreTag(new Ray(correctedPosition, vector.normalized), out var _, magnitude - m_MinimumDistanceFromTarget, (int)m_CollideAgainst & ~(int)m_TransparentLayers, in m_IgnoreTag))
				{
					return true;
				}
			}
			return false;
		}

		private static bool IsTargetOffscreen(CameraState state)
		{
			if (state.HasLookAt)
			{
				Vector3 vector = state.ReferenceLookAt - state.CorrectedPosition;
				vector = Quaternion.Inverse(state.CorrectedOrientation) * vector;
				if (state.Lens.Orthographic)
				{
					if (Mathf.Abs(vector.y) > state.Lens.OrthographicSize)
					{
						return true;
					}
					if (Mathf.Abs(vector.x) > state.Lens.OrthographicSize * state.Lens.Aspect)
					{
						return true;
					}
				}
				else
				{
					float num = state.Lens.FieldOfView / 2f;
					if (UnityVectorExtensions.Angle(vector.ProjectOntoPlane(Vector3.right), Vector3.forward) > num)
					{
						return true;
					}
					num = 57.29578f * Mathf.Atan(Mathf.Tan(num * (MathF.PI / 180f)) * state.Lens.Aspect);
					if (UnityVectorExtensions.Angle(vector.ProjectOntoPlane(Vector3.up), Vector3.forward) > num)
					{
						return true;
					}
				}
			}
			return false;
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("")]
	[SaveDuringPlay]
	[ExecuteAlways]
	[DisallowMultipleComponent]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineConfiner.html")]
	public class CinemachineConfiner : CinemachineExtension
	{
		public enum Mode
		{
			Confine2D,
			Confine3D
		}

		private class VcamExtraState
		{
			public Vector3 m_previousDisplacement;

			public float confinerDisplacement;
		}

		[Tooltip("The confiner can operate using a 2D bounding shape or a 3D bounding volume")]
		public Mode m_ConfineMode;

		[Tooltip("The volume within which the camera is to be contained")]
		public Collider m_BoundingVolume;

		[Tooltip("The 2D shape within which the camera is to be contained")]
		public Collider2D m_BoundingShape2D;

		private Collider2D m_BoundingShape2DCache;

		[Tooltip("If camera is orthographic, screen edges will be confined to the volume.  If not checked, then only the camera center will be confined")]
		public bool m_ConfineScreenEdges = true;

		[Tooltip("How gradually to return the camera to the bounding volume if it goes beyond the borders.  Higher numbers are more gradual.")]
		[Range(0f, 10f)]
		public float m_Damping;

		private List<List<Vector2>> m_pathCache;

		private int m_pathTotalPointCount;

		public bool IsValid
		{
			get
			{
				if (m_ConfineMode != Mode.Confine3D || !(m_BoundingVolume != null) || !m_BoundingVolume.enabled || !m_BoundingVolume.gameObject.activeInHierarchy)
				{
					if (m_ConfineMode == Mode.Confine2D && m_BoundingShape2D != null && m_BoundingShape2D.enabled)
					{
						return m_BoundingShape2D.gameObject.activeInHierarchy;
					}
					return false;
				}
				return true;
			}
		}

		public bool CameraWasDisplaced(CinemachineVirtualCameraBase vcam)
		{
			return GetCameraDisplacementDistance(vcam) > 0f;
		}

		public float GetCameraDisplacementDistance(CinemachineVirtualCameraBase vcam)
		{
			return GetExtraState<VcamExtraState>(vcam).confinerDisplacement;
		}

		private void OnValidate()
		{
			m_Damping = Mathf.Max(0f, m_Damping);
		}

		protected override void ConnectToVcam(bool connect)
		{
			base.ConnectToVcam(connect);
		}

		public override float GetMaxDampTime()
		{
			return m_Damping;
		}

		protected override void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, CinemachineCore.Stage stage, ref CameraState state, float deltaTime)
		{
			if (IsValid && stage == CinemachineCore.Stage.Body)
			{
				VcamExtraState extraState = GetExtraState<VcamExtraState>(vcam);
				Vector3 vector = ((!m_ConfineScreenEdges || !state.Lens.Orthographic) ? ConfinePoint(state.CorrectedPosition) : ConfineScreenEdges(ref state));
				if (m_Damping > 0f && deltaTime >= 0f && base.VirtualCamera.PreviousStateIsValid)
				{
					Vector3 initial = vector - extraState.m_previousDisplacement;
					initial = Damper.Damp(initial, m_Damping, deltaTime);
					vector = extraState.m_previousDisplacement + initial;
				}
				extraState.m_previousDisplacement = vector;
				state.PositionCorrection += vector;
				extraState.confinerDisplacement = vector.magnitude;
			}
		}

		public void InvalidatePathCache()
		{
			m_pathCache = null;
			m_BoundingShape2DCache = null;
		}

		private bool ValidatePathCache()
		{
			if (m_BoundingShape2DCache != m_BoundingShape2D)
			{
				InvalidatePathCache();
				m_BoundingShape2DCache = m_BoundingShape2D;
			}
			Type type = ((m_BoundingShape2D == null) ? null : m_BoundingShape2D.GetType());
			if (type == typeof(PolygonCollider2D))
			{
				PolygonCollider2D polygonCollider2D = m_BoundingShape2D as PolygonCollider2D;
				if (m_pathCache == null || m_pathCache.Count != polygonCollider2D.pathCount || m_pathTotalPointCount != polygonCollider2D.GetTotalPointCount())
				{
					m_pathCache = new List<List<Vector2>>();
					for (int i = 0; i < polygonCollider2D.pathCount; i++)
					{
						Vector2[] path = polygonCollider2D.GetPath(i);
						List<Vector2> list = new List<Vector2>();
						for (int j = 0; j < path.Length; j++)
						{
							list.Add(path[j]);
						}
						m_pathCache.Add(list);
					}
					m_pathTotalPointCount = polygonCollider2D.GetTotalPointCount();
				}
				return true;
			}
			if (type == typeof(CompositeCollider2D))
			{
				CompositeCollider2D compositeCollider2D = m_BoundingShape2D as CompositeCollider2D;
				if (m_pathCache == null || m_pathCache.Count != compositeCollider2D.pathCount || m_pathTotalPointCount != compositeCollider2D.pointCount)
				{
					m_pathCache = new List<List<Vector2>>();
					Vector2[] array = new Vector2[compositeCollider2D.pointCount];
					Vector3 lossyScale = m_BoundingShape2D.transform.lossyScale;
					Vector2 vector = new Vector2(1f / lossyScale.x, 1f / lossyScale.y);
					for (int k = 0; k < compositeCollider2D.pathCount; k++)
					{
						int path2 = compositeCollider2D.GetPath(k, array);
						List<Vector2> list2 = new List<Vector2>();
						for (int l = 0; l < path2; l++)
						{
							list2.Add(array[l] * vector);
						}
						m_pathCache.Add(list2);
					}
					m_pathTotalPointCount = compositeCollider2D.pointCount;
				}
				return true;
			}
			InvalidatePathCache();
			return false;
		}

		private Vector3 ConfinePoint(Vector3 camPos)
		{
			if (m_ConfineMode == Mode.Confine3D)
			{
				return m_BoundingVolume.ClosestPoint(camPos) - camPos;
			}
			Vector2 vector = camPos;
			Vector2 vector2 = vector;
			if (m_BoundingShape2D.OverlapPoint(camPos))
			{
				return Vector3.zero;
			}
			if (!ValidatePathCache())
			{
				return Vector3.zero;
			}
			float num = float.MaxValue;
			for (int i = 0; i < m_pathCache.Count; i++)
			{
				int count = m_pathCache[i].Count;
				if (count <= 0)
				{
					continue;
				}
				Vector2 vector3 = m_BoundingShape2D.transform.TransformPoint(m_pathCache[i][count - 1] + m_BoundingShape2D.offset);
				for (int j = 0; j < count; j++)
				{
					Vector2 vector4 = m_BoundingShape2D.transform.TransformPoint(m_pathCache[i][j] + m_BoundingShape2D.offset);
					Vector2 vector5 = Vector2.Lerp(vector3, vector4, vector.ClosestPointOnSegment(vector3, vector4));
					float num2 = Vector2.SqrMagnitude(vector - vector5);
					if (num2 < num)
					{
						num = num2;
						vector2 = vector5;
					}
					vector3 = vector4;
				}
			}
			return vector2 - vector;
		}

		private Vector3 ConfineScreenEdges(ref CameraState state)
		{
			Quaternion correctedOrientation = state.CorrectedOrientation;
			float orthographicSize = state.Lens.OrthographicSize;
			float num = orthographicSize * state.Lens.Aspect;
			Vector3 vector = correctedOrientation * Vector3.right * num;
			Vector3 vector2 = correctedOrientation * Vector3.up * orthographicSize;
			Vector3 zero = Vector3.zero;
			Vector3 correctedPosition = state.CorrectedPosition;
			Vector3 vector3 = Vector3.zero;
			for (int i = 0; i < 12; i++)
			{
				Vector3 vector4 = ConfinePoint(correctedPosition - vector2 - vector);
				if (vector4.AlmostZero())
				{
					vector4 = ConfinePoint(correctedPosition + vector2 + vector);
				}
				if (vector4.AlmostZero())
				{
					vector4 = ConfinePoint(correctedPosition - vector2 + vector);
				}
				if (vector4.AlmostZero())
				{
					vector4 = ConfinePoint(correctedPosition + vector2 - vector);
				}
				if (vector4.AlmostZero())
				{
					break;
				}
				if ((vector4 + vector3).AlmostZero())
				{
					zero += vector4 * 0.5f;
					break;
				}
				zero += vector4;
				correctedPosition += vector4;
				vector3 = vector4;
			}
			return zero;
		}
	}
	[AddComponentMenu("")]
	[SaveDuringPlay]
	[ExecuteAlways]
	[DisallowMultipleComponent]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineConfiner2D.html")]
	public class CinemachineConfiner2D : CinemachineExtension
	{
		private class VcamExtraState
		{
			public Vector3 m_PreviousDisplacement;

			public Vector3 m_DampedDisplacement;

			public ConfinerOven.BakedSolution m_BakedSolution;

			public CinemachineVirtualCameraBase m_vcam;
		}

		private struct ShapeCache
		{
			public ConfinerOven m_confinerOven;

			public List<List<Vector2>> m_OriginalPath;

			public Matrix4x4 m_DeltaWorldToBaked;

			public Matrix4x4 m_DeltaBakedToWorld;

			private float m_aspectRatio;

			private float m_maxWindowSize;

			private float m_skeletonPadding;

			internal float m_maxComputationTimePerFrameInSeconds;

			private Matrix4x4 m_bakedToWorld;

			private Collider2D m_boundingShape2D;

			public void Invalidate()
			{
				m_aspectRatio = 0f;
				m_maxWindowSize = -1f;
				m_DeltaBakedToWorld = (m_DeltaWorldToBaked = Matrix4x4.identity);
				m_boundingShape2D = null;
				m_OriginalPath = null;
				m_confinerOven = null;
			}

			public bool ValidateCache(Collider2D boundingShape2D, float maxWindowSize, float aspectRatio, float skeletonPadding, out bool confinerStateChanged)
			{
				confinerStateChanged = false;
				if (IsValid(in boundingShape2D, in aspectRatio, in maxWindowSize, in skeletonPadding))
				{
					if (m_confinerOven.State == ConfinerOven.BakingState.BAKING)
					{
						m_confinerOven.BakeConfiner(m_maxComputationTimePerFrameInSeconds);
						confinerStateChanged = m_confinerOven.State != ConfinerOven.BakingState.BAKING;
					}
					CalculateDeltaTransformationMatrix();
					if (((Vector2)m_DeltaWorldToBaked.lossyScale).IsUniform())
					{
						return true;
					}
				}
				Invalidate();
				confinerStateChanged = true;
				Type type = ((boundingShape2D == null) ? null : boundingShape2D.GetType());
				if (type == typeof(PolygonCollider2D))
				{
					PolygonCollider2D polygonCollider2D = boundingShape2D as PolygonCollider2D;
					m_OriginalPath = new List<List<Vector2>>();
					m_bakedToWorld = boundingShape2D.transform.localToWorldMatrix;
					for (int i = 0; i < polygonCollider2D.pathCount; i++)
					{
						Vector2[] path = polygonCollider2D.GetPath(i);
						List<Vector2> list = new List<Vector2>();
						for (int j = 0; j < path.Length; j++)
						{
							list.Add(m_bakedToWorld.MultiplyPoint3x4(path[j]));
						}
						m_OriginalPath.Add(list);
					}
				}
				else
				{
					if (!(type == typeof(CompositeCollider2D)))
					{
						return false;
					}
					CompositeCollider2D compositeCollider2D = boundingShape2D as CompositeCollider2D;
					m_OriginalPath = new List<List<Vector2>>();
					m_bakedToWorld = boundingShape2D.transform.localToWorldMatrix;
					Vector2[] array = new Vector2[compositeCollider2D.pointCount];
					for (int k = 0; k < compositeCollider2D.pathCount; k++)
					{
						int path2 = compositeCollider2D.GetPath(k, array);
						List<Vector2> list2 = new List<Vector2>();
						for (int l = 0; l < path2; l++)
						{
							list2.Add(m_bakedToWorld.MultiplyPoint3x4(array[l]));
						}
						m_OriginalPath.Add(list2);
					}
				}
				m_confinerOven = new ConfinerOven(in m_OriginalPath, in aspectRatio, maxWindowSize, skeletonPadding);
				m_aspectRatio = aspectRatio;
				m_boundingShape2D = boundingShape2D;
				m_maxWindowSize = maxWindowSize;
				m_skeletonPadding = skeletonPadding;
				CalculateDeltaTransformationMatrix();
				return true;
			}

			private bool IsValid(in Collider2D boundingShape2D, in float aspectRatio, in float maxOrthoSize, in float padding)
			{
				if (boundingShape2D != null && m_boundingShape2D != null && m_boundingShape2D == boundingShape2D && m_OriginalPath != null && m_confinerOven != null && Mathf.Abs(m_aspectRatio - aspectRatio) < 0.0001f && Mathf.Abs(m_maxWindowSize - maxOrthoSize) < 0.0001f)
				{
					return Mathf.Abs(m_skeletonPadding - padding) < 0.0001f;
				}
				return false;
			}

			private void CalculateDeltaTransformationMatrix()
			{
				Matrix4x4 matrix4x = Matrix4x4.Translate(-m_boundingShape2D.offset) * m_boundingShape2D.transform.worldToLocalMatrix;
				m_DeltaWorldToBaked = m_bakedToWorld * matrix4x;
				m_DeltaBakedToWorld = m_DeltaWorldToBaked.inverse;
			}
		}

		[Tooltip("The 2D shape within which the camera is to be contained.  Can be a 2D polygon or 2D composite collider.")]
		public Collider2D m_BoundingShape2D;

		[Tooltip("Damping applied around corners to avoid jumps.  Higher numbers are more gradual.")]
		[Range(0f, 5f)]
		public float m_Damping;

		[Tooltip("To optimize computation and memory costs, set this to the largest view size that the camera is expected to have.  The confiner will not compute a polygon cache for frustum sizes larger than this.  This refers to the size in world units of the frustum at the confiner plane (for orthographic cameras, this is just the orthographic size).  If set to 0, then this parameter is ignored and a polygon cache will be calculated for all potential window sizes.")]
		public float m_MaxWindowSize;

		[Tooltip("For large window sizes, the confiner will potentially generate polygons with zero area.  The padding may be used to add a small amount of area to these polygons, to prevent them from being a series of disconnected dots.")]
		[Range(0f, 100f)]
		public float m_Padding;

		private float m_MaxComputationTimePerFrameInSeconds = 1f / 120f;

		private const float k_cornerAngleTreshold = 10f;

		private ShapeCache m_shapeCache;

		public void InvalidateCache()
		{
			m_shapeCache.Invalidate();
		}

		public bool ValidateCache(float cameraAspectRatio)
		{
			bool confinerStateChanged;
			return m_shapeCache.ValidateCache(m_BoundingShape2D, m_MaxWindowSize, cameraAspectRatio, m_Padding, out confinerStateChanged);
		}

		protected override void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, CinemachineCore.Stage stage, ref CameraState state, float deltaTime)
		{
			if (stage != CinemachineCore.Stage.Body)
			{
				return;
			}
			float aspect = state.Lens.Aspect;
			if (!m_shapeCache.ValidateCache(m_BoundingShape2D, m_MaxWindowSize, aspect, m_Padding, out var confinerStateChanged))
			{
				return;
			}
			Vector3 correctedPosition = state.CorrectedPosition;
			Vector3 vector = m_shapeCache.m_DeltaWorldToBaked.MultiplyPoint3x4(correctedPosition);
			float frustumHeight = CalculateHalfFrustumHeight(in state, in vector.z) * m_shapeCache.m_DeltaWorldToBaked.lossyScale.x;
			VcamExtraState extraState = GetExtraState<VcamExtraState>(vcam);
			extraState.m_vcam = vcam;
			if (confinerStateChanged || extraState.m_BakedSolution == null || !extraState.m_BakedSolution.IsValid())
			{
				extraState.m_BakedSolution = m_shapeCache.m_confinerOven.GetBakedSolution(frustumHeight);
			}
			vector = extraState.m_BakedSolution.ConfinePoint((Vector2)vector);
			Vector3 vector2 = m_shapeCache.m_DeltaBakedToWorld.MultiplyPoint3x4(vector);
			Vector3 vector3 = state.CorrectedOrientation * Vector3.forward;
			vector2 -= vector3 * Vector3.Dot(vector3, vector2 - correctedPosition);
			Vector3 previousDisplacement = extraState.m_PreviousDisplacement;
			Vector3 vector4 = (extraState.m_PreviousDisplacement = vector2 - correctedPosition);
			if (!base.VirtualCamera.PreviousStateIsValid || deltaTime < 0f || m_Damping <= 0f)
			{
				extraState.m_DampedDisplacement = Vector3.zero;
			}
			else
			{
				if (previousDisplacement.sqrMagnitude > 0.01f && Vector2.Angle(previousDisplacement, vector4) > 10f)
				{
					extraState.m_DampedDisplacement += vector4 - previousDisplacement;
				}
				extraState.m_DampedDisplacement -= Damper.Damp(extraState.m_DampedDisplacement, m_Damping, deltaTime);
				vector4 -= extraState.m_DampedDisplacement;
			}
			state.PositionCorrection += vector4;
		}

		private float CalculateHalfFrustumHeight(in CameraState state, in float cameraPosLocalZ)
		{
			float f = ((!state.Lens.Orthographic) ? (cameraPosLocalZ * Mathf.Tan(state.Lens.FieldOfView * 0.5f * (MathF.PI / 180f))) : state.Lens.OrthographicSize);
			return Mathf.Abs(f);
		}

		private void OnValidate()
		{
			m_Damping = Mathf.Max(0f, m_Damping);
			m_shapeCache.m_maxComputationTimePerFrameInSeconds = m_MaxComputationTimePerFrameInSeconds;
		}

		private void Reset()
		{
			m_Damping = 0.5f;
			m_MaxWindowSize = -1f;
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[ExecuteAlways]
	[DisallowMultipleComponent]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineDollyCart.html")]
	public class CinemachineDollyCart : MonoBehaviour
	{
		public enum UpdateMethod
		{
			Update,
			FixedUpdate,
			LateUpdate
		}

		[Tooltip("The path to follow")]
		public CinemachinePathBase m_Path;

		[Tooltip("When to move the cart, if Velocity is non-zero")]
		public UpdateMethod m_UpdateMethod;

		[Tooltip("How to interpret the Path Position.  If set to Path Units, values are as follows: 0 represents the first waypoint on the path, 1 is the second, and so on.  Values in-between are points on the path in between the waypoints.  If set to Distance, then Path Position represents distance along the path.")]
		public CinemachinePathBase.PositionUnits m_PositionUnits = CinemachinePathBase.PositionUnits.Distance;

		[Tooltip("Move the cart with this speed along the path.  The value is interpreted according to the Position Units setting.")]
		[FormerlySerializedAs("m_Velocity")]
		public float m_Speed;

		[Tooltip("The position along the path at which the cart will be placed.  This can be animated directly or, if the velocity is non-zero, will be updated automatically.  The value is interpreted according to the Position Units setting.")]
		[FormerlySerializedAs("m_CurrentDistance")]
		public float m_Position;

		private void FixedUpdate()
		{
			if (m_UpdateMethod == UpdateMethod.FixedUpdate)
			{
				SetCartPosition(m_Position + m_Speed * Time.deltaTime);
			}
		}

		private void Update()
		{
			float num = (Application.isPlaying ? m_Speed : 0f);
			if (m_UpdateMethod == UpdateMethod.Update)
			{
				SetCartPosition(m_Position + num * Time.deltaTime);
			}
		}

		private void LateUpdate()
		{
			if (!Application.isPlaying)
			{
				SetCartPosition(m_Position);
			}
			else if (m_UpdateMethod == UpdateMethod.LateUpdate)
			{
				SetCartPosition(m_Position + m_Speed * Time.deltaTime);
			}
		}

		private void SetCartPosition(float distanceAlongPath)
		{
			if (m_Path != null)
			{
				m_Position = m_Path.StandardizeUnit(distanceAlongPath, m_PositionUnits);
				Vector3 pos = m_Path.EvaluatePositionAtUnit(m_Position, m_PositionUnits);
				Quaternion rot = m_Path.EvaluateOrientationAtUnit(m_Position, m_PositionUnits);
				base.transform.ConservativeSetPositionAndRotation(pos, rot);
			}
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[RequireComponent(typeof(Camera))]
	[DisallowMultipleComponent]
	[AddComponentMenu("Cinemachine/CinemachineExternalCamera")]
	[ExecuteAlways]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineExternalCamera.html")]
	public class CinemachineExternalCamera : CinemachineVirtualCameraBase
	{
		[Tooltip("The object that the camera is looking at.  Setting this will improve the quality of the blends to and from this camera")]
		[NoSaveDuringPlay]
		[VcamTargetProperty]
		public Transform m_LookAt;

		private Camera m_Camera;

		private CameraState m_State = CameraState.Default;

		[Tooltip("Hint for blending positions to and from this virtual camera")]
		[FormerlySerializedAs("m_PositionBlending")]
		public BlendHint m_BlendHint;

		public override CameraState State => m_State;

		public override Transform LookAt
		{
			get
			{
				return m_LookAt;
			}
			set
			{
				m_LookAt = value;
			}
		}

		public override Transform Follow { get; set; }

		public override void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
		{
			if (m_Camera == null)
			{
				TryGetComponent<Camera>(out m_Camera);
			}
			m_State = CameraState.Default;
			m_State.RawPosition = base.transform.position;
			m_State.RawOrientation = base.transform.rotation;
			m_State.ReferenceUp = m_State.RawOrientation * Vector3.up;
			if (m_Camera != null)
			{
				m_State.Lens = LensSettings.FromCamera(m_Camera);
			}
			if (m_LookAt != null)
			{
				m_State.ReferenceLookAt = m_LookAt.transform.position;
				Vector3 vector = m_State.ReferenceLookAt - State.RawPosition;
				if (!vector.AlmostZero())
				{
					m_State.ReferenceLookAt = m_State.RawPosition + Vector3.Project(vector, State.RawOrientation * Vector3.forward);
				}
			}
			ApplyPositionBlendMethod(ref m_State, m_BlendHint);
			InvokePostPipelineStageCallback(this, CinemachineCore.Stage.Finalize, ref m_State, deltaTime);
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("")]
	[SaveDuringPlay]
	[ExecuteAlways]
	[DisallowMultipleComponent]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineFollowZoom.html")]
	public class CinemachineFollowZoom : CinemachineExtension
	{
		private class VcamExtraState
		{
			public float m_previousFrameZoom;
		}

		[Tooltip("The shot width to maintain, in world units, at target distance.")]
		public float m_Width = 2f;

		[Range(0f, 20f)]
		[Tooltip("Increase this value to soften the aggressiveness of the follow-zoom.  Small numbers are more responsive, larger numbers give a more heavy slowly responding camera.")]
		public float m_Damping = 1f;

		[Range(1f, 179f)]
		[Tooltip("Lower limit for the FOV that this behaviour will generate.")]
		public float m_MinFOV = 3f;

		[Range(1f, 179f)]
		[Tooltip("Upper limit for the FOV that this behaviour will generate.")]
		public float m_MaxFOV = 60f;

		private void OnValidate()
		{
			m_Width = Mathf.Max(0f, m_Width);
			m_MaxFOV = Mathf.Clamp(m_MaxFOV, 1f, 179f);
			m_MinFOV = Mathf.Clamp(m_MinFOV, 1f, m_MaxFOV);
		}

		public override float GetMaxDampTime()
		{
			return m_Damping;
		}

		protected override void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, CinemachineCore.Stage stage, ref CameraState state, float deltaTime)
		{
			VcamExtraState extraState = GetExtraState<VcamExtraState>(vcam);
			if (deltaTime < 0f || !base.VirtualCamera.PreviousStateIsValid)
			{
				extraState.m_previousFrameZoom = state.Lens.FieldOfView;
			}
			if (stage != CinemachineCore.Stage.Body)
			{
				return;
			}
			float value = Mathf.Max(m_Width, 0f);
			float value2 = 179f;
			float num = Vector3.Distance(state.CorrectedPosition, state.ReferenceLookAt);
			if (num > 0.0001f)
			{
				float min = num * 2f * Mathf.Tan(m_MinFOV * (MathF.PI / 180f) / 2f);
				float max = num * 2f * Mathf.Tan(m_MaxFOV * (MathF.PI / 180f) / 2f);
				value = Mathf.Clamp(value, min, max);
				if (deltaTime >= 0f && m_Damping > 0f && base.VirtualCamera.PreviousStateIsValid)
				{
					float num2 = num * 2f * Mathf.Tan(extraState.m_previousFrameZoom * (MathF.PI / 180f) / 2f);
					float initial = value - num2;
					initial = base.VirtualCamera.DetachedLookAtTargetDamp(initial, m_Damping, deltaTime);
					value = num2 + initial;
				}
				value2 = 2f * Mathf.Atan(value / (2f * num)) * 57.29578f;
			}
			LensSettings lens = state.Lens;
			lens.FieldOfView = (extraState.m_previousFrameZoom = Mathf.Clamp(value2, m_MinFOV, m_MaxFOV));
			state.Lens = lens;
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[DisallowMultipleComponent]
	[ExecuteAlways]
	[ExcludeFromPreset]
	[AddComponentMenu("Cinemachine/CinemachineFreeLook")]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineFreeLook.html")]
	public class CinemachineFreeLook : CinemachineVirtualCameraBase
	{
		[Serializable]
		public struct Orbit
		{
			public float m_Height;

			public float m_Radius;

			public Orbit(float h, float r)
			{
				m_Height = h;
				m_Radius = r;
			}
		}

		public delegate CinemachineVirtualCamera CreateRigDelegate(CinemachineFreeLook vcam, string name, CinemachineVirtualCamera copyFrom);

		public delegate void DestroyRigDelegate(GameObject rig);

		[Tooltip("Object for the camera children to look at (the aim target).")]
		[NoSaveDuringPlay]
		[VcamTargetProperty]
		public Transform m_LookAt;

		[Tooltip("Object for the camera children wants to move with (the body target).")]
		[NoSaveDuringPlay]
		[VcamTargetProperty]
		public Transform m_Follow;

		[Tooltip("If enabled, this lens setting will apply to all three child rigs, otherwise the child rig lens settings will be used")]
		[FormerlySerializedAs("m_UseCommonLensSetting")]
		public bool m_CommonLens = true;

		[FormerlySerializedAs("m_LensAttributes")]
		[Tooltip("Specifies the lens properties of this Virtual Camera.  This generally mirrors the Unity Camera's lens settings, and will be used to drive the Unity camera when the vcam is active")]
		public LensSettings m_Lens = LensSettings.Default;

		public TransitionParams m_Transitions;

		[SerializeField]
		[HideInInspector]
		[FormerlySerializedAs("m_BlendHint")]
		[FormerlySerializedAs("m_PositionBlending")]
		private BlendHint m_LegacyBlendHint;

		[Header("Axis Control")]
		[Tooltip("The Vertical axis.  Value is 0..1.  Chooses how to blend the child rigs")]
		[AxisStateProperty]
		public AxisState m_YAxis = new AxisState(0f, 1f, wrap: false, rangeLocked: true, 2f, 0.2f, 0.1f, "Mouse Y", invert: false);

		[Tooltip("Controls how automatic recentering of the Y axis is accomplished")]
		public AxisState.Recentering m_YAxisRecentering = new AxisState.Recentering(enabled: false, 1f, 2f);

		[Tooltip("The Horizontal axis.  Value is -180...180.  This is passed on to the rigs' OrbitalTransposer component")]
		[AxisStateProperty]
		public AxisState m_XAxis = new AxisState(-180f, 180f, wrap: true, rangeLocked: false, 300f, 0.1f, 0.1f, "Mouse X", invert: true);

		[OrbitalTransposerHeadingProperty]
		[Tooltip("The definition of Forward.  Camera will follow behind.")]
		public CinemachineOrbitalTransposer.Heading m_Heading = new CinemachineOrbitalTransposer.Heading(CinemachineOrbitalTransposer.Heading.HeadingDefinition.TargetForward, 4, 0f);

		[Tooltip("Controls how automatic recentering of the X axis is accomplished")]
		public AxisState.Recentering m_RecenterToTargetHeading = new AxisState.Recentering(enabled: false, 1f, 2f);

		[Header("Orbits")]
		[Tooltip("The coordinate space to use when interpreting the offset from the target.  This is also used to set the camera's Up vector, which will be maintained when aiming the camera.")]
		public CinemachineTransposer.BindingMode m_BindingMode = CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp;

		[Tooltip("Controls how taut is the line that connects the rigs' orbits, which determines final placement on the Y axis")]
		[Range(0f, 1f)]
		[FormerlySerializedAs("m_SplineTension")]
		public float m_SplineCurvature = 0.2f;

		[Tooltip("The radius and height of the three orbiting rigs.")]
		public Orbit[] m_Orbits = new Orbit[3]
		{
			new Orbit(4.5f, 1.75f),
			new Orbit(2.5f, 3f),
			new Orbit(0.4f, 1.3f)
		};

		[SerializeField]
		[HideInInspector]
		[FormerlySerializedAs("m_HeadingBias")]
		private float m_LegacyHeadingBias = float.MaxValue;

		private bool mUseLegacyRigDefinitions;

		private bool mIsDestroyed;

		private CameraState m_State = CameraState.Default;

		[SerializeField]
		[HideInInspector]
		[NoSaveDuringPlay]
		private CinemachineVirtualCamera[] m_Rigs = new CinemachineVirtualCamera[3];

		private CinemachineOrbitalTransposer[] mOrbitals;

		private CinemachineBlend mBlendA;

		private CinemachineBlend mBlendB;

		public static CreateRigDelegate CreateRigOverride;

		public static DestroyRigDelegate DestroyRigOverride;

		private float m_CachedXAxisHeading;

		private float m_LastHeadingUpdateFrame;

		private Orbit[] m_CachedOrbits;

		private float m_CachedTension;

		private Vector4[] m_CachedKnots;

		private Vector4[] m_CachedCtrl1;

		private Vector4[] m_CachedCtrl2;

		internal bool RigsAreCreated
		{
			get
			{
				if (m_Rigs != null)
				{
					return m_Rigs.Length == 3;
				}
				return false;
			}
		}

		public static string[] RigNames => new string[3] { "TopRig", "MiddleRig", "BottomRig" };

		public override bool PreviousStateIsValid
		{
			get
			{
				return base.PreviousStateIsValid;
			}
			set
			{
				if (!value)
				{
					int num = 0;
					while (m_Rigs != null && num < m_Rigs.Length)
					{
						if (m_Rigs[num] != null)
						{
							m_Rigs[num].PreviousStateIsValid = value;
						}
						num++;
					}
				}
				base.PreviousStateIsValid = value;
			}
		}

		public override CameraState State => m_State;

		public override Transform LookAt
		{
			get
			{
				return ResolveLookAt(m_LookAt);
			}
			set
			{
				m_LookAt = value;
			}
		}

		public override Transform Follow
		{
			get
			{
				return ResolveFollow(m_Follow);
			}
			set
			{
				m_Follow = value;
			}
		}

		protected override void OnValidate()
		{
			base.OnValidate();
			if (m_LegacyHeadingBias != float.MaxValue)
			{
				m_Heading.m_Bias = m_LegacyHeadingBias;
				m_LegacyHeadingBias = float.MaxValue;
				int heading = (int)m_Heading.m_Definition;
				if (m_RecenterToTargetHeading.LegacyUpgrade(ref heading, ref m_Heading.m_VelocityFilterStrength))
				{
					m_Heading.m_Definition = (CinemachineOrbitalTransposer.Heading.HeadingDefinition)heading;
				}
				mUseLegacyRigDefinitions = true;
			}
			if (m_LegacyBlendHint != BlendHint.None)
			{
				m_Transitions.m_BlendHint = m_LegacyBlendHint;
				m_LegacyBlendHint = BlendHint.None;
			}
			m_YAxis.Validate();
			m_XAxis.Validate();
			m_RecenterToTargetHeading.Validate();
			m_YAxisRecentering.Validate();
			m_Lens.Validate();
			InvalidateRigCache();
		}

		public CinemachineVirtualCamera GetRig(int i)
		{
			if (!UpdateRigCache() || i < 0 || i >= 3)
			{
				return null;
			}
			return m_Rigs[i];
		}

		protected override void OnEnable()
		{
			mIsDestroyed = false;
			base.OnEnable();
			InvalidateRigCache();
			UpdateInputAxisProvider();
		}

		public void UpdateInputAxisProvider()
		{
			m_XAxis.SetInputAxisProvider(0, null);
			m_YAxis.SetInputAxisProvider(1, null);
			AxisState.IInputAxisProvider inputAxisProvider = GetInputAxisProvider();
			if (inputAxisProvider != null)
			{
				m_XAxis.SetInputAxisProvider(0, inputAxisProvider);
				m_YAxis.SetInputAxisProvider(1, inputAxisProvider);
			}
		}

		protected override void OnDestroy()
		{
			if (m_Rigs != null)
			{
				CinemachineVirtualCamera[] rigs = m_Rigs;
				foreach (CinemachineVirtualCamera cinemachineVirtualCamera in rigs)
				{
					if (cinemachineVirtualCamera != null && cinemachineVirtualCamera.gameObject != null)
					{
						cinemachineVirtualCamera.gameObject.hideFlags &= ~(HideFlags.HideInHierarchy | HideFlags.HideInInspector);
					}
				}
			}
			mIsDestroyed = true;
			base.OnDestroy();
		}

		private void OnTransformChildrenChanged()
		{
			InvalidateRigCache();
		}

		private void Reset()
		{
			DestroyRigs();
			UpdateRigCache();
		}

		public override bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly = false)
		{
			if (!RigsAreCreated)
			{
				return false;
			}
			float yAxisValue = GetYAxisValue();
			if (dominantChildOnly)
			{
				if (vcam == m_Rigs[0])
				{
					return yAxisValue > 0.666f;
				}
				if (vcam == m_Rigs[2])
				{
					return (double)yAxisValue < 0.333;
				}
				if (vcam == m_Rigs[1])
				{
					if (yAxisValue >= 0.333f)
					{
						return yAxisValue <= 0.666f;
					}
					return false;
				}
				return false;
			}
			if (vcam == m_Rigs[1])
			{
				return true;
			}
			if (yAxisValue < 0.5f)
			{
				return vcam == m_Rigs[2];
			}
			return vcam == m_Rigs[0];
		}

		public override void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
			UpdateRigCache();
			if (RigsAreCreated)
			{
				CinemachineVirtualCamera[] rigs = m_Rigs;
				for (int i = 0; i < rigs.Length; i++)
				{
					rigs[i].OnTargetObjectWarped(target, positionDelta);
				}
			}
			base.OnTargetObjectWarped(target, positionDelta);
		}

		public override void ForceCameraPosition(Vector3 pos, Quaternion rot)
		{
			Vector3 referenceUp = m_State.ReferenceUp;
			m_YAxis.Value = GetYAxisClosestValue(pos, referenceUp);
			PreviousStateIsValid = true;
			base.transform.ConservativeSetPositionAndRotation(pos, rot);
			m_State.RawPosition = pos;
			m_State.RawOrientation = rot;
			if (UpdateRigCache())
			{
				for (int i = 0; i < 3; i++)
				{
					m_Rigs[i].ForceCameraPosition(pos, rot);
				}
				if (m_BindingMode != CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp)
				{
					m_XAxis.Value = mOrbitals[1].m_XAxis.Value;
				}
				PushSettingsToRigs();
				InternalUpdateCameraState(referenceUp, -1f);
			}
			base.ForceCameraPosition(pos, rot);
		}

		public override void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
		{
			UpdateTargetCache();
			UpdateRigCache();
			if (RigsAreCreated)
			{
				m_State = CalculateNewState(worldUp, deltaTime);
				ApplyPositionBlendMethod(ref m_State, m_Transitions.m_BlendHint);
				if (Follow != null)
				{
					Vector3 vector = m_State.RawPosition - base.transform.position;
					base.transform.position = m_State.RawPosition;
					m_Rigs[0].transform.position -= vector;
					m_Rigs[1].transform.position -= vector;
					m_Rigs[2].transform.position -= vector;
				}
				InvokePostPipelineStageCallback(this, CinemachineCore.Stage.Finalize, ref m_State, deltaTime);
				if (PreviousStateIsValid && CinemachineCore.Instance.IsLive(this) && deltaTime >= 0f && m_YAxis.Update(deltaTime))
				{
					m_YAxisRecentering.CancelRecentering();
				}
				PushSettingsToRigs();
				if (m_BindingMode == CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp)
				{
					m_XAxis.Value = 0f;
				}
				PreviousStateIsValid = true;
			}
		}

		public override void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
		{
			base.OnTransitionFromCamera(fromCam, worldUp, deltaTime);
			if (!RigsAreCreated)
			{
				return;
			}
			InvokeOnTransitionInExtensions(fromCam, worldUp, deltaTime);
			if (fromCam != null && m_Transitions.m_InheritPosition && !CinemachineCore.Instance.IsLiveInBlend(this))
			{
				Vector3 pos = fromCam.State.RawPosition;
				if (fromCam is CinemachineFreeLook)
				{
					CinemachineFreeLook cinemachineFreeLook = fromCam as CinemachineFreeLook;
					CinemachineOrbitalTransposer cinemachineOrbitalTransposer = ((cinemachineFreeLook.mOrbitals != null) ? cinemachineFreeLook.mOrbitals[1] : null);
					if (cinemachineOrbitalTransposer != null)
					{
						pos = cinemachineOrbitalTransposer.GetTargetCameraPosition(worldUp);
					}
				}
				ForceCameraPosition(pos, fromCam.State.FinalOrientation);
			}
			UpdateCameraState(worldUp, deltaTime);
			if (m_Transitions.m_OnCameraLive != null)
			{
				m_Transitions.m_OnCameraLive.Invoke(this, fromCam);
			}
		}

		internal override bool RequiresUserInput()
		{
			return true;
		}

		private float GetYAxisClosestValue(Vector3 cameraPos, Vector3 up)
		{
			if (Follow != null)
			{
				Vector3 vector = Quaternion.FromToRotation(up, Vector3.up) * (cameraPos - Follow.position);
				Vector3 vector2 = vector;
				vector2.y = 0f;
				if (!vector2.AlmostZero())
				{
					vector = Quaternion.AngleAxis(UnityVectorExtensions.SignedAngle(vector2, Vector3.back, Vector3.up), Vector3.up) * vector;
				}
				vector.x = 0f;
				return SteepestDescent(vector.normalized * (cameraPos - Follow.position).magnitude);
			}
			return m_YAxis.Value;
		}

		private float SteepestDescent(Vector3 cameraOffset)
		{
			float num = InitialGuess();
			for (int i = 0; i < 10; i++)
			{
				float num2 = AngleFunction(num);
				float num3 = SlopeOfAngleFunction(num);
				if (Mathf.Abs(num3) < 0.005f || Mathf.Abs(num2) < 0.005f)
				{
					break;
				}
				num = Mathf.Clamp01(num - num2 / num3);
			}
			return num;
			float AngleFunction(float input)
			{
				Vector3 localPositionForCameraFromInput = GetLocalPositionForCameraFromInput(input);
				return Mathf.Abs(UnityVectorExtensions.SignedAngle(cameraOffset, localPositionForCameraFromInput, Vector3.right));
			}
			float InitialGuess()
			{
				UpdateCachedSpline();
				float best = 0.5f;
				float bestAngle = AngleFunction(best);
				for (int j = 0; j <= 5; j++)
				{
					float num4 = (float)j * 0.1f;
					ChooseBestAngle(0.5f + num4);
					ChooseBestAngle(0.5f - num4);
				}
				return best;
				void ChooseBestAngle(float referenceAngle)
				{
					float num5 = AngleFunction(referenceAngle);
					if (num5 < bestAngle)
					{
						bestAngle = num5;
						best = referenceAngle;
					}
				}
			}
			float SlopeOfAngleFunction(float input)
			{
				float num4 = AngleFunction(input - 0.005f);
				return (AngleFunction(input + 0.005f) - num4) / 0.01f;
			}
		}

		private void InvalidateRigCache()
		{
			mOrbitals = null;
		}

		private void DestroyRigs()
		{
			List<CinemachineVirtualCamera> list = new List<CinemachineVirtualCamera>(3);
			for (int i = 0; i < RigNames.Length; i++)
			{
				foreach (Transform item in base.transform)
				{
					if (item.gameObject.name == RigNames[i])
					{
						list.Add(item.GetComponent<CinemachineVirtualCamera>());
					}
				}
			}
			foreach (CinemachineVirtualCamera item2 in list)
			{
				if (!(item2 != null))
				{
					continue;
				}
				if (DestroyRigOverride != null)
				{
					DestroyRigOverride(item2.gameObject);
					continue;
				}
				item2.DestroyPipeline();
				UnityEngine.Object.Destroy(item2);
				if (!RuntimeUtility.IsPrefab(base.gameObject))
				{
					UnityEngine.Object.Destroy(item2.gameObject);
				}
			}
			mOrbitals = null;
			m_Rigs = null;
		}

		private CinemachineVirtualCamera[] CreateRigs(CinemachineVirtualCamera[] copyFrom)
		{
			float[] array = new float[3] { 0.5f, 0.55f, 0.6f };
			mOrbitals = null;
			m_Rigs = null;
			CinemachineVirtualCamera[] array2 = new CinemachineVirtualCamera[3];
			for (int i = 0; i < array2.Length; i++)
			{
				CinemachineVirtualCamera cinemachineVirtualCamera = ((copyFrom != null && copyFrom.Length > i) ? copyFrom[i] : null);
				if (CreateRigOverride != null)
				{
					array2[i] = CreateRigOverride(this, RigNames[i], cinemachineVirtualCamera);
				}
				else
				{
					GameObject gameObject = null;
					foreach (Transform item in base.transform)
					{
						if (item.gameObject.name == RigNames[i])
						{
							gameObject = item.gameObject;
							break;
						}
					}
					if (gameObject == null && !RuntimeUtility.IsPrefab(base.gameObject))
					{
						gameObject = new GameObject(RigNames[i]);
						gameObject.transform.parent = base.transform;
					}
					if (gameObject == null)
					{
						array2[i] = null;
					}
					else
					{
						array2[i] = gameObject.AddComponent<CinemachineVirtualCamera>();
						array2[i].AddCinemachineComponent<CinemachineOrbitalTransposer>();
						array2[i].AddCinemachineComponent<CinemachineComposer>();
					}
				}
				if (!(array2[i] != null))
				{
					continue;
				}
				array2[i].InvalidateComponentPipeline();
				CinemachineOrbitalTransposer cinemachineOrbitalTransposer = array2[i].GetCinemachineComponent<CinemachineOrbitalTransposer>();
				if (cinemachineOrbitalTransposer == null)
				{
					cinemachineOrbitalTransposer = array2[i].AddCinemachineComponent<CinemachineOrbitalTransposer>();
				}
				if (cinemachineVirtualCamera == null)
				{
					cinemachineOrbitalTransposer.m_YawDamping = 0f;
					CinemachineComposer cinemachineComponent = array2[i].GetCinemachineComponent<CinemachineComposer>();
					if (cinemachineComponent != null)
					{
						cinemachineComponent.m_HorizontalDamping = (cinemachineComponent.m_VerticalDamping = 0f);
						cinemachineComponent.m_ScreenX = 0.5f;
						cinemachineComponent.m_ScreenY = array[i];
						cinemachineComponent.m_DeadZoneWidth = (cinemachineComponent.m_DeadZoneHeight = 0f);
						cinemachineComponent.m_SoftZoneWidth = (cinemachineComponent.m_SoftZoneHeight = 0.8f);
						cinemachineComponent.m_BiasX = (cinemachineComponent.m_BiasY = 0f);
					}
				}
			}
			return array2;
		}

		private bool UpdateRigCache()
		{
			if (mIsDestroyed)
			{
				return false;
			}
			if (mOrbitals != null && mOrbitals.Length == 3)
			{
				return true;
			}
			m_CachedXAxisHeading = 0f;
			m_Rigs = null;
			mOrbitals = null;
			List<CinemachineVirtualCamera> list = LocateExistingRigs(forceOrbital: false);
			if (list == null || list.Count != 3)
			{
				DestroyRigs();
				CreateRigs(null);
				list = LocateExistingRigs(forceOrbital: true);
			}
			if (list != null && list.Count == 3)
			{
				m_Rigs = list.ToArray();
			}
			if (RigsAreCreated)
			{
				mOrbitals = new CinemachineOrbitalTransposer[m_Rigs.Length];
				for (int i = 0; i < m_Rigs.Length; i++)
				{
					mOrbitals[i] = m_Rigs[i].GetCinemachineComponent<CinemachineOrbitalTransposer>();
				}
				mBlendA = new CinemachineBlend(m_Rigs[1], m_Rigs[0], AnimationCurve.Linear(0f, 0f, 1f, 1f), 1f, 0f);
				mBlendB = new CinemachineBlend(m_Rigs[2], m_Rigs[1], AnimationCurve.Linear(0f, 0f, 1f, 1f), 1f, 0f);
				return true;
			}
			return false;
		}

		private List<CinemachineVirtualCamera> LocateExistingRigs(bool forceOrbital)
		{
			m_CachedXAxisHeading = m_XAxis.Value;
			m_LastHeadingUpdateFrame = -1f;
			List<CinemachineVirtualCamera> list = new List<CinemachineVirtualCamera>(3);
			foreach (Transform item in base.transform)
			{
				CinemachineVirtualCamera component = item.GetComponent<CinemachineVirtualCamera>();
				if (!(component != null))
				{
					continue;
				}
				GameObject gameObject = item.gameObject;
				for (int i = 0; i < RigNames.Length; i++)
				{
					if (!(gameObject.name != RigNames[i]))
					{
						CinemachineOrbitalTransposer cinemachineOrbitalTransposer = component.GetCinemachineComponent<CinemachineOrbitalTransposer>();
						if (cinemachineOrbitalTransposer == null && forceOrbital)
						{
							cinemachineOrbitalTransposer = component.AddCinemachineComponent<CinemachineOrbitalTransposer>();
						}
						if (cinemachineOrbitalTransposer != null)
						{
							cinemachineOrbitalTransposer.m_HeadingIsSlave = true;
							cinemachineOrbitalTransposer.HideOffsetInInspector = true;
							cinemachineOrbitalTransposer.m_XAxis.m_InputAxisName = string.Empty;
							cinemachineOrbitalTransposer.HeadingUpdater = UpdateXAxisHeading;
							cinemachineOrbitalTransposer.m_RecenterToTargetHeading.m_enabled = false;
							component.m_StandbyUpdate = m_StandbyUpdate;
							list.Add(component);
						}
					}
				}
			}
			return list;
		}

		private float UpdateXAxisHeading(CinemachineOrbitalTransposer orbital, float deltaTime, Vector3 up)
		{
			if (this == null)
			{
				return 0f;
			}
			if (!PreviousStateIsValid)
			{
				deltaTime = -1f;
			}
			if (m_LastHeadingUpdateFrame != (float)Time.frameCount || deltaTime < 0f)
			{
				m_LastHeadingUpdateFrame = Time.frameCount;
				float value = m_XAxis.Value;
				m_CachedXAxisHeading = orbital.UpdateHeading(deltaTime, up, ref m_XAxis, ref m_RecenterToTargetHeading, CinemachineCore.Instance.IsLive(this));
				if (m_BindingMode == CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp)
				{
					m_XAxis.Value = value;
				}
			}
			return m_CachedXAxisHeading;
		}

		private void PushSettingsToRigs()
		{
			for (int i = 0; i < m_Rigs.Length; i++)
			{
				if (m_CommonLens)
				{
					m_Rigs[i].m_Lens = m_Lens;
				}
				if (mUseLegacyRigDefinitions)
				{
					mUseLegacyRigDefinitions = false;
					m_Orbits[i].m_Height = mOrbitals[i].m_FollowOffset.y;
					m_Orbits[i].m_Radius = 0f - mOrbitals[i].m_FollowOffset.z;
					if (m_Rigs[i].Follow != null)
					{
						Follow = m_Rigs[i].Follow;
					}
				}
				m_Rigs[i].Follow = null;
				m_Rigs[i].m_StandbyUpdate = m_StandbyUpdate;
				m_Rigs[i].FollowTargetAttachment = FollowTargetAttachment;
				m_Rigs[i].LookAtTargetAttachment = LookAtTargetAttachment;
				if (!PreviousStateIsValid)
				{
					m_Rigs[i].PreviousStateIsValid = false;
					m_Rigs[i].transform.ConservativeSetPositionAndRotation(base.transform.position, base.transform.rotation);
				}
				mOrbitals[i].m_FollowOffset = GetLocalPositionForCameraFromInput(GetYAxisValue());
				mOrbitals[i].m_BindingMode = m_BindingMode;
				mOrbitals[i].m_Heading = m_Heading;
				mOrbitals[i].m_XAxis.Value = m_XAxis.Value;
				if (m_BindingMode == CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp)
				{
					m_Rigs[i].SetStateRawPosition(State.RawPosition);
				}
			}
		}

		private float GetYAxisValue()
		{
			float num = m_YAxis.m_MaxValue - m_YAxis.m_MinValue;
			if (!(num > 0.0001f))
			{
				return 0.5f;
			}
			return m_YAxis.Value / num;
		}

		private CameraState CalculateNewState(Vector3 worldUp, float deltaTime)
		{
			CameraState result = PullStateFromVirtualCamera(worldUp, ref m_Lens);
			m_YAxisRecentering.DoRecentering(ref m_YAxis, deltaTime, 0.5f);
			float yAxisValue = GetYAxisValue();
			if (yAxisValue > 0.5f)
			{
				if (mBlendA != null)
				{
					mBlendA.TimeInBlend = (yAxisValue - 0.5f) * 2f;
					mBlendA.UpdateCameraState(worldUp, deltaTime);
					result = mBlendA.State;
				}
			}
			else if (mBlendB != null)
			{
				mBlendB.TimeInBlend = yAxisValue * 2f;
				mBlendB.UpdateCameraState(worldUp, deltaTime);
				result = mBlendB.State;
			}
			return result;
		}

		public Vector3 GetLocalPositionForCameraFromInput(float t)
		{
			if (mOrbitals == null)
			{
				return Vector3.zero;
			}
			UpdateCachedSpline();
			int num = 1;
			if (t > 0.5f)
			{
				t -= 0.5f;
				num = 2;
			}
			return SplineHelpers.Bezier3(t * 2f, m_CachedKnots[num], m_CachedCtrl1[num], m_CachedCtrl2[num], m_CachedKnots[num + 1]);
		}

		private void UpdateCachedSpline()
		{
			bool flag = m_CachedOrbits != null && m_CachedOrbits.Length == 3 && m_CachedTension == m_SplineCurvature;
			for (int i = 0; i < 3 && flag; i++)
			{
				flag = m_CachedOrbits[i].m_Height == m_Orbits[i].m_Height && m_CachedOrbits[i].m_Radius == m_Orbits[i].m_Radius;
			}
			if (!flag)
			{
				float splineCurvature = m_SplineCurvature;
				m_CachedKnots = new Vector4[5];
				m_CachedCtrl1 = new Vector4[5];
				m_CachedCtrl2 = new Vector4[5];
				m_CachedKnots[1] = new Vector4(0f, m_Orbits[2].m_Height, 0f - m_Orbits[2].m_Radius, 0f);
				m_CachedKnots[2] = new Vector4(0f, m_Orbits[1].m_Height, 0f - m_Orbits[1].m_Radius, 0f);
				m_CachedKnots[3] = new Vector4(0f, m_Orbits[0].m_Height, 0f - m_Orbits[0].m_Radius, 0f);
				m_CachedKnots[0] = Vector4.Lerp(m_CachedKnots[1], Vector4.zero, splineCurvature);
				m_CachedKnots[4] = Vector4.Lerp(m_CachedKnots[3], Vector4.zero, splineCurvature);
				SplineHelpers.ComputeSmoothControlPoints(ref m_CachedKnots, ref m_CachedCtrl1, ref m_CachedCtrl2);
				m_CachedOrbits = new Orbit[3];
				for (int j = 0; j < 3; j++)
				{
					m_CachedOrbits[j] = m_Orbits[j];
				}
				m_CachedTension = m_SplineCurvature;
			}
		}

		internal override void OnBeforeSerialize()
		{
			if (!m_Lens.IsPhysicalCamera)
			{
				m_Lens.SensorSize = Vector2.one;
			}
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[DisallowMultipleComponent]
	[ExecuteAlways]
	[ExcludeFromPreset]
	[AddComponentMenu("Cinemachine/CinemachineMixingCamera")]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineMixingCamera.html")]
	public class CinemachineMixingCamera : CinemachineVirtualCameraBase
	{
		public const int MaxCameras = 8;

		[Tooltip("The weight of the first tracked camera")]
		public float m_Weight0 = 0.5f;

		[Tooltip("The weight of the second tracked camera")]
		public float m_Weight1 = 0.5f;

		[Tooltip("The weight of the third tracked camera")]
		public float m_Weight2 = 0.5f;

		[Tooltip("The weight of the fourth tracked camera")]
		public float m_Weight3 = 0.5f;

		[Tooltip("The weight of the fifth tracked camera")]
		public float m_Weight4 = 0.5f;

		[Tooltip("The weight of the sixth tracked camera")]
		public float m_Weight5 = 0.5f;

		[Tooltip("The weight of the seventh tracked camera")]
		public float m_Weight6 = 0.5f;

		[Tooltip("The weight of the eighth tracked camera")]
		public float m_Weight7 = 0.5f;

		private CameraState m_State = CameraState.Default;

		private CinemachineVirtualCameraBase[] m_ChildCameras;

		private Dictionary<CinemachineVirtualCameraBase, int> m_indexMap;

		private ICinemachineCamera LiveChild { get; set; }

		public override CameraState State => m_State;

		public override Transform LookAt { get; set; }

		public override Transform Follow { get; set; }

		public CinemachineVirtualCameraBase[] ChildCameras
		{
			get
			{
				ValidateListOfChildren();
				return m_ChildCameras;
			}
		}

		public float GetWeight(int index)
		{
			switch (index)
			{
			case 0:
				return m_Weight0;
			case 1:
				return m_Weight1;
			case 2:
				return m_Weight2;
			case 3:
				return m_Weight3;
			case 4:
				return m_Weight4;
			case 5:
				return m_Weight5;
			case 6:
				return m_Weight6;
			case 7:
				return m_Weight7;
			default:
				UnityEngine.Debug.LogError("CinemachineMixingCamera: Invalid index: " + index);
				return 0f;
			}
		}

		public void SetWeight(int index, float w)
		{
			switch (index)
			{
			case 0:
				m_Weight0 = w;
				break;
			case 1:
				m_Weight1 = w;
				break;
			case 2:
				m_Weight2 = w;
				break;
			case 3:
				m_Weight3 = w;
				break;
			case 4:
				m_Weight4 = w;
				break;
			case 5:
				m_Weight5 = w;
				break;
			case 6:
				m_Weight6 = w;
				break;
			case 7:
				m_Weight7 = w;
				break;
			default:
				UnityEngine.Debug.LogError("CinemachineMixingCamera: Invalid index: " + index);
				break;
			}
		}

		public float GetWeight(CinemachineVirtualCameraBase vcam)
		{
			ValidateListOfChildren();
			if (m_indexMap.TryGetValue(vcam, out var value))
			{
				return GetWeight(value);
			}
			UnityEngine.Debug.LogError("CinemachineMixingCamera: Invalid child: " + ((vcam != null) ? vcam.Name : "(null)"));
			return 0f;
		}

		public void SetWeight(CinemachineVirtualCameraBase vcam, float w)
		{
			ValidateListOfChildren();
			if (m_indexMap.TryGetValue(vcam, out var value))
			{
				SetWeight(value, w);
			}
			else
			{
				UnityEngine.Debug.LogError("CinemachineMixingCamera: Invalid child: " + ((vcam != null) ? vcam.Name : "(null)"));
			}
		}

		public override void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
			ValidateListOfChildren();
			CinemachineVirtualCameraBase[] childCameras = m_ChildCameras;
			for (int i = 0; i < childCameras.Length; i++)
			{
				childCameras[i].OnTargetObjectWarped(target, positionDelta);
			}
			base.OnTargetObjectWarped(target, positionDelta);
		}

		public override void ForceCameraPosition(Vector3 pos, Quaternion rot)
		{
			ValidateListOfChildren();
			CinemachineVirtualCameraBase[] childCameras = m_ChildCameras;
			for (int i = 0; i < childCameras.Length; i++)
			{
				childCameras[i].ForceCameraPosition(pos, rot);
			}
			base.ForceCameraPosition(pos, rot);
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			InvalidateListOfChildren();
		}

		public void OnTransformChildrenChanged()
		{
			InvalidateListOfChildren();
		}

		protected override void OnValidate()
		{
			base.OnValidate();
			for (int i = 0; i < 8; i++)
			{
				SetWeight(i, Mathf.Max(0f, GetWeight(i)));
			}
		}

		public override bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly = false)
		{
			CinemachineVirtualCameraBase[] childCameras = ChildCameras;
			for (int i = 0; i < 8 && i < childCameras.Length; i++)
			{
				if (childCameras[i] == vcam)
				{
					if (GetWeight(i) > 0.0001f)
					{
						return childCameras[i].isActiveAndEnabled;
					}
					return false;
				}
			}
			return false;
		}

		protected void InvalidateListOfChildren()
		{
			m_ChildCameras = null;
			m_indexMap = null;
			LiveChild = null;
		}

		protected void ValidateListOfChildren()
		{
			if (m_ChildCameras != null)
			{
				return;
			}
			m_indexMap = new Dictionary<CinemachineVirtualCameraBase, int>();
			List<CinemachineVirtualCameraBase> list = new List<CinemachineVirtualCameraBase>();
			CinemachineVirtualCameraBase[] componentsInChildren = GetComponentsInChildren<CinemachineVirtualCameraBase>(includeInactive: true);
			foreach (CinemachineVirtualCameraBase cinemachineVirtualCameraBase in componentsInChildren)
			{
				if (cinemachineVirtualCameraBase.transform.parent == base.transform)
				{
					int count = list.Count;
					list.Add(cinemachineVirtualCameraBase);
					if (count < 8)
					{
						m_indexMap.Add(cinemachineVirtualCameraBase, count);
					}
				}
			}
			m_ChildCameras = list.ToArray();
		}

		public override void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
		{
			base.OnTransitionFromCamera(fromCam, worldUp, deltaTime);
			InvokeOnTransitionInExtensions(fromCam, worldUp, deltaTime);
			CinemachineVirtualCameraBase[] childCameras = ChildCameras;
			for (int i = 0; i < 8 && i < childCameras.Length; i++)
			{
				childCameras[i].OnTransitionFromCamera(fromCam, worldUp, deltaTime);
			}
			InternalUpdateCameraState(worldUp, deltaTime);
		}

		public override void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
		{
			CinemachineVirtualCameraBase[] childCameras = ChildCameras;
			LiveChild = null;
			float num = 0f;
			float num2 = 0f;
			for (int i = 0; i < 8 && i < childCameras.Length; i++)
			{
				CinemachineVirtualCameraBase cinemachineVirtualCameraBase = childCameras[i];
				if (!cinemachineVirtualCameraBase.isActiveAndEnabled)
				{
					continue;
				}
				float num3 = Mathf.Max(0f, GetWeight(i));
				if (num3 > 0.0001f)
				{
					num2 += num3;
					if (num2 == num3)
					{
						m_State = cinemachineVirtualCameraBase.State;
					}
					else
					{
						m_State = CameraState.Lerp(m_State, cinemachineVirtualCameraBase.State, num3 / num2);
					}
					if (num3 > num)
					{
						num = num3;
						LiveChild = cinemachineVirtualCameraBase;
					}
				}
			}
			InvokePostPipelineStageCallback(this, CinemachineCore.Stage.Finalize, ref m_State, deltaTime);
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("Cinemachine/CinemachinePath")]
	[SaveDuringPlay]
	[DisallowMultipleComponent]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachinePath.html")]
	public class CinemachinePath : CinemachinePathBase
	{
		[Serializable]
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public struct Waypoint
		{
			[Tooltip("Position in path-local space")]
			public Vector3 position;

			[Tooltip("Offset from the position, which defines the tangent of the curve at the waypoint.  The length of the tangent encodes the strength of the bezier handle.  The same handle is used symmetrically on both sides of the waypoint, to ensure smoothness.")]
			public Vector3 tangent;

			[Tooltip("Defines the roll of the path at this waypoint.  The other orientation axes are inferred from the tangent and world up.")]
			public float roll;
		}

		[Tooltip("If checked, then the path ends are joined to form a continuous loop.")]
		public bool m_Looped;

		[Tooltip("The waypoints that define the path.  They will be interpolated using a bezier curve.")]
		public Waypoint[] m_Waypoints = Array.Empty<Waypoint>();

		public override float MinPos => 0f;

		public override float MaxPos
		{
			get
			{
				int num = m_Waypoints.Length - 1;
				if (num < 1)
				{
					return 0f;
				}
				return m_Looped ? (num + 1) : num;
			}
		}

		public override bool Looped => m_Looped;

		public override int DistanceCacheSampleStepsPerSegment => m_Resolution;

		private void Reset()
		{
			m_Looped = false;
			m_Waypoints = new Waypoint[2]
			{
				new Waypoint
				{
					position = new Vector3(0f, 0f, -5f),
					tangent = new Vector3(1f, 0f, 0f)
				},
				new Waypoint
				{
					position = new Vector3(0f, 0f, 5f),
					tangent = new Vector3(1f, 0f, 0f)
				}
			};
			m_Appearance = new Appearance();
			InvalidateDistanceCache();
		}

		private void OnValidate()
		{
			InvalidateDistanceCache();
		}

		private float GetBoundingIndices(float pos, out int indexA, out int indexB)
		{
			pos = StandardizePos(pos);
			int num = Mathf.RoundToInt(pos);
			if (Mathf.Abs(pos - (float)num) < 0.0001f)
			{
				indexA = (indexB = ((num != m_Waypoints.Length) ? num : 0));
			}
			else
			{
				indexA = Mathf.FloorToInt(pos);
				if (indexA >= m_Waypoints.Length)
				{
					pos -= MaxPos;
					indexA = 0;
				}
				indexB = Mathf.CeilToInt(pos);
				if (indexB >= m_Waypoints.Length)
				{
					indexB = 0;
				}
			}
			return pos;
		}

		public override Vector3 EvaluateLocalPosition(float pos)
		{
			Vector3 result = Vector3.zero;
			if (m_Waypoints.Length != 0)
			{
				pos = GetBoundingIndices(pos, out var indexA, out var indexB);
				if (indexA == indexB)
				{
					result = m_Waypoints[indexA].position;
				}
				else
				{
					Waypoint waypoint = m_Waypoints[indexA];
					Waypoint waypoint2 = m_Waypoints[indexB];
					result = SplineHelpers.Bezier3(pos - (float)indexA, m_Waypoints[indexA].position, waypoint.position + waypoint.tangent, waypoint2.position - waypoint2.tangent, waypoint2.position);
				}
			}
			return result;
		}

		public override Vector3 EvaluateLocalTangent(float pos)
		{
			Vector3 result = Vector3.forward;
			if (m_Waypoints.Length != 0)
			{
				pos = GetBoundingIndices(pos, out var indexA, out var indexB);
				if (indexA == indexB)
				{
					result = m_Waypoints[indexA].tangent;
				}
				else
				{
					Waypoint waypoint = m_Waypoints[indexA];
					Waypoint waypoint2 = m_Waypoints[indexB];
					result = SplineHelpers.BezierTangent3(pos - (float)indexA, m_Waypoints[indexA].position, waypoint.position + waypoint.tangent, waypoint2.position - waypoint2.tangent, waypoint2.position);
				}
			}
			return result;
		}

		public override Quaternion EvaluateLocalOrientation(float pos)
		{
			Quaternion result = Quaternion.identity;
			if (m_Waypoints.Length != 0)
			{
				pos = GetBoundingIndices(pos, out var indexA, out var indexB);
				Vector3 vector = EvaluateLocalTangent(pos);
				if (!vector.AlmostZero())
				{
					result = Quaternion.LookRotation(vector) * RollAroundForward(GetRoll(indexA, indexB, pos));
				}
			}
			return result;
		}

		internal float GetRoll(int indexA, int indexB, float standardizedPos)
		{
			if (indexA == indexB)
			{
				return m_Waypoints[indexA].roll;
			}
			float num = m_Waypoints[indexA].roll;
			float num2 = m_Waypoints[indexB].roll;
			if (indexB == 0)
			{
				num %= 360f;
				num2 %= 360f;
			}
			return Mathf.Lerp(num, num2, standardizedPos - (float)indexA);
		}

		private static Quaternion RollAroundForward(float angle)
		{
			float f = angle * 0.5f * (MathF.PI / 180f);
			return new Quaternion(0f, 0f, Mathf.Sin(f), Mathf.Cos(f));
		}
	}
	[AddComponentMenu("")]
	public sealed class CinemachinePipeline : MonoBehaviour
	{
	}
	[AddComponentMenu("")]
	[DisallowMultipleComponent]
	public class CinemachinePixelPerfect : MonoBehaviour
	{
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("Cinemachine/CinemachineSmoothPath")]
	[SaveDuringPlay]
	[DisallowMultipleComponent]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineSmoothPath.html")]
	public class CinemachineSmoothPath : CinemachinePathBase
	{
		[Serializable]
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public struct Waypoint
		{
			[Tooltip("Position in path-local space")]
			public Vector3 position;

			[Tooltip("Defines the roll of the path at this waypoint.  The other orientation axes are inferred from the tangent and world up.")]
			public float roll;

			internal Vector4 AsVector4 => new Vector4(position.x, position.y, position.z, roll);

			internal static Waypoint FromVector4(Vector4 v)
			{
				return new Waypoint
				{
					position = new Vector3(v[0], v[1], v[2]),
					roll = v[3]
				};
			}
		}

		[Tooltip("If checked, then the path ends are joined to form a continuous loop.")]
		public bool m_Looped;

		[Tooltip("The waypoints that define the path.  They will be interpolated using a bezier curve.")]
		public Waypoint[] m_Waypoints = Array.Empty<Waypoint>();

		internal Waypoint[] m_ControlPoints1;

		internal Waypoint[] m_ControlPoints2;

		private bool m_IsLoopedCache;

		public override float MinPos => 0f;

		public override float MaxPos
		{
			get
			{
				int num = m_Waypoints.Length - 1;
				if (num < 1)
				{
					return 0f;
				}
				return m_Looped ? (num + 1) : num;
			}
		}

		public override bool Looped => m_Looped;

		public override int DistanceCacheSampleStepsPerSegment => m_Resolution;

		private void OnValidate()
		{
			InvalidateDistanceCache();
		}

		private void Reset()
		{
			m_Looped = false;
			m_Waypoints = new Waypoint[2]
			{
				new Waypoint
				{
					position = new Vector3(0f, 0f, -5f)
				},
				new Waypoint
				{
					position = new Vector3(0f, 0f, 5f)
				}
			};
			m_Appearance = new Appearance();
			InvalidateDistanceCache();
		}

		public override void InvalidateDistanceCache()
		{
			base.InvalidateDistanceCache();
			m_ControlPoints1 = null;
			m_ControlPoints2 = null;
		}

		internal void UpdateControlPoints()
		{
			int num = ((m_Waypoints != null) ? m_Waypoints.Length : 0);
			if (num > 1 && (Looped != m_IsLoopedCache || m_ControlPoints1 == null || m_ControlPoints1.Length != num || m_ControlPoints2 == null || m_ControlPoints2.Length != num))
			{
				Vector4[] ctrl = new Vector4[num];
				Vector4[] ctrl2 = new Vector4[num];
				Vector4[] knot = new Vector4[num];
				for (int i = 0; i < num; i++)
				{
					knot[i] = m_Waypoints[i].AsVector4;
				}
				if (Looped)
				{
					SplineHelpers.ComputeSmoothControlPointsLooped(ref knot, ref ctrl, ref ctrl2);
				}
				else
				{
					SplineHelpers.ComputeSmoothControlPoints(ref knot, ref ctrl, ref ctrl2);
				}
				m_ControlPoints1 = new Waypoint[num];
				m_ControlPoints2 = new Waypoint[num];
				for (int j = 0; j < num; j++)
				{
					m_ControlPoints1[j] = Waypoint.FromVector4(ctrl[j]);
					m_ControlPoints2[j] = Waypoint.FromVector4(ctrl2[j]);
				}
				m_IsLoopedCache = Looped;
			}
		}

		private float GetBoundingIndices(float pos, out int indexA, out int indexB)
		{
			pos = StandardizePos(pos);
			int num = m_Waypoints.Length;
			if (num < 2)
			{
				indexA = (indexB = 0);
			}
			else
			{
				indexA = Mathf.FloorToInt(pos);
				if (indexA >= num)
				{
					pos -= MaxPos;
					indexA = 0;
				}
				indexB = indexA + 1;
				if (indexB == num)
				{
					if (Looped)
					{
						indexB = 0;
					}
					else
					{
						indexB--;
						indexA--;
					}
				}
			}
			return pos;
		}

		public override Vector3 EvaluateLocalPosition(float pos)
		{
			Vector3 result = Vector3.zero;
			if (m_Waypoints.Length != 0)
			{
				UpdateControlPoints();
				pos = GetBoundingIndices(pos, out var indexA, out var indexB);
				result = ((indexA != indexB) ? SplineHelpers.Bezier3(pos - (float)indexA, m_Waypoints[indexA].position, m_ControlPoints1[indexA].position, m_ControlPoints2[indexA].position, m_Waypoints[indexB].position) : m_Waypoints[indexA].position);
			}
			return result;
		}

		public override Vector3 EvaluateLocalTangent(float pos)
		{
			Vector3 result = Vector3.forward;
			if (m_Waypoints.Length > 1)
			{
				UpdateControlPoints();
				pos = GetBoundingIndices(pos, out var indexA, out var indexB);
				if (!Looped && indexA == m_Waypoints.Length - 1)
				{
					indexA--;
				}
				result = SplineHelpers.BezierTangent3(pos - (float)indexA, m_Waypoints[indexA].position, m_ControlPoints1[indexA].position, m_ControlPoints2[indexA].position, m_Waypoints[indexB].position);
			}
			return result;
		}

		public override Quaternion EvaluateLocalOrientation(float pos)
		{
			Quaternion result = Quaternion.identity;
			if (m_Waypoints.Length != 0)
			{
				pos = GetBoundingIndices(pos, out var indexA, out var indexB);
				float angle;
				if (indexA == indexB)
				{
					angle = m_Waypoints[indexA].roll;
				}
				else
				{
					UpdateControlPoints();
					angle = SplineHelpers.Bezier1(pos - (float)indexA, m_Waypoints[indexA].roll, m_ControlPoints1[indexA].roll, m_ControlPoints2[indexA].roll, m_Waypoints[indexB].roll);
				}
				Vector3 vector = EvaluateLocalTangent(pos);
				if (!vector.AlmostZero())
				{
					result = Quaternion.LookRotation(vector) * RollAroundForward(angle);
				}
			}
			return result;
		}

		private static Quaternion RollAroundForward(float angle)
		{
			float f = angle * 0.5f * (MathF.PI / 180f);
			return new Quaternion(0f, 0f, Mathf.Sin(f), Mathf.Cos(f));
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[DisallowMultipleComponent]
	[ExecuteAlways]
	[ExcludeFromPreset]
	[AddComponentMenu("Cinemachine/CinemachineStateDrivenCamera")]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineStateDrivenCamera.html")]
	public class CinemachineStateDrivenCamera : CinemachineVirtualCameraBase
	{
		[Serializable]
		public struct Instruction
		{
			[Tooltip("The full hash of the animation state")]
			public int m_FullHash;

			[Tooltip("The virtual camera to activate when the animation state becomes active")]
			public CinemachineVirtualCameraBase m_VirtualCamera;

			[Tooltip("How long to wait (in seconds) before activating the virtual camera. This filters out very short state durations")]
			public float m_ActivateAfter;

			[Tooltip("The minimum length of time (in seconds) to keep a virtual camera active")]
			public float m_MinDuration;
		}

		[Serializable]
		[DocumentationSorting(DocumentationSortingAttribute.Level.Undoc)]
		internal struct ParentHash
		{
			public int m_Hash;

			public int m_ParentHash;

			public ParentHash(int h, int p)
			{
				m_Hash = h;
				m_ParentHash = p;
			}
		}

		private struct HashPair
		{
			public int parentHash;

			public int hash;
		}

		[Tooltip("Default object for the camera children to look at (the aim target), if not specified in a child camera.  May be empty if all of the children define targets of their own.")]
		[NoSaveDuringPlay]
		[VcamTargetProperty]
		public Transform m_LookAt;

		[Tooltip("Default object for the camera children wants to move with (the body target), if not specified in a child camera.  May be empty if all of the children define targets of their own.")]
		[NoSaveDuringPlay]
		[VcamTargetProperty]
		public Transform m_Follow;

		[Space]
		[Tooltip("The state machine whose state changes will drive this camera's choice of active child")]
		[NoSaveDuringPlay]
		public Animator m_AnimatedTarget;

		[Tooltip("Which layer in the target state machine to observe")]
		[NoSaveDuringPlay]
		public int m_LayerIndex;

		[Tooltip("When enabled, the current child camera and blend will be indicated in the game window, for debugging")]
		public bool m_ShowDebugText;

		[SerializeField]
		[HideInInspector]
		[NoSaveDuringPlay]
		internal CinemachineVirtualCameraBase[] m_ChildCameras;

		[Tooltip("The set of instructions associating virtual cameras with states.  These instructions are used to choose the live child at any given moment")]
		public Instruction[] m_Instructions;

		[CinemachineBlendDefinitionProperty]
		[Tooltip("The blend which is used if you don't explicitly define a blend between two Virtual Camera children")]
		public CinemachineBlendDefinition m_DefaultBlend = new CinemachineBlendDefinition(CinemachineBlendDefinition.Style.EaseInOut, 0.5f);

		[Tooltip("This is the asset which contains custom settings for specific child blends")]
		public CinemachineBlenderSettings m_CustomBlends;

		[HideInInspector]
		[SerializeField]
		internal ParentHash[] m_ParentHash;

		private ICinemachineCamera m_TransitioningFrom;

		private CameraState m_State = CameraState.Default;

		private Dictionary<AnimationClip, List<HashPair>> mHashCache;

		private float mActivationTime;

		private Instruction mActiveInstruction;

		private float mPendingActivationTime;

		private Instruction mPendingInstruction;

		private CinemachineBlend mActiveBlend;

		private Dictionary<int, int> mInstructionDictionary;

		private Dictionary<int, int> mStateParentLookup;

		private List<AnimatorClipInfo> m_clipInfoList = new List<AnimatorClipInfo>();

		public override string Description
		{
			get
			{
				if (mActiveBlend != null)
				{
					return mActiveBlend.Description;
				}
				ICinemachineCamera liveChild = LiveChild;
				if (liveChild == null)
				{
					return "(none)";
				}
				StringBuilder stringBuilder = CinemachineDebug.SBFromPool();
				stringBuilder.Append("[");
				stringBuilder.Append(liveChild.Name);
				stringBuilder.Append("]");
				string result = stringBuilder.ToString();
				CinemachineDebug.ReturnToPool(stringBuilder);
				return result;
			}
		}

		public ICinemachineCamera LiveChild { get; set; }

		public override CameraState State => m_State;

		public override Transform LookAt
		{
			get
			{
				return ResolveLookAt(m_LookAt);
			}
			set
			{
				m_LookAt = value;
			}
		}

		public override Transform Follow
		{
			get
			{
				return ResolveFollow(m_Follow);
			}
			set
			{
				m_Follow = value;
			}
		}

		public CinemachineVirtualCameraBase[] ChildCameras
		{
			get
			{
				UpdateListOfChildren();
				return m_ChildCameras;
			}
		}

		public bool IsBlending => mActiveBlend != null;

		public CinemachineBlend ActiveBlend => mActiveBlend;

		public override bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly = false)
		{
			if (vcam != LiveChild)
			{
				if (mActiveBlend != null)
				{
					return mActiveBlend.Uses(vcam);
				}
				return false;
			}
			return true;
		}

		public override void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
			UpdateListOfChildren();
			CinemachineVirtualCameraBase[] childCameras = m_ChildCameras;
			for (int i = 0; i < childCameras.Length; i++)
			{
				childCameras[i].OnTargetObjectWarped(target, positionDelta);
			}
			base.OnTargetObjectWarped(target, positionDelta);
		}

		public override void ForceCameraPosition(Vector3 pos, Quaternion rot)
		{
			UpdateListOfChildren();
			CinemachineVirtualCameraBase[] childCameras = m_ChildCameras;
			for (int i = 0; i < childCameras.Length; i++)
			{
				childCameras[i].ForceCameraPosition(pos, rot);
			}
			base.ForceCameraPosition(pos, rot);
		}

		public override void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
		{
			base.OnTransitionFromCamera(fromCam, worldUp, deltaTime);
			InvokeOnTransitionInExtensions(fromCam, worldUp, deltaTime);
			m_TransitioningFrom = fromCam;
			InternalUpdateCameraState(worldUp, deltaTime);
		}

		public override void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
		{
			UpdateListOfChildren();
			CinemachineVirtualCameraBase cinemachineVirtualCameraBase = ChooseCurrentCamera();
			if (cinemachineVirtualCameraBase != null && !cinemachineVirtualCameraBase.gameObject.activeInHierarchy)
			{
				cinemachineVirtualCameraBase.gameObject.SetActive(value: true);
				cinemachineVirtualCameraBase.UpdateCameraState(worldUp, deltaTime);
			}
			ICinemachineCamera liveChild = LiveChild;
			LiveChild = cinemachineVirtualCameraBase;
			if (liveChild != LiveChild && LiveChild != null)
			{
				LiveChild.OnTransitionFromCamera(liveChild, worldUp, deltaTime);
				CinemachineCore.Instance.GenerateCameraActivationEvent(LiveChild, liveChild);
				if (liveChild != null)
				{
					mActiveBlend = CreateBlend(liveChild, LiveChild, LookupBlend(liveChild, LiveChild), mActiveBlend);
					if (mActiveBlend == null || !mActiveBlend.Uses(liveChild))
					{
						CinemachineCore.Instance.GenerateCameraCutEvent(LiveChild);
					}
				}
			}
			if (mActiveBlend != null)
			{
				mActiveBlend.TimeInBlend += ((deltaTime >= 0f) ? deltaTime : mActiveBlend.Duration);
				if (mActiveBlend.IsComplete)
				{
					mActiveBlend = null;
				}
			}
			if (mActiveBlend != null)
			{
				mActiveBlend.UpdateCameraState(worldUp, deltaTime);
				m_State = mActiveBlend.State;
			}
			else if (LiveChild != null)
			{
				if (m_TransitioningFrom != null)
				{
					LiveChild.OnTransitionFromCamera(m_TransitioningFrom, worldUp, deltaTime);
				}
				m_State = LiveChild.State;
			}
			m_TransitioningFrom = null;
			InvokePostPipelineStageCallback(this, CinemachineCore.Stage.Finalize, ref m_State, deltaTime);
			PreviousStateIsValid = true;
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			InvalidateListOfChildren();
			mActiveBlend = null;
			CinemachineDebug.OnGUIHandlers = (CinemachineDebug.OnGUIDelegate)Delegate.Remove(CinemachineDebug.OnGUIHandlers, new CinemachineDebug.OnGUIDelegate(OnGuiHandler));
			CinemachineDebug.OnGUIHandlers = (CinemachineDebug.OnGUIDelegate)Delegate.Combine(CinemachineDebug.OnGUIHandlers, new CinemachineDebug.OnGUIDelegate(OnGuiHandler));
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			CinemachineDebug.OnGUIHandlers = (CinemachineDebug.OnGUIDelegate)Delegate.Remove(CinemachineDebug.OnGUIHandlers, new CinemachineDebug.OnGUIDelegate(OnGuiHandler));
		}

		public void OnTransformChildrenChanged()
		{
			InvalidateListOfChildren();
		}

		private void OnGuiHandler()
		{
			if (!m_ShowDebugText)
			{
				CinemachineDebug.ReleaseScreenPos(this);
				return;
			}
			StringBuilder stringBuilder = CinemachineDebug.SBFromPool();
			stringBuilder.Append(base.Name);
			stringBuilder.Append(": ");
			stringBuilder.Append(Description);
			string text = stringBuilder.ToString();
			GUI.Label(CinemachineDebug.GetScreenPos(this, text, GUI.skin.box), text, GUI.skin.box);
			CinemachineDebug.ReturnToPool(stringBuilder);
		}

		public static int CreateFakeHash(int parentHash, AnimationClip clip)
		{
			return Animator.StringToHash(parentHash + "_" + clip.name);
		}

		private int LookupFakeHash(int parentHash, AnimationClip clip)
		{
			if (mHashCache == null)
			{
				mHashCache = new Dictionary<AnimationClip, List<HashPair>>();
			}
			List<HashPair> value = null;
			if (!mHashCache.TryGetValue(clip, out value))
			{
				value = new List<HashPair>();
				mHashCache[clip] = value;
			}
			for (int i = 0; i < value.Count; i++)
			{
				if (value[i].parentHash == parentHash)
				{
					return value[i].hash;
				}
			}
			int num = CreateFakeHash(parentHash, clip);
			value.Add(new HashPair
			{
				parentHash = parentHash,
				hash = num
			});
			mStateParentLookup[num] = parentHash;
			return num;
		}

		private void InvalidateListOfChildren()
		{
			m_ChildCameras = null;
			LiveChild = null;
		}

		private void UpdateListOfChildren()
		{
			if (m_ChildCameras != null && mInstructionDictionary != null && mStateParentLookup != null)
			{
				return;
			}
			List<CinemachineVirtualCameraBase> list = new List<CinemachineVirtualCameraBase>();
			CinemachineVirtualCameraBase[] componentsInChildren = GetComponentsInChildren<CinemachineVirtualCameraBase>(includeInactive: true);
			foreach (CinemachineVirtualCameraBase cinemachineVirtualCameraBase in componentsInChildren)
			{
				if (cinemachineVirtualCameraBase.transform.parent == base.transform)
				{
					list.Add(cinemachineVirtualCameraBase);
				}
			}
			m_ChildCameras = list.ToArray();
			ValidateInstructions();
		}

		internal void ValidateInstructions()
		{
			if (m_Instructions == null)
			{
				m_Instructions = Array.Empty<Instruction>();
			}
			mInstructionDictionary = new Dictionary<int, int>();
			for (int i = 0; i < m_Instructions.Length; i++)
			{
				if (m_Instructions[i].m_VirtualCamera != null && m_Instructions[i].m_VirtualCamera.transform.parent != base.transform)
				{
					m_Instructions[i].m_VirtualCamera = null;
				}
				mInstructionDictionary[m_Instructions[i].m_FullHash] = i;
			}
			mStateParentLookup = new Dictionary<int, int>();
			if (m_ParentHash != null)
			{
				ParentHash[] parentHash = m_ParentHash;
				for (int j = 0; j < parentHash.Length; j++)
				{
					ParentHash parentHash2 = parentHash[j];
					mStateParentLookup[parentHash2.m_Hash] = parentHash2.m_ParentHash;
				}
			}
			mHashCache = null;
			mActivationTime = (mPendingActivationTime = 0f);
			mActiveBlend = null;
		}

		private CinemachineVirtualCameraBase ChooseCurrentCamera()
		{
			if (m_ChildCameras == null || m_ChildCameras.Length == 0)
			{
				mActivationTime = 0f;
				return null;
			}
			CinemachineVirtualCameraBase cinemachineVirtualCameraBase = m_ChildCameras[0];
			if (m_AnimatedTarget == null || !m_AnimatedTarget.gameObject.activeSelf || m_AnimatedTarget.runtimeAnimatorController == null || m_LayerIndex < 0 || !m_AnimatedTarget.hasBoundPlayables || m_LayerIndex >= m_AnimatedTarget.layerCount)
			{
				mActivationTime = 0f;
				return cinemachineVirtualCameraBase;
			}
			int num;
			if (m_AnimatedTarget.IsInTransition(m_LayerIndex))
			{
				AnimatorStateInfo nextAnimatorStateInfo = m_AnimatedTarget.GetNextAnimatorStateInfo(m_LayerIndex);
				m_AnimatedTarget.GetNextAnimatorClipInfo(m_LayerIndex, m_clipInfoList);
				num = GetClipHash(nextAnimatorStateInfo.fullPathHash, m_clipInfoList);
			}
			else
			{
				AnimatorStateInfo currentAnimatorStateInfo = m_AnimatedTarget.GetCurrentAnimatorStateInfo(m_LayerIndex);
				m_AnimatedTarget.GetCurrentAnimatorClipInfo(m_LayerIndex, m_clipInfoList);
				num = GetClipHash(currentAnimatorStateInfo.fullPathHash, m_clipInfoList);
			}
			while (num != 0 && !mInstructionDictionary.ContainsKey(num))
			{
				num = (mStateParentLookup.ContainsKey(num) ? mStateParentLookup[num] : 0);
			}
			float currentTime = CinemachineCore.CurrentTime;
			if (mActivationTime != 0f)
			{
				if (mActiveInstruction.m_FullHash == num)
				{
					mPendingActivationTime = 0f;
					return mActiveInstruction.m_VirtualCamera;
				}
				if (PreviousStateIsValid && mPendingActivationTime != 0f && mPendingInstruction.m_FullHash == num)
				{
					if (currentTime - mPendingActivationTime > mPendingInstruction.m_ActivateAfter && (currentTime - mActivationTime > mActiveInstruction.m_MinDuration || mPendingInstruction.m_VirtualCamera.Priority > mActiveInstruction.m_VirtualCamera.Priority))
					{
						mActiveInstruction = mPendingInstruction;
						mActivationTime = currentTime;
						mPendingActivationTime = 0f;
					}
					return mActiveInstruction.m_VirtualCamera;
				}
			}
			mPendingActivationTime = 0f;
			if (!mInstructionDictionary.ContainsKey(num))
			{
				if (mActivationTime != 0f)
				{
					return mActiveInstruction.m_VirtualCamera;
				}
				return cinemachineVirtualCameraBase;
			}
			Instruction instruction = m_Instructions[mInstructionDictionary[num]];
			if (instruction.m_VirtualCamera == null)
			{
				instruction.m_VirtualCamera = cinemachineVirtualCameraBase;
			}
			if (PreviousStateIsValid && mActivationTime > 0f && (instruction.m_ActivateAfter > 0f || (currentTime - mActivationTime < mActiveInstruction.m_MinDuration && instruction.m_VirtualCamera.Priority <= mActiveInstruction.m_VirtualCamera.Priority)))
			{
				mPendingInstruction = instruction;
				mPendingActivationTime = currentTime;
				if (mActivationTime != 0f)
				{
					return mActiveInstruction.m_VirtualCamera;
				}
				return cinemachineVirtualCameraBase;
			}
			mActiveInstruction = instruction;
			mActivationTime = currentTime;
			return mActiveInstruction.m_VirtualCamera;
		}

		private int GetClipHash(int hash, List<AnimatorClipInfo> clips)
		{
			int num = -1;
			for (int i = 0; i < clips.Count; i++)
			{
				if (num < 0 || clips[i].weight > clips[num].weight)
				{
					num = i;
				}
			}
			if (num >= 0 && clips[num].weight > 0f)
			{
				hash = LookupFakeHash(hash, clips[num].clip);
			}
			return hash;
		}

		private CinemachineBlendDefinition LookupBlend(ICinemachineCamera fromKey, ICinemachineCamera toKey)
		{
			CinemachineBlendDefinition cinemachineBlendDefinition = m_DefaultBlend;
			if (m_CustomBlends != null)
			{
				string fromCameraName = ((fromKey != null) ? fromKey.Name : string.Empty);
				string toCameraName = ((toKey != null) ? toKey.Name : string.Empty);
				cinemachineBlendDefinition = m_CustomBlends.GetBlendForVirtualCameras(fromCameraName, toCameraName, cinemachineBlendDefinition);
			}
			if (CinemachineCore.GetBlendOverride != null)
			{
				cinemachineBlendDefinition = CinemachineCore.GetBlendOverride(fromKey, toKey, cinemachineBlendDefinition, this);
			}
			return cinemachineBlendDefinition;
		}
	}
	[SaveDuringPlay]
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("")]
	[ExecuteAlways]
	[DisallowMultipleComponent]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineStoryboard.html")]
	public class CinemachineStoryboard : CinemachineExtension
	{
		public enum FillStrategy
		{
			BestFit,
			CropImageToFit,
			StretchToFit
		}

		private class CanvasInfo
		{
			public GameObject mCanvas;

			public Canvas mCanvasComponent;

			public CinemachineBrain mCanvasParent;

			public RectTransform mViewport;

			public RawImage mRawImage;
		}

		public enum StoryboardRenderMode
		{
			ScreenSpaceOverlay,
			ScreenSpaceCamera
		}

		[Tooltip("If checked, all storyboards are globally muted")]
		public static bool s_StoryboardGlobalMute;

		[Tooltip("If checked, the specified image will be displayed as an overlay over the virtual camera's output")]
		public bool m_ShowImage = true;

		[Tooltip("The image to display")]
		public Texture m_Image;

		[Tooltip("How to handle differences between image aspect and screen aspect")]
		public FillStrategy m_Aspect;

		[Tooltip("The opacity of the image.  0 is transparent, 1 is opaque")]
		[Range(0f, 1f)]
		public float m_Alpha = 1f;

		[Tooltip("The screen-space position at which to display the image.  Zero is center")]
		public Vector2 m_Center = Vector2.zero;

		[Tooltip("The screen-space rotation to apply to the image")]
		public Vector3 m_Rotation = Vector3.zero;

		[Tooltip("The screen-space scaling to apply to the image")]
		public Vector2 m_Scale = Vector3.one;

		[Tooltip("If checked, X and Y scale are synchronized")]
		public bool m_SyncScale = true;

		[Tooltip("If checked, Camera transform will not be controlled by this virtual camera")]
		public bool m_MuteCamera;

		[Range(-1f, 1f)]
		[Tooltip("Wipe the image on and off horizontally")]
		public float m_SplitView;

		[Tooltip("The render mode of the canvas on which the storyboard is drawn.")]
		public StoryboardRenderMode m_RenderMode;

		[Tooltip("Allows ordering canvases to render on top or below other canvases.")]
		public int m_SortingOrder;

		[Tooltip("How far away from the camera is the Canvas generated.")]
		public float m_PlaneDistance = 100f;

		private List<CanvasInfo> mCanvasInfo = new List<CanvasInfo>();

		private string CanvasName => "_CM_canvas" + base.gameObject.GetInstanceID();

		protected override void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, CinemachineCore.Stage stage, ref CameraState state, float deltaTime)
		{
			if (!(vcam != base.VirtualCamera) && stage == CinemachineCore.Stage.Finalize)
			{
				UpdateRenderCanvas();
				if (m_ShowImage)
				{
					state.AddCustomBlendable(new CameraState.CustomBlendable(this, 1f));
				}
				if (m_MuteCamera)
				{
					state.BlendHint |= (CameraState.BlendHintValue)67;
				}
			}
		}

		private void UpdateRenderCanvas()
		{
			for (int i = 0; i < mCanvasInfo.Count; i++)
			{
				if (mCanvasInfo[i] == null || mCanvasInfo[i].mCanvasComponent == null)
				{
					mCanvasInfo.RemoveAt(i--);
					continue;
				}
				mCanvasInfo[i].mCanvasComponent.renderMode = (RenderMode)m_RenderMode;
				mCanvasInfo[i].mCanvasComponent.planeDistance = m_PlaneDistance;
				mCanvasInfo[i].mCanvasComponent.sortingOrder = m_SortingOrder;
			}
		}

		protected override void ConnectToVcam(bool connect)
		{
			base.ConnectToVcam(connect);
			CinemachineCore.CameraUpdatedEvent.RemoveListener(CameraUpdatedCallback);
			if (connect)
			{
				CinemachineCore.CameraUpdatedEvent.AddListener(CameraUpdatedCallback);
			}
			else
			{
				DestroyCanvas();
			}
		}

		private void CameraUpdatedCallback(CinemachineBrain brain)
		{
			bool flag = base.enabled && m_ShowImage && CinemachineCore.Instance.IsLive(base.VirtualCamera);
			int num = 1 << base.gameObject.layer;
			if (brain.OutputCamera == null || (brain.OutputCamera.cullingMask & num) == 0)
			{
				flag = false;
			}
			if (s_StoryboardGlobalMute)
			{
				flag = false;
			}
			CanvasInfo canvasInfo = LocateMyCanvas(brain, flag);
			if (canvasInfo != null && canvasInfo.mCanvas != null)
			{
				canvasInfo.mCanvas.SetActive(flag);
			}
		}

		private CanvasInfo LocateMyCanvas(CinemachineBrain parent, bool createIfNotFound)
		{
			CanvasInfo canvasInfo = null;
			int num = 0;
			while (canvasInfo == null && num < mCanvasInfo.Count)
			{
				if (mCanvasInfo[num] != null && mCanvasInfo[num].mCanvasParent == parent)
				{
					canvasInfo = mCanvasInfo[num];
				}
				num++;
			}
			if (createIfNotFound)
			{
				if (canvasInfo == null)
				{
					canvasInfo = new CanvasInfo
					{
						mCanvasParent = parent
					};
					int childCount = parent.transform.childCount;
					int num2 = 0;
					while (canvasInfo.mCanvas == null && num2 < childCount)
					{
						RectTransform rectTransform = parent.transform.GetChild(num2) as RectTransform;
						if (rectTransform != null && rectTransform.name == CanvasName)
						{
							canvasInfo.mCanvas = rectTransform.gameObject;
							RectTransform[] componentsInChildren = canvasInfo.mCanvas.GetComponentsInChildren<RectTransform>();
							canvasInfo.mViewport = ((componentsInChildren.Length > 1) ? componentsInChildren[1] : null);
							canvasInfo.mRawImage = canvasInfo.mCanvas.GetComponentInChildren<RawImage>();
							canvasInfo.mCanvasComponent = canvasInfo.mCanvas.GetComponent<Canvas>();
						}
						num2++;
					}
					mCanvasInfo.Add(canvasInfo);
				}
				if (canvasInfo.mCanvas == null || canvasInfo.mViewport == null || canvasInfo.mRawImage == null || canvasInfo.mCanvasComponent == null)
				{
					CreateCanvas(canvasInfo);
				}
			}
			return canvasInfo;
		}

		private void CreateCanvas(CanvasInfo ci)
		{
			ci.mCanvas = new GameObject(CanvasName, typeof(RectTransform));
			ci.mCanvas.layer = base.gameObject.layer;
			ci.mCanvas.hideFlags = HideFlags.HideAndDontSave;
			ci.mCanvas.transform.SetParent(ci.mCanvasParent.transform);
			Canvas canvas = (ci.mCanvasComponent = ci.mCanvas.AddComponent<Canvas>());
			canvas.renderMode = (RenderMode)m_RenderMode;
			canvas.sortingOrder = m_SortingOrder;
			canvas.planeDistance = m_PlaneDistance;
			canvas.worldCamera = ci.mCanvasParent.OutputCamera;
			GameObject gameObject = new GameObject("Viewport", typeof(RectTransform));
			gameObject.transform.SetParent(ci.mCanvas.transform);
			ci.mViewport = (RectTransform)gameObject.transform;
			gameObject.AddComponent<RectMask2D>();
			gameObject = new GameObject("RawImage", typeof(RectTransform));
			gameObject.transform.SetParent(ci.mViewport.transform);
			ci.mRawImage = gameObject.AddComponent<RawImage>();
		}

		private void DestroyCanvas()
		{
			int brainCount = CinemachineCore.Instance.BrainCount;
			for (int i = 0; i < brainCount; i++)
			{
				CinemachineBrain activeBrain = CinemachineCore.Instance.GetActiveBrain(i);
				for (int num = activeBrain.transform.childCount - 1; num >= 0; num--)
				{
					RectTransform rectTransform = activeBrain.transform.GetChild(num) as RectTransform;
					if (rectTransform != null && rectTransform.name == CanvasName)
					{
						RuntimeUtility.DestroyObject(rectTransform.gameObject);
					}
				}
			}
			mCanvasInfo.Clear();
		}

		private void PlaceImage(CanvasInfo ci, float alpha)
		{
			if (!(ci.mRawImage != null) || !(ci.mViewport != null))
			{
				return;
			}
			Rect rect = new Rect(0f, 0f, Screen.width, Screen.height);
			if (ci.mCanvasParent.OutputCamera != null)
			{
				rect = ci.mCanvasParent.OutputCamera.pixelRect;
			}
			rect.x -= (float)Screen.width / 2f;
			rect.y -= (float)Screen.height / 2f;
			float num = (0f - Mathf.Clamp(m_SplitView, -1f, 1f)) * rect.width;
			Vector3 localPosition = rect.center;
			localPosition.x -= num / 2f;
			ci.mViewport.localPosition = localPosition;
			ci.mViewport.localRotation = Quaternion.identity;
			ci.mViewport.localScale = Vector3.one;
			ci.mViewport.ForceUpdateRectTransforms();
			ci.mViewport.sizeDelta = new Vector2(rect.width + 1f - Mathf.Abs(num), rect.height + 1f);
			Vector2 one = Vector2.one;
			if (m_Image != null && m_Image.width > 0 && m_Image.width > 0 && rect.width > 0f && rect.height > 0f)
			{
				float num2 = rect.height * (float)m_Image.width / (rect.width * (float)m_Image.height);
				switch (m_Aspect)
				{
				case FillStrategy.BestFit:
					if (num2 >= 1f)
					{
						one.y /= num2;
					}
					else
					{
						one.x *= num2;
					}
					break;
				case FillStrategy.CropImageToFit:
					if (num2 >= 1f)
					{
						one.x *= num2;
					}
					else
					{
						one.y /= num2;
					}
					break;
				}
			}
			one.x *= m_Scale.x;
			one.y *= (m_SyncScale ? m_Scale.x : m_Scale.y);
			ci.mRawImage.texture = m_Image;
			Color white = Color.white;
			white.a = m_Alpha * alpha;
			ci.mRawImage.color = white;
			localPosition = new Vector2(rect.width * m_Center.x, rect.height * m_Center.y);
			localPosition.x += num / 2f;
			ci.mRawImage.rectTransform.localPosition = localPosition;
			ci.mRawImage.rectTransform.localRotation = Quaternion.Euler(m_Rotation);
			ci.mRawImage.rectTransform.localScale = one;
			ci.mRawImage.rectTransform.ForceUpdateRectTransforms();
			ci.mRawImage.rectTransform.sizeDelta = rect.size;
		}

		private static void StaticBlendingHandler(CinemachineBrain brain)
		{
			CameraState currentCameraState = brain.CurrentCameraState;
			int numCustomBlendables = currentCameraState.NumCustomBlendables;
			for (int i = 0; i < numCustomBlendables; i++)
			{
				CameraState.CustomBlendable customBlendable = currentCameraState.GetCustomBlendable(i);
				CinemachineStoryboard cinemachineStoryboard = customBlendable.m_Custom as CinemachineStoryboard;
				if (!(cinemachineStoryboard == null))
				{
					bool createIfNotFound = true;
					int num = 1 << cinemachineStoryboard.gameObject.layer;
					if (brain.OutputCamera == null || (brain.OutputCamera.cullingMask & num) == 0)
					{
						createIfNotFound = false;
					}
					if (s_StoryboardGlobalMute)
					{
						createIfNotFound = false;
					}
					CanvasInfo canvasInfo = cinemachineStoryboard.LocateMyCanvas(brain, createIfNotFound);
					if (canvasInfo != null)
					{
						cinemachineStoryboard.PlaceImage(canvasInfo, customBlendable.m_Weight);
					}
				}
			}
		}

		[RuntimeInitializeOnLoadMethod]
		private static void InitializeModule()
		{
			CinemachineCore.CameraUpdatedEvent.RemoveListener(StaticBlendingHandler);
			CinemachineCore.CameraUpdatedEvent.AddListener(StaticBlendingHandler);
		}
	}
	public interface ICinemachineTargetGroup
	{
		Transform Transform { get; }

		Bounds BoundingBox { get; }

		BoundingSphere Sphere { get; }

		bool IsEmpty { get; }

		Bounds GetViewSpaceBoundingBox(Matrix4x4 observer);

		void GetViewSpaceAngularBounds(Matrix4x4 observer, out Vector2 minAngles, out Vector2 maxAngles, out Vector2 zRange);
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("Cinemachine/CinemachineTargetGroup")]
	[SaveDuringPlay]
	[ExecuteAlways]
	[DisallowMultipleComponent]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineTargetGroup.html")]
	public class CinemachineTargetGroup : MonoBehaviour, ICinemachineTargetGroup
	{
		[Serializable]
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public struct Target
		{
			[Tooltip("The target objects.  This object's position and orientation will contribute to the group's average position and orientation, in accordance with its weight")]
			public Transform target;

			[Tooltip("How much weight to give the target when averaging.  Cannot be negative")]
			public float weight;

			[Tooltip("The radius of the target, used for calculating the bounding box.  Cannot be negative")]
			public float radius;
		}

		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public enum PositionMode
		{
			GroupCenter,
			GroupAverage
		}

		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public enum RotationMode
		{
			Manual,
			GroupAverage
		}

		public enum UpdateMethod
		{
			Update,
			FixedUpdate,
			LateUpdate
		}

		[Tooltip("How the group's position is calculated.  Select GroupCenter for the center of the bounding box, and GroupAverage for a weighted average of the positions of the members.")]
		public PositionMode m_PositionMode;

		[Tooltip("How the group's rotation is calculated.  Select Manual to use the value in the group's transform, and GroupAverage for a weighted average of the orientations of the members.")]
		public RotationMode m_RotationMode;

		[Tooltip("When to update the group's transform based on the position of the group members")]
		public UpdateMethod m_UpdateMethod = UpdateMethod.LateUpdate;

		[NoSaveDuringPlay]
		[Tooltip("The target objects, together with their weights and radii, that will contribute to the group's average position, orientation, and size.")]
		public Target[] m_Targets = Array.Empty<Target>();

		private float m_MaxWeight;

		private float m_WeightSum;

		private Vector3 m_AveragePos;

		private Bounds m_BoundingBox;

		private BoundingSphere m_BoundingSphere;

		private int m_LastUpdateFrame = -1;

		private List<int> m_ValidMembers = new List<int>();

		private List<bool> m_MemberValidity = new List<bool>();

		public Transform Transform => base.transform;

		public Bounds BoundingBox
		{
			get
			{
				if (m_LastUpdateFrame != Time.frameCount)
				{
					DoUpdate();
				}
				return m_BoundingBox;
			}
			private set
			{
				m_BoundingBox = value;
			}
		}

		public BoundingSphere Sphere
		{
			get
			{
				if (m_LastUpdateFrame != Time.frameCount)
				{
					DoUpdate();
				}
				return m_BoundingSphere;
			}
			private set
			{
				m_BoundingSphere = value;
			}
		}

		public bool IsEmpty
		{
			get
			{
				if (m_LastUpdateFrame != Time.frameCount)
				{
					DoUpdate();
				}
				return m_ValidMembers.Count == 0;
			}
		}

		private bool CachedCountIsValid => m_MemberValidity.Count == ((m_Targets != null) ? m_Targets.Length : 0);

		private void OnValidate()
		{
			int num = ((m_Targets != null) ? m_Targets.Length : 0);
			for (int i = 0; i < num; i++)
			{
				m_Targets[i].weight = Mathf.Max(0f, m_Targets[i].weight);
				m_Targets[i].radius = Mathf.Max(0f, m_Targets[i].radius);
			}
		}

		private void Reset()
		{
			m_PositionMode = PositionMode.GroupCenter;
			m_RotationMode = RotationMode.Manual;
			m_UpdateMethod = UpdateMethod.LateUpdate;
			m_Targets = Array.Empty<Target>();
		}

		public void AddMember(Transform t, float weight, float radius)
		{
			int num = 0;
			if (m_Targets == null)
			{
				m_Targets = new Target[1];
			}
			else
			{
				num = m_Targets.Length;
				Target[] targets = m_Targets;
				m_Targets = new Target[num + 1];
				Array.Copy(targets, m_Targets, num);
			}
			m_Targets[num].target = t;
			m_Targets[num].weight = weight;
			m_Targets[num].radius = radius;
		}

		public void RemoveMember(Transform t)
		{
			int num = FindMember(t);
			if (num >= 0)
			{
				Target[] targets = m_Targets;
				m_Targets = new Target[m_Targets.Length - 1];
				if (num > 0)
				{
					Array.Copy(targets, m_Targets, num);
				}
				if (num < targets.Length - 1)
				{
					Array.Copy(targets, num + 1, m_Targets, num, targets.Length - num - 1);
				}
			}
		}

		public int FindMember(Transform t)
		{
			if (m_Targets != null)
			{
				for (int num = m_Targets.Length - 1; num >= 0; num--)
				{
					if (m_Targets[num].target == t)
					{
						return num;
					}
				}
			}
			return -1;
		}

		public BoundingSphere GetWeightedBoundsForMember(int index)
		{
			if (m_LastUpdateFrame != Time.frameCount)
			{
				DoUpdate();
			}
			if (!IndexIsValid(index) || !m_MemberValidity[index])
			{
				return Sphere;
			}
			return WeightedMemberBoundsForValidMember(ref m_Targets[index], m_AveragePos, m_MaxWeight);
		}

		public Bounds GetViewSpaceBoundingBox(Matrix4x4 observer)
		{
			if (m_LastUpdateFrame != Time.frameCount)
			{
				DoUpdate();
			}
			Matrix4x4 result = observer;
			if (!Matrix4x4.Inverse3DAffine(observer, ref result))
			{
				result = observer.inverse;
			}
			Bounds result2 = new Bounds(result.MultiplyPoint3x4(m_AveragePos), Vector3.zero);
			if (CachedCountIsValid)
			{
				bool flag = false;
				Vector3 vector = 2f * Vector3.one;
				int count = m_ValidMembers.Count;
				for (int i = 0; i < count; i++)
				{
					BoundingSphere boundingSphere = WeightedMemberBoundsForValidMember(ref m_Targets[m_ValidMembers[i]], m_AveragePos, m_MaxWeight);
					boundingSphere.position = result.MultiplyPoint3x4(boundingSphere.position);
					if (flag)
					{
						result2.Encapsulate(new Bounds(boundingSphere.position, boundingSphere.radius * vector));
					}
					else
					{
						result2 = new Bounds(boundingSphere.position, boundingSphere.radius * vector);
					}
					flag = true;
				}
			}
			return result2;
		}

		private bool IndexIsValid(int index)
		{
			if (index >= 0 && m_Targets != null && index < m_Targets.Length)
			{
				return CachedCountIsValid;
			}
			return false;
		}

		private static BoundingSphere WeightedMemberBoundsForValidMember(ref Target t, Vector3 avgPos, float maxWeight)
		{
			Vector3 b = ((t.target == null) ? avgPos : TargetPositionCache.GetTargetPosition(t.target));
			float num = Mathf.Max(0f, t.weight);
			num = ((!(maxWeight > 0.0001f) || !(num < maxWeight)) ? 1f : (num / maxWeight));
			return new BoundingSphere(Vector3.Lerp(avgPos, b, num), t.radius * num);
		}

		public void DoUpdate()
		{
			m_LastUpdateFrame = Time.frameCount;
			UpdateMemberValidity();
			m_AveragePos = CalculateAveragePosition();
			BoundingBox = CalculateBoundingBox();
			m_BoundingSphere = CalculateBoundingSphere();
			switch (m_PositionMode)
			{
			case PositionMode.GroupCenter:
				base.transform.position = Sphere.position;
				break;
			case PositionMode.GroupAverage:
				base.transform.position = m_AveragePos;
				break;
			}
			RotationMode rotationMode = m_RotationMode;
			if (rotationMode != RotationMode.Manual && rotationMode == RotationMode.GroupAverage)
			{
				base.transform.rotation = CalculateAverageOrientation();
			}
		}

		private void UpdateMemberValidity()
		{
			int num = ((m_Targets != null) ? m_Targets.Length : 0);
			m_ValidMembers.Clear();
			m_ValidMembers.Capacity = Mathf.Max(m_ValidMembers.Capacity, num);
			m_MemberValidity.Clear();
			m_MemberValidity.Capacity = Mathf.Max(m_MemberValidity.Capacity, num);
			m_WeightSum = (m_MaxWeight = 0f);
			for (int i = 0; i < num; i++)
			{
				m_MemberValidity.Add(m_Targets[i].target != null && m_Targets[i].weight > 0.0001f && m_Targets[i].target.gameObject.activeInHierarchy);
				if (m_MemberValidity[i])
				{
					m_ValidMembers.Add(i);
					m_MaxWeight = Mathf.Max(m_MaxWeight, m_Targets[i].weight);
					m_WeightSum += m_Targets[i].weight;
				}
			}
		}

		private Vector3 CalculateAveragePosition()
		{
			if (m_WeightSum < 0.0001f)
			{
				return base.transform.position;
			}
			Vector3 zero = Vector3.zero;
			int count = m_ValidMembers.Count;
			for (int i = 0; i < count; i++)
			{
				int num = m_ValidMembers[i];
				float weight = m_Targets[num].weight;
				zero += TargetPositionCache.GetTargetPosition(m_Targets[num].target) * weight;
			}
			return zero / m_WeightSum;
		}

		private Bounds CalculateBoundingBox()
		{
			if (m_MaxWeight < 0.0001f)
			{
				return BoundingBox;
			}
			Bounds result = new Bounds(m_AveragePos, Vector3.zero);
			int count = m_ValidMembers.Count;
			for (int i = 0; i < count; i++)
			{
				BoundingSphere boundingSphere = WeightedMemberBoundsForValidMember(ref m_Targets[m_ValidMembers[i]], m_AveragePos, m_MaxWeight);
				result.Encapsulate(new Bounds(boundingSphere.position, boundingSphere.radius * 2f * Vector3.one));
			}
			return result;
		}

		private BoundingSphere CalculateBoundingSphere()
		{
			int count = m_ValidMembers.Count;
			if (count == 0 || m_MaxWeight < 0.0001f)
			{
				return m_BoundingSphere;
			}
			BoundingSphere result = WeightedMemberBoundsForValidMember(ref m_Targets[m_ValidMembers[0]], m_AveragePos, m_MaxWeight);
			for (int i = 1; i < count; i++)
			{
				BoundingSphere boundingSphere = WeightedMemberBoundsForValidMember(ref m_Targets[m_ValidMembers[i]], m_AveragePos, m_MaxWeight);
				float num = (boundingSphere.position - result.position).magnitude + boundingSphere.radius;
				if (num > result.radius)
				{
					result.radius = (result.radius + num) * 0.5f;
					result.position = (result.radius * result.position + (num - result.radius) * boundingSphere.position) / num;
				}
			}
			return result;
		}

		private Quaternion CalculateAverageOrientation()
		{
			if (m_WeightSum > 0.001f)
			{
				Vector3 zero = Vector3.zero;
				Vector3 zero2 = Vector3.zero;
				int count = m_ValidMembers.Count;
				for (int i = 0; i < count; i++)
				{
					int num = m_ValidMembers[i];
					float num2 = m_Targets[num].weight / m_WeightSum;
					Quaternion targetRotation = TargetPositionCache.GetTargetRotation(m_Targets[num].target);
					zero += targetRotation * Vector3.forward * num2;
					zero2 += targetRotation * Vector3.up * num2;
				}
				if (zero.sqrMagnitude > 0.0001f && zero2.sqrMagnitude > 0.0001f)
				{
					return Quaternion.LookRotation(zero, zero2);
				}
			}
			return base.transform.rotation;
		}

		private void FixedUpdate()
		{
			if (m_UpdateMethod == UpdateMethod.FixedUpdate)
			{
				DoUpdate();
			}
		}

		private void Update()
		{
			if (!Application.isPlaying || m_UpdateMethod == UpdateMethod.Update)
			{
				DoUpdate();
			}
		}

		private void LateUpdate()
		{
			if (m_UpdateMethod == UpdateMethod.LateUpdate)
			{
				DoUpdate();
			}
		}

		public void GetViewSpaceAngularBounds(Matrix4x4 observer, out Vector2 minAngles, out Vector2 maxAngles, out Vector2 zRange)
		{
			if (m_LastUpdateFrame != Time.frameCount)
			{
				DoUpdate();
			}
			Matrix4x4 result = observer;
			if (!Matrix4x4.Inverse3DAffine(observer, ref result))
			{
				result = observer.inverse;
			}
			float radius = m_BoundingSphere.radius;
			Bounds bounds = new Bounds
			{
				center = result.MultiplyPoint3x4(m_AveragePos),
				extents = new Vector3(radius, radius, radius)
			};
			zRange = new Vector2(bounds.center.z - radius, bounds.center.z + radius);
			if (CachedCountIsValid)
			{
				bool flag = false;
				int count = m_ValidMembers.Count;
				for (int i = 0; i < count; i++)
				{
					BoundingSphere boundingSphere = WeightedMemberBoundsForValidMember(ref m_Targets[m_ValidMembers[i]], m_AveragePos, m_MaxWeight);
					Vector3 vector = result.MultiplyPoint3x4(boundingSphere.position);
					if (!(vector.z < 0.0001f))
					{
						float num = boundingSphere.radius / vector.z;
						Vector3 vector2 = new Vector3(num, num, 0f);
						Vector3 vector3 = vector / vector.z;
						if (!flag)
						{
							bounds.center = vector3;
							bounds.extents = vector2;
							zRange = new Vector2(vector.z, vector.z);
							flag = true;
						}
						else
						{
							bounds.Encapsulate(vector3 + vector2);
							bounds.Encapsulate(vector3 - vector2);
							zRange.x = Mathf.Min(zRange.x, vector.z);
							zRange.y = Mathf.Max(zRange.y, vector.z);
						}
					}
				}
			}
			Vector3 min = bounds.min;
			Vector3 max = bounds.max;
			minAngles = new Vector2(Vector3.SignedAngle(Vector3.forward, new Vector3(0f, min.y, 1f), Vector3.left), Vector3.SignedAngle(Vector3.forward, new Vector3(min.x, 0f, 1f), Vector3.up));
			maxAngles = new Vector2(Vector3.SignedAngle(Vector3.forward, new Vector3(0f, max.y, 1f), Vector3.left), Vector3.SignedAngle(Vector3.forward, new Vector3(max.x, 0f, 1f), Vector3.up));
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[DisallowMultipleComponent]
	[ExecuteAlways]
	[ExcludeFromPreset]
	[AddComponentMenu("Cinemachine/CinemachineVirtualCamera")]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineVirtualCamera.html")]
	public class CinemachineVirtualCamera : CinemachineVirtualCameraBase
	{
		public delegate Transform CreatePipelineDelegate(CinemachineVirtualCamera vcam, string name, CinemachineComponentBase[] copyFrom);

		public delegate void DestroyPipelineDelegate(GameObject pipeline);

		[Tooltip("The object that the camera wants to look at (the Aim target).  If this is null, then the vcam's Transform orientation will define the camera's orientation.")]
		[NoSaveDuringPlay]
		[VcamTargetProperty]
		public Transform m_LookAt;

		[Tooltip("The object that the camera wants to move with (the Body target).  If this is null, then the vcam's Transform position will define the camera's position.")]
		[NoSaveDuringPlay]
		[VcamTargetProperty]
		public Transform m_Follow;

		[FormerlySerializedAs("m_LensAttributes")]
		[Tooltip("Specifies the lens properties of this Virtual Camera.  This generally mirrors the Unity Camera's lens settings, and will be used to drive the Unity camera when the vcam is active.")]
		public LensSettings m_Lens = LensSettings.Default;

		public TransitionParams m_Transitions;

		[SerializeField]
		[HideInInspector]
		[FormerlySerializedAs("m_BlendHint")]
		[FormerlySerializedAs("m_PositionBlending")]
		private BlendHint m_LegacyBlendHint;

		public const string PipelineName = "cm";

		public static CreatePipelineDelegate CreatePipelineOverride;

		public static DestroyPipelineDelegate DestroyPipelineOverride;

		private CameraState m_State = CameraState.Default;

		private CinemachineComponentBase[] m_ComponentPipeline;

		[SerializeField]
		[HideInInspector]
		private Transform m_ComponentOwner;

		private Transform mCachedLookAtTarget;

		private CinemachineVirtualCameraBase mCachedLookAtTargetVcam;

		public override CameraState State => m_State;

		public override Transform LookAt
		{
			get
			{
				return ResolveLookAt(m_LookAt);
			}
			set
			{
				m_LookAt = value;
			}
		}

		public override Transform Follow
		{
			get
			{
				return ResolveFollow(m_Follow);
			}
			set
			{
				m_Follow = value;
			}
		}

		public override float GetMaxDampTime()
		{
			float num = base.GetMaxDampTime();
			UpdateComponentPipeline();
			if (m_ComponentPipeline != null)
			{
				for (int i = 0; i < m_ComponentPipeline.Length; i++)
				{
					num = Mathf.Max(num, m_ComponentPipeline[i].GetMaxDampTime());
				}
			}
			return num;
		}

		public override void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
		{
			UpdateTargetCache();
			m_State = CalculateNewState(worldUp, deltaTime);
			ApplyPositionBlendMethod(ref m_State, m_Transitions.m_BlendHint);
			base.transform.GetPositionAndRotation(out var position, out var rotation);
			if (Follow != null)
			{
				position = m_State.RawPosition;
			}
			if (LookAt != null)
			{
				rotation = m_State.RawOrientation;
			}
			base.transform.ConservativeSetPositionAndRotation(position, rotation);
			PreviousStateIsValid = true;
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			m_State = PullStateFromVirtualCamera(Vector3.up, ref m_Lens);
			InvalidateComponentPipeline();
			if (base.ValidatingStreamVersion < 20170927)
			{
				if (Follow != null && GetCinemachineComponent(CinemachineCore.Stage.Body) == null)
				{
					AddCinemachineComponent<CinemachineHardLockToTarget>();
				}
				if (LookAt != null && GetCinemachineComponent(CinemachineCore.Stage.Aim) == null)
				{
					AddCinemachineComponent<CinemachineHardLookAt>();
				}
			}
		}

		protected override void OnDestroy()
		{
			foreach (Transform item in base.transform)
			{
				if (item.GetComponent<CinemachinePipeline>() != null)
				{
					item.gameObject.hideFlags &= ~(HideFlags.HideInHierarchy | HideFlags.HideInInspector);
				}
			}
			base.OnDestroy();
		}

		protected override void OnValidate()
		{
			base.OnValidate();
			m_Lens.Validate();
			if (m_LegacyBlendHint != BlendHint.None)
			{
				m_Transitions.m_BlendHint = m_LegacyBlendHint;
				m_LegacyBlendHint = BlendHint.None;
			}
		}

		private void OnTransformChildrenChanged()
		{
			InvalidateComponentPipeline();
		}

		private void Reset()
		{
			DestroyPipeline();
			UpdateComponentPipeline();
		}

		internal void DestroyPipeline()
		{
			List<Transform> list = new List<Transform>();
			foreach (Transform item in base.transform)
			{
				if (item.GetComponent<CinemachinePipeline>() != null)
				{
					list.Add(item);
				}
			}
			foreach (Transform item2 in list)
			{
				if (DestroyPipelineOverride != null)
				{
					DestroyPipelineOverride(item2.gameObject);
					continue;
				}
				CinemachineComponentBase[] components = item2.GetComponents<CinemachineComponentBase>();
				for (int i = 0; i < components.Length; i++)
				{
					UnityEngine.Object.Destroy(components[i]);
				}
				if (!RuntimeUtility.IsPrefab(base.gameObject))
				{
					UnityEngine.Object.Destroy(item2.gameObject);
				}
			}
			m_ComponentOwner = null;
			InvalidateComponentPipeline();
			PreviousStateIsValid = false;
		}

		internal Transform CreatePipeline(CinemachineVirtualCamera copyFrom)
		{
			CinemachineComponentBase[] copyFrom2 = null;
			if (copyFrom != null)
			{
				copyFrom.InvalidateComponentPipeline();
				copyFrom2 = copyFrom.GetComponentPipeline();
			}
			Transform result = null;
			if (CreatePipelineOverride != null)
			{
				result = CreatePipelineOverride(this, "cm", copyFrom2);
			}
			else if (!RuntimeUtility.IsPrefab(base.gameObject))
			{
				GameObject obj = new GameObject("cm");
				obj.transform.parent = base.transform;
				obj.AddComponent<CinemachinePipeline>();
				result = obj.transform;
			}
			PreviousStateIsValid = false;
			return result;
		}

		public void InvalidateComponentPipeline()
		{
			m_ComponentPipeline = null;
		}

		public Transform GetComponentOwner()
		{
			UpdateComponentPipeline();
			return m_ComponentOwner;
		}

		public CinemachineComponentBase[] GetComponentPipeline()
		{
			UpdateComponentPipeline();
			return m_ComponentPipeline;
		}

		public CinemachineComponentBase GetCinemachineComponent(CinemachineCore.Stage stage)
		{
			CinemachineComponentBase[] componentPipeline = GetComponentPipeline();
			if (componentPipeline != null)
			{
				CinemachineComponentBase[] array = componentPipeline;
				foreach (CinemachineComponentBase cinemachineComponentBase in array)
				{
					if (cinemachineComponentBase.Stage == stage)
					{
						return cinemachineComponentBase;
					}
				}
			}
			return null;
		}

		public T GetCinemachineComponent<T>() where T : CinemachineComponentBase
		{
			CinemachineComponentBase[] componentPipeline = GetComponentPipeline();
			if (componentPipeline != null)
			{
				CinemachineComponentBase[] array = componentPipeline;
				foreach (CinemachineComponentBase cinemachineComponentBase in array)
				{
					if (cinemachineComponentBase is T)
					{
						return cinemachineComponentBase as T;
					}
				}
			}
			return null;
		}

		public T AddCinemachineComponent<T>() where T : CinemachineComponentBase
		{
			Transform componentOwner = GetComponentOwner();
			if (componentOwner == null)
			{
				return null;
			}
			CinemachineComponentBase[] components = componentOwner.GetComponents<CinemachineComponentBase>();
			T val = componentOwner.gameObject.AddComponent<T>();
			if (val != null && components != null)
			{
				CinemachineCore.Stage stage = val.Stage;
				for (int num = components.Length - 1; num >= 0; num--)
				{
					if (components[num].Stage == stage)
					{
						components[num].enabled = false;
						RuntimeUtility.DestroyObject(components[num]);
					}
				}
			}
			InvalidateComponentPipeline();
			return val;
		}

		public void DestroyCinemachineComponent<T>() where T : CinemachineComponentBase
		{
			CinemachineComponentBase[] componentPipeline = GetComponentPipeline();
			if (componentPipeline == null)
			{
				return;
			}
			CinemachineComponentBase[] array = componentPipeline;
			foreach (CinemachineComponentBase cinemachineComponentBase in array)
			{
				if (cinemachineComponentBase is T)
				{
					cinemachineComponentBase.enabled = false;
					RuntimeUtility.DestroyObject(cinemachineComponentBase);
					InvalidateComponentPipeline();
				}
			}
		}

		private void UpdateComponentPipeline()
		{
			if (m_ComponentOwner != null && m_ComponentPipeline != null)
			{
				return;
			}
			m_ComponentOwner = null;
			List<CinemachineComponentBase> list = new List<CinemachineComponentBase>();
			foreach (Transform item in base.transform)
			{
				if (!(item.GetComponent<CinemachinePipeline>() != null))
				{
					continue;
				}
				CinemachineComponentBase[] components = item.GetComponents<CinemachineComponentBase>();
				foreach (CinemachineComponentBase cinemachineComponentBase in components)
				{
					if (cinemachineComponentBase.enabled)
					{
						list.Add(cinemachineComponentBase);
					}
				}
				m_ComponentOwner = item;
				break;
			}
			if (m_ComponentOwner == null)
			{
				m_ComponentOwner = CreatePipeline(null);
			}
			if (m_ComponentOwner != null && m_ComponentOwner.gameObject != null)
			{
				list.Sort((CinemachineComponentBase c1, CinemachineComponentBase c2) => c1.Stage - c2.Stage);
				m_ComponentPipeline = list.ToArray();
			}
		}

		internal static void SetFlagsForHiddenChild(GameObject child)
		{
			if (child != null)
			{
				if (CinemachineCore.sShowHiddenObjects)
				{
					child.hideFlags &= ~(HideFlags.HideInHierarchy | HideFlags.HideInInspector);
				}
				else
				{
					child.hideFlags |= HideFlags.HideInHierarchy | HideFlags.HideInInspector;
				}
			}
		}

		private CameraState CalculateNewState(Vector3 worldUp, float deltaTime)
		{
			FollowTargetAttachment = 1f;
			LookAtTargetAttachment = 1f;
			CameraState newState = PullStateFromVirtualCamera(worldUp, ref m_Lens);
			Transform lookAt = LookAt;
			if (lookAt != mCachedLookAtTarget)
			{
				mCachedLookAtTarget = lookAt;
				mCachedLookAtTargetVcam = null;
				if (lookAt != null)
				{
					mCachedLookAtTargetVcam = lookAt.GetComponent<CinemachineVirtualCameraBase>();
				}
			}
			if (lookAt != null)
			{
				if (mCachedLookAtTargetVcam != null)
				{
					newState.ReferenceLookAt = mCachedLookAtTargetVcam.State.FinalPosition;
				}
				else
				{
					newState.ReferenceLookAt = TargetPositionCache.GetTargetPosition(lookAt);
				}
			}
			UpdateComponentPipeline();
			InvokePrePipelineMutateCameraStateCallback(this, ref newState, deltaTime);
			bool flag = false;
			if (m_ComponentPipeline == null)
			{
				for (CinemachineCore.Stage stage = CinemachineCore.Stage.Body; stage <= CinemachineCore.Stage.Finalize; stage++)
				{
					InvokePostPipelineStageCallback(this, stage, ref newState, deltaTime);
				}
			}
			else
			{
				for (int i = 0; i < m_ComponentPipeline.Length; i++)
				{
					if (m_ComponentPipeline[i] != null)
					{
						m_ComponentPipeline[i].PrePipelineMutateCameraState(ref newState, deltaTime);
					}
				}
				int num = 0;
				CinemachineComponentBase cinemachineComponentBase = null;
				for (CinemachineCore.Stage stage2 = CinemachineCore.Stage.Body; stage2 <= CinemachineCore.Stage.Finalize; stage2++)
				{
					CinemachineComponentBase cinemachineComponentBase2 = ((num < m_ComponentPipeline.Length) ? m_ComponentPipeline[num] : null);
					if (cinemachineComponentBase2 != null && stage2 == cinemachineComponentBase2.Stage)
					{
						num++;
						if (stage2 == CinemachineCore.Stage.Body && cinemachineComponentBase2.BodyAppliesAfterAim)
						{
							cinemachineComponentBase = cinemachineComponentBase2;
							continue;
						}
						cinemachineComponentBase2.MutateCameraState(ref newState, deltaTime);
						flag = stage2 == CinemachineCore.Stage.Aim;
					}
					InvokePostPipelineStageCallback(this, stage2, ref newState, deltaTime);
					if (stage2 == CinemachineCore.Stage.Aim && cinemachineComponentBase != null)
					{
						cinemachineComponentBase.MutateCameraState(ref newState, deltaTime);
						InvokePostPipelineStageCallback(this, CinemachineCore.Stage.Body, ref newState, deltaTime);
					}
				}
			}
			if (!flag)
			{
				newState.BlendHint |= CameraState.BlendHintValue.IgnoreLookAtTarget;
			}
			return newState;
		}

		public override void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
			if (target == Follow)
			{
				base.transform.position += positionDelta;
				m_State.RawPosition += positionDelta;
			}
			UpdateComponentPipeline();
			if (m_ComponentPipeline != null)
			{
				for (int i = 0; i < m_ComponentPipeline.Length; i++)
				{
					m_ComponentPipeline[i].OnTargetObjectWarped(target, positionDelta);
				}
			}
			base.OnTargetObjectWarped(target, positionDelta);
		}

		public override void ForceCameraPosition(Vector3 pos, Quaternion rot)
		{
			PreviousStateIsValid = true;
			base.transform.ConservativeSetPositionAndRotation(pos, rot);
			m_State.RawPosition = pos;
			m_State.RawOrientation = rot;
			UpdateComponentPipeline();
			if (m_ComponentPipeline != null)
			{
				for (int i = 0; i < m_ComponentPipeline.Length; i++)
				{
					m_ComponentPipeline[i].ForceCameraPosition(pos, rot);
				}
			}
			base.ForceCameraPosition(pos, rot);
		}

		internal void SetStateRawPosition(Vector3 pos)
		{
			m_State.RawPosition = pos;
		}

		public override void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
		{
			base.OnTransitionFromCamera(fromCam, worldUp, deltaTime);
			InvokeOnTransitionInExtensions(fromCam, worldUp, deltaTime);
			bool flag = false;
			if (m_Transitions.m_InheritPosition && fromCam != null && !CinemachineCore.Instance.IsLiveInBlend(this))
			{
				ForceCameraPosition(fromCam.State.FinalPosition, fromCam.State.FinalOrientation);
			}
			UpdateComponentPipeline();
			if (m_ComponentPipeline != null)
			{
				for (int i = 0; i < m_ComponentPipeline.Length; i++)
				{
					if (m_ComponentPipeline[i].OnTransitionFromCamera(fromCam, worldUp, deltaTime, ref m_Transitions))
					{
						flag = true;
					}
				}
			}
			if (flag)
			{
				InternalUpdateCameraState(worldUp, deltaTime);
				InternalUpdateCameraState(worldUp, deltaTime);
			}
			else
			{
				UpdateCameraState(worldUp, deltaTime);
			}
			if (m_Transitions.m_OnCameraLive != null)
			{
				m_Transitions.m_OnCameraLive.Invoke(this, fromCam);
			}
		}

		internal override bool RequiresUserInput()
		{
			if (base.RequiresUserInput())
			{
				return true;
			}
			if (m_ComponentPipeline != null)
			{
				return m_ComponentPipeline.Any((CinemachineComponentBase c) => c != null && c.RequiresUserInput);
			}
			return false;
		}

		internal override void OnBeforeSerialize()
		{
			if (!m_Lens.IsPhysicalCamera)
			{
				m_Lens.SensorSize = Vector2.one;
			}
		}
	}
	[AddComponentMenu("")]
	[SaveDuringPlay]
	public class Cinemachine3rdPersonFollow : CinemachineComponentBase
	{
		[Tooltip("How responsively the camera tracks the target.  Each axis (camera-local) can have its own setting.  Value is the approximate time it takes the camera to catch up to the target's new position.  Smaller values give a more rigid effect, larger values give a squishier one")]
		public Vector3 Damping;

		[Header("Rig")]
		[Tooltip("Position of the shoulder pivot relative to the Follow target origin.  This offset is in target-local space")]
		public Vector3 ShoulderOffset;

		[Tooltip("Vertical offset of the hand in relation to the shoulder.  Arm length will affect the follow target's screen position when the camera rotates vertically")]
		public float VerticalArmLength;

		[Tooltip("Specifies which shoulder (left, right, or in-between) the camera is on")]
		[Range(0f, 1f)]
		public float CameraSide;

		[Tooltip("How far behind the hand the camera will be placed")]
		public float CameraDistance;

		[Header("Obstacles")]
		[Tooltip("Camera will avoid obstacles on these layers")]
		public LayerMask CameraCollisionFilter;

		[TagField]
		[Tooltip("Obstacles with this tag will be ignored.  It is a good idea to set this field to the target's tag")]
		public string IgnoreTag = string.Empty;

		[Tooltip("Specifies how close the camera can get to obstacles")]
		[Range(0f, 1f)]
		public float CameraRadius;

		[Range(0f, 10f)]
		[Tooltip("How gradually the camera moves to correct for occlusions.  Higher numbers will move the camera more gradually.")]
		public float DampingIntoCollision;

		[Range(0f, 10f)]
		[Tooltip("How gradually the camera returns to its normal position after having been corrected by the built-in collision resolution system.  Higher numbers will move the camera more gradually back to normal.")]
		public float DampingFromCollision;

		private Vector3 m_PreviousFollowTargetPosition;

		private Vector3 m_DampingCorrection;

		private float m_CamPosCollisionCorrection;

		public override bool IsValid
		{
			get
			{
				if (base.enabled)
				{
					return base.FollowTarget != null;
				}
				return false;
			}
		}

		public override CinemachineCore.Stage Stage => CinemachineCore.Stage.Body;

		private void OnValidate()
		{
			CameraSide = Mathf.Clamp(CameraSide, -1f, 1f);
			Damping.x = Mathf.Max(0f, Damping.x);
			Damping.y = Mathf.Max(0f, Damping.y);
			Damping.z = Mathf.Max(0f, Damping.z);
			CameraRadius = Mathf.Max(0.001f, CameraRadius);
			DampingIntoCollision = Mathf.Max(0f, DampingIntoCollision);
			DampingFromCollision = Mathf.Max(0f, DampingFromCollision);
		}

		private void Reset()
		{
			ShoulderOffset = new Vector3(0.5f, -0.4f, 0f);
			VerticalArmLength = 0.4f;
			CameraSide = 1f;
			CameraDistance = 2f;
			Damping = new Vector3(0.1f, 0.5f, 0.3f);
			CameraCollisionFilter = 0;
			CameraRadius = 0.2f;
			DampingIntoCollision = 0f;
			DampingFromCollision = 2f;
		}

		private void OnDestroy()
		{
			RuntimeUtility.DestroyScratchCollider();
		}

		public override float GetMaxDampTime()
		{
			return Mathf.Max(Mathf.Max(DampingIntoCollision, DampingFromCollision), Mathf.Max(Damping.x, Mathf.Max(Damping.y, Damping.z)));
		}

		public override void MutateCameraState(ref CameraState curState, float deltaTime)
		{
			if (IsValid)
			{
				if (!base.VirtualCamera.PreviousStateIsValid)
				{
					deltaTime = -1f;
				}
				PositionCamera(ref curState, deltaTime);
			}
		}

		public override void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
			base.OnTargetObjectWarped(target, positionDelta);
			if (target == base.FollowTarget)
			{
				m_PreviousFollowTargetPosition += positionDelta;
			}
		}

		private void PositionCamera(ref CameraState curState, float deltaTime)
		{
			Vector3 referenceUp = curState.ReferenceUp;
			Vector3 followTargetPosition = base.FollowTargetPosition;
			Quaternion followTargetRotation = base.FollowTargetRotation;
			Vector3 vector = followTargetRotation * Vector3.forward;
			Quaternion heading = GetHeading(followTargetRotation, referenceUp);
			if (deltaTime < 0f)
			{
				m_DampingCorrection = Vector3.zero;
				m_CamPosCollisionCorrection = 0f;
			}
			else
			{
				m_DampingCorrection += Quaternion.Inverse(heading) * (m_PreviousFollowTargetPosition - followTargetPosition);
				m_DampingCorrection -= base.VirtualCamera.DetachedFollowTargetDamp(m_DampingCorrection, Damping, deltaTime);
			}
			m_PreviousFollowTargetPosition = followTargetPosition;
			Vector3 root = followTargetPosition;
			GetRawRigPositions(root, followTargetRotation, heading, out var _, out var hand);
			Vector3 tip = hand - vector * (CameraDistance - m_DampingCorrection.z);
			float collisionCorrection = 0f;
			Vector3 root2 = ResolveCollisions(root, hand, -1f, CameraRadius * 1.05f, ref collisionCorrection);
			tip = ResolveCollisions(root2, tip, deltaTime, CameraRadius, ref m_CamPosCollisionCorrection);
			curState.RawPosition = tip;
			curState.RawOrientation = followTargetRotation;
		}

		public void GetRigPositions(out Vector3 root, out Vector3 shoulder, out Vector3 hand)
		{
			Vector3 referenceUp = base.VirtualCamera.State.ReferenceUp;
			Quaternion followTargetRotation = base.FollowTargetRotation;
			Quaternion heading = GetHeading(followTargetRotation, referenceUp);
			root = m_PreviousFollowTargetPosition;
			GetRawRigPositions(root, followTargetRotation, heading, out shoulder, out hand);
			float collisionCorrection = 0f;
			hand = ResolveCollisions(root, hand, -1f, CameraRadius * 1.05f, ref collisionCorrection);
		}

		internal static Quaternion GetHeading(Quaternion targetRot, Vector3 up)
		{
			Vector3 vector = targetRot * Vector3.forward;
			Vector3 vector2 = Vector3.Cross(up, Vector3.Cross(vector.ProjectOntoPlane(up), up));
			if (vector2.AlmostZero())
			{
				vector2 = Vector3.Cross(targetRot * Vector3.right, up);
			}
			return Quaternion.LookRotation(vector2, up);
		}

		private void GetRawRigPositions(Vector3 root, Quaternion targetRot, Quaternion heading, out Vector3 shoulder, out Vector3 hand)
		{
			Vector3 shoulderOffset = ShoulderOffset;
			shoulderOffset.x = Mathf.Lerp(0f - shoulderOffset.x, shoulderOffset.x, CameraSide);
			shoulderOffset.x += m_DampingCorrection.x;
			shoulderOffset.y += m_DampingCorrection.y;
			shoulder = root + heading * shoulderOffset;
			hand = shoulder + targetRot * new Vector3(0f, VerticalArmLength, 0f);
		}

		private Vector3 ResolveCollisions(Vector3 root, Vector3 tip, float deltaTime, float cameraRadius, ref float collisionCorrection)
		{
			if (CameraCollisionFilter.value == 0)
			{
				return tip;
			}
			Vector3 vector = tip - root;
			float magnitude = vector.magnitude;
			if (magnitude < 0.0001f)
			{
				return tip;
			}
			vector /= magnitude;
			Vector3 result = tip;
			float num = 0f;
			if (RuntimeUtility.SphereCastIgnoreTag(root, cameraRadius, vector, out var hitInfo, magnitude, CameraCollisionFilter, in IgnoreTag))
			{
				num = (hitInfo.point + hitInfo.normal * cameraRadius - tip).magnitude;
			}
			collisionCorrection += ((deltaTime < 0f) ? (num - collisionCorrection) : Damper.Damp(num - collisionCorrection, (num > collisionCorrection) ? DampingIntoCollision : DampingFromCollision, deltaTime));
			if (collisionCorrection > 0.0001f)
			{
				result -= vector * collisionCorrection;
			}
			return result;
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("")]
	[SaveDuringPlay]
	public class CinemachineBasicMultiChannelPerlin : CinemachineComponentBase
	{
		[Tooltip("The asset containing the Noise Profile.  Define the frequencies and amplitudes there to make a characteristic noise profile.  Make your own or just use one of the many presets.")]
		[FormerlySerializedAs("m_Definition")]
		[NoiseSettingsProperty]
		public NoiseSettings m_NoiseProfile;

		[Tooltip("When rotating the camera, offset the camera's pivot position by this much (camera space)")]
		public Vector3 m_PivotOffset = Vector3.zero;

		[Tooltip("Gain to apply to the amplitudes defined in the NoiseSettings asset.  1 is normal.  Setting this to 0 completely mutes the noise.")]
		public float m_AmplitudeGain = 1f;

		[Tooltip("Scale factor to apply to the frequencies defined in the NoiseSettings asset.  1 is normal.  Larger magnitudes will make the noise shake more rapidly.")]
		public float m_FrequencyGain = 1f;

		private bool mInitialized;

		private float mNoiseTime;

		[SerializeField]
		[HideInInspector]
		private Vector3 mNoiseOffsets = Vector3.zero;

		public override bool IsValid
		{
			get
			{
				if (base.enabled)
				{
					return m_NoiseProfile != null;
				}
				return false;
			}
		}

		public override CinemachineCore.Stage Stage => CinemachineCore.Stage.Noise;

		public override void MutateCameraState(ref CameraState curState, float deltaTime)
		{
			if (!IsValid || deltaTime < 0f)
			{
				mInitialized = false;
				return;
			}
			if (!mInitialized)
			{
				Initialize();
			}
			if (TargetPositionCache.CacheMode == TargetPositionCache.Mode.Playback && TargetPositionCache.HasCurrentTime)
			{
				mNoiseTime = TargetPositionCache.CurrentTime * m_FrequencyGain;
			}
			else
			{
				mNoiseTime += deltaTime * m_FrequencyGain;
			}
			curState.PositionCorrection += curState.CorrectedOrientation * NoiseSettings.GetCombinedFilterResults(m_NoiseProfile.PositionNoise, mNoiseTime, mNoiseOffsets) * m_AmplitudeGain;
			Quaternion quaternion = Quaternion.Euler(NoiseSettings.GetCombinedFilterResults(m_NoiseProfile.OrientationNoise, mNoiseTime, mNoiseOffsets) * m_AmplitudeGain);
			if (m_PivotOffset != Vector3.zero)
			{
				Matrix4x4 matrix4x = Matrix4x4.Translate(-m_PivotOffset);
				matrix4x = Matrix4x4.Rotate(quaternion) * matrix4x;
				matrix4x = Matrix4x4.Translate(m_PivotOffset) * matrix4x;
				curState.PositionCorrection += curState.CorrectedOrientation * matrix4x.MultiplyPoint(Vector3.zero);
			}
			curState.OrientationCorrection *= quaternion;
		}

		public void ReSeed()
		{
			mNoiseOffsets = new Vector3(UnityEngine.Random.Range(-1000f, 1000f), UnityEngine.Random.Range(-1000f, 1000f), UnityEngine.Random.Range(-1000f, 1000f));
		}

		private void Initialize()
		{
			mInitialized = true;
			mNoiseTime = CinemachineCore.CurrentTime * m_FrequencyGain;
			if (mNoiseOffsets == Vector3.zero)
			{
				ReSeed();
			}
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("")]
	[SaveDuringPlay]
	public class CinemachineComposer : CinemachineComponentBase
	{
		private struct FovCache
		{
			public Rect mFovSoftGuideRect;

			public Rect mFovHardGuideRect;

			public float mFovH;

			public float mFov;

			private float mOrthoSizeOverDistance;

			private float mAspect;

			private Rect mSoftGuideRect;

			private Rect mHardGuideRect;

			public void UpdateCache(LensSettings lens, Rect softGuide, Rect hardGuide, float targetDistance)
			{
				bool flag = mAspect != lens.Aspect || softGuide != mSoftGuideRect || hardGuide != mHardGuideRect;
				if (lens.Orthographic)
				{
					float num = Mathf.Abs(lens.OrthographicSize / targetDistance);
					if (mOrthoSizeOverDistance == 0f || Mathf.Abs(num - mOrthoSizeOverDistance) / mOrthoSizeOverDistance > mOrthoSizeOverDistance * 0.01f)
					{
						flag = true;
					}
					if (flag)
					{
						mFov = 114.59156f * Mathf.Atan(num);
						mFovH = 114.59156f * Mathf.Atan(lens.Aspect * num);
						mOrthoSizeOverDistance = num;
					}
				}
				else
				{
					float fieldOfView = lens.FieldOfView;
					if (mFov != fieldOfView)
					{
						flag = true;
					}
					if (flag)
					{
						mFov = fieldOfView;
						double num2 = 2.0 * Math.Atan(Math.Tan(mFov * (MathF.PI / 180f) / 2f) * (double)lens.Aspect);
						mFovH = (float)(57.295780181884766 * num2);
						mOrthoSizeOverDistance = 0f;
					}
				}
				if (flag)
				{
					mFovSoftGuideRect = ScreenToFOV(softGuide, mFov, mFovH, lens.Aspect);
					mSoftGuideRect = softGuide;
					mFovHardGuideRect = ScreenToFOV(hardGuide, mFov, mFovH, lens.Aspect);
					mHardGuideRect = hardGuide;
					mAspect = lens.Aspect;
				}
			}

			private Rect ScreenToFOV(Rect rScreen, float fov, float fovH, float aspect)
			{
				Rect result = new Rect(rScreen);
				Matrix4x4 inverse = Matrix4x4.Perspective(fov, aspect, 0.0001f, 2f).inverse;
				Vector3 v = inverse.MultiplyPoint(new Vector3(0f, result.yMin * 2f - 1f, 0.5f));
				v.z = 0f - v.z;
				float num = UnityVectorExtensions.SignedAngle(Vector3.forward, v, Vector3.left);
				result.yMin = (fov / 2f + num) / fov;
				v = inverse.MultiplyPoint(new Vector3(0f, result.yMax * 2f - 1f, 0.5f));
				v.z = 0f - v.z;
				num = UnityVectorExtensions.SignedAngle(Vector3.forward, v, Vector3.left);
				result.yMax = (fov / 2f + num) / fov;
				v = inverse.MultiplyPoint(new Vector3(result.xMin * 2f - 1f, 0f, 0.5f));
				v.z = 0f - v.z;
				num = UnityVectorExtensions.SignedAngle(Vector3.forward, v, Vector3.up);
				result.xMin = (fovH / 2f + num) / fovH;
				v = inverse.MultiplyPoint(new Vector3(result.xMax * 2f - 1f, 0f, 0.5f));
				v.z = 0f - v.z;
				num = UnityVectorExtensions.SignedAngle(Vector3.forward, v, Vector3.up);
				result.xMax = (fovH / 2f + num) / fovH;
				return result;
			}
		}

		[Tooltip("Target offset from the target object's center in target-local space. Use this to fine-tune the tracking target position when the desired area is not the tracked object's center.")]
		public Vector3 m_TrackedObjectOffset = Vector3.zero;

		[Space]
		[Tooltip("This setting will instruct the composer to adjust its target offset based on the motion of the target.  The composer will look at a point where it estimates the target will be this many seconds into the future.  Note that this setting is sensitive to noisy animation, and can amplify the noise, resulting in undesirable camera jitter.  If the camera jitters unacceptably when the target is in motion, turn down this setting, or animate the target more smoothly.")]
		[Range(0f, 1f)]
		public float m_LookaheadTime;

		[Tooltip("Controls the smoothness of the lookahead algorithm.  Larger values smooth out jittery predictions and also increase prediction lag")]
		[Range(0f, 30f)]
		public float m_LookaheadSmoothing;

		[Tooltip("If checked, movement along the Y axis will be ignored for lookahead calculations")]
		public bool m_LookaheadIgnoreY;

		[Space]
		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to follow the target in the screen-horizontal direction. Small numbers are more responsive, rapidly orienting the camera to keep the target in the dead zone. Larger numbers give a more heavy slowly responding camera. Using different vertical and horizontal settings can yield a wide range of camera behaviors.")]
		public float m_HorizontalDamping = 0.5f;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to follow the target in the screen-vertical direction. Small numbers are more responsive, rapidly orienting the camera to keep the target in the dead zone. Larger numbers give a more heavy slowly responding camera. Using different vertical and horizontal settings can yield a wide range of camera behaviors.")]
		public float m_VerticalDamping = 0.5f;

		[Space]
		[Range(-0.5f, 1.5f)]
		[Tooltip("Horizontal screen position for target. The camera will rotate to position the tracked object here.")]
		public float m_ScreenX = 0.5f;

		[Range(-0.5f, 1.5f)]
		[Tooltip("Vertical screen position for target, The camera will rotate to position the tracked object here.")]
		public float m_ScreenY = 0.5f;

		[Range(0f, 2f)]
		[Tooltip("Camera will not rotate horizontally if the target is within this range of the position.")]
		public float m_DeadZoneWidth;

		[Range(0f, 2f)]
		[Tooltip("Camera will not rotate vertically if the target is within this range of the position.")]
		public float m_DeadZoneHeight;

		[Range(0f, 2f)]
		[Tooltip("When target is within this region, camera will gradually rotate horizontally to re-align towards the desired position, depending on the damping speed.")]
		public float m_SoftZoneWidth = 0.8f;

		[Range(0f, 2f)]
		[Tooltip("When target is within this region, camera will gradually rotate vertically to re-align towards the desired position, depending on the damping speed.")]
		public float m_SoftZoneHeight = 0.8f;

		[Range(-0.5f, 0.5f)]
		[Tooltip("A non-zero bias will move the target position horizontally away from the center of the soft zone.")]
		public float m_BiasX;

		[Range(-0.5f, 0.5f)]
		[Tooltip("A non-zero bias will move the target position vertically away from the center of the soft zone.")]
		public float m_BiasY;

		[Tooltip("Force target to center of screen when this camera activates.  If false, will clamp target to the edges of the dead zone")]
		public bool m_CenterOnActivate = true;

		private Vector3 m_CameraPosPrevFrame = Vector3.zero;

		private Vector3 m_LookAtPrevFrame = Vector3.zero;

		private Vector2 m_ScreenOffsetPrevFrame = Vector2.zero;

		private Quaternion m_CameraOrientationPrevFrame = Quaternion.identity;

		internal PositionPredictor m_Predictor = new PositionPredictor();

		private FovCache mCache;

		public override bool IsValid
		{
			get
			{
				if (base.enabled)
				{
					return base.LookAtTarget != null;
				}
				return false;
			}
		}

		public override CinemachineCore.Stage Stage => CinemachineCore.Stage.Aim;

		public Vector3 TrackedPoint { get; private set; }

		internal Rect SoftGuideRect
		{
			get
			{
				return new Rect(m_ScreenX - m_DeadZoneWidth / 2f, m_ScreenY - m_DeadZoneHeight / 2f, m_DeadZoneWidth, m_DeadZoneHeight);
			}
			set
			{
				m_DeadZoneWidth = Mathf.Clamp(value.width, 0f, 2f);
				m_DeadZoneHeight = Mathf.Clamp(value.height, 0f, 2f);
				m_ScreenX = Mathf.Clamp(value.x + m_DeadZoneWidth / 2f, -0.5f, 1.5f);
				m_ScreenY = Mathf.Clamp(value.y + m_DeadZoneHeight / 2f, -0.5f, 1.5f);
				m_SoftZoneWidth = Mathf.Max(m_SoftZoneWidth, m_DeadZoneWidth);
				m_SoftZoneHeight = Mathf.Max(m_SoftZoneHeight, m_DeadZoneHeight);
			}
		}

		internal Rect HardGuideRect
		{
			get
			{
				Rect result = new Rect(m_ScreenX - m_SoftZoneWidth / 2f, m_ScreenY - m_SoftZoneHeight / 2f, m_SoftZoneWidth, m_SoftZoneHeight);
				result.position += new Vector2(m_BiasX * (m_SoftZoneWidth - m_DeadZoneWidth), m_BiasY * (m_SoftZoneHeight - m_DeadZoneHeight));
				return result;
			}
			set
			{
				m_SoftZoneWidth = Mathf.Clamp(value.width, 0f, 2f);
				m_SoftZoneHeight = Mathf.Clamp(value.height, 0f, 2f);
				m_DeadZoneWidth = Mathf.Min(m_DeadZoneWidth, m_SoftZoneWidth);
				m_DeadZoneHeight = Mathf.Min(m_DeadZoneHeight, m_SoftZoneHeight);
			}
		}

		protected virtual Vector3 GetLookAtPointAndSetTrackedPoint(Vector3 lookAt, Vector3 up, float deltaTime)
		{
			Vector3 vector = lookAt;
			if (base.LookAtTarget != null)
			{
				vector += base.LookAtTargetRotation * m_TrackedObjectOffset;
			}
			if (m_LookaheadTime < 0.0001f)
			{
				TrackedPoint = vector;
			}
			else
			{
				bool flag = base.VirtualCamera.LookAtTargetChanged || !base.VirtualCamera.PreviousStateIsValid;
				m_Predictor.Smoothing = m_LookaheadSmoothing;
				m_Predictor.AddPosition(vector, flag ? (-1f) : deltaTime, m_LookaheadTime);
				Vector3 vector2 = m_Predictor.PredictPositionDelta(m_LookaheadTime);
				if (m_LookaheadIgnoreY)
				{
					vector2 = vector2.ProjectOntoPlane(up);
				}
				TrackedPoint = vector + vector2;
			}
			return vector;
		}

		public override void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
			base.OnTargetObjectWarped(target, positionDelta);
			if (target == base.LookAtTarget)
			{
				m_CameraPosPrevFrame += positionDelta;
				m_LookAtPrevFrame += positionDelta;
				m_Predictor.ApplyTransformDelta(positionDelta);
			}
		}

		public override void ForceCameraPosition(Vector3 pos, Quaternion rot)
		{
			base.ForceCameraPosition(pos, rot);
			m_CameraPosPrevFrame = pos;
			m_CameraOrientationPrevFrame = rot;
		}

		public override float GetMaxDampTime()
		{
			return Mathf.Max(m_HorizontalDamping, m_VerticalDamping);
		}

		public override void PrePipelineMutateCameraState(ref CameraState curState, float deltaTime)
		{
			if (IsValid && curState.HasLookAt)
			{
				curState.ReferenceLookAt = GetLookAtPointAndSetTrackedPoint(curState.ReferenceLookAt, curState.ReferenceUp, deltaTime);
			}
		}

		public override void MutateCameraState(ref CameraState curState, float deltaTime)
		{
			if (!IsValid || !curState.HasLookAt)
			{
				return;
			}
			if (!(TrackedPoint - curState.ReferenceLookAt).AlmostZero())
			{
				Vector3 vector = Vector3.Lerp(curState.CorrectedPosition, curState.ReferenceLookAt, 0.5f);
				Vector3 lhs = curState.ReferenceLookAt - vector;
				Vector3 rhs = TrackedPoint - vector;
				if (Vector3.Dot(lhs, rhs) < 0f)
				{
					float t = Vector3.Distance(curState.ReferenceLookAt, vector) / Vector3.Distance(curState.ReferenceLookAt, TrackedPoint);
					TrackedPoint = Vector3.Lerp(curState.ReferenceLookAt, TrackedPoint, t);
				}
			}
			float magnitude = (TrackedPoint - curState.CorrectedPosition).magnitude;
			if (magnitude < 0.0001f)
			{
				if (deltaTime >= 0f && base.VirtualCamera.PreviousStateIsValid)
				{
					curState.RawOrientation = m_CameraOrientationPrevFrame;
				}
				return;
			}
			mCache.UpdateCache(curState.Lens, SoftGuideRect, HardGuideRect, magnitude);
			Quaternion rawOrientation = curState.RawOrientation;
			if (deltaTime < 0f || !base.VirtualCamera.PreviousStateIsValid)
			{
				rawOrientation = Quaternion.LookRotation(rawOrientation * Vector3.forward, curState.ReferenceUp);
				Rect screenRect = mCache.mFovSoftGuideRect;
				if (m_CenterOnActivate)
				{
					screenRect = new Rect(screenRect.center, Vector2.zero);
				}
				RotateToScreenBounds(ref curState, screenRect, curState.ReferenceLookAt, ref rawOrientation, mCache.mFov, mCache.mFovH, -1f);
			}
			else
			{
				Vector3 vector2 = m_LookAtPrevFrame - m_CameraPosPrevFrame;
				if (vector2.AlmostZero())
				{
					rawOrientation = Quaternion.LookRotation(m_CameraOrientationPrevFrame * Vector3.forward, curState.ReferenceUp);
				}
				else
				{
					vector2 = Quaternion.Euler(curState.PositionDampingBypass) * vector2;
					rawOrientation = Quaternion.LookRotation(vector2, curState.ReferenceUp);
					rawOrientation = rawOrientation.ApplyCameraRotation(-m_ScreenOffsetPrevFrame, curState.ReferenceUp);
				}
				RotateToScreenBounds(ref curState, mCache.mFovSoftGuideRect, TrackedPoint, ref rawOrientation, mCache.mFov, mCache.mFovH, deltaTime);
				if (deltaTime < 0f || base.VirtualCamera.LookAtTargetAttachment > 0.9999f)
				{
					RotateToScreenBounds(ref curState, mCache.mFovHardGuideRect, curState.ReferenceLookAt, ref rawOrientation, mCache.mFov, mCache.mFovH, -1f);
				}
			}
			m_CameraPosPrevFrame = curState.CorrectedPosition;
			m_LookAtPrevFrame = TrackedPoint;
			m_CameraOrientationPrevFrame = rawOrientation.Normalized();
			m_ScreenOffsetPrevFrame = m_CameraOrientationPrevFrame.GetCameraRotationToTarget(m_LookAtPrevFrame - curState.CorrectedPosition, curState.ReferenceUp);
			curState.RawOrientation = m_CameraOrientationPrevFrame;
		}

		private void RotateToScreenBounds(ref CameraState state, Rect screenRect, Vector3 trackedPoint, ref Quaternion rigOrientation, float fov, float fovH, float deltaTime)
		{
			Vector3 vector = trackedPoint - state.CorrectedPosition;
			Vector2 cameraRotationToTarget = rigOrientation.GetCameraRotationToTarget(vector, state.ReferenceUp);
			ClampVerticalBounds(ref screenRect, vector, state.ReferenceUp, fov);
			float num = (screenRect.yMin - 0.5f) * fov;
			float num2 = (screenRect.yMax - 0.5f) * fov;
			if (cameraRotationToTarget.x < num)
			{
				cameraRotationToTarget.x -= num;
			}
			else if (cameraRotationToTarget.x > num2)
			{
				cameraRotationToTarget.x -= num2;
			}
			else
			{
				cameraRotationToTarget.x = 0f;
			}
			num = (screenRect.xMin - 0.5f) * fovH;
			num2 = (screenRect.xMax - 0.5f) * fovH;
			if (cameraRotationToTarget.y < num)
			{
				cameraRotationToTarget.y -= num;
			}
			else if (cameraRotationToTarget.y > num2)
			{
				cameraRotationToTarget.y -= num2;
			}
			else
			{
				cameraRotationToTarget.y = 0f;
			}
			if (deltaTime >= 0f && base.VirtualCamera.PreviousStateIsValid)
			{
				cameraRotationToTarget.x = base.VirtualCamera.DetachedLookAtTargetDamp(cameraRotationToTarget.x, m_VerticalDamping, deltaTime);
				cameraRotationToTarget.y = base.VirtualCamera.DetachedLookAtTargetDamp(cameraRotationToTarget.y, m_HorizontalDamping, deltaTime);
			}
			rigOrientation = rigOrientation.ApplyCameraRotation(cameraRotationToTarget, state.ReferenceUp);
		}

		private bool ClampVerticalBounds(ref Rect r, Vector3 dir, Vector3 up, float fov)
		{
			float num = UnityVectorExtensions.Angle(dir, up);
			float num2 = fov / 2f + 1f;
			if (num < num2)
			{
				float num3 = 1f - (num2 - num) / fov;
				if (r.yMax > num3)
				{
					r.yMin = Mathf.Min(r.yMin, num3);
					r.yMax = Mathf.Min(r.yMax, num3);
					return true;
				}
			}
			if (num > 180f - num2)
			{
				float num4 = (num - (180f - num2)) / fov;
				if (num4 > r.yMin)
				{
					r.yMin = Mathf.Max(r.yMin, num4);
					r.yMax = Mathf.Max(r.yMax, num4);
					return true;
				}
			}
			return false;
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("")]
	[SaveDuringPlay]
	public class CinemachineFramingTransposer : CinemachineComponentBase
	{
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public enum FramingMode
		{
			Horizontal,
			Vertical,
			HorizontalAndVertical,
			None
		}

		public enum AdjustmentMode
		{
			ZoomOnly,
			DollyOnly,
			DollyThenZoom
		}

		[Tooltip("Offset from the Follow Target object (in target-local co-ordinates).  The camera will attempt to frame the point which is the target's position plus this offset.  Use it to correct for cases when the target's origin is not the point of interest for the camera.")]
		public Vector3 m_TrackedObjectOffset;

		[Tooltip("This setting will instruct the composer to adjust its target offset based on the motion of the target.  The composer will look at a point where it estimates the target will be this many seconds into the future.  Note that this setting is sensitive to noisy animation, and can amplify the noise, resulting in undesirable camera jitter.  If the camera jitters unacceptably when the target is in motion, turn down this setting, or animate the target more smoothly.")]
		[Range(0f, 1f)]
		[Space]
		public float m_LookaheadTime;

		[Tooltip("Controls the smoothness of the lookahead algorithm.  Larger values smooth out jittery predictions and also increase prediction lag")]
		[Range(0f, 30f)]
		public float m_LookaheadSmoothing;

		[Tooltip("If checked, movement along the Y axis will be ignored for lookahead calculations")]
		public bool m_LookaheadIgnoreY;

		[Space]
		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to maintain the offset in the X-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's x-axis offset.  Larger numbers give a more heavy slowly responding camera.  Using different settings per axis can yield a wide range of camera behaviors.")]
		public float m_XDamping = 1f;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to maintain the offset in the Y-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's y-axis offset.  Larger numbers give a more heavy slowly responding camera.  Using different settings per axis can yield a wide range of camera behaviors.")]
		public float m_YDamping = 1f;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to maintain the offset in the Z-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's z-axis offset.  Larger numbers give a more heavy slowly responding camera.  Using different settings per axis can yield a wide range of camera behaviors.")]
		public float m_ZDamping = 1f;

		[Tooltip("If set, damping will apply  only to target motion, but not to camera rotation changes.  Turn this on to get an instant response when the rotation changes.  ")]
		public bool m_TargetMovementOnly = true;

		[Space]
		[Range(-0.5f, 1.5f)]
		[Tooltip("Horizontal screen position for target. The camera will move to position the tracked object here.")]
		public float m_ScreenX = 0.5f;

		[Range(-0.5f, 1.5f)]
		[Tooltip("Vertical screen position for target, The camera will move to position the tracked object here.")]
		public float m_ScreenY = 0.5f;

		[Tooltip("The distance along the camera axis that will be maintained from the Follow target")]
		public float m_CameraDistance = 10f;

		[Space]
		[Range(0f, 2f)]
		[Tooltip("Camera will not move horizontally if the target is within this range of the position.")]
		public float m_DeadZoneWidth;

		[Range(0f, 2f)]
		[Tooltip("Camera will not move vertically if the target is within this range of the position.")]
		public float m_DeadZoneHeight;

		[Tooltip("The camera will not move along its z-axis if the Follow target is within this distance of the specified camera distance")]
		[FormerlySerializedAs("m_DistanceDeadZoneSize")]
		public float m_DeadZoneDepth;

		[Space]
		[Tooltip("If checked, then then soft zone will be unlimited in size.")]
		public bool m_UnlimitedSoftZone;

		[Range(0f, 2f)]
		[Tooltip("When target is within this region, camera will gradually move horizontally to re-align towards the desired position, depending on the damping speed.")]
		public float m_SoftZoneWidth = 0.8f;

		[Range(0f, 2f)]
		[Tooltip("When target is within this region, camera will gradually move vertically to re-align towards the desired position, depending on the damping speed.")]
		public float m_SoftZoneHeight = 0.8f;

		[Range(-0.5f, 0.5f)]
		[Tooltip("A non-zero bias will move the target position horizontally away from the center of the soft zone.")]
		public float m_BiasX;

		[Range(-0.5f, 0.5f)]
		[Tooltip("A non-zero bias will move the target position vertically away from the center of the soft zone.")]
		public float m_BiasY;

		[Tooltip("Force target to center of screen when this camera activates.  If false, will clamp target to the edges of the dead zone")]
		public bool m_CenterOnActivate = true;

		[Space]
		[Tooltip("What screen dimensions to consider when framing.  Can be Horizontal, Vertical, or both")]
		[FormerlySerializedAs("m_FramingMode")]
		public FramingMode m_GroupFramingMode = FramingMode.HorizontalAndVertical;

		[Tooltip("How to adjust the camera to get the desired framing.  You can zoom, dolly in/out, or do both.")]
		public AdjustmentMode m_AdjustmentMode;

		[Tooltip("The bounding box of the targets should occupy this amount of the screen space.  1 means fill the whole screen.  0.5 means fill half the screen, etc.")]
		public float m_GroupFramingSize = 0.8f;

		[Tooltip("The maximum distance toward the target that this behaviour is allowed to move the camera.")]
		public float m_MaxDollyIn = 5000f;

		[Tooltip("The maximum distance away the target that this behaviour is allowed to move the camera.")]
		public float m_MaxDollyOut = 5000f;

		[Tooltip("Set this to limit how close to the target the camera can get.")]
		public float m_MinimumDistance = 1f;

		[Tooltip("Set this to limit how far from the target the camera can get.")]
		public float m_MaximumDistance = 5000f;

		[Range(1f, 179f)]
		[Tooltip("If adjusting FOV, will not set the FOV lower than this.")]
		public float m_MinimumFOV = 3f;

		[Range(1f, 179f)]
		[Tooltip("If adjusting FOV, will not set the FOV higher than this.")]
		public float m_MaximumFOV = 60f;

		[Tooltip("If adjusting Orthographic Size, will not set it lower than this.")]
		public float m_MinimumOrthoSize = 1f;

		[Tooltip("If adjusting Orthographic Size, will not set it higher than this.")]
		public float m_MaximumOrthoSize = 5000f;

		private const float kMinimumCameraDistance = 0.01f;

		private const float kMinimumGroupSize = 0.01f;

		private Vector3 m_PreviousCameraPosition = Vector3.zero;

		internal PositionPredictor m_Predictor = new PositionPredictor();

		private bool m_InheritingPosition;

		private float m_prevFOV;

		private Quaternion m_prevRotation;

		internal Rect SoftGuideRect
		{
			get
			{
				return new Rect(m_ScreenX - m_DeadZoneWidth / 2f, m_ScreenY - m_DeadZoneHeight / 2f, m_DeadZoneWidth, m_DeadZoneHeight);
			}
			set
			{
				m_DeadZoneWidth = Mathf.Clamp(value.width, 0f, 2f);
				m_DeadZoneHeight = Mathf.Clamp(value.height, 0f, 2f);
				m_ScreenX = Mathf.Clamp(value.x + m_DeadZoneWidth / 2f, -0.5f, 1.5f);
				m_ScreenY = Mathf.Clamp(value.y + m_DeadZoneHeight / 2f, -0.5f, 1.5f);
				m_SoftZoneWidth = Mathf.Max(m_SoftZoneWidth, m_DeadZoneWidth);
				m_SoftZoneHeight = Mathf.Max(m_SoftZoneHeight, m_DeadZoneHeight);
			}
		}

		internal Rect HardGuideRect
		{
			get
			{
				Rect result = new Rect(m_ScreenX - m_SoftZoneWidth / 2f, m_ScreenY - m_SoftZoneHeight / 2f, m_SoftZoneWidth, m_SoftZoneHeight);
				result.position += new Vector2(m_BiasX * (m_SoftZoneWidth - m_DeadZoneWidth), m_BiasY * (m_SoftZoneHeight - m_DeadZoneHeight));
				return result;
			}
			set
			{
				m_SoftZoneWidth = Mathf.Clamp(value.width, 0f, 2f);
				m_SoftZoneHeight = Mathf.Clamp(value.height, 0f, 2f);
				m_DeadZoneWidth = Mathf.Min(m_DeadZoneWidth, m_SoftZoneWidth);
				m_DeadZoneHeight = Mathf.Min(m_DeadZoneHeight, m_SoftZoneHeight);
			}
		}

		public override bool IsValid
		{
			get
			{
				if (base.enabled)
				{
					return base.FollowTarget != null;
				}
				return false;
			}
		}

		public override CinemachineCore.Stage Stage => CinemachineCore.Stage.Body;

		public override bool BodyAppliesAfterAim => true;

		public Vector3 TrackedPoint { get; private set; }

		public Bounds LastBounds { get; private set; }

		public Matrix4x4 LastBoundsMatrix { get; private set; }

		private void OnValidate()
		{
			m_CameraDistance = Mathf.Max(m_CameraDistance, 0.01f);
			m_DeadZoneDepth = Mathf.Max(m_DeadZoneDepth, 0f);
			m_GroupFramingSize = Mathf.Max(0.001f, m_GroupFramingSize);
			m_MaxDollyIn = Mathf.Max(0f, m_MaxDollyIn);
			m_MaxDollyOut = Mathf.Max(0f, m_MaxDollyOut);
			m_MinimumDistance = Mathf.Max(0f, m_MinimumDistance);
			m_MaximumDistance = Mathf.Max(m_MinimumDistance, m_MaximumDistance);
			m_MinimumFOV = Mathf.Max(1f, m_MinimumFOV);
			m_MaximumFOV = Mathf.Clamp(m_MaximumFOV, m_MinimumFOV, 179f);
			m_MinimumOrthoSize = Mathf.Max(0.01f, m_MinimumOrthoSize);
			m_MaximumOrthoSize = Mathf.Max(m_MinimumOrthoSize, m_MaximumOrthoSize);
		}

		public override void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
			base.OnTargetObjectWarped(target, positionDelta);
			if (target == base.FollowTarget)
			{
				m_PreviousCameraPosition += positionDelta;
				m_Predictor.ApplyTransformDelta(positionDelta);
			}
		}

		public override void ForceCameraPosition(Vector3 pos, Quaternion rot)
		{
			base.ForceCameraPosition(pos, rot);
			m_PreviousCameraPosition = pos;
			m_prevRotation = rot;
		}

		public override float GetMaxDampTime()
		{
			return Mathf.Max(m_XDamping, Mathf.Max(m_YDamping, m_ZDamping));
		}

		public override bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime, ref CinemachineVirtualCameraBase.TransitionParams transitionParams)
		{
			if (fromCam != null && transitionParams.m_InheritPosition && !CinemachineCore.Instance.IsLiveInBlend(base.VirtualCamera))
			{
				m_PreviousCameraPosition = fromCam.State.RawPosition;
				m_prevRotation = fromCam.State.RawOrientation;
				m_InheritingPosition = true;
				return true;
			}
			return false;
		}

		private Rect ScreenToOrtho(Rect rScreen, float orthoSize, float aspect)
		{
			return new Rect
			{
				yMax = 2f * orthoSize * (1f - rScreen.yMin - 0.5f),
				yMin = 2f * orthoSize * (1f - rScreen.yMax - 0.5f),
				xMin = 2f * orthoSize * aspect * (rScreen.xMin - 0.5f),
				xMax = 2f * orthoSize * aspect * (rScreen.xMax - 0.5f)
			};
		}

		private Vector3 OrthoOffsetToScreenBounds(Vector3 targetPos2D, Rect screenRect)
		{
			Vector3 zero = Vector3.zero;
			if (targetPos2D.x < screenRect.xMin)
			{
				zero.x += targetPos2D.x - screenRect.xMin;
			}
			if (targetPos2D.x > screenRect.xMax)
			{
				zero.x += targetPos2D.x - screenRect.xMax;
			}
			if (targetPos2D.y < screenRect.yMin)
			{
				zero.y += targetPos2D.y - screenRect.yMin;
			}
			if (targetPos2D.y > screenRect.yMax)
			{
				zero.y += targetPos2D.y - screenRect.yMax;
			}
			return zero;
		}

		public override void MutateCameraState(ref CameraState curState, float deltaTime)
		{
			LensSettings lens = curState.Lens;
			Vector3 vector = base.FollowTargetPosition + base.FollowTargetRotation * m_TrackedObjectOffset;
			bool flag = deltaTime >= 0f && base.VirtualCamera.PreviousStateIsValid;
			if (!flag || base.VirtualCamera.FollowTargetChanged)
			{
				m_Predictor.Reset();
			}
			if (!flag)
			{
				m_PreviousCameraPosition = curState.RawPosition;
				m_prevFOV = (lens.Orthographic ? lens.OrthographicSize : lens.FieldOfView);
				m_prevRotation = curState.RawOrientation;
				if (!m_InheritingPosition && m_CenterOnActivate)
				{
					m_PreviousCameraPosition = base.FollowTargetPosition + curState.RawOrientation * Vector3.back * m_CameraDistance;
				}
			}
			if (!IsValid)
			{
				m_InheritingPosition = false;
				return;
			}
			float fieldOfView = lens.FieldOfView;
			ICinemachineTargetGroup abstractFollowTargetGroup = base.AbstractFollowTargetGroup;
			bool flag2 = abstractFollowTargetGroup != null && m_GroupFramingMode != FramingMode.None && !abstractFollowTargetGroup.IsEmpty;
			if (flag2)
			{
				vector = ComputeGroupBounds(abstractFollowTargetGroup, ref curState);
			}
			TrackedPoint = vector;
			if (m_LookaheadTime > 0.0001f)
			{
				m_Predictor.Smoothing = m_LookaheadSmoothing;
				m_Predictor.AddPosition(vector, deltaTime, m_LookaheadTime);
				Vector3 vector2 = m_Predictor.PredictPositionDelta(m_LookaheadTime);
				if (m_LookaheadIgnoreY)
				{
					vector2 = vector2.ProjectOntoPlane(curState.ReferenceUp);
				}
				Vector3 trackedPoint = vector + vector2;
				if (flag2)
				{
					Bounds lastBounds = LastBounds;
					lastBounds.center += LastBoundsMatrix.MultiplyPoint3x4(vector2);
					LastBounds = lastBounds;
				}
				TrackedPoint = trackedPoint;
			}
			if (!curState.HasLookAt)
			{
				curState.ReferenceLookAt = vector;
			}
			float num = m_CameraDistance;
			bool orthographic = lens.Orthographic;
			float a = (flag2 ? GetTargetHeight(LastBounds.size / m_GroupFramingSize) : 0f);
			a = Mathf.Max(a, 0.01f);
			if (!orthographic && flag2)
			{
				float z = LastBounds.extents.z;
				float z2 = LastBounds.center.z;
				if (z2 > z)
				{
					a = Mathf.Lerp(0f, a, (z2 - z) / z2);
				}
				if (m_AdjustmentMode != AdjustmentMode.ZoomOnly)
				{
					num = a / (2f * Mathf.Tan(fieldOfView * (MathF.PI / 180f) / 2f));
					num = Mathf.Clamp(num, m_MinimumDistance, m_MaximumDistance);
					float value = num - m_CameraDistance;
					value = Mathf.Clamp(value, 0f - m_MaxDollyIn, m_MaxDollyOut);
					num = m_CameraDistance + value;
				}
			}
			Quaternion rawOrientation = curState.RawOrientation;
			if (flag && m_TargetMovementOnly)
			{
				Quaternion quaternion = rawOrientation * Quaternion.Inverse(m_prevRotation);
				m_PreviousCameraPosition = TrackedPoint + quaternion * (m_PreviousCameraPosition - TrackedPoint);
			}
			m_prevRotation = rawOrientation;
			if (flag2)
			{
				if (orthographic)
				{
					a = Mathf.Clamp(a / 2f, m_MinimumOrthoSize, m_MaximumOrthoSize);
					if (flag)
					{
						a = m_prevFOV + base.VirtualCamera.DetachedFollowTargetDamp(a - m_prevFOV, m_ZDamping, deltaTime);
					}
					m_prevFOV = a;
					lens.OrthographicSize = Mathf.Clamp(a, m_MinimumOrthoSize, m_MaximumOrthoSize);
					curState.Lens = lens;
				}
				else if (m_AdjustmentMode != AdjustmentMode.DollyOnly)
				{
					float z3 = (Quaternion.Inverse(curState.RawOrientation) * (vector - curState.RawPosition)).z;
					float value2 = 179f;
					if (z3 > 0.0001f)
					{
						value2 = 2f * Mathf.Atan(a / (2f * z3)) * 57.29578f;
					}
					value2 = Mathf.Clamp(value2, m_MinimumFOV, m_MaximumFOV);
					if (flag)
					{
						value2 = m_prevFOV + base.VirtualCamera.DetachedFollowTargetDamp(value2 - m_prevFOV, m_ZDamping, deltaTime);
					}
					m_prevFOV = value2;
					lens.FieldOfView = value2;
					curState.Lens = lens;
				}
			}
			Vector3 previousCameraPosition = m_PreviousCameraPosition;
			Quaternion quaternion2 = Quaternion.Inverse(rawOrientation);
			Vector3 vector3 = quaternion2 * previousCameraPosition;
			Vector3 vector4 = quaternion2 * TrackedPoint - vector3;
			Vector3 vector5 = vector4;
			Vector3 vector6 = Vector3.zero;
			float num2 = Mathf.Max(0.01f, num - m_DeadZoneDepth / 2f);
			float num3 = Mathf.Max(num2, num + m_DeadZoneDepth / 2f);
			float num4 = Mathf.Min(vector4.z, vector5.z);
			if (num4 < num2)
			{
				vector6.z = num4 - num2;
			}
			if (num4 > num3)
			{
				vector6.z = num4 - num3;
			}
			float orthoSize = (lens.Orthographic ? lens.OrthographicSize : (Mathf.Tan(0.5f * fieldOfView * (MathF.PI / 180f)) * (num4 - vector6.z)));
			Rect rect = ScreenToOrtho(SoftGuideRect, orthoSize, lens.Aspect);
			if (!flag)
			{
				Rect screenRect = rect;
				if (m_CenterOnActivate && !m_InheritingPosition)
				{
					screenRect = new Rect(screenRect.center, Vector2.zero);
				}
				vector6 += OrthoOffsetToScreenBounds(vector4, screenRect);
			}
			else
			{
				vector6 += OrthoOffsetToScreenBounds(vector4, rect);
				vector6 = base.VirtualCamera.DetachedFollowTargetDamp(vector6, new Vector3(m_XDamping, m_YDamping, m_ZDamping), deltaTime);
				if (!m_UnlimitedSoftZone && (deltaTime < 0f || base.VirtualCamera.FollowTargetAttachment > 0.9999f))
				{
					Rect screenRect2 = ScreenToOrtho(HardGuideRect, orthoSize, lens.Aspect);
					Vector3 vector7 = quaternion2 * vector - vector3;
					vector6 += OrthoOffsetToScreenBounds(vector7 - vector6, screenRect2);
				}
			}
			curState.RawPosition = rawOrientation * (vector3 + vector6);
			m_PreviousCameraPosition = curState.RawPosition;
			m_InheritingPosition = false;
		}

		private float GetTargetHeight(Vector2 boundsSize)
		{
			return m_GroupFramingMode switch
			{
				FramingMode.Horizontal => boundsSize.x / base.VcamState.Lens.Aspect, 
				FramingMode.Vertical => boundsSize.y, 
				_ => Mathf.Max(boundsSize.x / base.VcamState.Lens.Aspect, boundsSize.y), 
			};
		}

		private Vector3 ComputeGroupBounds(ICinemachineTargetGroup group, ref CameraState curState)
		{
			Vector3 rawPosition = curState.RawPosition;
			Vector3 vector = curState.RawOrientation * Vector3.forward;
			LastBoundsMatrix = Matrix4x4.TRS(rawPosition, curState.RawOrientation, Vector3.one);
			Bounds lastBounds = group.GetViewSpaceBoundingBox(LastBoundsMatrix);
			Vector3 vector2 = LastBoundsMatrix.MultiplyPoint3x4(lastBounds.center);
			float z = lastBounds.extents.z;
			if (!curState.Lens.Orthographic)
			{
				float z2 = (Quaternion.Inverse(curState.RawOrientation) * (vector2 - rawPosition)).z;
				rawPosition = vector2 - vector * (Mathf.Max(z2, z) + z);
				lastBounds = GetScreenSpaceGroupBoundingBox(group, ref rawPosition, curState.RawOrientation);
				LastBoundsMatrix = Matrix4x4.TRS(rawPosition, curState.RawOrientation, Vector3.one);
				vector2 = LastBoundsMatrix.MultiplyPoint3x4(lastBounds.center);
			}
			LastBounds = lastBounds;
			return vector2 - vector * z;
		}

		private static Bounds GetScreenSpaceGroupBoundingBox(ICinemachineTargetGroup group, ref Vector3 pos, Quaternion orientation)
		{
			Matrix4x4 observer = Matrix4x4.TRS(pos, orientation, Vector3.one);
			group.GetViewSpaceAngularBounds(observer, out var minAngles, out var maxAngles, out var zRange);
			Vector2 vector = (minAngles + maxAngles) / 2f;
			Quaternion quaternion = Quaternion.identity.ApplyCameraRotation(new Vector2(0f - vector.x, vector.y), Vector3.up);
			pos = quaternion * new Vector3(0f, 0f, (zRange.y + zRange.x) / 2f);
			pos.z = 0f;
			pos = observer.MultiplyPoint3x4(pos);
			observer = Matrix4x4.TRS(pos, orientation, Vector3.one);
			group.GetViewSpaceAngularBounds(observer, out minAngles, out maxAngles, out zRange);
			float num = zRange.y + zRange.x;
			Vector2 vector2 = new Vector2(89.5f, 89.5f);
			if (zRange.x > 0f)
			{
				vector2 = Vector2.Max(maxAngles, minAngles.Abs());
				vector2 = Vector2.Min(vector2, new Vector2(89.5f, 89.5f));
			}
			vector2 *= MathF.PI / 180f;
			return new Bounds(new Vector3(0f, 0f, num / 2f), new Vector3(Mathf.Tan(vector2.y) * num, Mathf.Tan(vector2.x) * num, zRange.y - zRange.x));
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("")]
	[SaveDuringPlay]
	public class CinemachineGroupComposer : CinemachineComposer
	{
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public enum FramingMode
		{
			Horizontal,
			Vertical,
			HorizontalAndVertical
		}

		public enum AdjustmentMode
		{
			ZoomOnly,
			DollyOnly,
			DollyThenZoom
		}

		[Space]
		[Tooltip("The bounding box of the targets should occupy this amount of the screen space.  1 means fill the whole screen.  0.5 means fill half the screen, etc.")]
		public float m_GroupFramingSize = 0.8f;

		[Tooltip("What screen dimensions to consider when framing.  Can be Horizontal, Vertical, or both")]
		public FramingMode m_FramingMode = FramingMode.HorizontalAndVertical;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to frame the group. Small numbers are more responsive, rapidly adjusting the camera to keep the group in the frame.  Larger numbers give a more heavy slowly responding camera.")]
		public float m_FrameDamping = 2f;

		[Tooltip("How to adjust the camera to get the desired framing.  You can zoom, dolly in/out, or do both.")]
		public AdjustmentMode m_AdjustmentMode;

		[Tooltip("The maximum distance toward the target that this behaviour is allowed to move the camera.")]
		public float m_MaxDollyIn = 5000f;

		[Tooltip("The maximum distance away the target that this behaviour is allowed to move the camera.")]
		public float m_MaxDollyOut = 5000f;

		[Tooltip("Set this to limit how close to the target the camera can get.")]
		public float m_MinimumDistance = 1f;

		[Tooltip("Set this to limit how far from the target the camera can get.")]
		public float m_MaximumDistance = 5000f;

		[Range(1f, 179f)]
		[Tooltip("If adjusting FOV, will not set the FOV lower than this.")]
		public float m_MinimumFOV = 3f;

		[Range(1f, 179f)]
		[Tooltip("If adjusting FOV, will not set the FOV higher than this.")]
		public float m_MaximumFOV = 60f;

		[Tooltip("If adjusting Orthographic Size, will not set it lower than this.")]
		public float m_MinimumOrthoSize = 1f;

		[Tooltip("If adjusting Orthographic Size, will not set it higher than this.")]
		public float m_MaximumOrthoSize = 5000f;

		private float m_prevFramingDistance;

		private float m_prevFOV;

		public Bounds LastBounds { get; private set; }

		public Matrix4x4 LastBoundsMatrix { get; private set; }

		private void OnValidate()
		{
			m_GroupFramingSize = Mathf.Max(0.001f, m_GroupFramingSize);
			m_MaxDollyIn = Mathf.Max(0f, m_MaxDollyIn);
			m_MaxDollyOut = Mathf.Max(0f, m_MaxDollyOut);
			m_MinimumDistance = Mathf.Max(0f, m_MinimumDistance);
			m_MaximumDistance = Mathf.Max(m_MinimumDistance, m_MaximumDistance);
			m_MinimumFOV = Mathf.Max(1f, m_MinimumFOV);
			m_MaximumFOV = Mathf.Clamp(m_MaximumFOV, m_MinimumFOV, 179f);
			m_MinimumOrthoSize = Mathf.Max(0.01f, m_MinimumOrthoSize);
			m_MaximumOrthoSize = Mathf.Max(m_MinimumOrthoSize, m_MaximumOrthoSize);
		}

		public override float GetMaxDampTime()
		{
			return Mathf.Max(base.GetMaxDampTime(), m_FrameDamping);
		}

		public override void MutateCameraState(ref CameraState curState, float deltaTime)
		{
			ICinemachineTargetGroup abstractLookAtTargetGroup = base.AbstractLookAtTargetGroup;
			if (abstractLookAtTargetGroup == null)
			{
				base.MutateCameraState(ref curState, deltaTime);
				return;
			}
			if (!IsValid || !curState.HasLookAt)
			{
				m_prevFramingDistance = 0f;
				m_prevFOV = 0f;
				return;
			}
			bool orthographic = curState.Lens.Orthographic;
			bool flag = !orthographic && m_AdjustmentMode != AdjustmentMode.ZoomOnly;
			Vector3 referenceUp = curState.ReferenceUp;
			Vector3 rawPosition = curState.RawPosition;
			Vector3 position = abstractLookAtTargetGroup.Sphere.position;
			Vector3 newFwd = position - rawPosition;
			float magnitude = newFwd.magnitude;
			if (magnitude < 0.0001f)
			{
				return;
			}
			newFwd /= magnitude;
			LastBoundsMatrix = Matrix4x4.TRS(rawPosition, Quaternion.LookRotation(newFwd, referenceUp), Vector3.one);
			Bounds viewSpaceBoundingBox;
			if (orthographic)
			{
				viewSpaceBoundingBox = abstractLookAtTargetGroup.GetViewSpaceBoundingBox(LastBoundsMatrix);
				position = LastBoundsMatrix.MultiplyPoint3x4(viewSpaceBoundingBox.center);
				newFwd = (position - rawPosition).normalized;
				LastBoundsMatrix = Matrix4x4.TRS(rawPosition, Quaternion.LookRotation(newFwd, referenceUp), Vector3.one);
				viewSpaceBoundingBox = (LastBounds = abstractLookAtTargetGroup.GetViewSpaceBoundingBox(LastBoundsMatrix));
			}
			else
			{
				viewSpaceBoundingBox = GetScreenSpaceGroupBoundingBox(abstractLookAtTargetGroup, LastBoundsMatrix, out newFwd);
				LastBoundsMatrix = Matrix4x4.TRS(rawPosition, Quaternion.LookRotation(newFwd, referenceUp), Vector3.one);
				LastBounds = viewSpaceBoundingBox;
				position = rawPosition + newFwd * viewSpaceBoundingBox.center.z;
			}
			float z = viewSpaceBoundingBox.extents.z;
			float num = GetTargetHeight(viewSpaceBoundingBox.size / m_GroupFramingSize);
			if (orthographic)
			{
				num = Mathf.Clamp(num / 2f, m_MinimumOrthoSize, m_MaximumOrthoSize);
				if (deltaTime >= 0f && base.VirtualCamera.PreviousStateIsValid)
				{
					num = m_prevFOV + base.VirtualCamera.DetachedLookAtTargetDamp(num - m_prevFOV, m_FrameDamping, deltaTime);
				}
				m_prevFOV = num;
				LensSettings lens = curState.Lens;
				lens.OrthographicSize = Mathf.Clamp(num, m_MinimumOrthoSize, m_MaximumOrthoSize);
				curState.Lens = lens;
			}
			else
			{
				float z2 = viewSpaceBoundingBox.center.z;
				if (z2 > z)
				{
					num = Mathf.Lerp(0f, num, (z2 - z) / z2);
				}
				if (flag)
				{
					float value = Mathf.Clamp(z + num / (2f * Mathf.Tan(curState.Lens.FieldOfView * (MathF.PI / 180f) / 2f)), z + m_MinimumDistance, z + m_MaximumDistance) - Vector3.Distance(curState.RawPosition, position);
					value = Mathf.Clamp(value, 0f - m_MaxDollyIn, m_MaxDollyOut);
					if (deltaTime >= 0f && base.VirtualCamera.PreviousStateIsValid)
					{
						float initial = value - m_prevFramingDistance;
						initial = base.VirtualCamera.DetachedLookAtTargetDamp(initial, m_FrameDamping, deltaTime);
						value = m_prevFramingDistance + initial;
					}
					m_prevFramingDistance = value;
					curState.PositionCorrection -= newFwd * value;
					rawPosition -= newFwd * value;
				}
				if (m_AdjustmentMode != AdjustmentMode.DollyOnly)
				{
					float num2 = (position - rawPosition).magnitude - z;
					float value2 = 179f;
					if (num2 > 0.0001f)
					{
						value2 = 2f * Mathf.Atan(num / (2f * num2)) * 57.29578f;
					}
					value2 = Mathf.Clamp(value2, m_MinimumFOV, m_MaximumFOV);
					if (deltaTime >= 0f && m_prevFOV != 0f && base.VirtualCamera.PreviousStateIsValid)
					{
						value2 = m_prevFOV + base.VirtualCamera.DetachedLookAtTargetDamp(value2 - m_prevFOV, m_FrameDamping, deltaTime);
					}
					m_prevFOV = value2;
					LensSettings lens2 = curState.Lens;
					lens2.FieldOfView = value2;
					curState.Lens = lens2;
				}
			}
			curState.ReferenceLookAt = GetLookAtPointAndSetTrackedPoint(position, curState.ReferenceUp, deltaTime);
			base.MutateCameraState(ref curState, deltaTime);
		}

		private float GetTargetHeight(Vector2 boundsSize)
		{
			return m_FramingMode switch
			{
				FramingMode.Horizontal => Mathf.Max(0.0001f, boundsSize.x) / base.VcamState.Lens.Aspect, 
				FramingMode.Vertical => Mathf.Max(0.0001f, boundsSize.y), 
				_ => Mathf.Max(Mathf.Max(0.0001f, boundsSize.x) / base.VcamState.Lens.Aspect, Mathf.Max(0.0001f, boundsSize.y)), 
			};
		}

		private static Bounds GetScreenSpaceGroupBoundingBox(ICinemachineTargetGroup group, Matrix4x4 observer, out Vector3 newFwd)
		{
			group.GetViewSpaceAngularBounds(observer, out var minAngles, out var maxAngles, out var zRange);
			Vector2 vector = (minAngles + maxAngles) / 2f;
			newFwd = Quaternion.identity.ApplyCameraRotation(new Vector2(0f - vector.x, vector.y), Vector3.up) * Vector3.forward;
			newFwd = observer.MultiplyVector(newFwd);
			float num = zRange.y + zRange.x;
			Vector2 vector2 = Vector2.Min(maxAngles - vector, new Vector2(89.5f, 89.5f)) * (MathF.PI / 180f);
			return new Bounds(new Vector3(0f, 0f, num / 2f), new Vector3(Mathf.Tan(vector2.y) * num, Mathf.Tan(vector2.x) * num, zRange.y - zRange.x));
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("")]
	[SaveDuringPlay]
	public class CinemachineHardLockToTarget : CinemachineComponentBase
	{
		[Tooltip("How much time it takes for the position to catch up to the target's position")]
		public float m_Damping;

		private Vector3 m_PreviousTargetPosition;

		public override bool IsValid
		{
			get
			{
				if (base.enabled)
				{
					return base.FollowTarget != null;
				}
				return false;
			}
		}

		public override CinemachineCore.Stage Stage => CinemachineCore.Stage.Body;

		public override float GetMaxDampTime()
		{
			return m_Damping;
		}

		public override void MutateCameraState(ref CameraState curState, float deltaTime)
		{
			if (IsValid)
			{
				Vector3 vector = base.FollowTargetPosition;
				if (deltaTime >= 0f)
				{
					vector = m_PreviousTargetPosition + base.VirtualCamera.DetachedFollowTargetDamp(vector - m_PreviousTargetPosition, m_Damping, deltaTime);
				}
				m_PreviousTargetPosition = vector;
				curState.RawPosition = vector;
			}
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("")]
	[SaveDuringPlay]
	public class CinemachineHardLookAt : CinemachineComponentBase
	{
		public override bool IsValid
		{
			get
			{
				if (base.enabled)
				{
					return base.LookAtTarget != null;
				}
				return false;
			}
		}

		public override CinemachineCore.Stage Stage => CinemachineCore.Stage.Aim;

		public override void MutateCameraState(ref CameraState curState, float deltaTime)
		{
			if (!IsValid || !curState.HasLookAt)
			{
				return;
			}
			Vector3 vector = curState.ReferenceLookAt - curState.CorrectedPosition;
			if (vector.magnitude > 0.0001f)
			{
				if (Vector3.Cross(vector.normalized, curState.ReferenceUp).magnitude < 0.0001f)
				{
					curState.RawOrientation = Quaternion.FromToRotation(Vector3.forward, vector);
				}
				else
				{
					curState.RawOrientation = Quaternion.LookRotation(vector, curState.ReferenceUp);
				}
			}
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("")]
	[SaveDuringPlay]
	public class CinemachineOrbitalTransposer : CinemachineTransposer
	{
		[Serializable]
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public struct Heading
		{
			[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
			public enum HeadingDefinition
			{
				PositionDelta,
				Velocity,
				TargetForward,
				WorldForward
			}

			[FormerlySerializedAs("m_HeadingDefinition")]
			[Tooltip("How 'forward' is defined.  The camera will be placed by default behind the target.  PositionDelta will consider 'forward' to be the direction in which the target is moving.")]
			public HeadingDefinition m_Definition;

			[Range(0f, 10f)]
			[Tooltip("Size of the velocity sampling window for target heading filter.  This filters out irregularities in the target's movement.  Used only if deriving heading from target's movement (PositionDelta or Velocity)")]
			public int m_VelocityFilterStrength;

			[Range(-180f, 180f)]
			[FormerlySerializedAs("m_HeadingBias")]
			[Tooltip("Where the camera is placed when the X-axis value is zero.  This is a rotation in degrees around the Y axis.  When this value is 0, the camera will be placed behind the target.  Nonzero offsets will rotate the zero position around the target.")]
			public float m_Bias;

			public Heading(HeadingDefinition def, int filterStrength, float bias)
			{
				m_Definition = def;
				m_VelocityFilterStrength = filterStrength;
				m_Bias = bias;
			}
		}

		internal delegate float UpdateHeadingDelegate(CinemachineOrbitalTransposer orbital, float deltaTime, Vector3 up);

		[Space]
		[OrbitalTransposerHeadingProperty]
		[Tooltip("The definition of Forward.  Camera will follow behind.")]
		public Heading m_Heading = new Heading(Heading.HeadingDefinition.TargetForward, 4, 0f);

		[Tooltip("Automatic heading recentering.  The settings here defines how the camera will reposition itself in the absence of player input.")]
		public AxisState.Recentering m_RecenterToTargetHeading = new AxisState.Recentering(enabled: true, 1f, 2f);

		[Tooltip("Heading Control.  The settings here control the behaviour of the camera in response to the player's input.")]
		[AxisStateProperty]
		public AxisState m_XAxis = new AxisState(-180f, 180f, wrap: true, rangeLocked: false, 300f, 0.1f, 0.1f, "Mouse X", invert: true);

		[SerializeField]
		[HideInInspector]
		[FormerlySerializedAs("m_Radius")]
		private float m_LegacyRadius = float.MaxValue;

		[SerializeField]
		[HideInInspector]
		[FormerlySerializedAs("m_HeightOffset")]
		private float m_LegacyHeightOffset = float.MaxValue;

		[SerializeField]
		[HideInInspector]
		[FormerlySerializedAs("m_HeadingBias")]
		private float m_LegacyHeadingBias = float.MaxValue;

		[HideInInspector]
		[NoSaveDuringPlay]
		public bool m_HeadingIsSlave;

		internal UpdateHeadingDelegate HeadingUpdater = (CinemachineOrbitalTransposer orbital, float deltaTime, Vector3 up) => orbital.UpdateHeading(deltaTime, up, ref orbital.m_XAxis, ref orbital.m_RecenterToTargetHeading, CinemachineCore.Instance.IsLive(orbital.VirtualCamera));

		private Vector3 m_LastTargetPosition = Vector3.zero;

		private HeadingTracker mHeadingTracker;

		private Rigidbody m_TargetRigidBody;

		private Transform m_PreviousTarget;

		private Vector3 m_LastCameraPosition;

		private float m_LastHeading;

		public override bool RequiresUserInput => true;

		protected override void OnValidate()
		{
			if (m_LegacyRadius != float.MaxValue && m_LegacyHeightOffset != float.MaxValue && m_LegacyHeadingBias != float.MaxValue)
			{
				m_FollowOffset = new Vector3(0f, m_LegacyHeightOffset, 0f - m_LegacyRadius);
				m_LegacyHeightOffset = (m_LegacyRadius = float.MaxValue);
				m_Heading.m_Bias = m_LegacyHeadingBias;
				m_XAxis.m_MaxSpeed /= 10f;
				m_XAxis.m_AccelTime /= 10f;
				m_XAxis.m_DecelTime /= 10f;
				m_LegacyHeadingBias = float.MaxValue;
				int heading = (int)m_Heading.m_Definition;
				if (m_RecenterToTargetHeading.LegacyUpgrade(ref heading, ref m_Heading.m_VelocityFilterStrength))
				{
					m_Heading.m_Definition = (Heading.HeadingDefinition)heading;
				}
			}
			m_XAxis.Validate();
			m_RecenterToTargetHeading.Validate();
			base.OnValidate();
		}

		public float UpdateHeading(float deltaTime, Vector3 up, ref AxisState axis)
		{
			return UpdateHeading(deltaTime, up, ref axis, ref m_RecenterToTargetHeading, isLive: true);
		}

		public float UpdateHeading(float deltaTime, Vector3 up, ref AxisState axis, ref AxisState.Recentering recentering, bool isLive)
		{
			if (m_BindingMode == BindingMode.SimpleFollowWithWorldUp)
			{
				axis.m_MinValue = -180f;
				axis.m_MaxValue = 180f;
			}
			if (deltaTime < 0f || !base.VirtualCamera.PreviousStateIsValid || !isLive)
			{
				axis.Reset();
				recentering.CancelRecentering();
			}
			else if (axis.Update(deltaTime))
			{
				recentering.CancelRecentering();
			}
			if (m_BindingMode == BindingMode.SimpleFollowWithWorldUp)
			{
				float value = axis.Value;
				axis.Value = 0f;
				return value;
			}
			float targetHeading = GetTargetHeading(axis.Value, GetReferenceOrientation(up));
			recentering.DoRecentering(ref axis, deltaTime, targetHeading);
			return axis.Value;
		}

		private void OnEnable()
		{
			m_PreviousTarget = null;
			m_LastTargetPosition = Vector3.zero;
			UpdateInputAxisProvider();
		}

		public void UpdateInputAxisProvider()
		{
			m_XAxis.SetInputAxisProvider(0, null);
			if (!m_HeadingIsSlave && base.VirtualCamera != null)
			{
				AxisState.IInputAxisProvider inputAxisProvider = base.VirtualCamera.GetInputAxisProvider();
				if (inputAxisProvider != null)
				{
					m_XAxis.SetInputAxisProvider(0, inputAxisProvider);
				}
			}
		}

		public override void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
			base.OnTargetObjectWarped(target, positionDelta);
			if (target == base.FollowTarget)
			{
				m_LastTargetPosition += positionDelta;
				m_LastCameraPosition += positionDelta;
			}
		}

		public override void ForceCameraPosition(Vector3 pos, Quaternion rot)
		{
			base.ForceCameraPosition(pos, rot);
			m_LastCameraPosition = pos;
			m_XAxis.Value = GetAxisClosestValue(pos, base.VirtualCamera.State.ReferenceUp);
		}

		public override bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime, ref CinemachineVirtualCameraBase.TransitionParams transitionParams)
		{
			m_RecenterToTargetHeading.DoRecentering(ref m_XAxis, -1f, 0f);
			m_RecenterToTargetHeading.CancelRecentering();
			if (fromCam != null && m_BindingMode != BindingMode.SimpleFollowWithWorldUp && transitionParams.m_InheritPosition && !CinemachineCore.Instance.IsLiveInBlend(base.VirtualCamera))
			{
				m_XAxis.Value = GetAxisClosestValue(fromCam.State.RawPosition, worldUp);
				return true;
			}
			return false;
		}

		public float GetAxisClosestValue(Vector3 cameraPos, Vector3 up)
		{
			Quaternion referenceOrientation = GetReferenceOrientation(up);
			if (!(referenceOrientation * Vector3.forward).ProjectOntoPlane(up).AlmostZero() && base.FollowTarget != null)
			{
				float num = 0f;
				if (m_BindingMode != BindingMode.SimpleFollowWithWorldUp)
				{
					num += m_Heading.m_Bias;
				}
				referenceOrientation *= Quaternion.AngleAxis(num, up);
				Vector3 followTargetPosition = base.FollowTargetPosition;
				Vector3 vector = (followTargetPosition + referenceOrientation * base.EffectiveOffset - followTargetPosition).ProjectOntoPlane(up);
				Vector3 to = (cameraPos - followTargetPosition).ProjectOntoPlane(up);
				return Vector3.SignedAngle(vector, to, up);
			}
			return m_LastHeading;
		}

		public override void MutateCameraState(ref CameraState curState, float deltaTime)
		{
			InitPrevFrameStateInfo(ref curState, deltaTime);
			if (base.FollowTarget != m_PreviousTarget)
			{
				m_PreviousTarget = base.FollowTarget;
				m_TargetRigidBody = ((m_PreviousTarget == null) ? null : m_PreviousTarget.GetComponent<Rigidbody>());
				m_LastTargetPosition = ((m_PreviousTarget == null) ? Vector3.zero : m_PreviousTarget.position);
				mHeadingTracker = null;
			}
			m_LastHeading = HeadingUpdater(this, deltaTime, curState.ReferenceUp);
			float num = m_LastHeading;
			if (!IsValid)
			{
				return;
			}
			if (m_BindingMode != BindingMode.SimpleFollowWithWorldUp)
			{
				num += m_Heading.m_Bias;
			}
			Quaternion quaternion = Quaternion.AngleAxis(num, Vector3.up);
			Vector3 effectiveOffset = base.EffectiveOffset;
			Vector3 vector = quaternion * effectiveOffset;
			TrackTarget(deltaTime, curState.ReferenceUp, vector, out var outTargetPosition, out var outTargetOrient);
			vector = outTargetOrient * vector;
			curState.ReferenceUp = outTargetOrient * Vector3.up;
			Vector3 followTargetPosition = base.FollowTargetPosition;
			outTargetPosition += GetOffsetForMinimumTargetDistance(outTargetPosition, vector, curState.RawOrientation * Vector3.forward, curState.ReferenceUp, followTargetPosition);
			curState.RawPosition = outTargetPosition + vector;
			if (deltaTime >= 0f && base.VirtualCamera.PreviousStateIsValid)
			{
				Vector3 vector2 = followTargetPosition;
				if (base.LookAtTarget != null)
				{
					vector2 = base.LookAtTargetPosition;
				}
				Vector3 v = m_LastCameraPosition - vector2;
				Vector3 v2 = curState.RawPosition - vector2;
				if (v.sqrMagnitude > 0.01f && v2.sqrMagnitude > 0.01f)
				{
					curState.PositionDampingBypass = UnityVectorExtensions.SafeFromToRotation(v, v2, curState.ReferenceUp).eulerAngles;
				}
			}
			m_LastTargetPosition = followTargetPosition;
			m_LastCameraPosition = curState.RawPosition;
		}

		public override Vector3 GetTargetCameraPosition(Vector3 worldUp)
		{
			if (!IsValid)
			{
				return Vector3.zero;
			}
			float num = m_LastHeading;
			if (m_BindingMode != BindingMode.SimpleFollowWithWorldUp)
			{
				num += m_Heading.m_Bias;
			}
			Quaternion quaternion = Quaternion.AngleAxis(num, Vector3.up);
			quaternion = GetReferenceOrientation(worldUp) * quaternion;
			return quaternion * base.EffectiveOffset + m_LastTargetPosition;
		}

		private float GetTargetHeading(float currentHeading, Quaternion targetOrientation)
		{
			if (m_BindingMode == BindingMode.SimpleFollowWithWorldUp)
			{
				return 0f;
			}
			if (base.FollowTarget == null)
			{
				return currentHeading;
			}
			Heading.HeadingDefinition headingDefinition = m_Heading.m_Definition;
			if (headingDefinition == Heading.HeadingDefinition.Velocity && m_TargetRigidBody == null)
			{
				headingDefinition = Heading.HeadingDefinition.PositionDelta;
			}
			Vector3 zero = Vector3.zero;
			switch (headingDefinition)
			{
			case Heading.HeadingDefinition.Velocity:
				zero = m_TargetRigidBody.velocity;
				break;
			case Heading.HeadingDefinition.PositionDelta:
				zero = base.FollowTargetPosition - m_LastTargetPosition;
				break;
			case Heading.HeadingDefinition.TargetForward:
				zero = base.FollowTargetRotation * Vector3.forward;
				break;
			default:
				return 0f;
			}
			Vector3 vector = targetOrientation * Vector3.up;
			zero = zero.ProjectOntoPlane(vector);
			if (headingDefinition != Heading.HeadingDefinition.TargetForward)
			{
				int num = m_Heading.m_VelocityFilterStrength * 5;
				if (mHeadingTracker == null || mHeadingTracker.FilterSize != num)
				{
					mHeadingTracker = new HeadingTracker(num);
				}
				mHeadingTracker.DecayHistory();
				if (!zero.AlmostZero())
				{
					mHeadingTracker.Add(zero);
				}
				zero = mHeadingTracker.GetReliableHeading();
			}
			if (!zero.AlmostZero())
			{
				return UnityVectorExtensions.SignedAngle(targetOrientation * Vector3.forward, zero, vector);
			}
			return currentHeading;
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("")]
	[SaveDuringPlay]
	public class CinemachinePOV : CinemachineComponentBase
	{
		public enum RecenterTargetMode
		{
			None,
			FollowTargetForward,
			LookAtTargetForward
		}

		public RecenterTargetMode m_RecenterTarget;

		[Tooltip("The Vertical axis.  Value is -90..90. Controls the vertical orientation")]
		[AxisStateProperty]
		public AxisState m_VerticalAxis = new AxisState(-70f, 70f, wrap: false, rangeLocked: false, 300f, 0.1f, 0.1f, "Mouse Y", invert: true);

		[Tooltip("Controls how automatic recentering of the Vertical axis is accomplished")]
		public AxisState.Recentering m_VerticalRecentering = new AxisState.Recentering(enabled: false, 1f, 2f);

		[Tooltip("The Horizontal axis.  Value is -180..180.  Controls the horizontal orientation")]
		[AxisStateProperty]
		public AxisState m_HorizontalAxis = new AxisState(-180f, 180f, wrap: true, rangeLocked: false, 300f, 0.1f, 0.1f, "Mouse X", invert: false);

		[Tooltip("Controls how automatic recentering of the Horizontal axis is accomplished")]
		public AxisState.Recentering m_HorizontalRecentering = new AxisState.Recentering(enabled: false, 1f, 2f);

		[HideInInspector]
		[Tooltip("Obsolete - no longer used")]
		public bool m_ApplyBeforeBody;

		private Quaternion m_PreviousCameraRotation;

		public override bool IsValid => base.enabled;

		public override CinemachineCore.Stage Stage => CinemachineCore.Stage.Aim;

		public override bool RequiresUserInput => true;

		private void OnValidate()
		{
			m_VerticalAxis.Validate();
			m_VerticalRecentering.Validate();
			m_HorizontalAxis.Validate();
			m_HorizontalRecentering.Validate();
		}

		private void OnEnable()
		{
			UpdateInputAxisProvider();
		}

		public void UpdateInputAxisProvider()
		{
			m_HorizontalAxis.SetInputAxisProvider(0, null);
			m_VerticalAxis.SetInputAxisProvider(1, null);
			if (base.VirtualCamera != null)
			{
				AxisState.IInputAxisProvider inputAxisProvider = base.VirtualCamera.GetInputAxisProvider();
				if (inputAxisProvider != null)
				{
					m_HorizontalAxis.SetInputAxisProvider(0, inputAxisProvider);
					m_VerticalAxis.SetInputAxisProvider(1, inputAxisProvider);
				}
			}
		}

		public override void PrePipelineMutateCameraState(ref CameraState state, float deltaTime)
		{
		}

		public override void MutateCameraState(ref CameraState curState, float deltaTime)
		{
			if (!IsValid)
			{
				return;
			}
			if (deltaTime >= 0f && (!base.VirtualCamera.PreviousStateIsValid || !CinemachineCore.Instance.IsLive(base.VirtualCamera)))
			{
				deltaTime = -1f;
			}
			if (deltaTime >= 0f)
			{
				if (m_HorizontalAxis.Update(deltaTime))
				{
					m_HorizontalRecentering.CancelRecentering();
				}
				if (m_VerticalAxis.Update(deltaTime))
				{
					m_VerticalRecentering.CancelRecentering();
				}
			}
			Vector2 recenterTarget = GetRecenterTarget();
			m_HorizontalRecentering.DoRecentering(ref m_HorizontalAxis, deltaTime, recenterTarget.x);
			m_VerticalRecentering.DoRecentering(ref m_VerticalAxis, deltaTime, recenterTarget.y);
			Quaternion quaternion = Quaternion.Euler(m_VerticalAxis.Value, m_HorizontalAxis.Value, 0f);
			Transform parent = base.VirtualCamera.transform.parent;
			quaternion = (curState.RawOrientation = ((!(parent != null)) ? (Quaternion.FromToRotation(Vector3.up, curState.ReferenceUp) * quaternion) : (parent.rotation * quaternion)));
			if (base.VirtualCamera.PreviousStateIsValid)
			{
				curState.PositionDampingBypass = UnityVectorExtensions.SafeFromToRotation(m_PreviousCameraRotation * Vector3.forward, quaternion * Vector3.forward, curState.ReferenceUp).eulerAngles;
			}
			m_PreviousCameraRotation = quaternion;
		}

		public Vector2 GetRecenterTarget()
		{
			Transform transform = null;
			switch (m_RecenterTarget)
			{
			case RecenterTargetMode.FollowTargetForward:
				transform = base.VirtualCamera.Follow;
				break;
			case RecenterTargetMode.LookAtTargetForward:
				transform = base.VirtualCamera.LookAt;
				break;
			}
			if (transform != null)
			{
				Vector3 vector = transform.forward;
				Transform parent = base.VirtualCamera.transform.parent;
				if (parent != null)
				{
					vector = parent.rotation * vector;
				}
				Vector3 eulerAngles = Quaternion.FromToRotation(Vector3.forward, vector).eulerAngles;
				return new Vector2(NormalizeAngle(eulerAngles.y), NormalizeAngle(eulerAngles.x));
			}
			return Vector2.zero;
		}

		private static float NormalizeAngle(float angle)
		{
			return (angle + 180f) % 360f - 180f;
		}

		public override void ForceCameraPosition(Vector3 pos, Quaternion rot)
		{
			SetAxesForRotation(rot);
		}

		public override bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime, ref CinemachineVirtualCameraBase.TransitionParams transitionParams)
		{
			m_HorizontalRecentering.DoRecentering(ref m_HorizontalAxis, -1f, 0f);
			m_VerticalRecentering.DoRecentering(ref m_VerticalAxis, -1f, 0f);
			m_HorizontalRecentering.CancelRecentering();
			m_VerticalRecentering.CancelRecentering();
			if (fromCam != null && transitionParams.m_InheritPosition && !CinemachineCore.Instance.IsLiveInBlend(base.VirtualCamera))
			{
				SetAxesForRotation(fromCam.State.RawOrientation);
				return true;
			}
			return false;
		}

		private void SetAxesForRotation(Quaternion targetRot)
		{
			Vector3 referenceUp = base.VcamState.ReferenceUp;
			Vector3 vector = Vector3.forward;
			Transform parent = base.VirtualCamera.transform.parent;
			if (parent != null)
			{
				vector = parent.rotation * vector;
			}
			m_HorizontalAxis.Value = 0f;
			m_HorizontalAxis.Reset();
			Vector3 vector2 = targetRot * Vector3.forward;
			Vector3 vector3 = vector.ProjectOntoPlane(referenceUp);
			Vector3 vector4 = vector2.ProjectOntoPlane(referenceUp);
			if (!vector3.AlmostZero() && !vector4.AlmostZero())
			{
				m_HorizontalAxis.Value = Vector3.SignedAngle(vector3, vector4, referenceUp);
			}
			m_VerticalAxis.Value = 0f;
			m_VerticalAxis.Reset();
			vector = Quaternion.AngleAxis(m_HorizontalAxis.Value, referenceUp) * vector;
			Vector3 vector5 = Vector3.Cross(referenceUp, vector);
			if (!vector5.AlmostZero())
			{
				m_VerticalAxis.Value = Vector3.SignedAngle(vector, vector2, vector5);
			}
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("")]
	[SaveDuringPlay]
	public class CinemachineSameAsFollowTarget : CinemachineComponentBase
	{
		[Tooltip("How much time it takes for the aim to catch up to the target's rotation")]
		[FormerlySerializedAs("m_AngularDamping")]
		public float m_Damping;

		private Quaternion m_PreviousReferenceOrientation = Quaternion.identity;

		public override bool IsValid
		{
			get
			{
				if (base.enabled)
				{
					return base.FollowTarget != null;
				}
				return false;
			}
		}

		public override CinemachineCore.Stage Stage => CinemachineCore.Stage.Aim;

		public override float GetMaxDampTime()
		{
			return m_Damping;
		}

		public override void MutateCameraState(ref CameraState curState, float deltaTime)
		{
			if (IsValid)
			{
				Quaternion quaternion = base.FollowTargetRotation;
				if (deltaTime >= 0f)
				{
					float t = base.VirtualCamera.DetachedFollowTargetDamp(1f, m_Damping, deltaTime);
					quaternion = Quaternion.Slerp(m_PreviousReferenceOrientation, base.FollowTargetRotation, t);
				}
				m_PreviousReferenceOrientation = quaternion;
				curState.RawOrientation = quaternion;
				curState.ReferenceUp = quaternion * Vector3.up;
			}
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("")]
	[SaveDuringPlay]
	public class CinemachineTrackedDolly : CinemachineComponentBase
	{
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public enum CameraUpMode
		{
			Default,
			Path,
			PathNoRoll,
			FollowTarget,
			FollowTargetNoRoll
		}

		[Serializable]
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public struct AutoDolly
		{
			[Tooltip("If checked, will enable automatic dolly, which chooses a path position that is as close as possible to the Follow target.  Note: this can have significant performance impact")]
			public bool m_Enabled;

			[Tooltip("Offset, in current position units, from the closest point on the path to the follow target")]
			public float m_PositionOffset;

			[Tooltip("Search up to this many waypoints on either side of the current position.  Use 0 for Entire path.")]
			public int m_SearchRadius;

			[FormerlySerializedAs("m_StepsPerSegment")]
			[Tooltip("We search between waypoints by dividing the segment into this many straight pieces.  he higher the number, the more accurate the result, but performance is proportionally slower for higher numbers")]
			public int m_SearchResolution;

			public AutoDolly(bool enabled, float positionOffset, int searchRadius, int stepsPerSegment)
			{
				m_Enabled = enabled;
				m_PositionOffset = positionOffset;
				m_SearchRadius = searchRadius;
				m_SearchResolution = stepsPerSegment;
			}
		}

		[Tooltip("The path to which the camera will be constrained.  This must be non-null.")]
		public CinemachinePathBase m_Path;

		[Tooltip("The position along the path at which the camera will be placed.  This can be animated directly, or set automatically by the Auto-Dolly feature to get as close as possible to the Follow target.  The value is interpreted according to the Position Units setting.")]
		public float m_PathPosition;

		[Tooltip("How to interpret Path Position.  If set to Path Units, values are as follows: 0 represents the first waypoint on the path, 1 is the second, and so on.  Values in-between are points on the path in between the waypoints.  If set to Distance, then Path Position represents distance along the path.")]
		public CinemachinePathBase.PositionUnits m_PositionUnits;

		[Tooltip("Where to put the camera relative to the path position.  X is perpendicular to the path, Y is up, and Z is parallel to the path.  This allows the camera to be offset from the path itself (as if on a tripod, for example).")]
		public Vector3 m_PathOffset = Vector3.zero;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to maintain its position in a direction perpendicular to the path.  Small numbers are more responsive, rapidly translating the camera to keep the target's x-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")]
		public float m_XDamping;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to maintain its position in the path-local up direction.  Small numbers are more responsive, rapidly translating the camera to keep the target's y-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")]
		public float m_YDamping;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to maintain its position in a direction parallel to the path.  Small numbers are more responsive, rapidly translating the camera to keep the target's z-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")]
		public float m_ZDamping = 1f;

		[Tooltip("How to set the virtual camera's Up vector.  This will affect the screen composition, because the camera Aim behaviours will always try to respect the Up direction.")]
		public CameraUpMode m_CameraUp;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to track the target rotation's X angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")]
		public float m_PitchDamping;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to track the target rotation's Y angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")]
		public float m_YawDamping;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to track the target rotation's Z angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")]
		public float m_RollDamping;

		[Tooltip("Controls how automatic dollying occurs.  A Follow target is necessary to use this feature.")]
		public AutoDolly m_AutoDolly = new AutoDolly(enabled: false, 0f, 2, 5);

		private float m_PreviousPathPosition;

		private Quaternion m_PreviousOrientation = Quaternion.identity;

		private Vector3 m_PreviousCameraPosition = Vector3.zero;

		public override bool IsValid
		{
			get
			{
				if (base.enabled)
				{
					return m_Path != null;
				}
				return false;
			}
		}

		public override CinemachineCore.Stage Stage => CinemachineCore.Stage.Body;

		private Vector3 AngularDamping
		{
			get
			{
				switch (m_CameraUp)
				{
				case CameraUpMode.PathNoRoll:
				case CameraUpMode.FollowTargetNoRoll:
					return new Vector3(m_PitchDamping, m_YawDamping, 0f);
				case CameraUpMode.Default:
					return Vector3.zero;
				default:
					return new Vector3(m_PitchDamping, m_YawDamping, m_RollDamping);
				}
			}
		}

		public override float GetMaxDampTime()
		{
			Vector3 angularDamping = AngularDamping;
			float a = Mathf.Max(m_XDamping, Mathf.Max(m_YDamping, m_ZDamping));
			float b = Mathf.Max(angularDamping.x, Mathf.Max(angularDamping.y, angularDamping.z));
			return Mathf.Max(a, b);
		}

		public override void MutateCameraState(ref CameraState curState, float deltaTime)
		{
			if (deltaTime < 0f || !base.VirtualCamera.PreviousStateIsValid)
			{
				m_PreviousPathPosition = m_PathPosition;
				m_PreviousCameraPosition = curState.RawPosition;
				m_PreviousOrientation = curState.RawOrientation;
			}
			if (!IsValid)
			{
				return;
			}
			if (m_AutoDolly.m_Enabled && base.FollowTarget != null)
			{
				float f = m_Path.ToNativePathUnits(m_PreviousPathPosition, m_PositionUnits);
				m_PathPosition = m_Path.FindClosestPoint(base.FollowTargetPosition, Mathf.FloorToInt(f), (deltaTime < 0f || m_AutoDolly.m_SearchRadius <= 0) ? (-1) : m_AutoDolly.m_SearchRadius, m_AutoDolly.m_SearchResolution);
				m_PathPosition = m_Path.FromPathNativeUnits(m_PathPosition, m_PositionUnits);
				m_PathPosition += m_AutoDolly.m_PositionOffset;
			}
			float num = m_PathPosition;
			if (deltaTime >= 0f && base.VirtualCamera.PreviousStateIsValid)
			{
				float num2 = m_Path.MaxUnit(m_PositionUnits);
				if (num2 > 0f)
				{
					float num3 = m_Path.StandardizeUnit(m_PreviousPathPosition, m_PositionUnits);
					float num4 = m_Path.StandardizeUnit(num, m_PositionUnits);
					if (m_Path.Looped && Mathf.Abs(num4 - num3) > num2 / 2f)
					{
						num3 = ((!(num4 > num3)) ? (num3 - num2) : (num3 + num2));
					}
					m_PreviousPathPosition = num3;
					num = num4;
				}
				float initial = m_PreviousPathPosition - num;
				initial = Damper.Damp(initial, m_ZDamping, deltaTime);
				num = m_PreviousPathPosition - initial;
			}
			m_PreviousPathPosition = num;
			Quaternion quaternion = m_Path.EvaluateOrientationAtUnit(num, m_PositionUnits);
			Vector3 vector = m_Path.EvaluatePositionAtUnit(num, m_PositionUnits);
			Vector3 vector2 = quaternion * Vector3.right;
			Vector3 vector3 = quaternion * Vector3.up;
			Vector3 vector4 = quaternion * Vector3.forward;
			vector += m_PathOffset.x * vector2;
			vector += m_PathOffset.y * vector3;
			vector += m_PathOffset.z * vector4;
			if (deltaTime >= 0f && base.VirtualCamera.PreviousStateIsValid)
			{
				Vector3 previousCameraPosition = m_PreviousCameraPosition;
				Vector3 vector5 = previousCameraPosition - vector;
				Vector3 vector6 = Vector3.Dot(vector5, vector3) * vector3;
				Vector3 initial2 = vector5 - vector6;
				initial2 = Damper.Damp(initial2, m_XDamping, deltaTime);
				vector6 = Damper.Damp(vector6, m_YDamping, deltaTime);
				vector = previousCameraPosition - (initial2 + vector6);
			}
			curState.RawPosition = (m_PreviousCameraPosition = vector);
			Quaternion quaternion2 = GetCameraOrientationAtPathPoint(quaternion, curState.ReferenceUp);
			if (deltaTime >= 0f && base.VirtualCamera.PreviousStateIsValid)
			{
				Vector3 eulerAngles = (Quaternion.Inverse(m_PreviousOrientation) * quaternion2).eulerAngles;
				for (int i = 0; i < 3; i++)
				{
					if (eulerAngles[i] > 180f)
					{
						eulerAngles[i] -= 360f;
					}
				}
				eulerAngles = Damper.Damp(eulerAngles, AngularDamping, deltaTime);
				quaternion2 = m_PreviousOrientation * Quaternion.Euler(eulerAngles);
			}
			m_PreviousOrientation = quaternion2;
			curState.RawOrientation = quaternion2;
			if (m_CameraUp != CameraUpMode.Default)
			{
				curState.ReferenceUp = curState.RawOrientation * Vector3.up;
			}
		}

		private Quaternion GetCameraOrientationAtPathPoint(Quaternion pathOrientation, Vector3 up)
		{
			switch (m_CameraUp)
			{
			case CameraUpMode.Path:
				return pathOrientation;
			case CameraUpMode.PathNoRoll:
				return Quaternion.LookRotation(pathOrientation * Vector3.forward, up);
			case CameraUpMode.FollowTarget:
				if (base.FollowTarget != null)
				{
					return base.FollowTargetRotation;
				}
				break;
			case CameraUpMode.FollowTargetNoRoll:
				if (base.FollowTarget != null)
				{
					return Quaternion.LookRotation(base.FollowTargetRotation * Vector3.forward, up);
				}
				break;
			}
			return Quaternion.LookRotation(base.VirtualCamera.transform.rotation * Vector3.forward, up);
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[AddComponentMenu("")]
	[SaveDuringPlay]
	public class CinemachineTransposer : CinemachineComponentBase
	{
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public enum BindingMode
		{
			LockToTargetOnAssign,
			LockToTargetWithWorldUp,
			LockToTargetNoRoll,
			LockToTarget,
			WorldSpace,
			SimpleFollowWithWorldUp
		}

		public enum AngularDampingMode
		{
			Euler,
			Quaternion
		}

		[Tooltip("The coordinate space to use when interpreting the offset from the target.  This is also used to set the camera's Up vector, which will be maintained when aiming the camera.")]
		public BindingMode m_BindingMode = BindingMode.LockToTargetWithWorldUp;

		[Tooltip("The distance vector that the transposer will attempt to maintain from the Follow target")]
		public Vector3 m_FollowOffset = Vector3.back * 10f;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to maintain the offset in the X-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's x-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")]
		public float m_XDamping = 1f;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to maintain the offset in the Y-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's y-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")]
		public float m_YDamping = 1f;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to maintain the offset in the Z-axis.  Small numbers are more responsive, rapidly translating the camera to keep the target's z-axis offset.  Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors.")]
		public float m_ZDamping = 1f;

		public AngularDampingMode m_AngularDampingMode;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to track the target rotation's X angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")]
		public float m_PitchDamping;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to track the target rotation's Y angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")]
		public float m_YawDamping;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to track the target rotation's Z angle.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")]
		public float m_RollDamping;

		[Range(0f, 20f)]
		[Tooltip("How aggressively the camera tries to track the target's orientation.  Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.")]
		public float m_AngularDamping;

		private Vector3 m_PreviousTargetPosition = Vector3.zero;

		private Quaternion m_PreviousReferenceOrientation = Quaternion.identity;

		private Quaternion m_targetOrientationOnAssign = Quaternion.identity;

		private Vector3 m_PreviousOffset;

		private Transform m_previousTarget;

		public bool HideOffsetInInspector { get; set; }

		public Vector3 EffectiveOffset
		{
			get
			{
				Vector3 followOffset = m_FollowOffset;
				if (m_BindingMode == BindingMode.SimpleFollowWithWorldUp)
				{
					followOffset.x = 0f;
					followOffset.z = 0f - Mathf.Abs(followOffset.z);
				}
				return followOffset;
			}
		}

		public override bool IsValid
		{
			get
			{
				if (base.enabled)
				{
					return base.FollowTarget != null;
				}
				return false;
			}
		}

		public override CinemachineCore.Stage Stage => CinemachineCore.Stage.Body;

		protected Vector3 Damping
		{
			get
			{
				if (m_BindingMode == BindingMode.SimpleFollowWithWorldUp)
				{
					return new Vector3(0f, m_YDamping, m_ZDamping);
				}
				return new Vector3(m_XDamping, m_YDamping, m_ZDamping);
			}
		}

		protected Vector3 AngularDamping
		{
			get
			{
				switch (m_BindingMode)
				{
				case BindingMode.LockToTargetNoRoll:
					return new Vector3(m_PitchDamping, m_YawDamping, 0f);
				case BindingMode.LockToTargetWithWorldUp:
					return new Vector3(0f, m_YawDamping, 0f);
				case BindingMode.LockToTargetOnAssign:
				case BindingMode.WorldSpace:
				case BindingMode.SimpleFollowWithWorldUp:
					return Vector3.zero;
				default:
					return new Vector3(m_PitchDamping, m_YawDamping, m_RollDamping);
				}
			}
		}

		protected virtual void OnValidate()
		{
			m_FollowOffset = EffectiveOffset;
		}

		public override float GetMaxDampTime()
		{
			Vector3 damping = Damping;
			Vector3 angularDamping = AngularDamping;
			float a = Mathf.Max(damping.x, Mathf.Max(damping.y, damping.z));
			float b = Mathf.Max(angularDamping.x, Mathf.Max(angularDamping.y, angularDamping.z));
			return Mathf.Max(a, b);
		}

		public override void MutateCameraState(ref CameraState curState, float deltaTime)
		{
			InitPrevFrameStateInfo(ref curState, deltaTime);
			if (IsValid)
			{
				Vector3 effectiveOffset = EffectiveOffset;
				TrackTarget(deltaTime, curState.ReferenceUp, effectiveOffset, out var outTargetPosition, out var outTargetOrient);
				effectiveOffset = outTargetOrient * effectiveOffset;
				curState.ReferenceUp = outTargetOrient * Vector3.up;
				Vector3 followTargetPosition = base.FollowTargetPosition;
				outTargetPosition += GetOffsetForMinimumTargetDistance(outTargetPosition, effectiveOffset, curState.RawOrientation * Vector3.forward, curState.ReferenceUp, followTargetPosition);
				curState.RawPosition = outTargetPosition + effectiveOffset;
			}
		}

		public override void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
			base.OnTargetObjectWarped(target, positionDelta);
			if (target == base.FollowTarget)
			{
				m_PreviousTargetPosition += positionDelta;
			}
		}

		public override void ForceCameraPosition(Vector3 pos, Quaternion rot)
		{
			base.ForceCameraPosition(pos, rot);
			Quaternion quaternion = ((m_BindingMode == BindingMode.SimpleFollowWithWorldUp) ? rot : GetReferenceOrientation(base.VirtualCamera.State.ReferenceUp));
			m_PreviousTargetPosition = pos - quaternion * EffectiveOffset;
		}

		protected void InitPrevFrameStateInfo(ref CameraState curState, float deltaTime)
		{
			bool flag = deltaTime >= 0f && base.VirtualCamera.PreviousStateIsValid;
			if (m_previousTarget != base.FollowTarget || !flag)
			{
				m_previousTarget = base.FollowTarget;
				m_targetOrientationOnAssign = base.FollowTargetRotation;
			}
			if (!flag)
			{
				m_PreviousTargetPosition = base.FollowTargetPosition;
				m_PreviousReferenceOrientation = GetReferenceOrientation(curState.ReferenceUp);
			}
		}

		protected void TrackTarget(float deltaTime, Vector3 up, Vector3 desiredCameraOffset, out Vector3 outTargetPosition, out Quaternion outTargetOrient)
		{
			Quaternion referenceOrientation = GetReferenceOrientation(up);
			Quaternion quaternion = referenceOrientation;
			bool flag = deltaTime >= 0f && base.VirtualCamera.PreviousStateIsValid;
			if (flag)
			{
				if (m_AngularDampingMode == AngularDampingMode.Quaternion && m_BindingMode == BindingMode.LockToTarget)
				{
					float t = base.VirtualCamera.DetachedFollowTargetDamp(1f, m_AngularDamping, deltaTime);
					quaternion = Quaternion.Slerp(m_PreviousReferenceOrientation, referenceOrientation, t);
				}
				else if (m_BindingMode != BindingMode.SimpleFollowWithWorldUp)
				{
					Vector3 eulerAngles = (Quaternion.Inverse(m_PreviousReferenceOrientation) * referenceOrientation).eulerAngles;
					for (int i = 0; i < 3; i++)
					{
						if (eulerAngles[i] > 180f)
						{
							eulerAngles[i] -= 360f;
						}
						if (Mathf.Abs(eulerAngles[i]) < 0.01f)
						{
							eulerAngles[i] = 0f;
						}
					}
					eulerAngles = base.VirtualCamera.DetachedFollowTargetDamp(eulerAngles, AngularDamping, deltaTime);
					quaternion = m_PreviousReferenceOrientation * Quaternion.Euler(eulerAngles);
				}
			}
			m_PreviousReferenceOrientation = quaternion;
			Vector3 followTargetPosition = base.FollowTargetPosition;
			Vector3 vector = m_PreviousTargetPosition;
			Vector3 vector2 = (flag ? m_PreviousOffset : desiredCameraOffset);
			if ((desiredCameraOffset - vector2).sqrMagnitude > 0.01f)
			{
				Quaternion quaternion2 = UnityVectorExtensions.SafeFromToRotation(m_PreviousOffset.ProjectOntoPlane(up), desiredCameraOffset.ProjectOntoPlane(up), up);
				vector = followTargetPosition + quaternion2 * (m_PreviousTargetPosition - followTargetPosition);
			}
			m_PreviousOffset = desiredCameraOffset;
			Vector3 vector3 = followTargetPosition - vector;
			if (flag)
			{
				Quaternion quaternion3 = ((!desiredCameraOffset.AlmostZero()) ? Quaternion.LookRotation(quaternion * desiredCameraOffset, up) : base.VcamState.RawOrientation);
				Vector3 initial = Quaternion.Inverse(quaternion3) * vector3;
				initial = base.VirtualCamera.DetachedFollowTargetDamp(initial, Damping, deltaTime);
				vector3 = quaternion3 * initial;
			}
			vector += vector3;
			outTargetPosition = (m_PreviousTargetPosition = vector);
			outTargetOrient = quaternion;
		}

		protected Vector3 GetOffsetForMinimumTargetDistance(Vector3 dampedTargetPos, Vector3 cameraOffset, Vector3 cameraFwd, Vector3 up, Vector3 actualTargetPos)
		{
			Vector3 vector = Vector3.zero;
			if (base.VirtualCamera.FollowTargetAttachment > 0.9999f)
			{
				cameraOffset = cameraOffset.ProjectOntoPlane(up);
				float num = cameraOffset.magnitude * 0.2f;
				if (num > 0f)
				{
					actualTargetPos = actualTargetPos.ProjectOntoPlane(up);
					dampedTargetPos = dampedTargetPos.ProjectOntoPlane(up);
					Vector3 vector2 = dampedTargetPos + cameraOffset;
					float num2 = Vector3.Dot(actualTargetPos - vector2, (dampedTargetPos - vector2).normalized);
					if (num2 < num)
					{
						Vector3 vector3 = actualTargetPos - dampedTargetPos;
						float magnitude = vector3.magnitude;
						if (magnitude < 0.01f)
						{
							vector3 = -cameraFwd.ProjectOntoPlane(up);
						}
						else
						{
							vector3 /= magnitude;
						}
						vector = vector3 * (num - num2);
					}
					m_PreviousTargetPosition += vector;
				}
			}
			return vector;
		}

		public virtual Vector3 GetTargetCameraPosition(Vector3 worldUp)
		{
			if (!IsValid)
			{
				return Vector3.zero;
			}
			return base.FollowTargetPosition + GetReferenceOrientation(worldUp) * EffectiveOffset;
		}

		public Quaternion GetReferenceOrientation(Vector3 worldUp)
		{
			if (m_BindingMode == BindingMode.WorldSpace)
			{
				return Quaternion.identity;
			}
			if (base.FollowTarget != null)
			{
				Quaternion rotation = base.FollowTarget.rotation;
				switch (m_BindingMode)
				{
				case BindingMode.LockToTargetOnAssign:
					return m_targetOrientationOnAssign;
				case BindingMode.LockToTargetWithWorldUp:
				{
					Vector3 vector2 = (rotation * Vector3.forward).ProjectOntoPlane(worldUp);
					if (!vector2.AlmostZero())
					{
						return Quaternion.LookRotation(vector2, worldUp);
					}
					break;
				}
				case BindingMode.LockToTargetNoRoll:
					return Quaternion.LookRotation(rotation * Vector3.forward, worldUp);
				case BindingMode.LockToTarget:
					return rotation;
				case BindingMode.SimpleFollowWithWorldUp:
				{
					Vector3 vector = (base.FollowTargetPosition - base.VcamState.RawPosition).ProjectOntoPlane(worldUp);
					if (!vector.AlmostZero())
					{
						return Quaternion.LookRotation(vector, worldUp);
					}
					break;
				}
				}
			}
			return m_PreviousReferenceOrientation.normalized;
		}
	}
	[Serializable]
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	public struct AxisState
	{
		public enum SpeedMode
		{
			MaxSpeed,
			InputValueGain
		}

		public interface IInputAxisProvider
		{
			float GetAxisValue(int axis);
		}

		[Serializable]
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public struct Recentering
		{
			[Tooltip("If checked, will enable automatic recentering of the axis. If unchecked, recenting is disabled.")]
			public bool m_enabled;

			[Tooltip("If no user input has been detected on the axis, the axis will wait this long in seconds before recentering.")]
			public float m_WaitTime;

			[Tooltip("How long it takes to reach destination once recentering has started.")]
			public float m_RecenteringTime;

			private float m_LastUpdateTime;

			private float mLastAxisInputTime;

			private float mRecenteringVelocity;

			[SerializeField]
			[HideInInspector]
			[FormerlySerializedAs("m_HeadingDefinition")]
			private int m_LegacyHeadingDefinition;

			[SerializeField]
			[HideInInspector]
			[FormerlySerializedAs("m_VelocityFilterStrength")]
			private int m_LegacyVelocityFilterStrength;

			public Recentering(bool enabled, float waitTime, float recenteringTime)
			{
				m_enabled = enabled;
				m_WaitTime = waitTime;
				m_RecenteringTime = recenteringTime;
				mLastAxisInputTime = 0f;
				mRecenteringVelocity = 0f;
				m_LegacyHeadingDefinition = (m_LegacyVelocityFilterStrength = -1);
				m_LastUpdateTime = 0f;
			}

			public void Validate()
			{
				m_WaitTime = Mathf.Max(0f, m_WaitTime);
				m_RecenteringTime = Mathf.Max(0f, m_RecenteringTime);
			}

			public void CopyStateFrom(ref Recentering other)
			{
				if (mLastAxisInputTime != other.mLastAxisInputTime)
				{
					other.mRecenteringVelocity = 0f;
				}
				mLastAxisInputTime = other.mLastAxisInputTime;
			}

			public void CancelRecentering()
			{
				mLastAxisInputTime = Time.realtimeSinceStartup;
				mRecenteringVelocity = 0f;
			}

			public void RecenterNow()
			{
				mLastAxisInputTime = -1f;
			}

			public void DoRecentering(ref AxisState axis, float deltaTime, float recenterTarget)
			{
				if (deltaTime > 0f)
				{
					deltaTime = Time.realtimeSinceStartup - m_LastUpdateTime;
				}
				m_LastUpdateTime = Time.realtimeSinceStartup;
				if (!m_enabled && deltaTime >= 0f)
				{
					return;
				}
				recenterTarget = axis.ClampValue(recenterTarget);
				if (deltaTime < 0f)
				{
					CancelRecentering();
					if (m_enabled)
					{
						axis.Value = recenterTarget;
					}
					return;
				}
				float num = axis.ClampValue(axis.Value);
				float num2 = recenterTarget - num;
				if (num2 != 0f && (!(mLastAxisInputTime >= 0f) || !(Time.realtimeSinceStartup < mLastAxisInputTime + m_WaitTime)))
				{
					float num3 = axis.m_MaxValue - axis.m_MinValue;
					if (axis.m_Wrap && Mathf.Abs(num2) > num3 * 0.5f)
					{
						num += Mathf.Sign(recenterTarget - num) * num3;
					}
					num = ((!(m_RecenteringTime < 0.001f) && !(Mathf.Abs(num - recenterTarget) < 0.001f)) ? Mathf.SmoothDamp(num, recenterTarget, ref mRecenteringVelocity, m_RecenteringTime, 9999f, deltaTime) : recenterTarget);
					axis.Value = axis.ClampValue(num);
				}
			}

			internal bool LegacyUpgrade(ref int heading, ref int velocityFilter)
			{
				if (m_LegacyHeadingDefinition != -1 && m_LegacyVelocityFilterStrength != -1)
				{
					heading = m_LegacyHeadingDefinition;
					velocityFilter = m_LegacyVelocityFilterStrength;
					m_LegacyHeadingDefinition = (m_LegacyVelocityFilterStrength = -1);
					return true;
				}
				return false;
			}
		}

		[NoSaveDuringPlay]
		[Tooltip("The current value of the axis.")]
		public float Value;

		[Tooltip("How to interpret the Max Speed setting: in units/second, or as a direct input value multiplier")]
		public SpeedMode m_SpeedMode;

		[Tooltip("The maximum speed of this axis in units/second, or the input value multiplier, depending on the Speed Mode")]
		public float m_MaxSpeed;

		[Tooltip("The amount of time in seconds it takes to accelerate to MaxSpeed with the supplied Axis at its maximum value")]
		public float m_AccelTime;

		[Tooltip("The amount of time in seconds it takes to decelerate the axis to zero if the supplied axis is in a neutral position")]
		public float m_DecelTime;

		[FormerlySerializedAs("m_AxisName")]
		[Tooltip("The name of this axis as specified in Unity Input manager. Setting to an empty string will disable the automatic updating of this axis")]
		public string m_InputAxisName;

		[NoSaveDuringPlay]
		[Tooltip("The value of the input axis.  A value of 0 means no input.  You can drive this directly from a custom input system, or you can set the Axis Name and have the value driven by the internal Input Manager")]
		public float m_InputAxisValue;

		[FormerlySerializedAs("m_InvertAxis")]
		[Tooltip("If checked, then the raw value of the input axis will be inverted before it is used")]
		public bool m_InvertInput;

		[Tooltip("The minimum value for the axis")]
		public float m_MinValue;

		[Tooltip("The maximum value for the axis")]
		public float m_MaxValue;

		[Tooltip("If checked, then the axis will wrap around at the min/max values, forming a loop")]
		public bool m_Wrap;

		[Tooltip("Automatic recentering to at-rest position")]
		public Recentering m_Recentering;

		private float m_CurrentSpeed;

		private float m_LastUpdateTime;

		private int m_LastUpdateFrame;

		private const float Epsilon = 0.0001f;

		private IInputAxisProvider m_InputAxisProvider;

		private int m_InputAxisIndex;

		public bool HasInputProvider => m_InputAxisProvider != null;

		public bool ValueRangeLocked { get; set; }

		public bool HasRecentering { get; set; }

		public AxisState(float minValue, float maxValue, bool wrap, bool rangeLocked, float maxSpeed, float accelTime, float decelTime, string name, bool invert)
		{
			m_MinValue = minValue;
			m_MaxValue = maxValue;
			m_Wrap = wrap;
			ValueRangeLocked = rangeLocked;
			HasRecentering = false;
			m_Recentering = new Recentering(enabled: false, 1f, 2f);
			m_SpeedMode = SpeedMode.MaxSpeed;
			m_MaxSpeed = maxSpeed;
			m_AccelTime = accelTime;
			m_DecelTime = decelTime;
			Value = (minValue + maxValue) / 2f;
			m_InputAxisName = name;
			m_InputAxisValue = 0f;
			m_InvertInput = invert;
			m_CurrentSpeed = 0f;
			m_InputAxisProvider = null;
			m_InputAxisIndex = 0;
			m_LastUpdateTime = 0f;
			m_LastUpdateFrame = 0;
		}

		public void Validate()
		{
			if (m_SpeedMode == SpeedMode.MaxSpeed)
			{
				m_MaxSpeed = Mathf.Max(0f, m_MaxSpeed);
			}
			m_AccelTime = Mathf.Max(0f, m_AccelTime);
			m_DecelTime = Mathf.Max(0f, m_DecelTime);
			m_MaxValue = Mathf.Clamp(m_MaxValue, m_MinValue, m_MaxValue);
		}

		public void Reset()
		{
			m_InputAxisValue = 0f;
			m_CurrentSpeed = 0f;
			m_LastUpdateTime = 0f;
			m_LastUpdateFrame = 0;
		}

		public void SetInputAxisProvider(int axis, IInputAxisProvider provider)
		{
			m_InputAxisIndex = axis;
			m_InputAxisProvider = provider;
		}

		public bool Update(float deltaTime)
		{
			if (Time.frameCount == m_LastUpdateFrame)
			{
				return false;
			}
			m_LastUpdateFrame = Time.frameCount;
			if (deltaTime > 0f && m_LastUpdateTime != 0f)
			{
				deltaTime = Time.realtimeSinceStartup - m_LastUpdateTime;
			}
			m_LastUpdateTime = Time.realtimeSinceStartup;
			if (m_InputAxisProvider != null)
			{
				m_InputAxisValue = m_InputAxisProvider.GetAxisValue(m_InputAxisIndex);
			}
			else if (!string.IsNullOrEmpty(m_InputAxisName))
			{
				try
				{
					m_InputAxisValue = CinemachineCore.GetInputAxis(m_InputAxisName);
				}
				catch (ArgumentException ex)
				{
					UnityEngine.Debug.LogError(ex.ToString());
				}
			}
			float num = m_InputAxisValue;
			if (m_InvertInput)
			{
				num *= -1f;
			}
			if (m_SpeedMode == SpeedMode.MaxSpeed)
			{
				return MaxSpeedUpdate(num, deltaTime);
			}
			num *= m_MaxSpeed;
			if (deltaTime < 0f)
			{
				m_CurrentSpeed = 0f;
			}
			else if (deltaTime > 0.0001f)
			{
				float dampTime = ((Mathf.Abs(num) < Mathf.Abs(m_CurrentSpeed)) ? m_DecelTime : m_AccelTime);
				m_CurrentSpeed += Damper.Damp(num - m_CurrentSpeed, dampTime, deltaTime);
				float num2 = m_MaxValue - m_MinValue;
				if (!m_Wrap && m_DecelTime > 0.0001f && num2 > 0.0001f)
				{
					float num3 = ClampValue(Value);
					float num4 = ClampValue(num3 + m_CurrentSpeed * deltaTime);
					if (((m_CurrentSpeed > 0f) ? (m_MaxValue - num4) : (num4 - m_MinValue)) < 0.1f * num2 && Mathf.Abs(m_CurrentSpeed) > 0.0001f)
					{
						m_CurrentSpeed = Damper.Damp(num4 - num3, m_DecelTime, deltaTime) / deltaTime;
					}
				}
				num = m_CurrentSpeed * deltaTime;
			}
			Value = ClampValue(Value + m_CurrentSpeed);
			return Mathf.Abs(num) > 0.0001f;
		}

		private float ClampValue(float v)
		{
			float num = m_MaxValue - m_MinValue;
			if (m_Wrap && num > 0.0001f)
			{
				v = (v - m_MinValue) % num;
				v += m_MinValue + ((v < 0f) ? num : 0f);
			}
			return Mathf.Clamp(v, m_MinValue, m_MaxValue);
		}

		private bool MaxSpeedUpdate(float input, float deltaTime)
		{
			if (m_MaxSpeed > 0.0001f)
			{
				float num = input * m_MaxSpeed;
				if (Mathf.Abs(num) < 0.0001f || (Mathf.Sign(m_CurrentSpeed) == Mathf.Sign(num) && Mathf.Abs(num) < Mathf.Abs(m_CurrentSpeed)))
				{
					float num2 = Mathf.Min(Mathf.Abs(num - m_CurrentSpeed) / Mathf.Max(0.0001f, m_DecelTime) * deltaTime, Mathf.Abs(m_CurrentSpeed));
					m_CurrentSpeed -= Mathf.Sign(m_CurrentSpeed) * num2;
				}
				else
				{
					float num3 = Mathf.Abs(num - m_CurrentSpeed) / Mathf.Max(0.0001f, m_AccelTime);
					m_CurrentSpeed += Mathf.Sign(num) * num3 * deltaTime;
					if (Mathf.Sign(m_CurrentSpeed) == Mathf.Sign(num) && Mathf.Abs(m_CurrentSpeed) > Mathf.Abs(num))
					{
						m_CurrentSpeed = num;
					}
				}
			}
			float maxSpeed = GetMaxSpeed();
			m_CurrentSpeed = Mathf.Clamp(m_CurrentSpeed, 0f - maxSpeed, maxSpeed);
			if (Mathf.Abs(m_CurrentSpeed) < 0.0001f)
			{
				m_CurrentSpeed = 0f;
			}
			Value += m_CurrentSpeed * deltaTime;
			if (Value > m_MaxValue || Value < m_MinValue)
			{
				if (m_Wrap)
				{
					if (Value > m_MaxValue)
					{
						Value = m_MinValue + (Value - m_MaxValue);
					}
					else
					{
						Value = m_MaxValue + (Value - m_MinValue);
					}
				}
				else
				{
					Value = Mathf.Clamp(Value, m_MinValue, m_MaxValue);
					m_CurrentSpeed = 0f;
				}
			}
			return Mathf.Abs(input) > 0.0001f;
		}

		private float GetMaxSpeed()
		{
			float num = m_MaxValue - m_MinValue;
			if (!m_Wrap && num > 0f)
			{
				float num2 = num / 10f;
				if (m_CurrentSpeed > 0f && m_MaxValue - Value < num2)
				{
					float t = (m_MaxValue - Value) / num2;
					return Mathf.Lerp(0f, m_MaxSpeed, t);
				}
				if (m_CurrentSpeed < 0f && Value - m_MinValue < num2)
				{
					float t2 = (Value - m_MinValue) / num2;
					return Mathf.Lerp(0f, m_MaxSpeed, t2);
				}
			}
			return m_MaxSpeed;
		}
	}
	public struct CameraState
	{
		public enum BlendHintValue
		{
			Nothing = 0,
			NoPosition = 1,
			NoOrientation = 2,
			NoTransform = 3,
			SphericalPositionBlend = 4,
			CylindricalPositionBlend = 8,
			RadialAimBlend = 16,
			IgnoreLookAtTarget = 32,
			NoLens = 64
		}

		public struct CustomBlendable
		{
			public UnityEngine.Object m_Custom;

			public float m_Weight;

			public CustomBlendable(UnityEngine.Object custom, float weight)
			{
				m_Custom = custom;
				m_Weight = weight;
			}
		}

		public LensSettings Lens;

		public Vector3 ReferenceUp;

		public Vector3 ReferenceLookAt;

		public static Vector3 kNoPoint = new Vector3(float.NaN, float.NaN, float.NaN);

		public Vector3 RawPosition;

		public Quaternion RawOrientation;

		public Vector3 PositionDampingBypass;

		public float ShotQuality;

		public Vector3 PositionCorrection;

		public Quaternion OrientationCorrection;

		public BlendHintValue BlendHint;

		private CustomBlendable mCustom0;

		private CustomBlendable mCustom1;

		private CustomBlendable mCustom2;

		private CustomBlendable mCustom3;

		private List<CustomBlendable> m_CustomOverflow;

		public bool HasLookAt => ReferenceLookAt == ReferenceLookAt;

		public Vector3 CorrectedPosition => RawPosition + PositionCorrection;

		public Quaternion CorrectedOrientation => RawOrientation * OrientationCorrection;

		public Vector3 FinalPosition => RawPosition + PositionCorrection;

		public Quaternion FinalOrientation
		{
			get
			{
				if (Mathf.Abs(Lens.Dutch) > 0.0001f)
				{
					return CorrectedOrientation * Quaternion.AngleAxis(Lens.Dutch, Vector3.forward);
				}
				return CorrectedOrientation;
			}
		}

		public static CameraState Default => new CameraState
		{
			Lens = LensSettings.Default,
			ReferenceUp = Vector3.up,
			ReferenceLookAt = kNoPoint,
			RawPosition = Vector3.zero,
			RawOrientation = Quaternion.identity,
			ShotQuality = 1f,
			PositionCorrection = Vector3.zero,
			OrientationCorrection = Quaternion.identity,
			PositionDampingBypass = Vector3.zero,
			BlendHint = BlendHintValue.Nothing
		};

		public int NumCustomBlendables { get; private set; }

		public CustomBlendable GetCustomBlendable(int index)
		{
			switch (index)
			{
			case 0:
				return mCustom0;
			case 1:
				return mCustom1;
			case 2:
				return mCustom2;
			case 3:
				return mCustom3;
			default:
				index -= 4;
				if (m_CustomOverflow != null && index < m_CustomOverflow.Count)
				{
					return m_CustomOverflow[index];
				}
				return new CustomBlendable(null, 0f);
			}
		}

		private int FindCustomBlendable(UnityEngine.Object custom)
		{
			if (mCustom0.m_Custom == custom)
			{
				return 0;
			}
			if (mCustom1.m_Custom == custom)
			{
				return 1;
			}
			if (mCustom2.m_Custom == custom)
			{
				return 2;
			}
			if (mCustom3.m_Custom == custom)
			{
				return 3;
			}
			if (m_CustomOverflow != null)
			{
				for (int i = 0; i < m_CustomOverflow.Count; i++)
				{
					if (m_CustomOverflow[i].m_Custom == custom)
					{
						return i + 4;
					}
				}
			}
			return -1;
		}

		public void AddCustomBlendable(CustomBlendable b)
		{
			int num = FindCustomBlendable(b.m_Custom);
			if (num >= 0)
			{
				b.m_Weight += GetCustomBlendable(num).m_Weight;
			}
			else
			{
				num = NumCustomBlendables++;
			}
			switch (num)
			{
			case 0:
				mCustom0 = b;
				return;
			case 1:
				mCustom1 = b;
				return;
			case 2:
				mCustom2 = b;
				return;
			case 3:
				mCustom3 = b;
				return;
			}
			num -= 4;
			if (m_CustomOverflow == null)
			{
				m_CustomOverflow = new List<CustomBlendable>();
			}
			if (num < m_CustomOverflow.Count)
			{
				m_CustomOverflow[num] = b;
			}
			else
			{
				m_CustomOverflow.Add(b);
			}
		}

		public static CameraState Lerp(CameraState stateA, CameraState stateB, float t)
		{
			t = Mathf.Clamp01(t);
			float t2 = t;
			CameraState result = default(CameraState);
			if ((stateA.BlendHint & stateB.BlendHint & BlendHintValue.NoPosition) != BlendHintValue.Nothing)
			{
				result.BlendHint |= BlendHintValue.NoPosition;
			}
			if ((stateA.BlendHint & stateB.BlendHint & BlendHintValue.NoOrientation) != BlendHintValue.Nothing)
			{
				result.BlendHint |= BlendHintValue.NoOrientation;
			}
			if ((stateA.BlendHint & stateB.BlendHint & BlendHintValue.NoLens) != BlendHintValue.Nothing)
			{
				result.BlendHint |= BlendHintValue.NoLens;
			}
			if (((stateA.BlendHint | stateB.BlendHint) & BlendHintValue.SphericalPositionBlend) != BlendHintValue.Nothing)
			{
				result.BlendHint |= BlendHintValue.SphericalPositionBlend;
			}
			if (((stateA.BlendHint | stateB.BlendHint) & BlendHintValue.CylindricalPositionBlend) != BlendHintValue.Nothing)
			{
				result.BlendHint |= BlendHintValue.CylindricalPositionBlend;
			}
			if (((stateA.BlendHint | stateB.BlendHint) & BlendHintValue.NoLens) == 0)
			{
				result.Lens = LensSettings.Lerp(stateA.Lens, stateB.Lens, t);
			}
			else if ((stateA.BlendHint & stateB.BlendHint & BlendHintValue.NoLens) == 0)
			{
				if ((stateA.BlendHint & BlendHintValue.NoLens) != BlendHintValue.Nothing)
				{
					result.Lens = stateB.Lens;
				}
				else
				{
					result.Lens = stateA.Lens;
				}
			}
			result.ReferenceUp = Vector3.Slerp(stateA.ReferenceUp, stateB.ReferenceUp, t);
			result.ShotQuality = Mathf.Lerp(stateA.ShotQuality, stateB.ShotQuality, t);
			result.PositionCorrection = ApplyPosBlendHint(stateA.PositionCorrection, stateA.BlendHint, stateB.PositionCorrection, stateB.BlendHint, result.PositionCorrection, Vector3.Lerp(stateA.PositionCorrection, stateB.PositionCorrection, t));
			result.OrientationCorrection = ApplyRotBlendHint(stateA.OrientationCorrection, stateA.BlendHint, stateB.OrientationCorrection, stateB.BlendHint, result.OrientationCorrection, Quaternion.Slerp(stateA.OrientationCorrection, stateB.OrientationCorrection, t));
			if (!stateA.HasLookAt || !stateB.HasLookAt)
			{
				result.ReferenceLookAt = kNoPoint;
			}
			else
			{
				float fieldOfView = stateA.Lens.FieldOfView;
				float fieldOfView2 = stateB.Lens.FieldOfView;
				if (((stateA.BlendHint | stateB.BlendHint) & BlendHintValue.NoLens) == 0 && !result.Lens.Orthographic && !Mathf.Approximately(fieldOfView, fieldOfView2))
				{
					LensSettings lens = result.Lens;
					lens.FieldOfView = InterpolateFOV(fieldOfView, fieldOfView2, Mathf.Max((stateA.ReferenceLookAt - stateA.CorrectedPosition).magnitude, stateA.Lens.NearClipPlane), Mathf.Max((stateB.ReferenceLookAt - stateB.CorrectedPosition).magnitude, stateB.Lens.NearClipPlane), t);
					result.Lens = lens;
					t2 = Mathf.Abs((lens.FieldOfView - fieldOfView) / (fieldOfView2 - fieldOfView));
				}
				result.ReferenceLookAt = Vector3.Lerp(stateA.ReferenceLookAt, stateB.ReferenceLookAt, t2);
			}
			result.RawPosition = ApplyPosBlendHint(stateA.RawPosition, stateA.BlendHint, stateB.RawPosition, stateB.BlendHint, result.RawPosition, result.InterpolatePosition(stateA.RawPosition, stateA.ReferenceLookAt, stateB.RawPosition, stateB.ReferenceLookAt, t));
			if (result.HasLookAt && ((stateA.BlendHint | stateB.BlendHint) & BlendHintValue.RadialAimBlend) != BlendHintValue.Nothing)
			{
				result.ReferenceLookAt = result.RawPosition + Vector3.Slerp(stateA.ReferenceLookAt - result.RawPosition, stateB.ReferenceLookAt - result.RawPosition, t2);
			}
			Quaternion blended = result.RawOrientation;
			if (((stateA.BlendHint | stateB.BlendHint) & BlendHintValue.NoOrientation) == 0)
			{
				Vector3 vector = Vector3.zero;
				if (result.HasLookAt && Quaternion.Angle(stateA.RawOrientation, stateB.RawOrientation) > 0.0001f)
				{
					vector = result.ReferenceLookAt - result.CorrectedPosition;
				}
				if (vector.AlmostZero() || ((stateA.BlendHint | stateB.BlendHint) & BlendHintValue.IgnoreLookAtTarget) != BlendHintValue.Nothing)
				{
					blended = Quaternion.Slerp(stateA.RawOrientation, stateB.RawOrientation, t);
				}
				else
				{
					Vector3 vector2 = result.ReferenceUp;
					vector.Normalize();
					if (Vector3.Cross(vector, vector2).AlmostZero())
					{
						blended = Quaternion.Slerp(stateA.RawOrientation, stateB.RawOrientation, t);
						vector2 = blended * Vector3.up;
					}
					blended = Quaternion.LookRotation(vector, vector2);
					Vector2 a = -stateA.RawOrientation.GetCameraRotationToTarget(stateA.ReferenceLookAt - stateA.CorrectedPosition, vector2);
					Vector2 b = -stateB.RawOrientation.GetCameraRotationToTarget(stateB.ReferenceLookAt - stateB.CorrectedPosition, vector2);
					blended = blended.ApplyCameraRotation(Vector2.Lerp(a, b, t2), vector2);
				}
			}
			result.RawOrientation = ApplyRotBlendHint(stateA.RawOrientation, stateA.BlendHint, stateB.RawOrientation, stateB.BlendHint, result.RawOrientation, blended);
			for (int i = 0; i < stateA.NumCustomBlendables; i++)
			{
				CustomBlendable customBlendable = stateA.GetCustomBlendable(i);
				customBlendable.m_Weight *= 1f - t;
				if (customBlendable.m_Weight > 0f)
				{
					result.AddCustomBlendable(customBlendable);
				}
			}
			for (int j = 0; j < stateB.NumCustomBlendables; j++)
			{
				CustomBlendable customBlendable2 = stateB.GetCustomBlendable(j);
				customBlendable2.m_Weight *= t;
				if (customBlendable2.m_Weight > 0f)
				{
					result.AddCustomBlendable(customBlendable2);
				}
			}
			return result;
		}

		private static float InterpolateFOV(float fovA, float fovB, float dA, float dB, float t)
		{
			float a = dA * 2f * Mathf.Tan(fovA * (MathF.PI / 180f) / 2f);
			float b = dB * 2f * Mathf.Tan(fovB * (MathF.PI / 180f) / 2f);
			float num = Mathf.Lerp(a, b, t);
			float value = 179f;
			float num2 = Mathf.Lerp(dA, dB, t);
			if (num2 > 0.0001f)
			{
				value = 2f * Mathf.Atan(num / (2f * num2)) * 57.29578f;
			}
			return Mathf.Clamp(value, Mathf.Min(fovA, fovB), Mathf.Max(fovA, fovB));
		}

		private static Vector3 ApplyPosBlendHint(Vector3 posA, BlendHintValue hintA, Vector3 posB, BlendHintValue hintB, Vector3 original, Vector3 blended)
		{
			if (((hintA | hintB) & BlendHintValue.NoPosition) == 0)
			{
				return blended;
			}
			if ((hintA & hintB & BlendHintValue.NoPosition) != BlendHintValue.Nothing)
			{
				return original;
			}
			if ((hintA & BlendHintValue.NoPosition) != BlendHintValue.Nothing)
			{
				return posB;
			}
			return posA;
		}

		private static Quaternion ApplyRotBlendHint(Quaternion rotA, BlendHintValue hintA, Quaternion rotB, BlendHintValue hintB, Quaternion original, Quaternion blended)
		{
			if (((hintA | hintB) & BlendHintValue.NoOrientation) == 0)
			{
				return blended;
			}
			if ((hintA & hintB & BlendHintValue.NoOrientation) != BlendHintValue.Nothing)
			{
				return original;
			}
			if ((hintA & BlendHintValue.NoOrientation) != BlendHintValue.Nothing)
			{
				return rotB;
			}
			return rotA;
		}

		private Vector3 InterpolatePosition(Vector3 posA, Vector3 pivotA, Vector3 posB, Vector3 pivotB, float t)
		{
			if (pivotA == pivotA && pivotB == pivotB)
			{
				if ((BlendHint & BlendHintValue.CylindricalPositionBlend) != BlendHintValue.Nothing)
				{
					Vector3 vector = Vector3.ProjectOnPlane(posA - pivotA, ReferenceUp);
					Vector3 vector2 = Vector3.ProjectOnPlane(posB - pivotB, ReferenceUp);
					Vector3 vector3 = Vector3.Slerp(vector, vector2, t);
					posA = posA - vector + vector3;
					posB = posB - vector2 + vector3;
				}
				else if ((BlendHint & BlendHintValue.SphericalPositionBlend) != BlendHintValue.Nothing)
				{
					Vector3 vector4 = Vector3.Slerp(posA - pivotA, posB - pivotB, t);
					posA = pivotA + vector4;
					posB = pivotB + vector4;
				}
			}
			return Vector3.Lerp(posA, posB, t);
		}
	}
	public class CinemachineBlend
	{
		public ICinemachineCamera CamA;

		public ICinemachineCamera CamB;

		public AnimationCurve BlendCurve;

		public float TimeInBlend;

		public float Duration;

		public float BlendWeight
		{
			get
			{
				if (BlendCurve == null || BlendCurve.length < 2 || IsComplete)
				{
					return 1f;
				}
				return Mathf.Clamp01(BlendCurve.Evaluate(TimeInBlend / Duration));
			}
		}

		public bool IsValid
		{
			get
			{
				if (CamA == null || !CamA.IsValid)
				{
					if (CamB != null)
					{
						return CamB.IsValid;
					}
					return false;
				}
				return true;
			}
		}

		public bool IsComplete
		{
			get
			{
				if (!(TimeInBlend >= Duration))
				{
					return !IsValid;
				}
				return true;
			}
		}

		public string Description
		{
			get
			{
				StringBuilder stringBuilder = CinemachineDebug.SBFromPool();
				if (CamB == null || !CamB.IsValid)
				{
					stringBuilder.Append("(none)");
				}
				else
				{
					stringBuilder.Append("[");
					stringBuilder.Append(CamB.Name);
					stringBuilder.Append("]");
				}
				stringBuilder.Append(" ");
				stringBuilder.Append((int)(BlendWeight * 100f));
				stringBuilder.Append("% from ");
				if (CamA == null || !CamA.IsValid)
				{
					stringBuilder.Append("(none)");
				}
				else
				{
					stringBuilder.Append("[");
					stringBuilder.Append(CamA.Name);
					stringBuilder.Append("]");
				}
				string result = stringBuilder.ToString();
				CinemachineDebug.ReturnToPool(stringBuilder);
				return result;
			}
		}

		public CameraState State
		{
			get
			{
				if (CamA == null || !CamA.IsValid)
				{
					if (CamB == null || !CamB.IsValid)
					{
						return CameraState.Default;
					}
					return CamB.State;
				}
				if (CamB == null || !CamB.IsValid)
				{
					return CamA.State;
				}
				return CameraState.Lerp(CamA.State, CamB.State, BlendWeight);
			}
		}

		public bool Uses(ICinemachineCamera cam)
		{
			if (cam == CamA || cam == CamB)
			{
				return true;
			}
			if (CamA is BlendSourceVirtualCamera blendSourceVirtualCamera && blendSourceVirtualCamera.Blend.Uses(cam))
			{
				return true;
			}
			if (CamB is BlendSourceVirtualCamera blendSourceVirtualCamera2 && blendSourceVirtualCamera2.Blend.Uses(cam))
			{
				return true;
			}
			return false;
		}

		public CinemachineBlend(ICinemachineCamera a, ICinemachineCamera b, AnimationCurve curve, float duration, float t)
		{
			CamA = a;
			CamB = b;
			BlendCurve = curve;
			TimeInBlend = t;
			Duration = duration;
		}

		public void UpdateCameraState(Vector3 worldUp, float deltaTime)
		{
			if (CamA != null && CamA.IsValid)
			{
				CamA.UpdateCameraState(worldUp, deltaTime);
			}
			if (CamB != null && CamB.IsValid)
			{
				CamB.UpdateCameraState(worldUp, deltaTime);
			}
		}
	}
	[Serializable]
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	public struct CinemachineBlendDefinition
	{
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public enum Style
		{
			Cut,
			EaseInOut,
			EaseIn,
			EaseOut,
			HardIn,
			HardOut,
			Linear,
			Custom
		}

		[Tooltip("Shape of the blend curve")]
		public Style m_Style;

		[Tooltip("Duration of the blend, in seconds")]
		public float m_Time;

		public AnimationCurve m_CustomCurve;

		private static AnimationCurve[] sStandardCurves;

		public float BlendTime
		{
			get
			{
				if (m_Style != Style.Cut)
				{
					return m_Time;
				}
				return 0f;
			}
		}

		public AnimationCurve BlendCurve
		{
			get
			{
				if (m_Style == Style.Custom)
				{
					if (m_CustomCurve == null)
					{
						m_CustomCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);
					}
					return m_CustomCurve;
				}
				if (sStandardCurves == null)
				{
					CreateStandardCurves();
				}
				return sStandardCurves[(int)m_Style];
			}
		}

		public CinemachineBlendDefinition(Style style, float time)
		{
			m_Style = style;
			m_Time = time;
			m_CustomCurve = null;
		}

		private void CreateStandardCurves()
		{
			sStandardCurves = new AnimationCurve[7];
			sStandardCurves[0] = null;
			sStandardCurves[1] = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);
			sStandardCurves[2] = AnimationCurve.Linear(0f, 0f, 1f, 1f);
			Keyframe[] keys = sStandardCurves[2].keys;
			keys[0].outTangent = 1.4f;
			keys[1].inTangent = 0f;
			sStandardCurves[2].keys = keys;
			sStandardCurves[3] = AnimationCurve.Linear(0f, 0f, 1f, 1f);
			keys = sStandardCurves[3].keys;
			keys[0].outTangent = 0f;
			keys[1].inTangent = 1.4f;
			sStandardCurves[3].keys = keys;
			sStandardCurves[4] = AnimationCurve.Linear(0f, 0f, 1f, 1f);
			keys = sStandardCurves[4].keys;
			keys[0].outTangent = 0f;
			keys[1].inTangent = 3f;
			sStandardCurves[4].keys = keys;
			sStandardCurves[5] = AnimationCurve.Linear(0f, 0f, 1f, 1f);
			keys = sStandardCurves[5].keys;
			keys[0].outTangent = 3f;
			keys[1].inTangent = 0f;
			sStandardCurves[5].keys = keys;
			sStandardCurves[6] = AnimationCurve.Linear(0f, 0f, 1f, 1f);
		}
	}
	internal class StaticPointVirtualCamera : ICinemachineCamera
	{
		public string Name { get; private set; }

		public string Description => "";

		public int Priority { get; set; }

		public Transform LookAt { get; set; }

		public Transform Follow { get; set; }

		public CameraState State { get; private set; }

		public GameObject VirtualCameraGameObject => null;

		public bool IsValid => true;

		public ICinemachineCamera ParentCamera => null;

		public StaticPointVirtualCamera(CameraState state, string name)
		{
			State = state;
			Name = name;
		}

		public void SetState(CameraState state)
		{
			State = state;
		}

		public bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly = false)
		{
			return false;
		}

		public void UpdateCameraState(Vector3 worldUp, float deltaTime)
		{
		}

		public void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
		{
		}

		public void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
		{
		}

		public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
		}
	}
	internal class BlendSourceVirtualCamera : ICinemachineCamera
	{
		public CinemachineBlend Blend { get; set; }

		public string Name => "Mid-blend";

		public string Description
		{
			get
			{
				if (Blend != null)
				{
					return Blend.Description;
				}
				return "(null)";
			}
		}

		public int Priority { get; set; }

		public Transform LookAt { get; set; }

		public Transform Follow { get; set; }

		public CameraState State { get; private set; }

		public GameObject VirtualCameraGameObject => null;

		public bool IsValid
		{
			get
			{
				if (Blend != null)
				{
					return Blend.IsValid;
				}
				return false;
			}
		}

		public ICinemachineCamera ParentCamera => null;

		public BlendSourceVirtualCamera(CinemachineBlend blend)
		{
			Blend = blend;
		}

		public bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly = false)
		{
			if (Blend != null)
			{
				if (vcam != Blend.CamA)
				{
					return vcam == Blend.CamB;
				}
				return true;
			}
			return false;
		}

		public CameraState CalculateNewState(float deltaTime)
		{
			return State;
		}

		public void UpdateCameraState(Vector3 worldUp, float deltaTime)
		{
			if (Blend != null)
			{
				Blend.UpdateCameraState(worldUp, deltaTime);
				State = Blend.State;
			}
		}

		public void InternalUpdateCameraState(Vector3 worldUp, float deltaTime)
		{
		}

		public void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
		{
		}

		public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
		}
	}
	[Serializable]
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineBlending.html")]
	public sealed class CinemachineBlenderSettings : ScriptableObject
	{
		[Serializable]
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public struct CustomBlend
		{
			[Tooltip("When blending from this camera")]
			public string m_From;

			[Tooltip("When blending to this camera")]
			public string m_To;

			[CinemachineBlendDefinitionProperty]
			[Tooltip("Blend curve definition")]
			public CinemachineBlendDefinition m_Blend;
		}

		[Tooltip("The array containing explicitly defined blends between two Virtual Cameras")]
		public CustomBlend[] m_CustomBlends;

		public const string kBlendFromAnyCameraLabel = "**ANY CAMERA**";

		public CinemachineBlendDefinition GetBlendForVirtualCameras(string fromCameraName, string toCameraName, CinemachineBlendDefinition defaultBlend)
		{
			bool flag = false;
			bool flag2 = false;
			CinemachineBlendDefinition result = defaultBlend;
			CinemachineBlendDefinition result2 = defaultBlend;
			if (m_CustomBlends != null)
			{
				for (int i = 0; i < m_CustomBlends.Length; i++)
				{
					CustomBlend customBlend = m_CustomBlends[i];
					if (customBlend.m_From == fromCameraName && customBlend.m_To == toCameraName)
					{
						return customBlend.m_Blend;
					}
					if (customBlend.m_From == "**ANY CAMERA**")
					{
						if (!string.IsNullOrEmpty(toCameraName) && customBlend.m_To == toCameraName)
						{
							if (!flag)
							{
								result = customBlend.m_Blend;
							}
							flag = true;
						}
						else if (customBlend.m_To == "**ANY CAMERA**")
						{
							defaultBlend = customBlend.m_Blend;
						}
					}
					else if (customBlend.m_To == "**ANY CAMERA**" && !string.IsNullOrEmpty(fromCameraName) && customBlend.m_From == fromCameraName)
					{
						if (!flag2)
						{
							result2 = customBlend.m_Blend;
						}
						flag2 = true;
					}
				}
			}
			if (flag)
			{
				return result;
			}
			if (flag2)
			{
				return result2;
			}
			return defaultBlend;
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.API)]
	public abstract class CinemachineComponentBase : MonoBehaviour
	{
		protected const float Epsilon = 0.0001f;

		private CinemachineVirtualCameraBase m_vcamOwner;

		public CinemachineVirtualCameraBase VirtualCamera
		{
			get
			{
				if (m_vcamOwner == null)
				{
					m_vcamOwner = GetComponent<CinemachineVirtualCameraBase>();
				}
				if (m_vcamOwner == null && base.transform.parent != null)
				{
					m_vcamOwner = base.transform.parent.GetComponent<CinemachineVirtualCameraBase>();
				}
				return m_vcamOwner;
			}
		}

		public Transform FollowTarget
		{
			get
			{
				CinemachineVirtualCameraBase virtualCamera = VirtualCamera;
				if (!(virtualCamera == null))
				{
					return virtualCamera.ResolveFollow(virtualCamera.Follow);
				}
				return null;
			}
		}

		public Transform LookAtTarget
		{
			get
			{
				CinemachineVirtualCameraBase virtualCamera = VirtualCamera;
				if (!(virtualCamera == null))
				{
					return virtualCamera.ResolveLookAt(virtualCamera.LookAt);
				}
				return null;
			}
		}

		public ICinemachineTargetGroup AbstractFollowTargetGroup
		{
			get
			{
				CinemachineVirtualCameraBase virtualCamera = VirtualCamera;
				if (!(virtualCamera == null))
				{
					return virtualCamera.AbstractFollowTargetGroup;
				}
				return null;
			}
		}

		public CinemachineTargetGroup FollowTargetGroup => AbstractFollowTargetGroup as CinemachineTargetGroup;

		public Vector3 FollowTargetPosition
		{
			get
			{
				CinemachineVirtualCameraBase followTargetAsVcam = VirtualCamera.FollowTargetAsVcam;
				if (followTargetAsVcam != null)
				{
					return followTargetAsVcam.State.FinalPosition;
				}
				Transform followTarget = FollowTarget;
				if (followTarget != null)
				{
					return TargetPositionCache.GetTargetPosition(followTarget);
				}
				return Vector3.zero;
			}
		}

		public Quaternion FollowTargetRotation
		{
			get
			{
				CinemachineVirtualCameraBase followTargetAsVcam = VirtualCamera.FollowTargetAsVcam;
				if (followTargetAsVcam != null)
				{
					return followTargetAsVcam.State.FinalOrientation;
				}
				Transform followTarget = FollowTarget;
				if (followTarget != null)
				{
					return TargetPositionCache.GetTargetRotation(followTarget);
				}
				return Quaternion.identity;
			}
		}

		public ICinemachineTargetGroup AbstractLookAtTargetGroup => VirtualCamera.AbstractLookAtTargetGroup;

		public CinemachineTargetGroup LookAtTargetGroup => AbstractLookAtTargetGroup as CinemachineTargetGroup;

		public Vector3 LookAtTargetPosition
		{
			get
			{
				CinemachineVirtualCameraBase lookAtTargetAsVcam = VirtualCamera.LookAtTargetAsVcam;
				if (lookAtTargetAsVcam != null)
				{
					return lookAtTargetAsVcam.State.FinalPosition;
				}
				Transform lookAtTarget = LookAtTarget;
				if (lookAtTarget != null)
				{
					return TargetPositionCache.GetTargetPosition(lookAtTarget);
				}
				return Vector3.zero;
			}
		}

		public Quaternion LookAtTargetRotation
		{
			get
			{
				CinemachineVirtualCameraBase lookAtTargetAsVcam = VirtualCamera.LookAtTargetAsVcam;
				if (lookAtTargetAsVcam != null)
				{
					return lookAtTargetAsVcam.State.FinalOrientation;
				}
				Transform lookAtTarget = LookAtTarget;
				if (lookAtTarget != null)
				{
					return TargetPositionCache.GetTargetRotation(lookAtTarget);
				}
				return Quaternion.identity;
			}
		}

		public CameraState VcamState
		{
			get
			{
				CinemachineVirtualCameraBase virtualCamera = VirtualCamera;
				if (!(virtualCamera == null))
				{
					return virtualCamera.State;
				}
				return CameraState.Default;
			}
		}

		public abstract bool IsValid { get; }

		public abstract CinemachineCore.Stage Stage { get; }

		public virtual bool BodyAppliesAfterAim => false;

		public virtual bool RequiresUserInput => false;

		public virtual void PrePipelineMutateCameraState(ref CameraState curState, float deltaTime)
		{
		}

		public abstract void MutateCameraState(ref CameraState curState, float deltaTime);

		public virtual bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime, ref CinemachineVirtualCameraBase.TransitionParams transitionParams)
		{
			return false;
		}

		public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
		}

		public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot)
		{
		}

		public virtual float GetMaxDampTime()
		{
			return 0f;
		}
	}
	internal static class Documentation
	{
		public const string BaseURL = "https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/";
	}
	public sealed class CinemachineCore
	{
		public enum Stage
		{
			Body,
			Aim,
			Noise,
			Finalize
		}

		public delegate float AxisInputDelegate(string axisName);

		public delegate CinemachineBlendDefinition GetBlendOverrideDelegate(ICinemachineCamera fromVcam, ICinemachineCamera toVcam, CinemachineBlendDefinition defaultBlend, MonoBehaviour owner);

		private class UpdateStatus
		{
			public int lastUpdateFrame;

			public int lastUpdateFixedFrame;

			public UpdateTracker.UpdateClock lastUpdateMode;

			public float lastUpdateDeltaTime;
		}

		internal enum UpdateFilter
		{
			Fixed = 0,
			Late = 1,
			Smart = 8,
			SmartFixed = 8,
			SmartLate = 9
		}

		public static readonly int kStreamingVersion = 20170927;

		private static CinemachineCore sInstance = null;

		public static bool sShowHiddenObjects = false;

		public static AxisInputDelegate GetInputAxis = Input.GetAxis;

		public static float UniformDeltaTimeOverride = -1f;

		public static float CurrentTimeOverride = -1f;

		public static GetBlendOverrideDelegate GetBlendOverride;

		public static CinemachineBrain.BrainEvent CameraUpdatedEvent = new CinemachineBrain.BrainEvent();

		public static CinemachineBrain.BrainEvent CameraCutEvent = new CinemachineBrain.BrainEvent();

		private List<CinemachineBrain> mActiveBrains = new List<CinemachineBrain>();

		internal static bool FrameDeltaCompensationEnabled = true;

		private List<CinemachineVirtualCameraBase> mActiveCameras = new List<CinemachineVirtualCameraBase>();

		private bool m_ActiveCamerasAreSorted;

		private int m_ActivationSequence;

		private List<List<CinemachineVirtualCameraBase>> mAllCameras = new List<List<CinemachineVirtualCameraBase>>();

		private CinemachineVirtualCameraBase mRoundRobinVcamLastFrame;

		private static float s_LastUpdateTime;

		private static int s_FixedFrameCount;

		private Dictionary<CinemachineVirtualCameraBase, UpdateStatus> mUpdateStatus;

		internal UpdateFilter m_CurrentUpdateFilter;

		public static CinemachineCore Instance
		{
			get
			{
				if (sInstance == null)
				{
					sInstance = new CinemachineCore();
				}
				return sInstance;
			}
		}

		public static float DeltaTime
		{
			get
			{
				if (!(UniformDeltaTimeOverride >= 0f))
				{
					return Time.deltaTime;
				}
				return UniformDeltaTimeOverride;
			}
		}

		public static float CurrentTime
		{
			get
			{
				if (!(CurrentTimeOverride >= 0f))
				{
					return Time.time;
				}
				return CurrentTimeOverride;
			}
		}

		public int BrainCount => mActiveBrains.Count;

		public int VirtualCameraCount => mActiveCameras.Count;

		public CinemachineBrain GetActiveBrain(int index)
		{
			return mActiveBrains[index];
		}

		internal void AddActiveBrain(CinemachineBrain brain)
		{
			RemoveActiveBrain(brain);
			mActiveBrains.Insert(0, brain);
		}

		internal void RemoveActiveBrain(CinemachineBrain brain)
		{
			mActiveBrains.Remove(brain);
		}

		public CinemachineVirtualCameraBase GetVirtualCamera(int index)
		{
			if (!m_ActiveCamerasAreSorted && mActiveCameras.Count > 1)
			{
				mActiveCameras.Sort((CinemachineVirtualCameraBase x, CinemachineVirtualCameraBase y) => (x.Priority != y.Priority) ? y.Priority.CompareTo(x.Priority) : y.m_ActivationId.CompareTo(x.m_ActivationId));
				m_ActiveCamerasAreSorted = true;
			}
			return mActiveCameras[index];
		}

		internal void AddActiveCamera(CinemachineVirtualCameraBase vcam)
		{
			Assert.IsFalse(mActiveCameras.Contains(vcam));
			vcam.m_ActivationId = m_ActivationSequence++;
			mActiveCameras.Add(vcam);
			m_ActiveCamerasAreSorted = false;
		}

		internal void RemoveActiveCamera(CinemachineVirtualCameraBase vcam)
		{
			if (mActiveCameras.Contains(vcam))
			{
				mActiveCameras.Remove(vcam);
			}
		}

		internal void CameraDestroyed(CinemachineVirtualCameraBase vcam)
		{
			if (mActiveCameras.Contains(vcam))
			{
				mActiveCameras.Remove(vcam);
			}
			if (mUpdateStatus != null && mUpdateStatus.ContainsKey(vcam))
			{
				mUpdateStatus.Remove(vcam);
			}
		}

		internal void CameraEnabled(CinemachineVirtualCameraBase vcam)
		{
			int num = 0;
			for (ICinemachineCamera parentCamera = vcam.ParentCamera; parentCamera != null; parentCamera = parentCamera.ParentCamera)
			{
				num++;
			}
			while (mAllCameras.Count <= num)
			{
				mAllCameras.Add(new List<CinemachineVirtualCameraBase>());
			}
			mAllCameras[num].Add(vcam);
		}

		internal void CameraDisabled(CinemachineVirtualCameraBase vcam)
		{
			for (int i = 0; i < mAllCameras.Count; i++)
			{
				mAllCameras[i].Remove(vcam);
			}
			if (mRoundRobinVcamLastFrame == vcam)
			{
				mRoundRobinVcamLastFrame = null;
			}
		}

		internal void UpdateAllActiveVirtualCameras(int layerMask, Vector3 worldUp, float deltaTime)
		{
			UpdateFilter currentUpdateFilter = m_CurrentUpdateFilter;
			bool flag = currentUpdateFilter != UpdateFilter.Smart;
			CinemachineVirtualCameraBase cinemachineVirtualCameraBase = mRoundRobinVcamLastFrame;
			float currentTime = CurrentTime;
			if (currentTime != s_LastUpdateTime)
			{
				s_LastUpdateTime = currentTime;
				if ((currentUpdateFilter & (UpdateFilter)(-9)) == 0)
				{
					s_FixedFrameCount++;
				}
			}
			for (int num = mAllCameras.Count - 1; num >= 0; num--)
			{
				List<CinemachineVirtualCameraBase> list = mAllCameras[num];
				for (int num2 = list.Count - 1; num2 >= 0; num2--)
				{
					CinemachineVirtualCameraBase cinemachineVirtualCameraBase2 = list[num2];
					if (flag && cinemachineVirtualCameraBase2 == mRoundRobinVcamLastFrame)
					{
						cinemachineVirtualCameraBase = null;
					}
					if (cinemachineVirtualCameraBase2 == null)
					{
						list.RemoveAt(num2);
					}
					else if (cinemachineVirtualCameraBase2.m_StandbyUpdate == CinemachineVirtualCameraBase.StandbyUpdateMode.Always || IsLive(cinemachineVirtualCameraBase2))
					{
						if (((1 << cinemachineVirtualCameraBase2.gameObject.layer) & layerMask) != 0)
						{
							UpdateVirtualCamera(cinemachineVirtualCameraBase2, worldUp, deltaTime);
						}
					}
					else if (cinemachineVirtualCameraBase == null && mRoundRobinVcamLastFrame != cinemachineVirtualCameraBase2 && flag && cinemachineVirtualCameraBase2.m_StandbyUpdate != CinemachineVirtualCameraBase.StandbyUpdateMode.Never && cinemachineVirtualCameraBase2.isActiveAndEnabled)
					{
						m_CurrentUpdateFilter &= (UpdateFilter)(-9);
						UpdateVirtualCamera(cinemachineVirtualCameraBase2, worldUp, deltaTime);
						m_CurrentUpdateFilter = currentUpdateFilter;
						cinemachineVirtualCameraBase = cinemachineVirtualCameraBase2;
					}
				}
			}
			if (flag)
			{
				if (cinemachineVirtualCameraBase == mRoundRobinVcamLastFrame)
				{
					cinemachineVirtualCameraBase = null;
				}
				mRoundRobinVcamLastFrame = cinemachineVirtualCameraBase;
			}
		}

		internal void UpdateVirtualCamera(CinemachineVirtualCameraBase vcam, Vector3 worldUp, float deltaTime)
		{
			if (vcam == null)
			{
				return;
			}
			bool num = (m_CurrentUpdateFilter & UpdateFilter.Smart) == UpdateFilter.Smart;
			UpdateTracker.UpdateClock updateClock = (UpdateTracker.UpdateClock)(m_CurrentUpdateFilter & (UpdateFilter)(-9));
			if (num)
			{
				Transform updateTarget = GetUpdateTarget(vcam);
				if (updateTarget == null || UpdateTracker.GetPreferredUpdate(updateTarget) != updateClock)
				{
					return;
				}
			}
			if (mUpdateStatus == null)
			{
				mUpdateStatus = new Dictionary<CinemachineVirtualCameraBase, UpdateStatus>();
			}
			if (!mUpdateStatus.TryGetValue(vcam, out var value))
			{
				value = new UpdateStatus
				{
					lastUpdateDeltaTime = -2f,
					lastUpdateMode = UpdateTracker.UpdateClock.Late,
					lastUpdateFrame = Time.frameCount + 2,
					lastUpdateFixedFrame = s_FixedFrameCount + 2
				};
				mUpdateStatus.Add(vcam, value);
			}
			int num2 = ((updateClock == UpdateTracker.UpdateClock.Late) ? (Time.frameCount - value.lastUpdateFrame) : (s_FixedFrameCount - value.lastUpdateFixedFrame));
			if (deltaTime >= 0f)
			{
				if (num2 == 0 && value.lastUpdateMode == updateClock && value.lastUpdateDeltaTime == deltaTime)
				{
					return;
				}
				if (FrameDeltaCompensationEnabled && num2 > 0)
				{
					deltaTime *= (float)num2;
				}
			}
			vcam.InternalUpdateCameraState(worldUp, deltaTime);
			value.lastUpdateFrame = Time.frameCount;
			value.lastUpdateFixedFrame = s_FixedFrameCount;
			value.lastUpdateMode = updateClock;
			value.lastUpdateDeltaTime = deltaTime;
		}

		[RuntimeInitializeOnLoadMethod]
		private static void InitializeModule()
		{
			Instance.mUpdateStatus = new Dictionary<CinemachineVirtualCameraBase, UpdateStatus>();
		}

		private static Transform GetUpdateTarget(CinemachineVirtualCameraBase vcam)
		{
			if (vcam == null || vcam.gameObject == null)
			{
				return null;
			}
			Transform lookAt = vcam.LookAt;
			if (lookAt != null)
			{
				return lookAt;
			}
			lookAt = vcam.Follow;
			if (lookAt != null)
			{
				return lookAt;
			}
			return vcam.transform;
		}

		internal UpdateTracker.UpdateClock GetVcamUpdateStatus(CinemachineVirtualCameraBase vcam)
		{
			if (mUpdateStatus == null || !mUpdateStatus.TryGetValue(vcam, out var value))
			{
				return UpdateTracker.UpdateClock.Late;
			}
			return value.lastUpdateMode;
		}

		public bool IsLive(ICinemachineCamera vcam)
		{
			if (vcam != null)
			{
				for (int i = 0; i < BrainCount; i++)
				{
					CinemachineBrain activeBrain = GetActiveBrain(i);
					if (activeBrain != null && activeBrain.IsLive(vcam))
					{
						return true;
					}
				}
			}
			return false;
		}

		public bool IsLiveInBlend(ICinemachineCamera vcam)
		{
			if (vcam != null)
			{
				for (int i = 0; i < BrainCount; i++)
				{
					CinemachineBrain activeBrain = GetActiveBrain(i);
					if (activeBrain != null && activeBrain.IsLiveInBlend(vcam))
					{
						return true;
					}
				}
			}
			return false;
		}

		public void GenerateCameraActivationEvent(ICinemachineCamera vcam, ICinemachineCamera vcamFrom)
		{
			if (vcam == null)
			{
				return;
			}
			for (int i = 0; i < BrainCount; i++)
			{
				CinemachineBrain activeBrain = GetActiveBrain(i);
				if (activeBrain != null && activeBrain.IsLive(vcam))
				{
					activeBrain.m_CameraActivatedEvent.Invoke(vcam, vcamFrom);
				}
			}
		}

		public void GenerateCameraCutEvent(ICinemachineCamera vcam)
		{
			if (vcam == null)
			{
				return;
			}
			for (int i = 0; i < BrainCount; i++)
			{
				CinemachineBrain activeBrain = GetActiveBrain(i);
				if (activeBrain != null && activeBrain.IsLive(vcam))
				{
					if (activeBrain.m_CameraCutEvent != null)
					{
						activeBrain.m_CameraCutEvent.Invoke(activeBrain);
					}
					if (CameraCutEvent != null)
					{
						CameraCutEvent.Invoke(activeBrain);
					}
				}
			}
		}

		public CinemachineBrain FindPotentialTargetBrain(CinemachineVirtualCameraBase vcam)
		{
			if (vcam != null)
			{
				int brainCount = BrainCount;
				for (int i = 0; i < brainCount; i++)
				{
					CinemachineBrain activeBrain = GetActiveBrain(i);
					if (activeBrain != null && activeBrain.OutputCamera != null && activeBrain.IsLive(vcam))
					{
						return activeBrain;
					}
				}
				int num = 1 << vcam.gameObject.layer;
				for (int j = 0; j < brainCount; j++)
				{
					CinemachineBrain activeBrain2 = GetActiveBrain(j);
					if (activeBrain2 != null && activeBrain2.OutputCamera != null && (activeBrain2.OutputCamera.cullingMask & num) != 0)
					{
						return activeBrain2;
					}
				}
			}
			return null;
		}

		public void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
			int virtualCameraCount = VirtualCameraCount;
			for (int i = 0; i < virtualCameraCount; i++)
			{
				GetVirtualCamera(i).OnTargetObjectWarped(target, positionDelta);
			}
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.API)]
	public abstract class CinemachineExtension : MonoBehaviour
	{
		protected const float Epsilon = 0.0001f;

		private CinemachineVirtualCameraBase m_vcamOwner;

		private Dictionary<ICinemachineCamera, object> mExtraState;

		public CinemachineVirtualCameraBase VirtualCamera
		{
			get
			{
				if (m_vcamOwner == null)
				{
					m_vcamOwner = GetComponent<CinemachineVirtualCameraBase>();
				}
				return m_vcamOwner;
			}
		}

		public virtual bool RequiresUserInput => false;

		protected virtual void Awake()
		{
			ConnectToVcam(connect: true);
		}

		protected virtual void OnEnable()
		{
		}

		protected virtual void OnDestroy()
		{
			ConnectToVcam(connect: false);
		}

		internal void EnsureStarted()
		{
			ConnectToVcam(connect: true);
		}

		protected virtual void ConnectToVcam(bool connect)
		{
			if (connect && VirtualCamera == null)
			{
				UnityEngine.Debug.LogError("CinemachineExtension requires a Cinemachine Virtual Camera component");
			}
			if (VirtualCamera != null)
			{
				if (connect)
				{
					VirtualCamera.AddExtension(this);
				}
				else
				{
					VirtualCamera.RemoveExtension(this);
				}
			}
			mExtraState = null;
		}

		public virtual void PrePipelineMutateCameraStateCallback(CinemachineVirtualCameraBase vcam, ref CameraState curState, float deltaTime)
		{
		}

		public void InvokePostPipelineStageCallback(CinemachineVirtualCameraBase vcam, CinemachineCore.Stage stage, ref CameraState state, float deltaTime)
		{
			PostPipelineStageCallback(vcam, stage, ref state, deltaTime);
		}

		protected abstract void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, CinemachineCore.Stage stage, ref CameraState state, float deltaTime);

		public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
		}

		public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot)
		{
		}

		public virtual bool OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
		{
			return false;
		}

		public virtual float GetMaxDampTime()
		{
			return 0f;
		}

		protected T GetExtraState<T>(ICinemachineCamera vcam) where T : class, new()
		{
			if (mExtraState == null)
			{
				mExtraState = new Dictionary<ICinemachineCamera, object>();
			}
			object value = null;
			if (!mExtraState.TryGetValue(vcam, out value))
			{
				object obj = (mExtraState[vcam] = new T());
				value = obj;
			}
			return value as T;
		}

		protected List<T> GetAllExtraStates<T>() where T : class, new()
		{
			List<T> list = new List<T>();
			if (mExtraState != null)
			{
				foreach (KeyValuePair<ICinemachineCamera, object> item in mExtraState)
				{
					list.Add(item.Value as T);
				}
			}
			return list;
		}
	}
	[Serializable]
	public struct AxisBase
	{
		[NoSaveDuringPlay]
		[Tooltip("The current value of the axis.")]
		public float m_Value;

		[Tooltip("The minimum value for the axis")]
		public float m_MinValue;

		[Tooltip("The maximum value for the axis")]
		public float m_MaxValue;

		[Tooltip("If checked, then the axis will wrap around at the min/max values, forming a loop")]
		public bool m_Wrap;

		public void Validate()
		{
			m_MaxValue = Mathf.Clamp(m_MaxValue, m_MinValue, m_MaxValue);
		}
	}
	[Serializable]
	public struct CinemachineInputAxisDriver
	{
		[Tooltip("Multiply the input by this amount prior to processing.  Controls the input power.")]
		public float multiplier;

		[Tooltip("The amount of time in seconds it takes to accelerate to a higher speed")]
		public float accelTime;

		[Tooltip("The amount of time in seconds it takes to decelerate to a lower speed")]
		public float decelTime;

		[Tooltip("The name of this axis as specified in Unity Input manager. Setting to an empty string will disable the automatic updating of this axis")]
		public string name;

		[NoSaveDuringPlay]
		[Tooltip("The value of the input axis.  A value of 0 means no input.  You can drive this directly from a custom input system, or you can set the Axis Name and have the value driven by the internal Input Manager")]
		public float inputValue;

		private float mCurrentSpeed;

		private const float Epsilon = 0.0001f;

		public void Validate()
		{
			accelTime = Mathf.Max(0f, accelTime);
			decelTime = Mathf.Max(0f, decelTime);
		}

		public bool Update(float deltaTime, ref AxisBase axis)
		{
			if (!string.IsNullOrEmpty(name))
			{
				try
				{
					inputValue = CinemachineCore.GetInputAxis(name);
				}
				catch (ArgumentException)
				{
				}
			}
			float num = inputValue * multiplier;
			if (deltaTime < 0.0001f)
			{
				mCurrentSpeed = 0f;
			}
			else
			{
				float num2 = num / deltaTime;
				float dampTime = ((Mathf.Abs(num2) < Mathf.Abs(mCurrentSpeed)) ? decelTime : accelTime);
				num2 = (mCurrentSpeed += Damper.Damp(num2 - mCurrentSpeed, dampTime, deltaTime));
				float num3 = axis.m_MaxValue - axis.m_MinValue;
				if (!axis.m_Wrap && decelTime > 0.0001f && num3 > 0.0001f)
				{
					float num4 = ClampValue(ref axis, axis.m_Value);
					float num5 = ClampValue(ref axis, num4 + num2 * deltaTime);
					if (((num2 > 0f) ? (axis.m_MaxValue - num5) : (num5 - axis.m_MinValue)) < 0.1f * num3 && Mathf.Abs(num2) > 0.0001f)
					{
						num2 = Damper.Damp(num5 - num4, decelTime, deltaTime) / deltaTime;
					}
				}
				num = num2 * deltaTime;
			}
			axis.m_Value = ClampValue(ref axis, axis.m_Value + num);
			return Mathf.Abs(inputValue) > 0.0001f;
		}

		public bool Update(float deltaTime, ref AxisState axis)
		{
			AxisBase axis2 = new AxisBase
			{
				m_Value = axis.Value,
				m_MinValue = axis.m_MinValue,
				m_MaxValue = axis.m_MaxValue,
				m_Wrap = axis.m_Wrap
			};
			bool result = Update(deltaTime, ref axis2);
			axis.Value = axis2.m_Value;
			return result;
		}

		private float ClampValue(ref AxisBase axis, float v)
		{
			float num = axis.m_MaxValue - axis.m_MinValue;
			if (axis.m_Wrap && num > 0.0001f)
			{
				v = (v - axis.m_MinValue) % num;
				v += axis.m_MinValue + ((v < 0f) ? num : 0f);
			}
			return Mathf.Clamp(v, axis.m_MinValue, axis.m_MaxValue);
		}
	}
	public abstract class CinemachinePathBase : MonoBehaviour
	{
		[Serializable]
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public class Appearance
		{
			[Tooltip("The color of the path itself when it is active in the editor")]
			public Color pathColor = Color.green;

			[Tooltip("The color of the path itself when it is inactive in the editor")]
			public Color inactivePathColor = Color.gray;

			[Tooltip("The width of the railroad-tracks that are drawn to represent the path")]
			[Range(0f, 10f)]
			public float width = 0.2f;
		}

		public enum PositionUnits
		{
			PathUnits,
			Distance,
			Normalized
		}

		[Tooltip("Path samples per waypoint.  This is used for calculating path distances.")]
		[Range(1f, 100f)]
		public int m_Resolution = 20;

		[Tooltip("The settings that control how the path will appear in the editor scene view.")]
		public Appearance m_Appearance = new Appearance();

		private float[] m_DistanceToPos;

		private float[] m_PosToDistance;

		private int m_CachedSampleSteps;

		private float m_PathLength;

		private float m_cachedPosStepSize;

		private float m_cachedDistanceStepSize;

		public abstract float MinPos { get; }

		public abstract float MaxPos { get; }

		public abstract bool Looped { get; }

		public abstract int DistanceCacheSampleStepsPerSegment { get; }

		public float PathLength
		{
			get
			{
				if (DistanceCacheSampleStepsPerSegment < 1)
				{
					return 0f;
				}
				if (!DistanceCacheIsValid())
				{
					ResamplePath(DistanceCacheSampleStepsPerSegment);
				}
				return m_PathLength;
			}
		}

		public virtual float StandardizePos(float pos)
		{
			if (Looped && MaxPos > 0f)
			{
				pos %= MaxPos;
				if (pos < 0f)
				{
					pos += MaxPos;
				}
				return pos;
			}
			return Mathf.Clamp(pos, 0f, MaxPos);
		}

		public virtual Vector3 EvaluatePosition(float pos)
		{
			return base.transform.TransformPoint(EvaluateLocalPosition(pos));
		}

		public virtual Vector3 EvaluateTangent(float pos)
		{
			return base.transform.TransformDirection(EvaluateLocalTangent(pos));
		}

		public virtual Quaternion EvaluateOrientation(float pos)
		{
			return base.transform.rotation * EvaluateLocalOrientation(pos);
		}

		public abstract Vector3 EvaluateLocalPosition(float pos);

		public abstract Vector3 EvaluateLocalTangent(float pos);

		public abstract Quaternion EvaluateLocalOrientation(float pos);

		public virtual float FindClosestPoint(Vector3 p, int startSegment, int searchRadius, int stepsPerSegment)
		{
			float num = MinPos;
			float num2 = MaxPos;
			if (searchRadius >= 0)
			{
				if (Looped)
				{
					int num3 = Mathf.Min(searchRadius, Mathf.FloorToInt((num2 - num) / 2f));
					num = startSegment - num3;
					num2 = startSegment + num3 + 1;
				}
				else
				{
					num = Mathf.Max(startSegment - searchRadius, MinPos);
					num2 = Mathf.Min(startSegment + searchRadius + 1, MaxPos);
				}
			}
			stepsPerSegment = Mathf.RoundToInt(Mathf.Clamp(stepsPerSegment, 1f, 100f));
			float num4 = 1f / (float)stepsPerSegment;
			float num5 = startSegment;
			float num6 = float.MaxValue;
			int num7 = ((stepsPerSegment == 1) ? 1 : 3);
			for (int i = 0; i < num7; i++)
			{
				Vector3 vector = EvaluatePosition(num);
				for (float num8 = num + num4; num8 <= num2; num8 += num4)
				{
					Vector3 vector2 = EvaluatePosition(num8);
					float num9 = p.ClosestPointOnSegment(vector, vector2);
					float num10 = Vector3.SqrMagnitude(p - Vector3.Lerp(vector, vector2, num9));
					if (num10 < num6)
					{
						num6 = num10;
						num5 = num8 - (1f - num9) * num4;
					}
					vector = vector2;
				}
				num = num5 - num4;
				num2 = num5 + num4;
				num4 /= (float)stepsPerSegment;
			}
			return num5;
		}

		public float MinUnit(PositionUnits units)
		{
			return units switch
			{
				PositionUnits.Normalized => 0f, 
				PositionUnits.Distance => 0f, 
				_ => MinPos, 
			};
		}

		public float MaxUnit(PositionUnits units)
		{
			return units switch
			{
				PositionUnits.Normalized => 1f, 
				PositionUnits.Distance => PathLength, 
				_ => MaxPos, 
			};
		}

		public virtual float StandardizeUnit(float pos, PositionUnits units)
		{
			switch (units)
			{
			case PositionUnits.PathUnits:
				return StandardizePos(pos);
			case PositionUnits.Distance:
				return StandardizePathDistance(pos);
			default:
			{
				float pathLength = PathLength;
				if (pathLength < 0.0001f)
				{
					return 0f;
				}
				return StandardizePathDistance(pos * pathLength) / pathLength;
			}
			}
		}

		public Vector3 EvaluatePositionAtUnit(float pos, PositionUnits units)
		{
			return EvaluatePosition(ToNativePathUnits(pos, units));
		}

		public Vector3 EvaluateTangentAtUnit(float pos, PositionUnits units)
		{
			return EvaluateTangent(ToNativePathUnits(pos, units));
		}

		public Quaternion EvaluateOrientationAtUnit(float pos, PositionUnits units)
		{
			return EvaluateOrientation(ToNativePathUnits(pos, units));
		}

		public virtual void InvalidateDistanceCache()
		{
			m_DistanceToPos = null;
			m_PosToDistance = null;
			m_CachedSampleSteps = 0;
			m_PathLength = 0f;
		}

		public bool DistanceCacheIsValid()
		{
			if (MaxPos != MinPos)
			{
				if (m_DistanceToPos != null && m_PosToDistance != null && m_CachedSampleSteps == DistanceCacheSampleStepsPerSegment)
				{
					return m_CachedSampleSteps > 0;
				}
				return false;
			}
			return true;
		}

		public float StandardizePathDistance(float distance)
		{
			float pathLength = PathLength;
			if (pathLength < 1E-05f)
			{
				return 0f;
			}
			if (Looped)
			{
				distance %= pathLength;
				if (distance < 0f)
				{
					distance += pathLength;
				}
			}
			return Mathf.Clamp(distance, 0f, pathLength);
		}

		public float ToNativePathUnits(float pos, PositionUnits units)
		{
			if (units == PositionUnits.PathUnits)
			{
				return pos;
			}
			if (DistanceCacheSampleStepsPerSegment < 1 || PathLength < 0.0001f)
			{
				return MinPos;
			}
			if (units == PositionUnits.Normalized)
			{
				pos *= PathLength;
			}
			pos = StandardizePathDistance(pos);
			float num = pos / m_cachedDistanceStepSize;
			int num2 = Mathf.FloorToInt(num);
			if (num2 >= m_DistanceToPos.Length - 1)
			{
				return MaxPos;
			}
			float t = num - (float)num2;
			return MinPos + Mathf.Lerp(m_DistanceToPos[num2], m_DistanceToPos[num2 + 1], t);
		}

		public float FromPathNativeUnits(float pos, PositionUnits units)
		{
			if (units == PositionUnits.PathUnits)
			{
				return pos;
			}
			float pathLength = PathLength;
			if (DistanceCacheSampleStepsPerSegment < 1 || pathLength < 0.0001f)
			{
				return 0f;
			}
			pos = StandardizePos(pos);
			float num = pos / m_cachedPosStepSize;
			int num2 = Mathf.FloorToInt(num);
			if (num2 >= m_PosToDistance.Length - 1)
			{
				pos = m_PathLength;
			}
			else
			{
				float t = num - (float)num2;
				pos = Mathf.Lerp(m_PosToDistance[num2], m_PosToDistance[num2 + 1], t);
			}
			if (units == PositionUnits.Normalized)
			{
				pos /= pathLength;
			}
			return pos;
		}

		private void ResamplePath(int stepsPerSegment)
		{
			InvalidateDistanceCache();
			float minPos = MinPos;
			float maxPos = MaxPos;
			float num = 1f / (float)Mathf.Max(1, stepsPerSegment);
			int num2 = Mathf.RoundToInt((maxPos - minPos) / num) + 1;
			m_PosToDistance = new float[num2];
			m_CachedSampleSteps = stepsPerSegment;
			m_cachedPosStepSize = num;
			Vector3 a = EvaluatePosition(0f);
			m_PosToDistance[0] = 0f;
			float num3 = minPos;
			for (int i = 1; i < num2; i++)
			{
				num3 += num;
				Vector3 vector = EvaluatePosition(num3);
				float num4 = Vector3.Distance(a, vector);
				m_PathLength += num4;
				a = vector;
				m_PosToDistance[i] = m_PathLength;
			}
			m_DistanceToPos = new float[num2];
			m_DistanceToPos[0] = 0f;
			if (num2 <= 1)
			{
				return;
			}
			num = (m_cachedDistanceStepSize = m_PathLength / (float)(num2 - 1));
			float num5 = 0f;
			int num6 = 1;
			for (int j = 1; j < num2; j++)
			{
				num5 += num;
				float num7 = m_PosToDistance[num6];
				while (num7 < num5 && num6 < num2 - 1)
				{
					num7 = m_PosToDistance[++num6];
				}
				float num8 = m_PosToDistance[num6 - 1];
				float num9 = num7 - num8;
				float num10 = (num5 - num8) / num9;
				m_DistanceToPos[j] = m_cachedPosStepSize * (num10 + (float)num6 - 1f);
			}
		}
	}
	public sealed class AxisStatePropertyAttribute : PropertyAttribute
	{
	}
	public sealed class OrbitalTransposerHeadingPropertyAttribute : PropertyAttribute
	{
	}
	public sealed class LensSettingsPropertyAttribute : PropertyAttribute
	{
	}
	public sealed class VcamTargetPropertyAttribute : PropertyAttribute
	{
	}
	public sealed class CinemachineBlendDefinitionPropertyAttribute : PropertyAttribute
	{
	}
	public sealed class SaveDuringPlayAttribute : Attribute
	{
	}
	public sealed class NoSaveDuringPlayAttribute : PropertyAttribute
	{
	}
	public sealed class TagFieldAttribute : PropertyAttribute
	{
	}
	public sealed class NoiseSettingsPropertyAttribute : PropertyAttribute
	{
	}
	public sealed class CinemachineEmbeddedAssetPropertyAttribute : PropertyAttribute
	{
		public bool WarnIfNull;

		public CinemachineEmbeddedAssetPropertyAttribute(bool warnIfNull = false)
		{
			WarnIfNull = warnIfNull;
		}
	}
	[DocumentationSorting(Level.Undoc)]
	public sealed class DocumentationSortingAttribute : Attribute
	{
		public enum Level
		{
			Undoc,
			API,
			UserRef
		}

		public Level Category { get; private set; }

		public DocumentationSortingAttribute(Level category)
		{
			Category = category;
		}
	}
	[SaveDuringPlay]
	public abstract class CinemachineVirtualCameraBase : MonoBehaviour, ICinemachineCamera, ISerializationCallbackReceiver
	{
		public enum StandbyUpdateMode
		{
			Never,
			Always,
			RoundRobin
		}

		public enum BlendHint
		{
			None,
			SphericalPosition,
			CylindricalPosition,
			ScreenSpaceAimWhenTargetsDiffer
		}

		[Serializable]
		public struct TransitionParams
		{
			[Tooltip("Hint for blending positions to and from this virtual camera")]
			[FormerlySerializedAs("m_PositionBlending")]
			public BlendHint m_BlendHint;

			[Tooltip("When this virtual camera goes Live, attempt to force the position to be the same as the current position of the Unity Camera")]
			public bool m_InheritPosition;

			[Tooltip("This event fires when the virtual camera goes Live")]
			public CinemachineBrain.VcamActivatedEvent m_OnCameraLive;
		}

		[HideInInspector]
		[SerializeField]
		[NoSaveDuringPlay]
		public string[] m_ExcludedPropertiesInInspector = new string[1] { "m_Script" };

		[HideInInspector]
		[SerializeField]
		[NoSaveDuringPlay]
		public CinemachineCore.Stage[] m_LockStageInInspector;

		private int m_ValidatingStreamVersion;

		private bool m_OnValidateCalled;

		[HideInInspector]
		[SerializeField]
		[NoSaveDuringPlay]
		private int m_StreamingVersion;

		[NoSaveDuringPlay]
		[Tooltip("The priority will determine which camera becomes active based on the state of other cameras and this camera.  Higher numbers have greater priority.")]
		public int m_Priority = 10;

		internal int m_ActivationId;

		[NonSerialized]
		public float FollowTargetAttachment;

		[NonSerialized]
		public float LookAtTargetAttachment;

		[Tooltip("When the virtual camera is not live, this is how often the virtual camera will be updated.  Set this to tune for performance. Most of the time Never is fine, unless the virtual camera is doing shot evaluation.")]
		public StandbyUpdateMode m_StandbyUpdate = StandbyUpdateMode.RoundRobin;

		private bool m_WasStarted;

		private bool mSlaveStatusUpdated;

		private CinemachineVirtualCameraBase m_parentVcam;

		private int m_QueuePriority = int.MaxValue;

		private float m_blendStartPosition;

		private Transform m_CachedFollowTarget;

		private CinemachineVirtualCameraBase m_CachedFollowTargetVcam;

		private ICinemachineTargetGroup m_CachedFollowTargetGroup;

		private Transform m_CachedLookAtTarget;

		private CinemachineVirtualCameraBase m_CachedLookAtTargetVcam;

		private ICinemachineTargetGroup m_CachedLookAtTargetGroup;

		public int ValidatingStreamVersion
		{
			get
			{
				if (!m_OnValidateCalled)
				{
					return CinemachineCore.kStreamingVersion;
				}
				return m_ValidatingStreamVersion;
			}
			private set
			{
				m_ValidatingStreamVersion = value;
			}
		}

		internal List<CinemachineExtension> mExtensions { get; private set; }

		public string Name => base.name;

		public virtual string Description => "";

		public int Priority
		{
			get
			{
				return m_Priority;
			}
			set
			{
				m_Priority = value;
			}
		}

		public GameObject VirtualCameraGameObject
		{
			get
			{
				if (this == null)
				{
					return null;
				}
				return base.gameObject;
			}
		}

		public bool IsValid => !(this == null);

		public abstract CameraState State { get; }

		public ICinemachineCamera ParentCamera
		{
			get
			{
				if (!mSlaveStatusUpdated || !Application.isPlaying)
				{
					UpdateSlaveStatus();
				}
				return m_parentVcam;
			}
		}

		public abstract Transform LookAt { get; set; }

		public abstract Transform Follow { get; set; }

		public virtual bool PreviousStateIsValid { get; set; }

		public bool FollowTargetChanged { get; private set; }

		public bool LookAtTargetChanged { get; private set; }

		public ICinemachineTargetGroup AbstractFollowTargetGroup => m_CachedFollowTargetGroup;

		public CinemachineVirtualCameraBase FollowTargetAsVcam => m_CachedFollowTargetVcam;

		public ICinemachineTargetGroup AbstractLookAtTargetGroup => m_CachedLookAtTargetGroup;

		public CinemachineVirtualCameraBase LookAtTargetAsVcam => m_CachedLookAtTargetVcam;

		public virtual float GetMaxDampTime()
		{
			float num = 0f;
			if (mExtensions != null)
			{
				for (int i = 0; i < mExtensions.Count; i++)
				{
					num = Mathf.Max(num, mExtensions[i].GetMaxDampTime());
				}
			}
			return num;
		}

		public float DetachedFollowTargetDamp(float initial, float dampTime, float deltaTime)
		{
			dampTime = Mathf.Lerp(Mathf.Max(1f, dampTime), dampTime, FollowTargetAttachment);
			deltaTime = Mathf.Lerp(0f, deltaTime, FollowTargetAttachment);
			return Damper.Damp(initial, dampTime, deltaTime);
		}

		public Vector3 DetachedFollowTargetDamp(Vector3 initial, Vector3 dampTime, float deltaTime)
		{
			dampTime = Vector3.Lerp(Vector3.Max(Vector3.one, dampTime), dampTime, FollowTargetAttachment);
			deltaTime = Mathf.Lerp(0f, deltaTime, FollowTargetAttachment);
			return Damper.Damp(initial, dampTime, deltaTime);
		}

		public Vector3 DetachedFollowTargetDamp(Vector3 initial, float dampTime, float deltaTime)
		{
			dampTime = Mathf.Lerp(Mathf.Max(1f, dampTime), dampTime, FollowTargetAttachment);
			deltaTime = Mathf.Lerp(0f, deltaTime, FollowTargetAttachment);
			return Damper.Damp(initial, dampTime, deltaTime);
		}

		public float DetachedLookAtTargetDamp(float initial, float dampTime, float deltaTime)
		{
			dampTime = Mathf.Lerp(Mathf.Max(1f, dampTime), dampTime, LookAtTargetAttachment);
			deltaTime = Mathf.Lerp(0f, deltaTime, LookAtTargetAttachment);
			return Damper.Damp(initial, dampTime, deltaTime);
		}

		public Vector3 DetachedLookAtTargetDamp(Vector3 initial, Vector3 dampTime, float deltaTime)
		{
			dampTime = Vector3.Lerp(Vector3.Max(Vector3.one, dampTime), dampTime, LookAtTargetAttachment);
			deltaTime = Mathf.Lerp(0f, deltaTime, LookAtTargetAttachment);
			return Damper.Damp(initial, dampTime, deltaTime);
		}

		public Vector3 DetachedLookAtTargetDamp(Vector3 initial, float dampTime, float deltaTime)
		{
			dampTime = Mathf.Lerp(Mathf.Max(1f, dampTime), dampTime, LookAtTargetAttachment);
			deltaTime = Mathf.Lerp(0f, deltaTime, LookAtTargetAttachment);
			return Damper.Damp(initial, dampTime, deltaTime);
		}

		public virtual void AddExtension(CinemachineExtension extension)
		{
			if (mExtensions == null)
			{
				mExtensions = new List<CinemachineExtension>();
			}
			else
			{
				mExtensions.Remove(extension);
			}
			mExtensions.Add(extension);
		}

		public virtual void RemoveExtension(CinemachineExtension extension)
		{
			if (mExtensions != null)
			{
				mExtensions.Remove(extension);
			}
		}

		protected void InvokePostPipelineStageCallback(CinemachineVirtualCameraBase vcam, CinemachineCore.Stage stage, ref CameraState newState, float deltaTime)
		{
			if (mExtensions != null)
			{
				for (int i = 0; i < mExtensions.Count; i++)
				{
					CinemachineExtension cinemachineExtension = mExtensions[i];
					if (cinemachineExtension == null)
					{
						mExtensions.RemoveAt(i);
						i--;
					}
					else if (cinemachineExtension.enabled)
					{
						cinemachineExtension.InvokePostPipelineStageCallback(vcam, stage, ref newState, deltaTime);
					}
				}
			}
			CinemachineVirtualCameraBase cinemachineVirtualCameraBase = ParentCamera as CinemachineVirtualCameraBase;
			if (cinemachineVirtualCameraBase != null)
			{
				cinemachineVirtualCameraBase.InvokePostPipelineStageCallback(vcam, stage, ref newState, deltaTime);
			}
		}

		protected void InvokePrePipelineMutateCameraStateCallback(CinemachineVirtualCameraBase vcam, ref CameraState newState, float deltaTime)
		{
			if (mExtensions != null)
			{
				for (int i = 0; i < mExtensions.Count; i++)
				{
					CinemachineExtension cinemachineExtension = mExtensions[i];
					if (cinemachineExtension == null)
					{
						mExtensions.RemoveAt(i);
						i--;
					}
					else if (cinemachineExtension.enabled)
					{
						cinemachineExtension.PrePipelineMutateCameraStateCallback(vcam, ref newState, deltaTime);
					}
				}
			}
			CinemachineVirtualCameraBase cinemachineVirtualCameraBase = ParentCamera as CinemachineVirtualCameraBase;
			if (cinemachineVirtualCameraBase != null)
			{
				cinemachineVirtualCameraBase.InvokePrePipelineMutateCameraStateCallback(vcam, ref newState, deltaTime);
			}
		}

		protected bool InvokeOnTransitionInExtensions(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
		{
			bool result = false;
			if (mExtensions != null)
			{
				for (int i = 0; i < mExtensions.Count; i++)
				{
					CinemachineExtension cinemachineExtension = mExtensions[i];
					if (cinemachineExtension == null)
					{
						mExtensions.RemoveAt(i);
						i--;
					}
					else if (cinemachineExtension.enabled && cinemachineExtension.OnTransitionFromCamera(fromCam, worldUp, deltaTime))
					{
						result = true;
					}
				}
			}
			return result;
		}

		protected void ApplyPositionBlendMethod(ref CameraState state, BlendHint hint)
		{
			switch (hint)
			{
			case BlendHint.SphericalPosition:
				state.BlendHint |= CameraState.BlendHintValue.SphericalPositionBlend;
				break;
			case BlendHint.CylindricalPosition:
				state.BlendHint |= CameraState.BlendHintValue.CylindricalPositionBlend;
				break;
			case BlendHint.ScreenSpaceAimWhenTargetsDiffer:
				state.BlendHint |= CameraState.BlendHintValue.RadialAimBlend;
				break;
			}
		}

		public virtual bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly = false)
		{
			return false;
		}

		public void UpdateCameraState(Vector3 worldUp, float deltaTime)
		{
			CinemachineCore.Instance.UpdateVirtualCamera(this, worldUp, deltaTime);
		}

		public abstract void InternalUpdateCameraState(Vector3 worldUp, float deltaTime);

		public virtual void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime)
		{
			if (!base.gameObject.activeInHierarchy)
			{
				PreviousStateIsValid = false;
			}
		}

		protected virtual void OnDestroy()
		{
			CinemachineCore.Instance.CameraDestroyed(this);
		}

		protected virtual void OnTransformParentChanged()
		{
			CinemachineCore.Instance.CameraDisabled(this);
			CinemachineCore.Instance.CameraEnabled(this);
			UpdateSlaveStatus();
			UpdateVcamPoolStatus();
		}

		protected virtual void Start()
		{
			m_WasStarted = true;
		}

		internal virtual bool RequiresUserInput()
		{
			if (mExtensions != null)
			{
				return mExtensions.Any((CinemachineExtension extension) => extension != null && extension.RequiresUserInput);
			}
			return false;
		}

		internal void EnsureStarted()
		{
			if (!m_WasStarted)
			{
				m_WasStarted = true;
				CinemachineExtension[] componentsInChildren = GetComponentsInChildren<CinemachineExtension>();
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					componentsInChildren[i].EnsureStarted();
				}
			}
		}

		public AxisState.IInputAxisProvider GetInputAxisProvider()
		{
			MonoBehaviour[] componentsInChildren = GetComponentsInChildren<MonoBehaviour>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (componentsInChildren[i] is AxisState.IInputAxisProvider result)
				{
					return result;
				}
			}
			return null;
		}

		protected virtual void OnValidate()
		{
			m_OnValidateCalled = true;
			ValidatingStreamVersion = m_StreamingVersion;
			m_StreamingVersion = CinemachineCore.kStreamingVersion;
		}

		protected virtual void OnEnable()
		{
			UpdateSlaveStatus();
			UpdateVcamPoolStatus();
			if (!CinemachineCore.Instance.IsLive(this))
			{
				PreviousStateIsValid = false;
			}
			CinemachineCore.Instance.CameraEnabled(this);
			InvalidateCachedTargets();
			CinemachineVirtualCameraBase[] components = GetComponents<CinemachineVirtualCameraBase>();
			for (int i = 0; i < components.Length; i++)
			{
				if (components[i].enabled && components[i] != this)
				{
					UnityEngine.Debug.LogError(Name + " has multiple CinemachineVirtualCameraBase-derived components.  Disabling " + GetType().Name + ".");
					base.enabled = false;
				}
			}
		}

		protected virtual void OnDisable()
		{
			UpdateVcamPoolStatus();
			CinemachineCore.Instance.CameraDisabled(this);
		}

		protected virtual void Update()
		{
			if (m_Priority != m_QueuePriority)
			{
				UpdateVcamPoolStatus();
			}
		}

		private void UpdateSlaveStatus()
		{
			mSlaveStatusUpdated = true;
			m_parentVcam = null;
			Transform parent = base.transform.parent;
			if (parent != null)
			{
				parent.TryGetComponent<CinemachineVirtualCameraBase>(out m_parentVcam);
			}
		}

		public Transform ResolveLookAt(Transform localLookAt)
		{
			Transform transform = localLookAt;
			if (transform == null && ParentCamera != null)
			{
				transform = ParentCamera.LookAt;
			}
			return transform;
		}

		public Transform ResolveFollow(Transform localFollow)
		{
			Transform transform = localFollow;
			if (transform == null && ParentCamera != null)
			{
				transform = ParentCamera.Follow;
			}
			return transform;
		}

		private void UpdateVcamPoolStatus()
		{
			CinemachineCore.Instance.RemoveActiveCamera(this);
			if (m_parentVcam == null && base.isActiveAndEnabled)
			{
				CinemachineCore.Instance.AddActiveCamera(this);
			}
			m_QueuePriority = m_Priority;
		}

		public void MoveToTopOfPrioritySubqueue()
		{
			UpdateVcamPoolStatus();
		}

		public virtual void OnTargetObjectWarped(Transform target, Vector3 positionDelta)
		{
			if (mExtensions != null)
			{
				for (int i = 0; i < mExtensions.Count; i++)
				{
					mExtensions[i].OnTargetObjectWarped(target, positionDelta);
				}
			}
		}

		public virtual void ForceCameraPosition(Vector3 pos, Quaternion rot)
		{
			if (mExtensions != null)
			{
				for (int i = 0; i < mExtensions.Count; i++)
				{
					mExtensions[i].ForceCameraPosition(pos, rot);
				}
			}
		}

		private bool GetInheritPosition(ICinemachineCamera cam)
		{
			if (cam is CinemachineVirtualCamera)
			{
				return (cam as CinemachineVirtualCamera).m_Transitions.m_InheritPosition;
			}
			if (cam is CinemachineFreeLook)
			{
				return (cam as CinemachineFreeLook).m_Transitions.m_InheritPosition;
			}
			return false;
		}

		protected CinemachineBlend CreateBlend(ICinemachineCamera camA, ICinemachineCamera camB, CinemachineBlendDefinition blendDef, CinemachineBlend activeBlend)
		{
			if (blendDef.BlendCurve == null || blendDef.BlendTime <= 0f || (camA == null && camB == null))
			{
				m_blendStartPosition = 0f;
				return null;
			}
			if (activeBlend != null)
			{
				if (activeBlend != null && !activeBlend.IsComplete && activeBlend.CamA == camB && activeBlend.CamB == camA)
				{
					float num = m_blendStartPosition + (1f - m_blendStartPosition) * activeBlend.TimeInBlend / activeBlend.Duration;
					blendDef.m_Time *= num;
					m_blendStartPosition = 1f - num;
				}
				else
				{
					m_blendStartPosition = 0f;
				}
				camA = ((!GetInheritPosition(camB)) ? new BlendSourceVirtualCamera(activeBlend) : null);
			}
			if (camA == null)
			{
				camA = new StaticPointVirtualCamera(State, "(none)");
			}
			return new CinemachineBlend(camA, camB, blendDef.BlendCurve, blendDef.BlendTime, 0f);
		}

		protected CameraState PullStateFromVirtualCamera(Vector3 worldUp, ref LensSettings lens)
		{
			CameraState result = CameraState.Default;
			result.RawPosition = TargetPositionCache.GetTargetPosition(base.transform);
			result.RawOrientation = TargetPositionCache.GetTargetRotation(base.transform);
			result.ReferenceUp = worldUp;
			CinemachineBrain cinemachineBrain = CinemachineCore.Instance.FindPotentialTargetBrain(this);
			if (cinemachineBrain != null)
			{
				lens.SnapshotCameraReadOnlyProperties(cinemachineBrain.OutputCamera);
			}
			result.Lens = lens;
			return result;
		}

		private void InvalidateCachedTargets()
		{
			m_CachedFollowTarget = null;
			m_CachedFollowTargetVcam = null;
			m_CachedFollowTargetGroup = null;
			m_CachedLookAtTarget = null;
			m_CachedLookAtTargetVcam = null;
			m_CachedLookAtTargetGroup = null;
		}

		protected void UpdateTargetCache()
		{
			Transform transform = ResolveFollow(Follow);
			FollowTargetChanged = transform != m_CachedFollowTarget;
			if (FollowTargetChanged)
			{
				m_CachedFollowTarget = transform;
				m_CachedFollowTargetVcam = null;
				m_CachedFollowTargetGroup = null;
				if (m_CachedFollowTarget != null)
				{
					transform.TryGetComponent<CinemachineVirtualCameraBase>(out m_CachedFollowTargetVcam);
					transform.TryGetComponent<ICinemachineTargetGroup>(out m_CachedFollowTargetGroup);
				}
			}
			transform = ResolveLookAt(LookAt);
			LookAtTargetChanged = transform != m_CachedLookAtTarget;
			if (LookAtTargetChanged)
			{
				m_CachedLookAtTarget = transform;
				m_CachedLookAtTargetVcam = null;
				m_CachedLookAtTargetGroup = null;
				if (transform != null)
				{
					transform.TryGetComponent<CinemachineVirtualCameraBase>(out m_CachedLookAtTargetVcam);
					transform.TryGetComponent<ICinemachineTargetGroup>(out m_CachedLookAtTargetGroup);
				}
			}
		}

		void ISerializationCallbackReceiver.OnBeforeSerialize()
		{
			OnBeforeSerialize();
		}

		void ISerializationCallbackReceiver.OnAfterDeserialize()
		{
			if (m_StreamingVersion < CinemachineCore.kStreamingVersion)
			{
				LegacyUpgrade(m_StreamingVersion);
			}
			m_StreamingVersion = CinemachineCore.kStreamingVersion;
		}

		protected internal virtual void LegacyUpgrade(int streamedVersion)
		{
		}

		internal virtual void OnBeforeSerialize()
		{
		}

		public void CancelDamping(bool updateNow = false)
		{
			PreviousStateIsValid = false;
			if (updateNow)
			{
				Vector3 worldUp = State.ReferenceUp;
				CinemachineBrain cinemachineBrain = CinemachineCore.Instance.FindPotentialTargetBrain(this);
				if (cinemachineBrain != null)
				{
					worldUp = cinemachineBrain.DefaultWorldUp;
				}
				InternalUpdateCameraState(worldUp, -1f);
			}
		}
	}
	internal class ConfinerOven
	{
		public class BakedSolution
		{
			private float m_FrustumSizeIntSpace;

			private readonly AspectStretcher m_AspectStretcher;

			private readonly bool m_HasBones;

			private readonly double m_SqrPolygonDiagonal;

			private List<List<ClipperLib.IntPoint>> m_OriginalPolygon;

			private List<List<ClipperLib.IntPoint>> m_Solution;

			private const double k_ClipperEpsilon = 1000.0;

			public BakedSolution(float aspectRatio, float frustumHeight, bool hasBones, Rect polygonBounds, List<List<ClipperLib.IntPoint>> originalPolygon, List<List<ClipperLib.IntPoint>> solution)
			{
				m_AspectStretcher = new AspectStretcher(aspectRatio, polygonBounds.center.x);
				m_FrustumSizeIntSpace = frustumHeight * 100000f;
				m_HasBones = hasBones;
				m_OriginalPolygon = originalPolygon;
				m_Solution = solution;
				float num = polygonBounds.width / aspectRatio * 100000f;
				float num2 = polygonBounds.height * 100000f;
				m_SqrPolygonDiagonal = num * num + num2 * num2;
			}

			public bool IsValid()
			{
				return m_Solution != null;
			}

			public Vector2 ConfinePoint(in Vector2 pointToConfine)
			{
				if (m_Solution.Count <= 0)
				{
					return pointToConfine;
				}
				Vector2 vector = m_AspectStretcher.Stretch(pointToConfine);
				ClipperLib.IntPoint intPoint = new ClipperLib.IntPoint(vector.x * 100000f, vector.y * 100000f);
				for (int i = 0; i < m_Solution.Count; i++)
				{
					if (ClipperLib.Clipper.PointInPolygon(intPoint, m_Solution[i]) != 0)
					{
						return pointToConfine;
					}
				}
				bool flag = m_HasBones && IsInsideOriginal(intPoint);
				ClipperLib.IntPoint intPoint2 = intPoint;
				double num = double.MaxValue;
				for (int j = 0; j < m_Solution.Count; j++)
				{
					int count = m_Solution[j].Count;
					for (int k = 0; k < count; k++)
					{
						ClipperLib.IntPoint intPoint3 = m_Solution[j][k];
						ClipperLib.IntPoint intPoint4 = m_Solution[j][(k + 1) % count];
						ClipperLib.IntPoint intPoint5 = IntPointLerp(intPoint3, intPoint4, ClosestPointOnSegment(intPoint, intPoint3, intPoint4));
						double num2 = Mathf.Abs(intPoint.X - intPoint5.X);
						double num3 = Mathf.Abs(intPoint.Y - intPoint5.Y);
						double num4 = num2 * num2 + num3 * num3;
						if (num2 > (double)m_FrustumSizeIntSpace || num3 > (double)m_FrustumSizeIntSpace)
						{
							num4 += m_SqrPolygonDiagonal;
						}
						if (num4 < num && (!flag || !DoesIntersectOriginal(intPoint, intPoint5)))
						{
							num = num4;
							intPoint2 = intPoint5;
						}
					}
				}
				Vector2 p = new Vector2((float)intPoint2.X * 1E-05f, (float)intPoint2.Y * 1E-05f);
				return m_AspectStretcher.Unstretch(p);
				static float ClosestPointOnSegment(ClipperLib.IntPoint point, ClipperLib.IntPoint s0, ClipperLib.IntPoint s1)
				{
					double num5 = s1.X - s0.X;
					double num6 = s1.Y - s0.Y;
					double num7 = num5 * num5 + num6 * num6;
					if (num7 < 1000.0)
					{
						return 0f;
					}
					double num8 = point.X - s0.X;
					double num9 = point.Y - s0.Y;
					return Mathf.Clamp01((float)((num8 * num5 + num9 * num6) / num7));
				}
				bool DoesIntersectOriginal(ClipperLib.IntPoint l1, ClipperLib.IntPoint l2)
				{
					foreach (List<ClipperLib.IntPoint> item in m_OriginalPolygon)
					{
						int count2 = item.Count;
						for (int m = 0; m < count2; m++)
						{
							if (FindIntersection(in l1, in l2, item[m], item[(m + 1) % count2]) == 2)
							{
								return true;
							}
						}
					}
					return false;
				}
				static ClipperLib.IntPoint IntPointLerp(ClipperLib.IntPoint a, ClipperLib.IntPoint b, float lerp)
				{
					return new ClipperLib.IntPoint
					{
						X = Mathf.RoundToInt((float)a.X + (float)(b.X - a.X) * lerp),
						Y = Mathf.RoundToInt((float)a.Y + (float)(b.Y - a.Y) * lerp)
					};
				}
				bool IsInsideOriginal(ClipperLib.IntPoint point)
				{
					return m_OriginalPolygon.Any((List<ClipperLib.IntPoint> t) => ClipperLib.Clipper.PointInPolygon(point, t) != 0);
				}
			}

			private static int FindIntersection(in ClipperLib.IntPoint p1, in ClipperLib.IntPoint p2, in ClipperLib.IntPoint p3, in ClipperLib.IntPoint p4)
			{
				double num = p2.X - p1.X;
				double num2 = p2.Y - p1.Y;
				double num3 = p4.X - p3.X;
				double num4 = p4.Y - p3.Y;
				double num5 = num2 * num3 - num * num4;
				double num6 = ((double)(p1.X - p3.X) * num4 + (double)(p3.Y - p1.Y) * num3) / num5;
				if (double.IsInfinity(num6) || double.IsNaN(num6))
				{
					if (IntPointDiffSqrMagnitude(p1, p3) < 1000.0 || IntPointDiffSqrMagnitude(p1, p4) < 1000.0 || IntPointDiffSqrMagnitude(p2, p3) < 1000.0 || IntPointDiffSqrMagnitude(p2, p4) < 1000.0)
					{
						return 2;
					}
					return 0;
				}
				double num7 = ((double)(p3.X - p1.X) * num2 + (double)(p1.Y - p3.Y) * num) / (0.0 - num5);
				if (!(num6 >= 0.0) || !(num6 <= 1.0) || !(num7 >= 0.0) || !(num7 < 1.0))
				{
					return 1;
				}
				return 2;
				static double IntPointDiffSqrMagnitude(ClipperLib.IntPoint point1, ClipperLib.IntPoint point2)
				{
					double num8 = point1.X - point2.X;
					double num9 = point1.Y - point2.Y;
					return num8 * num8 + num9 * num9;
				}
			}
		}

		private readonly struct AspectStretcher
		{
			private readonly float m_InverseAspect;

			private readonly float m_CenterX;

			public float Aspect { get; }

			public AspectStretcher(float aspect, float centerX)
			{
				Aspect = aspect;
				m_InverseAspect = 1f / Aspect;
				m_CenterX = centerX;
			}

			public Vector2 Stretch(Vector2 p)
			{
				return new Vector2((p.x - m_CenterX) * m_InverseAspect + m_CenterX, p.y);
			}

			public Vector2 Unstretch(Vector2 p)
			{
				return new Vector2((p.x - m_CenterX) * Aspect + m_CenterX, p.y);
			}
		}

		private struct PolygonSolution
		{
			public List<List<ClipperLib.IntPoint>> polygons;

			public float frustumHeight;

			public bool IsNull => polygons == null;

			public bool StateChanged(in List<List<ClipperLib.IntPoint>> paths)
			{
				if (paths.Count != polygons.Count)
				{
					return true;
				}
				for (int i = 0; i < paths.Count; i++)
				{
					if (paths[i].Count != polygons[i].Count)
					{
						return true;
					}
				}
				return false;
			}
		}

		public enum BakingState
		{
			BAKING,
			BAKED,
			TIMEOUT
		}

		private struct BakingStateCache
		{
			public ClipperLib.ClipperOffset offsetter;

			public List<PolygonSolution> solutions;

			public PolygonSolution rightCandidate;

			public PolygonSolution leftCandidate;

			public List<List<ClipperLib.IntPoint>> maxCandidate;

			public float stepSize;

			public float maxFrustumHeight;

			public float userSetMaxFrustumHeight;

			public float theoriticalMaxFrustumHeight;

			public float currentFrustumHeight;

			public float bakeTime;
		}

		private float m_MinFrustumHeightWithBones;

		private float m_SkeletonPadding;

		private List<List<ClipperLib.IntPoint>> m_OriginalPolygon;

		private ClipperLib.IntPoint m_MidPoint;

		private List<List<ClipperLib.IntPoint>> m_Skeleton = new List<List<ClipperLib.IntPoint>>();

		private const long k_FloatToIntScaler = 100000L;

		private const float k_IntToFloatScaler = 1E-05f;

		private const float k_MinStepSize = 0.0005f;

		private Rect m_PolygonRect;

		private AspectStretcher m_AspectStretcher = new AspectStretcher(1f, 0f);

		private float m_MaxComputationTimeForFullSkeletonBakeInSeconds = 5f;

		public float bakeProgress;

		private BakingStateCache m_Cache;

		public BakingState State { get; private set; }

		public ConfinerOven(in List<List<Vector2>> inputPath, in float aspectRatio, float maxFrustumHeight, float skeletonPadding)
		{
			Initialize(in inputPath, in aspectRatio, maxFrustumHeight, Mathf.Max(0f, skeletonPadding) + 1f);
		}

		public BakedSolution GetBakedSolution(float frustumHeight)
		{
			frustumHeight = ((m_Cache.userSetMaxFrustumHeight <= 0f) ? frustumHeight : Mathf.Min(m_Cache.userSetMaxFrustumHeight, frustumHeight));
			if (State == BakingState.BAKED && frustumHeight > m_Cache.theoriticalMaxFrustumHeight)
			{
				return new BakedSolution(m_AspectStretcher.Aspect, frustumHeight, hasBones: false, m_PolygonRect, m_OriginalPolygon, new List<List<ClipperLib.IntPoint>>
				{
					new List<ClipperLib.IntPoint> { m_MidPoint }
				});
			}
			ClipperLib.ClipperOffset clipperOffset = new ClipperLib.ClipperOffset();
			clipperOffset.AddPaths(m_OriginalPolygon, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);
			List<List<ClipperLib.IntPoint>> solution = new List<List<ClipperLib.IntPoint>>();
			clipperOffset.Execute(ref solution, -1f * frustumHeight * 100000f);
			List<List<ClipperLib.IntPoint>> solution2 = new List<List<ClipperLib.IntPoint>>();
			if (State == BakingState.BAKING || m_Skeleton.Count == 0)
			{
				solution2 = solution;
			}
			else
			{
				ClipperLib.Clipper clipper = new ClipperLib.Clipper();
				clipper.AddPaths(solution, ClipperLib.PolyType.ptSubject, closed: true);
				clipper.AddPaths(m_Skeleton, ClipperLib.PolyType.ptClip, closed: true);
				clipper.Execute(ClipperLib.ClipType.ctUnion, solution2, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);
			}
			return new BakedSolution(m_AspectStretcher.Aspect, frustumHeight, m_MinFrustumHeightWithBones < frustumHeight, m_PolygonRect, m_OriginalPolygon, solution2);
		}

		private void Initialize(in List<List<Vector2>> inputPath, in float aspectRatio, float maxFrustumHeight, float skeletonPadding)
		{
			m_Skeleton.Clear();
			m_Cache.userSetMaxFrustumHeight = maxFrustumHeight;
			m_MinFrustumHeightWithBones = float.MaxValue;
			m_SkeletonPadding = skeletonPadding;
			m_PolygonRect = GetPolygonBoundingBox(in inputPath);
			m_AspectStretcher = new AspectStretcher(aspectRatio, m_PolygonRect.center.x);
			m_Cache.theoriticalMaxFrustumHeight = Mathf.Max(m_PolygonRect.width / aspectRatio, m_PolygonRect.height) / 2f;
			m_OriginalPolygon = new List<List<ClipperLib.IntPoint>>(inputPath.Count);
			for (int i = 0; i < inputPath.Count; i++)
			{
				List<Vector2> list = inputPath[i];
				int count = list.Count;
				List<ClipperLib.IntPoint> list2 = new List<ClipperLib.IntPoint>(count);
				for (int j = 0; j < count; j++)
				{
					Vector2 vector = m_AspectStretcher.Stretch(list[j]);
					list2.Add(new ClipperLib.IntPoint(vector.x * 100000f, vector.y * 100000f));
				}
				m_OriginalPolygon.Add(list2);
			}
			m_MidPoint = MidPointOfIntRect(ClipperLib.ClipperBase.GetBounds(m_OriginalPolygon));
			if (m_Cache.userSetMaxFrustumHeight < 0f)
			{
				State = BakingState.BAKED;
				return;
			}
			m_Cache.maxFrustumHeight = m_Cache.userSetMaxFrustumHeight;
			if (m_Cache.maxFrustumHeight == 0f || m_Cache.maxFrustumHeight > m_Cache.theoriticalMaxFrustumHeight)
			{
				m_Cache.maxFrustumHeight = m_Cache.theoriticalMaxFrustumHeight;
			}
			m_Cache.stepSize = m_Cache.maxFrustumHeight;
			m_Cache.offsetter = new ClipperLib.ClipperOffset();
			m_Cache.offsetter.AddPaths(m_OriginalPolygon, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);
			List<List<ClipperLib.IntPoint>> solution = new List<List<ClipperLib.IntPoint>>();
			m_Cache.offsetter.Execute(ref solution, 0.0);
			m_Cache.solutions = new List<PolygonSolution>();
			m_Cache.solutions.Add(new PolygonSolution
			{
				polygons = solution,
				frustumHeight = 0f
			});
			m_Cache.rightCandidate = default(PolygonSolution);
			m_Cache.leftCandidate = new PolygonSolution
			{
				polygons = solution,
				frustumHeight = 0f
			};
			m_Cache.currentFrustumHeight = 0f;
			m_Cache.maxCandidate = new List<List<ClipperLib.IntPoint>>();
			m_Cache.offsetter.Execute(ref m_Cache.maxCandidate, -1f * m_Cache.theoriticalMaxFrustumHeight * 100000f);
			m_Cache.bakeTime = 0f;
			State = BakingState.BAKING;
			bakeProgress = 0f;
			static Rect GetPolygonBoundingBox(in List<List<Vector2>> polygons)
			{
				float num = float.PositiveInfinity;
				float num2 = float.NegativeInfinity;
				float num3 = float.PositiveInfinity;
				float num4 = float.NegativeInfinity;
				for (int k = 0; k < polygons.Count; k++)
				{
					for (int l = 0; l < polygons[k].Count; l++)
					{
						Vector2 vector2 = polygons[k][l];
						num = Mathf.Min(num, vector2.x);
						num2 = Mathf.Max(num2, vector2.x);
						num3 = Mathf.Min(num3, vector2.y);
						num4 = Mathf.Max(num4, vector2.y);
					}
				}
				return new Rect(num, num3, Mathf.Max(0f, num2 - num), Mathf.Max(0f, num4 - num3));
			}
			static ClipperLib.IntPoint MidPointOfIntRect(ClipperLib.IntRect bounds)
			{
				return new ClipperLib.IntPoint((bounds.left + bounds.right) / 2, (bounds.top + bounds.bottom) / 2);
			}
		}

		public void BakeConfiner(float maxComputationTimePerFrameInSeconds)
		{
			if (State != BakingState.BAKING)
			{
				return;
			}
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			while (m_Cache.solutions.Count < 1000)
			{
				List<List<ClipperLib.IntPoint>> solution = new List<List<ClipperLib.IntPoint>>(m_Cache.leftCandidate.polygons.Count);
				m_Cache.stepSize = Mathf.Min(m_Cache.stepSize, m_Cache.maxFrustumHeight - m_Cache.leftCandidate.frustumHeight);
				m_Cache.currentFrustumHeight = m_Cache.leftCandidate.frustumHeight + m_Cache.stepSize;
				if (Math.Abs(m_Cache.currentFrustumHeight - m_Cache.maxFrustumHeight) < 0.0001f)
				{
					solution = m_Cache.maxCandidate;
				}
				else
				{
					m_Cache.offsetter.Execute(ref solution, -1f * m_Cache.currentFrustumHeight * 100000f);
				}
				if (m_Cache.leftCandidate.StateChanged(in solution))
				{
					m_Cache.rightCandidate = new PolygonSolution
					{
						polygons = solution,
						frustumHeight = m_Cache.currentFrustumHeight
					};
					m_Cache.stepSize = Mathf.Max(m_Cache.stepSize / 2f, 0.0005f);
				}
				else
				{
					m_Cache.leftCandidate = new PolygonSolution
					{
						polygons = solution,
						frustumHeight = m_Cache.currentFrustumHeight
					};
					if (!m_Cache.rightCandidate.IsNull)
					{
						m_Cache.stepSize = Mathf.Max(m_Cache.stepSize / 2f, 0.0005f);
					}
				}
				if (!m_Cache.rightCandidate.IsNull && m_Cache.stepSize <= 0.0005f)
				{
					m_Cache.solutions.Add(m_Cache.leftCandidate);
					m_Cache.solutions.Add(m_Cache.rightCandidate);
					m_Cache.leftCandidate = m_Cache.rightCandidate;
					m_Cache.rightCandidate = default(PolygonSolution);
					m_Cache.stepSize = m_Cache.maxFrustumHeight;
				}
				else if (m_Cache.rightCandidate.IsNull || m_Cache.leftCandidate.frustumHeight >= m_Cache.maxFrustumHeight)
				{
					m_Cache.solutions.Add(m_Cache.leftCandidate);
					break;
				}
				float num = Time.realtimeSinceStartup - realtimeSinceStartup;
				if (num > maxComputationTimePerFrameInSeconds)
				{
					m_Cache.bakeTime += num;
					if (m_Cache.bakeTime > m_MaxComputationTimeForFullSkeletonBakeInSeconds)
					{
						State = BakingState.TIMEOUT;
					}
					bakeProgress = m_Cache.leftCandidate.frustumHeight / m_Cache.maxFrustumHeight;
					return;
				}
			}
			ComputeSkeleton(in m_Cache.solutions);
			for (int num2 = m_Cache.solutions.Count - 1; num2 >= 0; num2--)
			{
				if (m_Cache.solutions[num2].polygons.Count == 0)
				{
					m_Cache.solutions.RemoveAt(num2);
				}
			}
			bakeProgress = 1f;
			State = BakingState.BAKED;
			void ComputeSkeleton(in List<PolygonSolution> solutions)
			{
				ClipperLib.Clipper clipper = new ClipperLib.Clipper();
				ClipperLib.ClipperOffset clipperOffset = new ClipperLib.ClipperOffset();
				for (int i = 1; i < solutions.Count - 1; i += 2)
				{
					PolygonSolution polygonSolution = solutions[i];
					PolygonSolution polygonSolution2 = solutions[i + 1];
					double num3 = m_SkeletonPadding * 100000f * (polygonSolution2.frustumHeight - polygonSolution.frustumHeight);
					List<List<ClipperLib.IntPoint>> solution2 = new List<List<ClipperLib.IntPoint>>();
					clipperOffset.Clear();
					clipperOffset.AddPaths(polygonSolution.polygons, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);
					clipperOffset.Execute(ref solution2, num3);
					List<List<ClipperLib.IntPoint>> solution3 = new List<List<ClipperLib.IntPoint>>();
					clipperOffset.Clear();
					clipperOffset.AddPaths(polygonSolution2.polygons, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);
					clipperOffset.Execute(ref solution3, num3 * 2.0);
					List<List<ClipperLib.IntPoint>> list = new List<List<ClipperLib.IntPoint>>();
					clipper.Clear();
					clipper.AddPaths(solution2, ClipperLib.PolyType.ptSubject, closed: true);
					clipper.AddPaths(solution3, ClipperLib.PolyType.ptClip, closed: true);
					clipper.Execute(ClipperLib.ClipType.ctDifference, list, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);
					if (list.Count > 0 && list[0].Count > 0)
					{
						m_Skeleton.AddRange(list);
						if (m_MinFrustumHeightWithBones == float.MaxValue)
						{
							m_MinFrustumHeightWithBones = polygonSolution2.frustumHeight;
						}
					}
				}
			}
		}
	}
	public interface ICinemachineCamera
	{
		string Name { get; }

		string Description { get; }

		int Priority { get; set; }

		Transform LookAt { get; set; }

		Transform Follow { get; set; }

		CameraState State { get; }

		GameObject VirtualCameraGameObject { get; }

		bool IsValid { get; }

		ICinemachineCamera ParentCamera { get; }

		bool IsLiveChild(ICinemachineCamera vcam, bool dominantChildOnly = false);

		void UpdateCameraState(Vector3 worldUp, float deltaTime);

		void InternalUpdateCameraState(Vector3 worldUp, float deltaTime);

		void OnTransitionFromCamera(ICinemachineCamera fromCam, Vector3 worldUp, float deltaTime);

		void OnTargetObjectWarped(Transform target, Vector3 positionDelta);
	}
	[Serializable]
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	public struct LensSettings
	{
		public enum OverrideModes
		{
			None,
			Orthographic,
			Perspective,
			Physical
		}

		public static LensSettings Default = new LensSettings(40f, 10f, 0.1f, 5000f, 0f);

		[Range(1f, 179f)]
		[Tooltip("This is the camera view in degrees. Display will be in vertical degress, unless the associated camera has its FOV axis setting set to Horizontal, in which case display will be in horizontal degress.  Internally, it is always vertical degrees.  For cinematic people, a 50mm lens on a super-35mm sensor would equal a 19.6 degree FOV")]
		public float FieldOfView;

		[Tooltip("When using an orthographic camera, this defines the half-height, in world coordinates, of the camera view.")]
		public float OrthographicSize;

		[Tooltip("This defines the near region in the renderable range of the camera frustum. Raising this value will stop the game from drawing things near the camera, which can sometimes come in handy.  Larger values will also increase your shadow resolution.")]
		public float NearClipPlane;

		[Tooltip("This defines the far region of the renderable range of the camera frustum. Typically you want to set this value as low as possible without cutting off desired distant objects")]
		public float FarClipPlane;

		[Range(-180f, 180f)]
		[Tooltip("Camera Z roll, or tilt, in degrees.")]
		public float Dutch;

		[Tooltip("Allows you to select a different camera mode to apply to the Camera component when Cinemachine activates this Virtual Camera.  The changes applied to the Camera component through this setting will remain after the Virtual Camera deactivation.")]
		public OverrideModes ModeOverride;

		public Vector2 LensShift;

		public Camera.GateFitMode GateFit;

		public float FocusDistance;

		[SerializeField]
		private Vector2 m_SensorSize;

		private bool m_OrthoFromCamera;

		private bool m_PhysicalFromCamera;

		public bool Orthographic
		{
			get
			{
				if (ModeOverride != OverrideModes.Orthographic)
				{
					if (ModeOverride == OverrideModes.None)
					{
						return m_OrthoFromCamera;
					}
					return false;
				}
				return true;
			}
			set
			{
				m_OrthoFromCamera = value;
				ModeOverride = (value ? OverrideModes.Orthographic : OverrideModes.Perspective);
			}
		}

		public Vector2 SensorSize
		{
			get
			{
				return m_SensorSize;
			}
			set
			{
				m_SensorSize = value;
			}
		}

		public float Aspect
		{
			get
			{
				if (SensorSize.y != 0f)
				{
					return SensorSize.x / SensorSize.y;
				}
				return 1f;
			}
		}

		public bool IsPhysicalCamera
		{
			get
			{
				if (ModeOverride != OverrideModes.Physical)
				{
					if (ModeOverride == OverrideModes.None)
					{
						return m_PhysicalFromCamera;
					}
					return false;
				}
				return true;
			}
			set
			{
				m_PhysicalFromCamera = value;
				ModeOverride = (value ? OverrideModes.Physical : OverrideModes.Perspective);
			}
		}

		public static LensSettings FromCamera(Camera fromCamera)
		{
			LensSettings result = Default;
			if (fromCamera != null)
			{
				result.FieldOfView = fromCamera.fieldOfView;
				result.OrthographicSize = fromCamera.orthographicSize;
				result.NearClipPlane = fromCamera.nearClipPlane;
				result.FarClipPlane = fromCamera.farClipPlane;
				result.LensShift = fromCamera.lensShift;
				result.GateFit = fromCamera.gateFit;
				result.FocusDistance = fromCamera.focusDistance;
				result.SnapshotCameraReadOnlyProperties(fromCamera);
			}
			return result;
		}

		public void SnapshotCameraReadOnlyProperties(Camera camera)
		{
			m_OrthoFromCamera = false;
			m_PhysicalFromCamera = false;
			if (camera != null && ModeOverride == OverrideModes.None)
			{
				m_OrthoFromCamera = camera.orthographic;
				m_PhysicalFromCamera = camera.usePhysicalProperties;
				m_SensorSize = camera.sensorSize;
				GateFit = camera.gateFit;
			}
			if (IsPhysicalCamera)
			{
				if (camera != null && m_SensorSize == Vector2.zero)
				{
					m_SensorSize = camera.sensorSize;
					GateFit = camera.gateFit;
				}
			}
			else
			{
				if (camera != null)
				{
					m_SensorSize = new Vector2(camera.aspect, 1f);
				}
				LensShift = Vector2.zero;
			}
		}

		public void SnapshotCameraReadOnlyProperties(ref LensSettings lens)
		{
			if (ModeOverride == OverrideModes.None)
			{
				m_OrthoFromCamera = lens.Orthographic;
				m_SensorSize = lens.m_SensorSize;
				m_PhysicalFromCamera = lens.IsPhysicalCamera;
			}
			if (!IsPhysicalCamera)
			{
				LensShift = Vector2.zero;
			}
		}

		public LensSettings(float verticalFOV, float orthographicSize, float nearClip, float farClip, float dutch)
		{
			this = default(LensSettings);
			FieldOfView = verticalFOV;
			OrthographicSize = orthographicSize;
			NearClipPlane = nearClip;
			FarClipPlane = farClip;
			Dutch = dutch;
			m_SensorSize = new Vector2(1f, 1f);
			GateFit = Camera.GateFitMode.Horizontal;
			FocusDistance = 10f;
		}

		public static LensSettings Lerp(LensSettings lensA, LensSettings lensB, float t)
		{
			t = Mathf.Clamp01(t);
			LensSettings result = ((t < 0.5f) ? lensA : lensB);
			result.FarClipPlane = Mathf.Lerp(lensA.FarClipPlane, lensB.FarClipPlane, t);
			result.NearClipPlane = Mathf.Lerp(lensA.NearClipPlane, lensB.NearClipPlane, t);
			result.FieldOfView = Mathf.Lerp(lensA.FieldOfView, lensB.FieldOfView, t);
			result.OrthographicSize = Mathf.Lerp(lensA.OrthographicSize, lensB.OrthographicSize, t);
			result.Dutch = Mathf.Lerp(lensA.Dutch, lensB.Dutch, t);
			result.m_SensorSize = Vector2.Lerp(lensA.m_SensorSize, lensB.m_SensorSize, t);
			result.LensShift = Vector2.Lerp(lensA.LensShift, lensB.LensShift, t);
			result.FocusDistance = Mathf.Lerp(lensA.FocusDistance, lensB.FocusDistance, t);
			return result;
		}

		public void Validate()
		{
			FarClipPlane = Mathf.Max(FarClipPlane, NearClipPlane + 0.001f);
			FieldOfView = Mathf.Clamp(FieldOfView, 0.01f, 179f);
			m_SensorSize.x = Mathf.Max(m_SensorSize.x, 0.1f);
			m_SensorSize.y = Mathf.Max(m_SensorSize.y, 0.1f);
			FocusDistance = Mathf.Max(FocusDistance, 0.01f);
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineNoiseProfiles.html")]
	public sealed class NoiseSettings : SignalSourceAsset
	{
		[Serializable]
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public struct NoiseParams
		{
			[Tooltip("The frequency of noise for this channel.  Higher magnitudes vibrate faster.")]
			public float Frequency;

			[Tooltip("The amplitude of the noise for this channel.  Larger numbers vibrate higher.")]
			public float Amplitude;

			[Tooltip("If checked, then the amplitude and frequency will not be randomized.")]
			public bool Constant;

			public float GetValueAt(float time, float timeOffset)
			{
				float num = Frequency * time + timeOffset;
				if (Constant)
				{
					return Mathf.Cos(num * 2f * MathF.PI) * Amplitude * 0.5f;
				}
				return (Mathf.PerlinNoise(num, 0f) - 0.5f) * Amplitude;
			}
		}

		[Serializable]
		[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
		public struct TransformNoiseParams
		{
			[Tooltip("Noise definition for X-axis")]
			public NoiseParams X;

			[Tooltip("Noise definition for Y-axis")]
			public NoiseParams Y;

			[Tooltip("Noise definition for Z-axis")]
			public NoiseParams Z;

			public Vector3 GetValueAt(float time, Vector3 timeOffsets)
			{
				return new Vector3(X.GetValueAt(time, timeOffsets.x), Y.GetValueAt(time, timeOffsets.y), Z.GetValueAt(time, timeOffsets.z));
			}
		}

		[Tooltip("These are the noise channels for the virtual camera's position. Convincing noise setups typically mix low, medium and high frequencies together, so start with a size of 3")]
		[FormerlySerializedAs("m_Position")]
		public TransformNoiseParams[] PositionNoise = Array.Empty<TransformNoiseParams>();

		[Tooltip("These are the noise channels for the virtual camera's orientation. Convincing noise setups typically mix low, medium and high frequencies together, so start with a size of 3")]
		[FormerlySerializedAs("m_Orientation")]
		public TransformNoiseParams[] OrientationNoise = Array.Empty<TransformNoiseParams>();

		public override float SignalDuration => 0f;

		public static Vector3 GetCombinedFilterResults(TransformNoiseParams[] noiseParams, float time, Vector3 timeOffsets)
		{
			Vector3 zero = Vector3.zero;
			if (noiseParams != null)
			{
				for (int i = 0; i < noiseParams.Length; i++)
				{
					zero += noiseParams[i].GetValueAt(time, timeOffsets);
				}
			}
			return zero;
		}

		public override void GetSignal(float timeSinceSignalStart, out Vector3 pos, out Quaternion rot)
		{
			pos = GetCombinedFilterResults(PositionNoise, timeSinceSignalStart, Vector3.zero);
			rot = Quaternion.Euler(GetCombinedFilterResults(OrientationNoise, timeSinceSignalStart, Vector3.zero));
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.Undoc)]
	public static class RuntimeUtility
	{
		private static RaycastHit[] s_HitBuffer = new RaycastHit[16];

		private static int[] s_PenetrationIndexBuffer = new int[16];

		private static SphereCollider s_ScratchCollider;

		private static GameObject s_ScratchColliderGameObject;

		public static void DestroyObject(UnityEngine.Object obj)
		{
			if (obj != null)
			{
				UnityEngine.Object.Destroy(obj);
			}
		}

		public static bool IsPrefab(GameObject gameObject)
		{
			return false;
		}

		public static bool RaycastIgnoreTag(Ray ray, out RaycastHit hitInfo, float rayLength, int layerMask, in string ignoreTag)
		{
			if (ignoreTag.Length == 0)
			{
				if (Physics.Raycast(ray, out hitInfo, rayLength, layerMask, QueryTriggerInteraction.Ignore))
				{
					return true;
				}
			}
			else
			{
				int num = -1;
				int num2 = Physics.RaycastNonAlloc(ray, s_HitBuffer, rayLength, layerMask, QueryTriggerInteraction.Ignore);
				for (int i = 0; i < num2; i++)
				{
					if (!s_HitBuffer[i].collider.CompareTag(ignoreTag) && (num < 0 || s_HitBuffer[i].distance < s_HitBuffer[num].distance))
					{
						num = i;
					}
				}
				if (num >= 0)
				{
					hitInfo = s_HitBuffer[num];
					if (num2 == s_HitBuffer.Length)
					{
						s_HitBuffer = new RaycastHit[s_HitBuffer.Length * 2];
					}
					return true;
				}
			}
			hitInfo = default(RaycastHit);
			return false;
		}

		public static bool SphereCastIgnoreTag(Vector3 rayStart, float radius, Vector3 dir, out RaycastHit hitInfo, float rayLength, int layerMask, in string ignoreTag)
		{
			int num = -1;
			int num2 = 0;
			float num3 = 0f;
			int num4 = Physics.SphereCastNonAlloc(rayStart, radius, dir, s_HitBuffer, rayLength, layerMask, QueryTriggerInteraction.Ignore);
			for (int i = 0; i < num4; i++)
			{
				RaycastHit raycastHit = s_HitBuffer[i];
				if (ignoreTag.Length > 0 && raycastHit.collider.CompareTag(ignoreTag))
				{
					continue;
				}
				if (raycastHit.distance == 0f && raycastHit.normal == -dir)
				{
					SphereCollider scratchCollider = GetScratchCollider();
					scratchCollider.radius = radius;
					Collider collider = raycastHit.collider;
					if (!Physics.ComputePenetration(scratchCollider, rayStart, Quaternion.identity, collider, collider.transform.position, collider.transform.rotation, out var direction, out var distance))
					{
						continue;
					}
					raycastHit.point = rayStart + direction * (distance - radius);
					raycastHit.distance = distance - radius;
					raycastHit.normal = direction;
					s_HitBuffer[i] = raycastHit;
					if (raycastHit.distance < -0.0001f)
					{
						num3 += raycastHit.distance;
						if (s_PenetrationIndexBuffer.Length > num2 + 1)
						{
							s_PenetrationIndexBuffer[num2++] = i;
						}
					}
				}
				if (num < 0 || raycastHit.distance < s_HitBuffer[num].distance)
				{
					num = i;
				}
			}
			if (num2 > 1)
			{
				hitInfo = default(RaycastHit);
				for (int j = 0; j < num2; j++)
				{
					RaycastHit raycastHit2 = s_HitBuffer[s_PenetrationIndexBuffer[j]];
					float num5 = raycastHit2.distance / num3;
					hitInfo.point += raycastHit2.point * num5;
					hitInfo.distance += raycastHit2.distance * num5;
					hitInfo.normal += raycastHit2.normal * num5;
				}
				hitInfo.normal = hitInfo.normal.normalized;
				return true;
			}
			if (num >= 0)
			{
				hitInfo = s_HitBuffer[num];
				if (num4 == s_HitBuffer.Length)
				{
					s_HitBuffer = new RaycastHit[s_HitBuffer.Length * 2];
				}
				return true;
			}
			hitInfo = default(RaycastHit);
			return false;
		}

		internal static SphereCollider GetScratchCollider()
		{
			if (s_ScratchColliderGameObject == null)
			{
				s_ScratchColliderGameObject = new GameObject("Cinemachine Scratch Collider");
				s_ScratchColliderGameObject.hideFlags = HideFlags.HideAndDontSave;
				s_ScratchColliderGameObject.transform.position = Vector3.zero;
				s_ScratchColliderGameObject.SetActive(value: true);
				s_ScratchCollider = s_ScratchColliderGameObject.AddComponent<SphereCollider>();
				s_ScratchCollider.isTrigger = true;
				Rigidbody rigidbody = s_ScratchColliderGameObject.AddComponent<Rigidbody>();
				rigidbody.detectCollisions = false;
				rigidbody.isKinematic = true;
			}
			return s_ScratchCollider;
		}

		internal static void DestroyScratchCollider()
		{
			if (s_ScratchColliderGameObject != null)
			{
				s_ScratchColliderGameObject.SetActive(value: false);
				DestroyObject(s_ScratchColliderGameObject.GetComponent<Rigidbody>());
			}
			DestroyObject(s_ScratchCollider);
			DestroyObject(s_ScratchColliderGameObject);
			s_ScratchColliderGameObject = null;
			s_ScratchCollider = null;
		}

		public static AnimationCurve NormalizeCurve(AnimationCurve curve, bool normalizeX, bool normalizeY)
		{
			if (!normalizeX && !normalizeY)
			{
				return curve;
			}
			Keyframe[] keys = curve.keys;
			if (keys.Length != 0)
			{
				float num = keys[0].time;
				float num2 = num;
				float num3 = keys[0].value;
				float num4 = num3;
				for (int i = 0; i < keys.Length; i++)
				{
					num = Mathf.Min(num, keys[i].time);
					num2 = Mathf.Max(num2, keys[i].time);
					num3 = Mathf.Min(num3, keys[i].value);
					num4 = Mathf.Max(num4, keys[i].value);
				}
				float num5 = num2 - num;
				float num6 = ((num5 < 0.0001f) ? 1f : (1f / num5));
				num5 = num4 - num3;
				float num7 = ((num5 < 1f) ? 1f : (1f / num5));
				float num8 = 0f;
				if (num5 < 1f)
				{
					num8 = ((!(num3 > 0f) || !(num3 + num5 <= 1f)) ? (1f - num5) : num3);
				}
				for (int j = 0; j < keys.Length; j++)
				{
					if (normalizeX)
					{
						keys[j].time = (keys[j].time - num) * num6;
					}
					if (normalizeY)
					{
						keys[j].value = (keys[j].value - num3) * num7 + num8;
					}
				}
				curve.keys = keys;
			}
			return curve;
		}
	}
	public interface ISignalSource6D
	{
		float SignalDuration { get; }

		void GetSignal(float timeSinceSignalStart, out Vector3 pos, out Quaternion rot);
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.API)]
	public abstract class SignalSourceAsset : ScriptableObject, ISignalSource6D
	{
		public abstract float SignalDuration { get; }

		public abstract void GetSignal(float timeSinceSignalStart, out Vector3 pos, out Quaternion rot);
	}
	internal class TargetPositionCache
	{
		public enum Mode
		{
			Disabled,
			Record,
			Playback
		}

		private class CacheCurve
		{
			public struct Item
			{
				public Vector3 Pos;

				public Quaternion Rot;

				public static Item Empty => new Item
				{
					Rot = Quaternion.identity
				};

				public static Item Lerp(Item a, Item b, float t)
				{
					return new Item
					{
						Pos = Vector3.LerpUnclamped(a.Pos, b.Pos, t),
						Rot = Quaternion.SlerpUnclamped(a.Rot, b.Rot, t)
					};
				}
			}

			public float StartTime;

			public float StepSize;

			private List<Item> m_Cache;

			public int Count => m_Cache.Count;

			public CacheCurve(float startTime, float endTime, float stepSize)
			{
				StepSize = stepSize;
				StartTime = startTime;
				m_Cache = new List<Item>(Mathf.CeilToInt((StepSize * 0.5f + endTime - startTime) / StepSize));
			}

			public void Add(Item item)
			{
				m_Cache.Add(item);
			}

			public void AddUntil(Item item, float time, bool isCut)
			{
				int num = m_Cache.Count - 1;
				float num2 = (float)num * StepSize;
				float num3 = time - StartTime - num2;
				if (isCut)
				{
					for (float num4 = StepSize; num4 <= num3; num4 += StepSize)
					{
						Add(item);
					}
					return;
				}
				Item a = m_Cache[num];
				for (float num5 = StepSize; num5 <= num3; num5 += StepSize)
				{
					Add(Item.Lerp(a, item, num5 / num3));
				}
			}

			public Item Evaluate(float time)
			{
				int count = m_Cache.Count;
				if (count == 0)
				{
					return Item.Empty;
				}
				float num = time - StartTime;
				int num2 = Mathf.Clamp(Mathf.FloorToInt(num / StepSize), 0, count - 1);
				Item item = m_Cache[num2];
				if (num2 == count - 1)
				{
					return item;
				}
				return Item.Lerp(item, m_Cache[num2 + 1], (num - (float)num2 * StepSize) / StepSize);
			}
		}

		private class CacheEntry
		{
			private struct RecordingItem
			{
				public float Time;

				public bool IsCut;

				public CacheCurve.Item Item;
			}

			public CacheCurve Curve;

			private List<RecordingItem> RawItems = new List<RecordingItem>();

			public void AddRawItem(float time, bool isCut, Transform target)
			{
				float num = time - 1f / 60f;
				int num2 = RawItems.Count - 1;
				int num3 = num2;
				while (num3 >= 0 && RawItems[num3].Time > num)
				{
					num3--;
				}
				if (num3 == num2)
				{
					RawItems.Add(new RecordingItem
					{
						Time = time,
						IsCut = isCut,
						Item = new CacheCurve.Item
						{
							Pos = target.position,
							Rot = target.rotation
						}
					});
					return;
				}
				int num4 = num3 + 2;
				if (num4 <= num2)
				{
					RawItems.RemoveRange(num4, RawItems.Count - num4);
				}
				RawItems[num3 + 1] = new RecordingItem
				{
					Time = time,
					IsCut = isCut,
					Item = new CacheCurve.Item
					{
						Pos = target.position,
						Rot = target.rotation
					}
				};
			}

			public void CreateCurves()
			{
				int num = RawItems.Count - 1;
				float startTime = ((num < 0) ? 0f : RawItems[0].Time);
				float endTime = ((num < 0) ? 0f : RawItems[num].Time);
				Curve = new CacheCurve(startTime, endTime, 1f / 60f);
				Curve.Add((num < 0) ? CacheCurve.Item.Empty : RawItems[0].Item);
				for (int i = 1; i <= num; i++)
				{
					Curve.AddUntil(RawItems[i].Item, RawItems[i].Time, RawItems[i].IsCut);
				}
				RawItems.Clear();
			}
		}

		public struct TimeRange
		{
			public float Start;

			public float End;

			public bool IsEmpty => End < Start;

			public static TimeRange Empty => new TimeRange
			{
				Start = float.MaxValue,
				End = float.MinValue
			};

			public bool Contains(float time)
			{
				if (time >= Start)
				{
					return time <= End;
				}
				return false;
			}

			public void Include(float time)
			{
				Start = Mathf.Min(Start, time);
				End = Mathf.Max(End, time);
			}
		}

		public static bool UseCache;

		public const float CacheStepSize = 1f / 60f;

		private static Mode m_CacheMode;

		public static float CurrentTime;

		public static int CurrentFrame;

		public static bool IsCameraCut;

		private static Dictionary<Transform, CacheEntry> m_Cache;

		private static TimeRange m_CacheTimeRange;

		private const float kWraparoundSlush = 0.1f;

		public static Mode CacheMode
		{
			get
			{
				return m_CacheMode;
			}
			set
			{
				if (value != m_CacheMode)
				{
					m_CacheMode = value;
					switch (value)
					{
					default:
						ClearCache();
						break;
					case Mode.Record:
						ClearCache();
						break;
					case Mode.Playback:
						CreatePlaybackCurves();
						break;
					}
				}
			}
		}

		public static bool IsRecording
		{
			get
			{
				if (UseCache)
				{
					return m_CacheMode == Mode.Record;
				}
				return false;
			}
		}

		public static bool CurrentPlaybackTimeValid
		{
			get
			{
				if (UseCache && m_CacheMode == Mode.Playback)
				{
					return HasCurrentTime;
				}
				return false;
			}
		}

		public static bool IsEmpty => CacheTimeRange.IsEmpty;

		public static TimeRange CacheTimeRange => m_CacheTimeRange;

		public static bool HasCurrentTime => m_CacheTimeRange.Contains(CurrentTime);

		public static void ClearCache()
		{
			m_Cache = ((CacheMode == Mode.Disabled) ? null : new Dictionary<Transform, CacheEntry>());
			m_CacheTimeRange = TimeRange.Empty;
			CurrentTime = 0f;
			CurrentFrame = 0;
			IsCameraCut = false;
		}

		private static void CreatePlaybackCurves()
		{
			if (m_Cache == null)
			{
				m_Cache = new Dictionary<Transform, CacheEntry>();
			}
			Dictionary<Transform, CacheEntry>.Enumerator enumerator = m_Cache.GetEnumerator();
			while (enumerator.MoveNext())
			{
				enumerator.Current.Value.CreateCurves();
			}
		}

		public static Vector3 GetTargetPosition(Transform target)
		{
			if (!UseCache || CacheMode == Mode.Disabled)
			{
				return target.position;
			}
			if (CacheMode == Mode.Record && !m_CacheTimeRange.IsEmpty && CurrentTime < m_CacheTimeRange.Start - 0.1f)
			{
				ClearCache();
			}
			if (CacheMode == Mode.Playback && !HasCurrentTime)
			{
				return target.position;
			}
			if (!m_Cache.TryGetValue(target, out var value))
			{
				if (CacheMode != Mode.Record)
				{
					return target.position;
				}
				value = new CacheEntry();
				m_Cache.Add(target, value);
			}
			if (CacheMode == Mode.Record)
			{
				value.AddRawItem(CurrentTime, IsCameraCut, target);
				m_CacheTimeRange.Include(CurrentTime);
				return target.position;
			}
			if (value.Curve == null)
			{
				return target.position;
			}
			return value.Curve.Evaluate(CurrentTime).Pos;
		}

		public static Quaternion GetTargetRotation(Transform target)
		{
			if (CacheMode == Mode.Disabled)
			{
				return target.rotation;
			}
			if (CacheMode == Mode.Record && !m_CacheTimeRange.IsEmpty && CurrentTime < m_CacheTimeRange.Start - 0.1f)
			{
				ClearCache();
			}
			if (CacheMode == Mode.Playback && !HasCurrentTime)
			{
				return target.rotation;
			}
			if (!m_Cache.TryGetValue(target, out var value))
			{
				if (CacheMode != Mode.Record)
				{
					return target.rotation;
				}
				value = new CacheEntry();
				m_Cache.Add(target, value);
			}
			if (CacheMode == Mode.Record)
			{
				if (m_CacheTimeRange.End <= CurrentTime)
				{
					value.AddRawItem(CurrentTime, IsCameraCut, target);
					m_CacheTimeRange.Include(CurrentTime);
				}
				return target.rotation;
			}
			return value.Curve.Evaluate(CurrentTime).Rot;
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.Undoc)]
	internal class UpdateTracker
	{
		public enum UpdateClock
		{
			Fixed,
			Late
		}

		private class UpdateStatus
		{
			private const int kWindowSize = 30;

			private int windowStart;

			private int numWindowLateUpdateMoves;

			private int numWindowFixedUpdateMoves;

			private int numWindows;

			private int lastFrameUpdated;

			private Matrix4x4 lastPos;

			public UpdateClock PreferredUpdate { get; private set; }

			public UpdateStatus(int currentFrame, Matrix4x4 pos)
			{
				windowStart = currentFrame;
				lastFrameUpdated = Time.frameCount;
				PreferredUpdate = UpdateClock.Late;
				lastPos = pos;
			}

			public void OnUpdate(int currentFrame, UpdateClock currentClock, Matrix4x4 pos)
			{
				if (!(lastPos == pos))
				{
					if (currentClock == UpdateClock.Late)
					{
						numWindowLateUpdateMoves++;
					}
					else if (lastFrameUpdated != currentFrame)
					{
						numWindowFixedUpdateMoves++;
					}
					lastPos = pos;
					UpdateClock preferredUpdate = ((numWindowFixedUpdateMoves <= 3 || numWindowLateUpdateMoves >= numWindowFixedUpdateMoves / 3) ? UpdateClock.Late : UpdateClock.Fixed);
					if (numWindows == 0)
					{
						PreferredUpdate = preferredUpdate;
					}
					if (windowStart + 30 <= currentFrame)
					{
						PreferredUpdate = preferredUpdate;
						numWindows++;
						windowStart = currentFrame;
						numWindowLateUpdateMoves = ((PreferredUpdate == UpdateClock.Late) ? 1 : 0);
						numWindowFixedUpdateMoves = ((PreferredUpdate == UpdateClock.Fixed) ? 1 : 0);
					}
				}
			}
		}

		private static Dictionary<Transform, UpdateStatus> mUpdateStatus = new Dictionary<Transform, UpdateStatus>();

		private static List<Transform> sToDelete = new List<Transform>();

		private static float mLastUpdateTime;

		[RuntimeInitializeOnLoadMethod]
		private static void InitializeModule()
		{
			mUpdateStatus.Clear();
		}

		private static void UpdateTargets(UpdateClock currentClock)
		{
			int frameCount = Time.frameCount;
			Dictionary<Transform, UpdateStatus>.Enumerator enumerator = mUpdateStatus.GetEnumerator();
			while (enumerator.MoveNext())
			{
				KeyValuePair<Transform, UpdateStatus> current = enumerator.Current;
				if (current.Key == null)
				{
					sToDelete.Add(current.Key);
				}
				else
				{
					current.Value.OnUpdate(frameCount, currentClock, current.Key.localToWorldMatrix);
				}
			}
			for (int num = sToDelete.Count - 1; num >= 0; num--)
			{
				mUpdateStatus.Remove(sToDelete[num]);
			}
			sToDelete.Clear();
		}

		public static UpdateClock GetPreferredUpdate(Transform target)
		{
			if (Application.isPlaying && target != null)
			{
				if (mUpdateStatus.TryGetValue(target, out var value))
				{
					return value.PreferredUpdate;
				}
				value = new UpdateStatus(Time.frameCount, target.localToWorldMatrix);
				mUpdateStatus.Add(target, value);
			}
			return UpdateClock.Late;
		}

		public static void OnUpdate(UpdateClock currentClock)
		{
			float currentTime = CinemachineCore.CurrentTime;
			if (currentTime != mLastUpdateTime)
			{
				mLastUpdateTime = currentTime;
				UpdateTargets(currentClock);
			}
		}
	}
	[AddComponentMenu("")]
	public class CinemachineInputProvider : MonoBehaviour
	{
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[SaveDuringPlay]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/api/Cinemachine.CinemachineTriggerAction.html")]
	public class CinemachineTriggerAction : MonoBehaviour
	{
		[Serializable]
		public struct ActionSettings
		{
			public enum Mode
			{
				Custom,
				PriorityBoost,
				Activate,
				Deactivate,
				Enable,
				Disable,
				Play,
				Stop
			}

			[Serializable]
			public class TriggerEvent : UnityEvent
			{
			}

			public enum TimeMode
			{
				FromStart,
				FromEnd,
				BeforeNow,
				AfterNow
			}

			[Tooltip("What action to take")]
			public Mode m_Action;

			[Tooltip("The target object on which to operate.  If null, then the current behaviour/GameObject will be used")]
			public UnityEngine.Object m_Target;

			[Tooltip("If PriorityBoost, this amount will be added to the virtual camera's priority")]
			public int m_BoostAmount;

			[Tooltip("If playing a timeline, start at this time")]
			public float m_StartTime;

			[Tooltip("How to interpret the start time")]
			public TimeMode m_Mode;

			[Tooltip("This event will be invoked")]
			public TriggerEvent m_Event;

			public ActionSettings(Mode action)
			{
				m_Action = action;
				m_Target = null;
				m_BoostAmount = 0;
				m_StartTime = 0f;
				m_Mode = TimeMode.FromStart;
				m_Event = new TriggerEvent();
			}

			public void Invoke()
			{
				UnityEngine.Object target = m_Target;
				if (target != null)
				{
					GameObject gameObject = target as GameObject;
					Behaviour behaviour = target as Behaviour;
					if (behaviour != null)
					{
						gameObject = behaviour.gameObject;
					}
					switch (m_Action)
					{
					case Mode.PriorityBoost:
					{
						CinemachineVirtualCameraBase component5 = gameObject.GetComponent<CinemachineVirtualCameraBase>();
						if (component5 != null)
						{
							component5.Priority += m_BoostAmount;
							component5.MoveToTopOfPrioritySubqueue();
						}
						break;
					}
					case Mode.Activate:
						if (gameObject != null)
						{
							gameObject.SetActive(value: true);
							CinemachineVirtualCameraBase component6 = gameObject.GetComponent<CinemachineVirtualCameraBase>();
							if (component6 != null)
							{
								component6.MoveToTopOfPrioritySubqueue();
							}
						}
						break;
					case Mode.Deactivate:
						if (gameObject != null)
						{
							gameObject.SetActive(value: false);
						}
						break;
					case Mode.Enable:
						if (behaviour != null)
						{
							behaviour.enabled = true;
						}
						break;
					case Mode.Disable:
						if (behaviour != null)
						{
							behaviour.enabled = false;
						}
						break;
					case Mode.Play:
					{
						PlayableDirector component3 = gameObject.GetComponent<PlayableDirector>();
						if (component3 != null)
						{
							double num = 0.0;
							double duration = component3.duration;
							double time = component3.time;
							component3.time = m_Mode switch
							{
								TimeMode.FromEnd => duration - (double)m_StartTime, 
								TimeMode.BeforeNow => time - (double)m_StartTime, 
								TimeMode.AfterNow => time + (double)m_StartTime, 
								_ => num + (double)m_StartTime, 
							};
							component3.Play();
						}
						else
						{
							Animation component4 = gameObject.GetComponent<Animation>();
							if (component4 != null)
							{
								component4.Play();
							}
						}
						break;
					}
					case Mode.Stop:
					{
						PlayableDirector component = gameObject.GetComponent<PlayableDirector>();
						if (component != null)
						{
							component.Stop();
							break;
						}
						Animation component2 = gameObject.GetComponent<Animation>();
						if (component2 != null)
						{
							component2.Stop();
						}
						break;
					}
					}
				}
				m_Event.Invoke();
			}
		}

		[Header("Trigger Object Filter")]
		[Tooltip("Only triggers generated by objects on these layers will be considered")]
		public LayerMask m_LayerMask = 1;

		[TagField]
		[Tooltip("If set, only triggers generated by objects with this tag will be considered")]
		public string m_WithTag = string.Empty;

		[TagField]
		[Tooltip("Triggers generated by objects with this tag will be ignored")]
		public string m_WithoutTag = string.Empty;

		[NoSaveDuringPlay]
		[Tooltip("Skip this many trigger entries before taking action")]
		public int m_SkipFirst;

		[Tooltip("Repeat the action for all subsequent trigger entries")]
		public bool m_Repeating = true;

		public ActionSettings m_OnObjectEnter = new ActionSettings(ActionSettings.Mode.Custom);

		public ActionSettings m_OnObjectExit = new ActionSettings(ActionSettings.Mode.Custom);

		private HashSet<GameObject> m_ActiveTriggerObjects = new HashSet<GameObject>();

		private bool Filter(GameObject other)
		{
			if (!base.enabled)
			{
				return false;
			}
			if (((1 << other.layer) & (int)m_LayerMask) == 0)
			{
				return false;
			}
			if (m_WithTag.Length != 0 && !other.CompareTag(m_WithTag))
			{
				return false;
			}
			if (m_WithoutTag.Length != 0 && other.CompareTag(m_WithoutTag))
			{
				return false;
			}
			return true;
		}

		private void InternalDoTriggerEnter(GameObject other)
		{
			if (Filter(other))
			{
				m_SkipFirst--;
				if (m_SkipFirst <= -1 && (m_Repeating || m_SkipFirst == -1))
				{
					m_ActiveTriggerObjects.Add(other);
					m_OnObjectEnter.Invoke();
				}
			}
		}

		private void InternalDoTriggerExit(GameObject other)
		{
			if (m_ActiveTriggerObjects.Contains(other))
			{
				m_ActiveTriggerObjects.Remove(other);
				if (base.enabled)
				{
					m_OnObjectExit.Invoke();
				}
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			InternalDoTriggerEnter(other.gameObject);
		}

		private void OnTriggerExit(Collider other)
		{
			InternalDoTriggerExit(other.gameObject);
		}

		private void OnCollisionEnter(Collision other)
		{
			InternalDoTriggerEnter(other.gameObject);
		}

		private void OnCollisionExit(Collision other)
		{
			InternalDoTriggerExit(other.gameObject);
		}

		private void OnTriggerEnter2D(Collider2D other)
		{
			InternalDoTriggerEnter(other.gameObject);
		}

		private void OnTriggerExit2D(Collider2D other)
		{
			InternalDoTriggerExit(other.gameObject);
		}

		private void OnCollisionEnter2D(Collision2D other)
		{
			InternalDoTriggerEnter(other.gameObject);
		}

		private void OnCollisionExit2D(Collision2D other)
		{
			InternalDoTriggerExit(other.gameObject);
		}

		private void OnEnable()
		{
		}
	}
	[RequireComponent(typeof(CinemachineTargetGroup))]
	[ExecuteAlways]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/api/Cinemachine.GroupWeightManipulator.html")]
	public class GroupWeightManipulator : MonoBehaviour
	{
		[Tooltip("The weight of the group member at index 0")]
		public float m_Weight0 = 1f;

		[Tooltip("The weight of the group member at index 1")]
		public float m_Weight1 = 1f;

		[Tooltip("The weight of the group member at index 2")]
		public float m_Weight2 = 1f;

		[Tooltip("The weight of the group member at index 3")]
		public float m_Weight3 = 1f;

		[Tooltip("The weight of the group member at index 4")]
		public float m_Weight4 = 1f;

		[Tooltip("The weight of the group member at index 5")]
		public float m_Weight5 = 1f;

		[Tooltip("The weight of the group member at index 6")]
		public float m_Weight6 = 1f;

		[Tooltip("The weight of the group member at index 7")]
		public float m_Weight7 = 1f;

		private CinemachineTargetGroup m_group;

		private void Start()
		{
			m_group = GetComponent<CinemachineTargetGroup>();
		}

		private void OnValidate()
		{
			m_Weight0 = Mathf.Max(0f, m_Weight0);
			m_Weight1 = Mathf.Max(0f, m_Weight1);
			m_Weight2 = Mathf.Max(0f, m_Weight2);
			m_Weight3 = Mathf.Max(0f, m_Weight3);
			m_Weight4 = Mathf.Max(0f, m_Weight4);
			m_Weight5 = Mathf.Max(0f, m_Weight5);
			m_Weight6 = Mathf.Max(0f, m_Weight6);
			m_Weight7 = Mathf.Max(0f, m_Weight7);
		}

		private void Update()
		{
			if (m_group != null)
			{
				UpdateWeights();
			}
		}

		private void UpdateWeights()
		{
			CinemachineTargetGroup.Target[] targets = m_group.m_Targets;
			int num = targets.Length - 1;
			if (num < 0)
			{
				return;
			}
			targets[0].weight = m_Weight0;
			if (num < 1)
			{
				return;
			}
			targets[1].weight = m_Weight1;
			if (num < 2)
			{
				return;
			}
			targets[2].weight = m_Weight2;
			if (num < 3)
			{
				return;
			}
			targets[3].weight = m_Weight3;
			if (num < 4)
			{
				return;
			}
			targets[4].weight = m_Weight4;
			if (num < 5)
			{
				return;
			}
			targets[5].weight = m_Weight5;
			if (num >= 6)
			{
				targets[6].weight = m_Weight6;
				if (num >= 7)
				{
					targets[7].weight = m_Weight7;
				}
			}
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[SaveDuringPlay]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineCollisionImpulseSource.html")]
	public class CinemachineCollisionImpulseSource : CinemachineImpulseSource
	{
		[Header("Trigger Object Filter")]
		[Tooltip("Only collisions with objects on these layers will generate Impulse events")]
		public LayerMask m_LayerMask = 1;

		[TagField]
		[Tooltip("No Impulse evemts will be generated for collisions with objects having these tags")]
		public string m_IgnoreTag = string.Empty;

		[Header("How To Generate The Impulse")]
		[Tooltip("If checked, signal direction will be affected by the direction of impact")]
		public bool m_UseImpactDirection;

		[Tooltip("If checked, signal amplitude will be multiplied by the mass of the impacting object")]
		public bool m_ScaleImpactWithMass;

		[Tooltip("If checked, signal amplitude will be multiplied by the speed of the impacting object")]
		public bool m_ScaleImpactWithSpeed;

		private Rigidbody mRigidBody;

		private Rigidbody2D mRigidBody2D;

		private void Start()
		{
			mRigidBody = GetComponent<Rigidbody>();
			mRigidBody2D = GetComponent<Rigidbody2D>();
		}

		private void OnEnable()
		{
		}

		private void OnCollisionEnter(Collision c)
		{
			GenerateImpactEvent(c.collider, c.relativeVelocity);
		}

		private void OnTriggerEnter(Collider c)
		{
			GenerateImpactEvent(c, Vector3.zero);
		}

		private float GetMassAndVelocity(Collider other, ref Vector3 vel)
		{
			bool flag = vel == Vector3.zero;
			float num = 1f;
			if (m_ScaleImpactWithMass || m_ScaleImpactWithSpeed || m_UseImpactDirection)
			{
				if (mRigidBody != null)
				{
					if (m_ScaleImpactWithMass)
					{
						num *= mRigidBody.mass;
					}
					if (flag)
					{
						vel = -mRigidBody.velocity;
					}
				}
				Rigidbody rigidbody = ((other != null) ? other.attachedRigidbody : null);
				if (rigidbody != null)
				{
					if (m_ScaleImpactWithMass)
					{
						num *= rigidbody.mass;
					}
					if (flag)
					{
						vel += rigidbody.velocity;
					}
				}
			}
			return num;
		}

		private void GenerateImpactEvent(Collider other, Vector3 vel)
		{
			if (!base.enabled)
			{
				return;
			}
			if (other != null)
			{
				int layer = other.gameObject.layer;
				if (((1 << layer) & (int)m_LayerMask) == 0 || (m_IgnoreTag.Length != 0 && other.CompareTag(m_IgnoreTag)))
				{
					return;
				}
			}
			float num = GetMassAndVelocity(other, ref vel);
			if (m_ScaleImpactWithSpeed)
			{
				num *= Mathf.Sqrt(vel.magnitude);
			}
			Vector3 vector = m_DefaultVelocity;
			if (m_UseImpactDirection && !vel.AlmostZero())
			{
				vector = -vel.normalized * vector.magnitude;
			}
			GenerateImpulseWithVelocity(vector * num);
		}

		private void OnCollisionEnter2D(Collision2D c)
		{
			GenerateImpactEvent2D(c.collider, c.relativeVelocity);
		}

		private void OnTriggerEnter2D(Collider2D c)
		{
			GenerateImpactEvent2D(c, Vector3.zero);
		}

		private float GetMassAndVelocity2D(Collider2D other2d, ref Vector3 vel)
		{
			bool flag = vel == Vector3.zero;
			float num = 1f;
			if (m_ScaleImpactWithMass || m_ScaleImpactWithSpeed || m_UseImpactDirection)
			{
				if (mRigidBody2D != null)
				{
					if (m_ScaleImpactWithMass)
					{
						num *= mRigidBody2D.mass;
					}
					if (flag)
					{
						vel = -mRigidBody2D.velocity;
					}
				}
				Rigidbody2D rigidbody2D = ((other2d != null) ? other2d.attachedRigidbody : null);
				if (rigidbody2D != null)
				{
					if (m_ScaleImpactWithMass)
					{
						num *= rigidbody2D.mass;
					}
					if (flag)
					{
						Vector3 vector = rigidbody2D.velocity;
						vel += vector;
					}
				}
			}
			return num;
		}

		private void GenerateImpactEvent2D(Collider2D other2d, Vector3 vel)
		{
			if (!base.enabled)
			{
				return;
			}
			if (other2d != null)
			{
				int layer = other2d.gameObject.layer;
				if (((1 << layer) & (int)m_LayerMask) == 0 || (m_IgnoreTag.Length != 0 && other2d.CompareTag(m_IgnoreTag)))
				{
					return;
				}
			}
			float num = GetMassAndVelocity2D(other2d, ref vel);
			if (m_ScaleImpactWithSpeed)
			{
				num *= Mathf.Sqrt(vel.magnitude);
			}
			Vector3 vector = m_DefaultVelocity;
			if (m_UseImpactDirection && !vel.AlmostZero())
			{
				vector = -vel.normalized * vector.magnitude;
			}
			GenerateImpulseWithVelocity(vector * num);
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineImpulseFixedSignals.html")]
	public class CinemachineFixedSignal : SignalSourceAsset
	{
		[Tooltip("The raw signal shape along the X axis")]
		public AnimationCurve m_XCurve;

		[Tooltip("The raw signal shape along the Y axis")]
		public AnimationCurve m_YCurve;

		[Tooltip("The raw signal shape along the Z axis")]
		public AnimationCurve m_ZCurve;

		public override float SignalDuration => Mathf.Max(AxisDuration(m_XCurve), Mathf.Max(AxisDuration(m_YCurve), AxisDuration(m_ZCurve)));

		private float AxisDuration(AnimationCurve axis)
		{
			float result = 0f;
			if (axis != null && axis.length > 1)
			{
				float time = axis[0].time;
				result = axis[axis.length - 1].time - time;
			}
			return result;
		}

		public override void GetSignal(float timeSinceSignalStart, out Vector3 pos, out Quaternion rot)
		{
			rot = Quaternion.identity;
			pos = new Vector3(AxisValue(m_XCurve, timeSinceSignalStart), AxisValue(m_YCurve, timeSinceSignalStart), AxisValue(m_ZCurve, timeSinceSignalStart));
		}

		private float AxisValue(AnimationCurve axis, float time)
		{
			if (axis == null || axis.length == 0)
			{
				return 0f;
			}
			return axis.Evaluate(time);
		}
	}
	public sealed class CinemachineImpulseDefinitionPropertyAttribute : PropertyAttribute
	{
	}
	[Serializable]
	[DocumentationSorting(DocumentationSortingAttribute.Level.API)]
	public class CinemachineImpulseDefinition
	{
		public enum ImpulseShapes
		{
			Custom,
			Recoil,
			Bump,
			Explosion,
			Rumble
		}

		public enum ImpulseTypes
		{
			Uniform,
			Dissipating,
			Propagating,
			Legacy
		}

		public enum RepeatMode
		{
			Stretch,
			Loop
		}

		private class SignalSource : ISignalSource6D
		{
			private CinemachineImpulseDefinition m_Def;

			private Vector3 m_Velocity;

			public float SignalDuration => m_Def.m_ImpulseDuration;

			public SignalSource(CinemachineImpulseDefinition def, Vector3 velocity)
			{
				m_Def = def;
				m_Velocity = velocity;
			}

			public void GetSignal(float timeSinceSignalStart, out Vector3 pos, out Quaternion rot)
			{
				pos = m_Velocity * m_Def.ImpulseCurve.Evaluate(timeSinceSignalStart / SignalDuration);
				rot = Quaternion.identity;
			}
		}

		private class LegacySignalSource : ISignalSource6D
		{
			private CinemachineImpulseDefinition m_Def;

			private Vector3 m_Velocity;

			private float m_StartTimeOffset;

			public float SignalDuration => m_Def.m_RawSignal.SignalDuration;

			public LegacySignalSource(CinemachineImpulseDefinition def, Vector3 velocity)
			{
				m_Def = def;
				m_Velocity = velocity;
				if (m_Def.m_Randomize && m_Def.m_RawSignal.SignalDuration <= 0f)
				{
					m_StartTimeOffset = UnityEngine.Random.Range(-1000f, 1000f);
				}
			}

			public void GetSignal(float timeSinceSignalStart, out Vector3 pos, out Quaternion rot)
			{
				float num = m_StartTimeOffset + timeSinceSignalStart * m_Def.m_FrequencyGain;
				float signalDuration = SignalDuration;
				if (signalDuration > 0f)
				{
					if (m_Def.m_RepeatMode == RepeatMode.Loop)
					{
						num %= signalDuration;
					}
					else if (m_Def.m_TimeEnvelope.Duration > 0.0001f)
					{
						num *= m_Def.m_TimeEnvelope.Duration / signalDuration;
					}
				}
				m_Def.m_RawSignal.GetSignal(num, out pos, out rot);
				float magnitude = m_Velocity.magnitude;
				_ = m_Velocity.normalized;
				magnitude *= m_Def.m_AmplitudeGain;
				pos *= magnitude;
				pos = Quaternion.FromToRotation(Vector3.down, m_Velocity) * pos;
				rot = Quaternion.SlerpUnclamped(Quaternion.identity, rot, magnitude);
			}
		}

		[CinemachineImpulseChannelProperty]
		[Tooltip("Impulse events generated here will appear on the channels included in the mask.")]
		public int m_ImpulseChannel = 1;

		[Tooltip("Shape of the impact signal")]
		public ImpulseShapes m_ImpulseShape;

		[Tooltip("Defines the custom shape of the impact signal that will be generated.")]
		public AnimationCurve m_CustomImpulseShape = new AnimationCurve();

		[Tooltip("The time during which the impact signal will occur.  The signal shape will be stretched to fill that time.")]
		public float m_ImpulseDuration = 0.2f;

		[Tooltip("How the impulse travels through space and time.")]
		public ImpulseTypes m_ImpulseType = ImpulseTypes.Legacy;

		[Tooltip("This defines how the widely signal will spread within the effect radius before dissipating with distance from the impact point")]
		[Range(0f, 1f)]
		public float m_DissipationRate;

		[Header("Signal Shape")]
		[Tooltip("Legacy mode only: Defines the signal that will be generated.")]
		[CinemachineEmbeddedAssetProperty(true)]
		public SignalSourceAsset m_RawSignal;

		[Tooltip("Legacy mode only: Gain to apply to the amplitudes defined in the signal source.  1 is normal.  Setting this to 0 completely mutes the signal.")]
		public float m_AmplitudeGain = 1f;

		[Tooltip("Legacy mode only: Scale factor to apply to the time axis.  1 is normal.  Larger magnitudes will make the signal progress more rapidly.")]
		public float m_FrequencyGain = 1f;

		[Tooltip("Legacy mode only: How to fit the signal into the envelope time")]
		public RepeatMode m_RepeatMode;

		[Tooltip("Legacy mode only: Randomize the signal start time")]
		public bool m_Randomize = true;

		[Tooltip("Legacy mode only: This defines the time-envelope of the signal.  The raw signal will be time-scaled to fit in the envelope.")]
		public CinemachineImpulseManager.EnvelopeDefinition m_TimeEnvelope = CinemachineImpulseManager.EnvelopeDefinition.Default();

		[Header("Spatial Range")]
		[Tooltip("Legacy mode only: The signal will have full amplitude in this radius surrounding the impact point.  Beyond that it will dissipate with distance.")]
		public float m_ImpactRadius = 100f;

		[Tooltip("Legacy mode only: How the signal direction behaves as the listener moves away from the origin.")]
		public CinemachineImpulseManager.ImpulseEvent.DirectionMode m_DirectionMode;

		[Tooltip("Legacy mode only: This defines how the signal will dissipate with distance beyond the impact radius.")]
		public CinemachineImpulseManager.ImpulseEvent.DissipationMode m_DissipationMode = CinemachineImpulseManager.ImpulseEvent.DissipationMode.ExponentialDecay;

		[Tooltip("The signal will have no effect outside this radius surrounding the impact point.")]
		public float m_DissipationDistance = 100f;

		[Tooltip("The speed (m/s) at which the impulse propagates through space.  High speeds allow listeners to react instantaneously, while slower speeds allow listeners in the scene to react as if to a wave spreading from the source.")]
		public float m_PropagationSpeed = 343f;

		private static AnimationCurve[] sStandardShapes;

		internal AnimationCurve ImpulseCurve
		{
			get
			{
				if (m_ImpulseShape == ImpulseShapes.Custom)
				{
					if (m_CustomImpulseShape == null)
					{
						m_CustomImpulseShape = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);
					}
					return m_CustomImpulseShape;
				}
				return GetStandardCurve(m_ImpulseShape);
			}
		}

		public void OnValidate()
		{
			RuntimeUtility.NormalizeCurve(m_CustomImpulseShape, normalizeX: true, normalizeY: false);
			m_ImpulseDuration = Mathf.Max(0.0001f, m_ImpulseDuration);
			m_DissipationDistance = Mathf.Max(0.0001f, m_DissipationDistance);
			m_DissipationRate = Mathf.Clamp01(m_DissipationRate);
			m_PropagationSpeed = Mathf.Max(1f, m_PropagationSpeed);
			m_ImpactRadius = Mathf.Max(0f, m_ImpactRadius);
			m_TimeEnvelope.Validate();
			m_PropagationSpeed = Mathf.Max(1f, m_PropagationSpeed);
		}

		private static void CreateStandardShapes()
		{
			int num = 0;
			foreach (object value in Enum.GetValues(typeof(ImpulseShapes)))
			{
				num = Mathf.Max(num, (int)value);
			}
			sStandardShapes = new AnimationCurve[num + 1];
			sStandardShapes[1] = new AnimationCurve(new Keyframe(0f, 1f, -3.2f, -3.2f), new Keyframe(1f, 0f, 0f, 0f));
			sStandardShapes[2] = new AnimationCurve(new Keyframe(0f, 0f, -4.9f, -4.9f), new Keyframe(0.2f, 0f, 8.25f, 8.25f), new Keyframe(1f, 0f, -0.25f, -0.25f));
			sStandardShapes[3] = new AnimationCurve(new Keyframe(0f, -1.4f, -7.9f, -7.9f), new Keyframe(0.27f, 0.78f, 23.4f, 23.4f), new Keyframe(0.54f, -0.12f, 22.6f, 22.6f), new Keyframe(0.75f, 0.042f, 9.23f, 9.23f), new Keyframe(0.9f, -0.02f, 5.8f, 5.8f), new Keyframe(0.95f, -0.006f, -3f, -3f), new Keyframe(1f, 0f, 0f, 0f));
			sStandardShapes[4] = new AnimationCurve(new Keyframe(0f, 0f, 0f, 0f), new Keyframe(0.1f, 0.25f, 0f, 0f), new Keyframe(0.2f, 0f, 0f, 0f), new Keyframe(0.3f, 0.75f, 0f, 0f), new Keyframe(0.4f, 0f, 0f, 0f), new Keyframe(0.5f, 1f, 0f, 0f), new Keyframe(0.6f, 0f, 0f, 0f), new Keyframe(0.7f, 0.75f, 0f, 0f), new Keyframe(0.8f, 0f, 0f, 0f), new Keyframe(0.9f, 0.25f, 0f, 0f), new Keyframe(1f, 0f, 0f, 0f));
		}

		internal static AnimationCurve GetStandardCurve(ImpulseShapes shape)
		{
			if (sStandardShapes == null)
			{
				CreateStandardShapes();
			}
			return sStandardShapes[(int)shape];
		}

		public void CreateEvent(Vector3 position, Vector3 velocity)
		{
			CreateAndReturnEvent(position, velocity);
		}

		public CinemachineImpulseManager.ImpulseEvent CreateAndReturnEvent(Vector3 position, Vector3 velocity)
		{
			if (m_ImpulseType == ImpulseTypes.Legacy)
			{
				return LegacyCreateAndReturnEvent(position, velocity);
			}
			if ((m_ImpulseShape == ImpulseShapes.Custom && m_CustomImpulseShape == null) || Mathf.Abs(m_DissipationDistance) < 0.0001f || Mathf.Abs(m_ImpulseDuration) < 0.0001f)
			{
				return null;
			}
			CinemachineImpulseManager.ImpulseEvent impulseEvent = CinemachineImpulseManager.Instance.NewImpulseEvent();
			impulseEvent.m_Envelope = new CinemachineImpulseManager.EnvelopeDefinition
			{
				m_SustainTime = m_ImpulseDuration
			};
			impulseEvent.m_SignalSource = new SignalSource(this, velocity);
			impulseEvent.m_Position = position;
			impulseEvent.m_Radius = ((m_ImpulseType == ImpulseTypes.Uniform) ? 9999999f : 0f);
			impulseEvent.m_Channel = m_ImpulseChannel;
			impulseEvent.m_DirectionMode = CinemachineImpulseManager.ImpulseEvent.DirectionMode.Fixed;
			impulseEvent.m_DissipationDistance = ((m_ImpulseType == ImpulseTypes.Uniform) ? 0f : m_DissipationDistance);
			impulseEvent.m_PropagationSpeed = ((m_ImpulseType == ImpulseTypes.Propagating) ? m_PropagationSpeed : 9999999f);
			impulseEvent.m_CustomDissipation = m_DissipationRate;
			CinemachineImpulseManager.Instance.AddImpulseEvent(impulseEvent);
			return impulseEvent;
		}

		private CinemachineImpulseManager.ImpulseEvent LegacyCreateAndReturnEvent(Vector3 position, Vector3 velocity)
		{
			if (m_RawSignal == null || Mathf.Abs(m_TimeEnvelope.Duration) < 0.0001f)
			{
				return null;
			}
			CinemachineImpulseManager.ImpulseEvent impulseEvent = CinemachineImpulseManager.Instance.NewImpulseEvent();
			impulseEvent.m_Envelope = m_TimeEnvelope;
			impulseEvent.m_Envelope = m_TimeEnvelope;
			if (m_TimeEnvelope.m_ScaleWithImpact)
			{
				impulseEvent.m_Envelope.m_DecayTime *= Mathf.Sqrt(velocity.magnitude);
			}
			impulseEvent.m_SignalSource = new LegacySignalSource(this, velocity);
			impulseEvent.m_Position = position;
			impulseEvent.m_Radius = m_ImpactRadius;
			impulseEvent.m_Channel = m_ImpulseChannel;
			impulseEvent.m_DirectionMode = m_DirectionMode;
			impulseEvent.m_DissipationMode = m_DissipationMode;
			impulseEvent.m_DissipationDistance = m_DissipationDistance;
			impulseEvent.m_PropagationSpeed = m_PropagationSpeed;
			CinemachineImpulseManager.Instance.AddImpulseEvent(impulseEvent);
			return impulseEvent;
		}
	}
	[SaveDuringPlay]
	[AddComponentMenu("")]
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[ExecuteAlways]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineImpulseListener.html")]
	public class CinemachineImpulseListener : CinemachineExtension
	{
		[Serializable]
		public struct ImpulseReaction
		{
			[Tooltip("Secondary shake that will be triggered by the primary impulse.")]
			[NoiseSettingsProperty]
			public NoiseSettings m_SecondaryNoise;

			[Tooltip("Gain to apply to the amplitudes defined in the signal source.  1 is normal.  Setting this to 0 completely mutes the signal.")]
			public float m_AmplitudeGain;

			[Tooltip("Scale factor to apply to the time axis.  1 is normal.  Larger magnitudes will make the signal progress more rapidly.")]
			public float m_FrequencyGain;

			[Tooltip("How long the secondary reaction lasts.")]
			public float m_Duration;

			private float m_CurrentAmount;

			private float m_CurrentTime;

			private float m_CurrentDamping;

			private bool m_Initialized;

			[SerializeField]
			[HideInInspector]
			private Vector3 m_NoiseOffsets;

			public void ReSeed()
			{
				m_NoiseOffsets = new Vector3(UnityEngine.Random.Range(-1000f, 1000f), UnityEngine.Random.Range(-1000f, 1000f), UnityEngine.Random.Range(-1000f, 1000f));
			}

			public bool GetReaction(float deltaTime, Vector3 impulsePos, out Vector3 pos, out Quaternion rot)
			{
				if (!m_Initialized)
				{
					m_Initialized = true;
					m_CurrentAmount = 0f;
					m_CurrentDamping = 0f;
					m_CurrentTime = CinemachineCore.CurrentTime * m_FrequencyGain;
					if (m_NoiseOffsets == Vector3.zero)
					{
						ReSeed();
					}
				}
				pos = Vector3.zero;
				rot = Quaternion.identity;
				float sqrMagnitude = impulsePos.sqrMagnitude;
				if (m_SecondaryNoise == null || (sqrMagnitude < 0.001f && m_CurrentAmount < 0.0001f))
				{
					return false;
				}
				if (TargetPositionCache.CacheMode == TargetPositionCache.Mode.Playback && TargetPositionCache.HasCurrentTime)
				{
					m_CurrentTime = TargetPositionCache.CurrentTime * m_FrequencyGain;
				}
				else
				{
					m_CurrentTime += deltaTime * m_FrequencyGain;
				}
				m_CurrentAmount = Mathf.Max(m_CurrentAmount, Mathf.Sqrt(sqrMagnitude));
				m_CurrentDamping = Mathf.Max(m_CurrentDamping, Mathf.Max(1f, Mathf.Sqrt(m_CurrentAmount)) * m_Duration);
				float num = m_CurrentAmount * m_AmplitudeGain;
				pos = NoiseSettings.GetCombinedFilterResults(m_SecondaryNoise.PositionNoise, m_CurrentTime, m_NoiseOffsets) * num;
				rot = Quaternion.Euler(NoiseSettings.GetCombinedFilterResults(m_SecondaryNoise.OrientationNoise, m_CurrentTime, m_NoiseOffsets) * num);
				m_CurrentAmount -= Damper.Damp(m_CurrentAmount, m_CurrentDamping, deltaTime);
				m_CurrentDamping -= Damper.Damp(m_CurrentDamping, m_CurrentDamping, deltaTime);
				return true;
			}
		}

		[Tooltip("When to apply the impulse reaction.  Default is after the Noise stage.  Modify this if necessary to influence the ordering of extension effects")]
		public CinemachineCore.Stage m_ApplyAfter = CinemachineCore.Stage.Aim;

		[Tooltip("Impulse events on channels not included in the mask will be ignored.")]
		[CinemachineImpulseChannelProperty]
		public int m_ChannelMask;

		[Tooltip("Gain to apply to the Impulse signal.  1 is normal strength.  Setting this to 0 completely mutes the signal.")]
		public float m_Gain;

		[Tooltip("Enable this to perform distance calculation in 2D (ignore Z)")]
		public bool m_Use2DDistance;

		[Tooltip("Enable this to process all impulse signals in camera space")]
		public bool m_UseCameraSpace;

		[Tooltip("This controls the secondary reaction of the listener to the incoming impulse.  The impulse might be for example a sharp shock, and the secondary reaction could be a vibration whose amplitude and duration is controlled by the size of the original impulse.  This allows different listeners to respond in different ways to the same impulse signal.")]
		public ImpulseReaction m_ReactionSettings;

		private void Reset()
		{
			m_ApplyAfter = CinemachineCore.Stage.Noise;
			m_ChannelMask = 1;
			m_Gain = 1f;
			m_Use2DDistance = false;
			m_UseCameraSpace = true;
			m_ReactionSettings = new ImpulseReaction
			{
				m_AmplitudeGain = 1f,
				m_FrequencyGain = 1f,
				m_Duration = 1f
			};
		}

		protected override void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, CinemachineCore.Stage stage, ref CameraState state, float deltaTime)
		{
			if (stage != m_ApplyAfter || !(deltaTime >= 0f))
			{
				return;
			}
			Vector3 pos;
			Quaternion rot;
			bool impulseAt = CinemachineImpulseManager.Instance.GetImpulseAt(state.FinalPosition, m_Use2DDistance, m_ChannelMask, out pos, out rot);
			Vector3 pos2;
			Quaternion rot2;
			bool reaction = m_ReactionSettings.GetReaction(deltaTime, pos, out pos2, out rot2);
			if (impulseAt)
			{
				rot = Quaternion.SlerpUnclamped(Quaternion.identity, rot, m_Gain);
				pos *= m_Gain;
			}
			if (reaction)
			{
				pos += pos2;
				rot *= rot2;
			}
			if (impulseAt || reaction)
			{
				if (m_UseCameraSpace)
				{
					pos = state.RawOrientation * pos;
				}
				state.PositionCorrection += pos;
				state.OrientationCorrection *= rot;
			}
		}
	}
	public sealed class CinemachineImpulseEnvelopePropertyAttribute : PropertyAttribute
	{
	}
	public sealed class CinemachineImpulseChannelPropertyAttribute : PropertyAttribute
	{
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.API)]
	public class CinemachineImpulseManager
	{
		[Serializable]
		public struct EnvelopeDefinition
		{
			[Tooltip("Normalized curve defining the shape of the start of the envelope.  If blank a default curve will be used")]
			public AnimationCurve m_AttackShape;

			[Tooltip("Normalized curve defining the shape of the end of the envelope.  If blank a default curve will be used")]
			public AnimationCurve m_DecayShape;

			[Tooltip("Duration in seconds of the attack.  Attack curve will be scaled to fit.  Must be >= 0.")]
			public float m_AttackTime;

			[Tooltip("Duration in seconds of the central fully-scaled part of the envelope.  Must be >= 0.")]
			public float m_SustainTime;

			[Tooltip("Duration in seconds of the decay.  Decay curve will be scaled to fit.  Must be >= 0.")]
			public float m_DecayTime;

			[Tooltip("If checked, signal amplitude scaling will also be applied to the time envelope of the signal.  Stronger signals will last longer.")]
			public bool m_ScaleWithImpact;

			[Tooltip("If true, then duration is infinite.")]
			public bool m_HoldForever;

			public float Duration
			{
				get
				{
					if (m_HoldForever)
					{
						return -1f;
					}
					return m_AttackTime + m_SustainTime + m_DecayTime;
				}
			}

			public static EnvelopeDefinition Default()
			{
				return new EnvelopeDefinition
				{
					m_DecayTime = 0.7f,
					m_SustainTime = 0.2f,
					m_ScaleWithImpact = true
				};
			}

			public float GetValueAt(float offset)
			{
				if (offset >= 0f)
				{
					if (offset < m_AttackTime && m_AttackTime > 0.0001f)
					{
						if (m_AttackShape == null || m_AttackShape.length < 2)
						{
							return Damper.Damp(1f, m_AttackTime, offset);
						}
						return m_AttackShape.Evaluate(offset / m_AttackTime);
					}
					offset -= m_AttackTime;
					if (m_HoldForever || offset < m_SustainTime)
					{
						return 1f;
					}
					offset -= m_SustainTime;
					if (offset < m_DecayTime && m_DecayTime > 0.0001f)
					{
						if (m_DecayShape == null || m_DecayShape.length < 2)
						{
							return 1f - Damper.Damp(1f, m_DecayTime, offset);
						}
						return m_DecayShape.Evaluate(offset / m_DecayTime);
					}
				}
				return 0f;
			}

			public void ChangeStopTime(float offset, bool forceNoDecay)
			{
				if (offset < 0f)
				{
					offset = 0f;
				}
				if (offset < m_AttackTime)
				{
					m_AttackTime = 0f;
				}
				m_SustainTime = offset - m_AttackTime;
				if (forceNoDecay)
				{
					m_DecayTime = 0f;
				}
			}

			public void Clear()
			{
				m_AttackShape = (m_DecayShape = null);
				m_AttackTime = (m_SustainTime = (m_DecayTime = 0f));
			}

			public void Validate()
			{
				m_AttackTime = Mathf.Max(0f, m_AttackTime);
				m_DecayTime = Mathf.Max(0f, m_DecayTime);
				m_SustainTime = Mathf.Max(0f, m_SustainTime);
			}
		}

		public class ImpulseEvent
		{
			public enum DirectionMode
			{
				Fixed,
				RotateTowardSource
			}

			public enum DissipationMode
			{
				LinearDecay,
				SoftDecay,
				ExponentialDecay
			}

			public float m_StartTime;

			public EnvelopeDefinition m_Envelope;

			public ISignalSource6D m_SignalSource;

			public Vector3 m_Position;

			public float m_Radius;

			public DirectionMode m_DirectionMode;

			public int m_Channel;

			public DissipationMode m_DissipationMode;

			public float m_DissipationDistance;

			public float m_CustomDissipation;

			public float m_PropagationSpeed;

			public bool Expired
			{
				get
				{
					float duration = m_Envelope.Duration;
					float num = m_Radius + m_DissipationDistance;
					float num2 = Instance.CurrentTime - num / Mathf.Max(1f, m_PropagationSpeed);
					if (duration > 0f)
					{
						return m_StartTime + duration <= num2;
					}
					return false;
				}
			}

			public void Cancel(float time, bool forceNoDecay)
			{
				m_Envelope.m_HoldForever = false;
				m_Envelope.ChangeStopTime(time - m_StartTime, forceNoDecay);
			}

			public float DistanceDecay(float distance)
			{
				float num = Mathf.Max(m_Radius, 0f);
				if (distance < num)
				{
					return 1f;
				}
				distance -= num;
				if (distance >= m_DissipationDistance)
				{
					return 0f;
				}
				if (m_CustomDissipation >= 0f)
				{
					return EvaluateDissipationScale(m_CustomDissipation, distance / m_DissipationDistance);
				}
				return m_DissipationMode switch
				{
					DissipationMode.SoftDecay => 0.5f * (1f + Mathf.Cos(MathF.PI * (distance / m_DissipationDistance))), 
					DissipationMode.ExponentialDecay => 1f - Damper.Damp(1f, m_DissipationDistance, distance), 
					_ => Mathf.Lerp(1f, 0f, distance / m_DissipationDistance), 
				};
			}

			public bool GetDecayedSignal(Vector3 listenerPosition, bool use2D, out Vector3 pos, out Quaternion rot)
			{
				if (m_SignalSource != null)
				{
					float num = (use2D ? Vector2.Distance(listenerPosition, m_Position) : Vector3.Distance(listenerPosition, m_Position));
					float num2 = Instance.CurrentTime - m_StartTime - num / Mathf.Max(1f, m_PropagationSpeed);
					float num3 = m_Envelope.GetValueAt(num2) * DistanceDecay(num);
					if (num3 != 0f)
					{
						m_SignalSource.GetSignal(num2, out pos, out rot);
						pos *= num3;
						rot = Quaternion.SlerpUnclamped(Quaternion.identity, rot, num3);
						if (m_DirectionMode == DirectionMode.RotateTowardSource && num > 0.0001f)
						{
							Quaternion quaternion = Quaternion.FromToRotation(Vector3.up, listenerPosition - m_Position);
							if (m_Radius > 0.0001f)
							{
								float num4 = Mathf.Clamp01(num / m_Radius);
								quaternion = Quaternion.Slerp(quaternion, Quaternion.identity, Mathf.Cos(MathF.PI * num4 / 2f));
							}
							pos = quaternion * pos;
						}
						return true;
					}
				}
				pos = Vector3.zero;
				rot = Quaternion.identity;
				return false;
			}

			public void Clear()
			{
				m_Envelope.Clear();
				m_StartTime = 0f;
				m_SignalSource = null;
				m_Position = Vector3.zero;
				m_Channel = 0;
				m_Radius = 0f;
				m_DissipationDistance = 100f;
				m_DissipationMode = DissipationMode.ExponentialDecay;
				m_CustomDissipation = -1f;
			}

			internal ImpulseEvent()
			{
			}
		}

		private static CinemachineImpulseManager sInstance;

		private const float Epsilon = 0.0001f;

		private List<ImpulseEvent> m_ExpiredEvents;

		private List<ImpulseEvent> m_ActiveEvents;

		public bool IgnoreTimeScale;

		public static CinemachineImpulseManager Instance
		{
			get
			{
				if (sInstance == null)
				{
					sInstance = new CinemachineImpulseManager();
				}
				return sInstance;
			}
		}

		public float CurrentTime
		{
			get
			{
				if (!IgnoreTimeScale)
				{
					return CinemachineCore.CurrentTime;
				}
				return Time.realtimeSinceStartup;
			}
		}

		private CinemachineImpulseManager()
		{
		}

		[RuntimeInitializeOnLoadMethod]
		private static void InitializeModule()
		{
			if (sInstance != null)
			{
				sInstance.Clear();
			}
		}

		internal static float EvaluateDissipationScale(float spread, float normalizedDistance)
		{
			float num = -0.8f + 1.6f * (1f - spread);
			num = (1f - num) * 0.5f;
			float t = Mathf.Clamp01(normalizedDistance) / ((1f / Mathf.Clamp01(num) - 2f) * (1f - normalizedDistance) + 1f);
			return 1f - SplineHelpers.Bezier1(t, 0f, 0f, 1f, 1f);
		}

		public bool GetImpulseAt(Vector3 listenerLocation, bool distance2D, int channelMask, out Vector3 pos, out Quaternion rot)
		{
			bool result = false;
			pos = Vector3.zero;
			rot = Quaternion.identity;
			if (m_ActiveEvents != null)
			{
				for (int num = m_ActiveEvents.Count - 1; num >= 0; num--)
				{
					ImpulseEvent impulseEvent = m_ActiveEvents[num];
					if (impulseEvent == null || impulseEvent.Expired)
					{
						m_ActiveEvents.RemoveAt(num);
						if (impulseEvent != null)
						{
							if (m_ExpiredEvents == null)
							{
								m_ExpiredEvents = new List<ImpulseEvent>();
							}
							impulseEvent.Clear();
							m_ExpiredEvents.Add(impulseEvent);
						}
					}
					else if ((impulseEvent.m_Channel & channelMask) != 0)
					{
						Vector3 pos2 = Vector3.zero;
						Quaternion rot2 = Quaternion.identity;
						if (impulseEvent.GetDecayedSignal(listenerLocation, distance2D, out pos2, out rot2))
						{
							result = true;
							pos += pos2;
							rot *= rot2;
						}
					}
				}
			}
			return result;
		}

		public ImpulseEvent NewImpulseEvent()
		{
			if (m_ExpiredEvents == null || m_ExpiredEvents.Count == 0)
			{
				return new ImpulseEvent
				{
					m_CustomDissipation = -1f
				};
			}
			ImpulseEvent result = m_ExpiredEvents[m_ExpiredEvents.Count - 1];
			m_ExpiredEvents.RemoveAt(m_ExpiredEvents.Count - 1);
			return result;
		}

		public void AddImpulseEvent(ImpulseEvent e)
		{
			if (m_ActiveEvents == null)
			{
				m_ActiveEvents = new List<ImpulseEvent>();
			}
			if (e != null)
			{
				e.m_StartTime = CurrentTime;
				m_ActiveEvents.Add(e);
			}
		}

		public void Clear()
		{
			if (m_ActiveEvents != null)
			{
				for (int i = 0; i < m_ActiveEvents.Count; i++)
				{
					m_ActiveEvents[i].Clear();
				}
				m_ActiveEvents.Clear();
			}
		}
	}
	[DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
	[SaveDuringPlay]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineImpulseSourceOverview.html")]
	public class CinemachineImpulseSource : MonoBehaviour
	{
		public CinemachineImpulseDefinition m_ImpulseDefinition = new CinemachineImpulseDefinition();

		[Header("Default Invocation")]
		[Tooltip("The default direction and force of the Impulse Signal in the absense of any specified overrides.  Overrides can be specified by calling the appropriate GenerateImpulse method in the API.")]
		public Vector3 m_DefaultVelocity = Vector3.down;

		private void OnValidate()
		{
			m_ImpulseDefinition.OnValidate();
		}

		private void Reset()
		{
			m_ImpulseDefinition = new CinemachineImpulseDefinition
			{
				m_ImpulseChannel = 1,
				m_ImpulseShape = CinemachineImpulseDefinition.ImpulseShapes.Bump,
				m_CustomImpulseShape = new AnimationCurve(),
				m_ImpulseDuration = 0.2f,
				m_ImpulseType = CinemachineImpulseDefinition.ImpulseTypes.Uniform,
				m_DissipationDistance = 100f,
				m_DissipationRate = 0.25f,
				m_PropagationSpeed = 343f
			};
			m_DefaultVelocity = Vector3.down;
		}

		public void GenerateImpulseAtPositionWithVelocity(Vector3 position, Vector3 velocity)
		{
			if (m_ImpulseDefinition != null)
			{
				m_ImpulseDefinition.CreateEvent(position, velocity);
			}
		}

		public void GenerateImpulseWithVelocity(Vector3 velocity)
		{
			GenerateImpulseAtPositionWithVelocity(base.transform.position, velocity);
		}

		public void GenerateImpulseWithForce(float force)
		{
			GenerateImpulseAtPositionWithVelocity(base.transform.position, m_DefaultVelocity * force);
		}

		public void GenerateImpulse()
		{
			GenerateImpulseWithVelocity(m_DefaultVelocity);
		}

		public void GenerateImpulseAt(Vector3 position, Vector3 velocity)
		{
			GenerateImpulseAtPositionWithVelocity(position, velocity);
		}

		public void GenerateImpulse(Vector3 velocity)
		{
			GenerateImpulseWithVelocity(velocity);
		}

		public void GenerateImpulse(float force)
		{
			GenerateImpulseWithForce(force);
		}
	}
	[SaveDuringPlay]
	[HelpURL("https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/api/Cinemachine.CinemachineIndependentImpulseListener.html")]
	public class CinemachineIndependentImpulseListener : MonoBehaviour
	{
		private Vector3 impulsePosLastFrame;

		private Quaternion impulseRotLastFrame;

		[Tooltip("Impulse events on channels not included in the mask will be ignored.")]
		[CinemachineImpulseChannelProperty]
		public int m_ChannelMask;

		[Tooltip("Gain to apply to the Impulse signal.  1 is normal strength.  Setting this to 0 completely mutes the signal.")]
		public float m_Gain;

		[Tooltip("Enable this to perform distance calculation in 2D (ignore Z)")]
		public bool m_Use2DDistance;

		[Tooltip("Enable this to process all impulse signals in camera space")]
		public bool m_UseLocalSpace;

		[Tooltip("This controls the secondary reaction of the listener to the incoming impulse.  The impulse might be for example a sharp shock, and the secondary reaction could be a vibration whose amplitude and duration is controlled by the size of the original impulse.  This allows different listeners to respond in different ways to the same impulse signal.")]
		public CinemachineImpulseListener.ImpulseReaction m_ReactionSettings;

		private void Reset()
		{
			m_ChannelMask = 1;
			m_Gain = 1f;
			m_Use2DDistance = false;
			m_UseLocalSpace = true;
			m_ReactionSettings = new CinemachineImpulseListener.ImpulseReaction
			{
				m_AmplitudeGain = 1f,
				m_FrequencyGain = 1f,
				m_Duration = 1f
			};
		}

		private void OnEnable()
		{
			impulsePosLastFrame = Vector3.zero;
			impulseRotLastFrame = Quaternion.identity;
		}

		private void Update()
		{
			base.transform.position -= impulsePosLastFrame;
			base.transform.rotation = base.transform.rotation * Quaternion.Inverse(impulseRotLastFrame);
		}

		private void LateUpdate()
		{
			bool impulseAt = CinemachineImpulseManager.Instance.GetImpulseAt(base.transform.position, m_Use2DDistance, m_ChannelMask, out impulsePosLastFrame, out impulseRotLastFrame);
			Vector3 pos;
			Quaternion rot;
			bool reaction = m_ReactionSettings.GetReaction(Time.deltaTime, impulsePosLastFrame, out pos, out rot);
			if (impulseAt)
			{
				impulseRotLastFrame = Quaternion.SlerpUnclamped(Quaternion.identity, impulseRotLastFrame, m_Gain);
				impulsePosLastFrame *= m_Gain;
			}
			if (reaction)
			{
				impulsePosLastFrame += pos;
				impulseRotLastFrame *= rot;
			}
			if (impulseAt || reaction)
			{
				if (m_UseLocalSpace)
				{
					impulsePosLastFrame = base.transform.rotation * impulsePosLastFrame;
				}
				base.transform.position += impulsePosLastFrame;
				base.transform.rotation = base.transform.rotation * impulseRotLastFrame;
			}
		}
	}
	internal static class ClipperLib
	{
		public struct DoublePoint
		{
			public double X;

			public double Y;

			public DoublePoint(double x = 0.0, double y = 0.0)
			{
				X = x;
				Y = y;
			}

			public DoublePoint(DoublePoint dp)
			{
				X = dp.X;
				Y = dp.Y;
			}

			public DoublePoint(IntPoint ip)
			{
				X = ip.X;
				Y = ip.Y;
			}
		}

		public class PolyTree : PolyNode
		{
			internal List<PolyNode> m_AllPolys = new List<PolyNode>();

			public int Total
			{
				get
				{
					int num = m_AllPolys.Count;
					if (num > 0 && m_Childs[0] != m_AllPolys[0])
					{
						num--;
					}
					return num;
				}
			}

			public void Clear()
			{
				for (int i = 0; i < m_AllPolys.Count; i++)
				{
					m_AllPolys[i] = null;
				}
				m_AllPolys.Clear();
				m_Childs.Clear();
			}

			public PolyNode GetFirst()
			{
				if (m_Childs.Count > 0)
				{
					return m_Childs[0];
				}
				return null;
			}
		}

		public class PolyNode
		{
			internal PolyNode m_Parent;

			internal List<IntPoint> m_polygon = new List<IntPoint>();

			internal int m_Index;

			internal JoinType m_jointype;

			internal EndType m_endtype;

			internal List<PolyNode> m_Childs = new List<PolyNode>();

			public int ChildCount => m_Childs.Count;

			public List<IntPoint> Contour => m_polygon;

			public List<PolyNode> Childs => m_Childs;

			public PolyNode Parent => m_Parent;

			public bool IsHole => IsHoleNode();

			public bool IsOpen { get; set; }

			private bool IsHoleNode()
			{
				bool flag = true;
				for (PolyNode parent = m_Parent; parent != null; parent = parent.m_Parent)
				{
					flag = !flag;
				}
				return flag;
			}

			internal void AddChild(PolyNode Child)
			{
				int count = m_Childs.Count;
				m_Childs.Add(Child);
				Child.m_Parent = this;
				Child.m_Index = count;
			}

			public PolyNode GetNext()
			{
				if (m_Childs.Count > 0)
				{
					return m_Childs[0];
				}
				return GetNextSiblingUp();
			}

			internal PolyNode GetNextSiblingUp()
			{
				if (m_Parent == null)
				{
					return null;
				}
				if (m_Index == m_Parent.m_Childs.Count - 1)
				{
					return m_Parent.GetNextSiblingUp();
				}
				return m_Parent.m_Childs[m_Index + 1];
			}
		}

		internal struct Int128
		{
			private long hi;

			private ulong lo;

			public Int128(long _lo)
			{
				lo = (ulong)_lo;
				if (_lo < 0)
				{
					hi = -1L;
				}
				else
				{
					hi = 0L;
				}
			}

			public Int128(long _hi, ulong _lo)
			{
				lo = _lo;
				hi = _hi;
			}

			public Int128(Int128 val)
			{
				hi = val.hi;
				lo = val.lo;
			}

			public bool IsNegative()
			{
				return hi < 0;
			}

			public static bool operator ==(Int128 val1, Int128 val2)
			{
				if ((object)val1 == (object)val2)
				{
					return true;
				}
				if ((object)val1 == null || (object)val2 == null)
				{
					return false;
				}
				if (val1.hi == val2.hi)
				{
					return val1.lo == val2.lo;
				}
				return false;
			}

			public static bool operator !=(Int128 val1, Int128 val2)
			{
				return !(val1 == val2);
			}

			public override bool Equals(object obj)
			{
				if (obj == null || !(obj is Int128 @int))
				{
					return false;
				}
				if (@int.hi == hi)
				{
					return @int.lo == lo;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return hi.GetHashCode() ^ lo.GetHashCode();
			}

			public static bool operator >(Int128 val1, Int128 val2)
			{
				if (val1.hi != val2.hi)
				{
					return val1.hi > val2.hi;
				}
				return val1.lo > val2.lo;
			}

			public static bool operator <(Int128 val1, Int128 val2)
			{
				if (val1.hi != val2.hi)
				{
					return val1.hi < val2.hi;
				}
				return val1.lo < val2.lo;
			}

			public static Int128 operator +(Int128 lhs, Int128 rhs)
			{
				lhs.hi += rhs.hi;
				lhs.lo += rhs.lo;
				if (lhs.lo < rhs.lo)
				{
					lhs.hi++;
				}
				return lhs;
			}

			public static Int128 operator -(Int128 lhs, Int128 rhs)
			{
				return lhs + -rhs;
			}

			public static Int128 operator -(Int128 val)
			{
				if (val.lo == 0L)
				{
					return new Int128(-val.hi, 0uL);
				}
				return new Int128(~val.hi, ~val.lo + 1);
			}

			public static explicit operator double(Int128 val)
			{
				if (val.hi < 0)
				{
					if (val.lo == 0L)
					{
						return (double)val.hi * 1.8446744073709552E+19;
					}
					return 0.0 - ((double)(~val.lo) + (double)(~val.hi) * 1.8446744073709552E+19);
				}
				return (double)val.lo + (double)val.hi * 1.8446744073709552E+19;
			}

			public static Int128 Int128Mul(long lhs, long rhs)
			{
				bool num = lhs < 0 != rhs < 0;
				if (lhs < 0)
				{
					lhs = -lhs;
				}
				if (rhs < 0)
				{
					rhs = -rhs;
				}
				long num2 = lhs >>> 32;
				ulong num3 = (ulong)(lhs & 0xFFFFFFFFu);
				ulong num4 = (ulong)rhs >> 32;
				ulong num5 = (ulong)(rhs & 0xFFFFFFFFu);
				ulong num6 = (ulong)num2 * num4;
				ulong num7 = num3 * num5;
				ulong num8 = (ulong)(num2 * (long)num5) + num3 * num4;
				long num9 = (long)(num6 + (num8 >> 32));
				ulong num10 = (num8 << 32) + num7;
				if (num10 < num7)
				{
					num9++;
				}
				Int128 @int = new Int128(num9, num10);
				if (!num)
				{
					return @int;
				}
				return -@int;
			}
		}

		public struct IntPoint
		{
			public long X;

			public long Y;

			public IntPoint(long X, long Y)
			{
				this.X = X;
				this.Y = Y;
			}

			public IntPoint(double x, double y)
			{
				X = (long)x;
				Y = (long)y;
			}

			public IntPoint(IntPoint pt)
			{
				X = pt.X;
				Y = pt.Y;
			}

			public static bool operator ==(IntPoint a, IntPoint b)
			{
				if (a.X == b.X)
				{
					return a.Y == b.Y;
				}
				return false;
			}

			public static bool operator !=(IntPoint a, IntPoint b)
			{
				if (a.X == b.X)
				{
					return a.Y != b.Y;
				}
				return true;
			}

			public override bool Equals(object obj)
			{
				if (obj == null)
				{
					return false;
				}
				if (obj is IntPoint intPoint)
				{
					if (X == intPoint.X)
					{
						return Y == intPoint.Y;
					}
					return false;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return base.GetHashCode();
			}
		}

		public struct IntRect
		{
			public long left;

			public long top;

			public long right;

			public long bottom;

			public IntRect(long l, long t, long r, long b)
			{
				left = l;
				top = t;
				right = r;
				bottom = b;
			}

			public IntRect(IntRect ir)
			{
				left = ir.left;
				top = ir.top;
				right = ir.right;
				bottom = ir.bottom;
			}
		}

		public enum ClipType
		{
			ctIntersection,
			ctUnion,
			ctDifference,
			ctXor
		}

		public enum PolyType
		{
			ptSubject,
			ptClip
		}

		public enum PolyFillType
		{
			pftEvenOdd,
			pftNonZero,
			pftPositive,
			pftNegative
		}

		public enum JoinType
		{
			jtSquare,
			jtRound,
			jtMiter
		}

		public enum EndType
		{
			etClosedPolygon,
			etClosedLine,
			etOpenButt,
			etOpenSquare,
			etOpenRound
		}

		internal enum EdgeSide
		{
			esLeft,
			esRight
		}

		internal enum Direction
		{
			dRightToLeft,
			dLeftToRight
		}

		internal class TEdge
		{
			internal IntPoint Bot;

			internal IntPoint Curr;

			internal IntPoint Top;

			internal IntPoint Delta;

			internal double Dx;

			internal PolyType PolyTyp;

			internal EdgeSide Side;

			internal int WindDelta;

			internal int WindCnt;

			internal int WindCnt2;

			internal int OutIdx;

			internal TEdge Next;

			internal TEdge Prev;

			internal TEdge NextInLML;

			internal TEdge NextInAEL;

			internal TEdge PrevInAEL;

			internal TEdge NextInSEL;

			internal TEdge PrevInSEL;
		}

		public class IntersectNode
		{
			internal TEdge Edge1;

			internal TEdge Edge2;

			internal IntPoint Pt;
		}

		public class MyIntersectNodeSort : IComparer<IntersectNode>
		{
			public int Compare(IntersectNode node1, IntersectNode node2)
			{
				long num = node2.Pt.Y - node1.Pt.Y;
				if (num > 0)
				{
					return 1;
				}
				if (num < 0)
				{
					return -1;
				}
				return 0;
			}
		}

		internal class LocalMinima
		{
			internal long Y;

			internal TEdge LeftBound;

			internal TEdge RightBound;

			internal LocalMinima Next;
		}

		internal class Scanbeam
		{
			internal long Y;

			internal Scanbeam Next;
		}

		internal class Maxima
		{
			internal long X;

			internal Maxima Next;

			internal Maxima Prev;
		}

		internal class OutRec
		{
			internal int Idx;

			internal bool IsHole;

			internal bool IsOpen;

			internal OutRec FirstLeft;

			internal OutPt Pts;

			internal OutPt BottomPt;

			internal PolyNode PolyNode;
		}

		internal class OutPt
		{
			internal int Idx;

			internal IntPoint Pt;

			internal OutPt Next;

			internal OutPt Prev;
		}

		internal class Join
		{
			internal OutPt OutPt1;

			internal OutPt OutPt2;

			internal IntPoint OffPt;
		}

		public class ClipperBase
		{
			internal const double horizontal = -3.4E+38;

			internal const int Skip = -2;

			internal const int Unassigned = -1;

			internal const double tolerance = 1E-20;

			public const long loRange = 1073741823L;

			public const long hiRange = 4611686018427387903L;

			internal LocalMinima m_MinimaList;

			internal LocalMinima m_CurrentLM;

			internal List<List<TEdge>> m_edges = new List<List<TEdge>>();

			internal Scanbeam m_Scanbeam;

			internal List<OutRec> m_PolyOuts;

			internal TEdge m_ActiveEdges;

			internal bool m_UseFullRange;

			internal bool m_HasOpenPaths;

			public bool PreserveCollinear { get; set; }

			internal static bool near_zero(double val)
			{
				if (val > -1E-20)
				{
					return val < 1E-20;
				}
				return false;
			}

			public void Swap(ref long val1, ref long val2)
			{
				long num = val1;
				val1 = val2;
				val2 = num;
			}

			internal static bool IsHorizontal(TEdge e)
			{
				return e.Delta.Y == 0;
			}

			internal bool PointIsVertex(IntPoint pt, OutPt pp)
			{
				OutPt outPt = pp;
				do
				{
					if (outPt.Pt == pt)
					{
						return true;
					}
					outPt = outPt.Next;
				}
				while (outPt != pp);
				return false;
			}

			internal bool PointOnLineSegment(IntPoint pt, IntPoint linePt1, IntPoint linePt2, bool UseFullRange)
			{
				if (UseFullRange)
				{
					if ((pt.X != linePt1.X || pt.Y != linePt1.Y) && (pt.X != linePt2.X || pt.Y != linePt2.Y))
					{
						if (pt.X > linePt1.X == pt.X < linePt2.X && pt.Y > linePt1.Y == pt.Y < linePt2.Y)
						{
							return Int128.Int128Mul(pt.X - linePt1.X, linePt2.Y - linePt1.Y) == Int128.Int128Mul(linePt2.X - linePt1.X, pt.Y - linePt1.Y);
						}
						return false;
					}
					return true;
				}
				if ((pt.X != linePt1.X || pt.Y != linePt1.Y) && (pt.X != linePt2.X || pt.Y != linePt2.Y))
				{
					if (pt.X > linePt1.X == pt.X < linePt2.X && pt.Y > linePt1.Y == pt.Y < linePt2.Y)
					{
						return (pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y);
					}
					return false;
				}
				return true;
			}

			internal bool PointOnPolygon(IntPoint pt, OutPt pp, bool UseFullRange)
			{
				OutPt outPt = pp;
				do
				{
					if (PointOnLineSegment(pt, outPt.Pt, outPt.Next.Pt, UseFullRange))
					{
						return true;
					}
					outPt = outPt.Next;
				}
				while (outPt != pp);
				return false;
			}

			internal static bool SlopesEqual(TEdge e1, TEdge e2, bool UseFullRange)
			{
				if (UseFullRange)
				{
					return Int128.Int128Mul(e1.Delta.Y, e2.Delta.X) == Int128.Int128Mul(e1.Delta.X, e2.Delta.Y);
				}
				return e1.Delta.Y * e2.Delta.X == e1.Delta.X * e2.Delta.Y;
			}

			internal static bool SlopesEqual(IntPoint pt1, IntPoint pt2, IntPoint pt3, bool UseFullRange)
			{
				if (UseFullRange)
				{
					return Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X) == Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y);
				}
				return (pt1.Y - pt2.Y) * (pt2.X - pt3.X) - (pt1.X - pt2.X) * (pt2.Y - pt3.Y) == 0;
			}

			internal static bool SlopesEqual(IntPoint pt1, IntPoint pt2, IntPoint pt3, IntPoint pt4, bool UseFullRange)
			{
				if (UseFullRange)
				{
					return Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X) == Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y);
				}
				return (pt1.Y - pt2.Y) * (pt3.X - pt4.X) - (pt1.X - pt2.X) * (pt3.Y - pt4.Y) == 0;
			}

			internal ClipperBase()
			{
				m_MinimaList = null;
				m_CurrentLM = null;
				m_UseFullRange = false;
				m_HasOpenPaths = false;
			}

			public virtual void Clear()
			{
				DisposeLocalMinimaList();
				for (int i = 0; i < m_edges.Count; i++)
				{
					for (int j = 0; j < m_edges[i].Count; j++)
					{
						m_edges[i][j] = null;
					}
					m_edges[i].Clear();
				}
				m_edges.Clear();
				m_UseFullRange = false;
				m_HasOpenPaths = false;
			}

			private void DisposeLocalMinimaList()
			{
				while (m_MinimaList != null)
				{
					LocalMinima next = m_MinimaList.Next;
					m_MinimaList = null;
					m_MinimaList = next;
				}
				m_CurrentLM = null;
			}

			private void RangeTest(IntPoint Pt, ref bool useFullRange)
			{
				if (useFullRange)
				{
					if (Pt.X > 4611686018427387903L || Pt.Y > 4611686018427387903L || -Pt.X > 4611686018427387903L || -Pt.Y > 4611686018427387903L)
					{
						throw new ClipperException("Coordinate outside allowed range");
					}
				}
				else if (Pt.X > 1073741823 || Pt.Y > 1073741823 || -Pt.X > 1073741823 || -Pt.Y > 1073741823)
				{
					useFullRange = true;
					RangeTest(Pt, ref useFullRange);
				}
			}

			private void InitEdge(TEdge e, TEdge eNext, TEdge ePrev, IntPoint pt)
			{
				e.Next = eNext;
				e.Prev = ePrev;
				e.Curr = pt;
				e.OutIdx = -1;
			}

			private void InitEdge2(TEdge e, PolyType polyType)
			{
				if (e.Curr.Y >= e.Next.Curr.Y)
				{
					e.Bot = e.Curr;
					e.Top = e.Next.Curr;
				}
				else
				{
					e.Top = e.Curr;
					e.Bot = e.Next.Curr;
				}
				SetDx(e);
				e.PolyTyp = polyType;
			}

			private TEdge FindNextLocMin(TEdge E)
			{
				while (true)
				{
					if (E.Bot != E.Prev.Bot || E.Curr == E.Top)
					{
						E = E.Next;
						continue;
					}
					if (E.Dx != -3.4E+38 && E.Prev.Dx != -3.4E+38)
					{
						break;
					}
					while (E.Prev.Dx == -3.4E+38)
					{
						E = E.Prev;
					}
					TEdge tEdge = E;
					while (E.Dx == -3.4E+38)
					{
						E = E.Next;
					}
					if (E.Top.Y != E.Prev.Bot.Y)
					{
						if (tEdge.Prev.Bot.X < E.Bot.X)
						{
							E = tEdge;
						}
						break;
					}
				}
				return E;
			}

			private TEdge ProcessBound(TEdge E, bool LeftBoundIsForward)
			{
				TEdge tEdge = E;
				if (tEdge.OutIdx == -2)
				{
					E = tEdge;
					if (LeftBoundIsForward)
					{
						while (E.Top.Y == E.Next.Bot.Y)
						{
							E = E.Next;
						}
						while (E != tEdge && E.Dx == -3.4E+38)
						{
							E = E.Prev;
						}
					}
					else
					{
						while (E.Top.Y == E.Prev.Bot.Y)
						{
							E = E.Prev;
						}
						while (E != tEdge && E.Dx == -3.4E+38)
						{
							E = E.Next;
						}
					}
					if (E == tEdge)
					{
						tEdge = ((!LeftBoundIsForward) ? E.Prev : E.Next);
					}
					else
					{
						E = ((!LeftBoundIsForward) ? tEdge.Prev : tEdge.Next);
						LocalMinima localMinima = new LocalMinima();
						localMinima.Next = null;
						localMinima.Y = E.Bot.Y;
						localMinima.LeftBound = null;
						localMinima.RightBound = E;
						E.WindDelta = 0;
						tEdge = ProcessBound(E, LeftBoundIsForward);
						InsertLocalMinima(localMinima);
					}
					return tEdge;
				}
				TEdge tEdge2;
				if (E.Dx == -3.4E+38)
				{
					tEdge2 = ((!LeftBoundIsForward) ? E.Next : E.Prev);
					if (tEdge2.Dx == -3.4E+38)
					{
						if (tEdge2.Bot.X != E.Bot.X && tEdge2.Top.X != E.Bot.X)
						{
							ReverseHorizontal(E);
						}
					}
					else if (tEdge2.Bot.X != E.Bot.X)
					{
						ReverseHorizontal(E);
					}
				}
				tEdge2 = E;
				if (LeftBoundIsForward)
				{
					while (tEdge.Top.Y == tEdge.Next.Bot.Y && tEdge.Next.OutIdx != -2)
					{
						tEdge = tEdge.Next;
					}
					if (tEdge.Dx == -3.4E+38 && tEdge.Next.OutIdx != -2)
					{
						TEdge tEdge3 = tEdge;
						while (tEdge3.Prev.Dx == -3.4E+38)
						{
							tEdge3 = tEdge3.Prev;
						}
						if (tEdge3.Prev.Top.X > tEdge.Next.Top.X)
						{
							tEdge = tEdge3.Prev;
						}
					}
					while (E != tEdge)
					{
						E.NextInLML = E.Next;
						if (E.Dx == -3.4E+38 && E != tEdge2 && E.Bot.X != E.Prev.Top.X)
						{
							ReverseHorizontal(E);
						}
						E = E.Next;
					}
					if (E.Dx == -3.4E+38 && E != tEdge2 && E.Bot.X != E.Prev.Top.X)
					{
						ReverseHorizontal(E);
					}
					return tEdge.Next;
				}
				while (tEdge.Top.Y == tEdge.Prev.Bot.Y && tEdge.Prev.OutIdx != -2)
				{
					tEdge = tEdge.Prev;
				}
				if (tEdge.Dx == -3.4E+38 && tEdge.Prev.OutIdx != -2)
				{
					TEdge tEdge3 = tEdge;
					while (tEdge3.Next.Dx == -3.4E+38)
					{
						tEdge3 = tEdge3.Next;
					}
					if (tEdge3.Next.Top.X == tEdge.Prev.Top.X || tEdge3.Next.Top.X > tEdge.Prev.Top.X)
					{
						tEdge = tEdge3.Next;
					}
				}
				while (E != tEdge)
				{
					E.NextInLML = E.Prev;
					if (E.Dx == -3.4E+38 && E != tEdge2 && E.Bot.X != E.Next.Top.X)
					{
						ReverseHorizontal(E);
					}
					E = E.Prev;
				}
				if (E.Dx == -3.4E+38 && E != tEdge2 && E.Bot.X != E.Next.Top.X)
				{
					ReverseHorizontal(E);
				}
				return tEdge.Prev;
			}

			public bool AddPath(List<IntPoint> pg, PolyType polyType, bool Closed)
			{
				if (!Closed && polyType == PolyType.ptClip)
				{
					throw new ClipperException("AddPath: Open paths must be subject.");
				}
				int num = pg.Count - 1;
				if (Closed)
				{
					while (num > 0 && pg[num] == pg[0])
					{
						num--;
					}
				}
				while (num > 0 && pg[num] == pg[num - 1])
				{
					num--;
				}
				if ((Closed && num < 2) || (!Closed && num < 1))
				{
					return false;
				}
				List<TEdge> list = new List<TEdge>(num + 1);
				for (int i = 0; i <= num; i++)
				{
					list.Add(new TEdge());
				}
				bool flag = true;
				list[1].Curr = pg[1];
				RangeTest(pg[0], ref m_UseFullRange);
				RangeTest(pg[num], ref m_UseFullRange);
				InitEdge(list[0], list[1], list[num], pg[0]);
				InitEdge(list[num], list[0], list[num - 1], pg[num]);
				for (int num2 = num - 1; num2 >= 1; num2--)
				{
					RangeTest(pg[num2], ref m_UseFullRange);
					InitEdge(list[num2], list[num2 + 1], list[num2 - 1], pg[num2]);
				}
				TEdge tEdge = list[0];
				TEdge tEdge2 = tEdge;
				TEdge tEdge3 = tEdge;
				while (true)
				{
					if (tEdge2.Curr == tEdge2.Next.Curr && (Closed || tEdge2.Next != tEdge))
					{
						if (tEdge2 == tEdge2.Next)
						{
							break;
						}
						if (tEdge2 == tEdge)
						{
							tEdge = tEdge2.Next;
						}
						tEdge2 = RemoveEdge(tEdge2);
						tEdge3 = tEdge2;
						continue;
					}
					if (tEdge2.Prev == tEdge2.Next)
					{
						break;
					}
					if (Closed && SlopesEqual(tEdge2.Prev.Curr, tEdge2.Curr, tEdge2.Next.Curr, m_UseFullRange) && (!PreserveCollinear || !Pt2IsBetweenPt1AndPt3(tEdge2.Prev.Curr, tEdge2.Curr, tEdge2.Next.Curr)))
					{
						if (tEdge2 == tEdge)
						{
							tEdge = tEdge2.Next;
						}
						tEdge2 = RemoveEdge(tEdge2);
						tEdge2 = tEdge2.Prev;
						tEdge3 = tEdge2;
					}
					else
					{
						tEdge2 = tEdge2.Next;
						if (tEdge2 == tEdge3 || (!Closed && tEdge2.Next == tEdge))
						{
							break;
						}
					}
				}
				if ((!Closed && tEdge2 == tEdge2.Next) || (Closed && tEdge2.Prev == tEdge2.Next))
				{
					return false;
				}
				if (!Closed)
				{
					m_HasOpenPaths = true;
					tEdge.Prev.OutIdx = -2;
				}
				tEdge2 = tEdge;
				do
				{
					InitEdge2(tEdge2, polyType);
					tEdge2 = tEdge2.Next;
					if (flag && tEdge2.Curr.Y != tEdge.Curr.Y)
					{
						flag = false;
					}
				}
				while (tEdge2 != tEdge);
				if (flag)
				{
					if (Closed)
					{
						return false;
					}
					tEdge2.Prev.OutIdx = -2;
					LocalMinima localMinima = new LocalMinima();
					localMinima.Next = null;
					localMinima.Y = tEdge2.Bot.Y;
					localMinima.LeftBound = null;
					localMinima.RightBound = tEdge2;
					localMinima.RightBound.Side = EdgeSide.esRight;
					localMinima.RightBound.WindDelta = 0;
					while (true)
					{
						if (tEdge2.Bot.X != tEdge2.Prev.Top.X)
						{
							ReverseHorizontal(tEdge2);
						}
						if (tEdge2.Next.OutIdx == -2)
						{
							break;
						}
						tEdge2.NextInLML = tEdge2.Next;
						tEdge2 = tEdge2.Next;
					}
					InsertLocalMinima(localMinima);
					m_edges.Add(list);
					return true;
				}
				m_edges.Add(list);
				TEdge tEdge4 = null;
				if (tEdge2.Prev.Bot == tEdge2.Prev.Top)
				{
					tEdge2 = tEdge2.Next;
				}
				while (true)
				{
					tEdge2 = FindNextLocMin(tEdge2);
					if (tEdge2 == tEdge4)
					{
						break;
					}
					if (tEdge4 == null)
					{
						tEdge4 = tEdge2;
					}
					LocalMinima localMinima2 = new LocalMinima();
					localMinima2.Next = null;
					localMinima2.Y = tEdge2.Bot.Y;
					bool flag2;
					if (tEdge2.Dx < tEdge2.Prev.Dx)
					{
						localMinima2.LeftBound = tEdge2.Prev;
						localMinima2.RightBound = tEdge2;
						flag2 = false;
					}
					else
					{
						localMinima2.LeftBound = tEdge2;
						localMinima2.RightBound = tEdge2.Prev;
						flag2 = true;
					}
					localMinima2.LeftBound.Side = EdgeSide.esLeft;
					localMinima2.RightBound.Side = EdgeSide.esRight;
					if (!Closed)
					{
						localMinima2.LeftBound.WindDelta = 0;
					}
					else if (localMinima2.LeftBound.Next == localMinima2.RightBound)
					{
						localMinima2.LeftBound.WindDelta = -1;
					}
					else
					{
						localMinima2.LeftBound.WindDelta = 1;
					}
					localMinima2.RightBound.WindDelta = -localMinima2.LeftBound.WindDelta;
					tEdge2 = ProcessBound(localMinima2.LeftBound, flag2);
					if (tEdge2.OutIdx == -2)
					{
						tEdge2 = ProcessBound(tEdge2, flag2);
					}
					TEdge tEdge5 = ProcessBound(localMinima2.RightBound, !flag2);
					if (tEdge5.OutIdx == -2)
					{
						tEdge5 = ProcessBound(tEdge5, !flag2);
					}
					if (localMinima2.LeftBound.OutIdx == -2)
					{
						localMinima2.LeftBound = null;
					}
					else if (localMinima2.RightBound.OutIdx == -2)
					{
						localMinima2.RightBound = null;
					}
					InsertLocalMinima(localMinima2);
					if (!flag2)
					{
						tEdge2 = tEdge5;
					}
				}
				return true;
			}

			public bool AddPaths(List<List<IntPoint>> ppg, PolyType polyType, bool closed)
			{
				bool result = false;
				for (int i = 0; i < ppg.Count; i++)
				{
					if (AddPath(ppg[i], polyType, closed))
					{
						result = true;
					}
				}
				return result;
			}

			internal bool Pt2IsBetweenPt1AndPt3(IntPoint pt1, IntPoint pt2, IntPoint pt3)
			{
				if (pt1 == pt3 || pt1 == pt2 || pt3 == pt2)
				{
					return false;
				}
				if (pt1.X != pt3.X)
				{
					return pt2.X > pt1.X == pt2.X < pt3.X;
				}
				return pt2.Y > pt1.Y == pt2.Y < pt3.Y;
			}

			private TEdge RemoveEdge(TEdge e)
			{
				e.Prev.Next = e.Next;
				e.Next.Prev = e.Prev;
				TEdge next = e.Next;
				e.Prev = null;
				return next;
			}

			private void SetDx(TEdge e)
			{
				e.Delta.X = e.Top.X - e.Bot.X;
				e.Delta.Y = e.Top.Y - e.Bot.Y;
				if (e.Delta.Y == 0L)
				{
					e.Dx = -3.4E+38;
				}
				else
				{
					e.Dx = (double)e.Delta.X / (double)e.Delta.Y;
				}
			}

			private void InsertLocalMinima(LocalMinima newLm)
			{
				if (m_MinimaList == null)
				{
					m_MinimaList = newLm;
					return;
				}
				if (newLm.Y >= m_MinimaList.Y)
				{
					newLm.Next = m_MinimaList;
					m_MinimaList = newLm;
					return;
				}
				LocalMinima localMinima = m_MinimaList;
				while (localMinima.Next != null && newLm.Y < localMinima.Next.Y)
				{
					localMinima = localMinima.Next;
				}
				newLm.Next = localMinima.Next;
				localMinima.Next = newLm;
			}

			internal bool PopLocalMinima(long Y, out LocalMinima current)
			{
				current = m_CurrentLM;
				if (m_CurrentLM != null && m_CurrentLM.Y == Y)
				{
					m_CurrentLM = m_CurrentLM.Next;
					return true;
				}
				return false;
			}

			private void ReverseHorizontal(TEdge e)
			{
				Swap(ref e.Top.X, ref e.Bot.X);
			}

			internal virtual void Reset()
			{
				m_CurrentLM = m_MinimaList;
				if (m_CurrentLM == null)
				{
					return;
				}
				m_Scanbeam = null;
				for (LocalMinima localMinima = m_MinimaList; localMinima != null; localMinima = localMinima.Next)
				{
					InsertScanbeam(localMinima.Y);
					TEdge leftBound = localMinima.LeftBound;
					if (leftBound != null)
					{
						leftBound.Curr = leftBound.Bot;
						leftBound.OutIdx = -1;
					}
					leftBound = localMinima.RightBound;
					if (leftBound != null)
					{
						leftBound.Curr = leftBound.Bot;
						leftBound.OutIdx = -1;
					}
				}
				m_ActiveEdges = null;
			}

			public static IntRect GetBounds(List<List<IntPoint>> paths)
			{
				int i = 0;
				int count;
				for (count = paths.Count; i < count && paths[i].Count == 0; i++)
				{
				}
				if (i == count)
				{
					return new IntRect(0L, 0L, 0L, 0L);
				}
				IntRect result = default(IntRect);
				result.left = paths[i][0].X;
				result.right = result.left;
				result.top = paths[i][0].Y;
				result.bottom = result.top;
				for (; i < count; i++)
				{
					for (int j = 0; j < paths[i].Count; j++)
					{
						if (paths[i][j].X < result.left)
						{
							result.left = paths[i][j].X;
						}
						else if (paths[i][j].X > result.right)
						{
							result.right = paths[i][j].X;
						}
						if (paths[i][j].Y < result.top)
						{
							result.top = paths[i][j].Y;
						}
						else if (paths[i][j].Y > result.bottom)
						{
							result.bottom = paths[i][j].Y;
						}
					}
				}
				return result;
			}

			internal void InsertScanbeam(long Y)
			{
				if (m_Scanbeam == null)
				{
					m_Scanbeam = new Scanbeam();
					m_Scanbeam.Next = null;
					m_Scanbeam.Y = Y;
					return;
				}
				if (Y > m_Scanbeam.Y)
				{
					Scanbeam scanbeam = new Scanbeam();
					scanbeam.Y = Y;
					scanbeam.Next = m_Scanbeam;
					m_Scanbeam = scanbeam;
					return;
				}
				Scanbeam scanbeam2 = m_Scanbeam;
				while (scanbeam2.Next != null && Y <= scanbeam2.Next.Y)
				{
					scanbeam2 = scanbeam2.Next;
				}
				if (Y != scanbeam2.Y)
				{
					Scanbeam scanbeam3 = new Scanbeam();
					scanbeam3.Y = Y;
					scanbeam3.Next = scanbeam2.Next;
					scanbeam2.Next = scanbeam3;
				}
			}

			internal bool PopScanbeam(out long Y)
			{
				if (m_Scanbeam == null)
				{
					Y = 0L;
					return false;
				}
				Y = m_Scanbeam.Y;
				m_Scanbeam = m_Scanbeam.Next;
				return true;
			}

			internal bool LocalMinimaPending()
			{
				return m_CurrentLM != null;
			}

			internal OutRec CreateOutRec()
			{
				OutRec outRec = new OutRec();
				outRec.Idx = -1;
				outRec.IsHole = false;
				outRec.IsOpen = false;
				outRec.FirstLeft = null;
				outRec.Pts = null;
				outRec.BottomPt = null;
				outRec.PolyNode = null;
				m_PolyOuts.Add(outRec);
				outRec.Idx = m_PolyOuts.Count - 1;
				return outRec;
			}

			internal void DisposeOutRec(int index)
			{
				m_PolyOuts[index].Pts = null;
				m_PolyOuts[index] = null;
			}

			internal void UpdateEdgeIntoAEL(ref TEdge e)
			{
				if (e.NextInLML == null)
				{
					throw new ClipperException("UpdateEdgeIntoAEL: invalid call");
				}
				TEdge prevInAEL = e.PrevInAEL;
				TEdge nextInAEL = e.NextInAEL;
				e.NextInLML.OutIdx = e.OutIdx;
				if (prevInAEL != null)
				{
					prevInAEL.NextInAEL = e.NextInLML;
				}
				else
				{
					m_ActiveEdges = e.NextInLML;
				}
				if (nextInAEL != null)
				{
					nextInAEL.PrevInAEL = e.NextInLML;
				}
				e.NextInLML.Side = e.Side;
				e.NextInLML.WindDelta = e.WindDelta;
				e.NextInLML.WindCnt = e.WindCnt;
				e.NextInLML.WindCnt2 = e.WindCnt2;
				e = e.NextInLML;
				e.Curr = e.Bot;
				e.PrevInAEL = prevInAEL;
				e.NextInAEL = nextInAEL;
				if (!IsHorizontal(e))
				{
					InsertScanbeam(e.Top.Y);
				}
			}

			internal void SwapPositionsInAEL(TEdge edge1, TEdge edge2)
			{
				if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)
				{
					return;
				}
				if (edge1.NextInAEL == edge2)
				{
					TEdge nextInAEL = edge2.NextInAEL;
					if (nextInAEL != null)
					{
						nextInAEL.PrevInAEL = edge1;
					}
					TEdge prevInAEL = edge1.PrevInAEL;
					if (prevInAEL != null)
					{
						prevInAEL.NextInAEL = edge2;
					}
					edge2.PrevInAEL = prevInAEL;
					edge2.NextInAEL = edge1;
					edge1.PrevInAEL = edge2;
					edge1.NextInAEL = nextInAEL;
				}
				else if (edge2.NextInAEL == edge1)
				{
					TEdge nextInAEL2 = edge1.NextInAEL;
					if (nextInAEL2 != null)
					{
						nextInAEL2.PrevInAEL = edge2;
					}
					TEdge prevInAEL2 = edge2.PrevInAEL;
					if (prevInAEL2 != null)
					{
						prevInAEL2.NextInAEL = edge1;
					}
					edge1.PrevInAEL = prevInAEL2;
					edge1.NextInAEL = edge2;
					edge2.PrevInAEL = edge1;
					edge2.NextInAEL = nextInAEL2;
				}
				else
				{
					TEdge nextInAEL3 = edge1.NextInAEL;
					TEdge prevInAEL3 = edge1.PrevInAEL;
					edge1.NextInAEL = edge2.NextInAEL;
					if (edge1.NextInAEL != null)
					{
						edge1.NextInAEL.PrevInAEL = edge1;
					}
					edge1.PrevInAEL = edge2.PrevInAEL;
					if (edge1.PrevInAEL != null)
					{
						edge1.PrevInAEL.NextInAEL = edge1;
					}
					edge2.NextInAEL = nextInAEL3;
					if (edge2.NextInAEL != null)
					{
						edge2.NextInAEL.PrevInAEL = edge2;
					}
					edge2.PrevInAEL = prevInAEL3;
					if (edge2.PrevInAEL != null)
					{
						edge2.PrevInAEL.NextInAEL = edge2;
					}
				}
				if (edge1.PrevInAEL == null)
				{
					m_ActiveEdges = edge1;
				}
				else if (edge2.PrevInAEL == null)
				{
					m_ActiveEdges = edge2;
				}
			}

			internal void DeleteFromAEL(TEdge e)
			{
				TEdge prevInAEL = e.PrevInAEL;
				TEdge nextInAEL = e.NextInAEL;
				if (prevInAEL != null || nextInAEL != null || e == m_ActiveEdges)
				{
					if (prevInAEL != null)
					{
						prevInAEL.NextInAEL = nextInAEL;
					}
					else
					{
						m_ActiveEdges = nextInAEL;
					}
					if (nextInAEL != null)
					{
						nextInAEL.PrevInAEL = prevInAEL;
					}
					e.NextInAEL = null;
					e.PrevInAEL = null;
				}
			}
		}

		public class Clipper : ClipperBase
		{
			internal enum NodeType
			{
				ntAny,
				ntOpen,
				ntClosed
			}

			public const int ioReverseSolution = 1;

			public const int ioStrictlySimple = 2;

			public const int ioPreserveCollinear = 4;

			private ClipType m_ClipType;

			private Maxima m_Maxima;

			private TEdge m_SortedEdges;

			private List<IntersectNode> m_IntersectList;

			private IComparer<IntersectNode> m_IntersectNodeComparer;

			private bool m_ExecuteLocked;

			private PolyFillType m_ClipFillType;

			private PolyFillType m_SubjFillType;

			private List<Join> m_Joins;

			private List<Join> m_GhostJoins;

			private bool m_UsingPolyTree;

			public bool ReverseSolution { get; set; }

			public bool StrictlySimple { get; set; }

			public Clipper(int InitOptions = 0)
			{
				m_Scanbeam = null;
				m_Maxima = null;
				m_ActiveEdges = null;
				m_SortedEdges = null;
				m_IntersectList = new List<IntersectNode>();
				m_IntersectNodeComparer = new MyIntersectNodeSort();
				m_ExecuteLocked = false;
				m_UsingPolyTree = false;
				m_PolyOuts = new List<OutRec>();
				m_Joins = new List<Join>();
				m_GhostJoins = new List<Join>();
				ReverseSolution = (1 & InitOptions) != 0;
				StrictlySimple = (2 & InitOptions) != 0;
				base.PreserveCollinear = (4 & InitOptions) != 0;
			}

			private void InsertMaxima(long X)
			{
				Maxima maxima = new Maxima();
				maxima.X = X;
				if (m_Maxima == null)
				{
					m_Maxima = maxima;
					m_Maxima.Next = null;
					m_Maxima.Prev = null;
					return;
				}
				if (X < m_Maxima.X)
				{
					maxima.Next = m_Maxima;
					maxima.Prev = null;
					m_Maxima = maxima;
					return;
				}
				Maxima maxima2 = m_Maxima;
				while (maxima2.Next != null && X >= maxima2.Next.X)
				{
					maxima2 = maxima2.Next;
				}
				if (X != maxima2.X)
				{
					maxima.Next = maxima2.Next;
					maxima.Prev = maxima2;
					if (maxima2.Next != null)
					{
						maxima2.Next.Prev = maxima;
					}
					maxima2.Next = maxima;
				}
			}

			public bool Execute(ClipType clipType, List<List<IntPoint>> solution, PolyFillType FillType = PolyFillType.pftEvenOdd)
			{
				return Execute(clipType, solution, FillType, FillType);
			}

			public bool Execute(ClipType clipType, PolyTree polytree, PolyFillType FillType = PolyFillType.pftEvenOdd)
			{
				return Execute(clipType, polytree, FillType, FillType);
			}

			public bool Execute(ClipType clipType, List<List<IntPoint>> solution, PolyFillType subjFillType, PolyFillType clipFillType)
			{
				if (m_ExecuteLocked)
				{
					return false;
				}
				if (m_HasOpenPaths)
				{
					throw new ClipperException("Error: PolyTree struct is needed for open path clipping.");
				}
				m_ExecuteLocked = true;
				solution.Clear();
				m_SubjFillType = subjFillType;
				m_ClipFillType = clipFillType;
				m_ClipType = clipType;
				m_UsingPolyTree = false;
				bool flag;
				try
				{
					flag = ExecuteInternal();
					if (flag)
					{
						BuildResult(solution);
					}
				}
				finally
				{
					DisposeAllPolyPts();
					m_ExecuteLocked = false;
				}
				return flag;
			}

			public bool Execute(ClipType clipType, PolyTree polytree, PolyFillType subjFillType, PolyFillType clipFillType)
			{
				if (m_ExecuteLocked)
				{
					return false;
				}
				m_ExecuteLocked = true;
				m_SubjFillType = subjFillType;
				m_ClipFillType = clipFillType;
				m_ClipType = clipType;
				m_UsingPolyTree = true;
				bool flag;
				try
				{
					flag = ExecuteInternal();
					if (flag)
					{
						BuildResult2(polytree);
					}
				}
				finally
				{
					DisposeAllPolyPts();
					m_ExecuteLocked = false;
				}
				return flag;
			}

			internal void FixHoleLinkage(OutRec outRec)
			{
				if (outRec.FirstLeft != null && (outRec.IsHole == outRec.FirstLeft.IsHole || outRec.FirstLeft.Pts == null))
				{
					OutRec firstLeft = outRec.FirstLeft;
					while (firstLeft != null && (firstLeft.IsHole == outRec.IsHole || firstLeft.Pts == null))
					{
						firstLeft = firstLeft.FirstLeft;
					}
					outRec.FirstLeft = firstLeft;
				}
			}

			private bool ExecuteInternal()
			{
				try
				{
					Reset();
					m_SortedEdges = null;
					m_Maxima = null;
					if (!PopScanbeam(out var Y))
					{
						return false;
					}
					InsertLocalMinimaIntoAEL(Y);
					long Y2;
					while (PopScanbeam(out Y2) || LocalMinimaPending())
					{
						ProcessHorizontals();
						m_GhostJoins.Clear();
						if (!ProcessIntersections(Y2))
						{
							return false;
						}
						ProcessEdgesAtTopOfScanbeam(Y2);
						Y = Y2;
						InsertLocalMinimaIntoAEL(Y);
					}
					foreach (OutRec polyOut in m_PolyOuts)
					{
						if (polyOut.Pts != null && !polyOut.IsOpen && (polyOut.IsHole ^ ReverseSolution) == Area(polyOut) > 0.0)
						{
							ReversePolyPtLinks(polyOut.Pts);
						}
					}
					JoinCommonEdges();
					foreach (OutRec polyOut2 in m_PolyOuts)
					{
						if (polyOut2.Pts != null)
						{
							if (polyOut2.IsOpen)
							{
								FixupOutPolyline(polyOut2);
							}
							else
							{
								FixupOutPolygon(polyOut2);
							}
						}
					}
					if (StrictlySimple)
					{
						DoSimplePolygons();
					}
					return true;
				}
				finally
				{
					m_Joins.Clear();
					m_GhostJoins.Clear();
				}
			}

			private void DisposeAllPolyPts()
			{
				for (int i = 0; i < m_PolyOuts.Count; i++)
				{
					DisposeOutRec(i);
				}
				m_PolyOuts.Clear();
			}

			private void AddJoin(OutPt Op1, OutPt Op2, IntPoint OffPt)
			{
				Join obj = new Join();
				obj.OutPt1 = Op1;
				obj.OutPt2 = Op2;
				obj.OffPt = OffPt;
				m_Joins.Add(obj);
			}

			private void AddGhostJoin(OutPt Op, IntPoint OffPt)
			{
				Join obj = new Join();
				obj.OutPt1 = Op;
				obj.OffPt = OffPt;
				m_GhostJoins.Add(obj);
			}

			private void InsertLocalMinimaIntoAEL(long botY)
			{
				LocalMinima current;
				while (PopLocalMinima(botY, out current))
				{
					TEdge leftBound = current.LeftBound;
					TEdge rightBound = current.RightBound;
					OutPt outPt = null;
					if (leftBound == null)
					{
						InsertEdgeIntoAEL(rightBound, null);
						SetWindingCount(rightBound);
						if (IsContributing(rightBound))
						{
							outPt = AddOutPt(rightBound, rightBound.Bot);
						}
					}
					else if (rightBound == null)
					{
						InsertEdgeIntoAEL(leftBound, null);
						SetWindingCount(leftBound);
						if (IsContributing(leftBound))
						{
							outPt = AddOutPt(leftBound, leftBound.Bot);
						}
						InsertScanbeam(leftBound.Top.Y);
					}
					else
					{
						InsertEdgeIntoAEL(leftBound, null);
						InsertEdgeIntoAEL(rightBound, leftBound);
						SetWindingCount(leftBound);
						rightBound.WindCnt = leftBound.WindCnt;
						rightBound.WindCnt2 = leftBound.WindCnt2;
						if (IsContributing(leftBound))
						{
							outPt = AddLocalMinPoly(leftBound, rightBound, leftBound.Bot);
						}
						InsertScanbeam(leftBound.Top.Y);
					}
					if (rightBound != null)
					{
						if (ClipperBase.IsHorizontal(rightBound))
						{
							if (rightBound.NextInLML != null)
							{
								InsertScanbeam(rightBound.NextInLML.Top.Y);
							}
							AddEdgeToSEL(rightBound);
						}
						else
						{
							InsertScanbeam(rightBound.Top.Y);
						}
					}
					if (leftBound == null || rightBound == null)
					{
						continue;
					}
					if (outPt != null && ClipperBase.IsHorizontal(rightBound) && m_GhostJoins.Count > 0 && rightBound.WindDelta != 0)
					{
						for (int i = 0; i < m_GhostJoins.Count; i++)
						{
							Join obj = m_GhostJoins[i];
							if (HorzSegmentsOverlap(obj.OutPt1.Pt.X, obj.OffPt.X, rightBound.Bot.X, rightBound.Top.X))
							{
								AddJoin(obj.OutPt1, outPt, obj.OffPt);
							}
						}
					}
					if (leftBound.OutIdx >= 0 && leftBound.PrevInAEL != null && leftBound.PrevInAEL.Curr.X == leftBound.Bot.X && leftBound.PrevInAEL.OutIdx >= 0 && ClipperBase.SlopesEqual(leftBound.PrevInAEL.Curr, leftBound.PrevInAEL.Top, leftBound.Curr, leftBound.Top, m_UseFullRange) && leftBound.WindDelta != 0 && leftBound.PrevInAEL.WindDelta != 0)
					{
						OutPt op = AddOutPt(leftBound.PrevInAEL, leftBound.Bot);
						AddJoin(outPt, op, leftBound.Top);
					}
					if (leftBound.NextInAEL == rightBound)
					{
						continue;
					}
					if (rightBound.OutIdx >= 0 && rightBound.PrevInAEL.OutIdx >= 0 && ClipperBase.SlopesEqual(rightBound.PrevInAEL.Curr, rightBound.PrevInAEL.Top, rightBound.Curr, rightBound.Top, m_UseFullRange) && rightBound.WindDelta != 0 && rightBound.PrevInAEL.WindDelta != 0)
					{
						OutPt op2 = AddOutPt(rightBound.PrevInAEL, rightBound.Bot);
						AddJoin(outPt, op2, rightBound.Top);
					}
					TEdge nextInAEL = leftBound.NextInAEL;
					if (nextInAEL != null)
					{
						while (nextInAEL != rightBound)
						{
							IntersectEdges(rightBound, nextInAEL, leftBound.Curr);
							nextInAEL = nextInAEL.NextInAEL;
						}
					}
				}
			}

			private void InsertEdgeIntoAEL(TEdge edge, TEdge startEdge)
			{
				if (m_ActiveEdges == null)
				{
					edge.PrevInAEL = null;
					edge.NextInAEL = null;
					m_ActiveEdges = edge;
					return;
				}
				if (startEdge == null && E2InsertsBeforeE1(m_ActiveEdges, edge))
				{
					edge.PrevInAEL = null;
					edge.NextInAEL = m_ActiveEdges;
					m_ActiveEdges.PrevInAEL = edge;
					m_ActiveEdges = edge;
					return;
				}
				if (startEdge == null)
				{
					startEdge = m_ActiveEdges;
				}
				while (startEdge.NextInAEL != null && !E2InsertsBeforeE1(startEdge.NextInAEL, edge))
				{
					startEdge = startEdge.NextInAEL;
				}
				edge.NextInAEL = startEdge.NextInAEL;
				if (startEdge.NextInAEL != null)
				{
					startEdge.NextInAEL.PrevInAEL = edge;
				}
				edge.PrevInAEL = startEdge;
				startEdge.NextInAEL = edge;
			}

			private bool E2InsertsBeforeE1(TEdge e1, TEdge e2)
			{
				if (e2.Curr.X == e1.Curr.X)
				{
					if (e2.Top.Y > e1.Top.Y)
					{
						return e2.Top.X < TopX(e1, e2.Top.Y);
					}
					return e1.Top.X > TopX(e2, e1.Top.Y);
				}
				return e2.Curr.X < e1.Curr.X;
			}

			private bool IsEvenOddFillType(TEdge edge)
			{
				if (edge.PolyTyp == PolyType.ptSubject)
				{
					return m_SubjFillType == PolyFillType.pftEvenOdd;
				}
				return m_ClipFillType == PolyFillType.pftEvenOdd;
			}

			private bool IsEvenOddAltFillType(TEdge edge)
			{
				if (edge.PolyTyp == PolyType.ptSubject)
				{
					return m_ClipFillType == PolyFillType.pftEvenOdd;
				}
				return m_SubjFillType == PolyFillType.pftEvenOdd;
			}

			private bool IsContributing(TEdge edge)
			{
				PolyFillType polyFillType;
				PolyFillType polyFillType2;
				if (edge.PolyTyp == PolyType.ptSubject)
				{
					polyFillType = m_SubjFillType;
					polyFillType2 = m_ClipFillType;
				}
				else
				{
					polyFillType = m_ClipFillType;
					polyFillType2 = m_SubjFillType;
				}
				switch (polyFillType)
				{
				case PolyFillType.pftEvenOdd:
					if (edge.WindDelta == 0 && edge.WindCnt != 1)
					{
						return false;
					}
					break;
				case PolyFillType.pftNonZero:
					if (Math.Abs(edge.WindCnt) != 1)
					{
						return false;
					}
					break;
				case PolyFillType.pftPositive:
					if (edge.WindCnt != 1)
					{
						return false;
					}
					break;
				default:
					if (edge.WindCnt != -1)
					{
						return false;
					}
					break;
				}
				switch (m_ClipType)
				{
				case ClipType.ctIntersection:
					switch (polyFillType2)
					{
					case PolyFillType.pftEvenOdd:
					case PolyFillType.pftNonZero:
						return edge.WindCnt2 != 0;
					case PolyFillType.pftPositive:
						return edge.WindCnt2 > 0;
					default:
						return edge.WindCnt2 < 0;
					}
				case ClipType.ctUnion:
					switch (polyFillType2)
					{
					case PolyFillType.pftEvenOdd:
					case PolyFillType.pftNonZero:
						return edge.WindCnt2 == 0;
					case PolyFillType.pftPositive:
						return edge.WindCnt2 <= 0;
					default:
						return edge.WindCnt2 >= 0;
					}
				case ClipType.ctDifference:
					if (edge.PolyTyp == PolyType.ptSubject)
					{
						switch (polyFillType2)
						{
						case PolyFillType.pftEvenOdd:
						case PolyFillType.pftNonZero:
							return edge.WindCnt2 == 0;
						case PolyFillType.pftPositive:
							return edge.WindCnt2 <= 0;
						default:
							return edge.WindCnt2 >= 0;
						}
					}
					switch (polyFillType2)
					{
					case PolyFillType.pftEvenOdd:
					case PolyFillType.pftNonZero:
						return edge.WindCnt2 != 0;
					case PolyFillType.pftPositive:
						return edge.WindCnt2 > 0;
					default:
						return edge.WindCnt2 < 0;
					}
				case ClipType.ctXor:
					if (edge.WindDelta == 0)
					{
						switch (polyFillType2)
						{
						case PolyFillType.pftEvenOdd:
						case PolyFillType.pftNonZero:
							return edge.WindCnt2 == 0;
						case PolyFillType.pftPositive:
							return edge.WindCnt2 <= 0;
						default:
							return edge.WindCnt2 >= 0;
						}
					}
					return true;
				default:
					return true;
				}
			}

			private void SetWindingCount(TEdge edge)
			{
				TEdge prevInAEL = edge.PrevInAEL;
				while (prevInAEL != null && (prevInAEL.PolyTyp != edge.PolyTyp || prevInAEL.WindDelta == 0))
				{
					prevInAEL = prevInAEL.PrevInAEL;
				}
				if (prevInAEL == null)
				{
					PolyFillType polyFillType = ((edge.PolyTyp == PolyType.ptSubject) ? m_SubjFillType : m_ClipFillType);
					if (edge.WindDelta == 0)
					{
						edge.WindCnt = ((polyFillType != PolyFillType.pftNegative) ? 1 : (-1));
					}
					else
					{
						edge.WindCnt = edge.WindDelta;
					}
					edge.WindCnt2 = 0;
					prevInAEL = m_ActiveEdges;
				}
				else if (edge.WindDelta == 0 && m_ClipType != ClipType.ctUnion)
				{
					edge.WindCnt = 1;
					edge.WindCnt2 = prevInAEL.WindCnt2;
					prevInAEL = prevInAEL.NextInAEL;
				}
				else if (IsEvenOddFillType(edge))
				{
					if (edge.WindDelta == 0)
					{
						bool flag = true;
						for (TEdge prevInAEL2 = prevInAEL.PrevInAEL; prevInAEL2 != null; prevInAEL2 = prevInAEL2.PrevInAEL)
						{
							if (prevInAEL2.PolyTyp == prevInAEL.PolyTyp && prevInAEL2.WindDelta != 0)
							{
								flag = !flag;
							}
						}
						edge.WindCnt = ((!flag) ? 1 : 0);
					}
					else
					{
						edge.WindCnt = edge.WindDelta;
					}
					edge.WindCnt2 = prevInAEL.WindCnt2;
					prevInAEL = prevInAEL.NextInAEL;
				}
				else
				{
					if (prevInAEL.WindCnt * prevInAEL.WindDelta < 0)
					{
						if (Math.Abs(prevInAEL.WindCnt) > 1)
						{
							if (prevInAEL.WindDelta * edge.WindDelta < 0)
							{
								edge.WindCnt = prevInAEL.WindCnt;
							}
							else
							{
								edge.WindCnt = prevInAEL.WindCnt + edge.WindDelta;
							}
						}
						else
						{
							edge.WindCnt = ((edge.WindDelta == 0) ? 1 : edge.WindDelta);
						}
					}
					else if (edge.WindDelta == 0)
					{
						edge.WindCnt = ((prevInAEL.WindCnt < 0) ? (prevInAEL.WindCnt - 1) : (prevInAEL.WindCnt + 1));
					}
					else if (prevInAEL.WindDelta * edge.WindDelta < 0)
					{
						edge.WindCnt = prevInAEL.WindCnt;
					}
					else
					{
						edge.WindCnt = prevInAEL.WindCnt + edge.WindDelta;
					}
					edge.WindCnt2 = prevInAEL.WindCnt2;
					prevInAEL = prevInAEL.NextInAEL;
				}
				if (IsEvenOddAltFillType(edge))
				{
					while (prevInAEL != edge)
					{
						if (prevInAEL.WindDelta != 0)
						{
							edge.WindCnt2 = ((edge.WindCnt2 == 0) ? 1 : 0);
						}
						prevInAEL = prevInAEL.NextInAEL;
					}
				}
				else
				{
					while (prevInAEL != edge)
					{
						edge.WindCnt2 += prevInAEL.WindDelta;
						prevInAEL = prevInAEL.NextInAEL;
					}
				}
			}

			private void AddEdgeToSEL(TEdge edge)
			{
				if (m_SortedEdges == null)
				{
					m_SortedEdges = edge;
					edge.PrevInSEL = null;
					edge.NextInSEL = null;
				}
				else
				{
					edge.NextInSEL = m_SortedEdges;
					edge.PrevInSEL = null;
					m_SortedEdges.PrevInSEL = edge;
					m_SortedEdges = edge;
				}
			}

			internal bool PopEdgeFromSEL(out TEdge e)
			{
				e = m_SortedEdges;
				if (e == null)
				{
					return false;
				}
				TEdge obj = e;
				m_SortedEdges = e.NextInSEL;
				if (m_SortedEdges != null)
				{
					m_SortedEdges.PrevInSEL = null;
				}
				obj.NextInSEL = null;
				obj.PrevInSEL = null;
				return true;
			}

			private void CopyAELToSEL()
			{
				for (TEdge tEdge = (m_SortedEdges = m_ActiveEdges); tEdge != null; tEdge = tEdge.NextInAEL)
				{
					tEdge.PrevInSEL = tEdge.PrevInAEL;
					tEdge.NextInSEL = tEdge.NextInAEL;
				}
			}

			private void SwapPositionsInSEL(TEdge edge1, TEdge edge2)
			{
				if ((edge1.NextInSEL == null && edge1.PrevInSEL == null) || (edge2.NextInSEL == null && edge2.PrevInSEL == null))
				{
					return;
				}
				if (edge1.NextInSEL == edge2)
				{
					TEdge nextInSEL = edge2.NextInSEL;
					if (nextInSEL != null)
					{
						nextInSEL.PrevInSEL = edge1;
					}
					TEdge prevInSEL = edge1.PrevInSEL;
					if (prevInSEL != null)
					{
						prevInSEL.NextInSEL = edge2;
					}
					edge2.PrevInSEL = prevInSEL;
					edge2.NextInSEL = edge1;
					edge1.PrevInSEL = edge2;
					edge1.NextInSEL = nextInSEL;
				}
				else if (edge2.NextInSEL == edge1)
				{
					TEdge nextInSEL2 = edge1.NextInSEL;
					if (nextInSEL2 != null)
					{
						nextInSEL2.PrevInSEL = edge2;
					}
					TEdge prevInSEL2 = edge2.PrevInSEL;
					if (prevInSEL2 != null)
					{
						prevInSEL2.NextInSEL = edge1;
					}
					edge1.PrevInSEL = prevInSEL2;
					edge1.NextInSEL = edge2;
					edge2.PrevInSEL = edge1;
					edge2.NextInSEL = nextInSEL2;
				}
				else
				{
					TEdge nextInSEL3 = edge1.NextInSEL;
					TEdge prevInSEL3 = edge1.PrevInSEL;
					edge1.NextInSEL = edge2.NextInSEL;
					if (edge1.NextInSEL != null)
					{
						edge1.NextInSEL.PrevInSEL = edge1;
					}
					edge1.PrevInSEL = edge2.PrevInSEL;
					if (edge1.PrevInSEL != null)
					{
						edge1.PrevInSEL.NextInSEL = edge1;
					}
					edge2.NextInSEL = nextInSEL3;
					if (edge2.NextInSEL != null)
					{
						edge2.NextInSEL.PrevInSEL = edge2;
					}
					edge2.PrevInSEL = prevInSEL3;
					if (edge2.PrevInSEL != null)
					{
						edge2.PrevInSEL.NextInSEL = edge2;
					}
				}
				if (edge1.PrevInSEL == null)
				{
					m_SortedEdges = edge1;
				}
				else if (edge2.PrevInSEL == null)
				{
					m_SortedEdges = edge2;
				}
			}

			private void AddLocalMaxPoly(TEdge e1, TEdge e2, IntPoint pt)
			{
				AddOutPt(e1, pt);
				if (e2.WindDelta == 0)
				{
					AddOutPt(e2, pt);
				}
				if (e1.OutIdx == e2.OutIdx)
				{
					e1.OutIdx = -1;
					e2.OutIdx = -1;
				}
				else if (e1.OutIdx < e2.OutIdx)
				{
					AppendPolygon(e1, e2);
				}
				else
				{
					AppendPolygon(e2, e1);
				}
			}

			private OutPt AddLocalMinPoly(TEdge e1, TEdge e2, IntPoint pt)
			{
				OutPt outPt;
				TEdge tEdge;
				TEdge tEdge2;
				if (ClipperBase.IsHorizontal(e2) || e1.Dx > e2.Dx)
				{
					outPt = AddOutPt(e1, pt);
					e2.OutIdx = e1.OutIdx;
					e1.Side = EdgeSide.esLeft;
					e2.Side = EdgeSide.esRight;
					tEdge = e1;
					tEdge2 = ((tEdge.PrevInAEL != e2) ? tEdge.PrevInAEL : e2.PrevInAEL);
				}
				else
				{
					outPt = AddOutPt(e2, pt);
					e1.OutIdx = e2.OutIdx;
					e1.Side = EdgeSide.esRight;
					e2.Side = EdgeSide.esLeft;
					tEdge = e2;
					tEdge2 = ((tEdge.PrevInAEL != e1) ? tEdge.PrevInAEL : e1.PrevInAEL);
				}
				if (tEdge2 != null && tEdge2.OutIdx >= 0 && tEdge2.Top.Y < pt.Y && tEdge.Top.Y < pt.Y)
				{
					long num = TopX(tEdge2, pt.Y);
					long num2 = TopX(tEdge, pt.Y);
					if (num == num2 && tEdge.WindDelta != 0 && tEdge2.WindDelta != 0 && ClipperBase.SlopesEqual(new IntPoint(num, pt.Y), tEdge2.Top, new IntPoint(num2, pt.Y), tEdge.Top, m_UseFullRange))
					{
						OutPt op = AddOutPt(tEdge2, pt);
						AddJoin(outPt, op, tEdge.Top);
					}
				}
				return outPt;
			}

			private OutPt AddOutPt(TEdge e, IntPoint pt)
			{
				if (e.OutIdx < 0)
				{
					OutRec outRec = CreateOutRec();
					outRec.IsOpen = e.WindDelta == 0;
					OutPt outPt = (outRec.Pts = new OutPt());
					outPt.Idx = outRec.Idx;
					outPt.Pt = pt;
					outPt.Next = outPt;
					outPt.Prev = outPt;
					if (!outRec.IsOpen)
					{
						SetHoleState(e, outRec);
					}
					e.OutIdx = outRec.Idx;
					return outPt;
				}
				OutRec outRec2 = m_PolyOuts[e.OutIdx];
				OutPt pts = outRec2.Pts;
				bool flag = e.Side == EdgeSide.esLeft;
				if (flag && pt == pts.Pt)
				{
					return pts;
				}
				if (!flag && pt == pts.Prev.Pt)
				{
					return pts.Prev;
				}
				OutPt outPt2 = new OutPt();
				outPt2.Idx = outRec2.Idx;
				outPt2.Pt = pt;
				outPt2.Next = pts;
				outPt2.Prev = pts.Prev;
				outPt2.Prev.Next = outPt2;
				pts.Prev = outPt2;
				if (flag)
				{
					outRec2.Pts = outPt2;
				}
				return outPt2;
			}

			private OutPt GetLastOutPt(TEdge e)
			{
				OutRec outRec = m_PolyOuts[e.OutIdx];
				if (e.Side == EdgeSide.esLeft)
				{
					return outRec.Pts;
				}
				return outRec.Pts.Prev;
			}

			internal void SwapPoints(ref IntPoint pt1, ref IntPoint pt2)
			{
				IntPoint intPoint = new IntPoint(pt1);
				pt1 = pt2;
				pt2 = intPoint;
			}

			private bool HorzSegmentsOverlap(long seg1a, long seg1b, long seg2a, long seg2b)
			{
				if (seg1a > seg1b)
				{
					Swap(ref seg1a, ref seg1b);
				}
				if (seg2a > seg2b)
				{
					Swap(ref seg2a, ref seg2b);
				}
				if (seg1a < seg2b)
				{
					return seg2a < seg1b;
				}
				return false;
			}

			private void SetHoleState(TEdge e, OutRec outRec)
			{
				TEdge prevInAEL = e.PrevInAEL;
				TEdge tEdge = null;
				while (prevInAEL != null)
				{
					if (prevInAEL.OutIdx >= 0 && prevInAEL.WindDelta != 0)
					{
						if (tEdge == null)
						{
							tEdge = prevInAEL;
						}
						else if (tEdge.OutIdx == prevInAEL.OutIdx)
						{
							tEdge = null;
						}
					}
					prevInAEL = prevInAEL.PrevInAEL;
				}
				if (tEdge == null)
				{
					outRec.FirstLeft = null;
					outRec.IsHole = false;
				}
				else
				{
					outRec.FirstLeft = m_PolyOuts[tEdge.OutIdx];
					outRec.IsHole = !outRec.FirstLeft.IsHole;
				}
			}

			private double GetDx(IntPoint pt1, IntPoint pt2)
			{
				if (pt1.Y == pt2.Y)
				{
					return -3.4E+38;
				}
				return (double)(pt2.X - pt1.X) / (double)(pt2.Y - pt1.Y);
			}

			private bool FirstIsBottomPt(OutPt btmPt1, OutPt btmPt2)
			{
				OutPt prev = btmPt1.Prev;
				while (prev.Pt == btmPt1.Pt && prev != btmPt1)
				{
					prev = prev.Prev;
				}
				double num = Math.Abs(GetDx(btmPt1.Pt, prev.Pt));
				prev = btmPt1.Next;
				while (prev.Pt == btmPt1.Pt && prev != btmPt1)
				{
					prev = prev.Next;
				}
				double num2 = Math.Abs(GetDx(btmPt1.Pt, prev.Pt));
				prev = btmPt2.Prev;
				while (prev.Pt == btmPt2.Pt && prev != btmPt2)
				{
					prev = prev.Prev;
				}
				double num3 = Math.Abs(GetDx(btmPt2.Pt, prev.Pt));
				prev = btmPt2.Next;
				while (prev.Pt == btmPt2.Pt && prev != btmPt2)
				{
					prev = prev.Next;
				}
				double num4 = Math.Abs(GetDx(btmPt2.Pt, prev.Pt));
				if (Math.Max(num, num2) == Math.Max(num3, num4) && Math.Min(num, num2) == Math.Min(num3, num4))
				{
					return Area(btmPt1) > 0.0;
				}
				if (!(num >= num3) || !(num >= num4))
				{
					if (num2 >= num3)
					{
						return num2 >= num4;
					}
					return false;
				}
				return true;
			}

			private OutPt GetBottomPt(OutPt pp)
			{
				OutPt outPt = null;
				OutPt next;
				for (next = pp.Next; next != pp; next = next.Next)
				{
					if (next.Pt.Y > pp.Pt.Y)
					{
						pp = next;
						outPt = null;
					}
					else if (next.Pt.Y == pp.Pt.Y && next.Pt.X <= pp.Pt.X)
					{
						if (next.Pt.X < pp.Pt.X)
						{
							outPt = null;
							pp = next;
						}
						else if (next.Next != pp && next.Prev != pp)
						{
							outPt = next;
						}
					}
				}
				if (outPt != null)
				{
					while (outPt != next)
					{
						if (!FirstIsBottomPt(next, outPt))
						{
							pp = outPt;
						}
						outPt = outPt.Next;
						while (outPt.Pt != pp.Pt)
						{
							outPt = outPt.Next;
						}
					}
				}
				return pp;
			}

			private OutRec GetLowermostRec(OutRec outRec1, OutRec outRec2)
			{
				if (outRec1.BottomPt == null)
				{
					outRec1.BottomPt = GetBottomPt(outRec1.Pts);
				}
				if (outRec2.BottomPt == null)
				{
					outRec2.BottomPt = GetBottomPt(outRec2.Pts);
				}
				OutPt bottomPt = outRec1.BottomPt;
				OutPt bottomPt2 = outRec2.BottomPt;
				if (bottomPt.Pt.Y > bottomPt2.Pt.Y)
				{
					return outRec1;
				}
				if (bottomPt.Pt.Y < bottomPt2.Pt.Y)
				{
					return outRec2;
				}
				if (bottomPt.Pt.X < bottomPt2.Pt.X)
				{
					return outRec1;
				}
				if (bottomPt.Pt.X > bottomPt2.Pt.X)
				{
					return outRec2;
				}
				if (bottomPt.Next == bottomPt)
				{
					return outRec2;
				}
				if (bottomPt2.Next == bottomPt2)
				{
					return outRec1;
				}
				if (FirstIsBottomPt(bottomPt, bottomPt2))
				{
					return outRec1;
				}
				return outRec2;
			}

			private bool OutRec1RightOfOutRec2(OutRec outRec1, OutRec outRec2)
			{
				do
				{
					outRec1 = outRec1.FirstLeft;
					if (outRec1 == outRec2)
					{
						return true;
					}
				}
				while (outRec1 != null);
				return false;
			}

			private OutRec GetOutRec(int idx)
			{
				OutRec outRec;
				for (outRec = m_PolyOuts[idx]; outRec != m_PolyOuts[outRec.Idx]; outRec = m_PolyOuts[outRec.Idx])
				{
				}
				return outRec;
			}

			private void AppendPolygon(TEdge e1, TEdge e2)
			{
				OutRec outRec = m_PolyOuts[e1.OutIdx];
				OutRec outRec2 = m_PolyOuts[e2.OutIdx];
				OutRec outRec3 = (OutRec1RightOfOutRec2(outRec, outRec2) ? outRec2 : ((!OutRec1RightOfOutRec2(outRec2, outRec)) ? GetLowermostRec(outRec, outRec2) : outRec));
				OutPt pts = outRec.Pts;
				OutPt prev = pts.Prev;
				OutPt pts2 = outRec2.Pts;
				OutPt prev2 = pts2.Prev;
				if (e1.Side == EdgeSide.esLeft)
				{
					if (e2.Side == EdgeSide.esLeft)
					{
						ReversePolyPtLinks(pts2);
						pts2.Next = pts;
						pts.Prev = pts2;
						prev.Next = prev2;
						prev2.Prev = prev;
						outRec.Pts = prev2;
					}
					else
					{
						prev2.Next = pts;
						pts.Prev = prev2;
						pts2.Prev = prev;
						prev.Next = pts2;
						outRec.Pts = pts2;
					}
				}
				else if (e2.Side == EdgeSide.esRight)
				{
					ReversePolyPtLinks(pts2);
					prev.Next = prev2;
					prev2.Prev = prev;
					pts2.Next = pts;
					pts.Prev = pts2;
				}
				else
				{
					prev.Next = pts2;
					pts2.Prev = prev;
					pts.Prev = prev2;
					prev2.Next = pts;
				}
				outRec.BottomPt = null;
				if (outRec3 == outRec2)
				{
					if (outRec2.FirstLeft != outRec)
					{
						outRec.FirstLeft = outRec2.FirstLeft;
					}
					outRec.IsHole = outRec2.IsHole;
				}
				outRec2.Pts = null;
				outRec2.BottomPt = null;
				outRec2.FirstLeft = outRec;
				int outIdx = e1.OutIdx;
				int outIdx2 = e2.OutIdx;
				e1.OutIdx = -1;
				e2.OutIdx = -1;
				for (TEdge tEdge = m_ActiveEdges; tEdge != null; tEdge = tEdge.NextInAEL)
				{
					if (tEdge.OutIdx == outIdx2)
					{
						tEdge.OutIdx = outIdx;
						tEdge.Side = e1.Side;
						break;
					}
				}
				outRec2.Idx = outRec.Idx;
			}

			private void ReversePolyPtLinks(OutPt pp)
			{
				if (pp != null)
				{
					OutPt outPt = pp;
					do
					{
						OutPt next = outPt.Next;
						outPt.Next = outPt.Prev;
						outPt.Prev = next;
						outPt = next;
					}
					while (outPt != pp);
				}
			}

			private static void SwapSides(TEdge edge1, TEdge edge2)
			{
				EdgeSide side = edge1.Side;
				edge1.Side = edge2.Side;
				edge2.Side = side;
			}

			private static void SwapPolyIndexes(TEdge edge1, TEdge edge2)
			{
				int outIdx = edge1.OutIdx;
				edge1.OutIdx = edge2.OutIdx;
				edge2.OutIdx = outIdx;
			}

			private void IntersectEdges(TEdge e1, TEdge e2, IntPoint pt)
			{
				bool flag = e1.OutIdx >= 0;
				bool flag2 = e2.OutIdx >= 0;
				if (e1.WindDelta == 0 || e2.WindDelta == 0)
				{
					if (e1.WindDelta == 0 && e2.WindDelta == 0)
					{
						return;
					}
					if (e1.PolyTyp == e2.PolyTyp && e1.WindDelta != e2.WindDelta && m_ClipType == ClipType.ctUnion)
					{
						if (e1.WindDelta == 0)
						{
							if (flag2)
							{
								AddOutPt(e1, pt);
								if (flag)
								{
									e1.OutIdx = -1;
								}
							}
						}
						else if (flag)
						{
							AddOutPt(e2, pt);
							if (flag2)
							{
								e2.OutIdx = -1;
							}
						}
					}
					else
					{
						if (e1.PolyTyp == e2.PolyTyp)
						{
							return;
						}
						if (e1.WindDelta == 0 && Math.Abs(e2.WindCnt) == 1 && (m_ClipType != ClipType.ctUnion || e2.WindCnt2 == 0))
						{
							AddOutPt(e1, pt);
							if (flag)
							{
								e1.OutIdx = -1;
							}
						}
						else if (e2.WindDelta == 0 && Math.Abs(e1.WindCnt) == 1 && (m_ClipType != ClipType.ctUnion || e1.WindCnt2 == 0))
						{
							AddOutPt(e2, pt);
							if (flag2)
							{
								e2.OutIdx = -1;
							}
						}
					}
					return;
				}
				if (e1.PolyTyp == e2.PolyTyp)
				{
					if (IsEvenOddFillType(e1))
					{
						int windCnt = e1.WindCnt;
						e1.WindCnt = e2.WindCnt;
						e2.WindCnt = windCnt;
					}
					else
					{
						if (e1.WindCnt + e2.WindDelta == 0)
						{
							e1.WindCnt = -e1.WindCnt;
						}
						else
						{
							e1.WindCnt += e2.WindDelta;
						}
						if (e2.WindCnt - e1.WindDelta == 0)
						{
							e2.WindCnt = -e2.WindCnt;
						}
						else
						{
							e2.WindCnt -= e1.WindDelta;
						}
					}
				}
				else
				{
					if (!IsEvenOddFillType(e2))
					{
						e1.WindCnt2 += e2.WindDelta;
					}
					else
					{
						e1.WindCnt2 = ((e1.WindCnt2 == 0) ? 1 : 0);
					}
					if (!IsEvenOddFillType(e1))
					{
						e2.WindCnt2 -= e1.WindDelta;
					}
					else
					{
						e2.WindCnt2 = ((e2.WindCnt2 == 0) ? 1 : 0);
					}
				}
				PolyFillType polyFillType;
				PolyFillType polyFillType2;
				if (e1.PolyTyp == PolyType.ptSubject)
				{
					polyFillType = m_SubjFillType;
					polyFillType2 = m_ClipFillType;
				}
				else
				{
					polyFillType = m_ClipFillType;
					polyFillType2 = m_SubjFillType;
				}
				PolyFillType polyFillType3;
				PolyFillType polyFillType4;
				if (e2.PolyTyp == PolyType.ptSubject)
				{
					polyFillType3 = m_SubjFillType;
					polyFillType4 = m_ClipFillType;
				}
				else
				{
					polyFillType3 = m_ClipFillType;
					polyFillType4 = m_SubjFillType;
				}
				int num = polyFillType switch
				{
					PolyFillType.pftPositive => e1.WindCnt, 
					PolyFillType.pftNegative => -e1.WindCnt, 
					_ => Math.Abs(e1.WindCnt), 
				};
				int num2 = polyFillType3 switch
				{
					PolyFillType.pftPositive => e2.WindCnt, 
					PolyFillType.pftNegative => -e2.WindCnt, 
					_ => Math.Abs(e2.WindCnt), 
				};
				if (flag && flag2)
				{
					if ((num != 0 && num != 1) || (num2 != 0 && num2 != 1) || (e1.PolyTyp != e2.PolyTyp && m_ClipType != ClipType.ctXor))
					{
						AddLocalMaxPoly(e1, e2, pt);
						return;
					}
					AddOutPt(e1, pt);
					AddOutPt(e2, pt);
					SwapSides(e1, e2);
					SwapPolyIndexes(e1, e2);
				}
				else if (flag)
				{
					if (num2 == 0 || num2 == 1)
					{
						AddOutPt(e1, pt);
						SwapSides(e1, e2);
						SwapPolyIndexes(e1, e2);
					}
				}
				else if (flag2)
				{
					if (num == 0 || num == 1)
					{
						AddOutPt(e2, pt);
						SwapSides(e1, e2);
						SwapPolyIndexes(e1, e2);
					}
				}
				else
				{
					if ((num != 0 && num != 1) || (num2 != 0 && num2 != 1))
					{
						return;
					}
					long num3 = polyFillType2 switch
					{
						PolyFillType.pftPositive => e1.WindCnt2, 
						PolyFillType.pftNegative => -e1.WindCnt2, 
						_ => Math.Abs(e1.WindCnt2), 
					};
					long num4 = polyFillType4 switch
					{
						PolyFillType.pftPositive => e2.WindCnt2, 
						PolyFillType.pftNegative => -e2.WindCnt2, 
						_ => Math.Abs(e2.WindCnt2), 
					};
					if (e1.PolyTyp != e2.PolyTyp)
					{
						AddLocalMinPoly(e1, e2, pt);
					}
					else if (num == 1 && num2 == 1)
					{
						switch (m_ClipType)
						{
						case ClipType.ctIntersection:
							if (num3 > 0 && num4 > 0)
							{
								AddLocalMinPoly(e1, e2, pt);
							}
							break;
						case ClipType.ctUnion:
							if (num3 <= 0 && num4 <= 0)
							{
								AddLocalMinPoly(e1, e2, pt);
							}
							break;
						case ClipType.ctDifference:
							if ((e1.PolyTyp == PolyType.ptClip && num3 > 0 && num4 > 0) || (e1.PolyTyp == PolyType.ptSubject && num3 <= 0 && num4 <= 0))
							{
								AddLocalMinPoly(e1, e2, pt);
							}
							break;
						case ClipType.ctXor:
							AddLocalMinPoly(e1, e2, pt);
							break;
						}
					}
					else
					{
						SwapSides(e1, e2);
					}
				}
			}

			private void DeleteFromSEL(TEdge e)
			{
				TEdge prevInSEL = e.PrevInSEL;
				TEdge nextInSEL = e.NextInSEL;
				if (prevInSEL != null || nextInSEL != null || e == m_SortedEdges)
				{
					if (prevInSEL != null)
					{
						prevInSEL.NextInSEL = nextInSEL;
					}
					else
					{
						m_SortedEdges = nextInSEL;
					}
					if (nextInSEL != null)
					{
						nextInSEL.PrevInSEL = prevInSEL;
					}
					e.NextInSEL = null;
					e.PrevInSEL = null;
				}
			}

			private void ProcessHorizontals()
			{
				TEdge e;
				while (PopEdgeFromSEL(out e))
				{
					ProcessHorizontal(e);
				}
			}

			private void GetHorzDirection(TEdge HorzEdge, out Direction Dir, out long Left, out long Right)
			{
				if (HorzEdge.Bot.X < HorzEdge.Top.X)
				{
					Left = HorzEdge.Bot.X;
					Right = HorzEdge.Top.X;
					Dir = Direction.dLeftToRight;
				}
				else
				{
					Left = HorzEdge.Top.X;
					Right = HorzEdge.Bot.X;
					Dir = Direction.dRightToLeft;
				}
			}

			private void ProcessHorizontal(TEdge horzEdge)
			{
				bool flag = horzEdge.WindDelta == 0;
				GetHorzDirection(horzEdge, out var Dir, out var Left, out var Right);
				TEdge tEdge = horzEdge;
				TEdge tEdge2 = null;
				while (tEdge.NextInLML != null && ClipperBase.IsHorizontal(tEdge.NextInLML))
				{
					tEdge = tEdge.NextInLML;
				}
				if (tEdge.NextInLML == null)
				{
					tEdge2 = GetMaximaPair(tEdge);
				}
				Maxima maxima = m_Maxima;
				if (maxima != null)
				{
					if (Dir == Direction.dLeftToRight)
					{
						while (maxima != null && maxima.X <= horzEdge.Bot.X)
						{
							maxima = maxima.Next;
						}
						if (maxima != null && maxima.X >= tEdge.Top.X)
						{
							maxima = null;
						}
					}
					else
					{
						while (maxima.Next != null && maxima.Next.X < horzEdge.Bot.X)
						{
							maxima = maxima.Next;
						}
						if (maxima.X <= tEdge.Top.X)
						{
							maxima = null;
						}
					}
				}
				OutPt outPt = null;
				while (true)
				{
					bool flag2 = horzEdge == tEdge;
					TEdge tEdge3 = GetNextInAEL(horzEdge, Dir);
					while (tEdge3 != null)
					{
						if (maxima != null)
						{
							if (Dir == Direction.dLeftToRight)
							{
								while (maxima != null && maxima.X < tEdge3.Curr.X)
								{
									if (horzEdge.OutIdx >= 0 && !flag)
									{
										AddOutPt(horzEdge, new IntPoint(maxima.X, horzEdge.Bot.Y));
									}
									maxima = maxima.Next;
								}
							}
							else
							{
								while (maxima != null && maxima.X > tEdge3.Curr.X)
								{
									if (horzEdge.OutIdx >= 0 && !flag)
									{
										AddOutPt(horzEdge, new IntPoint(maxima.X, horzEdge.Bot.Y));
									}
									maxima = maxima.Prev;
								}
							}
						}
						if ((Dir == Direction.dLeftToRight && tEdge3.Curr.X > Right) || (Dir == Direction.dRightToLeft && tEdge3.Curr.X < Left) || (tEdge3.Curr.X == horzEdge.Top.X && horzEdge.NextInLML != null && tEdge3.Dx < horzEdge.NextInLML.Dx))
						{
							break;
						}
						if (horzEdge.OutIdx >= 0 && !flag)
						{
							outPt = AddOutPt(horzEdge, tEdge3.Curr);
							for (TEdge tEdge4 = m_SortedEdges; tEdge4 != null; tEdge4 = tEdge4.NextInSEL)
							{
								if (tEdge4.OutIdx >= 0 && HorzSegmentsOverlap(horzEdge.Bot.X, horzEdge.Top.X, tEdge4.Bot.X, tEdge4.Top.X))
								{
									OutPt lastOutPt = GetLastOutPt(tEdge4);
									AddJoin(lastOutPt, outPt, tEdge4.Top);
								}
							}
							AddGhostJoin(outPt, horzEdge.Bot);
						}
						if (tEdge3 == tEdge2 && flag2)
						{
							if (horzEdge.OutIdx >= 0)
							{
								AddLocalMaxPoly(horzEdge, tEdge2, horzEdge.Top);
							}
							DeleteFromAEL(horzEdge);
							DeleteFromAEL(tEdge2);
							return;
						}
						if (Dir == Direction.dLeftToRight)
						{
							IntersectEdges(pt: new IntPoint(tEdge3.Curr.X, horzEdge.Curr.Y), e1: horzEdge, e2: tEdge3);
						}
						else
						{
							IntersectEdges(pt: new IntPoint(tEdge3.Curr.X, horzEdge.Curr.Y), e1: tEdge3, e2: horzEdge);
						}
						TEdge nextInAEL = GetNextInAEL(tEdge3, Dir);
						SwapPositionsInAEL(horzEdge, tEdge3);
						tEdge3 = nextInAEL;
					}
					if (horzEdge.NextInLML == null || !ClipperBase.IsHorizontal(horzEdge.NextInLML))
					{
						break;
					}
					UpdateEdgeIntoAEL(ref horzEdge);
					if (horzEdge.OutIdx >= 0)
					{
						AddOutPt(horzEdge, horzEdge.Bot);
					}
					GetHorzDirection(horzEdge, out Dir, out Left, out Right);
				}
				if (horzEdge.OutIdx >= 0 && outPt == null)
				{
					outPt = GetLastOutPt(horzEdge);
					for (TEdge tEdge5 = m_SortedEdges; tEdge5 != null; tEdge5 = tEdge5.NextInSEL)
					{
						if (tEdge5.OutIdx >= 0 && HorzSegmentsOverlap(horzEdge.Bot.X, horzEdge.Top.X, tEdge5.Bot.X, tEdge5.Top.X))
						{
							OutPt lastOutPt2 = GetLastOutPt(tEdge5);
							AddJoin(lastOutPt2, outPt, tEdge5.Top);
						}
					}
					AddGhostJoin(outPt, horzEdge.Top);
				}
				if (horzEdge.NextInLML != null)
				{
					if (horzEdge.OutIdx >= 0)
					{
						outPt = AddOutPt(horzEdge, horzEdge.Top);
						UpdateEdgeIntoAEL(ref horzEdge);
						if (horzEdge.WindDelta != 0)
						{
							TEdge prevInAEL = horzEdge.PrevInAEL;
							TEdge nextInAEL2 = horzEdge.NextInAEL;
							if (prevInAEL != null && prevInAEL.Curr.X == horzEdge.Bot.X && prevInAEL.Curr.Y == horzEdge.Bot.Y && prevInAEL.WindDelta != 0 && prevInAEL.OutIdx >= 0 && prevInAEL.Curr.Y > prevInAEL.Top.Y && ClipperBase.SlopesEqual(horzEdge, prevInAEL, m_UseFullRange))
							{
								OutPt op = AddOutPt(prevInAEL, horzEdge.Bot);
								AddJoin(outPt, op, horzEdge.Top);
							}
							else if (nextInAEL2 != null && nextInAEL2.Curr.X == horzEdge.Bot.X && nextInAEL2.Curr.Y == horzEdge.Bot.Y && nextInAEL2.WindDelta != 0 && nextInAEL2.OutIdx >= 0 && nextInAEL2.Curr.Y > nextInAEL2.Top.Y && ClipperBase.SlopesEqual(horzEdge, nextInAEL2, m_UseFullRange))
							{
								OutPt op2 = AddOutPt(nextInAEL2, horzEdge.Bot);
								AddJoin(outPt, op2, horzEdge.Top);
							}
						}
					}
					else
					{
						UpdateEdgeIntoAEL(ref horzEdge);
					}
				}
				else
				{
					if (horzEdge.OutIdx >= 0)
					{
						AddOutPt(horzEdge, horzEdge.Top);
					}
					DeleteFromAEL(horzEdge);
				}
			}

			private TEdge GetNextInAEL(TEdge e, Direction Direction)
			{
				if (Direction != Direction.dLeftToRight)
				{
					return e.PrevInAEL;
				}
				return e.NextInAEL;
			}

			private bool IsMinima(TEdge e)
			{
				if (e != null && e.Prev.NextInLML != e)
				{
					return e.Next.NextInLML != e;
				}
				return false;
			}

			private bool IsMaxima(TEdge e, double Y)
			{
				if (e != null && (double)e.Top.Y == Y)
				{
					return e.NextInLML == null;
				}
				return false;
			}

			private bool IsIntermediate(TEdge e, double Y)
			{
				if ((double)e.Top.Y == Y)
				{
					return e.NextInLML != null;
				}
				return false;
			}

			internal TEdge GetMaximaPair(TEdge e)
			{
				if (e.Next.Top == e.Top && e.Next.NextInLML == null)
				{
					return e.Next;
				}
				if (e.Prev.Top == e.Top && e.Prev.NextInLML == null)
				{
					return e.Prev;
				}
				return null;
			}

			internal TEdge GetMaximaPairEx(TEdge e)
			{
				TEdge maximaPair = GetMaximaPair(e);
				if (maximaPair == null || maximaPair.OutIdx == -2 || (maximaPair.NextInAEL == maximaPair.PrevInAEL && !ClipperBase.IsHorizontal(maximaPair)))
				{
					return null;
				}
				return maximaPair;
			}

			private bool ProcessIntersections(long topY)
			{
				if (m_ActiveEdges == null)
				{
					return true;
				}
				try
				{
					BuildIntersectList(topY);
					if (m_IntersectList.Count == 0)
					{
						return true;
					}
					if (m_IntersectList.Count != 1 && !FixupIntersectionOrder())
					{
						return false;
					}
					ProcessIntersectList();
				}
				catch
				{
					m_SortedEdges = null;
					m_IntersectList.Clear();
					throw new ClipperException("ProcessIntersections error");
				}
				m_SortedEdges = null;
				return true;
			}

			private void BuildIntersectList(long topY)
			{
				if (m_ActiveEdges == null)
				{
					return;
				}
				for (TEdge tEdge = (m_SortedEdges = m_ActiveEdges); tEdge != null; tEdge = tEdge.NextInAEL)
				{
					tEdge.PrevInSEL = tEdge.PrevInAEL;
					tEdge.NextInSEL = tEdge.NextInAEL;
					tEdge.Curr.X = TopX(tEdge, topY);
				}
				bool flag = true;
				while (flag && m_SortedEdges != null)
				{
					flag = false;
					TEdge tEdge = m_SortedEdges;
					while (tEdge.NextInSEL != null)
					{
						TEdge nextInSEL = tEdge.NextInSEL;
						if (tEdge.Curr.X > nextInSEL.Curr.X)
						{
							IntersectPoint(tEdge, nextInSEL, out var ip);
							if (ip.Y < topY)
							{
								ip = new IntPoint(TopX(tEdge, topY), topY);
							}
							IntersectNode intersectNode = new IntersectNode();
							intersectNode.Edge1 = tEdge;
							intersectNode.Edge2 = nextInSEL;
							intersectNode.Pt = ip;
							m_IntersectList.Add(intersectNode);
							SwapPositionsInSEL(tEdge, nextInSEL);
							flag = true;
						}
						else
						{
							tEdge = nextInSEL;
						}
					}
					if (tEdge.PrevInSEL == null)
					{
						break;
					}
					tEdge.PrevInSEL.NextInSEL = null;
				}
				m_SortedEdges = null;
			}

			private bool EdgesAdjacent(IntersectNode inode)
			{
				if (inode.Edge1.NextInSEL != inode.Edge2)
				{
					return inode.Edge1.PrevInSEL == inode.Edge2;
				}
				return true;
			}

			private static int IntersectNodeSort(IntersectNode node1, IntersectNode node2)
			{
				return (int)(node2.Pt.Y - node1.Pt.Y);
			}

			private bool FixupIntersectionOrder()
			{
				m_IntersectList.Sort(m_IntersectNodeComparer);
				CopyAELToSEL();
				int count = m_IntersectList.Count;
				for (int i = 0; i < count; i++)
				{
					if (!EdgesAdjacent(m_IntersectList[i]))
					{
						int j;
						for (j = i + 1; j < count && !EdgesAdjacent(m_IntersectList[j]); j++)
						{
						}
						if (j == count)
						{
							return false;
						}
						IntersectNode value = m_IntersectList[i];
						m_IntersectList[i] = m_IntersectList[j];
						m_IntersectList[j] = value;
					}
					SwapPositionsInSEL(m_IntersectList[i].Edge1, m_IntersectList[i].Edge2);
				}
				return true;
			}

			private void ProcessIntersectList()
			{
				for (int i = 0; i < m_IntersectList.Count; i++)
				{
					IntersectNode intersectNode = m_IntersectList[i];
					IntersectEdges(intersectNode.Edge1, intersectNode.Edge2, intersectNode.Pt);
					SwapPositionsInAEL(intersectNode.Edge1, intersectNode.Edge2);
				}
				m_IntersectList.Clear();
			}

			internal static long Round(double value)
			{
				if (!(value < 0.0))
				{
					return (long)(value + 0.5);
				}
				return (long)(value - 0.5);
			}

			private static long TopX(TEdge edge, long currentY)
			{
				if (currentY == edge.Top.Y)
				{
					return edge.Top.X;
				}
				return edge.Bot.X + Round(edge.Dx * (double)(currentY - edge.Bot.Y));
			}

			private void IntersectPoint(TEdge edge1, TEdge edge2, out IntPoint ip)
			{
				ip = default(IntPoint);
				if (edge1.Dx == edge2.Dx)
				{
					ip.Y = edge1.Curr.Y;
					ip.X = TopX(edge1, ip.Y);
					return;
				}
				if (edge1.Delta.X == 0L)
				{
					ip.X = edge1.Bot.X;
					if (ClipperBase.IsHorizontal(edge2))
					{
						ip.Y = edge2.Bot.Y;
					}
					else
					{
						double num = (double)edge2.Bot.Y - (double)edge2.Bot.X / edge2.Dx;
						ip.Y = Round((double)ip.X / edge2.Dx + num);
					}
				}
				else if (edge2.Delta.X == 0L)
				{
					ip.X = edge2.Bot.X;
					if (ClipperBase.IsHorizontal(edge1))
					{
						ip.Y = edge1.Bot.Y;
					}
					else
					{
						double num2 = (double)edge1.Bot.Y - (double)edge1.Bot.X / edge1.Dx;
						ip.Y = Round((double)ip.X / edge1.Dx + num2);
					}
				}
				else
				{
					double num2 = (double)edge1.Bot.X - (double)edge1.Bot.Y * edge1.Dx;
					double num = (double)edge2.Bot.X - (double)edge2.Bot.Y * edge2.Dx;
					double num3 = (num - num2) / (edge1.Dx - edge2.Dx);
					ip.Y = Round(num3);
					if (Math.Abs(edge1.Dx) < Math.Abs(edge2.Dx))
					{
						ip.X = Round(edge1.Dx * num3 + num2);
					}
					else
					{
						ip.X = Round(edge2.Dx * num3 + num);
					}
				}
				if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)
				{
					if (edge1.Top.Y > edge2.Top.Y)
					{
						ip.Y = edge1.Top.Y;
					}
					else
					{
						ip.Y = edge2.Top.Y;
					}
					if (Math.Abs(edge1.Dx) < Math.Abs(edge2.Dx))
					{
						ip.X = TopX(edge1, ip.Y);
					}
					else
					{
						ip.X = TopX(edge2, ip.Y);
					}
				}
				if (ip.Y > edge1.Curr.Y)
				{
					ip.Y = edge1.Curr.Y;
					if (Math.Abs(edge1.Dx) > Math.Abs(edge2.Dx))
					{
						ip.X = TopX(edge2, ip.Y);
					}
					else
					{
						ip.X = TopX(edge1, ip.Y);
					}
				}
			}

			private void ProcessEdgesAtTopOfScanbeam(long topY)
			{
				TEdge e = m_ActiveEdges;
				while (e != null)
				{
					bool flag = IsMaxima(e, topY);
					if (flag)
					{
						TEdge maximaPairEx = GetMaximaPairEx(e);
						flag = maximaPairEx == null || !ClipperBase.IsHorizontal(maximaPairEx);
					}
					if (flag)
					{
						if (StrictlySimple)
						{
							InsertMaxima(e.Top.X);
						}
						TEdge prevInAEL = e.PrevInAEL;
						DoMaxima(e);
						e = ((prevInAEL != null) ? prevInAEL.NextInAEL : m_ActiveEdges);
						continue;
					}
					if (IsIntermediate(e, topY) && ClipperBase.IsHorizontal(e.NextInLML))
					{
						UpdateEdgeIntoAEL(ref e);
						if (e.OutIdx >= 0)
						{
							AddOutPt(e, e.Bot);
						}
						AddEdgeToSEL(e);
					}
					else
					{
						e.Curr.X = TopX(e, topY);
						e.Curr.Y = topY;
					}
					if (StrictlySimple)
					{
						TEdge prevInAEL2 = e.PrevInAEL;
						if (e.OutIdx >= 0 && e.WindDelta != 0 && prevInAEL2 != null && prevInAEL2.OutIdx >= 0 && prevInAEL2.Curr.X == e.Curr.X && prevInAEL2.WindDelta != 0)
						{
							IntPoint intPoint = new IntPoint(e.Curr);
							OutPt op = AddOutPt(prevInAEL2, intPoint);
							OutPt op2 = AddOutPt(e, intPoint);
							AddJoin(op, op2, intPoint);
						}
					}
					e = e.NextInAEL;
				}
				ProcessHorizontals();
				m_Maxima = null;
				for (e = m_ActiveEdges; e != null; e = e.NextInAEL)
				{
					if (IsIntermediate(e, topY))
					{
						OutPt outPt = null;
						if (e.OutIdx >= 0)
						{
							outPt = AddOutPt(e, e.Top);
						}
						UpdateEdgeIntoAEL(ref e);
						TEdge prevInAEL3 = e.PrevInAEL;
						TEdge nextInAEL = e.NextInAEL;
						if (prevInAEL3 != null && prevInAEL3.Curr.X == e.Bot.X && prevInAEL3.Curr.Y == e.Bot.Y && outPt != null && prevInAEL3.OutIdx >= 0 && prevInAEL3.Curr.Y > prevInAEL3.Top.Y && ClipperBase.SlopesEqual(e.Curr, e.Top, prevInAEL3.Curr, prevInAEL3.Top, m_UseFullRange) && e.WindDelta != 0 && prevInAEL3.WindDelta != 0)
						{
							OutPt op3 = AddOutPt(prevInAEL3, e.Bot);
							AddJoin(outPt, op3, e.Top);
						}
						else if (nextInAEL != null && nextInAEL.Curr.X == e.Bot.X && nextInAEL.Curr.Y == e.Bot.Y && outPt != null && nextInAEL.OutIdx >= 0 && nextInAEL.Curr.Y > nextInAEL.Top.Y && ClipperBase.SlopesEqual(e.Curr, e.Top, nextInAEL.Curr, nextInAEL.Top, m_UseFullRange) && e.WindDelta != 0 && nextInAEL.WindDelta != 0)
						{
							OutPt op4 = AddOutPt(nextInAEL, e.Bot);
							AddJoin(outPt, op4, e.Top);
						}
					}
				}
			}

			private void DoMaxima(TEdge e)
			{
				TEdge maximaPairEx = GetMaximaPairEx(e);
				if (maximaPairEx == null)
				{
					if (e.OutIdx >= 0)
					{
						AddOutPt(e, e.Top);
					}
					DeleteFromAEL(e);
					return;
				}
				TEdge nextInAEL = e.NextInAEL;
				while (nextInAEL != null && nextInAEL != maximaPairEx)
				{
					IntersectEdges(e, nextInAEL, e.Top);
					SwapPositionsInAEL(e, nextInAEL);
					nextInAEL = e.NextInAEL;
				}
				if (e.OutIdx == -1 && maximaPairEx.OutIdx == -1)
				{
					DeleteFromAEL(e);
					DeleteFromAEL(maximaPairEx);
					return;
				}
				if (e.OutIdx >= 0 && maximaPairEx.OutIdx >= 0)
				{
					if (e.OutIdx >= 0)
					{
						AddLocalMaxPoly(e, maximaPairEx, e.Top);
					}
					DeleteFromAEL(e);
					DeleteFromAEL(maximaPairEx);
					return;
				}
				if (e.WindDelta == 0)
				{
					if (e.OutIdx >= 0)
					{
						AddOutPt(e, e.Top);
						e.OutIdx = -1;
					}
					DeleteFromAEL(e);
					if (maximaPairEx.OutIdx >= 0)
					{
						AddOutPt(maximaPairEx, e.Top);
						maximaPairEx.OutIdx = -1;
					}
					DeleteFromAEL(maximaPairEx);
					return;
				}
				throw new ClipperException("DoMaxima error");
			}

			public static void ReversePaths(List<List<IntPoint>> polys)
			{
				foreach (List<IntPoint> poly in polys)
				{
					poly.Reverse();
				}
			}

			public static bool Orientation(List<IntPoint> poly)
			{
				return Area(poly) >= 0.0;
			}

			private int PointCount(OutPt pts)
			{
				if (pts == null)
				{
					return 0;
				}
				int num = 0;
				OutPt outPt = pts;
				do
				{
					num++;
					outPt = outPt.Next;
				}
				while (outPt != pts);
				return num;
			}

			private void BuildResult(List<List<IntPoint>> polyg)
			{
				polyg.Clear();
				polyg.Capacity = m_PolyOuts.Count;
				for (int i = 0; i < m_PolyOuts.Count; i++)
				{
					OutRec outRec = m_PolyOuts[i];
					if (outRec.Pts == null)
					{
						continue;
					}
					OutPt prev = outRec.Pts.Prev;
					int num = PointCount(prev);
					if (num >= 2)
					{
						List<IntPoint> list = new List<IntPoint>(num);
						for (int j = 0; j < num; j++)
						{
							list.Add(prev.Pt);
							prev = prev.Prev;
						}
						polyg.Add(list);
					}
				}
			}

			private void BuildResult2(PolyTree polytree)
			{
				polytree.Clear();
				polytree.m_AllPolys.Capacity = m_PolyOuts.Count;
				for (int i = 0; i < m_PolyOuts.Count; i++)
				{
					OutRec outRec = m_PolyOuts[i];
					int num = PointCount(outRec.Pts);
					if ((!outRec.IsOpen || num >= 2) && (outRec.IsOpen || num >= 3))
					{
						FixHoleLinkage(outRec);
						PolyNode polyNode = new PolyNode();
						polytree.m_AllPolys.Add(polyNode);
						outRec.PolyNode = polyNode;
						polyNode.m_polygon.Capacity = num;
						OutPt prev = outRec.Pts.Prev;
						for (int j = 0; j < num; j++)
						{
							polyNode.m_polygon.Add(prev.Pt);
							prev = prev.Prev;
						}
					}
				}
				polytree.m_Childs.Capacity = m_PolyOuts.Count;
				for (int k = 0; k < m_PolyOuts.Count; k++)
				{
					OutRec outRec2 = m_PolyOuts[k];
					if (outRec2.PolyNode != null)
					{
						if (outRec2.IsOpen)
						{
							outRec2.PolyNode.IsOpen = true;
							polytree.AddChild(outRec2.PolyNode);
						}
						else if (outRec2.FirstLeft != null && outRec2.FirstLeft.PolyNode != null)
						{
							outRec2.FirstLeft.PolyNode.AddChild(outRec2.PolyNode);
						}
						else
						{
							polytree.AddChild(outRec2.PolyNode);
						}
					}
				}
			}

			private void FixupOutPolyline(OutRec outrec)
			{
				OutPt outPt = outrec.Pts;
				OutPt prev = outPt.Prev;
				while (outPt != prev)
				{
					outPt = outPt.Next;
					if (outPt.Pt == outPt.Prev.Pt)
					{
						if (outPt == prev)
						{
							prev = outPt.Prev;
						}
						OutPt prev2 = outPt.Prev;
						prev2.Next = outPt.Next;
						outPt.Next.Prev = prev2;
						outPt = prev2;
					}
				}
				if (outPt == outPt.Prev)
				{
					outrec.Pts = null;
				}
			}

			private void FixupOutPolygon(OutRec outRec)
			{
				OutPt outPt = null;
				outRec.BottomPt = null;
				OutPt outPt2 = outRec.Pts;
				bool flag = base.PreserveCollinear || StrictlySimple;
				while (true)
				{
					if (outPt2.Prev == outPt2 || outPt2.Prev == outPt2.Next)
					{
						outRec.Pts = null;
						return;
					}
					if (outPt2.Pt == outPt2.Next.Pt || outPt2.Pt == outPt2.Prev.Pt || (ClipperBase.SlopesEqual(outPt2.Prev.Pt, outPt2.Pt, outPt2.Next.Pt, m_UseFullRange) && (!flag || !Pt2IsBetweenPt1AndPt3(outPt2.Prev.Pt, outPt2.Pt, outPt2.Next.Pt))))
					{
						outPt = null;
						outPt2.Prev.Next = outPt2.Next;
						outPt2.Next.Prev = outPt2.Prev;
						outPt2 = outPt2.Prev;
						continue;
					}
					if (outPt2 == outPt)
					{
						break;
					}
					if (outPt == null)
					{
						outPt = outPt2;
					}
					outPt2 = outPt2.Next;
				}
				outRec.Pts = outPt2;
			}

			private OutPt DupOutPt(OutPt outPt, bool InsertAfter)
			{
				OutPt outPt2 = new OutPt();
				outPt2.Pt = outPt.Pt;
				outPt2.Idx = outPt.Idx;
				if (InsertAfter)
				{
					outPt2.Next = outPt.Next;
					outPt2.Prev = outPt;
					outPt.Next.Prev = outPt2;
					outPt.Next = outPt2;
				}
				else
				{
					outPt2.Prev = outPt.Prev;
					outPt2.Next = outPt;
					outPt.Prev.Next = outPt2;
					outPt.Prev = outPt2;
				}
				return outPt2;
			}

			private bool GetOverlap(long a1, long a2, long b1, long b2, out long Left, out long Right)
			{
				if (a1 < a2)
				{
					if (b1 < b2)
					{
						Left = Math.Max(a1, b1);
						Right = Math.Min(a2, b2);
					}
					else
					{
						Left = Math.Max(a1, b2);
						Right = Math.Min(a2, b1);
					}
				}
				else if (b1 < b2)
				{
					Left = Math.Max(a2, b1);
					Right = Math.Min(a1, b2);
				}
				else
				{
					Left = Math.Max(a2, b2);
					Right = Math.Min(a1, b1);
				}
				return Left < Right;
			}

			private bool JoinHorz(OutPt op1, OutPt op1b, OutPt op2, OutPt op2b, IntPoint Pt, bool DiscardLeft)
			{
				Direction direction = ((op1.Pt.X <= op1b.Pt.X) ? Direction.dLeftToRight : Direction.dRightToLeft);
				Direction direction2 = ((op2.Pt.X <= op2b.Pt.X) ? Direction.dLeftToRight : Direction.dRightToLeft);
				if (direction == direction2)
				{
					return false;
				}
				if (direction == Direction.dLeftToRight)
				{
					while (op1.Next.Pt.X <= Pt.X && op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)
					{
						op1 = op1.Next;
					}
					if (DiscardLeft && op1.Pt.X != Pt.X)
					{
						op1 = op1.Next;
					}
					op1b = DupOutPt(op1, !DiscardLeft);
					if (op1b.Pt != Pt)
					{
						op1 = op1b;
						op1.Pt = Pt;
						op1b = DupOutPt(op1, !DiscardLeft);
					}
				}
				else
				{
					while (op1.Next.Pt.X >= Pt.X && op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)
					{
						op1 = op1.Next;
					}
					if (!DiscardLeft && op1.Pt.X != Pt.X)
					{
						op1 = op1.Next;
					}
					op1b = DupOutPt(op1, DiscardLeft);
					if (op1b.Pt != Pt)
					{
						op1 = op1b;
						op1.Pt = Pt;
						op1b = DupOutPt(op1, DiscardLeft);
					}
				}
				if (direction2 == Direction.dLeftToRight)
				{
					while (op2.Next.Pt.X <= Pt.X && op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)
					{
						op2 = op2.Next;
					}
					if (DiscardLeft && op2.Pt.X != Pt.X)
					{
						op2 = op2.Next;
					}
					op2b = DupOutPt(op2, !DiscardLeft);
					if (op2b.Pt != Pt)
					{
						op2 = op2b;
						op2.Pt = Pt;
						op2b = DupOutPt(op2, !DiscardLeft);
					}
				}
				else
				{
					while (op2.Next.Pt.X >= Pt.X && op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)
					{
						op2 = op2.Next;
					}
					if (!DiscardLeft && op2.Pt.X != Pt.X)
					{
						op2 = op2.Next;
					}
					op2b = DupOutPt(op2, DiscardLeft);
					if (op2b.Pt != Pt)
					{
						op2 = op2b;
						op2.Pt = Pt;
						op2b = DupOutPt(op2, DiscardLeft);
					}
				}
				if (direction == Direction.dLeftToRight == DiscardLeft)
				{
					op1.Prev = op2;
					op2.Next = op1;
					op1b.Next = op2b;
					op2b.Prev = op1b;
				}
				else
				{
					op1.Next = op2;
					op2.Prev = op1;
					op1b.Prev = op2b;
					op2b.Next = op1b;
				}
				return true;
			}

			private bool JoinPoints(Join j, OutRec outRec1, OutRec outRec2)
			{
				OutPt outPt = j.OutPt1;
				OutPt outPt2 = j.OutPt2;
				bool flag = j.OutPt1.Pt.Y == j.OffPt.Y;
				OutPt next;
				OutPt next2;
				if (flag && j.OffPt == j.OutPt1.Pt && j.OffPt == j.OutPt2.Pt)
				{
					if (outRec1 != outRec2)
					{
						return false;
					}
					next = j.OutPt1.Next;
					while (next != outPt && next.Pt == j.OffPt)
					{
						next = next.Next;
					}
					bool flag2 = next.Pt.Y > j.OffPt.Y;
					next2 = j.OutPt2.Next;
					while (next2 != outPt2 && next2.Pt == j.OffPt)
					{
						next2 = next2.Next;
					}
					bool flag3 = next2.Pt.Y > j.OffPt.Y;
					if (flag2 == flag3)
					{
						return false;
					}
					if (flag2)
					{
						next = DupOutPt(outPt, InsertAfter: false);
						next2 = DupOutPt(outPt2, InsertAfter: true);
						outPt.Prev = outPt2;
						outPt2.Next = outPt;
						next.Next = next2;
						next2.Prev = next;
						j.OutPt1 = outPt;
						j.OutPt2 = next;
						return true;
					}
					next = DupOutPt(outPt, InsertAfter: true);
					next2 = DupOutPt(outPt2, InsertAfter: false);
					outPt.Next = outPt2;
					outPt2.Prev = outPt;
					next.Prev = next2;
					next2.Next = next;
					j.OutPt1 = outPt;
					j.OutPt2 = next;
					return true;
				}
				if (flag)
				{
					next = outPt;
					while (outPt.Prev.Pt.Y == outPt.Pt.Y && outPt.Prev != next && outPt.Prev != outPt2)
					{
						outPt = outPt.Prev;
					}
					while (next.Next.Pt.Y == next.Pt.Y && next.Next != outPt && next.Next != outPt2)
					{
						next = next.Next;
					}
					if (next.Next == outPt || next.Next == outPt2)
					{
						return false;
					}
					next2 = outPt2;
					while (outPt2.Prev.Pt.Y == outPt2.Pt.Y && outPt2.Prev != next2 && outPt2.Prev != next)
					{
						outPt2 = outPt2.Prev;
					}
					while (next2.Next.Pt.Y == next2.Pt.Y && next2.Next != outPt2 && next2.Next != outPt)
					{
						next2 = next2.Next;
					}
					if (next2.Next == outPt2 || next2.Next == outPt)
					{
						return false;
					}
					if (!GetOverlap(outPt.Pt.X, next.Pt.X, outPt2.Pt.X, next2.Pt.X, out var Left, out var Right))
					{
						return false;
					}
					IntPoint pt;
					bool discardLeft;
					if (outPt.Pt.X >= Left && outPt.Pt.X <= Right)
					{
						pt = outPt.Pt;
						discardLeft = outPt.Pt.X > next.Pt.X;
					}
					else if (outPt2.Pt.X >= Left && outPt2.Pt.X <= Right)
					{
						pt = outPt2.Pt;
						discardLeft = outPt2.Pt.X > next2.Pt.X;
					}
					else if (next.Pt.X >= Left && next.Pt.X <= Right)
					{
						pt = next.Pt;
						discardLeft = next.Pt.X > outPt.Pt.X;
					}
					else
					{
						pt = next2.Pt;
						discardLeft = next2.Pt.X > outPt2.Pt.X;
					}
					j.OutPt1 = outPt;
					j.OutPt2 = outPt2;
					return JoinHorz(outPt, next, outPt2, next2, pt, discardLeft);
				}
				next = outPt.Next;
				while (next.Pt == outPt.Pt && next != outPt)
				{
					next = next.Next;
				}
				bool flag4 = next.Pt.Y > outPt.Pt.Y || !ClipperBase.SlopesEqual(outPt.Pt, next.Pt, j.OffPt, m_UseFullRange);
				if (flag4)
				{
					next = outPt.Prev;
					while (next.Pt == outPt.Pt && next != outPt)
					{
						next = next.Prev;
					}
					if (next.Pt.Y > outPt.Pt.Y || !ClipperBase.SlopesEqual(outPt.Pt, next.Pt, j.OffPt, m_UseFullRange))
					{
						return false;
					}
				}
				next2 = outPt2.Next;
				while (next2.Pt == outPt2.Pt && next2 != outPt2)
				{
					next2 = next2.Next;
				}
				bool flag5 = next2.Pt.Y > outPt2.Pt.Y || !ClipperBase.SlopesEqual(outPt2.Pt, next2.Pt, j.OffPt, m_UseFullRange);
				if (flag5)
				{
					next2 = outPt2.Prev;
					while (next2.Pt == outPt2.Pt && next2 != outPt2)
					{
						next2 = next2.Prev;
					}
					if (next2.Pt.Y > outPt2.Pt.Y || !ClipperBase.SlopesEqual(outPt2.Pt, next2.Pt, j.OffPt, m_UseFullRange))
					{
						return false;
					}
				}
				if (next == outPt || next2 == outPt2 || next == next2 || (outRec1 == outRec2 && flag4 == flag5))
				{
					return false;
				}
				if (flag4)
				{
					next = DupOutPt(outPt, InsertAfter: false);
					next2 = DupOutPt(outPt2, InsertAfter: true);
					outPt.Prev = outPt2;
					outPt2.Next = outPt;
					next.Next = next2;
					next2.Prev = next;
					j.OutPt1 = outPt;
					j.OutPt2 = next;
					return true;
				}
				next = DupOutPt(outPt, InsertAfter: true);
				next2 = DupOutPt(outPt2, InsertAfter: false);
				outPt.Next = outPt2;
				outPt2.Prev = outPt;
				next.Prev = next2;
				next2.Next = next;
				j.OutPt1 = outPt;
				j.OutPt2 = next;
				return true;
			}

			public static int PointInPolygon(IntPoint pt, List<IntPoint> path)
			{
				int num = 0;
				int count = path.Count;
				if (count < 3)
				{
					return 0;
				}
				IntPoint intPoint = path[0];
				for (int i = 1; i <= count; i++)
				{
					IntPoint intPoint2 = ((i == count) ? path[0] : path[i]);
					if (intPoint2.Y == pt.Y && (intPoint2.X == pt.X || (intPoint.Y == pt.Y && intPoint2.X > pt.X == intPoint.X < pt.X)))
					{
						return -1;
					}
					if (intPoint.Y < pt.Y != intPoint2.Y < pt.Y)
					{
						if (intPoint.X >= pt.X)
						{
							if (intPoint2.X > pt.X)
							{
								num = 1 - num;
							}
							else
							{
								double num2 = (double)(intPoint.X - pt.X) * (double)(intPoint2.Y - pt.Y) - (double)(intPoint2.X - pt.X) * (double)(intPoint.Y - pt.Y);
								if (num2 == 0.0)
								{
									return -1;
								}
								if (num2 > 0.0 == intPoint2.Y > intPoint.Y)
								{
									num = 1 - num;
								}
							}
						}
						else if (intPoint2.X > pt.X)
						{
							double num3 = (double)(intPoint.X - pt.X) * (double)(intPoint2.Y - pt.Y) - (double)(intPoint2.X - pt.X) * (double)(intPoint.Y - pt.Y);
							if (num3 == 0.0)
							{
								return -1;
							}
							if (num3 > 0.0 == intPoint2.Y > intPoint.Y)
							{
								num = 1 - num;
							}
						}
					}
					intPoint = intPoint2;
				}
				return num;
			}

			private static int PointInPolygon(IntPoint pt, OutPt op)
			{
				int num = 0;
				OutPt outPt = op;
				long x = pt.X;
				long y = pt.Y;
				long num2 = op.Pt.X;
				long num3 = op.Pt.Y;
				do
				{
					op = op.Next;
					long x2 = op.Pt.X;
					long y2 = op.Pt.Y;
					if (y2 == y && (x2 == x || (num3 == y && x2 > x == num2 < x)))
					{
						return -1;
					}
					if (num3 < y != y2 < y)
					{
						if (num2 >= x)
						{
							if (x2 > x)
							{
								num = 1 - num;
							}
							else
							{
								double num4 = (double)(num2 - x) * (double)(y2 - y) - (double)(x2 - x) * (double)(num3 - y);
								if (num4 == 0.0)
								{
									return -1;
								}
								if (num4 > 0.0 == y2 > num3)
								{
									num = 1 - num;
								}
							}
						}
						else if (x2 > x)
						{
							double num5 = (double)(num2 - x) * (double)(y2 - y) - (double)(x2 - x) * (double)(num3 - y);
							if (num5 == 0.0)
							{
								return -1;
							}
							if (num5 > 0.0 == y2 > num3)
							{
								num = 1 - num;
							}
						}
					}
					num2 = x2;
					num3 = y2;
				}
				while (outPt != op);
				return num;
			}

			private static bool Poly2ContainsPoly1(OutPt outPt1, OutPt outPt2)
			{
				OutPt outPt3 = outPt1;
				do
				{
					int num = PointInPolygon(outPt3.Pt, outPt2);
					if (num >= 0)
					{
						return num > 0;
					}
					outPt3 = outPt3.Next;
				}
				while (outPt3 != outPt1);
				return true;
			}

			private void FixupFirstLefts1(OutRec OldOutRec, OutRec NewOutRec)
			{
				foreach (OutRec polyOut in m_PolyOuts)
				{
					OutRec outRec = ParseFirstLeft(polyOut.FirstLeft);
					if (polyOut.Pts != null && outRec == OldOutRec && Poly2ContainsPoly1(polyOut.Pts, NewOutRec.Pts))
					{
						polyOut.FirstLeft = NewOutRec;
					}
				}
			}

			private void FixupFirstLefts2(OutRec innerOutRec, OutRec outerOutRec)
			{
				OutRec firstLeft = outerOutRec.FirstLeft;
				foreach (OutRec polyOut in m_PolyOuts)
				{
					if (polyOut.Pts == null || polyOut == outerOutRec || polyOut == innerOutRec)
					{
						continue;
					}
					OutRec outRec = ParseFirstLeft(polyOut.FirstLeft);
					if (outRec == firstLeft || outRec == innerOutRec || outRec == outerOutRec)
					{
						if (Poly2ContainsPoly1(polyOut.Pts, innerOutRec.Pts))
						{
							polyOut.FirstLeft = innerOutRec;
						}
						else if (Poly2ContainsPoly1(polyOut.Pts, outerOutRec.Pts))
						{
							polyOut.FirstLeft = outerOutRec;
						}
						else if (polyOut.FirstLeft == innerOutRec || polyOut.FirstLeft == outerOutRec)
						{
							polyOut.FirstLeft = firstLeft;
						}
					}
				}
			}

			private void FixupFirstLefts3(OutRec OldOutRec, OutRec NewOutRec)
			{
				foreach (OutRec polyOut in m_PolyOuts)
				{
					OutRec outRec = ParseFirstLeft(polyOut.FirstLeft);
					if (polyOut.Pts != null && outRec == OldOutRec)
					{
						polyOut.FirstLeft = NewOutRec;
					}
				}
			}

			private static OutRec ParseFirstLeft(OutRec FirstLeft)
			{
				while (FirstLeft != null && FirstLeft.Pts == null)
				{
					FirstLeft = FirstLeft.FirstLeft;
				}
				return FirstLeft;
			}

			private void JoinCommonEdges()
			{
				for (int i = 0; i < m_Joins.Count; i++)
				{
					Join obj = m_Joins[i];
					OutRec outRec = GetOutRec(obj.OutPt1.Idx);
					OutRec outRec2 = GetOutRec(obj.OutPt2.Idx);
					if (outRec.Pts == null || outRec2.Pts == null || outRec.IsOpen || outRec2.IsOpen)
					{
						continue;
					}
					OutRec outRec3 = ((outRec == outRec2) ? outRec : (OutRec1RightOfOutRec2(outRec, outRec2) ? outRec2 : ((!OutRec1RightOfOutRec2(outRec2, outRec)) ? GetLowermostRec(outRec, outRec2) : outRec)));
					if (!JoinPoints(obj, outRec, outRec2))
					{
						continue;
					}
					if (outRec == outRec2)
					{
						outRec.Pts = obj.OutPt1;
						outRec.BottomPt = null;
						outRec2 = CreateOutRec();
						outRec2.Pts = obj.OutPt2;
						UpdateOutPtIdxs(outRec2);
						if (Poly2ContainsPoly1(outRec2.Pts, outRec.Pts))
						{
							outRec2.IsHole = !outRec.IsHole;
							outRec2.FirstLeft = outRec;
							if (m_UsingPolyTree)
							{
								FixupFirstLefts2(outRec2, outRec);
							}
							if ((outRec2.IsHole ^ ReverseSolution) == Area(outRec2) > 0.0)
							{
								ReversePolyPtLinks(outRec2.Pts);
							}
						}
						else if (Poly2ContainsPoly1(outRec.Pts, outRec2.Pts))
						{
							outRec2.IsHole = outRec.IsHole;
							outRec.IsHole = !outRec2.IsHole;
							outRec2.FirstLeft = outRec.FirstLeft;
							outRec.FirstLeft = outRec2;
							if (m_UsingPolyTree)
							{
								FixupFirstLefts2(outRec, outRec2);
							}
							if ((outRec.IsHole ^ ReverseSolution) == Area(outRec) > 0.0)
							{
								ReversePolyPtLinks(outRec.Pts);
							}
						}
						else
						{
							outRec2.IsHole = outRec.IsHole;
							outRec2.FirstLeft = outRec.FirstLeft;
							if (m_UsingPolyTree)
							{
								FixupFirstLefts1(outRec, outRec2);
							}
						}
					}
					else
					{
						outRec2.Pts = null;
						outRec2.BottomPt = null;
						outRec2.Idx = outRec.Idx;
						outRec.IsHole = outRec3.IsHole;
						if (outRec3 == outRec2)
						{
							outRec.FirstLeft = outRec2.FirstLeft;
						}
						outRec2.FirstLeft = outRec;
						if (m_UsingPolyTree)
						{
							FixupFirstLefts3(outRec2, outRec);
						}
					}
				}
			}

			private void UpdateOutPtIdxs(OutRec outrec)
			{
				OutPt outPt = outrec.Pts;
				do
				{
					outPt.Idx = outrec.Idx;
					outPt = outPt.Prev;
				}
				while (outPt != outrec.Pts);
			}

			private void DoSimplePolygons()
			{
				int num = 0;
				while (num < m_PolyOuts.Count)
				{
					OutRec outRec = m_PolyOuts[num++];
					OutPt outPt = outRec.Pts;
					if (outPt == null || outRec.IsOpen)
					{
						continue;
					}
					do
					{
						for (OutPt outPt2 = outPt.Next; outPt2 != outRec.Pts; outPt2 = outPt2.Next)
						{
							if (outPt.Pt == outPt2.Pt && outPt2.Next != outPt && outPt2.Prev != outPt)
							{
								OutPt prev = outPt.Prev;
								(outPt.Prev = outPt2.Prev).Next = outPt;
								outPt2.Prev = prev;
								prev.Next = outPt2;
								outRec.Pts = outPt;
								OutRec outRec2 = CreateOutRec();
								outRec2.Pts = outPt2;
								UpdateOutPtIdxs(outRec2);
								if (Poly2ContainsPoly1(outRec2.Pts, outRec.Pts))
								{
									outRec2.IsHole = !outRec.IsHole;
									outRec2.FirstLeft = outRec;
									if (m_UsingPolyTree)
									{
										FixupFirstLefts2(outRec2, outRec);
									}
								}
								else if (Poly2ContainsPoly1(outRec.Pts, outRec2.Pts))
								{
									outRec2.IsHole = outRec.IsHole;
									outRec.IsHole = !outRec2.IsHole;
									outRec2.FirstLeft = outRec.FirstLeft;
									outRec.FirstLeft = outRec2;
									if (m_UsingPolyTree)
									{
										FixupFirstLefts2(outRec, outRec2);
									}
								}
								else
								{
									outRec2.IsHole = outRec.IsHole;
									outRec2.FirstLeft = outRec.FirstLeft;
									if (m_UsingPolyTree)
									{
										FixupFirstLefts1(outRec, outRec2);
									}
								}
								outPt2 = outPt;
							}
						}
						outPt = outPt.Next;
					}
					while (outPt != outRec.Pts);
				}
			}

			public static double Area(List<IntPoint> poly)
			{
				int count = poly.Count;
				if (count < 3)
				{
					return 0.0;
				}
				double num = 0.0;
				int i = 0;
				int index = count - 1;
				for (; i < count; i++)
				{
					num += ((double)poly[index].X + (double)poly[i].X) * ((double)poly[index].Y - (double)poly[i].Y);
					index = i;
				}
				return (0.0 - num) * 0.5;
			}

			internal double Area(OutRec outRec)
			{
				return Area(outRec.Pts);
			}

			internal double Area(OutPt op)
			{
				OutPt outPt = op;
				if (op == null)
				{
					return 0.0;
				}
				double num = 0.0;
				do
				{
					num += (double)(op.Prev.Pt.X + op.Pt.X) * (double)(op.Prev.Pt.Y - op.Pt.Y);
					op = op.Next;
				}
				while (op != outPt);
				return num * 0.5;
			}

			public static List<List<IntPoint>> SimplifyPolygon(List<IntPoint> poly, PolyFillType fillType = PolyFillType.pftEvenOdd)
			{
				List<List<IntPoint>> list = new List<List<IntPoint>>();
				Clipper clipper = new Clipper();
				clipper.StrictlySimple = true;
				clipper.AddPath(poly, PolyType.ptSubject, Closed: true);
				clipper.Execute(ClipType.ctUnion, list, fillType, fillType);
				return list;
			}

			public static List<List<IntPoint>> SimplifyPolygons(List<List<IntPoint>> polys, PolyFillType fillType = PolyFillType.pftEvenOdd)
			{
				List<List<IntPoint>> list = new List<List<IntPoint>>();
				Clipper clipper = new Clipper();
				clipper.StrictlySimple = true;
				clipper.AddPaths(polys, PolyType.ptSubject, closed: true);
				clipper.Execute(ClipType.ctUnion, list, fillType, fillType);
				return list;
			}

			private static double DistanceSqrd(IntPoint pt1, IntPoint pt2)
			{
				double num = (double)pt1.X - (double)pt2.X;
				double num2 = (double)pt1.Y - (double)pt2.Y;
				return num * num + num2 * num2;
			}

			private static double DistanceFromLineSqrd(IntPoint pt, IntPoint ln1, IntPoint ln2)
			{
				double num = ln1.Y - ln2.Y;
				double num2 = ln2.X - ln1.X;
				double num3 = num * (double)ln1.X + num2 * (double)ln1.Y;
				num3 = num * (double)pt.X + num2 * (double)pt.Y - num3;
				return num3 * num3 / (num * num + num2 * num2);
			}

			private static bool SlopesNearCollinear(IntPoint pt1, IntPoint pt2, IntPoint pt3, double distSqrd)
			{
				if (Math.Abs(pt1.X - pt2.X) > Math.Abs(pt1.Y - pt2.Y))
				{
					if (pt1.X > pt2.X == pt1.X < pt3.X)
					{
						return DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;
					}
					if (pt2.X > pt1.X == pt2.X < pt3.X)
					{
						return DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;
					}
					return DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;
				}
				if (pt1.Y > pt2.Y == pt1.Y < pt3.Y)
				{
					return DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;
				}
				if (pt2.Y > pt1.Y == pt2.Y < pt3.Y)
				{
					return DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;
				}
				return DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;
			}

			private static bool PointsAreClose(IntPoint pt1, IntPoint pt2, double distSqrd)
			{
				double num = (double)pt1.X - (double)pt2.X;
				double num2 = (double)pt1.Y - (double)pt2.Y;
				return num * num + num2 * num2 <= distSqrd;
			}

			private static OutPt ExcludeOp(OutPt op)
			{
				OutPt prev = op.Prev;
				prev.Next = op.Next;
				op.Next.Prev = prev;
				prev.Idx = 0;
				return prev;
			}

			public static List<IntPoint> CleanPolygon(List<IntPoint> path, double distance = 1.415)
			{
				int num = path.Count;
				if (num == 0)
				{
					return new List<IntPoint>();
				}
				OutPt[] array = new OutPt[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = new OutPt();
				}
				for (int j = 0; j < num; j++)
				{
					array[j].Pt = path[j];
					array[j].Next = array[(j + 1) % num];
					array[j].Next.Prev = array[j];
					array[j].Idx = 0;
				}
				double distSqrd = distance * distance;
				OutPt outPt = array[0];
				while (outPt.Idx == 0 && outPt.Next != outPt.Prev)
				{
					if (PointsAreClose(outPt.Pt, outPt.Prev.Pt, distSqrd))
					{
						outPt = ExcludeOp(outPt);
						num--;
					}
					else if (PointsAreClose(outPt.Prev.Pt, outPt.Next.Pt, distSqrd))
					{
						ExcludeOp(outPt.Next);
						outPt = ExcludeOp(outPt);
						num -= 2;
					}
					else if (SlopesNearCollinear(outPt.Prev.Pt, outPt.Pt, outPt.Next.Pt, distSqrd))
					{
						outPt = ExcludeOp(outPt);
						num--;
					}
					else
					{
						outPt.Idx = 1;
						outPt = outPt.Next;
					}
				}
				if (num < 3)
				{
					num = 0;
				}
				List<IntPoint> list = new List<IntPoint>(num);
				for (int k = 0; k < num; k++)
				{
					list.Add(outPt.Pt);
					outPt = outPt.Next;
				}
				array = null;
				return list;
			}

			public static List<List<IntPoint>> CleanPolygons(List<List<IntPoint>> polys, double distance = 1.415)
			{
				List<List<IntPoint>> list = new List<List<IntPoint>>(polys.Count);
				for (int i = 0; i < polys.Count; i++)
				{
					list.Add(CleanPolygon(polys[i], distance));
				}
				return list;
			}

			internal static List<List<IntPoint>> Minkowski(List<IntPoint> pattern, List<IntPoint> path, bool IsSum, bool IsClosed)
			{
				int num = (IsClosed ? 1 : 0);
				int count = pattern.Count;
				int count2 = path.Count;
				List<List<IntPoint>> list = new List<List<IntPoint>>(count2);
				if (IsSum)
				{
					for (int i = 0; i < count2; i++)
					{
						List<IntPoint> list2 = new List<IntPoint>(count);
						foreach (IntPoint item in pattern)
						{
							list2.Add(new IntPoint(path[i].X + item.X, path[i].Y + item.Y));
						}
						list.Add(list2);
					}
				}
				else
				{
					for (int j = 0; j < count2; j++)
					{
						List<IntPoint> list3 = new List<IntPoint>(count);
						foreach (IntPoint item2 in pattern)
						{
							list3.Add(new IntPoint(path[j].X - item2.X, path[j].Y - item2.Y));
						}
						list.Add(list3);
					}
				}
				List<List<IntPoint>> list4 = new List<List<IntPoint>>((count2 + num) * (count + 1));
				for (int k = 0; k < count2 - 1 + num; k++)
				{
					for (int l = 0; l < count; l++)
					{
						List<IntPoint> list5 = new List<IntPoint>(4);
						list5.Add(list[k % count2][l % count]);
						list5.Add(list[(k + 1) % count2][l % count]);
						list5.Add(list[(k + 1) % count2][(l + 1) % count]);
						list5.Add(list[k % count2][(l + 1) % count]);
						if (!Orientation(list5))
						{
							list5.Reverse();
						}
						list4.Add(list5);
					}
				}
				return list4;
			}

			public static List<List<IntPoint>> MinkowskiSum(List<IntPoint> pattern, List<IntPoint> path, bool pathIsClosed)
			{
				List<List<IntPoint>> list = Minkowski(pattern, path, IsSum: true, pathIsClosed);
				Clipper clipper = new Clipper();
				clipper.AddPaths(list, PolyType.ptSubject, closed: true);
				clipper.Execute(ClipType.ctUnion, list, PolyFillType.pftNonZero, PolyFillType.pftNonZero);
				return list;
			}

			private static List<IntPoint> TranslatePath(List<IntPoint> path, IntPoint delta)
			{
				List<IntPoint> list = new List<IntPoint>(path.Count);
				for (int i = 0; i < path.Count; i++)
				{
					list.Add(new IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));
				}
				return list;
			}

			public static List<List<IntPoint>> MinkowskiSum(List<IntPoint> pattern, List<List<IntPoint>> paths, bool pathIsClosed)
			{
				List<List<IntPoint>> list = new List<List<IntPoint>>();
				Clipper clipper = new Clipper();
				for (int i = 0; i < paths.Count; i++)
				{
					List<List<IntPoint>> ppg = Minkowski(pattern, paths[i], IsSum: true, pathIsClosed);
					clipper.AddPaths(ppg, PolyType.ptSubject, closed: true);
					if (pathIsClosed)
					{
						List<IntPoint> pg = TranslatePath(paths[i], pattern[0]);
						clipper.AddPath(pg, PolyType.ptClip, Closed: true);
					}
				}
				clipper.Execute(ClipType.ctUnion, list, PolyFillType.pftNonZero, PolyFillType.pftNonZero);
				return list;
			}

			public static List<List<IntPoint>> MinkowskiDiff(List<IntPoint> poly1, List<IntPoint> poly2)
			{
				List<List<IntPoint>> list = Minkowski(poly1, poly2, IsSum: false, IsClosed: true);
				Clipper clipper = new Clipper();
				clipper.AddPaths(list, PolyType.ptSubject, closed: true);
				clipper.Execute(ClipType.ctUnion, list, PolyFillType.pftNonZero, PolyFillType.pftNonZero);
				return list;
			}

			public static List<List<IntPoint>> PolyTreeToPaths(PolyTree polytree)
			{
				List<List<IntPoint>> list = new List<List<IntPoint>>();
				list.Capacity = polytree.Total;
				AddPolyNodeToPaths(polytree, NodeType.ntAny, list);
				return list;
			}

			internal static void AddPolyNodeToPaths(PolyNode polynode, NodeType nt, List<List<IntPoint>> paths)
			{
				bool flag = true;
				switch (nt)
				{
				case NodeType.ntOpen:
					return;
				case NodeType.ntClosed:
					flag = !polynode.IsOpen;
					break;
				}
				if (polynode.m_polygon.Count > 0 && flag)
				{
					paths.Add(polynode.m_polygon);
				}
				foreach (PolyNode child in polynode.Childs)
				{
					AddPolyNodeToPaths(child, nt, paths);
				}
			}

			public static List<List<IntPoint>> OpenPathsFromPolyTree(PolyTree polytree)
			{
				List<List<IntPoint>> list = new List<List<IntPoint>>();
				list.Capacity = polytree.ChildCount;
				for (int i = 0; i < polytree.ChildCount; i++)
				{
					if (polytree.Childs[i].IsOpen)
					{
						list.Add(polytree.Childs[i].m_polygon);
					}
				}
				return list;
			}

			public static List<List<IntPoint>> ClosedPathsFromPolyTree(PolyTree polytree)
			{
				List<List<IntPoint>> list = new List<List<IntPoint>>();
				list.Capacity = polytree.Total;
				AddPolyNodeToPaths(polytree, NodeType.ntClosed, list);
				return list;
			}
		}

		public class ClipperOffset
		{
			private List<List<IntPoint>> m_destPolys;

			private List<IntPoint> m_srcPoly;

			private List<IntPoint> m_destPoly;

			private List<DoublePoint> m_normals = new List<DoublePoint>();

			private double m_delta;

			private double m_sinA;

			private double m_sin;

			private double m_cos;

			private double m_miterLim;

			private double m_StepsPerRad;

			private IntPoint m_lowest;

			private PolyNode m_polyNodes = new PolyNode();

			private const double two_pi = Math.PI * 2.0;

			private const double def_arc_tolerance = 0.25;

			public double ArcTolerance { get; set; }

			public double MiterLimit { get; set; }

			public ClipperOffset(double miterLimit = 2.0, double arcTolerance = 0.25)
			{
				MiterLimit = miterLimit;
				ArcTolerance = arcTolerance;
				m_lowest.X = -1L;
			}

			public void Clear()
			{
				m_polyNodes.Childs.Clear();
				m_lowest.X = -1L;
			}

			internal static long Round(double value)
			{
				if (!(value < 0.0))
				{
					return (long)(value + 0.5);
				}
				return (long)(value - 0.5);
			}

			public void AddPath(List<IntPoint> path, JoinType joinType, EndType endType)
			{
				int num = path.Count - 1;
				if (num < 0)
				{
					return;
				}
				PolyNode polyNode = new PolyNode();
				polyNode.m_jointype = joinType;
				polyNode.m_endtype = endType;
				if (endType == EndType.etClosedLine || endType == EndType.etClosedPolygon)
				{
					while (num > 0 && path[0] == path[num])
					{
						num--;
					}
				}
				polyNode.m_polygon.Capacity = num + 1;
				polyNode.m_polygon.Add(path[0]);
				int num2 = 0;
				int num3 = 0;
				for (int i = 1; i <= num; i++)
				{
					if (polyNode.m_polygon[num2] != path[i])
					{
						num2++;
						polyNode.m_polygon.Add(path[i]);
						if (path[i].Y > polyNode.m_polygon[num3].Y || (path[i].Y == polyNode.m_polygon[num3].Y && path[i].X < polyNode.m_polygon[num3].X))
						{
							num3 = num2;
						}
					}
				}
				if (endType == EndType.etClosedPolygon && num2 < 2)
				{
					return;
				}
				m_polyNodes.AddChild(polyNode);
				if (endType != EndType.etClosedPolygon)
				{
					return;
				}
				if (m_lowest.X < 0)
				{
					m_lowest = new IntPoint(m_polyNodes.ChildCount - 1, num3);
					return;
				}
				IntPoint intPoint = m_polyNodes.Childs[(int)m_lowest.X].m_polygon[(int)m_lowest.Y];
				if (polyNode.m_polygon[num3].Y > intPoint.Y || (polyNode.m_polygon[num3].Y == intPoint.Y && polyNode.m_polygon[num3].X < intPoint.X))
				{
					m_lowest = new IntPoint(m_polyNodes.ChildCount - 1, num3);
				}
			}

			public void AddPaths(List<List<IntPoint>> paths, JoinType joinType, EndType endType)
			{
				foreach (List<IntPoint> path in paths)
				{
					AddPath(path, joinType, endType);
				}
			}

			private void FixOrientations()
			{
				if (m_lowest.X >= 0 && !Clipper.Orientation(m_polyNodes.Childs[(int)m_lowest.X].m_polygon))
				{
					for (int i = 0; i < m_polyNodes.ChildCount; i++)
					{
						PolyNode polyNode = m_polyNodes.Childs[i];
						if (polyNode.m_endtype == EndType.etClosedPolygon || (polyNode.m_endtype == EndType.etClosedLine && Clipper.Orientation(polyNode.m_polygon)))
						{
							polyNode.m_polygon.Reverse();
						}
					}
					return;
				}
				for (int j = 0; j < m_polyNodes.ChildCount; j++)
				{
					PolyNode polyNode2 = m_polyNodes.Childs[j];
					if (polyNode2.m_endtype == EndType.etClosedLine && !Clipper.Orientation(polyNode2.m_polygon))
					{
						polyNode2.m_polygon.Reverse();
					}
				}
			}

			internal static DoublePoint GetUnitNormal(IntPoint pt1, IntPoint pt2)
			{
				double num = pt2.X - pt1.X;
				double num2 = pt2.Y - pt1.Y;
				if (num == 0.0 && num2 == 0.0)
				{
					return default(DoublePoint);
				}
				double num3 = 1.0 / Math.Sqrt(num * num + num2 * num2);
				num *= num3;
				num2 *= num3;
				return new DoublePoint(num2, 0.0 - num);
			}

			private void DoOffset(double delta)
			{
				m_destPolys = new List<List<IntPoint>>();
				m_delta = delta;
				if (ClipperBase.near_zero(delta))
				{
					m_destPolys.Capacity = m_polyNodes.ChildCount;
					for (int i = 0; i < m_polyNodes.ChildCount; i++)
					{
						PolyNode polyNode = m_polyNodes.Childs[i];
						if (polyNode.m_endtype == EndType.etClosedPolygon)
						{
							m_destPolys.Add(polyNode.m_polygon);
						}
					}
					return;
				}
				if (MiterLimit > 2.0)
				{
					m_miterLim = 2.0 / (MiterLimit * MiterLimit);
				}
				else
				{
					m_miterLim = 0.5;
				}
				double num = ((ArcTolerance <= 0.0) ? 0.25 : ((!(ArcTolerance > Math.Abs(delta) * 0.25)) ? ArcTolerance : (Math.Abs(delta) * 0.25)));
				double num2 = Math.PI / Math.Acos(1.0 - num / Math.Abs(delta));
				m_sin = Math.Sin(Math.PI * 2.0 / num2);
				m_cos = Math.Cos(Math.PI * 2.0 / num2);
				m_StepsPerRad = num2 / (Math.PI * 2.0);
				if (delta < 0.0)
				{
					m_sin = 0.0 - m_sin;
				}
				m_destPolys.Capacity = m_polyNodes.ChildCount * 2;
				for (int j = 0; j < m_polyNodes.ChildCount; j++)
				{
					PolyNode polyNode2 = m_polyNodes.Childs[j];
					m_srcPoly = polyNode2.m_polygon;
					int count = m_srcPoly.Count;
					if (count == 0 || (delta <= 0.0 && (count < 3 || polyNode2.m_endtype != EndType.etClosedPolygon)))
					{
						continue;
					}
					m_destPoly = new List<IntPoint>();
					if (count == 1)
					{
						if (polyNode2.m_jointype == JoinType.jtRound)
						{
							double num3 = 1.0;
							double num4 = 0.0;
							for (int k = 1; (double)k <= num2; k++)
							{
								m_destPoly.Add(new IntPoint(Round((double)m_srcPoly[0].X + num3 * delta), Round((double)m_srcPoly[0].Y + num4 * delta)));
								double num5 = num3;
								num3 = num3 * m_cos - m_sin * num4;
								num4 = num5 * m_sin + num4 * m_cos;
							}
						}
						else
						{
							double num6 = -1.0;
							double num7 = -1.0;
							for (int l = 0; l < 4; l++)
							{
								m_destPoly.Add(new IntPoint(Round((double)m_srcPoly[0].X + num6 * delta), Round((double)m_srcPoly[0].Y + num7 * delta)));
								if (num6 < 0.0)
								{
									num6 = 1.0;
								}
								else if (num7 < 0.0)
								{
									num7 = 1.0;
								}
								else
								{
									num6 = -1.0;
								}
							}
						}
						m_destPolys.Add(m_destPoly);
						continue;
					}
					m_normals.Clear();
					m_normals.Capacity = count;
					for (int m = 0; m < count - 1; m++)
					{
						m_normals.Add(GetUnitNormal(m_srcPoly[m], m_srcPoly[m + 1]));
					}
					if (polyNode2.m_endtype == EndType.etClosedLine || polyNode2.m_endtype == EndType.etClosedPolygon)
					{
						m_normals.Add(GetUnitNormal(m_srcPoly[count - 1], m_srcPoly[0]));
					}
					else
					{
						m_normals.Add(new DoublePoint(m_normals[count - 2]));
					}
					if (polyNode2.m_endtype == EndType.etClosedPolygon)
					{
						int k2 = count - 1;
						for (int n = 0; n < count; n++)
						{
							OffsetPoint(n, ref k2, polyNode2.m_jointype);
						}
						m_destPolys.Add(m_destPoly);
						continue;
					}
					if (polyNode2.m_endtype == EndType.etClosedLine)
					{
						int k3 = count - 1;
						for (int num8 = 0; num8 < count; num8++)
						{
							OffsetPoint(num8, ref k3, polyNode2.m_jointype);
						}
						m_destPolys.Add(m_destPoly);
						m_destPoly = new List<IntPoint>();
						DoublePoint doublePoint = m_normals[count - 1];
						for (int num9 = count - 1; num9 > 0; num9--)
						{
							m_normals[num9] = new DoublePoint(0.0 - m_normals[num9 - 1].X, 0.0 - m_normals[num9 - 1].Y);
						}
						m_normals[0] = new DoublePoint(0.0 - doublePoint.X, 0.0 - doublePoint.Y);
						k3 = 0;
						for (int num10 = count - 1; num10 >= 0; num10--)
						{
							OffsetPoint(num10, ref k3, polyNode2.m_jointype);
						}
						m_destPolys.Add(m_destPoly);
						continue;
					}
					int k4 = 0;
					for (int num11 = 1; num11 < count - 1; num11++)
					{
						OffsetPoint(num11, ref k4, polyNode2.m_jointype);
					}
					if (polyNode2.m_endtype == EndType.etOpenButt)
					{
						int index = count - 1;
						IntPoint item = new IntPoint(Round((double)m_srcPoly[index].X + m_normals[index].X * delta), Round((double)m_srcPoly[index].Y + m_normals[index].Y * delta));
						m_destPoly.Add(item);
						item = new IntPoint(Round((double)m_srcPoly[index].X - m_normals[index].X * delta), Round((double)m_srcPoly[index].Y - m_normals[index].Y * delta));
						m_destPoly.Add(item);
					}
					else
					{
						int num12 = count - 1;
						k4 = count - 2;
						m_sinA = 0.0;
						m_normals[num12] = new DoublePoint(0.0 - m_normals[num12].X, 0.0 - m_normals[num12].Y);
						if (polyNode2.m_endtype == EndType.etOpenSquare)
						{
							DoSquare(num12, k4);
						}
						else
						{
							DoRound(num12, k4);
						}
					}
					for (int num13 = count - 1; num13 > 0; num13--)
					{
						m_normals[num13] = new DoublePoint(0.0 - m_normals[num13 - 1].X, 0.0 - m_normals[num13 - 1].Y);
					}
					m_normals[0] = new DoublePoint(0.0 - m_normals[1].X, 0.0 - m_normals[1].Y);
					k4 = count - 1;
					for (int num14 = k4 - 1; num14 > 0; num14--)
					{
						OffsetPoint(num14, ref k4, polyNode2.m_jointype);
					}
					if (polyNode2.m_endtype == EndType.etOpenButt)
					{
						IntPoint item = new IntPoint(Round((double)m_srcPoly[0].X - m_normals[0].X * delta), Round((double)m_srcPoly[0].Y - m_normals[0].Y * delta));
						m_destPoly.Add(item);
						item = new IntPoint(Round((double)m_srcPoly[0].X + m_normals[0].X * delta), Round((double)m_srcPoly[0].Y + m_normals[0].Y * delta));
						m_destPoly.Add(item);
					}
					else
					{
						k4 = 1;
						m_sinA = 0.0;
						if (polyNode2.m_endtype == EndType.etOpenSquare)
						{
							DoSquare(0, 1);
						}
						else
						{
							DoRound(0, 1);
						}
					}
					m_destPolys.Add(m_destPoly);
				}
			}

			public void Execute(ref List<List<IntPoint>> solution, double delta)
			{
				solution.Clear();
				FixOrientations();
				DoOffset(delta);
				Clipper clipper = new Clipper();
				clipper.AddPaths(m_destPolys, PolyType.ptSubject, closed: true);
				if (delta > 0.0)
				{
					clipper.Execute(ClipType.ctUnion, solution, PolyFillType.pftPositive, PolyFillType.pftPositive);
					return;
				}
				IntRect bounds = ClipperBase.GetBounds(m_destPolys);
				List<IntPoint> list = new List<IntPoint>(4);
				list.Add(new IntPoint(bounds.left - 10, bounds.bottom + 10));
				list.Add(new IntPoint(bounds.right + 10, bounds.bottom + 10));
				list.Add(new IntPoint(bounds.right + 10, bounds.top - 10));
				list.Add(new IntPoint(bounds.left - 10, bounds.top - 10));
				clipper.AddPath(list, PolyType.ptSubject, Closed: true);
				clipper.ReverseSolution = true;
				clipper.Execute(ClipType.ctUnion, solution, PolyFillType.pftNegative, PolyFillType.pftNegative);
				if (solution.Count > 0)
				{
					solution.RemoveAt(0);
				}
			}

			public void Execute(ref PolyTree solution, double delta)
			{
				solution.Clear();
				FixOrientations();
				DoOffset(delta);
				Clipper clipper = new Clipper();
				clipper.AddPaths(m_destPolys, PolyType.ptSubject, closed: true);
				if (delta > 0.0)
				{
					clipper.Execute(ClipType.ctUnion, solution, PolyFillType.pftPositive, PolyFillType.pftPositive);
					return;
				}
				IntRect bounds = ClipperBase.GetBounds(m_destPolys);
				List<IntPoint> list = new List<IntPoint>(4);
				list.Add(new IntPoint(bounds.left - 10, bounds.bottom + 10));
				list.Add(new IntPoint(bounds.right + 10, bounds.bottom + 10));
				list.Add(new IntPoint(bounds.right + 10, bounds.top - 10));
				list.Add(new IntPoint(bounds.left - 10, bounds.top - 10));
				clipper.AddPath(list, PolyType.ptSubject, Closed: true);
				clipper.ReverseSolution = true;
				clipper.Execute(ClipType.ctUnion, solution, PolyFillType.pftNegative, PolyFillType.pftNegative);
				if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)
				{
					PolyNode polyNode = solution.Childs[0];
					solution.Childs.Capacity = polyNode.ChildCount;
					solution.Childs[0] = polyNode.Childs[0];
					solution.Childs[0].m_Parent = solution;
					for (int i = 1; i < polyNode.ChildCount; i++)
					{
						solution.AddChild(polyNode.Childs[i]);
					}
				}
				else
				{
					solution.Clear();
				}
			}

			private void OffsetPoint(int j, ref int k, JoinType jointype)
			{
				m_sinA = m_normals[k].X * m_normals[j].Y - m_normals[j].X * m_normals[k].Y;
				if (Math.Abs(m_sinA * m_delta) < 1.0)
				{
					if (m_normals[k].X * m_normals[j].X + m_normals[j].Y * m_normals[k].Y > 0.0)
					{
						m_destPoly.Add(new IntPoint(Round((double)m_srcPoly[j].X + m_normals[k].X * m_delta), Round((double)m_srcPoly[j].Y + m_normals[k].Y * m_delta)));
						return;
					}
				}
				else if (m_sinA > 1.0)
				{
					m_sinA = 1.0;
				}
				else if (m_sinA < -1.0)
				{
					m_sinA = -1.0;
				}
				if (m_sinA * m_delta < 0.0)
				{
					m_destPoly.Add(new IntPoint(Round((double)m_srcPoly[j].X + m_normals[k].X * m_delta), Round((double)m_srcPoly[j].Y + m_normals[k].Y * m_delta)));
					m_destPoly.Add(m_srcPoly[j]);
					m_destPoly.Add(new IntPoint(Round((double)m_srcPoly[j].X + m_normals[j].X * m_delta), Round((double)m_srcPoly[j].Y + m_normals[j].Y * m_delta)));
				}
				else
				{
					switch (jointype)
					{
					case JoinType.jtMiter:
					{
						double num = 1.0 + (m_normals[j].X * m_normals[k].X + m_normals[j].Y * m_normals[k].Y);
						if (num >= m_miterLim)
						{
							DoMiter(j, k, num);
						}
						else
						{
							DoSquare(j, k);
						}
						break;
					}
					case JoinType.jtSquare:
						DoSquare(j, k);
						break;
					case JoinType.jtRound:
						DoRound(j, k);
						break;
					}
				}
				k = j;
			}

			internal void DoSquare(int j, int k)
			{
				double num = Math.Tan(Math.Atan2(m_sinA, m_normals[k].X * m_normals[j].X + m_normals[k].Y * m_normals[j].Y) / 4.0);
				m_destPoly.Add(new IntPoint(Round((double)m_srcPoly[j].X + m_delta * (m_normals[k].X - m_normals[k].Y * num)), Round((double)m_srcPoly[j].Y + m_delta * (m_normals[k].Y + m_normals[k].X * num))));
				m_destPoly.Add(new IntPoint(Round((double)m_srcPoly[j].X + m_delta * (m_normals[j].X + m_normals[j].Y * num)), Round((double)m_srcPoly[j].Y + m_delta * (m_normals[j].Y - m_normals[j].X * num))));
			}

			internal void DoMiter(int j, int k, double r)
			{
				double num = m_delta / r;
				m_destPoly.Add(new IntPoint(Round((double)m_srcPoly[j].X + (m_normals[k].X + m_normals[j].X) * num), Round((double)m_srcPoly[j].Y + (m_normals[k].Y + m_normals[j].Y) * num)));
			}

			internal void DoRound(int j, int k)
			{
				double value = Math.Atan2(m_sinA, m_normals[k].X * m_normals[j].X + m_normals[k].Y * m_normals[j].Y);
				int num = Math.Max((int)Round(m_StepsPerRad * Math.Abs(value)), 1);
				double num2 = m_normals[k].X;
				double num3 = m_normals[k].Y;
				for (int i = 0; i < num; i++)
				{
					m_destPoly.Add(new IntPoint(Round((double)m_srcPoly[j].X + num2 * m_delta), Round((double)m_srcPoly[j].Y + num3 * m_delta)));
					double num4 = num2;
					num2 = num2 * m_cos - m_sin * num3;
					num3 = num4 * m_sin + num3 * m_cos;
				}
				m_destPoly.Add(new IntPoint(Round((double)m_srcPoly[j].X + m_normals[j].X * m_delta), Round((double)m_srcPoly[j].Y + m_normals[j].Y * m_delta)));
			}
		}

		private class ClipperException : Exception
		{
			public ClipperException(string description)
				: base(description)
			{
			}
		}
	}
}
namespace Cinemachine.PostFX
{
	[SaveDuringPlay]
	[AddComponentMenu("")]
	public class CinemachinePostProcessing : CinemachineExtension
	{
		protected override void PostPipelineStageCallback(CinemachineVirtualCameraBase vcam, CinemachineCore.Stage stage, ref CameraState state, float deltaTime)
		{
		}
	}
	[AddComponentMenu("")]
	public class CinemachineVolumeSettings : MonoBehaviour
	{
	}
}
namespace Cinemachine.Utility
{
	public class CinemachineDebug
	{
		public delegate void OnGUIDelegate();

		private static HashSet<UnityEngine.Object> mClients;

		public static OnGUIDelegate OnGUIHandlers;

		private static List<StringBuilder> mAvailableStringBuilders;

		public static void ReleaseScreenPos(UnityEngine.Object client)
		{
			if (mClients != null && mClients.Contains(client))
			{
				mClients.Remove(client);
			}
		}

		public static Rect GetScreenPos(UnityEngine.Object client, string text, GUIStyle style)
		{
			if (mClients == null)
			{
				mClients = new HashSet<UnityEngine.Object>();
			}
			if (!mClients.Contains(client))
			{
				mClients.Add(client);
			}
			Vector2 zero = Vector2.zero;
			Vector2 size = style.CalcSize(new GUIContent(text));
			if (mClients != null)
			{
				using HashSet<UnityEngine.Object>.Enumerator enumerator = mClients.GetEnumerator();
				while (enumerator.MoveNext() && !(enumerator.Current == client))
				{
					zero.y += size.y;
				}
			}
			return new Rect(zero, size);
		}

		public static StringBuilder SBFromPool()
		{
			if (mAvailableStringBuilders == null || mAvailableStringBuilders.Count == 0)
			{
				return new StringBuilder();
			}
			StringBuilder stringBuilder = mAvailableStringBuilders[mAvailableStringBuilders.Count - 1];
			mAvailableStringBuilders.RemoveAt(mAvailableStringBuilders.Count - 1);
			stringBuilder.Length = 0;
			return stringBuilder;
		}

		public static void ReturnToPool(StringBuilder sb)
		{
			if (mAvailableStringBuilders == null)
			{
				mAvailableStringBuilders = new List<StringBuilder>();
			}
			mAvailableStringBuilders.Add(sb);
		}
	}
	internal abstract class GaussianWindow1d<T>
	{
		protected T[] mData;

		protected float[] mKernel;

		protected int mCurrentPos = -1;

		public float Sigma { get; private set; }

		public int KernelSize => mKernel.Length;

		public int BufferLength => mData.Length;

		private void GenerateKernel(float sigma, int maxKernelRadius)
		{
			int num = Math.Min(maxKernelRadius, Mathf.FloorToInt(Mathf.Abs(sigma) * 2.5f));
			mKernel = new float[2 * num + 1];
			if (num == 0)
			{
				mKernel[0] = 1f;
			}
			else
			{
				float num2 = 0f;
				for (int i = -num; i <= num; i++)
				{
					mKernel[i + num] = (float)(Math.Exp((float)(-(i * i)) / (2f * sigma * sigma)) / (Math.PI * 2.0 * (double)sigma * (double)sigma));
					num2 += mKernel[i + num];
				}
				for (int j = -num; j <= num; j++)
				{
					mKernel[j + num] /= num2;
				}
			}
			Sigma = sigma;
		}

		protected abstract T Compute(int windowPos);

		public GaussianWindow1d(float sigma, int maxKernelRadius = 10)
		{
			GenerateKernel(sigma, maxKernelRadius);
			mData = new T[KernelSize];
			mCurrentPos = -1;
		}

		public void Reset()
		{
			mCurrentPos = -1;
		}

		public bool IsEmpty()
		{
			return mCurrentPos < 0;
		}

		public void AddValue(T v)
		{
			if (mCurrentPos < 0)
			{
				for (int i = 0; i < KernelSize; i++)
				{
					mData[i] = v;
				}
				mCurrentPos = Mathf.Min(1, KernelSize - 1);
			}
			mData[mCurrentPos] = v;
			if (++mCurrentPos == KernelSize)
			{
				mCurrentPos = 0;
			}
		}

		public T Filter(T v)
		{
			if (KernelSize < 3)
			{
				return v;
			}
			AddValue(v);
			return Value();
		}

		public T Value()
		{
			return Compute(mCurrentPos);
		}

		public void SetBufferValue(int index, T value)
		{
			mData[index] = value;
		}

		public T GetBufferValue(int index)
		{
			return mData[index];
		}
	}
	internal class GaussianWindow1D_Vector3 : GaussianWindow1d<Vector3>
	{
		public GaussianWindow1D_Vector3(float sigma, int maxKernelRadius = 10)
			: base(sigma, maxKernelRadius)
		{
		}

		protected override Vector3 Compute(int windowPos)
		{
			Vector3 zero = Vector3.zero;
			for (int i = 0; i < base.KernelSize; i++)
			{
				zero += mData[windowPos] * mKernel[i];
				if (++windowPos == base.KernelSize)
				{
					windowPos = 0;
				}
			}
			return zero;
		}
	}
	internal class GaussianWindow1D_Quaternion : GaussianWindow1d<Quaternion>
	{
		public GaussianWindow1D_Quaternion(float sigma, int maxKernelRadius = 10)
			: base(sigma, maxKernelRadius)
		{
		}

		protected override Quaternion Compute(int windowPos)
		{
			Quaternion q = new Quaternion(0f, 0f, 0f, 0f);
			Quaternion quaternion = mData[mCurrentPos];
			Quaternion quaternion2 = Quaternion.Inverse(quaternion);
			for (int i = 0; i < base.KernelSize; i++)
			{
				float num = mKernel[i];
				Quaternion b = quaternion2 * mData[windowPos];
				if (Quaternion.Dot(Quaternion.identity, b) < 0f)
				{
					num = 0f - num;
				}
				q.x += b.x * num;
				q.y += b.y * num;
				q.z += b.z * num;
				q.w += b.w * num;
				if (++windowPos == base.KernelSize)
				{
					windowPos = 0;
				}
			}
			return quaternion * Quaternion.Normalize(q);
		}
	}
	internal class GaussianWindow1D_CameraRotation : GaussianWindow1d<Vector2>
	{
		public GaussianWindow1D_CameraRotation(float sigma, int maxKernelRadius = 10)
			: base(sigma, maxKernelRadius)
		{
		}

		protected override Vector2 Compute(int windowPos)
		{
			Vector2 zero = Vector2.zero;
			Vector2 vector = mData[mCurrentPos];
			for (int i = 0; i < base.KernelSize; i++)
			{
				Vector2 vector2 = mData[windowPos] - vector;
				if (vector2.y > 180f)
				{
					vector2.y -= 360f;
				}
				if (vector2.y < -180f)
				{
					vector2.y += 360f;
				}
				zero += vector2 * mKernel[i];
				if (++windowPos == base.KernelSize)
				{
					windowPos = 0;
				}
			}
			return vector + zero;
		}
	}
	public class PositionPredictor
	{
		private Vector3 m_Velocity;

		private Vector3 m_SmoothDampVelocity;

		private Vector3 m_Pos;

		private bool m_HavePos;

		public float Smoothing;

		public bool IsEmpty()
		{
			return !m_HavePos;
		}

		public void ApplyTransformDelta(Vector3 positionDelta)
		{
			m_Pos += positionDelta;
		}

		public void Reset()
		{
			m_HavePos = false;
			m_SmoothDampVelocity = Vector3.zero;
			m_Velocity = Vector3.zero;
		}

		public void AddPosition(Vector3 pos, float deltaTime, float lookaheadTime)
		{
			if (deltaTime < 0f)
			{
				Reset();
			}
			if (m_HavePos && deltaTime > 0.0001f)
			{
				Vector3 target = (pos - m_Pos) / deltaTime;
				bool flag = target.sqrMagnitude < m_Velocity.sqrMagnitude;
				m_Velocity = Vector3.SmoothDamp(m_Velocity, target, ref m_SmoothDampVelocity, Smoothing / (float)(flag ? 30 : 10), float.PositiveInfinity, deltaTime);
			}
			m_Pos = pos;
			m_HavePos = true;
		}

		public Vector3 PredictPositionDelta(float lookaheadTime)
		{
			return m_Velocity * lookaheadTime;
		}

		public Vector3 PredictPosition(float lookaheadTime)
		{
			return m_Pos + PredictPositionDelta(lookaheadTime);
		}
	}
	public static class Damper
	{
		private const float Epsilon = 0.0001f;

		public const float kNegligibleResidual = 0.01f;

		private const float kLogNegligibleResidual = -4.6051702f;

		private static float DecayConstant(float time, float residual)
		{
			return Mathf.Log(1f / residual) / time;
		}

		private static float DecayedRemainder(float initial, float decayConstant, float deltaTime)
		{
			return initial / Mathf.Exp(decayConstant * deltaTime);
		}

		public static float Damp(float initial, float dampTime, float deltaTime)
		{
			if (dampTime < 0.0001f || Mathf.Abs(initial) < 0.0001f)
			{
				return initial;
			}
			if (deltaTime < 0.0001f)
			{
				return 0f;
			}
			float num = 4.6051702f / dampTime;
			return initial * (1f - Mathf.Exp((0f - num) * deltaTime));
		}

		public static Vector3 Damp(Vector3 initial, Vector3 dampTime, float deltaTime)
		{
			for (int i = 0; i < 3; i++)
			{
				initial[i] = Damp(initial[i], dampTime[i], deltaTime);
			}
			return initial;
		}

		public static Vector3 Damp(Vector3 initial, float dampTime, float deltaTime)
		{
			for (int i = 0; i < 3; i++)
			{
				initial[i] = Damp(initial[i], dampTime, deltaTime);
			}
			return initial;
		}
	}
	public class HeadingTracker
	{
		private struct Item
		{
			public Vector3 velocity;

			public float weight;

			public float time;
		}

		private Item[] mHistory;

		private int mTop;

		private int mBottom;

		private int mCount;

		private Vector3 mHeadingSum;

		private float mWeightSum;

		private float mWeightTime;

		private Vector3 mLastGoodHeading = Vector3.zero;

		private static float mDecayExponent;

		public int FilterSize => mHistory.Length;

		public HeadingTracker(int filterSize)
		{
			mHistory = new Item[filterSize];
			float num = (float)filterSize / 5f;
			mDecayExponent = (0f - Mathf.Log(2f)) / num;
			ClearHistory();
		}

		private void ClearHistory()
		{
			mTop = (mBottom = (mCount = 0));
			mWeightSum = 0f;
			mHeadingSum = Vector3.zero;
		}

		private static float Decay(float time)
		{
			return Mathf.Exp(time * mDecayExponent);
		}

		public void Add(Vector3 velocity)
		{
			if (FilterSize == 0)
			{
				mLastGoodHeading = velocity;
				return;
			}
			float magnitude = velocity.magnitude;
			if (magnitude > 0.0001f)
			{
				Item item = new Item
				{
					velocity = velocity,
					weight = magnitude,
					time = CinemachineCore.CurrentTime
				};
				if (mCount == FilterSize)
				{
					PopBottom();
				}
				mCount++;
				mHistory[mTop] = item;
				if (++mTop == FilterSize)
				{
					mTop = 0;
				}
				mWeightSum *= Decay(item.time - mWeightTime);
				mWeightTime = item.time;
				mWeightSum += magnitude;
				mHeadingSum += item.velocity;
			}
		}

		private void PopBottom()
		{
			if (mCount > 0)
			{
				float currentTime = CinemachineCore.CurrentTime;
				Item item = mHistory[mBottom];
				if (++mBottom == FilterSize)
				{
					mBottom = 0;
				}
				mCount--;
				float num = Decay(currentTime - item.time);
				mWeightSum -= item.weight * num;
				mHeadingSum -= item.velocity * num;
				if (mWeightSum <= 0.0001f || mCount == 0)
				{
					ClearHistory();
				}
			}
		}

		public void DecayHistory()
		{
			float currentTime = CinemachineCore.CurrentTime;
			float num = Decay(currentTime - mWeightTime);
			mWeightSum *= num;
			mWeightTime = currentTime;
			if (mWeightSum < 0.0001f)
			{
				ClearHistory();
			}
			else
			{
				mHeadingSum *= num;
			}
		}

		public Vector3 GetReliableHeading()
		{
			if (mWeightSum > 0.0001f && (mCount == mHistory.Length || mLastGoodHeading.AlmostZero()))
			{
				Vector3 v = mHeadingSum / mWeightSum;
				if (!v.AlmostZero())
				{
					mLastGoodHeading = v.normalized;
				}
			}
			return mLastGoodHeading;
		}
	}
	public static class SplineHelpers
	{
		public static Vector3 Bezier3(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
		{
			t = Mathf.Clamp01(t);
			float num = 1f - t;
			return num * num * num * p0 + 3f * num * num * t * p1 + 3f * num * t * t * p2 + t * t * t * p3;
		}

		public static Vector3 BezierTangent3(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
		{
			t = Mathf.Clamp01(t);
			return (-3f * p0 + 9f * p1 - 9f * p2 + 3f * p3) * (t * t) + (6f * p0 - 12f * p1 + 6f * p2) * t - 3f * p0 + 3f * p1;
		}

		public static void BezierTangentWeights3(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, out Vector3 w0, out Vector3 w1, out Vector3 w2)
		{
			w0 = -3f * p0 + 9f * p1 - 9f * p2 + 3f * p3;
			w1 = 6f * p0 - 12f * p1 + 6f * p2;
			w2 = -3f * p0 + 3f * p1;
		}

		public static float Bezier1(float t, float p0, float p1, float p2, float p3)
		{
			t = Mathf.Clamp01(t);
			float num = 1f - t;
			return num * num * num * p0 + 3f * num * num * t * p1 + 3f * num * t * t * p2 + t * t * t * p3;
		}

		public static float BezierTangent1(float t, float p0, float p1, float p2, float p3)
		{
			t = Mathf.Clamp01(t);
			return (-3f * p0 + 9f * p1 - 9f * p2 + 3f * p3) * t * t + (6f * p0 - 12f * p1 + 6f * p2) * t - 3f * p0 + 3f * p1;
		}

		public static void ComputeSmoothControlPoints(ref Vector4[] knot, ref Vector4[] ctrl1, ref Vector4[] ctrl2)
		{
			int num = knot.Length;
			if (num <= 2)
			{
				switch (num)
				{
				case 2:
					ctrl1[0] = Vector4.Lerp(knot[0], knot[1], 0.33333f);
					ctrl2[0] = Vector4.Lerp(knot[0], knot[1], 0.66666f);
					break;
				case 1:
					ctrl1[0] = (ctrl2[0] = knot[0]);
					break;
				}
				return;
			}
			float[] array = new float[num];
			float[] array2 = new float[num];
			float[] array3 = new float[num];
			float[] array4 = new float[num];
			for (int i = 0; i < 4; i++)
			{
				int num2 = num - 1;
				array[0] = 0f;
				array2[0] = 2f;
				array3[0] = 1f;
				array4[0] = knot[0][i] + 2f * knot[1][i];
				for (int j = 1; j < num2 - 1; j++)
				{
					array[j] = 1f;
					array2[j] = 4f;
					array3[j] = 1f;
					array4[j] = 4f * knot[j][i] + 2f * knot[j + 1][i];
				}
				array[num2 - 1] = 2f;
				array2[num2 - 1] = 7f;
				array3[num2 - 1] = 0f;
				array4[num2 - 1] = 8f * knot[num2 - 1][i] + knot[num2][i];
				for (int k = 1; k < num2; k++)
				{
					float num3 = array[k] / array2[k - 1];
					array2[k] -= num3 * array3[k - 1];
					array4[k] -= num3 * array4[k - 1];
				}
				ctrl1[num2 - 1][i] = array4[num2 - 1] / array2[num2 - 1];
				for (int num4 = num2 - 2; num4 >= 0; num4--)
				{
					ctrl1[num4][i] = (array4[num4] - array3[num4] * ctrl1[num4 + 1][i]) / array2[num4];
				}
				for (int l = 0; l < num2; l++)
				{
					ctrl2[l][i] = 2f * knot[l + 1][i] - ctrl1[l + 1][i];
				}
				ctrl2[num2 - 1][i] = 0.5f * (knot[num2][i] + ctrl1[num2 - 1][i]);
			}
		}

		public static void ComputeSmoothControlPointsLooped(ref Vector4[] knot, ref Vector4[] ctrl1, ref Vector4[] ctrl2)
		{
			int num = knot.Length;
			if (num < 2)
			{
				if (num == 1)
				{
					ctrl1[0] = (ctrl2[0] = knot[0]);
				}
				return;
			}
			int num2 = Mathf.Min(4, num - 1);
			Vector4[] knot2 = new Vector4[num + 2 * num2];
			Vector4[] ctrl3 = new Vector4[num + 2 * num2];
			Vector4[] ctrl4 = new Vector4[num + 2 * num2];
			for (int i = 0; i < num2; i++)
			{
				knot2[i] = knot[num - (num2 - i)];
				knot2[num + num2 + i] = knot[i];
			}
			for (int j = 0; j < num; j++)
			{
				knot2[j + num2] = knot[j];
			}
			ComputeSmoothControlPoints(ref knot2, ref ctrl3, ref ctrl4);
			for (int k = 0; k < num; k++)
			{
				ctrl1[k] = ctrl3[k + num2];
				ctrl2[k] = ctrl4[k + num2];
			}
		}
	}
	public static class UnityVectorExtensions
	{
		public const float Epsilon = 0.0001f;

		public static bool IsNaN(this Vector2 v)
		{
			if (!float.IsNaN(v.x))
			{
				return float.IsNaN(v.y);
			}
			return true;
		}

		public static bool IsNaN(this Vector3 v)
		{
			if (!float.IsNaN(v.x) && !float.IsNaN(v.y))
			{
				return float.IsNaN(v.z);
			}
			return true;
		}

		public static float ClosestPointOnSegment(this Vector3 p, Vector3 s0, Vector3 s1)
		{
			Vector3 vector = s1 - s0;
			float num = Vector3.SqrMagnitude(vector);
			if (num < 0.0001f)
			{
				return 0f;
			}
			return Mathf.Clamp01(Vector3.Dot(p - s0, vector) / num);
		}

		public static float ClosestPointOnSegment(this Vector2 p, Vector2 s0, Vector2 s1)
		{
			Vector2 vector = s1 - s0;
			float num = Vector2.SqrMagnitude(vector);
			if (num < 0.0001f)
			{
				return 0f;
			}
			return Mathf.Clamp01(Vector2.Dot(p - s0, vector) / num);
		}

		public static Vector3 ProjectOntoPlane(this Vector3 vector, Vector3 planeNormal)
		{
			return vector - Vector3.Dot(vector, planeNormal) * planeNormal;
		}

		public static Vector2 SquareNormalize(this Vector2 v)
		{
			float num = Mathf.Max(Mathf.Abs(v.x), Mathf.Abs(v.y));
			if (!(num < 0.0001f))
			{
				return v / num;
			}
			return Vector2.zero;
		}

		public static int FindIntersection(in Vector2 p1, in Vector2 p2, in Vector2 q1, in Vector2 q2, out Vector2 intersection)
		{
			Vector2 vector = p2 - p1;
			Vector2 vector2 = q2 - q1;
			Vector2 vector3 = q1 - p1;
			float num = vector.Cross(vector2);
			if (Mathf.Abs(num) < 1E-05f)
			{
				intersection = Vector2.positiveInfinity;
				if (Mathf.Abs(vector3.Cross(vector)) < 1E-05f)
				{
					float num2 = Vector2.Dot(vector2, vector);
					if (num2 > 0f && (p1 - q2).sqrMagnitude < 0.001f)
					{
						intersection = q2;
						return 4;
					}
					if (num2 < 0f && (p2 - q2).sqrMagnitude < 0.001f)
					{
						intersection = p2;
						return 4;
					}
					float num3 = Vector2.Dot(vector3, vector);
					if (0f <= num3 && num3 <= Vector2.Dot(vector, vector))
					{
						if (num3 < 0.0001f)
						{
							if (num2 <= 0f && (p1 - q1).sqrMagnitude < 0.001f)
							{
								intersection = p1;
							}
						}
						else if (num2 > 0f && (p2 - q1).sqrMagnitude < 0.001f)
						{
							intersection = p2;
						}
						return 4;
					}
					num3 = Vector2.Dot(p1 - q1, vector2);
					if (0f <= num3 && num3 <= Vector2.Dot(vector2, vector2))
					{
						return 4;
					}
					return 3;
				}
				return 0;
			}
			float num4 = vector3.Cross(vector2) / num;
			intersection = p1 + num4 * vector;
			float num5 = vector3.Cross(vector) / num;
			if (0f <= num4 && num4 <= 1f && 0f <= num5 && num5 <= 1f)
			{
				return 2;
			}
			return 1;
		}

		private static float Cross(this Vector2 v1, Vector2 v2)
		{
			return v1.x * v2.y - v1.y * v2.x;
		}

		public static Vector2 Abs(this Vector2 v)
		{
			return new Vector2(Mathf.Abs(v.x), Mathf.Abs(v.y));
		}

		public static Vector3 Abs(this Vector3 v)
		{
			return new Vector3(Mathf.Abs(v.x), Mathf.Abs(v.y), Mathf.Abs(v.z));
		}

		public static bool IsUniform(this Vector2 v)
		{
			return Math.Abs(v.x - v.y) < 0.0001f;
		}

		public static bool IsUniform(this Vector3 v)
		{
			if (Math.Abs(v.x - v.y) < 0.0001f)
			{
				return Math.Abs(v.x - v.z) < 0.0001f;
			}
			return false;
		}

		public static bool AlmostZero(this Vector3 v)
		{
			return v.sqrMagnitude < 9.999999E-09f;
		}

		internal static void ConservativeSetPositionAndRotation(this Transform t, Vector3 pos, Quaternion rot)
		{
			if (!t.position.Equals(pos) || !t.rotation.Equals(rot))
			{
				t.SetPositionAndRotation(pos, rot);
			}
		}

		public static float Angle(Vector3 v1, Vector3 v2)
		{
			v1.Normalize();
			v2.Normalize();
			return Mathf.Atan2((v1 - v2).magnitude, (v1 + v2).magnitude) * 57.29578f * 2f;
		}

		public static float SignedAngle(Vector3 v1, Vector3 v2, Vector3 up)
		{
			float num = Angle(v1, v2);
			if (Mathf.Sign(Vector3.Dot(up, Vector3.Cross(v1, v2))) < 0f)
			{
				return 0f - num;
			}
			return num;
		}

		public static Quaternion SafeFromToRotation(Vector3 v1, Vector3 v2, Vector3 up)
		{
			Vector3 vector = Vector3.Cross(v1, v2);
			if (vector.AlmostZero())
			{
				vector = up;
			}
			return Quaternion.AngleAxis(Angle(v1, v2), vector);
		}

		public static Vector3 SlerpWithReferenceUp(Vector3 vA, Vector3 vB, float t, Vector3 up)
		{
			float magnitude = vA.magnitude;
			float magnitude2 = vB.magnitude;
			if (magnitude < 0.0001f || magnitude2 < 0.0001f)
			{
				return Vector3.Lerp(vA, vB, t);
			}
			Vector3 forward = vA / magnitude;
			Vector3 forward2 = vB / magnitude2;
			Quaternion qA = Quaternion.LookRotation(forward, up);
			Quaternion qB = Quaternion.LookRotation(forward2, up);
			return UnityQuaternionExtensions.SlerpWithReferenceUp(qA, qB, t, up) * Vector3.forward * Mathf.Lerp(magnitude, magnitude2, t);
		}
	}
	public static class UnityQuaternionExtensions
	{
		public static Quaternion SlerpWithReferenceUp(Quaternion qA, Quaternion qB, float t, Vector3 up)
		{
			Vector3 vector = (qA * Vector3.forward).ProjectOntoPlane(up);
			Vector3 v = (qB * Vector3.forward).ProjectOntoPlane(up);
			if (vector.AlmostZero() || v.AlmostZero())
			{
				return Quaternion.Slerp(qA, qB, t);
			}
			Quaternion quaternion = Quaternion.LookRotation(vector, up);
			Quaternion quaternion2 = Quaternion.Inverse(quaternion);
			Quaternion quaternion3 = quaternion2 * qA;
			Quaternion quaternion4 = quaternion2 * qB;
			Vector3 eulerAngles = quaternion3.eulerAngles;
			Vector3 eulerAngles2 = quaternion4.eulerAngles;
			return quaternion * Quaternion.Euler(Mathf.LerpAngle(eulerAngles.x, eulerAngles2.x, t), Mathf.LerpAngle(eulerAngles.y, eulerAngles2.y, t), Mathf.LerpAngle(eulerAngles.z, eulerAngles2.z, t));
		}

		public static Quaternion Normalized(this Quaternion q)
		{
			Vector4 normalized = new Vector4(q.x, q.y, q.z, q.w).normalized;
			return new Quaternion(normalized.x, normalized.y, normalized.z, normalized.w);
		}

		public static Vector2 GetCameraRotationToTarget(this Quaternion orient, Vector3 lookAtDir, Vector3 worldUp)
		{
			if (lookAtDir.AlmostZero())
			{
				return Vector2.zero;
			}
			Quaternion quaternion = Quaternion.Inverse(orient);
			Vector3 vector = quaternion * worldUp;
			lookAtDir = quaternion * lookAtDir;
			float num = 0f;
			Vector3 vector2 = lookAtDir.ProjectOntoPlane(vector);
			if (!vector2.AlmostZero())
			{
				Vector3 vector3 = Vector3.forward.ProjectOntoPlane(vector);
				if (vector3.AlmostZero())
				{
					vector3 = ((!(Vector3.Dot(vector3, vector) > 0f)) ? Vector3.up.ProjectOntoPlane(vector) : Vector3.down.ProjectOntoPlane(vector));
				}
				num = UnityVectorExtensions.SignedAngle(vector3, vector2, vector);
			}
			Quaternion quaternion2 = Quaternion.AngleAxis(num, vector);
			return new Vector2(UnityVectorExtensions.SignedAngle(quaternion2 * Vector3.forward, lookAtDir, quaternion2 * Vector3.right), num);
		}

		public static Quaternion ApplyCameraRotation(this Quaternion orient, Vector2 rot, Vector3 worldUp)
		{
			if (rot.sqrMagnitude < 0.0001f)
			{
				return orient;
			}
			Quaternion quaternion = Quaternion.AngleAxis(rot.x, Vector3.right);
			return Quaternion.AngleAxis(rot.y, worldUp) * orient * quaternion;
		}
	}
	public static class UnityRectExtensions
	{
		public static Rect Inflated(this Rect r, Vector2 delta)
		{
			return new Rect(r.xMin - delta.x, r.yMin - delta.y, r.width + delta.x * 2f, r.height + delta.y * 2f);
		}
	}
}
