using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.ComponentModel.Design.Serialization;
using System.Diagnostics;
using System.Drawing.Design;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Drawing.Internal;
using System.Drawing.Text;
using System.Globalization;
using System.IO;
using System.Internal;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Runtime.Serialization;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using Unity;

[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyTitle("System.Drawing.dll")]
[assembly: AssemblyDescription("System.Drawing.dll")]
[assembly: AssemblyDefaultAlias("System.Drawing.dll")]
[assembly: AssemblyCompany("Mono development team")]
[assembly: AssemblyProduct("Mono Common Language Infrastructure")]
[assembly: AssemblyCopyright("(c) Various Mono authors")]
[assembly: SatelliteContractVersion("4.0.0.0")]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: ComVisible(false)]
[assembly: ComCompatibleVersion(1, 0, 3300, 0)]
[assembly: AllowPartiallyTrustedCallers]
[assembly: CLSCompliant(true)]
[assembly: AssemblyDelaySign(true)]
[assembly: AssemblyFileVersion("4.6.57.0")]
[assembly: CompilationRelaxations(CompilationRelaxations.NoStringInterning)]
[assembly: AssemblyInformationalVersion("4.6.57.0")]
[assembly: Dependency("System,", LoadHint.Always)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("4.0.0.0")]
[module: UnverifiableCode]
internal static class Consts
{
	public const string MonoVersion = "5.11.0.0";

	public const string MonoCompany = "Mono development team";

	public const string MonoProduct = "Mono Common Language Infrastructure";

	public const string MonoCopyright = "(c) Various Mono authors";

	public const int MonoCorlibVersion = 1051100001;

	public const string FxVersion = "4.0.0.0";

	public const string FxFileVersion = "4.6.57.0";

	public const string EnvironmentVersion = "4.0.30319.42000";

	public const string VsVersion = "0.0.0.0";

	public const string VsFileVersion = "11.0.0.0";

	private const string PublicKeyToken = "b77a5c561934e089";

	public const string AssemblyI18N = "I18N, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMicrosoft_JScript = "Microsoft.JScript, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblyMicrosoft_VisualStudio = "Microsoft.VisualStudio, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblyMicrosoft_VisualStudio_Web = "Microsoft.VisualStudio.Web, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblyMicrosoft_VSDesigner = "Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblyMono_Http = "Mono.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMono_Posix = "Mono.Posix, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMono_Security = "Mono.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMono_Messaging_RabbitMQ = "Mono.Messaging.RabbitMQ, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyCorlib = "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem = "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem_Data = "System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem_Design = "System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_DirectoryServices = "System.DirectoryServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Drawing = "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Drawing_Design = "System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Messaging = "System.Messaging, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Security = "System.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_ServiceProcess = "System.ServiceProcess, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Web = "System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Windows_Forms = "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem_2_0 = "System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystemCore_3_5 = "System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem_Core = "System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string WindowsBase_3_0 = "WindowsBase, Version=3.0.0.0, PublicKeyToken=31bf3856ad364e35";

	public const string AssemblyWindowsBase = "WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	public const string AssemblyPresentationCore_3_5 = "PresentationCore, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	public const string AssemblyPresentationCore_4_0 = "PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	public const string AssemblyPresentationFramework_3_5 = "PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	public const string AssemblySystemServiceModel_3_0 = "System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
}
internal sealed class Locale
{
	private Locale()
	{
	}

	public static string GetText(string msg)
	{
		return msg;
	}

	public static string GetText(string fmt, params object[] args)
	{
		return string.Format(fmt, args);
	}
}
internal class SR
{
	public const string CantTellPrinterName = "(printer name protected due to security restrictions)";

	public const string CantChangeImmutableObjects = "Changes cannot be made to {0} because permissions are not valid.";

	public const string CantMakeIconTransparent = "Bitmaps that are icons cannot be made transparent. Icons natively support transparency. Use the Icon constructor to create an icon.";

	public const string ColorNotSystemColor = "The color {0} is not a system color.";

	public const string DotNET_ComponentType = ".NET Component";

	public const string GdiplusAborted = "Function was ended.";

	public const string GdiplusAccessDenied = "File access is denied.";

	public const string GdiplusCannotCreateGraphicsFromIndexedPixelFormat = "A Graphics object cannot be created from an image that has an indexed pixel format.";

	public const string GdiplusCannotSetPixelFromIndexedPixelFormat = "SetPixel is not supported for images with indexed pixel formats.";

	public const string GdiplusDestPointsInvalidParallelogram = "Destination points define a parallelogram which must have a length of 3. These points will represent the upper-left, upper-right, and lower-left coordinates (defined in that order).";

	public const string GdiplusDestPointsInvalidLength = "Destination points must be an array with a length of 3 or 4. A length of 3 defines a parallelogram with the upper-left, upper-right, and lower-left corners. A length of 4 defines a quadrilateral with the fourth element of the array specifying the lower-right coordinate.";

	public const string GdiplusFileNotFound = "File not found.";

	public const string GdiplusFontFamilyNotFound = "Font '{0}' cannot be found.";

	public const string GdiplusFontStyleNotFound = "Font '{0}' does not support style '{1}'.";

	public const string GdiplusGenericError = "A generic error occurred in GDI+.";

	public const string GdiplusInsufficientBuffer = "Buffer is too small (internal GDI+ error).";

	public const string GdiplusInvalidParameter = "Parameter is not valid.";

	public const string GdiplusInvalidRectangle = "Rectangle '{0}' cannot have a width or height equal to 0.";

	public const string GdiplusInvalidSize = "Operation requires a transformation of the image from GDI+ to GDI. GDI does not support images with a width or height greater than 32767.";

	public const string GdiplusOutOfMemory = "Out of memory.";

	public const string GdiplusNotImplemented = "Not implemented.";

	public const string GdiplusNotInitialized = "GDI+ is not properly initialized (internal GDI+ error).";

	public const string GdiplusNotTrueTypeFont = "Only TrueType fonts are supported. '{0}' is not a TrueType font.";

	public const string GdiplusNotTrueTypeFont_NoName = "Only TrueType fonts are supported. This is not a TrueType font.";

	public const string GdiplusObjectBusy = "Object is currently in use elsewhere.";

	public const string GdiplusOverflow = "Overflow error.";

	public const string GdiplusPropertyNotFoundError = "Property cannot be found.";

	public const string GdiplusPropertyNotSupportedError = "Property is not supported.";

	public const string GdiplusUnknown = "Unknown GDI+ error occurred.";

	public const string GdiplusUnknownImageFormat = "Image format is unknown.";

	public const string GdiplusUnsupportedGdiplusVersion = "Current version of GDI+ does not support this feature.";

	public const string GdiplusWrongState = "Bitmap region is already locked.";

	public const string GlobalAssemblyCache = " (Global Assembly Cache)";

	public const string GraphicsBufferCurrentlyBusy = "BufferedGraphicsContext cannot be disposed of because a buffer operation is currently in progress.";

	public const string GraphicsBufferQueryFail = "Screen-compatible bitmap cannot be created. The screen bitmap format cannot be determined.";

	public const string ToolboxItemLocked = "Toolbox item cannot be modified.";

	public const string ToolboxItemInvalidPropertyType = "Property {0} requires an argument of type {1}.";

	public const string ToolboxItemValueNotSerializable = "Data type {0} is not serializable. Items added to a property dictionary must be serializable.";

	public const string ToolboxItemInvalidKey = "Argument should be a non-empty string.";

	public const string IllegalState = "Internal state of the {0} class is invalid.";

	public const string InterpolationColorsColorBlendNotSet = "Property must be set to a valid ColorBlend object to use interpolation colors.";

	public const string InterpolationColorsCommon = "{0}{1} ColorBlend objects must be constructed with the same number of positions and color values. Positions must be between 0.0 and 1.0, 1.0 indicating the last element in the array.";

	public const string InterpolationColorsInvalidColorBlendObject = "ColorBlend object that was set is not valid.";

	public const string InterpolationColorsInvalidStartPosition = "Position's first element must be equal to 0.";

	public const string InterpolationColorsInvalidEndPosition = "Position's last element must be equal to 1.0.";

	public const string InterpolationColorsLength = "Array of colors and positions must contain at least two elements.";

	public const string InterpolationColorsLengthsDiffer = "Colors and positions do not have the same number of elements.";

	public const string InvalidArgument = "Value of '{1}' is not valid for '{0}'.";

	public const string InvalidBoundArgument = "Value of '{1}' is not valid for '{0}'. '{0}' should be greater than {2} and less than or equal to {3}.";

	public const string InvalidClassName = "Class name is not valid.";

	public const string InvalidColor = "Color '{0}' is not valid.";

	public const string InvalidDashPattern = "DashPattern value is not valid.";

	public const string InvalidEx2BoundArgument = "Value of '{1}' is not valid for '{0}'. '{0}' should be greater than or equal to {2} and less than or equal to {3}.";

	public const string InvalidFrame = "Frame is not valid. Frame must be between 0 and FrameCount.";

	public const string InvalidGDIHandle = "Win32 handle that was passed to {0} is not valid or is the wrong type.";

	public const string InvalidImage = "Image type is unknown.";

	public const string InvalidLowBoundArgumentEx = "Value of '{1}' is not valid for '{0}'. '{0}' must be greater than or equal to {2}.";

	public const string InvalidPermissionLevel = "Permission level is not valid.";

	public const string InvalidPermissionState = "Permission state is not valid.";

	public const string InvalidPictureType = "Argument '{0}' must be a picture that can be used as a {1}.";

	public const string InvalidPrinterException_InvalidPrinter = "Settings to access printer '{0}' are not valid.";

	public const string InvalidPrinterException_NoDefaultPrinter = "No printers are installed.";

	public const string InvalidPrinterHandle = "Handle {0} is not valid.";

	public const string ValidRangeX = "Parameter must be positive and < Width.";

	public const string ValidRangeY = "Parameter must be positive and < Height.";

	public const string NativeHandle0 = "Native handle is 0.";

	public const string NoDefaultPrinter = "Default printer is not set.";

	public const string NotImplemented = "Not implemented.";

	public const string PDOCbeginPrintDescr = "Occurs when the document is about to be printed.";

	public const string PDOCdocumentNameDescr = "The name of the document shown to the user.";

	public const string PDOCdocumentPageSettingsDescr = "The page settings of the page currently being printed.";

	public const string PDOCendPrintDescr = "Occurs after the document has been printed.";

	public const string PDOCoriginAtMarginsDescr = "Indicates that the graphics origin is located at the user-specified page margins.";

	public const string PDOCprintControllerDescr = "Retrieves the print controller for this document.";

	public const string PDOCprintPageDescr = "Occurs once for each page to be printed.";

	public const string PDOCprinterSettingsDescr = "Retrieves the settings for the printer the document is currently being printed to.";

	public const string PDOCqueryPageSettingsDescr = "Occurs before each page is printed.  Useful for changing PageSettings for a particular page.";

	public const string PrintDocumentDesc = "Defines an object that sends output to a printer.";

	public const string PrintingPermissionBadXml = "XML is not valid.";

	public const string PrintingPermissionAttributeInvalidPermissionLevel = "Permission level must be between PrintingPermissionLevel.NoPrinting and PrintingPermissionLevel.AllPrinting.";

	public const string PropertyValueInvalidEntry = "IDictionary parameter contains at least one entry that is not valid. Ensure all values are consistent with the object's properties.";

	public const string PSizeNotCustom = "PaperSize cannot be changed unless the Kind property is set to Custom.";

	public const string ResourceNotFound = "Resource '{1}' cannot be found in class '{0}'.";

	public const string TargetNotPrintingPermission = "Target does not have permission to print.";

	public const string TextParseFailedFormat = "Text \"{0}\" cannot be parsed. The expected text format is \"{1}\".";

	public const string TriStateCompareError = "TriState.Default cannot be converted into a Boolean.";

	public const string toStringIcon = "(Icon)";

	public const string toStringNone = "(none)";

	public const string DCTypeInvalid = "GetObjectType on this dc returned an invalid value.";

	public const string InvalidEnumArgument = "The value of argument '{0}' ({1}) is invalid for Enum type '{2}'.";

	public const string ConvertInvalidPrimitive = "{0} is not a valid value for {1}.";

	public const string LibgdiplusNotFound = "The native library \"libgdiplus\" is not installed on the system, or was otherwise unable to be loaded.";

	public static string Format(string format, params object[] args)
	{
		return string.Format(format, args);
	}
}
namespace System
{
	[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
	internal class MonoTODOAttribute : Attribute
	{
		private string comment;

		public string Comment => comment;

		public MonoTODOAttribute()
		{
		}

		public MonoTODOAttribute(string comment)
		{
			this.comment = comment;
		}
	}
	[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
	internal class MonoDocumentationNoteAttribute : System.MonoTODOAttribute
	{
		public MonoDocumentationNoteAttribute(string comment)
			: base(comment)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
	internal class MonoExtensionAttribute : System.MonoTODOAttribute
	{
		public MonoExtensionAttribute(string comment)
			: base(comment)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
	internal class MonoInternalNoteAttribute : System.MonoTODOAttribute
	{
		public MonoInternalNoteAttribute(string comment)
			: base(comment)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
	internal class MonoLimitationAttribute : System.MonoTODOAttribute
	{
		public MonoLimitationAttribute(string comment)
			: base(comment)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
	internal class MonoNotSupportedAttribute : System.MonoTODOAttribute
	{
		public MonoNotSupportedAttribute(string comment)
			: base(comment)
		{
		}
	}
}
namespace System.Internal
{
	internal sealed class HandleCollector
	{
		private class HandleType
		{
			internal readonly string name;

			private int _initialThreshHold;

			private int _threshHold;

			private int _handleCount;

			private readonly int _deltaPercent;

			internal HandleType(string name, int expense, int initialThreshHold)
			{
				this.name = name;
				_initialThreshHold = initialThreshHold;
				_threshHold = initialThreshHold;
				_deltaPercent = 100 - expense;
			}

			internal void Add(IntPtr handle)
			{
				if (!(handle == IntPtr.Zero))
				{
					bool flag = false;
					int currentHandleCount = 0;
					lock (this)
					{
						_handleCount++;
						flag = NeedCollection();
						currentHandleCount = _handleCount;
					}
					lock (s_internalSyncObject)
					{
						HandleCollector.HandleAdded?.Invoke(name, handle, currentHandleCount);
					}
					if (flag && flag)
					{
						GC.Collect();
						Thread.Sleep((100 - _deltaPercent) / 4);
					}
				}
			}

			internal bool NeedCollection()
			{
				if (_handleCount > _threshHold)
				{
					_threshHold = _handleCount + _handleCount * _deltaPercent / 100;
					return true;
				}
				int num = 100 * _threshHold / (100 + _deltaPercent);
				if (num >= _initialThreshHold && _handleCount < (int)((float)num * 0.9f))
				{
					_threshHold = num;
				}
				return false;
			}

			internal IntPtr Remove(IntPtr handle)
			{
				if (handle == IntPtr.Zero)
				{
					return handle;
				}
				int currentHandleCount = 0;
				lock (this)
				{
					_handleCount--;
					if (_handleCount < 0)
					{
						_handleCount = 0;
					}
					currentHandleCount = _handleCount;
				}
				lock (s_internalSyncObject)
				{
					HandleCollector.HandleRemoved?.Invoke(name, handle, currentHandleCount);
				}
				return handle;
			}
		}

		private static HandleType[] s_handleTypes;

		private static int s_handleTypeCount;

		private static object s_internalSyncObject = new object();

		internal static event HandleChangeEventHandler HandleAdded;

		internal static event HandleChangeEventHandler HandleRemoved;

		internal static IntPtr Add(IntPtr handle, int type)
		{
			s_handleTypes[type - 1].Add(handle);
			return handle;
		}

		internal static int RegisterType(string typeName, int expense, int initialThreshold)
		{
			lock (s_internalSyncObject)
			{
				if (s_handleTypeCount == 0 || s_handleTypeCount == s_handleTypes.Length)
				{
					HandleType[] destinationArray = new HandleType[s_handleTypeCount + 10];
					if (s_handleTypes != null)
					{
						Array.Copy(s_handleTypes, 0, destinationArray, 0, s_handleTypeCount);
					}
					s_handleTypes = destinationArray;
				}
				s_handleTypes[s_handleTypeCount++] = new HandleType(typeName, expense, initialThreshold);
				return s_handleTypeCount;
			}
		}

		internal static IntPtr Remove(IntPtr handle, int type)
		{
			return s_handleTypes[type - 1].Remove(handle);
		}
	}
	internal delegate void HandleChangeEventHandler(string handleType, IntPtr handleValue, int currentHandleCount);
}
namespace System.Drawing
{
	internal static class ColorTable
	{
		private static readonly Lazy<Dictionary<string, Color>> s_colorConstants = new Lazy<Dictionary<string, Color>>(GetColors);

		internal static Dictionary<string, Color> Colors => s_colorConstants.Value;

		private static Dictionary<string, Color> GetColors()
		{
			Dictionary<string, Color> dictionary = new Dictionary<string, Color>(StringComparer.OrdinalIgnoreCase);
			FillConstants(dictionary, typeof(Color));
			return dictionary;
		}

		private static void FillConstants(Dictionary<string, Color> colors, Type enumType)
		{
			PropertyInfo[] properties = enumType.GetProperties();
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (propertyInfo.PropertyType == typeof(Color))
				{
					colors[propertyInfo.Name] = (Color)propertyInfo.GetValue(null, null);
				}
			}
		}

		internal static bool TryGetNamedColor(string name, out Color result)
		{
			return Colors.TryGetValue(name, out result);
		}

		internal static bool IsKnownNamedColor(string name)
		{
			Color value;
			return Colors.TryGetValue(name, out value);
		}
	}
	internal static class ColorUtil
	{
		public static Color FromKnownColor(KnownColor color)
		{
			return Color.FromKnownColor(color);
		}

		public static bool IsSystemColor(this Color color)
		{
			return color.IsSystemColor;
		}
	}
	internal static class AssemblyRef
	{
		public const string SystemDrawingDesign = "System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

		public const string SystemDesign = "System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

		public const string SystemWindowsForms = "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
	}
	/// <summary>Specifies that, when interpreting <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> declarations, the assembly should look for the indicated resources in the same assembly, but with the <see cref="P:System.Drawing.Configuration.SystemDrawingSection.BitmapSuffix" /> configuration value appended to the declared file name.</summary>
	[AttributeUsage(AttributeTargets.Assembly)]
	public class BitmapSuffixInSameAssemblyAttribute : Attribute
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.BitmapSuffixInSameAssemblyAttribute" /> class.</summary>
		public BitmapSuffixInSameAssemblyAttribute()
		{
		}
	}
	/// <summary>Specifies that, when interpreting <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> declarations, the assembly should look for the indicated resources in a satellite assembly, but with the <see cref="P:System.Drawing.Configuration.SystemDrawingSection.BitmapSuffix" /> configuration value appended to the declared file name.</summary>
	[AttributeUsage(AttributeTargets.Assembly)]
	public class BitmapSuffixInSatelliteAssemblyAttribute : Attribute
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.BitmapSuffixInSatelliteAssemblyAttribute" /> class.</summary>
		public BitmapSuffixInSatelliteAssemblyAttribute()
		{
		}
	}
	/// <summary>Defines objects used to fill the interiors of graphical shapes such as rectangles, ellipses, pies, polygons, and paths.</summary>
	public abstract class Brush : MarshalByRefObject, ICloneable, IDisposable
	{
		private IntPtr _nativeBrush;

		[Browsable(false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		internal IntPtr NativeBrush => _nativeBrush;

		/// <summary>When overridden in a derived class, creates an exact copy of this <see cref="T:System.Drawing.Brush" />.</summary>
		/// <returns>The new <see cref="T:System.Drawing.Brush" /> that this method creates.</returns>
		public abstract object Clone();

		/// <summary>In a derived class, sets a reference to a GDI+ brush object.</summary>
		/// <param name="brush">A pointer to the GDI+ brush object.</param>
		protected internal void SetNativeBrush(IntPtr brush)
		{
			SetNativeBrushInternal(brush);
		}

		internal void SetNativeBrushInternal(IntPtr brush)
		{
			_nativeBrush = brush;
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Brush" /> object.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		/// <summary>Releases the unmanaged resources used by the <see cref="T:System.Drawing.Brush" /> and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///   <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		protected virtual void Dispose(bool disposing)
		{
			if (!(_nativeBrush != IntPtr.Zero))
			{
				return;
			}
			try
			{
				GDIPlus.GdipDeleteBrush(new HandleRef(this, _nativeBrush));
			}
			catch (Exception ex) when (!ClientUtils.IsSecurityOrCriticalException(ex))
			{
			}
			finally
			{
				_nativeBrush = IntPtr.Zero;
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Brush()
		{
			Dispose(disposing: false);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Brush" /> class.</summary>
		protected Brush()
		{
		}
	}
	internal static class ClientUtils
	{
		internal class WeakRefCollection : IList, ICollection, IEnumerable
		{
			internal class WeakRefObject
			{
				private int _hash;

				private WeakReference _weakHolder;

				internal bool IsAlive => _weakHolder.IsAlive;

				internal object Target => _weakHolder.Target;

				internal WeakRefObject(object obj)
				{
					_weakHolder = new WeakReference(obj);
					_hash = obj.GetHashCode();
				}

				public override int GetHashCode()
				{
					return _hash;
				}

				public override bool Equals(object obj)
				{
					WeakRefObject weakRefObject = obj as WeakRefObject;
					if (weakRefObject == this)
					{
						return true;
					}
					if (weakRefObject == null)
					{
						return false;
					}
					if (weakRefObject.Target != Target && (Target == null || !Target.Equals(weakRefObject.Target)))
					{
						return false;
					}
					return true;
				}
			}

			internal ArrayList InnerList { get; }

			public int RefCheckThreshold { get; set; } = int.MaxValue;

			public object this[int index]
			{
				get
				{
					if (InnerList[index] is WeakRefObject { IsAlive: not false } weakRefObject)
					{
						return weakRefObject.Target;
					}
					return null;
				}
				set
				{
					InnerList[index] = CreateWeakRefObject(value);
				}
			}

			public bool IsFixedSize => InnerList.IsFixedSize;

			public int Count => InnerList.Count;

			object ICollection.SyncRoot => InnerList.SyncRoot;

			public bool IsReadOnly => InnerList.IsReadOnly;

			bool ICollection.IsSynchronized => InnerList.IsSynchronized;

			internal WeakRefCollection()
				: this(4)
			{
			}

			internal WeakRefCollection(int size)
			{
				InnerList = new ArrayList(size);
			}

			public void ScavengeReferences()
			{
				int num = 0;
				int count = Count;
				for (int i = 0; i < count; i++)
				{
					if (this[num] == null)
					{
						InnerList.RemoveAt(num);
					}
					else
					{
						num++;
					}
				}
			}

			public override bool Equals(object obj)
			{
				if (!(obj is WeakRefCollection weakRefCollection))
				{
					return true;
				}
				if (weakRefCollection == null || Count != weakRefCollection.Count)
				{
					return false;
				}
				for (int i = 0; i < Count; i++)
				{
					if (InnerList[i] != weakRefCollection.InnerList[i] && (InnerList[i] == null || !InnerList[i].Equals(weakRefCollection.InnerList[i])))
					{
						return false;
					}
				}
				return true;
			}

			public override int GetHashCode()
			{
				return base.GetHashCode();
			}

			private WeakRefObject CreateWeakRefObject(object value)
			{
				if (value == null)
				{
					return null;
				}
				return new WeakRefObject(value);
			}

			private static void Copy(WeakRefCollection sourceList, int sourceIndex, WeakRefCollection destinationList, int destinationIndex, int length)
			{
				if (sourceIndex < destinationIndex)
				{
					sourceIndex += length;
					destinationIndex += length;
					while (length > 0)
					{
						destinationList.InnerList[--destinationIndex] = sourceList.InnerList[--sourceIndex];
						length--;
					}
				}
				else
				{
					while (length > 0)
					{
						destinationList.InnerList[destinationIndex++] = sourceList.InnerList[sourceIndex++];
						length--;
					}
				}
			}

			public void RemoveByHashCode(object value)
			{
				if (value == null)
				{
					return;
				}
				int hashCode = value.GetHashCode();
				for (int i = 0; i < InnerList.Count; i++)
				{
					if (InnerList[i] != null && InnerList[i].GetHashCode() == hashCode)
					{
						RemoveAt(i);
						break;
					}
				}
			}

			public void Clear()
			{
				InnerList.Clear();
			}

			public bool Contains(object value)
			{
				return InnerList.Contains(CreateWeakRefObject(value));
			}

			public void RemoveAt(int index)
			{
				InnerList.RemoveAt(index);
			}

			public void Remove(object value)
			{
				InnerList.Remove(CreateWeakRefObject(value));
			}

			public int IndexOf(object value)
			{
				return InnerList.IndexOf(CreateWeakRefObject(value));
			}

			public void Insert(int index, object value)
			{
				InnerList.Insert(index, CreateWeakRefObject(value));
			}

			public int Add(object value)
			{
				if (Count > RefCheckThreshold)
				{
					ScavengeReferences();
				}
				return InnerList.Add(CreateWeakRefObject(value));
			}

			public void CopyTo(Array array, int index)
			{
				InnerList.CopyTo(array, index);
			}

			public IEnumerator GetEnumerator()
			{
				return InnerList.GetEnumerator();
			}
		}

		public static bool IsCriticalException(Exception ex)
		{
			if (!(ex is NullReferenceException) && !(ex is StackOverflowException) && !(ex is OutOfMemoryException) && !(ex is ThreadAbortException) && !(ex is ExecutionEngineException) && !(ex is IndexOutOfRangeException))
			{
				return ex is AccessViolationException;
			}
			return true;
		}

		public static bool IsSecurityOrCriticalException(Exception ex)
		{
			if (!(ex is SecurityException))
			{
				return IsCriticalException(ex);
			}
			return true;
		}
	}
	/// <summary>Specifies style information applied to text.</summary>
	[Flags]
	public enum FontStyle
	{
		/// <summary>Normal text.</summary>
		Regular = 0,
		/// <summary>Bold text.</summary>
		Bold = 1,
		/// <summary>Italic text.</summary>
		Italic = 2,
		/// <summary>Underlined text.</summary>
		Underline = 4,
		/// <summary>Text with a line through the middle.</summary>
		Strikeout = 8
	}
	[SuppressUnmanagedCodeSecurity]
	internal class SafeNativeMethods
	{
		[SuppressUnmanagedCodeSecurity]
		internal class Gdip : GDIPlus
		{
			private static readonly TraceSwitch s_gdiPlusInitialization;

			private static IntPtr s_initToken;

			private const string ThreadDataSlotName = "system.drawing.threaddata";

			internal const int Ok = 0;

			internal const int GenericError = 1;

			internal const int InvalidParameter = 2;

			internal const int OutOfMemory = 3;

			internal const int ObjectBusy = 4;

			internal const int InsufficientBuffer = 5;

			internal const int NotImplemented = 6;

			internal const int Win32Error = 7;

			internal const int WrongState = 8;

			internal const int Aborted = 9;

			internal const int FileNotFound = 10;

			internal const int ValueOverflow = 11;

			internal const int AccessDenied = 12;

			internal const int UnknownImageFormat = 13;

			internal const int FontFamilyNotFound = 14;

			internal const int FontStyleNotFound = 15;

			internal const int NotTrueTypeFont = 16;

			internal const int UnsupportedGdiplusVersion = 17;

			internal const int GdiplusNotInitialized = 18;

			internal const int PropertyNotFound = 19;

			internal const int PropertyNotSupported = 20;

			private static bool Initialized => s_initToken != IntPtr.Zero;

			internal static IDictionary ThreadData
			{
				get
				{
					LocalDataStoreSlot namedDataSlot = Thread.GetNamedDataSlot("system.drawing.threaddata");
					IDictionary dictionary = (IDictionary)Thread.GetData(namedDataSlot);
					if (dictionary == null)
					{
						dictionary = new Hashtable();
						Thread.SetData(namedDataSlot, dictionary);
					}
					return dictionary;
				}
			}

			static Gdip()
			{
				s_gdiPlusInitialization = new TraceSwitch("GdiPlusInitialization", "Tracks GDI+ initialization and teardown");
				s_initToken = (IntPtr)1;
				AppDomain currentDomain = AppDomain.CurrentDomain;
				currentDomain.ProcessExit += OnProcessExit;
				if (!currentDomain.IsDefaultAppDomain())
				{
					currentDomain.DomainUnload += OnProcessExit;
				}
			}

			[MethodImpl(MethodImplOptions.NoInlining)]
			private static void ClearThreadData()
			{
				Thread.SetData(Thread.GetNamedDataSlot("system.drawing.threaddata"), null);
			}

			private static void Shutdown()
			{
				if (Initialized)
				{
					ClearThreadData();
					AppDomain currentDomain = AppDomain.CurrentDomain;
					currentDomain.ProcessExit -= OnProcessExit;
					if (!currentDomain.IsDefaultAppDomain())
					{
						currentDomain.DomainUnload -= OnProcessExit;
					}
				}
			}

			[PrePrepareMethod]
			private static void OnProcessExit(object sender, EventArgs e)
			{
				Shutdown();
			}

			internal static void DummyFunction()
			{
			}

			internal static void CheckStatus(int status)
			{
				if (status != 0)
				{
					throw StatusException(status);
				}
			}

			internal static Exception StatusException(int status)
			{
				return status switch
				{
					1 => new ExternalException(global::SR.Format("A generic error occurred in GDI+."), -2147467259), 
					2 => new ArgumentException(global::SR.Format("Parameter is not valid.")), 
					3 => new OutOfMemoryException(global::SR.Format("Out of memory.")), 
					4 => new InvalidOperationException(global::SR.Format("Object is currently in use elsewhere.")), 
					5 => new OutOfMemoryException(global::SR.Format("Buffer is too small (internal GDI+ error).")), 
					6 => new NotImplementedException(global::SR.Format("Not implemented.")), 
					7 => new ExternalException(global::SR.Format("A generic error occurred in GDI+."), -2147467259), 
					8 => new InvalidOperationException(global::SR.Format("Bitmap region is already locked.")), 
					9 => new ExternalException(global::SR.Format("Function was ended."), -2147467260), 
					10 => new FileNotFoundException(global::SR.Format("File not found.")), 
					11 => new OverflowException(global::SR.Format("Overflow error.")), 
					12 => new ExternalException(global::SR.Format("File access is denied."), -2147024891), 
					13 => new ArgumentException(global::SR.Format("Image format is unknown.")), 
					19 => new ArgumentException(global::SR.Format("Property cannot be found.")), 
					20 => new ArgumentException(global::SR.Format("Property is not supported.")), 
					14 => new ArgumentException(global::SR.Format("Font '{0}' cannot be found.", "?")), 
					15 => new ArgumentException(global::SR.Format("Font '{0}' does not support style '{1}'.", "?", "?")), 
					16 => new ArgumentException(global::SR.Format("Only TrueType fonts are supported. This is not a TrueType font.")), 
					17 => new ExternalException(global::SR.Format("Current version of GDI+ does not support this feature."), -2147467259), 
					18 => new ExternalException(global::SR.Format("GDI+ is not properly initialized (internal GDI+ error)."), -2147467259), 
					_ => new ExternalException(global::SR.Format("Unknown GDI+ error occurred."), -2147418113), 
				};
			}

			internal static PointF[] ConvertGPPOINTFArrayF(IntPtr memory, int count)
			{
				if (memory == IntPtr.Zero)
				{
					throw new ArgumentNullException("memory");
				}
				PointF[] array = new PointF[count];
				Type typeFromHandle = typeof(GPPOINTF);
				int num = Marshal.SizeOf(typeFromHandle);
				for (int i = 0; i < count; i++)
				{
					GPPOINTF gPPOINTF = (GPPOINTF)Marshal.PtrToStructure((IntPtr)((long)memory + i * num), typeFromHandle);
					array[i] = new PointF(gPPOINTF.X, gPPOINTF.Y);
				}
				return array;
			}

			internal static Point[] ConvertGPPOINTArray(IntPtr memory, int count)
			{
				if (memory == IntPtr.Zero)
				{
					throw new ArgumentNullException("memory");
				}
				Point[] array = new Point[count];
				Type typeFromHandle = typeof(GPPOINT);
				int num = Marshal.SizeOf(typeFromHandle);
				for (int i = 0; i < count; i++)
				{
					GPPOINT gPPOINT = (GPPOINT)Marshal.PtrToStructure((IntPtr)((long)memory + i * num), typeFromHandle);
					array[i] = new Point(gPPOINT.X, gPPOINT.Y);
				}
				return array;
			}

			internal static IntPtr ConvertPointToMemory(PointF[] points)
			{
				if (points == null)
				{
					throw new ArgumentNullException("points");
				}
				int num = Marshal.SizeOf(typeof(GPPOINTF));
				int num2 = points.Length;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
				for (int i = 0; i < num2; i++)
				{
					Marshal.StructureToPtr(new GPPOINTF(points[i]), (IntPtr)checked((long)intPtr + i * num), fDeleteOld: false);
				}
				return intPtr;
			}

			internal static IntPtr ConvertPointToMemory(Point[] points)
			{
				if (points == null)
				{
					throw new ArgumentNullException("points");
				}
				int num = Marshal.SizeOf(typeof(GPPOINT));
				int num2 = points.Length;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
				for (int i = 0; i < num2; i++)
				{
					Marshal.StructureToPtr(new GPPOINT(points[i]), (IntPtr)checked((long)intPtr + i * num), fDeleteOld: false);
				}
				return intPtr;
			}

			internal static IntPtr ConvertRectangleToMemory(RectangleF[] rect)
			{
				if (rect == null)
				{
					throw new ArgumentNullException("rect");
				}
				int num = Marshal.SizeOf(typeof(GPRECTF));
				int num2 = rect.Length;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
				for (int i = 0; i < num2; i++)
				{
					Marshal.StructureToPtr(new GPRECTF(rect[i]), (IntPtr)checked((long)intPtr + i * num), fDeleteOld: false);
				}
				return intPtr;
			}

			internal static IntPtr ConvertRectangleToMemory(Rectangle[] rect)
			{
				if (rect == null)
				{
					throw new ArgumentNullException("rect");
				}
				int num = Marshal.SizeOf(typeof(GPRECT));
				int num2 = rect.Length;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
				for (int i = 0; i < num2; i++)
				{
					Marshal.StructureToPtr(new GPRECT(rect[i]), (IntPtr)checked((long)intPtr + i * num), fDeleteOld: false);
				}
				return intPtr;
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		public class ENHMETAHEADER
		{
			public int iType;

			public int nSize = 40;

			public int rclBounds_left;

			public int rclBounds_top;

			public int rclBounds_right;

			public int rclBounds_bottom;

			public int rclFrame_left;

			public int rclFrame_top;

			public int rclFrame_right;

			public int rclFrame_bottom;

			public int dSignature;

			public int nVersion;

			public int nBytes;

			public int nRecords;

			public short nHandles;

			public short sReserved;

			public int nDescription;

			public int offDescription;

			public int nPalEntries;

			public int szlDevice_cx;

			public int szlDevice_cy;

			public int szlMillimeters_cx;

			public int szlMillimeters_cy;

			public int cbPixelFormat;

			public int offPixelFormat;

			public int bOpenGL;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		public class DOCINFO
		{
			public int cbSize = 20;

			public string lpszDocName;

			public string lpszOutput;

			public string lpszDatatype;

			public int fwType;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		public class PRINTDLG
		{
			public int lStructSize;

			public IntPtr hwndOwner;

			public IntPtr hDevMode;

			public IntPtr hDevNames;

			public IntPtr hDC;

			public int Flags;

			public short nFromPage;

			public short nToPage;

			public short nMinPage;

			public short nMaxPage;

			public short nCopies;

			public IntPtr hInstance;

			public IntPtr lCustData;

			public IntPtr lpfnPrintHook;

			public IntPtr lpfnSetupHook;

			public string lpPrintTemplateName;

			public string lpSetupTemplateName;

			public IntPtr hPrintTemplate;

			public IntPtr hSetupTemplate;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto, Pack = 1)]
		public class PRINTDLGX86
		{
			public int lStructSize;

			public IntPtr hwndOwner;

			public IntPtr hDevMode;

			public IntPtr hDevNames;

			public IntPtr hDC;

			public int Flags;

			public short nFromPage;

			public short nToPage;

			public short nMinPage;

			public short nMaxPage;

			public short nCopies;

			public IntPtr hInstance;

			public IntPtr lCustData;

			public IntPtr lpfnPrintHook;

			public IntPtr lpfnSetupHook;

			public string lpPrintTemplateName;

			public string lpSetupTemplateName;

			public IntPtr hPrintTemplate;

			public IntPtr hSetupTemplate;
		}

		[StructLayout(LayoutKind.Sequential)]
		public class ICONINFO
		{
			public int fIcon;

			public int xHotspot;

			public int yHotspot;

			public IntPtr hbmMask = IntPtr.Zero;

			public IntPtr hbmColor = IntPtr.Zero;
		}

		[StructLayout(LayoutKind.Sequential)]
		public class BITMAP
		{
			public int bmType;

			public int bmWidth;

			public int bmHeight;

			public int bmWidthBytes;

			public short bmPlanes;

			public short bmBitsPixel;

			public IntPtr bmBits = IntPtr.Zero;
		}

		[StructLayout(LayoutKind.Sequential)]
		public class BITMAPINFOHEADER
		{
			public int biSize = 40;

			public int biWidth;

			public int biHeight;

			public short biPlanes;

			public short biBitCount;

			public int biCompression;

			public int biSizeImage;

			public int biXPelsPerMeter;

			public int biYPelsPerMeter;

			public int biClrUsed;

			public int biClrImportant;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		public class LOGFONT
		{
			public int lfHeight;

			public int lfWidth;

			public int lfEscapement;

			public int lfOrientation;

			public int lfWeight;

			public byte lfItalic;

			public byte lfUnderline;

			public byte lfStrikeOut;

			public byte lfCharSet;

			public byte lfOutPrecision;

			public byte lfClipPrecision;

			public byte lfQuality;

			public byte lfPitchAndFamily;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string lfFaceName;

			public override string ToString()
			{
				return "lfHeight=" + lfHeight + ", lfWidth=" + lfWidth + ", lfEscapement=" + lfEscapement + ", lfOrientation=" + lfOrientation + ", lfWeight=" + lfWeight + ", lfItalic=" + lfItalic + ", lfUnderline=" + lfUnderline + ", lfStrikeOut=" + lfStrikeOut + ", lfCharSet=" + lfCharSet + ", lfOutPrecision=" + lfOutPrecision + ", lfClipPrecision=" + lfClipPrecision + ", lfQuality=" + lfQuality + ", lfPitchAndFamily=" + lfPitchAndFamily + ", lfFaceName=" + lfFaceName;
			}
		}

		[StructLayout(LayoutKind.Sequential, Pack = 2)]
		public struct ICONDIR
		{
			public short idReserved;

			public short idType;

			public short idCount;

			public ICONDIRENTRY idEntries;
		}

		public struct ICONDIRENTRY
		{
			public byte bWidth;

			public byte bHeight;

			public byte bColorCount;

			public byte bReserved;

			public short wPlanes;

			public short wBitCount;

			public int dwBytesInRes;

			public int dwImageOffset;
		}

		public class Ole
		{
			public const int PICTYPE_ICON = 3;
		}

		[StructLayout(LayoutKind.Sequential)]
		public class PICTDESC
		{
			internal int cbSizeOfStruct;

			public int picType;

			internal IntPtr union1;

			internal int union2;

			internal int union3;

			public static PICTDESC CreateIconPICTDESC(IntPtr hicon)
			{
				return new PICTDESC
				{
					cbSizeOfStruct = 12,
					picType = 3,
					union1 = hicon
				};
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		public class DEVMODE
		{
			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string dmDeviceName;

			public short dmSpecVersion;

			public short dmDriverVersion;

			public short dmSize;

			public short dmDriverExtra;

			public int dmFields;

			public short dmOrientation;

			public short dmPaperSize;

			public short dmPaperLength;

			public short dmPaperWidth;

			public short dmScale;

			public short dmCopies;

			public short dmDefaultSource;

			public short dmPrintQuality;

			public short dmColor;

			public short dmDuplex;

			public short dmYResolution;

			public short dmTTOption;

			public short dmCollate;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string dmFormName;

			public short dmLogPixels;

			public int dmBitsPerPel;

			public int dmPelsWidth;

			public int dmPelsHeight;

			public int dmDisplayFlags;

			public int dmDisplayFrequency;

			public int dmICMMethod;

			public int dmICMIntent;

			public int dmMediaType;

			public int dmDitherType;

			public int dmICCManufacturer;

			public int dmICCModel;

			public int dmPanningWidth;

			public int dmPanningHeight;

			public override string ToString()
			{
				return "[DEVMODE: dmDeviceName=" + dmDeviceName + ", dmSpecVersion=" + dmSpecVersion + ", dmDriverVersion=" + dmDriverVersion + ", dmSize=" + dmSize + ", dmDriverExtra=" + dmDriverExtra + ", dmFields=" + dmFields + ", dmOrientation=" + dmOrientation + ", dmPaperSize=" + dmPaperSize + ", dmPaperLength=" + dmPaperLength + ", dmPaperWidth=" + dmPaperWidth + ", dmScale=" + dmScale + ", dmCopies=" + dmCopies + ", dmDefaultSource=" + dmDefaultSource + ", dmPrintQuality=" + dmPrintQuality + ", dmColor=" + dmColor + ", dmDuplex=" + dmDuplex + ", dmYResolution=" + dmYResolution + ", dmTTOption=" + dmTTOption + ", dmCollate=" + dmCollate + ", dmFormName=" + dmFormName + ", dmLogPixels=" + dmLogPixels + ", dmBitsPerPel=" + dmBitsPerPel + ", dmPelsWidth=" + dmPelsWidth + ", dmPelsHeight=" + dmPelsHeight + ", dmDisplayFlags=" + dmDisplayFlags + ", dmDisplayFrequency=" + dmDisplayFrequency + ", dmICMMethod=" + dmICMMethod + ", dmICMIntent=" + dmICMIntent + ", dmMediaType=" + dmMediaType + ", dmDitherType=" + dmDitherType + ", dmICCManufacturer=" + dmICCManufacturer + ", dmICCModel=" + dmICCModel + ", dmPanningWidth=" + dmPanningWidth + ", dmPanningHeight=" + dmPanningHeight + "]";
			}
		}

		public sealed class CommonHandles
		{
			public static readonly int GDI;

			public static readonly int HDC;

			public static readonly int Icon;

			public static readonly int Kernel;

			static CommonHandles()
			{
				GDI = System.Internal.HandleCollector.RegisterType("GDI", 50, 500);
				HDC = System.Internal.HandleCollector.RegisterType("HDC", 100, 2);
				Icon = System.Internal.HandleCollector.RegisterType("Icon", 20, 500);
				Kernel = System.Internal.HandleCollector.RegisterType("Kernel", 0, 1000);
			}
		}

		public class StreamConsts
		{
			public const int STREAM_SEEK_SET = 0;

			public const int STREAM_SEEK_CUR = 1;

			public const int STREAM_SEEK_END = 2;
		}

		[ComImport]
		[Guid("7BF80980-BF32-101A-8BBB-00AA00300CAB")]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		public interface IPicture
		{
			[SuppressUnmanagedCodeSecurity]
			IntPtr GetHandle();

			[SuppressUnmanagedCodeSecurity]
			IntPtr GetHPal();

			[SuppressUnmanagedCodeSecurity]
			[return: MarshalAs(UnmanagedType.I2)]
			short GetPictureType();

			[SuppressUnmanagedCodeSecurity]
			int GetWidth();

			[SuppressUnmanagedCodeSecurity]
			int GetHeight();

			[SuppressUnmanagedCodeSecurity]
			void Render();

			[SuppressUnmanagedCodeSecurity]
			void SetHPal([In] IntPtr phpal);

			[SuppressUnmanagedCodeSecurity]
			IntPtr GetCurDC();

			[SuppressUnmanagedCodeSecurity]
			void SelectPicture([In] IntPtr hdcIn, [Out][MarshalAs(UnmanagedType.LPArray)] int[] phdcOut, [Out][MarshalAs(UnmanagedType.LPArray)] int[] phbmpOut);

			[SuppressUnmanagedCodeSecurity]
			[return: MarshalAs(UnmanagedType.Bool)]
			bool GetKeepOriginalFormat();

			[SuppressUnmanagedCodeSecurity]
			void SetKeepOriginalFormat([In][MarshalAs(UnmanagedType.Bool)] bool pfkeep);

			[SuppressUnmanagedCodeSecurity]
			void PictureChanged();

			[PreserveSig]
			[SuppressUnmanagedCodeSecurity]
			int SaveAsFile([In][MarshalAs(UnmanagedType.Interface)] UnsafeNativeMethods.IStream pstm, [In] int fSaveMemCopy, out int pcbSize);

			[SuppressUnmanagedCodeSecurity]
			int GetAttributes();

			[SuppressUnmanagedCodeSecurity]
			void SetHdc([In] IntPtr hdc);
		}

		public const int ERROR_CANCELLED = 1223;

		public const int E_UNEXPECTED = -2147418113;

		public const int E_NOTIMPL = -2147467263;

		public const int E_ABORT = -2147467260;

		public const int E_FAIL = -2147467259;

		public const int E_ACCESSDENIED = -2147024891;

		public const int GMEM_MOVEABLE = 2;

		public const int GMEM_ZEROINIT = 64;

		public const int DM_IN_BUFFER = 8;

		public const int DM_OUT_BUFFER = 2;

		public const int DT_PLOTTER = 0;

		public const int DT_RASPRINTER = 2;

		public const int TECHNOLOGY = 2;

		public const int DC_PAPERS = 2;

		public const int DC_PAPERSIZE = 3;

		public const int DC_BINS = 6;

		public const int DC_DUPLEX = 7;

		public const int DC_BINNAMES = 12;

		public const int DC_ENUMRESOLUTIONS = 13;

		public const int DC_PAPERNAMES = 16;

		public const int DC_ORIENTATION = 17;

		public const int DC_COPIES = 18;

		public const int PD_ALLPAGES = 0;

		public const int PD_SELECTION = 1;

		public const int PD_PAGENUMS = 2;

		public const int PD_CURRENTPAGE = 4194304;

		public const int PD_RETURNDEFAULT = 1024;

		public const int DI_NORMAL = 3;

		public const int IMAGE_ICON = 1;

		public const int IDI_APPLICATION = 32512;

		public const int IDI_HAND = 32513;

		public const int IDI_QUESTION = 32514;

		public const int IDI_EXCLAMATION = 32515;

		public const int IDI_ASTERISK = 32516;

		public const int IDI_WINLOGO = 32517;

		public const int IDI_WARNING = 32515;

		public const int IDI_ERROR = 32513;

		public const int IDI_INFORMATION = 32516;

		public const int SRCCOPY = 13369376;

		public const int PLANES = 14;

		public const int BITSPIXEL = 12;

		public const int LOGPIXELSX = 88;

		public const int LOGPIXELSY = 90;

		public const int PHYSICALWIDTH = 110;

		public const int PHYSICALHEIGHT = 111;

		public const int PHYSICALOFFSETX = 112;

		public const int PHYSICALOFFSETY = 113;

		public const int VERTRES = 10;

		public const int HORZRES = 8;

		public const int DM_ORIENTATION = 1;

		public const int DM_PAPERSIZE = 2;

		public const int DM_PAPERLENGTH = 4;

		public const int DM_PAPERWIDTH = 8;

		public const int DM_COPIES = 256;

		public const int DM_DEFAULTSOURCE = 512;

		public const int DM_PRINTQUALITY = 1024;

		public const int DM_COLOR = 2048;

		public const int DM_DUPLEX = 4096;

		public const int DM_YRESOLUTION = 8192;

		public const int DM_COLLATE = 32768;

		public const int DMORIENT_PORTRAIT = 1;

		public const int DMORIENT_LANDSCAPE = 2;

		public const int DMPAPER_LETTER = 1;

		public const int DMPAPER_LETTERSMALL = 2;

		public const int DMPAPER_TABLOID = 3;

		public const int DMPAPER_LEDGER = 4;

		public const int DMPAPER_LEGAL = 5;

		public const int DMPAPER_STATEMENT = 6;

		public const int DMPAPER_EXECUTIVE = 7;

		public const int DMPAPER_A3 = 8;

		public const int DMPAPER_A4 = 9;

		public const int DMPAPER_A4SMALL = 10;

		public const int DMPAPER_A5 = 11;

		public const int DMPAPER_B4 = 12;

		public const int DMPAPER_B5 = 13;

		public const int DMPAPER_FOLIO = 14;

		public const int DMPAPER_QUARTO = 15;

		public const int DMPAPER_10X14 = 16;

		public const int DMPAPER_11X17 = 17;

		public const int DMPAPER_NOTE = 18;

		public const int DMPAPER_ENV_9 = 19;

		public const int DMPAPER_ENV_10 = 20;

		public const int DMPAPER_ENV_11 = 21;

		public const int DMPAPER_ENV_12 = 22;

		public const int DMPAPER_ENV_14 = 23;

		public const int DMPAPER_CSHEET = 24;

		public const int DMPAPER_DSHEET = 25;

		public const int DMPAPER_ESHEET = 26;

		public const int DMPAPER_ENV_DL = 27;

		public const int DMPAPER_ENV_C5 = 28;

		public const int DMPAPER_ENV_C3 = 29;

		public const int DMPAPER_ENV_C4 = 30;

		public const int DMPAPER_ENV_C6 = 31;

		public const int DMPAPER_ENV_C65 = 32;

		public const int DMPAPER_ENV_B4 = 33;

		public const int DMPAPER_ENV_B5 = 34;

		public const int DMPAPER_ENV_B6 = 35;

		public const int DMPAPER_ENV_ITALY = 36;

		public const int DMPAPER_ENV_MONARCH = 37;

		public const int DMPAPER_ENV_PERSONAL = 38;

		public const int DMPAPER_FANFOLD_US = 39;

		public const int DMPAPER_FANFOLD_STD_GERMAN = 40;

		public const int DMPAPER_FANFOLD_LGL_GERMAN = 41;

		public const int DMPAPER_ISO_B4 = 42;

		public const int DMPAPER_JAPANESE_POSTCARD = 43;

		public const int DMPAPER_9X11 = 44;

		public const int DMPAPER_10X11 = 45;

		public const int DMPAPER_15X11 = 46;

		public const int DMPAPER_ENV_INVITE = 47;

		public const int DMPAPER_RESERVED_48 = 48;

		public const int DMPAPER_RESERVED_49 = 49;

		public const int DMPAPER_LETTER_EXTRA = 50;

		public const int DMPAPER_LEGAL_EXTRA = 51;

		public const int DMPAPER_TABLOID_EXTRA = 52;

		public const int DMPAPER_A4_EXTRA = 53;

		public const int DMPAPER_LETTER_TRANSVERSE = 54;

		public const int DMPAPER_A4_TRANSVERSE = 55;

		public const int DMPAPER_LETTER_EXTRA_TRANSVERSE = 56;

		public const int DMPAPER_A_PLUS = 57;

		public const int DMPAPER_B_PLUS = 58;

		public const int DMPAPER_LETTER_PLUS = 59;

		public const int DMPAPER_A4_PLUS = 60;

		public const int DMPAPER_A5_TRANSVERSE = 61;

		public const int DMPAPER_B5_TRANSVERSE = 62;

		public const int DMPAPER_A3_EXTRA = 63;

		public const int DMPAPER_A5_EXTRA = 64;

		public const int DMPAPER_B5_EXTRA = 65;

		public const int DMPAPER_A2 = 66;

		public const int DMPAPER_A3_TRANSVERSE = 67;

		public const int DMPAPER_A3_EXTRA_TRANSVERSE = 68;

		public const int DMPAPER_DBL_JAPANESE_POSTCARD = 69;

		public const int DMPAPER_A6 = 70;

		public const int DMPAPER_JENV_KAKU2 = 71;

		public const int DMPAPER_JENV_KAKU3 = 72;

		public const int DMPAPER_JENV_CHOU3 = 73;

		public const int DMPAPER_JENV_CHOU4 = 74;

		public const int DMPAPER_LETTER_ROTATED = 75;

		public const int DMPAPER_A3_ROTATED = 76;

		public const int DMPAPER_A4_ROTATED = 77;

		public const int DMPAPER_A5_ROTATED = 78;

		public const int DMPAPER_B4_JIS_ROTATED = 79;

		public const int DMPAPER_B5_JIS_ROTATED = 80;

		public const int DMPAPER_JAPANESE_POSTCARD_ROTATED = 81;

		public const int DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82;

		public const int DMPAPER_A6_ROTATED = 83;

		public const int DMPAPER_JENV_KAKU2_ROTATED = 84;

		public const int DMPAPER_JENV_KAKU3_ROTATED = 85;

		public const int DMPAPER_JENV_CHOU3_ROTATED = 86;

		public const int DMPAPER_JENV_CHOU4_ROTATED = 87;

		public const int DMPAPER_B6_JIS = 88;

		public const int DMPAPER_B6_JIS_ROTATED = 89;

		public const int DMPAPER_12X11 = 90;

		public const int DMPAPER_JENV_YOU4 = 91;

		public const int DMPAPER_JENV_YOU4_ROTATED = 92;

		public const int DMPAPER_P16K = 93;

		public const int DMPAPER_P32K = 94;

		public const int DMPAPER_P32KBIG = 95;

		public const int DMPAPER_PENV_1 = 96;

		public const int DMPAPER_PENV_2 = 97;

		public const int DMPAPER_PENV_3 = 98;

		public const int DMPAPER_PENV_4 = 99;

		public const int DMPAPER_PENV_5 = 100;

		public const int DMPAPER_PENV_6 = 101;

		public const int DMPAPER_PENV_7 = 102;

		public const int DMPAPER_PENV_8 = 103;

		public const int DMPAPER_PENV_9 = 104;

		public const int DMPAPER_PENV_10 = 105;

		public const int DMPAPER_P16K_ROTATED = 106;

		public const int DMPAPER_P32K_ROTATED = 107;

		public const int DMPAPER_P32KBIG_ROTATED = 108;

		public const int DMPAPER_PENV_1_ROTATED = 109;

		public const int DMPAPER_PENV_2_ROTATED = 110;

		public const int DMPAPER_PENV_3_ROTATED = 111;

		public const int DMPAPER_PENV_4_ROTATED = 112;

		public const int DMPAPER_PENV_5_ROTATED = 113;

		public const int DMPAPER_PENV_6_ROTATED = 114;

		public const int DMPAPER_PENV_7_ROTATED = 115;

		public const int DMPAPER_PENV_8_ROTATED = 116;

		public const int DMPAPER_PENV_9_ROTATED = 117;

		public const int DMPAPER_PENV_10_ROTATED = 118;

		public const int DMPAPER_LAST = 118;

		public const int DMBIN_UPPER = 1;

		public const int DMBIN_LOWER = 2;

		public const int DMBIN_MIDDLE = 3;

		public const int DMBIN_MANUAL = 4;

		public const int DMBIN_ENVELOPE = 5;

		public const int DMBIN_ENVMANUAL = 6;

		public const int DMBIN_AUTO = 7;

		public const int DMBIN_TRACTOR = 8;

		public const int DMBIN_SMALLFMT = 9;

		public const int DMBIN_LARGEFMT = 10;

		public const int DMBIN_LARGECAPACITY = 11;

		public const int DMBIN_CASSETTE = 14;

		public const int DMBIN_FORMSOURCE = 15;

		public const int DMBIN_LAST = 15;

		public const int DMBIN_USER = 256;

		public const int DMRES_DRAFT = -1;

		public const int DMRES_LOW = -2;

		public const int DMRES_MEDIUM = -3;

		public const int DMRES_HIGH = -4;

		public const int DMCOLOR_MONOCHROME = 1;

		public const int DMCOLOR_COLOR = 2;

		public const int DMDUP_SIMPLEX = 1;

		public const int DMDUP_VERTICAL = 2;

		public const int DMDUP_HORIZONTAL = 3;

		public const int DMCOLLATE_FALSE = 0;

		public const int DMCOLLATE_TRUE = 1;

		public const int PRINTER_ENUM_LOCAL = 2;

		public const int PRINTER_ENUM_CONNECTIONS = 4;

		public const int SRCPAINT = 15597702;

		public const int SRCAND = 8913094;

		public const int SRCINVERT = 6684742;

		public const int SRCERASE = 4457256;

		public const int NOTSRCCOPY = 3342344;

		public const int NOTSRCERASE = 1114278;

		public const int MERGECOPY = 12583114;

		public const int MERGEPAINT = 12255782;

		public const int PATCOPY = 15728673;

		public const int PATPAINT = 16452105;

		public const int PATINVERT = 5898313;

		public const int DSTINVERT = 5570569;

		public const int BLACKNESS = 66;

		public const int WHITENESS = 16711778;

		public const int CAPTUREBLT = 1073741824;

		public const int SM_CXICON = 11;

		public const int SM_CYICON = 12;

		public const int DEFAULT_CHARSET = 1;

		public const int NOMIRRORBITMAP = int.MinValue;

		public const int QUERYESCSUPPORT = 8;

		public const int CHECKJPEGFORMAT = 4119;

		public const int CHECKPNGFORMAT = 4120;

		public const int ERROR_ACCESS_DENIED = 5;

		public const int ERROR_INVALID_PARAMETER = 87;

		public const int ERROR_PROC_NOT_FOUND = 127;

		[DllImport("gdi32", CharSet = CharSet.Auto, EntryPoint = "CreateCompatibleBitmap", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntCreateCompatibleBitmap(HandleRef hDC, int width, int height);

		public static IntPtr CreateCompatibleBitmap(HandleRef hDC, int width, int height)
		{
			return System.Internal.HandleCollector.Add(IntCreateCompatibleBitmap(hDC, width, height), CommonHandles.GDI);
		}

		[DllImport("gdi32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int BitBlt(HandleRef hDC, int x, int y, int nWidth, int nHeight, HandleRef hSrcDC, int xSrc, int ySrc, int dwRop);

		[DllImport("gdi32")]
		public static extern int GetDIBits(HandleRef hdc, HandleRef hbm, int arg1, int arg2, IntPtr arg3, ref NativeMethods.BITMAPINFO_FLAT bmi, int arg5);

		[DllImport("gdi32")]
		public static extern uint GetPaletteEntries(HandleRef hpal, int iStartIndex, int nEntries, byte[] lppe);

		[DllImport("gdi32", CharSet = CharSet.Auto, EntryPoint = "CreateDIBSection", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntCreateDIBSection(HandleRef hdc, ref NativeMethods.BITMAPINFO_FLAT bmi, int iUsage, ref IntPtr ppvBits, IntPtr hSection, int dwOffset);

		public static IntPtr CreateDIBSection(HandleRef hdc, ref NativeMethods.BITMAPINFO_FLAT bmi, int iUsage, ref IntPtr ppvBits, IntPtr hSection, int dwOffset)
		{
			return System.Internal.HandleCollector.Add(IntCreateDIBSection(hdc, ref bmi, iUsage, ref ppvBits, hSection, dwOffset), CommonHandles.GDI);
		}

		[DllImport("kernel32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr GlobalFree(HandleRef handle);

		[DllImport("gdi32", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int StartDoc(HandleRef hDC, DOCINFO lpDocInfo);

		[DllImport("gdi32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int StartPage(HandleRef hDC);

		[DllImport("gdi32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int EndPage(HandleRef hDC);

		[DllImport("gdi32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int AbortDoc(HandleRef hDC);

		[DllImport("gdi32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int EndDoc(HandleRef hDC);

		[DllImport("comdlg32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern bool PrintDlg([In][Out] PRINTDLG lppd);

		[DllImport("comdlg32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern bool PrintDlg([In][Out] PRINTDLGX86 lppd);

		[DllImport("winspool.drv", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int DeviceCapabilities(string pDevice, string pPort, short fwCapabilities, IntPtr pOutput, IntPtr pDevMode);

		[DllImport("winspool.drv", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int DocumentProperties(HandleRef hwnd, HandleRef hPrinter, string pDeviceName, IntPtr pDevModeOutput, HandleRef pDevModeInput, int fMode);

		[DllImport("winspool.drv", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int DocumentProperties(HandleRef hwnd, HandleRef hPrinter, string pDeviceName, IntPtr pDevModeOutput, IntPtr pDevModeInput, int fMode);

		[DllImport("winspool.drv", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int EnumPrinters(int flags, string name, int level, IntPtr pPrinterEnum, int cbBuf, out int pcbNeeded, out int pcReturned);

		[DllImport("kernel32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr GlobalLock(HandleRef handle);

		[DllImport("gdi32", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern IntPtr ResetDC(HandleRef hDC, HandleRef lpDevMode);

		[DllImport("kernel32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern bool GlobalUnlock(HandleRef handle);

		[DllImport("gdi32", CharSet = CharSet.Auto, EntryPoint = "CreateRectRgn", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntCreateRectRgn(int x1, int y1, int x2, int y2);

		public static IntPtr CreateRectRgn(int x1, int y1, int x2, int y2)
		{
			return System.Internal.HandleCollector.Add(IntCreateRectRgn(x1, y1, x2, y2), CommonHandles.GDI);
		}

		[DllImport("gdi32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetClipRgn(HandleRef hDC, HandleRef hRgn);

		[DllImport("gdi32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int SelectClipRgn(HandleRef hDC, HandleRef hRgn);

		[DllImport("gdi32", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int AddFontResourceEx(string lpszFilename, int fl, IntPtr pdv);

		public static int AddFontFile(string fileName)
		{
			return AddFontResourceEx(fileName, 16, IntPtr.Zero);
		}

		internal static IntPtr SaveClipRgn(IntPtr hDC)
		{
			IntPtr intPtr = CreateRectRgn(0, 0, 0, 0);
			IntPtr result = IntPtr.Zero;
			try
			{
				if (GetClipRgn(new HandleRef(null, hDC), new HandleRef(null, intPtr)) > 0)
				{
					result = intPtr;
					intPtr = IntPtr.Zero;
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					DeleteObject(new HandleRef(null, intPtr));
				}
			}
			return result;
		}

		internal static void RestoreClipRgn(IntPtr hDC, IntPtr hRgn)
		{
			try
			{
				SelectClipRgn(new HandleRef(null, hDC), new HandleRef(null, hRgn));
			}
			finally
			{
				if (hRgn != IntPtr.Zero)
				{
					DeleteObject(new HandleRef(null, hRgn));
				}
			}
		}

		[DllImport("gdi32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int ExtEscape(HandleRef hDC, int nEscape, int cbInput, ref int inData, int cbOutput, out int outData);

		[DllImport("gdi32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int ExtEscape(HandleRef hDC, int nEscape, int cbInput, byte[] inData, int cbOutput, out int outData);

		[DllImport("gdi32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int IntersectClipRect(HandleRef hDC, int x1, int y1, int x2, int y2);

		[DllImport("kernel32", CharSet = CharSet.Auto, EntryPoint = "GlobalAlloc", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntGlobalAlloc(int uFlags, UIntPtr dwBytes);

		public static IntPtr GlobalAlloc(int uFlags, uint dwBytes)
		{
			return IntGlobalAlloc(uFlags, new UIntPtr(dwBytes));
		}

		internal unsafe static void ZeroMemory(byte* ptr, ulong length)
		{
			byte* ptr2 = ptr + length;
			while (ptr != ptr2)
			{
				*(ptr++) = 0;
			}
		}

		[DllImport("gdi32", CharSet = CharSet.Auto, EntryPoint = "DeleteObject", ExactSpelling = true, SetLastError = true)]
		internal static extern int IntDeleteObject(HandleRef hObject);

		public static int DeleteObject(HandleRef hObject)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hObject, CommonHandles.GDI);
			return IntDeleteObject(hObject);
		}

		[DllImport("gdi32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr SelectObject(HandleRef hdc, HandleRef obj);

		[DllImport("user32", EntryPoint = "CreateIconFromResourceEx", SetLastError = true)]
		private unsafe static extern IntPtr IntCreateIconFromResourceEx(byte* pbIconBits, int cbIconBits, bool fIcon, int dwVersion, int csDesired, int cyDesired, int flags);

		public unsafe static IntPtr CreateIconFromResourceEx(byte* pbIconBits, int cbIconBits, bool fIcon, int dwVersion, int csDesired, int cyDesired, int flags)
		{
			return System.Internal.HandleCollector.Add(IntCreateIconFromResourceEx(pbIconBits, cbIconBits, fIcon, dwVersion, csDesired, cyDesired, flags), CommonHandles.Icon);
		}

		[DllImport("shell32.dll", BestFitMapping = false, CharSet = CharSet.Auto, EntryPoint = "ExtractAssociatedIcon")]
		public static extern IntPtr IntExtractAssociatedIcon(HandleRef hInst, StringBuilder iconPath, ref int index);

		public static IntPtr ExtractAssociatedIcon(HandleRef hInst, StringBuilder iconPath, ref int index)
		{
			return System.Internal.HandleCollector.Add(IntExtractAssociatedIcon(hInst, iconPath, ref index), CommonHandles.Icon);
		}

		[DllImport("user32", CharSet = CharSet.Auto, EntryPoint = "LoadIcon", SetLastError = true)]
		private static extern IntPtr IntLoadIcon(HandleRef hInst, IntPtr iconId);

		public static IntPtr LoadIcon(HandleRef hInst, int iconId)
		{
			return IntLoadIcon(hInst, new IntPtr(iconId));
		}

		[DllImport("user32", CharSet = CharSet.Auto, EntryPoint = "DestroyIcon", ExactSpelling = true, SetLastError = true)]
		private static extern bool IntDestroyIcon(HandleRef hIcon);

		public static bool DestroyIcon(HandleRef hIcon)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hIcon, CommonHandles.Icon);
			return IntDestroyIcon(hIcon);
		}

		[DllImport("user32", CharSet = CharSet.Auto, EntryPoint = "CopyImage", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntCopyImage(HandleRef hImage, int uType, int cxDesired, int cyDesired, int fuFlags);

		public static IntPtr CopyImage(HandleRef hImage, int uType, int cxDesired, int cyDesired, int fuFlags)
		{
			return System.Internal.HandleCollector.Add(type: (uType != 1) ? CommonHandles.GDI : CommonHandles.Icon, handle: IntCopyImage(hImage, uType, cxDesired, cyDesired, fuFlags));
		}

		[DllImport("gdi32", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetObject(HandleRef hObject, int nSize, [In][Out] BITMAP bm);

		[DllImport("gdi32", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetObject(HandleRef hObject, int nSize, [In][Out] LOGFONT lf);

		public static int GetObject(HandleRef hObject, LOGFONT lp)
		{
			return GetObject(hObject, Marshal.SizeOf(typeof(LOGFONT)), lp);
		}

		[DllImport("user32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern bool GetIconInfo(HandleRef hIcon, [In][Out] ICONINFO info);

		[DllImport("user32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern bool DrawIconEx(HandleRef hDC, int x, int y, HandleRef hIcon, int width, int height, int iStepIfAniCursor, HandleRef hBrushFlickerFree, int diFlags);

		[DllImport("oleaut32.dll", PreserveSig = false)]
		public static extern IPicture OleCreatePictureIndirect(PICTDESC pictdesc, [In] ref Guid refiid, bool fOwn);
	}
	/// <summary>Defines methods for obtaining and releasing an existing handle to a Windows device context.</summary>
	public interface IDeviceContext : IDisposable
	{
		/// <summary>Returns the handle to a Windows device context.</summary>
		/// <returns>An <see cref="T:System.IntPtr" /> representing the handle of a device context.</returns>
		IntPtr GetHdc();

		/// <summary>Releases the handle of a Windows device context.</summary>
		void ReleaseHdc();
	}
	internal class NativeMethods
	{
		internal struct BITMAPINFO_FLAT
		{
			public int bmiHeader_biSize;

			public int bmiHeader_biWidth;

			public int bmiHeader_biHeight;

			public short bmiHeader_biPlanes;

			public short bmiHeader_biBitCount;

			public int bmiHeader_biCompression;

			public int bmiHeader_biSizeImage;

			public int bmiHeader_biXPelsPerMeter;

			public int bmiHeader_biYPelsPerMeter;

			public int bmiHeader_biClrUsed;

			public int bmiHeader_biClrImportant;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 1024)]
			public byte[] bmiColors;
		}

		[StructLayout(LayoutKind.Sequential)]
		internal class BITMAPINFOHEADER
		{
			public int biSize = 40;

			public int biWidth;

			public int biHeight;

			public short biPlanes;

			public short biBitCount;

			public int biCompression;

			public int biSizeImage;

			public int biXPelsPerMeter;

			public int biYPelsPerMeter;

			public int biClrUsed;

			public int biClrImportant;
		}

		internal struct PALETTEENTRY
		{
			public byte peRed;

			public byte peGreen;

			public byte peBlue;

			public byte peFlags;
		}

		internal struct RGBQUAD
		{
			public byte rgbBlue;

			public byte rgbGreen;

			public byte rgbRed;

			public byte rgbReserved;
		}

		[StructLayout(LayoutKind.Sequential)]
		internal class NONCLIENTMETRICS
		{
			public int cbSize = Marshal.SizeOf(typeof(NONCLIENTMETRICS));

			public int iBorderWidth;

			public int iScrollWidth;

			public int iScrollHeight;

			public int iCaptionWidth;

			public int iCaptionHeight;

			[MarshalAs(UnmanagedType.Struct)]
			public SafeNativeMethods.LOGFONT lfCaptionFont;

			public int iSmCaptionWidth;

			public int iSmCaptionHeight;

			[MarshalAs(UnmanagedType.Struct)]
			public SafeNativeMethods.LOGFONT lfSmCaptionFont;

			public int iMenuWidth;

			public int iMenuHeight;

			[MarshalAs(UnmanagedType.Struct)]
			public SafeNativeMethods.LOGFONT lfMenuFont;

			[MarshalAs(UnmanagedType.Struct)]
			public SafeNativeMethods.LOGFONT lfStatusFont;

			[MarshalAs(UnmanagedType.Struct)]
			public SafeNativeMethods.LOGFONT lfMessageFont;
		}

		internal static HandleRef NullHandleRef = new HandleRef(null, IntPtr.Zero);

		public const int MAX_PATH = 260;

		internal const int SM_REMOTESESSION = 4096;

		internal const int OBJ_DC = 3;

		internal const int OBJ_METADC = 4;

		internal const int OBJ_MEMDC = 10;

		internal const int OBJ_ENHMETADC = 12;

		internal const int DIB_RGB_COLORS = 0;

		internal const int BI_BITFIELDS = 3;

		internal const int BI_RGB = 0;

		internal const int BITMAPINFO_MAX_COLORSIZE = 256;

		internal const int SPI_GETICONTITLELOGFONT = 31;

		internal const int SPI_GETNONCLIENTMETRICS = 41;

		internal const int DEFAULT_GUI_FONT = 17;
	}
	/// <summary>Specifies how much an image is rotated and the axis used to flip the image.</summary>
	public enum RotateFlipType
	{
		/// <summary>Specifies no clockwise rotation and no flipping.</summary>
		RotateNoneFlipNone = 0,
		/// <summary>Specifies a 90-degree clockwise rotation without flipping.</summary>
		Rotate90FlipNone = 1,
		/// <summary>Specifies a 180-degree clockwise rotation without flipping.</summary>
		Rotate180FlipNone = 2,
		/// <summary>Specifies a 270-degree clockwise rotation without flipping.</summary>
		Rotate270FlipNone = 3,
		/// <summary>Specifies no clockwise rotation followed by a horizontal flip.</summary>
		RotateNoneFlipX = 4,
		/// <summary>Specifies a 90-degree clockwise rotation followed by a horizontal flip.</summary>
		Rotate90FlipX = 5,
		/// <summary>Specifies a 180-degree clockwise rotation followed by a horizontal flip.</summary>
		Rotate180FlipX = 6,
		/// <summary>Specifies a 270-degree clockwise rotation followed by a horizontal flip.</summary>
		Rotate270FlipX = 7,
		/// <summary>Specifies no clockwise rotation followed by a vertical flip.</summary>
		RotateNoneFlipY = 6,
		/// <summary>Specifies a 90-degree clockwise rotation followed by a vertical flip.</summary>
		Rotate90FlipY = 7,
		/// <summary>Specifies a 180-degree clockwise rotation followed by a vertical flip.</summary>
		Rotate180FlipY = 4,
		/// <summary>Specifies a 270-degree clockwise rotation followed by a vertical flip.</summary>
		Rotate270FlipY = 5,
		/// <summary>Specifies no clockwise rotation followed by a horizontal and vertical flip.</summary>
		RotateNoneFlipXY = 2,
		/// <summary>Specifies a 90-degree clockwise rotation followed by a horizontal and vertical flip.</summary>
		Rotate90FlipXY = 3,
		/// <summary>Specifies a 180-degree clockwise rotation followed by a horizontal and vertical flip.</summary>
		Rotate180FlipXY = 0,
		/// <summary>Specifies a 270-degree clockwise rotation followed by a horizontal and vertical flip.</summary>
		Rotate270FlipXY = 1
	}
	/// <summary>Defines a brush of a single color. Brushes are used to fill graphics shapes, such as rectangles, ellipses, pies, polygons, and paths. This class cannot be inherited.</summary>
	public sealed class SolidBrush : Brush
	{
		private Color _color = Color.Empty;

		private bool _immutable;

		/// <summary>Gets or sets the color of this <see cref="T:System.Drawing.SolidBrush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> structure that represents the color of this brush.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.SolidBrush.Color" /> property is set on an immutable <see cref="T:System.Drawing.SolidBrush" />.</exception>
		public Color Color
		{
			get
			{
				if (_color == Color.Empty)
				{
					SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipGetSolidFillColor(new HandleRef(this, base.NativeBrush), out var color));
					_color = Color.FromArgb(color);
				}
				return _color;
			}
			set
			{
				if (_immutable)
				{
					throw new ArgumentException(global::SR.Format("Changes cannot be made to {0} because permissions are not valid.", "Brush"));
				}
				if (_color != value)
				{
					_ = _color;
					InternalSetColor(value);
				}
			}
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.SolidBrush" /> object of the specified color.</summary>
		/// <param name="color">A <see cref="T:System.Drawing.Color" /> structure that represents the color of this brush.</param>
		public SolidBrush(Color color)
		{
			_color = color;
			IntPtr brush = IntPtr.Zero;
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipCreateSolidFill(_color.ToArgb(), out brush));
			SetNativeBrushInternal(brush);
		}

		internal SolidBrush(Color color, bool immutable)
			: this(color)
		{
			_immutable = immutable;
		}

		internal SolidBrush(IntPtr nativeBrush)
		{
			SetNativeBrushInternal(nativeBrush);
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.SolidBrush" /> object.</summary>
		/// <returns>The <see cref="T:System.Drawing.SolidBrush" /> object that this method creates.</returns>
		public override object Clone()
		{
			IntPtr clonedBrush = IntPtr.Zero;
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipCloneBrush(new HandleRef(this, base.NativeBrush), out clonedBrush));
			return new SolidBrush(clonedBrush);
		}

		protected override void Dispose(bool disposing)
		{
			if (!disposing)
			{
				_immutable = false;
			}
			else if (_immutable)
			{
				throw new ArgumentException(global::SR.Format("Changes cannot be made to {0} because permissions are not valid.", "Brush"));
			}
			base.Dispose(disposing);
		}

		private void InternalSetColor(Color value)
		{
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipSetSolidFillColor(new HandleRef(this, base.NativeBrush), value.ToArgb()));
			_color = value;
		}
	}
	/// <summary>Specifies the alignment of a text string relative to its layout rectangle.</summary>
	public enum StringAlignment
	{
		/// <summary>Specifies the text be aligned near the layout. In a left-to-right layout, the near position is left. In a right-to-left layout, the near position is right.</summary>
		Near,
		/// <summary>Specifies that text is aligned in the center of the layout rectangle.</summary>
		Center,
		/// <summary>Specifies that text is aligned far from the origin position of the layout rectangle. In a left-to-right layout, the far position is right. In a right-to-left layout, the far position is left.</summary>
		Far
	}
	/// <summary>The <see cref="T:System.Drawing.StringDigitSubstitute" /> enumeration specifies how to substitute digits in a string according to a user's locale or language.</summary>
	public enum StringDigitSubstitute
	{
		/// <summary>Specifies a user-defined substitution scheme.</summary>
		User,
		/// <summary>Specifies to disable substitutions.</summary>
		None,
		/// <summary>Specifies substitution digits that correspond with the official national language of the user's locale.</summary>
		National,
		/// <summary>Specifies substitution digits that correspond with the user's native script or language, which may be different from the official national language of the user's locale.</summary>
		Traditional
	}
	/// <summary>Specifies the display and layout information for text strings.</summary>
	[Flags]
	public enum StringFormatFlags
	{
		/// <summary>Text is displayed from right to left.</summary>
		DirectionRightToLeft = 1,
		/// <summary>Text is vertically aligned.</summary>
		DirectionVertical = 2,
		/// <summary>Parts of characters are allowed to overhang the string's layout rectangle. By default, characters are repositioned to avoid any overhang.</summary>
		FitBlackBox = 4,
		/// <summary>Control characters such as the left-to-right mark are shown in the output with a representative glyph.</summary>
		DisplayFormatControl = 0x20,
		/// <summary>Fallback to alternate fonts for characters not supported in the requested font is disabled. Any missing characters are displayed with the fonts missing glyph, usually an open square.</summary>
		NoFontFallback = 0x400,
		/// <summary>Includes the trailing space at the end of each line. By default the boundary rectangle returned by the <see cref="Overload:System.Drawing.Graphics.MeasureString" /> method excludes the space at the end of each line. Set this flag to include that space in measurement.</summary>
		MeasureTrailingSpaces = 0x800,
		/// <summary>Text wrapping between lines when formatting within a rectangle is disabled. This flag is implied when a point is passed instead of a rectangle, or when the specified rectangle has a zero line length.</summary>
		NoWrap = 0x1000,
		/// <summary>Only entire lines are laid out in the formatting rectangle. By default layout continues until the end of the text, or until no more lines are visible as a result of clipping, whichever comes first. Note that the default settings allow the last line to be partially obscured by a formatting rectangle that is not a whole multiple of the line height. To ensure that only whole lines are seen, specify this value and be careful to provide a formatting rectangle at least as tall as the height of one line.</summary>
		LineLimit = 0x2000,
		/// <summary>Overhanging parts of glyphs, and unwrapped text reaching outside the formatting rectangle are allowed to show. By default all text and glyph parts reaching outside the formatting rectangle are clipped.</summary>
		NoClip = 0x4000
	}
	/// <summary>Specifies how to trim characters from a string that does not completely fit into a layout shape.</summary>
	public enum StringTrimming
	{
		/// <summary>Specifies no trimming.</summary>
		None,
		/// <summary>Specifies that the text is trimmed to the nearest character.</summary>
		Character,
		/// <summary>Specifies that text is trimmed to the nearest word.</summary>
		Word,
		/// <summary>Specifies that the text is trimmed to the nearest character, and an ellipsis is inserted at the end of a trimmed line.</summary>
		EllipsisCharacter,
		/// <summary>Specifies that text is trimmed to the nearest word, and an ellipsis is inserted at the end of a trimmed line.</summary>
		EllipsisWord,
		/// <summary>The center is removed from trimmed lines and replaced by an ellipsis. The algorithm keeps as much of the last slash-delimited segment of the line as possible.</summary>
		EllipsisPath
	}
	/// <summary>Specifies the units of measure for a text string.</summary>
	public enum StringUnit
	{
		/// <summary>Specifies world units as the unit of measure.</summary>
		World = 0,
		/// <summary>Specifies the device unit as the unit of measure.</summary>
		Display = 1,
		/// <summary>Specifies a pixel as the unit of measure.</summary>
		Pixel = 2,
		/// <summary>Specifies a printer's point (1/72 inch) as the unit of measure.</summary>
		Point = 3,
		/// <summary>Specifies an inch as the unit of measure.</summary>
		Inch = 4,
		/// <summary>Specifies 1/300 of an inch as the unit of measure.</summary>
		Document = 5,
		/// <summary>Specifies a millimeter as the unit of measure</summary>
		Millimeter = 6,
		/// <summary>Specifies a printer's em size of 32 as the unit of measure.</summary>
		Em = 32
	}
	/// <summary>Each property of the <see cref="T:System.Drawing.SystemBrushes" /> class is a <see cref="T:System.Drawing.SolidBrush" /> that is the color of a Windows display element.</summary>
	public static class SystemBrushes
	{
		private static readonly object s_systemBrushesKey = new object();

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the active window's border.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the active window's border.</returns>
		public static Brush ActiveBorder => FromSystemColor(SystemColors.ActiveBorder);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of the active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of the active window's title bar.</returns>
		public static Brush ActiveCaption => FromSystemColor(SystemColors.ActiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text in the active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of the active window's title bar.</returns>
		public static Brush ActiveCaptionText => FromSystemColor(SystemColors.ActiveCaptionText);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the application workspace.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the application workspace.</returns>
		public static Brush AppWorkspace => FromSystemColor(SystemColors.AppWorkspace);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the face color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the face color of a 3-D element.</returns>
		public static Brush ButtonFace => FromSystemColor(SystemColors.ButtonFace);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the highlight color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the highlight color of a 3-D element.</returns>
		public static Brush ButtonHighlight => FromSystemColor(SystemColors.ButtonHighlight);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the shadow color of a 3-D element.</returns>
		public static Brush ButtonShadow => FromSystemColor(SystemColors.ButtonShadow);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the face color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the face color of a 3-D element.</returns>
		public static Brush Control => FromSystemColor(SystemColors.Control);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the highlight color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the highlight color of a 3-D element.</returns>
		public static Brush ControlLightLight => FromSystemColor(SystemColors.ControlLightLight);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the light color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the light color of a 3-D element.</returns>
		public static Brush ControlLight => FromSystemColor(SystemColors.ControlLight);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the shadow color of a 3-D element.</returns>
		public static Brush ControlDark => FromSystemColor(SystemColors.ControlDark);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the dark shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the dark shadow color of a 3-D element.</returns>
		public static Brush ControlDarkDark => FromSystemColor(SystemColors.ControlDarkDark);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of text in a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of text in a 3-D element.</returns>
		public static Brush ControlText => FromSystemColor(SystemColors.ControlText);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the desktop.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the desktop.</returns>
		public static Brush Desktop => FromSystemColor(SystemColors.Desktop);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the lightest color in the color gradient of an active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the lightest color in the color gradient of an active window's title bar.</returns>
		public static Brush GradientActiveCaption => FromSystemColor(SystemColors.GradientActiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the lightest color in the color gradient of an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the lightest color in the color gradient of an inactive window's title bar.</returns>
		public static Brush GradientInactiveCaption => FromSystemColor(SystemColors.GradientInactiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of dimmed text.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of dimmed text.</returns>
		public static Brush GrayText => FromSystemColor(SystemColors.GrayText);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of selected items.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of selected items.</returns>
		public static Brush Highlight => FromSystemColor(SystemColors.Highlight);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text of selected items.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text of selected items.</returns>
		public static Brush HighlightText => FromSystemColor(SystemColors.HighlightText);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color used to designate a hot-tracked item.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color used to designate a hot-tracked item.</returns>
		public static Brush HotTrack => FromSystemColor(SystemColors.HotTrack);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of an inactive window's title bar.</returns>
		public static Brush InactiveCaption => FromSystemColor(SystemColors.InactiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of an inactive window's border.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of an inactive window's border.</returns>
		public static Brush InactiveBorder => FromSystemColor(SystemColors.InactiveBorder);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text in an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text in an inactive window's title bar.</returns>
		public static Brush InactiveCaptionText => FromSystemColor(SystemColors.InactiveCaptionText);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of a ToolTip.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of a ToolTip.</returns>
		public static Brush Info => FromSystemColor(SystemColors.Info);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text of a ToolTip.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> is the color of the text of a ToolTip.</returns>
		public static Brush InfoText => FromSystemColor(SystemColors.InfoText);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of a menu's background.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of a menu's background.</returns>
		public static Brush Menu => FromSystemColor(SystemColors.Menu);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of a menu bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of a menu bar.</returns>
		public static Brush MenuBar => FromSystemColor(SystemColors.MenuBar);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color used to highlight menu items when the menu appears as a flat menu.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color used to highlight menu items when the menu appears as a flat menu.</returns>
		public static Brush MenuHighlight => FromSystemColor(SystemColors.MenuHighlight);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of a menu's text.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of a menu's text.</returns>
		public static Brush MenuText => FromSystemColor(SystemColors.MenuText);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of a scroll bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of a scroll bar.</returns>
		public static Brush ScrollBar => FromSystemColor(SystemColors.ScrollBar);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background in the client area of a window.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background in the client area of a window.</returns>
		public static Brush Window => FromSystemColor(SystemColors.Window);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of a window frame.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of a window frame.</returns>
		public static Brush WindowFrame => FromSystemColor(SystemColors.WindowFrame);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text in the client area of a window.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text in the client area of a window.</returns>
		public static Brush WindowText => FromSystemColor(SystemColors.WindowText);

		/// <summary>Creates a <see cref="T:System.Drawing.Brush" /> from the specified <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <param name="c">The <see cref="T:System.Drawing.Color" /> structure from which to create the <see cref="T:System.Drawing.Brush" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Brush" /> this method creates.</returns>
		public static Brush FromSystemColor(Color c)
		{
			if (!c.IsSystemColor())
			{
				throw new ArgumentException(global::SR.Format("The color {0} is not a system color.", c.ToString()));
			}
			Brush[] array = (Brush[])SafeNativeMethods.Gdip.ThreadData[s_systemBrushesKey];
			if (array == null)
			{
				array = new Brush[33];
				SafeNativeMethods.Gdip.ThreadData[s_systemBrushesKey] = array;
			}
			int num = (int)c.ToKnownColor();
			if (num > 167)
			{
				num -= 141;
			}
			num--;
			if (array[num] == null)
			{
				array[num] = new SolidBrush(c, immutable: true);
			}
			return array[num];
		}

		internal SystemBrushes()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Each property of the <see cref="T:System.Drawing.TextureBrush" /> class is a <see cref="T:System.Drawing.Brush" /> object that uses an image to fill the interior of a shape. This class cannot be inherited.</summary>
	public sealed class TextureBrush : Brush
	{
		/// <summary>Gets or sets a copy of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> object that defines a local geometric transformation for the image associated with this <see cref="T:System.Drawing.TextureBrush" /> object.</summary>
		/// <returns>A copy of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> object that defines a geometric transformation that applies only to fills drawn by using this <see cref="T:System.Drawing.TextureBrush" /> object.</returns>
		public Matrix Transform
		{
			get
			{
				Matrix matrix = new Matrix();
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipGetTextureTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix)));
				return matrix;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipSetTextureTransform(new HandleRef(this, base.NativeBrush), new HandleRef(value, value.nativeMatrix)));
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.WrapMode" /> enumeration that indicates the wrap mode for this <see cref="T:System.Drawing.TextureBrush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> enumeration that specifies how fills drawn by using this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> object are tiled.</returns>
		public WrapMode WrapMode
		{
			get
			{
				int wrapMode = 0;
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipGetTextureWrapMode(new HandleRef(this, base.NativeBrush), out wrapMode));
				return (WrapMode)wrapMode;
			}
			set
			{
				if (value < WrapMode.Tile || value > WrapMode.Clamp)
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(WrapMode));
				}
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipSetTextureWrapMode(new HandleRef(this, base.NativeBrush), (int)value));
			}
		}

		/// <summary>Gets the <see cref="T:System.Drawing.Image" /> object associated with this <see cref="T:System.Drawing.TextureBrush" /> object.</summary>
		/// <returns>An <see cref="T:System.Drawing.Image" /> object that represents the image with which this <see cref="T:System.Drawing.TextureBrush" /> object fills shapes.</returns>
		public Image Image
		{
			get
			{
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipGetTextureImage(new HandleRef(this, base.NativeBrush), out var image));
				return Image.CreateImageObject(image);
			}
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image.</summary>
		/// <param name="bitmap">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		public TextureBrush(Image bitmap)
			: this(bitmap, WrapMode.Tile)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image and wrap mode.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		/// <param name="wrapMode">A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> enumeration that specifies how this <see cref="T:System.Drawing.TextureBrush" /> object is tiled.</param>
		public TextureBrush(Image image, WrapMode wrapMode)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (wrapMode < WrapMode.Tile || wrapMode > WrapMode.Clamp)
			{
				throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
			}
			IntPtr texture = IntPtr.Zero;
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipCreateTexture(new HandleRef(image, image.nativeImage), (int)wrapMode, out texture));
			SetNativeBrushInternal(texture);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image, wrap mode, and bounding rectangle.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		/// <param name="wrapMode">A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> enumeration that specifies how this <see cref="T:System.Drawing.TextureBrush" /> object is tiled.</param>
		/// <param name="dstRect">A <see cref="T:System.Drawing.RectangleF" /> structure that represents the bounding rectangle for this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		public TextureBrush(Image image, WrapMode wrapMode, RectangleF dstRect)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (wrapMode < WrapMode.Tile || wrapMode > WrapMode.Clamp)
			{
				throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
			}
			IntPtr texture = IntPtr.Zero;
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipCreateTexture2(new HandleRef(image, image.nativeImage), (int)wrapMode, dstRect.X, dstRect.Y, dstRect.Width, dstRect.Height, out texture));
			SetNativeBrushInternal(texture);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image, wrap mode, and bounding rectangle.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		/// <param name="wrapMode">A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> enumeration that specifies how this <see cref="T:System.Drawing.TextureBrush" /> object is tiled.</param>
		/// <param name="dstRect">A <see cref="T:System.Drawing.Rectangle" /> structure that represents the bounding rectangle for this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		public TextureBrush(Image image, WrapMode wrapMode, Rectangle dstRect)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (wrapMode < WrapMode.Tile || wrapMode > WrapMode.Clamp)
			{
				throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
			}
			IntPtr texture = IntPtr.Zero;
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipCreateTexture2I(new HandleRef(image, image.nativeImage), (int)wrapMode, dstRect.X, dstRect.Y, dstRect.Width, dstRect.Height, out texture));
			SetNativeBrushInternal(texture);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image and bounding rectangle.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		/// <param name="dstRect">A <see cref="T:System.Drawing.RectangleF" /> structure that represents the bounding rectangle for this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		public TextureBrush(Image image, RectangleF dstRect)
			: this(image, dstRect, null)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image, bounding rectangle, and image attributes.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		/// <param name="dstRect">A <see cref="T:System.Drawing.RectangleF" /> structure that represents the bounding rectangle for this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		/// <param name="imageAttr">An <see cref="T:System.Drawing.Imaging.ImageAttributes" /> object that contains additional information about the image used by this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		public TextureBrush(Image image, RectangleF dstRect, ImageAttributes imageAttr)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			IntPtr texture = IntPtr.Zero;
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipCreateTextureIA(new HandleRef(image, image.nativeImage), new HandleRef(imageAttr, imageAttr?.nativeImageAttributes ?? IntPtr.Zero), dstRect.X, dstRect.Y, dstRect.Width, dstRect.Height, out texture));
			SetNativeBrushInternal(texture);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image and bounding rectangle.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		/// <param name="dstRect">A <see cref="T:System.Drawing.Rectangle" /> structure that represents the bounding rectangle for this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		public TextureBrush(Image image, Rectangle dstRect)
			: this(image, dstRect, null)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image, bounding rectangle, and image attributes.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		/// <param name="dstRect">A <see cref="T:System.Drawing.Rectangle" /> structure that represents the bounding rectangle for this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		/// <param name="imageAttr">An <see cref="T:System.Drawing.Imaging.ImageAttributes" /> object that contains additional information about the image used by this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		public TextureBrush(Image image, Rectangle dstRect, ImageAttributes imageAttr)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			IntPtr texture = IntPtr.Zero;
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipCreateTextureIAI(new HandleRef(image, image.nativeImage), new HandleRef(imageAttr, imageAttr?.nativeImageAttributes ?? IntPtr.Zero), dstRect.X, dstRect.Y, dstRect.Width, dstRect.Height, out texture));
			SetNativeBrushInternal(texture);
		}

		internal TextureBrush(IntPtr nativeBrush)
		{
			SetNativeBrushInternal(nativeBrush);
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.TextureBrush" /> object.</summary>
		/// <returns>The <see cref="T:System.Drawing.TextureBrush" /> object this method creates, cast as an <see cref="T:System.Object" /> object.</returns>
		public override object Clone()
		{
			IntPtr clonedBrush = IntPtr.Zero;
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipCloneBrush(new HandleRef(this, base.NativeBrush), out clonedBrush));
			return new TextureBrush(clonedBrush);
		}

		/// <summary>Resets the <see langword="Transform" /> property of this <see cref="T:System.Drawing.TextureBrush" /> object to identity.</summary>
		public void ResetTransform()
		{
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipResetTextureTransform(new HandleRef(this, base.NativeBrush)));
		}

		/// <summary>Multiplies the <see cref="T:System.Drawing.Drawing2D.Matrix" /> object that represents the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> object by prepending the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> object.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> object by which to multiply the geometric transformation.</param>
		public void MultiplyTransform(Matrix matrix)
		{
			MultiplyTransform(matrix, MatrixOrder.Prepend);
		}

		/// <summary>Multiplies the <see cref="T:System.Drawing.Drawing2D.Matrix" /> object that represents the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> object in the specified order.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> object by which to multiply the geometric transformation.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> enumeration that specifies the order in which to multiply the two matrices.</param>
		public void MultiplyTransform(Matrix matrix, MatrixOrder order)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (!(matrix.nativeMatrix == IntPtr.Zero))
			{
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipMultiplyTextureTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix), order));
			}
		}

		/// <summary>Translates the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified dimensions. This method prepends the translation to the transformation.</summary>
		/// <param name="dx">The dimension by which to translate the transformation in the x direction.</param>
		/// <param name="dy">The dimension by which to translate the transformation in the y direction.</param>
		public void TranslateTransform(float dx, float dy)
		{
			TranslateTransform(dx, dy, MatrixOrder.Prepend);
		}

		/// <summary>Translates the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified dimensions in the specified order.</summary>
		/// <param name="dx">The dimension by which to translate the transformation in the x direction.</param>
		/// <param name="dy">The dimension by which to translate the transformation in the y direction.</param>
		/// <param name="order">The order (prepend or append) in which to apply the translation.</param>
		public void TranslateTransform(float dx, float dy, MatrixOrder order)
		{
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipTranslateTextureTransform(new HandleRef(this, base.NativeBrush), dx, dy, order));
		}

		/// <summary>Scales the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified amounts. This method prepends the scaling matrix to the transformation.</summary>
		/// <param name="sx">The amount by which to scale the transformation in the x direction.</param>
		/// <param name="sy">The amount by which to scale the transformation in the y direction.</param>
		public void ScaleTransform(float sx, float sy)
		{
			ScaleTransform(sx, sy, MatrixOrder.Prepend);
		}

		/// <summary>Scales the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified amounts in the specified order.</summary>
		/// <param name="sx">The amount by which to scale the transformation in the x direction.</param>
		/// <param name="sy">The amount by which to scale the transformation in the y direction.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> enumeration that specifies whether to append or prepend the scaling matrix.</param>
		public void ScaleTransform(float sx, float sy, MatrixOrder order)
		{
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipScaleTextureTransform(new HandleRef(this, base.NativeBrush), sx, sy, order));
		}

		/// <summary>Rotates the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified amount. This method prepends the rotation to the transformation.</summary>
		/// <param name="angle">The angle of rotation.</param>
		public void RotateTransform(float angle)
		{
			RotateTransform(angle, MatrixOrder.Prepend);
		}

		/// <summary>Rotates the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified amount in the specified order.</summary>
		/// <param name="angle">The angle of rotation.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> enumeration that specifies whether to append or prepend the rotation matrix.</param>
		public void RotateTransform(float angle, MatrixOrder order)
		{
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipRotateTextureTransform(new HandleRef(this, base.NativeBrush), angle, order));
		}
	}
	[SuppressUnmanagedCodeSecurity]
	internal class UnsafeNativeMethods
	{
		[ComImport]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		[Guid("0000000C-0000-0000-C000-000000000046")]
		public interface IStream
		{
			int Read([In] IntPtr buf, [In] int len);

			int Write([In] IntPtr buf, [In] int len);

			[return: MarshalAs(UnmanagedType.I8)]
			long Seek([In][MarshalAs(UnmanagedType.I8)] long dlibMove, [In] int dwOrigin);

			void SetSize([In][MarshalAs(UnmanagedType.I8)] long libNewSize);

			[return: MarshalAs(UnmanagedType.I8)]
			long CopyTo([In][MarshalAs(UnmanagedType.Interface)] IStream pstm, [In][MarshalAs(UnmanagedType.I8)] long cb, [Out][MarshalAs(UnmanagedType.LPArray)] long[] pcbRead);

			void Commit([In] int grfCommitFlags);

			void Revert();

			void LockRegion([In][MarshalAs(UnmanagedType.I8)] long libOffset, [In][MarshalAs(UnmanagedType.I8)] long cb, [In] int dwLockType);

			void UnlockRegion([In][MarshalAs(UnmanagedType.I8)] long libOffset, [In][MarshalAs(UnmanagedType.I8)] long cb, [In] int dwLockType);

			void Stat([In] IntPtr pStatstg, [In] int grfStatFlag);

			[return: MarshalAs(UnmanagedType.Interface)]
			IStream Clone();
		}

		internal class ComStreamFromDataStream : IStream
		{
			protected Stream dataStream;

			private long _virtualPosition = -1L;

			internal ComStreamFromDataStream(Stream dataStream)
			{
				this.dataStream = dataStream ?? throw new ArgumentNullException("dataStream");
			}

			private void ActualizeVirtualPosition()
			{
				if (_virtualPosition != -1)
				{
					if (_virtualPosition > dataStream.Length)
					{
						dataStream.SetLength(_virtualPosition);
					}
					dataStream.Position = _virtualPosition;
					_virtualPosition = -1L;
				}
			}

			public virtual IStream Clone()
			{
				NotImplemented();
				return null;
			}

			public virtual void Commit(int grfCommitFlags)
			{
				dataStream.Flush();
				ActualizeVirtualPosition();
			}

			public virtual long CopyTo(IStream pstm, long cb, long[] pcbRead)
			{
				int num = 4096;
				IntPtr intPtr = Marshal.AllocHGlobal(num);
				if (intPtr == IntPtr.Zero)
				{
					throw new OutOfMemoryException();
				}
				long num2 = 0L;
				try
				{
					int num4;
					for (; num2 < cb; num2 += num4)
					{
						int num3 = num;
						if (num2 + num3 > cb)
						{
							num3 = (int)(cb - num2);
						}
						num4 = Read(intPtr, num3);
						if (num4 == 0)
						{
							break;
						}
						if (pstm.Write(intPtr, num4) != num4)
						{
							throw EFail("Wrote an incorrect number of bytes");
						}
					}
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (pcbRead != null && pcbRead.Length != 0)
				{
					pcbRead[0] = num2;
				}
				return num2;
			}

			public virtual void LockRegion(long libOffset, long cb, int dwLockType)
			{
			}

			protected static ExternalException EFail(string msg)
			{
				throw new ExternalException(msg, -2147467259);
			}

			protected static void NotImplemented()
			{
				throw new ExternalException(global::SR.Format("Not implemented."), -2147467263);
			}

			public virtual int Read(IntPtr buf, int length)
			{
				byte[] array = new byte[length];
				int result = Read(array, length);
				Marshal.Copy(array, 0, buf, length);
				return result;
			}

			public virtual int Read(byte[] buffer, int length)
			{
				ActualizeVirtualPosition();
				return dataStream.Read(buffer, 0, length);
			}

			public virtual void Revert()
			{
				NotImplemented();
			}

			public virtual long Seek(long offset, int origin)
			{
				long num = _virtualPosition;
				if (_virtualPosition == -1)
				{
					num = dataStream.Position;
				}
				long length = dataStream.Length;
				switch (origin)
				{
				case 0:
					if (offset <= length)
					{
						dataStream.Position = offset;
						_virtualPosition = -1L;
					}
					else
					{
						_virtualPosition = offset;
					}
					break;
				case 2:
					if (offset <= 0)
					{
						dataStream.Position = length + offset;
						_virtualPosition = -1L;
					}
					else
					{
						_virtualPosition = length + offset;
					}
					break;
				case 1:
					if (offset + num <= length)
					{
						dataStream.Position = num + offset;
						_virtualPosition = -1L;
					}
					else
					{
						_virtualPosition = offset + num;
					}
					break;
				}
				if (_virtualPosition != -1)
				{
					return _virtualPosition;
				}
				return dataStream.Position;
			}

			public virtual void SetSize(long value)
			{
				dataStream.SetLength(value);
			}

			public virtual void Stat(IntPtr pstatstg, int grfStatFlag)
			{
				NotImplemented();
			}

			public virtual void UnlockRegion(long libOffset, long cb, int dwLockType)
			{
			}

			public virtual int Write(IntPtr buf, int length)
			{
				byte[] array = new byte[length];
				Marshal.Copy(buf, array, 0, length);
				return Write(array, length);
			}

			public virtual int Write(byte[] buffer, int length)
			{
				ActualizeVirtualPosition();
				dataStream.Write(buffer, 0, length);
				return length;
			}
		}

		[DllImport("kernel32", CharSet = CharSet.Auto, EntryPoint = "RtlMoveMemory", ExactSpelling = true, SetLastError = true)]
		public static extern void CopyMemory(HandleRef destData, HandleRef srcData, int size);

		[DllImport("user32", CharSet = CharSet.Auto, EntryPoint = "GetDC", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntGetDC(HandleRef hWnd);

		public static IntPtr GetDC(HandleRef hWnd)
		{
			return System.Internal.HandleCollector.Add(IntGetDC(hWnd), SafeNativeMethods.CommonHandles.HDC);
		}

		[DllImport("gdi32", CharSet = CharSet.Auto, EntryPoint = "DeleteDC", ExactSpelling = true, SetLastError = true)]
		private static extern bool IntDeleteDC(HandleRef hDC);

		public static bool DeleteDC(HandleRef hDC)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hDC, SafeNativeMethods.CommonHandles.GDI);
			return IntDeleteDC(hDC);
		}

		[DllImport("user32", CharSet = CharSet.Auto, EntryPoint = "ReleaseDC", ExactSpelling = true, SetLastError = true)]
		private static extern int IntReleaseDC(HandleRef hWnd, HandleRef hDC);

		public static int ReleaseDC(HandleRef hWnd, HandleRef hDC)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hDC, SafeNativeMethods.CommonHandles.HDC);
			return IntReleaseDC(hWnd, hDC);
		}

		[DllImport("gdi32", CharSet = CharSet.Auto, EntryPoint = "CreateCompatibleDC", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntCreateCompatibleDC(HandleRef hDC);

		public static IntPtr CreateCompatibleDC(HandleRef hDC)
		{
			return System.Internal.HandleCollector.Add(IntCreateCompatibleDC(hDC), SafeNativeMethods.CommonHandles.GDI);
		}

		[DllImport("gdi32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr GetStockObject(int nIndex);

		[DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetSystemDefaultLCID();

		[DllImport("user32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetSystemMetrics(int nIndex);

		[DllImport("user32", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern bool SystemParametersInfo(int uiAction, int uiParam, [In][Out] NativeMethods.NONCLIENTMETRICS pvParam, int fWinIni);

		[DllImport("user32", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern bool SystemParametersInfo(int uiAction, int uiParam, [In][Out] SafeNativeMethods.LOGFONT pvParam, int fWinIni);

		[DllImport("gdi32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetDeviceCaps(HandleRef hDC, int nIndex);

		[DllImport("gdi32", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetObjectType(HandleRef hObject);
	}
	/// <summary>Encapsulates a GDI+ bitmap, which consists of the pixel data for a graphics image and its attributes. A <see cref="T:System.Drawing.Bitmap" /> is an object used to work with images defined by pixel data.</summary>
	[Serializable]
	[ComVisible(true)]
	[Editor("System.Drawing.Design.BitmapEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	public sealed class Bitmap : Image
	{
		private Bitmap()
		{
		}

		internal Bitmap(IntPtr ptr)
		{
			nativeObject = ptr;
		}

		internal Bitmap(IntPtr ptr, Stream stream)
		{
			if (GDIPlus.RunningOnWindows())
			{
				base.stream = stream;
			}
			nativeObject = ptr;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class with the specified size.</summary>
		/// <param name="width">The width, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="height">The height, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public Bitmap(int width, int height)
			: this(width, height, PixelFormat.Format32bppArgb)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class with the specified size and with the resolution of the specified <see cref="T:System.Drawing.Graphics" /> object.</summary>
		/// <param name="width">The width, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="height">The height, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="g">The <see cref="T:System.Drawing.Graphics" /> object that specifies the resolution for the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="g" /> is <see langword="null" />.</exception>
		public Bitmap(int width, int height, Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreateBitmapFromGraphics(width, height, g.nativeObject, out var bitmap));
			nativeObject = bitmap;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class with the specified size and format.</summary>
		/// <param name="width">The width, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="height">The height, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="format">The pixel format for the new <see cref="T:System.Drawing.Bitmap" />. This must specify a value that begins with Format.</param>
		/// <exception cref="T:System.ArgumentException">A <see cref="T:System.Drawing.Imaging.PixelFormat" /> value is specified whose name does not start with Format. For example, specifying <see cref="F:System.Drawing.Imaging.PixelFormat.Gdi" /> will cause an <see cref="T:System.ArgumentException" />, but <see cref="F:System.Drawing.Imaging.PixelFormat.Format48bppRgb" /> will not.</exception>
		public Bitmap(int width, int height, PixelFormat format)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateBitmapFromScan0(width, height, 0, format, IntPtr.Zero, out var bmp));
			nativeObject = bmp;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from the specified existing image.</summary>
		/// <param name="original">The <see cref="T:System.Drawing.Image" /> from which to create the new <see cref="T:System.Drawing.Bitmap" />.</param>
		public Bitmap(Image original)
			: this(original, original.Width, original.Height)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from the specified data stream.</summary>
		/// <param name="stream">The data stream used to load the image.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="stream" /> does not contain image data or is <see langword="null" />.  
		/// -or-  
		/// <paramref name="stream" /> contains a PNG image file with a single dimension greater than 65,535 pixels.</exception>
		public Bitmap(Stream stream)
			: this(stream, useIcm: false)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from the specified file.</summary>
		/// <param name="filename">The bitmap file name and path.</param>
		/// <exception cref="T:System.IO.FileNotFoundException">The specified file is not found.</exception>
		public Bitmap(string filename)
			: this(filename, useIcm: false)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from the specified existing image, scaled to the specified size.</summary>
		/// <param name="original">The <see cref="T:System.Drawing.Image" /> from which to create the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="newSize">The <see cref="T:System.Drawing.Size" /> structure that represent the size of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public Bitmap(Image original, Size newSize)
			: this(original, newSize.Width, newSize.Height)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from the specified data stream.</summary>
		/// <param name="stream">The data stream used to load the image.</param>
		/// <param name="useIcm">
		///   <see langword="true" /> to use color correction for this <see cref="T:System.Drawing.Bitmap" />; otherwise, <see langword="false" />.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="stream" /> does not contain image data or is <see langword="null" />.  
		/// -or-  
		/// <paramref name="stream" /> contains a PNG image file with a single dimension greater than 65,535 pixels.</exception>
		public Bitmap(Stream stream, bool useIcm)
		{
			nativeObject = Image.InitFromStream(stream);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from the specified file.</summary>
		/// <param name="filename">The name of the bitmap file.</param>
		/// <param name="useIcm">
		///   <see langword="true" /> to use color correction for this <see cref="T:System.Drawing.Bitmap" />; otherwise, <see langword="false" />.</param>
		public Bitmap(string filename, bool useIcm)
		{
			if (filename == null)
			{
				throw new ArgumentNullException("filename");
			}
			GDIPlus.CheckStatus((!useIcm) ? GDIPlus.GdipCreateBitmapFromFile(filename, out var bitmap) : GDIPlus.GdipCreateBitmapFromFileICM(filename, out bitmap));
			nativeObject = bitmap;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from a specified resource.</summary>
		/// <param name="type">The class used to extract the resource.</param>
		/// <param name="resource">The name of the resource.</param>
		public Bitmap(Type type, string resource)
		{
			if (resource == null)
			{
				throw new ArgumentException("resource");
			}
			if (type == null)
			{
				throw new NullReferenceException();
			}
			Stream manifestResourceStream = type.GetTypeInfo().Assembly.GetManifestResourceStream(type, resource);
			if (manifestResourceStream == null)
			{
				throw new FileNotFoundException(global::Locale.GetText("Resource '{0}' was not found.", resource));
			}
			nativeObject = Image.InitFromStream(manifestResourceStream);
			if (GDIPlus.RunningOnWindows())
			{
				stream = manifestResourceStream;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from the specified existing image, scaled to the specified size.</summary>
		/// <param name="original">The <see cref="T:System.Drawing.Image" /> from which to create the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="width">The width, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="height">The height, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public Bitmap(Image original, int width, int height)
			: this(width, height, PixelFormat.Format32bppArgb)
		{
			Graphics graphics = Graphics.FromImage(this);
			graphics.DrawImage(original, 0, 0, width, height);
			graphics.Dispose();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class with the specified size, pixel format, and pixel data.</summary>
		/// <param name="width">The width, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="height">The height, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="stride">Integer that specifies the byte offset between the beginning of one scan line and the next. This is usually (but not necessarily) the number of bytes in the pixel format (for example, 2 for 16 bits per pixel) multiplied by the width of the bitmap. The value passed to this parameter must be a multiple of four.</param>
		/// <param name="format">The pixel format for the new <see cref="T:System.Drawing.Bitmap" />. This must specify a value that begins with Format.</param>
		/// <param name="scan0">Pointer to an array of bytes that contains the pixel data.</param>
		/// <exception cref="T:System.ArgumentException">A <see cref="T:System.Drawing.Imaging.PixelFormat" /> value is specified whose name does not start with Format. For example, specifying <see cref="F:System.Drawing.Imaging.PixelFormat.Gdi" /> will cause an <see cref="T:System.ArgumentException" />, but <see cref="F:System.Drawing.Imaging.PixelFormat.Format48bppRgb" /> will not.</exception>
		public Bitmap(int width, int height, int stride, PixelFormat format, IntPtr scan0)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateBitmapFromScan0(width, height, stride, format, scan0, out var bmp));
			nativeObject = bmp;
		}

		private Bitmap(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		/// <summary>Gets the color of the specified pixel in this <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <param name="x">The x-coordinate of the pixel to retrieve.</param>
		/// <param name="y">The y-coordinate of the pixel to retrieve.</param>
		/// <returns>A <see cref="T:System.Drawing.Color" /> structure that represents the color of the specified pixel.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="x" /> is less than 0, or greater than or equal to <see cref="P:System.Drawing.Image.Width" />.  
		/// -or-  
		/// <paramref name="y" /> is less than 0, or greater than or equal to <see cref="P:System.Drawing.Image.Height" />.</exception>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public Color GetPixel(int x, int y)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipBitmapGetPixel(nativeObject, x, y, out var argb));
			return Color.FromArgb(argb);
		}

		/// <summary>Sets the color of the specified pixel in this <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <param name="x">The x-coordinate of the pixel to set.</param>
		/// <param name="y">The y-coordinate of the pixel to set.</param>
		/// <param name="color">A <see cref="T:System.Drawing.Color" /> structure that represents the color to assign to the specified pixel.</param>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public void SetPixel(int x, int y, Color color)
		{
			Status num = GDIPlus.GdipBitmapSetPixel(nativeObject, x, y, color.ToArgb());
			if (num == Status.InvalidParameter && (base.PixelFormat & PixelFormat.Indexed) != PixelFormat.Undefined)
			{
				throw new InvalidOperationException(global::Locale.GetText("SetPixel cannot be called on indexed bitmaps."));
			}
			GDIPlus.CheckStatus(num);
		}

		/// <summary>Creates a copy of the section of this <see cref="T:System.Drawing.Bitmap" /> defined by <see cref="T:System.Drawing.Rectangle" /> structure and with a specified <see cref="T:System.Drawing.Imaging.PixelFormat" /> enumeration.</summary>
		/// <param name="rect">Defines the portion of this <see cref="T:System.Drawing.Bitmap" /> to copy. Coordinates are relative to this <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="format">The pixel format for the new <see cref="T:System.Drawing.Bitmap" />. This must specify a value that begins with Format.</param>
		/// <returns>The new <see cref="T:System.Drawing.Bitmap" /> that this method creates.</returns>
		/// <exception cref="T:System.OutOfMemoryException">
		///   <paramref name="rect" /> is outside of the source bitmap bounds.</exception>
		/// <exception cref="T:System.ArgumentException">The height or width of <paramref name="rect" /> is 0.  
		///  -or-  
		///  A <see cref="T:System.Drawing.Imaging.PixelFormat" /> value is specified whose name does not start with Format. For example, specifying <see cref="F:System.Drawing.Imaging.PixelFormat.Gdi" /> will cause an <see cref="T:System.ArgumentException" />, but <see cref="F:System.Drawing.Imaging.PixelFormat.Format48bppRgb" /> will not.</exception>
		public Bitmap Clone(Rectangle rect, PixelFormat format)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCloneBitmapAreaI(rect.X, rect.Y, rect.Width, rect.Height, format, nativeObject, out var bitmap));
			return new Bitmap(bitmap);
		}

		/// <summary>Creates a copy of the section of this <see cref="T:System.Drawing.Bitmap" /> defined with a specified <see cref="T:System.Drawing.Imaging.PixelFormat" /> enumeration.</summary>
		/// <param name="rect">Defines the portion of this <see cref="T:System.Drawing.Bitmap" /> to copy.</param>
		/// <param name="format">Specifies the <see cref="T:System.Drawing.Imaging.PixelFormat" /> enumeration for the destination <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Bitmap" /> that this method creates.</returns>
		/// <exception cref="T:System.OutOfMemoryException">
		///   <paramref name="rect" /> is outside of the source bitmap bounds.</exception>
		/// <exception cref="T:System.ArgumentException">The height or width of <paramref name="rect" /> is 0.</exception>
		public Bitmap Clone(RectangleF rect, PixelFormat format)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCloneBitmapArea(rect.X, rect.Y, rect.Width, rect.Height, format, nativeObject, out var bitmap));
			return new Bitmap(bitmap);
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Bitmap" /> from a Windows handle to an icon.</summary>
		/// <param name="hicon">A handle to an icon.</param>
		/// <returns>The <see cref="T:System.Drawing.Bitmap" /> that this method creates.</returns>
		public static Bitmap FromHicon(IntPtr hicon)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateBitmapFromHICON(hicon, out var bitmap));
			return new Bitmap(bitmap);
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Bitmap" /> from the specified Windows resource.</summary>
		/// <param name="hinstance">A handle to an instance of the executable file that contains the resource.</param>
		/// <param name="bitmapName">A string that contains the name of the resource bitmap.</param>
		/// <returns>The <see cref="T:System.Drawing.Bitmap" /> that this method creates.</returns>
		public static Bitmap FromResource(IntPtr hinstance, string bitmapName)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateBitmapFromResource(hinstance, bitmapName, out var bitmap));
			return new Bitmap(bitmap);
		}

		/// <summary>Creates a GDI bitmap object from this <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <returns>A handle to the GDI bitmap object that this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">The height or width of the bitmap is greater than <see cref="F:System.Int16.MaxValue" />.</exception>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public IntPtr GetHbitmap()
		{
			return GetHbitmap(Color.Gray);
		}

		/// <summary>Creates a GDI bitmap object from this <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <param name="background">A <see cref="T:System.Drawing.Color" /> structure that specifies the background color. This parameter is ignored if the bitmap is totally opaque.</param>
		/// <returns>A handle to the GDI bitmap object that this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">The height or width of the bitmap is greater than <see cref="F:System.Int16.MaxValue" />.</exception>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public IntPtr GetHbitmap(Color background)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateHBITMAPFromBitmap(nativeObject, out var HandleBmp, background.ToArgb()));
			return HandleBmp;
		}

		/// <summary>Returns the handle to an icon.</summary>
		/// <returns>A Windows handle to an icon with the same image as the <see cref="T:System.Drawing.Bitmap" />.</returns>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public IntPtr GetHicon()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateHICONFromBitmap(nativeObject, out var HandleIcon));
			return HandleIcon;
		}

		/// <summary>Locks a <see cref="T:System.Drawing.Bitmap" /> into system memory.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the <see cref="T:System.Drawing.Bitmap" /> to lock.</param>
		/// <param name="flags">An <see cref="T:System.Drawing.Imaging.ImageLockMode" /> enumeration that specifies the access level (read/write) for the <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="format">A <see cref="T:System.Drawing.Imaging.PixelFormat" /> enumeration that specifies the data format of this <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <returns>A <see cref="T:System.Drawing.Imaging.BitmapData" /> that contains information about this lock operation.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="T:System.Drawing.Imaging.PixelFormat" /> is not a specific bits-per-pixel value.  
		///  -or-  
		///  The incorrect <see cref="T:System.Drawing.Imaging.PixelFormat" /> is passed in for a bitmap.</exception>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public BitmapData LockBits(Rectangle rect, ImageLockMode flags, PixelFormat format)
		{
			BitmapData bitmapData = new BitmapData();
			return LockBits(rect, flags, format, bitmapData);
		}

		/// <summary>Locks a <see cref="T:System.Drawing.Bitmap" /> into system memory</summary>
		/// <param name="rect">A rectangle structure that specifies the portion of the <see cref="T:System.Drawing.Bitmap" /> to lock.</param>
		/// <param name="flags">One of the <see cref="T:System.Drawing.Imaging.ImageLockMode" /> values that specifies the access level (read/write) for the <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="format">One of the <see cref="T:System.Drawing.Imaging.PixelFormat" /> values that specifies the data format of the <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="bitmapData">A <see cref="T:System.Drawing.Imaging.BitmapData" /> that contains information about the lock operation.</param>
		/// <returns>A <see cref="T:System.Drawing.Imaging.BitmapData" /> that contains information about the lock operation.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <see cref="T:System.Drawing.Imaging.PixelFormat" /> value is not a specific bits-per-pixel value.  
		/// -or-  
		/// The incorrect <see cref="T:System.Drawing.Imaging.PixelFormat" /> is passed in for a bitmap.</exception>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public BitmapData LockBits(Rectangle rect, ImageLockMode flags, PixelFormat format, BitmapData bitmapData)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipBitmapLockBits(nativeObject, ref rect, flags, format, bitmapData));
			return bitmapData;
		}

		/// <summary>Makes the default transparent color transparent for this <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <exception cref="T:System.InvalidOperationException">The image format of the <see cref="T:System.Drawing.Bitmap" /> is an icon format.</exception>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public void MakeTransparent()
		{
			Color pixel = GetPixel(0, 0);
			MakeTransparent(pixel);
		}

		/// <summary>Makes the specified color transparent for this <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <param name="transparentColor">The <see cref="T:System.Drawing.Color" /> structure that represents the color to make transparent.</param>
		/// <exception cref="T:System.InvalidOperationException">The image format of the <see cref="T:System.Drawing.Bitmap" /> is an icon format.</exception>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public void MakeTransparent(Color transparentColor)
		{
			Bitmap bitmap = new Bitmap(base.Width, base.Height, PixelFormat.Format32bppArgb);
			Graphics graphics = Graphics.FromImage(bitmap);
			Rectangle destRect = new Rectangle(0, 0, base.Width, base.Height);
			ImageAttributes imageAttributes = new ImageAttributes();
			imageAttributes.SetColorKey(transparentColor, transparentColor);
			graphics.DrawImage(this, destRect, 0, 0, base.Width, base.Height, GraphicsUnit.Pixel, imageAttributes);
			IntPtr intPtr = nativeObject;
			nativeObject = bitmap.nativeObject;
			bitmap.nativeObject = intPtr;
			graphics.Dispose();
			bitmap.Dispose();
			imageAttributes.Dispose();
		}

		/// <summary>Sets the resolution for this <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <param name="xDpi">The horizontal resolution, in dots per inch, of the <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="yDpi">The vertical resolution, in dots per inch, of the <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public void SetResolution(float xDpi, float yDpi)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipBitmapSetResolution(nativeObject, xDpi, yDpi));
		}

		/// <summary>Unlocks this <see cref="T:System.Drawing.Bitmap" /> from system memory.</summary>
		/// <param name="bitmapdata">A <see cref="T:System.Drawing.Imaging.BitmapData" /> that specifies information about the lock operation.</param>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public void UnlockBits(BitmapData bitmapdata)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipBitmapUnlockBits(nativeObject, bitmapdata));
		}
	}
	/// <summary>Brushes for all the standard colors. This class cannot be inherited.</summary>
	public sealed class Brushes
	{
		private static SolidBrush aliceBlue;

		private static SolidBrush antiqueWhite;

		private static SolidBrush aqua;

		private static SolidBrush aquamarine;

		private static SolidBrush azure;

		private static SolidBrush beige;

		private static SolidBrush bisque;

		private static SolidBrush black;

		private static SolidBrush blanchedAlmond;

		private static SolidBrush blue;

		private static SolidBrush blueViolet;

		private static SolidBrush brown;

		private static SolidBrush burlyWood;

		private static SolidBrush cadetBlue;

		private static SolidBrush chartreuse;

		private static SolidBrush chocolate;

		private static SolidBrush coral;

		private static SolidBrush cornflowerBlue;

		private static SolidBrush cornsilk;

		private static SolidBrush crimson;

		private static SolidBrush cyan;

		private static SolidBrush darkBlue;

		private static SolidBrush darkCyan;

		private static SolidBrush darkGoldenrod;

		private static SolidBrush darkGray;

		private static SolidBrush darkGreen;

		private static SolidBrush darkKhaki;

		private static SolidBrush darkMagenta;

		private static SolidBrush darkOliveGreen;

		private static SolidBrush darkOrange;

		private static SolidBrush darkOrchid;

		private static SolidBrush darkRed;

		private static SolidBrush darkSalmon;

		private static SolidBrush darkSeaGreen;

		private static SolidBrush darkSlateBlue;

		private static SolidBrush darkSlateGray;

		private static SolidBrush darkTurquoise;

		private static SolidBrush darkViolet;

		private static SolidBrush deepPink;

		private static SolidBrush deepSkyBlue;

		private static SolidBrush dimGray;

		private static SolidBrush dodgerBlue;

		private static SolidBrush firebrick;

		private static SolidBrush floralWhite;

		private static SolidBrush forestGreen;

		private static SolidBrush fuchsia;

		private static SolidBrush gainsboro;

		private static SolidBrush ghostWhite;

		private static SolidBrush gold;

		private static SolidBrush goldenrod;

		private static SolidBrush gray;

		private static SolidBrush green;

		private static SolidBrush greenYellow;

		private static SolidBrush honeydew;

		private static SolidBrush hotPink;

		private static SolidBrush indianRed;

		private static SolidBrush indigo;

		private static SolidBrush ivory;

		private static SolidBrush khaki;

		private static SolidBrush lavender;

		private static SolidBrush lavenderBlush;

		private static SolidBrush lawnGreen;

		private static SolidBrush lemonChiffon;

		private static SolidBrush lightBlue;

		private static SolidBrush lightCoral;

		private static SolidBrush lightCyan;

		private static SolidBrush lightGoldenrodYellow;

		private static SolidBrush lightGray;

		private static SolidBrush lightGreen;

		private static SolidBrush lightPink;

		private static SolidBrush lightSalmon;

		private static SolidBrush lightSeaGreen;

		private static SolidBrush lightSkyBlue;

		private static SolidBrush lightSlateGray;

		private static SolidBrush lightSteelBlue;

		private static SolidBrush lightYellow;

		private static SolidBrush lime;

		private static SolidBrush limeGreen;

		private static SolidBrush linen;

		private static SolidBrush magenta;

		private static SolidBrush maroon;

		private static SolidBrush mediumAquamarine;

		private static SolidBrush mediumBlue;

		private static SolidBrush mediumOrchid;

		private static SolidBrush mediumPurple;

		private static SolidBrush mediumSeaGreen;

		private static SolidBrush mediumSlateBlue;

		private static SolidBrush mediumSpringGreen;

		private static SolidBrush mediumTurquoise;

		private static SolidBrush mediumVioletRed;

		private static SolidBrush midnightBlue;

		private static SolidBrush mintCream;

		private static SolidBrush mistyRose;

		private static SolidBrush moccasin;

		private static SolidBrush navajoWhite;

		private static SolidBrush navy;

		private static SolidBrush oldLace;

		private static SolidBrush olive;

		private static SolidBrush oliveDrab;

		private static SolidBrush orange;

		private static SolidBrush orangeRed;

		private static SolidBrush orchid;

		private static SolidBrush paleGoldenrod;

		private static SolidBrush paleGreen;

		private static SolidBrush paleTurquoise;

		private static SolidBrush paleVioletRed;

		private static SolidBrush papayaWhip;

		private static SolidBrush peachPuff;

		private static SolidBrush peru;

		private static SolidBrush pink;

		private static SolidBrush plum;

		private static SolidBrush powderBlue;

		private static SolidBrush purple;

		private static SolidBrush red;

		private static SolidBrush rosyBrown;

		private static SolidBrush royalBlue;

		private static SolidBrush saddleBrown;

		private static SolidBrush salmon;

		private static SolidBrush sandyBrown;

		private static SolidBrush seaGreen;

		private static SolidBrush seaShell;

		private static SolidBrush sienna;

		private static SolidBrush silver;

		private static SolidBrush skyBlue;

		private static SolidBrush slateBlue;

		private static SolidBrush slateGray;

		private static SolidBrush snow;

		private static SolidBrush springGreen;

		private static SolidBrush steelBlue;

		private static SolidBrush tan;

		private static SolidBrush teal;

		private static SolidBrush thistle;

		private static SolidBrush tomato;

		private static SolidBrush transparent;

		private static SolidBrush turquoise;

		private static SolidBrush violet;

		private static SolidBrush wheat;

		private static SolidBrush white;

		private static SolidBrush whiteSmoke;

		private static SolidBrush yellow;

		private static SolidBrush yellowGreen;

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush AliceBlue
		{
			get
			{
				if (aliceBlue == null)
				{
					aliceBlue = new SolidBrush(Color.AliceBlue);
				}
				return aliceBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush AntiqueWhite
		{
			get
			{
				if (antiqueWhite == null)
				{
					antiqueWhite = new SolidBrush(Color.AntiqueWhite);
				}
				return antiqueWhite;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Aqua
		{
			get
			{
				if (aqua == null)
				{
					aqua = new SolidBrush(Color.Aqua);
				}
				return aqua;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Aquamarine
		{
			get
			{
				if (aquamarine == null)
				{
					aquamarine = new SolidBrush(Color.Aquamarine);
				}
				return aquamarine;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Azure
		{
			get
			{
				if (azure == null)
				{
					azure = new SolidBrush(Color.Azure);
				}
				return azure;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Beige
		{
			get
			{
				if (beige == null)
				{
					beige = new SolidBrush(Color.Beige);
				}
				return beige;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Bisque
		{
			get
			{
				if (bisque == null)
				{
					bisque = new SolidBrush(Color.Bisque);
				}
				return bisque;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Black
		{
			get
			{
				if (black == null)
				{
					black = new SolidBrush(Color.Black);
				}
				return black;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush BlanchedAlmond
		{
			get
			{
				if (blanchedAlmond == null)
				{
					blanchedAlmond = new SolidBrush(Color.BlanchedAlmond);
				}
				return blanchedAlmond;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Blue
		{
			get
			{
				if (blue == null)
				{
					blue = new SolidBrush(Color.Blue);
				}
				return blue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush BlueViolet
		{
			get
			{
				if (blueViolet == null)
				{
					blueViolet = new SolidBrush(Color.BlueViolet);
				}
				return blueViolet;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Brown
		{
			get
			{
				if (brown == null)
				{
					brown = new SolidBrush(Color.Brown);
				}
				return brown;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush BurlyWood
		{
			get
			{
				if (burlyWood == null)
				{
					burlyWood = new SolidBrush(Color.BurlyWood);
				}
				return burlyWood;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush CadetBlue
		{
			get
			{
				if (cadetBlue == null)
				{
					cadetBlue = new SolidBrush(Color.CadetBlue);
				}
				return cadetBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Chartreuse
		{
			get
			{
				if (chartreuse == null)
				{
					chartreuse = new SolidBrush(Color.Chartreuse);
				}
				return chartreuse;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Chocolate
		{
			get
			{
				if (chocolate == null)
				{
					chocolate = new SolidBrush(Color.Chocolate);
				}
				return chocolate;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Coral
		{
			get
			{
				if (coral == null)
				{
					coral = new SolidBrush(Color.Coral);
				}
				return coral;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush CornflowerBlue
		{
			get
			{
				if (cornflowerBlue == null)
				{
					cornflowerBlue = new SolidBrush(Color.CornflowerBlue);
				}
				return cornflowerBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Cornsilk
		{
			get
			{
				if (cornsilk == null)
				{
					cornsilk = new SolidBrush(Color.Cornsilk);
				}
				return cornsilk;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Crimson
		{
			get
			{
				if (crimson == null)
				{
					crimson = new SolidBrush(Color.Crimson);
				}
				return crimson;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Cyan
		{
			get
			{
				if (cyan == null)
				{
					cyan = new SolidBrush(Color.Cyan);
				}
				return cyan;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkBlue
		{
			get
			{
				if (darkBlue == null)
				{
					darkBlue = new SolidBrush(Color.DarkBlue);
				}
				return darkBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkCyan
		{
			get
			{
				if (darkCyan == null)
				{
					darkCyan = new SolidBrush(Color.DarkCyan);
				}
				return darkCyan;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkGoldenrod
		{
			get
			{
				if (darkGoldenrod == null)
				{
					darkGoldenrod = new SolidBrush(Color.DarkGoldenrod);
				}
				return darkGoldenrod;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkGray
		{
			get
			{
				if (darkGray == null)
				{
					darkGray = new SolidBrush(Color.DarkGray);
				}
				return darkGray;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkGreen
		{
			get
			{
				if (darkGreen == null)
				{
					darkGreen = new SolidBrush(Color.DarkGreen);
				}
				return darkGreen;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkKhaki
		{
			get
			{
				if (darkKhaki == null)
				{
					darkKhaki = new SolidBrush(Color.DarkKhaki);
				}
				return darkKhaki;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkMagenta
		{
			get
			{
				if (darkMagenta == null)
				{
					darkMagenta = new SolidBrush(Color.DarkMagenta);
				}
				return darkMagenta;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkOliveGreen
		{
			get
			{
				if (darkOliveGreen == null)
				{
					darkOliveGreen = new SolidBrush(Color.DarkOliveGreen);
				}
				return darkOliveGreen;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkOrange
		{
			get
			{
				if (darkOrange == null)
				{
					darkOrange = new SolidBrush(Color.DarkOrange);
				}
				return darkOrange;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkOrchid
		{
			get
			{
				if (darkOrchid == null)
				{
					darkOrchid = new SolidBrush(Color.DarkOrchid);
				}
				return darkOrchid;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkRed
		{
			get
			{
				if (darkRed == null)
				{
					darkRed = new SolidBrush(Color.DarkRed);
				}
				return darkRed;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkSalmon
		{
			get
			{
				if (darkSalmon == null)
				{
					darkSalmon = new SolidBrush(Color.DarkSalmon);
				}
				return darkSalmon;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkSeaGreen
		{
			get
			{
				if (darkSeaGreen == null)
				{
					darkSeaGreen = new SolidBrush(Color.DarkSeaGreen);
				}
				return darkSeaGreen;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkSlateBlue
		{
			get
			{
				if (darkSlateBlue == null)
				{
					darkSlateBlue = new SolidBrush(Color.DarkSlateBlue);
				}
				return darkSlateBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkSlateGray
		{
			get
			{
				if (darkSlateGray == null)
				{
					darkSlateGray = new SolidBrush(Color.DarkSlateGray);
				}
				return darkSlateGray;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkTurquoise
		{
			get
			{
				if (darkTurquoise == null)
				{
					darkTurquoise = new SolidBrush(Color.DarkTurquoise);
				}
				return darkTurquoise;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkViolet
		{
			get
			{
				if (darkViolet == null)
				{
					darkViolet = new SolidBrush(Color.DarkViolet);
				}
				return darkViolet;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DeepPink
		{
			get
			{
				if (deepPink == null)
				{
					deepPink = new SolidBrush(Color.DeepPink);
				}
				return deepPink;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DeepSkyBlue
		{
			get
			{
				if (deepSkyBlue == null)
				{
					deepSkyBlue = new SolidBrush(Color.DeepSkyBlue);
				}
				return deepSkyBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DimGray
		{
			get
			{
				if (dimGray == null)
				{
					dimGray = new SolidBrush(Color.DimGray);
				}
				return dimGray;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DodgerBlue
		{
			get
			{
				if (dodgerBlue == null)
				{
					dodgerBlue = new SolidBrush(Color.DodgerBlue);
				}
				return dodgerBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Firebrick
		{
			get
			{
				if (firebrick == null)
				{
					firebrick = new SolidBrush(Color.Firebrick);
				}
				return firebrick;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush FloralWhite
		{
			get
			{
				if (floralWhite == null)
				{
					floralWhite = new SolidBrush(Color.FloralWhite);
				}
				return floralWhite;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush ForestGreen
		{
			get
			{
				if (forestGreen == null)
				{
					forestGreen = new SolidBrush(Color.ForestGreen);
				}
				return forestGreen;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Fuchsia
		{
			get
			{
				if (fuchsia == null)
				{
					fuchsia = new SolidBrush(Color.Fuchsia);
				}
				return fuchsia;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Gainsboro
		{
			get
			{
				if (gainsboro == null)
				{
					gainsboro = new SolidBrush(Color.Gainsboro);
				}
				return gainsboro;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush GhostWhite
		{
			get
			{
				if (ghostWhite == null)
				{
					ghostWhite = new SolidBrush(Color.GhostWhite);
				}
				return ghostWhite;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Gold
		{
			get
			{
				if (gold == null)
				{
					gold = new SolidBrush(Color.Gold);
				}
				return gold;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Goldenrod
		{
			get
			{
				if (goldenrod == null)
				{
					goldenrod = new SolidBrush(Color.Goldenrod);
				}
				return goldenrod;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Gray
		{
			get
			{
				if (gray == null)
				{
					gray = new SolidBrush(Color.Gray);
				}
				return gray;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Green
		{
			get
			{
				if (green == null)
				{
					green = new SolidBrush(Color.Green);
				}
				return green;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush GreenYellow
		{
			get
			{
				if (greenYellow == null)
				{
					greenYellow = new SolidBrush(Color.GreenYellow);
				}
				return greenYellow;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Honeydew
		{
			get
			{
				if (honeydew == null)
				{
					honeydew = new SolidBrush(Color.Honeydew);
				}
				return honeydew;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush HotPink
		{
			get
			{
				if (hotPink == null)
				{
					hotPink = new SolidBrush(Color.HotPink);
				}
				return hotPink;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush IndianRed
		{
			get
			{
				if (indianRed == null)
				{
					indianRed = new SolidBrush(Color.IndianRed);
				}
				return indianRed;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Indigo
		{
			get
			{
				if (indigo == null)
				{
					indigo = new SolidBrush(Color.Indigo);
				}
				return indigo;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Ivory
		{
			get
			{
				if (ivory == null)
				{
					ivory = new SolidBrush(Color.Ivory);
				}
				return ivory;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Khaki
		{
			get
			{
				if (khaki == null)
				{
					khaki = new SolidBrush(Color.Khaki);
				}
				return khaki;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Lavender
		{
			get
			{
				if (lavender == null)
				{
					lavender = new SolidBrush(Color.Lavender);
				}
				return lavender;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LavenderBlush
		{
			get
			{
				if (lavenderBlush == null)
				{
					lavenderBlush = new SolidBrush(Color.LavenderBlush);
				}
				return lavenderBlush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LawnGreen
		{
			get
			{
				if (lawnGreen == null)
				{
					lawnGreen = new SolidBrush(Color.LawnGreen);
				}
				return lawnGreen;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LemonChiffon
		{
			get
			{
				if (lemonChiffon == null)
				{
					lemonChiffon = new SolidBrush(Color.LemonChiffon);
				}
				return lemonChiffon;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightBlue
		{
			get
			{
				if (lightBlue == null)
				{
					lightBlue = new SolidBrush(Color.LightBlue);
				}
				return lightBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightCoral
		{
			get
			{
				if (lightCoral == null)
				{
					lightCoral = new SolidBrush(Color.LightCoral);
				}
				return lightCoral;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightCyan
		{
			get
			{
				if (lightCyan == null)
				{
					lightCyan = new SolidBrush(Color.LightCyan);
				}
				return lightCyan;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightGoldenrodYellow
		{
			get
			{
				if (lightGoldenrodYellow == null)
				{
					lightGoldenrodYellow = new SolidBrush(Color.LightGoldenrodYellow);
				}
				return lightGoldenrodYellow;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightGray
		{
			get
			{
				if (lightGray == null)
				{
					lightGray = new SolidBrush(Color.LightGray);
				}
				return lightGray;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightGreen
		{
			get
			{
				if (lightGreen == null)
				{
					lightGreen = new SolidBrush(Color.LightGreen);
				}
				return lightGreen;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightPink
		{
			get
			{
				if (lightPink == null)
				{
					lightPink = new SolidBrush(Color.LightPink);
				}
				return lightPink;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightSalmon
		{
			get
			{
				if (lightSalmon == null)
				{
					lightSalmon = new SolidBrush(Color.LightSalmon);
				}
				return lightSalmon;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightSeaGreen
		{
			get
			{
				if (lightSeaGreen == null)
				{
					lightSeaGreen = new SolidBrush(Color.LightSeaGreen);
				}
				return lightSeaGreen;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightSkyBlue
		{
			get
			{
				if (lightSkyBlue == null)
				{
					lightSkyBlue = new SolidBrush(Color.LightSkyBlue);
				}
				return lightSkyBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightSlateGray
		{
			get
			{
				if (lightSlateGray == null)
				{
					lightSlateGray = new SolidBrush(Color.LightSlateGray);
				}
				return lightSlateGray;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightSteelBlue
		{
			get
			{
				if (lightSteelBlue == null)
				{
					lightSteelBlue = new SolidBrush(Color.LightSteelBlue);
				}
				return lightSteelBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightYellow
		{
			get
			{
				if (lightYellow == null)
				{
					lightYellow = new SolidBrush(Color.LightYellow);
				}
				return lightYellow;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Lime
		{
			get
			{
				if (lime == null)
				{
					lime = new SolidBrush(Color.Lime);
				}
				return lime;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LimeGreen
		{
			get
			{
				if (limeGreen == null)
				{
					limeGreen = new SolidBrush(Color.LimeGreen);
				}
				return limeGreen;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Linen
		{
			get
			{
				if (linen == null)
				{
					linen = new SolidBrush(Color.Linen);
				}
				return linen;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Magenta
		{
			get
			{
				if (magenta == null)
				{
					magenta = new SolidBrush(Color.Magenta);
				}
				return magenta;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Maroon
		{
			get
			{
				if (maroon == null)
				{
					maroon = new SolidBrush(Color.Maroon);
				}
				return maroon;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumAquamarine
		{
			get
			{
				if (mediumAquamarine == null)
				{
					mediumAquamarine = new SolidBrush(Color.MediumAquamarine);
				}
				return mediumAquamarine;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumBlue
		{
			get
			{
				if (mediumBlue == null)
				{
					mediumBlue = new SolidBrush(Color.MediumBlue);
				}
				return mediumBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumOrchid
		{
			get
			{
				if (mediumOrchid == null)
				{
					mediumOrchid = new SolidBrush(Color.MediumOrchid);
				}
				return mediumOrchid;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumPurple
		{
			get
			{
				if (mediumPurple == null)
				{
					mediumPurple = new SolidBrush(Color.MediumPurple);
				}
				return mediumPurple;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumSeaGreen
		{
			get
			{
				if (mediumSeaGreen == null)
				{
					mediumSeaGreen = new SolidBrush(Color.MediumSeaGreen);
				}
				return mediumSeaGreen;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumSlateBlue
		{
			get
			{
				if (mediumSlateBlue == null)
				{
					mediumSlateBlue = new SolidBrush(Color.MediumSlateBlue);
				}
				return mediumSlateBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumSpringGreen
		{
			get
			{
				if (mediumSpringGreen == null)
				{
					mediumSpringGreen = new SolidBrush(Color.MediumSpringGreen);
				}
				return mediumSpringGreen;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumTurquoise
		{
			get
			{
				if (mediumTurquoise == null)
				{
					mediumTurquoise = new SolidBrush(Color.MediumTurquoise);
				}
				return mediumTurquoise;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumVioletRed
		{
			get
			{
				if (mediumVioletRed == null)
				{
					mediumVioletRed = new SolidBrush(Color.MediumVioletRed);
				}
				return mediumVioletRed;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MidnightBlue
		{
			get
			{
				if (midnightBlue == null)
				{
					midnightBlue = new SolidBrush(Color.MidnightBlue);
				}
				return midnightBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MintCream
		{
			get
			{
				if (mintCream == null)
				{
					mintCream = new SolidBrush(Color.MintCream);
				}
				return mintCream;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MistyRose
		{
			get
			{
				if (mistyRose == null)
				{
					mistyRose = new SolidBrush(Color.MistyRose);
				}
				return mistyRose;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Moccasin
		{
			get
			{
				if (moccasin == null)
				{
					moccasin = new SolidBrush(Color.Moccasin);
				}
				return moccasin;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush NavajoWhite
		{
			get
			{
				if (navajoWhite == null)
				{
					navajoWhite = new SolidBrush(Color.NavajoWhite);
				}
				return navajoWhite;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Navy
		{
			get
			{
				if (navy == null)
				{
					navy = new SolidBrush(Color.Navy);
				}
				return navy;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush OldLace
		{
			get
			{
				if (oldLace == null)
				{
					oldLace = new SolidBrush(Color.OldLace);
				}
				return oldLace;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Olive
		{
			get
			{
				if (olive == null)
				{
					olive = new SolidBrush(Color.Olive);
				}
				return olive;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush OliveDrab
		{
			get
			{
				if (oliveDrab == null)
				{
					oliveDrab = new SolidBrush(Color.OliveDrab);
				}
				return oliveDrab;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Orange
		{
			get
			{
				if (orange == null)
				{
					orange = new SolidBrush(Color.Orange);
				}
				return orange;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush OrangeRed
		{
			get
			{
				if (orangeRed == null)
				{
					orangeRed = new SolidBrush(Color.OrangeRed);
				}
				return orangeRed;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Orchid
		{
			get
			{
				if (orchid == null)
				{
					orchid = new SolidBrush(Color.Orchid);
				}
				return orchid;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush PaleGoldenrod
		{
			get
			{
				if (paleGoldenrod == null)
				{
					paleGoldenrod = new SolidBrush(Color.PaleGoldenrod);
				}
				return paleGoldenrod;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush PaleGreen
		{
			get
			{
				if (paleGreen == null)
				{
					paleGreen = new SolidBrush(Color.PaleGreen);
				}
				return paleGreen;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush PaleTurquoise
		{
			get
			{
				if (paleTurquoise == null)
				{
					paleTurquoise = new SolidBrush(Color.PaleTurquoise);
				}
				return paleTurquoise;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush PaleVioletRed
		{
			get
			{
				if (paleVioletRed == null)
				{
					paleVioletRed = new SolidBrush(Color.PaleVioletRed);
				}
				return paleVioletRed;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush PapayaWhip
		{
			get
			{
				if (papayaWhip == null)
				{
					papayaWhip = new SolidBrush(Color.PapayaWhip);
				}
				return papayaWhip;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush PeachPuff
		{
			get
			{
				if (peachPuff == null)
				{
					peachPuff = new SolidBrush(Color.PeachPuff);
				}
				return peachPuff;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Peru
		{
			get
			{
				if (peru == null)
				{
					peru = new SolidBrush(Color.Peru);
				}
				return peru;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Pink
		{
			get
			{
				if (pink == null)
				{
					pink = new SolidBrush(Color.Pink);
				}
				return pink;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Plum
		{
			get
			{
				if (plum == null)
				{
					plum = new SolidBrush(Color.Plum);
				}
				return plum;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush PowderBlue
		{
			get
			{
				if (powderBlue == null)
				{
					powderBlue = new SolidBrush(Color.PowderBlue);
				}
				return powderBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Purple
		{
			get
			{
				if (purple == null)
				{
					purple = new SolidBrush(Color.Purple);
				}
				return purple;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Red
		{
			get
			{
				if (red == null)
				{
					red = new SolidBrush(Color.Red);
				}
				return red;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush RosyBrown
		{
			get
			{
				if (rosyBrown == null)
				{
					rosyBrown = new SolidBrush(Color.RosyBrown);
				}
				return rosyBrown;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush RoyalBlue
		{
			get
			{
				if (royalBlue == null)
				{
					royalBlue = new SolidBrush(Color.RoyalBlue);
				}
				return royalBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SaddleBrown
		{
			get
			{
				if (saddleBrown == null)
				{
					saddleBrown = new SolidBrush(Color.SaddleBrown);
				}
				return saddleBrown;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Salmon
		{
			get
			{
				if (salmon == null)
				{
					salmon = new SolidBrush(Color.Salmon);
				}
				return salmon;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SandyBrown
		{
			get
			{
				if (sandyBrown == null)
				{
					sandyBrown = new SolidBrush(Color.SandyBrown);
				}
				return sandyBrown;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SeaGreen
		{
			get
			{
				if (seaGreen == null)
				{
					seaGreen = new SolidBrush(Color.SeaGreen);
				}
				return seaGreen;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SeaShell
		{
			get
			{
				if (seaShell == null)
				{
					seaShell = new SolidBrush(Color.SeaShell);
				}
				return seaShell;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Sienna
		{
			get
			{
				if (sienna == null)
				{
					sienna = new SolidBrush(Color.Sienna);
				}
				return sienna;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Silver
		{
			get
			{
				if (silver == null)
				{
					silver = new SolidBrush(Color.Silver);
				}
				return silver;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SkyBlue
		{
			get
			{
				if (skyBlue == null)
				{
					skyBlue = new SolidBrush(Color.SkyBlue);
				}
				return skyBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SlateBlue
		{
			get
			{
				if (slateBlue == null)
				{
					slateBlue = new SolidBrush(Color.SlateBlue);
				}
				return slateBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SlateGray
		{
			get
			{
				if (slateGray == null)
				{
					slateGray = new SolidBrush(Color.SlateGray);
				}
				return slateGray;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Snow
		{
			get
			{
				if (snow == null)
				{
					snow = new SolidBrush(Color.Snow);
				}
				return snow;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SpringGreen
		{
			get
			{
				if (springGreen == null)
				{
					springGreen = new SolidBrush(Color.SpringGreen);
				}
				return springGreen;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SteelBlue
		{
			get
			{
				if (steelBlue == null)
				{
					steelBlue = new SolidBrush(Color.SteelBlue);
				}
				return steelBlue;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Tan
		{
			get
			{
				if (tan == null)
				{
					tan = new SolidBrush(Color.Tan);
				}
				return tan;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Teal
		{
			get
			{
				if (teal == null)
				{
					teal = new SolidBrush(Color.Teal);
				}
				return teal;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Thistle
		{
			get
			{
				if (thistle == null)
				{
					thistle = new SolidBrush(Color.Thistle);
				}
				return thistle;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Tomato
		{
			get
			{
				if (tomato == null)
				{
					tomato = new SolidBrush(Color.Tomato);
				}
				return tomato;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Transparent
		{
			get
			{
				if (transparent == null)
				{
					transparent = new SolidBrush(Color.Transparent);
				}
				return transparent;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Turquoise
		{
			get
			{
				if (turquoise == null)
				{
					turquoise = new SolidBrush(Color.Turquoise);
				}
				return turquoise;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Violet
		{
			get
			{
				if (violet == null)
				{
					violet = new SolidBrush(Color.Violet);
				}
				return violet;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Wheat
		{
			get
			{
				if (wheat == null)
				{
					wheat = new SolidBrush(Color.Wheat);
				}
				return wheat;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush White
		{
			get
			{
				if (white == null)
				{
					white = new SolidBrush(Color.White);
				}
				return white;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush WhiteSmoke
		{
			get
			{
				if (whiteSmoke == null)
				{
					whiteSmoke = new SolidBrush(Color.WhiteSmoke);
				}
				return whiteSmoke;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Yellow
		{
			get
			{
				if (yellow == null)
				{
					yellow = new SolidBrush(Color.Yellow);
				}
				return yellow;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush YellowGreen
		{
			get
			{
				if (yellowGreen == null)
				{
					yellowGreen = new SolidBrush(Color.YellowGreen);
				}
				return yellowGreen;
			}
		}

		private Brushes()
		{
		}
	}
	/// <summary>Provides a graphics buffer for double buffering.</summary>
	public sealed class BufferedGraphics : IDisposable
	{
		private Rectangle size;

		private Bitmap membmp;

		private Graphics target;

		private Graphics source;

		/// <summary>Gets a <see cref="T:System.Drawing.Graphics" /> object that outputs to the graphics buffer.</summary>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> object that outputs to the graphics buffer.</returns>
		public Graphics Graphics
		{
			get
			{
				if (source == null)
				{
					source = Graphics.FromImage(membmp);
				}
				return source;
			}
		}

		private BufferedGraphics()
		{
		}

		internal BufferedGraphics(Graphics targetGraphics, Rectangle targetRectangle)
		{
			size = targetRectangle;
			target = targetGraphics;
			membmp = new Bitmap(size.Width, size.Height);
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~BufferedGraphics()
		{
			Dispose(disposing: false);
		}

		/// <summary>Releases all resources used by the <see cref="T:System.Drawing.BufferedGraphics" /> object.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (disposing)
			{
				if (membmp != null)
				{
					membmp.Dispose();
					membmp = null;
				}
				if (source != null)
				{
					source.Dispose();
					source = null;
				}
				target = null;
			}
		}

		/// <summary>Writes the contents of the graphics buffer to the default device.</summary>
		public void Render()
		{
			Render(target);
		}

		/// <summary>Writes the contents of the graphics buffer to the specified <see cref="T:System.Drawing.Graphics" /> object.</summary>
		/// <param name="target">A <see cref="T:System.Drawing.Graphics" /> object to which to write the contents of the graphics buffer.</param>
		public void Render(Graphics target)
		{
			target?.DrawImage(membmp, size);
		}

		/// <summary>Writes the contents of the graphics buffer to the device context associated with the specified <see cref="T:System.IntPtr" /> handle.</summary>
		/// <param name="targetDC">An <see cref="T:System.IntPtr" /> that points to the device context to which to write the contents of the graphics buffer.</param>
		[System.MonoTODO("The targetDC parameter has no equivalent in libgdiplus.")]
		public void Render(IntPtr targetDC)
		{
			throw new NotImplementedException();
		}
	}
	/// <summary>Provides methods for creating graphics buffers that can be used for double buffering.</summary>
	public sealed class BufferedGraphicsContext : IDisposable
	{
		private Size max_buffer;

		/// <summary>Gets or sets the maximum size of the buffer to use.</summary>
		/// <returns>A <see cref="T:System.Drawing.Size" /> indicating the maximum size of the buffer dimensions.</returns>
		/// <exception cref="T:System.ArgumentException">The height or width of the size is less than or equal to zero.</exception>
		public Size MaximumBuffer
		{
			get
			{
				return max_buffer;
			}
			set
			{
				if (value.Width <= 0 || value.Height <= 0)
				{
					throw new ArgumentException("The height or width of the size is less than or equal to zero.");
				}
				max_buffer = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.BufferedGraphicsContext" /> class.</summary>
		public BufferedGraphicsContext()
		{
			max_buffer = Size.Empty;
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~BufferedGraphicsContext()
		{
		}

		/// <summary>Creates a graphics buffer of the specified size using the pixel format of the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="targetGraphics">The <see cref="T:System.Drawing.Graphics" /> to match the pixel format for the new buffer to.</param>
		/// <param name="targetRectangle">A <see cref="T:System.Drawing.Rectangle" /> indicating the size of the buffer to create.</param>
		/// <returns>A <see cref="T:System.Drawing.BufferedGraphics" /> that can be used to draw to a buffer of the specified dimensions.</returns>
		public BufferedGraphics Allocate(Graphics targetGraphics, Rectangle targetRectangle)
		{
			return new BufferedGraphics(targetGraphics, targetRectangle);
		}

		/// <summary>Creates a graphics buffer of the specified size using the pixel format of the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="targetDC">An <see cref="T:System.IntPtr" /> to a device context to match the pixel format of the new buffer to.</param>
		/// <param name="targetRectangle">A <see cref="T:System.Drawing.Rectangle" /> indicating the size of the buffer to create.</param>
		/// <returns>A <see cref="T:System.Drawing.BufferedGraphics" /> that can be used to draw to a buffer of the specified dimensions.</returns>
		[System.MonoTODO("The targetDC parameter has no equivalent in libgdiplus.")]
		public BufferedGraphics Allocate(IntPtr targetDC, Rectangle targetRectangle)
		{
			throw new NotImplementedException();
		}

		/// <summary>Releases all resources used by the <see cref="T:System.Drawing.BufferedGraphicsContext" />.</summary>
		public void Dispose()
		{
			GC.SuppressFinalize(this);
		}

		/// <summary>Disposes of the current graphics buffer, if a buffer has been allocated and has not yet been disposed.</summary>
		public void Invalidate()
		{
		}
	}
	/// <summary>Provides access to the main buffered graphics context object for the application domain.</summary>
	public sealed class BufferedGraphicsManager
	{
		private static BufferedGraphicsContext graphics_context;

		/// <summary>Gets the <see cref="T:System.Drawing.BufferedGraphicsContext" /> for the current application domain.</summary>
		/// <returns>The <see cref="T:System.Drawing.BufferedGraphicsContext" /> for the current application domain.</returns>
		public static BufferedGraphicsContext Current => graphics_context;

		static BufferedGraphicsManager()
		{
			graphics_context = new BufferedGraphicsContext();
		}

		private BufferedGraphicsManager()
		{
		}
	}
	/// <summary>Specifies a range of character positions within a string.</summary>
	public struct CharacterRange
	{
		private int first;

		private int length;

		/// <summary>Gets or sets the position in the string of the first character of this <see cref="T:System.Drawing.CharacterRange" />.</summary>
		/// <returns>The first position of this <see cref="T:System.Drawing.CharacterRange" />.</returns>
		public int First
		{
			get
			{
				return first;
			}
			set
			{
				first = value;
			}
		}

		/// <summary>Gets or sets the number of positions in this <see cref="T:System.Drawing.CharacterRange" />.</summary>
		/// <returns>The number of positions in this <see cref="T:System.Drawing.CharacterRange" />.</returns>
		public int Length
		{
			get
			{
				return length;
			}
			set
			{
				length = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.CharacterRange" /> structure, specifying a range of character positions within a string.</summary>
		/// <param name="First">The position of the first character in the range. For example, if <paramref name="First" /> is set to 0, the first position of the range is position 0 in the string.</param>
		/// <param name="Length">The number of positions in the range.</param>
		public CharacterRange(int First, int Length)
		{
			first = First;
			length = Length;
		}

		/// <summary>Gets a value indicating whether this object is equivalent to the specified object.</summary>
		/// <param name="obj">The object to compare to for equality.</param>
		/// <returns>
		///   <see langword="true" /> to indicate the specified object is an instance with the same <see cref="P:System.Drawing.CharacterRange.First" /> and <see cref="P:System.Drawing.CharacterRange.Length" /> value as this instance; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is CharacterRange characterRange))
			{
				return false;
			}
			return this == characterRange;
		}

		/// <summary>Returns the hash code for this instance.</summary>
		/// <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
		public override int GetHashCode()
		{
			return first ^ length;
		}

		/// <summary>Compares two <see cref="T:System.Drawing.CharacterRange" /> objects. Gets a value indicating whether the <see cref="P:System.Drawing.CharacterRange.First" /> and <see cref="P:System.Drawing.CharacterRange.Length" /> values of the two <see cref="T:System.Drawing.CharacterRange" /> objects are equal.</summary>
		/// <param name="cr1">A <see cref="T:System.Drawing.CharacterRange" /> to compare for equality.</param>
		/// <param name="cr2">A <see cref="T:System.Drawing.CharacterRange" /> to compare for equality.</param>
		/// <returns>
		///   <see langword="true" /> to indicate the two <see cref="T:System.Drawing.CharacterRange" /> objects have the same <see cref="P:System.Drawing.CharacterRange.First" /> and <see cref="P:System.Drawing.CharacterRange.Length" /> values; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(CharacterRange cr1, CharacterRange cr2)
		{
			if (cr1.first == cr2.first)
			{
				return cr1.length == cr2.length;
			}
			return false;
		}

		/// <summary>Compares two <see cref="T:System.Drawing.CharacterRange" /> objects. Gets a value indicating whether the <see cref="P:System.Drawing.CharacterRange.First" /> or <see cref="P:System.Drawing.CharacterRange.Length" /> values of the two <see cref="T:System.Drawing.CharacterRange" /> objects are not equal.</summary>
		/// <param name="cr1">A <see cref="T:System.Drawing.CharacterRange" /> to compare for inequality.</param>
		/// <param name="cr2">A <see cref="T:System.Drawing.CharacterRange" /> to compare for inequality.</param>
		/// <returns>
		///   <see langword="true" /> to indicate the either the <see cref="P:System.Drawing.CharacterRange.First" /> or <see cref="P:System.Drawing.CharacterRange.Length" /> values of the two <see cref="T:System.Drawing.CharacterRange" /> objects differ; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(CharacterRange cr1, CharacterRange cr2)
		{
			if (cr1.first == cr2.first)
			{
				return cr1.length != cr2.length;
			}
			return true;
		}
	}
	/// <summary>Represents an ARGB (alpha, red, green, blue) color.</summary>
	[Serializable]
	[TypeConverter(typeof(ColorConverter))]
	[Editor("System.Drawing.Design.ColorEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	public struct Color
	{
		[Flags]
		internal enum ColorType : short
		{
			Empty = 0,
			Known = 1,
			ARGB = 2,
			Named = 4,
			System = 8
		}

		private long value;

		internal short state;

		internal short knownColor;

		internal string name;

		/// <summary>Represents a color that is <see langword="null" />.</summary>
		public static readonly Color Empty;

		/// <summary>Gets the name of this <see cref="T:System.Drawing.Color" />.</summary>
		/// <returns>The name of this <see cref="T:System.Drawing.Color" />.</returns>
		public string Name
		{
			get
			{
				if (name == null)
				{
					if (IsNamedColor)
					{
						name = KnownColors.GetName(knownColor);
					}
					else
					{
						name = $"{ToArgb():x}";
					}
				}
				return name;
			}
		}

		/// <summary>Gets a value indicating whether this <see cref="T:System.Drawing.Color" /> structure is a predefined color. Predefined colors are represented by the elements of the <see cref="T:System.Drawing.KnownColor" /> enumeration.</summary>
		/// <returns>
		///   <see langword="true" /> if this <see cref="T:System.Drawing.Color" /> was created from a predefined color by using either the <see cref="M:System.Drawing.Color.FromName(System.String)" /> method or the <see cref="M:System.Drawing.Color.FromKnownColor(System.Drawing.KnownColor)" /> method; otherwise, <see langword="false" />.</returns>
		public bool IsKnownColor => (state & 1) != 0;

		/// <summary>Gets a value indicating whether this <see cref="T:System.Drawing.Color" /> structure is a system color. A system color is a color that is used in a Windows display element. System colors are represented by elements of the <see cref="T:System.Drawing.KnownColor" /> enumeration.</summary>
		/// <returns>
		///   <see langword="true" /> if this <see cref="T:System.Drawing.Color" /> was created from a system color by using either the <see cref="M:System.Drawing.Color.FromName(System.String)" /> method or the <see cref="M:System.Drawing.Color.FromKnownColor(System.Drawing.KnownColor)" /> method; otherwise, <see langword="false" />.</returns>
		public bool IsSystemColor => (state & 8) != 0;

		/// <summary>Gets a value indicating whether this <see cref="T:System.Drawing.Color" /> structure is a named color or a member of the <see cref="T:System.Drawing.KnownColor" /> enumeration.</summary>
		/// <returns>
		///   <see langword="true" /> if this <see cref="T:System.Drawing.Color" /> was created by using either the <see cref="M:System.Drawing.Color.FromName(System.String)" /> method or the <see cref="M:System.Drawing.Color.FromKnownColor(System.Drawing.KnownColor)" /> method; otherwise, <see langword="false" />.</returns>
		public bool IsNamedColor => (state & 5) != 0;

		internal long Value
		{
			get
			{
				if (value == 0L && IsKnownColor)
				{
					value = FromKnownColor((KnownColor)knownColor).ToArgb() & 0xFFFFFFFFu;
				}
				return value;
			}
			set
			{
				this.value = value;
			}
		}

		/// <summary>Specifies whether this <see cref="T:System.Drawing.Color" /> structure is uninitialized.</summary>
		/// <returns>This property returns <see langword="true" /> if this color is uninitialized; otherwise, <see langword="false" />.</returns>
		public bool IsEmpty => state == 0;

		/// <summary>Gets the alpha component value of this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The alpha component value of this <see cref="T:System.Drawing.Color" />.</returns>
		public byte A => (byte)(Value >> 24);

		/// <summary>Gets the red component value of this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The red component value of this <see cref="T:System.Drawing.Color" />.</returns>
		public byte R => (byte)(Value >> 16);

		/// <summary>Gets the green component value of this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The green component value of this <see cref="T:System.Drawing.Color" />.</returns>
		public byte G => (byte)(Value >> 8);

		/// <summary>Gets the blue component value of this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The blue component value of this <see cref="T:System.Drawing.Color" />.</returns>
		public byte B => (byte)Value;

		/// <summary>Gets a system-defined color.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Transparent => FromKnownColor(KnownColor.Transparent);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF0F8FF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color AliceBlue => FromKnownColor(KnownColor.AliceBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFAEBD7.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color AntiqueWhite => FromKnownColor(KnownColor.AntiqueWhite);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00FFFF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Aqua => FromKnownColor(KnownColor.Aqua);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF7FFFD4.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Aquamarine => FromKnownColor(KnownColor.Aquamarine);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF0FFFF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Azure => FromKnownColor(KnownColor.Azure);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF5F5DC.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Beige => FromKnownColor(KnownColor.Beige);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFE4C4.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Bisque => FromKnownColor(KnownColor.Bisque);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF000000.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Black => FromKnownColor(KnownColor.Black);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFEBCD.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color BlanchedAlmond => FromKnownColor(KnownColor.BlanchedAlmond);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF0000FF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Blue => FromKnownColor(KnownColor.Blue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF8A2BE2.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color BlueViolet => FromKnownColor(KnownColor.BlueViolet);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFA52A2A.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Brown => FromKnownColor(KnownColor.Brown);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFDEB887.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color BurlyWood => FromKnownColor(KnownColor.BurlyWood);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF5F9EA0.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color CadetBlue => FromKnownColor(KnownColor.CadetBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF7FFF00.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Chartreuse => FromKnownColor(KnownColor.Chartreuse);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFD2691E.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Chocolate => FromKnownColor(KnownColor.Chocolate);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF7F50.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Coral => FromKnownColor(KnownColor.Coral);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF6495ED.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color CornflowerBlue => FromKnownColor(KnownColor.CornflowerBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFF8DC.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Cornsilk => FromKnownColor(KnownColor.Cornsilk);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFDC143C.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Crimson => FromKnownColor(KnownColor.Crimson);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00FFFF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Cyan => FromKnownColor(KnownColor.Cyan);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00008B.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkBlue => FromKnownColor(KnownColor.DarkBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF008B8B.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkCyan => FromKnownColor(KnownColor.DarkCyan);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFB8860B.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkGoldenrod => FromKnownColor(KnownColor.DarkGoldenrod);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFA9A9A9.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkGray => FromKnownColor(KnownColor.DarkGray);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF006400.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkGreen => FromKnownColor(KnownColor.DarkGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFBDB76B.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkKhaki => FromKnownColor(KnownColor.DarkKhaki);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF8B008B.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkMagenta => FromKnownColor(KnownColor.DarkMagenta);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF556B2F.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkOliveGreen => FromKnownColor(KnownColor.DarkOliveGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF8C00.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkOrange => FromKnownColor(KnownColor.DarkOrange);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF9932CC.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkOrchid => FromKnownColor(KnownColor.DarkOrchid);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF8B0000.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkRed => FromKnownColor(KnownColor.DarkRed);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFE9967A.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkSalmon => FromKnownColor(KnownColor.DarkSalmon);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF8FBC8F.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkSeaGreen => FromKnownColor(KnownColor.DarkSeaGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF483D8B.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkSlateBlue => FromKnownColor(KnownColor.DarkSlateBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF2F4F4F.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkSlateGray => FromKnownColor(KnownColor.DarkSlateGray);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00CED1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkTurquoise => FromKnownColor(KnownColor.DarkTurquoise);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF9400D3.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkViolet => FromKnownColor(KnownColor.DarkViolet);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF1493.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DeepPink => FromKnownColor(KnownColor.DeepPink);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00BFFF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DeepSkyBlue => FromKnownColor(KnownColor.DeepSkyBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF696969.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DimGray => FromKnownColor(KnownColor.DimGray);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF1E90FF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DodgerBlue => FromKnownColor(KnownColor.DodgerBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFB22222.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Firebrick => FromKnownColor(KnownColor.Firebrick);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFFAF0.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color FloralWhite => FromKnownColor(KnownColor.FloralWhite);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF228B22.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color ForestGreen => FromKnownColor(KnownColor.ForestGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF00FF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Fuchsia => FromKnownColor(KnownColor.Fuchsia);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFDCDCDC.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Gainsboro => FromKnownColor(KnownColor.Gainsboro);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF8F8FF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color GhostWhite => FromKnownColor(KnownColor.GhostWhite);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFD700.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Gold => FromKnownColor(KnownColor.Gold);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFDAA520.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Goldenrod => FromKnownColor(KnownColor.Goldenrod);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF808080.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> strcture representing a system-defined color.</returns>
		public static Color Gray => FromKnownColor(KnownColor.Gray);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF008000.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Green => FromKnownColor(KnownColor.Green);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFADFF2F.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color GreenYellow => FromKnownColor(KnownColor.GreenYellow);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF0FFF0.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Honeydew => FromKnownColor(KnownColor.Honeydew);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF69B4.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color HotPink => FromKnownColor(KnownColor.HotPink);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFCD5C5C.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color IndianRed => FromKnownColor(KnownColor.IndianRed);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF4B0082.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Indigo => FromKnownColor(KnownColor.Indigo);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFFFF0.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Ivory => FromKnownColor(KnownColor.Ivory);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF0E68C.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Khaki => FromKnownColor(KnownColor.Khaki);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFE6E6FA.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Lavender => FromKnownColor(KnownColor.Lavender);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFF0F5.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LavenderBlush => FromKnownColor(KnownColor.LavenderBlush);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF7CFC00.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LawnGreen => FromKnownColor(KnownColor.LawnGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFFACD.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LemonChiffon => FromKnownColor(KnownColor.LemonChiffon);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFADD8E6.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightBlue => FromKnownColor(KnownColor.LightBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF08080.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightCoral => FromKnownColor(KnownColor.LightCoral);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFE0FFFF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightCyan => FromKnownColor(KnownColor.LightCyan);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFAFAD2.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightGoldenrodYellow => FromKnownColor(KnownColor.LightGoldenrodYellow);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF90EE90.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightGreen => FromKnownColor(KnownColor.LightGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFD3D3D3.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightGray => FromKnownColor(KnownColor.LightGray);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFB6C1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightPink => FromKnownColor(KnownColor.LightPink);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFA07A.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightSalmon => FromKnownColor(KnownColor.LightSalmon);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF20B2AA.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightSeaGreen => FromKnownColor(KnownColor.LightSeaGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF87CEFA.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightSkyBlue => FromKnownColor(KnownColor.LightSkyBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF778899.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightSlateGray => FromKnownColor(KnownColor.LightSlateGray);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFB0C4DE.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightSteelBlue => FromKnownColor(KnownColor.LightSteelBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFFFE0.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightYellow => FromKnownColor(KnownColor.LightYellow);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00FF00.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Lime => FromKnownColor(KnownColor.Lime);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF32CD32.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LimeGreen => FromKnownColor(KnownColor.LimeGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFAF0E6.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Linen => FromKnownColor(KnownColor.Linen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF00FF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Magenta => FromKnownColor(KnownColor.Magenta);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF800000.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Maroon => FromKnownColor(KnownColor.Maroon);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF66CDAA.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumAquamarine => FromKnownColor(KnownColor.MediumAquamarine);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF0000CD.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumBlue => FromKnownColor(KnownColor.MediumBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFBA55D3.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumOrchid => FromKnownColor(KnownColor.MediumOrchid);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF9370DB.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumPurple => FromKnownColor(KnownColor.MediumPurple);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF3CB371.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumSeaGreen => FromKnownColor(KnownColor.MediumSeaGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF7B68EE.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumSlateBlue => FromKnownColor(KnownColor.MediumSlateBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00FA9A.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumSpringGreen => FromKnownColor(KnownColor.MediumSpringGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF48D1CC.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumTurquoise => FromKnownColor(KnownColor.MediumTurquoise);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFC71585.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumVioletRed => FromKnownColor(KnownColor.MediumVioletRed);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF191970.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MidnightBlue => FromKnownColor(KnownColor.MidnightBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF5FFFA.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MintCream => FromKnownColor(KnownColor.MintCream);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFE4E1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MistyRose => FromKnownColor(KnownColor.MistyRose);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFE4B5.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Moccasin => FromKnownColor(KnownColor.Moccasin);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFDEAD.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color NavajoWhite => FromKnownColor(KnownColor.NavajoWhite);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF000080.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Navy => FromKnownColor(KnownColor.Navy);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFDF5E6.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color OldLace => FromKnownColor(KnownColor.OldLace);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF808000.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Olive => FromKnownColor(KnownColor.Olive);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF6B8E23.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color OliveDrab => FromKnownColor(KnownColor.OliveDrab);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFA500.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Orange => FromKnownColor(KnownColor.Orange);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF4500.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color OrangeRed => FromKnownColor(KnownColor.OrangeRed);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFDA70D6.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Orchid => FromKnownColor(KnownColor.Orchid);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFEEE8AA.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color PaleGoldenrod => FromKnownColor(KnownColor.PaleGoldenrod);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF98FB98.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color PaleGreen => FromKnownColor(KnownColor.PaleGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFAFEEEE.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color PaleTurquoise => FromKnownColor(KnownColor.PaleTurquoise);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFDB7093.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color PaleVioletRed => FromKnownColor(KnownColor.PaleVioletRed);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFEFD5.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color PapayaWhip => FromKnownColor(KnownColor.PapayaWhip);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFDAB9.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color PeachPuff => FromKnownColor(KnownColor.PeachPuff);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFCD853F.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Peru => FromKnownColor(KnownColor.Peru);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFC0CB.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Pink => FromKnownColor(KnownColor.Pink);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFDDA0DD.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Plum => FromKnownColor(KnownColor.Plum);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFB0E0E6.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color PowderBlue => FromKnownColor(KnownColor.PowderBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF800080.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Purple => FromKnownColor(KnownColor.Purple);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF0000.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Red => FromKnownColor(KnownColor.Red);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFBC8F8F.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color RosyBrown => FromKnownColor(KnownColor.RosyBrown);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF4169E1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color RoyalBlue => FromKnownColor(KnownColor.RoyalBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF8B4513.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SaddleBrown => FromKnownColor(KnownColor.SaddleBrown);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFA8072.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Salmon => FromKnownColor(KnownColor.Salmon);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF4A460.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SandyBrown => FromKnownColor(KnownColor.SandyBrown);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF2E8B57.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SeaGreen => FromKnownColor(KnownColor.SeaGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFF5EE.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SeaShell => FromKnownColor(KnownColor.SeaShell);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFA0522D.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Sienna => FromKnownColor(KnownColor.Sienna);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFC0C0C0.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Silver => FromKnownColor(KnownColor.Silver);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF87CEEB.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SkyBlue => FromKnownColor(KnownColor.SkyBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF6A5ACD.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SlateBlue => FromKnownColor(KnownColor.SlateBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF708090.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SlateGray => FromKnownColor(KnownColor.SlateGray);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFFAFA.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Snow => FromKnownColor(KnownColor.Snow);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00FF7F.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SpringGreen => FromKnownColor(KnownColor.SpringGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF4682B4.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SteelBlue => FromKnownColor(KnownColor.SteelBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFD2B48C.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Tan => FromKnownColor(KnownColor.Tan);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF008080.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Teal => FromKnownColor(KnownColor.Teal);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFD8BFD8.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Thistle => FromKnownColor(KnownColor.Thistle);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF6347.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Tomato => FromKnownColor(KnownColor.Tomato);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF40E0D0.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Turquoise => FromKnownColor(KnownColor.Turquoise);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFEE82EE.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Violet => FromKnownColor(KnownColor.Violet);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF5DEB3.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Wheat => FromKnownColor(KnownColor.Wheat);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFFFFF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color White => FromKnownColor(KnownColor.White);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF5F5F5.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color WhiteSmoke => FromKnownColor(KnownColor.WhiteSmoke);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFFF00.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Yellow => FromKnownColor(KnownColor.Yellow);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF9ACD32.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color YellowGreen => FromKnownColor(KnownColor.YellowGreen);

		/// <summary>Creates a <see cref="T:System.Drawing.Color" /> structure from the specified 8-bit color values (red, green, and blue). The alpha value is implicitly 255 (fully opaque). Although this method allows a 32-bit value to be passed for each color component, the value of each component is limited to 8 bits.</summary>
		/// <param name="red">The red component value for the new <see cref="T:System.Drawing.Color" />. Valid values are 0 through 255.</param>
		/// <param name="green">The green component value for the new <see cref="T:System.Drawing.Color" />. Valid values are 0 through 255.</param>
		/// <param name="blue">The blue component value for the new <see cref="T:System.Drawing.Color" />. Valid values are 0 through 255.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> that this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="red" />, <paramref name="green" />, or <paramref name="blue" /> is less than 0 or greater than 255.</exception>
		public static Color FromArgb(int red, int green, int blue)
		{
			return FromArgb(255, red, green, blue);
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Color" /> structure from the four ARGB component (alpha, red, green, and blue) values. Although this method allows a 32-bit value to be passed for each component, the value of each component is limited to 8 bits.</summary>
		/// <param name="alpha">The alpha component. Valid values are 0 through 255.</param>
		/// <param name="red">The red component. Valid values are 0 through 255.</param>
		/// <param name="green">The green component. Valid values are 0 through 255.</param>
		/// <param name="blue">The blue component. Valid values are 0 through 255.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> that this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="alpha" />, <paramref name="red" />, <paramref name="green" />, or <paramref name="blue" /> is less than 0 or greater than 255.</exception>
		public static Color FromArgb(int alpha, int red, int green, int blue)
		{
			CheckARGBValues(alpha, red, green, blue);
			return new Color
			{
				state = 2,
				Value = (alpha << 24) + (red << 16) + (green << 8) + blue
			};
		}

		/// <summary>Gets the 32-bit ARGB value of this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The 32-bit ARGB value of this <see cref="T:System.Drawing.Color" />.</returns>
		public int ToArgb()
		{
			return (int)Value;
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Color" /> structure from the specified <see cref="T:System.Drawing.Color" /> structure, but with the new specified alpha value. Although this method allows a 32-bit value to be passed for the alpha value, the value is limited to 8 bits.</summary>
		/// <param name="alpha">The alpha value for the new <see cref="T:System.Drawing.Color" />. Valid values are 0 through 255.</param>
		/// <param name="baseColor">The <see cref="T:System.Drawing.Color" /> from which to create the new <see cref="T:System.Drawing.Color" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> that this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="alpha" /> is less than 0 or greater than 255.</exception>
		public static Color FromArgb(int alpha, Color baseColor)
		{
			return FromArgb(alpha, baseColor.R, baseColor.G, baseColor.B);
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Color" /> structure from a 32-bit ARGB value.</summary>
		/// <param name="argb">A value specifying the 32-bit ARGB value.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> structure that this method creates.</returns>
		public static Color FromArgb(int argb)
		{
			return FromArgb((argb >> 24) & 0xFF, (argb >> 16) & 0xFF, (argb >> 8) & 0xFF, argb & 0xFF);
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Color" /> structure from the specified predefined color.</summary>
		/// <param name="color">An element of the <see cref="T:System.Drawing.KnownColor" /> enumeration.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> that this method creates.</returns>
		public static Color FromKnownColor(KnownColor color)
		{
			short num = (short)color;
			Color result;
			if (num <= 0 || num >= KnownColors.ArgbValues.Length)
			{
				result = FromArgb(0, 0, 0, 0);
				result.state |= 4;
			}
			else
			{
				result = new Color
				{
					state = 7
				};
				if (num < 27 || num > 169)
				{
					result.state |= 8;
				}
				result.Value = KnownColors.ArgbValues[num];
			}
			result.knownColor = num;
			return result;
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Color" /> structure from the specified name of a predefined color.</summary>
		/// <param name="name">A string that is the name of a predefined color. Valid names are the same as the names of the elements of the <see cref="T:System.Drawing.KnownColor" /> enumeration.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> that this method creates.</returns>
		public static Color FromName(string name)
		{
			try
			{
				return FromKnownColor((KnownColor)Enum.Parse(typeof(KnownColor), name, ignoreCase: true));
			}
			catch
			{
				Color result = FromArgb(0, 0, 0, 0);
				result.name = name;
				result.state |= 4;
				return result;
			}
		}

		/// <summary>Tests whether two specified <see cref="T:System.Drawing.Color" /> structures are equivalent.</summary>
		/// <param name="left">The <see cref="T:System.Drawing.Color" /> that is to the left of the equality operator.</param>
		/// <param name="right">The <see cref="T:System.Drawing.Color" /> that is to the right of the equality operator.</param>
		/// <returns>
		///   <see langword="true" /> if the two <see cref="T:System.Drawing.Color" /> structures are equal; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(Color left, Color right)
		{
			if (left.Value != right.Value)
			{
				return false;
			}
			if (left.IsNamedColor != right.IsNamedColor)
			{
				return false;
			}
			if (left.IsSystemColor != right.IsSystemColor)
			{
				return false;
			}
			if (left.IsEmpty != right.IsEmpty)
			{
				return false;
			}
			if (left.IsNamedColor && left.Name != right.Name)
			{
				return false;
			}
			return true;
		}

		/// <summary>Tests whether two specified <see cref="T:System.Drawing.Color" /> structures are different.</summary>
		/// <param name="left">The <see cref="T:System.Drawing.Color" /> that is to the left of the inequality operator.</param>
		/// <param name="right">The <see cref="T:System.Drawing.Color" /> that is to the right of the inequality operator.</param>
		/// <returns>
		///   <see langword="true" /> if the two <see cref="T:System.Drawing.Color" /> structures are different; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(Color left, Color right)
		{
			return !(left == right);
		}

		/// <summary>Gets the hue-saturation-lightness (HSL) lightness value for this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The lightness of this <see cref="T:System.Drawing.Color" />. The lightness ranges from 0.0 through 1.0, where 0.0 represents black and 1.0 represents white.</returns>
		public float GetBrightness()
		{
			byte b = Math.Min(R, Math.Min(G, B));
			return (float)(Math.Max(R, Math.Max(G, B)) + b) / 510f;
		}

		/// <summary>Gets the hue-saturation-lightness (HSL) saturation value for this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The saturation of this <see cref="T:System.Drawing.Color" />. The saturation ranges from 0.0 through 1.0, where 0.0 is grayscale and 1.0 is the most saturated.</returns>
		public float GetSaturation()
		{
			byte b = Math.Min(R, Math.Min(G, B));
			byte b2 = Math.Max(R, Math.Max(G, B));
			if (b2 == b)
			{
				return 0f;
			}
			int num = b2 + b;
			if (num > 255)
			{
				num = 510 - num;
			}
			return (float)(b2 - b) / (float)num;
		}

		/// <summary>Gets the hue-saturation-lightness (HSL) hue value, in degrees, for this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The hue, in degrees, of this <see cref="T:System.Drawing.Color" />. The hue is measured in degrees, ranging from 0.0 through 360.0, in HSL color space.</returns>
		public float GetHue()
		{
			int r = R;
			int g = G;
			int b = B;
			byte b2 = (byte)Math.Min(r, Math.Min(g, b));
			byte b3 = (byte)Math.Max(r, Math.Max(g, b));
			if (b3 == b2)
			{
				return 0f;
			}
			float num = b3 - b2;
			float num2 = (float)(b3 - r) / num;
			float num3 = (float)(b3 - g) / num;
			float num4 = (float)(b3 - b) / num;
			float num5 = 0f;
			if (r == b3)
			{
				num5 = 60f * (6f + num4 - num3);
			}
			if (g == b3)
			{
				num5 = 60f * (2f + num2 - num4);
			}
			if (b == b3)
			{
				num5 = 60f * (4f + num3 - num2);
			}
			if (num5 > 360f)
			{
				num5 -= 360f;
			}
			return num5;
		}

		/// <summary>Gets the <see cref="T:System.Drawing.KnownColor" /> value of this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>An element of the <see cref="T:System.Drawing.KnownColor" /> enumeration, if the <see cref="T:System.Drawing.Color" /> is created from a predefined color by using either the <see cref="M:System.Drawing.Color.FromName(System.String)" /> method or the <see cref="M:System.Drawing.Color.FromKnownColor(System.Drawing.KnownColor)" /> method; otherwise, 0.</returns>
		public KnownColor ToKnownColor()
		{
			return (KnownColor)knownColor;
		}

		/// <summary>Tests whether the specified object is a <see cref="T:System.Drawing.Color" /> structure and is equivalent to this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <param name="obj">The object to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.Color" /> structure equivalent to this <see cref="T:System.Drawing.Color" /> structure; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is Color color))
			{
				return false;
			}
			return this == color;
		}

		/// <summary>Returns a hash code for this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>An integer value that specifies the hash code for this <see cref="T:System.Drawing.Color" />.</returns>
		public override int GetHashCode()
		{
			int num = (int)(Value ^ (Value >> 32) ^ state ^ (knownColor >> 16));
			if (IsNamedColor)
			{
				num ^= Name.GetHashCode();
			}
			return num;
		}

		/// <summary>Converts this <see cref="T:System.Drawing.Color" /> structure to a human-readable string.</summary>
		/// <returns>A string that is the name of this <see cref="T:System.Drawing.Color" />, if the <see cref="T:System.Drawing.Color" /> is created from a predefined color by using either the <see cref="M:System.Drawing.Color.FromName(System.String)" /> method or the <see cref="M:System.Drawing.Color.FromKnownColor(System.Drawing.KnownColor)" /> method; otherwise, a string that consists of the ARGB component names and their values.</returns>
		public override string ToString()
		{
			if (IsEmpty)
			{
				return "Color [Empty]";
			}
			if (IsNamedColor)
			{
				return "Color [" + Name + "]";
			}
			return $"Color [A={A}, R={R}, G={G}, B={B}]";
		}

		private static void CheckRGBValues(int red, int green, int blue)
		{
			if (red > 255 || red < 0)
			{
				throw CreateColorArgumentException(red, "red");
			}
			if (green > 255 || green < 0)
			{
				throw CreateColorArgumentException(green, "green");
			}
			if (blue > 255 || blue < 0)
			{
				throw CreateColorArgumentException(blue, "blue");
			}
		}

		private static ArgumentException CreateColorArgumentException(int value, string color)
		{
			return new ArgumentException(string.Format("'{0}' is not a valid value for '{1}'. '{1}' should be greater or equal to 0 and less than or equal to 255.", value, color));
		}

		private static void CheckARGBValues(int alpha, int red, int green, int blue)
		{
			if (alpha > 255 || alpha < 0)
			{
				throw CreateColorArgumentException(alpha, "alpha");
			}
			CheckRGBValues(red, green, blue);
		}
	}
	/// <summary>Converts colors from one data type to another. Access this class through the <see cref="T:System.ComponentModel.TypeDescriptor" />.</summary>
	public class ColorConverter : TypeConverter
	{
		private sealed class CompareColors : IComparer
		{
			public int Compare(object x, object y)
			{
				return string.Compare(((Color)x).Name, ((Color)y).Name);
			}
		}

		private static StandardValuesCollection cached;

		private static object creatingCached = new object();

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.ColorConverter" /> class.</summary>
		public ColorConverter()
		{
		}

		/// <summary>Determines if this converter can convert an object in the given source type to the native type of the converter.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. You can use this object to get additional information about the environment from which this converter is being invoked.</param>
		/// <param name="sourceType">The type from which you want to convert.</param>
		/// <returns>
		///   <see langword="true" /> if this object can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Returns a value indicating whether this converter can convert an object to the given destination type using the context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> that represents the type to which you want to convert.</param>
		/// <returns>
		///   <see langword="true" /> if this converter can perform the operation; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		internal static Color StaticConvertFromString(ITypeDescriptorContext context, string s, CultureInfo culture)
		{
			if (culture == null)
			{
				culture = CultureInfo.InvariantCulture;
			}
			s = s.Trim();
			if (s.Length == 0)
			{
				return Color.Empty;
			}
			if (char.IsLetter(s[0]))
			{
				KnownColor kc;
				try
				{
					kc = (KnownColor)Enum.Parse(typeof(KnownColor), s, ignoreCase: true);
				}
				catch (Exception innerException)
				{
					string text = global::Locale.GetText("Invalid color name '{0}'.", s);
					throw new Exception(text, new FormatException(text, innerException));
				}
				return KnownColors.FromKnownColor(kc);
			}
			string listSeparator = culture.TextInfo.ListSeparator;
			Color color = Color.Empty;
			if (s.IndexOf(listSeparator) == -1)
			{
				bool flag = s[0] == '#';
				int num = (flag ? 1 : 0);
				bool flag2 = false;
				if (s.Length > num + 1 && s[num] == '0')
				{
					flag2 = s[num + 1] == 'x' || s[num + 1] == 'X';
					if (flag2)
					{
						num += 2;
					}
				}
				if (flag || flag2)
				{
					s = s.Substring(num);
					int num2;
					try
					{
						num2 = int.Parse(s, NumberStyles.HexNumber);
					}
					catch (Exception innerException2)
					{
						throw new Exception(global::Locale.GetText("Invalid Int32 value '{0}'.", s), innerException2);
					}
					if (s.Length < 6 || (s.Length == 6 && flag && flag2))
					{
						num2 &= 0xFFFFFF;
					}
					else if (num2 >> 24 == 0)
					{
						num2 |= -16777216;
					}
					color = Color.FromArgb(num2);
				}
			}
			if (color.IsEmpty)
			{
				Int32Converter int32Converter = new Int32Converter();
				string[] array = s.Split(listSeparator.ToCharArray());
				int[] array2 = new int[array.Length];
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = (int)int32Converter.ConvertFrom(context, culture, array[i]);
				}
				color = array.Length switch
				{
					1 => Color.FromArgb(array2[0]), 
					3 => Color.FromArgb(array2[0], array2[1], array2[2]), 
					4 => Color.FromArgb(array2[0], array2[1], array2[2], array2[3]), 
					_ => throw new ArgumentException(s + " is not a valid color value."), 
				};
			}
			if (!color.IsEmpty)
			{
				Color result = KnownColors.FindColorMatch(color);
				if (!result.IsEmpty)
				{
					return result;
				}
			}
			return color;
		}

		/// <summary>Converts the given object to the converter's native type.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> that provides a format context. You can use this object to get additional information about the environment from which this converter is being invoked.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> that specifies the culture to represent the color.</param>
		/// <param name="value">The object to convert.</param>
		/// <returns>An <see cref="T:System.Object" /> representing the converted value.</returns>
		/// <exception cref="T:System.ArgumentException">The conversion cannot be performed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (!(value is string s))
			{
				return base.ConvertFrom(context, culture, value);
			}
			return StaticConvertFromString(context, s, culture);
		}

		/// <summary>Converts the specified object to another type.</summary>
		/// <param name="context">A formatter context. Use this object to extract additional information about the environment from which this converter is being invoked. Always check whether this value is <see langword="null" />. Also, properties on the context object may return <see langword="null" />.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> that specifies the culture to represent the color.</param>
		/// <param name="value">The object to convert.</param>
		/// <param name="destinationType">The type to convert the object to.</param>
		/// <returns>An <see cref="T:System.Object" /> representing the converted value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="destinationtype" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be performed.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (value is Color color)
			{
				if (destinationType == typeof(string))
				{
					if (color == Color.Empty)
					{
						return string.Empty;
					}
					if (color.IsKnownColor || color.IsNamedColor)
					{
						return color.Name;
					}
					string listSeparator = culture.TextInfo.ListSeparator;
					StringBuilder stringBuilder = new StringBuilder();
					if (color.A != byte.MaxValue)
					{
						stringBuilder.Append(color.A);
						stringBuilder.Append(listSeparator);
						stringBuilder.Append(" ");
					}
					stringBuilder.Append(color.R);
					stringBuilder.Append(listSeparator);
					stringBuilder.Append(" ");
					stringBuilder.Append(color.G);
					stringBuilder.Append(listSeparator);
					stringBuilder.Append(" ");
					stringBuilder.Append(color.B);
					return stringBuilder.ToString();
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					if (color.IsEmpty)
					{
						return new InstanceDescriptor(typeof(Color).GetTypeInfo().GetField("Empty"), null);
					}
					if (color.IsSystemColor)
					{
						return new InstanceDescriptor(typeof(SystemColors).GetTypeInfo().GetProperty(color.Name), null);
					}
					if (color.IsKnownColor)
					{
						return new InstanceDescriptor(typeof(Color).GetTypeInfo().GetProperty(color.Name), null);
					}
					return new InstanceDescriptor(typeof(Color).GetTypeInfo().GetMethod("FromArgb", new Type[4]
					{
						typeof(int),
						typeof(int),
						typeof(int),
						typeof(int)
					}), new object[4] { color.A, color.R, color.G, color.B });
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <summary>Retrieves a collection containing a set of standard values for the data type for which this validator is designed. This will return <see langword="null" /> if the data type does not support a standard set of values.</summary>
		/// <param name="context">A formatter context. Use this object to extract additional information about the environment from which this converter is being invoked. Always check whether this value is <see langword="null" />. Also, properties on the context object may return <see langword="null" />.</param>
		/// <returns>A collection containing <see langword="null" /> or a standard set of valid values. The default implementation always returns <see langword="null" />.</returns>
		public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
		{
			lock (creatingCached)
			{
				if (cached != null)
				{
					return cached;
				}
				Array array = Array.CreateInstance(typeof(Color), KnownColors.ArgbValues.Length - 1);
				for (int i = 1; i < KnownColors.ArgbValues.Length; i++)
				{
					array.SetValue(KnownColors.FromKnownColor((KnownColor)i), i - 1);
				}
				Array.Sort(array, 0, array.Length, new CompareColors());
				cached = new StandardValuesCollection(array);
			}
			return cached;
		}

		/// <summary>Determines if this object supports a standard set of values that can be chosen from a list.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> through which additional context can be provided.</param>
		/// <returns>
		///   <see langword="true" /> if <see cref="Overload:System.Drawing.ColorConverter.GetStandardValues" /> must be called to find a common set of values the object supports; otherwise, <see langword="false" />.</returns>
		public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
	/// <summary>Translates colors to and from GDI+ <see cref="T:System.Drawing.Color" /> structures. This class cannot be inherited.</summary>
	public sealed class ColorTranslator
	{
		private ColorTranslator()
		{
		}

		/// <summary>Translates an HTML color representation to a GDI+ <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <param name="htmlColor">The string representation of the Html color to translate.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> structure that represents the translated HTML color or <see cref="F:System.Drawing.Color.Empty" /> if <paramref name="htmlColor" /> is <see langword="null" />.</returns>
		/// <exception cref="T:System.Exception">
		///   <paramref name="htmlColor" /> is not a valid HTML color name.</exception>
		public static Color FromHtml(string htmlColor)
		{
			if (string.IsNullOrEmpty(htmlColor))
			{
				return Color.Empty;
			}
			switch (htmlColor.ToLowerInvariant())
			{
			case "buttonface":
			case "threedface":
				return SystemColors.Control;
			case "buttonhighlight":
			case "threedlightshadow":
				return SystemColors.ControlLightLight;
			case "buttonshadow":
				return SystemColors.ControlDark;
			case "captiontext":
				return SystemColors.ActiveCaptionText;
			case "threeddarkshadow":
				return SystemColors.ControlDarkDark;
			case "threedhighlight":
				return SystemColors.ControlLight;
			case "background":
				return SystemColors.Desktop;
			case "buttontext":
				return SystemColors.ControlText;
			case "infobackground":
				return SystemColors.Info;
			case "lightgrey":
				return Color.LightGray;
			default:
				if (htmlColor[0] == '#' && htmlColor.Length == 4)
				{
					char c = htmlColor[1];
					char c2 = htmlColor[2];
					char c3 = htmlColor[3];
					htmlColor = new string(new char[7] { '#', c, c, c2, c2, c3, c3 });
				}
				return (Color)TypeDescriptor.GetConverter(typeof(Color)).ConvertFromString(htmlColor);
			}
		}

		internal static Color FromBGR(int bgr)
		{
			Color color = Color.FromArgb(255, bgr & 0xFF, (bgr >> 8) & 0xFF, (bgr >> 16) & 0xFF);
			Color result = KnownColors.FindColorMatch(color);
			if (!result.IsEmpty)
			{
				return result;
			}
			return color;
		}

		/// <summary>Translates an OLE color value to a GDI+ <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <param name="oleColor">The OLE color to translate.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> structure that represents the translated OLE color.</returns>
		public static Color FromOle(int oleColor)
		{
			return FromBGR(oleColor);
		}

		/// <summary>Translates a Windows color value to a GDI+ <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <param name="win32Color">The Windows color to translate.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> structure that represents the translated Windows color.</returns>
		public static Color FromWin32(int win32Color)
		{
			return FromBGR(win32Color);
		}

		/// <summary>Translates the specified <see cref="T:System.Drawing.Color" /> structure to an HTML string color representation.</summary>
		/// <param name="c">The <see cref="T:System.Drawing.Color" /> structure to translate.</param>
		/// <returns>The string that represents the HTML color.</returns>
		public static string ToHtml(Color c)
		{
			if (c.IsEmpty)
			{
				return string.Empty;
			}
			if (c.IsSystemColor)
			{
				KnownColor knownColor = c.ToKnownColor();
				switch (knownColor)
				{
				case KnownColor.ActiveBorder:
				case KnownColor.ActiveCaption:
				case KnownColor.AppWorkspace:
				case KnownColor.GrayText:
				case KnownColor.Highlight:
				case KnownColor.HighlightText:
				case KnownColor.InactiveBorder:
				case KnownColor.InactiveCaption:
				case KnownColor.InactiveCaptionText:
				case KnownColor.InfoText:
				case KnownColor.Menu:
				case KnownColor.MenuText:
				case KnownColor.ScrollBar:
				case KnownColor.Window:
				case KnownColor.WindowFrame:
				case KnownColor.WindowText:
					return KnownColors.GetName(knownColor).ToLowerInvariant();
				case KnownColor.ActiveCaptionText:
					return "captiontext";
				case KnownColor.Control:
					return "buttonface";
				case KnownColor.ControlDark:
					return "buttonshadow";
				case KnownColor.ControlDarkDark:
					return "threeddarkshadow";
				case KnownColor.ControlLight:
					return "buttonface";
				case KnownColor.ControlLightLight:
					return "buttonhighlight";
				case KnownColor.ControlText:
					return "buttontext";
				case KnownColor.Desktop:
					return "background";
				case KnownColor.HotTrack:
					return "highlight";
				case KnownColor.Info:
					return "infobackground";
				default:
					return string.Empty;
				}
			}
			if (c.IsNamedColor)
			{
				if (c == Color.LightGray)
				{
					return "LightGrey";
				}
				return c.Name;
			}
			return FormatHtml(c.R, c.G, c.B);
		}

		private static char GetHexNumber(int b)
		{
			return (char)((b > 9) ? (55 + b) : (48 + b));
		}

		private static string FormatHtml(int r, int g, int b)
		{
			return new string(new char[7]
			{
				'#',
				GetHexNumber((r >> 4) & 0xF),
				GetHexNumber(r & 0xF),
				GetHexNumber((g >> 4) & 0xF),
				GetHexNumber(g & 0xF),
				GetHexNumber((b >> 4) & 0xF),
				GetHexNumber(b & 0xF)
			});
		}

		/// <summary>Translates the specified <see cref="T:System.Drawing.Color" /> structure to an OLE color.</summary>
		/// <param name="c">The <see cref="T:System.Drawing.Color" /> structure to translate.</param>
		/// <returns>The OLE color value.</returns>
		public static int ToOle(Color c)
		{
			return (c.B << 16) | (c.G << 8) | c.R;
		}

		/// <summary>Translates the specified <see cref="T:System.Drawing.Color" /> structure to a Windows color.</summary>
		/// <param name="c">The <see cref="T:System.Drawing.Color" /> structure to translate.</param>
		/// <returns>The Windows color value.</returns>
		public static int ToWin32(Color c)
		{
			return (c.B << 16) | (c.G << 8) | c.R;
		}
	}
	internal sealed class ComIStreamMarshaler : ICustomMarshaler
	{
		private delegate int QueryInterfaceDelegate(IntPtr @this, [In] ref Guid riid, IntPtr ppvObject);

		private delegate int AddRefDelegate(IntPtr @this);

		private delegate int ReleaseDelegate(IntPtr @this);

		private delegate int ReadDelegate(IntPtr @this, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] pv, int cb, IntPtr pcbRead);

		private delegate int WriteDelegate(IntPtr @this, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] pv, int cb, IntPtr pcbWritten);

		private delegate int SeekDelegate(IntPtr @this, long dlibMove, int dwOrigin, IntPtr plibNewPosition);

		private delegate int SetSizeDelegate(IntPtr @this, long libNewSize);

		private delegate int CopyToDelegate(IntPtr @this, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "System.Drawing.ComIStreamMarshaler")] IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);

		private delegate int CommitDelegate(IntPtr @this, int grfCommitFlags);

		private delegate int RevertDelegate(IntPtr @this);

		private delegate int LockRegionDelegate(IntPtr @this, long libOffset, long cb, int dwLockType);

		private delegate int UnlockRegionDelegate(IntPtr @this, long libOffset, long cb, int dwLockType);

		private delegate int StatDelegate(IntPtr @this, out System.Runtime.InteropServices.ComTypes.STATSTG pstatstg, int grfStatFlag);

		private delegate int CloneDelegate(IntPtr @this, out IntPtr ppstm);

		[StructLayout(LayoutKind.Sequential)]
		private sealed class IStreamInterface
		{
			internal IntPtr lpVtbl;

			internal IntPtr gcHandle;
		}

		[StructLayout(LayoutKind.Sequential)]
		private sealed class IStreamVtbl
		{
			internal QueryInterfaceDelegate QueryInterface;

			internal AddRefDelegate AddRef;

			internal ReleaseDelegate Release;

			internal ReadDelegate Read;

			internal WriteDelegate Write;

			internal SeekDelegate Seek;

			internal SetSizeDelegate SetSize;

			internal CopyToDelegate CopyTo;

			internal CommitDelegate Commit;

			internal RevertDelegate Revert;

			internal LockRegionDelegate LockRegion;

			internal UnlockRegionDelegate UnlockRegion;

			internal StatDelegate Stat;

			internal CloneDelegate Clone;
		}

		private sealed class ManagedToNativeWrapper
		{
			[StructLayout(LayoutKind.Sequential)]
			private sealed class ReleaseSlot
			{
				internal ReleaseDelegate Release;
			}

			private static readonly Guid IID_IUnknown;

			private static readonly Guid IID_IStream;

			private static readonly MethodInfo exceptionGetHResult;

			private static readonly IStreamVtbl managedVtable;

			private static IntPtr comVtable;

			private static int vtableRefCount;

			private IStream managedInterface;

			private IntPtr comInterface;

			private GCHandle gcHandle;

			private int refCount = 1;

			static ManagedToNativeWrapper()
			{
				IID_IUnknown = new Guid("00000000-0000-0000-C000-000000000046");
				IID_IStream = new Guid("0000000C-0000-0000-C000-000000000046");
				exceptionGetHResult = typeof(Exception).GetTypeInfo().GetProperty("HResult", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.GetProperty | BindingFlags.ExactBinding, null, typeof(int), new Type[0], null).GetGetMethod(nonPublic: true);
				EventHandler value = OnShutdown;
				AppDomain currentDomain = AppDomain.CurrentDomain;
				currentDomain.DomainUnload += value;
				currentDomain.ProcessExit += value;
				managedVtable = new IStreamVtbl
				{
					QueryInterface = QueryInterface,
					AddRef = AddRef,
					Release = Release,
					Read = Read,
					Write = Write,
					Seek = Seek,
					SetSize = SetSize,
					CopyTo = CopyTo,
					Commit = Commit,
					Revert = Revert,
					LockRegion = LockRegion,
					UnlockRegion = UnlockRegion,
					Stat = Stat,
					Clone = Clone
				};
				CreateVtable();
			}

			private ManagedToNativeWrapper(IStream managedInterface)
			{
				lock (managedVtable)
				{
					if (vtableRefCount == 0 && comVtable == IntPtr.Zero)
					{
						CreateVtable();
					}
					vtableRefCount++;
				}
				try
				{
					this.managedInterface = managedInterface;
					gcHandle = GCHandle.Alloc(this);
					IStreamInterface structure = new IStreamInterface
					{
						lpVtbl = comVtable,
						gcHandle = (IntPtr)gcHandle
					};
					comInterface = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(IStreamInterface)));
					Marshal.StructureToPtr(structure, comInterface, fDeleteOld: false);
				}
				catch
				{
					Dispose();
					throw;
				}
			}

			private void Dispose()
			{
				if (gcHandle.IsAllocated)
				{
					gcHandle.Free();
				}
				if (comInterface != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(comInterface);
					comInterface = IntPtr.Zero;
				}
				managedInterface = null;
				lock (managedVtable)
				{
					if (--vtableRefCount == 0 && Environment.HasShutdownStarted)
					{
						DisposeVtable();
					}
				}
			}

			private static void OnShutdown(object sender, EventArgs e)
			{
				lock (managedVtable)
				{
					if (vtableRefCount == 0 && comVtable != IntPtr.Zero)
					{
						DisposeVtable();
					}
				}
			}

			private static void CreateVtable()
			{
				comVtable = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(IStreamVtbl)));
				Marshal.StructureToPtr(managedVtable, comVtable, fDeleteOld: false);
			}

			private static void DisposeVtable()
			{
				Marshal.DestroyStructure(comVtable, typeof(IStreamVtbl));
				Marshal.FreeHGlobal(comVtable);
				comVtable = IntPtr.Zero;
			}

			internal static IStream GetUnderlyingInterface(IntPtr comInterface, bool outParam)
			{
				if (Marshal.ReadIntPtr(comInterface) == comVtable)
				{
					IStream result = GetObject(comInterface).managedInterface;
					if (outParam)
					{
						Release(comInterface);
					}
					return result;
				}
				return null;
			}

			internal static IntPtr GetInterface(IStream managedInterface)
			{
				if (managedInterface == null)
				{
					return IntPtr.Zero;
				}
				IntPtr underlyingInterface;
				if ((underlyingInterface = NativeToManagedWrapper.GetUnderlyingInterface(managedInterface)) == IntPtr.Zero)
				{
					underlyingInterface = new ManagedToNativeWrapper(managedInterface).comInterface;
				}
				return underlyingInterface;
			}

			internal static void ReleaseInterface(IntPtr comInterface)
			{
				if (comInterface != IntPtr.Zero)
				{
					IntPtr intPtr = Marshal.ReadIntPtr(comInterface);
					if (intPtr == comVtable)
					{
						Release(comInterface);
					}
					else
					{
						((ReleaseSlot)Marshal.PtrToStructure((IntPtr)((long)intPtr + IntPtr.Size * 2), typeof(ReleaseSlot))).Release(comInterface);
					}
				}
			}

			private static int GetHRForException(Exception e)
			{
				return (int)exceptionGetHResult.Invoke(e, null);
			}

			private static ManagedToNativeWrapper GetObject(IntPtr @this)
			{
				return (ManagedToNativeWrapper)((GCHandle)Marshal.ReadIntPtr(@this, IntPtr.Size)).Target;
			}

			private static int QueryInterface(IntPtr @this, ref Guid riid, IntPtr ppvObject)
			{
				try
				{
					if (IID_IUnknown.Equals(riid) || IID_IStream.Equals(riid))
					{
						Marshal.WriteIntPtr(ppvObject, @this);
						AddRef(@this);
						return 0;
					}
					Marshal.WriteIntPtr(ppvObject, IntPtr.Zero);
					return -2147467262;
				}
				catch (Exception e)
				{
					return GetHRForException(e);
				}
			}

			private static int AddRef(IntPtr @this)
			{
				int num;
				try
				{
					ManagedToNativeWrapper managedToNativeWrapper = GetObject(@this);
					lock (managedToNativeWrapper)
					{
						num = ++managedToNativeWrapper.refCount;
						num = num;
					}
				}
				catch
				{
					num = 0;
				}
				return num;
			}

			private static int Release(IntPtr @this)
			{
				int num;
				try
				{
					ManagedToNativeWrapper managedToNativeWrapper = GetObject(@this);
					lock (managedToNativeWrapper)
					{
						if (managedToNativeWrapper.refCount != 0)
						{
							num = --managedToNativeWrapper.refCount;
							if (num == 0)
							{
								managedToNativeWrapper.Dispose();
							}
						}
						num = managedToNativeWrapper.refCount;
					}
				}
				catch
				{
					num = 0;
				}
				return num;
			}

			private static int Read(IntPtr @this, byte[] pv, int cb, IntPtr pcbRead)
			{
				try
				{
					GetObject(@this).managedInterface.Read(pv, cb, pcbRead);
					return 0;
				}
				catch (Exception e)
				{
					return GetHRForException(e);
				}
			}

			private static int Write(IntPtr @this, byte[] pv, int cb, IntPtr pcbWritten)
			{
				try
				{
					GetObject(@this).managedInterface.Write(pv, cb, pcbWritten);
					return 0;
				}
				catch (Exception e)
				{
					return GetHRForException(e);
				}
			}

			private static int Seek(IntPtr @this, long dlibMove, int dwOrigin, IntPtr plibNewPosition)
			{
				try
				{
					GetObject(@this).managedInterface.Seek(dlibMove, dwOrigin, plibNewPosition);
					return 0;
				}
				catch (Exception e)
				{
					return GetHRForException(e);
				}
			}

			private static int SetSize(IntPtr @this, long libNewSize)
			{
				try
				{
					GetObject(@this).managedInterface.SetSize(libNewSize);
					return 0;
				}
				catch (Exception e)
				{
					return GetHRForException(e);
				}
			}

			private static int CopyTo(IntPtr @this, IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten)
			{
				try
				{
					GetObject(@this).managedInterface.CopyTo(pstm, cb, pcbRead, pcbWritten);
					return 0;
				}
				catch (Exception e)
				{
					return GetHRForException(e);
				}
			}

			private static int Commit(IntPtr @this, int grfCommitFlags)
			{
				try
				{
					GetObject(@this).managedInterface.Commit(grfCommitFlags);
					return 0;
				}
				catch (Exception e)
				{
					return GetHRForException(e);
				}
			}

			private static int Revert(IntPtr @this)
			{
				try
				{
					GetObject(@this).managedInterface.Revert();
					return 0;
				}
				catch (Exception e)
				{
					return GetHRForException(e);
				}
			}

			private static int LockRegion(IntPtr @this, long libOffset, long cb, int dwLockType)
			{
				try
				{
					GetObject(@this).managedInterface.LockRegion(libOffset, cb, dwLockType);
					return 0;
				}
				catch (Exception e)
				{
					return GetHRForException(e);
				}
			}

			private static int UnlockRegion(IntPtr @this, long libOffset, long cb, int dwLockType)
			{
				try
				{
					GetObject(@this).managedInterface.UnlockRegion(libOffset, cb, dwLockType);
					return 0;
				}
				catch (Exception e)
				{
					return GetHRForException(e);
				}
			}

			private static int Stat(IntPtr @this, out System.Runtime.InteropServices.ComTypes.STATSTG pstatstg, int grfStatFlag)
			{
				try
				{
					GetObject(@this).managedInterface.Stat(out pstatstg, grfStatFlag);
					return 0;
				}
				catch (Exception e)
				{
					pstatstg = default(System.Runtime.InteropServices.ComTypes.STATSTG);
					return GetHRForException(e);
				}
			}

			private static int Clone(IntPtr @this, out IntPtr ppstm)
			{
				ppstm = IntPtr.Zero;
				try
				{
					GetObject(@this).managedInterface.Clone(out var ppstm2);
					ppstm = GetInterface(ppstm2);
					return 0;
				}
				catch (Exception e)
				{
					return GetHRForException(e);
				}
			}
		}

		private sealed class NativeToManagedWrapper : IStream
		{
			private IntPtr comInterface;

			private IStreamVtbl managedVtable;

			private NativeToManagedWrapper(IntPtr comInterface, bool outParam)
			{
				this.comInterface = comInterface;
				managedVtable = (IStreamVtbl)Marshal.PtrToStructure(Marshal.ReadIntPtr(comInterface), typeof(IStreamVtbl));
				if (!outParam)
				{
					managedVtable.AddRef(comInterface);
				}
			}

			~NativeToManagedWrapper()
			{
				Dispose(disposing: false);
			}

			private void Dispose(bool disposing)
			{
				managedVtable.Release(comInterface);
				if (disposing)
				{
					comInterface = IntPtr.Zero;
					managedVtable = null;
					GC.SuppressFinalize(this);
				}
			}

			internal static IntPtr GetUnderlyingInterface(IStream managedInterface)
			{
				if (managedInterface is NativeToManagedWrapper)
				{
					NativeToManagedWrapper nativeToManagedWrapper = (NativeToManagedWrapper)managedInterface;
					nativeToManagedWrapper.managedVtable.AddRef(nativeToManagedWrapper.comInterface);
					return nativeToManagedWrapper.comInterface;
				}
				return IntPtr.Zero;
			}

			internal static IStream GetInterface(IntPtr comInterface, bool outParam)
			{
				if (comInterface == IntPtr.Zero)
				{
					return null;
				}
				IStream result;
				if ((result = ManagedToNativeWrapper.GetUnderlyingInterface(comInterface, outParam)) == null)
				{
					result = new NativeToManagedWrapper(comInterface, outParam);
				}
				return result;
			}

			internal static void ReleaseInterface(IStream managedInterface)
			{
				if (managedInterface is NativeToManagedWrapper)
				{
					((NativeToManagedWrapper)managedInterface).Dispose(disposing: true);
				}
			}

			private static void ThrowExceptionForHR(int result)
			{
				if (result < 0)
				{
					throw new COMException(null, result);
				}
			}

			public void Read(byte[] pv, int cb, IntPtr pcbRead)
			{
				ThrowExceptionForHR(managedVtable.Read(comInterface, pv, cb, pcbRead));
			}

			public void Write(byte[] pv, int cb, IntPtr pcbWritten)
			{
				ThrowExceptionForHR(managedVtable.Write(comInterface, pv, cb, pcbWritten));
			}

			public void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition)
			{
				ThrowExceptionForHR(managedVtable.Seek(comInterface, dlibMove, dwOrigin, plibNewPosition));
			}

			public void SetSize(long libNewSize)
			{
				ThrowExceptionForHR(managedVtable.SetSize(comInterface, libNewSize));
			}

			public void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten)
			{
				ThrowExceptionForHR(managedVtable.CopyTo(comInterface, pstm, cb, pcbRead, pcbWritten));
			}

			public void Commit(int grfCommitFlags)
			{
				ThrowExceptionForHR(managedVtable.Commit(comInterface, grfCommitFlags));
			}

			public void Revert()
			{
				ThrowExceptionForHR(managedVtable.Revert(comInterface));
			}

			public void LockRegion(long libOffset, long cb, int dwLockType)
			{
				ThrowExceptionForHR(managedVtable.LockRegion(comInterface, libOffset, cb, dwLockType));
			}

			public void UnlockRegion(long libOffset, long cb, int dwLockType)
			{
				ThrowExceptionForHR(managedVtable.UnlockRegion(comInterface, libOffset, cb, dwLockType));
			}

			public void Stat(out System.Runtime.InteropServices.ComTypes.STATSTG pstatstg, int grfStatFlag)
			{
				ThrowExceptionForHR(managedVtable.Stat(comInterface, out pstatstg, grfStatFlag));
			}

			public void Clone(out IStream ppstm)
			{
				ThrowExceptionForHR(managedVtable.Clone(comInterface, out var ppstm2));
				ppstm = GetInterface(ppstm2, outParam: true);
			}
		}

		private const int S_OK = 0;

		private const int E_NOINTERFACE = -2147467262;

		private static readonly ComIStreamMarshaler defaultInstance = new ComIStreamMarshaler();

		private ComIStreamMarshaler()
		{
		}

		private static ICustomMarshaler GetInstance(string cookie)
		{
			return defaultInstance;
		}

		public IntPtr MarshalManagedToNative(object managedObj)
		{
			return ManagedToNativeWrapper.GetInterface((IStream)managedObj);
		}

		public void CleanUpNativeData(IntPtr pNativeData)
		{
			ManagedToNativeWrapper.ReleaseInterface(pNativeData);
		}

		public object MarshalNativeToManaged(IntPtr pNativeData)
		{
			return NativeToManagedWrapper.GetInterface(pNativeData, outParam: false);
		}

		public void CleanUpManagedData(object managedObj)
		{
			NativeToManagedWrapper.ReleaseInterface((IStream)managedObj);
		}

		public int GetNativeDataSize()
		{
			return -1;
		}
	}
	internal sealed class ComIStreamWrapper : IStream
	{
		private const int STG_E_INVALIDFUNCTION = -2147287039;

		private readonly Stream baseStream;

		private long position = -1L;

		internal ComIStreamWrapper(Stream stream)
		{
			baseStream = stream;
		}

		private void SetSizeToPosition()
		{
			if (position != -1)
			{
				if (position > baseStream.Length)
				{
					baseStream.SetLength(position);
				}
				baseStream.Position = position;
				position = -1L;
			}
		}

		public void Read(byte[] pv, int cb, IntPtr pcbRead)
		{
			int val = 0;
			if (cb != 0)
			{
				SetSizeToPosition();
				val = baseStream.Read(pv, 0, cb);
			}
			if (pcbRead != IntPtr.Zero)
			{
				Marshal.WriteInt32(pcbRead, val);
			}
		}

		public void Write(byte[] pv, int cb, IntPtr pcbWritten)
		{
			if (cb != 0)
			{
				SetSizeToPosition();
				baseStream.Write(pv, 0, cb);
			}
			if (pcbWritten != IntPtr.Zero)
			{
				Marshal.WriteInt32(pcbWritten, cb);
			}
		}

		public void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition)
		{
			long length = baseStream.Length;
			long num = (SeekOrigin)dwOrigin switch
			{
				SeekOrigin.Begin => dlibMove, 
				SeekOrigin.Current => (position != -1) ? (position + dlibMove) : (baseStream.Position + dlibMove), 
				SeekOrigin.End => length + dlibMove, 
				_ => throw new ExternalException(null, -2147287039), 
			};
			if (num > length)
			{
				position = num;
			}
			else
			{
				baseStream.Position = num;
				position = -1L;
			}
			if (plibNewPosition != IntPtr.Zero)
			{
				Marshal.WriteInt64(plibNewPosition, num);
			}
		}

		public void SetSize(long libNewSize)
		{
			baseStream.SetLength(libNewSize);
		}

		public void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten)
		{
			long num = 0L;
			if (cb != 0L)
			{
				int num2 = (int)((cb >= 4096) ? 4096 : cb);
				byte[] array = new byte[num2];
				SetSizeToPosition();
				int num3;
				while ((num3 = baseStream.Read(array, 0, num2)) != 0)
				{
					pstm.Write(array, num3, IntPtr.Zero);
					num += num3;
					if (num >= cb)
					{
						break;
					}
					if (cb - num < 4096)
					{
						num2 = (int)(cb - num);
					}
				}
			}
			if (pcbRead != IntPtr.Zero)
			{
				Marshal.WriteInt64(pcbRead, num);
			}
			if (pcbWritten != IntPtr.Zero)
			{
				Marshal.WriteInt64(pcbWritten, num);
			}
		}

		public void Commit(int grfCommitFlags)
		{
			baseStream.Flush();
			SetSizeToPosition();
		}

		public void Revert()
		{
			throw new ExternalException(null, -2147287039);
		}

		public void LockRegion(long libOffset, long cb, int dwLockType)
		{
			throw new ExternalException(null, -2147287039);
		}

		public void UnlockRegion(long libOffset, long cb, int dwLockType)
		{
			throw new ExternalException(null, -2147287039);
		}

		public void Stat(out System.Runtime.InteropServices.ComTypes.STATSTG pstatstg, int grfStatFlag)
		{
			pstatstg = default(System.Runtime.InteropServices.ComTypes.STATSTG);
			pstatstg.cbSize = baseStream.Length;
		}

		public void Clone(out IStream ppstm)
		{
			ppstm = null;
			throw new ExternalException(null, -2147287039);
		}
	}
	/// <summary>Specifies alignment of content on the drawing surface.</summary>
	[Editor("System.Drawing.Design.ContentAlignmentEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	public enum ContentAlignment
	{
		/// <summary>Content is vertically aligned at the top, and horizontally aligned on the left.</summary>
		TopLeft = 1,
		/// <summary>Content is vertically aligned at the top, and horizontally aligned at the center.</summary>
		TopCenter = 2,
		/// <summary>Content is vertically aligned at the top, and horizontally aligned on the right.</summary>
		TopRight = 4,
		/// <summary>Content is vertically aligned in the middle, and horizontally aligned on the left.</summary>
		MiddleLeft = 0x10,
		/// <summary>Content is vertically aligned in the middle, and horizontally aligned at the center.</summary>
		MiddleCenter = 0x20,
		/// <summary>Content is vertically aligned in the middle, and horizontally aligned on the right.</summary>
		MiddleRight = 0x40,
		/// <summary>Content is vertically aligned at the bottom, and horizontally aligned on the left.</summary>
		BottomLeft = 0x100,
		/// <summary>Content is vertically aligned at the bottom, and horizontally aligned at the center.</summary>
		BottomCenter = 0x200,
		/// <summary>Content is vertically aligned at the bottom, and horizontally aligned on the right.</summary>
		BottomRight = 0x400
	}
	/// <summary>Determines how the source color in a copy pixel operation is combined with the destination color to result in a final color.</summary>
	[ComVisible(true)]
	public enum CopyPixelOperation
	{
		/// <summary>The destination area is filled by using the color associated with index 0 in the physical palette. (This color is black for the default physical palette.)</summary>
		Blackness = 66,
		/// <summary>Windows that are layered on top of your window are included in the resulting image. By default, the image contains only your window. Note that this generally cannot be used for printing device contexts.</summary>
		CaptureBlt = 1073741824,
		/// <summary>The destination area is inverted.</summary>
		DestinationInvert = 5570569,
		/// <summary>The colors of the source area are merged with the colors of the selected brush of the destination device context using the Boolean <see langword="AND" /> operator.</summary>
		MergeCopy = 12583114,
		/// <summary>The colors of the inverted source area are merged with the colors of the destination area by using the Boolean <see langword="OR" /> operator.</summary>
		MergePaint = 12255782,
		/// <summary>The bitmap is not mirrored.</summary>
		NoMirrorBitmap = int.MinValue,
		/// <summary>The inverted source area is copied to the destination.</summary>
		NotSourceCopy = 3342344,
		/// <summary>The source and destination colors are combined using the Boolean <see langword="OR" /> operator, and then resultant color is then inverted.</summary>
		NotSourceErase = 1114278,
		/// <summary>The brush currently selected in the destination device context is copied to the destination bitmap.</summary>
		PatCopy = 15728673,
		/// <summary>The colors of the brush currently selected in the destination device context are combined with the colors of the destination are using the Boolean <see langword="XOR" /> operator.</summary>
		PatInvert = 5898313,
		/// <summary>The colors of the brush currently selected in the destination device context are combined with the colors of the inverted source area using the Boolean <see langword="OR" /> operator. The result of this operation is combined with the colors of the destination area using the Boolean <see langword="OR" /> operator.</summary>
		PatPaint = 16452105,
		/// <summary>The colors of the source and destination areas are combined using the Boolean <see langword="AND" /> operator.</summary>
		SourceAnd = 8913094,
		/// <summary>The source area is copied directly to the destination area.</summary>
		SourceCopy = 13369376,
		/// <summary>The inverted colors of the destination area are combined with the colors of the source area using the Boolean <see langword="AND" /> operator.</summary>
		SourceErase = 4457256,
		/// <summary>The colors of the source and destination areas are combined using the Boolean <see langword="XOR" /> operator.</summary>
		SourceInvert = 6684742,
		/// <summary>The colors of the source and destination areas are combined using the Boolean <see langword="OR" /> operator.</summary>
		SourcePaint = 15597702,
		/// <summary>The destination area is filled by using the color associated with index 1 in the physical palette. (This color is white for the default physical palette.)</summary>
		Whiteness = 16711778
	}
	internal class ExternDll
	{
		public const string Gdiplus = "gdiplus";

		public const string User32 = "user32";

		public const string Gdi32 = "gdi32";

		public const string Kernel32 = "kernel32";

		public const string Winspool = "winspool.drv";

		public const string Comdlg32 = "comdlg32.dll";

		public const string Comctl32 = "comctl32.dll";

		public const string Shell32 = "shell32.dll";

		public const string Oleaut32 = "oleaut32.dll";
	}
	/// <summary>Defines a particular format for text, including font face, size, and style attributes. This class cannot be inherited.</summary>
	[Serializable]
	[Editor("System.Drawing.Design.FontEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	[ComVisible(true)]
	[TypeConverter(typeof(FontConverter))]
	public sealed class Font : MarshalByRefObject, ISerializable, ICloneable, IDisposable
	{
		private IntPtr fontObject = IntPtr.Zero;

		private string systemFontName;

		private string originalFontName;

		private float _size;

		private object olf;

		private const byte DefaultCharSet = 1;

		private static int CharSetOffset = -1;

		private bool _bold;

		private FontFamily _fontFamily;

		private byte _gdiCharSet;

		private bool _gdiVerticalFont;

		private bool _italic;

		private string _name;

		private float _sizeInPoints;

		private bool _strikeout;

		private FontStyle _style;

		private bool _underline;

		private GraphicsUnit _unit;

		private int _hashCode;

		internal IntPtr NativeObject => fontObject;

		/// <summary>Gets a value that indicates whether this <see cref="T:System.Drawing.Font" /> is bold.</summary>
		/// <returns>
		///   <see langword="true" /> if this <see cref="T:System.Drawing.Font" /> is bold; otherwise, <see langword="false" />.</returns>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool Bold => _bold;

		/// <summary>Gets the <see cref="T:System.Drawing.FontFamily" /> associated with this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.FontFamily" /> associated with this <see cref="T:System.Drawing.Font" />.</returns>
		[Browsable(false)]
		public FontFamily FontFamily => _fontFamily;

		/// <summary>Gets a byte value that specifies the GDI character set that this <see cref="T:System.Drawing.Font" /> uses.</summary>
		/// <returns>A byte value that specifies the GDI character set that this <see cref="T:System.Drawing.Font" /> uses. The default is 1.</returns>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public byte GdiCharSet => _gdiCharSet;

		/// <summary>Gets a Boolean value that indicates whether this <see cref="T:System.Drawing.Font" /> is derived from a GDI vertical font.</summary>
		/// <returns>
		///   <see langword="true" /> if this <see cref="T:System.Drawing.Font" /> is derived from a GDI vertical font; otherwise, <see langword="false" />.</returns>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool GdiVerticalFont => _gdiVerticalFont;

		/// <summary>Gets the line spacing of this font.</summary>
		/// <returns>The line spacing, in pixels, of this font.</returns>
		[Browsable(false)]
		public int Height => (int)Math.Ceiling(GetHeight());

		/// <summary>Gets a value indicating whether the font is a member of <see cref="T:System.Drawing.SystemFonts" />.</summary>
		/// <returns>
		///   <see langword="true" /> if the font is a member of <see cref="T:System.Drawing.SystemFonts" />; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
		[Browsable(false)]
		public bool IsSystemFont => !string.IsNullOrEmpty(systemFontName);

		/// <summary>Gets a value that indicates whether this font has the italic style applied.</summary>
		/// <returns>
		///   <see langword="true" /> to indicate this font has the italic style applied; otherwise, <see langword="false" />.</returns>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool Italic => _italic;

		/// <summary>Gets the face name of this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>A string representation of the face name of this <see cref="T:System.Drawing.Font" />.</returns>
		[TypeConverter(typeof(FontConverter.FontNameConverter))]
		[Editor("System.Drawing.Design.FontNameEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public string Name => _name;

		/// <summary>Gets the em-size of this <see cref="T:System.Drawing.Font" /> measured in the units specified by the <see cref="P:System.Drawing.Font.Unit" /> property.</summary>
		/// <returns>The em-size of this <see cref="T:System.Drawing.Font" />.</returns>
		public float Size => _size;

		/// <summary>Gets the em-size, in points, of this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>The em-size, in points, of this <see cref="T:System.Drawing.Font" />.</returns>
		[Browsable(false)]
		public float SizeInPoints => _sizeInPoints;

		/// <summary>Gets a value that indicates whether this <see cref="T:System.Drawing.Font" /> specifies a horizontal line through the font.</summary>
		/// <returns>
		///   <see langword="true" /> if this <see cref="T:System.Drawing.Font" /> has a horizontal line through it; otherwise, <see langword="false" />.</returns>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool Strikeout => _strikeout;

		/// <summary>Gets style information for this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.FontStyle" /> enumeration that contains style information for this <see cref="T:System.Drawing.Font" />.</returns>
		[Browsable(false)]
		public FontStyle Style => _style;

		/// <summary>Gets the name of the system font if the <see cref="P:System.Drawing.Font.IsSystemFont" /> property returns <see langword="true" />.</summary>
		/// <returns>The name of the system font, if <see cref="P:System.Drawing.Font.IsSystemFont" /> returns <see langword="true" />; otherwise, an empty string ("").</returns>
		[Browsable(false)]
		public string SystemFontName => systemFontName;

		/// <summary>Gets the name of the font originally specified.</summary>
		/// <returns>The string representing the name of the font originally specified.</returns>
		[Browsable(false)]
		public string OriginalFontName => originalFontName;

		/// <summary>Gets a value that indicates whether this <see cref="T:System.Drawing.Font" /> is underlined.</summary>
		/// <returns>
		///   <see langword="true" /> if this <see cref="T:System.Drawing.Font" /> is underlined; otherwise, <see langword="false" />.</returns>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool Underline => _underline;

		/// <summary>Gets the unit of measure for this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.GraphicsUnit" /> that represents the unit of measure for this <see cref="T:System.Drawing.Font" />.</returns>
		[TypeConverter(typeof(FontConverter.FontUnitConverter))]
		public GraphicsUnit Unit => _unit;

		private void CreateFont(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte charSet, bool isVertical)
		{
			originalFontName = familyName;
			FontFamily fontFamily;
			try
			{
				fontFamily = new FontFamily(familyName);
			}
			catch (Exception)
			{
				fontFamily = FontFamily.GenericSansSerif;
			}
			setProperties(fontFamily, emSize, style, unit, charSet, isVertical);
			Status status = GDIPlus.GdipCreateFont(fontFamily.NativeFamily, emSize, style, unit, out fontObject);
			if (status == Status.FontStyleNotFound)
			{
				throw new ArgumentException(global::Locale.GetText("Style {0} isn't supported by font {1}.", style.ToString(), familyName));
			}
			GDIPlus.CheckStatus(status);
		}

		private Font(SerializationInfo info, StreamingContext context)
		{
			string familyName = (string)info.GetValue("Name", typeof(string));
			float emSize = (float)info.GetValue("Size", typeof(float));
			FontStyle style = (FontStyle)info.GetValue("Style", typeof(FontStyle));
			GraphicsUnit unit = (GraphicsUnit)info.GetValue("Unit", typeof(GraphicsUnit));
			CreateFont(familyName, emSize, style, unit, 1, isVertical: false);
		}

		/// <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the target object.</summary>
		/// <param name="si">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
		/// <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this serialization.</param>
		void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context)
		{
			si.AddValue("Name", Name);
			si.AddValue("Size", Size);
			si.AddValue("Style", Style);
			si.AddValue("Unit", Unit);
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Font()
		{
			Dispose();
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Font" />.</summary>
		public void Dispose()
		{
			if (fontObject != IntPtr.Zero)
			{
				Status status = GDIPlus.GdipDeleteFont(fontObject);
				fontObject = IntPtr.Zero;
				GC.SuppressFinalize(this);
				GDIPlus.CheckStatus(status);
			}
		}

		internal void SetSystemFontName(string newSystemFontName)
		{
			systemFontName = newSystemFontName;
		}

		internal void unitConversion(GraphicsUnit fromUnit, GraphicsUnit toUnit, float nSrc, out float nTrg)
		{
			float num = 0f;
			nTrg = 0f;
			switch (fromUnit)
			{
			case GraphicsUnit.Display:
				num = nSrc / 75f;
				break;
			case GraphicsUnit.Document:
				num = nSrc / 300f;
				break;
			case GraphicsUnit.Inch:
				num = nSrc;
				break;
			case GraphicsUnit.Millimeter:
				num = nSrc / 25.4f;
				break;
			case GraphicsUnit.World:
			case GraphicsUnit.Pixel:
				num = nSrc / Graphics.systemDpiX;
				break;
			case GraphicsUnit.Point:
				num = nSrc / 72f;
				break;
			default:
				throw new ArgumentException("Invalid GraphicsUnit");
			}
			switch (toUnit)
			{
			case GraphicsUnit.Display:
				nTrg = num * 75f;
				break;
			case GraphicsUnit.Document:
				nTrg = num * 300f;
				break;
			case GraphicsUnit.Inch:
				nTrg = num;
				break;
			case GraphicsUnit.Millimeter:
				nTrg = num * 25.4f;
				break;
			case GraphicsUnit.World:
			case GraphicsUnit.Pixel:
				nTrg = num * Graphics.systemDpiX;
				break;
			case GraphicsUnit.Point:
				nTrg = num * 72f;
				break;
			default:
				throw new ArgumentException("Invalid GraphicsUnit");
			}
		}

		private void setProperties(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte charSet, bool isVertical)
		{
			_name = family.Name;
			_fontFamily = family;
			_size = emSize;
			_unit = unit;
			_style = style;
			_gdiCharSet = charSet;
			_gdiVerticalFont = isVertical;
			unitConversion(unit, GraphicsUnit.Point, emSize, out _sizeInPoints);
			_bold = (_italic = (_strikeout = (_underline = false)));
			if ((style & FontStyle.Bold) == FontStyle.Bold)
			{
				_bold = true;
			}
			if ((style & FontStyle.Italic) == FontStyle.Italic)
			{
				_italic = true;
			}
			if ((style & FontStyle.Strikeout) == FontStyle.Strikeout)
			{
				_strikeout = true;
			}
			if ((style & FontStyle.Underline) == FontStyle.Underline)
			{
				_underline = true;
			}
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Font" /> from the specified Windows handle.</summary>
		/// <param name="hfont">A Windows handle to a GDI font.</param>
		/// <returns>The <see cref="T:System.Drawing.Font" /> this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="hfont" /> points to an object that is not a TrueType font.</exception>
		public static Font FromHfont(IntPtr hfont)
		{
			FontStyle fontStyle = FontStyle.Regular;
			LOGFONT lf = default(LOGFONT);
			if (hfont == IntPtr.Zero)
			{
				return new Font("Arial", 10f, FontStyle.Regular);
			}
			if (GDIPlus.RunningOnUnix())
			{
				GDIPlus.CheckStatus(GDIPlus.GdipCreateFontFromHfont(hfont, out var font, ref lf));
				if (lf.lfItalic != 0)
				{
					fontStyle |= FontStyle.Italic;
				}
				if (lf.lfUnderline != 0)
				{
					fontStyle |= FontStyle.Underline;
				}
				if (lf.lfStrikeOut != 0)
				{
					fontStyle |= FontStyle.Strikeout;
				}
				if (lf.lfWeight > 400)
				{
					fontStyle |= FontStyle.Bold;
				}
				return new Font(size: (lf.lfHeight >= 0) ? ((float)lf.lfHeight) : ((float)(lf.lfHeight * -1)), newFontObject: font, familyName: lf.lfFaceName, style: fontStyle);
			}
			fontStyle = FontStyle.Regular;
			IntPtr dC = GDIPlus.GetDC(IntPtr.Zero);
			try
			{
				return FromLogFont(lf, dC);
			}
			finally
			{
				GDIPlus.ReleaseDC(IntPtr.Zero, dC);
			}
		}

		/// <summary>Returns a handle to this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>A Windows handle to this <see cref="T:System.Drawing.Font" />.</returns>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The operation was unsuccessful.</exception>
		public IntPtr ToHfont()
		{
			if (fontObject == IntPtr.Zero)
			{
				throw new ArgumentException(global::Locale.GetText("Object has been disposed."));
			}
			if (GDIPlus.RunningOnUnix())
			{
				return fontObject;
			}
			if (olf == null)
			{
				olf = default(LOGFONT);
				ToLogFont(olf);
			}
			LOGFONT logfont = (LOGFONT)olf;
			return GDIPlus.CreateFontIndirect(ref logfont);
		}

		internal Font(IntPtr newFontObject, string familyName, FontStyle style, float size)
		{
			FontFamily family;
			try
			{
				family = new FontFamily(familyName);
			}
			catch (Exception)
			{
				family = FontFamily.GenericSansSerif;
			}
			setProperties(family, size, style, GraphicsUnit.Pixel, 0, isVertical: false);
			fontObject = newFontObject;
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> that uses the specified existing <see cref="T:System.Drawing.Font" /> and <see cref="T:System.Drawing.FontStyle" /> enumeration.</summary>
		/// <param name="prototype">The existing <see cref="T:System.Drawing.Font" /> from which to create the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="newStyle">The <see cref="T:System.Drawing.FontStyle" /> to apply to the new <see cref="T:System.Drawing.Font" />. Multiple values of the <see cref="T:System.Drawing.FontStyle" /> enumeration can be combined with the <see langword="OR" /> operator.</param>
		public Font(Font prototype, FontStyle newStyle)
		{
			setProperties(prototype.FontFamily, prototype.Size, newStyle, prototype.Unit, prototype.GdiCharSet, prototype.GdiVerticalFont);
			GDIPlus.CheckStatus(GDIPlus.GdipCreateFont(_fontFamily.NativeFamily, Size, Style, Unit, out fontObject));
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size and unit. Sets the style to <see cref="F:System.Drawing.FontStyle.Regular" />.</summary>
		/// <param name="family">The <see cref="T:System.Drawing.FontFamily" /> of the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="family" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		public Font(FontFamily family, float emSize, GraphicsUnit unit)
			: this(family, emSize, FontStyle.Regular, unit, 1, gdiVerticalFont: false)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size and unit. The style is set to <see cref="F:System.Drawing.FontStyle.Regular" />.</summary>
		/// <param name="familyName">A string representation of the <see cref="T:System.Drawing.FontFamily" /> for the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		public Font(string familyName, float emSize, GraphicsUnit unit)
			: this(new FontFamily(familyName), emSize, FontStyle.Regular, unit, 1, gdiVerticalFont: false)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size.</summary>
		/// <param name="family">The <see cref="T:System.Drawing.FontFamily" /> of the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size, in points, of the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		public Font(FontFamily family, float emSize)
			: this(family, emSize, FontStyle.Regular, GraphicsUnit.Point, 1, gdiVerticalFont: false)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size and style.</summary>
		/// <param name="family">The <see cref="T:System.Drawing.FontFamily" /> of the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size, in points, of the new font.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="family" /> is <see langword="null" />.</exception>
		public Font(FontFamily family, float emSize, FontStyle style)
			: this(family, emSize, style, GraphicsUnit.Point, 1, gdiVerticalFont: false)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size, style, and unit.</summary>
		/// <param name="family">The <see cref="T:System.Drawing.FontFamily" /> of the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="family" /> is <see langword="null" />.</exception>
		public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit)
			: this(family, emSize, style, unit, 1, gdiVerticalFont: false)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size, style, unit, and character set.</summary>
		/// <param name="family">The <see cref="T:System.Drawing.FontFamily" /> of the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <param name="gdiCharSet">A <see cref="T:System.Byte" /> that specifies a  
		///  GDI character set to use for the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="family" /> is <see langword="null" />.</exception>
		public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet)
			: this(family, emSize, style, unit, gdiCharSet, gdiVerticalFont: false)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size, style, unit, and character set.</summary>
		/// <param name="family">The <see cref="T:System.Drawing.FontFamily" /> of the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <param name="gdiCharSet">A <see cref="T:System.Byte" /> that specifies a  
		///  GDI character set to use for this font.</param>
		/// <param name="gdiVerticalFont">A Boolean value indicating whether the new font is derived from a GDI vertical font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="family" /> is <see langword="null" /></exception>
		public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont)
		{
			if (family == null)
			{
				throw new ArgumentNullException("family");
			}
			setProperties(family, emSize, style, unit, gdiCharSet, gdiVerticalFont);
			GDIPlus.CheckStatus(GDIPlus.GdipCreateFont(family.NativeFamily, emSize, style, unit, out fontObject));
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size.</summary>
		/// <param name="familyName">A string representation of the <see cref="T:System.Drawing.FontFamily" /> for the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size, in points, of the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity or is not a valid number.</exception>
		public Font(string familyName, float emSize)
			: this(familyName, emSize, FontStyle.Regular, GraphicsUnit.Point, 1, gdiVerticalFont: false)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size and style.</summary>
		/// <param name="familyName">A string representation of the <see cref="T:System.Drawing.FontFamily" /> for the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size, in points, of the new font.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		public Font(string familyName, float emSize, FontStyle style)
			: this(familyName, emSize, style, GraphicsUnit.Point, 1, gdiVerticalFont: false)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size, style, and unit.</summary>
		/// <param name="familyName">A string representation of the <see cref="T:System.Drawing.FontFamily" /> for the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity or is not a valid number.</exception>
		public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit)
			: this(familyName, emSize, style, unit, 1, gdiVerticalFont: false)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size, style, unit, and character set.</summary>
		/// <param name="familyName">A string representation of the <see cref="T:System.Drawing.FontFamily" /> for the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <param name="gdiCharSet">A <see cref="T:System.Byte" /> that specifies a GDI character set to use for this font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet)
			: this(familyName, emSize, style, unit, gdiCharSet, gdiVerticalFont: false)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using the specified size, style, unit, and character set.</summary>
		/// <param name="familyName">A string representation of the <see cref="T:System.Drawing.FontFamily" /> for the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <param name="gdiCharSet">A <see cref="T:System.Byte" /> that specifies a GDI character set to use for this font.</param>
		/// <param name="gdiVerticalFont">A Boolean value indicating whether the new <see cref="T:System.Drawing.Font" /> is derived from a GDI vertical font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont)
		{
			CreateFont(familyName, emSize, style, unit, gdiCharSet, gdiVerticalFont);
		}

		internal Font(string familyName, float emSize, string systemName)
			: this(familyName, emSize, FontStyle.Regular, GraphicsUnit.Point, 1, gdiVerticalFont: false)
		{
			systemFontName = systemName;
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Font" /> this method creates, cast as an <see cref="T:System.Object" />.</returns>
		public object Clone()
		{
			return new Font(this, Style);
		}

		/// <summary>Indicates whether the specified object is a <see cref="T:System.Drawing.Font" /> and has the same <see cref="P:System.Drawing.Font.FontFamily" />, <see cref="P:System.Drawing.Font.GdiVerticalFont" />, <see cref="P:System.Drawing.Font.GdiCharSet" />, <see cref="P:System.Drawing.Font.Style" />, <see cref="P:System.Drawing.Font.Size" />, and <see cref="P:System.Drawing.Font.Unit" /> property values as this <see cref="T:System.Drawing.Font" />.</summary>
		/// <param name="obj">The object to test.</param>
		/// <returns>
		///   <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Drawing.Font" /> and has the same <see cref="P:System.Drawing.Font.FontFamily" />, <see cref="P:System.Drawing.Font.GdiVerticalFont" />, <see cref="P:System.Drawing.Font.GdiCharSet" />, <see cref="P:System.Drawing.Font.Style" />, <see cref="P:System.Drawing.Font.Size" />, and <see cref="P:System.Drawing.Font.Unit" /> property values as this <see cref="T:System.Drawing.Font" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is Font font))
			{
				return false;
			}
			if (font.FontFamily.Equals(FontFamily) && font.Size == Size && font.Style == Style && font.Unit == Unit && font.GdiCharSet == GdiCharSet && font.GdiVerticalFont == GdiVerticalFont)
			{
				return true;
			}
			return false;
		}

		/// <summary>Gets the hash code for this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>The hash code for this <see cref="T:System.Drawing.Font" />.</returns>
		public override int GetHashCode()
		{
			if (_hashCode == 0)
			{
				_hashCode = 17;
				_hashCode = _hashCode * 23 + _name.GetHashCode();
				_hashCode = _hashCode * 23 + FontFamily.GetHashCode();
				_hashCode = _hashCode * 23 + _size.GetHashCode();
				_hashCode = _hashCode * 23 + _unit.GetHashCode();
				_hashCode = _hashCode * 23 + _style.GetHashCode();
				_hashCode = _hashCode * 23 + _gdiCharSet;
				_hashCode = _hashCode * 23 + _gdiVerticalFont.GetHashCode();
			}
			return _hashCode;
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Font" /> from the specified Windows handle to a device context.</summary>
		/// <param name="hdc">A handle to a device context.</param>
		/// <returns>The <see cref="T:System.Drawing.Font" /> this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">The font for the specified device context is not a TrueType font.</exception>
		[System.MonoTODO("The hdc parameter has no direct equivalent in libgdiplus.")]
		public static Font FromHdc(IntPtr hdc)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Font" /> from the specified GDI logical font (LOGFONT) structure.</summary>
		/// <param name="lf">An <see cref="T:System.Object" /> that represents the GDI <see langword="LOGFONT" /> structure from which to create the <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="hdc">A handle to a device context that contains additional information about the <paramref name="lf" /> structure.</param>
		/// <returns>The <see cref="T:System.Drawing.Font" /> that this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">The font is not a TrueType font.</exception>
		[System.MonoTODO("The returned font may not have all it's properties initialized correctly.")]
		public static Font FromLogFont(object lf, IntPtr hdc)
		{
			LOGFONT lf2 = (LOGFONT)lf;
			GDIPlus.CheckStatus(GDIPlus.GdipCreateFontFromLogfont(hdc, ref lf2, out var ptr));
			return new Font(ptr, "Microsoft Sans Serif", FontStyle.Regular, 10f);
		}

		/// <summary>Returns the line spacing, in pixels, of this font.</summary>
		/// <returns>The line spacing, in pixels, of this font.</returns>
		public float GetHeight()
		{
			return GetHeight(Graphics.systemDpiY);
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Font" /> from the specified GDI logical font (LOGFONT) structure.</summary>
		/// <param name="lf">An <see cref="T:System.Object" /> that represents the GDI <see langword="LOGFONT" /> structure from which to create the <see cref="T:System.Drawing.Font" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Font" /> that this method creates.</returns>
		public static Font FromLogFont(object lf)
		{
			if (GDIPlus.RunningOnUnix())
			{
				return FromLogFont(lf, IntPtr.Zero);
			}
			IntPtr intPtr = IntPtr.Zero;
			try
			{
				intPtr = GDIPlus.GetDC(IntPtr.Zero);
				return FromLogFont(lf, intPtr);
			}
			finally
			{
				GDIPlus.ReleaseDC(IntPtr.Zero, intPtr);
			}
		}

		/// <summary>Creates a GDI logical font (LOGFONT) structure from this <see cref="T:System.Drawing.Font" />.</summary>
		/// <param name="logFont">An <see cref="T:System.Object" /> to represent the <see langword="LOGFONT" /> structure that this method creates.</param>
		public void ToLogFont(object logFont)
		{
			if (GDIPlus.RunningOnUnix())
			{
				using (Bitmap image = new Bitmap(1, 1, PixelFormat.Format32bppArgb))
				{
					using Graphics graphics = Graphics.FromImage(image);
					ToLogFont(logFont, graphics);
					return;
				}
			}
			IntPtr dC = GDIPlus.GetDC(IntPtr.Zero);
			try
			{
				using Graphics graphics2 = Graphics.FromHdc(dC);
				ToLogFont(logFont, graphics2);
			}
			finally
			{
				GDIPlus.ReleaseDC(IntPtr.Zero, dC);
			}
		}

		/// <summary>Creates a GDI logical font (LOGFONT) structure from this <see cref="T:System.Drawing.Font" />.</summary>
		/// <param name="logFont">An <see cref="T:System.Object" /> to represent the <see langword="LOGFONT" /> structure that this method creates.</param>
		/// <param name="graphics">A <see cref="T:System.Drawing.Graphics" /> that provides additional information for the <see langword="LOGFONT" /> structure.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="graphics" /> is <see langword="null" />.</exception>
		public void ToLogFont(object logFont, Graphics graphics)
		{
			if (graphics == null)
			{
				throw new ArgumentNullException("graphics");
			}
			if (logFont == null)
			{
				throw new AccessViolationException("logFont");
			}
			if (!logFont.GetType().GetTypeInfo().IsLayoutSequential)
			{
				throw new ArgumentException("logFont", global::Locale.GetText("Layout must be sequential."));
			}
			Type typeFromHandle = typeof(LOGFONT);
			int num = Marshal.SizeOf(logFont);
			if (num < Marshal.SizeOf(typeFromHandle))
			{
				return;
			}
			IntPtr intPtr = Marshal.AllocHGlobal(num);
			Status status;
			try
			{
				Marshal.StructureToPtr(logFont, intPtr, fDeleteOld: false);
				status = GDIPlus.GdipGetLogFont(NativeObject, graphics.NativeObject, logFont);
				if (status != Status.Ok)
				{
					Marshal.PtrToStructure(intPtr, logFont);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (CharSetOffset == -1)
			{
				CharSetOffset = (int)Marshal.OffsetOf(typeFromHandle, "lfCharSet");
			}
			GCHandle gCHandle = GCHandle.Alloc(logFont, GCHandleType.Pinned);
			try
			{
				IntPtr ptr = gCHandle.AddrOfPinnedObject();
				if (Marshal.ReadByte(ptr, CharSetOffset) == 0)
				{
					Marshal.WriteByte(ptr, CharSetOffset, 1);
				}
			}
			finally
			{
				gCHandle.Free();
			}
			GDIPlus.CheckStatus(status);
		}

		/// <summary>Returns the line spacing, in the current unit of a specified <see cref="T:System.Drawing.Graphics" />, of this font.</summary>
		/// <param name="graphics">A <see cref="T:System.Drawing.Graphics" /> that holds the vertical resolution, in dots per inch, of the display device as well as settings for page unit and page scale.</param>
		/// <returns>The line spacing, in pixels, of this font.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="graphics" /> is <see langword="null" />.</exception>
		public float GetHeight(Graphics graphics)
		{
			if (graphics == null)
			{
				throw new ArgumentNullException("graphics");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipGetFontHeight(fontObject, graphics.NativeObject, out var height));
			return height;
		}

		/// <summary>Returns the height, in pixels, of this <see cref="T:System.Drawing.Font" /> when drawn to a device with the specified vertical resolution.</summary>
		/// <param name="dpi">The vertical resolution, in dots per inch, used to calculate the height of the font.</param>
		/// <returns>The height, in pixels, of this <see cref="T:System.Drawing.Font" />.</returns>
		public float GetHeight(float dpi)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipGetFontHeightGivenDPI(fontObject, dpi, out var height));
			return height;
		}

		/// <summary>Returns a human-readable string representation of this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>A string that represents this <see cref="T:System.Drawing.Font" />.</returns>
		public override string ToString()
		{
			return $"[Font: Name={_name}, Size={Size}, Units={(int)_unit}, GdiCharSet={_gdiCharSet}, GdiVerticalFont={_gdiVerticalFont}]";
		}
	}
	/// <summary>Converts <see cref="T:System.Drawing.Font" /> objects from one data type to another.</summary>
	public class FontConverter : TypeConverter
	{
		/// <summary>
		///   <see cref="T:System.Drawing.FontConverter.FontNameConverter" /> is a type converter that is used to convert a font name to and from various other representations.</summary>
		public sealed class FontNameConverter : TypeConverter, IDisposable
		{
			private FontFamily[] fonts;

			/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.FontConverter.FontNameConverter" /> class.</summary>
			public FontNameConverter()
			{
				fonts = FontFamily.Families;
			}

			/// <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
			void IDisposable.Dispose()
			{
			}

			/// <summary>Determines if this converter can convert an object in the given source type to the native type of the converter.</summary>
			/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to extract additional information about the environment this converter is being invoked from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may return <see langword="null" />.</param>
			/// <param name="sourceType">The type you wish to convert from.</param>
			/// <returns>
			///   <see langword="true" /> if the converter can perform the conversion; otherwise, <see langword="false" />.</returns>
			public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
			{
				if (sourceType == typeof(string))
				{
					return true;
				}
				return base.CanConvertFrom(context, sourceType);
			}

			/// <summary>Converts the given object to the converter's native type.</summary>
			/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to extract additional information about the environment this converter is being invoked from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may return <see langword="null" />.</param>
			/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> to use to perform the conversion</param>
			/// <param name="value">The object to convert.</param>
			/// <returns>The converted object.</returns>
			/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
			public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
			{
				if (value is string)
				{
					return value;
				}
				return base.ConvertFrom(context, culture, value);
			}

			/// <summary>Retrieves a collection containing a set of standard values for the data type this converter is designed for.</summary>
			/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to extract additional information about the environment this converter is being invoked from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may return <see langword="null" />.</param>
			/// <returns>A collection containing a standard set of valid values, or <see langword="null" />. The default is <see langword="null" />.</returns>
			public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
			{
				string[] array = new string[fonts.Length];
				int num = fonts.Length;
				while (num > 0)
				{
					num--;
					array[num] = fonts[num].Name;
				}
				return new StandardValuesCollection(array);
			}

			/// <summary>Determines if the list of standard values returned from the <see cref="Overload:System.Drawing.FontConverter.FontNameConverter.GetStandardValues" /> method is an exclusive list.</summary>
			/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to extract additional information about the environment this converter is being invoked from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may return <see langword="null" />.</param>
			/// <returns>
			///   <see langword="true" /> if the collection returned from <see cref="Overload:System.Drawing.FontConverter.FontNameConverter.GetStandardValues" /> is an exclusive list of possible values; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
			public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)
			{
				return false;
			}

			/// <summary>Determines if this object supports a standard set of values that can be picked from a list.</summary>
			/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to extract additional information about the environment this converter is being invoked from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may return <see langword="null" />.</param>
			/// <returns>
			///   <see langword="true" /> if <see cref="Overload:System.Drawing.FontConverter.FontNameConverter.GetStandardValues" /> should be called to find a common set of values the object supports; otherwise, <see langword="false" />.</returns>
			public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
			{
				return true;
			}
		}

		/// <summary>Converts font units to and from other unit types.</summary>
		public class FontUnitConverter : EnumConverter
		{
			/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.FontConverter.FontUnitConverter" /> class.</summary>
			public FontUnitConverter()
				: base(typeof(GraphicsUnit))
			{
			}

			/// <summary>Returns a collection of standard values valid for the <see cref="T:System.Drawing.Font" /> type.</summary>
			/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
			public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
			{
				return base.GetStandardValues(context);
			}
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.FontConverter" /> object.</summary>
		public FontConverter()
		{
		}

		/// <summary>Allows the <see cref="T:System.Drawing.FontConverter" /> to attempt to free resources and perform other cleanup operations before the <see cref="T:System.Drawing.FontConverter" /> is reclaimed by garbage collection.</summary>
		~FontConverter()
		{
		}

		/// <summary>Determines whether this converter can convert an object in the specified source type to the native type of the converter.</summary>
		/// <param name="context">A formatter context. This object can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="sourceType">The type you want to convert from.</param>
		/// <returns>This method returns <see langword="true" /> if this object can perform the conversion.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Gets a value indicating whether this converter can convert an object to the given destination type using the context.</summary>
		/// <param name="context">An <see langword="ITypeDescriptorContext" /> object that provides a format context.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> object that represents the type you want to convert to.</param>
		/// <returns>This method returns <see langword="true" /> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(string))
			{
				return true;
			}
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts the specified object to another type.</summary>
		/// <param name="context">A formatter context. This object can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> object that specifies the culture used to represent the object.</param>
		/// <param name="value">The object to convert.</param>
		/// <param name="destinationType">The data type to convert the object to.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion was not successful.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == typeof(string) && value is Font)
			{
				Font font = (Font)value;
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(font.Name).Append(culture.TextInfo.ListSeparator[0] + " ");
				stringBuilder.Append(font.Size);
				switch (font.Unit)
				{
				case GraphicsUnit.Display:
					stringBuilder.Append("display");
					break;
				case GraphicsUnit.Document:
					stringBuilder.Append("doc");
					break;
				case GraphicsUnit.Point:
					stringBuilder.Append("pt");
					break;
				case GraphicsUnit.Inch:
					stringBuilder.Append("in");
					break;
				case GraphicsUnit.Millimeter:
					stringBuilder.Append("mm");
					break;
				case GraphicsUnit.Pixel:
					stringBuilder.Append("px");
					break;
				case GraphicsUnit.World:
					stringBuilder.Append("world");
					break;
				}
				if (font.Style != FontStyle.Regular)
				{
					stringBuilder.Append(culture.TextInfo.ListSeparator[0] + " style=").Append(font.Style);
				}
				return stringBuilder.ToString();
			}
			if (destinationType == typeof(InstanceDescriptor) && value is Font)
			{
				Font font2 = (Font)value;
				return new InstanceDescriptor(typeof(Font).GetTypeInfo().GetConstructor(new Type[4]
				{
					typeof(string),
					typeof(float),
					typeof(FontStyle),
					typeof(GraphicsUnit)
				}), new object[4] { font2.Name, font2.Size, font2.Style, font2.Unit });
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <summary>Converts the specified object to the native type of the converter.</summary>
		/// <param name="context">A formatter context. This object can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">A <see langword="CultureInfo" /> object that specifies the culture used to represent the font.</param>
		/// <param name="value">The object to convert.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion could not be performed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (!(value is string))
			{
				return base.ConvertFrom(context, culture, value);
			}
			string text = (string)value;
			text = text.Trim();
			if (text.Length == 0)
			{
				return null;
			}
			if (culture == null)
			{
				culture = CultureInfo.CurrentCulture;
			}
			string[] array = text.Split(new char[1] { culture.TextInfo.ListSeparator[0] });
			if (array.Length < 1)
			{
				throw new ArgumentException("Failed to parse font format");
			}
			text = array[0];
			float emSize = 8f;
			string text2 = "px";
			GraphicsUnit unit = GraphicsUnit.Pixel;
			if (array.Length > 1)
			{
				for (int i = 0; i < array[1].Length; i++)
				{
					if (char.IsLetter(array[1][i]))
					{
						emSize = (float)TypeDescriptor.GetConverter(typeof(float)).ConvertFromString(context, culture, array[1].Substring(0, i));
						text2 = array[1].Substring(i);
						break;
					}
				}
				switch (text2)
				{
				case "display":
					unit = GraphicsUnit.Display;
					break;
				case "doc":
					unit = GraphicsUnit.Document;
					break;
				case "pt":
					unit = GraphicsUnit.Point;
					break;
				case "in":
					unit = GraphicsUnit.Inch;
					break;
				case "mm":
					unit = GraphicsUnit.Millimeter;
					break;
				case "px":
					unit = GraphicsUnit.Pixel;
					break;
				case "world":
					unit = GraphicsUnit.World;
					break;
				}
			}
			FontStyle fontStyle = FontStyle.Regular;
			if (array.Length > 2)
			{
				for (int j = 2; j < array.Length; j++)
				{
					string obj = array[j];
					if (obj.IndexOf("Regular") != -1)
					{
						fontStyle |= FontStyle.Regular;
					}
					if (obj.IndexOf("Bold") != -1)
					{
						fontStyle |= FontStyle.Bold;
					}
					if (obj.IndexOf("Italic") != -1)
					{
						fontStyle |= FontStyle.Italic;
					}
					if (obj.IndexOf("Strikeout") != -1)
					{
						fontStyle |= FontStyle.Strikeout;
					}
					if (obj.IndexOf("Underline") != -1)
					{
						fontStyle |= FontStyle.Underline;
					}
				}
			}
			return new Font(text, emSize, fontStyle, unit);
		}

		/// <summary>Creates an object of this type by using a specified set of property values for the object.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <param name="propertyValues">A dictionary of new property values. The dictionary contains a series of name-value pairs, one for each property returned from the <see cref="Overload:System.Drawing.FontConverter.GetProperties" /> method.</param>
		/// <returns>The newly created object, or <see langword="null" /> if the object could not be created. The default implementation returns <see langword="null" />.  
		///  <see cref="M:System.Drawing.FontConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> useful for creating non-changeable objects that have changeable properties.</returns>
		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			byte gdiCharSet = 1;
			float emSize = 8f;
			string text = null;
			bool gdiVerticalFont = false;
			FontStyle fontStyle = FontStyle.Regular;
			FontFamily fontFamily = null;
			GraphicsUnit unit = GraphicsUnit.Point;
			object obj;
			if ((obj = propertyValues["GdiCharSet"]) != null)
			{
				gdiCharSet = (byte)obj;
			}
			if ((obj = propertyValues["Size"]) != null)
			{
				emSize = (float)obj;
			}
			if ((obj = propertyValues["Unit"]) != null)
			{
				unit = (GraphicsUnit)obj;
			}
			if ((obj = propertyValues["Name"]) != null)
			{
				text = (string)obj;
			}
			if ((obj = propertyValues["GdiVerticalFont"]) != null)
			{
				gdiVerticalFont = (bool)obj;
			}
			if ((obj = propertyValues["Bold"]) != null && (bool)obj)
			{
				fontStyle |= FontStyle.Bold;
			}
			if ((obj = propertyValues["Italic"]) != null && (bool)obj)
			{
				fontStyle |= FontStyle.Italic;
			}
			if ((obj = propertyValues["Strikeout"]) != null && (bool)obj)
			{
				fontStyle |= FontStyle.Strikeout;
			}
			if ((obj = propertyValues["Underline"]) != null && (bool)obj)
			{
				fontStyle |= FontStyle.Underline;
			}
			if (text == null)
			{
				fontFamily = new FontFamily("Tahoma");
			}
			else
			{
				text = text.ToLower();
				FontFamily[] families = new InstalledFontCollection().Families;
				foreach (FontFamily fontFamily2 in families)
				{
					if (text == fontFamily2.Name.ToLower())
					{
						fontFamily = fontFamily2;
						break;
					}
				}
				if (fontFamily == null)
				{
					families = new PrivateFontCollection().Families;
					foreach (FontFamily fontFamily3 in families)
					{
						if (text == fontFamily3.Name.ToLower())
						{
							fontFamily = fontFamily3;
							break;
						}
					}
				}
				if (fontFamily == null)
				{
					fontFamily = FontFamily.GenericSansSerif;
				}
			}
			return new Font(fontFamily, emSize, fontStyle, unit, gdiCharSet, gdiVerticalFont);
		}

		/// <summary>Determines whether changing a value on this object should require a call to the <see cref="Overload:System.Drawing.FontConverter.CreateInstance" /> method to create a new value.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <returns>This method returns <see langword="true" /> if the <see langword="CreateInstance" /> object should be called when a change is made to one or more properties of this object; otherwise, <see langword="false" />.</returns>
		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Retrieves the set of properties for this type. By default, a type does not have any properties to return.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <param name="value">The value of the object to get the properties for.</param>
		/// <param name="attributes">An array of <see cref="T:System.Attribute" /> objects that describe the properties.</param>
		/// <returns>The set of properties that should be exposed for this data type. If no properties should be exposed, this may return <see langword="null" />. The default implementation always returns <see langword="null" />.  
		///  An easy implementation of this method can call the <see cref="Overload:System.ComponentModel.TypeConverter.GetProperties" /> method for the correct data type.</returns>
		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			if (value is Font)
			{
				return TypeDescriptor.GetProperties(value, attributes);
			}
			return base.GetProperties(context, value, attributes);
		}

		/// <summary>Determines whether this object supports properties. The default is <see langword="false" />.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <returns>This method returns <see langword="true" /> if the <see cref="M:System.Drawing.FontConverter.GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext)" /> method should be called to find the properties of this object; otherwise, <see langword="false" />.</returns>
		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
	/// <summary>Defines a group of type faces having a similar basic design and certain variations in styles. This class cannot be inherited.</summary>
	public sealed class FontFamily : MarshalByRefObject, IDisposable
	{
		private string name;

		private IntPtr nativeFontFamily = IntPtr.Zero;

		internal IntPtr NativeObject => nativeFontFamily;

		internal IntPtr NativeFamily => nativeFontFamily;

		/// <summary>Gets the name of this <see cref="T:System.Drawing.FontFamily" />.</summary>
		/// <returns>A <see cref="T:System.String" /> that represents the name of this <see cref="T:System.Drawing.FontFamily" />.</returns>
		public string Name
		{
			get
			{
				if (nativeFontFamily == IntPtr.Zero)
				{
					throw new ArgumentException("Name", global::Locale.GetText("Object was disposed."));
				}
				if (name == null)
				{
					refreshName();
				}
				return name;
			}
		}

		/// <summary>Gets a generic monospace <see cref="T:System.Drawing.FontFamily" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.FontFamily" /> that represents a generic monospace font.</returns>
		public static FontFamily GenericMonospace => new FontFamily(GenericFontFamilies.Monospace);

		/// <summary>Gets a generic sans serif <see cref="T:System.Drawing.FontFamily" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.FontFamily" /> object that represents a generic sans serif font.</returns>
		public static FontFamily GenericSansSerif => new FontFamily(GenericFontFamilies.SansSerif);

		/// <summary>Gets a generic serif <see cref="T:System.Drawing.FontFamily" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.FontFamily" /> that represents a generic serif font.</returns>
		public static FontFamily GenericSerif => new FontFamily(GenericFontFamilies.Serif);

		/// <summary>Returns an array that contains all the <see cref="T:System.Drawing.FontFamily" /> objects associated with the current graphics context.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.FontFamily" /> objects associated with the current graphics context.</returns>
		public static FontFamily[] Families => new InstalledFontCollection().Families;

		internal FontFamily(IntPtr fntfamily)
		{
			nativeFontFamily = fntfamily;
		}

		internal void refreshName()
		{
			if (!(nativeFontFamily == IntPtr.Zero))
			{
				StringBuilder stringBuilder = new StringBuilder(32);
				GDIPlus.CheckStatus(GDIPlus.GdipGetFamilyName(nativeFontFamily, stringBuilder, 0));
				name = stringBuilder.ToString();
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~FontFamily()
		{
			Dispose();
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.FontFamily" /> from the specified generic font family.</summary>
		/// <param name="genericFamily">The <see cref="T:System.Drawing.Text.GenericFontFamilies" /> from which to create the new <see cref="T:System.Drawing.FontFamily" />.</param>
		public FontFamily(GenericFontFamilies genericFamily)
		{
			GDIPlus.CheckStatus(genericFamily switch
			{
				GenericFontFamilies.SansSerif => GDIPlus.GdipGetGenericFontFamilySansSerif(out nativeFontFamily), 
				GenericFontFamilies.Serif => GDIPlus.GdipGetGenericFontFamilySerif(out nativeFontFamily), 
				_ => GDIPlus.GdipGetGenericFontFamilyMonospace(out nativeFontFamily), 
			});
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.FontFamily" /> with the specified name.</summary>
		/// <param name="name">The name of the new <see cref="T:System.Drawing.FontFamily" />.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="name" /> is an empty string ("").  
		/// -or-  
		/// <paramref name="name" /> specifies a font that is not installed on the computer running the application.  
		/// -or-  
		/// <paramref name="name" /> specifies a font that is not a TrueType font.</exception>
		public FontFamily(string name)
			: this(name, null)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.FontFamily" /> in the specified <see cref="T:System.Drawing.Text.FontCollection" /> with the specified name.</summary>
		/// <param name="name">A <see cref="T:System.String" /> that represents the name of the new <see cref="T:System.Drawing.FontFamily" />.</param>
		/// <param name="fontCollection">The <see cref="T:System.Drawing.Text.FontCollection" /> that contains this <see cref="T:System.Drawing.FontFamily" />.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="name" /> is an empty string ("").  
		/// -or-  
		/// <paramref name="name" /> specifies a font that is not installed on the computer running the application.  
		/// -or-  
		/// <paramref name="name" /> specifies a font that is not a TrueType font.</exception>
		public FontFamily(string name, FontCollection fontCollection)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateFontFamilyFromName(name, fontCollection?._nativeFontCollection ?? IntPtr.Zero, out nativeFontFamily));
		}

		/// <summary>Returns the cell ascent, in design units, of the <see cref="T:System.Drawing.FontFamily" /> of the specified style.</summary>
		/// <param name="style">A <see cref="T:System.Drawing.FontStyle" /> that contains style information for the font.</param>
		/// <returns>The cell ascent for this <see cref="T:System.Drawing.FontFamily" /> that uses the specified <see cref="T:System.Drawing.FontStyle" />.</returns>
		public int GetCellAscent(FontStyle style)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipGetCellAscent(nativeFontFamily, (int)style, out var ascent));
			return ascent;
		}

		/// <summary>Returns the cell descent, in design units, of the <see cref="T:System.Drawing.FontFamily" /> of the specified style.</summary>
		/// <param name="style">A <see cref="T:System.Drawing.FontStyle" /> that contains style information for the font.</param>
		/// <returns>The cell descent metric for this <see cref="T:System.Drawing.FontFamily" /> that uses the specified <see cref="T:System.Drawing.FontStyle" />.</returns>
		public int GetCellDescent(FontStyle style)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipGetCellDescent(nativeFontFamily, (int)style, out var descent));
			return descent;
		}

		/// <summary>Gets the height, in font design units, of the em square for the specified style.</summary>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> for which to get the em height.</param>
		/// <returns>The height of the em square.</returns>
		public int GetEmHeight(FontStyle style)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipGetEmHeight(nativeFontFamily, (int)style, out var emHeight));
			return emHeight;
		}

		/// <summary>Returns the line spacing, in design units, of the <see cref="T:System.Drawing.FontFamily" /> of the specified style. The line spacing is the vertical distance between the base lines of two consecutive lines of text.</summary>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> to apply.</param>
		/// <returns>The distance between two consecutive lines of text.</returns>
		public int GetLineSpacing(FontStyle style)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipGetLineSpacing(nativeFontFamily, (int)style, out var spacing));
			return spacing;
		}

		/// <summary>Indicates whether the specified <see cref="T:System.Drawing.FontStyle" /> enumeration is available.</summary>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if the specified <see cref="T:System.Drawing.FontStyle" /> is available; otherwise, <see langword="false" />.</returns>
		[System.MonoDocumentationNote("When used with libgdiplus this method always return true (styles are created on demand).")]
		public bool IsStyleAvailable(FontStyle style)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipIsStyleAvailable(nativeFontFamily, (int)style, out var styleAvailable));
			return styleAvailable;
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.FontFamily" />.</summary>
		public void Dispose()
		{
			if (nativeFontFamily != IntPtr.Zero)
			{
				Status status = GDIPlus.GdipDeleteFontFamily(nativeFontFamily);
				nativeFontFamily = IntPtr.Zero;
				GC.SuppressFinalize(this);
				GDIPlus.CheckStatus(status);
			}
		}

		/// <summary>Indicates whether the specified object is a <see cref="T:System.Drawing.FontFamily" /> and is identical to this <see cref="T:System.Drawing.FontFamily" />.</summary>
		/// <param name="obj">The object to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.FontFamily" /> and is identical to this <see cref="T:System.Drawing.FontFamily" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is FontFamily fontFamily))
			{
				return false;
			}
			return Name == fontFamily.Name;
		}

		/// <summary>Gets a hash code for this <see cref="T:System.Drawing.FontFamily" />.</summary>
		/// <returns>The hash code for this <see cref="T:System.Drawing.FontFamily" />.</returns>
		public override int GetHashCode()
		{
			return Name.GetHashCode();
		}

		/// <summary>Returns an array that contains all the <see cref="T:System.Drawing.FontFamily" /> objects available for the specified graphics context.</summary>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> object from which to return <see cref="T:System.Drawing.FontFamily" /> objects.</param>
		/// <returns>An array of <see cref="T:System.Drawing.FontFamily" /> objects available for the specified <see cref="T:System.Drawing.Graphics" /> object.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="graphics" /> is <see langword="null" />.</exception>
		public static FontFamily[] GetFamilies(Graphics graphics)
		{
			if (graphics == null)
			{
				throw new ArgumentNullException("graphics");
			}
			return new InstalledFontCollection().Families;
		}

		/// <summary>Returns the name, in the specified language, of this <see cref="T:System.Drawing.FontFamily" />.</summary>
		/// <param name="language">The language in which the name is returned.</param>
		/// <returns>A <see cref="T:System.String" /> that represents the name, in the specified language, of this <see cref="T:System.Drawing.FontFamily" />.</returns>
		[System.MonoLimitation("The language parameter is ignored. We always return the name using the default system language.")]
		public string GetName(int language)
		{
			return Name;
		}

		/// <summary>Converts this <see cref="T:System.Drawing.FontFamily" /> to a human-readable string representation.</summary>
		/// <returns>The string that represents this <see cref="T:System.Drawing.FontFamily" />.</returns>
		public override string ToString()
		{
			return "[FontFamily: Name=" + Name + "]";
		}
	}
	/// <summary>Encapsulates a GDI+ drawing surface. This class cannot be inherited.</summary>
	public sealed class Graphics : MarshalByRefObject, IDisposable, IDeviceContext
	{
		/// <summary>Provides a callback method for the <see cref="Overload:System.Drawing.Graphics.EnumerateMetafile" /> method.</summary>
		/// <param name="recordType">Member of the <see cref="T:System.Drawing.Imaging.EmfPlusRecordType" /> enumeration that specifies the type of metafile record.</param>
		/// <param name="flags">Set of flags that specify attributes of the record.</param>
		/// <param name="dataSize">Number of bytes in the record data.</param>
		/// <param name="data">Pointer to a buffer that contains the record data.</param>
		/// <param name="callbackData">Not used.</param>
		/// <returns>Return <see langword="true" /> if you want to continue enumerating records; otherwise, <see langword="false" />.</returns>
		public delegate bool EnumerateMetafileProc(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr data, PlayRecordCallback callbackData);

		/// <summary>Provides a callback method for deciding when the <see cref="Overload:System.Drawing.Graphics.DrawImage" /> method should prematurely cancel execution and stop drawing an image.</summary>
		/// <param name="callbackdata">Internal pointer that specifies data for the callback method. This parameter is not passed by all <see cref="Overload:System.Drawing.Graphics.DrawImage" /> overloads. You can test for its absence by checking for the value <see cref="F:System.IntPtr.Zero" />.</param>
		/// <returns>This method returns <see langword="true" /> if it decides that the <see cref="Overload:System.Drawing.Graphics.DrawImage" /> method should prematurely stop execution. Otherwise it returns <see langword="false" /> to indicate that the <see cref="Overload:System.Drawing.Graphics.DrawImage" /> method should continue execution.</returns>
		public delegate bool DrawImageAbort(IntPtr callbackdata);

		internal IntPtr nativeObject;

		internal IMacContext maccontext;

		private bool disposed;

		private static float defDpiX;

		private static float defDpiY;

		private IntPtr deviceContextHdc;

		private const string MetafileEnumeration = "Metafiles enumeration, for both WMF and EMF formats, isn't supported.";

		internal static float systemDpiX
		{
			get
			{
				if (defDpiX == 0f)
				{
					Graphics graphics = FromImage(new Bitmap(1, 1));
					defDpiX = graphics.DpiX;
					defDpiY = graphics.DpiY;
				}
				return defDpiX;
			}
		}

		internal static float systemDpiY
		{
			get
			{
				if (defDpiY == 0f)
				{
					Graphics graphics = FromImage(new Bitmap(1, 1));
					defDpiX = graphics.DpiX;
					defDpiY = graphics.DpiY;
				}
				return defDpiY;
			}
		}

		internal IntPtr NativeGraphics => nativeObject;

		internal IntPtr NativeObject
		{
			get
			{
				return nativeObject;
			}
			set
			{
				nativeObject = value;
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Region" /> that limits the drawing region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Region" /> that limits the portion of this <see cref="T:System.Drawing.Graphics" /> that is currently available for drawing.</returns>
		public Region Clip
		{
			get
			{
				Region region = new Region();
				GDIPlus.CheckStatus(GDIPlus.GdipGetClip(nativeObject, region.NativeObject));
				return region;
			}
			set
			{
				SetClip(value, CombineMode.Replace);
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.RectangleF" /> structure that bounds the clipping region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> structure that represents a bounding rectangle for the clipping region of this <see cref="T:System.Drawing.Graphics" />.</returns>
		public RectangleF ClipBounds
		{
			get
			{
				RectangleF rect = default(RectangleF);
				GDIPlus.CheckStatus(GDIPlus.GdipGetClipBounds(nativeObject, out rect));
				return rect;
			}
		}

		/// <summary>Gets a value that specifies how composited images are drawn to this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>This property specifies a member of the <see cref="T:System.Drawing.Drawing2D.CompositingMode" /> enumeration. The default is <see cref="F:System.Drawing.Drawing2D.CompositingMode.SourceOver" />.</returns>
		public CompositingMode CompositingMode
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetCompositingMode(nativeObject, out var compositingMode));
				return compositingMode;
			}
			set
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetCompositingMode(nativeObject, value));
			}
		}

		/// <summary>Gets or sets the rendering quality of composited images drawn to this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>This property specifies a member of the <see cref="T:System.Drawing.Drawing2D.CompositingQuality" /> enumeration. The default is <see cref="F:System.Drawing.Drawing2D.CompositingQuality.Default" />.</returns>
		public CompositingQuality CompositingQuality
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetCompositingQuality(nativeObject, out var compositingQuality));
				return compositingQuality;
			}
			set
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetCompositingQuality(nativeObject, value));
			}
		}

		/// <summary>Gets the horizontal resolution of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>The value, in dots per inch, for the horizontal resolution supported by this <see cref="T:System.Drawing.Graphics" />.</returns>
		public float DpiX
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetDpiX(nativeObject, out var dpi));
				return dpi;
			}
		}

		/// <summary>Gets the vertical resolution of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>The value, in dots per inch, for the vertical resolution supported by this <see cref="T:System.Drawing.Graphics" />.</returns>
		public float DpiY
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetDpiY(nativeObject, out var dpi));
				return dpi;
			}
		}

		/// <summary>Gets or sets the interpolation mode associated with this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Drawing2D.InterpolationMode" /> values.</returns>
		public InterpolationMode InterpolationMode
		{
			get
			{
				InterpolationMode interpolationMode = InterpolationMode.Invalid;
				GDIPlus.CheckStatus(GDIPlus.GdipGetInterpolationMode(nativeObject, out interpolationMode));
				return interpolationMode;
			}
			set
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetInterpolationMode(nativeObject, value));
			}
		}

		/// <summary>Gets a value indicating whether the clipping region of this <see cref="T:System.Drawing.Graphics" /> is empty.</summary>
		/// <returns>
		///   <see langword="true" /> if the clipping region of this <see cref="T:System.Drawing.Graphics" /> is empty; otherwise, <see langword="false" />.</returns>
		public bool IsClipEmpty
		{
			get
			{
				bool result = false;
				GDIPlus.CheckStatus(GDIPlus.GdipIsClipEmpty(nativeObject, out result));
				return result;
			}
		}

		/// <summary>Gets a value indicating whether the visible clipping region of this <see cref="T:System.Drawing.Graphics" /> is empty.</summary>
		/// <returns>
		///   <see langword="true" /> if the visible portion of the clipping region of this <see cref="T:System.Drawing.Graphics" /> is empty; otherwise, <see langword="false" />.</returns>
		public bool IsVisibleClipEmpty
		{
			get
			{
				bool result = false;
				GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleClipEmpty(nativeObject, out result));
				return result;
			}
		}

		/// <summary>Gets or sets the scaling between world units and page units for this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>This property specifies a value for the scaling between world units and page units for this <see cref="T:System.Drawing.Graphics" />.</returns>
		public float PageScale
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPageScale(nativeObject, out var scale));
				return scale;
			}
			set
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetPageScale(nativeObject, value));
			}
		}

		/// <summary>Gets or sets the unit of measure used for page coordinates in this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.GraphicsUnit" /> values other than <see cref="F:System.Drawing.GraphicsUnit.World" />.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
		///   <see cref="P:System.Drawing.Graphics.PageUnit" /> is set to <see cref="F:System.Drawing.GraphicsUnit.World" />, which is not a physical unit.</exception>
		public GraphicsUnit PageUnit
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPageUnit(nativeObject, out var unit));
				return unit;
			}
			set
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetPageUnit(nativeObject, value));
			}
		}

		/// <summary>Gets or sets a value specifying how pixels are offset during rendering of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>This property specifies a member of the <see cref="T:System.Drawing.Drawing2D.PixelOffsetMode" /> enumeration</returns>
		[System.MonoTODO("This property does not do anything when used with libgdiplus.")]
		public PixelOffsetMode PixelOffsetMode
		{
			get
			{
				PixelOffsetMode pixelOffsetMode = PixelOffsetMode.Invalid;
				GDIPlus.CheckStatus(GDIPlus.GdipGetPixelOffsetMode(nativeObject, out pixelOffsetMode));
				return pixelOffsetMode;
			}
			set
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetPixelOffsetMode(nativeObject, value));
			}
		}

		/// <summary>Gets or sets the rendering origin of this <see cref="T:System.Drawing.Graphics" /> for dithering and for hatch brushes.</summary>
		/// <returns>A <see cref="T:System.Drawing.Point" /> structure that represents the dither origin for 8-bits-per-pixel and 16-bits-per-pixel dithering and is also used to set the origin for hatch brushes.</returns>
		public Point RenderingOrigin
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetRenderingOrigin(nativeObject, out var x, out var y));
				return new Point(x, y);
			}
			set
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetRenderingOrigin(nativeObject, value.X, value.Y));
			}
		}

		/// <summary>Gets or sets the rendering quality for this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Drawing2D.SmoothingMode" /> values.</returns>
		public SmoothingMode SmoothingMode
		{
			get
			{
				SmoothingMode smoothingMode = SmoothingMode.Invalid;
				GDIPlus.CheckStatus(GDIPlus.GdipGetSmoothingMode(nativeObject, out smoothingMode));
				return smoothingMode;
			}
			set
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetSmoothingMode(nativeObject, value));
			}
		}

		/// <summary>Gets or sets the gamma correction value for rendering text.</summary>
		/// <returns>The gamma correction value used for rendering antialiased and ClearType text.</returns>
		[System.MonoTODO("This property does not do anything when used with libgdiplus.")]
		public int TextContrast
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetTextContrast(nativeObject, out var contrast));
				return contrast;
			}
			set
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetTextContrast(nativeObject, value));
			}
		}

		/// <summary>Gets or sets the rendering mode for text associated with this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Text.TextRenderingHint" /> values.</returns>
		public TextRenderingHint TextRenderingHint
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetTextRenderingHint(nativeObject, out var mode));
				return mode;
			}
			set
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetTextRenderingHint(nativeObject, value));
			}
		}

		/// <summary>Gets or sets a copy of the geometric world transformation for this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>A copy of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> that represents the geometric world transformation for this <see cref="T:System.Drawing.Graphics" />.</returns>
		public Matrix Transform
		{
			get
			{
				Matrix matrix = new Matrix();
				GDIPlus.CheckStatus(GDIPlus.GdipGetWorldTransform(nativeObject, matrix.nativeMatrix));
				return matrix;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetWorldTransform(nativeObject, value.nativeMatrix));
			}
		}

		/// <summary>Gets the bounding rectangle of the visible clipping region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> structure that represents a bounding rectangle for the visible clipping region of this <see cref="T:System.Drawing.Graphics" />.</returns>
		public RectangleF VisibleClipBounds
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetVisibleClipBounds(nativeObject, out var rect));
				return rect;
			}
		}

		internal Graphics(IntPtr nativeGraphics)
		{
			nativeObject = IntPtr.Zero;
			base..ctor();
			nativeObject = nativeGraphics;
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Graphics()
		{
			Dispose();
		}

		/// <summary>Adds a comment to the current <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="data">Array of bytes that contains the comment.</param>
		[System.MonoTODO("Metafiles, both WMF and EMF formats, aren't supported.")]
		public void AddMetafileComment(byte[] data)
		{
			throw new NotImplementedException();
		}

		/// <summary>Saves a graphics container with the current state of this <see cref="T:System.Drawing.Graphics" /> and opens and uses a new graphics container.</summary>
		/// <returns>This method returns a <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> that represents the state of this <see cref="T:System.Drawing.Graphics" /> at the time of the method call.</returns>
		public GraphicsContainer BeginContainer()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipBeginContainer2(nativeObject, out var state));
			return new GraphicsContainer(state);
		}

		/// <summary>Saves a graphics container with the current state of this <see cref="T:System.Drawing.Graphics" /> and opens and uses a new graphics container with the specified scale transformation.</summary>
		/// <param name="dstrect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that, together with the <paramref name="srcrect" /> parameter, specifies a scale transformation for the container.</param>
		/// <param name="srcrect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that, together with the <paramref name="dstrect" /> parameter, specifies a scale transformation for the container.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure for the container.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> that represents the state of this <see cref="T:System.Drawing.Graphics" /> at the time of the method call.</returns>
		[System.MonoTODO("The rectangles and unit parameters aren't supported in libgdiplus")]
		public GraphicsContainer BeginContainer(Rectangle dstrect, Rectangle srcrect, GraphicsUnit unit)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipBeginContainerI(nativeObject, ref dstrect, ref srcrect, unit, out var state));
			return new GraphicsContainer(state);
		}

		/// <summary>Saves a graphics container with the current state of this <see cref="T:System.Drawing.Graphics" /> and opens and uses a new graphics container with the specified scale transformation.</summary>
		/// <param name="dstrect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that, together with the <paramref name="srcrect" /> parameter, specifies a scale transformation for the new graphics container.</param>
		/// <param name="srcrect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that, together with the <paramref name="dstrect" /> parameter, specifies a scale transformation for the new graphics container.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure for the container.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> that represents the state of this <see cref="T:System.Drawing.Graphics" /> at the time of the method call.</returns>
		[System.MonoTODO("The rectangles and unit parameters aren't supported in libgdiplus")]
		public GraphicsContainer BeginContainer(RectangleF dstrect, RectangleF srcrect, GraphicsUnit unit)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipBeginContainer(nativeObject, ref dstrect, ref srcrect, unit, out var state));
			return new GraphicsContainer(state);
		}

		/// <summary>Clears the entire drawing surface and fills it with the specified background color.</summary>
		/// <param name="color">
		///   <see cref="T:System.Drawing.Color" /> structure that represents the background color of the drawing surface.</param>
		public void Clear(Color color)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipGraphicsClear(nativeObject, color.ToArgb()));
		}

		/// <summary>Performs a bit-block transfer of color data, corresponding to a rectangle of pixels, from the screen to the drawing surface of the <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="upperLeftSource">The point at the upper-left corner of the source rectangle.</param>
		/// <param name="upperLeftDestination">The point at the upper-left corner of the destination rectangle.</param>
		/// <param name="blockRegionSize">The size of the area to be transferred.</param>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The operation failed.</exception>
		[System.MonoLimitation("Works on Win32 and on X11 (but not on Cocoa and Quartz)")]
		public void CopyFromScreen(Point upperLeftSource, Point upperLeftDestination, Size blockRegionSize)
		{
			CopyFromScreen(upperLeftSource.X, upperLeftSource.Y, upperLeftDestination.X, upperLeftDestination.Y, blockRegionSize, CopyPixelOperation.SourceCopy);
		}

		/// <summary>Performs a bit-block transfer of color data, corresponding to a rectangle of pixels, from the screen to the drawing surface of the <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="upperLeftSource">The point at the upper-left corner of the source rectangle.</param>
		/// <param name="upperLeftDestination">The point at the upper-left corner of the destination rectangle.</param>
		/// <param name="blockRegionSize">The size of the area to be transferred.</param>
		/// <param name="copyPixelOperation">One of the <see cref="T:System.Drawing.CopyPixelOperation" /> values.</param>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
		///   <paramref name="copyPixelOperation" /> is not a member of <see cref="T:System.Drawing.CopyPixelOperation" />.</exception>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The operation failed.</exception>
		[System.MonoLimitation("Works on Win32 and (for CopyPixelOperation.SourceCopy only) on X11 but not on Cocoa and Quartz")]
		public void CopyFromScreen(Point upperLeftSource, Point upperLeftDestination, Size blockRegionSize, CopyPixelOperation copyPixelOperation)
		{
			CopyFromScreen(upperLeftSource.X, upperLeftSource.Y, upperLeftDestination.X, upperLeftDestination.Y, blockRegionSize, copyPixelOperation);
		}

		/// <summary>Performs a bit-block transfer of the color data, corresponding to a rectangle of pixels, from the screen to the drawing surface of the <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="sourceX">The x-coordinate of the point at the upper-left corner of the source rectangle.</param>
		/// <param name="sourceY">The y-coordinate of the point at the upper-left corner of the source rectangle.</param>
		/// <param name="destinationX">The x-coordinate of the point at the upper-left corner of the destination rectangle.</param>
		/// <param name="destinationY">The y-coordinate of the point at the upper-left corner of the destination rectangle.</param>
		/// <param name="blockRegionSize">The size of the area to be transferred.</param>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The operation failed.</exception>
		[System.MonoLimitation("Works on Win32 and on X11 (but not on Cocoa and Quartz)")]
		public void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize)
		{
			CopyFromScreen(sourceX, sourceY, destinationX, destinationY, blockRegionSize, CopyPixelOperation.SourceCopy);
		}

		/// <summary>Performs a bit-block transfer of the color data, corresponding to a rectangle of pixels, from the screen to the drawing surface of the <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="sourceX">The x-coordinate of the point at the upper-left corner of the source rectangle.</param>
		/// <param name="sourceY">The y-coordinate of the point at the upper-left corner of the source rectangle</param>
		/// <param name="destinationX">The x-coordinate of the point at the upper-left corner of the destination rectangle.</param>
		/// <param name="destinationY">The y-coordinate of the point at the upper-left corner of the destination rectangle.</param>
		/// <param name="blockRegionSize">The size of the area to be transferred.</param>
		/// <param name="copyPixelOperation">One of the <see cref="T:System.Drawing.CopyPixelOperation" /> values.</param>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
		///   <paramref name="copyPixelOperation" /> is not a member of <see cref="T:System.Drawing.CopyPixelOperation" />.</exception>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The operation failed.</exception>
		[System.MonoLimitation("Works on Win32 and (for CopyPixelOperation.SourceCopy only) on X11 but not on Cocoa and Quartz")]
		public void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize, CopyPixelOperation copyPixelOperation)
		{
			if (!Enum.IsDefined(typeof(CopyPixelOperation), copyPixelOperation))
			{
				throw new InvalidEnumArgumentException(global::Locale.GetText("Enum argument value '{0}' is not valid for CopyPixelOperation", copyPixelOperation));
			}
			if (GDIPlus.UseX11Drawable)
			{
				CopyFromScreenX11(sourceX, sourceY, destinationX, destinationY, blockRegionSize, copyPixelOperation);
			}
			else if (GDIPlus.UseCarbonDrawable)
			{
				CopyFromScreenMac(sourceX, sourceY, destinationX, destinationY, blockRegionSize, copyPixelOperation);
			}
			else if (GDIPlus.UseCocoaDrawable)
			{
				CopyFromScreenMac(sourceX, sourceY, destinationX, destinationY, blockRegionSize, copyPixelOperation);
			}
			else
			{
				CopyFromScreenWin32(sourceX, sourceY, destinationX, destinationY, blockRegionSize, copyPixelOperation);
			}
		}

		private void CopyFromScreenWin32(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize, CopyPixelOperation copyPixelOperation)
		{
			IntPtr dC = GDIPlus.GetDC(GDIPlus.GetDesktopWindow());
			IntPtr hdc = GetHdc();
			GDIPlus.BitBlt(hdc, destinationX, destinationY, blockRegionSize.Width, blockRegionSize.Height, dC, sourceX, sourceY, (int)copyPixelOperation);
			GDIPlus.ReleaseDC(IntPtr.Zero, dC);
			ReleaseHdc(hdc);
		}

		private void CopyFromScreenMac(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize, CopyPixelOperation copyPixelOperation)
		{
			throw new NotImplementedException();
		}

		private void CopyFromScreenX11(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize, CopyPixelOperation copyPixelOperation)
		{
			int pane = -1;
			int nitems = 0;
			if (copyPixelOperation != CopyPixelOperation.SourceCopy)
			{
				throw new NotImplementedException("Operation not implemented under X11");
			}
			if (GDIPlus.Display == IntPtr.Zero)
			{
				GDIPlus.Display = GDIPlus.XOpenDisplay(IntPtr.Zero);
			}
			IntPtr drawable = GDIPlus.XRootWindow(GDIPlus.Display, 0);
			IntPtr visual = GDIPlus.XDefaultVisual(GDIPlus.Display, 0);
			XVisualInfo vinfo_template = new XVisualInfo
			{
				visualid = GDIPlus.XVisualIDFromVisual(visual)
			};
			IntPtr intPtr = GDIPlus.XGetVisualInfo(GDIPlus.Display, 1, ref vinfo_template, ref nitems);
			vinfo_template = (XVisualInfo)Marshal.PtrToStructure(intPtr, typeof(XVisualInfo));
			IntPtr intPtr2 = GDIPlus.XGetImage(GDIPlus.Display, drawable, sourceX, sourceY, blockRegionSize.Width, blockRegionSize.Height, pane, 2);
			if (intPtr2 == IntPtr.Zero)
			{
				throw new InvalidOperationException($"XGetImage returned NULL when asked to for a {blockRegionSize.Width}x{blockRegionSize.Height} region block");
			}
			Bitmap bitmap = new Bitmap(blockRegionSize.Width, blockRegionSize.Height);
			int num = (int)vinfo_template.red_mask;
			int num2 = (int)vinfo_template.blue_mask;
			int num3 = (int)vinfo_template.green_mask;
			for (int i = 0; i < blockRegionSize.Height; i++)
			{
				for (int j = 0; j < blockRegionSize.Width; j++)
				{
					int num4 = GDIPlus.XGetPixel(intPtr2, j, i);
					int red;
					int green;
					int blue;
					switch (vinfo_template.depth)
					{
					case 16u:
						red = ((num4 & num) >> 8) & 0xFF;
						green = ((num4 & num3) >> 3) & 0xFF;
						blue = ((num4 & num2) << 3) & 0xFF;
						break;
					case 24u:
					case 32u:
						red = ((num4 & num) >> 16) & 0xFF;
						green = ((num4 & num3) >> 8) & 0xFF;
						blue = num4 & num2 & 0xFF;
						break;
					default:
						throw new NotImplementedException(global::Locale.GetText("{0}bbp depth not supported.", vinfo_template.depth));
					}
					bitmap.SetPixel(j, i, Color.FromArgb(255, red, green, blue));
				}
			}
			DrawImage(bitmap, destinationX, destinationY);
			bitmap.Dispose();
			GDIPlus.XDestroyImage(intPtr2);
			GDIPlus.XFree(intPtr);
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Graphics" />.</summary>
		public void Dispose()
		{
			if (!disposed)
			{
				if (GDIPlus.UseCarbonDrawable || GDIPlus.UseCocoaDrawable)
				{
					Flush();
					if (maccontext != null)
					{
						maccontext.Release();
					}
				}
				Status status = GDIPlus.GdipDeleteGraphics(nativeObject);
				nativeObject = IntPtr.Zero;
				GDIPlus.CheckStatus(status);
				disposed = true;
			}
			GC.SuppressFinalize(this);
		}

		/// <summary>Draws an arc representing a portion of an ellipse specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the arc.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that defines the boundaries of the ellipse.</param>
		/// <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the starting point of the arc.</param>
		/// <param name="sweepAngle">Angle in degrees measured clockwise from the <paramref name="startAngle" /> parameter to ending point of the arc.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawArc(Pen pen, Rectangle rect, float startAngle, float sweepAngle)
		{
			DrawArc(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		/// <summary>Draws an arc representing a portion of an ellipse specified by a <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the arc.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that defines the boundaries of the ellipse.</param>
		/// <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the starting point of the arc.</param>
		/// <param name="sweepAngle">Angle in degrees measured clockwise from the <paramref name="startAngle" /> parameter to ending point of the arc.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" /></exception>
		public void DrawArc(Pen pen, RectangleF rect, float startAngle, float sweepAngle)
		{
			DrawArc(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		/// <summary>Draws an arc representing a portion of an ellipse specified by a pair of coordinates, a width, and a height.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the arc.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle that defines the ellipse.</param>
		/// <param name="width">Width of the rectangle that defines the ellipse.</param>
		/// <param name="height">Height of the rectangle that defines the ellipse.</param>
		/// <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the starting point of the arc.</param>
		/// <param name="sweepAngle">Angle in degrees measured clockwise from the <paramref name="startAngle" /> parameter to ending point of the arc.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawArc(Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawArc(nativeObject, pen.NativePen, x, y, width, height, startAngle, sweepAngle));
		}

		/// <summary>Draws an arc representing a portion of an ellipse specified by a pair of coordinates, a width, and a height.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the arc.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle that defines the ellipse.</param>
		/// <param name="width">Width of the rectangle that defines the ellipse.</param>
		/// <param name="height">Height of the rectangle that defines the ellipse.</param>
		/// <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the starting point of the arc.</param>
		/// <param name="sweepAngle">Angle in degrees measured clockwise from the <paramref name="startAngle" /> parameter to ending point of the arc.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawArc(Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawArcI(nativeObject, pen.NativePen, x, y, width, height, startAngle, sweepAngle));
		}

		/// <summary>Draws a Bzier spline defined by four <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="pt1">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the starting point of the curve.</param>
		/// <param name="pt2">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the first control point for the curve.</param>
		/// <param name="pt3">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the second control point for the curve.</param>
		/// <param name="pt4">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the ending point of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawBezier(Pen pen, PointF pt1, PointF pt2, PointF pt3, PointF pt4)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawBezier(nativeObject, pen.NativePen, pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y));
		}

		/// <summary>Draws a Bzier spline defined by four <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> structure that determines the color, width, and style of the curve.</param>
		/// <param name="pt1">
		///   <see cref="T:System.Drawing.Point" /> structure that represents the starting point of the curve.</param>
		/// <param name="pt2">
		///   <see cref="T:System.Drawing.Point" /> structure that represents the first control point for the curve.</param>
		/// <param name="pt3">
		///   <see cref="T:System.Drawing.Point" /> structure that represents the second control point for the curve.</param>
		/// <param name="pt4">
		///   <see cref="T:System.Drawing.Point" /> structure that represents the ending point of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawBezier(Pen pen, Point pt1, Point pt2, Point pt3, Point pt4)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawBezierI(nativeObject, pen.NativePen, pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y));
		}

		/// <summary>Draws a Bzier spline defined by four ordered pairs of coordinates that represent points.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="x1">The x-coordinate of the starting point of the curve.</param>
		/// <param name="y1">The y-coordinate of the starting point of the curve.</param>
		/// <param name="x2">The x-coordinate of the first control point of the curve.</param>
		/// <param name="y2">The y-coordinate of the first control point of the curve.</param>
		/// <param name="x3">The x-coordinate of the second control point of the curve.</param>
		/// <param name="y3">The y-coordinate of the second control point of the curve.</param>
		/// <param name="x4">The x-coordinate of the ending point of the curve.</param>
		/// <param name="y4">The y-coordinate of the ending point of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawBezier(Pen pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawBezier(nativeObject, pen.NativePen, x1, y1, x2, y2, x3, y3, x4, y4));
		}

		/// <summary>Draws a series of Bzier splines from an array of <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that represent the points that determine the curve. The number of points in the array should be a multiple of 3 plus 1, such as 4, 7, or 10.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawBeziers(Pen pen, Point[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			int num = points.Length;
			if (num >= 4)
			{
				for (int i = 0; i < num - 1; i += 3)
				{
					Point point = points[i];
					Point point2 = points[i + 1];
					Point point3 = points[i + 2];
					Point point4 = points[i + 3];
					GDIPlus.CheckStatus(GDIPlus.GdipDrawBezier(nativeObject, pen.NativePen, point.X, point.Y, point2.X, point2.Y, point3.X, point3.Y, point4.X, point4.Y));
				}
			}
		}

		/// <summary>Draws a series of Bzier splines from an array of <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that represent the points that determine the curve. The number of points in the array should be a multiple of 3 plus 1, such as 4, 7, or 10.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawBeziers(Pen pen, PointF[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			int num = points.Length;
			if (num >= 4)
			{
				for (int i = 0; i < num - 1; i += 3)
				{
					PointF pointF = points[i];
					PointF pointF2 = points[i + 1];
					PointF pointF3 = points[i + 2];
					PointF pointF4 = points[i + 3];
					GDIPlus.CheckStatus(GDIPlus.GdipDrawBezier(nativeObject, pen.NativePen, pointF.X, pointF.Y, pointF2.X, pointF2.Y, pointF3.X, pointF3.Y, pointF4.X, pointF4.Y));
				}
			}
		}

		/// <summary>Draws a closed cardinal spline defined by an array of <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and height of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawClosedCurve(Pen pen, PointF[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawClosedCurve(nativeObject, pen.NativePen, points, points.Length));
		}

		/// <summary>Draws a closed cardinal spline defined by an array of <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and height of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawClosedCurve(Pen pen, Point[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawClosedCurveI(nativeObject, pen.NativePen, points, points.Length));
		}

		/// <summary>Draws a closed cardinal spline defined by an array of <see cref="T:System.Drawing.Point" /> structures using a specified tension.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and height of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <param name="fillmode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the curve is filled. This parameter is required but ignored.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawClosedCurve(Pen pen, Point[] points, float tension, FillMode fillmode)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawClosedCurve2I(nativeObject, pen.NativePen, points, points.Length, tension));
		}

		/// <summary>Draws a closed cardinal spline defined by an array of <see cref="T:System.Drawing.PointF" /> structures using a specified tension.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and height of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <param name="fillmode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the curve is filled. This parameter is required but is ignored.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawClosedCurve(Pen pen, PointF[] points, float tension, FillMode fillmode)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawClosedCurve2(nativeObject, pen.NativePen, points, points.Length, tension));
		}

		/// <summary>Draws a cardinal spline through a specified array of <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and height of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawCurve(Pen pen, Point[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawCurveI(nativeObject, pen.NativePen, points, points.Length));
		}

		/// <summary>Draws a cardinal spline through a specified array of <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawCurve(Pen pen, PointF[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawCurve(nativeObject, pen.NativePen, points, points.Length));
		}

		/// <summary>Draws a cardinal spline through a specified array of <see cref="T:System.Drawing.PointF" /> structures using a specified tension.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that represent the points that define the curve.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawCurve(Pen pen, PointF[] points, float tension)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawCurve2(nativeObject, pen.NativePen, points, points.Length, tension));
		}

		/// <summary>Draws a cardinal spline through a specified array of <see cref="T:System.Drawing.Point" /> structures using a specified tension.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawCurve(Pen pen, Point[] points, float tension)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawCurve2I(nativeObject, pen.NativePen, points, points.Length, tension));
		}

		/// <summary>Draws a cardinal spline through a specified array of <see cref="T:System.Drawing.PointF" /> structures. The drawing begins offset from the beginning of the array.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <param name="offset">Offset from the first element in the array of the <paramref name="points" /> parameter to the starting point in the curve.</param>
		/// <param name="numberOfSegments">Number of segments after the starting point to include in the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawCurve(Pen pen, PointF[] points, int offset, int numberOfSegments)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawCurve3(nativeObject, pen.NativePen, points, points.Length, offset, numberOfSegments, 0.5f));
		}

		/// <summary>Draws a cardinal spline through a specified array of <see cref="T:System.Drawing.Point" /> structures using a specified tension.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <param name="offset">Offset from the first element in the array of the <paramref name="points" /> parameter to the starting point in the curve.</param>
		/// <param name="numberOfSegments">Number of segments after the starting point to include in the curve.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawCurve(Pen pen, Point[] points, int offset, int numberOfSegments, float tension)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawCurve3I(nativeObject, pen.NativePen, points, points.Length, offset, numberOfSegments, tension));
		}

		/// <summary>Draws a cardinal spline through a specified array of <see cref="T:System.Drawing.PointF" /> structures using a specified tension. The drawing begins offset from the beginning of the array.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <param name="offset">Offset from the first element in the array of the <paramref name="points" /> parameter to the starting point in the curve.</param>
		/// <param name="numberOfSegments">Number of segments after the starting point to include in the curve.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawCurve(Pen pen, PointF[] points, int offset, int numberOfSegments, float tension)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawCurve3(nativeObject, pen.NativePen, points, points.Length, offset, numberOfSegments, tension));
		}

		/// <summary>Draws an ellipse specified by a bounding <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the ellipse.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that defines the boundaries of the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawEllipse(Pen pen, Rectangle rect)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			DrawEllipse(pen, rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Draws an ellipse defined by a bounding <see cref="T:System.Drawing.RectangleF" />.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the ellipse.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that defines the boundaries of the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawEllipse(Pen pen, RectangleF rect)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			DrawEllipse(pen, rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Draws an ellipse defined by a bounding rectangle specified by coordinates for the upper-left corner of the rectangle, a height, and a width.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the ellipse.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawEllipse(Pen pen, int x, int y, int width, int height)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawEllipseI(nativeObject, pen.NativePen, x, y, width, height));
		}

		/// <summary>Draws an ellipse defined by a bounding rectangle specified by a pair of coordinates, a height, and a width.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the ellipse.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawEllipse(Pen pen, float x, float y, float width, float height)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawEllipse(nativeObject, pen.NativePen, x, y, width, height));
		}

		/// <summary>Draws the image represented by the specified <see cref="T:System.Drawing.Icon" /> within the area specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="icon">
		///   <see cref="T:System.Drawing.Icon" /> to draw.</param>
		/// <param name="targetRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the resulting image on the display surface. The image contained in the <paramref name="icon" /> parameter is scaled to the dimensions of this rectangular area.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="icon" /> is <see langword="null" />.</exception>
		public void DrawIcon(Icon icon, Rectangle targetRect)
		{
			if (icon == null)
			{
				throw new ArgumentNullException("icon");
			}
			DrawImage(icon.GetInternalBitmap(), targetRect);
		}

		/// <summary>Draws the image represented by the specified <see cref="T:System.Drawing.Icon" /> at the specified coordinates.</summary>
		/// <param name="icon">
		///   <see cref="T:System.Drawing.Icon" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="icon" /> is <see langword="null" />.</exception>
		public void DrawIcon(Icon icon, int x, int y)
		{
			if (icon == null)
			{
				throw new ArgumentNullException("icon");
			}
			DrawImage(icon.GetInternalBitmap(), x, y);
		}

		/// <summary>Draws the image represented by the specified <see cref="T:System.Drawing.Icon" /> without scaling the image.</summary>
		/// <param name="icon">
		///   <see cref="T:System.Drawing.Icon" /> to draw.</param>
		/// <param name="targetRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the resulting image. The image is not scaled to fit this rectangle, but retains its original size. If the image is larger than the rectangle, it is clipped to fit inside it.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="icon" /> is <see langword="null" />.</exception>
		public void DrawIconUnstretched(Icon icon, Rectangle targetRect)
		{
			if (icon == null)
			{
				throw new ArgumentNullException("icon");
			}
			DrawImageUnscaled(icon.GetInternalBitmap(), targetRect);
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, RectangleF rect)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImageRect(nativeObject, image.NativeObject, rect.X, rect.Y, rect.Width, rect.Height));
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" />, using its original physical size, at the specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="point">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the upper-left corner of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, PointF point)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImage(nativeObject, image.NativeObject, point.X, point.Y));
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified shape and size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Point[] destPoints)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImagePointsI(nativeObject, image.NativeObject, destPoints, destPoints.Length));
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" />, using its original physical size, at the specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="point">
		///   <see cref="T:System.Drawing.Point" /> structure that represents the location of the upper-left corner of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Point point)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			DrawImage(image, point.X, point.Y);
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle rect)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			DrawImage(image, rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified shape and size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, PointF[] destPoints)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImagePoints(nativeObject, image.NativeObject, destPoints, destPoints.Length));
		}

		/// <summary>Draws the specified image, using its original physical size, at the location specified by a coordinate pair.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, int x, int y)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImageI(nativeObject, image.NativeObject, x, y));
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" />, using its original physical size, at the specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, float x, float y)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImage(nativeObject, image.NativeObject, x, y));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImageRectRectI(nativeObject, image.NativeObject, destRect.X, destRect.Y, destRect.Width, destRect.Height, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit, IntPtr.Zero, null, IntPtr.Zero));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImageRectRect(nativeObject, image.NativeObject, destRect.X, destRect.Y, destRect.Width, destRect.Height, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit, IntPtr.Zero, null, IntPtr.Zero));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImagePointsRectI(nativeObject, image.NativeObject, destPoints, destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit, IntPtr.Zero, null, IntPtr.Zero));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImagePointsRect(nativeObject, image.NativeObject, destPoints, destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit, IntPtr.Zero, null, IntPtr.Zero));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImagePointsRectI(nativeObject, image.NativeObject, destPoints, destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit, imageAttr?.nativeImageAttributes ?? IntPtr.Zero, null, IntPtr.Zero));
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="width">Width of the drawn image.</param>
		/// <param name="height">Height of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, float x, float y, float width, float height)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImageRect(nativeObject, image.NativeObject, x, y, width, height));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImagePointsRect(nativeObject, image.NativeObject, destPoints, destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit, imageAttr?.nativeImageAttributes ?? IntPtr.Zero, null, IntPtr.Zero));
		}

		/// <summary>Draws a portion of an image at a specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, int x, int y, Rectangle srcRect, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImagePointRectI(nativeObject, image.NativeObject, x, y, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit));
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="width">Width of the drawn image.</param>
		/// <param name="height">Height of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, int x, int y, int width, int height)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImageRectI(nativeObject, image.nativeObject, x, y, width, height));
		}

		/// <summary>Draws a portion of an image at a specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, float x, float y, RectangleF srcRect, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImagePointRect(nativeObject, image.nativeObject, x, y, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> method according to application-determined criteria.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImagePointsRect(nativeObject, image.NativeObject, destPoints, destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit, imageAttr?.nativeImageAttributes ?? IntPtr.Zero, callback, IntPtr.Zero));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> method according to application-determined criteria.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImagePointsRectI(nativeObject, image.NativeObject, destPoints, destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit, imageAttr?.nativeImageAttributes ?? IntPtr.Zero, callback, IntPtr.Zero));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> method according to application-determined criteria.</param>
		/// <param name="callbackData">Value specifying additional data for the <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate to use when checking whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> method.</param>
		public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback, int callbackData)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImagePointsRectI(nativeObject, image.NativeObject, destPoints, destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit, imageAttr?.nativeImageAttributes ?? IntPtr.Zero, callback, (IntPtr)callbackData));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImageRectRect(nativeObject, image.NativeObject, destRect.X, destRect.Y, destRect.Width, destRect.Height, srcX, srcY, srcWidth, srcHeight, srcUnit, IntPtr.Zero, null, IntPtr.Zero));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> method according to application-determined criteria.</param>
		/// <param name="callbackData">Value specifying additional data for the <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate to use when checking whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> method.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback, int callbackData)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImagePointsRect(nativeObject, image.NativeObject, destPoints, destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit, imageAttr?.nativeImageAttributes ?? IntPtr.Zero, callback, (IntPtr)callbackData));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImageRectRectI(nativeObject, image.NativeObject, destRect.X, destRect.Y, destRect.Width, destRect.Height, srcX, srcY, srcWidth, srcHeight, srcUnit, IntPtr.Zero, null, IntPtr.Zero));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <param name="imageAttrs">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImageRectRect(nativeObject, image.NativeObject, destRect.X, destRect.Y, destRect.Width, destRect.Height, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs?.nativeImageAttributes ?? IntPtr.Zero, null, IntPtr.Zero));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttr)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImageRectRectI(nativeObject, image.NativeObject, destRect.X, destRect.Y, destRect.Width, destRect.Height, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr?.nativeImageAttributes ?? IntPtr.Zero, null, IntPtr.Zero));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for <paramref name="image" />.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> method according to application-determined criteria.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImageRectRectI(nativeObject, image.NativeObject, destRect.X, destRect.Y, destRect.Width, destRect.Height, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr?.nativeImageAttributes ?? IntPtr.Zero, callback, IntPtr.Zero));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <param name="imageAttrs">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> method according to application-determined criteria.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, DrawImageAbort callback)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImageRectRect(nativeObject, image.NativeObject, destRect.X, destRect.Y, destRect.Width, destRect.Height, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs?.nativeImageAttributes ?? IntPtr.Zero, callback, IntPtr.Zero));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <param name="imageAttrs">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" /> method according to application-determined criteria.</param>
		/// <param name="callbackData">Value specifying additional data for the <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate to use when checking whether to stop execution of the <see langword="DrawImage" /> method.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, DrawImageAbort callback, IntPtr callbackData)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImageRectRect(nativeObject, image.NativeObject, destRect.X, destRect.Y, destRect.Width, destRect.Height, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs?.nativeImageAttributes ?? IntPtr.Zero, callback, callbackData));
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <param name="imageAttrs">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" /> method according to application-determined criteria.</param>
		/// <param name="callbackData">Value specifying additional data for the <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate to use when checking whether to stop execution of the <see langword="DrawImage" /> method.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, DrawImageAbort callback, IntPtr callbackData)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImageRectRect(nativeObject, image.NativeObject, destRect.X, destRect.Y, destRect.Width, destRect.Height, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs?.nativeImageAttributes ?? IntPtr.Zero, callback, callbackData));
		}

		/// <summary>Draws a specified image using its original physical size at a specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="point">
		///   <see cref="T:System.Drawing.Point" /> structure that specifies the upper-left corner of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImageUnscaled(Image image, Point point)
		{
			DrawImageUnscaled(image, point.X, point.Y);
		}

		/// <summary>Draws a specified image using its original physical size at a specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> that specifies the upper-left corner of the drawn image. The X and Y properties of the rectangle specify the upper-left corner. The Width and Height properties are ignored.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImageUnscaled(Image image, Rectangle rect)
		{
			DrawImageUnscaled(image, rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Draws the specified image using its original physical size at the location specified by a coordinate pair.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImageUnscaled(Image image, int x, int y)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			DrawImage(image, x, y, image.Width, image.Height);
		}

		/// <summary>Draws a specified image using its original physical size at a specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="width">Not used.</param>
		/// <param name="height">Not used.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImageUnscaled(Image image, int x, int y, int width, int height)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (width <= 0 || height <= 0)
			{
				return;
			}
			using Image image2 = new Bitmap(width, height);
			using Graphics graphics = FromImage(image2);
			graphics.DrawImage(image, 0, 0, image.Width, image.Height);
			DrawImage(image2, x, y, width, height);
		}

		/// <summary>Draws the specified image without scaling and clips it, if necessary, to fit in the specified rectangle.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> in which to draw the image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImageUnscaledAndClipped(Image image, Rectangle rect)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int width = ((image.Width > rect.Width) ? rect.Width : image.Width);
			int height = ((image.Height > rect.Height) ? rect.Height : image.Height);
			DrawImageUnscaled(image, rect.X, rect.Y, width, height);
		}

		/// <summary>Draws a line connecting two <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the line.</param>
		/// <param name="pt1">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the first point to connect.</param>
		/// <param name="pt2">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the second point to connect.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawLine(Pen pen, PointF pt1, PointF pt2)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawLine(nativeObject, pen.NativePen, pt1.X, pt1.Y, pt2.X, pt2.Y));
		}

		/// <summary>Draws a line connecting two <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the line.</param>
		/// <param name="pt1">
		///   <see cref="T:System.Drawing.Point" /> structure that represents the first point to connect.</param>
		/// <param name="pt2">
		///   <see cref="T:System.Drawing.Point" /> structure that represents the second point to connect.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawLine(Pen pen, Point pt1, Point pt2)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawLineI(nativeObject, pen.NativePen, pt1.X, pt1.Y, pt2.X, pt2.Y));
		}

		/// <summary>Draws a line connecting the two points specified by the coordinate pairs.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the line.</param>
		/// <param name="x1">The x-coordinate of the first point.</param>
		/// <param name="y1">The y-coordinate of the first point.</param>
		/// <param name="x2">The x-coordinate of the second point.</param>
		/// <param name="y2">The y-coordinate of the second point.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawLine(Pen pen, int x1, int y1, int x2, int y2)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawLineI(nativeObject, pen.NativePen, x1, y1, x2, y2));
		}

		/// <summary>Draws a line connecting the two points specified by the coordinate pairs.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the line.</param>
		/// <param name="x1">The x-coordinate of the first point.</param>
		/// <param name="y1">The y-coordinate of the first point.</param>
		/// <param name="x2">The x-coordinate of the second point.</param>
		/// <param name="y2">The y-coordinate of the second point.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawLine(Pen pen, float x1, float y1, float x2, float y2)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (!float.IsNaN(x1) && !float.IsNaN(y1) && !float.IsNaN(x2) && !float.IsNaN(y2))
			{
				GDIPlus.CheckStatus(GDIPlus.GdipDrawLine(nativeObject, pen.NativePen, x1, y1, x2, y2));
			}
		}

		/// <summary>Draws a series of line segments that connect an array of <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the line segments.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that represent the points to connect.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawLines(Pen pen, PointF[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawLines(nativeObject, pen.NativePen, points, points.Length));
		}

		/// <summary>Draws a series of line segments that connect an array of <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the line segments.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that represent the points to connect.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawLines(Pen pen, Point[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawLinesI(nativeObject, pen.NativePen, points, points.Length));
		}

		/// <summary>Draws a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the path.</param>
		/// <param name="path">
		///   <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to draw.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="path" /> is <see langword="null" />.</exception>
		public void DrawPath(Pen pen, GraphicsPath path)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawPath(nativeObject, pen.NativePen, path.nativePath));
		}

		/// <summary>Draws a pie shape defined by an ellipse specified by a <see cref="T:System.Drawing.Rectangle" /> structure and two radial lines.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the pie shape.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that represents the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="startAngle">Angle measured in degrees clockwise from the x-axis to the first side of the pie shape.</param>
		/// <param name="sweepAngle">Angle measured in degrees clockwise from the <paramref name="startAngle" /> parameter to the second side of the pie shape.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawPie(Pen pen, Rectangle rect, float startAngle, float sweepAngle)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			DrawPie(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		/// <summary>Draws a pie shape defined by an ellipse specified by a <see cref="T:System.Drawing.RectangleF" /> structure and two radial lines.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the pie shape.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that represents the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="startAngle">Angle measured in degrees clockwise from the x-axis to the first side of the pie shape.</param>
		/// <param name="sweepAngle">Angle measured in degrees clockwise from the <paramref name="startAngle" /> parameter to the second side of the pie shape.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawPie(Pen pen, RectangleF rect, float startAngle, float sweepAngle)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			DrawPie(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		/// <summary>Draws a pie shape defined by an ellipse specified by a coordinate pair, a width, a height, and two radial lines.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the pie shape.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="startAngle">Angle measured in degrees clockwise from the x-axis to the first side of the pie shape.</param>
		/// <param name="sweepAngle">Angle measured in degrees clockwise from the <paramref name="startAngle" /> parameter to the second side of the pie shape.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawPie(Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawPie(nativeObject, pen.NativePen, x, y, width, height, startAngle, sweepAngle));
		}

		/// <summary>Draws a pie shape defined by an ellipse specified by a coordinate pair, a width, a height, and two radial lines.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the pie shape.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="startAngle">Angle measured in degrees clockwise from the x-axis to the first side of the pie shape.</param>
		/// <param name="sweepAngle">Angle measured in degrees clockwise from the <paramref name="startAngle" /> parameter to the second side of the pie shape.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawPie(Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawPieI(nativeObject, pen.NativePen, x, y, width, height, startAngle, sweepAngle));
		}

		/// <summary>Draws a polygon defined by an array of <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the polygon.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that represent the vertices of the polygon.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawPolygon(Pen pen, Point[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawPolygonI(nativeObject, pen.NativePen, points, points.Length));
		}

		/// <summary>Draws a polygon defined by an array of <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the polygon.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that represent the vertices of the polygon.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawPolygon(Pen pen, PointF[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawPolygon(nativeObject, pen.NativePen, points, points.Length));
		}

		/// <summary>Draws a rectangle specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="pen">A <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the rectangle.</param>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle to draw.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawRectangle(Pen pen, Rectangle rect)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			DrawRectangle(pen, rect.Left, rect.Top, rect.Width, rect.Height);
		}

		/// <summary>Draws a rectangle specified by a coordinate pair, a width, and a height.</summary>
		/// <param name="pen">A <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the rectangle.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to draw.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to draw.</param>
		/// <param name="width">The width of the rectangle to draw.</param>
		/// <param name="height">The height of the rectangle to draw.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawRectangle(Pen pen, float x, float y, float width, float height)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawRectangle(nativeObject, pen.NativePen, x, y, width, height));
		}

		/// <summary>Draws a rectangle specified by a coordinate pair, a width, and a height.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the rectangle.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to draw.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to draw.</param>
		/// <param name="width">Width of the rectangle to draw.</param>
		/// <param name="height">Height of the rectangle to draw.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawRectangle(Pen pen, int x, int y, int width, int height)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawRectangleI(nativeObject, pen.NativePen, x, y, width, height));
		}

		/// <summary>Draws a series of rectangles specified by <see cref="T:System.Drawing.RectangleF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the outlines of the rectangles.</param>
		/// <param name="rects">Array of <see cref="T:System.Drawing.RectangleF" /> structures that represent the rectangles to draw.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="rects" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="rects" /> is a zero-length array.</exception>
		public void DrawRectangles(Pen pen, RectangleF[] rects)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("image");
			}
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawRectangles(nativeObject, pen.NativePen, rects, rects.Length));
		}

		/// <summary>Draws a series of rectangles specified by <see cref="T:System.Drawing.Rectangle" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the outlines of the rectangles.</param>
		/// <param name="rects">Array of <see cref="T:System.Drawing.Rectangle" /> structures that represent the rectangles to draw.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="rects" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="rects" /> is a zero-length array.</exception>
		public void DrawRectangles(Pen pen, Rectangle[] rects)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("image");
			}
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipDrawRectanglesI(nativeObject, pen.NativePen, rects, rects.Length));
		}

		/// <summary>Draws the specified text string in the specified rectangle with the specified <see cref="T:System.Drawing.Brush" /> and <see cref="T:System.Drawing.Font" /> objects.</summary>
		/// <param name="s">String to draw.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the color and texture of the drawn text.</param>
		/// <param name="layoutRectangle">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location of the drawn text.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="s" /> is <see langword="null" />.</exception>
		public void DrawString(string s, Font font, Brush brush, RectangleF layoutRectangle)
		{
			DrawString(s, font, brush, layoutRectangle, null);
		}

		/// <summary>Draws the specified text string at the specified location with the specified <see cref="T:System.Drawing.Brush" /> and <see cref="T:System.Drawing.Font" /> objects.</summary>
		/// <param name="s">String to draw.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the color and texture of the drawn text.</param>
		/// <param name="point">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the upper-left corner of the drawn text.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="s" /> is <see langword="null" />.</exception>
		public void DrawString(string s, Font font, Brush brush, PointF point)
		{
			DrawString(s, font, brush, new RectangleF(point.X, point.Y, 0f, 0f), null);
		}

		/// <summary>Draws the specified text string at the specified location with the specified <see cref="T:System.Drawing.Brush" /> and <see cref="T:System.Drawing.Font" /> objects using the formatting attributes of the specified <see cref="T:System.Drawing.StringFormat" />.</summary>
		/// <param name="s">String to draw.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the color and texture of the drawn text.</param>
		/// <param name="point">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the upper-left corner of the drawn text.</param>
		/// <param name="format">
		///   <see cref="T:System.Drawing.StringFormat" /> that specifies formatting attributes, such as line spacing and alignment, that are applied to the drawn text.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="s" /> is <see langword="null" />.</exception>
		public void DrawString(string s, Font font, Brush brush, PointF point, StringFormat format)
		{
			DrawString(s, font, brush, new RectangleF(point.X, point.Y, 0f, 0f), format);
		}

		/// <summary>Draws the specified text string at the specified location with the specified <see cref="T:System.Drawing.Brush" /> and <see cref="T:System.Drawing.Font" /> objects.</summary>
		/// <param name="s">String to draw.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the color and texture of the drawn text.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn text.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn text.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="s" /> is <see langword="null" />.</exception>
		public void DrawString(string s, Font font, Brush brush, float x, float y)
		{
			DrawString(s, font, brush, new RectangleF(x, y, 0f, 0f), null);
		}

		/// <summary>Draws the specified text string at the specified location with the specified <see cref="T:System.Drawing.Brush" /> and <see cref="T:System.Drawing.Font" /> objects using the formatting attributes of the specified <see cref="T:System.Drawing.StringFormat" />.</summary>
		/// <param name="s">String to draw.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the color and texture of the drawn text.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn text.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn text.</param>
		/// <param name="format">
		///   <see cref="T:System.Drawing.StringFormat" /> that specifies formatting attributes, such as line spacing and alignment, that are applied to the drawn text.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="s" /> is <see langword="null" />.</exception>
		public void DrawString(string s, Font font, Brush brush, float x, float y, StringFormat format)
		{
			DrawString(s, font, brush, new RectangleF(x, y, 0f, 0f), format);
		}

		/// <summary>Draws the specified text string in the specified rectangle with the specified <see cref="T:System.Drawing.Brush" /> and <see cref="T:System.Drawing.Font" /> objects using the formatting attributes of the specified <see cref="T:System.Drawing.StringFormat" />.</summary>
		/// <param name="s">String to draw.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the color and texture of the drawn text.</param>
		/// <param name="layoutRectangle">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location of the drawn text.</param>
		/// <param name="format">
		///   <see cref="T:System.Drawing.StringFormat" /> that specifies formatting attributes, such as line spacing and alignment, that are applied to the drawn text.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="s" /> is <see langword="null" />.</exception>
		public void DrawString(string s, Font font, Brush brush, RectangleF layoutRectangle, StringFormat format)
		{
			if (font == null)
			{
				throw new ArgumentNullException("font");
			}
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (s != null && s.Length != 0)
			{
				GDIPlus.CheckStatus(GDIPlus.GdipDrawString(nativeObject, s, s.Length, font.NativeObject, ref layoutRectangle, format?.NativeObject ?? IntPtr.Zero, brush.NativeBrush));
			}
		}

		/// <summary>Closes the current graphics container and restores the state of this <see cref="T:System.Drawing.Graphics" /> to the state saved by a call to the <see cref="M:System.Drawing.Graphics.BeginContainer" /> method.</summary>
		/// <param name="container">
		///   <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> that represents the container this method restores.</param>
		public void EndContainer(GraphicsContainer container)
		{
			if (container == null)
			{
				throw new ArgumentNullException("container");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipEndContainer(nativeObject, container.NativeObject));
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, EnumerateMetafileProc callback)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records of the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, EnumerateMetafileProc callback)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, EnumerateMetafileProc callback)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records of the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, EnumerateMetafileProc callback)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.Point" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Point destPoint, EnumerateMetafileProc callback)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, PointF destPoint, EnumerateMetafileProc callback)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, PointF destPoint, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records of the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.Point" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Point destPoint, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records of the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.Point" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structures that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records of a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records of a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records of the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.Point" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Point destPoint, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, PointF destPoint, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records of the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records of a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records of a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.Point" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records of a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.Point" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records of a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		[System.MonoTODO("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
		public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			throw new NotImplementedException();
		}

		/// <summary>Updates the clip region of this <see cref="T:System.Drawing.Graphics" /> to exclude the area specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the rectangle to exclude from the clip region.</param>
		public void ExcludeClip(Rectangle rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipSetClipRectI(nativeObject, rect.X, rect.Y, rect.Width, rect.Height, CombineMode.Exclude));
		}

		/// <summary>Updates the clip region of this <see cref="T:System.Drawing.Graphics" /> to exclude the area specified by a <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">
		///   <see cref="T:System.Drawing.Region" /> that specifies the region to exclude from the clip region.</param>
		public void ExcludeClip(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipSetClipRegion(nativeObject, region.NativeObject, CombineMode.Exclude));
		}

		/// <summary>Fills the interior of a closed cardinal spline curve defined by an array of <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillClosedCurve(Brush brush, PointF[] points)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillClosedCurve(nativeObject, brush.NativeBrush, points, points.Length));
		}

		/// <summary>Fills the interior of a closed cardinal spline curve defined by an array of <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillClosedCurve(Brush brush, Point[] points)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillClosedCurveI(nativeObject, brush.NativeBrush, points, points.Length));
		}

		/// <summary>Fills the interior of a closed cardinal spline curve defined by an array of <see cref="T:System.Drawing.PointF" /> structures using the specified fill mode.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <param name="fillmode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the curve is filled.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillClosedCurve(Brush brush, PointF[] points, FillMode fillmode)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			FillClosedCurve(brush, points, fillmode, 0.5f);
		}

		/// <summary>Fills the interior of a closed cardinal spline curve defined by an array of <see cref="T:System.Drawing.Point" /> structures using the specified fill mode.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <param name="fillmode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the curve is filled.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillClosedCurve(Brush brush, Point[] points, FillMode fillmode)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			FillClosedCurve(brush, points, fillmode, 0.5f);
		}

		/// <summary>Fills the interior of a closed cardinal spline curve defined by an array of <see cref="T:System.Drawing.PointF" /> structures using the specified fill mode and tension.</summary>
		/// <param name="brush">A <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <param name="fillmode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the curve is filled.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillClosedCurve(Brush brush, PointF[] points, FillMode fillmode, float tension)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillClosedCurve2(nativeObject, brush.NativeBrush, points, points.Length, tension, fillmode));
		}

		/// <summary>Fills the interior of a closed cardinal spline curve defined by an array of <see cref="T:System.Drawing.Point" /> structures using the specified fill mode and tension.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <param name="fillmode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the curve is filled.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillClosedCurve(Brush brush, Point[] points, FillMode fillmode, float tension)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillClosedCurve2I(nativeObject, brush.NativeBrush, points, points.Length, tension, fillmode));
		}

		/// <summary>Fills the interior of an ellipse defined by a bounding rectangle specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that represents the bounding rectangle that defines the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillEllipse(Brush brush, Rectangle rect)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Fills the interior of an ellipse defined by a bounding rectangle specified by a <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that represents the bounding rectangle that defines the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillEllipse(Brush brush, RectangleF rect)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Fills the interior of an ellipse defined by a bounding rectangle specified by a pair of coordinates, a width, and a height.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillEllipse(Brush brush, float x, float y, float width, float height)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillEllipse(nativeObject, brush.NativeBrush, x, y, width, height));
		}

		/// <summary>Fills the interior of an ellipse defined by a bounding rectangle specified by a pair of coordinates, a width, and a height.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillEllipse(Brush brush, int x, int y, int width, int height)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillEllipseI(nativeObject, brush.NativeBrush, x, y, width, height));
		}

		/// <summary>Fills the interior of a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="path">
		///   <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> that represents the path to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="path" /> is <see langword="null" />.</exception>
		public void FillPath(Brush brush, GraphicsPath path)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillPath(nativeObject, brush.NativeBrush, path.nativePath));
		}

		/// <summary>Fills the interior of a pie section defined by an ellipse specified by a <see cref="T:System.Drawing.RectangleF" /> structure and two radial lines.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that represents the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the first side of the pie section.</param>
		/// <param name="sweepAngle">Angle in degrees measured clockwise from the <paramref name="startAngle" /> parameter to the second side of the pie section.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillPie(Brush brush, Rectangle rect, float startAngle, float sweepAngle)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillPie(nativeObject, brush.NativeBrush, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle));
		}

		/// <summary>Fills the interior of a pie section defined by an ellipse specified by a pair of coordinates, a width, a height, and two radial lines.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the first side of the pie section.</param>
		/// <param name="sweepAngle">Angle in degrees measured clockwise from the <paramref name="startAngle" /> parameter to the second side of the pie section.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillPie(Brush brush, int x, int y, int width, int height, int startAngle, int sweepAngle)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillPieI(nativeObject, brush.NativeBrush, x, y, width, height, startAngle, sweepAngle));
		}

		/// <summary>Fills the interior of a pie section defined by an ellipse specified by a pair of coordinates, a width, a height, and two radial lines.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the first side of the pie section.</param>
		/// <param name="sweepAngle">Angle in degrees measured clockwise from the <paramref name="startAngle" /> parameter to the second side of the pie section.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillPie(Brush brush, float x, float y, float width, float height, float startAngle, float sweepAngle)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillPie(nativeObject, brush.NativeBrush, x, y, width, height, startAngle, sweepAngle));
		}

		/// <summary>Fills the interior of a polygon defined by an array of points specified by <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that represent the vertices of the polygon to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillPolygon(Brush brush, PointF[] points)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillPolygon2(nativeObject, brush.NativeBrush, points, points.Length));
		}

		/// <summary>Fills the interior of a polygon defined by an array of points specified by <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that represent the vertices of the polygon to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillPolygon(Brush brush, Point[] points)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillPolygon2I(nativeObject, brush.NativeBrush, points, points.Length));
		}

		/// <summary>Fills the interior of a polygon defined by an array of points specified by <see cref="T:System.Drawing.Point" /> structures using the specified fill mode.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that represent the vertices of the polygon to fill.</param>
		/// <param name="fillMode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines the style of the fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillPolygon(Brush brush, Point[] points, FillMode fillMode)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillPolygonI(nativeObject, brush.NativeBrush, points, points.Length, fillMode));
		}

		/// <summary>Fills the interior of a polygon defined by an array of points specified by <see cref="T:System.Drawing.PointF" /> structures using the specified fill mode.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that represent the vertices of the polygon to fill.</param>
		/// <param name="fillMode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines the style of the fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillPolygon(Brush brush, PointF[] points, FillMode fillMode)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillPolygon(nativeObject, brush.NativeBrush, points, points.Length, fillMode));
		}

		/// <summary>Fills the interior of a rectangle specified by a <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillRectangle(Brush brush, RectangleF rect)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			FillRectangle(brush, rect.Left, rect.Top, rect.Width, rect.Height);
		}

		/// <summary>Fills the interior of a rectangle specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillRectangle(Brush brush, Rectangle rect)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			FillRectangle(brush, rect.Left, rect.Top, rect.Width, rect.Height);
		}

		/// <summary>Fills the interior of a rectangle specified by a pair of coordinates, a width, and a height.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to fill.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to fill.</param>
		/// <param name="width">Width of the rectangle to fill.</param>
		/// <param name="height">Height of the rectangle to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillRectangle(Brush brush, int x, int y, int width, int height)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillRectangleI(nativeObject, brush.NativeBrush, x, y, width, height));
		}

		/// <summary>Fills the interior of a rectangle specified by a pair of coordinates, a width, and a height.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to fill.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to fill.</param>
		/// <param name="width">Width of the rectangle to fill.</param>
		/// <param name="height">Height of the rectangle to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillRectangle(Brush brush, float x, float y, float width, float height)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillRectangle(nativeObject, brush.NativeBrush, x, y, width, height));
		}

		/// <summary>Fills the interiors of a series of rectangles specified by <see cref="T:System.Drawing.Rectangle" /> structures.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="rects">Array of <see cref="T:System.Drawing.Rectangle" /> structures that represent the rectangles to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="rects" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="rects" /> is a zero-length array.</exception>
		public void FillRectangles(Brush brush, Rectangle[] rects)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillRectanglesI(nativeObject, brush.NativeBrush, rects, rects.Length));
		}

		/// <summary>Fills the interiors of a series of rectangles specified by <see cref="T:System.Drawing.RectangleF" /> structures.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="rects">Array of <see cref="T:System.Drawing.RectangleF" /> structures that represent the rectangles to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="rects" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="Rects" /> is a zero-length array.</exception>
		public void FillRectangles(Brush brush, RectangleF[] rects)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillRectangles(nativeObject, brush.NativeBrush, rects, rects.Length));
		}

		/// <summary>Fills the interior of a <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="region">
		///   <see cref="T:System.Drawing.Region" /> that represents the area to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="region" /> is <see langword="null" />.</exception>
		public void FillRegion(Brush brush, Region region)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipFillRegion(nativeObject, brush.NativeBrush, region.NativeObject));
		}

		/// <summary>Forces execution of all pending graphics operations and returns immediately without waiting for the operations to finish.</summary>
		public void Flush()
		{
			Flush(FlushIntention.Flush);
		}

		/// <summary>Forces execution of all pending graphics operations with the method waiting or not waiting, as specified, to return before the operations finish.</summary>
		/// <param name="intention">Member of the <see cref="T:System.Drawing.Drawing2D.FlushIntention" /> enumeration that specifies whether the method returns immediately or waits for any existing operations to finish.</param>
		public void Flush(FlushIntention intention)
		{
			if (!(nativeObject == IntPtr.Zero))
			{
				GDIPlus.CheckStatus(GDIPlus.GdipFlush(nativeObject, intention));
				if (maccontext != null)
				{
					maccontext.Synchronize();
				}
			}
		}

		/// <summary>Creates a new <see cref="T:System.Drawing.Graphics" /> from the specified handle to a device context.</summary>
		/// <param name="hdc">Handle to a device context.</param>
		/// <returns>This method returns a new <see cref="T:System.Drawing.Graphics" /> for the specified device context.</returns>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public static Graphics FromHdc(IntPtr hdc)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateFromHDC(hdc, out var graphics));
			return new Graphics(graphics);
		}

		/// <summary>Creates a new <see cref="T:System.Drawing.Graphics" /> from the specified handle to a device context and handle to a device.</summary>
		/// <param name="hdc">Handle to a device context.</param>
		/// <param name="hdevice">Handle to a device.</param>
		/// <returns>This method returns a new <see cref="T:System.Drawing.Graphics" /> for the specified device context and device.</returns>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		[System.MonoTODO]
		public static Graphics FromHdc(IntPtr hdc, IntPtr hdevice)
		{
			throw new NotImplementedException();
		}

		/// <summary>Returns a <see cref="T:System.Drawing.Graphics" /> for the specified device context.</summary>
		/// <param name="hdc">Handle to a device context.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> for the specified device context.</returns>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public static Graphics FromHdcInternal(IntPtr hdc)
		{
			GDIPlus.Display = hdc;
			return null;
		}

		/// <summary>Creates a new <see cref="T:System.Drawing.Graphics" /> from the specified handle to a window.</summary>
		/// <param name="hwnd">Handle to a window.</param>
		/// <returns>This method returns a new <see cref="T:System.Drawing.Graphics" /> for the specified window handle.</returns>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public static Graphics FromHwnd(IntPtr hwnd)
		{
			IntPtr graphics;
			if (GDIPlus.UseCocoaDrawable)
			{
				CocoaContext cGContextForNSView = MacSupport.GetCGContextForNSView(hwnd);
				GDIPlus.GdipCreateFromContext_macosx(cGContextForNSView.ctx, cGContextForNSView.width, cGContextForNSView.height, out graphics);
				return new Graphics(graphics)
				{
					maccontext = cGContextForNSView
				};
			}
			if (GDIPlus.UseCarbonDrawable)
			{
				CarbonContext cGContextForView = MacSupport.GetCGContextForView(hwnd);
				GDIPlus.GdipCreateFromContext_macosx(cGContextForView.ctx, cGContextForView.width, cGContextForView.height, out graphics);
				return new Graphics(graphics)
				{
					maccontext = cGContextForView
				};
			}
			if (GDIPlus.UseX11Drawable)
			{
				if (GDIPlus.Display == IntPtr.Zero)
				{
					GDIPlus.Display = GDIPlus.XOpenDisplay(IntPtr.Zero);
					if (GDIPlus.Display == IntPtr.Zero)
					{
						throw new NotSupportedException("Could not open display (X-Server required. Check your DISPLAY environment variable)");
					}
				}
				if (hwnd == IntPtr.Zero)
				{
					hwnd = GDIPlus.XRootWindow(GDIPlus.Display, GDIPlus.XDefaultScreen(GDIPlus.Display));
				}
				return FromXDrawable(hwnd, GDIPlus.Display);
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreateFromHWND(hwnd, out graphics));
			return new Graphics(graphics);
		}

		/// <summary>Creates a new <see cref="T:System.Drawing.Graphics" /> for the specified windows handle.</summary>
		/// <param name="hwnd">Handle to a window.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> for the specified window handle.</returns>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public static Graphics FromHwndInternal(IntPtr hwnd)
		{
			return FromHwnd(hwnd);
		}

		/// <summary>Creates a new <see cref="T:System.Drawing.Graphics" /> from the specified <see cref="T:System.Drawing.Image" />.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> from which to create the new <see cref="T:System.Drawing.Graphics" />.</param>
		/// <returns>This method returns a new <see cref="T:System.Drawing.Graphics" /> for the specified <see cref="T:System.Drawing.Image" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Exception">
		///   <paramref name="image" /> has an indexed pixel format or its format is undefined.</exception>
		public static Graphics FromImage(Image image)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if ((image.PixelFormat & PixelFormat.Indexed) != PixelFormat.Undefined)
			{
				throw new Exception(global::Locale.GetText("Cannot create Graphics from an indexed bitmap."));
			}
			GDIPlus.CheckStatus(GDIPlus.GdipGetImageGraphicsContext(image.nativeObject, out var graphics));
			Graphics graphics2 = new Graphics(graphics);
			if (GDIPlus.RunningOnUnix())
			{
				Rectangle rect = new Rectangle(0, 0, image.Width, image.Height);
				GDIPlus.GdipSetVisibleClip_linux(graphics2.NativeObject, ref rect);
			}
			return graphics2;
		}

		internal static Graphics FromXDrawable(IntPtr drawable, IntPtr display)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateFromXDrawable_linux(drawable, display, out var graphics));
			return new Graphics(graphics);
		}

		/// <summary>Gets a handle to the current Windows halftone palette.</summary>
		/// <returns>Internal pointer that specifies the handle to the palette.</returns>
		[System.MonoTODO]
		public static IntPtr GetHalftonePalette()
		{
			throw new NotImplementedException();
		}

		/// <summary>Gets the handle to the device context associated with this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>Handle to the device context associated with this <see cref="T:System.Drawing.Graphics" />.</returns>
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public IntPtr GetHdc()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipGetDC(nativeObject, out deviceContextHdc));
			return deviceContextHdc;
		}

		/// <summary>Gets the nearest color to the specified <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <param name="color">
		///   <see cref="T:System.Drawing.Color" /> structure for which to find a match.</param>
		/// <returns>A <see cref="T:System.Drawing.Color" /> structure that represents the nearest color to the one specified with the <paramref name="color" /> parameter.</returns>
		public Color GetNearestColor(Color color)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipGetNearestColor(nativeObject, out var argb));
			return Color.FromArgb(argb);
		}

		/// <summary>Updates the clip region of this <see cref="T:System.Drawing.Graphics" /> to the intersection of the current clip region and the specified <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">
		///   <see cref="T:System.Drawing.Region" /> to intersect with the current region.</param>
		public void IntersectClip(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipSetClipRegion(nativeObject, region.NativeObject, CombineMode.Intersect));
		}

		/// <summary>Updates the clip region of this <see cref="T:System.Drawing.Graphics" /> to the intersection of the current clip region and the specified <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure to intersect with the current clip region.</param>
		public void IntersectClip(RectangleF rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipSetClipRect(nativeObject, rect.X, rect.Y, rect.Width, rect.Height, CombineMode.Intersect));
		}

		/// <summary>Updates the clip region of this <see cref="T:System.Drawing.Graphics" /> to the intersection of the current clip region and the specified <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure to intersect with the current clip region.</param>
		public void IntersectClip(Rectangle rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipSetClipRectI(nativeObject, rect.X, rect.Y, rect.Width, rect.Height, CombineMode.Intersect));
		}

		/// <summary>Indicates whether the specified <see cref="T:System.Drawing.Point" /> structure is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="point">
		///   <see cref="T:System.Drawing.Point" /> structure to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the point specified by the <paramref name="point" /> parameter is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Point point)
		{
			bool result = false;
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisiblePointI(nativeObject, point.X, point.Y, out result));
			return result;
		}

		/// <summary>Indicates whether the rectangle specified by a <see cref="T:System.Drawing.RectangleF" /> structure is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the rectangle specified by the <paramref name="rect" /> parameter is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(RectangleF rect)
		{
			bool result = false;
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRect(nativeObject, rect.X, rect.Y, rect.Width, rect.Height, out result));
			return result;
		}

		/// <summary>Indicates whether the specified <see cref="T:System.Drawing.PointF" /> structure is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="point">
		///   <see cref="T:System.Drawing.PointF" /> structure to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the point specified by the <paramref name="point" /> parameter is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(PointF point)
		{
			bool result = false;
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisiblePoint(nativeObject, point.X, point.Y, out result));
			return result;
		}

		/// <summary>Indicates whether the rectangle specified by a <see cref="T:System.Drawing.Rectangle" /> structure is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the rectangle specified by the <paramref name="rect" /> parameter is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Rectangle rect)
		{
			bool result = false;
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRectI(nativeObject, rect.X, rect.Y, rect.Width, rect.Height, out result));
			return result;
		}

		/// <summary>Indicates whether the point specified by a pair of coordinates is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the point to test for visibility.</param>
		/// <param name="y">The y-coordinate of the point to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the point defined by the <paramref name="x" /> and <paramref name="y" /> parameters is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y)
		{
			return IsVisible(new PointF(x, y));
		}

		/// <summary>Indicates whether the point specified by a pair of coordinates is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the point to test for visibility.</param>
		/// <param name="y">The y-coordinate of the point to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the point defined by the <paramref name="x" /> and <paramref name="y" /> parameters is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(int x, int y)
		{
			return IsVisible(new Point(x, y));
		}

		/// <summary>Indicates whether the rectangle specified by a pair of coordinates, a width, and a height is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to test for visibility.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to test for visibility.</param>
		/// <param name="width">Width of the rectangle to test for visibility.</param>
		/// <param name="height">Height of the rectangle to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the rectangle defined by the <paramref name="x" />, <paramref name="y" />, <paramref name="width" />, and <paramref name="height" /> parameters is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y, float width, float height)
		{
			return IsVisible(new RectangleF(x, y, width, height));
		}

		/// <summary>Indicates whether the rectangle specified by a pair of coordinates, a width, and a height is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to test for visibility.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to test for visibility.</param>
		/// <param name="width">Width of the rectangle to test for visibility.</param>
		/// <param name="height">Height of the rectangle to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the rectangle defined by the <paramref name="x" />, <paramref name="y" />, <paramref name="width" />, and <paramref name="height" /> parameters is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(int x, int y, int width, int height)
		{
			return IsVisible(new Rectangle(x, y, width, height));
		}

		/// <summary>Gets an array of <see cref="T:System.Drawing.Region" /> objects, each of which bounds a range of character positions within the specified string.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="layoutRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the layout rectangle for the string.</param>
		/// <param name="stringFormat">
		///   <see cref="T:System.Drawing.StringFormat" /> that represents formatting information, such as line spacing, for the string.</param>
		/// <returns>This method returns an array of <see cref="T:System.Drawing.Region" /> objects, each of which bounds a range of character positions within the specified string.</returns>
		public Region[] MeasureCharacterRanges(string text, Font font, RectangleF layoutRect, StringFormat stringFormat)
		{
			if (text == null || text.Length == 0)
			{
				return new Region[0];
			}
			if (font == null)
			{
				throw new ArgumentNullException("font");
			}
			if (stringFormat == null)
			{
				throw new ArgumentException("stringFormat");
			}
			int measurableCharacterRangeCount = stringFormat.GetMeasurableCharacterRangeCount();
			if (measurableCharacterRangeCount == 0)
			{
				return new Region[0];
			}
			IntPtr[] array = new IntPtr[measurableCharacterRangeCount];
			Region[] array2 = new Region[measurableCharacterRangeCount];
			for (int i = 0; i < measurableCharacterRangeCount; i++)
			{
				array2[i] = new Region();
				array[i] = array2[i].NativeObject;
			}
			GDIPlus.CheckStatus(GDIPlus.GdipMeasureCharacterRanges(nativeObject, text, text.Length, font.NativeObject, ref layoutRect, stringFormat.NativeObject, measurableCharacterRangeCount, out array[0]));
			return array2;
		}

		private unsafe SizeF GdipMeasureString(IntPtr graphics, string text, Font font, ref RectangleF layoutRect, IntPtr stringFormat)
		{
			if (text == null || text.Length == 0)
			{
				return SizeF.Empty;
			}
			if (font == null)
			{
				throw new ArgumentNullException("font");
			}
			RectangleF boundingBox = default(RectangleF);
			GDIPlus.CheckStatus(GDIPlus.GdipMeasureString(nativeObject, text, text.Length, font.NativeObject, ref layoutRect, stringFormat, out boundingBox, null, null));
			return new SizeF(boundingBox.Width, boundingBox.Height);
		}

		/// <summary>Measures the specified string when drawn with the specified <see cref="T:System.Drawing.Font" />.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.SizeF" /> structure that represents the size, in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, of the string specified by the <paramref name="text" /> parameter as drawn with the <paramref name="font" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="font" /> is <see langword="null" />.</exception>
		public SizeF MeasureString(string text, Font font)
		{
			return MeasureString(text, font, SizeF.Empty);
		}

		/// <summary>Measures the specified string when drawn with the specified <see cref="T:System.Drawing.Font" /> within the specified layout area.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> defines the text format of the string.</param>
		/// <param name="layoutArea">
		///   <see cref="T:System.Drawing.SizeF" /> structure that specifies the maximum layout area for the text.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.SizeF" /> structure that represents the size, in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, of the string specified by the <paramref name="text" /> parameter as drawn with the <paramref name="font" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="font" /> is <see langword="null" />.</exception>
		public SizeF MeasureString(string text, Font font, SizeF layoutArea)
		{
			RectangleF layoutRect = new RectangleF(0f, 0f, layoutArea.Width, layoutArea.Height);
			return GdipMeasureString(nativeObject, text, font, ref layoutRect, IntPtr.Zero);
		}

		/// <summary>Measures the specified string when drawn with the specified <see cref="T:System.Drawing.Font" />.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the format of the string.</param>
		/// <param name="width">Maximum width of the string in pixels.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.SizeF" /> structure that represents the size, in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, of the string specified in the <paramref name="text" /> parameter as drawn with the <paramref name="font" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="font" /> is <see langword="null" />.</exception>
		public SizeF MeasureString(string text, Font font, int width)
		{
			RectangleF layoutRect = new RectangleF(0f, 0f, width, 2.1474836E+09f);
			return GdipMeasureString(nativeObject, text, font, ref layoutRect, IntPtr.Zero);
		}

		/// <summary>Measures the specified string when drawn with the specified <see cref="T:System.Drawing.Font" /> and formatted with the specified <see cref="T:System.Drawing.StringFormat" />.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> defines the text format of the string.</param>
		/// <param name="layoutArea">
		///   <see cref="T:System.Drawing.SizeF" /> structure that specifies the maximum layout area for the text.</param>
		/// <param name="stringFormat">
		///   <see cref="T:System.Drawing.StringFormat" /> that represents formatting information, such as line spacing, for the string.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.SizeF" /> structure that represents the size, in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, of the string specified in the <paramref name="text" /> parameter as drawn with the <paramref name="font" /> parameter and the <paramref name="stringFormat" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="font" /> is <see langword="null" />.</exception>
		public SizeF MeasureString(string text, Font font, SizeF layoutArea, StringFormat stringFormat)
		{
			RectangleF layoutRect = new RectangleF(0f, 0f, layoutArea.Width, layoutArea.Height);
			IntPtr stringFormat2 = stringFormat?.NativeObject ?? IntPtr.Zero;
			return GdipMeasureString(nativeObject, text, font, ref layoutRect, stringFormat2);
		}

		/// <summary>Measures the specified string when drawn with the specified <see cref="T:System.Drawing.Font" /> and formatted with the specified <see cref="T:System.Drawing.StringFormat" />.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="width">Maximum width of the string.</param>
		/// <param name="format">
		///   <see cref="T:System.Drawing.StringFormat" /> that represents formatting information, such as line spacing, for the string.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.SizeF" /> structure that represents the size, in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, of the string specified in the <paramref name="text" /> parameter as drawn with the <paramref name="font" /> parameter and the <paramref name="stringFormat" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="font" /> is <see langword="null" />.</exception>
		public SizeF MeasureString(string text, Font font, int width, StringFormat format)
		{
			RectangleF layoutRect = new RectangleF(0f, 0f, width, 2.1474836E+09f);
			IntPtr stringFormat = format?.NativeObject ?? IntPtr.Zero;
			return GdipMeasureString(nativeObject, text, font, ref layoutRect, stringFormat);
		}

		/// <summary>Measures the specified string when drawn with the specified <see cref="T:System.Drawing.Font" /> and formatted with the specified <see cref="T:System.Drawing.StringFormat" />.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> defines the text format of the string.</param>
		/// <param name="origin">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the upper-left corner of the string.</param>
		/// <param name="stringFormat">
		///   <see cref="T:System.Drawing.StringFormat" /> that represents formatting information, such as line spacing, for the string.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.SizeF" /> structure that represents the size, in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, of the string specified by the <paramref name="text" /> parameter as drawn with the <paramref name="font" /> parameter and the <paramref name="stringFormat" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="font" /> is <see langword="null" />.</exception>
		public SizeF MeasureString(string text, Font font, PointF origin, StringFormat stringFormat)
		{
			RectangleF layoutRect = new RectangleF(origin.X, origin.Y, 0f, 0f);
			IntPtr stringFormat2 = stringFormat?.NativeObject ?? IntPtr.Zero;
			return GdipMeasureString(nativeObject, text, font, ref layoutRect, stringFormat2);
		}

		/// <summary>Measures the specified string when drawn with the specified <see cref="T:System.Drawing.Font" /> and formatted with the specified <see cref="T:System.Drawing.StringFormat" />.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="layoutArea">
		///   <see cref="T:System.Drawing.SizeF" /> structure that specifies the maximum layout area for the text.</param>
		/// <param name="stringFormat">
		///   <see cref="T:System.Drawing.StringFormat" /> that represents formatting information, such as line spacing, for the string.</param>
		/// <param name="charactersFitted">Number of characters in the string.</param>
		/// <param name="linesFilled">Number of text lines in the string.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.SizeF" /> structure that represents the size of the string, in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, of the <paramref name="text" /> parameter as drawn with the <paramref name="font" /> parameter and the <paramref name="stringFormat" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="font" /> is <see langword="null" />.</exception>
		public unsafe SizeF MeasureString(string text, Font font, SizeF layoutArea, StringFormat stringFormat, out int charactersFitted, out int linesFilled)
		{
			charactersFitted = 0;
			linesFilled = 0;
			if (text == null || text.Length == 0)
			{
				return SizeF.Empty;
			}
			if (font == null)
			{
				throw new ArgumentNullException("font");
			}
			RectangleF boundingBox = default(RectangleF);
			RectangleF layoutRect = new RectangleF(0f, 0f, layoutArea.Width, layoutArea.Height);
			IntPtr stringFormat2 = stringFormat?.NativeObject ?? IntPtr.Zero;
			fixed (int* codepointsFitted = &charactersFitted)
			{
				fixed (int* linesFilled2 = &linesFilled)
				{
					GDIPlus.CheckStatus(GDIPlus.GdipMeasureString(nativeObject, text, text.Length, font.NativeObject, ref layoutRect, stringFormat2, out boundingBox, codepointsFitted, linesFilled2));
				}
			}
			return new SizeF(boundingBox.Width, boundingBox.Height);
		}

		/// <summary>Multiplies the world transformation of this <see cref="T:System.Drawing.Graphics" /> and specified the <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="matrix">4x4 <see cref="T:System.Drawing.Drawing2D.Matrix" /> that multiplies the world transformation.</param>
		public void MultiplyTransform(Matrix matrix)
		{
			MultiplyTransform(matrix, MatrixOrder.Prepend);
		}

		/// <summary>Multiplies the world transformation of this <see cref="T:System.Drawing.Graphics" /> and specified the <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the specified order.</summary>
		/// <param name="matrix">4x4 <see cref="T:System.Drawing.Drawing2D.Matrix" /> that multiplies the world transformation.</param>
		/// <param name="order">Member of the <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> enumeration that determines the order of the multiplication.</param>
		public void MultiplyTransform(Matrix matrix, MatrixOrder order)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipMultiplyWorldTransform(nativeObject, matrix.nativeMatrix, order));
		}

		/// <summary>Releases a device context handle obtained by a previous call to the <see cref="M:System.Drawing.Graphics.GetHdc" /> method of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="hdc">Handle to a device context obtained by a previous call to the <see cref="M:System.Drawing.Graphics.GetHdc" /> method of this <see cref="T:System.Drawing.Graphics" />.</param>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public void ReleaseHdc(IntPtr hdc)
		{
			ReleaseHdcInternal(hdc);
		}

		/// <summary>Releases a device context handle obtained by a previous call to the <see cref="M:System.Drawing.Graphics.GetHdc" /> method of this <see cref="T:System.Drawing.Graphics" />.</summary>
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public void ReleaseHdc()
		{
			ReleaseHdcInternal(deviceContextHdc);
		}

		/// <summary>Releases a handle to a device context.</summary>
		/// <param name="hdc">Handle to a device context.</param>
		[System.MonoLimitation("Can only be used when hdc was provided by Graphics.GetHdc() method")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void ReleaseHdcInternal(IntPtr hdc)
		{
			Status status = Status.InvalidParameter;
			if (hdc == deviceContextHdc)
			{
				status = GDIPlus.GdipReleaseDC(nativeObject, deviceContextHdc);
				deviceContextHdc = IntPtr.Zero;
			}
			GDIPlus.CheckStatus(status);
		}

		/// <summary>Resets the clip region of this <see cref="T:System.Drawing.Graphics" /> to an infinite region.</summary>
		public void ResetClip()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipResetClip(nativeObject));
		}

		/// <summary>Resets the world transformation matrix of this <see cref="T:System.Drawing.Graphics" /> to the identity matrix.</summary>
		public void ResetTransform()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipResetWorldTransform(nativeObject));
		}

		/// <summary>Restores the state of this <see cref="T:System.Drawing.Graphics" /> to the state represented by a <see cref="T:System.Drawing.Drawing2D.GraphicsState" />.</summary>
		/// <param name="gstate">
		///   <see cref="T:System.Drawing.Drawing2D.GraphicsState" /> that represents the state to which to restore this <see cref="T:System.Drawing.Graphics" />.</param>
		public void Restore(GraphicsState gstate)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipRestoreGraphics(nativeObject, (uint)gstate.nativeState));
		}

		/// <summary>Applies the specified rotation to the transformation matrix of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="angle">Angle of rotation in degrees.</param>
		public void RotateTransform(float angle)
		{
			RotateTransform(angle, MatrixOrder.Prepend);
		}

		/// <summary>Applies the specified rotation to the transformation matrix of this <see cref="T:System.Drawing.Graphics" /> in the specified order.</summary>
		/// <param name="angle">Angle of rotation in degrees.</param>
		/// <param name="order">Member of the <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> enumeration that specifies whether the rotation is appended or prepended to the matrix transformation.</param>
		public void RotateTransform(float angle, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipRotateWorldTransform(nativeObject, angle, order));
		}

		/// <summary>Saves the current state of this <see cref="T:System.Drawing.Graphics" /> and identifies the saved state with a <see cref="T:System.Drawing.Drawing2D.GraphicsState" />.</summary>
		/// <returns>This method returns a <see cref="T:System.Drawing.Drawing2D.GraphicsState" /> that represents the saved state of this <see cref="T:System.Drawing.Graphics" />.</returns>
		public GraphicsState Save()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipSaveGraphics(nativeObject, out var state));
			return new GraphicsState((int)state);
		}

		/// <summary>Applies the specified scaling operation to the transformation matrix of this <see cref="T:System.Drawing.Graphics" /> by prepending it to the object's transformation matrix.</summary>
		/// <param name="sx">Scale factor in the x direction.</param>
		/// <param name="sy">Scale factor in the y direction.</param>
		public void ScaleTransform(float sx, float sy)
		{
			ScaleTransform(sx, sy, MatrixOrder.Prepend);
		}

		/// <summary>Applies the specified scaling operation to the transformation matrix of this <see cref="T:System.Drawing.Graphics" /> in the specified order.</summary>
		/// <param name="sx">Scale factor in the x direction.</param>
		/// <param name="sy">Scale factor in the y direction.</param>
		/// <param name="order">Member of the <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> enumeration that specifies whether the scaling operation is prepended or appended to the transformation matrix.</param>
		public void ScaleTransform(float sx, float sy, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipScaleWorldTransform(nativeObject, sx, sy, order));
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the rectangle specified by a <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that represents the new clip region.</param>
		public void SetClip(RectangleF rect)
		{
			SetClip(rect, CombineMode.Replace);
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="path">
		///   <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> that represents the new clip region.</param>
		public void SetClip(GraphicsPath path)
		{
			SetClip(path, CombineMode.Replace);
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the rectangle specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that represents the new clip region.</param>
		public void SetClip(Rectangle rect)
		{
			SetClip(rect, CombineMode.Replace);
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the <see langword="Clip" /> property of the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="g">
		///   <see cref="T:System.Drawing.Graphics" /> from which to take the new clip region.</param>
		public void SetClip(Graphics g)
		{
			SetClip(g, CombineMode.Replace);
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the result of the specified combining operation of the current clip region and the <see cref="P:System.Drawing.Graphics.Clip" /> property of the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="g">
		///   <see cref="T:System.Drawing.Graphics" /> that specifies the clip region to combine.</param>
		/// <param name="combineMode">Member of the <see cref="T:System.Drawing.Drawing2D.CombineMode" /> enumeration that specifies the combining operation to use.</param>
		public void SetClip(Graphics g, CombineMode combineMode)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipSetClipGraphics(nativeObject, g.NativeObject, combineMode));
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the result of the specified operation combining the current clip region and the rectangle specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure to combine.</param>
		/// <param name="combineMode">Member of the <see cref="T:System.Drawing.Drawing2D.CombineMode" /> enumeration that specifies the combining operation to use.</param>
		public void SetClip(Rectangle rect, CombineMode combineMode)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipSetClipRectI(nativeObject, rect.X, rect.Y, rect.Width, rect.Height, combineMode));
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the result of the specified operation combining the current clip region and the rectangle specified by a <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure to combine.</param>
		/// <param name="combineMode">Member of the <see cref="T:System.Drawing.Drawing2D.CombineMode" /> enumeration that specifies the combining operation to use.</param>
		public void SetClip(RectangleF rect, CombineMode combineMode)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipSetClipRect(nativeObject, rect.X, rect.Y, rect.Width, rect.Height, combineMode));
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the result of the specified operation combining the current clip region and the specified <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">
		///   <see cref="T:System.Drawing.Region" /> to combine.</param>
		/// <param name="combineMode">Member from the <see cref="T:System.Drawing.Drawing2D.CombineMode" /> enumeration that specifies the combining operation to use.</param>
		public void SetClip(Region region, CombineMode combineMode)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipSetClipRegion(nativeObject, region.NativeObject, combineMode));
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the result of the specified operation combining the current clip region and the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="path">
		///   <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to combine.</param>
		/// <param name="combineMode">Member of the <see cref="T:System.Drawing.Drawing2D.CombineMode" /> enumeration that specifies the combining operation to use.</param>
		public void SetClip(GraphicsPath path, CombineMode combineMode)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipSetClipPath(nativeObject, path.nativePath, combineMode));
		}

		/// <summary>Transforms an array of points from one coordinate space to another using the current world and page transformations of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="destSpace">Member of the <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> enumeration that specifies the destination coordinate space.</param>
		/// <param name="srcSpace">Member of the <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> enumeration that specifies the source coordinate space.</param>
		/// <param name="pts">Array of <see cref="T:System.Drawing.PointF" /> structures that represent the points to transform.</param>
		public void TransformPoints(CoordinateSpace destSpace, CoordinateSpace srcSpace, PointF[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr intPtr = GDIPlus.FromPointToUnManagedMemory(pts);
			GDIPlus.CheckStatus(GDIPlus.GdipTransformPoints(nativeObject, destSpace, srcSpace, intPtr, pts.Length));
			GDIPlus.FromUnManagedMemoryToPoint(intPtr, pts);
		}

		/// <summary>Transforms an array of points from one coordinate space to another using the current world and page transformations of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="destSpace">Member of the <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> enumeration that specifies the destination coordinate space.</param>
		/// <param name="srcSpace">Member of the <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> enumeration that specifies the source coordinate space.</param>
		/// <param name="pts">Array of <see cref="T:System.Drawing.Point" /> structures that represents the points to transformation.</param>
		public void TransformPoints(CoordinateSpace destSpace, CoordinateSpace srcSpace, Point[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr intPtr = GDIPlus.FromPointToUnManagedMemoryI(pts);
			GDIPlus.CheckStatus(GDIPlus.GdipTransformPointsI(nativeObject, destSpace, srcSpace, intPtr, pts.Length));
			GDIPlus.FromUnManagedMemoryToPointI(intPtr, pts);
		}

		/// <summary>Translates the clipping region of this <see cref="T:System.Drawing.Graphics" /> by specified amounts in the horizontal and vertical directions.</summary>
		/// <param name="dx">The x-coordinate of the translation.</param>
		/// <param name="dy">The y-coordinate of the translation.</param>
		public void TranslateClip(int dx, int dy)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipTranslateClipI(nativeObject, dx, dy));
		}

		/// <summary>Translates the clipping region of this <see cref="T:System.Drawing.Graphics" /> by specified amounts in the horizontal and vertical directions.</summary>
		/// <param name="dx">The x-coordinate of the translation.</param>
		/// <param name="dy">The y-coordinate of the translation.</param>
		public void TranslateClip(float dx, float dy)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipTranslateClip(nativeObject, dx, dy));
		}

		/// <summary>Changes the origin of the coordinate system by prepending the specified translation to the transformation matrix of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="dx">The x-coordinate of the translation.</param>
		/// <param name="dy">The y-coordinate of the translation.</param>
		public void TranslateTransform(float dx, float dy)
		{
			TranslateTransform(dx, dy, MatrixOrder.Prepend);
		}

		/// <summary>Changes the origin of the coordinate system by applying the specified translation to the transformation matrix of this <see cref="T:System.Drawing.Graphics" /> in the specified order.</summary>
		/// <param name="dx">The x-coordinate of the translation.</param>
		/// <param name="dy">The y-coordinate of the translation.</param>
		/// <param name="order">Member of the <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> enumeration that specifies whether the translation is prepended or appended to the transformation matrix.</param>
		public void TranslateTransform(float dx, float dy, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipTranslateWorldTransform(nativeObject, dx, dy, order));
		}

		/// <summary>Gets the cumulative graphics context.</summary>
		/// <returns>An <see cref="T:System.Object" /> representing the cumulative graphics context.</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		[System.MonoTODO]
		public object GetContextInfo()
		{
			throw new NotImplementedException();
		}

		internal Graphics()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Specifies the unit of measure for the given data.</summary>
	public enum GraphicsUnit
	{
		/// <summary>Specifies the world coordinate system unit as the unit of measure.</summary>
		World,
		/// <summary>Specifies the unit of measure of the display device. Typically pixels for video displays, and 1/100 inch for printers.</summary>
		Display,
		/// <summary>Specifies a device pixel as the unit of measure.</summary>
		Pixel,
		/// <summary>Specifies a printer's point (1/72 inch) as the unit of measure.</summary>
		Point,
		/// <summary>Specifies the inch as the unit of measure.</summary>
		Inch,
		/// <summary>Specifies the document unit (1/300 inch) as the unit of measure.</summary>
		Document,
		/// <summary>Specifies the millimeter as the unit of measure.</summary>
		Millimeter
	}
	/// <summary>Represents a Windows icon, which is a small bitmap image that is used to represent an object. Icons can be thought of as transparent bitmaps, although their size is determined by the system.</summary>
	[Serializable]
	[TypeConverter(typeof(IconConverter))]
	[Editor("System.Drawing.Design.IconEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	public sealed class Icon : MarshalByRefObject, ISerializable, ICloneable, IDisposable
	{
		internal struct IconDirEntry
		{
			internal byte width;

			internal byte height;

			internal byte colorCount;

			internal byte reserved;

			internal ushort planes;

			internal ushort bitCount;

			internal uint bytesInRes;

			internal uint imageOffset;

			internal bool ignore;
		}

		internal struct IconDir
		{
			internal ushort idReserved;

			internal ushort idType;

			internal ushort idCount;

			internal IconDirEntry[] idEntries;
		}

		internal struct BitmapInfoHeader
		{
			internal uint biSize;

			internal int biWidth;

			internal int biHeight;

			internal ushort biPlanes;

			internal ushort biBitCount;

			internal uint biCompression;

			internal uint biSizeImage;

			internal int biXPelsPerMeter;

			internal int biYPelsPerMeter;

			internal uint biClrUsed;

			internal uint biClrImportant;
		}

		[StructLayout(LayoutKind.Sequential)]
		internal abstract class ImageData
		{
		}

		[StructLayout(LayoutKind.Sequential)]
		internal class IconImage : ImageData
		{
			internal BitmapInfoHeader iconHeader;

			internal uint[] iconColors;

			internal byte[] iconXOR;

			internal byte[] iconAND;
		}

		[StructLayout(LayoutKind.Sequential)]
		internal class IconDump : ImageData
		{
			internal byte[] data;
		}

		private Size iconSize;

		private IntPtr handle = IntPtr.Zero;

		private IconDir iconDir;

		private ushort id;

		private ImageData[] imageData;

		private bool undisposable;

		private bool disposed;

		private Bitmap bitmap;

		/// <summary>Gets the Windows handle for this <see cref="T:System.Drawing.Icon" />. This is not a copy of the handle; do not free it.</summary>
		/// <returns>The Windows handle for the icon.</returns>
		[Browsable(false)]
		public IntPtr Handle
		{
			get
			{
				if (!disposed && handle == IntPtr.Zero)
				{
					if (GDIPlus.RunningOnUnix())
					{
						handle = GetInternalBitmap().NativeObject;
					}
					else
					{
						IconInfo piconinfo = default(IconInfo);
						piconinfo.IsIcon = true;
						piconinfo.hbmColor = ToBitmap().GetHbitmap();
						piconinfo.hbmMask = piconinfo.hbmColor;
						handle = GDIPlus.CreateIconIndirect(ref piconinfo);
					}
				}
				return handle;
			}
		}

		/// <summary>Gets the height of this <see cref="T:System.Drawing.Icon" />.</summary>
		/// <returns>The height of this <see cref="T:System.Drawing.Icon" />.</returns>
		[Browsable(false)]
		public int Height => iconSize.Height;

		/// <summary>Gets the size of this <see cref="T:System.Drawing.Icon" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure that specifies the width and height of this <see cref="T:System.Drawing.Icon" />.</returns>
		public Size Size => iconSize;

		/// <summary>Gets the width of this <see cref="T:System.Drawing.Icon" />.</summary>
		/// <returns>The width of this <see cref="T:System.Drawing.Icon" />.</returns>
		[Browsable(false)]
		public int Width => iconSize.Width;

		private Icon()
		{
		}

		private Icon(IntPtr handle)
		{
			this.handle = handle;
			bitmap = Bitmap.FromHicon(handle);
			iconSize = new Size(bitmap.Width, bitmap.Height);
			if (GDIPlus.RunningOnUnix())
			{
				bitmap = Bitmap.FromHicon(handle);
				iconSize = new Size(bitmap.Width, bitmap.Height);
			}
			else
			{
				GDIPlus.GetIconInfo(handle, out var iconinfo);
				if (!iconinfo.IsIcon)
				{
					throw new NotImplementedException(global::Locale.GetText("Handle doesn't represent an ICON."));
				}
				iconSize = new Size(iconinfo.xHotspot * 2, iconinfo.yHotspot * 2);
				bitmap = Image.FromHbitmap(iconinfo.hbmColor);
			}
			undisposable = true;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class and attempts to find a version of the icon that matches the requested size.</summary>
		/// <param name="original">The icon to load the different size from.</param>
		/// <param name="width">The width of the new icon.</param>
		/// <param name="height">The height of the new icon.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="original" /> parameter is <see langword="null" />.</exception>
		public Icon(Icon original, int width, int height)
			: this(original, new Size(width, height))
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class and attempts to find a version of the icon that matches the requested size.</summary>
		/// <param name="original">The <see cref="T:System.Drawing.Icon" /> from which to load the newly sized icon.</param>
		/// <param name="size">A <see cref="T:System.Drawing.Size" /> structure that specifies the height and width of the new <see cref="T:System.Drawing.Icon" />.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="original" /> parameter is <see langword="null" />.</exception>
		public Icon(Icon original, Size size)
		{
			if (original == null)
			{
				throw new ArgumentException("original");
			}
			iconSize = size;
			iconDir = original.iconDir;
			int idCount = iconDir.idCount;
			if (idCount > 0)
			{
				imageData = original.imageData;
				id = ushort.MaxValue;
				for (ushort num = 0; num < idCount; num++)
				{
					IconDirEntry iconDirEntry = iconDir.idEntries[num];
					if ((iconDirEntry.height == size.Height || iconDirEntry.width == size.Width) && !iconDirEntry.ignore)
					{
						id = num;
						break;
					}
				}
				if (id == ushort.MaxValue)
				{
					int num2 = Math.Min(size.Height, size.Width);
					IconDirEntry? iconDirEntry2 = null;
					for (ushort num3 = 0; num3 < idCount; num3++)
					{
						IconDirEntry value = iconDir.idEntries[num3];
						if ((value.height < num2 || value.width < num2) && !value.ignore)
						{
							if (!iconDirEntry2.HasValue)
							{
								iconDirEntry2 = value;
								id = num3;
							}
							else if (value.height > iconDirEntry2.Value.height || value.width > iconDirEntry2.Value.width)
							{
								iconDirEntry2 = value;
								id = num3;
							}
						}
					}
				}
				if (id == ushort.MaxValue)
				{
					int num4 = idCount;
					while (id == ushort.MaxValue && num4 > 0)
					{
						num4--;
						if (!iconDir.idEntries[num4].ignore)
						{
							id = (ushort)num4;
						}
					}
				}
				if (id == ushort.MaxValue)
				{
					throw new ArgumentException("Icon", "No valid icon image found");
				}
				iconSize.Height = iconDir.idEntries[id].height;
				iconSize.Width = iconDir.idEntries[id].width;
			}
			else
			{
				iconSize.Height = size.Height;
				iconSize.Width = size.Width;
			}
			if (original.bitmap != null)
			{
				bitmap = (Bitmap)original.bitmap.Clone();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class from the specified data stream.</summary>
		/// <param name="stream">The data stream from which to load the <see cref="T:System.Drawing.Icon" />.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="stream" /> parameter is <see langword="null" />.</exception>
		public Icon(Stream stream)
			: this(stream, 32, 32)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class from the specified data stream and with the specified width and height.</summary>
		/// <param name="stream">The data stream from which to load the icon.</param>
		/// <param name="width">The width, in pixels, of the icon.</param>
		/// <param name="height">The height, in pixels, of the icon.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="stream" /> parameter is <see langword="null" />.</exception>
		public Icon(Stream stream, int width, int height)
		{
			InitFromStreamWithSize(stream, width, height);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class from the specified file name.</summary>
		/// <param name="fileName">The file to load the <see cref="T:System.Drawing.Icon" /> from.</param>
		public Icon(string fileName)
		{
			using FileStream stream = File.OpenRead(fileName);
			InitFromStreamWithSize(stream, 32, 32);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class from a resource in the specified assembly.</summary>
		/// <param name="type">A <see cref="T:System.Type" /> that specifies the assembly in which to look for the resource.</param>
		/// <param name="resource">The resource name to load.</param>
		/// <exception cref="T:System.ArgumentException">An icon specified by <paramref name="resource" /> cannot be found in the assembly that contains the specified <paramref name="type" />.</exception>
		public Icon(Type type, string resource)
		{
			if (resource == null)
			{
				throw new ArgumentException("resource");
			}
			if (type == null)
			{
				throw new NullReferenceException();
			}
			using Stream stream = type.GetTypeInfo().Assembly.GetManifestResourceStream(type, resource);
			if (stream == null)
			{
				throw new FileNotFoundException(global::Locale.GetText("Resource '{0}' was not found.", resource));
			}
			InitFromStreamWithSize(stream, 32, 32);
		}

		private Icon(SerializationInfo info, StreamingContext context)
		{
			MemoryStream memoryStream = null;
			int width = 0;
			int height = 0;
			SerializationInfoEnumerator enumerator = info.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SerializationEntry current = enumerator.Current;
				if (string.Compare(current.Name, "IconData", ignoreCase: true) == 0)
				{
					memoryStream = new MemoryStream((byte[])current.Value);
				}
				if (string.Compare(current.Name, "IconSize", ignoreCase: true) == 0)
				{
					Size size = (Size)current.Value;
					width = size.Width;
					height = size.Height;
				}
			}
			if (memoryStream != null)
			{
				memoryStream.Seek(0L, SeekOrigin.Begin);
				InitFromStreamWithSize(memoryStream, width, height);
			}
		}

		internal Icon(string resourceName, bool undisposable)
		{
			using (Stream stream = typeof(Icon).GetTypeInfo().Assembly.GetManifestResourceStream(resourceName))
			{
				if (stream == null)
				{
					throw new FileNotFoundException(global::Locale.GetText("Resource '{0}' was not found.", resourceName));
				}
				InitFromStreamWithSize(stream, 32, 32);
			}
			this.undisposable = true;
		}

		/// <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data that is required to serialize the target object.</summary>
		/// <param name="si">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object to populate with data.</param>
		/// <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this serialization.</param>
		void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context)
		{
			MemoryStream memoryStream = new MemoryStream();
			Save(memoryStream);
			si.AddValue("IconSize", Size, typeof(Size));
			si.AddValue("IconData", memoryStream.ToArray());
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class of the specified size from the specified stream.</summary>
		/// <param name="stream">The stream that contains the icon data.</param>
		/// <param name="size">The desired size of the icon.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="stream" /> is <see langword="null" /> or does not contain image data.</exception>
		public Icon(Stream stream, Size size)
			: this(stream, size.Width, size.Height)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class with the specified width and height from the specified file.</summary>
		/// <param name="fileName">The name and path to the file that contains the <see cref="T:System.Drawing.Icon" /> data.</param>
		/// <param name="width">The desired width of the <see cref="T:System.Drawing.Icon" />.</param>
		/// <param name="height">The desired height of the <see cref="T:System.Drawing.Icon" />.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="string" /> is <see langword="null" /> or does not contain image data.</exception>
		public Icon(string fileName, int width, int height)
		{
			using FileStream stream = File.OpenRead(fileName);
			InitFromStreamWithSize(stream, width, height);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class of the specified size from the specified file.</summary>
		/// <param name="fileName">The name and path to the file that contains the icon data.</param>
		/// <param name="size">The desired size of the icon.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="string" /> is <see langword="null" /> or does not contain image data.</exception>
		public Icon(string fileName, Size size)
		{
			using FileStream stream = File.OpenRead(fileName);
			InitFromStreamWithSize(stream, size.Width, size.Height);
		}

		/// <summary>Returns an icon representation of an image that is contained in the specified file.</summary>
		/// <param name="filePath">The path to the file that contains an image.</param>
		/// <returns>The <see cref="T:System.Drawing.Icon" /> representation of the image that is contained in the specified file.</returns>
		/// <exception cref="T:System.ArgumentException">The <paramref name="filePath" /> does not indicate a valid file.  
		///  -or-  
		///  The <paramref name="filePath" /> indicates a Universal Naming Convention (UNC) path.</exception>
		[System.MonoLimitation("The same icon, SystemIcons.WinLogo, is returned for all file types.")]
		public static Icon ExtractAssociatedIcon(string filePath)
		{
			if (string.IsNullOrEmpty(filePath))
			{
				throw new ArgumentException(global::Locale.GetText("Null or empty path."), "filePath");
			}
			if (!File.Exists(filePath))
			{
				throw new FileNotFoundException(global::Locale.GetText("Couldn't find specified file."), filePath);
			}
			return SystemIcons.WinLogo;
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Icon" />.</summary>
		public void Dispose()
		{
			if (undisposable)
			{
				return;
			}
			if (!disposed)
			{
				if (GDIPlus.RunningOnWindows() && handle != IntPtr.Zero)
				{
					GDIPlus.DestroyIcon(handle);
					handle = IntPtr.Zero;
				}
				if (bitmap != null)
				{
					bitmap.Dispose();
					bitmap = null;
				}
				GC.SuppressFinalize(this);
			}
			disposed = true;
		}

		/// <summary>Clones the <see cref="T:System.Drawing.Icon" />, creating a duplicate image.</summary>
		/// <returns>An object that can be cast to an <see cref="T:System.Drawing.Icon" />.</returns>
		public object Clone()
		{
			return new Icon(this, Size);
		}

		/// <summary>Creates a GDI+ <see cref="T:System.Drawing.Icon" /> from the specified Windows handle to an icon (<see langword="HICON" />).</summary>
		/// <param name="handle">A Windows handle to an icon.</param>
		/// <returns>The <see cref="T:System.Drawing.Icon" /> this method creates.</returns>
		public static Icon FromHandle(IntPtr handle)
		{
			if (handle == IntPtr.Zero)
			{
				throw new ArgumentException("handle");
			}
			return new Icon(handle);
		}

		private void SaveIconImage(BinaryWriter writer, IconImage ii)
		{
			BitmapInfoHeader iconHeader = ii.iconHeader;
			writer.Write(iconHeader.biSize);
			writer.Write(iconHeader.biWidth);
			writer.Write(iconHeader.biHeight);
			writer.Write(iconHeader.biPlanes);
			writer.Write(iconHeader.biBitCount);
			writer.Write(iconHeader.biCompression);
			writer.Write(iconHeader.biSizeImage);
			writer.Write(iconHeader.biXPelsPerMeter);
			writer.Write(iconHeader.biYPelsPerMeter);
			writer.Write(iconHeader.biClrUsed);
			writer.Write(iconHeader.biClrImportant);
			int num = ii.iconColors.Length;
			for (int i = 0; i < num; i++)
			{
				writer.Write(ii.iconColors[i]);
			}
			writer.Write(ii.iconXOR);
			writer.Write(ii.iconAND);
		}

		private void SaveIconDump(BinaryWriter writer, IconDump id)
		{
			writer.Write(id.data);
		}

		private void SaveIconDirEntry(BinaryWriter writer, IconDirEntry ide, uint offset)
		{
			writer.Write(ide.width);
			writer.Write(ide.height);
			writer.Write(ide.colorCount);
			writer.Write(ide.reserved);
			writer.Write(ide.planes);
			writer.Write(ide.bitCount);
			writer.Write(ide.bytesInRes);
			writer.Write((offset == uint.MaxValue) ? ide.imageOffset : offset);
		}

		private void SaveAll(BinaryWriter writer)
		{
			writer.Write(iconDir.idReserved);
			writer.Write(iconDir.idType);
			ushort idCount = iconDir.idCount;
			writer.Write(idCount);
			for (int i = 0; i < idCount; i++)
			{
				SaveIconDirEntry(writer, iconDir.idEntries[i], uint.MaxValue);
			}
			for (int j = 0; j < idCount; j++)
			{
				while (writer.BaseStream.Length < iconDir.idEntries[j].imageOffset)
				{
					writer.Write((byte)0);
				}
				if (imageData[j] is IconDump)
				{
					SaveIconDump(writer, (IconDump)imageData[j]);
				}
				else
				{
					SaveIconImage(writer, (IconImage)imageData[j]);
				}
			}
		}

		private void SaveBestSingleIcon(BinaryWriter writer, int width, int height)
		{
			writer.Write(iconDir.idReserved);
			writer.Write(iconDir.idType);
			writer.Write((ushort)1);
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < iconDir.idCount; i++)
			{
				IconDirEntry iconDirEntry = iconDir.idEntries[i];
				if (width == iconDirEntry.width && height == iconDirEntry.height && iconDirEntry.bitCount >= num2)
				{
					num2 = iconDirEntry.bitCount;
					num = i;
				}
			}
			SaveIconDirEntry(writer, iconDir.idEntries[num], 22u);
			SaveIconImage(writer, (IconImage)imageData[num]);
		}

		private void SaveBitmapAsIcon(BinaryWriter writer)
		{
			writer.Write((ushort)0);
			writer.Write((ushort)1);
			writer.Write((ushort)1);
			IconDirEntry ide = new IconDirEntry
			{
				width = (byte)bitmap.Width,
				height = (byte)bitmap.Height,
				colorCount = 0,
				reserved = 0,
				planes = 0,
				bitCount = 32,
				imageOffset = 22u
			};
			BitmapInfoHeader iconHeader = new BitmapInfoHeader
			{
				biSize = (uint)Marshal.SizeOf(typeof(BitmapInfoHeader)),
				biWidth = bitmap.Width,
				biHeight = 2 * bitmap.Height,
				biPlanes = 1,
				biBitCount = 32,
				biCompression = 0u,
				biSizeImage = 0u,
				biXPelsPerMeter = 0,
				biYPelsPerMeter = 0,
				biClrUsed = 0u,
				biClrImportant = 0u
			};
			IconImage iconImage = new IconImage();
			iconImage.iconHeader = iconHeader;
			iconImage.iconColors = new uint[0];
			int num = (((iconHeader.biBitCount * bitmap.Width + 31) & -32) >> 3) * bitmap.Height;
			iconImage.iconXOR = new byte[num];
			int num2 = 0;
			for (int num3 = bitmap.Height - 1; num3 >= 0; num3--)
			{
				for (int i = 0; i < bitmap.Width; i++)
				{
					Color pixel = bitmap.GetPixel(i, num3);
					iconImage.iconXOR[num2++] = pixel.B;
					iconImage.iconXOR[num2++] = pixel.G;
					iconImage.iconXOR[num2++] = pixel.R;
					iconImage.iconXOR[num2++] = pixel.A;
				}
			}
			int num4 = (((Width + 31) & -32) >> 3) * bitmap.Height;
			iconImage.iconAND = new byte[num4];
			ide.bytesInRes = (uint)(iconHeader.biSize + num + num4);
			SaveIconDirEntry(writer, ide, uint.MaxValue);
			SaveIconImage(writer, iconImage);
		}

		private void Save(Stream outputStream, int width, int height)
		{
			BinaryWriter binaryWriter = new BinaryWriter(outputStream);
			if (iconDir.idEntries != null)
			{
				if (width == -1 && height == -1)
				{
					SaveAll(binaryWriter);
				}
				else
				{
					SaveBestSingleIcon(binaryWriter, width, height);
				}
			}
			else if (bitmap != null)
			{
				SaveBitmapAsIcon(binaryWriter);
			}
			binaryWriter.Flush();
		}

		/// <summary>Saves this <see cref="T:System.Drawing.Icon" /> to the specified output <see cref="T:System.IO.Stream" />.</summary>
		/// <param name="outputStream">The <see cref="T:System.IO.Stream" /> to save to.</param>
		public void Save(Stream outputStream)
		{
			if (outputStream == null)
			{
				throw new NullReferenceException("outputStream");
			}
			Save(outputStream, -1, -1);
		}

		internal Bitmap BuildBitmapOnWin32()
		{
			if (imageData == null)
			{
				return new Bitmap(32, 32);
			}
			IconImage iconImage = (IconImage)imageData[id];
			BitmapInfoHeader iconHeader = iconImage.iconHeader;
			int num = iconHeader.biHeight / 2;
			if (iconHeader.biClrUsed == 0)
			{
				_ = iconHeader.biBitCount;
				_ = 24;
			}
			Bitmap bitmap = iconHeader.biBitCount switch
			{
				1 => new Bitmap(iconHeader.biWidth, num, PixelFormat.Format1bppIndexed), 
				4 => new Bitmap(iconHeader.biWidth, num, PixelFormat.Format4bppIndexed), 
				8 => new Bitmap(iconHeader.biWidth, num, PixelFormat.Format8bppIndexed), 
				24 => new Bitmap(iconHeader.biWidth, num, PixelFormat.Format24bppRgb), 
				32 => new Bitmap(iconHeader.biWidth, num, PixelFormat.Format32bppArgb), 
				_ => throw new Exception(global::Locale.GetText("Unexpected number of bits: {0}", iconHeader.biBitCount)), 
			};
			if (iconHeader.biBitCount < 24)
			{
				ColorPalette palette = bitmap.Palette;
				for (int i = 0; i < iconImage.iconColors.Length; i++)
				{
					palette.Entries[i] = Color.FromArgb((int)iconImage.iconColors[i] | -16777216);
				}
				bitmap.Palette = palette;
			}
			int num2 = ((iconHeader.biWidth * iconHeader.biBitCount + 31) & -32) >> 3;
			BitmapData bitmapData = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height), ImageLockMode.WriteOnly, bitmap.PixelFormat);
			for (int j = 0; j < num; j++)
			{
				Marshal.Copy(iconImage.iconXOR, num2 * j, (IntPtr)(bitmapData.Scan0.ToInt64() + bitmapData.Stride * (num - 1 - j)), num2);
			}
			bitmap.UnlockBits(bitmapData);
			bitmap = new Bitmap(bitmap);
			num2 = ((iconHeader.biWidth + 31) & -32) >> 3;
			for (int k = 0; k < num; k++)
			{
				for (int l = 0; l < iconHeader.biWidth / 8; l++)
				{
					for (int num3 = 7; num3 >= 0; num3--)
					{
						if (((iconImage.iconAND[k * num2 + l] >> num3) & 1) != 0)
						{
							bitmap.SetPixel(l * 8 + 7 - num3, num - k - 1, Color.Transparent);
						}
					}
				}
			}
			return bitmap;
		}

		internal Bitmap GetInternalBitmap()
		{
			if (bitmap == null)
			{
				if (GDIPlus.RunningOnUnix())
				{
					using MemoryStream memoryStream = new MemoryStream();
					Save(memoryStream, Width, Height);
					memoryStream.Position = 0L;
					bitmap = (Bitmap)Image.LoadFromStream(memoryStream, keepAlive: false);
				}
				else
				{
					bitmap = BuildBitmapOnWin32();
				}
			}
			return bitmap;
		}

		/// <summary>Converts this <see cref="T:System.Drawing.Icon" /> to a GDI+ <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Bitmap" /> that represents the converted <see cref="T:System.Drawing.Icon" />.</returns>
		public Bitmap ToBitmap()
		{
			if (disposed)
			{
				throw new ObjectDisposedException(global::Locale.GetText("Icon instance was disposed."));
			}
			return new Bitmap(GetInternalBitmap());
		}

		/// <summary>Gets a human-readable string that describes the <see cref="T:System.Drawing.Icon" />.</summary>
		/// <returns>A string that describes the <see cref="T:System.Drawing.Icon" />.</returns>
		public override string ToString()
		{
			return "<Icon>";
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Icon()
		{
			Dispose();
		}

		private void InitFromStreamWithSize(Stream stream, int width, int height)
		{
			if (stream == null || stream.Length == 0L)
			{
				throw new ArgumentException("The argument 'stream' must be a picture that can be used as a Icon", "stream");
			}
			BinaryReader binaryReader = new BinaryReader(stream);
			iconDir.idReserved = binaryReader.ReadUInt16();
			if (iconDir.idReserved != 0)
			{
				throw new ArgumentException("Invalid Argument", "stream");
			}
			iconDir.idType = binaryReader.ReadUInt16();
			if (iconDir.idType != 1)
			{
				throw new ArgumentException("Invalid Argument", "stream");
			}
			ushort num = binaryReader.ReadUInt16();
			imageData = new ImageData[num];
			iconDir.idCount = num;
			iconDir.idEntries = new IconDirEntry[num];
			bool flag = false;
			IconDirEntry iconDirEntry = default(IconDirEntry);
			for (int i = 0; i < num; i++)
			{
				iconDirEntry.width = binaryReader.ReadByte();
				iconDirEntry.height = binaryReader.ReadByte();
				iconDirEntry.colorCount = binaryReader.ReadByte();
				iconDirEntry.reserved = binaryReader.ReadByte();
				iconDirEntry.planes = binaryReader.ReadUInt16();
				iconDirEntry.bitCount = binaryReader.ReadUInt16();
				iconDirEntry.bytesInRes = binaryReader.ReadUInt32();
				iconDirEntry.imageOffset = binaryReader.ReadUInt32();
				if (iconDirEntry.width == 0 && iconDirEntry.height == 0)
				{
					iconDirEntry.ignore = true;
				}
				else
				{
					iconDirEntry.ignore = false;
				}
				iconDir.idEntries[i] = iconDirEntry;
				if (!flag && (iconDirEntry.height == height || iconDirEntry.width == width) && !iconDirEntry.ignore)
				{
					id = (ushort)i;
					flag = true;
					iconSize.Height = iconDirEntry.height;
					iconSize.Width = iconDirEntry.width;
				}
			}
			int num2 = 0;
			for (int j = 0; j < num; j++)
			{
				if (!iconDir.idEntries[j].ignore)
				{
					num2++;
				}
			}
			if (num2 == 0)
			{
				throw new Win32Exception(0, "No valid icon entry were found.");
			}
			if (!flag)
			{
				uint num3 = 0u;
				for (int k = 0; k < num; k++)
				{
					if (iconDir.idEntries[k].bytesInRes >= num3 && !iconDir.idEntries[k].ignore)
					{
						num3 = iconDir.idEntries[k].bytesInRes;
						id = (ushort)k;
						iconSize.Height = iconDir.idEntries[k].height;
						iconSize.Width = iconDir.idEntries[k].width;
					}
				}
			}
			for (int l = 0; l < num; l++)
			{
				if (iconDir.idEntries[l].ignore)
				{
					IconDump iconDump = new IconDump();
					stream.Seek(iconDir.idEntries[l].imageOffset, SeekOrigin.Begin);
					iconDump.data = new byte[iconDir.idEntries[l].bytesInRes];
					stream.Read(iconDump.data, 0, iconDump.data.Length);
					imageData[l] = iconDump;
					continue;
				}
				IconImage iconImage = new IconImage();
				BitmapInfoHeader iconHeader = default(BitmapInfoHeader);
				stream.Seek(iconDir.idEntries[l].imageOffset, SeekOrigin.Begin);
				byte[] array = new byte[iconDir.idEntries[l].bytesInRes];
				stream.Read(array, 0, array.Length);
				BinaryReader binaryReader2 = new BinaryReader(new MemoryStream(array));
				iconHeader.biSize = binaryReader2.ReadUInt32();
				iconHeader.biWidth = binaryReader2.ReadInt32();
				iconHeader.biHeight = binaryReader2.ReadInt32();
				iconHeader.biPlanes = binaryReader2.ReadUInt16();
				iconHeader.biBitCount = binaryReader2.ReadUInt16();
				iconHeader.biCompression = binaryReader2.ReadUInt32();
				iconHeader.biSizeImage = binaryReader2.ReadUInt32();
				iconHeader.biXPelsPerMeter = binaryReader2.ReadInt32();
				iconHeader.biYPelsPerMeter = binaryReader2.ReadInt32();
				iconHeader.biClrUsed = binaryReader2.ReadUInt32();
				iconHeader.biClrImportant = binaryReader2.ReadUInt32();
				iconImage.iconHeader = iconHeader;
				int num4 = iconHeader.biBitCount switch
				{
					1 => 2, 
					4 => 16, 
					8 => 256, 
					_ => 0, 
				};
				iconImage.iconColors = new uint[num4];
				for (int m = 0; m < num4; m++)
				{
					iconImage.iconColors[m] = binaryReader2.ReadUInt32();
				}
				int num5 = iconHeader.biHeight / 2;
				int num6 = (iconHeader.biWidth * iconHeader.biPlanes * iconHeader.biBitCount + 31 >> 5 << 2) * num5;
				iconImage.iconXOR = new byte[num6];
				int num7 = binaryReader2.Read(iconImage.iconXOR, 0, num6);
				if (num7 != num6)
				{
					throw new ArgumentException(global::Locale.GetText("{0} data length expected {1}, read {2}", "XOR", num6, num7), "stream");
				}
				int num8 = (((iconHeader.biWidth + 31) & -32) >> 3) * num5;
				iconImage.iconAND = new byte[num8];
				num7 = binaryReader2.Read(iconImage.iconAND, 0, num8);
				if (num7 != num8)
				{
					throw new ArgumentException(global::Locale.GetText("{0} data length expected {1}, read {2}", "AND", num8, num7), "stream");
				}
				imageData[l] = iconImage;
				binaryReader2.Dispose();
			}
			binaryReader.Dispose();
		}
	}
	/// <summary>Converts an <see cref="T:System.Drawing.Icon" /> object from one data type to another. Access this class through the <see cref="T:System.ComponentModel.TypeDescriptor" /> object.</summary>
	public class IconConverter : ExpandableObjectConverter
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.IconConverter" /> class.</summary>
		public IconConverter()
		{
		}

		/// <summary>Determines whether this <see cref="T:System.Drawing.IconConverter" /> can convert an instance of a specified type to an <see cref="T:System.Drawing.Icon" />, using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="sourceType">A <see cref="T:System.Type" /> that specifies the type you want to convert from.</param>
		/// <returns>This method returns <see langword="true" /> if this <see cref="T:System.Drawing.IconConverter" /> can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(byte[]))
			{
				return true;
			}
			return false;
		}

		/// <summary>Determines whether this <see cref="T:System.Drawing.IconConverter" /> can convert an <see cref="T:System.Drawing.Icon" /> to an instance of a specified type, using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> that specifies the type you want to convert to.</param>
		/// <returns>This method returns <see langword="true" /> if this <see cref="T:System.Drawing.IconConverter" /> can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(byte[]) || destinationType == typeof(string))
			{
				return true;
			}
			return false;
		}

		/// <summary>Converts a specified object to an <see cref="T:System.Drawing.Icon" />.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> that holds information about a specific culture.</param>
		/// <param name="value">The <see cref="T:System.Object" /> to be converted.</param>
		/// <returns>If this method succeeds, it returns the <see cref="T:System.Drawing.Icon" /> that it created by converting the specified object. Otherwise, it throws an exception.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion could not be performed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (!(value is byte[] buffer))
			{
				return base.ConvertFrom(context, culture, value);
			}
			return new Icon(new MemoryStream(buffer));
		}

		/// <summary>Converts an <see cref="T:System.Drawing.Icon" /> (or an object that can be cast to an <see cref="T:System.Drawing.Icon" />) to a specified type.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> object that specifies formatting conventions used by a particular culture.</param>
		/// <param name="value">The object to convert. This object should be of type icon or some type that can be cast to <see cref="T:System.Drawing.Icon" />.</param>
		/// <param name="destinationType">The type to convert the icon to.</param>
		/// <returns>This method returns the converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion could not be performed.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (value is Icon && destinationType == typeof(string))
			{
				return value.ToString();
			}
			if (value == null && destinationType == typeof(string))
			{
				return "(none)";
			}
			if (CanConvertTo(null, destinationType))
			{
				using (MemoryStream memoryStream = new MemoryStream())
				{
					((Icon)value).Save(memoryStream);
					return memoryStream.ToArray();
				}
			}
			return new NotSupportedException("IconConverter can not convert from " + value.GetType());
		}
	}
	/// <summary>An abstract base class that provides functionality for the <see cref="T:System.Drawing.Bitmap" /> and <see cref="T:System.Drawing.Imaging.Metafile" /> descended classes.</summary>
	[Serializable]
	[ImmutableObject(true)]
	[TypeConverter(typeof(ImageConverter))]
	[ComVisible(true)]
	[Editor("System.Drawing.Design.ImageEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	public abstract class Image : MarshalByRefObject, IDisposable, ICloneable, ISerializable
	{
		/// <summary>Provides a callback method for determining when the <see cref="M:System.Drawing.Image.GetThumbnailImage(System.Int32,System.Int32,System.Drawing.Image.GetThumbnailImageAbort,System.IntPtr)" /> method should prematurely cancel execution.</summary>
		/// <returns>This method returns <see langword="true" /> if it decides that the <see cref="M:System.Drawing.Image.GetThumbnailImage(System.Int32,System.Int32,System.Drawing.Image.GetThumbnailImageAbort,System.IntPtr)" /> method should prematurely stop execution; otherwise, it returns <see langword="false" />.</returns>
		public delegate bool GetThumbnailImageAbort();

		private object tag;

		internal IntPtr nativeObject = IntPtr.Zero;

		internal Stream stream;

		/// <summary>Gets attribute flags for the pixel data of this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>The integer representing a bitwise combination of <see cref="T:System.Drawing.Imaging.ImageFlags" /> for this <see cref="T:System.Drawing.Image" />.</returns>
		[Browsable(false)]
		public int Flags
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetImageFlags(nativeObject, out var flag));
				return flag;
			}
		}

		/// <summary>Gets an array of GUIDs that represent the dimensions of frames within this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>An array of GUIDs that specify the dimensions of frames within this <see cref="T:System.Drawing.Image" /> from most significant to least significant.</returns>
		[Browsable(false)]
		public Guid[] FrameDimensionsList
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipImageGetFrameDimensionsCount(nativeObject, out var count));
				Guid[] array = new Guid[count];
				GDIPlus.CheckStatus(GDIPlus.GdipImageGetFrameDimensionsList(nativeObject, array, count));
				return array;
			}
		}

		/// <summary>Gets the height, in pixels, of this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>The height, in pixels, of this <see cref="T:System.Drawing.Image" />.</returns>
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[DefaultValue(false)]
		public int Height
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetImageHeight(nativeObject, out var height));
				return (int)height;
			}
		}

		/// <summary>Gets the horizontal resolution, in pixels per inch, of this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>The horizontal resolution, in pixels per inch, of this <see cref="T:System.Drawing.Image" />.</returns>
		public float HorizontalResolution
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetImageHorizontalResolution(nativeObject, out var resolution));
				return resolution;
			}
		}

		/// <summary>Gets or sets the color palette used for this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Imaging.ColorPalette" /> that represents the color palette used for this <see cref="T:System.Drawing.Image" />.</returns>
		[Browsable(false)]
		public ColorPalette Palette
		{
			get
			{
				return retrieveGDIPalette();
			}
			set
			{
				storeGDIPalette(value);
			}
		}

		/// <summary>Gets the width and height of this image.</summary>
		/// <returns>A <see cref="T:System.Drawing.SizeF" /> structure that represents the width and height of this <see cref="T:System.Drawing.Image" />.</returns>
		public SizeF PhysicalDimension
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetImageDimension(nativeObject, out var width, out var height));
				return new SizeF(width, height);
			}
		}

		/// <summary>Gets the pixel format for this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Imaging.PixelFormat" /> that represents the pixel format for this <see cref="T:System.Drawing.Image" />.</returns>
		public PixelFormat PixelFormat
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetImagePixelFormat(nativeObject, out var format));
				return format;
			}
		}

		/// <summary>Gets IDs of the property items stored in this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>An array of the property IDs, one for each property item stored in this image.</returns>
		[Browsable(false)]
		public int[] PropertyIdList
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPropertyCount(nativeObject, out var propNumbers));
				int[] array = new int[propNumbers];
				GDIPlus.CheckStatus(GDIPlus.GdipGetPropertyIdList(nativeObject, propNumbers, array));
				return array;
			}
		}

		/// <summary>Gets all the property items (pieces of metadata) stored in this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.Imaging.PropertyItem" /> objects, one for each property item stored in the image.</returns>
		[Browsable(false)]
		public PropertyItem[] PropertyItems
		{
			get
			{
				GdipPropertyItem structure = default(GdipPropertyItem);
				GDIPlus.CheckStatus(GDIPlus.GdipGetPropertySize(nativeObject, out var bufferSize, out var propNumbers));
				PropertyItem[] array = new PropertyItem[propNumbers];
				if (propNumbers == 0)
				{
					return array;
				}
				IntPtr intPtr = Marshal.AllocHGlobal(bufferSize * propNumbers);
				try
				{
					GDIPlus.CheckStatus(GDIPlus.GdipGetAllPropertyItems(nativeObject, bufferSize, propNumbers, intPtr));
					int num = Marshal.SizeOf(structure);
					IntPtr ptr = intPtr;
					int num2 = 0;
					while (num2 < propNumbers)
					{
						structure = (GdipPropertyItem)Marshal.PtrToStructure(ptr, typeof(GdipPropertyItem));
						array[num2] = new PropertyItem();
						GdipPropertyItem.MarshalTo(structure, array[num2]);
						num2++;
						ptr = new IntPtr(ptr.ToInt64() + num);
					}
					return array;
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		/// <summary>Gets the file format of this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Imaging.ImageFormat" /> that represents the file format of this <see cref="T:System.Drawing.Image" />.</returns>
		public ImageFormat RawFormat
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetImageRawFormat(nativeObject, out var format));
				return new ImageFormat(format);
			}
		}

		/// <summary>Gets the width and height, in pixels, of this image.</summary>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure that represents the width and height, in pixels, of this image.</returns>
		public Size Size => new Size(Width, Height);

		/// <summary>Gets or sets an object that provides additional data about the image.</summary>
		/// <returns>The <see cref="T:System.Object" /> that provides additional data about the image.</returns>
		[DefaultValue(null)]
		[Localizable(false)]
		[Bindable(true)]
		[TypeConverter(typeof(StringConverter))]
		public object Tag
		{
			get
			{
				return tag;
			}
			set
			{
				tag = value;
			}
		}

		/// <summary>Gets the vertical resolution, in pixels per inch, of this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>The vertical resolution, in pixels per inch, of this <see cref="T:System.Drawing.Image" />.</returns>
		public float VerticalResolution
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetImageVerticalResolution(nativeObject, out var resolution));
				return resolution;
			}
		}

		/// <summary>Gets the width, in pixels, of this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>The width, in pixels, of this <see cref="T:System.Drawing.Image" />.</returns>
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[DefaultValue(false)]
		public int Width
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetImageWidth(nativeObject, out var width));
				return (int)width;
			}
		}

		internal IntPtr NativeObject
		{
			get
			{
				return nativeObject;
			}
			set
			{
				nativeObject = value;
			}
		}

		internal IntPtr nativeImage => nativeObject;

		internal Image()
		{
		}

		internal Image(SerializationInfo info, StreamingContext context)
		{
			SerializationInfoEnumerator enumerator = info.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SerializationEntry current = enumerator.Current;
				if (string.Compare(current.Name, "Data", ignoreCase: true) != 0)
				{
					continue;
				}
				byte[] array = (byte[])current.Value;
				if (array != null)
				{
					MemoryStream memoryStream = new MemoryStream(array);
					nativeObject = InitFromStream(memoryStream);
					if (GDIPlus.RunningOnWindows())
					{
						stream = memoryStream;
					}
				}
			}
		}

		/// <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the target object.</summary>
		/// <param name="si">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object to populate with data.</param>
		/// <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this serialization.</param>
		void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context)
		{
			using MemoryStream memoryStream = new MemoryStream();
			if (RawFormat.Equals(ImageFormat.Icon))
			{
				Save(memoryStream, ImageFormat.Png);
			}
			else
			{
				Save(memoryStream, RawFormat);
			}
			si.AddValue("Data", memoryStream.ToArray());
		}

		/// <summary>Creates an <see cref="T:System.Drawing.Image" /> from the specified file.</summary>
		/// <param name="filename">A string that contains the name of the file from which to create the <see cref="T:System.Drawing.Image" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Image" /> this method creates.</returns>
		/// <exception cref="T:System.OutOfMemoryException">The file does not have a valid image format.  
		///  -or-  
		///  GDI+ does not support the pixel format of the file.</exception>
		/// <exception cref="T:System.IO.FileNotFoundException">The specified file does not exist.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="filename" /> is a <see cref="T:System.Uri" />.</exception>
		public static Image FromFile(string filename)
		{
			return FromFile(filename, useEmbeddedColorManagement: false);
		}

		/// <summary>Creates an <see cref="T:System.Drawing.Image" /> from the specified file using embedded color management information in that file.</summary>
		/// <param name="filename">A string that contains the name of the file from which to create the <see cref="T:System.Drawing.Image" />.</param>
		/// <param name="useEmbeddedColorManagement">Set to <see langword="true" /> to use color management information embedded in the image file; otherwise, <see langword="false" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Image" /> this method creates.</returns>
		/// <exception cref="T:System.OutOfMemoryException">The file does not have a valid image format.  
		///  -or-  
		///  GDI+ does not support the pixel format of the file.</exception>
		/// <exception cref="T:System.IO.FileNotFoundException">The specified file does not exist.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="filename" /> is a <see cref="T:System.Uri" />.</exception>
		public static Image FromFile(string filename, bool useEmbeddedColorManagement)
		{
			if (!File.Exists(filename))
			{
				throw new FileNotFoundException(filename);
			}
			IntPtr image;
			Status status = ((!useEmbeddedColorManagement) ? GDIPlus.GdipLoadImageFromFile(filename, out image) : GDIPlus.GdipLoadImageFromFileICM(filename, out image));
			GDIPlus.CheckStatus(status);
			return CreateFromHandle(image);
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Bitmap" /> from a handle to a GDI bitmap.</summary>
		/// <param name="hbitmap">The GDI bitmap handle from which to create the <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Bitmap" /> this method creates.</returns>
		public static Bitmap FromHbitmap(IntPtr hbitmap)
		{
			return FromHbitmap(hbitmap, IntPtr.Zero);
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Bitmap" /> from a handle to a GDI bitmap and a handle to a GDI palette.</summary>
		/// <param name="hbitmap">The GDI bitmap handle from which to create the <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="hpalette">A handle to a GDI palette used to define the bitmap colors if the bitmap specified in the <paramref name="hbitmap" /> parameter is not a device-independent bitmap (DIB).</param>
		/// <returns>The <see cref="T:System.Drawing.Bitmap" /> this method creates.</returns>
		public static Bitmap FromHbitmap(IntPtr hbitmap, IntPtr hpalette)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateBitmapFromHBITMAP(hbitmap, hpalette, out var image));
			return new Bitmap(image);
		}

		/// <summary>Creates an <see cref="T:System.Drawing.Image" /> from the specified data stream.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Image" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Image" /> this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">The stream does not have a valid image format  
		///  -or-  
		///  <paramref name="stream" /> is <see langword="null" />.</exception>
		public static Image FromStream(Stream stream)
		{
			return LoadFromStream(stream, keepAlive: false);
		}

		/// <summary>Creates an <see cref="T:System.Drawing.Image" /> from the specified data stream, optionally using embedded color management information in that stream.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Image" />.</param>
		/// <param name="useEmbeddedColorManagement">
		///   <see langword="true" /> to use color management information embedded in the data stream; otherwise, <see langword="false" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Image" /> this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">The stream does not have a valid image format  
		///  -or-  
		///  <paramref name="stream" /> is <see langword="null" />.</exception>
		[System.MonoLimitation("useEmbeddedColorManagement  isn't supported.")]
		public static Image FromStream(Stream stream, bool useEmbeddedColorManagement)
		{
			return LoadFromStream(stream, keepAlive: false);
		}

		/// <summary>Creates an <see cref="T:System.Drawing.Image" /> from the specified data stream, optionally using embedded color management information and validating the image data.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Image" />.</param>
		/// <param name="useEmbeddedColorManagement">
		///   <see langword="true" /> to use color management information embedded in the data stream; otherwise, <see langword="false" />.</param>
		/// <param name="validateImageData">
		///   <see langword="true" /> to validate the image data; otherwise, <see langword="false" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Image" /> this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">The stream does not have a valid image format.</exception>
		[System.MonoLimitation("useEmbeddedColorManagement  and validateImageData aren't supported.")]
		public static Image FromStream(Stream stream, bool useEmbeddedColorManagement, bool validateImageData)
		{
			return LoadFromStream(stream, keepAlive: false);
		}

		internal static Image LoadFromStream(Stream stream, bool keepAlive)
		{
			if (stream == null)
			{
				throw new ArgumentNullException("stream");
			}
			Image image = CreateFromHandle(InitFromStream(stream));
			if (keepAlive && GDIPlus.RunningOnWindows())
			{
				image.stream = stream;
			}
			return image;
		}

		internal static Image CreateImageObject(IntPtr nativeImage)
		{
			return CreateFromHandle(nativeImage);
		}

		internal static Image CreateFromHandle(IntPtr handle)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipGetImageType(handle, out var type));
			return type switch
			{
				ImageType.Bitmap => new Bitmap(handle), 
				ImageType.Metafile => new Metafile(handle), 
				_ => throw new NotSupportedException(global::Locale.GetText("Unknown image type.")), 
			};
		}

		/// <summary>Returns the color depth, in number of bits per pixel, of the specified pixel format.</summary>
		/// <param name="pixfmt">The <see cref="T:System.Drawing.Imaging.PixelFormat" /> member that specifies the format for which to find the size.</param>
		/// <returns>The color depth of the specified pixel format.</returns>
		public static int GetPixelFormatSize(PixelFormat pixfmt)
		{
			int result = 0;
			switch (pixfmt)
			{
			case PixelFormat.Format16bppRgb555:
			case PixelFormat.Format16bppRgb565:
			case PixelFormat.Format16bppArgb1555:
			case PixelFormat.Format16bppGrayScale:
				result = 16;
				break;
			case PixelFormat.Format1bppIndexed:
				result = 1;
				break;
			case PixelFormat.Format24bppRgb:
				result = 24;
				break;
			case PixelFormat.Format32bppRgb:
			case PixelFormat.Format32bppPArgb:
			case PixelFormat.Format32bppArgb:
				result = 32;
				break;
			case PixelFormat.Format48bppRgb:
				result = 48;
				break;
			case PixelFormat.Format4bppIndexed:
				result = 4;
				break;
			case PixelFormat.Format64bppPArgb:
			case PixelFormat.Format64bppArgb:
				result = 64;
				break;
			case PixelFormat.Format8bppIndexed:
				result = 8;
				break;
			}
			return result;
		}

		/// <summary>Returns a value that indicates whether the pixel format for this <see cref="T:System.Drawing.Image" /> contains alpha information.</summary>
		/// <param name="pixfmt">The <see cref="T:System.Drawing.Imaging.PixelFormat" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="pixfmt" /> contains alpha information; otherwise, <see langword="false" />.</returns>
		public static bool IsAlphaPixelFormat(PixelFormat pixfmt)
		{
			bool result = false;
			switch (pixfmt)
			{
			case PixelFormat.Format16bppArgb1555:
			case PixelFormat.Format32bppPArgb:
			case PixelFormat.Format64bppPArgb:
			case PixelFormat.Format32bppArgb:
			case PixelFormat.Format64bppArgb:
				result = true;
				break;
			case PixelFormat.Format16bppRgb555:
			case PixelFormat.Format16bppRgb565:
			case PixelFormat.Format24bppRgb:
			case PixelFormat.Format32bppRgb:
			case PixelFormat.Format1bppIndexed:
			case PixelFormat.Format4bppIndexed:
			case PixelFormat.Format8bppIndexed:
			case PixelFormat.Format16bppGrayScale:
			case PixelFormat.Format48bppRgb:
				result = false;
				break;
			}
			return result;
		}

		/// <summary>Returns a value that indicates whether the pixel format is 32 bits per pixel.</summary>
		/// <param name="pixfmt">The <see cref="T:System.Drawing.Imaging.PixelFormat" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="pixfmt" /> is canonical; otherwise, <see langword="false" />.</returns>
		public static bool IsCanonicalPixelFormat(PixelFormat pixfmt)
		{
			return (pixfmt & PixelFormat.Canonical) != 0;
		}

		/// <summary>Returns a value that indicates whether the pixel format is 64 bits per pixel.</summary>
		/// <param name="pixfmt">The <see cref="T:System.Drawing.Imaging.PixelFormat" /> enumeration to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="pixfmt" /> is extended; otherwise, <see langword="false" />.</returns>
		public static bool IsExtendedPixelFormat(PixelFormat pixfmt)
		{
			return (pixfmt & PixelFormat.Extended) != 0;
		}

		internal static IntPtr InitFromStream(Stream stream)
		{
			if (stream == null)
			{
				throw new ArgumentException("stream");
			}
			if (!stream.CanSeek)
			{
				byte[] array = new byte[256];
				int num = 0;
				int num2;
				do
				{
					if (array.Length < num + 256)
					{
						byte[] array2 = new byte[array.Length * 2];
						Array.Copy(array, array2, array.Length);
						array = array2;
					}
					num2 = stream.Read(array, num, 256);
					num += num2;
				}
				while (num2 != 0);
				stream = new MemoryStream(array, 0, num);
			}
			Status status;
			IntPtr image;
			if (GDIPlus.RunningOnUnix())
			{
				GDIPlus.GdiPlusStreamHelper gdiPlusStreamHelper = new GDIPlus.GdiPlusStreamHelper(stream, seekToOrigin: true);
				status = GDIPlus.GdipLoadImageFromDelegate_linux(gdiPlusStreamHelper.GetHeaderDelegate, gdiPlusStreamHelper.GetBytesDelegate, gdiPlusStreamHelper.PutBytesDelegate, gdiPlusStreamHelper.SeekDelegate, gdiPlusStreamHelper.CloseDelegate, gdiPlusStreamHelper.SizeDelegate, out image);
			}
			else
			{
				status = GDIPlus.GdipLoadImageFromStream(new ComIStreamWrapper(stream), out image);
			}
			if (status != Status.Ok)
			{
				return IntPtr.Zero;
			}
			return image;
		}

		/// <summary>Gets the bounds of the image in the specified unit.</summary>
		/// <param name="pageUnit">One of the <see cref="T:System.Drawing.GraphicsUnit" /> values indicating the unit of measure for the bounding rectangle.</param>
		/// <returns>The <see cref="T:System.Drawing.RectangleF" /> that represents the bounds of the image, in the specified unit.</returns>
		public RectangleF GetBounds(ref GraphicsUnit pageUnit)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipGetImageBounds(nativeObject, out var source, ref pageUnit));
			return source;
		}

		/// <summary>Returns information about the parameters supported by the specified image encoder.</summary>
		/// <param name="encoder">A GUID that specifies the image encoder.</param>
		/// <returns>An <see cref="T:System.Drawing.Imaging.EncoderParameters" /> that contains an array of <see cref="T:System.Drawing.Imaging.EncoderParameter" /> objects. Each <see cref="T:System.Drawing.Imaging.EncoderParameter" /> contains information about one of the parameters supported by the specified image encoder.</returns>
		public EncoderParameters GetEncoderParameterList(Guid encoder)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipGetEncoderParameterListSize(nativeObject, ref encoder, out var size));
			IntPtr intPtr = Marshal.AllocHGlobal((int)size);
			try
			{
				Status status = GDIPlus.GdipGetEncoderParameterList(nativeObject, ref encoder, size, intPtr);
				EncoderParameters result = EncoderParameters.ConvertFromMemory(intPtr);
				GDIPlus.CheckStatus(status);
				return result;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Returns the number of frames of the specified dimension.</summary>
		/// <param name="dimension">A <see cref="T:System.Drawing.Imaging.FrameDimension" /> that specifies the identity of the dimension type.</param>
		/// <returns>The number of frames in the specified dimension.</returns>
		public int GetFrameCount(FrameDimension dimension)
		{
			Guid guidDimension = dimension.Guid;
			GDIPlus.CheckStatus(GDIPlus.GdipImageGetFrameCount(nativeObject, ref guidDimension, out var count));
			return (int)count;
		}

		/// <summary>Gets the specified property item from this <see cref="T:System.Drawing.Image" />.</summary>
		/// <param name="propid">The ID of the property item to get.</param>
		/// <returns>The <see cref="T:System.Drawing.Imaging.PropertyItem" /> this method gets.</returns>
		/// <exception cref="T:System.ArgumentException">The image format of this image does not support property items.</exception>
		public PropertyItem GetPropertyItem(int propid)
		{
			PropertyItem propertyItem = new PropertyItem();
			GDIPlus.CheckStatus(GDIPlus.GdipGetPropertyItemSize(nativeObject, propid, out var propertySize));
			IntPtr intPtr = Marshal.AllocHGlobal(propertySize);
			try
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPropertyItem(nativeObject, propid, propertySize, intPtr));
				GdipPropertyItem.MarshalTo((GdipPropertyItem)Marshal.PtrToStructure(intPtr, typeof(GdipPropertyItem)), propertyItem);
				return propertyItem;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Returns a thumbnail for this <see cref="T:System.Drawing.Image" />.</summary>
		/// <param name="thumbWidth">The width, in pixels, of the requested thumbnail image.</param>
		/// <param name="thumbHeight">The height, in pixels, of the requested thumbnail image.</param>
		/// <param name="callback">A <see cref="T:System.Drawing.Image.GetThumbnailImageAbort" /> delegate.  
		///  Note You must create a delegate and pass a reference to the delegate as the <paramref name="callback" /> parameter, but the delegate is not used.</param>
		/// <param name="callbackData">Must be <see cref="F:System.IntPtr.Zero" />.</param>
		/// <returns>An <see cref="T:System.Drawing.Image" /> that represents the thumbnail.</returns>
		public Image GetThumbnailImage(int thumbWidth, int thumbHeight, GetThumbnailImageAbort callback, IntPtr callbackData)
		{
			if (thumbWidth <= 0 || thumbHeight <= 0)
			{
				throw new OutOfMemoryException("Invalid thumbnail size");
			}
			Image image = new Bitmap(thumbWidth, thumbHeight);
			using Graphics graphics = Graphics.FromImage(image);
			GDIPlus.CheckStatus(GDIPlus.GdipDrawImageRectRectI(graphics.nativeObject, nativeObject, 0, 0, thumbWidth, thumbHeight, 0, 0, Width, Height, GraphicsUnit.Pixel, IntPtr.Zero, null, IntPtr.Zero));
			return image;
		}

		/// <summary>Removes the specified property item from this <see cref="T:System.Drawing.Image" />.</summary>
		/// <param name="propid">The ID of the property item to remove.</param>
		/// <exception cref="T:System.ArgumentException">The image does not contain the requested property item.  
		///  -or-  
		///  The image format for this image does not support property items.</exception>
		public void RemovePropertyItem(int propid)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipRemovePropertyItem(nativeObject, propid));
		}

		/// <summary>Rotates, flips, or rotates and flips the <see cref="T:System.Drawing.Image" />.</summary>
		/// <param name="rotateFlipType">A <see cref="T:System.Drawing.RotateFlipType" /> member that specifies the type of rotation and flip to apply to the image.</param>
		public void RotateFlip(RotateFlipType rotateFlipType)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipImageRotateFlip(nativeObject, rotateFlipType));
		}

		internal ImageCodecInfo findEncoderForFormat(ImageFormat format)
		{
			ImageCodecInfo[] imageEncoders = ImageCodecInfo.GetImageEncoders();
			ImageCodecInfo result = null;
			if (format.Guid.Equals(ImageFormat.MemoryBmp.Guid))
			{
				format = ImageFormat.Png;
			}
			for (int i = 0; i < imageEncoders.Length; i++)
			{
				if (imageEncoders[i].FormatID.Equals(format.Guid))
				{
					result = imageEncoders[i];
					break;
				}
			}
			return result;
		}

		/// <summary>Saves this <see cref="T:System.Drawing.Image" /> to the specified file or stream.</summary>
		/// <param name="filename">A string that contains the name of the file to which to save this <see cref="T:System.Drawing.Image" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="filename" /> is <see langword="null." /></exception>
		/// <exception cref="T:System.Runtime.InteropServices.ExternalException">The image was saved with the wrong image format.  
		///  -or-  
		///  The image was saved to the same file it was created from.</exception>
		public void Save(string filename)
		{
			Save(filename, RawFormat);
		}

		/// <summary>Saves this <see cref="T:System.Drawing.Image" /> to the specified file in the specified format.</summary>
		/// <param name="filename">A string that contains the name of the file to which to save this <see cref="T:System.Drawing.Image" />.</param>
		/// <param name="format">The <see cref="T:System.Drawing.Imaging.ImageFormat" /> for this <see cref="T:System.Drawing.Image" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="filename" /> or <paramref name="format" /> is <see langword="null." /></exception>
		/// <exception cref="T:System.Runtime.InteropServices.ExternalException">The image was saved with the wrong image format.  
		///  -or-  
		///  The image was saved to the same file it was created from.</exception>
		public void Save(string filename, ImageFormat format)
		{
			ImageCodecInfo imageCodecInfo = findEncoderForFormat(format);
			if (imageCodecInfo == null)
			{
				imageCodecInfo = findEncoderForFormat(RawFormat);
				if (imageCodecInfo == null)
				{
					throw new ArgumentException(global::Locale.GetText("No codec available for saving format '{0}'.", format.Guid), "format");
				}
			}
			Save(filename, imageCodecInfo, null);
		}

		/// <summary>Saves this <see cref="T:System.Drawing.Image" /> to the specified file, with the specified encoder and image-encoder parameters.</summary>
		/// <param name="filename">A string that contains the name of the file to which to save this <see cref="T:System.Drawing.Image" />.</param>
		/// <param name="encoder">The <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> for this <see cref="T:System.Drawing.Image" />.</param>
		/// <param name="encoderParams">An <see cref="T:System.Drawing.Imaging.EncoderParameters" /> to use for this <see cref="T:System.Drawing.Image" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="filename" /> or <paramref name="encoder" /> is <see langword="null." /></exception>
		/// <exception cref="T:System.Runtime.InteropServices.ExternalException">The image was saved with the wrong image format.  
		///  -or-  
		///  The image was saved to the same file it was created from.</exception>
		public void Save(string filename, ImageCodecInfo encoder, EncoderParameters encoderParams)
		{
			Guid encoderClsID = encoder.Clsid;
			Status status;
			if (encoderParams == null)
			{
				status = GDIPlus.GdipSaveImageToFile(nativeObject, filename, ref encoderClsID, IntPtr.Zero);
			}
			else
			{
				IntPtr intPtr = encoderParams.ConvertToMemory();
				status = GDIPlus.GdipSaveImageToFile(nativeObject, filename, ref encoderClsID, intPtr);
				Marshal.FreeHGlobal(intPtr);
			}
			GDIPlus.CheckStatus(status);
		}

		/// <summary>Saves this image to the specified stream in the specified format.</summary>
		/// <param name="stream">The <see cref="T:System.IO.Stream" /> where the image will be saved.</param>
		/// <param name="format">An <see cref="T:System.Drawing.Imaging.ImageFormat" /> that specifies the format of the saved image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="stream" /> or <paramref name="format" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Runtime.InteropServices.ExternalException">The image was saved with the wrong image format</exception>
		public void Save(Stream stream, ImageFormat format)
		{
			ImageCodecInfo imageCodecInfo = findEncoderForFormat(format);
			if (imageCodecInfo == null)
			{
				throw new ArgumentException("No codec available for format:" + format.Guid);
			}
			Save(stream, imageCodecInfo, null);
		}

		/// <summary>Saves this image to the specified stream, with the specified encoder and image encoder parameters.</summary>
		/// <param name="stream">The <see cref="T:System.IO.Stream" /> where the image will be saved.</param>
		/// <param name="encoder">The <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> for this <see cref="T:System.Drawing.Image" />.</param>
		/// <param name="encoderParams">An <see cref="T:System.Drawing.Imaging.EncoderParameters" /> that specifies parameters used by the image encoder.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="stream" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Runtime.InteropServices.ExternalException">The image was saved with the wrong image format.</exception>
		public void Save(Stream stream, ImageCodecInfo encoder, EncoderParameters encoderParams)
		{
			Guid clsidEncoder = encoder.Clsid;
			IntPtr intPtr = encoderParams?.ConvertToMemory() ?? IntPtr.Zero;
			Status status;
			try
			{
				if (GDIPlus.RunningOnUnix())
				{
					GDIPlus.GdiPlusStreamHelper gdiPlusStreamHelper = new GDIPlus.GdiPlusStreamHelper(stream, seekToOrigin: false);
					status = GDIPlus.GdipSaveImageToDelegate_linux(nativeObject, gdiPlusStreamHelper.GetBytesDelegate, gdiPlusStreamHelper.PutBytesDelegate, gdiPlusStreamHelper.SeekDelegate, gdiPlusStreamHelper.CloseDelegate, gdiPlusStreamHelper.SizeDelegate, ref clsidEncoder, intPtr);
				}
				else
				{
					status = GDIPlus.GdipSaveImageToStream(new HandleRef(this, nativeObject), new ComIStreamWrapper(stream), ref clsidEncoder, new HandleRef(encoderParams, intPtr));
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
			GDIPlus.CheckStatus(status);
		}

		/// <summary>Adds a frame to the file or stream specified in a previous call to the <see cref="Overload:System.Drawing.Image.Save" /> method. Use this method to save selected frames from a multiple-frame image to another multiple-frame image.</summary>
		/// <param name="encoderParams">An <see cref="T:System.Drawing.Imaging.EncoderParameters" /> that holds parameters required by the image encoder that is used by the save-add operation.</param>
		public void SaveAdd(EncoderParameters encoderParams)
		{
			IntPtr intPtr = encoderParams.ConvertToMemory();
			Status status = GDIPlus.GdipSaveAdd(nativeObject, intPtr);
			Marshal.FreeHGlobal(intPtr);
			GDIPlus.CheckStatus(status);
		}

		/// <summary>Adds a frame to the file or stream specified in a previous call to the <see cref="Overload:System.Drawing.Image.Save" /> method.</summary>
		/// <param name="image">An <see cref="T:System.Drawing.Image" /> that contains the frame to add.</param>
		/// <param name="encoderParams">An <see cref="T:System.Drawing.Imaging.EncoderParameters" /> that holds parameters required by the image encoder that is used by the save-add operation.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void SaveAdd(Image image, EncoderParameters encoderParams)
		{
			IntPtr intPtr = encoderParams.ConvertToMemory();
			Status status = GDIPlus.GdipSaveAddImage(nativeObject, image.NativeObject, intPtr);
			Marshal.FreeHGlobal(intPtr);
			GDIPlus.CheckStatus(status);
		}

		/// <summary>Selects the frame specified by the dimension and index.</summary>
		/// <param name="dimension">A <see cref="T:System.Drawing.Imaging.FrameDimension" /> that specifies the identity of the dimension type.</param>
		/// <param name="frameIndex">The index of the active frame.</param>
		/// <returns>Always returns 0.</returns>
		public int SelectActiveFrame(FrameDimension dimension, int frameIndex)
		{
			Guid guidDimension = dimension.Guid;
			GDIPlus.CheckStatus(GDIPlus.GdipImageSelectActiveFrame(nativeObject, ref guidDimension, frameIndex));
			return frameIndex;
		}

		/// <summary>Stores a property item (piece of metadata) in this <see cref="T:System.Drawing.Image" />.</summary>
		/// <param name="propitem">The <see cref="T:System.Drawing.Imaging.PropertyItem" /> to be stored.</param>
		/// <exception cref="T:System.ArgumentException">The image format of this image does not support property items.</exception>
		public unsafe void SetPropertyItem(PropertyItem propitem)
		{
			if (propitem == null)
			{
				throw new ArgumentNullException("propitem");
			}
			int num = Marshal.SizeOf(propitem.Value[0]) * propitem.Value.Length;
			IntPtr intPtr = Marshal.AllocHGlobal(num);
			try
			{
				GdipPropertyItem gdipPropertyItem = new GdipPropertyItem
				{
					id = propitem.Id,
					len = propitem.Len,
					type = propitem.Type
				};
				Marshal.Copy(propitem.Value, 0, intPtr, num);
				gdipPropertyItem.value = intPtr;
				GDIPlus.CheckStatus(GDIPlus.GdipSetPropertyItem(nativeObject, &gdipPropertyItem));
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		internal ColorPalette retrieveGDIPalette()
		{
			ColorPalette colorPalette = new ColorPalette();
			GDIPlus.CheckStatus(GDIPlus.GdipGetImagePaletteSize(nativeObject, out var size));
			IntPtr intPtr = Marshal.AllocHGlobal(size);
			try
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetImagePalette(nativeObject, intPtr, size));
				colorPalette.ConvertFromMemory(intPtr);
				return colorPalette;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		internal void storeGDIPalette(ColorPalette palette)
		{
			if (palette == null)
			{
				throw new ArgumentNullException("palette");
			}
			IntPtr intPtr = palette.ConvertToMemory();
			if (intPtr == IntPtr.Zero)
			{
				return;
			}
			try
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetImagePalette(nativeObject, intPtr));
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Image" />.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Image()
		{
			Dispose(disposing: false);
		}

		/// <summary>Releases the unmanaged resources used by the <see cref="T:System.Drawing.Image" /> and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///   <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		protected virtual void Dispose(bool disposing)
		{
			if (GDIPlus.GdiPlusToken != 0L && nativeObject != IntPtr.Zero)
			{
				Status status = GDIPlus.GdipDisposeImage(nativeObject);
				if (stream != null)
				{
					stream.Dispose();
					stream = null;
				}
				nativeObject = IntPtr.Zero;
				GDIPlus.CheckStatus(status);
			}
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Image" /> this method creates, cast as an object.</returns>
		public object Clone()
		{
			if (GDIPlus.RunningOnWindows() && stream != null)
			{
				return CloneFromStream();
			}
			IntPtr imageclone = IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipCloneImage(NativeObject, out imageclone));
			if (this is Bitmap)
			{
				return new Bitmap(imageclone);
			}
			return new Metafile(imageclone);
		}

		private object CloneFromStream()
		{
			MemoryStream memoryStream = new MemoryStream(new byte[stream.Length]);
			int num = (int)((stream.Length < 4096) ? stream.Length : 4096);
			byte[] buffer = new byte[num];
			stream.Position = 0L;
			do
			{
				num = stream.Read(buffer, 0, num);
				memoryStream.Write(buffer, 0, num);
			}
			while (num == 4096);
			IntPtr zero = IntPtr.Zero;
			zero = InitFromStream(memoryStream);
			if (this is Bitmap)
			{
				return new Bitmap(zero, memoryStream);
			}
			return new Metafile(zero, memoryStream);
		}
	}
	internal class AnimateEventArgs : EventArgs
	{
		private int frameCount;

		private int activeFrame;

		private Thread thread;

		public Thread RunThread
		{
			get
			{
				return thread;
			}
			set
			{
				thread = value;
			}
		}

		public AnimateEventArgs(Image image)
		{
			frameCount = image.GetFrameCount(FrameDimension.Time);
		}

		public int GetNextFrame()
		{
			if (activeFrame < frameCount - 1)
			{
				activeFrame++;
			}
			else
			{
				activeFrame = 0;
			}
			return activeFrame;
		}
	}
	/// <summary>Animates an image that has time-based frames.</summary>
	public sealed class ImageAnimator
	{
		private static Hashtable ht = Hashtable.Synchronized(new Hashtable());

		private ImageAnimator()
		{
		}

		/// <summary>Displays a multiple-frame image as an animation.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object to animate.</param>
		/// <param name="onFrameChangedHandler">An <see langword="EventHandler" /> object that specifies the method that is called when the animation frame changes.</param>
		public static void Animate(Image image, EventHandler onFrameChangedHandler)
		{
			if (CanAnimate(image) && !ht.ContainsKey(image))
			{
				byte[] value = image.GetPropertyItem(20736).Value;
				int[] array = new int[value.Length >> 2];
				int num = 0;
				int num2 = 0;
				while (num < value.Length)
				{
					int num3 = BitConverter.ToInt32(value, num) * 10;
					array[num2] = ((num3 < 100) ? 100 : num3);
					num += 4;
					num2++;
				}
				AnimateEventArgs e = new AnimateEventArgs(image);
				Thread thread = new Thread(new WorkerThread(onFrameChangedHandler, e, array).LoopHandler);
				thread.IsBackground = true;
				e.RunThread = thread;
				ht.Add(image, e);
				thread.Start();
			}
		}

		/// <summary>Returns a Boolean value indicating whether the specified image contains time-based frames.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified image contains time-based frames; otherwise, <see langword="false" />.</returns>
		public static bool CanAnimate(Image image)
		{
			if (image == null)
			{
				return false;
			}
			int num = image.FrameDimensionsList.Length;
			if (num < 1)
			{
				return false;
			}
			for (int i = 0; i < num; i++)
			{
				if (image.FrameDimensionsList[i].Equals(FrameDimension.Time.Guid))
				{
					return image.GetFrameCount(FrameDimension.Time) > 1;
				}
			}
			return false;
		}

		/// <summary>Terminates a running animation.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object to stop animating.</param>
		/// <param name="onFrameChangedHandler">An <see langword="EventHandler" /> object that specifies the method that is called when the animation frame changes.</param>
		public static void StopAnimate(Image image, EventHandler onFrameChangedHandler)
		{
			if (image != null && ht.ContainsKey(image))
			{
				((AnimateEventArgs)ht[image]).RunThread.Abort();
				ht.Remove(image);
			}
		}

		/// <summary>Advances the frame in all images currently being animated. The new frame is drawn the next time the image is rendered.</summary>
		public static void UpdateFrames()
		{
			foreach (Image key in ht.Keys)
			{
				UpdateImageFrame(key);
			}
		}

		/// <summary>Advances the frame in the specified image. The new frame is drawn the next time the image is rendered. This method applies only to images with time-based frames.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object for which to update frames.</param>
		public static void UpdateFrames(Image image)
		{
			if (image != null && ht.ContainsKey(image))
			{
				UpdateImageFrame(image);
			}
		}

		private static void UpdateImageFrame(Image image)
		{
			AnimateEventArgs e = (AnimateEventArgs)ht[image];
			image.SelectActiveFrame(FrameDimension.Time, e.GetNextFrame());
		}
	}
	internal class WorkerThread
	{
		private EventHandler frameChangeHandler;

		private AnimateEventArgs animateEventArgs;

		private int[] delay;

		public WorkerThread(EventHandler frmChgHandler, AnimateEventArgs aniEvtArgs, int[] delay)
		{
			frameChangeHandler = frmChgHandler;
			animateEventArgs = aniEvtArgs;
			this.delay = delay;
		}

		public void LoopHandler()
		{
			try
			{
				int num = 0;
				while (true)
				{
					Thread.Sleep(delay[num++]);
					frameChangeHandler(null, animateEventArgs);
					if (num == delay.Length)
					{
						num = 0;
					}
				}
			}
			catch (ThreadAbortException)
			{
				Thread.ResetAbort();
			}
		}
	}
	/// <summary>
	///   <see cref="T:System.Drawing.ImageConverter" /> is a class that can be used to convert <see cref="T:System.Drawing.Image" /> objects from one data type to another. Access this class through the <see cref="T:System.ComponentModel.TypeDescriptor" /> object.</summary>
	public class ImageConverter : TypeConverter
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.ImageConverter" /> class.</summary>
		public ImageConverter()
		{
		}

		/// <summary>Determines whether this <see cref="T:System.Drawing.ImageConverter" /> can convert an instance of a specified type to an <see cref="T:System.Drawing.Image" />, using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="sourceType">A <see cref="T:System.Type" /> that specifies the type you want to convert from.</param>
		/// <returns>This method returns <see langword="true" /> if this <see cref="T:System.Drawing.ImageConverter" /> can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(byte[]))
			{
				return true;
			}
			return false;
		}

		/// <summary>Determines whether this <see cref="T:System.Drawing.ImageConverter" /> can convert an <see cref="T:System.Drawing.Image" /> to an instance of a specified type, using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> that specifies the type you want to convert to.</param>
		/// <returns>This method returns <see langword="true" /> if this <see cref="T:System.Drawing.ImageConverter" /> can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(byte[]) || destinationType == typeof(string))
			{
				return true;
			}
			return false;
		}

		/// <summary>Converts a specified object to an <see cref="T:System.Drawing.Image" />.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> that holds information about a specific culture.</param>
		/// <param name="value">The <see cref="T:System.Object" /> to be converted.</param>
		/// <returns>If this method succeeds, it returns the <see cref="T:System.Drawing.Image" /> that it created by converting the specified object. Otherwise, it throws an exception.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (!(value is byte[] buffer))
			{
				return base.ConvertFrom(context, culture, value);
			}
			return Image.FromStream(new MemoryStream(buffer));
		}

		/// <summary>Converts an <see cref="T:System.Drawing.Image" /> (or an object that can be cast to an <see cref="T:System.Drawing.Image" />) to the specified type.</summary>
		/// <param name="context">A formatter context. This object can be used to get more information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> object that specifies formatting conventions used by a particular culture.</param>
		/// <param name="value">The <see cref="T:System.Drawing.Image" /> to convert.</param>
		/// <param name="destinationType">The <see cref="T:System.Type" /> to convert the <see cref="T:System.Drawing.Image" /> to.</param>
		/// <returns>This method returns the converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (value == null)
			{
				return "(none)";
			}
			if (value is Image)
			{
				if (destinationType == typeof(string))
				{
					return value.ToString();
				}
				if (CanConvertTo(null, destinationType))
				{
					using (MemoryStream memoryStream = new MemoryStream())
					{
						((Image)value).Save(memoryStream, ((Image)value).RawFormat);
						return memoryStream.ToArray();
					}
				}
			}
			throw new NotSupportedException(global::Locale.GetText("ImageConverter can not convert from type '{0}'.", value.GetType()));
		}

		/// <summary>Gets the set of properties for this type.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <param name="value">The value of the object to get the properties for.</param>
		/// <param name="attributes">An array of <see cref="T:System.Attribute" /> objects that describe the properties.</param>
		/// <returns>The set of properties that should be exposed for this data type. If no properties should be exposed, this can return <see langword="null" />. The default implementation always returns <see langword="null" />.</returns>
		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			return TypeDescriptor.GetProperties(typeof(Image), attributes);
		}

		/// <summary>Indicates whether this object supports properties. By default, this is <see langword="false" />.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <returns>This method returns <see langword="true" /> if the <see cref="Overload:System.Drawing.ImageConverter.GetProperties" /> method should be called to find the properties of this object.</returns>
		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
	/// <summary>
	///   <see cref="T:System.Drawing.ImageFormatConverter" /> is a class that can be used to convert <see cref="T:System.Drawing.Imaging.ImageFormat" /> objects from one data type to another. Access this class through the <see cref="T:System.ComponentModel.TypeDescriptor" /> object.</summary>
	public class ImageFormatConverter : TypeConverter
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.ImageFormatConverter" /> class.</summary>
		public ImageFormatConverter()
		{
		}

		/// <summary>Indicates whether this converter can convert an object in the specified source type to the native type of the converter.</summary>
		/// <param name="context">A formatter context. This object can be used to get more information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="sourceType">The type you want to convert from.</param>
		/// <returns>This method returns <see langword="true" /> if this object can perform the conversion.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Gets a value indicating whether this converter can convert an object to the specified destination type using the context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that specifies the context for this type conversion.</param>
		/// <param name="destinationType">The <see cref="T:System.Type" /> that represents the type to which you want to convert this <see cref="T:System.Drawing.Imaging.ImageFormat" /> object.</param>
		/// <returns>This method returns <see langword="true" /> if this object can perform the conversion.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(string))
			{
				return true;
			}
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts the specified object to an <see cref="T:System.Drawing.Imaging.ImageFormat" /> object.</summary>
		/// <param name="context">A formatter context. This object can be used to get more information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> object that specifies formatting conventions for a particular culture.</param>
		/// <param name="value">The object to convert.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (!(value is string text))
			{
				return base.ConvertFrom(context, culture, value);
			}
			if (text[0] == '[')
			{
				if (text.Equals(ImageFormat.Bmp.ToString()))
				{
					return ImageFormat.Bmp;
				}
				if (text.Equals(ImageFormat.Emf.ToString()))
				{
					return ImageFormat.Emf;
				}
				if (text.Equals(ImageFormat.Exif.ToString()))
				{
					return ImageFormat.Exif;
				}
				if (text.Equals(ImageFormat.Gif.ToString()))
				{
					return ImageFormat.Gif;
				}
				if (text.Equals(ImageFormat.Icon.ToString()))
				{
					return ImageFormat.Icon;
				}
				if (text.Equals(ImageFormat.Jpeg.ToString()))
				{
					return ImageFormat.Jpeg;
				}
				if (text.Equals(ImageFormat.MemoryBmp.ToString()))
				{
					return ImageFormat.MemoryBmp;
				}
				if (text.Equals(ImageFormat.Png.ToString()))
				{
					return ImageFormat.Png;
				}
				if (text.Equals(ImageFormat.Tiff.ToString()))
				{
					return ImageFormat.Tiff;
				}
				if (text.Equals(ImageFormat.Wmf.ToString()))
				{
					return ImageFormat.Wmf;
				}
			}
			else
			{
				if (string.Compare(text, "Bmp", StringComparison.OrdinalIgnoreCase) == 0)
				{
					return ImageFormat.Bmp;
				}
				if (string.Compare(text, "Emf", StringComparison.OrdinalIgnoreCase) == 0)
				{
					return ImageFormat.Emf;
				}
				if (string.Compare(text, "Exif", StringComparison.OrdinalIgnoreCase) == 0)
				{
					return ImageFormat.Exif;
				}
				if (string.Compare(text, "Gif", StringComparison.OrdinalIgnoreCase) == 0)
				{
					return ImageFormat.Gif;
				}
				if (string.Compare(text, "Icon", StringComparison.OrdinalIgnoreCase) == 0)
				{
					return ImageFormat.Icon;
				}
				if (string.Compare(text, "Jpeg", StringComparison.OrdinalIgnoreCase) == 0)
				{
					return ImageFormat.Jpeg;
				}
				if (string.Compare(text, "MemoryBmp", StringComparison.OrdinalIgnoreCase) == 0)
				{
					return ImageFormat.MemoryBmp;
				}
				if (string.Compare(text, "Png", StringComparison.OrdinalIgnoreCase) == 0)
				{
					return ImageFormat.Png;
				}
				if (string.Compare(text, "Tiff", StringComparison.OrdinalIgnoreCase) == 0)
				{
					return ImageFormat.Tiff;
				}
				if (string.Compare(text, "Wmf", StringComparison.OrdinalIgnoreCase) == 0)
				{
					return ImageFormat.Wmf;
				}
			}
			return base.ConvertFrom(context, culture, value);
		}

		/// <summary>Converts the specified object to the specified type.</summary>
		/// <param name="context">A formatter context. This object can be used to get more information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> object that specifies formatting conventions for a particular culture.</param>
		/// <param name="value">The object to convert.</param>
		/// <param name="destinationType">The type to convert the object to.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="destinationType" /> is <see langword="null." /></exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (value is ImageFormat)
			{
				ImageFormat imageFormat = (ImageFormat)value;
				string text = null;
				if (imageFormat.Guid.Equals(ImageFormat.Bmp.Guid))
				{
					text = "Bmp";
				}
				else if (imageFormat.Guid.Equals(ImageFormat.Emf.Guid))
				{
					text = "Emf";
				}
				else if (imageFormat.Guid.Equals(ImageFormat.Exif.Guid))
				{
					text = "Exif";
				}
				else if (imageFormat.Guid.Equals(ImageFormat.Gif.Guid))
				{
					text = "Gif";
				}
				else if (imageFormat.Guid.Equals(ImageFormat.Icon.Guid))
				{
					text = "Icon";
				}
				else if (imageFormat.Guid.Equals(ImageFormat.Jpeg.Guid))
				{
					text = "Jpeg";
				}
				else if (imageFormat.Guid.Equals(ImageFormat.MemoryBmp.Guid))
				{
					text = "MemoryBmp";
				}
				else if (imageFormat.Guid.Equals(ImageFormat.Png.Guid))
				{
					text = "Png";
				}
				else if (imageFormat.Guid.Equals(ImageFormat.Tiff.Guid))
				{
					text = "Tiff";
				}
				else if (imageFormat.Guid.Equals(ImageFormat.Wmf.Guid))
				{
					text = "Wmf";
				}
				if (destinationType == typeof(string))
				{
					if (text == null)
					{
						return imageFormat.ToString();
					}
					return text;
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					if (text != null)
					{
						return new InstanceDescriptor(typeof(ImageFormat).GetTypeInfo().GetProperty(text), null);
					}
					return new InstanceDescriptor(typeof(ImageFormat).GetTypeInfo().GetConstructor(new Type[1] { typeof(Guid) }), new object[1] { imageFormat.Guid });
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <summary>Gets a collection that contains a set of standard values for the data type this validator is designed for. Returns <see langword="null" /> if the data type does not support a standard set of values.</summary>
		/// <param name="context">A formatter context. This object can be used to get more information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <returns>A collection that contains a standard set of valid values, or <see langword="null" />. The default implementation always returns <see langword="null" />.</returns>
		public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
		{
			return new StandardValuesCollection(new ImageFormat[10]
			{
				ImageFormat.MemoryBmp,
				ImageFormat.Bmp,
				ImageFormat.Emf,
				ImageFormat.Wmf,
				ImageFormat.Gif,
				ImageFormat.Jpeg,
				ImageFormat.Png,
				ImageFormat.Tiff,
				ImageFormat.Exif,
				ImageFormat.Icon
			});
		}

		/// <summary>Indicates whether this object supports a standard set of values that can be picked from a list.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <returns>This method returns <see langword="true" /> if the <see cref="Overload:System.Drawing.ImageFormatConverter.GetStandardValues" /> method should be called to find a common set of values the object supports.</returns>
		public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
	/// <summary>Specifies the known system colors.</summary>
	public enum KnownColor
	{
		/// <summary>The system-defined color of the active window's border.</summary>
		ActiveBorder = 1,
		/// <summary>The system-defined color of the background of the active window's title bar.</summary>
		ActiveCaption,
		/// <summary>The system-defined color of the text in the active window's title bar.</summary>
		ActiveCaptionText,
		/// <summary>The system-defined color of the application workspace. The application workspace is the area in a multiple-document view that is not being occupied by documents.</summary>
		AppWorkspace,
		/// <summary>The system-defined face color of a 3-D element.</summary>
		Control,
		/// <summary>The system-defined shadow color of a 3-D element. The shadow color is applied to parts of a 3-D element that face away from the light source.</summary>
		ControlDark,
		/// <summary>The system-defined color that is the dark shadow color of a 3-D element. The dark shadow color is applied to the parts of a 3-D element that are the darkest color.</summary>
		ControlDarkDark,
		/// <summary>The system-defined color that is the light color of a 3-D element. The light color is applied to parts of a 3-D element that face the light source.</summary>
		ControlLight,
		/// <summary>The system-defined highlight color of a 3-D element. The highlight color is applied to the parts of a 3-D element that are the lightest color.</summary>
		ControlLightLight,
		/// <summary>The system-defined color of text in a 3-D element.</summary>
		ControlText,
		/// <summary>The system-defined color of the desktop.</summary>
		Desktop,
		/// <summary>The system-defined color of dimmed text. Items in a list that are disabled are displayed in dimmed text.</summary>
		GrayText,
		/// <summary>The system-defined color of the background of selected items. This includes selected menu items as well as selected text.</summary>
		Highlight,
		/// <summary>The system-defined color of the text of selected items.</summary>
		HighlightText,
		/// <summary>The system-defined color used to designate a hot-tracked item. Single-clicking a hot-tracked item executes the item.</summary>
		HotTrack,
		/// <summary>The system-defined color of an inactive window's border.</summary>
		InactiveBorder,
		/// <summary>The system-defined color of the background of an inactive window's title bar.</summary>
		InactiveCaption,
		/// <summary>The system-defined color of the text in an inactive window's title bar.</summary>
		InactiveCaptionText,
		/// <summary>The system-defined color of the background of a ToolTip.</summary>
		Info,
		/// <summary>The system-defined color of the text of a ToolTip.</summary>
		InfoText,
		/// <summary>The system-defined color of a menu's background.</summary>
		Menu,
		/// <summary>The system-defined color of a menu's text.</summary>
		MenuText,
		/// <summary>The system-defined color of the background of a scroll bar.</summary>
		ScrollBar,
		/// <summary>The system-defined color of the background in the client area of a window.</summary>
		Window,
		/// <summary>The system-defined color of a window frame.</summary>
		WindowFrame,
		/// <summary>The system-defined color of the text in the client area of a window.</summary>
		WindowText,
		/// <summary>A system-defined color.</summary>
		Transparent,
		/// <summary>A system-defined color.</summary>
		AliceBlue,
		/// <summary>A system-defined color.</summary>
		AntiqueWhite,
		/// <summary>A system-defined color.</summary>
		Aqua,
		/// <summary>A system-defined color.</summary>
		Aquamarine,
		/// <summary>A system-defined color.</summary>
		Azure,
		/// <summary>A system-defined color.</summary>
		Beige,
		/// <summary>A system-defined color.</summary>
		Bisque,
		/// <summary>A system-defined color.</summary>
		Black,
		/// <summary>A system-defined color.</summary>
		BlanchedAlmond,
		/// <summary>A system-defined color.</summary>
		Blue,
		/// <summary>A system-defined color.</summary>
		BlueViolet,
		/// <summary>A system-defined color.</summary>
		Brown,
		/// <summary>A system-defined color.</summary>
		BurlyWood,
		/// <summary>A system-defined color.</summary>
		CadetBlue,
		/// <summary>A system-defined color.</summary>
		Chartreuse,
		/// <summary>A system-defined color.</summary>
		Chocolate,
		/// <summary>A system-defined color.</summary>
		Coral,
		/// <summary>A system-defined color.</summary>
		CornflowerBlue,
		/// <summary>A system-defined color.</summary>
		Cornsilk,
		/// <summary>A system-defined color.</summary>
		Crimson,
		/// <summary>A system-defined color.</summary>
		Cyan,
		/// <summary>A system-defined color.</summary>
		DarkBlue,
		/// <summary>A system-defined color.</summary>
		DarkCyan,
		/// <summary>A system-defined color.</summary>
		DarkGoldenrod,
		/// <summary>A system-defined color.</summary>
		DarkGray,
		/// <summary>A system-defined color.</summary>
		DarkGreen,
		/// <summary>A system-defined color.</summary>
		DarkKhaki,
		/// <summary>A system-defined color.</summary>
		DarkMagenta,
		/// <summary>A system-defined color.</summary>
		DarkOliveGreen,
		/// <summary>A system-defined color.</summary>
		DarkOrange,
		/// <summary>A system-defined color.</summary>
		DarkOrchid,
		/// <summary>A system-defined color.</summary>
		DarkRed,
		/// <summary>A system-defined color.</summary>
		DarkSalmon,
		/// <summary>A system-defined color.</summary>
		DarkSeaGreen,
		/// <summary>A system-defined color.</summary>
		DarkSlateBlue,
		/// <summary>A system-defined color.</summary>
		DarkSlateGray,
		/// <summary>A system-defined color.</summary>
		DarkTurquoise,
		/// <summary>A system-defined color.</summary>
		DarkViolet,
		/// <summary>A system-defined color.</summary>
		DeepPink,
		/// <summary>A system-defined color.</summary>
		DeepSkyBlue,
		/// <summary>A system-defined color.</summary>
		DimGray,
		/// <summary>A system-defined color.</summary>
		DodgerBlue,
		/// <summary>A system-defined color.</summary>
		Firebrick,
		/// <summary>A system-defined color.</summary>
		FloralWhite,
		/// <summary>A system-defined color.</summary>
		ForestGreen,
		/// <summary>A system-defined color.</summary>
		Fuchsia,
		/// <summary>A system-defined color.</summary>
		Gainsboro,
		/// <summary>A system-defined color.</summary>
		GhostWhite,
		/// <summary>A system-defined color.</summary>
		Gold,
		/// <summary>A system-defined color.</summary>
		Goldenrod,
		/// <summary>A system-defined color.</summary>
		Gray,
		/// <summary>A system-defined color.</summary>
		Green,
		/// <summary>A system-defined color.</summary>
		GreenYellow,
		/// <summary>A system-defined color.</summary>
		Honeydew,
		/// <summary>A system-defined color.</summary>
		HotPink,
		/// <summary>A system-defined color.</summary>
		IndianRed,
		/// <summary>A system-defined color.</summary>
		Indigo,
		/// <summary>A system-defined color.</summary>
		Ivory,
		/// <summary>A system-defined color.</summary>
		Khaki,
		/// <summary>A system-defined color.</summary>
		Lavender,
		/// <summary>A system-defined color.</summary>
		LavenderBlush,
		/// <summary>A system-defined color.</summary>
		LawnGreen,
		/// <summary>A system-defined color.</summary>
		LemonChiffon,
		/// <summary>A system-defined color.</summary>
		LightBlue,
		/// <summary>A system-defined color.</summary>
		LightCoral,
		/// <summary>A system-defined color.</summary>
		LightCyan,
		/// <summary>A system-defined color.</summary>
		LightGoldenrodYellow,
		/// <summary>A system-defined color.</summary>
		LightGray,
		/// <summary>A system-defined color.</summary>
		LightGreen,
		/// <summary>A system-defined color.</summary>
		LightPink,
		/// <summary>A system-defined color.</summary>
		LightSalmon,
		/// <summary>A system-defined color.</summary>
		LightSeaGreen,
		/// <summary>A system-defined color.</summary>
		LightSkyBlue,
		/// <summary>A system-defined color.</summary>
		LightSlateGray,
		/// <summary>A system-defined color.</summary>
		LightSteelBlue,
		/// <summary>A system-defined color.</summary>
		LightYellow,
		/// <summary>A system-defined color.</summary>
		Lime,
		/// <summary>A system-defined color.</summary>
		LimeGreen,
		/// <summary>A system-defined color.</summary>
		Linen,
		/// <summary>A system-defined color.</summary>
		Magenta,
		/// <summary>A system-defined color.</summary>
		Maroon,
		/// <summary>A system-defined color.</summary>
		MediumAquamarine,
		/// <summary>A system-defined color.</summary>
		MediumBlue,
		/// <summary>A system-defined color.</summary>
		MediumOrchid,
		/// <summary>A system-defined color.</summary>
		MediumPurple,
		/// <summary>A system-defined color.</summary>
		MediumSeaGreen,
		/// <summary>A system-defined color.</summary>
		MediumSlateBlue,
		/// <summary>A system-defined color.</summary>
		MediumSpringGreen,
		/// <summary>A system-defined color.</summary>
		MediumTurquoise,
		/// <summary>A system-defined color.</summary>
		MediumVioletRed,
		/// <summary>A system-defined color.</summary>
		MidnightBlue,
		/// <summary>A system-defined color.</summary>
		MintCream,
		/// <summary>A system-defined color.</summary>
		MistyRose,
		/// <summary>A system-defined color.</summary>
		Moccasin,
		/// <summary>A system-defined color.</summary>
		NavajoWhite,
		/// <summary>A system-defined color.</summary>
		Navy,
		/// <summary>A system-defined color.</summary>
		OldLace,
		/// <summary>A system-defined color.</summary>
		Olive,
		/// <summary>A system-defined color.</summary>
		OliveDrab,
		/// <summary>A system-defined color.</summary>
		Orange,
		/// <summary>A system-defined color.</summary>
		OrangeRed,
		/// <summary>A system-defined color.</summary>
		Orchid,
		/// <summary>A system-defined color.</summary>
		PaleGoldenrod,
		/// <summary>A system-defined color.</summary>
		PaleGreen,
		/// <summary>A system-defined color.</summary>
		PaleTurquoise,
		/// <summary>A system-defined color.</summary>
		PaleVioletRed,
		/// <summary>A system-defined color.</summary>
		PapayaWhip,
		/// <summary>A system-defined color.</summary>
		PeachPuff,
		/// <summary>A system-defined color.</summary>
		Peru,
		/// <summary>A system-defined color.</summary>
		Pink,
		/// <summary>A system-defined color.</summary>
		Plum,
		/// <summary>A system-defined color.</summary>
		PowderBlue,
		/// <summary>A system-defined color.</summary>
		Purple,
		/// <summary>A system-defined color.</summary>
		Red,
		/// <summary>A system-defined color.</summary>
		RosyBrown,
		/// <summary>A system-defined color.</summary>
		RoyalBlue,
		/// <summary>A system-defined color.</summary>
		SaddleBrown,
		/// <summary>A system-defined color.</summary>
		Salmon,
		/// <summary>A system-defined color.</summary>
		SandyBrown,
		/// <summary>A system-defined color.</summary>
		SeaGreen,
		/// <summary>A system-defined color.</summary>
		SeaShell,
		/// <summary>A system-defined color.</summary>
		Sienna,
		/// <summary>A system-defined color.</summary>
		Silver,
		/// <summary>A system-defined color.</summary>
		SkyBlue,
		/// <summary>A system-defined color.</summary>
		SlateBlue,
		/// <summary>A system-defined color.</summary>
		SlateGray,
		/// <summary>A system-defined color.</summary>
		Snow,
		/// <summary>A system-defined color.</summary>
		SpringGreen,
		/// <summary>A system-defined color.</summary>
		SteelBlue,
		/// <summary>A system-defined color.</summary>
		Tan,
		/// <summary>A system-defined color.</summary>
		Teal,
		/// <summary>A system-defined color.</summary>
		Thistle,
		/// <summary>A system-defined color.</summary>
		Tomato,
		/// <summary>A system-defined color.</summary>
		Turquoise,
		/// <summary>A system-defined color.</summary>
		Violet,
		/// <summary>A system-defined color.</summary>
		Wheat,
		/// <summary>A system-defined color.</summary>
		White,
		/// <summary>A system-defined color.</summary>
		WhiteSmoke,
		/// <summary>A system-defined color.</summary>
		Yellow,
		/// <summary>A system-defined color.</summary>
		YellowGreen,
		/// <summary>The system-defined face color of a 3-D element.</summary>
		ButtonFace,
		/// <summary>The system-defined color that is the highlight color of a 3-D element. This color is applied to parts of a 3-D element that face the light source.</summary>
		ButtonHighlight,
		/// <summary>The system-defined color that is the shadow color of a 3-D element. This color is applied to parts of a 3-D element that face away from the light source.</summary>
		ButtonShadow,
		/// <summary>The system-defined color of the lightest color in the color gradient of an active window's title bar.</summary>
		GradientActiveCaption,
		/// <summary>The system-defined color of the lightest color in the color gradient of an inactive window's title bar.</summary>
		GradientInactiveCaption,
		/// <summary>The system-defined color of the background of a menu bar.</summary>
		MenuBar,
		/// <summary>The system-defined color used to highlight menu items when the menu appears as a flat menu.</summary>
		MenuHighlight
	}
	internal static class KnownColors
	{
		internal static uint[] ArgbValues;

		static KnownColors()
		{
			ArgbValues = new uint[175]
			{
				0u, 4292137160u, 4278211811u, 4294967295u, 4286611584u, 4293716440u, 4289505433u, 4285624164u, 4294045666u, 4294967295u,
				4278190080u, 4278210200u, 4289505433u, 4281428677u, 4294967295u, 4278190208u, 4292137160u, 4286224095u, 4292404472u, 4294967265u,
				4278190080u, 4294967295u, 4278190080u, 4292137160u, 4294967295u, 4278190080u, 4278190080u, 16777215u, 4293982463u, 4294634455u,
				4278255615u, 4286578644u, 4293984255u, 4294309340u, 4294960324u, 4278190080u, 4294962125u, 4278190335u, 4287245282u, 4289014314u,
				4292786311u, 4284456608u, 4286578432u, 4291979550u, 4294934352u, 4284782061u, 4294965468u, 4292613180u, 4278255615u, 4278190219u,
				4278225803u, 4290283019u, 4289309097u, 4278215680u, 4290623339u, 4287299723u, 4283788079u, 4294937600u, 4288230092u, 4287299584u,
				4293498490u, 4287609995u, 4282924427u, 4281290575u, 4278243025u, 4287889619u, 4294907027u, 4278239231u, 4285098345u, 4280193279u,
				4289864226u, 4294966000u, 4280453922u, 4294902015u, 4292664540u, 4294506751u, 4294956800u, 4292519200u, 4286611584u, 4278222848u,
				4289593135u, 4293984240u, 4294928820u, 4291648604u, 4283105410u, 4294967280u, 4293977740u, 4293322490u, 4294963445u, 4286381056u,
				4294965965u, 4289583334u, 4293951616u, 4292935679u, 4294638290u, 4292072403u, 4287688336u, 4294948545u, 4294942842u, 4280332970u,
				4287090426u, 4286023833u, 4289774814u, 4294967264u, 4278255360u, 4281519410u, 4294635750u, 4294902015u, 4286578688u, 4284927402u,
				4278190285u, 4290401747u, 4287852763u, 4282168177u, 4286277870u, 4278254234u, 4282962380u, 4291237253u, 4279834992u, 4294311930u,
				4294960353u, 4294960309u, 4294958765u, 4278190208u, 4294833638u, 4286611456u, 4285238819u, 4294944000u, 4294919424u, 4292505814u,
				4293847210u, 4288215960u, 4289720046u, 4292571283u, 4294963157u, 4294957753u, 4291659071u, 4294951115u, 4292714717u, 4289781990u,
				4286578816u, 4294901760u, 4290547599u, 4282477025u, 4287317267u, 4294606962u, 4294222944u, 4281240407u, 4294964718u, 4288696877u,
				4290822336u, 4287090411u, 4285160141u, 4285563024u, 4294966010u, 4278255487u, 4282811060u, 4291998860u, 4278222976u, 4292394968u,
				4294927175u, 4282441936u, 4293821166u, 4294303411u, 4294967295u, 4294309365u, 4294967040u, 4288335154u, 4293716440u, 4294967295u,
				4289505433u, 4282226175u, 4288526827u, 4293716440u, 4281428677u
			};
			if (GDIPlus.RunningOnWindows())
			{
				RetrieveWindowsSystemColors();
			}
		}

		private static uint GetSysColor(GetSysColorIndex index)
		{
			uint num = GDIPlus.Win32GetSysColor(index);
			return 0xFF000000u | ((num & 0xFF) << 16) | (num & 0xFF00) | (num >> 16);
		}

		private static void RetrieveWindowsSystemColors()
		{
			ArgbValues[1] = GetSysColor(GetSysColorIndex.COLOR_ACTIVEBORDER);
			ArgbValues[2] = GetSysColor(GetSysColorIndex.COLOR_ACTIVECAPTION);
			ArgbValues[3] = GetSysColor(GetSysColorIndex.COLOR_CAPTIONTEXT);
			ArgbValues[4] = GetSysColor(GetSysColorIndex.COLOR_APPWORKSPACE);
			ArgbValues[5] = GetSysColor(GetSysColorIndex.COLOR_BTNFACE);
			ArgbValues[6] = GetSysColor(GetSysColorIndex.COLOR_BTNSHADOW);
			ArgbValues[7] = GetSysColor(GetSysColorIndex.COLOR_3DDKSHADOW);
			ArgbValues[8] = GetSysColor(GetSysColorIndex.COLOR_3DLIGHT);
			ArgbValues[9] = GetSysColor(GetSysColorIndex.COLOR_BTNHIGHLIGHT);
			ArgbValues[10] = GetSysColor(GetSysColorIndex.COLOR_BTNTEXT);
			ArgbValues[11] = GetSysColor(GetSysColorIndex.COLOR_BACKGROUND);
			ArgbValues[12] = GetSysColor(GetSysColorIndex.COLOR_GRAYTEXT);
			ArgbValues[13] = GetSysColor(GetSysColorIndex.COLOR_HIGHLIGHT);
			ArgbValues[14] = GetSysColor(GetSysColorIndex.COLOR_HIGHLIGHTTEXT);
			ArgbValues[15] = GetSysColor(GetSysColorIndex.COLOR_HOTLIGHT);
			ArgbValues[16] = GetSysColor(GetSysColorIndex.COLOR_INACTIVEBORDER);
			ArgbValues[17] = GetSysColor(GetSysColorIndex.COLOR_INACTIVECAPTION);
			ArgbValues[18] = GetSysColor(GetSysColorIndex.COLOR_INACTIVECAPTIONTEXT);
			ArgbValues[19] = GetSysColor(GetSysColorIndex.COLOR_INFOBK);
			ArgbValues[20] = GetSysColor(GetSysColorIndex.COLOR_INFOTEXT);
			ArgbValues[21] = GetSysColor(GetSysColorIndex.COLOR_MENU);
			ArgbValues[22] = GetSysColor(GetSysColorIndex.COLOR_MENUTEXT);
			ArgbValues[23] = GetSysColor(GetSysColorIndex.COLOR_SCROLLBAR);
			ArgbValues[24] = GetSysColor(GetSysColorIndex.COLOR_WINDOW);
			ArgbValues[25] = GetSysColor(GetSysColorIndex.COLOR_WINDOWFRAME);
			ArgbValues[26] = GetSysColor(GetSysColorIndex.COLOR_WINDOWTEXT);
			ArgbValues[168] = GetSysColor(GetSysColorIndex.COLOR_BTNFACE);
			ArgbValues[169] = GetSysColor(GetSysColorIndex.COLOR_BTNHIGHLIGHT);
			ArgbValues[170] = GetSysColor(GetSysColorIndex.COLOR_BTNSHADOW);
			ArgbValues[171] = GetSysColor(GetSysColorIndex.COLOR_GRADIENTACTIVECAPTION);
			ArgbValues[172] = GetSysColor(GetSysColorIndex.COLOR_GRADIENTINACTIVECAPTION);
			ArgbValues[173] = GetSysColor(GetSysColorIndex.COLOR_MENUBAR);
			ArgbValues[174] = GetSysColor(GetSysColorIndex.COLOR_MENUHIGHLIGHT);
		}

		public static Color FromKnownColor(KnownColor kc)
		{
			return Color.FromKnownColor(kc);
		}

		public static string GetName(short kc)
		{
			return kc switch
			{
				1 => "ActiveBorder", 
				2 => "ActiveCaption", 
				3 => "ActiveCaptionText", 
				4 => "AppWorkspace", 
				5 => "Control", 
				6 => "ControlDark", 
				7 => "ControlDarkDark", 
				8 => "ControlLight", 
				9 => "ControlLightLight", 
				10 => "ControlText", 
				11 => "Desktop", 
				12 => "GrayText", 
				13 => "Highlight", 
				14 => "HighlightText", 
				15 => "HotTrack", 
				16 => "InactiveBorder", 
				17 => "InactiveCaption", 
				18 => "InactiveCaptionText", 
				19 => "Info", 
				20 => "InfoText", 
				21 => "Menu", 
				22 => "MenuText", 
				23 => "ScrollBar", 
				24 => "Window", 
				25 => "WindowFrame", 
				26 => "WindowText", 
				27 => "Transparent", 
				28 => "AliceBlue", 
				29 => "AntiqueWhite", 
				30 => "Aqua", 
				31 => "Aquamarine", 
				32 => "Azure", 
				33 => "Beige", 
				34 => "Bisque", 
				35 => "Black", 
				36 => "BlanchedAlmond", 
				37 => "Blue", 
				38 => "BlueViolet", 
				39 => "Brown", 
				40 => "BurlyWood", 
				41 => "CadetBlue", 
				42 => "Chartreuse", 
				43 => "Chocolate", 
				44 => "Coral", 
				45 => "CornflowerBlue", 
				46 => "Cornsilk", 
				47 => "Crimson", 
				48 => "Cyan", 
				49 => "DarkBlue", 
				50 => "DarkCyan", 
				51 => "DarkGoldenrod", 
				52 => "DarkGray", 
				53 => "DarkGreen", 
				54 => "DarkKhaki", 
				55 => "DarkMagenta", 
				56 => "DarkOliveGreen", 
				57 => "DarkOrange", 
				58 => "DarkOrchid", 
				59 => "DarkRed", 
				60 => "DarkSalmon", 
				61 => "DarkSeaGreen", 
				62 => "DarkSlateBlue", 
				63 => "DarkSlateGray", 
				64 => "DarkTurquoise", 
				65 => "DarkViolet", 
				66 => "DeepPink", 
				67 => "DeepSkyBlue", 
				68 => "DimGray", 
				69 => "DodgerBlue", 
				70 => "Firebrick", 
				71 => "FloralWhite", 
				72 => "ForestGreen", 
				73 => "Fuchsia", 
				74 => "Gainsboro", 
				75 => "GhostWhite", 
				76 => "Gold", 
				77 => "Goldenrod", 
				78 => "Gray", 
				79 => "Green", 
				80 => "GreenYellow", 
				81 => "Honeydew", 
				82 => "HotPink", 
				83 => "IndianRed", 
				84 => "Indigo", 
				85 => "Ivory", 
				86 => "Khaki", 
				87 => "Lavender", 
				88 => "LavenderBlush", 
				89 => "LawnGreen", 
				90 => "LemonChiffon", 
				91 => "LightBlue", 
				92 => "LightCoral", 
				93 => "LightCyan", 
				94 => "LightGoldenrodYellow", 
				95 => "LightGray", 
				96 => "LightGreen", 
				97 => "LightPink", 
				98 => "LightSalmon", 
				99 => "LightSeaGreen", 
				100 => "LightSkyBlue", 
				101 => "LightSlateGray", 
				102 => "LightSteelBlue", 
				103 => "LightYellow", 
				104 => "Lime", 
				105 => "LimeGreen", 
				106 => "Linen", 
				107 => "Magenta", 
				108 => "Maroon", 
				109 => "MediumAquamarine", 
				110 => "MediumBlue", 
				111 => "MediumOrchid", 
				112 => "MediumPurple", 
				113 => "MediumSeaGreen", 
				114 => "MediumSlateBlue", 
				115 => "MediumSpringGreen", 
				116 => "MediumTurquoise", 
				117 => "MediumVioletRed", 
				118 => "MidnightBlue", 
				119 => "MintCream", 
				120 => "MistyRose", 
				121 => "Moccasin", 
				122 => "NavajoWhite", 
				123 => "Navy", 
				124 => "OldLace", 
				125 => "Olive", 
				126 => "OliveDrab", 
				127 => "Orange", 
				128 => "OrangeRed", 
				129 => "Orchid", 
				130 => "PaleGoldenrod", 
				131 => "PaleGreen", 
				132 => "PaleTurquoise", 
				133 => "PaleVioletRed", 
				134 => "PapayaWhip", 
				135 => "PeachPuff", 
				136 => "Peru", 
				137 => "Pink", 
				138 => "Plum", 
				139 => "PowderBlue", 
				140 => "Purple", 
				141 => "Red", 
				142 => "RosyBrown", 
				143 => "RoyalBlue", 
				144 => "SaddleBrown", 
				145 => "Salmon", 
				146 => "SandyBrown", 
				147 => "SeaGreen", 
				148 => "SeaShell", 
				149 => "Sienna", 
				150 => "Silver", 
				151 => "SkyBlue", 
				152 => "SlateBlue", 
				153 => "SlateGray", 
				154 => "Snow", 
				155 => "SpringGreen", 
				156 => "SteelBlue", 
				157 => "Tan", 
				158 => "Teal", 
				159 => "Thistle", 
				160 => "Tomato", 
				161 => "Turquoise", 
				162 => "Violet", 
				163 => "Wheat", 
				164 => "White", 
				165 => "WhiteSmoke", 
				166 => "Yellow", 
				167 => "YellowGreen", 
				168 => "ButtonFace", 
				169 => "ButtonHighlight", 
				170 => "ButtonShadow", 
				171 => "GradientActiveCaption", 
				172 => "GradientInactiveCaption", 
				173 => "MenuBar", 
				174 => "MenuHighlight", 
				_ => string.Empty, 
			};
		}

		public static string GetName(KnownColor kc)
		{
			return GetName((short)kc);
		}

		public static Color FindColorMatch(Color c)
		{
			uint num = (uint)c.ToArgb();
			for (int i = 27; i < 167; i++)
			{
				if (num == ArgbValues[i])
				{
					return FromKnownColor((KnownColor)i);
				}
			}
			return Color.Empty;
		}

		public static void Update(int knownColor, int color)
		{
			ArgbValues[knownColor] = (uint)color;
		}
	}
	/// <summary>Defines an object used to draw lines and curves. This class cannot be inherited.</summary>
	public sealed class Pen : MarshalByRefObject, ICloneable, IDisposable
	{
		internal IntPtr nativeObject;

		internal bool isModifiable = true;

		private Color color;

		private CustomLineCap startCap;

		private CustomLineCap endCap;

		/// <summary>Gets or sets the alignment for this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.PenAlignment" /> that represents the alignment for this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The specified value is not a member of <see cref="T:System.Drawing.Drawing2D.PenAlignment" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.Alignment" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		[System.MonoLimitation("Libgdiplus doesn't use this property for rendering")]
		public PenAlignment Alignment
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPenMode(nativeObject, out var alignment));
				return alignment;
			}
			set
			{
				if (value < PenAlignment.Center || value > PenAlignment.Right)
				{
					throw new InvalidEnumArgumentException("Alignment", (int)value, typeof(PenAlignment));
				}
				if (isModifiable)
				{
					GDIPlus.CheckStatus(GDIPlus.GdipSetPenMode(nativeObject, value));
					return;
				}
				throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
			}
		}

		/// <summary>Gets or sets the <see cref="T:System.Drawing.Brush" /> that determines attributes of this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> that determines attributes of this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.Brush" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public Brush Brush
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPenBrushFill(nativeObject, out var brush));
				return new SolidBrush(brush);
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("Brush");
				}
				if (!isModifiable)
				{
					throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetPenBrushFill(nativeObject, value.NativeBrush));
				color = Color.Empty;
			}
		}

		/// <summary>Gets or sets the color of this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> structure that represents the color of this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.Color" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public Color Color
		{
			get
			{
				if (color.Equals(Color.Empty))
				{
					GDIPlus.CheckStatus(GDIPlus.GdipGetPenColor(nativeObject, out var argb));
					color = Color.FromArgb(argb);
				}
				return color;
			}
			set
			{
				if (!isModifiable)
				{
					throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetPenColor(nativeObject, value.ToArgb()));
				color = value;
			}
		}

		/// <summary>Gets or sets an array of values that specifies a compound pen. A compound pen draws a compound line made up of parallel lines and spaces.</summary>
		/// <returns>An array of real numbers that specifies the compound array. The elements in the array must be in increasing order, not less than 0, and not greater than 1.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.CompoundArray" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public float[] CompoundArray
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPenCompoundCount(nativeObject, out var count));
				float[] array = new float[count];
				GDIPlus.CheckStatus(GDIPlus.GdipGetPenCompoundArray(nativeObject, array, count));
				return array;
			}
			set
			{
				if (isModifiable)
				{
					if (value.Length < 2)
					{
						throw new ArgumentException("Invalid parameter.");
					}
					foreach (float num in value)
					{
						if (num < 0f || num > 1f)
						{
							throw new ArgumentException("Invalid parameter.");
						}
					}
					GDIPlus.CheckStatus(GDIPlus.GdipSetPenCompoundArray(nativeObject, value, value.Length));
					return;
				}
				throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
			}
		}

		/// <summary>Gets or sets a custom cap to use at the end of lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> that represents the cap used at the end of lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.CustomEndCap" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public CustomLineCap CustomEndCap
		{
			get
			{
				return endCap;
			}
			set
			{
				if (isModifiable)
				{
					GDIPlus.CheckStatus(GDIPlus.GdipSetPenCustomEndCap(nativeObject, value.nativeCap));
					endCap = value;
					return;
				}
				throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
			}
		}

		/// <summary>Gets or sets a custom cap to use at the beginning of lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> that represents the cap used at the beginning of lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.CustomStartCap" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public CustomLineCap CustomStartCap
		{
			get
			{
				return startCap;
			}
			set
			{
				if (isModifiable)
				{
					GDIPlus.CheckStatus(GDIPlus.GdipSetPenCustomStartCap(nativeObject, value.nativeCap));
					startCap = value;
					return;
				}
				throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
			}
		}

		/// <summary>Gets or sets the cap style used at the end of the dashes that make up dashed lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Drawing2D.DashCap" /> values that represents the cap style used at the beginning and end of the dashes that make up dashed lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The specified value is not a member of <see cref="T:System.Drawing.Drawing2D.DashCap" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.DashCap" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public DashCap DashCap
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPenDashCap197819(nativeObject, out var dashCap));
				return dashCap;
			}
			set
			{
				if (value < DashCap.Flat || value > DashCap.Triangle)
				{
					throw new InvalidEnumArgumentException("DashCap", (int)value, typeof(DashCap));
				}
				if (isModifiable)
				{
					GDIPlus.CheckStatus(GDIPlus.GdipSetPenDashCap197819(nativeObject, value));
					return;
				}
				throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
			}
		}

		/// <summary>Gets or sets the distance from the start of a line to the beginning of a dash pattern.</summary>
		/// <returns>The distance from the start of a line to the beginning of a dash pattern.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.DashOffset" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public float DashOffset
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPenDashOffset(nativeObject, out var offset));
				return offset;
			}
			set
			{
				if (isModifiable)
				{
					GDIPlus.CheckStatus(GDIPlus.GdipSetPenDashOffset(nativeObject, value));
					return;
				}
				throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
			}
		}

		/// <summary>Gets or sets an array of custom dashes and spaces.</summary>
		/// <returns>An array of real numbers that specifies the lengths of alternating dashes and spaces in dashed lines.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.DashPattern" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public float[] DashPattern
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPenDashCount(nativeObject, out var count));
				float[] array;
				if (count <= 0)
				{
					array = ((DashStyle != DashStyle.Custom) ? new float[0] : new float[1] { 1f });
				}
				else
				{
					array = new float[count];
					GDIPlus.CheckStatus(GDIPlus.GdipGetPenDashArray(nativeObject, array, count));
				}
				return array;
			}
			set
			{
				if (isModifiable)
				{
					if (value.Length == 0)
					{
						throw new ArgumentException("Invalid parameter.");
					}
					for (int i = 0; i < value.Length; i++)
					{
						if (value[i] <= 0f)
						{
							throw new ArgumentException("Invalid parameter.");
						}
					}
					GDIPlus.CheckStatus(GDIPlus.GdipSetPenDashArray(nativeObject, value, value.Length));
					return;
				}
				throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
			}
		}

		/// <summary>Gets or sets the style used for dashed lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.DashStyle" /> that represents the style used for dashed lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.DashStyle" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public DashStyle DashStyle
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPenDashStyle(nativeObject, out var dashStyle));
				return dashStyle;
			}
			set
			{
				if (value < DashStyle.Solid || value > DashStyle.Custom)
				{
					throw new InvalidEnumArgumentException("DashStyle", (int)value, typeof(DashStyle));
				}
				if (isModifiable)
				{
					GDIPlus.CheckStatus(GDIPlus.GdipSetPenDashStyle(nativeObject, value));
					return;
				}
				throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
			}
		}

		/// <summary>Gets or sets the cap style used at the beginning of lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Drawing2D.LineCap" /> values that represents the cap style used at the beginning of lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The specified value is not a member of <see cref="T:System.Drawing.Drawing2D.LineCap" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.StartCap" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public LineCap StartCap
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPenStartCap(nativeObject, out var result));
				return result;
			}
			set
			{
				if (value < LineCap.Flat || value > LineCap.Custom)
				{
					throw new InvalidEnumArgumentException("StartCap", (int)value, typeof(LineCap));
				}
				if (isModifiable)
				{
					GDIPlus.CheckStatus(GDIPlus.GdipSetPenStartCap(nativeObject, value));
					return;
				}
				throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
			}
		}

		/// <summary>Gets or sets the cap style used at the end of lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Drawing2D.LineCap" /> values that represents the cap style used at the end of lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The specified value is not a member of <see cref="T:System.Drawing.Drawing2D.LineCap" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.EndCap" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public LineCap EndCap
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPenEndCap(nativeObject, out var result));
				return result;
			}
			set
			{
				if (value < LineCap.Flat || value > LineCap.Custom)
				{
					throw new InvalidEnumArgumentException("EndCap", (int)value, typeof(LineCap));
				}
				if (isModifiable)
				{
					GDIPlus.CheckStatus(GDIPlus.GdipSetPenEndCap(nativeObject, value));
					return;
				}
				throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
			}
		}

		/// <summary>Gets or sets the join style for the ends of two consecutive lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.LineJoin" /> that represents the join style for the ends of two consecutive lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.LineJoin" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public LineJoin LineJoin
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPenLineJoin(nativeObject, out var lineJoin));
				return lineJoin;
			}
			set
			{
				if (value < LineJoin.Miter || value > LineJoin.MiterClipped)
				{
					throw new InvalidEnumArgumentException("LineJoin", (int)value, typeof(LineJoin));
				}
				if (isModifiable)
				{
					GDIPlus.CheckStatus(GDIPlus.GdipSetPenLineJoin(nativeObject, value));
					return;
				}
				throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
			}
		}

		/// <summary>Gets or sets the limit of the thickness of the join on a mitered corner.</summary>
		/// <returns>The limit of the thickness of the join on a mitered corner.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.MiterLimit" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public float MiterLimit
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPenMiterLimit(nativeObject, out var miterLimit));
				return miterLimit;
			}
			set
			{
				if (isModifiable)
				{
					GDIPlus.CheckStatus(GDIPlus.GdipSetPenMiterLimit(nativeObject, value));
					return;
				}
				throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
			}
		}

		/// <summary>Gets the style of lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.PenType" /> enumeration that specifies the style of lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		public PenType PenType
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPenFillType(nativeObject, out var type));
				return type;
			}
		}

		/// <summary>Gets or sets a copy of the geometric transformation for this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A copy of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> that represents the geometric transformation for this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.Transform" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public Matrix Transform
		{
			get
			{
				Matrix matrix = new Matrix();
				GDIPlus.CheckStatus(GDIPlus.GdipGetPenTransform(nativeObject, matrix.nativeMatrix));
				return matrix;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("Transform");
				}
				if (isModifiable)
				{
					GDIPlus.CheckStatus(GDIPlus.GdipSetPenTransform(nativeObject, value.nativeMatrix));
					return;
				}
				throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
			}
		}

		/// <summary>Gets or sets the width of this <see cref="T:System.Drawing.Pen" />, in units of the <see cref="T:System.Drawing.Graphics" /> object used for drawing.</summary>
		/// <returns>The width of this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.Width" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public float Width
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPenWidth(nativeObject, out var width));
				return width;
			}
			set
			{
				if (isModifiable)
				{
					GDIPlus.CheckStatus(GDIPlus.GdipSetPenWidth(nativeObject, value));
					return;
				}
				throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
			}
		}

		internal IntPtr NativePen => nativeObject;

		internal Pen(IntPtr p)
		{
			nativeObject = p;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Pen" /> class with the specified <see cref="T:System.Drawing.Brush" />.</summary>
		/// <param name="brush">A <see cref="T:System.Drawing.Brush" /> that determines the fill properties of this <see cref="T:System.Drawing.Pen" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public Pen(Brush brush)
			: this(brush, 1f)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Pen" /> class with the specified color.</summary>
		/// <param name="color">A <see cref="T:System.Drawing.Color" /> structure that indicates the color of this <see cref="T:System.Drawing.Pen" />.</param>
		public Pen(Color color)
			: this(color, 1f)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Pen" /> class with the specified <see cref="T:System.Drawing.Brush" /> and <see cref="P:System.Drawing.Pen.Width" />.</summary>
		/// <param name="brush">A <see cref="T:System.Drawing.Brush" /> that determines the characteristics of this <see cref="T:System.Drawing.Pen" />.</param>
		/// <param name="width">The width of the new <see cref="T:System.Drawing.Pen" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public Pen(Brush brush, float width)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreatePen2(brush.NativeBrush, width, GraphicsUnit.World, out nativeObject));
			color = Color.Empty;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Pen" /> class with the specified <see cref="T:System.Drawing.Color" /> and <see cref="P:System.Drawing.Pen.Width" /> properties.</summary>
		/// <param name="color">A <see cref="T:System.Drawing.Color" /> structure that indicates the color of this <see cref="T:System.Drawing.Pen" />.</param>
		/// <param name="width">A value indicating the width of this <see cref="T:System.Drawing.Pen" />.</param>
		public Pen(Color color, float width)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreatePen1(color.ToArgb(), width, GraphicsUnit.World, out nativeObject));
			this.color = color;
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>An <see cref="T:System.Object" /> that can be cast to a <see cref="T:System.Drawing.Pen" />.</returns>
		public object Clone()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipClonePen(nativeObject, out var clonepen));
			return new Pen(clonepen)
			{
				startCap = startCap,
				endCap = endCap
			};
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Pen" />.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (disposing && !isModifiable)
			{
				throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
			}
			if (nativeObject != IntPtr.Zero)
			{
				Status status = GDIPlus.GdipDeletePen(nativeObject);
				nativeObject = IntPtr.Zero;
				GDIPlus.CheckStatus(status);
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Pen()
		{
			Dispose(disposing: false);
		}

		/// <summary>Multiplies the transformation matrix for this <see cref="T:System.Drawing.Pen" /> by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> object by which to multiply the transformation matrix.</param>
		public void MultiplyTransform(Matrix matrix)
		{
			MultiplyTransform(matrix, MatrixOrder.Prepend);
		}

		/// <summary>Multiplies the transformation matrix for this <see cref="T:System.Drawing.Pen" /> by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the specified order.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which to multiply the transformation matrix.</param>
		/// <param name="order">The order in which to perform the multiplication operation.</param>
		public void MultiplyTransform(Matrix matrix, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipMultiplyPenTransform(nativeObject, matrix.nativeMatrix, order));
		}

		/// <summary>Resets the geometric transformation matrix for this <see cref="T:System.Drawing.Pen" /> to identity.</summary>
		public void ResetTransform()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipResetPenTransform(nativeObject));
		}

		/// <summary>Rotates the local geometric transformation by the specified angle. This method prepends the rotation to the transformation.</summary>
		/// <param name="angle">The angle of rotation.</param>
		public void RotateTransform(float angle)
		{
			RotateTransform(angle, MatrixOrder.Prepend);
		}

		/// <summary>Rotates the local geometric transformation by the specified angle in the specified order.</summary>
		/// <param name="angle">The angle of rotation.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies whether to append or prepend the rotation matrix.</param>
		public void RotateTransform(float angle, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipRotatePenTransform(nativeObject, angle, order));
		}

		/// <summary>Scales the local geometric transformation by the specified factors. This method prepends the scaling matrix to the transformation.</summary>
		/// <param name="sx">The factor by which to scale the transformation in the x-axis direction.</param>
		/// <param name="sy">The factor by which to scale the transformation in the y-axis direction.</param>
		public void ScaleTransform(float sx, float sy)
		{
			ScaleTransform(sx, sy, MatrixOrder.Prepend);
		}

		/// <summary>Scales the local geometric transformation by the specified factors in the specified order.</summary>
		/// <param name="sx">The factor by which to scale the transformation in the x-axis direction.</param>
		/// <param name="sy">The factor by which to scale the transformation in the y-axis direction.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies whether to append or prepend the scaling matrix.</param>
		public void ScaleTransform(float sx, float sy, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipScalePenTransform(nativeObject, sx, sy, order));
		}

		/// <summary>Sets the values that determine the style of cap used to end lines drawn by this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <param name="startCap">A <see cref="T:System.Drawing.Drawing2D.LineCap" /> that represents the cap style to use at the beginning of lines drawn with this <see cref="T:System.Drawing.Pen" />.</param>
		/// <param name="endCap">A <see cref="T:System.Drawing.Drawing2D.LineCap" /> that represents the cap style to use at the end of lines drawn with this <see cref="T:System.Drawing.Pen" />.</param>
		/// <param name="dashCap">A <see cref="T:System.Drawing.Drawing2D.LineCap" /> that represents the cap style to use at the beginning or end of dashed lines drawn with this <see cref="T:System.Drawing.Pen" />.</param>
		public void SetLineCap(LineCap startCap, LineCap endCap, DashCap dashCap)
		{
			if (isModifiable)
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetPenLineCap197819(nativeObject, startCap, endCap, dashCap));
				return;
			}
			throw new ArgumentException(global::Locale.GetText("This Pen object can't be modified."));
		}

		/// <summary>Translates the local geometric transformation by the specified dimensions. This method prepends the translation to the transformation.</summary>
		/// <param name="dx">The value of the translation in x.</param>
		/// <param name="dy">The value of the translation in y.</param>
		public void TranslateTransform(float dx, float dy)
		{
			TranslateTransform(dx, dy, MatrixOrder.Prepend);
		}

		/// <summary>Translates the local geometric transformation by the specified dimensions in the specified order.</summary>
		/// <param name="dx">The value of the translation in x.</param>
		/// <param name="dy">The value of the translation in y.</param>
		/// <param name="order">The order (prepend or append) in which to apply the translation.</param>
		public void TranslateTransform(float dx, float dy, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipTranslatePenTransform(nativeObject, dx, dy, order));
		}
	}
	/// <summary>Pens for all the standard colors. This class cannot be inherited.</summary>
	public sealed class Pens
	{
		private static Pen aliceblue;

		private static Pen antiquewhite;

		private static Pen aqua;

		private static Pen aquamarine;

		private static Pen azure;

		private static Pen beige;

		private static Pen bisque;

		private static Pen black;

		private static Pen blanchedalmond;

		private static Pen blue;

		private static Pen blueviolet;

		private static Pen brown;

		private static Pen burlywood;

		private static Pen cadetblue;

		private static Pen chartreuse;

		private static Pen chocolate;

		private static Pen coral;

		private static Pen cornflowerblue;

		private static Pen cornsilk;

		private static Pen crimson;

		private static Pen cyan;

		private static Pen darkblue;

		private static Pen darkcyan;

		private static Pen darkgoldenrod;

		private static Pen darkgray;

		private static Pen darkgreen;

		private static Pen darkkhaki;

		private static Pen darkmagenta;

		private static Pen darkolivegreen;

		private static Pen darkorange;

		private static Pen darkorchid;

		private static Pen darkred;

		private static Pen darksalmon;

		private static Pen darkseagreen;

		private static Pen darkslateblue;

		private static Pen darkslategray;

		private static Pen darkturquoise;

		private static Pen darkviolet;

		private static Pen deeppink;

		private static Pen deepskyblue;

		private static Pen dimgray;

		private static Pen dodgerblue;

		private static Pen firebrick;

		private static Pen floralwhite;

		private static Pen forestgreen;

		private static Pen fuchsia;

		private static Pen gainsboro;

		private static Pen ghostwhite;

		private static Pen gold;

		private static Pen goldenrod;

		private static Pen gray;

		private static Pen green;

		private static Pen greenyellow;

		private static Pen honeydew;

		private static Pen hotpink;

		private static Pen indianred;

		private static Pen indigo;

		private static Pen ivory;

		private static Pen khaki;

		private static Pen lavender;

		private static Pen lavenderblush;

		private static Pen lawngreen;

		private static Pen lemonchiffon;

		private static Pen lightblue;

		private static Pen lightcoral;

		private static Pen lightcyan;

		private static Pen lightgoldenrodyellow;

		private static Pen lightgray;

		private static Pen lightgreen;

		private static Pen lightpink;

		private static Pen lightsalmon;

		private static Pen lightseagreen;

		private static Pen lightskyblue;

		private static Pen lightslategray;

		private static Pen lightsteelblue;

		private static Pen lightyellow;

		private static Pen lime;

		private static Pen limegreen;

		private static Pen linen;

		private static Pen magenta;

		private static Pen maroon;

		private static Pen mediumaquamarine;

		private static Pen mediumblue;

		private static Pen mediumorchid;

		private static Pen mediumpurple;

		private static Pen mediumseagreen;

		private static Pen mediumslateblue;

		private static Pen mediumspringgreen;

		private static Pen mediumturquoise;

		private static Pen mediumvioletred;

		private static Pen midnightblue;

		private static Pen mintcream;

		private static Pen mistyrose;

		private static Pen moccasin;

		private static Pen navajowhite;

		private static Pen navy;

		private static Pen oldlace;

		private static Pen olive;

		private static Pen olivedrab;

		private static Pen orange;

		private static Pen orangered;

		private static Pen orchid;

		private static Pen palegoldenrod;

		private static Pen palegreen;

		private static Pen paleturquoise;

		private static Pen palevioletred;

		private static Pen papayawhip;

		private static Pen peachpuff;

		private static Pen peru;

		private static Pen pink;

		private static Pen plum;

		private static Pen powderblue;

		private static Pen purple;

		private static Pen red;

		private static Pen rosybrown;

		private static Pen royalblue;

		private static Pen saddlebrown;

		private static Pen salmon;

		private static Pen sandybrown;

		private static Pen seagreen;

		private static Pen seashell;

		private static Pen sienna;

		private static Pen silver;

		private static Pen skyblue;

		private static Pen slateblue;

		private static Pen slategray;

		private static Pen snow;

		private static Pen springgreen;

		private static Pen steelblue;

		private static Pen tan;

		private static Pen teal;

		private static Pen thistle;

		private static Pen tomato;

		private static Pen transparent;

		private static Pen turquoise;

		private static Pen violet;

		private static Pen wheat;

		private static Pen white;

		private static Pen whitesmoke;

		private static Pen yellow;

		private static Pen yellowgreen;

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen AliceBlue
		{
			get
			{
				if (aliceblue == null)
				{
					aliceblue = new Pen(Color.AliceBlue);
					aliceblue.isModifiable = false;
				}
				return aliceblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen AntiqueWhite
		{
			get
			{
				if (antiquewhite == null)
				{
					antiquewhite = new Pen(Color.AntiqueWhite);
					antiquewhite.isModifiable = false;
				}
				return antiquewhite;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Aqua
		{
			get
			{
				if (aqua == null)
				{
					aqua = new Pen(Color.Aqua);
					aqua.isModifiable = false;
				}
				return aqua;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Aquamarine
		{
			get
			{
				if (aquamarine == null)
				{
					aquamarine = new Pen(Color.Aquamarine);
					aquamarine.isModifiable = false;
				}
				return aquamarine;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Azure
		{
			get
			{
				if (azure == null)
				{
					azure = new Pen(Color.Azure);
					azure.isModifiable = false;
				}
				return azure;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Beige
		{
			get
			{
				if (beige == null)
				{
					beige = new Pen(Color.Beige);
					beige.isModifiable = false;
				}
				return beige;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Bisque
		{
			get
			{
				if (bisque == null)
				{
					bisque = new Pen(Color.Bisque);
					bisque.isModifiable = false;
				}
				return bisque;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Black
		{
			get
			{
				if (black == null)
				{
					black = new Pen(Color.Black);
					black.isModifiable = false;
				}
				return black;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen BlanchedAlmond
		{
			get
			{
				if (blanchedalmond == null)
				{
					blanchedalmond = new Pen(Color.BlanchedAlmond);
					blanchedalmond.isModifiable = false;
				}
				return blanchedalmond;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Blue
		{
			get
			{
				if (blue == null)
				{
					blue = new Pen(Color.Blue);
					blue.isModifiable = false;
				}
				return blue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen BlueViolet
		{
			get
			{
				if (blueviolet == null)
				{
					blueviolet = new Pen(Color.BlueViolet);
					blueviolet.isModifiable = false;
				}
				return blueviolet;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Brown
		{
			get
			{
				if (brown == null)
				{
					brown = new Pen(Color.Brown);
					brown.isModifiable = false;
				}
				return brown;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen BurlyWood
		{
			get
			{
				if (burlywood == null)
				{
					burlywood = new Pen(Color.BurlyWood);
					burlywood.isModifiable = false;
				}
				return burlywood;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen CadetBlue
		{
			get
			{
				if (cadetblue == null)
				{
					cadetblue = new Pen(Color.CadetBlue);
					cadetblue.isModifiable = false;
				}
				return cadetblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Chartreuse
		{
			get
			{
				if (chartreuse == null)
				{
					chartreuse = new Pen(Color.Chartreuse);
					chartreuse.isModifiable = false;
				}
				return chartreuse;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Chocolate
		{
			get
			{
				if (chocolate == null)
				{
					chocolate = new Pen(Color.Chocolate);
					chocolate.isModifiable = false;
				}
				return chocolate;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Coral
		{
			get
			{
				if (coral == null)
				{
					coral = new Pen(Color.Coral);
					coral.isModifiable = false;
				}
				return coral;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen CornflowerBlue
		{
			get
			{
				if (cornflowerblue == null)
				{
					cornflowerblue = new Pen(Color.CornflowerBlue);
					cornflowerblue.isModifiable = false;
				}
				return cornflowerblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Cornsilk
		{
			get
			{
				if (cornsilk == null)
				{
					cornsilk = new Pen(Color.Cornsilk);
					cornsilk.isModifiable = false;
				}
				return cornsilk;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Crimson
		{
			get
			{
				if (crimson == null)
				{
					crimson = new Pen(Color.Crimson);
					crimson.isModifiable = false;
				}
				return crimson;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Cyan
		{
			get
			{
				if (cyan == null)
				{
					cyan = new Pen(Color.Cyan);
					cyan.isModifiable = false;
				}
				return cyan;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkBlue
		{
			get
			{
				if (darkblue == null)
				{
					darkblue = new Pen(Color.DarkBlue);
					darkblue.isModifiable = false;
				}
				return darkblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkCyan
		{
			get
			{
				if (darkcyan == null)
				{
					darkcyan = new Pen(Color.DarkCyan);
					darkcyan.isModifiable = false;
				}
				return darkcyan;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkGoldenrod
		{
			get
			{
				if (darkgoldenrod == null)
				{
					darkgoldenrod = new Pen(Color.DarkGoldenrod);
					darkgoldenrod.isModifiable = false;
				}
				return darkgoldenrod;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkGray
		{
			get
			{
				if (darkgray == null)
				{
					darkgray = new Pen(Color.DarkGray);
					darkgray.isModifiable = false;
				}
				return darkgray;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkGreen
		{
			get
			{
				if (darkgreen == null)
				{
					darkgreen = new Pen(Color.DarkGreen);
					darkgreen.isModifiable = false;
				}
				return darkgreen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkKhaki
		{
			get
			{
				if (darkkhaki == null)
				{
					darkkhaki = new Pen(Color.DarkKhaki);
					darkkhaki.isModifiable = false;
				}
				return darkkhaki;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkMagenta
		{
			get
			{
				if (darkmagenta == null)
				{
					darkmagenta = new Pen(Color.DarkMagenta);
					darkmagenta.isModifiable = false;
				}
				return darkmagenta;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkOliveGreen
		{
			get
			{
				if (darkolivegreen == null)
				{
					darkolivegreen = new Pen(Color.DarkOliveGreen);
					darkolivegreen.isModifiable = false;
				}
				return darkolivegreen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkOrange
		{
			get
			{
				if (darkorange == null)
				{
					darkorange = new Pen(Color.DarkOrange);
					darkorange.isModifiable = false;
				}
				return darkorange;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkOrchid
		{
			get
			{
				if (darkorchid == null)
				{
					darkorchid = new Pen(Color.DarkOrchid);
					darkorchid.isModifiable = false;
				}
				return darkorchid;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkRed
		{
			get
			{
				if (darkred == null)
				{
					darkred = new Pen(Color.DarkRed);
					darkred.isModifiable = false;
				}
				return darkred;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkSalmon
		{
			get
			{
				if (darksalmon == null)
				{
					darksalmon = new Pen(Color.DarkSalmon);
					darksalmon.isModifiable = false;
				}
				return darksalmon;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkSeaGreen
		{
			get
			{
				if (darkseagreen == null)
				{
					darkseagreen = new Pen(Color.DarkSeaGreen);
					darkseagreen.isModifiable = false;
				}
				return darkseagreen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkSlateBlue
		{
			get
			{
				if (darkslateblue == null)
				{
					darkslateblue = new Pen(Color.DarkSlateBlue);
					darkslateblue.isModifiable = false;
				}
				return darkslateblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkSlateGray
		{
			get
			{
				if (darkslategray == null)
				{
					darkslategray = new Pen(Color.DarkSlateGray);
					darkslategray.isModifiable = false;
				}
				return darkslategray;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkTurquoise
		{
			get
			{
				if (darkturquoise == null)
				{
					darkturquoise = new Pen(Color.DarkTurquoise);
					darkturquoise.isModifiable = false;
				}
				return darkturquoise;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkViolet
		{
			get
			{
				if (darkviolet == null)
				{
					darkviolet = new Pen(Color.DarkViolet);
					darkviolet.isModifiable = false;
				}
				return darkviolet;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DeepPink
		{
			get
			{
				if (deeppink == null)
				{
					deeppink = new Pen(Color.DeepPink);
					deeppink.isModifiable = false;
				}
				return deeppink;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DeepSkyBlue
		{
			get
			{
				if (deepskyblue == null)
				{
					deepskyblue = new Pen(Color.DeepSkyBlue);
					deepskyblue.isModifiable = false;
				}
				return deepskyblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DimGray
		{
			get
			{
				if (dimgray == null)
				{
					dimgray = new Pen(Color.DimGray);
					dimgray.isModifiable = false;
				}
				return dimgray;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DodgerBlue
		{
			get
			{
				if (dodgerblue == null)
				{
					dodgerblue = new Pen(Color.DodgerBlue);
					dodgerblue.isModifiable = false;
				}
				return dodgerblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Firebrick
		{
			get
			{
				if (firebrick == null)
				{
					firebrick = new Pen(Color.Firebrick);
					firebrick.isModifiable = false;
				}
				return firebrick;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen FloralWhite
		{
			get
			{
				if (floralwhite == null)
				{
					floralwhite = new Pen(Color.FloralWhite);
					floralwhite.isModifiable = false;
				}
				return floralwhite;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen ForestGreen
		{
			get
			{
				if (forestgreen == null)
				{
					forestgreen = new Pen(Color.ForestGreen);
					forestgreen.isModifiable = false;
				}
				return forestgreen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Fuchsia
		{
			get
			{
				if (fuchsia == null)
				{
					fuchsia = new Pen(Color.Fuchsia);
					fuchsia.isModifiable = false;
				}
				return fuchsia;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Gainsboro
		{
			get
			{
				if (gainsboro == null)
				{
					gainsboro = new Pen(Color.Gainsboro);
					gainsboro.isModifiable = false;
				}
				return gainsboro;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen GhostWhite
		{
			get
			{
				if (ghostwhite == null)
				{
					ghostwhite = new Pen(Color.GhostWhite);
					ghostwhite.isModifiable = false;
				}
				return ghostwhite;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Gold
		{
			get
			{
				if (gold == null)
				{
					gold = new Pen(Color.Gold);
					gold.isModifiable = false;
				}
				return gold;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Goldenrod
		{
			get
			{
				if (goldenrod == null)
				{
					goldenrod = new Pen(Color.Goldenrod);
					goldenrod.isModifiable = false;
				}
				return goldenrod;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Gray
		{
			get
			{
				if (gray == null)
				{
					gray = new Pen(Color.Gray);
					gray.isModifiable = false;
				}
				return gray;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Green
		{
			get
			{
				if (green == null)
				{
					green = new Pen(Color.Green);
					green.isModifiable = false;
				}
				return green;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen GreenYellow
		{
			get
			{
				if (greenyellow == null)
				{
					greenyellow = new Pen(Color.GreenYellow);
					greenyellow.isModifiable = false;
				}
				return greenyellow;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Honeydew
		{
			get
			{
				if (honeydew == null)
				{
					honeydew = new Pen(Color.Honeydew);
					honeydew.isModifiable = false;
				}
				return honeydew;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen HotPink
		{
			get
			{
				if (hotpink == null)
				{
					hotpink = new Pen(Color.HotPink);
					hotpink.isModifiable = false;
				}
				return hotpink;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen IndianRed
		{
			get
			{
				if (indianred == null)
				{
					indianred = new Pen(Color.IndianRed);
					indianred.isModifiable = false;
				}
				return indianred;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Indigo
		{
			get
			{
				if (indigo == null)
				{
					indigo = new Pen(Color.Indigo);
					indigo.isModifiable = false;
				}
				return indigo;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Ivory
		{
			get
			{
				if (ivory == null)
				{
					ivory = new Pen(Color.Ivory);
					ivory.isModifiable = false;
				}
				return ivory;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Khaki
		{
			get
			{
				if (khaki == null)
				{
					khaki = new Pen(Color.Khaki);
					khaki.isModifiable = false;
				}
				return khaki;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Lavender
		{
			get
			{
				if (lavender == null)
				{
					lavender = new Pen(Color.Lavender);
					lavender.isModifiable = false;
				}
				return lavender;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LavenderBlush
		{
			get
			{
				if (lavenderblush == null)
				{
					lavenderblush = new Pen(Color.LavenderBlush);
					lavenderblush.isModifiable = false;
				}
				return lavenderblush;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LawnGreen
		{
			get
			{
				if (lawngreen == null)
				{
					lawngreen = new Pen(Color.LawnGreen);
					lawngreen.isModifiable = false;
				}
				return lawngreen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LemonChiffon
		{
			get
			{
				if (lemonchiffon == null)
				{
					lemonchiffon = new Pen(Color.LemonChiffon);
					lemonchiffon.isModifiable = false;
				}
				return lemonchiffon;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightBlue
		{
			get
			{
				if (lightblue == null)
				{
					lightblue = new Pen(Color.LightBlue);
					lightblue.isModifiable = false;
				}
				return lightblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightCoral
		{
			get
			{
				if (lightcoral == null)
				{
					lightcoral = new Pen(Color.LightCoral);
					lightcoral.isModifiable = false;
				}
				return lightcoral;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightCyan
		{
			get
			{
				if (lightcyan == null)
				{
					lightcyan = new Pen(Color.LightCyan);
					lightcyan.isModifiable = false;
				}
				return lightcyan;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightGoldenrodYellow
		{
			get
			{
				if (lightgoldenrodyellow == null)
				{
					lightgoldenrodyellow = new Pen(Color.LightGoldenrodYellow);
					lightgoldenrodyellow.isModifiable = false;
				}
				return lightgoldenrodyellow;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightGray
		{
			get
			{
				if (lightgray == null)
				{
					lightgray = new Pen(Color.LightGray);
					lightgray.isModifiable = false;
				}
				return lightgray;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightGreen
		{
			get
			{
				if (lightgreen == null)
				{
					lightgreen = new Pen(Color.LightGreen);
					lightgreen.isModifiable = false;
				}
				return lightgreen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightPink
		{
			get
			{
				if (lightpink == null)
				{
					lightpink = new Pen(Color.LightPink);
					lightpink.isModifiable = false;
				}
				return lightpink;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightSalmon
		{
			get
			{
				if (lightsalmon == null)
				{
					lightsalmon = new Pen(Color.LightSalmon);
					lightsalmon.isModifiable = false;
				}
				return lightsalmon;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightSeaGreen
		{
			get
			{
				if (lightseagreen == null)
				{
					lightseagreen = new Pen(Color.LightSeaGreen);
					lightseagreen.isModifiable = false;
				}
				return lightseagreen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightSkyBlue
		{
			get
			{
				if (lightskyblue == null)
				{
					lightskyblue = new Pen(Color.LightSkyBlue);
					lightskyblue.isModifiable = false;
				}
				return lightskyblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightSlateGray
		{
			get
			{
				if (lightslategray == null)
				{
					lightslategray = new Pen(Color.LightSlateGray);
					lightslategray.isModifiable = false;
				}
				return lightslategray;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightSteelBlue
		{
			get
			{
				if (lightsteelblue == null)
				{
					lightsteelblue = new Pen(Color.LightSteelBlue);
					lightsteelblue.isModifiable = false;
				}
				return lightsteelblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightYellow
		{
			get
			{
				if (lightyellow == null)
				{
					lightyellow = new Pen(Color.LightYellow);
					lightyellow.isModifiable = false;
				}
				return lightyellow;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Lime
		{
			get
			{
				if (lime == null)
				{
					lime = new Pen(Color.Lime);
					lime.isModifiable = false;
				}
				return lime;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LimeGreen
		{
			get
			{
				if (limegreen == null)
				{
					limegreen = new Pen(Color.LimeGreen);
					limegreen.isModifiable = false;
				}
				return limegreen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Linen
		{
			get
			{
				if (linen == null)
				{
					linen = new Pen(Color.Linen);
					linen.isModifiable = false;
				}
				return linen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Magenta
		{
			get
			{
				if (magenta == null)
				{
					magenta = new Pen(Color.Magenta);
					magenta.isModifiable = false;
				}
				return magenta;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Maroon
		{
			get
			{
				if (maroon == null)
				{
					maroon = new Pen(Color.Maroon);
					maroon.isModifiable = false;
				}
				return maroon;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumAquamarine
		{
			get
			{
				if (mediumaquamarine == null)
				{
					mediumaquamarine = new Pen(Color.MediumAquamarine);
					mediumaquamarine.isModifiable = false;
				}
				return mediumaquamarine;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumBlue
		{
			get
			{
				if (mediumblue == null)
				{
					mediumblue = new Pen(Color.MediumBlue);
					mediumblue.isModifiable = false;
				}
				return mediumblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumOrchid
		{
			get
			{
				if (mediumorchid == null)
				{
					mediumorchid = new Pen(Color.MediumOrchid);
					mediumorchid.isModifiable = false;
				}
				return mediumorchid;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumPurple
		{
			get
			{
				if (mediumpurple == null)
				{
					mediumpurple = new Pen(Color.MediumPurple);
					mediumpurple.isModifiable = false;
				}
				return mediumpurple;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumSeaGreen
		{
			get
			{
				if (mediumseagreen == null)
				{
					mediumseagreen = new Pen(Color.MediumSeaGreen);
					mediumseagreen.isModifiable = false;
				}
				return mediumseagreen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumSlateBlue
		{
			get
			{
				if (mediumslateblue == null)
				{
					mediumslateblue = new Pen(Color.MediumSlateBlue);
					mediumslateblue.isModifiable = false;
				}
				return mediumslateblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumSpringGreen
		{
			get
			{
				if (mediumspringgreen == null)
				{
					mediumspringgreen = new Pen(Color.MediumSpringGreen);
					mediumspringgreen.isModifiable = false;
				}
				return mediumspringgreen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumTurquoise
		{
			get
			{
				if (mediumturquoise == null)
				{
					mediumturquoise = new Pen(Color.MediumTurquoise);
					mediumturquoise.isModifiable = false;
				}
				return mediumturquoise;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumVioletRed
		{
			get
			{
				if (mediumvioletred == null)
				{
					mediumvioletred = new Pen(Color.MediumVioletRed);
					mediumvioletred.isModifiable = false;
				}
				return mediumvioletred;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MidnightBlue
		{
			get
			{
				if (midnightblue == null)
				{
					midnightblue = new Pen(Color.MidnightBlue);
					midnightblue.isModifiable = false;
				}
				return midnightblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MintCream
		{
			get
			{
				if (mintcream == null)
				{
					mintcream = new Pen(Color.MintCream);
					mintcream.isModifiable = false;
				}
				return mintcream;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MistyRose
		{
			get
			{
				if (mistyrose == null)
				{
					mistyrose = new Pen(Color.MistyRose);
					mistyrose.isModifiable = false;
				}
				return mistyrose;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Moccasin
		{
			get
			{
				if (moccasin == null)
				{
					moccasin = new Pen(Color.Moccasin);
					moccasin.isModifiable = false;
				}
				return moccasin;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen NavajoWhite
		{
			get
			{
				if (navajowhite == null)
				{
					navajowhite = new Pen(Color.NavajoWhite);
					navajowhite.isModifiable = false;
				}
				return navajowhite;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Navy
		{
			get
			{
				if (navy == null)
				{
					navy = new Pen(Color.Navy);
					navy.isModifiable = false;
				}
				return navy;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen OldLace
		{
			get
			{
				if (oldlace == null)
				{
					oldlace = new Pen(Color.OldLace);
					oldlace.isModifiable = false;
				}
				return oldlace;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Olive
		{
			get
			{
				if (olive == null)
				{
					olive = new Pen(Color.Olive);
					olive.isModifiable = false;
				}
				return olive;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen OliveDrab
		{
			get
			{
				if (olivedrab == null)
				{
					olivedrab = new Pen(Color.OliveDrab);
					olivedrab.isModifiable = false;
				}
				return olivedrab;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Orange
		{
			get
			{
				if (orange == null)
				{
					orange = new Pen(Color.Orange);
					orange.isModifiable = false;
				}
				return orange;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen OrangeRed
		{
			get
			{
				if (orangered == null)
				{
					orangered = new Pen(Color.OrangeRed);
					orangered.isModifiable = false;
				}
				return orangered;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Orchid
		{
			get
			{
				if (orchid == null)
				{
					orchid = new Pen(Color.Orchid);
					orchid.isModifiable = false;
				}
				return orchid;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen PaleGoldenrod
		{
			get
			{
				if (palegoldenrod == null)
				{
					palegoldenrod = new Pen(Color.PaleGoldenrod);
					palegoldenrod.isModifiable = false;
				}
				return palegoldenrod;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen PaleGreen
		{
			get
			{
				if (palegreen == null)
				{
					palegreen = new Pen(Color.PaleGreen);
					palegreen.isModifiable = false;
				}
				return palegreen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen PaleTurquoise
		{
			get
			{
				if (paleturquoise == null)
				{
					paleturquoise = new Pen(Color.PaleTurquoise);
					paleturquoise.isModifiable = false;
				}
				return paleturquoise;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen PaleVioletRed
		{
			get
			{
				if (palevioletred == null)
				{
					palevioletred = new Pen(Color.PaleVioletRed);
					palevioletred.isModifiable = false;
				}
				return palevioletred;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen PapayaWhip
		{
			get
			{
				if (papayawhip == null)
				{
					papayawhip = new Pen(Color.PapayaWhip);
					papayawhip.isModifiable = false;
				}
				return papayawhip;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen PeachPuff
		{
			get
			{
				if (peachpuff == null)
				{
					peachpuff = new Pen(Color.PeachPuff);
					peachpuff.isModifiable = false;
				}
				return peachpuff;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Peru
		{
			get
			{
				if (peru == null)
				{
					peru = new Pen(Color.Peru);
					peru.isModifiable = false;
				}
				return peru;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Pink
		{
			get
			{
				if (pink == null)
				{
					pink = new Pen(Color.Pink);
					pink.isModifiable = false;
				}
				return pink;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Plum
		{
			get
			{
				if (plum == null)
				{
					plum = new Pen(Color.Plum);
					plum.isModifiable = false;
				}
				return plum;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen PowderBlue
		{
			get
			{
				if (powderblue == null)
				{
					powderblue = new Pen(Color.PowderBlue);
					powderblue.isModifiable = false;
				}
				return powderblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Purple
		{
			get
			{
				if (purple == null)
				{
					purple = new Pen(Color.Purple);
					purple.isModifiable = false;
				}
				return purple;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Red
		{
			get
			{
				if (red == null)
				{
					red = new Pen(Color.Red);
					red.isModifiable = false;
				}
				return red;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen RosyBrown
		{
			get
			{
				if (rosybrown == null)
				{
					rosybrown = new Pen(Color.RosyBrown);
					rosybrown.isModifiable = false;
				}
				return rosybrown;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen RoyalBlue
		{
			get
			{
				if (royalblue == null)
				{
					royalblue = new Pen(Color.RoyalBlue);
					royalblue.isModifiable = false;
				}
				return royalblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SaddleBrown
		{
			get
			{
				if (saddlebrown == null)
				{
					saddlebrown = new Pen(Color.SaddleBrown);
					saddlebrown.isModifiable = false;
				}
				return saddlebrown;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Salmon
		{
			get
			{
				if (salmon == null)
				{
					salmon = new Pen(Color.Salmon);
					salmon.isModifiable = false;
				}
				return salmon;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SandyBrown
		{
			get
			{
				if (sandybrown == null)
				{
					sandybrown = new Pen(Color.SandyBrown);
					sandybrown.isModifiable = false;
				}
				return sandybrown;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SeaGreen
		{
			get
			{
				if (seagreen == null)
				{
					seagreen = new Pen(Color.SeaGreen);
					seagreen.isModifiable = false;
				}
				return seagreen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SeaShell
		{
			get
			{
				if (seashell == null)
				{
					seashell = new Pen(Color.SeaShell);
					seashell.isModifiable = false;
				}
				return seashell;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Sienna
		{
			get
			{
				if (sienna == null)
				{
					sienna = new Pen(Color.Sienna);
					sienna.isModifiable = false;
				}
				return sienna;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Silver
		{
			get
			{
				if (silver == null)
				{
					silver = new Pen(Color.Silver);
					silver.isModifiable = false;
				}
				return silver;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SkyBlue
		{
			get
			{
				if (skyblue == null)
				{
					skyblue = new Pen(Color.SkyBlue);
					skyblue.isModifiable = false;
				}
				return skyblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SlateBlue
		{
			get
			{
				if (slateblue == null)
				{
					slateblue = new Pen(Color.SlateBlue);
					slateblue.isModifiable = false;
				}
				return slateblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SlateGray
		{
			get
			{
				if (slategray == null)
				{
					slategray = new Pen(Color.SlateGray);
					slategray.isModifiable = false;
				}
				return slategray;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Snow
		{
			get
			{
				if (snow == null)
				{
					snow = new Pen(Color.Snow);
					snow.isModifiable = false;
				}
				return snow;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SpringGreen
		{
			get
			{
				if (springgreen == null)
				{
					springgreen = new Pen(Color.SpringGreen);
					springgreen.isModifiable = false;
				}
				return springgreen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SteelBlue
		{
			get
			{
				if (steelblue == null)
				{
					steelblue = new Pen(Color.SteelBlue);
					steelblue.isModifiable = false;
				}
				return steelblue;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Tan
		{
			get
			{
				if (tan == null)
				{
					tan = new Pen(Color.Tan);
					tan.isModifiable = false;
				}
				return tan;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Teal
		{
			get
			{
				if (teal == null)
				{
					teal = new Pen(Color.Teal);
					teal.isModifiable = false;
				}
				return teal;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Thistle
		{
			get
			{
				if (thistle == null)
				{
					thistle = new Pen(Color.Thistle);
					thistle.isModifiable = false;
				}
				return thistle;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Tomato
		{
			get
			{
				if (tomato == null)
				{
					tomato = new Pen(Color.Tomato);
					tomato.isModifiable = false;
				}
				return tomato;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Transparent
		{
			get
			{
				if (transparent == null)
				{
					transparent = new Pen(Color.Transparent);
					transparent.isModifiable = false;
				}
				return transparent;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Turquoise
		{
			get
			{
				if (turquoise == null)
				{
					turquoise = new Pen(Color.Turquoise);
					turquoise.isModifiable = false;
				}
				return turquoise;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Violet
		{
			get
			{
				if (violet == null)
				{
					violet = new Pen(Color.Violet);
					violet.isModifiable = false;
				}
				return violet;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Wheat
		{
			get
			{
				if (wheat == null)
				{
					wheat = new Pen(Color.Wheat);
					wheat.isModifiable = false;
				}
				return wheat;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen White
		{
			get
			{
				if (white == null)
				{
					white = new Pen(Color.White);
					white.isModifiable = false;
				}
				return white;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen WhiteSmoke
		{
			get
			{
				if (whitesmoke == null)
				{
					whitesmoke = new Pen(Color.WhiteSmoke);
					whitesmoke.isModifiable = false;
				}
				return whitesmoke;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Yellow
		{
			get
			{
				if (yellow == null)
				{
					yellow = new Pen(Color.Yellow);
					yellow.isModifiable = false;
				}
				return yellow;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen YellowGreen
		{
			get
			{
				if (yellowgreen == null)
				{
					yellowgreen = new Pen(Color.YellowGreen);
					yellowgreen.isModifiable = false;
				}
				return yellowgreen;
			}
		}

		private Pens()
		{
		}
	}
	/// <summary>Represents an ordered pair of integer x- and y-coordinates that defines a point in a two-dimensional plane.</summary>
	[Serializable]
	[ComVisible(true)]
	[TypeConverter(typeof(PointConverter))]
	public struct Point
	{
		private int x;

		private int y;

		/// <summary>Represents a <see cref="T:System.Drawing.Point" /> that has <see cref="P:System.Drawing.Point.X" /> and <see cref="P:System.Drawing.Point.Y" /> values set to zero.</summary>
		public static readonly Point Empty;

		/// <summary>Gets a value indicating whether this <see cref="T:System.Drawing.Point" /> is empty.</summary>
		/// <returns>
		///   <see langword="true" /> if both <see cref="P:System.Drawing.Point.X" /> and <see cref="P:System.Drawing.Point.Y" /> are 0; otherwise, <see langword="false" />.</returns>
		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (x == 0)
				{
					return y == 0;
				}
				return false;
			}
		}

		/// <summary>Gets or sets the x-coordinate of this <see cref="T:System.Drawing.Point" />.</summary>
		/// <returns>The x-coordinate of this <see cref="T:System.Drawing.Point" />.</returns>
		public int X
		{
			get
			{
				return x;
			}
			set
			{
				x = value;
			}
		}

		/// <summary>Gets or sets the y-coordinate of this <see cref="T:System.Drawing.Point" />.</summary>
		/// <returns>The y-coordinate of this <see cref="T:System.Drawing.Point" />.</returns>
		public int Y
		{
			get
			{
				return y;
			}
			set
			{
				y = value;
			}
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.PointF" /> to a <see cref="T:System.Drawing.Point" /> by rounding the values of the <see cref="T:System.Drawing.PointF" /> to the next higher integer values.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.PointF" /> to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.Point" /> this method converts to.</returns>
		public static Point Ceiling(PointF value)
		{
			checked
			{
				int num = (int)Math.Ceiling(value.X);
				int num2 = (int)Math.Ceiling(value.Y);
				return new Point(num, num2);
			}
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.PointF" /> to a <see cref="T:System.Drawing.Point" /> object by rounding the <see cref="T:System.Drawing.Point" /> values to the nearest integer.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.PointF" /> to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.Point" /> this method converts to.</returns>
		public static Point Round(PointF value)
		{
			checked
			{
				int num = (int)Math.Round(value.X);
				int num2 = (int)Math.Round(value.Y);
				return new Point(num, num2);
			}
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.PointF" /> to a <see cref="T:System.Drawing.Point" /> by truncating the values of the <see cref="T:System.Drawing.Point" />.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.PointF" /> to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.Point" /> this method converts to.</returns>
		public static Point Truncate(PointF value)
		{
			checked
			{
				int num = (int)value.X;
				int num2 = (int)value.Y;
				return new Point(num, num2);
			}
		}

		/// <summary>Translates a <see cref="T:System.Drawing.Point" /> by a given <see cref="T:System.Drawing.Size" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.Point" /> to translate.</param>
		/// <param name="sz">A <see cref="T:System.Drawing.Size" /> that specifies the pair of numbers to add to the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.Point" />.</returns>
		public static Point operator +(Point pt, Size sz)
		{
			return new Point(pt.X + sz.Width, pt.Y + sz.Height);
		}

		/// <summary>Compares two <see cref="T:System.Drawing.Point" /> objects. The result specifies whether the values of the <see cref="P:System.Drawing.Point.X" /> and <see cref="P:System.Drawing.Point.Y" /> properties of the two <see cref="T:System.Drawing.Point" /> objects are equal.</summary>
		/// <param name="left">A <see cref="T:System.Drawing.Point" /> to compare.</param>
		/// <param name="right">A <see cref="T:System.Drawing.Point" /> to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="P:System.Drawing.Point.X" /> and <see cref="P:System.Drawing.Point.Y" /> values of <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(Point left, Point right)
		{
			if (left.X == right.X)
			{
				return left.Y == right.Y;
			}
			return false;
		}

		/// <summary>Compares two <see cref="T:System.Drawing.Point" /> objects. The result specifies whether the values of the <see cref="P:System.Drawing.Point.X" /> or <see cref="P:System.Drawing.Point.Y" /> properties of the two <see cref="T:System.Drawing.Point" /> objects are unequal.</summary>
		/// <param name="left">A <see cref="T:System.Drawing.Point" /> to compare.</param>
		/// <param name="right">A <see cref="T:System.Drawing.Point" /> to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the values of either the <see cref="P:System.Drawing.Point.X" /> properties or the <see cref="P:System.Drawing.Point.Y" /> properties of <paramref name="left" /> and <paramref name="right" /> differ; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(Point left, Point right)
		{
			if (left.X == right.X)
			{
				return left.Y != right.Y;
			}
			return true;
		}

		/// <summary>Translates a <see cref="T:System.Drawing.Point" /> by the negative of a given <see cref="T:System.Drawing.Size" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.Point" /> to translate.</param>
		/// <param name="sz">A <see cref="T:System.Drawing.Size" /> that specifies the pair of numbers to subtract from the coordinates of <paramref name="pt" />.</param>
		/// <returns>A <see cref="T:System.Drawing.Point" /> structure that is translated by the negative of a given <see cref="T:System.Drawing.Size" /> structure.</returns>
		public static Point operator -(Point pt, Size sz)
		{
			return new Point(pt.X - sz.Width, pt.Y - sz.Height);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.Point" /> structure to a <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <param name="p">The <see cref="T:System.Drawing.Point" /> to be converted.</param>
		/// <returns>The <see cref="T:System.Drawing.Size" /> that results from the conversion.</returns>
		public static explicit operator Size(Point p)
		{
			return new Size(p.X, p.Y);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.Point" /> structure to a <see cref="T:System.Drawing.PointF" /> structure.</summary>
		/// <param name="p">The <see cref="T:System.Drawing.Point" /> to be converted.</param>
		/// <returns>The <see cref="T:System.Drawing.PointF" /> that results from the conversion.</returns>
		public static implicit operator PointF(Point p)
		{
			return new PointF(p.X, p.Y);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Point" /> class using coordinates specified by an integer value.</summary>
		/// <param name="dw">A 32-bit integer that specifies the coordinates for the new <see cref="T:System.Drawing.Point" />.</param>
		public Point(int dw)
		{
			y = dw >> 16;
			x = (short)(dw & 0xFFFF);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Point" /> class from a <see cref="T:System.Drawing.Size" />.</summary>
		/// <param name="sz">A <see cref="T:System.Drawing.Size" /> that specifies the coordinates for the new <see cref="T:System.Drawing.Point" />.</param>
		public Point(Size sz)
		{
			x = sz.Width;
			y = sz.Height;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Point" /> class with the specified coordinates.</summary>
		/// <param name="x">The horizontal position of the point.</param>
		/// <param name="y">The vertical position of the point.</param>
		public Point(int x, int y)
		{
			this.x = x;
			this.y = y;
		}

		/// <summary>Specifies whether this <see cref="T:System.Drawing.Point" /> contains the same coordinates as the specified <see cref="T:System.Object" />.</summary>
		/// <param name="obj">The <see cref="T:System.Object" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.Point" /> and has the same coordinates as this <see cref="T:System.Drawing.Point" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is Point))
			{
				return false;
			}
			return this == (Point)obj;
		}

		/// <summary>Returns a hash code for this <see cref="T:System.Drawing.Point" />.</summary>
		/// <returns>An integer value that specifies a hash value for this <see cref="T:System.Drawing.Point" />.</returns>
		public override int GetHashCode()
		{
			return x ^ y;
		}

		/// <summary>Translates this <see cref="T:System.Drawing.Point" /> by the specified amount.</summary>
		/// <param name="dx">The amount to offset the x-coordinate.</param>
		/// <param name="dy">The amount to offset the y-coordinate.</param>
		public void Offset(int dx, int dy)
		{
			x += dx;
			y += dy;
		}

		/// <summary>Converts this <see cref="T:System.Drawing.Point" /> to a human-readable string.</summary>
		/// <returns>A string that represents this <see cref="T:System.Drawing.Point" />.</returns>
		public override string ToString()
		{
			return $"{{X={x.ToString(CultureInfo.InvariantCulture)},Y={y.ToString(CultureInfo.InvariantCulture)}}}";
		}

		/// <summary>Adds the specified <see cref="T:System.Drawing.Size" /> to the specified <see cref="T:System.Drawing.Point" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.Point" /> to add.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.Size" /> to add</param>
		/// <returns>The <see cref="T:System.Drawing.Point" /> that is the result of the addition operation.</returns>
		public static Point Add(Point pt, Size sz)
		{
			return new Point(pt.X + sz.Width, pt.Y + sz.Height);
		}

		/// <summary>Translates this <see cref="T:System.Drawing.Point" /> by the specified <see cref="T:System.Drawing.Point" />.</summary>
		/// <param name="p">The <see cref="T:System.Drawing.Point" /> used offset this <see cref="T:System.Drawing.Point" />.</param>
		public void Offset(Point p)
		{
			Offset(p.X, p.Y);
		}

		/// <summary>Returns the result of subtracting specified <see cref="T:System.Drawing.Size" /> from the specified <see cref="T:System.Drawing.Point" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.Point" /> to be subtracted from.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.Size" /> to subtract from the <see cref="T:System.Drawing.Point" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Point" /> that is the result of the subtraction operation.</returns>
		public static Point Subtract(Point pt, Size sz)
		{
			return new Point(pt.X - sz.Width, pt.Y - sz.Height);
		}
	}
	/// <summary>Converts a <see cref="T:System.Drawing.Point" /> object from one data type to another.</summary>
	public class PointConverter : TypeConverter
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.PointConverter" /> class.</summary>
		public PointConverter()
		{
		}

		/// <summary>Determines if this converter can convert an object in the given source type to the native type of the converter.</summary>
		/// <param name="context">A formatter context. This object can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="sourceType">The type you want to convert from.</param>
		/// <returns>
		///   <see langword="true" /> if this object can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Gets a value indicating whether this converter can convert an object to the given destination type using the context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> object that provides a format context.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> object that represents the type you want to convert to.</param>
		/// <returns>
		///   <see langword="true" /> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(string))
			{
				return true;
			}
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts the specified object to a <see cref="T:System.Drawing.Point" /> object.</summary>
		/// <param name="context">A formatter context. This object can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">An object that contains culture specific information, such as the language, calendar, and cultural conventions associated with a specific culture. It is based on the RFC 1766 standard.</param>
		/// <param name="value">The object to convert.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (culture == null)
			{
				culture = CultureInfo.CurrentCulture;
			}
			if (!(value is string text))
			{
				return base.ConvertFrom(context, culture, value);
			}
			string[] array = text.Split(culture.TextInfo.ListSeparator.ToCharArray());
			Int32Converter int32Converter = new Int32Converter();
			int[] array2 = new int[array.Length];
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = (int)int32Converter.ConvertFromString(context, culture, array[i]);
			}
			if (array.Length != 2)
			{
				throw new ArgumentException("Failed to parse Text(" + text + ") expected text in the format \"x, y.\"");
			}
			return new Point(array2[0], array2[1]);
		}

		/// <summary>Converts the specified object to the specified type.</summary>
		/// <param name="context">A formatter context. This object can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">An object that contains culture specific information, such as the language, calendar, and cultural conventions associated with a specific culture. It is based on the RFC 1766 standard.</param>
		/// <param name="value">The object to convert.</param>
		/// <param name="destinationType">The type to convert the object to.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (culture == null)
			{
				culture = CultureInfo.CurrentCulture;
			}
			if (value is Point point)
			{
				if (destinationType == typeof(string))
				{
					return point.X.ToString(culture) + culture.TextInfo.ListSeparator + " " + point.Y.ToString(culture);
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					return new InstanceDescriptor(typeof(Point).GetConstructor(new Type[2]
					{
						typeof(int),
						typeof(int)
					}), new object[2] { point.X, point.Y });
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <summary>Creates an instance of this type given a set of property values for the object.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <param name="propertyValues">A dictionary of new property values. The dictionary contains a series of name-value pairs, one for each property returned from <see cref="M:System.Drawing.PointConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object,System.Attribute[])" />.</param>
		/// <returns>The newly created object, or <see langword="null" /> if the object could not be created. The default implementation returns <see langword="null" />.</returns>
		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			object obj = propertyValues["X"];
			object obj2 = propertyValues["Y"];
			if (obj == null || obj2 == null)
			{
				throw new ArgumentException("propertyValues");
			}
			int x = (int)obj;
			int y = (int)obj2;
			return new Point(x, y);
		}

		/// <summary>Determines if changing a value on this object should require a call to <see cref="M:System.Drawing.PointConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> to create a new value.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> through which additional context can be provided.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="M:System.Drawing.PointConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> method should be called when a change is made to one or more properties of this object; otherwise, <see langword="false" />.</returns>
		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Retrieves the set of properties for this type. By default, a type does not return any properties.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <param name="value">The value of the object to get the properties for.</param>
		/// <param name="attributes">An array of <see cref="T:System.Attribute" /> objects that describe the properties.</param>
		/// <returns>The set of properties that are exposed for this data type. If no properties are exposed, this method might return <see langword="null" />. The default implementation always returns <see langword="null" />.</returns>
		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			if (value is Point)
			{
				return TypeDescriptor.GetProperties(value, attributes);
			}
			return base.GetProperties(context, value, attributes);
		}

		/// <summary>Determines if this object supports properties. By default, this is <see langword="false" />.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> through which additional context can be provided.</param>
		/// <returns>
		///   <see langword="true" /> if <see cref="M:System.Drawing.PointConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object,System.Attribute[])" /> should be called to find the properties of this object; otherwise, <see langword="false" />.</returns>
		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
	/// <summary>Represents an ordered pair of floating-point x- and y-coordinates that defines a point in a two-dimensional plane.</summary>
	[Serializable]
	[ComVisible(true)]
	public struct PointF
	{
		private float x;

		private float y;

		/// <summary>Represents a new instance of the <see cref="T:System.Drawing.PointF" /> class with member data left uninitialized.</summary>
		public static readonly PointF Empty;

		/// <summary>Gets a value indicating whether this <see cref="T:System.Drawing.PointF" /> is empty.</summary>
		/// <returns>
		///   <see langword="true" /> if both <see cref="P:System.Drawing.PointF.X" /> and <see cref="P:System.Drawing.PointF.Y" /> are 0; otherwise, <see langword="false" />.</returns>
		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if ((double)x == 0.0)
				{
					return (double)y == 0.0;
				}
				return false;
			}
		}

		/// <summary>Gets or sets the x-coordinate of this <see cref="T:System.Drawing.PointF" />.</summary>
		/// <returns>The x-coordinate of this <see cref="T:System.Drawing.PointF" />.</returns>
		public float X
		{
			get
			{
				return x;
			}
			set
			{
				x = value;
			}
		}

		/// <summary>Gets or sets the y-coordinate of this <see cref="T:System.Drawing.PointF" />.</summary>
		/// <returns>The y-coordinate of this <see cref="T:System.Drawing.PointF" />.</returns>
		public float Y
		{
			get
			{
				return y;
			}
			set
			{
				y = value;
			}
		}

		/// <summary>Translates a <see cref="T:System.Drawing.PointF" /> by a given <see cref="T:System.Drawing.Size" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">A <see cref="T:System.Drawing.Size" /> that specifies the pair of numbers to add to the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF operator +(PointF pt, Size sz)
		{
			return new PointF(pt.X + (float)sz.Width, pt.Y + (float)sz.Height);
		}

		/// <summary>Translates the <see cref="T:System.Drawing.PointF" /> by the specified <see cref="T:System.Drawing.SizeF" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.SizeF" /> that specifies the numbers to add to the x- and y-coordinates of the <see cref="T:System.Drawing.PointF" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF operator +(PointF pt, SizeF sz)
		{
			return new PointF(pt.X + sz.Width, pt.Y + sz.Height);
		}

		/// <summary>Compares two <see cref="T:System.Drawing.PointF" /> structures. The result specifies whether the values of the <see cref="P:System.Drawing.PointF.X" /> and <see cref="P:System.Drawing.PointF.Y" /> properties of the two <see cref="T:System.Drawing.PointF" /> structures are equal.</summary>
		/// <param name="left">A <see cref="T:System.Drawing.PointF" /> to compare.</param>
		/// <param name="right">A <see cref="T:System.Drawing.PointF" /> to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="P:System.Drawing.PointF.X" /> and <see cref="P:System.Drawing.PointF.Y" /> values of the left and right <see cref="T:System.Drawing.PointF" /> structures are equal; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(PointF left, PointF right)
		{
			if (left.X == right.X)
			{
				return left.Y == right.Y;
			}
			return false;
		}

		/// <summary>Determines whether the coordinates of the specified points are not equal.</summary>
		/// <param name="left">A <see cref="T:System.Drawing.PointF" /> to compare.</param>
		/// <param name="right">A <see cref="T:System.Drawing.PointF" /> to compare.</param>
		/// <returns>
		///   <see langword="true" /> to indicate the <see cref="P:System.Drawing.PointF.X" /> and <see cref="P:System.Drawing.PointF.Y" /> values of <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(PointF left, PointF right)
		{
			if (left.X == right.X)
			{
				return left.Y != right.Y;
			}
			return true;
		}

		/// <summary>Translates a <see cref="T:System.Drawing.PointF" /> by the negative of a given <see cref="T:System.Drawing.Size" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.Size" /> that specifies the numbers to subtract from the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF operator -(PointF pt, Size sz)
		{
			return new PointF(pt.X - (float)sz.Width, pt.Y - (float)sz.Height);
		}

		/// <summary>Translates a <see cref="T:System.Drawing.PointF" /> by the negative of a specified <see cref="T:System.Drawing.SizeF" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.SizeF" /> that specifies the numbers to subtract from the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF operator -(PointF pt, SizeF sz)
		{
			return new PointF(pt.X - sz.Width, pt.Y - sz.Height);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.PointF" /> class with the specified coordinates.</summary>
		/// <param name="x">The horizontal position of the point.</param>
		/// <param name="y">The vertical position of the point.</param>
		public PointF(float x, float y)
		{
			this.x = x;
			this.y = y;
		}

		/// <summary>Specifies whether this <see cref="T:System.Drawing.PointF" /> contains the same coordinates as the specified <see cref="T:System.Object" />.</summary>
		/// <param name="obj">The <see cref="T:System.Object" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.PointF" /> and has the same coordinates as this <see cref="T:System.Drawing.Point" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is PointF))
			{
				return false;
			}
			return this == (PointF)obj;
		}

		/// <summary>Returns a hash code for this <see cref="T:System.Drawing.PointF" /> structure.</summary>
		/// <returns>An integer value that specifies a hash value for this <see cref="T:System.Drawing.PointF" /> structure.</returns>
		public override int GetHashCode()
		{
			return (int)x ^ (int)y;
		}

		/// <summary>Converts this <see cref="T:System.Drawing.PointF" /> to a human readable string.</summary>
		/// <returns>A string that represents this <see cref="T:System.Drawing.PointF" />.</returns>
		public override string ToString()
		{
			return $"{{X={x.ToString(CultureInfo.CurrentCulture)}, Y={y.ToString(CultureInfo.CurrentCulture)}}}";
		}

		/// <summary>Translates a given <see cref="T:System.Drawing.PointF" /> by the specified <see cref="T:System.Drawing.Size" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.Size" /> that specifies the numbers to add to the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF Add(PointF pt, Size sz)
		{
			return new PointF(pt.X + (float)sz.Width, pt.Y + (float)sz.Height);
		}

		/// <summary>Translates a given <see cref="T:System.Drawing.PointF" /> by a specified <see cref="T:System.Drawing.SizeF" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.SizeF" /> that specifies the numbers to add to the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF Add(PointF pt, SizeF sz)
		{
			return new PointF(pt.X + sz.Width, pt.Y + sz.Height);
		}

		/// <summary>Translates a <see cref="T:System.Drawing.PointF" /> by the negative of a specified size.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.Size" /> that specifies the numbers to subtract from the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF Subtract(PointF pt, Size sz)
		{
			return new PointF(pt.X - (float)sz.Width, pt.Y - (float)sz.Height);
		}

		/// <summary>Translates a <see cref="T:System.Drawing.PointF" /> by the negative of a specified size.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.SizeF" /> that specifies the numbers to subtract from the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF Subtract(PointF pt, SizeF sz)
		{
			return new PointF(pt.X - sz.Width, pt.Y - sz.Height);
		}
	}
	/// <summary>Stores a set of four integers that represent the location and size of a rectangle</summary>
	[Serializable]
	[TypeConverter(typeof(RectangleConverter))]
	[ComVisible(true)]
	public struct Rectangle
	{
		private int x;

		private int y;

		private int width;

		private int height;

		/// <summary>Represents a <see cref="T:System.Drawing.Rectangle" /> structure with its properties left uninitialized.</summary>
		public static readonly Rectangle Empty;

		/// <summary>Gets the y-coordinate that is the sum of the <see cref="P:System.Drawing.Rectangle.Y" /> and <see cref="P:System.Drawing.Rectangle.Height" /> property values of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The y-coordinate that is the sum of <see cref="P:System.Drawing.Rectangle.Y" /> and <see cref="P:System.Drawing.Rectangle.Height" /> of this <see cref="T:System.Drawing.Rectangle" />.</returns>
		[Browsable(false)]
		public int Bottom => y + height;

		/// <summary>Gets or sets the height of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The height of this <see cref="T:System.Drawing.Rectangle" /> structure. The default is 0.</returns>
		public int Height
		{
			get
			{
				return height;
			}
			set
			{
				height = value;
			}
		}

		/// <summary>Tests whether all numeric properties of this <see cref="T:System.Drawing.Rectangle" /> have values of zero.</summary>
		/// <returns>This property returns <see langword="true" /> if the <see cref="P:System.Drawing.Rectangle.Width" />, <see cref="P:System.Drawing.Rectangle.Height" />, <see cref="P:System.Drawing.Rectangle.X" />, and <see cref="P:System.Drawing.Rectangle.Y" /> properties of this <see cref="T:System.Drawing.Rectangle" /> all have values of zero; otherwise, <see langword="false" />.</returns>
		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (x == 0 && y == 0 && width == 0)
				{
					return height == 0;
				}
				return false;
			}
		}

		/// <summary>Gets the x-coordinate of the left edge of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The x-coordinate of the left edge of this <see cref="T:System.Drawing.Rectangle" /> structure.</returns>
		[Browsable(false)]
		public int Left => X;

		/// <summary>Gets or sets the coordinates of the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>A <see cref="T:System.Drawing.Point" /> that represents the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</returns>
		[Browsable(false)]
		public Point Location
		{
			get
			{
				return new Point(x, y);
			}
			set
			{
				x = value.X;
				y = value.Y;
			}
		}

		/// <summary>Gets the x-coordinate that is the sum of <see cref="P:System.Drawing.Rectangle.X" /> and <see cref="P:System.Drawing.Rectangle.Width" /> property values of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The x-coordinate that is the sum of <see cref="P:System.Drawing.Rectangle.X" /> and <see cref="P:System.Drawing.Rectangle.Width" /> of this <see cref="T:System.Drawing.Rectangle" />.</returns>
		[Browsable(false)]
		public int Right => X + Width;

		/// <summary>Gets or sets the size of this <see cref="T:System.Drawing.Rectangle" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Size" /> that represents the width and height of this <see cref="T:System.Drawing.Rectangle" /> structure.</returns>
		[Browsable(false)]
		public Size Size
		{
			get
			{
				return new Size(Width, Height);
			}
			set
			{
				Width = value.Width;
				Height = value.Height;
			}
		}

		/// <summary>Gets the y-coordinate of the top edge of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The y-coordinate of the top edge of this <see cref="T:System.Drawing.Rectangle" /> structure.</returns>
		[Browsable(false)]
		public int Top => y;

		/// <summary>Gets or sets the width of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The width of this <see cref="T:System.Drawing.Rectangle" /> structure. The default is 0.</returns>
		public int Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		/// <summary>Gets or sets the x-coordinate of the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The x-coordinate of the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure. The default is 0.</returns>
		public int X
		{
			get
			{
				return x;
			}
			set
			{
				x = value;
			}
		}

		/// <summary>Gets or sets the y-coordinate of the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The y-coordinate of the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure. The default is 0.</returns>
		public int Y
		{
			get
			{
				return y;
			}
			set
			{
				y = value;
			}
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.RectangleF" /> structure to a <see cref="T:System.Drawing.Rectangle" /> structure by rounding the <see cref="T:System.Drawing.RectangleF" /> values to the next higher integer values.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.RectangleF" /> structure to be converted.</param>
		/// <returns>Returns a <see cref="T:System.Drawing.Rectangle" />.</returns>
		public static Rectangle Ceiling(RectangleF value)
		{
			checked
			{
				int num = (int)Math.Ceiling(value.X);
				int num2 = (int)Math.Ceiling(value.Y);
				int num3 = (int)Math.Ceiling(value.Width);
				int num4 = (int)Math.Ceiling(value.Height);
				return new Rectangle(num, num2, num3, num4);
			}
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Rectangle" /> structure with the specified edge locations.</summary>
		/// <param name="left">The x-coordinate of the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</param>
		/// <param name="top">The y-coordinate of the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</param>
		/// <param name="right">The x-coordinate of the lower-right corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</param>
		/// <param name="bottom">The y-coordinate of the lower-right corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</param>
		/// <returns>The new <see cref="T:System.Drawing.Rectangle" /> that this method creates.</returns>
		public static Rectangle FromLTRB(int left, int top, int right, int bottom)
		{
			return new Rectangle(left, top, right - left, bottom - top);
		}

		/// <summary>Creates and returns an enlarged copy of the specified <see cref="T:System.Drawing.Rectangle" /> structure. The copy is enlarged by the specified amount. The original <see cref="T:System.Drawing.Rectangle" /> structure remains unmodified.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> with which to start. This rectangle is not modified.</param>
		/// <param name="x">The amount to inflate this <see cref="T:System.Drawing.Rectangle" /> horizontally.</param>
		/// <param name="y">The amount to inflate this <see cref="T:System.Drawing.Rectangle" /> vertically.</param>
		/// <returns>The enlarged <see cref="T:System.Drawing.Rectangle" />.</returns>
		public static Rectangle Inflate(Rectangle rect, int x, int y)
		{
			Rectangle result = new Rectangle(rect.Location, rect.Size);
			result.Inflate(x, y);
			return result;
		}

		/// <summary>Enlarges this <see cref="T:System.Drawing.Rectangle" /> by the specified amount.</summary>
		/// <param name="width">The amount to inflate this <see cref="T:System.Drawing.Rectangle" /> horizontally.</param>
		/// <param name="height">The amount to inflate this <see cref="T:System.Drawing.Rectangle" /> vertically.</param>
		public void Inflate(int width, int height)
		{
			Inflate(new Size(width, height));
		}

		/// <summary>Enlarges this <see cref="T:System.Drawing.Rectangle" /> by the specified amount.</summary>
		/// <param name="size">The amount to inflate this rectangle.</param>
		public void Inflate(Size size)
		{
			x -= size.Width;
			y -= size.Height;
			Width += size.Width * 2;
			Height += size.Height * 2;
		}

		/// <summary>Returns a third <see cref="T:System.Drawing.Rectangle" /> structure that represents the intersection of two other <see cref="T:System.Drawing.Rectangle" /> structures. If there is no intersection, an empty <see cref="T:System.Drawing.Rectangle" /> is returned.</summary>
		/// <param name="a">A rectangle to intersect.</param>
		/// <param name="b">A rectangle to intersect.</param>
		/// <returns>A <see cref="T:System.Drawing.Rectangle" /> that represents the intersection of <paramref name="a" /> and <paramref name="b" />.</returns>
		public static Rectangle Intersect(Rectangle a, Rectangle b)
		{
			if (!a.IntersectsWithInclusive(b))
			{
				return Empty;
			}
			return FromLTRB(Math.Max(a.Left, b.Left), Math.Max(a.Top, b.Top), Math.Min(a.Right, b.Right), Math.Min(a.Bottom, b.Bottom));
		}

		/// <summary>Replaces this <see cref="T:System.Drawing.Rectangle" /> with the intersection of itself and the specified <see cref="T:System.Drawing.Rectangle" />.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> with which to intersect.</param>
		public void Intersect(Rectangle rect)
		{
			this = Intersect(this, rect);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.RectangleF" /> to a <see cref="T:System.Drawing.Rectangle" /> by rounding the <see cref="T:System.Drawing.RectangleF" /> values to the nearest integer values.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.RectangleF" /> to be converted.</param>
		/// <returns>The rounded interger value of the <see cref="T:System.Drawing.Rectangle" />.</returns>
		public static Rectangle Round(RectangleF value)
		{
			checked
			{
				int num = (int)Math.Round(value.X);
				int num2 = (int)Math.Round(value.Y);
				int num3 = (int)Math.Round(value.Width);
				int num4 = (int)Math.Round(value.Height);
				return new Rectangle(num, num2, num3, num4);
			}
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.RectangleF" /> to a <see cref="T:System.Drawing.Rectangle" /> by truncating the <see cref="T:System.Drawing.RectangleF" /> values.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.RectangleF" /> to be converted.</param>
		/// <returns>The truncated value of the  <see cref="T:System.Drawing.Rectangle" />.</returns>
		public static Rectangle Truncate(RectangleF value)
		{
			checked
			{
				int num = (int)value.X;
				int num2 = (int)value.Y;
				int num3 = (int)value.Width;
				int num4 = (int)value.Height;
				return new Rectangle(num, num2, num3, num4);
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Rectangle" /> structure that contains the union of two <see cref="T:System.Drawing.Rectangle" /> structures.</summary>
		/// <param name="a">A rectangle to union.</param>
		/// <param name="b">A rectangle to union.</param>
		/// <returns>A <see cref="T:System.Drawing.Rectangle" /> structure that bounds the union of the two <see cref="T:System.Drawing.Rectangle" /> structures.</returns>
		public static Rectangle Union(Rectangle a, Rectangle b)
		{
			return FromLTRB(Math.Min(a.Left, b.Left), Math.Min(a.Top, b.Top), Math.Max(a.Right, b.Right), Math.Max(a.Bottom, b.Bottom));
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.Rectangle" /> structures have equal location and size.</summary>
		/// <param name="left">The <see cref="T:System.Drawing.Rectangle" /> structure that is to the left of the equality operator.</param>
		/// <param name="right">The <see cref="T:System.Drawing.Rectangle" /> structure that is to the right of the equality operator.</param>
		/// <returns>This operator returns <see langword="true" /> if the two <see cref="T:System.Drawing.Rectangle" /> structures have equal <see cref="P:System.Drawing.Rectangle.X" />, <see cref="P:System.Drawing.Rectangle.Y" />, <see cref="P:System.Drawing.Rectangle.Width" />, and <see cref="P:System.Drawing.Rectangle.Height" /> properties.</returns>
		public static bool operator ==(Rectangle left, Rectangle right)
		{
			if (left.Location == right.Location)
			{
				return left.Size == right.Size;
			}
			return false;
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.Rectangle" /> structures differ in location or size.</summary>
		/// <param name="left">The <see cref="T:System.Drawing.Rectangle" /> structure that is to the left of the inequality operator.</param>
		/// <param name="right">The <see cref="T:System.Drawing.Rectangle" /> structure that is to the right of the inequality operator.</param>
		/// <returns>This operator returns <see langword="true" /> if any of the <see cref="P:System.Drawing.Rectangle.X" />, <see cref="P:System.Drawing.Rectangle.Y" />, <see cref="P:System.Drawing.Rectangle.Width" /> or <see cref="P:System.Drawing.Rectangle.Height" /> properties of the two <see cref="T:System.Drawing.Rectangle" /> structures are unequal; otherwise <see langword="false" />.</returns>
		public static bool operator !=(Rectangle left, Rectangle right)
		{
			if (!(left.Location != right.Location))
			{
				return left.Size != right.Size;
			}
			return true;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Rectangle" /> class with the specified location and size.</summary>
		/// <param name="location">A <see cref="T:System.Drawing.Point" /> that represents the upper-left corner of the rectangular region.</param>
		/// <param name="size">A <see cref="T:System.Drawing.Size" /> that represents the width and height of the rectangular region.</param>
		public Rectangle(Point location, Size size)
		{
			x = location.X;
			y = location.Y;
			width = size.Width;
			height = size.Height;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Rectangle" /> class with the specified location and size.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle.</param>
		/// <param name="width">The width of the rectangle.</param>
		/// <param name="height">The height of the rectangle.</param>
		public Rectangle(int x, int y, int width, int height)
		{
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
		}

		/// <summary>Determines if the specified point is contained within this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <returns>This method returns <see langword="true" /> if the point defined by <paramref name="x" /> and <paramref name="y" /> is contained within this <see cref="T:System.Drawing.Rectangle" /> structure; otherwise <see langword="false" />.</returns>
		public bool Contains(int x, int y)
		{
			if (x >= Left && x < Right && y >= Top)
			{
				return y < Bottom;
			}
			return false;
		}

		/// <summary>Determines if the specified point is contained within this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.Point" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if the point represented by <paramref name="pt" /> is contained within this <see cref="T:System.Drawing.Rectangle" /> structure; otherwise <see langword="false" />.</returns>
		public bool Contains(Point pt)
		{
			return Contains(pt.X, pt.Y);
		}

		/// <summary>Determines if the rectangular region represented by <paramref name="rect" /> is entirely contained within this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if the rectangular region represented by <paramref name="rect" /> is entirely contained within this <see cref="T:System.Drawing.Rectangle" /> structure; otherwise <see langword="false" />.</returns>
		public bool Contains(Rectangle rect)
		{
			return rect == Intersect(this, rect);
		}

		/// <summary>Tests whether <paramref name="obj" /> is a <see cref="T:System.Drawing.Rectangle" /> structure with the same location and size of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="obj">The <see cref="T:System.Object" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.Rectangle" /> structure and its <see cref="P:System.Drawing.Rectangle.X" />, <see cref="P:System.Drawing.Rectangle.Y" />, <see cref="P:System.Drawing.Rectangle.Width" />, and <see cref="P:System.Drawing.Rectangle.Height" /> properties are equal to the corresponding properties of this <see cref="T:System.Drawing.Rectangle" /> structure; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is Rectangle))
			{
				return false;
			}
			return this == (Rectangle)obj;
		}

		/// <summary>Returns the hash code for this <see cref="T:System.Drawing.Rectangle" /> structure. For information about the use of hash codes, see <see cref="M:System.Object.GetHashCode" /> .</summary>
		/// <returns>An integer that represents the hash code for this rectangle.</returns>
		public override int GetHashCode()
		{
			return (height + width) ^ (x + y);
		}

		/// <summary>Determines if this rectangle intersects with <paramref name="rect" />.</summary>
		/// <param name="rect">The rectangle to test.</param>
		/// <returns>This method returns <see langword="true" /> if there is any intersection, otherwise <see langword="false" />.</returns>
		public bool IntersectsWith(Rectangle rect)
		{
			if (Left < rect.Right && Right > rect.Left && Top < rect.Bottom)
			{
				return Bottom > rect.Top;
			}
			return false;
		}

		private bool IntersectsWithInclusive(Rectangle r)
		{
			if (Left <= r.Right && Right >= r.Left && Top <= r.Bottom)
			{
				return Bottom >= r.Top;
			}
			return false;
		}

		/// <summary>Adjusts the location of this rectangle by the specified amount.</summary>
		/// <param name="x">The horizontal offset.</param>
		/// <param name="y">The vertical offset.</param>
		public void Offset(int x, int y)
		{
			this.x += x;
			this.y += y;
		}

		/// <summary>Adjusts the location of this rectangle by the specified amount.</summary>
		/// <param name="pos">Amount to offset the location.</param>
		public void Offset(Point pos)
		{
			x += pos.X;
			y += pos.Y;
		}

		/// <summary>Converts the attributes of this <see cref="T:System.Drawing.Rectangle" /> to a human-readable string.</summary>
		/// <returns>A string that contains the position, width, and height of this <see cref="T:System.Drawing.Rectangle" /> structure  for example, {X=20, Y=20, Width=100, Height=50}</returns>
		public override string ToString()
		{
			return $"{{X={x},Y={y},Width={width},Height={height}}}";
		}
	}
	/// <summary>Converts rectangles from one data type to another. Access this class through the <see cref="T:System.ComponentModel.TypeDescriptor" />.</summary>
	public class RectangleConverter : TypeConverter
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.RectangleConverter" /> class.</summary>
		public RectangleConverter()
		{
		}

		/// <summary>Determines if this converter can convert an object in the given source type to the native type of the converter.</summary>
		/// <param name="context">A formatter context. This object can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="sourceType">The type you want to convert from.</param>
		/// <returns>This method returns <see langword="true" /> if this object can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Gets a value indicating whether this converter can convert an object to the given destination type using the context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> object that provides a format context. This can be <see langword="null" />, so you should always check. Also, properties on the context object can also return <see langword="null" />.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> object that represents the type you want to convert to.</param>
		/// <returns>This method returns <see langword="true" /> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(string))
			{
				return true;
			}
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts the given object to a <see cref="T:System.Drawing.Rectangle" /> object.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">An <see cref="T:System.Globalization.CultureInfo" /> that contains culture specific information, such as the language, calendar, and cultural conventions associated with a specific culture. It is based on the RFC 1766 standard.</param>
		/// <param name="value">The object to convert.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (!(value is string text))
			{
				return base.ConvertFrom(context, culture, value);
			}
			if (culture == null)
			{
				culture = CultureInfo.CurrentCulture;
			}
			string[] array = text.Split(culture.TextInfo.ListSeparator.ToCharArray());
			Int32Converter int32Converter = new Int32Converter();
			int[] array2 = new int[array.Length];
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = (int)int32Converter.ConvertFromString(context, culture, array[i]);
			}
			if (array.Length != 4)
			{
				throw new ArgumentException("Failed to parse Text(" + text + ") expected text in the format \"x,y,Width,Height.\"");
			}
			return new Rectangle(array2[0], array2[1], array2[2], array2[3]);
		}

		/// <summary>Converts the specified object to the specified type.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">An <see cref="T:System.Globalization.CultureInfo" /> that contains culture specific information, such as the language, calendar, and cultural conventions associated with a specific culture. It is based on the RFC 1766 standard.</param>
		/// <param name="value">The object to convert.</param>
		/// <param name="destinationType">The type to convert the object to.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (value is Rectangle rectangle)
			{
				if (destinationType == typeof(string))
				{
					string listSeparator = culture.TextInfo.ListSeparator;
					StringBuilder stringBuilder = new StringBuilder();
					stringBuilder.Append(rectangle.X.ToString(culture));
					stringBuilder.Append(listSeparator);
					stringBuilder.Append(" ");
					stringBuilder.Append(rectangle.Y.ToString(culture));
					stringBuilder.Append(listSeparator);
					stringBuilder.Append(" ");
					stringBuilder.Append(rectangle.Width.ToString(culture));
					stringBuilder.Append(listSeparator);
					stringBuilder.Append(" ");
					stringBuilder.Append(rectangle.Height.ToString(culture));
					return stringBuilder.ToString();
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					return new InstanceDescriptor(typeof(Rectangle).GetConstructor(new Type[4]
					{
						typeof(int),
						typeof(int),
						typeof(int),
						typeof(int)
					}), new object[4] { rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height });
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <summary>Creates an instance of this type given a set of property values for the object. This is useful for objects that are immutable but still want to provide changeable properties.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be provided.</param>
		/// <param name="propertyValues">A dictionary of new property values. The dictionary contains a series of name-value pairs, one for each property returned from a call to the <see cref="M:System.Drawing.RectangleConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object,System.Attribute[])" /> method.</param>
		/// <returns>The newly created object, or <see langword="null" /> if the object could not be created. The default implementation returns <see langword="null" />.</returns>
		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			object obj = propertyValues["X"];
			object obj2 = propertyValues["Y"];
			object obj3 = propertyValues["Width"];
			object obj4 = propertyValues["Height"];
			if (obj == null || obj2 == null || obj3 == null || obj4 == null)
			{
				throw new ArgumentException("propertyValues");
			}
			int x = (int)obj;
			int y = (int)obj2;
			int width = (int)obj3;
			int height = (int)obj4;
			return new Rectangle(x, y, width, height);
		}

		/// <summary>Determines if changing a value on this object should require a call to <see cref="M:System.Drawing.RectangleConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> to create a new value.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <returns>This method returns <see langword="true" /> if <see cref="M:System.Drawing.RectangleConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> should be called when a change is made to one or more properties of this object; otherwise, <see langword="false" />.</returns>
		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Retrieves the set of properties for this type. By default, a type does not return any properties.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be provided.</param>
		/// <param name="value">The value of the object to get the properties for.</param>
		/// <param name="attributes">An array of <see cref="T:System.Attribute" /> objects that describe the properties.</param>
		/// <returns>The set of properties that should be exposed for this data type. If no properties should be exposed, this may return <see langword="null" />. The default implementation always returns <see langword="null" />.</returns>
		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			if (value is Rectangle)
			{
				return TypeDescriptor.GetProperties(value, attributes);
			}
			return base.GetProperties(context, value, attributes);
		}

		/// <summary>Determines if this object supports properties. By default, this is <see langword="false" />.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be provided.</param>
		/// <returns>This method returns <see langword="true" /> if <see cref="M:System.Drawing.RectangleConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object,System.Attribute[])" /> should be called to find the properties of this object; otherwise, <see langword="false" />.</returns>
		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
	/// <summary>Stores a set of four floating-point numbers that represent the location and size of a rectangle. For more advanced region functions, use a <see cref="T:System.Drawing.Region" /> object.</summary>
	[Serializable]
	public struct RectangleF
	{
		private float x;

		private float y;

		private float width;

		private float height;

		/// <summary>Represents an instance of the <see cref="T:System.Drawing.RectangleF" /> class with its members uninitialized.</summary>
		public static readonly RectangleF Empty;

		/// <summary>Gets the y-coordinate that is the sum of <see cref="P:System.Drawing.RectangleF.Y" /> and <see cref="P:System.Drawing.RectangleF.Height" /> of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The y-coordinate that is the sum of <see cref="P:System.Drawing.RectangleF.Y" /> and <see cref="P:System.Drawing.RectangleF.Height" /> of this <see cref="T:System.Drawing.RectangleF" /> structure.</returns>
		[Browsable(false)]
		public float Bottom => Y + Height;

		/// <summary>Gets or sets the height of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The height of this <see cref="T:System.Drawing.RectangleF" /> structure. The default is 0.</returns>
		public float Height
		{
			get
			{
				return height;
			}
			set
			{
				height = value;
			}
		}

		/// <summary>Gets a value that indicates whether the <see cref="P:System.Drawing.RectangleF.Width" /> or <see cref="P:System.Drawing.RectangleF.Height" /> property of this <see cref="T:System.Drawing.RectangleF" /> has a value of zero.</summary>
		/// <returns>
		///   <see langword="true" /> if the <see cref="P:System.Drawing.RectangleF.Width" /> or <see cref="P:System.Drawing.RectangleF.Height" /> property of this <see cref="T:System.Drawing.RectangleF" /> has a value of zero; otherwise, <see langword="false" />.</returns>
		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (!(width <= 0f))
				{
					return height <= 0f;
				}
				return true;
			}
		}

		/// <summary>Gets the x-coordinate of the left edge of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The x-coordinate of the left edge of this <see cref="T:System.Drawing.RectangleF" /> structure.</returns>
		[Browsable(false)]
		public float Left => X;

		/// <summary>Gets or sets the coordinates of the upper-left corner of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>A <see cref="T:System.Drawing.PointF" /> that represents the upper-left corner of this <see cref="T:System.Drawing.RectangleF" /> structure.</returns>
		[Browsable(false)]
		public PointF Location
		{
			get
			{
				return new PointF(x, y);
			}
			set
			{
				x = value.X;
				y = value.Y;
			}
		}

		/// <summary>Gets the x-coordinate that is the sum of <see cref="P:System.Drawing.RectangleF.X" /> and <see cref="P:System.Drawing.RectangleF.Width" /> of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The x-coordinate that is the sum of <see cref="P:System.Drawing.RectangleF.X" /> and <see cref="P:System.Drawing.RectangleF.Width" /> of this <see cref="T:System.Drawing.RectangleF" /> structure.</returns>
		[Browsable(false)]
		public float Right => X + Width;

		/// <summary>Gets or sets the size of this <see cref="T:System.Drawing.RectangleF" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.SizeF" /> that represents the width and height of this <see cref="T:System.Drawing.RectangleF" /> structure.</returns>
		[Browsable(false)]
		public SizeF Size
		{
			get
			{
				return new SizeF(width, height);
			}
			set
			{
				width = value.Width;
				height = value.Height;
			}
		}

		/// <summary>Gets the y-coordinate of the top edge of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The y-coordinate of the top edge of this <see cref="T:System.Drawing.RectangleF" /> structure.</returns>
		[Browsable(false)]
		public float Top => Y;

		/// <summary>Gets or sets the width of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The width of this <see cref="T:System.Drawing.RectangleF" /> structure. The default is 0.</returns>
		public float Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		/// <summary>Gets or sets the x-coordinate of the upper-left corner of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The x-coordinate of the upper-left corner of this <see cref="T:System.Drawing.RectangleF" /> structure. The default is 0.</returns>
		public float X
		{
			get
			{
				return x;
			}
			set
			{
				x = value;
			}
		}

		/// <summary>Gets or sets the y-coordinate of the upper-left corner of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The y-coordinate of the upper-left corner of this <see cref="T:System.Drawing.RectangleF" /> structure. The default is 0.</returns>
		public float Y
		{
			get
			{
				return y;
			}
			set
			{
				y = value;
			}
		}

		/// <summary>Creates a <see cref="T:System.Drawing.RectangleF" /> structure with upper-left corner and lower-right corner at the specified locations.</summary>
		/// <param name="left">The x-coordinate of the upper-left corner of the rectangular region.</param>
		/// <param name="top">The y-coordinate of the upper-left corner of the rectangular region.</param>
		/// <param name="right">The x-coordinate of the lower-right corner of the rectangular region.</param>
		/// <param name="bottom">The y-coordinate of the lower-right corner of the rectangular region.</param>
		/// <returns>The new <see cref="T:System.Drawing.RectangleF" /> that this method creates.</returns>
		public static RectangleF FromLTRB(float left, float top, float right, float bottom)
		{
			return new RectangleF(left, top, right - left, bottom - top);
		}

		/// <summary>Creates and returns an enlarged copy of the specified <see cref="T:System.Drawing.RectangleF" /> structure. The copy is enlarged by the specified amount and the original rectangle remains unmodified.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> to be copied. This rectangle is not modified.</param>
		/// <param name="x">The amount to enlarge the copy of the rectangle horizontally.</param>
		/// <param name="y">The amount to enlarge the copy of the rectangle vertically.</param>
		/// <returns>The enlarged <see cref="T:System.Drawing.RectangleF" />.</returns>
		public static RectangleF Inflate(RectangleF rect, float x, float y)
		{
			RectangleF result = new RectangleF(rect.X, rect.Y, rect.Width, rect.Height);
			result.Inflate(x, y);
			return result;
		}

		/// <summary>Enlarges this <see cref="T:System.Drawing.RectangleF" /> structure by the specified amount.</summary>
		/// <param name="x">The amount to inflate this <see cref="T:System.Drawing.RectangleF" /> structure horizontally.</param>
		/// <param name="y">The amount to inflate this <see cref="T:System.Drawing.RectangleF" /> structure vertically.</param>
		public void Inflate(float x, float y)
		{
			Inflate(new SizeF(x, y));
		}

		/// <summary>Enlarges this <see cref="T:System.Drawing.RectangleF" /> by the specified amount.</summary>
		/// <param name="size">The amount to inflate this rectangle.</param>
		public void Inflate(SizeF size)
		{
			x -= size.Width;
			y -= size.Height;
			width += size.Width * 2f;
			height += size.Height * 2f;
		}

		/// <summary>Returns a <see cref="T:System.Drawing.RectangleF" /> structure that represents the intersection of two rectangles. If there is no intersection, and empty <see cref="T:System.Drawing.RectangleF" /> is returned.</summary>
		/// <param name="a">A rectangle to intersect.</param>
		/// <param name="b">A rectangle to intersect.</param>
		/// <returns>A third <see cref="T:System.Drawing.RectangleF" /> structure the size of which represents the overlapped area of the two specified rectangles.</returns>
		public static RectangleF Intersect(RectangleF a, RectangleF b)
		{
			if (!a.IntersectsWithInclusive(b))
			{
				return Empty;
			}
			return FromLTRB(Math.Max(a.Left, b.Left), Math.Max(a.Top, b.Top), Math.Min(a.Right, b.Right), Math.Min(a.Bottom, b.Bottom));
		}

		/// <summary>Replaces this <see cref="T:System.Drawing.RectangleF" /> structure with the intersection of itself and the specified <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">The rectangle to intersect.</param>
		public void Intersect(RectangleF rect)
		{
			this = Intersect(this, rect);
		}

		/// <summary>Creates the smallest possible third rectangle that can contain both of two rectangles that form a union.</summary>
		/// <param name="a">A rectangle to union.</param>
		/// <param name="b">A rectangle to union.</param>
		/// <returns>A third <see cref="T:System.Drawing.RectangleF" /> structure that contains both of the two rectangles that form the union.</returns>
		public static RectangleF Union(RectangleF a, RectangleF b)
		{
			return FromLTRB(Math.Min(a.Left, b.Left), Math.Min(a.Top, b.Top), Math.Max(a.Right, b.Right), Math.Max(a.Bottom, b.Bottom));
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.RectangleF" /> structures have equal location and size.</summary>
		/// <param name="left">The <see cref="T:System.Drawing.RectangleF" /> structure that is to the left of the equality operator.</param>
		/// <param name="right">The <see cref="T:System.Drawing.RectangleF" /> structure that is to the right of the equality operator.</param>
		/// <returns>
		///   <see langword="true" /> if the two specified <see cref="T:System.Drawing.RectangleF" /> structures have equal <see cref="P:System.Drawing.RectangleF.X" />, <see cref="P:System.Drawing.RectangleF.Y" />, <see cref="P:System.Drawing.RectangleF.Width" />, and <see cref="P:System.Drawing.RectangleF.Height" /> properties; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(RectangleF left, RectangleF right)
		{
			if (left.X == right.X && left.Y == right.Y && left.Width == right.Width)
			{
				return left.Height == right.Height;
			}
			return false;
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.RectangleF" /> structures differ in location or size.</summary>
		/// <param name="left">The <see cref="T:System.Drawing.RectangleF" /> structure that is to the left of the inequality operator.</param>
		/// <param name="right">The <see cref="T:System.Drawing.RectangleF" /> structure that is to the right of the inequality operator.</param>
		/// <returns>
		///   <see langword="true" /> if any of the <see cref="P:System.Drawing.RectangleF.X" /> , <see cref="P:System.Drawing.RectangleF.Y" />, <see cref="P:System.Drawing.RectangleF.Width" />, or <see cref="P:System.Drawing.RectangleF.Height" /> properties of the two <see cref="T:System.Drawing.Rectangle" /> structures are unequal; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(RectangleF left, RectangleF right)
		{
			if (left.X == right.X && left.Y == right.Y && left.Width == right.Width)
			{
				return left.Height != right.Height;
			}
			return true;
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.Rectangle" /> structure to a <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="r">The <see cref="T:System.Drawing.Rectangle" /> structure to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.RectangleF" /> structure that is converted from the specified <see cref="T:System.Drawing.Rectangle" /> structure.</returns>
		public static implicit operator RectangleF(Rectangle r)
		{
			return new RectangleF(r.X, r.Y, r.Width, r.Height);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.RectangleF" /> class with the specified location and size.</summary>
		/// <param name="location">A <see cref="T:System.Drawing.PointF" /> that represents the upper-left corner of the rectangular region.</param>
		/// <param name="size">A <see cref="T:System.Drawing.SizeF" /> that represents the width and height of the rectangular region.</param>
		public RectangleF(PointF location, SizeF size)
		{
			x = location.X;
			y = location.Y;
			width = size.Width;
			height = size.Height;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.RectangleF" /> class with the specified location and size.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle.</param>
		/// <param name="width">The width of the rectangle.</param>
		/// <param name="height">The height of the rectangle.</param>
		public RectangleF(float x, float y, float width, float height)
		{
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
		}

		/// <summary>Determines if the specified point is contained within this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <returns>
		///   <see langword="true" /> if the point defined by <paramref name="x" /> and <paramref name="y" /> is contained within this <see cref="T:System.Drawing.RectangleF" /> structure; otherwise, <see langword="false" />.</returns>
		public bool Contains(float x, float y)
		{
			if (x >= Left && x < Right && y >= Top)
			{
				return y < Bottom;
			}
			return false;
		}

		/// <summary>Determines if the specified point is contained within this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if the point represented by the <paramref name="pt" /> parameter is contained within this <see cref="T:System.Drawing.RectangleF" /> structure; otherwise, <see langword="false" />.</returns>
		public bool Contains(PointF pt)
		{
			return Contains(pt.X, pt.Y);
		}

		/// <summary>Determines if the rectangular region represented by <paramref name="rect" /> is entirely contained within this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if the rectangular region represented by <paramref name="rect" /> is entirely contained within the rectangular region represented by this <see cref="T:System.Drawing.RectangleF" />; otherwise, <see langword="false" />.</returns>
		public bool Contains(RectangleF rect)
		{
			if (X <= rect.X && Right >= rect.Right && Y <= rect.Y)
			{
				return Bottom >= rect.Bottom;
			}
			return false;
		}

		/// <summary>Tests whether <paramref name="obj" /> is a <see cref="T:System.Drawing.RectangleF" /> with the same location and size of this <see cref="T:System.Drawing.RectangleF" />.</summary>
		/// <param name="obj">The <see cref="T:System.Object" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.RectangleF" /> and its <see langword="X" />, <see langword="Y" />, <see langword="Width" />, and <see langword="Height" /> properties are equal to the corresponding properties of this <see cref="T:System.Drawing.RectangleF" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is RectangleF))
			{
				return false;
			}
			return this == (RectangleF)obj;
		}

		/// <summary>Gets the hash code for this <see cref="T:System.Drawing.RectangleF" /> structure. For information about the use of hash codes, see <see langword="Object.GetHashCode" />.</summary>
		/// <returns>The hash code for this <see cref="T:System.Drawing.RectangleF" />.</returns>
		public override int GetHashCode()
		{
			return (int)(x + y + width + height);
		}

		/// <summary>Determines if this rectangle intersects with <paramref name="rect" />.</summary>
		/// <param name="rect">The rectangle to test.</param>
		/// <returns>
		///   <see langword="true" /> if there is any intersection; otherwise, <see langword="false" />.</returns>
		public bool IntersectsWith(RectangleF rect)
		{
			if (!(Left >= rect.Right) && !(Right <= rect.Left) && !(Top >= rect.Bottom))
			{
				return !(Bottom <= rect.Top);
			}
			return false;
		}

		private bool IntersectsWithInclusive(RectangleF r)
		{
			if (!(Left > r.Right) && !(Right < r.Left) && !(Top > r.Bottom))
			{
				return !(Bottom < r.Top);
			}
			return false;
		}

		/// <summary>Adjusts the location of this rectangle by the specified amount.</summary>
		/// <param name="x">The amount to offset the location horizontally.</param>
		/// <param name="y">The amount to offset the location vertically.</param>
		public void Offset(float x, float y)
		{
			X += x;
			Y += y;
		}

		/// <summary>Adjusts the location of this rectangle by the specified amount.</summary>
		/// <param name="pos">The amount to offset the location.</param>
		public void Offset(PointF pos)
		{
			Offset(pos.X, pos.Y);
		}

		/// <summary>Converts the <see langword="Location" /> and <see cref="T:System.Drawing.Size" /> of this <see cref="T:System.Drawing.RectangleF" /> to a human-readable string.</summary>
		/// <returns>A string that contains the position, width, and height of this <see cref="T:System.Drawing.RectangleF" /> structure. For example, "{X=20, Y=20, Width=100, Height=50}".</returns>
		public override string ToString()
		{
			return $"{{X={x},Y={y},Width={width},Height={height}}}";
		}
	}
	/// <summary>Describes the interior of a graphics shape composed of rectangles and paths. This class cannot be inherited.</summary>
	public sealed class Region : MarshalByRefObject, IDisposable
	{
		private IntPtr nativeRegion = IntPtr.Zero;

		internal IntPtr NativeObject
		{
			get
			{
				return nativeRegion;
			}
			set
			{
				nativeRegion = value;
			}
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Region" />.</summary>
		public Region()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateRegion(out nativeRegion));
		}

		internal Region(IntPtr native)
		{
			nativeRegion = native;
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Region" /> with the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="path">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> that defines the new <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="path" /> is <see langword="null" />.</exception>
		public Region(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreateRegionPath(path.nativePath, out nativeRegion));
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Region" /> from the specified <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> structure that defines the interior of the new <see cref="T:System.Drawing.Region" />.</param>
		public Region(Rectangle rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateRegionRectI(ref rect, out nativeRegion));
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Region" /> from the specified <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> structure that defines the interior of the new <see cref="T:System.Drawing.Region" />.</param>
		public Region(RectangleF rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateRegionRect(ref rect, out nativeRegion));
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Region" /> from the specified data.</summary>
		/// <param name="rgnData">A <see cref="T:System.Drawing.Drawing2D.RegionData" /> that defines the interior of the new <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="rgnData" /> is <see langword="null" />.</exception>
		public Region(RegionData rgnData)
		{
			if (rgnData == null)
			{
				throw new ArgumentNullException("rgnData");
			}
			if (rgnData.Data.Length == 0)
			{
				throw new ArgumentException("rgnData");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreateRegionRgnData(rgnData.Data, rgnData.Data.Length, out nativeRegion));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union of itself and the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to unite with this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="path" /> is <see langword="null" />.</exception>
		public void Union(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionPath(nativeRegion, path.nativePath, CombineMode.Union));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union of itself and the specified <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> structure to unite with this <see cref="T:System.Drawing.Region" />.</param>
		public void Union(Rectangle rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionRectI(nativeRegion, ref rect, CombineMode.Union));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union of itself and the specified <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> structure to unite with this <see cref="T:System.Drawing.Region" />.</param>
		public void Union(RectangleF rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionRect(nativeRegion, ref rect, CombineMode.Union));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union of itself and the specified <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">The <see cref="T:System.Drawing.Region" /> to unite with this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="region" /> is <see langword="null" />.</exception>
		public void Union(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionRegion(nativeRegion, region.NativeObject, CombineMode.Union));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the intersection of itself with the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to intersect with this <see cref="T:System.Drawing.Region" />.</param>
		public void Intersect(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionPath(nativeRegion, path.nativePath, CombineMode.Intersect));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the intersection of itself with the specified <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> structure to intersect with this <see cref="T:System.Drawing.Region" />.</param>
		public void Intersect(Rectangle rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionRectI(nativeRegion, ref rect, CombineMode.Intersect));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the intersection of itself with the specified <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> structure to intersect with this <see cref="T:System.Drawing.Region" />.</param>
		public void Intersect(RectangleF rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionRect(nativeRegion, ref rect, CombineMode.Intersect));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the intersection of itself with the specified <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">The <see cref="T:System.Drawing.Region" /> to intersect with this <see cref="T:System.Drawing.Region" />.</param>
		public void Intersect(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionRegion(nativeRegion, region.NativeObject, CombineMode.Intersect));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain the portion of the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> that does not intersect with this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to complement this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="path" /> is <see langword="null" />.</exception>
		public void Complement(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionPath(nativeRegion, path.nativePath, CombineMode.Complement));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain the portion of the specified <see cref="T:System.Drawing.Rectangle" /> structure that does not intersect with this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> structure to complement this <see cref="T:System.Drawing.Region" />.</param>
		public void Complement(Rectangle rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionRectI(nativeRegion, ref rect, CombineMode.Complement));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain the portion of the specified <see cref="T:System.Drawing.RectangleF" /> structure that does not intersect with this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> structure to complement this <see cref="T:System.Drawing.Region" />.</param>
		public void Complement(RectangleF rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionRect(nativeRegion, ref rect, CombineMode.Complement));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain the portion of the specified <see cref="T:System.Drawing.Region" /> that does not intersect with this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">The <see cref="T:System.Drawing.Region" /> object to complement this <see cref="T:System.Drawing.Region" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="region" /> is <see langword="null" />.</exception>
		public void Complement(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionRegion(nativeRegion, region.NativeObject, CombineMode.Complement));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain only the portion of its interior that does not intersect with the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to exclude from this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="path" /> is <see langword="null" />.</exception>
		public void Exclude(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionPath(nativeRegion, path.nativePath, CombineMode.Exclude));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain only the portion of its interior that does not intersect with the specified <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> structure to exclude from this <see cref="T:System.Drawing.Region" />.</param>
		public void Exclude(Rectangle rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionRectI(nativeRegion, ref rect, CombineMode.Exclude));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain only the portion of its interior that does not intersect with the specified <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> structure to exclude from this <see cref="T:System.Drawing.Region" />.</param>
		public void Exclude(RectangleF rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionRect(nativeRegion, ref rect, CombineMode.Exclude));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain only the portion of its interior that does not intersect with the specified <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">The <see cref="T:System.Drawing.Region" /> to exclude from this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="region" /> is <see langword="null" />.</exception>
		public void Exclude(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionRegion(nativeRegion, region.NativeObject, CombineMode.Exclude));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union minus the intersection of itself with the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to <see cref="Overload:System.Drawing.Region.Xor" /> with this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="path" /> is <see langword="null" />.</exception>
		public void Xor(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionPath(nativeRegion, path.nativePath, CombineMode.Xor));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union minus the intersection of itself with the specified <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> structure to <see cref="Overload:System.Drawing.Region.Xor" /> with this <see cref="T:System.Drawing.Region" />.</param>
		public void Xor(Rectangle rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionRectI(nativeRegion, ref rect, CombineMode.Xor));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union minus the intersection of itself with the specified <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> structure to <see cref="M:System.Drawing.Region.Xor(System.Drawing.Drawing2D.GraphicsPath)" /> with this <see cref="T:System.Drawing.Region" />.</param>
		public void Xor(RectangleF rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionRect(nativeRegion, ref rect, CombineMode.Xor));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union minus the intersection of itself with the specified <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">The <see cref="T:System.Drawing.Region" /> to <see cref="Overload:System.Drawing.Region.Xor" /> with this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="region" /> is <see langword="null" />.</exception>
		public void Xor(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCombineRegionRegion(nativeRegion, region.NativeObject, CombineMode.Xor));
		}

		/// <summary>Gets a <see cref="T:System.Drawing.RectangleF" /> structure that represents a rectangle that bounds this <see cref="T:System.Drawing.Region" /> on the drawing surface of a <see cref="T:System.Drawing.Graphics" /> object.</summary>
		/// <param name="g">The <see cref="T:System.Drawing.Graphics" /> on which this <see cref="T:System.Drawing.Region" /> is drawn.</param>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> structure that represents the bounding rectangle for this <see cref="T:System.Drawing.Region" /> on the specified drawing surface.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="g" /> is <see langword="null" />.</exception>
		public RectangleF GetBounds(Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			RectangleF rect = default(Rectangle);
			GDIPlus.CheckStatus(GDIPlus.GdipGetRegionBounds(nativeRegion, g.NativeObject, ref rect));
			return rect;
		}

		/// <summary>Offsets the coordinates of this <see cref="T:System.Drawing.Region" /> by the specified amount.</summary>
		/// <param name="dx">The amount to offset this <see cref="T:System.Drawing.Region" /> horizontally.</param>
		/// <param name="dy">The amount to offset this <see cref="T:System.Drawing.Region" /> vertically.</param>
		public void Translate(int dx, int dy)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipTranslateRegionI(nativeRegion, dx, dy));
		}

		/// <summary>Offsets the coordinates of this <see cref="T:System.Drawing.Region" /> by the specified amount.</summary>
		/// <param name="dx">The amount to offset this <see cref="T:System.Drawing.Region" /> horizontally.</param>
		/// <param name="dy">The amount to offset this <see cref="T:System.Drawing.Region" /> vertically.</param>
		public void Translate(float dx, float dy)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipTranslateRegion(nativeRegion, dx, dy));
		}

		/// <summary>Tests whether the specified point is contained within this <see cref="T:System.Drawing.Region" /> object when drawn using the specified <see cref="T:System.Drawing.Graphics" /> object.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when the specified point is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(int x, int y, Graphics g)
		{
			IntPtr graphics = g?.NativeObject ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRegionPointI(nativeRegion, x, y, graphics, out var result));
			return result;
		}

		/// <summary>Tests whether any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="width">The width of the rectangle to test.</param>
		/// <param name="height">The height of the rectangle to test.</param>
		/// <returns>
		///   <see langword="true" /> when any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(int x, int y, int width, int height)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRegionRectI(nativeRegion, x, y, width, height, IntPtr.Zero, out var result));
			return result;
		}

		/// <summary>Tests whether any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" /> when drawn using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="width">The width of the rectangle to test.</param>
		/// <param name="height">The height of the rectangle to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(int x, int y, int width, int height, Graphics g)
		{
			IntPtr graphics = g?.NativeObject ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRegionRectI(nativeRegion, x, y, width, height, graphics, out var result));
			return result;
		}

		/// <summary>Tests whether the specified <see cref="T:System.Drawing.Point" /> structure is contained within this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="point">The <see cref="T:System.Drawing.Point" /> structure to test.</param>
		/// <returns>
		///   <see langword="true" /> when <paramref name="point" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Point point)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRegionPointI(nativeRegion, point.X, point.Y, IntPtr.Zero, out var result));
			return result;
		}

		/// <summary>Tests whether the specified <see cref="T:System.Drawing.PointF" /> structure is contained within this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="point">The <see cref="T:System.Drawing.PointF" /> structure to test.</param>
		/// <returns>
		///   <see langword="true" /> when <paramref name="point" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(PointF point)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRegionPoint(nativeRegion, point.X, point.Y, IntPtr.Zero, out var result));
			return result;
		}

		/// <summary>Tests whether the specified <see cref="T:System.Drawing.Point" /> structure is contained within this <see cref="T:System.Drawing.Region" /> when drawn using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="point">The <see cref="T:System.Drawing.Point" /> structure to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when <paramref name="point" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Point point, Graphics g)
		{
			IntPtr graphics = g?.NativeObject ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRegionPointI(nativeRegion, point.X, point.Y, graphics, out var result));
			return result;
		}

		/// <summary>Tests whether the specified <see cref="T:System.Drawing.PointF" /> structure is contained within this <see cref="T:System.Drawing.Region" /> when drawn using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="point">The <see cref="T:System.Drawing.PointF" /> structure to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when <paramref name="point" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(PointF point, Graphics g)
		{
			IntPtr graphics = g?.NativeObject ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRegionPoint(nativeRegion, point.X, point.Y, graphics, out var result));
			return result;
		}

		/// <summary>Tests whether any portion of the specified <see cref="T:System.Drawing.Rectangle" /> structure is contained within this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> structure to test.</param>
		/// <returns>This method returns <see langword="true" /> when any portion of <paramref name="rect" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Rectangle rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRegionRectI(nativeRegion, rect.X, rect.Y, rect.Width, rect.Height, IntPtr.Zero, out var result));
			return result;
		}

		/// <summary>Tests whether any portion of the specified <see cref="T:System.Drawing.RectangleF" /> structure is contained within this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> structure to test.</param>
		/// <returns>
		///   <see langword="true" /> when any portion of <paramref name="rect" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(RectangleF rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRegionRect(nativeRegion, rect.X, rect.Y, rect.Width, rect.Height, IntPtr.Zero, out var result));
			return result;
		}

		/// <summary>Tests whether any portion of the specified <see cref="T:System.Drawing.Rectangle" /> structure is contained within this <see cref="T:System.Drawing.Region" /> when drawn using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> structure to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when any portion of the <paramref name="rect" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Rectangle rect, Graphics g)
		{
			IntPtr graphics = g?.NativeObject ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRegionRectI(nativeRegion, rect.X, rect.Y, rect.Width, rect.Height, graphics, out var result));
			return result;
		}

		/// <summary>Tests whether any portion of the specified <see cref="T:System.Drawing.RectangleF" /> structure is contained within this <see cref="T:System.Drawing.Region" /> when drawn using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> structure to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when <paramref name="rect" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(RectangleF rect, Graphics g)
		{
			IntPtr graphics = g?.NativeObject ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRegionRect(nativeRegion, rect.X, rect.Y, rect.Width, rect.Height, graphics, out var result));
			return result;
		}

		/// <summary>Tests whether the specified point is contained within this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <returns>
		///   <see langword="true" /> when the specified point is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRegionPoint(nativeRegion, x, y, IntPtr.Zero, out var result));
			return result;
		}

		/// <summary>Tests whether the specified point is contained within this <see cref="T:System.Drawing.Region" /> when drawn using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when the specified point is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y, Graphics g)
		{
			IntPtr graphics = g?.NativeObject ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRegionPoint(nativeRegion, x, y, graphics, out var result));
			return result;
		}

		/// <summary>Tests whether any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="width">The width of the rectangle to test.</param>
		/// <param name="height">The height of the rectangle to test.</param>
		/// <returns>
		///   <see langword="true" /> when any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" /> object; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y, float width, float height)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRegionRect(nativeRegion, x, y, width, height, IntPtr.Zero, out var result));
			return result;
		}

		/// <summary>Tests whether any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" /> when drawn using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="width">The width of the rectangle to test.</param>
		/// <param name="height">The height of the rectangle to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y, float width, float height, Graphics g)
		{
			IntPtr graphics = g?.NativeObject ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisibleRegionRect(nativeRegion, x, y, width, height, graphics, out var result));
			return result;
		}

		/// <summary>Tests whether this <see cref="T:System.Drawing.Region" /> has an empty interior on the specified drawing surface.</summary>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a drawing surface.</param>
		/// <returns>
		///   <see langword="true" /> if the interior of this <see cref="T:System.Drawing.Region" /> is empty when the transformation associated with <paramref name="g" /> is applied; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="g" /> is <see langword="null" />.</exception>
		public bool IsEmpty(Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipIsEmptyRegion(nativeRegion, g.NativeObject, out var result));
			return result;
		}

		/// <summary>Tests whether this <see cref="T:System.Drawing.Region" /> has an infinite interior on the specified drawing surface.</summary>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a drawing surface.</param>
		/// <returns>
		///   <see langword="true" /> if the interior of this <see cref="T:System.Drawing.Region" /> is infinite when the transformation associated with <paramref name="g" /> is applied; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="g" /> is <see langword="null" />.</exception>
		public bool IsInfinite(Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipIsInfiniteRegion(nativeRegion, g.NativeObject, out var result));
			return result;
		}

		/// <summary>Initializes this <see cref="T:System.Drawing.Region" /> to an empty interior.</summary>
		public void MakeEmpty()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipSetEmpty(nativeRegion));
		}

		/// <summary>Initializes this <see cref="T:System.Drawing.Region" /> object to an infinite interior.</summary>
		public void MakeInfinite()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipSetInfinite(nativeRegion));
		}

		/// <summary>Tests whether the specified <see cref="T:System.Drawing.Region" /> is identical to this <see cref="T:System.Drawing.Region" /> on the specified drawing surface.</summary>
		/// <param name="region">The <see cref="T:System.Drawing.Region" /> to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a drawing surface.</param>
		/// <returns>
		///   <see langword="true" /> if the interior of region is identical to the interior of this region when the transformation associated with the <paramref name="g" /> parameter is applied; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="g" /> or <paramref name="region" /> is <see langword="null" />.</exception>
		public bool Equals(Region region, Graphics g)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipIsEqualRegion(nativeRegion, region.NativeObject, g.NativeObject, out var result));
			return result;
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Region" /> from a handle to the specified existing GDI region.</summary>
		/// <param name="hrgn">A handle to an existing <see cref="T:System.Drawing.Region" />.</param>
		/// <returns>The new <see cref="T:System.Drawing.Region" />.</returns>
		public static Region FromHrgn(IntPtr hrgn)
		{
			if (hrgn == IntPtr.Zero)
			{
				throw new ArgumentException("hrgn");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreateRegionHrgn(hrgn, out var region));
			return new Region(region);
		}

		/// <summary>Returns a Windows handle to this <see cref="T:System.Drawing.Region" /> in the specified graphics context.</summary>
		/// <param name="g">The <see cref="T:System.Drawing.Graphics" /> on which this <see cref="T:System.Drawing.Region" /> is drawn.</param>
		/// <returns>A Windows handle to this <see cref="T:System.Drawing.Region" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="g" /> is <see langword="null" />.</exception>
		public IntPtr GetHrgn(Graphics g)
		{
			if (g == null)
			{
				return nativeRegion;
			}
			IntPtr hRgn = IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipGetRegionHRgn(nativeRegion, g.NativeObject, ref hRgn));
			return hRgn;
		}

		/// <summary>Returns a <see cref="T:System.Drawing.Drawing2D.RegionData" /> that represents the information that describes this <see cref="T:System.Drawing.Region" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.RegionData" /> that represents the information that describes this <see cref="T:System.Drawing.Region" />.</returns>
		public RegionData GetRegionData()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipGetRegionDataSize(nativeRegion, out var bufferSize));
			byte[] array = new byte[bufferSize];
			GDIPlus.CheckStatus(GDIPlus.GdipGetRegionData(nativeRegion, array, bufferSize, out var _));
			return new RegionData(array);
		}

		/// <summary>Returns an array of <see cref="T:System.Drawing.RectangleF" /> structures that approximate this <see cref="T:System.Drawing.Region" /> after the specified matrix transformation is applied.</summary>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> that represents a geometric transformation to apply to the region.</param>
		/// <returns>An array of <see cref="T:System.Drawing.RectangleF" /> structures that approximate this <see cref="T:System.Drawing.Region" /> after the specified matrix transformation is applied.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="matrix" /> is <see langword="null" />.</exception>
		public RectangleF[] GetRegionScans(Matrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipGetRegionScansCount(nativeRegion, out var count, matrix.NativeObject));
			if (count == 0)
			{
				return new RectangleF[0];
			}
			RectangleF[] array = new RectangleF[count];
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(array[0]) * count);
			try
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetRegionScans(nativeRegion, intPtr, out count, matrix.NativeObject));
			}
			finally
			{
				GDIPlus.FromUnManagedMemoryToRectangles(intPtr, array);
			}
			return array;
		}

		/// <summary>Transforms this <see cref="T:System.Drawing.Region" /> by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which to transform this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="matrix" /> is <see langword="null" />.</exception>
		public void Transform(Matrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipTransformRegion(nativeRegion, matrix.NativeObject));
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Region" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Region" /> that this method creates.</returns>
		public Region Clone()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCloneRegion(nativeRegion, out var cloned));
			return new Region(cloned);
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Region" />.</summary>
		public void Dispose()
		{
			DisposeHandle();
			GC.SuppressFinalize(this);
		}

		private void DisposeHandle()
		{
			if (nativeRegion != IntPtr.Zero)
			{
				GDIPlus.GdipDeleteRegion(nativeRegion);
				nativeRegion = IntPtr.Zero;
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Region()
		{
			DisposeHandle();
		}

		/// <summary>Releases the handle of the <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="regionHandle">The handle to the <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="regionHandle" /> is <see langword="null" />.</exception>
		public void ReleaseHrgn(IntPtr regionHandle)
		{
			if (regionHandle == IntPtr.Zero)
			{
				throw new ArgumentNullException("regionHandle");
			}
			Status status = Status.Ok;
			if (GDIPlus.RunningOnUnix())
			{
				status = GDIPlus.GdipDeleteRegion(regionHandle);
			}
			else if (!GDIPlus.DeleteObject(regionHandle))
			{
				status = Status.InvalidParameter;
			}
			GDIPlus.CheckStatus(status);
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class SRDescriptionAttribute : DescriptionAttribute
	{
		private bool isReplaced;

		public override string Description
		{
			get
			{
				if (!isReplaced)
				{
					isReplaced = true;
					base.DescriptionValue = global::Locale.GetText(base.DescriptionValue);
				}
				return base.DescriptionValue;
			}
		}

		public SRDescriptionAttribute(string description)
			: base(description)
		{
		}
	}
	/// <summary>Stores an ordered pair of integers, which specify a <see cref="P:System.Drawing.Size.Height" /> and <see cref="P:System.Drawing.Size.Width" />.</summary>
	[Serializable]
	[ComVisible(true)]
	[TypeConverter(typeof(SizeConverter))]
	public struct Size
	{
		private int width;

		private int height;

		/// <summary>Gets a <see cref="T:System.Drawing.Size" /> structure that has a <see cref="P:System.Drawing.Size.Height" /> and <see cref="P:System.Drawing.Size.Width" /> value of 0.</summary>
		public static readonly Size Empty;

		/// <summary>Tests whether this <see cref="T:System.Drawing.Size" /> structure has width and height of 0.</summary>
		/// <returns>This property returns <see langword="true" /> when this <see cref="T:System.Drawing.Size" /> structure has both a width and height of 0; otherwise, <see langword="false" />.</returns>
		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (width == 0)
				{
					return height == 0;
				}
				return false;
			}
		}

		/// <summary>Gets or sets the horizontal component of this <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <returns>The horizontal component of this <see cref="T:System.Drawing.Size" /> structure, typically measured in pixels.</returns>
		public int Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		/// <summary>Gets or sets the vertical component of this <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <returns>The vertical component of this <see cref="T:System.Drawing.Size" /> structure, typically measured in pixels.</returns>
		public int Height
		{
			get
			{
				return height;
			}
			set
			{
				height = value;
			}
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.SizeF" /> structure to a <see cref="T:System.Drawing.Size" /> structure by rounding the values of the <see cref="T:System.Drawing.Size" /> structure to the next higher integer values.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.SizeF" /> structure to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.Size" /> structure this method converts to.</returns>
		public static Size Ceiling(SizeF value)
		{
			checked
			{
				int num = (int)Math.Ceiling(value.Width);
				int num2 = (int)Math.Ceiling(value.Height);
				return new Size(num, num2);
			}
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.SizeF" /> structure to a <see cref="T:System.Drawing.Size" /> structure by rounding the values of the <see cref="T:System.Drawing.SizeF" /> structure to the nearest integer values.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.SizeF" /> structure to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.Size" /> structure this method converts to.</returns>
		public static Size Round(SizeF value)
		{
			checked
			{
				int num = (int)Math.Round(value.Width);
				int num2 = (int)Math.Round(value.Height);
				return new Size(num, num2);
			}
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.SizeF" /> structure to a <see cref="T:System.Drawing.Size" /> structure by truncating the values of the <see cref="T:System.Drawing.SizeF" /> structure to the next lower integer values.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.SizeF" /> structure to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.Size" /> structure this method converts to.</returns>
		public static Size Truncate(SizeF value)
		{
			checked
			{
				int num = (int)value.Width;
				int num2 = (int)value.Height;
				return new Size(num, num2);
			}
		}

		/// <summary>Adds the width and height of one <see cref="T:System.Drawing.Size" /> structure to the width and height of another <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <param name="sz1">The first <see cref="T:System.Drawing.Size" /> to add.</param>
		/// <param name="sz2">The second <see cref="T:System.Drawing.Size" /> to add.</param>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure that is the result of the addition operation.</returns>
		public static Size operator +(Size sz1, Size sz2)
		{
			return new Size(sz1.Width + sz2.Width, sz1.Height + sz2.Height);
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.Size" /> structures are equal.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.Size" /> structure on the left side of the equality operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.Size" /> structure on the right of the equality operator.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="sz1" /> and <paramref name="sz2" /> have equal width and height; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(Size sz1, Size sz2)
		{
			if (sz1.Width == sz2.Width)
			{
				return sz1.Height == sz2.Height;
			}
			return false;
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.Size" /> structures are different.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.Size" /> structure on the left of the inequality operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.Size" /> structure on the right of the inequality operator.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="sz1" /> and <paramref name="sz2" /> differ either in width or height; <see langword="false" /> if <paramref name="sz1" /> and <paramref name="sz2" /> are equal.</returns>
		public static bool operator !=(Size sz1, Size sz2)
		{
			if (sz1.Width == sz2.Width)
			{
				return sz1.Height != sz2.Height;
			}
			return true;
		}

		/// <summary>Subtracts the width and height of one <see cref="T:System.Drawing.Size" /> structure from the width and height of another <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.Size" /> structure on the left side of the subtraction operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.Size" /> structure on the right side of the subtraction operator.</param>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure that is the result of the subtraction operation.</returns>
		public static Size operator -(Size sz1, Size sz2)
		{
			return new Size(sz1.Width - sz2.Width, sz1.Height - sz2.Height);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.Size" /> structure to a <see cref="T:System.Drawing.Point" /> structure.</summary>
		/// <param name="size">The <see cref="T:System.Drawing.Size" /> structure to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.Point" /> structure to which this operator converts.</returns>
		public static explicit operator Point(Size size)
		{
			return new Point(size.Width, size.Height);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.Size" /> structure to a <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <param name="p">The <see cref="T:System.Drawing.Size" /> structure to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.SizeF" /> structure to which this operator converts.</returns>
		public static implicit operator SizeF(Size p)
		{
			return new SizeF(p.Width, p.Height);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Size" /> structure from the specified <see cref="T:System.Drawing.Point" /> structure.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.Point" /> structure from which to initialize this <see cref="T:System.Drawing.Size" /> structure.</param>
		public Size(Point pt)
		{
			width = pt.X;
			height = pt.Y;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Size" /> structure from the specified dimensions.</summary>
		/// <param name="width">The width component of the new <see cref="T:System.Drawing.Size" />.</param>
		/// <param name="height">The height component of the new <see cref="T:System.Drawing.Size" />.</param>
		public Size(int width, int height)
		{
			this.width = width;
			this.height = height;
		}

		/// <summary>Tests to see whether the specified object is a <see cref="T:System.Drawing.Size" /> structure with the same dimensions as this <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <param name="obj">The <see cref="T:System.Object" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.Size" /> and has the same width and height as this <see cref="T:System.Drawing.Size" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is Size))
			{
				return false;
			}
			return this == (Size)obj;
		}

		/// <summary>Returns a hash code for this <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <returns>An integer value that specifies a hash value for this <see cref="T:System.Drawing.Size" /> structure.</returns>
		public override int GetHashCode()
		{
			return width ^ height;
		}

		/// <summary>Creates a human-readable string that represents this <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <returns>A string that represents this <see cref="T:System.Drawing.Size" />.</returns>
		public override string ToString()
		{
			return $"{{Width={width}, Height={height}}}";
		}

		/// <summary>Adds the width and height of one <see cref="T:System.Drawing.Size" /> structure to the width and height of another <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <param name="sz1">The first <see cref="T:System.Drawing.Size" /> structure to add.</param>
		/// <param name="sz2">The second <see cref="T:System.Drawing.Size" /> structure to add.</param>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure that is the result of the addition operation.</returns>
		public static Size Add(Size sz1, Size sz2)
		{
			return new Size(sz1.Width + sz2.Width, sz1.Height + sz2.Height);
		}

		/// <summary>Subtracts the width and height of one <see cref="T:System.Drawing.Size" /> structure from the width and height of another <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.Size" /> structure on the left side of the subtraction operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.Size" /> structure on the right side of the subtraction operator.</param>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure that is a result of the subtraction operation.</returns>
		public static Size Subtract(Size sz1, Size sz2)
		{
			return new Size(sz1.Width - sz2.Width, sz1.Height - sz2.Height);
		}
	}
	/// <summary>The <see cref="T:System.Drawing.SizeConverter" /> class is used to convert from one data type to another. Access this class through the <see cref="T:System.ComponentModel.TypeDescriptor" /> object.</summary>
	public class SizeConverter : TypeConverter
	{
		/// <summary>Initializes a new <see cref="T:System.Drawing.SizeConverter" /> object.</summary>
		public SizeConverter()
		{
		}

		/// <summary>Determines whether this converter can convert an object in the specified source type to the native type of the converter.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="sourceType">The type you want to convert from.</param>
		/// <returns>This method returns <see langword="true" /> if this object can perform the conversion.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Gets a value indicating whether this converter can convert an object to the given destination type using the context.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to get additional information about the environment this converter is being called from. This can be <see langword="null" />, so always check. Also, properties on the context object can return <see langword="null" />.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> that represents the type you want to convert to.</param>
		/// <returns>This method returns <see langword="true" /> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(string))
			{
				return true;
			}
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts the specified object to the converter's native type.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">An <see cref="T:System.Globalization.CultureInfo" /> object that contains culture specific information, such as the language, calendar, and cultural conventions associated with a specific culture. It is based on the RFC 1766 standard.</param>
		/// <param name="value">The object to convert.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (culture == null)
			{
				culture = CultureInfo.CurrentCulture;
			}
			if (!(value is string text))
			{
				return base.ConvertFrom(context, culture, value);
			}
			string[] array = text.Split(culture.TextInfo.ListSeparator.ToCharArray());
			Int32Converter int32Converter = new Int32Converter();
			int[] array2 = new int[array.Length];
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = (int)int32Converter.ConvertFromString(context, culture, array[i]);
			}
			if (array.Length != 2)
			{
				throw new ArgumentException("Failed to parse Text(" + text + ") expected text in the format \"Width,Height.\"");
			}
			return new Size(array2[0], array2[1]);
		}

		/// <summary>Converts the specified object to the specified type.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">An <see cref="T:System.Globalization.CultureInfo" /> object that contains culture specific information, such as the language, calendar, and cultural conventions associated with a specific culture. It is based on the RFC 1766 standard.</param>
		/// <param name="value">The object to convert.</param>
		/// <param name="destinationType">The type to convert the object to.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (culture == null)
			{
				culture = CultureInfo.CurrentCulture;
			}
			if (value is Size size)
			{
				if (destinationType == typeof(string))
				{
					return size.Width.ToString(culture) + culture.TextInfo.ListSeparator + " " + size.Height.ToString(culture);
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					return new InstanceDescriptor(typeof(Size).GetConstructor(new Type[2]
					{
						typeof(int),
						typeof(int)
					}), new object[2] { size.Width, size.Height });
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <summary>Creates an object of this type by using a specified set of property values for the object. This is useful for creating non-changeable objects that have changeable properties.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> through which additional context can be provided.</param>
		/// <param name="propertyValues">A dictionary of new property values. The dictionary contains a series of name-value pairs, one for each property returned from the <see cref="M:System.Drawing.SizeConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object,System.Attribute[])" /> method.</param>
		/// <returns>The newly created object, or <see langword="null" /> if the object could not be created. The default implementation returns <see langword="null" />.</returns>
		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			object obj = propertyValues["Width"];
			object obj2 = propertyValues["Height"];
			if (obj == null || obj2 == null)
			{
				throw new ArgumentException("propertyValues");
			}
			int width = (int)obj;
			int height = (int)obj2;
			return new Size(width, height);
		}

		/// <summary>Determines whether changing a value on this object should require a call to the <see cref="M:System.Drawing.SizeConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> method to create a new value.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> through which additional context can be provided.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="M:System.Drawing.SizeConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> object should be called when a change is made to one or more properties of this object.</returns>
		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Retrieves the set of properties for this type. By default, a type does not have any properties to return.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> through which additional context can be provided.</param>
		/// <param name="value">The value of the object to get the properties for.</param>
		/// <param name="attributes">An array of <see cref="T:System.Attribute" /> objects that describe the properties.</param>
		/// <returns>The set of properties that should be exposed for this data type. If no properties should be exposed, this may return <see langword="null" />. The default implementation always returns <see langword="null" />.</returns>
		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			if (value is Size)
			{
				return TypeDescriptor.GetProperties(value, attributes);
			}
			return base.GetProperties(context, value, attributes);
		}

		/// <summary>Determines whether this object supports properties. By default, this is <see langword="false" />.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> through which additional context can be provided.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="M:System.Drawing.SizeConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object,System.Attribute[])" /> method should be called to find the properties of this object.</returns>
		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
	/// <summary>Stores an ordered pair of floating-point numbers, typically the width and height of a rectangle.</summary>
	[Serializable]
	[ComVisible(true)]
	[TypeConverter(typeof(SizeFConverter))]
	public struct SizeF
	{
		private float width;

		private float height;

		/// <summary>Gets a <see cref="T:System.Drawing.SizeF" /> structure that has a <see cref="P:System.Drawing.SizeF.Height" /> and <see cref="P:System.Drawing.SizeF.Width" /> value of 0.</summary>
		public static readonly SizeF Empty;

		/// <summary>Gets a value that indicates whether this <see cref="T:System.Drawing.SizeF" /> structure has zero width and height.</summary>
		/// <returns>
		///   <see langword="true" /> when this <see cref="T:System.Drawing.SizeF" /> structure has both a width and height of zero; otherwise, <see langword="false" />.</returns>
		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if ((double)width == 0.0)
				{
					return (double)height == 0.0;
				}
				return false;
			}
		}

		/// <summary>Gets or sets the horizontal component of this <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <returns>The horizontal component of this <see cref="T:System.Drawing.SizeF" /> structure, typically measured in pixels.</returns>
		public float Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		/// <summary>Gets or sets the vertical component of this <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <returns>The vertical component of this <see cref="T:System.Drawing.SizeF" /> structure, typically measured in pixels.</returns>
		public float Height
		{
			get
			{
				return height;
			}
			set
			{
				height = value;
			}
		}

		/// <summary>Adds the width and height of one <see cref="T:System.Drawing.SizeF" /> structure to the width and height of another <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <param name="sz1">The first <see cref="T:System.Drawing.SizeF" /> structure to add.</param>
		/// <param name="sz2">The second <see cref="T:System.Drawing.SizeF" /> structure to add.</param>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure that is the result of the addition operation.</returns>
		public static SizeF operator +(SizeF sz1, SizeF sz2)
		{
			return new SizeF(sz1.Width + sz2.Width, sz1.Height + sz2.Height);
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.SizeF" /> structures are equal.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.SizeF" /> structure on the left side of the equality operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.SizeF" /> structure on the right of the equality operator.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="sz1" /> and <paramref name="sz2" /> have equal width and height; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(SizeF sz1, SizeF sz2)
		{
			if (sz1.Width == sz2.Width)
			{
				return sz1.Height == sz2.Height;
			}
			return false;
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.SizeF" /> structures are different.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.SizeF" /> structure on the left of the inequality operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.SizeF" /> structure on the right of the inequality operator.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="sz1" /> and <paramref name="sz2" /> differ either in width or height; <see langword="false" /> if <paramref name="sz1" /> and <paramref name="sz2" /> are equal.</returns>
		public static bool operator !=(SizeF sz1, SizeF sz2)
		{
			if (sz1.Width == sz2.Width)
			{
				return sz1.Height != sz2.Height;
			}
			return true;
		}

		/// <summary>Subtracts the width and height of one <see cref="T:System.Drawing.SizeF" /> structure from the width and height of another <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.SizeF" /> structure on the left side of the subtraction operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.SizeF" /> structure on the right side of the subtraction operator.</param>
		/// <returns>A <see cref="T:System.Drawing.SizeF" /> that is the result of the subtraction operation.</returns>
		public static SizeF operator -(SizeF sz1, SizeF sz2)
		{
			return new SizeF(sz1.Width - sz2.Width, sz1.Height - sz2.Height);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.SizeF" /> structure to a <see cref="T:System.Drawing.PointF" /> structure.</summary>
		/// <param name="size">The <see cref="T:System.Drawing.SizeF" /> structure to be converted</param>
		/// <returns>The <see cref="T:System.Drawing.PointF" /> structure to which this operator converts.</returns>
		public static explicit operator PointF(SizeF size)
		{
			return new PointF(size.Width, size.Height);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.SizeF" /> structure from the specified <see cref="T:System.Drawing.PointF" /> structure.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> structure from which to initialize this <see cref="T:System.Drawing.SizeF" /> structure.</param>
		public SizeF(PointF pt)
		{
			width = pt.X;
			height = pt.Y;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.SizeF" /> structure from the specified existing <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <param name="size">The <see cref="T:System.Drawing.SizeF" /> structure from which to create the new <see cref="T:System.Drawing.SizeF" /> structure.</param>
		public SizeF(SizeF size)
		{
			width = size.Width;
			height = size.Height;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.SizeF" /> structure from the specified dimensions.</summary>
		/// <param name="width">The width component of the new <see cref="T:System.Drawing.SizeF" /> structure.</param>
		/// <param name="height">The height component of the new <see cref="T:System.Drawing.SizeF" /> structure.</param>
		public SizeF(float width, float height)
		{
			this.width = width;
			this.height = height;
		}

		/// <summary>Tests to see whether the specified object is a <see cref="T:System.Drawing.SizeF" /> structure with the same dimensions as this <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <param name="obj">The <see cref="T:System.Object" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.SizeF" /> and has the same width and height as this <see cref="T:System.Drawing.SizeF" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is SizeF))
			{
				return false;
			}
			return this == (SizeF)obj;
		}

		/// <summary>Returns a hash code for this <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <returns>An integer value that specifies a hash value for this <see cref="T:System.Drawing.Size" /> structure.</returns>
		public override int GetHashCode()
		{
			return (int)width ^ (int)height;
		}

		/// <summary>Converts a <see cref="T:System.Drawing.SizeF" /> structure to a <see cref="T:System.Drawing.PointF" /> structure.</summary>
		/// <returns>A <see cref="T:System.Drawing.PointF" /> structure.</returns>
		public PointF ToPointF()
		{
			return new PointF(width, height);
		}

		/// <summary>Converts a <see cref="T:System.Drawing.SizeF" /> structure to a <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure.</returns>
		public Size ToSize()
		{
			checked
			{
				int num = (int)width;
				int num2 = (int)height;
				return new Size(num, num2);
			}
		}

		/// <summary>Creates a human-readable string that represents this <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <returns>A string that represents this <see cref="T:System.Drawing.SizeF" /> structure.</returns>
		public override string ToString()
		{
			return $"{{Width={width.ToString(CultureInfo.CurrentCulture)}, Height={height.ToString(CultureInfo.CurrentCulture)}}}";
		}

		/// <summary>Adds the width and height of one <see cref="T:System.Drawing.SizeF" /> structure to the width and height of another <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <param name="sz1">The first <see cref="T:System.Drawing.SizeF" /> structure to add.</param>
		/// <param name="sz2">The second <see cref="T:System.Drawing.SizeF" /> structure to add.</param>
		/// <returns>A <see cref="T:System.Drawing.SizeF" /> structure that is the result of the addition operation.</returns>
		public static SizeF Add(SizeF sz1, SizeF sz2)
		{
			return new SizeF(sz1.Width + sz2.Width, sz1.Height + sz2.Height);
		}

		/// <summary>Subtracts the width and height of one <see cref="T:System.Drawing.SizeF" /> structure from the width and height of another <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.SizeF" /> structure on the left side of the subtraction operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.SizeF" /> structure on the right side of the subtraction operator.</param>
		/// <returns>A <see cref="T:System.Drawing.SizeF" /> structure that is a result of the subtraction operation.</returns>
		public static SizeF Subtract(SizeF sz1, SizeF sz2)
		{
			return new SizeF(sz1.Width - sz2.Width, sz1.Height - sz2.Height);
		}
	}
	/// <summary>Converts <see cref="T:System.Drawing.SizeF" /> objects from one type to another.</summary>
	public class SizeFConverter : TypeConverter
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.SizeFConverter" /> class.</summary>
		public SizeFConverter()
		{
		}

		/// <summary>Returns a value indicating whether the converter can convert from the type specified to the <see cref="T:System.Drawing.SizeF" /> type, using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be supplied.</param>
		/// <param name="sourceType">A <see cref="T:System.Type" /> the represents the type you wish to convert from.</param>
		/// <returns>
		///   <see langword="true" /> to indicate the conversion can be performed; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Returns a value indicating whether the <see cref="T:System.Drawing.SizeFConverter" /> can convert a <see cref="T:System.Drawing.SizeF" /> to the specified type.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be supplied.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> that represents the type you want to convert from.</param>
		/// <returns>
		///   <see langword="true" /> if this converter can perform the conversion otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(string))
			{
				return true;
			}
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts the given object to the type of this converter, using the specified context and culture information.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="culture">The <see cref="T:System.Globalization.CultureInfo" /> to use as the current culture.</param>
		/// <param name="value">The <see cref="T:System.Object" /> to convert.</param>
		/// <returns>An <see cref="T:System.Object" /> that represents the converted value.</returns>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (!(value is string text))
			{
				return base.ConvertFrom(context, culture, value);
			}
			if (culture == null)
			{
				culture = CultureInfo.CurrentCulture;
			}
			string[] array = text.Split(culture.TextInfo.ListSeparator.ToCharArray());
			SingleConverter singleConverter = new SingleConverter();
			float[] array2 = new float[array.Length];
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = (float)singleConverter.ConvertFromString(context, culture, array[i]);
			}
			if (array.Length != 2)
			{
				throw new ArgumentException("Failed to parse Text(" + text + ") expected text in the format \"Width,Height.\"");
			}
			return new SizeF(array2[0], array2[1]);
		}

		/// <summary>Converts the given value object to the specified type, using the specified context and culture information.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" />. If null is passed, the current culture is assumed.</param>
		/// <param name="value">The <see cref="T:System.Object" /> to convert.</param>
		/// <param name="destinationType">The <see cref="T:System.Type" /> to convert the value parameter to.</param>
		/// <returns>An <see cref="T:System.Object" /> that represents the converted value.</returns>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (value is SizeF sizeF)
			{
				if (destinationType == typeof(string))
				{
					return sizeF.Width.ToString(culture) + culture.TextInfo.ListSeparator + " " + sizeF.Height.ToString(culture);
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					return new InstanceDescriptor(typeof(SizeF).GetConstructor(new Type[2]
					{
						typeof(float),
						typeof(float)
					}), new object[2] { sizeF.Width, sizeF.Height });
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <summary>Creates an instance of a <see cref="T:System.Drawing.SizeF" /> with the specified property values using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be supplied.</param>
		/// <param name="propertyValues">An <see cref="T:System.Collections.IDictionary" /> containing property names and values.</param>
		/// <returns>An <see cref="T:System.Object" /> representing the new <see cref="T:System.Drawing.SizeF" />, or <see langword="null" /> if the object cannot be created.</returns>
		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			float width = (float)propertyValues["Width"];
			float height = (float)propertyValues["Height"];
			return new SizeF(width, height);
		}

		/// <summary>Returns a value indicating whether changing a value on this object requires a call to the <see cref="Overload:System.Drawing.SizeFConverter.CreateInstance" /> method to create a new value.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. This may be <see langword="null" />.</param>
		/// <returns>Always returns <see langword="true" />.</returns>
		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Retrieves a set of properties for the <see cref="T:System.Drawing.SizeF" /> type using the specified context and attributes.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be supplied.</param>
		/// <param name="value">The <see cref="T:System.Object" /> to return properties for.</param>
		/// <param name="attributes">An array of <see cref="T:System.Attribute" /> objects that describe the properties.</param>
		/// <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> containing the properties.</returns>
		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			if (value is SizeF)
			{
				return TypeDescriptor.GetProperties(value, attributes);
			}
			return base.GetProperties(context, value, attributes);
		}

		/// <summary>Returns whether the <see cref="T:System.Drawing.SizeF" /> type supports properties.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be supplied.</param>
		/// <returns>Always returns <see langword="true" />.</returns>
		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
	/// <summary>Encapsulates text layout information (such as alignment, orientation and tab stops) display manipulations (such as ellipsis insertion and national digit substitution) and OpenType features. This class cannot be inherited.</summary>
	public sealed class StringFormat : MarshalByRefObject, IDisposable, ICloneable
	{
		private IntPtr nativeStrFmt = IntPtr.Zero;

		private int language;

		/// <summary>Gets or sets horizontal alignment of the string.</summary>
		/// <returns>A <see cref="T:System.Drawing.StringAlignment" /> enumeration that specifies the horizontal  alignment of the string.</returns>
		public StringAlignment Alignment
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetStringFormatAlign(nativeStrFmt, out var align));
				return align;
			}
			set
			{
				if (value < StringAlignment.Near || value > StringAlignment.Far)
				{
					throw new InvalidEnumArgumentException("Alignment");
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetStringFormatAlign(nativeStrFmt, value));
			}
		}

		/// <summary>Gets or sets the vertical alignment of the string.</summary>
		/// <returns>A <see cref="T:System.Drawing.StringAlignment" /> enumeration that represents the vertical line alignment.</returns>
		public StringAlignment LineAlignment
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetStringFormatLineAlign(nativeStrFmt, out var align));
				return align;
			}
			set
			{
				if (value < StringAlignment.Near || value > StringAlignment.Far)
				{
					throw new InvalidEnumArgumentException("Alignment");
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetStringFormatLineAlign(nativeStrFmt, value));
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Drawing.StringFormatFlags" /> enumeration that contains formatting information.</summary>
		/// <returns>A <see cref="T:System.Drawing.StringFormatFlags" /> enumeration that contains formatting information.</returns>
		public StringFormatFlags FormatFlags
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetStringFormatFlags(nativeStrFmt, out var flags));
				return flags;
			}
			set
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetStringFormatFlags(nativeStrFmt, value));
			}
		}

		/// <summary>Gets or sets the <see cref="T:System.Drawing.Text.HotkeyPrefix" /> object for this <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <returns>The <see cref="T:System.Drawing.Text.HotkeyPrefix" /> object for this <see cref="T:System.Drawing.StringFormat" /> object, the default is <see cref="F:System.Drawing.Text.HotkeyPrefix.None" />.</returns>
		public HotkeyPrefix HotkeyPrefix
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetStringFormatHotkeyPrefix(nativeStrFmt, out var hotkeyPrefix));
				return hotkeyPrefix;
			}
			set
			{
				if (value < HotkeyPrefix.None || value > HotkeyPrefix.Hide)
				{
					throw new InvalidEnumArgumentException("HotkeyPrefix");
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetStringFormatHotkeyPrefix(nativeStrFmt, value));
			}
		}

		/// <summary>Gets or sets the <see cref="T:System.Drawing.StringTrimming" /> enumeration for this <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.StringTrimming" /> enumeration that indicates how text drawn with this <see cref="T:System.Drawing.StringFormat" /> object is trimmed when it exceeds the edges of the layout rectangle.</returns>
		public StringTrimming Trimming
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetStringFormatTrimming(nativeStrFmt, out var trimming));
				return trimming;
			}
			set
			{
				if (value < StringTrimming.None || value > StringTrimming.EllipsisPath)
				{
					throw new InvalidEnumArgumentException("Trimming");
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetStringFormatTrimming(nativeStrFmt, value));
			}
		}

		/// <summary>Gets a generic default <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <returns>The generic default <see cref="T:System.Drawing.StringFormat" /> object.</returns>
		public static StringFormat GenericDefault
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipStringFormatGetGenericDefault(out var format));
				return new StringFormat(format);
			}
		}

		/// <summary>Gets the language that is used when local digits are substituted for western digits.</summary>
		/// <returns>A National Language Support (NLS) language identifier that identifies the language that will be used when local digits are substituted for western digits. You can pass the <see cref="P:System.Globalization.CultureInfo.LCID" /> property of a <see cref="T:System.Globalization.CultureInfo" /> object as the NLS language identifier. For example, suppose you create a <see cref="T:System.Globalization.CultureInfo" /> object by passing the string "ar-EG" to a <see cref="T:System.Globalization.CultureInfo" /> constructor. If you pass the <see cref="P:System.Globalization.CultureInfo.LCID" /> property of that <see cref="T:System.Globalization.CultureInfo" /> object along with <see cref="F:System.Drawing.StringDigitSubstitute.Traditional" /> to the <see cref="M:System.Drawing.StringFormat.SetDigitSubstitution(System.Int32,System.Drawing.StringDigitSubstitute)" /> method, then Arabic-Indic digits will be substituted for western digits at display time.</returns>
		public int DigitSubstitutionLanguage => language;

		/// <summary>Gets a generic typographic <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <returns>A generic typographic <see cref="T:System.Drawing.StringFormat" /> object.</returns>
		public static StringFormat GenericTypographic
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipStringFormatGetGenericTypographic(out var format));
				return new StringFormat(format);
			}
		}

		/// <summary>Gets the method to be used for digit substitution.</summary>
		/// <returns>A <see cref="T:System.Drawing.StringDigitSubstitute" /> enumeration value that specifies how to substitute characters in a string that cannot be displayed because they are not supported by the current font.</returns>
		public StringDigitSubstitute DigitSubstitutionMethod
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetStringFormatDigitSubstitution(nativeStrFmt, language, out var substitute));
				return substitute;
			}
		}

		internal IntPtr NativeObject
		{
			get
			{
				return nativeStrFmt;
			}
			set
			{
				nativeStrFmt = value;
			}
		}

		internal IntPtr nativeFormat => nativeStrFmt;

		/// <summary>Initializes a new <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		public StringFormat()
			: this((StringFormatFlags)0, 0)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.StringFormat" /> object with the specified <see cref="T:System.Drawing.StringFormatFlags" /> enumeration and language.</summary>
		/// <param name="options">The <see cref="T:System.Drawing.StringFormatFlags" /> enumeration for the new <see cref="T:System.Drawing.StringFormat" /> object.</param>
		/// <param name="language">A value that indicates the language of the text.</param>
		public StringFormat(StringFormatFlags options, int language)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateStringFormat(options, language, out nativeStrFmt));
		}

		internal StringFormat(IntPtr native)
		{
			nativeStrFmt = native;
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~StringFormat()
		{
			Dispose(disposing: false);
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (nativeStrFmt != IntPtr.Zero)
			{
				Status status = GDIPlus.GdipDeleteStringFormat(nativeStrFmt);
				nativeStrFmt = IntPtr.Zero;
				GDIPlus.CheckStatus(status);
			}
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.StringFormat" /> object from the specified existing <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <param name="format">The <see cref="T:System.Drawing.StringFormat" /> object from which to initialize the new <see cref="T:System.Drawing.StringFormat" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="format" /> is <see langword="null" />.</exception>
		public StringFormat(StringFormat format)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCloneStringFormat(format.NativeObject, out nativeStrFmt));
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.StringFormat" /> object with the specified <see cref="T:System.Drawing.StringFormatFlags" /> enumeration.</summary>
		/// <param name="options">The <see cref="T:System.Drawing.StringFormatFlags" /> enumeration for the new <see cref="T:System.Drawing.StringFormat" /> object.</param>
		public StringFormat(StringFormatFlags options)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateStringFormat(options, 0, out nativeStrFmt));
		}

		/// <summary>Specifies an array of <see cref="T:System.Drawing.CharacterRange" /> structures that represent the ranges of characters measured by a call to the <see cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" /> method.</summary>
		/// <param name="ranges">An array of <see cref="T:System.Drawing.CharacterRange" /> structures that specifies the ranges of characters measured by a call to the <see cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" /> method.</param>
		/// <exception cref="T:System.OverflowException">More than 32 character ranges are set.</exception>
		public void SetMeasurableCharacterRanges(CharacterRange[] ranges)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipSetStringFormatMeasurableCharacterRanges(nativeStrFmt, ranges.Length, ranges));
		}

		internal int GetMeasurableCharacterRangeCount()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipGetStringFormatMeasurableCharacterRangeCount(nativeStrFmt, out var cnt));
			return cnt;
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <returns>The <see cref="T:System.Drawing.StringFormat" /> object this method creates.</returns>
		public object Clone()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCloneStringFormat(nativeStrFmt, out var format));
			return new StringFormat(format);
		}

		/// <summary>Converts this <see cref="T:System.Drawing.StringFormat" /> object to a human-readable string.</summary>
		/// <returns>A string representation of this <see cref="T:System.Drawing.StringFormat" /> object.</returns>
		public override string ToString()
		{
			return "[StringFormat, FormatFlags=" + FormatFlags.ToString() + "]";
		}

		/// <summary>Sets tab stops for this <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <param name="firstTabOffset">The number of spaces between the beginning of a line of text and the first tab stop.</param>
		/// <param name="tabStops">An array of distances between tab stops in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property.</param>
		public void SetTabStops(float firstTabOffset, float[] tabStops)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipSetStringFormatTabStops(nativeStrFmt, firstTabOffset, tabStops.Length, tabStops));
		}

		/// <summary>Specifies the language and method to be used when local digits are substituted for western digits.</summary>
		/// <param name="language">A National Language Support (NLS) language identifier that identifies the language that will be used when local digits are substituted for western digits. You can pass the <see cref="P:System.Globalization.CultureInfo.LCID" /> property of a <see cref="T:System.Globalization.CultureInfo" /> object as the NLS language identifier. For example, suppose you create a <see cref="T:System.Globalization.CultureInfo" /> object by passing the string "ar-EG" to a <see cref="T:System.Globalization.CultureInfo" /> constructor. If you pass the <see cref="P:System.Globalization.CultureInfo.LCID" /> property of that <see cref="T:System.Globalization.CultureInfo" /> object along with <see cref="F:System.Drawing.StringDigitSubstitute.Traditional" /> to the <see cref="M:System.Drawing.StringFormat.SetDigitSubstitution(System.Int32,System.Drawing.StringDigitSubstitute)" /> method, then Arabic-Indic digits will be substituted for western digits at display time.</param>
		/// <param name="substitute">An element of the <see cref="T:System.Drawing.StringDigitSubstitute" /> enumeration that specifies how digits are displayed.</param>
		public void SetDigitSubstitution(int language, StringDigitSubstitute substitute)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipSetStringFormatDigitSubstitution(nativeStrFmt, this.language, substitute));
		}

		/// <summary>Gets the tab stops for this <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <param name="firstTabOffset">The number of spaces between the beginning of a text line and the first tab stop.</param>
		/// <returns>An array of distances (in number of spaces) between tab stops.</returns>
		public float[] GetTabStops(out float firstTabOffset)
		{
			int count = 0;
			firstTabOffset = 0f;
			GDIPlus.CheckStatus(GDIPlus.GdipGetStringFormatTabStopCount(nativeStrFmt, out count));
			float[] array = new float[count];
			if (count != 0)
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetStringFormatTabStops(nativeStrFmt, count, out firstTabOffset, array));
			}
			return array;
		}
	}
	/// <summary>Each property of the <see cref="T:System.Drawing.SystemColors" /> class is a <see cref="T:System.Drawing.Color" /> structure that is the color of a Windows display element.</summary>
	public sealed class SystemColors
	{
		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the active window's border.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the active window's border.</returns>
		public static Color ActiveBorder => KnownColors.FromKnownColor(KnownColor.ActiveBorder);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the background of the active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the active window's title bar.</returns>
		public static Color ActiveCaption => KnownColors.FromKnownColor(KnownColor.ActiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the text in the active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the text in the active window's title bar.</returns>
		public static Color ActiveCaptionText => KnownColors.FromKnownColor(KnownColor.ActiveCaptionText);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the application workspace.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the application workspace.</returns>
		public static Color AppWorkspace => KnownColors.FromKnownColor(KnownColor.AppWorkspace);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the face color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the face color of a 3-D element.</returns>
		public static Color Control => KnownColors.FromKnownColor(KnownColor.Control);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the shadow color of a 3-D element.</returns>
		public static Color ControlDark => KnownColors.FromKnownColor(KnownColor.ControlDark);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the dark shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the dark shadow color of a 3-D element.</returns>
		public static Color ControlDarkDark => KnownColors.FromKnownColor(KnownColor.ControlDarkDark);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the light color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the light color of a 3-D element.</returns>
		public static Color ControlLight => KnownColors.FromKnownColor(KnownColor.ControlLight);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the highlight color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the highlight color of a 3-D element.</returns>
		public static Color ControlLightLight => KnownColors.FromKnownColor(KnownColor.ControlLightLight);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of text in a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of text in a 3-D element.</returns>
		public static Color ControlText => KnownColors.FromKnownColor(KnownColor.ControlText);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the desktop.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the desktop.</returns>
		public static Color Desktop => KnownColors.FromKnownColor(KnownColor.Desktop);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of dimmed text.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of dimmed text.</returns>
		public static Color GrayText => KnownColors.FromKnownColor(KnownColor.GrayText);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the background of selected items.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the background of selected items.</returns>
		public static Color Highlight => KnownColors.FromKnownColor(KnownColor.Highlight);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the text of selected items.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the text of selected items.</returns>
		public static Color HighlightText => KnownColors.FromKnownColor(KnownColor.HighlightText);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color used to designate a hot-tracked item.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color used to designate a hot-tracked item.</returns>
		public static Color HotTrack => KnownColors.FromKnownColor(KnownColor.HotTrack);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of an inactive window's border.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of an inactive window's border.</returns>
		public static Color InactiveBorder => KnownColors.FromKnownColor(KnownColor.InactiveBorder);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the background of an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the background of an inactive window's title bar.</returns>
		public static Color InactiveCaption => KnownColors.FromKnownColor(KnownColor.InactiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the text in an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the text in an inactive window's title bar.</returns>
		public static Color InactiveCaptionText => KnownColors.FromKnownColor(KnownColor.InactiveCaptionText);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the background of a ToolTip.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the background of a ToolTip.</returns>
		public static Color Info => KnownColors.FromKnownColor(KnownColor.Info);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the text of a ToolTip.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the text of a ToolTip.</returns>
		public static Color InfoText => KnownColors.FromKnownColor(KnownColor.InfoText);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of a menu's background.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of a menu's background.</returns>
		public static Color Menu => KnownColors.FromKnownColor(KnownColor.Menu);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of a menu's text.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of a menu's text.</returns>
		public static Color MenuText => KnownColors.FromKnownColor(KnownColor.MenuText);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the background of a scroll bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the background of a scroll bar.</returns>
		public static Color ScrollBar => KnownColors.FromKnownColor(KnownColor.ScrollBar);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the background in the client area of a window.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the background in the client area of a window.</returns>
		public static Color Window => KnownColors.FromKnownColor(KnownColor.Window);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of a window frame.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of a window frame.</returns>
		public static Color WindowFrame => KnownColors.FromKnownColor(KnownColor.WindowFrame);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the text in the client area of a window.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the text in the client area of a window.</returns>
		public static Color WindowText => KnownColors.FromKnownColor(KnownColor.WindowText);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the face color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the face color of a 3-D element.</returns>
		public static Color ButtonFace => KnownColors.FromKnownColor(KnownColor.ButtonFace);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the highlight color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the highlight color of a 3-D element.</returns>
		public static Color ButtonHighlight => KnownColors.FromKnownColor(KnownColor.ButtonHighlight);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the shadow color of a 3-D element.</returns>
		public static Color ButtonShadow => KnownColors.FromKnownColor(KnownColor.ButtonShadow);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the lightest color in the color gradient of an active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the lightest color in the color gradient of an active window's title bar.</returns>
		public static Color GradientActiveCaption => KnownColors.FromKnownColor(KnownColor.GradientActiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the lightest color in the color gradient of an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the lightest color in the color gradient of an inactive window's title bar.</returns>
		public static Color GradientInactiveCaption => KnownColors.FromKnownColor(KnownColor.GradientInactiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the background of a menu bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the background of a menu bar.</returns>
		public static Color MenuBar => KnownColors.FromKnownColor(KnownColor.MenuBar);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color used to highlight menu items when the menu appears as a flat menu.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color used to highlight menu items when the menu appears as a flat menu.</returns>
		public static Color MenuHighlight => KnownColors.FromKnownColor(KnownColor.MenuHighlight);

		private SystemColors()
		{
		}
	}
	/// <summary>Specifies the fonts used to display text in Windows display elements.</summary>
	public sealed class SystemFonts
	{
		/// <summary>Gets a <see cref="T:System.Drawing.Font" /> that is used to display text in the title bars of windows.</summary>
		/// <returns>A <see cref="T:System.Drawing.Font" /> that is used to display text in the title bars of windows.</returns>
		public static Font CaptionFont => new Font("Microsoft Sans Serif", 11f, "CaptionFont");

		/// <summary>Gets the default font that applications can use for dialog boxes and forms.</summary>
		/// <returns>The default <see cref="T:System.Drawing.Font" /> of the system. The value returned will vary depending on the user's operating system and the local culture setting of their system.</returns>
		public static Font DefaultFont => new Font("Microsoft Sans Serif", 8.25f, "DefaultFont");

		/// <summary>Gets a font that applications can use for dialog boxes and forms.</summary>
		/// <returns>A <see cref="T:System.Drawing.Font" /> that can be used for dialog boxes and forms, depending on the operating system and local culture setting of the system.</returns>
		public static Font DialogFont => new Font("Tahoma", 8f, "DialogFont");

		/// <summary>Gets a <see cref="T:System.Drawing.Font" /> that is used for icon titles.</summary>
		/// <returns>A <see cref="T:System.Drawing.Font" /> that is used for icon titles.</returns>
		public static Font IconTitleFont => new Font("Microsoft Sans Serif", 11f, "IconTitleFont");

		/// <summary>Gets a <see cref="T:System.Drawing.Font" /> that is used for menus.</summary>
		/// <returns>A <see cref="T:System.Drawing.Font" /> that is used for menus.</returns>
		public static Font MenuFont => new Font("Microsoft Sans Serif", 11f, "MenuFont");

		/// <summary>Gets a <see cref="T:System.Drawing.Font" /> that is used for message boxes.</summary>
		/// <returns>A <see cref="T:System.Drawing.Font" /> that is used for message boxes</returns>
		public static Font MessageBoxFont => new Font("Microsoft Sans Serif", 11f, "MessageBoxFont");

		/// <summary>Gets a <see cref="T:System.Drawing.Font" /> that is used to display text in the title bars of small windows, such as tool windows.</summary>
		/// <returns>A <see cref="T:System.Drawing.Font" /> that is used to display text in the title bars of small windows, such as tool windows.</returns>
		public static Font SmallCaptionFont => new Font("Microsoft Sans Serif", 11f, "SmallCaptionFont");

		/// <summary>Gets a <see cref="T:System.Drawing.Font" /> that is used to display text in the status bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Font" /> that is used to display text in the status bar.</returns>
		public static Font StatusFont => new Font("Microsoft Sans Serif", 11f, "StatusFont");

		static SystemFonts()
		{
		}

		private SystemFonts()
		{
		}

		/// <summary>Returns a font object that corresponds to the specified system font name.</summary>
		/// <param name="systemFontName">The name of the system font you need a font object for.</param>
		/// <returns>A <see cref="T:System.Drawing.Font" /> if the specified name matches a value in <see cref="T:System.Drawing.SystemFonts" />; otherwise, <see langword="null" />.</returns>
		public static Font GetFontByName(string systemFontName)
		{
			return systemFontName switch
			{
				"CaptionFont" => CaptionFont, 
				"DefaultFont" => DefaultFont, 
				"DialogFont" => DialogFont, 
				"IconTitleFont" => IconTitleFont, 
				"MenuFont" => MenuFont, 
				"MessageBoxFont" => MessageBoxFont, 
				"SmallCaptionFont" => SmallCaptionFont, 
				"StatusFont" => StatusFont, 
				_ => null, 
			};
		}
	}
	/// <summary>Each property of the <see cref="T:System.Drawing.SystemIcons" /> class is an <see cref="T:System.Drawing.Icon" /> object for Windows system-wide icons. This class cannot be inherited.</summary>
	public sealed class SystemIcons
	{
		private static Icon[] icons;

		private const int Application_Winlogo = 0;

		private const int Asterisk_Information = 1;

		private const int Error_Hand = 2;

		private const int Exclamation_Warning = 3;

		private const int Question_ = 4;

		private const int Shield_ = 5;

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the default application icon (WIN32: IDI_APPLICATION).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the default application icon.</returns>
		public static Icon Application => icons[0];

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the system asterisk icon (WIN32: IDI_ASTERISK).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the system asterisk icon.</returns>
		public static Icon Asterisk => icons[1];

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the system error icon (WIN32: IDI_ERROR).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the system error icon.</returns>
		public static Icon Error => icons[2];

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the system exclamation icon (WIN32: IDI_EXCLAMATION).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the system exclamation icon.</returns>
		public static Icon Exclamation => icons[3];

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the system hand icon (WIN32: IDI_HAND).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the system hand icon.</returns>
		public static Icon Hand => icons[2];

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the system information icon (WIN32: IDI_INFORMATION).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the system information icon.</returns>
		public static Icon Information => icons[1];

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the system question icon (WIN32: IDI_QUESTION).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the system question icon.</returns>
		public static Icon Question => icons[4];

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the system warning icon (WIN32: IDI_WARNING).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the system warning icon.</returns>
		public static Icon Warning => icons[3];

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the Windows logo icon (WIN32: IDI_WINLOGO).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the Windows logo icon.</returns>
		public static Icon WinLogo => icons[0];

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the shield icon.</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the shield icon.</returns>
		public static Icon Shield => icons[5];

		static SystemIcons()
		{
			icons = new Icon[6];
			icons[0] = new Icon("Mono.ico", undisposable: true);
			icons[1] = new Icon("Information.ico", undisposable: true);
			icons[2] = new Icon("Error.ico", undisposable: true);
			icons[3] = new Icon("Warning.ico", undisposable: true);
			icons[4] = new Icon("Question.ico", undisposable: true);
			icons[5] = new Icon("Shield.ico", undisposable: true);
		}

		private SystemIcons()
		{
		}
	}
	/// <summary>Each property of the <see cref="T:System.Drawing.SystemPens" /> class is a <see cref="T:System.Drawing.Pen" /> that is the color of a Windows display element and that has a width of 1 pixel.</summary>
	public sealed class SystemPens
	{
		private static Pen active_caption_text;

		private static Pen control;

		private static Pen control_dark;

		private static Pen control_dark_dark;

		private static Pen control_light;

		private static Pen control_light_light;

		private static Pen control_text;

		private static Pen gray_text;

		private static Pen highlight;

		private static Pen highlight_text;

		private static Pen inactive_caption_text;

		private static Pen info_text;

		private static Pen menu_text;

		private static Pen window_frame;

		private static Pen window_text;

		private static Pen active_border;

		private static Pen active_caption;

		private static Pen app_workspace;

		private static Pen button_face;

		private static Pen button_highlight;

		private static Pen button_shadow;

		private static Pen desktop;

		private static Pen gradient_activecaption;

		private static Pen gradient_inactivecaption;

		private static Pen hot_track;

		private static Pen inactive_border;

		private static Pen inactive_caption;

		private static Pen info;

		private static Pen menu;

		private static Pen menu_bar;

		private static Pen menu_highlight;

		private static Pen scroll_bar;

		private static Pen window;

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the text in the active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the text in the active window's title bar.</returns>
		public static Pen ActiveCaptionText
		{
			get
			{
				if (active_caption_text == null)
				{
					active_caption_text = new Pen(SystemColors.ActiveCaptionText);
					active_caption_text.isModifiable = false;
				}
				return active_caption_text;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the face color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the face color of a 3-D element.</returns>
		public static Pen Control
		{
			get
			{
				if (control == null)
				{
					control = new Pen(SystemColors.Control);
					control.isModifiable = false;
				}
				return control;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the shadow color of a 3-D element.</returns>
		public static Pen ControlDark
		{
			get
			{
				if (control_dark == null)
				{
					control_dark = new Pen(SystemColors.ControlDark);
					control_dark.isModifiable = false;
				}
				return control_dark;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the dark shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the dark shadow color of a 3-D element.</returns>
		public static Pen ControlDarkDark
		{
			get
			{
				if (control_dark_dark == null)
				{
					control_dark_dark = new Pen(SystemColors.ControlDarkDark);
					control_dark_dark.isModifiable = false;
				}
				return control_dark_dark;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the light color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the light color of a 3-D element.</returns>
		public static Pen ControlLight
		{
			get
			{
				if (control_light == null)
				{
					control_light = new Pen(SystemColors.ControlLight);
					control_light.isModifiable = false;
				}
				return control_light;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the highlight color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the highlight color of a 3-D element.</returns>
		public static Pen ControlLightLight
		{
			get
			{
				if (control_light_light == null)
				{
					control_light_light = new Pen(SystemColors.ControlLightLight);
					control_light_light.isModifiable = false;
				}
				return control_light_light;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of text in a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of text in a 3-D element.</returns>
		public static Pen ControlText
		{
			get
			{
				if (control_text == null)
				{
					control_text = new Pen(SystemColors.ControlText);
					control_text.isModifiable = false;
				}
				return control_text;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of dimmed text.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of dimmed text.</returns>
		public static Pen GrayText
		{
			get
			{
				if (gray_text == null)
				{
					gray_text = new Pen(SystemColors.GrayText);
					gray_text.isModifiable = false;
				}
				return gray_text;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the background of selected items.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the background of selected items.</returns>
		public static Pen Highlight
		{
			get
			{
				if (highlight == null)
				{
					highlight = new Pen(SystemColors.Highlight);
					highlight.isModifiable = false;
				}
				return highlight;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the text of selected items.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the text of selected items.</returns>
		public static Pen HighlightText
		{
			get
			{
				if (highlight_text == null)
				{
					highlight_text = new Pen(SystemColors.HighlightText);
					highlight_text.isModifiable = false;
				}
				return highlight_text;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the text in an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the text in an inactive window's title bar.</returns>
		public static Pen InactiveCaptionText
		{
			get
			{
				if (inactive_caption_text == null)
				{
					inactive_caption_text = new Pen(SystemColors.InactiveCaptionText);
					inactive_caption_text.isModifiable = false;
				}
				return inactive_caption_text;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the text of a ToolTip.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the text of a ToolTip.</returns>
		public static Pen InfoText
		{
			get
			{
				if (info_text == null)
				{
					info_text = new Pen(SystemColors.InfoText);
					info_text.isModifiable = false;
				}
				return info_text;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of a menu's text.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of a menu's text.</returns>
		public static Pen MenuText
		{
			get
			{
				if (menu_text == null)
				{
					menu_text = new Pen(SystemColors.MenuText);
					menu_text.isModifiable = false;
				}
				return menu_text;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of a window frame.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of a window frame.</returns>
		public static Pen WindowFrame
		{
			get
			{
				if (window_frame == null)
				{
					window_frame = new Pen(SystemColors.WindowFrame);
					window_frame.isModifiable = false;
				}
				return window_frame;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the text in the client area of a window.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the text in the client area of a window.</returns>
		public static Pen WindowText
		{
			get
			{
				if (window_text == null)
				{
					window_text = new Pen(SystemColors.WindowText);
					window_text.isModifiable = false;
				}
				return window_text;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the active window's border.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the active window's border.</returns>
		public static Pen ActiveBorder
		{
			get
			{
				if (active_border == null)
				{
					active_border = new Pen(SystemColors.ActiveBorder);
					active_border.isModifiable = false;
				}
				return active_border;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the background of the active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the background of the active window's title bar.</returns>
		public static Pen ActiveCaption
		{
			get
			{
				if (active_caption == null)
				{
					active_caption = new Pen(SystemColors.ActiveCaption);
					active_caption.isModifiable = false;
				}
				return active_caption;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the application workspace.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the application workspace.</returns>
		public static Pen AppWorkspace
		{
			get
			{
				if (app_workspace == null)
				{
					app_workspace = new Pen(SystemColors.AppWorkspace);
					app_workspace.isModifiable = false;
				}
				return app_workspace;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the face color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the face color of a 3-D element.</returns>
		public static Pen ButtonFace
		{
			get
			{
				if (button_face == null)
				{
					button_face = new Pen(SystemColors.ButtonFace);
					button_face.isModifiable = false;
				}
				return button_face;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the highlight color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the highlight color of a 3-D element.</returns>
		public static Pen ButtonHighlight
		{
			get
			{
				if (button_highlight == null)
				{
					button_highlight = new Pen(SystemColors.ButtonHighlight);
					button_highlight.isModifiable = false;
				}
				return button_highlight;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the shadow color of a 3-D element.</returns>
		public static Pen ButtonShadow
		{
			get
			{
				if (button_shadow == null)
				{
					button_shadow = new Pen(SystemColors.ButtonShadow);
					button_shadow.isModifiable = false;
				}
				return button_shadow;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the Windows desktop.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the Windows desktop.</returns>
		public static Pen Desktop
		{
			get
			{
				if (desktop == null)
				{
					desktop = new Pen(SystemColors.Desktop);
					desktop.isModifiable = false;
				}
				return desktop;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the lightest color in the color gradient of an active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the lightest color in the color gradient of an active window's title bar.</returns>
		public static Pen GradientActiveCaption
		{
			get
			{
				if (gradient_activecaption == null)
				{
					gradient_activecaption = new Pen(SystemColors.GradientActiveCaption);
					gradient_activecaption.isModifiable = false;
				}
				return gradient_activecaption;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the lightest color in the color gradient of an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the lightest color in the color gradient of an inactive window's title bar.</returns>
		public static Pen GradientInactiveCaption
		{
			get
			{
				if (gradient_inactivecaption == null)
				{
					gradient_inactivecaption = new Pen(SystemColors.GradientInactiveCaption);
					gradient_inactivecaption.isModifiable = false;
				}
				return gradient_inactivecaption;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color used to designate a hot-tracked item.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color used to designate a hot-tracked item.</returns>
		public static Pen HotTrack
		{
			get
			{
				if (hot_track == null)
				{
					hot_track = new Pen(SystemColors.HotTrack);
					hot_track.isModifiable = false;
				}
				return hot_track;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> is the color of the border of an inactive window.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the border of an inactive window.</returns>
		public static Pen InactiveBorder
		{
			get
			{
				if (inactive_border == null)
				{
					inactive_border = new Pen(SystemColors.InactiveBorder);
					inactive_border.isModifiable = false;
				}
				return inactive_border;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the title bar caption of an inactive window.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the title bar caption of an inactive window.</returns>
		public static Pen InactiveCaption
		{
			get
			{
				if (inactive_caption == null)
				{
					inactive_caption = new Pen(SystemColors.InactiveCaption);
					inactive_caption.isModifiable = false;
				}
				return inactive_caption;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the background of a ToolTip.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the background of a ToolTip.</returns>
		public static Pen Info
		{
			get
			{
				if (info == null)
				{
					info = new Pen(SystemColors.Info);
					info.isModifiable = false;
				}
				return info;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of a menu's background.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of a menu's background.</returns>
		public static Pen Menu
		{
			get
			{
				if (menu == null)
				{
					menu = new Pen(SystemColors.Menu);
					menu.isModifiable = false;
				}
				return menu;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the background of a menu bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the background of a menu bar.</returns>
		public static Pen MenuBar
		{
			get
			{
				if (menu_bar == null)
				{
					menu_bar = new Pen(SystemColors.MenuBar);
					menu_bar.isModifiable = false;
				}
				return menu_bar;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color used to highlight menu items when the menu appears as a flat menu.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color used to highlight menu items when the menu appears as a flat menu.</returns>
		public static Pen MenuHighlight
		{
			get
			{
				if (menu_highlight == null)
				{
					menu_highlight = new Pen(SystemColors.MenuHighlight);
					menu_highlight.isModifiable = false;
				}
				return menu_highlight;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the background of a scroll bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the background of a scroll bar.</returns>
		public static Pen ScrollBar
		{
			get
			{
				if (scroll_bar == null)
				{
					scroll_bar = new Pen(SystemColors.ScrollBar);
					scroll_bar.isModifiable = false;
				}
				return scroll_bar;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the background in the client area of a window.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the background in the client area of a window.</returns>
		public static Pen Window
		{
			get
			{
				if (window == null)
				{
					window = new Pen(SystemColors.Window);
					window.isModifiable = false;
				}
				return window;
			}
		}

		private SystemPens()
		{
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Pen" /> from the specified <see cref="T:System.Drawing.Color" />.</summary>
		/// <param name="c">The <see cref="T:System.Drawing.Color" /> for the new <see cref="T:System.Drawing.Pen" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Pen" /> this method creates.</returns>
		public static Pen FromSystemColor(Color c)
		{
			if (c.IsSystemColor)
			{
				return new Pen(c)
				{
					isModifiable = false
				};
			}
			throw new ArgumentException($"The color {c} is not a system color.");
		}
	}
	/// <summary>Allows you to specify an icon to represent a control in a container, such as the Microsoft Visual Studio Form Designer.</summary>
	[AttributeUsage(AttributeTargets.Class)]
	public class ToolboxBitmapAttribute : Attribute
	{
		private Image smallImage;

		private Image bigImage;

		/// <summary>A <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object that has its small image and its large image set to <see langword="null" />.</summary>
		public static readonly ToolboxBitmapAttribute Default = new ToolboxBitmapAttribute();

		private ToolboxBitmapAttribute()
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object with an image from a specified file.</summary>
		/// <param name="imageFile">The name of a file that contains a 16 by 16 bitmap.</param>
		public ToolboxBitmapAttribute(string imageFile)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object based on a 16 x 16 bitmap that is embedded as a resource in a specified assembly.</summary>
		/// <param name="t">A <see cref="T:System.Type" /> whose defining assembly is searched for the bitmap resource.</param>
		public ToolboxBitmapAttribute(Type t)
		{
			smallImage = GetImageFromResource(t, null, large: false);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object based on a 16 by 16 bitmap that is embedded as a resource in a specified assembly.</summary>
		/// <param name="t">A <see cref="T:System.Type" /> whose defining assembly is searched for the bitmap resource.</param>
		/// <param name="name">The name of the embedded bitmap resource.</param>
		public ToolboxBitmapAttribute(Type t, string name)
		{
			smallImage = GetImageFromResource(t, name, large: false);
		}

		/// <summary>Indicates whether the specified object is a <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object and is identical to this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</summary>
		/// <param name="value">The <see cref="T:System.Object" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if <paramref name="value" /> is both a <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object and is identical to this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</returns>
		public override bool Equals(object value)
		{
			if (!(value is ToolboxBitmapAttribute))
			{
				return false;
			}
			if (value == this)
			{
				return true;
			}
			return ((ToolboxBitmapAttribute)value).smallImage == smallImage;
		}

		/// <summary>Gets a hash code for this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</summary>
		/// <returns>The hash code for this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</returns>
		public override int GetHashCode()
		{
			return smallImage.GetHashCode() ^ bigImage.GetHashCode();
		}

		/// <summary>Gets the small <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</summary>
		/// <param name="component">If this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object does not already have a small image, this method searches for a bitmap resource in the assembly that defines the type of the object specified by the component parameter. For example, if you pass an object of type ControlA to the component parameter, then this method searches the assembly that defines ControlA.</param>
		/// <returns>The small <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</returns>
		public Image GetImage(object component)
		{
			return GetImage(component.GetType(), null, large: false);
		}

		/// <summary>Gets the small or large <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</summary>
		/// <param name="component">If this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object does not already have a small image, this method searches for a bitmap resource in the assembly that defines the type of the object specified by the component parameter. For example, if you pass an object of type ControlA to the component parameter, then this method searches the assembly that defines ControlA.</param>
		/// <param name="large">Specifies whether this method returns a large image (<see langword="true" />) or a small image (<see langword="false" />). The small image is 16 by 16, and the large image is 32 by 32.</param>
		/// <returns>An <see cref="T:System.Drawing.Image" /> object associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</returns>
		public Image GetImage(object component, bool large)
		{
			return GetImage(component.GetType(), null, large);
		}

		/// <summary>Gets the small <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</summary>
		/// <param name="type">If this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object does not already have a small image, this method searches for a bitmap resource in the assembly that defines the type specified by the type parameter. For example, if you pass typeof(ControlA) to the type parameter, then this method searches the assembly that defines ControlA.</param>
		/// <returns>The small <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</returns>
		public Image GetImage(Type type)
		{
			return GetImage(type, null, large: false);
		}

		/// <summary>Gets the small or large <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</summary>
		/// <param name="type">If this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object does not already have a small image, this method searches for a bitmap resource in the assembly that defines the type specified by the component type. For example, if you pass typeof(ControlA) to the type parameter, then this method searches the assembly that defines ControlA.</param>
		/// <param name="large">Specifies whether this method returns a large image (<see langword="true" />) or a small image (<see langword="false" />). The small image is 16 by 16, and the large image is 32 by 32.</param>
		/// <returns>An <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</returns>
		public Image GetImage(Type type, bool large)
		{
			return GetImage(type, null, large);
		}

		/// <summary>Gets the small or large <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</summary>
		/// <param name="type">If this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object does not already have a small image, this method searches for an embedded bitmap resource in the assembly that defines the type specified by the component type. For example, if you pass typeof(ControlA) to the type parameter, then this method searches the assembly that defines ControlA.</param>
		/// <param name="imgName">The name of the embedded bitmap resource.</param>
		/// <param name="large">Specifies whether this method returns a large image (<see langword="true" />) or a small image (<see langword="false" />). The small image is 16 by 16, and the large image is 32 by 32.</param>
		/// <returns>An <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</returns>
		public Image GetImage(Type type, string imgName, bool large)
		{
			if (smallImage == null)
			{
				smallImage = GetImageFromResource(type, imgName, large: false);
			}
			if (large)
			{
				if (bigImage == null)
				{
					bigImage = new Bitmap(smallImage, 32, 32);
				}
				return bigImage;
			}
			return smallImage;
		}

		/// <summary>Returns an <see cref="T:System.Drawing.Image" /> object based on a bitmap resource that is embedded in an assembly.</summary>
		/// <param name="t">This method searches for an embedded bitmap resource in the assembly that defines the type specified by the t parameter. For example, if you pass typeof(ControlA) to the t parameter, then this method searches the assembly that defines ControlA.</param>
		/// <param name="imageName">The name of the embedded bitmap resource.</param>
		/// <param name="large">Specifies whether this method returns a large image (true) or a small image (false). The small image is 16 by 16, and the large image is 32 x 32.</param>
		/// <returns>An <see cref="T:System.Drawing.Image" /> object based on the retrieved bitmap.</returns>
		public static Image GetImageFromResource(Type t, string imageName, bool large)
		{
			if (imageName == null)
			{
				imageName = t.Name + ".bmp";
			}
			try
			{
				Bitmap bitmap;
				using (Stream stream = t.GetTypeInfo().Assembly.GetManifestResourceStream(t.Namespace + "." + imageName))
				{
					if (stream == null)
					{
						return null;
					}
					bitmap = new Bitmap(stream, useIcm: false);
				}
				if (large)
				{
					return new Bitmap(bitmap, 32, 32);
				}
				return bitmap;
			}
			catch
			{
				return null;
			}
		}
	}
	internal enum Status
	{
		Ok,
		GenericError,
		InvalidParameter,
		OutOfMemory,
		ObjectBusy,
		InsufficientBuffer,
		NotImplemented,
		Win32Error,
		WrongState,
		Aborted,
		FileNotFound,
		ValueOverflow,
		AccessDenied,
		UnknownImageFormat,
		FontFamilyNotFound,
		FontStyleNotFound,
		NotTrueTypeFont,
		UnsupportedGdiplusVersion,
		GdiplusNotInitialized,
		PropertyNotFound,
		PropertyNotSupported,
		ProfileNotFound
	}
	internal enum BrushType
	{
		BrushTypeSolidColor,
		BrushTypeHatchFill,
		BrushTypeTextureFill,
		BrushTypePathGradient,
		BrushTypeLinearGradient
	}
	internal enum ImageType
	{
		Unknown,
		Bitmap,
		Metafile
	}
	internal enum GetSysColorIndex
	{
		COLOR_SCROLLBAR = 0,
		COLOR_BACKGROUND = 1,
		COLOR_ACTIVECAPTION = 2,
		COLOR_INACTIVECAPTION = 3,
		COLOR_MENU = 4,
		COLOR_WINDOW = 5,
		COLOR_WINDOWFRAME = 6,
		COLOR_MENUTEXT = 7,
		COLOR_WINDOWTEXT = 8,
		COLOR_CAPTIONTEXT = 9,
		COLOR_ACTIVEBORDER = 10,
		COLOR_INACTIVEBORDER = 11,
		COLOR_APPWORKSPACE = 12,
		COLOR_HIGHLIGHT = 13,
		COLOR_HIGHLIGHTTEXT = 14,
		COLOR_BTNFACE = 15,
		COLOR_BTNSHADOW = 16,
		COLOR_GRAYTEXT = 17,
		COLOR_BTNTEXT = 18,
		COLOR_INACTIVECAPTIONTEXT = 19,
		COLOR_BTNHIGHLIGHT = 20,
		COLOR_3DDKSHADOW = 21,
		COLOR_3DLIGHT = 22,
		COLOR_INFOTEXT = 23,
		COLOR_INFOBK = 24,
		COLOR_HOTLIGHT = 26,
		COLOR_GRADIENTACTIVECAPTION = 27,
		COLOR_GRADIENTINACTIVECAPTION = 28,
		COLOR_MENUHIGHLIGHT = 29,
		COLOR_MENUBAR = 30,
		COLOR_DESKTOP = 1,
		COLOR_3DFACE = 16,
		COLOR_3DSHADOW = 16,
		COLOR_3DHIGHLIGHT = 20,
		COLOR_3DHILIGHT = 20,
		COLOR_BTNHILIGHT = 20,
		COLOR_MAXVALUE = 30
	}
	internal class GDIPlus
	{
		public delegate int StreamGetHeaderDelegate(IntPtr buf, int bufsz);

		public delegate int StreamGetBytesDelegate(IntPtr buf, int bufsz, bool peek);

		public delegate long StreamSeekDelegate(int offset, int whence);

		public delegate int StreamPutBytesDelegate(IntPtr buf, int bufsz);

		public delegate void StreamCloseDelegate();

		public delegate long StreamSizeDelegate();

		internal sealed class GdiPlusStreamHelper
		{
			public Stream stream;

			private StreamGetHeaderDelegate sghd;

			private StreamGetBytesDelegate sgbd;

			private StreamSeekDelegate skd;

			private StreamPutBytesDelegate spbd;

			private StreamCloseDelegate scd;

			private StreamSizeDelegate ssd;

			private byte[] start_buf;

			private int start_buf_pos;

			private int start_buf_len;

			private byte[] managedBuf;

			private const int default_bufsize = 4096;

			public StreamGetHeaderDelegate GetHeaderDelegate
			{
				get
				{
					if (stream != null && stream.CanRead)
					{
						if (sghd == null)
						{
							sghd = StreamGetHeaderImpl;
						}
						return sghd;
					}
					return null;
				}
			}

			public StreamGetBytesDelegate GetBytesDelegate
			{
				get
				{
					if (stream != null && stream.CanRead)
					{
						if (sgbd == null)
						{
							sgbd = StreamGetBytesImpl;
						}
						return sgbd;
					}
					return null;
				}
			}

			public StreamSeekDelegate SeekDelegate
			{
				get
				{
					if (stream != null && stream.CanSeek)
					{
						if (skd == null)
						{
							skd = StreamSeekImpl;
						}
						return skd;
					}
					return null;
				}
			}

			public StreamPutBytesDelegate PutBytesDelegate
			{
				get
				{
					if (stream != null && stream.CanWrite)
					{
						if (spbd == null)
						{
							spbd = StreamPutBytesImpl;
						}
						return spbd;
					}
					return null;
				}
			}

			public StreamCloseDelegate CloseDelegate
			{
				get
				{
					if (stream != null)
					{
						if (scd == null)
						{
							scd = StreamCloseImpl;
						}
						return scd;
					}
					return null;
				}
			}

			public StreamSizeDelegate SizeDelegate
			{
				get
				{
					if (stream != null)
					{
						if (ssd == null)
						{
							ssd = StreamSizeImpl;
						}
						return ssd;
					}
					return null;
				}
			}

			public GdiPlusStreamHelper(Stream s, bool seekToOrigin)
			{
				managedBuf = new byte[4096];
				stream = s;
				if (stream != null && stream.CanSeek && seekToOrigin)
				{
					stream.Seek(0L, SeekOrigin.Begin);
				}
			}

			public int StreamGetHeaderImpl(IntPtr buf, int bufsz)
			{
				start_buf = new byte[bufsz];
				int num;
				try
				{
					num = stream.Read(start_buf, 0, bufsz);
				}
				catch (IOException)
				{
					return -1;
				}
				if (num > 0 && buf != IntPtr.Zero)
				{
					Marshal.Copy(start_buf, 0, (IntPtr)buf.ToInt64(), num);
				}
				start_buf_pos = 0;
				start_buf_len = num;
				return num;
			}

			public int StreamGetBytesImpl(IntPtr buf, int bufsz, bool peek)
			{
				if (buf == IntPtr.Zero && peek)
				{
					return -1;
				}
				if (bufsz > managedBuf.Length)
				{
					managedBuf = new byte[bufsz];
				}
				int num = 0;
				long offset = 0L;
				if (bufsz > 0)
				{
					if (stream.CanSeek)
					{
						offset = stream.Position;
					}
					if (start_buf_len > 0)
					{
						if (start_buf_len > bufsz)
						{
							Array.Copy(start_buf, start_buf_pos, managedBuf, 0, bufsz);
							start_buf_pos += bufsz;
							start_buf_len -= bufsz;
							num = bufsz;
							bufsz = 0;
						}
						else
						{
							Array.Copy(start_buf, start_buf_pos, managedBuf, 0, start_buf_len);
							bufsz -= start_buf_len;
							num = start_buf_len;
							start_buf_len = 0;
						}
					}
					if (bufsz > 0)
					{
						try
						{
							num += stream.Read(managedBuf, num, bufsz);
						}
						catch (IOException)
						{
							return -1;
						}
					}
					if (num > 0 && buf != IntPtr.Zero)
					{
						Marshal.Copy(managedBuf, 0, (IntPtr)buf.ToInt64(), num);
					}
					_ = !stream.CanSeek && bufsz == 10 && peek;
					if (peek)
					{
						if (!stream.CanSeek)
						{
							throw new NotSupportedException();
						}
						stream.Seek(offset, SeekOrigin.Begin);
					}
				}
				return num;
			}

			public long StreamSeekImpl(int offset, int whence)
			{
				if (whence < 0 || whence > 2)
				{
					return -1L;
				}
				start_buf_pos += start_buf_len;
				start_buf_len = 0;
				SeekOrigin origin;
				switch (whence)
				{
				case 0:
					origin = SeekOrigin.Begin;
					break;
				case 1:
					origin = SeekOrigin.Current;
					break;
				case 2:
					origin = SeekOrigin.End;
					break;
				default:
					return -1L;
				}
				return stream.Seek(offset, origin);
			}

			public int StreamPutBytesImpl(IntPtr buf, int bufsz)
			{
				if (bufsz > managedBuf.Length)
				{
					managedBuf = new byte[bufsz];
				}
				Marshal.Copy(buf, managedBuf, 0, bufsz);
				stream.Write(managedBuf, 0, bufsz);
				return bufsz;
			}

			public void StreamCloseImpl()
			{
				stream.Dispose();
			}

			public long StreamSizeImpl()
			{
				try
				{
					return stream.Length;
				}
				catch
				{
					return -1L;
				}
			}
		}

		public const int FACESIZE = 32;

		public const int LANG_NEUTRAL = 0;

		public static IntPtr Display;

		public static bool UseX11Drawable;

		public static bool UseCarbonDrawable;

		public static bool UseCocoaDrawable;

		private const string GdiPlus = "gdiplus";

		internal static ulong GdiPlusToken;

		[DllImport("gdiplus")]
		internal static extern Status GdiplusStartup(ref ulong token, ref GdiplusStartupInput input, ref GdiplusStartupOutput output);

		[DllImport("gdiplus")]
		internal static extern void GdiplusShutdown(ref ulong token);

		private static void ProcessExit(object sender, EventArgs e)
		{
			GC.Collect();
			GC.WaitForPendingFinalizers();
		}

		static GDIPlus()
		{
			Display = IntPtr.Zero;
			UseX11Drawable = false;
			UseCarbonDrawable = false;
			UseCocoaDrawable = false;
			GdiPlusToken = 0uL;
			int platform = (int)Environment.OSVersion.Platform;
			if (platform == 4 || platform == 6 || platform == 128)
			{
				if (Environment.GetEnvironmentVariable("not_supported_MONO_MWF_USE_NEW_X11_BACKEND") != null || Environment.GetEnvironmentVariable("MONO_MWF_MAC_FORCE_X11") != null)
				{
					UseX11Drawable = true;
				}
				else
				{
					IntPtr intPtr = Marshal.AllocHGlobal(8192);
					if (uname(intPtr) != 0)
					{
						UseX11Drawable = true;
					}
					else if (Marshal.PtrToStringAnsi(intPtr) == "Darwin")
					{
						UseCarbonDrawable = true;
					}
					else
					{
						UseX11Drawable = true;
					}
					Marshal.FreeHGlobal(intPtr);
				}
			}
			GdiplusStartupInput input = GdiplusStartupInput.MakeGdiplusStartupInput();
			GdiplusStartupOutput output = GdiplusStartupOutput.MakeGdiplusStartupOutput();
			try
			{
				GdiplusStartup(ref GdiPlusToken, ref input, ref output);
			}
			catch (TypeInitializationException)
			{
				Console.Error.WriteLine("* ERROR: Can not initialize GDI+ library{0}{0}Please check http://www.mono-project.com/Problem:GDIPlusInit for details", Environment.NewLine);
			}
			AppDomain.CurrentDomain.ProcessExit += ProcessExit;
		}

		public static bool RunningOnWindows()
		{
			if (!UseX11Drawable && !UseCarbonDrawable)
			{
				return !UseCocoaDrawable;
			}
			return false;
		}

		public static bool RunningOnUnix()
		{
			if (!UseX11Drawable && !UseCarbonDrawable)
			{
				return UseCocoaDrawable;
			}
			return true;
		}

		public static void FromUnManagedMemoryToPointI(IntPtr prt, Point[] pts)
		{
			int num = Marshal.SizeOf(pts[0]);
			IntPtr ptr = prt;
			int num2 = 0;
			while (num2 < pts.Length)
			{
				pts[num2] = (Point)Marshal.PtrToStructure(ptr, typeof(Point));
				num2++;
				ptr = new IntPtr(ptr.ToInt64() + num);
			}
			Marshal.FreeHGlobal(prt);
		}

		public static void FromUnManagedMemoryToPoint(IntPtr prt, PointF[] pts)
		{
			int num = Marshal.SizeOf(pts[0]);
			IntPtr ptr = prt;
			int num2 = 0;
			while (num2 < pts.Length)
			{
				pts[num2] = (PointF)Marshal.PtrToStructure(ptr, typeof(PointF));
				num2++;
				ptr = new IntPtr(ptr.ToInt64() + num);
			}
			Marshal.FreeHGlobal(prt);
		}

		public static IntPtr FromPointToUnManagedMemoryI(Point[] pts)
		{
			int num = Marshal.SizeOf(pts[0]);
			IntPtr intPtr = Marshal.AllocHGlobal(num * pts.Length);
			IntPtr ptr = intPtr;
			int num2 = 0;
			while (num2 < pts.Length)
			{
				Marshal.StructureToPtr(pts[num2], ptr, fDeleteOld: false);
				num2++;
				ptr = new IntPtr(ptr.ToInt64() + num);
			}
			return intPtr;
		}

		public static void FromUnManagedMemoryToRectangles(IntPtr prt, RectangleF[] pts)
		{
			int num = Marshal.SizeOf(pts[0]);
			IntPtr ptr = prt;
			int num2 = 0;
			while (num2 < pts.Length)
			{
				pts[num2] = (RectangleF)Marshal.PtrToStructure(ptr, typeof(RectangleF));
				num2++;
				ptr = new IntPtr(ptr.ToInt64() + num);
			}
			Marshal.FreeHGlobal(prt);
		}

		public static IntPtr FromPointToUnManagedMemory(PointF[] pts)
		{
			int num = Marshal.SizeOf(pts[0]);
			IntPtr intPtr = Marshal.AllocHGlobal(num * pts.Length);
			IntPtr ptr = intPtr;
			int num2 = 0;
			while (num2 < pts.Length)
			{
				Marshal.StructureToPtr(pts[num2], ptr, fDeleteOld: false);
				num2++;
				ptr = new IntPtr(ptr.ToInt64() + num);
			}
			return intPtr;
		}

		internal static void CheckStatus(Status status)
		{
			switch (status)
			{
			case Status.Ok:
				break;
			case Status.GenericError:
				throw new Exception(global::Locale.GetText("Generic Error [GDI+ status: {0}]", status));
			case Status.InvalidParameter:
				throw new ArgumentException(global::Locale.GetText("A null reference or invalid value was found [GDI+ status: {0}]", status));
			case Status.OutOfMemory:
				throw new OutOfMemoryException(global::Locale.GetText("Not enough memory to complete operation [GDI+ status: {0}]", status));
			case Status.ObjectBusy:
				throw new MemberAccessException(global::Locale.GetText("Object is busy and cannot state allow this operation [GDI+ status: {0}]", status));
			case Status.InsufficientBuffer:
				throw new InternalBufferOverflowException(global::Locale.GetText("Insufficient buffer provided to complete operation [GDI+ status: {0}]", status));
			case Status.PropertyNotSupported:
				throw new NotSupportedException(global::Locale.GetText("Property not supported [GDI+ status: {0}]", status));
			case Status.FileNotFound:
				throw new FileNotFoundException(global::Locale.GetText("Requested file was not found [GDI+ status: {0}]", status));
			case Status.AccessDenied:
				throw new UnauthorizedAccessException(global::Locale.GetText("Access to resource was denied [GDI+ status: {0}]", status));
			case Status.UnknownImageFormat:
				throw new NotSupportedException(global::Locale.GetText("Either the image format is unknown or you don't have the required libraries to decode this format [GDI+ status: {0}]", status));
			case Status.NotImplemented:
				throw new NotImplementedException(global::Locale.GetText("The requested feature is not implemented [GDI+ status: {0}]", status));
			case Status.WrongState:
				throw new ArgumentException(global::Locale.GetText("Object is not in a state that can allow this operation [GDI+ status: {0}]", status));
			case Status.FontFamilyNotFound:
				throw new ArgumentException(global::Locale.GetText("The requested FontFamily could not be found [GDI+ status: {0}]", status));
			case Status.ValueOverflow:
				throw new OverflowException(global::Locale.GetText("Argument is out of range [GDI+ status: {0}]", status));
			case Status.Win32Error:
				throw new InvalidOperationException(global::Locale.GetText("The operation is invalid [GDI+ status: {0}]", status));
			default:
				throw new Exception(global::Locale.GetText("Unknown Error [GDI+ status: {0}]", status));
			}
		}

		[DllImport("gdiplus")]
		internal static extern IntPtr GdipAlloc(int size);

		[DllImport("gdiplus")]
		internal static extern void GdipFree(IntPtr ptr);

		[DllImport("gdiplus")]
		internal static extern int GdipCloneBrush(HandleRef brush, out IntPtr clonedBrush);

		[DllImport("gdiplus")]
		internal static extern int GdipDeleteBrush(HandleRef brush);

		[DllImport("gdiplus")]
		internal static extern int GdipGetBrushType(HandleRef brush, out BrushType type);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateRegion(out IntPtr region);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateRegionRgnData(byte[] data, int size, out IntPtr region);

		[DllImport("gdiplus")]
		internal static extern Status GdipDeleteRegion(IntPtr region);

		[DllImport("gdiplus")]
		internal static extern Status GdipCloneRegion(IntPtr region, out IntPtr cloned);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateRegionRect(ref RectangleF rect, out IntPtr region);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateRegionRectI(ref Rectangle rect, out IntPtr region);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateRegionPath(IntPtr path, out IntPtr region);

		[DllImport("gdiplus")]
		internal static extern Status GdipTranslateRegion(IntPtr region, float dx, float dy);

		[DllImport("gdiplus")]
		internal static extern Status GdipTranslateRegionI(IntPtr region, int dx, int dy);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsVisibleRegionPoint(IntPtr region, float x, float y, IntPtr graphics, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsVisibleRegionPointI(IntPtr region, int x, int y, IntPtr graphics, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsVisibleRegionRect(IntPtr region, float x, float y, float width, float height, IntPtr graphics, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsVisibleRegionRectI(IntPtr region, int x, int y, int width, int height, IntPtr graphics, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipCombineRegionRect(IntPtr region, ref RectangleF rect, CombineMode combineMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipCombineRegionRectI(IntPtr region, ref Rectangle rect, CombineMode combineMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipCombineRegionPath(IntPtr region, IntPtr path, CombineMode combineMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetRegionBounds(IntPtr region, IntPtr graphics, ref RectangleF rect);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetInfinite(IntPtr region);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetEmpty(IntPtr region);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsEmptyRegion(IntPtr region, IntPtr graphics, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsInfiniteRegion(IntPtr region, IntPtr graphics, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipCombineRegionRegion(IntPtr region, IntPtr region2, CombineMode combineMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsEqualRegion(IntPtr region, IntPtr region2, IntPtr graphics, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetRegionDataSize(IntPtr region, out int bufferSize);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetRegionData(IntPtr region, byte[] buffer, int bufferSize, out int sizeFilled);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetRegionScansCount(IntPtr region, out int count, IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetRegionScans(IntPtr region, IntPtr rects, out int count, IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipTransformRegion(IntPtr region, IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillRegion(IntPtr graphics, IntPtr brush, IntPtr region);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetRegionHRgn(IntPtr region, IntPtr graphics, ref IntPtr hRgn);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateRegionHrgn(IntPtr hRgn, out IntPtr region);

		[DllImport("gdiplus")]
		internal static extern int GdipCreateSolidFill(int color, out IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern int GdipGetSolidFillColor(HandleRef brush, out int color);

		[DllImport("gdiplus")]
		internal static extern int GdipSetSolidFillColor(HandleRef brush, int color);

		[DllImport("gdiplus")]
		internal static extern int GdipCreateHatchBrush(int hatchstyle, int foreColor, int backColor, out IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern int GdipGetHatchStyle(HandleRef brush, out int hatchstyle);

		[DllImport("gdiplus")]
		internal static extern int GdipGetHatchForegroundColor(HandleRef brush, out int foreColor);

		[DllImport("gdiplus")]
		internal static extern int GdipGetHatchBackgroundColor(HandleRef brush, out int backColor);

		[DllImport("gdiplus")]
		internal static extern int GdipGetTextureImage(HandleRef texture, out IntPtr image);

		[DllImport("gdiplus")]
		internal static extern int GdipCreateTexture(HandleRef image, int wrapMode, out IntPtr texture);

		[DllImport("gdiplus")]
		internal static extern int GdipCreateTextureIAI(HandleRef image, HandleRef imageAttributes, int x, int y, int width, int height, out IntPtr texture);

		[DllImport("gdiplus")]
		internal static extern int GdipCreateTextureIA(HandleRef image, HandleRef imageAttributes, float x, float y, float width, float height, out IntPtr texture);

		[DllImport("gdiplus")]
		internal static extern int GdipCreateTexture2I(HandleRef image, int wrapMode, int x, int y, int width, int height, out IntPtr texture);

		[DllImport("gdiplus")]
		internal static extern int GdipCreateTexture2(HandleRef image, int wrapMode, float x, float y, float width, float height, out IntPtr texture);

		[DllImport("gdiplus")]
		internal static extern int GdipGetTextureTransform(HandleRef texture, HandleRef matrix);

		[DllImport("gdiplus")]
		internal static extern int GdipSetTextureTransform(HandleRef texture, HandleRef matrix);

		[DllImport("gdiplus")]
		internal static extern int GdipGetTextureWrapMode(HandleRef texture, out int wrapMode);

		[DllImport("gdiplus")]
		internal static extern int GdipSetTextureWrapMode(HandleRef texture, int wrapMode);

		[DllImport("gdiplus")]
		internal static extern int GdipMultiplyTextureTransform(HandleRef texture, HandleRef matrix, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern int GdipResetTextureTransform(HandleRef texture);

		[DllImport("gdiplus")]
		internal static extern int GdipRotateTextureTransform(HandleRef texture, float angle, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern int GdipScaleTextureTransform(HandleRef texture, float sx, float sy, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern int GdipTranslateTextureTransform(HandleRef texture, float dx, float dy, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreatePathGradientFromPath(IntPtr path, out IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreatePathGradientI(Point[] points, int count, WrapMode wrapMode, out IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreatePathGradient(PointF[] points, int count, WrapMode wrapMode, out IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathGradientBlendCount(IntPtr brush, out int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathGradientBlend(IntPtr brush, float[] blend, float[] positions, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPathGradientBlend(IntPtr brush, float[] blend, float[] positions, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathGradientCenterColor(IntPtr brush, out int color);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPathGradientCenterColor(IntPtr brush, int color);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathGradientCenterPoint(IntPtr brush, out PointF point);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPathGradientCenterPoint(IntPtr brush, ref PointF point);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathGradientFocusScales(IntPtr brush, out float xScale, out float yScale);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPathGradientFocusScales(IntPtr brush, float xScale, float yScale);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathGradientPresetBlendCount(IntPtr brush, out int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathGradientPresetBlend(IntPtr brush, int[] blend, float[] positions, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPathGradientPresetBlend(IntPtr brush, int[] blend, float[] positions, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathGradientRect(IntPtr brush, out RectangleF rect);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathGradientSurroundColorCount(IntPtr brush, out int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathGradientSurroundColorsWithCount(IntPtr brush, int[] color, ref int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPathGradientSurroundColorsWithCount(IntPtr brush, int[] color, ref int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathGradientTransform(IntPtr brush, IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPathGradientTransform(IntPtr brush, IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathGradientWrapMode(IntPtr brush, out WrapMode wrapMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPathGradientWrapMode(IntPtr brush, WrapMode wrapMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPathGradientLinearBlend(IntPtr brush, float focus, float scale);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPathGradientSigmaBlend(IntPtr brush, float focus, float scale);

		[DllImport("gdiplus")]
		internal static extern Status GdipMultiplyPathGradientTransform(IntPtr texture, IntPtr matrix, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipResetPathGradientTransform(IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern Status GdipRotatePathGradientTransform(IntPtr brush, float angle, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipScalePathGradientTransform(IntPtr brush, float sx, float sy, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipTranslatePathGradientTransform(IntPtr brush, float dx, float dy, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateLineBrushI(ref Point point1, ref Point point2, int color1, int color2, WrapMode wrapMode, out IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateLineBrush(ref PointF point1, ref PointF point2, int color1, int color2, WrapMode wrapMode, out IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateLineBrushFromRectI(ref Rectangle rect, int color1, int color2, LinearGradientMode linearGradientMode, WrapMode wrapMode, out IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateLineBrushFromRect(ref RectangleF rect, int color1, int color2, LinearGradientMode linearGradientMode, WrapMode wrapMode, out IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateLineBrushFromRectWithAngleI(ref Rectangle rect, int color1, int color2, float angle, bool isAngleScaleable, WrapMode wrapMode, out IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateLineBrushFromRectWithAngle(ref RectangleF rect, int color1, int color2, float angle, bool isAngleScaleable, WrapMode wrapMode, out IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetLineBlendCount(IntPtr brush, out int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetLineBlend(IntPtr brush, float[] blend, float[] positions, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetLineBlend(IntPtr brush, float[] blend, float[] positions, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetLineGammaCorrection(IntPtr brush, bool useGammaCorrection);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetLineGammaCorrection(IntPtr brush, out bool useGammaCorrection);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetLinePresetBlendCount(IntPtr brush, out int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetLinePresetBlend(IntPtr brush, int[] blend, float[] positions, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetLinePresetBlend(IntPtr brush, int[] blend, float[] positions, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetLineColors(IntPtr brush, int color1, int color2);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetLineColors(IntPtr brush, int[] colors);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetLineRectI(IntPtr brush, out Rectangle rect);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetLineRect(IntPtr brush, out RectangleF rect);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetLineTransform(IntPtr brush, IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetLineTransform(IntPtr brush, IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetLineWrapMode(IntPtr brush, WrapMode wrapMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetLineWrapMode(IntPtr brush, out WrapMode wrapMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetLineLinearBlend(IntPtr brush, float focus, float scale);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetLineSigmaBlend(IntPtr brush, float focus, float scale);

		[DllImport("gdiplus")]
		internal static extern Status GdipMultiplyLineTransform(IntPtr brush, IntPtr matrix, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipResetLineTransform(IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern Status GdipRotateLineTransform(IntPtr brush, float angle, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipScaleLineTransform(IntPtr brush, float sx, float sy, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipTranslateLineTransform(IntPtr brush, float dx, float dy, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateFromHDC(IntPtr hDC, out IntPtr graphics);

		[DllImport("gdiplus")]
		internal static extern Status GdipDeleteGraphics(IntPtr graphics);

		[DllImport("gdiplus")]
		internal static extern Status GdipRestoreGraphics(IntPtr graphics, uint graphicsState);

		[DllImport("gdiplus")]
		internal static extern Status GdipSaveGraphics(IntPtr graphics, out uint state);

		[DllImport("gdiplus")]
		internal static extern Status GdipMultiplyWorldTransform(IntPtr graphics, IntPtr matrix, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipRotateWorldTransform(IntPtr graphics, float angle, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipTranslateWorldTransform(IntPtr graphics, float dx, float dy, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawArc(IntPtr graphics, IntPtr pen, float x, float y, float width, float height, float startAngle, float sweepAngle);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawArcI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height, float startAngle, float sweepAngle);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawBezier(IntPtr graphics, IntPtr pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawBezierI(IntPtr graphics, IntPtr pen, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawEllipseI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawEllipse(IntPtr graphics, IntPtr pen, float x, float y, float width, float height);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawLine(IntPtr graphics, IntPtr pen, float x1, float y1, float x2, float y2);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawLineI(IntPtr graphics, IntPtr pen, int x1, int y1, int x2, int y2);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawLines(IntPtr graphics, IntPtr pen, PointF[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawLinesI(IntPtr graphics, IntPtr pen, Point[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawPath(IntPtr graphics, IntPtr pen, IntPtr path);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawPie(IntPtr graphics, IntPtr pen, float x, float y, float width, float height, float startAngle, float sweepAngle);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawPieI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height, float startAngle, float sweepAngle);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawPolygon(IntPtr graphics, IntPtr pen, PointF[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawPolygonI(IntPtr graphics, IntPtr pen, Point[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawRectangle(IntPtr graphics, IntPtr pen, float x, float y, float width, float height);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawRectangleI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawRectangles(IntPtr graphics, IntPtr pen, RectangleF[] rects, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawRectanglesI(IntPtr graphics, IntPtr pen, Rectangle[] rects, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillEllipseI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillEllipse(IntPtr graphics, IntPtr pen, float x, float y, float width, float height);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillPolygon(IntPtr graphics, IntPtr brush, PointF[] points, int count, FillMode fillMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillPolygonI(IntPtr graphics, IntPtr brush, Point[] points, int count, FillMode fillMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillPolygon2(IntPtr graphics, IntPtr brush, PointF[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillPolygon2I(IntPtr graphics, IntPtr brush, Point[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillRectangle(IntPtr graphics, IntPtr brush, float x1, float y1, float x2, float y2);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillRectangleI(IntPtr graphics, IntPtr brush, int x1, int y1, int x2, int y2);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillRectangles(IntPtr graphics, IntPtr brush, RectangleF[] rects, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillRectanglesI(IntPtr graphics, IntPtr brush, Rectangle[] rects, int count);

		[DllImport("gdiplus", CharSet = CharSet.Unicode)]
		internal static extern Status GdipDrawString(IntPtr graphics, string text, int len, IntPtr font, ref RectangleF rc, IntPtr format, IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetDC(IntPtr graphics, out IntPtr hdc);

		[DllImport("gdiplus")]
		internal static extern Status GdipReleaseDC(IntPtr graphics, IntPtr hdc);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawImageRectI(IntPtr graphics, IntPtr image, int x, int y, int width, int height);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetRenderingOrigin(IntPtr graphics, out int x, out int y);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetRenderingOrigin(IntPtr graphics, int x, int y);

		[DllImport("gdiplus")]
		internal static extern Status GdipCloneBitmapArea(float x, float y, float width, float height, PixelFormat format, IntPtr original, out IntPtr bitmap);

		[DllImport("gdiplus")]
		internal static extern Status GdipCloneBitmapAreaI(int x, int y, int width, int height, PixelFormat format, IntPtr original, out IntPtr bitmap);

		[DllImport("gdiplus")]
		internal static extern Status GdipResetWorldTransform(IntPtr graphics);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetWorldTransform(IntPtr graphics, IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetWorldTransform(IntPtr graphics, IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipScaleWorldTransform(IntPtr graphics, float sx, float sy, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipGraphicsClear(IntPtr graphics, int argb);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawClosedCurve(IntPtr graphics, IntPtr pen, PointF[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawClosedCurveI(IntPtr graphics, IntPtr pen, Point[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawClosedCurve2(IntPtr graphics, IntPtr pen, PointF[] points, int count, float tension);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawClosedCurve2I(IntPtr graphics, IntPtr pen, Point[] points, int count, float tension);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawCurve(IntPtr graphics, IntPtr pen, PointF[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawCurveI(IntPtr graphics, IntPtr pen, Point[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawCurve2(IntPtr graphics, IntPtr pen, PointF[] points, int count, float tension);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawCurve2I(IntPtr graphics, IntPtr pen, Point[] points, int count, float tension);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawCurve3(IntPtr graphics, IntPtr pen, PointF[] points, int count, int offset, int numberOfSegments, float tension);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawCurve3I(IntPtr graphics, IntPtr pen, Point[] points, int count, int offset, int numberOfSegments, float tension);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetClipRect(IntPtr graphics, float x, float y, float width, float height, CombineMode combineMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetClipRectI(IntPtr graphics, int x, int y, int width, int height, CombineMode combineMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetClipPath(IntPtr graphics, IntPtr path, CombineMode combineMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetClipRegion(IntPtr graphics, IntPtr region, CombineMode combineMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetClipGraphics(IntPtr graphics, IntPtr srcgraphics, CombineMode combineMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipResetClip(IntPtr graphics);

		[DllImport("gdiplus")]
		internal static extern Status GdipEndContainer(IntPtr graphics, uint state);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetClip(IntPtr graphics, IntPtr region);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillClosedCurve(IntPtr graphics, IntPtr brush, PointF[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillClosedCurveI(IntPtr graphics, IntPtr brush, Point[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillClosedCurve2(IntPtr graphics, IntPtr brush, PointF[] points, int count, float tension, FillMode fillMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillClosedCurve2I(IntPtr graphics, IntPtr brush, Point[] points, int count, float tension, FillMode fillMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillPie(IntPtr graphics, IntPtr brush, float x, float y, float width, float height, float startAngle, float sweepAngle);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillPieI(IntPtr graphics, IntPtr brush, int x, int y, int width, int height, float startAngle, float sweepAngle);

		[DllImport("gdiplus")]
		internal static extern Status GdipFillPath(IntPtr graphics, IntPtr brush, IntPtr path);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetNearestColor(IntPtr graphics, out int argb);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsVisiblePoint(IntPtr graphics, float x, float y, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsVisiblePointI(IntPtr graphics, int x, int y, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsVisibleRect(IntPtr graphics, float x, float y, float width, float height, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsVisibleRectI(IntPtr graphics, int x, int y, int width, int height, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipTransformPoints(IntPtr graphics, CoordinateSpace destSpace, CoordinateSpace srcSpace, IntPtr points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipTransformPointsI(IntPtr graphics, CoordinateSpace destSpace, CoordinateSpace srcSpace, IntPtr points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipTranslateClip(IntPtr graphics, float dx, float dy);

		[DllImport("gdiplus")]
		internal static extern Status GdipTranslateClipI(IntPtr graphics, int dx, int dy);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetClipBounds(IntPtr graphics, out RectangleF rect);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetCompositingMode(IntPtr graphics, CompositingMode compositingMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetCompositingMode(IntPtr graphics, out CompositingMode compositingMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetCompositingQuality(IntPtr graphics, CompositingQuality compositingQuality);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetCompositingQuality(IntPtr graphics, out CompositingQuality compositingQuality);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetInterpolationMode(IntPtr graphics, InterpolationMode interpolationMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetInterpolationMode(IntPtr graphics, out InterpolationMode interpolationMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetDpiX(IntPtr graphics, out float dpi);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetDpiY(IntPtr graphics, out float dpi);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsClipEmpty(IntPtr graphics, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsVisibleClipEmpty(IntPtr graphics, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPageUnit(IntPtr graphics, out GraphicsUnit unit);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPageScale(IntPtr graphics, out float scale);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPageUnit(IntPtr graphics, GraphicsUnit unit);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPageScale(IntPtr graphics, float scale);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPixelOffsetMode(IntPtr graphics, PixelOffsetMode pixelOffsetMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPixelOffsetMode(IntPtr graphics, out PixelOffsetMode pixelOffsetMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetSmoothingMode(IntPtr graphics, SmoothingMode smoothingMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetSmoothingMode(IntPtr graphics, out SmoothingMode smoothingMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetTextContrast(IntPtr graphics, int contrast);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetTextContrast(IntPtr graphics, out int contrast);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetTextRenderingHint(IntPtr graphics, TextRenderingHint mode);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetTextRenderingHint(IntPtr graphics, out TextRenderingHint mode);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetVisibleClipBounds(IntPtr graphics, out RectangleF rect);

		[DllImport("gdiplus")]
		internal static extern Status GdipFlush(IntPtr graphics, FlushIntention intention);

		[DllImport("gdiplus", CharSet = CharSet.Unicode)]
		internal static extern Status GdipAddPathString(IntPtr path, string s, int lenght, IntPtr family, int style, float emSize, ref RectangleF layoutRect, IntPtr format);

		[DllImport("gdiplus", CharSet = CharSet.Unicode)]
		internal static extern Status GdipAddPathStringI(IntPtr path, string s, int lenght, IntPtr family, int style, float emSize, ref Rectangle layoutRect, IntPtr format);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreatePen1(int argb, float width, GraphicsUnit unit, out IntPtr pen);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreatePen2(IntPtr brush, float width, GraphicsUnit unit, out IntPtr pen);

		[DllImport("gdiplus")]
		internal static extern Status GdipClonePen(IntPtr pen, out IntPtr clonepen);

		[DllImport("gdiplus")]
		internal static extern Status GdipDeletePen(IntPtr pen);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenBrushFill(IntPtr pen, IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenBrushFill(IntPtr pen, out IntPtr brush);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenFillType(IntPtr pen, out PenType type);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenColor(IntPtr pen, int color);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenColor(IntPtr pen, out int color);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenCompoundArray(IntPtr pen, float[] dash, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenCompoundArray(IntPtr pen, float[] dash, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenCompoundCount(IntPtr pen, out int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenDashCap197819(IntPtr pen, DashCap dashCap);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenDashCap197819(IntPtr pen, out DashCap dashCap);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenDashStyle(IntPtr pen, DashStyle dashStyle);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenDashStyle(IntPtr pen, out DashStyle dashStyle);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenDashOffset(IntPtr pen, float offset);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenDashOffset(IntPtr pen, out float offset);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenDashCount(IntPtr pen, out int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenDashArray(IntPtr pen, float[] dash, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenDashArray(IntPtr pen, float[] dash, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenMiterLimit(IntPtr pen, float miterLimit);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenMiterLimit(IntPtr pen, out float miterLimit);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenLineJoin(IntPtr pen, LineJoin lineJoin);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenLineJoin(IntPtr pen, out LineJoin lineJoin);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenLineCap197819(IntPtr pen, LineCap startCap, LineCap endCap, DashCap dashCap);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenMode(IntPtr pen, PenAlignment alignment);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenMode(IntPtr pen, out PenAlignment alignment);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenStartCap(IntPtr pen, LineCap startCap);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenStartCap(IntPtr pen, out LineCap startCap);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenEndCap(IntPtr pen, LineCap endCap);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenEndCap(IntPtr pen, out LineCap endCap);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenCustomStartCap(IntPtr pen, IntPtr customCap);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenCustomStartCap(IntPtr pen, out IntPtr customCap);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenCustomEndCap(IntPtr pen, IntPtr customCap);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenCustomEndCap(IntPtr pen, out IntPtr customCap);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenTransform(IntPtr pen, IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenTransform(IntPtr pen, IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPenWidth(IntPtr pen, float width);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPenWidth(IntPtr pen, out float width);

		[DllImport("gdiplus")]
		internal static extern Status GdipResetPenTransform(IntPtr pen);

		[DllImport("gdiplus")]
		internal static extern Status GdipMultiplyPenTransform(IntPtr pen, IntPtr matrix, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipRotatePenTransform(IntPtr pen, float angle, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipScalePenTransform(IntPtr pen, float sx, float sy, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipTranslatePenTransform(IntPtr pen, float dx, float dy, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern int GdipCreateCustomLineCap(HandleRef fillPath, HandleRef strokePath, LineCap baseCap, float baseInset, out IntPtr customCap);

		[DllImport("gdiplus")]
		internal static extern int GdipDeleteCustomLineCap(HandleRef customCap);

		[DllImport("gdiplus")]
		internal static extern int GdipCloneCustomLineCap(HandleRef customCap, out IntPtr clonedCap);

		[DllImport("gdiplus")]
		internal static extern int GdipSetCustomLineCapStrokeCaps(HandleRef customCap, LineCap startCap, LineCap endCap);

		[DllImport("gdiplus")]
		internal static extern int GdipGetCustomLineCapStrokeCaps(HandleRef customCap, out LineCap startCap, out LineCap endCap);

		[DllImport("gdiplus")]
		internal static extern int GdipSetCustomLineCapStrokeJoin(HandleRef customCap, LineJoin lineJoin);

		[DllImport("gdiplus")]
		internal static extern int GdipGetCustomLineCapStrokeJoin(HandleRef customCap, out LineJoin lineJoin);

		[DllImport("gdiplus")]
		internal static extern int GdipSetCustomLineCapBaseCap(HandleRef customCap, LineCap baseCap);

		[DllImport("gdiplus")]
		internal static extern int GdipGetCustomLineCapBaseCap(HandleRef customCap, out LineCap baseCap);

		[DllImport("gdiplus")]
		internal static extern int GdipSetCustomLineCapBaseInset(HandleRef customCap, float inset);

		[DllImport("gdiplus")]
		internal static extern int GdipGetCustomLineCapBaseInset(HandleRef customCap, out float inset);

		[DllImport("gdiplus")]
		internal static extern int GdipSetCustomLineCapWidthScale(HandleRef customCap, float widthScale);

		[DllImport("gdiplus")]
		internal static extern int GdipGetCustomLineCapWidthScale(HandleRef customCap, out float widthScale);

		[DllImport("gdiplus")]
		internal static extern int GdipCreateAdjustableArrowCap(float height, float width, bool isFilled, out IntPtr arrowCap);

		[DllImport("gdiplus")]
		internal static extern int GdipSetAdjustableArrowCapHeight(HandleRef arrowCap, float height);

		[DllImport("gdiplus")]
		internal static extern int GdipGetAdjustableArrowCapHeight(HandleRef arrowCap, out float height);

		[DllImport("gdiplus")]
		internal static extern int GdipSetAdjustableArrowCapWidth(HandleRef arrowCap, float width);

		[DllImport("gdiplus")]
		internal static extern int GdipGetAdjustableArrowCapWidth(HandleRef arrowCap, out float width);

		[DllImport("gdiplus")]
		internal static extern int GdipSetAdjustableArrowCapMiddleInset(HandleRef arrowCap, float middleInset);

		[DllImport("gdiplus")]
		internal static extern int GdipGetAdjustableArrowCapMiddleInset(HandleRef arrowCap, out float middleInset);

		[DllImport("gdiplus")]
		internal static extern int GdipSetAdjustableArrowCapFillState(HandleRef arrowCap, bool isFilled);

		[DllImport("gdiplus")]
		internal static extern int GdipGetAdjustableArrowCapFillState(HandleRef arrowCap, out bool isFilled);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateFromHWND(IntPtr hwnd, out IntPtr graphics);

		[DllImport("gdiplus", CharSet = CharSet.Unicode)]
		internal unsafe static extern Status GdipMeasureString(IntPtr graphics, string str, int length, IntPtr font, ref RectangleF layoutRect, IntPtr stringFormat, out RectangleF boundingBox, int* codepointsFitted, int* linesFilled);

		[DllImport("gdiplus", CharSet = CharSet.Unicode)]
		internal static extern Status GdipMeasureCharacterRanges(IntPtr graphics, string str, int length, IntPtr font, ref RectangleF layoutRect, IntPtr stringFormat, int regcount, out IntPtr regions);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetStringFormatMeasurableCharacterRanges(IntPtr native, int cnt, CharacterRange[] range);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetStringFormatMeasurableCharacterRangeCount(IntPtr native, out int cnt);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateBitmapFromScan0(int width, int height, int stride, PixelFormat format, IntPtr scan0, out IntPtr bmp);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateBitmapFromGraphics(int width, int height, IntPtr target, out IntPtr bitmap);

		[DllImport("gdiplus")]
		internal static extern Status GdipBitmapLockBits(IntPtr bmp, ref Rectangle rc, ImageLockMode flags, PixelFormat format, [In][Out] BitmapData bmpData);

		[DllImport("gdiplus")]
		internal static extern Status GdipBitmapSetResolution(IntPtr bmp, float xdpi, float ydpi);

		[DllImport("gdiplus")]
		internal static extern Status GdipBitmapUnlockBits(IntPtr bmp, [In][Out] BitmapData bmpData);

		[DllImport("gdiplus")]
		internal static extern Status GdipBitmapGetPixel(IntPtr bmp, int x, int y, out int argb);

		[DllImport("gdiplus")]
		internal static extern Status GdipBitmapSetPixel(IntPtr bmp, int x, int y, int argb);

		[DllImport("gdiplus", CharSet = CharSet.Auto)]
		internal static extern Status GdipLoadImageFromFile([MarshalAs(UnmanagedType.LPWStr)] string filename, out IntPtr image);

		[DllImport("gdiplus", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal static extern Status GdipLoadImageFromStream([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "System.Drawing.ComIStreamMarshaler")] IStream stream, out IntPtr image);

		[DllImport("gdiplus", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal static extern Status GdipSaveImageToStream(HandleRef image, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "System.Drawing.ComIStreamMarshaler")] IStream stream, [In] ref Guid clsidEncoder, HandleRef encoderParams);

		[DllImport("gdiplus")]
		internal static extern Status GdipCloneImage(IntPtr image, out IntPtr imageclone);

		[DllImport("gdiplus", CharSet = CharSet.Auto)]
		internal static extern Status GdipLoadImageFromFileICM([MarshalAs(UnmanagedType.LPWStr)] string filename, out IntPtr image);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateBitmapFromHBITMAP(IntPtr hBitMap, IntPtr gdiPalette, out IntPtr image);

		[DllImport("gdiplus")]
		internal static extern Status GdipDisposeImage(IntPtr image);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetImageFlags(IntPtr image, out int flag);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetImageType(IntPtr image, out ImageType type);

		[DllImport("gdiplus")]
		internal static extern Status GdipImageGetFrameDimensionsCount(IntPtr image, out uint count);

		[DllImport("gdiplus")]
		internal static extern Status GdipImageGetFrameDimensionsList(IntPtr image, [Out] Guid[] dimensionIDs, uint count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetImageHeight(IntPtr image, out uint height);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetImageHorizontalResolution(IntPtr image, out float resolution);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetImagePaletteSize(IntPtr image, out int size);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetImagePalette(IntPtr image, IntPtr palette, int size);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetImagePalette(IntPtr image, IntPtr palette);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetImageDimension(IntPtr image, out float width, out float height);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetImagePixelFormat(IntPtr image, out PixelFormat format);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPropertyCount(IntPtr image, out uint propNumbers);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPropertyIdList(IntPtr image, uint propNumbers, [Out] int[] list);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPropertySize(IntPtr image, out int bufferSize, out int propNumbers);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetAllPropertyItems(IntPtr image, int bufferSize, int propNumbers, IntPtr items);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetImageRawFormat(IntPtr image, out Guid format);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetImageVerticalResolution(IntPtr image, out float resolution);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetImageWidth(IntPtr image, out uint width);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetImageBounds(IntPtr image, out RectangleF source, ref GraphicsUnit unit);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetEncoderParameterListSize(IntPtr image, ref Guid encoder, out uint size);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetEncoderParameterList(IntPtr image, ref Guid encoder, uint size, IntPtr buffer);

		[DllImport("gdiplus")]
		internal static extern Status GdipImageGetFrameCount(IntPtr image, ref Guid guidDimension, out uint count);

		[DllImport("gdiplus")]
		internal static extern Status GdipImageSelectActiveFrame(IntPtr image, ref Guid guidDimension, int frameIndex);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPropertyItemSize(IntPtr image, int propertyID, out int propertySize);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPropertyItem(IntPtr image, int propertyID, int propertySize, IntPtr buffer);

		[DllImport("gdiplus")]
		internal static extern Status GdipRemovePropertyItem(IntPtr image, int propertyId);

		[DllImport("gdiplus")]
		internal unsafe static extern Status GdipSetPropertyItem(IntPtr image, GdipPropertyItem* propertyItem);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetImageThumbnail(IntPtr image, uint width, uint height, out IntPtr thumbImage, IntPtr callback, IntPtr callBackData);

		[DllImport("gdiplus")]
		internal static extern Status GdipImageRotateFlip(IntPtr image, RotateFlipType rotateFlipType);

		[DllImport("gdiplus", CharSet = CharSet.Unicode)]
		internal static extern Status GdipSaveImageToFile(IntPtr image, string filename, ref Guid encoderClsID, IntPtr encoderParameters);

		[DllImport("gdiplus")]
		internal static extern Status GdipSaveAdd(IntPtr image, IntPtr encoderParameters);

		[DllImport("gdiplus")]
		internal static extern Status GdipSaveAddImage(IntPtr image, IntPtr imagenew, IntPtr encoderParameters);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawImageI(IntPtr graphics, IntPtr image, int x, int y);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetImageGraphicsContext(IntPtr image, out IntPtr graphics);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawImage(IntPtr graphics, IntPtr image, float x, float y);

		[DllImport("gdiplus")]
		internal static extern Status GdipBeginContainer(IntPtr graphics, ref RectangleF dstrect, ref RectangleF srcrect, GraphicsUnit unit, out uint state);

		[DllImport("gdiplus")]
		internal static extern Status GdipBeginContainerI(IntPtr graphics, ref Rectangle dstrect, ref Rectangle srcrect, GraphicsUnit unit, out uint state);

		[DllImport("gdiplus")]
		internal static extern Status GdipBeginContainer2(IntPtr graphics, out uint state);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawImagePoints(IntPtr graphics, IntPtr image, PointF[] destPoints, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawImagePointsI(IntPtr graphics, IntPtr image, Point[] destPoints, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawImageRectRectI(IntPtr graphics, IntPtr image, int dstx, int dsty, int dstwidth, int dstheight, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawImageRectRect(IntPtr graphics, IntPtr image, float dstx, float dsty, float dstwidth, float dstheight, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawImagePointsRectI(IntPtr graphics, IntPtr image, Point[] destPoints, int count, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawImagePointsRect(IntPtr graphics, IntPtr image, PointF[] destPoints, int count, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawImageRect(IntPtr graphics, IntPtr image, float x, float y, float width, float height);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawImagePointRect(IntPtr graphics, IntPtr image, float x, float y, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit);

		[DllImport("gdiplus")]
		internal static extern Status GdipDrawImagePointRectI(IntPtr graphics, IntPtr image, int x, int y, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateStringFormat(StringFormatFlags formatAttributes, int language, out IntPtr native);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateHBITMAPFromBitmap(IntPtr bmp, out IntPtr HandleBmp, int clrbackground);

		[DllImport("gdiplus", CharSet = CharSet.Auto)]
		internal static extern Status GdipCreateBitmapFromFile([MarshalAs(UnmanagedType.LPWStr)] string filename, out IntPtr bitmap);

		[DllImport("gdiplus", CharSet = CharSet.Auto)]
		internal static extern Status GdipCreateBitmapFromFileICM([MarshalAs(UnmanagedType.LPWStr)] string filename, out IntPtr bitmap);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateHICONFromBitmap(IntPtr bmp, out IntPtr HandleIcon);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateBitmapFromHICON(IntPtr hicon, out IntPtr bitmap);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateBitmapFromResource(IntPtr hInstance, string lpBitmapName, out IntPtr bitmap);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateMatrix(out IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateMatrix2(float m11, float m12, float m21, float m22, float dx, float dy, out IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateMatrix3(ref RectangleF rect, PointF[] dstplg, out IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateMatrix3I(ref Rectangle rect, Point[] dstplg, out IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipDeleteMatrix(IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipCloneMatrix(IntPtr matrix, out IntPtr cloneMatrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetMatrixElements(IntPtr matrix, float m11, float m12, float m21, float m22, float dx, float dy);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetMatrixElements(IntPtr matrix, IntPtr matrixOut);

		[DllImport("gdiplus")]
		internal static extern Status GdipMultiplyMatrix(IntPtr matrix, IntPtr matrix2, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipTranslateMatrix(IntPtr matrix, float offsetX, float offsetY, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipScaleMatrix(IntPtr matrix, float scaleX, float scaleY, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipRotateMatrix(IntPtr matrix, float angle, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipShearMatrix(IntPtr matrix, float shearX, float shearY, MatrixOrder order);

		[DllImport("gdiplus")]
		internal static extern Status GdipInvertMatrix(IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipTransformMatrixPoints(IntPtr matrix, [In][Out] PointF[] pts, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipTransformMatrixPointsI(IntPtr matrix, [In][Out] Point[] pts, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipVectorTransformMatrixPoints(IntPtr matrix, [In][Out] PointF[] pts, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipVectorTransformMatrixPointsI(IntPtr matrix, [In][Out] Point[] pts, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsMatrixInvertible(IntPtr matrix, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsMatrixIdentity(IntPtr matrix, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsMatrixEqual(IntPtr matrix, IntPtr matrix2, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreatePath(FillMode brushMode, out IntPtr path);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreatePath2(PointF[] points, byte[] types, int count, FillMode brushMode, out IntPtr path);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreatePath2I(Point[] points, byte[] types, int count, FillMode brushMode, out IntPtr path);

		[DllImport("gdiplus")]
		internal static extern Status GdipClonePath(IntPtr path, out IntPtr clonePath);

		[DllImport("gdiplus")]
		internal static extern Status GdipDeletePath(IntPtr path);

		[DllImport("gdiplus")]
		internal static extern Status GdipResetPath(IntPtr path);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPointCount(IntPtr path, out int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathTypes(IntPtr path, [Out] byte[] types, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathPoints(IntPtr path, [Out] PointF[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathPointsI(IntPtr path, [Out] Point[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathFillMode(IntPtr path, out FillMode fillMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPathFillMode(IntPtr path, FillMode fillMode);

		[DllImport("gdiplus")]
		internal static extern Status GdipStartPathFigure(IntPtr path);

		[DllImport("gdiplus")]
		internal static extern Status GdipClosePathFigure(IntPtr path);

		[DllImport("gdiplus")]
		internal static extern Status GdipClosePathFigures(IntPtr path);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetPathMarker(IntPtr path);

		[DllImport("gdiplus")]
		internal static extern Status GdipClearPathMarkers(IntPtr path);

		[DllImport("gdiplus")]
		internal static extern Status GdipReversePath(IntPtr path);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathLastPoint(IntPtr path, out PointF lastPoint);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathLine(IntPtr path, float x1, float y1, float x2, float y2);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathLine2(IntPtr path, PointF[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathLine2I(IntPtr path, Point[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathArc(IntPtr path, float x, float y, float width, float height, float startAngle, float sweepAngle);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathBezier(IntPtr path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathBeziers(IntPtr path, PointF[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathCurve(IntPtr path, PointF[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathCurveI(IntPtr path, Point[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathCurve2(IntPtr path, PointF[] points, int count, float tension);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathCurve2I(IntPtr path, Point[] points, int count, float tension);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathCurve3(IntPtr path, PointF[] points, int count, int offset, int numberOfSegments, float tension);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathCurve3I(IntPtr path, Point[] points, int count, int offset, int numberOfSegments, float tension);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathClosedCurve(IntPtr path, PointF[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathClosedCurveI(IntPtr path, Point[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathClosedCurve2(IntPtr path, PointF[] points, int count, float tension);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathClosedCurve2I(IntPtr path, Point[] points, int count, float tension);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathRectangle(IntPtr path, float x, float y, float width, float height);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathRectangles(IntPtr path, RectangleF[] rects, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathEllipse(IntPtr path, float x, float y, float width, float height);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathEllipseI(IntPtr path, int x, int y, int width, int height);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathPie(IntPtr path, float x, float y, float width, float height, float startAngle, float sweepAngle);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathPieI(IntPtr path, int x, int y, int width, int height, float startAngle, float sweepAngle);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathPolygon(IntPtr path, PointF[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathPath(IntPtr path, IntPtr addingPath, bool connect);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathLineI(IntPtr path, int x1, int y1, int x2, int y2);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathArcI(IntPtr path, int x, int y, int width, int height, float startAngle, float sweepAngle);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathBezierI(IntPtr path, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathBeziersI(IntPtr path, Point[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathPolygonI(IntPtr path, Point[] points, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathRectangleI(IntPtr path, int x, int y, int width, int height);

		[DllImport("gdiplus")]
		internal static extern Status GdipAddPathRectanglesI(IntPtr path, Rectangle[] rects, int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipFlattenPath(IntPtr path, IntPtr matrix, float floatness);

		[DllImport("gdiplus")]
		internal static extern Status GdipTransformPath(IntPtr path, IntPtr matrix);

		[DllImport("gdiplus")]
		internal static extern Status GdipWarpPath(IntPtr path, IntPtr matrix, PointF[] points, int count, float srcx, float srcy, float srcwidth, float srcheight, WarpMode mode, float flatness);

		[DllImport("gdiplus")]
		internal static extern Status GdipWidenPath(IntPtr path, IntPtr pen, IntPtr matrix, float flatness);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathWorldBounds(IntPtr path, out RectangleF bounds, IntPtr matrix, IntPtr pen);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetPathWorldBoundsI(IntPtr path, out Rectangle bounds, IntPtr matrix, IntPtr pen);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsVisiblePathPoint(IntPtr path, float x, float y, IntPtr graphics, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsVisiblePathPointI(IntPtr path, int x, int y, IntPtr graphics, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsOutlineVisiblePathPoint(IntPtr path, float x, float y, IntPtr pen, IntPtr graphics, out bool result);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsOutlineVisiblePathPointI(IntPtr path, int x, int y, IntPtr pen, IntPtr graphics, out bool result);

		[DllImport("gdiplus")]
		internal static extern int GdipCreatePathIter(out IntPtr iterator, HandleRef path);

		[DllImport("gdiplus")]
		internal static extern int GdipPathIterGetCount(HandleRef iterator, out int count);

		[DllImport("gdiplus")]
		internal static extern int GdipPathIterGetSubpathCount(HandleRef iterator, out int count);

		[DllImport("gdiplus")]
		internal static extern int GdipDeletePathIter(HandleRef iterator);

		[DllImport("gdiplus")]
		internal static extern int GdipPathIterCopyData(HandleRef iterator, out int resultCount, IntPtr points, byte[] types, int startIndex, int endIndex);

		[DllImport("gdiplus")]
		internal static extern int GdipPathIterEnumerate(HandleRef iterator, out int resultCount, IntPtr points, byte[] types, int count);

		[DllImport("gdiplus")]
		internal static extern int GdipPathIterHasCurve(HandleRef iterator, out bool curve);

		[DllImport("gdiplus")]
		internal static extern int GdipPathIterNextMarkerPath(HandleRef iterator, out int resultCount, HandleRef path);

		[DllImport("gdiplus")]
		internal static extern int GdipPathIterNextMarker(HandleRef iterator, out int resultCount, out int startIndex, out int endIndex);

		[DllImport("gdiplus")]
		internal static extern int GdipPathIterNextPathType(HandleRef iterator, out int resultCount, out byte pathType, out int startIndex, out int endIndex);

		[DllImport("gdiplus")]
		internal static extern int GdipPathIterNextSubpathPath(HandleRef iterator, out int resultCount, HandleRef path, out bool isClosed);

		[DllImport("gdiplus")]
		internal static extern int GdipPathIterNextSubpath(HandleRef iterator, out int resultCount, out int startIndex, out int endIndex, out bool isClosed);

		[DllImport("gdiplus")]
		internal static extern int GdipPathIterRewind(HandleRef iterator);

		[DllImport("gdiplus")]
		internal static extern int GdipCreateImageAttributes(out IntPtr imageattr);

		[DllImport("gdiplus")]
		internal static extern int GdipSetImageAttributesColorKeys(HandleRef imageattr, ColorAdjustType type, bool enableFlag, int colorLow, int colorHigh);

		[DllImport("gdiplus")]
		internal static extern int GdipDisposeImageAttributes(HandleRef imageattr);

		[DllImport("gdiplus")]
		internal static extern int GdipSetImageAttributesColorMatrix(HandleRef imageattr, ColorAdjustType type, bool enableFlag, ColorMatrix colorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag flags);

		[DllImport("gdiplus")]
		internal static extern int GdipSetImageAttributesGamma(HandleRef imageattr, ColorAdjustType type, bool enableFlag, float gamma);

		[DllImport("gdiplus")]
		internal static extern int GdipSetImageAttributesNoOp(HandleRef imageattr, ColorAdjustType type, bool enableFlag);

		[DllImport("gdiplus")]
		internal static extern int GdipSetImageAttributesOutputChannel(HandleRef imageattr, ColorAdjustType type, bool enableFlag, ColorChannelFlag channelFlags);

		[DllImport("gdiplus", CharSet = CharSet.Auto)]
		internal static extern int GdipSetImageAttributesOutputChannelColorProfile(HandleRef imageattr, ColorAdjustType type, bool enableFlag, [MarshalAs(UnmanagedType.LPWStr)] string profileName);

		[DllImport("gdiplus")]
		internal static extern int GdipSetImageAttributesRemapTable(HandleRef imageattr, ColorAdjustType type, bool enableFlag, int mapSize, HandleRef colorMap);

		[DllImport("gdiplus")]
		internal static extern int GdipSetImageAttributesThreshold(HandleRef imageattr, ColorAdjustType type, bool enableFlag, float thresHold);

		[DllImport("gdiplus")]
		internal static extern int GdipCloneImageAttributes(HandleRef imageattr, out IntPtr cloneImageattr);

		[DllImport("gdiplus")]
		internal static extern int GdipGetImageAttributesAdjustedPalette(HandleRef imageattr, HandleRef colorPalette, ColorAdjustType colorAdjustType);

		[DllImport("gdiplus")]
		internal static extern int GdipSetImageAttributesWrapMode(HandleRef imageattr, int wrap, int argb, bool clamp);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateFont(IntPtr fontFamily, float emSize, FontStyle style, GraphicsUnit unit, out IntPtr font);

		[DllImport("gdiplus")]
		internal static extern Status GdipDeleteFont(IntPtr font);

		[DllImport("gdiplus", CharSet = CharSet.Auto)]
		internal static extern Status GdipGetLogFont(IntPtr font, IntPtr graphics, [Out][MarshalAs(UnmanagedType.AsAny)] object logfontA);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateFontFromDC(IntPtr hdc, out IntPtr font);

		[DllImport("gdiplus", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern Status GdipCreateFontFromLogfont(IntPtr hdc, ref LOGFONT lf, out IntPtr ptr);

		[DllImport("gdiplus", CharSet = CharSet.Ansi)]
		internal static extern Status GdipCreateFontFromHfont(IntPtr hdc, out IntPtr font, ref LOGFONT lf);

		[DllImport("gdi32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto)]
		internal static extern IntPtr CreateFontIndirect(ref LOGFONT logfont);

		[DllImport("user32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi)]
		internal static extern IntPtr GetDC(IntPtr hwnd);

		[DllImport("user32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi)]
		internal static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);

		[DllImport("gdi32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi)]
		internal static extern IntPtr SelectObject(IntPtr hdc, IntPtr obj);

		[DllImport("user32.dll", SetLastError = true)]
		internal static extern bool GetIconInfo(IntPtr hIcon, out IconInfo iconinfo);

		[DllImport("user32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
		internal static extern IntPtr CreateIconIndirect([In] ref IconInfo piconinfo);

		[DllImport("user32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
		internal static extern bool DestroyIcon(IntPtr hIcon);

		[DllImport("gdi32.dll")]
		internal static extern bool DeleteObject(IntPtr hObject);

		[DllImport("user32.dll")]
		internal static extern IntPtr GetDesktopWindow();

		[DllImport("gdi32.dll", SetLastError = true)]
		public static extern int BitBlt(IntPtr hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, IntPtr hdcSrc, int nXSrc, int nYSrc, int dwRop);

		[DllImport("user32.dll", CallingConvention = CallingConvention.StdCall, EntryPoint = "GetSysColor")]
		public static extern uint Win32GetSysColor(GetSysColorIndex index);

		[DllImport("libX11")]
		internal static extern IntPtr XOpenDisplay(IntPtr display);

		[DllImport("libX11")]
		internal static extern int XCloseDisplay(IntPtr display);

		[DllImport("libX11")]
		internal static extern IntPtr XRootWindow(IntPtr display, int screen);

		[DllImport("libX11")]
		internal static extern int XDefaultScreen(IntPtr display);

		[DllImport("libX11")]
		internal static extern uint XDefaultDepth(IntPtr display, int screen);

		[DllImport("libX11")]
		internal static extern IntPtr XGetImage(IntPtr display, IntPtr drawable, int src_x, int src_y, int width, int height, int pane, int format);

		[DllImport("libX11")]
		internal static extern int XGetPixel(IntPtr image, int x, int y);

		[DllImport("libX11")]
		internal static extern int XDestroyImage(IntPtr image);

		[DllImport("libX11")]
		internal static extern IntPtr XDefaultVisual(IntPtr display, int screen);

		[DllImport("libX11")]
		internal static extern IntPtr XGetVisualInfo(IntPtr display, int vinfo_mask, ref XVisualInfo vinfo_template, ref int nitems);

		[DllImport("libX11")]
		internal static extern IntPtr XVisualIDFromVisual(IntPtr visual);

		[DllImport("libX11")]
		internal static extern void XFree(IntPtr data);

		[DllImport("gdiplus")]
		internal static extern int GdipGetFontCollectionFamilyCount(HandleRef collection, out int found);

		[DllImport("gdiplus")]
		internal static extern int GdipGetFontCollectionFamilyList(HandleRef collection, int getCount, IntPtr[] dest, out int retCount);

		[DllImport("gdiplus")]
		internal static extern int GdipNewInstalledFontCollection(out IntPtr collection);

		[DllImport("gdiplus")]
		internal static extern Status GdipNewPrivateFontCollection(out IntPtr collection);

		[DllImport("gdiplus")]
		internal static extern Status GdipDeletePrivateFontCollection(ref IntPtr collection);

		[DllImport("gdiplus", CharSet = CharSet.Auto)]
		internal static extern Status GdipPrivateAddFontFile(IntPtr collection, [MarshalAs(UnmanagedType.LPWStr)] string fileName);

		[DllImport("gdiplus")]
		internal static extern Status GdipPrivateAddMemoryFont(IntPtr collection, IntPtr mem, int length);

		[DllImport("gdiplus", CharSet = CharSet.Auto)]
		internal static extern Status GdipCreateFontFamilyFromName([MarshalAs(UnmanagedType.LPWStr)] string fName, IntPtr collection, out IntPtr fontFamily);

		[DllImport("gdiplus", CharSet = CharSet.Unicode)]
		internal static extern Status GdipGetFamilyName(IntPtr family, StringBuilder name, int language);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetGenericFontFamilySansSerif(out IntPtr fontFamily);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetGenericFontFamilySerif(out IntPtr fontFamily);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetGenericFontFamilyMonospace(out IntPtr fontFamily);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetCellAscent(IntPtr fontFamily, int style, out short ascent);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetCellDescent(IntPtr fontFamily, int style, out short descent);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetLineSpacing(IntPtr fontFamily, int style, out short spacing);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetEmHeight(IntPtr fontFamily, int style, out short emHeight);

		[DllImport("gdiplus")]
		internal static extern Status GdipIsStyleAvailable(IntPtr fontFamily, int style, out bool styleAvailable);

		[DllImport("gdiplus")]
		internal static extern Status GdipDeleteFontFamily(IntPtr fontFamily);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetFontSize(IntPtr font, out float size);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetFontHeight(IntPtr font, IntPtr graphics, out float height);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetFontHeightGivenDPI(IntPtr font, float dpi, out float height);

		[DllImport("gdiplus")]
		internal static extern int GdipCloneFontFamily(HandleRef fontFamily, out IntPtr clone);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateStringFormat(int formatAttributes, int language, out IntPtr format);

		[DllImport("gdiplus")]
		internal static extern Status GdipStringFormatGetGenericDefault(out IntPtr format);

		[DllImport("gdiplus")]
		internal static extern Status GdipStringFormatGetGenericTypographic(out IntPtr format);

		[DllImport("gdiplus")]
		internal static extern Status GdipDeleteStringFormat(IntPtr format);

		[DllImport("gdiplus")]
		internal static extern Status GdipCloneStringFormat(IntPtr srcformat, out IntPtr format);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetStringFormatFlags(IntPtr format, StringFormatFlags flags);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetStringFormatFlags(IntPtr format, out StringFormatFlags flags);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetStringFormatAlign(IntPtr format, StringAlignment align);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetStringFormatAlign(IntPtr format, out StringAlignment align);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetStringFormatLineAlign(IntPtr format, StringAlignment align);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetStringFormatLineAlign(IntPtr format, out StringAlignment align);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetStringFormatTrimming(IntPtr format, StringTrimming trimming);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetStringFormatTrimming(IntPtr format, out StringTrimming trimming);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetStringFormatHotkeyPrefix(IntPtr format, HotkeyPrefix hotkeyPrefix);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetStringFormatHotkeyPrefix(IntPtr format, out HotkeyPrefix hotkeyPrefix);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetStringFormatTabStops(IntPtr format, float firstTabOffset, int count, float[] tabStops);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetStringFormatDigitSubstitution(IntPtr format, int language, out StringDigitSubstitute substitute);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetStringFormatDigitSubstitution(IntPtr format, int language, StringDigitSubstitute substitute);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetStringFormatTabStopCount(IntPtr format, out int count);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetStringFormatTabStops(IntPtr format, int count, out float firstTabOffset, [In][Out] float[] tabStops);

		[DllImport("gdiplus", CharSet = CharSet.Auto)]
		internal static extern Status GdipCreateMetafileFromFile([MarshalAs(UnmanagedType.LPWStr)] string filename, out IntPtr metafile);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateMetafileFromEmf(IntPtr hEmf, bool deleteEmf, out IntPtr metafile);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateMetafileFromWmf(IntPtr hWmf, bool deleteWmf, WmfPlaceableFileHeader wmfPlaceableFileHeader, out IntPtr metafile);

		[DllImport("gdiplus", CharSet = CharSet.Auto)]
		internal static extern Status GdipGetMetafileHeaderFromFile([MarshalAs(UnmanagedType.LPWStr)] string filename, IntPtr header);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetMetafileHeaderFromMetafile(IntPtr metafile, IntPtr header);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetMetafileHeaderFromEmf(IntPtr hEmf, IntPtr header);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetMetafileHeaderFromWmf(IntPtr hWmf, IntPtr wmfPlaceableFileHeader, IntPtr header);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetHemfFromMetafile(IntPtr metafile, out IntPtr hEmf);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetMetafileDownLevelRasterizationLimit(IntPtr metafile, ref uint metafileRasterizationLimitDpi);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetMetafileDownLevelRasterizationLimit(IntPtr metafile, uint metafileRasterizationLimitDpi);

		[DllImport("gdiplus")]
		internal static extern Status GdipPlayMetafileRecord(IntPtr metafile, EmfPlusRecordType recordType, int flags, int dataSize, byte[] data);

		[DllImport("gdiplus")]
		internal static extern Status GdipRecordMetafile(IntPtr hdc, EmfType type, ref RectangleF frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)] string description, out IntPtr metafile);

		[DllImport("gdiplus")]
		internal static extern Status GdipRecordMetafileI(IntPtr hdc, EmfType type, ref Rectangle frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)] string description, out IntPtr metafile);

		[DllImport("gdiplus")]
		internal static extern Status GdipRecordMetafileFileName([MarshalAs(UnmanagedType.LPWStr)] string filename, IntPtr hdc, EmfType type, ref RectangleF frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)] string description, out IntPtr metafile);

		[DllImport("gdiplus")]
		internal static extern Status GdipRecordMetafileFileNameI([MarshalAs(UnmanagedType.LPWStr)] string filename, IntPtr hdc, EmfType type, ref Rectangle frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)] string description, out IntPtr metafile);

		[DllImport("gdiplus", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal static extern Status GdipCreateMetafileFromStream([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "System.Drawing.ComIStreamMarshaler")] IStream stream, out IntPtr metafile);

		[DllImport("gdiplus", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal static extern Status GdipGetMetafileHeaderFromStream([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "System.Drawing.ComIStreamMarshaler")] IStream stream, IntPtr header);

		[DllImport("gdiplus")]
		internal static extern Status GdipRecordMetafileStream([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "System.Drawing.ComIStreamMarshaler")] IStream stream, IntPtr hdc, EmfType type, ref RectangleF frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)] string description, out IntPtr metafile);

		[DllImport("gdiplus")]
		internal static extern Status GdipRecordMetafileStreamI([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "System.Drawing.ComIStreamMarshaler")] IStream stream, IntPtr hdc, EmfType type, ref Rectangle frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)] string description, out IntPtr metafile);

		[DllImport("gdiplus")]
		internal static extern int GdipGetImageDecodersSize(out int decoderNums, out int arraySize);

		[DllImport("gdiplus")]
		internal static extern int GdipGetImageDecoders(int decoderNums, int arraySize, IntPtr decoders);

		[DllImport("gdiplus")]
		internal static extern int GdipGetImageEncodersSize(out int encoderNums, out int arraySize);

		[DllImport("gdiplus")]
		internal static extern int GdipGetImageEncoders(int encoderNums, int arraySize, IntPtr encoders);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateFromContext_macosx(IntPtr cgref, int width, int height, out IntPtr graphics);

		[DllImport("gdiplus")]
		internal static extern Status GdipSetVisibleClip_linux(IntPtr graphics, ref Rectangle rect);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateFromXDrawable_linux(IntPtr drawable, IntPtr display, out IntPtr graphics);

		[DllImport("gdiplus")]
		internal static extern Status GdipLoadImageFromDelegate_linux(StreamGetHeaderDelegate getHeader, StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close, StreamSizeDelegate size, out IntPtr image);

		[DllImport("gdiplus")]
		internal static extern Status GdipSaveImageToDelegate_linux(IntPtr image, StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close, StreamSizeDelegate size, ref Guid encoderClsID, IntPtr encoderParameters);

		[DllImport("gdiplus")]
		internal static extern Status GdipCreateMetafileFromDelegate_linux(StreamGetHeaderDelegate getHeader, StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close, StreamSizeDelegate size, out IntPtr metafile);

		[DllImport("gdiplus")]
		internal static extern Status GdipGetMetafileHeaderFromDelegate_linux(StreamGetHeaderDelegate getHeader, StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close, StreamSizeDelegate size, IntPtr header);

		[DllImport("gdiplus")]
		internal static extern Status GdipRecordMetafileFromDelegate_linux(StreamGetHeaderDelegate getHeader, StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close, StreamSizeDelegate size, IntPtr hdc, EmfType type, ref RectangleF frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)] string description, out IntPtr metafile);

		[DllImport("gdiplus")]
		internal static extern Status GdipRecordMetafileFromDelegateI_linux(StreamGetHeaderDelegate getHeader, StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close, StreamSizeDelegate size, IntPtr hdc, EmfType type, ref Rectangle frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)] string description, out IntPtr metafile);

		[DllImport("libc")]
		private static extern int uname(IntPtr buf);
	}
	internal struct GdiplusStartupInput
	{
		internal uint GdiplusVersion;

		internal IntPtr DebugEventCallback;

		internal int SuppressBackgroundThread;

		internal int SuppressExternalCodecs;

		internal static GdiplusStartupInput MakeGdiplusStartupInput()
		{
			return new GdiplusStartupInput
			{
				GdiplusVersion = 1u,
				DebugEventCallback = IntPtr.Zero,
				SuppressBackgroundThread = 0,
				SuppressExternalCodecs = 0
			};
		}
	}
	internal struct GdiplusStartupOutput
	{
		internal IntPtr NotificationHook;

		internal IntPtr NotificationUnhook;

		internal static GdiplusStartupOutput MakeGdiplusStartupOutput()
		{
			GdiplusStartupOutput result = default(GdiplusStartupOutput);
			result.NotificationHook = (result.NotificationUnhook = IntPtr.Zero);
			return result;
		}
	}
	internal struct GdiColorPalette
	{
		internal int Flags;

		internal int Count;
	}
	internal struct GdiColorMap
	{
		internal int from;

		internal int to;
	}
	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
	internal struct LOGFONT
	{
		internal int lfHeight;

		internal uint lfWidth;

		internal uint lfEscapement;

		internal uint lfOrientation;

		internal uint lfWeight;

		internal byte lfItalic;

		internal byte lfUnderline;

		internal byte lfStrikeOut;

		internal byte lfCharSet;

		internal byte lfOutPrecision;

		internal byte lfClipPrecision;

		internal byte lfQuality;

		internal byte lfPitchAndFamily;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
		internal string lfFaceName;
	}
	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal struct GdipImageCodecInfo
	{
		internal Guid Clsid;

		internal Guid FormatID;

		internal IntPtr CodecName;

		internal IntPtr DllName;

		internal IntPtr FormatDescription;

		internal IntPtr FilenameExtension;

		internal IntPtr MimeType;

		internal ImageCodecFlags Flags;

		internal int Version;

		internal int SigCount;

		internal int SigSize;

		private IntPtr SigPattern;

		private IntPtr SigMask;

		internal static void MarshalTo(GdipImageCodecInfo gdipcodec, ImageCodecInfo codec)
		{
			codec.CodecName = Marshal.PtrToStringUni(gdipcodec.CodecName);
			codec.DllName = Marshal.PtrToStringUni(gdipcodec.DllName);
			codec.FormatDescription = Marshal.PtrToStringUni(gdipcodec.FormatDescription);
			codec.FilenameExtension = Marshal.PtrToStringUni(gdipcodec.FilenameExtension);
			codec.MimeType = Marshal.PtrToStringUni(gdipcodec.MimeType);
			codec.Clsid = gdipcodec.Clsid;
			codec.FormatID = gdipcodec.FormatID;
			codec.Flags = gdipcodec.Flags;
			codec.Version = gdipcodec.Version;
			codec.SignatureMasks = new byte[gdipcodec.SigCount][];
			codec.SignaturePatterns = new byte[gdipcodec.SigCount][];
			IntPtr source = gdipcodec.SigPattern;
			IntPtr source2 = gdipcodec.SigMask;
			for (int i = 0; i < gdipcodec.SigCount; i++)
			{
				codec.SignatureMasks[i] = new byte[gdipcodec.SigSize];
				Marshal.Copy(source2, codec.SignatureMasks[i], 0, gdipcodec.SigSize);
				source2 = new IntPtr(source2.ToInt64() + gdipcodec.SigSize);
				codec.SignaturePatterns[i] = new byte[gdipcodec.SigSize];
				Marshal.Copy(source, codec.SignaturePatterns[i], 0, gdipcodec.SigSize);
				source = new IntPtr(source.ToInt64() + gdipcodec.SigSize);
			}
		}
	}
	internal struct GdipEncoderParameter
	{
		internal Guid guid;

		internal uint numberOfValues;

		internal EncoderParameterValueType type;

		internal IntPtr value;
	}
	internal struct GdipPropertyItem
	{
		internal int id;

		internal int len;

		internal short type;

		internal IntPtr value;

		internal static void MarshalTo(GdipPropertyItem gdipProp, PropertyItem prop)
		{
			prop.Id = gdipProp.id;
			prop.Len = gdipProp.len;
			prop.Type = gdipProp.type;
			prop.Value = new byte[gdipProp.len];
			Marshal.Copy(gdipProp.value, prop.Value, 0, gdipProp.len);
		}
	}
	internal struct IconInfo
	{
		private int fIcon;

		public int xHotspot;

		public int yHotspot;

		public IntPtr hbmMask;

		public IntPtr hbmColor;

		public bool IsIcon
		{
			get
			{
				return fIcon == 1;
			}
			set
			{
				fIcon = (value ? 1 : 0);
			}
		}
	}
	internal struct XColor
	{
		public int pixel;

		public ushort red;

		public ushort green;

		public ushort blue;

		public sbyte flags;

		public sbyte pad;
	}
	internal struct XVisualInfo
	{
		internal IntPtr visual;

		internal IntPtr visualid;

		internal int screen;

		internal uint depth;

		internal int klass;

		internal IntPtr red_mask;

		internal IntPtr green_mask;

		internal IntPtr blue_mask;

		internal int colormap_size;

		internal int bits_per_rgb;
	}
	internal static class MacSupport
	{
		internal static Hashtable contextReference;

		internal static object lockobj;

		internal static Delegate hwnd_delegate;

		static MacSupport()
		{
			contextReference = new Hashtable();
			lockobj = new object();
			Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
			foreach (Assembly assembly in assemblies)
			{
				if (string.Equals(assembly.GetName().Name, "System.Windows.Forms"))
				{
					Type type = assembly.GetType("System.Windows.Forms.XplatUICarbon");
					if (type != null)
					{
						hwnd_delegate = (Delegate)type.GetTypeInfo().GetField("HwndDelegate", BindingFlags.Static | BindingFlags.NonPublic).GetValue(null);
					}
				}
			}
		}

		internal static CocoaContext GetCGContextForNSView(IntPtr handle)
		{
			IntPtr intPtr = objc_msgSend(objc_msgSend(objc_getClass("NSGraphicsContext"), sel_registerName("currentContext")), sel_registerName("graphicsPort"));
			Rect arect = default(Rect);
			CGContextSaveGState(intPtr);
			objc_msgSend_stret(ref arect, handle, sel_registerName("bounds"));
			if (bool_objc_msgSend(handle, sel_registerName("isFlipped")))
			{
				CGContextTranslateCTM(intPtr, arect.origin.x, arect.size.height);
				CGContextScaleCTM(intPtr, 1f, -1f);
			}
			return new CocoaContext(intPtr, (int)arect.size.width, (int)arect.size.height);
		}

		internal static CarbonContext GetCGContextForView(IntPtr handle)
		{
			IntPtr context = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			IntPtr zero2 = IntPtr.Zero;
			zero2 = GetControlOwner(handle);
			if (handle == IntPtr.Zero || zero2 == IntPtr.Zero)
			{
				zero = GetQDGlobalsThePort();
				CreateCGContextForPort(zero, ref context);
				Rect rect = CGDisplayBounds(CGMainDisplayID());
				return new CarbonContext(zero, context, (int)rect.size.width, (int)rect.size.height);
			}
			QDRect rect2 = default(QDRect);
			Rect r = default(Rect);
			zero = GetWindowPort(zero2);
			context = GetContext(zero);
			GetWindowBounds(zero2, 32u, ref rect2);
			HIViewGetBounds(handle, ref r);
			HIViewConvertRect(ref r, handle, IntPtr.Zero);
			if (r.size.height < 0f)
			{
				r.size.height = 0f;
			}
			if (r.size.width < 0f)
			{
				r.size.width = 0f;
			}
			CGContextTranslateCTM(context, r.origin.x, (float)(rect2.bottom - rect2.top) - (r.origin.y + r.size.height));
			Rect rect3 = new Rect(0f, 0f, r.size.width, r.size.height);
			CGContextSaveGState(context);
			Rectangle[] array = (Rectangle[])hwnd_delegate.DynamicInvoke(handle);
			if (array != null && array.Length != 0)
			{
				int num = array.Length;
				CGContextBeginPath(context);
				CGContextAddRect(context, rect3);
				for (int i = 0; i < num; i++)
				{
					CGContextAddRect(context, new Rect(array[i].X, r.size.height - (float)array[i].Y - (float)array[i].Height, array[i].Width, array[i].Height));
				}
				CGContextClosePath(context);
				CGContextEOClip(context);
			}
			else
			{
				CGContextBeginPath(context);
				CGContextAddRect(context, rect3);
				CGContextClosePath(context);
				CGContextClip(context);
			}
			return new CarbonContext(zero, context, (int)r.size.width, (int)r.size.height);
		}

		internal static IntPtr GetContext(IntPtr port)
		{
			IntPtr context = IntPtr.Zero;
			lock (lockobj)
			{
				CreateCGContextForPort(port, ref context);
				return context;
			}
		}

		internal static void ReleaseContext(IntPtr port, IntPtr context)
		{
			CGContextRestoreGState(context);
			lock (lockobj)
			{
				CFRelease(context);
			}
		}

		[DllImport("libobjc.dylib")]
		public static extern IntPtr objc_getClass(string className);

		[DllImport("libobjc.dylib")]
		public static extern IntPtr objc_msgSend(IntPtr basePtr, IntPtr selector, string argument);

		[DllImport("libobjc.dylib")]
		public static extern IntPtr objc_msgSend(IntPtr basePtr, IntPtr selector);

		[DllImport("libobjc.dylib")]
		public static extern void objc_msgSend_stret(ref Rect arect, IntPtr basePtr, IntPtr selector);

		[DllImport("libobjc.dylib", EntryPoint = "objc_msgSend")]
		public static extern bool bool_objc_msgSend(IntPtr handle, IntPtr selector);

		[DllImport("libobjc.dylib")]
		public static extern IntPtr sel_registerName(string selectorName);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern IntPtr CGMainDisplayID();

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern Rect CGDisplayBounds(IntPtr display);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern int HIViewGetBounds(IntPtr vHnd, ref Rect r);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern int HIViewConvertRect(ref Rect r, IntPtr a, IntPtr b);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern IntPtr GetControlOwner(IntPtr aView);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern int GetWindowBounds(IntPtr wHnd, uint reg, ref QDRect rect);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern IntPtr GetWindowPort(IntPtr hWnd);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern IntPtr GetQDGlobalsThePort();

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CreateCGContextForPort(IntPtr port, ref IntPtr context);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CFRelease(IntPtr context);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void QDBeginCGContext(IntPtr port, ref IntPtr context);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void QDEndCGContext(IntPtr port, ref IntPtr context);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern int CGContextClipToRect(IntPtr context, Rect clip);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern int CGContextClipToRects(IntPtr context, Rect[] clip_rects, int count);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGContextTranslateCTM(IntPtr context, float tx, float ty);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGContextScaleCTM(IntPtr context, float x, float y);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGContextFlush(IntPtr context);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGContextSynchronize(IntPtr context);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern IntPtr CGPathCreateMutable();

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGPathAddRects(IntPtr path, IntPtr _void, Rect[] rects, int count);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGPathAddRect(IntPtr path, IntPtr _void, Rect rect);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGContextAddRects(IntPtr context, Rect[] rects, int count);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGContextAddRect(IntPtr context, Rect rect);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGContextBeginPath(IntPtr context);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGContextClosePath(IntPtr context);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGContextAddPath(IntPtr context, IntPtr path);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGContextClip(IntPtr context);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGContextEOClip(IntPtr context);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGContextEOFillPath(IntPtr context);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGContextSaveGState(IntPtr context);

		[DllImport("/System/Library/Frameworks/Carbon.framework/Versions/Current/Carbon")]
		internal static extern void CGContextRestoreGState(IntPtr context);
	}
	internal struct CGSize
	{
		public float width;

		public float height;
	}
	internal struct CGPoint
	{
		public float x;

		public float y;
	}
	internal struct Rect
	{
		public CGPoint origin;

		public CGSize size;

		public Rect(float x, float y, float width, float height)
		{
			origin.x = x;
			origin.y = y;
			size.width = width;
			size.height = height;
		}
	}
	internal struct QDRect
	{
		public short top;

		public short left;

		public short bottom;

		public short right;
	}
	internal struct CarbonContext : IMacContext
	{
		public IntPtr port;

		public IntPtr ctx;

		public int width;

		public int height;

		public CarbonContext(IntPtr port, IntPtr ctx, int width, int height)
		{
			this.port = port;
			this.ctx = ctx;
			this.width = width;
			this.height = height;
		}

		public void Synchronize()
		{
			MacSupport.CGContextSynchronize(ctx);
		}

		public void Release()
		{
			MacSupport.ReleaseContext(port, ctx);
		}
	}
	internal struct CocoaContext : IMacContext
	{
		public IntPtr ctx;

		public int width;

		public int height;

		public CocoaContext(IntPtr ctx, int width, int height)
		{
			this.ctx = ctx;
			this.width = width;
			this.height = height;
		}

		public void Synchronize()
		{
			MacSupport.CGContextSynchronize(ctx);
		}

		public void Release()
		{
			MacSupport.CGContextRestoreGState(ctx);
		}
	}
	internal interface IMacContext
	{
		void Synchronize();

		void Release();
	}
}
namespace System.Drawing.Text
{
	/// <summary>Provides a base class for installed and private font collections.</summary>
	public abstract class FontCollection : IDisposable
	{
		internal IntPtr _nativeFontCollection;

		/// <summary>Gets the array of <see cref="T:System.Drawing.FontFamily" /> objects associated with this <see cref="T:System.Drawing.Text.FontCollection" />.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.FontFamily" /> objects.</returns>
		public FontFamily[] Families
		{
			get
			{
				int found = 0;
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipGetFontCollectionFamilyCount(new HandleRef(this, _nativeFontCollection), out found));
				IntPtr[] array = new IntPtr[found];
				int retCount = 0;
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipGetFontCollectionFamilyList(new HandleRef(this, _nativeFontCollection), found, array, out retCount));
				FontFamily[] array2 = new FontFamily[retCount];
				for (int i = 0; i < retCount; i++)
				{
					GDIPlus.GdipCloneFontFamily(new HandleRef(null, array[i]), out var clone);
					array2[i] = new FontFamily(clone);
				}
				return array2;
			}
		}

		internal FontCollection()
		{
			_nativeFontCollection = IntPtr.Zero;
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Text.FontCollection" />.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		/// <summary>Releases the unmanaged resources used by the <see cref="T:System.Drawing.Text.FontCollection" /> and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///   <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		protected virtual void Dispose(bool disposing)
		{
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~FontCollection()
		{
			Dispose(disposing: false);
		}
	}
	/// <summary>Specifies a generic <see cref="T:System.Drawing.FontFamily" /> object.</summary>
	public enum GenericFontFamilies
	{
		/// <summary>A generic Serif <see cref="T:System.Drawing.FontFamily" /> object.</summary>
		Serif,
		/// <summary>A generic Sans Serif <see cref="T:System.Drawing.FontFamily" /> object.</summary>
		SansSerif,
		/// <summary>A generic Monospace <see cref="T:System.Drawing.FontFamily" /> object.</summary>
		Monospace
	}
	/// <summary>Specifies the type of display for hot-key prefixes that relate to text.</summary>
	public enum HotkeyPrefix
	{
		/// <summary>No hot-key prefix.</summary>
		None,
		/// <summary>Display the hot-key prefix.</summary>
		Show,
		/// <summary>Do not display the hot-key prefix.</summary>
		Hide
	}
	/// <summary>Represents the fonts installed on the system. This class cannot be inherited.</summary>
	public sealed class InstalledFontCollection : FontCollection
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Text.InstalledFontCollection" /> class.</summary>
		public InstalledFontCollection()
		{
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipNewInstalledFontCollection(out _nativeFontCollection));
		}
	}
	/// <summary>Specifies the quality of text rendering.</summary>
	public enum TextRenderingHint
	{
		/// <summary>Each character is drawn using its glyph bitmap, with the system default rendering hint. The text will be drawn using whatever font-smoothing settings the user has selected for the system.</summary>
		SystemDefault,
		/// <summary>Each character is drawn using its glyph bitmap. Hinting is used to improve character appearance on stems and curvature.</summary>
		SingleBitPerPixelGridFit,
		/// <summary>Each character is drawn using its glyph bitmap. Hinting is not used.</summary>
		SingleBitPerPixel,
		/// <summary>Each character is drawn using its antialiased glyph bitmap with hinting. Much better quality due to antialiasing, but at a higher performance cost.</summary>
		AntiAliasGridFit,
		/// <summary>Each character is drawn using its antialiased glyph bitmap without hinting. Better quality due to antialiasing. Stem width differences may be noticeable because hinting is turned off.</summary>
		AntiAlias,
		/// <summary>Each character is drawn using its glyph ClearType bitmap with hinting. The highest quality setting. Used to take advantage of ClearType font features.</summary>
		ClearTypeGridFit
	}
	/// <summary>Provides a collection of font families built from font files that are provided by the client application.</summary>
	public sealed class PrivateFontCollection : FontCollection
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Text.PrivateFontCollection" /> class.</summary>
		public PrivateFontCollection()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipNewPrivateFontCollection(out _nativeFontCollection));
		}

		/// <summary>Adds a font from the specified file to this <see cref="T:System.Drawing.Text.PrivateFontCollection" />.</summary>
		/// <param name="filename">A <see cref="T:System.String" /> that contains the file name of the font to add.</param>
		/// <exception cref="T:System.IO.FileNotFoundException">The specified font is not supported or the font file cannot be found.</exception>
		public void AddFontFile(string filename)
		{
			if (filename == null)
			{
				throw new ArgumentNullException("filename");
			}
			string fullPath = Path.GetFullPath(filename);
			if (!File.Exists(fullPath))
			{
				throw new FileNotFoundException();
			}
			GDIPlus.CheckStatus(GDIPlus.GdipPrivateAddFontFile(_nativeFontCollection, fullPath));
		}

		/// <summary>Adds a font contained in system memory to this <see cref="T:System.Drawing.Text.PrivateFontCollection" />.</summary>
		/// <param name="memory">The memory address of the font to add.</param>
		/// <param name="length">The memory length of the font to add.</param>
		public void AddMemoryFont(IntPtr memory, int length)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipPrivateAddMemoryFont(_nativeFontCollection, memory, length));
		}

		protected override void Dispose(bool disposing)
		{
			if (_nativeFontCollection != IntPtr.Zero)
			{
				GDIPlus.GdipDeletePrivateFontCollection(ref _nativeFontCollection);
				_nativeFontCollection = IntPtr.Zero;
			}
			base.Dispose(disposing);
		}
	}
}
namespace System.Drawing.Printing
{
	/// <summary>Specifies the printer's duplex setting.</summary>
	public enum Duplex
	{
		/// <summary>The printer's default duplex setting.</summary>
		Default = -1,
		/// <summary>Single-sided printing.</summary>
		Simplex = 1,
		/// <summary>Double-sided, horizontal printing.</summary>
		Horizontal = 3,
		/// <summary>Double-sided, vertical printing.</summary>
		Vertical = 2
	}
	/// <summary>Represents the exception that is thrown when you try to access a printer using printer settings that are not valid.</summary>
	[Serializable]
	public class InvalidPrinterException : SystemException
	{
		private PrinterSettings _settings;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.InvalidPrinterException" /> class with serialized data.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
		/// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="info" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is <see langword="null" /> or <see cref="P:System.Exception.HResult" /> is 0.</exception>
		protected InvalidPrinterException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			_settings = (PrinterSettings)info.GetValue("settings", typeof(PrinterSettings));
		}

		/// <summary>Overridden. Sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with information about the exception.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
		/// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="info" /> is <see langword="null" />.</exception>
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			if (info == null)
			{
				throw new ArgumentNullException("info");
			}
			info.AddValue("settings", _settings);
			base.GetObjectData(info, context);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.InvalidPrinterException" /> class.</summary>
		/// <param name="settings">A <see cref="T:System.Drawing.Printing.PrinterSettings" /> that specifies the settings for a printer.</param>
		public InvalidPrinterException(PrinterSettings settings)
			: base(GenerateMessage(settings))
		{
			_settings = settings;
		}

		private static string GenerateMessage(PrinterSettings settings)
		{
			if (settings.IsDefaultPrinter)
			{
				return global::SR.Format("No printers are installed.");
			}
			try
			{
				return global::SR.Format("Settings to access printer '{0}' are not valid.", settings.PrinterName);
			}
			catch (SecurityException)
			{
				return global::SR.Format("Settings to access printer '{0}' are not valid.", global::SR.Format("(printer name protected due to security restrictions)"));
			}
		}
	}
	/// <summary>Specifies the dimensions of the margins of a printed page.</summary>
	[Serializable]
	[TypeConverter(typeof(MarginsConverter))]
	public class Margins : ICloneable
	{
		private int _left;

		private int _right;

		private int _bottom;

		private int _top;

		[OptionalField]
		private double _doubleLeft;

		[OptionalField]
		private double _doubleRight;

		[OptionalField]
		private double _doubleTop;

		[OptionalField]
		private double _doubleBottom;

		/// <summary>Gets or sets the left margin width, in hundredths of an inch.</summary>
		/// <returns>The left margin width, in hundredths of an inch.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.Margins.Left" /> property is set to a value that is less than 0.</exception>
		public int Left
		{
			get
			{
				return _left;
			}
			set
			{
				CheckMargin(value, "Left");
				_left = value;
				_doubleLeft = value;
			}
		}

		/// <summary>Gets or sets the right margin width, in hundredths of an inch.</summary>
		/// <returns>The right margin width, in hundredths of an inch.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.Margins.Right" /> property is set to a value that is less than 0.</exception>
		public int Right
		{
			get
			{
				return _right;
			}
			set
			{
				CheckMargin(value, "Right");
				_right = value;
				_doubleRight = value;
			}
		}

		/// <summary>Gets or sets the top margin width, in hundredths of an inch.</summary>
		/// <returns>The top margin width, in hundredths of an inch.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.Margins.Top" /> property is set to a value that is less than 0.</exception>
		public int Top
		{
			get
			{
				return _top;
			}
			set
			{
				CheckMargin(value, "Top");
				_top = value;
				_doubleTop = value;
			}
		}

		/// <summary>Gets or sets the bottom margin, in hundredths of an inch.</summary>
		/// <returns>The bottom margin, in hundredths of an inch.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.Margins.Bottom" /> property is set to a value that is less than 0.</exception>
		public int Bottom
		{
			get
			{
				return _bottom;
			}
			set
			{
				CheckMargin(value, "Bottom");
				_bottom = value;
				_doubleBottom = value;
			}
		}

		internal double DoubleLeft
		{
			get
			{
				return _doubleLeft;
			}
			set
			{
				Left = (int)Math.Round(value);
				_doubleLeft = value;
			}
		}

		internal double DoubleRight
		{
			get
			{
				return _doubleRight;
			}
			set
			{
				Right = (int)Math.Round(value);
				_doubleRight = value;
			}
		}

		internal double DoubleTop
		{
			get
			{
				return _doubleTop;
			}
			set
			{
				Top = (int)Math.Round(value);
				_doubleTop = value;
			}
		}

		internal double DoubleBottom
		{
			get
			{
				return _doubleBottom;
			}
			set
			{
				Bottom = (int)Math.Round(value);
				_doubleBottom = value;
			}
		}

		[OnDeserialized]
		private void OnDeserializedMethod(StreamingContext context)
		{
			if (_doubleLeft == 0.0 && _left != 0)
			{
				_doubleLeft = _left;
			}
			if (_doubleRight == 0.0 && _right != 0)
			{
				_doubleRight = _right;
			}
			if (_doubleTop == 0.0 && _top != 0)
			{
				_doubleTop = _top;
			}
			if (_doubleBottom == 0.0 && _bottom != 0)
			{
				_doubleBottom = _bottom;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.Margins" /> class with 1-inch wide margins.</summary>
		public Margins()
			: this(100, 100, 100, 100)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.Margins" /> class with the specified left, right, top, and bottom margins.</summary>
		/// <param name="left">The left margin, in hundredths of an inch.</param>
		/// <param name="right">The right margin, in hundredths of an inch.</param>
		/// <param name="top">The top margin, in hundredths of an inch.</param>
		/// <param name="bottom">The bottom margin, in hundredths of an inch.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="left" /> parameter value is less than 0.  
		///  -or-  
		///  The <paramref name="right" /> parameter value is less than 0.  
		///  -or-  
		///  The <paramref name="top" /> parameter value is less than 0.  
		///  -or-  
		///  The <paramref name="bottom" /> parameter value is less than 0.</exception>
		public Margins(int left, int right, int top, int bottom)
		{
			CheckMargin(left, "left");
			CheckMargin(right, "right");
			CheckMargin(top, "top");
			CheckMargin(bottom, "bottom");
			_left = left;
			_right = right;
			_top = top;
			_bottom = bottom;
			_doubleLeft = left;
			_doubleRight = right;
			_doubleTop = top;
			_doubleBottom = bottom;
		}

		private void CheckMargin(int margin, string name)
		{
			if (margin < 0)
			{
				throw new ArgumentException(global::SR.Format("Value of '{1}' is not valid for '{0}'. '{0}' must be greater than or equal to {2}.", name, margin, "0"));
			}
		}

		/// <summary>Retrieves a duplicate of this object, member by member.</summary>
		/// <returns>A duplicate of this object.</returns>
		public object Clone()
		{
			return MemberwiseClone();
		}

		/// <summary>Compares this <see cref="T:System.Drawing.Printing.Margins" /> to the specified <see cref="T:System.Object" /> to determine whether they have the same dimensions.</summary>
		/// <param name="obj">The object to which to compare this <see cref="T:System.Drawing.Printing.Margins" />.</param>
		/// <returns>
		///   <see langword="true" /> if the specified object is a <see cref="T:System.Drawing.Printing.Margins" /> and has the same <see cref="P:System.Drawing.Printing.Margins.Top" />, <see cref="P:System.Drawing.Printing.Margins.Bottom" />, <see cref="P:System.Drawing.Printing.Margins.Right" /> and <see cref="P:System.Drawing.Printing.Margins.Left" /> values as this <see cref="T:System.Drawing.Printing.Margins" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			Margins margins = obj as Margins;
			if (margins == this)
			{
				return true;
			}
			if (margins == null)
			{
				return false;
			}
			if (margins.Left == Left && margins.Right == Right && margins.Top == Top)
			{
				return margins.Bottom == Bottom;
			}
			return false;
		}

		/// <summary>Calculates and retrieves a hash code based on the width of the left, right, top, and bottom margins.</summary>
		/// <returns>A hash code based on the left, right, top, and bottom margins.</returns>
		public override int GetHashCode()
		{
			int left = Left;
			uint right = (uint)Right;
			uint top = (uint)Top;
			uint bottom = (uint)Bottom;
			return (int)((uint)left ^ ((right << 13) | (right >> 19)) ^ ((top << 26) | (top >> 6)) ^ ((bottom << 7) | (bottom >> 25)));
		}

		/// <summary>Compares two <see cref="T:System.Drawing.Printing.Margins" /> to determine if they have the same dimensions.</summary>
		/// <param name="m1">The first <see cref="T:System.Drawing.Printing.Margins" /> to compare for equality.</param>
		/// <param name="m2">The second <see cref="T:System.Drawing.Printing.Margins" /> to compare for equality.</param>
		/// <returns>
		///   <see langword="true" /> to indicate the <see cref="P:System.Drawing.Printing.Margins.Left" />, <see cref="P:System.Drawing.Printing.Margins.Right" />, <see cref="P:System.Drawing.Printing.Margins.Top" />, and <see cref="P:System.Drawing.Printing.Margins.Bottom" /> properties of both margins have the same value; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(Margins m1, Margins m2)
		{
			if ((object)m1 == null != ((object)m2 == null))
			{
				return false;
			}
			if ((object)m1 != null)
			{
				if (m1.Left == m2.Left && m1.Top == m2.Top && m1.Right == m2.Right)
				{
					return m1.Bottom == m2.Bottom;
				}
				return false;
			}
			return true;
		}

		/// <summary>Compares two <see cref="T:System.Drawing.Printing.Margins" /> to determine whether they are of unequal width.</summary>
		/// <param name="m1">The first <see cref="T:System.Drawing.Printing.Margins" /> to compare for inequality.</param>
		/// <param name="m2">The second <see cref="T:System.Drawing.Printing.Margins" /> to compare for inequality.</param>
		/// <returns>
		///   <see langword="true" /> to indicate if the <see cref="P:System.Drawing.Printing.Margins.Left" />, <see cref="P:System.Drawing.Printing.Margins.Right" />, <see cref="P:System.Drawing.Printing.Margins.Top" />, or <see cref="P:System.Drawing.Printing.Margins.Bottom" /> properties of both margins are not equal; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(Margins m1, Margins m2)
		{
			return !(m1 == m2);
		}

		/// <summary>Converts the <see cref="T:System.Drawing.Printing.Margins" /> to a string.</summary>
		/// <returns>A <see cref="T:System.String" /> representation of the <see cref="T:System.Drawing.Printing.Margins" />.</returns>
		public override string ToString()
		{
			return "[Margins Left=" + Left.ToString(CultureInfo.InvariantCulture) + " Right=" + Right.ToString(CultureInfo.InvariantCulture) + " Top=" + Top.ToString(CultureInfo.InvariantCulture) + " Bottom=" + Bottom.ToString(CultureInfo.InvariantCulture) + "]";
		}
	}
	/// <summary>Specifies the standard paper sizes.</summary>
	public enum PaperKind
	{
		/// <summary>The paper size is defined by the user.</summary>
		Custom = 0,
		/// <summary>Letter paper (8.5 in. by 11 in.).</summary>
		Letter = 1,
		/// <summary>Legal paper (8.5 in. by 14 in.).</summary>
		Legal = 5,
		/// <summary>A4 paper (210 mm by 297 mm).</summary>
		A4 = 9,
		/// <summary>C paper (17 in. by 22 in.).</summary>
		CSheet = 24,
		/// <summary>D paper (22 in. by 34 in.).</summary>
		DSheet = 25,
		/// <summary>E paper (34 in. by 44 in.).</summary>
		ESheet = 26,
		/// <summary>Letter small paper (8.5 in. by 11 in.).</summary>
		LetterSmall = 2,
		/// <summary>Tabloid paper (11 in. by 17 in.).</summary>
		Tabloid = 3,
		/// <summary>Ledger paper (17 in. by 11 in.).</summary>
		Ledger = 4,
		/// <summary>Statement paper (5.5 in. by 8.5 in.).</summary>
		Statement = 6,
		/// <summary>Executive paper (7.25 in. by 10.5 in.).</summary>
		Executive = 7,
		/// <summary>A3 paper (297 mm by 420 mm).</summary>
		A3 = 8,
		/// <summary>A4 small paper (210 mm by 297 mm).</summary>
		A4Small = 10,
		/// <summary>A5 paper (148 mm by 210 mm).</summary>
		A5 = 11,
		/// <summary>B4 paper (250 mm by 353 mm).</summary>
		B4 = 12,
		/// <summary>B5 paper (176 mm by 250 mm).</summary>
		B5 = 13,
		/// <summary>Folio paper (8.5 in. by 13 in.).</summary>
		Folio = 14,
		/// <summary>Quarto paper (215 mm by 275 mm).</summary>
		Quarto = 15,
		/// <summary>Standard paper (10 in. by 14 in.).</summary>
		Standard10x14 = 16,
		/// <summary>Standard paper (11 in. by 17 in.).</summary>
		Standard11x17 = 17,
		/// <summary>Note paper (8.5 in. by 11 in.).</summary>
		Note = 18,
		/// <summary>#9 envelope (3.875 in. by 8.875 in.).</summary>
		Number9Envelope = 19,
		/// <summary>#10 envelope (4.125 in. by 9.5 in.).</summary>
		Number10Envelope = 20,
		/// <summary>#11 envelope (4.5 in. by 10.375 in.).</summary>
		Number11Envelope = 21,
		/// <summary>#12 envelope (4.75 in. by 11 in.).</summary>
		Number12Envelope = 22,
		/// <summary>#14 envelope (5 in. by 11.5 in.).</summary>
		Number14Envelope = 23,
		/// <summary>DL envelope (110 mm by 220 mm).</summary>
		DLEnvelope = 27,
		/// <summary>C5 envelope (162 mm by 229 mm).</summary>
		C5Envelope = 28,
		/// <summary>C3 envelope (324 mm by 458 mm).</summary>
		C3Envelope = 29,
		/// <summary>C4 envelope (229 mm by 324 mm).</summary>
		C4Envelope = 30,
		/// <summary>C6 envelope (114 mm by 162 mm).</summary>
		C6Envelope = 31,
		/// <summary>C65 envelope (114 mm by 229 mm).</summary>
		C65Envelope = 32,
		/// <summary>B4 envelope (250 mm by 353 mm).</summary>
		B4Envelope = 33,
		/// <summary>B5 envelope (176 mm by 250 mm).</summary>
		B5Envelope = 34,
		/// <summary>B6 envelope (176 mm by 125 mm).</summary>
		B6Envelope = 35,
		/// <summary>Italy envelope (110 mm by 230 mm).</summary>
		ItalyEnvelope = 36,
		/// <summary>Monarch envelope (3.875 in. by 7.5 in.).</summary>
		MonarchEnvelope = 37,
		/// <summary>6 3/4 envelope (3.625 in. by 6.5 in.).</summary>
		PersonalEnvelope = 38,
		/// <summary>US standard fanfold (14.875 in. by 11 in.).</summary>
		USStandardFanfold = 39,
		/// <summary>German standard fanfold (8.5 in. by 12 in.).</summary>
		GermanStandardFanfold = 40,
		/// <summary>German legal fanfold (8.5 in. by 13 in.).</summary>
		GermanLegalFanfold = 41,
		/// <summary>ISO B4 (250 mm by 353 mm).</summary>
		IsoB4 = 42,
		/// <summary>Japanese postcard (100 mm by 148 mm).</summary>
		JapanesePostcard = 43,
		/// <summary>Standard paper (9 in. by 11 in.).</summary>
		Standard9x11 = 44,
		/// <summary>Standard paper (10 in. by 11 in.).</summary>
		Standard10x11 = 45,
		/// <summary>Standard paper (15 in. by 11 in.).</summary>
		Standard15x11 = 46,
		/// <summary>Invitation envelope (220 mm by 220 mm).</summary>
		InviteEnvelope = 47,
		/// <summary>Letter extra paper (9.275 in. by 12 in.). This value is specific to the PostScript driver and is used only by Linotronic printers in order to conserve paper.</summary>
		LetterExtra = 50,
		/// <summary>Legal extra paper (9.275 in. by 15 in.). This value is specific to the PostScript driver and is used only by Linotronic printers in order to conserve paper.</summary>
		LegalExtra = 51,
		/// <summary>Tabloid extra paper (11.69 in. by 18 in.). This value is specific to the PostScript driver and is used only by Linotronic printers in order to conserve paper.</summary>
		TabloidExtra = 52,
		/// <summary>A4 extra paper (236 mm by 322 mm). This value is specific to the PostScript driver and is used only by Linotronic printers to help save paper.</summary>
		A4Extra = 53,
		/// <summary>Letter transverse paper (8.275 in. by 11 in.).</summary>
		LetterTransverse = 54,
		/// <summary>A4 transverse paper (210 mm by 297 mm).</summary>
		A4Transverse = 55,
		/// <summary>Letter extra transverse paper (9.275 in. by 12 in.).</summary>
		LetterExtraTransverse = 56,
		/// <summary>SuperA/SuperA/A4 paper (227 mm by 356 mm).</summary>
		APlus = 57,
		/// <summary>SuperB/SuperB/A3 paper (305 mm by 487 mm).</summary>
		BPlus = 58,
		/// <summary>Letter plus paper (8.5 in. by 12.69 in.).</summary>
		LetterPlus = 59,
		/// <summary>A4 plus paper (210 mm by 330 mm).</summary>
		A4Plus = 60,
		/// <summary>A5 transverse paper (148 mm by 210 mm).</summary>
		A5Transverse = 61,
		/// <summary>JIS B5 transverse paper (182 mm by 257 mm).</summary>
		B5Transverse = 62,
		/// <summary>A3 extra paper (322 mm by 445 mm).</summary>
		A3Extra = 63,
		/// <summary>A5 extra paper (174 mm by 235 mm).</summary>
		A5Extra = 64,
		/// <summary>ISO B5 extra paper (201 mm by 276 mm).</summary>
		B5Extra = 65,
		/// <summary>A2 paper (420 mm by 594 mm).</summary>
		A2 = 66,
		/// <summary>A3 transverse paper (297 mm by 420 mm).</summary>
		A3Transverse = 67,
		/// <summary>A3 extra transverse paper (322 mm by 445 mm).</summary>
		A3ExtraTransverse = 68,
		/// <summary>Japanese double postcard (200 mm by 148 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseDoublePostcard = 69,
		/// <summary>A6 paper (105 mm by 148 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		A6 = 70,
		/// <summary>Japanese Kaku #2 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeKakuNumber2 = 71,
		/// <summary>Japanese Kaku #3 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeKakuNumber3 = 72,
		/// <summary>Japanese Chou #3 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeChouNumber3 = 73,
		/// <summary>Japanese Chou #4 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeChouNumber4 = 74,
		/// <summary>Letter rotated paper (11 in. by 8.5 in.).</summary>
		LetterRotated = 75,
		/// <summary>A3 rotated paper (420 mm by 297 mm).</summary>
		A3Rotated = 76,
		/// <summary>A4 rotated paper (297 mm by 210 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		A4Rotated = 77,
		/// <summary>A5 rotated paper (210 mm by 148 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		A5Rotated = 78,
		/// <summary>JIS B4 rotated paper (364 mm by 257 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		B4JisRotated = 79,
		/// <summary>JIS B5 rotated paper (257 mm by 182 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		B5JisRotated = 80,
		/// <summary>Japanese rotated postcard (148 mm by 100 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapanesePostcardRotated = 81,
		/// <summary>Japanese rotated double postcard (148 mm by 200 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseDoublePostcardRotated = 82,
		/// <summary>A6 rotated paper (148 mm by 105 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		A6Rotated = 83,
		/// <summary>Japanese rotated Kaku #2 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeKakuNumber2Rotated = 84,
		/// <summary>Japanese rotated Kaku #3 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeKakuNumber3Rotated = 85,
		/// <summary>Japanese rotated Chou #3 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeChouNumber3Rotated = 86,
		/// <summary>Japanese rotated Chou #4 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeChouNumber4Rotated = 87,
		/// <summary>JIS B6 paper (128 mm by 182 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		B6Jis = 88,
		/// <summary>JIS B6 rotated paper (182 mm by 128 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		B6JisRotated = 89,
		/// <summary>Standard paper (12 in. by 11 in.). Requires Windows 98, Windows NT 4.0, or later.</summary>
		Standard12x11 = 90,
		/// <summary>Japanese You #4 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeYouNumber4 = 91,
		/// <summary>Japanese You #4 rotated envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeYouNumber4Rotated = 92,
		/// <summary>16K paper (146 mm by 215 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		Prc16K = 93,
		/// <summary>32K paper (97 mm by 151 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		Prc32K = 94,
		/// <summary>32K big paper (97 mm by 151 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		Prc32KBig = 95,
		/// <summary>#1 envelope (102 mm by 165 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber1 = 96,
		/// <summary>#2 envelope (102 mm by 176 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber2 = 97,
		/// <summary>#3 envelope (125 mm by 176 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber3 = 98,
		/// <summary>#4 envelope (110 mm by 208 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber4 = 99,
		/// <summary>#5 envelope (110 mm by 220 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber5 = 100,
		/// <summary>#6 envelope (120 mm by 230 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber6 = 101,
		/// <summary>#7 envelope (160 mm by 230 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber7 = 102,
		/// <summary>#8 envelope (120 mm by 309 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber8 = 103,
		/// <summary>#9 envelope (229 mm by 324 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber9 = 104,
		/// <summary>#10 envelope (324 mm by 458 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber10 = 105,
		/// <summary>16K rotated paper (146 mm by 215 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		Prc16KRotated = 106,
		/// <summary>32K rotated paper (97 mm by 151 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		Prc32KRotated = 107,
		/// <summary>32K big rotated paper (97 mm by 151 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		Prc32KBigRotated = 108,
		/// <summary>#1 rotated envelope (165 mm by 102 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber1Rotated = 109,
		/// <summary>#2 rotated envelope (176 mm by 102 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber2Rotated = 110,
		/// <summary>#3 rotated envelope (176 mm by 125 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber3Rotated = 111,
		/// <summary>#4 rotated envelope (208 mm by 110 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber4Rotated = 112,
		/// <summary>Envelope #5 rotated envelope (220 mm by 110 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber5Rotated = 113,
		/// <summary>#6 rotated envelope (230 mm by 120 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber6Rotated = 114,
		/// <summary>#7 rotated envelope (230 mm by 160 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber7Rotated = 115,
		/// <summary>#8 rotated envelope (309 mm by 120 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber8Rotated = 116,
		/// <summary>#9 rotated envelope (324 mm by 229 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber9Rotated = 117,
		/// <summary>#10 rotated envelope (458 mm by 324 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber10Rotated = 118
	}
	/// <summary>Specifies the size of a piece of paper.</summary>
	[Serializable]
	public class PaperSize
	{
		private PaperKind _kind;

		private string _name;

		private int _width;

		private int _height;

		private bool _createdByDefaultConstructor;

		/// <summary>Gets or sets the height of the paper, in hundredths of an inch.</summary>
		/// <returns>The height of the paper, in hundredths of an inch.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.PaperSize.Kind" /> property is not set to <see cref="F:System.Drawing.Printing.PaperKind.Custom" />.</exception>
		public int Height
		{
			get
			{
				return _height;
			}
			set
			{
				if (_kind != PaperKind.Custom && !_createdByDefaultConstructor)
				{
					throw new ArgumentException(global::SR.Format("PaperSize cannot be changed unless the Kind property is set to Custom."));
				}
				_height = value;
			}
		}

		/// <summary>Gets the type of paper.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Printing.PaperKind" /> values.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.PaperSize.Kind" /> property is not set to <see cref="F:System.Drawing.Printing.PaperKind.Custom" />.</exception>
		public PaperKind Kind
		{
			get
			{
				if (_kind <= PaperKind.PrcEnvelopeNumber10Rotated && _kind != (PaperKind)48 && _kind != (PaperKind)49)
				{
					return _kind;
				}
				return PaperKind.Custom;
			}
		}

		/// <summary>Gets or sets the name of the type of paper.</summary>
		/// <returns>The name of the type of paper.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.PaperSize.Kind" /> property is not set to <see cref="F:System.Drawing.Printing.PaperKind.Custom" />.</exception>
		public string PaperName
		{
			get
			{
				return _name;
			}
			set
			{
				if (_kind != PaperKind.Custom && !_createdByDefaultConstructor)
				{
					throw new ArgumentException(global::SR.Format("PaperSize cannot be changed unless the Kind property is set to Custom."));
				}
				_name = value;
			}
		}

		/// <summary>Gets or sets an integer representing one of the <see cref="T:System.Drawing.Printing.PaperSize" /> values or a custom value.</summary>
		/// <returns>An integer representing one of the <see cref="T:System.Drawing.Printing.PaperSize" /> values, or a custom value.</returns>
		public int RawKind
		{
			get
			{
				return (int)_kind;
			}
			set
			{
				_kind = (PaperKind)value;
			}
		}

		/// <summary>Gets or sets the width of the paper, in hundredths of an inch.</summary>
		/// <returns>The width of the paper, in hundredths of an inch.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.PaperSize.Kind" /> property is not set to <see cref="F:System.Drawing.Printing.PaperKind.Custom" />.</exception>
		public int Width
		{
			get
			{
				return _width;
			}
			set
			{
				if (_kind != PaperKind.Custom && !_createdByDefaultConstructor)
				{
					throw new ArgumentException(global::SR.Format("PaperSize cannot be changed unless the Kind property is set to Custom."));
				}
				_width = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PaperSize" /> class.</summary>
		public PaperSize()
		{
			_kind = PaperKind.Custom;
			_name = string.Empty;
			_createdByDefaultConstructor = true;
		}

		internal PaperSize(PaperKind kind, string name, int width, int height)
		{
			_kind = kind;
			_name = name;
			_width = width;
			_height = height;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PaperSize" /> class.</summary>
		/// <param name="name">The name of the paper.</param>
		/// <param name="width">The width of the paper, in hundredths of an inch.</param>
		/// <param name="height">The height of the paper, in hundredths of an inch.</param>
		public PaperSize(string name, int width, int height)
		{
			_kind = PaperKind.Custom;
			_name = name;
			_width = width;
			_height = height;
		}

		/// <summary>Provides information about the <see cref="T:System.Drawing.Printing.PaperSize" /> in string form.</summary>
		/// <returns>A string.</returns>
		public override string ToString()
		{
			return "[PaperSize " + PaperName + " Kind=" + Kind.ToString() + " Height=" + Height.ToString(CultureInfo.InvariantCulture) + " Width=" + Width.ToString(CultureInfo.InvariantCulture) + "]";
		}
	}
	/// <summary>Specifies the paper tray from which the printer gets paper.</summary>
	[Serializable]
	public class PaperSource
	{
		private string _name;

		private PaperSourceKind _kind;

		/// <summary>Gets the paper source.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Printing.PaperSourceKind" /> values.</returns>
		public PaperSourceKind Kind
		{
			get
			{
				if (_kind >= (PaperSourceKind)256)
				{
					return PaperSourceKind.Custom;
				}
				return _kind;
			}
		}

		/// <summary>Gets or sets the integer representing one of the <see cref="T:System.Drawing.Printing.PaperSourceKind" /> values or a custom value.</summary>
		/// <returns>The integer value representing one of the <see cref="T:System.Drawing.Printing.PaperSourceKind" /> values or a custom value.</returns>
		public int RawKind
		{
			get
			{
				return (int)_kind;
			}
			set
			{
				_kind = (PaperSourceKind)value;
			}
		}

		/// <summary>Gets or sets the name of the paper source.</summary>
		/// <returns>The name of the paper source.</returns>
		public string SourceName
		{
			get
			{
				return _name;
			}
			set
			{
				_name = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PaperSource" /> class.</summary>
		public PaperSource()
		{
			_kind = PaperSourceKind.Custom;
			_name = string.Empty;
		}

		internal PaperSource(PaperSourceKind kind, string name)
		{
			_kind = kind;
			_name = name;
		}

		/// <summary>Provides information about the <see cref="T:System.Drawing.Printing.PaperSource" /> in string form.</summary>
		/// <returns>A string.</returns>
		public override string ToString()
		{
			return "[PaperSource " + SourceName + " Kind=" + Kind.ToString() + "]";
		}
	}
	/// <summary>Standard paper sources.</summary>
	public enum PaperSourceKind
	{
		/// <summary>The upper bin of a printer (or the default bin, if the printer only has one bin).</summary>
		Upper = 1,
		/// <summary>The lower bin of a printer.</summary>
		Lower = 2,
		/// <summary>The middle bin of a printer.</summary>
		Middle = 3,
		/// <summary>Manually fed paper.</summary>
		Manual = 4,
		/// <summary>An envelope.</summary>
		Envelope = 5,
		/// <summary>Manually fed envelope.</summary>
		ManualFeed = 6,
		/// <summary>Automatically fed paper.</summary>
		AutomaticFeed = 7,
		/// <summary>A tractor feed.</summary>
		TractorFeed = 8,
		/// <summary>Small-format paper.</summary>
		SmallFormat = 9,
		/// <summary>Large-format paper.</summary>
		LargeFormat = 10,
		/// <summary>The printer's large-capacity bin.</summary>
		LargeCapacity = 11,
		/// <summary>A paper cassette.</summary>
		Cassette = 14,
		/// <summary>The printer's default input bin.</summary>
		FormSource = 15,
		/// <summary>A printer-specific paper source.</summary>
		Custom = 257
	}
	/// <summary>Specifies print preview information for a single page. This class cannot be inherited.</summary>
	public sealed class PreviewPageInfo
	{
		private Image _image;

		private Size _physicalSize = Size.Empty;

		/// <summary>Gets the image of the printed page.</summary>
		/// <returns>An <see cref="T:System.Drawing.Image" /> representing the printed page.</returns>
		public Image Image => _image;

		/// <summary>Gets the size of the printed page, in hundredths of an inch.</summary>
		/// <returns>A <see cref="T:System.Drawing.Size" /> that specifies the size of the printed page, in hundredths of an inch.</returns>
		public Size PhysicalSize => _physicalSize;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PreviewPageInfo" /> class.</summary>
		/// <param name="image">The image of the printed page.</param>
		/// <param name="physicalSize">The size of the printed page, in hundredths of an inch.</param>
		public PreviewPageInfo(Image image, Size physicalSize)
		{
			_image = image;
			_physicalSize = physicalSize;
		}
	}
	/// <summary>Specifies the type of print operation occurring.</summary>
	public enum PrintAction
	{
		/// <summary>The print operation is printing to a file.</summary>
		PrintToFile,
		/// <summary>The print operation is a print preview.</summary>
		PrintToPreview,
		/// <summary>The print operation is printing to a printer.</summary>
		PrintToPrinter
	}
	/// <summary>Represents the method that will handle the <see cref="E:System.Drawing.Printing.PrintDocument.BeginPrint" /> or <see cref="E:System.Drawing.Printing.PrintDocument.EndPrint" /> event of a <see cref="T:System.Drawing.Printing.PrintDocument" />.</summary>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains the event data.</param>
	public delegate void PrintEventHandler(object sender, PrintEventArgs e);
	/// <summary>Represents the method that will handle the <see cref="E:System.Drawing.Printing.PrintDocument.PrintPage" /> event of a <see cref="T:System.Drawing.Printing.PrintDocument" />.</summary>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains the event data.</param>
	public delegate void PrintPageEventHandler(object sender, PrintPageEventArgs e);
	/// <summary>Specifies the part of the document to print.</summary>
	public enum PrintRange
	{
		/// <summary>All pages are printed.</summary>
		AllPages = 0,
		/// <summary>The pages between <see cref="P:System.Drawing.Printing.PrinterSettings.FromPage" /> and <see cref="P:System.Drawing.Printing.PrinterSettings.ToPage" /> are printed.</summary>
		SomePages = 2,
		/// <summary>The selected pages are printed.</summary>
		Selection = 1,
		/// <summary>The currently displayed page is printed</summary>
		CurrentPage = 4194304
	}
	/// <summary>Represents the resolution supported by a printer.</summary>
	[Serializable]
	public class PrinterResolution
	{
		private int _x;

		private int _y;

		private PrinterResolutionKind _kind;

		/// <summary>Gets or sets the printer resolution.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Printing.PrinterResolutionKind" /> values.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The value assigned is not a member of the <see cref="T:System.Drawing.Printing.PrinterResolutionKind" /> enumeration.</exception>
		public PrinterResolutionKind Kind
		{
			get
			{
				return _kind;
			}
			set
			{
				if (value < PrinterResolutionKind.High || value > PrinterResolutionKind.Custom)
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(PrinterResolutionKind));
				}
				_kind = value;
			}
		}

		/// <summary>Gets the horizontal printer resolution, in dots per inch.</summary>
		/// <returns>The horizontal printer resolution, in dots per inch, if <see cref="P:System.Drawing.Printing.PrinterResolution.Kind" /> is set to <see cref="F:System.Drawing.Printing.PrinterResolutionKind.Custom" />; otherwise, a <see langword="dmPrintQuality" /> value.</returns>
		public int X
		{
			get
			{
				return _x;
			}
			set
			{
				_x = value;
			}
		}

		/// <summary>Gets the vertical printer resolution, in dots per inch.</summary>
		/// <returns>The vertical printer resolution, in dots per inch.</returns>
		public int Y
		{
			get
			{
				return _y;
			}
			set
			{
				_y = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrinterResolution" /> class.</summary>
		public PrinterResolution()
		{
			_kind = PrinterResolutionKind.Custom;
		}

		internal PrinterResolution(PrinterResolutionKind kind, int x, int y)
		{
			_kind = kind;
			_x = x;
			_y = y;
		}

		/// <summary>This member overrides the <see cref="M:System.Object.ToString" /> method.</summary>
		/// <returns>A <see cref="T:System.String" /> that contains information about the <see cref="T:System.Drawing.Printing.PrinterResolution" />.</returns>
		public override string ToString()
		{
			if (_kind != PrinterResolutionKind.Custom)
			{
				return "[PrinterResolution " + Kind.ToString() + "]";
			}
			return "[PrinterResolution X=" + X.ToString(CultureInfo.InvariantCulture) + " Y=" + Y.ToString(CultureInfo.InvariantCulture) + "]";
		}
	}
	/// <summary>Specifies a printer resolution.</summary>
	public enum PrinterResolutionKind
	{
		/// <summary>High resolution.</summary>
		High = -4,
		/// <summary>Medium resolution.</summary>
		Medium,
		/// <summary>Low resolution.</summary>
		Low,
		/// <summary>Draft-quality resolution.</summary>
		Draft,
		/// <summary>Custom resolution.</summary>
		Custom
	}
	/// <summary>Specifies several of the units of measure used for printing.</summary>
	public enum PrinterUnit
	{
		/// <summary>The default unit (0.01 in.).</summary>
		Display,
		/// <summary>One-thousandth of an inch (0.001 in.).</summary>
		ThousandthsOfAnInch,
		/// <summary>One-hundredth of a millimeter (0.01 mm).</summary>
		HundredthsOfAMillimeter,
		/// <summary>One-tenth of a millimeter (0.1 mm).</summary>
		TenthsOfAMillimeter
	}
	/// <summary>Specifies a series of conversion methods that are useful when interoperating with the Win32 printing API. This class cannot be inherited.</summary>
	public sealed class PrinterUnitConvert
	{
		private PrinterUnitConvert()
		{
		}

		/// <summary>Converts a double-precision floating-point number from one <see cref="T:System.Drawing.Printing.PrinterUnit" /> type to another <see cref="T:System.Drawing.Printing.PrinterUnit" /> type.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.Point" /> being converted.</param>
		/// <param name="fromUnit">The unit to convert from.</param>
		/// <param name="toUnit">The unit to convert to.</param>
		/// <returns>A double-precision floating-point number that represents the converted <see cref="T:System.Drawing.Printing.PrinterUnit" />.</returns>
		public static double Convert(double value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			double num = UnitsPerDisplay(fromUnit);
			double num2 = UnitsPerDisplay(toUnit);
			return value * num2 / num;
		}

		/// <summary>Converts a 32-bit signed integer from one <see cref="T:System.Drawing.Printing.PrinterUnit" /> type to another <see cref="T:System.Drawing.Printing.PrinterUnit" /> type.</summary>
		/// <param name="value">The value being converted.</param>
		/// <param name="fromUnit">The unit to convert from.</param>
		/// <param name="toUnit">The unit to convert to.</param>
		/// <returns>A 32-bit signed integer that represents the converted <see cref="T:System.Drawing.Printing.PrinterUnit" />.</returns>
		public static int Convert(int value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			return (int)Math.Round(Convert((double)value, fromUnit, toUnit));
		}

		/// <summary>Converts a <see cref="T:System.Drawing.Point" /> from one <see cref="T:System.Drawing.Printing.PrinterUnit" /> type to another <see cref="T:System.Drawing.Printing.PrinterUnit" /> type.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.Point" /> being converted.</param>
		/// <param name="fromUnit">The unit to convert from.</param>
		/// <param name="toUnit">The unit to convert to.</param>
		/// <returns>A <see cref="T:System.Drawing.Point" /> that represents the converted <see cref="T:System.Drawing.Printing.PrinterUnit" />.</returns>
		public static Point Convert(Point value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			return new Point(Convert(value.X, fromUnit, toUnit), Convert(value.Y, fromUnit, toUnit));
		}

		/// <summary>Converts a <see cref="T:System.Drawing.Size" /> from one <see cref="T:System.Drawing.Printing.PrinterUnit" /> type to another <see cref="T:System.Drawing.Printing.PrinterUnit" /> type.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.Size" /> being converted.</param>
		/// <param name="fromUnit">The unit to convert from.</param>
		/// <param name="toUnit">The unit to convert to.</param>
		/// <returns>A <see cref="T:System.Drawing.Size" /> that represents the converted <see cref="T:System.Drawing.Printing.PrinterUnit" />.</returns>
		public static Size Convert(Size value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			return new Size(Convert(value.Width, fromUnit, toUnit), Convert(value.Height, fromUnit, toUnit));
		}

		/// <summary>Converts a <see cref="T:System.Drawing.Rectangle" /> from one <see cref="T:System.Drawing.Printing.PrinterUnit" /> type to another <see cref="T:System.Drawing.Printing.PrinterUnit" /> type.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.Rectangle" /> being converted.</param>
		/// <param name="fromUnit">The unit to convert from.</param>
		/// <param name="toUnit">The unit to convert to.</param>
		/// <returns>A <see cref="T:System.Drawing.Rectangle" /> that represents the converted <see cref="T:System.Drawing.Printing.PrinterUnit" />.</returns>
		public static Rectangle Convert(Rectangle value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			return new Rectangle(Convert(value.X, fromUnit, toUnit), Convert(value.Y, fromUnit, toUnit), Convert(value.Width, fromUnit, toUnit), Convert(value.Height, fromUnit, toUnit));
		}

		/// <summary>Converts a <see cref="T:System.Drawing.Printing.Margins" /> from one <see cref="T:System.Drawing.Printing.PrinterUnit" /> type to another <see cref="T:System.Drawing.Printing.PrinterUnit" /> type.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.Printing.Margins" /> being converted.</param>
		/// <param name="fromUnit">The unit to convert from.</param>
		/// <param name="toUnit">The unit to convert to.</param>
		/// <returns>A <see cref="T:System.Drawing.Printing.Margins" /> that represents the converted <see cref="T:System.Drawing.Printing.PrinterUnit" />.</returns>
		public static Margins Convert(Margins value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			return new Margins
			{
				DoubleLeft = Convert(value.DoubleLeft, fromUnit, toUnit),
				DoubleRight = Convert(value.DoubleRight, fromUnit, toUnit),
				DoubleTop = Convert(value.DoubleTop, fromUnit, toUnit),
				DoubleBottom = Convert(value.DoubleBottom, fromUnit, toUnit)
			};
		}

		private static double UnitsPerDisplay(PrinterUnit unit)
		{
			return unit switch
			{
				PrinterUnit.Display => 1.0, 
				PrinterUnit.ThousandthsOfAnInch => 10.0, 
				PrinterUnit.HundredthsOfAMillimeter => 25.4, 
				PrinterUnit.TenthsOfAMillimeter => 2.54, 
				_ => 1.0, 
			};
		}
	}
	/// <summary>Controls access to printers. This class cannot be inherited.</summary>
	[Serializable]
	public sealed class PrintingPermission : CodeAccessPermission, IUnrestrictedPermission
	{
		private PrintingPermissionLevel printingLevel;

		/// <summary>Gets or sets the code's level of printing access.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Printing.PrintingPermissionLevel" /> values.</returns>
		public PrintingPermissionLevel Level
		{
			get
			{
				return printingLevel;
			}
			set
			{
				VerifyPrintingLevel(value);
				printingLevel = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrintingPermission" /> class with either fully restricted or unrestricted access, as specified.</summary>
		/// <param name="state">One of the <see cref="T:System.Security.Permissions.PermissionState" /> values.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="state" /> is not a valid <see cref="T:System.Security.Permissions.PermissionState" />.</exception>
		public PrintingPermission(PermissionState state)
		{
			switch (state)
			{
			case PermissionState.Unrestricted:
				printingLevel = PrintingPermissionLevel.AllPrinting;
				break;
			case PermissionState.None:
				printingLevel = PrintingPermissionLevel.NoPrinting;
				break;
			default:
				throw new ArgumentException(global::SR.Format("Permission state is not valid."));
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrintingPermission" /> class with the level of printing access specified.</summary>
		/// <param name="printingLevel">One of the <see cref="T:System.Drawing.Printing.PrintingPermissionLevel" /> values.</param>
		public PrintingPermission(PrintingPermissionLevel printingLevel)
		{
			VerifyPrintingLevel(printingLevel);
			this.printingLevel = printingLevel;
		}

		private static void VerifyPrintingLevel(PrintingPermissionLevel level)
		{
			if (level < PrintingPermissionLevel.NoPrinting || level > PrintingPermissionLevel.AllPrinting)
			{
				throw new ArgumentException(global::SR.Format("Permission level is not valid."));
			}
		}

		/// <summary>Gets a value indicating whether the permission is unrestricted.</summary>
		/// <returns>
		///   <see langword="true" /> if permission is unrestricted; otherwise, <see langword="false" />.</returns>
		public bool IsUnrestricted()
		{
			return printingLevel == PrintingPermissionLevel.AllPrinting;
		}

		/// <summary>Determines whether the current permission object is a subset of the specified permission.</summary>
		/// <param name="target">A permission object that is to be tested for the subset relationship. This object must be of the same type as the current permission object.</param>
		/// <returns>
		///   <see langword="true" /> if the current permission object is a subset of <paramref name="target" />; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="target" /> is an object that is not of the same type as the current permission object.</exception>
		public override bool IsSubsetOf(IPermission target)
		{
			if (target == null)
			{
				return printingLevel == PrintingPermissionLevel.NoPrinting;
			}
			if (!(target is PrintingPermission printingPermission))
			{
				throw new ArgumentException(global::SR.Format("Target does not have permission to print."));
			}
			return printingLevel <= printingPermission.printingLevel;
		}

		/// <summary>Creates and returns a permission that is the intersection of the current permission object and a target permission object.</summary>
		/// <param name="target">A permission object of the same type as the current permission object.</param>
		/// <returns>A new permission object that represents the intersection of the current object and the specified target. This object is <see langword="null" /> if the intersection is empty.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="target" /> is an object that is not of the same type as the current permission object.</exception>
		public override IPermission Intersect(IPermission target)
		{
			if (target == null)
			{
				return null;
			}
			if (!(target is PrintingPermission printingPermission))
			{
				throw new ArgumentException(global::SR.Format("Target does not have permission to print."));
			}
			PrintingPermissionLevel printingPermissionLevel = ((printingLevel < printingPermission.printingLevel) ? printingLevel : printingPermission.printingLevel);
			if (printingPermissionLevel == PrintingPermissionLevel.NoPrinting)
			{
				return null;
			}
			return new PrintingPermission(printingPermissionLevel);
		}

		/// <summary>Creates a permission that combines the permission object and the target permission object.</summary>
		/// <param name="target">A permission object of the same type as the current permission object.</param>
		/// <returns>A new permission object that represents the union of the current permission object and the specified permission object.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="target" /> is an object that is not of the same type as the current permission object.</exception>
		public override IPermission Union(IPermission target)
		{
			if (target == null)
			{
				return Copy();
			}
			if (!(target is PrintingPermission printingPermission))
			{
				throw new ArgumentException(global::SR.Format("Target does not have permission to print."));
			}
			PrintingPermissionLevel printingPermissionLevel = ((printingLevel > printingPermission.printingLevel) ? printingLevel : printingPermission.printingLevel);
			if (printingPermissionLevel == PrintingPermissionLevel.NoPrinting)
			{
				return null;
			}
			return new PrintingPermission(printingPermissionLevel);
		}

		/// <summary>Creates and returns an identical copy of the current permission object.</summary>
		/// <returns>A copy of the current permission object.</returns>
		public override IPermission Copy()
		{
			return new PrintingPermission(printingLevel);
		}

		/// <summary>Creates an XML encoding of the security object and its current state.</summary>
		/// <returns>An XML encoding of the security object, including any state information.</returns>
		public override SecurityElement ToXml()
		{
			SecurityElement securityElement = new SecurityElement("IPermission");
			securityElement.AddAttribute("class", GetType().FullName + ", " + ((MemberInfo)GetType()).Module.Assembly.FullName.Replace('"', '\''));
			securityElement.AddAttribute("version", "1");
			if (!IsUnrestricted())
			{
				securityElement.AddAttribute("Level", Enum.GetName(typeof(PrintingPermissionLevel), printingLevel));
			}
			else
			{
				securityElement.AddAttribute("Unrestricted", "true");
			}
			return securityElement;
		}

		/// <summary>Reconstructs a security object with a specified state from an XML encoding.</summary>
		/// <param name="esd">The XML encoding to use to reconstruct the security object.</param>
		public override void FromXml(SecurityElement esd)
		{
			if (esd == null)
			{
				throw new ArgumentNullException("esd");
			}
			string text = esd.Attribute("class");
			if (text == null || text.IndexOf(GetType().FullName) == -1)
			{
				throw new ArgumentException(global::SR.Format("Class name is not valid."));
			}
			string text2 = esd.Attribute("Unrestricted");
			if (text2 != null && string.Equals(text2, "true", StringComparison.OrdinalIgnoreCase))
			{
				printingLevel = PrintingPermissionLevel.AllPrinting;
				return;
			}
			printingLevel = PrintingPermissionLevel.NoPrinting;
			string text3 = esd.Attribute("Level");
			if (text3 != null)
			{
				printingLevel = (PrintingPermissionLevel)Enum.Parse(typeof(PrintingPermissionLevel), text3);
			}
		}
	}
	/// <summary>Allows declarative printing permission checks.</summary>
	[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
	public sealed class PrintingPermissionAttribute : CodeAccessSecurityAttribute
	{
		private PrintingPermissionLevel level;

		/// <summary>Gets or sets the type of printing allowed.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Printing.PrintingPermissionLevel" /> values.</returns>
		/// <exception cref="T:System.ArgumentException">The value is not one of the <see cref="T:System.Drawing.Printing.PrintingPermissionLevel" /> values.</exception>
		public PrintingPermissionLevel Level
		{
			get
			{
				return level;
			}
			set
			{
				if (value < PrintingPermissionLevel.NoPrinting || value > PrintingPermissionLevel.AllPrinting)
				{
					throw new ArgumentException(global::SR.Format("Permission level must be between PrintingPermissionLevel.NoPrinting and PrintingPermissionLevel.AllPrinting."), "value");
				}
				level = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrintingPermissionAttribute" /> class.</summary>
		/// <param name="action">One of the <see cref="T:System.Security.Permissions.SecurityAction" /> values.</param>
		public PrintingPermissionAttribute(SecurityAction action)
			: base(action)
		{
		}

		/// <summary>Creates the permission based on the requested access levels, which are set through the <see cref="P:System.Drawing.Printing.PrintingPermissionAttribute.Level" /> property on the attribute.</summary>
		/// <returns>An <see cref="T:System.Security.IPermission" /> that represents the created permission.</returns>
		public override IPermission CreatePermission()
		{
			if (base.Unrestricted)
			{
				return new PrintingPermission(PermissionState.Unrestricted);
			}
			return new PrintingPermission(level);
		}
	}
	/// <summary>Specifies the type of printing that code is allowed to do.</summary>
	[Serializable]
	public enum PrintingPermissionLevel
	{
		/// <summary>Prevents access to printers. <see cref="F:System.Drawing.Printing.PrintingPermissionLevel.NoPrinting" /> is a subset of <see cref="F:System.Drawing.Printing.PrintingPermissionLevel.SafePrinting" />.</summary>
		NoPrinting,
		/// <summary>Provides printing only from a restricted dialog box. <see cref="F:System.Drawing.Printing.PrintingPermissionLevel.SafePrinting" /> is a subset of <see cref="F:System.Drawing.Printing.PrintingPermissionLevel.DefaultPrinting" />.</summary>
		SafePrinting,
		/// <summary>Provides printing programmatically to the default printer, along with safe printing through semirestricted dialog box. <see cref="F:System.Drawing.Printing.PrintingPermissionLevel.DefaultPrinting" /> is a subset of <see cref="F:System.Drawing.Printing.PrintingPermissionLevel.AllPrinting" />.</summary>
		DefaultPrinting,
		/// <summary>Provides full access to all printers.</summary>
		AllPrinting
	}
	/// <summary>Provides data for the <see cref="E:System.Drawing.Printing.PrintDocument.QueryPageSettings" /> event.</summary>
	public class QueryPageSettingsEventArgs : PrintEventArgs
	{
		private PageSettings _pageSettings;

		internal bool PageSettingsChanged;

		/// <summary>Gets or sets the page settings for the page to be printed.</summary>
		/// <returns>The page settings for the page to be printed.</returns>
		public PageSettings PageSettings
		{
			get
			{
				PageSettingsChanged = true;
				return _pageSettings;
			}
			set
			{
				if (value == null)
				{
					value = new PageSettings();
				}
				_pageSettings = value;
				PageSettingsChanged = true;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.QueryPageSettingsEventArgs" /> class.</summary>
		/// <param name="pageSettings">The page settings for the page to be printed.</param>
		public QueryPageSettingsEventArgs(PageSettings pageSettings)
		{
			_pageSettings = pageSettings;
		}
	}
	/// <summary>Represents the method that handles the <see cref="E:System.Drawing.Printing.PrintDocument.QueryPageSettings" /> event of a <see cref="T:System.Drawing.Printing.PrintDocument" />.</summary>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">A <see cref="T:System.Drawing.Printing.QueryPageSettingsEventArgs" /> that contains the event data.</param>
	public delegate void QueryPageSettingsEventHandler(object sender, QueryPageSettingsEventArgs e);
	/// <summary>Provides a <see cref="T:System.Drawing.Printing.MarginsConverter" /> for <see cref="T:System.Drawing.Printing.Margins" />.</summary>
	public class MarginsConverter : ExpandableObjectConverter
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.MarginsConverter" /> class.</summary>
		public MarginsConverter()
		{
		}

		/// <summary>Returns whether this converter can convert an object of the specified source type to the native type of the converter using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="sourceType">A <see cref="T:System.Type" /> that represents the type from which you want to convert.</param>
		/// <returns>
		///   <see langword="true" /> if an object can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Returns whether this converter can convert an object to the given destination type using the context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> that represents the type to which you want to convert.</param>
		/// <returns>
		///   <see langword="true" /> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(string))
			{
				return true;
			}
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts the specified object to the converter's native type.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> that provides the language to convert to.</param>
		/// <param name="value">The <see cref="T:System.Object" /> to convert.</param>
		/// <returns>An <see cref="T:System.Object" /> that represents the converted value.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="value" /> does not contain values for all four margins. For example, "100,100,100,100" specifies 1 inch for the left, right, top, and bottom margins.</exception>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be performed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string)
			{
				if (value == null)
				{
					return new Margins();
				}
				string text = "( |\\t)*";
				text = text + ";" + text;
				Match match = new Regex("(?<left>\\d+)" + text + "(?<right>\\d+)" + text + "(?<top>\\d+)" + text + "(?<bottom>\\d+)").Match(value as string);
				if (!match.Success)
				{
					throw new ArgumentException("value");
				}
				int left;
				int right;
				int top;
				int bottom;
				try
				{
					left = int.Parse(match.Groups["left"].Value);
					right = int.Parse(match.Groups["right"].Value);
					top = int.Parse(match.Groups["top"].Value);
					bottom = int.Parse(match.Groups["bottom"].Value);
				}
				catch (Exception innerException)
				{
					throw new ArgumentException("value", innerException);
				}
				return new Margins(left, right, top, bottom);
			}
			return base.ConvertFrom(context, culture, value);
		}

		/// <summary>Converts the given value object to the specified destination type using the specified context and arguments.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> that provides the language to convert to.</param>
		/// <param name="value">The <see cref="T:System.Object" /> to convert.</param>
		/// <param name="destinationType">The <see cref="T:System.Type" /> to which to convert the value.</param>
		/// <returns>An <see cref="T:System.Object" /> that represents the converted value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="destinationType" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be performed.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == typeof(string) && value is Margins)
			{
				Margins margins = value as Margins;
				return $"{margins.Left}; {margins.Right}; {margins.Top}; {margins.Bottom}";
			}
			if (destinationType == typeof(InstanceDescriptor) && value is Margins)
			{
				Margins margins2 = (Margins)value;
				return new InstanceDescriptor(typeof(Margins).GetTypeInfo().GetConstructor(new Type[4]
				{
					typeof(int),
					typeof(int),
					typeof(int),
					typeof(int)
				}), new object[4] { margins2.Left, margins2.Right, margins2.Top, margins2.Bottom });
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <summary>Returns whether changing a value on this object requires a call to the <see cref="M:System.Drawing.Printing.MarginsConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> method to create a new value, using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <returns>
		///   <see langword="true" /> if changing a property on this object requires a call to <see cref="M:System.Drawing.Printing.MarginsConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> to create a new value; otherwise, <see langword="false" />. This method always returns <see langword="true" />.</returns>
		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Creates an <see cref="T:System.Object" /> given a set of property values for the object.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="propertyValues">An <see cref="T:System.Collections.IDictionary" /> of new property values.</param>
		/// <returns>An <see cref="T:System.Object" /> representing the specified <see cref="T:System.Collections.IDictionary" />, or <see langword="null" /> if the object cannot be created.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="propertyValues" /> is <see langword="null" />.</exception>
		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			try
			{
				return new Margins
				{
					Left = int.Parse(propertyValues["Left"].ToString()),
					Right = int.Parse(propertyValues["Right"].ToString()),
					Top = int.Parse(propertyValues["Top"].ToString()),
					Bottom = int.Parse(propertyValues["Bottom"].ToString())
				};
			}
			catch (Exception)
			{
				return null;
			}
		}
	}
	/// <summary>Specifies settings that apply to a single, printed page.</summary>
	[Serializable]
	public class PageSettings : ICloneable
	{
		internal bool color;

		internal bool landscape;

		internal PaperSize paperSize;

		internal PaperSource paperSource;

		internal PrinterResolution printerResolution;

		private Margins margins = new Margins();

		private float hardMarginX;

		private float hardMarginY;

		private RectangleF printableArea;

		private PrinterSettings printerSettings;

		/// <summary>Gets the size of the page, taking into account the page orientation specified by the <see cref="P:System.Drawing.Printing.PageSettings.Landscape" /> property.</summary>
		/// <returns>A <see cref="T:System.Drawing.Rectangle" /> that represents the length and width, in hundredths of an inch, of the page.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		public Rectangle Bounds
		{
			get
			{
				int width = paperSize.Width;
				int height = paperSize.Height;
				width -= margins.Left + margins.Right;
				height -= margins.Top + margins.Bottom;
				if (landscape)
				{
					int num = width;
					width = height;
					height = num;
				}
				return new Rectangle(margins.Left, margins.Top, width, height);
			}
		}

		/// <summary>Gets or sets a value indicating whether the page should be printed in color.</summary>
		/// <returns>
		///   <see langword="true" /> if the page should be printed in color; otherwise, <see langword="false" />. The default is determined by the printer.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		public bool Color
		{
			get
			{
				if (!printerSettings.IsValid)
				{
					throw new InvalidPrinterException(printerSettings);
				}
				return color;
			}
			set
			{
				color = value;
			}
		}

		/// <summary>Gets or sets a value indicating whether the page is printed in landscape or portrait orientation.</summary>
		/// <returns>
		///   <see langword="true" /> if the page should be printed in landscape orientation; otherwise, <see langword="false" />. The default is determined by the printer.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		public bool Landscape
		{
			get
			{
				if (!printerSettings.IsValid)
				{
					throw new InvalidPrinterException(printerSettings);
				}
				return landscape;
			}
			set
			{
				landscape = value;
			}
		}

		/// <summary>Gets or sets the margins for this page.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.Margins" /> that represents the margins, in hundredths of an inch, for the page. The default is 1-inch margins on all sides.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		public Margins Margins
		{
			get
			{
				if (!printerSettings.IsValid)
				{
					throw new InvalidPrinterException(printerSettings);
				}
				return margins;
			}
			set
			{
				margins = value;
			}
		}

		/// <summary>Gets or sets the paper size for the page.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PaperSize" /> that represents the size of the paper. The default is the printer's default paper size.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist or there is no default printer installed.</exception>
		public PaperSize PaperSize
		{
			get
			{
				if (!printerSettings.IsValid)
				{
					throw new InvalidPrinterException(printerSettings);
				}
				return paperSize;
			}
			set
			{
				if (value != null)
				{
					paperSize = value;
				}
			}
		}

		/// <summary>Gets or sets the page's paper source; for example, the printer's upper tray.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PaperSource" /> that specifies the source of the paper. The default is the printer's default paper source.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist or there is no default printer installed.</exception>
		public PaperSource PaperSource
		{
			get
			{
				if (!printerSettings.IsValid)
				{
					throw new InvalidPrinterException(printerSettings);
				}
				return paperSource;
			}
			set
			{
				if (value != null)
				{
					paperSource = value;
				}
			}
		}

		/// <summary>Gets or sets the printer resolution for the page.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PrinterResolution" /> that specifies the printer resolution for the page. The default is the printer's default resolution.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist or there is no default printer installed.</exception>
		public PrinterResolution PrinterResolution
		{
			get
			{
				if (!printerSettings.IsValid)
				{
					throw new InvalidPrinterException(printerSettings);
				}
				return printerResolution;
			}
			set
			{
				if (value != null)
				{
					printerResolution = value;
				}
			}
		}

		/// <summary>Gets or sets the printer settings associated with the page.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PrinterSettings" /> that represents the printer settings associated with the page.</returns>
		public PrinterSettings PrinterSettings
		{
			get
			{
				return printerSettings;
			}
			set
			{
				printerSettings = value;
			}
		}

		/// <summary>Gets the x-coordinate, in hundredths of an inch, of the hard margin at the left of the page.</summary>
		/// <returns>The x-coordinate, in hundredths of an inch, of the left-hand hard margin.</returns>
		public float HardMarginX => hardMarginX;

		/// <summary>Gets the y-coordinate, in hundredths of an inch, of the hard margin at the top of the page.</summary>
		/// <returns>The y-coordinate, in hundredths of an inch, of the hard margin at the top of the page.</returns>
		public float HardMarginY => hardMarginY;

		/// <summary>Gets the bounds of the printable area of the page for the printer.</summary>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> representing the length and width, in hundredths of an inch, of the area the printer is capable of printing in.</returns>
		public RectangleF PrintableArea => printableArea;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PageSettings" /> class using the default printer.</summary>
		public PageSettings()
			: this(new PrinterSettings())
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PageSettings" /> class using a specified printer.</summary>
		/// <param name="printerSettings">The <see cref="T:System.Drawing.Printing.PrinterSettings" /> that describes the printer to use.</param>
		public PageSettings(PrinterSettings printerSettings)
		{
			PrinterSettings = printerSettings;
			color = printerSettings.DefaultPageSettings.color;
			landscape = printerSettings.DefaultPageSettings.landscape;
			paperSize = printerSettings.DefaultPageSettings.paperSize;
			paperSource = printerSettings.DefaultPageSettings.paperSource;
			printerResolution = printerSettings.DefaultPageSettings.printerResolution;
		}

		internal PageSettings(PrinterSettings printerSettings, bool color, bool landscape, PaperSize paperSize, PaperSource paperSource, PrinterResolution printerResolution)
		{
			PrinterSettings = printerSettings;
			this.color = color;
			this.landscape = landscape;
			this.paperSize = paperSize;
			this.paperSource = paperSource;
			this.printerResolution = printerResolution;
		}

		/// <summary>Creates a copy of this <see cref="T:System.Drawing.Printing.PageSettings" />.</summary>
		/// <returns>A copy of this object.</returns>
		public object Clone()
		{
			PrinterResolution printerResolution = new PrinterResolution(this.printerResolution.Kind, this.printerResolution.X, this.printerResolution.Y);
			PaperSource paperSource = new PaperSource(this.paperSource.Kind, this.paperSource.SourceName);
			PaperSize paperSize = new PaperSize(this.paperSize.PaperName, this.paperSize.Width, this.paperSize.Height);
			paperSize.RawKind = (int)this.paperSize.Kind;
			return new PageSettings(printerSettings, color, landscape, paperSize, paperSource, printerResolution)
			{
				Margins = (Margins)margins.Clone()
			};
		}

		/// <summary>Copies the relevant information from the <see cref="T:System.Drawing.Printing.PageSettings" /> to the specified <see langword="DEVMODE" /> structure.</summary>
		/// <param name="hdevmode">The handle to a Win32 <see langword="DEVMODE" /> structure.</param>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist or there is no default printer installed.</exception>
		[System.MonoTODO("PageSettings.CopyToHdevmode")]
		public void CopyToHdevmode(IntPtr hdevmode)
		{
			throw new NotImplementedException();
		}

		/// <summary>Copies relevant information to the <see cref="T:System.Drawing.Printing.PageSettings" /> from the specified <see langword="DEVMODE" /> structure.</summary>
		/// <param name="hdevmode">The handle to a Win32 <see langword="DEVMODE" /> structure.</param>
		/// <exception cref="T:System.ArgumentException">The printer handle is not valid.</exception>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist or there is no default printer installed.</exception>
		[System.MonoTODO("PageSettings.SetHdevmode")]
		public void SetHdevmode(IntPtr hdevmode)
		{
			throw new NotImplementedException();
		}

		/// <summary>Converts the <see cref="T:System.Drawing.Printing.PageSettings" /> to string form.</summary>
		/// <returns>A string showing the various property settings for the <see cref="T:System.Drawing.Printing.PageSettings" />.</returns>
		public override string ToString()
		{
			return string.Format(string.Concat(string.Concat(string.Concat(string.Concat(string.Concat("[PageSettings: Color={0}" + ", Landscape={1}", ", Margins={2}"), ", PaperSize={3}"), ", PaperSource={4}"), ", PrinterResolution={5}"), "]"), color, landscape, margins, paperSize, paperSource, printerResolution);
		}
	}
	/// <summary>Specifies a print controller that displays a document on a screen as a series of images.</summary>
	public class PreviewPrintController : PrintController
	{
		private bool useantialias;

		private ArrayList pageInfoList;

		/// <summary>Gets a value indicating whether this controller is used for print preview.</summary>
		/// <returns>
		///   <see langword="true" /> in all cases.</returns>
		public override bool IsPreview => true;

		/// <summary>Gets or sets a value indicating whether to use anti-aliasing when displaying the print preview.</summary>
		/// <returns>
		///   <see langword="true" /> if the print preview uses anti-aliasing; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
		public virtual bool UseAntiAlias
		{
			get
			{
				return useantialias;
			}
			set
			{
				useantialias = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PreviewPrintController" /> class.</summary>
		public PreviewPrintController()
		{
			pageInfoList = new ArrayList();
		}

		/// <summary>Completes the control sequence that determines when and how to preview a page in a print document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being previewed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains data about how to preview a page in the print document.</param>
		[System.MonoTODO]
		public override void OnEndPage(PrintDocument document, PrintPageEventArgs e)
		{
		}

		/// <summary>Begins the control sequence that determines when and how to preview a print document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being previewed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains data about how to print the document.</param>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		[System.MonoTODO]
		public override void OnStartPrint(PrintDocument document, PrintEventArgs e)
		{
			if (!document.PrinterSettings.IsValid)
			{
				throw new InvalidPrinterException(document.PrinterSettings);
			}
			foreach (PreviewPageInfo pageInfo in pageInfoList)
			{
				pageInfo.Image.Dispose();
			}
			pageInfoList.Clear();
		}

		/// <summary>Completes the control sequence that determines when and how to preview a print document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being previewed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains data about how to preview the print document.</param>
		[System.MonoTODO]
		public override void OnEndPrint(PrintDocument document, PrintEventArgs e)
		{
		}

		/// <summary>Begins the control sequence that determines when and how to preview a page in a print document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being previewed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains data about how to preview a page in the print document. Initially, the <see cref="P:System.Drawing.Printing.PrintPageEventArgs.Graphics" /> property of this parameter will be <see langword="null" />. The value returned from this method will be used to set this property.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> that represents a page from a <see cref="T:System.Drawing.Printing.PrintDocument" />.</returns>
		[System.MonoTODO]
		public override Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e)
		{
			Image image = new Bitmap(e.PageSettings.PaperSize.Width, e.PageSettings.PaperSize.Height);
			PreviewPageInfo previewPageInfo = new PreviewPageInfo(image, new Size(e.PageSettings.PaperSize.Width, e.PageSettings.PaperSize.Height));
			pageInfoList.Add(previewPageInfo);
			Graphics graphics = Graphics.FromImage(previewPageInfo.Image);
			graphics.FillRectangle(new SolidBrush(Color.White), new Rectangle(new Point(0, 0), new Size(image.Width, image.Height)));
			return graphics;
		}

		/// <summary>Captures the pages of a document as a series of images.</summary>
		/// <returns>An array of type <see cref="T:System.Drawing.Printing.PreviewPageInfo" /> that contains the pages of a <see cref="T:System.Drawing.Printing.PrintDocument" /> as a series of images.</returns>
		public PreviewPageInfo[] GetPreviewPageInfo()
		{
			PreviewPageInfo[] array = new PreviewPageInfo[pageInfoList.Count];
			pageInfoList.CopyTo(array);
			return array;
		}
	}
	/// <summary>Controls how a document is printed, when printing from a Windows Forms application.</summary>
	public abstract class PrintController
	{
		/// <summary>Gets a value indicating whether the <see cref="T:System.Drawing.Printing.PrintController" /> is used for print preview.</summary>
		/// <returns>
		///   <see langword="false" /> in all cases.</returns>
		public virtual bool IsPreview => false;

		/// <summary>When overridden in a derived class, completes the control sequence that determines when and how to print a page of a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document currently being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains the event data.</param>
		public virtual void OnEndPage(PrintDocument document, PrintPageEventArgs e)
		{
		}

		/// <summary>When overridden in a derived class, begins the control sequence that determines when and how to print a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document currently being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains the event data.</param>
		public virtual void OnStartPrint(PrintDocument document, PrintEventArgs e)
		{
		}

		/// <summary>When overridden in a derived class, completes the control sequence that determines when and how to print a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document currently being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains the event data.</param>
		public virtual void OnEndPrint(PrintDocument document, PrintEventArgs e)
		{
		}

		/// <summary>When overridden in a derived class, begins the control sequence that determines when and how to print a page of a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document currently being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains the event data.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> that represents a page from a <see cref="T:System.Drawing.Printing.PrintDocument" />.</returns>
		public virtual Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e)
		{
			return null;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrintController" /> class.</summary>
		protected PrintController()
		{
		}
	}
	/// <summary>Defines a reusable object that sends output to a printer, when printing from a Windows Forms application.</summary>
	[DefaultEvent("PrintPage")]
	[DefaultProperty("DocumentName")]
	[ToolboxItemFilter("System.Drawing.Printing", ToolboxItemFilterType.Allow)]
	public class PrintDocument : Component
	{
		private PageSettings defaultpagesettings;

		private PrinterSettings printersettings;

		private PrintController printcontroller;

		private string documentname;

		private bool originAtMargins;

		/// <summary>Gets or sets page settings that are used as defaults for all pages to be printed.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PageSettings" /> that specifies the default page settings for the document.</returns>
		[SRDescription("The settings for the current page.")]
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public PageSettings DefaultPageSettings
		{
			get
			{
				return defaultpagesettings;
			}
			set
			{
				defaultpagesettings = value;
			}
		}

		/// <summary>Gets or sets the document name to display (for example, in a print status dialog box or printer queue) while printing the document.</summary>
		/// <returns>The document name to display while printing the document. The default is "document".</returns>
		[SRDescription("The name of the document.")]
		[DefaultValue("document")]
		public string DocumentName
		{
			get
			{
				return documentname;
			}
			set
			{
				documentname = value;
			}
		}

		/// <summary>Gets or sets the print controller that guides the printing process.</summary>
		/// <returns>The <see cref="T:System.Drawing.Printing.PrintController" /> that guides the printing process. The default is a new instance of the <see cref="T:System.Windows.Forms.PrintControllerWithStatusDialog" /> class.</returns>
		[SRDescription("The print controller object.")]
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public PrintController PrintController
		{
			get
			{
				return printcontroller;
			}
			set
			{
				printcontroller = value;
			}
		}

		/// <summary>Gets or sets the printer that prints the document.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PrinterSettings" /> that specifies where and how the document is printed. The default is a <see cref="T:System.Drawing.Printing.PrinterSettings" /> with its properties set to their default values.</returns>
		[Browsable(false)]
		[SRDescription("The current settings for the active printer.")]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public PrinterSettings PrinterSettings
		{
			get
			{
				return printersettings;
			}
			set
			{
				printersettings = ((value == null) ? new PrinterSettings() : value);
			}
		}

		/// <summary>Gets or sets a value indicating whether the position of a graphics object associated with a page is located just inside the user-specified margins or at the top-left corner of the printable area of the page.</summary>
		/// <returns>
		///   <see langword="true" /> if the graphics origin starts at the page margins; <see langword="false" /> if the graphics origin is at the top-left corner of the printable page. The default is <see langword="false" />.</returns>
		[DefaultValue(false)]
		[SRDescription("Determines if the origin is set at the specified margins.")]
		public bool OriginAtMargins
		{
			get
			{
				return originAtMargins;
			}
			set
			{
				originAtMargins = value;
			}
		}

		/// <summary>Occurs when the <see cref="M:System.Drawing.Printing.PrintDocument.Print" /> method is called and before the first page of the document prints.</summary>
		[SRDescription("Raised when printing begins")]
		public event PrintEventHandler BeginPrint;

		/// <summary>Occurs when the last page of the document has printed.</summary>
		[SRDescription("Raised when printing ends")]
		public event PrintEventHandler EndPrint;

		/// <summary>Occurs when the output to print for the current page is needed.</summary>
		[SRDescription("Raised when printing of a new page begins")]
		public event PrintPageEventHandler PrintPage;

		/// <summary>Occurs immediately before each <see cref="E:System.Drawing.Printing.PrintDocument.PrintPage" /> event.</summary>
		[SRDescription("Raised before printing of a new page begins")]
		public event QueryPageSettingsEventHandler QueryPageSettings;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrintDocument" /> class.</summary>
		public PrintDocument()
		{
			documentname = "document";
			printersettings = new PrinterSettings();
			defaultpagesettings = (PageSettings)printersettings.DefaultPageSettings.Clone();
			printcontroller = new StandardPrintController();
		}

		/// <summary>Starts the document's printing process.</summary>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		public void Print()
		{
			PrintEventArgs e = new PrintEventArgs();
			OnBeginPrint(e);
			if (e.Cancel)
			{
				return;
			}
			PrintController.OnStartPrint(this, e);
			if (e.Cancel)
			{
				return;
			}
			Graphics graphics = null;
			if (e.GraphicsContext != null)
			{
				graphics = Graphics.FromHdc(e.GraphicsContext.Hdc);
				e.GraphicsContext.Graphics = graphics;
			}
			PrintPageEventArgs e3;
			do
			{
				QueryPageSettingsEventArgs e2 = new QueryPageSettingsEventArgs(DefaultPageSettings.Clone() as PageSettings);
				OnQueryPageSettings(e2);
				PageSettings pageSettings = e2.PageSettings;
				e3 = new PrintPageEventArgs(graphics, pageSettings.Bounds, new Rectangle(0, 0, pageSettings.PaperSize.Width, pageSettings.PaperSize.Height), pageSettings);
				e3.GraphicsContext = e.GraphicsContext;
				Graphics graphics2 = PrintController.OnStartPage(this, e3);
				e3.SetGraphics(graphics2);
				if (!e3.Cancel)
				{
					OnPrintPage(e3);
				}
				PrintController.OnEndPage(this, e3);
			}
			while (!e3.Cancel && e3.HasMorePages);
			OnEndPrint(e);
			PrintController.OnEndPrint(this, e);
		}

		/// <summary>Provides information about the print document, in string form.</summary>
		/// <returns>A string.</returns>
		public override string ToString()
		{
			return "[PrintDocument " + DocumentName + "]";
		}

		/// <summary>Raises the <see cref="E:System.Drawing.Printing.PrintDocument.BeginPrint" /> event. It is called after the <see cref="M:System.Drawing.Printing.PrintDocument.Print" /> method is called and before the first page of the document prints.</summary>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains the event data.</param>
		protected virtual void OnBeginPrint(PrintEventArgs e)
		{
			if (this.BeginPrint != null)
			{
				this.BeginPrint(this, e);
			}
		}

		/// <summary>Raises the <see cref="E:System.Drawing.Printing.PrintDocument.EndPrint" /> event. It is called when the last page of the document has printed.</summary>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains the event data.</param>
		protected virtual void OnEndPrint(PrintEventArgs e)
		{
			if (this.EndPrint != null)
			{
				this.EndPrint(this, e);
			}
		}

		/// <summary>Raises the <see cref="E:System.Drawing.Printing.PrintDocument.PrintPage" /> event. It is called before a page prints.</summary>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains the event data.</param>
		protected virtual void OnPrintPage(PrintPageEventArgs e)
		{
			if (this.PrintPage != null)
			{
				this.PrintPage(this, e);
			}
		}

		/// <summary>Raises the <see cref="E:System.Drawing.Printing.PrintDocument.QueryPageSettings" /> event. It is called immediately before each <see cref="E:System.Drawing.Printing.PrintDocument.PrintPage" /> event.</summary>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.QueryPageSettingsEventArgs" /> that contains the event data.</param>
		protected virtual void OnQueryPageSettings(QueryPageSettingsEventArgs e)
		{
			if (this.QueryPageSettings != null)
			{
				this.QueryPageSettings(this, e);
			}
		}
	}
	/// <summary>Provides data for the <see cref="E:System.Drawing.Printing.PrintDocument.BeginPrint" /> and <see cref="E:System.Drawing.Printing.PrintDocument.EndPrint" /> events.</summary>
	public class PrintEventArgs : CancelEventArgs
	{
		private GraphicsPrinter graphics_context;

		private PrintAction action;

		/// <summary>Returns <see cref="F:System.Drawing.Printing.PrintAction.PrintToFile" /> in all cases.</summary>
		/// <returns>
		///   <see cref="F:System.Drawing.Printing.PrintAction.PrintToFile" /> in all cases.</returns>
		public PrintAction PrintAction => action;

		internal GraphicsPrinter GraphicsContext
		{
			get
			{
				return graphics_context;
			}
			set
			{
				graphics_context = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrintEventArgs" /> class.</summary>
		public PrintEventArgs()
		{
		}

		internal PrintEventArgs(PrintAction action)
		{
			this.action = action;
		}
	}
	/// <summary>Provides data for the <see cref="E:System.Drawing.Printing.PrintDocument.PrintPage" /> event.</summary>
	public class PrintPageEventArgs : EventArgs
	{
		private bool cancel;

		private Graphics graphics;

		private bool hasmorePages;

		private Rectangle marginBounds;

		private Rectangle pageBounds;

		private PageSettings pageSettings;

		private GraphicsPrinter graphics_context;

		/// <summary>Gets or sets a value indicating whether the print job should be canceled.</summary>
		/// <returns>
		///   <see langword="true" /> if the print job should be canceled; otherwise, <see langword="false" />.</returns>
		public bool Cancel
		{
			get
			{
				return cancel;
			}
			set
			{
				cancel = value;
			}
		}

		/// <summary>Gets the <see cref="T:System.Drawing.Graphics" /> used to paint the page.</summary>
		/// <returns>The <see cref="T:System.Drawing.Graphics" /> used to paint the page.</returns>
		public Graphics Graphics => graphics;

		/// <summary>Gets or sets a value indicating whether an additional page should be printed.</summary>
		/// <returns>
		///   <see langword="true" /> if an additional page should be printed; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
		public bool HasMorePages
		{
			get
			{
				return hasmorePages;
			}
			set
			{
				hasmorePages = value;
			}
		}

		/// <summary>Gets the rectangular area that represents the portion of the page inside the margins.</summary>
		/// <returns>The rectangular area, measured in hundredths of an inch, that represents the portion of the page inside the margins.</returns>
		public Rectangle MarginBounds => marginBounds;

		/// <summary>Gets the rectangular area that represents the total area of the page.</summary>
		/// <returns>The rectangular area that represents the total area of the page.</returns>
		public Rectangle PageBounds => pageBounds;

		/// <summary>Gets the page settings for the current page.</summary>
		/// <returns>The page settings for the current page.</returns>
		public PageSettings PageSettings => pageSettings;

		internal GraphicsPrinter GraphicsContext
		{
			get
			{
				return graphics_context;
			}
			set
			{
				graphics_context = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> class.</summary>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> used to paint the item.</param>
		/// <param name="marginBounds">The area between the margins.</param>
		/// <param name="pageBounds">The total area of the paper.</param>
		/// <param name="pageSettings">The <see cref="T:System.Drawing.Printing.PageSettings" /> for the page.</param>
		public PrintPageEventArgs(Graphics graphics, Rectangle marginBounds, Rectangle pageBounds, PageSettings pageSettings)
		{
			this.graphics = graphics;
			this.marginBounds = marginBounds;
			this.pageBounds = pageBounds;
			this.pageSettings = pageSettings;
		}

		internal void SetGraphics(Graphics g)
		{
			graphics = g;
		}
	}
	/// <summary>Specifies information about how a document is printed, including the printer that prints it, when printing from a Windows Forms application.</summary>
	[Serializable]
	public class PrinterSettings : ICloneable
	{
		/// <summary>Contains a collection of <see cref="T:System.Drawing.Printing.PaperSource" /> objects.</summary>
		public class PaperSourceCollection : ICollection, IEnumerable
		{
			private ArrayList _PaperSources = new ArrayList();

			/// <summary>Gets the number of different paper sources in the collection.</summary>
			/// <returns>The number of different paper sources in the collection.</returns>
			public int Count => _PaperSources.Count;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.Count" />.</summary>
			int ICollection.Count => _PaperSources.Count;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.IsSynchronized" />.</summary>
			bool ICollection.IsSynchronized => false;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.SyncRoot" />.</summary>
			object ICollection.SyncRoot => this;

			/// <summary>Gets the <see cref="T:System.Drawing.Printing.PaperSource" /> at a specified index.</summary>
			/// <param name="index">The index of the <see cref="T:System.Drawing.Printing.PaperSource" /> to get.</param>
			/// <returns>The <see cref="T:System.Drawing.Printing.PaperSource" /> at the specified index.</returns>
			public virtual PaperSource this[int index] => _PaperSources[index] as PaperSource;

			/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSourceCollection" /> class.</summary>
			/// <param name="array">An array of type <see cref="T:System.Drawing.Printing.PaperSource" />.</param>
			public PaperSourceCollection(PaperSource[] array)
			{
				foreach (PaperSource value in array)
				{
					_PaperSources.Add(value);
				}
			}

			/// <summary>Adds the specified <see cref="T:System.Drawing.Printing.PaperSource" /> to end of the <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSourceCollection" />.</summary>
			/// <param name="paperSource">The <see cref="T:System.Drawing.Printing.PaperSource" /> to add to the collection.</param>
			/// <returns>The zero-based index where the <see cref="T:System.Drawing.Printing.PaperSource" /> was added.</returns>
			[EditorBrowsable(EditorBrowsableState.Never)]
			public int Add(PaperSource paperSource)
			{
				return _PaperSources.Add(paperSource);
			}

			/// <summary>Copies the contents of the current <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSourceCollection" /> to the specified array, starting at the specified index.</summary>
			/// <param name="paperSources">A zero-based array that receives the items copied from the <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSourceCollection" />.</param>
			/// <param name="index">The index at which to start copying items.</param>
			public void CopyTo(PaperSource[] paperSources, int index)
			{
				throw new NotImplementedException();
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.IEnumerable.GetEnumerator" />.</summary>
			IEnumerator IEnumerable.GetEnumerator()
			{
				return _PaperSources.GetEnumerator();
			}

			/// <summary>Returns an enumerator that can iterate through the collection.</summary>
			/// <returns>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSourceCollection" />.</returns>
			public IEnumerator GetEnumerator()
			{
				return _PaperSources.GetEnumerator();
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />.</summary>
			/// <param name="array">The destination array for the contents of the collection.</param>
			/// <param name="index">The index at which to start the copy operation.</param>
			void ICollection.CopyTo(Array array, int index)
			{
				_PaperSources.CopyTo(array, index);
			}

			internal void Clear()
			{
				_PaperSources.Clear();
			}
		}

		/// <summary>Contains a collection of <see cref="T:System.Drawing.Printing.PaperSize" /> objects.</summary>
		public class PaperSizeCollection : ICollection, IEnumerable
		{
			private ArrayList _PaperSizes = new ArrayList();

			/// <summary>Gets the number of different paper sizes in the collection.</summary>
			/// <returns>The number of different paper sizes in the collection.</returns>
			public int Count => _PaperSizes.Count;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.Count" />.</summary>
			int ICollection.Count => _PaperSizes.Count;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.IsSynchronized" />.</summary>
			bool ICollection.IsSynchronized => false;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.SyncRoot" />.</summary>
			object ICollection.SyncRoot => this;

			/// <summary>Gets the <see cref="T:System.Drawing.Printing.PaperSize" /> at a specified index.</summary>
			/// <param name="index">The index of the <see cref="T:System.Drawing.Printing.PaperSize" /> to get.</param>
			/// <returns>The <see cref="T:System.Drawing.Printing.PaperSize" /> at the specified index.</returns>
			public virtual PaperSize this[int index] => _PaperSizes[index] as PaperSize;

			/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSizeCollection" /> class.</summary>
			/// <param name="array">An array of type <see cref="T:System.Drawing.Printing.PaperSize" />.</param>
			public PaperSizeCollection(PaperSize[] array)
			{
				foreach (PaperSize value in array)
				{
					_PaperSizes.Add(value);
				}
			}

			/// <summary>Adds a <see cref="T:System.Drawing.Printing.PrinterResolution" /> to the end of the collection.</summary>
			/// <param name="paperSize">The <see cref="T:System.Drawing.Printing.PaperSize" /> to add to the collection.</param>
			/// <returns>The zero-based index of the newly added item.</returns>
			[EditorBrowsable(EditorBrowsableState.Never)]
			public int Add(PaperSize paperSize)
			{
				return _PaperSizes.Add(paperSize);
			}

			/// <summary>Copies the contents of the current <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSizeCollection" /> to the specified array, starting at the specified index.</summary>
			/// <param name="paperSizes">A zero-based array that receives the items copied from the <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSizeCollection" />.</param>
			/// <param name="index">The index at which to start copying items.</param>
			public void CopyTo(PaperSize[] paperSizes, int index)
			{
				throw new NotImplementedException();
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.IEnumerable.GetEnumerator" />.</summary>
			/// <returns>An enumerator associated with the collection.</returns>
			IEnumerator IEnumerable.GetEnumerator()
			{
				return _PaperSizes.GetEnumerator();
			}

			/// <summary>Returns an enumerator that can iterate through the collection.</summary>
			/// <returns>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSizeCollection" />.</returns>
			public IEnumerator GetEnumerator()
			{
				return _PaperSizes.GetEnumerator();
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />.</summary>
			/// <param name="array">A zero-based array that receives the items copied from the collection.</param>
			/// <param name="index">The index at which to start copying items.</param>
			void ICollection.CopyTo(Array array, int index)
			{
				_PaperSizes.CopyTo(array, index);
			}

			internal void Clear()
			{
				_PaperSizes.Clear();
			}
		}

		/// <summary>Contains a collection of <see cref="T:System.Drawing.Printing.PrinterResolution" /> objects.</summary>
		public class PrinterResolutionCollection : ICollection, IEnumerable
		{
			private ArrayList _PrinterResolutions = new ArrayList();

			/// <summary>Gets the number of available printer resolutions in the collection.</summary>
			/// <returns>The number of available printer resolutions in the collection.</returns>
			public int Count => _PrinterResolutions.Count;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.Count" />.</summary>
			int ICollection.Count => _PrinterResolutions.Count;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.IsSynchronized" />.</summary>
			bool ICollection.IsSynchronized => false;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.SyncRoot" />.</summary>
			object ICollection.SyncRoot => this;

			/// <summary>Gets the <see cref="T:System.Drawing.Printing.PrinterResolution" /> at a specified index.</summary>
			/// <param name="index">The index of the <see cref="T:System.Drawing.Printing.PrinterResolution" /> to get.</param>
			/// <returns>The <see cref="T:System.Drawing.Printing.PrinterResolution" /> at the specified index.</returns>
			public virtual PrinterResolution this[int index] => _PrinterResolutions[index] as PrinterResolution;

			/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrinterSettings.PrinterResolutionCollection" /> class.</summary>
			/// <param name="array">An array of type <see cref="T:System.Drawing.Printing.PrinterResolution" />.</param>
			public PrinterResolutionCollection(PrinterResolution[] array)
			{
				foreach (PrinterResolution value in array)
				{
					_PrinterResolutions.Add(value);
				}
			}

			/// <summary>Adds a <see cref="T:System.Drawing.Printing.PrinterResolution" /> to the end of the collection.</summary>
			/// <param name="printerResolution">The <see cref="T:System.Drawing.Printing.PrinterResolution" /> to add to the collection.</param>
			/// <returns>The zero-based index of the newly added item.</returns>
			[EditorBrowsable(EditorBrowsableState.Never)]
			public int Add(PrinterResolution printerResolution)
			{
				return _PrinterResolutions.Add(printerResolution);
			}

			/// <summary>Copies the contents of the current <see cref="T:System.Drawing.Printing.PrinterSettings.PrinterResolutionCollection" /> to the specified array, starting at the specified index.</summary>
			/// <param name="printerResolutions">A zero-based array that receives the items copied from the <see cref="T:System.Drawing.Printing.PrinterSettings.PrinterResolutionCollection" />.</param>
			/// <param name="index">The index at which to start copying items.</param>
			public void CopyTo(PrinterResolution[] printerResolutions, int index)
			{
				throw new NotImplementedException();
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.IEnumerable.GetEnumerator" />.</summary>
			IEnumerator IEnumerable.GetEnumerator()
			{
				return _PrinterResolutions.GetEnumerator();
			}

			/// <summary>Returns an enumerator that can iterate through the collection.</summary>
			/// <returns>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Drawing.Printing.PrinterSettings.PrinterResolutionCollection" />.</returns>
			public IEnumerator GetEnumerator()
			{
				return _PrinterResolutions.GetEnumerator();
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />.</summary>
			/// <param name="array">The destination array.</param>
			/// <param name="index">The index at which to start the copy operation.</param>
			void ICollection.CopyTo(Array array, int index)
			{
				_PrinterResolutions.CopyTo(array, index);
			}

			internal void Clear()
			{
				_PrinterResolutions.Clear();
			}
		}

		/// <summary>Contains a collection of <see cref="T:System.String" /> objects.</summary>
		public class StringCollection : ICollection, IEnumerable
		{
			private ArrayList _Strings = new ArrayList();

			/// <summary>Gets the number of strings in the collection.</summary>
			/// <returns>The number of strings in the collection.</returns>
			public int Count => _Strings.Count;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.Count" />.</summary>
			int ICollection.Count => _Strings.Count;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.IsSynchronized" />.</summary>
			bool ICollection.IsSynchronized => false;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.SyncRoot" />.</summary>
			object ICollection.SyncRoot => this;

			/// <summary>Gets the <see cref="T:System.String" /> at a specified index.</summary>
			/// <param name="index">The index of the <see cref="T:System.String" /> to get.</param>
			/// <returns>The <see cref="T:System.String" /> at the specified index.</returns>
			public virtual string this[int index] => _Strings[index] as string;

			/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrinterSettings.StringCollection" /> class.</summary>
			/// <param name="array">An array of type <see cref="T:System.String" />.</param>
			public StringCollection(string[] array)
			{
				foreach (string value in array)
				{
					_Strings.Add(value);
				}
			}

			/// <summary>Adds a string to the end of the collection.</summary>
			/// <param name="value">The string to add to the collection.</param>
			/// <returns>The zero-based index of the newly added item.</returns>
			[EditorBrowsable(EditorBrowsableState.Never)]
			public int Add(string value)
			{
				return _Strings.Add(value);
			}

			/// <summary>Copies the contents of the current <see cref="T:System.Drawing.Printing.PrinterSettings.PrinterResolutionCollection" /> to the specified array, starting at the specified index</summary>
			/// <param name="strings">A zero-based array that receives the items copied from the <see cref="T:System.Drawing.Printing.PrinterSettings.StringCollection" />.</param>
			/// <param name="index">The index at which to start copying items.</param>
			public void CopyTo(string[] strings, int index)
			{
				throw new NotImplementedException();
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.IEnumerable.GetEnumerator" />.</summary>
			IEnumerator IEnumerable.GetEnumerator()
			{
				return _Strings.GetEnumerator();
			}

			/// <summary>Returns an enumerator that can iterate through the collection.</summary>
			/// <returns>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Drawing.Printing.PrinterSettings.StringCollection" />.</returns>
			public IEnumerator GetEnumerator()
			{
				return _Strings.GetEnumerator();
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />.</summary>
			/// <param name="array">The array for items to be copied to.</param>
			/// <param name="index">The starting index.</param>
			void ICollection.CopyTo(Array array, int index)
			{
				_Strings.CopyTo(array, index);
			}
		}

		private string printer_name;

		private string print_filename;

		private short copies;

		private int maximum_page;

		private int minimum_page;

		private int from_page;

		private int to_page;

		private bool collate;

		private PrintRange print_range;

		internal int maximum_copies;

		internal bool can_duplex;

		internal bool supports_color;

		internal int landscape_angle;

		private bool print_tofile;

		internal PrinterResolutionCollection printer_resolutions;

		internal PaperSizeCollection paper_sizes;

		internal PaperSourceCollection paper_sources;

		private PageSettings default_pagesettings;

		private Duplex duplex;

		internal bool is_plotter;

		private PrintingServices printing_services;

		internal NameValueCollection printer_capabilities;

		/// <summary>Gets a value indicating whether the printer supports double-sided printing.</summary>
		/// <returns>
		///   <see langword="true" /> if the printer supports double-sided printing; otherwise, <see langword="false" />.</returns>
		public bool CanDuplex => can_duplex;

		/// <summary>Gets or sets a value indicating whether the printed document is collated.</summary>
		/// <returns>
		///   <see langword="true" /> if the printed document is collated; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
		public bool Collate
		{
			get
			{
				return collate;
			}
			set
			{
				collate = value;
			}
		}

		/// <summary>Gets or sets the number of copies of the document to print.</summary>
		/// <returns>The number of copies to print. The default is 1.</returns>
		/// <exception cref="T:System.ArgumentException">The value of the <see cref="P:System.Drawing.Printing.PrinterSettings.Copies" /> property is less than zero.</exception>
		public short Copies
		{
			get
			{
				return copies;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException("The value of the Copies property is less than zero.");
				}
				copies = value;
			}
		}

		/// <summary>Gets the default page settings for this printer.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PageSettings" /> that represents the default page settings for this printer.</returns>
		public PageSettings DefaultPageSettings
		{
			get
			{
				if (default_pagesettings == null)
				{
					default_pagesettings = new PageSettings(this, SupportsColor, landscape: false, new PaperSize("A4", 827, 1169), new PaperSource(PaperSourceKind.FormSource, "Tray"), new PrinterResolution(PrinterResolutionKind.Medium, 200, 200));
				}
				return default_pagesettings;
			}
		}

		/// <summary>Gets or sets the printer setting for double-sided printing.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Printing.Duplex" /> values. The default is determined by the printer.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The value of the <see cref="P:System.Drawing.Printing.PrinterSettings.Duplex" /> property is not one of the <see cref="T:System.Drawing.Printing.Duplex" /> values.</exception>
		public Duplex Duplex
		{
			get
			{
				return duplex;
			}
			set
			{
				duplex = value;
			}
		}

		/// <summary>Gets or sets the page number of the first page to print.</summary>
		/// <returns>The page number of the first page to print.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.PrinterSettings.FromPage" /> property's value is less than zero.</exception>
		public int FromPage
		{
			get
			{
				return from_page;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException("The value of the FromPage property is less than zero");
				}
				from_page = value;
			}
		}

		/// <summary>Gets the names of all printers installed on the computer.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PrinterSettings.StringCollection" /> that represents the names of all printers installed on the computer.</returns>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The available printers could not be enumerated.</exception>
		public static StringCollection InstalledPrinters => SysPrn.GlobalService.InstalledPrinters;

		/// <summary>Gets a value indicating whether the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property designates the default printer, except when the user explicitly sets <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" />.</summary>
		/// <returns>
		///   <see langword="true" /> if <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> designates the default printer; otherwise, <see langword="false" />.</returns>
		public bool IsDefaultPrinter => printer_name == printing_services.DefaultPrinter;

		/// <summary>Gets a value indicating whether the printer is a plotter.</summary>
		/// <returns>
		///   <see langword="true" /> if the printer is a plotter; <see langword="false" /> if the printer is a raster.</returns>
		public bool IsPlotter => is_plotter;

		/// <summary>Gets a value indicating whether the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property designates a valid printer.</summary>
		/// <returns>
		///   <see langword="true" /> if the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property designates a valid printer; otherwise, <see langword="false" />.</returns>
		public bool IsValid => printing_services.IsPrinterValid(printer_name);

		/// <summary>Gets the angle, in degrees, that the portrait orientation is rotated to produce the landscape orientation.</summary>
		/// <returns>The angle, in degrees, that the portrait orientation is rotated to produce the landscape orientation.</returns>
		public int LandscapeAngle => landscape_angle;

		/// <summary>Gets the maximum number of copies that the printer enables the user to print at a time.</summary>
		/// <returns>The maximum number of copies that the printer enables the user to print at a time.</returns>
		public int MaximumCopies => maximum_copies;

		/// <summary>Gets or sets the maximum <see cref="P:System.Drawing.Printing.PrinterSettings.FromPage" /> or <see cref="P:System.Drawing.Printing.PrinterSettings.ToPage" /> that can be selected in a <see cref="T:System.Windows.Forms.PrintDialog" />.</summary>
		/// <returns>The maximum <see cref="P:System.Drawing.Printing.PrinterSettings.FromPage" /> or <see cref="P:System.Drawing.Printing.PrinterSettings.ToPage" /> that can be selected in a <see cref="T:System.Windows.Forms.PrintDialog" />.</returns>
		/// <exception cref="T:System.ArgumentException">The value of the <see cref="P:System.Drawing.Printing.PrinterSettings.MaximumPage" /> property is less than zero.</exception>
		public int MaximumPage
		{
			get
			{
				return maximum_page;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException("The value of the MaximumPage property is less than zero");
				}
				maximum_page = value;
			}
		}

		/// <summary>Gets or sets the minimum <see cref="P:System.Drawing.Printing.PrinterSettings.FromPage" /> or <see cref="P:System.Drawing.Printing.PrinterSettings.ToPage" /> that can be selected in a <see cref="T:System.Windows.Forms.PrintDialog" />.</summary>
		/// <returns>The minimum <see cref="P:System.Drawing.Printing.PrinterSettings.FromPage" /> or <see cref="P:System.Drawing.Printing.PrinterSettings.ToPage" /> that can be selected in a <see cref="T:System.Windows.Forms.PrintDialog" />.</returns>
		/// <exception cref="T:System.ArgumentException">The value of the <see cref="P:System.Drawing.Printing.PrinterSettings.MinimumPage" /> property is less than zero.</exception>
		public int MinimumPage
		{
			get
			{
				return minimum_page;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException("The value of the MaximumPage property is less than zero");
				}
				minimum_page = value;
			}
		}

		/// <summary>Gets the paper sizes that are supported by this printer.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSizeCollection" /> that represents the paper sizes that are supported by this printer.</returns>
		public PaperSizeCollection PaperSizes
		{
			get
			{
				if (!IsValid)
				{
					throw new InvalidPrinterException(this);
				}
				return paper_sizes;
			}
		}

		/// <summary>Gets the paper source trays that are available on the printer.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSourceCollection" /> that represents the paper source trays that are available on this printer.</returns>
		public PaperSourceCollection PaperSources
		{
			get
			{
				if (!IsValid)
				{
					throw new InvalidPrinterException(this);
				}
				return paper_sources;
			}
		}

		/// <summary>Gets or sets the file name, when printing to a file.</summary>
		/// <returns>The file name, when printing to a file.</returns>
		public string PrintFileName
		{
			get
			{
				return print_filename;
			}
			set
			{
				print_filename = value;
			}
		}

		/// <summary>Gets or sets the name of the printer to use.</summary>
		/// <returns>The name of the printer to use.</returns>
		public string PrinterName
		{
			get
			{
				return printer_name;
			}
			set
			{
				if (!(printer_name == value))
				{
					printer_name = value;
					printing_services.LoadPrinterSettings(printer_name, this);
				}
			}
		}

		/// <summary>Gets all the resolutions that are supported by this printer.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PrinterSettings.PrinterResolutionCollection" /> that represents the resolutions that are supported by this printer.</returns>
		public PrinterResolutionCollection PrinterResolutions
		{
			get
			{
				if (!IsValid)
				{
					throw new InvalidPrinterException(this);
				}
				if (printer_resolutions == null)
				{
					printer_resolutions = new PrinterResolutionCollection(new PrinterResolution[0]);
					printing_services.LoadPrinterResolutions(printer_name, this);
				}
				return printer_resolutions;
			}
		}

		/// <summary>Gets or sets the page numbers that the user has specified to be printed.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Printing.PrintRange" /> values.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The value of the <see cref="P:System.Drawing.Printing.PrinterSettings.PrintRange" /> property is not one of the <see cref="T:System.Drawing.Printing.PrintRange" /> values.</exception>
		public PrintRange PrintRange
		{
			get
			{
				return print_range;
			}
			set
			{
				if (value != PrintRange.AllPages && value != PrintRange.Selection && value != PrintRange.SomePages)
				{
					throw new InvalidEnumArgumentException("The value of the PrintRange property is not one of the PrintRange values");
				}
				print_range = value;
			}
		}

		/// <summary>Gets or sets a value indicating whether the printing output is sent to a file instead of a port.</summary>
		/// <returns>
		///   <see langword="true" /> if the printing output is sent to a file; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
		public bool PrintToFile
		{
			get
			{
				return print_tofile;
			}
			set
			{
				print_tofile = value;
			}
		}

		/// <summary>Gets a value indicating whether this printer supports color printing.</summary>
		/// <returns>
		///   <see langword="true" /> if this printer supports color; otherwise, <see langword="false" />.</returns>
		public bool SupportsColor => supports_color;

		/// <summary>Gets or sets the number of the last page to print.</summary>
		/// <returns>The number of the last page to print.</returns>
		/// <exception cref="T:System.ArgumentException">The value of the <see cref="P:System.Drawing.Printing.PrinterSettings.ToPage" /> property is less than zero.</exception>
		public int ToPage
		{
			get
			{
				return to_page;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException("The value of the ToPage property is less than zero");
				}
				to_page = value;
			}
		}

		internal NameValueCollection PrinterCapabilities
		{
			get
			{
				if (printer_capabilities == null)
				{
					printer_capabilities = new NameValueCollection();
				}
				return printer_capabilities;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrinterSettings" /> class.</summary>
		public PrinterSettings()
			: this(SysPrn.CreatePrintingService())
		{
		}

		internal PrinterSettings(PrintingServices printing_services)
		{
			this.printing_services = printing_services;
			printer_name = printing_services.DefaultPrinter;
			ResetToDefaults();
			printing_services.LoadPrinterSettings(printer_name, this);
		}

		private void ResetToDefaults()
		{
			printer_resolutions = null;
			paper_sizes = null;
			paper_sources = null;
			default_pagesettings = null;
			maximum_page = 9999;
			copies = 1;
			collate = true;
		}

		/// <summary>Creates a copy of this <see cref="T:System.Drawing.Printing.PrinterSettings" />.</summary>
		/// <returns>A copy of this object.</returns>
		public object Clone()
		{
			return new PrinterSettings(printing_services);
		}

		/// <summary>Returns a <see cref="T:System.Drawing.Graphics" /> that contains printer information that is useful when creating a <see cref="T:System.Drawing.Printing.PrintDocument" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> that contains information from a printer.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		[System.MonoTODO("PrinterSettings.CreateMeasurementGraphics")]
		public Graphics CreateMeasurementGraphics()
		{
			throw new NotImplementedException();
		}

		/// <summary>Returns a <see cref="T:System.Drawing.Graphics" /> that contains printer information, optionally specifying the origin at the margins.</summary>
		/// <param name="honorOriginAtMargins">
		///   <see langword="true" /> to indicate the origin at the margins; otherwise, <see langword="false" />.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> that contains printer information from the <see cref="T:System.Drawing.Printing.PageSettings" />.</returns>
		[System.MonoTODO("PrinterSettings.CreateMeasurementGraphics")]
		public Graphics CreateMeasurementGraphics(bool honorOriginAtMargins)
		{
			throw new NotImplementedException();
		}

		/// <summary>Returns a <see cref="T:System.Drawing.Graphics" /> that contains printer information associated with the specified <see cref="T:System.Drawing.Printing.PageSettings" />.</summary>
		/// <param name="pageSettings">The <see cref="T:System.Drawing.Printing.PageSettings" /> to retrieve a graphics object for.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> that contains printer information from the <see cref="T:System.Drawing.Printing.PageSettings" />.</returns>
		[System.MonoTODO("PrinterSettings.CreateMeasurementGraphics")]
		public Graphics CreateMeasurementGraphics(PageSettings pageSettings)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Graphics" /> associated with the specified page settings and optionally specifying the origin at the margins.</summary>
		/// <param name="pageSettings">The <see cref="T:System.Drawing.Printing.PageSettings" /> to retrieve a <see cref="T:System.Drawing.Graphics" /> object for.</param>
		/// <param name="honorOriginAtMargins">
		///   <see langword="true" /> to specify the origin at the margins; otherwise, <see langword="false" />.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> that contains printer information from the <see cref="T:System.Drawing.Printing.PageSettings" />.</returns>
		[System.MonoTODO("PrinterSettings.CreateMeasurementGraphics")]
		public Graphics CreateMeasurementGraphics(PageSettings pageSettings, bool honorOriginAtMargins)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a handle to a <see langword="DEVMODE" /> structure that corresponds to the printer settings.</summary>
		/// <returns>A handle to a <see langword="DEVMODE" /> structure.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The printer's initialization information could not be retrieved.</exception>
		[System.MonoTODO("PrinterSettings.GetHdevmode")]
		public IntPtr GetHdevmode()
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a handle to a <see langword="DEVMODE" /> structure that corresponds to the printer and the page settings specified through the <paramref name="pageSettings" /> parameter.</summary>
		/// <param name="pageSettings">The <see cref="T:System.Drawing.Printing.PageSettings" /> object that the <see langword="DEVMODE" /> structure's handle corresponds to.</param>
		/// <returns>A handle to a <see langword="DEVMODE" /> structure.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The printer's initialization information could not be retrieved.</exception>
		[System.MonoTODO("PrinterSettings.GetHdevmode")]
		public IntPtr GetHdevmode(PageSettings pageSettings)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a handle to a <see langword="DEVNAMES" /> structure that corresponds to the printer settings.</summary>
		/// <returns>A handle to a <see langword="DEVNAMES" /> structure.</returns>
		[System.MonoTODO("PrinterSettings.GetHdevname")]
		public IntPtr GetHdevnames()
		{
			throw new NotImplementedException();
		}

		/// <summary>Gets a value indicating whether the printer supports printing the specified image file.</summary>
		/// <param name="image">The image to print.</param>
		/// <returns>
		///   <see langword="true" /> if the printer supports printing the specified image; otherwise, <see langword="false" />.</returns>
		[System.MonoTODO("IsDirectPrintingSupported")]
		public bool IsDirectPrintingSupported(Image image)
		{
			throw new NotImplementedException();
		}

		/// <summary>Returns a value indicating whether the printer supports printing the specified image format.</summary>
		/// <param name="imageFormat">An <see cref="T:System.Drawing.Imaging.ImageFormat" /> to print.</param>
		/// <returns>
		///   <see langword="true" /> if the printer supports printing the specified image format; otherwise, <see langword="false" />.</returns>
		[System.MonoTODO("IsDirectPrintingSupported")]
		public bool IsDirectPrintingSupported(ImageFormat imageFormat)
		{
			throw new NotImplementedException();
		}

		/// <summary>Copies the relevant information out of the given handle and into the <see cref="T:System.Drawing.Printing.PrinterSettings" />.</summary>
		/// <param name="hdevmode">The handle to a Win32 <see langword="DEVMODE" /> structure.</param>
		/// <exception cref="T:System.ArgumentException">The printer handle is not valid.</exception>
		[System.MonoTODO("PrinterSettings.SetHdevmode")]
		public void SetHdevmode(IntPtr hdevmode)
		{
			throw new NotImplementedException();
		}

		/// <summary>Copies the relevant information out of the given handle and into the <see cref="T:System.Drawing.Printing.PrinterSettings" />.</summary>
		/// <param name="hdevnames">The handle to a Win32 <see langword="DEVNAMES" /> structure.</param>
		/// <exception cref="T:System.ArgumentException">The printer handle is invalid.</exception>
		[System.MonoTODO("PrinterSettings.SetHdevnames")]
		public void SetHdevnames(IntPtr hdevnames)
		{
			throw new NotImplementedException();
		}

		/// <summary>Provides information about the <see cref="T:System.Drawing.Printing.PrinterSettings" /> in string form.</summary>
		/// <returns>A string.</returns>
		public override string ToString()
		{
			return "Printer [PrinterSettings " + printer_name + " Copies=" + copies + " Collate=" + collate.ToString() + " Duplex=" + can_duplex.ToString() + " FromPage=" + from_page + " LandscapeAngle=" + landscape_angle + " MaximumCopies=" + maximum_copies + " OutputPort= ToPage=" + to_page + "]";
		}
	}
	internal abstract class PrintingServices
	{
		internal abstract string DefaultPrinter { get; }

		internal abstract bool IsPrinterValid(string printer);

		internal abstract void LoadPrinterSettings(string printer, PrinterSettings settings);

		internal abstract void LoadPrinterResolutions(string printer, PrinterSettings settings);

		internal abstract void GetPrintDialogInfo(string printer, ref string port, ref string type, ref string status, ref string comment);

		internal void LoadDefaultResolutions(PrinterSettings.PrinterResolutionCollection col)
		{
			col.Add(new PrinterResolution(PrinterResolutionKind.High, -4, -1));
			col.Add(new PrinterResolution(PrinterResolutionKind.Medium, -3, -1));
			col.Add(new PrinterResolution(PrinterResolutionKind.Low, -2, -1));
			col.Add(new PrinterResolution(PrinterResolutionKind.Draft, -1, -1));
		}
	}
	internal abstract class GlobalPrintingServices
	{
		internal abstract PrinterSettings.StringCollection InstalledPrinters { get; }

		internal abstract IntPtr CreateGraphicsContext(PrinterSettings settings, PageSettings page_settings);

		internal abstract bool StartDoc(GraphicsPrinter gr, string doc_name, string output_file);

		internal abstract bool StartPage(GraphicsPrinter gr);

		internal abstract bool EndPage(GraphicsPrinter gr);

		internal abstract bool EndDoc(GraphicsPrinter gr);
	}
	internal class SysPrn
	{
		internal class Printer
		{
			public readonly string Comment;

			public readonly string Port;

			public readonly string Type;

			public readonly string Status;

			public PrinterSettings Settings;

			public Printer(string port, string type, string status, string comment)
			{
				Port = port;
				Type = type;
				Status = status;
				Comment = comment;
			}
		}

		private static GlobalPrintingServices global_printing_services;

		private static bool is_unix;

		internal static GlobalPrintingServices GlobalService
		{
			get
			{
				if (global_printing_services == null)
				{
					if (is_unix)
					{
						global_printing_services = new GlobalPrintingServicesUnix();
					}
					else
					{
						global_printing_services = new GlobalPrintingServicesWin32();
					}
				}
				return global_printing_services;
			}
		}

		static SysPrn()
		{
			is_unix = GDIPlus.RunningOnUnix();
		}

		internal static PrintingServices CreatePrintingService()
		{
			if (is_unix)
			{
				return new PrintingServicesUnix();
			}
			return new PrintingServicesWin32();
		}

		internal static void GetPrintDialogInfo(string printer, ref string port, ref string type, ref string status, ref string comment)
		{
			CreatePrintingService().GetPrintDialogInfo(printer, ref port, ref type, ref status, ref comment);
		}
	}
	internal class GraphicsPrinter
	{
		private Graphics graphics;

		private IntPtr hDC;

		internal Graphics Graphics
		{
			get
			{
				return graphics;
			}
			set
			{
				graphics = value;
			}
		}

		internal IntPtr Hdc => hDC;

		internal GraphicsPrinter(Graphics gr, IntPtr dc)
		{
			graphics = gr;
			hDC = dc;
		}
	}
	internal class PrintingServicesUnix : PrintingServices
	{
		public struct DOCINFO
		{
			public PrinterSettings settings;

			public PageSettings default_page_settings;

			public string title;

			public string filename;
		}

		public struct PPD_SIZE
		{
			public int marked;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 42)]
			public string name;

			public float width;

			public float length;

			public float left;

			public float bottom;

			public float right;

			public float top;
		}

		public struct PPD_GROUP
		{
			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 40)]
			public string text;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 42)]
			public string name;

			public int num_options;

			public IntPtr options;

			public int num_subgroups;

			public IntPtr subgrups;
		}

		public struct PPD_OPTION
		{
			public byte conflicted;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 41)]
			public string keyword;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 41)]
			public string defchoice;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 81)]
			public string text;

			public int ui;

			public int section;

			public float order;

			public int num_choices;

			public IntPtr choices;
		}

		public struct PPD_CHOICE
		{
			public byte marked;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 41)]
			public string choice;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 81)]
			public string text;

			public IntPtr code;

			public IntPtr option;
		}

		public struct PPD_FILE
		{
			public int language_level;

			public int color_device;

			public int variable_sizes;

			public int accurate_screens;

			public int contone_only;

			public int landscape;

			public int model_number;

			public int manual_copies;

			public int throughput;

			public int colorspace;

			public IntPtr patches;

			public int num_emulations;

			public IntPtr emulations;

			public IntPtr jcl_begin;

			public IntPtr jcl_ps;

			public IntPtr jcl_end;

			public IntPtr lang_encoding;

			public IntPtr lang_version;

			public IntPtr modelname;

			public IntPtr ttrasterizer;

			public IntPtr manufacturer;

			public IntPtr product;

			public IntPtr nickname;

			public IntPtr shortnickname;

			public int num_groups;

			public IntPtr groups;

			public int num_sizes;

			public IntPtr sizes;
		}

		public struct CUPS_OPTIONS
		{
			public IntPtr name;

			public IntPtr val;
		}

		public struct CUPS_DESTS
		{
			public IntPtr name;

			public IntPtr instance;

			public int is_default;

			public int num_options;

			public IntPtr options;
		}

		private static Hashtable doc_info;

		private static bool cups_installed;

		private static Hashtable installed_printers;

		private static string default_printer;

		private static string tmpfile;

		internal static PrinterSettings.StringCollection InstalledPrinters
		{
			get
			{
				LoadPrinters();
				PrinterSettings.StringCollection stringCollection = new PrinterSettings.StringCollection(new string[0]);
				foreach (object key in installed_printers.Keys)
				{
					stringCollection.Add(key.ToString());
				}
				return stringCollection;
			}
		}

		internal override string DefaultPrinter
		{
			get
			{
				if (installed_printers.Count == 0)
				{
					LoadPrinters();
				}
				return default_printer;
			}
		}

		internal PrintingServicesUnix()
		{
		}

		static PrintingServicesUnix()
		{
			doc_info = new Hashtable();
			default_printer = string.Empty;
			installed_printers = new Hashtable();
			CheckCupsInstalled();
		}

		private static void CheckCupsInstalled()
		{
			try
			{
				cupsGetDefault();
			}
			catch (DllNotFoundException)
			{
				Console.WriteLine("libcups not found. To have printing support, you need cups installed");
				cups_installed = false;
				return;
			}
			cups_installed = true;
		}

		private IntPtr OpenPrinter(string printer)
		{
			try
			{
				return ppdOpenFile(Marshal.PtrToStringAnsi(cupsGetPPD(printer)));
			}
			catch (Exception)
			{
				Console.WriteLine("There was an error opening the printer {0}. Please check your cups installation.");
			}
			return IntPtr.Zero;
		}

		private void ClosePrinter(ref IntPtr handle)
		{
			try
			{
				if (handle != IntPtr.Zero)
				{
					ppdClose(handle);
				}
			}
			finally
			{
				handle = IntPtr.Zero;
			}
		}

		private static int OpenDests(ref IntPtr ptr)
		{
			try
			{
				return cupsGetDests(ref ptr);
			}
			catch
			{
				ptr = IntPtr.Zero;
			}
			return 0;
		}

		private static void CloseDests(ref IntPtr ptr, int count)
		{
			try
			{
				if (ptr != IntPtr.Zero)
				{
					cupsFreeDests(count, ptr);
				}
			}
			finally
			{
				ptr = IntPtr.Zero;
			}
		}

		internal override bool IsPrinterValid(string printer)
		{
			if (!cups_installed || ((printer == null) | (printer == string.Empty)))
			{
				return false;
			}
			return installed_printers.Contains(printer);
		}

		internal override void LoadPrinterSettings(string printer, PrinterSettings settings)
		{
			if (!cups_installed || printer == null || printer == string.Empty)
			{
				return;
			}
			if (installed_printers.Count == 0)
			{
				LoadPrinters();
			}
			if (((SysPrn.Printer)installed_printers[printer]).Settings != null)
			{
				SysPrn.Printer printer2 = (SysPrn.Printer)installed_printers[printer];
				settings.can_duplex = printer2.Settings.can_duplex;
				settings.is_plotter = printer2.Settings.is_plotter;
				settings.landscape_angle = printer2.Settings.landscape_angle;
				settings.maximum_copies = printer2.Settings.maximum_copies;
				settings.paper_sizes = printer2.Settings.paper_sizes;
				settings.paper_sources = printer2.Settings.paper_sources;
				settings.printer_capabilities = printer2.Settings.printer_capabilities;
				settings.printer_resolutions = printer2.Settings.printer_resolutions;
				settings.supports_color = printer2.Settings.supports_color;
				return;
			}
			settings.PrinterCapabilities.Clear();
			IntPtr ptr = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			IntPtr zero2 = IntPtr.Zero;
			string text = string.Empty;
			int num = 0;
			try
			{
				num = OpenDests(ref ptr);
				if (num == 0)
				{
					return;
				}
				int num2 = Marshal.SizeOf(typeof(CUPS_DESTS));
				zero = ptr;
				for (int i = 0; i < num; i++)
				{
					if (Marshal.PtrToStringAnsi(Marshal.ReadIntPtr(zero)).Equals(printer))
					{
						text = printer;
						break;
					}
					zero = (IntPtr)((long)zero + num2);
				}
				if (!text.Equals(printer))
				{
					return;
				}
				zero2 = OpenPrinter(printer);
				if (!(zero2 == IntPtr.Zero))
				{
					CUPS_DESTS cUPS_DESTS = (CUPS_DESTS)Marshal.PtrToStructure(zero, typeof(CUPS_DESTS));
					NameValueCollection nameValueCollection = new NameValueCollection();
					NameValueCollection paper_names = new NameValueCollection();
					NameValueCollection paper_sources = new NameValueCollection();
					LoadPrinterOptions(cUPS_DESTS.options, cUPS_DESTS.num_options, zero2, nameValueCollection, paper_names, out var defsize, paper_sources, out var defsource);
					if (settings.paper_sizes == null)
					{
						settings.paper_sizes = new PrinterSettings.PaperSizeCollection(new PaperSize[0]);
					}
					else
					{
						settings.paper_sizes.Clear();
					}
					if (settings.paper_sources == null)
					{
						settings.paper_sources = new PrinterSettings.PaperSourceCollection(new PaperSource[0]);
					}
					else
					{
						settings.paper_sources.Clear();
					}
					settings.DefaultPageSettings.PaperSource = LoadPrinterPaperSources(settings, defsource, paper_sources);
					settings.DefaultPageSettings.PaperSize = LoadPrinterPaperSizes(zero2, settings, defsize, paper_names);
					LoadPrinterResolutionsAndDefault(printer, settings, zero2);
					PPD_FILE pPD_FILE = (PPD_FILE)Marshal.PtrToStructure(zero2, typeof(PPD_FILE));
					settings.landscape_angle = pPD_FILE.landscape;
					settings.supports_color = ((pPD_FILE.color_device != 0) ? true : false);
					settings.can_duplex = nameValueCollection["Duplex"] != null;
					ClosePrinter(ref zero2);
					((SysPrn.Printer)installed_printers[printer]).Settings = settings;
				}
			}
			finally
			{
				CloseDests(ref ptr, num);
			}
		}

		private static void LoadPrinterOptions(IntPtr options, int numOptions, IntPtr ppd, NameValueCollection list, NameValueCollection paper_names, out string defsize, NameValueCollection paper_sources, out string defsource)
		{
			int num = Marshal.SizeOf(typeof(CUPS_OPTIONS));
			LoadOptionList(ppd, "PageSize", paper_names, out defsize);
			LoadOptionList(ppd, "InputSlot", paper_sources, out defsource);
			for (int i = 0; i < numOptions; i++)
			{
				CUPS_OPTIONS obj = (CUPS_OPTIONS)Marshal.PtrToStructure(options, typeof(CUPS_OPTIONS));
				string text = Marshal.PtrToStringAnsi(obj.name);
				string text2 = Marshal.PtrToStringAnsi(obj.val);
				if (text == "PageSize")
				{
					defsize = text2;
				}
				else if (text == "InputSlot")
				{
					defsource = text2;
				}
				list.Add(text, text2);
				options = (IntPtr)((long)options + num);
			}
		}

		private static NameValueCollection LoadPrinterOptions(IntPtr options, int numOptions)
		{
			int num = Marshal.SizeOf(typeof(CUPS_OPTIONS));
			NameValueCollection nameValueCollection = new NameValueCollection();
			for (int i = 0; i < numOptions; i++)
			{
				CUPS_OPTIONS obj = (CUPS_OPTIONS)Marshal.PtrToStructure(options, typeof(CUPS_OPTIONS));
				string name = Marshal.PtrToStringAnsi(obj.name);
				string value = Marshal.PtrToStringAnsi(obj.val);
				nameValueCollection.Add(name, value);
				options = (IntPtr)((long)options + num);
			}
			return nameValueCollection;
		}

		private static void LoadOptionList(IntPtr ppd, string option_name, NameValueCollection list, out string defoption)
		{
			IntPtr zero = IntPtr.Zero;
			int num = Marshal.SizeOf(typeof(PPD_CHOICE));
			defoption = null;
			zero = ppdFindOption(ppd, option_name);
			if (zero != IntPtr.Zero)
			{
				PPD_OPTION pPD_OPTION = (PPD_OPTION)Marshal.PtrToStructure(zero, typeof(PPD_OPTION));
				defoption = pPD_OPTION.defchoice;
				zero = pPD_OPTION.choices;
				for (int i = 0; i < pPD_OPTION.num_choices; i++)
				{
					PPD_CHOICE pPD_CHOICE = (PPD_CHOICE)Marshal.PtrToStructure(zero, typeof(PPD_CHOICE));
					list.Add(pPD_CHOICE.choice, pPD_CHOICE.text);
					zero = (IntPtr)((long)zero + num);
				}
			}
		}

		internal override void LoadPrinterResolutions(string printer, PrinterSettings settings)
		{
			IntPtr handle = OpenPrinter(printer);
			if (!(handle == IntPtr.Zero))
			{
				LoadPrinterResolutionsAndDefault(printer, settings, handle);
				ClosePrinter(ref handle);
			}
		}

		private PrinterResolution ParseResolution(string resolution)
		{
			if (string.IsNullOrEmpty(resolution))
			{
				return null;
			}
			int num = resolution.IndexOf("dpi");
			if (num == -1)
			{
				return null;
			}
			resolution = resolution.Substring(0, num);
			int num2;
			int y;
			try
			{
				if (resolution.Contains("x"))
				{
					string[] array = resolution.Split(new char[1] { 'x' });
					num2 = Convert.ToInt32(array[0]);
					y = Convert.ToInt32(array[1]);
				}
				else
				{
					num2 = Convert.ToInt32(resolution);
					y = num2;
				}
			}
			catch (Exception)
			{
				return null;
			}
			return new PrinterResolution(PrinterResolutionKind.Custom, num2, y);
		}

		private PaperSize LoadPrinterPaperSizes(IntPtr ppd_handle, PrinterSettings settings, string def_size, NameValueCollection paper_names)
		{
			PaperSize result = new PaperSize(GetPaperKind(827, 1169), "A4", 827, 1169);
			PPD_FILE pPD_FILE = (PPD_FILE)Marshal.PtrToStructure(ppd_handle, typeof(PPD_FILE));
			IntPtr intPtr = pPD_FILE.sizes;
			for (int i = 0; i < pPD_FILE.num_sizes; i++)
			{
				PPD_SIZE structure = (PPD_SIZE)Marshal.PtrToStructure(intPtr, typeof(PPD_SIZE));
				string name = paper_names[structure.name];
				float num = structure.width * 100f / 72f;
				float num2 = structure.length * 100f / 72f;
				PaperKind paperKind = GetPaperKind((int)num, (int)num2);
				PaperSize paperSize = new PaperSize(paperKind, name, (int)num, (int)num2);
				paperSize.RawKind = (int)paperKind;
				if (def_size == paperSize.Kind.ToString())
				{
					result = paperSize;
				}
				settings.paper_sizes.Add(paperSize);
				intPtr = (IntPtr)((long)intPtr + Marshal.SizeOf(structure));
			}
			return result;
		}

		private PaperSource LoadPrinterPaperSources(PrinterSettings settings, string def_source, NameValueCollection paper_sources)
		{
			PaperSource paperSource = null;
			foreach (string paper_source in paper_sources)
			{
				settings.paper_sources.Add(new PaperSource(paper_source switch
				{
					"Auto" => PaperSourceKind.AutomaticFeed, 
					"Standard" => PaperSourceKind.AutomaticFeed, 
					"Tray" => PaperSourceKind.AutomaticFeed, 
					"Envelope" => PaperSourceKind.Envelope, 
					"Manual" => PaperSourceKind.Manual, 
					_ => PaperSourceKind.Custom, 
				}, paper_sources[paper_source]));
				if (def_source == paper_source)
				{
					paperSource = settings.paper_sources[settings.paper_sources.Count - 1];
				}
			}
			if (paperSource == null && settings.paper_sources.Count > 0)
			{
				return settings.paper_sources[0];
			}
			return paperSource;
		}

		private void LoadPrinterResolutionsAndDefault(string printer, PrinterSettings settings, IntPtr ppd_handle)
		{
			if (settings.printer_resolutions == null)
			{
				settings.printer_resolutions = new PrinterSettings.PrinterResolutionCollection(new PrinterResolution[0]);
			}
			else
			{
				settings.printer_resolutions.Clear();
			}
			NameValueCollection nameValueCollection = new NameValueCollection();
			LoadOptionList(ppd_handle, "Resolution", nameValueCollection, out var defoption);
			foreach (object key in nameValueCollection.Keys)
			{
				PrinterResolution printerResolution = ParseResolution(key.ToString());
				settings.PrinterResolutions.Add(printerResolution);
			}
			PrinterResolution printerResolution2 = ParseResolution(defoption);
			if (printerResolution2 == null)
			{
				printerResolution2 = ParseResolution("300dpi");
			}
			if (nameValueCollection.Count == 0)
			{
				settings.PrinterResolutions.Add(printerResolution2);
			}
			settings.DefaultPageSettings.PrinterResolution = printerResolution2;
		}

		private static void LoadPrinters()
		{
			installed_printers.Clear();
			if (!cups_installed)
			{
				return;
			}
			IntPtr ptr = IntPtr.Zero;
			int num = 0;
			int num2 = Marshal.SizeOf(typeof(CUPS_DESTS));
			string type;
			string text2;
			string comment;
			string text = (type = (text2 = (comment = string.Empty)));
			int num3 = 0;
			try
			{
				num = OpenDests(ref ptr);
				IntPtr intPtr = ptr;
				for (int i = 0; i < num; i++)
				{
					CUPS_DESTS cUPS_DESTS = (CUPS_DESTS)Marshal.PtrToStructure(intPtr, typeof(CUPS_DESTS));
					string text3 = Marshal.PtrToStringAnsi(cUPS_DESTS.name);
					if (cUPS_DESTS.is_default == 1)
					{
						default_printer = text3;
					}
					if (text.Equals(string.Empty))
					{
						text = text3;
					}
					NameValueCollection nameValueCollection = LoadPrinterOptions(cUPS_DESTS.options, cUPS_DESTS.num_options);
					if (nameValueCollection["printer-state"] != null)
					{
						num3 = int.Parse(nameValueCollection["printer-state"]);
					}
					if (nameValueCollection["printer-comment"] != null)
					{
						comment = nameValueCollection["printer-state"];
					}
					installed_printers.Add(text3, new SysPrn.Printer(string.Empty, type, num3 switch
					{
						4 => "Printing", 
						5 => "Stopped", 
						_ => "Ready", 
					}, comment));
					intPtr = (IntPtr)((long)intPtr + num2);
				}
			}
			finally
			{
				CloseDests(ref ptr, num);
			}
			if (default_printer.Equals(string.Empty))
			{
				default_printer = text;
			}
		}

		internal override void GetPrintDialogInfo(string printer, ref string port, ref string type, ref string status, ref string comment)
		{
			int num = 0;
			int num2 = -1;
			bool flag = false;
			IntPtr ptr = IntPtr.Zero;
			int num3 = Marshal.SizeOf(typeof(CUPS_DESTS));
			if (!cups_installed)
			{
				return;
			}
			try
			{
				num = OpenDests(ref ptr);
				if (num == 0)
				{
					return;
				}
				IntPtr intPtr = ptr;
				for (int i = 0; i < num; i++)
				{
					if (Marshal.PtrToStringAnsi(Marshal.ReadIntPtr(intPtr)).Equals(printer))
					{
						flag = true;
						break;
					}
					intPtr = (IntPtr)((long)intPtr + num3);
				}
				if (flag)
				{
					CUPS_DESTS cUPS_DESTS = (CUPS_DESTS)Marshal.PtrToStructure(intPtr, typeof(CUPS_DESTS));
					NameValueCollection nameValueCollection = LoadPrinterOptions(cUPS_DESTS.options, cUPS_DESTS.num_options);
					if (nameValueCollection["printer-state"] != null)
					{
						num2 = int.Parse(nameValueCollection["printer-state"]);
					}
					if (nameValueCollection["printer-comment"] != null)
					{
						comment = nameValueCollection["printer-state"];
					}
					switch (num2)
					{
					case 4:
						status = "Printing";
						break;
					case 5:
						status = "Stopped";
						break;
					default:
						status = "Ready";
						break;
					}
				}
			}
			finally
			{
				CloseDests(ref ptr, num);
			}
		}

		private PaperKind GetPaperKind(int width, int height)
		{
			if (width == 827 && height == 1169)
			{
				return PaperKind.A4;
			}
			if (width == 583 && height == 827)
			{
				return PaperKind.A5;
			}
			if (width == 717 && height == 1012)
			{
				return PaperKind.B5;
			}
			if (width == 693 && height == 984)
			{
				return PaperKind.B5Envelope;
			}
			if (width == 638 && height == 902)
			{
				return PaperKind.C5Envelope;
			}
			if (width == 449 && height == 638)
			{
				return PaperKind.C6Envelope;
			}
			if (width == 1700 && height == 2200)
			{
				return PaperKind.CSheet;
			}
			if (width == 433 && height == 866)
			{
				return PaperKind.DLEnvelope;
			}
			if (width == 2200 && height == 3400)
			{
				return PaperKind.DSheet;
			}
			if (width == 3400 && height == 4400)
			{
				return PaperKind.ESheet;
			}
			if (width == 725 && height == 1050)
			{
				return PaperKind.Executive;
			}
			if (width == 850 && height == 1300)
			{
				return PaperKind.Folio;
			}
			if (width == 850 && height == 1200)
			{
				return PaperKind.GermanStandardFanfold;
			}
			if (width == 1700 && height == 1100)
			{
				return PaperKind.Ledger;
			}
			if (width == 850 && height == 1400)
			{
				return PaperKind.Legal;
			}
			if (width == 927 && height == 1500)
			{
				return PaperKind.LegalExtra;
			}
			if (width == 850 && height == 1100)
			{
				return PaperKind.Letter;
			}
			if (width == 927 && height == 1200)
			{
				return PaperKind.LetterExtra;
			}
			if (width == 850 && height == 1269)
			{
				return PaperKind.LetterPlus;
			}
			if (width == 387 && height == 750)
			{
				return PaperKind.MonarchEnvelope;
			}
			if (width == 387 && height == 887)
			{
				return PaperKind.Number9Envelope;
			}
			if (width == 413 && height == 950)
			{
				return PaperKind.Number10Envelope;
			}
			if (width == 450 && height == 1037)
			{
				return PaperKind.Number11Envelope;
			}
			if (width == 475 && height == 1100)
			{
				return PaperKind.Number12Envelope;
			}
			if (width == 500 && height == 1150)
			{
				return PaperKind.Number14Envelope;
			}
			if (width == 363 && height == 650)
			{
				return PaperKind.PersonalEnvelope;
			}
			if (width == 1000 && height == 1100)
			{
				return PaperKind.Standard10x11;
			}
			if (width == 1000 && height == 1400)
			{
				return PaperKind.Standard10x14;
			}
			if (width == 1100 && height == 1700)
			{
				return PaperKind.Standard11x17;
			}
			if (width == 1200 && height == 1100)
			{
				return PaperKind.Standard12x11;
			}
			if (width == 1500 && height == 1100)
			{
				return PaperKind.Standard15x11;
			}
			if (width == 900 && height == 1100)
			{
				return PaperKind.Standard9x11;
			}
			if (width == 550 && height == 850)
			{
				return PaperKind.Statement;
			}
			if (width == 1100 && height == 1700)
			{
				return PaperKind.Tabloid;
			}
			if (width == 1487 && height == 1100)
			{
				return PaperKind.USStandardFanfold;
			}
			return PaperKind.Custom;
		}

		internal static int GetCupsOptions(PrinterSettings printer_settings, PageSettings page_settings, out IntPtr options)
		{
			options = IntPtr.Zero;
			PaperSize paperSize = page_settings.PaperSize;
			int num = paperSize.Width * 72 / 100;
			int num2 = paperSize.Height * 72 / 100;
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("copies=" + printer_settings.Copies + " Collate=" + printer_settings.Collate.ToString() + " ColorModel=" + (page_settings.Color ? "Color" : "Black") + " PageSize=" + $"Custom.{num}x{num2}" + " landscape=" + page_settings.Landscape.ToString());
			if (printer_settings.CanDuplex)
			{
				if (printer_settings.Duplex == Duplex.Simplex)
				{
					stringBuilder.Append(" Duplex=None");
				}
				else
				{
					stringBuilder.Append(" Duplex=DuplexNoTumble");
				}
			}
			return cupsParseOptions(stringBuilder.ToString(), 0, ref options);
		}

		internal static bool StartDoc(GraphicsPrinter gr, string doc_name, string output_file)
		{
			DOCINFO dOCINFO = (DOCINFO)doc_info[gr.Hdc];
			dOCINFO.title = doc_name;
			return true;
		}

		internal static bool EndDoc(GraphicsPrinter gr)
		{
			DOCINFO dOCINFO = (DOCINFO)doc_info[gr.Hdc];
			gr.Graphics.Dispose();
			IntPtr options;
			int cupsOptions = GetCupsOptions(dOCINFO.settings, dOCINFO.default_page_settings, out options);
			cupsPrintFile(dOCINFO.settings.PrinterName, dOCINFO.filename, dOCINFO.title, cupsOptions, options);
			cupsFreeOptions(cupsOptions, options);
			doc_info.Remove(gr.Hdc);
			if (tmpfile != null)
			{
				try
				{
					File.Delete(tmpfile);
				}
				catch
				{
				}
			}
			return true;
		}

		internal static bool StartPage(GraphicsPrinter gr)
		{
			return true;
		}

		internal static bool EndPage(GraphicsPrinter gr)
		{
			GdipGetPostScriptSavePage(gr.Hdc);
			return true;
		}

		internal static IntPtr CreateGraphicsContext(PrinterSettings settings, PageSettings default_page_settings)
		{
			IntPtr graphics = IntPtr.Zero;
			string filename;
			if (!settings.PrintToFile)
			{
				StringBuilder stringBuilder = new StringBuilder(1024);
				int capacity = stringBuilder.Capacity;
				cupsTempFd(stringBuilder, capacity);
				filename = (tmpfile = stringBuilder.ToString());
			}
			else
			{
				filename = settings.PrintFileName;
			}
			PaperSize paperSize = default_page_settings.PaperSize;
			int num;
			int num2;
			if (default_page_settings.Landscape)
			{
				num = paperSize.Height;
				num2 = paperSize.Width;
			}
			else
			{
				num = paperSize.Width;
				num2 = paperSize.Height;
			}
			GdipGetPostScriptGraphicsContext(filename, num * 72 / 100, num2 * 72 / 100, default_page_settings.PrinterResolution.X, default_page_settings.PrinterResolution.Y, ref graphics);
			DOCINFO dOCINFO = new DOCINFO
			{
				filename = filename,
				settings = settings,
				default_page_settings = default_page_settings
			};
			doc_info.Add(graphics, dOCINFO);
			return graphics;
		}

		[DllImport("libcups", CharSet = CharSet.Ansi)]
		private static extern int cupsGetDests(ref IntPtr dests);

		[DllImport("libcups")]
		private static extern void cupsFreeDests(int num_dests, IntPtr dests);

		[DllImport("libcups", CharSet = CharSet.Ansi)]
		private static extern IntPtr cupsTempFd(StringBuilder sb, int len);

		[DllImport("libcups", CharSet = CharSet.Ansi)]
		private static extern IntPtr cupsGetDefault();

		[DllImport("libcups", CharSet = CharSet.Ansi)]
		private static extern int cupsPrintFile(string printer, string filename, string title, int num_options, IntPtr options);

		[DllImport("libcups", CharSet = CharSet.Ansi)]
		private static extern IntPtr cupsGetPPD(string printer);

		[DllImport("libcups", CharSet = CharSet.Ansi)]
		private static extern IntPtr ppdOpenFile(string filename);

		[DllImport("libcups", CharSet = CharSet.Ansi)]
		private static extern IntPtr ppdFindOption(IntPtr ppd_file, string keyword);

		[DllImport("libcups")]
		private static extern void ppdClose(IntPtr ppd);

		[DllImport("libcups", CharSet = CharSet.Ansi)]
		private static extern int cupsParseOptions(string arg, int number_of_options, ref IntPtr options);

		[DllImport("libcups")]
		private static extern void cupsFreeOptions(int number_options, IntPtr options);

		[DllImport("gdiplus.dll", CharSet = CharSet.Ansi)]
		private static extern int GdipGetPostScriptGraphicsContext(string filename, int with, int height, double dpix, double dpiy, ref IntPtr graphics);

		[DllImport("gdiplus.dll")]
		private static extern int GdipGetPostScriptSavePage(IntPtr graphics);
	}
	internal class GlobalPrintingServicesUnix : GlobalPrintingServices
	{
		internal override PrinterSettings.StringCollection InstalledPrinters => PrintingServicesUnix.InstalledPrinters;

		internal override IntPtr CreateGraphicsContext(PrinterSettings settings, PageSettings default_page_settings)
		{
			return PrintingServicesUnix.CreateGraphicsContext(settings, default_page_settings);
		}

		internal override bool StartDoc(GraphicsPrinter gr, string doc_name, string output_file)
		{
			return PrintingServicesUnix.StartDoc(gr, doc_name, output_file);
		}

		internal override bool EndDoc(GraphicsPrinter gr)
		{
			return PrintingServicesUnix.EndDoc(gr);
		}

		internal override bool StartPage(GraphicsPrinter gr)
		{
			return PrintingServicesUnix.StartPage(gr);
		}

		internal override bool EndPage(GraphicsPrinter gr)
		{
			return PrintingServicesUnix.EndPage(gr);
		}
	}
	internal class PrintingServicesWin32 : PrintingServices
	{
		internal struct PRINTER_INFO
		{
			public IntPtr pServerName;

			public IntPtr pPrinterName;

			public IntPtr pShareName;

			public IntPtr pPortName;

			public IntPtr pDriverName;

			public IntPtr pComment;

			public IntPtr pLocation;

			public IntPtr pDevMode;

			public IntPtr pSepFile;

			public IntPtr pPrintProcessor;

			public IntPtr pDatatype;

			public IntPtr pParameters;

			public IntPtr pSecurityDescriptor;

			public uint Attributes;

			public uint Priority;

			public uint DefaultPriority;

			public uint StartTime;

			public uint UntilTime;

			public uint Status;

			public uint cJobs;

			public uint AveragePPM;
		}

		internal struct DOCINFO
		{
			public int cbSize;

			public IntPtr lpszDocName;

			public IntPtr lpszOutput;

			public IntPtr lpszDatatype;

			public int fwType;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct DEVMODE
		{
			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string dmDeviceName;

			public short dmSpecVersion;

			public short dmDriverVersion;

			public short dmSize;

			public short dmDriverExtra;

			public int dmFields;

			public short dmOrientation;

			public short dmPaperSize;

			public short dmPaperLength;

			public short dmPaperWidth;

			public short dmScale;

			public short dmCopies;

			public short dmDefaultSource;

			public short dmPrintQuality;

			public short dmColor;

			public short dmDuplex;

			public short dmYResolution;

			public short dmTTOption;

			public short dmCollate;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string dmFormName;

			public short dmLogPixels;

			public short dmBitsPerPel;

			public int dmPelsWidth;

			public int dmPelsHeight;

			public int dmDisplayFlags;

			public int dmDisplayFrequency;

			public int dmICMMethod;

			public int dmICMIntent;

			public int dmMediaType;

			public int dmDitherType;

			public int dmReserved1;

			public int dmReserved2;

			public int dmPanningWidth;

			public int dmPanningHeight;
		}

		internal enum DCCapabilities : short
		{
			DC_FIELDS = 1,
			DC_PAPERS,
			DC_PAPERSIZE,
			DC_MINEXTENT,
			DC_MAXEXTENT,
			DC_BINS,
			DC_DUPLEX,
			DC_SIZE,
			DC_EXTRA,
			DC_VERSION,
			DC_DRIVER,
			DC_BINNAMES,
			DC_ENUMRESOLUTIONS,
			DC_FILEDEPENDENCIES,
			DC_TRUETYPE,
			DC_PAPERNAMES,
			DC_ORIENTATION,
			DC_COPIES,
			DC_BINADJUST,
			DC_EMF_COMPLIANT,
			DC_DATATYPE_PRODUCED,
			DC_COLLATE,
			DC_MANUFACTURER,
			DC_MODEL,
			DC_PERSONALITY,
			DC_PRINTRATE,
			DC_PRINTRATEUNIT,
			DC_PRINTERMEM,
			DC_MEDIAREADY,
			DC_STAPLE,
			DC_PRINTRATEPPM,
			DC_COLORDEVICE,
			DC_NUP
		}

		[Flags]
		internal enum PrinterStatus : uint
		{
			PS_PAUSED = 1u,
			PS_ERROR = 2u,
			PS_PENDING_DELETION = 4u,
			PS_PAPER_JAM = 8u,
			PS_PAPER_OUT = 0x10u,
			PS_MANUAL_FEED = 0x20u,
			PS_PAPER_PROBLEM = 0x40u,
			PS_OFFLINE = 0x80u,
			PS_IO_ACTIVE = 0x100u,
			PS_BUSY = 0x200u,
			PS_PRINTING = 0x400u,
			PS_OUTPUT_BIN_FULL = 0x800u,
			PS_NOT_AVAILABLE = 0x1000u,
			PS_WAITING = 0x2000u,
			PS_PROCESSING = 0x4000u,
			PS_INITIALIZING = 0x8000u,
			PS_WARMING_UP = 0x10000u,
			PS_TONER_LOW = 0x20000u,
			PS_NO_TONER = 0x40000u,
			PS_PAGE_PUNT = 0x80000u,
			PS_USER_INTERVENTION = 0x100000u,
			PS_OUT_OF_MEMORY = 0x200000u,
			PS_DOOR_OPEN = 0x400000u,
			PS_SERVER_UNKNOWN = 0x800000u,
			PS_POWER_SAVE = 0x1000000u
		}

		internal enum DevCapabilities
		{
			TECHNOLOGY = 2
		}

		internal enum PrinterType
		{
			DT_PLOTTER,
			DT_RASDIPLAY,
			DT_RASPRINTER,
			DT_RASCAMERA,
			DT_CHARSTREAM,
			DT_METAFILE,
			DT_DISPFILE
		}

		[Flags]
		internal enum EnumPrinters : uint
		{
			PRINTER_ENUM_DEFAULT = 1u,
			PRINTER_ENUM_LOCAL = 2u,
			PRINTER_ENUM_CONNECTIONS = 4u,
			PRINTER_ENUM_FAVORITE = 4u,
			PRINTER_ENUM_NAME = 8u,
			PRINTER_ENUM_REMOTE = 0x10u,
			PRINTER_ENUM_SHARED = 0x20u,
			PRINTER_ENUM_NETWORK = 0x40u
		}

		private bool is_printer_valid;

		internal override string DefaultPrinter
		{
			get
			{
				StringBuilder stringBuilder = new StringBuilder(1024);
				int bufferSize = stringBuilder.Capacity;
				if (Win32GetDefaultPrinter(stringBuilder, ref bufferSize) > 0 && IsPrinterValid(stringBuilder.ToString()))
				{
					return stringBuilder.ToString();
				}
				return string.Empty;
			}
		}

		internal static PrinterSettings.StringCollection InstalledPrinters
		{
			get
			{
				PrinterSettings.StringCollection stringCollection = new PrinterSettings.StringCollection(new string[0]);
				uint pcbNeeded = 0u;
				uint pcReturned = 0u;
				Win32EnumPrinters(6, null, 2u, IntPtr.Zero, 0u, ref pcbNeeded, ref pcReturned);
				if (pcbNeeded == 0)
				{
					return stringCollection;
				}
				IntPtr intPtr;
				IntPtr ptr = (intPtr = Marshal.AllocHGlobal((int)pcbNeeded));
				try
				{
					Win32EnumPrinters(6, null, 2u, intPtr, pcbNeeded, ref pcbNeeded, ref pcReturned);
					for (int i = 0; i < pcReturned; i++)
					{
						PRINTER_INFO structure = (PRINTER_INFO)Marshal.PtrToStructure(ptr, typeof(PRINTER_INFO));
						string value = Marshal.PtrToStringUni(structure.pPrinterName);
						stringCollection.Add(value);
						ptr = new IntPtr(ptr.ToInt64() + Marshal.SizeOf(structure));
					}
					return stringCollection;
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		internal PrintingServicesWin32()
		{
		}

		internal override bool IsPrinterValid(string printer)
		{
			if ((printer == null) | (printer == string.Empty))
			{
				return false;
			}
			int num = Win32DocumentProperties(IntPtr.Zero, IntPtr.Zero, printer, IntPtr.Zero, IntPtr.Zero, 0);
			is_printer_valid = num > 0;
			return is_printer_valid;
		}

		internal override void LoadPrinterSettings(string printer, PrinterSettings settings)
		{
			IntPtr phPrinter = IntPtr.Zero;
			IntPtr intPtr = IntPtr.Zero;
			settings.maximum_copies = Win32DeviceCapabilities(printer, null, DCCapabilities.DC_COPIES, IntPtr.Zero, IntPtr.Zero);
			int num = Win32DeviceCapabilities(printer, null, DCCapabilities.DC_DUPLEX, IntPtr.Zero, IntPtr.Zero);
			settings.can_duplex = num == 1;
			num = Win32DeviceCapabilities(printer, null, DCCapabilities.DC_COLORDEVICE, IntPtr.Zero, IntPtr.Zero);
			settings.supports_color = num == 1;
			num = Win32DeviceCapabilities(printer, null, DCCapabilities.DC_ORIENTATION, IntPtr.Zero, IntPtr.Zero);
			if (num != -1)
			{
				settings.landscape_angle = num;
			}
			_ = IntPtr.Zero;
			IntPtr hDc = Win32CreateIC(null, printer, null, IntPtr.Zero);
			num = Win32GetDeviceCaps(hDc, 2);
			settings.is_plotter = num == 0;
			Win32DeleteDC(hDc);
			try
			{
				Win32OpenPrinter(printer, out phPrinter, IntPtr.Zero);
				num = Win32DocumentProperties(IntPtr.Zero, phPrinter, null, IntPtr.Zero, IntPtr.Zero, 0);
				if (num < 0)
				{
					return;
				}
				intPtr = Marshal.AllocHGlobal(num);
				num = Win32DocumentProperties(IntPtr.Zero, phPrinter, null, intPtr, IntPtr.Zero, 2);
				DEVMODE dEVMODE = (DEVMODE)Marshal.PtrToStructure(intPtr, typeof(DEVMODE));
				LoadPrinterPaperSizes(printer, settings);
				foreach (PaperSize paperSize in settings.PaperSizes)
				{
					if (paperSize.Kind == (PaperKind)dEVMODE.dmPaperSize)
					{
						settings.DefaultPageSettings.PaperSize = paperSize;
						break;
					}
				}
				LoadPrinterPaperSources(printer, settings);
				foreach (PaperSource paperSource in settings.PaperSources)
				{
					if (paperSource.Kind == (PaperSourceKind)dEVMODE.dmDefaultSource)
					{
						settings.DefaultPageSettings.PaperSource = paperSource;
						break;
					}
				}
			}
			finally
			{
				Win32ClosePrinter(phPrinter);
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		internal override void LoadPrinterResolutions(string printer, PrinterSettings settings)
		{
			IntPtr zero = IntPtr.Zero;
			settings.PrinterResolutions.Clear();
			LoadDefaultResolutions(settings.PrinterResolutions);
			int num = Win32DeviceCapabilities(printer, null, DCCapabilities.DC_ENUMRESOLUTIONS, IntPtr.Zero, IntPtr.Zero);
			if (num == -1)
			{
				return;
			}
			IntPtr ptr = (zero = Marshal.AllocHGlobal(num * 2 * Marshal.SizeOf(zero)));
			num = Win32DeviceCapabilities(printer, null, DCCapabilities.DC_ENUMRESOLUTIONS, zero, IntPtr.Zero);
			if (num != -1)
			{
				for (int i = 0; i < num; i++)
				{
					int num2 = Marshal.ReadInt32(ptr);
					ptr = new IntPtr(ptr.ToInt64() + Marshal.SizeOf(num2));
					int num3 = Marshal.ReadInt32(ptr);
					ptr = new IntPtr(ptr.ToInt64() + Marshal.SizeOf(num3));
					settings.PrinterResolutions.Add(new PrinterResolution(PrinterResolutionKind.Custom, num2, num3));
				}
			}
			Marshal.FreeHGlobal(zero);
		}

		private void LoadPrinterPaperSizes(string printer, PrinterSettings settings)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			if (settings.PaperSizes == null)
			{
				settings.paper_sizes = new PrinterSettings.PaperSizeCollection(new PaperSize[0]);
			}
			else
			{
				settings.PaperSizes.Clear();
			}
			int num = Win32DeviceCapabilities(printer, null, DCCapabilities.DC_PAPERSIZE, IntPtr.Zero, IntPtr.Zero);
			if (num == -1)
			{
				return;
			}
			try
			{
				IntPtr ptr = (intPtr2 = Marshal.AllocHGlobal(num * 2 * 4));
				IntPtr ptr2 = (intPtr = Marshal.AllocHGlobal(num * 64 * 2));
				IntPtr ptr3 = (intPtr3 = Marshal.AllocHGlobal(num * 2));
				int num2 = Win32DeviceCapabilities(printer, null, DCCapabilities.DC_PAPERSIZE, intPtr2, IntPtr.Zero);
				if (num2 != -1)
				{
					num2 = Win32DeviceCapabilities(printer, null, DCCapabilities.DC_PAPERS, intPtr3, IntPtr.Zero);
					num2 = Win32DeviceCapabilities(printer, null, DCCapabilities.DC_PAPERNAMES, intPtr, IntPtr.Zero);
					for (int i = 0; i < num2; i++)
					{
						int value = Marshal.ReadInt32(ptr, i * 8);
						int value2 = Marshal.ReadInt32(ptr, i * 8 + 4);
						value = PrinterUnitConvert.Convert(value, PrinterUnit.TenthsOfAMillimeter, PrinterUnit.Display);
						value2 = PrinterUnitConvert.Convert(value2, PrinterUnit.TenthsOfAMillimeter, PrinterUnit.Display);
						string name = Marshal.PtrToStringUni(ptr2);
						ptr2 = new IntPtr(ptr2.ToInt64() + 128);
						PaperKind rawKind = (PaperKind)Marshal.ReadInt16(ptr3);
						ptr3 = new IntPtr(ptr3.ToInt64() + 2);
						PaperSize paperSize = new PaperSize(name, value, value2);
						paperSize.RawKind = (int)rawKind;
						settings.PaperSizes.Add(paperSize);
					}
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
				if (intPtr3 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr3);
				}
			}
		}

		internal static bool StartDoc(GraphicsPrinter gr, string doc_name, string output_file)
		{
			DOCINFO lpdi = default(DOCINFO);
			lpdi.cbSize = Marshal.SizeOf(lpdi);
			lpdi.lpszDocName = Marshal.StringToHGlobalUni(doc_name);
			lpdi.lpszOutput = IntPtr.Zero;
			lpdi.lpszDatatype = IntPtr.Zero;
			lpdi.fwType = 0;
			int num = Win32StartDoc(gr.Hdc, ref lpdi);
			Marshal.FreeHGlobal(lpdi.lpszDocName);
			if (num <= 0)
			{
				return false;
			}
			return true;
		}

		private void LoadPrinterPaperSources(string printer, PrinterSettings settings)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			if (settings.PaperSources == null)
			{
				settings.paper_sources = new PrinterSettings.PaperSourceCollection(new PaperSource[0]);
			}
			else
			{
				settings.PaperSources.Clear();
			}
			int num = Win32DeviceCapabilities(printer, null, DCCapabilities.DC_BINNAMES, IntPtr.Zero, IntPtr.Zero);
			if (num == -1)
			{
				return;
			}
			try
			{
				IntPtr ptr = (intPtr = Marshal.AllocHGlobal(num * 2 * 24));
				IntPtr ptr2 = (intPtr2 = Marshal.AllocHGlobal(num * 2));
				int num2 = Win32DeviceCapabilities(printer, null, DCCapabilities.DC_BINNAMES, intPtr, IntPtr.Zero);
				if (num2 != -1)
				{
					num2 = Win32DeviceCapabilities(printer, null, DCCapabilities.DC_BINS, intPtr2, IntPtr.Zero);
					for (int i = 0; i < num2; i++)
					{
						string name = Marshal.PtrToStringUni(ptr);
						PaperSourceKind kind = (PaperSourceKind)Marshal.ReadInt16(ptr2);
						settings.PaperSources.Add(new PaperSource(kind, name));
						ptr = new IntPtr(ptr.ToInt64() + 48);
						ptr2 = new IntPtr(ptr2.ToInt64() + 2);
					}
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		internal static bool StartPage(GraphicsPrinter gr)
		{
			if (Win32StartPage(gr.Hdc) <= 0)
			{
				return false;
			}
			return true;
		}

		internal static bool EndPage(GraphicsPrinter gr)
		{
			if (Win32EndPage(gr.Hdc) <= 0)
			{
				return false;
			}
			return true;
		}

		internal static bool EndDoc(GraphicsPrinter gr)
		{
			int num = Win32EndDoc(gr.Hdc);
			Win32DeleteDC(gr.Hdc);
			gr.Graphics.Dispose();
			if (num <= 0)
			{
				return false;
			}
			return true;
		}

		internal static IntPtr CreateGraphicsContext(PrinterSettings settings, PageSettings default_page_settings)
		{
			_ = IntPtr.Zero;
			return Win32CreateDC(null, settings.PrinterName, null, IntPtr.Zero);
		}

		internal override void GetPrintDialogInfo(string printer, ref string port, ref string type, ref string status, ref string comment)
		{
			PRINTER_INFO pRINTER_INFO = default(PRINTER_INFO);
			int dwNeeded = 0;
			Win32OpenPrinter(printer, out var phPrinter, IntPtr.Zero);
			if (!(phPrinter == IntPtr.Zero))
			{
				Win32GetPrinter(phPrinter, 2, IntPtr.Zero, 0, ref dwNeeded);
				IntPtr intPtr = Marshal.AllocHGlobal(dwNeeded);
				Win32GetPrinter(phPrinter, 2, intPtr, dwNeeded, ref dwNeeded);
				pRINTER_INFO = (PRINTER_INFO)Marshal.PtrToStructure(intPtr, typeof(PRINTER_INFO));
				Marshal.FreeHGlobal(intPtr);
				port = Marshal.PtrToStringUni(pRINTER_INFO.pPortName);
				comment = Marshal.PtrToStringUni(pRINTER_INFO.pComment);
				type = Marshal.PtrToStringUni(pRINTER_INFO.pDriverName);
				status = GetPrinterStatusMsg(pRINTER_INFO.Status);
				Win32ClosePrinter(phPrinter);
			}
		}

		private string GetPrinterStatusMsg(uint status)
		{
			string text = string.Empty;
			if (status == 0)
			{
				return "Ready";
			}
			if ((status & 1) != 0)
			{
				text += "Paused; ";
			}
			if ((status & 2) != 0)
			{
				text += "Error; ";
			}
			if ((status & 4) != 0)
			{
				text += "Pending deletion; ";
			}
			if ((status & 8) != 0)
			{
				text += "Paper jam; ";
			}
			if ((status & 0x10) != 0)
			{
				text += "Paper out; ";
			}
			if ((status & 0x20) != 0)
			{
				text += "Manual feed; ";
			}
			if ((status & 0x40) != 0)
			{
				text += "Paper problem; ";
			}
			if ((status & 0x80) != 0)
			{
				text += "Offline; ";
			}
			if ((status & 0x100) != 0)
			{
				text += "I/O active; ";
			}
			if ((status & 0x200) != 0)
			{
				text += "Busy; ";
			}
			if ((status & 0x400) != 0)
			{
				text += "Printing; ";
			}
			if ((status & 0x800) != 0)
			{
				text += "Output bin full; ";
			}
			if ((status & 0x1000) != 0)
			{
				text += "Not available; ";
			}
			if ((status & 0x2000) != 0)
			{
				text += "Waiting; ";
			}
			if ((status & 0x4000) != 0)
			{
				text += "Processing; ";
			}
			if ((status & 0x8000) != 0)
			{
				text += "Initializing; ";
			}
			if ((status & 0x10000) != 0)
			{
				text += "Warming up; ";
			}
			if ((status & 0x20000) != 0)
			{
				text += "Toner low; ";
			}
			if ((status & 0x40000) != 0)
			{
				text += "No toner; ";
			}
			if ((status & 0x80000) != 0)
			{
				text += "Page punt; ";
			}
			if ((status & 0x100000) != 0)
			{
				text += "User intervention; ";
			}
			if ((status & 0x200000) != 0)
			{
				text += "Out of memory; ";
			}
			if ((status & 0x400000) != 0)
			{
				text += "Door open; ";
			}
			if ((status & 0x800000) != 0)
			{
				text += "Server unkown; ";
			}
			if ((status & 0x1000000) != 0)
			{
				text += "Power save; ";
			}
			return text;
		}

		[DllImport("winspool.drv", CharSet = CharSet.Unicode, EntryPoint = "OpenPrinter", SetLastError = true)]
		private static extern int Win32OpenPrinter(string pPrinterName, out IntPtr phPrinter, IntPtr pDefault);

		[DllImport("winspool.drv", CharSet = CharSet.Unicode, EntryPoint = "GetPrinter", SetLastError = true)]
		private static extern int Win32GetPrinter(IntPtr hPrinter, int level, IntPtr dwBuf, int size, ref int dwNeeded);

		[DllImport("winspool.drv", CharSet = CharSet.Unicode, EntryPoint = "ClosePrinter", SetLastError = true)]
		private static extern int Win32ClosePrinter(IntPtr hPrinter);

		[DllImport("winspool.drv", CharSet = CharSet.Unicode, EntryPoint = "DeviceCapabilities", SetLastError = true)]
		private static extern int Win32DeviceCapabilities(string device, string port, DCCapabilities cap, IntPtr outputBuffer, IntPtr deviceMode);

		[DllImport("winspool.drv", CharSet = CharSet.Unicode, EntryPoint = "EnumPrinters", SetLastError = true)]
		private static extern int Win32EnumPrinters(int Flags, string Name, uint Level, IntPtr pPrinterEnum, uint cbBuf, ref uint pcbNeeded, ref uint pcReturned);

		[DllImport("winspool.drv", CharSet = CharSet.Unicode, EntryPoint = "GetDefaultPrinter", SetLastError = true)]
		private static extern int Win32GetDefaultPrinter(StringBuilder buffer, ref int bufferSize);

		[DllImport("winspool.drv", CharSet = CharSet.Unicode, EntryPoint = "DocumentProperties", SetLastError = true)]
		private static extern int Win32DocumentProperties(IntPtr hwnd, IntPtr hPrinter, string pDeviceName, IntPtr pDevModeOutput, IntPtr pDevModeInput, int fMode);

		[DllImport("gdi32.dll", EntryPoint = "CreateDC")]
		private static extern IntPtr Win32CreateDC(string lpszDriver, string lpszDevice, string lpszOutput, IntPtr lpInitData);

		[DllImport("gdi32.dll", EntryPoint = "CreateIC")]
		private static extern IntPtr Win32CreateIC(string lpszDriver, string lpszDevice, string lpszOutput, IntPtr lpInitData);

		[DllImport("gdi32.dll", CharSet = CharSet.Unicode, EntryPoint = "StartDoc")]
		private static extern int Win32StartDoc(IntPtr hdc, [In] ref DOCINFO lpdi);

		[DllImport("gdi32.dll", EntryPoint = "StartPage")]
		private static extern int Win32StartPage(IntPtr hDC);

		[DllImport("gdi32.dll", EntryPoint = "EndPage")]
		private static extern int Win32EndPage(IntPtr hdc);

		[DllImport("gdi32.dll", EntryPoint = "EndDoc")]
		private static extern int Win32EndDoc(IntPtr hdc);

		[DllImport("gdi32.dll", EntryPoint = "DeleteDC")]
		public static extern IntPtr Win32DeleteDC(IntPtr hDc);

		[DllImport("gdi32.dll", EntryPoint = "GetDeviceCaps")]
		public static extern int Win32GetDeviceCaps(IntPtr hDc, int index);
	}
	internal class GlobalPrintingServicesWin32 : GlobalPrintingServices
	{
		internal override PrinterSettings.StringCollection InstalledPrinters => PrintingServicesWin32.InstalledPrinters;

		internal override IntPtr CreateGraphicsContext(PrinterSettings settings, PageSettings default_page_settings)
		{
			return PrintingServicesWin32.CreateGraphicsContext(settings, default_page_settings);
		}

		internal override bool StartDoc(GraphicsPrinter gr, string doc_name, string output_file)
		{
			return PrintingServicesWin32.StartDoc(gr, doc_name, output_file);
		}

		internal override bool EndDoc(GraphicsPrinter gr)
		{
			return PrintingServicesWin32.EndDoc(gr);
		}

		internal override bool StartPage(GraphicsPrinter gr)
		{
			return PrintingServicesWin32.StartPage(gr);
		}

		internal override bool EndPage(GraphicsPrinter gr)
		{
			return PrintingServicesWin32.EndPage(gr);
		}
	}
	/// <summary>Specifies a print controller that sends information to a printer.</summary>
	public class StandardPrintController : PrintController
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.StandardPrintController" /> class.</summary>
		public StandardPrintController()
		{
		}

		/// <summary>Completes the control sequence that determines when and how to print a page of a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains data about how to print a page in the document.</param>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The native Win32 Application Programming Interface (API) could not finish writing to a page.</exception>
		public override void OnEndPage(PrintDocument document, PrintPageEventArgs e)
		{
			SysPrn.GlobalService.EndPage(e.GraphicsContext);
		}

		/// <summary>Begins the control sequence that determines when and how to print a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains data about how to print the document.</param>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer settings are not valid.</exception>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The native Win32 Application Programming Interface (API) could not start a print job.</exception>
		public override void OnStartPrint(PrintDocument document, PrintEventArgs e)
		{
			IntPtr dc = SysPrn.GlobalService.CreateGraphicsContext(document.PrinterSettings, document.DefaultPageSettings);
			e.GraphicsContext = new GraphicsPrinter(null, dc);
			SysPrn.GlobalService.StartDoc(e.GraphicsContext, document.DocumentName, string.Empty);
		}

		/// <summary>Completes the control sequence that determines when and how to print a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains data about how to print the document.</param>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The native Win32 Application Programming Interface (API) could not complete the print job.  
		///  -or-  
		///  The native Win32 API could not delete the specified device context (DC).</exception>
		public override void OnEndPrint(PrintDocument document, PrintEventArgs e)
		{
			SysPrn.GlobalService.EndDoc(e.GraphicsContext);
		}

		/// <summary>Begins the control sequence that determines when and how to print a page in a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains data about how to print a page in the document. Initially, the <see cref="P:System.Drawing.Printing.PrintPageEventArgs.Graphics" /> property of this parameter will be <see langword="null" />. The value returned from the <see cref="M:System.Drawing.Printing.StandardPrintController.OnStartPage(System.Drawing.Printing.PrintDocument,System.Drawing.Printing.PrintPageEventArgs)" /> method will be used to set this property.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> object that represents a page from a <see cref="T:System.Drawing.Printing.PrintDocument" />.</returns>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The native Win32 Application Programming Interface (API) could not prepare the printer driver to accept data.  
		///  -or-  
		///  The native Win32 API could not update the specified printer or plotter device context (DC) using the specified information.</exception>
		public override Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e)
		{
			SysPrn.GlobalService.StartPage(e.GraphicsContext);
			return e.Graphics;
		}
	}
}
namespace System.Drawing.Internal
{
	[StructLayout(LayoutKind.Sequential)]
	internal class GPPOINT
	{
		internal int X;

		internal int Y;

		internal GPPOINT()
		{
		}

		internal GPPOINT(Point pt)
		{
			X = pt.X;
			Y = pt.Y;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class GPPOINTF
	{
		internal float X;

		internal float Y;

		internal GPPOINTF()
		{
		}

		internal GPPOINTF(PointF pt)
		{
			X = pt.X;
			Y = pt.Y;
		}

		internal PointF ToPoint()
		{
			return new PointF(X, Y);
		}
	}
	internal struct GPRECT
	{
		internal int X;

		internal int Y;

		internal int Width;

		internal int Height;

		internal GPRECT(int x, int y, int width, int height)
		{
			X = x;
			Y = y;
			Width = width;
			Height = height;
		}

		internal GPRECT(Rectangle rect)
		{
			X = rect.X;
			Y = rect.Y;
			Width = rect.Width;
			Height = rect.Height;
		}
	}
	internal struct GPRECTF
	{
		internal float X;

		internal float Y;

		internal float Width;

		internal float Height;

		internal SizeF SizeF => new SizeF(Width, Height);

		internal GPRECTF(float x, float y, float width, float height)
		{
			X = x;
			Y = y;
			Width = width;
			Height = height;
		}

		internal GPRECTF(RectangleF rect)
		{
			X = rect.X;
			Y = rect.Y;
			Width = rect.Width;
			Height = rect.Height;
		}

		internal RectangleF ToRectangleF()
		{
			return new RectangleF(X, Y, Width, Height);
		}
	}
}
namespace System.Drawing.Imaging
{
	/// <summary>Specifies which GDI+ objects use color adjustment information.</summary>
	public enum ColorAdjustType
	{
		/// <summary>Color adjustment information that is used by all GDI+ objects that do not have their own color adjustment information.</summary>
		Default,
		/// <summary>Color adjustment information for <see cref="T:System.Drawing.Bitmap" /> objects.</summary>
		Bitmap,
		/// <summary>Color adjustment information for <see cref="T:System.Drawing.Brush" /> objects.</summary>
		Brush,
		/// <summary>Color adjustment information for <see cref="T:System.Drawing.Pen" /> objects.</summary>
		Pen,
		/// <summary>Color adjustment information for text.</summary>
		Text,
		/// <summary>The number of types specified.</summary>
		Count,
		/// <summary>The number of types specified.</summary>
		Any
	}
	/// <summary>Specifies individual channels in the CMYK (cyan, magenta, yellow, black) color space. This enumeration is used by the <see cref="Overload:System.Drawing.Imaging.ImageAttributes.SetOutputChannel" /> methods.</summary>
	public enum ColorChannelFlag
	{
		/// <summary>The cyan color channel.</summary>
		ColorChannelC,
		/// <summary>The magenta color channel.</summary>
		ColorChannelM,
		/// <summary>The yellow color channel.</summary>
		ColorChannelY,
		/// <summary>The black color channel.</summary>
		ColorChannelK,
		/// <summary>The last selected channel should be used.</summary>
		ColorChannelLast
	}
	/// <summary>Defines a map for converting colors. Several methods of the <see cref="T:System.Drawing.Imaging.ImageAttributes" /> class adjust image colors by using a color-remap table, which is an array of <see cref="T:System.Drawing.Imaging.ColorMap" /> structures. Not inheritable.</summary>
	public sealed class ColorMap
	{
		private Color _oldColor;

		private Color _newColor;

		/// <summary>Gets or sets the existing <see cref="T:System.Drawing.Color" /> structure to be converted.</summary>
		/// <returns>The existing <see cref="T:System.Drawing.Color" /> structure to be converted.</returns>
		public Color OldColor
		{
			get
			{
				return _oldColor;
			}
			set
			{
				_oldColor = value;
			}
		}

		/// <summary>Gets or sets the new <see cref="T:System.Drawing.Color" /> structure to which to convert.</summary>
		/// <returns>The new <see cref="T:System.Drawing.Color" /> structure to which to convert.</returns>
		public Color NewColor
		{
			get
			{
				return _newColor;
			}
			set
			{
				_newColor = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.ColorMap" /> class.</summary>
		public ColorMap()
		{
			_oldColor = default(Color);
			_newColor = default(Color);
		}
	}
	/// <summary>Specifies the types of color maps.</summary>
	public enum ColorMapType
	{
		/// <summary>A default color map.</summary>
		Default,
		/// <summary>Specifies a color map for a <see cref="T:System.Drawing.Brush" />.</summary>
		Brush
	}
	/// <summary>Defines a 5 x 5 matrix that contains the coordinates for the RGBAW space. Several methods of the <see cref="T:System.Drawing.Imaging.ImageAttributes" /> class adjust image colors by using a color matrix. This class cannot be inherited.</summary>
	[StructLayout(LayoutKind.Sequential)]
	public sealed class ColorMatrix
	{
		private float _matrix00;

		private float _matrix01;

		private float _matrix02;

		private float _matrix03;

		private float _matrix04;

		private float _matrix10;

		private float _matrix11;

		private float _matrix12;

		private float _matrix13;

		private float _matrix14;

		private float _matrix20;

		private float _matrix21;

		private float _matrix22;

		private float _matrix23;

		private float _matrix24;

		private float _matrix30;

		private float _matrix31;

		private float _matrix32;

		private float _matrix33;

		private float _matrix34;

		private float _matrix40;

		private float _matrix41;

		private float _matrix42;

		private float _matrix43;

		private float _matrix44;

		/// <summary>Gets or sets the element at the 0 (zero) row and 0 column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the 0 row and 0 column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix00
		{
			get
			{
				return _matrix00;
			}
			set
			{
				_matrix00 = value;
			}
		}

		/// <summary>Gets or sets the element at the 0 (zero) row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the 0 row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" /> .</returns>
		public float Matrix01
		{
			get
			{
				return _matrix01;
			}
			set
			{
				_matrix01 = value;
			}
		}

		/// <summary>Gets or sets the element at the 0 (zero) row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the 0 row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix02
		{
			get
			{
				return _matrix02;
			}
			set
			{
				_matrix02 = value;
			}
		}

		/// <summary>Gets or sets the element at the 0 (zero) row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />. Represents the alpha component.</summary>
		/// <returns>The element at the 0 row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix03
		{
			get
			{
				return _matrix03;
			}
			set
			{
				_matrix03 = value;
			}
		}

		/// <summary>Gets or sets the element at the 0 (zero) row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the 0 row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix04
		{
			get
			{
				return _matrix04;
			}
			set
			{
				_matrix04 = value;
			}
		}

		/// <summary>Gets or sets the element at the first row and 0 (zero) column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the first row and 0 column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix10
		{
			get
			{
				return _matrix10;
			}
			set
			{
				_matrix10 = value;
			}
		}

		/// <summary>Gets or sets the element at the first row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the first row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix11
		{
			get
			{
				return _matrix11;
			}
			set
			{
				_matrix11 = value;
			}
		}

		/// <summary>Gets or sets the element at the first row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the first row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix12
		{
			get
			{
				return _matrix12;
			}
			set
			{
				_matrix12 = value;
			}
		}

		/// <summary>Gets or sets the element at the first row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />. Represents the alpha component.</summary>
		/// <returns>The element at the first row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix13
		{
			get
			{
				return _matrix13;
			}
			set
			{
				_matrix13 = value;
			}
		}

		/// <summary>Gets or sets the element at the first row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the first row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix14
		{
			get
			{
				return _matrix14;
			}
			set
			{
				_matrix14 = value;
			}
		}

		/// <summary>Gets or sets the element at the second row and 0 (zero) column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the second row and 0 column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix20
		{
			get
			{
				return _matrix20;
			}
			set
			{
				_matrix20 = value;
			}
		}

		/// <summary>Gets or sets the element at the second row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the second row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix21
		{
			get
			{
				return _matrix21;
			}
			set
			{
				_matrix21 = value;
			}
		}

		/// <summary>Gets or sets the element at the second row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the second row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix22
		{
			get
			{
				return _matrix22;
			}
			set
			{
				_matrix22 = value;
			}
		}

		/// <summary>Gets or sets the element at the second row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the second row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix23
		{
			get
			{
				return _matrix23;
			}
			set
			{
				_matrix23 = value;
			}
		}

		/// <summary>Gets or sets the element at the second row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the second row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix24
		{
			get
			{
				return _matrix24;
			}
			set
			{
				_matrix24 = value;
			}
		}

		/// <summary>Gets or sets the element at the third row and 0 (zero) column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the third row and 0 column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix30
		{
			get
			{
				return _matrix30;
			}
			set
			{
				_matrix30 = value;
			}
		}

		/// <summary>Gets or sets the element at the third row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the third row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix31
		{
			get
			{
				return _matrix31;
			}
			set
			{
				_matrix31 = value;
			}
		}

		/// <summary>Gets or sets the element at the third row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the third row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix32
		{
			get
			{
				return _matrix32;
			}
			set
			{
				_matrix32 = value;
			}
		}

		/// <summary>Gets or sets the element at the third row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />. Represents the alpha component.</summary>
		/// <returns>The element at the third row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix33
		{
			get
			{
				return _matrix33;
			}
			set
			{
				_matrix33 = value;
			}
		}

		/// <summary>Gets or sets the element at the third row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the third row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix34
		{
			get
			{
				return _matrix34;
			}
			set
			{
				_matrix34 = value;
			}
		}

		/// <summary>Gets or sets the element at the fourth row and 0 (zero) column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the fourth row and 0 column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix40
		{
			get
			{
				return _matrix40;
			}
			set
			{
				_matrix40 = value;
			}
		}

		/// <summary>Gets or sets the element at the fourth row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the fourth row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix41
		{
			get
			{
				return _matrix41;
			}
			set
			{
				_matrix41 = value;
			}
		}

		/// <summary>Gets or sets the element at the fourth row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the fourth row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix42
		{
			get
			{
				return _matrix42;
			}
			set
			{
				_matrix42 = value;
			}
		}

		/// <summary>Gets or sets the element at the fourth row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />. Represents the alpha component.</summary>
		/// <returns>The element at the fourth row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix43
		{
			get
			{
				return _matrix43;
			}
			set
			{
				_matrix43 = value;
			}
		}

		/// <summary>Gets or sets the element at the fourth row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the fourth row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix44
		{
			get
			{
				return _matrix44;
			}
			set
			{
				_matrix44 = value;
			}
		}

		/// <summary>Gets or sets the element at the specified row and column in the <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <param name="row">The row of the element.</param>
		/// <param name="column">The column of the element.</param>
		/// <returns>The element at the specified row and column.</returns>
		public float this[int row, int column]
		{
			get
			{
				return GetMatrix()[row][column];
			}
			set
			{
				float[][] matrix = GetMatrix();
				matrix[row][column] = value;
				SetMatrix(matrix);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.ColorMatrix" /> class.</summary>
		public ColorMatrix()
		{
			_matrix00 = 1f;
			_matrix11 = 1f;
			_matrix22 = 1f;
			_matrix33 = 1f;
			_matrix44 = 1f;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.ColorMatrix" /> class using the elements in the specified matrix <paramref name="newColorMatrix" />.</summary>
		/// <param name="newColorMatrix">The values of the elements for the new <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</param>
		[CLSCompliant(false)]
		public ColorMatrix(float[][] newColorMatrix)
		{
			SetMatrix(newColorMatrix);
		}

		internal void SetMatrix(float[][] newColorMatrix)
		{
			_matrix00 = newColorMatrix[0][0];
			_matrix01 = newColorMatrix[0][1];
			_matrix02 = newColorMatrix[0][2];
			_matrix03 = newColorMatrix[0][3];
			_matrix04 = newColorMatrix[0][4];
			_matrix10 = newColorMatrix[1][0];
			_matrix11 = newColorMatrix[1][1];
			_matrix12 = newColorMatrix[1][2];
			_matrix13 = newColorMatrix[1][3];
			_matrix14 = newColorMatrix[1][4];
			_matrix20 = newColorMatrix[2][0];
			_matrix21 = newColorMatrix[2][1];
			_matrix22 = newColorMatrix[2][2];
			_matrix23 = newColorMatrix[2][3];
			_matrix24 = newColorMatrix[2][4];
			_matrix30 = newColorMatrix[3][0];
			_matrix31 = newColorMatrix[3][1];
			_matrix32 = newColorMatrix[3][2];
			_matrix33 = newColorMatrix[3][3];
			_matrix34 = newColorMatrix[3][4];
			_matrix40 = newColorMatrix[4][0];
			_matrix41 = newColorMatrix[4][1];
			_matrix42 = newColorMatrix[4][2];
			_matrix43 = newColorMatrix[4][3];
			_matrix44 = newColorMatrix[4][4];
		}

		internal float[][] GetMatrix()
		{
			float[][] array = new float[5][];
			for (int i = 0; i < 5; i++)
			{
				array[i] = new float[5];
			}
			array[0][0] = _matrix00;
			array[0][1] = _matrix01;
			array[0][2] = _matrix02;
			array[0][3] = _matrix03;
			array[0][4] = _matrix04;
			array[1][0] = _matrix10;
			array[1][1] = _matrix11;
			array[1][2] = _matrix12;
			array[1][3] = _matrix13;
			array[1][4] = _matrix14;
			array[2][0] = _matrix20;
			array[2][1] = _matrix21;
			array[2][2] = _matrix22;
			array[2][3] = _matrix23;
			array[2][4] = _matrix24;
			array[3][0] = _matrix30;
			array[3][1] = _matrix31;
			array[3][2] = _matrix32;
			array[3][3] = _matrix33;
			array[3][4] = _matrix34;
			array[4][0] = _matrix40;
			array[4][1] = _matrix41;
			array[4][2] = _matrix42;
			array[4][3] = _matrix43;
			array[4][4] = _matrix44;
			return array;
		}
	}
	/// <summary>Specifies the types of images and colors that will be affected by the color and grayscale adjustment settings of an <see cref="T:System.Drawing.Imaging.ImageAttributes" />.</summary>
	public enum ColorMatrixFlag
	{
		/// <summary>All color values, including gray shades, are adjusted by the same color-adjustment matrix.</summary>
		Default,
		/// <summary>All colors are adjusted, but gray shades are not adjusted. A gray shade is any color that has the same value for its red, green, and blue components.</summary>
		SkipGrays,
		/// <summary>Only gray shades are adjusted.</summary>
		AltGrays
	}
	/// <summary>Specifies two modes for color component values.</summary>
	public enum ColorMode
	{
		/// <summary>The integer values supplied are 32-bit values.</summary>
		Argb32Mode,
		/// <summary>The integer values supplied are 64-bit values.</summary>
		Argb64Mode
	}
	/// <summary>Defines an array of colors that make up a color palette. The colors are 32-bit ARGB colors. Not inheritable.</summary>
	public sealed class ColorPalette
	{
		private int _flags;

		private Color[] _entries;

		/// <summary>Gets a value that specifies how to interpret the color information in the array of colors.</summary>
		/// <returns>The following flag values are valid:  
		///  0x00000001 The color values in the array contain alpha information.  
		///  0x00000002 The colors in the array are grayscale values.  
		///  0x00000004 The colors in the array are halftone values.</returns>
		public int Flags => _flags;

		/// <summary>Gets an array of <see cref="T:System.Drawing.Color" /> structures.</summary>
		/// <returns>The array of <see cref="T:System.Drawing.Color" /> structure that make up this <see cref="T:System.Drawing.Imaging.ColorPalette" />.</returns>
		public Color[] Entries => _entries;

		internal ColorPalette(int count)
		{
			_entries = new Color[count];
		}

		internal ColorPalette()
		{
			_entries = new Color[1];
		}

		internal void ConvertFromMemory(IntPtr memory)
		{
			_flags = Marshal.ReadInt32(memory);
			int num = Marshal.ReadInt32((IntPtr)((long)memory + 4));
			_entries = new Color[num];
			for (int i = 0; i < num; i++)
			{
				int argb = Marshal.ReadInt32((IntPtr)((long)memory + 8 + i * 4));
				_entries[i] = Color.FromArgb(argb);
			}
		}

		internal IntPtr ConvertToMemory()
		{
			int num = _entries.Length;
			IntPtr intPtr;
			checked
			{
				intPtr = Marshal.AllocHGlobal(4 * (2 + num));
				Marshal.WriteInt32(intPtr, 0, _flags);
				Marshal.WriteInt32((IntPtr)((long)intPtr + 4), 0, num);
			}
			for (int i = 0; i < num; i++)
			{
				Marshal.WriteInt32((IntPtr)((long)intPtr + 4 * (i + 2)), 0, _entries[i].ToArgb());
			}
			return intPtr;
		}
	}
	internal enum EmfPlusFlags
	{
		Display = 1,
		NonDualGdi
	}
	/// <summary>Specifies the methods available for use with a metafile to read and write graphic commands.</summary>
	public enum EmfPlusRecordType
	{
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfRecordBase = 65536,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetBkColor = 66049,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetBkMode = 65794,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetMapMode = 65795,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetROP2 = 65796,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetRelAbs = 65797,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetPolyFillMode = 65798,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetStretchBltMode = 65799,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetTextCharExtra = 65800,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetTextColor = 66057,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetTextJustification = 66058,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetWindowOrg = 66059,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetWindowExt = 66060,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetViewportOrg = 66061,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetViewportExt = 66062,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfOffsetWindowOrg = 66063,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfScaleWindowExt = 66576,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfOffsetViewportOrg = 66065,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfScaleViewportExt = 66578,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfLineTo = 66067,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfMoveTo = 66068,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfExcludeClipRect = 66581,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfIntersectClipRect = 66582,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfArc = 67607,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfEllipse = 66584,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfFloodFill = 66585,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfPie = 67610,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfRectangle = 66587,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfRoundRect = 67100,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfPatBlt = 67101,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSaveDC = 65566,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetPixel = 66591,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfOffsetCilpRgn = 66080,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfTextOut = 66849,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfBitBlt = 67874,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfStretchBlt = 68387,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfPolygon = 66340,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfPolyline = 66341,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfEscape = 67110,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfRestoreDC = 65831,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfFillRegion = 66088,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfFrameRegion = 66601,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfInvertRegion = 65834,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfPaintRegion = 65835,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSelectClipRegion = 65836,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSelectObject = 65837,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetTextAlign = 65838,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfChord = 67632,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetMapperFlags = 66097,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfExtTextOut = 68146,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetDibToDev = 68915,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSelectPalette = 66100,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfRealizePalette = 65589,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfAnimatePalette = 66614,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetPalEntries = 65591,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfPolyPolygon = 66872,
		/// <summary>Increases or decreases the size of a logical palette based on the specified value.</summary>
		WmfResizePalette = 65849,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfDibBitBlt = 67904,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfDibStretchBlt = 68417,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfDibCreatePatternBrush = 65858,
		/// <summary>Copies the color data for a rectangle of pixels in a DIB to the specified destination rectangle.</summary>
		WmfStretchDib = 69443,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfExtFloodFill = 66888,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetLayout = 65865,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfDeleteObject = 66032,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfCreatePalette = 65783,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfCreatePatternBrush = 66041,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfCreatePenIndirect = 66298,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfCreateFontIndirect = 66299,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfCreateBrushIndirect = 66300,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfCreateRegion = 67327,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfHeader = 1,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyBezier = 2,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolygon = 3,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyline = 4,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyBezierTo = 5,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyLineTo = 6,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyPolyline = 7,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyPolygon = 8,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetWindowExtEx = 9,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetWindowOrgEx = 10,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetViewportExtEx = 11,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetViewportOrgEx = 12,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetBrushOrgEx = 13,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfEof = 14,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetPixelV = 15,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetMapperFlags = 16,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetMapMode = 17,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetBkMode = 18,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetPolyFillMode = 19,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetROP2 = 20,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetStretchBltMode = 21,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetTextAlign = 22,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetColorAdjustment = 23,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetTextColor = 24,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetBkColor = 25,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfOffsetClipRgn = 26,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfMoveToEx = 27,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetMetaRgn = 28,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExcludeClipRect = 29,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfIntersectClipRect = 30,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfScaleViewportExtEx = 31,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfScaleWindowExtEx = 32,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSaveDC = 33,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfRestoreDC = 34,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetWorldTransform = 35,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfModifyWorldTransform = 36,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSelectObject = 37,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCreatePen = 38,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCreateBrushIndirect = 39,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfDeleteObject = 40,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfAngleArc = 41,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfEllipse = 42,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfRectangle = 43,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfRoundRect = 44,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfRoundArc = 45,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfChord = 46,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPie = 47,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSelectPalette = 48,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCreatePalette = 49,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetPaletteEntries = 50,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfResizePalette = 51,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfRealizePalette = 52,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExtFloodFill = 53,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfLineTo = 54,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfArcTo = 55,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyDraw = 56,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetArcDirection = 57,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetMiterLimit = 58,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfBeginPath = 59,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfEndPath = 60,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCloseFigure = 61,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfFillPath = 62,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfStrokeAndFillPath = 63,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfStrokePath = 64,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfFlattenPath = 65,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfWidenPath = 66,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSelectClipPath = 67,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfAbortPath = 68,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfReserved069 = 69,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfGdiComment = 70,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfFillRgn = 71,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfFrameRgn = 72,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfInvertRgn = 73,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPaintRgn = 74,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExtSelectClipRgn = 75,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfBitBlt = 76,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfStretchBlt = 77,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfMaskBlt = 78,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPlgBlt = 79,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetDIBitsToDevice = 80,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfStretchDIBits = 81,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExtCreateFontIndirect = 82,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExtTextOutA = 83,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExtTextOutW = 84,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyBezier16 = 85,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolygon16 = 86,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyline16 = 87,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyBezierTo16 = 88,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolylineTo16 = 89,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyPolyline16 = 90,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyPolygon16 = 91,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyDraw16 = 92,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCreateMonoBrush = 93,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCreateDibPatternBrushPt = 94,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExtCreatePen = 95,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyTextOutA = 96,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyTextOutW = 97,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetIcmMode = 98,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCreateColorSpace = 99,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetColorSpace = 100,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfDeleteColorSpace = 101,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfGlsRecord = 102,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfGlsBoundedRecord = 103,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPixelFormat = 104,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfDrawEscape = 105,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExtEscape = 106,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfStartDoc = 107,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSmallTextOut = 108,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfForceUfiMapping = 109,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfNamedEscpae = 110,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfColorCorrectPalette = 111,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetIcmProfileA = 112,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetIcmProfileW = 113,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfAlphaBlend = 114,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetLayout = 115,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfTransparentBlt = 116,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfReserved117 = 117,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfGradientFill = 118,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetLinkedUfis = 119,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetTextJustification = 120,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfColorMatchToTargetW = 121,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCreateColorSpaceW = 122,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfMax = 122,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfMin = 1,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPlusRecordBase = 16384,
		/// <summary>Indicates invalid data.</summary>
		Invalid = 16384,
		/// <summary>Identifies a record that is the EMF+ header.</summary>
		Header = 16385,
		/// <summary>Identifies a record that marks the last EMF+ record of a metafile.</summary>
		EndOfFile = 16386,
		/// <summary>See <see cref="M:System.Drawing.Graphics.AddMetafileComment(System.Byte[])" />.</summary>
		Comment = 16387,
		/// <summary>See <see cref="M:System.Drawing.Graphics.GetHdc" />.</summary>
		GetDC = 16388,
		/// <summary>Marks the start of a multiple-format section.</summary>
		MultiFormatStart = 16389,
		/// <summary>Marks a multiple-format section.</summary>
		MultiFormatSection = 16390,
		/// <summary>Marks the end of a multiple-format section.</summary>
		MultiFormatEnd = 16391,
		/// <summary>Marks an object.</summary>
		Object = 16392,
		/// <summary>See <see cref="M:System.Drawing.Graphics.Clear(System.Drawing.Color)" />.</summary>
		Clear = 16393,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.FillRectangles" /> methods.</summary>
		FillRects = 16394,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawRectangles" /> methods.</summary>
		DrawRects = 16395,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.FillPolygon" /> methods.</summary>
		FillPolygon = 16396,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawLines" /> methods.</summary>
		DrawLines = 16397,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.FillEllipse" /> methods.</summary>
		FillEllipse = 16398,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawEllipse" /> methods.</summary>
		DrawEllipse = 16399,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.FillPie" /> methods.</summary>
		FillPie = 16400,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawPie" /> methods.</summary>
		DrawPie = 16401,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawArc" /> methods.</summary>
		DrawArc = 16402,
		/// <summary>See <see cref="M:System.Drawing.Graphics.FillRegion(System.Drawing.Brush,System.Drawing.Region)" />.</summary>
		FillRegion = 16403,
		/// <summary>See <see cref="M:System.Drawing.Graphics.FillPath(System.Drawing.Brush,System.Drawing.Drawing2D.GraphicsPath)" />.</summary>
		FillPath = 16404,
		/// <summary>See <see cref="M:System.Drawing.Graphics.DrawPath(System.Drawing.Pen,System.Drawing.Drawing2D.GraphicsPath)" />.</summary>
		DrawPath = 16405,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.FillClosedCurve" /> methods.</summary>
		FillClosedCurve = 16406,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawClosedCurve" /> methods.</summary>
		DrawClosedCurve = 16407,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawCurve" /> methods.</summary>
		DrawCurve = 16408,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawBeziers" /> methods.</summary>
		DrawBeziers = 16409,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawImage" /> methods.</summary>
		DrawImage = 16410,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawImage" /> methods.</summary>
		DrawImagePoints = 16411,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawString" /> methods.</summary>
		DrawString = 16412,
		/// <summary>See <see cref="P:System.Drawing.Graphics.RenderingOrigin" />.</summary>
		SetRenderingOrigin = 16413,
		/// <summary>See <see cref="P:System.Drawing.Graphics.SmoothingMode" />.</summary>
		SetAntiAliasMode = 16414,
		/// <summary>See <see cref="P:System.Drawing.Graphics.TextRenderingHint" />.</summary>
		SetTextRenderingHint = 16415,
		/// <summary>See <see cref="P:System.Drawing.Graphics.TextContrast" />.</summary>
		SetTextContrast = 16416,
		/// <summary>See <see cref="P:System.Drawing.Graphics.InterpolationMode" />.</summary>
		SetInterpolationMode = 16417,
		/// <summary>See <see cref="P:System.Drawing.Graphics.PixelOffsetMode" />.</summary>
		SetPixelOffsetMode = 16418,
		/// <summary>See <see cref="P:System.Drawing.Graphics.CompositingMode" />.</summary>
		SetCompositingMode = 16419,
		/// <summary>See <see cref="P:System.Drawing.Graphics.CompositingQuality" />.</summary>
		SetCompositingQuality = 16420,
		/// <summary>See <see cref="M:System.Drawing.Graphics.Save" />.</summary>
		Save = 16421,
		/// <summary>See <see cref="M:System.Drawing.Graphics.Restore(System.Drawing.Drawing2D.GraphicsState)" />.</summary>
		Restore = 16422,
		/// <summary>See <see cref="M:System.Drawing.Graphics.BeginContainer" /> methods.</summary>
		BeginContainer = 16423,
		/// <summary>See <see cref="M:System.Drawing.Graphics.BeginContainer" /> methods.</summary>
		BeginContainerNoParams = 16424,
		/// <summary>See <see cref="M:System.Drawing.Graphics.EndContainer(System.Drawing.Drawing2D.GraphicsContainer)" />.</summary>
		EndContainer = 16425,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.TransformPoints" /> methods.</summary>
		SetWorldTransform = 16426,
		/// <summary>See <see cref="M:System.Drawing.Graphics.ResetTransform" />.</summary>
		ResetWorldTransform = 16427,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.MultiplyTransform" /> methods.</summary>
		MultiplyWorldTransform = 16428,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.TransformPoints" /> methods.</summary>
		TranslateWorldTransform = 16429,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.ScaleTransform" /> methods.</summary>
		ScaleWorldTransform = 16430,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.RotateTransform" /> methods.</summary>
		RotateWorldTransform = 16431,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.TransformPoints" /> methods.</summary>
		SetPageTransform = 16432,
		/// <summary>See <see cref="M:System.Drawing.Graphics.ResetClip" />.</summary>
		ResetClip = 16433,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.SetClip" /> methods.</summary>
		SetClipRect = 16434,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.SetClip" /> methods.</summary>
		SetClipPath = 16435,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.SetClip" /> methods.</summary>
		SetClipRegion = 16436,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.TranslateClip" /> methods.</summary>
		OffsetClip = 16437,
		/// <summary>Specifies a character string, a location, and formatting information.</summary>
		DrawDriverString = 16438,
		/// <summary>Used internally.</summary>
		Total = 16439,
		/// <summary>The maximum value for this enumeration.</summary>
		Max = 16438,
		/// <summary>The minimum value for this enumeration.</summary>
		Min = 16385
	}
	/// <summary>Specifies the nature of the records that are placed in an Enhanced Metafile (EMF) file. This enumeration is used by several constructors in the <see cref="T:System.Drawing.Imaging.Metafile" /> class.</summary>
	public enum EmfType
	{
		/// <summary>Specifies that all the records in the metafile are EMF records, which can be displayed by GDI or GDI+.</summary>
		EmfOnly = 3,
		/// <summary>Specifies that all the records in the metafile are EMF+ records, which can be displayed by GDI+ but not by GDI.</summary>
		EmfPlusOnly,
		/// <summary>Specifies that all EMF+ records in the metafile are associated with an alternate EMF record. Metafiles of type <see cref="F:System.Drawing.Imaging.EmfType.EmfPlusDual" /> can be displayed by GDI or by GDI+.</summary>
		EmfPlusDual
	}
	/// <summary>An <see cref="T:System.Drawing.Imaging.Encoder" /> object encapsulates a globally unique identifier (GUID) that identifies the category of an image encoder parameter.</summary>
	public sealed class Encoder
	{
		/// <summary>An <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the compression parameter category.</summary>
		public static readonly Encoder Compression = new Encoder(new Guid(-526552163, -13100, 17646, new byte[8] { 142, 186, 63, 191, 139, 228, 252, 88 }));

		/// <summary>An <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the color depth parameter category.</summary>
		public static readonly Encoder ColorDepth = new Encoder(new Guid(1711829077, -21146, 19580, new byte[8] { 154, 24, 56, 162, 49, 11, 131, 55 }));

		/// <summary>Represents an <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the scan method parameter category.</summary>
		public static readonly Encoder ScanMethod = new Encoder(new Guid(978200161, 12553, 20054, new byte[8] { 133, 54, 66, 193, 86, 231, 220, 250 }));

		/// <summary>Represents an <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the version parameter category.</summary>
		public static readonly Encoder Version = new Encoder(new Guid(617712758, -32438, 16804, new byte[8] { 191, 83, 28, 33, 156, 204, 247, 151 }));

		/// <summary>Represents an <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the render method parameter category.</summary>
		public static readonly Encoder RenderMethod = new Encoder(new Guid(1833092410, 8858, 18469, new byte[8] { 139, 183, 92, 153, 226, 185, 168, 184 }));

		/// <summary>Gets an <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the quality parameter category.</summary>
		public static readonly Encoder Quality = new Encoder(new Guid(492561589, -1462, 17709, new byte[8] { 156, 221, 93, 179, 81, 5, 231, 235 }));

		/// <summary>Represents an <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the transformation parameter category.</summary>
		public static readonly Encoder Transformation = new Encoder(new Guid(-1928416559, -23154, 20136, new byte[8] { 170, 20, 16, 128, 116, 183, 182, 249 }));

		/// <summary>Represents an <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the luminance table parameter category.</summary>
		public static readonly Encoder LuminanceTable = new Encoder(new Guid(-307020850, 614, 19063, new byte[8] { 185, 4, 39, 33, 96, 153, 231, 23 }));

		/// <summary>An <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the chrominance table parameter category.</summary>
		public static readonly Encoder ChrominanceTable = new Encoder(new Guid(-219916836, 2483, 17174, new byte[8] { 130, 96, 103, 106, 218, 50, 72, 28 }));

		/// <summary>Represents an <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the save flag parameter category.</summary>
		public static readonly Encoder SaveFlag = new Encoder(new Guid(690120444, -21440, 18367, new byte[8] { 140, 252, 168, 91, 137, 166, 85, 222 }));

		private Guid _guid;

		/// <summary>Gets a globally unique identifier (GUID) that identifies an image encoder parameter category.</summary>
		/// <returns>The GUID that identifies an image encoder parameter category.</returns>
		public Guid Guid => _guid;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Encoder" /> class from the specified globally unique identifier (GUID). The GUID specifies an image encoder parameter category.</summary>
		/// <param name="guid">A globally unique identifier that identifies an image encoder parameter category.</param>
		public Encoder(Guid guid)
		{
			_guid = guid;
		}
	}
	/// <summary>Used to pass a value, or an array of values, to an image encoder.</summary>
	[StructLayout(LayoutKind.Sequential)]
	public sealed class EncoderParameter : IDisposable
	{
		[MarshalAs(UnmanagedType.Struct)]
		private Guid _parameterGuid;

		private int _numberOfValues;

		private EncoderParameterValueType _parameterValueType;

		private IntPtr _parameterValue;

		/// <summary>Gets or sets the <see cref="T:System.Drawing.Imaging.Encoder" /> object associated with this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. The <see cref="T:System.Drawing.Imaging.Encoder" /> object encapsulates the globally unique identifier (GUID) that specifies the category (for example <see cref="F:System.Drawing.Imaging.Encoder.Quality" />, <see cref="F:System.Drawing.Imaging.Encoder.ColorDepth" />, or <see cref="F:System.Drawing.Imaging.Encoder.Compression" />) of the parameter stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the GUID that specifies the category of the parameter stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</returns>
		public Encoder Encoder
		{
			get
			{
				return new Encoder(_parameterGuid);
			}
			set
			{
				_parameterGuid = value.Guid;
			}
		}

		/// <summary>Gets the data type of the values stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		/// <returns>A member of the <see cref="T:System.Drawing.Imaging.EncoderParameterValueType" /> enumeration that indicates the data type of the values stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</returns>
		public EncoderParameterValueType Type => _parameterValueType;

		/// <summary>Gets the data type of the values stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		/// <returns>A member of the <see cref="T:System.Drawing.Imaging.EncoderParameterValueType" /> enumeration that indicates the data type of the values stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</returns>
		public EncoderParameterValueType ValueType => _parameterValueType;

		/// <summary>Gets the number of elements in the array of values stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		/// <returns>An integer that indicates the number of elements in the array of values stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</returns>
		public int NumberOfValues => _numberOfValues;

		/// <summary>Allows an <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object to attempt to free resources and perform other cleanup operations before the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object is reclaimed by garbage collection.</summary>
		~EncoderParameter()
		{
			Dispose(disposing: false);
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.KeepAlive(this);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (_parameterValue != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(_parameterValue);
			}
			_parameterValue = IntPtr.Zero;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and one unsigned 8-bit integer. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeByte" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to 1.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">An 8-bit unsigned integer that specifies the value stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		public EncoderParameter(Encoder encoder, byte value)
		{
			_parameterGuid = encoder.Guid;
			_parameterValueType = EncoderParameterValueType.ValueTypeByte;
			_numberOfValues = 1;
			_parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(byte)));
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteByte(_parameterValue, value);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and one 8-bit value. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeUndefined" /> or <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeByte" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to 1.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">A byte that specifies the value stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		/// <param name="undefined">If <see langword="true" />, the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property is set to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeUndefined" />; otherwise, the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property is set to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeByte" />.</param>
		public EncoderParameter(Encoder encoder, byte value, bool undefined)
		{
			_parameterGuid = encoder.Guid;
			if (undefined)
			{
				_parameterValueType = EncoderParameterValueType.ValueTypeUndefined;
			}
			else
			{
				_parameterValueType = EncoderParameterValueType.ValueTypeByte;
			}
			_numberOfValues = 1;
			_parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(byte)));
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteByte(_parameterValue, value);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and one, 16-bit integer. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeShort" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to 1.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">A 16-bit integer that specifies the value stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. Must be nonnegative.</param>
		public EncoderParameter(Encoder encoder, short value)
		{
			_parameterGuid = encoder.Guid;
			_parameterValueType = EncoderParameterValueType.ValueTypeShort;
			_numberOfValues = 1;
			_parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(short)));
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteInt16(_parameterValue, value);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and one 64-bit integer. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeLong" /> (32 bits), and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to 1.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">A 64-bit integer that specifies the value stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. Must be nonnegative. This parameter is converted to a 32-bit integer before it is stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		public EncoderParameter(Encoder encoder, long value)
		{
			_parameterGuid = encoder.Guid;
			_parameterValueType = EncoderParameterValueType.ValueTypeLong;
			_numberOfValues = 1;
			_parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(int)));
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteInt32(_parameterValue, (int)value);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and a pair of 32-bit integers. The pair of integers represents a fraction, the first integer being the numerator, and the second integer being the denominator. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeRational" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to 1.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="numerator">A 32-bit integer that represents the numerator of a fraction. Must be nonnegative.</param>
		/// <param name="denominator">A 32-bit integer that represents the denominator of a fraction. Must be nonnegative.</param>
		public EncoderParameter(Encoder encoder, int numerator, int denominator)
		{
			_parameterGuid = encoder.Guid;
			_parameterValueType = EncoderParameterValueType.ValueTypeRational;
			_numberOfValues = 1;
			int num = Marshal.SizeOf(typeof(int));
			_parameterValue = Marshal.AllocHGlobal(2 * num);
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteInt32(_parameterValue, numerator);
			Marshal.WriteInt32(Add(_parameterValue, num), denominator);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and a pair of 64-bit integers. The pair of integers represents a range of integers, the first integer being the smallest number in the range, and the second integer being the largest number in the range. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeLongRange" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to 1.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="rangebegin">A 64-bit integer that represents the smallest number in a range of integers. Must be nonnegative. This parameter is converted to a 32-bit integer before it is stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		/// <param name="rangeend">A 64-bit integer that represents the largest number in a range of integers. Must be nonnegative. This parameter is converted to a 32-bit integer before it is stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		public EncoderParameter(Encoder encoder, long rangebegin, long rangeend)
		{
			_parameterGuid = encoder.Guid;
			_parameterValueType = EncoderParameterValueType.ValueTypeLongRange;
			_numberOfValues = 1;
			int num = Marshal.SizeOf(typeof(int));
			_parameterValue = Marshal.AllocHGlobal(2 * num);
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteInt32(_parameterValue, (int)rangebegin);
			Marshal.WriteInt32(Add(_parameterValue, num), (int)rangeend);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and four, 32-bit integers. The four integers represent a range of fractions. The first two integers represent the smallest fraction in the range, and the remaining two integers represent the largest fraction in the range. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeRationalRange" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to 1.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="numerator1">A 32-bit integer that represents the numerator of the smallest fraction in the range. Must be nonnegative.</param>
		/// <param name="demoninator1">A 32-bit integer that represents the denominator of the smallest fraction in the range. Must be nonnegative.</param>
		/// <param name="numerator2">A 32-bit integer that represents the denominator of the smallest fraction in the range. Must be nonnegative.</param>
		/// <param name="demoninator2">A 32-bit integer that represents the numerator of the largest fraction in the range. Must be nonnegative.</param>
		public EncoderParameter(Encoder encoder, int numerator1, int demoninator1, int numerator2, int demoninator2)
		{
			_parameterGuid = encoder.Guid;
			_parameterValueType = EncoderParameterValueType.ValueTypeRationalRange;
			_numberOfValues = 1;
			int num = Marshal.SizeOf(typeof(int));
			_parameterValue = Marshal.AllocHGlobal(4 * num);
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteInt32(_parameterValue, numerator1);
			Marshal.WriteInt32(Add(_parameterValue, num), demoninator1);
			Marshal.WriteInt32(Add(_parameterValue, 2 * num), numerator2);
			Marshal.WriteInt32(Add(_parameterValue, 3 * num), demoninator2);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and a character string. The string is converted to a null-terminated ASCII string before it is stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeAscii" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the length of the ASCII string including the NULL terminator.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">A <see cref="T:System.String" /> that specifies the value stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		public EncoderParameter(Encoder encoder, string value)
		{
			_parameterGuid = encoder.Guid;
			_parameterValueType = EncoderParameterValueType.ValueTypeAscii;
			_numberOfValues = value.Length;
			_parameterValue = Marshal.StringToHGlobalAnsi(value);
			GC.KeepAlive(this);
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and an array of unsigned 8-bit integers. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeByte" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the number of elements in the array.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">An array of 8-bit unsigned integers that specifies the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		public EncoderParameter(Encoder encoder, byte[] value)
		{
			_parameterGuid = encoder.Guid;
			_parameterValueType = EncoderParameterValueType.ValueTypeByte;
			_numberOfValues = value.Length;
			_parameterValue = Marshal.AllocHGlobal(_numberOfValues);
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.Copy(value, 0, _parameterValue, _numberOfValues);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and an array of bytes. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeUndefined" /> or <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeByte" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the number of elements in the array.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">An array of bytes that specifies the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		/// <param name="undefined">If <see langword="true" />, the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property is set to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeUndefined" />; otherwise, the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property is set to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeByte" />.</param>
		public EncoderParameter(Encoder encoder, byte[] value, bool undefined)
		{
			_parameterGuid = encoder.Guid;
			if (undefined)
			{
				_parameterValueType = EncoderParameterValueType.ValueTypeUndefined;
			}
			else
			{
				_parameterValueType = EncoderParameterValueType.ValueTypeByte;
			}
			_numberOfValues = value.Length;
			_parameterValue = Marshal.AllocHGlobal(_numberOfValues);
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.Copy(value, 0, _parameterValue, _numberOfValues);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and an array of 16-bit integers. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeShort" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the number of elements in the array.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">An array of 16-bit integers that specifies the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. The integers in the array must be nonnegative.</param>
		public EncoderParameter(Encoder encoder, short[] value)
		{
			_parameterGuid = encoder.Guid;
			_parameterValueType = EncoderParameterValueType.ValueTypeShort;
			_numberOfValues = value.Length;
			int num = Marshal.SizeOf(typeof(short));
			_parameterValue = Marshal.AllocHGlobal(checked(_numberOfValues * num));
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.Copy(value, 0, _parameterValue, _numberOfValues);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and an array of 64-bit integers. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeLong" /> (32-bit), and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the number of elements in the array.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">An array of 64-bit integers that specifies the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. The integers in the array must be nonnegative. The 64-bit integers are converted to 32-bit integers before they are stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		public unsafe EncoderParameter(Encoder encoder, long[] value)
		{
			_parameterGuid = encoder.Guid;
			_parameterValueType = EncoderParameterValueType.ValueTypeLong;
			_numberOfValues = value.Length;
			int num = Marshal.SizeOf(typeof(int));
			_parameterValue = Marshal.AllocHGlobal(checked(_numberOfValues * num));
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			int* ptr = (int*)(void*)_parameterValue;
			fixed (long* ptr2 = value)
			{
				for (int i = 0; i < value.Length; i++)
				{
					ptr[i] = (int)ptr2[i];
				}
			}
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and two arrays of 32-bit integers. The two arrays represent an array of fractions. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeRational" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the number of elements in the <paramref name="numerator" /> array, which must be the same as the number of elements in the <paramref name="denominator" /> array.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="numerator">An array of 32-bit integers that specifies the numerators of the fractions. The integers in the array must be nonnegative.</param>
		/// <param name="denominator">An array of 32-bit integers that specifies the denominators of the fractions. The integers in the array must be nonnegative. A denominator of a given index is paired with the numerator of the same index.</param>
		public EncoderParameter(Encoder encoder, int[] numerator, int[] denominator)
		{
			_parameterGuid = encoder.Guid;
			if (numerator.Length != denominator.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			_parameterValueType = EncoderParameterValueType.ValueTypeRational;
			_numberOfValues = numerator.Length;
			int num = Marshal.SizeOf(typeof(int));
			_parameterValue = Marshal.AllocHGlobal(checked(_numberOfValues * 2 * num));
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			for (int i = 0; i < _numberOfValues; i++)
			{
				Marshal.WriteInt32(Add(i * 2 * num, _parameterValue), numerator[i]);
				Marshal.WriteInt32(Add((i * 2 + 1) * num, _parameterValue), denominator[i]);
			}
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and two arrays of 64-bit integers. The two arrays represent an array integer ranges. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeLongRange" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the number of elements in the <paramref name="rangebegin" /> array, which must be the same as the number of elements in the <paramref name="rangeend" /> array.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="rangebegin">An array of 64-bit integers that specifies the minimum values for the integer ranges. The integers in the array must be nonnegative. The 64-bit integers are converted to 32-bit integers before they are stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		/// <param name="rangeend">An array of 64-bit integers that specifies the maximum values for the integer ranges. The integers in the array must be nonnegative. The 64-bit integers are converted to 32-bit integers before they are stored in the <see cref="T:System.Drawing.Imaging.EncoderParameters" /> object. A maximum value of a given index is paired with the minimum value of the same index.</param>
		public EncoderParameter(Encoder encoder, long[] rangebegin, long[] rangeend)
		{
			_parameterGuid = encoder.Guid;
			if (rangebegin.Length != rangeend.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			_parameterValueType = EncoderParameterValueType.ValueTypeLongRange;
			_numberOfValues = rangebegin.Length;
			int num = Marshal.SizeOf(typeof(int));
			_parameterValue = Marshal.AllocHGlobal(checked(_numberOfValues * 2 * num));
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			for (int i = 0; i < _numberOfValues; i++)
			{
				Marshal.WriteInt32(Add(i * 2 * num, _parameterValue), (int)rangebegin[i]);
				Marshal.WriteInt32(Add((i * 2 + 1) * num, _parameterValue), (int)rangeend[i]);
			}
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and four arrays of 32-bit integers. The four arrays represent an array rational ranges. A rational range is the set of all fractions from a minimum fractional value through a maximum fractional value. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeRationalRange" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the number of elements in the <paramref name="numerator1" /> array, which must be the same as the number of elements in the other three arrays.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="numerator1">An array of 32-bit integers that specifies the numerators of the minimum values for the ranges. The integers in the array must be nonnegative.</param>
		/// <param name="denominator1">An array of 32-bit integers that specifies the denominators of the minimum values for the ranges. The integers in the array must be nonnegative.</param>
		/// <param name="numerator2">An array of 32-bit integers that specifies the numerators of the maximum values for the ranges. The integers in the array must be nonnegative.</param>
		/// <param name="denominator2">An array of 32-bit integers that specifies the denominators of the maximum values for the ranges. The integers in the array must be nonnegative.</param>
		public EncoderParameter(Encoder encoder, int[] numerator1, int[] denominator1, int[] numerator2, int[] denominator2)
		{
			_parameterGuid = encoder.Guid;
			if (numerator1.Length != denominator1.Length || numerator1.Length != denominator2.Length || denominator1.Length != denominator2.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			_parameterValueType = EncoderParameterValueType.ValueTypeRationalRange;
			_numberOfValues = numerator1.Length;
			int num = Marshal.SizeOf(typeof(int));
			_parameterValue = Marshal.AllocHGlobal(checked(_numberOfValues * 4 * num));
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			for (int i = 0; i < _numberOfValues; i++)
			{
				Marshal.WriteInt32(Add(_parameterValue, 4 * i * num), numerator1[i]);
				Marshal.WriteInt32(Add(_parameterValue, (4 * i + 1) * num), denominator1[i]);
				Marshal.WriteInt32(Add(_parameterValue, (4 * i + 2) * num), numerator2[i]);
				Marshal.WriteInt32(Add(_parameterValue, (4 * i + 3) * num), denominator2[i]);
			}
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and three integers that specify the number of values, the data type of the values, and a pointer to the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="NumberOfValues">An integer that specifies the number of values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. The <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property is set to this value.</param>
		/// <param name="Type">A member of the <see cref="T:System.Drawing.Imaging.EncoderParameterValueType" /> enumeration that specifies the data type of the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. The <see cref="T:System.Type" /> and <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> properties are set to this value.</param>
		/// <param name="Value">A pointer to an array of values of the type specified by the <paramref name="Type" /> parameter.</param>
		/// <exception cref="T:System.InvalidOperationException">Type is not a valid <see cref="T:System.Drawing.Imaging.EncoderParameterValueType" />.</exception>
		[Obsolete("This constructor has been deprecated. Use EncoderParameter(Encoder encoder, int numberValues, EncoderParameterValueType type, IntPtr value) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
		public EncoderParameter(Encoder encoder, int NumberOfValues, int Type, int Value)
		{
			int num;
			switch ((EncoderParameterValueType)Type)
			{
			case EncoderParameterValueType.ValueTypeByte:
			case EncoderParameterValueType.ValueTypeAscii:
				num = 1;
				break;
			case EncoderParameterValueType.ValueTypeShort:
				num = 2;
				break;
			case EncoderParameterValueType.ValueTypeLong:
				num = 4;
				break;
			case EncoderParameterValueType.ValueTypeRational:
			case EncoderParameterValueType.ValueTypeLongRange:
				num = 8;
				break;
			case EncoderParameterValueType.ValueTypeUndefined:
				num = 1;
				break;
			case EncoderParameterValueType.ValueTypeRationalRange:
				num = 16;
				break;
			default:
				throw SafeNativeMethods.Gdip.StatusException(8);
			}
			int num2 = checked(num * NumberOfValues);
			_parameterValue = Marshal.AllocHGlobal(num2);
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			for (int i = 0; i < num2; i++)
			{
				Marshal.WriteByte(Add(_parameterValue, i), Marshal.ReadByte((IntPtr)(Value + i)));
			}
			_parameterValueType = (EncoderParameterValueType)Type;
			_numberOfValues = NumberOfValues;
			_parameterGuid = encoder.Guid;
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object, number of values, data type of the values, and a pointer to the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="numberValues">An integer that specifies the number of values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. The <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property is set to this value.</param>
		/// <param name="type">A member of the <see cref="T:System.Drawing.Imaging.EncoderParameterValueType" /> enumeration that specifies the data type of the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. The <see cref="T:System.Type" /> and <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> properties are set to this value.</param>
		/// <param name="value">A pointer to an array of values of the type specified by the <paramref name="Type" /> parameter.</param>
		public EncoderParameter(Encoder encoder, int numberValues, EncoderParameterValueType type, IntPtr value)
		{
			int num;
			switch (type)
			{
			case EncoderParameterValueType.ValueTypeByte:
			case EncoderParameterValueType.ValueTypeAscii:
				num = 1;
				break;
			case EncoderParameterValueType.ValueTypeShort:
				num = 2;
				break;
			case EncoderParameterValueType.ValueTypeLong:
				num = 4;
				break;
			case EncoderParameterValueType.ValueTypeRational:
			case EncoderParameterValueType.ValueTypeLongRange:
				num = 8;
				break;
			case EncoderParameterValueType.ValueTypeUndefined:
				num = 1;
				break;
			case EncoderParameterValueType.ValueTypeRationalRange:
				num = 16;
				break;
			default:
				throw SafeNativeMethods.Gdip.StatusException(8);
			}
			int num2 = checked(num * numberValues);
			_parameterValue = Marshal.AllocHGlobal(num2);
			if (_parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			for (int i = 0; i < num2; i++)
			{
				Marshal.WriteByte(Add(_parameterValue, i), Marshal.ReadByte(value + i));
			}
			_parameterValueType = type;
			_numberOfValues = numberValues;
			_parameterGuid = encoder.Guid;
			GC.KeepAlive(this);
		}

		private static IntPtr Add(IntPtr a, int b)
		{
			return (IntPtr)((long)a + b);
		}

		private static IntPtr Add(int a, IntPtr b)
		{
			return (IntPtr)(a + (long)b);
		}
	}
	/// <summary>Used to specify the data type of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> used with the <see cref="Overload:System.Drawing.Image.Save" /> or <see cref="Overload:System.Drawing.Image.SaveAdd" /> method of an image.</summary>
	public enum EncoderParameterValueType
	{
		/// <summary>Specifies that each value in the array is an 8-bit unsigned integer.</summary>
		ValueTypeByte = 1,
		/// <summary>Specifies that the array of values is a null-terminated ASCII character string. Note that the <see langword="NumberOfValues" /> data member of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object indicates the length of the character string including the NULL terminator.</summary>
		ValueTypeAscii,
		/// <summary>Specifies that each value in the array is a 16-bit, unsigned integer.</summary>
		ValueTypeShort,
		/// <summary>Specifies that each value in the array is a 32-bit unsigned integer.</summary>
		ValueTypeLong,
		/// <summary>Specifies that each value in the array is a pair of 32-bit unsigned integers. Each pair represents a fraction, the first integer being the numerator and the second integer being the denominator.</summary>
		ValueTypeRational,
		/// <summary>Specifies that each value in the array is a pair of 32-bit unsigned integers. Each pair represents a range of numbers.</summary>
		ValueTypeLongRange,
		/// <summary>Specifies that the array of values is an array of bytes that has no data type defined.</summary>
		ValueTypeUndefined,
		/// <summary>Specifies that each value in the array is a set of four, 32-bit unsigned integers. The first two integers represent one fraction, and the second two integers represent a second fraction. The two fractions represent a range of rational numbers. The first fraction is the smallest rational number in the range, and the second fraction is the largest rational number in the range.</summary>
		ValueTypeRationalRange
	}
	/// <summary>Encapsulates an array of <see cref="T:System.Drawing.Imaging.EncoderParameter" /> objects.</summary>
	public sealed class EncoderParameters : IDisposable
	{
		private EncoderParameter[] _param;

		/// <summary>Gets or sets an array of <see cref="T:System.Drawing.Imaging.EncoderParameter" /> objects.</summary>
		/// <returns>The array of <see cref="T:System.Drawing.Imaging.EncoderParameter" /> objects.</returns>
		public EncoderParameter[] Param
		{
			get
			{
				return _param;
			}
			set
			{
				_param = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameters" /> class that can contain the specified number of <see cref="T:System.Drawing.Imaging.EncoderParameter" /> objects.</summary>
		/// <param name="count">An integer that specifies the number of <see cref="T:System.Drawing.Imaging.EncoderParameter" /> objects that the <see cref="T:System.Drawing.Imaging.EncoderParameters" /> object can contain.</param>
		public EncoderParameters(int count)
		{
			_param = new EncoderParameter[count];
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameters" /> class that can contain one <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		public EncoderParameters()
		{
			_param = new EncoderParameter[1];
		}

		internal IntPtr ConvertToMemory()
		{
			int num = Marshal.SizeOf(typeof(EncoderParameter));
			int num2 = _param.Length;
			IntPtr intPtr;
			long num3;
			checked
			{
				intPtr = Marshal.AllocHGlobal(num2 * num + Marshal.SizeOf(typeof(IntPtr)));
				if (intPtr == IntPtr.Zero)
				{
					throw SafeNativeMethods.Gdip.StatusException(3);
				}
				Marshal.WriteIntPtr(intPtr, (IntPtr)num2);
				num3 = (long)intPtr + Marshal.SizeOf(typeof(IntPtr));
			}
			for (int i = 0; i < num2; i++)
			{
				Marshal.StructureToPtr(_param[i], (IntPtr)(num3 + i * num), fDeleteOld: false);
			}
			return intPtr;
		}

		internal static EncoderParameters ConvertFromMemory(IntPtr memory)
		{
			if (memory == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			int num = Marshal.ReadIntPtr(memory).ToInt32();
			EncoderParameters encoderParameters = new EncoderParameters(num);
			int num2 = Marshal.SizeOf(typeof(EncoderParameter));
			long num3 = (long)memory + Marshal.SizeOf(typeof(IntPtr));
			for (int i = 0; i < num; i++)
			{
				Guid guid = (Guid)Marshal.PtrToStructure((IntPtr)(i * num2 + num3), typeof(Guid));
				int numberValues = Marshal.ReadInt32((IntPtr)(i * num2 + num3 + 16));
				EncoderParameterValueType type = (EncoderParameterValueType)Marshal.ReadInt32((IntPtr)(i * num2 + num3 + 20));
				IntPtr value = Marshal.ReadIntPtr((IntPtr)(i * num2 + num3 + 24));
				encoderParameters._param[i] = new EncoderParameter(new Encoder(guid), numberValues, type, value);
			}
			return encoderParameters;
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Imaging.EncoderParameters" /> object.</summary>
		public void Dispose()
		{
			EncoderParameter[] param = _param;
			for (int i = 0; i < param.Length; i++)
			{
				param[i]?.Dispose();
			}
			_param = null;
		}
	}
	/// <summary>Used to specify the parameter value passed to a JPEG or TIFF image encoder when using the <see cref="M:System.Drawing.Image.Save(System.String,System.Drawing.Imaging.ImageCodecInfo,System.Drawing.Imaging.EncoderParameters)" /> or <see cref="M:System.Drawing.Image.SaveAdd(System.Drawing.Imaging.EncoderParameters)" /> methods.</summary>
	public enum EncoderValue
	{
		/// <summary>Not used in GDI+ version 1.0.</summary>
		ColorTypeCMYK,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		ColorTypeYCCK,
		/// <summary>Specifies the LZW compression scheme. Can be passed to the TIFF encoder as a parameter that belongs to the Compression category.</summary>
		CompressionLZW,
		/// <summary>Specifies the CCITT3 compression scheme. Can be passed to the TIFF encoder as a parameter that belongs to the compression category.</summary>
		CompressionCCITT3,
		/// <summary>Specifies the CCITT4 compression scheme. Can be passed to the TIFF encoder as a parameter that belongs to the compression category.</summary>
		CompressionCCITT4,
		/// <summary>Specifies the RLE compression scheme. Can be passed to the TIFF encoder as a parameter that belongs to the compression category.</summary>
		CompressionRle,
		/// <summary>Specifies no compression. Can be passed to the TIFF encoder as a parameter that belongs to the compression category.</summary>
		CompressionNone,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		ScanMethodInterlaced,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		ScanMethodNonInterlaced,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		VersionGif87,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		VersionGif89,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		RenderProgressive,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		RenderNonProgressive,
		/// <summary>Specifies that the image is to be rotated clockwise 90 degrees about its center. Can be passed to the JPEG encoder as a parameter that belongs to the transformation category.</summary>
		TransformRotate90,
		/// <summary>Specifies that the image is to be rotated 180 degrees about its center. Can be passed to the JPEG encoder as a parameter that belongs to the transformation category.</summary>
		TransformRotate180,
		/// <summary>Specifies that the image is to be rotated clockwise 270 degrees about its center. Can be passed to the JPEG encoder as a parameter that belongs to the transformation category.</summary>
		TransformRotate270,
		/// <summary>Specifies that the image is to be flipped horizontally (about the vertical axis). Can be passed to the JPEG encoder as a parameter that belongs to the transformation category.</summary>
		TransformFlipHorizontal,
		/// <summary>Specifies that the image is to be flipped vertically (about the horizontal axis). Can be passed to the JPEG encoder as a parameter that belongs to the transformation category.</summary>
		TransformFlipVertical,
		/// <summary>Specifies that the image has more than one frame (page). Can be passed to the TIFF encoder as a parameter that belongs to the save flag category.</summary>
		MultiFrame,
		/// <summary>Specifies the last frame in a multiple-frame image. Can be passed to the TIFF encoder as a parameter that belongs to the save flag category.</summary>
		LastFrame,
		/// <summary>Specifies that a multiple-frame file or stream should be closed. Can be passed to the TIFF encoder as a parameter that belongs to the save flag category.</summary>
		Flush,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		FrameDimensionTime,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		FrameDimensionResolution,
		/// <summary>Specifies that a frame is to be added to the page dimension of an image. Can be passed to the TIFF encoder as a parameter that belongs to the save flag category.</summary>
		FrameDimensionPage
	}
	/// <summary>Provides properties that get the frame dimensions of an image. Not inheritable.</summary>
	public sealed class FrameDimension
	{
		private static FrameDimension s_time = new FrameDimension(new Guid("{6aedbd6d-3fb5-418a-83a6-7f45229dc872}"));

		private static FrameDimension s_resolution = new FrameDimension(new Guid("{84236f7b-3bd3-428f-8dab-4ea1439ca315}"));

		private static FrameDimension s_page = new FrameDimension(new Guid("{7462dc86-6180-4c7e-8e3f-ee7333a7a483}"));

		private Guid _guid;

		/// <summary>Gets a globally unique identifier (GUID) that represents this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object.</summary>
		/// <returns>A <see langword="Guid" /> structure that contains a GUID that represents this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object.</returns>
		public Guid Guid => _guid;

		/// <summary>Gets the time dimension.</summary>
		/// <returns>The time dimension.</returns>
		public static FrameDimension Time => s_time;

		/// <summary>Gets the resolution dimension.</summary>
		/// <returns>The resolution dimension.</returns>
		public static FrameDimension Resolution => s_resolution;

		/// <summary>Gets the page dimension.</summary>
		/// <returns>The page dimension.</returns>
		public static FrameDimension Page => s_page;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.FrameDimension" /> class using the specified <see langword="Guid" /> structure.</summary>
		/// <param name="guid">A <see langword="Guid" /> structure that contains a GUID for this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object.</param>
		public FrameDimension(Guid guid)
		{
			_guid = guid;
		}

		/// <summary>Returns a value that indicates whether the specified object is a <see cref="T:System.Drawing.Imaging.FrameDimension" /> equivalent to this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object.</summary>
		/// <param name="o">The object to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="o" /> is a <see cref="T:System.Drawing.Imaging.FrameDimension" /> equivalent to this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object o)
		{
			if (!(o is FrameDimension frameDimension))
			{
				return false;
			}
			return _guid == frameDimension._guid;
		}

		/// <summary>Returns a hash code for this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object.</summary>
		/// <returns>The hash code of this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object.</returns>
		public override int GetHashCode()
		{
			return _guid.GetHashCode();
		}

		/// <summary>Converts this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object to a human-readable string.</summary>
		/// <returns>A string that represents this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object.</returns>
		public override string ToString()
		{
			if (this == s_time)
			{
				return "Time";
			}
			if (this == s_resolution)
			{
				return "Resolution";
			}
			if (this == s_page)
			{
				return "Page";
			}
			return string.Concat("[FrameDimension: ", _guid, "]");
		}
	}
	/// <summary>Contains information about how bitmap and metafile colors are manipulated during rendering.</summary>
	[StructLayout(LayoutKind.Sequential)]
	public sealed class ImageAttributes : ICloneable, IDisposable
	{
		internal IntPtr nativeImageAttributes;

		internal void SetNativeImageAttributes(IntPtr handle)
		{
			if (handle == IntPtr.Zero)
			{
				throw new ArgumentNullException("handle");
			}
			nativeImageAttributes = handle;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.ImageAttributes" /> class.</summary>
		public ImageAttributes()
		{
			IntPtr imageattr = IntPtr.Zero;
			int num = GDIPlus.GdipCreateImageAttributes(out imageattr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImageAttributes(imageattr);
		}

		internal ImageAttributes(IntPtr newNativeImageAttributes)
		{
			SetNativeImageAttributes(newNativeImageAttributes);
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Imaging.ImageAttributes" /> object.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativeImageAttributes != IntPtr.Zero))
			{
				return;
			}
			try
			{
				GDIPlus.GdipDisposeImageAttributes(new HandleRef(this, nativeImageAttributes));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeImageAttributes = IntPtr.Zero;
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~ImageAttributes()
		{
			Dispose(disposing: false);
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Imaging.ImageAttributes" /> object.</summary>
		/// <returns>The <see cref="T:System.Drawing.Imaging.ImageAttributes" /> object this class creates, cast as an object.</returns>
		public object Clone()
		{
			IntPtr cloneImageattr = IntPtr.Zero;
			int num = GDIPlus.GdipCloneImageAttributes(new HandleRef(this, nativeImageAttributes), out cloneImageattr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new ImageAttributes(cloneImageattr);
		}

		/// <summary>Sets the color-adjustment matrix for the default category.</summary>
		/// <param name="newColorMatrix">The color-adjustment matrix.</param>
		public void SetColorMatrix(ColorMatrix newColorMatrix)
		{
			SetColorMatrix(newColorMatrix, ColorMatrixFlag.Default, ColorAdjustType.Default);
		}

		/// <summary>Sets the color-adjustment matrix for the default category.</summary>
		/// <param name="newColorMatrix">The color-adjustment matrix.</param>
		/// <param name="flags">An element of <see cref="T:System.Drawing.Imaging.ColorMatrixFlag" /> that specifies the type of image and color that will be affected by the color-adjustment matrix.</param>
		public void SetColorMatrix(ColorMatrix newColorMatrix, ColorMatrixFlag flags)
		{
			SetColorMatrix(newColorMatrix, flags, ColorAdjustType.Default);
		}

		/// <summary>Sets the color-adjustment matrix for a specified category.</summary>
		/// <param name="newColorMatrix">The color-adjustment matrix.</param>
		/// <param name="mode">An element of <see cref="T:System.Drawing.Imaging.ColorMatrixFlag" /> that specifies the type of image and color that will be affected by the color-adjustment matrix.</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the color-adjustment matrix is set.</param>
		public void SetColorMatrix(ColorMatrix newColorMatrix, ColorMatrixFlag mode, ColorAdjustType type)
		{
			int num = GDIPlus.GdipSetImageAttributesColorMatrix(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, newColorMatrix, null, mode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Clears the color-adjustment matrix for the default category.</summary>
		public void ClearColorMatrix()
		{
			ClearColorMatrix(ColorAdjustType.Default);
		}

		/// <summary>Clears the color-adjustment matrix for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the color-adjustment matrix is cleared.</param>
		public void ClearColorMatrix(ColorAdjustType type)
		{
			int num = GDIPlus.GdipSetImageAttributesColorMatrix(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, null, null, ColorMatrixFlag.Default);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the color-adjustment matrix and the grayscale-adjustment matrix for the default category.</summary>
		/// <param name="newColorMatrix">The color-adjustment matrix.</param>
		/// <param name="grayMatrix">The grayscale-adjustment matrix.</param>
		public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix)
		{
			SetColorMatrices(newColorMatrix, grayMatrix, ColorMatrixFlag.Default, ColorAdjustType.Default);
		}

		/// <summary>Sets the color-adjustment matrix and the grayscale-adjustment matrix for the default category.</summary>
		/// <param name="newColorMatrix">The color-adjustment matrix.</param>
		/// <param name="grayMatrix">The grayscale-adjustment matrix.</param>
		/// <param name="flags">An element of <see cref="T:System.Drawing.Imaging.ColorMatrixFlag" /> that specifies the type of image and color that will be affected by the color-adjustment and grayscale-adjustment matrices.</param>
		public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag flags)
		{
			SetColorMatrices(newColorMatrix, grayMatrix, flags, ColorAdjustType.Default);
		}

		/// <summary>Sets the color-adjustment matrix and the grayscale-adjustment matrix for a specified category.</summary>
		/// <param name="newColorMatrix">The color-adjustment matrix.</param>
		/// <param name="grayMatrix">The grayscale-adjustment matrix.</param>
		/// <param name="mode">An element of <see cref="T:System.Drawing.Imaging.ColorMatrixFlag" /> that specifies the type of image and color that will be affected by the color-adjustment and grayscale-adjustment matrices.</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the color-adjustment and grayscale-adjustment matrices are set.</param>
		public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag mode, ColorAdjustType type)
		{
			int num = GDIPlus.GdipSetImageAttributesColorMatrix(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, newColorMatrix, grayMatrix, mode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the threshold (transparency range) for the default category.</summary>
		/// <param name="threshold">A real number that specifies the threshold value.</param>
		public void SetThreshold(float threshold)
		{
			SetThreshold(threshold, ColorAdjustType.Default);
		}

		/// <summary>Sets the threshold (transparency range) for a specified category.</summary>
		/// <param name="threshold">A threshold value from 0.0 to 1.0 that is used as a breakpoint to sort colors that will be mapped to either a maximum or a minimum value.</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the color threshold is set.</param>
		public void SetThreshold(float threshold, ColorAdjustType type)
		{
			int num = GDIPlus.GdipSetImageAttributesThreshold(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, threshold);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Clears the threshold value for the default category.</summary>
		public void ClearThreshold()
		{
			ClearThreshold(ColorAdjustType.Default);
		}

		/// <summary>Clears the threshold value for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the threshold is cleared.</param>
		public void ClearThreshold(ColorAdjustType type)
		{
			int num = GDIPlus.GdipSetImageAttributesThreshold(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, 0f);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the gamma value for the default category.</summary>
		/// <param name="gamma">The gamma correction value.</param>
		public void SetGamma(float gamma)
		{
			SetGamma(gamma, ColorAdjustType.Default);
		}

		/// <summary>Sets the gamma value for a specified category.</summary>
		/// <param name="gamma">The gamma correction value.</param>
		/// <param name="type">An element of the <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> enumeration that specifies the category for which the gamma value is set.</param>
		public void SetGamma(float gamma, ColorAdjustType type)
		{
			int num = GDIPlus.GdipSetImageAttributesGamma(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, gamma);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Disables gamma correction for the default category.</summary>
		public void ClearGamma()
		{
			ClearGamma(ColorAdjustType.Default);
		}

		/// <summary>Disables gamma correction for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which gamma correction is disabled.</param>
		public void ClearGamma(ColorAdjustType type)
		{
			int num = GDIPlus.GdipSetImageAttributesGamma(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, 0f);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Turns off color adjustment for the default category. You can call the <see cref="Overload:System.Drawing.Imaging.ImageAttributes.ClearNoOp" /> method to reinstate the color-adjustment settings that were in place before the call to the <see cref="Overload:System.Drawing.Imaging.ImageAttributes.SetNoOp" /> method.</summary>
		public void SetNoOp()
		{
			SetNoOp(ColorAdjustType.Default);
		}

		/// <summary>Turns off color adjustment for a specified category. You can call the <see cref="Overload:System.Drawing.Imaging.ImageAttributes.ClearNoOp" /> method to reinstate the color-adjustment settings that were in place before the call to the <see cref="Overload:System.Drawing.Imaging.ImageAttributes.SetNoOp" /> method.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which color correction is turned off.</param>
		public void SetNoOp(ColorAdjustType type)
		{
			int num = GDIPlus.GdipSetImageAttributesNoOp(new HandleRef(this, nativeImageAttributes), type, enableFlag: true);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Clears the <see langword="NoOp" /> setting for the default category.</summary>
		public void ClearNoOp()
		{
			ClearNoOp(ColorAdjustType.Default);
		}

		/// <summary>Clears the <see langword="NoOp" /> setting for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the <see langword="NoOp" /> setting is cleared.</param>
		public void ClearNoOp(ColorAdjustType type)
		{
			int num = GDIPlus.GdipSetImageAttributesNoOp(new HandleRef(this, nativeImageAttributes), type, enableFlag: false);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the color key for the default category.</summary>
		/// <param name="colorLow">The low color-key value.</param>
		/// <param name="colorHigh">The high color-key value.</param>
		public void SetColorKey(Color colorLow, Color colorHigh)
		{
			SetColorKey(colorLow, colorHigh, ColorAdjustType.Default);
		}

		/// <summary>Sets the color key (transparency range) for a specified category.</summary>
		/// <param name="colorLow">The low color-key value.</param>
		/// <param name="colorHigh">The high color-key value.</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the color key is set.</param>
		public void SetColorKey(Color colorLow, Color colorHigh, ColorAdjustType type)
		{
			int colorLow2 = colorLow.ToArgb();
			int colorHigh2 = colorHigh.ToArgb();
			int num = GDIPlus.GdipSetImageAttributesColorKeys(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, colorLow2, colorHigh2);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Clears the color key (transparency range) for the default category.</summary>
		public void ClearColorKey()
		{
			ClearColorKey(ColorAdjustType.Default);
		}

		/// <summary>Clears the color key (transparency range) for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the color key is cleared.</param>
		public void ClearColorKey(ColorAdjustType type)
		{
			int num = 0;
			int num2 = GDIPlus.GdipSetImageAttributesColorKeys(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, num, num);
			if (num2 != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num2);
			}
		}

		/// <summary>Sets the CMYK (cyan-magenta-yellow-black) output channel for the default category.</summary>
		/// <param name="flags">An element of <see cref="T:System.Drawing.Imaging.ColorChannelFlag" /> that specifies the output channel.</param>
		public void SetOutputChannel(ColorChannelFlag flags)
		{
			SetOutputChannel(flags, ColorAdjustType.Default);
		}

		/// <summary>Sets the CMYK (cyan-magenta-yellow-black) output channel for a specified category.</summary>
		/// <param name="flags">An element of <see cref="T:System.Drawing.Imaging.ColorChannelFlag" /> that specifies the output channel.</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the output channel is set.</param>
		public void SetOutputChannel(ColorChannelFlag flags, ColorAdjustType type)
		{
			int num = GDIPlus.GdipSetImageAttributesOutputChannel(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, flags);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Clears the CMYK (cyan-magenta-yellow-black) output channel setting for the default category.</summary>
		public void ClearOutputChannel()
		{
			ClearOutputChannel(ColorAdjustType.Default);
		}

		/// <summary>Clears the (cyan-magenta-yellow-black) output channel setting for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the output channel setting is cleared.</param>
		public void ClearOutputChannel(ColorAdjustType type)
		{
			int num = GDIPlus.GdipSetImageAttributesOutputChannel(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, ColorChannelFlag.ColorChannelLast);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the output channel color-profile file for the default category.</summary>
		/// <param name="colorProfileFilename">The path name of a color-profile file. If the color-profile file is in the %SystemRoot%\System32\Spool\Drivers\Color directory, this parameter can be the file name. Otherwise, this parameter must be the fully qualified path name.</param>
		public void SetOutputChannelColorProfile(string colorProfileFilename)
		{
			SetOutputChannelColorProfile(colorProfileFilename, ColorAdjustType.Default);
		}

		/// <summary>Sets the output channel color-profile file for a specified category.</summary>
		/// <param name="colorProfileFilename">The path name of a color-profile file. If the color-profile file is in the %SystemRoot%\System32\Spool\Drivers\Color directory, this parameter can be the file name. Otherwise, this parameter must be the fully qualified path name.</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the output channel color-profile file is set.</param>
		public void SetOutputChannelColorProfile(string colorProfileFilename, ColorAdjustType type)
		{
			Path.GetFullPath(colorProfileFilename);
			int num = GDIPlus.GdipSetImageAttributesOutputChannelColorProfile(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, colorProfileFilename);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Clears the output channel color profile setting for the default category.</summary>
		public void ClearOutputChannelColorProfile()
		{
			ClearOutputChannel(ColorAdjustType.Default);
		}

		/// <summary>Clears the output channel color profile setting for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the output channel profile setting is cleared.</param>
		public void ClearOutputChannelColorProfile(ColorAdjustType type)
		{
			int num = GDIPlus.GdipSetImageAttributesOutputChannel(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, ColorChannelFlag.ColorChannelLast);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the color-remap table for the default category.</summary>
		/// <param name="map">An array of color pairs of type <see cref="T:System.Drawing.Imaging.ColorMap" />. Each color pair contains an existing color (the first value) and the color that it will be mapped to (the second value).</param>
		public void SetRemapTable(ColorMap[] map)
		{
			SetRemapTable(map, ColorAdjustType.Default);
		}

		/// <summary>Sets the color-remap table for a specified category.</summary>
		/// <param name="map">An array of color pairs of type <see cref="T:System.Drawing.Imaging.ColorMap" />. Each color pair contains an existing color (the first value) and the color that it will be mapped to (the second value).</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the color-remap table is set.</param>
		public void SetRemapTable(ColorMap[] map, ColorAdjustType type)
		{
			int num = 0;
			int num2 = map.Length;
			int num3 = 4;
			IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num3 * 2));
			try
			{
				for (num = 0; num < num2; num++)
				{
					Marshal.StructureToPtr(map[num].OldColor.ToArgb(), (IntPtr)((long)intPtr + num * num3 * 2), fDeleteOld: false);
					Marshal.StructureToPtr(map[num].NewColor.ToArgb(), (IntPtr)((long)intPtr + num * num3 * 2 + num3), fDeleteOld: false);
				}
				int num4 = GDIPlus.GdipSetImageAttributesRemapTable(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, num2, new HandleRef(null, intPtr));
				if (num4 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num4);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Clears the color-remap table for the default category.</summary>
		public void ClearRemapTable()
		{
			ClearRemapTable(ColorAdjustType.Default);
		}

		/// <summary>Clears the color-remap table for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the remap table is cleared.</param>
		public void ClearRemapTable(ColorAdjustType type)
		{
			int num = GDIPlus.GdipSetImageAttributesRemapTable(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, 0, NativeMethods.NullHandleRef);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the color-remap table for the brush category.</summary>
		/// <param name="map">An array of <see cref="T:System.Drawing.Imaging.ColorMap" /> objects.</param>
		public void SetBrushRemapTable(ColorMap[] map)
		{
			SetRemapTable(map, ColorAdjustType.Brush);
		}

		/// <summary>Clears the brush color-remap table of this <see cref="T:System.Drawing.Imaging.ImageAttributes" /> object.</summary>
		public void ClearBrushRemapTable()
		{
			ClearRemapTable(ColorAdjustType.Brush);
		}

		/// <summary>Sets the wrap mode that is used to decide how to tile a texture across a shape, or at shape boundaries. A texture is tiled across a shape to fill it in when the texture is smaller than the shape it is filling.</summary>
		/// <param name="mode">An element of <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that specifies how repeated copies of an image are used to tile an area.</param>
		public void SetWrapMode(WrapMode mode)
		{
			SetWrapMode(mode, default(Color), clamp: false);
		}

		/// <summary>Sets the wrap mode and color used to decide how to tile a texture across a shape, or at shape boundaries. A texture is tiled across a shape to fill it in when the texture is smaller than the shape it is filling.</summary>
		/// <param name="mode">An element of <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that specifies how repeated copies of an image are used to tile an area.</param>
		/// <param name="color">An <see cref="T:System.Drawing.Imaging.ImageAttributes" /> object that specifies the color of pixels outside of a rendered image. This color is visible if the mode parameter is set to <see cref="F:System.Drawing.Drawing2D.WrapMode.Clamp" /> and the source rectangle passed to <see cref="Overload:System.Drawing.Graphics.DrawImage" /> is larger than the image itself.</param>
		public void SetWrapMode(WrapMode mode, Color color)
		{
			SetWrapMode(mode, color, clamp: false);
		}

		/// <summary>Sets the wrap mode and color used to decide how to tile a texture across a shape, or at shape boundaries. A texture is tiled across a shape to fill it in when the texture is smaller than the shape it is filling.</summary>
		/// <param name="mode">An element of <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that specifies how repeated copies of an image are used to tile an area.</param>
		/// <param name="color">A color object that specifies the color of pixels outside of a rendered image. This color is visible if the mode parameter is set to <see cref="F:System.Drawing.Drawing2D.WrapMode.Clamp" /> and the source rectangle passed to <see cref="Overload:System.Drawing.Graphics.DrawImage" /> is larger than the image itself.</param>
		/// <param name="clamp">This parameter has no effect. Set it to <see langword="false" />.</param>
		public void SetWrapMode(WrapMode mode, Color color, bool clamp)
		{
			int num = GDIPlus.GdipSetImageAttributesWrapMode(new HandleRef(this, nativeImageAttributes), (int)mode, color.ToArgb(), clamp);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adjusts the colors in a palette according to the adjustment settings of a specified category.</summary>
		/// <param name="palette">A <see cref="T:System.Drawing.Imaging.ColorPalette" /> that on input contains the palette to be adjusted, and on output contains the adjusted palette.</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category whose adjustment settings will be applied to the palette.</param>
		public void GetAdjustedPalette(ColorPalette palette, ColorAdjustType type)
		{
			IntPtr intPtr = palette.ConvertToMemory();
			try
			{
				int num = GDIPlus.GdipGetImageAttributesAdjustedPalette(new HandleRef(this, nativeImageAttributes), new HandleRef(null, intPtr), type);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				palette.ConvertFromMemory(intPtr);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}
	}
	/// <summary>Provides attributes of an image encoder/decoder (codec).</summary>
	[Flags]
	public enum ImageCodecFlags
	{
		/// <summary>The codec supports encoding (saving).</summary>
		Encoder = 1,
		/// <summary>The codec supports decoding (reading).</summary>
		Decoder = 2,
		/// <summary>The codec supports raster images (bitmaps).</summary>
		SupportBitmap = 4,
		/// <summary>The codec supports vector images (metafiles).</summary>
		SupportVector = 8,
		/// <summary>The encoder requires a seekable output stream.</summary>
		SeekableEncode = 0x10,
		/// <summary>The decoder has blocking behavior during the decoding process.</summary>
		BlockingDecode = 0x20,
		/// <summary>The codec is built into GDI+.</summary>
		Builtin = 0x10000,
		/// <summary>Not used.</summary>
		System = 0x20000,
		/// <summary>Not used.</summary>
		User = 0x40000
	}
	/// <summary>The <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> class provides the necessary storage members and methods to retrieve all pertinent information about the installed image encoders and decoders (called codecs). Not inheritable.</summary>
	public sealed class ImageCodecInfo
	{
		private Guid _clsid;

		private Guid _formatID;

		private string _codecName;

		private string _dllName;

		private string _formatDescription;

		private string _filenameExtension;

		private string _mimeType;

		private ImageCodecFlags _flags;

		private int _version;

		private byte[][] _signaturePatterns;

		private byte[][] _signatureMasks;

		/// <summary>Gets or sets a <see cref="T:System.Guid" /> structure that contains a GUID that identifies a specific codec.</summary>
		/// <returns>A <see cref="T:System.Guid" /> structure that contains a GUID that identifies a specific codec.</returns>
		public Guid Clsid
		{
			get
			{
				return _clsid;
			}
			set
			{
				_clsid = value;
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Guid" /> structure that contains a GUID that identifies the codec's format.</summary>
		/// <returns>A <see cref="T:System.Guid" /> structure that contains a GUID that identifies the codec's format.</returns>
		public Guid FormatID
		{
			get
			{
				return _formatID;
			}
			set
			{
				_formatID = value;
			}
		}

		/// <summary>Gets or sets a string that contains the name of the codec.</summary>
		/// <returns>A string that contains the name of the codec.</returns>
		public string CodecName
		{
			get
			{
				return _codecName;
			}
			set
			{
				_codecName = value;
			}
		}

		/// <summary>Gets or sets string that contains the path name of the DLL that holds the codec. If the codec is not in a DLL, this pointer is <see langword="null" />.</summary>
		/// <returns>A string that contains the path name of the DLL that holds the codec.</returns>
		public string DllName
		{
			get
			{
				return _dllName;
			}
			set
			{
				_dllName = value;
			}
		}

		/// <summary>Gets or sets a string that describes the codec's file format.</summary>
		/// <returns>A string that describes the codec's file format.</returns>
		public string FormatDescription
		{
			get
			{
				return _formatDescription;
			}
			set
			{
				_formatDescription = value;
			}
		}

		/// <summary>Gets or sets string that contains the file name extension(s) used in the codec. The extensions are separated by semicolons.</summary>
		/// <returns>A string that contains the file name extension(s) used in the codec.</returns>
		public string FilenameExtension
		{
			get
			{
				return _filenameExtension;
			}
			set
			{
				_filenameExtension = value;
			}
		}

		/// <summary>Gets or sets a string that contains the codec's Multipurpose Internet Mail Extensions (MIME) type.</summary>
		/// <returns>A string that contains the codec's Multipurpose Internet Mail Extensions (MIME) type.</returns>
		public string MimeType
		{
			get
			{
				return _mimeType;
			}
			set
			{
				_mimeType = value;
			}
		}

		/// <summary>Gets or sets 32-bit value used to store additional information about the codec. This property returns a combination of flags from the <see cref="T:System.Drawing.Imaging.ImageCodecFlags" /> enumeration.</summary>
		/// <returns>A 32-bit value used to store additional information about the codec.</returns>
		public ImageCodecFlags Flags
		{
			get
			{
				return _flags;
			}
			set
			{
				_flags = value;
			}
		}

		/// <summary>Gets or sets the version number of the codec.</summary>
		/// <returns>The version number of the codec.</returns>
		public int Version
		{
			get
			{
				return _version;
			}
			set
			{
				_version = value;
			}
		}

		/// <summary>Gets or sets a two dimensional array of bytes that represents the signature of the codec.</summary>
		/// <returns>A two dimensional array of bytes that represents the signature of the codec.</returns>
		[CLSCompliant(false)]
		public byte[][] SignaturePatterns
		{
			get
			{
				return _signaturePatterns;
			}
			set
			{
				_signaturePatterns = value;
			}
		}

		/// <summary>Gets or sets a two dimensional array of bytes that can be used as a filter.</summary>
		/// <returns>A two dimensional array of bytes that can be used as a filter.</returns>
		[CLSCompliant(false)]
		public byte[][] SignatureMasks
		{
			get
			{
				return _signatureMasks;
			}
			set
			{
				_signatureMasks = value;
			}
		}

		internal ImageCodecInfo()
		{
		}

		/// <summary>Returns an array of <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> objects that contain information about the image decoders built into GDI+.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> objects. Each <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> object in the array contains information about one of the built-in image decoders.</returns>
		public static ImageCodecInfo[] GetImageDecoders()
		{
			int num = GDIPlus.GdipGetImageDecodersSize(out var decoderNums, out var arraySize);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			IntPtr intPtr = Marshal.AllocHGlobal(arraySize);
			try
			{
				num = GDIPlus.GdipGetImageDecoders(decoderNums, arraySize, intPtr);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return ConvertFromMemory(intPtr, decoderNums);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Returns an array of <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> objects that contain information about the image encoders built into GDI+.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> objects. Each <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> object in the array contains information about one of the built-in image encoders.</returns>
		public static ImageCodecInfo[] GetImageEncoders()
		{
			int num = GDIPlus.GdipGetImageEncodersSize(out var encoderNums, out var arraySize);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			IntPtr intPtr = Marshal.AllocHGlobal(arraySize);
			try
			{
				num = GDIPlus.GdipGetImageEncoders(encoderNums, arraySize, intPtr);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return ConvertFromMemory(intPtr, encoderNums);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		private static ImageCodecInfo[] ConvertFromMemory(IntPtr memoryStart, int numCodecs)
		{
			ImageCodecInfo[] array = new ImageCodecInfo[numCodecs];
			for (int i = 0; i < numCodecs; i++)
			{
				IntPtr ptr = (IntPtr)((long)memoryStart + Marshal.SizeOf(typeof(ImageCodecInfoPrivate)) * i);
				ImageCodecInfoPrivate imageCodecInfoPrivate = new ImageCodecInfoPrivate();
				Marshal.PtrToStructure(ptr, imageCodecInfoPrivate);
				array[i] = new ImageCodecInfo();
				array[i].Clsid = imageCodecInfoPrivate.Clsid;
				array[i].FormatID = imageCodecInfoPrivate.FormatID;
				array[i].CodecName = Marshal.PtrToStringUni(imageCodecInfoPrivate.CodecName);
				array[i].DllName = Marshal.PtrToStringUni(imageCodecInfoPrivate.DllName);
				array[i].FormatDescription = Marshal.PtrToStringUni(imageCodecInfoPrivate.FormatDescription);
				array[i].FilenameExtension = Marshal.PtrToStringUni(imageCodecInfoPrivate.FilenameExtension);
				array[i].MimeType = Marshal.PtrToStringUni(imageCodecInfoPrivate.MimeType);
				array[i].Flags = (ImageCodecFlags)imageCodecInfoPrivate.Flags;
				array[i].Version = imageCodecInfoPrivate.Version;
				array[i].SignaturePatterns = new byte[imageCodecInfoPrivate.SigCount][];
				array[i].SignatureMasks = new byte[imageCodecInfoPrivate.SigCount][];
				for (int j = 0; j < imageCodecInfoPrivate.SigCount; j++)
				{
					array[i].SignaturePatterns[j] = new byte[imageCodecInfoPrivate.SigSize];
					array[i].SignatureMasks[j] = new byte[imageCodecInfoPrivate.SigSize];
					Marshal.Copy((IntPtr)((long)imageCodecInfoPrivate.SigMask + j * imageCodecInfoPrivate.SigSize), array[i].SignatureMasks[j], 0, imageCodecInfoPrivate.SigSize);
					Marshal.Copy((IntPtr)((long)imageCodecInfoPrivate.SigPattern + j * imageCodecInfoPrivate.SigSize), array[i].SignaturePatterns[j], 0, imageCodecInfoPrivate.SigSize);
				}
			}
			return array;
		}
	}
	[StructLayout(LayoutKind.Sequential, Pack = 8)]
	internal class ImageCodecInfoPrivate
	{
		[MarshalAs(UnmanagedType.Struct)]
		public Guid Clsid;

		[MarshalAs(UnmanagedType.Struct)]
		public Guid FormatID;

		public IntPtr CodecName = IntPtr.Zero;

		public IntPtr DllName = IntPtr.Zero;

		public IntPtr FormatDescription = IntPtr.Zero;

		public IntPtr FilenameExtension = IntPtr.Zero;

		public IntPtr MimeType = IntPtr.Zero;

		public int Flags;

		public int Version;

		public int SigCount;

		public int SigSize;

		public IntPtr SigPattern = IntPtr.Zero;

		public IntPtr SigMask = IntPtr.Zero;
	}
	/// <summary>Specifies the attributes of the pixel data contained in an <see cref="T:System.Drawing.Image" /> object. The <see cref="P:System.Drawing.Image.Flags" /> property returns a member of this enumeration.</summary>
	[Flags]
	public enum ImageFlags
	{
		/// <summary>There is no format information.</summary>
		None = 0,
		/// <summary>The pixel data is scalable.</summary>
		Scalable = 1,
		/// <summary>The pixel data contains alpha information.</summary>
		HasAlpha = 2,
		/// <summary>Specifies that the pixel data has alpha values other than 0 (transparent) and 255 (opaque).</summary>
		HasTranslucent = 4,
		/// <summary>The pixel data is partially scalable, but there are some limitations.</summary>
		PartiallyScalable = 8,
		/// <summary>The pixel data uses an RGB color space.</summary>
		ColorSpaceRgb = 0x10,
		/// <summary>The pixel data uses a CMYK color space.</summary>
		ColorSpaceCmyk = 0x20,
		/// <summary>The pixel data is grayscale.</summary>
		ColorSpaceGray = 0x40,
		/// <summary>Specifies that the image is stored using a YCBCR color space.</summary>
		ColorSpaceYcbcr = 0x80,
		/// <summary>Specifies that the image is stored using a YCCK color space.</summary>
		ColorSpaceYcck = 0x100,
		/// <summary>Specifies that dots per inch information is stored in the image.</summary>
		HasRealDpi = 0x1000,
		/// <summary>Specifies that the pixel size is stored in the image.</summary>
		HasRealPixelSize = 0x2000,
		/// <summary>The pixel data is read-only.</summary>
		ReadOnly = 0x10000,
		/// <summary>The pixel data can be cached for faster access.</summary>
		Caching = 0x20000
	}
	/// <summary>Specifies flags that are passed to the flags parameter of the <see cref="Overload:System.Drawing.Bitmap.LockBits" /> method. The <see cref="Overload:System.Drawing.Bitmap.LockBits" /> method locks a portion of an image so that you can read or write the pixel data.</summary>
	public enum ImageLockMode
	{
		/// <summary>Specifies that a portion of the image is locked for reading.</summary>
		ReadOnly = 1,
		/// <summary>Specifies that a portion of the image is locked for writing.</summary>
		WriteOnly,
		/// <summary>Specifies that a portion of the image is locked for reading or writing.</summary>
		ReadWrite,
		/// <summary>Specifies that the buffer used for reading or writing pixel data is allocated by the user. If this flag is set, the <paramref name="flags" /> parameter of the <see cref="Overload:System.Drawing.Bitmap.LockBits" /> method serves as an input parameter (and possibly as an output parameter). If this flag is cleared, then the <paramref name="flags" /> parameter serves only as an output parameter.</summary>
		UserInputBuffer
	}
	/// <summary>Specifies the unit of measurement for the rectangle used to size and position a metafile. This is specified during the creation of the <see cref="T:System.Drawing.Imaging.Metafile" /> object.</summary>
	public enum MetafileFrameUnit
	{
		/// <summary>The unit of measurement is 1 pixel.</summary>
		Pixel = 2,
		/// <summary>The unit of measurement is 1 printer's point.</summary>
		Point,
		/// <summary>The unit of measurement is 1 inch.</summary>
		Inch,
		/// <summary>The unit of measurement is 1/300 of an inch.</summary>
		Document,
		/// <summary>The unit of measurement is 1 millimeter.</summary>
		Millimeter,
		/// <summary>The unit of measurement is 0.01 millimeter. Provided for compatibility with GDI.</summary>
		GdiCompatible
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class MetafileHeaderEmf
	{
		public MetafileType type;

		public int size;

		public int version;

		public EmfPlusFlags emfPlusFlags;

		public float dpiX;

		public float dpiY;

		public int X;

		public int Y;

		public int Width;

		public int Height;

		public SafeNativeMethods.ENHMETAHEADER EmfHeader;

		public int EmfPlusHeaderSize;

		public int LogicalDpiX;

		public int LogicalDpiY;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 8)]
	internal class MetafileHeaderWmf
	{
		public MetafileType type;

		public int size = Marshal.SizeOf(typeof(MetafileHeaderWmf));

		public int version;

		public EmfPlusFlags emfPlusFlags;

		public float dpiX;

		public float dpiY;

		public int X;

		public int Y;

		public int Width;

		public int Height;

		[MarshalAs(UnmanagedType.Struct)]
		public MetaHeader WmfHeader = new MetaHeader();

		public int dummy1;

		public int dummy2;

		public int dummy3;

		public int dummy4;

		public int dummy5;

		public int dummy6;

		public int dummy7;

		public int dummy8;

		public int dummy9;

		public int dummy10;

		public int dummy11;

		public int dummy12;

		public int dummy13;

		public int dummy14;

		public int dummy15;

		public int dummy16;

		public int EmfPlusHeaderSize;

		public int LogicalDpiX;

		public int LogicalDpiY;
	}
	/// <summary>Specifies types of metafiles. The <see cref="P:System.Drawing.Imaging.MetafileHeader.Type" /> property returns a member of this enumeration.</summary>
	public enum MetafileType
	{
		/// <summary>Specifies a metafile format that is not recognized in GDI+.</summary>
		Invalid,
		/// <summary>Specifies a WMF (Windows Metafile) file. Such a file contains only GDI records.</summary>
		Wmf,
		/// <summary>Specifies a WMF (Windows Metafile) file that has a placeable metafile header in front of it.</summary>
		WmfPlaceable,
		/// <summary>Specifies an Enhanced Metafile (EMF) file. Such a file contains only GDI records.</summary>
		Emf,
		/// <summary>Specifies an EMF+ file. Such a file contains only GDI+ records and must be displayed by using GDI+. Displaying the records using GDI may cause unpredictable results.</summary>
		EmfPlusOnly,
		/// <summary>Specifies an EMF+ Dual file. Such a file contains GDI+ records along with alternative GDI records and can be displayed by using either GDI or GDI+. Displaying the records using GDI may cause some quality degradation.</summary>
		EmfPlusDual
	}
	/// <summary>Specifies the type of color data in the system palette. The data can be color data with alpha, grayscale data only, or halftone data.</summary>
	[Flags]
	public enum PaletteFlags
	{
		/// <summary>Alpha data.</summary>
		HasAlpha = 1,
		/// <summary>Grayscale data.</summary>
		GrayScale = 2,
		/// <summary>Halftone data.</summary>
		Halftone = 4
	}
	/// <summary>Specifies the format of the color data for each pixel in the image.</summary>
	public enum PixelFormat
	{
		/// <summary>The pixel data contains color-indexed values, which means the values are an index to colors in the system color table, as opposed to individual color values.</summary>
		Indexed = 65536,
		/// <summary>The pixel data contains GDI colors.</summary>
		Gdi = 131072,
		/// <summary>The pixel data contains alpha values that are not premultiplied.</summary>
		Alpha = 262144,
		/// <summary>The pixel format contains premultiplied alpha values.</summary>
		PAlpha = 524288,
		/// <summary>Reserved.</summary>
		Extended = 1048576,
		/// <summary>The default pixel format of 32 bits per pixel. The format specifies 24-bit color depth and an 8-bit alpha channel.</summary>
		Canonical = 2097152,
		/// <summary>The pixel format is undefined.</summary>
		Undefined = 0,
		/// <summary>No pixel format is specified.</summary>
		DontCare = 0,
		/// <summary>Specifies that the pixel format is 1 bit per pixel and that it uses indexed color. The color table therefore has two colors in it.</summary>
		Format1bppIndexed = 196865,
		/// <summary>Specifies that the format is 4 bits per pixel, indexed.</summary>
		Format4bppIndexed = 197634,
		/// <summary>Specifies that the format is 8 bits per pixel, indexed. The color table therefore has 256 colors in it.</summary>
		Format8bppIndexed = 198659,
		/// <summary>The pixel format is 16 bits per pixel. The color information specifies 65536 shades of gray.</summary>
		Format16bppGrayScale = 1052676,
		/// <summary>Specifies that the format is 16 bits per pixel; 5 bits each are used for the red, green, and blue components. The remaining bit is not used.</summary>
		Format16bppRgb555 = 135173,
		/// <summary>Specifies that the format is 16 bits per pixel; 5 bits are used for the red component, 6 bits are used for the green component, and 5 bits are used for the blue component.</summary>
		Format16bppRgb565 = 135174,
		/// <summary>The pixel format is 16 bits per pixel. The color information specifies 32,768 shades of color, of which 5 bits are red, 5 bits are green, 5 bits are blue, and 1 bit is alpha.</summary>
		Format16bppArgb1555 = 397319,
		/// <summary>Specifies that the format is 24 bits per pixel; 8 bits each are used for the red, green, and blue components.</summary>
		Format24bppRgb = 137224,
		/// <summary>Specifies that the format is 32 bits per pixel; 8 bits each are used for the red, green, and blue components. The remaining 8 bits are not used.</summary>
		Format32bppRgb = 139273,
		/// <summary>Specifies that the format is 32 bits per pixel; 8 bits each are used for the alpha, red, green, and blue components.</summary>
		Format32bppArgb = 2498570,
		/// <summary>Specifies that the format is 32 bits per pixel; 8 bits each are used for the alpha, red, green, and blue components. The red, green, and blue components are premultiplied, according to the alpha component.</summary>
		Format32bppPArgb = 925707,
		/// <summary>Specifies that the format is 48 bits per pixel; 16 bits each are used for the red, green, and blue components.</summary>
		Format48bppRgb = 1060876,
		/// <summary>Specifies that the format is 64 bits per pixel; 16 bits each are used for the alpha, red, green, and blue components.</summary>
		Format64bppArgb = 3424269,
		/// <summary>Specifies that the format is 64 bits per pixel; 16 bits each are used for the alpha, red, green, and blue components. The red, green, and blue components are premultiplied according to the alpha component.</summary>
		Format64bppPArgb = 1851406,
		/// <summary>The maximum value for this enumeration.</summary>
		Max = 15
	}
	/// <summary>This delegate is not used. For an example of enumerating the records of a metafile, see <see cref="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc)" />.</summary>
	/// <param name="recordType">Not used.</param>
	/// <param name="flags">Not used.</param>
	/// <param name="dataSize">Not used.</param>
	/// <param name="recordData">Not used.</param>
	public delegate void PlayRecordCallback(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr recordData);
	/// <summary>Encapsulates a metadata property to be included in an image file. Not inheritable.</summary>
	public sealed class PropertyItem
	{
		private int _id;

		private int _len;

		private short _type;

		private byte[] _value;

		/// <summary>Gets or sets the ID of the property.</summary>
		/// <returns>The integer that represents the ID of the property.</returns>
		public int Id
		{
			get
			{
				return _id;
			}
			set
			{
				_id = value;
			}
		}

		/// <summary>Gets or sets the length (in bytes) of the <see cref="P:System.Drawing.Imaging.PropertyItem.Value" /> property.</summary>
		/// <returns>An integer that represents the length (in bytes) of the <see cref="P:System.Drawing.Imaging.PropertyItem.Value" /> byte array.</returns>
		public int Len
		{
			get
			{
				return _len;
			}
			set
			{
				_len = value;
			}
		}

		/// <summary>Gets or sets an integer that defines the type of data contained in the <see cref="P:System.Drawing.Imaging.PropertyItem.Value" /> property.</summary>
		/// <returns>An integer that defines the type of data contained in <see cref="P:System.Drawing.Imaging.PropertyItem.Value" />.</returns>
		public short Type
		{
			get
			{
				return _type;
			}
			set
			{
				_type = value;
			}
		}

		/// <summary>Gets or sets the value of the property item.</summary>
		/// <returns>A byte array that represents the value of the property item.</returns>
		public byte[] Value
		{
			get
			{
				return _value;
			}
			set
			{
				_value = value;
			}
		}

		internal PropertyItem()
		{
		}
	}
	/// <summary>Defines a placeable metafile. Not inheritable.</summary>
	[StructLayout(LayoutKind.Sequential)]
	public sealed class WmfPlaceableFileHeader
	{
		private int _key = -1698247209;

		private short _hmf;

		private short _bboxLeft;

		private short _bboxTop;

		private short _bboxRight;

		private short _bboxBottom;

		private short _inch;

		private int _reserved;

		private short _checksum;

		/// <summary>Gets or sets a value indicating the presence of a placeable metafile header.</summary>
		/// <returns>A value indicating presence of a placeable metafile header.</returns>
		public int Key
		{
			get
			{
				return _key;
			}
			set
			{
				_key = value;
			}
		}

		/// <summary>Gets or sets the handle of the metafile in memory.</summary>
		/// <returns>The handle of the metafile in memory.</returns>
		public short Hmf
		{
			get
			{
				return _hmf;
			}
			set
			{
				_hmf = value;
			}
		}

		/// <summary>Gets or sets the x-coordinate of the upper-left corner of the bounding rectangle of the metafile image on the output device.</summary>
		/// <returns>The x-coordinate of the upper-left corner of the bounding rectangle of the metafile image on the output device.</returns>
		public short BboxLeft
		{
			get
			{
				return _bboxLeft;
			}
			set
			{
				_bboxLeft = value;
			}
		}

		/// <summary>Gets or sets the y-coordinate of the upper-left corner of the bounding rectangle of the metafile image on the output device.</summary>
		/// <returns>The y-coordinate of the upper-left corner of the bounding rectangle of the metafile image on the output device.</returns>
		public short BboxTop
		{
			get
			{
				return _bboxTop;
			}
			set
			{
				_bboxTop = value;
			}
		}

		/// <summary>Gets or sets the x-coordinate of the lower-right corner of the bounding rectangle of the metafile image on the output device.</summary>
		/// <returns>The x-coordinate of the lower-right corner of the bounding rectangle of the metafile image on the output device.</returns>
		public short BboxRight
		{
			get
			{
				return _bboxRight;
			}
			set
			{
				_bboxRight = value;
			}
		}

		/// <summary>Gets or sets the y-coordinate of the lower-right corner of the bounding rectangle of the metafile image on the output device.</summary>
		/// <returns>The y-coordinate of the lower-right corner of the bounding rectangle of the metafile image on the output device.</returns>
		public short BboxBottom
		{
			get
			{
				return _bboxBottom;
			}
			set
			{
				_bboxBottom = value;
			}
		}

		/// <summary>Gets or sets the number of twips per inch.</summary>
		/// <returns>The number of twips per inch.</returns>
		public short Inch
		{
			get
			{
				return _inch;
			}
			set
			{
				_inch = value;
			}
		}

		/// <summary>Reserved. Do not use.</summary>
		/// <returns>Reserved. Do not use.</returns>
		public int Reserved
		{
			get
			{
				return _reserved;
			}
			set
			{
				_reserved = value;
			}
		}

		/// <summary>Gets or sets the checksum value for the previous ten <see langword="WORD" /> s in the header.</summary>
		/// <returns>The checksum value for the previous ten <see langword="WORD" /> s in the header.</returns>
		public short Checksum
		{
			get
			{
				return _checksum;
			}
			set
			{
				_checksum = value;
			}
		}

		/// <summary>Initializes a new instance of the <see langword="WmfPlaceableFileHeader" /> class.</summary>
		public WmfPlaceableFileHeader()
		{
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal sealed class PropertyItemInternal : IDisposable
	{
		public int id;

		public int len;

		public short type;

		public IntPtr value = IntPtr.Zero;

		public byte[] Value
		{
			get
			{
				if (len == 0)
				{
					return null;
				}
				byte[] array = new byte[len];
				Marshal.Copy(value, array, 0, len);
				return array;
			}
		}

		internal PropertyItemInternal()
		{
		}

		~PropertyItemInternal()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		private void Dispose(bool disposing)
		{
			if (value != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(value);
				value = IntPtr.Zero;
			}
			if (disposing)
			{
				GC.SuppressFinalize(this);
			}
		}

		internal static PropertyItemInternal ConvertFromPropertyItem(PropertyItem propItem)
		{
			PropertyItemInternal propertyItemInternal = new PropertyItemInternal();
			propertyItemInternal.id = propItem.Id;
			propertyItemInternal.len = 0;
			propertyItemInternal.type = propItem.Type;
			byte[] array = propItem.Value;
			if (array != null)
			{
				int num = (propertyItemInternal.len = array.Length);
				propertyItemInternal.value = Marshal.AllocHGlobal(num);
				Marshal.Copy(array, 0, propertyItemInternal.value, num);
			}
			return propertyItemInternal;
		}

		internal static PropertyItem[] ConvertFromMemory(IntPtr propdata, int count)
		{
			PropertyItem[] array = new PropertyItem[count];
			for (int i = 0; i < count; i++)
			{
				PropertyItemInternal propertyItemInternal = null;
				try
				{
					propertyItemInternal = (PropertyItemInternal)Marshal.PtrToStructure(propdata, typeof(PropertyItemInternal));
					array[i] = new PropertyItem();
					array[i].Id = propertyItemInternal.id;
					array[i].Len = propertyItemInternal.len;
					array[i].Type = propertyItemInternal.type;
					array[i].Value = propertyItemInternal.Value;
					propertyItemInternal.value = IntPtr.Zero;
				}
				finally
				{
					propertyItemInternal?.Dispose();
				}
				propdata = (IntPtr)((long)propdata + Marshal.SizeOf(typeof(PropertyItemInternal)));
			}
			return array;
		}
	}
	/// <summary>Specifies the attributes of a bitmap image. The <see cref="T:System.Drawing.Imaging.BitmapData" /> class is used by the <see cref="Overload:System.Drawing.Bitmap.LockBits" /> and <see cref="M:System.Drawing.Bitmap.UnlockBits(System.Drawing.Imaging.BitmapData)" /> methods of the <see cref="T:System.Drawing.Bitmap" /> class. Not inheritable.</summary>
	[StructLayout(LayoutKind.Sequential)]
	public sealed class BitmapData
	{
		private int width;

		private int height;

		private int stride;

		private PixelFormat pixel_format;

		private IntPtr scan0;

		private int reserved;

		private IntPtr palette;

		private int property_count;

		private IntPtr property;

		private float dpi_horz;

		private float dpi_vert;

		private int image_flags;

		private int left;

		private int top;

		private int x;

		private int y;

		private int transparent;

		/// <summary>Gets or sets the pixel height of the <see cref="T:System.Drawing.Bitmap" /> object. Also sometimes referred to as the number of scan lines.</summary>
		/// <returns>The pixel height of the <see cref="T:System.Drawing.Bitmap" /> object.</returns>
		public int Height
		{
			get
			{
				return height;
			}
			set
			{
				height = value;
			}
		}

		/// <summary>Gets or sets the pixel width of the <see cref="T:System.Drawing.Bitmap" /> object. This can also be thought of as the number of pixels in one scan line.</summary>
		/// <returns>The pixel width of the <see cref="T:System.Drawing.Bitmap" /> object.</returns>
		public int Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		/// <summary>Gets or sets the format of the pixel information in the <see cref="T:System.Drawing.Bitmap" /> object that returned this <see cref="T:System.Drawing.Imaging.BitmapData" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Imaging.PixelFormat" /> that specifies the format of the pixel information in the associated <see cref="T:System.Drawing.Bitmap" /> object.</returns>
		public PixelFormat PixelFormat
		{
			get
			{
				return pixel_format;
			}
			set
			{
				pixel_format = value;
			}
		}

		/// <summary>Reserved. Do not use.</summary>
		/// <returns>Reserved. Do not use.</returns>
		public int Reserved
		{
			get
			{
				return reserved;
			}
			set
			{
				reserved = value;
			}
		}

		/// <summary>Gets or sets the address of the first pixel data in the bitmap. This can also be thought of as the first scan line in the bitmap.</summary>
		/// <returns>The address of the first pixel data in the bitmap.</returns>
		public IntPtr Scan0
		{
			get
			{
				return scan0;
			}
			set
			{
				scan0 = value;
			}
		}

		/// <summary>Gets or sets the stride width (also called scan width) of the <see cref="T:System.Drawing.Bitmap" /> object.</summary>
		/// <returns>The stride width, in bytes, of the <see cref="T:System.Drawing.Bitmap" /> object.</returns>
		public int Stride
		{
			get
			{
				return stride;
			}
			set
			{
				stride = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.BitmapData" /> class.</summary>
		public BitmapData()
		{
		}
	}
	/// <summary>Specifies the file format of the image. Not inheritable.</summary>
	[TypeConverter(typeof(ImageFormatConverter))]
	public sealed class ImageFormat
	{
		private Guid guid;

		private string name;

		private const string BmpGuid = "b96b3cab-0728-11d3-9d7b-0000f81ef32e";

		private const string EmfGuid = "b96b3cac-0728-11d3-9d7b-0000f81ef32e";

		private const string ExifGuid = "b96b3cb2-0728-11d3-9d7b-0000f81ef32e";

		private const string GifGuid = "b96b3cb0-0728-11d3-9d7b-0000f81ef32e";

		private const string TiffGuid = "b96b3cb1-0728-11d3-9d7b-0000f81ef32e";

		private const string PngGuid = "b96b3caf-0728-11d3-9d7b-0000f81ef32e";

		private const string MemoryBmpGuid = "b96b3caa-0728-11d3-9d7b-0000f81ef32e";

		private const string IconGuid = "b96b3cb5-0728-11d3-9d7b-0000f81ef32e";

		private const string JpegGuid = "b96b3cae-0728-11d3-9d7b-0000f81ef32e";

		private const string WmfGuid = "b96b3cad-0728-11d3-9d7b-0000f81ef32e";

		private static object locker = new object();

		private static ImageFormat BmpImageFormat;

		private static ImageFormat EmfImageFormat;

		private static ImageFormat ExifImageFormat;

		private static ImageFormat GifImageFormat;

		private static ImageFormat TiffImageFormat;

		private static ImageFormat PngImageFormat;

		private static ImageFormat MemoryBmpImageFormat;

		private static ImageFormat IconImageFormat;

		private static ImageFormat JpegImageFormat;

		private static ImageFormat WmfImageFormat;

		/// <summary>Gets a <see cref="T:System.Guid" /> structure that represents this <see cref="T:System.Drawing.Imaging.ImageFormat" /> object.</summary>
		/// <returns>A <see cref="T:System.Guid" /> structure that represents this <see cref="T:System.Drawing.Imaging.ImageFormat" /> object.</returns>
		public Guid Guid => guid;

		/// <summary>Gets the bitmap (BMP) image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the bitmap image format.</returns>
		public static ImageFormat Bmp
		{
			get
			{
				lock (locker)
				{
					if (BmpImageFormat == null)
					{
						BmpImageFormat = new ImageFormat("Bmp", "b96b3cab-0728-11d3-9d7b-0000f81ef32e");
					}
					return BmpImageFormat;
				}
			}
		}

		/// <summary>Gets the enhanced metafile (EMF) image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the enhanced metafile image format.</returns>
		public static ImageFormat Emf
		{
			get
			{
				lock (locker)
				{
					if (EmfImageFormat == null)
					{
						EmfImageFormat = new ImageFormat("Emf", "b96b3cac-0728-11d3-9d7b-0000f81ef32e");
					}
					return EmfImageFormat;
				}
			}
		}

		/// <summary>Gets the Exchangeable Image File (Exif) format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the Exif format.</returns>
		public static ImageFormat Exif
		{
			get
			{
				lock (locker)
				{
					if (ExifImageFormat == null)
					{
						ExifImageFormat = new ImageFormat("Exif", "b96b3cb2-0728-11d3-9d7b-0000f81ef32e");
					}
					return ExifImageFormat;
				}
			}
		}

		/// <summary>Gets the Graphics Interchange Format (GIF) image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the GIF image format.</returns>
		public static ImageFormat Gif
		{
			get
			{
				lock (locker)
				{
					if (GifImageFormat == null)
					{
						GifImageFormat = new ImageFormat("Gif", "b96b3cb0-0728-11d3-9d7b-0000f81ef32e");
					}
					return GifImageFormat;
				}
			}
		}

		/// <summary>Gets the Windows icon image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the Windows icon image format.</returns>
		public static ImageFormat Icon
		{
			get
			{
				lock (locker)
				{
					if (IconImageFormat == null)
					{
						IconImageFormat = new ImageFormat("Icon", "b96b3cb5-0728-11d3-9d7b-0000f81ef32e");
					}
					return IconImageFormat;
				}
			}
		}

		/// <summary>Gets the Joint Photographic Experts Group (JPEG) image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the JPEG image format.</returns>
		public static ImageFormat Jpeg
		{
			get
			{
				lock (locker)
				{
					if (JpegImageFormat == null)
					{
						JpegImageFormat = new ImageFormat("Jpeg", "b96b3cae-0728-11d3-9d7b-0000f81ef32e");
					}
					return JpegImageFormat;
				}
			}
		}

		/// <summary>Gets the format of a bitmap in memory.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the format of a bitmap in memory.</returns>
		public static ImageFormat MemoryBmp
		{
			get
			{
				lock (locker)
				{
					if (MemoryBmpImageFormat == null)
					{
						MemoryBmpImageFormat = new ImageFormat("MemoryBMP", "b96b3caa-0728-11d3-9d7b-0000f81ef32e");
					}
					return MemoryBmpImageFormat;
				}
			}
		}

		/// <summary>Gets the W3C Portable Network Graphics (PNG) image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the PNG image format.</returns>
		public static ImageFormat Png
		{
			get
			{
				lock (locker)
				{
					if (PngImageFormat == null)
					{
						PngImageFormat = new ImageFormat("Png", "b96b3caf-0728-11d3-9d7b-0000f81ef32e");
					}
					return PngImageFormat;
				}
			}
		}

		/// <summary>Gets the Tagged Image File Format (TIFF) image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the TIFF image format.</returns>
		public static ImageFormat Tiff
		{
			get
			{
				lock (locker)
				{
					if (TiffImageFormat == null)
					{
						TiffImageFormat = new ImageFormat("Tiff", "b96b3cb1-0728-11d3-9d7b-0000f81ef32e");
					}
					return TiffImageFormat;
				}
			}
		}

		/// <summary>Gets the Windows metafile (WMF) image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the Windows metafile image format.</returns>
		public static ImageFormat Wmf
		{
			get
			{
				lock (locker)
				{
					if (WmfImageFormat == null)
					{
						WmfImageFormat = new ImageFormat("Wmf", "b96b3cad-0728-11d3-9d7b-0000f81ef32e");
					}
					return WmfImageFormat;
				}
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.ImageFormat" /> class by using the specified <see cref="T:System.Guid" /> structure.</summary>
		/// <param name="guid">The <see cref="T:System.Guid" /> structure that specifies a particular image format.</param>
		public ImageFormat(Guid guid)
		{
			this.guid = guid;
		}

		private ImageFormat(string name, string guid)
		{
			this.name = name;
			this.guid = new Guid(guid);
		}

		/// <summary>Returns a value that indicates whether the specified object is an <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that is equivalent to this <see cref="T:System.Drawing.Imaging.ImageFormat" /> object.</summary>
		/// <param name="o">The object to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="o" /> is an <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that is equivalent to this <see cref="T:System.Drawing.Imaging.ImageFormat" /> object; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object o)
		{
			if (!(o is ImageFormat { Guid: var guid }))
			{
				return false;
			}
			return guid.Equals(this.guid);
		}

		/// <summary>Returns a hash code value that represents this object.</summary>
		/// <returns>A hash code that represents this object.</returns>
		public override int GetHashCode()
		{
			return guid.GetHashCode();
		}

		/// <summary>Converts this <see cref="T:System.Drawing.Imaging.ImageFormat" /> object to a human-readable string.</summary>
		/// <returns>A string that represents this <see cref="T:System.Drawing.Imaging.ImageFormat" /> object.</returns>
		public override string ToString()
		{
			if (name != null)
			{
				return name;
			}
			return "[ImageFormat: " + guid.ToString() + "]";
		}
	}
	[StructLayout(LayoutKind.Sequential, Pack = 2)]
	internal struct WmfMetaHeader
	{
		public short file_type;

		public short header_size;

		public short version;

		public ushort file_size_low;

		public ushort file_size_high;

		public short num_of_objects;

		public int max_record_size;

		public short num_of_params;
	}
	/// <summary>Contains information about a windows-format (WMF) metafile.</summary>
	[StructLayout(LayoutKind.Sequential)]
	public sealed class MetaHeader
	{
		private WmfMetaHeader wmf;

		/// <summary>Gets or sets the size, in bytes, of the header file.</summary>
		/// <returns>The size, in bytes, of the header file.</returns>
		public short HeaderSize
		{
			get
			{
				return wmf.header_size;
			}
			set
			{
				wmf.header_size = value;
			}
		}

		/// <summary>Gets or sets the size, in bytes, of the largest record in the associated <see cref="T:System.Drawing.Imaging.Metafile" /> object.</summary>
		/// <returns>The size, in bytes, of the largest record in the associated <see cref="T:System.Drawing.Imaging.Metafile" /> object.</returns>
		public int MaxRecord
		{
			get
			{
				return wmf.max_record_size;
			}
			set
			{
				wmf.max_record_size = value;
			}
		}

		/// <summary>Gets or sets the maximum number of objects that exist in the <see cref="T:System.Drawing.Imaging.Metafile" /> object at the same time.</summary>
		/// <returns>The maximum number of objects that exist in the <see cref="T:System.Drawing.Imaging.Metafile" /> object at the same time.</returns>
		public short NoObjects
		{
			get
			{
				return wmf.num_of_objects;
			}
			set
			{
				wmf.num_of_objects = value;
			}
		}

		/// <summary>Not used. Always returns 0.</summary>
		/// <returns>Always 0.</returns>
		public short NoParameters
		{
			get
			{
				return wmf.num_of_params;
			}
			set
			{
				wmf.num_of_params = value;
			}
		}

		/// <summary>Gets or sets the size, in bytes, of the associated <see cref="T:System.Drawing.Imaging.Metafile" /> object.</summary>
		/// <returns>The size, in bytes, of the associated <see cref="T:System.Drawing.Imaging.Metafile" /> object.</returns>
		public int Size
		{
			get
			{
				if (BitConverter.IsLittleEndian)
				{
					return (wmf.file_size_high << 16) | wmf.file_size_low;
				}
				return (wmf.file_size_low << 16) | wmf.file_size_high;
			}
			set
			{
				if (BitConverter.IsLittleEndian)
				{
					wmf.file_size_high = (ushort)(value >> 16);
					wmf.file_size_low = (ushort)value;
				}
				else
				{
					wmf.file_size_high = (ushort)value;
					wmf.file_size_low = (ushort)(value >> 16);
				}
			}
		}

		/// <summary>Gets or sets the type of the associated <see cref="T:System.Drawing.Imaging.Metafile" /> object.</summary>
		/// <returns>The type of the associated <see cref="T:System.Drawing.Imaging.Metafile" /> object.</returns>
		public short Type
		{
			get
			{
				return wmf.file_type;
			}
			set
			{
				wmf.file_type = value;
			}
		}

		/// <summary>Gets or sets the version number of the header format.</summary>
		/// <returns>The version number of the header format.</returns>
		public short Version
		{
			get
			{
				return wmf.version;
			}
			set
			{
				wmf.version = value;
			}
		}

		/// <summary>Initializes a new instance of the <see langword="MetaHeader" /> class.</summary>
		public MetaHeader()
		{
		}

		internal MetaHeader(WmfMetaHeader header)
		{
			wmf.file_type = header.file_type;
			wmf.header_size = header.header_size;
			wmf.version = header.version;
			wmf.file_size_low = header.file_size_low;
			wmf.file_size_high = header.file_size_high;
			wmf.num_of_objects = header.num_of_objects;
			wmf.max_record_size = header.max_record_size;
			wmf.num_of_params = header.num_of_params;
		}
	}
	/// <summary>Defines a graphic metafile. A metafile contains records that describe a sequence of graphics operations that can be recorded (constructed) and played back (displayed). This class is not inheritable.</summary>
	[Serializable]
	[System.MonoTODO("Metafiles, both WMF and EMF formats, are only partially supported.")]
	[Editor("System.Drawing.Design.MetafileEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	public sealed class Metafile : Image
	{
		internal Metafile(IntPtr ptr)
		{
			nativeObject = ptr;
		}

		internal Metafile(IntPtr ptr, Stream stream)
		{
			if (GDIPlus.RunningOnWindows())
			{
				base.stream = stream;
			}
			nativeObject = ptr;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream.</summary>
		/// <param name="stream">The <see cref="T:System.IO.Stream" /> from which to create the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="stream" /> is <see langword="null" />.</exception>
		public Metafile(Stream stream)
		{
			if (stream == null)
			{
				throw new ArgumentException("stream");
			}
			Status status;
			if (GDIPlus.RunningOnUnix())
			{
				GDIPlus.GdiPlusStreamHelper gdiPlusStreamHelper = new GDIPlus.GdiPlusStreamHelper(stream, seekToOrigin: false);
				status = GDIPlus.GdipCreateMetafileFromDelegate_linux(gdiPlusStreamHelper.GetHeaderDelegate, gdiPlusStreamHelper.GetBytesDelegate, gdiPlusStreamHelper.PutBytesDelegate, gdiPlusStreamHelper.SeekDelegate, gdiPlusStreamHelper.CloseDelegate, gdiPlusStreamHelper.SizeDelegate, out nativeObject);
			}
			else
			{
				status = GDIPlus.GdipCreateMetafileFromStream(new ComIStreamWrapper(stream), out nativeObject);
			}
			GDIPlus.CheckStatus(status);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified file name.</summary>
		/// <param name="filename">A <see cref="T:System.String" /> that represents the file name from which to create the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string filename)
		{
			if (filename == null)
			{
				throw new ArgumentNullException("filename");
			}
			if (filename.Length == 0)
			{
				throw new ArgumentException("filename");
			}
			Status num = GDIPlus.GdipCreateMetafileFromFile(filename, out nativeObject);
			if (num == Status.GenericError)
			{
				throw new ExternalException("Couldn't load specified file.");
			}
			GDIPlus.CheckStatus(num);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified handle.</summary>
		/// <param name="henhmetafile">A handle to an enhanced metafile.</param>
		/// <param name="deleteEmf">
		///   <see langword="true" /> to delete the enhanced metafile handle when the <see cref="T:System.Drawing.Imaging.Metafile" /> is deleted; otherwise, <see langword="false" />.</param>
		public Metafile(IntPtr henhmetafile, bool deleteEmf)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateMetafileFromEmf(henhmetafile, deleteEmf, out nativeObject));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified handle to a device context and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="emfType">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, EmfType emfType)
			: this(referenceHdc, default(RectangleF), MetafileFrameUnit.GdiCompatible, emfType, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, Rectangle frameRect)
			: this(referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, RectangleF frameRect)
			: this(referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified handle and a <see cref="T:System.Drawing.Imaging.WmfPlaceableFileHeader" />.</summary>
		/// <param name="hmetafile">A windows handle to a <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="wmfHeader">A <see cref="T:System.Drawing.Imaging.WmfPlaceableFileHeader" />.</param>
		public Metafile(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateMetafileFromEmf(hmetafile, deleteEmf: false, out nativeObject));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		public Metafile(Stream stream, IntPtr referenceHdc)
			: this(stream, referenceHdc, default(RectangleF), MetafileFrameUnit.GdiCompatible, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		public Metafile(string fileName, IntPtr referenceHdc)
			: this(fileName, referenceHdc, default(RectangleF), MetafileFrameUnit.GdiCompatible, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified handle to a device context and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A string can be supplied to name the file.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="emfType">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, EmfType emfType, string description)
			: this(referenceHdc, default(RectangleF), MetafileFrameUnit.GdiCompatible, emfType, description)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle that uses the supplied unit of measure.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit)
			: this(referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle that uses the supplied unit of measure.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit)
			: this(referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified handle and a <see cref="T:System.Drawing.Imaging.WmfPlaceableFileHeader" />. Also, the <paramref name="deleteWmf" /> parameter can be used to delete the handle when the metafile is deleted.</summary>
		/// <param name="hmetafile">A windows handle to a <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="wmfHeader">A <see cref="T:System.Drawing.Imaging.WmfPlaceableFileHeader" />.</param>
		/// <param name="deleteWmf">
		///   <see langword="true" /> to delete the handle to the new <see cref="T:System.Drawing.Imaging.Metafile" /> when the <see cref="T:System.Drawing.Imaging.Metafile" /> is deleted; otherwise, <see langword="false" />.</param>
		public Metafile(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader, bool deleteWmf)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateMetafileFromEmf(hmetafile, deleteWmf, out nativeObject));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, EmfType type)
			: this(stream, referenceHdc, default(RectangleF), MetafileFrameUnit.GdiCompatible, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, and a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect)
			: this(stream, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, and a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect)
			: this(stream, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, EmfType type)
			: this(fileName, referenceHdc, default(RectangleF), MetafileFrameUnit.GdiCompatible, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, and a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect)
			: this(fileName, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, and a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect)
			: this(fileName, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle that uses the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle that uses the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. Also, a string that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" /> can be added.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, EmfType type, string description)
			: this(stream, referenceHdc, default(RectangleF), MetafileFrameUnit.GdiCompatible, type, description)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, and the supplied unit of measure.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit)
			: this(stream, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, and the supplied unit of measure.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit)
			: this(stream, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A descriptive string can be added, as well.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, EmfType type, string description)
			: this(fileName, referenceHdc, default(RectangleF), MetafileFrameUnit.GdiCompatible, type, description)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, and the supplied unit of measure.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit)
			: this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, and the supplied unit of measure.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit)
			: this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle that uses the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A string can be provided to name the file.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="desc">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string desc)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipRecordMetafileI(referenceHdc, type, ref frameRect, frameUnit, desc, out nativeObject));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle that uses the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A string can be provided to name the file.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipRecordMetafile(referenceHdc, type, ref frameRect, frameUnit, description, out nativeObject));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(stream, referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(stream, referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(fileName, referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, and the supplied unit of measure. A descriptive string can also be added.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, string description)
			: this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual, description)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(fileName, referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, and the supplied unit of measure. A descriptive string can also be added.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="desc">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, string desc)
			: this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual, desc)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A string that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" /> can be added.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
		{
			if (stream == null)
			{
				throw new NullReferenceException("stream");
			}
			Status status = Status.NotImplemented;
			if (GDIPlus.RunningOnUnix())
			{
				GDIPlus.GdiPlusStreamHelper gdiPlusStreamHelper = new GDIPlus.GdiPlusStreamHelper(stream, seekToOrigin: false);
				status = GDIPlus.GdipRecordMetafileFromDelegateI_linux(gdiPlusStreamHelper.GetHeaderDelegate, gdiPlusStreamHelper.GetBytesDelegate, gdiPlusStreamHelper.PutBytesDelegate, gdiPlusStreamHelper.SeekDelegate, gdiPlusStreamHelper.CloseDelegate, gdiPlusStreamHelper.SizeDelegate, referenceHdc, type, ref frameRect, frameUnit, description, out nativeObject);
			}
			else
			{
				status = GDIPlus.GdipRecordMetafileStreamI(new ComIStreamWrapper(stream), referenceHdc, type, ref frameRect, frameUnit, description, out nativeObject);
			}
			GDIPlus.CheckStatus(status);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A string that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" /> can be added.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
		{
			if (stream == null)
			{
				throw new NullReferenceException("stream");
			}
			Status status = Status.NotImplemented;
			if (GDIPlus.RunningOnUnix())
			{
				GDIPlus.GdiPlusStreamHelper gdiPlusStreamHelper = new GDIPlus.GdiPlusStreamHelper(stream, seekToOrigin: false);
				status = GDIPlus.GdipRecordMetafileFromDelegate_linux(gdiPlusStreamHelper.GetHeaderDelegate, gdiPlusStreamHelper.GetBytesDelegate, gdiPlusStreamHelper.PutBytesDelegate, gdiPlusStreamHelper.SeekDelegate, gdiPlusStreamHelper.CloseDelegate, gdiPlusStreamHelper.SizeDelegate, referenceHdc, type, ref frameRect, frameUnit, description, out nativeObject);
			}
			else
			{
				status = GDIPlus.GdipRecordMetafileStream(new ComIStreamWrapper(stream), referenceHdc, type, ref frameRect, frameUnit, description, out nativeObject);
			}
			GDIPlus.CheckStatus(status);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A descriptive string can also be added.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipRecordMetafileFileNameI(fileName, referenceHdc, type, ref frameRect, frameUnit, description, out nativeObject));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A descriptive string can also be added.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipRecordMetafileFileName(fileName, referenceHdc, type, ref frameRect, frameUnit, description, out nativeObject));
		}

		/// <summary>Returns a Windows handle to an enhanced <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>A Windows handle to this enhanced <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public IntPtr GetHenhmetafile()
		{
			return nativeObject;
		}

		/// <summary>Returns the <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with this <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with this <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		[System.MonoLimitation("Metafiles aren't only partially supported by libgdiplus.")]
		public MetafileHeader GetMetafileHeader()
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(MetafileHeader)));
			try
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetMetafileHeaderFromMetafile(nativeObject, intPtr));
				return new MetafileHeader(intPtr);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Returns the <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="henhmetafile">The handle to the enhanced <see cref="T:System.Drawing.Imaging.Metafile" /> for which a header is returned.</param>
		/// <returns>The <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		[System.MonoLimitation("Metafiles aren't only partially supported by libgdiplus.")]
		public static MetafileHeader GetMetafileHeader(IntPtr henhmetafile)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(MetafileHeader)));
			try
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetMetafileHeaderFromEmf(henhmetafile, intPtr));
				return new MetafileHeader(intPtr);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Returns the <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> containing the <see cref="T:System.Drawing.Imaging.Metafile" /> for which a header is retrieved.</param>
		/// <returns>The <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		[System.MonoLimitation("Metafiles aren't only partially supported by libgdiplus.")]
		public static MetafileHeader GetMetafileHeader(Stream stream)
		{
			if (stream == null)
			{
				throw new NullReferenceException("stream");
			}
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(MetafileHeader)));
			try
			{
				Status status;
				if (GDIPlus.RunningOnUnix())
				{
					GDIPlus.GdiPlusStreamHelper gdiPlusStreamHelper = new GDIPlus.GdiPlusStreamHelper(stream, seekToOrigin: false);
					status = GDIPlus.GdipGetMetafileHeaderFromDelegate_linux(gdiPlusStreamHelper.GetHeaderDelegate, gdiPlusStreamHelper.GetBytesDelegate, gdiPlusStreamHelper.PutBytesDelegate, gdiPlusStreamHelper.SeekDelegate, gdiPlusStreamHelper.CloseDelegate, gdiPlusStreamHelper.SizeDelegate, intPtr);
				}
				else
				{
					status = GDIPlus.GdipGetMetafileHeaderFromStream(new ComIStreamWrapper(stream), intPtr);
				}
				GDIPlus.CheckStatus(status);
				return new MetafileHeader(intPtr);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Returns the <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> containing the name of the <see cref="T:System.Drawing.Imaging.Metafile" /> for which a header is retrieved.</param>
		/// <returns>The <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		[System.MonoLimitation("Metafiles aren't only partially supported by libgdiplus.")]
		public static MetafileHeader GetMetafileHeader(string fileName)
		{
			if (fileName == null)
			{
				throw new ArgumentNullException("fileName");
			}
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(MetafileHeader)));
			try
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetMetafileHeaderFromFile(fileName, intPtr));
				return new MetafileHeader(intPtr);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Returns the <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="hmetafile">The handle to the <see cref="T:System.Drawing.Imaging.Metafile" /> for which to return a header.</param>
		/// <param name="wmfHeader">A <see cref="T:System.Drawing.Imaging.WmfPlaceableFileHeader" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		[System.MonoLimitation("Metafiles aren't only partially supported by libgdiplus.")]
		public static MetafileHeader GetMetafileHeader(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(MetafileHeader)));
			try
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetMetafileHeaderFromEmf(hmetafile, intPtr));
				return new MetafileHeader(intPtr);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Plays an individual metafile record.</summary>
		/// <param name="recordType">Element of the <see cref="T:System.Drawing.Imaging.EmfPlusRecordType" /> that specifies the type of metafile record being played.</param>
		/// <param name="flags">A set of flags that specify attributes of the record.</param>
		/// <param name="dataSize">The number of bytes in the record data.</param>
		/// <param name="data">An array of bytes that contains the record data.</param>
		[System.MonoLimitation("Metafiles aren't only partially supported by libgdiplus.")]
		public void PlayRecord(EmfPlusRecordType recordType, int flags, int dataSize, byte[] data)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipPlayMetafileRecord(nativeObject, recordType, flags, dataSize, data));
		}
	}
	[StructLayout(LayoutKind.Sequential, Pack = 2)]
	internal struct EnhMetafileHeader
	{
		public int type;

		public int size;

		public Rectangle bounds;

		public Rectangle frame;

		public int signature;

		public int version;

		public int bytes;

		public int records;

		public short handles;

		public short reserved;

		public int description;

		public int off_description;

		public int palette_entires;

		public Size device;

		public Size millimeters;
	}
	[StructLayout(LayoutKind.Explicit)]
	internal struct MonoMetafileHeader
	{
		[FieldOffset(0)]
		public MetafileType type;

		[FieldOffset(4)]
		public int size;

		[FieldOffset(8)]
		public int version;

		[FieldOffset(12)]
		public int emf_plus_flags;

		[FieldOffset(16)]
		public float dpi_x;

		[FieldOffset(20)]
		public float dpi_y;

		[FieldOffset(24)]
		public int x;

		[FieldOffset(28)]
		public int y;

		[FieldOffset(32)]
		public int width;

		[FieldOffset(36)]
		public int height;

		[FieldOffset(40)]
		public WmfMetaHeader wmf_header;

		[FieldOffset(40)]
		public EnhMetafileHeader emf_header;

		[FieldOffset(128)]
		public int emfplus_header_size;

		[FieldOffset(132)]
		public int logical_dpi_x;

		[FieldOffset(136)]
		public int logical_dpi_y;
	}
	/// <summary>Contains attributes of an associated <see cref="T:System.Drawing.Imaging.Metafile" />. Not inheritable.</summary>
	[StructLayout(LayoutKind.Sequential)]
	[System.MonoTODO("Metafiles, both WMF and EMF formats, aren't supported.")]
	public sealed class MetafileHeader
	{
		private MonoMetafileHeader header;

		/// <summary>Gets a <see cref="T:System.Drawing.Rectangle" /> that bounds the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Rectangle" /> that bounds the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public Rectangle Bounds => new Rectangle(header.x, header.y, header.width, header.height);

		/// <summary>Gets the horizontal resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>The horizontal resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public float DpiX => header.dpi_x;

		/// <summary>Gets the vertical resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>The vertical resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public float DpiY => header.dpi_y;

		/// <summary>Gets the size, in bytes, of the enhanced metafile plus header file.</summary>
		/// <returns>The size, in bytes, of the enhanced metafile plus header file.</returns>
		public int EmfPlusHeaderSize => header.emfplus_header_size;

		/// <summary>Gets the logical horizontal resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>The logical horizontal resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public int LogicalDpiX => header.logical_dpi_x;

		/// <summary>Gets the logical vertical resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>The logical vertical resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public int LogicalDpiY => header.logical_dpi_y;

		/// <summary>Gets the size, in bytes, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>The size, in bytes, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public int MetafileSize => header.size;

		/// <summary>Gets the type of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Imaging.MetafileType" /> enumeration that represents the type of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public MetafileType Type => header.type;

		/// <summary>Gets the version number of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>The version number of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public int Version => header.version;

		/// <summary>Gets the Windows metafile (WMF) header file for the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Imaging.MetaHeader" /> that contains the WMF header file for the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public MetaHeader WmfHeader
		{
			get
			{
				if (IsWmf())
				{
					return new MetaHeader(header.wmf_header);
				}
				throw new ArgumentException("WmfHeader only available on WMF files.");
			}
		}

		internal MetafileHeader(IntPtr henhmetafile)
		{
			Marshal.PtrToStructure(henhmetafile, this);
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is device dependent.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is device dependent; otherwise, <see langword="false" />.</returns>
		[System.MonoTODO("always returns false")]
		public bool IsDisplay()
		{
			return false;
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows enhanced metafile format.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows enhanced metafile format; otherwise, <see langword="false" />.</returns>
		public bool IsEmf()
		{
			return Type == MetafileType.Emf;
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows enhanced metafile format or the Windows enhanced metafile plus format.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows enhanced metafile format or the Windows enhanced metafile plus format; otherwise, <see langword="false" />.</returns>
		public bool IsEmfOrEmfPlus()
		{
			return Type >= MetafileType.Emf;
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows enhanced metafile plus format.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows enhanced metafile plus format; otherwise, <see langword="false" />.</returns>
		public bool IsEmfPlus()
		{
			return Type >= MetafileType.EmfPlusOnly;
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Dual enhanced metafile format. This format supports both the enhanced and the enhanced plus format.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Dual enhanced metafile format; otherwise, <see langword="false" />.</returns>
		public bool IsEmfPlusDual()
		{
			return Type == MetafileType.EmfPlusDual;
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> supports only the Windows enhanced metafile plus format.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> supports only the Windows enhanced metafile plus format; otherwise, <see langword="false" />.</returns>
		public bool IsEmfPlusOnly()
		{
			return Type == MetafileType.EmfPlusOnly;
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows metafile format.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows metafile format; otherwise, <see langword="false" />.</returns>
		public bool IsWmf()
		{
			return Type <= MetafileType.WmfPlaceable;
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows placeable metafile format.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows placeable metafile format; otherwise, <see langword="false" />.</returns>
		public bool IsWmfPlaceable()
		{
			return Type == MetafileType.WmfPlaceable;
		}

		internal MetafileHeader()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
}
namespace System.Drawing.Design
{
	/// <summary>Represents a collection of category name strings.</summary>
	public sealed class CategoryNameCollection : ReadOnlyCollectionBase
	{
		/// <summary>Gets the category name at the specified index.</summary>
		/// <param name="index">The index of the collection element to access.</param>
		/// <returns>The category name at the specified index.</returns>
		public string this[int index] => (string)base.InnerList[index];

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.CategoryNameCollection" /> class using the specified collection.</summary>
		/// <param name="value">A <see cref="T:System.Drawing.Design.CategoryNameCollection" /> that contains the names to initialize the collection values to.</param>
		public CategoryNameCollection(CategoryNameCollection value)
		{
			base.InnerList.AddRange(value);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.CategoryNameCollection" /> class using the specified array of names.</summary>
		/// <param name="value">An array of strings that contains the names of the categories to initialize the collection values to.</param>
		public CategoryNameCollection(string[] value)
		{
			base.InnerList.AddRange(value);
		}

		/// <summary>Indicates whether the specified category is contained in the collection.</summary>
		/// <param name="value">The string to check for in the collection.</param>
		/// <returns>
		///   <see langword="true" /> if the specified category is contained in the collection; otherwise, <see langword="false" />.</returns>
		public bool Contains(string value)
		{
			return base.InnerList.Contains(value);
		}

		/// <summary>Copies the collection elements to the specified array at the specified index.</summary>
		/// <param name="array">The array to copy to.</param>
		/// <param name="index">The index of the destination array at which to begin copying.</param>
		public void CopyTo(string[] array, int index)
		{
			base.InnerList.CopyTo(array, index);
		}

		/// <summary>Gets the index of the specified value.</summary>
		/// <param name="value">The category name to retrieve the index of in the collection.</param>
		/// <returns>The index in the collection, or <see langword="null" /> if the string does not exist in the collection.</returns>
		public int IndexOf(string value)
		{
			return base.InnerList.IndexOf(value);
		}
	}
	/// <summary>Provides an interface to manage the images, ToolTips, and event handlers for the properties of a component displayed in a property browser.</summary>
	public interface IPropertyValueUIService
	{
		/// <summary>Occurs when the list of <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> objects is modified.</summary>
		event EventHandler PropertyUIValueItemsChanged;

		/// <summary>Adds the specified <see cref="T:System.Drawing.Design.PropertyValueUIHandler" /> to this service.</summary>
		/// <param name="newHandler">The property value UI handler to add.</param>
		void AddPropertyValueUIHandler(PropertyValueUIHandler newHandler);

		/// <summary>Gets the <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> objects that match the specified context and property descriptor characteristics.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to gain additional context information.</param>
		/// <param name="propDesc">A <see cref="T:System.ComponentModel.PropertyDescriptor" /> that indicates the property to match with the properties to return.</param>
		/// <returns>An array of <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> objects that match the specified parameters.</returns>
		PropertyValueUIItem[] GetPropertyUIValueItems(ITypeDescriptorContext context, PropertyDescriptor propDesc);

		/// <summary>Notifies the <see cref="T:System.Drawing.Design.IPropertyValueUIService" /> implementation that the global list of <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> objects has been modified.</summary>
		void NotifyPropertyValueUIItemsChanged();

		/// <summary>Removes the specified <see cref="T:System.Drawing.Design.PropertyValueUIHandler" /> from the property value UI service.</summary>
		/// <param name="newHandler">The handler to remove.</param>
		void RemovePropertyValueUIHandler(PropertyValueUIHandler newHandler);
	}
	/// <summary>Exposes a collection of toolbox items.</summary>
	public interface IToolboxItemProvider
	{
		/// <summary>Gets a collection of <see cref="T:System.Drawing.Design.ToolboxItem" /> objects.</summary>
		/// <returns>A collection of <see cref="T:System.Drawing.Design.ToolboxItem" /> objects.</returns>
		ToolboxItemCollection Items { get; }
	}
	/// <summary>Provides methods and properties to manage and query the toolbox in the development environment.</summary>
	[ComImport]
	[Guid("4BACD258-DE64-4048-BC4E-FEDBEF9ACB76")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface IToolboxService
	{
		/// <summary>Gets the names of all the tool categories currently on the toolbox.</summary>
		/// <returns>A <see cref="T:System.Drawing.Design.CategoryNameCollection" /> containing the tool categories.</returns>
		CategoryNameCollection CategoryNames { get; }

		/// <summary>Gets or sets the name of the currently selected tool category from the toolbox.</summary>
		/// <returns>The name of the currently selected category.</returns>
		string SelectedCategory { get; set; }

		/// <summary>Adds a new toolbox item creator for a specified data format.</summary>
		/// <param name="creator">A <see cref="T:System.Drawing.Design.ToolboxItemCreatorCallback" /> that can create a component when the toolbox item is invoked.</param>
		/// <param name="format">The data format that the creator handles.</param>
		void AddCreator(ToolboxItemCreatorCallback creator, string format);

		/// <summary>Adds a new toolbox item creator for a specified data format and designer host.</summary>
		/// <param name="creator">A <see cref="T:System.Drawing.Design.ToolboxItemCreatorCallback" /> that can create a component when the toolbox item is invoked.</param>
		/// <param name="format">The data format that the creator handles.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that represents the designer host to associate with the creator.</param>
		void AddCreator(ToolboxItemCreatorCallback creator, string format, IDesignerHost host);

		/// <summary>Adds the specified project-linked toolbox item to the toolbox.</summary>
		/// <param name="toolboxItem">The linked <see cref="T:System.Drawing.Design.ToolboxItem" /> to add to the toolbox.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> for the current design document.</param>
		void AddLinkedToolboxItem(ToolboxItem toolboxItem, IDesignerHost host);

		/// <summary>Adds the specified project-linked toolbox item to the toolbox in the specified category.</summary>
		/// <param name="toolboxItem">The linked <see cref="T:System.Drawing.Design.ToolboxItem" /> to add to the toolbox.</param>
		/// <param name="category">The toolbox item category to add the toolbox item to.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> for the current design document.</param>
		void AddLinkedToolboxItem(ToolboxItem toolboxItem, string category, IDesignerHost host);

		/// <summary>Adds the specified toolbox item to the toolbox.</summary>
		/// <param name="toolboxItem">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to add to the toolbox.</param>
		void AddToolboxItem(ToolboxItem toolboxItem);

		/// <summary>Adds the specified toolbox item to the toolbox in the specified category.</summary>
		/// <param name="toolboxItem">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to add to the toolbox.</param>
		/// <param name="category">The toolbox item category to add the <see cref="T:System.Drawing.Design.ToolboxItem" /> to.</param>
		void AddToolboxItem(ToolboxItem toolboxItem, string category);

		/// <summary>Gets a toolbox item from the specified object that represents a toolbox item in serialized form.</summary>
		/// <param name="serializedObject">The object that contains the <see cref="T:System.Drawing.Design.ToolboxItem" /> to retrieve.</param>
		/// <returns>The <see cref="T:System.Drawing.Design.ToolboxItem" /> created from the serialized object.</returns>
		ToolboxItem DeserializeToolboxItem(object serializedObject);

		/// <summary>Gets a toolbox item from the specified object that represents a toolbox item in serialized form, using the specified designer host.</summary>
		/// <param name="serializedObject">The object that contains the <see cref="T:System.Drawing.Design.ToolboxItem" /> to retrieve.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> to associate with this <see cref="T:System.Drawing.Design.ToolboxItem" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Design.ToolboxItem" /> created from deserialization.</returns>
		ToolboxItem DeserializeToolboxItem(object serializedObject, IDesignerHost host);

		/// <summary>Gets the currently selected toolbox item.</summary>
		/// <returns>The <see cref="T:System.Drawing.Design.ToolboxItem" /> that is currently selected, or <see langword="null" /> if no toolbox item has been selected.</returns>
		ToolboxItem GetSelectedToolboxItem();

		/// <summary>Gets the currently selected toolbox item if it is available to all designers, or if it supports the specified designer.</summary>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that the selected tool must be associated with for it to be returned.</param>
		/// <returns>The <see cref="T:System.Drawing.Design.ToolboxItem" /> that is currently selected, or <see langword="null" /> if no toolbox item is currently selected.</returns>
		ToolboxItem GetSelectedToolboxItem(IDesignerHost host);

		/// <summary>Gets the entire collection of toolbox items from the toolbox.</summary>
		/// <returns>A <see cref="T:System.Drawing.Design.ToolboxItemCollection" /> that contains the current toolbox items.</returns>
		ToolboxItemCollection GetToolboxItems();

		/// <summary>Gets the collection of toolbox items that are associated with the specified designer host from the toolbox.</summary>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that is associated with the toolbox items to retrieve.</param>
		/// <returns>A <see cref="T:System.Drawing.Design.ToolboxItemCollection" /> that contains the current toolbox items that are associated with the specified designer host.</returns>
		ToolboxItemCollection GetToolboxItems(IDesignerHost host);

		/// <summary>Gets a collection of toolbox items from the toolbox that match the specified category.</summary>
		/// <param name="category">The toolbox item category to retrieve all the toolbox items from.</param>
		/// <returns>A <see cref="T:System.Drawing.Design.ToolboxItemCollection" /> that contains the current toolbox items that are associated with the specified category.</returns>
		ToolboxItemCollection GetToolboxItems(string category);

		/// <summary>Gets the collection of toolbox items that are associated with the specified designer host and category from the toolbox.</summary>
		/// <param name="category">The toolbox item category to retrieve the toolbox items from.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that is associated with the toolbox items to retrieve.</param>
		/// <returns>A <see cref="T:System.Drawing.Design.ToolboxItemCollection" /> that contains the current toolbox items that are associated with the specified category and designer host.</returns>
		ToolboxItemCollection GetToolboxItems(string category, IDesignerHost host);

		/// <summary>Gets a value indicating whether the specified object which represents a serialized toolbox item can be used by the specified designer host.</summary>
		/// <param name="serializedObject">The object that contains the <see cref="T:System.Drawing.Design.ToolboxItem" /> to retrieve.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> to test for support for the <see cref="T:System.Drawing.Design.ToolboxItem" />.</param>
		/// <returns>
		///   <see langword="true" /> if the specified object is compatible with the specified designer host; otherwise, <see langword="false" />.</returns>
		bool IsSupported(object serializedObject, IDesignerHost host);

		/// <summary>Gets a value indicating whether the specified object which represents a serialized toolbox item matches the specified attributes.</summary>
		/// <param name="serializedObject">The object that contains the <see cref="T:System.Drawing.Design.ToolboxItem" /> to retrieve.</param>
		/// <param name="filterAttributes">An <see cref="T:System.Collections.ICollection" /> that contains the attributes to test the serialized object for.</param>
		/// <returns>
		///   <see langword="true" /> if the object matches the specified attributes; otherwise, <see langword="false" />.</returns>
		bool IsSupported(object serializedObject, ICollection filterAttributes);

		/// <summary>Gets a value indicating whether the specified object is a serialized toolbox item.</summary>
		/// <param name="serializedObject">The object to inspect.</param>
		/// <returns>
		///   <see langword="true" /> if the object contains a toolbox item object; otherwise, <see langword="false" />.</returns>
		bool IsToolboxItem(object serializedObject);

		/// <summary>Gets a value indicating whether the specified object is a serialized toolbox item, using the specified designer host.</summary>
		/// <param name="serializedObject">The object to inspect.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that is making this request.</param>
		/// <returns>
		///   <see langword="true" /> if the object contains a toolbox item object; otherwise, <see langword="false" />.</returns>
		bool IsToolboxItem(object serializedObject, IDesignerHost host);

		/// <summary>Refreshes the state of the toolbox items.</summary>
		void Refresh();

		/// <summary>Removes a previously added toolbox item creator of the specified data format.</summary>
		/// <param name="format">The data format of the creator to remove.</param>
		void RemoveCreator(string format);

		/// <summary>Removes a previously added toolbox creator that is associated with the specified data format and the specified designer host.</summary>
		/// <param name="format">The data format of the creator to remove.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that is associated with the creator to remove.</param>
		void RemoveCreator(string format, IDesignerHost host);

		/// <summary>Removes the specified toolbox item from the toolbox.</summary>
		/// <param name="toolboxItem">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to remove from the toolbox.</param>
		void RemoveToolboxItem(ToolboxItem toolboxItem);

		/// <summary>Removes the specified toolbox item from the toolbox.</summary>
		/// <param name="toolboxItem">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to remove from the toolbox.</param>
		/// <param name="category">The toolbox item category to remove the <see cref="T:System.Drawing.Design.ToolboxItem" /> from.</param>
		void RemoveToolboxItem(ToolboxItem toolboxItem, string category);

		/// <summary>Notifies the toolbox service that the selected tool has been used.</summary>
		void SelectedToolboxItemUsed();

		/// <summary>Gets a serializable object that represents the specified toolbox item.</summary>
		/// <param name="toolboxItem">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to serialize.</param>
		/// <returns>An object that represents the specified <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		object SerializeToolboxItem(ToolboxItem toolboxItem);

		/// <summary>Sets the current application's cursor to a cursor that represents the currently selected tool.</summary>
		/// <returns>
		///   <see langword="true" /> if the cursor is set by the currently selected tool, <see langword="false" /> if there is no tool selected and the cursor is set to the standard windows cursor.</returns>
		bool SetCursor();

		/// <summary>Selects the specified toolbox item.</summary>
		/// <param name="toolboxItem">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to select.</param>
		void SetSelectedToolboxItem(ToolboxItem toolboxItem);
	}
	/// <summary>Defines an interface for setting the currently selected toolbox item and indicating whether a designer supports a particular toolbox item.</summary>
	public interface IToolboxUser
	{
		/// <summary>Gets a value indicating whether the specified tool is supported by the current designer.</summary>
		/// <param name="tool">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to be tested for toolbox support.</param>
		/// <returns>
		///   <see langword="true" /> if the tool is supported by the toolbox and can be enabled; <see langword="false" /> if the document designer does not know how to use the tool.</returns>
		bool GetToolSupported(ToolboxItem tool);

		/// <summary>Selects the specified tool.</summary>
		/// <param name="tool">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to select.</param>
		void ToolPicked(ToolboxItem tool);
	}
	/// <summary>Provides data for the <see cref="M:System.Drawing.Design.UITypeEditor.PaintValue(System.Object,System.Drawing.Graphics,System.Drawing.Rectangle)" /> method.</summary>
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class PaintValueEventArgs : EventArgs
	{
		private readonly ITypeDescriptorContext context;

		private readonly object valueToPaint;

		private readonly Graphics graphics;

		private readonly Rectangle bounds;

		/// <summary>Gets the rectangle that indicates the area in which the painting should be done.</summary>
		/// <returns>The rectangle that indicates the area in which the painting should be done.</returns>
		public Rectangle Bounds => bounds;

		/// <summary>Gets the <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> interface to be used to gain additional information about the context this value appears in.</summary>
		/// <returns>An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that indicates the context of the event.</returns>
		public ITypeDescriptorContext Context => context;

		/// <summary>Gets the <see cref="T:System.Drawing.Graphics" /> object with which painting should be done.</summary>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> object to use for painting.</returns>
		public Graphics Graphics => graphics;

		/// <summary>Gets the value to paint.</summary>
		/// <returns>An object indicating what to paint.</returns>
		public object Value => valueToPaint;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.PaintValueEventArgs" /> class using the specified values.</summary>
		/// <param name="context">The context in which the value appears.</param>
		/// <param name="value">The value to paint.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> object with which drawing is to be done.</param>
		/// <param name="bounds">The <see cref="T:System.Drawing.Rectangle" /> in which drawing is to be done.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="graphics" /> is <see langword="null" />.</exception>
		public PaintValueEventArgs(ITypeDescriptorContext context, object value, Graphics graphics, Rectangle bounds)
		{
			this.context = context;
			valueToPaint = value;
			this.graphics = graphics;
			if (graphics == null)
			{
				throw new ArgumentNullException("graphics");
			}
			this.bounds = bounds;
		}
	}
	/// <summary>Represents the method that adds a delegate to an implementation of <see cref="T:System.Drawing.Design.IPropertyValueUIService" />.</summary>
	/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to obtain context information.</param>
	/// <param name="propDesc">A <see cref="T:System.ComponentModel.PropertyDescriptor" /> that represents the property being queried.</param>
	/// <param name="valueUIItemList">An <see cref="T:System.Collections.ArrayList" /> of <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> objects containing the UI items associated with the property.</param>
	public delegate void PropertyValueUIHandler(ITypeDescriptorContext context, PropertyDescriptor propDesc, ArrayList valueUIItemList);
	/// <summary>Provides information about a property displayed in the Properties window, including the associated event handler, pop-up information string, and the icon to display for the property.</summary>
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public class PropertyValueUIItem
	{
		private Image itemImage;

		private PropertyValueUIItemInvokeHandler handler;

		private string tooltip;

		/// <summary>Gets the 8 x 8 pixel image that will be drawn in the Properties window.</summary>
		/// <returns>The image to use for the property icon.</returns>
		public virtual Image Image => itemImage;

		/// <summary>Gets the handler that is raised when a user double-clicks this item.</summary>
		/// <returns>A <see cref="T:System.Drawing.Design.PropertyValueUIItemInvokeHandler" /> indicating the event handler for this user interface (UI) item.</returns>
		public virtual PropertyValueUIItemInvokeHandler InvokeHandler => handler;

		/// <summary>Gets or sets the information string to display for this item.</summary>
		/// <returns>A string containing the information string to display for this item.</returns>
		public virtual string ToolTip => tooltip;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> class.</summary>
		/// <param name="uiItemImage">The icon to display. The image must be 8 x 8 pixels.</param>
		/// <param name="handler">The handler to invoke when the image is double-clicked.</param>
		/// <param name="tooltip">The <see cref="P:System.Drawing.Design.PropertyValueUIItem.ToolTip" /> to display for the property that this <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> is associated with.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="uiItemImage" /> or <paramref name="handler" /> is <see langword="null" />.</exception>
		public PropertyValueUIItem(Image uiItemImage, PropertyValueUIItemInvokeHandler handler, string tooltip)
		{
			itemImage = uiItemImage;
			this.handler = handler;
			if (itemImage == null)
			{
				throw new ArgumentNullException("uiItemImage");
			}
			if (handler == null)
			{
				throw new ArgumentNullException("handler");
			}
			this.tooltip = tooltip;
		}

		/// <summary>Resets the user interface (UI) item.</summary>
		public virtual void Reset()
		{
		}
	}
	/// <summary>Represents the method that will handle the <see cref="P:System.Drawing.Design.PropertyValueUIItem.InvokeHandler" /> event of a <see cref="T:System.Drawing.Design.PropertyValueUIItem" />.</summary>
	/// <param name="context">The <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> for the property associated with the icon that was double-clicked.</param>
	/// <param name="descriptor">The property associated with the icon that was double-clicked.</param>
	/// <param name="invokedItem">The <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> associated with the icon that was double-clicked.</param>
	public delegate void PropertyValueUIItemInvokeHandler(ITypeDescriptorContext context, PropertyDescriptor descriptor, PropertyValueUIItem invokedItem);
	/// <summary>Provides data for the <see cref="E:System.Drawing.Design.ToolboxItem.ComponentsCreated" /> event that occurs when components are added to the toolbox.</summary>
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class ToolboxComponentsCreatedEventArgs : EventArgs
	{
		private readonly IComponent[] comps;

		/// <summary>Gets or sets an array containing the components to add to the toolbox.</summary>
		/// <returns>An array of type <see cref="T:System.ComponentModel.IComponent" /> indicating the components to add to the toolbox.</returns>
		public IComponent[] Components => (IComponent[])comps.Clone();

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.ToolboxComponentsCreatedEventArgs" /> class.</summary>
		/// <param name="components">The components to include in the toolbox.</param>
		public ToolboxComponentsCreatedEventArgs(IComponent[] components)
		{
			comps = components;
		}
	}
	/// <summary>Represents the method that handles the <see cref="E:System.Drawing.Design.ToolboxItem.ComponentsCreated" /> event.</summary>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">A <see cref="T:System.Drawing.Design.ToolboxComponentsCreatedEventArgs" /> that provides data for the event.</param>
	public delegate void ToolboxComponentsCreatedEventHandler(object sender, ToolboxComponentsCreatedEventArgs e);
	/// <summary>Provides data for the <see cref="E:System.Drawing.Design.ToolboxItem.ComponentsCreating" /> event that occurs when components are added to the toolbox.</summary>
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class ToolboxComponentsCreatingEventArgs : EventArgs
	{
		private readonly IDesignerHost host;

		/// <summary>Gets or sets an instance of the <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that made the request to create toolbox components.</summary>
		/// <returns>The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that made the request to create toolbox components, or <see langword="null" /> if no designer host was provided to the toolbox item.</returns>
		public IDesignerHost DesignerHost => host;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.ToolboxComponentsCreatingEventArgs" /> class.</summary>
		/// <param name="host">The designer host that is making the request.</param>
		public ToolboxComponentsCreatingEventArgs(IDesignerHost host)
		{
			this.host = host;
		}
	}
	/// <summary>Represents the method that handles the <see cref="E:System.Drawing.Design.ToolboxItem.ComponentsCreating" /> event.</summary>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">A <see cref="T:System.Drawing.Design.ToolboxComponentsCreatingEventArgs" /> that provides data for the event.</param>
	public delegate void ToolboxComponentsCreatingEventHandler(object sender, ToolboxComponentsCreatingEventArgs e);
	/// <summary>Represents a collection of toolbox items.</summary>
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public sealed class ToolboxItemCollection : ReadOnlyCollectionBase
	{
		/// <summary>Gets the <see cref="T:System.Drawing.Design.ToolboxItem" /> at the specified index.</summary>
		/// <param name="index">The index of the object to get or set.</param>
		/// <returns>A <see cref="T:System.Drawing.Design.ToolboxItem" /> at each valid index in the collection.</returns>
		public ToolboxItem this[int index] => (ToolboxItem)base.InnerList[index];

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.ToolboxItemCollection" /> class using the specified collection.</summary>
		/// <param name="value">A <see cref="T:System.Drawing.Design.ToolboxItemCollection" /> to fill the new collection with.</param>
		public ToolboxItemCollection(ToolboxItemCollection value)
		{
			base.InnerList.AddRange(value);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.ToolboxItemCollection" /> class using the specified array of toolbox items.</summary>
		/// <param name="value">An array of type <see cref="T:System.Drawing.Design.ToolboxItem" /> containing the toolbox items to fill the collection with.</param>
		public ToolboxItemCollection(ToolboxItem[] value)
		{
			base.InnerList.AddRange(value);
		}

		/// <summary>Indicates whether the collection contains the specified <see cref="T:System.Drawing.Design.ToolboxItem" />.</summary>
		/// <param name="value">A <see cref="T:System.Drawing.Design.ToolboxItem" /> to search the collection for.</param>
		/// <returns>
		///   <see langword="true" /> if the collection contains the specified object; otherwise, <see langword="false" />.</returns>
		public bool Contains(ToolboxItem value)
		{
			return base.InnerList.Contains(value);
		}

		/// <summary>Copies the collection to the specified array beginning with the specified destination index.</summary>
		/// <param name="array">The array to copy to.</param>
		/// <param name="index">The index to begin copying to.</param>
		public void CopyTo(ToolboxItem[] array, int index)
		{
			base.InnerList.CopyTo(array, index);
		}

		/// <summary>Gets the index of the specified <see cref="T:System.Drawing.Design.ToolboxItem" />, if it exists in the collection.</summary>
		/// <param name="value">A <see cref="T:System.Drawing.Design.ToolboxItem" /> to get the index of in the collection.</param>
		/// <returns>The index of the specified <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		public int IndexOf(ToolboxItem value)
		{
			return base.InnerList.IndexOf(value);
		}
	}
	/// <summary>Provides a callback mechanism that can create a <see cref="T:System.Drawing.Design.ToolboxItem" />.</summary>
	/// <param name="serializedObject">The object which contains the data to create a <see cref="T:System.Drawing.Design.ToolboxItem" /> for.</param>
	/// <param name="format">The name of the clipboard data format to create a <see cref="T:System.Drawing.Design.ToolboxItem" /> for.</param>
	/// <returns>The deserialized <see cref="T:System.Drawing.Design.ToolboxItem" /> object specified by <paramref name="serializedObject" />.</returns>
	public delegate ToolboxItem ToolboxItemCreatorCallback(object serializedObject, string format);
	/// <summary>Provides a base class that can be used to design value editors that can provide a user interface (UI) for representing and editing the values of objects of the supported data types.</summary>
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class UITypeEditor
	{
		/// <summary>Gets a value indicating whether drop-down editors should be resizable by the user.</summary>
		/// <returns>
		///   <see langword="true" /> if drop-down editors are resizable; otherwise, <see langword="false" />.</returns>
		public virtual bool IsDropDownResizable => false;

		static UITypeEditor()
		{
			Hashtable table = new Hashtable
			{
				[typeof(DateTime)] = "System.ComponentModel.Design.DateTimeEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(Array)] = "System.ComponentModel.Design.ArrayEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(IList)] = "System.ComponentModel.Design.CollectionEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(ICollection)] = "System.ComponentModel.Design.CollectionEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(byte[])] = "System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(Stream)] = "System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(string[])] = "System.Windows.Forms.Design.StringArrayEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(Collection<string>)] = "System.Windows.Forms.Design.StringCollectionEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"
			};
			TypeDescriptor.AddEditorTable(typeof(UITypeEditor), table);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.UITypeEditor" /> class.</summary>
		public UITypeEditor()
		{
		}

		/// <summary>Edits the value of the specified object using the editor style indicated by the <see cref="M:System.Drawing.Design.UITypeEditor.GetEditStyle" /> method.</summary>
		/// <param name="provider">An <see cref="T:System.IServiceProvider" /> that this editor can use to obtain services.</param>
		/// <param name="value">The object to edit.</param>
		/// <returns>The new value of the object.</returns>
		public object EditValue(IServiceProvider provider, object value)
		{
			return EditValue(null, provider, value);
		}

		/// <summary>Edits the specified object's value using the editor style indicated by the <see cref="M:System.Drawing.Design.UITypeEditor.GetEditStyle" /> method.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to gain additional context information.</param>
		/// <param name="provider">An <see cref="T:System.IServiceProvider" /> that this editor can use to obtain services.</param>
		/// <param name="value">The object to edit.</param>
		/// <returns>The new value of the object. If the value of the object has not changed, this should return the same object it was passed.</returns>
		public virtual object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value)
		{
			return value;
		}

		/// <summary>Gets the editor style used by the <see cref="M:System.Drawing.Design.UITypeEditor.EditValue(System.IServiceProvider,System.Object)" /> method.</summary>
		/// <returns>A <see cref="T:System.Drawing.Design.UITypeEditorEditStyle" /> enumeration value that indicates the style of editor used by the current <see cref="T:System.Drawing.Design.UITypeEditor" />. By default, this method will return <see cref="F:System.Drawing.Design.UITypeEditorEditStyle.None" />.</returns>
		public UITypeEditorEditStyle GetEditStyle()
		{
			return GetEditStyle(null);
		}

		/// <summary>Indicates whether this editor supports painting a representation of an object's value.</summary>
		/// <returns>
		///   <see langword="true" /> if <see cref="M:System.Drawing.Design.UITypeEditor.PaintValue(System.Object,System.Drawing.Graphics,System.Drawing.Rectangle)" /> is implemented; otherwise, <see langword="false" />.</returns>
		public bool GetPaintValueSupported()
		{
			return GetPaintValueSupported(null);
		}

		/// <summary>Indicates whether the specified context supports painting a representation of an object's value within the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to gain additional context information.</param>
		/// <returns>
		///   <see langword="true" /> if <see cref="M:System.Drawing.Design.UITypeEditor.PaintValue(System.Object,System.Drawing.Graphics,System.Drawing.Rectangle)" /> is implemented; otherwise, <see langword="false" />.</returns>
		public virtual bool GetPaintValueSupported(ITypeDescriptorContext context)
		{
			return false;
		}

		/// <summary>Gets the editor style used by the <see cref="M:System.Drawing.Design.UITypeEditor.EditValue(System.IServiceProvider,System.Object)" /> method.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to gain additional context information.</param>
		/// <returns>A <see cref="T:System.Drawing.Design.UITypeEditorEditStyle" /> value that indicates the style of editor used by the <see cref="M:System.Drawing.Design.UITypeEditor.EditValue(System.IServiceProvider,System.Object)" /> method. If the <see cref="T:System.Drawing.Design.UITypeEditor" /> does not support this method, then <see cref="M:System.Drawing.Design.UITypeEditor.GetEditStyle" /> will return <see cref="F:System.Drawing.Design.UITypeEditorEditStyle.None" />.</returns>
		public virtual UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context)
		{
			return UITypeEditorEditStyle.None;
		}

		/// <summary>Paints a representation of the value of the specified object to the specified canvas.</summary>
		/// <param name="value">The object whose value this type editor will display.</param>
		/// <param name="canvas">A drawing canvas on which to paint the representation of the object's value.</param>
		/// <param name="rectangle">A <see cref="T:System.Drawing.Rectangle" /> within whose boundaries to paint the value.</param>
		public void PaintValue(object value, Graphics canvas, Rectangle rectangle)
		{
			PaintValue(new PaintValueEventArgs(null, value, canvas, rectangle));
		}

		/// <summary>Paints a representation of the value of an object using the specified <see cref="T:System.Drawing.Design.PaintValueEventArgs" />.</summary>
		/// <param name="e">A <see cref="T:System.Drawing.Design.PaintValueEventArgs" /> that indicates what to paint and where to paint it.</param>
		public virtual void PaintValue(PaintValueEventArgs e)
		{
		}
	}
	/// <summary>Specifies identifiers that indicate the value editing style of a <see cref="T:System.Drawing.Design.UITypeEditor" />.</summary>
	public enum UITypeEditorEditStyle
	{
		/// <summary>Provides no interactive user interface (UI) component.</summary>
		None = 1,
		/// <summary>Displays an ellipsis (...) button to start a modal dialog box, which requires user input before continuing a program, or a modeless dialog box, which stays on the screen and is available for use at any time but permits other user activities.</summary>
		Modal,
		/// <summary>Displays a drop-down arrow button and hosts the user interface (UI) in a drop-down dialog box.</summary>
		DropDown
	}
	/// <summary>Provides a base implementation of a toolbox item.</summary>
	[Serializable]
	[System.MonoTODO("Implementation is incomplete.")]
	[PermissionSet(SecurityAction.InheritanceDemand, Unrestricted = true)]
	[PermissionSet(SecurityAction.LinkDemand, Unrestricted = true)]
	public class ToolboxItem : ISerializable
	{
		private bool locked;

		private Hashtable properties = new Hashtable();

		/// <summary>Gets or sets the name of the assembly that contains the type or types that the toolbox item creates.</summary>
		/// <returns>An <see cref="T:System.Reflection.AssemblyName" /> that indicates the assembly containing the type or types to create.</returns>
		public AssemblyName AssemblyName
		{
			get
			{
				return (AssemblyName)properties["AssemblyName"];
			}
			set
			{
				SetValue("AssemblyName", value);
			}
		}

		/// <summary>Gets or sets a bitmap to represent the toolbox item in the toolbox.</summary>
		/// <returns>A <see cref="T:System.Drawing.Bitmap" /> that represents the toolbox item in the toolbox.</returns>
		public Bitmap Bitmap
		{
			get
			{
				return (Bitmap)properties["Bitmap"];
			}
			set
			{
				SetValue("Bitmap", value);
			}
		}

		/// <summary>Gets or sets the display name for the toolbox item.</summary>
		/// <returns>The display name for the toolbox item.</returns>
		public string DisplayName
		{
			get
			{
				return GetValue("DisplayName");
			}
			set
			{
				SetValue("DisplayName", value);
			}
		}

		/// <summary>Gets or sets the filter that determines whether the toolbox item can be used on a destination component.</summary>
		/// <returns>An <see cref="T:System.Collections.ICollection" /> of <see cref="T:System.ComponentModel.ToolboxItemFilterAttribute" /> objects.</returns>
		public ICollection Filter
		{
			get
			{
				ICollection collection = (ICollection)properties["Filter"];
				if (collection == null)
				{
					collection = new ToolboxItemFilterAttribute[0];
				}
				return collection;
			}
			set
			{
				SetValue("Filter", value);
			}
		}

		/// <summary>Gets a value indicating whether the <see cref="T:System.Drawing.Design.ToolboxItem" /> is currently locked.</summary>
		/// <returns>
		///   <see langword="true" /> if the toolbox item is locked; otherwise, <see langword="false" />.</returns>
		public virtual bool Locked => locked;

		/// <summary>Gets or sets the fully qualified name of the type of <see cref="T:System.ComponentModel.IComponent" /> that the toolbox item creates when invoked.</summary>
		/// <returns>The fully qualified type name of the type of component that this toolbox item creates.</returns>
		public string TypeName
		{
			get
			{
				return GetValue("TypeName");
			}
			set
			{
				SetValue("TypeName", value);
			}
		}

		/// <summary>Gets or sets the company name for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</summary>
		/// <returns>A <see cref="T:System.String" /> that specifies the company for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		public string Company
		{
			get
			{
				return (string)properties["Company"];
			}
			set
			{
				SetValue("Company", value);
			}
		}

		/// <summary>Gets the component type for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</summary>
		/// <returns>A <see cref="T:System.String" /> that specifies the component type for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		public virtual string ComponentType => ".NET Component";

		/// <summary>Gets or sets the <see cref="T:System.Reflection.AssemblyName" /> for the toolbox item.</summary>
		/// <returns>An array of <see cref="T:System.Reflection.AssemblyName" /> objects.</returns>
		public AssemblyName[] DependentAssemblies
		{
			get
			{
				return (AssemblyName[])properties["DependentAssemblies"];
			}
			set
			{
				AssemblyName[] array = new AssemblyName[value.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = value[i];
				}
				SetValue("DependentAssemblies", array);
			}
		}

		/// <summary>Gets or sets the description for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</summary>
		/// <returns>A <see cref="T:System.String" /> that specifies the description for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		public string Description
		{
			get
			{
				return (string)properties["Description"];
			}
			set
			{
				SetValue("Description", value);
			}
		}

		/// <summary>Gets a value indicating whether the toolbox item is transient.</summary>
		/// <returns>
		///   <see langword="true" />, if this toolbox item should not be stored in any toolbox database when an application that is providing a toolbox closes; otherwise, <see langword="false" />.</returns>
		public bool IsTransient
		{
			get
			{
				object obj = properties["IsTransient"];
				if (obj != null)
				{
					return (bool)obj;
				}
				return false;
			}
			set
			{
				SetValue("IsTransient", value);
			}
		}

		/// <summary>Gets a dictionary of properties.</summary>
		/// <returns>A dictionary of name/value pairs (the names are property names and the values are property values).</returns>
		public IDictionary Properties => properties;

		/// <summary>Gets the version for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</summary>
		/// <returns>A <see cref="T:System.String" /> that specifies the version for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		public virtual string Version => string.Empty;

		/// <summary>Gets or sets the original bitmap that will be used in the toolbox for this item.</summary>
		/// <returns>A <see cref="T:System.Drawing.Bitmap" /> that represents the toolbox item in the toolbox.</returns>
		public Bitmap OriginalBitmap
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Occurs immediately after components are created.</summary>
		public event ToolboxComponentsCreatedEventHandler ComponentsCreated;

		/// <summary>Occurs when components are about to be created.</summary>
		public event ToolboxComponentsCreatingEventHandler ComponentsCreating;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.ToolboxItem" /> class.</summary>
		public ToolboxItem()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.ToolboxItem" /> class that creates the specified type of component.</summary>
		/// <param name="toolType">The type of <see cref="T:System.ComponentModel.IComponent" /> that the toolbox item creates.</param>
		/// <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Drawing.Design.ToolboxItem" /> was locked.</exception>
		public ToolboxItem(Type toolType)
		{
			Initialize(toolType);
		}

		/// <summary>Throws an exception if the toolbox item is currently locked.</summary>
		/// <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Drawing.Design.ToolboxItem" /> is locked.</exception>
		protected void CheckUnlocked()
		{
			if (locked)
			{
				throw new InvalidOperationException("The ToolboxItem is locked");
			}
		}

		/// <summary>Creates the components that the toolbox item is configured to create.</summary>
		/// <returns>An array of created <see cref="T:System.ComponentModel.IComponent" /> objects.</returns>
		public IComponent[] CreateComponents()
		{
			return CreateComponents(null);
		}

		/// <summary>Creates the components that the toolbox item is configured to create, using the specified designer host.</summary>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> to use when creating the components.</param>
		/// <returns>An array of created <see cref="T:System.ComponentModel.IComponent" /> objects.</returns>
		public IComponent[] CreateComponents(IDesignerHost host)
		{
			OnComponentsCreating(new ToolboxComponentsCreatingEventArgs(host));
			IComponent[] array = CreateComponentsCore(host);
			OnComponentsCreated(new ToolboxComponentsCreatedEventArgs(array));
			return array;
		}

		/// <summary>Creates a component or an array of components when the toolbox item is invoked.</summary>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> to host the toolbox item.</param>
		/// <returns>An array of created <see cref="T:System.ComponentModel.IComponent" /> objects.</returns>
		protected virtual IComponent[] CreateComponentsCore(IDesignerHost host)
		{
			if (host == null)
			{
				throw new ArgumentNullException("host");
			}
			Type type = GetType(host, AssemblyName, TypeName, reference: true);
			if (type == null)
			{
				return new IComponent[0];
			}
			return new IComponent[1] { host.CreateComponent(type) };
		}

		/// <summary>Creates an array of components when the toolbox item is invoked.</summary>
		/// <param name="host">The designer host to use when creating components.</param>
		/// <param name="defaultValues">A dictionary of property name/value pairs of default values with which to initialize the component.</param>
		/// <returns>An array of created <see cref="T:System.ComponentModel.IComponent" /> objects.</returns>
		protected virtual IComponent[] CreateComponentsCore(IDesignerHost host, IDictionary defaultValues)
		{
			IComponent[] array = CreateComponentsCore(host);
			IComponent[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				Component component = (Component)array2[i];
				(host.GetDesigner(component) as IComponentInitializer).InitializeNewComponent(defaultValues);
			}
			return array;
		}

		/// <summary>Creates the components that the toolbox item is configured to create, using the specified designer host and default values.</summary>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> to use when creating the components.</param>
		/// <param name="defaultValues">A dictionary of property name/value pairs of default values with which to initialize the component.</param>
		/// <returns>An array of created <see cref="T:System.ComponentModel.IComponent" /> objects.</returns>
		public IComponent[] CreateComponents(IDesignerHost host, IDictionary defaultValues)
		{
			OnComponentsCreating(new ToolboxComponentsCreatingEventArgs(host));
			IComponent[] array = CreateComponentsCore(host, defaultValues);
			OnComponentsCreated(new ToolboxComponentsCreatedEventArgs(array));
			return array;
		}

		/// <summary>Filters a property value before returning it.</summary>
		/// <param name="propertyName">The name of the property to filter.</param>
		/// <param name="value">The value against which to filter the property.</param>
		/// <returns>A filtered property value.</returns>
		protected virtual object FilterPropertyValue(string propertyName, object value)
		{
			switch (propertyName)
			{
			case "AssemblyName":
				if (value != null)
				{
					return (value as ICloneable).Clone();
				}
				return null;
			case "DisplayName":
			case "TypeName":
				if (value != null)
				{
					return value;
				}
				return string.Empty;
			case "Filter":
				if (value != null)
				{
					return value;
				}
				return new ToolboxItemFilterAttribute[0];
			default:
				return value;
			}
		}

		/// <summary>Loads the state of the toolbox item from the specified serialization information object.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to load from.</param>
		/// <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that indicates the stream characteristics.</param>
		protected virtual void Deserialize(SerializationInfo info, StreamingContext context)
		{
			AssemblyName = (AssemblyName)info.GetValue("AssemblyName", typeof(AssemblyName));
			Bitmap = (Bitmap)info.GetValue("Bitmap", typeof(Bitmap));
			Filter = (ICollection)info.GetValue("Filter", typeof(ICollection));
			DisplayName = info.GetString("DisplayName");
			locked = info.GetBoolean("Locked");
			TypeName = info.GetString("TypeName");
		}

		/// <summary>Determines whether two <see cref="T:System.Drawing.Design.ToolboxItem" /> instances are equal.</summary>
		/// <param name="obj">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to compare with the current <see cref="T:System.Drawing.Design.ToolboxItem" />.</param>
		/// <returns>
		///   <see langword="true" /> if the specified <see cref="T:System.Drawing.Design.ToolboxItem" /> is equal to the current <see cref="T:System.Drawing.Design.ToolboxItem" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is ToolboxItem toolboxItem))
			{
				return false;
			}
			if (obj == this)
			{
				return true;
			}
			if (toolboxItem.AssemblyName.Equals(AssemblyName) && toolboxItem.Locked.Equals(locked) && toolboxItem.TypeName.Equals(TypeName) && toolboxItem.DisplayName.Equals(DisplayName))
			{
				return toolboxItem.Bitmap.Equals(Bitmap);
			}
			return false;
		}

		/// <summary>Returns the hash code for this instance.</summary>
		/// <returns>A hash code for the current <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		public override int GetHashCode()
		{
			return (TypeName + DisplayName).GetHashCode();
		}

		/// <summary>Enables access to the type associated with the toolbox item.</summary>
		/// <param name="host">The designer host to query for <see cref="T:System.ComponentModel.Design.ITypeResolutionService" />.</param>
		/// <returns>The type associated with the toolbox item.</returns>
		public Type GetType(IDesignerHost host)
		{
			return GetType(host, AssemblyName, TypeName, reference: false);
		}

		/// <summary>Creates an instance of the specified type, optionally using a specified designer host and assembly name.</summary>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> for the current document. This can be <see langword="null" />.</param>
		/// <param name="assemblyName">An <see cref="T:System.Reflection.AssemblyName" /> that indicates the assembly that contains the type to load. This can be <see langword="null" />.</param>
		/// <param name="typeName">The name of the type to create an instance of.</param>
		/// <param name="reference">A value indicating whether or not to add a reference to the assembly that contains the specified type to the designer host's set of references.</param>
		/// <returns>An instance of the specified type, if it can be located.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="typeName" /> is not specified.</exception>
		protected virtual Type GetType(IDesignerHost host, AssemblyName assemblyName, string typeName, bool reference)
		{
			if (typeName == null)
			{
				throw new ArgumentNullException("typeName");
			}
			if (host == null)
			{
				return null;
			}
			ITypeResolutionService typeResolutionService = host.GetService(typeof(ITypeResolutionService)) as ITypeResolutionService;
			Type result = null;
			if (typeResolutionService != null)
			{
				typeResolutionService.GetAssembly(assemblyName, throwOnError: true);
				if (reference)
				{
					typeResolutionService.ReferenceAssembly(assemblyName);
				}
				result = typeResolutionService.GetType(typeName, throwOnError: true);
			}
			else
			{
				Assembly assembly = Assembly.Load(assemblyName);
				if (assembly != null)
				{
					result = assembly.GetType(typeName);
				}
			}
			return result;
		}

		/// <summary>Initializes the current toolbox item with the specified type to create.</summary>
		/// <param name="type">The <see cref="T:System.Type" /> that the toolbox item creates.</param>
		/// <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Drawing.Design.ToolboxItem" /> was locked.</exception>
		public virtual void Initialize(Type type)
		{
			CheckUnlocked();
			if (type == null)
			{
				return;
			}
			AssemblyName = type.Assembly.GetName();
			DisplayName = type.Name;
			TypeName = type.FullName;
			Image image = null;
			object[] customAttributes = type.GetCustomAttributes(inherit: true);
			for (int i = 0; i < customAttributes.Length; i++)
			{
				if (customAttributes[i] is ToolboxBitmapAttribute toolboxBitmapAttribute)
				{
					image = toolboxBitmapAttribute.GetImage(type);
					break;
				}
			}
			if (image == null)
			{
				image = ToolboxBitmapAttribute.GetImageFromResource(type, null, large: false);
			}
			if (image != null)
			{
				Bitmap = image as Bitmap;
				if (Bitmap == null)
				{
					Bitmap = new Bitmap(image);
				}
			}
			Filter = type.GetCustomAttributes(typeof(ToolboxItemFilterAttribute), inherit: true);
		}

		/// <summary>For a description of this member, see the <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> method.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
		/// <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this serialization.</param>
		void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
		{
			Serialize(info, context);
		}

		/// <summary>Locks the toolbox item and prevents changes to its properties.</summary>
		public virtual void Lock()
		{
			locked = true;
		}

		/// <summary>Raises the <see cref="E:System.Drawing.Design.ToolboxItem.ComponentsCreated" /> event.</summary>
		/// <param name="args">A <see cref="T:System.Drawing.Design.ToolboxComponentsCreatedEventArgs" /> that provides data for the event.</param>
		protected virtual void OnComponentsCreated(ToolboxComponentsCreatedEventArgs args)
		{
			if (this.ComponentsCreated != null)
			{
				this.ComponentsCreated(this, args);
			}
		}

		/// <summary>Raises the <see cref="E:System.Drawing.Design.ToolboxItem.ComponentsCreating" /> event.</summary>
		/// <param name="args">A <see cref="T:System.Drawing.Design.ToolboxComponentsCreatingEventArgs" /> that provides data for the event.</param>
		protected virtual void OnComponentsCreating(ToolboxComponentsCreatingEventArgs args)
		{
			if (this.ComponentsCreating != null)
			{
				this.ComponentsCreating(this, args);
			}
		}

		/// <summary>Saves the state of the toolbox item to the specified serialization information object.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to save to.</param>
		/// <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that indicates the stream characteristics.</param>
		protected virtual void Serialize(SerializationInfo info, StreamingContext context)
		{
			info.AddValue("AssemblyName", AssemblyName);
			info.AddValue("Bitmap", Bitmap);
			info.AddValue("Filter", Filter);
			info.AddValue("DisplayName", DisplayName);
			info.AddValue("Locked", locked);
			info.AddValue("TypeName", TypeName);
		}

		/// <summary>Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Drawing.Design.ToolboxItem" />.</summary>
		/// <returns>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		public override string ToString()
		{
			return DisplayName;
		}

		/// <summary>Validates that an object is of a given type.</summary>
		/// <param name="propertyName">The name of the property to validate.</param>
		/// <param name="value">Optional value against which to validate.</param>
		/// <param name="expectedType">The expected type of the property.</param>
		/// <param name="allowNull">
		///   <see langword="true" /> to allow <see langword="null" />; otherwise, <see langword="false" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="value" /> is <see langword="null" />, and <paramref name="allowNull" /> is <see langword="false" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="value" /> is not the type specified by <paramref name="expectedType" />.</exception>
		protected void ValidatePropertyType(string propertyName, object value, Type expectedType, bool allowNull)
		{
			if (!allowNull && value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (value != null && !expectedType.Equals(value.GetType()))
			{
				throw new ArgumentException(global::Locale.GetText("Type mismatch between value ({0}) and expected type ({1}).", value.GetType(), expectedType), "value");
			}
		}

		/// <summary>Validates a property before it is assigned to the property dictionary.</summary>
		/// <param name="propertyName">The name of the property to validate.</param>
		/// <param name="value">The value against which to validate.</param>
		/// <returns>The value used to perform validation.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="value" /> is <see langword="null" />, and <paramref name="propertyName" /> is "IsTransient".</exception>
		protected virtual object ValidatePropertyValue(string propertyName, object value)
		{
			switch (propertyName)
			{
			case "AssemblyName":
				ValidatePropertyType(propertyName, value, typeof(AssemblyName), allowNull: true);
				break;
			case "Bitmap":
				ValidatePropertyType(propertyName, value, typeof(Bitmap), allowNull: true);
				break;
			case "Company":
			case "Description":
			case "DisplayName":
			case "TypeName":
				ValidatePropertyType(propertyName, value, typeof(string), allowNull: true);
				if (value == null)
				{
					value = string.Empty;
				}
				break;
			case "IsTransient":
				ValidatePropertyType(propertyName, value, typeof(bool), allowNull: false);
				break;
			case "Filter":
				ValidatePropertyType(propertyName, value, typeof(ToolboxItemFilterAttribute[]), allowNull: true);
				if (value == null)
				{
					value = new ToolboxItemFilterAttribute[0];
				}
				break;
			case "DependentAssemblies":
				ValidatePropertyType(propertyName, value, typeof(AssemblyName[]), allowNull: true);
				break;
			}
			return value;
		}

		private void SetValue(string propertyName, object value)
		{
			CheckUnlocked();
			properties[propertyName] = ValidatePropertyValue(propertyName, value);
		}

		private string GetValue(string propertyName)
		{
			string text = (string)properties[propertyName];
			if (text != null)
			{
				return text;
			}
			return string.Empty;
		}
	}
}
namespace System.Drawing.Drawing2D
{
	/// <summary>Specifies the type of graphic shape to use on both ends of each dash in a dashed line.</summary>
	public enum DashCap
	{
		/// <summary>Specifies a square cap that squares off both ends of each dash.</summary>
		Flat = 0,
		/// <summary>Specifies a circular cap that rounds off both ends of each dash.</summary>
		Round = 2,
		/// <summary>Specifies a triangular cap that points both ends of each dash.</summary>
		Triangle = 3
	}
	/// <summary>Represents an adjustable arrow-shaped line cap. This class cannot be inherited.</summary>
	public sealed class AdjustableArrowCap : CustomLineCap
	{
		/// <summary>Gets or sets the height of the arrow cap.</summary>
		/// <returns>The height of the arrow cap.</returns>
		public float Height
		{
			get
			{
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipGetAdjustableArrowCapHeight(new HandleRef(this, nativeCap), out var height));
				return height;
			}
			set
			{
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipSetAdjustableArrowCapHeight(new HandleRef(this, nativeCap), value));
			}
		}

		/// <summary>Gets or sets the width of the arrow cap.</summary>
		/// <returns>The width, in units, of the arrow cap.</returns>
		public float Width
		{
			get
			{
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipGetAdjustableArrowCapWidth(new HandleRef(this, nativeCap), out var width));
				return width;
			}
			set
			{
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipSetAdjustableArrowCapWidth(new HandleRef(this, nativeCap), value));
			}
		}

		/// <summary>Gets or sets the number of units between the outline of the arrow cap and the fill.</summary>
		/// <returns>The number of units between the outline of the arrow cap and the fill of the arrow cap.</returns>
		public float MiddleInset
		{
			get
			{
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipGetAdjustableArrowCapMiddleInset(new HandleRef(this, nativeCap), out var middleInset));
				return middleInset;
			}
			set
			{
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipSetAdjustableArrowCapMiddleInset(new HandleRef(this, nativeCap), value));
			}
		}

		/// <summary>Gets or sets whether the arrow cap is filled.</summary>
		/// <returns>This property is <see langword="true" /> if the arrow cap is filled; otherwise, <see langword="false" />.</returns>
		public bool Filled
		{
			get
			{
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipGetAdjustableArrowCapFillState(new HandleRef(this, nativeCap), out var isFilled));
				return isFilled;
			}
			set
			{
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipSetAdjustableArrowCapFillState(new HandleRef(this, nativeCap), value));
			}
		}

		internal AdjustableArrowCap(IntPtr nativeCap)
			: base(nativeCap)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.AdjustableArrowCap" /> class with the specified width and height. The arrow end caps created with this constructor are always filled.</summary>
		/// <param name="width">The width of the arrow.</param>
		/// <param name="height">The height of the arrow.</param>
		public AdjustableArrowCap(float width, float height)
			: this(width, height, isFilled: true)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.AdjustableArrowCap" /> class with the specified width, height, and fill property. Whether an arrow end cap is filled depends on the argument passed to the <paramref name="isFilled" /> parameter.</summary>
		/// <param name="width">The width of the arrow.</param>
		/// <param name="height">The height of the arrow.</param>
		/// <param name="isFilled">
		///   <see langword="true" /> to fill the arrow cap; otherwise, <see langword="false" />.</param>
		public AdjustableArrowCap(float width, float height, bool isFilled)
		{
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipCreateAdjustableArrowCap(height, width, isFilled, out var arrowCap));
			SetNativeLineCap(arrowCap);
		}
	}
	/// <summary>Defines a blend pattern for a <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> object. This class cannot be inherited.</summary>
	public sealed class Blend
	{
		/// <summary>Gets or sets an array of blend factors for the gradient.</summary>
		/// <returns>An array of blend factors that specify the percentages of the starting color and the ending color to be used at the corresponding position.</returns>
		public float[] Factors { get; set; }

		/// <summary>Gets or sets an array of blend positions for the gradient.</summary>
		/// <returns>An array of blend positions that specify the percentages of distance along the gradient line.</returns>
		public float[] Positions { get; set; }

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.Blend" /> class.</summary>
		public Blend()
		{
			Factors = new float[1];
			Positions = new float[1];
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.Blend" /> class with the specified number of factors and positions.</summary>
		/// <param name="count">The number of elements in the <see cref="P:System.Drawing.Drawing2D.Blend.Factors" /> and <see cref="P:System.Drawing.Drawing2D.Blend.Positions" /> arrays.</param>
		public Blend(int count)
		{
			Factors = new float[count];
			Positions = new float[count];
		}
	}
	internal enum BrushType
	{
		SolidColor,
		HatchFill,
		TextureFill,
		PathGradient,
		LinearGradient
	}
	/// <summary>Defines arrays of colors and positions used for interpolating color blending in a multicolor gradient. This class cannot be inherited.</summary>
	public sealed class ColorBlend
	{
		/// <summary>Gets or sets an array of colors that represents the colors to use at corresponding positions along a gradient.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.Color" /> structures that represents the colors to use at corresponding positions along a gradient.</returns>
		public Color[] Colors { get; set; }

		/// <summary>Gets or sets the positions along a gradient line.</summary>
		/// <returns>An array of values that specify percentages of distance along the gradient line.</returns>
		public float[] Positions { get; set; }

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.ColorBlend" /> class.</summary>
		public ColorBlend()
		{
			Colors = new Color[1];
			Positions = new float[1];
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.ColorBlend" /> class with the specified number of colors and positions.</summary>
		/// <param name="count">The number of colors and positions in this <see cref="T:System.Drawing.Drawing2D.ColorBlend" />.</param>
		public ColorBlend(int count)
		{
			Colors = new Color[count];
			Positions = new float[count];
		}
	}
	/// <summary>Specifies how different clipping regions can be combined.</summary>
	public enum CombineMode
	{
		/// <summary>One clipping region is replaced by another.</summary>
		Replace,
		/// <summary>Two clipping regions are combined by taking their intersection.</summary>
		Intersect,
		/// <summary>Two clipping regions are combined by taking the union of both.</summary>
		Union,
		/// <summary>Two clipping regions are combined by taking only the areas enclosed by one or the other region, but not both.</summary>
		Xor,
		/// <summary>Specifies that the existing region is replaced by the result of the new region being removed from the existing region. Said differently, the new region is excluded from the existing region.</summary>
		Exclude,
		/// <summary>Specifies that the existing region is replaced by the result of the existing region being removed from the new region. Said differently, the existing region is excluded from the new region.</summary>
		Complement
	}
	/// <summary>Specifies how the source colors are combined with the background colors.</summary>
	public enum CompositingMode
	{
		/// <summary>Specifies that when a color is rendered, it is blended with the background color. The blend is determined by the alpha component of the color being rendered.</summary>
		SourceOver,
		/// <summary>Specifies that when a color is rendered, it overwrites the background color.</summary>
		SourceCopy
	}
	/// <summary>Specifies the quality level to use during compositing.</summary>
	public enum CompositingQuality
	{
		/// <summary>Invalid quality.</summary>
		Invalid = -1,
		/// <summary>Default quality.</summary>
		Default,
		/// <summary>High speed, low quality.</summary>
		HighSpeed,
		/// <summary>High quality, low speed compositing.</summary>
		HighQuality,
		/// <summary>Gamma correction is used.</summary>
		GammaCorrected,
		/// <summary>Assume linear values.</summary>
		AssumeLinear
	}
	/// <summary>Specifies the system to use when evaluating coordinates.</summary>
	public enum CoordinateSpace
	{
		/// <summary>Specifies that coordinates are in the world coordinate context. World coordinates are used in a nonphysical environment, such as a modeling environment.</summary>
		World,
		/// <summary>Specifies that coordinates are in the page coordinate context. Their units are defined by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, and must be one of the elements of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration.</summary>
		Page,
		/// <summary>Specifies that coordinates are in the device coordinate context. On a computer screen the device coordinates are usually measured in pixels.</summary>
		Device
	}
	/// <summary>Encapsulates a custom user-defined line cap.</summary>
	public class CustomLineCap : MarshalByRefObject, ICloneable, IDisposable
	{
		internal SafeCustomLineCapHandle nativeCap;

		private bool _disposed;

		/// <summary>Gets or sets the <see cref="T:System.Drawing.Drawing2D.LineJoin" /> enumeration that determines how lines that compose this <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> object are joined.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.LineJoin" /> enumeration this <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> object uses to join lines.</returns>
		public LineJoin StrokeJoin
		{
			get
			{
				LineJoin lineJoin;
				int num = GDIPlus.GdipGetCustomLineCapStrokeJoin(new HandleRef(this, nativeCap), out lineJoin);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return lineJoin;
			}
			set
			{
				int num = GDIPlus.GdipSetCustomLineCapStrokeJoin(new HandleRef(this, nativeCap), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration on which this <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> is based.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration on which this <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> is based.</returns>
		public LineCap BaseCap
		{
			get
			{
				LineCap baseCap;
				int num = GDIPlus.GdipGetCustomLineCapBaseCap(new HandleRef(this, nativeCap), out baseCap);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return baseCap;
			}
			set
			{
				int num = GDIPlus.GdipSetCustomLineCapBaseCap(new HandleRef(this, nativeCap), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the distance between the cap and the line.</summary>
		/// <returns>The distance between the beginning of the cap and the end of the line.</returns>
		public float BaseInset
		{
			get
			{
				float inset;
				int num = GDIPlus.GdipGetCustomLineCapBaseInset(new HandleRef(this, nativeCap), out inset);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return inset;
			}
			set
			{
				int num = GDIPlus.GdipSetCustomLineCapBaseInset(new HandleRef(this, nativeCap), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the amount by which to scale this <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> Class object with respect to the width of the <see cref="T:System.Drawing.Pen" /> object.</summary>
		/// <returns>The amount by which to scale the cap.</returns>
		public float WidthScale
		{
			get
			{
				float widthScale;
				int num = GDIPlus.GdipGetCustomLineCapWidthScale(new HandleRef(this, nativeCap), out widthScale);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return widthScale;
			}
			set
			{
				int num = GDIPlus.GdipSetCustomLineCapWidthScale(new HandleRef(this, nativeCap), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		internal static CustomLineCap CreateCustomLineCapObject(IntPtr cap)
		{
			return new CustomLineCap(cap);
		}

		internal CustomLineCap()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> class with the specified outline and fill.</summary>
		/// <param name="fillPath">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object that defines the fill for the custom cap.</param>
		/// <param name="strokePath">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object that defines the outline of the custom cap.</param>
		public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath)
			: this(fillPath, strokePath, LineCap.Flat)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> class from the specified existing <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration with the specified outline and fill.</summary>
		/// <param name="fillPath">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object that defines the fill for the custom cap.</param>
		/// <param name="strokePath">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object that defines the outline of the custom cap.</param>
		/// <param name="baseCap">The line cap from which to create the custom cap.</param>
		public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath, LineCap baseCap)
			: this(fillPath, strokePath, baseCap, 0f)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> class from the specified existing <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration with the specified outline, fill, and inset.</summary>
		/// <param name="fillPath">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object that defines the fill for the custom cap.</param>
		/// <param name="strokePath">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object that defines the outline of the custom cap.</param>
		/// <param name="baseCap">The line cap from which to create the custom cap.</param>
		/// <param name="baseInset">The distance between the cap and the line.</param>
		public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath, LineCap baseCap, float baseInset)
		{
			IntPtr customCap;
			int num = GDIPlus.GdipCreateCustomLineCap(new HandleRef(fillPath, fillPath?.nativePath ?? IntPtr.Zero), new HandleRef(strokePath, strokePath?.nativePath ?? IntPtr.Zero), baseCap, baseInset, out customCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeLineCap(customCap);
		}

		internal CustomLineCap(IntPtr nativeLineCap)
		{
			SetNativeLineCap(nativeLineCap);
		}

		internal void SetNativeLineCap(IntPtr handle)
		{
			if (handle == IntPtr.Zero)
			{
				throw new ArgumentNullException("handle");
			}
			nativeCap = new SafeCustomLineCapHandle(handle);
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> object.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		/// <summary>Releases the unmanaged resources used by the <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///   <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		protected virtual void Dispose(bool disposing)
		{
			if (!_disposed)
			{
				if (disposing && nativeCap != null)
				{
					nativeCap.Dispose();
				}
				_disposed = true;
			}
		}

		/// <summary>Allows an <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> to attempt to free resources and perform other cleanup operations before the <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> is reclaimed by garbage collection.</summary>
		~CustomLineCap()
		{
			Dispose(disposing: false);
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Drawing2D.CustomLineCap" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> this method creates, cast as an object.</returns>
		public virtual object Clone()
		{
			IntPtr clonedCap;
			int num = GDIPlus.GdipCloneCustomLineCap(new HandleRef(this, nativeCap), out clonedCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return CreateCustomLineCapObject(clonedCap);
		}

		/// <summary>Sets the caps used to start and end lines that make up this custom cap.</summary>
		/// <param name="startCap">The <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration used at the beginning of a line within this cap.</param>
		/// <param name="endCap">The <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration used at the end of a line within this cap.</param>
		public void SetStrokeCaps(LineCap startCap, LineCap endCap)
		{
			int num = GDIPlus.GdipSetCustomLineCapStrokeCaps(new HandleRef(this, nativeCap), startCap, endCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Gets the caps used to start and end lines that make up this custom cap.</summary>
		/// <param name="startCap">The <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration used at the beginning of a line within this cap.</param>
		/// <param name="endCap">The <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration used at the end of a line within this cap.</param>
		public void GetStrokeCaps(out LineCap startCap, out LineCap endCap)
		{
			int num = GDIPlus.GdipGetCustomLineCapStrokeCaps(new HandleRef(this, nativeCap), out startCap, out endCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}
	}
	internal enum CustomLineCapType
	{
		Default,
		AdjustableArrowCap
	}
	/// <summary>Specifies the style of dashed lines drawn with a <see cref="T:System.Drawing.Pen" /> object.</summary>
	public enum DashStyle
	{
		/// <summary>Specifies a solid line.</summary>
		Solid,
		/// <summary>Specifies a line consisting of dashes.</summary>
		Dash,
		/// <summary>Specifies a line consisting of dots.</summary>
		Dot,
		/// <summary>Specifies a line consisting of a repeating pattern of dash-dot.</summary>
		DashDot,
		/// <summary>Specifies a line consisting of a repeating pattern of dash-dot-dot.</summary>
		DashDotDot,
		/// <summary>Specifies a user-defined custom dash style.</summary>
		Custom
	}
	/// <summary>Specifies how the interior of a closed path is filled.</summary>
	public enum FillMode
	{
		/// <summary>Specifies the alternate fill mode.</summary>
		Alternate,
		/// <summary>Specifies the winding fill mode.</summary>
		Winding
	}
	/// <summary>Specifies whether commands in the graphics stack are terminated (flushed) immediately or executed as soon as possible.</summary>
	public enum FlushIntention
	{
		/// <summary>Specifies that the stack of all graphics operations is flushed immediately.</summary>
		Flush,
		/// <summary>Specifies that all graphics operations on the stack are executed as soon as possible. This synchronizes the graphics state.</summary>
		Sync
	}
	/// <summary>Provides the ability to iterate through subpaths in a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> and test the types of shapes contained in each subpath. This class cannot be inherited.</summary>
	public sealed class GraphicsPathIterator : MarshalByRefObject, IDisposable
	{
		internal IntPtr nativeIter;

		/// <summary>Gets the number of points in the path.</summary>
		/// <returns>The number of points in the path.</returns>
		public int Count
		{
			get
			{
				int count;
				int num = GDIPlus.GdipPathIterGetCount(new HandleRef(this, nativeIter), out count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return count;
			}
		}

		/// <summary>Gets the number of subpaths in the path.</summary>
		/// <returns>The number of subpaths in the path.</returns>
		public int SubpathCount
		{
			get
			{
				int count;
				int num = GDIPlus.GdipPathIterGetSubpathCount(new HandleRef(this, nativeIter), out count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return count;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" /> class with the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object for which this helper class is to be initialized.</param>
		public GraphicsPathIterator(GraphicsPath path)
		{
			IntPtr iterator = IntPtr.Zero;
			int num = GDIPlus.GdipCreatePathIter(out iterator, new HandleRef(path, path?.nativePath ?? IntPtr.Zero));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			nativeIter = iterator;
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" /> object.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativeIter != IntPtr.Zero))
			{
				return;
			}
			try
			{
				GDIPlus.GdipDeletePathIter(new HandleRef(this, nativeIter));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeIter = IntPtr.Zero;
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~GraphicsPathIterator()
		{
			Dispose(disposing: false);
		}

		/// <summary>Moves the <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" /> to the next subpath in the path. The start index and end index of the next subpath are contained in the [out] parameters.</summary>
		/// <param name="startIndex">[out] Receives the starting index of the next subpath.</param>
		/// <param name="endIndex">[out] Receives the ending index of the next subpath.</param>
		/// <param name="isClosed">[out] Indicates whether the subpath is closed.</param>
		/// <returns>The number of subpaths in the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object.</returns>
		public int NextSubpath(out int startIndex, out int endIndex, out bool isClosed)
		{
			int resultCount;
			int startIndex2;
			int endIndex2;
			int num = GDIPlus.GdipPathIterNextSubpath(new HandleRef(this, nativeIter), out resultCount, out startIndex2, out endIndex2, out isClosed);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			startIndex = startIndex2;
			endIndex = endIndex2;
			return resultCount;
		}

		/// <summary>Gets the next figure (subpath) from the associated path of this <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" />.</summary>
		/// <param name="path">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> that is to have its data points set to match the data points of the retrieved figure (subpath) for this iterator.</param>
		/// <param name="isClosed">[out] Indicates whether the current subpath is closed. It is <see langword="true" /> if the if the figure is closed, otherwise it is <see langword="false" />.</param>
		/// <returns>The number of data points in the retrieved figure (subpath). If there are no more figures to retrieve, zero is returned.</returns>
		public int NextSubpath(GraphicsPath path, out bool isClosed)
		{
			int resultCount;
			int num = GDIPlus.GdipPathIterNextSubpathPath(new HandleRef(this, nativeIter), out resultCount, new HandleRef(path, path?.nativePath ?? IntPtr.Zero), out isClosed);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return resultCount;
		}

		/// <summary>Gets the starting index and the ending index of the next group of data points that all have the same type.</summary>
		/// <param name="pathType">[out] Receives the point type shared by all points in the group. Possible types can be retrieved from the <see cref="T:System.Drawing.Drawing2D.PathPointType" /> enumeration.</param>
		/// <param name="startIndex">[out] Receives the starting index of the group of points.</param>
		/// <param name="endIndex">[out] Receives the ending index of the group of points.</param>
		/// <returns>This method returns the number of data points in the group. If there are no more groups in the path, this method returns 0.</returns>
		public int NextPathType(out byte pathType, out int startIndex, out int endIndex)
		{
			int resultCount;
			int num = GDIPlus.GdipPathIterNextPathType(new HandleRef(this, nativeIter), out resultCount, out pathType, out startIndex, out endIndex);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return resultCount;
		}

		/// <summary>Increments the <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" /> to the next marker in the path and returns the start and stop indexes by way of the [out] parameters.</summary>
		/// <param name="startIndex">[out] The integer reference supplied to this parameter receives the index of the point that starts a subpath.</param>
		/// <param name="endIndex">[out] The integer reference supplied to this parameter receives the index of the point that ends the subpath to which <paramref name="startIndex" /> points.</param>
		/// <returns>The number of points between this marker and the next.</returns>
		public int NextMarker(out int startIndex, out int endIndex)
		{
			int resultCount;
			int num = GDIPlus.GdipPathIterNextMarker(new HandleRef(this, nativeIter), out resultCount, out startIndex, out endIndex);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return resultCount;
		}

		/// <summary>This <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" /> object has a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object associated with it. The <see cref="M:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker(System.Drawing.Drawing2D.GraphicsPath)" /> method increments the associated <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to the next marker in its path and copies all the points contained between the current marker and the next marker (or end of path) to a second <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object passed in to the parameter.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object to which the points will be copied.</param>
		/// <returns>The number of points between this marker and the next.</returns>
		public int NextMarker(GraphicsPath path)
		{
			int resultCount;
			int num = GDIPlus.GdipPathIterNextMarkerPath(new HandleRef(this, nativeIter), out resultCount, new HandleRef(path, path?.nativePath ?? IntPtr.Zero));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return resultCount;
		}

		/// <summary>Indicates whether the path associated with this <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" /> contains a curve.</summary>
		/// <returns>This method returns <see langword="true" /> if the current subpath contains a curve; otherwise, <see langword="false" />.</returns>
		public bool HasCurve()
		{
			bool curve;
			int num = GDIPlus.GdipPathIterHasCurve(new HandleRef(this, nativeIter), out curve);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return curve;
		}

		/// <summary>Rewinds this <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" /> to the beginning of its associated path.</summary>
		public void Rewind()
		{
			int num = GDIPlus.GdipPathIterRewind(new HandleRef(this, nativeIter));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Copies the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> property and <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> property arrays of the associated <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> into the two specified arrays.</summary>
		/// <param name="points">Upon return, contains an array of <see cref="T:System.Drawing.PointF" /> structures that represents the points in the path.</param>
		/// <param name="types">Upon return, contains an array of bytes that represents the types of points in the path.</param>
		/// <returns>The number of points copied.</returns>
		public unsafe int Enumerate(ref PointF[] points, ref byte[] types)
		{
			if (points.Length != types.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			int resultCount = 0;
			int num = Marshal.SizeOf(typeof(GPPOINTF));
			int num2 = points.Length;
			byte[] array = new byte[num2];
			IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
			try
			{
				int num3 = GDIPlus.GdipPathIterEnumerate(new HandleRef(this, nativeIter), out resultCount, intPtr, array, num2);
				if (num3 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num3);
				}
				if (resultCount < num2)
				{
					SafeNativeMethods.ZeroMemory((byte*)checked((long)intPtr + resultCount * num), (ulong)((num2 - resultCount) * num));
				}
				points = SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr, num2);
				array.CopyTo(types, 0);
				return resultCount;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Copies the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> property and <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> property arrays of the associated <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> into the two specified arrays.</summary>
		/// <param name="points">Upon return, contains an array of <see cref="T:System.Drawing.PointF" /> structures that represents the points in the path.</param>
		/// <param name="types">Upon return, contains an array of bytes that represents the types of points in the path.</param>
		/// <param name="startIndex">Specifies the starting index of the arrays.</param>
		/// <param name="endIndex">Specifies the ending index of the arrays.</param>
		/// <returns>The number of points copied.</returns>
		public unsafe int CopyData(ref PointF[] points, ref byte[] types, int startIndex, int endIndex)
		{
			if (points.Length != types.Length || endIndex - startIndex + 1 > points.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			int resultCount = 0;
			int num = Marshal.SizeOf(typeof(GPPOINTF));
			int num2 = points.Length;
			byte[] array = new byte[num2];
			IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
			try
			{
				int num3 = GDIPlus.GdipPathIterCopyData(new HandleRef(this, nativeIter), out resultCount, intPtr, array, startIndex, endIndex);
				if (num3 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num3);
				}
				if (resultCount < num2)
				{
					SafeNativeMethods.ZeroMemory((byte*)checked((long)intPtr + resultCount * num), (ulong)((num2 - resultCount) * num));
				}
				points = SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr, num2);
				array.CopyTo(types, 0);
				return resultCount;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}
	}
	/// <summary>Represents the state of a <see cref="T:System.Drawing.Graphics" /> object. This object is returned by a call to the <see cref="M:System.Drawing.Graphics.Save" /> methods. This class cannot be inherited.</summary>
	public sealed class GraphicsState : MarshalByRefObject
	{
		internal int nativeState;

		internal GraphicsState(int nativeState)
		{
			this.nativeState = nativeState;
		}

		internal GraphicsState()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Defines a rectangular brush with a hatch style, a foreground color, and a background color. This class cannot be inherited.</summary>
	public sealed class HatchBrush : Brush
	{
		/// <summary>Gets the hatch style of this <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> object.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Drawing2D.HatchStyle" /> values that represents the pattern of this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</returns>
		public HatchStyle HatchStyle
		{
			get
			{
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipGetHatchStyle(new HandleRef(this, base.NativeBrush), out var hatchstyle));
				return (HatchStyle)hatchstyle;
			}
		}

		/// <summary>Gets the color of hatch lines drawn by this <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> structure that represents the foreground color for this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</returns>
		public Color ForegroundColor
		{
			get
			{
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipGetHatchForegroundColor(new HandleRef(this, base.NativeBrush), out var foreColor));
				return Color.FromArgb(foreColor);
			}
		}

		/// <summary>Gets the color of spaces between the hatch lines drawn by this <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> structure that represents the background color for this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</returns>
		public Color BackgroundColor
		{
			get
			{
				SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipGetHatchBackgroundColor(new HandleRef(this, base.NativeBrush), out var backColor));
				return Color.FromArgb(backColor);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> class with the specified <see cref="T:System.Drawing.Drawing2D.HatchStyle" /> enumeration and foreground color.</summary>
		/// <param name="hatchstyle">One of the <see cref="T:System.Drawing.Drawing2D.HatchStyle" /> values that represents the pattern drawn by this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</param>
		/// <param name="foreColor">The <see cref="T:System.Drawing.Color" /> structure that represents the color of lines drawn by this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</param>
		public HatchBrush(HatchStyle hatchstyle, Color foreColor)
			: this(hatchstyle, foreColor, Color.FromArgb(-16777216))
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> class with the specified <see cref="T:System.Drawing.Drawing2D.HatchStyle" /> enumeration, foreground color, and background color.</summary>
		/// <param name="hatchstyle">One of the <see cref="T:System.Drawing.Drawing2D.HatchStyle" /> values that represents the pattern drawn by this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</param>
		/// <param name="foreColor">The <see cref="T:System.Drawing.Color" /> structure that represents the color of lines drawn by this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</param>
		/// <param name="backColor">The <see cref="T:System.Drawing.Color" /> structure that represents the color of spaces between the lines drawn by this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</param>
		public HatchBrush(HatchStyle hatchstyle, Color foreColor, Color backColor)
		{
			if (hatchstyle < HatchStyle.Horizontal || hatchstyle > HatchStyle.SolidDiamond)
			{
				throw new ArgumentException(global::SR.Format("The value of argument '{0}' ({1}) is invalid for Enum type '{2}'.", "hatchstyle", hatchstyle, "HatchStyle"), "hatchstyle");
			}
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipCreateHatchBrush((int)hatchstyle, foreColor.ToArgb(), backColor.ToArgb(), out var brush));
			SetNativeBrushInternal(brush);
		}

		internal HatchBrush(IntPtr nativeBrush)
		{
			SetNativeBrushInternal(nativeBrush);
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> object.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> this method creates, cast as an object.</returns>
		public override object Clone()
		{
			IntPtr clonedBrush = IntPtr.Zero;
			SafeNativeMethods.Gdip.CheckStatus(GDIPlus.GdipCloneBrush(new HandleRef(this, base.NativeBrush), out clonedBrush));
			return new HatchBrush(clonedBrush);
		}
	}
	/// <summary>Specifies the different patterns available for <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> objects.</summary>
	public enum HatchStyle
	{
		/// <summary>A pattern of horizontal lines.</summary>
		Horizontal = 0,
		/// <summary>A pattern of vertical lines.</summary>
		Vertical = 1,
		/// <summary>A pattern of lines on a diagonal from upper left to lower right.</summary>
		ForwardDiagonal = 2,
		/// <summary>A pattern of lines on a diagonal from upper right to lower left.</summary>
		BackwardDiagonal = 3,
		/// <summary>Specifies horizontal and vertical lines that cross.</summary>
		Cross = 4,
		/// <summary>A pattern of crisscross diagonal lines.</summary>
		DiagonalCross = 5,
		/// <summary>Specifies a 5-percent hatch. The ratio of foreground color to background color is 5:95.</summary>
		Percent05 = 6,
		/// <summary>Specifies a 10-percent hatch. The ratio of foreground color to background color is 10:90.</summary>
		Percent10 = 7,
		/// <summary>Specifies a 20-percent hatch. The ratio of foreground color to background color is 20:80.</summary>
		Percent20 = 8,
		/// <summary>Specifies a 25-percent hatch. The ratio of foreground color to background color is 25:75.</summary>
		Percent25 = 9,
		/// <summary>Specifies a 30-percent hatch. The ratio of foreground color to background color is 30:70.</summary>
		Percent30 = 10,
		/// <summary>Specifies a 40-percent hatch. The ratio of foreground color to background color is 40:60.</summary>
		Percent40 = 11,
		/// <summary>Specifies a 50-percent hatch. The ratio of foreground color to background color is 50:50.</summary>
		Percent50 = 12,
		/// <summary>Specifies a 60-percent hatch. The ratio of foreground color to background color is 60:40.</summary>
		Percent60 = 13,
		/// <summary>Specifies a 70-percent hatch. The ratio of foreground color to background color is 70:30.</summary>
		Percent70 = 14,
		/// <summary>Specifies a 75-percent hatch. The ratio of foreground color to background color is 75:25.</summary>
		Percent75 = 15,
		/// <summary>Specifies a 80-percent hatch. The ratio of foreground color to background color is 80:100.</summary>
		Percent80 = 16,
		/// <summary>Specifies a 90-percent hatch. The ratio of foreground color to background color is 90:10.</summary>
		Percent90 = 17,
		/// <summary>Specifies diagonal lines that slant to the right from top points to bottom points and are spaced 50 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.ForwardDiagonal" />, but are not antialiased.</summary>
		LightDownwardDiagonal = 18,
		/// <summary>Specifies diagonal lines that slant to the left from top points to bottom points and are spaced 50 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.BackwardDiagonal" />, but they are not antialiased.</summary>
		LightUpwardDiagonal = 19,
		/// <summary>Specifies diagonal lines that slant to the right from top points to bottom points, are spaced 50 percent closer together than, and are twice the width of <see cref="F:System.Drawing.Drawing2D.HatchStyle.ForwardDiagonal" />. This hatch pattern is not antialiased.</summary>
		DarkDownwardDiagonal = 20,
		/// <summary>Specifies diagonal lines that slant to the left from top points to bottom points, are spaced 50 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.BackwardDiagonal" />, and are twice its width, but the lines are not antialiased.</summary>
		DarkUpwardDiagonal = 21,
		/// <summary>Specifies diagonal lines that slant to the right from top points to bottom points, have the same spacing as hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.ForwardDiagonal" />, and are triple its width, but are not antialiased.</summary>
		WideDownwardDiagonal = 22,
		/// <summary>Specifies diagonal lines that slant to the left from top points to bottom points, have the same spacing as hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.BackwardDiagonal" />, and are triple its width, but are not antialiased.</summary>
		WideUpwardDiagonal = 23,
		/// <summary>Specifies vertical lines that are spaced 50 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.Vertical" />.</summary>
		LightVertical = 24,
		/// <summary>Specifies horizontal lines that are spaced 50 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.Horizontal" />.</summary>
		LightHorizontal = 25,
		/// <summary>Specifies vertical lines that are spaced 75 percent closer together than hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.Vertical" /> (or 25 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.LightVertical" />).</summary>
		NarrowVertical = 26,
		/// <summary>Specifies horizontal lines that are spaced 75 percent closer together than hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.Horizontal" /> (or 25 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.LightHorizontal" />).</summary>
		NarrowHorizontal = 27,
		/// <summary>Specifies vertical lines that are spaced 50 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.Vertical" /> and are twice its width.</summary>
		DarkVertical = 28,
		/// <summary>Specifies horizontal lines that are spaced 50 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.Horizontal" /> and are twice the width of <see cref="F:System.Drawing.Drawing2D.HatchStyle.Horizontal" />.</summary>
		DarkHorizontal = 29,
		/// <summary>Specifies dashed diagonal lines, that slant to the right from top points to bottom points.</summary>
		DashedDownwardDiagonal = 30,
		/// <summary>Specifies dashed diagonal lines, that slant to the left from top points to bottom points.</summary>
		DashedUpwardDiagonal = 31,
		/// <summary>Specifies dashed horizontal lines.</summary>
		DashedHorizontal = 32,
		/// <summary>Specifies dashed vertical lines.</summary>
		DashedVertical = 33,
		/// <summary>Specifies a hatch that has the appearance of confetti.</summary>
		SmallConfetti = 34,
		/// <summary>Specifies a hatch that has the appearance of confetti, and is composed of larger pieces than <see cref="F:System.Drawing.Drawing2D.HatchStyle.SmallConfetti" />.</summary>
		LargeConfetti = 35,
		/// <summary>Specifies horizontal lines that are composed of zigzags.</summary>
		ZigZag = 36,
		/// <summary>Specifies horizontal lines that are composed of tildes.</summary>
		Wave = 37,
		/// <summary>Specifies a hatch that has the appearance of layered bricks that slant to the left from top points to bottom points.</summary>
		DiagonalBrick = 38,
		/// <summary>Specifies a hatch that has the appearance of horizontally layered bricks.</summary>
		HorizontalBrick = 39,
		/// <summary>Specifies a hatch that has the appearance of a woven material.</summary>
		Weave = 40,
		/// <summary>Specifies a hatch that has the appearance of a plaid material.</summary>
		Plaid = 41,
		/// <summary>Specifies a hatch that has the appearance of divots.</summary>
		Divot = 42,
		/// <summary>Specifies horizontal and vertical lines, each of which is composed of dots, that cross.</summary>
		DottedGrid = 43,
		/// <summary>Specifies forward diagonal and backward diagonal lines, each of which is composed of dots, that cross.</summary>
		DottedDiamond = 44,
		/// <summary>Specifies a hatch that has the appearance of diagonally layered shingles that slant to the right from top points to bottom points.</summary>
		Shingle = 45,
		/// <summary>Specifies a hatch that has the appearance of a trellis.</summary>
		Trellis = 46,
		/// <summary>Specifies a hatch that has the appearance of spheres laid adjacent to one another.</summary>
		Sphere = 47,
		/// <summary>Specifies horizontal and vertical lines that cross and are spaced 50 percent closer together than hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.Cross" />.</summary>
		SmallGrid = 48,
		/// <summary>Specifies a hatch that has the appearance of a checkerboard.</summary>
		SmallCheckerBoard = 49,
		/// <summary>Specifies a hatch that has the appearance of a checkerboard with squares that are twice the size of <see cref="F:System.Drawing.Drawing2D.HatchStyle.SmallCheckerBoard" />.</summary>
		LargeCheckerBoard = 50,
		/// <summary>Specifies forward diagonal and backward diagonal lines that cross but are not antialiased.</summary>
		OutlinedDiamond = 51,
		/// <summary>Specifies a hatch that has the appearance of a checkerboard placed diagonally.</summary>
		SolidDiamond = 52,
		/// <summary>Specifies the hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.Cross" />.</summary>
		LargeGrid = 4,
		/// <summary>Specifies hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.Horizontal" />.</summary>
		Min = 0,
		/// <summary>Specifies hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.SolidDiamond" />.</summary>
		Max = 4
	}
	/// <summary>The <see cref="T:System.Drawing.Drawing2D.InterpolationMode" /> enumeration specifies the algorithm that is used when images are scaled or rotated.</summary>
	public enum InterpolationMode
	{
		/// <summary>Equivalent to the <see cref="F:System.Drawing.Drawing2D.QualityMode.Invalid" /> element of the <see cref="T:System.Drawing.Drawing2D.QualityMode" /> enumeration.</summary>
		Invalid = -1,
		/// <summary>Specifies default mode.</summary>
		Default,
		/// <summary>Specifies low quality interpolation.</summary>
		Low,
		/// <summary>Specifies high quality interpolation.</summary>
		High,
		/// <summary>Specifies bilinear interpolation. No prefiltering is done. This mode is not suitable for shrinking an image below 50 percent of its original size.</summary>
		Bilinear,
		/// <summary>Specifies bicubic interpolation. No prefiltering is done. This mode is not suitable for shrinking an image below 25 percent of its original size.</summary>
		Bicubic,
		/// <summary>Specifies nearest-neighbor interpolation.</summary>
		NearestNeighbor,
		/// <summary>Specifies high-quality, bilinear interpolation. Prefiltering is performed to ensure high-quality shrinking.</summary>
		HighQualityBilinear,
		/// <summary>Specifies high-quality, bicubic interpolation. Prefiltering is performed to ensure high-quality shrinking. This mode produces the highest quality transformed images.</summary>
		HighQualityBicubic
	}
	/// <summary>Specifies the available cap styles with which a <see cref="T:System.Drawing.Pen" /> object can end a line.</summary>
	public enum LineCap
	{
		/// <summary>Specifies a flat line cap.</summary>
		Flat = 0,
		/// <summary>Specifies a square line cap.</summary>
		Square = 1,
		/// <summary>Specifies a round line cap.</summary>
		Round = 2,
		/// <summary>Specifies a triangular line cap.</summary>
		Triangle = 3,
		/// <summary>Specifies no anchor.</summary>
		NoAnchor = 16,
		/// <summary>Specifies a square anchor line cap.</summary>
		SquareAnchor = 17,
		/// <summary>Specifies a round anchor cap.</summary>
		RoundAnchor = 18,
		/// <summary>Specifies a diamond anchor cap.</summary>
		DiamondAnchor = 19,
		/// <summary>Specifies an arrow-shaped anchor cap.</summary>
		ArrowAnchor = 20,
		/// <summary>Specifies a custom line cap.</summary>
		Custom = 255,
		/// <summary>Specifies a mask used to check whether a line cap is an anchor cap.</summary>
		AnchorMask = 240
	}
	/// <summary>Specifies how to join consecutive line or curve segments in a figure (subpath) contained in a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object.</summary>
	public enum LineJoin
	{
		/// <summary>Specifies a mitered join. This produces a sharp corner or a clipped corner, depending on whether the length of the miter exceeds the miter limit.</summary>
		Miter,
		/// <summary>Specifies a beveled join. This produces a diagonal corner.</summary>
		Bevel,
		/// <summary>Specifies a circular join. This produces a smooth, circular arc between the lines.</summary>
		Round,
		/// <summary>Specifies a mitered join. This produces a sharp corner or a beveled corner, depending on whether the length of the miter exceeds the miter limit.</summary>
		MiterClipped
	}
	/// <summary>Specifies the direction of a linear gradient.</summary>
	public enum LinearGradientMode
	{
		/// <summary>Specifies a gradient from left to right.</summary>
		Horizontal,
		/// <summary>Specifies a gradient from top to bottom.</summary>
		Vertical,
		/// <summary>Specifies a gradient from upper left to lower right.</summary>
		ForwardDiagonal,
		/// <summary>Specifies a gradient from upper right to lower left.</summary>
		BackwardDiagonal
	}
	/// <summary>Specifies the order for matrix transform operations.</summary>
	public enum MatrixOrder
	{
		/// <summary>The new operation is applied before the old operation.</summary>
		Prepend,
		/// <summary>The new operation is applied after the old operation.</summary>
		Append
	}
	/// <summary>Contains the graphical data that makes up a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object. This class cannot be inherited.</summary>
	public sealed class PathData
	{
		/// <summary>Gets or sets an array of <see cref="T:System.Drawing.PointF" /> structures that represents the points through which the path is constructed.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.PointF" /> objects that represents the points through which the path is constructed.</returns>
		public PointF[] Points { get; set; }

		/// <summary>Gets or sets the types of the corresponding points in the path.</summary>
		/// <returns>An array of bytes that specify the types of the corresponding points in the path.</returns>
		public byte[] Types { get; set; }

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.PathData" /> class.</summary>
		public PathData()
		{
		}
	}
	/// <summary>Specifies the type of point in a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object.</summary>
	public enum PathPointType
	{
		/// <summary>The starting point of a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object.</summary>
		Start = 0,
		/// <summary>A line segment.</summary>
		Line = 1,
		/// <summary>A default Bzier curve.</summary>
		Bezier = 3,
		/// <summary>A mask point.</summary>
		PathTypeMask = 7,
		/// <summary>The corresponding segment is dashed.</summary>
		DashMode = 16,
		/// <summary>A path marker.</summary>
		PathMarker = 32,
		/// <summary>The endpoint of a subpath.</summary>
		CloseSubpath = 128,
		/// <summary>A cubic Bzier curve.</summary>
		Bezier3 = 3
	}
	/// <summary>Specifies the alignment of a <see cref="T:System.Drawing.Pen" /> object in relation to the theoretical, zero-width line.</summary>
	public enum PenAlignment
	{
		/// <summary>Specifies that the <see cref="T:System.Drawing.Pen" /> object is centered over the theoretical line.</summary>
		Center,
		/// <summary>Specifies that the <see cref="T:System.Drawing.Pen" /> is positioned on the inside of the theoretical line.</summary>
		Inset,
		/// <summary>Specifies the <see cref="T:System.Drawing.Pen" /> is positioned on the outside of the theoretical line.</summary>
		Outset,
		/// <summary>Specifies the <see cref="T:System.Drawing.Pen" /> is positioned to the left of the theoretical line.</summary>
		Left,
		/// <summary>Specifies the <see cref="T:System.Drawing.Pen" /> is positioned to the right of the theoretical line.</summary>
		Right
	}
	/// <summary>Specifies the type of fill a <see cref="T:System.Drawing.Pen" /> object uses to fill lines.</summary>
	public enum PenType
	{
		/// <summary>Specifies a solid fill.</summary>
		SolidColor,
		/// <summary>Specifies a hatch fill.</summary>
		HatchFill,
		/// <summary>Specifies a bitmap texture fill.</summary>
		TextureFill,
		/// <summary>Specifies a path gradient fill.</summary>
		PathGradient,
		/// <summary>Specifies a linear gradient fill.</summary>
		LinearGradient
	}
	/// <summary>Specifies how pixels are offset during rendering.</summary>
	public enum PixelOffsetMode
	{
		/// <summary>Specifies an invalid mode.</summary>
		Invalid = -1,
		/// <summary>Specifies the default mode.</summary>
		Default,
		/// <summary>Specifies high speed, low quality rendering.</summary>
		HighSpeed,
		/// <summary>Specifies high quality, low speed rendering.</summary>
		HighQuality,
		/// <summary>Specifies no pixel offset.</summary>
		None,
		/// <summary>Specifies that pixels are offset by -.5 units, both horizontally and vertically, for high speed antialiasing.</summary>
		Half
	}
	/// <summary>Specifies the overall quality when rendering GDI+ objects.</summary>
	public enum QualityMode
	{
		/// <summary>Specifies an invalid mode.</summary>
		Invalid = -1,
		/// <summary>Specifies the default mode.</summary>
		Default,
		/// <summary>Specifies low quality, high speed rendering.</summary>
		Low,
		/// <summary>Specifies high quality, low speed rendering.</summary>
		High
	}
	/// <summary>Encapsulates the data that makes up a <see cref="T:System.Drawing.Region" /> object. This class cannot be inherited.</summary>
	public sealed class RegionData
	{
		/// <summary>Gets or sets an array of bytes that specify the <see cref="T:System.Drawing.Region" /> object.</summary>
		/// <returns>An array of bytes that specify the <see cref="T:System.Drawing.Region" /> object.</returns>
		public byte[] Data { get; set; }

		internal RegionData(byte[] data)
		{
			Data = data;
		}

		internal RegionData()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	[SecurityCritical]
	internal class SafeCustomLineCapHandle : SafeHandle
	{
		public override bool IsInvalid => handle == IntPtr.Zero;

		internal SafeCustomLineCapHandle(IntPtr h)
			: base(IntPtr.Zero, ownsHandle: true)
		{
			SetHandle(h);
		}

		[SecurityCritical]
		protected override bool ReleaseHandle()
		{
			int num = 0;
			if (!IsInvalid)
			{
				try
				{
					num = GDIPlus.GdipDeleteCustomLineCap(new HandleRef(this, handle));
				}
				catch (Exception ex)
				{
					if (ClientUtils.IsSecurityOrCriticalException(ex))
					{
						throw;
					}
				}
				finally
				{
					handle = IntPtr.Zero;
				}
			}
			return num == 0;
		}

		public static implicit operator IntPtr(SafeCustomLineCapHandle handle)
		{
			return handle?.handle ?? IntPtr.Zero;
		}

		public static explicit operator SafeCustomLineCapHandle(IntPtr handle)
		{
			return new SafeCustomLineCapHandle(handle);
		}
	}
	/// <summary>Specifies whether smoothing (antialiasing) is applied to lines and curves and the edges of filled areas.</summary>
	public enum SmoothingMode
	{
		/// <summary>Specifies an invalid mode.</summary>
		Invalid = -1,
		/// <summary>Specifies no antialiasing.</summary>
		Default,
		/// <summary>Specifies no antialiasing.</summary>
		HighSpeed,
		/// <summary>Specifies antialiased rendering.</summary>
		HighQuality,
		/// <summary>Specifies no antialiasing.</summary>
		None,
		/// <summary>Specifies antialiased rendering.</summary>
		AntiAlias
	}
	/// <summary>Specifies the type of warp transformation applied in a <see cref="Overload:System.Drawing.Drawing2D.GraphicsPath.Warp" /> method.</summary>
	public enum WarpMode
	{
		/// <summary>Specifies a perspective warp.</summary>
		Perspective,
		/// <summary>Specifies a bilinear warp.</summary>
		Bilinear
	}
	/// <summary>Specifies how a texture or gradient is tiled when it is smaller than the area being filled.</summary>
	public enum WrapMode
	{
		/// <summary>Tiles the gradient or texture.</summary>
		Tile,
		/// <summary>Reverses the texture or gradient horizontally and then tiles the texture or gradient.</summary>
		TileFlipX,
		/// <summary>Reverses the texture or gradient vertically and then tiles the texture or gradient.</summary>
		TileFlipY,
		/// <summary>Reverses the texture or gradient horizontally and vertically and then tiles the texture or gradient.</summary>
		TileFlipXY,
		/// <summary>The texture or gradient is not tiled.</summary>
		Clamp
	}
	/// <summary>Represents the internal data of a graphics container. This class is used when saving the state of a <see cref="T:System.Drawing.Graphics" /> object using the <see cref="M:System.Drawing.Graphics.BeginContainer" /> and <see cref="M:System.Drawing.Graphics.EndContainer(System.Drawing.Drawing2D.GraphicsContainer)" /> methods. This class cannot be inherited.</summary>
	public sealed class GraphicsContainer : MarshalByRefObject
	{
		private uint nativeState;

		internal uint NativeObject => nativeState;

		internal GraphicsContainer(uint state)
		{
			nativeState = state;
		}

		internal GraphicsContainer()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents a series of connected lines and curves. This class cannot be inherited.</summary>
	public sealed class GraphicsPath : MarshalByRefObject, ICloneable, IDisposable
	{
		private const float FlatnessDefault = 0.25f;

		internal IntPtr nativePath = IntPtr.Zero;

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the interiors of shapes in this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> are filled.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that specifies how the interiors of shapes in this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> are filled.</returns>
		public FillMode FillMode
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPathFillMode(nativePath, out var fillMode));
				return fillMode;
			}
			set
			{
				if (value < FillMode.Alternate || value > FillMode.Winding)
				{
					throw new InvalidEnumArgumentException("FillMode", (int)value, typeof(FillMode));
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetPathFillMode(nativePath, value));
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Drawing2D.PathData" /> that encapsulates arrays of points (<paramref name="points" />) and types (<paramref name="types" />) for this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.PathData" /> that encapsulates arrays for both the points and types for this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
		public PathData PathData
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPointCount(nativePath, out var count));
				PointF[] points = new PointF[count];
				byte[] types = new byte[count];
				if (count > 0)
				{
					GDIPlus.CheckStatus(GDIPlus.GdipGetPathPoints(nativePath, points, count));
					GDIPlus.CheckStatus(GDIPlus.GdipGetPathTypes(nativePath, types, count));
				}
				return new PathData
				{
					Points = points,
					Types = types
				};
			}
		}

		/// <summary>Gets the points in the path.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.PointF" /> objects that represent the path.</returns>
		public PointF[] PathPoints
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPointCount(nativePath, out var count));
				if (count == 0)
				{
					throw new ArgumentException("PathPoints");
				}
				PointF[] array = new PointF[count];
				GDIPlus.CheckStatus(GDIPlus.GdipGetPathPoints(nativePath, array, count));
				return array;
			}
		}

		/// <summary>Gets the types of the corresponding points in the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> array.</summary>
		/// <returns>An array of bytes that specifies the types of the corresponding points in the path.</returns>
		public byte[] PathTypes
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPointCount(nativePath, out var count));
				if (count == 0)
				{
					throw new ArgumentException("PathTypes");
				}
				byte[] array = new byte[count];
				GDIPlus.CheckStatus(GDIPlus.GdipGetPathTypes(nativePath, array, count));
				return array;
			}
		}

		/// <summary>Gets the number of elements in the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> or the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> array.</summary>
		/// <returns>An integer that specifies the number of elements in the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> or the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> array.</returns>
		public int PointCount
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPointCount(nativePath, out var count));
				return count;
			}
		}

		internal IntPtr NativeObject
		{
			get
			{
				return nativePath;
			}
			set
			{
				nativePath = value;
			}
		}

		private GraphicsPath(IntPtr ptr)
		{
			nativePath = ptr;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> class with a <see cref="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" /> value of <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
		public GraphicsPath()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreatePath(FillMode.Alternate, out nativePath));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> class with the specified <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration.</summary>
		/// <param name="fillMode">The <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the interior of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> is filled.</param>
		public GraphicsPath(FillMode fillMode)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreatePath(fillMode, out nativePath));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> class with the specified <see cref="T:System.Drawing.Drawing2D.PathPointType" /> and <see cref="T:System.Drawing.Point" /> arrays.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.Point" /> structures that defines the coordinates of the points that make up this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
		/// <param name="types">An array of <see cref="T:System.Drawing.Drawing2D.PathPointType" /> enumeration elements that specifies the type of each corresponding point in the <paramref name="pts" /> array.</param>
		public GraphicsPath(Point[] pts, byte[] types)
			: this(pts, types, FillMode.Alternate)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> array with the specified <see cref="T:System.Drawing.Drawing2D.PathPointType" /> and <see cref="T:System.Drawing.PointF" /> arrays.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.PointF" /> structures that defines the coordinates of the points that make up this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
		/// <param name="types">An array of <see cref="T:System.Drawing.Drawing2D.PathPointType" /> enumeration elements that specifies the type of each corresponding point in the <paramref name="pts" /> array.</param>
		public GraphicsPath(PointF[] pts, byte[] types)
			: this(pts, types, FillMode.Alternate)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> class with the specified <see cref="T:System.Drawing.Drawing2D.PathPointType" /> and <see cref="T:System.Drawing.Point" /> arrays and with the specified <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration element.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.Point" /> structures that defines the coordinates of the points that make up this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
		/// <param name="types">An array of <see cref="T:System.Drawing.Drawing2D.PathPointType" /> enumeration elements that specifies the type of each corresponding point in the <paramref name="pts" /> array.</param>
		/// <param name="fillMode">A <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that specifies how the interiors of shapes in this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> are filled.</param>
		public GraphicsPath(Point[] pts, byte[] types, FillMode fillMode)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			if (pts.Length != types.Length)
			{
				throw new ArgumentException("Invalid parameter passed. Number of points and types must be same.");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreatePath2I(pts, types, pts.Length, fillMode, out nativePath));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> array with the specified <see cref="T:System.Drawing.Drawing2D.PathPointType" /> and <see cref="T:System.Drawing.PointF" /> arrays and with the specified <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration element.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.PointF" /> structures that defines the coordinates of the points that make up this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
		/// <param name="types">An array of <see cref="T:System.Drawing.Drawing2D.PathPointType" /> enumeration elements that specifies the type of each corresponding point in the <paramref name="pts" /> array.</param>
		/// <param name="fillMode">A <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that specifies how the interiors of shapes in this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> are filled.</param>
		public GraphicsPath(PointF[] pts, byte[] types, FillMode fillMode)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			if (pts.Length != types.Length)
			{
				throw new ArgumentException("Invalid parameter passed. Number of points and types must be same.");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreatePath2(pts, types, pts.Length, fillMode, out nativePath));
		}

		/// <summary>Creates an exact copy of this path.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> this method creates, cast as an object.</returns>
		public object Clone()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipClonePath(nativePath, out var clonePath));
			return new GraphicsPath(clonePath);
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~GraphicsPath()
		{
			Dispose(disposing: false);
		}

		private void Dispose(bool disposing)
		{
			if (nativePath != IntPtr.Zero)
			{
				GDIPlus.CheckStatus(GDIPlus.GdipDeletePath(nativePath));
				nativePath = IntPtr.Zero;
			}
		}

		/// <summary>Appends an elliptical arc to the current figure.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangular bounds of the ellipse from which the arc is taken.</param>
		/// <param name="startAngle">The starting angle of the arc, measured in degrees clockwise from the x-axis.</param>
		/// <param name="sweepAngle">The angle between <paramref name="startAngle" /> and the end of the arc.</param>
		public void AddArc(Rectangle rect, float startAngle, float sweepAngle)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathArcI(nativePath, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle));
		}

		/// <summary>Appends an elliptical arc to the current figure.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangular bounds of the ellipse from which the arc is taken.</param>
		/// <param name="startAngle">The starting angle of the arc, measured in degrees clockwise from the x-axis.</param>
		/// <param name="sweepAngle">The angle between <paramref name="startAngle" /> and the end of the arc.</param>
		public void AddArc(RectangleF rect, float startAngle, float sweepAngle)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathArc(nativePath, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle));
		}

		/// <summary>Appends an elliptical arc to the current figure.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="width">The width of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="height">The height of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="startAngle">The starting angle of the arc, measured in degrees clockwise from the x-axis.</param>
		/// <param name="sweepAngle">The angle between <paramref name="startAngle" /> and the end of the arc.</param>
		public void AddArc(int x, int y, int width, int height, float startAngle, float sweepAngle)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathArcI(nativePath, x, y, width, height, startAngle, sweepAngle));
		}

		/// <summary>Appends an elliptical arc to the current figure.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="width">The width of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="height">The height of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="startAngle">The starting angle of the arc, measured in degrees clockwise from the x-axis.</param>
		/// <param name="sweepAngle">The angle between <paramref name="startAngle" /> and the end of the arc.</param>
		public void AddArc(float x, float y, float width, float height, float startAngle, float sweepAngle)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathArc(nativePath, x, y, width, height, startAngle, sweepAngle));
		}

		/// <summary>Adds a cubic Bzier curve to the current figure.</summary>
		/// <param name="pt1">A <see cref="T:System.Drawing.Point" /> that represents the starting point of the curve.</param>
		/// <param name="pt2">A <see cref="T:System.Drawing.Point" /> that represents the first control point for the curve.</param>
		/// <param name="pt3">A <see cref="T:System.Drawing.Point" /> that represents the second control point for the curve.</param>
		/// <param name="pt4">A <see cref="T:System.Drawing.Point" /> that represents the endpoint of the curve.</param>
		public void AddBezier(Point pt1, Point pt2, Point pt3, Point pt4)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathBezierI(nativePath, pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y));
		}

		/// <summary>Adds a cubic Bzier curve to the current figure.</summary>
		/// <param name="pt1">A <see cref="T:System.Drawing.PointF" /> that represents the starting point of the curve.</param>
		/// <param name="pt2">A <see cref="T:System.Drawing.PointF" /> that represents the first control point for the curve.</param>
		/// <param name="pt3">A <see cref="T:System.Drawing.PointF" /> that represents the second control point for the curve.</param>
		/// <param name="pt4">A <see cref="T:System.Drawing.PointF" /> that represents the endpoint of the curve.</param>
		public void AddBezier(PointF pt1, PointF pt2, PointF pt3, PointF pt4)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathBezier(nativePath, pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y));
		}

		/// <summary>Adds a cubic Bzier curve to the current figure.</summary>
		/// <param name="x1">The x-coordinate of the starting point of the curve.</param>
		/// <param name="y1">The y-coordinate of the starting point of the curve.</param>
		/// <param name="x2">The x-coordinate of the first control point for the curve.</param>
		/// <param name="y2">The y-coordinate of the first control point for the curve.</param>
		/// <param name="x3">The x-coordinate of the second control point for the curve.</param>
		/// <param name="y3">The y-coordinate of the second control point for the curve.</param>
		/// <param name="x4">The x-coordinate of the endpoint of the curve.</param>
		/// <param name="y4">The y-coordinate of the endpoint of the curve.</param>
		public void AddBezier(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathBezierI(nativePath, x1, y1, x2, y2, x3, y3, x4, y4));
		}

		/// <summary>Adds a cubic Bzier curve to the current figure.</summary>
		/// <param name="x1">The x-coordinate of the starting point of the curve.</param>
		/// <param name="y1">The y-coordinate of the starting point of the curve.</param>
		/// <param name="x2">The x-coordinate of the first control point for the curve.</param>
		/// <param name="y2">The y-coordinate of the first control point for the curve.</param>
		/// <param name="x3">The x-coordinate of the second control point for the curve.</param>
		/// <param name="y3">The y-coordinate of the second control point for the curve.</param>
		/// <param name="x4">The x-coordinate of the endpoint of the curve.</param>
		/// <param name="y4">The y-coordinate of the endpoint of the curve.</param>
		public void AddBezier(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathBezier(nativePath, x1, y1, x2, y2, x3, y3, x4, y4));
		}

		/// <summary>Adds a sequence of connected cubic Bzier curves to the current figure.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that define the curves.</param>
		public void AddBeziers(params Point[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathBeziersI(nativePath, points, points.Length));
		}

		/// <summary>Adds a sequence of connected cubic Bzier curves to the current figure.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that define the curves.</param>
		public void AddBeziers(PointF[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathBeziers(nativePath, points, points.Length));
		}

		/// <summary>Adds an ellipse to the current path.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> that represents the bounding rectangle that defines the ellipse.</param>
		public void AddEllipse(RectangleF rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathEllipse(nativePath, rect.X, rect.Y, rect.Width, rect.Height));
		}

		/// <summary>Adds an ellipse to the current path.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="width">The width of the bounding rectangle that defines the ellipse.</param>
		/// <param name="height">The height of the bounding rectangle that defines the ellipse.</param>
		public void AddEllipse(float x, float y, float width, float height)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathEllipse(nativePath, x, y, width, height));
		}

		/// <summary>Adds an ellipse to the current path.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> that represents the bounding rectangle that defines the ellipse.</param>
		public void AddEllipse(Rectangle rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathEllipseI(nativePath, rect.X, rect.Y, rect.Width, rect.Height));
		}

		/// <summary>Adds an ellipse to the current path.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="width">The width of the bounding rectangle that defines the ellipse.</param>
		/// <param name="height">The height of the bounding rectangle that defines the ellipse.</param>
		public void AddEllipse(int x, int y, int width, int height)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathEllipseI(nativePath, x, y, width, height));
		}

		/// <summary>Appends a line segment to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="pt1">A <see cref="T:System.Drawing.Point" /> that represents the starting point of the line.</param>
		/// <param name="pt2">A <see cref="T:System.Drawing.Point" /> that represents the endpoint of the line.</param>
		public void AddLine(Point pt1, Point pt2)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathLineI(nativePath, pt1.X, pt1.Y, pt2.X, pt2.Y));
		}

		/// <summary>Appends a line segment to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="pt1">A <see cref="T:System.Drawing.PointF" /> that represents the starting point of the line.</param>
		/// <param name="pt2">A <see cref="T:System.Drawing.PointF" /> that represents the endpoint of the line.</param>
		public void AddLine(PointF pt1, PointF pt2)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathLine(nativePath, pt1.X, pt1.Y, pt2.X, pt2.Y));
		}

		/// <summary>Appends a line segment to the current figure.</summary>
		/// <param name="x1">The x-coordinate of the starting point of the line.</param>
		/// <param name="y1">The y-coordinate of the starting point of the line.</param>
		/// <param name="x2">The x-coordinate of the endpoint of the line.</param>
		/// <param name="y2">The y-coordinate of the endpoint of the line.</param>
		public void AddLine(int x1, int y1, int x2, int y2)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathLineI(nativePath, x1, y1, x2, y2));
		}

		/// <summary>Appends a line segment to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="x1">The x-coordinate of the starting point of the line.</param>
		/// <param name="y1">The y-coordinate of the starting point of the line.</param>
		/// <param name="x2">The x-coordinate of the endpoint of the line.</param>
		/// <param name="y2">The y-coordinate of the endpoint of the line.</param>
		public void AddLine(float x1, float y1, float x2, float y2)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathLine(nativePath, x1, y1, x2, y2));
		}

		/// <summary>Appends a series of connected line segments to the end of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that define the line segments to add.</param>
		public void AddLines(Point[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			if (points.Length == 0)
			{
				throw new ArgumentException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathLine2I(nativePath, points, points.Length));
		}

		/// <summary>Appends a series of connected line segments to the end of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that define the line segments to add.</param>
		public void AddLines(PointF[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			if (points.Length == 0)
			{
				throw new ArgumentException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathLine2(nativePath, points, points.Length));
		}

		/// <summary>Adds the outline of a pie shape to this path.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> that represents the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="startAngle">The starting angle for the pie section, measured in degrees clockwise from the x-axis.</param>
		/// <param name="sweepAngle">The angle between <paramref name="startAngle" /> and the end of the pie section, measured in degrees clockwise from <paramref name="startAngle" />.</param>
		public void AddPie(Rectangle rect, float startAngle, float sweepAngle)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathPie(nativePath, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle));
		}

		/// <summary>Adds the outline of a pie shape to this path.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="width">The width of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="height">The height of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="startAngle">The starting angle for the pie section, measured in degrees clockwise from the x-axis.</param>
		/// <param name="sweepAngle">The angle between <paramref name="startAngle" /> and the end of the pie section, measured in degrees clockwise from <paramref name="startAngle" />.</param>
		public void AddPie(int x, int y, int width, int height, float startAngle, float sweepAngle)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathPieI(nativePath, x, y, width, height, startAngle, sweepAngle));
		}

		/// <summary>Adds the outline of a pie shape to this path.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="width">The width of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="height">The height of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="startAngle">The starting angle for the pie section, measured in degrees clockwise from the x-axis.</param>
		/// <param name="sweepAngle">The angle between <paramref name="startAngle" /> and the end of the pie section, measured in degrees clockwise from <paramref name="startAngle" />.</param>
		public void AddPie(float x, float y, float width, float height, float startAngle, float sweepAngle)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathPie(nativePath, x, y, width, height, startAngle, sweepAngle));
		}

		/// <summary>Adds a polygon to this path.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that defines the polygon to add.</param>
		public void AddPolygon(Point[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathPolygonI(nativePath, points, points.Length));
		}

		/// <summary>Adds a polygon to this path.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that defines the polygon to add.</param>
		public void AddPolygon(PointF[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathPolygon(nativePath, points, points.Length));
		}

		/// <summary>Adds a rectangle to this path.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle to add.</param>
		public void AddRectangle(Rectangle rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathRectangleI(nativePath, rect.X, rect.Y, rect.Width, rect.Height));
		}

		/// <summary>Adds a rectangle to this path.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle to add.</param>
		public void AddRectangle(RectangleF rect)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathRectangle(nativePath, rect.X, rect.Y, rect.Width, rect.Height));
		}

		/// <summary>Adds a series of rectangles to this path.</summary>
		/// <param name="rects">An array of <see cref="T:System.Drawing.Rectangle" /> structures that represents the rectangles to add.</param>
		public void AddRectangles(Rectangle[] rects)
		{
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			if (rects.Length == 0)
			{
				throw new ArgumentException("rects");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathRectanglesI(nativePath, rects, rects.Length));
		}

		/// <summary>Adds a series of rectangles to this path.</summary>
		/// <param name="rects">An array of <see cref="T:System.Drawing.RectangleF" /> structures that represents the rectangles to add.</param>
		public void AddRectangles(RectangleF[] rects)
		{
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			if (rects.Length == 0)
			{
				throw new ArgumentException("rects");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathRectangles(nativePath, rects, rects.Length));
		}

		/// <summary>Appends the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to this path.</summary>
		/// <param name="addingPath">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to add.</param>
		/// <param name="connect">A Boolean value that specifies whether the first figure in the added path is part of the last figure in this path. A value of <see langword="true" /> specifies that (if possible) the first figure in the added path is part of the last figure in this path. A value of <see langword="false" /> specifies that the first figure in the added path is separate from the last figure in this path.</param>
		public void AddPath(GraphicsPath addingPath, bool connect)
		{
			if (addingPath == null)
			{
				throw new ArgumentNullException("addingPath");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathPath(nativePath, addingPath.nativePath, connect));
		}

		/// <summary>Gets the last point in the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> array of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.PointF" /> that represents the last point in this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
		public PointF GetLastPoint()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipGetPathLastPoint(nativePath, out var lastPoint));
			return lastPoint;
		}

		/// <summary>Adds a closed curve to this path. A cardinal spline curve is used because the curve travels through each of the points in the array.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that define the curve.</param>
		public void AddClosedCurve(Point[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathClosedCurveI(nativePath, points, points.Length));
		}

		/// <summary>Adds a closed curve to this path. A cardinal spline curve is used because the curve travels through each of the points in the array.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that define the curve.</param>
		public void AddClosedCurve(PointF[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathClosedCurve(nativePath, points, points.Length));
		}

		/// <summary>Adds a closed curve to this path. A cardinal spline curve is used because the curve travels through each of the points in the array.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that define the curve.</param>
		/// <param name="tension">A value between from 0 through 1 that specifies the amount that the curve bends between points, with 0 being the smallest curve (sharpest corner) and 1 being the smoothest curve.</param>
		public void AddClosedCurve(Point[] points, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathClosedCurve2I(nativePath, points, points.Length, tension));
		}

		/// <summary>Adds a closed curve to this path. A cardinal spline curve is used because the curve travels through each of the points in the array.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that define the curve.</param>
		/// <param name="tension">A value between from 0 through 1 that specifies the amount that the curve bends between points, with 0 being the smallest curve (sharpest corner) and 1 being the smoothest curve.</param>
		public void AddClosedCurve(PointF[] points, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathClosedCurve2(nativePath, points, points.Length, tension));
		}

		/// <summary>Adds a spline curve to the current figure. A cardinal spline curve is used because the curve travels through each of the points in the array.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that define the curve.</param>
		public void AddCurve(Point[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathCurveI(nativePath, points, points.Length));
		}

		/// <summary>Adds a spline curve to the current figure. A cardinal spline curve is used because the curve travels through each of the points in the array.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that define the curve.</param>
		public void AddCurve(PointF[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathCurve(nativePath, points, points.Length));
		}

		/// <summary>Adds a spline curve to the current figure.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that define the curve.</param>
		/// <param name="tension">A value that specifies the amount that the curve bends between control points. Values greater than 1 produce unpredictable results.</param>
		public void AddCurve(Point[] points, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathCurve2I(nativePath, points, points.Length, tension));
		}

		/// <summary>Adds a spline curve to the current figure.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that define the curve.</param>
		/// <param name="tension">A value that specifies the amount that the curve bends between control points. Values greater than 1 produce unpredictable results.</param>
		public void AddCurve(PointF[] points, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathCurve2(nativePath, points, points.Length, tension));
		}

		/// <summary>Adds a spline curve to the current figure.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that define the curve.</param>
		/// <param name="offset">The index of the element in the <paramref name="points" /> array that is used as the first point in the curve.</param>
		/// <param name="numberOfSegments">A value that specifies the amount that the curve bends between control points. Values greater than 1 produce unpredictable results.</param>
		/// <param name="tension">A value that specifies the amount that the curve bends between control points. Values greater than 1 produce unpredictable results.</param>
		public void AddCurve(Point[] points, int offset, int numberOfSegments, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathCurve3I(nativePath, points, points.Length, offset, numberOfSegments, tension));
		}

		/// <summary>Adds a spline curve to the current figure.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that define the curve.</param>
		/// <param name="offset">The index of the element in the <paramref name="points" /> array that is used as the first point in the curve.</param>
		/// <param name="numberOfSegments">The number of segments used to draw the curve. A segment can be thought of as a line connecting two points.</param>
		/// <param name="tension">A value that specifies the amount that the curve bends between control points. Values greater than 1 produce unpredictable results.</param>
		public void AddCurve(PointF[] points, int offset, int numberOfSegments, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathCurve3(nativePath, points, points.Length, offset, numberOfSegments, tension));
		}

		/// <summary>Empties the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> and <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> arrays and sets the <see cref="T:System.Drawing.Drawing2D.FillMode" /> to <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
		public void Reset()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipResetPath(nativePath));
		}

		/// <summary>Reverses the order of points in the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> array of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		public void Reverse()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipReversePath(nativePath));
		}

		/// <summary>Applies a transform matrix to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> that represents the transformation to apply.</param>
		public void Transform(Matrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipTransformPath(nativePath, matrix.nativeMatrix));
		}

		/// <summary>Adds a text string to this path.</summary>
		/// <param name="s">The <see cref="T:System.String" /> to add.</param>
		/// <param name="family">A <see cref="T:System.Drawing.FontFamily" /> that represents the name of the font with which the test is drawn.</param>
		/// <param name="style">A <see cref="T:System.Drawing.FontStyle" /> enumeration that represents style information about the text (bold, italic, and so on). This must be cast as an integer (see the example code later in this section).</param>
		/// <param name="emSize">The height of the em square box that bounds the character.</param>
		/// <param name="origin">A <see cref="T:System.Drawing.Point" /> that represents the point where the text starts.</param>
		/// <param name="format">A <see cref="T:System.Drawing.StringFormat" /> that specifies text formatting information, such as line spacing and alignment.</param>
		[System.MonoTODO("The StringFormat parameter is ignored when using libgdiplus.")]
		public void AddString(string s, FontFamily family, int style, float emSize, Point origin, StringFormat format)
		{
			AddString(s, family, style, emSize, new Rectangle
			{
				X = origin.X,
				Y = origin.Y
			}, format);
		}

		/// <summary>Adds a text string to this path.</summary>
		/// <param name="s">The <see cref="T:System.String" /> to add.</param>
		/// <param name="family">A <see cref="T:System.Drawing.FontFamily" /> that represents the name of the font with which the test is drawn.</param>
		/// <param name="style">A <see cref="T:System.Drawing.FontStyle" /> enumeration that represents style information about the text (bold, italic, and so on). This must be cast as an integer (see the example code later in this section).</param>
		/// <param name="emSize">The height of the em square box that bounds the character.</param>
		/// <param name="origin">A <see cref="T:System.Drawing.PointF" /> that represents the point where the text starts.</param>
		/// <param name="format">A <see cref="T:System.Drawing.StringFormat" /> that specifies text formatting information, such as line spacing and alignment.</param>
		[System.MonoTODO("The StringFormat parameter is ignored when using libgdiplus.")]
		public void AddString(string s, FontFamily family, int style, float emSize, PointF origin, StringFormat format)
		{
			AddString(s, family, style, emSize, new RectangleF
			{
				X = origin.X,
				Y = origin.Y
			}, format);
		}

		/// <summary>Adds a text string to this path.</summary>
		/// <param name="s">The <see cref="T:System.String" /> to add.</param>
		/// <param name="family">A <see cref="T:System.Drawing.FontFamily" /> that represents the name of the font with which the test is drawn.</param>
		/// <param name="style">A <see cref="T:System.Drawing.FontStyle" /> enumeration that represents style information about the text (bold, italic, and so on). This must be cast as an integer (see the example code later in this section).</param>
		/// <param name="emSize">The height of the em square box that bounds the character.</param>
		/// <param name="layoutRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the text.</param>
		/// <param name="format">A <see cref="T:System.Drawing.StringFormat" /> that specifies text formatting information, such as line spacing and alignment.</param>
		[System.MonoTODO("The layoutRect and StringFormat parameters are ignored when using libgdiplus.")]
		public void AddString(string s, FontFamily family, int style, float emSize, Rectangle layoutRect, StringFormat format)
		{
			if (family == null)
			{
				throw new ArgumentException("family");
			}
			IntPtr format2 = format?.NativeObject ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathStringI(nativePath, s, s.Length, family.NativeFamily, style, emSize, ref layoutRect, format2));
		}

		/// <summary>Adds a text string to this path.</summary>
		/// <param name="s">The <see cref="T:System.String" /> to add.</param>
		/// <param name="family">A <see cref="T:System.Drawing.FontFamily" /> that represents the name of the font with which the test is drawn.</param>
		/// <param name="style">A <see cref="T:System.Drawing.FontStyle" /> enumeration that represents style information about the text (bold, italic, and so on). This must be cast as an integer (see the example code later in this section).</param>
		/// <param name="emSize">The height of the em square box that bounds the character.</param>
		/// <param name="layoutRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the text.</param>
		/// <param name="format">A <see cref="T:System.Drawing.StringFormat" /> that specifies text formatting information, such as line spacing and alignment.</param>
		[System.MonoTODO("The layoutRect and StringFormat parameters are ignored when using libgdiplus.")]
		public void AddString(string s, FontFamily family, int style, float emSize, RectangleF layoutRect, StringFormat format)
		{
			if (family == null)
			{
				throw new ArgumentException("family");
			}
			IntPtr format2 = format?.NativeObject ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipAddPathString(nativePath, s, s.Length, family.NativeFamily, style, emSize, ref layoutRect, format2));
		}

		/// <summary>Clears all markers from this path.</summary>
		public void ClearMarkers()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipClearPathMarkers(nativePath));
		}

		/// <summary>Closes all open figures in this path and starts a new figure. It closes each open figure by connecting a line from its endpoint to its starting point.</summary>
		public void CloseAllFigures()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipClosePathFigures(nativePath));
		}

		/// <summary>Closes the current figure and starts a new figure. If the current figure contains a sequence of connected lines and curves, the method closes the loop by connecting a line from the endpoint to the starting point.</summary>
		public void CloseFigure()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipClosePathFigure(nativePath));
		}

		/// <summary>Converts each curve in this path into a sequence of connected line segments.</summary>
		public void Flatten()
		{
			Flatten(null, 0.25f);
		}

		/// <summary>Applies the specified transform and then converts each curve in this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> into a sequence of connected line segments.</summary>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which to transform this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> before flattening.</param>
		public void Flatten(Matrix matrix)
		{
			Flatten(matrix, 0.25f);
		}

		/// <summary>Converts each curve in this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> into a sequence of connected line segments.</summary>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which to transform this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> before flattening.</param>
		/// <param name="flatness">Specifies the maximum permitted error between the curve and its flattened approximation. A value of 0.25 is the default. Reducing the flatness value will increase the number of line segments in the approximation.</param>
		public void Flatten(Matrix matrix, float flatness)
		{
			IntPtr matrix2 = matrix?.nativeMatrix ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipFlattenPath(nativePath, matrix2, flatness));
		}

		/// <summary>Returns a rectangle that bounds this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> that represents a rectangle that bounds this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
		public RectangleF GetBounds()
		{
			return GetBounds(null, null);
		}

		/// <summary>Returns a rectangle that bounds this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when this path is transformed by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> that specifies a transformation to be applied to this path before the bounding rectangle is calculated. This path is not permanently transformed; the transformation is used only during the process of calculating the bounding rectangle.</param>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> that represents a rectangle that bounds this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
		public RectangleF GetBounds(Matrix matrix)
		{
			return GetBounds(matrix, null);
		}

		/// <summary>Returns a rectangle that bounds this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when the current path is transformed by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> and drawn with the specified <see cref="T:System.Drawing.Pen" />.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> that specifies a transformation to be applied to this path before the bounding rectangle is calculated. This path is not permanently transformed; the transformation is used only during the process of calculating the bounding rectangle.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> with which to draw the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> that represents a rectangle that bounds this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
		public RectangleF GetBounds(Matrix matrix, Pen pen)
		{
			IntPtr matrix2 = matrix?.nativeMatrix ?? IntPtr.Zero;
			IntPtr pen2 = pen?.NativePen ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipGetPathWorldBounds(nativePath, out var bounds, matrix2, pen2));
			return bounds;
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />.</summary>
		/// <param name="point">A <see cref="T:System.Drawing.Point" /> that specifies the location to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(Point point, Pen pen)
		{
			return IsOutlineVisible(point.X, point.Y, pen, null);
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />.</summary>
		/// <param name="point">A <see cref="T:System.Drawing.PointF" /> that specifies the location to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(PointF point, Pen pen)
		{
			return IsOutlineVisible(point.X, point.Y, pen, null);
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(int x, int y, Pen pen)
		{
			return IsOutlineVisible(x, y, pen, null);
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(float x, float y, Pen pen)
		{
			return IsOutlineVisible(x, y, pen, null);
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" /> and using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="pt">A <see cref="T:System.Drawing.Point" /> that specifies the location to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> as drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(Point pt, Pen pen, Graphics graphics)
		{
			return IsOutlineVisible(pt.X, pt.Y, pen, graphics);
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" /> and using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="pt">A <see cref="T:System.Drawing.PointF" /> that specifies the location to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> as drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(PointF pt, Pen pen, Graphics graphics)
		{
			return IsOutlineVisible(pt.X, pt.Y, pen, graphics);
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" /> and using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> as drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(int x, int y, Pen pen, Graphics graphics)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			IntPtr graphics2 = graphics?.nativeObject ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipIsOutlineVisiblePathPointI(nativePath, x, y, pen.NativePen, graphics2, out var result));
			return result;
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" /> and using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> as drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(float x, float y, Pen pen, Graphics graphics)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			IntPtr graphics2 = graphics?.nativeObject ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipIsOutlineVisiblePathPoint(nativePath, x, y, pen.NativePen, graphics2, out var result));
			return result;
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="point">A <see cref="T:System.Drawing.Point" /> that represents the point to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Point point)
		{
			return IsVisible(point.X, point.Y, null);
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="point">A <see cref="T:System.Drawing.PointF" /> that represents the point to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(PointF point)
		{
			return IsVisible(point.X, point.Y, null);
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(int x, int y)
		{
			return IsVisible(x, y, null);
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y)
		{
			return IsVisible(x, y, null);
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="pt">A <see cref="T:System.Drawing.Point" /> that represents the point to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Point pt, Graphics graphics)
		{
			return IsVisible(pt.X, pt.Y, graphics);
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="pt">A <see cref="T:System.Drawing.PointF" /> that represents the point to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(PointF pt, Graphics graphics)
		{
			return IsVisible(pt.X, pt.Y, graphics);
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />, using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(int x, int y, Graphics graphics)
		{
			IntPtr graphics2 = graphics?.nativeObject ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisiblePathPointI(nativePath, x, y, graphics2, out var result));
			return result;
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> in the visible clip region of the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y, Graphics graphics)
		{
			IntPtr graphics2 = graphics?.nativeObject ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipIsVisiblePathPoint(nativePath, x, y, graphics2, out var result));
			return result;
		}

		/// <summary>Sets a marker on this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		public void SetMarkers()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipSetPathMarker(nativePath));
		}

		/// <summary>Starts a new figure without closing the current figure. All subsequent points added to the path are added to this new figure.</summary>
		public void StartFigure()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipStartPathFigure(nativePath));
		}

		/// <summary>Applies a warp transform, defined by a rectangle and a parallelogram, to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="destPoints">An array of <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram to which the rectangle defined by <paramref name="srcRect" /> is transformed. The array can contain either three or four elements. If the array contains three elements, the lower-right corner of the parallelogram is implied by the first three points.</param>
		/// <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that is transformed to the parallelogram defined by <paramref name="destPoints" />.</param>
		[System.MonoTODO("GdipWarpPath isn't implemented in libgdiplus")]
		public void Warp(PointF[] destPoints, RectangleF srcRect)
		{
			Warp(destPoints, srcRect, null, WarpMode.Perspective, 0.25f);
		}

		/// <summary>Applies a warp transform, defined by a rectangle and a parallelogram, to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="destPoints">An array of <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram to which the rectangle defined by <paramref name="srcRect" /> is transformed. The array can contain either three or four elements. If the array contains three elements, the lower-right corner of the parallelogram is implied by the first three points.</param>
		/// <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that is transformed to the parallelogram defined by <paramref name="destPoints" />.</param>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> that specifies a geometric transform to apply to the path.</param>
		[System.MonoTODO("GdipWarpPath isn't implemented in libgdiplus")]
		public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix)
		{
			Warp(destPoints, srcRect, matrix, WarpMode.Perspective, 0.25f);
		}

		/// <summary>Applies a warp transform, defined by a rectangle and a parallelogram, to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="destPoints">An array of <see cref="T:System.Drawing.PointF" /> structures that defines a parallelogram to which the rectangle defined by <paramref name="srcRect" /> is transformed. The array can contain either three or four elements. If the array contains three elements, the lower-right corner of the parallelogram is implied by the first three points.</param>
		/// <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that is transformed to the parallelogram defined by <paramref name="destPoints" />.</param>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> that specifies a geometric transform to apply to the path.</param>
		/// <param name="warpMode">A <see cref="T:System.Drawing.Drawing2D.WarpMode" /> enumeration that specifies whether this warp operation uses perspective or bilinear mode.</param>
		[System.MonoTODO("GdipWarpPath isn't implemented in libgdiplus")]
		public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix, WarpMode warpMode)
		{
			Warp(destPoints, srcRect, matrix, warpMode, 0.25f);
		}

		/// <summary>Applies a warp transform, defined by a rectangle and a parallelogram, to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="destPoints">An array of <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram to which the rectangle defined by <paramref name="srcRect" /> is transformed. The array can contain either three or four elements. If the array contains three elements, the lower-right corner of the parallelogram is implied by the first three points.</param>
		/// <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that is transformed to the parallelogram defined by <paramref name="destPoints" />.</param>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> that specifies a geometric transform to apply to the path.</param>
		/// <param name="warpMode">A <see cref="T:System.Drawing.Drawing2D.WarpMode" /> enumeration that specifies whether this warp operation uses perspective or bilinear mode.</param>
		/// <param name="flatness">A value from 0 through 1 that specifies how flat the resulting path is. For more information, see the <see cref="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" /> methods.</param>
		[System.MonoTODO("GdipWarpPath isn't implemented in libgdiplus")]
		public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix, WarpMode warpMode, float flatness)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			IntPtr matrix2 = matrix?.nativeMatrix ?? IntPtr.Zero;
			GDIPlus.CheckStatus(GDIPlus.GdipWarpPath(nativePath, matrix2, destPoints, destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, warpMode, flatness));
		}

		/// <summary>Adds an additional outline to the path.</summary>
		/// <param name="pen">A <see cref="T:System.Drawing.Pen" /> that specifies the width between the original outline of the path and the new outline this method creates.</param>
		[System.MonoTODO("GdipWidenPath isn't implemented in libgdiplus")]
		public void Widen(Pen pen)
		{
			Widen(pen, null, 0.25f);
		}

		/// <summary>Adds an additional outline to the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="pen">A <see cref="T:System.Drawing.Pen" /> that specifies the width between the original outline of the path and the new outline this method creates.</param>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> that specifies a transform to apply to the path before widening.</param>
		[System.MonoTODO("GdipWidenPath isn't implemented in libgdiplus")]
		public void Widen(Pen pen, Matrix matrix)
		{
			Widen(pen, matrix, 0.25f);
		}

		/// <summary>Replaces this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> with curves that enclose the area that is filled when this path is drawn by the specified pen.</summary>
		/// <param name="pen">A <see cref="T:System.Drawing.Pen" /> that specifies the width between the original outline of the path and the new outline this method creates.</param>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> that specifies a transform to apply to the path before widening.</param>
		/// <param name="flatness">A value that specifies the flatness for curves.</param>
		[System.MonoTODO("GdipWidenPath isn't implemented in libgdiplus")]
		public void Widen(Pen pen, Matrix matrix, float flatness)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (PointCount != 0)
			{
				IntPtr matrix2 = matrix?.nativeMatrix ?? IntPtr.Zero;
				GDIPlus.CheckStatus(GDIPlus.GdipWidenPath(nativePath, pen.NativePen, matrix2, flatness));
			}
		}
	}
	/// <summary>Encapsulates a <see cref="T:System.Drawing.Brush" /> with a linear gradient. This class cannot be inherited.</summary>
	public sealed class LinearGradientBrush : Brush
	{
		private RectangleF rectangle;

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.Blend" /> that specifies positions and factors that define a custom falloff for the gradient.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.Blend" /> that represents a custom falloff for the gradient.</returns>
		public Blend Blend
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetLineBlendCount(base.NativeBrush, out var count));
				float[] array = new float[count];
				float[] positions = new float[count];
				GDIPlus.CheckStatus(GDIPlus.GdipGetLineBlend(base.NativeBrush, array, positions, count));
				return new Blend
				{
					Factors = array,
					Positions = positions
				};
			}
			set
			{
				float[] factors = value.Factors;
				float[] positions = value.Positions;
				int num = factors.Length;
				if (num == 0 || positions.Length == 0)
				{
					throw new ArgumentException("Invalid Blend object. It should have at least 2 elements in each of the factors and positions arrays.");
				}
				if (num != positions.Length)
				{
					throw new ArgumentException("Invalid Blend object. It should contain the same number of factors and positions values.");
				}
				if (positions[0] != 0f)
				{
					throw new ArgumentException("Invalid Blend object. The positions array must have 0.0 as its first element.");
				}
				if (positions[num - 1] != 1f)
				{
					throw new ArgumentException("Invalid Blend object. The positions array must have 1.0 as its last element.");
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetLineBlend(base.NativeBrush, factors, positions, num));
			}
		}

		/// <summary>Gets or sets a value indicating whether gamma correction is enabled for this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />.</summary>
		/// <returns>The value is <see langword="true" /> if gamma correction is enabled for this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />; otherwise, <see langword="false" />.</returns>
		[System.MonoTODO("The GammaCorrection value is ignored when using libgdiplus.")]
		public bool GammaCorrection
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetLineGammaCorrection(base.NativeBrush, out var useGammaCorrection));
				return useGammaCorrection;
			}
			set
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetLineGammaCorrection(base.NativeBrush, value));
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.ColorBlend" /> that defines a multicolor linear gradient.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.ColorBlend" /> that defines a multicolor linear gradient.</returns>
		public ColorBlend InterpolationColors
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetLinePresetBlendCount(base.NativeBrush, out var count));
				int[] array = new int[count];
				float[] positions = new float[count];
				GDIPlus.CheckStatus(GDIPlus.GdipGetLinePresetBlend(base.NativeBrush, array, positions, count));
				ColorBlend colorBlend = new ColorBlend();
				Color[] array2 = new Color[count];
				for (int i = 0; i < count; i++)
				{
					array2[i] = Color.FromArgb(array[i]);
				}
				colorBlend.Colors = array2;
				colorBlend.Positions = positions;
				return colorBlend;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentException("InterpolationColors is null");
				}
				Color[] colors = value.Colors;
				float[] positions = value.Positions;
				int num = colors.Length;
				if (num == 0 || positions.Length == 0)
				{
					throw new ArgumentException("Invalid ColorBlend object. It should have at least 2 elements in each of the colors and positions arrays.");
				}
				if (num != positions.Length)
				{
					throw new ArgumentException("Invalid ColorBlend object. It should contain the same number of positions and color values.");
				}
				if (positions[0] != 0f)
				{
					throw new ArgumentException("Invalid ColorBlend object. The positions array must have 0.0 as its first element.");
				}
				if (positions[num - 1] != 1f)
				{
					throw new ArgumentException("Invalid ColorBlend object. The positions array must have 1.0 as its last element.");
				}
				int[] array = new int[colors.Length];
				for (int i = 0; i < colors.Length; i++)
				{
					array[i] = colors[i].ToArgb();
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetLinePresetBlend(base.NativeBrush, array, positions, num));
			}
		}

		/// <summary>Gets or sets the starting and ending colors of the gradient.</summary>
		/// <returns>An array of two <see cref="T:System.Drawing.Color" /> structures that represents the starting and ending colors of the gradient.</returns>
		public Color[] LinearColors
		{
			get
			{
				int[] array = new int[2];
				GDIPlus.CheckStatus(GDIPlus.GdipGetLineColors(base.NativeBrush, array));
				return new Color[2]
				{
					Color.FromArgb(array[0]),
					Color.FromArgb(array[1])
				};
			}
			set
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetLineColors(base.NativeBrush, value[0].ToArgb(), value[1].ToArgb()));
			}
		}

		/// <summary>Gets a rectangular region that defines the starting and ending points of the gradient.</summary>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> structure that specifies the starting and ending points of the gradient.</returns>
		public RectangleF Rectangle => rectangle;

		/// <summary>Gets or sets a copy <see cref="T:System.Drawing.Drawing2D.Matrix" /> that defines a local geometric transform for this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />.</summary>
		/// <returns>A copy of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> that defines a geometric transform that applies only to fills drawn with this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />.</returns>
		public Matrix Transform
		{
			get
			{
				Matrix matrix = new Matrix();
				GDIPlus.CheckStatus(GDIPlus.GdipGetLineTransform(base.NativeBrush, matrix.nativeMatrix));
				return matrix;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("Transform");
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetLineTransform(base.NativeBrush, value.nativeMatrix));
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.WrapMode" /> enumeration that indicates the wrap mode for this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that specifies how fills drawn with this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> are tiled.</returns>
		public WrapMode WrapMode
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetLineWrapMode(base.NativeBrush, out var wrapMode));
				return wrapMode;
			}
			set
			{
				if (value < WrapMode.Tile || value > WrapMode.Clamp)
				{
					throw new InvalidEnumArgumentException("WrapMode");
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetLineWrapMode(base.NativeBrush, value));
			}
		}

		internal LinearGradientBrush(IntPtr native)
		{
			Status status = GDIPlus.GdipGetLineRect(native, out rectangle);
			SetNativeBrush(native);
			GDIPlus.CheckStatus(status);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> class with the specified points and colors.</summary>
		/// <param name="point1">A <see cref="T:System.Drawing.Point" /> structure that represents the starting point of the linear gradient.</param>
		/// <param name="point2">A <see cref="T:System.Drawing.Point" /> structure that represents the endpoint of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color of the linear gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color of the linear gradient.</param>
		public LinearGradientBrush(Point point1, Point point2, Color color1, Color color2)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateLineBrushI(ref point1, ref point2, color1.ToArgb(), color2.ToArgb(), WrapMode.Tile, out var brush));
			SetNativeBrush(brush);
			GDIPlus.CheckStatus(GDIPlus.GdipGetLineRect(brush, out rectangle));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> class with the specified points and colors.</summary>
		/// <param name="point1">A <see cref="T:System.Drawing.PointF" /> structure that represents the starting point of the linear gradient.</param>
		/// <param name="point2">A <see cref="T:System.Drawing.PointF" /> structure that represents the endpoint of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color of the linear gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color of the linear gradient.</param>
		public LinearGradientBrush(PointF point1, PointF point2, Color color1, Color color2)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateLineBrush(ref point1, ref point2, color1.ToArgb(), color2.ToArgb(), WrapMode.Tile, out var brush));
			SetNativeBrush(brush);
			GDIPlus.CheckStatus(GDIPlus.GdipGetLineRect(brush, out rectangle));
		}

		/// <summary>Creates a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> class based on a rectangle, starting and ending colors, and orientation.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> structure that specifies the bounds of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color for the gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color for the gradient.</param>
		/// <param name="linearGradientMode">A <see cref="T:System.Drawing.Drawing2D.LinearGradientMode" /> enumeration element that specifies the orientation of the gradient. The orientation determines the starting and ending points of the gradient. For example, <see langword="LinearGradientMode.ForwardDiagonal" /> specifies that the starting point is the upper-left corner of the rectangle and the ending point is the lower-right corner of the rectangle.</param>
		public LinearGradientBrush(Rectangle rect, Color color1, Color color2, LinearGradientMode linearGradientMode)
		{
			if (linearGradientMode < LinearGradientMode.Horizontal || linearGradientMode > LinearGradientMode.BackwardDiagonal)
			{
				throw new InvalidEnumArgumentException("linearGradientMode", (int)linearGradientMode, typeof(LinearGradientMode));
			}
			if (rect.Width == 0 || rect.Height == 0)
			{
				throw new ArgumentException($"Rectangle '{rect.ToString()}' cannot have a width or height equal to 0.");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreateLineBrushFromRectI(ref rect, color1.ToArgb(), color2.ToArgb(), linearGradientMode, WrapMode.Tile, out var brush));
			SetNativeBrush(brush);
			rectangle = rect;
		}

		/// <summary>Creates a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> class based on a rectangle, starting and ending colors, and an orientation angle.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> structure that specifies the bounds of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color for the gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color for the gradient.</param>
		/// <param name="angle">The angle, measured in degrees clockwise from the x-axis, of the gradient's orientation line.</param>
		public LinearGradientBrush(Rectangle rect, Color color1, Color color2, float angle)
			: this(rect, color1, color2, angle, isAngleScaleable: false)
		{
		}

		/// <summary>Creates a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> based on a rectangle, starting and ending colors, and an orientation mode.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> structure that specifies the bounds of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color for the gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color for the gradient.</param>
		/// <param name="linearGradientMode">A <see cref="T:System.Drawing.Drawing2D.LinearGradientMode" /> enumeration element that specifies the orientation of the gradient. The orientation determines the starting and ending points of the gradient. For example, <see langword="LinearGradientMode.ForwardDiagonal" /> specifies that the starting point is the upper-left corner of the rectangle and the ending point is the lower-right corner of the rectangle.</param>
		public LinearGradientBrush(RectangleF rect, Color color1, Color color2, LinearGradientMode linearGradientMode)
		{
			if (linearGradientMode < LinearGradientMode.Horizontal || linearGradientMode > LinearGradientMode.BackwardDiagonal)
			{
				throw new InvalidEnumArgumentException("linearGradientMode", (int)linearGradientMode, typeof(LinearGradientMode));
			}
			if ((double)rect.Width == 0.0 || (double)rect.Height == 0.0)
			{
				throw new ArgumentException($"Rectangle '{rect.ToString()}' cannot have a width or height equal to 0.");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreateLineBrushFromRect(ref rect, color1.ToArgb(), color2.ToArgb(), linearGradientMode, WrapMode.Tile, out var brush));
			SetNativeBrush(brush);
			rectangle = rect;
		}

		/// <summary>Creates a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> class based on a rectangle, starting and ending colors, and an orientation angle.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> structure that specifies the bounds of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color for the gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color for the gradient.</param>
		/// <param name="angle">The angle, measured in degrees clockwise from the x-axis, of the gradient's orientation line.</param>
		public LinearGradientBrush(RectangleF rect, Color color1, Color color2, float angle)
			: this(rect, color1, color2, angle, isAngleScaleable: false)
		{
		}

		/// <summary>Creates a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> class based on a rectangle, starting and ending colors, and an orientation angle.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> structure that specifies the bounds of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color for the gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color for the gradient.</param>
		/// <param name="angle">The angle, measured in degrees clockwise from the x-axis, of the gradient's orientation line.</param>
		/// <param name="isAngleScaleable">Set to <see langword="true" /> to specify that the angle is affected by the transform associated with this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />; otherwise, <see langword="false" />.</param>
		public LinearGradientBrush(Rectangle rect, Color color1, Color color2, float angle, bool isAngleScaleable)
		{
			if (rect.Width == 0 || rect.Height == 0)
			{
				throw new ArgumentException($"Rectangle '{rect.ToString()}' cannot have a width or height equal to 0.");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreateLineBrushFromRectWithAngleI(ref rect, color1.ToArgb(), color2.ToArgb(), angle, isAngleScaleable, WrapMode.Tile, out var brush));
			SetNativeBrush(brush);
			rectangle = rect;
		}

		/// <summary>Creates a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> class based on a rectangle, starting and ending colors, and an orientation angle.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> structure that specifies the bounds of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color for the gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color for the gradient.</param>
		/// <param name="angle">The angle, measured in degrees clockwise from the x-axis, of the gradient's orientation line.</param>
		/// <param name="isAngleScaleable">Set to <see langword="true" /> to specify that the angle is affected by the transform associated with this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />; otherwise, <see langword="false" />.</param>
		public LinearGradientBrush(RectangleF rect, Color color1, Color color2, float angle, bool isAngleScaleable)
		{
			if (rect.Width == 0f || rect.Height == 0f)
			{
				throw new ArgumentException($"Rectangle '{rect.ToString()}' cannot have a width or height equal to 0.");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreateLineBrushFromRectWithAngle(ref rect, color1.ToArgb(), color2.ToArgb(), angle, isAngleScaleable, WrapMode.Tile, out var brush));
			SetNativeBrush(brush);
			rectangle = rect;
		}

		/// <summary>Multiplies the <see cref="T:System.Drawing.Drawing2D.Matrix" /> that represents the local geometric transform of this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> by prepending the specified <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which to multiply the geometric transform.</param>
		public void MultiplyTransform(Matrix matrix)
		{
			MultiplyTransform(matrix, MatrixOrder.Prepend);
		}

		/// <summary>Multiplies the <see cref="T:System.Drawing.Drawing2D.Matrix" /> that represents the local geometric transform of this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the specified order.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which to multiply the geometric transform.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies in which order to multiply the two matrices.</param>
		public void MultiplyTransform(Matrix matrix, MatrixOrder order)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipMultiplyLineTransform(base.NativeBrush, matrix.nativeMatrix, order));
		}

		/// <summary>Resets the <see cref="P:System.Drawing.Drawing2D.LinearGradientBrush.Transform" /> property to identity.</summary>
		public void ResetTransform()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipResetLineTransform(base.NativeBrush));
		}

		/// <summary>Rotates the local geometric transform by the specified amount. This method prepends the rotation to the transform.</summary>
		/// <param name="angle">The angle of rotation.</param>
		public void RotateTransform(float angle)
		{
			RotateTransform(angle, MatrixOrder.Prepend);
		}

		/// <summary>Rotates the local geometric transform by the specified amount in the specified order.</summary>
		/// <param name="angle">The angle of rotation.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies whether to append or prepend the rotation matrix.</param>
		public void RotateTransform(float angle, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipRotateLineTransform(base.NativeBrush, angle, order));
		}

		/// <summary>Scales the local geometric transform by the specified amounts. This method prepends the scaling matrix to the transform.</summary>
		/// <param name="sx">The amount by which to scale the transform in the x-axis direction.</param>
		/// <param name="sy">The amount by which to scale the transform in the y-axis direction.</param>
		public void ScaleTransform(float sx, float sy)
		{
			ScaleTransform(sx, sy, MatrixOrder.Prepend);
		}

		/// <summary>Scales the local geometric transform by the specified amounts in the specified order.</summary>
		/// <param name="sx">The amount by which to scale the transform in the x-axis direction.</param>
		/// <param name="sy">The amount by which to scale the transform in the y-axis direction.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies whether to append or prepend the scaling matrix.</param>
		public void ScaleTransform(float sx, float sy, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipScaleLineTransform(base.NativeBrush, sx, sy, order));
		}

		/// <summary>Creates a linear gradient with a center color and a linear falloff to a single color on both ends.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies the center of the gradient (the point where the gradient is composed of only the ending color).</param>
		public void SetBlendTriangularShape(float focus)
		{
			SetBlendTriangularShape(focus, 1f);
		}

		/// <summary>Creates a linear gradient with a center color and a linear falloff to a single color on both ends.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies the center of the gradient (the point where the gradient is composed of only the ending color).</param>
		/// <param name="scale">A value from 0 through1 that specifies how fast the colors falloff from the starting color to <paramref name="focus" /> (ending color)</param>
		public void SetBlendTriangularShape(float focus, float scale)
		{
			if (focus < 0f || focus > 1f || scale < 0f || scale > 1f)
			{
				throw new ArgumentException("Invalid parameter passed.");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipSetLineLinearBlend(base.NativeBrush, focus, scale));
		}

		/// <summary>Creates a gradient falloff based on a bell-shaped curve.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies the center of the gradient (the point where the starting color and ending color are blended equally).</param>
		public void SetSigmaBellShape(float focus)
		{
			SetSigmaBellShape(focus, 1f);
		}

		/// <summary>Creates a gradient falloff based on a bell-shaped curve.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies the center of the gradient (the point where the gradient is composed of only the ending color).</param>
		/// <param name="scale">A value from 0 through 1 that specifies how fast the colors falloff from the <paramref name="focus" />.</param>
		public void SetSigmaBellShape(float focus, float scale)
		{
			if (focus < 0f || focus > 1f || scale < 0f || scale > 1f)
			{
				throw new ArgumentException("Invalid parameter passed.");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipSetLineSigmaBlend(base.NativeBrush, focus, scale));
		}

		/// <summary>Translates the local geometric transform by the specified dimensions. This method prepends the translation to the transform.</summary>
		/// <param name="dx">The value of the translation in x.</param>
		/// <param name="dy">The value of the translation in y.</param>
		public void TranslateTransform(float dx, float dy)
		{
			TranslateTransform(dx, dy, MatrixOrder.Prepend);
		}

		/// <summary>Translates the local geometric transform by the specified dimensions in the specified order.</summary>
		/// <param name="dx">The value of the translation in x.</param>
		/// <param name="dy">The value of the translation in y.</param>
		/// <param name="order">The order (prepend or append) in which to apply the translation.</param>
		public void TranslateTransform(float dx, float dy, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipTranslateLineTransform(base.NativeBrush, dx, dy, order));
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> this method creates, cast as an object.</returns>
		public override object Clone()
		{
			GDIPlus.CheckStatus((Status)GDIPlus.GdipCloneBrush(new HandleRef(this, base.NativeBrush), out var clonedBrush));
			return new LinearGradientBrush(clonedBrush);
		}
	}
	/// <summary>Encapsulates a 3-by-3 affine matrix that represents a geometric transform. This class cannot be inherited.</summary>
	public sealed class Matrix : MarshalByRefObject, IDisposable
	{
		internal IntPtr nativeMatrix;

		/// <summary>Gets an array of floating-point values that represents the elements of this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <returns>An array of floating-point values that represents the elements of this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</returns>
		public float[] Elements
		{
			get
			{
				float[] array = new float[6];
				IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(float)) * 6);
				try
				{
					GDIPlus.CheckStatus(GDIPlus.GdipGetMatrixElements(nativeMatrix, intPtr));
					Marshal.Copy(intPtr, array, 0, 6);
					return array;
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		/// <summary>Gets a value indicating whether this <see cref="T:System.Drawing.Drawing2D.Matrix" /> is the identity matrix.</summary>
		/// <returns>This property is <see langword="true" /> if this <see cref="T:System.Drawing.Drawing2D.Matrix" /> is identity; otherwise, <see langword="false" />.</returns>
		public bool IsIdentity
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipIsMatrixIdentity(nativeMatrix, out var result));
				return result;
			}
		}

		/// <summary>Gets a value indicating whether this <see cref="T:System.Drawing.Drawing2D.Matrix" /> is invertible.</summary>
		/// <returns>This property is <see langword="true" /> if this <see cref="T:System.Drawing.Drawing2D.Matrix" /> is invertible; otherwise, <see langword="false" />.</returns>
		public bool IsInvertible
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipIsMatrixInvertible(nativeMatrix, out var result));
				return result;
			}
		}

		/// <summary>Gets the x translation value (the dx value, or the element in the third row and first column) of this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <returns>The x translation value of this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</returns>
		public float OffsetX => Elements[4];

		/// <summary>Gets the y translation value (the dy value, or the element in the third row and second column) of this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <returns>The y translation value of this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</returns>
		public float OffsetY => Elements[5];

		internal IntPtr NativeObject
		{
			get
			{
				return nativeMatrix;
			}
			set
			{
				nativeMatrix = value;
			}
		}

		internal Matrix(IntPtr ptr)
		{
			nativeMatrix = ptr;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> class as the identity matrix.</summary>
		public Matrix()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateMatrix(out nativeMatrix));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> class to the geometric transform defined by the specified rectangle and array of points.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle to be transformed.</param>
		/// <param name="plgpts">An array of three <see cref="T:System.Drawing.Point" /> structures that represents the points of a parallelogram to which the upper-left, upper-right, and lower-left corners of the rectangle is to be transformed. The lower-right corner of the parallelogram is implied by the first three corners.</param>
		public Matrix(Rectangle rect, Point[] plgpts)
		{
			if (plgpts == null)
			{
				throw new ArgumentNullException("plgpts");
			}
			if (plgpts.Length != 3)
			{
				throw new ArgumentException("plgpts");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreateMatrix3I(ref rect, plgpts, out nativeMatrix));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> class to the geometric transform defined by the specified rectangle and array of points.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle to be transformed.</param>
		/// <param name="plgpts">An array of three <see cref="T:System.Drawing.PointF" /> structures that represents the points of a parallelogram to which the upper-left, upper-right, and lower-left corners of the rectangle is to be transformed. The lower-right corner of the parallelogram is implied by the first three corners.</param>
		public Matrix(RectangleF rect, PointF[] plgpts)
		{
			if (plgpts == null)
			{
				throw new ArgumentNullException("plgpts");
			}
			if (plgpts.Length != 3)
			{
				throw new ArgumentException("plgpts");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreateMatrix3(ref rect, plgpts, out nativeMatrix));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> class with the specified elements.</summary>
		/// <param name="m11">The value in the first row and first column of the new <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="m12">The value in the first row and second column of the new <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="m21">The value in the second row and first column of the new <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="m22">The value in the second row and second column of the new <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="dx">The value in the third row and first column of the new <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="dy">The value in the third row and second column of the new <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		public Matrix(float m11, float m12, float m21, float m22, float dx, float dy)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCreateMatrix2(m11, m12, m21, m22, dx, dy, out nativeMatrix));
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.Matrix" /> that this method creates.</returns>
		public Matrix Clone()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipCloneMatrix(nativeMatrix, out var cloneMatrix));
			return new Matrix(cloneMatrix);
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		public void Dispose()
		{
			if (nativeMatrix != IntPtr.Zero)
			{
				GDIPlus.CheckStatus(GDIPlus.GdipDeleteMatrix(nativeMatrix));
				nativeMatrix = IntPtr.Zero;
			}
			GC.SuppressFinalize(this);
		}

		/// <summary>Tests whether the specified object is a <see cref="T:System.Drawing.Drawing2D.Matrix" /> and is identical to this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="obj">The object to test.</param>
		/// <returns>This method returns <see langword="true" /> if <paramref name="obj" /> is the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> identical to this <see cref="T:System.Drawing.Drawing2D.Matrix" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Matrix matrix)
			{
				GDIPlus.CheckStatus(GDIPlus.GdipIsMatrixEqual(nativeMatrix, matrix.nativeMatrix, out var result));
				return result;
			}
			return false;
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Matrix()
		{
			Dispose();
		}

		/// <summary>Returns a hash code.</summary>
		/// <returns>The hash code for this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</returns>
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		/// <summary>Inverts this <see cref="T:System.Drawing.Drawing2D.Matrix" />, if it is invertible.</summary>
		public void Invert()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipInvertMatrix(nativeMatrix));
		}

		/// <summary>Multiplies this <see cref="T:System.Drawing.Drawing2D.Matrix" /> by the matrix specified in the <paramref name="matrix" /> parameter, by prepending the specified <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which this <see cref="T:System.Drawing.Drawing2D.Matrix" /> is to be multiplied.</param>
		public void Multiply(Matrix matrix)
		{
			Multiply(matrix, MatrixOrder.Prepend);
		}

		/// <summary>Multiplies this <see cref="T:System.Drawing.Drawing2D.Matrix" /> by the matrix specified in the <paramref name="matrix" /> parameter, and in the order specified in the <paramref name="order" /> parameter.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which this <see cref="T:System.Drawing.Drawing2D.Matrix" /> is to be multiplied.</param>
		/// <param name="order">The <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that represents the order of the multiplication.</param>
		public void Multiply(Matrix matrix, MatrixOrder order)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipMultiplyMatrix(nativeMatrix, matrix.nativeMatrix, order));
		}

		/// <summary>Resets this <see cref="T:System.Drawing.Drawing2D.Matrix" /> to have the elements of the identity matrix.</summary>
		public void Reset()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipSetMatrixElements(nativeMatrix, 1f, 0f, 0f, 1f, 0f, 0f));
		}

		/// <summary>Prepend to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> a clockwise rotation, around the origin and by the specified angle.</summary>
		/// <param name="angle">The angle of the rotation, in degrees.</param>
		public void Rotate(float angle)
		{
			Rotate(angle, MatrixOrder.Prepend);
		}

		/// <summary>Applies a clockwise rotation of an amount specified in the <paramref name="angle" /> parameter, around the origin (zero x and y coordinates) for this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="angle">The angle (extent) of the rotation, in degrees.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies the order (append or prepend) in which the rotation is applied to this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		public void Rotate(float angle, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipRotateMatrix(nativeMatrix, angle, order));
		}

		/// <summary>Applies a clockwise rotation to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> around the point specified in the <paramref name="point" /> parameter, and by prepending the rotation.</summary>
		/// <param name="angle">The angle (extent) of the rotation, in degrees.</param>
		/// <param name="point">A <see cref="T:System.Drawing.PointF" /> that represents the center of the rotation.</param>
		public void RotateAt(float angle, PointF point)
		{
			RotateAt(angle, point, MatrixOrder.Prepend);
		}

		/// <summary>Applies a clockwise rotation about the specified point to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the specified order.</summary>
		/// <param name="angle">The angle of the rotation, in degrees.</param>
		/// <param name="point">A <see cref="T:System.Drawing.PointF" /> that represents the center of the rotation.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies the order (append or prepend) in which the rotation is applied.</param>
		public void RotateAt(float angle, PointF point, MatrixOrder order)
		{
			if (order < MatrixOrder.Prepend || order > MatrixOrder.Append)
			{
				throw new ArgumentException("order");
			}
			angle *= MathF.PI / 180f;
			float num = (float)Math.Cos(angle);
			float num2 = (float)Math.Sin(angle);
			float num3 = (0f - point.X) * num + point.Y * num2 + point.X;
			float num4 = (0f - point.X) * num2 - point.Y * num + point.Y;
			float[] elements = Elements;
			Status status = ((order != MatrixOrder.Prepend) ? GDIPlus.GdipSetMatrixElements(nativeMatrix, elements[0] * num + elements[1] * (0f - num2), elements[0] * num2 + elements[1] * num, elements[2] * num + elements[3] * (0f - num2), elements[2] * num2 + elements[3] * num, elements[4] * num + elements[5] * (0f - num2) + num3, elements[4] * num2 + elements[5] * num + num4) : GDIPlus.GdipSetMatrixElements(nativeMatrix, num * elements[0] + num2 * elements[2], num * elements[1] + num2 * elements[3], (0f - num2) * elements[0] + num * elements[2], (0f - num2) * elements[1] + num * elements[3], num3 * elements[0] + num4 * elements[2] + elements[4], num3 * elements[1] + num4 * elements[3] + elements[5]));
			GDIPlus.CheckStatus(status);
		}

		/// <summary>Applies the specified scale vector to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> by prepending the scale vector.</summary>
		/// <param name="scaleX">The value by which to scale this <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the x-axis direction.</param>
		/// <param name="scaleY">The value by which to scale this <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the y-axis direction.</param>
		public void Scale(float scaleX, float scaleY)
		{
			Scale(scaleX, scaleY, MatrixOrder.Prepend);
		}

		/// <summary>Applies the specified scale vector (<paramref name="scaleX" /> and <paramref name="scaleY" />) to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> using the specified order.</summary>
		/// <param name="scaleX">The value by which to scale this <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the x-axis direction.</param>
		/// <param name="scaleY">The value by which to scale this <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the y-axis direction.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies the order (append or prepend) in which the scale vector is applied to this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		public void Scale(float scaleX, float scaleY, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipScaleMatrix(nativeMatrix, scaleX, scaleY, order));
		}

		/// <summary>Applies the specified shear vector to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> by prepending the shear transformation.</summary>
		/// <param name="shearX">The horizontal shear factor.</param>
		/// <param name="shearY">The vertical shear factor.</param>
		public void Shear(float shearX, float shearY)
		{
			Shear(shearX, shearY, MatrixOrder.Prepend);
		}

		/// <summary>Applies the specified shear vector to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the specified order.</summary>
		/// <param name="shearX">The horizontal shear factor.</param>
		/// <param name="shearY">The vertical shear factor.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies the order (append or prepend) in which the shear is applied.</param>
		public void Shear(float shearX, float shearY, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipShearMatrix(nativeMatrix, shearX, shearY, order));
		}

		/// <summary>Applies the geometric transform represented by this <see cref="T:System.Drawing.Drawing2D.Matrix" /> to a specified array of points.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points to transform.</param>
		public void TransformPoints(Point[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipTransformMatrixPointsI(nativeMatrix, pts, pts.Length));
		}

		/// <summary>Applies the geometric transform represented by this <see cref="T:System.Drawing.Drawing2D.Matrix" /> to a specified array of points.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points to transform.</param>
		public void TransformPoints(PointF[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipTransformMatrixPoints(nativeMatrix, pts, pts.Length));
		}

		/// <summary>Applies only the scale and rotate components of this <see cref="T:System.Drawing.Drawing2D.Matrix" /> to the specified array of points.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points to transform.</param>
		public void TransformVectors(Point[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipVectorTransformMatrixPointsI(nativeMatrix, pts, pts.Length));
		}

		/// <summary>Multiplies each vector in an array by the matrix. The translation elements of this matrix (third row) are ignored.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points to transform.</param>
		public void TransformVectors(PointF[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipVectorTransformMatrixPoints(nativeMatrix, pts, pts.Length));
		}

		/// <summary>Applies the specified translation vector (<paramref name="offsetX" /> and <paramref name="offsetY" />) to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> by prepending the translation vector.</summary>
		/// <param name="offsetX">The x value by which to translate this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="offsetY">The y value by which to translate this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		public void Translate(float offsetX, float offsetY)
		{
			Translate(offsetX, offsetY, MatrixOrder.Prepend);
		}

		/// <summary>Applies the specified translation vector to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the specified order.</summary>
		/// <param name="offsetX">The x value by which to translate this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="offsetY">The y value by which to translate this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies the order (append or prepend) in which the translation is applied to this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		public void Translate(float offsetX, float offsetY, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipTranslateMatrix(nativeMatrix, offsetX, offsetY, order));
		}

		/// <summary>Multiplies each vector in an array by the matrix. The translation elements of this matrix (third row) are ignored.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points to transform.</param>
		public void VectorTransformPoints(Point[] pts)
		{
			TransformVectors(pts);
		}
	}
	/// <summary>Encapsulates a <see cref="T:System.Drawing.Brush" /> object that fills the interior of a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object with a gradient. This class cannot be inherited.</summary>
	[System.MonoTODO("libgdiplus/cairo doesn't support path gradients - unless it can be mapped to a radial gradient")]
	public sealed class PathGradientBrush : Brush
	{
		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.Blend" /> that specifies positions and factors that define a custom falloff for the gradient.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.Blend" /> that represents a custom falloff for the gradient.</returns>
		public Blend Blend
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPathGradientBlendCount(base.NativeBrush, out var count));
				float[] array = new float[count];
				float[] positions = new float[count];
				GDIPlus.CheckStatus(GDIPlus.GdipGetPathGradientBlend(base.NativeBrush, array, positions, count));
				return new Blend
				{
					Factors = array,
					Positions = positions
				};
			}
			set
			{
				float[] factors = value.Factors;
				float[] positions = value.Positions;
				int num = factors.Length;
				if (num == 0 || positions.Length == 0)
				{
					throw new ArgumentException("Invalid Blend object. It should have at least 2 elements in each of the factors and positions arrays.");
				}
				if (num != positions.Length)
				{
					throw new ArgumentException("Invalid Blend object. It should contain the same number of factors and positions values.");
				}
				if (positions[0] != 0f)
				{
					throw new ArgumentException("Invalid Blend object. The positions array must have 0.0 as its first element.");
				}
				if (positions[num - 1] != 1f)
				{
					throw new ArgumentException("Invalid Blend object. The positions array must have 1.0 as its last element.");
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetPathGradientBlend(base.NativeBrush, factors, positions, num));
			}
		}

		/// <summary>Gets or sets the color at the center of the path gradient.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that represents the color at the center of the path gradient.</returns>
		public Color CenterColor
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPathGradientCenterColor(base.NativeBrush, out var color));
				return Color.FromArgb(color);
			}
			set
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetPathGradientCenterColor(base.NativeBrush, value.ToArgb()));
			}
		}

		/// <summary>Gets or sets the center point of the path gradient.</summary>
		/// <returns>A <see cref="T:System.Drawing.PointF" /> that represents the center point of the path gradient.</returns>
		public PointF CenterPoint
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPathGradientCenterPoint(base.NativeBrush, out var point));
				return point;
			}
			set
			{
				PointF point = value;
				GDIPlus.CheckStatus(GDIPlus.GdipSetPathGradientCenterPoint(base.NativeBrush, ref point));
			}
		}

		/// <summary>Gets or sets the focus point for the gradient falloff.</summary>
		/// <returns>A <see cref="T:System.Drawing.PointF" /> that represents the focus point for the gradient falloff.</returns>
		public PointF FocusScales
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPathGradientFocusScales(base.NativeBrush, out var xScale, out var yScale));
				return new PointF(xScale, yScale);
			}
			set
			{
				GDIPlus.CheckStatus(GDIPlus.GdipSetPathGradientFocusScales(base.NativeBrush, value.X, value.Y));
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.ColorBlend" /> that defines a multicolor linear gradient.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.ColorBlend" /> that defines a multicolor linear gradient.</returns>
		public ColorBlend InterpolationColors
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPathGradientPresetBlendCount(base.NativeBrush, out var count));
				if (count < 1)
				{
					count = 1;
				}
				int[] array = new int[count];
				float[] positions = new float[count];
				if (count > 1)
				{
					GDIPlus.CheckStatus(GDIPlus.GdipGetPathGradientPresetBlend(base.NativeBrush, array, positions, count));
				}
				ColorBlend colorBlend = new ColorBlend();
				Color[] array2 = new Color[count];
				for (int i = 0; i < count; i++)
				{
					array2[i] = Color.FromArgb(array[i]);
				}
				colorBlend.Colors = array2;
				colorBlend.Positions = positions;
				return colorBlend;
			}
			set
			{
				Color[] colors = value.Colors;
				float[] positions = value.Positions;
				int num = colors.Length;
				if (num == 0 || positions.Length == 0)
				{
					throw new ArgumentException("Invalid ColorBlend object. It should have at least 2 elements in each of the colors and positions arrays.");
				}
				if (num != positions.Length)
				{
					throw new ArgumentException("Invalid ColorBlend object. It should contain the same number of positions and color values.");
				}
				if (positions[0] != 0f)
				{
					throw new ArgumentException("Invalid ColorBlend object. The positions array must have 0.0 as its first element.");
				}
				if (positions[num - 1] != 1f)
				{
					throw new ArgumentException("Invalid ColorBlend object. The positions array must have 1.0 as its last element.");
				}
				int[] array = new int[colors.Length];
				for (int i = 0; i < colors.Length; i++)
				{
					array[i] = colors[i].ToArgb();
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetPathGradientPresetBlend(base.NativeBrush, array, positions, num));
			}
		}

		/// <summary>Gets a bounding rectangle for this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> that represents a rectangular region that bounds the path this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> fills.</returns>
		public RectangleF Rectangle
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPathGradientRect(base.NativeBrush, out var rect));
				return rect;
			}
		}

		/// <summary>Gets or sets an array of colors that correspond to the points in the path this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> fills.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.Color" /> structures that represents the colors associated with each point in the path this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> fills.</returns>
		public Color[] SurroundColors
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPathGradientSurroundColorCount(base.NativeBrush, out var count));
				int[] array = new int[count];
				GDIPlus.CheckStatus(GDIPlus.GdipGetPathGradientSurroundColorsWithCount(base.NativeBrush, array, ref count));
				Color[] array2 = new Color[count];
				for (int i = 0; i < count; i++)
				{
					array2[i] = Color.FromArgb(array[i]);
				}
				return array2;
			}
			set
			{
				int count = value.Length;
				int[] array = new int[count];
				for (int i = 0; i < count; i++)
				{
					array[i] = value[i].ToArgb();
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetPathGradientSurroundColorsWithCount(base.NativeBrush, array, ref count));
			}
		}

		/// <summary>Gets or sets a copy of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> that defines a local geometric transform for this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" />.</summary>
		/// <returns>A copy of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> that defines a geometric transform that applies only to fills drawn with this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" />.</returns>
		public Matrix Transform
		{
			get
			{
				Matrix matrix = new Matrix();
				GDIPlus.CheckStatus(GDIPlus.GdipGetPathGradientTransform(base.NativeBrush, matrix.nativeMatrix));
				return matrix;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("Transform");
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetPathGradientTransform(base.NativeBrush, value.nativeMatrix));
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that indicates the wrap mode for this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that specifies how fills drawn with this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> are tiled.</returns>
		public WrapMode WrapMode
		{
			get
			{
				GDIPlus.CheckStatus(GDIPlus.GdipGetPathGradientWrapMode(base.NativeBrush, out var wrapMode));
				return wrapMode;
			}
			set
			{
				if (value < WrapMode.Tile || value > WrapMode.Clamp)
				{
					throw new InvalidEnumArgumentException("WrapMode");
				}
				GDIPlus.CheckStatus(GDIPlus.GdipSetPathGradientWrapMode(base.NativeBrush, value));
			}
		}

		internal PathGradientBrush(IntPtr native)
		{
			SetNativeBrush(native);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> class with the specified path.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> that defines the area filled by this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" />.</param>
		public PathGradientBrush(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreatePathGradientFromPath(path.nativePath, out var brush));
			SetNativeBrush(brush);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> class with the specified points.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that make up the vertices of the path.</param>
		public PathGradientBrush(Point[] points)
			: this(points, WrapMode.Clamp)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> class with the specified points.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that make up the vertices of the path.</param>
		public PathGradientBrush(PointF[] points)
			: this(points, WrapMode.Clamp)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> class with the specified points and wrap mode.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that make up the vertices of the path.</param>
		/// <param name="wrapMode">A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that specifies how fills drawn with this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> are tiled.</param>
		public PathGradientBrush(Point[] points, WrapMode wrapMode)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			if (wrapMode < WrapMode.Tile || wrapMode > WrapMode.Clamp)
			{
				throw new InvalidEnumArgumentException("WrapMode");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreatePathGradientI(points, points.Length, wrapMode, out var brush));
			SetNativeBrush(brush);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> class with the specified points and wrap mode.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that make up the vertices of the path.</param>
		/// <param name="wrapMode">A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that specifies how fills drawn with this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> are tiled.</param>
		public PathGradientBrush(PointF[] points, WrapMode wrapMode)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			if (wrapMode < WrapMode.Tile || wrapMode > WrapMode.Clamp)
			{
				throw new InvalidEnumArgumentException("WrapMode");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipCreatePathGradient(points, points.Length, wrapMode, out var brush));
			SetNativeBrush(brush);
		}

		/// <summary>Updates the brush's transformation matrix with the product of brush's transformation matrix multiplied by another matrix.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> that will be multiplied by the brush's current transformation matrix.</param>
		public void MultiplyTransform(Matrix matrix)
		{
			MultiplyTransform(matrix, MatrixOrder.Prepend);
		}

		/// <summary>Updates the brush's transformation matrix with the product of the brush's transformation matrix multiplied by another matrix.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> that will be multiplied by the brush's current transformation matrix.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies in which order to multiply the two matrices.</param>
		public void MultiplyTransform(Matrix matrix, MatrixOrder order)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipMultiplyPathGradientTransform(base.NativeBrush, matrix.nativeMatrix, order));
		}

		/// <summary>Resets the <see cref="P:System.Drawing.Drawing2D.PathGradientBrush.Transform" /> property to identity.</summary>
		public void ResetTransform()
		{
			GDIPlus.CheckStatus(GDIPlus.GdipResetPathGradientTransform(base.NativeBrush));
		}

		/// <summary>Rotates the local geometric transform by the specified amount. This method prepends the rotation to the transform.</summary>
		/// <param name="angle">The angle (extent) of rotation.</param>
		public void RotateTransform(float angle)
		{
			RotateTransform(angle, MatrixOrder.Prepend);
		}

		/// <summary>Rotates the local geometric transform by the specified amount in the specified order.</summary>
		/// <param name="angle">The angle (extent) of rotation.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies whether to append or prepend the rotation matrix.</param>
		public void RotateTransform(float angle, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipRotatePathGradientTransform(base.NativeBrush, angle, order));
		}

		/// <summary>Scales the local geometric transform by the specified amounts. This method prepends the scaling matrix to the transform.</summary>
		/// <param name="sx">The transform scale factor in the x-axis direction.</param>
		/// <param name="sy">The transform scale factor in the y-axis direction.</param>
		public void ScaleTransform(float sx, float sy)
		{
			ScaleTransform(sx, sy, MatrixOrder.Prepend);
		}

		/// <summary>Scales the local geometric transform by the specified amounts in the specified order.</summary>
		/// <param name="sx">The transform scale factor in the x-axis direction.</param>
		/// <param name="sy">The transform scale factor in the y-axis direction.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies whether to append or prepend the scaling matrix.</param>
		public void ScaleTransform(float sx, float sy, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipScalePathGradientTransform(base.NativeBrush, sx, sy, order));
		}

		/// <summary>Creates a gradient with a center color and a linear falloff to one surrounding color.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies where, along any radial from the center of the path to the path's boundary, the center color will be at its highest intensity. A value of 1 (the default) places the highest intensity at the center of the path.</param>
		public void SetBlendTriangularShape(float focus)
		{
			SetBlendTriangularShape(focus, 1f);
		}

		/// <summary>Creates a gradient with a center color and a linear falloff to each surrounding color.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies where, along any radial from the center of the path to the path's boundary, the center color will be at its highest intensity. A value of 1 (the default) places the highest intensity at the center of the path.</param>
		/// <param name="scale">A value from 0 through 1 that specifies the maximum intensity of the center color that gets blended with the boundary color. A value of 1 causes the highest possible intensity of the center color, and it is the default value.</param>
		public void SetBlendTriangularShape(float focus, float scale)
		{
			if (focus < 0f || focus > 1f || scale < 0f || scale > 1f)
			{
				throw new ArgumentException("Invalid parameter passed.");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipSetPathGradientLinearBlend(base.NativeBrush, focus, scale));
		}

		/// <summary>Creates a gradient brush that changes color starting from the center of the path outward to the path's boundary. The transition from one color to another is based on a bell-shaped curve.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies where, along any radial from the center of the path to the path's boundary, the center color will be at its highest intensity. A value of 1 (the default) places the highest intensity at the center of the path.</param>
		public void SetSigmaBellShape(float focus)
		{
			SetSigmaBellShape(focus, 1f);
		}

		/// <summary>Creates a gradient brush that changes color starting from the center of the path outward to the path's boundary. The transition from one color to another is based on a bell-shaped curve.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies where, along any radial from the center of the path to the path's boundary, the center color will be at its highest intensity. A value of 1 (the default) places the highest intensity at the center of the path.</param>
		/// <param name="scale">A value from 0 through 1 that specifies the maximum intensity of the center color that gets blended with the boundary color. A value of 1 causes the highest possible intensity of the center color, and it is the default value.</param>
		public void SetSigmaBellShape(float focus, float scale)
		{
			if (focus < 0f || focus > 1f || scale < 0f || scale > 1f)
			{
				throw new ArgumentException("Invalid parameter passed.");
			}
			GDIPlus.CheckStatus(GDIPlus.GdipSetPathGradientSigmaBlend(base.NativeBrush, focus, scale));
		}

		/// <summary>Applies the specified translation to the local geometric transform. This method prepends the translation to the transform.</summary>
		/// <param name="dx">The value of the translation in x.</param>
		/// <param name="dy">The value of the translation in y.</param>
		public void TranslateTransform(float dx, float dy)
		{
			TranslateTransform(dx, dy, MatrixOrder.Prepend);
		}

		/// <summary>Applies the specified translation to the local geometric transform in the specified order.</summary>
		/// <param name="dx">The value of the translation in x.</param>
		/// <param name="dy">The value of the translation in y.</param>
		/// <param name="order">The order (prepend or append) in which to apply the translation.</param>
		public void TranslateTransform(float dx, float dy, MatrixOrder order)
		{
			GDIPlus.CheckStatus(GDIPlus.GdipTranslatePathGradientTransform(base.NativeBrush, dx, dy, order));
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> this method creates, cast as an object.</returns>
		public override object Clone()
		{
			GDIPlus.CheckStatus((Status)GDIPlus.GdipCloneBrush(new HandleRef(this, base.NativeBrush), out var clonedBrush));
			return new PathGradientBrush(clonedBrush);
		}
	}
}
namespace Unity
{
	internal sealed class ThrowStub : ObjectDisposedException
	{
		public static void ThrowNotSupportedException()
		{
			throw new PlatformNotSupportedException();
		}
	}
}
