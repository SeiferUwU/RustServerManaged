#define UNITY_ASSERTIONS
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Threading;
using AOT;
using Microsoft.CodeAnalysis;
using Unity.Burst;
using Unity.Burst.CompilerServices;
using Unity.Burst.Intrinsics;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using Unity.Mathematics;
using Unity.Properties;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Scripting.APIUpdating;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: InternalsVisibleTo("Unity.Burst.Tests")]
[assembly: InternalsVisibleTo("Unity.Collections.BurstCompatibilityTestCodeGen")]
[assembly: InternalsVisibleTo("Unity.Collections.Tests")]
[assembly: InternalsVisibleTo("Unity.Collections.CodeGen")]
[assembly: InternalsVisibleTo("Unity.Collections.Editor")]
[assembly: InternalsVisibleTo("Unity.Collections.PerformanceTests")]
[assembly: InternalsVisibleTo("Unity.Entities")]
[assembly: InternalsVisibleTo("Unity.Entities.CodeGen")]
[assembly: InternalsVisibleTo("Unity.Entities.Tests")]
[assembly: InternalsVisibleTo("Unity.Entities.Editor")]
[assembly: InternalsVisibleTo("Unity.Entities.Editor.Tests")]
[assembly: InternalsVisibleTo("Unity.Entities.Graphics")]
[assembly: InternalsVisibleTo("Unity.Entities.Hybrid")]
[assembly: InternalsVisibleTo("Unity.Runtime")]
[assembly: InternalsVisibleTo("Unity.Runtime.Tests")]
[assembly: InternalsVisibleTo("Unity.Runtime.IO.Tests")]
[assembly: InternalsVisibleTo("Unity.Runtime.UnityInstance")]
[assembly: InternalsVisibleTo("Unity.Scenes")]
[assembly: InternalsVisibleTo("Unity.Scenes.Editor")]
[assembly: InternalsVisibleTo("Samples.GridPath.Tests")]
[assembly: InternalsVisibleTo("Unity.Entities.PerformanceTests")]
[assembly: BurstCompiler.StaticTypeReinit(typeof(AllocatorManager.StackAllocator.Try_000000AB$BurstDirectCall))]
[assembly: BurstCompiler.StaticTypeReinit(typeof(AllocatorManager.SlabAllocator.Try_000000B9$BurstDirectCall))]
[assembly: BurstCompiler.StaticTypeReinit(typeof(Unity.Collections.Try_000000E3$BurstDirectCall))]
[assembly: BurstCompiler.StaticTypeReinit(typeof(Unity.Collections.Try_000009DE$BurstDirectCall))]
[assembly: BurstCompiler.StaticTypeReinit(typeof(Unity.Collections.Hash64Long_00000A73$BurstDirectCall))]
[assembly: BurstCompiler.StaticTypeReinit(typeof(Unity.Collections.Hash128Long_00000A7A$BurstDirectCall))]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
namespace Microsoft.CodeAnalysis
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class EmbeddedAttribute : Attribute
	{
	}
}
namespace System.Runtime.CompilerServices
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class IsUnmanagedAttribute : Attribute
	{
	}
}
[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		return new MonoScriptData
		{
			FilePathsData = new byte[6703]
			{
				0, 0, 0, 21, 0, 0, 0, 87, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 64, 50, 46, 53, 46, 49, 92, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 92, 65, 108, 108, 111,
				99, 97, 116, 111, 114, 77, 97, 110, 97, 103,
				101, 114, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 88, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 64, 50, 46, 53,
				46, 49, 92, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				92, 65, 117, 116, 111, 70, 114, 101, 101, 65,
				108, 108, 111, 99, 97, 116, 111, 114, 46, 99,
				115, 0, 0, 0, 5, 0, 0, 0, 79, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 99, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 64, 50, 46, 53, 46, 49, 92, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 92, 66, 105, 116,
				70, 105, 101, 108, 100, 46, 99, 115, 0, 0,
				0, 4, 0, 0, 0, 87, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 99, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 64,
				50, 46, 53, 46, 49, 92, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 92, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 72, 101, 108, 112, 101, 114,
				46, 99, 115, 0, 0, 0, 5, 0, 0, 0,
				85, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 64, 50, 46, 53, 46, 49,
				92, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 92, 67,
				111, 110, 99, 117, 114, 114, 101, 110, 116, 77,
				97, 115, 107, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 91, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 99, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 64, 50, 46,
				53, 46, 49, 92, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 92, 68, 97, 116, 97, 83, 116, 114, 101,
				97, 109, 69, 120, 116, 101, 110, 115, 105, 111,
				110, 115, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 87, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 64, 50, 46, 53,
				46, 49, 92, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				92, 68, 97, 116, 97, 83, 116, 114, 101, 97,
				109, 82, 101, 97, 100, 101, 114, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 87, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 64, 50, 46, 53, 46, 49, 92, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 92, 68, 97, 116, 97,
				83, 116, 114, 101, 97, 109, 87, 114, 105, 116,
				101, 114, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 80, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 64, 50, 46, 53,
				46, 49, 92, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				92, 68, 101, 98, 117, 103, 86, 105, 101, 119,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				97, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 64, 50, 46, 53, 46, 49,
				92, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 92, 68,
				111, 117, 98, 108, 101, 82, 101, 119, 105, 110,
				100, 97, 98, 108, 101, 65, 108, 108, 111, 99,
				97, 116, 111, 114, 115, 46, 99, 115, 0, 0,
				0, 23, 0, 0, 0, 84, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 99, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 64,
				50, 46, 53, 46, 49, 92, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 92, 70, 105, 120, 101, 100, 76,
				105, 115, 116, 46, 103, 101, 110, 46, 99, 115,
				0, 0, 0, 22, 0, 0, 0, 86, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 64, 50, 46, 53, 46, 49, 92, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 92, 70, 105, 120, 101,
				100, 83, 116, 114, 105, 110, 103, 46, 103, 101,
				110, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 95, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 99, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 64, 50, 46, 53, 46,
				49, 92, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 92,
				70, 105, 120, 101, 100, 83, 116, 114, 105, 110,
				103, 65, 112, 112, 101, 110, 100, 77, 101, 116,
				104, 111, 100, 115, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 92, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 99, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 64, 50,
				46, 53, 46, 49, 92, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 92, 70, 105, 120, 101, 100, 83, 116,
				114, 105, 110, 103, 70, 111, 114, 109, 97, 116,
				46, 103, 101, 110, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 99, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 99, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 64, 50,
				46, 53, 46, 49, 92, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 92, 70, 105, 120, 101, 100, 83, 116,
				114, 105, 110, 103, 70, 111, 114, 109, 97, 116,
				77, 101, 116, 104, 111, 100, 115, 46, 103, 101,
				110, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 97, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 99, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 64, 50, 46, 53, 46,
				49, 92, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 92,
				70, 105, 120, 101, 100, 83, 116, 114, 105, 110,
				103, 73, 110, 116, 101, 114, 110, 97, 108, 77,
				101, 116, 104, 111, 100, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 89, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				64, 50, 46, 53, 46, 49, 92, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 92, 70, 105, 120, 101, 100,
				83, 116, 114, 105, 110, 103, 77, 101, 116, 104,
				111, 100, 115, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 94, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 99, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 64, 50, 46,
				53, 46, 49, 92, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 92, 70, 105, 120, 101, 100, 83, 116, 114,
				105, 110, 103, 80, 97, 114, 115, 101, 77, 101,
				116, 104, 111, 100, 115, 46, 99, 115, 0, 0,
				0, 3, 0, 0, 0, 87, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 99, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 64,
				50, 46, 53, 46, 49, 92, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 92, 70, 105, 120, 101, 100, 83,
				116, 114, 105, 110, 103, 85, 116, 105, 108, 115,
				46, 99, 115, 0, 0, 0, 3, 0, 0, 0,
				114, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 64, 50, 46, 53, 46, 49,
				92, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 92, 71,
				101, 110, 101, 114, 97, 116, 101, 84, 101, 115,
				116, 115, 70, 111, 114, 66, 117, 114, 115, 116,
				67, 111, 109, 112, 97, 116, 105, 98, 105, 108,
				105, 116, 121, 65, 116, 116, 114, 105, 98, 117,
				116, 101, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 92, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 64, 50, 46, 53,
				46, 49, 92, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				92, 74, 111, 98, 115, 92, 69, 97, 114, 108,
				121, 73, 110, 105, 116, 72, 101, 108, 112, 101,
				114, 115, 46, 99, 115, 0, 0, 0, 6, 0,
				0, 0, 86, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 64, 50, 46, 53,
				46, 49, 92, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				92, 74, 111, 98, 115, 92, 73, 74, 111, 98,
				70, 105, 108, 116, 101, 114, 46, 99, 115, 0,
				0, 0, 3, 0, 0, 0, 96, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				64, 50, 46, 53, 46, 49, 92, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 92, 74, 111, 98, 115, 92,
				73, 74, 111, 98, 80, 97, 114, 97, 108, 108,
				101, 108, 70, 111, 114, 66, 97, 116, 99, 104,
				46, 99, 115, 0, 0, 0, 3, 0, 0, 0,
				96, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 64, 50, 46, 53, 46, 49,
				92, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 92, 74,
				111, 98, 115, 92, 73, 74, 111, 98, 80, 97,
				114, 97, 108, 108, 101, 108, 70, 111, 114, 68,
				101, 102, 101, 114, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 107, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 99, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 64, 50,
				46, 53, 46, 49, 92, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 92, 74, 111, 98, 115, 92, 82, 101,
				103, 105, 115, 116, 101, 114, 71, 101, 110, 101,
				114, 105, 99, 74, 111, 98, 84, 121, 112, 101,
				65, 116, 116, 114, 105, 98, 117, 116, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 85,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 99, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 64, 50, 46, 53, 46, 49, 92,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 92, 76, 105,
				115, 116, 69, 120, 116, 101, 110, 115, 105, 111,
				110, 115, 46, 99, 115, 0, 0, 0, 4, 0,
				0, 0, 77, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 64, 50, 46, 53,
				46, 49, 92, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				92, 77, 101, 109, 111, 114, 121, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 92, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 64, 50, 46, 53, 46, 49, 92, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 92, 78, 97, 116, 105,
				118, 101, 65, 114, 114, 97, 121, 69, 120, 116,
				101, 110, 115, 105, 111, 110, 115, 46, 99, 115,
				0, 0, 0, 5, 0, 0, 0, 85, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 64, 50, 46, 53, 46, 49, 92, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 92, 78, 97, 116, 105,
				118, 101, 66, 105, 116, 65, 114, 114, 97, 121,
				46, 99, 115, 0, 0, 0, 7, 0, 0, 0,
				84, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 64, 50, 46, 53, 46, 49,
				92, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 92, 78,
				97, 116, 105, 118, 101, 72, 97, 115, 104, 77,
				97, 112, 46, 99, 115, 0, 0, 0, 4, 0,
				0, 0, 84, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 64, 50, 46, 53,
				46, 49, 92, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				92, 78, 97, 116, 105, 118, 101, 72, 97, 115,
				104, 83, 101, 116, 46, 99, 115, 0, 0, 0,
				9, 0, 0, 0, 81, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 99, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 64, 50,
				46, 53, 46, 49, 92, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 92, 78, 97, 116, 105, 118, 101, 76,
				105, 115, 116, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 95, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 99, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 64, 50, 46,
				53, 46, 49, 92, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 92, 78, 97, 116, 105, 118, 101, 78, 111,
				116, 66, 117, 114, 115, 116, 67, 111, 109, 112,
				97, 116, 105, 98, 108, 101, 46, 99, 115, 0,
				0, 0, 6, 0, 0, 0, 92, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				64, 50, 46, 53, 46, 49, 92, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 92, 78, 97, 116, 105, 118,
				101, 80, 97, 114, 97, 108, 108, 101, 108, 72,
				97, 115, 104, 77, 97, 112, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 102, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				64, 50, 46, 53, 46, 49, 92, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 92, 78, 97, 116, 105, 118,
				101, 80, 97, 114, 97, 108, 108, 101, 108, 72,
				97, 115, 104, 77, 97, 112, 69, 120, 116, 101,
				110, 115, 105, 111, 110, 115, 46, 99, 115, 0,
				0, 0, 5, 0, 0, 0, 92, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				64, 50, 46, 53, 46, 49, 92, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 92, 78, 97, 116, 105, 118,
				101, 80, 97, 114, 97, 108, 108, 101, 108, 72,
				97, 115, 104, 83, 101, 116, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 106, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				64, 50, 46, 53, 46, 49, 92, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 92, 78, 97, 116, 105, 118,
				101, 80, 97, 114, 97, 108, 108, 101, 108, 72,
				97, 115, 104, 83, 101, 116, 69, 120, 116, 101,
				110, 115, 105, 111, 110, 115, 46, 103, 101, 110,
				46, 99, 115, 0, 0, 0, 8, 0, 0, 0,
				97, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 64, 50, 46, 53, 46, 49,
				92, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 92, 78,
				97, 116, 105, 118, 101, 80, 97, 114, 97, 108,
				108, 101, 108, 77, 117, 108, 116, 105, 72, 97,
				115, 104, 77, 97, 112, 46, 99, 115, 0, 0,
				0, 6, 0, 0, 0, 82, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 99, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 64,
				50, 46, 53, 46, 49, 92, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 92, 78, 97, 116, 105, 118, 101,
				81, 117, 101, 117, 101, 46, 99, 115, 0, 0,
				0, 5, 0, 0, 0, 86, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 99, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 64,
				50, 46, 53, 46, 49, 92, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 92, 78, 97, 116, 105, 118, 101,
				82, 101, 102, 101, 114, 101, 110, 99, 101, 46,
				99, 115, 0, 0, 0, 4, 0, 0, 0, 86,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 99, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 64, 50, 46, 53, 46, 49, 92,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 92, 78, 97,
				116, 105, 118, 101, 82, 105, 110, 103, 81, 117,
				101, 117, 101, 46, 99, 115, 0, 0, 0, 8,
				0, 0, 0, 81, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 99, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 64, 50, 46,
				53, 46, 49, 92, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 92, 78, 97, 116, 105, 118, 101, 83, 111,
				114, 116, 46, 99, 115, 0, 0, 0, 7, 0,
				0, 0, 83, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 64, 50, 46, 53,
				46, 49, 92, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				92, 78, 97, 116, 105, 118, 101, 83, 116, 114,
				101, 97, 109, 46, 99, 115, 0, 0, 0, 5,
				0, 0, 0, 85, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 99, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 64, 50, 46,
				53, 46, 49, 92, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 92, 78, 97, 116, 105, 118, 101, 84, 101,
				120, 116, 46, 103, 101, 110, 46, 99, 115, 0,
				0, 0, 4, 0, 0, 0, 90, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				64, 50, 46, 53, 46, 49, 92, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 92, 82, 101, 119, 105, 110,
				100, 97, 98, 108, 101, 65, 108, 108, 111, 99,
				97, 116, 111, 114, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 93, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 99, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 64, 50,
				46, 53, 46, 49, 92, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 92, 83, 116, 114, 101, 97, 109, 67,
				111, 109, 112, 114, 101, 115, 115, 105, 111, 110,
				77, 111, 100, 101, 108, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 80, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 99, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 64,
				50, 46, 53, 46, 49, 92, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 92, 85, 73, 110, 116, 70, 108,
				111, 97, 116, 46, 99, 115, 0, 0, 0, 2,
				0, 0, 0, 78, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 99, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 64, 50, 46,
				53, 46, 49, 92, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 92, 85, 110, 105, 99, 111, 100, 101, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 89,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 99, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 64, 50, 46, 53, 46, 49, 92,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 92, 85, 110,
				115, 97, 102, 101, 65, 112, 112, 101, 110, 100,
				66, 117, 102, 102, 101, 114, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 90, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				64, 50, 46, 53, 46, 49, 92, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 92, 85, 110, 115, 97, 102,
				101, 65, 116, 111, 109, 105, 99, 67, 111, 117,
				110, 116, 101, 114, 46, 99, 115, 0, 0, 0,
				3, 0, 0, 0, 85, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 99, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 64, 50,
				46, 53, 46, 49, 92, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 92, 85, 110, 115, 97, 102, 101, 66,
				105, 116, 65, 114, 114, 97, 121, 46, 99, 115,
				0, 0, 0, 6, 0, 0, 0, 84, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 64, 50, 46, 53, 46, 49, 92, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 92, 85, 110, 115, 97,
				102, 101, 72, 97, 115, 104, 77, 97, 112, 46,
				99, 115, 0, 0, 0, 4, 0, 0, 0, 84,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 99, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 64, 50, 46, 53, 46, 49, 92,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 92, 85, 110,
				115, 97, 102, 101, 72, 97, 115, 104, 83, 101,
				116, 46, 99, 115, 0, 0, 0, 15, 0, 0,
				0, 81, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 99, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 64, 50, 46, 53, 46,
				49, 92, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 92,
				85, 110, 115, 97, 102, 101, 76, 105, 115, 116,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				95, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 99, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 64, 50, 46, 53, 46, 49,
				92, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 92, 85,
				110, 115, 97, 102, 101, 78, 111, 116, 66, 117,
				114, 115, 116, 67, 111, 109, 112, 97, 116, 105,
				98, 108, 101, 46, 99, 115, 0, 0, 0, 14,
				0, 0, 0, 92, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 99, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 64, 50, 46,
				53, 46, 49, 92, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 92, 85, 110, 115, 97, 102, 101, 80, 97,
				114, 97, 108, 108, 101, 108, 72, 97, 115, 104,
				77, 97, 112, 46, 99, 115, 0, 0, 0, 5,
				0, 0, 0, 92, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 99, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 64, 50, 46,
				53, 46, 49, 92, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 92, 85, 110, 115, 97, 102, 101, 80, 97,
				114, 97, 108, 108, 101, 108, 72, 97, 115, 104,
				83, 101, 116, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 106, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 99, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 64, 50, 46,
				53, 46, 49, 92, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 92, 85, 110, 115, 97, 102, 101, 80, 97,
				114, 97, 108, 108, 101, 108, 72, 97, 115, 104,
				83, 101, 116, 69, 120, 116, 101, 110, 115, 105,
				111, 110, 115, 46, 103, 101, 110, 46, 99, 115,
				0, 0, 0, 6, 0, 0, 0, 97, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 64, 50, 46, 53, 46, 49, 92, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 92, 85, 110, 115, 97,
				102, 101, 80, 97, 114, 97, 108, 108, 101, 108,
				77, 117, 108, 116, 105, 72, 97, 115, 104, 77,
				97, 112, 46, 99, 115, 0, 0, 0, 10, 0,
				0, 0, 82, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 64, 50, 46, 53,
				46, 49, 92, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				92, 85, 110, 115, 97, 102, 101, 81, 117, 101,
				117, 101, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 86, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 64, 50, 46, 53,
				46, 49, 92, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				92, 85, 110, 115, 97, 102, 101, 82, 105, 110,
				103, 81, 117, 101, 117, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 93, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 99,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				64, 50, 46, 53, 46, 49, 92, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 92, 85, 110, 115, 97, 102,
				101, 83, 99, 114, 97, 116, 99, 104, 65, 108,
				108, 111, 99, 97, 116, 111, 114, 46, 99, 115,
				0, 0, 0, 9, 0, 0, 0, 83, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 64, 50, 46, 53, 46, 49, 92, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 92, 85, 110, 115, 97,
				102, 101, 83, 116, 114, 101, 97, 109, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 81, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 99, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 64, 50, 46, 53, 46, 49, 92, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 92, 85, 110, 115,
				97, 102, 101, 84, 101, 120, 116, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 86, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				99, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 64, 50, 46, 53, 46, 49, 92, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 92, 85, 110, 115, 97,
				102, 101, 85, 116, 105, 108, 105, 116, 121, 69,
				120, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 93, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 99, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 64, 50, 46, 53, 46,
				49, 92, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 92,
				85, 84, 70, 56, 65, 114, 114, 97, 121, 85,
				110, 115, 97, 102, 101, 85, 116, 105, 108, 105,
				116, 121, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 83, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 99, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 64, 50, 46, 53,
				46, 49, 92, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				92, 120, 120, 72, 97, 115, 104, 51, 46, 65,
				86, 88, 50, 46, 99, 115, 0, 0, 0, 3,
				0, 0, 0, 78, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 99, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 64, 50, 46,
				53, 46, 49, 92, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 92, 120, 120, 72, 97, 115, 104, 51, 46,
				99, 115, 0, 0, 0, 3, 0, 0, 0, 93,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 99, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 64, 50, 46, 53, 46, 49, 92,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 92, 120, 120,
				72, 97, 115, 104, 51, 46, 83, 116, 114, 101,
				97, 109, 105, 110, 103, 83, 116, 97, 116, 101,
				46, 99, 115
			},
			TypesData = new byte[13958]
			{
				0, 0, 0, 0, 25, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 83, 112, 105, 110, 110, 101, 114,
				0, 0, 0, 0, 34, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 65, 108, 108, 111, 99, 97, 116,
				111, 114, 77, 97, 110, 97, 103, 101, 114, 0,
				0, 0, 0, 50, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 65, 108, 108, 111, 99, 97, 116, 111,
				114, 77, 97, 110, 97, 103, 101, 114, 124, 65,
				108, 108, 111, 99, 97, 116, 111, 114, 72, 97,
				110, 100, 108, 101, 0, 0, 0, 0, 46, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 46, 65, 108, 108,
				111, 99, 97, 116, 111, 114, 77, 97, 110, 97,
				103, 101, 114, 124, 66, 108, 111, 99, 107, 72,
				97, 110, 100, 108, 101, 0, 0, 0, 0, 40,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 65, 108,
				108, 111, 99, 97, 116, 111, 114, 77, 97, 110,
				97, 103, 101, 114, 124, 82, 97, 110, 103, 101,
				0, 0, 0, 0, 40, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 46, 65, 108, 108, 111, 99, 97, 116,
				111, 114, 77, 97, 110, 97, 103, 101, 114, 124,
				66, 108, 111, 99, 107, 0, 0, 0, 0, 45,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 65, 108,
				108, 111, 99, 97, 116, 111, 114, 77, 97, 110,
				97, 103, 101, 114, 124, 73, 65, 108, 108, 111,
				99, 97, 116, 111, 114, 0, 0, 0, 0, 49,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 65, 108,
				108, 111, 99, 97, 116, 111, 114, 77, 97, 110,
				97, 103, 101, 114, 124, 83, 116, 97, 99, 107,
				65, 108, 108, 111, 99, 97, 116, 111, 114, 0,
				0, 0, 0, 48, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 65, 108, 108, 111, 99, 97, 116, 111,
				114, 77, 97, 110, 97, 103, 101, 114, 124, 83,
				108, 97, 98, 65, 108, 108, 111, 99, 97, 116,
				111, 114, 0, 0, 0, 0, 45, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 46, 65, 108, 108, 111, 99,
				97, 116, 111, 114, 77, 97, 110, 97, 103, 101,
				114, 124, 84, 97, 98, 108, 101, 69, 110, 116,
				114, 121, 0, 0, 0, 0, 42, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 46, 65, 108, 108, 111, 99,
				97, 116, 111, 114, 77, 97, 110, 97, 103, 101,
				114, 124, 65, 114, 114, 97, 121, 49, 54, 0,
				0, 0, 0, 43, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 65, 108, 108, 111, 99, 97, 116, 111,
				114, 77, 97, 110, 97, 103, 101, 114, 124, 65,
				114, 114, 97, 121, 50, 53, 54, 0, 0, 0,
				0, 44, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				65, 108, 108, 111, 99, 97, 116, 111, 114, 77,
				97, 110, 97, 103, 101, 114, 124, 65, 114, 114,
				97, 121, 52, 48, 57, 54, 0, 0, 0, 0,
				45, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 65,
				108, 108, 111, 99, 97, 116, 111, 114, 77, 97,
				110, 97, 103, 101, 114, 124, 65, 114, 114, 97,
				121, 51, 50, 55, 54, 56, 0, 0, 0, 0,
				48, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 65,
				108, 108, 111, 99, 97, 116, 111, 114, 77, 97,
				110, 97, 103, 101, 114, 124, 83, 104, 97, 114,
				101, 100, 83, 116, 97, 116, 105, 99, 115, 0,
				0, 0, 0, 60, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 65, 108, 108, 111, 99, 97, 116, 111,
				114, 77, 97, 110, 97, 103, 101, 114, 43, 83,
				104, 97, 114, 101, 100, 83, 116, 97, 116, 105,
				99, 115, 124, 73, 115, 73, 110, 115, 116, 97,
				108, 108, 101, 100, 0, 0, 0, 0, 59, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 46, 65, 108, 108,
				111, 99, 97, 116, 111, 114, 77, 97, 110, 97,
				103, 101, 114, 43, 83, 104, 97, 114, 101, 100,
				83, 116, 97, 116, 105, 99, 115, 124, 84, 97,
				98, 108, 101, 69, 110, 116, 114, 121, 0, 0,
				0, 0, 62, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				46, 65, 108, 108, 111, 99, 97, 116, 111, 114,
				77, 97, 110, 97, 103, 101, 114, 43, 83, 104,
				97, 114, 101, 100, 83, 116, 97, 116, 105, 99,
				115, 124, 73, 115, 65, 117, 116, 111, 68, 105,
				115, 112, 111, 115, 101, 0, 0, 0, 0, 42,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 65, 108,
				108, 111, 99, 97, 116, 111, 114, 77, 97, 110,
				97, 103, 101, 114, 124, 77, 97, 110, 97, 103,
				101, 100, 0, 0, 0, 0, 49, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 46, 65, 108, 108, 111, 99,
				97, 116, 111, 114, 77, 97, 110, 97, 103, 101,
				114, 124, 65, 108, 108, 111, 99, 97, 116, 111,
				114, 67, 97, 99, 104, 101, 0, 0, 0, 0,
				33, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 124, 65,
				108, 108, 111, 99, 97, 116, 111, 114, 72, 101,
				108, 112, 101, 114, 0, 0, 0, 0, 31, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 124, 65, 114, 114,
				97, 121, 79, 102, 65, 114, 114, 97, 121, 115,
				0, 0, 0, 0, 35, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 65, 117, 116, 111, 70, 114, 101,
				101, 65, 108, 108, 111, 99, 97, 116, 111, 114,
				0, 0, 0, 0, 25, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 66, 105, 116, 119, 105, 115, 101,
				0, 0, 0, 0, 28, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 66, 105, 116, 70, 105, 101, 108,
				100, 51, 50, 0, 0, 0, 0, 37, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 124, 66, 105, 116, 70,
				105, 101, 108, 100, 51, 50, 68, 101, 98, 117,
				103, 86, 105, 101, 119, 0, 0, 0, 0, 28,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 66, 105,
				116, 70, 105, 101, 108, 100, 54, 52, 0, 0,
				0, 0, 37, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				124, 66, 105, 116, 70, 105, 101, 108, 100, 54,
				52, 68, 101, 98, 117, 103, 86, 105, 101, 119,
				0, 0, 0, 0, 35, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 73, 78, 97, 116, 105, 118, 101,
				68, 105, 115, 112, 111, 115, 97, 98, 108, 101,
				0, 0, 0, 0, 34, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 72, 101, 108, 112, 101, 114, 0,
				0, 0, 0, 50, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 72, 101, 108, 112, 101, 114, 124, 76,
				111, 110, 103, 68, 111, 117, 98, 108, 101, 85,
				110, 105, 111, 110, 0, 0, 0, 0, 43, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 72, 101, 108,
				112, 101, 114, 124, 68, 117, 109, 109, 121, 74,
				111, 98, 0, 0, 0, 0, 23, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 124, 76, 111, 110, 103, 56,
				0, 0, 0, 0, 24, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 76, 111, 110, 103, 54, 52, 0,
				0, 0, 0, 25, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 124, 76, 111, 110, 103, 53, 49, 50, 0,
				0, 0, 0, 26, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 124, 76, 111, 110, 103, 49, 48, 50, 52,
				0, 0, 0, 0, 32, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 67, 111, 110, 99, 117, 114, 114,
				101, 110, 116, 77, 97, 115, 107, 0, 0, 0,
				0, 54, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				76, 111, 119, 76, 101, 118, 101, 108, 46, 85,
				110, 115, 97, 102, 101, 124, 68, 97, 116, 97,
				83, 116, 114, 101, 97, 109, 69, 120, 116, 101,
				110, 115, 105, 111, 110, 115, 0, 0, 0, 0,
				34, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 124, 68,
				97, 116, 97, 83, 116, 114, 101, 97, 109, 82,
				101, 97, 100, 101, 114, 0, 0, 0, 0, 26,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 124, 67,
				111, 110, 116, 101, 120, 116, 0, 0, 0, 0,
				34, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 124, 68,
				97, 116, 97, 83, 116, 114, 101, 97, 109, 87,
				114, 105, 116, 101, 114, 0, 0, 0, 0, 29,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 124, 83,
				116, 114, 101, 97, 109, 68, 97, 116, 97, 0,
				0, 0, 0, 22, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 124, 80, 97, 105, 114, 0, 0, 0, 0,
				26, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 124, 76,
				105, 115, 116, 80, 97, 105, 114, 0, 0, 0,
				0, 44, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 124,
				68, 111, 117, 98, 108, 101, 82, 101, 119, 105,
				110, 100, 97, 98, 108, 101, 65, 108, 108, 111,
				99, 97, 116, 111, 114, 115, 1, 0, 0, 0,
				27, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 124, 70,
				105, 120, 101, 100, 76, 105, 115, 116, 1, 0,
				0, 0, 27, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				124, 70, 105, 120, 101, 100, 76, 105, 115, 116,
				0, 0, 0, 0, 34, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 70, 105, 120, 101, 100, 76, 105,
				115, 116, 51, 50, 66, 121, 116, 101, 115, 1,
				0, 0, 0, 29, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 124, 69, 110, 117, 109, 101, 114, 97,
				116, 111, 114, 0, 0, 0, 0, 44, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 124, 70, 105, 120, 101,
				100, 76, 105, 115, 116, 51, 50, 66, 121, 116,
				101, 115, 69, 120, 116, 101, 110, 115, 105, 111,
				110, 115, 0, 0, 0, 0, 43, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 124, 70, 105, 120, 101, 100,
				76, 105, 115, 116, 51, 50, 66, 121, 116, 101,
				115, 68, 101, 98, 117, 103, 86, 105, 101, 119,
				0, 0, 0, 0, 34, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 70, 105, 120, 101, 100, 76, 105,
				115, 116, 54, 52, 66, 121, 116, 101, 115, 1,
				0, 0, 0, 29, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 124, 69, 110, 117, 109, 101, 114, 97,
				116, 111, 114, 0, 0, 0, 0, 44, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 124, 70, 105, 120, 101,
				100, 76, 105, 115, 116, 54, 52, 66, 121, 116,
				101, 115, 69, 120, 116, 101, 110, 115, 105, 111,
				110, 115, 0, 0, 0, 0, 43, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 124, 70, 105, 120, 101, 100,
				76, 105, 115, 116, 54, 52, 66, 121, 116, 101,
				115, 68, 101, 98, 117, 103, 86, 105, 101, 119,
				0, 0, 0, 0, 35, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 70, 105, 120, 101, 100, 76, 105,
				115, 116, 49, 50, 56, 66, 121, 116, 101, 115,
				1, 0, 0, 0, 29, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 46, 124, 69, 110, 117, 109, 101, 114,
				97, 116, 111, 114, 0, 0, 0, 0, 45, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 124, 70, 105, 120,
				101, 100, 76, 105, 115, 116, 49, 50, 56, 66,
				121, 116, 101, 115, 69, 120, 116, 101, 110, 115,
				105, 111, 110, 115, 0, 0, 0, 0, 44, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 124, 70, 105, 120,
				101, 100, 76, 105, 115, 116, 49, 50, 56, 66,
				121, 116, 101, 115, 68, 101, 98, 117, 103, 86,
				105, 101, 119, 0, 0, 0, 0, 35, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 124, 70, 105, 120, 101,
				100, 76, 105, 115, 116, 53, 49, 50, 66, 121,
				116, 101, 115, 1, 0, 0, 0, 29, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 46, 124, 69, 110, 117,
				109, 101, 114, 97, 116, 111, 114, 0, 0, 0,
				0, 45, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 124,
				70, 105, 120, 101, 100, 76, 105, 115, 116, 53,
				49, 50, 66, 121, 116, 101, 115, 69, 120, 116,
				101, 110, 115, 105, 111, 110, 115, 0, 0, 0,
				0, 44, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 124,
				70, 105, 120, 101, 100, 76, 105, 115, 116, 53,
				49, 50, 66, 121, 116, 101, 115, 68, 101, 98,
				117, 103, 86, 105, 101, 119, 0, 0, 0, 0,
				36, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 124, 70,
				105, 120, 101, 100, 76, 105, 115, 116, 52, 48,
				57, 54, 66, 121, 116, 101, 115, 1, 0, 0,
				0, 29, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				124, 69, 110, 117, 109, 101, 114, 97, 116, 111,
				114, 0, 0, 0, 0, 46, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 124, 70, 105, 120, 101, 100, 76,
				105, 115, 116, 52, 48, 57, 54, 66, 121, 116,
				101, 115, 69, 120, 116, 101, 110, 115, 105, 111,
				110, 115, 0, 0, 0, 0, 45, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 124, 70, 105, 120, 101, 100,
				76, 105, 115, 116, 52, 48, 57, 54, 66, 121,
				116, 101, 115, 68, 101, 98, 117, 103, 86, 105,
				101, 119, 0, 0, 0, 0, 37, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 124, 70, 105, 120, 101, 100,
				76, 105, 115, 116, 69, 120, 116, 101, 110, 115,
				105, 111, 110, 115, 0, 0, 0, 0, 36, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 124, 70, 105, 120,
				101, 100, 66, 121, 116, 101, 115, 49, 54, 65,
				108, 105, 103, 110, 56, 0, 0, 0, 0, 30,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 70, 105,
				120, 101, 100, 66, 121, 116, 101, 115, 49, 54,
				0, 0, 0, 0, 36, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 70, 105, 120, 101, 100, 66, 121,
				116, 101, 115, 51, 50, 65, 108, 105, 103, 110,
				56, 0, 0, 0, 0, 36, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 124, 70, 105, 120, 101, 100, 66,
				121, 116, 101, 115, 54, 52, 65, 108, 105, 103,
				110, 56, 0, 0, 0, 0, 37, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 124, 70, 105, 120, 101, 100,
				66, 121, 116, 101, 115, 49, 50, 56, 65, 108,
				105, 103, 110, 56, 0, 0, 0, 0, 37, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 124, 70, 105, 120,
				101, 100, 66, 121, 116, 101, 115, 53, 49, 50,
				65, 108, 105, 103, 110, 56, 0, 0, 0, 0,
				38, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 124, 70,
				105, 120, 101, 100, 66, 121, 116, 101, 115, 52,
				48, 57, 54, 65, 108, 105, 103, 110, 56, 0,
				0, 0, 0, 30, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 124, 70, 105, 120, 101, 100, 66, 121, 116,
				101, 115, 51, 48, 0, 0, 0, 0, 36, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 124, 70, 105, 120,
				101, 100, 83, 116, 114, 105, 110, 103, 51, 50,
				66, 121, 116, 101, 115, 1, 0, 0, 0, 29,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 124, 69,
				110, 117, 109, 101, 114, 97, 116, 111, 114, 0,
				0, 0, 0, 30, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 124, 70, 105, 120, 101, 100, 66, 121, 116,
				101, 115, 54, 50, 0, 0, 0, 0, 36, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 124, 70, 105, 120,
				101, 100, 83, 116, 114, 105, 110, 103, 54, 52,
				66, 121, 116, 101, 115, 1, 0, 0, 0, 29,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 124, 69,
				110, 117, 109, 101, 114, 97, 116, 111, 114, 0,
				0, 0, 0, 31, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 124, 70, 105, 120, 101, 100, 66, 121, 116,
				101, 115, 49, 50, 54, 0, 0, 0, 0, 37,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 70, 105,
				120, 101, 100, 83, 116, 114, 105, 110, 103, 49,
				50, 56, 66, 121, 116, 101, 115, 1, 0, 0,
				0, 29, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				124, 69, 110, 117, 109, 101, 114, 97, 116, 111,
				114, 0, 0, 0, 0, 31, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 124, 70, 105, 120, 101, 100, 66,
				121, 116, 101, 115, 53, 49, 48, 0, 0, 0,
				0, 37, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 124,
				70, 105, 120, 101, 100, 83, 116, 114, 105, 110,
				103, 53, 49, 50, 66, 121, 116, 101, 115, 1,
				0, 0, 0, 29, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 124, 69, 110, 117, 109, 101, 114, 97,
				116, 111, 114, 0, 0, 0, 0, 32, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 124, 70, 105, 120, 101,
				100, 66, 121, 116, 101, 115, 52, 48, 57, 52,
				0, 0, 0, 0, 38, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 70, 105, 120, 101, 100, 83, 116,
				114, 105, 110, 103, 52, 48, 57, 54, 66, 121,
				116, 101, 115, 1, 0, 0, 0, 29, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 46, 124, 69, 110, 117,
				109, 101, 114, 97, 116, 111, 114, 1, 0, 0,
				0, 36, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 124,
				70, 105, 120, 101, 100, 83, 116, 114, 105, 110,
				103, 77, 101, 116, 104, 111, 100, 115, 0, 0,
				0, 0, 29, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				124, 70, 105, 120, 101, 100, 83, 116, 114, 105,
				110, 103, 1, 0, 0, 0, 36, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 124, 70, 105, 120, 101, 100,
				83, 116, 114, 105, 110, 103, 77, 101, 116, 104,
				111, 100, 115, 1, 0, 0, 0, 36, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 124, 70, 105, 120, 101,
				100, 83, 116, 114, 105, 110, 103, 77, 101, 116,
				104, 111, 100, 115, 1, 0, 0, 0, 36, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 124, 70, 105, 120,
				101, 100, 83, 116, 114, 105, 110, 103, 77, 101,
				116, 104, 111, 100, 115, 1, 0, 0, 0, 36,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 70, 105,
				120, 101, 100, 83, 116, 114, 105, 110, 103, 77,
				101, 116, 104, 111, 100, 115, 0, 0, 0, 0,
				28, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 124, 73,
				85, 84, 70, 56, 66, 121, 116, 101, 115, 0,
				0, 0, 0, 34, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 124, 70, 105, 120, 101, 100, 83, 116, 114,
				105, 110, 103, 85, 116, 105, 108, 115, 0, 0,
				0, 0, 49, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				46, 70, 105, 120, 101, 100, 83, 116, 114, 105,
				110, 103, 85, 116, 105, 108, 115, 124, 85, 105,
				110, 116, 70, 108, 111, 97, 116, 85, 110, 105,
				111, 110, 0, 0, 0, 0, 42, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 124, 66, 117, 114, 115, 116,
				67, 111, 109, 112, 97, 116, 105, 98, 108, 101,
				65, 116, 116, 114, 105, 98, 117, 116, 101, 0,
				0, 0, 0, 61, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 124, 71, 101, 110, 101, 114, 97, 116, 101,
				84, 101, 115, 116, 115, 70, 111, 114, 66, 117,
				114, 115, 116, 67, 111, 109, 112, 97, 116, 105,
				98, 105, 108, 105, 116, 121, 65, 116, 116, 114,
				105, 98, 117, 116, 101, 0, 0, 0, 0, 56,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 69, 120,
				99, 108, 117, 100, 101, 70, 114, 111, 109, 66,
				117, 114, 115, 116, 67, 111, 109, 112, 97, 116,
				84, 101, 115, 116, 105, 110, 103, 65, 116, 116,
				114, 105, 98, 117, 116, 101, 0, 0, 0, 0,
				27, 85, 110, 105, 116, 121, 46, 74, 111, 98,
				115, 124, 69, 97, 114, 108, 121, 73, 110, 105,
				116, 72, 101, 108, 112, 101, 114, 115, 0, 0,
				0, 0, 41, 85, 110, 105, 116, 121, 46, 74,
				111, 98, 115, 124, 74, 111, 98, 80, 97, 114,
				97, 108, 108, 101, 108, 73, 110, 100, 101, 120,
				76, 105, 115, 116, 69, 120, 116, 101, 110, 115,
				105, 111, 110, 115, 0, 0, 0, 0, 32, 85,
				110, 105, 116, 121, 46, 74, 111, 98, 115, 124,
				73, 74, 111, 98, 80, 97, 114, 97, 108, 108,
				101, 108, 70, 111, 114, 70, 105, 108, 116, 101,
				114, 0, 0, 0, 0, 21, 85, 110, 105, 116,
				121, 46, 74, 111, 98, 115, 124, 73, 74, 111,
				98, 70, 105, 108, 116, 101, 114, 0, 0, 0,
				0, 31, 85, 110, 105, 116, 121, 46, 74, 111,
				98, 115, 124, 73, 74, 111, 98, 70, 105, 108,
				116, 101, 114, 69, 120, 116, 101, 110, 115, 105,
				111, 110, 115, 0, 0, 0, 0, 49, 85, 110,
				105, 116, 121, 46, 74, 111, 98, 115, 46, 73,
				74, 111, 98, 70, 105, 108, 116, 101, 114, 69,
				120, 116, 101, 110, 115, 105, 111, 110, 115, 124,
				74, 111, 98, 70, 105, 108, 116, 101, 114, 80,
				114, 111, 100, 117, 99, 101, 114, 0, 0, 0,
				0, 43, 85, 110, 105, 116, 121, 46, 74, 111,
				98, 115, 46, 73, 74, 111, 98, 70, 105, 108,
				116, 101, 114, 69, 120, 116, 101, 110, 115, 105,
				111, 110, 115, 43, 124, 74, 111, 98, 87, 114,
				97, 112, 112, 101, 114, 0, 0, 0, 0, 31,
				85, 110, 105, 116, 121, 46, 74, 111, 98, 115,
				124, 73, 74, 111, 98, 80, 97, 114, 97, 108,
				108, 101, 108, 70, 111, 114, 66, 97, 116, 99,
				104, 0, 0, 0, 0, 41, 85, 110, 105, 116,
				121, 46, 74, 111, 98, 115, 124, 73, 74, 111,
				98, 80, 97, 114, 97, 108, 108, 101, 108, 70,
				111, 114, 66, 97, 116, 99, 104, 69, 120, 116,
				101, 110, 115, 105, 111, 110, 115, 0, 0, 0,
				0, 69, 85, 110, 105, 116, 121, 46, 74, 111,
				98, 115, 46, 73, 74, 111, 98, 80, 97, 114,
				97, 108, 108, 101, 108, 70, 111, 114, 66, 97,
				116, 99, 104, 69, 120, 116, 101, 110, 115, 105,
				111, 110, 115, 124, 74, 111, 98, 80, 97, 114,
				97, 108, 108, 101, 108, 70, 111, 114, 66, 97,
				116, 99, 104, 80, 114, 111, 100, 117, 99, 101,
				114, 0, 0, 0, 0, 31, 85, 110, 105, 116,
				121, 46, 74, 111, 98, 115, 124, 73, 74, 111,
				98, 80, 97, 114, 97, 108, 108, 101, 108, 70,
				111, 114, 68, 101, 102, 101, 114, 0, 0, 0,
				0, 41, 85, 110, 105, 116, 121, 46, 74, 111,
				98, 115, 124, 73, 74, 111, 98, 80, 97, 114,
				97, 108, 108, 101, 108, 70, 111, 114, 68, 101,
				102, 101, 114, 69, 120, 116, 101, 110, 115, 105,
				111, 110, 115, 0, 0, 0, 0, 69, 85, 110,
				105, 116, 121, 46, 74, 111, 98, 115, 46, 73,
				74, 111, 98, 80, 97, 114, 97, 108, 108, 101,
				108, 70, 111, 114, 68, 101, 102, 101, 114, 69,
				120, 116, 101, 110, 115, 105, 111, 110, 115, 124,
				74, 111, 98, 80, 97, 114, 97, 108, 108, 101,
				108, 70, 111, 114, 68, 101, 102, 101, 114, 80,
				114, 111, 100, 117, 99, 101, 114, 0, 0, 0,
				0, 42, 85, 110, 105, 116, 121, 46, 74, 111,
				98, 115, 124, 82, 101, 103, 105, 115, 116, 101,
				114, 71, 101, 110, 101, 114, 105, 99, 74, 111,
				98, 84, 121, 112, 101, 65, 116, 116, 114, 105,
				98, 117, 116, 101, 0, 0, 0, 0, 41, 85,
				110, 105, 116, 121, 46, 74, 111, 98, 115, 124,
				68, 79, 84, 83, 67, 111, 109, 112, 105, 108,
				101, 114, 71, 101, 110, 101, 114, 97, 116, 101,
				100, 65, 116, 116, 114, 105, 98, 117, 116, 101,
				0, 0, 0, 0, 32, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 76, 105, 115, 116, 69, 120, 116,
				101, 110, 115, 105, 111, 110, 115, 0, 0, 0,
				0, 24, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 124,
				77, 101, 109, 111, 114, 121, 0, 0, 0, 0,
				28, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 124,
				85, 110, 109, 97, 110, 97, 103, 101, 100, 0,
				0, 0, 0, 25, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 46, 124, 65, 114, 114, 97, 121, 0,
				0, 0, 0, 24, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 124, 65, 114, 114, 97, 121, 0, 0,
				0, 0, 39, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				124, 78, 97, 116, 105, 118, 101, 65, 114, 114,
				97, 121, 69, 120, 116, 101, 110, 115, 105, 111,
				110, 115, 0, 0, 0, 0, 59, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 46, 78, 97, 116, 105, 118,
				101, 65, 114, 114, 97, 121, 69, 120, 116, 101,
				110, 115, 105, 111, 110, 115, 124, 78, 97, 116,
				105, 118, 101, 65, 114, 114, 97, 121, 83, 116,
				97, 116, 105, 99, 73, 100, 0, 0, 0, 0,
				32, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 124, 78,
				97, 116, 105, 118, 101, 66, 105, 116, 65, 114,
				114, 97, 121, 1, 0, 0, 0, 27, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 46, 124, 82, 101, 97,
				100, 79, 110, 108, 121, 0, 0, 0, 0, 39,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 78, 97,
				116, 105, 118, 101, 66, 105, 116, 65, 114, 114,
				97, 121, 68, 105, 115, 112, 111, 115, 101, 0,
				0, 0, 0, 42, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 124, 78, 97, 116, 105, 118, 101, 66, 105,
				116, 65, 114, 114, 97, 121, 68, 105, 115, 112,
				111, 115, 101, 74, 111, 98, 0, 0, 0, 0,
				61, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 76,
				111, 119, 76, 101, 118, 101, 108, 46, 85, 110,
				115, 97, 102, 101, 124, 78, 97, 116, 105, 118,
				101, 66, 105, 116, 65, 114, 114, 97, 121, 85,
				110, 115, 97, 102, 101, 85, 116, 105, 108, 105,
				116, 121, 0, 0, 0, 0, 38, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 124, 78, 97, 116, 105, 118,
				101, 72, 97, 115, 104, 77, 97, 112, 68, 105,
				115, 112, 111, 115, 101, 0, 0, 0, 0, 41,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 78, 97,
				116, 105, 118, 101, 72, 97, 115, 104, 77, 97,
				112, 68, 105, 115, 112, 111, 115, 101, 74, 111,
				98, 0, 0, 0, 0, 24, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 124, 75, 86, 80, 97, 105, 114,
				0, 0, 0, 0, 31, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 78, 97, 116, 105, 118, 101, 72,
				97, 115, 104, 77, 97, 112, 1, 0, 0, 0,
				29, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 124,
				69, 110, 117, 109, 101, 114, 97, 116, 111, 114,
				1, 0, 0, 0, 27, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 46, 124, 82, 101, 97, 100, 79, 110,
				108, 121, 0, 0, 0, 0, 48, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 124, 78, 97, 116, 105, 118,
				101, 72, 97, 115, 104, 77, 97, 112, 68, 101,
				98, 117, 103, 103, 101, 114, 84, 121, 112, 101,
				80, 114, 111, 120, 121, 0, 0, 0, 0, 31,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 78, 97,
				116, 105, 118, 101, 72, 97, 115, 104, 83, 101,
				116, 1, 0, 0, 0, 29, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 46, 124, 69, 110, 117, 109, 101,
				114, 97, 116, 111, 114, 1, 0, 0, 0, 27,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 124, 82,
				101, 97, 100, 79, 110, 108, 121, 0, 0, 0,
				0, 48, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 124,
				78, 97, 116, 105, 118, 101, 72, 97, 115, 104,
				83, 101, 116, 68, 101, 98, 117, 103, 103, 101,
				114, 84, 121, 112, 101, 80, 114, 111, 120, 121,
				0, 0, 0, 0, 28, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 73, 73, 110, 100, 101, 120, 97,
				98, 108, 101, 0, 0, 0, 0, 29, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 124, 73, 78, 97, 116,
				105, 118, 101, 76, 105, 115, 116, 0, 0, 0,
				0, 28, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 124,
				78, 97, 116, 105, 118, 101, 76, 105, 115, 116,
				1, 0, 0, 0, 33, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 46, 124, 80, 97, 114, 97, 108, 108,
				101, 108, 87, 114, 105, 116, 101, 114, 0, 0,
				0, 0, 35, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				124, 78, 97, 116, 105, 118, 101, 76, 105, 115,
				116, 68, 105, 115, 112, 111, 115, 101, 0, 0,
				0, 0, 38, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				124, 78, 97, 116, 105, 118, 101, 76, 105, 115,
				116, 68, 105, 115, 112, 111, 115, 101, 74, 111,
				98, 0, 0, 0, 0, 37, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 124, 78, 97, 116, 105, 118, 101,
				76, 105, 115, 116, 68, 101, 98, 117, 103, 86,
				105, 101, 119, 0, 0, 0, 0, 38, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 124, 78, 97, 116, 105,
				118, 101, 76, 105, 115, 116, 69, 120, 116, 101,
				110, 115, 105, 111, 110, 115, 0, 0, 0, 0,
				57, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 76,
				111, 119, 76, 101, 118, 101, 108, 46, 85, 110,
				115, 97, 102, 101, 124, 78, 97, 116, 105, 118,
				101, 76, 105, 115, 116, 85, 110, 115, 97, 102,
				101, 85, 116, 105, 108, 105, 116, 121, 0, 0,
				0, 0, 47, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				46, 78, 111, 116, 66, 117, 114, 115, 116, 67,
				111, 109, 112, 97, 116, 105, 98, 108, 101, 124,
				69, 120, 116, 101, 110, 115, 105, 111, 110, 115,
				0, 0, 0, 0, 38, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 78, 97, 116, 105, 118, 101, 75,
				101, 121, 86, 97, 108, 117, 101, 65, 114, 114,
				97, 121, 115, 0, 0, 0, 0, 39, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 124, 78, 97, 116, 105,
				118, 101, 80, 97, 114, 97, 108, 108, 101, 108,
				72, 97, 115, 104, 77, 97, 112, 1, 0, 0,
				0, 27, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				124, 82, 101, 97, 100, 79, 110, 108, 121, 1,
				0, 0, 0, 33, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 124, 80, 97, 114, 97, 108, 108, 101,
				108, 87, 114, 105, 116, 101, 114, 1, 0, 0,
				0, 29, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				124, 69, 110, 117, 109, 101, 114, 97, 116, 111,
				114, 0, 0, 0, 0, 56, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 124, 78, 97, 116, 105, 118, 101,
				80, 97, 114, 97, 108, 108, 101, 108, 72, 97,
				115, 104, 77, 97, 112, 68, 101, 98, 117, 103,
				103, 101, 114, 84, 121, 112, 101, 80, 114, 111,
				120, 121, 0, 0, 0, 0, 49, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 124, 78, 97, 116, 105, 118,
				101, 80, 97, 114, 97, 108, 108, 101, 108, 72,
				97, 115, 104, 77, 97, 112, 69, 120, 116, 101,
				110, 115, 105, 111, 110, 115, 0, 0, 0, 0,
				39, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 124, 78,
				97, 116, 105, 118, 101, 80, 97, 114, 97, 108,
				108, 101, 108, 72, 97, 115, 104, 83, 101, 116,
				1, 0, 0, 0, 33, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 46, 124, 80, 97, 114, 97, 108, 108,
				101, 108, 87, 114, 105, 116, 101, 114, 1, 0,
				0, 0, 29, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				46, 124, 69, 110, 117, 109, 101, 114, 97, 116,
				111, 114, 1, 0, 0, 0, 27, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 46, 124, 82, 101, 97, 100,
				79, 110, 108, 121, 0, 0, 0, 0, 56, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 124, 78, 97, 116,
				105, 118, 101, 80, 97, 114, 97, 108, 108, 101,
				108, 72, 97, 115, 104, 83, 101, 116, 68, 101,
				98, 117, 103, 103, 101, 114, 84, 121, 112, 101,
				80, 114, 111, 120, 121, 0, 0, 0, 0, 35,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 72, 97,
				115, 104, 83, 101, 116, 69, 120, 116, 101, 110,
				115, 105, 111, 110, 115, 0, 0, 0, 0, 52,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 78, 97,
				116, 105, 118, 101, 80, 97, 114, 97, 108, 108,
				101, 108, 77, 117, 108, 116, 105, 72, 97, 115,
				104, 77, 97, 112, 73, 116, 101, 114, 97, 116,
				111, 114, 0, 0, 0, 0, 44, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 124, 78, 97, 116, 105, 118,
				101, 80, 97, 114, 97, 108, 108, 101, 108, 77,
				117, 108, 116, 105, 72, 97, 115, 104, 77, 97,
				112, 1, 0, 0, 0, 33, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 46, 124, 80, 97, 114, 97, 108,
				108, 101, 108, 87, 114, 105, 116, 101, 114, 1,
				0, 0, 0, 29, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 124, 69, 110, 117, 109, 101, 114, 97,
				116, 111, 114, 0, 0, 0, 0, 37, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 46, 124, 75, 101, 121,
				86, 97, 108, 117, 101, 69, 110, 117, 109, 101,
				114, 97, 116, 111, 114, 1, 0, 0, 0, 27,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 124, 82,
				101, 97, 100, 79, 110, 108, 121, 0, 0, 0,
				0, 61, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 124,
				78, 97, 116, 105, 118, 101, 80, 97, 114, 97,
				108, 108, 101, 108, 77, 117, 108, 116, 105, 72,
				97, 115, 104, 77, 97, 112, 68, 101, 98, 117,
				103, 103, 101, 114, 84, 121, 112, 101, 80, 114,
				111, 120, 121, 0, 0, 0, 0, 54, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 124, 78, 97, 116, 105,
				118, 101, 80, 97, 114, 97, 108, 108, 101, 108,
				77, 117, 108, 116, 105, 72, 97, 115, 104, 77,
				97, 112, 69, 120, 116, 101, 110, 115, 105, 111,
				110, 115, 0, 0, 0, 0, 29, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 124, 78, 97, 116, 105, 118,
				101, 81, 117, 101, 117, 101, 1, 0, 0, 0,
				29, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 124,
				69, 110, 117, 109, 101, 114, 97, 116, 111, 114,
				1, 0, 0, 0, 27, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 46, 124, 82, 101, 97, 100, 79, 110,
				108, 121, 1, 0, 0, 0, 33, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 46, 124, 80, 97, 114, 97,
				108, 108, 101, 108, 87, 114, 105, 116, 101, 114,
				0, 0, 0, 0, 36, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 78, 97, 116, 105, 118, 101, 81,
				117, 101, 117, 101, 68, 105, 115, 112, 111, 115,
				101, 0, 0, 0, 0, 39, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 124, 78, 97, 116, 105, 118, 101,
				81, 117, 101, 117, 101, 68, 105, 115, 112, 111,
				115, 101, 74, 111, 98, 0, 0, 0, 0, 33,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 78, 97,
				116, 105, 118, 101, 82, 101, 102, 101, 114, 101,
				110, 99, 101, 1, 0, 0, 0, 27, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 46, 124, 82, 101, 97,
				100, 79, 110, 108, 121, 0, 0, 0, 0, 40,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 78, 97,
				116, 105, 118, 101, 82, 101, 102, 101, 114, 101,
				110, 99, 101, 68, 105, 115, 112, 111, 115, 101,
				0, 0, 0, 0, 43, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 78, 97, 116, 105, 118, 101, 82,
				101, 102, 101, 114, 101, 110, 99, 101, 68, 105,
				115, 112, 111, 115, 101, 74, 111, 98, 0, 0,
				0, 0, 62, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				46, 76, 111, 119, 76, 101, 118, 101, 108, 46,
				85, 110, 115, 97, 102, 101, 124, 78, 97, 116,
				105, 118, 101, 82, 101, 102, 101, 114, 101, 110,
				99, 101, 85, 110, 115, 97, 102, 101, 85, 116,
				105, 108, 105, 116, 121, 0, 0, 0, 0, 33,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 78, 97,
				116, 105, 118, 101, 82, 105, 110, 103, 81, 117,
				101, 117, 101, 0, 0, 0, 0, 42, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 124, 78, 97, 116, 105,
				118, 101, 82, 105, 110, 103, 81, 117, 101, 117,
				101, 68, 101, 98, 117, 103, 86, 105, 101, 119,
				0, 0, 0, 0, 40, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 78, 97, 116, 105, 118, 101, 82,
				105, 110, 103, 81, 117, 101, 117, 101, 68, 105,
				115, 112, 111, 115, 101, 0, 0, 0, 0, 43,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 78, 97,
				116, 105, 118, 101, 82, 105, 110, 103, 81, 117,
				101, 117, 101, 68, 105, 115, 112, 111, 115, 101,
				74, 111, 98, 0, 0, 0, 0, 37, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 124, 78, 97, 116, 105,
				118, 101, 83, 111, 114, 116, 69, 120, 116, 101,
				110, 115, 105, 111, 110, 0, 0, 0, 0, 53,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 78, 97,
				116, 105, 118, 101, 83, 111, 114, 116, 69, 120,
				116, 101, 110, 115, 105, 111, 110, 124, 68, 101,
				102, 97, 117, 108, 116, 67, 111, 109, 112, 97,
				114, 101, 114, 0, 0, 0, 0, 25, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 124, 83, 111, 114, 116,
				74, 111, 98, 1, 0, 0, 0, 30, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 46, 124, 83, 101, 103,
				109, 101, 110, 116, 83, 111, 114, 116, 1, 0,
				0, 0, 35, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				46, 124, 83, 101, 103, 109, 101, 110, 116, 83,
				111, 114, 116, 77, 101, 114, 103, 101, 0, 0,
				0, 0, 30, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				124, 83, 111, 114, 116, 74, 111, 98, 68, 101,
				102, 101, 114, 1, 0, 0, 0, 30, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 46, 124, 83, 101, 103,
				109, 101, 110, 116, 83, 111, 114, 116, 1, 0,
				0, 0, 35, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				46, 124, 83, 101, 103, 109, 101, 110, 116, 83,
				111, 114, 116, 77, 101, 114, 103, 101, 0, 0,
				0, 0, 30, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				124, 78, 97, 116, 105, 118, 101, 83, 116, 114,
				101, 97, 109, 0, 0, 0, 0, 35, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 46, 124, 67, 111, 110,
				115, 116, 114, 117, 99, 116, 74, 111, 98, 76,
				105, 115, 116, 0, 0, 0, 0, 31, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 46, 124, 67, 111, 110,
				115, 116, 114, 117, 99, 116, 74, 111, 98, 0,
				0, 0, 0, 25, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 124, 87, 114, 105, 116, 101, 114, 0,
				0, 0, 0, 25, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 124, 82, 101, 97, 100, 101, 114, 0,
				0, 0, 0, 37, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 124, 78, 97, 116, 105, 118, 101, 83, 116,
				114, 101, 97, 109, 68, 105, 115, 112, 111, 115,
				101, 0, 0, 0, 0, 40, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 124, 78, 97, 116, 105, 118, 101,
				83, 116, 114, 101, 97, 109, 68, 105, 115, 112,
				111, 115, 101, 74, 111, 98, 0, 0, 0, 0,
				28, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 124, 78,
				97, 116, 105, 118, 101, 84, 101, 120, 116, 1,
				0, 0, 0, 29, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 124, 69, 110, 117, 109, 101, 114, 97,
				116, 111, 114, 1, 0, 0, 0, 27, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 46, 124, 82, 101, 97,
				100, 79, 110, 108, 121, 0, 0, 0, 0, 35,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 78, 97,
				116, 105, 118, 101, 84, 101, 120, 116, 68, 105,
				115, 112, 111, 115, 101, 0, 0, 0, 0, 38,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 78, 97,
				116, 105, 118, 101, 84, 101, 120, 116, 68, 105,
				115, 112, 111, 115, 101, 74, 111, 98, 0, 0,
				0, 0, 32, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				124, 85, 110, 109, 97, 110, 97, 103, 101, 100,
				65, 114, 114, 97, 121, 0, 0, 0, 0, 37,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 124, 82, 101,
				119, 105, 110, 100, 97, 98, 108, 101, 65, 108,
				108, 111, 99, 97, 116, 111, 114, 0, 0, 0,
				0, 24, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				124, 85, 110, 105, 111, 110, 0, 0, 0, 0,
				30, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 124,
				77, 101, 109, 111, 114, 121, 66, 108, 111, 99,
				107, 0, 0, 0, 0, 40, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 124, 83, 116, 114, 101, 97, 109,
				67, 111, 109, 112, 114, 101, 115, 115, 105, 111,
				110, 77, 111, 100, 101, 108, 0, 0, 0, 0,
				47, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 124,
				83, 104, 97, 114, 101, 100, 83, 116, 97, 116,
				105, 99, 67, 111, 109, 112, 114, 101, 115, 115,
				105, 111, 110, 77, 111, 100, 101, 108, 0, 0,
				0, 0, 27, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				124, 85, 73, 110, 116, 70, 108, 111, 97, 116,
				0, 0, 0, 0, 25, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 85, 110, 105, 99, 111, 100, 101,
				0, 0, 0, 0, 23, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 46, 124, 82, 117, 110, 101, 0, 0,
				0, 0, 52, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				46, 76, 111, 119, 76, 101, 118, 101, 108, 46,
				85, 110, 115, 97, 102, 101, 124, 85, 110, 115,
				97, 102, 101, 65, 112, 112, 101, 110, 100, 66,
				117, 102, 102, 101, 114, 1, 0, 0, 0, 41,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 76, 111,
				119, 76, 101, 118, 101, 108, 46, 85, 110, 115,
				97, 102, 101, 46, 124, 82, 101, 97, 100, 101,
				114, 0, 0, 0, 0, 55, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 46, 76, 111, 119, 76, 101, 118,
				101, 108, 46, 85, 110, 115, 97, 102, 101, 124,
				85, 110, 115, 97, 102, 101, 65, 116, 111, 109,
				105, 99, 67, 111, 117, 110, 116, 101, 114, 51,
				50, 0, 0, 0, 0, 55, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 46, 76, 111, 119, 76, 101, 118,
				101, 108, 46, 85, 110, 115, 97, 102, 101, 124,
				85, 110, 115, 97, 102, 101, 65, 116, 111, 109,
				105, 99, 67, 111, 117, 110, 116, 101, 114, 54,
				52, 0, 0, 0, 0, 48, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 46, 76, 111, 119, 76, 101, 118,
				101, 108, 46, 85, 110, 115, 97, 102, 101, 124,
				85, 110, 115, 97, 102, 101, 66, 105, 116, 65,
				114, 114, 97, 121, 1, 0, 0, 0, 43, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 46, 76, 111, 119,
				76, 101, 118, 101, 108, 46, 85, 110, 115, 97,
				102, 101, 46, 124, 82, 101, 97, 100, 79, 110,
				108, 121, 0, 0, 0, 0, 57, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 46, 76, 111, 119, 76, 101,
				118, 101, 108, 46, 85, 110, 115, 97, 102, 101,
				124, 85, 110, 115, 97, 102, 101, 66, 105, 116,
				65, 114, 114, 97, 121, 68, 101, 98, 117, 103,
				86, 105, 101, 119, 0, 0, 0, 0, 47, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 46, 76, 111, 119,
				76, 101, 118, 101, 108, 46, 85, 110, 115, 97,
				102, 101, 124, 72, 97, 115, 104, 77, 97, 112,
				72, 101, 108, 112, 101, 114, 1, 0, 0, 0,
				45, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 76,
				111, 119, 76, 101, 118, 101, 108, 46, 85, 110,
				115, 97, 102, 101, 46, 124, 69, 110, 117, 109,
				101, 114, 97, 116, 111, 114, 0, 0, 0, 0,
				47, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 76,
				111, 119, 76, 101, 118, 101, 108, 46, 85, 110,
				115, 97, 102, 101, 124, 85, 110, 115, 97, 102,
				101, 72, 97, 115, 104, 77, 97, 112, 1, 0,
				0, 0, 45, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				46, 76, 111, 119, 76, 101, 118, 101, 108, 46,
				85, 110, 115, 97, 102, 101, 46, 124, 69, 110,
				117, 109, 101, 114, 97, 116, 111, 114, 1, 0,
				0, 0, 43, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				46, 76, 111, 119, 76, 101, 118, 101, 108, 46,
				85, 110, 115, 97, 102, 101, 46, 124, 82, 101,
				97, 100, 79, 110, 108, 121, 0, 0, 0, 0,
				64, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 76,
				111, 119, 76, 101, 118, 101, 108, 46, 85, 110,
				115, 97, 102, 101, 124, 85, 110, 115, 97, 102,
				101, 72, 97, 115, 104, 77, 97, 112, 68, 101,
				98, 117, 103, 103, 101, 114, 84, 121, 112, 101,
				80, 114, 111, 120, 121, 0, 0, 0, 0, 47,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 76, 111,
				119, 76, 101, 118, 101, 108, 46, 85, 110, 115,
				97, 102, 101, 124, 85, 110, 115, 97, 102, 101,
				72, 97, 115, 104, 83, 101, 116, 1, 0, 0,
				0, 45, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				76, 111, 119, 76, 101, 118, 101, 108, 46, 85,
				110, 115, 97, 102, 101, 46, 124, 69, 110, 117,
				109, 101, 114, 97, 116, 111, 114, 1, 0, 0,
				0, 43, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				76, 111, 119, 76, 101, 118, 101, 108, 46, 85,
				110, 115, 97, 102, 101, 46, 124, 82, 101, 97,
				100, 79, 110, 108, 121, 0, 0, 0, 0, 64,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 76, 111,
				119, 76, 101, 118, 101, 108, 46, 85, 110, 115,
				97, 102, 101, 124, 85, 110, 115, 97, 102, 101,
				72, 97, 115, 104, 83, 101, 116, 68, 101, 98,
				117, 103, 103, 101, 114, 84, 121, 112, 101, 80,
				114, 111, 120, 121, 0, 0, 0, 0, 50, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 46, 76, 111, 119,
				76, 101, 118, 101, 108, 46, 85, 110, 115, 97,
				102, 101, 124, 85, 110, 115, 97, 102, 101, 68,
				105, 115, 112, 111, 115, 101, 74, 111, 98, 0,
				0, 0, 0, 51, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 76, 111, 119, 76, 101, 118, 101, 108,
				46, 85, 110, 115, 97, 102, 101, 124, 85, 110,
				116, 121, 112, 101, 100, 85, 110, 115, 97, 102,
				101, 76, 105, 115, 116, 0, 0, 0, 0, 44,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 76, 111,
				119, 76, 101, 118, 101, 108, 46, 85, 110, 115,
				97, 102, 101, 124, 85, 110, 115, 97, 102, 101,
				76, 105, 115, 116, 1, 0, 0, 0, 43, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 46, 76, 111, 119,
				76, 101, 118, 101, 108, 46, 85, 110, 115, 97,
				102, 101, 46, 124, 82, 101, 97, 100, 79, 110,
				108, 121, 1, 0, 0, 0, 49, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 46, 76, 111, 119, 76, 101,
				118, 101, 108, 46, 85, 110, 115, 97, 102, 101,
				46, 124, 80, 97, 114, 97, 108, 108, 101, 108,
				82, 101, 97, 100, 101, 114, 1, 0, 0, 0,
				49, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 76,
				111, 119, 76, 101, 118, 101, 108, 46, 85, 110,
				115, 97, 102, 101, 46, 124, 80, 97, 114, 97,
				108, 108, 101, 108, 87, 114, 105, 116, 101, 114,
				1, 0, 0, 0, 45, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 46, 76, 111, 119, 76, 101, 118, 101,
				108, 46, 85, 110, 115, 97, 102, 101, 46, 124,
				69, 110, 117, 109, 101, 114, 97, 116, 111, 114,
				0, 0, 0, 0, 54, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 46, 76, 111, 119, 76, 101, 118, 101,
				108, 46, 85, 110, 115, 97, 102, 101, 124, 85,
				110, 115, 97, 102, 101, 76, 105, 115, 116, 69,
				120, 116, 101, 110, 115, 105, 111, 110, 115, 0,
				0, 0, 0, 54, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 76, 111, 119, 76, 101, 118, 101, 108,
				46, 85, 110, 115, 97, 102, 101, 124, 85, 110,
				115, 97, 102, 101, 76, 105, 115, 116, 84, 68,
				101, 98, 117, 103, 86, 105, 101, 119, 0, 0,
				0, 0, 47, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				46, 76, 111, 119, 76, 101, 118, 101, 108, 46,
				85, 110, 115, 97, 102, 101, 124, 85, 110, 115,
				97, 102, 101, 80, 116, 114, 76, 105, 115, 116,
				1, 0, 0, 0, 43, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 46, 76, 111, 119, 76, 101, 118, 101,
				108, 46, 85, 110, 115, 97, 102, 101, 46, 124,
				82, 101, 97, 100, 79, 110, 108, 121, 1, 0,
				0, 0, 49, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				46, 76, 111, 119, 76, 101, 118, 101, 108, 46,
				85, 110, 115, 97, 102, 101, 46, 124, 80, 97,
				114, 97, 108, 108, 101, 108, 82, 101, 97, 100,
				101, 114, 1, 0, 0, 0, 49, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 46, 76, 111, 119, 76, 101,
				118, 101, 108, 46, 85, 110, 115, 97, 102, 101,
				46, 124, 80, 97, 114, 97, 108, 108, 101, 108,
				87, 114, 105, 116, 101, 114, 0, 0, 0, 0,
				57, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 76,
				111, 119, 76, 101, 118, 101, 108, 46, 85, 110,
				115, 97, 102, 101, 124, 85, 110, 115, 97, 102,
				101, 80, 116, 114, 76, 105, 115, 116, 69, 120,
				116, 101, 110, 115, 105, 111, 110, 115, 0, 0,
				0, 0, 56, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				46, 76, 111, 119, 76, 101, 118, 101, 108, 46,
				85, 110, 115, 97, 102, 101, 124, 85, 110, 115,
				97, 102, 101, 80, 116, 114, 76, 105, 115, 116,
				68, 101, 98, 117, 103, 86, 105, 101, 119, 0,
				0, 0, 0, 63, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 76, 111, 119, 76, 101, 118, 101, 108,
				46, 85, 110, 115, 97, 102, 101, 46, 78, 111,
				116, 66, 117, 114, 115, 116, 67, 111, 109, 112,
				97, 116, 105, 98, 108, 101, 124, 69, 120, 116,
				101, 110, 115, 105, 111, 110, 115, 0, 0, 0,
				0, 65, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				76, 111, 119, 76, 101, 118, 101, 108, 46, 85,
				110, 115, 97, 102, 101, 124, 85, 110, 115, 97,
				102, 101, 80, 97, 114, 97, 108, 108, 101, 108,
				72, 97, 115, 104, 77, 97, 112, 66, 117, 99,
				107, 101, 116, 68, 97, 116, 97, 0, 0, 0,
				0, 59, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				76, 111, 119, 76, 101, 118, 101, 108, 46, 85,
				110, 115, 97, 102, 101, 124, 85, 110, 115, 97,
				102, 101, 80, 97, 114, 97, 108, 108, 101, 108,
				72, 97, 115, 104, 77, 97, 112, 68, 97, 116,
				97, 0, 0, 0, 0, 66, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 46, 76, 111, 119, 76, 101, 118,
				101, 108, 46, 85, 110, 115, 97, 102, 101, 124,
				85, 110, 115, 97, 102, 101, 80, 97, 114, 97,
				108, 108, 101, 108, 72, 97, 115, 104, 77, 97,
				112, 68, 97, 116, 97, 68, 105, 115, 112, 111,
				115, 101, 0, 0, 0, 0, 69, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 46, 76, 111, 119, 76, 101,
				118, 101, 108, 46, 85, 110, 115, 97, 102, 101,
				124, 85, 110, 115, 97, 102, 101, 80, 97, 114,
				97, 108, 108, 101, 108, 72, 97, 115, 104, 77,
				97, 112, 68, 97, 116, 97, 68, 105, 115, 112,
				111, 115, 101, 74, 111, 98, 0, 0, 0, 0,
				59, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 76,
				111, 119, 76, 101, 118, 101, 108, 46, 85, 110,
				115, 97, 102, 101, 124, 85, 110, 115, 97, 102,
				101, 80, 97, 114, 97, 108, 108, 101, 108, 72,
				97, 115, 104, 77, 97, 112, 66, 97, 115, 101,
				0, 0, 0, 0, 42, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 46, 76, 111, 119, 76, 101, 118, 101,
				108, 46, 85, 110, 115, 97, 102, 101, 124, 75,
				101, 121, 86, 97, 108, 117, 101, 0, 0, 0,
				0, 69, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				76, 111, 119, 76, 101, 118, 101, 108, 46, 85,
				110, 115, 97, 102, 101, 124, 85, 110, 115, 97,
				102, 101, 80, 97, 114, 97, 108, 108, 101, 108,
				72, 97, 115, 104, 77, 97, 112, 68, 97, 116,
				97, 69, 110, 117, 109, 101, 114, 97, 116, 111,
				114, 0, 0, 0, 0, 55, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 46, 76, 111, 119, 76, 101, 118,
				101, 108, 46, 85, 110, 115, 97, 102, 101, 124,
				85, 110, 115, 97, 102, 101, 80, 97, 114, 97,
				108, 108, 101, 108, 72, 97, 115, 104, 77, 97,
				112, 1, 0, 0, 0, 43, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 46, 76, 111, 119, 76, 101, 118,
				101, 108, 46, 85, 110, 115, 97, 102, 101, 46,
				124, 82, 101, 97, 100, 79, 110, 108, 121, 1,
				0, 0, 0, 49, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 76, 111, 119, 76, 101, 118, 101, 108,
				46, 85, 110, 115, 97, 102, 101, 46, 124, 80,
				97, 114, 97, 108, 108, 101, 108, 87, 114, 105,
				116, 101, 114, 1, 0, 0, 0, 45, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 46, 76, 111, 119, 76,
				101, 118, 101, 108, 46, 85, 110, 115, 97, 102,
				101, 46, 124, 69, 110, 117, 109, 101, 114, 97,
				116, 111, 114, 0, 0, 0, 0, 65, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 46, 76, 111, 119, 76,
				101, 118, 101, 108, 46, 85, 110, 115, 97, 102,
				101, 124, 85, 110, 115, 97, 102, 101, 80, 97,
				114, 97, 108, 108, 101, 108, 72, 97, 115, 104,
				77, 97, 112, 68, 105, 115, 112, 111, 115, 101,
				74, 111, 98, 0, 0, 0, 0, 72, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 46, 76, 111, 119, 76,
				101, 118, 101, 108, 46, 85, 110, 115, 97, 102,
				101, 124, 85, 110, 115, 97, 102, 101, 80, 97,
				114, 97, 108, 108, 101, 108, 72, 97, 115, 104,
				77, 97, 112, 68, 101, 98, 117, 103, 103, 101,
				114, 84, 121, 112, 101, 80, 114, 111, 120, 121,
				0, 0, 0, 0, 62, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 46, 76, 111, 119, 76, 101, 118, 101,
				108, 46, 85, 110, 115, 97, 102, 101, 124, 85,
				110, 116, 121, 112, 101, 100, 85, 110, 115, 97,
				102, 101, 80, 97, 114, 97, 108, 108, 101, 108,
				72, 97, 115, 104, 77, 97, 112, 0, 0, 0,
				0, 55, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				76, 111, 119, 76, 101, 118, 101, 108, 46, 85,
				110, 115, 97, 102, 101, 124, 85, 110, 115, 97,
				102, 101, 80, 97, 114, 97, 108, 108, 101, 108,
				72, 97, 115, 104, 83, 101, 116, 1, 0, 0,
				0, 49, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				76, 111, 119, 76, 101, 118, 101, 108, 46, 85,
				110, 115, 97, 102, 101, 46, 124, 80, 97, 114,
				97, 108, 108, 101, 108, 87, 114, 105, 116, 101,
				114, 1, 0, 0, 0, 45, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 46, 76, 111, 119, 76, 101, 118,
				101, 108, 46, 85, 110, 115, 97, 102, 101, 46,
				124, 69, 110, 117, 109, 101, 114, 97, 116, 111,
				114, 1, 0, 0, 0, 43, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 46, 76, 111, 119, 76, 101, 118,
				101, 108, 46, 85, 110, 115, 97, 102, 101, 46,
				124, 82, 101, 97, 100, 79, 110, 108, 121, 0,
				0, 0, 0, 72, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 76, 111, 119, 76, 101, 118, 101, 108,
				46, 85, 110, 115, 97, 102, 101, 124, 85, 110,
				115, 97, 102, 101, 80, 97, 114, 97, 108, 108,
				101, 108, 72, 97, 115, 104, 83, 101, 116, 68,
				101, 98, 117, 103, 103, 101, 114, 84, 121, 112,
				101, 80, 114, 111, 120, 121, 0, 0, 0, 0,
				51, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 76,
				111, 119, 76, 101, 118, 101, 108, 46, 85, 110,
				115, 97, 102, 101, 124, 72, 97, 115, 104, 83,
				101, 116, 69, 120, 116, 101, 110, 115, 105, 111,
				110, 115, 0, 0, 0, 0, 60, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 46, 76, 111, 119, 76, 101,
				118, 101, 108, 46, 85, 110, 115, 97, 102, 101,
				124, 85, 110, 115, 97, 102, 101, 80, 97, 114,
				97, 108, 108, 101, 108, 77, 117, 108, 116, 105,
				72, 97, 115, 104, 77, 97, 112, 1, 0, 0,
				0, 45, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				76, 111, 119, 76, 101, 118, 101, 108, 46, 85,
				110, 115, 97, 102, 101, 46, 124, 69, 110, 117,
				109, 101, 114, 97, 116, 111, 114, 1, 0, 0,
				0, 49, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				76, 111, 119, 76, 101, 118, 101, 108, 46, 85,
				110, 115, 97, 102, 101, 46, 124, 80, 97, 114,
				97, 108, 108, 101, 108, 87, 114, 105, 116, 101,
				114, 0, 0, 0, 0, 53, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 46, 76, 111, 119, 76, 101, 118,
				101, 108, 46, 85, 110, 115, 97, 102, 101, 46,
				124, 75, 101, 121, 86, 97, 108, 117, 101, 69,
				110, 117, 109, 101, 114, 97, 116, 111, 114, 1,
				0, 0, 0, 43, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 76, 111, 119, 76, 101, 118, 101, 108,
				46, 85, 110, 115, 97, 102, 101, 46, 124, 82,
				101, 97, 100, 79, 110, 108, 121, 0, 0, 0,
				0, 77, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				76, 111, 119, 76, 101, 118, 101, 108, 46, 85,
				110, 115, 97, 102, 101, 124, 85, 110, 115, 97,
				102, 101, 80, 97, 114, 97, 108, 108, 101, 108,
				77, 117, 108, 116, 105, 72, 97, 115, 104, 77,
				97, 112, 68, 101, 98, 117, 103, 103, 101, 114,
				84, 121, 112, 101, 80, 114, 111, 120, 121, 0,
				0, 0, 0, 40, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 124, 85, 110, 115, 97, 102, 101, 81, 117,
				101, 117, 101, 66, 108, 111, 99, 107, 72, 101,
				97, 100, 101, 114, 0, 0, 0, 0, 42, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 124, 85, 110, 115,
				97, 102, 101, 81, 117, 101, 117, 101, 66, 108,
				111, 99, 107, 80, 111, 111, 108, 68, 97, 116,
				97, 0, 0, 0, 0, 38, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 124, 85, 110, 115, 97, 102, 101,
				81, 117, 101, 117, 101, 66, 108, 111, 99, 107,
				80, 111, 111, 108, 0, 0, 0, 0, 33, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 124, 85, 110, 115,
				97, 102, 101, 81, 117, 101, 117, 101, 68, 97,
				116, 97, 0, 0, 0, 0, 29, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 124, 85, 110, 115, 97, 102,
				101, 81, 117, 101, 117, 101, 1, 0, 0, 0,
				29, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 124,
				69, 110, 117, 109, 101, 114, 97, 116, 111, 114,
				1, 0, 0, 0, 27, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 46, 124, 82, 101, 97, 100, 79, 110,
				108, 121, 1, 0, 0, 0, 33, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 46, 124, 80, 97, 114, 97,
				108, 108, 101, 108, 87, 114, 105, 116, 101, 114,
				0, 0, 0, 0, 36, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 124, 85, 110, 115, 97, 102, 101, 81,
				117, 101, 117, 101, 68, 105, 115, 112, 111, 115,
				101, 0, 0, 0, 0, 39, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 124, 85, 110, 115, 97, 102, 101,
				81, 117, 101, 117, 101, 68, 105, 115, 112, 111,
				115, 101, 74, 111, 98, 0, 0, 0, 0, 49,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 76, 111,
				119, 76, 101, 118, 101, 108, 46, 85, 110, 115,
				97, 102, 101, 124, 85, 110, 115, 97, 102, 101,
				82, 105, 110, 103, 81, 117, 101, 117, 101, 0,
				0, 0, 0, 58, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 76, 111, 119, 76, 101, 118, 101, 108,
				46, 85, 110, 115, 97, 102, 101, 124, 85, 110,
				115, 97, 102, 101, 82, 105, 110, 103, 81, 117,
				101, 117, 101, 68, 101, 98, 117, 103, 86, 105,
				101, 119, 0, 0, 0, 0, 56, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 46, 76, 111, 119, 76, 101,
				118, 101, 108, 46, 85, 110, 115, 97, 102, 101,
				124, 85, 110, 115, 97, 102, 101, 83, 99, 114,
				97, 116, 99, 104, 65, 108, 108, 111, 99, 97,
				116, 111, 114, 0, 0, 0, 0, 51, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 46, 76, 111, 119, 76,
				101, 118, 101, 108, 46, 85, 110, 115, 97, 102,
				101, 124, 85, 110, 115, 97, 102, 101, 83, 116,
				114, 101, 97, 109, 66, 108, 111, 99, 107, 0,
				0, 0, 0, 51, 85, 110, 105, 116, 121, 46,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				115, 46, 76, 111, 119, 76, 101, 118, 101, 108,
				46, 85, 110, 115, 97, 102, 101, 124, 85, 110,
				115, 97, 102, 101, 83, 116, 114, 101, 97, 109,
				82, 97, 110, 103, 101, 0, 0, 0, 0, 55,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 76, 111,
				119, 76, 101, 118, 101, 108, 46, 85, 110, 115,
				97, 102, 101, 124, 85, 110, 115, 97, 102, 101,
				83, 116, 114, 101, 97, 109, 66, 108, 111, 99,
				107, 68, 97, 116, 97, 0, 0, 0, 0, 46,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 76, 111,
				119, 76, 101, 118, 101, 108, 46, 85, 110, 115,
				97, 102, 101, 124, 85, 110, 115, 97, 102, 101,
				83, 116, 114, 101, 97, 109, 0, 0, 0, 0,
				45, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 76,
				111, 119, 76, 101, 118, 101, 108, 46, 85, 110,
				115, 97, 102, 101, 46, 124, 68, 105, 115, 112,
				111, 115, 101, 74, 111, 98, 0, 0, 0, 0,
				51, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 76,
				111, 119, 76, 101, 118, 101, 108, 46, 85, 110,
				115, 97, 102, 101, 46, 124, 67, 111, 110, 115,
				116, 114, 117, 99, 116, 74, 111, 98, 76, 105,
				115, 116, 0, 0, 0, 0, 47, 85, 110, 105,
				116, 121, 46, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 115, 46, 76, 111, 119, 76, 101,
				118, 101, 108, 46, 85, 110, 115, 97, 102, 101,
				46, 124, 67, 111, 110, 115, 116, 114, 117, 99,
				116, 74, 111, 98, 0, 0, 0, 0, 41, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 46, 76, 111, 119,
				76, 101, 118, 101, 108, 46, 85, 110, 115, 97,
				102, 101, 46, 124, 87, 114, 105, 116, 101, 114,
				1, 0, 0, 0, 41, 85, 110, 105, 116, 121,
				46, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 115, 46, 76, 111, 119, 76, 101, 118, 101,
				108, 46, 85, 110, 115, 97, 102, 101, 46, 124,
				82, 101, 97, 100, 101, 114, 0, 0, 0, 0,
				54, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 46, 76,
				111, 119, 76, 101, 118, 101, 108, 46, 85, 110,
				115, 97, 102, 101, 124, 85, 110, 115, 97, 102,
				101, 84, 101, 120, 116, 69, 120, 116, 101, 110,
				115, 105, 111, 110, 115, 0, 0, 0, 0, 44,
				85, 110, 105, 116, 121, 46, 67, 111, 108, 108,
				101, 99, 116, 105, 111, 110, 115, 46, 76, 111,
				119, 76, 101, 118, 101, 108, 46, 85, 110, 115,
				97, 102, 101, 124, 85, 110, 115, 97, 102, 101,
				84, 101, 120, 116, 0, 0, 0, 0, 57, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 46, 76, 111, 119,
				76, 101, 118, 101, 108, 46, 85, 110, 115, 97,
				102, 101, 124, 85, 110, 115, 97, 102, 101, 85,
				116, 105, 108, 105, 116, 121, 69, 120, 116, 101,
				110, 115, 105, 111, 110, 115, 0, 0, 0, 0,
				40, 85, 110, 105, 116, 121, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 124, 85,
				84, 70, 56, 65, 114, 114, 97, 121, 85, 110,
				115, 97, 102, 101, 85, 116, 105, 108, 105, 116,
				121, 0, 0, 0, 0, 51, 85, 110, 105, 116,
				121, 46, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 46, 85, 84, 70, 56, 65, 114,
				114, 97, 121, 85, 110, 115, 97, 102, 101, 85,
				116, 105, 108, 105, 116, 121, 124, 67, 111, 109,
				112, 97, 114, 105, 115, 111, 110, 1, 0, 0,
				0, 25, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 124,
				120, 120, 72, 97, 115, 104, 51, 1, 0, 0,
				0, 25, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 124,
				120, 120, 72, 97, 115, 104, 51, 0, 0, 0,
				0, 32, 85, 110, 105, 116, 121, 46, 67, 111,
				108, 108, 101, 99, 116, 105, 111, 110, 115, 46,
				120, 120, 72, 97, 115, 104, 51, 124, 117, 108,
				111, 110, 103, 50, 0, 0, 0, 0, 34, 85,
				110, 105, 116, 121, 46, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 115, 124, 120, 120, 72,
				97, 115, 104, 68, 101, 102, 97, 117, 108, 116,
				75, 101, 121, 1, 0, 0, 0, 25, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 124, 120, 120, 72, 97,
				115, 104, 51, 0, 0, 0, 0, 40, 85, 110,
				105, 116, 121, 46, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 115, 46, 120, 120, 72, 97,
				115, 104, 51, 124, 83, 116, 114, 101, 97, 109,
				105, 110, 103, 83, 116, 97, 116, 101, 0, 0,
				0, 0, 45, 85, 110, 105, 116, 121, 46, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 115,
				46, 120, 120, 72, 97, 115, 104, 51, 43, 124,
				83, 116, 114, 101, 97, 109, 105, 110, 103, 83,
				116, 97, 116, 101, 68, 97, 116, 97
			},
			TotalFiles = 69,
			TotalTypes = 308,
			IsEditorOnly = false
		};
	}
}
namespace Unity.Jobs
{
	public class EarlyInitHelpers
	{
		public delegate void EarlyInitFunction();

		private static List<EarlyInitFunction> s_PendingDelegates;

		static EarlyInitHelpers()
		{
			FlushEarlyInits();
		}

		public static void FlushEarlyInits()
		{
			while (s_PendingDelegates != null)
			{
				List<EarlyInitFunction> list = s_PendingDelegates;
				s_PendingDelegates = null;
				for (int i = 0; i < list.Count; i++)
				{
					try
					{
						list[i]();
					}
					catch (Exception exception)
					{
						UnityEngine.Debug.LogException(exception);
					}
				}
			}
		}

		public static void AddEarlyInitFunction(EarlyInitFunction func)
		{
			if (s_PendingDelegates == null)
			{
				s_PendingDelegates = new List<EarlyInitFunction>();
			}
			s_PendingDelegates.Add(func);
		}

		public static void JobReflectionDataCreationFailed(Exception ex)
		{
			UnityEngine.Debug.LogError("Failed to create job reflection data. Please refer to callstack of exception for information on which job could not produce its reflection data.");
			UnityEngine.Debug.LogException(ex);
		}
	}
	[Obsolete("'JobParallelIndexListExtensions' has been deprecated; Use 'IJobFilterExtensions' instead.", false)]
	public static class JobParallelIndexListExtensions
	{
		[Obsolete("The signature for 'ScheduleAppend' has changed. 'innerloopBatchCount' is no longer part of this API.", false)]
		public static JobHandle ScheduleAppend<T>(this T jobData, NativeList<int> indices, int arrayLength, int innerloopBatchCount, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobFilter
		{
			return jobData.ScheduleAppend(indices, arrayLength, dependsOn);
		}

		[Obsolete("The signature for 'ScheduleFilter' has changed. 'innerloopBatchCount' is no longer part of this API.")]
		public static JobHandle ScheduleFilter<T>(this T jobData, NativeList<int> indices, int innerloopBatchCount, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobFilter
		{
			return jobData.ScheduleFilter(indices, dependsOn);
		}
	}
	[Obsolete("'IJobParallelForFilter' has been deprecated; use 'IJobFilter' instead. (UnityUpgradable) -> IJobFilter")]
	public interface IJobParallelForFilter
	{
		bool Execute(int index);
	}
	[JobProducerType(typeof(IJobFilterExtensions.JobFilterProducer<>))]
	public interface IJobFilter
	{
		bool Execute(int index);
	}
	public static class IJobFilterExtensions
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		internal struct JobFilterProducer<T> where T : struct, IJobFilter
		{
			public struct JobWrapper
			{
				[NativeDisableParallelForRestriction]
				public NativeList<int> outputIndices;

				public int appendCount;

				public T JobData;
			}

			public delegate void ExecuteJobFunction(ref JobWrapper jobWrapper, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

			internal static readonly SharedStatic<IntPtr> jobReflectionData = SharedStatic<IntPtr>.GetOrCreate<JobFilterProducer<T>>();

			[BurstDiscard]
			internal static void Initialize()
			{
				if (jobReflectionData.Data == IntPtr.Zero)
				{
					jobReflectionData.Data = JobsUtility.CreateJobReflectionData(typeof(JobWrapper), typeof(T), new ExecuteJobFunction(Execute));
				}
			}

			public static void Execute(ref JobWrapper jobWrapper, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
			{
				if (jobWrapper.appendCount == -1)
				{
					ExecuteFilter(ref jobWrapper, bufferRangePatchData);
				}
				else
				{
					ExecuteAppend(ref jobWrapper, bufferRangePatchData);
				}
			}

			public unsafe static void ExecuteAppend(ref JobWrapper jobWrapper, IntPtr bufferRangePatchData)
			{
				int length = jobWrapper.outputIndices.Length;
				jobWrapper.outputIndices.Capacity = math.max(jobWrapper.appendCount + length, jobWrapper.outputIndices.Capacity);
				int* unsafePtr = jobWrapper.outputIndices.GetUnsafePtr();
				int num = length;
				for (int i = 0; i != jobWrapper.appendCount; i++)
				{
					if (jobWrapper.JobData.Execute(i))
					{
						unsafePtr[num] = i;
						num++;
					}
				}
				jobWrapper.outputIndices.ResizeUninitialized(num);
			}

			public unsafe static void ExecuteFilter(ref JobWrapper jobWrapper, IntPtr bufferRangePatchData)
			{
				int* unsafePtr = jobWrapper.outputIndices.GetUnsafePtr();
				int length = jobWrapper.outputIndices.Length;
				int num = 0;
				for (int i = 0; i != length; i++)
				{
					int num2 = unsafePtr[i];
					if (jobWrapper.JobData.Execute(num2))
					{
						unsafePtr[num] = num2;
						num++;
					}
				}
				jobWrapper.outputIndices.ResizeUninitialized(num);
			}
		}

		public static void EarlyJobInit<T>() where T : struct, IJobFilter
		{
			JobFilterProducer<T>.Initialize();
		}

		private static IntPtr GetReflectionData<T>() where T : struct, IJobFilter
		{
			JobFilterProducer<T>.Initialize();
			return JobFilterProducer<T>.jobReflectionData.Data;
		}

		public static JobHandle ScheduleAppend<T>(this T jobData, NativeList<int> indices, int arrayLength, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobFilter
		{
			return ScheduleAppendByRef(ref jobData, indices, arrayLength, dependsOn);
		}

		public static JobHandle ScheduleFilter<T>(this T jobData, NativeList<int> indices, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobFilter
		{
			return ScheduleFilterByRef(ref jobData, indices, dependsOn);
		}

		public static void RunAppend<T>(this T jobData, NativeList<int> indices, int arrayLength) where T : struct, IJobFilter
		{
			RunAppendByRef(ref jobData, indices, arrayLength);
		}

		public static void RunFilter<T>(this T jobData, NativeList<int> indices) where T : struct, IJobFilter
		{
			RunFilterByRef(ref jobData, indices);
		}

		public unsafe static JobHandle ScheduleAppendByRef<T>(this ref T jobData, NativeList<int> indices, int arrayLength, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobFilter
		{
			JobFilterProducer<T>.JobWrapper output = new JobFilterProducer<T>.JobWrapper
			{
				JobData = jobData,
				outputIndices = indices,
				appendCount = arrayLength
			};
			JobsUtility.JobScheduleParameters parameters = new JobsUtility.JobScheduleParameters(UnsafeUtility.AddressOf(ref output), GetReflectionData<T>(), dependsOn, ScheduleMode.Single);
			return JobsUtility.Schedule(ref parameters);
		}

		public unsafe static JobHandle ScheduleFilterByRef<T>(this ref T jobData, NativeList<int> indices, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobFilter
		{
			JobFilterProducer<T>.JobWrapper output = new JobFilterProducer<T>.JobWrapper
			{
				JobData = jobData,
				outputIndices = indices,
				appendCount = -1
			};
			JobsUtility.JobScheduleParameters parameters = new JobsUtility.JobScheduleParameters(UnsafeUtility.AddressOf(ref output), GetReflectionData<T>(), dependsOn, ScheduleMode.Single);
			return JobsUtility.Schedule(ref parameters);
		}

		public unsafe static void RunAppendByRef<T>(this ref T jobData, NativeList<int> indices, int arrayLength) where T : struct, IJobFilter
		{
			JobFilterProducer<T>.JobWrapper output = new JobFilterProducer<T>.JobWrapper
			{
				JobData = jobData,
				outputIndices = indices,
				appendCount = arrayLength
			};
			JobsUtility.JobScheduleParameters parameters = new JobsUtility.JobScheduleParameters(UnsafeUtility.AddressOf(ref output), GetReflectionData<T>(), default(JobHandle), ScheduleMode.Run);
			JobsUtility.Schedule(ref parameters);
		}

		public unsafe static void RunFilterByRef<T>(this ref T jobData, NativeList<int> indices) where T : struct, IJobFilter
		{
			JobFilterProducer<T>.JobWrapper output = new JobFilterProducer<T>.JobWrapper
			{
				JobData = jobData,
				outputIndices = indices,
				appendCount = -1
			};
			JobsUtility.JobScheduleParameters parameters = new JobsUtility.JobScheduleParameters(UnsafeUtility.AddressOf(ref output), GetReflectionData<T>(), default(JobHandle), ScheduleMode.Run);
			JobsUtility.Schedule(ref parameters);
		}
	}
	[JobProducerType(typeof(IJobParallelForBatchExtensions.JobParallelForBatchProducer<>))]
	public interface IJobParallelForBatch
	{
		void Execute(int startIndex, int count);
	}
	public static class IJobParallelForBatchExtensions
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		internal struct JobParallelForBatchProducer<T> where T : struct, IJobParallelForBatch
		{
			internal delegate void ExecuteJobFunction(ref T jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

			internal static readonly SharedStatic<IntPtr> jobReflectionData = SharedStatic<IntPtr>.GetOrCreate<JobParallelForBatchProducer<T>>();

			[BurstDiscard]
			internal static void Initialize()
			{
				if (jobReflectionData.Data == IntPtr.Zero)
				{
					jobReflectionData.Data = JobsUtility.CreateJobReflectionData(typeof(T), new ExecuteJobFunction(Execute));
				}
			}

			public static void Execute(ref T jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
			{
				int beginIndex;
				int endIndex;
				while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out beginIndex, out endIndex))
				{
					jobData.Execute(beginIndex, endIndex - beginIndex);
				}
			}
		}

		public static void EarlyJobInit<T>() where T : struct, IJobParallelForBatch
		{
			JobParallelForBatchProducer<T>.Initialize();
		}

		private static IntPtr GetReflectionData<T>() where T : struct, IJobParallelForBatch
		{
			JobParallelForBatchProducer<T>.Initialize();
			return JobParallelForBatchProducer<T>.jobReflectionData.Data;
		}

		public unsafe static JobHandle Schedule<T>(this T jobData, int arrayLength, int indicesPerJobCount, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobParallelForBatch
		{
			JobsUtility.JobScheduleParameters parameters = new JobsUtility.JobScheduleParameters(UnsafeUtility.AddressOf(ref jobData), GetReflectionData<T>(), dependsOn, ScheduleMode.Single);
			return JobsUtility.ScheduleParallelFor(ref parameters, arrayLength, indicesPerJobCount);
		}

		public unsafe static JobHandle ScheduleByRef<T>(this ref T jobData, int arrayLength, int indicesPerJobCount, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobParallelForBatch
		{
			JobsUtility.JobScheduleParameters parameters = new JobsUtility.JobScheduleParameters(UnsafeUtility.AddressOf(ref jobData), GetReflectionData<T>(), dependsOn, ScheduleMode.Single);
			return JobsUtility.ScheduleParallelFor(ref parameters, arrayLength, indicesPerJobCount);
		}

		public unsafe static JobHandle ScheduleParallel<T>(this T jobData, int arrayLength, int indicesPerJobCount, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobParallelForBatch
		{
			JobsUtility.JobScheduleParameters parameters = new JobsUtility.JobScheduleParameters(UnsafeUtility.AddressOf(ref jobData), GetReflectionData<T>(), dependsOn, ScheduleMode.Batched);
			return JobsUtility.ScheduleParallelFor(ref parameters, arrayLength, indicesPerJobCount);
		}

		public unsafe static JobHandle ScheduleParallelByRef<T>(this ref T jobData, int arrayLength, int indicesPerJobCount, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobParallelForBatch
		{
			JobsUtility.JobScheduleParameters parameters = new JobsUtility.JobScheduleParameters(UnsafeUtility.AddressOf(ref jobData), GetReflectionData<T>(), dependsOn, ScheduleMode.Batched);
			return JobsUtility.ScheduleParallelFor(ref parameters, arrayLength, indicesPerJobCount);
		}

		public static JobHandle ScheduleBatch<T>(this T jobData, int arrayLength, int indicesPerJobCount, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobParallelForBatch
		{
			return ScheduleParallel(jobData, arrayLength, indicesPerJobCount, dependsOn);
		}

		public static JobHandle ScheduleBatchByRef<T>(this ref T jobData, int arrayLength, int indicesPerJobCount, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobParallelForBatch
		{
			return ScheduleParallelByRef(ref jobData, arrayLength, indicesPerJobCount, dependsOn);
		}

		public unsafe static void Run<T>(this T jobData, int arrayLength, int indicesPerJobCount) where T : struct, IJobParallelForBatch
		{
			JobsUtility.JobScheduleParameters parameters = new JobsUtility.JobScheduleParameters(UnsafeUtility.AddressOf(ref jobData), GetReflectionData<T>(), default(JobHandle), ScheduleMode.Run);
			JobsUtility.ScheduleParallelFor(ref parameters, arrayLength, arrayLength);
		}

		public unsafe static void RunByRef<T>(this ref T jobData, int arrayLength, int indicesPerJobCount) where T : struct, IJobParallelForBatch
		{
			JobsUtility.JobScheduleParameters parameters = new JobsUtility.JobScheduleParameters(UnsafeUtility.AddressOf(ref jobData), GetReflectionData<T>(), default(JobHandle), ScheduleMode.Run);
			JobsUtility.ScheduleParallelFor(ref parameters, arrayLength, arrayLength);
		}

		public static void RunBatch<T>(this T jobData, int arrayLength) where T : struct, IJobParallelForBatch
		{
			jobData.Run(arrayLength, arrayLength);
		}

		public static void RunBatchByRef<T>(this ref T jobData, int arrayLength) where T : struct, IJobParallelForBatch
		{
			RunByRef(ref jobData, arrayLength, arrayLength);
		}
	}
	[JobProducerType(typeof(IJobParallelForDeferExtensions.JobParallelForDeferProducer<>))]
	public interface IJobParallelForDefer
	{
		void Execute(int index);
	}
	public static class IJobParallelForDeferExtensions
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		internal struct JobParallelForDeferProducer<T> where T : struct, IJobParallelForDefer
		{
			public delegate void ExecuteJobFunction(ref T jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

			internal static readonly SharedStatic<IntPtr> jobReflectionData = SharedStatic<IntPtr>.GetOrCreate<JobParallelForDeferProducer<T>>();

			[BurstDiscard]
			internal static void Initialize()
			{
				if (jobReflectionData.Data == IntPtr.Zero)
				{
					jobReflectionData.Data = JobsUtility.CreateJobReflectionData(typeof(T), new ExecuteJobFunction(Execute));
				}
			}

			public static void Execute(ref T jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
			{
				int beginIndex;
				int endIndex;
				while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out beginIndex, out endIndex))
				{
					int num = endIndex;
					for (int i = beginIndex; i < num; i++)
					{
						jobData.Execute(i);
					}
				}
			}
		}

		public static void EarlyJobInit<T>() where T : struct, IJobParallelForDefer
		{
			JobParallelForDeferProducer<T>.Initialize();
		}

		public unsafe static JobHandle Schedule<T, U>(this T jobData, NativeList<U> list, int innerloopBatchCount, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobParallelForDefer where U : unmanaged
		{
			void* atomicSafetyHandlePtr = null;
			return ScheduleInternal(ref jobData, innerloopBatchCount, NativeListUnsafeUtility.GetInternalListDataPtrUnchecked(ref list), atomicSafetyHandlePtr, dependsOn);
		}

		public unsafe static JobHandle ScheduleByRef<T, U>(this ref T jobData, NativeList<U> list, int innerloopBatchCount, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobParallelForDefer where U : unmanaged
		{
			void* atomicSafetyHandlePtr = null;
			return ScheduleInternal(ref jobData, innerloopBatchCount, NativeListUnsafeUtility.GetInternalListDataPtrUnchecked(ref list), atomicSafetyHandlePtr, dependsOn);
		}

		public unsafe static JobHandle Schedule<T>(this T jobData, int* forEachCount, int innerloopBatchCount, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobParallelForDefer
		{
			byte* forEachListPtr = (byte*)forEachCount - sizeof(void*);
			return ScheduleInternal(ref jobData, innerloopBatchCount, forEachListPtr, null, dependsOn);
		}

		public unsafe static JobHandle ScheduleByRef<T>(this ref T jobData, int* forEachCount, int innerloopBatchCount, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobParallelForDefer
		{
			byte* forEachListPtr = (byte*)forEachCount - sizeof(void*);
			return ScheduleInternal(ref jobData, innerloopBatchCount, forEachListPtr, null, dependsOn);
		}

		private unsafe static JobHandle ScheduleInternal<T>(ref T jobData, int innerloopBatchCount, void* forEachListPtr, void* atomicSafetyHandlePtr, JobHandle dependsOn) where T : struct, IJobParallelForDefer
		{
			JobParallelForDeferProducer<T>.Initialize();
			IntPtr data = JobParallelForDeferProducer<T>.jobReflectionData.Data;
			JobsUtility.JobScheduleParameters parameters = new JobsUtility.JobScheduleParameters(UnsafeUtility.AddressOf(ref jobData), data, dependsOn, ScheduleMode.Batched);
			return JobsUtility.ScheduleParallelForDeferArraySize(ref parameters, innerloopBatchCount, forEachListPtr, atomicSafetyHandlePtr);
		}
	}
	[MovedFrom(true, "Unity.Entities", "Unity.Entities", null)]
	[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
	public class RegisterGenericJobTypeAttribute : Attribute
	{
		public Type ConcreteType;

		public RegisterGenericJobTypeAttribute(Type type)
		{
			ConcreteType = type;
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	internal class DOTSCompilerGeneratedAttribute : Attribute
	{
	}
}
namespace Unity.Collections
{
	[GenerateTestsForBurstCompatibility]
	internal struct Spinner
	{
		private int m_Lock;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Acquire()
		{
			while (Interlocked.CompareExchange(ref m_Lock, 1, 0) != 0)
			{
				while (Volatile.Read(ref m_Lock) == 1)
				{
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal bool TryAcquire()
		{
			if (Volatile.Read(ref m_Lock) == 0)
			{
				return Interlocked.CompareExchange(ref m_Lock, 1, 0) == 0;
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal bool TryAcquire(bool spin)
		{
			if (spin)
			{
				Acquire();
				return true;
			}
			return TryAcquire();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Release()
		{
			Volatile.Write(ref m_Lock, 0);
		}
	}
	public static class AllocatorManager
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate int TryFunction(IntPtr allocatorState, ref Block block);

		public struct AllocatorHandle : IAllocator, IDisposable, IEquatable<AllocatorHandle>, IComparable<AllocatorHandle>
		{
			public ushort Index;

			public ushort Version;

			internal ref TableEntry TableEntry => ref SharedStatics.TableEntry.Ref.Data.ElementAt(Index);

			internal bool IsInstalled => ((SharedStatics.IsInstalled.Ref.Data.ElementAt(Index >> 6) >> (int)Index) & 1) != 0;

			public int Value => Index;

			public TryFunction Function => null;

			public AllocatorHandle Handle
			{
				get
				{
					return this;
				}
				set
				{
					this = value;
				}
			}

			public Allocator ToAllocator
			{
				get
				{
					uint index = Index;
					return (Allocator)((Version << 16) | (int)index);
				}
			}

			public bool IsCustomAllocator => Index >= 64;

			public bool IsAutoDispose => ((SharedStatics.IsAutoDispose.Ref.Data.ElementAt(Index >> 6) >> (int)Index) & 1) != 0;

			internal void IncrementVersion()
			{
			}

			internal void Rewind()
			{
			}

			internal void Install(TableEntry tableEntry)
			{
				Rewind();
				TableEntry = tableEntry;
			}

			public static implicit operator AllocatorHandle(Allocator a)
			{
				return new AllocatorHandle
				{
					Index = (ushort)(a & (Allocator)65535),
					Version = 0
				};
			}

			public int TryAllocateBlock<T>(out Block block, int items) where T : unmanaged
			{
				block = new Block
				{
					Range = new Range
					{
						Items = items,
						Allocator = this
					},
					BytesPerItem = UnsafeUtility.SizeOf<T>(),
					Alignment = 1 << math.min(3, math.tzcnt(UnsafeUtility.SizeOf<T>()))
				};
				return Try(ref block);
			}

			public Block AllocateBlock<T>(int items) where T : unmanaged
			{
				TryAllocateBlock<T>(out var block, items);
				return block;
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private static void CheckAllocatedSuccessfully(int error)
			{
				if (error != 0)
				{
					throw new ArgumentException($"Error {error}: Failed to Allocate");
				}
			}

			public int Try(ref Block block)
			{
				block.Range.Allocator = this;
				return AllocatorManager.Try(ref block);
			}

			public void Dispose()
			{
				Rewind();
				TableEntry = default(TableEntry);
			}

			public override bool Equals(object obj)
			{
				if (obj is AllocatorHandle)
				{
					return Value == ((AllocatorHandle)obj).Value;
				}
				if (obj is Allocator)
				{
					return ToAllocator == (Allocator)obj;
				}
				return false;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool Equals(AllocatorHandle other)
			{
				return Value == other.Value;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool Equals(Allocator other)
			{
				return ToAllocator == other;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public override int GetHashCode()
			{
				return Value;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public static bool operator ==(AllocatorHandle lhs, AllocatorHandle rhs)
			{
				return lhs.Value == rhs.Value;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public static bool operator !=(AllocatorHandle lhs, AllocatorHandle rhs)
			{
				return lhs.Value != rhs.Value;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public static bool operator <(AllocatorHandle lhs, AllocatorHandle rhs)
			{
				return lhs.Value < rhs.Value;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public static bool operator >(AllocatorHandle lhs, AllocatorHandle rhs)
			{
				return lhs.Value > rhs.Value;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public static bool operator <=(AllocatorHandle lhs, AllocatorHandle rhs)
			{
				return lhs.Value <= rhs.Value;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public static bool operator >=(AllocatorHandle lhs, AllocatorHandle rhs)
			{
				return lhs.Value >= rhs.Value;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public int CompareTo(AllocatorHandle other)
			{
				return Value - other.Value;
			}
		}

		public struct BlockHandle
		{
			public ushort Value;
		}

		public struct Range : IDisposable
		{
			public IntPtr Pointer;

			public int Items;

			public AllocatorHandle Allocator;

			public void Dispose()
			{
				Block block = new Block
				{
					Range = this
				};
				block.Dispose();
				this = block.Range;
			}
		}

		public struct Block : IDisposable
		{
			public Range Range;

			public int BytesPerItem;

			public int AllocatedItems;

			public byte Log2Alignment;

			public byte Padding0;

			public ushort Padding1;

			public uint Padding2;

			public long Bytes => (long)BytesPerItem * (long)Range.Items;

			public long AllocatedBytes => (long)BytesPerItem * (long)AllocatedItems;

			public int Alignment
			{
				get
				{
					return 1 << (int)Log2Alignment;
				}
				set
				{
					Log2Alignment = (byte)(32 - math.lzcnt(math.max(1, value) - 1));
				}
			}

			public void Dispose()
			{
				TryFree();
			}

			public int TryAllocate()
			{
				Range.Pointer = IntPtr.Zero;
				return Try(ref this);
			}

			public int TryFree()
			{
				Range.Items = 0;
				return Try(ref this);
			}

			public void Allocate()
			{
				TryAllocate();
			}

			public void Free()
			{
				TryFree();
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private void CheckFailedToAllocate(int error)
			{
				if (error != 0)
				{
					throw new ArgumentException($"Error {error}: Failed to Allocate {this}");
				}
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private void CheckFailedToFree(int error)
			{
				if (error != 0)
				{
					throw new ArgumentException($"Error {error}: Failed to Free {this}");
				}
			}
		}

		public interface IAllocator : IDisposable
		{
			TryFunction Function { get; }

			AllocatorHandle Handle { get; set; }

			Allocator ToAllocator { get; }

			bool IsCustomAllocator { get; }

			bool IsAutoDispose => false;

			int Try(ref Block block);
		}

		[BurstCompile]
		internal struct StackAllocator : IAllocator, IDisposable
		{
			internal delegate int Try_000000AB$PostfixBurstDelegate(IntPtr allocatorState, ref Block block);

			internal static class Try_000000AB$BurstDirectCall
			{
				private static IntPtr Pointer;

				private static IntPtr DeferredCompilation;

				[BurstDiscard]
				private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
				{
					if (Pointer == (IntPtr)0)
					{
						Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(Try_000000AB$PostfixBurstDelegate).TypeHandle);
					}
					P_0 = Pointer;
				}

				private static IntPtr GetFunctionPointer()
				{
					nint result = 0;
					GetFunctionPointerDiscard(ref result);
					return result;
				}

				public static void Constructor()
				{
					DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
				}

				public static void Initialize()
				{
				}

				static Try_000000AB$BurstDirectCall()
				{
					Constructor();
				}

				public unsafe static int Invoke(IntPtr allocatorState, ref Block block)
				{
					if (BurstCompiler.IsEnabled)
					{
						IntPtr functionPointer = GetFunctionPointer();
						if (functionPointer != (IntPtr)0)
						{
							return ((delegate* unmanaged[Cdecl]<IntPtr, ref Block, int>)functionPointer)(allocatorState, ref block);
						}
					}
					return Try$BurstManaged(allocatorState, ref block);
				}
			}

			internal AllocatorHandle m_handle;

			internal Block m_storage;

			internal long m_top;

			public AllocatorHandle Handle
			{
				get
				{
					return m_handle;
				}
				set
				{
					m_handle = value;
				}
			}

			public Allocator ToAllocator => m_handle.ToAllocator;

			public bool IsCustomAllocator => m_handle.IsCustomAllocator;

			public TryFunction Function => Try;

			public void Initialize(Block storage)
			{
				m_storage = storage;
				m_top = 0L;
			}

			public unsafe int Try(ref Block block)
			{
				if (block.Range.Pointer == IntPtr.Zero)
				{
					if (m_top + block.Bytes > m_storage.Bytes)
					{
						return -1;
					}
					block.Range.Pointer = (IntPtr)((byte*)(void*)m_storage.Range.Pointer + m_top);
					block.AllocatedItems = block.Range.Items;
					m_top += block.Bytes;
					return 0;
				}
				if (block.Bytes == 0L)
				{
					if ((byte*)(void*)block.Range.Pointer - (byte*)(void*)m_storage.Range.Pointer == m_top - block.AllocatedBytes)
					{
						m_top -= block.AllocatedBytes;
						block.Range.Pointer = IntPtr.Zero;
						block.AllocatedItems = 0;
						return 0;
					}
					return -1;
				}
				return -1;
			}

			[BurstCompile]
			[MonoPInvokeCallback(typeof(TryFunction))]
			public static int Try(IntPtr allocatorState, ref Block block)
			{
				return Try_000000AB$BurstDirectCall.Invoke(allocatorState, ref block);
			}

			public void Dispose()
			{
				m_handle.Rewind();
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			[BurstCompile]
			[MonoPInvokeCallback(typeof(TryFunction))]
			internal unsafe static int Try$BurstManaged(IntPtr allocatorState, ref Block block)
			{
				return ((StackAllocator*)(void*)allocatorState)->Try(ref block);
			}
		}

		[BurstCompile]
		internal struct SlabAllocator : IAllocator, IDisposable
		{
			internal delegate int Try_000000B9$PostfixBurstDelegate(IntPtr allocatorState, ref Block block);

			internal static class Try_000000B9$BurstDirectCall
			{
				private static IntPtr Pointer;

				private static IntPtr DeferredCompilation;

				[BurstDiscard]
				private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
				{
					if (Pointer == (IntPtr)0)
					{
						Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(Try_000000B9$PostfixBurstDelegate).TypeHandle);
					}
					P_0 = Pointer;
				}

				private static IntPtr GetFunctionPointer()
				{
					nint result = 0;
					GetFunctionPointerDiscard(ref result);
					return result;
				}

				public static void Constructor()
				{
					DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
				}

				public static void Initialize()
				{
				}

				static Try_000000B9$BurstDirectCall()
				{
					Constructor();
				}

				public unsafe static int Invoke(IntPtr allocatorState, ref Block block)
				{
					if (BurstCompiler.IsEnabled)
					{
						IntPtr functionPointer = GetFunctionPointer();
						if (functionPointer != (IntPtr)0)
						{
							return ((delegate* unmanaged[Cdecl]<IntPtr, ref Block, int>)functionPointer)(allocatorState, ref block);
						}
					}
					return Try$BurstManaged(allocatorState, ref block);
				}
			}

			internal AllocatorHandle m_handle;

			internal Block Storage;

			internal int Log2SlabSizeInBytes;

			internal FixedList4096Bytes<int> Occupied;

			internal long budgetInBytes;

			internal long allocatedBytes;

			public AllocatorHandle Handle
			{
				get
				{
					return m_handle;
				}
				set
				{
					m_handle = value;
				}
			}

			public Allocator ToAllocator => m_handle.ToAllocator;

			public bool IsCustomAllocator => m_handle.IsCustomAllocator;

			public long BudgetInBytes => budgetInBytes;

			public long AllocatedBytes => allocatedBytes;

			internal int SlabSizeInBytes
			{
				get
				{
					return 1 << Log2SlabSizeInBytes;
				}
				set
				{
					Log2SlabSizeInBytes = (byte)(32 - math.lzcnt(math.max(1, value) - 1));
				}
			}

			internal int Slabs => (int)(Storage.Bytes >> Log2SlabSizeInBytes);

			public TryFunction Function => Try;

			internal void Initialize(Block storage, int slabSizeInBytes, long budget)
			{
				Assert.IsTrue((slabSizeInBytes & (slabSizeInBytes - 1)) == 0);
				Storage = storage;
				Log2SlabSizeInBytes = 0;
				Occupied = default(FixedList4096Bytes<int>);
				budgetInBytes = budget;
				allocatedBytes = 0L;
				SlabSizeInBytes = slabSizeInBytes;
				Occupied.Length = (Slabs + 31) / 32;
			}

			public int Try(ref Block block)
			{
				if (block.Range.Pointer == IntPtr.Zero)
				{
					if (block.Bytes + allocatedBytes > budgetInBytes)
					{
						return -2;
					}
					if (block.Bytes > SlabSizeInBytes)
					{
						return -1;
					}
					for (int i = 0; i < Occupied.Length; i++)
					{
						int num = Occupied[i];
						if (num == -1)
						{
							continue;
						}
						for (int j = 0; j < 32; j++)
						{
							if ((num & (1 << j)) == 0)
							{
								Occupied[i] |= 1 << j;
								block.Range.Pointer = Storage.Range.Pointer + (int)(SlabSizeInBytes * ((long)i * 32L + j));
								block.AllocatedItems = SlabSizeInBytes / block.BytesPerItem;
								allocatedBytes += block.Bytes;
								return 0;
							}
						}
					}
					return -1;
				}
				if (block.Bytes == 0L)
				{
					long num2 = (long)block.Range.Pointer - (long)Storage.Range.Pointer >>> Log2SlabSizeInBytes;
					int index = (int)(num2 >>> 5);
					int num3 = (int)(num2 & 0x1F);
					Occupied[index] &= ~(1 << num3);
					block.Range.Pointer = IntPtr.Zero;
					int num4 = block.AllocatedItems * block.BytesPerItem;
					allocatedBytes -= num4;
					block.AllocatedItems = 0;
					return 0;
				}
				return -1;
			}

			[BurstCompile]
			[MonoPInvokeCallback(typeof(TryFunction))]
			public static int Try(IntPtr allocatorState, ref Block block)
			{
				return Try_000000B9$BurstDirectCall.Invoke(allocatorState, ref block);
			}

			public void Dispose()
			{
				m_handle.Rewind();
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			[BurstCompile]
			[MonoPInvokeCallback(typeof(TryFunction))]
			internal unsafe static int Try$BurstManaged(IntPtr allocatorState, ref Block block)
			{
				return ((SlabAllocator*)(void*)allocatorState)->Try(ref block);
			}
		}

		internal struct TableEntry
		{
			internal IntPtr function;

			internal IntPtr state;
		}

		internal struct Array16<T> where T : unmanaged
		{
			internal T f0;

			internal T f1;

			internal T f2;

			internal T f3;

			internal T f4;

			internal T f5;

			internal T f6;

			internal T f7;

			internal T f8;

			internal T f9;

			internal T f10;

			internal T f11;

			internal T f12;

			internal T f13;

			internal T f14;

			internal T f15;
		}

		internal struct Array256<T> where T : unmanaged
		{
			internal Array16<T> f0;

			internal Array16<T> f1;

			internal Array16<T> f2;

			internal Array16<T> f3;

			internal Array16<T> f4;

			internal Array16<T> f5;

			internal Array16<T> f6;

			internal Array16<T> f7;

			internal Array16<T> f8;

			internal Array16<T> f9;

			internal Array16<T> f10;

			internal Array16<T> f11;

			internal Array16<T> f12;

			internal Array16<T> f13;

			internal Array16<T> f14;

			internal Array16<T> f15;
		}

		internal struct Array4096<T> where T : unmanaged
		{
			internal Array256<T> f0;

			internal Array256<T> f1;

			internal Array256<T> f2;

			internal Array256<T> f3;

			internal Array256<T> f4;

			internal Array256<T> f5;

			internal Array256<T> f6;

			internal Array256<T> f7;

			internal Array256<T> f8;

			internal Array256<T> f9;

			internal Array256<T> f10;

			internal Array256<T> f11;

			internal Array256<T> f12;

			internal Array256<T> f13;

			internal Array256<T> f14;

			internal Array256<T> f15;
		}

		internal struct Array32768<T> : IIndexable<T> where T : unmanaged
		{
			internal Array4096<T> f0;

			internal Array4096<T> f1;

			internal Array4096<T> f2;

			internal Array4096<T> f3;

			internal Array4096<T> f4;

			internal Array4096<T> f5;

			internal Array4096<T> f6;

			internal Array4096<T> f7;

			public int Length
			{
				get
				{
					return 32768;
				}
				set
				{
				}
			}

			public unsafe ref T ElementAt(int index)
			{
				fixed (Array4096<T>* ptr = &f0)
				{
					return ref UnsafeUtility.AsRef<T>((byte*)ptr + (nint)index * (nint)sizeof(T));
				}
			}
		}

		internal sealed class SharedStatics
		{
			internal sealed class IsInstalled
			{
				internal static readonly SharedStatic<Long1024> Ref = SharedStatic<Long1024>.GetOrCreateUnsafe(0u, -4832911380680317357L, 0L);
			}

			internal sealed class TableEntry
			{
				internal static readonly SharedStatic<Array32768<AllocatorManager.TableEntry>> Ref = SharedStatic<Array32768<AllocatorManager.TableEntry>>.GetOrCreateUnsafe(0u, -1297938794087215229L, 0L);
			}

			internal sealed class IsAutoDispose
			{
				internal static readonly SharedStatic<Long1024> Ref = SharedStatic<Long1024>.GetOrCreateUnsafe(0u, -5725630068035020733L, 0L);
			}
		}

		internal static class Managed
		{
			internal static TryFunction[] TryFunctionDelegates = new TryFunction[32768];

			[ExcludeFromBurstCompatTesting("Uses managed delegate")]
			public static void RegisterDelegate(int index, TryFunction function)
			{
				if (index >= 32768)
				{
					throw new ArgumentException("index to be registered in TryFunction delegate table exceeds maximum.");
				}
				TryFunctionDelegates[index] = function;
			}

			[ExcludeFromBurstCompatTesting("Uses managed delegate")]
			public static void UnregisterDelegate(int index)
			{
				if (index >= 32768)
				{
					throw new ArgumentException("index to be unregistered in TryFunction delegate table exceeds maximum.");
				}
				TryFunctionDelegates[index] = null;
			}
		}

		private static class AllocatorCache<T> where T : unmanaged, IAllocator
		{
			public static FunctionPointer<TryFunction> TryFunction;

			public static TryFunction CachedFunction;
		}

		public static readonly AllocatorHandle Invalid = new AllocatorHandle
		{
			Index = 0
		};

		public static readonly AllocatorHandle None = new AllocatorHandle
		{
			Index = 1
		};

		public static readonly AllocatorHandle Temp = new AllocatorHandle
		{
			Index = 2
		};

		public static readonly AllocatorHandle TempJob = new AllocatorHandle
		{
			Index = 3
		};

		public static readonly AllocatorHandle Persistent = new AllocatorHandle
		{
			Index = 4
		};

		public static readonly AllocatorHandle AudioKernel = new AllocatorHandle
		{
			Index = 5
		};

		public const int kErrorNone = 0;

		public const int kErrorBufferOverflow = -1;

		public const ushort FirstUserIndex = 64;

		public const ushort MaxNumCustomAllocators = 32768;

		internal static readonly ushort NumGlobalScratchAllocators = (ushort)JobsUtility.ThreadIndexCount;

		internal static readonly ushort MaxNumGlobalAllocators = (ushort)JobsUtility.ThreadIndexCount;

		internal static readonly uint GlobalAllocatorBaseIndex = (uint)(32768 - MaxNumGlobalAllocators);

		internal static readonly uint FirstGlobalScratchpadAllocatorIndex = GlobalAllocatorBaseIndex;

		internal static Block AllocateBlock<T>(this ref T t, int sizeOf, int alignOf, int items) where T : unmanaged, IAllocator
		{
			Block block = new Block
			{
				Range = 
				{
					Pointer = IntPtr.Zero,
					Items = items,
					Allocator = t.Handle
				},
				BytesPerItem = sizeOf,
				Alignment = math.max(64, alignOf)
			};
			t.Try(ref block);
			return block;
		}

		internal static Block AllocateBlock<T, U>(this ref T t, U u, int items) where T : unmanaged, IAllocator where U : unmanaged
		{
			return AllocateBlock(ref t, UnsafeUtility.SizeOf<U>(), UnsafeUtility.AlignOf<U>(), items);
		}

		public unsafe static void* Allocate<T>(this ref T t, int sizeOf, int alignOf, int items = 1) where T : unmanaged, IAllocator
		{
			return (void*)AllocateBlock(ref t, sizeOf, alignOf, items).Range.Pointer;
		}

		internal unsafe static U* Allocate<T, U>(this ref T t, U u, int items) where T : unmanaged, IAllocator where U : unmanaged
		{
			return (U*)Allocate(ref t, UnsafeUtility.SizeOf<U>(), UnsafeUtility.AlignOf<U>(), items);
		}

		internal unsafe static void* AllocateStruct<T, U>(this ref T t, U u, int items) where T : unmanaged, IAllocator where U : unmanaged
		{
			return Allocate(ref t, UnsafeUtility.SizeOf<U>(), UnsafeUtility.AlignOf<U>(), items);
		}

		internal static void FreeBlock<T>(this ref T t, ref Block block) where T : unmanaged, IAllocator
		{
			block.Range.Items = 0;
			t.Try(ref block);
		}

		internal unsafe static void Free<T>(this ref T t, void* pointer, int sizeOf, int alignOf, int items) where T : unmanaged, IAllocator
		{
			if (pointer != null)
			{
				Block block = new Block
				{
					AllocatedItems = items,
					Range = 
					{
						Pointer = (IntPtr)pointer
					},
					BytesPerItem = sizeOf,
					Alignment = alignOf
				};
				FreeBlock(ref t, ref block);
			}
		}

		internal unsafe static void Free<T, U>(this ref T t, U* pointer, int items) where T : unmanaged, IAllocator where U : unmanaged
		{
			Free(ref t, pointer, UnsafeUtility.SizeOf<U>(), UnsafeUtility.AlignOf<U>(), items);
		}

		public unsafe static void* Allocate(AllocatorHandle handle, int itemSizeInBytes, int alignmentInBytes, int items = 1)
		{
			return Allocate(ref handle, itemSizeInBytes, alignmentInBytes, items);
		}

		public unsafe static T* Allocate<T>(AllocatorHandle handle, int items = 1) where T : unmanaged
		{
			return Allocate(ref handle, default(T), items);
		}

		public unsafe static void Free(AllocatorHandle handle, void* pointer, int itemSizeInBytes, int alignmentInBytes, int items = 1)
		{
			Free(ref handle, pointer, itemSizeInBytes, alignmentInBytes, items);
		}

		public unsafe static void Free(AllocatorHandle handle, void* pointer)
		{
			Free(ref handle, (byte*)pointer, 1);
		}

		public unsafe static void Free<T>(AllocatorHandle handle, T* pointer, int items = 1) where T : unmanaged
		{
			Free(ref handle, pointer, items);
		}

		public static AllocatorHandle ConvertToAllocatorHandle(Allocator a)
		{
			ushort index = (ushort)(a & (Allocator)65535);
			ushort version = (ushort)((uint)a >> 16);
			return new AllocatorHandle
			{
				Index = index,
				Version = version
			};
		}

		[BurstDiscard]
		private static void CheckDelegate(ref bool useDelegate)
		{
			useDelegate = true;
		}

		private static bool UseDelegate()
		{
			bool useDelegate = false;
			CheckDelegate(ref useDelegate);
			return useDelegate;
		}

		private static int allocate_block(ref Block block)
		{
			TableEntry tableEntry = default(TableEntry);
			tableEntry = block.Range.Allocator.TableEntry;
			return new FunctionPointer<TryFunction>(tableEntry.function).Invoke(tableEntry.state, ref block);
		}

		[BurstDiscard]
		private static void forward_mono_allocate_block(ref Block block, ref int error)
		{
			TableEntry tableEntry = default(TableEntry);
			tableEntry = block.Range.Allocator.TableEntry;
			if (block.Range.Allocator.Handle.Index >= 32768)
			{
				throw new ArgumentException("Allocator index into TryFunction delegate table exceeds maximum.");
			}
			error = Managed.TryFunctionDelegates[block.Range.Allocator.Handle.Index](tableEntry.state, ref block);
		}

		internal static Allocator LegacyOf(AllocatorHandle handle)
		{
			if (handle.Value >= 64)
			{
				return Allocator.Persistent;
			}
			return (Allocator)handle.Value;
		}

		private unsafe static int TryLegacy(ref Block block)
		{
			if (block.Range.Pointer == IntPtr.Zero)
			{
				block.Range.Pointer = (IntPtr)Memory.Unmanaged.Allocate(block.Bytes, block.Alignment, LegacyOf(block.Range.Allocator));
				block.AllocatedItems = block.Range.Items;
				if (!(block.Range.Pointer == IntPtr.Zero))
				{
					return 0;
				}
				return -1;
			}
			if (block.Bytes == 0L)
			{
				if (LegacyOf(block.Range.Allocator) != Allocator.None)
				{
					Memory.Unmanaged.Free((void*)block.Range.Pointer, LegacyOf(block.Range.Allocator));
				}
				block.Range.Pointer = IntPtr.Zero;
				block.AllocatedItems = 0;
				return 0;
			}
			return -1;
		}

		public static int Try(ref Block block)
		{
			if (block.Range.Allocator.Value < 64)
			{
				return TryLegacy(ref block);
			}
			TableEntry tableEntry = default(TableEntry);
			tableEntry = block.Range.Allocator.TableEntry;
			new FunctionPointer<TryFunction>(tableEntry.function);
			if (UseDelegate())
			{
				int error = 0;
				forward_mono_allocate_block(ref block, ref error);
				return error;
			}
			return allocate_block(ref block);
		}

		public static void Initialize()
		{
		}

		internal static void Install(AllocatorHandle handle, IntPtr allocatorState, FunctionPointer<TryFunction> functionPointer, TryFunction function, bool IsAutoDispose = false)
		{
			if (functionPointer.Value == IntPtr.Zero)
			{
				Unregister(ref handle);
			}
			else if (ConcurrentMask.Succeeded(ConcurrentMask.TryAllocate(ref SharedStatics.IsInstalled.Ref.Data, handle.Value, 1)))
			{
				handle.Install(new TableEntry
				{
					state = allocatorState,
					function = functionPointer.Value
				});
				Managed.RegisterDelegate(handle.Index, function);
				if (IsAutoDispose)
				{
					ConcurrentMask.TryAllocate(ref SharedStatics.IsAutoDispose.Ref.Data, handle.Value, 1);
				}
			}
		}

		internal static void Install(AllocatorHandle handle, IntPtr allocatorState, TryFunction function)
		{
			FunctionPointer<TryFunction> functionPointer = ((function == null) ? new FunctionPointer<TryFunction>(IntPtr.Zero) : BurstCompiler.CompileFunctionPointer(function));
			Install(handle, allocatorState, functionPointer, function);
		}

		internal static AllocatorHandle Register(IntPtr allocatorState, FunctionPointer<TryFunction> functionPointer, bool IsAutoDispose = false, bool isGlobal = false, int globalIndex = 0)
		{
			int error;
			int offset;
			if (isGlobal)
			{
				if (globalIndex < GlobalAllocatorBaseIndex)
				{
					throw new ArgumentException($"Error: {globalIndex} is less than GlobalAllocatorBaseIndex");
				}
				error = ConcurrentMask.TryAllocate(ref SharedStatics.IsInstalled.Ref.Data, globalIndex, 1);
				offset = globalIndex;
			}
			else
			{
				error = ConcurrentMask.TryAllocate(ref SharedStatics.IsInstalled.Ref.Data, out offset, 1, (int)(GlobalAllocatorBaseIndex - 1), 1);
			}
			TableEntry tableEntry = new TableEntry
			{
				state = allocatorState,
				function = functionPointer.Value
			};
			AllocatorHandle result = default(AllocatorHandle);
			if (ConcurrentMask.Succeeded(error))
			{
				result.Index = (ushort)offset;
				result.Install(tableEntry);
				if (IsAutoDispose)
				{
					ConcurrentMask.TryAllocate(ref SharedStatics.IsAutoDispose.Ref.Data, offset, 1);
				}
			}
			return result;
		}

		[ExcludeFromBurstCompatTesting("Uses managed delegate")]
		public unsafe static void Register<T>(this ref T t, bool IsAutoDispose = false, bool isGlobal = false, int globalIndex = 0) where T : unmanaged, IAllocator
		{
			TryFunction function = t.Function;
			FunctionPointer<TryFunction> functionPointer;
			if (function == null)
			{
				functionPointer = new FunctionPointer<TryFunction>(IntPtr.Zero);
			}
			else
			{
				if (function != AllocatorCache<T>.CachedFunction)
				{
					AllocatorCache<T>.TryFunction = BurstCompiler.CompileFunctionPointer(function);
					AllocatorCache<T>.CachedFunction = function;
				}
				functionPointer = AllocatorCache<T>.TryFunction;
			}
			t.Handle = Register((IntPtr)UnsafeUtility.AddressOf(ref t), functionPointer, IsAutoDispose, isGlobal, globalIndex);
			Managed.RegisterDelegate(t.Handle.Index, t.Function);
		}

		public static void UnmanagedUnregister<T>(this ref T t) where T : unmanaged, IAllocator
		{
			if (t.Handle.IsInstalled)
			{
				t.Handle.Install(default(TableEntry));
				ConcurrentMask.TryFree(ref SharedStatics.IsInstalled.Ref.Data, t.Handle.Value, 1);
				ConcurrentMask.TryFree(ref SharedStatics.IsAutoDispose.Ref.Data, t.Handle.Value, 1);
			}
		}

		[ExcludeFromBurstCompatTesting("Uses managed delegate")]
		public static void Unregister<T>(this ref T t) where T : unmanaged, IAllocator
		{
			if (t.Handle.IsInstalled)
			{
				t.Handle.Dispose();
				ConcurrentMask.TryFree(ref SharedStatics.IsInstalled.Ref.Data, t.Handle.Value, 1);
				ConcurrentMask.TryFree(ref SharedStatics.IsAutoDispose.Ref.Data, t.Handle.Value, 1);
				Managed.UnregisterDelegate(t.Handle.Index);
			}
		}

		[ExcludeFromBurstCompatTesting("Register uses managed delegate")]
		internal unsafe static ref T CreateAllocator<T>(AllocatorHandle backingAllocator, bool isGlobal = false, int globalIndex = 0) where T : unmanaged, IAllocator
		{
			T* ptr = (T*)Memory.Unmanaged.Allocate(UnsafeUtility.SizeOf<T>(), 16, backingAllocator);
			*ptr = default(T);
			ref T reference = ref UnsafeUtility.AsRef<T>(ptr);
			Register(ref reference, ptr->IsAutoDispose, isGlobal, globalIndex);
			return ref reference;
		}

		[ExcludeFromBurstCompatTesting("Registration uses managed delegates")]
		internal unsafe static void DestroyAllocator<T>(this ref T t, AllocatorHandle backingAllocator) where T : unmanaged, IAllocator
		{
			Unregister(ref t);
			Memory.Unmanaged.Free(UnsafeUtility.AddressOf(ref t), backingAllocator);
		}

		public static void Shutdown()
		{
		}

		internal static bool IsCustomAllocator(AllocatorHandle allocator)
		{
			return allocator.Index >= 64;
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		internal static void CheckFailedToAllocate(int error)
		{
			if (error != 0)
			{
				throw new ArgumentException("failed to allocate");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		internal static void CheckFailedToFree(int error)
		{
			if (error != 0)
			{
				throw new ArgumentException("failed to free");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		internal static void CheckValid(AllocatorHandle handle)
		{
		}

		public static void Initialize$StackAllocator_Try_000000AB$BurstDirectCall()
		{
			StackAllocator.Try_000000AB$BurstDirectCall.Initialize();
		}

		public static void Initialize$SlabAllocator_Try_000000B9$BurstDirectCall()
		{
			SlabAllocator.Try_000000B9$BurstDirectCall.Initialize();
		}
	}
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(AllocatorManager.AllocatorHandle) })]
	public struct AllocatorHelper<T> : IDisposable where T : unmanaged, AllocatorManager.IAllocator
	{
		private unsafe readonly T* m_allocator;

		private AllocatorManager.AllocatorHandle m_backingAllocator;

		public unsafe ref T Allocator => ref UnsafeUtility.AsRef<T>(m_allocator);

		[ExcludeFromBurstCompatTesting("CreateAllocator is unburstable")]
		public unsafe AllocatorHelper(AllocatorManager.AllocatorHandle backingAllocator, bool isGlobal = false, int globalIndex = 0)
		{
			m_allocator = (T*)UnsafeUtility.AddressOf(ref AllocatorManager.CreateAllocator<T>(backingAllocator, isGlobal, globalIndex));
			m_backingAllocator = backingAllocator;
		}

		[ExcludeFromBurstCompatTesting("DestroyAllocator is unburstable")]
		public unsafe void Dispose()
		{
			AllocatorManager.DestroyAllocator(ref UnsafeUtility.AsRef<T>(m_allocator), m_backingAllocator);
		}
	}
	internal struct ArrayOfArrays<T> : IDisposable where T : unmanaged
	{
		private AllocatorManager.AllocatorHandle m_backingAllocatorHandle;

		private int m_lengthInElements;

		private int m_capacityInElements;

		private int m_log2BlockSizeInElements;

		private int m_blocks;

		private unsafe IntPtr* m_block;

		private int BlockSizeInElements => 1 << m_log2BlockSizeInElements;

		private unsafe int BlockSizeInBytes => BlockSizeInElements * sizeof(T);

		private int BlockMask => BlockSizeInElements - 1;

		public int Length => m_lengthInElements;

		public int Capacity => m_capacityInElements;

		public unsafe ref T this[int elementIndex]
		{
			get
			{
				int num = BlockIndexOfElement(elementIndex);
				IntPtr intPtr = m_block[num];
				int num2 = elementIndex & BlockMask;
				T* ptr = (T*)(void*)intPtr;
				return ref ptr[num2];
			}
		}

		public unsafe ArrayOfArrays(int capacityInElements, AllocatorManager.AllocatorHandle backingAllocatorHandle, int log2BlockSizeInElements = 12)
		{
			this = default(ArrayOfArrays<T>);
			m_backingAllocatorHandle = backingAllocatorHandle;
			m_lengthInElements = 0;
			m_capacityInElements = capacityInElements;
			m_log2BlockSizeInElements = log2BlockSizeInElements;
			m_blocks = capacityInElements + BlockMask >> m_log2BlockSizeInElements;
			m_block = (IntPtr*)Memory.Unmanaged.Allocate(sizeof(IntPtr) * m_blocks, 16, m_backingAllocatorHandle);
			UnsafeUtility.MemSet(m_block, 0, sizeof(IntPtr) * m_blocks);
		}

		public unsafe void LockfreeAdd(T t)
		{
			int elementIndex = Interlocked.Increment(ref m_lengthInElements) - 1;
			int i = BlockIndexOfElement(elementIndex);
			if (m_block[i] == IntPtr.Zero)
			{
				void* ptr = Memory.Unmanaged.Allocate(BlockSizeInBytes, 16, m_backingAllocatorHandle);
				int num;
				for (num = math.min(m_blocks, i + 4); i < num && !(IntPtr.Zero == Interlocked.CompareExchange(ref m_block[i], (IntPtr)ptr, IntPtr.Zero)); i++)
				{
				}
				if (i == num)
				{
					Memory.Unmanaged.Free(ptr, m_backingAllocatorHandle);
				}
			}
			this[elementIndex] = t;
		}

		public void Rewind()
		{
			m_lengthInElements = 0;
		}

		public unsafe void Clear()
		{
			Rewind();
			for (int i = 0; i < m_blocks; i++)
			{
				if (m_block[i] != IntPtr.Zero)
				{
					Memory.Unmanaged.Free((void*)m_block[i], m_backingAllocatorHandle);
					m_block[i] = IntPtr.Zero;
				}
			}
		}

		public unsafe void Dispose()
		{
			Clear();
			Memory.Unmanaged.Free(m_block, m_backingAllocatorHandle);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckElementIndex(int elementIndex)
		{
			if (elementIndex >= m_lengthInElements)
			{
				throw new ArgumentException($"Element index {elementIndex} must be less than length in elements {m_lengthInElements}.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckBlockIndex(int blockIndex)
		{
			if (blockIndex >= m_blocks)
			{
				throw new ArgumentException($"Block index {blockIndex} must be less than number of blocks {m_blocks}.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private unsafe void CheckBlockIsNotNull(int blockIndex)
		{
			if (m_block[blockIndex] == IntPtr.Zero)
			{
				throw new ArgumentException($"Block index {blockIndex} is a null pointer.");
			}
		}

		public void RemoveAtSwapBack(int elementIndex)
		{
			this[elementIndex] = this[Length - 1];
			m_lengthInElements--;
		}

		private int BlockIndexOfElement(int elementIndex)
		{
			return elementIndex >> m_log2BlockSizeInElements;
		}

		public unsafe void TrimExcess()
		{
			for (int i = BlockIndexOfElement(m_lengthInElements + BlockMask); i < m_blocks; i++)
			{
				if (m_block[i] != IntPtr.Zero)
				{
					Memory.Unmanaged.Free((void*)m_block[i], m_backingAllocatorHandle);
					m_block[i] = IntPtr.Zero;
				}
			}
		}
	}
	[BurstCompile]
	internal struct AutoFreeAllocator : AllocatorManager.IAllocator, IDisposable
	{
		internal delegate int Try_000000E3$PostfixBurstDelegate(IntPtr state, ref AllocatorManager.Block block);

		internal static class Try_000000E3$BurstDirectCall
		{
			private static IntPtr Pointer;

			private static IntPtr DeferredCompilation;

			[BurstDiscard]
			private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
			{
				if (Pointer == (IntPtr)0)
				{
					Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(Try_000000E3$PostfixBurstDelegate).TypeHandle);
				}
				P_0 = Pointer;
			}

			private static IntPtr GetFunctionPointer()
			{
				nint result = 0;
				GetFunctionPointerDiscard(ref result);
				return result;
			}

			public static void Constructor()
			{
				DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
			}

			public static void Initialize()
			{
			}

			static Try_000000E3$BurstDirectCall()
			{
				Constructor();
			}

			public unsafe static int Invoke(IntPtr state, ref AllocatorManager.Block block)
			{
				if (BurstCompiler.IsEnabled)
				{
					IntPtr functionPointer = GetFunctionPointer();
					if (functionPointer != (IntPtr)0)
					{
						return ((delegate* unmanaged[Cdecl]<IntPtr, ref AllocatorManager.Block, int>)functionPointer)(state, ref block);
					}
				}
				return Try$BurstManaged(state, ref block);
			}
		}

		private ArrayOfArrays<IntPtr> m_allocated;

		private ArrayOfArrays<IntPtr> m_tofree;

		private AllocatorManager.AllocatorHandle m_handle;

		private AllocatorManager.AllocatorHandle m_backingAllocatorHandle;

		public AllocatorManager.TryFunction Function => Try;

		public AllocatorManager.AllocatorHandle Handle
		{
			get
			{
				return m_handle;
			}
			set
			{
				m_handle = value;
			}
		}

		public Allocator ToAllocator => m_handle.ToAllocator;

		public bool IsCustomAllocator => m_handle.IsCustomAllocator;

		public bool IsAutoDispose => true;

		public unsafe void Update()
		{
			int length = m_tofree.Length;
			while (length-- > 0)
			{
				int length2 = m_allocated.Length;
				while (length2-- > 0)
				{
					if (m_allocated[length2] == m_tofree[length])
					{
						Memory.Unmanaged.Free((void*)m_tofree[length], m_backingAllocatorHandle);
						m_allocated.RemoveAtSwapBack(length2);
						break;
					}
				}
			}
			m_tofree.Rewind();
			m_allocated.TrimExcess();
		}

		public void Initialize(AllocatorManager.AllocatorHandle backingAllocatorHandle)
		{
			m_allocated = new ArrayOfArrays<IntPtr>(1048576, backingAllocatorHandle);
			m_tofree = new ArrayOfArrays<IntPtr>(131072, backingAllocatorHandle);
			m_backingAllocatorHandle = backingAllocatorHandle;
		}

		public unsafe void FreeAll()
		{
			Update();
			m_handle.Rewind();
			for (int i = 0; i < m_allocated.Length; i++)
			{
				Memory.Unmanaged.Free((void*)m_allocated[i], m_backingAllocatorHandle);
			}
			m_allocated.Rewind();
		}

		public void Dispose()
		{
			FreeAll();
			m_tofree.Dispose();
			m_allocated.Dispose();
		}

		public unsafe int Try(ref AllocatorManager.Block block)
		{
			if (block.Range.Pointer == IntPtr.Zero)
			{
				if (block.Bytes == 0L)
				{
					return 0;
				}
				byte* ptr = (byte*)Memory.Unmanaged.Allocate(block.Bytes, block.Alignment, m_backingAllocatorHandle);
				block.Range.Pointer = (IntPtr)ptr;
				block.AllocatedItems = block.Range.Items;
				m_allocated.LockfreeAdd(block.Range.Pointer);
				return 0;
			}
			if (block.Range.Items == 0)
			{
				m_tofree.LockfreeAdd(block.Range.Pointer);
				block.Range.Pointer = IntPtr.Zero;
				block.AllocatedItems = 0;
				return 0;
			}
			return -1;
		}

		[BurstCompile]
		[MonoPInvokeCallback(typeof(AllocatorManager.TryFunction))]
		internal static int Try(IntPtr state, ref AllocatorManager.Block block)
		{
			return Try_000000E3$BurstDirectCall.Invoke(state, ref block);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[BurstCompile]
		[MonoPInvokeCallback(typeof(AllocatorManager.TryFunction))]
		internal unsafe static int Try$BurstManaged(IntPtr state, ref AllocatorManager.Block block)
		{
			return ((AutoFreeAllocator*)(void*)state)->Try(ref block);
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	[GenerateTestsForBurstCompatibility]
	internal struct Bitwise
	{
		internal static int AlignDown(int value, int alignPow2)
		{
			return value & ~(alignPow2 - 1);
		}

		internal static int AlignUp(int value, int alignPow2)
		{
			return AlignDown(value + alignPow2 - 1, alignPow2);
		}

		internal static int FromBool(bool value)
		{
			if (!value)
			{
				return 0;
			}
			return 1;
		}

		internal static uint ExtractBits(uint input, int pos, uint mask)
		{
			return (input >> pos) & mask;
		}

		internal static uint ReplaceBits(uint input, int pos, uint mask, uint value)
		{
			uint num = (value & mask) << pos;
			uint num2 = input & ~(mask << pos);
			return num | num2;
		}

		internal static uint SetBits(uint input, int pos, uint mask, bool value)
		{
			return ReplaceBits(input, pos, mask, (uint)(-FromBool(value)));
		}

		internal static ulong ExtractBits(ulong input, int pos, ulong mask)
		{
			return (input >> pos) & mask;
		}

		internal static ulong ReplaceBits(ulong input, int pos, ulong mask, ulong value)
		{
			ulong num = (value & mask) << pos;
			ulong num2 = input & ~(mask << pos);
			return num | num2;
		}

		internal static ulong SetBits(ulong input, int pos, ulong mask, bool value)
		{
			return ReplaceBits(input, pos, mask, (ulong)(-FromBool(value)));
		}

		internal static int lzcnt(byte value)
		{
			return math.lzcnt((uint)value) - 24;
		}

		internal static int tzcnt(byte value)
		{
			return math.min(8, math.tzcnt((uint)value));
		}

		internal static int lzcnt(ushort value)
		{
			return math.lzcnt((uint)value) - 16;
		}

		internal static int tzcnt(ushort value)
		{
			return math.min(16, math.tzcnt((uint)value));
		}

		private unsafe static int FindUlong(ulong* ptr, int beginBit, int endBit, int numBits)
		{
			_ = numBits + 63 >> 6;
			int num = 64;
			int i = beginBit / num;
			for (int num2 = AlignUp(endBit, num) / num; i < num2; i++)
			{
				if (ptr[i] != 0L)
				{
					continue;
				}
				int num3 = i * num;
				int num4 = math.min(num3 + num, endBit) - num3;
				if (num3 != beginBit)
				{
					ulong x = ptr[num3 / num - 1];
					int num5 = math.max(num3 - math.lzcnt(x), beginBit);
					num4 += num3 - num5;
					num3 = num5;
				}
				for (i++; i < num2; i++)
				{
					if (num4 >= numBits)
					{
						return num3;
					}
					ulong num6 = ptr[i];
					int num7 = i * num;
					num4 += math.min(num7 + math.tzcnt(num6), endBit) - num7;
					if (num6 != 0L)
					{
						break;
					}
				}
				if (num4 >= numBits)
				{
					return num3;
				}
			}
			return endBit;
		}

		private unsafe static int FindUint(ulong* ptr, int beginBit, int endBit, int numBits)
		{
			_ = numBits + 31 >> 5;
			int num = 32;
			int i = beginBit / num;
			for (int num2 = AlignUp(endBit, num) / num; i < num2; i++)
			{
				if (((uint*)ptr)[i] != 0)
				{
					continue;
				}
				int num3 = i * num;
				int num4 = math.min(num3 + num, endBit) - num3;
				if (num3 != beginBit)
				{
					uint x = ((uint*)ptr)[num3 / num - 1];
					int num5 = math.max(num3 - math.lzcnt(x), beginBit);
					num4 += num3 - num5;
					num3 = num5;
				}
				for (i++; i < num2; i++)
				{
					if (num4 >= numBits)
					{
						return num3;
					}
					uint num6 = ((uint*)ptr)[i];
					int num7 = i * num;
					num4 += math.min(num7 + math.tzcnt(num6), endBit) - num7;
					if (num6 != 0)
					{
						break;
					}
				}
				if (num4 >= numBits)
				{
					return num3;
				}
			}
			return endBit;
		}

		private unsafe static int FindUshort(ulong* ptr, int beginBit, int endBit, int numBits)
		{
			_ = numBits + 15 >> 4;
			int num = 16;
			int i = beginBit / num;
			for (int num2 = AlignUp(endBit, num) / num; i < num2; i++)
			{
				if (((ushort*)ptr)[i] != 0)
				{
					continue;
				}
				int num3 = i * num;
				int num4 = math.min(num3 + num, endBit) - num3;
				if (num3 != beginBit)
				{
					ushort value = ((ushort*)ptr)[num3 / num - 1];
					int num5 = math.max(num3 - lzcnt(value), beginBit);
					num4 += num3 - num5;
					num3 = num5;
				}
				for (i++; i < num2; i++)
				{
					if (num4 >= numBits)
					{
						return num3;
					}
					ushort num6 = ((ushort*)ptr)[i];
					int num7 = i * num;
					num4 += math.min(num7 + tzcnt(num6), endBit) - num7;
					if (num6 != 0)
					{
						break;
					}
				}
				if (num4 >= numBits)
				{
					return num3;
				}
			}
			return endBit;
		}

		private unsafe static int FindByte(ulong* ptr, int beginBit, int endBit, int numBits)
		{
			_ = numBits + 7 >> 3;
			int num = 8;
			int i = beginBit / num;
			for (int num2 = AlignUp(endBit, num) / num; i < num2; i++)
			{
				if (((bool*)ptr)[i])
				{
					continue;
				}
				int num3 = i * num;
				int num4 = math.min(num3 + num, endBit) - num3;
				if (num3 != beginBit)
				{
					byte value = ((byte*)ptr)[num3 / num - 1];
					int num5 = math.max(num3 - lzcnt(value), beginBit);
					num4 += num3 - num5;
					num3 = num5;
				}
				for (i++; i < num2; i++)
				{
					if (num4 >= numBits)
					{
						return num3;
					}
					byte b = ((byte*)ptr)[i];
					int num6 = i * num;
					num4 += math.min(num6 + tzcnt(b), endBit) - num6;
					if (b != 0)
					{
						break;
					}
				}
				if (num4 >= numBits)
				{
					return num3;
				}
			}
			return endBit;
		}

		private unsafe static int FindUpto14bits(ulong* ptr, int beginBit, int endBit, int numBits)
		{
			byte b = (byte)(beginBit & 7);
			byte b2 = (byte)(~(255 << (int)b));
			int num = 0;
			int num2 = beginBit / 8;
			int num3 = AlignUp(endBit, 8) / 8;
			for (int i = num2; i < num3; i++)
			{
				byte b3 = ((byte*)ptr)[i];
				b3 = (byte)(b3 | ((i == num2) ? b2 : 0));
				if (b3 != byte.MaxValue)
				{
					int num4 = i * 8;
					int num5 = math.min(num4 + tzcnt(b3), endBit) - num4;
					if (num + num5 >= numBits)
					{
						return num4 - num;
					}
					num = lzcnt(b3);
					int num6 = num4 + 8;
					int num7 = math.max(num6 - num, beginBit);
					num = math.min(num6, endBit) - num7;
					if (num >= numBits)
					{
						return num7;
					}
				}
			}
			return endBit;
		}

		private unsafe static int FindUpto6bits(ulong* ptr, int beginBit, int endBit, int numBits)
		{
			byte b = (byte)(~(255 << (beginBit & 7)));
			byte b2 = (byte)(~(255 >> ((8 - (endBit & 7)) & 7)));
			int num = 1 << numBits - 1;
			int num2 = beginBit / 8;
			int num3 = AlignUp(endBit, 8) / 8;
			for (int i = num2; i < num3; i++)
			{
				byte b3 = ((byte*)ptr)[i];
				b3 = (byte)(b3 | ((i == num2) ? b : 0));
				b3 = (byte)(b3 | ((i == num3 - 1) ? b2 : 0));
				if (b3 == byte.MaxValue)
				{
					continue;
				}
				int num4 = i * 8;
				int num5 = num4 + 7;
				while (num4 < num5)
				{
					int num6 = tzcnt((byte)(b3 ^ 0xFF));
					b3 = (byte)(b3 >> num6);
					num4 += num6;
					if ((b3 & num) == 0)
					{
						return num4;
					}
					b3 >>= 1;
					num4++;
				}
			}
			return endBit;
		}

		internal unsafe static int FindWithBeginEnd(ulong* ptr, int beginBit, int endBit, int numBits)
		{
			int num;
			if (numBits >= 127)
			{
				num = FindUlong(ptr, beginBit, endBit, numBits);
				if (num != endBit)
				{
					return num;
				}
			}
			if (numBits >= 63)
			{
				num = FindUint(ptr, beginBit, endBit, numBits);
				if (num != endBit)
				{
					return num;
				}
			}
			if (numBits >= 128)
			{
				return int.MaxValue;
			}
			if (numBits >= 31)
			{
				num = FindUshort(ptr, beginBit, endBit, numBits);
				if (num != endBit)
				{
					return num;
				}
			}
			if (numBits >= 64)
			{
				return int.MaxValue;
			}
			num = FindByte(ptr, beginBit, endBit, numBits);
			if (num != endBit)
			{
				return num;
			}
			if (numBits < 15)
			{
				num = FindUpto14bits(ptr, beginBit, endBit, numBits);
				if (num != endBit)
				{
					return num;
				}
				if (numBits < 7)
				{
					num = FindUpto6bits(ptr, beginBit, endBit, numBits);
					if (num != endBit)
					{
						return num;
					}
				}
			}
			return int.MaxValue;
		}

		internal unsafe static int Find(ulong* ptr, int pos, int count, int numBits)
		{
			return FindWithBeginEnd(ptr, pos, pos + count, numBits);
		}

		internal unsafe static bool TestNone(ulong* ptr, int length, int pos, int numBits = 1)
		{
			int num = math.min(pos + numBits, length);
			int num2 = pos >> 6;
			int num3 = pos & 0x3F;
			int num4 = num - 1 >> 6;
			int num5 = num & 0x3F;
			ulong num6 = (ulong)(-1L << num3);
			ulong num7 = ulong.MaxValue >> 64 - num5;
			if (num2 == num4)
			{
				ulong num8 = num6 & num7;
				return (ptr[num2] & num8) == 0;
			}
			if ((ptr[num2] & num6) != 0L)
			{
				return false;
			}
			for (int i = num2 + 1; i < num4; i++)
			{
				if (ptr[i] != 0L)
				{
					return false;
				}
			}
			return (ptr[num4] & num7) == 0;
		}

		internal unsafe static bool TestAny(ulong* ptr, int length, int pos, int numBits = 1)
		{
			int num = math.min(pos + numBits, length);
			int num2 = pos >> 6;
			int num3 = pos & 0x3F;
			int num4 = num - 1 >> 6;
			int num5 = num & 0x3F;
			ulong num6 = (ulong)(-1L << num3);
			ulong num7 = ulong.MaxValue >> 64 - num5;
			if (num2 == num4)
			{
				ulong num8 = num6 & num7;
				return (ptr[num2] & num8) != 0;
			}
			if ((ptr[num2] & num6) != 0L)
			{
				return true;
			}
			for (int i = num2 + 1; i < num4; i++)
			{
				if (ptr[i] != 0L)
				{
					return true;
				}
			}
			return (ptr[num4] & num7) != 0;
		}

		internal unsafe static bool TestAll(ulong* ptr, int length, int pos, int numBits = 1)
		{
			int num = math.min(pos + numBits, length);
			int num2 = pos >> 6;
			int num3 = pos & 0x3F;
			int num4 = num - 1 >> 6;
			int num5 = num & 0x3F;
			ulong num6 = (ulong)(-1L << num3);
			ulong num7 = ulong.MaxValue >> 64 - num5;
			if (num2 == num4)
			{
				ulong num8 = num6 & num7;
				return num8 == (ptr[num2] & num8);
			}
			if (num6 != (ptr[num2] & num6))
			{
				return false;
			}
			for (int i = num2 + 1; i < num4; i++)
			{
				if (ulong.MaxValue != ptr[i])
				{
					return false;
				}
			}
			return num7 == (ptr[num4] & num7);
		}

		internal unsafe static int CountBits(ulong* ptr, int length, int pos, int numBits = 1)
		{
			int num = math.min(pos + numBits, length);
			int num2 = pos >> 6;
			int num3 = pos & 0x3F;
			int num4 = num - 1 >> 6;
			int num5 = num & 0x3F;
			ulong num6 = (ulong)(-1L << num3);
			ulong num7 = ulong.MaxValue >> 64 - num5;
			if (num2 == num4)
			{
				ulong num8 = num6 & num7;
				return math.countbits(ptr[num2] & num8);
			}
			int num9 = math.countbits(ptr[num2] & num6);
			for (int i = num2 + 1; i < num4; i++)
			{
				num9 += math.countbits(ptr[i]);
			}
			return num9 + math.countbits(ptr[num4] & num7);
		}

		internal unsafe static bool IsSet(ulong* ptr, int pos)
		{
			int num = pos >> 6;
			int num2 = pos & 0x3F;
			ulong num3 = (ulong)(1L << num2);
			return (ptr[num] & num3) != 0;
		}

		internal unsafe static ulong GetBits(ulong* ptr, int length, int pos, int numBits = 1)
		{
			int num = pos >> 6;
			int num2 = pos & 0x3F;
			if (num2 + numBits <= 64)
			{
				ulong mask = ulong.MaxValue >> 64 - numBits;
				return ExtractBits(ptr[num], num2, mask);
			}
			int num3 = math.min(pos + numBits, length);
			int num4 = num3 - 1 >> 6;
			int num5 = num3 & 0x3F;
			ulong mask2 = ulong.MaxValue >> num2;
			ulong num6 = ExtractBits(ptr[num], num2, mask2);
			ulong mask3 = ulong.MaxValue >> 64 - num5;
			return (ExtractBits(ptr[num4], 0, mask3) << 64 - num2) | num6;
		}
	}
	[DebuggerTypeProxy(typeof(BitField32DebugView))]
	[GenerateTestsForBurstCompatibility]
	public struct BitField32
	{
		public uint Value;

		public BitField32(uint initialValue = 0u)
		{
			Value = initialValue;
		}

		public void Clear()
		{
			Value = 0u;
		}

		public void SetBits(int pos, bool value)
		{
			Value = Bitwise.SetBits(Value, pos, 1u, value);
		}

		public void SetBits(int pos, bool value, int numBits)
		{
			uint mask = uint.MaxValue >> 32 - numBits;
			Value = Bitwise.SetBits(Value, pos, mask, value);
		}

		public uint GetBits(int pos, int numBits = 1)
		{
			uint mask = uint.MaxValue >> 32 - numBits;
			return Bitwise.ExtractBits(Value, pos, mask);
		}

		public bool IsSet(int pos)
		{
			return GetBits(pos) != 0;
		}

		public bool TestNone(int pos, int numBits = 1)
		{
			return GetBits(pos, numBits) == 0;
		}

		public bool TestAny(int pos, int numBits = 1)
		{
			return GetBits(pos, numBits) != 0;
		}

		public bool TestAll(int pos, int numBits = 1)
		{
			uint num = uint.MaxValue >> 32 - numBits;
			return num == Bitwise.ExtractBits(Value, pos, num);
		}

		public int CountBits()
		{
			return math.countbits(Value);
		}

		public int CountLeadingZeros()
		{
			return math.lzcnt(Value);
		}

		public int CountTrailingZeros()
		{
			return math.tzcnt(Value);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckArgs(int pos, int numBits)
		{
			if (pos > 31 || numBits == 0 || numBits > 32 || pos + numBits > 32)
			{
				throw new ArgumentException($"BitField32 invalid arguments: pos {pos} (must be 0-31), numBits {numBits} (must be 1-32).");
			}
		}
	}
	internal sealed class BitField32DebugView
	{
		private BitField32 BitField;

		public bool[] Bits
		{
			get
			{
				bool[] array = new bool[32];
				for (int i = 0; i < 32; i++)
				{
					array[i] = BitField.IsSet(i);
				}
				return array;
			}
		}

		public BitField32DebugView(BitField32 bitfield)
		{
			BitField = bitfield;
		}
	}
	[DebuggerTypeProxy(typeof(BitField64DebugView))]
	[GenerateTestsForBurstCompatibility]
	public struct BitField64
	{
		public ulong Value;

		public BitField64(ulong initialValue = 0uL)
		{
			Value = initialValue;
		}

		public void Clear()
		{
			Value = 0uL;
		}

		public void SetBits(int pos, bool value)
		{
			Value = Bitwise.SetBits(Value, pos, 1uL, value);
		}

		public void SetBits(int pos, bool value, int numBits = 1)
		{
			ulong mask = ulong.MaxValue >> 64 - numBits;
			Value = Bitwise.SetBits(Value, pos, mask, value);
		}

		public ulong GetBits(int pos, int numBits = 1)
		{
			ulong mask = ulong.MaxValue >> 64 - numBits;
			return Bitwise.ExtractBits(Value, pos, mask);
		}

		public bool IsSet(int pos)
		{
			return GetBits(pos) != 0;
		}

		public bool TestNone(int pos, int numBits = 1)
		{
			return GetBits(pos, numBits) == 0;
		}

		public bool TestAny(int pos, int numBits = 1)
		{
			return GetBits(pos, numBits) != 0;
		}

		public bool TestAll(int pos, int numBits = 1)
		{
			ulong num = ulong.MaxValue >> 64 - numBits;
			return num == Bitwise.ExtractBits(Value, pos, num);
		}

		public int CountBits()
		{
			return math.countbits(Value);
		}

		public int CountLeadingZeros()
		{
			return math.lzcnt(Value);
		}

		public int CountTrailingZeros()
		{
			return math.tzcnt(Value);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckArgs(int pos, int numBits)
		{
			if (pos > 63 || numBits == 0 || numBits > 64 || pos + numBits > 64)
			{
				throw new ArgumentException($"BitField32 invalid arguments: pos {pos} (must be 0-63), numBits {numBits} (must be 1-64).");
			}
		}
	}
	internal sealed class BitField64DebugView
	{
		private BitField64 Data;

		public bool[] Bits
		{
			get
			{
				bool[] array = new bool[64];
				for (int i = 0; i < 64; i++)
				{
					array[i] = Data.IsSet(i);
				}
				return array;
			}
		}

		public BitField64DebugView(BitField64 data)
		{
			Data = data;
		}
	}
	public interface INativeDisposable : IDisposable
	{
		JobHandle Dispose(JobHandle inputDeps);
	}
	[GenerateTestsForBurstCompatibility]
	public static class CollectionHelper
	{
		[StructLayout(LayoutKind.Explicit)]
		internal struct LongDoubleUnion
		{
			[FieldOffset(0)]
			internal long longValue;

			[FieldOffset(0)]
			internal double doubleValue;
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		[BurstCompile]
		public struct DummyJob : IJob
		{
			public void Execute()
			{
			}
		}

		public const int CacheLineSize = 64;

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		internal static void CheckAllocator(AllocatorManager.AllocatorHandle allocator)
		{
			if (!ShouldDeallocate(allocator))
			{
				throw new ArgumentException($"Allocator {allocator} must not be None or Invalid");
			}
		}

		public static int Log2Floor(int value)
		{
			return 31 - math.lzcnt((uint)value);
		}

		public static int Log2Ceil(int value)
		{
			return 32 - math.lzcnt((uint)(value - 1));
		}

		public static int Align(int size, int alignmentPowerOfTwo)
		{
			if (alignmentPowerOfTwo == 0)
			{
				return size;
			}
			return (size + alignmentPowerOfTwo - 1) & ~(alignmentPowerOfTwo - 1);
		}

		public static ulong Align(ulong size, ulong alignmentPowerOfTwo)
		{
			if (alignmentPowerOfTwo == 0L)
			{
				return size;
			}
			return (size + alignmentPowerOfTwo - 1) & ~(alignmentPowerOfTwo - 1);
		}

		public unsafe static bool IsAligned(void* p, int alignmentPowerOfTwo)
		{
			return ((ulong)p & (ulong)((long)alignmentPowerOfTwo - 1L)) == 0;
		}

		public static bool IsAligned(ulong offset, int alignmentPowerOfTwo)
		{
			return (offset & (ulong)((long)alignmentPowerOfTwo - 1L)) == 0;
		}

		public static bool IsPowerOfTwo(int value)
		{
			return (value & (value - 1)) == 0;
		}

		public unsafe static uint Hash(void* ptr, int bytes)
		{
			ulong num = 5381uL;
			while (bytes > 0)
			{
				ulong num2 = ((byte*)ptr)[--bytes];
				num = (num << 5) + num + num2;
			}
			return (uint)num;
		}

		[ExcludeFromBurstCompatTesting("Used only for debugging, and uses managed strings")]
		internal static void WriteLayout(Type type)
		{
			Console.WriteLine($"   Offset | Bytes  | Name     Layout: {0}", type.Name);
			FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (FieldInfo fieldInfo in fields)
			{
				Console.WriteLine("   {0, 6} | {1, 6} | {2}", Marshal.OffsetOf(type, fieldInfo.Name), Marshal.SizeOf(fieldInfo.FieldType), fieldInfo.Name);
			}
		}

		internal static bool ShouldDeallocate(AllocatorManager.AllocatorHandle allocator)
		{
			return allocator.ToAllocator > Allocator.None;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[return: AssumeRange(0L, 2147483647L)]
		internal static int AssumePositive(int value)
		{
			return value;
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "ENABLE_UNITY_COLLECTIONS_CHECKS", GenericTypeArguments = new Type[] { typeof(NativeArray<int>) })]
		internal static void CheckIsUnmanaged<T>()
		{
			if (!UnsafeUtility.IsUnmanaged<T>())
			{
				throw new ArgumentException($"{typeof(T)} used in native collection is not blittable or not primitive");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		internal static void CheckIntPositivePowerOfTwo(int value)
		{
			if (value <= 0 || (value & (value - 1)) != 0)
			{
				throw new ArgumentException($"Alignment requested: {value} is not a non-zero, positive power of two.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		internal static void CheckUlongPositivePowerOfTwo(ulong value)
		{
			if (value == 0 || (value & (value - 1)) != 0)
			{
				throw new ArgumentException($"Alignment requested: {value} is not a non-zero, positive power of two.");
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		internal static void CheckIndexInRange(int index, int length)
		{
			if ((uint)index >= (uint)length)
			{
				throw new IndexOutOfRangeException($"Index {index} is out of range in container of '{length}' Length.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		internal static void CheckCapacityInRange(int capacity, int length)
		{
			if (capacity < 0)
			{
				throw new ArgumentOutOfRangeException($"Capacity {capacity} must be positive.");
			}
			if (capacity < length)
			{
				throw new ArgumentOutOfRangeException($"Capacity {capacity} is out of range in container of '{length}' Length.");
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(AllocatorManager.AllocatorHandle)
		})]
		public static NativeArray<T> CreateNativeArray<T, U>(int length, ref U allocator, NativeArrayOptions options = NativeArrayOptions.ClearMemory) where T : unmanaged where U : unmanaged, AllocatorManager.IAllocator
		{
			NativeArray<T> array;
			if (!allocator.IsCustomAllocator)
			{
				array = new NativeArray<T>(length, allocator.ToAllocator, options);
			}
			else
			{
				array = default(NativeArray<T>);
				NativeArrayExtensions.Initialize(ref array, length, ref allocator, options);
			}
			return array;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static NativeArray<T> CreateNativeArray<T>(int length, AllocatorManager.AllocatorHandle allocator, NativeArrayOptions options = NativeArrayOptions.ClearMemory) where T : unmanaged
		{
			NativeArray<T> array;
			if (!AllocatorManager.IsCustomAllocator(allocator))
			{
				array = new NativeArray<T>(length, allocator.ToAllocator, options);
			}
			else
			{
				array = default(NativeArray<T>);
				NativeArrayExtensions.Initialize(ref array, length, allocator, options);
			}
			return array;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static NativeArray<T> CreateNativeArray<T>(NativeArray<T> array, AllocatorManager.AllocatorHandle allocator) where T : unmanaged
		{
			NativeArray<T> array2;
			if (!AllocatorManager.IsCustomAllocator(allocator))
			{
				array2 = new NativeArray<T>(array, allocator.ToAllocator);
			}
			else
			{
				array2 = default(NativeArray<T>);
				NativeArrayExtensions.Initialize(ref array2, array.Length, allocator);
				array2.CopyFrom(array);
			}
			return array2;
		}

		[ExcludeFromBurstCompatTesting("Managed array")]
		public static NativeArray<T> CreateNativeArray<T>(T[] array, AllocatorManager.AllocatorHandle allocator) where T : unmanaged
		{
			NativeArray<T> array2;
			if (!AllocatorManager.IsCustomAllocator(allocator))
			{
				array2 = new NativeArray<T>(array, allocator.ToAllocator);
			}
			else
			{
				array2 = default(NativeArray<T>);
				NativeArrayExtensions.Initialize(ref array2, array.Length, allocator);
				array2.CopyFrom(array);
			}
			return array2;
		}

		[ExcludeFromBurstCompatTesting("Managed array")]
		public static NativeArray<T> CreateNativeArray<T, U>(T[] array, ref U allocator) where T : unmanaged where U : unmanaged, AllocatorManager.IAllocator
		{
			NativeArray<T> array2;
			if (!allocator.IsCustomAllocator)
			{
				array2 = new NativeArray<T>(array, allocator.ToAllocator);
			}
			else
			{
				array2 = default(NativeArray<T>);
				NativeArrayExtensions.Initialize(ref array2, array.Length, ref allocator);
				array2.CopyFrom(array);
			}
			return array2;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static void DisposeNativeArray<T>(NativeArray<T> nativeArray, AllocatorManager.AllocatorHandle allocator) where T : unmanaged
		{
			NativeArrayExtensions.DisposeCheckAllocator(ref nativeArray);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static void Dispose<T>(NativeArray<T> nativeArray) where T : unmanaged
		{
			NativeArrayExtensions.DisposeCheckAllocator(ref nativeArray);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckConvertArguments<T>(int length) where T : unmanaged
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException("length", "Length must be >= 0");
			}
			if (!UnsafeUtility.IsUnmanaged<T>())
			{
				throw new InvalidOperationException($"{typeof(T)} used in NativeArray<{typeof(T)}> must be unmanaged (contain no managed types).");
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static NativeArray<T> ConvertExistingDataToNativeArray<T>(void* dataPointer, int length, AllocatorManager.AllocatorHandle allocator, bool setTempMemoryHandle = false) where T : unmanaged
		{
			NativeArray<T> result = new NativeArray<T>
			{
				m_Buffer = dataPointer,
				m_Length = length
			};
			if (!allocator.IsCustomAllocator)
			{
				result.m_AllocatorLabel = allocator.ToAllocator;
			}
			else
			{
				result.m_AllocatorLabel = Allocator.None;
			}
			return result;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static NativeArray<T> ConvertExistingNativeListToNativeArray<T>(ref NativeList<T> nativeList, int length, AllocatorManager.AllocatorHandle allocator) where T : unmanaged
		{
			return ConvertExistingDataToNativeArray<T>(nativeList.GetUnsafePtr(), length, allocator);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int),
			typeof(AllocatorManager.AllocatorHandle)
		})]
		public static NativeParallelMultiHashMap<TKey, TValue> CreateNativeParallelMultiHashMap<TKey, TValue, U>(int length, ref U allocator) where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged where U : unmanaged, AllocatorManager.IAllocator
		{
			NativeParallelMultiHashMap<TKey, TValue> result = default(NativeParallelMultiHashMap<TKey, TValue>);
			result.Initialize(length, ref allocator);
			return result;
		}

		[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "ENABLE_UNITY_COLLECTIONS_CHECKS", GenericTypeArguments = new Type[] { typeof(DummyJob) })]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		public static void CheckReflectionDataCorrect<T>(IntPtr reflectionData)
		{
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		[BurstDiscard]
		private static void CheckReflectionDataCorrectInternal<T>(IntPtr reflectionData, ref bool burstCompiled)
		{
			if (reflectionData == IntPtr.Zero)
			{
				throw new InvalidOperationException($"Reflection data was not set up by an Initialize() call. For generic job types, please include [assembly: RegisterGenericJobType(typeof({typeof(T)}))] in your source file.");
			}
			burstCompiled = false;
		}
	}
	internal struct Long8
	{
		internal long f0;

		internal long f1;

		internal long f2;

		internal long f3;

		internal long f4;

		internal long f5;

		internal long f6;

		internal long f7;
	}
	internal struct Long64
	{
		internal Long8 f0;

		internal Long8 f1;

		internal Long8 f2;

		internal Long8 f3;

		internal Long8 f4;

		internal Long8 f5;

		internal Long8 f6;

		internal Long8 f7;
	}
	internal struct Long512
	{
		internal Long64 f0;

		internal Long64 f1;

		internal Long64 f2;

		internal Long64 f3;

		internal Long64 f4;

		internal Long64 f5;

		internal Long64 f6;

		internal Long64 f7;
	}
	internal struct Long1024 : IIndexable<long>
	{
		internal Long512 f0;

		internal Long512 f1;

		public int Length
		{
			get
			{
				return 1024;
			}
			set
			{
			}
		}

		public unsafe ref long ElementAt(int index)
		{
			fixed (Long512* ptr = &f0)
			{
				return ref UnsafeUtility.AsRef<long>((byte*)ptr + (nint)index * (nint)8);
			}
		}
	}
	internal class ConcurrentMask
	{
		internal const int ErrorFailedToFree = -1;

		internal const int ErrorFailedToAllocate = -2;

		internal const int ErrorAllocationCrossesWordBoundary = -3;

		internal const int EmptyBeforeAllocation = 0;

		internal const int EmptyAfterFree = 0;

		internal static long AtomicOr(ref long destination, long source)
		{
			long num = Interlocked.Read(ref destination);
			long num2;
			long num3;
			do
			{
				num2 = num | source;
				num3 = num;
				num = Interlocked.CompareExchange(ref destination, num2, num3);
			}
			while (num != num3);
			return num2;
		}

		internal static long AtomicAnd(ref long destination, long source)
		{
			long num = Interlocked.Read(ref destination);
			long num2;
			long num3;
			do
			{
				num2 = num & source;
				num3 = num;
				num = Interlocked.CompareExchange(ref destination, num2, num3);
			}
			while (num != num3);
			return num2;
		}

		internal static void longestConsecutiveOnes(long value, out int offset, out int count)
		{
			count = 0;
			long num = value;
			while (num != 0L)
			{
				value = num;
				num = value & (value >>> 1);
				count++;
			}
			offset = math.tzcnt(value);
		}

		internal static bool foundAtLeastThisManyConsecutiveOnes(long value, int minimum, out int offset, out int count)
		{
			if (minimum == 1)
			{
				offset = math.tzcnt(value);
				count = 1;
				return offset != 64;
			}
			longestConsecutiveOnes(value, out offset, out count);
			return count >= minimum;
		}

		internal static bool foundAtLeastThisManyConsecutiveZeroes(long value, int minimum, out int offset, out int count)
		{
			return foundAtLeastThisManyConsecutiveOnes(~value, minimum, out offset, out count);
		}

		internal static bool Succeeded(int error)
		{
			return error >= 0;
		}

		internal static long MakeMask(int offset, int bits)
		{
			return (long)(ulong.MaxValue >> 64 - bits << offset);
		}

		internal static int TryAllocate(ref long l, int offset, int bits)
		{
			long num = MakeMask(offset, bits);
			long num2 = Interlocked.Read(ref l);
			long num3;
			do
			{
				if ((num2 & num) != 0L)
				{
					return -2;
				}
				long value = num2 | num;
				num3 = num2;
				num2 = Interlocked.CompareExchange(ref l, value, num3);
			}
			while (num2 != num3);
			return math.countbits(num2);
		}

		internal static int TryFree(ref long l, int offset, int bits)
		{
			long num = MakeMask(offset, bits);
			long num2 = Interlocked.Read(ref l);
			long num3;
			long num4;
			do
			{
				if ((num2 & num) != num)
				{
					return -1;
				}
				num3 = num2 & ~num;
				num4 = num2;
				num2 = Interlocked.CompareExchange(ref l, num3, num4);
			}
			while (num2 != num4);
			return math.countbits(num3);
		}

		internal static int TryAllocate(ref long l, out int offset, int bits)
		{
			long num = Interlocked.Read(ref l);
			long num3;
			do
			{
				if (!foundAtLeastThisManyConsecutiveZeroes(num, bits, out offset, out var _))
				{
					return -2;
				}
				long num2 = MakeMask(offset, bits);
				long value = num | num2;
				num3 = num;
				num = Interlocked.CompareExchange(ref l, value, num3);
			}
			while (num != num3);
			return math.countbits(num);
		}

		internal static int TryAllocate<T>(ref T t, int offset, int bits) where T : IIndexable<long>
		{
			int index = offset >> 6;
			int num = offset & 0x3F;
			if (num + bits > 64)
			{
				return -3;
			}
			return TryAllocate(ref t.ElementAt(index), num, bits);
		}

		internal static int TryFree<T>(ref T t, int offset, int bits) where T : IIndexable<long>
		{
			int index = offset >> 6;
			int offset2 = offset & 0x3F;
			return TryFree(ref t.ElementAt(index), offset2, bits);
		}

		internal static int TryAllocate<T>(ref T t, out int offset, int begin, int end, int bits) where T : IIndexable<long>
		{
			int i;
			for (i = begin; i < end && t.ElementAt(i) == -1; i++)
			{
			}
			for (; i < end; i++)
			{
				int offset2;
				int num = TryAllocate(ref t.ElementAt(i), out offset2, bits);
				if (Succeeded(num))
				{
					offset = i * 64 + offset2;
					return num;
				}
			}
			offset = -1;
			return -2;
		}

		internal static int TryAllocate<T>(ref T t, out int offset, int begin, int bits) where T : IIndexable<long>
		{
			int num = TryAllocate(ref t, out offset, begin, t.Length, bits);
			if (Succeeded(num))
			{
				return num;
			}
			return TryAllocate(ref t, out offset, 0, begin, bits);
		}

		internal static int TryAllocate<T>(ref T t, out int offset, int bits) where T : IIndexable<long>
		{
			return TryAllocate(ref t, out offset, 0, t.Length, bits);
		}
	}
	[MovedFrom(true, "Unity.Networking.Transport", null, null)]
	[GenerateTestsForBurstCompatibility]
	public struct DataStreamReader
	{
		private struct Context
		{
			public int m_ReadByteIndex;

			public int m_BitIndex;

			public ulong m_BitBuffer;

			public int m_FailedReads;
		}

		[NativeDisableUnsafePtrRestriction]
		internal unsafe byte* m_BufferPtr;

		private Context m_Context;

		private int m_Length;

		public static bool IsLittleEndian => DataStreamWriter.IsLittleEndian;

		public readonly bool HasFailedReads => m_Context.m_FailedReads > 0;

		public readonly int Length => m_Length;

		public unsafe readonly bool IsCreated => m_BufferPtr != null;

		public DataStreamReader(NativeArray<byte> array)
		{
			Initialize(out this, array);
		}

		private unsafe static void Initialize(out DataStreamReader self, NativeArray<byte> array)
		{
			self.m_BufferPtr = (byte*)array.GetUnsafeReadOnlyPtr();
			self.m_Length = array.Length;
			self.m_Context = default(Context);
		}

		private static short ByteSwap(short val)
		{
			return (short)(((val & 0xFF) << 8) | ((val >> 8) & 0xFF));
		}

		private static int ByteSwap(int val)
		{
			return ((val & 0xFF) << 24) | ((val & 0xFF00) << 8) | ((val >> 8) & 0xFF00) | ((val >> 24) & 0xFF);
		}

		private unsafe void ReadBytesInternal(byte* data, int length)
		{
			if (GetBytesRead() + length > m_Length)
			{
				m_Context.m_FailedReads++;
				UnsafeUtility.MemClear(data, length);
			}
			else
			{
				Flush();
				UnsafeUtility.MemCpy(data, m_BufferPtr + m_Context.m_ReadByteIndex, length);
				m_Context.m_ReadByteIndex += length;
			}
		}

		public unsafe void ReadBytes(NativeArray<byte> array)
		{
			ReadBytesInternal((byte*)array.GetUnsafePtr(), array.Length);
		}

		public unsafe void ReadBytes(Span<byte> span)
		{
			fixed (byte* data = span)
			{
				ReadBytesInternal(data, span.Length);
			}
		}

		public int GetBytesRead()
		{
			return m_Context.m_ReadByteIndex - (m_Context.m_BitIndex >> 3);
		}

		public int GetBitsRead()
		{
			return (m_Context.m_ReadByteIndex << 3) - m_Context.m_BitIndex;
		}

		public void SeekSet(int pos)
		{
			if (pos > m_Length)
			{
				m_Context.m_FailedReads++;
				return;
			}
			m_Context.m_ReadByteIndex = pos;
			m_Context.m_BitIndex = 0;
			m_Context.m_BitBuffer = 0uL;
		}

		public unsafe byte ReadByte()
		{
			byte result = default(byte);
			ReadBytesInternal(&result, 1);
			return result;
		}

		public unsafe short ReadShort()
		{
			short result = default(short);
			ReadBytesInternal((byte*)(&result), 2);
			return result;
		}

		public unsafe ushort ReadUShort()
		{
			ushort result = default(ushort);
			ReadBytesInternal((byte*)(&result), 2);
			return result;
		}

		public unsafe int ReadInt()
		{
			int result = default(int);
			ReadBytesInternal((byte*)(&result), 4);
			return result;
		}

		public unsafe uint ReadUInt()
		{
			uint result = default(uint);
			ReadBytesInternal((byte*)(&result), 4);
			return result;
		}

		public unsafe long ReadLong()
		{
			long result = default(long);
			ReadBytesInternal((byte*)(&result), 8);
			return result;
		}

		public unsafe ulong ReadULong()
		{
			ulong result = default(ulong);
			ReadBytesInternal((byte*)(&result), 8);
			return result;
		}

		public void Flush()
		{
			m_Context.m_ReadByteIndex -= m_Context.m_BitIndex >> 3;
			m_Context.m_BitIndex = 0;
			m_Context.m_BitBuffer = 0uL;
		}

		public unsafe short ReadShortNetworkByteOrder()
		{
			short num = default(short);
			ReadBytesInternal((byte*)(&num), 2);
			if (!IsLittleEndian)
			{
				return num;
			}
			return ByteSwap(num);
		}

		public ushort ReadUShortNetworkByteOrder()
		{
			return (ushort)ReadShortNetworkByteOrder();
		}

		public unsafe int ReadIntNetworkByteOrder()
		{
			int num = default(int);
			ReadBytesInternal((byte*)(&num), 4);
			if (!IsLittleEndian)
			{
				return num;
			}
			return ByteSwap(num);
		}

		public uint ReadUIntNetworkByteOrder()
		{
			return (uint)ReadIntNetworkByteOrder();
		}

		public float ReadFloat()
		{
			UIntFloat uIntFloat = new UIntFloat
			{
				intValue = (uint)ReadInt()
			};
			return uIntFloat.floatValue;
		}

		public double ReadDouble()
		{
			UIntFloat uIntFloat = new UIntFloat
			{
				longValue = (ulong)ReadLong()
			};
			return uIntFloat.doubleValue;
		}

		public uint ReadPackedUInt(in StreamCompressionModel model)
		{
			return ReadPackedUIntInternal(6, in model);
		}

		private unsafe uint ReadPackedUIntInternal(int maxSymbolLength, in StreamCompressionModel model)
		{
			FillBitBuffer();
			uint num = (uint)((1 << maxSymbolLength) - 1);
			uint num2 = (uint)(int)m_Context.m_BitBuffer & num;
			ushort num3 = model.decodeTable[(int)num2];
			int num4 = num3 >> 8;
			int num5 = num3 & 0xFF;
			if (m_Context.m_BitIndex < num5)
			{
				m_Context.m_FailedReads++;
				return 0u;
			}
			m_Context.m_BitBuffer >>= num5;
			m_Context.m_BitIndex -= num5;
			uint num6 = model.bucketOffsets[num4];
			byte numbits = model.bucketSizes[num4];
			return ReadRawBitsInternal(numbits) + num6;
		}

		private unsafe void FillBitBuffer()
		{
			while (m_Context.m_BitIndex <= 56 && m_Context.m_ReadByteIndex < m_Length)
			{
				m_Context.m_BitBuffer |= (ulong)m_BufferPtr[m_Context.m_ReadByteIndex++] << m_Context.m_BitIndex;
				m_Context.m_BitIndex += 8;
			}
		}

		private uint ReadRawBitsInternal(int numbits)
		{
			if (m_Context.m_BitIndex < numbits)
			{
				m_Context.m_FailedReads++;
				return 0u;
			}
			int result = (int)((long)m_Context.m_BitBuffer & ((1L << numbits) - 1));
			m_Context.m_BitBuffer >>= numbits;
			m_Context.m_BitIndex -= numbits;
			return (uint)result;
		}

		public uint ReadRawBits(int numbits)
		{
			FillBitBuffer();
			return ReadRawBitsInternal(numbits);
		}

		public unsafe ulong ReadPackedULong(in StreamCompressionModel model)
		{
			ulong result = default(ulong);
			*(uint*)(&result) = ReadPackedUInt(in model);
			((int*)(&result))[1] = (int)ReadPackedUInt(in model);
			return result;
		}

		public int ReadPackedInt(in StreamCompressionModel model)
		{
			uint num = ReadPackedUInt(in model);
			return (int)((num >> 1) ^ (0 - (num & 1)));
		}

		public long ReadPackedLong(in StreamCompressionModel model)
		{
			ulong num = ReadPackedULong(in model);
			return (long)((num >> 1) ^ (0L - (num & 1)));
		}

		public float ReadPackedFloat(in StreamCompressionModel model)
		{
			return ReadPackedFloatDelta(0f, in model);
		}

		public double ReadPackedDouble(in StreamCompressionModel model)
		{
			return ReadPackedDoubleDelta(0.0, in model);
		}

		public int ReadPackedIntDelta(int baseline, in StreamCompressionModel model)
		{
			int num = ReadPackedInt(in model);
			return baseline - num;
		}

		public uint ReadPackedUIntDelta(uint baseline, in StreamCompressionModel model)
		{
			uint num = (uint)ReadPackedInt(in model);
			return baseline - num;
		}

		public long ReadPackedLongDelta(long baseline, in StreamCompressionModel model)
		{
			long num = ReadPackedLong(in model);
			return baseline - num;
		}

		public ulong ReadPackedULongDelta(ulong baseline, in StreamCompressionModel model)
		{
			ulong num = (ulong)ReadPackedLong(in model);
			return baseline - num;
		}

		public float ReadPackedFloatDelta(float baseline, in StreamCompressionModel model)
		{
			FillBitBuffer();
			if (ReadRawBitsInternal(1) == 0)
			{
				return baseline;
			}
			int numbits = 32;
			return new UIntFloat
			{
				intValue = ReadRawBitsInternal(numbits)
			}.floatValue;
		}

		public unsafe double ReadPackedDoubleDelta(double baseline, in StreamCompressionModel model)
		{
			FillBitBuffer();
			if (ReadRawBitsInternal(1) == 0)
			{
				return baseline;
			}
			int numbits = 32;
			UIntFloat uIntFloat = default(UIntFloat);
			uint* ptr = (uint*)(&uIntFloat.longValue);
			*ptr = ReadRawBitsInternal(numbits);
			FillBitBuffer();
			ptr[1] |= ReadRawBitsInternal(numbits);
			return uIntFloat.doubleValue;
		}

		public unsafe FixedString32Bytes ReadFixedString32()
		{
			FixedString32Bytes result = default(FixedString32Bytes);
			byte* data = (byte*)(&result) + 2;
			*(ushort*)(&result) = ReadFixedStringInternal(data, result.Capacity);
			return result;
		}

		public unsafe FixedString64Bytes ReadFixedString64()
		{
			FixedString64Bytes result = default(FixedString64Bytes);
			byte* data = (byte*)(&result) + 2;
			*(ushort*)(&result) = ReadFixedStringInternal(data, result.Capacity);
			return result;
		}

		public unsafe FixedString128Bytes ReadFixedString128()
		{
			FixedString128Bytes result = default(FixedString128Bytes);
			byte* data = (byte*)(&result) + 2;
			*(ushort*)(&result) = ReadFixedStringInternal(data, result.Capacity);
			return result;
		}

		public unsafe FixedString512Bytes ReadFixedString512()
		{
			FixedString512Bytes result = default(FixedString512Bytes);
			byte* data = (byte*)(&result) + 2;
			*(ushort*)(&result) = ReadFixedStringInternal(data, result.Capacity);
			return result;
		}

		public unsafe FixedString4096Bytes ReadFixedString4096()
		{
			FixedString4096Bytes result = default(FixedString4096Bytes);
			byte* data = (byte*)(&result) + 2;
			*(ushort*)(&result) = ReadFixedStringInternal(data, result.Capacity);
			return result;
		}

		public unsafe ushort ReadFixedString(NativeArray<byte> array)
		{
			return ReadFixedStringInternal((byte*)array.GetUnsafePtr(), array.Length);
		}

		private unsafe ushort ReadFixedStringInternal(byte* data, int maxLength)
		{
			ushort num = ReadUShort();
			if (num > maxLength)
			{
				return 0;
			}
			ReadBytesInternal(data, num);
			return num;
		}

		public unsafe FixedString32Bytes ReadPackedFixedString32Delta(FixedString32Bytes baseline, in StreamCompressionModel model)
		{
			FixedString32Bytes result = default(FixedString32Bytes);
			byte* data = (byte*)(&result) + 2;
			*(ushort*)(&result) = ReadPackedFixedStringDeltaInternal(data, result.Capacity, (byte*)(&baseline) + 2, *(ushort*)(&baseline), in model);
			return result;
		}

		public unsafe FixedString64Bytes ReadPackedFixedString64Delta(FixedString64Bytes baseline, in StreamCompressionModel model)
		{
			FixedString64Bytes result = default(FixedString64Bytes);
			byte* data = (byte*)(&result) + 2;
			*(ushort*)(&result) = ReadPackedFixedStringDeltaInternal(data, result.Capacity, (byte*)(&baseline) + 2, *(ushort*)(&baseline), in model);
			return result;
		}

		public unsafe FixedString128Bytes ReadPackedFixedString128Delta(FixedString128Bytes baseline, in StreamCompressionModel model)
		{
			FixedString128Bytes result = default(FixedString128Bytes);
			byte* data = (byte*)(&result) + 2;
			*(ushort*)(&result) = ReadPackedFixedStringDeltaInternal(data, result.Capacity, (byte*)(&baseline) + 2, *(ushort*)(&baseline), in model);
			return result;
		}

		public unsafe FixedString512Bytes ReadPackedFixedString512Delta(FixedString512Bytes baseline, in StreamCompressionModel model)
		{
			FixedString512Bytes result = default(FixedString512Bytes);
			byte* data = (byte*)(&result) + 2;
			*(ushort*)(&result) = ReadPackedFixedStringDeltaInternal(data, result.Capacity, (byte*)(&baseline) + 2, *(ushort*)(&baseline), in model);
			return result;
		}

		public unsafe FixedString4096Bytes ReadPackedFixedString4096Delta(FixedString4096Bytes baseline, in StreamCompressionModel model)
		{
			FixedString4096Bytes result = default(FixedString4096Bytes);
			byte* data = (byte*)(&result) + 2;
			*(ushort*)(&result) = ReadPackedFixedStringDeltaInternal(data, result.Capacity, (byte*)(&baseline) + 2, *(ushort*)(&baseline), in model);
			return result;
		}

		public unsafe ushort ReadPackedFixedStringDelta(NativeArray<byte> data, NativeArray<byte> baseData, in StreamCompressionModel model)
		{
			return ReadPackedFixedStringDeltaInternal((byte*)data.GetUnsafePtr(), data.Length, (byte*)baseData.GetUnsafePtr(), (ushort)baseData.Length, in model);
		}

		private unsafe ushort ReadPackedFixedStringDeltaInternal(byte* data, int maxLength, byte* baseData, ushort baseLength, in StreamCompressionModel model)
		{
			uint num = ReadPackedUIntDelta(baseLength, in model);
			if (num > (uint)maxLength)
			{
				return 0;
			}
			if (num <= baseLength)
			{
				for (int i = 0; i < num; i++)
				{
					data[i] = (byte)ReadPackedUIntDelta(baseData[i], in model);
				}
			}
			else
			{
				for (int j = 0; j < baseLength; j++)
				{
					data[j] = (byte)ReadPackedUIntDelta(baseData[j], in model);
				}
				for (int k = baseLength; k < num; k++)
				{
					data[k] = (byte)ReadPackedUInt(in model);
				}
			}
			return (ushort)num;
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		internal readonly void CheckRead()
		{
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckBits(int numBits)
		{
			if (numBits < 0 || numBits > 32)
			{
				throw new ArgumentOutOfRangeException($"Invalid number of bits specified: {numBits}! Valid range is (0, 32) inclusive.");
			}
		}
	}
	[MovedFrom(true, "Unity.Networking.Transport", "Unity.Networking.Transport", null)]
	[GenerateTestsForBurstCompatibility]
	public struct DataStreamWriter
	{
		private struct StreamData
		{
			public unsafe byte* buffer;

			public int length;

			public int capacity;

			public ulong bitBuffer;

			public int bitIndex;

			public int failedWrites;
		}

		[NativeDisableUnsafePtrRestriction]
		private StreamData m_Data;

		public IntPtr m_SendHandleData;

		public unsafe static bool IsLittleEndian
		{
			get
			{
				uint num = 1u;
				byte* ptr = (byte*)(&num);
				return *ptr == 1;
			}
		}

		public unsafe readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data.buffer != null;
			}
		}

		public readonly bool HasFailedWrites
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data.failedWrites > 0;
			}
		}

		public readonly int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data.capacity;
			}
		}

		public int Length
		{
			get
			{
				SyncBitData();
				return m_Data.length + (m_Data.bitIndex + 7 >> 3);
			}
		}

		public int LengthInBits
		{
			get
			{
				SyncBitData();
				return m_Data.length * 8 + m_Data.bitIndex;
			}
		}

		public DataStreamWriter(int length, AllocatorManager.AllocatorHandle allocator)
		{
			Initialize(out this, CollectionHelper.CreateNativeArray<byte>(length, allocator));
		}

		public DataStreamWriter(NativeArray<byte> data)
		{
			Initialize(out this, data);
		}

		public unsafe DataStreamWriter(byte* data, int length)
		{
			NativeArray<byte> data2 = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(data, length, Allocator.Invalid);
			Initialize(out this, data2);
		}

		public unsafe NativeArray<byte> AsNativeArray()
		{
			return NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(m_Data.buffer, Length, Allocator.Invalid);
		}

		private unsafe static void Initialize(out DataStreamWriter self, NativeArray<byte> data)
		{
			self.m_SendHandleData = IntPtr.Zero;
			self.m_Data.capacity = data.Length;
			self.m_Data.length = 0;
			self.m_Data.buffer = (byte*)data.GetUnsafePtr();
			self.m_Data.bitBuffer = 0uL;
			self.m_Data.bitIndex = 0;
			self.m_Data.failedWrites = 0;
		}

		private static short ByteSwap(short val)
		{
			return (short)(((val & 0xFF) << 8) | ((val >> 8) & 0xFF));
		}

		private static int ByteSwap(int val)
		{
			return ((val & 0xFF) << 24) | ((val & 0xFF00) << 8) | ((val >> 8) & 0xFF00) | ((val >> 24) & 0xFF);
		}

		private unsafe void SyncBitData()
		{
			int num = m_Data.bitIndex;
			if (num > 0)
			{
				ulong num2 = m_Data.bitBuffer;
				int num3 = 0;
				while (num > 0)
				{
					m_Data.buffer[m_Data.length + num3] = (byte)num2;
					num -= 8;
					num2 >>= 8;
					num3++;
				}
			}
		}

		public unsafe void Flush()
		{
			while (m_Data.bitIndex > 0)
			{
				m_Data.buffer[m_Data.length++] = (byte)m_Data.bitBuffer;
				m_Data.bitIndex -= 8;
				m_Data.bitBuffer >>= 8;
			}
			m_Data.bitIndex = 0;
		}

		private unsafe bool WriteBytesInternal(byte* data, int bytes)
		{
			if (m_Data.length + (m_Data.bitIndex + 7 >> 3) + bytes > m_Data.capacity)
			{
				m_Data.failedWrites++;
				return false;
			}
			Flush();
			UnsafeUtility.MemCpy(m_Data.buffer + m_Data.length, data, bytes);
			m_Data.length += bytes;
			return true;
		}

		public unsafe bool WriteByte(byte value)
		{
			return WriteBytesInternal(&value, 1);
		}

		public unsafe bool WriteBytes(NativeArray<byte> value)
		{
			return WriteBytesInternal((byte*)value.GetUnsafeReadOnlyPtr(), value.Length);
		}

		public unsafe bool WriteBytes(Span<byte> value)
		{
			fixed (byte* data = value)
			{
				return WriteBytesInternal(data, value.Length);
			}
		}

		public unsafe bool WriteShort(short value)
		{
			return WriteBytesInternal((byte*)(&value), 2);
		}

		public unsafe bool WriteUShort(ushort value)
		{
			return WriteBytesInternal((byte*)(&value), 2);
		}

		public unsafe bool WriteInt(int value)
		{
			return WriteBytesInternal((byte*)(&value), 4);
		}

		public unsafe bool WriteUInt(uint value)
		{
			return WriteBytesInternal((byte*)(&value), 4);
		}

		public unsafe bool WriteLong(long value)
		{
			return WriteBytesInternal((byte*)(&value), 8);
		}

		public unsafe bool WriteULong(ulong value)
		{
			return WriteBytesInternal((byte*)(&value), 8);
		}

		public unsafe bool WriteShortNetworkByteOrder(short value)
		{
			short num = (IsLittleEndian ? ByteSwap(value) : value);
			return WriteBytesInternal((byte*)(&num), 2);
		}

		public bool WriteUShortNetworkByteOrder(ushort value)
		{
			return WriteShortNetworkByteOrder((short)value);
		}

		public unsafe bool WriteIntNetworkByteOrder(int value)
		{
			int num = (IsLittleEndian ? ByteSwap(value) : value);
			return WriteBytesInternal((byte*)(&num), 4);
		}

		public bool WriteUIntNetworkByteOrder(uint value)
		{
			return WriteIntNetworkByteOrder((int)value);
		}

		public bool WriteFloat(float value)
		{
			UIntFloat uIntFloat = new UIntFloat
			{
				floatValue = value
			};
			return WriteInt((int)uIntFloat.intValue);
		}

		public bool WriteDouble(double value)
		{
			UIntFloat uIntFloat = new UIntFloat
			{
				doubleValue = value
			};
			return WriteLong((long)uIntFloat.longValue);
		}

		private unsafe void FlushBits()
		{
			while (m_Data.bitIndex >= 8)
			{
				m_Data.buffer[m_Data.length++] = (byte)m_Data.bitBuffer;
				m_Data.bitIndex -= 8;
				m_Data.bitBuffer >>= 8;
			}
		}

		private void WriteRawBitsInternal(uint value, int numbits)
		{
			m_Data.bitBuffer |= (ulong)value << m_Data.bitIndex;
			m_Data.bitIndex += numbits;
		}

		public bool WriteRawBits(uint value, int numbits)
		{
			if (m_Data.length + (m_Data.bitIndex + numbits + 7 >> 3) > m_Data.capacity)
			{
				m_Data.failedWrites++;
				return false;
			}
			WriteRawBitsInternal(value, numbits);
			FlushBits();
			return true;
		}

		public unsafe bool WritePackedUInt(uint value, in StreamCompressionModel model)
		{
			int num = model.CalculateBucket(value);
			uint num2 = model.bucketOffsets[num];
			int num3 = model.bucketSizes[num];
			ushort num4 = model.encodeTable[num];
			if (m_Data.length + (m_Data.bitIndex + (num4 & 0xFF) + num3 + 7 >> 3) > m_Data.capacity)
			{
				m_Data.failedWrites++;
				return false;
			}
			WriteRawBitsInternal((uint)(num4 >> 8), num4 & 0xFF);
			WriteRawBitsInternal(value - num2, num3);
			FlushBits();
			return true;
		}

		public unsafe bool WritePackedULong(ulong value, in StreamCompressionModel model)
		{
			uint* ptr = (uint*)(&value);
			return WritePackedUInt(*ptr, in model) & WritePackedUInt(ptr[1], in model);
		}

		public bool WritePackedInt(int value, in StreamCompressionModel model)
		{
			uint value2 = (uint)((value >> 31) ^ (value << 1));
			return WritePackedUInt(value2, in model);
		}

		public bool WritePackedLong(long value, in StreamCompressionModel model)
		{
			ulong value2 = (ulong)((value >> 63) ^ (value << 1));
			return WritePackedULong(value2, in model);
		}

		public bool WritePackedFloat(float value, in StreamCompressionModel model)
		{
			return WritePackedFloatDelta(value, 0f, in model);
		}

		public bool WritePackedDouble(double value, in StreamCompressionModel model)
		{
			return WritePackedDoubleDelta(value, 0.0, in model);
		}

		public bool WritePackedUIntDelta(uint value, uint baseline, in StreamCompressionModel model)
		{
			int value2 = (int)(baseline - value);
			return WritePackedInt(value2, in model);
		}

		public bool WritePackedIntDelta(int value, int baseline, in StreamCompressionModel model)
		{
			int value2 = baseline - value;
			return WritePackedInt(value2, in model);
		}

		public bool WritePackedLongDelta(long value, long baseline, in StreamCompressionModel model)
		{
			long value2 = baseline - value;
			return WritePackedLong(value2, in model);
		}

		public bool WritePackedULongDelta(ulong value, ulong baseline, in StreamCompressionModel model)
		{
			long value2 = (long)(baseline - value);
			return WritePackedLong(value2, in model);
		}

		public bool WritePackedFloatDelta(float value, float baseline, in StreamCompressionModel model)
		{
			int num = 0;
			if (value != baseline)
			{
				num = 32;
			}
			if (m_Data.length + (m_Data.bitIndex + 1 + num + 7 >> 3) > m_Data.capacity)
			{
				m_Data.failedWrites++;
				return false;
			}
			if (num == 0)
			{
				WriteRawBitsInternal(0u, 1);
			}
			else
			{
				WriteRawBitsInternal(1u, 1);
				UIntFloat uIntFloat = new UIntFloat
				{
					floatValue = value
				};
				WriteRawBitsInternal(uIntFloat.intValue, num);
			}
			FlushBits();
			return true;
		}

		public unsafe bool WritePackedDoubleDelta(double value, double baseline, in StreamCompressionModel model)
		{
			int num = 0;
			if (value != baseline)
			{
				num = 64;
			}
			if (m_Data.length + (m_Data.bitIndex + 1 + num + 7 >> 3) > m_Data.capacity)
			{
				m_Data.failedWrites++;
				return false;
			}
			if (num == 0)
			{
				WriteRawBitsInternal(0u, 1);
			}
			else
			{
				WriteRawBitsInternal(1u, 1);
				UIntFloat uIntFloat = new UIntFloat
				{
					doubleValue = value
				};
				uint* ptr = (uint*)(&uIntFloat.longValue);
				WriteRawBitsInternal(*ptr, 32);
				FlushBits();
				WriteRawBitsInternal(ptr[1], 32);
			}
			FlushBits();
			return true;
		}

		public unsafe bool WriteFixedString32(FixedString32Bytes str)
		{
			int bytes = *(ushort*)(&str) + 2;
			byte* data = (byte*)(&str);
			return WriteBytesInternal(data, bytes);
		}

		public unsafe bool WriteFixedString64(FixedString64Bytes str)
		{
			int bytes = *(ushort*)(&str) + 2;
			byte* data = (byte*)(&str);
			return WriteBytesInternal(data, bytes);
		}

		public unsafe bool WriteFixedString128(FixedString128Bytes str)
		{
			int bytes = *(ushort*)(&str) + 2;
			byte* data = (byte*)(&str);
			return WriteBytesInternal(data, bytes);
		}

		public unsafe bool WriteFixedString512(FixedString512Bytes str)
		{
			int bytes = *(ushort*)(&str) + 2;
			byte* data = (byte*)(&str);
			return WriteBytesInternal(data, bytes);
		}

		public unsafe bool WriteFixedString4096(FixedString4096Bytes str)
		{
			int bytes = *(ushort*)(&str) + 2;
			byte* data = (byte*)(&str);
			return WriteBytesInternal(data, bytes);
		}

		public unsafe bool WritePackedFixedString32Delta(FixedString32Bytes str, FixedString32Bytes baseline, in StreamCompressionModel model)
		{
			ushort length = *(ushort*)(&str);
			byte* data = (byte*)(&str) + 2;
			return WritePackedFixedStringDelta(data, length, (byte*)(&baseline) + 2, *(ushort*)(&baseline), in model);
		}

		public unsafe bool WritePackedFixedString64Delta(FixedString64Bytes str, FixedString64Bytes baseline, in StreamCompressionModel model)
		{
			ushort length = *(ushort*)(&str);
			byte* data = (byte*)(&str) + 2;
			return WritePackedFixedStringDelta(data, length, (byte*)(&baseline) + 2, *(ushort*)(&baseline), in model);
		}

		public unsafe bool WritePackedFixedString128Delta(FixedString128Bytes str, FixedString128Bytes baseline, in StreamCompressionModel model)
		{
			ushort length = *(ushort*)(&str);
			byte* data = (byte*)(&str) + 2;
			return WritePackedFixedStringDelta(data, length, (byte*)(&baseline) + 2, *(ushort*)(&baseline), in model);
		}

		public unsafe bool WritePackedFixedString512Delta(FixedString512Bytes str, FixedString512Bytes baseline, in StreamCompressionModel model)
		{
			ushort length = *(ushort*)(&str);
			byte* data = (byte*)(&str) + 2;
			return WritePackedFixedStringDelta(data, length, (byte*)(&baseline) + 2, *(ushort*)(&baseline), in model);
		}

		public unsafe bool WritePackedFixedString4096Delta(FixedString4096Bytes str, FixedString4096Bytes baseline, in StreamCompressionModel model)
		{
			ushort length = *(ushort*)(&str);
			byte* data = (byte*)(&str) + 2;
			return WritePackedFixedStringDelta(data, length, (byte*)(&baseline) + 2, *(ushort*)(&baseline), in model);
		}

		private unsafe bool WritePackedFixedStringDelta(byte* data, uint length, byte* baseData, uint baseLength, in StreamCompressionModel model)
		{
			StreamData data2 = m_Data;
			if (!WritePackedUIntDelta(length, baseLength, in model))
			{
				return false;
			}
			bool flag = false;
			if (length <= baseLength)
			{
				for (uint num = 0u; num < length; num++)
				{
					flag |= !WritePackedUIntDelta(data[num], baseData[num], in model);
				}
			}
			else
			{
				for (uint num2 = 0u; num2 < baseLength; num2++)
				{
					flag |= !WritePackedUIntDelta(data[num2], baseData[num2], in model);
				}
				for (uint num3 = baseLength; num3 < length; num3++)
				{
					flag |= !WritePackedUInt(data[num3], in model);
				}
			}
			if (flag)
			{
				m_Data = data2;
				m_Data.failedWrites++;
			}
			return !flag;
		}

		public void Clear()
		{
			m_Data.length = 0;
			m_Data.bitIndex = 0;
			m_Data.bitBuffer = 0uL;
			m_Data.failedWrites = 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private readonly void CheckRead()
		{
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private void CheckWrite()
		{
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckAllocator(AllocatorManager.AllocatorHandle allocator)
		{
			if (allocator.ToAllocator != Allocator.Temp)
			{
				throw new InvalidOperationException("DataStreamWriters can only be created with temp memory");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckBits(uint value, int numBits)
		{
			if (numBits < 0 || numBits > 32)
			{
				throw new ArgumentOutOfRangeException($"Invalid number of bits specified: {numBits}! Valid range is (0, 32) inclusive.");
			}
			ulong num = (ulong)(1L << numBits);
			if (value >= num)
			{
				throw new ArgumentOutOfRangeException($"Value {value} does not fit in the specified number of bits: {numBits}! Range (inclusive) is (0, {num - 1})!");
			}
		}
	}
	internal struct Pair<Key, Value>
	{
		public Key key;

		public Value value;

		public Pair(Key k, Value v)
		{
			key = k;
			value = v;
		}

		public override string ToString()
		{
			return $"{key} = {value}";
		}
	}
	internal struct ListPair<Key, Value> where Value : IList
	{
		public Key key;

		public Value value;

		public ListPair(Key k, Value v)
		{
			key = k;
			value = v;
		}

		public override string ToString()
		{
			string text = $"{key} = [";
			for (int i = 0; i < value.Count; i++)
			{
				text += value[i];
				if (i < value.Count - 1)
				{
					text += ", ";
				}
			}
			return text + "]";
		}
	}
	public struct DoubleRewindableAllocators : IDisposable
	{
		private unsafe RewindableAllocator* Pointer;

		private AllocatorHelper<RewindableAllocator> UpdateAllocatorHelper0;

		private AllocatorHelper<RewindableAllocator> UpdateAllocatorHelper1;

		public unsafe ref RewindableAllocator Allocator => ref UnsafeUtility.AsRef<RewindableAllocator>(Pointer);

		public unsafe bool IsCreated => Pointer != null;

		internal bool EnableBlockFree
		{
			get
			{
				Assert.IsTrue(UpdateAllocatorHelper0.Allocator.EnableBlockFree == UpdateAllocatorHelper1.Allocator.EnableBlockFree);
				return UpdateAllocatorHelper0.Allocator.EnableBlockFree;
			}
			set
			{
				UpdateAllocatorHelper0.Allocator.EnableBlockFree = value;
				UpdateAllocatorHelper1.Allocator.EnableBlockFree = value;
			}
		}

		public unsafe void Update()
		{
			RewindableAllocator* ptr = (RewindableAllocator*)UnsafeUtility.AddressOf(ref UpdateAllocatorHelper0.Allocator);
			RewindableAllocator* ptr2 = (RewindableAllocator*)UnsafeUtility.AddressOf(ref UpdateAllocatorHelper1.Allocator);
			Pointer = ((Pointer == ptr) ? ptr2 : ptr);
			Allocator.Rewind();
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckIsCreated()
		{
			if (!IsCreated)
			{
				throw new InvalidOperationException("DoubleRewindableAllocators is not created.");
			}
		}

		public DoubleRewindableAllocators(AllocatorManager.AllocatorHandle backingAllocator, int initialSizeInBytes)
		{
			this = default(DoubleRewindableAllocators);
			Initialize(backingAllocator, initialSizeInBytes);
		}

		public unsafe void Initialize(AllocatorManager.AllocatorHandle backingAllocator, int initialSizeInBytes)
		{
			UpdateAllocatorHelper0 = new AllocatorHelper<RewindableAllocator>(backingAllocator);
			UpdateAllocatorHelper1 = new AllocatorHelper<RewindableAllocator>(backingAllocator);
			UpdateAllocatorHelper0.Allocator.Initialize(initialSizeInBytes);
			UpdateAllocatorHelper1.Allocator.Initialize(initialSizeInBytes);
			Pointer = null;
			Update();
		}

		public void Dispose()
		{
			if (IsCreated)
			{
				UpdateAllocatorHelper0.Allocator.Dispose();
				UpdateAllocatorHelper1.Allocator.Dispose();
				UpdateAllocatorHelper0.Dispose();
				UpdateAllocatorHelper1.Dispose();
			}
		}
	}
	[Serializable]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
	{
		typeof(int),
		typeof(FixedBytes32Align8)
	})]
	internal struct FixedList<T, U> : INativeList<T>, IIndexable<T> where T : unmanaged where U : unmanaged
	{
		[SerializeField]
		internal U data;

		internal unsafe ushort length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				fixed (U* ptr = &data)
				{
					void* ptr2 = ptr;
					return *(ushort*)ptr2;
				}
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				fixed (U* ptr = &data)
				{
					void* ptr2 = ptr;
					*(ushort*)ptr2 = value;
				}
			}
		}

		internal unsafe readonly byte* buffer
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				fixed (U* ptr = &data)
				{
					void* ptr2 = ptr;
					return (byte*)ptr2 + UnsafeUtility.SizeOf<ushort>();
				}
			}
		}

		[CreateProperty]
		public int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return length;
			}
			set
			{
				length = (ushort)value;
			}
		}

		[CreateProperty]
		private IEnumerable<T> Elements => ToArray();

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return Length == 0;
			}
		}

		internal readonly int LengthInBytes => Length * UnsafeUtility.SizeOf<T>();

		internal unsafe readonly byte* Buffer
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return buffer + FixedList.PaddingBytes<T>();
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return FixedList.Capacity<U, T>();
			}
			set
			{
			}
		}

		public unsafe T this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return UnsafeUtility.ReadArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index));
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				UnsafeUtility.WriteArrayElement(Buffer, CollectionHelper.AssumePositive(index), value);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe ref T ElementAt(int index)
		{
			return ref UnsafeUtility.ArrayElementAsRef<T>(Buffer, index);
		}

		public unsafe override int GetHashCode()
		{
			return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
		}

		public void Add(in T item)
		{
			AddNoResize(in item);
		}

		public unsafe void AddRange(void* ptr, int length)
		{
			AddRangeNoResize(ptr, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AddNoResize(in T item)
		{
			this[Length++] = item;
		}

		public unsafe void AddRangeNoResize(void* ptr, int length)
		{
			int num = Length;
			Length += length;
			UnsafeUtility.MemCpy(Buffer + (nint)num * (nint)sizeof(T), ptr, UnsafeUtility.SizeOf<T>() * length);
		}

		public unsafe void AddReplicate(in T value, int count)
		{
			int num = Length;
			Length += count;
			fixed (T* source = &value)
			{
				UnsafeUtility.MemCpyReplicate(Buffer + (nint)num * (nint)sizeof(T), source, UnsafeUtility.SizeOf<T>(), count);
			}
		}

		public void Clear()
		{
			Length = 0;
		}

		public unsafe void InsertRangeWithBeginEnd(int begin, int end)
		{
			int num = end - begin;
			if (num >= 1)
			{
				int num2 = length - begin;
				Length += num;
				if (num2 >= 1)
				{
					int num3 = num2 * UnsafeUtility.SizeOf<T>();
					byte* num4 = Buffer;
					byte* destination = num4 + end * UnsafeUtility.SizeOf<T>();
					byte* source = num4 + begin * UnsafeUtility.SizeOf<T>();
					UnsafeUtility.MemMove(destination, source, num3);
				}
			}
		}

		public void InsertRange(int index, int count)
		{
			InsertRangeWithBeginEnd(index, index + count);
		}

		public void Insert(int index, in T item)
		{
			InsertRangeWithBeginEnd(index, index + 1);
			this[index] = item;
		}

		public void RemoveAtSwapBack(int index)
		{
			RemoveRangeSwapBack(index, 1);
		}

		public unsafe void RemoveRangeSwapBack(int index, int count)
		{
			if (count > 0)
			{
				int num = math.max(Length - count, index + count);
				int num2 = UnsafeUtility.SizeOf<T>();
				void* destination = Buffer + index * num2;
				void* source = Buffer + num * num2;
				UnsafeUtility.MemCpy(destination, source, (Length - num) * num2);
				Length -= count;
			}
		}

		public void RemoveAt(int index)
		{
			RemoveRange(index, 1);
		}

		public unsafe void RemoveRange(int index, int count)
		{
			if (count > 0)
			{
				int num = math.min(index + count, Length);
				int num2 = UnsafeUtility.SizeOf<T>();
				void* destination = Buffer + index * num2;
				void* source = Buffer + num * num2;
				UnsafeUtility.MemCpy(destination, source, (Length - num) * num2);
				Length -= count;
			}
		}

		[ExcludeFromBurstCompatTesting("Returns managed array")]
		public unsafe T[] ToArray()
		{
			T[] array = new T[Length];
			byte* source = Buffer;
			fixed (T* destination = array)
			{
				UnsafeUtility.MemCpy(destination, source, LengthInBytes);
			}
			return array;
		}

		public unsafe NativeArray<T> ToNativeArray(AllocatorManager.AllocatorHandle allocator)
		{
			NativeArray<T> nativeArray = CollectionHelper.CreateNativeArray<T>(Length, allocator, NativeArrayOptions.UninitializedMemory);
			UnsafeUtility.MemCpy(nativeArray.GetUnsafePtr(), Buffer, LengthInBytes);
			return nativeArray;
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	[GenerateTestsForBurstCompatibility]
	internal struct FixedList
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		internal static int PaddingBytes<T>() where T : unmanaged
		{
			return math.max(0, math.min(6, (1 << math.tzcnt(UnsafeUtility.SizeOf<T>())) - 2));
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		internal static int StorageBytes<BUFFER, T>() where BUFFER : unmanaged where T : unmanaged
		{
			return UnsafeUtility.SizeOf<BUFFER>() - UnsafeUtility.SizeOf<ushort>() - PaddingBytes<T>();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		internal static int Capacity<BUFFER, T>() where BUFFER : unmanaged where T : unmanaged
		{
			return StorageBytes<BUFFER, T>() / UnsafeUtility.SizeOf<T>();
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		internal static void CheckResize<BUFFER, T>(int newLength) where BUFFER : unmanaged where T : unmanaged
		{
			int num = Capacity<BUFFER, T>();
			if (newLength < 0 || newLength > num)
			{
				throw new IndexOutOfRangeException($"NewLength {newLength} is out of range of '{num}' Capacity.");
			}
		}
	}
	[Serializable]
	[DebuggerTypeProxy(typeof(FixedList32BytesDebugView<>))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct FixedList32Bytes<T> : INativeList<T>, IIndexable<T>, IEnumerable<T>, IEnumerable, IEquatable<FixedList32Bytes<T>>, IComparable<FixedList32Bytes<T>>, IEquatable<FixedList64Bytes<T>>, IComparable<FixedList64Bytes<T>>, IEquatable<FixedList128Bytes<T>>, IComparable<FixedList128Bytes<T>>, IEquatable<FixedList512Bytes<T>>, IComparable<FixedList512Bytes<T>>, IEquatable<FixedList4096Bytes<T>>, IComparable<FixedList4096Bytes<T>> where T : unmanaged
	{
		public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
		{
			private FixedList32Bytes<T> m_List;

			private int m_Index;

			public T Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_List[m_Index];
				}
			}

			object IEnumerator.Current => Current;

			public Enumerator(ref FixedList32Bytes<T> list)
			{
				m_List = list;
				m_Index = -1;
			}

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				m_Index++;
				return m_Index < m_List.Length;
			}

			public void Reset()
			{
				m_Index = -1;
			}
		}

		[SerializeField]
		internal FixedBytes32Align8 data;

		internal unsafe ushort length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				fixed (FixedBytes32Align8* ptr = &data)
				{
					void* ptr2 = ptr;
					return *(ushort*)ptr2;
				}
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				fixed (FixedBytes32Align8* ptr = &data)
				{
					void* ptr2 = ptr;
					*(ushort*)ptr2 = value;
				}
			}
		}

		internal unsafe readonly byte* buffer
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				fixed (FixedBytes32Align8* ptr = &data)
				{
					void* ptr2 = ptr;
					return (byte*)ptr2 + UnsafeUtility.SizeOf<ushort>();
				}
			}
		}

		[CreateProperty]
		public int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return length;
			}
			set
			{
				length = (ushort)value;
			}
		}

		[CreateProperty]
		private IEnumerable<T> Elements => ToArray();

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return Length == 0;
			}
		}

		internal int LengthInBytes => Length * UnsafeUtility.SizeOf<T>();

		internal unsafe readonly byte* Buffer
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return buffer + FixedList.PaddingBytes<T>();
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return FixedList.Capacity<FixedBytes32Align8, T>();
			}
			set
			{
			}
		}

		public unsafe T this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return UnsafeUtility.ReadArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index));
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				UnsafeUtility.WriteArrayElement(Buffer, CollectionHelper.AssumePositive(index), value);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe ref T ElementAt(int index)
		{
			return ref UnsafeUtility.ArrayElementAsRef<T>(Buffer, index);
		}

		public unsafe override int GetHashCode()
		{
			return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
		}

		public void Add(in T item)
		{
			AddNoResize(in item);
		}

		public unsafe void AddRange(void* ptr, int length)
		{
			AddRangeNoResize(ptr, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AddNoResize(in T item)
		{
			this[Length++] = item;
		}

		public unsafe void AddRangeNoResize(void* ptr, int length)
		{
			int num = Length;
			Length += length;
			UnsafeUtility.MemCpy(Buffer + (nint)num * (nint)sizeof(T), ptr, UnsafeUtility.SizeOf<T>() * length);
		}

		public unsafe void AddReplicate(in T value, int count)
		{
			int num = Length;
			Length += count;
			fixed (T* source = &value)
			{
				UnsafeUtility.MemCpyReplicate(Buffer + (nint)num * (nint)sizeof(T), source, UnsafeUtility.SizeOf<T>(), count);
			}
		}

		public void Clear()
		{
			Length = 0;
		}

		public unsafe void InsertRangeWithBeginEnd(int begin, int end)
		{
			int num = end - begin;
			if (num >= 1)
			{
				int num2 = length - begin;
				Length += num;
				if (num2 >= 1)
				{
					int num3 = num2 * UnsafeUtility.SizeOf<T>();
					byte* num4 = Buffer;
					byte* destination = num4 + end * UnsafeUtility.SizeOf<T>();
					byte* source = num4 + begin * UnsafeUtility.SizeOf<T>();
					UnsafeUtility.MemMove(destination, source, num3);
				}
			}
		}

		public void InsertRange(int index, int count)
		{
			InsertRangeWithBeginEnd(index, index + count);
		}

		public void Insert(int index, in T item)
		{
			InsertRangeWithBeginEnd(index, index + 1);
			this[index] = item;
		}

		public void RemoveAtSwapBack(int index)
		{
			RemoveRangeSwapBack(index, 1);
		}

		public unsafe void RemoveRangeSwapBack(int index, int count)
		{
			if (count > 0)
			{
				int num = math.max(Length - count, index + count);
				int num2 = UnsafeUtility.SizeOf<T>();
				void* destination = Buffer + index * num2;
				void* source = Buffer + num * num2;
				UnsafeUtility.MemCpy(destination, source, (Length - num) * num2);
				Length -= count;
			}
		}

		public void RemoveAt(int index)
		{
			RemoveRange(index, 1);
		}

		public unsafe void RemoveRange(int index, int count)
		{
			if (count > 0)
			{
				int num = math.min(index + count, Length);
				int num2 = UnsafeUtility.SizeOf<T>();
				void* destination = Buffer + index * num2;
				void* source = Buffer + num * num2;
				UnsafeUtility.MemCpy(destination, source, (Length - num) * num2);
				Length -= count;
			}
		}

		[ExcludeFromBurstCompatTesting("Returns managed array")]
		public unsafe T[] ToArray()
		{
			T[] array = new T[Length];
			byte* source = Buffer;
			fixed (T* destination = array)
			{
				UnsafeUtility.MemCpy(destination, source, LengthInBytes);
			}
			return array;
		}

		public unsafe NativeArray<T> ToNativeArray(AllocatorManager.AllocatorHandle allocator)
		{
			NativeArray<T> nativeArray = CollectionHelper.CreateNativeArray<T>(Length, allocator, NativeArrayOptions.UninitializedMemory);
			UnsafeUtility.MemCpy(nativeArray.GetUnsafePtr(), Buffer, LengthInBytes);
			return nativeArray;
		}

		public unsafe static bool operator ==(in FixedList32Bytes<T> a, in FixedList32Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList32Bytes<T> a, in FixedList32Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList32Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList32Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public unsafe static bool operator ==(in FixedList32Bytes<T> a, in FixedList64Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList32Bytes<T> a, in FixedList64Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList64Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList64Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList32Bytes(in FixedList64Bytes<T> other)
		{
			this = default(FixedList32Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList64Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList32Bytes<T>(in FixedList64Bytes<T> other)
		{
			return new FixedList32Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList32Bytes<T> a, in FixedList128Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList32Bytes<T> a, in FixedList128Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList128Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList128Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList32Bytes(in FixedList128Bytes<T> other)
		{
			this = default(FixedList32Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList128Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList32Bytes<T>(in FixedList128Bytes<T> other)
		{
			return new FixedList32Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList32Bytes<T> a, in FixedList512Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList32Bytes<T> a, in FixedList512Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList512Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList512Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList32Bytes(in FixedList512Bytes<T> other)
		{
			this = default(FixedList32Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList512Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList32Bytes<T>(in FixedList512Bytes<T> other)
		{
			return new FixedList32Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList32Bytes<T> a, in FixedList4096Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList32Bytes<T> a, in FixedList4096Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList4096Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList4096Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList32Bytes(in FixedList4096Bytes<T> other)
		{
			this = default(FixedList32Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList4096Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList32Bytes<T>(in FixedList4096Bytes<T> other)
		{
			return new FixedList32Bytes<T>(in other);
		}

		[ExcludeFromBurstCompatTesting("Takes managed object")]
		public override bool Equals(object obj)
		{
			if (obj is FixedList32Bytes<T> other)
			{
				return Equals(other);
			}
			if (obj is FixedList64Bytes<T> other2)
			{
				return Equals(other2);
			}
			if (obj is FixedList128Bytes<T> other3)
			{
				return Equals(other3);
			}
			if (obj is FixedList512Bytes<T> other4)
			{
				return Equals(other4);
			}
			if (obj is FixedList4096Bytes<T> other5)
			{
				return Equals(other5);
			}
			return false;
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(ref this);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			throw new NotImplementedException();
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class FixedList32BytesExtensions
	{
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static int IndexOf<T, U>(this ref FixedList32Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			return NativeArrayExtensions.IndexOf<T, U>(list.Buffer, list.Length, value);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool Contains<T, U>(this ref FixedList32Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			return IndexOf(ref list, value) != -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool Remove<T, U>(this ref FixedList32Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			int num = IndexOf(ref list, value);
			if (num < 0)
			{
				return false;
			}
			list.RemoveAt(num);
			return true;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool RemoveSwapBack<T, U>(this ref FixedList32Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			int num = IndexOf(ref list, value);
			if (num == -1)
			{
				return false;
			}
			list.RemoveAtSwapBack(num);
			return true;
		}
	}
	internal sealed class FixedList32BytesDebugView<T> where T : unmanaged
	{
		private FixedList32Bytes<T> m_List;

		public T[] Items => m_List.ToArray();

		public FixedList32BytesDebugView(FixedList32Bytes<T> list)
		{
			m_List = list;
		}
	}
	[Serializable]
	[DebuggerTypeProxy(typeof(FixedList64BytesDebugView<>))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct FixedList64Bytes<T> : INativeList<T>, IIndexable<T>, IEnumerable<T>, IEnumerable, IEquatable<FixedList32Bytes<T>>, IComparable<FixedList32Bytes<T>>, IEquatable<FixedList64Bytes<T>>, IComparable<FixedList64Bytes<T>>, IEquatable<FixedList128Bytes<T>>, IComparable<FixedList128Bytes<T>>, IEquatable<FixedList512Bytes<T>>, IComparable<FixedList512Bytes<T>>, IEquatable<FixedList4096Bytes<T>>, IComparable<FixedList4096Bytes<T>> where T : unmanaged
	{
		public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
		{
			private FixedList64Bytes<T> m_List;

			private int m_Index;

			public T Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_List[m_Index];
				}
			}

			object IEnumerator.Current => Current;

			public Enumerator(ref FixedList64Bytes<T> list)
			{
				m_List = list;
				m_Index = -1;
			}

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				m_Index++;
				return m_Index < m_List.Length;
			}

			public void Reset()
			{
				m_Index = -1;
			}
		}

		[SerializeField]
		internal FixedBytes64Align8 data;

		internal unsafe ushort length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				fixed (FixedBytes64Align8* ptr = &data)
				{
					void* ptr2 = ptr;
					return *(ushort*)ptr2;
				}
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				fixed (FixedBytes64Align8* ptr = &data)
				{
					void* ptr2 = ptr;
					*(ushort*)ptr2 = value;
				}
			}
		}

		internal unsafe readonly byte* buffer
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				fixed (FixedBytes64Align8* ptr = &data)
				{
					void* ptr2 = ptr;
					return (byte*)ptr2 + UnsafeUtility.SizeOf<ushort>();
				}
			}
		}

		[CreateProperty]
		public int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return length;
			}
			set
			{
				length = (ushort)value;
			}
		}

		[CreateProperty]
		private IEnumerable<T> Elements => ToArray();

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return Length == 0;
			}
		}

		internal int LengthInBytes => Length * UnsafeUtility.SizeOf<T>();

		internal unsafe readonly byte* Buffer
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return buffer + FixedList.PaddingBytes<T>();
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return FixedList.Capacity<FixedBytes64Align8, T>();
			}
			set
			{
			}
		}

		public unsafe T this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return UnsafeUtility.ReadArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index));
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				UnsafeUtility.WriteArrayElement(Buffer, CollectionHelper.AssumePositive(index), value);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe ref T ElementAt(int index)
		{
			return ref UnsafeUtility.ArrayElementAsRef<T>(Buffer, index);
		}

		public unsafe override int GetHashCode()
		{
			return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
		}

		public void Add(in T item)
		{
			AddNoResize(in item);
		}

		public unsafe void AddRange(void* ptr, int length)
		{
			AddRangeNoResize(ptr, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AddNoResize(in T item)
		{
			this[Length++] = item;
		}

		public unsafe void AddRangeNoResize(void* ptr, int length)
		{
			int num = Length;
			Length += length;
			UnsafeUtility.MemCpy(Buffer + (nint)num * (nint)sizeof(T), ptr, UnsafeUtility.SizeOf<T>() * length);
		}

		public unsafe void AddReplicate(in T value, int count)
		{
			int num = Length;
			Length += count;
			fixed (T* source = &value)
			{
				UnsafeUtility.MemCpyReplicate(Buffer + (nint)num * (nint)sizeof(T), source, UnsafeUtility.SizeOf<T>(), count);
			}
		}

		public void Clear()
		{
			Length = 0;
		}

		public unsafe void InsertRangeWithBeginEnd(int begin, int end)
		{
			int num = end - begin;
			if (num >= 1)
			{
				int num2 = length - begin;
				Length += num;
				if (num2 >= 1)
				{
					int num3 = num2 * UnsafeUtility.SizeOf<T>();
					byte* num4 = Buffer;
					byte* destination = num4 + end * UnsafeUtility.SizeOf<T>();
					byte* source = num4 + begin * UnsafeUtility.SizeOf<T>();
					UnsafeUtility.MemMove(destination, source, num3);
				}
			}
		}

		public void InsertRange(int index, int count)
		{
			InsertRangeWithBeginEnd(index, index + count);
		}

		public void Insert(int index, in T item)
		{
			InsertRangeWithBeginEnd(index, index + 1);
			this[index] = item;
		}

		public void RemoveAtSwapBack(int index)
		{
			RemoveRangeSwapBack(index, 1);
		}

		public unsafe void RemoveRangeSwapBack(int index, int count)
		{
			if (count > 0)
			{
				int num = math.max(Length - count, index + count);
				int num2 = UnsafeUtility.SizeOf<T>();
				void* destination = Buffer + index * num2;
				void* source = Buffer + num * num2;
				UnsafeUtility.MemCpy(destination, source, (Length - num) * num2);
				Length -= count;
			}
		}

		public void RemoveAt(int index)
		{
			RemoveRange(index, 1);
		}

		public unsafe void RemoveRange(int index, int count)
		{
			if (count > 0)
			{
				int num = math.min(index + count, Length);
				int num2 = UnsafeUtility.SizeOf<T>();
				void* destination = Buffer + index * num2;
				void* source = Buffer + num * num2;
				UnsafeUtility.MemCpy(destination, source, (Length - num) * num2);
				Length -= count;
			}
		}

		[ExcludeFromBurstCompatTesting("Returns managed array")]
		public unsafe T[] ToArray()
		{
			T[] array = new T[Length];
			byte* source = Buffer;
			fixed (T* destination = array)
			{
				UnsafeUtility.MemCpy(destination, source, LengthInBytes);
			}
			return array;
		}

		public unsafe NativeArray<T> ToNativeArray(AllocatorManager.AllocatorHandle allocator)
		{
			NativeArray<T> nativeArray = CollectionHelper.CreateNativeArray<T>(Length, allocator, NativeArrayOptions.UninitializedMemory);
			UnsafeUtility.MemCpy(nativeArray.GetUnsafePtr(), Buffer, LengthInBytes);
			return nativeArray;
		}

		public unsafe static bool operator ==(in FixedList64Bytes<T> a, in FixedList32Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList64Bytes<T> a, in FixedList32Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList32Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList32Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList64Bytes(in FixedList32Bytes<T> other)
		{
			this = default(FixedList64Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList32Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList64Bytes<T>(in FixedList32Bytes<T> other)
		{
			return new FixedList64Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList64Bytes<T> a, in FixedList64Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList64Bytes<T> a, in FixedList64Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList64Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList64Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public unsafe static bool operator ==(in FixedList64Bytes<T> a, in FixedList128Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList64Bytes<T> a, in FixedList128Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList128Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList128Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList64Bytes(in FixedList128Bytes<T> other)
		{
			this = default(FixedList64Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList128Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList64Bytes<T>(in FixedList128Bytes<T> other)
		{
			return new FixedList64Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList64Bytes<T> a, in FixedList512Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList64Bytes<T> a, in FixedList512Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList512Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList512Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList64Bytes(in FixedList512Bytes<T> other)
		{
			this = default(FixedList64Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList512Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList64Bytes<T>(in FixedList512Bytes<T> other)
		{
			return new FixedList64Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList64Bytes<T> a, in FixedList4096Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList64Bytes<T> a, in FixedList4096Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList4096Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList4096Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList64Bytes(in FixedList4096Bytes<T> other)
		{
			this = default(FixedList64Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList4096Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList64Bytes<T>(in FixedList4096Bytes<T> other)
		{
			return new FixedList64Bytes<T>(in other);
		}

		[ExcludeFromBurstCompatTesting("Takes managed object")]
		public override bool Equals(object obj)
		{
			if (obj is FixedList32Bytes<T> other)
			{
				return Equals(other);
			}
			if (obj is FixedList64Bytes<T> other2)
			{
				return Equals(other2);
			}
			if (obj is FixedList128Bytes<T> other3)
			{
				return Equals(other3);
			}
			if (obj is FixedList512Bytes<T> other4)
			{
				return Equals(other4);
			}
			if (obj is FixedList4096Bytes<T> other5)
			{
				return Equals(other5);
			}
			return false;
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(ref this);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			throw new NotImplementedException();
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class FixedList64BytesExtensions
	{
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static int IndexOf<T, U>(this ref FixedList64Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			return NativeArrayExtensions.IndexOf<T, U>(list.Buffer, list.Length, value);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool Contains<T, U>(this ref FixedList64Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			return IndexOf(ref list, value) != -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool Remove<T, U>(this ref FixedList64Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			int num = IndexOf(ref list, value);
			if (num < 0)
			{
				return false;
			}
			list.RemoveAt(num);
			return true;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool RemoveSwapBack<T, U>(this ref FixedList64Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			int num = IndexOf(ref list, value);
			if (num == -1)
			{
				return false;
			}
			list.RemoveAtSwapBack(num);
			return true;
		}
	}
	internal sealed class FixedList64BytesDebugView<T> where T : unmanaged
	{
		private FixedList64Bytes<T> m_List;

		public T[] Items => m_List.ToArray();

		public FixedList64BytesDebugView(FixedList64Bytes<T> list)
		{
			m_List = list;
		}
	}
	[Serializable]
	[DebuggerTypeProxy(typeof(FixedList128BytesDebugView<>))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct FixedList128Bytes<T> : INativeList<T>, IIndexable<T>, IEnumerable<T>, IEnumerable, IEquatable<FixedList32Bytes<T>>, IComparable<FixedList32Bytes<T>>, IEquatable<FixedList64Bytes<T>>, IComparable<FixedList64Bytes<T>>, IEquatable<FixedList128Bytes<T>>, IComparable<FixedList128Bytes<T>>, IEquatable<FixedList512Bytes<T>>, IComparable<FixedList512Bytes<T>>, IEquatable<FixedList4096Bytes<T>>, IComparable<FixedList4096Bytes<T>> where T : unmanaged
	{
		public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
		{
			private FixedList128Bytes<T> m_List;

			private int m_Index;

			public T Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_List[m_Index];
				}
			}

			object IEnumerator.Current => Current;

			public Enumerator(ref FixedList128Bytes<T> list)
			{
				m_List = list;
				m_Index = -1;
			}

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				m_Index++;
				return m_Index < m_List.Length;
			}

			public void Reset()
			{
				m_Index = -1;
			}
		}

		[SerializeField]
		internal FixedBytes128Align8 data;

		internal unsafe ushort length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				fixed (FixedBytes128Align8* ptr = &data)
				{
					void* ptr2 = ptr;
					return *(ushort*)ptr2;
				}
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				fixed (FixedBytes128Align8* ptr = &data)
				{
					void* ptr2 = ptr;
					*(ushort*)ptr2 = value;
				}
			}
		}

		internal unsafe readonly byte* buffer
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				fixed (FixedBytes128Align8* ptr = &data)
				{
					void* ptr2 = ptr;
					return (byte*)ptr2 + UnsafeUtility.SizeOf<ushort>();
				}
			}
		}

		[CreateProperty]
		public int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return length;
			}
			set
			{
				length = (ushort)value;
			}
		}

		[CreateProperty]
		private IEnumerable<T> Elements => ToArray();

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return Length == 0;
			}
		}

		internal int LengthInBytes => Length * UnsafeUtility.SizeOf<T>();

		internal unsafe readonly byte* Buffer
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return buffer + FixedList.PaddingBytes<T>();
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return FixedList.Capacity<FixedBytes128Align8, T>();
			}
			set
			{
			}
		}

		public unsafe T this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return UnsafeUtility.ReadArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index));
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				UnsafeUtility.WriteArrayElement(Buffer, CollectionHelper.AssumePositive(index), value);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe ref T ElementAt(int index)
		{
			return ref UnsafeUtility.ArrayElementAsRef<T>(Buffer, index);
		}

		public unsafe override int GetHashCode()
		{
			return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
		}

		public void Add(in T item)
		{
			AddNoResize(in item);
		}

		public unsafe void AddRange(void* ptr, int length)
		{
			AddRangeNoResize(ptr, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AddNoResize(in T item)
		{
			this[Length++] = item;
		}

		public unsafe void AddRangeNoResize(void* ptr, int length)
		{
			int num = Length;
			Length += length;
			UnsafeUtility.MemCpy(Buffer + (nint)num * (nint)sizeof(T), ptr, UnsafeUtility.SizeOf<T>() * length);
		}

		public unsafe void AddReplicate(in T value, int count)
		{
			int num = Length;
			Length += count;
			fixed (T* source = &value)
			{
				UnsafeUtility.MemCpyReplicate(Buffer + (nint)num * (nint)sizeof(T), source, UnsafeUtility.SizeOf<T>(), count);
			}
		}

		public void Clear()
		{
			Length = 0;
		}

		public unsafe void InsertRangeWithBeginEnd(int begin, int end)
		{
			int num = end - begin;
			if (num >= 1)
			{
				int num2 = length - begin;
				Length += num;
				if (num2 >= 1)
				{
					int num3 = num2 * UnsafeUtility.SizeOf<T>();
					byte* num4 = Buffer;
					byte* destination = num4 + end * UnsafeUtility.SizeOf<T>();
					byte* source = num4 + begin * UnsafeUtility.SizeOf<T>();
					UnsafeUtility.MemMove(destination, source, num3);
				}
			}
		}

		public void InsertRange(int index, int count)
		{
			InsertRangeWithBeginEnd(index, index + count);
		}

		public void Insert(int index, in T item)
		{
			InsertRangeWithBeginEnd(index, index + 1);
			this[index] = item;
		}

		public void RemoveAtSwapBack(int index)
		{
			RemoveRangeSwapBack(index, 1);
		}

		public unsafe void RemoveRangeSwapBack(int index, int count)
		{
			if (count > 0)
			{
				int num = math.max(Length - count, index + count);
				int num2 = UnsafeUtility.SizeOf<T>();
				void* destination = Buffer + index * num2;
				void* source = Buffer + num * num2;
				UnsafeUtility.MemCpy(destination, source, (Length - num) * num2);
				Length -= count;
			}
		}

		public void RemoveAt(int index)
		{
			RemoveRange(index, 1);
		}

		public unsafe void RemoveRange(int index, int count)
		{
			if (count > 0)
			{
				int num = math.min(index + count, Length);
				int num2 = UnsafeUtility.SizeOf<T>();
				void* destination = Buffer + index * num2;
				void* source = Buffer + num * num2;
				UnsafeUtility.MemCpy(destination, source, (Length - num) * num2);
				Length -= count;
			}
		}

		[ExcludeFromBurstCompatTesting("Returns managed array")]
		public unsafe T[] ToArray()
		{
			T[] array = new T[Length];
			byte* source = Buffer;
			fixed (T* destination = array)
			{
				UnsafeUtility.MemCpy(destination, source, LengthInBytes);
			}
			return array;
		}

		public unsafe NativeArray<T> ToNativeArray(AllocatorManager.AllocatorHandle allocator)
		{
			NativeArray<T> nativeArray = CollectionHelper.CreateNativeArray<T>(Length, allocator, NativeArrayOptions.UninitializedMemory);
			UnsafeUtility.MemCpy(nativeArray.GetUnsafePtr(), Buffer, LengthInBytes);
			return nativeArray;
		}

		public unsafe static bool operator ==(in FixedList128Bytes<T> a, in FixedList32Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList128Bytes<T> a, in FixedList32Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList32Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList32Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList128Bytes(in FixedList32Bytes<T> other)
		{
			this = default(FixedList128Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList32Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList128Bytes<T>(in FixedList32Bytes<T> other)
		{
			return new FixedList128Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList128Bytes<T> a, in FixedList64Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList128Bytes<T> a, in FixedList64Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList64Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList64Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList128Bytes(in FixedList64Bytes<T> other)
		{
			this = default(FixedList128Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList64Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList128Bytes<T>(in FixedList64Bytes<T> other)
		{
			return new FixedList128Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList128Bytes<T> a, in FixedList128Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList128Bytes<T> a, in FixedList128Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList128Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList128Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public unsafe static bool operator ==(in FixedList128Bytes<T> a, in FixedList512Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList128Bytes<T> a, in FixedList512Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList512Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList512Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList128Bytes(in FixedList512Bytes<T> other)
		{
			this = default(FixedList128Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList512Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList128Bytes<T>(in FixedList512Bytes<T> other)
		{
			return new FixedList128Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList128Bytes<T> a, in FixedList4096Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList128Bytes<T> a, in FixedList4096Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList4096Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList4096Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList128Bytes(in FixedList4096Bytes<T> other)
		{
			this = default(FixedList128Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList4096Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList128Bytes<T>(in FixedList4096Bytes<T> other)
		{
			return new FixedList128Bytes<T>(in other);
		}

		[ExcludeFromBurstCompatTesting("Takes managed object")]
		public override bool Equals(object obj)
		{
			if (obj is FixedList32Bytes<T> other)
			{
				return Equals(other);
			}
			if (obj is FixedList64Bytes<T> other2)
			{
				return Equals(other2);
			}
			if (obj is FixedList128Bytes<T> other3)
			{
				return Equals(other3);
			}
			if (obj is FixedList512Bytes<T> other4)
			{
				return Equals(other4);
			}
			if (obj is FixedList4096Bytes<T> other5)
			{
				return Equals(other5);
			}
			return false;
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(ref this);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			throw new NotImplementedException();
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class FixedList128BytesExtensions
	{
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static int IndexOf<T, U>(this ref FixedList128Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			return NativeArrayExtensions.IndexOf<T, U>(list.Buffer, list.Length, value);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool Contains<T, U>(this ref FixedList128Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			return IndexOf(ref list, value) != -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool Remove<T, U>(this ref FixedList128Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			int num = IndexOf(ref list, value);
			if (num < 0)
			{
				return false;
			}
			list.RemoveAt(num);
			return true;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool RemoveSwapBack<T, U>(this ref FixedList128Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			int num = IndexOf(ref list, value);
			if (num == -1)
			{
				return false;
			}
			list.RemoveAtSwapBack(num);
			return true;
		}
	}
	internal sealed class FixedList128BytesDebugView<T> where T : unmanaged
	{
		private FixedList128Bytes<T> m_List;

		public T[] Items => m_List.ToArray();

		public FixedList128BytesDebugView(FixedList128Bytes<T> list)
		{
			m_List = list;
		}
	}
	[Serializable]
	[DebuggerTypeProxy(typeof(FixedList512BytesDebugView<>))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct FixedList512Bytes<T> : INativeList<T>, IIndexable<T>, IEnumerable<T>, IEnumerable, IEquatable<FixedList32Bytes<T>>, IComparable<FixedList32Bytes<T>>, IEquatable<FixedList64Bytes<T>>, IComparable<FixedList64Bytes<T>>, IEquatable<FixedList128Bytes<T>>, IComparable<FixedList128Bytes<T>>, IEquatable<FixedList512Bytes<T>>, IComparable<FixedList512Bytes<T>>, IEquatable<FixedList4096Bytes<T>>, IComparable<FixedList4096Bytes<T>> where T : unmanaged
	{
		public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
		{
			private FixedList512Bytes<T> m_List;

			private int m_Index;

			public T Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_List[m_Index];
				}
			}

			object IEnumerator.Current => Current;

			public Enumerator(ref FixedList512Bytes<T> list)
			{
				m_List = list;
				m_Index = -1;
			}

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				m_Index++;
				return m_Index < m_List.Length;
			}

			public void Reset()
			{
				m_Index = -1;
			}
		}

		[SerializeField]
		internal FixedBytes512Align8 data;

		internal unsafe ushort length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				fixed (FixedBytes512Align8* ptr = &data)
				{
					void* ptr2 = ptr;
					return *(ushort*)ptr2;
				}
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				fixed (FixedBytes512Align8* ptr = &data)
				{
					void* ptr2 = ptr;
					*(ushort*)ptr2 = value;
				}
			}
		}

		internal unsafe readonly byte* buffer
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				fixed (FixedBytes512Align8* ptr = &data)
				{
					void* ptr2 = ptr;
					return (byte*)ptr2 + UnsafeUtility.SizeOf<ushort>();
				}
			}
		}

		[CreateProperty]
		public int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return length;
			}
			set
			{
				length = (ushort)value;
			}
		}

		[CreateProperty]
		private IEnumerable<T> Elements => ToArray();

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return Length == 0;
			}
		}

		internal int LengthInBytes => Length * UnsafeUtility.SizeOf<T>();

		internal unsafe readonly byte* Buffer
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return buffer + FixedList.PaddingBytes<T>();
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return FixedList.Capacity<FixedBytes512Align8, T>();
			}
			set
			{
			}
		}

		public unsafe T this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return UnsafeUtility.ReadArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index));
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				UnsafeUtility.WriteArrayElement(Buffer, CollectionHelper.AssumePositive(index), value);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe ref T ElementAt(int index)
		{
			return ref UnsafeUtility.ArrayElementAsRef<T>(Buffer, index);
		}

		public unsafe override int GetHashCode()
		{
			return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
		}

		public void Add(in T item)
		{
			AddNoResize(in item);
		}

		public unsafe void AddRange(void* ptr, int length)
		{
			AddRangeNoResize(ptr, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AddNoResize(in T item)
		{
			this[Length++] = item;
		}

		public unsafe void AddRangeNoResize(void* ptr, int length)
		{
			int num = Length;
			Length += length;
			UnsafeUtility.MemCpy(Buffer + (nint)num * (nint)sizeof(T), ptr, UnsafeUtility.SizeOf<T>() * length);
		}

		public unsafe void AddReplicate(in T value, int count)
		{
			int num = Length;
			Length += count;
			fixed (T* source = &value)
			{
				UnsafeUtility.MemCpyReplicate(Buffer + (nint)num * (nint)sizeof(T), source, UnsafeUtility.SizeOf<T>(), count);
			}
		}

		public void Clear()
		{
			Length = 0;
		}

		public unsafe void InsertRangeWithBeginEnd(int begin, int end)
		{
			int num = end - begin;
			if (num >= 1)
			{
				int num2 = length - begin;
				Length += num;
				if (num2 >= 1)
				{
					int num3 = num2 * UnsafeUtility.SizeOf<T>();
					byte* num4 = Buffer;
					byte* destination = num4 + end * UnsafeUtility.SizeOf<T>();
					byte* source = num4 + begin * UnsafeUtility.SizeOf<T>();
					UnsafeUtility.MemMove(destination, source, num3);
				}
			}
		}

		public void InsertRange(int index, int count)
		{
			InsertRangeWithBeginEnd(index, index + count);
		}

		public void Insert(int index, in T item)
		{
			InsertRangeWithBeginEnd(index, index + 1);
			this[index] = item;
		}

		public void RemoveAtSwapBack(int index)
		{
			RemoveRangeSwapBack(index, 1);
		}

		public unsafe void RemoveRangeSwapBack(int index, int count)
		{
			if (count > 0)
			{
				int num = math.max(Length - count, index + count);
				int num2 = UnsafeUtility.SizeOf<T>();
				void* destination = Buffer + index * num2;
				void* source = Buffer + num * num2;
				UnsafeUtility.MemCpy(destination, source, (Length - num) * num2);
				Length -= count;
			}
		}

		public void RemoveAt(int index)
		{
			RemoveRange(index, 1);
		}

		public unsafe void RemoveRange(int index, int count)
		{
			if (count > 0)
			{
				int num = math.min(index + count, Length);
				int num2 = UnsafeUtility.SizeOf<T>();
				void* destination = Buffer + index * num2;
				void* source = Buffer + num * num2;
				UnsafeUtility.MemCpy(destination, source, (Length - num) * num2);
				Length -= count;
			}
		}

		[ExcludeFromBurstCompatTesting("Returns managed array")]
		public unsafe T[] ToArray()
		{
			T[] array = new T[Length];
			byte* source = Buffer;
			fixed (T* destination = array)
			{
				UnsafeUtility.MemCpy(destination, source, LengthInBytes);
			}
			return array;
		}

		public unsafe NativeArray<T> ToNativeArray(AllocatorManager.AllocatorHandle allocator)
		{
			NativeArray<T> nativeArray = CollectionHelper.CreateNativeArray<T>(Length, allocator, NativeArrayOptions.UninitializedMemory);
			UnsafeUtility.MemCpy(nativeArray.GetUnsafePtr(), Buffer, LengthInBytes);
			return nativeArray;
		}

		public unsafe static bool operator ==(in FixedList512Bytes<T> a, in FixedList32Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList512Bytes<T> a, in FixedList32Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList32Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList32Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList512Bytes(in FixedList32Bytes<T> other)
		{
			this = default(FixedList512Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList32Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList512Bytes<T>(in FixedList32Bytes<T> other)
		{
			return new FixedList512Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList512Bytes<T> a, in FixedList64Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList512Bytes<T> a, in FixedList64Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList64Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList64Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList512Bytes(in FixedList64Bytes<T> other)
		{
			this = default(FixedList512Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList64Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList512Bytes<T>(in FixedList64Bytes<T> other)
		{
			return new FixedList512Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList512Bytes<T> a, in FixedList128Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList512Bytes<T> a, in FixedList128Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList128Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList128Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList512Bytes(in FixedList128Bytes<T> other)
		{
			this = default(FixedList512Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList128Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList512Bytes<T>(in FixedList128Bytes<T> other)
		{
			return new FixedList512Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList512Bytes<T> a, in FixedList512Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList512Bytes<T> a, in FixedList512Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList512Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList512Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public unsafe static bool operator ==(in FixedList512Bytes<T> a, in FixedList4096Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList512Bytes<T> a, in FixedList4096Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList4096Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList4096Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList512Bytes(in FixedList4096Bytes<T> other)
		{
			this = default(FixedList512Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList4096Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList512Bytes<T>(in FixedList4096Bytes<T> other)
		{
			return new FixedList512Bytes<T>(in other);
		}

		[ExcludeFromBurstCompatTesting("Takes managed object")]
		public override bool Equals(object obj)
		{
			if (obj is FixedList32Bytes<T> other)
			{
				return Equals(other);
			}
			if (obj is FixedList64Bytes<T> other2)
			{
				return Equals(other2);
			}
			if (obj is FixedList128Bytes<T> other3)
			{
				return Equals(other3);
			}
			if (obj is FixedList512Bytes<T> other4)
			{
				return Equals(other4);
			}
			if (obj is FixedList4096Bytes<T> other5)
			{
				return Equals(other5);
			}
			return false;
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(ref this);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			throw new NotImplementedException();
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class FixedList512BytesExtensions
	{
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static int IndexOf<T, U>(this ref FixedList512Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			return NativeArrayExtensions.IndexOf<T, U>(list.Buffer, list.Length, value);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool Contains<T, U>(this ref FixedList512Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			return IndexOf(ref list, value) != -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool Remove<T, U>(this ref FixedList512Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			int num = IndexOf(ref list, value);
			if (num < 0)
			{
				return false;
			}
			list.RemoveAt(num);
			return true;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool RemoveSwapBack<T, U>(this ref FixedList512Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			int num = IndexOf(ref list, value);
			if (num == -1)
			{
				return false;
			}
			list.RemoveAtSwapBack(num);
			return true;
		}
	}
	internal sealed class FixedList512BytesDebugView<T> where T : unmanaged
	{
		private FixedList512Bytes<T> m_List;

		public T[] Items => m_List.ToArray();

		public FixedList512BytesDebugView(FixedList512Bytes<T> list)
		{
			m_List = list;
		}
	}
	[Serializable]
	[DebuggerTypeProxy(typeof(FixedList4096BytesDebugView<>))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct FixedList4096Bytes<T> : INativeList<T>, IIndexable<T>, IEnumerable<T>, IEnumerable, IEquatable<FixedList32Bytes<T>>, IComparable<FixedList32Bytes<T>>, IEquatable<FixedList64Bytes<T>>, IComparable<FixedList64Bytes<T>>, IEquatable<FixedList128Bytes<T>>, IComparable<FixedList128Bytes<T>>, IEquatable<FixedList512Bytes<T>>, IComparable<FixedList512Bytes<T>>, IEquatable<FixedList4096Bytes<T>>, IComparable<FixedList4096Bytes<T>> where T : unmanaged
	{
		public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
		{
			private FixedList4096Bytes<T> m_List;

			private int m_Index;

			public T Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_List[m_Index];
				}
			}

			object IEnumerator.Current => Current;

			public Enumerator(ref FixedList4096Bytes<T> list)
			{
				m_List = list;
				m_Index = -1;
			}

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				m_Index++;
				return m_Index < m_List.Length;
			}

			public void Reset()
			{
				m_Index = -1;
			}
		}

		[SerializeField]
		internal FixedBytes4096Align8 data;

		internal unsafe ushort length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				fixed (FixedBytes4096Align8* ptr = &data)
				{
					void* ptr2 = ptr;
					return *(ushort*)ptr2;
				}
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				fixed (FixedBytes4096Align8* ptr = &data)
				{
					void* ptr2 = ptr;
					*(ushort*)ptr2 = value;
				}
			}
		}

		internal unsafe readonly byte* buffer
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				fixed (FixedBytes4096Align8* ptr = &data)
				{
					void* ptr2 = ptr;
					return (byte*)ptr2 + UnsafeUtility.SizeOf<ushort>();
				}
			}
		}

		[CreateProperty]
		public int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return length;
			}
			set
			{
				length = (ushort)value;
			}
		}

		[CreateProperty]
		private IEnumerable<T> Elements => ToArray();

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return Length == 0;
			}
		}

		internal int LengthInBytes => Length * UnsafeUtility.SizeOf<T>();

		internal unsafe readonly byte* Buffer
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return buffer + FixedList.PaddingBytes<T>();
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return FixedList.Capacity<FixedBytes4096Align8, T>();
			}
			set
			{
			}
		}

		public unsafe T this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return UnsafeUtility.ReadArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index));
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				UnsafeUtility.WriteArrayElement(Buffer, CollectionHelper.AssumePositive(index), value);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe ref T ElementAt(int index)
		{
			return ref UnsafeUtility.ArrayElementAsRef<T>(Buffer, index);
		}

		public unsafe override int GetHashCode()
		{
			return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
		}

		public void Add(in T item)
		{
			AddNoResize(in item);
		}

		public unsafe void AddRange(void* ptr, int length)
		{
			AddRangeNoResize(ptr, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AddNoResize(in T item)
		{
			this[Length++] = item;
		}

		public unsafe void AddRangeNoResize(void* ptr, int length)
		{
			int num = Length;
			Length += length;
			UnsafeUtility.MemCpy(Buffer + (nint)num * (nint)sizeof(T), ptr, UnsafeUtility.SizeOf<T>() * length);
		}

		public unsafe void AddReplicate(in T value, int count)
		{
			int num = Length;
			Length += count;
			fixed (T* source = &value)
			{
				UnsafeUtility.MemCpyReplicate(Buffer + (nint)num * (nint)sizeof(T), source, UnsafeUtility.SizeOf<T>(), count);
			}
		}

		public void Clear()
		{
			Length = 0;
		}

		public unsafe void InsertRangeWithBeginEnd(int begin, int end)
		{
			int num = end - begin;
			if (num >= 1)
			{
				int num2 = length - begin;
				Length += num;
				if (num2 >= 1)
				{
					int num3 = num2 * UnsafeUtility.SizeOf<T>();
					byte* num4 = Buffer;
					byte* destination = num4 + end * UnsafeUtility.SizeOf<T>();
					byte* source = num4 + begin * UnsafeUtility.SizeOf<T>();
					UnsafeUtility.MemMove(destination, source, num3);
				}
			}
		}

		public void InsertRange(int index, int count)
		{
			InsertRangeWithBeginEnd(index, index + count);
		}

		public void Insert(int index, in T item)
		{
			InsertRangeWithBeginEnd(index, index + 1);
			this[index] = item;
		}

		public void RemoveAtSwapBack(int index)
		{
			RemoveRangeSwapBack(index, 1);
		}

		public unsafe void RemoveRangeSwapBack(int index, int count)
		{
			if (count > 0)
			{
				int num = math.max(Length - count, index + count);
				int num2 = UnsafeUtility.SizeOf<T>();
				void* destination = Buffer + index * num2;
				void* source = Buffer + num * num2;
				UnsafeUtility.MemCpy(destination, source, (Length - num) * num2);
				Length -= count;
			}
		}

		public void RemoveAt(int index)
		{
			RemoveRange(index, 1);
		}

		public unsafe void RemoveRange(int index, int count)
		{
			if (count > 0)
			{
				int num = math.min(index + count, Length);
				int num2 = UnsafeUtility.SizeOf<T>();
				void* destination = Buffer + index * num2;
				void* source = Buffer + num * num2;
				UnsafeUtility.MemCpy(destination, source, (Length - num) * num2);
				Length -= count;
			}
		}

		[ExcludeFromBurstCompatTesting("Returns managed array")]
		public unsafe T[] ToArray()
		{
			T[] array = new T[Length];
			byte* source = Buffer;
			fixed (T* destination = array)
			{
				UnsafeUtility.MemCpy(destination, source, LengthInBytes);
			}
			return array;
		}

		public unsafe NativeArray<T> ToNativeArray(AllocatorManager.AllocatorHandle allocator)
		{
			NativeArray<T> nativeArray = CollectionHelper.CreateNativeArray<T>(Length, allocator, NativeArrayOptions.UninitializedMemory);
			UnsafeUtility.MemCpy(nativeArray.GetUnsafePtr(), Buffer, LengthInBytes);
			return nativeArray;
		}

		public unsafe static bool operator ==(in FixedList4096Bytes<T> a, in FixedList32Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList4096Bytes<T> a, in FixedList32Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList32Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList32Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList4096Bytes(in FixedList32Bytes<T> other)
		{
			this = default(FixedList4096Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList32Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList4096Bytes<T>(in FixedList32Bytes<T> other)
		{
			return new FixedList4096Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList4096Bytes<T> a, in FixedList64Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList4096Bytes<T> a, in FixedList64Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList64Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList64Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList4096Bytes(in FixedList64Bytes<T> other)
		{
			this = default(FixedList4096Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList64Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList4096Bytes<T>(in FixedList64Bytes<T> other)
		{
			return new FixedList4096Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList4096Bytes<T> a, in FixedList128Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList4096Bytes<T> a, in FixedList128Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList128Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList128Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList4096Bytes(in FixedList128Bytes<T> other)
		{
			this = default(FixedList4096Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList128Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList4096Bytes<T>(in FixedList128Bytes<T> other)
		{
			return new FixedList4096Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList4096Bytes<T> a, in FixedList512Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList4096Bytes<T> a, in FixedList512Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList512Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList512Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		public FixedList4096Bytes(in FixedList512Bytes<T> other)
		{
			this = default(FixedList4096Bytes<T>);
			Initialize(in other);
		}

		internal unsafe int Initialize(in FixedList512Bytes<T> other)
		{
			if (other.Length > Capacity)
			{
				return 1;
			}
			length = other.length;
			UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
			return 0;
		}

		public static implicit operator FixedList4096Bytes<T>(in FixedList512Bytes<T> other)
		{
			return new FixedList4096Bytes<T>(in other);
		}

		public unsafe static bool operator ==(in FixedList4096Bytes<T> a, in FixedList4096Bytes<T> b)
		{
			if (a.length != b.length)
			{
				return false;
			}
			return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
		}

		public static bool operator !=(in FixedList4096Bytes<T> a, in FixedList4096Bytes<T> b)
		{
			return !(a == b);
		}

		public unsafe int CompareTo(FixedList4096Bytes<T> other)
		{
			byte* num = buffer;
			byte* ptr = other.buffer;
			byte* ptr2 = num + FixedList.PaddingBytes<T>();
			byte* ptr3 = ptr + FixedList.PaddingBytes<T>();
			int num2 = math.min(Length, other.Length);
			for (int i = 0; i < num2; i++)
			{
				int num3 = UnsafeUtility.MemCmp(ptr2 + sizeof(T) * i, ptr3 + sizeof(T) * i, sizeof(T));
				if (num3 != 0)
				{
					return num3;
				}
			}
			return Length.CompareTo(other.Length);
		}

		public bool Equals(FixedList4096Bytes<T> other)
		{
			return CompareTo(other) == 0;
		}

		[ExcludeFromBurstCompatTesting("Takes managed object")]
		public override bool Equals(object obj)
		{
			if (obj is FixedList32Bytes<T> other)
			{
				return Equals(other);
			}
			if (obj is FixedList64Bytes<T> other2)
			{
				return Equals(other2);
			}
			if (obj is FixedList128Bytes<T> other3)
			{
				return Equals(other3);
			}
			if (obj is FixedList512Bytes<T> other4)
			{
				return Equals(other4);
			}
			if (obj is FixedList4096Bytes<T> other5)
			{
				return Equals(other5);
			}
			return false;
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(ref this);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			throw new NotImplementedException();
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class FixedList4096BytesExtensions
	{
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static int IndexOf<T, U>(this ref FixedList4096Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			return NativeArrayExtensions.IndexOf<T, U>(list.Buffer, list.Length, value);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool Contains<T, U>(this ref FixedList4096Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			return IndexOf(ref list, value) != -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool Remove<T, U>(this ref FixedList4096Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			int num = IndexOf(ref list, value);
			if (num < 0)
			{
				return false;
			}
			list.RemoveAt(num);
			return true;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool RemoveSwapBack<T, U>(this ref FixedList4096Bytes<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			int num = IndexOf(ref list, value);
			if (num == -1)
			{
				return false;
			}
			list.RemoveAtSwapBack(num);
			return true;
		}
	}
	internal sealed class FixedList4096BytesDebugView<T> where T : unmanaged
	{
		private FixedList4096Bytes<T> m_List;

		public T[] Items => m_List.ToArray();

		public FixedList4096BytesDebugView(FixedList4096Bytes<T> list)
		{
			m_List = list;
		}
	}
	public static class FixedListExtensions
	{
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static void Sort<T>(this ref FixedList32Bytes<T> list) where T : unmanaged, IComparable<T>
		{
			NativeSortExtension.Sort((T*)(list.buffer + FixedList.PaddingBytes<T>()), list.Length);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(NativeSortExtension.DefaultComparer<int>)
		})]
		public unsafe static void Sort<T, U>(this ref FixedList32Bytes<T> list, U comp) where T : unmanaged, IComparable<T> where U : IComparer<T>
		{
			NativeSortExtension.Sort((T*)(list.buffer + FixedList.PaddingBytes<T>()), list.Length, comp);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static void Sort<T>(this ref FixedList64Bytes<T> list) where T : unmanaged, IComparable<T>
		{
			NativeSortExtension.Sort((T*)(list.buffer + FixedList.PaddingBytes<T>()), list.Length);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(NativeSortExtension.DefaultComparer<int>)
		})]
		public unsafe static void Sort<T, U>(this ref FixedList64Bytes<T> list, U comp) where T : unmanaged, IComparable<T> where U : IComparer<T>
		{
			NativeSortExtension.Sort((T*)(list.buffer + FixedList.PaddingBytes<T>()), list.Length, comp);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static void Sort<T>(this ref FixedList128Bytes<T> list) where T : unmanaged, IComparable<T>
		{
			NativeSortExtension.Sort((T*)(list.buffer + FixedList.PaddingBytes<T>()), list.Length);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(NativeSortExtension.DefaultComparer<int>)
		})]
		public unsafe static void Sort<T, U>(this ref FixedList128Bytes<T> list, U comp) where T : unmanaged, IComparable<T> where U : IComparer<T>
		{
			NativeSortExtension.Sort((T*)(list.buffer + FixedList.PaddingBytes<T>()), list.Length, comp);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static void Sort<T>(this ref FixedList512Bytes<T> list) where T : unmanaged, IComparable<T>
		{
			NativeSortExtension.Sort((T*)(list.buffer + FixedList.PaddingBytes<T>()), list.Length);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(NativeSortExtension.DefaultComparer<int>)
		})]
		public unsafe static void Sort<T, U>(this ref FixedList512Bytes<T> list, U comp) where T : unmanaged, IComparable<T> where U : IComparer<T>
		{
			NativeSortExtension.Sort((T*)(list.buffer + FixedList.PaddingBytes<T>()), list.Length, comp);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static void Sort<T>(this ref FixedList4096Bytes<T> list) where T : unmanaged, IComparable<T>
		{
			NativeSortExtension.Sort((T*)(list.buffer + FixedList.PaddingBytes<T>()), list.Length);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(NativeSortExtension.DefaultComparer<int>)
		})]
		public unsafe static void Sort<T, U>(this ref FixedList4096Bytes<T> list, U comp) where T : unmanaged, IComparable<T> where U : IComparer<T>
		{
			NativeSortExtension.Sort((T*)(list.buffer + FixedList.PaddingBytes<T>()), list.Length, comp);
		}
	}
	[Serializable]
	[StructLayout(LayoutKind.Explicit, Size = 16)]
	[GenerateTestsForBurstCompatibility]
	internal struct FixedBytes16Align8
	{
		[FieldOffset(0)]
		[SerializeField]
		public ulong byte0000;

		[FieldOffset(8)]
		[SerializeField]
		public ulong byte0008;
	}
	[Serializable]
	[StructLayout(LayoutKind.Explicit, Size = 16)]
	[GenerateTestsForBurstCompatibility]
	public struct FixedBytes16
	{
		[FieldOffset(0)]
		public byte byte0000;

		[FieldOffset(1)]
		public byte byte0001;

		[FieldOffset(2)]
		public byte byte0002;

		[FieldOffset(3)]
		public byte byte0003;

		[FieldOffset(4)]
		public byte byte0004;

		[FieldOffset(5)]
		public byte byte0005;

		[FieldOffset(6)]
		public byte byte0006;

		[FieldOffset(7)]
		public byte byte0007;

		[FieldOffset(8)]
		public byte byte0008;

		[FieldOffset(9)]
		public byte byte0009;

		[FieldOffset(10)]
		public byte byte0010;

		[FieldOffset(11)]
		public byte byte0011;

		[FieldOffset(12)]
		public byte byte0012;

		[FieldOffset(13)]
		public byte byte0013;

		[FieldOffset(14)]
		public byte byte0014;

		[FieldOffset(15)]
		public byte byte0015;
	}
	[Serializable]
	[StructLayout(LayoutKind.Explicit, Size = 32)]
	[GenerateTestsForBurstCompatibility]
	internal struct FixedBytes32Align8
	{
		[FieldOffset(0)]
		[SerializeField]
		internal FixedBytes16Align8 offset0000;

		[FieldOffset(16)]
		[SerializeField]
		internal FixedBytes16Align8 offset0016;
	}
	[Serializable]
	[StructLayout(LayoutKind.Explicit, Size = 64)]
	[GenerateTestsForBurstCompatibility]
	internal struct FixedBytes64Align8
	{
		[FieldOffset(0)]
		[SerializeField]
		internal FixedBytes16Align8 offset0000;

		[FieldOffset(16)]
		[SerializeField]
		internal FixedBytes16Align8 offset0016;

		[FieldOffset(32)]
		[SerializeField]
		internal FixedBytes16Align8 offset0032;

		[FieldOffset(48)]
		[SerializeField]
		internal FixedBytes16Align8 offset0048;
	}
	[Serializable]
	[StructLayout(LayoutKind.Explicit, Size = 128)]
	[GenerateTestsForBurstCompatibility]
	internal struct FixedBytes128Align8
	{
		[FieldOffset(0)]
		[SerializeField]
		internal FixedBytes16Align8 offset0000;

		[FieldOffset(16)]
		[SerializeField]
		internal FixedBytes16Align8 offset0016;

		[FieldOffset(32)]
		[SerializeField]
		internal FixedBytes16Align8 offset0032;

		[FieldOffset(48)]
		[SerializeField]
		internal FixedBytes16Align8 offset0048;

		[FieldOffset(64)]
		[SerializeField]
		internal FixedBytes16Align8 offset0064;

		[FieldOffset(80)]
		[SerializeField]
		internal FixedBytes16Align8 offset0080;

		[FieldOffset(96)]
		[SerializeField]
		internal FixedBytes16Align8 offset0096;

		[FieldOffset(112)]
		[SerializeField]
		internal FixedBytes16Align8 offset0112;
	}
	[Serializable]
	[StructLayout(LayoutKind.Explicit, Size = 512)]
	[GenerateTestsForBurstCompatibility]
	internal struct FixedBytes512Align8
	{
		[FieldOffset(0)]
		[SerializeField]
		internal FixedBytes16Align8 offset0000;

		[FieldOffset(16)]
		[SerializeField]
		internal FixedBytes16Align8 offset0016;

		[FieldOffset(32)]
		[SerializeField]
		internal FixedBytes16Align8 offset0032;

		[FieldOffset(48)]
		[SerializeField]
		internal FixedBytes16Align8 offset0048;

		[FieldOffset(64)]
		[SerializeField]
		internal FixedBytes16Align8 offset0064;

		[FieldOffset(80)]
		[SerializeField]
		internal FixedBytes16Align8 offset0080;

		[FieldOffset(96)]
		[SerializeField]
		internal FixedBytes16Align8 offset0096;

		[FieldOffset(112)]
		[SerializeField]
		internal FixedBytes16Align8 offset0112;

		[FieldOffset(128)]
		[SerializeField]
		internal FixedBytes16Align8 offset0128;

		[FieldOffset(144)]
		[SerializeField]
		internal FixedBytes16Align8 offset0144;

		[FieldOffset(160)]
		[SerializeField]
		internal FixedBytes16Align8 offset0160;

		[FieldOffset(176)]
		[SerializeField]
		internal FixedBytes16Align8 offset0176;

		[FieldOffset(192)]
		[SerializeField]
		internal FixedBytes16Align8 offset0192;

		[FieldOffset(208)]
		[SerializeField]
		internal FixedBytes16Align8 offset0208;

		[FieldOffset(224)]
		[SerializeField]
		internal FixedBytes16Align8 offset0224;

		[FieldOffset(240)]
		[SerializeField]
		internal FixedBytes16Align8 offset0240;

		[FieldOffset(256)]
		[SerializeField]
		internal FixedBytes16Align8 offset0256;

		[FieldOffset(272)]
		[SerializeField]
		internal FixedBytes16Align8 offset0272;

		[FieldOffset(288)]
		[SerializeField]
		internal FixedBytes16Align8 offset0288;

		[FieldOffset(304)]
		[SerializeField]
		internal FixedBytes16Align8 offset0304;

		[FieldOffset(320)]
		[SerializeField]
		internal FixedBytes16Align8 offset0320;

		[FieldOffset(336)]
		[SerializeField]
		internal FixedBytes16Align8 offset0336;

		[FieldOffset(352)]
		[SerializeField]
		internal FixedBytes16Align8 offset0352;

		[FieldOffset(368)]
		[SerializeField]
		internal FixedBytes16Align8 offset0368;

		[FieldOffset(384)]
		[SerializeField]
		internal FixedBytes16Align8 offset0384;

		[FieldOffset(400)]
		[SerializeField]
		internal FixedBytes16Align8 offset0400;

		[FieldOffset(416)]
		[SerializeField]
		internal FixedBytes16Align8 offset0416;

		[FieldOffset(432)]
		[SerializeField]
		internal FixedBytes16Align8 offset0432;

		[FieldOffset(448)]
		[SerializeField]
		internal FixedBytes16Align8 offset0448;

		[FieldOffset(464)]
		[SerializeField]
		internal FixedBytes16Align8 offset0464;

		[FieldOffset(480)]
		[SerializeField]
		internal FixedBytes16Align8 offset0480;

		[FieldOffset(496)]
		[SerializeField]
		internal FixedBytes16Align8 offset0496;
	}
	[Serializable]
	[StructLayout(LayoutKind.Explicit, Size = 4096)]
	[GenerateTestsForBurstCompatibility]
	internal struct FixedBytes4096Align8
	{
		[FieldOffset(0)]
		[SerializeField]
		internal FixedBytes16Align8 offset0000;

		[FieldOffset(16)]
		[SerializeField]
		internal FixedBytes16Align8 offset0016;

		[FieldOffset(32)]
		[SerializeField]
		internal FixedBytes16Align8 offset0032;

		[FieldOffset(48)]
		[SerializeField]
		internal FixedBytes16Align8 offset0048;

		[FieldOffset(64)]
		[SerializeField]
		internal FixedBytes16Align8 offset0064;

		[FieldOffset(80)]
		[SerializeField]
		internal FixedBytes16Align8 offset0080;

		[FieldOffset(96)]
		[SerializeField]
		internal FixedBytes16Align8 offset0096;

		[FieldOffset(112)]
		[SerializeField]
		internal FixedBytes16Align8 offset0112;

		[FieldOffset(128)]
		[SerializeField]
		internal FixedBytes16Align8 offset0128;

		[FieldOffset(144)]
		[SerializeField]
		internal FixedBytes16Align8 offset0144;

		[FieldOffset(160)]
		[SerializeField]
		internal FixedBytes16Align8 offset0160;

		[FieldOffset(176)]
		[SerializeField]
		internal FixedBytes16Align8 offset0176;

		[FieldOffset(192)]
		[SerializeField]
		internal FixedBytes16Align8 offset0192;

		[FieldOffset(208)]
		[SerializeField]
		internal FixedBytes16Align8 offset0208;

		[FieldOffset(224)]
		[SerializeField]
		internal FixedBytes16Align8 offset0224;

		[FieldOffset(240)]
		[SerializeField]
		internal FixedBytes16Align8 offset0240;

		[FieldOffset(256)]
		[SerializeField]
		internal FixedBytes16Align8 offset0256;

		[FieldOffset(272)]
		[SerializeField]
		internal FixedBytes16Align8 offset0272;

		[FieldOffset(288)]
		[SerializeField]
		internal FixedBytes16Align8 offset0288;

		[FieldOffset(304)]
		[SerializeField]
		internal FixedBytes16Align8 offset0304;

		[FieldOffset(320)]
		[SerializeField]
		internal FixedBytes16Align8 offset0320;

		[FieldOffset(336)]
		[SerializeField]
		internal FixedBytes16Align8 offset0336;

		[FieldOffset(352)]
		[SerializeField]
		internal FixedBytes16Align8 offset0352;

		[FieldOffset(368)]
		[SerializeField]
		internal FixedBytes16Align8 offset0368;

		[FieldOffset(384)]
		[SerializeField]
		internal FixedBytes16Align8 offset0384;

		[FieldOffset(400)]
		[SerializeField]
		internal FixedBytes16Align8 offset0400;

		[FieldOffset(416)]
		[SerializeField]
		internal FixedBytes16Align8 offset0416;

		[FieldOffset(432)]
		[SerializeField]
		internal FixedBytes16Align8 offset0432;

		[FieldOffset(448)]
		[SerializeField]
		internal FixedBytes16Align8 offset0448;

		[FieldOffset(464)]
		[SerializeField]
		internal FixedBytes16Align8 offset0464;

		[FieldOffset(480)]
		[SerializeField]
		internal FixedBytes16Align8 offset0480;

		[FieldOffset(496)]
		[SerializeField]
		internal FixedBytes16Align8 offset0496;

		[FieldOffset(512)]
		[SerializeField]
		internal FixedBytes16Align8 offset0512;

		[FieldOffset(528)]
		[SerializeField]
		internal FixedBytes16Align8 offset0528;

		[FieldOffset(544)]
		[SerializeField]
		internal FixedBytes16Align8 offset0544;

		[FieldOffset(560)]
		[SerializeField]
		internal FixedBytes16Align8 offset0560;

		[FieldOffset(576)]
		[SerializeField]
		internal FixedBytes16Align8 offset0576;

		[FieldOffset(592)]
		[SerializeField]
		internal FixedBytes16Align8 offset0592;

		[FieldOffset(608)]
		[SerializeField]
		internal FixedBytes16Align8 offset0608;

		[FieldOffset(624)]
		[SerializeField]
		internal FixedBytes16Align8 offset0624;

		[FieldOffset(640)]
		[SerializeField]
		internal FixedBytes16Align8 offset0640;

		[FieldOffset(656)]
		[SerializeField]
		internal FixedBytes16Align8 offset0656;

		[FieldOffset(672)]
		[SerializeField]
		internal FixedBytes16Align8 offset0672;

		[FieldOffset(688)]
		[SerializeField]
		internal FixedBytes16Align8 offset0688;

		[FieldOffset(704)]
		[SerializeField]
		internal FixedBytes16Align8 offset0704;

		[FieldOffset(720)]
		[SerializeField]
		internal FixedBytes16Align8 offset0720;

		[FieldOffset(736)]
		[SerializeField]
		internal FixedBytes16Align8 offset0736;

		[FieldOffset(752)]
		[SerializeField]
		internal FixedBytes16Align8 offset0752;

		[FieldOffset(768)]
		[SerializeField]
		internal FixedBytes16Align8 offset0768;

		[FieldOffset(784)]
		[SerializeField]
		internal FixedBytes16Align8 offset0784;

		[FieldOffset(800)]
		[SerializeField]
		internal FixedBytes16Align8 offset0800;

		[FieldOffset(816)]
		[SerializeField]
		internal FixedBytes16Align8 offset0816;

		[FieldOffset(832)]
		[SerializeField]
		internal FixedBytes16Align8 offset0832;

		[FieldOffset(848)]
		[SerializeField]
		internal FixedBytes16Align8 offset0848;

		[FieldOffset(864)]
		[SerializeField]
		internal FixedBytes16Align8 offset0864;

		[FieldOffset(880)]
		[SerializeField]
		internal FixedBytes16Align8 offset0880;

		[FieldOffset(896)]
		[SerializeField]
		internal FixedBytes16Align8 offset0896;

		[FieldOffset(912)]
		[SerializeField]
		internal FixedBytes16Align8 offset0912;

		[FieldOffset(928)]
		[SerializeField]
		internal FixedBytes16Align8 offset0928;

		[FieldOffset(944)]
		[SerializeField]
		internal FixedBytes16Align8 offset0944;

		[FieldOffset(960)]
		[SerializeField]
		internal FixedBytes16Align8 offset0960;

		[FieldOffset(976)]
		[SerializeField]
		internal FixedBytes16Align8 offset0976;

		[FieldOffset(992)]
		[SerializeField]
		internal FixedBytes16Align8 offset0992;

		[FieldOffset(1008)]
		[SerializeField]
		internal FixedBytes16Align8 offset1008;

		[FieldOffset(1024)]
		[SerializeField]
		internal FixedBytes16Align8 offset1024;

		[FieldOffset(1040)]
		[SerializeField]
		internal FixedBytes16Align8 offset1040;

		[FieldOffset(1056)]
		[SerializeField]
		internal FixedBytes16Align8 offset1056;

		[FieldOffset(1072)]
		[SerializeField]
		internal FixedBytes16Align8 offset1072;

		[FieldOffset(1088)]
		[SerializeField]
		internal FixedBytes16Align8 offset1088;

		[FieldOffset(1104)]
		[SerializeField]
		internal FixedBytes16Align8 offset1104;

		[FieldOffset(1120)]
		[SerializeField]
		internal FixedBytes16Align8 offset1120;

		[FieldOffset(1136)]
		[SerializeField]
		internal FixedBytes16Align8 offset1136;

		[FieldOffset(1152)]
		[SerializeField]
		internal FixedBytes16Align8 offset1152;

		[FieldOffset(1168)]
		[SerializeField]
		internal FixedBytes16Align8 offset1168;

		[FieldOffset(1184)]
		[SerializeField]
		internal FixedBytes16Align8 offset1184;

		[FieldOffset(1200)]
		[SerializeField]
		internal FixedBytes16Align8 offset1200;

		[FieldOffset(1216)]
		[SerializeField]
		internal FixedBytes16Align8 offset1216;

		[FieldOffset(1232)]
		[SerializeField]
		internal FixedBytes16Align8 offset1232;

		[FieldOffset(1248)]
		[SerializeField]
		internal FixedBytes16Align8 offset1248;

		[FieldOffset(1264)]
		[SerializeField]
		internal FixedBytes16Align8 offset1264;

		[FieldOffset(1280)]
		[SerializeField]
		internal FixedBytes16Align8 offset1280;

		[FieldOffset(1296)]
		[SerializeField]
		internal FixedBytes16Align8 offset1296;

		[FieldOffset(1312)]
		[SerializeField]
		internal FixedBytes16Align8 offset1312;

		[FieldOffset(1328)]
		[SerializeField]
		internal FixedBytes16Align8 offset1328;

		[FieldOffset(1344)]
		[SerializeField]
		internal FixedBytes16Align8 offset1344;

		[FieldOffset(1360)]
		[SerializeField]
		internal FixedBytes16Align8 offset1360;

		[FieldOffset(1376)]
		[SerializeField]
		internal FixedBytes16Align8 offset1376;

		[FieldOffset(1392)]
		[SerializeField]
		internal FixedBytes16Align8 offset1392;

		[FieldOffset(1408)]
		[SerializeField]
		internal FixedBytes16Align8 offset1408;

		[FieldOffset(1424)]
		[SerializeField]
		internal FixedBytes16Align8 offset1424;

		[FieldOffset(1440)]
		[SerializeField]
		internal FixedBytes16Align8 offset1440;

		[FieldOffset(1456)]
		[SerializeField]
		internal FixedBytes16Align8 offset1456;

		[FieldOffset(1472)]
		[SerializeField]
		internal FixedBytes16Align8 offset1472;

		[FieldOffset(1488)]
		[SerializeField]
		internal FixedBytes16Align8 offset1488;

		[FieldOffset(1504)]
		[SerializeField]
		internal FixedBytes16Align8 offset1504;

		[FieldOffset(1520)]
		[SerializeField]
		internal FixedBytes16Align8 offset1520;

		[FieldOffset(1536)]
		[SerializeField]
		internal FixedBytes16Align8 offset1536;

		[FieldOffset(1552)]
		[SerializeField]
		internal FixedBytes16Align8 offset1552;

		[FieldOffset(1568)]
		[SerializeField]
		internal FixedBytes16Align8 offset1568;

		[FieldOffset(1584)]
		[SerializeField]
		internal FixedBytes16Align8 offset1584;

		[FieldOffset(1600)]
		[SerializeField]
		internal FixedBytes16Align8 offset1600;

		[FieldOffset(1616)]
		[SerializeField]
		internal FixedBytes16Align8 offset1616;

		[FieldOffset(1632)]
		[SerializeField]
		internal FixedBytes16Align8 offset1632;

		[FieldOffset(1648)]
		[SerializeField]
		internal FixedBytes16Align8 offset1648;

		[FieldOffset(1664)]
		[SerializeField]
		internal FixedBytes16Align8 offset1664;

		[FieldOffset(1680)]
		[SerializeField]
		internal FixedBytes16Align8 offset1680;

		[FieldOffset(1696)]
		[SerializeField]
		internal FixedBytes16Align8 offset1696;

		[FieldOffset(1712)]
		[SerializeField]
		internal FixedBytes16Align8 offset1712;

		[FieldOffset(1728)]
		[SerializeField]
		internal FixedBytes16Align8 offset1728;

		[FieldOffset(1744)]
		[SerializeField]
		internal FixedBytes16Align8 offset1744;

		[FieldOffset(1760)]
		[SerializeField]
		internal FixedBytes16Align8 offset1760;

		[FieldOffset(1776)]
		[SerializeField]
		internal FixedBytes16Align8 offset1776;

		[FieldOffset(1792)]
		[SerializeField]
		internal FixedBytes16Align8 offset1792;

		[FieldOffset(1808)]
		[SerializeField]
		internal FixedBytes16Align8 offset1808;

		[FieldOffset(1824)]
		[SerializeField]
		internal FixedBytes16Align8 offset1824;

		[FieldOffset(1840)]
		[SerializeField]
		internal FixedBytes16Align8 offset1840;

		[FieldOffset(1856)]
		[SerializeField]
		internal FixedBytes16Align8 offset1856;

		[FieldOffset(1872)]
		[SerializeField]
		internal FixedBytes16Align8 offset1872;

		[FieldOffset(1888)]
		[SerializeField]
		internal FixedBytes16Align8 offset1888;

		[FieldOffset(1904)]
		[SerializeField]
		internal FixedBytes16Align8 offset1904;

		[FieldOffset(1920)]
		[SerializeField]
		internal FixedBytes16Align8 offset1920;

		[FieldOffset(1936)]
		[SerializeField]
		internal FixedBytes16Align8 offset1936;

		[FieldOffset(1952)]
		[SerializeField]
		internal FixedBytes16Align8 offset1952;

		[FieldOffset(1968)]
		[SerializeField]
		internal FixedBytes16Align8 offset1968;

		[FieldOffset(1984)]
		[SerializeField]
		internal FixedBytes16Align8 offset1984;

		[FieldOffset(2000)]
		[SerializeField]
		internal FixedBytes16Align8 offset2000;

		[FieldOffset(2016)]
		[SerializeField]
		internal FixedBytes16Align8 offset2016;

		[FieldOffset(2032)]
		[SerializeField]
		internal FixedBytes16Align8 offset2032;

		[FieldOffset(2048)]
		[SerializeField]
		internal FixedBytes16Align8 offset2048;

		[FieldOffset(2064)]
		[SerializeField]
		internal FixedBytes16Align8 offset2064;

		[FieldOffset(2080)]
		[SerializeField]
		internal FixedBytes16Align8 offset2080;

		[FieldOffset(2096)]
		[SerializeField]
		internal FixedBytes16Align8 offset2096;

		[FieldOffset(2112)]
		[SerializeField]
		internal FixedBytes16Align8 offset2112;

		[FieldOffset(2128)]
		[SerializeField]
		internal FixedBytes16Align8 offset2128;

		[FieldOffset(2144)]
		[SerializeField]
		internal FixedBytes16Align8 offset2144;

		[FieldOffset(2160)]
		[SerializeField]
		internal FixedBytes16Align8 offset2160;

		[FieldOffset(2176)]
		[SerializeField]
		internal FixedBytes16Align8 offset2176;

		[FieldOffset(2192)]
		[SerializeField]
		internal FixedBytes16Align8 offset2192;

		[FieldOffset(2208)]
		[SerializeField]
		internal FixedBytes16Align8 offset2208;

		[FieldOffset(2224)]
		[SerializeField]
		internal FixedBytes16Align8 offset2224;

		[FieldOffset(2240)]
		[SerializeField]
		internal FixedBytes16Align8 offset2240;

		[FieldOffset(2256)]
		[SerializeField]
		internal FixedBytes16Align8 offset2256;

		[FieldOffset(2272)]
		[SerializeField]
		internal FixedBytes16Align8 offset2272;

		[FieldOffset(2288)]
		[SerializeField]
		internal FixedBytes16Align8 offset2288;

		[FieldOffset(2304)]
		[SerializeField]
		internal FixedBytes16Align8 offset2304;

		[FieldOffset(2320)]
		[SerializeField]
		internal FixedBytes16Align8 offset2320;

		[FieldOffset(2336)]
		[SerializeField]
		internal FixedBytes16Align8 offset2336;

		[FieldOffset(2352)]
		[SerializeField]
		internal FixedBytes16Align8 offset2352;

		[FieldOffset(2368)]
		[SerializeField]
		internal FixedBytes16Align8 offset2368;

		[FieldOffset(2384)]
		[SerializeField]
		internal FixedBytes16Align8 offset2384;

		[FieldOffset(2400)]
		[SerializeField]
		internal FixedBytes16Align8 offset2400;

		[FieldOffset(2416)]
		[SerializeField]
		internal FixedBytes16Align8 offset2416;

		[FieldOffset(2432)]
		[SerializeField]
		internal FixedBytes16Align8 offset2432;

		[FieldOffset(2448)]
		[SerializeField]
		internal FixedBytes16Align8 offset2448;

		[FieldOffset(2464)]
		[SerializeField]
		internal FixedBytes16Align8 offset2464;

		[FieldOffset(2480)]
		[SerializeField]
		internal FixedBytes16Align8 offset2480;

		[FieldOffset(2496)]
		[SerializeField]
		internal FixedBytes16Align8 offset2496;

		[FieldOffset(2512)]
		[SerializeField]
		internal FixedBytes16Align8 offset2512;

		[FieldOffset(2528)]
		[SerializeField]
		internal FixedBytes16Align8 offset2528;

		[FieldOffset(2544)]
		[SerializeField]
		internal FixedBytes16Align8 offset2544;

		[FieldOffset(2560)]
		[SerializeField]
		internal FixedBytes16Align8 offset2560;

		[FieldOffset(2576)]
		[SerializeField]
		internal FixedBytes16Align8 offset2576;

		[FieldOffset(2592)]
		[SerializeField]
		internal FixedBytes16Align8 offset2592;

		[FieldOffset(2608)]
		[SerializeField]
		internal FixedBytes16Align8 offset2608;

		[FieldOffset(2624)]
		[SerializeField]
		internal FixedBytes16Align8 offset2624;

		[FieldOffset(2640)]
		[SerializeField]
		internal FixedBytes16Align8 offset2640;

		[FieldOffset(2656)]
		[SerializeField]
		internal FixedBytes16Align8 offset2656;

		[FieldOffset(2672)]
		[SerializeField]
		internal FixedBytes16Align8 offset2672;

		[FieldOffset(2688)]
		[SerializeField]
		internal FixedBytes16Align8 offset2688;

		[FieldOffset(2704)]
		[SerializeField]
		internal FixedBytes16Align8 offset2704;

		[FieldOffset(2720)]
		[SerializeField]
		internal FixedBytes16Align8 offset2720;

		[FieldOffset(2736)]
		[SerializeField]
		internal FixedBytes16Align8 offset2736;

		[FieldOffset(2752)]
		[SerializeField]
		internal FixedBytes16Align8 offset2752;

		[FieldOffset(2768)]
		[SerializeField]
		internal FixedBytes16Align8 offset2768;

		[FieldOffset(2784)]
		[SerializeField]
		internal FixedBytes16Align8 offset2784;

		[FieldOffset(2800)]
		[SerializeField]
		internal FixedBytes16Align8 offset2800;

		[FieldOffset(2816)]
		[SerializeField]
		internal FixedBytes16Align8 offset2816;

		[FieldOffset(2832)]
		[SerializeField]
		internal FixedBytes16Align8 offset2832;

		[FieldOffset(2848)]
		[SerializeField]
		internal FixedBytes16Align8 offset2848;

		[FieldOffset(2864)]
		[SerializeField]
		internal FixedBytes16Align8 offset2864;

		[FieldOffset(2880)]
		[SerializeField]
		internal FixedBytes16Align8 offset2880;

		[FieldOffset(2896)]
		[SerializeField]
		internal FixedBytes16Align8 offset2896;

		[FieldOffset(2912)]
		[SerializeField]
		internal FixedBytes16Align8 offset2912;

		[FieldOffset(2928)]
		[SerializeField]
		internal FixedBytes16Align8 offset2928;

		[FieldOffset(2944)]
		[SerializeField]
		internal FixedBytes16Align8 offset2944;

		[FieldOffset(2960)]
		[SerializeField]
		internal FixedBytes16Align8 offset2960;

		[FieldOffset(2976)]
		[SerializeField]
		internal FixedBytes16Align8 offset2976;

		[FieldOffset(2992)]
		[SerializeField]
		internal FixedBytes16Align8 offset2992;

		[FieldOffset(3008)]
		[SerializeField]
		internal FixedBytes16Align8 offset3008;

		[FieldOffset(3024)]
		[SerializeField]
		internal FixedBytes16Align8 offset3024;

		[FieldOffset(3040)]
		[SerializeField]
		internal FixedBytes16Align8 offset3040;

		[FieldOffset(3056)]
		[SerializeField]
		internal FixedBytes16Align8 offset3056;

		[FieldOffset(3072)]
		[SerializeField]
		internal FixedBytes16Align8 offset3072;

		[FieldOffset(3088)]
		[SerializeField]
		internal FixedBytes16Align8 offset3088;

		[FieldOffset(3104)]
		[SerializeField]
		internal FixedBytes16Align8 offset3104;

		[FieldOffset(3120)]
		[SerializeField]
		internal FixedBytes16Align8 offset3120;

		[FieldOffset(3136)]
		[SerializeField]
		internal FixedBytes16Align8 offset3136;

		[FieldOffset(3152)]
		[SerializeField]
		internal FixedBytes16Align8 offset3152;

		[FieldOffset(3168)]
		[SerializeField]
		internal FixedBytes16Align8 offset3168;

		[FieldOffset(3184)]
		[SerializeField]
		internal FixedBytes16Align8 offset3184;

		[FieldOffset(3200)]
		[SerializeField]
		internal FixedBytes16Align8 offset3200;

		[FieldOffset(3216)]
		[SerializeField]
		internal FixedBytes16Align8 offset3216;

		[FieldOffset(3232)]
		[SerializeField]
		internal FixedBytes16Align8 offset3232;

		[FieldOffset(3248)]
		[SerializeField]
		internal FixedBytes16Align8 offset3248;

		[FieldOffset(3264)]
		[SerializeField]
		internal FixedBytes16Align8 offset3264;

		[FieldOffset(3280)]
		[SerializeField]
		internal FixedBytes16Align8 offset3280;

		[FieldOffset(3296)]
		[SerializeField]
		internal FixedBytes16Align8 offset3296;

		[FieldOffset(3312)]
		[SerializeField]
		internal FixedBytes16Align8 offset3312;

		[FieldOffset(3328)]
		[SerializeField]
		internal FixedBytes16Align8 offset3328;

		[FieldOffset(3344)]
		[SerializeField]
		internal FixedBytes16Align8 offset3344;

		[FieldOffset(3360)]
		[SerializeField]
		internal FixedBytes16Align8 offset3360;

		[FieldOffset(3376)]
		[SerializeField]
		internal FixedBytes16Align8 offset3376;

		[FieldOffset(3392)]
		[SerializeField]
		internal FixedBytes16Align8 offset3392;

		[FieldOffset(3408)]
		[SerializeField]
		internal FixedBytes16Align8 offset3408;

		[FieldOffset(3424)]
		[SerializeField]
		internal FixedBytes16Align8 offset3424;

		[FieldOffset(3440)]
		[SerializeField]
		internal FixedBytes16Align8 offset3440;

		[FieldOffset(3456)]
		[SerializeField]
		internal FixedBytes16Align8 offset3456;

		[FieldOffset(3472)]
		[SerializeField]
		internal FixedBytes16Align8 offset3472;

		[FieldOffset(3488)]
		[SerializeField]
		internal FixedBytes16Align8 offset3488;

		[FieldOffset(3504)]
		[SerializeField]
		internal FixedBytes16Align8 offset3504;

		[FieldOffset(3520)]
		[SerializeField]
		internal FixedBytes16Align8 offset3520;

		[FieldOffset(3536)]
		[SerializeField]
		internal FixedBytes16Align8 offset3536;

		[FieldOffset(3552)]
		[SerializeField]
		internal FixedBytes16Align8 offset3552;

		[FieldOffset(3568)]
		[SerializeField]
		internal FixedBytes16Align8 offset3568;

		[FieldOffset(3584)]
		[SerializeField]
		internal FixedBytes16Align8 offset3584;

		[FieldOffset(3600)]
		[SerializeField]
		internal FixedBytes16Align8 offset3600;

		[FieldOffset(3616)]
		[SerializeField]
		internal FixedBytes16Align8 offset3616;

		[FieldOffset(3632)]
		[SerializeField]
		internal FixedBytes16Align8 offset3632;

		[FieldOffset(3648)]
		[SerializeField]
		internal FixedBytes16Align8 offset3648;

		[FieldOffset(3664)]
		[SerializeField]
		internal FixedBytes16Align8 offset3664;

		[FieldOffset(3680)]
		[SerializeField]
		internal FixedBytes16Align8 offset3680;

		[FieldOffset(3696)]
		[SerializeField]
		internal FixedBytes16Align8 offset3696;

		[FieldOffset(3712)]
		[SerializeField]
		internal FixedBytes16Align8 offset3712;

		[FieldOffset(3728)]
		[SerializeField]
		internal FixedBytes16Align8 offset3728;

		[FieldOffset(3744)]
		[SerializeField]
		internal FixedBytes16Align8 offset3744;

		[FieldOffset(3760)]
		[SerializeField]
		internal FixedBytes16Align8 offset3760;

		[FieldOffset(3776)]
		[SerializeField]
		internal FixedBytes16Align8 offset3776;

		[FieldOffset(3792)]
		[SerializeField]
		internal FixedBytes16Align8 offset3792;

		[FieldOffset(3808)]
		[SerializeField]
		internal FixedBytes16Align8 offset3808;

		[FieldOffset(3824)]
		[SerializeField]
		internal FixedBytes16Align8 offset3824;

		[FieldOffset(3840)]
		[SerializeField]
		internal FixedBytes16Align8 offset3840;

		[FieldOffset(3856)]
		[SerializeField]
		internal FixedBytes16Align8 offset3856;

		[FieldOffset(3872)]
		[SerializeField]
		internal FixedBytes16Align8 offset3872;

		[FieldOffset(3888)]
		[SerializeField]
		internal FixedBytes16Align8 offset3888;

		[FieldOffset(3904)]
		[SerializeField]
		internal FixedBytes16Align8 offset3904;

		[FieldOffset(3920)]
		[SerializeField]
		internal FixedBytes16Align8 offset3920;

		[FieldOffset(3936)]
		[SerializeField]
		internal FixedBytes16Align8 offset3936;

		[FieldOffset(3952)]
		[SerializeField]
		internal FixedBytes16Align8 offset3952;

		[FieldOffset(3968)]
		[SerializeField]
		internal FixedBytes16Align8 offset3968;

		[FieldOffset(3984)]
		[SerializeField]
		internal FixedBytes16Align8 offset3984;

		[FieldOffset(4000)]
		[SerializeField]
		internal FixedBytes16Align8 offset4000;

		[FieldOffset(4016)]
		[SerializeField]
		internal FixedBytes16Align8 offset4016;

		[FieldOffset(4032)]
		[SerializeField]
		internal FixedBytes16Align8 offset4032;

		[FieldOffset(4048)]
		[SerializeField]
		internal FixedBytes16Align8 offset4048;

		[FieldOffset(4064)]
		[SerializeField]
		internal FixedBytes16Align8 offset4064;

		[FieldOffset(4080)]
		[SerializeField]
		internal FixedBytes16Align8 offset4080;
	}
	[Serializable]
	[StructLayout(LayoutKind.Explicit, Size = 30)]
	[GenerateTestsForBurstCompatibility]
	public struct FixedBytes30
	{
		[FieldOffset(0)]
		public FixedBytes16 offset0000;

		[FieldOffset(16)]
		public byte byte0016;

		[FieldOffset(17)]
		public byte byte0017;

		[FieldOffset(18)]
		public byte byte0018;

		[FieldOffset(19)]
		public byte byte0019;

		[FieldOffset(20)]
		public byte byte0020;

		[FieldOffset(21)]
		public byte byte0021;

		[FieldOffset(22)]
		public byte byte0022;

		[FieldOffset(23)]
		public byte byte0023;

		[FieldOffset(24)]
		public byte byte0024;

		[FieldOffset(25)]
		public byte byte0025;

		[FieldOffset(26)]
		public byte byte0026;

		[FieldOffset(27)]
		public byte byte0027;

		[FieldOffset(28)]
		public byte byte0028;

		[FieldOffset(29)]
		public byte byte0029;
	}
	[Serializable]
	[StructLayout(LayoutKind.Sequential, Size = 32)]
	[GenerateTestsForBurstCompatibility]
	public struct FixedString32Bytes : INativeList<byte>, IIndexable<byte>, IUTF8Bytes, IComparable<string>, IEquatable<string>, IComparable<FixedString32Bytes>, IEquatable<FixedString32Bytes>, IComparable<FixedString64Bytes>, IEquatable<FixedString64Bytes>, IComparable<FixedString128Bytes>, IEquatable<FixedString128Bytes>, IComparable<FixedString512Bytes>, IEquatable<FixedString512Bytes>, IComparable<FixedString4096Bytes>, IEquatable<FixedString4096Bytes>
	{
		public struct Enumerator : IEnumerator
		{
			private FixedString32Bytes target;

			private int offset;

			private Unicode.Rune current;

			public Unicode.Rune Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return current;
				}
			}

			object IEnumerator.Current => Current;

			public Enumerator(FixedString32Bytes other)
			{
				target = other;
				offset = 0;
				current = default(Unicode.Rune);
			}

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public unsafe bool MoveNext()
			{
				if (offset >= target.Length)
				{
					return false;
				}
				Unicode.Utf8ToUcs(out current, target.GetUnsafePtr(), ref offset, target.Length);
				return true;
			}

			public void Reset()
			{
				offset = 0;
				current = default(Unicode.Rune);
			}
		}

		internal const ushort utf8MaxLengthInBytes = 29;

		[SerializeField]
		internal ushort utf8LengthInBytes;

		[SerializeField]
		internal FixedBytes30 bytes;

		public static int UTF8MaxLengthInBytes => 29;

		[CreateProperty]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[ExcludeFromBurstCompatTesting("Returns managed string")]
		public string Value => ToString();

		public unsafe int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return utf8LengthInBytes;
			}
			set
			{
				utf8LengthInBytes = (ushort)value;
				GetUnsafePtr()[(int)utf8LengthInBytes] = 0;
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return 29;
			}
			set
			{
			}
		}

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return utf8LengthInBytes == 0;
			}
		}

		public unsafe byte this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return GetUnsafePtr()[index];
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				GetUnsafePtr()[index] = value;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe readonly byte* GetUnsafePtr()
		{
			fixed (FixedBytes30* result = &bytes)
			{
				return (byte*)result;
			}
		}

		public unsafe bool TryResize(int newLength, NativeArrayOptions clearOptions = NativeArrayOptions.ClearMemory)
		{
			if (newLength < 0 || newLength > 29)
			{
				return false;
			}
			if (newLength == utf8LengthInBytes)
			{
				return true;
			}
			if (clearOptions == NativeArrayOptions.ClearMemory)
			{
				if (newLength > utf8LengthInBytes)
				{
					UnsafeUtility.MemClear(GetUnsafePtr() + (int)utf8LengthInBytes, newLength - utf8LengthInBytes);
				}
				else
				{
					UnsafeUtility.MemClear(GetUnsafePtr() + newLength, utf8LengthInBytes - newLength);
				}
			}
			utf8LengthInBytes = (ushort)newLength;
			GetUnsafePtr()[(int)utf8LengthInBytes] = 0;
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe ref byte ElementAt(int index)
		{
			return ref GetUnsafePtr()[index];
		}

		public void Clear()
		{
			Length = 0;
		}

		public void Add(in byte value)
		{
			this[Length++] = value;
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public int CompareTo(string other)
		{
			return ToString().CompareTo(other);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public unsafe bool Equals(string other)
		{
			int num = utf8LengthInBytes;
			int length = other.Length;
			byte* utf8Buffer = (byte*)UnsafeUtilityExtensions.AddressOf(in bytes);
			fixed (char* utf16Buffer = other)
			{
				return UTF8ArrayUnsafeUtility.StrCmp(utf8Buffer, num, utf16Buffer, length) == 0;
			}
		}

		public unsafe ref FixedList32Bytes<byte> AsFixedList()
		{
			return ref UnsafeUtility.AsRef<FixedList32Bytes<byte>>(UnsafeUtility.AddressOf(ref this));
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public FixedString32Bytes(string source)
		{
			this = default(FixedString32Bytes);
			Initialize(source);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		internal CopyError Initialize(string source)
		{
			return FixedStringMethods.CopyFromTruncated(ref this, source);
		}

		public FixedString32Bytes(Unicode.Rune rune, int count = 1)
		{
			this = default(FixedString32Bytes);
			Initialize(rune, count);
		}

		internal FormatError Initialize(Unicode.Rune rune, int count = 1)
		{
			this = default(FixedString32Bytes);
			return FixedStringMethods.Append(ref this, rune, count);
		}

		internal unsafe FormatError Initialize(byte* srcBytes, int srcLength)
		{
			bytes = default(FixedBytes30);
			utf8LengthInBytes = 0;
			int destLength = 0;
			FormatError formatError = UTF8ArrayUnsafeUtility.AppendUTF8Bytes(GetUnsafePtr(), ref destLength, 29, srcBytes, srcLength);
			if (formatError != FormatError.None)
			{
				return formatError;
			}
			Length = destLength;
			return FormatError.None;
		}

		public unsafe FixedString32Bytes(NativeText.ReadOnly other)
		{
			this = default(FixedString32Bytes);
			Initialize(other.GetUnsafePtr(), other.Length);
		}

		public unsafe FixedString32Bytes(in UnsafeText other)
		{
			this = default(FixedString32Bytes);
			Initialize(other.GetUnsafePtr(), other.Length);
		}

		public int CompareTo(FixedString32Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString32Bytes(in FixedString32Bytes other)
		{
			this = default(FixedString32Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString32Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString32Bytes a, in FixedString32Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString32Bytes a, in FixedString32Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString32Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString64Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString32Bytes(in FixedString64Bytes other)
		{
			this = default(FixedString32Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString64Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString32Bytes a, in FixedString64Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString32Bytes a, in FixedString64Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString64Bytes other)
		{
			return this == other;
		}

		public static implicit operator FixedString64Bytes(in FixedString32Bytes fs)
		{
			return new FixedString64Bytes(in fs);
		}

		public int CompareTo(FixedString128Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString32Bytes(in FixedString128Bytes other)
		{
			this = default(FixedString32Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString128Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString32Bytes a, in FixedString128Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString32Bytes a, in FixedString128Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString128Bytes other)
		{
			return this == other;
		}

		public static implicit operator FixedString128Bytes(in FixedString32Bytes fs)
		{
			return new FixedString128Bytes(in fs);
		}

		public int CompareTo(FixedString512Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString32Bytes(in FixedString512Bytes other)
		{
			this = default(FixedString32Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString512Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString32Bytes a, in FixedString512Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString32Bytes a, in FixedString512Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString512Bytes other)
		{
			return this == other;
		}

		public static implicit operator FixedString512Bytes(in FixedString32Bytes fs)
		{
			return new FixedString512Bytes(in fs);
		}

		public int CompareTo(FixedString4096Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString32Bytes(in FixedString4096Bytes other)
		{
			this = default(FixedString32Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString4096Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString32Bytes a, in FixedString4096Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString32Bytes a, in FixedString4096Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString4096Bytes other)
		{
			return this == other;
		}

		public static implicit operator FixedString4096Bytes(in FixedString32Bytes fs)
		{
			return new FixedString4096Bytes(in fs);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static implicit operator FixedString32Bytes(string b)
		{
			return new FixedString32Bytes(b);
		}

		[ExcludeFromBurstCompatTesting("Returns managed string")]
		public override string ToString()
		{
			return FixedStringMethods.ConvertToString(ref this);
		}

		public override int GetHashCode()
		{
			return FixedStringMethods.ComputeHashCode(ref this);
		}

		[ExcludeFromBurstCompatTesting("Takes managed object")]
		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is string other)
			{
				return Equals(other);
			}
			if (obj is FixedString32Bytes other2)
			{
				return Equals(other2);
			}
			if (obj is FixedString64Bytes other3)
			{
				return Equals(other3);
			}
			if (obj is FixedString128Bytes other4)
			{
				return Equals(other4);
			}
			if (obj is FixedString512Bytes other5)
			{
				return Equals(other5);
			}
			if (obj is FixedString4096Bytes other6)
			{
				return Equals(other6);
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private readonly void CheckIndexInRange(int index)
		{
			if (index < 0)
			{
				throw new IndexOutOfRangeException($"Index {index} must be positive.");
			}
			if (index >= utf8LengthInBytes)
			{
				throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString32Bytes of '{utf8LengthInBytes}' Length.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckLengthInRange(int length)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
			}
			if (length > 29)
			{
				throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString32Bytes of '{(ushort)29}' Capacity.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckCapacityInRange(int capacity)
		{
			if (capacity > 29)
			{
				throw new ArgumentOutOfRangeException($"Capacity {capacity} must be lower than {(ushort)29}.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckCopyError(CopyError error, string source)
		{
			if (error != CopyError.None)
			{
				throw new ArgumentException($"FixedString32Bytes: {error} while copying \"{source}\"");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckFormatError(FormatError error)
		{
			if (error != FormatError.None)
			{
				throw new ArgumentException("Source is too long to fit into fixed string of this size");
			}
		}
	}
	[Serializable]
	[StructLayout(LayoutKind.Explicit, Size = 62)]
	[GenerateTestsForBurstCompatibility]
	public struct FixedBytes62
	{
		[FieldOffset(0)]
		public FixedBytes16 offset0000;

		[FieldOffset(16)]
		public FixedBytes16 offset0016;

		[FieldOffset(32)]
		public FixedBytes16 offset0032;

		[FieldOffset(48)]
		public byte byte0048;

		[FieldOffset(49)]
		public byte byte0049;

		[FieldOffset(50)]
		public byte byte0050;

		[FieldOffset(51)]
		public byte byte0051;

		[FieldOffset(52)]
		public byte byte0052;

		[FieldOffset(53)]
		public byte byte0053;

		[FieldOffset(54)]
		public byte byte0054;

		[FieldOffset(55)]
		public byte byte0055;

		[FieldOffset(56)]
		public byte byte0056;

		[FieldOffset(57)]
		public byte byte0057;

		[FieldOffset(58)]
		public byte byte0058;

		[FieldOffset(59)]
		public byte byte0059;

		[FieldOffset(60)]
		public byte byte0060;

		[FieldOffset(61)]
		public byte byte0061;
	}
	[Serializable]
	[StructLayout(LayoutKind.Sequential, Size = 64)]
	[GenerateTestsForBurstCompatibility]
	public struct FixedString64Bytes : INativeList<byte>, IIndexable<byte>, IUTF8Bytes, IComparable<string>, IEquatable<string>, IComparable<FixedString32Bytes>, IEquatable<FixedString32Bytes>, IComparable<FixedString64Bytes>, IEquatable<FixedString64Bytes>, IComparable<FixedString128Bytes>, IEquatable<FixedString128Bytes>, IComparable<FixedString512Bytes>, IEquatable<FixedString512Bytes>, IComparable<FixedString4096Bytes>, IEquatable<FixedString4096Bytes>
	{
		public struct Enumerator : IEnumerator
		{
			private FixedString64Bytes target;

			private int offset;

			private Unicode.Rune current;

			public Unicode.Rune Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return current;
				}
			}

			object IEnumerator.Current => Current;

			public Enumerator(FixedString64Bytes other)
			{
				target = other;
				offset = 0;
				current = default(Unicode.Rune);
			}

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public unsafe bool MoveNext()
			{
				if (offset >= target.Length)
				{
					return false;
				}
				Unicode.Utf8ToUcs(out current, target.GetUnsafePtr(), ref offset, target.Length);
				return true;
			}

			public void Reset()
			{
				offset = 0;
				current = default(Unicode.Rune);
			}
		}

		internal const ushort utf8MaxLengthInBytes = 61;

		[SerializeField]
		internal ushort utf8LengthInBytes;

		[SerializeField]
		internal FixedBytes62 bytes;

		public static int UTF8MaxLengthInBytes => 61;

		[CreateProperty]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[ExcludeFromBurstCompatTesting("Returns managed string")]
		public string Value => ToString();

		public unsafe int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return utf8LengthInBytes;
			}
			set
			{
				utf8LengthInBytes = (ushort)value;
				GetUnsafePtr()[(int)utf8LengthInBytes] = 0;
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return 61;
			}
			set
			{
			}
		}

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return utf8LengthInBytes == 0;
			}
		}

		public unsafe byte this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return GetUnsafePtr()[index];
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				GetUnsafePtr()[index] = value;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe readonly byte* GetUnsafePtr()
		{
			fixed (FixedBytes62* result = &bytes)
			{
				return (byte*)result;
			}
		}

		public unsafe bool TryResize(int newLength, NativeArrayOptions clearOptions = NativeArrayOptions.ClearMemory)
		{
			if (newLength < 0 || newLength > 61)
			{
				return false;
			}
			if (newLength == utf8LengthInBytes)
			{
				return true;
			}
			if (clearOptions == NativeArrayOptions.ClearMemory)
			{
				if (newLength > utf8LengthInBytes)
				{
					UnsafeUtility.MemClear(GetUnsafePtr() + (int)utf8LengthInBytes, newLength - utf8LengthInBytes);
				}
				else
				{
					UnsafeUtility.MemClear(GetUnsafePtr() + newLength, utf8LengthInBytes - newLength);
				}
			}
			utf8LengthInBytes = (ushort)newLength;
			GetUnsafePtr()[(int)utf8LengthInBytes] = 0;
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe ref byte ElementAt(int index)
		{
			return ref GetUnsafePtr()[index];
		}

		public void Clear()
		{
			Length = 0;
		}

		public void Add(in byte value)
		{
			this[Length++] = value;
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public int CompareTo(string other)
		{
			return ToString().CompareTo(other);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public unsafe bool Equals(string other)
		{
			int num = utf8LengthInBytes;
			int length = other.Length;
			byte* utf8Buffer = (byte*)UnsafeUtilityExtensions.AddressOf(in bytes);
			fixed (char* utf16Buffer = other)
			{
				return UTF8ArrayUnsafeUtility.StrCmp(utf8Buffer, num, utf16Buffer, length) == 0;
			}
		}

		public unsafe ref FixedList64Bytes<byte> AsFixedList()
		{
			return ref UnsafeUtility.AsRef<FixedList64Bytes<byte>>(UnsafeUtility.AddressOf(ref this));
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public FixedString64Bytes(string source)
		{
			this = default(FixedString64Bytes);
			Initialize(source);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		internal CopyError Initialize(string source)
		{
			return FixedStringMethods.CopyFromTruncated(ref this, source);
		}

		public FixedString64Bytes(Unicode.Rune rune, int count = 1)
		{
			this = default(FixedString64Bytes);
			Initialize(rune, count);
		}

		internal FormatError Initialize(Unicode.Rune rune, int count = 1)
		{
			this = default(FixedString64Bytes);
			return FixedStringMethods.Append(ref this, rune, count);
		}

		internal unsafe FormatError Initialize(byte* srcBytes, int srcLength)
		{
			bytes = default(FixedBytes62);
			utf8LengthInBytes = 0;
			int destLength = 0;
			FormatError formatError = UTF8ArrayUnsafeUtility.AppendUTF8Bytes(GetUnsafePtr(), ref destLength, 61, srcBytes, srcLength);
			if (formatError != FormatError.None)
			{
				return formatError;
			}
			Length = destLength;
			return FormatError.None;
		}

		public unsafe FixedString64Bytes(NativeText.ReadOnly other)
		{
			this = default(FixedString64Bytes);
			Initialize(other.GetUnsafePtr(), other.Length);
		}

		public unsafe FixedString64Bytes(in UnsafeText other)
		{
			this = default(FixedString64Bytes);
			Initialize(other.GetUnsafePtr(), other.Length);
		}

		public int CompareTo(FixedString32Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString64Bytes(in FixedString32Bytes other)
		{
			this = default(FixedString64Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString32Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString64Bytes a, in FixedString32Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString64Bytes a, in FixedString32Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString32Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString64Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString64Bytes(in FixedString64Bytes other)
		{
			this = default(FixedString64Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString64Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString64Bytes a, in FixedString64Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString64Bytes a, in FixedString64Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString64Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString128Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString64Bytes(in FixedString128Bytes other)
		{
			this = default(FixedString64Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString128Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString64Bytes a, in FixedString128Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString64Bytes a, in FixedString128Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString128Bytes other)
		{
			return this == other;
		}

		public static implicit operator FixedString128Bytes(in FixedString64Bytes fs)
		{
			return new FixedString128Bytes(in fs);
		}

		public int CompareTo(FixedString512Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString64Bytes(in FixedString512Bytes other)
		{
			this = default(FixedString64Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString512Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString64Bytes a, in FixedString512Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString64Bytes a, in FixedString512Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString512Bytes other)
		{
			return this == other;
		}

		public static implicit operator FixedString512Bytes(in FixedString64Bytes fs)
		{
			return new FixedString512Bytes(in fs);
		}

		public int CompareTo(FixedString4096Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString64Bytes(in FixedString4096Bytes other)
		{
			this = default(FixedString64Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString4096Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString64Bytes a, in FixedString4096Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString64Bytes a, in FixedString4096Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString4096Bytes other)
		{
			return this == other;
		}

		public static implicit operator FixedString4096Bytes(in FixedString64Bytes fs)
		{
			return new FixedString4096Bytes(in fs);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static implicit operator FixedString64Bytes(string b)
		{
			return new FixedString64Bytes(b);
		}

		[ExcludeFromBurstCompatTesting("Returns managed string")]
		public override string ToString()
		{
			return FixedStringMethods.ConvertToString(ref this);
		}

		public override int GetHashCode()
		{
			return FixedStringMethods.ComputeHashCode(ref this);
		}

		[ExcludeFromBurstCompatTesting("Takes managed object")]
		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is string other)
			{
				return Equals(other);
			}
			if (obj is FixedString32Bytes other2)
			{
				return Equals(other2);
			}
			if (obj is FixedString64Bytes other3)
			{
				return Equals(other3);
			}
			if (obj is FixedString128Bytes other4)
			{
				return Equals(other4);
			}
			if (obj is FixedString512Bytes other5)
			{
				return Equals(other5);
			}
			if (obj is FixedString4096Bytes other6)
			{
				return Equals(other6);
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private readonly void CheckIndexInRange(int index)
		{
			if (index < 0)
			{
				throw new IndexOutOfRangeException($"Index {index} must be positive.");
			}
			if (index >= utf8LengthInBytes)
			{
				throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString64Bytes of '{utf8LengthInBytes}' Length.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckLengthInRange(int length)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
			}
			if (length > 61)
			{
				throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString64Bytes of '{(ushort)61}' Capacity.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckCapacityInRange(int capacity)
		{
			if (capacity > 61)
			{
				throw new ArgumentOutOfRangeException($"Capacity {capacity} must be lower than {(ushort)61}.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckCopyError(CopyError error, string source)
		{
			if (error != CopyError.None)
			{
				throw new ArgumentException($"FixedString64Bytes: {error} while copying \"{source}\"");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckFormatError(FormatError error)
		{
			if (error != FormatError.None)
			{
				throw new ArgumentException("Source is too long to fit into fixed string of this size");
			}
		}
	}
	[Serializable]
	[StructLayout(LayoutKind.Explicit, Size = 126)]
	[GenerateTestsForBurstCompatibility]
	public struct FixedBytes126
	{
		[FieldOffset(0)]
		public FixedBytes16 offset0000;

		[FieldOffset(16)]
		public FixedBytes16 offset0016;

		[FieldOffset(32)]
		public FixedBytes16 offset0032;

		[FieldOffset(48)]
		public FixedBytes16 offset0048;

		[FieldOffset(64)]
		public FixedBytes16 offset0064;

		[FieldOffset(80)]
		public FixedBytes16 offset0080;

		[FieldOffset(96)]
		public FixedBytes16 offset0096;

		[FieldOffset(112)]
		public byte byte0112;

		[FieldOffset(113)]
		public byte byte0113;

		[FieldOffset(114)]
		public byte byte0114;

		[FieldOffset(115)]
		public byte byte0115;

		[FieldOffset(116)]
		public byte byte0116;

		[FieldOffset(117)]
		public byte byte0117;

		[FieldOffset(118)]
		public byte byte0118;

		[FieldOffset(119)]
		public byte byte0119;

		[FieldOffset(120)]
		public byte byte0120;

		[FieldOffset(121)]
		public byte byte0121;

		[FieldOffset(122)]
		public byte byte0122;

		[FieldOffset(123)]
		public byte byte0123;

		[FieldOffset(124)]
		public byte byte0124;

		[FieldOffset(125)]
		public byte byte0125;
	}
	[Serializable]
	[StructLayout(LayoutKind.Sequential, Size = 128)]
	[GenerateTestsForBurstCompatibility]
	public struct FixedString128Bytes : INativeList<byte>, IIndexable<byte>, IUTF8Bytes, IComparable<string>, IEquatable<string>, IComparable<FixedString32Bytes>, IEquatable<FixedString32Bytes>, IComparable<FixedString64Bytes>, IEquatable<FixedString64Bytes>, IComparable<FixedString128Bytes>, IEquatable<FixedString128Bytes>, IComparable<FixedString512Bytes>, IEquatable<FixedString512Bytes>, IComparable<FixedString4096Bytes>, IEquatable<FixedString4096Bytes>
	{
		public struct Enumerator : IEnumerator
		{
			private FixedString128Bytes target;

			private int offset;

			private Unicode.Rune current;

			public Unicode.Rune Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return current;
				}
			}

			object IEnumerator.Current => Current;

			public Enumerator(FixedString128Bytes other)
			{
				target = other;
				offset = 0;
				current = default(Unicode.Rune);
			}

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public unsafe bool MoveNext()
			{
				if (offset >= target.Length)
				{
					return false;
				}
				Unicode.Utf8ToUcs(out current, target.GetUnsafePtr(), ref offset, target.Length);
				return true;
			}

			public void Reset()
			{
				offset = 0;
				current = default(Unicode.Rune);
			}
		}

		internal const ushort utf8MaxLengthInBytes = 125;

		[SerializeField]
		internal ushort utf8LengthInBytes;

		[SerializeField]
		internal FixedBytes126 bytes;

		public static int UTF8MaxLengthInBytes => 125;

		[CreateProperty]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[ExcludeFromBurstCompatTesting("Returns managed string")]
		public string Value => ToString();

		public unsafe int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return utf8LengthInBytes;
			}
			set
			{
				utf8LengthInBytes = (ushort)value;
				GetUnsafePtr()[(int)utf8LengthInBytes] = 0;
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return 125;
			}
			set
			{
			}
		}

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return utf8LengthInBytes == 0;
			}
		}

		public unsafe byte this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return GetUnsafePtr()[index];
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				GetUnsafePtr()[index] = value;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe readonly byte* GetUnsafePtr()
		{
			fixed (FixedBytes126* result = &bytes)
			{
				return (byte*)result;
			}
		}

		public unsafe bool TryResize(int newLength, NativeArrayOptions clearOptions = NativeArrayOptions.ClearMemory)
		{
			if (newLength < 0 || newLength > 125)
			{
				return false;
			}
			if (newLength == utf8LengthInBytes)
			{
				return true;
			}
			if (clearOptions == NativeArrayOptions.ClearMemory)
			{
				if (newLength > utf8LengthInBytes)
				{
					UnsafeUtility.MemClear(GetUnsafePtr() + (int)utf8LengthInBytes, newLength - utf8LengthInBytes);
				}
				else
				{
					UnsafeUtility.MemClear(GetUnsafePtr() + newLength, utf8LengthInBytes - newLength);
				}
			}
			utf8LengthInBytes = (ushort)newLength;
			GetUnsafePtr()[(int)utf8LengthInBytes] = 0;
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe ref byte ElementAt(int index)
		{
			return ref GetUnsafePtr()[index];
		}

		public void Clear()
		{
			Length = 0;
		}

		public void Add(in byte value)
		{
			this[Length++] = value;
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public int CompareTo(string other)
		{
			return ToString().CompareTo(other);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public unsafe bool Equals(string other)
		{
			int num = utf8LengthInBytes;
			int length = other.Length;
			byte* utf8Buffer = (byte*)UnsafeUtilityExtensions.AddressOf(in bytes);
			fixed (char* utf16Buffer = other)
			{
				return UTF8ArrayUnsafeUtility.StrCmp(utf8Buffer, num, utf16Buffer, length) == 0;
			}
		}

		public unsafe ref FixedList128Bytes<byte> AsFixedList()
		{
			return ref UnsafeUtility.AsRef<FixedList128Bytes<byte>>(UnsafeUtility.AddressOf(ref this));
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public FixedString128Bytes(string source)
		{
			this = default(FixedString128Bytes);
			Initialize(source);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		internal CopyError Initialize(string source)
		{
			return FixedStringMethods.CopyFromTruncated(ref this, source);
		}

		public FixedString128Bytes(Unicode.Rune rune, int count = 1)
		{
			this = default(FixedString128Bytes);
			Initialize(rune, count);
		}

		internal FormatError Initialize(Unicode.Rune rune, int count = 1)
		{
			this = default(FixedString128Bytes);
			return FixedStringMethods.Append(ref this, rune, count);
		}

		internal unsafe FormatError Initialize(byte* srcBytes, int srcLength)
		{
			bytes = default(FixedBytes126);
			utf8LengthInBytes = 0;
			int destLength = 0;
			FormatError formatError = UTF8ArrayUnsafeUtility.AppendUTF8Bytes(GetUnsafePtr(), ref destLength, 125, srcBytes, srcLength);
			if (formatError != FormatError.None)
			{
				return formatError;
			}
			Length = destLength;
			return FormatError.None;
		}

		public unsafe FixedString128Bytes(NativeText.ReadOnly other)
		{
			this = default(FixedString128Bytes);
			Initialize(other.GetUnsafePtr(), other.Length);
		}

		public unsafe FixedString128Bytes(in UnsafeText other)
		{
			this = default(FixedString128Bytes);
			Initialize(other.GetUnsafePtr(), other.Length);
		}

		public int CompareTo(FixedString32Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString128Bytes(in FixedString32Bytes other)
		{
			this = default(FixedString128Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString32Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString128Bytes a, in FixedString32Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString128Bytes a, in FixedString32Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString32Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString64Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString128Bytes(in FixedString64Bytes other)
		{
			this = default(FixedString128Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString64Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString128Bytes a, in FixedString64Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString128Bytes a, in FixedString64Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString64Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString128Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString128Bytes(in FixedString128Bytes other)
		{
			this = default(FixedString128Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString128Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString128Bytes a, in FixedString128Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString128Bytes a, in FixedString128Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString128Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString512Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString128Bytes(in FixedString512Bytes other)
		{
			this = default(FixedString128Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString512Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString128Bytes a, in FixedString512Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString128Bytes a, in FixedString512Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString512Bytes other)
		{
			return this == other;
		}

		public static implicit operator FixedString512Bytes(in FixedString128Bytes fs)
		{
			return new FixedString512Bytes(in fs);
		}

		public int CompareTo(FixedString4096Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString128Bytes(in FixedString4096Bytes other)
		{
			this = default(FixedString128Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString4096Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString128Bytes a, in FixedString4096Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString128Bytes a, in FixedString4096Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString4096Bytes other)
		{
			return this == other;
		}

		public static implicit operator FixedString4096Bytes(in FixedString128Bytes fs)
		{
			return new FixedString4096Bytes(in fs);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static implicit operator FixedString128Bytes(string b)
		{
			return new FixedString128Bytes(b);
		}

		[ExcludeFromBurstCompatTesting("Returns managed string")]
		public override string ToString()
		{
			return FixedStringMethods.ConvertToString(ref this);
		}

		public override int GetHashCode()
		{
			return FixedStringMethods.ComputeHashCode(ref this);
		}

		[ExcludeFromBurstCompatTesting("Takes managed object")]
		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is string other)
			{
				return Equals(other);
			}
			if (obj is FixedString32Bytes other2)
			{
				return Equals(other2);
			}
			if (obj is FixedString64Bytes other3)
			{
				return Equals(other3);
			}
			if (obj is FixedString128Bytes other4)
			{
				return Equals(other4);
			}
			if (obj is FixedString512Bytes other5)
			{
				return Equals(other5);
			}
			if (obj is FixedString4096Bytes other6)
			{
				return Equals(other6);
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private readonly void CheckIndexInRange(int index)
		{
			if (index < 0)
			{
				throw new IndexOutOfRangeException($"Index {index} must be positive.");
			}
			if (index >= utf8LengthInBytes)
			{
				throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString128Bytes of '{utf8LengthInBytes}' Length.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckLengthInRange(int length)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
			}
			if (length > 125)
			{
				throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString128Bytes of '{(ushort)125}' Capacity.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckCapacityInRange(int capacity)
		{
			if (capacity > 125)
			{
				throw new ArgumentOutOfRangeException($"Capacity {capacity} must be lower than {(ushort)125}.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckCopyError(CopyError error, string source)
		{
			if (error != CopyError.None)
			{
				throw new ArgumentException($"FixedString128Bytes: {error} while copying \"{source}\"");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckFormatError(FormatError error)
		{
			if (error != FormatError.None)
			{
				throw new ArgumentException("Source is too long to fit into fixed string of this size");
			}
		}
	}
	[Serializable]
	[StructLayout(LayoutKind.Explicit, Size = 510)]
	[GenerateTestsForBurstCompatibility]
	public struct FixedBytes510
	{
		[FieldOffset(0)]
		public FixedBytes16 offset0000;

		[FieldOffset(16)]
		public FixedBytes16 offset0016;

		[FieldOffset(32)]
		public FixedBytes16 offset0032;

		[FieldOffset(48)]
		public FixedBytes16 offset0048;

		[FieldOffset(64)]
		public FixedBytes16 offset0064;

		[FieldOffset(80)]
		public FixedBytes16 offset0080;

		[FieldOffset(96)]
		public FixedBytes16 offset0096;

		[FieldOffset(112)]
		public FixedBytes16 offset0112;

		[FieldOffset(128)]
		public FixedBytes16 offset0128;

		[FieldOffset(144)]
		public FixedBytes16 offset0144;

		[FieldOffset(160)]
		public FixedBytes16 offset0160;

		[FieldOffset(176)]
		public FixedBytes16 offset0176;

		[FieldOffset(192)]
		public FixedBytes16 offset0192;

		[FieldOffset(208)]
		public FixedBytes16 offset0208;

		[FieldOffset(224)]
		public FixedBytes16 offset0224;

		[FieldOffset(240)]
		public FixedBytes16 offset0240;

		[FieldOffset(256)]
		public FixedBytes16 offset0256;

		[FieldOffset(272)]
		public FixedBytes16 offset0272;

		[FieldOffset(288)]
		public FixedBytes16 offset0288;

		[FieldOffset(304)]
		public FixedBytes16 offset0304;

		[FieldOffset(320)]
		public FixedBytes16 offset0320;

		[FieldOffset(336)]
		public FixedBytes16 offset0336;

		[FieldOffset(352)]
		public FixedBytes16 offset0352;

		[FieldOffset(368)]
		public FixedBytes16 offset0368;

		[FieldOffset(384)]
		public FixedBytes16 offset0384;

		[FieldOffset(400)]
		public FixedBytes16 offset0400;

		[FieldOffset(416)]
		public FixedBytes16 offset0416;

		[FieldOffset(432)]
		public FixedBytes16 offset0432;

		[FieldOffset(448)]
		public FixedBytes16 offset0448;

		[FieldOffset(464)]
		public FixedBytes16 offset0464;

		[FieldOffset(480)]
		public FixedBytes16 offset0480;

		[FieldOffset(496)]
		public byte byte0496;

		[FieldOffset(497)]
		public byte byte0497;

		[FieldOffset(498)]
		public byte byte0498;

		[FieldOffset(499)]
		public byte byte0499;

		[FieldOffset(500)]
		public byte byte0500;

		[FieldOffset(501)]
		public byte byte0501;

		[FieldOffset(502)]
		public byte byte0502;

		[FieldOffset(503)]
		public byte byte0503;

		[FieldOffset(504)]
		public byte byte0504;

		[FieldOffset(505)]
		public byte byte0505;

		[FieldOffset(506)]
		public byte byte0506;

		[FieldOffset(507)]
		public byte byte0507;

		[FieldOffset(508)]
		public byte byte0508;

		[FieldOffset(509)]
		public byte byte0509;
	}
	[Serializable]
	[StructLayout(LayoutKind.Sequential, Size = 512)]
	[GenerateTestsForBurstCompatibility]
	public struct FixedString512Bytes : INativeList<byte>, IIndexable<byte>, IUTF8Bytes, IComparable<string>, IEquatable<string>, IComparable<FixedString32Bytes>, IEquatable<FixedString32Bytes>, IComparable<FixedString64Bytes>, IEquatable<FixedString64Bytes>, IComparable<FixedString128Bytes>, IEquatable<FixedString128Bytes>, IComparable<FixedString512Bytes>, IEquatable<FixedString512Bytes>, IComparable<FixedString4096Bytes>, IEquatable<FixedString4096Bytes>
	{
		public struct Enumerator : IEnumerator
		{
			private FixedString512Bytes target;

			private int offset;

			private Unicode.Rune current;

			public Unicode.Rune Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return current;
				}
			}

			object IEnumerator.Current => Current;

			public Enumerator(FixedString512Bytes other)
			{
				target = other;
				offset = 0;
				current = default(Unicode.Rune);
			}

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public unsafe bool MoveNext()
			{
				if (offset >= target.Length)
				{
					return false;
				}
				Unicode.Utf8ToUcs(out current, target.GetUnsafePtr(), ref offset, target.Length);
				return true;
			}

			public void Reset()
			{
				offset = 0;
				current = default(Unicode.Rune);
			}
		}

		internal const ushort utf8MaxLengthInBytes = 509;

		[SerializeField]
		internal ushort utf8LengthInBytes;

		[SerializeField]
		internal FixedBytes510 bytes;

		public static int UTF8MaxLengthInBytes => 509;

		[CreateProperty]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[ExcludeFromBurstCompatTesting("Returns managed string")]
		public string Value => ToString();

		public unsafe int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return utf8LengthInBytes;
			}
			set
			{
				utf8LengthInBytes = (ushort)value;
				GetUnsafePtr()[(int)utf8LengthInBytes] = 0;
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return 509;
			}
			set
			{
			}
		}

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return utf8LengthInBytes == 0;
			}
		}

		public unsafe byte this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return GetUnsafePtr()[index];
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				GetUnsafePtr()[index] = value;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe readonly byte* GetUnsafePtr()
		{
			fixed (FixedBytes510* result = &bytes)
			{
				return (byte*)result;
			}
		}

		public unsafe bool TryResize(int newLength, NativeArrayOptions clearOptions = NativeArrayOptions.ClearMemory)
		{
			if (newLength < 0 || newLength > 509)
			{
				return false;
			}
			if (newLength == utf8LengthInBytes)
			{
				return true;
			}
			if (clearOptions == NativeArrayOptions.ClearMemory)
			{
				if (newLength > utf8LengthInBytes)
				{
					UnsafeUtility.MemClear(GetUnsafePtr() + (int)utf8LengthInBytes, newLength - utf8LengthInBytes);
				}
				else
				{
					UnsafeUtility.MemClear(GetUnsafePtr() + newLength, utf8LengthInBytes - newLength);
				}
			}
			utf8LengthInBytes = (ushort)newLength;
			GetUnsafePtr()[(int)utf8LengthInBytes] = 0;
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe ref byte ElementAt(int index)
		{
			return ref GetUnsafePtr()[index];
		}

		public void Clear()
		{
			Length = 0;
		}

		public void Add(in byte value)
		{
			this[Length++] = value;
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public int CompareTo(string other)
		{
			return ToString().CompareTo(other);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public unsafe bool Equals(string other)
		{
			int num = utf8LengthInBytes;
			int length = other.Length;
			byte* utf8Buffer = (byte*)UnsafeUtilityExtensions.AddressOf(in bytes);
			fixed (char* utf16Buffer = other)
			{
				return UTF8ArrayUnsafeUtility.StrCmp(utf8Buffer, num, utf16Buffer, length) == 0;
			}
		}

		public unsafe ref FixedList512Bytes<byte> AsFixedList()
		{
			return ref UnsafeUtility.AsRef<FixedList512Bytes<byte>>(UnsafeUtility.AddressOf(ref this));
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public FixedString512Bytes(string source)
		{
			this = default(FixedString512Bytes);
			Initialize(source);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		internal CopyError Initialize(string source)
		{
			return FixedStringMethods.CopyFromTruncated(ref this, source);
		}

		public FixedString512Bytes(Unicode.Rune rune, int count = 1)
		{
			this = default(FixedString512Bytes);
			Initialize(rune, count);
		}

		internal FormatError Initialize(Unicode.Rune rune, int count = 1)
		{
			this = default(FixedString512Bytes);
			return FixedStringMethods.Append(ref this, rune, count);
		}

		internal unsafe FormatError Initialize(byte* srcBytes, int srcLength)
		{
			bytes = default(FixedBytes510);
			utf8LengthInBytes = 0;
			int destLength = 0;
			FormatError formatError = UTF8ArrayUnsafeUtility.AppendUTF8Bytes(GetUnsafePtr(), ref destLength, 509, srcBytes, srcLength);
			if (formatError != FormatError.None)
			{
				return formatError;
			}
			Length = destLength;
			return FormatError.None;
		}

		public unsafe FixedString512Bytes(NativeText.ReadOnly other)
		{
			this = default(FixedString512Bytes);
			Initialize(other.GetUnsafePtr(), other.Length);
		}

		public unsafe FixedString512Bytes(in UnsafeText other)
		{
			this = default(FixedString512Bytes);
			Initialize(other.GetUnsafePtr(), other.Length);
		}

		public int CompareTo(FixedString32Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString512Bytes(in FixedString32Bytes other)
		{
			this = default(FixedString512Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString32Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString512Bytes a, in FixedString32Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString512Bytes a, in FixedString32Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString32Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString64Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString512Bytes(in FixedString64Bytes other)
		{
			this = default(FixedString512Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString64Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString512Bytes a, in FixedString64Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString512Bytes a, in FixedString64Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString64Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString128Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString512Bytes(in FixedString128Bytes other)
		{
			this = default(FixedString512Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString128Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString512Bytes a, in FixedString128Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString512Bytes a, in FixedString128Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString128Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString512Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString512Bytes(in FixedString512Bytes other)
		{
			this = default(FixedString512Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString512Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString512Bytes a, in FixedString512Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString512Bytes a, in FixedString512Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString512Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString4096Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString512Bytes(in FixedString4096Bytes other)
		{
			this = default(FixedString512Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString4096Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString512Bytes a, in FixedString4096Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString512Bytes a, in FixedString4096Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString4096Bytes other)
		{
			return this == other;
		}

		public static implicit operator FixedString4096Bytes(in FixedString512Bytes fs)
		{
			return new FixedString4096Bytes(in fs);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static implicit operator FixedString512Bytes(string b)
		{
			return new FixedString512Bytes(b);
		}

		[ExcludeFromBurstCompatTesting("Returns managed string")]
		public override string ToString()
		{
			return FixedStringMethods.ConvertToString(ref this);
		}

		public override int GetHashCode()
		{
			return FixedStringMethods.ComputeHashCode(ref this);
		}

		[ExcludeFromBurstCompatTesting("Takes managed object")]
		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is string other)
			{
				return Equals(other);
			}
			if (obj is FixedString32Bytes other2)
			{
				return Equals(other2);
			}
			if (obj is FixedString64Bytes other3)
			{
				return Equals(other3);
			}
			if (obj is FixedString128Bytes other4)
			{
				return Equals(other4);
			}
			if (obj is FixedString512Bytes other5)
			{
				return Equals(other5);
			}
			if (obj is FixedString4096Bytes other6)
			{
				return Equals(other6);
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private readonly void CheckIndexInRange(int index)
		{
			if (index < 0)
			{
				throw new IndexOutOfRangeException($"Index {index} must be positive.");
			}
			if (index >= utf8LengthInBytes)
			{
				throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString512Bytes of '{utf8LengthInBytes}' Length.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckLengthInRange(int length)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
			}
			if (length > 509)
			{
				throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString512Bytes of '{(ushort)509}' Capacity.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckCapacityInRange(int capacity)
		{
			if (capacity > 509)
			{
				throw new ArgumentOutOfRangeException($"Capacity {capacity} must be lower than {(ushort)509}.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckCopyError(CopyError error, string source)
		{
			if (error != CopyError.None)
			{
				throw new ArgumentException($"FixedString512Bytes: {error} while copying \"{source}\"");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckFormatError(FormatError error)
		{
			if (error != FormatError.None)
			{
				throw new ArgumentException("Source is too long to fit into fixed string of this size");
			}
		}
	}
	[Serializable]
	[StructLayout(LayoutKind.Explicit, Size = 4094)]
	[GenerateTestsForBurstCompatibility]
	public struct FixedBytes4094
	{
		[FieldOffset(0)]
		public FixedBytes16 offset0000;

		[FieldOffset(16)]
		public FixedBytes16 offset0016;

		[FieldOffset(32)]
		public FixedBytes16 offset0032;

		[FieldOffset(48)]
		public FixedBytes16 offset0048;

		[FieldOffset(64)]
		public FixedBytes16 offset0064;

		[FieldOffset(80)]
		public FixedBytes16 offset0080;

		[FieldOffset(96)]
		public FixedBytes16 offset0096;

		[FieldOffset(112)]
		public FixedBytes16 offset0112;

		[FieldOffset(128)]
		public FixedBytes16 offset0128;

		[FieldOffset(144)]
		public FixedBytes16 offset0144;

		[FieldOffset(160)]
		public FixedBytes16 offset0160;

		[FieldOffset(176)]
		public FixedBytes16 offset0176;

		[FieldOffset(192)]
		public FixedBytes16 offset0192;

		[FieldOffset(208)]
		public FixedBytes16 offset0208;

		[FieldOffset(224)]
		public FixedBytes16 offset0224;

		[FieldOffset(240)]
		public FixedBytes16 offset0240;

		[FieldOffset(256)]
		public FixedBytes16 offset0256;

		[FieldOffset(272)]
		public FixedBytes16 offset0272;

		[FieldOffset(288)]
		public FixedBytes16 offset0288;

		[FieldOffset(304)]
		public FixedBytes16 offset0304;

		[FieldOffset(320)]
		public FixedBytes16 offset0320;

		[FieldOffset(336)]
		public FixedBytes16 offset0336;

		[FieldOffset(352)]
		public FixedBytes16 offset0352;

		[FieldOffset(368)]
		public FixedBytes16 offset0368;

		[FieldOffset(384)]
		public FixedBytes16 offset0384;

		[FieldOffset(400)]
		public FixedBytes16 offset0400;

		[FieldOffset(416)]
		public FixedBytes16 offset0416;

		[FieldOffset(432)]
		public FixedBytes16 offset0432;

		[FieldOffset(448)]
		public FixedBytes16 offset0448;

		[FieldOffset(464)]
		public FixedBytes16 offset0464;

		[FieldOffset(480)]
		public FixedBytes16 offset0480;

		[FieldOffset(496)]
		public FixedBytes16 offset0496;

		[FieldOffset(512)]
		public FixedBytes16 offset0512;

		[FieldOffset(528)]
		public FixedBytes16 offset0528;

		[FieldOffset(544)]
		public FixedBytes16 offset0544;

		[FieldOffset(560)]
		public FixedBytes16 offset0560;

		[FieldOffset(576)]
		public FixedBytes16 offset0576;

		[FieldOffset(592)]
		public FixedBytes16 offset0592;

		[FieldOffset(608)]
		public FixedBytes16 offset0608;

		[FieldOffset(624)]
		public FixedBytes16 offset0624;

		[FieldOffset(640)]
		public FixedBytes16 offset0640;

		[FieldOffset(656)]
		public FixedBytes16 offset0656;

		[FieldOffset(672)]
		public FixedBytes16 offset0672;

		[FieldOffset(688)]
		public FixedBytes16 offset0688;

		[FieldOffset(704)]
		public FixedBytes16 offset0704;

		[FieldOffset(720)]
		public FixedBytes16 offset0720;

		[FieldOffset(736)]
		public FixedBytes16 offset0736;

		[FieldOffset(752)]
		public FixedBytes16 offset0752;

		[FieldOffset(768)]
		public FixedBytes16 offset0768;

		[FieldOffset(784)]
		public FixedBytes16 offset0784;

		[FieldOffset(800)]
		public FixedBytes16 offset0800;

		[FieldOffset(816)]
		public FixedBytes16 offset0816;

		[FieldOffset(832)]
		public FixedBytes16 offset0832;

		[FieldOffset(848)]
		public FixedBytes16 offset0848;

		[FieldOffset(864)]
		public FixedBytes16 offset0864;

		[FieldOffset(880)]
		public FixedBytes16 offset0880;

		[FieldOffset(896)]
		public FixedBytes16 offset0896;

		[FieldOffset(912)]
		public FixedBytes16 offset0912;

		[FieldOffset(928)]
		public FixedBytes16 offset0928;

		[FieldOffset(944)]
		public FixedBytes16 offset0944;

		[FieldOffset(960)]
		public FixedBytes16 offset0960;

		[FieldOffset(976)]
		public FixedBytes16 offset0976;

		[FieldOffset(992)]
		public FixedBytes16 offset0992;

		[FieldOffset(1008)]
		public FixedBytes16 offset1008;

		[FieldOffset(1024)]
		public FixedBytes16 offset1024;

		[FieldOffset(1040)]
		public FixedBytes16 offset1040;

		[FieldOffset(1056)]
		public FixedBytes16 offset1056;

		[FieldOffset(1072)]
		public FixedBytes16 offset1072;

		[FieldOffset(1088)]
		public FixedBytes16 offset1088;

		[FieldOffset(1104)]
		public FixedBytes16 offset1104;

		[FieldOffset(1120)]
		public FixedBytes16 offset1120;

		[FieldOffset(1136)]
		public FixedBytes16 offset1136;

		[FieldOffset(1152)]
		public FixedBytes16 offset1152;

		[FieldOffset(1168)]
		public FixedBytes16 offset1168;

		[FieldOffset(1184)]
		public FixedBytes16 offset1184;

		[FieldOffset(1200)]
		public FixedBytes16 offset1200;

		[FieldOffset(1216)]
		public FixedBytes16 offset1216;

		[FieldOffset(1232)]
		public FixedBytes16 offset1232;

		[FieldOffset(1248)]
		public FixedBytes16 offset1248;

		[FieldOffset(1264)]
		public FixedBytes16 offset1264;

		[FieldOffset(1280)]
		public FixedBytes16 offset1280;

		[FieldOffset(1296)]
		public FixedBytes16 offset1296;

		[FieldOffset(1312)]
		public FixedBytes16 offset1312;

		[FieldOffset(1328)]
		public FixedBytes16 offset1328;

		[FieldOffset(1344)]
		public FixedBytes16 offset1344;

		[FieldOffset(1360)]
		public FixedBytes16 offset1360;

		[FieldOffset(1376)]
		public FixedBytes16 offset1376;

		[FieldOffset(1392)]
		public FixedBytes16 offset1392;

		[FieldOffset(1408)]
		public FixedBytes16 offset1408;

		[FieldOffset(1424)]
		public FixedBytes16 offset1424;

		[FieldOffset(1440)]
		public FixedBytes16 offset1440;

		[FieldOffset(1456)]
		public FixedBytes16 offset1456;

		[FieldOffset(1472)]
		public FixedBytes16 offset1472;

		[FieldOffset(1488)]
		public FixedBytes16 offset1488;

		[FieldOffset(1504)]
		public FixedBytes16 offset1504;

		[FieldOffset(1520)]
		public FixedBytes16 offset1520;

		[FieldOffset(1536)]
		public FixedBytes16 offset1536;

		[FieldOffset(1552)]
		public FixedBytes16 offset1552;

		[FieldOffset(1568)]
		public FixedBytes16 offset1568;

		[FieldOffset(1584)]
		public FixedBytes16 offset1584;

		[FieldOffset(1600)]
		public FixedBytes16 offset1600;

		[FieldOffset(1616)]
		public FixedBytes16 offset1616;

		[FieldOffset(1632)]
		public FixedBytes16 offset1632;

		[FieldOffset(1648)]
		public FixedBytes16 offset1648;

		[FieldOffset(1664)]
		public FixedBytes16 offset1664;

		[FieldOffset(1680)]
		public FixedBytes16 offset1680;

		[FieldOffset(1696)]
		public FixedBytes16 offset1696;

		[FieldOffset(1712)]
		public FixedBytes16 offset1712;

		[FieldOffset(1728)]
		public FixedBytes16 offset1728;

		[FieldOffset(1744)]
		public FixedBytes16 offset1744;

		[FieldOffset(1760)]
		public FixedBytes16 offset1760;

		[FieldOffset(1776)]
		public FixedBytes16 offset1776;

		[FieldOffset(1792)]
		public FixedBytes16 offset1792;

		[FieldOffset(1808)]
		public FixedBytes16 offset1808;

		[FieldOffset(1824)]
		public FixedBytes16 offset1824;

		[FieldOffset(1840)]
		public FixedBytes16 offset1840;

		[FieldOffset(1856)]
		public FixedBytes16 offset1856;

		[FieldOffset(1872)]
		public FixedBytes16 offset1872;

		[FieldOffset(1888)]
		public FixedBytes16 offset1888;

		[FieldOffset(1904)]
		public FixedBytes16 offset1904;

		[FieldOffset(1920)]
		public FixedBytes16 offset1920;

		[FieldOffset(1936)]
		public FixedBytes16 offset1936;

		[FieldOffset(1952)]
		public FixedBytes16 offset1952;

		[FieldOffset(1968)]
		public FixedBytes16 offset1968;

		[FieldOffset(1984)]
		public FixedBytes16 offset1984;

		[FieldOffset(2000)]
		public FixedBytes16 offset2000;

		[FieldOffset(2016)]
		public FixedBytes16 offset2016;

		[FieldOffset(2032)]
		public FixedBytes16 offset2032;

		[FieldOffset(2048)]
		public FixedBytes16 offset2048;

		[FieldOffset(2064)]
		public FixedBytes16 offset2064;

		[FieldOffset(2080)]
		public FixedBytes16 offset2080;

		[FieldOffset(2096)]
		public FixedBytes16 offset2096;

		[FieldOffset(2112)]
		public FixedBytes16 offset2112;

		[FieldOffset(2128)]
		public FixedBytes16 offset2128;

		[FieldOffset(2144)]
		public FixedBytes16 offset2144;

		[FieldOffset(2160)]
		public FixedBytes16 offset2160;

		[FieldOffset(2176)]
		public FixedBytes16 offset2176;

		[FieldOffset(2192)]
		public FixedBytes16 offset2192;

		[FieldOffset(2208)]
		public FixedBytes16 offset2208;

		[FieldOffset(2224)]
		public FixedBytes16 offset2224;

		[FieldOffset(2240)]
		public FixedBytes16 offset2240;

		[FieldOffset(2256)]
		public FixedBytes16 offset2256;

		[FieldOffset(2272)]
		public FixedBytes16 offset2272;

		[FieldOffset(2288)]
		public FixedBytes16 offset2288;

		[FieldOffset(2304)]
		public FixedBytes16 offset2304;

		[FieldOffset(2320)]
		public FixedBytes16 offset2320;

		[FieldOffset(2336)]
		public FixedBytes16 offset2336;

		[FieldOffset(2352)]
		public FixedBytes16 offset2352;

		[FieldOffset(2368)]
		public FixedBytes16 offset2368;

		[FieldOffset(2384)]
		public FixedBytes16 offset2384;

		[FieldOffset(2400)]
		public FixedBytes16 offset2400;

		[FieldOffset(2416)]
		public FixedBytes16 offset2416;

		[FieldOffset(2432)]
		public FixedBytes16 offset2432;

		[FieldOffset(2448)]
		public FixedBytes16 offset2448;

		[FieldOffset(2464)]
		public FixedBytes16 offset2464;

		[FieldOffset(2480)]
		public FixedBytes16 offset2480;

		[FieldOffset(2496)]
		public FixedBytes16 offset2496;

		[FieldOffset(2512)]
		public FixedBytes16 offset2512;

		[FieldOffset(2528)]
		public FixedBytes16 offset2528;

		[FieldOffset(2544)]
		public FixedBytes16 offset2544;

		[FieldOffset(2560)]
		public FixedBytes16 offset2560;

		[FieldOffset(2576)]
		public FixedBytes16 offset2576;

		[FieldOffset(2592)]
		public FixedBytes16 offset2592;

		[FieldOffset(2608)]
		public FixedBytes16 offset2608;

		[FieldOffset(2624)]
		public FixedBytes16 offset2624;

		[FieldOffset(2640)]
		public FixedBytes16 offset2640;

		[FieldOffset(2656)]
		public FixedBytes16 offset2656;

		[FieldOffset(2672)]
		public FixedBytes16 offset2672;

		[FieldOffset(2688)]
		public FixedBytes16 offset2688;

		[FieldOffset(2704)]
		public FixedBytes16 offset2704;

		[FieldOffset(2720)]
		public FixedBytes16 offset2720;

		[FieldOffset(2736)]
		public FixedBytes16 offset2736;

		[FieldOffset(2752)]
		public FixedBytes16 offset2752;

		[FieldOffset(2768)]
		public FixedBytes16 offset2768;

		[FieldOffset(2784)]
		public FixedBytes16 offset2784;

		[FieldOffset(2800)]
		public FixedBytes16 offset2800;

		[FieldOffset(2816)]
		public FixedBytes16 offset2816;

		[FieldOffset(2832)]
		public FixedBytes16 offset2832;

		[FieldOffset(2848)]
		public FixedBytes16 offset2848;

		[FieldOffset(2864)]
		public FixedBytes16 offset2864;

		[FieldOffset(2880)]
		public FixedBytes16 offset2880;

		[FieldOffset(2896)]
		public FixedBytes16 offset2896;

		[FieldOffset(2912)]
		public FixedBytes16 offset2912;

		[FieldOffset(2928)]
		public FixedBytes16 offset2928;

		[FieldOffset(2944)]
		public FixedBytes16 offset2944;

		[FieldOffset(2960)]
		public FixedBytes16 offset2960;

		[FieldOffset(2976)]
		public FixedBytes16 offset2976;

		[FieldOffset(2992)]
		public FixedBytes16 offset2992;

		[FieldOffset(3008)]
		public FixedBytes16 offset3008;

		[FieldOffset(3024)]
		public FixedBytes16 offset3024;

		[FieldOffset(3040)]
		public FixedBytes16 offset3040;

		[FieldOffset(3056)]
		public FixedBytes16 offset3056;

		[FieldOffset(3072)]
		public FixedBytes16 offset3072;

		[FieldOffset(3088)]
		public FixedBytes16 offset3088;

		[FieldOffset(3104)]
		public FixedBytes16 offset3104;

		[FieldOffset(3120)]
		public FixedBytes16 offset3120;

		[FieldOffset(3136)]
		public FixedBytes16 offset3136;

		[FieldOffset(3152)]
		public FixedBytes16 offset3152;

		[FieldOffset(3168)]
		public FixedBytes16 offset3168;

		[FieldOffset(3184)]
		public FixedBytes16 offset3184;

		[FieldOffset(3200)]
		public FixedBytes16 offset3200;

		[FieldOffset(3216)]
		public FixedBytes16 offset3216;

		[FieldOffset(3232)]
		public FixedBytes16 offset3232;

		[FieldOffset(3248)]
		public FixedBytes16 offset3248;

		[FieldOffset(3264)]
		public FixedBytes16 offset3264;

		[FieldOffset(3280)]
		public FixedBytes16 offset3280;

		[FieldOffset(3296)]
		public FixedBytes16 offset3296;

		[FieldOffset(3312)]
		public FixedBytes16 offset3312;

		[FieldOffset(3328)]
		public FixedBytes16 offset3328;

		[FieldOffset(3344)]
		public FixedBytes16 offset3344;

		[FieldOffset(3360)]
		public FixedBytes16 offset3360;

		[FieldOffset(3376)]
		public FixedBytes16 offset3376;

		[FieldOffset(3392)]
		public FixedBytes16 offset3392;

		[FieldOffset(3408)]
		public FixedBytes16 offset3408;

		[FieldOffset(3424)]
		public FixedBytes16 offset3424;

		[FieldOffset(3440)]
		public FixedBytes16 offset3440;

		[FieldOffset(3456)]
		public FixedBytes16 offset3456;

		[FieldOffset(3472)]
		public FixedBytes16 offset3472;

		[FieldOffset(3488)]
		public FixedBytes16 offset3488;

		[FieldOffset(3504)]
		public FixedBytes16 offset3504;

		[FieldOffset(3520)]
		public FixedBytes16 offset3520;

		[FieldOffset(3536)]
		public FixedBytes16 offset3536;

		[FieldOffset(3552)]
		public FixedBytes16 offset3552;

		[FieldOffset(3568)]
		public FixedBytes16 offset3568;

		[FieldOffset(3584)]
		public FixedBytes16 offset3584;

		[FieldOffset(3600)]
		public FixedBytes16 offset3600;

		[FieldOffset(3616)]
		public FixedBytes16 offset3616;

		[FieldOffset(3632)]
		public FixedBytes16 offset3632;

		[FieldOffset(3648)]
		public FixedBytes16 offset3648;

		[FieldOffset(3664)]
		public FixedBytes16 offset3664;

		[FieldOffset(3680)]
		public FixedBytes16 offset3680;

		[FieldOffset(3696)]
		public FixedBytes16 offset3696;

		[FieldOffset(3712)]
		public FixedBytes16 offset3712;

		[FieldOffset(3728)]
		public FixedBytes16 offset3728;

		[FieldOffset(3744)]
		public FixedBytes16 offset3744;

		[FieldOffset(3760)]
		public FixedBytes16 offset3760;

		[FieldOffset(3776)]
		public FixedBytes16 offset3776;

		[FieldOffset(3792)]
		public FixedBytes16 offset3792;

		[FieldOffset(3808)]
		public FixedBytes16 offset3808;

		[FieldOffset(3824)]
		public FixedBytes16 offset3824;

		[FieldOffset(3840)]
		public FixedBytes16 offset3840;

		[FieldOffset(3856)]
		public FixedBytes16 offset3856;

		[FieldOffset(3872)]
		public FixedBytes16 offset3872;

		[FieldOffset(3888)]
		public FixedBytes16 offset3888;

		[FieldOffset(3904)]
		public FixedBytes16 offset3904;

		[FieldOffset(3920)]
		public FixedBytes16 offset3920;

		[FieldOffset(3936)]
		public FixedBytes16 offset3936;

		[FieldOffset(3952)]
		public FixedBytes16 offset3952;

		[FieldOffset(3968)]
		public FixedBytes16 offset3968;

		[FieldOffset(3984)]
		public FixedBytes16 offset3984;

		[FieldOffset(4000)]
		public FixedBytes16 offset4000;

		[FieldOffset(4016)]
		public FixedBytes16 offset4016;

		[FieldOffset(4032)]
		public FixedBytes16 offset4032;

		[FieldOffset(4048)]
		public FixedBytes16 offset4048;

		[FieldOffset(4064)]
		public FixedBytes16 offset4064;

		[FieldOffset(4080)]
		public byte byte4080;

		[FieldOffset(4081)]
		public byte byte4081;

		[FieldOffset(4082)]
		public byte byte4082;

		[FieldOffset(4083)]
		public byte byte4083;

		[FieldOffset(4084)]
		public byte byte4084;

		[FieldOffset(4085)]
		public byte byte4085;

		[FieldOffset(4086)]
		public byte byte4086;

		[FieldOffset(4087)]
		public byte byte4087;

		[FieldOffset(4088)]
		public byte byte4088;

		[FieldOffset(4089)]
		public byte byte4089;

		[FieldOffset(4090)]
		public byte byte4090;

		[FieldOffset(4091)]
		public byte byte4091;

		[FieldOffset(4092)]
		public byte byte4092;

		[FieldOffset(4093)]
		public byte byte4093;
	}
	[Serializable]
	[StructLayout(LayoutKind.Sequential, Size = 4096)]
	[GenerateTestsForBurstCompatibility]
	public struct FixedString4096Bytes : INativeList<byte>, IIndexable<byte>, IUTF8Bytes, IComparable<string>, IEquatable<string>, IComparable<FixedString32Bytes>, IEquatable<FixedString32Bytes>, IComparable<FixedString64Bytes>, IEquatable<FixedString64Bytes>, IComparable<FixedString128Bytes>, IEquatable<FixedString128Bytes>, IComparable<FixedString512Bytes>, IEquatable<FixedString512Bytes>, IComparable<FixedString4096Bytes>, IEquatable<FixedString4096Bytes>
	{
		public struct Enumerator : IEnumerator
		{
			private FixedString4096Bytes target;

			private int offset;

			private Unicode.Rune current;

			public Unicode.Rune Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return current;
				}
			}

			object IEnumerator.Current => Current;

			public Enumerator(FixedString4096Bytes other)
			{
				target = other;
				offset = 0;
				current = default(Unicode.Rune);
			}

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public unsafe bool MoveNext()
			{
				if (offset >= target.Length)
				{
					return false;
				}
				Unicode.Utf8ToUcs(out current, target.GetUnsafePtr(), ref offset, target.Length);
				return true;
			}

			public void Reset()
			{
				offset = 0;
				current = default(Unicode.Rune);
			}
		}

		internal const ushort utf8MaxLengthInBytes = 4093;

		[SerializeField]
		internal ushort utf8LengthInBytes;

		[SerializeField]
		internal FixedBytes4094 bytes;

		public static int UTF8MaxLengthInBytes => 4093;

		[CreateProperty]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[ExcludeFromBurstCompatTesting("Returns managed string")]
		public string Value => ToString();

		public unsafe int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return utf8LengthInBytes;
			}
			set
			{
				utf8LengthInBytes = (ushort)value;
				GetUnsafePtr()[(int)utf8LengthInBytes] = 0;
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return 4093;
			}
			set
			{
			}
		}

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return utf8LengthInBytes == 0;
			}
		}

		public unsafe byte this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return GetUnsafePtr()[index];
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				GetUnsafePtr()[index] = value;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe readonly byte* GetUnsafePtr()
		{
			fixed (FixedBytes4094* result = &bytes)
			{
				return (byte*)result;
			}
		}

		public unsafe bool TryResize(int newLength, NativeArrayOptions clearOptions = NativeArrayOptions.ClearMemory)
		{
			if (newLength < 0 || newLength > 4093)
			{
				return false;
			}
			if (newLength == utf8LengthInBytes)
			{
				return true;
			}
			if (clearOptions == NativeArrayOptions.ClearMemory)
			{
				if (newLength > utf8LengthInBytes)
				{
					UnsafeUtility.MemClear(GetUnsafePtr() + (int)utf8LengthInBytes, newLength - utf8LengthInBytes);
				}
				else
				{
					UnsafeUtility.MemClear(GetUnsafePtr() + newLength, utf8LengthInBytes - newLength);
				}
			}
			utf8LengthInBytes = (ushort)newLength;
			GetUnsafePtr()[(int)utf8LengthInBytes] = 0;
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe ref byte ElementAt(int index)
		{
			return ref GetUnsafePtr()[index];
		}

		public void Clear()
		{
			Length = 0;
		}

		public void Add(in byte value)
		{
			this[Length++] = value;
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public int CompareTo(string other)
		{
			return ToString().CompareTo(other);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public unsafe bool Equals(string other)
		{
			int num = utf8LengthInBytes;
			int length = other.Length;
			byte* utf8Buffer = (byte*)UnsafeUtilityExtensions.AddressOf(in bytes);
			fixed (char* utf16Buffer = other)
			{
				return UTF8ArrayUnsafeUtility.StrCmp(utf8Buffer, num, utf16Buffer, length) == 0;
			}
		}

		public unsafe ref FixedList4096Bytes<byte> AsFixedList()
		{
			return ref UnsafeUtility.AsRef<FixedList4096Bytes<byte>>(UnsafeUtility.AddressOf(ref this));
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public FixedString4096Bytes(string source)
		{
			this = default(FixedString4096Bytes);
			Initialize(source);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		internal CopyError Initialize(string source)
		{
			return FixedStringMethods.CopyFromTruncated(ref this, source);
		}

		public FixedString4096Bytes(Unicode.Rune rune, int count = 1)
		{
			this = default(FixedString4096Bytes);
			Initialize(rune, count);
		}

		internal FormatError Initialize(Unicode.Rune rune, int count = 1)
		{
			this = default(FixedString4096Bytes);
			return FixedStringMethods.Append(ref this, rune, count);
		}

		internal unsafe FormatError Initialize(byte* srcBytes, int srcLength)
		{
			bytes = default(FixedBytes4094);
			utf8LengthInBytes = 0;
			int destLength = 0;
			FormatError formatError = UTF8ArrayUnsafeUtility.AppendUTF8Bytes(GetUnsafePtr(), ref destLength, 4093, srcBytes, srcLength);
			if (formatError != FormatError.None)
			{
				return formatError;
			}
			Length = destLength;
			return FormatError.None;
		}

		public unsafe FixedString4096Bytes(NativeText.ReadOnly other)
		{
			this = default(FixedString4096Bytes);
			Initialize(other.GetUnsafePtr(), other.Length);
		}

		public unsafe FixedString4096Bytes(in UnsafeText other)
		{
			this = default(FixedString4096Bytes);
			Initialize(other.GetUnsafePtr(), other.Length);
		}

		public int CompareTo(FixedString32Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString4096Bytes(in FixedString32Bytes other)
		{
			this = default(FixedString4096Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString32Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString4096Bytes a, in FixedString32Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString4096Bytes a, in FixedString32Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString32Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString64Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString4096Bytes(in FixedString64Bytes other)
		{
			this = default(FixedString4096Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString64Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString4096Bytes a, in FixedString64Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString4096Bytes a, in FixedString64Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString64Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString128Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString4096Bytes(in FixedString128Bytes other)
		{
			this = default(FixedString4096Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString128Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString4096Bytes a, in FixedString128Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString4096Bytes a, in FixedString128Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString128Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString512Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString4096Bytes(in FixedString512Bytes other)
		{
			this = default(FixedString4096Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString512Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString4096Bytes a, in FixedString512Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString4096Bytes a, in FixedString512Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString512Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString4096Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public FixedString4096Bytes(in FixedString4096Bytes other)
		{
			this = default(FixedString4096Bytes);
			Initialize(in other);
		}

		internal unsafe FormatError Initialize(in FixedString4096Bytes other)
		{
			return Initialize((byte*)UnsafeUtilityExtensions.AddressOf(in other.bytes), other.utf8LengthInBytes);
		}

		public unsafe static bool operator ==(in FixedString4096Bytes a, in FixedString4096Bytes b)
		{
			int aLength = a.utf8LengthInBytes;
			int bLength = b.utf8LengthInBytes;
			byte* aBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in a.bytes);
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aBytes, aLength, bBytes, bLength);
		}

		public static bool operator !=(in FixedString4096Bytes a, in FixedString4096Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString4096Bytes other)
		{
			return this == other;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static implicit operator FixedString4096Bytes(string b)
		{
			return new FixedString4096Bytes(b);
		}

		[ExcludeFromBurstCompatTesting("Returns managed string")]
		public override string ToString()
		{
			return FixedStringMethods.ConvertToString(ref this);
		}

		public override int GetHashCode()
		{
			return FixedStringMethods.ComputeHashCode(ref this);
		}

		[ExcludeFromBurstCompatTesting("Takes managed object")]
		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is string other)
			{
				return Equals(other);
			}
			if (obj is FixedString32Bytes other2)
			{
				return Equals(other2);
			}
			if (obj is FixedString64Bytes other3)
			{
				return Equals(other3);
			}
			if (obj is FixedString128Bytes other4)
			{
				return Equals(other4);
			}
			if (obj is FixedString512Bytes other5)
			{
				return Equals(other5);
			}
			if (obj is FixedString4096Bytes other6)
			{
				return Equals(other6);
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private readonly void CheckIndexInRange(int index)
		{
			if (index < 0)
			{
				throw new IndexOutOfRangeException($"Index {index} must be positive.");
			}
			if (index >= utf8LengthInBytes)
			{
				throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString4096Bytes of '{utf8LengthInBytes}' Length.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckLengthInRange(int length)
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
			}
			if (length > 4093)
			{
				throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString4096Bytes of '{(ushort)4093}' Capacity.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckCapacityInRange(int capacity)
		{
			if (capacity > 4093)
			{
				throw new ArgumentOutOfRangeException($"Capacity {capacity} must be lower than {(ushort)4093}.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckCopyError(CopyError error, string source)
		{
			if (error != CopyError.None)
			{
				throw new ArgumentException($"FixedString4096Bytes: {error} while copying \"{source}\"");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckFormatError(FormatError error)
		{
			if (error != FormatError.None)
			{
				throw new ArgumentException("Source is too long to fit into fixed string of this size");
			}
		}
	}
	[GenerateTestsForBurstCompatibility]
	[GenerateTestsForBurstCompatibility]
	[GenerateTestsForBurstCompatibility]
	[GenerateTestsForBurstCompatibility]
	public static class FixedStringMethods
	{
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public static FormatError Append<T>(this ref T fs, Unicode.Rune rune) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int index = fs.Length;
			int num = rune.LengthInUtf8Bytes();
			if (!fs.TryResize(index + num, NativeArrayOptions.UninitializedMemory))
			{
				return FormatError.Overflow;
			}
			return Write(ref fs, ref index, rune);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public static FormatError Append<T>(this ref T fs, char ch) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			return Append(ref fs, (Unicode.Rune)ch);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static FormatError AppendRawByte<T>(this ref T fs, byte a) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int length = fs.Length;
			if (!fs.TryResize(length + 1, NativeArrayOptions.UninitializedMemory))
			{
				return FormatError.Overflow;
			}
			fs.GetUnsafePtr()[length] = a;
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static FormatError Append<T>(this ref T fs, Unicode.Rune rune, int count) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int length = fs.Length;
			if (!fs.TryResize(length + rune.LengthInUtf8Bytes() * count, NativeArrayOptions.UninitializedMemory))
			{
				return FormatError.Overflow;
			}
			int capacity = fs.Capacity;
			byte* unsafePtr = fs.GetUnsafePtr();
			int index = length;
			for (int i = 0; i < count; i++)
			{
				if (Unicode.UcsToUtf8(unsafePtr, ref index, capacity, rune) != ConversionError.None)
				{
					return FormatError.Overflow;
				}
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static FormatError Append<T>(this ref T fs, long input) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			byte* ptr = stackalloc byte[20];
			int num = 20;
			if (input >= 0)
			{
				do
				{
					byte b = (byte)(input % 10);
					ptr[--num] = (byte)(48 + b);
					input /= 10;
				}
				while (input != 0L);
			}
			else
			{
				do
				{
					byte b2 = (byte)(input % 10);
					ptr[--num] = (byte)(48 - b2);
					input /= 10;
				}
				while (input != 0L);
				ptr[--num] = 45;
			}
			return Append(ref fs, ptr + num, 20 - num);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public static FormatError Append<T>(this ref T fs, int input) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			return Append(ref fs, (long)input);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static FormatError Append<T>(this ref T fs, ulong input) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			byte* ptr = stackalloc byte[20];
			int num = 20;
			do
			{
				byte b = (byte)(input % 10);
				ptr[--num] = (byte)(48 + b);
				input /= 10;
			}
			while (input != 0L);
			return Append(ref fs, ptr + num, 20 - num);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public static FormatError Append<T>(this ref T fs, uint input) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			return Append(ref fs, (ulong)input);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static FormatError Append<T>(this ref T fs, float input, char decimalSeparator = '.') where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedStringUtils.UintFloatUnion uintFloatUnion = new FixedStringUtils.UintFloatUnion
			{
				floatValue = input
			};
			uint num = uintFloatUnion.uintValue >> 31;
			uintFloatUnion.uintValue &= 2147483647u;
			FormatError result;
			if ((uintFloatUnion.uintValue & 0x7F800000) == 2139095040)
			{
				if (uintFloatUnion.uintValue == 2139095040)
				{
					if (num != 0 && (result = Append(ref fs, '-')) != FormatError.None)
					{
						return result;
					}
					return Append(ref fs, 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y');
				}
				return Append(ref fs, 'N', 'a', 'N');
			}
			if (num != 0 && uintFloatUnion.uintValue != 0 && (result = Append(ref fs, '-')) != FormatError.None)
			{
				return result;
			}
			ulong mantissa = 0uL;
			int exponent = 0;
			FixedStringUtils.Base2ToBase10(ref mantissa, ref exponent, uintFloatUnion.floatValue);
			char* ptr = stackalloc char[9];
			int num2 = 0;
			do
			{
				if (num2 >= 9)
				{
					return FormatError.Overflow;
				}
				ulong num3 = mantissa % 10;
				ptr[8 - num2++] = (char)(48 + num3);
				mantissa /= 10;
			}
			while (mantissa != 0);
			char* ptr2 = ptr + 9 - num2;
			int num4 = -exponent - num2 + 1;
			if (num4 > 0)
			{
				if (num4 > 4)
				{
					return AppendScientific(ref fs, ptr2, num2, exponent, decimalSeparator);
				}
				if ((result = Append(ref fs, '0', decimalSeparator)) != FormatError.None)
				{
					return result;
				}
				for (num4--; num4 > 0; num4--)
				{
					if ((result = Append(ref fs, '0')) != FormatError.None)
					{
						return result;
					}
				}
				for (int i = 0; i < num2; i++)
				{
					if ((result = Append(ref fs, ptr2[i])) != FormatError.None)
					{
						return result;
					}
				}
				return FormatError.None;
			}
			int num5 = exponent;
			if (num5 > 0)
			{
				if (num5 > 4)
				{
					return AppendScientific(ref fs, ptr2, num2, exponent, decimalSeparator);
				}
				for (int j = 0; j < num2; j++)
				{
					if ((result = Append(ref fs, ptr2[j])) != FormatError.None)
					{
						return result;
					}
				}
				while (num5 > 0)
				{
					if ((result = Append(ref fs, '0')) != FormatError.None)
					{
						return result;
					}
					num5--;
				}
				return FormatError.None;
			}
			int num6 = num2 + exponent;
			for (int k = 0; k < num2; k++)
			{
				if (k == num6 && (result = Append(ref fs, decimalSeparator)) != FormatError.None)
				{
					return result;
				}
				if ((result = Append(ref fs, ptr2[k])) != FormatError.None)
				{
					return result;
				}
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static FormatError Append<T, T2>(this ref T fs, in T2 input) where T : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref T2 reference = ref UnsafeUtilityExtensions.AsRef(in input);
			return Append(ref fs, reference.GetUnsafePtr(), reference.Length);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public static CopyError CopyFrom<T, T2>(this ref T fs, in T2 input) where T : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			fs.Length = 0;
			if (Append(ref fs, in input) != FormatError.None)
			{
				return CopyError.Truncation;
			}
			return CopyError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static FormatError Append<T>(this ref T fs, byte* utf8Bytes, int utf8BytesLength) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int length = fs.Length;
			if (!fs.TryResize(length + utf8BytesLength, NativeArrayOptions.UninitializedMemory))
			{
				return FormatError.Overflow;
			}
			UnsafeUtility.MemCpy(fs.GetUnsafePtr() + length, utf8Bytes, utf8BytesLength);
			return FormatError.None;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public unsafe static FormatError Append<T>(this ref T fs, string s) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int num = s.Length * 4;
			byte* ptr = stackalloc byte[(int)(uint)num];
			int destLength;
			fixed (char* src = s)
			{
				if (UTF8ArrayUnsafeUtility.Copy(ptr, out destLength, num, src, s.Length) != CopyError.None)
				{
					return FormatError.Overflow;
				}
			}
			return Append(ref fs, ptr, destLength);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static CopyError CopyFrom<T>(this ref T fs, string s) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			fs.Length = 0;
			if (Append(ref fs, s) != FormatError.None)
			{
				return CopyError.Truncation;
			}
			return CopyError.None;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public unsafe static CopyError CopyFromTruncated<T>(this ref T fs, string s) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			fixed (char* src = s)
			{
				int destLength;
				CopyError result = UTF8ArrayUnsafeUtility.Copy(fs.GetUnsafePtr(), out destLength, fs.Capacity, src, s.Length);
				fs.Length = destLength;
				return result;
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static CopyError CopyFromTruncated<T, T2>(this ref T fs, in T2 input) where T : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int destLength;
			CopyError result = UTF8ArrayUnsafeUtility.Copy(fs.GetUnsafePtr(), out destLength, fs.Capacity, input.GetUnsafePtr(), input.Length);
			fs.Length = destLength;
			return result;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static FormatError AppendFormat<T, U, T0>(this ref T dest, in U format, in T0 arg0) where T : unmanaged, INativeList<byte>, IUTF8Bytes where U : unmanaged, INativeList<byte>, IUTF8Bytes where T0 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref U reference = ref UnsafeUtilityExtensions.AsRef(in format);
			int length = reference.Length;
			byte* unsafePtr = reference.GetUnsafePtr();
			int num = 0;
			FormatError formatError = FormatError.None;
			while (num < length)
			{
				byte b = unsafePtr[num++];
				switch (b)
				{
				case 123:
					if (num < length)
					{
						b = unsafePtr[num++];
						formatError = ((b >= 48 && b <= 57 && num < length && unsafePtr[num++] == 125) ? ((b - 48 != 0) ? FormatError.BadFormatSpecifier : Append(ref dest, in arg0)) : ((b != 123) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b)));
						break;
					}
					return FormatError.BadFormatSpecifier;
				case 125:
					if (num < length)
					{
						b = unsafePtr[num++];
					}
					else
					{
						formatError = FormatError.BadFormatSpecifier;
					}
					formatError = ((b != 125) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b));
					break;
				default:
					formatError = AppendRawByte(ref dest, b);
					break;
				}
				if (formatError != FormatError.None)
				{
					return formatError;
				}
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static FormatError AppendFormat<T, U, T0, T1>(this ref T dest, in U format, in T0 arg0, in T1 arg1) where T : unmanaged, INativeList<byte>, IUTF8Bytes where U : unmanaged, INativeList<byte>, IUTF8Bytes where T0 : unmanaged, INativeList<byte>, IUTF8Bytes where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref U reference = ref UnsafeUtilityExtensions.AsRef(in format);
			int length = reference.Length;
			byte* unsafePtr = reference.GetUnsafePtr();
			int num = 0;
			FormatError formatError = FormatError.None;
			while (num < length)
			{
				byte b = unsafePtr[num++];
				switch (b)
				{
				case 123:
					if (num < length)
					{
						b = unsafePtr[num++];
						formatError = ((b >= 48 && b <= 57 && num < length && unsafePtr[num++] == 125) ? ((b - 48) switch
						{
							0 => Append(ref dest, in arg0), 
							1 => Append(ref dest, in arg1), 
							_ => FormatError.BadFormatSpecifier, 
						}) : ((b != 123) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b)));
						break;
					}
					return FormatError.BadFormatSpecifier;
				case 125:
					if (num < length)
					{
						b = unsafePtr[num++];
					}
					else
					{
						formatError = FormatError.BadFormatSpecifier;
					}
					formatError = ((b != 125) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b));
					break;
				default:
					formatError = AppendRawByte(ref dest, b);
					break;
				}
				if (formatError != FormatError.None)
				{
					return formatError;
				}
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static FormatError AppendFormat<T, U, T0, T1, T2>(this ref T dest, in U format, in T0 arg0, in T1 arg1, in T2 arg2) where T : unmanaged, INativeList<byte>, IUTF8Bytes where U : unmanaged, INativeList<byte>, IUTF8Bytes where T0 : unmanaged, INativeList<byte>, IUTF8Bytes where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref U reference = ref UnsafeUtilityExtensions.AsRef(in format);
			int length = reference.Length;
			byte* unsafePtr = reference.GetUnsafePtr();
			int num = 0;
			FormatError formatError = FormatError.None;
			while (num < length)
			{
				byte b = unsafePtr[num++];
				switch (b)
				{
				case 123:
					if (num < length)
					{
						b = unsafePtr[num++];
						formatError = ((b >= 48 && b <= 57 && num < length && unsafePtr[num++] == 125) ? ((int)b switch
						{
							48 => Append(ref dest, in arg0), 
							49 => Append(ref dest, in arg1), 
							50 => Append(ref dest, in arg2), 
							_ => FormatError.BadFormatSpecifier, 
						}) : ((b != 123) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b)));
						break;
					}
					return FormatError.BadFormatSpecifier;
				case 125:
					if (num < length)
					{
						b = unsafePtr[num++];
					}
					else
					{
						formatError = FormatError.BadFormatSpecifier;
					}
					formatError = ((b != 125) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b));
					break;
				default:
					formatError = AppendRawByte(ref dest, b);
					break;
				}
				if (formatError != FormatError.None)
				{
					return formatError;
				}
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static FormatError AppendFormat<T, U, T0, T1, T2, T3>(this ref T dest, in U format, in T0 arg0, in T1 arg1, in T2 arg2, in T3 arg3) where T : unmanaged, INativeList<byte>, IUTF8Bytes where U : unmanaged, INativeList<byte>, IUTF8Bytes where T0 : unmanaged, INativeList<byte>, IUTF8Bytes where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref U reference = ref UnsafeUtilityExtensions.AsRef(in format);
			int length = reference.Length;
			byte* unsafePtr = reference.GetUnsafePtr();
			int num = 0;
			FormatError formatError = FormatError.None;
			while (num < length)
			{
				byte b = unsafePtr[num++];
				switch (b)
				{
				case 123:
					if (num < length)
					{
						b = unsafePtr[num++];
						formatError = ((b >= 48 && b <= 57 && num < length && unsafePtr[num++] == 125) ? ((int)b switch
						{
							48 => Append(ref dest, in arg0), 
							49 => Append(ref dest, in arg1), 
							50 => Append(ref dest, in arg2), 
							51 => Append(ref dest, in arg3), 
							_ => FormatError.BadFormatSpecifier, 
						}) : ((b != 123) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b)));
						break;
					}
					return FormatError.BadFormatSpecifier;
				case 125:
					if (num < length)
					{
						b = unsafePtr[num++];
					}
					else
					{
						formatError = FormatError.BadFormatSpecifier;
					}
					formatError = ((b != 125) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b));
					break;
				default:
					formatError = AppendRawByte(ref dest, b);
					break;
				}
				if (formatError != FormatError.None)
				{
					return formatError;
				}
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static FormatError AppendFormat<T, U, T0, T1, T2, T3, T4>(this ref T dest, in U format, in T0 arg0, in T1 arg1, in T2 arg2, in T3 arg3, in T4 arg4) where T : unmanaged, INativeList<byte>, IUTF8Bytes where U : unmanaged, INativeList<byte>, IUTF8Bytes where T0 : unmanaged, INativeList<byte>, IUTF8Bytes where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes where T4 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref U reference = ref UnsafeUtilityExtensions.AsRef(in format);
			int length = reference.Length;
			byte* unsafePtr = reference.GetUnsafePtr();
			int num = 0;
			FormatError formatError = FormatError.None;
			while (num < length)
			{
				byte b = unsafePtr[num++];
				switch (b)
				{
				case 123:
					if (num < length)
					{
						b = unsafePtr[num++];
						formatError = ((b >= 48 && b <= 57 && num < length && unsafePtr[num++] == 125) ? ((int)b switch
						{
							48 => Append(ref dest, in arg0), 
							49 => Append(ref dest, in arg1), 
							50 => Append(ref dest, in arg2), 
							51 => Append(ref dest, in arg3), 
							52 => Append(ref dest, in arg4), 
							_ => FormatError.BadFormatSpecifier, 
						}) : ((b != 123) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b)));
						break;
					}
					return FormatError.BadFormatSpecifier;
				case 125:
					if (num < length)
					{
						b = unsafePtr[num++];
					}
					else
					{
						formatError = FormatError.BadFormatSpecifier;
					}
					formatError = ((b != 125) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b));
					break;
				default:
					formatError = AppendRawByte(ref dest, b);
					break;
				}
				if (formatError != FormatError.None)
				{
					return formatError;
				}
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static FormatError AppendFormat<T, U, T0, T1, T2, T3, T4, T5>(this ref T dest, in U format, in T0 arg0, in T1 arg1, in T2 arg2, in T3 arg3, in T4 arg4, in T5 arg5) where T : unmanaged, INativeList<byte>, IUTF8Bytes where U : unmanaged, INativeList<byte>, IUTF8Bytes where T0 : unmanaged, INativeList<byte>, IUTF8Bytes where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes where T4 : unmanaged, INativeList<byte>, IUTF8Bytes where T5 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref U reference = ref UnsafeUtilityExtensions.AsRef(in format);
			int length = reference.Length;
			byte* unsafePtr = reference.GetUnsafePtr();
			int num = 0;
			FormatError formatError = FormatError.None;
			while (num < length)
			{
				byte b = unsafePtr[num++];
				switch (b)
				{
				case 123:
					if (num < length)
					{
						b = unsafePtr[num++];
						formatError = ((b >= 48 && b <= 57 && num < length && unsafePtr[num++] == 125) ? ((int)b switch
						{
							48 => Append(ref dest, in arg0), 
							49 => Append(ref dest, in arg1), 
							50 => Append(ref dest, in arg2), 
							51 => Append(ref dest, in arg3), 
							52 => Append(ref dest, in arg4), 
							53 => Append(ref dest, in arg5), 
							_ => FormatError.BadFormatSpecifier, 
						}) : ((b != 123) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b)));
						break;
					}
					return FormatError.BadFormatSpecifier;
				case 125:
					if (num < length)
					{
						b = unsafePtr[num++];
					}
					else
					{
						formatError = FormatError.BadFormatSpecifier;
					}
					formatError = ((b != 125) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b));
					break;
				default:
					formatError = AppendRawByte(ref dest, b);
					break;
				}
				if (formatError != FormatError.None)
				{
					return formatError;
				}
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static FormatError AppendFormat<T, U, T0, T1, T2, T3, T4, T5, T6>(this ref T dest, in U format, in T0 arg0, in T1 arg1, in T2 arg2, in T3 arg3, in T4 arg4, in T5 arg5, in T6 arg6) where T : unmanaged, INativeList<byte>, IUTF8Bytes where U : unmanaged, INativeList<byte>, IUTF8Bytes where T0 : unmanaged, INativeList<byte>, IUTF8Bytes where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes where T4 : unmanaged, INativeList<byte>, IUTF8Bytes where T5 : unmanaged, INativeList<byte>, IUTF8Bytes where T6 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref U reference = ref UnsafeUtilityExtensions.AsRef(in format);
			int length = reference.Length;
			byte* unsafePtr = reference.GetUnsafePtr();
			int num = 0;
			FormatError formatError = FormatError.None;
			while (num < length)
			{
				byte b = unsafePtr[num++];
				switch (b)
				{
				case 123:
					if (num < length)
					{
						b = unsafePtr[num++];
						formatError = ((b >= 48 && b <= 57 && num < length && unsafePtr[num++] == 125) ? ((int)b switch
						{
							48 => Append(ref dest, in arg0), 
							49 => Append(ref dest, in arg1), 
							50 => Append(ref dest, in arg2), 
							51 => Append(ref dest, in arg3), 
							52 => Append(ref dest, in arg4), 
							53 => Append(ref dest, in arg5), 
							54 => Append(ref dest, in arg6), 
							_ => FormatError.BadFormatSpecifier, 
						}) : ((b != 123) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b)));
						break;
					}
					return FormatError.BadFormatSpecifier;
				case 125:
					if (num < length)
					{
						b = unsafePtr[num++];
					}
					else
					{
						formatError = FormatError.BadFormatSpecifier;
					}
					formatError = ((b != 125) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b));
					break;
				default:
					formatError = AppendRawByte(ref dest, b);
					break;
				}
				if (formatError != FormatError.None)
				{
					return formatError;
				}
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static FormatError AppendFormat<T, U, T0, T1, T2, T3, T4, T5, T6, T7>(this ref T dest, in U format, in T0 arg0, in T1 arg1, in T2 arg2, in T3 arg3, in T4 arg4, in T5 arg5, in T6 arg6, in T7 arg7) where T : unmanaged, INativeList<byte>, IUTF8Bytes where U : unmanaged, INativeList<byte>, IUTF8Bytes where T0 : unmanaged, INativeList<byte>, IUTF8Bytes where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes where T4 : unmanaged, INativeList<byte>, IUTF8Bytes where T5 : unmanaged, INativeList<byte>, IUTF8Bytes where T6 : unmanaged, INativeList<byte>, IUTF8Bytes where T7 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref U reference = ref UnsafeUtilityExtensions.AsRef(in format);
			int length = reference.Length;
			byte* unsafePtr = reference.GetUnsafePtr();
			int num = 0;
			FormatError formatError = FormatError.None;
			while (num < length)
			{
				byte b = unsafePtr[num++];
				switch (b)
				{
				case 123:
					if (num < length)
					{
						b = unsafePtr[num++];
						formatError = ((b >= 48 && b <= 57 && num < length && unsafePtr[num++] == 125) ? ((int)b switch
						{
							48 => Append(ref dest, in arg0), 
							49 => Append(ref dest, in arg1), 
							50 => Append(ref dest, in arg2), 
							51 => Append(ref dest, in arg3), 
							52 => Append(ref dest, in arg4), 
							53 => Append(ref dest, in arg5), 
							54 => Append(ref dest, in arg6), 
							55 => Append(ref dest, in arg7), 
							_ => FormatError.BadFormatSpecifier, 
						}) : ((b != 123) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b)));
						break;
					}
					return FormatError.BadFormatSpecifier;
				case 125:
					if (num < length)
					{
						b = unsafePtr[num++];
					}
					else
					{
						formatError = FormatError.BadFormatSpecifier;
					}
					formatError = ((b != 125) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b));
					break;
				default:
					formatError = AppendRawByte(ref dest, b);
					break;
				}
				if (formatError != FormatError.None)
				{
					return formatError;
				}
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static FormatError AppendFormat<T, U, T0, T1, T2, T3, T4, T5, T6, T7, T8>(this ref T dest, in U format, in T0 arg0, in T1 arg1, in T2 arg2, in T3 arg3, in T4 arg4, in T5 arg5, in T6 arg6, in T7 arg7, in T8 arg8) where T : unmanaged, INativeList<byte>, IUTF8Bytes where U : unmanaged, INativeList<byte>, IUTF8Bytes where T0 : unmanaged, INativeList<byte>, IUTF8Bytes where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes where T4 : unmanaged, INativeList<byte>, IUTF8Bytes where T5 : unmanaged, INativeList<byte>, IUTF8Bytes where T6 : unmanaged, INativeList<byte>, IUTF8Bytes where T7 : unmanaged, INativeList<byte>, IUTF8Bytes where T8 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref U reference = ref UnsafeUtilityExtensions.AsRef(in format);
			int length = reference.Length;
			byte* unsafePtr = reference.GetUnsafePtr();
			int num = 0;
			FormatError formatError = FormatError.None;
			while (num < length)
			{
				byte b = unsafePtr[num++];
				switch (b)
				{
				case 123:
					if (num < length)
					{
						b = unsafePtr[num++];
						formatError = ((b >= 48 && b <= 57 && num < length && unsafePtr[num++] == 125) ? ((int)b switch
						{
							48 => Append(ref dest, in arg0), 
							49 => Append(ref dest, in arg1), 
							50 => Append(ref dest, in arg2), 
							51 => Append(ref dest, in arg3), 
							52 => Append(ref dest, in arg4), 
							53 => Append(ref dest, in arg5), 
							54 => Append(ref dest, in arg6), 
							55 => Append(ref dest, in arg7), 
							56 => Append(ref dest, in arg8), 
							_ => FormatError.BadFormatSpecifier, 
						}) : ((b != 123) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b)));
						break;
					}
					return FormatError.BadFormatSpecifier;
				case 125:
					if (num < length)
					{
						b = unsafePtr[num++];
					}
					else
					{
						formatError = FormatError.BadFormatSpecifier;
					}
					formatError = ((b != 125) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b));
					break;
				default:
					formatError = AppendRawByte(ref dest, b);
					break;
				}
				if (formatError != FormatError.None)
				{
					return formatError;
				}
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static FormatError AppendFormat<T, U, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ref T dest, in U format, in T0 arg0, in T1 arg1, in T2 arg2, in T3 arg3, in T4 arg4, in T5 arg5, in T6 arg6, in T7 arg7, in T8 arg8, in T9 arg9) where T : unmanaged, INativeList<byte>, IUTF8Bytes where U : unmanaged, INativeList<byte>, IUTF8Bytes where T0 : unmanaged, INativeList<byte>, IUTF8Bytes where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes where T4 : unmanaged, INativeList<byte>, IUTF8Bytes where T5 : unmanaged, INativeList<byte>, IUTF8Bytes where T6 : unmanaged, INativeList<byte>, IUTF8Bytes where T7 : unmanaged, INativeList<byte>, IUTF8Bytes where T8 : unmanaged, INativeList<byte>, IUTF8Bytes where T9 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref U reference = ref UnsafeUtilityExtensions.AsRef(in format);
			int length = reference.Length;
			byte* unsafePtr = reference.GetUnsafePtr();
			int num = 0;
			FormatError formatError = FormatError.None;
			while (num < length)
			{
				byte b = unsafePtr[num++];
				switch (b)
				{
				case 123:
					if (num < length)
					{
						b = unsafePtr[num++];
						formatError = ((b >= 48 && b <= 57 && num < length && unsafePtr[num++] == 125) ? ((int)b switch
						{
							48 => Append(ref dest, in arg0), 
							49 => Append(ref dest, in arg1), 
							50 => Append(ref dest, in arg2), 
							51 => Append(ref dest, in arg3), 
							52 => Append(ref dest, in arg4), 
							53 => Append(ref dest, in arg5), 
							54 => Append(ref dest, in arg6), 
							55 => Append(ref dest, in arg7), 
							56 => Append(ref dest, in arg8), 
							57 => Append(ref dest, in arg9), 
							_ => FormatError.BadFormatSpecifier, 
						}) : ((b != 123) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b)));
						break;
					}
					return FormatError.BadFormatSpecifier;
				case 125:
					if (num < length)
					{
						b = unsafePtr[num++];
					}
					else
					{
						formatError = FormatError.BadFormatSpecifier;
					}
					formatError = ((b != 125) ? FormatError.BadFormatSpecifier : AppendRawByte(ref dest, b));
					break;
				default:
					formatError = AppendRawByte(ref dest, b);
					break;
				}
				if (formatError != FormatError.None)
				{
					return formatError;
				}
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		internal static FormatError Append<T>(this ref T fs, char a, char b) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			if ((FormatError.None | Append(ref fs, (Unicode.Rune)a) | Append(ref fs, (Unicode.Rune)b)) != FormatError.None)
			{
				return FormatError.Overflow;
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		internal static FormatError Append<T>(this ref T fs, char a, char b, char c) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			if ((FormatError.None | Append(ref fs, (Unicode.Rune)a) | Append(ref fs, (Unicode.Rune)b) | Append(ref fs, (Unicode.Rune)c)) != FormatError.None)
			{
				return FormatError.Overflow;
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		internal static FormatError Append<T>(this ref T fs, char a, char b, char c, char d, char e, char f, char g, char h) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			if ((FormatError.None | Append(ref fs, (Unicode.Rune)a) | Append(ref fs, (Unicode.Rune)b) | Append(ref fs, (Unicode.Rune)c) | Append(ref fs, (Unicode.Rune)d) | Append(ref fs, (Unicode.Rune)e) | Append(ref fs, (Unicode.Rune)f) | Append(ref fs, (Unicode.Rune)g) | Append(ref fs, (Unicode.Rune)h)) != FormatError.None)
			{
				return FormatError.Overflow;
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		internal unsafe static FormatError AppendScientific<T>(this ref T fs, char* source, int sourceLength, int decimalExponent, char decimalSeparator = '.') where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FormatError result;
			if ((result = Append(ref fs, *source)) != FormatError.None)
			{
				return result;
			}
			if (sourceLength > 1)
			{
				if ((result = Append(ref fs, decimalSeparator)) != FormatError.None)
				{
					return result;
				}
				for (int i = 1; i < sourceLength; i++)
				{
					if ((result = Append(ref fs, source[i])) != FormatError.None)
					{
						return result;
					}
				}
			}
			if ((result = Append(ref fs, 'E')) != FormatError.None)
			{
				return result;
			}
			if (decimalExponent < 0)
			{
				if ((result = Append(ref fs, '-')) != FormatError.None)
				{
					return result;
				}
				decimalExponent *= -1;
				decimalExponent -= sourceLength - 1;
			}
			else
			{
				if ((result = Append(ref fs, '+')) != FormatError.None)
				{
					return result;
				}
				decimalExponent += sourceLength - 1;
			}
			char* ptr = stackalloc char[2];
			for (int j = 0; j < 2; j++)
			{
				int num = decimalExponent % 10;
				ptr[1 - j] = (char)(48 + num);
				decimalExponent /= 10;
			}
			for (int k = 0; k < 2; k++)
			{
				if ((result = Append(ref fs, ptr[k])) != FormatError.None)
				{
					return result;
				}
			}
			return FormatError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		internal static bool Found<T>(this ref T fs, ref int offset, char a, char b, char c) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int num = offset;
			if ((Read(ref fs, ref offset).value | 0x20) == a && (Read(ref fs, ref offset).value | 0x20) == b && (Read(ref fs, ref offset).value | 0x20) == c)
			{
				return true;
			}
			offset = num;
			return false;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		internal static bool Found<T>(this ref T fs, ref int offset, char a, char b, char c, char d, char e, char f, char g, char h) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int num = offset;
			if ((Read(ref fs, ref offset).value | 0x20) == a && (Read(ref fs, ref offset).value | 0x20) == b && (Read(ref fs, ref offset).value | 0x20) == c && (Read(ref fs, ref offset).value | 0x20) == d && (Read(ref fs, ref offset).value | 0x20) == e && (Read(ref fs, ref offset).value | 0x20) == f && (Read(ref fs, ref offset).value | 0x20) == g && (Read(ref fs, ref offset).value | 0x20) == h)
			{
				return true;
			}
			offset = num;
			return false;
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		internal static void CheckSubstringInRange(int strLength, int startIndex, int length)
		{
			if (startIndex < 0)
			{
				throw new ArgumentOutOfRangeException($"startIndex {startIndex} must be positive.");
			}
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException($"length {length} cannot be negative.");
			}
			if (startIndex > strLength)
			{
				throw new ArgumentOutOfRangeException($"startIndex {startIndex} cannot be larger than string length {strLength}.");
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static T Substring<T>(this ref T str, int startIndex, int length) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			length = math.min(length, str.Length - startIndex);
			T fs = new T();
			Append(ref fs, str.GetUnsafePtr() + startIndex, length);
			return fs;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public static T Substring<T>(this ref T str, int startIndex) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			return Substring(ref str, startIndex, str.Length - startIndex);
		}

		public unsafe static NativeText Substring(this ref NativeText str, int startIndex, int length, AllocatorManager.AllocatorHandle allocator)
		{
			length = math.min(length, str.Length - startIndex);
			NativeText fs = new NativeText(length, allocator);
			Append(ref fs, str.GetUnsafePtr() + startIndex, length);
			return fs;
		}

		public static NativeText Substring(this ref NativeText str, int startIndex, AllocatorManager.AllocatorHandle allocator)
		{
			return str.Substring(startIndex, str.Length - startIndex);
		}

		public unsafe static NativeText Substring(this ref NativeText str, int startIndex, int length)
		{
			return str.Substring(startIndex, length, str.m_Data->m_UntypedListData.Allocator);
		}

		public static NativeText Substring(this ref NativeText str, int startIndex)
		{
			return str.Substring(startIndex, str.Length - startIndex);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public static int IndexOf<T>(this ref T fs, Unicode.Rune rune) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int length = fs.Length;
			int num = 0;
			while (num < length)
			{
				int index = num;
				if (Read(ref fs, ref index).value == rune.value)
				{
					return num;
				}
				num = index;
			}
			return -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static int IndexOf<T>(this ref T fs, byte* bytes, int bytesLen) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			byte* unsafePtr = fs.GetUnsafePtr();
			int length = fs.Length;
			for (int i = 0; i <= length - bytesLen; i++)
			{
				int num = 0;
				while (true)
				{
					if (num < bytesLen)
					{
						if (unsafePtr[i + num] != bytes[num])
						{
							break;
						}
						num++;
						continue;
					}
					return i;
				}
			}
			return -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static int IndexOf<T>(this ref T fs, byte* bytes, int bytesLen, int startIndex, int distance = int.MaxValue) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			byte* unsafePtr = fs.GetUnsafePtr();
			int length = fs.Length;
			int num = Math.Min(distance - 1, length - bytesLen);
			for (int i = startIndex; i <= num; i++)
			{
				int num2 = 0;
				while (true)
				{
					if (num2 < bytesLen)
					{
						if (unsafePtr[i + num2] != bytes[num2])
						{
							break;
						}
						num2++;
						continue;
					}
					return i;
				}
			}
			return -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static int IndexOf<T, T2>(this ref T fs, in T2 other) where T : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref T2 reference = ref UnsafeUtilityExtensions.AsRef(in other);
			return IndexOf(ref fs, reference.GetUnsafePtr(), reference.Length);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static int IndexOf<T, T2>(this ref T fs, in T2 other, int startIndex, int distance = int.MaxValue) where T : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref T2 reference = ref UnsafeUtilityExtensions.AsRef(in other);
			return IndexOf(ref fs, reference.GetUnsafePtr(), reference.Length, startIndex, distance);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public static bool Contains<T, T2>(this ref T fs, in T2 other) where T : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			return IndexOf(ref fs, in other) != -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public static int LastIndexOf<T>(this ref T fs, Unicode.Rune rune) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			if (Unicode.IsValidCodePoint(rune.value))
			{
				for (int num = fs.Length - 1; num >= 0; num--)
				{
					Unicode.Rune rune2 = Peek(ref fs, num);
					if (Unicode.IsValidCodePoint(rune2.value) && rune2.value == rune.value)
					{
						return num;
					}
				}
			}
			return -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static int LastIndexOf<T>(this ref T fs, byte* bytes, int bytesLen) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			byte* unsafePtr = fs.GetUnsafePtr();
			for (int num = fs.Length - bytesLen; num >= 0; num--)
			{
				int num2 = 0;
				while (true)
				{
					if (num2 < bytesLen)
					{
						if (unsafePtr[num + num2] != bytes[num2])
						{
							break;
						}
						num2++;
						continue;
					}
					return num;
				}
			}
			return -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static int LastIndexOf<T>(this ref T fs, byte* bytes, int bytesLen, int startIndex, int distance = int.MaxValue) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			byte* unsafePtr = fs.GetUnsafePtr();
			startIndex = Math.Min(fs.Length - bytesLen, startIndex);
			int num = Math.Max(0, startIndex - distance);
			for (int num2 = startIndex; num2 >= num; num2--)
			{
				int num3 = 0;
				while (true)
				{
					if (num3 < bytesLen)
					{
						if (unsafePtr[num2 + num3] != bytes[num3])
						{
							break;
						}
						num3++;
						continue;
					}
					return num2;
				}
			}
			return -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static int LastIndexOf<T, T2>(this ref T fs, in T2 other) where T : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref T2 reference = ref UnsafeUtilityExtensions.AsRef(in other);
			return LastIndexOf(ref fs, reference.GetUnsafePtr(), reference.Length);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static int LastIndexOf<T, T2>(this ref T fs, in T2 other, int startIndex, int distance = int.MaxValue) where T : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref T2 reference = ref UnsafeUtilityExtensions.AsRef(in other);
			return LastIndexOf(ref fs, reference.GetUnsafePtr(), reference.Length, startIndex, distance);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static int CompareTo<T>(this ref T fs, byte* bytes, int bytesLen) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			byte* unsafePtr = fs.GetUnsafePtr();
			int length = fs.Length;
			int num = ((length < bytesLen) ? length : bytesLen);
			for (int i = 0; i < num; i++)
			{
				if (unsafePtr[i] < bytes[i])
				{
					return -1;
				}
				if (unsafePtr[i] > bytes[i])
				{
					return 1;
				}
			}
			if (length < bytesLen)
			{
				return -1;
			}
			if (length > bytesLen)
			{
				return 1;
			}
			return 0;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static int CompareTo<T, T2>(this ref T fs, in T2 other) where T : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref T2 reference = ref UnsafeUtilityExtensions.AsRef(in other);
			return CompareTo(ref fs, reference.GetUnsafePtr(), reference.Length);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static bool Equals<T>(this ref T fs, byte* bytes, int bytesLen) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			byte* unsafePtr = fs.GetUnsafePtr();
			if (fs.Length != bytesLen)
			{
				return false;
			}
			if (unsafePtr == bytes)
			{
				return true;
			}
			return CompareTo(ref fs, bytes, bytesLen) == 0;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static bool Equals<T, T2>(this ref T fs, in T2 other) where T : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			ref T2 reference = ref UnsafeUtilityExtensions.AsRef(in other);
			return Equals(ref fs, reference.GetUnsafePtr(), reference.Length);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static Unicode.Rune Peek<T>(this ref T fs, int index) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			if (index >= fs.Length)
			{
				return Unicode.BadRune;
			}
			Unicode.Utf8ToUcs(out var rune, fs.GetUnsafePtr(), ref index, fs.Capacity);
			return rune;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static Unicode.Rune Read<T>(this ref T fs, ref int index) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			if (index >= fs.Length)
			{
				return Unicode.BadRune;
			}
			Unicode.Utf8ToUcs(out var rune, fs.GetUnsafePtr(), ref index, fs.Capacity);
			return rune;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static FormatError Write<T>(this ref T fs, ref int index, Unicode.Rune rune) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			if (Unicode.UcsToUtf8(fs.GetUnsafePtr(), ref index, fs.Capacity, rune) != ConversionError.None)
			{
				return FormatError.Overflow;
			}
			return FormatError.None;
		}

		[ExcludeFromBurstCompatTesting("Returns managed string")]
		public unsafe static string ConvertToString<T>(this ref T fs) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			char* ptr = stackalloc char[fs.Length * 2];
			int utf16Length = 0;
			Unicode.Utf8ToUtf16(fs.GetUnsafePtr(), fs.Length, ptr, out utf16Length, fs.Length * 2);
			return new string(ptr, 0, utf16Length);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static int ComputeHashCode<T>(this ref T fs) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			return (int)CollectionHelper.Hash(fs.GetUnsafePtr(), fs.Length);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public static int EffectiveSizeOf<T>(this ref T fs) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			return 2 + fs.Length + 1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static bool StartsWith<T>(this ref T fs, Unicode.Rune rune) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int num = rune.LengthInUtf8Bytes();
			if (fs.Length >= num)
			{
				return UTF8ArrayUnsafeUtility.StrCmp(fs.GetUnsafePtr(), num, &rune, 1) == 0;
			}
			return false;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static bool StartsWith<T, U>(this ref T fs, in U other) where T : unmanaged, INativeList<byte>, IUTF8Bytes where U : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int length = other.Length;
			if (fs.Length >= length)
			{
				return UTF8ArrayUnsafeUtility.StrCmp(fs.GetUnsafePtr(), length, other.GetUnsafePtr(), length) == 0;
			}
			return false;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static bool EndsWith<T>(this ref T fs, Unicode.Rune rune) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int num = rune.LengthInUtf8Bytes();
			if (fs.Length >= num)
			{
				return UTF8ArrayUnsafeUtility.StrCmp(fs.GetUnsafePtr() + fs.Length - num, num, &rune, 1) == 0;
			}
			return false;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString128Bytes),
			typeof(FixedString128Bytes)
		})]
		public unsafe static bool EndsWith<T, U>(this ref T fs, in U other) where T : unmanaged, INativeList<byte>, IUTF8Bytes where U : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int length = other.Length;
			if (fs.Length >= length)
			{
				return UTF8ArrayUnsafeUtility.StrCmp(fs.GetUnsafePtr() + fs.Length - length, length, other.GetUnsafePtr(), length) == 0;
			}
			return false;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		internal unsafe static int TrimStartIndex<T>(this ref T fs) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int length = fs.Length;
			byte* unsafePtr = fs.GetUnsafePtr();
			int index = 0;
			int num;
			Unicode.Rune rune;
			do
			{
				num = index;
			}
			while (Unicode.Utf8ToUcs(out rune, unsafePtr, ref index, length) == ConversionError.None && rune.IsWhiteSpace());
			return index - (index - num);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		internal unsafe static int TrimStartIndex<T>(this ref T fs, ReadOnlySpan<Unicode.Rune> trimRunes) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int length = fs.Length;
			byte* unsafePtr = fs.GetUnsafePtr();
			int index = 0;
			int num;
			ConversionError conversionError;
			bool flag;
			do
			{
				num = index;
				conversionError = Unicode.Utf8ToUcs(out var rune, unsafePtr, ref index, length);
				flag = false;
				int i = 0;
				for (int length2 = trimRunes.Length; i < length2; i++)
				{
					if (flag)
					{
						break;
					}
					flag |= trimRunes[i] == rune;
				}
			}
			while (conversionError == ConversionError.None && flag);
			return index - (index - num);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		internal unsafe static int TrimEndIndex<T>(this ref T fs) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int length = fs.Length;
			byte* unsafePtr = fs.GetUnsafePtr();
			int index = length;
			int num;
			Unicode.Rune rune;
			do
			{
				num = index;
			}
			while (Unicode.Utf8ToUcsReverse(out rune, unsafePtr, ref index, length) == ConversionError.None && rune.IsWhiteSpace());
			return index + (num - index);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		internal unsafe static int TrimEndIndex<T>(this ref T fs, ReadOnlySpan<Unicode.Rune> trimRunes) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int length = fs.Length;
			byte* unsafePtr = fs.GetUnsafePtr();
			int index = length;
			int num;
			ConversionError conversionError;
			bool flag;
			do
			{
				num = index;
				conversionError = Unicode.Utf8ToUcsReverse(out var rune, unsafePtr, ref index, length);
				flag = false;
				int i = 0;
				for (int length2 = trimRunes.Length; i < length2; i++)
				{
					if (flag)
					{
						break;
					}
					flag |= trimRunes[i] == rune;
				}
			}
			while (conversionError == ConversionError.None && flag);
			return index + (num - index);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static T TrimStart<T>(this ref T fs) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int num = TrimStartIndex(ref fs);
			T fs2 = new T();
			Append(ref fs2, fs.GetUnsafePtr() + num, fs.Length - num);
			return fs2;
		}

		public unsafe static UnsafeText TrimStart(this ref UnsafeText fs, AllocatorManager.AllocatorHandle allocator)
		{
			int num = TrimStartIndex(ref fs);
			int num2 = fs.Length - num;
			UnsafeText fs2 = new UnsafeText(num2, allocator);
			Append(ref fs2, fs.GetUnsafePtr() + num, num2);
			return fs2;
		}

		public unsafe static NativeText TrimStart(this ref NativeText fs, AllocatorManager.AllocatorHandle allocator)
		{
			int num = TrimStartIndex(ref fs);
			int num2 = fs.Length - num;
			NativeText fs2 = new NativeText(num2, allocator);
			Append(ref fs2, fs.GetUnsafePtr() + num, num2);
			return fs2;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static T TrimStart<T>(this ref T fs, ReadOnlySpan<Unicode.Rune> trimRunes) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int num = TrimStartIndex(ref fs, trimRunes);
			T fs2 = new T();
			Append(ref fs2, fs.GetUnsafePtr() + num, fs.Length - num);
			return fs2;
		}

		public unsafe static UnsafeText TrimStart(this ref UnsafeText fs, AllocatorManager.AllocatorHandle allocator, ReadOnlySpan<Unicode.Rune> trimRunes)
		{
			int num = TrimStartIndex(ref fs, trimRunes);
			int num2 = fs.Length - num;
			UnsafeText fs2 = new UnsafeText(num2, allocator);
			Append(ref fs2, fs.GetUnsafePtr() + num, num2);
			return fs2;
		}

		public unsafe static NativeText TrimStart(this ref NativeText fs, AllocatorManager.AllocatorHandle allocator, ReadOnlySpan<Unicode.Rune> trimRunes)
		{
			int num = TrimStartIndex(ref fs, trimRunes);
			int num2 = fs.Length - num;
			NativeText fs2 = new NativeText(num2, allocator);
			Append(ref fs2, fs.GetUnsafePtr() + num, num2);
			return fs2;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static T TrimEnd<T>(this ref T fs) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int utf8BytesLength = TrimEndIndex(ref fs);
			T fs2 = new T();
			Append(ref fs2, fs.GetUnsafePtr(), utf8BytesLength);
			return fs2;
		}

		public unsafe static UnsafeText TrimEnd(this ref UnsafeText fs, AllocatorManager.AllocatorHandle allocator)
		{
			int num = TrimEndIndex(ref fs);
			UnsafeText fs2 = new UnsafeText(num, allocator);
			Append(ref fs2, fs.GetUnsafePtr(), num);
			return fs2;
		}

		public unsafe static NativeText TrimEnd(this ref NativeText fs, AllocatorManager.AllocatorHandle allocator)
		{
			int num = TrimEndIndex(ref fs);
			NativeText fs2 = new NativeText(num, allocator);
			Append(ref fs2, fs.GetUnsafePtr(), num);
			return fs2;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static T TrimEnd<T>(this ref T fs, ReadOnlySpan<Unicode.Rune> trimRunes) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int utf8BytesLength = TrimEndIndex(ref fs, trimRunes);
			T fs2 = new T();
			Append(ref fs2, fs.GetUnsafePtr(), utf8BytesLength);
			return fs2;
		}

		public unsafe static UnsafeText TrimEnd(this ref UnsafeText fs, AllocatorManager.AllocatorHandle allocator, ReadOnlySpan<Unicode.Rune> trimRunes)
		{
			int num = TrimEndIndex(ref fs, trimRunes);
			UnsafeText fs2 = new UnsafeText(num, allocator);
			Append(ref fs2, fs.GetUnsafePtr(), num);
			return fs2;
		}

		public unsafe static NativeText TrimEnd(this ref NativeText fs, AllocatorManager.AllocatorHandle allocator, ReadOnlySpan<Unicode.Rune> trimRunes)
		{
			int num = TrimEndIndex(ref fs, trimRunes);
			NativeText fs2 = new NativeText(num, allocator);
			Append(ref fs2, fs.GetUnsafePtr(), num);
			return fs2;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static T Trim<T>(this ref T fs) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int num = TrimStartIndex(ref fs);
			if (num == fs.Length)
			{
				return new T();
			}
			int num2 = TrimEndIndex(ref fs);
			T fs2 = new T();
			Append(ref fs2, fs.GetUnsafePtr() + num, num2 - num);
			return fs2;
		}

		public unsafe static UnsafeText Trim(this ref UnsafeText fs, AllocatorManager.AllocatorHandle allocator)
		{
			int num = TrimStartIndex(ref fs);
			if (num == fs.Length)
			{
				return new UnsafeText(0, allocator);
			}
			int num2 = TrimEndIndex(ref fs) - num;
			UnsafeText fs2 = new UnsafeText(num2, allocator);
			Append(ref fs2, fs.GetUnsafePtr() + num, num2);
			return fs2;
		}

		public unsafe static NativeText Trim(this ref NativeText fs, AllocatorManager.AllocatorHandle allocator)
		{
			int num = TrimStartIndex(ref fs);
			if (num == fs.Length)
			{
				return new NativeText(0, allocator);
			}
			int num2 = TrimEndIndex(ref fs) - num;
			NativeText fs2 = new NativeText(num2, allocator);
			Append(ref fs2, fs.GetUnsafePtr() + num, num2);
			return fs2;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static T Trim<T>(this ref T fs, ReadOnlySpan<Unicode.Rune> trimRunes) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int num = TrimStartIndex(ref fs, trimRunes);
			if (num == fs.Length)
			{
				return new T();
			}
			int num2 = TrimEndIndex(ref fs, trimRunes);
			T fs2 = new T();
			Append(ref fs2, fs.GetUnsafePtr() + num, num2 - num);
			return fs2;
		}

		public unsafe static UnsafeText Trim(this ref UnsafeText fs, AllocatorManager.AllocatorHandle allocator, ReadOnlySpan<Unicode.Rune> trimRunes)
		{
			int num = TrimStartIndex(ref fs, trimRunes);
			if (num == fs.Length)
			{
				return new UnsafeText(0, allocator);
			}
			int num2 = TrimEndIndex(ref fs) - num;
			UnsafeText fs2 = new UnsafeText(num2, allocator);
			Append(ref fs2, fs.GetUnsafePtr() + num, num2);
			return fs2;
		}

		public unsafe static NativeText Trim(this ref NativeText fs, AllocatorManager.AllocatorHandle allocator, ReadOnlySpan<Unicode.Rune> trimRunes)
		{
			int num = TrimStartIndex(ref fs, trimRunes);
			if (num == fs.Length)
			{
				return new NativeText(0, allocator);
			}
			int num2 = TrimEndIndex(ref fs) - num;
			NativeText fs2 = new NativeText(num2, allocator);
			Append(ref fs2, fs.GetUnsafePtr() + num, num2);
			return fs2;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static T ToLowerAscii<T>(this ref T fs) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int length = fs.Length;
			byte* unsafePtr = fs.GetUnsafePtr();
			T fs2 = new T();
			ConversionError conversionError = ConversionError.None;
			int index = 0;
			while (index < length && conversionError == ConversionError.None)
			{
				conversionError = Unicode.Utf8ToUcs(out var rune, unsafePtr, ref index, length);
				Append(ref fs2, rune.ToLowerAscii());
			}
			return fs2;
		}

		public unsafe static UnsafeText ToLowerAscii(this ref UnsafeText fs, AllocatorManager.AllocatorHandle allocator)
		{
			int length = fs.Length;
			byte* unsafePtr = fs.GetUnsafePtr();
			UnsafeText fs2 = new UnsafeText(length, allocator);
			ConversionError conversionError = ConversionError.None;
			int index = 0;
			while (index < length && conversionError == ConversionError.None)
			{
				conversionError = Unicode.Utf8ToUcs(out var rune, unsafePtr, ref index, length);
				Append(ref fs2, rune.ToLowerAscii());
			}
			return fs2;
		}

		public unsafe static NativeText ToLowerAscii(this ref NativeText fs, AllocatorManager.AllocatorHandle allocator)
		{
			int length = fs.Length;
			byte* unsafePtr = fs.GetUnsafePtr();
			NativeText fs2 = new NativeText(length, allocator);
			ConversionError conversionError = ConversionError.None;
			int index = 0;
			while (index < length && conversionError == ConversionError.None)
			{
				conversionError = Unicode.Utf8ToUcs(out var rune, unsafePtr, ref index, length);
				Append(ref fs2, rune.ToLowerAscii());
			}
			return fs2;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public unsafe static T ToUpperAscii<T>(this ref T fs) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int length = fs.Length;
			byte* unsafePtr = fs.GetUnsafePtr();
			T fs2 = new T();
			ConversionError conversionError = ConversionError.None;
			int index = 0;
			while (index < length && conversionError == ConversionError.None)
			{
				conversionError = Unicode.Utf8ToUcs(out var rune, unsafePtr, ref index, length);
				Append(ref fs2, rune.ToUpperAscii());
			}
			return fs2;
		}

		public unsafe static UnsafeText ToUpperAscii(this ref UnsafeText fs, AllocatorManager.AllocatorHandle allocator)
		{
			int length = fs.Length;
			byte* unsafePtr = fs.GetUnsafePtr();
			UnsafeText fs2 = new UnsafeText(length, allocator);
			ConversionError conversionError = ConversionError.None;
			int index = 0;
			while (index < length && conversionError == ConversionError.None)
			{
				conversionError = Unicode.Utf8ToUcs(out var rune, unsafePtr, ref index, length);
				Append(ref fs2, rune.ToUpperAscii());
			}
			return fs2;
		}

		public unsafe static NativeText ToUpperAscii(this ref NativeText fs, AllocatorManager.AllocatorHandle allocator)
		{
			int length = fs.Length;
			byte* unsafePtr = fs.GetUnsafePtr();
			NativeText fs2 = new NativeText(length, allocator);
			ConversionError conversionError = ConversionError.None;
			int index = 0;
			while (index < length && conversionError == ConversionError.None)
			{
				conversionError = Unicode.Utf8ToUcs(out var rune, unsafePtr, ref index, length);
				Append(ref fs2, rune.ToUpperAscii());
			}
			return fs2;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		internal static bool ParseLongInternal<T>(ref T fs, ref int offset, out long value) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int num = offset;
			int num2 = 1;
			if (offset < fs.Length)
			{
				if (Peek(ref fs, offset).value == 43)
				{
					Read(ref fs, ref offset);
				}
				else if (Peek(ref fs, offset).value == 45)
				{
					num2 = -1;
					Read(ref fs, ref offset);
				}
			}
			int num3 = offset;
			value = 0L;
			while (offset < fs.Length && Unicode.Rune.IsDigit(Peek(ref fs, offset)))
			{
				value *= 10L;
				value += Read(ref fs, ref offset).value - 48;
			}
			value = num2 * value;
			if (offset == num3)
			{
				offset = num;
				return false;
			}
			return true;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public static ParseError Parse<T>(this ref T fs, ref int offset, ref int output) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			if (!ParseLongInternal(ref fs, ref offset, out var value))
			{
				return ParseError.Syntax;
			}
			if (value > int.MaxValue)
			{
				return ParseError.Overflow;
			}
			if (value < int.MinValue)
			{
				return ParseError.Overflow;
			}
			output = (int)value;
			return ParseError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public static ParseError Parse<T>(this ref T fs, ref int offset, ref uint output) where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			if (!ParseLongInternal(ref fs, ref offset, out var value))
			{
				return ParseError.Syntax;
			}
			if (value > uint.MaxValue)
			{
				return ParseError.Overflow;
			}
			if (value < 0)
			{
				return ParseError.Overflow;
			}
			output = (uint)value;
			return ParseError.None;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString128Bytes) })]
		public static ParseError Parse<T>(this ref T fs, ref int offset, ref float output, char decimalSeparator = '.') where T : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			int num = offset;
			int num2 = 1;
			if (offset < fs.Length)
			{
				if (Peek(ref fs, offset).value == 43)
				{
					Read(ref fs, ref offset);
				}
				else if (Peek(ref fs, offset).value == 45)
				{
					num2 = -1;
					Read(ref fs, ref offset);
				}
			}
			if (Found(ref fs, ref offset, 'n', 'a', 'n'))
			{
				FixedStringUtils.UintFloatUnion uintFloatUnion = new FixedStringUtils.UintFloatUnion
				{
					uintValue = 4290772992u
				};
				output = uintFloatUnion.floatValue;
				return ParseError.None;
			}
			if (Found(ref fs, ref offset, 'i', 'n', 'f', 'i', 'n', 'i', 't', 'y'))
			{
				output = ((num2 == 1) ? float.PositiveInfinity : float.NegativeInfinity);
				return ParseError.None;
			}
			ulong num3 = 0uL;
			int num4 = 0;
			int num5 = 0;
			int num6 = 0;
			while (offset < fs.Length && Unicode.Rune.IsDigit(Peek(ref fs, offset)))
			{
				num6++;
				if (num4 < 9)
				{
					long num7 = (long)(num3 * 10) + (long)(Peek(ref fs, offset).value - 48);
					if ((ulong)num7 > num3)
					{
						num4++;
					}
					num3 = (ulong)num7;
				}
				else
				{
					num5--;
				}
				Read(ref fs, ref offset);
			}
			if (offset < fs.Length && Peek(ref fs, offset).value == decimalSeparator)
			{
				Read(ref fs, ref offset);
				while (offset < fs.Length && Unicode.Rune.IsDigit(Peek(ref fs, offset)))
				{
					num6++;
					if (num4 < 9)
					{
						long num8 = (long)(num3 * 10) + (long)(Peek(ref fs, offset).value - 48);
						if ((ulong)num8 > num3)
						{
							num4++;
						}
						num3 = (ulong)num8;
						num5++;
					}
					Read(ref fs, ref offset);
				}
			}
			if (num6 == 0)
			{
				offset = num;
				return ParseError.Syntax;
			}
			int num9 = 0;
			int num10 = 1;
			if (offset < fs.Length && (Peek(ref fs, offset).value | 0x20) == 101)
			{
				Read(ref fs, ref offset);
				if (offset < fs.Length)
				{
					if (Peek(ref fs, offset).value == 43)
					{
						Read(ref fs, ref offset);
					}
					else if (Peek(ref fs, offset).value == 45)
					{
						num10 = -1;
						Read(ref fs, ref offset);
					}
				}
				int num11 = offset;
				while (offset < fs.Length && Unicode.Rune.IsDigit(Peek(ref fs, offset)))
				{
					num9 = num9 * 10 + (Peek(ref fs, offset).value - 48);
					Read(ref fs, ref offset);
				}
				if (offset == num11)
				{
					offset = num;
					return ParseError.Syntax;
				}
				if (num9 > 38)
				{
					if (num10 == 1)
					{
						return ParseError.Overflow;
					}
					return ParseError.Underflow;
				}
			}
			num9 = num9 * num10 - num5;
			ParseError parseError = FixedStringUtils.Base10ToBase2(ref output, num3, num9);
			if (parseError != ParseError.None)
			{
				return parseError;
			}
			output *= num2;
			return ParseError.None;
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class FixedString
	{
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, int arg1, int arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, int arg1, int arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, int arg1, int arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, int arg1, int arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, float arg1, int arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, float arg1, int arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, float arg1, int arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, float arg1, int arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, string arg1, int arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, string arg1, int arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, string arg1, int arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, string arg1, int arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, T1 arg1, int arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, T1 arg1, int arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, T1 arg1, int arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, T2 arg1, int arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg2);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in fs, in fs2);
			return dest;
		}

		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, int arg1, float arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, int arg1, float arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, int arg1, float arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, int arg1, float arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, float arg1, float arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, float arg1, float arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, float arg1, float arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, float arg1, float arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, string arg1, float arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, string arg1, float arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, string arg1, float arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, string arg1, float arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, T1 arg1, float arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, T1 arg1, float arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, T1 arg1, float arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, T2 arg1, float arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg2);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in fs, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, int arg1, string arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, int arg1, string arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, int arg1, string arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, int arg1, string arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, float arg1, string arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, float arg1, string arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, float arg1, string arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, float arg1, string arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, string arg1, string arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, string arg1, string arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, string arg1, string arg2, int arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, string arg1, string arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, T1 arg1, string arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, T1 arg1, string arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, T1 arg1, string arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, T2 arg1, string arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg2);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in fs, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, int arg1, T1 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, int arg1, T1 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, int arg1, T1 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, int arg1, T2 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in arg2, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, float arg1, T1 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, float arg1, T1 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, float arg1, T1 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, float arg1, T2 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in arg2, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, string arg1, T1 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, string arg1, T1 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, string arg1, T1 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, string arg1, T2 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in arg2, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, int arg0, T1 arg1, T2 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in arg2, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, float arg0, T1 arg1, T2 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in arg2, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, string arg0, T1 arg1, T2 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in arg2, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2, T3>(FixedString512Bytes formatString, T1 arg0, T2 arg1, T3 arg2, int arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in arg2, in fs);
			return dest;
		}

		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, int arg1, int arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, int arg1, int arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, int arg1, int arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, int arg1, int arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, float arg1, int arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, float arg1, int arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, float arg1, int arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, float arg1, int arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, string arg1, int arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, string arg1, int arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, string arg1, int arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, string arg1, int arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, T1 arg1, int arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, T1 arg1, int arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, T1 arg1, int arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, T2 arg1, int arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg2);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in fs, in fs2);
			return dest;
		}

		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, int arg1, float arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, int arg1, float arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, int arg1, float arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, int arg1, float arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, float arg1, float arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, float arg1, float arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, float arg1, float arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, float arg1, float arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, string arg1, float arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, string arg1, float arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, string arg1, float arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, string arg1, float arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, T1 arg1, float arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, T1 arg1, float arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, T1 arg1, float arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, T2 arg1, float arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg2);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in fs, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, int arg1, string arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, int arg1, string arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, int arg1, string arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, int arg1, string arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, float arg1, string arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, float arg1, string arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, float arg1, string arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, float arg1, string arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, string arg1, string arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, string arg1, string arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, string arg1, string arg2, float arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, string arg1, string arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, T1 arg1, string arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, T1 arg1, string arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, T1 arg1, string arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, T2 arg1, string arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg2);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in fs, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, int arg1, T1 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, int arg1, T1 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, int arg1, T1 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, int arg1, T2 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in arg2, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, float arg1, T1 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, float arg1, T1 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, float arg1, T1 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, float arg1, T2 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in arg2, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, string arg1, T1 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, string arg1, T1 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, string arg1, T1 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, string arg1, T2 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in arg2, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, int arg0, T1 arg1, T2 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in arg2, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, float arg0, T1 arg1, T2 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in arg2, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, string arg0, T1 arg1, T2 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in arg2, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2, T3>(FixedString512Bytes formatString, T1 arg0, T2 arg1, T3 arg2, float arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in arg2, in fs);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, int arg1, int arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, int arg1, int arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, int arg1, int arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, int arg1, int arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, float arg1, int arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, float arg1, int arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, float arg1, int arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, float arg1, int arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, string arg1, int arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, string arg1, int arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, string arg1, int arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, string arg1, int arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, T1 arg1, int arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, T1 arg1, int arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, T1 arg1, int arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, T2 arg1, int arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg2);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in fs, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, int arg1, float arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, int arg1, float arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, int arg1, float arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, int arg1, float arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, float arg1, float arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, float arg1, float arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, float arg1, float arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, float arg1, float arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, string arg1, float arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, string arg1, float arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, string arg1, float arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, string arg1, float arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, T1 arg1, float arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, T1 arg1, float arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, T1 arg1, float arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, T2 arg1, float arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg2);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in fs, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, int arg1, string arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, int arg1, string arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, int arg1, string arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, int arg1, string arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, float arg1, string arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, float arg1, string arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, float arg1, string arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, float arg1, string arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, int arg0, string arg1, string arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, float arg0, string arg1, string arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format(FixedString512Bytes formatString, string arg0, string arg1, string arg2, string arg3)
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedString32Bytes fs4 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs4, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in fs4);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, T1 arg0, string arg1, string arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, T1 arg1, string arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, T1 arg1, string arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, T1 arg1, string arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, T2 arg1, string arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg2);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in fs, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, int arg1, T1 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, int arg1, T1 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, int arg1, T1 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, int arg1, T2 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in arg2, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, float arg1, T1 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, float arg1, T1 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, float arg1, T1 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, float arg1, T2 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in arg2, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, string arg1, T1 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, string arg1, T1 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, string arg1, T1 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, string arg1, T2 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in arg2, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, int arg0, T1 arg1, T2 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in arg2, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, float arg0, T1 arg1, T2 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in arg2, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, string arg0, T1 arg1, T2 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in arg2, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2, T3>(FixedString512Bytes formatString, T1 arg0, T2 arg1, T3 arg2, string arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg3);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in arg2, in fs);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, int arg1, int arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, int arg1, int arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, int arg1, int arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, int arg1, int arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, float arg1, int arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, float arg1, int arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, float arg1, int arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, float arg1, int arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, string arg1, int arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, string arg1, int arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, string arg1, int arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, string arg1, int arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, int arg0, T1 arg1, int arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, float arg0, T1 arg1, int arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, string arg0, T1 arg1, int arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2, T3>(FixedString512Bytes formatString, T1 arg0, T2 arg1, int arg2, T3 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in fs, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, int arg1, float arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, int arg1, float arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, int arg1, float arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, int arg1, float arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, float arg1, float arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, float arg1, float arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, float arg1, float arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, float arg1, float arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, string arg1, float arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, string arg1, float arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, string arg1, float arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, string arg1, float arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, int arg0, T1 arg1, float arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, float arg0, T1 arg1, float arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, string arg0, T1 arg1, float arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2, T3>(FixedString512Bytes formatString, T1 arg0, T2 arg1, float arg2, T3 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in fs, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, int arg1, string arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, int arg1, string arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, int arg1, string arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, int arg1, string arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, float arg1, string arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, float arg1, string arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, float arg1, string arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, float arg1, string arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, int arg0, string arg1, string arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, float arg0, string arg1, string arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1>(FixedString512Bytes formatString, string arg0, string arg1, string arg2, T1 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, T1 arg0, string arg1, string arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, int arg0, T1 arg1, string arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, float arg0, T1 arg1, string arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, string arg0, T1 arg1, string arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2, T3>(FixedString512Bytes formatString, T1 arg0, T2 arg1, string arg2, T3 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in fs, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, int arg0, int arg1, T1 arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, float arg0, int arg1, T1 arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, string arg0, int arg1, T1 arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2, T3>(FixedString512Bytes formatString, T1 arg0, int arg1, T2 arg2, T3 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in arg2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, int arg0, float arg1, T1 arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, float arg0, float arg1, T1 arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, string arg0, float arg1, T1 arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2, T3>(FixedString512Bytes formatString, T1 arg0, float arg1, T2 arg2, T3 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in arg2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, int arg0, string arg1, T1 arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, float arg0, string arg1, T1 arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2>(FixedString512Bytes formatString, string arg0, string arg1, T1 arg2, T2 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2, T3>(FixedString512Bytes formatString, T1 arg0, string arg1, T2 arg2, T3 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in arg2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2, T3>(FixedString512Bytes formatString, int arg0, T1 arg1, T2 arg2, T3 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in arg2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2, T3>(FixedString512Bytes formatString, float arg0, T1 arg1, T2 arg2, T3 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in arg2, in arg3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString512Bytes Format<T1, T2, T3>(FixedString512Bytes formatString, string arg0, T1 arg1, T2 arg2, T3 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in arg2, in arg3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString512Bytes Format<T1, T2, T3, T4>(FixedString512Bytes formatString, T1 arg0, T2 arg1, T3 arg2, T4 arg3) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes where T4 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString512Bytes dest = default(FixedString512Bytes);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in arg2, in arg3);
			return dest;
		}

		public static FixedString128Bytes Format(FixedString128Bytes formatString, int arg0, int arg1, int arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		public static FixedString128Bytes Format(FixedString128Bytes formatString, float arg0, int arg1, int arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, string arg0, int arg1, int arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, T1 arg0, int arg1, int arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2);
			return dest;
		}

		public static FixedString128Bytes Format(FixedString128Bytes formatString, int arg0, float arg1, int arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		public static FixedString128Bytes Format(FixedString128Bytes formatString, float arg0, float arg1, int arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, string arg0, float arg1, int arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, T1 arg0, float arg1, int arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, int arg0, string arg1, int arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, float arg0, string arg1, int arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, string arg0, string arg1, int arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, T1 arg0, string arg1, int arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, int arg0, T1 arg1, int arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, float arg0, T1 arg1, int arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, string arg0, T1 arg1, int arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString128Bytes Format<T1, T2>(FixedString128Bytes formatString, T1 arg0, T2 arg1, int arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in fs);
			return dest;
		}

		public static FixedString128Bytes Format(FixedString128Bytes formatString, int arg0, int arg1, float arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		public static FixedString128Bytes Format(FixedString128Bytes formatString, float arg0, int arg1, float arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, string arg0, int arg1, float arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, T1 arg0, int arg1, float arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2);
			return dest;
		}

		public static FixedString128Bytes Format(FixedString128Bytes formatString, int arg0, float arg1, float arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		public static FixedString128Bytes Format(FixedString128Bytes formatString, float arg0, float arg1, float arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, string arg0, float arg1, float arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, T1 arg0, float arg1, float arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, int arg0, string arg1, float arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, float arg0, string arg1, float arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, string arg0, string arg1, float arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, T1 arg0, string arg1, float arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, int arg0, T1 arg1, float arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, float arg0, T1 arg1, float arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, string arg0, T1 arg1, float arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString128Bytes Format<T1, T2>(FixedString128Bytes formatString, T1 arg0, T2 arg1, float arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in fs);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, int arg0, int arg1, string arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, float arg0, int arg1, string arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, string arg0, int arg1, string arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, T1 arg0, int arg1, string arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, int arg0, float arg1, string arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, float arg0, float arg1, string arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, string arg0, float arg1, string arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, T1 arg0, float arg1, string arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, int arg0, string arg1, string arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, float arg0, string arg1, string arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, string arg0, string arg1, string arg2)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedString32Bytes fs3 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs3, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in fs3);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, T1 arg0, string arg1, string arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, int arg0, T1 arg1, string arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, float arg0, T1 arg1, string arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, string arg0, T1 arg1, string arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1, T2>(FixedString128Bytes formatString, T1 arg0, T2 arg1, string arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg2);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in fs);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, int arg0, int arg1, T1 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, float arg0, int arg1, T1 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, string arg0, int arg1, T1 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString128Bytes Format<T1, T2>(FixedString128Bytes formatString, T1 arg0, int arg1, T2 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in arg2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, int arg0, float arg1, T1 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, float arg0, float arg1, T1 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, string arg0, float arg1, T1 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString128Bytes Format<T1, T2>(FixedString128Bytes formatString, T1 arg0, float arg1, T2 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in arg2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, int arg0, string arg1, T1 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, float arg0, string arg1, T1 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, string arg0, string arg1, T1 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2, in arg2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1, T2>(FixedString128Bytes formatString, T1 arg0, string arg1, T2 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs, in arg2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString128Bytes Format<T1, T2>(FixedString128Bytes formatString, int arg0, T1 arg1, T2 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in arg2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString128Bytes Format<T1, T2>(FixedString128Bytes formatString, float arg0, T1 arg1, T2 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in arg2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1, T2>(FixedString128Bytes formatString, string arg0, T1 arg1, T2 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1, in arg2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString128Bytes Format<T1, T2, T3>(FixedString128Bytes formatString, T1 arg0, T2 arg1, T3 arg2) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes where T3 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1, in arg2);
			return dest;
		}

		public static FixedString128Bytes Format(FixedString128Bytes formatString, int arg0, int arg1)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2);
			return dest;
		}

		public static FixedString128Bytes Format(FixedString128Bytes formatString, float arg0, int arg1)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, string arg0, int arg1)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, T1 arg0, int arg1) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs);
			return dest;
		}

		public static FixedString128Bytes Format(FixedString128Bytes formatString, int arg0, float arg1)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2);
			return dest;
		}

		public static FixedString128Bytes Format(FixedString128Bytes formatString, float arg0, float arg1)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, string arg0, float arg1)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, T1 arg0, float arg1) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, int arg0, string arg1)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, float arg0, string arg1)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, string arg0, string arg1)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedString32Bytes fs2 = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs2, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in fs2);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, T1 arg0, string arg1) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg1);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in fs);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, int arg0, T1 arg1) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, float arg0, T1 arg1) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, string arg0, T1 arg1) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs, in arg1);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(FixedString32Bytes),
			typeof(FixedString32Bytes)
		})]
		public static FixedString128Bytes Format<T1, T2>(FixedString128Bytes formatString, T1 arg0, T2 arg1) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes where T2 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0, in arg1);
			return dest;
		}

		public static FixedString128Bytes Format(FixedString128Bytes formatString, int arg0)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs);
			return dest;
		}

		public static FixedString128Bytes Format(FixedString128Bytes formatString, float arg0)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs);
			return dest;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public static FixedString128Bytes Format(FixedString128Bytes formatString, string arg0)
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedString32Bytes fs = default(FixedString32Bytes);
			FixedStringMethods.Append(ref fs, arg0);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in fs);
			return dest;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(FixedString32Bytes) })]
		public static FixedString128Bytes Format<T1>(FixedString128Bytes formatString, T1 arg0) where T1 : unmanaged, INativeList<byte>, IUTF8Bytes
		{
			FixedString128Bytes dest = default(FixedString128Bytes);
			FixedStringMethods.AppendFormat(ref dest, in formatString, in arg0);
			return dest;
		}
	}
	public interface IUTF8Bytes
	{
		bool IsEmpty { get; }

		unsafe byte* GetUnsafePtr();

		bool TryResize(int newLength, NativeArrayOptions clearOptions = NativeArrayOptions.ClearMemory);
	}
	[GenerateTestsForBurstCompatibility]
	internal static class FixedStringUtils
	{
		[StructLayout(LayoutKind.Explicit)]
		internal struct UintFloatUnion
		{
			[FieldOffset(0)]
			public uint uintValue;

			[FieldOffset(0)]
			public float floatValue;
		}

		internal static ParseError Base10ToBase2(ref float output, ulong mantissa10, int exponent10)
		{
			if (mantissa10 == 0L)
			{
				output = 0f;
				return ParseError.None;
			}
			if (exponent10 == 0)
			{
				output = mantissa10;
				return ParseError.None;
			}
			int num = exponent10;
			ulong num2 = mantissa10;
			while (exponent10 > 0)
			{
				while ((num2 & 0xE000000000000000uL) != 0L)
				{
					num2 >>= 1;
					num++;
				}
				num2 *= 5;
				exponent10--;
			}
			while (exponent10 < 0)
			{
				while ((num2 & 0x8000000000000000uL) == 0L)
				{
					num2 <<= 1;
					num--;
				}
				num2 /= 5;
				exponent10++;
			}
			UintFloatUnion uintFloatUnion = new UintFloatUnion
			{
				floatValue = num2
			};
			int num3 = (int)(((uintFloatUnion.uintValue >> 23) & 0xFF) - 127);
			num3 += num;
			if (num3 > 128)
			{
				return ParseError.Overflow;
			}
			if (num3 < -127)
			{
				return ParseError.Underflow;
			}
			uintFloatUnion.uintValue = (uintFloatUnion.uintValue & 0x807FFFFFu) | (uint)(num3 + 127 << 23);
			output = uintFloatUnion.floatValue;
			return ParseError.None;
		}

		internal static void Base2ToBase10(ref ulong mantissa10, ref int exponent10, float input)
		{
			UintFloatUnion uintFloatUnion = new UintFloatUnion
			{
				floatValue = input
			};
			if (uintFloatUnion.uintValue == 0)
			{
				mantissa10 = 0uL;
				exponent10 = 0;
				return;
			}
			uint num = (uintFloatUnion.uintValue & 0x7FFFFF) | 0x800000;
			int i = (int)((uintFloatUnion.uintValue >> 23) - 127 - 23);
			mantissa10 = num;
			exponent10 = i;
			if (i > 0)
			{
				while (i > 0)
				{
					while (mantissa10 <= 1844674407370955161L)
					{
						mantissa10 *= 10uL;
						exponent10--;
					}
					mantissa10 /= 5uL;
					i--;
				}
			}
			if (i < 0)
			{
				for (; i < 0; i++)
				{
					while (mantissa10 > 3689348814741910323L)
					{
						mantissa10 /= 10uL;
						exponent10++;
					}
					mantissa10 *= 5uL;
				}
			}
			while (mantissa10 > 9999999 || mantissa10 % 10 == 0L)
			{
				mantissa10 = (mantissa10 + (uint)((mantissa10 < 100000000) ? 5 : 0)) / 10;
				exponent10++;
			}
		}
	}
	[Obsolete("Use GenerateTestsForBurstCompatibility (UnityUpgradable) -> GenerateTestsForBurstCompatibilityAttribute", true)]
	public class BurstCompatibleAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]
	public class GenerateTestsForBurstCompatibilityAttribute : Attribute
	{
		public enum BurstCompatibleCompileTarget
		{
			Player,
			Editor,
			PlayerAndEditor
		}

		public string RequiredUnityDefine;

		public BurstCompatibleCompileTarget CompileTarget;

		public Type[] GenericTypeArguments { get; set; }
	}
	[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property)]
	public class ExcludeFromBurstCompatTestingAttribute : Attribute
	{
		public string Reason { get; set; }

		public ExcludeFromBurstCompatTestingAttribute(string _reason)
		{
			Reason = _reason;
		}
	}
	public static class ListExtensions
	{
		public static bool RemoveSwapBack<T>(this List<T> list, T value)
		{
			int num = list.IndexOf(value);
			if (num < 0)
			{
				return false;
			}
			list.RemoveAtSwapBack(num);
			return true;
		}

		public static bool RemoveSwapBack<T>(this List<T> list, Predicate<T> matcher)
		{
			int num = list.FindIndex(matcher);
			if (num < 0)
			{
				return false;
			}
			list.RemoveAtSwapBack(num);
			return true;
		}

		public static void RemoveAtSwapBack<T>(this List<T> list, int index)
		{
			int index2 = list.Count - 1;
			list[index] = list[index2];
			list.RemoveAt(index2);
		}

		public static NativeList<T> ToNativeList<T>(this List<T> list, AllocatorManager.AllocatorHandle allocator) where T : unmanaged
		{
			NativeList<T> result = new NativeList<T>(list.Count, allocator);
			for (int i = 0; i < list.Count; i++)
			{
				result.AddNoResize(list[i]);
			}
			return result;
		}

		public static NativeArray<T> ToNativeArray<T>(this List<T> list, AllocatorManager.AllocatorHandle allocator) where T : unmanaged
		{
			NativeArray<T> result = CollectionHelper.CreateNativeArray<T>(list.Count, allocator, NativeArrayOptions.UninitializedMemory);
			for (int i = 0; i < list.Count; i++)
			{
				result[i] = list[i];
			}
			return result;
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	[GenerateTestsForBurstCompatibility]
	internal struct Memory
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		[GenerateTestsForBurstCompatibility]
		internal struct Unmanaged
		{
			[StructLayout(LayoutKind.Sequential, Size = 1)]
			[GenerateTestsForBurstCompatibility]
			internal struct Array
			{
				private static bool IsCustom(AllocatorManager.AllocatorHandle allocator)
				{
					return allocator.Index >= 64;
				}

				private unsafe static void* CustomResize(void* oldPointer, long oldCount, long newCount, AllocatorManager.AllocatorHandle allocator, long size, int align)
				{
					AllocatorManager.Block block = new AllocatorManager.Block
					{
						Range = 
						{
							Allocator = allocator,
							Items = (int)newCount,
							Pointer = (IntPtr)oldPointer
						},
						BytesPerItem = (int)size,
						Alignment = align,
						AllocatedItems = (int)oldCount
					};
					AllocatorManager.Try(ref block);
					return (void*)block.Range.Pointer;
				}

				internal unsafe static void* Resize(void* oldPointer, long oldCount, long newCount, AllocatorManager.AllocatorHandle allocator, long size, int align)
				{
					int num = math.max(64, align);
					if (IsCustom(allocator))
					{
						return CustomResize(oldPointer, oldCount, newCount, allocator, size, num);
					}
					void* ptr = default(void*);
					if (newCount > 0)
					{
						ptr = UnsafeUtility.MallocTracked(newCount * size, num, allocator.ToAllocator, 0);
						if (oldCount > 0)
						{
							long size2 = math.min(oldCount, newCount) * size;
							UnsafeUtility.MemCpy(ptr, oldPointer, size2);
						}
					}
					if (oldCount > 0)
					{
						UnsafeUtility.FreeTracked(oldPointer, allocator.ToAllocator);
					}
					return ptr;
				}

				[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
				internal unsafe static T* Resize<T>(T* oldPointer, long oldCount, long newCount, AllocatorManager.AllocatorHandle allocator) where T : unmanaged
				{
					return (T*)Resize(oldPointer, oldCount, newCount, allocator, UnsafeUtility.SizeOf<T>(), UnsafeUtility.AlignOf<T>());
				}

				[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
				internal unsafe static T* Allocate<T>(long count, AllocatorManager.AllocatorHandle allocator) where T : unmanaged
				{
					return Resize<T>(null, 0L, count, allocator);
				}

				[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
				internal unsafe static void Free<T>(T* pointer, long count, AllocatorManager.AllocatorHandle allocator) where T : unmanaged
				{
					if (pointer != null)
					{
						Resize(pointer, count, 0L, allocator);
					}
				}
			}

			internal unsafe static void* Allocate(long size, int align, AllocatorManager.AllocatorHandle allocator)
			{
				return Array.Resize(null, 0L, 1L, allocator, size, align);
			}

			internal unsafe static void Free(void* pointer, AllocatorManager.AllocatorHandle allocator)
			{
				if (pointer != null)
				{
					Array.Resize(pointer, 1L, 0L, allocator, 1L, 1);
				}
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			internal unsafe static T* Allocate<T>(AllocatorManager.AllocatorHandle allocator) where T : unmanaged
			{
				return Array.Resize<T>(null, 0L, 1L, allocator);
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			internal unsafe static void Free<T>(T* pointer, AllocatorManager.AllocatorHandle allocator) where T : unmanaged
			{
				if (pointer != null)
				{
					Array.Resize(pointer, 1L, 0L, allocator);
				}
			}
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		[GenerateTestsForBurstCompatibility]
		internal struct Array
		{
			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			internal unsafe static void Set<T>(T* pointer, long count, T t = default(T)) where T : unmanaged
			{
				UnsafeUtility.SizeOf<T>();
				for (int i = 0; i < count; i++)
				{
					pointer[i] = t;
				}
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			internal unsafe static void Clear<T>(T* pointer, long count) where T : unmanaged
			{
				long size = count * UnsafeUtility.SizeOf<T>();
				UnsafeUtility.MemClear(pointer, size);
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			internal unsafe static void Copy<T>(T* dest, T* src, long count) where T : unmanaged
			{
				long size = count * UnsafeUtility.SizeOf<T>();
				UnsafeUtility.MemCpy(dest, src, size);
			}
		}

		internal const long k_MaximumRamSizeInBytes = 1099511627776L;

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		internal static void CheckByteCountIsReasonable(long size)
		{
			if (size < 0)
			{
				throw new InvalidOperationException($"Attempted to operate on {size} bytes of memory: negative size");
			}
			if (size > 1099511627776L)
			{
				throw new InvalidOperationException($"Attempted to operate on {size} bytes of memory: size too big");
			}
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class NativeArrayExtensions
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		public struct NativeArrayStaticId<T> where T : unmanaged
		{
			internal static readonly SharedStatic<int> s_staticSafetyId = SharedStatic<int>.GetOrCreate<NativeArray<T>>();
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static bool Contains<T, U>(this NativeArray<T> array, U value) where T : unmanaged, IEquatable<U>
		{
			return IndexOf<T, U>(array.GetUnsafeReadOnlyPtr(), array.Length, value) != -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static int IndexOf<T, U>(this NativeArray<T> array, U value) where T : unmanaged, IEquatable<U>
		{
			return IndexOf<T, U>(array.GetUnsafeReadOnlyPtr(), array.Length, value);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static bool Contains<T, U>(this NativeArray<T>.ReadOnly array, U value) where T : unmanaged, IEquatable<U>
		{
			return IndexOf<T, U>(array.GetUnsafeReadOnlyPtr(), array.m_Length, value) != -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static int IndexOf<T, U>(this NativeArray<T>.ReadOnly array, U value) where T : unmanaged, IEquatable<U>
		{
			return IndexOf<T, U>(array.GetUnsafeReadOnlyPtr(), array.m_Length, value);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static bool Contains<T, U>(void* ptr, int length, U value) where T : unmanaged, IEquatable<U>
		{
			return IndexOf<T, U>(ptr, length, value) != -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static int IndexOf<T, U>(void* ptr, int length, U value) where T : unmanaged, IEquatable<U>
		{
			for (int i = 0; i != length; i++)
			{
				if (UnsafeUtility.ReadArrayElement<T>(ptr, i).Equals(value))
				{
					return i;
				}
			}
			return -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static void CopyFrom<T>(this ref NativeArray<T> container, NativeList<T> other) where T : unmanaged, IEquatable<T>
		{
			container.CopyFrom(other.AsArray());
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static void CopyFrom<T>(this ref NativeArray<T> container, in NativeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			using NativeArray<T> array = other.ToNativeArray(Allocator.TempJob);
			container.CopyFrom(array);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static void CopyFrom<T>(this ref NativeArray<T> container, in UnsafeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			using NativeArray<T> array = other.ToNativeArray(Allocator.TempJob);
			container.CopyFrom(array);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static NativeArray<U> Reinterpret<T, U>(this NativeArray<T> array) where T : unmanaged where U : unmanaged
		{
			int num = UnsafeUtility.SizeOf<T>();
			int num2 = UnsafeUtility.SizeOf<U>();
			long num3 = (long)array.Length * (long)num / num2;
			return NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<U>(NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(array), (int)num3, Allocator.None);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static bool ArraysEqual<T>(this NativeArray<T> container, NativeArray<T> other) where T : unmanaged, IEquatable<T>
		{
			if (container.Length != other.Length)
			{
				return false;
			}
			for (int i = 0; i != container.Length; i++)
			{
				if (!container[i].Equals(other[i]))
				{
					return false;
				}
			}
			return true;
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckReinterpretSize<T, U>(ref NativeArray<T> array) where T : unmanaged where U : unmanaged
		{
			int num = UnsafeUtility.SizeOf<T>();
			int num2 = UnsafeUtility.SizeOf<U>();
			long num3 = (long)array.Length * (long)num;
			if (num3 / num2 * num2 != num3)
			{
				throw new InvalidOperationException($"Types {typeof(T)} (array length {array.Length}) and {typeof(U)} cannot be aliased due to size constraints. The size of the types and lengths involved must line up.");
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		internal unsafe static void Initialize<T>(this ref NativeArray<T> array, int length, AllocatorManager.AllocatorHandle allocator, NativeArrayOptions options = NativeArrayOptions.ClearMemory) where T : unmanaged
		{
			AllocatorManager.AllocatorHandle t = allocator;
			array = default(NativeArray<T>);
			array.m_Buffer = AllocatorManager.AllocateStruct(ref t, default(T), length);
			array.m_Length = length;
			array.m_AllocatorLabel = (allocator.IsAutoDispose ? Allocator.None : allocator.ToAllocator);
			if (options == NativeArrayOptions.ClearMemory)
			{
				UnsafeUtility.MemClear(array.m_Buffer, array.m_Length * UnsafeUtility.SizeOf<T>());
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(AllocatorManager.AllocatorHandle)
		})]
		internal unsafe static void Initialize<T, U>(this ref NativeArray<T> array, int length, ref U allocator, NativeArrayOptions options = NativeArrayOptions.ClearMemory) where T : unmanaged where U : unmanaged, AllocatorManager.IAllocator
		{
			array = default(NativeArray<T>);
			array.m_Buffer = AllocatorManager.AllocateStruct(ref allocator, default(T), length);
			array.m_Length = length;
			array.m_AllocatorLabel = (allocator.IsAutoDispose ? Allocator.None : allocator.ToAllocator);
			if (options == NativeArrayOptions.ClearMemory)
			{
				UnsafeUtility.MemClear(array.m_Buffer, array.m_Length * UnsafeUtility.SizeOf<T>());
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		internal unsafe static void DisposeCheckAllocator<T>(this ref NativeArray<T> array) where T : unmanaged
		{
			if (array.m_Buffer == null)
			{
				throw new ObjectDisposedException("The NativeArray is already disposed.");
			}
			if (!AllocatorManager.IsCustomAllocator(array.m_AllocatorLabel))
			{
				array.Dispose();
				return;
			}
			AllocatorManager.Free(array.m_AllocatorLabel, array.m_Buffer);
			array.m_AllocatorLabel = Allocator.Invalid;
			array.m_Buffer = null;
		}
	}
	[NativeContainer]
	[DebuggerDisplay("Length = {Length}, IsCreated = {IsCreated}")]
	[GenerateTestsForBurstCompatibility]
	public struct NativeBitArray : INativeDisposable, IDisposable
	{
		[NativeContainer]
		[NativeContainerIsReadOnly]
		public struct ReadOnly
		{
			[NativeDisableUnsafePtrRestriction]
			internal UnsafeBitArray.ReadOnly m_BitArray;

			public readonly bool IsCreated => m_BitArray.IsCreated;

			public readonly bool IsEmpty => m_BitArray.IsEmpty;

			public readonly int Length => CollectionHelper.AssumePositive(m_BitArray.Length);

			internal unsafe ReadOnly(ref NativeBitArray data)
			{
				m_BitArray = data.m_BitArray->AsReadOnly();
			}

			public readonly ulong GetBits(int pos, int numBits = 1)
			{
				return m_BitArray.GetBits(pos, numBits);
			}

			public readonly bool IsSet(int pos)
			{
				return m_BitArray.IsSet(pos);
			}

			public readonly int Find(int pos, int numBits)
			{
				return m_BitArray.Find(pos, numBits);
			}

			public readonly int Find(int pos, int count, int numBits)
			{
				return m_BitArray.Find(pos, count, numBits);
			}

			public readonly bool TestNone(int pos, int numBits = 1)
			{
				return m_BitArray.TestNone(pos, numBits);
			}

			public readonly bool TestAny(int pos, int numBits = 1)
			{
				return m_BitArray.TestAny(pos, numBits);
			}

			public readonly bool TestAll(int pos, int numBits = 1)
			{
				return m_BitArray.TestAll(pos, numBits);
			}

			public readonly int CountBits(int pos, int numBits = 1)
			{
				return m_BitArray.CountBits(pos, numBits);
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			private readonly void CheckRead()
			{
			}
		}

		[NativeDisableUnsafePtrRestriction]
		internal unsafe UnsafeBitArray* m_BitArray;

		internal AllocatorManager.AllocatorHandle m_Allocator;

		public unsafe readonly bool IsCreated
		{
			get
			{
				if (m_BitArray != null)
				{
					return m_BitArray->IsCreated;
				}
				return false;
			}
		}

		public readonly bool IsEmpty
		{
			get
			{
				if (IsCreated)
				{
					return Length == 0;
				}
				return true;
			}
		}

		public unsafe readonly int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return CollectionHelper.AssumePositive(m_BitArray->Length);
			}
		}

		public unsafe readonly int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return CollectionHelper.AssumePositive(m_BitArray->Capacity);
			}
		}

		public unsafe NativeBitArray(int numBits, AllocatorManager.AllocatorHandle allocator, NativeArrayOptions options = NativeArrayOptions.ClearMemory)
		{
			m_BitArray = UnsafeBitArray.Alloc(allocator);
			m_Allocator = allocator;
			*m_BitArray = new UnsafeBitArray(numBits, allocator, options);
		}

		public unsafe void Resize(int numBits, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory)
		{
			m_BitArray->Resize(numBits, options);
		}

		public unsafe void SetCapacity(int capacityInBits)
		{
			m_BitArray->SetCapacity(capacityInBits);
		}

		public unsafe void TrimExcess()
		{
			m_BitArray->TrimExcess();
		}

		public unsafe void Dispose()
		{
			if (IsCreated)
			{
				UnsafeBitArray.Free(m_BitArray, m_Allocator);
				m_BitArray = null;
				m_Allocator = AllocatorManager.Invalid;
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new NativeBitArrayDisposeJob
			{
				Data = new NativeBitArrayDispose
				{
					m_BitArrayData = m_BitArray,
					m_Allocator = m_Allocator
				}
			}.Schedule(inputDeps);
			m_BitArray = null;
			m_Allocator = AllocatorManager.Invalid;
			return result;
		}

		public unsafe void Clear()
		{
			m_BitArray->Clear();
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe NativeArray<T> AsNativeArray<T>() where T : unmanaged
		{
			int num = UnsafeUtility.SizeOf<T>() * 8;
			int length = m_BitArray->Length / num;
			return NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<T>(m_BitArray->Ptr, length, Allocator.None);
		}

		public unsafe void Set(int pos, bool value)
		{
			m_BitArray->Set(pos, value);
		}

		public unsafe void SetBits(int pos, bool value, int numBits)
		{
			m_BitArray->SetBits(pos, value, numBits);
		}

		public unsafe void SetBits(int pos, ulong value, int numBits = 1)
		{
			m_BitArray->SetBits(pos, value, numBits);
		}

		public unsafe ulong GetBits(int pos, int numBits = 1)
		{
			return m_BitArray->GetBits(pos, numBits);
		}

		public unsafe bool IsSet(int pos)
		{
			return m_BitArray->IsSet(pos);
		}

		public unsafe void Copy(int dstPos, int srcPos, int numBits)
		{
			m_BitArray->Copy(dstPos, srcPos, numBits);
		}

		public unsafe void Copy(int dstPos, ref NativeBitArray srcBitArray, int srcPos, int numBits)
		{
			m_BitArray->Copy(dstPos, ref *srcBitArray.m_BitArray, srcPos, numBits);
		}

		public unsafe int Find(int pos, int numBits)
		{
			return m_BitArray->Find(pos, numBits);
		}

		public unsafe int Find(int pos, int count, int numBits)
		{
			return m_BitArray->Find(pos, count, numBits);
		}

		public unsafe bool TestNone(int pos, int numBits = 1)
		{
			return m_BitArray->TestNone(pos, numBits);
		}

		public unsafe bool TestAny(int pos, int numBits = 1)
		{
			return m_BitArray->TestAny(pos, numBits);
		}

		public unsafe bool TestAll(int pos, int numBits = 1)
		{
			return m_BitArray->TestAll(pos, numBits);
		}

		public unsafe int CountBits(int pos, int numBits = 1)
		{
			return m_BitArray->CountBits(pos, numBits);
		}

		public ReadOnly AsReadOnly()
		{
			return new ReadOnly(ref this);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private readonly void CheckRead()
		{
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private unsafe void CheckReadBounds<T>() where T : unmanaged
		{
			int num = UnsafeUtility.SizeOf<T>() * 8;
			int num2 = m_BitArray->Length / num;
			if (num2 == 0)
			{
				throw new InvalidOperationException($"Number of bits in the NativeBitArray {m_BitArray->Length} is not sufficient to cast to NativeArray<T> {UnsafeUtility.SizeOf<T>() * 8}.");
			}
			if (m_BitArray->Length != num * num2)
			{
				throw new InvalidOperationException($"Number of bits in the NativeBitArray {m_BitArray->Length} couldn't hold multiple of T {UnsafeUtility.SizeOf<T>()}. Output array would be truncated.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private void CheckWrite()
		{
		}
	}
	[NativeContainer]
	[GenerateTestsForBurstCompatibility]
	internal struct NativeBitArrayDispose
	{
		[NativeDisableUnsafePtrRestriction]
		public unsafe UnsafeBitArray* m_BitArrayData;

		public AllocatorManager.AllocatorHandle m_Allocator;

		public unsafe void Dispose()
		{
			UnsafeBitArray.Free(m_BitArrayData, m_Allocator);
		}
	}
	[BurstCompile]
	internal struct NativeBitArrayDisposeJob : IJob
	{
		public NativeBitArrayDispose Data;

		public void Execute()
		{
			Data.Dispose();
		}
	}
	[NativeContainer]
	[GenerateTestsForBurstCompatibility]
	internal struct NativeHashMapDispose
	{
		[NativeDisableUnsafePtrRestriction]
		internal unsafe UnsafeHashMap<int, int>* m_HashMapData;

		internal AllocatorManager.AllocatorHandle m_Allocator;

		internal unsafe void Dispose()
		{
			HashMapHelper<int>* hashMapData = (HashMapHelper<int>*)m_HashMapData;
			HashMapHelper<int>.Free(hashMapData);
		}
	}
	[BurstCompile]
	internal struct NativeHashMapDisposeJob : IJob
	{
		internal NativeHashMapDispose Data;

		public void Execute()
		{
			Data.Dispose();
		}
	}
	[DebuggerDisplay("Key = {Key}, Value = {Value}")]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
	{
		typeof(int),
		typeof(int)
	})]
	public struct KVPair<TKey, TValue> where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
	{
		internal unsafe HashMapHelper<TKey>* m_Data;

		internal int m_Index;

		internal int m_Next;

		public static KVPair<TKey, TValue> Null => new KVPair<TKey, TValue>
		{
			m_Index = -1
		};

		public unsafe TKey Key
		{
			get
			{
				if (m_Index != -1)
				{
					return m_Data->Keys[m_Index];
				}
				return default(TKey);
			}
		}

		public unsafe ref TValue Value => ref UnsafeUtility.AsRef<TValue>(m_Data->Ptr + sizeof(TValue) * m_Index);

		public unsafe bool GetKeyValue(out TKey key, out TValue value)
		{
			if (m_Index != -1)
			{
				key = m_Data->Keys[m_Index];
				value = UnsafeUtility.ReadArrayElement<TValue>(m_Data->Ptr, m_Index);
				return true;
			}
			key = default(TKey);
			value = default(TValue);
			return false;
		}
	}
	[NativeContainer]
	[DebuggerTypeProxy(typeof(NativeHashMapDebuggerTypeProxy<, >))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
	{
		typeof(int),
		typeof(int)
	})]
	public struct NativeHashMap<TKey, TValue> : INativeDisposable, IDisposable, IEnumerable<KVPair<TKey, TValue>>, IEnumerable where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
	{
		[NativeContainer]
		[NativeContainerIsReadOnly]
		public struct Enumerator : IEnumerator<KVPair<TKey, TValue>>, IEnumerator, IDisposable
		{
			[NativeDisableUnsafePtrRestriction]
			internal HashMapHelper<TKey>.Enumerator m_Enumerator;

			public KVPair<TKey, TValue> Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Enumerator.GetCurrent<TValue>();
				}
			}

			object IEnumerator.Current => Current;

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				return m_Enumerator.MoveNext();
			}

			public void Reset()
			{
				m_Enumerator.Reset();
			}
		}

		[NativeContainer]
		[NativeContainerIsReadOnly]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public struct ReadOnly : IEnumerable<KVPair<TKey, TValue>>, IEnumerable
		{
			[NativeDisableUnsafePtrRestriction]
			internal unsafe HashMapHelper<TKey>* m_Data;

			public unsafe readonly bool IsCreated
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					if (m_Data != null)
					{
						return m_Data->IsCreated;
					}
					return false;
				}
			}

			public unsafe readonly bool IsEmpty
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					if (!IsCreated)
					{
						return true;
					}
					return m_Data->IsEmpty;
				}
			}

			public unsafe readonly int Count
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data->Count;
				}
			}

			public unsafe readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data->Capacity;
				}
			}

			public unsafe readonly TValue this[TKey key]
			{
				get
				{
					m_Data->TryGetValue<TValue>(key, out var item);
					return item;
				}
			}

			internal unsafe ReadOnly(ref NativeHashMap<TKey, TValue> data)
			{
				m_Data = data.m_Data;
			}

			public unsafe readonly bool TryGetValue(TKey key, out TValue item)
			{
				return m_Data->TryGetValue<TValue>(key, out item);
			}

			public unsafe readonly bool ContainsKey(TKey key)
			{
				return -1 != m_Data->Find(key);
			}

			public unsafe readonly NativeArray<TKey> GetKeyArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_Data->GetKeyArray(allocator);
			}

			public unsafe readonly NativeArray<TValue> GetValueArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_Data->GetValueArray<TValue>(allocator);
			}

			public unsafe readonly NativeKeyValueArrays<TKey, TValue> GetKeyValueArrays(AllocatorManager.AllocatorHandle allocator)
			{
				return m_Data->GetKeyValueArrays<TValue>(allocator);
			}

			public unsafe readonly Enumerator GetEnumerator()
			{
				return new Enumerator
				{
					m_Enumerator = new HashMapHelper<TKey>.Enumerator(m_Data)
				};
			}

			IEnumerator<KVPair<TKey, TValue>> IEnumerable<KVPair<TKey, TValue>>.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			private readonly void CheckRead()
			{
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private readonly void ThrowKeyNotPresent(TKey key)
			{
				throw new ArgumentException($"Key: {key} is not present.");
			}
		}

		[NativeDisableUnsafePtrRestriction]
		internal unsafe HashMapHelper<TKey>* m_Data;

		public unsafe readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (m_Data != null)
				{
					return m_Data->IsCreated;
				}
				return false;
			}
		}

		public unsafe readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (!IsCreated)
				{
					return true;
				}
				return m_Data->IsEmpty;
			}
		}

		public unsafe readonly int Count
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data->Count;
			}
		}

		public unsafe int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return m_Data->Capacity;
			}
			set
			{
				m_Data->Resize(value);
			}
		}

		public unsafe TValue this[TKey key]
		{
			get
			{
				m_Data->TryGetValue<TValue>(key, out var item);
				return item;
			}
			set
			{
				int num = m_Data->Find(key);
				if (-1 == num)
				{
					TryAdd(key, value);
				}
				else
				{
					UnsafeUtility.WriteArrayElement(m_Data->Ptr, num, value);
				}
			}
		}

		public unsafe NativeHashMap(int initialCapacity, AllocatorManager.AllocatorHandle allocator)
		{
			m_Data = HashMapHelper<TKey>.Alloc(initialCapacity, sizeof(TValue), 256, allocator);
		}

		public unsafe void Dispose()
		{
			if (IsCreated)
			{
				HashMapHelper<TKey>.Free(m_Data);
				m_Data = null;
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new NativeHashMapDisposeJob
			{
				Data = new NativeHashMapDispose
				{
					m_HashMapData = (UnsafeHashMap<int, int>*)m_Data
				}
			}.Schedule(inputDeps);
			m_Data = null;
			return result;
		}

		public unsafe void Clear()
		{
			m_Data->Clear();
		}

		public unsafe bool TryAdd(TKey key, TValue item)
		{
			int num = m_Data->TryAdd(in key);
			if (-1 != num)
			{
				UnsafeUtility.WriteArrayElement(m_Data->Ptr, num, item);
				return true;
			}
			return false;
		}

		public void Add(TKey key, TValue item)
		{
			TryAdd(key, item);
		}

		public unsafe bool Remove(TKey key)
		{
			return -1 != m_Data->TryRemove(key);
		}

		public unsafe bool TryGetValue(TKey key, out TValue item)
		{
			return m_Data->TryGetValue<TValue>(key, out item);
		}

		public unsafe bool ContainsKey(TKey key)
		{
			return -1 != m_Data->Find(key);
		}

		public unsafe void TrimExcess()
		{
			m_Data->TrimExcess();
		}

		public unsafe NativeArray<TKey> GetKeyArray(AllocatorManager.AllocatorHandle allocator)
		{
			return m_Data->GetKeyArray(allocator);
		}

		public unsafe NativeArray<TValue> GetValueArray(AllocatorManager.AllocatorHandle allocator)
		{
			return m_Data->GetValueArray<TValue>(allocator);
		}

		public unsafe NativeKeyValueArrays<TKey, TValue> GetKeyValueArrays(AllocatorManager.AllocatorHandle allocator)
		{
			return m_Data->GetKeyValueArrays<TValue>(allocator);
		}

		public unsafe Enumerator GetEnumerator()
		{
			return new Enumerator
			{
				m_Enumerator = new HashMapHelper<TKey>.Enumerator(m_Data)
			};
		}

		IEnumerator<KVPair<TKey, TValue>> IEnumerable<KVPair<TKey, TValue>>.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		public ReadOnly AsReadOnly()
		{
			return new ReadOnly(ref this);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private readonly void CheckRead()
		{
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private void CheckWrite()
		{
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void ThrowKeyNotPresent(TKey key)
		{
			throw new ArgumentException($"Key: {key} is not present.");
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void ThrowKeyAlreadyAdded(TKey key)
		{
			throw new ArgumentException($"An item with the same key has already been added: {key}");
		}
	}
	internal sealed class NativeHashMapDebuggerTypeProxy<TKey, TValue> where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
	{
		private unsafe HashMapHelper<TKey>* Data;

		public unsafe List<Pair<TKey, TValue>> Items
		{
			get
			{
				if (Data == null)
				{
					return null;
				}
				List<Pair<TKey, TValue>> list = new List<Pair<TKey, TValue>>();
				NativeKeyValueArrays<TKey, TValue> keyValueArrays = Data->GetKeyValueArrays<TValue>(Allocator.Temp);
				try
				{
					for (int i = 0; i < keyValueArrays.Length; i++)
					{
						NativeArray<TKey> keys = keyValueArrays.Keys;
						TKey k = keys[i];
						NativeArray<TValue> values = keyValueArrays.Values;
						list.Add(new Pair<TKey, TValue>(k, values[i]));
					}
					return list;
				}
				finally
				{
					((IDisposable)keyValueArrays/*cast due to .constrained prefix*/).Dispose();
				}
			}
		}

		public unsafe NativeHashMapDebuggerTypeProxy(NativeHashMap<TKey, TValue> target)
		{
			Data = target.m_Data;
		}

		public unsafe NativeHashMapDebuggerTypeProxy(NativeHashMap<TKey, TValue>.ReadOnly target)
		{
			Data = target.m_Data;
		}
	}
	[NativeContainer]
	[DebuggerTypeProxy(typeof(NativeHashSetDebuggerTypeProxy<>))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct NativeHashSet<T> : INativeDisposable, IDisposable, IEnumerable<T>, IEnumerable where T : unmanaged, IEquatable<T>
	{
		[NativeContainer]
		[NativeContainerIsReadOnly]
		public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
		{
			[NativeDisableUnsafePtrRestriction]
			internal HashMapHelper<T>.Enumerator m_Enumerator;

			public T Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Enumerator.GetCurrentKey();
				}
			}

			object IEnumerator.Current => Current;

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				return m_Enumerator.MoveNext();
			}

			public void Reset()
			{
				m_Enumerator.Reset();
			}
		}

		[NativeContainer]
		[NativeContainerIsReadOnly]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ReadOnly : IEnumerable<T>, IEnumerable
		{
			[NativeDisableUnsafePtrRestriction]
			internal unsafe HashMapHelper<T>* m_Data;

			public unsafe readonly bool IsCreated
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					if (m_Data != null)
					{
						return m_Data->IsCreated;
					}
					return false;
				}
			}

			public unsafe readonly bool IsEmpty
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					if (!IsCreated)
					{
						return true;
					}
					return m_Data->IsEmpty;
				}
			}

			public unsafe readonly int Count
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data->Count;
				}
			}

			public unsafe readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data->Capacity;
				}
			}

			internal unsafe ReadOnly(ref NativeHashSet<T> data)
			{
				m_Data = data.m_Data;
			}

			public unsafe readonly bool Contains(T item)
			{
				return -1 != m_Data->Find(item);
			}

			public unsafe readonly NativeArray<T> ToNativeArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_Data->GetKeyArray(allocator);
			}

			public unsafe readonly Enumerator GetEnumerator()
			{
				return new Enumerator
				{
					m_Enumerator = new HashMapHelper<T>.Enumerator(m_Data)
				};
			}

			IEnumerator<T> IEnumerable<T>.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			private readonly void CheckRead()
			{
			}
		}

		[NativeDisableUnsafePtrRestriction]
		internal unsafe HashMapHelper<T>* m_Data;

		public unsafe readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (!IsCreated)
				{
					return true;
				}
				return m_Data->IsEmpty;
			}
		}

		public unsafe readonly int Count
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data->Count;
			}
		}

		public unsafe int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return m_Data->Capacity;
			}
			set
			{
				m_Data->Resize(value);
			}
		}

		public unsafe readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (m_Data != null)
				{
					return m_Data->IsCreated;
				}
				return false;
			}
		}

		public unsafe NativeHashSet(int initialCapacity, AllocatorManager.AllocatorHandle allocator)
		{
			m_Data = HashMapHelper<T>.Alloc(initialCapacity, 0, 256, allocator);
		}

		public unsafe void Dispose()
		{
			if (IsCreated)
			{
				HashMapHelper<T>.Free(m_Data);
				m_Data = null;
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new NativeHashMapDisposeJob
			{
				Data = new NativeHashMapDispose
				{
					m_HashMapData = (UnsafeHashMap<int, int>*)m_Data
				}
			}.Schedule(inputDeps);
			m_Data = null;
			return result;
		}

		public unsafe void Clear()
		{
			m_Data->Clear();
		}

		public unsafe bool Add(T item)
		{
			return -1 != m_Data->TryAdd(in item);
		}

		public unsafe bool Remove(T item)
		{
			return -1 != m_Data->TryRemove(item);
		}

		public unsafe bool Contains(T item)
		{
			return -1 != m_Data->Find(item);
		}

		public unsafe void TrimExcess()
		{
			m_Data->TrimExcess();
		}

		public unsafe NativeArray<T> ToNativeArray(AllocatorManager.AllocatorHandle allocator)
		{
			return m_Data->GetKeyArray(allocator);
		}

		public unsafe Enumerator GetEnumerator()
		{
			return new Enumerator
			{
				m_Enumerator = new HashMapHelper<T>.Enumerator(m_Data)
			};
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		public ReadOnly AsReadOnly()
		{
			return new ReadOnly(ref this);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private readonly void CheckRead()
		{
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private void CheckWrite()
		{
		}
	}
	internal sealed class NativeHashSetDebuggerTypeProxy<T> where T : unmanaged, IEquatable<T>
	{
		private unsafe HashMapHelper<T>* Data;

		public unsafe List<T> Items
		{
			get
			{
				if (Data == null)
				{
					return null;
				}
				List<T> list = new List<T>();
				using NativeArray<T> nativeArray = Data->GetKeyArray(Allocator.Temp);
				for (int i = 0; i < nativeArray.Length; i++)
				{
					list.Add(nativeArray[i]);
				}
				return list;
			}
		}

		public unsafe NativeHashSetDebuggerTypeProxy(NativeHashSet<T> data)
		{
			Data = data.m_Data;
		}
	}
	public interface IIndexable<T> where T : unmanaged
	{
		int Length { get; set; }

		ref T ElementAt(int index);
	}
	public interface INativeList<T> : IIndexable<T> where T : unmanaged
	{
		int Capacity { get; set; }

		bool IsEmpty { get; }

		T this[int index] { get; set; }

		void Clear();
	}
	[NativeContainer]
	[DebuggerDisplay("Length = {m_ListData == null ? default : m_ListData->Length}, Capacity = {m_ListData == null ? default : m_ListData->Capacity}")]
	[DebuggerTypeProxy(typeof(NativeListDebugView<>))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct NativeList<T> : INativeDisposable, IDisposable, INativeList<T>, IIndexable<T>, IEnumerable<T>, IEnumerable where T : unmanaged
	{
		[NativeContainer]
		[NativeContainerIsAtomicWriteOnly]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ParallelWriter
		{
			[NativeDisableUnsafePtrRestriction]
			public unsafe UnsafeList<T>* ListData;

			public unsafe readonly void* Ptr
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return ListData->Ptr;
				}
			}

			internal unsafe ParallelWriter(UnsafeList<T>* listData)
			{
				ListData = listData;
			}

			public unsafe void AddNoResize(T value)
			{
				int index = Interlocked.Increment(ref ListData->m_length) - 1;
				UnsafeUtility.WriteArrayElement(ListData->Ptr, index, value);
			}

			public unsafe void AddRangeNoResize(void* ptr, int count)
			{
				int num = Interlocked.Add(ref ListData->m_length, count) - count;
				int num2 = sizeof(T);
				void* destination = (byte*)ListData->Ptr + num * num2;
				UnsafeUtility.MemCpy(destination, ptr, count * num2);
			}

			public unsafe void AddRangeNoResize(UnsafeList<T> list)
			{
				AddRangeNoResize(list.Ptr, list.Length);
			}

			public unsafe void AddRangeNoResize(NativeList<T> list)
			{
				AddRangeNoResize(*list.m_ListData);
			}
		}

		[NativeDisableUnsafePtrRestriction]
		internal unsafe UnsafeList<T>* m_ListData;

		public unsafe T this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return (*m_ListData)[index];
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				(*m_ListData)[index] = value;
			}
		}

		public unsafe int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return CollectionHelper.AssumePositive(m_ListData->Length);
			}
			set
			{
				m_ListData->Resize(value, NativeArrayOptions.ClearMemory);
			}
		}

		public unsafe int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return m_ListData->Capacity;
			}
			set
			{
				m_ListData->Capacity = value;
			}
		}

		public unsafe readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (m_ListData != null)
				{
					return m_ListData->Length == 0;
				}
				return true;
			}
		}

		public unsafe readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_ListData != null;
			}
		}

		public NativeList(AllocatorManager.AllocatorHandle allocator)
			: this(1, allocator)
		{
		}

		public NativeList(int initialCapacity, AllocatorManager.AllocatorHandle allocator)
		{
			this = default(NativeList<T>);
			AllocatorManager.AllocatorHandle allocator2 = allocator;
			Initialize(initialCapacity, ref allocator2);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(AllocatorManager.AllocatorHandle) })]
		internal unsafe void Initialize<U>(int initialCapacity, ref U allocator) where U : unmanaged, AllocatorManager.IAllocator
		{
			m_ListData = UnsafeList<T>.Create(initialCapacity, ref allocator, NativeArrayOptions.UninitializedMemory);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(AllocatorManager.AllocatorHandle) })]
		internal static NativeList<T> New<U>(int initialCapacity, ref U allocator) where U : unmanaged, AllocatorManager.IAllocator
		{
			NativeList<T> result = default(NativeList<T>);
			result.Initialize(initialCapacity, ref allocator);
			return result;
		}

		public unsafe ref T ElementAt(int index)
		{
			return ref m_ListData->ElementAt(index);
		}

		public unsafe UnsafeList<T>* GetUnsafeList()
		{
			return m_ListData;
		}

		public unsafe void AddNoResize(T value)
		{
			m_ListData->AddNoResize(value);
		}

		public unsafe void AddRangeNoResize(void* ptr, int count)
		{
			m_ListData->AddRangeNoResize(ptr, count);
		}

		public unsafe void AddRangeNoResize(NativeList<T> list)
		{
			m_ListData->AddRangeNoResize(*list.m_ListData);
		}

		public unsafe void Add(in T value)
		{
			m_ListData->Add(in value);
		}

		public unsafe void AddRange(NativeArray<T> array)
		{
			AddRange(array.GetUnsafeReadOnlyPtr(), array.Length);
		}

		public unsafe void AddRange(void* ptr, int count)
		{
			m_ListData->AddRange(ptr, CollectionHelper.AssumePositive(count));
		}

		public unsafe void AddReplicate(in T value, int count)
		{
			m_ListData->AddReplicate(in value, CollectionHelper.AssumePositive(count));
		}

		public unsafe void InsertRangeWithBeginEnd(int begin, int end)
		{
			m_ListData->InsertRangeWithBeginEnd(begin, end);
		}

		public void InsertRange(int index, int count)
		{
			InsertRangeWithBeginEnd(index, index + count);
		}

		public unsafe void RemoveAtSwapBack(int index)
		{
			m_ListData->RemoveAtSwapBack(index);
		}

		public unsafe void RemoveRangeSwapBack(int index, int count)
		{
			m_ListData->RemoveRangeSwapBack(index, count);
		}

		public unsafe void RemoveAt(int index)
		{
			m_ListData->RemoveAt(index);
		}

		public unsafe void RemoveRange(int index, int count)
		{
			m_ListData->RemoveRange(index, count);
		}

		public unsafe void Dispose()
		{
			if (IsCreated)
			{
				UnsafeList<T>.Destroy(m_ListData);
				m_ListData = null;
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(AllocatorManager.AllocatorHandle) })]
		internal unsafe void Dispose<U>(ref U allocator) where U : unmanaged, AllocatorManager.IAllocator
		{
			if (IsCreated)
			{
				UnsafeList<T>.Destroy(m_ListData, ref allocator);
				m_ListData = null;
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new NativeListDisposeJob
			{
				Data = new NativeListDispose
				{
					m_ListData = (UntypedUnsafeList*)m_ListData
				}
			}.Schedule(inputDeps);
			m_ListData = null;
			return result;
		}

		public unsafe void Clear()
		{
			m_ListData->Clear();
		}

		[Obsolete("Implicit cast from `NativeList<T>` to `NativeArray<T>` has been deprecated; Use '.AsArray()' method to do explicit cast instead.", false)]
		public static implicit operator NativeArray<T>(NativeList<T> nativeList)
		{
			return nativeList.AsArray();
		}

		public unsafe NativeArray<T> AsArray()
		{
			return NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<T>(m_ListData->Ptr, m_ListData->Length, Allocator.None);
		}

		public unsafe NativeArray<T> AsDeferredJobArray()
		{
			byte* listData = (byte*)m_ListData;
			listData++;
			return NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<T>(listData, 0, Allocator.Invalid);
		}

		public unsafe NativeArray<T> ToArray(AllocatorManager.AllocatorHandle allocator)
		{
			NativeArray<T> result = CollectionHelper.CreateNativeArray<T>(Length, allocator, NativeArrayOptions.UninitializedMemory);
			UnsafeUtility.MemCpy(result.m_Buffer, m_ListData->Ptr, Length * UnsafeUtility.SizeOf<T>());
			return result;
		}

		public unsafe void CopyFrom(in NativeArray<T> other)
		{
			m_ListData->CopyFrom(in other);
		}

		public unsafe void CopyFrom(in UnsafeList<T> other)
		{
			m_ListData->CopyFrom(in other);
		}

		public unsafe void CopyFrom(in NativeList<T> other)
		{
			CopyFrom(in *other.m_ListData);
		}

		public NativeArray<T>.Enumerator GetEnumerator()
		{
			NativeArray<T> array = AsArray();
			return new NativeArray<T>.Enumerator(ref array);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		public unsafe void Resize(int length, NativeArrayOptions options)
		{
			m_ListData->Resize(length, options);
		}

		public void ResizeUninitialized(int length)
		{
			Resize(length, NativeArrayOptions.UninitializedMemory);
		}

		public unsafe void SetCapacity(int capacity)
		{
			m_ListData->SetCapacity(capacity);
		}

		public unsafe void TrimExcess()
		{
			m_ListData->TrimExcess();
		}

		public unsafe NativeArray<T>.ReadOnly AsReadOnly()
		{
			return new NativeArray<T>.ReadOnly(m_ListData->Ptr, m_ListData->Length);
		}

		public unsafe NativeArray<T>.ReadOnly AsParallelReader()
		{
			return new NativeArray<T>.ReadOnly(m_ListData->Ptr, m_ListData->Length);
		}

		public unsafe ParallelWriter AsParallelWriter()
		{
			return new ParallelWriter(m_ListData);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckInitialCapacity(int initialCapacity)
		{
			if (initialCapacity < 0)
			{
				throw new ArgumentOutOfRangeException("initialCapacity", "Capacity must be >= 0");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckTotalSize(int initialCapacity, long totalSize)
		{
			if (totalSize > int.MaxValue)
			{
				throw new ArgumentOutOfRangeException("initialCapacity", $"Capacity * sizeof(T) cannot exceed {int.MaxValue} bytes");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckSufficientCapacity(int capacity, int length)
		{
			if (capacity < length)
			{
				throw new InvalidOperationException($"Length {length} exceeds Capacity {capacity}");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckIndexInRange(int value, int length)
		{
			if (value < 0)
			{
				throw new IndexOutOfRangeException($"Value {value} must be positive.");
			}
			if ((uint)value >= (uint)length)
			{
				throw new IndexOutOfRangeException($"Value {value} is out of range in NativeList of '{length}' Length.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckArgPositive(int value)
		{
			if (value < 0)
			{
				throw new ArgumentOutOfRangeException($"Value {value} must be positive.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private unsafe void CheckHandleMatches(AllocatorManager.AllocatorHandle handle)
		{
			if (m_ListData == null)
			{
				throw new ArgumentOutOfRangeException($"Allocator handle {handle} can't match because container is not initialized.");
			}
			if (m_ListData->Allocator.Index != handle.Index)
			{
				throw new ArgumentOutOfRangeException($"Allocator handle {handle} can't match because container handle index doesn't match.");
			}
			if (m_ListData->Allocator.Version != handle.Version)
			{
				throw new ArgumentOutOfRangeException($"Allocator handle {handle} matches container handle index, but has different version.");
			}
		}
	}
	[NativeContainer]
	[GenerateTestsForBurstCompatibility]
	internal struct NativeListDispose
	{
		[NativeDisableUnsafePtrRestriction]
		public unsafe UntypedUnsafeList* m_ListData;

		public unsafe void Dispose()
		{
			UnsafeList<int>* listData = (UnsafeList<int>*)m_ListData;
			UnsafeList<int>.Destroy(listData);
		}
	}
	[BurstCompile]
	[GenerateTestsForBurstCompatibility]
	internal struct NativeListDisposeJob : IJob
	{
		internal NativeListDispose Data;

		public void Execute()
		{
			Data.Dispose();
		}
	}
	internal sealed class NativeListDebugView<T> where T : unmanaged
	{
		private unsafe UnsafeList<T>* Data;

		public unsafe T[] Items
		{
			get
			{
				if (Data == null)
				{
					return null;
				}
				int length = Data->Length;
				T[] array = new T[length];
				fixed (T* destination = &array[0])
				{
					UnsafeUtility.MemCpy(destination, Data->Ptr, length * UnsafeUtility.SizeOf<T>());
				}
				return array;
			}
		}

		public unsafe NativeListDebugView(NativeList<T> array)
		{
			Data = array.m_ListData;
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class NativeListExtensions
	{
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static bool Contains<T, U>(this NativeList<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			return NativeArrayExtensions.IndexOf<T, U>(list.GetUnsafeReadOnlyPtr(), list.Length, value) != -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static int IndexOf<T, U>(this NativeList<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			return NativeArrayExtensions.IndexOf<T, U>(list.GetUnsafeReadOnlyPtr(), list.Length, value);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static bool ArraysEqual<T>(this NativeArray<T> container, in NativeList<T> other) where T : unmanaged, IEquatable<T>
		{
			return container.ArraysEqual(other.AsArray());
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static bool ArraysEqual<T>(this NativeList<T> container, in NativeArray<T> other) where T : unmanaged, IEquatable<T>
		{
			return other.ArraysEqual(in container);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static bool ArraysEqual<T>(this NativeList<T> container, in NativeList<T> other) where T : unmanaged, IEquatable<T>
		{
			return container.AsArray().ArraysEqual(other.AsArray());
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static bool ArraysEqual<T>(this NativeList<T> container, in UnsafeList<T> other) where T : unmanaged, IEquatable<T>
		{
			return (*container.m_ListData).ArraysEqual(in other);
		}
	}
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
	{
		typeof(int),
		typeof(int)
	})]
	public struct NativeKeyValueArrays<TKey, TValue> : INativeDisposable, IDisposable where TKey : unmanaged where TValue : unmanaged
	{
		public NativeArray<TKey> Keys;

		public NativeArray<TValue> Values;

		public int Length => Keys.Length;

		public NativeKeyValueArrays(int length, AllocatorManager.AllocatorHandle allocator, NativeArrayOptions options)
		{
			Keys = CollectionHelper.CreateNativeArray<TKey>(length, allocator, options);
			Values = CollectionHelper.CreateNativeArray<TValue>(length, allocator, options);
		}

		public void Dispose()
		{
			Keys.Dispose();
			Values.Dispose();
		}

		public JobHandle Dispose(JobHandle inputDeps)
		{
			return Keys.Dispose(Values.Dispose(inputDeps));
		}
	}
	[NativeContainer]
	[DebuggerDisplay("Count = {m_HashMapData.Count()}, Capacity = {m_HashMapData.Capacity}, IsCreated = {m_HashMapData.IsCreated}, IsEmpty = {IsEmpty}")]
	[DebuggerTypeProxy(typeof(NativeParallelHashMapDebuggerTypeProxy<, >))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
	{
		typeof(int),
		typeof(int)
	})]
	public struct NativeParallelHashMap<TKey, TValue> : INativeDisposable, IDisposable, IEnumerable<KeyValue<TKey, TValue>>, IEnumerable where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
	{
		[NativeContainer]
		[NativeContainerIsReadOnly]
		[DebuggerTypeProxy(typeof(NativeParallelHashMapDebuggerTypeProxy<, >))]
		[DebuggerDisplay("Count = {m_HashMapData.Count()}, Capacity = {m_HashMapData.Capacity}, IsCreated = {m_HashMapData.IsCreated}, IsEmpty = {IsEmpty}")]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public struct ReadOnly : IEnumerable<KeyValue<TKey, TValue>>, IEnumerable
		{
			internal UnsafeParallelHashMap<TKey, TValue> m_HashMapData;

			public readonly bool IsCreated
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_HashMapData.IsCreated;
				}
			}

			public readonly bool IsEmpty
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					if (!IsCreated)
					{
						return true;
					}
					return m_HashMapData.IsEmpty;
				}
			}

			public readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_HashMapData.Capacity;
				}
			}

			public readonly TValue this[TKey key]
			{
				get
				{
					if (m_HashMapData.TryGetValue(key, out var item))
					{
						return item;
					}
					return default(TValue);
				}
			}

			internal ReadOnly(UnsafeParallelHashMap<TKey, TValue> hashMapData)
			{
				m_HashMapData = hashMapData;
			}

			public readonly int Count()
			{
				return m_HashMapData.Count();
			}

			public readonly bool TryGetValue(TKey key, out TValue item)
			{
				return m_HashMapData.TryGetValue(key, out item);
			}

			public readonly bool ContainsKey(TKey key)
			{
				return m_HashMapData.ContainsKey(key);
			}

			public readonly NativeArray<TKey> GetKeyArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_HashMapData.GetKeyArray(allocator);
			}

			public readonly NativeArray<TValue> GetValueArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_HashMapData.GetValueArray(allocator);
			}

			public readonly NativeKeyValueArrays<TKey, TValue> GetKeyValueArrays(AllocatorManager.AllocatorHandle allocator)
			{
				return m_HashMapData.GetKeyValueArrays(allocator);
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			private readonly void CheckRead()
			{
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private readonly void ThrowKeyNotPresent(TKey key)
			{
				throw new ArgumentException($"Key: {key} is not present in the NativeParallelHashMap.");
			}

			public unsafe readonly Enumerator GetEnumerator()
			{
				return new Enumerator
				{
					m_Enumerator = new UnsafeParallelHashMapDataEnumerator(m_HashMapData.m_Buffer)
				};
			}

			IEnumerator<KeyValue<TKey, TValue>> IEnumerable<KeyValue<TKey, TValue>>.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				throw new NotImplementedException();
			}
		}

		[NativeContainer]
		[NativeContainerIsAtomicWriteOnly]
		[DebuggerDisplay("Capacity = {m_Writer.Capacity}")]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public struct ParallelWriter
		{
			internal UnsafeParallelHashMap<TKey, TValue>.ParallelWriter m_Writer;

			public int ThreadIndex => m_Writer.m_ThreadIndex;

			[Obsolete("'m_ThreadIndex' has been deprecated; use 'ThreadIndex' instead. (UnityUpgradable) -> ThreadIndex")]
			public int m_ThreadIndex => m_Writer.m_ThreadIndex;

			public readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Writer.Capacity;
				}
			}

			public bool TryAdd(TKey key, TValue item)
			{
				return m_Writer.TryAdd(key, item);
			}

			internal bool TryAdd(TKey key, TValue item, int threadIndexOverride)
			{
				return m_Writer.TryAdd(key, item, threadIndexOverride);
			}
		}

		[NativeContainer]
		[NativeContainerIsReadOnly]
		public struct Enumerator : IEnumerator<KeyValue<TKey, TValue>>, IEnumerator, IDisposable
		{
			internal UnsafeParallelHashMapDataEnumerator m_Enumerator;

			public KeyValue<TKey, TValue> Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Enumerator.GetCurrent<TKey, TValue>();
				}
			}

			object IEnumerator.Current => Current;

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				return m_Enumerator.MoveNext();
			}

			public void Reset()
			{
				m_Enumerator.Reset();
			}
		}

		internal UnsafeParallelHashMap<TKey, TValue> m_HashMapData;

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (!IsCreated)
				{
					return true;
				}
				return m_HashMapData.IsEmpty;
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return m_HashMapData.Capacity;
			}
			set
			{
				m_HashMapData.Capacity = value;
			}
		}

		public TValue this[TKey key]
		{
			get
			{
				if (m_HashMapData.TryGetValue(key, out var item))
				{
					return item;
				}
				return default(TValue);
			}
			set
			{
				m_HashMapData[key] = value;
			}
		}

		public readonly bool IsCreated => m_HashMapData.IsCreated;

		public NativeParallelHashMap(int capacity, AllocatorManager.AllocatorHandle allocator)
		{
			m_HashMapData = new UnsafeParallelHashMap<TKey, TValue>(capacity, allocator);
		}

		public int Count()
		{
			return m_HashMapData.Count();
		}

		public void Clear()
		{
			m_HashMapData.Clear();
		}

		public unsafe bool TryAdd(TKey key, TValue item)
		{
			return UnsafeParallelHashMapBase<TKey, TValue>.TryAdd(m_HashMapData.m_Buffer, key, item, isMultiHashMap: false, m_HashMapData.m_AllocatorLabel);
		}

		public unsafe void Add(TKey key, TValue item)
		{
			UnsafeParallelHashMapBase<TKey, TValue>.TryAdd(m_HashMapData.m_Buffer, key, item, isMultiHashMap: false, m_HashMapData.m_AllocatorLabel);
		}

		public bool Remove(TKey key)
		{
			return m_HashMapData.Remove(key);
		}

		public bool TryGetValue(TKey key, out TValue item)
		{
			return m_HashMapData.TryGetValue(key, out item);
		}

		public bool ContainsKey(TKey key)
		{
			return m_HashMapData.ContainsKey(key);
		}

		public void Dispose()
		{
			if (IsCreated)
			{
				m_HashMapData.Dispose();
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new UnsafeParallelHashMapDataDisposeJob
			{
				Data = new UnsafeParallelHashMapDataDispose
				{
					m_Buffer = m_HashMapData.m_Buffer,
					m_AllocatorLabel = m_HashMapData.m_AllocatorLabel
				}
			}.Schedule(inputDeps);
			m_HashMapData.m_Buffer = null;
			return result;
		}

		public NativeArray<TKey> GetKeyArray(AllocatorManager.AllocatorHandle allocator)
		{
			return m_HashMapData.GetKeyArray(allocator);
		}

		public NativeArray<TValue> GetValueArray(AllocatorManager.AllocatorHandle allocator)
		{
			return m_HashMapData.GetValueArray(allocator);
		}

		public NativeKeyValueArrays<TKey, TValue> GetKeyValueArrays(AllocatorManager.AllocatorHandle allocator)
		{
			return m_HashMapData.GetKeyValueArrays(allocator);
		}

		public ParallelWriter AsParallelWriter()
		{
			ParallelWriter result = default(ParallelWriter);
			result.m_Writer = m_HashMapData.AsParallelWriter();
			return result;
		}

		public ReadOnly AsReadOnly()
		{
			return new ReadOnly(m_HashMapData);
		}

		public unsafe Enumerator GetEnumerator()
		{
			return new Enumerator
			{
				m_Enumerator = new UnsafeParallelHashMapDataEnumerator(m_HashMapData.m_Buffer)
			};
		}

		IEnumerator<KeyValue<TKey, TValue>> IEnumerable<KeyValue<TKey, TValue>>.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private readonly void CheckRead()
		{
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private void CheckWrite()
		{
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void ThrowKeyNotPresent(TKey key)
		{
			throw new ArgumentException($"Key: {key} is not present in the NativeParallelHashMap.");
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void ThrowKeyAlreadyAdded(TKey key)
		{
			throw new ArgumentException("An item with the same key has already been added", "key");
		}
	}
	internal sealed class NativeParallelHashMapDebuggerTypeProxy<TKey, TValue> where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
	{
		private UnsafeParallelHashMap<TKey, TValue> m_Target;

		public List<Pair<TKey, TValue>> Items
		{
			get
			{
				List<Pair<TKey, TValue>> list = new List<Pair<TKey, TValue>>();
				NativeKeyValueArrays<TKey, TValue> keyValueArrays = m_Target.GetKeyValueArrays(Allocator.Temp);
				try
				{
					for (int i = 0; i < keyValueArrays.Length; i++)
					{
						NativeArray<TKey> keys = keyValueArrays.Keys;
						TKey k = keys[i];
						NativeArray<TValue> values = keyValueArrays.Values;
						list.Add(new Pair<TKey, TValue>(k, values[i]));
					}
					return list;
				}
				finally
				{
					((IDisposable)keyValueArrays/*cast due to .constrained prefix*/).Dispose();
				}
			}
		}

		public NativeParallelHashMapDebuggerTypeProxy(NativeParallelHashMap<TKey, TValue> target)
		{
			m_Target = target.m_HashMapData;
		}

		internal NativeParallelHashMapDebuggerTypeProxy(NativeParallelHashMap<TKey, TValue>.ReadOnly target)
		{
			m_Target = target.m_HashMapData;
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class NativeParallelHashMapExtensions
	{
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static int Unique<T>(this NativeArray<T> array) where T : unmanaged, IEquatable<T>
		{
			if (array.Length == 0)
			{
				return 0;
			}
			int num = 0;
			int length = array.Length;
			int num2 = num;
			while (++num != length)
			{
				if (!array[num2].Equals(array[num]))
				{
					array[++num2] = array[num];
				}
			}
			return ++num2;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static (NativeArray<TKey>, int) GetUniqueKeyArray<TKey, TValue>(this UnsafeParallelMultiHashMap<TKey, TValue> container, AllocatorManager.AllocatorHandle allocator) where TKey : unmanaged, IEquatable<TKey>, IComparable<TKey> where TValue : unmanaged
		{
			NativeArray<TKey> keyArray = container.GetKeyArray(allocator);
			keyArray.Sort();
			int item = keyArray.Unique();
			return (keyArray, item);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static (NativeArray<TKey>, int) GetUniqueKeyArray<TKey, TValue>(this NativeParallelMultiHashMap<TKey, TValue> container, AllocatorManager.AllocatorHandle allocator) where TKey : unmanaged, IEquatable<TKey>, IComparable<TKey> where TValue : unmanaged
		{
			NativeArray<TKey> keyArray = container.GetKeyArray(allocator);
			keyArray.Sort();
			int item = keyArray.Unique();
			return (keyArray, item);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static UnsafeParallelHashMapBucketData GetUnsafeBucketData<TKey, TValue>(this NativeParallelHashMap<TKey, TValue> container) where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
		{
			return container.m_HashMapData.m_Buffer->GetBucketData();
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static UnsafeParallelHashMapBucketData GetUnsafeBucketData<TKey, TValue>(this NativeParallelMultiHashMap<TKey, TValue> container) where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
		{
			return container.m_MultiHashMapData.m_Buffer->GetBucketData();
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static void Remove<TKey, TValue>(this NativeParallelMultiHashMap<TKey, TValue> container, TKey key, TValue value) where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged, IEquatable<TValue>
		{
			container.m_MultiHashMapData.Remove(key, value);
		}
	}
	[DebuggerTypeProxy(typeof(NativeParallelHashSetDebuggerTypeProxy<>))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct NativeParallelHashSet<T> : INativeDisposable, IDisposable, IEnumerable<T>, IEnumerable where T : unmanaged, IEquatable<T>
	{
		[NativeContainerIsAtomicWriteOnly]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ParallelWriter
		{
			internal NativeParallelHashMap<T, bool>.ParallelWriter m_Data;

			public readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data.Capacity;
				}
			}

			public bool Add(T item)
			{
				return m_Data.TryAdd(item, item: false);
			}

			internal bool Add(T item, int threadIndexOverride)
			{
				return m_Data.TryAdd(item, item: false, threadIndexOverride);
			}
		}

		[NativeContainer]
		[NativeContainerIsReadOnly]
		public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
		{
			internal UnsafeParallelHashMapDataEnumerator m_Enumerator;

			public T Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Enumerator.GetCurrentKey<T>();
				}
			}

			object IEnumerator.Current => Current;

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				return m_Enumerator.MoveNext();
			}

			public void Reset()
			{
				m_Enumerator.Reset();
			}
		}

		[NativeContainer]
		[NativeContainerIsReadOnly]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ReadOnly : IEnumerable<T>, IEnumerable
		{
			internal UnsafeParallelHashMap<T, bool> m_Data;

			public readonly bool IsCreated
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data.IsCreated;
				}
			}

			public readonly bool IsEmpty
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					if (!IsCreated)
					{
						return true;
					}
					return m_Data.IsEmpty;
				}
			}

			public readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data.Capacity;
				}
			}

			internal ReadOnly(ref NativeParallelHashSet<T> data)
			{
				m_Data = data.m_Data.m_HashMapData;
			}

			public readonly int Count()
			{
				return m_Data.Count();
			}

			public readonly bool Contains(T item)
			{
				return m_Data.ContainsKey(item);
			}

			public readonly NativeArray<T> ToNativeArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_Data.GetKeyArray(allocator);
			}

			public unsafe readonly Enumerator GetEnumerator()
			{
				return new Enumerator
				{
					m_Enumerator = new UnsafeParallelHashMapDataEnumerator(m_Data.m_Buffer)
				};
			}

			IEnumerator<T> IEnumerable<T>.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			private readonly void CheckRead()
			{
			}
		}

		internal NativeParallelHashMap<T, bool> m_Data;

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data.IsEmpty;
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return m_Data.Capacity;
			}
			set
			{
				m_Data.Capacity = value;
			}
		}

		public readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data.IsCreated;
			}
		}

		public NativeParallelHashSet(int capacity, AllocatorManager.AllocatorHandle allocator)
		{
			m_Data = new NativeParallelHashMap<T, bool>(capacity, allocator);
		}

		public int Count()
		{
			return m_Data.Count();
		}

		public void Dispose()
		{
			m_Data.Dispose();
		}

		public JobHandle Dispose(JobHandle inputDeps)
		{
			return m_Data.Dispose(inputDeps);
		}

		public void Clear()
		{
			m_Data.Clear();
		}

		public bool Add(T item)
		{
			return m_Data.TryAdd(item, item: false);
		}

		public bool Remove(T item)
		{
			return m_Data.Remove(item);
		}

		public bool Contains(T item)
		{
			return m_Data.ContainsKey(item);
		}

		public NativeArray<T> ToNativeArray(AllocatorManager.AllocatorHandle allocator)
		{
			return m_Data.GetKeyArray(allocator);
		}

		public ParallelWriter AsParallelWriter()
		{
			ParallelWriter result = default(ParallelWriter);
			result.m_Data = m_Data.AsParallelWriter();
			return result;
		}

		public unsafe Enumerator GetEnumerator()
		{
			return new Enumerator
			{
				m_Enumerator = new UnsafeParallelHashMapDataEnumerator(m_Data.m_HashMapData.m_Buffer)
			};
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		public ReadOnly AsReadOnly()
		{
			return new ReadOnly(ref this);
		}
	}
	internal sealed class NativeParallelHashSetDebuggerTypeProxy<T> where T : unmanaged, IEquatable<T>
	{
		private NativeParallelHashSet<T> Data;

		public List<T> Items
		{
			get
			{
				List<T> list = new List<T>();
				using NativeArray<T> nativeArray = Data.ToNativeArray(Allocator.Temp);
				for (int i = 0; i < nativeArray.Length; i++)
				{
					list.Add(nativeArray[i]);
				}
				return list;
			}
		}

		public NativeParallelHashSetDebuggerTypeProxy(NativeParallelHashSet<T> data)
		{
			Data = data;
		}
	}
	public static class HashSetExtensions
	{
		public static void ExceptWith<T>(this ref NativeHashSet<T> container, FixedList128Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, FixedList128Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, FixedList128Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeHashSet<T> container, FixedList32Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, FixedList32Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, FixedList32Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeHashSet<T> container, FixedList4096Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, FixedList4096Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, FixedList4096Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeHashSet<T> container, FixedList512Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, FixedList512Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, FixedList512Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeHashSet<T> container, FixedList64Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, FixedList64Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, FixedList64Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeHashSet<T> container, NativeArray<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, NativeArray<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, NativeArray<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeHashSet<T> container, NativeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, NativeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, NativeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeHashSet<T> container, NativeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, NativeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, NativeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeHashSet<T> container, NativeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, NativeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, NativeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeHashSet<T> container, NativeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, NativeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, NativeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeHashSet<T> container, NativeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, NativeList<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, NativeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, FixedList128Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, FixedList128Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, FixedList128Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, FixedList32Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, FixedList32Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, FixedList32Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, FixedList4096Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, FixedList4096Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, FixedList4096Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, FixedList512Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, FixedList512Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, FixedList512Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, FixedList64Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, FixedList64Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, FixedList64Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, NativeArray<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, NativeArray<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, NativeArray<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, NativeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, NativeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, NativeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, NativeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, NativeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, NativeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, NativeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, NativeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, NativeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, NativeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, NativeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, NativeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, NativeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, NativeList<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, NativeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}
	}
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct NativeParallelMultiHashMapIterator<TKey> where TKey : unmanaged
	{
		internal TKey key;

		internal int NextEntryIndex;

		internal int EntryIndex;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public int GetEntryIndex()
		{
			return EntryIndex;
		}
	}
	[NativeContainer]
	[DebuggerTypeProxy(typeof(NativeParallelMultiHashMapDebuggerTypeProxy<, >))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
	{
		typeof(int),
		typeof(int)
	})]
	public struct NativeParallelMultiHashMap<TKey, TValue> : INativeDisposable, IDisposable, IEnumerable<KeyValue<TKey, TValue>>, IEnumerable where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
	{
		[NativeContainer]
		[NativeContainerIsAtomicWriteOnly]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public struct ParallelWriter
		{
			internal UnsafeParallelMultiHashMap<TKey, TValue>.ParallelWriter m_Writer;

			public int m_ThreadIndex => m_Writer.m_ThreadIndex;

			public readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Writer.Capacity;
				}
			}

			public void Add(TKey key, TValue item)
			{
				m_Writer.Add(key, item);
			}
		}

		public struct Enumerator : IEnumerator<TValue>, IEnumerator, IDisposable
		{
			internal NativeParallelMultiHashMap<TKey, TValue> hashmap;

			internal TKey key;

			internal byte isFirst;

			private TValue value;

			private NativeParallelMultiHashMapIterator<TKey> iterator;

			public TValue Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return value;
				}
			}

			object IEnumerator.Current => Current;

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				if (isFirst == 1)
				{
					isFirst = 0;
					return hashmap.TryGetFirstValue(key, out value, out iterator);
				}
				return hashmap.TryGetNextValue(out value, ref iterator);
			}

			public void Reset()
			{
				isFirst = 1;
			}

			public Enumerator GetEnumerator()
			{
				return this;
			}
		}

		[NativeContainer]
		[NativeContainerIsReadOnly]
		public struct KeyValueEnumerator : IEnumerator<KeyValue<TKey, TValue>>, IEnumerator, IDisposable
		{
			internal UnsafeParallelHashMapDataEnumerator m_Enumerator;

			public readonly KeyValue<TKey, TValue> Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Enumerator.GetCurrent<TKey, TValue>();
				}
			}

			object IEnumerator.Current => Current;

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				return m_Enumerator.MoveNext();
			}

			public void Reset()
			{
				m_Enumerator.Reset();
			}
		}

		[NativeContainer]
		[NativeContainerIsReadOnly]
		[DebuggerTypeProxy(typeof(NativeParallelHashMapDebuggerTypeProxy<, >))]
		[DebuggerDisplay("Count = {m_HashMapData.Count()}, Capacity = {m_HashMapData.Capacity}, IsCreated = {m_HashMapData.IsCreated}, IsEmpty = {IsEmpty}")]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public struct ReadOnly : IEnumerable<KeyValue<TKey, TValue>>, IEnumerable
		{
			internal UnsafeParallelMultiHashMap<TKey, TValue> m_MultiHashMapData;

			public readonly bool IsCreated
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_MultiHashMapData.IsCreated;
				}
			}

			public readonly bool IsEmpty
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					if (!IsCreated)
					{
						return true;
					}
					return m_MultiHashMapData.IsEmpty;
				}
			}

			public readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_MultiHashMapData.Capacity;
				}
			}

			internal ReadOnly(UnsafeParallelMultiHashMap<TKey, TValue> container)
			{
				m_MultiHashMapData = container;
			}

			public readonly int Count()
			{
				return m_MultiHashMapData.Count();
			}

			public readonly bool TryGetFirstValue(TKey key, out TValue item, out NativeParallelMultiHashMapIterator<TKey> it)
			{
				return m_MultiHashMapData.TryGetFirstValue(key, out item, out it);
			}

			public readonly bool TryGetNextValue(out TValue item, ref NativeParallelMultiHashMapIterator<TKey> it)
			{
				return m_MultiHashMapData.TryGetNextValue(out item, ref it);
			}

			public readonly bool ContainsKey(TKey key)
			{
				return m_MultiHashMapData.ContainsKey(key);
			}

			public readonly NativeArray<TKey> GetKeyArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_MultiHashMapData.GetKeyArray(allocator);
			}

			public readonly NativeArray<TValue> GetValueArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_MultiHashMapData.GetValueArray(allocator);
			}

			public readonly NativeKeyValueArrays<TKey, TValue> GetKeyValueArrays(AllocatorManager.AllocatorHandle allocator)
			{
				return m_MultiHashMapData.GetKeyValueArrays(allocator);
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			private readonly void CheckRead()
			{
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private readonly void ThrowKeyNotPresent(TKey key)
			{
				throw new ArgumentException($"Key: {key} is not present in the NativeParallelHashMap.");
			}

			public unsafe KeyValueEnumerator GetEnumerator()
			{
				return new KeyValueEnumerator
				{
					m_Enumerator = new UnsafeParallelHashMapDataEnumerator(m_MultiHashMapData.m_Buffer)
				};
			}

			IEnumerator<KeyValue<TKey, TValue>> IEnumerable<KeyValue<TKey, TValue>>.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				throw new NotImplementedException();
			}
		}

		internal UnsafeParallelMultiHashMap<TKey, TValue> m_MultiHashMapData;

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_MultiHashMapData.IsEmpty;
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return m_MultiHashMapData.Capacity;
			}
			set
			{
				m_MultiHashMapData.Capacity = value;
			}
		}

		public readonly bool IsCreated => m_MultiHashMapData.IsCreated;

		public NativeParallelMultiHashMap(int capacity, AllocatorManager.AllocatorHandle allocator)
		{
			this = default(NativeParallelMultiHashMap<TKey, TValue>);
			Initialize(capacity, ref allocator);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(AllocatorManager.AllocatorHandle) })]
		internal void Initialize<U>(int capacity, ref U allocator) where U : unmanaged, AllocatorManager.IAllocator
		{
			m_MultiHashMapData = new UnsafeParallelMultiHashMap<TKey, TValue>(capacity, allocator.Handle);
		}

		public readonly int Count()
		{
			return m_MultiHashMapData.Count();
		}

		public void Clear()
		{
			m_MultiHashMapData.Clear();
		}

		public void Add(TKey key, TValue item)
		{
			m_MultiHashMapData.Add(key, item);
		}

		public int Remove(TKey key)
		{
			return m_MultiHashMapData.Remove(key);
		}

		public void Remove(NativeParallelMultiHashMapIterator<TKey> it)
		{
			m_MultiHashMapData.Remove(it);
		}

		public bool TryGetFirstValue(TKey key, out TValue item, out NativeParallelMultiHashMapIterator<TKey> it)
		{
			return m_MultiHashMapData.TryGetFirstValue(key, out item, out it);
		}

		public bool TryGetNextValue(out TValue item, ref NativeParallelMultiHashMapIterator<TKey> it)
		{
			return m_MultiHashMapData.TryGetNextValue(out item, ref it);
		}

		public bool ContainsKey(TKey key)
		{
			TValue item;
			NativeParallelMultiHashMapIterator<TKey> it;
			return TryGetFirstValue(key, out item, out it);
		}

		public int CountValuesForKey(TKey key)
		{
			if (!TryGetFirstValue(key, out var item, out var it))
			{
				return 0;
			}
			int num = 1;
			while (TryGetNextValue(out item, ref it))
			{
				num++;
			}
			return num;
		}

		public bool SetValue(TValue item, NativeParallelMultiHashMapIterator<TKey> it)
		{
			return m_MultiHashMapData.SetValue(item, it);
		}

		public void Dispose()
		{
			if (IsCreated)
			{
				m_MultiHashMapData.Dispose();
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new UnsafeParallelHashMapDataDisposeJob
			{
				Data = new UnsafeParallelHashMapDataDispose
				{
					m_Buffer = m_MultiHashMapData.m_Buffer,
					m_AllocatorLabel = m_MultiHashMapData.m_AllocatorLabel
				}
			}.Schedule(inputDeps);
			m_MultiHashMapData.m_Buffer = null;
			return result;
		}

		public NativeArray<TKey> GetKeyArray(AllocatorManager.AllocatorHandle allocator)
		{
			return m_MultiHashMapData.GetKeyArray(allocator);
		}

		public NativeArray<TValue> GetValueArray(AllocatorManager.AllocatorHandle allocator)
		{
			return m_MultiHashMapData.GetValueArray(allocator);
		}

		public NativeKeyValueArrays<TKey, TValue> GetKeyValueArrays(AllocatorManager.AllocatorHandle allocator)
		{
			return m_MultiHashMapData.GetKeyValueArrays(allocator);
		}

		public ParallelWriter AsParallelWriter()
		{
			ParallelWriter result = default(ParallelWriter);
			result.m_Writer = m_MultiHashMapData.AsParallelWriter();
			return result;
		}

		public Enumerator GetValuesForKey(TKey key)
		{
			return new Enumerator
			{
				hashmap = this,
				key = key,
				isFirst = 1
			};
		}

		public unsafe KeyValueEnumerator GetEnumerator()
		{
			return new KeyValueEnumerator
			{
				m_Enumerator = new UnsafeParallelHashMapDataEnumerator(m_MultiHashMapData.m_Buffer)
			};
		}

		IEnumerator<KeyValue<TKey, TValue>> IEnumerable<KeyValue<TKey, TValue>>.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		public ReadOnly AsReadOnly()
		{
			return new ReadOnly(m_MultiHashMapData);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private readonly void CheckRead()
		{
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private void CheckWrite()
		{
		}
	}
	internal sealed class NativeParallelMultiHashMapDebuggerTypeProxy<TKey, TValue> where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
	{
		private NativeParallelMultiHashMap<TKey, TValue> m_Target;

		public List<ListPair<TKey, List<TValue>>> Items
		{
			get
			{
				List<ListPair<TKey, List<TValue>>> list = new List<ListPair<TKey, List<TValue>>>();
				(NativeArray<TKey>, int) tuple = default((NativeArray<TKey>, int));
				using (NativeParallelHashMap<TKey, TValue> nativeParallelHashMap = new NativeParallelHashMap<TKey, TValue>(m_Target.Count(), Allocator.Temp))
				{
					NativeParallelMultiHashMap<TKey, TValue>.KeyValueEnumerator enumerator = m_Target.GetEnumerator();
					while (enumerator.MoveNext())
					{
						nativeParallelHashMap.TryAdd(enumerator.Current.Key, default(TValue));
					}
					tuple.Item1 = nativeParallelHashMap.GetKeyArray(Allocator.Temp);
					tuple.Item2 = tuple.Item1.Length;
				}
				using (tuple.Item1)
				{
					for (int i = 0; i < tuple.Item2; i++)
					{
						List<TValue> list2 = new List<TValue>();
						if (m_Target.TryGetFirstValue(tuple.Item1[i], out var item, out var it))
						{
							do
							{
								list2.Add(item);
							}
							while (m_Target.TryGetNextValue(out item, ref it));
						}
						list.Add(new ListPair<TKey, List<TValue>>(tuple.Item1[i], list2));
					}
					return list;
				}
			}
		}

		public NativeParallelMultiHashMapDebuggerTypeProxy(NativeParallelMultiHashMap<TKey, TValue> target)
		{
			m_Target = target;
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class NativeParallelMultiHashMapExtensions
	{
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int),
			typeof(AllocatorManager.AllocatorHandle)
		})]
		internal static void Initialize<TKey, TValue, U>(this ref NativeParallelMultiHashMap<TKey, TValue> container, int capacity, ref U allocator) where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged where U : unmanaged, AllocatorManager.IAllocator
		{
			container.m_MultiHashMapData = new UnsafeParallelMultiHashMap<TKey, TValue>(capacity, allocator.Handle);
		}
	}
	[NativeContainer]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct NativeQueue<T> : INativeDisposable, IDisposable where T : unmanaged
	{
		[NativeContainer]
		[NativeContainerIsReadOnly]
		public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
		{
			internal UnsafeQueue<T>.Enumerator m_Enumerator;

			public T Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Enumerator.Current;
				}
			}

			object IEnumerator.Current => Current;

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				return m_Enumerator.MoveNext();
			}

			public void Reset()
			{
				m_Enumerator.Reset();
			}
		}

		[NativeContainer]
		[NativeContainerIsReadOnly]
		public struct ReadOnly : IEnumerable<T>, IEnumerable
		{
			private UnsafeQueue<T>.ReadOnly m_ReadOnly;

			public readonly bool IsCreated
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_ReadOnly.IsCreated;
				}
			}

			public readonly int Count => m_ReadOnly.Count;

			public readonly T this[int index] => m_ReadOnly[index];

			internal unsafe ReadOnly(ref NativeQueue<T> data)
			{
				m_ReadOnly = new UnsafeQueue<T>.ReadOnly(ref *data.m_Queue);
			}

			public readonly bool IsEmpty()
			{
				return m_ReadOnly.IsEmpty();
			}

			public readonly Enumerator GetEnumerator()
			{
				return new Enumerator
				{
					m_Enumerator = m_ReadOnly.GetEnumerator()
				};
			}

			IEnumerator<T> IEnumerable<T>.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			private readonly void CheckRead()
			{
			}
		}

		[NativeContainer]
		[NativeContainerIsAtomicWriteOnly]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ParallelWriter
		{
			internal UnsafeQueue<T>.ParallelWriter unsafeWriter;

			public void Enqueue(T value)
			{
				unsafeWriter.Enqueue(value);
			}

			internal void Enqueue(T value, int threadIndexOverride)
			{
				unsafeWriter.Enqueue(value, threadIndexOverride);
			}
		}

		[NativeDisableUnsafePtrRestriction]
		private unsafe UnsafeQueue<T>* m_Queue;

		public unsafe readonly int Count => m_Queue->Count;

		public unsafe readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (m_Queue != null)
				{
					return m_Queue->IsCreated;
				}
				return false;
			}
		}

		public unsafe NativeQueue(AllocatorManager.AllocatorHandle allocator)
		{
			m_Queue = UnsafeQueue<T>.Alloc(allocator);
			*m_Queue = new UnsafeQueue<T>(allocator);
		}

		public unsafe readonly bool IsEmpty()
		{
			if (IsCreated)
			{
				return m_Queue->IsEmpty();
			}
			return true;
		}

		public unsafe T Peek()
		{
			return m_Queue->Peek();
		}

		public unsafe void Enqueue(T value)
		{
			m_Queue->Enqueue(value);
		}

		public unsafe T Dequeue()
		{
			return m_Queue->Dequeue();
		}

		public unsafe bool TryDequeue(out T item)
		{
			return m_Queue->TryDequeue(out item);
		}

		public unsafe NativeArray<T> ToArray(AllocatorManager.AllocatorHandle allocator)
		{
			return m_Queue->ToArray(allocator);
		}

		public unsafe void Clear()
		{
			m_Queue->Clear();
		}

		public unsafe void Dispose()
		{
			if (IsCreated)
			{
				UnsafeQueue<T>.Free(m_Queue);
				m_Queue = null;
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new NativeQueueDisposeJob
			{
				Data = new NativeQueueDispose
				{
					m_QueueData = (UnsafeQueue<int>*)m_Queue
				}
			}.Schedule(inputDeps);
			m_Queue = null;
			return result;
		}

		public ReadOnly AsReadOnly()
		{
			return new ReadOnly(ref this);
		}

		public unsafe ParallelWriter AsParallelWriter()
		{
			ParallelWriter result = default(ParallelWriter);
			result.unsafeWriter = m_Queue->AsParallelWriter();
			return result;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private readonly void CheckRead()
		{
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private void CheckWrite()
		{
		}
	}
	[NativeContainer]
	[GenerateTestsForBurstCompatibility]
	internal struct NativeQueueDispose
	{
		[NativeDisableUnsafePtrRestriction]
		public unsafe UnsafeQueue<int>* m_QueueData;

		public unsafe void Dispose()
		{
			UnsafeQueue<int>.Free(m_QueueData);
		}
	}
	[BurstCompile]
	internal struct NativeQueueDisposeJob : IJob
	{
		public NativeQueueDispose Data;

		public void Execute()
		{
			Data.Dispose();
		}
	}
	[NativeContainer]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct NativeReference<T> : INativeDisposable, IDisposable, IEquatable<NativeReference<T>> where T : unmanaged
	{
		[NativeContainer]
		[NativeContainerIsReadOnly]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ReadOnly
		{
			[NativeDisableUnsafePtrRestriction]
			private unsafe readonly void* m_Data;

			public unsafe T Value => *(T*)m_Data;

			internal unsafe ReadOnly(void* data)
			{
				m_Data = data;
			}
		}

		[NativeDisableUnsafePtrRestriction]
		internal unsafe void* m_Data;

		internal AllocatorManager.AllocatorHandle m_AllocatorLabel;

		public unsafe T Value
		{
			get
			{
				return *(T*)m_Data;
			}
			set
			{
				*(T*)m_Data = value;
			}
		}

		public unsafe readonly bool IsCreated => m_Data != null;

		public unsafe NativeReference(AllocatorManager.AllocatorHandle allocator, NativeArrayOptions options = NativeArrayOptions.ClearMemory)
		{
			Allocate(allocator, out this);
			if (options == NativeArrayOptions.ClearMemory)
			{
				UnsafeUtility.MemClear(m_Data, UnsafeUtility.SizeOf<T>());
			}
		}

		public unsafe NativeReference(T value, AllocatorManager.AllocatorHandle allocator)
		{
			Allocate(allocator, out this);
			*(T*)m_Data = value;
		}

		private unsafe static void Allocate(AllocatorManager.AllocatorHandle allocator, out NativeReference<T> reference)
		{
			reference = default(NativeReference<T>);
			reference.m_Data = Memory.Unmanaged.Allocate(UnsafeUtility.SizeOf<T>(), UnsafeUtility.AlignOf<T>(), allocator);
			reference.m_AllocatorLabel = allocator;
		}

		public unsafe void Dispose()
		{
			if (IsCreated)
			{
				if (CollectionHelper.ShouldDeallocate(m_AllocatorLabel))
				{
					Memory.Unmanaged.Free(m_Data, m_AllocatorLabel);
					m_AllocatorLabel = Allocator.Invalid;
				}
				m_Data = null;
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			if (CollectionHelper.ShouldDeallocate(m_AllocatorLabel))
			{
				JobHandle result = new NativeReferenceDisposeJob
				{
					Data = new NativeReferenceDispose
					{
						m_Data = m_Data,
						m_AllocatorLabel = m_AllocatorLabel
					}
				}.Schedule(inputDeps);
				m_Data = null;
				m_AllocatorLabel = Allocator.Invalid;
				return result;
			}
			m_Data = null;
			return inputDeps;
		}

		public void CopyFrom(NativeReference<T> reference)
		{
			Copy(this, reference);
		}

		public void CopyTo(NativeReference<T> reference)
		{
			Copy(reference, this);
		}

		[ExcludeFromBurstCompatTesting("Equals boxes because Value does not implement IEquatable<T>")]
		public bool Equals(NativeReference<T> other)
		{
			return Value.Equals(other.Value);
		}

		[ExcludeFromBurstCompatTesting("Takes managed object")]
		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is NativeReference<T>)
			{
				return Equals((NativeReference<T>)obj);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return Value.GetHashCode();
		}

		public static bool operator ==(NativeReference<T> left, NativeReference<T> right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(NativeReference<T> left, NativeReference<T> right)
		{
			return !left.Equals(right);
		}

		public unsafe static void Copy(NativeReference<T> dst, NativeReference<T> src)
		{
			UnsafeUtility.MemCpy(dst.m_Data, src.m_Data, UnsafeUtility.SizeOf<T>());
		}

		public unsafe ReadOnly AsReadOnly()
		{
			return new ReadOnly(m_Data);
		}

		public static implicit operator ReadOnly(NativeReference<T> nativeReference)
		{
			return nativeReference.AsReadOnly();
		}
	}
	[NativeContainer]
	internal struct NativeReferenceDispose
	{
		[NativeDisableUnsafePtrRestriction]
		internal unsafe void* m_Data;

		internal AllocatorManager.AllocatorHandle m_AllocatorLabel;

		public unsafe void Dispose()
		{
			Memory.Unmanaged.Free(m_Data, m_AllocatorLabel);
		}
	}
	[BurstCompile]
	internal struct NativeReferenceDisposeJob : IJob
	{
		internal NativeReferenceDispose Data;

		public void Execute()
		{
			Data.Dispose();
		}
	}
	[NativeContainer]
	[DebuggerDisplay("Length = {Length}, Capacity = {Capacity}, IsCreated = {IsCreated}, IsEmpty = {IsEmpty}")]
	[DebuggerTypeProxy(typeof(NativeRingQueueDebugView<>))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct NativeRingQueue<T> : INativeDisposable, IDisposable where T : unmanaged
	{
		[NativeDisableUnsafePtrRestriction]
		internal unsafe UnsafeRingQueue<T>* m_RingQueue;

		public unsafe readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (m_RingQueue != null)
				{
					return m_RingQueue->IsCreated;
				}
				return false;
			}
		}

		public unsafe readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (m_RingQueue != null)
				{
					return m_RingQueue->Length == 0;
				}
				return true;
			}
		}

		public unsafe readonly int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return CollectionHelper.AssumePositive(m_RingQueue->Length);
			}
		}

		public unsafe readonly int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return CollectionHelper.AssumePositive(m_RingQueue->Capacity);
			}
		}

		public unsafe NativeRingQueue(int capacity, AllocatorManager.AllocatorHandle allocator, NativeArrayOptions options = NativeArrayOptions.ClearMemory)
		{
			m_RingQueue = UnsafeRingQueue<T>.Alloc(allocator);
			*m_RingQueue = new UnsafeRingQueue<T>(capacity, allocator, options);
		}

		public unsafe void Dispose()
		{
			if (IsCreated)
			{
				UnsafeRingQueue<T>.Free(m_RingQueue);
				m_RingQueue = null;
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new NativeRingQueueDisposeJob
			{
				Data = new NativeRingQueueDispose
				{
					m_QueueData = (UnsafeRingQueue<int>*)m_RingQueue
				}
			}.Schedule(inputDeps);
			m_RingQueue = null;
			return result;
		}

		public unsafe bool TryEnqueue(T value)
		{
			return m_RingQueue->TryEnqueue(value);
		}

		public unsafe void Enqueue(T value)
		{
			m_RingQueue->Enqueue(value);
		}

		public unsafe bool TryDequeue(out T item)
		{
			return m_RingQueue->TryDequeue(out item);
		}

		public unsafe T Dequeue()
		{
			return m_RingQueue->Dequeue();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private readonly void CheckRead()
		{
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private readonly void CheckWrite()
		{
		}
	}
	internal sealed class NativeRingQueueDebugView<T> where T : unmanaged
	{
		private unsafe UnsafeRingQueue<T>* Data;

		public unsafe T[] Items
		{
			get
			{
				T[] array = new T[Data->Length];
				int read = Data->m_Read;
				int capacity = Data->m_Capacity;
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = Data->Ptr[(read + i) % capacity];
				}
				return array;
			}
		}

		public unsafe NativeRingQueueDebugView(NativeRingQueue<T> data)
		{
			Data = data.m_RingQueue;
		}
	}
	[NativeContainer]
	[GenerateTestsForBurstCompatibility]
	internal struct NativeRingQueueDispose
	{
		[NativeDisableUnsafePtrRestriction]
		public unsafe UnsafeRingQueue<int>* m_QueueData;

		public unsafe void Dispose()
		{
			UnsafeRingQueue<int>.Free(m_QueueData);
		}
	}
	[BurstCompile]
	internal struct NativeRingQueueDisposeJob : IJob
	{
		public NativeRingQueueDispose Data;

		public void Execute()
		{
			Data.Dispose();
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class NativeSortExtension
	{
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct DefaultComparer<T> : IComparer<T> where T : IComparable<T>
		{
			public int Compare(T x, T y)
			{
				return x.CompareTo(y);
			}
		}

		private const int k_IntrosortSizeThreshold = 16;

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static void Sort<T>(T* array, int length) where T : unmanaged, IComparable<T>
		{
			IntroSort<T, DefaultComparer<T>>(array, length, default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public unsafe static void Sort<T, U>(T* array, int length, U comp) where T : unmanaged where U : IComparer<T>
		{
			IntroSort<T, U>(array, length, comp);
		}

		[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "UNITY_2020_2_OR_NEWER", GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static SortJob<T, DefaultComparer<T>> SortJob<T>(T* array, int length) where T : unmanaged, IComparable<T>
		{
			return new SortJob<T, DefaultComparer<T>>
			{
				Data = array,
				Length = length,
				Comp = default(DefaultComparer<T>)
			};
		}

		[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "UNITY_2020_2_OR_NEWER", GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public unsafe static SortJob<T, U> SortJob<T, U>(T* array, int length, U comp) where T : unmanaged where U : IComparer<T>
		{
			return new SortJob<T, U>
			{
				Data = array,
				Length = length,
				Comp = comp
			};
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static int BinarySearch<T>(T* ptr, int length, T value) where T : unmanaged, IComparable<T>
		{
			return BinarySearch(ptr, length, value, default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public unsafe static int BinarySearch<T, U>(T* ptr, int length, T value, U comp) where T : unmanaged where U : IComparer<T>
		{
			int num = 0;
			for (int num2 = length; num2 != 0; num2 >>= 1)
			{
				int num3 = num + (num2 >> 1);
				T y = ptr[num3];
				int num4 = comp.Compare(value, y);
				if (num4 == 0)
				{
					return num3;
				}
				if (num4 > 0)
				{
					num = num3 + 1;
					num2--;
				}
			}
			return ~num;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static void Sort<T>(this NativeArray<T> array) where T : unmanaged, IComparable<T>
		{
			IntroSortStruct<T, DefaultComparer<T>>(array.GetUnsafePtr(), array.Length, default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public unsafe static void Sort<T, U>(this NativeArray<T> array, U comp) where T : unmanaged where U : IComparer<T>
		{
			T* unsafePtr = (T*)array.GetUnsafePtr();
			int length = array.Length;
			IntroSortStruct<T, U>(unsafePtr, length, comp);
		}

		[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "UNITY_2020_2_OR_NEWER", GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static SortJob<T, DefaultComparer<T>> SortJob<T>(this NativeArray<T> array) where T : unmanaged, IComparable<T>
		{
			return SortJob((T*)NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(array), array.Length, default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "UNITY_2020_2_OR_NEWER", GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public unsafe static SortJob<T, U> SortJob<T, U>(this NativeArray<T> array, U comp) where T : unmanaged where U : IComparer<T>
		{
			T* unsafeBufferPointerWithoutChecks = (T*)NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(array);
			int length = array.Length;
			return new SortJob<T, U>
			{
				Data = unsafeBufferPointerWithoutChecks,
				Length = length,
				Comp = comp
			};
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static int BinarySearch<T>(this NativeArray<T> array, T value) where T : unmanaged, IComparable<T>
		{
			return array.BinarySearch(value, default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public unsafe static int BinarySearch<T, U>(this NativeArray<T> array, T value, U comp) where T : unmanaged where U : IComparer<T>
		{
			return BinarySearch((T*)array.GetUnsafeReadOnlyPtr(), array.Length, value, comp);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static int BinarySearch<T>(this NativeArray<T>.ReadOnly array, T value) where T : unmanaged, IComparable<T>
		{
			return array.BinarySearch(value, default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public unsafe static int BinarySearch<T, U>(this NativeArray<T>.ReadOnly array, T value, U comp) where T : unmanaged where U : IComparer<T>
		{
			return BinarySearch((T*)array.GetUnsafeReadOnlyPtr(), array.Length, value, comp);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static void Sort<T>(this NativeList<T> list) where T : unmanaged, IComparable<T>
		{
			list.Sort(default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public unsafe static void Sort<T, U>(this NativeList<T> list, U comp) where T : unmanaged where U : IComparer<T>
		{
			IntroSort<T, U>(list.GetUnsafePtr(), list.Length, comp);
		}

		[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "UNITY_2020_2_OR_NEWER", GenericTypeArguments = new Type[] { typeof(int) })]
		public static SortJob<T, DefaultComparer<T>> SortJob<T>(this NativeList<T> list) where T : unmanaged, IComparable<T>
		{
			return list.SortJob(default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "UNITY_2020_2_OR_NEWER", GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public unsafe static SortJob<T, U> SortJob<T, U>(this NativeList<T> list, U comp) where T : unmanaged where U : IComparer<T>
		{
			return SortJob(list.GetUnsafePtr(), list.Length, comp);
		}

		[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "UNITY_2020_2_OR_NEWER", GenericTypeArguments = new Type[] { typeof(int) })]
		public static SortJobDefer<T, DefaultComparer<T>> SortJobDefer<T>(this NativeList<T> list) where T : unmanaged, IComparable<T>
		{
			return list.SortJobDefer(default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "UNITY_2020_2_OR_NEWER", GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public static SortJobDefer<T, U> SortJobDefer<T, U>(this NativeList<T> list, U comp) where T : unmanaged where U : IComparer<T>
		{
			return new SortJobDefer<T, U>
			{
				Data = list,
				Comp = comp
			};
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static int BinarySearch<T>(this NativeList<T> list, T value) where T : unmanaged, IComparable<T>
		{
			return list.AsReadOnly().BinarySearch(value, default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public static int BinarySearch<T, U>(this NativeList<T> list, T value, U comp) where T : unmanaged where U : IComparer<T>
		{
			return list.AsReadOnly().BinarySearch(value, comp);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static void Sort<T>(this UnsafeList<T> list) where T : unmanaged, IComparable<T>
		{
			list.Sort(default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public unsafe static void Sort<T, U>(this UnsafeList<T> list, U comp) where T : unmanaged where U : IComparer<T>
		{
			IntroSort<T, U>(list.Ptr, list.Length, comp);
		}

		[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "UNITY_2020_2_OR_NEWER", GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static SortJob<T, DefaultComparer<T>> SortJob<T>(this UnsafeList<T> list) where T : unmanaged, IComparable<T>
		{
			return SortJob(list.Ptr, list.Length, default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "UNITY_2020_2_OR_NEWER", GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public unsafe static SortJob<T, U> SortJob<T, U>(this UnsafeList<T> list, U comp) where T : unmanaged where U : IComparer<T>
		{
			return SortJob(list.Ptr, list.Length, comp);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static int BinarySearch<T>(this UnsafeList<T> list, T value) where T : unmanaged, IComparable<T>
		{
			return list.BinarySearch(value, default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public unsafe static int BinarySearch<T, U>(this UnsafeList<T> list, T value, U comp) where T : unmanaged where U : IComparer<T>
		{
			return BinarySearch(list.Ptr, list.Length, value, comp);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static void Sort<T>(this NativeSlice<T> slice) where T : unmanaged, IComparable<T>
		{
			slice.Sort(default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public unsafe static void Sort<T, U>(this NativeSlice<T> slice, U comp) where T : unmanaged where U : IComparer<T>
		{
			T* unsafePtr = (T*)slice.GetUnsafePtr();
			int length = slice.Length;
			IntroSortStruct<T, U>(unsafePtr, length, comp);
		}

		[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "UNITY_2020_2_OR_NEWER", GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static SortJob<T, DefaultComparer<T>> SortJob<T>(this NativeSlice<T> slice) where T : unmanaged, IComparable<T>
		{
			return SortJob((T*)slice.GetUnsafePtr(), slice.Length, default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "UNITY_2020_2_OR_NEWER", GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public unsafe static SortJob<T, U> SortJob<T, U>(this NativeSlice<T> slice, U comp) where T : unmanaged where U : IComparer<T>
		{
			return SortJob((T*)slice.GetUnsafePtr(), slice.Length, comp);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static int BinarySearch<T>(this NativeSlice<T> slice, T value) where T : unmanaged, IComparable<T>
		{
			return slice.BinarySearch(value, default(DefaultComparer<T>));
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		public unsafe static int BinarySearch<T, U>(this NativeSlice<T> slice, T value, U comp) where T : unmanaged where U : IComparer<T>
		{
			return BinarySearch((T*)slice.GetUnsafeReadOnlyPtr(), slice.Length, value, comp);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		internal unsafe static void IntroSort<T, U>(void* array, int length, U comp) where T : unmanaged where U : IComparer<T>
		{
			IntroSort_R<T, U>(array, 0, length - 1, 2 * CollectionHelper.Log2Floor(length), comp);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(DefaultComparer<int>)
		})]
		internal unsafe static void IntroSort_R<T, U>(void* array, int lo, int hi, int depth, U comp) where T : unmanaged where U : IComparer<T>
		{
			while (hi > lo)
			{
				int num = hi - lo + 1;
				if (num <= 16)
				{
					switch (num)
					{
					case 1:
						break;
					case 2:
						SwapIfGreaterWithItems<T, U>(array, lo, hi, comp);
						break;
					case 3:
						SwapIfGreaterWithItems<T, U>(array, lo, hi - 1, comp);
						SwapIfGreaterWithItems<T, U>(array, lo, hi, comp);
						SwapIfGreaterWithItems<T, U>(array, hi - 1, hi, comp);
						break;
					default:
						InsertionSort<T, U>(array, lo, hi, comp);
						break;
					}
					break;
				}
				if (depth == 0)
				{
					HeapSort<T, U>(array, lo, hi, comp);
					break;
				}
				depth--;
				int num2 = Partition<T, U>(array, lo, hi, comp);
				IntroSort_R<T, U>(array, num2 + 1, hi, depth, comp);
				hi = num2 - 1;
			}
		}

		private unsafe static void InsertionSort<T, U>(void* array, int lo, int hi, U comp) where T : unmanaged where U : IComparer<T>
		{
			for (int i = lo; i < hi; i++)
			{
				int num = i;
				T val = UnsafeUtility.ReadArrayElement<T>(array, i + 1);
				while (num >= lo && comp.Compare(val, UnsafeUtility.ReadArrayElement<T>(array, num)) < 0)
				{
					UnsafeUtility.WriteArrayElement(array, num + 1, UnsafeUtility.ReadArrayElement<T>(array, num));
					num--;
				}
				UnsafeUtility.WriteArrayElement(array, num + 1, val);
			}
		}

		private unsafe static int Partition<T, U>(void* array, int lo, int hi, U comp) where T : unmanaged where U : IComparer<T>
		{
			int num = lo + (hi - lo) / 2;
			SwapIfGreaterWithItems<T, U>(array, lo, num, comp);
			SwapIfGreaterWithItems<T, U>(array, lo, hi, comp);
			SwapIfGreaterWithItems<T, U>(array, num, hi, comp);
			T x = UnsafeUtility.ReadArrayElement<T>(array, num);
			Swap<T>(array, num, hi - 1);
			int num2 = lo;
			int num3 = hi - 1;
			while (num2 < num3)
			{
				while (num2 < hi)
				{
					T y = UnsafeUtility.ReadArrayElement<T>(array, ++num2);
					if (comp.Compare(x, y) <= 0)
					{
						break;
					}
				}
				while (num3 > num2)
				{
					T y2 = UnsafeUtility.ReadArrayElement<T>(array, --num3);
					if (comp.Compare(x, y2) >= 0)
					{
						break;
					}
				}
				if (num2 >= num3)
				{
					break;
				}
				Swap<T>(array, num2, num3);
			}
			Swap<T>(array, num2, hi - 1);
			return num2;
		}

		private unsafe static void HeapSort<T, U>(void* array, int lo, int hi, U comp) where T : unmanaged where U : IComparer<T>
		{
			int num = hi - lo + 1;
			for (int num2 = num / 2; num2 >= 1; num2--)
			{
				Heapify<T, U>(array, num2, num, lo, comp);
			}
			for (int num3 = num; num3 > 1; num3--)
			{
				Swap<T>(array, lo, lo + num3 - 1);
				Heapify<T, U>(array, 1, num3 - 1, lo, comp);
			}
		}

		private unsafe static void Heapify<T, U>(void* array, int i, int n, int lo, U comp) where T : unmanaged where U : IComparer<T>
		{
			T val = UnsafeUtility.ReadArrayElement<T>(array, lo + i - 1);
			while (i <= n / 2)
			{
				int num = 2 * i;
				if (num < n)
				{
					T x = UnsafeUtility.ReadArrayElement<T>(array, lo + num - 1);
					T y = UnsafeUtility.ReadArrayElement<T>(array, lo + num);
					if (comp.Compare(x, y) < 0)
					{
						num++;
					}
				}
				T x2 = UnsafeUtility.ReadArrayElement<T>(array, lo + num - 1);
				if (comp.Compare(x2, val) < 0)
				{
					break;
				}
				UnsafeUtility.WriteArrayElement(array, lo + i - 1, UnsafeUtility.ReadArrayElement<T>(array, lo + num - 1));
				i = num;
			}
			UnsafeUtility.WriteArrayElement(array, lo + i - 1, val);
		}

		private unsafe static void Swap<T>(void* array, int lhs, int rhs) where T : unmanaged
		{
			T value = UnsafeUtility.ReadArrayElement<T>(array, lhs);
			UnsafeUtility.WriteArrayElement(array, lhs, UnsafeUtility.ReadArrayElement<T>(array, rhs));
			UnsafeUtility.WriteArrayElement(array, rhs, value);
		}

		private unsafe static void SwapIfGreaterWithItems<T, U>(void* array, int lhs, int rhs, U comp) where T : unmanaged where U : IComparer<T>
		{
			if (lhs != rhs && comp.Compare(UnsafeUtility.ReadArrayElement<T>(array, lhs), UnsafeUtility.ReadArrayElement<T>(array, rhs)) > 0)
			{
				Swap<T>(array, lhs, rhs);
			}
		}

		private unsafe static void IntroSortStruct<T, U>(void* array, int length, U comp) where T : unmanaged where U : IComparer<T>
		{
			IntroSortStruct_R<T, U>(array, 0, length - 1, 2 * CollectionHelper.Log2Floor(length), comp);
		}

		private unsafe static void IntroSortStruct_R<T, U>(void* array, in int lo, in int _hi, int depth, U comp) where T : unmanaged where U : IComparer<T>
		{
			int hi = _hi;
			while (hi > lo)
			{
				int num = hi - lo + 1;
				if (num <= 16)
				{
					switch (num)
					{
					case 1:
						break;
					case 2:
						SwapIfGreaterWithItemsStruct<T, U>(array, lo, hi, comp);
						break;
					case 3:
						SwapIfGreaterWithItemsStruct<T, U>(array, lo, hi - 1, comp);
						SwapIfGreaterWithItemsStruct<T, U>(array, lo, hi, comp);
						SwapIfGreaterWithItemsStruct<T, U>(array, hi - 1, hi, comp);
						break;
					default:
						InsertionSortStruct<T, U>(array, in lo, in hi, comp);
						break;
					}
					break;
				}
				if (depth == 0)
				{
					HeapSortStruct<T, U>(array, in lo, in hi, comp);
					break;
				}
				depth--;
				int num2 = PartitionStruct<T, U>(array, in lo, in hi, comp);
				IntroSortStruct_R<T, U>(array, num2 + 1, in hi, depth, comp);
				hi = num2 - 1;
			}
		}

		private unsafe static void InsertionSortStruct<T, U>(void* array, in int lo, in int hi, U comp) where T : unmanaged where U : IComparer<T>
		{
			for (int i = lo; i < hi; i++)
			{
				int num = i;
				T val = UnsafeUtility.ReadArrayElement<T>(array, i + 1);
				while (num >= lo && comp.Compare(val, UnsafeUtility.ReadArrayElement<T>(array, num)) < 0)
				{
					UnsafeUtility.WriteArrayElement(array, num + 1, UnsafeUtility.ReadArrayElement<T>(array, num));
					num--;
				}
				UnsafeUtility.WriteArrayElement(array, num + 1, val);
			}
		}

		private unsafe static int PartitionStruct<T, U>(void* array, in int lo, in int hi, U comp) where T : unmanaged where U : IComparer<T>
		{
			int num = lo + (hi - lo) / 2;
			SwapIfGreaterWithItemsStruct<T, U>(array, lo, num, comp);
			SwapIfGreaterWithItemsStruct<T, U>(array, lo, hi, comp);
			SwapIfGreaterWithItemsStruct<T, U>(array, num, hi, comp);
			T x = UnsafeUtility.ReadArrayElement<T>(array, num);
			SwapStruct<T>(array, num, hi - 1);
			int num2 = lo;
			int num3 = hi - 1;
			while (num2 < num3)
			{
				while (num2 < hi)
				{
					T y = UnsafeUtility.ReadArrayElement<T>(array, ++num2);
					if (comp.Compare(x, y) <= 0)
					{
						break;
					}
				}
				while (num3 > num2)
				{
					T y2 = UnsafeUtility.ReadArrayElement<T>(array, --num3);
					if (comp.Compare(x, y2) >= 0)
					{
						break;
					}
				}
				if (num2 >= num3)
				{
					break;
				}
				SwapStruct<T>(array, num2, num3);
			}
			SwapStruct<T>(array, num2, hi - 1);
			return num2;
		}

		private unsafe static void HeapSortStruct<T, U>(void* array, in int lo, in int hi, U comp) where T : unmanaged where U : IComparer<T>
		{
			int num = hi - lo + 1;
			for (int num2 = num / 2; num2 >= 1; num2--)
			{
				HeapifyStruct<T, U>(array, num2, num, in lo, comp);
			}
			for (int num3 = num; num3 > 1; num3--)
			{
				SwapStruct<T>(array, lo, lo + num3 - 1);
				HeapifyStruct<T, U>(array, 1, num3 - 1, in lo, comp);
			}
		}

		private unsafe static void HeapifyStruct<T, U>(void* array, int i, int n, in int lo, U comp) where T : unmanaged where U : IComparer<T>
		{
			T val = UnsafeUtility.ReadArrayElement<T>(array, lo + i - 1);
			while (i <= n / 2)
			{
				int num = 2 * i;
				if (num < n)
				{
					T x = UnsafeUtility.ReadArrayElement<T>(array, lo + num - 1);
					T y = UnsafeUtility.ReadArrayElement<T>(array, lo + num);
					if (comp.Compare(x, y) < 0)
					{
						num++;
					}
				}
				T x2 = UnsafeUtility.ReadArrayElement<T>(array, lo + num - 1);
				if (comp.Compare(x2, val) < 0)
				{
					break;
				}
				UnsafeUtility.WriteArrayElement(array, lo + i - 1, UnsafeUtility.ReadArrayElement<T>(array, lo + num - 1));
				i = num;
			}
			UnsafeUtility.WriteArrayElement(array, lo + i - 1, val);
		}

		private unsafe static void SwapStruct<T>(void* array, int lhs, int rhs) where T : unmanaged
		{
			T value = UnsafeUtility.ReadArrayElement<T>(array, lhs);
			UnsafeUtility.WriteArrayElement(array, lhs, UnsafeUtility.ReadArrayElement<T>(array, rhs));
			UnsafeUtility.WriteArrayElement(array, rhs, value);
		}

		private unsafe static void SwapIfGreaterWithItemsStruct<T, U>(void* array, int lhs, int rhs, U comp) where T : unmanaged where U : IComparer<T>
		{
			if (lhs != rhs && comp.Compare(UnsafeUtility.ReadArrayElement<T>(array, lhs), UnsafeUtility.ReadArrayElement<T>(array, rhs)) > 0)
			{
				SwapStruct<T>(array, lhs, rhs);
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckStrideMatchesSize<T>(int stride) where T : unmanaged
		{
			if (stride != UnsafeUtility.SizeOf<T>())
			{
				throw new InvalidOperationException("Sort requires that stride matches the size of the source type");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private unsafe static void CheckComparer<T, U>(T* array, int length, U comp) where T : unmanaged where U : IComparer<T>
		{
			if (length <= 0)
			{
				return;
			}
			T val = *array;
			if (comp.Compare(val, val) != 0)
			{
				throw new InvalidOperationException("Comparison function is incorrect. Compare(a, a) must return 0/equal.");
			}
			int i = 1;
			for (int num = math.min(length, 8); i < num; i++)
			{
				T val2 = array[i];
				if (comp.Compare(val, val2) != 0 || comp.Compare(val2, val) != 0)
				{
					if (comp.Compare(val, val2) == 0)
					{
						throw new InvalidOperationException("Comparison function is incorrect. Compare(a, b) of two different values should not return 0/equal.");
					}
					if (comp.Compare(val2, val) == 0)
					{
						throw new InvalidOperationException("Comparison function is incorrect. Compare(b, a) of two different values should not return 0/equal.");
					}
					if (comp.Compare(val, val2) == comp.Compare(val2, val))
					{
						throw new InvalidOperationException("Comparison function is incorrect. Compare(a, b) when a and b are different values should not return the same value as Compare(b, a).");
					}
					break;
				}
			}
		}
	}
	[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "UNITY_2020_2_OR_NEWER", GenericTypeArguments = new Type[]
	{
		typeof(int),
		typeof(NativeSortExtension.DefaultComparer<int>)
	})]
	public struct SortJob<T, U> where T : unmanaged where U : IComparer<T>
	{
		[BurstCompile]
		public struct SegmentSort : IJobParallelFor
		{
			[NativeDisableUnsafePtrRestriction]
			internal unsafe T* Data;

			internal U Comp;

			internal int Length;

			internal int SegmentWidth;

			public unsafe void Execute(int index)
			{
				int num = index * SegmentWidth;
				int length = ((Length - num < SegmentWidth) ? (Length - num) : SegmentWidth);
				NativeSortExtension.Sort(Data + num, length, Comp);
			}
		}

		[BurstCompile]
		public struct SegmentSortMerge : IJob
		{
			[NativeDisableUnsafePtrRestriction]
			internal unsafe T* Data;

			internal U Comp;

			internal int Length;

			internal int SegmentWidth;

			public unsafe void Execute()
			{
				int num = (Length + (SegmentWidth - 1)) / SegmentWidth;
				int* ptr = stackalloc int[num];
				T* ptr2 = (T*)Memory.Unmanaged.Allocate(UnsafeUtility.SizeOf<T>() * Length, 16, Allocator.Temp);
				for (int i = 0; i < Length; i++)
				{
					int num2 = -1;
					T val = default(T);
					for (int j = 0; j < num; j++)
					{
						int num3 = j * SegmentWidth;
						int num4 = ptr[j];
						int num5 = ((Length - num3 < SegmentWidth) ? (Length - num3) : SegmentWidth);
						if (num4 != num5)
						{
							T val2 = Data[num3 + num4];
							if (num2 == -1 || Comp.Compare(val2, val) <= 0)
							{
								val = val2;
								num2 = j;
							}
						}
					}
					ptr[num2]++;
					ptr2[i] = val;
				}
				UnsafeUtility.MemCpy(Data, ptr2, UnsafeUtility.SizeOf<T>() * Length);
			}
		}

		public unsafe T* Data;

		public U Comp;

		public int Length;

		public unsafe JobHandle Schedule(JobHandle inputDeps = default(JobHandle))
		{
			if (Length == 0)
			{
				return inputDeps;
			}
			int num = (Length + 1023) / 1024;
			int threadIndexCount = JobsUtility.ThreadIndexCount;
			int num2 = math.max(1, threadIndexCount);
			int innerloopBatchCount = num / num2;
			JobHandle dependsOn = IJobParallelForExtensions.Schedule(new SegmentSort
			{
				Data = Data,
				Comp = Comp,
				Length = Length,
				SegmentWidth = 1024
			}, num, innerloopBatchCount, inputDeps);
			return new SegmentSortMerge
			{
				Data = Data,
				Comp = Comp,
				Length = Length,
				SegmentWidth = 1024
			}.Schedule(dependsOn);
		}
	}
	[GenerateTestsForBurstCompatibility(RequiredUnityDefine = "UNITY_2020_2_OR_NEWER", GenericTypeArguments = new Type[]
	{
		typeof(int),
		typeof(NativeSortExtension.DefaultComparer<int>)
	})]
	public struct SortJobDefer<T, U> where T : unmanaged where U : IComparer<T>
	{
		[BurstCompile]
		public struct SegmentSort : IJobParallelForDefer
		{
			[ReadOnly]
			internal NativeList<T> DataRO;

			[NativeDisableUnsafePtrRestriction]
			internal unsafe UnsafeList<T>* Data;

			internal U Comp;

			internal int SegmentWidth;

			public unsafe void Execute(int index)
			{
				int num = index * SegmentWidth;
				int length = ((Data->Length - num < SegmentWidth) ? (Data->Length - num) : SegmentWidth);
				NativeSortExtension.Sort(Data->Ptr + num, length, Comp);
			}
		}

		[BurstCompile]
		public struct SegmentSortMerge : IJob
		{
			[NativeDisableUnsafePtrRestriction]
			internal NativeList<T> Data;

			internal U Comp;

			internal int SegmentWidth;

			public unsafe void Execute()
			{
				int length = Data.Length;
				T* unsafePtr = Data.GetUnsafePtr();
				int num = (length + (SegmentWidth - 1)) / SegmentWidth;
				int* ptr = stackalloc int[num];
				T* ptr2 = (T*)Memory.Unmanaged.Allocate(UnsafeUtility.SizeOf<T>() * length, 16, Allocator.Temp);
				for (int i = 0; i < length; i++)
				{
					int num2 = -1;
					T val = default(T);
					for (int j = 0; j < num; j++)
					{
						int num3 = j * SegmentWidth;
						int num4 = ptr[j];
						int num5 = ((length - num3 < SegmentWidth) ? (length - num3) : SegmentWidth);
						if (num4 != num5)
						{
							T val2 = unsafePtr[num3 + num4];
							if (num2 == -1 || Comp.Compare(val2, val) <= 0)
							{
								val = val2;
								num2 = j;
							}
						}
					}
					ptr[num2]++;
					ptr2[i] = val;
				}
				UnsafeUtility.MemCpy(unsafePtr, ptr2, UnsafeUtility.SizeOf<T>() * length);
			}
		}

		public NativeList<T> Data;

		public U Comp;

		public unsafe JobHandle Schedule(JobHandle inputDeps = default(JobHandle))
		{
			SegmentSort jobData = new SegmentSort
			{
				DataRO = Data,
				Data = Data.m_ListData,
				Comp = Comp,
				SegmentWidth = 1024
			};
			JobHandle dependsOn = IJobParallelForDeferExtensions.ScheduleByRef(ref jobData, Data, 1024, inputDeps);
			return new SegmentSortMerge
			{
				Data = Data,
				Comp = Comp,
				SegmentWidth = 1024
			}.Schedule(dependsOn);
		}
	}
	[NativeContainer]
	[GenerateTestsForBurstCompatibility]
	public struct NativeStream : INativeDisposable, IDisposable
	{
		[BurstCompile]
		private struct ConstructJobList : IJob
		{
			public NativeStream Container;

			[ReadOnly]
			[NativeDisableUnsafePtrRestriction]
			public unsafe UntypedUnsafeList* List;

			public unsafe void Execute()
			{
				Container.AllocateForEach(List->m_length);
			}
		}

		[BurstCompile]
		private struct ConstructJob : IJob
		{
			public NativeStream Container;

			[ReadOnly]
			public NativeArray<int> Length;

			public void Execute()
			{
				Container.AllocateForEach(Length[0]);
			}
		}

		[NativeContainer]
		[NativeContainerSupportsMinMaxWriteRestriction]
		[GenerateTestsForBurstCompatibility]
		public struct Writer
		{
			private UnsafeStream.Writer m_Writer;

			public int ForEachCount => m_Writer.ForEachCount;

			internal Writer(ref NativeStream stream)
			{
				m_Writer = stream.m_Stream.AsWriter();
			}

			public void PatchMinMaxRange(int foreEachIndex)
			{
			}

			public void BeginForEachIndex(int foreachIndex)
			{
				m_Writer.BeginForEachIndex(foreachIndex);
			}

			public void EndForEachIndex()
			{
				m_Writer.EndForEachIndex();
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public void Write<T>(T value) where T : unmanaged
			{
				Allocate<T>() = value;
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public unsafe ref T Allocate<T>() where T : unmanaged
			{
				int size = UnsafeUtility.SizeOf<T>();
				return ref UnsafeUtility.AsRef<T>(Allocate(size));
			}

			public unsafe byte* Allocate(int size)
			{
				return m_Writer.Allocate(size);
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private void CheckBeginForEachIndex(int foreachIndex)
			{
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private void CheckEndForEachIndex()
			{
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private void CheckAllocateSize(int size)
			{
			}
		}

		[NativeContainer]
		[NativeContainerIsReadOnly]
		[GenerateTestsForBurstCompatibility]
		public struct Reader
		{
			private UnsafeStream.Reader m_Reader;

			public int ForEachCount => m_Reader.ForEachCount;

			public int RemainingItemCount => m_Reader.RemainingItemCount;

			internal Reader(ref NativeStream stream)
			{
				m_Reader = stream.m_Stream.AsReader();
			}

			public int BeginForEachIndex(int foreachIndex)
			{
				return m_Reader.BeginForEachIndex(foreachIndex);
			}

			public void EndForEachIndex()
			{
				m_Reader.EndForEachIndex();
			}

			public unsafe byte* ReadUnsafePtr(int size)
			{
				m_Reader.m_RemainingItemCount--;
				byte* currentPtr = m_Reader.m_CurrentPtr;
				m_Reader.m_CurrentPtr += size;
				if (m_Reader.m_CurrentPtr > m_Reader.m_CurrentBlockEnd)
				{
					m_Reader.m_CurrentBlock = m_Reader.m_CurrentBlock->Next;
					m_Reader.m_CurrentPtr = m_Reader.m_CurrentBlock->Data;
					m_Reader.m_CurrentBlockEnd = (byte*)m_Reader.m_CurrentBlock + 4096;
					currentPtr = m_Reader.m_CurrentPtr;
					m_Reader.m_CurrentPtr += size;
				}
				return currentPtr;
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public unsafe ref T Read<T>() where T : unmanaged
			{
				int size = UnsafeUtility.SizeOf<T>();
				return ref UnsafeUtility.AsRef<T>(ReadUnsafePtr(size));
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public ref T Peek<T>() where T : unmanaged
			{
				UnsafeUtility.SizeOf<T>();
				return ref m_Reader.Peek<T>();
			}

			public int Count()
			{
				return m_Reader.Count();
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private void CheckNotReadingOutOfBounds(int size)
			{
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			private void CheckRead()
			{
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private void CheckReadSize(int size)
			{
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private void CheckBeginForEachIndex(int forEachIndex)
			{
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private unsafe void CheckEndForEachIndex()
			{
				if (m_Reader.m_RemainingItemCount != 0)
				{
					throw new ArgumentException("Not all elements (Count) have been read. If this is intentional, simply skip calling EndForEachIndex();");
				}
				if (m_Reader.m_CurrentBlockEnd != m_Reader.m_CurrentPtr)
				{
					throw new ArgumentException("Not all data (Data Size) has been read. If this is intentional, simply skip calling EndForEachIndex();");
				}
			}
		}

		private UnsafeStream m_Stream;

		public readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Stream.IsCreated;
			}
		}

		public readonly int ForEachCount => m_Stream.ForEachCount;

		public NativeStream(int bufferCount, AllocatorManager.AllocatorHandle allocator)
		{
			AllocateBlock(out this, allocator);
			m_Stream.AllocateForEach(bufferCount);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static JobHandle ScheduleConstruct<T>(out NativeStream stream, NativeList<T> bufferCount, JobHandle dependency, AllocatorManager.AllocatorHandle allocator) where T : unmanaged
		{
			AllocateBlock(out stream, allocator);
			return new ConstructJobList
			{
				List = (UntypedUnsafeList*)bufferCount.GetUnsafeList(),
				Container = stream
			}.Schedule(dependency);
		}

		public static JobHandle ScheduleConstruct(out NativeStream stream, NativeArray<int> bufferCount, JobHandle dependency, AllocatorManager.AllocatorHandle allocator)
		{
			AllocateBlock(out stream, allocator);
			return new ConstructJob
			{
				Length = bufferCount,
				Container = stream
			}.Schedule(dependency);
		}

		public readonly bool IsEmpty()
		{
			return m_Stream.IsEmpty();
		}

		public Reader AsReader()
		{
			return new Reader(ref this);
		}

		public Writer AsWriter()
		{
			return new Writer(ref this);
		}

		public int Count()
		{
			return m_Stream.Count();
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public NativeArray<T> ToNativeArray<T>(AllocatorManager.AllocatorHandle allocator) where T : unmanaged
		{
			return m_Stream.ToNativeArray<T>(allocator);
		}

		public void Dispose()
		{
			if (IsCreated)
			{
				m_Stream.Dispose();
			}
		}

		public JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new NativeStreamDisposeJob
			{
				Data = new NativeStreamDispose
				{
					m_StreamData = m_Stream
				}
			}.Schedule(inputDeps);
			m_Stream = default(UnsafeStream);
			return result;
		}

		private static void AllocateBlock(out NativeStream stream, AllocatorManager.AllocatorHandle allocator)
		{
			UnsafeStream.AllocateBlock(out stream.m_Stream, allocator);
		}

		private void AllocateForEach(int forEachCount)
		{
			m_Stream.AllocateForEach(forEachCount);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckForEachCountGreaterThanZero(int forEachCount)
		{
			if (forEachCount <= 0)
			{
				throw new ArgumentException("foreachCount must be > 0", "foreachCount");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private readonly void CheckRead()
		{
		}
	}
	[NativeContainer]
	[GenerateTestsForBurstCompatibility]
	internal struct NativeStreamDispose
	{
		public UnsafeStream m_StreamData;

		public void Dispose()
		{
			m_StreamData.Dispose();
		}
	}
	[BurstCompile]
	internal struct NativeStreamDisposeJob : IJob
	{
		public NativeStreamDispose Data;

		public void Execute()
		{
			Data.Dispose();
		}
	}
	[NativeContainer]
	[DebuggerDisplay("Length = {Length}")]
	[GenerateTestsForBurstCompatibility]
	public struct NativeText : INativeList<byte>, IIndexable<byte>, INativeDisposable, IDisposable, IUTF8Bytes, IComparable<string>, IEquatable<string>, IComparable<NativeText>, IEquatable<NativeText>, IComparable<FixedString32Bytes>, IEquatable<FixedString32Bytes>, IComparable<FixedString64Bytes>, IEquatable<FixedString64Bytes>, IComparable<FixedString128Bytes>, IEquatable<FixedString128Bytes>, IComparable<FixedString512Bytes>, IEquatable<FixedString512Bytes>, IComparable<FixedString4096Bytes>, IEquatable<FixedString4096Bytes>
	{
		public struct Enumerator : IEnumerator<Unicode.Rune>, IEnumerator, IDisposable
		{
			private ReadOnly target;

			private int offset;

			private Unicode.Rune current;

			object IEnumerator.Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return Current;
				}
			}

			public Unicode.Rune Current => current;

			public Enumerator(NativeText source)
			{
				target = source.AsReadOnly();
				offset = 0;
				current = default(Unicode.Rune);
			}

			public Enumerator(ReadOnly source)
			{
				target = source;
				offset = 0;
				current = default(Unicode.Rune);
			}

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public unsafe bool MoveNext()
			{
				if (offset >= target.Length)
				{
					return false;
				}
				Unicode.Utf8ToUcs(out current, target.GetUnsafePtr(), ref offset, target.Length);
				return true;
			}

			public void Reset()
			{
				offset = 0;
				current = default(Unicode.Rune);
			}
		}

		[NativeContainer]
		[NativeContainerIsReadOnly]
		public struct ReadOnly : INativeList<byte>, IIndexable<byte>, IUTF8Bytes, IComparable<string>, IEquatable<string>, IComparable<NativeText>, IEquatable<NativeText>, IComparable<FixedString32Bytes>, IEquatable<FixedString32Bytes>, IComparable<FixedString64Bytes>, IEquatable<FixedString64Bytes>, IComparable<FixedString128Bytes>, IEquatable<FixedString128Bytes>, IComparable<FixedString512Bytes>, IEquatable<FixedString512Bytes>, IComparable<FixedString4096Bytes>, IEquatable<FixedString4096Bytes>
		{
			[NativeDisableUnsafePtrRestriction]
			internal unsafe UnsafeText* m_Data;

			public unsafe int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				readonly get
				{
					return m_Data->Capacity;
				}
				set
				{
				}
			}

			public unsafe bool IsEmpty
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				readonly get
				{
					if (m_Data == null)
					{
						return true;
					}
					return m_Data->IsEmpty;
				}
				set
				{
				}
			}

			public unsafe int Length
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				readonly get
				{
					return m_Data->Length;
				}
				set
				{
				}
			}

			public unsafe byte this[int index]
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				readonly get
				{
					return m_Data->ElementAt(index);
				}
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				set
				{
				}
			}

			[CreateProperty]
			[EditorBrowsable(EditorBrowsableState.Never)]
			[ExcludeFromBurstCompatTesting("Returns managed string")]
			public string Value => ToString();

			internal unsafe ReadOnly(UnsafeText* text)
			{
				m_Data = text;
			}

			public void Clear()
			{
			}

			public ref byte ElementAt(int index)
			{
				throw new NotSupportedException("Trying to retrieve non-readonly ref to NativeText.ReadOnly data. This is not permitted.");
			}

			public unsafe byte* GetUnsafePtr()
			{
				return m_Data->GetUnsafePtr();
			}

			public bool TryResize(int newLength, NativeArrayOptions clearOptions = NativeArrayOptions.ClearMemory)
			{
				return false;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			internal unsafe static void CheckNull(void* dataPtr)
			{
				if (dataPtr == null)
				{
					throw new InvalidOperationException("NativeText.ReadOnly has yet to be created or has been destroyed!");
				}
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			private readonly void CheckRead()
			{
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private void ErrorWrite()
			{
				throw new NotSupportedException("Trying to write to a NativeText.ReadOnly. Write operations are not permitted and are ignored.");
			}

			[ExcludeFromBurstCompatTesting("Takes managed string")]
			public unsafe int CompareTo(string other)
			{
				return m_Data->ToString().CompareTo(other);
			}

			[ExcludeFromBurstCompatTesting("Takes managed string")]
			public unsafe bool Equals(string other)
			{
				return m_Data->ToString().Equals(other);
			}

			public unsafe int CompareTo(ReadOnly other)
			{
				return FixedStringMethods.CompareTo(ref *m_Data, in *other.m_Data);
			}

			public unsafe bool Equals(ReadOnly other)
			{
				return FixedStringMethods.Equals(ref *m_Data, in *other.m_Data);
			}

			public unsafe int CompareTo(NativeText other)
			{
				return FixedStringMethods.CompareTo(ref this, in *other.m_Data);
			}

			public unsafe bool Equals(NativeText other)
			{
				return FixedStringMethods.Equals(ref this, in *other.m_Data);
			}

			public int CompareTo(FixedString32Bytes other)
			{
				return FixedStringMethods.CompareTo(ref this, in other);
			}

			public unsafe static bool operator ==(in ReadOnly a, in FixedString32Bytes b)
			{
				UnsafeText data = *a.m_Data;
				int length = data.Length;
				int utf8LengthInBytes = b.utf8LengthInBytes;
				byte* unsafePtr = data.GetUnsafePtr();
				byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
				return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(unsafePtr, length, bBytes, utf8LengthInBytes);
			}

			public static bool operator !=(in ReadOnly a, in FixedString32Bytes b)
			{
				return !(a == b);
			}

			public bool Equals(FixedString32Bytes other)
			{
				return this == other;
			}

			public int CompareTo(FixedString64Bytes other)
			{
				return FixedStringMethods.CompareTo(ref this, in other);
			}

			public unsafe static bool operator ==(in ReadOnly a, in FixedString64Bytes b)
			{
				UnsafeText data = *a.m_Data;
				int length = data.Length;
				int utf8LengthInBytes = b.utf8LengthInBytes;
				byte* unsafePtr = data.GetUnsafePtr();
				byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
				return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(unsafePtr, length, bBytes, utf8LengthInBytes);
			}

			public static bool operator !=(in ReadOnly a, in FixedString64Bytes b)
			{
				return !(a == b);
			}

			public bool Equals(FixedString64Bytes other)
			{
				return this == other;
			}

			public int CompareTo(FixedString128Bytes other)
			{
				return FixedStringMethods.CompareTo(ref this, in other);
			}

			public unsafe static bool operator ==(in ReadOnly a, in FixedString128Bytes b)
			{
				UnsafeText data = *a.m_Data;
				int length = data.Length;
				int utf8LengthInBytes = b.utf8LengthInBytes;
				byte* unsafePtr = data.GetUnsafePtr();
				byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
				return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(unsafePtr, length, bBytes, utf8LengthInBytes);
			}

			public static bool operator !=(in ReadOnly a, in FixedString128Bytes b)
			{
				return !(a == b);
			}

			public bool Equals(FixedString128Bytes other)
			{
				return this == other;
			}

			public int CompareTo(FixedString512Bytes other)
			{
				return FixedStringMethods.CompareTo(ref this, in other);
			}

			public unsafe static bool operator ==(in ReadOnly a, in FixedString512Bytes b)
			{
				UnsafeText data = *a.m_Data;
				int length = data.Length;
				int utf8LengthInBytes = b.utf8LengthInBytes;
				byte* unsafePtr = data.GetUnsafePtr();
				byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
				return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(unsafePtr, length, bBytes, utf8LengthInBytes);
			}

			public static bool operator !=(in ReadOnly a, in FixedString512Bytes b)
			{
				return !(a == b);
			}

			public bool Equals(FixedString512Bytes other)
			{
				return this == other;
			}

			public int CompareTo(FixedString4096Bytes other)
			{
				return FixedStringMethods.CompareTo(ref this, in other);
			}

			public unsafe static bool operator ==(in ReadOnly a, in FixedString4096Bytes b)
			{
				UnsafeText data = *a.m_Data;
				int length = data.Length;
				int utf8LengthInBytes = b.utf8LengthInBytes;
				byte* unsafePtr = data.GetUnsafePtr();
				byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
				return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(unsafePtr, length, bBytes, utf8LengthInBytes);
			}

			public static bool operator !=(in ReadOnly a, in FixedString4096Bytes b)
			{
				return !(a == b);
			}

			public bool Equals(FixedString4096Bytes other)
			{
				return this == other;
			}

			[ExcludeFromBurstCompatTesting("Returns managed string")]
			public unsafe override string ToString()
			{
				if (m_Data == null)
				{
					return "";
				}
				return FixedStringMethods.ConvertToString(ref this);
			}

			public override int GetHashCode()
			{
				return FixedStringMethods.ComputeHashCode(ref this);
			}

			[ExcludeFromBurstCompatTesting("Takes managed object")]
			public override bool Equals(object other)
			{
				if (other == null)
				{
					return false;
				}
				if (other is string other2)
				{
					return Equals(other2);
				}
				if (other is NativeText other3)
				{
					return Equals(other3);
				}
				if (other is ReadOnly other4)
				{
					return Equals(other4);
				}
				if (other is FixedString32Bytes other5)
				{
					return Equals(other5);
				}
				if (other is FixedString64Bytes other6)
				{
					return Equals(other6);
				}
				if (other is FixedString128Bytes other7)
				{
					return Equals(other7);
				}
				if (other is FixedString512Bytes other8)
				{
					return Equals(other8);
				}
				if (other is FixedString4096Bytes other9)
				{
					return Equals(other9);
				}
				return false;
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(this);
			}
		}

		[NativeDisableUnsafePtrRestriction]
		internal unsafe UnsafeText* m_Data;

		public unsafe int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return m_Data->Length;
			}
			set
			{
				m_Data->Length = value;
			}
		}

		public unsafe int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return m_Data->Capacity;
			}
			set
			{
				m_Data->Capacity = value;
			}
		}

		public unsafe readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (!IsCreated)
				{
					return true;
				}
				return m_Data->IsEmpty;
			}
		}

		public unsafe readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data != null;
			}
		}

		public unsafe byte this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data->ElementAt(index);
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				m_Data->ElementAt(index) = value;
			}
		}

		[CreateProperty]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[ExcludeFromBurstCompatTesting("Returns managed string")]
		public string Value => ToString();

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public NativeText(string source, Allocator allocator)
			: this(source, (AllocatorManager.AllocatorHandle)allocator)
		{
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public unsafe NativeText(string source, AllocatorManager.AllocatorHandle allocator)
			: this(source.Length * 2, allocator)
		{
			Length = source.Length * 2;
			fixed (char* src = source)
			{
				if (UTF8ArrayUnsafeUtility.Copy(GetUnsafePtr(), out var destLength, Capacity, src, source.Length) != CopyError.None)
				{
					m_Data->Dispose();
					m_Data = UnsafeText.Alloc(allocator);
					*m_Data = default(UnsafeText);
				}
				Length = destLength;
			}
		}

		public NativeText(int capacity, Allocator allocator)
			: this(capacity, (AllocatorManager.AllocatorHandle)allocator)
		{
		}

		public unsafe NativeText(int capacity, AllocatorManager.AllocatorHandle allocator)
		{
			m_Data = UnsafeText.Alloc(allocator);
			*m_Data = new UnsafeText(capacity, allocator);
		}

		public NativeText(Allocator allocator)
			: this((AllocatorManager.AllocatorHandle)allocator)
		{
		}

		public NativeText(AllocatorManager.AllocatorHandle allocator)
			: this(512, allocator)
		{
		}

		public unsafe NativeText(in FixedString32Bytes source, AllocatorManager.AllocatorHandle allocator)
			: this(source.utf8LengthInBytes, allocator)
		{
			Length = source.utf8LengthInBytes;
			byte* source2 = (byte*)UnsafeUtilityExtensions.AddressOf(in source.bytes);
			UnsafeUtility.MemCpy(m_Data->GetUnsafePtr(), source2, source.utf8LengthInBytes);
		}

		public NativeText(in FixedString32Bytes source, Allocator allocator)
			: this(in source, (AllocatorManager.AllocatorHandle)allocator)
		{
		}

		public unsafe NativeText(in FixedString64Bytes source, AllocatorManager.AllocatorHandle allocator)
			: this(source.utf8LengthInBytes, allocator)
		{
			Length = source.utf8LengthInBytes;
			byte* source2 = (byte*)UnsafeUtilityExtensions.AddressOf(in source.bytes);
			UnsafeUtility.MemCpy(m_Data->GetUnsafePtr(), source2, source.utf8LengthInBytes);
		}

		public NativeText(in FixedString64Bytes source, Allocator allocator)
			: this(in source, (AllocatorManager.AllocatorHandle)allocator)
		{
		}

		public unsafe NativeText(in FixedString128Bytes source, AllocatorManager.AllocatorHandle allocator)
			: this(source.utf8LengthInBytes, allocator)
		{
			Length = source.utf8LengthInBytes;
			byte* source2 = (byte*)UnsafeUtilityExtensions.AddressOf(in source.bytes);
			UnsafeUtility.MemCpy(m_Data->GetUnsafePtr(), source2, source.utf8LengthInBytes);
		}

		public NativeText(in FixedString128Bytes source, Allocator allocator)
			: this(in source, (AllocatorManager.AllocatorHandle)allocator)
		{
		}

		public unsafe NativeText(in FixedString512Bytes source, AllocatorManager.AllocatorHandle allocator)
			: this(source.utf8LengthInBytes, allocator)
		{
			Length = source.utf8LengthInBytes;
			byte* source2 = (byte*)UnsafeUtilityExtensions.AddressOf(in source.bytes);
			UnsafeUtility.MemCpy(m_Data->GetUnsafePtr(), source2, source.utf8LengthInBytes);
		}

		public NativeText(in FixedString512Bytes source, Allocator allocator)
			: this(in source, (AllocatorManager.AllocatorHandle)allocator)
		{
		}

		public unsafe NativeText(in FixedString4096Bytes source, AllocatorManager.AllocatorHandle allocator)
			: this(source.utf8LengthInBytes, allocator)
		{
			Length = source.utf8LengthInBytes;
			byte* source2 = (byte*)UnsafeUtilityExtensions.AddressOf(in source.bytes);
			UnsafeUtility.MemCpy(m_Data->GetUnsafePtr(), source2, source.utf8LengthInBytes);
		}

		public NativeText(in FixedString4096Bytes source, Allocator allocator)
			: this(in source, (AllocatorManager.AllocatorHandle)allocator)
		{
		}

		public bool TryResize(int newLength, NativeArrayOptions clearOptions = NativeArrayOptions.ClearMemory)
		{
			Length = newLength;
			return true;
		}

		public unsafe byte* GetUnsafePtr()
		{
			return m_Data->GetUnsafePtr();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe ref byte ElementAt(int index)
		{
			return ref m_Data->ElementAt(index);
		}

		public void Clear()
		{
			Length = 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Add(in byte value)
		{
			this[Length++] = value;
		}

		public unsafe int CompareTo(NativeText other)
		{
			return FixedStringMethods.CompareTo(ref this, in *other.m_Data);
		}

		public unsafe bool Equals(NativeText other)
		{
			return FixedStringMethods.Equals(ref this, in *other.m_Data);
		}

		public int CompareTo(ReadOnly other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public unsafe bool Equals(ReadOnly other)
		{
			return FixedStringMethods.Equals(ref this, in *other.m_Data);
		}

		public unsafe void Dispose()
		{
			if (IsCreated)
			{
				UnsafeText.Free(m_Data);
				m_Data = null;
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new NativeTextDisposeJob
			{
				Data = new NativeTextDispose
				{
					m_TextData = m_Data
				}
			}.Schedule(inputDeps);
			m_Data = null;
			return result;
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public int CompareTo(string other)
		{
			return ToString().CompareTo(other);
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public bool Equals(string other)
		{
			return ToString().Equals(other);
		}

		public int CompareTo(FixedString32Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public unsafe static bool operator ==(in NativeText a, in FixedString32Bytes b)
		{
			NativeText nativeText = UnsafeUtilityExtensions.AsRef(in a);
			int length = nativeText.Length;
			int utf8LengthInBytes = b.utf8LengthInBytes;
			byte* unsafePtr = nativeText.GetUnsafePtr();
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(unsafePtr, length, bBytes, utf8LengthInBytes);
		}

		public static bool operator !=(in NativeText a, in FixedString32Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString32Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString64Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public unsafe static bool operator ==(in NativeText a, in FixedString64Bytes b)
		{
			NativeText nativeText = UnsafeUtilityExtensions.AsRef(in a);
			int length = nativeText.Length;
			int utf8LengthInBytes = b.utf8LengthInBytes;
			byte* unsafePtr = nativeText.GetUnsafePtr();
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(unsafePtr, length, bBytes, utf8LengthInBytes);
		}

		public static bool operator !=(in NativeText a, in FixedString64Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString64Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString128Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public unsafe static bool operator ==(in NativeText a, in FixedString128Bytes b)
		{
			NativeText nativeText = UnsafeUtilityExtensions.AsRef(in a);
			int length = nativeText.Length;
			int utf8LengthInBytes = b.utf8LengthInBytes;
			byte* unsafePtr = nativeText.GetUnsafePtr();
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(unsafePtr, length, bBytes, utf8LengthInBytes);
		}

		public static bool operator !=(in NativeText a, in FixedString128Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString128Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString512Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public unsafe static bool operator ==(in NativeText a, in FixedString512Bytes b)
		{
			NativeText nativeText = UnsafeUtilityExtensions.AsRef(in a);
			int length = nativeText.Length;
			int utf8LengthInBytes = b.utf8LengthInBytes;
			byte* unsafePtr = nativeText.GetUnsafePtr();
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(unsafePtr, length, bBytes, utf8LengthInBytes);
		}

		public static bool operator !=(in NativeText a, in FixedString512Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString512Bytes other)
		{
			return this == other;
		}

		public int CompareTo(FixedString4096Bytes other)
		{
			return FixedStringMethods.CompareTo(ref this, in other);
		}

		public unsafe static bool operator ==(in NativeText a, in FixedString4096Bytes b)
		{
			NativeText nativeText = UnsafeUtilityExtensions.AsRef(in a);
			int length = nativeText.Length;
			int utf8LengthInBytes = b.utf8LengthInBytes;
			byte* unsafePtr = nativeText.GetUnsafePtr();
			byte* bBytes = (byte*)UnsafeUtilityExtensions.AddressOf(in b.bytes);
			return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(unsafePtr, length, bBytes, utf8LengthInBytes);
		}

		public static bool operator !=(in NativeText a, in FixedString4096Bytes b)
		{
			return !(a == b);
		}

		public bool Equals(FixedString4096Bytes other)
		{
			return this == other;
		}

		[ExcludeFromBurstCompatTesting("Returns managed string")]
		public unsafe override string ToString()
		{
			if (m_Data == null)
			{
				return "";
			}
			return FixedStringMethods.ConvertToString(ref this);
		}

		public override int GetHashCode()
		{
			return FixedStringMethods.ComputeHashCode(ref this);
		}

		[ExcludeFromBurstCompatTesting("Takes managed object")]
		public override bool Equals(object other)
		{
			if (other == null)
			{
				return false;
			}
			if (other is string other2)
			{
				return Equals(other2);
			}
			if (other is NativeText other3)
			{
				return Equals(other3);
			}
			if (other is ReadOnly other4)
			{
				return Equals(other4);
			}
			if (other is FixedString32Bytes other5)
			{
				return Equals(other5);
			}
			if (other is FixedString64Bytes other6)
			{
				return Equals(other6);
			}
			if (other is FixedString128Bytes other7)
			{
				return Equals(other7);
			}
			if (other is FixedString512Bytes other8)
			{
				return Equals(other8);
			}
			if (other is FixedString4096Bytes other9)
			{
				return Equals(other9);
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		internal unsafe static void CheckNull(void* dataPtr)
		{
			if (dataPtr == null)
			{
				throw new InvalidOperationException("NativeText has yet to be created or has been destroyed!");
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private readonly void CheckRead()
		{
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private void CheckWrite()
		{
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private readonly void CheckWriteAndBumpSecondaryVersion()
		{
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckIndexInRange(int index)
		{
			if (index < 0)
			{
				throw new IndexOutOfRangeException($"Index {index} must be positive.");
			}
			if (index >= Length)
			{
				throw new IndexOutOfRangeException($"Index {index} is out of range in NativeText of {Length} length.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void ThrowCopyError(CopyError error, string source)
		{
			throw new ArgumentException($"NativeText: {error} while copying \"{source}\"");
		}

		public unsafe ReadOnly AsReadOnly()
		{
			return new ReadOnly(m_Data);
		}
	}
	[NativeContainer]
	[GenerateTestsForBurstCompatibility]
	internal struct NativeTextDispose
	{
		[NativeDisableUnsafePtrRestriction]
		public unsafe UnsafeText* m_TextData;

		public unsafe void Dispose()
		{
			UnsafeText.Free(m_TextData);
		}
	}
	[BurstCompile]
	internal struct NativeTextDisposeJob : IJob
	{
		public NativeTextDispose Data;

		public void Execute()
		{
			Data.Dispose();
		}
	}
	internal struct UnmanagedArray<T> : IDisposable where T : unmanaged
	{
		private IntPtr m_pointer;

		private int m_length;

		private AllocatorManager.AllocatorHandle m_allocator;

		public int Length => m_length;

		public unsafe ref T this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return ref *(T*)((byte*)(void*)m_pointer + (nint)index * (nint)sizeof(T));
			}
		}

		public unsafe UnmanagedArray(int length, AllocatorManager.AllocatorHandle allocator)
		{
			m_pointer = (IntPtr)Memory.Unmanaged.Array.Allocate<T>(length, allocator);
			m_length = length;
			m_allocator = allocator;
		}

		public unsafe void Dispose()
		{
			Memory.Unmanaged.Free((T*)(void*)m_pointer, Allocator.Persistent);
		}

		public unsafe T* GetUnsafePointer()
		{
			return (T*)(void*)m_pointer;
		}
	}
	[BurstCompile]
	public struct RewindableAllocator : AllocatorManager.IAllocator, IDisposable
	{
		internal struct Union
		{
			internal long m_long;

			private const int currentBits = 40;

			private const int currentOffset = 0;

			private const long currentMask = 1099511627775L;

			private const int allocCountBits = 24;

			private const int allocCountOffset = 40;

			private const long allocCountMask = 16777215L;

			internal long m_current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_long & 0xFFFFFFFFFFL;
				}
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				set
				{
					m_long &= -1099511627776L;
					m_long |= value & 0xFFFFFFFFFFL;
				}
			}

			internal long m_allocCount
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return (m_long >> 40) & 0xFFFFFF;
				}
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				set
				{
					m_long &= 1099511627775L;
					m_long |= (value & 0xFFFFFF) << 40;
				}
			}
		}

		[GenerateTestsForBurstCompatibility]
		internal struct MemoryBlock : IDisposable
		{
			public const int kMaximumAlignment = 16384;

			public unsafe byte* m_pointer;

			public long m_bytes;

			public Union m_union;

			public unsafe MemoryBlock(long bytes)
			{
				m_pointer = (byte*)Memory.Unmanaged.Allocate(bytes, 16384, Allocator.Persistent);
				Assert.IsTrue(m_pointer != null, "Memory block allocation failed, system out of memory");
				m_bytes = bytes;
				m_union = default(Union);
			}

			public void Rewind()
			{
				m_union = default(Union);
			}

			public unsafe void Dispose()
			{
				Memory.Unmanaged.Free(m_pointer, Allocator.Persistent);
				m_pointer = null;
				m_bytes = 0L;
				m_union = default(Union);
			}

			public unsafe bool Contains(IntPtr ptr)
			{
				void* ptr2 = (void*)ptr;
				if (ptr2 >= m_pointer)
				{
					return ptr2 < m_pointer + m_union.m_current;
				}
				return false;
			}
		}

		internal delegate int Try_000009DE$PostfixBurstDelegate(IntPtr state, ref AllocatorManager.Block block);

		internal static class Try_000009DE$BurstDirectCall
		{
			private static IntPtr Pointer;

			private static IntPtr DeferredCompilation;

			[BurstDiscard]
			private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
			{
				if (Pointer == (IntPtr)0)
				{
					Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(Try_000009DE$PostfixBurstDelegate).TypeHandle);
				}
				P_0 = Pointer;
			}

			private static IntPtr GetFunctionPointer()
			{
				nint result = 0;
				GetFunctionPointerDiscard(ref result);
				return result;
			}

			public static void Constructor()
			{
				DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
			}

			public static void Initialize()
			{
			}

			static Try_000009DE$BurstDirectCall()
			{
				Constructor();
			}

			public unsafe static int Invoke(IntPtr state, ref AllocatorManager.Block block)
			{
				if (BurstCompiler.IsEnabled)
				{
					IntPtr functionPointer = GetFunctionPointer();
					if (functionPointer != (IntPtr)0)
					{
						return ((delegate* unmanaged[Cdecl]<IntPtr, ref AllocatorManager.Block, int>)functionPointer)(state, ref block);
					}
				}
				return Try$BurstManaged(state, ref block);
			}
		}

		private const int kLog2MaxMemoryBlockSize = 26;

		private const long kMaxMemoryBlockSize = 67108864L;

		private const long kMinMemoryBlockSize = 131072L;

		private const int kMaxNumBlocks = 64;

		private const int kBlockBusyRewindMask = int.MinValue;

		private const int kBlockBusyAllocateMask = int.MaxValue;

		private Spinner m_spinner;

		private AllocatorManager.AllocatorHandle m_handle;

		private UnmanagedArray<MemoryBlock> m_block;

		private int m_last;

		private int m_used;

		private byte m_enableBlockFree;

		private byte m_reachMaxBlockSize;

		public bool EnableBlockFree
		{
			get
			{
				return m_enableBlockFree != 0;
			}
			set
			{
				m_enableBlockFree = (byte)(value ? 1 : 0);
			}
		}

		public int BlocksAllocated => m_last + 1;

		public int InitialSizeInBytes => (int)m_block[0].m_bytes;

		internal long MaxMemoryBlockSize => 67108864L;

		internal long BytesAllocated
		{
			get
			{
				long num = 0L;
				for (int i = 0; i <= m_last; i++)
				{
					num += m_block[i].m_bytes;
				}
				return num;
			}
		}

		[ExcludeFromBurstCompatTesting("Uses managed delegate")]
		public AllocatorManager.TryFunction Function => Try;

		public AllocatorManager.AllocatorHandle Handle
		{
			get
			{
				return m_handle;
			}
			set
			{
				m_handle = value;
			}
		}

		public Allocator ToAllocator => m_handle.ToAllocator;

		public bool IsCustomAllocator => m_handle.IsCustomAllocator;

		public bool IsAutoDispose => true;

		public void Initialize(int initialSizeInBytes, bool enableBlockFree = false)
		{
			m_spinner = default(Spinner);
			m_block = new UnmanagedArray<MemoryBlock>(64, Allocator.Persistent);
			long bytes = (((long)initialSizeInBytes > 131072L) ? initialSizeInBytes : 131072);
			m_block[0] = new MemoryBlock(bytes);
			m_last = (m_used = 0);
			m_enableBlockFree = (byte)(enableBlockFree ? 1 : 0);
			m_reachMaxBlockSize = (byte)(((long)initialSizeInBytes >= 67108864L) ? 1 : 0);
		}

		public void Rewind()
		{
			if (JobsUtility.IsExecutingJob)
			{
				throw new InvalidOperationException("You cannot Rewind a RewindableAllocator from a Job.");
			}
			m_handle.Rewind();
			while (m_last > m_used)
			{
				m_block[m_last--].Dispose();
			}
			while (m_used > 0)
			{
				m_block[m_used--].Rewind();
			}
			m_block[0].Rewind();
		}

		public void Dispose()
		{
			if (JobsUtility.IsExecutingJob)
			{
				throw new InvalidOperationException("You cannot Dispose a RewindableAllocator from a Job.");
			}
			m_used = 0;
			Rewind();
			m_block[0].Dispose();
			m_block.Dispose();
			m_last = (m_used = 0);
		}

		private unsafe int TryAllocate(ref AllocatorManager.Block block, int startIndex, int lastIndex, long alignedSize, long alignmentMask)
		{
			for (int i = startIndex; i <= lastIndex; i++)
			{
				Union union = default(Union);
				long num = 0L;
				bool flag = false;
				union.m_long = Interlocked.Read(ref m_block[i].m_union.m_long);
				Union union2;
				do
				{
					num = (union.m_current + alignmentMask) & ~alignmentMask;
					if (num + block.Bytes > m_block[i].m_bytes)
					{
						flag = true;
						break;
					}
					union2 = union;
					Union union3 = new Union
					{
						m_current = ((num + alignedSize > m_block[i].m_bytes) ? m_block[i].m_bytes : (num + alignedSize)),
						m_allocCount = union.m_allocCount + 1
					};
					union.m_long = Interlocked.CompareExchange(ref m_block[i].m_union.m_long, union3.m_long, union2.m_long);
				}
				while (union.m_long != union2.m_long);
				if (!flag)
				{
					block.Range.Pointer = (IntPtr)(m_block[i].m_pointer + num);
					block.AllocatedItems = block.Range.Items;
					Interlocked.MemoryBarrier();
					int num2 = m_used;
					int num3;
					int num4;
					do
					{
						num3 = num2;
						num4 = ((i > num3) ? i : num3);
						num2 = Interlocked.CompareExchange(ref m_used, num4, num3);
					}
					while (num4 != num3);
					return 0;
				}
			}
			return -1;
		}

		public int Try(ref AllocatorManager.Block block)
		{
			if (block.Range.Pointer == IntPtr.Zero)
			{
				int num = math.max(64, block.Alignment);
				int num2 = ((num != 64) ? 1 : 0);
				int num3 = 63;
				if (num2 == 1)
				{
					num = (num + num3) & ~num3;
				}
				long num4 = (long)num - 1L;
				long num5 = (block.Bytes + num2 * num + num4) & ~num4;
				int last = m_last;
				int num6 = TryAllocate(ref block, 0, m_last, num5, num4);
				if (num6 == 0)
				{
					return num6;
				}
				m_spinner.Acquire();
				num6 = TryAllocate(ref block, last, m_last, num5, num4);
				if (num6 == 0)
				{
					m_spinner.Release();
					return num6;
				}
				long x = ((m_reachMaxBlockSize != 0) ? (m_block[m_last].m_bytes + 67108864) : (m_block[m_last].m_bytes << 1));
				x = math.max(x, num5);
				m_reachMaxBlockSize = (byte)((x >= 67108864) ? 1 : 0);
				m_block[m_last + 1] = new MemoryBlock(x);
				Interlocked.Increment(ref m_last);
				num6 = TryAllocate(ref block, m_last, m_last, num5, num4);
				m_spinner.Release();
				return num6;
			}
			if (block.Range.Items == 0)
			{
				if (m_enableBlockFree != 0)
				{
					for (int i = 0; i <= m_last; i++)
					{
						if (!m_block[i].Contains(block.Range.Pointer))
						{
							continue;
						}
						Union union = new Union
						{
							m_long = Interlocked.Read(ref m_block[i].m_union.m_long)
						};
						Union union2;
						do
						{
							union2 = union;
							Union union3 = union;
							union3.m_allocCount--;
							if (union3.m_allocCount == 0L)
							{
								union3.m_current = 0L;
							}
							union.m_long = Interlocked.CompareExchange(ref m_block[i].m_union.m_long, union3.m_long, union2.m_long);
						}
						while (union.m_long != union2.m_long);
					}
				}
				return 0;
			}
			return -1;
		}

		[BurstCompile]
		[MonoPInvokeCallback(typeof(AllocatorManager.TryFunction))]
		internal static int Try(IntPtr state, ref AllocatorManager.Block block)
		{
			return Try_000009DE$BurstDirectCall.Invoke(state, ref block);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe NativeArray<T> AllocateNativeArray<T>(int length) where T : unmanaged
		{
			return new NativeArray<T>
			{
				m_Buffer = AllocatorManager.AllocateStruct(ref this, default(T), length),
				m_Length = length,
				m_AllocatorLabel = Allocator.None
			};
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe NativeList<T> AllocateNativeList<T>(int capacity) where T : unmanaged
		{
			NativeList<T> result = default(NativeList<T>);
			result.m_ListData = AllocatorManager.Allocate(ref this, default(UnsafeList<T>), 1);
			result.m_ListData->Ptr = AllocatorManager.Allocate(ref this, default(T), capacity);
			result.m_ListData->m_length = 0;
			result.m_ListData->m_capacity = capacity;
			result.m_ListData->Allocator = Allocator.None;
			return result;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[BurstCompile]
		[MonoPInvokeCallback(typeof(AllocatorManager.TryFunction))]
		internal unsafe static int Try$BurstManaged(IntPtr state, ref AllocatorManager.Block block)
		{
			return ((RewindableAllocator*)(void*)state)->Try(ref block);
		}
	}
	[GenerateTestsForBurstCompatibility]
	public struct StreamCompressionModel
	{
		private static class SharedStaticCompressionModel
		{
			internal static readonly SharedStatic<StreamCompressionModel> Default = SharedStatic<StreamCompressionModel>.GetOrCreateUnsafe(0u, 6564095697914452312L, 0L);
		}

		internal static readonly byte[] k_BucketSizes = new byte[16]
		{
			0, 0, 1, 2, 3, 4, 6, 8, 10, 12,
			15, 18, 21, 24, 27, 32
		};

		internal static readonly uint[] k_BucketOffsets = new uint[16]
		{
			0u, 1u, 2u, 4u, 8u, 16u, 32u, 96u, 352u, 1376u,
			5472u, 38240u, 300384u, 2397536u, 19174752u, 153392480u
		};

		internal static readonly int[] k_FirstBucketCandidate = new int[33]
		{
			15, 15, 15, 15, 14, 14, 14, 13, 13, 13,
			12, 12, 12, 11, 11, 11, 10, 10, 10, 9,
			9, 8, 8, 7, 7, 6, 5, 4, 3, 2,
			1, 1, 0
		};

		internal static readonly byte[] k_DefaultModelData = new byte[19]
		{
			16, 2, 3, 3, 3, 4, 4, 4, 5, 5,
			5, 6, 6, 6, 6, 6, 6, 0, 0
		};

		internal const int k_AlphabetSize = 16;

		internal const int k_MaxHuffmanSymbolLength = 6;

		internal const int k_MaxContexts = 1;

		private byte m_Initialized;

		internal unsafe fixed ushort encodeTable[16];

		internal unsafe fixed ushort decodeTable[64];

		internal unsafe fixed byte bucketSizes[16];

		internal unsafe fixed uint bucketOffsets[16];

		public static StreamCompressionModel Default
		{
			get
			{
				if (SharedStaticCompressionModel.Default.Data.m_Initialized == 1)
				{
					return SharedStaticCompressionModel.Default.Data;
				}
				Initialize();
				SharedStaticCompressionModel.Default.Data.m_Initialized = 1;
				return SharedStaticCompressionModel.Default.Data;
			}
		}

		private unsafe static void Initialize()
		{
			for (int i = 0; i < 16; i++)
			{
				SharedStaticCompressionModel.Default.Data.bucketSizes[i] = k_BucketSizes[i];
				SharedStaticCompressionModel.Default.Data.bucketOffsets[i] = k_BucketOffsets[i];
			}
			NativeArray<byte> nativeArray = new NativeArray<byte>(k_DefaultModelData.Length, Allocator.Temp);
			for (int j = 0; j < k_DefaultModelData.Length; j++)
			{
				nativeArray[j] = k_DefaultModelData[j];
			}
			int num = 1;
			NativeArray<byte> nativeArray2 = new NativeArray<byte>(num * 16, Allocator.Temp);
			int num2 = 0;
			_ = nativeArray[num2++];
			for (int k = 0; k < 16; k++)
			{
				byte value = nativeArray[num2++];
				for (int l = 0; l < num; l++)
				{
					nativeArray2[num * l + k] = value;
				}
			}
			int num3 = nativeArray[num2] | (nativeArray[num2 + 1] << 8);
			num2 += 2;
			for (int m = 0; m < num3; m++)
			{
				int num4 = nativeArray[num2] | (nativeArray[num2 + 1] << 8);
				num2 += 2;
				_ = nativeArray[num2++];
				for (int n = 0; n < 16; n++)
				{
					byte value2 = nativeArray[num2++];
					nativeArray2[num * num4 + n] = value2;
				}
			}
			NativeArray<byte> symbolLengths = new NativeArray<byte>(16, Allocator.Temp);
			NativeArray<ushort> nativeArray3 = new NativeArray<ushort>(64, Allocator.Temp);
			NativeArray<byte> symbolCodes = new NativeArray<byte>(16, Allocator.Temp);
			for (int num5 = 0; num5 < num; num5++)
			{
				for (int num6 = 0; num6 < 16; num6++)
				{
					symbolLengths[num6] = nativeArray2[num * num5 + num6];
				}
				GenerateHuffmanCodes(symbolCodes, 0, symbolLengths, 0, 16, 6);
				GenerateHuffmanDecodeTable(nativeArray3, 0, symbolLengths, symbolCodes, 16, 6);
				for (int num7 = 0; num7 < 16; num7++)
				{
					SharedStaticCompressionModel.Default.Data.encodeTable[num5 * 16 + num7] = (ushort)((symbolCodes[num7] << 8) | nativeArray2[num * num5 + num7]);
				}
				for (int num8 = 0; num8 < 64; num8++)
				{
					SharedStaticCompressionModel.Default.Data.decodeTable[num5 * 64 + num8] = nativeArray3[num8];
				}
			}
		}

		private static void GenerateHuffmanCodes(NativeArray<byte> symbolCodes, int symbolCodesOffset, NativeArray<byte> symbolLengths, int symbolLengthsOffset, int alphabetSize, int maxCodeLength)
		{
			NativeArray<byte> nativeArray = new NativeArray<byte>(maxCodeLength + 1, Allocator.Temp);
			NativeArray<byte> nativeArray2 = new NativeArray<byte>((maxCodeLength + 1) * alphabetSize, Allocator.Temp);
			for (int i = 0; i < alphabetSize; i++)
			{
				int num = symbolLengths[i + symbolLengthsOffset];
				nativeArray2[(maxCodeLength + 1) * num + nativeArray[num]++] = (byte)i;
			}
			uint num2 = 0u;
			for (int j = 1; j <= maxCodeLength; j++)
			{
				int num3 = nativeArray[j];
				for (int k = 0; k < num3; k++)
				{
					int num4 = nativeArray2[(maxCodeLength + 1) * j + k];
					symbolCodes[num4 + symbolCodesOffset] = (byte)ReverseBits(num2++, j);
				}
				num2 <<= 1;
			}
		}

		private static uint ReverseBits(uint value, int num_bits)
		{
			value = ((value & 0x55555555) << 1) | ((value & 0xAAAAAAAAu) >> 1);
			value = ((value & 0x33333333) << 2) | ((value & 0xCCCCCCCCu) >> 2);
			value = ((value & 0xF0F0F0F) << 4) | ((value & 0xF0F0F0F0u) >> 4);
			value = ((value & 0xFF00FF) << 8) | ((value & 0xFF00FF00u) >> 8);
			value = (value << 16) | (value >> 16);
			return value >> 32 - num_bits;
		}

		private static void GenerateHuffmanDecodeTable(NativeArray<ushort> decodeTable, int decodeTableOffset, NativeArray<byte> symbolLengths, NativeArray<byte> symbolCodes, int alphabetSize, int maxCodeLength)
		{
			uint num = (uint)(1 << maxCodeLength);
			for (int i = 0; i < alphabetSize; i++)
			{
				int num2 = symbolLengths[i];
				if (num2 > 0)
				{
					uint num3 = symbolCodes[i];
					uint num4 = (uint)(1 << num2);
					do
					{
						decodeTable[(int)(decodeTableOffset + num3)] = (ushort)((i << 8) | num2);
						num3 += num4;
					}
					while (num3 < num);
				}
			}
		}

		public unsafe readonly int CalculateBucket(uint value)
		{
			int num = k_FirstBucketCandidate[math.lzcnt(value)];
			if (num + 1 < 16 && value >= bucketOffsets[num + 1])
			{
				num++;
			}
			return num;
		}

		public unsafe readonly int GetCompressedSizeInBits(uint value)
		{
			int num = CalculateBucket(value);
			int num2 = bucketSizes[num];
			return (encodeTable[num] & 0xFF) + num2;
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckAlphabetSize(int alphabetSize)
		{
			if (alphabetSize != 16)
			{
				throw new InvalidOperationException("The alphabet size of compression models must be " + 16);
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckSymbolLength(NativeArray<byte> symbolLengths, int symbolLengthsOffset, int symbol, int length)
		{
			if (symbolLengths[symbol + symbolLengthsOffset] != length)
			{
				throw new InvalidOperationException("Incorrect symbol length");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckAlphabetAndMaxCodeLength(int alphabetSize, int maxCodeLength)
		{
			if (alphabetSize > 256 || maxCodeLength > 8)
			{
				throw new InvalidOperationException("Can only generate huffman codes up to alphabet size 256 and maximum code length 8");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckExceedMaxCodeLength(int length, int maxCodeLength)
		{
			if (length > maxCodeLength)
			{
				throw new InvalidOperationException("Maximum code length exceeded");
			}
		}
	}
	[StructLayout(LayoutKind.Explicit)]
	internal struct UIntFloat
	{
		[FieldOffset(0)]
		public float floatValue;

		[FieldOffset(0)]
		public uint intValue;

		[FieldOffset(0)]
		public double doubleValue;

		[FieldOffset(0)]
		public ulong longValue;
	}
	public enum FormatError
	{
		None,
		Overflow,
		BadFormatSpecifier
	}
	public enum ParseError
	{
		None,
		Syntax,
		Overflow,
		Underflow
	}
	public enum CopyError
	{
		None,
		Truncation
	}
	public enum ConversionError
	{
		None,
		Overflow,
		Encoding,
		CodePoint
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	[GenerateTestsForBurstCompatibility]
	public struct Unicode
	{
		[GenerateTestsForBurstCompatibility]
		public struct Rune
		{
			public int value;

			public Rune(int codepoint)
			{
				value = codepoint;
			}

			public static implicit operator Rune(char codepoint)
			{
				return new Rune
				{
					value = codepoint
				};
			}

			public static bool operator ==(Rune lhs, Rune rhs)
			{
				return lhs.value == rhs.value;
			}

			[ExcludeFromBurstCompatTesting("Takes managed object")]
			public override bool Equals(object obj)
			{
				if (obj is Rune)
				{
					return value == ((Rune)obj).value;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return value;
			}

			public static bool operator !=(Rune lhs, Rune rhs)
			{
				return lhs.value != rhs.value;
			}

			public static bool IsDigit(Rune r)
			{
				return r.IsDigit();
			}

			internal bool IsAscii()
			{
				return value < 128;
			}

			internal bool IsLatin1()
			{
				return value < 256;
			}

			internal bool IsDigit()
			{
				if (value >= 48)
				{
					return value <= 57;
				}
				return false;
			}

			internal bool IsWhiteSpace()
			{
				if (IsLatin1())
				{
					if (value != 32 && (value < 9 || value > 13) && value != 160)
					{
						return value == 133;
					}
					return true;
				}
				if (value != 5760 && (value < 8192 || value > 8202) && value != 8232 && value != 8233 && value != 8239 && value != 8287)
				{
					return value == 12288;
				}
				return true;
			}

			internal Rune ToLowerAscii()
			{
				return new Rune(value + (((uint)(value - 65) <= 25u) ? 32 : 0));
			}

			internal Rune ToUpperAscii()
			{
				return new Rune(value - (((uint)(value - 97) <= 25u) ? 32 : 0));
			}

			public int LengthInUtf8Bytes()
			{
				if (value < 0)
				{
					return 4;
				}
				if (value <= 127)
				{
					return 1;
				}
				if (value <= 2047)
				{
					return 2;
				}
				if (value <= 65535)
				{
					return 3;
				}
				_ = value;
				_ = 2097151;
				return 4;
			}
		}

		public const int kMaximumValidCodePoint = 1114111;

		public static Rune ReplacementCharacter => new Rune
		{
			value = 65533
		};

		public static Rune BadRune => new Rune
		{
			value = 0
		};

		public static bool IsValidCodePoint(int codepoint)
		{
			if (codepoint > 1114111)
			{
				return false;
			}
			if (codepoint < 0)
			{
				return false;
			}
			return true;
		}

		public static bool NotTrailer(byte b)
		{
			return (b & 0xC0) != 128;
		}

		public unsafe static ConversionError Utf8ToUcs(out Rune rune, byte* buffer, ref int index, int capacity)
		{
			int num = 0;
			rune = ReplacementCharacter;
			if (index + 1 > capacity)
			{
				return ConversionError.Overflow;
			}
			if ((buffer[index] & 0x80) == 0)
			{
				rune.value = buffer[index];
				index++;
				return ConversionError.None;
			}
			if ((buffer[index] & 0xE0) == 192)
			{
				if (index + 2 > capacity)
				{
					index++;
					return ConversionError.Overflow;
				}
				num = buffer[index] & 0x1F;
				num = (num << 6) | (buffer[index + 1] & 0x3F);
				if (num < 128 || NotTrailer(buffer[index + 1]))
				{
					index++;
					return ConversionError.Encoding;
				}
				rune.value = num;
				index += 2;
				return ConversionError.None;
			}
			if ((buffer[index] & 0xF0) == 224)
			{
				if (index + 3 > capacity)
				{
					index++;
					return ConversionError.Overflow;
				}
				num = buffer[index] & 0xF;
				num = (num << 6) | (buffer[index + 1] & 0x3F);
				num = (num << 6) | (buffer[index + 2] & 0x3F);
				if (num < 2048 || !IsValidCodePoint(num) || NotTrailer(buffer[index + 1]) || NotTrailer(buffer[index + 2]))
				{
					index++;
					return ConversionError.Encoding;
				}
				rune.value = num;
				index += 3;
				return ConversionError.None;
			}
			if ((buffer[index] & 0xF8) == 240)
			{
				if (index + 4 > capacity)
				{
					index++;
					return ConversionError.Overflow;
				}
				num = buffer[index] & 7;
				num = (num << 6) | (buffer[index + 1] & 0x3F);
				num = (num << 6) | (buffer[index + 2] & 0x3F);
				num = (num << 6) | (buffer[index + 3] & 0x3F);
				if (num < 65536 || !IsValidCodePoint(num) || NotTrailer(buffer[index + 1]) || NotTrailer(buffer[index + 2]) || NotTrailer(buffer[index + 3]))
				{
					index++;
					return ConversionError.Encoding;
				}
				rune.value = num;
				index += 4;
				return ConversionError.None;
			}
			index++;
			return ConversionError.Encoding;
		}

		private unsafe static int FindUtf8CharStartInReverse(byte* ptr, ref int index)
		{
			do
			{
				if (index <= 0)
				{
					return 0;
				}
				index--;
			}
			while ((ptr[index] & 0xC0) == 128);
			return index;
		}

		internal unsafe static ConversionError Utf8ToUcsReverse(out Rune rune, byte* buffer, ref int index, int capacity)
		{
			int num = index;
			index--;
			index = FindUtf8CharStartInReverse(buffer, ref index);
			if (index == num)
			{
				rune = ReplacementCharacter;
				return ConversionError.Overflow;
			}
			int index2 = index;
			return Utf8ToUcs(out rune, buffer, ref index2, capacity);
		}

		private static bool IsLeadingSurrogate(char c)
		{
			if (c >= '\ud800')
			{
				return c <= '\udbff';
			}
			return false;
		}

		private static bool IsTrailingSurrogate(char c)
		{
			if (c >= '\udc00')
			{
				return c <= '\udfff';
			}
			return false;
		}

		public unsafe static ConversionError Utf16ToUcs(out Rune rune, char* buffer, ref int index, int capacity)
		{
			int num = 0;
			rune = ReplacementCharacter;
			if (index + 1 > capacity)
			{
				return ConversionError.Overflow;
			}
			if (!IsLeadingSurrogate(buffer[index]) || index + 2 > capacity)
			{
				rune.value = buffer[index];
				index++;
				return ConversionError.None;
			}
			num = buffer[index] & 0x3FF;
			if (!IsTrailingSurrogate(buffer[index + 1]))
			{
				rune.value = buffer[index];
				index++;
				return ConversionError.None;
			}
			num = (num << 10) | (buffer[index + 1] & 0x3FF);
			num += 65536;
			rune.value = num;
			index += 2;
			return ConversionError.None;
		}

		internal unsafe static ConversionError UcsToUcs(out Rune rune, Rune* buffer, ref int index, int capacity)
		{
			rune = ReplacementCharacter;
			if (index + 1 > capacity)
			{
				return ConversionError.Overflow;
			}
			rune = buffer[index];
			index++;
			return ConversionError.None;
		}

		public unsafe static ConversionError UcsToUtf8(byte* buffer, ref int index, int capacity, Rune rune)
		{
			if (!IsValidCodePoint(rune.value))
			{
				return ConversionError.CodePoint;
			}
			if (index + 1 > capacity)
			{
				return ConversionError.Overflow;
			}
			if (rune.value <= 127)
			{
				buffer[index++] = (byte)rune.value;
				return ConversionError.None;
			}
			if (rune.value <= 2047)
			{
				if (index + 2 > capacity)
				{
					return ConversionError.Overflow;
				}
				buffer[index++] = (byte)(0xC0 | (rune.value >> 6));
				buffer[index++] = (byte)(0x80 | (rune.value & 0x3F));
				return ConversionError.None;
			}
			if (rune.value <= 65535)
			{
				if (index + 3 > capacity)
				{
					return ConversionError.Overflow;
				}
				buffer[index++] = (byte)(0xE0 | (rune.value >> 12));
				buffer[index++] = (byte)(0x80 | ((rune.value >> 6) & 0x3F));
				buffer[index++] = (byte)(0x80 | (rune.value & 0x3F));
				return ConversionError.None;
			}
			if (rune.value <= 2097151)
			{
				if (index + 4 > capacity)
				{
					return ConversionError.Overflow;
				}
				buffer[index++] = (byte)(0xF0 | (rune.value >> 18));
				buffer[index++] = (byte)(0x80 | ((rune.value >> 12) & 0x3F));
				buffer[index++] = (byte)(0x80 | ((rune.value >> 6) & 0x3F));
				buffer[index++] = (byte)(0x80 | (rune.value & 0x3F));
				return ConversionError.None;
			}
			return ConversionError.Encoding;
		}

		public unsafe static ConversionError UcsToUtf16(char* buffer, ref int index, int capacity, Rune rune)
		{
			if (!IsValidCodePoint(rune.value))
			{
				return ConversionError.CodePoint;
			}
			if (index + 1 > capacity)
			{
				return ConversionError.Overflow;
			}
			if (rune.value >= 65536)
			{
				if (index + 2 > capacity)
				{
					return ConversionError.Overflow;
				}
				int num = rune.value - 65536;
				if (num >= 1048576)
				{
					return ConversionError.Encoding;
				}
				buffer[index++] = (char)(0xD800 | (num >> 10));
				buffer[index++] = (char)(0xDC00 | (num & 0x3FF));
				return ConversionError.None;
			}
			buffer[index++] = (char)rune.value;
			return ConversionError.None;
		}

		public unsafe static ConversionError Utf16ToUtf8(char* utf16Buffer, int utf16Length, byte* utf8Buffer, out int utf8Length, int utf8Capacity)
		{
			utf8Length = 0;
			int index = 0;
			while (index < utf16Length)
			{
				Utf16ToUcs(out var rune, utf16Buffer, ref index, utf16Length);
				if (UcsToUtf8(utf8Buffer, ref utf8Length, utf8Capacity, rune) == ConversionError.Overflow)
				{
					return ConversionError.Overflow;
				}
			}
			return ConversionError.None;
		}

		public unsafe static ConversionError Utf8ToUtf8(byte* srcBuffer, int srcLength, byte* destBuffer, out int destLength, int destCapacity)
		{
			if (destCapacity >= srcLength)
			{
				UnsafeUtility.MemCpy(destBuffer, srcBuffer, srcLength);
				destLength = srcLength;
				return ConversionError.None;
			}
			destLength = 0;
			int index = 0;
			while (index < srcLength)
			{
				Utf8ToUcs(out var rune, srcBuffer, ref index, srcLength);
				if (UcsToUtf8(destBuffer, ref destLength, destCapacity, rune) == ConversionError.Overflow)
				{
					return ConversionError.Overflow;
				}
			}
			return ConversionError.None;
		}

		public unsafe static ConversionError Utf8ToUtf16(byte* utf8Buffer, int utf8Length, char* utf16Buffer, out int utf16Length, int utf16Capacity)
		{
			utf16Length = 0;
			int index = 0;
			while (index < utf8Length)
			{
				Utf8ToUcs(out var rune, utf8Buffer, ref index, utf8Length);
				if (UcsToUtf16(utf16Buffer, ref utf16Length, utf16Capacity, rune) == ConversionError.Overflow)
				{
					return ConversionError.Overflow;
				}
			}
			return ConversionError.None;
		}

		private unsafe static int CountRunes(byte* utf8Buffer, int utf8Length, int maxRunes = int.MaxValue)
		{
			int num = 0;
			int num2 = 0;
			while (num < maxRunes && num2 < utf8Length)
			{
				if ((utf8Buffer[num2] & 0xC0) != 128)
				{
					num++;
				}
				num2++;
			}
			return num;
		}
	}
	internal struct UnsafeQueueBlockHeader
	{
		public unsafe UnsafeQueueBlockHeader* m_NextBlock;

		public int m_NumItems;
	}
	[GenerateTestsForBurstCompatibility]
	internal struct UnsafeQueueBlockPoolData
	{
		internal IntPtr m_FirstBlock;

		internal int m_NumBlocks;

		internal int m_MaxBlocks;

		internal const int m_BlockSize = 16384;

		internal int m_AllocLock;

		public unsafe UnsafeQueueBlockHeader* AllocateBlock()
		{
			while (Interlocked.CompareExchange(ref m_AllocLock, 1, 0) != 0)
			{
			}
			UnsafeQueueBlockHeader* ptr = (UnsafeQueueBlockHeader*)(void*)m_FirstBlock;
			UnsafeQueueBlockHeader* ptr2;
			do
			{
				ptr2 = ptr;
				if (ptr2 == null)
				{
					Interlocked.Exchange(ref m_AllocLock, 0);
					Interlocked.Increment(ref m_NumBlocks);
					return (UnsafeQueueBlockHeader*)Memory.Unmanaged.Allocate(16384L, 16, Allocator.Persistent);
				}
				ptr = (UnsafeQueueBlockHeader*)(void*)Interlocked.CompareExchange(ref m_FirstBlock, (IntPtr)ptr2->m_NextBlock, (IntPtr)ptr2);
			}
			while (ptr != ptr2);
			Interlocked.Exchange(ref m_AllocLock, 0);
			return ptr2;
		}

		public unsafe void FreeBlock(UnsafeQueueBlockHeader* block)
		{
			if (m_NumBlocks > m_MaxBlocks)
			{
				if (Interlocked.Decrement(ref m_NumBlocks) + 1 > m_MaxBlocks)
				{
					Memory.Unmanaged.Free(block, Allocator.Persistent);
					return;
				}
				Interlocked.Increment(ref m_NumBlocks);
			}
			UnsafeQueueBlockHeader* ptr = (UnsafeQueueBlockHeader*)(void*)m_FirstBlock;
			UnsafeQueueBlockHeader* ptr2;
			do
			{
				ptr2 = ptr;
				block->m_NextBlock = ptr;
				ptr = (UnsafeQueueBlockHeader*)(void*)Interlocked.CompareExchange(ref m_FirstBlock, (IntPtr)block, (IntPtr)ptr);
			}
			while (ptr != ptr2);
		}
	}
	internal class UnsafeQueueBlockPool
	{
		private static readonly SharedStatic<IntPtr> Data = SharedStatic<IntPtr>.GetOrCreateUnsafe(0u, 8615650021869908731L, 0L);

		internal unsafe static UnsafeQueueBlockPoolData* GetQueueBlockPool()
		{
			UnsafeQueueBlockPoolData** unsafeDataPointer = (UnsafeQueueBlockPoolData**)Data.UnsafeDataPointer;
			UnsafeQueueBlockPoolData* ptr = *unsafeDataPointer;
			if (ptr == null)
			{
				ptr = (*unsafeDataPointer = (UnsafeQueueBlockPoolData*)Memory.Unmanaged.Allocate(UnsafeUtility.SizeOf<UnsafeQueueBlockPoolData>(), 8, Allocator.Persistent));
				ptr->m_NumBlocks = (ptr->m_MaxBlocks = 256);
				ptr->m_AllocLock = 0;
				UnsafeQueueBlockHeader* ptr2 = null;
				for (int i = 0; i < ptr->m_MaxBlocks; i++)
				{
					UnsafeQueueBlockHeader* ptr3 = (UnsafeQueueBlockHeader*)Memory.Unmanaged.Allocate(16384L, 16, Allocator.Persistent);
					ptr3->m_NextBlock = ptr2;
					ptr2 = ptr3;
				}
				ptr->m_FirstBlock = (IntPtr)ptr2;
				AppDomainOnDomainUnload();
			}
			return ptr;
		}

		[BurstDiscard]
		private static void AppDomainOnDomainUnload()
		{
			AppDomain.CurrentDomain.DomainUnload += OnDomainUnload;
		}

		private unsafe static void OnDomainUnload(object sender, EventArgs e)
		{
			UnsafeQueueBlockPoolData** unsafeDataPointer = (UnsafeQueueBlockPoolData**)Data.UnsafeDataPointer;
			UnsafeQueueBlockPoolData* ptr = *unsafeDataPointer;
			while (ptr->m_FirstBlock != IntPtr.Zero)
			{
				UnsafeQueueBlockHeader* ptr2 = (UnsafeQueueBlockHeader*)(void*)ptr->m_FirstBlock;
				ptr->m_FirstBlock = (IntPtr)ptr2->m_NextBlock;
				Memory.Unmanaged.Free(ptr2, Allocator.Persistent);
				ptr->m_NumBlocks--;
			}
			Memory.Unmanaged.Free(ptr, Allocator.Persistent);
			*unsafeDataPointer = null;
		}
	}
	[GenerateTestsForBurstCompatibility]
	internal struct UnsafeQueueData
	{
		public IntPtr m_FirstBlock;

		public IntPtr m_LastBlock;

		public int m_MaxItems;

		public int m_CurrentRead;

		public unsafe byte* m_CurrentWriteBlockTLS;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal unsafe UnsafeQueueBlockHeader* GetCurrentWriteBlockTLS(int threadIndex)
		{
			UnsafeQueueBlockHeader** ptr = (UnsafeQueueBlockHeader**)(m_CurrentWriteBlockTLS + threadIndex * 64);
			return *ptr;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal unsafe void SetCurrentWriteBlockTLS(int threadIndex, UnsafeQueueBlockHeader* currentWriteBlock)
		{
			UnsafeQueueBlockHeader** ptr = (UnsafeQueueBlockHeader**)(m_CurrentWriteBlockTLS + threadIndex * 64);
			*ptr = currentWriteBlock;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static UnsafeQueueBlockHeader* AllocateWriteBlockMT<T>(UnsafeQueueData* data, UnsafeQueueBlockPoolData* pool, int threadIndex) where T : unmanaged
		{
			UnsafeQueueBlockHeader* currentWriteBlockTLS = data->GetCurrentWriteBlockTLS(threadIndex);
			if (currentWriteBlockTLS != null)
			{
				if (currentWriteBlockTLS->m_NumItems != data->m_MaxItems)
				{
					return currentWriteBlockTLS;
				}
				currentWriteBlockTLS = null;
			}
			currentWriteBlockTLS = pool->AllocateBlock();
			currentWriteBlockTLS->m_NextBlock = null;
			currentWriteBlockTLS->m_NumItems = 0;
			UnsafeQueueBlockHeader* ptr = (UnsafeQueueBlockHeader*)(void*)Interlocked.Exchange(ref data->m_LastBlock, (IntPtr)currentWriteBlockTLS);
			if (ptr == null)
			{
				data->m_FirstBlock = (IntPtr)currentWriteBlockTLS;
			}
			else
			{
				ptr->m_NextBlock = currentWriteBlockTLS;
			}
			data->SetCurrentWriteBlockTLS(threadIndex, currentWriteBlockTLS);
			return currentWriteBlockTLS;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static void AllocateQueue<T>(AllocatorManager.AllocatorHandle label, out UnsafeQueueData* outBuf) where T : unmanaged
		{
			int threadIndexCount = JobsUtility.ThreadIndexCount;
			int num = CollectionHelper.Align(UnsafeUtility.SizeOf<UnsafeQueueData>(), 64);
			UnsafeQueueData* ptr = (UnsafeQueueData*)Memory.Unmanaged.Allocate(num + 64 * threadIndexCount, 64, label);
			ptr->m_CurrentWriteBlockTLS = (byte*)ptr + num;
			ptr->m_FirstBlock = IntPtr.Zero;
			ptr->m_LastBlock = IntPtr.Zero;
			ptr->m_MaxItems = (16384 - UnsafeUtility.SizeOf<UnsafeQueueBlockHeader>()) / UnsafeUtility.SizeOf<T>();
			ptr->m_CurrentRead = 0;
			for (int i = 0; i < threadIndexCount; i++)
			{
				ptr->SetCurrentWriteBlockTLS(i, null);
			}
			outBuf = ptr;
		}

		public unsafe static void DeallocateQueue(UnsafeQueueData* data, UnsafeQueueBlockPoolData* pool, AllocatorManager.AllocatorHandle allocation)
		{
			UnsafeQueueBlockHeader* ptr = (UnsafeQueueBlockHeader*)(void*)data->m_FirstBlock;
			while (ptr != null)
			{
				UnsafeQueueBlockHeader* nextBlock = ptr->m_NextBlock;
				pool->FreeBlock(ptr);
				ptr = nextBlock;
			}
			Memory.Unmanaged.Free(data, allocation);
		}
	}
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct UnsafeQueue<T> : INativeDisposable, IDisposable where T : unmanaged
	{
		public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
		{
			[NativeDisableUnsafePtrRestriction]
			internal unsafe UnsafeQueueBlockHeader* m_FirstBlock;

			[NativeDisableUnsafePtrRestriction]
			internal unsafe UnsafeQueueBlockHeader* m_Block;

			internal int m_Index;

			private T value;

			public T Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return value;
				}
			}

			object IEnumerator.Current => Current;

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public unsafe bool MoveNext()
			{
				m_Index++;
				while (m_Block != null)
				{
					int numItems = m_Block->m_NumItems;
					if (m_Index < numItems)
					{
						value = UnsafeUtility.ReadArrayElement<T>(m_Block + 1, m_Index);
						return true;
					}
					m_Index -= numItems;
					m_Block = m_Block->m_NextBlock;
				}
				value = default(T);
				return false;
			}

			public unsafe void Reset()
			{
				m_Block = m_FirstBlock;
				m_Index = -1;
			}
		}

		public struct ReadOnly : IEnumerable<T>, IEnumerable
		{
			[NativeDisableUnsafePtrRestriction]
			private unsafe UnsafeQueueData* m_Buffer;

			public unsafe readonly bool IsCreated
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Buffer != null;
				}
			}

			public unsafe readonly int Count
			{
				get
				{
					int num = 0;
					for (UnsafeQueueBlockHeader* ptr = (UnsafeQueueBlockHeader*)(void*)m_Buffer->m_FirstBlock; ptr != null; ptr = ptr->m_NextBlock)
					{
						num += ptr->m_NumItems;
					}
					return num - m_Buffer->m_CurrentRead;
				}
			}

			public readonly T this[int index]
			{
				get
				{
					TryGetValue(index, out var item);
					return item;
				}
			}

			internal unsafe ReadOnly(ref UnsafeQueue<T> data)
			{
				m_Buffer = data.m_Buffer;
			}

			public unsafe readonly bool IsEmpty()
			{
				int num = 0;
				int currentRead = m_Buffer->m_CurrentRead;
				for (UnsafeQueueBlockHeader* ptr = (UnsafeQueueBlockHeader*)(void*)m_Buffer->m_FirstBlock; ptr != null; ptr = ptr->m_NextBlock)
				{
					num += ptr->m_NumItems;
					if (num > currentRead)
					{
						return false;
					}
				}
				return num == currentRead;
			}

			private unsafe readonly bool TryGetValue(int index, out T item)
			{
				if (index >= 0)
				{
					int num = index;
					for (UnsafeQueueBlockHeader* ptr = (UnsafeQueueBlockHeader*)(void*)m_Buffer->m_FirstBlock; ptr != null; ptr = ptr->m_NextBlock)
					{
						int numItems = ptr->m_NumItems;
						if (num < numItems)
						{
							item = UnsafeUtility.ReadArrayElement<T>(ptr + 1, num);
							return true;
						}
						num -= numItems;
					}
				}
				item = default(T);
				return false;
			}

			public unsafe readonly Enumerator GetEnumerator()
			{
				return new Enumerator
				{
					m_FirstBlock = (UnsafeQueueBlockHeader*)(void*)m_Buffer->m_FirstBlock,
					m_Block = (UnsafeQueueBlockHeader*)(void*)m_Buffer->m_FirstBlock,
					m_Index = -1
				};
			}

			IEnumerator<T> IEnumerable<T>.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private readonly void ThrowIndexOutOfRangeException(int index)
			{
				throw new IndexOutOfRangeException($"Index {index} is out of bounds [0-{Count}].");
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ParallelWriter
		{
			[NativeDisableUnsafePtrRestriction]
			internal unsafe UnsafeQueueData* m_Buffer;

			[NativeDisableUnsafePtrRestriction]
			internal unsafe UnsafeQueueBlockPoolData* m_QueuePool;

			[NativeSetThreadIndex]
			internal int m_ThreadIndex;

			public unsafe void Enqueue(T value)
			{
				UnsafeQueueBlockHeader* ptr = UnsafeQueueData.AllocateWriteBlockMT<T>(m_Buffer, m_QueuePool, m_ThreadIndex);
				UnsafeUtility.WriteArrayElement(ptr + 1, ptr->m_NumItems, value);
				ptr->m_NumItems++;
			}

			internal unsafe void Enqueue(T value, int threadIndexOverride)
			{
				UnsafeQueueBlockHeader* ptr = UnsafeQueueData.AllocateWriteBlockMT<T>(m_Buffer, m_QueuePool, threadIndexOverride);
				UnsafeUtility.WriteArrayElement(ptr + 1, ptr->m_NumItems, value);
				ptr->m_NumItems++;
			}
		}

		[NativeDisableUnsafePtrRestriction]
		internal unsafe UnsafeQueueData* m_Buffer;

		[NativeDisableUnsafePtrRestriction]
		internal unsafe UnsafeQueueBlockPoolData* m_QueuePool;

		internal AllocatorManager.AllocatorHandle m_AllocatorLabel;

		public unsafe readonly int Count
		{
			get
			{
				int num = 0;
				for (UnsafeQueueBlockHeader* ptr = (UnsafeQueueBlockHeader*)(void*)m_Buffer->m_FirstBlock; ptr != null; ptr = ptr->m_NextBlock)
				{
					num += ptr->m_NumItems;
				}
				return num - m_Buffer->m_CurrentRead;
			}
		}

		internal unsafe static int PersistentMemoryBlockCount
		{
			get
			{
				return UnsafeQueueBlockPool.GetQueueBlockPool()->m_MaxBlocks;
			}
			set
			{
				Interlocked.Exchange(ref UnsafeQueueBlockPool.GetQueueBlockPool()->m_MaxBlocks, value);
			}
		}

		internal static int MemoryBlockSize => 16384;

		public unsafe readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Buffer != null;
			}
		}

		public unsafe UnsafeQueue(AllocatorManager.AllocatorHandle allocator)
		{
			m_QueuePool = UnsafeQueueBlockPool.GetQueueBlockPool();
			m_AllocatorLabel = allocator;
			UnsafeQueueData.AllocateQueue<T>(allocator, out m_Buffer);
		}

		internal unsafe static UnsafeQueue<T>* Alloc(AllocatorManager.AllocatorHandle allocator)
		{
			return (UnsafeQueue<T>*)Memory.Unmanaged.Allocate(sizeof(UnsafeQueue<T>), UnsafeUtility.AlignOf<UnsafeQueue<T>>(), allocator);
		}

		internal unsafe static void Free(UnsafeQueue<T>* data)
		{
			if (data == null)
			{
				throw new InvalidOperationException("UnsafeQueue has yet to be created or has been destroyed!");
			}
			AllocatorManager.AllocatorHandle allocatorLabel = data->m_AllocatorLabel;
			data->Dispose();
			Memory.Unmanaged.Free(data, allocatorLabel);
		}

		public unsafe readonly bool IsEmpty()
		{
			if (IsCreated)
			{
				int num = 0;
				int currentRead = m_Buffer->m_CurrentRead;
				for (UnsafeQueueBlockHeader* ptr = (UnsafeQueueBlockHeader*)(void*)m_Buffer->m_FirstBlock; ptr != null; ptr = ptr->m_NextBlock)
				{
					num += ptr->m_NumItems;
					if (num > currentRead)
					{
						return false;
					}
				}
				return num == currentRead;
			}
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe T Peek()
		{
			UnsafeQueueBlockHeader* ptr = (UnsafeQueueBlockHeader*)(void*)m_Buffer->m_FirstBlock;
			return UnsafeUtility.ReadArrayElement<T>(ptr + 1, m_Buffer->m_CurrentRead);
		}

		public unsafe void Enqueue(T value)
		{
			UnsafeQueueBlockHeader* ptr = UnsafeQueueData.AllocateWriteBlockMT<T>(m_Buffer, m_QueuePool, 0);
			UnsafeUtility.WriteArrayElement(ptr + 1, ptr->m_NumItems, value);
			ptr->m_NumItems++;
		}

		public T Dequeue()
		{
			TryDequeue(out var item);
			return item;
		}

		public unsafe bool TryDequeue(out T item)
		{
			UnsafeQueueBlockHeader* ptr = (UnsafeQueueBlockHeader*)(void*)m_Buffer->m_FirstBlock;
			if (ptr != null)
			{
				int num = m_Buffer->m_CurrentRead++;
				int numItems = ptr->m_NumItems;
				item = UnsafeUtility.ReadArrayElement<T>(ptr + 1, num);
				if (num + 1 >= numItems)
				{
					m_Buffer->m_CurrentRead = 0;
					m_Buffer->m_FirstBlock = (IntPtr)ptr->m_NextBlock;
					if (m_Buffer->m_FirstBlock == IntPtr.Zero)
					{
						m_Buffer->m_LastBlock = IntPtr.Zero;
					}
					int threadIndexCount = JobsUtility.ThreadIndexCount;
					for (int i = 0; i < threadIndexCount; i++)
					{
						if (m_Buffer->GetCurrentWriteBlockTLS(i) == ptr)
						{
							m_Buffer->SetCurrentWriteBlockTLS(i, null);
						}
					}
					m_QueuePool->FreeBlock(ptr);
				}
				return true;
			}
			item = default(T);
			return false;
		}

		public unsafe NativeArray<T> ToArray(AllocatorManager.AllocatorHandle allocator)
		{
			UnsafeQueueBlockHeader* ptr = (UnsafeQueueBlockHeader*)(void*)m_Buffer->m_FirstBlock;
			NativeArray<T> nativeArray = CollectionHelper.CreateNativeArray<T>(Count, allocator, NativeArrayOptions.UninitializedMemory);
			UnsafeQueueBlockHeader* ptr2 = ptr;
			byte* unsafePtr = (byte*)nativeArray.GetUnsafePtr();
			int num = UnsafeUtility.SizeOf<T>();
			int num2 = 0;
			int num3 = m_Buffer->m_CurrentRead * num;
			int num4 = m_Buffer->m_CurrentRead;
			while (ptr2 != null)
			{
				int num5 = (ptr2->m_NumItems - num4) * num;
				UnsafeUtility.MemCpy(unsafePtr + num2, (byte*)(ptr2 + 1) + num3, num5);
				num3 = (num4 = 0);
				num2 += num5;
				ptr2 = ptr2->m_NextBlock;
			}
			return nativeArray;
		}

		public unsafe void Clear()
		{
			UnsafeQueueBlockHeader* ptr = (UnsafeQueueBlockHeader*)(void*)m_Buffer->m_FirstBlock;
			while (ptr != null)
			{
				UnsafeQueueBlockHeader* nextBlock = ptr->m_NextBlock;
				m_QueuePool->FreeBlock(ptr);
				ptr = nextBlock;
			}
			m_Buffer->m_FirstBlock = IntPtr.Zero;
			m_Buffer->m_LastBlock = IntPtr.Zero;
			m_Buffer->m_CurrentRead = 0;
			int threadIndexCount = JobsUtility.ThreadIndexCount;
			for (int i = 0; i < threadIndexCount; i++)
			{
				m_Buffer->SetCurrentWriteBlockTLS(i, null);
			}
		}

		public unsafe void Dispose()
		{
			if (IsCreated)
			{
				UnsafeQueueData.DeallocateQueue(m_Buffer, m_QueuePool, m_AllocatorLabel);
				m_Buffer = null;
				m_QueuePool = null;
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new UnsafeQueueDisposeJob
			{
				Data = new UnsafeQueueDispose
				{
					m_Buffer = m_Buffer,
					m_QueuePool = m_QueuePool,
					m_AllocatorLabel = m_AllocatorLabel
				}
			}.Schedule(inputDeps);
			m_Buffer = null;
			m_QueuePool = null;
			return result;
		}

		public ReadOnly AsReadOnly()
		{
			return new ReadOnly(ref this);
		}

		public unsafe ParallelWriter AsParallelWriter()
		{
			ParallelWriter result = default(ParallelWriter);
			result.m_Buffer = m_Buffer;
			result.m_QueuePool = m_QueuePool;
			result.m_ThreadIndex = 0;
			return result;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private unsafe void CheckNotEmpty()
		{
			_ = m_Buffer->m_FirstBlock == (IntPtr)0;
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void ThrowEmpty()
		{
			throw new InvalidOperationException("Trying to read from an empty queue.");
		}
	}
	[GenerateTestsForBurstCompatibility]
	internal struct UnsafeQueueDispose
	{
		[NativeDisableUnsafePtrRestriction]
		internal unsafe UnsafeQueueData* m_Buffer;

		[NativeDisableUnsafePtrRestriction]
		internal unsafe UnsafeQueueBlockPoolData* m_QueuePool;

		internal AllocatorManager.AllocatorHandle m_AllocatorLabel;

		public unsafe void Dispose()
		{
			UnsafeQueueData.DeallocateQueue(m_Buffer, m_QueuePool, m_AllocatorLabel);
		}
	}
	[BurstCompile]
	internal struct UnsafeQueueDisposeJob : IJob
	{
		public UnsafeQueueDispose Data;

		public void Execute()
		{
			Data.Dispose();
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class UTF8ArrayUnsafeUtility
	{
		internal struct Comparison
		{
			public bool terminates;

			public int result;

			public Comparison(Unicode.Rune runeA, ConversionError errorA, Unicode.Rune runeB, ConversionError errorB)
			{
				if (errorA != ConversionError.None)
				{
					runeA.value = 0;
				}
				if (errorB != ConversionError.None)
				{
					runeB.value = 0;
				}
				if (runeA.value != runeB.value)
				{
					result = runeA.value - runeB.value;
					terminates = true;
				}
				else
				{
					result = 0;
					terminates = runeA.value == 0 && runeB.value == 0;
				}
			}
		}

		public unsafe static CopyError Copy(byte* dest, out int destLength, int destUTF8MaxLengthInBytes, char* src, int srcLength)
		{
			if (Unicode.Utf16ToUtf8(src, srcLength, dest, out destLength, destUTF8MaxLengthInBytes) == ConversionError.None)
			{
				return CopyError.None;
			}
			return CopyError.Truncation;
		}

		public unsafe static CopyError Copy(byte* dest, out ushort destLength, ushort destUTF8MaxLengthInBytes, char* src, int srcLength)
		{
			int utf8Length;
			ConversionError num = Unicode.Utf16ToUtf8(src, srcLength, dest, out utf8Length, destUTF8MaxLengthInBytes);
			destLength = (ushort)utf8Length;
			if (num == ConversionError.None)
			{
				return CopyError.None;
			}
			return CopyError.Truncation;
		}

		public unsafe static CopyError Copy(byte* dest, out int destLength, int destUTF8MaxLengthInBytes, byte* src, int srcLength)
		{
			int destLength2;
			ConversionError num = Unicode.Utf8ToUtf8(src, srcLength, dest, out destLength2, destUTF8MaxLengthInBytes);
			destLength = destLength2;
			if (num == ConversionError.None)
			{
				return CopyError.None;
			}
			return CopyError.Truncation;
		}

		public unsafe static CopyError Copy(byte* dest, out ushort destLength, ushort destUTF8MaxLengthInBytes, byte* src, ushort srcLength)
		{
			int destLength2;
			ConversionError num = Unicode.Utf8ToUtf8(src, srcLength, dest, out destLength2, destUTF8MaxLengthInBytes);
			destLength = (ushort)destLength2;
			if (num == ConversionError.None)
			{
				return CopyError.None;
			}
			return CopyError.Truncation;
		}

		public unsafe static CopyError Copy(char* dest, out int destLength, int destUCS2MaxLengthInChars, byte* src, int srcLength)
		{
			if (Unicode.Utf8ToUtf16(src, srcLength, dest, out destLength, destUCS2MaxLengthInChars) == ConversionError.None)
			{
				return CopyError.None;
			}
			return CopyError.Truncation;
		}

		public unsafe static CopyError Copy(char* dest, out ushort destLength, ushort destUCS2MaxLengthInChars, byte* src, ushort srcLength)
		{
			int utf16Length;
			ConversionError num = Unicode.Utf8ToUtf16(src, srcLength, dest, out utf16Length, destUCS2MaxLengthInChars);
			destLength = (ushort)utf16Length;
			if (num == ConversionError.None)
			{
				return CopyError.None;
			}
			return CopyError.Truncation;
		}

		public unsafe static FormatError AppendUTF8Bytes(byte* dest, ref int destLength, int destCapacity, byte* src, int srcLength)
		{
			if (destLength + srcLength > destCapacity)
			{
				return FormatError.Overflow;
			}
			UnsafeUtility.MemCpy(dest + destLength, src, srcLength);
			destLength += srcLength;
			return FormatError.None;
		}

		public unsafe static CopyError Append(byte* dest, ref ushort destLength, ushort destUTF8MaxLengthInBytes, byte* src, ushort srcLength)
		{
			int destLength2;
			ConversionError num = Unicode.Utf8ToUtf8(src, srcLength, dest + (int)destLength, out destLength2, destUTF8MaxLengthInBytes - destLength);
			destLength += (ushort)destLength2;
			if (num == ConversionError.None)
			{
				return CopyError.None;
			}
			return CopyError.Truncation;
		}

		public unsafe static CopyError Append(byte* dest, ref ushort destLength, ushort destUTF8MaxLengthInBytes, char* src, int srcLength)
		{
			int utf8Length;
			ConversionError num = Unicode.Utf16ToUtf8(src, srcLength, dest + (int)destLength, out utf8Length, destUTF8MaxLengthInBytes - destLength);
			destLength += (ushort)utf8Length;
			if (num == ConversionError.None)
			{
				return CopyError.None;
			}
			return CopyError.Truncation;
		}

		public unsafe static CopyError Append(char* dest, ref ushort destLength, ushort destUCS2MaxLengthInChars, byte* src, ushort srcLength)
		{
			int utf16Length;
			ConversionError num = Unicode.Utf8ToUtf16(src, srcLength, dest + (int)destLength, out utf16Length, destUCS2MaxLengthInChars - destLength);
			destLength += (ushort)utf16Length;
			if (num == ConversionError.None)
			{
				return CopyError.None;
			}
			return CopyError.Truncation;
		}

		public unsafe static int StrCmp(byte* utf8BufferA, int utf8LengthInBytesA, byte* utf8BufferB, int utf8LengthInBytesB)
		{
			int index = 0;
			int index2 = 0;
			Comparison comparison;
			do
			{
				Unicode.Rune rune;
				ConversionError errorA = Unicode.Utf8ToUcs(out rune, utf8BufferA, ref index, utf8LengthInBytesA);
				Unicode.Rune rune2;
				ConversionError errorB = Unicode.Utf8ToUcs(out rune2, utf8BufferB, ref index2, utf8LengthInBytesB);
				comparison = new Comparison(rune, errorA, rune2, errorB);
			}
			while (!comparison.terminates);
			return comparison.result;
		}

		internal unsafe static int StrCmp(byte* utf8BufferA, int utf8LengthInBytesA, Unicode.Rune* runeBufferB, int lengthInRunesB)
		{
			int index = 0;
			int index2 = 0;
			Comparison comparison;
			do
			{
				Unicode.Rune rune;
				ConversionError errorA = Unicode.Utf8ToUcs(out rune, utf8BufferA, ref index, utf8LengthInBytesA);
				Unicode.Rune rune2;
				ConversionError errorB = Unicode.UcsToUcs(out rune2, runeBufferB, ref index2, lengthInRunesB);
				comparison = new Comparison(rune, errorA, rune2, errorB);
			}
			while (!comparison.terminates);
			return comparison.result;
		}

		public unsafe static int StrCmp(char* utf16BufferA, int utf16LengthInCharsA, char* utf16BufferB, int utf16LengthInCharsB)
		{
			int index = 0;
			int index2 = 0;
			Comparison comparison;
			do
			{
				Unicode.Rune rune;
				ConversionError errorA = Unicode.Utf16ToUcs(out rune, utf16BufferA, ref index, utf16LengthInCharsA);
				Unicode.Rune rune2;
				ConversionError errorB = Unicode.Utf16ToUcs(out rune2, utf16BufferB, ref index2, utf16LengthInCharsB);
				comparison = new Comparison(rune, errorA, rune2, errorB);
			}
			while (!comparison.terminates);
			return comparison.result;
		}

		public unsafe static bool EqualsUTF8Bytes(byte* aBytes, int aLength, byte* bBytes, int bLength)
		{
			if (aLength == bLength)
			{
				return StrCmp(aBytes, aLength, bBytes, bLength) == 0;
			}
			return false;
		}

		public unsafe static int StrCmp(byte* utf8Buffer, int utf8LengthInBytes, char* utf16Buffer, int utf16LengthInChars)
		{
			int index = 0;
			int index2 = 0;
			Comparison comparison;
			do
			{
				Unicode.Rune rune;
				ConversionError errorA = Unicode.Utf8ToUcs(out rune, utf8Buffer, ref index, utf8LengthInBytes);
				Unicode.Rune rune2;
				ConversionError errorB = Unicode.Utf16ToUcs(out rune2, utf16Buffer, ref index2, utf16LengthInChars);
				comparison = new Comparison(rune, errorA, rune2, errorB);
			}
			while (!comparison.terminates);
			return comparison.result;
		}

		public unsafe static int StrCmp(char* utf16Buffer, int utf16LengthInChars, byte* utf8Buffer, int utf8LengthInBytes)
		{
			return -StrCmp(utf8Buffer, utf8LengthInBytes, utf16Buffer, utf16LengthInChars);
		}
	}
	[GenerateTestsForBurstCompatibility]
	[BurstCompile]
	[GenerateTestsForBurstCompatibility]
	[GenerateTestsForBurstCompatibility]
	public static class xxHash3
	{
		private struct ulong2
		{
			public ulong x;

			public ulong y;

			public ulong2(ulong x, ulong y)
			{
				this.x = x;
				this.y = y;
			}
		}

		[GenerateTestsForBurstCompatibility]
		public struct StreamingState
		{
			[StructLayout(LayoutKind.Explicit)]
			private struct StreamingStateData
			{
				[FieldOffset(0)]
				public ulong Acc;

				[FieldOffset(64)]
				public byte Buffer;

				[FieldOffset(320)]
				public int IsHash64;

				[FieldOffset(324)]
				public int BufferedSize;

				[FieldOffset(328)]
				public int NbStripesSoFar;

				[FieldOffset(336)]
				public long TotalLength;

				[FieldOffset(344)]
				public ulong Seed;

				[FieldOffset(352)]
				public byte SecretKey;

				[FieldOffset(540)]
				public byte _PadEnd;
			}

			private static readonly int SECRET_LIMIT = 128;

			private static readonly int NB_STRIPES_PER_BLOCK = SECRET_LIMIT / 8;

			private static readonly int INTERNAL_BUFFER_SIZE = 256;

			private static readonly int INTERNAL_BUFFER_STRIPES = INTERNAL_BUFFER_SIZE / 64;

			private StreamingStateData State;

			private unsafe ulong* Acc
			{
				[DebuggerStepThrough]
				get
				{
					return (ulong*)UnsafeUtility.AddressOf(ref State.Acc);
				}
			}

			private unsafe byte* Buffer
			{
				[DebuggerStepThrough]
				get
				{
					return (byte*)UnsafeUtility.AddressOf(ref State.Buffer);
				}
			}

			private unsafe byte* SecretKey
			{
				[DebuggerStepThrough]
				get
				{
					return (byte*)UnsafeUtility.AddressOf(ref State.SecretKey);
				}
			}

			public StreamingState(bool isHash64, ulong seed = 0uL)
			{
				State = default(StreamingStateData);
				Reset(isHash64, seed);
			}

			public unsafe void Reset(bool isHash64, ulong seed = 0uL)
			{
				int num = UnsafeUtility.SizeOf<StreamingStateData>();
				UnsafeUtility.MemClear(UnsafeUtility.AddressOf(ref State), num);
				State.IsHash64 = (isHash64 ? 1 : 0);
				ulong* acc = Acc;
				*acc = 3266489917uL;
				acc[1] = 11400714785074694791uL;
				acc[2] = 14029467366897019727uL;
				acc[3] = 1609587929392839161uL;
				acc[4] = 9650029242287828579uL;
				acc[5] = 2246822519uL;
				acc[6] = 2870177450012600261uL;
				acc[7] = 2654435761uL;
				State.Seed = seed;
				fixed (byte* kSecret = xxHashDefaultKey.kSecret)
				{
					if (seed != 0L)
					{
						EncodeSecretKey(SecretKey, kSecret, seed);
					}
					else
					{
						UnsafeUtility.MemCpy(SecretKey, kSecret, 192L);
					}
				}
			}

			public unsafe void Update(void* input, int length)
			{
				byte* ptr = (byte*)input;
				byte* ptr2 = ptr + length;
				int isHash = State.IsHash64;
				byte* secretKey = SecretKey;
				State.TotalLength += length;
				if (State.BufferedSize + length <= INTERNAL_BUFFER_SIZE)
				{
					UnsafeUtility.MemCpy(Buffer + State.BufferedSize, ptr, length);
					State.BufferedSize += length;
					return;
				}
				if (State.BufferedSize != 0)
				{
					int num = INTERNAL_BUFFER_SIZE - State.BufferedSize;
					UnsafeUtility.MemCpy(Buffer + State.BufferedSize, ptr, num);
					ptr += num;
					ConsumeStripes(Acc, ref State.NbStripesSoFar, Buffer, INTERNAL_BUFFER_STRIPES, secretKey, isHash);
					State.BufferedSize = 0;
				}
				if (ptr + INTERNAL_BUFFER_SIZE < ptr2)
				{
					byte* ptr3 = ptr2 - INTERNAL_BUFFER_SIZE;
					do
					{
						ConsumeStripes(Acc, ref State.NbStripesSoFar, ptr, INTERNAL_BUFFER_STRIPES, secretKey, isHash);
						ptr += INTERNAL_BUFFER_SIZE;
					}
					while (ptr < ptr3);
					UnsafeUtility.MemCpy(Buffer + INTERNAL_BUFFER_SIZE - 64, ptr - 64, 64L);
				}
				if (ptr < ptr2)
				{
					long num2 = ptr2 - ptr;
					UnsafeUtility.MemCpy(Buffer, ptr, num2);
					State.BufferedSize = (int)num2;
				}
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public unsafe void Update<T>(in T input) where T : unmanaged
			{
				Update(UnsafeUtilityExtensions.AddressOf(in input), UnsafeUtility.SizeOf<T>());
			}

			public unsafe uint4 DigestHash128()
			{
				byte* secretKey = SecretKey;
				uint4 result;
				if (State.TotalLength > 240)
				{
					ulong* acc = stackalloc ulong[8];
					DigestLong(acc, secretKey, 0);
					ulong ul = MergeAcc(acc, secretKey + 11, (ulong)(State.TotalLength * -7046029288634856825L));
					ulong ul2 = MergeAcc(acc, secretKey + SECRET_LIMIT - 11, (ulong)(~(State.TotalLength * -4417276706812531889L)));
					result = ToUint4(ul, ul2);
				}
				else
				{
					result = Hash128(Buffer, State.TotalLength, State.Seed);
				}
				Reset(State.IsHash64 == 1, State.Seed);
				return result;
			}

			public unsafe uint2 DigestHash64()
			{
				byte* secretKey = SecretKey;
				uint2 result;
				if (State.TotalLength > 240)
				{
					ulong* acc = stackalloc ulong[8];
					DigestLong(acc, secretKey, 1);
					result = ToUint2(MergeAcc(acc, secretKey + 11, (ulong)(State.TotalLength * -7046029288634856825L)));
				}
				else
				{
					result = Hash64(Buffer, State.TotalLength, State.Seed);
				}
				Reset(State.IsHash64 == 1, State.Seed);
				return result;
			}

			private unsafe void DigestLong(ulong* acc, byte* secret, int isHash64)
			{
				UnsafeUtility.MemCpy(acc, Acc, 64L);
				if (State.BufferedSize >= 64)
				{
					int num = (State.BufferedSize - 1) / 64;
					ConsumeStripes(acc, ref State.NbStripesSoFar, Buffer, num, secret, isHash64);
					if (X86.Avx2.IsAvx2Supported)
					{
						Avx2Accumulate512(acc, Buffer + State.BufferedSize - 64, null, secret + SECRET_LIMIT - 7);
					}
					else
					{
						DefaultAccumulate512(acc, Buffer + State.BufferedSize - 64, null, secret + SECRET_LIMIT - 7, isHash64);
					}
					return;
				}
				byte* ptr = stackalloc byte[64];
				int num2 = 64 - State.BufferedSize;
				UnsafeUtility.MemCpy(ptr, Buffer + INTERNAL_BUFFER_SIZE - num2, num2);
				UnsafeUtility.MemCpy(ptr + num2, Buffer, State.BufferedSize);
				if (X86.Avx2.IsAvx2Supported)
				{
					Avx2Accumulate512(acc, ptr, null, secret + SECRET_LIMIT - 7);
				}
				else
				{
					DefaultAccumulate512(acc, ptr, null, secret + SECRET_LIMIT - 7, isHash64);
				}
			}

			private unsafe void ConsumeStripes(ulong* acc, ref int nbStripesSoFar, byte* input, long totalStripes, byte* secret, int isHash64)
			{
				if (NB_STRIPES_PER_BLOCK - nbStripesSoFar <= totalStripes)
				{
					int num = NB_STRIPES_PER_BLOCK - nbStripesSoFar;
					if (X86.Avx2.IsAvx2Supported)
					{
						Avx2Accumulate(acc, input, null, secret + nbStripesSoFar * 8, num, isHash64);
						Avx2ScrambleAcc(acc, secret + SECRET_LIMIT);
						Avx2Accumulate(acc, input + num * 64, null, secret, totalStripes - num, isHash64);
					}
					else
					{
						DefaultAccumulate(acc, input, null, secret + nbStripesSoFar * 8, num, isHash64);
						DefaultScrambleAcc(acc, secret + SECRET_LIMIT);
						DefaultAccumulate(acc, input + num * 64, null, secret, totalStripes - num, isHash64);
					}
					nbStripesSoFar = (int)totalStripes - num;
				}
				else
				{
					if (X86.Avx2.IsAvx2Supported)
					{
						Avx2Accumulate(acc, input, null, secret + nbStripesSoFar * 8, totalStripes, isHash64);
					}
					else
					{
						DefaultAccumulate(acc, input, null, secret + nbStripesSoFar * 8, totalStripes, isHash64);
					}
					nbStripesSoFar += (int)totalStripes;
				}
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private void CheckKeySize(int isHash64)
			{
				if (State.IsHash64 != isHash64)
				{
					string text = ((State.IsHash64 != 0) ? "64" : "128");
					throw new InvalidOperationException("The streaming state was create for " + text + " bits hash key, the calling method doesn't support this key size, please use the appropriate API");
				}
			}
		}

		internal unsafe delegate ulong Hash64Long_00000A73$PostfixBurstDelegate(byte* input, byte* dest, long length, byte* secret);

		internal static class Hash64Long_00000A73$BurstDirectCall
		{
			private static IntPtr Pointer;

			private static IntPtr DeferredCompilation;

			[BurstDiscard]
			private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
			{
				if (Pointer == (IntPtr)0)
				{
					Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(Hash64Long_00000A73$PostfixBurstDelegate).TypeHandle);
				}
				P_0 = Pointer;
			}

			private static IntPtr GetFunctionPointer()
			{
				nint result = 0;
				GetFunctionPointerDiscard(ref result);
				return result;
			}

			public static void Constructor()
			{
				DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
			}

			public static void Initialize()
			{
			}

			static Hash64Long_00000A73$BurstDirectCall()
			{
				Constructor();
			}

			public unsafe static ulong Invoke(byte* input, byte* dest, long length, byte* secret)
			{
				if (BurstCompiler.IsEnabled)
				{
					IntPtr functionPointer = GetFunctionPointer();
					if (functionPointer != (IntPtr)0)
					{
						return ((delegate* unmanaged[Cdecl]<byte*, byte*, long, byte*, ulong>)functionPointer)(input, dest, length, secret);
					}
				}
				return Hash64Long$BurstManaged(input, dest, length, secret);
			}
		}

		internal unsafe delegate void Hash128Long_00000A7A$PostfixBurstDelegate(byte* input, byte* dest, long length, byte* secret, out uint4 result);

		internal static class Hash128Long_00000A7A$BurstDirectCall
		{
			private static IntPtr Pointer;

			private static IntPtr DeferredCompilation;

			[BurstDiscard]
			private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
			{
				if (Pointer == (IntPtr)0)
				{
					Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(Hash128Long_00000A7A$PostfixBurstDelegate).TypeHandle);
				}
				P_0 = Pointer;
			}

			private static IntPtr GetFunctionPointer()
			{
				nint result = 0;
				GetFunctionPointerDiscard(ref result);
				return result;
			}

			public static void Constructor()
			{
				DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
			}

			public static void Initialize()
			{
			}

			static Hash128Long_00000A7A$BurstDirectCall()
			{
				Constructor();
			}

			public unsafe static void Invoke(byte* input, byte* dest, long length, byte* secret, out uint4 result)
			{
				if (BurstCompiler.IsEnabled)
				{
					IntPtr functionPointer = GetFunctionPointer();
					if (functionPointer != (IntPtr)0)
					{
						((delegate* unmanaged[Cdecl]<byte*, byte*, long, byte*, ref uint4, void>)functionPointer)(input, dest, length, secret, ref result);
						return;
					}
				}
				Hash128Long$BurstManaged(input, dest, length, secret, out result);
			}
		}

		private const int STRIPE_LEN = 64;

		private const int ACC_NB = 8;

		private const int SECRET_CONSUME_RATE = 8;

		private const int SECRET_KEY_SIZE = 192;

		private const int SECRET_KEY_MIN_SIZE = 136;

		private const int SECRET_LASTACC_START = 7;

		private const int NB_ROUNDS = 16;

		private const int BLOCK_LEN = 1024;

		private const uint PRIME32_1 = 2654435761u;

		private const uint PRIME32_2 = 2246822519u;

		private const uint PRIME32_3 = 3266489917u;

		private const uint PRIME32_5 = 374761393u;

		private const ulong PRIME64_1 = 11400714785074694791uL;

		private const ulong PRIME64_2 = 14029467366897019727uL;

		private const ulong PRIME64_3 = 1609587929392839161uL;

		private const ulong PRIME64_4 = 9650029242287828579uL;

		private const ulong PRIME64_5 = 2870177450012600261uL;

		private const int MIDSIZE_MAX = 240;

		private const int MIDSIZE_STARTOFFSET = 3;

		private const int MIDSIZE_LASTOFFSET = 17;

		private const int SECRET_MERGEACCS_START = 11;

		internal unsafe static void Avx2HashLongInternalLoop(ulong* acc, byte* input, byte* dest, long length, byte* secret, int isHash64)
		{
			if (!X86.Avx2.IsAvx2Supported)
			{
				return;
			}
			long num = (length - 1) / 1024;
			for (int i = 0; i < num; i++)
			{
				Avx2Accumulate(acc, input + i * 1024, (dest == null) ? null : (dest + i * 1024), secret, 16L, isHash64);
				Avx2ScrambleAcc(acc, secret + 192 - 64);
			}
			long nbStripes = (length - 1 - 1024 * num) / 64;
			Avx2Accumulate(acc, input + num * 1024, (dest == null) ? null : (dest + num * 1024), secret, nbStripes, isHash64);
			byte* input2 = input + length - 64;
			Avx2Accumulate512(acc, input2, null, secret + 192 - 64 - 7);
			if (dest != null)
			{
				long num2 = length % 64;
				if (num2 != 0L)
				{
					UnsafeUtility.MemCpy(dest + length - num2, input + length - num2, num2);
				}
			}
		}

		internal unsafe static void Avx2ScrambleAcc(ulong* acc, byte* secret)
		{
			if (X86.Avx2.IsAvx2Supported)
			{
				v256 b = X86.Avx.mm256_set1_epi32(-1640531535);
				v256 a = *(v256*)acc;
				v256 b2 = X86.Avx2.mm256_srli_epi64(a, 47);
				v256 a2 = X86.Avx2.mm256_xor_si256(a, b2);
				v256 b3 = X86.Avx.mm256_loadu_si256(secret);
				v256 a3 = X86.Avx2.mm256_xor_si256(a2, b3);
				v256 a4 = X86.Avx2.mm256_shuffle_epi32(a3, X86.Sse.SHUFFLE(0, 3, 0, 1));
				v256 a5 = X86.Avx2.mm256_mul_epu32(a3, b);
				v256 a6 = X86.Avx2.mm256_mul_epu32(a4, b);
				*(v256*)acc = X86.Avx2.mm256_add_epi64(a5, X86.Avx2.mm256_slli_epi64(a6, 32));
				v256 a7 = ((v256*)acc)[1];
				b2 = X86.Avx2.mm256_srli_epi64(a7, 47);
				v256 a8 = X86.Avx2.mm256_xor_si256(a7, b2);
				b3 = X86.Avx.mm256_loadu_si256(secret + sizeof(v256));
				v256 a9 = X86.Avx2.mm256_xor_si256(a8, b3);
				a4 = X86.Avx2.mm256_shuffle_epi32(a9, X86.Sse.SHUFFLE(0, 3, 0, 1));
				a5 = X86.Avx2.mm256_mul_epu32(a9, b);
				a6 = X86.Avx2.mm256_mul_epu32(a4, b);
				((v256*)acc)[1] = X86.Avx2.mm256_add_epi64(a5, X86.Avx2.mm256_slli_epi64(a6, 32));
			}
		}

		internal unsafe static void Avx2Accumulate(ulong* acc, byte* input, byte* dest, byte* secret, long nbStripes, int isHash64)
		{
			if (X86.Avx2.IsAvx2Supported)
			{
				for (int i = 0; i < nbStripes; i++)
				{
					byte* input2 = input + i * 64;
					Avx2Accumulate512(acc, input2, (dest == null) ? null : (dest + i * 64), secret + i * 8);
				}
			}
		}

		internal unsafe static void Avx2Accumulate512(ulong* acc, byte* input, byte* dest, byte* secret)
		{
			if (X86.Avx2.IsAvx2Supported)
			{
				v256 v = X86.Avx.mm256_loadu_si256(input);
				v256 b = X86.Avx.mm256_loadu_si256(secret);
				v256 a = X86.Avx2.mm256_xor_si256(v, b);
				if (dest != null)
				{
					X86.Avx.mm256_storeu_si256(dest, v);
				}
				v256 b2 = X86.Avx2.mm256_shuffle_epi32(a, X86.Sse.SHUFFLE(0, 3, 0, 1));
				v256 a2 = X86.Avx2.mm256_mul_epu32(a, b2);
				v256 b3 = X86.Avx2.mm256_shuffle_epi32(v, X86.Sse.SHUFFLE(1, 0, 3, 2));
				v256 b4 = X86.Avx2.mm256_add_epi64(*(v256*)acc, b3);
				*(v256*)acc = X86.Avx2.mm256_add_epi64(a2, b4);
				v = X86.Avx.mm256_loadu_si256(input + sizeof(v256));
				b = X86.Avx.mm256_loadu_si256(secret + sizeof(v256));
				v256 a3 = X86.Avx2.mm256_xor_si256(v, b);
				if (dest != null)
				{
					X86.Avx.mm256_storeu_si256(dest + 32, v);
				}
				b2 = X86.Avx2.mm256_shuffle_epi32(a3, X86.Sse.SHUFFLE(0, 3, 0, 1));
				a2 = X86.Avx2.mm256_mul_epu32(a3, b2);
				b3 = X86.Avx2.mm256_shuffle_epi32(v, X86.Sse.SHUFFLE(1, 0, 3, 2));
				b4 = X86.Avx2.mm256_add_epi64(((v256*)acc)[1], b3);
				((v256*)acc)[1] = X86.Avx2.mm256_add_epi64(a2, b4);
			}
		}

		public unsafe static uint2 Hash64(void* input, long length)
		{
			fixed (byte* kSecret = xxHashDefaultKey.kSecret)
			{
				void* secret = kSecret;
				return ToUint2(Hash64Internal((byte*)input, null, length, (byte*)secret, 0uL));
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static uint2 Hash64<T>(in T input) where T : unmanaged
		{
			return Hash64(UnsafeUtilityExtensions.AddressOf(in input), UnsafeUtility.SizeOf<T>());
		}

		public unsafe static uint2 Hash64(void* input, long length, ulong seed)
		{
			fixed (byte* kSecret = xxHashDefaultKey.kSecret)
			{
				return ToUint2(Hash64Internal((byte*)input, null, length, kSecret, seed));
			}
		}

		public unsafe static uint4 Hash128(void* input, long length)
		{
			fixed (byte* kSecret = xxHashDefaultKey.kSecret)
			{
				void* secret = kSecret;
				Hash128Internal((byte*)input, null, length, (byte*)secret, 0uL, out var result);
				return result;
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static uint4 Hash128<T>(in T input) where T : unmanaged
		{
			return Hash128(UnsafeUtilityExtensions.AddressOf(in input), UnsafeUtility.SizeOf<T>());
		}

		public unsafe static uint4 Hash128(void* input, void* destination, long length)
		{
			fixed (byte* kSecret = xxHashDefaultKey.kSecret)
			{
				Hash128Internal((byte*)input, (byte*)destination, length, kSecret, 0uL, out var result);
				return result;
			}
		}

		public unsafe static uint4 Hash128(void* input, long length, ulong seed)
		{
			fixed (byte* kSecret = xxHashDefaultKey.kSecret)
			{
				Hash128Internal((byte*)input, null, length, kSecret, seed, out var result);
				return result;
			}
		}

		public unsafe static uint4 Hash128(void* input, void* destination, long length, ulong seed)
		{
			fixed (byte* kSecret = xxHashDefaultKey.kSecret)
			{
				Hash128Internal((byte*)input, (byte*)destination, length, kSecret, seed, out var result);
				return result;
			}
		}

		internal unsafe static ulong Hash64Internal(byte* input, byte* dest, long length, byte* secret, ulong seed)
		{
			if (length < 16)
			{
				return Hash64Len0To16(input, length, secret, seed);
			}
			if (length < 128)
			{
				return Hash64Len17To128(input, length, secret, seed);
			}
			if (length < 240)
			{
				return Hash64Len129To240(input, length, secret, seed);
			}
			if (seed != 0L)
			{
				byte* ptr = (byte*)Memory.Unmanaged.Allocate(192L, 64, Allocator.Temp);
				EncodeSecretKey(ptr, secret, seed);
				ulong result = Hash64Long(input, dest, length, ptr);
				Memory.Unmanaged.Free(ptr, Allocator.Temp);
				return result;
			}
			return Hash64Long(input, dest, length, secret);
		}

		internal unsafe static void Hash128Internal(byte* input, byte* dest, long length, byte* secret, ulong seed, out uint4 result)
		{
			if (dest != null && length < 240)
			{
				UnsafeUtility.MemCpy(dest, input, length);
			}
			if (length < 16)
			{
				Hash128Len0To16(input, length, secret, seed, out result);
			}
			else if (length < 128)
			{
				Hash128Len17To128(input, length, secret, seed, out result);
			}
			else if (length < 240)
			{
				Hash128Len129To240(input, length, secret, seed, out result);
			}
			else if (seed != 0L)
			{
				byte* ptr = (byte*)(((long)stackalloc byte[223] + 31L) & -32);
				EncodeSecretKey(ptr, secret, seed);
				Hash128Long(input, dest, length, ptr, out result);
			}
			else
			{
				Hash128Long(input, dest, length, secret, out result);
			}
		}

		private unsafe static ulong Hash64Len1To3(byte* input, long len, byte* secret, ulong seed)
		{
			byte num = *input;
			byte b = input[len >> 1];
			byte b2 = input[len - 1];
			int num2 = (num << 16) | (b << 24) | b2 | ((int)len << 8);
			ulong num3 = (Read32LE(secret) ^ Read32LE(secret + 4)) + seed;
			return AvalancheH64((uint)num2 ^ num3);
		}

		private unsafe static ulong Hash64Len4To8(byte* input, long length, byte* secret, ulong seed)
		{
			seed ^= (ulong)Swap32((uint)seed) << 32;
			uint num = Read32LE(input);
			uint num2 = Read32LE(input + length - 4);
			ulong num3 = (Read64LE(secret + 8) ^ Read64LE(secret + 16)) - seed;
			return rrmxmx((num2 + ((ulong)num << 32)) ^ num3, (ulong)length);
		}

		private unsafe static ulong Hash64Len9To16(byte* input, long length, byte* secret, ulong seed)
		{
			ulong num = (Read64LE(secret + 24) ^ Read64LE(secret + 32)) + seed;
			ulong num2 = (Read64LE(secret + 40) ^ Read64LE(secret + 48)) - seed;
			ulong num3 = Read64LE(input) ^ num;
			ulong num4 = Read64LE(input + length - 8) ^ num2;
			return Avalanche((ulong)(length + (long)Swap64(num3) + (long)num4) + Mul128Fold64(num3, num4));
		}

		private unsafe static ulong Hash64Len0To16(byte* input, long length, byte* secret, ulong seed)
		{
			if (length > 8)
			{
				return Hash64Len9To16(input, length, secret, seed);
			}
			if (length >= 4)
			{
				return Hash64Len4To8(input, length, secret, seed);
			}
			if (length > 0)
			{
				return Hash64Len1To3(input, length, secret, seed);
			}
			return AvalancheH64(seed ^ (Read64LE(secret + 56) ^ Read64LE(secret + 64)));
		}

		private unsafe static ulong Hash64Len17To128(byte* input, long length, byte* secret, ulong seed)
		{
			ulong num = (ulong)(length * -7046029288634856825L);
			if (length > 32)
			{
				if (length > 64)
				{
					if (length > 96)
					{
						num += Mix16(input + 48, secret + 96, seed);
						num += Mix16(input + length - 64, secret + 112, seed);
					}
					num += Mix16(input + 32, secret + 64, seed);
					num += Mix16(input + length - 48, secret + 80, seed);
				}
				num += Mix16(input + 16, secret + 32, seed);
				num += Mix16(input + length - 32, secret + 48, seed);
			}
			num += Mix16(input, secret, seed);
			num += Mix16(input + length - 16, secret + 16, seed);
			return Avalanche(num);
		}

		private unsafe static ulong Hash64Len129To240(byte* input, long length, byte* secret, ulong seed)
		{
			ulong num = (ulong)(length * -7046029288634856825L);
			int num2 = (int)length / 16;
			for (int i = 0; i < 8; i++)
			{
				num += Mix16(input + 16 * i, secret + 16 * i, seed);
			}
			num = Avalanche(num);
			for (int j = 8; j < num2; j++)
			{
				num += Mix16(input + 16 * j, secret + 16 * (j - 8) + 3, seed);
			}
			num += Mix16(input + length - 16, secret + 136 - 17, seed);
			return Avalanche(num);
		}

		[BurstCompile]
		private unsafe static ulong Hash64Long(byte* input, byte* dest, long length, byte* secret)
		{
			return Hash64Long_00000A73$BurstDirectCall.Invoke(input, dest, length, secret);
		}

		private unsafe static void Hash128Len1To3(byte* input, long length, byte* secret, ulong seed, out uint4 result)
		{
			byte num = *input;
			byte b = input[length >> 1];
			byte b2 = input[length - 1];
			int num2 = (num << 16) + (b << 24) + b2 + ((int)length << 8);
			uint num3 = RotL32(Swap32((uint)num2), 13);
			ulong num4 = (Read32LE(secret) ^ Read32LE(secret + 4)) + seed;
			ulong num5 = (Read32LE(secret + 8) ^ Read32LE(secret + 12)) - seed;
			ulong h = (uint)num2 ^ num4;
			ulong h2 = num3 ^ num5;
			result = ToUint4(AvalancheH64(h), AvalancheH64(h2));
		}

		private unsafe static void Hash128Len4To8(byte* input, long len, byte* secret, ulong seed, out uint4 result)
		{
			seed ^= (ulong)Swap32((uint)seed) << 32;
			uint num = Read32LE(input);
			uint num2 = Read32LE(input + len - 4);
			ulong num3 = num + ((ulong)num2 << 32);
			ulong num4 = (Read64LE(secret + 16) ^ Read64LE(secret + 24)) + seed;
			ulong high;
			ulong num5 = Common.umul128(num3 ^ num4, (ulong)(-7046029288634856825L + (len << 2)), out high);
			high += num5 << 1;
			num5 ^= high >> 3;
			num5 = XorShift64(num5, 35);
			num5 *= 11507291218515648293uL;
			num5 = XorShift64(num5, 28);
			high = Avalanche(high);
			result = ToUint4(num5, high);
		}

		private unsafe static void Hash128Len9To16(byte* input, long len, byte* secret, ulong seed, out uint4 result)
		{
			ulong num = (Read64LE(secret + 32) ^ Read64LE(secret + 40)) - seed;
			ulong num2 = (Read64LE(secret + 48) ^ Read64LE(secret + 56)) + seed;
			ulong num3 = Read64LE(input);
			ulong num4 = Read64LE(input + len - 8);
			ulong high;
			long num5 = (long)Common.umul128(num3 ^ num4 ^ num, 11400714785074694791uL, out high) + (len - 1 << 54);
			num4 ^= num2;
			high += num4 + Mul32To64((uint)num4, 2246822518u);
			ulong high2;
			ulong h = Common.umul128((ulong)num5 ^ Swap64(high), 14029467366897019727uL, out high2);
			high2 += (ulong)((long)high * -4417276706812531889L);
			result = ToUint4(Avalanche(h), Avalanche(high2));
		}

		private unsafe static void Hash128Len0To16(byte* input, long length, byte* secret, ulong seed, out uint4 result)
		{
			if (length > 8)
			{
				Hash128Len9To16(input, length, secret, seed, out result);
				return;
			}
			if (length >= 4)
			{
				Hash128Len4To8(input, length, secret, seed, out result);
				return;
			}
			if (length > 0)
			{
				Hash128Len1To3(input, length, secret, seed, out result);
				return;
			}
			ulong num = Read64LE(secret + 64) ^ Read64LE(secret + 72);
			ulong num2 = Read64LE(secret + 80) ^ Read64LE(secret + 88);
			ulong ul = AvalancheH64(seed ^ num);
			ulong ul2 = AvalancheH64(seed ^ num2);
			result = ToUint4(ul, ul2);
		}

		private unsafe static void Hash128Len17To128(byte* input, long length, byte* secret, ulong seed, out uint4 result)
		{
			ulong2 acc = new ulong2((ulong)(length * -7046029288634856825L), 0uL);
			if (length > 32)
			{
				if (length > 64)
				{
					if (length > 96)
					{
						acc = Mix32(acc, input + 48, input + length - 64, secret + 96, seed);
					}
					acc = Mix32(acc, input + 32, input + length - 48, secret + 64, seed);
				}
				acc = Mix32(acc, input + 16, input + length - 32, secret + 32, seed);
			}
			acc = Mix32(acc, input, input + length - 16, secret, seed);
			ulong h = acc.x + acc.y;
			ulong h2 = (ulong)((long)acc.x * -7046029288634856825L + (long)acc.y * -8796714831421723037L + (length - (long)seed) * -4417276706812531889L);
			result = ToUint4(Avalanche(h), 0 - Avalanche(h2));
		}

		private unsafe static void Hash128Len129To240(byte* input, long length, byte* secret, ulong seed, out uint4 result)
		{
			ulong2 acc = new ulong2((ulong)(length * -7046029288634856825L), 0uL);
			long num = length / 32;
			for (int i = 0; i < 4; i++)
			{
				acc = Mix32(acc, input + 32 * i, input + 32 * i + 16, secret + 32 * i, seed);
			}
			acc.x = Avalanche(acc.x);
			acc.y = Avalanche(acc.y);
			for (int i = 4; i < num; i++)
			{
				acc = Mix32(acc, input + 32 * i, input + 32 * i + 16, secret + 3 + 32 * (i - 4), seed);
			}
			acc = Mix32(acc, input + length - 16, input + length - 32, secret + 136 - 17 - 16, 0 - seed);
			ulong h = acc.x + acc.y;
			ulong h2 = (ulong)((long)acc.x * -7046029288634856825L + (long)acc.y * -8796714831421723037L + (length - (long)seed) * -4417276706812531889L);
			result = ToUint4(Avalanche(h), 0 - Avalanche(h2));
		}

		[BurstCompile]
		private unsafe static void Hash128Long(byte* input, byte* dest, long length, byte* secret, out uint4 result)
		{
			Hash128Long_00000A7A$BurstDirectCall.Invoke(input, dest, length, secret, out result);
		}

		internal static uint2 ToUint2(ulong u)
		{
			return new uint2((uint)(u & 0xFFFFFFFFu), (uint)(u >> 32));
		}

		internal static uint4 ToUint4(ulong ul0, ulong ul1)
		{
			return new uint4((uint)(ul0 & 0xFFFFFFFFu), (uint)(ul0 >> 32), (uint)(ul1 & 0xFFFFFFFFu), (uint)(ul1 >> 32));
		}

		internal unsafe static void EncodeSecretKey(byte* dst, byte* secret, ulong seed)
		{
			int num = 12;
			for (int i = 0; i < num; i++)
			{
				Write64LE(dst + 16 * i, Read64LE(secret + 16 * i) + seed);
				Write64LE(dst + 16 * i + 8, Read64LE(secret + 16 * i + 8) - seed);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private unsafe static ulong Read64LE(void* addr)
		{
			return *(ulong*)addr;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private unsafe static uint Read32LE(void* addr)
		{
			return *(uint*)addr;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private unsafe static void Write64LE(void* addr, ulong value)
		{
			*(ulong*)addr = value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private unsafe static void Read32LE(void* addr, uint value)
		{
			*(uint*)addr = value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static ulong Mul32To64(uint x, uint y)
		{
			return (ulong)x * (ulong)y;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static ulong Swap64(ulong x)
		{
			return ((x << 56) & 0xFF00000000000000uL) | ((x << 40) & 0xFF000000000000L) | ((x << 24) & 0xFF0000000000L) | ((x << 8) & 0xFF00000000L) | ((x >> 8) & 0xFF000000u) | ((x >> 24) & 0xFF0000) | ((x >> 40) & 0xFF00) | ((x >> 56) & 0xFF);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static uint Swap32(uint x)
		{
			return ((x << 24) & 0xFF000000u) | ((x << 8) & 0xFF0000) | ((x >> 8) & 0xFF00) | ((x >> 24) & 0xFF);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static uint RotL32(uint x, int r)
		{
			return (x << r) | (x >> 32 - r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static ulong RotL64(ulong x, int r)
		{
			return (x << r) | (x >> 64 - r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static ulong XorShift64(ulong v64, int shift)
		{
			return v64 ^ (v64 >> shift);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static ulong Mul128Fold64(ulong lhs, ulong rhs)
		{
			ulong high;
			return Common.umul128(lhs, rhs, out high) ^ high;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private unsafe static ulong Mix16(byte* input, byte* secret, ulong seed)
		{
			ulong num = Read64LE(input);
			return Mul128Fold64(rhs: Read64LE(input + 8) ^ (Read64LE(secret + 8) - seed), lhs: num ^ (Read64LE(secret) + seed));
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private unsafe static ulong2 Mix32(ulong2 acc, byte* input_1, byte* input_2, byte* secret, ulong seed)
		{
			ulong x = (acc.x + Mix16(input_1, secret, seed)) ^ (Read64LE(input_2) + Read64LE(input_2 + 8));
			ulong num = acc.y + Mix16(input_2, secret + 16, seed);
			num ^= Read64LE(input_1) + Read64LE(input_1 + 8);
			return new ulong2(x, num);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static ulong Avalanche(ulong h64)
		{
			h64 = XorShift64(h64, 37);
			h64 *= 1609587791953885689L;
			h64 = XorShift64(h64, 32);
			return h64;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static ulong AvalancheH64(ulong h64)
		{
			h64 ^= h64 >> 33;
			h64 *= 14029467366897019727uL;
			h64 ^= h64 >> 29;
			h64 *= 1609587929392839161L;
			h64 ^= h64 >> 32;
			return h64;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static ulong rrmxmx(ulong h64, ulong length)
		{
			h64 ^= RotL64(h64, 49) ^ RotL64(h64, 24);
			h64 *= 11507291218515648293uL;
			h64 ^= (h64 >> 35) + length;
			h64 *= 11507291218515648293uL;
			return XorShift64(h64, 28);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private unsafe static ulong Mix2Acc(ulong acc0, ulong acc1, byte* secret)
		{
			return Mul128Fold64(acc0 ^ Read64LE(secret), acc1 ^ Read64LE(secret + 8));
		}

		internal unsafe static ulong MergeAcc(ulong* acc, byte* secret, ulong start)
		{
			return Avalanche(start + Mix2Acc(*acc, acc[1], secret) + Mix2Acc(acc[2], acc[3], secret + 16) + Mix2Acc(acc[4], acc[5], secret + 32) + Mix2Acc(acc[6], acc[7], secret + 48));
		}

		private unsafe static void DefaultHashLongInternalLoop(ulong* acc, byte* input, byte* dest, long length, byte* secret, int isHash64)
		{
			long num = (length - 1) / 1024;
			for (int i = 0; i < num; i++)
			{
				DefaultAccumulate(acc, input + i * 1024, (dest == null) ? null : (dest + i * 1024), secret, 16L, isHash64);
				DefaultScrambleAcc(acc, secret + 192 - 64);
			}
			long nbStripes = (length - 1 - 1024 * num) / 64;
			DefaultAccumulate(acc, input + num * 1024, (dest == null) ? null : (dest + num * 1024), secret, nbStripes, isHash64);
			byte* input2 = input + length - 64;
			DefaultAccumulate512(acc, input2, null, secret + 192 - 64 - 7, isHash64);
			if (dest != null)
			{
				long num2 = length % 64;
				if (num2 != 0L)
				{
					UnsafeUtility.MemCpy(dest + length - num2, input + length - num2, num2);
				}
			}
		}

		internal unsafe static void DefaultAccumulate(ulong* acc, byte* input, byte* dest, byte* secret, long nbStripes, int isHash64)
		{
			for (int i = 0; i < nbStripes; i++)
			{
				DefaultAccumulate512(acc, input + i * 64, (dest == null) ? null : (dest + i * 64), secret + i * 8, isHash64);
			}
		}

		internal unsafe static void DefaultAccumulate512(ulong* acc, byte* input, byte* dest, byte* secret, int isHash64)
		{
			int num = 8;
			for (int i = 0; i < num; i++)
			{
				ulong num2 = Read64LE(input + 8 * i);
				ulong num3 = num2 ^ Read64LE(secret + i * 8);
				if (dest != null)
				{
					Write64LE(dest + 8 * i, num2);
				}
				acc[i ^ 1] += num2;
				acc[i] += Mul32To64((uint)(num3 & 0xFFFFFFFFu), (uint)(num3 >> 32));
			}
		}

		internal unsafe static void DefaultScrambleAcc(ulong* acc, byte* secret)
		{
			for (int i = 0; i < 8; i++)
			{
				ulong num = Read64LE(secret + 8 * i);
				ulong v = acc[i];
				v = XorShift64(v, 47);
				v ^= num;
				v *= 2654435761u;
				acc[i] = v;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[BurstCompile]
		internal unsafe static ulong Hash64Long$BurstManaged(byte* input, byte* dest, long length, byte* secret)
		{
			ulong* ptr = (ulong*)(((long)stackalloc byte[95] + 31L) & -32);
			*ptr = 3266489917uL;
			ptr[1] = 11400714785074694791uL;
			ptr[2] = 14029467366897019727uL;
			ptr[3] = 1609587929392839161uL;
			ptr[4] = 9650029242287828579uL;
			ptr[5] = 2246822519uL;
			ptr[6] = 2870177450012600261uL;
			ptr[7] = 2654435761uL;
			if (X86.Avx2.IsAvx2Supported)
			{
				Avx2HashLongInternalLoop(ptr, input, dest, length, secret, 1);
			}
			else
			{
				DefaultHashLongInternalLoop(ptr, input, dest, length, secret, 1);
			}
			return MergeAcc(ptr, secret + 11, (ulong)(length * -7046029288634856825L));
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[BurstCompile]
		internal unsafe static void Hash128Long$BurstManaged(byte* input, byte* dest, long length, byte* secret, out uint4 result)
		{
			ulong* ptr = (ulong*)(((long)stackalloc byte[95] + 31L) & -32);
			*ptr = 3266489917uL;
			ptr[1] = 11400714785074694791uL;
			ptr[2] = 14029467366897019727uL;
			ptr[3] = 1609587929392839161uL;
			ptr[4] = 9650029242287828579uL;
			ptr[5] = 2246822519uL;
			ptr[6] = 2870177450012600261uL;
			ptr[7] = 2654435761uL;
			if (X86.Avx2.IsAvx2Supported)
			{
				Avx2HashLongInternalLoop(ptr, input, dest, length, secret, 0);
			}
			else
			{
				DefaultHashLongInternalLoop(ptr, input, dest, length, secret, 0);
			}
			ulong ul = MergeAcc(ptr, secret + 11, (ulong)(length * -7046029288634856825L));
			ulong ul2 = MergeAcc(ptr, secret + 192 - 64 - 11, (ulong)(~(length * -4417276706812531889L)));
			result = ToUint4(ul, ul2);
		}
	}
	internal static class xxHashDefaultKey
	{
		public static readonly byte[] kSecret = new byte[192]
		{
			184, 254, 108, 57, 35, 164, 75, 190, 124, 1,
			129, 44, 247, 33, 173, 28, 222, 212, 109, 233,
			131, 144, 151, 219, 114, 64, 164, 164, 183, 179,
			103, 31, 203, 121, 230, 78, 204, 192, 229, 120,
			130, 90, 208, 125, 204, 255, 114, 33, 184, 8,
			70, 116, 247, 67, 36, 142, 224, 53, 144, 230,
			129, 58, 38, 76, 60, 40, 82, 187, 145, 195,
			0, 203, 136, 208, 101, 139, 27, 83, 46, 163,
			113, 100, 72, 151, 162, 13, 249, 78, 56, 25,
			239, 70, 169, 222, 172, 216, 168, 250, 118, 63,
			227, 156, 52, 63, 249, 220, 187, 199, 199, 11,
			79, 29, 138, 81, 224, 75, 205, 180, 89, 49,
			200, 159, 126, 201, 217, 120, 115, 100, 234, 197,
			172, 131, 52, 211, 235, 195, 197, 129, 160, 255,
			250, 19, 99, 235, 23, 13, 221, 81, 183, 240,
			218, 73, 211, 22, 85, 38, 41, 212, 104, 158,
			43, 22, 190, 88, 125, 71, 161, 252, 143, 248,
			184, 209, 122, 208, 49, 206, 69, 203, 58, 143,
			149, 22, 4, 40, 175, 215, 251, 202, 187, 75,
			64, 126
		};
	}
}
namespace Unity.Collections.NotBurstCompatible
{
	public static class Extensions
	{
		[ExcludeFromBurstCompatTesting("Returns managed array")]
		public static T[] ToArray<T>(this NativeHashSet<T> set) where T : unmanaged, IEquatable<T>
		{
			NativeArray<T> nativeArray = set.ToNativeArray(Allocator.TempJob);
			T[] result = nativeArray.ToArray();
			nativeArray.Dispose();
			return result;
		}

		[ExcludeFromBurstCompatTesting("Returns managed array")]
		public static T[] ToArray<T>(this NativeParallelHashSet<T> set) where T : unmanaged, IEquatable<T>
		{
			NativeArray<T> nativeArray = set.ToNativeArray(Allocator.TempJob);
			T[] result = nativeArray.ToArray();
			nativeArray.Dispose();
			return result;
		}

		[ExcludeFromBurstCompatTesting("Returns managed array")]
		public static T[] ToArrayNBC<T>(this NativeList<T> list) where T : unmanaged
		{
			return list.AsArray().ToArray();
		}

		[ExcludeFromBurstCompatTesting("Takes managed array")]
		public static void CopyFromNBC<T>(this NativeList<T> list, T[] array) where T : unmanaged
		{
			list.Clear();
			list.Resize(array.Length, NativeArrayOptions.UninitializedMemory);
			list.AsArray().CopyFrom(array);
		}
	}
}
namespace Unity.Collections.LowLevel.Unsafe
{
	[GenerateTestsForBurstCompatibility]
	public static class DataStreamExtensions
	{
		public unsafe static DataStreamWriter Create(byte* data, int length)
		{
			return new DataStreamWriter(NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(data, length, Allocator.None));
		}

		public unsafe static bool WriteBytesUnsafe(this ref DataStreamWriter writer, byte* data, int bytes)
		{
			NativeArray<byte> value = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(data, bytes, Allocator.None);
			return writer.WriteBytes(value);
		}

		public unsafe static void ReadBytesUnsafe(this ref DataStreamReader reader, byte* data, int length)
		{
			NativeArray<byte> array = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(data, length, Allocator.None);
			reader.ReadBytes(array);
		}

		public unsafe static ushort ReadFixedStringUnsafe(this ref DataStreamReader reader, byte* data, int maxLength)
		{
			NativeArray<byte> array = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(data, maxLength, Allocator.Temp);
			return reader.ReadFixedString(array);
		}

		public unsafe static ushort ReadPackedFixedStringDeltaUnsafe(this ref DataStreamReader reader, byte* data, int maxLength, byte* baseData, ushort baseLength, StreamCompressionModel model)
		{
			NativeArray<byte> data2 = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(data, maxLength, Allocator.Temp);
			NativeArray<byte> baseData2 = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(baseData, baseLength, Allocator.Temp);
			return reader.ReadPackedFixedStringDelta(data2, baseData2, in model);
		}

		public unsafe static void* GetUnsafeReadOnlyPtr(this ref DataStreamReader reader)
		{
			return reader.m_BufferPtr;
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class NativeBitArrayUnsafeUtility
	{
		public unsafe static NativeBitArray ConvertExistingDataToNativeBitArray(void* ptr, int sizeInBytes, AllocatorManager.AllocatorHandle allocator)
		{
			UnsafeBitArray* ptr2 = UnsafeBitArray.Alloc(Allocator.Persistent);
			*ptr2 = new UnsafeBitArray(ptr, sizeInBytes, allocator);
			return new NativeBitArray
			{
				m_BitArray = ptr2,
				m_Allocator = Allocator.Persistent
			};
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class NativeListUnsafeUtility
	{
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static T* GetUnsafePtr<T>(this NativeList<T> list) where T : unmanaged
		{
			return list.m_ListData->Ptr;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static T* GetUnsafeReadOnlyPtr<T>(this NativeList<T> list) where T : unmanaged
		{
			return list.m_ListData->Ptr;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static void* GetInternalListDataPtrUnchecked<T>(ref NativeList<T> list) where T : unmanaged
		{
			return list.m_ListData;
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class NativeReferenceUnsafeUtility
	{
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static T* GetUnsafePtr<T>(this NativeReference<T> reference) where T : unmanaged
		{
			return (T*)reference.m_Data;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static T* GetUnsafeReadOnlyPtr<T>(this NativeReference<T> reference) where T : unmanaged
		{
			return (T*)reference.m_Data;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static T* GetUnsafePtrWithoutChecks<T>(this NativeReference<T> reference) where T : unmanaged
		{
			return (T*)reference.m_Data;
		}
	}
	[GenerateTestsForBurstCompatibility]
	public struct UnsafeAppendBuffer : INativeDisposable, IDisposable
	{
		[GenerateTestsForBurstCompatibility]
		public struct Reader
		{
			public unsafe readonly byte* Ptr;

			public readonly int Size;

			public int Offset;

			public bool EndOfBuffer => Offset == Size;

			public unsafe Reader(ref UnsafeAppendBuffer buffer)
			{
				Ptr = buffer.Ptr;
				Size = buffer.Length;
				Offset = 0;
			}

			public unsafe Reader(void* ptr, int length)
			{
				Ptr = (byte*)ptr;
				Size = length;
				Offset = 0;
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public unsafe void ReadNext<T>(out T value) where T : unmanaged
			{
				int num = UnsafeUtility.SizeOf<T>();
				void* ptr = Ptr + Offset;
				if (CollectionHelper.IsAligned((ulong)ptr, UnsafeUtility.AlignOf<T>()))
				{
					UnsafeUtility.CopyPtrToStructure<T>(ptr, out value);
				}
				else
				{
					fixed (T* ptr2 = &value)
					{
						void* destination = ptr2;
						UnsafeUtility.MemCpy(destination, ptr, num);
					}
				}
				Offset += num;
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public unsafe T ReadNext<T>() where T : unmanaged
			{
				int num = UnsafeUtility.SizeOf<T>();
				void* ptr = Ptr + Offset;
				T result = default(T);
				if (CollectionHelper.IsAligned((ulong)ptr, UnsafeUtility.AlignOf<T>()))
				{
					result = UnsafeUtility.ReadArrayElement<T>(ptr, 0);
				}
				else
				{
					UnsafeUtility.MemCpy(&result, ptr, num);
				}
				Offset += num;
				return result;
			}

			public unsafe void* ReadNext(int structSize)
			{
				void* result = (void*)((IntPtr)Ptr + Offset);
				Offset += structSize;
				return result;
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public unsafe void ReadNext<T>(out NativeArray<T> value, AllocatorManager.AllocatorHandle allocator) where T : unmanaged
			{
				int num = ReadNext<int>();
				value = CollectionHelper.CreateNativeArray<T>(num, allocator, NativeArrayOptions.UninitializedMemory);
				int num2 = num * UnsafeUtility.SizeOf<T>();
				if (num2 > 0)
				{
					void* source = ReadNext(num2);
					UnsafeUtility.MemCpy(value.GetUnsafePtr(), source, num2);
				}
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public unsafe void* ReadNextArray<T>(out int length) where T : unmanaged
			{
				length = ReadNext<int>();
				if (length != 0)
				{
					return ReadNext(length * UnsafeUtility.SizeOf<T>());
				}
				return null;
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private void CheckBounds(int structSize)
			{
				if (Offset + structSize > Size)
				{
					throw new ArgumentException($"Requested value outside bounds of UnsafeAppendOnlyBuffer. Remaining bytes: {Size - Offset} Requested: {structSize}");
				}
			}
		}

		[NativeDisableUnsafePtrRestriction]
		public unsafe byte* Ptr;

		public int Length;

		public int Capacity;

		public AllocatorManager.AllocatorHandle Allocator;

		public readonly int Alignment;

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return Length == 0;
			}
		}

		public unsafe readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return Ptr != null;
			}
		}

		public unsafe UnsafeAppendBuffer(int initialCapacity, int alignment, AllocatorManager.AllocatorHandle allocator)
		{
			Alignment = alignment;
			Allocator = allocator;
			Ptr = null;
			Length = 0;
			Capacity = 0;
			SetCapacity(math.max(initialCapacity, 1));
		}

		public unsafe UnsafeAppendBuffer(void* ptr, int length)
		{
			Alignment = 0;
			Allocator = AllocatorManager.None;
			Ptr = (byte*)ptr;
			Length = 0;
			Capacity = length;
		}

		public unsafe void Dispose()
		{
			if (IsCreated)
			{
				if (CollectionHelper.ShouldDeallocate(Allocator))
				{
					Memory.Unmanaged.Free(Ptr, Allocator);
					Allocator = AllocatorManager.Invalid;
				}
				Ptr = null;
				Length = 0;
				Capacity = 0;
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			if (CollectionHelper.ShouldDeallocate(Allocator))
			{
				JobHandle result = new UnsafeDisposeJob
				{
					Ptr = Ptr,
					Allocator = Allocator
				}.Schedule(inputDeps);
				Ptr = null;
				Allocator = AllocatorManager.Invalid;
				return result;
			}
			Ptr = null;
			return inputDeps;
		}

		public void Reset()
		{
			Length = 0;
		}

		public unsafe void SetCapacity(int capacity)
		{
			if (capacity > Capacity)
			{
				capacity = math.max(64, math.ceilpow2(capacity));
				byte* ptr = (byte*)Memory.Unmanaged.Allocate(capacity, Alignment, Allocator);
				if (Ptr != null)
				{
					UnsafeUtility.MemCpy(ptr, Ptr, Length);
					Memory.Unmanaged.Free(Ptr, Allocator);
				}
				Ptr = ptr;
				Capacity = capacity;
			}
		}

		public void ResizeUninitialized(int length)
		{
			SetCapacity(length);
			Length = length;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe void Add<T>(T value) where T : unmanaged
		{
			int num = UnsafeUtility.SizeOf<T>();
			SetCapacity(Length + num);
			void* ptr = Ptr + Length;
			if (CollectionHelper.IsAligned((ulong)ptr, UnsafeUtility.AlignOf<T>()))
			{
				UnsafeUtility.CopyStructureToPtr(ref value, ptr);
			}
			else
			{
				UnsafeUtility.MemCpy(ptr, &value, num);
			}
			Length += num;
		}

		public unsafe void Add(void* ptr, int structSize)
		{
			SetCapacity(Length + structSize);
			UnsafeUtility.MemCpy(Ptr + Length, ptr, structSize);
			Length += structSize;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe void AddArray<T>(void* ptr, int length) where T : unmanaged
		{
			Add(length);
			if (length != 0)
			{
				Add(ptr, length * UnsafeUtility.SizeOf<T>());
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe void Add<T>(NativeArray<T> value) where T : unmanaged
		{
			Add(value.Length);
			Add(value.GetUnsafeReadOnlyPtr(), UnsafeUtility.SizeOf<T>() * value.Length);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe T Pop<T>() where T : unmanaged
		{
			int num = UnsafeUtility.SizeOf<T>();
			long num2 = (long)Ptr;
			long num3 = Length;
			long num4 = num2 + num3 - num;
			T result = default(T);
			if (CollectionHelper.IsAligned((ulong)num4, UnsafeUtility.AlignOf<T>()))
			{
				result = UnsafeUtility.ReadArrayElement<T>((void*)num4, 0);
			}
			else
			{
				UnsafeUtility.MemCpy(&result, (void*)num4, num);
			}
			Length -= num;
			return result;
		}

		public unsafe void Pop(void* ptr, int structSize)
		{
			long num = (long)Ptr;
			long num2 = Length;
			long num3 = num + num2 - structSize;
			UnsafeUtility.MemCpy(ptr, (void*)num3, structSize);
			Length -= structSize;
		}

		public Reader AsReader()
		{
			return new Reader(ref this);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckAlignment(int alignment)
		{
			bool num = alignment == 0;
			bool flag = ((alignment - 1) & alignment) == 0;
			if (!(!num && flag))
			{
				throw new ArgumentException($"Specified alignment must be non-zero positive power of two. Requested: {alignment}");
			}
		}
	}
	[GenerateTestsForBurstCompatibility]
	public struct UnsafeAtomicCounter32
	{
		public unsafe int* Counter;

		public unsafe UnsafeAtomicCounter32(void* ptr)
		{
			Counter = (int*)ptr;
		}

		public unsafe void Reset(int value = 0)
		{
			*Counter = value;
		}

		public unsafe int Add(int value)
		{
			return Interlocked.Add(ref UnsafeUtility.AsRef<int>(Counter), value) - value;
		}

		public int Sub(int value)
		{
			return Add(-value);
		}

		public unsafe int AddSat(int value, int max = int.MaxValue)
		{
			int num = *Counter;
			int num2;
			do
			{
				num2 = num;
				num = ((num >= max) ? max : math.min(max, num + value));
				num = Interlocked.CompareExchange(ref UnsafeUtility.AsRef<int>(Counter), num, num2);
			}
			while (num2 != num && num2 != max);
			return num2;
		}

		public unsafe int SubSat(int value, int min = int.MinValue)
		{
			int num = *Counter;
			int num2;
			do
			{
				num2 = num;
				num = ((num <= min) ? min : math.max(min, num - value));
				num = Interlocked.CompareExchange(ref UnsafeUtility.AsRef<int>(Counter), num, num2);
			}
			while (num2 != num && num2 != min);
			return num2;
		}
	}
	[GenerateTestsForBurstCompatibility]
	public struct UnsafeAtomicCounter64
	{
		public unsafe long* Counter;

		public unsafe UnsafeAtomicCounter64(void* ptr)
		{
			Counter = (long*)ptr;
		}

		public unsafe void Reset(long value = 0L)
		{
			*Counter = value;
		}

		public unsafe long Add(long value)
		{
			return Interlocked.Add(ref UnsafeUtility.AsRef<long>(Counter), value) - value;
		}

		public long Sub(long value)
		{
			return Add(-value);
		}

		public unsafe long AddSat(long value, long max = long.MaxValue)
		{
			long num = *Counter;
			long num2;
			do
			{
				num2 = num;
				num = ((num >= max) ? max : math.min(max, num + value));
				num = Interlocked.CompareExchange(ref UnsafeUtility.AsRef<long>(Counter), num, num2);
			}
			while (num2 != num && num2 != max);
			return num2;
		}

		public unsafe long SubSat(long value, long min = long.MinValue)
		{
			long num = *Counter;
			long num2;
			do
			{
				num2 = num;
				num = ((num <= min) ? min : math.max(min, num - value));
				num = Interlocked.CompareExchange(ref UnsafeUtility.AsRef<long>(Counter), num, num2);
			}
			while (num2 != num && num2 != min);
			return num2;
		}
	}
	[DebuggerDisplay("Length = {Length}, IsCreated = {IsCreated}")]
	[DebuggerTypeProxy(typeof(UnsafeBitArrayDebugView))]
	[GenerateTestsForBurstCompatibility]
	public struct UnsafeBitArray : INativeDisposable, IDisposable
	{
		public struct ReadOnly
		{
			[NativeDisableUnsafePtrRestriction]
			public unsafe readonly ulong* Ptr;

			public readonly int Length;

			public unsafe readonly bool IsCreated => Ptr != null;

			public readonly bool IsEmpty
			{
				get
				{
					if (IsCreated)
					{
						return Length == 0;
					}
					return true;
				}
			}

			internal unsafe ReadOnly(ulong* ptr, int length)
			{
				Ptr = ptr;
				Length = length;
			}

			public unsafe readonly ulong GetBits(int pos, int numBits = 1)
			{
				return Bitwise.GetBits(Ptr, Length, pos, numBits);
			}

			public unsafe readonly bool IsSet(int pos)
			{
				return Bitwise.IsSet(Ptr, pos);
			}

			public unsafe readonly int Find(int pos, int numBits)
			{
				int count = Length - pos;
				return Bitwise.Find(Ptr, pos, count, numBits);
			}

			public unsafe readonly int Find(int pos, int count, int numBits)
			{
				return Bitwise.Find(Ptr, pos, count, numBits);
			}

			public unsafe readonly bool TestNone(int pos, int numBits = 1)
			{
				return Bitwise.TestNone(Ptr, pos, numBits);
			}

			public unsafe readonly bool TestAny(int pos, int numBits = 1)
			{
				return Bitwise.TestAny(Ptr, Length, pos, numBits);
			}

			public unsafe readonly bool TestAll(int pos, int numBits = 1)
			{
				return Bitwise.TestAll(Ptr, Length, pos, numBits);
			}

			public unsafe readonly int CountBits(int pos, int numBits = 1)
			{
				return Bitwise.CountBits(Ptr, Length, pos, numBits);
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private readonly void CheckArgs(int pos, int numBits)
			{
				if (pos < 0 || pos >= Length || numBits < 1)
				{
					throw new ArgumentException($"BitArray invalid arguments: pos {pos} (must be 0-{Length - 1}), numBits {numBits} (must be greater than 0).");
				}
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private readonly void CheckArgsPosCount(int begin, int count, int numBits)
			{
				if (begin < 0 || begin >= Length)
				{
					throw new ArgumentException($"BitArray invalid argument: begin {begin} (must be 0-{Length - 1}).");
				}
				if (count < 0 || count > Length)
				{
					throw new ArgumentException($"BitArray invalid argument: count {count} (must be 0-{Length}).");
				}
				if (numBits < 1 || count < numBits)
				{
					throw new ArgumentException($"BitArray invalid argument: numBits {numBits} (must be greater than 0).");
				}
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private readonly void CheckArgsUlong(int pos, int numBits)
			{
				if (numBits < 1 || numBits > 64)
				{
					throw new ArgumentException($"BitArray invalid arguments: numBits {numBits} (must be 1-64).");
				}
				if (pos + numBits > Length)
				{
					throw new ArgumentException($"BitArray invalid arguments: Out of bounds pos {pos}, numBits {numBits}, Length {Length}.");
				}
			}
		}

		[NativeDisableUnsafePtrRestriction]
		public unsafe ulong* Ptr;

		public int Length;

		public int Capacity;

		public AllocatorManager.AllocatorHandle Allocator;

		public unsafe readonly bool IsCreated => Ptr != null;

		public readonly bool IsEmpty
		{
			get
			{
				if (IsCreated)
				{
					return Length == 0;
				}
				return true;
			}
		}

		public unsafe UnsafeBitArray(void* ptr, int sizeInBytes, AllocatorManager.AllocatorHandle allocator = default(AllocatorManager.AllocatorHandle))
		{
			Ptr = (ulong*)ptr;
			Length = sizeInBytes * 8;
			Capacity = sizeInBytes * 8;
			Allocator = allocator;
		}

		public unsafe UnsafeBitArray(int numBits, AllocatorManager.AllocatorHandle allocator, NativeArrayOptions options = NativeArrayOptions.ClearMemory)
		{
			Allocator = allocator;
			Ptr = null;
			Length = 0;
			Capacity = 0;
			Resize(numBits, options);
		}

		internal unsafe static UnsafeBitArray* Alloc(AllocatorManager.AllocatorHandle allocator)
		{
			return (UnsafeBitArray*)Memory.Unmanaged.Allocate(sizeof(UnsafeBitArray), UnsafeUtility.AlignOf<UnsafeBitArray>(), allocator);
		}

		internal unsafe static void Free(UnsafeBitArray* data, AllocatorManager.AllocatorHandle allocator)
		{
			if (data == null)
			{
				throw new InvalidOperationException("UnsafeBitArray has yet to be created or has been destroyed!");
			}
			data->Dispose();
			Memory.Unmanaged.Free(data, allocator);
		}

		private unsafe void Realloc(int capacityInBits)
		{
			int num = Bitwise.AlignUp(capacityInBits, 64);
			int num2 = num / 8;
			ulong* ptr = null;
			if (num2 > 0)
			{
				ptr = (ulong*)Memory.Unmanaged.Allocate(num2, 16, Allocator);
				if (Capacity > 0)
				{
					int num3 = math.min(num, Capacity) / 8;
					UnsafeUtility.MemCpy(ptr, Ptr, num3);
				}
			}
			Memory.Unmanaged.Free(Ptr, Allocator);
			Ptr = ptr;
			Capacity = num;
			Length = math.min(Length, num);
		}

		public void Resize(int numBits, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory)
		{
			int num = math.max(numBits, 1);
			if (num > Capacity)
			{
				SetCapacity(num);
			}
			int length = Length;
			Length = numBits;
			if (options == NativeArrayOptions.ClearMemory && length < Length)
			{
				SetBits(length, value: false, Length - length);
			}
		}

		public void SetCapacity(int capacityInBits)
		{
			if (Capacity != capacityInBits)
			{
				Realloc(capacityInBits);
			}
		}

		public void TrimExcess()
		{
			SetCapacity(Length);
		}

		public unsafe void Dispose()
		{
			if (IsCreated)
			{
				if (CollectionHelper.ShouldDeallocate(Allocator))
				{
					Memory.Unmanaged.Free(Ptr, Allocator);
					Allocator = AllocatorManager.Invalid;
				}
				Ptr = null;
				Length = 0;
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			if (CollectionHelper.ShouldDeallocate(Allocator))
			{
				JobHandle result = new UnsafeDisposeJob
				{
					Ptr = Ptr,
					Allocator = Allocator
				}.Schedule(inputDeps);
				Ptr = null;
				Allocator = AllocatorManager.Invalid;
				return result;
			}
			Ptr = null;
			return inputDeps;
		}

		public unsafe void Clear()
		{
			int num = Bitwise.AlignUp(Length, 64) / 8;
			UnsafeUtility.MemClear(Ptr, num);
		}

		public unsafe static void Set(ulong* ptr, int pos, bool value)
		{
			int num = pos >> 6;
			int num2 = pos & 0x3F;
			ulong num3 = (ulong)(1L << num2);
			ulong num4 = (ptr[num] & ~num3) | ((ulong)(-Bitwise.FromBool(value)) & num3);
			ptr[num] = num4;
		}

		public unsafe void Set(int pos, bool value)
		{
			Set(Ptr, pos, value);
		}

		public unsafe void SetBits(int pos, bool value, int numBits)
		{
			int num = math.min(pos + numBits, Length);
			int num2 = pos >> 6;
			int num3 = pos & 0x3F;
			int num4 = num - 1 >> 6;
			int num5 = num & 0x3F;
			ulong num6 = (ulong)(-1L << num3);
			ulong num7 = ulong.MaxValue >> 64 - num5;
			ulong num8 = (ulong)(-Bitwise.FromBool(value));
			ulong num9 = num6 & num8;
			ulong num10 = num7 & num8;
			ulong num11 = ~num6;
			ulong num12 = ~num7;
			if (num2 == num4)
			{
				ulong num13 = ~(num6 & num7);
				ulong num14 = num9 & num10;
				Ptr[num2] = (Ptr[num2] & num13) | num14;
				return;
			}
			Ptr[num2] = (Ptr[num2] & num11) | num9;
			for (int i = num2 + 1; i < num4; i++)
			{
				Ptr[i] = num8;
			}
			Ptr[num4] = (Ptr[num4] & num12) | num10;
		}

		public unsafe void SetBits(int pos, ulong value, int numBits = 1)
		{
			int num = pos >> 6;
			int num2 = pos & 0x3F;
			if (num2 + numBits <= 64)
			{
				ulong mask = ulong.MaxValue >> 64 - numBits;
				Ptr[num] = Bitwise.ReplaceBits(Ptr[num], num2, mask, value);
				return;
			}
			int num3 = math.min(pos + numBits, Length);
			int num4 = num3 - 1 >> 6;
			int num5 = num3 & 0x3F;
			ulong mask2 = ulong.MaxValue >> num2;
			Ptr[num] = Bitwise.ReplaceBits(Ptr[num], num2, mask2, value);
			ulong value2 = value >> 64 - num2;
			ulong mask3 = ulong.MaxValue >> 64 - num5;
			Ptr[num4] = Bitwise.ReplaceBits(Ptr[num4], 0, mask3, value2);
		}

		public unsafe ulong GetBits(int pos, int numBits = 1)
		{
			return Bitwise.GetBits(Ptr, Length, pos, numBits);
		}

		public unsafe bool IsSet(int pos)
		{
			return Bitwise.IsSet(Ptr, pos);
		}

		internal void CopyUlong(int dstPos, ref UnsafeBitArray srcBitArray, int srcPos, int numBits)
		{
			SetBits(dstPos, srcBitArray.GetBits(srcPos, numBits), numBits);
		}

		public void Copy(int dstPos, int srcPos, int numBits)
		{
			if (dstPos != srcPos)
			{
				Copy(dstPos, ref this, srcPos, numBits);
			}
		}

		public unsafe void Copy(int dstPos, ref UnsafeBitArray srcBitArray, int srcPos, int numBits)
		{
			if (numBits == 0)
			{
				return;
			}
			if (numBits <= 64)
			{
				CopyUlong(dstPos, ref srcBitArray, srcPos, numBits);
			}
			else if (numBits <= 128)
			{
				CopyUlong(dstPos, ref srcBitArray, srcPos, 64);
				numBits -= 64;
				if (numBits > 0)
				{
					CopyUlong(dstPos + 64, ref srcBitArray, srcPos + 64, numBits);
				}
			}
			else if ((dstPos & 7) == (srcPos & 7))
			{
				int num = CollectionHelper.Align(dstPos, 8) >> 3;
				int num2 = CollectionHelper.Align(srcPos, 8) >> 3;
				int num3 = num * 8 - dstPos;
				if (num3 > 0)
				{
					CopyUlong(dstPos, ref srcBitArray, srcPos, num3);
				}
				int num4 = numBits - num3;
				int num5 = num4 / 8;
				if (num5 > 0)
				{
					UnsafeUtility.MemMove((byte*)Ptr + num, (byte*)srcBitArray.Ptr + num2, num5);
				}
				int num6 = num4 & 7;
				if (num6 > 0)
				{
					CopyUlong((num + num5) * 8, ref srcBitArray, (num2 + num5) * 8, num6);
				}
			}
			else
			{
				int num7 = CollectionHelper.Align(dstPos, 64) - dstPos;
				if (num7 > 0)
				{
					CopyUlong(dstPos, ref srcBitArray, srcPos, num7);
					numBits -= num7;
					dstPos += num7;
					srcPos += num7;
				}
				while (numBits >= 64)
				{
					Ptr[dstPos >> 6] = srcBitArray.GetBits(srcPos, 64);
					numBits -= 64;
					dstPos += 64;
					srcPos += 64;
				}
				if (numBits > 0)
				{
					CopyUlong(dstPos, ref srcBitArray, srcPos, numBits);
				}
			}
		}

		public unsafe int Find(int pos, int numBits)
		{
			int count = Length - pos;
			return Bitwise.Find(Ptr, pos, count, numBits);
		}

		public unsafe int Find(int pos, int count, int numBits)
		{
			return Bitwise.Find(Ptr, pos, count, numBits);
		}

		public unsafe bool TestNone(int pos, int numBits = 1)
		{
			return Bitwise.TestNone(Ptr, Length, pos, numBits);
		}

		public unsafe bool TestAny(int pos, int numBits = 1)
		{
			return Bitwise.TestAny(Ptr, Length, pos, numBits);
		}

		public unsafe bool TestAll(int pos, int numBits = 1)
		{
			return Bitwise.TestAll(Ptr, Length, pos, numBits);
		}

		public unsafe int CountBits(int pos, int numBits = 1)
		{
			return Bitwise.CountBits(Ptr, Length, pos, numBits);
		}

		public unsafe ReadOnly AsReadOnly()
		{
			return new ReadOnly(Ptr, Length);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckSizeMultipleOf8(int sizeInBytes)
		{
			if ((sizeInBytes & 7) != 0)
			{
				throw new ArgumentException($"BitArray invalid arguments: sizeInBytes {sizeInBytes} (must be multiple of 8-bytes, sizeInBytes: {sizeInBytes}).");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckArgs(int pos, int numBits)
		{
			if (pos < 0 || pos >= Length || numBits < 1)
			{
				throw new ArgumentException($"BitArray invalid arguments: pos {pos} (must be 0-{Length - 1}), numBits {numBits} (must be greater than 0).");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckArgsPosCount(int begin, int count, int numBits)
		{
			if (begin < 0 || begin >= Length)
			{
				throw new ArgumentException($"BitArray invalid argument: begin {begin} (must be 0-{Length - 1}).");
			}
			if (count < 0 || count > Length)
			{
				throw new ArgumentException($"BitArray invalid argument: count {count} (must be 0-{Length}).");
			}
			if (numBits < 1 || count < numBits)
			{
				throw new ArgumentException($"BitArray invalid argument: numBits {numBits} (must be greater than 0).");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckArgsUlong(int pos, int numBits)
		{
			if (numBits < 1 || numBits > 64)
			{
				throw new ArgumentException($"BitArray invalid arguments: numBits {numBits} (must be 1-64).");
			}
			if (pos + numBits > Length)
			{
				throw new ArgumentException($"BitArray invalid arguments: Out of bounds pos {pos}, numBits {numBits}, Length {Length}.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckArgsCopy(ref UnsafeBitArray dstBitArray, int dstPos, ref UnsafeBitArray srcBitArray, int srcPos, int numBits)
		{
			if (srcPos + numBits > srcBitArray.Length)
			{
				throw new ArgumentException($"BitArray invalid arguments: Out of bounds - source position {srcPos}, numBits {numBits}, source bit array Length {srcBitArray.Length}.");
			}
			if (dstPos + numBits > dstBitArray.Length)
			{
				throw new ArgumentException($"BitArray invalid arguments: Out of bounds - destination position {dstPos}, numBits {numBits}, destination bit array Length {dstBitArray.Length}.");
			}
		}
	}
	internal sealed class UnsafeBitArrayDebugView
	{
		private UnsafeBitArray Data;

		public bool[] Bits
		{
			get
			{
				bool[] array = new bool[Data.Length];
				for (int i = 0; i < Data.Length; i++)
				{
					array[i] = Data.IsSet(i);
				}
				return array;
			}
		}

		public UnsafeBitArrayDebugView(UnsafeBitArray data)
		{
			Data = data;
		}
	}
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	internal struct HashMapHelper<TKey> where TKey : unmanaged, IEquatable<TKey>
	{
		internal struct Enumerator
		{
			[NativeDisableUnsafePtrRestriction]
			internal unsafe HashMapHelper<TKey>* m_Data;

			internal int m_Index;

			internal int m_BucketIndex;

			internal int m_NextIndex;

			internal unsafe Enumerator(HashMapHelper<TKey>* data)
			{
				m_Data = data;
				m_Index = -1;
				m_BucketIndex = 0;
				m_NextIndex = -1;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			internal unsafe bool MoveNext()
			{
				return m_Data->MoveNext(ref m_BucketIndex, ref m_NextIndex, out m_Index);
			}

			internal void Reset()
			{
				m_Index = -1;
				m_BucketIndex = 0;
				m_NextIndex = -1;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			internal unsafe KVPair<TKey, TValue> GetCurrent<TValue>() where TValue : unmanaged
			{
				return new KVPair<TKey, TValue>
				{
					m_Data = m_Data,
					m_Index = m_Index
				};
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			internal unsafe TKey GetCurrentKey()
			{
				if (m_Index != -1)
				{
					return m_Data->Keys[m_Index];
				}
				return default(TKey);
			}
		}

		[NativeDisableUnsafePtrRestriction]
		internal unsafe byte* Ptr;

		[NativeDisableUnsafePtrRestriction]
		internal unsafe TKey* Keys;

		[NativeDisableUnsafePtrRestriction]
		internal unsafe int* Next;

		[NativeDisableUnsafePtrRestriction]
		internal unsafe int* Buckets;

		internal int Count;

		internal int Capacity;

		internal int Log2MinGrowth;

		internal int BucketCapacity;

		internal int AllocatedIndex;

		internal int FirstFreeIdx;

		internal int SizeOfTValue;

		internal AllocatorManager.AllocatorHandle Allocator;

		internal const int kMinimumCapacity = 256;

		internal unsafe readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return Ptr != null;
			}
		}

		internal readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (IsCreated)
				{
					return Count == 0;
				}
				return true;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal int CalcCapacityCeilPow2(int capacity)
		{
			capacity = math.max(math.max(1, Count), capacity);
			return math.ceilpow2(math.max(capacity, 1 << Log2MinGrowth));
		}

		internal static int GetBucketSize(int capacity)
		{
			return capacity * 2;
		}

		internal unsafe void Clear()
		{
			UnsafeUtility.MemSet(Buckets, byte.MaxValue, BucketCapacity * 4);
			UnsafeUtility.MemSet(Next, byte.MaxValue, Capacity * 4);
			Count = 0;
			FirstFreeIdx = -1;
			AllocatedIndex = 0;
		}

		internal unsafe void Init(int capacity, int sizeOfValueT, int minGrowth, AllocatorManager.AllocatorHandle allocator)
		{
			Count = 0;
			Log2MinGrowth = (byte)(32 - math.lzcnt(math.max(1, minGrowth) - 1));
			capacity = CalcCapacityCeilPow2(capacity);
			Capacity = capacity;
			BucketCapacity = GetBucketSize(capacity);
			Allocator = allocator;
			SizeOfTValue = sizeOfValueT;
			int outKeyOffset;
			int outNextOffset;
			int outBucketOffset;
			int num = CalculateDataSize(capacity, BucketCapacity, sizeOfValueT, out outKeyOffset, out outNextOffset, out outBucketOffset);
			Ptr = (byte*)Memory.Unmanaged.Allocate(num, 64, allocator);
			Keys = (TKey*)(Ptr + outKeyOffset);
			Next = (int*)(Ptr + outNextOffset);
			Buckets = (int*)(Ptr + outBucketOffset);
			Clear();
		}

		internal unsafe void Dispose()
		{
			Memory.Unmanaged.Free(Ptr, Allocator);
			Ptr = null;
			Keys = null;
			Next = null;
			Buckets = null;
			Count = 0;
			BucketCapacity = 0;
		}

		internal unsafe static HashMapHelper<TKey>* Alloc(int capacity, int sizeOfValueT, int minGrowth, AllocatorManager.AllocatorHandle allocator)
		{
			HashMapHelper<TKey>* ptr = (HashMapHelper<TKey>*)Memory.Unmanaged.Allocate(sizeof(HashMapHelper<TKey>), UnsafeUtility.AlignOf<HashMapHelper<TKey>>(), allocator);
			ptr->Init(capacity, sizeOfValueT, minGrowth, allocator);
			return ptr;
		}

		internal unsafe static void Free(HashMapHelper<TKey>* data)
		{
			if (data == null)
			{
				throw new InvalidOperationException("Hash based container has yet to be created or has been destroyed!");
			}
			data->Dispose();
			Memory.Unmanaged.Free(data, data->Allocator);
		}

		internal void Resize(int newCapacity)
		{
			newCapacity = math.max(newCapacity, Count);
			int num = math.ceilpow2(GetBucketSize(newCapacity));
			if (Capacity != newCapacity || BucketCapacity != num)
			{
				ResizeExact(newCapacity, num);
			}
		}

		internal unsafe void ResizeExact(int newCapacity, int newBucketCapacity)
		{
			int outKeyOffset;
			int outNextOffset;
			int outBucketOffset;
			int num = CalculateDataSize(newCapacity, newBucketCapacity, SizeOfTValue, out outKeyOffset, out outNextOffset, out outBucketOffset);
			byte* ptr = Ptr;
			TKey* keys = Keys;
			int* next = Next;
			int* buckets = Buckets;
			int bucketCapacity = BucketCapacity;
			Ptr = (byte*)Memory.Unmanaged.Allocate(num, 64, Allocator);
			Keys = (TKey*)(Ptr + outKeyOffset);
			Next = (int*)(Ptr + outNextOffset);
			Buckets = (int*)(Ptr + outBucketOffset);
			Capacity = newCapacity;
			BucketCapacity = newBucketCapacity;
			Clear();
			int i = 0;
			for (int num2 = bucketCapacity; i < num2; i++)
			{
				for (int num3 = buckets[i]; num3 != -1; num3 = next[num3])
				{
					int num4 = TryAdd(in keys[num3]);
					UnsafeUtility.MemCpy(Ptr + SizeOfTValue * num4, ptr + SizeOfTValue * num3, SizeOfTValue);
				}
			}
			Memory.Unmanaged.Free(ptr, Allocator);
		}

		internal void TrimExcess()
		{
			int num = CalcCapacityCeilPow2(Count);
			ResizeExact(num, GetBucketSize(num));
		}

		internal unsafe static int CalculateDataSize(int capacity, int bucketCapacity, int sizeOfTValue, out int outKeyOffset, out int outNextOffset, out int outBucketOffset)
		{
			int num = 4;
			int num2 = sizeOfTValue * capacity;
			int num3 = sizeof(TKey) * capacity;
			int num4 = num * capacity;
			int num5 = num * bucketCapacity;
			int result = num2 + num3 + num4 + num5;
			outKeyOffset = num2;
			outNextOffset = outKeyOffset + num3;
			outBucketOffset = outNextOffset + num4;
			return result;
		}

		internal unsafe readonly int GetCount()
		{
			if (AllocatedIndex <= 0)
			{
				return 0;
			}
			int num = 0;
			for (int num2 = FirstFreeIdx; num2 >= 0; num2 = Next[num2])
			{
				num++;
			}
			return math.min(Capacity, AllocatedIndex) - num;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private int GetBucket(in TKey key)
		{
			return (int)((uint)key.GetHashCode() & (BucketCapacity - 1));
		}

		internal unsafe int TryAdd(in TKey key)
		{
			if (-1 == Find(key))
			{
				if (AllocatedIndex >= Capacity && FirstFreeIdx < 0)
				{
					int newCapacity = CalcCapacityCeilPow2(Capacity + (1 << Log2MinGrowth));
					Resize(newCapacity);
				}
				int num = FirstFreeIdx;
				if (num >= 0)
				{
					FirstFreeIdx = Next[num];
				}
				else
				{
					num = AllocatedIndex++;
				}
				UnsafeUtility.WriteArrayElement(Keys, num, key);
				int bucket = GetBucket(in key);
				Next[num] = Buckets[bucket];
				Buckets[bucket] = num;
				Count++;
				return num;
			}
			return -1;
		}

		internal unsafe int Find(TKey key)
		{
			if (AllocatedIndex > 0)
			{
				int bucket = GetBucket(in key);
				int num = Buckets[bucket];
				if ((uint)num < (uint)Capacity)
				{
					int* next = Next;
					while (!UnsafeUtility.ReadArrayElement<TKey>(Keys, num).Equals(key))
					{
						num = next[num];
						if ((uint)num >= (uint)Capacity)
						{
							return -1;
						}
					}
					return num;
				}
			}
			return -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		internal unsafe bool TryGetValue<TValue>(TKey key, out TValue item) where TValue : unmanaged
		{
			int num = Find(key);
			if (-1 != num)
			{
				item = UnsafeUtility.ReadArrayElement<TValue>(Ptr, num);
				return true;
			}
			item = default(TValue);
			return false;
		}

		internal unsafe int TryRemove(TKey key)
		{
			if (Capacity != 0)
			{
				int num = 0;
				int bucket = GetBucket(in key);
				int num2 = -1;
				int num3 = Buckets[bucket];
				while (num3 >= 0 && num3 < Capacity)
				{
					if (UnsafeUtility.ReadArrayElement<TKey>(Keys, num3).Equals(key))
					{
						num++;
						if (num2 < 0)
						{
							Buckets[bucket] = Next[num3];
						}
						else
						{
							Next[num2] = Next[num3];
						}
						int num4 = Next[num3];
						Next[num3] = FirstFreeIdx;
						FirstFreeIdx = num3;
						num3 = num4;
						break;
					}
					num2 = num3;
					num3 = Next[num3];
				}
				Count -= num;
				if (num == 0)
				{
					return -1;
				}
				return num;
			}
			return -1;
		}

		internal unsafe bool MoveNextSearch(ref int bucketIndex, ref int nextIndex, out int index)
		{
			int i = bucketIndex;
			for (int bucketCapacity = BucketCapacity; i < bucketCapacity; i++)
			{
				int num = Buckets[i];
				if (num != -1)
				{
					index = num;
					bucketIndex = i + 1;
					nextIndex = Next[num];
					return true;
				}
			}
			index = -1;
			bucketIndex = BucketCapacity;
			nextIndex = -1;
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal unsafe bool MoveNext(ref int bucketIndex, ref int nextIndex, out int index)
		{
			if (nextIndex != -1)
			{
				index = nextIndex;
				nextIndex = Next[nextIndex];
				return true;
			}
			return MoveNextSearch(ref bucketIndex, ref nextIndex, out index);
		}

		internal unsafe NativeArray<TKey> GetKeyArray(AllocatorManager.AllocatorHandle allocator)
		{
			NativeArray<TKey> result = CollectionHelper.CreateNativeArray<TKey>(Count, allocator, NativeArrayOptions.UninitializedMemory);
			int i = 0;
			int num = 0;
			int length = result.Length;
			for (int bucketCapacity = BucketCapacity; i < bucketCapacity; i++)
			{
				if (num >= length)
				{
					break;
				}
				for (int num2 = Buckets[i]; num2 != -1; num2 = Next[num2])
				{
					result[num++] = UnsafeUtility.ReadArrayElement<TKey>(Keys, num2);
				}
			}
			return result;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		internal unsafe NativeArray<TValue> GetValueArray<TValue>(AllocatorManager.AllocatorHandle allocator) where TValue : unmanaged
		{
			NativeArray<TValue> result = CollectionHelper.CreateNativeArray<TValue>(Count, allocator, NativeArrayOptions.UninitializedMemory);
			int i = 0;
			int num = 0;
			int length = result.Length;
			for (int bucketCapacity = BucketCapacity; i < bucketCapacity; i++)
			{
				if (num >= length)
				{
					break;
				}
				for (int num2 = Buckets[i]; num2 != -1; num2 = Next[num2])
				{
					result[num++] = UnsafeUtility.ReadArrayElement<TValue>(Ptr, num2);
				}
			}
			return result;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		internal unsafe NativeKeyValueArrays<TKey, TValue> GetKeyValueArrays<TValue>(AllocatorManager.AllocatorHandle allocator) where TValue : unmanaged
		{
			NativeKeyValueArrays<TKey, TValue> result = new NativeKeyValueArrays<TKey, TValue>(Count, allocator, NativeArrayOptions.UninitializedMemory);
			int i = 0;
			int num = 0;
			int length = result.Length;
			for (int bucketCapacity = BucketCapacity; i < bucketCapacity; i++)
			{
				if (num >= length)
				{
					break;
				}
				for (int num2 = Buckets[i]; num2 != -1; num2 = Next[num2])
				{
					result.Keys[num] = UnsafeUtility.ReadArrayElement<TKey>(Keys, num2);
					result.Values[num] = UnsafeUtility.ReadArrayElement<TValue>(Ptr, num2);
					num++;
				}
			}
			return result;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckIndexOutOfBounds(int idx)
		{
			if ((uint)idx >= (uint)Capacity)
			{
				throw new InvalidOperationException($"Internal HashMap error. idx {idx}");
			}
		}
	}
	[DebuggerTypeProxy(typeof(UnsafeHashMapDebuggerTypeProxy<, >))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
	{
		typeof(int),
		typeof(int)
	})]
	public struct UnsafeHashMap<TKey, TValue> : INativeDisposable, IDisposable, IEnumerable<KVPair<TKey, TValue>>, IEnumerable where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
	{
		public struct Enumerator : IEnumerator<KVPair<TKey, TValue>>, IEnumerator, IDisposable
		{
			internal HashMapHelper<TKey>.Enumerator m_Enumerator;

			public KVPair<TKey, TValue> Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Enumerator.GetCurrent<TValue>();
				}
			}

			object IEnumerator.Current => Current;

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				return m_Enumerator.MoveNext();
			}

			public void Reset()
			{
				m_Enumerator.Reset();
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public struct ReadOnly : IEnumerable<KVPair<TKey, TValue>>, IEnumerable
		{
			[NativeDisableUnsafePtrRestriction]
			internal HashMapHelper<TKey> m_Data;

			public readonly bool IsCreated
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data.IsCreated;
				}
			}

			public readonly bool IsEmpty
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data.IsEmpty;
				}
			}

			public readonly int Count
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data.Count;
				}
			}

			public readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data.Capacity;
				}
			}

			public readonly TValue this[TKey key]
			{
				get
				{
					m_Data.TryGetValue<TValue>(key, out var item);
					return item;
				}
			}

			internal ReadOnly(ref HashMapHelper<TKey> data)
			{
				m_Data = data;
			}

			public readonly bool TryGetValue(TKey key, out TValue item)
			{
				return m_Data.TryGetValue<TValue>(key, out item);
			}

			public readonly bool ContainsKey(TKey key)
			{
				return -1 != m_Data.Find(key);
			}

			public readonly NativeArray<TKey> GetKeyArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_Data.GetKeyArray(allocator);
			}

			public readonly NativeArray<TValue> GetValueArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_Data.GetValueArray<TValue>(allocator);
			}

			public readonly NativeKeyValueArrays<TKey, TValue> GetKeyValueArrays(AllocatorManager.AllocatorHandle allocator)
			{
				return m_Data.GetKeyValueArrays<TValue>(allocator);
			}

			public unsafe readonly Enumerator GetEnumerator()
			{
				fixed (HashMapHelper<TKey>* data = &m_Data)
				{
					return new Enumerator
					{
						m_Enumerator = new HashMapHelper<TKey>.Enumerator(data)
					};
				}
			}

			IEnumerator<KVPair<TKey, TValue>> IEnumerable<KVPair<TKey, TValue>>.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				throw new NotImplementedException();
			}
		}

		[NativeDisableUnsafePtrRestriction]
		internal HashMapHelper<TKey> m_Data;

		public readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data.IsCreated;
			}
		}

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data.IsEmpty;
			}
		}

		public readonly int Count
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data.Count;
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return m_Data.Capacity;
			}
			set
			{
				m_Data.Resize(value);
			}
		}

		public unsafe TValue this[TKey key]
		{
			get
			{
				m_Data.TryGetValue<TValue>(key, out var item);
				return item;
			}
			set
			{
				int num = m_Data.Find(key);
				if (-1 != num)
				{
					UnsafeUtility.WriteArrayElement(m_Data.Ptr, num, value);
				}
				else
				{
					TryAdd(key, value);
				}
			}
		}

		public unsafe UnsafeHashMap(int initialCapacity, AllocatorManager.AllocatorHandle allocator)
		{
			m_Data = default(HashMapHelper<TKey>);
			m_Data.Init(initialCapacity, sizeof(TValue), 256, allocator);
		}

		public void Dispose()
		{
			if (IsCreated)
			{
				m_Data.Dispose();
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new UnsafeDisposeJob
			{
				Ptr = m_Data.Ptr,
				Allocator = m_Data.Allocator
			}.Schedule(inputDeps);
			m_Data = default(HashMapHelper<TKey>);
			return result;
		}

		public void Clear()
		{
			m_Data.Clear();
		}

		public unsafe bool TryAdd(TKey key, TValue item)
		{
			int num = m_Data.TryAdd(in key);
			if (-1 != num)
			{
				UnsafeUtility.WriteArrayElement(m_Data.Ptr, num, item);
				return true;
			}
			return false;
		}

		public void Add(TKey key, TValue item)
		{
			TryAdd(key, item);
		}

		public bool Remove(TKey key)
		{
			return -1 != m_Data.TryRemove(key);
		}

		public bool TryGetValue(TKey key, out TValue item)
		{
			return m_Data.TryGetValue<TValue>(key, out item);
		}

		public bool ContainsKey(TKey key)
		{
			return -1 != m_Data.Find(key);
		}

		public void TrimExcess()
		{
			m_Data.TrimExcess();
		}

		public NativeArray<TKey> GetKeyArray(AllocatorManager.AllocatorHandle allocator)
		{
			return m_Data.GetKeyArray(allocator);
		}

		public NativeArray<TValue> GetValueArray(AllocatorManager.AllocatorHandle allocator)
		{
			return m_Data.GetValueArray<TValue>(allocator);
		}

		public NativeKeyValueArrays<TKey, TValue> GetKeyValueArrays(AllocatorManager.AllocatorHandle allocator)
		{
			return m_Data.GetKeyValueArrays<TValue>(allocator);
		}

		public unsafe Enumerator GetEnumerator()
		{
			fixed (HashMapHelper<TKey>* data = &m_Data)
			{
				return new Enumerator
				{
					m_Enumerator = new HashMapHelper<TKey>.Enumerator(data)
				};
			}
		}

		IEnumerator<KVPair<TKey, TValue>> IEnumerable<KVPair<TKey, TValue>>.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		public ReadOnly AsReadOnly()
		{
			return new ReadOnly(ref m_Data);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void ThrowKeyNotPresent(TKey key)
		{
			throw new ArgumentException($"Key: {key} is not present.");
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void ThrowKeyAlreadyAdded(TKey key)
		{
			throw new ArgumentException($"An item with the same key has already been added: {key}");
		}
	}
	internal sealed class UnsafeHashMapDebuggerTypeProxy<TKey, TValue> where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
	{
		private HashMapHelper<TKey> Data;

		public List<Pair<TKey, TValue>> Items
		{
			get
			{
				List<Pair<TKey, TValue>> list = new List<Pair<TKey, TValue>>();
				NativeKeyValueArrays<TKey, TValue> keyValueArrays = Data.GetKeyValueArrays<TValue>(Allocator.Temp);
				try
				{
					for (int i = 0; i < keyValueArrays.Length; i++)
					{
						NativeArray<TKey> keys = keyValueArrays.Keys;
						TKey k = keys[i];
						NativeArray<TValue> values = keyValueArrays.Values;
						list.Add(new Pair<TKey, TValue>(k, values[i]));
					}
					return list;
				}
				finally
				{
					((IDisposable)keyValueArrays/*cast due to .constrained prefix*/).Dispose();
				}
			}
		}

		public UnsafeHashMapDebuggerTypeProxy(UnsafeHashMap<TKey, TValue> target)
		{
			Data = target.m_Data;
		}

		public UnsafeHashMapDebuggerTypeProxy(UnsafeHashMap<TKey, TValue>.ReadOnly target)
		{
			Data = target.m_Data;
		}
	}
	[DebuggerTypeProxy(typeof(UnsafeHashSetDebuggerTypeProxy<>))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct UnsafeHashSet<T> : INativeDisposable, IDisposable, IEnumerable<T>, IEnumerable where T : unmanaged, IEquatable<T>
	{
		public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
		{
			internal HashMapHelper<T>.Enumerator m_Enumerator;

			public unsafe T Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Enumerator.m_Data->Keys[m_Enumerator.m_Index];
				}
			}

			object IEnumerator.Current => Current;

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				return m_Enumerator.MoveNext();
			}

			public void Reset()
			{
				m_Enumerator.Reset();
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ReadOnly : IEnumerable<T>, IEnumerable
		{
			internal HashMapHelper<T> m_Data;

			public readonly bool IsCreated
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data.IsCreated;
				}
			}

			public readonly bool IsEmpty
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data.IsEmpty;
				}
			}

			public readonly int Count
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data.Count;
				}
			}

			public readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data.Capacity;
				}
			}

			internal ReadOnly(ref HashMapHelper<T> data)
			{
				m_Data = data;
			}

			public readonly bool Contains(T item)
			{
				return -1 != m_Data.Find(item);
			}

			public readonly NativeArray<T> ToNativeArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_Data.GetKeyArray(allocator);
			}

			public unsafe readonly Enumerator GetEnumerator()
			{
				fixed (HashMapHelper<T>* data = &m_Data)
				{
					return new Enumerator
					{
						m_Enumerator = new HashMapHelper<T>.Enumerator(data)
					};
				}
			}

			IEnumerator<T> IEnumerable<T>.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				throw new NotImplementedException();
			}
		}

		internal HashMapHelper<T> m_Data;

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (IsCreated)
				{
					return m_Data.IsEmpty;
				}
				return true;
			}
		}

		public readonly int Count
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data.Count;
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return m_Data.Capacity;
			}
			set
			{
				m_Data.Resize(value);
			}
		}

		public readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data.IsCreated;
			}
		}

		public UnsafeHashSet(int initialCapacity, AllocatorManager.AllocatorHandle allocator)
		{
			m_Data = default(HashMapHelper<T>);
			m_Data.Init(initialCapacity, 0, 256, allocator);
		}

		public void Dispose()
		{
			if (IsCreated)
			{
				m_Data.Dispose();
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new UnsafeDisposeJob
			{
				Ptr = m_Data.Ptr,
				Allocator = m_Data.Allocator
			}.Schedule(inputDeps);
			m_Data.Ptr = null;
			return result;
		}

		public void Clear()
		{
			m_Data.Clear();
		}

		public bool Add(T item)
		{
			return -1 != m_Data.TryAdd(in item);
		}

		public bool Remove(T item)
		{
			return -1 != m_Data.TryRemove(item);
		}

		public bool Contains(T item)
		{
			return -1 != m_Data.Find(item);
		}

		public void TrimExcess()
		{
			m_Data.TrimExcess();
		}

		public NativeArray<T> ToNativeArray(AllocatorManager.AllocatorHandle allocator)
		{
			return m_Data.GetKeyArray(allocator);
		}

		public unsafe Enumerator GetEnumerator()
		{
			fixed (HashMapHelper<T>* data = &m_Data)
			{
				return new Enumerator
				{
					m_Enumerator = new HashMapHelper<T>.Enumerator(data)
				};
			}
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		public ReadOnly AsReadOnly()
		{
			return new ReadOnly(ref m_Data);
		}
	}
	internal sealed class UnsafeHashSetDebuggerTypeProxy<T> where T : unmanaged, IEquatable<T>
	{
		private HashMapHelper<T> Data;

		public List<T> Items
		{
			get
			{
				List<T> list = new List<T>();
				using NativeArray<T> nativeArray = Data.GetKeyArray(Allocator.Temp);
				for (int i = 0; i < nativeArray.Length; i++)
				{
					list.Add(nativeArray[i]);
				}
				return list;
			}
		}

		public UnsafeHashSetDebuggerTypeProxy(UnsafeHashSet<T> data)
		{
			Data = data.m_Data;
		}
	}
	[BurstCompile]
	internal struct UnsafeDisposeJob : IJob
	{
		[NativeDisableUnsafePtrRestriction]
		public unsafe void* Ptr;

		public AllocatorManager.AllocatorHandle Allocator;

		public unsafe void Execute()
		{
			AllocatorManager.Free(Allocator, Ptr);
		}
	}
	internal struct UntypedUnsafeList
	{
		[NativeDisableUnsafePtrRestriction]
		internal unsafe readonly void* Ptr;

		internal readonly int m_length;

		internal readonly int m_capacity;

		internal readonly AllocatorManager.AllocatorHandle Allocator;

		internal readonly int padding;
	}
	[DebuggerDisplay("Length = {Length}, Capacity = {Capacity}, IsCreated = {IsCreated}, IsEmpty = {IsEmpty}")]
	[DebuggerTypeProxy(typeof(UnsafeListTDebugView<>))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct UnsafeList<T> : INativeDisposable, IDisposable, INativeList<T>, IIndexable<T>, IEnumerable<T>, IEnumerable where T : unmanaged
	{
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ReadOnly : IEnumerable<T>, IEnumerable
		{
			[NativeDisableUnsafePtrRestriction]
			public unsafe readonly T* Ptr;

			public readonly int Length;

			public unsafe readonly bool IsCreated
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return Ptr != null;
				}
			}

			public readonly bool IsEmpty
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					if (IsCreated)
					{
						return Length == 0;
					}
					return true;
				}
			}

			internal unsafe ReadOnly(T* ptr, int length)
			{
				Ptr = ptr;
				Length = length;
			}

			public unsafe Enumerator GetEnumerator()
			{
				return new Enumerator
				{
					m_Ptr = Ptr,
					m_Length = Length,
					m_Index = -1
				};
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			IEnumerator<T> IEnumerable<T>.GetEnumerator()
			{
				throw new NotImplementedException();
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ParallelReader
		{
			[NativeDisableUnsafePtrRestriction]
			public unsafe readonly T* Ptr;

			public readonly int Length;

			internal unsafe ParallelReader(T* ptr, int length)
			{
				Ptr = ptr;
				Length = length;
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ParallelWriter
		{
			[NativeDisableUnsafePtrRestriction]
			public unsafe UnsafeList<T>* ListData;

			public unsafe readonly void* Ptr
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return ListData->Ptr;
				}
			}

			internal unsafe ParallelWriter(UnsafeList<T>* listData)
			{
				ListData = listData;
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public unsafe void AddNoResize(T value)
			{
				int index = Interlocked.Increment(ref ListData->m_length) - 1;
				UnsafeUtility.WriteArrayElement(ListData->Ptr, index, value);
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public unsafe void AddRangeNoResize(void* ptr, int count)
			{
				int num = Interlocked.Add(ref ListData->m_length, count) - count;
				void* destination = (byte*)ListData->Ptr + num * sizeof(T);
				UnsafeUtility.MemCpy(destination, ptr, count * sizeof(T));
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public unsafe void AddRangeNoResize(UnsafeList<T> list)
			{
				AddRangeNoResize(list.Ptr, list.Length);
			}
		}

		public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
		{
			internal unsafe T* m_Ptr;

			internal int m_Length;

			internal int m_Index;

			public unsafe T Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Ptr[m_Index];
				}
			}

			object IEnumerator.Current => Current;

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				return ++m_Index < m_Length;
			}

			public void Reset()
			{
				m_Index = -1;
			}
		}

		[NativeDisableUnsafePtrRestriction]
		public unsafe T* Ptr;

		public int m_length;

		public int m_capacity;

		public AllocatorManager.AllocatorHandle Allocator;

		private readonly int padding;

		public int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return CollectionHelper.AssumePositive(m_length);
			}
			set
			{
				if (value > Capacity)
				{
					Resize(value);
				}
				else
				{
					m_length = value;
				}
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return CollectionHelper.AssumePositive(m_capacity);
			}
			set
			{
				SetCapacity(value);
			}
		}

		public unsafe T this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return Ptr[CollectionHelper.AssumePositive(index)];
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				Ptr[CollectionHelper.AssumePositive(index)] = value;
			}
		}

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (IsCreated)
				{
					return m_length == 0;
				}
				return true;
			}
		}

		public unsafe readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return Ptr != null;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe ref T ElementAt(int index)
		{
			return ref Ptr[CollectionHelper.AssumePositive(index)];
		}

		public unsafe UnsafeList(T* ptr, int length)
		{
			this = default(UnsafeList<T>);
			Ptr = ptr;
			m_length = length;
			m_capacity = length;
			Allocator = AllocatorManager.None;
		}

		public unsafe UnsafeList(int initialCapacity, AllocatorManager.AllocatorHandle allocator, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory)
		{
			Ptr = null;
			m_length = 0;
			m_capacity = 0;
			Allocator = allocator;
			padding = 0;
			SetCapacity(math.max(initialCapacity, 1));
			if (options == NativeArrayOptions.ClearMemory && Ptr != null)
			{
				int num = sizeof(T);
				UnsafeUtility.MemClear(Ptr, Capacity * num);
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(AllocatorManager.AllocatorHandle) })]
		internal unsafe static UnsafeList<T>* Create<U>(int initialCapacity, ref U allocator, NativeArrayOptions options) where U : unmanaged, AllocatorManager.IAllocator
		{
			UnsafeList<T>* intPtr = AllocatorManager.Allocate(ref allocator, default(UnsafeList<T>), 1);
			*intPtr = new UnsafeList<T>(initialCapacity, allocator.Handle, options);
			return intPtr;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(AllocatorManager.AllocatorHandle) })]
		internal unsafe static void Destroy<U>(UnsafeList<T>* listData, ref U allocator) where U : unmanaged, AllocatorManager.IAllocator
		{
			listData->Dispose(ref allocator);
			AllocatorManager.Free(ref allocator, listData, sizeof(UnsafeList<T>), UnsafeUtility.AlignOf<UnsafeList<T>>(), 1);
		}

		public unsafe static UnsafeList<T>* Create(int initialCapacity, AllocatorManager.AllocatorHandle allocator, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory)
		{
			UnsafeList<T>* intPtr = AllocatorManager.Allocate<UnsafeList<T>>(allocator);
			*intPtr = new UnsafeList<T>(initialCapacity, allocator, options);
			return intPtr;
		}

		public unsafe static void Destroy(UnsafeList<T>* listData)
		{
			AllocatorManager.AllocatorHandle allocator = listData->Allocator;
			listData->Dispose();
			AllocatorManager.Free(allocator, listData);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(AllocatorManager.AllocatorHandle) })]
		internal unsafe void Dispose<U>(ref U allocator) where U : unmanaged, AllocatorManager.IAllocator
		{
			AllocatorManager.Free(ref allocator, Ptr, m_capacity);
			Ptr = null;
			m_length = 0;
			m_capacity = 0;
		}

		public unsafe void Dispose()
		{
			if (IsCreated)
			{
				if (CollectionHelper.ShouldDeallocate(Allocator))
				{
					AllocatorManager.Free(Allocator, Ptr, m_capacity);
					Allocator = AllocatorManager.Invalid;
				}
				Ptr = null;
				m_length = 0;
				m_capacity = 0;
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			if (CollectionHelper.ShouldDeallocate(Allocator))
			{
				JobHandle result = new UnsafeDisposeJob
				{
					Ptr = Ptr,
					Allocator = Allocator
				}.Schedule(inputDeps);
				Ptr = null;
				Allocator = AllocatorManager.Invalid;
				return result;
			}
			Ptr = null;
			return inputDeps;
		}

		public void Clear()
		{
			m_length = 0;
		}

		public unsafe void Resize(int length, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory)
		{
			int length2 = m_length;
			if (length > Capacity)
			{
				SetCapacity(length);
			}
			m_length = length;
			if (options == NativeArrayOptions.ClearMemory && length2 < length)
			{
				int num = length - length2;
				byte* ptr = (byte*)Ptr;
				int num2 = sizeof(T);
				UnsafeUtility.MemClear(ptr + length2 * num2, num * num2);
			}
		}

		private unsafe void ResizeExact<U>(ref U allocator, int newCapacity) where U : unmanaged, AllocatorManager.IAllocator
		{
			newCapacity = math.max(0, newCapacity);
			T* ptr = null;
			int alignOf = UnsafeUtility.AlignOf<T>();
			int num = sizeof(T);
			if (newCapacity > 0)
			{
				ptr = (T*)AllocatorManager.Allocate(ref allocator, num, alignOf, newCapacity);
				if (Ptr != null && m_capacity > 0)
				{
					int num2 = math.min(newCapacity, Capacity) * num;
					UnsafeUtility.MemCpy(ptr, Ptr, num2);
				}
			}
			AllocatorManager.Free(ref allocator, Ptr, Capacity);
			Ptr = ptr;
			m_capacity = newCapacity;
			m_length = math.min(m_length, newCapacity);
		}

		private void ResizeExact(int capacity)
		{
			ResizeExact(ref Allocator, capacity);
		}

		private unsafe void SetCapacity<U>(ref U allocator, int capacity) where U : unmanaged, AllocatorManager.IAllocator
		{
			int num = sizeof(T);
			int x = math.max(capacity, 64 / num);
			x = math.ceilpow2(x);
			if (x != Capacity)
			{
				ResizeExact(ref allocator, x);
			}
		}

		public void SetCapacity(int capacity)
		{
			SetCapacity(ref Allocator, capacity);
		}

		public void TrimExcess()
		{
			if (Capacity != m_length)
			{
				ResizeExact(m_length);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe void AddNoResize(T value)
		{
			UnsafeUtility.WriteArrayElement(Ptr, m_length, value);
			m_length++;
		}

		public unsafe void AddRangeNoResize(void* ptr, int count)
		{
			int num = sizeof(T);
			void* destination = (byte*)Ptr + m_length * num;
			UnsafeUtility.MemCpy(destination, ptr, count * num);
			m_length += count;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe void AddRangeNoResize(UnsafeList<T> list)
		{
			AddRangeNoResize(list.Ptr, CollectionHelper.AssumePositive(list.Length));
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe void Add(in T value)
		{
			int length = m_length;
			if (m_length < m_capacity)
			{
				Ptr[length] = value;
				m_length++;
			}
			else
			{
				Resize(length + 1);
				Ptr[length] = value;
			}
		}

		public unsafe void AddRange(void* ptr, int count)
		{
			int length = m_length;
			if (m_length + count > Capacity)
			{
				Resize(m_length + count);
			}
			else
			{
				m_length += count;
			}
			int num = sizeof(T);
			void* destination = (byte*)Ptr + length * num;
			UnsafeUtility.MemCpy(destination, ptr, count * num);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe void AddRange(UnsafeList<T> list)
		{
			AddRange(list.Ptr, list.Length);
		}

		public unsafe void AddReplicate(in T value, int count)
		{
			int length = m_length;
			if (m_length + count > Capacity)
			{
				Resize(m_length + count);
			}
			else
			{
				m_length += count;
			}
			fixed (T* ptr = &value)
			{
				void* source = ptr;
				UnsafeUtility.MemCpyReplicate(Ptr + length, source, UnsafeUtility.SizeOf<T>(), count);
			}
		}

		public unsafe void InsertRangeWithBeginEnd(int begin, int end)
		{
			begin = CollectionHelper.AssumePositive(begin);
			end = CollectionHelper.AssumePositive(end);
			int num = end - begin;
			if (num >= 1)
			{
				int length = m_length;
				if (m_length + num > Capacity)
				{
					Resize(m_length + num);
				}
				else
				{
					m_length += num;
				}
				int num2 = length - begin;
				if (num2 >= 1)
				{
					int num3 = sizeof(T);
					int num4 = num2 * num3;
					byte* ptr = (byte*)Ptr;
					byte* destination = ptr + end * num3;
					byte* source = ptr + begin * num3;
					UnsafeUtility.MemMove(destination, source, num4);
				}
			}
		}

		public void InsertRange(int index, int count)
		{
			InsertRangeWithBeginEnd(index, index + count);
		}

		public unsafe void RemoveAtSwapBack(int index)
		{
			index = CollectionHelper.AssumePositive(index);
			int num = m_length - 1;
			T* num2 = Ptr + index;
			T* ptr = Ptr + num;
			*num2 = *ptr;
			m_length--;
		}

		public unsafe void RemoveRangeSwapBack(int index, int count)
		{
			index = CollectionHelper.AssumePositive(index);
			count = CollectionHelper.AssumePositive(count);
			if (count > 0)
			{
				int num = math.max(m_length - count, index + count);
				int num2 = sizeof(T);
				void* destination = (byte*)Ptr + index * num2;
				void* source = (byte*)Ptr + num * num2;
				UnsafeUtility.MemCpy(destination, source, (m_length - num) * num2);
				m_length -= count;
			}
		}

		public unsafe void RemoveAt(int index)
		{
			index = CollectionHelper.AssumePositive(index);
			T* ptr = Ptr + index;
			T* ptr2 = ptr + 1;
			m_length--;
			for (int i = index; i < m_length; i++)
			{
				*(ptr++) = *(ptr2++);
			}
		}

		public unsafe void RemoveRange(int index, int count)
		{
			index = CollectionHelper.AssumePositive(index);
			count = CollectionHelper.AssumePositive(count);
			if (count > 0)
			{
				int num = math.min(index + count, m_length);
				int num2 = sizeof(T);
				void* destination = (byte*)Ptr + index * num2;
				void* source = (byte*)Ptr + num * num2;
				UnsafeUtility.MemCpy(destination, source, (m_length - num) * num2);
				m_length -= count;
			}
		}

		public unsafe ReadOnly AsReadOnly()
		{
			return new ReadOnly(Ptr, Length);
		}

		public unsafe ParallelReader AsParallelReader()
		{
			return new ParallelReader(Ptr, Length);
		}

		public unsafe ParallelWriter AsParallelWriter()
		{
			return new ParallelWriter((UnsafeList<T>*)UnsafeUtility.AddressOf(ref this));
		}

		public unsafe void CopyFrom(in NativeArray<T> other)
		{
			Resize(other.Length);
			UnsafeUtility.MemCpy(Ptr, other.GetUnsafeReadOnlyPtr(), UnsafeUtility.SizeOf<T>() * other.Length);
		}

		public unsafe void CopyFrom(in UnsafeList<T> other)
		{
			Resize(other.Length);
			UnsafeUtility.MemCpy(Ptr, other.Ptr, UnsafeUtility.SizeOf<T>() * other.Length);
		}

		public unsafe Enumerator GetEnumerator()
		{
			return new Enumerator
			{
				m_Ptr = Ptr,
				m_Length = Length,
				m_Index = -1
			};
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		internal unsafe static void CheckNull(void* listData)
		{
			if (listData == null)
			{
				throw new InvalidOperationException("UnsafeList has yet to be created or has been destroyed!");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckIndexCount(int index, int count)
		{
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException($"Value for count {count} must be positive.");
			}
			if (index < 0)
			{
				throw new IndexOutOfRangeException($"Value for index {index} must be positive.");
			}
			if (index > Length)
			{
				throw new IndexOutOfRangeException($"Value for index {index} is out of bounds.");
			}
			if (index + count > Length)
			{
				throw new ArgumentOutOfRangeException($"Value for count {count} is out of bounds.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckBeginEndNoLength(int begin, int end)
		{
			if (begin > end)
			{
				throw new ArgumentException($"Value for begin {begin} index must less or equal to end {end}.");
			}
			if (begin < 0)
			{
				throw new ArgumentOutOfRangeException($"Value for begin {begin} must be positive.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckBeginEnd(int begin, int end)
		{
			if (begin > Length)
			{
				throw new ArgumentOutOfRangeException($"Value for begin {begin} is out of bounds.");
			}
			if (end > Length)
			{
				throw new ArgumentOutOfRangeException($"Value for end {end} is out of bounds.");
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckNoResizeHasEnoughCapacity(int length)
		{
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckNoResizeHasEnoughCapacity(int length, int index)
		{
			if (Capacity < index + length)
			{
				throw new InvalidOperationException($"AddNoResize assumes that list capacity is sufficient (Capacity {Capacity}, Length {Length}), requested length {length}!");
			}
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class UnsafeListExtensions
	{
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static int IndexOf<T, U>(this UnsafeList<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			return NativeArrayExtensions.IndexOf<T, U>(list.Ptr, list.Length, value);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool Contains<T, U>(this UnsafeList<T> list, U value) where T : unmanaged, IEquatable<U>
		{
			return list.IndexOf(value) != -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static int IndexOf<T, U>(this UnsafeList<T>.ReadOnly list, U value) where T : unmanaged, IEquatable<U>
		{
			return NativeArrayExtensions.IndexOf<T, U>(list.Ptr, list.Length, value);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool Contains<T, U>(this UnsafeList<T>.ReadOnly list, U value) where T : unmanaged, IEquatable<U>
		{
			return list.IndexOf(value) != -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public unsafe static int IndexOf<T, U>(this UnsafeList<T>.ParallelReader list, U value) where T : unmanaged, IEquatable<U>
		{
			return NativeArrayExtensions.IndexOf<T, U>(list.Ptr, list.Length, value);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public static bool Contains<T, U>(this UnsafeList<T>.ParallelReader list, U value) where T : unmanaged, IEquatable<U>
		{
			return list.IndexOf(value) != -1;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static bool ArraysEqual<T>(this UnsafeList<T> container, in UnsafeList<T> other) where T : unmanaged, IEquatable<T>
		{
			if (container.Length != other.Length)
			{
				return false;
			}
			for (int i = 0; i != container.Length; i++)
			{
				if (!container[i].Equals(other[i]))
				{
					return false;
				}
			}
			return true;
		}
	}
	internal sealed class UnsafeListTDebugView<T> where T : unmanaged
	{
		private UnsafeList<T> Data;

		public unsafe T[] Items
		{
			get
			{
				T[] array = new T[Data.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = Data.Ptr[i];
				}
				return array;
			}
		}

		public UnsafeListTDebugView(UnsafeList<T> data)
		{
			Data = data;
		}
	}
	[DebuggerDisplay("Length = {Length}, Capacity = {Capacity}, IsCreated = {IsCreated}, IsEmpty = {IsEmpty}")]
	[DebuggerTypeProxy(typeof(UnsafePtrListDebugView<>))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct UnsafePtrList<T> : INativeDisposable, IDisposable, IEnumerable<IntPtr>, IEnumerable where T : unmanaged
	{
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ReadOnly
		{
			[NativeDisableUnsafePtrRestriction]
			public unsafe readonly T** Ptr;

			public readonly int Length;

			public unsafe readonly bool IsCreated
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return Ptr != null;
				}
			}

			public readonly bool IsEmpty
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					if (IsCreated)
					{
						return Length == 0;
					}
					return true;
				}
			}

			internal unsafe ReadOnly(T** ptr, int length)
			{
				Ptr = ptr;
				Length = length;
			}

			public unsafe int IndexOf(void* ptr)
			{
				for (int i = 0; i < Length; i++)
				{
					if (Ptr[i] == ptr)
					{
						return i;
					}
				}
				return -1;
			}

			public unsafe bool Contains(void* ptr)
			{
				return IndexOf(ptr) != -1;
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ParallelReader
		{
			[NativeDisableUnsafePtrRestriction]
			public unsafe readonly T** Ptr;

			public readonly int Length;

			internal unsafe ParallelReader(T** ptr, int length)
			{
				Ptr = ptr;
				Length = length;
			}

			public unsafe int IndexOf(void* ptr)
			{
				for (int i = 0; i < Length; i++)
				{
					if (Ptr[i] == ptr)
					{
						return i;
					}
				}
				return -1;
			}

			public unsafe bool Contains(void* ptr)
			{
				return IndexOf(ptr) != -1;
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ParallelWriter
		{
			[NativeDisableUnsafePtrRestriction]
			public unsafe readonly T** Ptr;

			[NativeDisableUnsafePtrRestriction]
			public unsafe UnsafeList<IntPtr>* ListData;

			internal unsafe ParallelWriter(T** ptr, UnsafeList<IntPtr>* listData)
			{
				Ptr = ptr;
				ListData = listData;
			}

			public unsafe void AddNoResize(T* value)
			{
				ListData->AddNoResize((IntPtr)value);
			}

			public unsafe void AddRangeNoResize(T** ptr, int count)
			{
				ListData->AddRangeNoResize(ptr, count);
			}

			public unsafe void AddRangeNoResize(UnsafePtrList<T> list)
			{
				ListData->AddRangeNoResize(list.Ptr, list.Length);
			}
		}

		[NativeDisableUnsafePtrRestriction]
		public unsafe readonly T** Ptr;

		public readonly int m_length;

		public readonly int m_capacity;

		public readonly AllocatorManager.AllocatorHandle Allocator;

		private readonly int padding;

		public int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return this.ListDataRO().Length;
			}
			set
			{
				UnsafePtrListExtensions.ListData(ref this).Length = value;
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return this.ListDataRO().Capacity;
			}
			set
			{
				UnsafePtrListExtensions.ListData(ref this).Capacity = value;
			}
		}

		public unsafe T* this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return Ptr[CollectionHelper.AssumePositive(index)];
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				Ptr[CollectionHelper.AssumePositive(index)] = value;
			}
		}

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (IsCreated)
				{
					return Length == 0;
				}
				return true;
			}
		}

		public unsafe readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return Ptr != null;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe ref T* ElementAt(int index)
		{
			return ref Ptr[CollectionHelper.AssumePositive(index)];
		}

		public unsafe UnsafePtrList(T** ptr, int length)
		{
			this = default(UnsafePtrList<T>);
			Ptr = ptr;
			m_length = length;
			m_capacity = length;
			Allocator = AllocatorManager.None;
		}

		public unsafe UnsafePtrList(int initialCapacity, AllocatorManager.AllocatorHandle allocator, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory)
		{
			Ptr = null;
			m_length = 0;
			m_capacity = 0;
			padding = 0;
			Allocator = AllocatorManager.None;
			UnsafePtrListExtensions.ListData(ref this) = new UnsafeList<IntPtr>(initialCapacity, allocator, options);
		}

		public unsafe static UnsafePtrList<T>* Create(T** ptr, int length)
		{
			UnsafePtrList<T>* intPtr = AllocatorManager.Allocate<UnsafePtrList<T>>(AllocatorManager.Persistent);
			*intPtr = new UnsafePtrList<T>(ptr, length);
			return intPtr;
		}

		public unsafe static UnsafePtrList<T>* Create(int initialCapacity, AllocatorManager.AllocatorHandle allocator, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory)
		{
			UnsafePtrList<T>* intPtr = AllocatorManager.Allocate<UnsafePtrList<T>>(allocator);
			*intPtr = new UnsafePtrList<T>(initialCapacity, allocator, options);
			return intPtr;
		}

		public unsafe static void Destroy(UnsafePtrList<T>* listData)
		{
			AllocatorManager.AllocatorHandle handle = ((UnsafePtrListExtensions.ListData(ref *listData).Allocator.Value == AllocatorManager.Invalid.Value) ? AllocatorManager.Persistent : UnsafePtrListExtensions.ListData(ref *listData).Allocator);
			listData->Dispose();
			AllocatorManager.Free(handle, listData);
		}

		public void Dispose()
		{
			UnsafePtrListExtensions.ListData(ref this).Dispose();
		}

		public JobHandle Dispose(JobHandle inputDeps)
		{
			return UnsafePtrListExtensions.ListData(ref this).Dispose(inputDeps);
		}

		public void Clear()
		{
			UnsafePtrListExtensions.ListData(ref this).Clear();
		}

		public void Resize(int length, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory)
		{
			UnsafePtrListExtensions.ListData(ref this).Resize(length, options);
		}

		public void SetCapacity(int capacity)
		{
			UnsafePtrListExtensions.ListData(ref this).SetCapacity(capacity);
		}

		public void TrimExcess()
		{
			UnsafePtrListExtensions.ListData(ref this).TrimExcess();
		}

		public unsafe int IndexOf(void* ptr)
		{
			for (int i = 0; i < Length; i++)
			{
				if (Ptr[i] == ptr)
				{
					return i;
				}
			}
			return -1;
		}

		public unsafe bool Contains(void* ptr)
		{
			return IndexOf(ptr) != -1;
		}

		public unsafe void AddNoResize(void* value)
		{
			UnsafePtrListExtensions.ListData(ref this).AddNoResize((IntPtr)value);
		}

		public unsafe void AddRangeNoResize(void** ptr, int count)
		{
			UnsafePtrListExtensions.ListData(ref this).AddRangeNoResize(ptr, count);
		}

		public unsafe void AddRangeNoResize(UnsafePtrList<T> list)
		{
			UnsafePtrListExtensions.ListData(ref this).AddRangeNoResize(list.Ptr, list.Length);
		}

		public void Add(in IntPtr value)
		{
			UnsafePtrListExtensions.ListData(ref this).Add(in value);
		}

		public unsafe void Add(void* value)
		{
			UnsafePtrListExtensions.ListData(ref this).Add((IntPtr)value);
		}

		public unsafe void AddRange(void* ptr, int length)
		{
			UnsafePtrListExtensions.ListData(ref this).AddRange(ptr, length);
		}

		public void AddRange(UnsafePtrList<T> list)
		{
			UnsafePtrListExtensions.ListData(ref this).AddRange(UnsafePtrListExtensions.ListData(ref list));
		}

		public void InsertRangeWithBeginEnd(int begin, int end)
		{
			UnsafePtrListExtensions.ListData(ref this).InsertRangeWithBeginEnd(begin, end);
		}

		public void RemoveAtSwapBack(int index)
		{
			UnsafePtrListExtensions.ListData(ref this).RemoveAtSwapBack(index);
		}

		public void RemoveRangeSwapBack(int index, int count)
		{
			UnsafePtrListExtensions.ListData(ref this).RemoveRangeSwapBack(index, count);
		}

		public void RemoveAt(int index)
		{
			UnsafePtrListExtensions.ListData(ref this).RemoveAt(index);
		}

		public void RemoveRange(int index, int count)
		{
			UnsafePtrListExtensions.ListData(ref this).RemoveRange(index, count);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator<IntPtr> IEnumerable<IntPtr>.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		public unsafe ReadOnly AsReadOnly()
		{
			return new ReadOnly(Ptr, Length);
		}

		public unsafe ParallelReader AsParallelReader()
		{
			return new ParallelReader(Ptr, Length);
		}

		public unsafe ParallelWriter AsParallelWriter()
		{
			return new ParallelWriter(Ptr, (UnsafeList<IntPtr>*)UnsafeUtility.AddressOf(ref this));
		}
	}
	[GenerateTestsForBurstCompatibility]
	internal static class UnsafePtrListExtensions
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static ref UnsafeList<IntPtr> ListData<T>(this ref UnsafePtrList<T> from) where T : unmanaged
		{
			return ref UnsafeUtility.As<UnsafePtrList<T>, UnsafeList<IntPtr>>(ref from);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static UnsafeList<IntPtr> ListDataRO<T>(this UnsafePtrList<T> from) where T : unmanaged
		{
			return UnsafeUtility.As<UnsafePtrList<T>, UnsafeList<IntPtr>>(ref from);
		}
	}
	internal sealed class UnsafePtrListDebugView<T> where T : unmanaged
	{
		private UnsafePtrList<T> Data;

		public unsafe T*[] Items
		{
			get
			{
				T*[] array = new T*[Data.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = Data.Ptr[i];
				}
				return array;
			}
		}

		public UnsafePtrListDebugView(UnsafePtrList<T> data)
		{
			Data = data;
		}
	}
	[GenerateTestsForBurstCompatibility]
	public struct UnsafeParallelHashMapBucketData
	{
		public unsafe readonly byte* values;

		public unsafe readonly byte* keys;

		public unsafe readonly byte* next;

		public unsafe readonly byte* buckets;

		public readonly int bucketCapacityMask;

		internal unsafe UnsafeParallelHashMapBucketData(byte* v, byte* k, byte* n, byte* b, int bcm)
		{
			values = v;
			keys = k;
			next = n;
			buckets = b;
			bucketCapacityMask = bcm;
		}
	}
	[StructLayout(LayoutKind.Explicit)]
	[GenerateTestsForBurstCompatibility]
	internal struct UnsafeParallelHashMapData
	{
		[FieldOffset(0)]
		internal unsafe byte* values;

		[FieldOffset(8)]
		internal unsafe byte* keys;

		[FieldOffset(16)]
		internal unsafe byte* next;

		[FieldOffset(24)]
		internal unsafe byte* buckets;

		[FieldOffset(32)]
		internal int keyCapacity;

		[FieldOffset(36)]
		internal int bucketCapacityMask;

		[FieldOffset(40)]
		internal int allocatedIndexLength;

		private const int kFirstFreeTLSOffset = 64;

		internal const int IntsPerCacheLine = 16;

		internal unsafe int* firstFreeTLS => (int*)UnsafeUtility.AddressOf(ref this) + 16;

		internal static int GetBucketSize(int capacity)
		{
			return capacity * 2;
		}

		internal static int GrowCapacity(int capacity)
		{
			if (capacity == 0)
			{
				return 1;
			}
			return capacity * 2;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		internal unsafe static void AllocateHashMap<TKey, TValue>(int length, int bucketLength, AllocatorManager.AllocatorHandle label, out UnsafeParallelHashMapData* outBuf) where TKey : unmanaged where TValue : unmanaged
		{
			int threadIndexCount = JobsUtility.ThreadIndexCount;
			Assert.IsTrue(sizeof(UnsafeParallelHashMapData) <= 64);
			UnsafeParallelHashMapData* ptr = (UnsafeParallelHashMapData*)Memory.Unmanaged.Allocate(64 + 64 * threadIndexCount, 64, label);
			bucketLength = math.ceilpow2(bucketLength);
			ptr->keyCapacity = length;
			ptr->bucketCapacityMask = bucketLength - 1;
			int keyOffset;
			int nextOffset;
			int bucketOffset;
			int num = CalculateDataSize<TKey, TValue>(length, bucketLength, out keyOffset, out nextOffset, out bucketOffset);
			ptr->values = (byte*)Memory.Unmanaged.Allocate(num, 64, label);
			ptr->keys = ptr->values + keyOffset;
			ptr->next = ptr->values + nextOffset;
			ptr->buckets = ptr->values + bucketOffset;
			outBuf = ptr;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		internal unsafe static void ReallocateHashMap<TKey, TValue>(UnsafeParallelHashMapData* data, int newCapacity, int newBucketCapacity, AllocatorManager.AllocatorHandle label) where TKey : unmanaged where TValue : unmanaged
		{
			newBucketCapacity = math.ceilpow2(newBucketCapacity);
			if (data->keyCapacity == newCapacity && data->bucketCapacityMask + 1 == newBucketCapacity)
			{
				return;
			}
			int keyOffset;
			int nextOffset;
			int bucketOffset;
			byte* ptr = (byte*)Memory.Unmanaged.Allocate(CalculateDataSize<TKey, TValue>(newCapacity, newBucketCapacity, out keyOffset, out nextOffset, out bucketOffset), 64, label);
			byte* destination = ptr + keyOffset;
			byte* ptr2 = ptr + nextOffset;
			byte* ptr3 = ptr + bucketOffset;
			UnsafeUtility.MemCpy(ptr, data->values, data->keyCapacity * UnsafeUtility.SizeOf<TValue>());
			UnsafeUtility.MemCpy(destination, data->keys, data->keyCapacity * UnsafeUtility.SizeOf<TKey>());
			UnsafeUtility.MemCpy(ptr2, data->next, data->keyCapacity * UnsafeUtility.SizeOf<int>());
			for (int i = data->keyCapacity; i < newCapacity; i++)
			{
				((int*)ptr2)[i] = -1;
			}
			for (int j = 0; j < newBucketCapacity; j++)
			{
				((int*)ptr3)[j] = -1;
			}
			for (int k = 0; k <= data->bucketCapacityMask; k++)
			{
				int* ptr4 = (int*)data->buckets;
				int* ptr5 = (int*)ptr2;
				while (ptr4[k] >= 0)
				{
					int num = ptr4[k];
					ptr4[k] = ptr5[num];
					int num2 = UnsafeUtility.ReadArrayElement<TKey>(data->keys, num).GetHashCode() & (newBucketCapacity - 1);
					ptr5[num] = ((int*)ptr3)[num2];
					((int*)ptr3)[num2] = num;
				}
			}
			Memory.Unmanaged.Free(data->values, label);
			if (data->allocatedIndexLength > data->keyCapacity)
			{
				data->allocatedIndexLength = data->keyCapacity;
			}
			data->values = ptr;
			data->keys = destination;
			data->next = ptr2;
			data->buckets = ptr3;
			data->keyCapacity = newCapacity;
			data->bucketCapacityMask = newBucketCapacity - 1;
		}

		internal unsafe static void DeallocateHashMap(UnsafeParallelHashMapData* data, AllocatorManager.AllocatorHandle allocator)
		{
			Memory.Unmanaged.Free(data->values, allocator);
			Memory.Unmanaged.Free(data, allocator);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		internal static int CalculateDataSize<TKey, TValue>(int length, int bucketLength, out int keyOffset, out int nextOffset, out int bucketOffset) where TKey : unmanaged where TValue : unmanaged
		{
			int num = UnsafeUtility.SizeOf<TValue>();
			int num2 = UnsafeUtility.SizeOf<TKey>();
			int num3 = UnsafeUtility.SizeOf<int>();
			int num4 = CollectionHelper.Align(num * length, 64);
			int num5 = CollectionHelper.Align(num2 * length, 64);
			int num6 = CollectionHelper.Align(num3 * length, 64);
			int num7 = CollectionHelper.Align(num3 * bucketLength, 64);
			int result = num4 + num5 + num6 + num7;
			keyOffset = num4;
			nextOffset = keyOffset + num5;
			bucketOffset = nextOffset + num6;
			return result;
		}

		internal unsafe static bool IsEmpty(UnsafeParallelHashMapData* data)
		{
			if (data->allocatedIndexLength <= 0)
			{
				return true;
			}
			int* ptr = (int*)data->buckets;
			int* ptr2 = (int*)data->next;
			int num = data->bucketCapacityMask;
			for (int i = 0; i <= num; i++)
			{
				if (ptr[i] != -1)
				{
					return false;
				}
			}
			return true;
		}

		internal unsafe static int GetCount(UnsafeParallelHashMapData* data)
		{
			if (data->allocatedIndexLength <= 0)
			{
				return 0;
			}
			int* ptr = (int*)data->next;
			int num = 0;
			int threadIndexCount = JobsUtility.ThreadIndexCount;
			for (int i = 0; i < threadIndexCount; i++)
			{
				for (int num2 = data->firstFreeTLS[i * 16]; num2 >= 0; num2 = ptr[num2])
				{
					num++;
				}
			}
			return math.min(data->keyCapacity, data->allocatedIndexLength) - num;
		}

		internal unsafe static bool MoveNextSearch(UnsafeParallelHashMapData* data, ref int bucketIndex, ref int nextIndex, out int index)
		{
			int* ptr = (int*)data->buckets;
			int num = data->bucketCapacityMask;
			for (int i = bucketIndex; i <= num; i++)
			{
				int num2 = ptr[i];
				if (num2 != -1)
				{
					int* ptr2 = (int*)data->next;
					index = num2;
					bucketIndex = i + 1;
					nextIndex = ptr2[num2];
					return true;
				}
			}
			index = -1;
			bucketIndex = num + 1;
			nextIndex = -1;
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal unsafe static bool MoveNext(UnsafeParallelHashMapData* data, ref int bucketIndex, ref int nextIndex, out int index)
		{
			if (nextIndex != -1)
			{
				int* ptr = (int*)data->next;
				index = nextIndex;
				nextIndex = ptr[nextIndex];
				return true;
			}
			return MoveNextSearch(data, ref bucketIndex, ref nextIndex, out index);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		internal unsafe static void GetKeyArray<TKey>(UnsafeParallelHashMapData* data, NativeArray<TKey> result) where TKey : unmanaged
		{
			int* ptr = (int*)data->buckets;
			int* ptr2 = (int*)data->next;
			int i = 0;
			int num = 0;
			int length = result.Length;
			for (; i <= data->bucketCapacityMask; i++)
			{
				if (num >= length)
				{
					break;
				}
				for (int num2 = ptr[i]; num2 != -1; num2 = ptr2[num2])
				{
					result[num++] = UnsafeUtility.ReadArrayElement<TKey>(data->keys, num2);
				}
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		internal unsafe static void GetValueArray<TValue>(UnsafeParallelHashMapData* data, NativeArray<TValue> result) where TValue : unmanaged
		{
			int* ptr = (int*)data->buckets;
			int* ptr2 = (int*)data->next;
			int i = 0;
			int num = 0;
			int length = result.Length;
			for (int num2 = data->bucketCapacityMask; i <= num2; i++)
			{
				if (num >= length)
				{
					break;
				}
				for (int num3 = ptr[i]; num3 != -1; num3 = ptr2[num3])
				{
					result[num++] = UnsafeUtility.ReadArrayElement<TValue>(data->values, num3);
				}
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		internal unsafe static void GetKeyValueArrays<TKey, TValue>(UnsafeParallelHashMapData* data, NativeKeyValueArrays<TKey, TValue> result) where TKey : unmanaged where TValue : unmanaged
		{
			int* ptr = (int*)data->buckets;
			int* ptr2 = (int*)data->next;
			int i = 0;
			int num = 0;
			int length = result.Length;
			for (int num2 = data->bucketCapacityMask; i <= num2; i++)
			{
				if (num >= length)
				{
					break;
				}
				for (int num3 = ptr[i]; num3 != -1; num3 = ptr2[num3])
				{
					result.Keys[num] = UnsafeUtility.ReadArrayElement<TKey>(data->keys, num3);
					result.Values[num] = UnsafeUtility.ReadArrayElement<TValue>(data->values, num3);
					num++;
				}
			}
		}

		internal unsafe UnsafeParallelHashMapBucketData GetBucketData()
		{
			return new UnsafeParallelHashMapBucketData(values, keys, next, buckets, bucketCapacityMask);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private unsafe static void CheckHashMapReallocateDoesNotShrink(UnsafeParallelHashMapData* data, int newCapacity)
		{
			if (data->keyCapacity > newCapacity)
			{
				throw new InvalidOperationException("Shrinking a hash map is not supported");
			}
		}
	}
	[NativeContainer]
	[GenerateTestsForBurstCompatibility]
	internal struct UnsafeParallelHashMapDataDispose
	{
		[NativeDisableUnsafePtrRestriction]
		internal unsafe UnsafeParallelHashMapData* m_Buffer;

		internal AllocatorManager.AllocatorHandle m_AllocatorLabel;

		public unsafe void Dispose()
		{
			UnsafeParallelHashMapData.DeallocateHashMap(m_Buffer, m_AllocatorLabel);
		}
	}
	[BurstCompile]
	internal struct UnsafeParallelHashMapDataDisposeJob : IJob
	{
		internal UnsafeParallelHashMapDataDispose Data;

		public void Execute()
		{
			Data.Dispose();
		}
	}
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
	{
		typeof(int),
		typeof(int)
	})]
	internal struct UnsafeParallelHashMapBase<TKey, TValue> where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
	{
		private const int SentinelRefilling = -2;

		private const int SentinelSwapInProgress = -3;

		internal unsafe static void Clear(UnsafeParallelHashMapData* data)
		{
			UnsafeUtility.MemSet(data->buckets, byte.MaxValue, (data->bucketCapacityMask + 1) * 4);
			UnsafeUtility.MemSet(data->next, byte.MaxValue, data->keyCapacity * 4);
			int threadIndexCount = JobsUtility.ThreadIndexCount;
			for (int i = 0; i < threadIndexCount; i++)
			{
				data->firstFreeTLS[i * 16] = -1;
			}
			data->allocatedIndexLength = 0;
		}

		internal unsafe static int AllocEntry(UnsafeParallelHashMapData* data, int threadIndex)
		{
			int* next = (int*)data->next;
			int num;
			while (true)
			{
				num = Volatile.Read(ref data->firstFreeTLS[threadIndex * 16]);
				if (num == -3)
				{
					continue;
				}
				if (num < 0)
				{
					Interlocked.Exchange(ref data->firstFreeTLS[threadIndex * 16], -2);
					if (data->allocatedIndexLength < data->keyCapacity)
					{
						num = Interlocked.Add(ref data->allocatedIndexLength, 16) - 16;
						if (num < data->keyCapacity - 1)
						{
							int num2 = math.min(16, data->keyCapacity - num);
							for (int i = 1; i < num2; i++)
							{
								next[num + i] = num + i + 1;
							}
							next[num + num2 - 1] = -1;
							next[num] = -1;
							Interlocked.Exchange(ref data->firstFreeTLS[threadIndex * 16], num + 1);
							return num;
						}
						if (num == data->keyCapacity - 1)
						{
							Interlocked.Exchange(ref data->firstFreeTLS[threadIndex * 16], -1);
							return num;
						}
					}
					Interlocked.Exchange(ref data->firstFreeTLS[threadIndex * 16], -1);
					int threadIndexCount = JobsUtility.ThreadIndexCount;
					bool flag = true;
					while (flag)
					{
						flag = false;
						for (int num3 = (threadIndex + 1) % threadIndexCount; num3 != threadIndex; num3 = (num3 + 1) % threadIndexCount)
						{
							do
							{
								num = Volatile.Read(ref data->firstFreeTLS[num3 * 16]);
							}
							while (num == -3 || (num >= 0 && Interlocked.CompareExchange(ref data->firstFreeTLS[num3 * 16], -3, num) != num));
							if (num == -2)
							{
								flag = true;
							}
							else if (num >= 0)
							{
								Interlocked.Exchange(ref data->firstFreeTLS[num3 * 16], next[num]);
								next[num] = -1;
								return num;
							}
						}
					}
				}
				if (Interlocked.CompareExchange(ref data->firstFreeTLS[threadIndex * 16], -3, num) == num)
				{
					break;
				}
			}
			Interlocked.Exchange(ref data->firstFreeTLS[threadIndex * 16], next[num]);
			next[num] = -1;
			return num;
		}

		internal unsafe static void FreeEntry(UnsafeParallelHashMapData* data, int idx, int threadIndex)
		{
			int* next = (int*)data->next;
			int num = -1;
			while (true)
			{
				num = Volatile.Read(ref data->firstFreeTLS[threadIndex * 16]);
				if (num != -3)
				{
					next[idx] = num;
					if (Interlocked.CompareExchange(ref data->firstFreeTLS[threadIndex * 16], idx, num) == num)
					{
						break;
					}
				}
			}
		}

		internal unsafe static bool TryAddAtomic(UnsafeParallelHashMapData* data, TKey key, TValue item, int threadIndex)
		{
			if (TryGetFirstValueAtomic(data, key, out var item2, out var it))
			{
				return false;
			}
			int num = AllocEntry(data, threadIndex);
			UnsafeUtility.WriteArrayElement(data->keys, num, key);
			UnsafeUtility.WriteArrayElement(data->values, num, item);
			int num2 = key.GetHashCode() & data->bucketCapacityMask;
			int* buckets = (int*)data->buckets;
			if (Interlocked.CompareExchange(ref buckets[num2], num, -1) != -1)
			{
				int* next = (int*)data->next;
				int num3 = -1;
				do
				{
					num3 = (next[num] = buckets[num2]);
					if (TryGetFirstValueAtomic(data, key, out item2, out it))
					{
						FreeEntry(data, num, threadIndex);
						return false;
					}
				}
				while (Interlocked.CompareExchange(ref buckets[num2], num, num3) != num3);
			}
			return true;
		}

		internal unsafe static void AddAtomicMulti(UnsafeParallelHashMapData* data, TKey key, TValue item, int threadIndex)
		{
			int num = AllocEntry(data, threadIndex);
			UnsafeUtility.WriteArrayElement(data->keys, num, key);
			UnsafeUtility.WriteArrayElement(data->values, num, item);
			int num2 = key.GetHashCode() & data->bucketCapacityMask;
			int* buckets = (int*)data->buckets;
			int* next = (int*)data->next;
			int num3;
			do
			{
				num3 = (next[num] = buckets[num2]);
			}
			while (Interlocked.CompareExchange(ref buckets[num2], num, num3) != num3);
		}

		internal unsafe static bool TryAdd(UnsafeParallelHashMapData* data, TKey key, TValue item, bool isMultiHashMap, AllocatorManager.AllocatorHandle allocation)
		{
			if (isMultiHashMap || !TryGetFirstValueAtomic(data, key, out var _, out var _))
			{
				int num;
				int* next;
				if (data->allocatedIndexLength >= data->keyCapacity && *data->firstFreeTLS < 0)
				{
					int threadIndexCount = JobsUtility.ThreadIndexCount;
					for (int i = 1; i < threadIndexCount; i++)
					{
						if (data->firstFreeTLS[i * 16] >= 0)
						{
							num = data->firstFreeTLS[i * 16];
							next = (int*)data->next;
							data->firstFreeTLS[i * 16] = next[num];
							next[num] = -1;
							*data->firstFreeTLS = num;
							break;
						}
					}
					if (*data->firstFreeTLS < 0)
					{
						int num2 = UnsafeParallelHashMapData.GrowCapacity(data->keyCapacity);
						UnsafeParallelHashMapData.ReallocateHashMap<TKey, TValue>(data, num2, UnsafeParallelHashMapData.GetBucketSize(num2), allocation);
					}
				}
				num = *data->firstFreeTLS;
				if (num >= 0)
				{
					*data->firstFreeTLS = ((int*)data->next)[num];
				}
				else
				{
					num = data->allocatedIndexLength++;
				}
				UnsafeUtility.WriteArrayElement(data->keys, num, key);
				UnsafeUtility.WriteArrayElement(data->values, num, item);
				int num3 = key.GetHashCode() & data->bucketCapacityMask;
				int* buckets = (int*)data->buckets;
				next = (int*)data->next;
				next[num] = buckets[num3];
				buckets[num3] = num;
				return true;
			}
			return false;
		}

		internal unsafe static int Remove(UnsafeParallelHashMapData* data, TKey key, bool isMultiHashMap)
		{
			if (data->keyCapacity == 0)
			{
				return 0;
			}
			int num = 0;
			int* buckets = (int*)data->buckets;
			int* next = (int*)data->next;
			int num2 = key.GetHashCode() & data->bucketCapacityMask;
			int num3 = -1;
			int num4 = buckets[num2];
			while (num4 >= 0 && num4 < data->keyCapacity)
			{
				if (UnsafeUtility.ReadArrayElement<TKey>(data->keys, num4).Equals(key))
				{
					num++;
					if (num3 < 0)
					{
						buckets[num2] = next[num4];
					}
					else
					{
						next[num3] = next[num4];
					}
					int num5 = next[num4];
					next[num4] = *data->firstFreeTLS;
					*data->firstFreeTLS = num4;
					num4 = num5;
					if (!isMultiHashMap)
					{
						break;
					}
				}
				else
				{
					num3 = num4;
					num4 = next[num4];
				}
			}
			return num;
		}

		internal unsafe static void Remove(UnsafeParallelHashMapData* data, NativeParallelMultiHashMapIterator<TKey> it)
		{
			int* buckets = (int*)data->buckets;
			int* next = (int*)data->next;
			int num = it.key.GetHashCode() & data->bucketCapacityMask;
			int num2 = buckets[num];
			if (num2 == it.EntryIndex)
			{
				buckets[num] = next[num2];
			}
			else
			{
				while (num2 >= 0 && next[num2] != it.EntryIndex)
				{
					num2 = next[num2];
				}
				_ = 0;
				next[num2] = next[it.EntryIndex];
			}
			next[it.EntryIndex] = *data->firstFreeTLS;
			*data->firstFreeTLS = it.EntryIndex;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		internal unsafe static void RemoveKeyValue<TValueEQ>(UnsafeParallelHashMapData* data, TKey key, TValueEQ value) where TValueEQ : unmanaged, IEquatable<TValueEQ>
		{
			if (data->keyCapacity == 0)
			{
				return;
			}
			int* buckets = (int*)data->buckets;
			uint keyCapacity = (uint)data->keyCapacity;
			int* ptr = buckets + (key.GetHashCode() & data->bucketCapacityMask);
			int num = *ptr;
			if ((uint)num >= keyCapacity)
			{
				return;
			}
			int* next = (int*)data->next;
			byte* keys = data->keys;
			byte* values = data->values;
			int* firstFreeTLS = data->firstFreeTLS;
			do
			{
				if (UnsafeUtility.ReadArrayElement<TKey>(keys, num).Equals(key) && UnsafeUtility.ReadArrayElement<TValueEQ>(values, num).Equals(value))
				{
					int num2 = next[num];
					next[num] = *firstFreeTLS;
					*firstFreeTLS = num;
					num = (*ptr = num2);
				}
				else
				{
					ptr = next + num;
					num = *ptr;
				}
			}
			while ((uint)num < keyCapacity);
		}

		internal unsafe static bool TryGetFirstValueAtomic(UnsafeParallelHashMapData* data, TKey key, out TValue item, out NativeParallelMultiHashMapIterator<TKey> it)
		{
			it.key = key;
			if (data->allocatedIndexLength <= 0)
			{
				it.EntryIndex = (it.NextEntryIndex = -1);
				item = default(TValue);
				return false;
			}
			int* buckets = (int*)data->buckets;
			int num = key.GetHashCode() & data->bucketCapacityMask;
			it.EntryIndex = (it.NextEntryIndex = buckets[num]);
			return TryGetNextValueAtomic(data, out item, ref it);
		}

		internal unsafe static bool TryGetNextValueAtomic(UnsafeParallelHashMapData* data, out TValue item, ref NativeParallelMultiHashMapIterator<TKey> it)
		{
			int num = it.NextEntryIndex;
			it.NextEntryIndex = -1;
			it.EntryIndex = -1;
			item = default(TValue);
			if (num < 0 || num >= data->keyCapacity)
			{
				return false;
			}
			int* next = (int*)data->next;
			while (!UnsafeUtility.ReadArrayElement<TKey>(data->keys, num).Equals(it.key))
			{
				num = next[num];
				if (num < 0 || num >= data->keyCapacity)
				{
					return false;
				}
			}
			it.NextEntryIndex = next[num];
			it.EntryIndex = num;
			item = UnsafeUtility.ReadArrayElement<TValue>(data->values, num);
			return true;
		}

		internal unsafe static bool SetValue(UnsafeParallelHashMapData* data, ref NativeParallelMultiHashMapIterator<TKey> it, ref TValue item)
		{
			int entryIndex = it.EntryIndex;
			if (entryIndex < 0 || entryIndex >= data->keyCapacity)
			{
				return false;
			}
			UnsafeUtility.WriteArrayElement(data->values, entryIndex, item);
			return true;
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckOutOfCapacity(int idx, int keyCapacity)
		{
			if (idx >= keyCapacity)
			{
				throw new InvalidOperationException($"nextPtr idx {idx} beyond capacity {keyCapacity}");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private unsafe static void CheckIndexOutOfBounds(UnsafeParallelHashMapData* data, int idx)
		{
			if (idx < 0 || idx >= data->keyCapacity)
			{
				throw new InvalidOperationException("Internal HashMap error");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void ThrowFull()
		{
			throw new InvalidOperationException("HashMap is full");
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void ThrowInvalidIterator()
		{
			throw new InvalidOperationException("Invalid iterator passed to HashMap remove");
		}
	}
	[DebuggerDisplay("Key = {Key}, Value = {Value}")]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
	{
		typeof(int),
		typeof(int)
	})]
	public struct KeyValue<TKey, TValue> where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
	{
		internal unsafe UnsafeParallelHashMapData* m_Buffer;

		internal int m_Index;

		internal int m_Next;

		public static KeyValue<TKey, TValue> Null => new KeyValue<TKey, TValue>
		{
			m_Index = -1
		};

		public unsafe TKey Key
		{
			get
			{
				if (m_Index != -1)
				{
					return UnsafeUtility.ReadArrayElement<TKey>(m_Buffer->keys, m_Index);
				}
				return default(TKey);
			}
		}

		public unsafe ref TValue Value => ref UnsafeUtility.AsRef<TValue>(m_Buffer->values + UnsafeUtility.SizeOf<TValue>() * m_Index);

		public unsafe bool GetKeyValue(out TKey key, out TValue value)
		{
			if (m_Index != -1)
			{
				key = UnsafeUtility.ReadArrayElement<TKey>(m_Buffer->keys, m_Index);
				value = UnsafeUtility.ReadArrayElement<TValue>(m_Buffer->values, m_Index);
				return true;
			}
			key = default(TKey);
			value = default(TValue);
			return false;
		}
	}
	internal struct UnsafeParallelHashMapDataEnumerator
	{
		[NativeDisableUnsafePtrRestriction]
		internal unsafe UnsafeParallelHashMapData* m_Buffer;

		internal int m_Index;

		internal int m_BucketIndex;

		internal int m_NextIndex;

		internal unsafe UnsafeParallelHashMapDataEnumerator(UnsafeParallelHashMapData* data)
		{
			m_Buffer = data;
			m_Index = -1;
			m_BucketIndex = 0;
			m_NextIndex = -1;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal unsafe bool MoveNext()
		{
			return UnsafeParallelHashMapData.MoveNext(m_Buffer, ref m_BucketIndex, ref m_NextIndex, out m_Index);
		}

		internal void Reset()
		{
			m_Index = -1;
			m_BucketIndex = 0;
			m_NextIndex = -1;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal unsafe KeyValue<TKey, TValue> GetCurrent<TKey, TValue>() where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
		{
			return new KeyValue<TKey, TValue>
			{
				m_Buffer = m_Buffer,
				m_Index = m_Index
			};
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal unsafe TKey GetCurrentKey<TKey>() where TKey : unmanaged, IEquatable<TKey>
		{
			if (m_Index != -1)
			{
				return UnsafeUtility.ReadArrayElement<TKey>(m_Buffer->keys, m_Index);
			}
			return default(TKey);
		}
	}
	[DebuggerDisplay("Count = {Count()}, Capacity = {Capacity}, IsCreated = {IsCreated}, IsEmpty = {IsEmpty}")]
	[DebuggerTypeProxy(typeof(UnsafeParallelHashMapDebuggerTypeProxy<, >))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
	{
		typeof(int),
		typeof(int)
	})]
	public struct UnsafeParallelHashMap<TKey, TValue> : INativeDisposable, IDisposable, IEnumerable<KeyValue<TKey, TValue>>, IEnumerable where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
	{
		[DebuggerDisplay("Count = {m_HashMapData.Count()}, Capacity = {m_HashMapData.Capacity}, IsCreated = {m_HashMapData.IsCreated}, IsEmpty = {IsEmpty}")]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public struct ReadOnly : IEnumerable<KeyValue<TKey, TValue>>, IEnumerable
		{
			internal UnsafeParallelHashMap<TKey, TValue> m_HashMapData;

			public readonly bool IsCreated
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_HashMapData.IsCreated;
				}
			}

			public readonly bool IsEmpty
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					if (!IsCreated)
					{
						return true;
					}
					return m_HashMapData.IsEmpty;
				}
			}

			public readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_HashMapData.Capacity;
				}
			}

			public readonly TValue this[TKey key]
			{
				get
				{
					if (m_HashMapData.TryGetValue(key, out var item))
					{
						return item;
					}
					return default(TValue);
				}
			}

			internal ReadOnly(UnsafeParallelHashMap<TKey, TValue> hashMapData)
			{
				m_HashMapData = hashMapData;
			}

			public readonly int Count()
			{
				return m_HashMapData.Count();
			}

			public readonly bool TryGetValue(TKey key, out TValue item)
			{
				return m_HashMapData.TryGetValue(key, out item);
			}

			public readonly bool ContainsKey(TKey key)
			{
				return m_HashMapData.ContainsKey(key);
			}

			public readonly NativeArray<TKey> GetKeyArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_HashMapData.GetKeyArray(allocator);
			}

			public readonly NativeArray<TValue> GetValueArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_HashMapData.GetValueArray(allocator);
			}

			public readonly NativeKeyValueArrays<TKey, TValue> GetKeyValueArrays(AllocatorManager.AllocatorHandle allocator)
			{
				return m_HashMapData.GetKeyValueArrays(allocator);
			}

			[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
			[Conditional("UNITY_DOTS_DEBUG")]
			private readonly void ThrowKeyNotPresent(TKey key)
			{
				throw new ArgumentException($"Key: {key} is not present in the NativeParallelHashMap.");
			}

			public unsafe readonly Enumerator GetEnumerator()
			{
				return new Enumerator
				{
					m_Enumerator = new UnsafeParallelHashMapDataEnumerator(m_HashMapData.m_Buffer)
				};
			}

			IEnumerator<KeyValue<TKey, TValue>> IEnumerable<KeyValue<TKey, TValue>>.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				throw new NotImplementedException();
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public struct ParallelWriter
		{
			[NativeDisableUnsafePtrRestriction]
			internal unsafe UnsafeParallelHashMapData* m_Buffer;

			[NativeSetThreadIndex]
			internal int m_ThreadIndex;

			public int ThreadIndex => m_ThreadIndex;

			public unsafe readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Buffer->keyCapacity;
				}
			}

			public unsafe bool TryAdd(TKey key, TValue item)
			{
				Assert.IsTrue(m_ThreadIndex >= 0);
				return UnsafeParallelHashMapBase<TKey, TValue>.TryAddAtomic(m_Buffer, key, item, m_ThreadIndex);
			}

			internal unsafe bool TryAdd(TKey key, TValue item, int threadIndexOverride)
			{
				Assert.IsTrue(threadIndexOverride >= 0);
				return UnsafeParallelHashMapBase<TKey, TValue>.TryAddAtomic(m_Buffer, key, item, threadIndexOverride);
			}
		}

		public struct Enumerator : IEnumerator<KeyValue<TKey, TValue>>, IEnumerator, IDisposable
		{
			internal UnsafeParallelHashMapDataEnumerator m_Enumerator;

			public KeyValue<TKey, TValue> Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Enumerator.GetCurrent<TKey, TValue>();
				}
			}

			object IEnumerator.Current => Current;

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				return m_Enumerator.MoveNext();
			}

			public void Reset()
			{
				m_Enumerator.Reset();
			}
		}

		[NativeDisableUnsafePtrRestriction]
		internal unsafe UnsafeParallelHashMapData* m_Buffer;

		internal AllocatorManager.AllocatorHandle m_AllocatorLabel;

		public unsafe readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Buffer != null;
			}
		}

		public unsafe readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (IsCreated)
				{
					return UnsafeParallelHashMapData.IsEmpty(m_Buffer);
				}
				return true;
			}
		}

		public unsafe int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return m_Buffer->keyCapacity;
			}
			set
			{
				UnsafeParallelHashMapData.ReallocateHashMap<TKey, TValue>(m_Buffer, value, UnsafeParallelHashMapData.GetBucketSize(value), m_AllocatorLabel);
			}
		}

		public unsafe TValue this[TKey key]
		{
			get
			{
				TryGetValue(key, out var item);
				return item;
			}
			set
			{
				if (UnsafeParallelHashMapBase<TKey, TValue>.TryGetFirstValueAtomic(m_Buffer, key, out var _, out var it))
				{
					UnsafeParallelHashMapBase<TKey, TValue>.SetValue(m_Buffer, ref it, ref value);
				}
				else
				{
					UnsafeParallelHashMapBase<TKey, TValue>.TryAdd(m_Buffer, key, value, isMultiHashMap: false, m_AllocatorLabel);
				}
			}
		}

		public unsafe UnsafeParallelHashMap(int capacity, AllocatorManager.AllocatorHandle allocator)
		{
			m_AllocatorLabel = allocator;
			UnsafeParallelHashMapData.AllocateHashMap<TKey, TValue>(capacity, capacity * 2, allocator, out m_Buffer);
			Clear();
		}

		public unsafe readonly int Count()
		{
			return UnsafeParallelHashMapData.GetCount(m_Buffer);
		}

		public unsafe void Clear()
		{
			UnsafeParallelHashMapBase<TKey, TValue>.Clear(m_Buffer);
		}

		public unsafe bool TryAdd(TKey key, TValue item)
		{
			return UnsafeParallelHashMapBase<TKey, TValue>.TryAdd(m_Buffer, key, item, isMultiHashMap: false, m_AllocatorLabel);
		}

		public unsafe void Add(TKey key, TValue item)
		{
			UnsafeParallelHashMapBase<TKey, TValue>.TryAdd(m_Buffer, key, item, isMultiHashMap: false, m_AllocatorLabel);
		}

		public unsafe bool Remove(TKey key)
		{
			return UnsafeParallelHashMapBase<TKey, TValue>.Remove(m_Buffer, key, isMultiHashMap: false) != 0;
		}

		public unsafe bool TryGetValue(TKey key, out TValue item)
		{
			NativeParallelMultiHashMapIterator<TKey> it;
			return UnsafeParallelHashMapBase<TKey, TValue>.TryGetFirstValueAtomic(m_Buffer, key, out item, out it);
		}

		public unsafe bool ContainsKey(TKey key)
		{
			TValue item;
			NativeParallelMultiHashMapIterator<TKey> it;
			return UnsafeParallelHashMapBase<TKey, TValue>.TryGetFirstValueAtomic(m_Buffer, key, out item, out it);
		}

		public unsafe void Dispose()
		{
			if (IsCreated)
			{
				UnsafeParallelHashMapData.DeallocateHashMap(m_Buffer, m_AllocatorLabel);
				m_Buffer = null;
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new UnsafeParallelHashMapDisposeJob
			{
				Data = m_Buffer,
				Allocator = m_AllocatorLabel
			}.Schedule(inputDeps);
			m_Buffer = null;
			return result;
		}

		public unsafe NativeArray<TKey> GetKeyArray(AllocatorManager.AllocatorHandle allocator)
		{
			NativeArray<TKey> result = CollectionHelper.CreateNativeArray<TKey>(UnsafeParallelHashMapData.GetCount(m_Buffer), allocator, NativeArrayOptions.UninitializedMemory);
			UnsafeParallelHashMapData.GetKeyArray(m_Buffer, result);
			return result;
		}

		public unsafe NativeArray<TValue> GetValueArray(AllocatorManager.AllocatorHandle allocator)
		{
			NativeArray<TValue> result = CollectionHelper.CreateNativeArray<TValue>(UnsafeParallelHashMapData.GetCount(m_Buffer), allocator, NativeArrayOptions.UninitializedMemory);
			UnsafeParallelHashMapData.GetValueArray(m_Buffer, result);
			return result;
		}

		public unsafe NativeKeyValueArrays<TKey, TValue> GetKeyValueArrays(AllocatorManager.AllocatorHandle allocator)
		{
			NativeKeyValueArrays<TKey, TValue> result = new NativeKeyValueArrays<TKey, TValue>(UnsafeParallelHashMapData.GetCount(m_Buffer), allocator, NativeArrayOptions.UninitializedMemory);
			UnsafeParallelHashMapData.GetKeyValueArrays(m_Buffer, result);
			return result;
		}

		public unsafe ParallelWriter AsParallelWriter()
		{
			ParallelWriter result = default(ParallelWriter);
			result.m_ThreadIndex = 0;
			result.m_Buffer = m_Buffer;
			return result;
		}

		public ReadOnly AsReadOnly()
		{
			return new ReadOnly(this);
		}

		public unsafe Enumerator GetEnumerator()
		{
			return new Enumerator
			{
				m_Enumerator = new UnsafeParallelHashMapDataEnumerator(m_Buffer)
			};
		}

		IEnumerator<KeyValue<TKey, TValue>> IEnumerable<KeyValue<TKey, TValue>>.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}
	}
	[BurstCompile]
	internal struct UnsafeParallelHashMapDisposeJob : IJob
	{
		[NativeDisableUnsafePtrRestriction]
		public unsafe UnsafeParallelHashMapData* Data;

		public AllocatorManager.AllocatorHandle Allocator;

		public unsafe void Execute()
		{
			UnsafeParallelHashMapData.DeallocateHashMap(Data, Allocator);
		}
	}
	internal sealed class UnsafeParallelHashMapDebuggerTypeProxy<TKey, TValue> where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
	{
		private UnsafeParallelHashMap<TKey, TValue> m_Target;

		public List<Pair<TKey, TValue>> Items
		{
			get
			{
				List<Pair<TKey, TValue>> list = new List<Pair<TKey, TValue>>();
				NativeKeyValueArrays<TKey, TValue> keyValueArrays = m_Target.GetKeyValueArrays(Allocator.Temp);
				try
				{
					for (int i = 0; i < keyValueArrays.Length; i++)
					{
						NativeArray<TKey> keys = keyValueArrays.Keys;
						TKey k = keys[i];
						NativeArray<TValue> values = keyValueArrays.Values;
						list.Add(new Pair<TKey, TValue>(k, values[i]));
					}
					return list;
				}
				finally
				{
					((IDisposable)keyValueArrays/*cast due to .constrained prefix*/).Dispose();
				}
			}
		}

		public UnsafeParallelHashMapDebuggerTypeProxy(UnsafeParallelHashMap<TKey, TValue> target)
		{
			m_Target = target;
		}
	}
	public struct UntypedUnsafeParallelHashMap
	{
		[NativeDisableUnsafePtrRestriction]
		private unsafe UnsafeParallelHashMapData* m_Buffer;

		private AllocatorManager.AllocatorHandle m_AllocatorLabel;
	}
	[DebuggerTypeProxy(typeof(UnsafeParallelHashSetDebuggerTypeProxy<>))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct UnsafeParallelHashSet<T> : INativeDisposable, IDisposable, IEnumerable<T>, IEnumerable where T : unmanaged, IEquatable<T>
	{
		[NativeContainerIsAtomicWriteOnly]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ParallelWriter
		{
			internal UnsafeParallelHashMap<T, bool>.ParallelWriter m_Data;

			public readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data.Capacity;
				}
			}

			public bool Add(T item)
			{
				return m_Data.TryAdd(item, item: false);
			}

			internal bool Add(T item, int threadIndexOverride)
			{
				return m_Data.TryAdd(item, item: false, threadIndexOverride);
			}
		}

		public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
		{
			internal UnsafeParallelHashMapDataEnumerator m_Enumerator;

			public T Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Enumerator.GetCurrentKey<T>();
				}
			}

			object IEnumerator.Current => Current;

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				return m_Enumerator.MoveNext();
			}

			public void Reset()
			{
				m_Enumerator.Reset();
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public struct ReadOnly : IEnumerable<T>, IEnumerable
		{
			internal UnsafeParallelHashMap<T, bool> m_Data;

			public readonly bool IsCreated
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data.IsCreated;
				}
			}

			public readonly bool IsEmpty
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					if (m_Data.IsCreated)
					{
						return m_Data.IsEmpty;
					}
					return true;
				}
			}

			public readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Data.Capacity;
				}
			}

			internal ReadOnly(ref UnsafeParallelHashSet<T> data)
			{
				m_Data = data.m_Data;
			}

			public readonly int Count()
			{
				return m_Data.Count();
			}

			public readonly bool Contains(T item)
			{
				return m_Data.ContainsKey(item);
			}

			public readonly NativeArray<T> ToNativeArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_Data.GetKeyArray(allocator);
			}

			public unsafe readonly Enumerator GetEnumerator()
			{
				return new Enumerator
				{
					m_Enumerator = new UnsafeParallelHashMapDataEnumerator(m_Data.m_Buffer)
				};
			}

			IEnumerator<T> IEnumerable<T>.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				throw new NotImplementedException();
			}
		}

		internal UnsafeParallelHashMap<T, bool> m_Data;

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data.IsEmpty;
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return m_Data.Capacity;
			}
			set
			{
				m_Data.Capacity = value;
			}
		}

		public readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Data.IsCreated;
			}
		}

		public UnsafeParallelHashSet(int capacity, AllocatorManager.AllocatorHandle allocator)
		{
			m_Data = new UnsafeParallelHashMap<T, bool>(capacity, allocator);
		}

		public int Count()
		{
			return m_Data.Count();
		}

		public void Dispose()
		{
			m_Data.Dispose();
		}

		public JobHandle Dispose(JobHandle inputDeps)
		{
			return m_Data.Dispose(inputDeps);
		}

		public void Clear()
		{
			m_Data.Clear();
		}

		public bool Add(T item)
		{
			return m_Data.TryAdd(item, item: false);
		}

		public bool Remove(T item)
		{
			return m_Data.Remove(item);
		}

		public bool Contains(T item)
		{
			return m_Data.ContainsKey(item);
		}

		public NativeArray<T> ToNativeArray(AllocatorManager.AllocatorHandle allocator)
		{
			return m_Data.GetKeyArray(allocator);
		}

		public ParallelWriter AsParallelWriter()
		{
			return new ParallelWriter
			{
				m_Data = m_Data.AsParallelWriter()
			};
		}

		public unsafe Enumerator GetEnumerator()
		{
			return new Enumerator
			{
				m_Enumerator = new UnsafeParallelHashMapDataEnumerator(m_Data.m_Buffer)
			};
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		public ReadOnly AsReadOnly()
		{
			return new ReadOnly(ref this);
		}
	}
	internal sealed class UnsafeParallelHashSetDebuggerTypeProxy<T> where T : unmanaged, IEquatable<T>
	{
		private UnsafeParallelHashSet<T> Data;

		public List<T> Items
		{
			get
			{
				List<T> list = new List<T>();
				using NativeArray<T> nativeArray = Data.ToNativeArray(Allocator.Temp);
				for (int i = 0; i < nativeArray.Length; i++)
				{
					list.Add(nativeArray[i]);
				}
				return list;
			}
		}

		public UnsafeParallelHashSetDebuggerTypeProxy(UnsafeParallelHashSet<T> data)
		{
			Data = data;
		}
	}
	public static class HashSetExtensions
	{
		public static void ExceptWith<T>(this ref NativeHashSet<T> container, UnsafeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, UnsafeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, UnsafeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeHashSet<T> container, UnsafeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, UnsafeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, UnsafeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeHashSet<T> container, UnsafeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, UnsafeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, UnsafeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeHashSet<T> container, UnsafeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, UnsafeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, UnsafeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeHashSet<T> container, UnsafeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeHashSet<T> container, UnsafeList<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeHashSet<T> container, UnsafeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, UnsafeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, UnsafeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, UnsafeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, UnsafeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, UnsafeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, UnsafeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, UnsafeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, UnsafeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, UnsafeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, UnsafeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, UnsafeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, UnsafeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref NativeParallelHashSet<T> container, UnsafeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref NativeParallelHashSet<T> container, UnsafeList<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref NativeParallelHashSet<T> container, UnsafeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, FixedList128Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, FixedList128Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, FixedList128Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, FixedList32Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, FixedList32Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, FixedList32Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, FixedList4096Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, FixedList4096Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, FixedList4096Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, FixedList512Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, FixedList512Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, FixedList512Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, FixedList64Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, FixedList64Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, FixedList64Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, NativeArray<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, NativeArray<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, NativeArray<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, NativeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, NativeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, NativeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, NativeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, NativeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, NativeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, UnsafeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, UnsafeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, UnsafeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, UnsafeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, UnsafeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, UnsafeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, NativeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, NativeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, NativeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, NativeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, NativeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, NativeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, UnsafeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, UnsafeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, UnsafeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, UnsafeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, UnsafeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, UnsafeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, NativeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, NativeList<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, NativeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeHashSet<T> container, UnsafeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeHashSet<T> container, UnsafeList<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count, Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeHashSet<T> container, UnsafeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, FixedList128Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, FixedList128Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, FixedList128Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, FixedList32Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, FixedList32Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, FixedList32Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, FixedList4096Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, FixedList4096Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, FixedList4096Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, FixedList512Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, FixedList512Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, FixedList512Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, FixedList64Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, FixedList64Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, FixedList64Bytes<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, NativeArray<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, NativeArray<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, NativeArray<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, NativeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, NativeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, NativeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, NativeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, NativeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, NativeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, UnsafeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, UnsafeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, UnsafeHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, UnsafeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, UnsafeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, UnsafeHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, NativeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, NativeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, NativeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, NativeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, NativeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, NativeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, UnsafeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, UnsafeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, UnsafeParallelHashSet<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, UnsafeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, UnsafeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, UnsafeParallelHashSet<T>.ReadOnly other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, NativeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, NativeList<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, NativeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}

		public static void ExceptWith<T>(this ref UnsafeParallelHashSet<T> container, UnsafeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Remove(item);
			}
		}

		public static void IntersectWith<T>(this ref UnsafeParallelHashSet<T> container, UnsafeList<T> other) where T : unmanaged, IEquatable<T>
		{
			UnsafeList<T> other2 = new UnsafeList<T>(container.Count(), Allocator.Temp);
			foreach (T item in other)
			{
				T value = item;
				if (container.Contains(value))
				{
					other2.Add(in value);
				}
			}
			container.Clear();
			container.UnionWith(other2);
			other2.Dispose();
		}

		public static void UnionWith<T>(this ref UnsafeParallelHashSet<T> container, UnsafeList<T> other) where T : unmanaged, IEquatable<T>
		{
			foreach (T item in other)
			{
				container.Add(item);
			}
		}
	}
	[DebuggerTypeProxy(typeof(UnsafeParallelMultiHashMapDebuggerTypeProxy<, >))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
	{
		typeof(int),
		typeof(int)
	})]
	public struct UnsafeParallelMultiHashMap<TKey, TValue> : INativeDisposable, IDisposable, IEnumerable<KeyValue<TKey, TValue>>, IEnumerable where TKey : unmanaged, IEquatable<TKey> where TValue : unmanaged
	{
		public struct Enumerator : IEnumerator<TValue>, IEnumerator, IDisposable
		{
			internal UnsafeParallelMultiHashMap<TKey, TValue> hashmap;

			internal TKey key;

			internal bool isFirst;

			private TValue value;

			private NativeParallelMultiHashMapIterator<TKey> iterator;

			public TValue Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return value;
				}
			}

			object IEnumerator.Current => Current;

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				if (isFirst)
				{
					isFirst = false;
					return hashmap.TryGetFirstValue(key, out value, out iterator);
				}
				return hashmap.TryGetNextValue(out value, ref iterator);
			}

			public void Reset()
			{
				isFirst = true;
			}

			public Enumerator GetEnumerator()
			{
				return this;
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public struct ParallelWriter
		{
			[NativeDisableUnsafePtrRestriction]
			internal unsafe UnsafeParallelHashMapData* m_Buffer;

			[NativeSetThreadIndex]
			internal int m_ThreadIndex;

			public unsafe readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Buffer->keyCapacity;
				}
			}

			public unsafe void Add(TKey key, TValue item)
			{
				Assert.IsTrue(m_ThreadIndex >= 0);
				UnsafeParallelHashMapBase<TKey, TValue>.AddAtomicMulti(m_Buffer, key, item, m_ThreadIndex);
			}
		}

		public struct KeyValueEnumerator : IEnumerator<KeyValue<TKey, TValue>>, IEnumerator, IDisposable
		{
			internal UnsafeParallelHashMapDataEnumerator m_Enumerator;

			public KeyValue<TKey, TValue> Current
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_Enumerator.GetCurrent<TKey, TValue>();
				}
			}

			object IEnumerator.Current => Current;

			public void Dispose()
			{
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public bool MoveNext()
			{
				return m_Enumerator.MoveNext();
			}

			public void Reset()
			{
				m_Enumerator.Reset();
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[]
		{
			typeof(int),
			typeof(int)
		})]
		public struct ReadOnly : IEnumerable<KeyValue<TKey, TValue>>, IEnumerable
		{
			internal UnsafeParallelMultiHashMap<TKey, TValue> m_MultiHashMapData;

			public readonly bool IsCreated
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_MultiHashMapData.IsCreated;
				}
			}

			public readonly bool IsEmpty
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					if (!IsCreated)
					{
						return true;
					}
					return m_MultiHashMapData.IsEmpty;
				}
			}

			public readonly int Capacity
			{
				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				get
				{
					return m_MultiHashMapData.Capacity;
				}
			}

			internal ReadOnly(UnsafeParallelMultiHashMap<TKey, TValue> container)
			{
				m_MultiHashMapData = container;
			}

			public readonly int Count()
			{
				return m_MultiHashMapData.Count();
			}

			public readonly bool TryGetFirstValue(TKey key, out TValue item, out NativeParallelMultiHashMapIterator<TKey> it)
			{
				return m_MultiHashMapData.TryGetFirstValue(key, out item, out it);
			}

			public readonly bool TryGetNextValue(out TValue item, ref NativeParallelMultiHashMapIterator<TKey> it)
			{
				return m_MultiHashMapData.TryGetNextValue(out item, ref it);
			}

			public readonly bool ContainsKey(TKey key)
			{
				return m_MultiHashMapData.ContainsKey(key);
			}

			public readonly NativeArray<TKey> GetKeyArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_MultiHashMapData.GetKeyArray(allocator);
			}

			public readonly NativeArray<TValue> GetValueArray(AllocatorManager.AllocatorHandle allocator)
			{
				return m_MultiHashMapData.GetValueArray(allocator);
			}

			public readonly NativeKeyValueArrays<TKey, TValue> GetKeyValueArrays(AllocatorManager.AllocatorHandle allocator)
			{
				return m_MultiHashMapData.GetKeyValueArrays(allocator);
			}

			public unsafe KeyValueEnumerator GetEnumerator()
			{
				return new KeyValueEnumerator
				{
					m_Enumerator = new UnsafeParallelHashMapDataEnumerator(m_MultiHashMapData.m_Buffer)
				};
			}

			IEnumerator<KeyValue<TKey, TValue>> IEnumerable<KeyValue<TKey, TValue>>.GetEnumerator()
			{
				throw new NotImplementedException();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				throw new NotImplementedException();
			}
		}

		[NativeDisableUnsafePtrRestriction]
		internal unsafe UnsafeParallelHashMapData* m_Buffer;

		internal AllocatorManager.AllocatorHandle m_AllocatorLabel;

		public unsafe readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (IsCreated)
				{
					return UnsafeParallelHashMapData.IsEmpty(m_Buffer);
				}
				return true;
			}
		}

		public unsafe int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return m_Buffer->keyCapacity;
			}
			set
			{
				UnsafeParallelHashMapData.ReallocateHashMap<TKey, TValue>(m_Buffer, value, UnsafeParallelHashMapData.GetBucketSize(value), m_AllocatorLabel);
			}
		}

		public unsafe readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Buffer != null;
			}
		}

		public unsafe UnsafeParallelMultiHashMap(int capacity, AllocatorManager.AllocatorHandle allocator)
		{
			m_AllocatorLabel = allocator;
			UnsafeParallelHashMapData.AllocateHashMap<TKey, TValue>(capacity, capacity * 2, allocator, out m_Buffer);
			Clear();
		}

		public unsafe readonly int Count()
		{
			if (m_Buffer->allocatedIndexLength <= 0)
			{
				return 0;
			}
			return UnsafeParallelHashMapData.GetCount(m_Buffer);
		}

		public unsafe void Clear()
		{
			UnsafeParallelHashMapBase<TKey, TValue>.Clear(m_Buffer);
		}

		public unsafe void Add(TKey key, TValue item)
		{
			UnsafeParallelHashMapBase<TKey, TValue>.TryAdd(m_Buffer, key, item, isMultiHashMap: true, m_AllocatorLabel);
		}

		public unsafe int Remove(TKey key)
		{
			return UnsafeParallelHashMapBase<TKey, TValue>.Remove(m_Buffer, key, isMultiHashMap: true);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe void Remove<TValueEQ>(TKey key, TValueEQ value) where TValueEQ : unmanaged, IEquatable<TValueEQ>
		{
			UnsafeParallelHashMapBase<TKey, TValueEQ>.RemoveKeyValue(m_Buffer, key, value);
		}

		public unsafe void Remove(NativeParallelMultiHashMapIterator<TKey> it)
		{
			UnsafeParallelHashMapBase<TKey, TValue>.Remove(m_Buffer, it);
		}

		public unsafe readonly bool TryGetFirstValue(TKey key, out TValue item, out NativeParallelMultiHashMapIterator<TKey> it)
		{
			return UnsafeParallelHashMapBase<TKey, TValue>.TryGetFirstValueAtomic(m_Buffer, key, out item, out it);
		}

		public unsafe readonly bool TryGetNextValue(out TValue item, ref NativeParallelMultiHashMapIterator<TKey> it)
		{
			return UnsafeParallelHashMapBase<TKey, TValue>.TryGetNextValueAtomic(m_Buffer, out item, ref it);
		}

		public readonly bool ContainsKey(TKey key)
		{
			TValue item;
			NativeParallelMultiHashMapIterator<TKey> it;
			return TryGetFirstValue(key, out item, out it);
		}

		public readonly int CountValuesForKey(TKey key)
		{
			if (!TryGetFirstValue(key, out var item, out var it))
			{
				return 0;
			}
			int num = 1;
			while (TryGetNextValue(out item, ref it))
			{
				num++;
			}
			return num;
		}

		public unsafe bool SetValue(TValue item, NativeParallelMultiHashMapIterator<TKey> it)
		{
			return UnsafeParallelHashMapBase<TKey, TValue>.SetValue(m_Buffer, ref it, ref item);
		}

		public unsafe void Dispose()
		{
			if (IsCreated)
			{
				UnsafeParallelHashMapData.DeallocateHashMap(m_Buffer, m_AllocatorLabel);
				m_Buffer = null;
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new UnsafeParallelHashMapDisposeJob
			{
				Data = m_Buffer,
				Allocator = m_AllocatorLabel
			}.Schedule(inputDeps);
			m_Buffer = null;
			return result;
		}

		public unsafe readonly NativeArray<TKey> GetKeyArray(AllocatorManager.AllocatorHandle allocator)
		{
			NativeArray<TKey> result = CollectionHelper.CreateNativeArray<TKey>(Count(), allocator, NativeArrayOptions.UninitializedMemory);
			UnsafeParallelHashMapData.GetKeyArray(m_Buffer, result);
			return result;
		}

		public unsafe readonly NativeArray<TValue> GetValueArray(AllocatorManager.AllocatorHandle allocator)
		{
			NativeArray<TValue> result = CollectionHelper.CreateNativeArray<TValue>(Count(), allocator, NativeArrayOptions.UninitializedMemory);
			UnsafeParallelHashMapData.GetValueArray(m_Buffer, result);
			return result;
		}

		public unsafe readonly NativeKeyValueArrays<TKey, TValue> GetKeyValueArrays(AllocatorManager.AllocatorHandle allocator)
		{
			NativeKeyValueArrays<TKey, TValue> result = new NativeKeyValueArrays<TKey, TValue>(Count(), allocator, NativeArrayOptions.UninitializedMemory);
			UnsafeParallelHashMapData.GetKeyValueArrays(m_Buffer, result);
			return result;
		}

		public Enumerator GetValuesForKey(TKey key)
		{
			return new Enumerator
			{
				hashmap = this,
				key = key,
				isFirst = true
			};
		}

		public unsafe ParallelWriter AsParallelWriter()
		{
			ParallelWriter result = default(ParallelWriter);
			result.m_ThreadIndex = 0;
			result.m_Buffer = m_Buffer;
			return result;
		}

		public unsafe KeyValueEnumerator GetEnumerator()
		{
			return new KeyValueEnumerator
			{
				m_Enumerator = new UnsafeParallelHashMapDataEnumerator(m_Buffer)
			};
		}

		IEnumerator<KeyValue<TKey, TValue>> IEnumerable<KeyValue<TKey, TValue>>.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			throw new NotImplementedException();
		}

		public ReadOnly AsReadOnly()
		{
			return new ReadOnly(this);
		}
	}
	internal sealed class UnsafeParallelMultiHashMapDebuggerTypeProxy<TKey, TValue> where TKey : unmanaged, IEquatable<TKey>, IComparable<TKey> where TValue : unmanaged
	{
		private UnsafeParallelMultiHashMap<TKey, TValue> m_Target;

		public List<ListPair<TKey, List<TValue>>> Items
		{
			get
			{
				List<ListPair<TKey, List<TValue>>> list = new List<ListPair<TKey, List<TValue>>>();
				(NativeArray<TKey>, int) uniqueKeyArray = GetUniqueKeyArray(ref m_Target, Allocator.Temp);
				using (uniqueKeyArray.Item1)
				{
					for (int i = 0; i < uniqueKeyArray.Item2; i++)
					{
						List<TValue> list2 = new List<TValue>();
						if (m_Target.TryGetFirstValue(uniqueKeyArray.Item1[i], out var item, out var it))
						{
							do
							{
								list2.Add(item);
							}
							while (m_Target.TryGetNextValue(out item, ref it));
						}
						list.Add(new ListPair<TKey, List<TValue>>(uniqueKeyArray.Item1[i], list2));
					}
					return list;
				}
			}
		}

		public UnsafeParallelMultiHashMapDebuggerTypeProxy(UnsafeParallelMultiHashMap<TKey, TValue> target)
		{
			m_Target = target;
		}

		public static (NativeArray<TKey>, int) GetUniqueKeyArray(ref UnsafeParallelMultiHashMap<TKey, TValue> hashMap, AllocatorManager.AllocatorHandle allocator)
		{
			NativeArray<TKey> keyArray = hashMap.GetKeyArray(allocator);
			keyArray.Sort();
			int item = keyArray.Unique();
			return (keyArray, item);
		}
	}
	[DebuggerDisplay("Length = {Length}, Capacity = {Capacity}, IsCreated = {IsCreated}, IsEmpty = {IsEmpty}")]
	[DebuggerTypeProxy(typeof(UnsafeRingQueueDebugView<>))]
	[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
	public struct UnsafeRingQueue<T> : INativeDisposable, IDisposable where T : unmanaged
	{
		[NativeDisableUnsafePtrRestriction]
		public unsafe T* Ptr;

		public AllocatorManager.AllocatorHandle Allocator;

		internal readonly int m_Capacity;

		internal int m_Filled;

		internal int m_Write;

		internal int m_Read;

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Filled == 0;
			}
		}

		public readonly int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Filled;
			}
		}

		public readonly int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_Capacity;
			}
		}

		public unsafe readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return Ptr != null;
			}
		}

		public unsafe UnsafeRingQueue(T* ptr, int capacity)
		{
			Ptr = ptr;
			Allocator = AllocatorManager.None;
			m_Capacity = capacity;
			m_Filled = 0;
			m_Write = 0;
			m_Read = 0;
		}

		public unsafe UnsafeRingQueue(int capacity, AllocatorManager.AllocatorHandle allocator, NativeArrayOptions options = NativeArrayOptions.ClearMemory)
		{
			Allocator = allocator;
			m_Capacity = capacity;
			m_Filled = 0;
			m_Write = 0;
			m_Read = 0;
			int num = capacity * UnsafeUtility.SizeOf<T>();
			Ptr = (T*)Memory.Unmanaged.Allocate(num, 16, allocator);
			if (options == NativeArrayOptions.ClearMemory)
			{
				UnsafeUtility.MemClear(Ptr, num);
			}
		}

		internal unsafe static UnsafeRingQueue<T>* Alloc(AllocatorManager.AllocatorHandle allocator)
		{
			return (UnsafeRingQueue<T>*)Memory.Unmanaged.Allocate(sizeof(UnsafeRingQueue<T>), UnsafeUtility.AlignOf<UnsafeRingQueue<T>>(), allocator);
		}

		internal unsafe static void Free(UnsafeRingQueue<T>* data)
		{
			if (data == null)
			{
				throw new InvalidOperationException("UnsafeRingQueue has yet to be created or has been destroyed!");
			}
			AllocatorManager.AllocatorHandle allocator = data->Allocator;
			data->Dispose();
			Memory.Unmanaged.Free(data, allocator);
		}

		public unsafe void Dispose()
		{
			if (IsCreated)
			{
				if (CollectionHelper.ShouldDeallocate(Allocator))
				{
					Memory.Unmanaged.Free(Ptr, Allocator);
					Allocator = AllocatorManager.Invalid;
				}
				Ptr = null;
			}
		}

		public unsafe JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			if (CollectionHelper.ShouldDeallocate(Allocator))
			{
				JobHandle result = new UnsafeDisposeJob
				{
					Ptr = Ptr,
					Allocator = Allocator
				}.Schedule(inputDeps);
				Ptr = null;
				Allocator = AllocatorManager.Invalid;
				return result;
			}
			Ptr = null;
			return inputDeps;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private unsafe bool TryEnqueueInternal(T value)
		{
			if (m_Filled == m_Capacity)
			{
				return false;
			}
			Ptr[m_Write] = value;
			m_Write++;
			if (m_Write == m_Capacity)
			{
				m_Write = 0;
			}
			m_Filled++;
			return true;
		}

		public bool TryEnqueue(T value)
		{
			return TryEnqueueInternal(value);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void ThrowQueueFull()
		{
			throw new InvalidOperationException("Trying to enqueue into full queue.");
		}

		public void Enqueue(T value)
		{
			TryEnqueueInternal(value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private unsafe bool TryDequeueInternal(out T item)
		{
			item = Ptr[m_Read];
			if (m_Filled == 0)
			{
				return false;
			}
			m_Read++;
			if (m_Read == m_Capacity)
			{
				m_Read = 0;
			}
			m_Filled--;
			return true;
		}

		public bool TryDequeue(out T item)
		{
			return TryDequeueInternal(out item);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void ThrowQueueEmpty()
		{
			throw new InvalidOperationException("Trying to dequeue from an empty queue");
		}

		public T Dequeue()
		{
			TryDequeueInternal(out var item);
			return item;
		}
	}
	internal sealed class UnsafeRingQueueDebugView<T> where T : unmanaged
	{
		private UnsafeRingQueue<T> Data;

		public unsafe T[] Items
		{
			get
			{
				T[] array = new T[Data.Length];
				int read = Data.m_Read;
				int capacity = Data.m_Capacity;
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = Data.Ptr[(read + i) % capacity];
				}
				return array;
			}
		}

		public UnsafeRingQueueDebugView(UnsafeRingQueue<T> data)
		{
			Data = data;
		}
	}
	[GenerateTestsForBurstCompatibility]
	public struct UnsafeScratchAllocator
	{
		private unsafe void* m_Pointer;

		private int m_LengthInBytes;

		private readonly int m_CapacityInBytes;

		public unsafe UnsafeScratchAllocator(void* ptr, int capacityInBytes)
		{
			m_Pointer = ptr;
			m_LengthInBytes = 0;
			m_CapacityInBytes = capacityInBytes;
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckAllocationDoesNotExceedCapacity(ulong requestedSize)
		{
			if (requestedSize > (ulong)m_CapacityInBytes)
			{
				throw new ArgumentException($"Cannot allocate more than provided size in UnsafeScratchAllocator. Requested: {requestedSize} Size: {m_LengthInBytes} Capacity: {m_CapacityInBytes}");
			}
		}

		public unsafe void* Allocate(int sizeInBytes, int alignmentInBytes)
		{
			if (sizeInBytes == 0)
			{
				return null;
			}
			ulong num = (ulong)(alignmentInBytes - 1);
			long num2 = ((long)(IntPtr)m_Pointer + m_LengthInBytes + (long)num) & (long)(~num);
			long num3 = (byte*)(void*)(IntPtr)num2 - (byte*)m_Pointer;
			num3 += sizeInBytes;
			m_LengthInBytes = (int)num3;
			return (void*)(IntPtr)num2;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe void* Allocate<T>(int count = 1) where T : unmanaged
		{
			return Allocate(UnsafeUtility.SizeOf<T>() * count, UnsafeUtility.AlignOf<T>());
		}
	}
	[GenerateTestsForBurstCompatibility]
	internal struct UnsafeStreamBlock
	{
		internal unsafe UnsafeStreamBlock* Next;

		internal unsafe fixed byte Data[1];
	}
	[GenerateTestsForBurstCompatibility]
	internal struct UnsafeStreamRange
	{
		internal unsafe UnsafeStreamBlock* Block;

		internal int OffsetInFirstBlock;

		internal int ElementCount;

		internal int LastOffset;

		internal int NumberOfBlocks;
	}
	[GenerateTestsForBurstCompatibility]
	internal struct UnsafeStreamBlockData
	{
		internal const int AllocationSize = 4096;

		internal AllocatorManager.AllocatorHandle Allocator;

		internal unsafe UnsafeStreamBlock** Blocks;

		internal int BlockCount;

		internal AllocatorManager.Block Ranges;

		internal int RangeCount;

		internal unsafe UnsafeStreamBlock* Allocate(UnsafeStreamBlock* oldBlock, int threadIndex)
		{
			Assert.IsTrue(threadIndex < BlockCount && threadIndex >= 0);
			UnsafeStreamBlock* ptr = (UnsafeStreamBlock*)Memory.Unmanaged.Array.Resize(null, 0L, 4096L, Allocator, 1L, 16);
			ptr->Next = null;
			if (oldBlock == null)
			{
				ptr->Next = Blocks[threadIndex];
				Blocks[threadIndex] = ptr;
			}
			else
			{
				ptr->Next = oldBlock->Next;
				oldBlock->Next = ptr;
			}
			return ptr;
		}

		internal unsafe void Free(UnsafeStreamBlock* oldBlock)
		{
			Memory.Unmanaged.Array.Resize(oldBlock, 4096L, 0L, Allocator, 1L, 16);
		}
	}
	[GenerateTestsForBurstCompatibility]
	public struct UnsafeStream : INativeDisposable, IDisposable
	{
		[BurstCompile]
		private struct DisposeJob : IJob
		{
			public UnsafeStream Container;

			public void Execute()
			{
				Container.Deallocate();
			}
		}

		[BurstCompile]
		private struct ConstructJobList : IJob
		{
			public UnsafeStream Container;

			[ReadOnly]
			[NativeDisableUnsafePtrRestriction]
			public unsafe UntypedUnsafeList* List;

			public unsafe void Execute()
			{
				Container.AllocateForEach(List->m_length);
			}
		}

		[BurstCompile]
		private struct ConstructJob : IJob
		{
			public UnsafeStream Container;

			[ReadOnly]
			public NativeArray<int> Length;

			public void Execute()
			{
				Container.AllocateForEach(Length[0]);
			}
		}

		[GenerateTestsForBurstCompatibility]
		public struct Writer
		{
			[NativeDisableUnsafePtrRestriction]
			internal AllocatorManager.Block m_BlockData;

			[NativeDisableUnsafePtrRestriction]
			private unsafe UnsafeStreamBlock* m_CurrentBlock;

			[NativeDisableUnsafePtrRestriction]
			private unsafe byte* m_CurrentPtr;

			[NativeDisableUnsafePtrRestriction]
			private unsafe byte* m_CurrentBlockEnd;

			internal int m_ForeachIndex;

			private int m_ElementCount;

			[NativeDisableUnsafePtrRestriction]
			private unsafe UnsafeStreamBlock* m_FirstBlock;

			private int m_FirstOffset;

			private int m_NumberOfBlocks;

			[NativeSetThreadIndex]
			private int m_ThreadIndex;

			public unsafe int ForEachCount => ((UnsafeStreamBlockData*)(void*)m_BlockData.Range.Pointer)->RangeCount;

			internal unsafe Writer(ref UnsafeStream stream)
			{
				m_BlockData = stream.m_BlockData;
				m_ForeachIndex = int.MinValue;
				m_ElementCount = -1;
				m_CurrentBlock = null;
				m_CurrentBlockEnd = null;
				m_CurrentPtr = null;
				m_FirstBlock = null;
				m_NumberOfBlocks = 0;
				m_FirstOffset = 0;
				m_ThreadIndex = 0;
			}

			public unsafe void BeginForEachIndex(int foreachIndex)
			{
				m_ForeachIndex = foreachIndex;
				m_ElementCount = 0;
				m_NumberOfBlocks = 0;
				m_FirstBlock = m_CurrentBlock;
				m_FirstOffset = (int)(m_CurrentPtr - (byte*)m_CurrentBlock);
			}

			public unsafe void EndForEachIndex()
			{
				UnsafeStreamBlockData* ptr = (UnsafeStreamBlockData*)(void*)m_BlockData.Range.Pointer;
				UnsafeStreamRange* ptr2 = (UnsafeStreamRange*)(void*)ptr->Ranges.Range.Pointer;
				ptr2[m_ForeachIndex].ElementCount = m_ElementCount;
				ptr2[m_ForeachIndex].OffsetInFirstBlock = m_FirstOffset;
				ptr2[m_ForeachIndex].Block = m_FirstBlock;
				ptr2[m_ForeachIndex].LastOffset = (int)(m_CurrentPtr - (byte*)m_CurrentBlock);
				ptr2[m_ForeachIndex].NumberOfBlocks = m_NumberOfBlocks;
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public void Write<T>(T value) where T : unmanaged
			{
				Allocate<T>() = value;
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public unsafe ref T Allocate<T>() where T : unmanaged
			{
				int size = UnsafeUtility.SizeOf<T>();
				return ref UnsafeUtility.AsRef<T>(Allocate(size));
			}

			public unsafe byte* Allocate(int size)
			{
				byte* currentPtr = m_CurrentPtr;
				m_CurrentPtr += size;
				if (m_CurrentPtr > m_CurrentBlockEnd)
				{
					UnsafeStreamBlock* currentBlock = m_CurrentBlock;
					UnsafeStreamBlockData* ptr = (UnsafeStreamBlockData*)(void*)m_BlockData.Range.Pointer;
					m_CurrentBlock = ptr->Allocate(currentBlock, m_ThreadIndex);
					m_CurrentPtr = m_CurrentBlock->Data;
					if (m_FirstBlock == null)
					{
						m_FirstOffset = (int)(m_CurrentPtr - (byte*)m_CurrentBlock);
						m_FirstBlock = m_CurrentBlock;
					}
					else
					{
						m_NumberOfBlocks++;
					}
					m_CurrentBlockEnd = (byte*)m_CurrentBlock + 4096;
					currentPtr = m_CurrentPtr;
					m_CurrentPtr += size;
				}
				m_ElementCount++;
				return currentPtr;
			}
		}

		[GenerateTestsForBurstCompatibility]
		public struct Reader
		{
			[NativeDisableUnsafePtrRestriction]
			internal AllocatorManager.Block m_BlockData;

			[NativeDisableUnsafePtrRestriction]
			internal unsafe UnsafeStreamBlock* m_CurrentBlock;

			[NativeDisableUnsafePtrRestriction]
			internal unsafe byte* m_CurrentPtr;

			[NativeDisableUnsafePtrRestriction]
			internal unsafe byte* m_CurrentBlockEnd;

			internal int m_RemainingItemCount;

			internal int m_LastBlockSize;

			public unsafe int ForEachCount => ((UnsafeStreamBlockData*)(void*)m_BlockData.Range.Pointer)->RangeCount;

			public int RemainingItemCount => m_RemainingItemCount;

			internal unsafe Reader(ref UnsafeStream stream)
			{
				m_BlockData = stream.m_BlockData;
				m_CurrentBlock = null;
				m_CurrentPtr = null;
				m_CurrentBlockEnd = null;
				m_RemainingItemCount = 0;
				m_LastBlockSize = 0;
			}

			public unsafe int BeginForEachIndex(int foreachIndex)
			{
				UnsafeStreamBlockData* ptr = (UnsafeStreamBlockData*)(void*)m_BlockData.Range.Pointer;
				UnsafeStreamRange* ptr2 = (UnsafeStreamRange*)(void*)ptr->Ranges.Range.Pointer;
				m_RemainingItemCount = ptr2[foreachIndex].ElementCount;
				m_LastBlockSize = ptr2[foreachIndex].LastOffset;
				m_CurrentBlock = ptr2[foreachIndex].Block;
				m_CurrentPtr = (byte*)m_CurrentBlock + ptr2[foreachIndex].OffsetInFirstBlock;
				m_CurrentBlockEnd = (byte*)m_CurrentBlock + 4096;
				return m_RemainingItemCount;
			}

			public void EndForEachIndex()
			{
			}

			public unsafe byte* ReadUnsafePtr(int size)
			{
				m_RemainingItemCount--;
				byte* currentPtr = m_CurrentPtr;
				m_CurrentPtr += size;
				if (m_CurrentPtr > m_CurrentBlockEnd)
				{
					m_CurrentBlock = m_CurrentBlock->Next;
					m_CurrentPtr = m_CurrentBlock->Data;
					m_CurrentBlockEnd = (byte*)m_CurrentBlock + 4096;
					currentPtr = m_CurrentPtr;
					m_CurrentPtr += size;
				}
				return currentPtr;
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public unsafe ref T Read<T>() where T : unmanaged
			{
				int size = UnsafeUtility.SizeOf<T>();
				return ref UnsafeUtility.AsRef<T>(ReadUnsafePtr(size));
			}

			[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
			public unsafe ref T Peek<T>() where T : unmanaged
			{
				int num = UnsafeUtility.SizeOf<T>();
				byte* ptr = m_CurrentPtr;
				if (ptr + num > m_CurrentBlockEnd)
				{
					ptr = m_CurrentBlock->Next->Data;
				}
				return ref UnsafeUtility.AsRef<T>(ptr);
			}

			public unsafe int Count()
			{
				UnsafeStreamBlockData* ptr = (UnsafeStreamBlockData*)(void*)m_BlockData.Range.Pointer;
				UnsafeStreamRange* ptr2 = (UnsafeStreamRange*)(void*)ptr->Ranges.Range.Pointer;
				int num = 0;
				for (int i = 0; i != ptr->RangeCount; i++)
				{
					num += ptr2[i].ElementCount;
				}
				return num;
			}
		}

		[NativeDisableUnsafePtrRestriction]
		internal AllocatorManager.Block m_BlockData;

		public readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return m_BlockData.Range.Pointer != IntPtr.Zero;
			}
		}

		public unsafe readonly int ForEachCount => ((UnsafeStreamBlockData*)(void*)m_BlockData.Range.Pointer)->RangeCount;

		public UnsafeStream(int bufferCount, AllocatorManager.AllocatorHandle allocator)
		{
			AllocateBlock(out this, allocator);
			AllocateForEach(bufferCount);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static JobHandle ScheduleConstruct<T>(out UnsafeStream stream, NativeList<T> bufferCount, JobHandle dependency, AllocatorManager.AllocatorHandle allocator) where T : unmanaged
		{
			AllocateBlock(out stream, allocator);
			return new ConstructJobList
			{
				List = (UntypedUnsafeList*)bufferCount.GetUnsafeList(),
				Container = stream
			}.Schedule(dependency);
		}

		public static JobHandle ScheduleConstruct(out UnsafeStream stream, NativeArray<int> bufferCount, JobHandle dependency, AllocatorManager.AllocatorHandle allocator)
		{
			AllocateBlock(out stream, allocator);
			return new ConstructJob
			{
				Length = bufferCount,
				Container = stream
			}.Schedule(dependency);
		}

		internal unsafe static void AllocateBlock(out UnsafeStream stream, AllocatorManager.AllocatorHandle allocator)
		{
			int threadIndexCount = JobsUtility.ThreadIndexCount;
			int sizeOf = sizeof(UnsafeStreamBlockData) + sizeof(UnsafeStreamBlock*) * threadIndexCount;
			AllocatorManager.Block blockData = AllocatorManager.AllocateBlock(ref allocator, sizeOf, 16, 1);
			UnsafeUtility.MemClear((void*)blockData.Range.Pointer, blockData.AllocatedBytes);
			stream.m_BlockData = blockData;
			UnsafeStreamBlockData* ptr = (UnsafeStreamBlockData*)(void*)blockData.Range.Pointer;
			ptr->Allocator = allocator;
			ptr->BlockCount = threadIndexCount;
			ptr->Blocks = (UnsafeStreamBlock**)(void*)(blockData.Range.Pointer + sizeof(UnsafeStreamBlockData));
			ptr->Ranges = default(AllocatorManager.Block);
			ptr->RangeCount = 0;
		}

		internal unsafe void AllocateForEach(int forEachCount)
		{
			UnsafeStreamBlockData* ptr = (UnsafeStreamBlockData*)(void*)m_BlockData.Range.Pointer;
			ptr->Ranges = AllocatorManager.AllocateBlock(ref m_BlockData.Range.Allocator, sizeof(UnsafeStreamRange), 16, forEachCount);
			ptr->RangeCount = forEachCount;
			UnsafeUtility.MemClear((void*)ptr->Ranges.Range.Pointer, ptr->Ranges.AllocatedBytes);
		}

		public unsafe readonly bool IsEmpty()
		{
			if (!IsCreated)
			{
				return true;
			}
			UnsafeStreamBlockData* ptr = (UnsafeStreamBlockData*)(void*)m_BlockData.Range.Pointer;
			UnsafeStreamRange* ptr2 = (UnsafeStreamRange*)(void*)ptr->Ranges.Range.Pointer;
			for (int i = 0; i != ptr->RangeCount; i++)
			{
				if (ptr2[i].ElementCount > 0)
				{
					return false;
				}
			}
			return true;
		}

		public Reader AsReader()
		{
			return new Reader(ref this);
		}

		public Writer AsWriter()
		{
			return new Writer(ref this);
		}

		public unsafe int Count()
		{
			int num = 0;
			UnsafeStreamBlockData* ptr = (UnsafeStreamBlockData*)(void*)m_BlockData.Range.Pointer;
			UnsafeStreamRange* ptr2 = (UnsafeStreamRange*)(void*)ptr->Ranges.Range.Pointer;
			for (int i = 0; i != ptr->RangeCount; i++)
			{
				num += ptr2[i].ElementCount;
			}
			return num;
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public NativeArray<T> ToNativeArray<T>(AllocatorManager.AllocatorHandle allocator) where T : unmanaged
		{
			NativeArray<T> result = CollectionHelper.CreateNativeArray<T>(Count(), allocator, NativeArrayOptions.UninitializedMemory);
			Reader reader = AsReader();
			int num = 0;
			for (int i = 0; i != reader.ForEachCount; i++)
			{
				reader.BeginForEachIndex(i);
				int remainingItemCount = reader.RemainingItemCount;
				for (int j = 0; j < remainingItemCount; j++)
				{
					result[num] = reader.Read<T>();
					num++;
				}
				reader.EndForEachIndex();
			}
			return result;
		}

		private unsafe void Deallocate()
		{
			if (!IsCreated)
			{
				return;
			}
			UnsafeStreamBlockData* ptr = (UnsafeStreamBlockData*)(void*)m_BlockData.Range.Pointer;
			for (int i = 0; i != ptr->BlockCount; i++)
			{
				UnsafeStreamBlock* ptr2 = ptr->Blocks[i];
				while (ptr2 != null)
				{
					UnsafeStreamBlock* next = ptr2->Next;
					ptr->Free(ptr2);
					ptr2 = next;
				}
			}
			ptr->Ranges.Dispose();
			m_BlockData.Dispose();
			m_BlockData = default(AllocatorManager.Block);
		}

		public void Dispose()
		{
			if (IsCreated)
			{
				Deallocate();
			}
		}

		public JobHandle Dispose(JobHandle inputDeps)
		{
			if (!IsCreated)
			{
				return inputDeps;
			}
			JobHandle result = new DisposeJob
			{
				Container = this
			}.Schedule(inputDeps);
			m_BlockData = default(AllocatorManager.Block);
			return result;
		}
	}
	internal static class UnsafeTextExtensions
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static ref UnsafeList<byte> AsUnsafeListOfBytes(this ref UnsafeText text)
		{
			return ref UnsafeUtility.As<UntypedUnsafeList, UnsafeList<byte>>(ref text.m_UntypedListData);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static UnsafeList<byte> AsUnsafeListOfBytesRO(this UnsafeText text)
		{
			return UnsafeUtility.As<UntypedUnsafeList, UnsafeList<byte>>(ref text.m_UntypedListData);
		}
	}
	[GenerateTestsForBurstCompatibility]
	[DebuggerDisplay("Length = {Length}, Capacity = {Capacity}, IsCreated = {IsCreated}, IsEmpty = {IsEmpty}")]
	public struct UnsafeText : INativeDisposable, IDisposable, IUTF8Bytes, INativeList<byte>, IIndexable<byte>
	{
		internal UntypedUnsafeList m_UntypedListData;

		public readonly bool IsCreated
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return this.AsUnsafeListOfBytesRO().IsCreated;
			}
		}

		public readonly bool IsEmpty
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (IsCreated)
				{
					return Length == 0;
				}
				return true;
			}
		}

		public unsafe byte this[int index]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return UnsafeUtility.ReadArrayElement<byte>(m_UntypedListData.Ptr, index);
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			set
			{
				UnsafeUtility.WriteArrayElement(m_UntypedListData.Ptr, index, value);
			}
		}

		public int Capacity
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return this.AsUnsafeListOfBytesRO().Capacity - 1;
			}
			set
			{
				this.AsUnsafeListOfBytes().SetCapacity(value + 1);
			}
		}

		public int Length
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			readonly get
			{
				return this.AsUnsafeListOfBytesRO().Length - 1;
			}
			set
			{
				this.AsUnsafeListOfBytes().Resize(value + 1);
				this.AsUnsafeListOfBytes()[value] = 0;
			}
		}

		public UnsafeText(int capacity, AllocatorManager.AllocatorHandle allocator)
		{
			m_UntypedListData = default(UntypedUnsafeList);
			this.AsUnsafeListOfBytes() = new UnsafeList<byte>(capacity + 1, allocator);
			Length = 0;
		}

		internal unsafe static UnsafeText* Alloc(AllocatorManager.AllocatorHandle allocator)
		{
			return (UnsafeText*)Memory.Unmanaged.Allocate(sizeof(UnsafeText), UnsafeUtility.AlignOf<UnsafeText>(), allocator);
		}

		internal unsafe static void Free(UnsafeText* data)
		{
			if (data == null)
			{
				throw new InvalidOperationException("UnsafeText has yet to be created or has been destroyed!");
			}
			AllocatorManager.AllocatorHandle allocator = data->m_UntypedListData.Allocator;
			data->Dispose();
			Memory.Unmanaged.Free(data, allocator);
		}

		public void Dispose()
		{
			this.AsUnsafeListOfBytes().Dispose();
		}

		public JobHandle Dispose(JobHandle inputDeps)
		{
			return this.AsUnsafeListOfBytes().Dispose(inputDeps);
		}

		public unsafe ref byte ElementAt(int index)
		{
			return ref UnsafeUtility.ArrayElementAsRef<byte>(m_UntypedListData.Ptr, index);
		}

		public void Clear()
		{
			Length = 0;
		}

		public unsafe byte* GetUnsafePtr()
		{
			return (byte*)m_UntypedListData.Ptr;
		}

		public bool TryResize(int newLength, NativeArrayOptions clearOptions = NativeArrayOptions.ClearMemory)
		{
			this.AsUnsafeListOfBytes().Resize(newLength + 1, clearOptions);
			this.AsUnsafeListOfBytes()[newLength] = 0;
			return true;
		}

		[ExcludeFromBurstCompatTesting("Returns managed string")]
		public override string ToString()
		{
			if (!IsCreated)
			{
				return "";
			}
			return FixedStringMethods.ConvertToString(ref this);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void CheckIndexInRange(int index)
		{
			if (index < 0)
			{
				throw new IndexOutOfRangeException($"Index {index} must be positive.");
			}
			if (index >= Length)
			{
				throw new IndexOutOfRangeException($"Index {index} is out of range in UnsafeText of {Length} length.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private void ThrowCopyError(CopyError error, string source)
		{
			throw new ArgumentException($"UnsafeText: {error} while copying \"{source}\"");
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckCapacityInRange(int value, int length)
		{
			if (value < 0)
			{
				throw new ArgumentOutOfRangeException($"Value {value} must be positive.");
			}
			if ((uint)value < (uint)length)
			{
				throw new ArgumentOutOfRangeException($"Value {value} is out of range in NativeList of '{length}' Length.");
			}
		}
	}
	[GenerateTestsForBurstCompatibility]
	public static class UnsafeUtilityExtensions
	{
		internal unsafe static void MemSwap(void* ptr, void* otherPtr, long size)
		{
			byte* ptr2 = (byte*)ptr;
			byte* ptr3 = (byte*)otherPtr;
			byte* ptr4 = stackalloc byte[1024];
			while (size > 0)
			{
				long num = math.min(size, 1024L);
				UnsafeUtility.MemCpy(ptr4, ptr2, num);
				UnsafeUtility.MemCpy(ptr2, ptr3, num);
				UnsafeUtility.MemCpy(ptr3, ptr4, num);
				size -= num;
				ptr3 += num;
				ptr2 += num;
			}
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static T ReadArrayElementBoundsChecked<T>(void* source, int index, int capacity) where T : unmanaged
		{
			return UnsafeUtility.ReadArrayElement<T>(source, index);
		}

		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static void WriteArrayElementBoundsChecked<T>(void* destination, int index, T value, int capacity) where T : unmanaged
		{
			UnsafeUtility.WriteArrayElement(destination, index, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public unsafe static void* AddressOf<T>(in T value) where T : unmanaged
		{
			return ILSupport.AddressOf(in value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		[GenerateTestsForBurstCompatibility(GenericTypeArguments = new Type[] { typeof(int) })]
		public static ref T AsRef<T>(in T value) where T : unmanaged
		{
			return ref ILSupport.AsRef(in value);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private unsafe static void CheckMemSwapOverlap(byte* dst, byte* src, long size)
		{
			if (dst + size > src && src + size > dst)
			{
				throw new InvalidOperationException("MemSwap memory blocks are overlapped.");
			}
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		[Conditional("UNITY_DOTS_DEBUG")]
		private static void CheckIndexRange(int index, int capacity)
		{
			if (index > capacity - 1 || index < 0)
			{
				throw new IndexOutOfRangeException($"Attempt to read or write from array index {index}, which is out of bounds. Array capacity is {capacity}. " + "This may lead to a crash, data corruption, or reading invalid data.");
			}
		}
	}
}
namespace Unity.Collections.LowLevel.Unsafe.NotBurstCompatible
{
	public static class Extensions
	{
		public static T[] ToArray<T>(this UnsafeParallelHashSet<T> set) where T : unmanaged, IEquatable<T>
		{
			NativeArray<T> nativeArray = set.ToNativeArray(Allocator.TempJob);
			T[] result = nativeArray.ToArray();
			nativeArray.Dispose();
			return result;
		}

		[ExcludeFromBurstCompatTesting("Takes managed string")]
		public unsafe static void AddNBC(this ref UnsafeAppendBuffer buffer, string value)
		{
			if (value != null)
			{
				buffer.Add(value.Length);
				fixed (char* ptr = value)
				{
					buffer.Add(ptr, 2 * value.Length);
				}
			}
			else
			{
				buffer.Add(-1);
			}
		}

		[ExcludeFromBurstCompatTesting("Returns managed array")]
		public unsafe static byte[] ToBytesNBC(this ref UnsafeAppendBuffer buffer)
		{
			byte[] array = new byte[buffer.Length];
			fixed (byte* destination = array)
			{
				UnsafeUtility.MemCpy(destination, buffer.Ptr, buffer.Length);
			}
			return array;
		}

		[ExcludeFromBurstCompatTesting("Managed string out argument")]
		public unsafe static void ReadNextNBC(this ref UnsafeAppendBuffer.Reader reader, out string value)
		{
			reader.ReadNext(out int value2);
			if (value2 != -1)
			{
				value = new string('0', value2);
				fixed (char* destination = value)
				{
					int num = value2 * 2;
					UnsafeUtility.MemCpy(destination, reader.ReadNext(num), num);
				}
			}
			else
			{
				value = null;
			}
		}
	}
}
[DOTSCompilerGenerated]
internal class __JobReflectionRegistrationOutput__1652832624114795843
{
	public static void CreateJobReflectionData()
	{
		try
		{
			IJobExtensions.EarlyJobInit<CollectionHelper.DummyJob>();
			IJobExtensions.EarlyJobInit<NativeBitArrayDisposeJob>();
			IJobExtensions.EarlyJobInit<NativeHashMapDisposeJob>();
			IJobExtensions.EarlyJobInit<NativeListDisposeJob>();
			IJobExtensions.EarlyJobInit<NativeQueueDisposeJob>();
			IJobExtensions.EarlyJobInit<NativeReferenceDisposeJob>();
			IJobExtensions.EarlyJobInit<NativeRingQueueDisposeJob>();
			IJobExtensions.EarlyJobInit<NativeStream.ConstructJobList>();
			IJobExtensions.EarlyJobInit<NativeStream.ConstructJob>();
			IJobExtensions.EarlyJobInit<NativeStreamDisposeJob>();
			IJobExtensions.EarlyJobInit<NativeTextDisposeJob>();
			IJobExtensions.EarlyJobInit<UnsafeQueueDisposeJob>();
			IJobExtensions.EarlyJobInit<UnsafeDisposeJob>();
			IJobExtensions.EarlyJobInit<UnsafeParallelHashMapDataDisposeJob>();
			IJobExtensions.EarlyJobInit<UnsafeParallelHashMapDisposeJob>();
			IJobExtensions.EarlyJobInit<UnsafeStream.DisposeJob>();
			IJobExtensions.EarlyJobInit<UnsafeStream.ConstructJobList>();
			IJobExtensions.EarlyJobInit<UnsafeStream.ConstructJob>();
		}
		catch (Exception ex)
		{
			EarlyInitHelpers.JobReflectionDataCreationFailed(ex);
		}
	}

	[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]
	public static void EarlyInit()
	{
		CreateJobReflectionData();
	}
}
internal static class $BurstDirectCallInitializer
{
	[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]
	private static void Initialize()
	{
		AllocatorManager.Initialize$StackAllocator_Try_000000AB$BurstDirectCall();
		AllocatorManager.Initialize$SlabAllocator_Try_000000B9$BurstDirectCall();
		AutoFreeAllocator.Try_000000E3$BurstDirectCall.Initialize();
		RewindableAllocator.Try_000009DE$BurstDirectCall.Initialize();
		xxHash3.Hash64Long_00000A73$BurstDirectCall.Initialize();
		xxHash3.Hash128Long_00000A7A$BurstDirectCall.Initialize();
	}
}
