using System;
using System.Buffers;
using System.Buffers.Text;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Numerics;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Versioning;
using System.Security;
using System.Security.Permissions;
using System.Text.Encodings.Web;
using System.Text.Json.Nodes;
using System.Text.Json.Reflection;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Converters;
using System.Text.Json.Serialization.Metadata;
using System.Threading;
using System.Threading.Tasks;
using FxResources.System.Text.Json;
using Microsoft.CodeAnalysis;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName = ".NET Standard 2.0")]
[assembly: AssemblyMetadata("Serviceable", "True")]
[assembly: AssemblyMetadata("PreferInbox", "True")]
[assembly: AssemblyDefaultAlias("System.Text.Json")]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: CLSCompliant(true)]
[assembly: AssemblyMetadata("IsTrimmable", "True")]
[assembly: DefaultDllImportSearchPaths(DllImportSearchPath.System32 | DllImportSearchPath.AssemblyDirectory)]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyCopyright("© Microsoft Corporation. All rights reserved.")]
[assembly: AssemblyDescription("Provides high-performance and low-allocating types that serialize objects to JavaScript Object Notation (JSON) text and deserialize JSON text to objects, with UTF-8 support built-in. Also provides types to read and write JSON text encoded as UTF-8, and to create an in-memory document object model (DOM), that is read-only, for random access of the JSON elements within a structured view of the data.\r\n\r\nThe System.Text.Json library is built-in as part of the shared framework in .NET Runtime. The package can be installed when you need to use it in other target frameworks.")]
[assembly: AssemblyFileVersion("8.0.123.58001")]
[assembly: AssemblyInformationalVersion("8.0.1+bf5e279d9239bfef5bb1b8d6212f1b971c434606")]
[assembly: AssemblyProduct("Microsoft® .NET")]
[assembly: AssemblyTitle("System.Text.Json")]
[assembly: AssemblyMetadata("RepositoryUrl", "https://github.com/dotnet/runtime")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("8.0.0.0")]
[module: UnverifiableCode]
[module: RefSafetyRules(11)]
[module: NullablePublicOnly(false)]
namespace Microsoft.CodeAnalysis
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class EmbeddedAttribute : Attribute
	{
	}
}
namespace System.Runtime.CompilerServices
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class IsReadOnlyAttribute : Attribute
	{
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class IsUnmanagedAttribute : Attribute
	{
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class IsByRefLikeAttribute : Attribute
	{
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Parameter | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter, AllowMultiple = false, Inherited = false)]
	internal sealed class NullableAttribute : Attribute
	{
		public readonly byte[] NullableFlags;

		public NullableAttribute(byte P_0)
		{
			NullableFlags = new byte[1] { P_0 };
		}

		public NullableAttribute(byte[] P_0)
		{
			NullableFlags = P_0;
		}
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Interface | AttributeTargets.Delegate, AllowMultiple = false, Inherited = false)]
	internal sealed class NullableContextAttribute : Attribute
	{
		public readonly byte Flag;

		public NullableContextAttribute(byte P_0)
		{
			Flag = P_0;
		}
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Module, AllowMultiple = false, Inherited = false)]
	internal sealed class NullablePublicOnlyAttribute : Attribute
	{
		public readonly bool IncludesInternals;

		public NullablePublicOnlyAttribute(bool P_0)
		{
			IncludesInternals = P_0;
		}
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
	internal sealed class ScopedRefAttribute : Attribute
	{
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Module, AllowMultiple = false, Inherited = false)]
	internal sealed class RefSafetyRulesAttribute : Attribute
	{
		public readonly int Version;

		public RefSafetyRulesAttribute(int P_0)
		{
			Version = P_0;
		}
	}
}
namespace FxResources.System.Text.Json
{
	internal static class SR
	{
	}
}
namespace System
{
	internal static class HexConverter
	{
		public enum Casing : uint
		{
			Upper = 0u,
			Lower = 8224u
		}

		public static ReadOnlySpan<byte> CharToHexLookup => new byte[256]
		{
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 0, 1,
			2, 3, 4, 5, 6, 7, 8, 9, 255, 255,
			255, 255, 255, 255, 255, 10, 11, 12, 13, 14,
			15, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 10, 11, 12,
			13, 14, 15, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255
		};

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ToBytesBuffer(byte value, Span<byte> buffer, int startingIndex = 0, Casing casing = Casing.Upper)
		{
			uint num = (uint)(((value & 0xF0) << 4) + (value & 0xF) - 35209);
			uint num2 = ((((0 - num) & 0x7070) >> 4) + num + 47545) | (uint)casing;
			buffer[startingIndex + 1] = (byte)num2;
			buffer[startingIndex] = (byte)(num2 >> 8);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ToCharsBuffer(byte value, Span<char> buffer, int startingIndex = 0, Casing casing = Casing.Upper)
		{
			uint num = (uint)(((value & 0xF0) << 4) + (value & 0xF) - 35209);
			uint num2 = ((((0 - num) & 0x7070) >> 4) + num + 47545) | (uint)casing;
			buffer[startingIndex + 1] = (char)(num2 & 0xFF);
			buffer[startingIndex] = (char)(num2 >> 8);
		}

		public static void EncodeToUtf16(ReadOnlySpan<byte> bytes, Span<char> chars, Casing casing = Casing.Upper)
		{
			for (int i = 0; i < bytes.Length; i++)
			{
				ToCharsBuffer(bytes[i], chars, i * 2, casing);
			}
		}

		public static string ToString(ReadOnlySpan<byte> bytes, Casing casing = Casing.Upper)
		{
			Span<char> span = ((bytes.Length <= 16) ? stackalloc char[bytes.Length * 2] : MemoryExtensions.AsSpan(new char[bytes.Length * 2]));
			Span<char> buffer = span;
			int num = 0;
			ReadOnlySpan<byte> readOnlySpan = bytes;
			for (int i = 0; i < readOnlySpan.Length; i++)
			{
				byte value = readOnlySpan[i];
				ToCharsBuffer(value, buffer, num, casing);
				num += 2;
			}
			return buffer.ToString();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static char ToCharUpper(int value)
		{
			value &= 0xF;
			value += 48;
			if (value > 57)
			{
				value += 7;
			}
			return (char)value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static char ToCharLower(int value)
		{
			value &= 0xF;
			value += 48;
			if (value > 57)
			{
				value += 39;
			}
			return (char)value;
		}

		public static bool TryDecodeFromUtf16(ReadOnlySpan<char> chars, Span<byte> bytes)
		{
			int charsProcessed;
			return TryDecodeFromUtf16(chars, bytes, out charsProcessed);
		}

		public static bool TryDecodeFromUtf16(ReadOnlySpan<char> chars, Span<byte> bytes, out int charsProcessed)
		{
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			while (num2 < bytes.Length)
			{
				num3 = FromChar(chars[num + 1]);
				num4 = FromChar(chars[num]);
				if ((num3 | num4) == 255)
				{
					break;
				}
				bytes[num2++] = (byte)((num4 << 4) | num3);
				num += 2;
			}
			if (num3 == 255)
			{
				num++;
			}
			charsProcessed = num;
			return (num3 | num4) != 255;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int FromChar(int c)
		{
			if (c < CharToHexLookup.Length)
			{
				return CharToHexLookup[c];
			}
			return 255;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int FromUpperChar(int c)
		{
			if (c <= 71)
			{
				return CharToHexLookup[c];
			}
			return 255;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static int FromLowerChar(int c)
		{
			switch (c)
			{
			case 48:
			case 49:
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 56:
			case 57:
				return c - 48;
			case 97:
			case 98:
			case 99:
			case 100:
			case 101:
			case 102:
				return c - 97 + 10;
			default:
				return 255;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsHexChar(int c)
		{
			if (IntPtr.Size == 8)
			{
				ulong num = (uint)(c - 48);
				ulong num2 = (ulong)(-17875860044349952L << (int)num);
				ulong num3 = num - 64;
				return (long)(num2 & num3) < 0L;
			}
			return FromChar(c) != 255;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsHexUpperChar(int c)
		{
			if ((uint)(c - 48) > 9u)
			{
				return (uint)(c - 65) <= 5u;
			}
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsHexLowerChar(int c)
		{
			if ((uint)(c - 48) > 9u)
			{
				return (uint)(c - 97) <= 5u;
			}
			return true;
		}
	}
	internal static class Obsoletions
	{
		internal const string SharedUrlFormat = "https://aka.ms/dotnet-warnings/{0}";

		internal const string SystemTextEncodingUTF7Message = "The UTF-7 encoding is insecure and should not be used. Consider using UTF-8 instead.";

		internal const string SystemTextEncodingUTF7DiagId = "SYSLIB0001";

		internal const string PrincipalPermissionAttributeMessage = "PrincipalPermissionAttribute is not honored by the runtime and must not be used.";

		internal const string PrincipalPermissionAttributeDiagId = "SYSLIB0002";

		internal const string CodeAccessSecurityMessage = "Code Access Security is not supported or honored by the runtime.";

		internal const string CodeAccessSecurityDiagId = "SYSLIB0003";

		internal const string ConstrainedExecutionRegionMessage = "The Constrained Execution Region (CER) feature is not supported.";

		internal const string ConstrainedExecutionRegionDiagId = "SYSLIB0004";

		internal const string GlobalAssemblyCacheMessage = "The Global Assembly Cache is not supported.";

		internal const string GlobalAssemblyCacheDiagId = "SYSLIB0005";

		internal const string ThreadAbortMessage = "Thread.Abort is not supported and throws PlatformNotSupportedException.";

		internal const string ThreadResetAbortMessage = "Thread.ResetAbort is not supported and throws PlatformNotSupportedException.";

		internal const string ThreadAbortDiagId = "SYSLIB0006";

		internal const string DefaultCryptoAlgorithmsMessage = "The default implementation of this cryptography algorithm is not supported.";

		internal const string DefaultCryptoAlgorithmsDiagId = "SYSLIB0007";

		internal const string CreatePdbGeneratorMessage = "The CreatePdbGenerator API is not supported and throws PlatformNotSupportedException.";

		internal const string CreatePdbGeneratorDiagId = "SYSLIB0008";

		internal const string AuthenticationManagerMessage = "The AuthenticationManager Authenticate and PreAuthenticate methods are not supported and throw PlatformNotSupportedException.";

		internal const string AuthenticationManagerDiagId = "SYSLIB0009";

		internal const string RemotingApisMessage = "This Remoting API is not supported and throws PlatformNotSupportedException.";

		internal const string RemotingApisDiagId = "SYSLIB0010";

		internal const string BinaryFormatterMessage = "BinaryFormatter serialization is obsolete and should not be used. See https://aka.ms/binaryformatter for more information.";

		internal const string BinaryFormatterDiagId = "SYSLIB0011";

		internal const string CodeBaseMessage = "Assembly.CodeBase and Assembly.EscapedCodeBase are only included for .NET Framework compatibility. Use Assembly.Location instead.";

		internal const string CodeBaseDiagId = "SYSLIB0012";

		internal const string EscapeUriStringMessage = "Uri.EscapeUriString can corrupt the Uri string in some cases. Consider using Uri.EscapeDataString for query string components instead.";

		internal const string EscapeUriStringDiagId = "SYSLIB0013";

		internal const string WebRequestMessage = "WebRequest, HttpWebRequest, ServicePoint, and WebClient are obsolete. Use HttpClient instead.";

		internal const string WebRequestDiagId = "SYSLIB0014";

		internal const string DisablePrivateReflectionAttributeMessage = "DisablePrivateReflectionAttribute has no effect in .NET 6.0+.";

		internal const string DisablePrivateReflectionAttributeDiagId = "SYSLIB0015";

		internal const string GetContextInfoMessage = "Use the Graphics.GetContextInfo overloads that accept arguments for better performance and fewer allocations.";

		internal const string GetContextInfoDiagId = "SYSLIB0016";

		internal const string StrongNameKeyPairMessage = "Strong name signing is not supported and throws PlatformNotSupportedException.";

		internal const string StrongNameKeyPairDiagId = "SYSLIB0017";

		internal const string ReflectionOnlyLoadingMessage = "ReflectionOnly loading is not supported and throws PlatformNotSupportedException.";

		internal const string ReflectionOnlyLoadingDiagId = "SYSLIB0018";

		internal const string RuntimeEnvironmentMessage = "RuntimeEnvironment members SystemConfigurationFile, GetRuntimeInterfaceAsIntPtr, and GetRuntimeInterfaceAsObject are not supported and throw PlatformNotSupportedException.";

		internal const string RuntimeEnvironmentDiagId = "SYSLIB0019";

		internal const string JsonSerializerOptionsIgnoreNullValuesMessage = "JsonSerializerOptions.IgnoreNullValues is obsolete. To ignore null values when serializing, set DefaultIgnoreCondition to JsonIgnoreCondition.WhenWritingNull.";

		internal const string JsonSerializerOptionsIgnoreNullValuesDiagId = "SYSLIB0020";

		internal const string DerivedCryptographicTypesMessage = "Derived cryptographic types are obsolete. Use the Create method on the base type instead.";

		internal const string DerivedCryptographicTypesDiagId = "SYSLIB0021";

		internal const string RijndaelMessage = "The Rijndael and RijndaelManaged types are obsolete. Use Aes instead.";

		internal const string RijndaelDiagId = "SYSLIB0022";

		internal const string RNGCryptoServiceProviderMessage = "RNGCryptoServiceProvider is obsolete. To generate a random number, use one of the RandomNumberGenerator static methods instead.";

		internal const string RNGCryptoServiceProviderDiagId = "SYSLIB0023";

		internal const string AppDomainCreateUnloadMessage = "Creating and unloading AppDomains is not supported and throws an exception.";

		internal const string AppDomainCreateUnloadDiagId = "SYSLIB0024";

		internal const string SuppressIldasmAttributeMessage = "SuppressIldasmAttribute has no effect in .NET 6.0+.";

		internal const string SuppressIldasmAttributeDiagId = "SYSLIB0025";

		internal const string X509CertificateImmutableMessage = "X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.";

		internal const string X509CertificateImmutableDiagId = "SYSLIB0026";

		internal const string PublicKeyPropertyMessage = "PublicKey.Key is obsolete. Use the appropriate method to get the public key, such as GetRSAPublicKey.";

		internal const string PublicKeyPropertyDiagId = "SYSLIB0027";

		internal const string X509CertificatePrivateKeyMessage = "X509Certificate2.PrivateKey is obsolete. Use the appropriate method to get the private key, such as GetRSAPrivateKey, or use the CopyWithPrivateKey method to create a new instance with a private key.";

		internal const string X509CertificatePrivateKeyDiagId = "SYSLIB0028";

		internal const string ProduceLegacyHmacValuesMessage = "ProduceLegacyHmacValues is obsolete. Producing legacy HMAC values is not supported.";

		internal const string ProduceLegacyHmacValuesDiagId = "SYSLIB0029";

		internal const string UseManagedSha1Message = "HMACSHA1 always uses the algorithm implementation provided by the platform. Use a constructor without the useManagedSha1 parameter.";

		internal const string UseManagedSha1DiagId = "SYSLIB0030";

		internal const string CryptoConfigEncodeOIDMessage = "EncodeOID is obsolete. Use the ASN.1 functionality provided in System.Formats.Asn1.";

		internal const string CryptoConfigEncodeOIDDiagId = "SYSLIB0031";

		internal const string CorruptedStateRecoveryMessage = "Recovery from corrupted process state exceptions is not supported; HandleProcessCorruptedStateExceptionsAttribute is ignored.";

		internal const string CorruptedStateRecoveryDiagId = "SYSLIB0032";

		internal const string Rfc2898CryptDeriveKeyMessage = "Rfc2898DeriveBytes.CryptDeriveKey is obsolete and is not supported. Use PasswordDeriveBytes.CryptDeriveKey instead.";

		internal const string Rfc2898CryptDeriveKeyDiagId = "SYSLIB0033";

		internal const string CmsSignerCspParamsCtorMessage = "CmsSigner(CspParameters) is obsolete and is not supported. Use an alternative constructor instead.";

		internal const string CmsSignerCspParamsCtorDiagId = "SYSLIB0034";

		internal const string SignerInfoCounterSigMessage = "ComputeCounterSignature without specifying a CmsSigner is obsolete and is not supported. Use the overload that accepts a CmsSigner.";

		internal const string SignerInfoCounterSigDiagId = "SYSLIB0035";

		internal const string RegexCompileToAssemblyMessage = "Regex.CompileToAssembly is obsolete and not supported. Use the GeneratedRegexAttribute with the regular expression source generator instead.";

		internal const string RegexCompileToAssemblyDiagId = "SYSLIB0036";

		internal const string AssemblyNameMembersMessage = "AssemblyName members HashAlgorithm, ProcessorArchitecture, and VersionCompatibility are obsolete and not supported.";

		internal const string AssemblyNameMembersDiagId = "SYSLIB0037";

		internal const string SystemDataSerializationFormatBinaryMessage = "SerializationFormat.Binary is obsolete and should not be used. See https://aka.ms/serializationformat-binary-obsolete for more information.";

		internal const string SystemDataSerializationFormatBinaryDiagId = "SYSLIB0038";

		internal const string TlsVersion10and11Message = "TLS versions 1.0 and 1.1 have known vulnerabilities and are not recommended. Use a newer TLS version instead, or use SslProtocols.None to defer to OS defaults.";

		internal const string TlsVersion10and11DiagId = "SYSLIB0039";

		internal const string EncryptionPolicyMessage = "EncryptionPolicy.NoEncryption and AllowEncryption significantly reduce security and should not be used in production code.";

		internal const string EncryptionPolicyDiagId = "SYSLIB0040";

		internal const string Rfc2898OutdatedCtorMessage = "The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.";

		internal const string Rfc2898OutdatedCtorDiagId = "SYSLIB0041";

		internal const string EccXmlExportImportMessage = "ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.";

		internal const string EccXmlExportImportDiagId = "SYSLIB0042";

		internal const string EcDhPublicKeyBlobMessage = "ECDiffieHellmanPublicKey.ToByteArray() and the associated constructor do not have a consistent and interoperable implementation on all platforms. Use ECDiffieHellmanPublicKey.ExportSubjectPublicKeyInfo() instead.";

		internal const string EcDhPublicKeyBlobDiagId = "SYSLIB0043";

		internal const string AssemblyNameCodeBaseMessage = "AssemblyName.CodeBase and AssemblyName.EscapedCodeBase are obsolete. Using them for loading an assembly is not supported.";

		internal const string AssemblyNameCodeBaseDiagId = "SYSLIB0044";

		internal const string CryptoStringFactoryMessage = "Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.";

		internal const string CryptoStringFactoryDiagId = "SYSLIB0045";

		internal const string ControlledExecutionRunMessage = "ControlledExecution.Run method may corrupt the process and should not be used in production code.";

		internal const string ControlledExecutionRunDiagId = "SYSLIB0046";

		internal const string XmlSecureResolverMessage = "XmlSecureResolver is obsolete. Use XmlResolver.ThrowingResolver instead when attempting to forbid XML external entity resolution.";

		internal const string XmlSecureResolverDiagId = "SYSLIB0047";

		internal const string RsaEncryptDecryptValueMessage = "RSA.EncryptValue and DecryptValue are not supported and throw NotSupportedException. Use RSA.Encrypt and RSA.Decrypt instead.";

		internal const string RsaEncryptDecryptDiagId = "SYSLIB0048";

		internal const string JsonSerializerOptionsAddContextMessage = "JsonSerializerOptions.AddContext is obsolete. To register a JsonSerializerContext, use either the TypeInfoResolver or TypeInfoResolverChain properties.";

		internal const string JsonSerializerOptionsAddContextDiagId = "SYSLIB0049";

		internal const string LegacyFormatterMessage = "Formatter-based serialization is obsolete and should not be used.";

		internal const string LegacyFormatterDiagId = "SYSLIB0050";

		internal const string LegacyFormatterImplMessage = "This API supports obsolete formatter-based serialization. It should not be called or extended by application code.";

		internal const string LegacyFormatterImplDiagId = "SYSLIB0051";

		internal const string RegexExtensibilityImplMessage = "This API supports obsolete mechanisms for Regex extensibility. It is not supported.";

		internal const string RegexExtensibilityDiagId = "SYSLIB0052";

		internal const string AesGcmTagConstructorMessage = "AesGcm should indicate the required tag size for encryption and decryption. Use a constructor that accepts the tag size.";

		internal const string AesGcmTagConstructorDiagId = "SYSLIB0053";
	}
	internal static class SR
	{
		private static readonly bool s_usingResourceKeys = AppContext.TryGetSwitch("System.Resources.UseSystemResourceKeys", out var isEnabled) && isEnabled;

		private static ResourceManager s_resourceManager;

		internal static ResourceManager ResourceManager => s_resourceManager ?? (s_resourceManager = new ResourceManager(typeof(SR)));

		internal static string ArrayDepthTooLarge => GetResourceString("ArrayDepthTooLarge");

		internal static string CallFlushToAvoidDataLoss => GetResourceString("CallFlushToAvoidDataLoss");

		internal static string CannotReadIncompleteUTF16 => GetResourceString("CannotReadIncompleteUTF16");

		internal static string CannotReadInvalidUTF16 => GetResourceString("CannotReadInvalidUTF16");

		internal static string CannotStartObjectArrayAfterPrimitiveOrClose => GetResourceString("CannotStartObjectArrayAfterPrimitiveOrClose");

		internal static string CannotStartObjectArrayWithoutProperty => GetResourceString("CannotStartObjectArrayWithoutProperty");

		internal static string CannotTranscodeInvalidUtf8 => GetResourceString("CannotTranscodeInvalidUtf8");

		internal static string CannotDecodeInvalidBase64 => GetResourceString("CannotDecodeInvalidBase64");

		internal static string CannotTranscodeInvalidUtf16 => GetResourceString("CannotTranscodeInvalidUtf16");

		internal static string CannotEncodeInvalidUTF16 => GetResourceString("CannotEncodeInvalidUTF16");

		internal static string CannotEncodeInvalidUTF8 => GetResourceString("CannotEncodeInvalidUTF8");

		internal static string CannotWritePropertyWithinArray => GetResourceString("CannotWritePropertyWithinArray");

		internal static string CannotWritePropertyAfterProperty => GetResourceString("CannotWritePropertyAfterProperty");

		internal static string CannotWriteValueAfterPrimitiveOrClose => GetResourceString("CannotWriteValueAfterPrimitiveOrClose");

		internal static string CannotWriteValueWithinObject => GetResourceString("CannotWriteValueWithinObject");

		internal static string DepthTooLarge => GetResourceString("DepthTooLarge");

		internal static string DestinationTooShort => GetResourceString("DestinationTooShort");

		internal static string EmptyJsonIsInvalid => GetResourceString("EmptyJsonIsInvalid");

		internal static string EndOfCommentNotFound => GetResourceString("EndOfCommentNotFound");

		internal static string EndOfStringNotFound => GetResourceString("EndOfStringNotFound");

		internal static string ExpectedEndAfterSingleJson => GetResourceString("ExpectedEndAfterSingleJson");

		internal static string ExpectedEndOfDigitNotFound => GetResourceString("ExpectedEndOfDigitNotFound");

		internal static string ExpectedFalse => GetResourceString("ExpectedFalse");

		internal static string ExpectedJsonTokens => GetResourceString("ExpectedJsonTokens");

		internal static string ExpectedOneCompleteToken => GetResourceString("ExpectedOneCompleteToken");

		internal static string ExpectedNextDigitEValueNotFound => GetResourceString("ExpectedNextDigitEValueNotFound");

		internal static string ExpectedNull => GetResourceString("ExpectedNull");

		internal static string ExpectedSeparatorAfterPropertyNameNotFound => GetResourceString("ExpectedSeparatorAfterPropertyNameNotFound");

		internal static string ExpectedStartOfPropertyNotFound => GetResourceString("ExpectedStartOfPropertyNotFound");

		internal static string ExpectedStartOfPropertyOrValueNotFound => GetResourceString("ExpectedStartOfPropertyOrValueNotFound");

		internal static string ExpectedStartOfValueNotFound => GetResourceString("ExpectedStartOfValueNotFound");

		internal static string ExpectedTrue => GetResourceString("ExpectedTrue");

		internal static string ExpectedValueAfterPropertyNameNotFound => GetResourceString("ExpectedValueAfterPropertyNameNotFound");

		internal static string FailedToGetLargerSpan => GetResourceString("FailedToGetLargerSpan");

		internal static string FoundInvalidCharacter => GetResourceString("FoundInvalidCharacter");

		internal static string InvalidCast => GetResourceString("InvalidCast");

		internal static string InvalidCharacterAfterEscapeWithinString => GetResourceString("InvalidCharacterAfterEscapeWithinString");

		internal static string InvalidCharacterWithinString => GetResourceString("InvalidCharacterWithinString");

		internal static string InvalidEnumTypeWithSpecialChar => GetResourceString("InvalidEnumTypeWithSpecialChar");

		internal static string InvalidEndOfJsonNonPrimitive => GetResourceString("InvalidEndOfJsonNonPrimitive");

		internal static string InvalidHexCharacterWithinString => GetResourceString("InvalidHexCharacterWithinString");

		internal static string JsonDocumentDoesNotSupportComments => GetResourceString("JsonDocumentDoesNotSupportComments");

		internal static string JsonElementHasWrongType => GetResourceString("JsonElementHasWrongType");

		internal static string DefaultTypeInfoResolverImmutable => GetResourceString("DefaultTypeInfoResolverImmutable");

		internal static string TypeInfoResolverChainImmutable => GetResourceString("TypeInfoResolverChainImmutable");

		internal static string TypeInfoImmutable => GetResourceString("TypeInfoImmutable");

		internal static string MaxDepthMustBePositive => GetResourceString("MaxDepthMustBePositive");

		internal static string CommentHandlingMustBeValid => GetResourceString("CommentHandlingMustBeValid");

		internal static string MismatchedObjectArray => GetResourceString("MismatchedObjectArray");

		internal static string CannotWriteEndAfterProperty => GetResourceString("CannotWriteEndAfterProperty");

		internal static string ObjectDepthTooLarge => GetResourceString("ObjectDepthTooLarge");

		internal static string PropertyNameTooLarge => GetResourceString("PropertyNameTooLarge");

		internal static string FormatDecimal => GetResourceString("FormatDecimal");

		internal static string FormatDouble => GetResourceString("FormatDouble");

		internal static string FormatInt32 => GetResourceString("FormatInt32");

		internal static string FormatInt64 => GetResourceString("FormatInt64");

		internal static string FormatSingle => GetResourceString("FormatSingle");

		internal static string FormatUInt32 => GetResourceString("FormatUInt32");

		internal static string FormatUInt64 => GetResourceString("FormatUInt64");

		internal static string RequiredDigitNotFoundAfterDecimal => GetResourceString("RequiredDigitNotFoundAfterDecimal");

		internal static string RequiredDigitNotFoundAfterSign => GetResourceString("RequiredDigitNotFoundAfterSign");

		internal static string RequiredDigitNotFoundEndOfData => GetResourceString("RequiredDigitNotFoundEndOfData");

		internal static string SpecialNumberValuesNotSupported => GetResourceString("SpecialNumberValuesNotSupported");

		internal static string ValueTooLarge => GetResourceString("ValueTooLarge");

		internal static string ZeroDepthAtEnd => GetResourceString("ZeroDepthAtEnd");

		internal static string DeserializeUnableToConvertValue => GetResourceString("DeserializeUnableToConvertValue");

		internal static string DeserializeWrongType => GetResourceString("DeserializeWrongType");

		internal static string SerializationInvalidBufferSize => GetResourceString("SerializationInvalidBufferSize");

		internal static string BufferWriterAdvancedTooFar => GetResourceString("BufferWriterAdvancedTooFar");

		internal static string InvalidComparison => GetResourceString("InvalidComparison");

		internal static string UnsupportedFormat => GetResourceString("UnsupportedFormat");

		internal static string ExpectedStartOfPropertyOrValueAfterComment => GetResourceString("ExpectedStartOfPropertyOrValueAfterComment");

		internal static string TrailingCommaNotAllowedBeforeArrayEnd => GetResourceString("TrailingCommaNotAllowedBeforeArrayEnd");

		internal static string TrailingCommaNotAllowedBeforeObjectEnd => GetResourceString("TrailingCommaNotAllowedBeforeObjectEnd");

		internal static string SerializerOptionsReadOnly => GetResourceString("SerializerOptionsReadOnly");

		internal static string SerializerOptions_InvalidChainedResolver => GetResourceString("SerializerOptions_InvalidChainedResolver");

		internal static string StreamNotWritable => GetResourceString("StreamNotWritable");

		internal static string CannotWriteCommentWithEmbeddedDelimiter => GetResourceString("CannotWriteCommentWithEmbeddedDelimiter");

		internal static string SerializerPropertyNameConflict => GetResourceString("SerializerPropertyNameConflict");

		internal static string SerializerPropertyNameNull => GetResourceString("SerializerPropertyNameNull");

		internal static string SerializationDataExtensionPropertyInvalid => GetResourceString("SerializationDataExtensionPropertyInvalid");

		internal static string SerializationDuplicateTypeAttribute => GetResourceString("SerializationDuplicateTypeAttribute");

		internal static string ExtensionDataConflictsWithUnmappedMemberHandling => GetResourceString("ExtensionDataConflictsWithUnmappedMemberHandling");

		internal static string SerializationNotSupportedType => GetResourceString("SerializationNotSupportedType");

		internal static string TypeRequiresAsyncSerialization => GetResourceString("TypeRequiresAsyncSerialization");

		internal static string InvalidCharacterAtStartOfComment => GetResourceString("InvalidCharacterAtStartOfComment");

		internal static string UnexpectedEndOfDataWhileReadingComment => GetResourceString("UnexpectedEndOfDataWhileReadingComment");

		internal static string CannotSkip => GetResourceString("CannotSkip");

		internal static string NotEnoughData => GetResourceString("NotEnoughData");

		internal static string UnexpectedEndOfLineSeparator => GetResourceString("UnexpectedEndOfLineSeparator");

		internal static string JsonSerializerDoesNotSupportComments => GetResourceString("JsonSerializerDoesNotSupportComments");

		internal static string DeserializeNoConstructor => GetResourceString("DeserializeNoConstructor");

		internal static string DeserializePolymorphicInterface => GetResourceString("DeserializePolymorphicInterface");

		internal static string SerializationConverterOnAttributeNotCompatible => GetResourceString("SerializationConverterOnAttributeNotCompatible");

		internal static string SerializationConverterOnAttributeInvalid => GetResourceString("SerializationConverterOnAttributeInvalid");

		internal static string SerializationConverterRead => GetResourceString("SerializationConverterRead");

		internal static string SerializationConverterNotCompatible => GetResourceString("SerializationConverterNotCompatible");

		internal static string ResolverTypeNotCompatible => GetResourceString("ResolverTypeNotCompatible");

		internal static string ResolverTypeInfoOptionsNotCompatible => GetResourceString("ResolverTypeInfoOptionsNotCompatible");

		internal static string SerializationConverterWrite => GetResourceString("SerializationConverterWrite");

		internal static string NamingPolicyReturnNull => GetResourceString("NamingPolicyReturnNull");

		internal static string SerializationDuplicateAttribute => GetResourceString("SerializationDuplicateAttribute");

		internal static string SerializeUnableToSerialize => GetResourceString("SerializeUnableToSerialize");

		internal static string FormatByte => GetResourceString("FormatByte");

		internal static string FormatInt16 => GetResourceString("FormatInt16");

		internal static string FormatSByte => GetResourceString("FormatSByte");

		internal static string FormatUInt16 => GetResourceString("FormatUInt16");

		internal static string SerializerCycleDetected => GetResourceString("SerializerCycleDetected");

		internal static string InvalidLeadingZeroInNumber => GetResourceString("InvalidLeadingZeroInNumber");

		internal static string MetadataCannotParsePreservedObjectToImmutable => GetResourceString("MetadataCannotParsePreservedObjectToImmutable");

		internal static string MetadataDuplicateIdFound => GetResourceString("MetadataDuplicateIdFound");

		internal static string MetadataIdIsNotFirstProperty => GetResourceString("MetadataIdIsNotFirstProperty");

		internal static string MetadataInvalidReferenceToValueType => GetResourceString("MetadataInvalidReferenceToValueType");

		internal static string MetadataInvalidTokenAfterValues => GetResourceString("MetadataInvalidTokenAfterValues");

		internal static string MetadataPreservedArrayFailed => GetResourceString("MetadataPreservedArrayFailed");

		internal static string MetadataInvalidPropertyInArrayMetadata => GetResourceString("MetadataInvalidPropertyInArrayMetadata");

		internal static string MetadataStandaloneValuesProperty => GetResourceString("MetadataStandaloneValuesProperty");

		internal static string MetadataReferenceCannotContainOtherProperties => GetResourceString("MetadataReferenceCannotContainOtherProperties");

		internal static string MetadataReferenceNotFound => GetResourceString("MetadataReferenceNotFound");

		internal static string MetadataValueWasNotString => GetResourceString("MetadataValueWasNotString");

		internal static string MetadataInvalidPropertyWithLeadingDollarSign => GetResourceString("MetadataInvalidPropertyWithLeadingDollarSign");

		internal static string MetadataUnexpectedProperty => GetResourceString("MetadataUnexpectedProperty");

		internal static string UnmappedJsonProperty => GetResourceString("UnmappedJsonProperty");

		internal static string MetadataDuplicateTypeProperty => GetResourceString("MetadataDuplicateTypeProperty");

		internal static string MultipleMembersBindWithConstructorParameter => GetResourceString("MultipleMembersBindWithConstructorParameter");

		internal static string ConstructorParamIncompleteBinding => GetResourceString("ConstructorParamIncompleteBinding");

		internal static string ObjectWithParameterizedCtorRefMetadataNotSupported => GetResourceString("ObjectWithParameterizedCtorRefMetadataNotSupported");

		internal static string SerializerConverterFactoryReturnsNull => GetResourceString("SerializerConverterFactoryReturnsNull");

		internal static string SerializationNotSupportedParentType => GetResourceString("SerializationNotSupportedParentType");

		internal static string ExtensionDataCannotBindToCtorParam => GetResourceString("ExtensionDataCannotBindToCtorParam");

		internal static string BufferMaximumSizeExceeded => GetResourceString("BufferMaximumSizeExceeded");

		internal static string CannotSerializeInvalidType => GetResourceString("CannotSerializeInvalidType");

		internal static string SerializeTypeInstanceNotSupported => GetResourceString("SerializeTypeInstanceNotSupported");

		internal static string JsonIncludeOnInaccessibleProperty => GetResourceString("JsonIncludeOnInaccessibleProperty");

		internal static string CannotSerializeInvalidMember => GetResourceString("CannotSerializeInvalidMember");

		internal static string CannotPopulateCollection => GetResourceString("CannotPopulateCollection");

		internal static string ConstructorContainsNullParameterNames => GetResourceString("ConstructorContainsNullParameterNames");

		internal static string DefaultIgnoreConditionAlreadySpecified => GetResourceString("DefaultIgnoreConditionAlreadySpecified");

		internal static string DefaultIgnoreConditionInvalid => GetResourceString("DefaultIgnoreConditionInvalid");

		internal static string DictionaryKeyTypeNotSupported => GetResourceString("DictionaryKeyTypeNotSupported");

		internal static string IgnoreConditionOnValueTypeInvalid => GetResourceString("IgnoreConditionOnValueTypeInvalid");

		internal static string NumberHandlingOnPropertyInvalid => GetResourceString("NumberHandlingOnPropertyInvalid");

		internal static string ConverterCanConvertMultipleTypes => GetResourceString("ConverterCanConvertMultipleTypes");

		internal static string MetadataReferenceOfTypeCannotBeAssignedToType => GetResourceString("MetadataReferenceOfTypeCannotBeAssignedToType");

		internal static string DeserializeUnableToAssignValue => GetResourceString("DeserializeUnableToAssignValue");

		internal static string DeserializeUnableToAssignNull => GetResourceString("DeserializeUnableToAssignNull");

		internal static string SerializerConverterFactoryReturnsJsonConverterFactory => GetResourceString("SerializerConverterFactoryReturnsJsonConverterFactory");

		internal static string SerializerConverterFactoryInvalidArgument => GetResourceString("SerializerConverterFactoryInvalidArgument");

		internal static string NodeElementWrongType => GetResourceString("NodeElementWrongType");

		internal static string NodeElementCannotBeObjectOrArray => GetResourceString("NodeElementCannotBeObjectOrArray");

		internal static string NodeAlreadyHasParent => GetResourceString("NodeAlreadyHasParent");

		internal static string NodeCycleDetected => GetResourceString("NodeCycleDetected");

		internal static string NodeUnableToConvert => GetResourceString("NodeUnableToConvert");

		internal static string NodeUnableToConvertElement => GetResourceString("NodeUnableToConvertElement");

		internal static string NodeValueNotAllowed => GetResourceString("NodeValueNotAllowed");

		internal static string NodeWrongType => GetResourceString("NodeWrongType");

		internal static string NodeParentWrongType => GetResourceString("NodeParentWrongType");

		internal static string NodeDuplicateKey => GetResourceString("NodeDuplicateKey");

		internal static string SerializerContextOptionsReadOnly => GetResourceString("SerializerContextOptionsReadOnly");

		internal static string ConverterForPropertyMustBeValid => GetResourceString("ConverterForPropertyMustBeValid");

		internal static string NoMetadataForType => GetResourceString("NoMetadataForType");

		internal static string AmbiguousMetadataForType => GetResourceString("AmbiguousMetadataForType");

		internal static string CollectionIsReadOnly => GetResourceString("CollectionIsReadOnly");

		internal static string ArrayIndexNegative => GetResourceString("ArrayIndexNegative");

		internal static string ArrayTooSmall => GetResourceString("ArrayTooSmall");

		internal static string NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty => GetResourceString("NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty");

		internal static string NoMetadataForTypeProperties => GetResourceString("NoMetadataForTypeProperties");

		internal static string FieldCannotBeVirtual => GetResourceString("FieldCannotBeVirtual");

		internal static string MissingFSharpCoreMember => GetResourceString("MissingFSharpCoreMember");

		internal static string FSharpDiscriminatedUnionsNotSupported => GetResourceString("FSharpDiscriminatedUnionsNotSupported");

		internal static string Polymorphism_BaseConverterDoesNotSupportMetadata => GetResourceString("Polymorphism_BaseConverterDoesNotSupportMetadata");

		internal static string Polymorphism_DerivedConverterDoesNotSupportMetadata => GetResourceString("Polymorphism_DerivedConverterDoesNotSupportMetadata");

		internal static string Polymorphism_TypeDoesNotSupportPolymorphism => GetResourceString("Polymorphism_TypeDoesNotSupportPolymorphism");

		internal static string Polymorphism_DerivedTypeIsNotSupported => GetResourceString("Polymorphism_DerivedTypeIsNotSupported");

		internal static string Polymorphism_DerivedTypeIsAlreadySpecified => GetResourceString("Polymorphism_DerivedTypeIsAlreadySpecified");

		internal static string Polymorphism_TypeDicriminatorIdIsAlreadySpecified => GetResourceString("Polymorphism_TypeDicriminatorIdIsAlreadySpecified");

		internal static string Polymorphism_InvalidCustomTypeDiscriminatorPropertyName => GetResourceString("Polymorphism_InvalidCustomTypeDiscriminatorPropertyName");

		internal static string Polymorphism_ConfigurationDoesNotSpecifyDerivedTypes => GetResourceString("Polymorphism_ConfigurationDoesNotSpecifyDerivedTypes");

		internal static string Polymorphism_UnrecognizedTypeDiscriminator => GetResourceString("Polymorphism_UnrecognizedTypeDiscriminator");

		internal static string Polymorphism_RuntimeTypeNotSupported => GetResourceString("Polymorphism_RuntimeTypeNotSupported");

		internal static string Polymorphism_RuntimeTypeDiamondAmbiguity => GetResourceString("Polymorphism_RuntimeTypeDiamondAmbiguity");

		internal static string InvalidJsonTypeInfoOperationForKind => GetResourceString("InvalidJsonTypeInfoOperationForKind");

		internal static string CreateObjectConverterNotCompatible => GetResourceString("CreateObjectConverterNotCompatible");

		internal static string JsonPropertyInfoBoundToDifferentParent => GetResourceString("JsonPropertyInfoBoundToDifferentParent");

		internal static string JsonSerializerOptionsNoTypeInfoResolverSpecified => GetResourceString("JsonSerializerOptionsNoTypeInfoResolverSpecified");

		internal static string JsonSerializerIsReflectionDisabled => GetResourceString("JsonSerializerIsReflectionDisabled");

		internal static string JsonPolymorphismOptionsAssociatedWithDifferentJsonTypeInfo => GetResourceString("JsonPolymorphismOptionsAssociatedWithDifferentJsonTypeInfo");

		internal static string JsonPropertyRequiredAndNotDeserializable => GetResourceString("JsonPropertyRequiredAndNotDeserializable");

		internal static string JsonPropertyRequiredAndExtensionData => GetResourceString("JsonPropertyRequiredAndExtensionData");

		internal static string JsonRequiredPropertiesMissing => GetResourceString("JsonRequiredPropertiesMissing");

		internal static string ObjectCreationHandlingPopulateNotSupportedByConverter => GetResourceString("ObjectCreationHandlingPopulateNotSupportedByConverter");

		internal static string ObjectCreationHandlingPropertyMustHaveAGetter => GetResourceString("ObjectCreationHandlingPropertyMustHaveAGetter");

		internal static string ObjectCreationHandlingPropertyValueTypeMustHaveASetter => GetResourceString("ObjectCreationHandlingPropertyValueTypeMustHaveASetter");

		internal static string ObjectCreationHandlingPropertyCannotAllowPolymorphicDeserialization => GetResourceString("ObjectCreationHandlingPropertyCannotAllowPolymorphicDeserialization");

		internal static string ObjectCreationHandlingPropertyCannotAllowReadOnlyMember => GetResourceString("ObjectCreationHandlingPropertyCannotAllowReadOnlyMember");

		internal static string ObjectCreationHandlingPropertyCannotAllowReferenceHandling => GetResourceString("ObjectCreationHandlingPropertyCannotAllowReferenceHandling");

		internal static string ObjectCreationHandlingPropertyDoesNotSupportParameterizedConstructors => GetResourceString("ObjectCreationHandlingPropertyDoesNotSupportParameterizedConstructors");

		internal static string FormatInt128 => GetResourceString("FormatInt128");

		internal static string FormatUInt128 => GetResourceString("FormatUInt128");

		internal static string FormatHalf => GetResourceString("FormatHalf");

		internal static bool UsingResourceKeys()
		{
			return s_usingResourceKeys;
		}

		private static string GetResourceString(string resourceKey)
		{
			if (UsingResourceKeys())
			{
				return resourceKey;
			}
			string result = null;
			try
			{
				result = ResourceManager.GetString(resourceKey);
			}
			catch (MissingManifestResourceException)
			{
			}
			return result;
		}

		private static string GetResourceString(string resourceKey, string defaultString)
		{
			string resourceString = GetResourceString(resourceKey);
			if (!(resourceKey == resourceString) && resourceString != null)
			{
				return resourceString;
			}
			return defaultString;
		}

		internal static string Format(string resourceFormat, object p1)
		{
			if (UsingResourceKeys())
			{
				return string.Join(", ", resourceFormat, p1);
			}
			return string.Format(resourceFormat, p1);
		}

		internal static string Format(string resourceFormat, object p1, object p2)
		{
			if (UsingResourceKeys())
			{
				return string.Join(", ", resourceFormat, p1, p2);
			}
			return string.Format(resourceFormat, p1, p2);
		}

		internal static string Format(string resourceFormat, object p1, object p2, object p3)
		{
			if (UsingResourceKeys())
			{
				return string.Join(", ", resourceFormat, p1, p2, p3);
			}
			return string.Format(resourceFormat, p1, p2, p3);
		}

		internal static string Format(string resourceFormat, params object[] args)
		{
			if (args != null)
			{
				if (UsingResourceKeys())
				{
					return resourceFormat + ", " + string.Join(", ", args);
				}
				return string.Format(resourceFormat, args);
			}
			return resourceFormat;
		}

		internal static string Format(IFormatProvider provider, string resourceFormat, object p1)
		{
			if (UsingResourceKeys())
			{
				return string.Join(", ", resourceFormat, p1);
			}
			return string.Format(provider, resourceFormat, p1);
		}

		internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2)
		{
			if (UsingResourceKeys())
			{
				return string.Join(", ", resourceFormat, p1, p2);
			}
			return string.Format(provider, resourceFormat, p1, p2);
		}

		internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3)
		{
			if (UsingResourceKeys())
			{
				return string.Join(", ", resourceFormat, p1, p2, p3);
			}
			return string.Format(provider, resourceFormat, p1, p2, p3);
		}

		internal static string Format(IFormatProvider provider, string resourceFormat, params object[] args)
		{
			if (args != null)
			{
				if (UsingResourceKeys())
				{
					return resourceFormat + ", " + string.Join(", ", args);
				}
				return string.Format(provider, resourceFormat, args);
			}
			return resourceFormat;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Interface | AttributeTargets.Delegate, Inherited = false)]
	internal sealed class ObsoleteAttribute : Attribute
	{
		public string Message { get; }

		public bool IsError { get; }

		public string DiagnosticId { get; set; }

		public string UrlFormat { get; set; }

		public ObsoleteAttribute()
		{
		}

		public ObsoleteAttribute(string message)
		{
			Message = message;
		}

		public ObsoleteAttribute(string message, bool error)
		{
			Message = message;
			IsError = error;
		}
	}
}
namespace System.Diagnostics.CodeAnalysis
{
	[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Field, AllowMultiple = true, Inherited = false)]
	internal sealed class DynamicDependencyAttribute : Attribute
	{
		public string MemberSignature { get; }

		public DynamicallyAccessedMemberTypes MemberTypes { get; }

		public Type Type { get; }

		public string TypeName { get; }

		public string AssemblyName { get; }

		public string Condition { get; set; }

		public DynamicDependencyAttribute(string memberSignature)
		{
			MemberSignature = memberSignature;
		}

		public DynamicDependencyAttribute(string memberSignature, Type type)
		{
			MemberSignature = memberSignature;
			Type = type;
		}

		public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName)
		{
			MemberSignature = memberSignature;
			TypeName = typeName;
			AssemblyName = assemblyName;
		}

		public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type)
		{
			MemberTypes = memberTypes;
			Type = type;
		}

		public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName)
		{
			MemberTypes = memberTypes;
			TypeName = typeName;
			AssemblyName = assemblyName;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Interface | AttributeTargets.Parameter | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter, Inherited = false)]
	internal sealed class DynamicallyAccessedMembersAttribute : Attribute
	{
		public DynamicallyAccessedMemberTypes MemberTypes { get; }

		public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes)
		{
			MemberTypes = memberTypes;
		}
	}
	[Flags]
	internal enum DynamicallyAccessedMemberTypes
	{
		None = 0,
		PublicParameterlessConstructor = 1,
		PublicConstructors = 3,
		NonPublicConstructors = 4,
		PublicMethods = 8,
		NonPublicMethods = 0x10,
		PublicFields = 0x20,
		NonPublicFields = 0x40,
		PublicNestedTypes = 0x80,
		NonPublicNestedTypes = 0x100,
		PublicProperties = 0x200,
		NonPublicProperties = 0x400,
		PublicEvents = 0x800,
		NonPublicEvents = 0x1000,
		Interfaces = 0x2000,
		All = -1
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Constructor | AttributeTargets.Method, Inherited = false)]
	internal sealed class RequiresUnreferencedCodeAttribute : Attribute
	{
		public string Message { get; }

		public string Url { get; set; }

		public RequiresUnreferencedCodeAttribute(string message)
		{
			Message = message;
		}
	}
	[AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = true)]
	internal sealed class UnconditionalSuppressMessageAttribute : Attribute
	{
		public string Category { get; }

		public string CheckId { get; }

		public string Scope { get; set; }

		public string Target { get; set; }

		public string MessageId { get; set; }

		public string Justification { get; set; }

		public UnconditionalSuppressMessageAttribute(string category, string checkId)
		{
			Category = category;
			CheckId = checkId;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
	internal sealed class StringSyntaxAttribute : Attribute
	{
		public const string CompositeFormat = "CompositeFormat";

		public const string DateOnlyFormat = "DateOnlyFormat";

		public const string DateTimeFormat = "DateTimeFormat";

		public const string EnumFormat = "EnumFormat";

		public const string GuidFormat = "GuidFormat";

		public const string Json = "Json";

		public const string NumericFormat = "NumericFormat";

		public const string Regex = "Regex";

		public const string TimeOnlyFormat = "TimeOnlyFormat";

		public const string TimeSpanFormat = "TimeSpanFormat";

		public const string Uri = "Uri";

		public const string Xml = "Xml";

		public string Syntax { get; }

		public object[] Arguments { get; }

		public StringSyntaxAttribute(string syntax)
		{
			Syntax = syntax;
			Arguments = Array.Empty<object>();
		}

		public StringSyntaxAttribute(string syntax, params object[] arguments)
		{
			Syntax = syntax;
			Arguments = arguments;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Constructor | AttributeTargets.Method, Inherited = false)]
	internal sealed class RequiresDynamicCodeAttribute : Attribute
	{
		public string Message { get; }

		public string Url { get; set; }

		public RequiresDynamicCodeAttribute(string message)
		{
			Message = message;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, Inherited = false)]
	internal sealed class AllowNullAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, Inherited = false)]
	internal sealed class DisallowNullAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, Inherited = false)]
	internal sealed class MaybeNullAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, Inherited = false)]
	internal sealed class NotNullAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
	internal sealed class MaybeNullWhenAttribute : Attribute
	{
		public bool ReturnValue { get; }

		public MaybeNullWhenAttribute(bool returnValue)
		{
			ReturnValue = returnValue;
		}
	}
	[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
	internal sealed class NotNullWhenAttribute : Attribute
	{
		public bool ReturnValue { get; }

		public NotNullWhenAttribute(bool returnValue)
		{
			ReturnValue = returnValue;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]
	internal sealed class NotNullIfNotNullAttribute : Attribute
	{
		public string ParameterName { get; }

		public NotNullIfNotNullAttribute(string parameterName)
		{
			ParameterName = parameterName;
		}
	}
	[AttributeUsage(AttributeTargets.Method, Inherited = false)]
	internal sealed class DoesNotReturnAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
	internal sealed class DoesNotReturnIfAttribute : Attribute
	{
		public bool ParameterValue { get; }

		public DoesNotReturnIfAttribute(bool parameterValue)
		{
			ParameterValue = parameterValue;
		}
	}
	[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
	internal sealed class MemberNotNullAttribute : Attribute
	{
		public string[] Members { get; }

		public MemberNotNullAttribute(string member)
		{
			Members = new string[1] { member };
		}

		public MemberNotNullAttribute(params string[] members)
		{
			Members = members;
		}
	}
	[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
	internal sealed class MemberNotNullWhenAttribute : Attribute
	{
		public bool ReturnValue { get; }

		public string[] Members { get; }

		public MemberNotNullWhenAttribute(bool returnValue, string member)
		{
			ReturnValue = returnValue;
			Members = new string[1] { member };
		}

		public MemberNotNullWhenAttribute(bool returnValue, params string[] members)
		{
			ReturnValue = returnValue;
			Members = members;
		}
	}
}
namespace System.Runtime.InteropServices
{
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
	internal sealed class LibraryImportAttribute : Attribute
	{
		public string LibraryName { get; }

		public string EntryPoint { get; set; }

		public StringMarshalling StringMarshalling { get; set; }

		public Type StringMarshallingCustomType { get; set; }

		public bool SetLastError { get; set; }

		public LibraryImportAttribute(string libraryName)
		{
			LibraryName = libraryName;
		}
	}
	internal enum StringMarshalling
	{
		Custom,
		Utf8,
		Utf16
	}
}
namespace System.Runtime.Versioning
{
	[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Module | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Interface | AttributeTargets.Delegate, Inherited = false)]
	internal sealed class RequiresPreviewFeaturesAttribute : Attribute
	{
		public string Message { get; }

		public string Url { get; set; }

		public RequiresPreviewFeaturesAttribute()
		{
		}

		public RequiresPreviewFeaturesAttribute(string message)
		{
			Message = message;
		}
	}
}
namespace System.Runtime.CompilerServices
{
	[EditorBrowsable(EditorBrowsableState.Never)]
	internal static class IsExternalInit
	{
	}
}
namespace System.Collections.Generic
{
	internal sealed class ReferenceEqualityComparer : IEqualityComparer<object>, IEqualityComparer
	{
		public static ReferenceEqualityComparer Instance { get; } = new ReferenceEqualityComparer();

		private ReferenceEqualityComparer()
		{
		}

		public new bool Equals(object x, object y)
		{
			return x == y;
		}

		public int GetHashCode(object obj)
		{
			return RuntimeHelpers.GetHashCode(obj);
		}
	}
	internal static class StackExtensions
	{
		public static bool TryPeek<T>(this Stack<T> stack, [MaybeNullWhen(false)] out T result)
		{
			if (stack.Count > 0)
			{
				result = stack.Peek();
				return true;
			}
			result = default(T);
			return false;
		}

		public static bool TryPop<T>(this Stack<T> stack, [MaybeNullWhen(false)] out T result)
		{
			if (stack.Count > 0)
			{
				result = stack.Pop();
				return true;
			}
			result = default(T);
			return false;
		}
	}
}
namespace System.Buffers
{
	internal sealed class ArrayBufferWriter<T> : IBufferWriter<T>
	{
		private const int ArrayMaxLength = 2147483591;

		private const int DefaultInitialBufferSize = 256;

		private T[] _buffer;

		private int _index;

		public ReadOnlyMemory<T> WrittenMemory => MemoryExtensions.AsMemory(_buffer, 0, _index);

		public ReadOnlySpan<T> WrittenSpan => MemoryExtensions.AsSpan(_buffer, 0, _index);

		public int WrittenCount => _index;

		public int Capacity => _buffer.Length;

		public int FreeCapacity => _buffer.Length - _index;

		public ArrayBufferWriter()
		{
			_buffer = Array.Empty<T>();
			_index = 0;
		}

		public ArrayBufferWriter(int initialCapacity)
		{
			if (initialCapacity <= 0)
			{
				throw new ArgumentException(null, "initialCapacity");
			}
			_buffer = new T[initialCapacity];
			_index = 0;
		}

		public void Clear()
		{
			MemoryExtensions.AsSpan(_buffer, 0, _index).Clear();
			_index = 0;
		}

		public void ResetWrittenCount()
		{
			_index = 0;
		}

		public void Advance(int count)
		{
			if (count < 0)
			{
				throw new ArgumentException(null, "count");
			}
			if (_index > _buffer.Length - count)
			{
				ThrowInvalidOperationException_AdvancedTooFar(_buffer.Length);
			}
			_index += count;
		}

		public Memory<T> GetMemory(int sizeHint = 0)
		{
			CheckAndResizeBuffer(sizeHint);
			return MemoryExtensions.AsMemory(_buffer, _index);
		}

		public Span<T> GetSpan(int sizeHint = 0)
		{
			CheckAndResizeBuffer(sizeHint);
			return MemoryExtensions.AsSpan(_buffer, _index);
		}

		private void CheckAndResizeBuffer(int sizeHint)
		{
			if (sizeHint < 0)
			{
				throw new ArgumentException("sizeHint");
			}
			if (sizeHint == 0)
			{
				sizeHint = 1;
			}
			if (sizeHint <= FreeCapacity)
			{
				return;
			}
			int num = _buffer.Length;
			int num2 = Math.Max(sizeHint, num);
			if (num == 0)
			{
				num2 = Math.Max(num2, 256);
			}
			int num3 = num + num2;
			if ((uint)num3 > 2147483647u)
			{
				uint num4 = (uint)(num - FreeCapacity + sizeHint);
				if (num4 > 2147483591)
				{
					ThrowOutOfMemoryException(num4);
				}
				num3 = 2147483591;
			}
			Array.Resize(ref _buffer, num3);
		}

		private static void ThrowInvalidOperationException_AdvancedTooFar(int capacity)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.BufferWriterAdvancedTooFar, capacity));
		}

		private static void ThrowOutOfMemoryException(uint capacity)
		{
			throw new OutOfMemoryException(System.SR.Format(System.SR.BufferMaximumSizeExceeded, capacity));
		}
	}
}
namespace System.Buffers.Text
{
	internal enum SequenceValidity
	{
		Empty,
		WellFormed,
		Incomplete,
		Invalid
	}
}
namespace System.Text.Json
{
	internal sealed class PooledByteBufferWriter : IBufferWriter<byte>, IDisposable
	{
		private byte[] _rentedBuffer;

		private int _index;

		private const int MinimumBufferSize = 256;

		public const int MaximumBufferSize = 2147483591;

		public ReadOnlyMemory<byte> WrittenMemory => MemoryExtensions.AsMemory(_rentedBuffer, 0, _index);

		public int WrittenCount => _index;

		public int Capacity => _rentedBuffer.Length;

		public int FreeCapacity => _rentedBuffer.Length - _index;

		private PooledByteBufferWriter()
		{
		}

		public PooledByteBufferWriter(int initialCapacity)
			: this()
		{
			_rentedBuffer = ArrayPool<byte>.Shared.Rent(initialCapacity);
			_index = 0;
		}

		public void Clear()
		{
			ClearHelper();
		}

		public void ClearAndReturnBuffers()
		{
			ClearHelper();
			byte[] rentedBuffer = _rentedBuffer;
			_rentedBuffer = null;
			ArrayPool<byte>.Shared.Return(rentedBuffer);
		}

		private void ClearHelper()
		{
			MemoryExtensions.AsSpan(_rentedBuffer, 0, _index).Clear();
			_index = 0;
		}

		public void Dispose()
		{
			if (_rentedBuffer != null)
			{
				ClearHelper();
				byte[] rentedBuffer = _rentedBuffer;
				_rentedBuffer = null;
				ArrayPool<byte>.Shared.Return(rentedBuffer);
			}
		}

		public void InitializeEmptyInstance(int initialCapacity)
		{
			_rentedBuffer = ArrayPool<byte>.Shared.Rent(initialCapacity);
			_index = 0;
		}

		public static PooledByteBufferWriter CreateEmptyInstanceForCaching()
		{
			return new PooledByteBufferWriter();
		}

		public void Advance(int count)
		{
			_index += count;
		}

		public Memory<byte> GetMemory(int sizeHint = 256)
		{
			CheckAndResizeBuffer(sizeHint);
			return MemoryExtensions.AsMemory(_rentedBuffer, _index);
		}

		public Span<byte> GetSpan(int sizeHint = 256)
		{
			CheckAndResizeBuffer(sizeHint);
			return MemoryExtensions.AsSpan(_rentedBuffer, _index);
		}

		internal Task WriteToStreamAsync(Stream destination, CancellationToken cancellationToken)
		{
			return destination.WriteAsync(_rentedBuffer, 0, _index, cancellationToken);
		}

		internal void WriteToStream(Stream destination)
		{
			destination.Write(_rentedBuffer, 0, _index);
		}

		private void CheckAndResizeBuffer(int sizeHint)
		{
			int num = _rentedBuffer.Length;
			int num2 = num - _index;
			if (_index >= 1073741795)
			{
				sizeHint = Math.Max(sizeHint, 2147483591 - num);
			}
			if (sizeHint <= num2)
			{
				return;
			}
			int num3 = Math.Max(sizeHint, num);
			int num4 = num + num3;
			if ((uint)num4 > 2147483591u)
			{
				num4 = num + sizeHint;
				if ((uint)num4 > 2147483591u)
				{
					ThrowHelper.ThrowOutOfMemoryException_BufferMaximumSizeExceeded((uint)num4);
				}
			}
			byte[] rentedBuffer = _rentedBuffer;
			_rentedBuffer = ArrayPool<byte>.Shared.Rent(num4);
			Span<byte> span = MemoryExtensions.AsSpan(rentedBuffer, 0, _index);
			span.CopyTo(_rentedBuffer);
			span.Clear();
			ArrayPool<byte>.Shared.Return(rentedBuffer);
		}
	}
	internal static class ThrowHelper
	{
		public const string ExceptionSourceValueToRethrowAsJsonException = "System.Text.Json.Rethrowable";

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		public static void ThrowOutOfMemoryException_BufferMaximumSizeExceeded(uint capacity)
		{
			throw new OutOfMemoryException(System.SR.Format(System.SR.BufferMaximumSizeExceeded, capacity));
		}

		[DoesNotReturn]
		public static void ThrowArgumentNullException(string parameterName)
		{
			throw new ArgumentNullException(parameterName);
		}

		[DoesNotReturn]
		public static void ThrowArgumentOutOfRangeException_MaxDepthMustBePositive(string parameterName)
		{
			throw GetArgumentOutOfRangeException(parameterName, System.SR.MaxDepthMustBePositive);
		}

		private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(string parameterName, string message)
		{
			return new ArgumentOutOfRangeException(parameterName, message);
		}

		[DoesNotReturn]
		public static void ThrowArgumentOutOfRangeException_CommentEnumMustBeInRange(string parameterName)
		{
			throw GetArgumentOutOfRangeException(parameterName, System.SR.CommentHandlingMustBeValid);
		}

		[DoesNotReturn]
		public static void ThrowArgumentOutOfRangeException_ArrayIndexNegative(string paramName)
		{
			throw new ArgumentOutOfRangeException(paramName, System.SR.ArrayIndexNegative);
		}

		[DoesNotReturn]
		public static void ThrowArgumentOutOfRangeException_JsonConverterFactory_TypeNotSupported(Type typeToConvert)
		{
			throw new ArgumentOutOfRangeException("typeToConvert", System.SR.Format(System.SR.SerializerConverterFactoryInvalidArgument, typeToConvert.FullName));
		}

		[DoesNotReturn]
		public static void ThrowArgumentException_ArrayTooSmall(string paramName)
		{
			throw new ArgumentException(System.SR.ArrayTooSmall, paramName);
		}

		private static ArgumentException GetArgumentException(string message)
		{
			return new ArgumentException(message);
		}

		[DoesNotReturn]
		public static void ThrowArgumentException(string message)
		{
			throw GetArgumentException(message);
		}

		public static InvalidOperationException GetInvalidOperationException_CallFlushFirst(int _buffered)
		{
			return GetInvalidOperationException(System.SR.Format(System.SR.CallFlushToAvoidDataLoss, _buffered));
		}

		[DoesNotReturn]
		public static void ThrowArgumentException_DestinationTooShort()
		{
			throw GetArgumentException(System.SR.DestinationTooShort);
		}

		[DoesNotReturn]
		public static void ThrowArgumentException_PropertyNameTooLarge(int tokenLength)
		{
			throw GetArgumentException(System.SR.Format(System.SR.PropertyNameTooLarge, tokenLength));
		}

		[DoesNotReturn]
		public static void ThrowArgumentException_ValueTooLarge(long tokenLength)
		{
			throw GetArgumentException(System.SR.Format(System.SR.ValueTooLarge, tokenLength));
		}

		[DoesNotReturn]
		public static void ThrowArgumentException_ValueNotSupported()
		{
			throw GetArgumentException(System.SR.SpecialNumberValuesNotSupported);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_NeedLargerSpan()
		{
			throw GetInvalidOperationException(System.SR.FailedToGetLargerSpan);
		}

		[DoesNotReturn]
		public static void ThrowPropertyNameTooLargeArgumentException(int length)
		{
			throw GetArgumentException(System.SR.Format(System.SR.PropertyNameTooLarge, length));
		}

		[DoesNotReturn]
		public static void ThrowArgumentException(ReadOnlySpan<byte> propertyName, ReadOnlySpan<byte> value)
		{
			if (propertyName.Length > 166666666)
			{
				ThrowArgumentException(System.SR.Format(System.SR.PropertyNameTooLarge, propertyName.Length));
			}
			else
			{
				ThrowArgumentException(System.SR.Format(System.SR.ValueTooLarge, value.Length));
			}
		}

		[DoesNotReturn]
		public static void ThrowArgumentException(ReadOnlySpan<byte> propertyName, ReadOnlySpan<char> value)
		{
			if (propertyName.Length > 166666666)
			{
				ThrowArgumentException(System.SR.Format(System.SR.PropertyNameTooLarge, propertyName.Length));
			}
			else
			{
				ThrowArgumentException(System.SR.Format(System.SR.ValueTooLarge, value.Length));
			}
		}

		[DoesNotReturn]
		public static void ThrowArgumentException(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value)
		{
			if (propertyName.Length > 166666666)
			{
				ThrowArgumentException(System.SR.Format(System.SR.PropertyNameTooLarge, propertyName.Length));
			}
			else
			{
				ThrowArgumentException(System.SR.Format(System.SR.ValueTooLarge, value.Length));
			}
		}

		[DoesNotReturn]
		public static void ThrowArgumentException(ReadOnlySpan<char> propertyName, ReadOnlySpan<char> value)
		{
			if (propertyName.Length > 166666666)
			{
				ThrowArgumentException(System.SR.Format(System.SR.PropertyNameTooLarge, propertyName.Length));
			}
			else
			{
				ThrowArgumentException(System.SR.Format(System.SR.ValueTooLarge, value.Length));
			}
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationOrArgumentException(ReadOnlySpan<byte> propertyName, int currentDepth, int maxDepth)
		{
			currentDepth &= 0x7FFFFFFF;
			if (currentDepth >= maxDepth)
			{
				ThrowInvalidOperationException(System.SR.Format(System.SR.DepthTooLarge, currentDepth, maxDepth));
			}
			else
			{
				ThrowArgumentException(System.SR.Format(System.SR.PropertyNameTooLarge, propertyName.Length));
			}
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException(int currentDepth, int maxDepth)
		{
			currentDepth &= 0x7FFFFFFF;
			ThrowInvalidOperationException(System.SR.Format(System.SR.DepthTooLarge, currentDepth, maxDepth));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException(string message)
		{
			throw GetInvalidOperationException(message);
		}

		private static InvalidOperationException GetInvalidOperationException(string message)
		{
			return new InvalidOperationException(message)
			{
				Source = "System.Text.Json.Rethrowable"
			};
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_DepthNonZeroOrEmptyJson(int currentDepth)
		{
			throw GetInvalidOperationException(currentDepth);
		}

		private static InvalidOperationException GetInvalidOperationException(int currentDepth)
		{
			currentDepth &= 0x7FFFFFFF;
			if (currentDepth != 0)
			{
				return GetInvalidOperationException(System.SR.Format(System.SR.ZeroDepthAtEnd, currentDepth));
			}
			return GetInvalidOperationException(System.SR.EmptyJsonIsInvalid);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationOrArgumentException(ReadOnlySpan<char> propertyName, int currentDepth, int maxDepth)
		{
			currentDepth &= 0x7FFFFFFF;
			if (currentDepth >= maxDepth)
			{
				ThrowInvalidOperationException(System.SR.Format(System.SR.DepthTooLarge, currentDepth, maxDepth));
			}
			else
			{
				ThrowArgumentException(System.SR.Format(System.SR.PropertyNameTooLarge, propertyName.Length));
			}
		}

		public static InvalidOperationException GetInvalidOperationException_ExpectedArray(JsonTokenType tokenType)
		{
			return GetInvalidOperationException("array", tokenType);
		}

		public static InvalidOperationException GetInvalidOperationException_ExpectedObject(JsonTokenType tokenType)
		{
			return GetInvalidOperationException("object", tokenType);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ExpectedNumber(JsonTokenType tokenType)
		{
			throw GetInvalidOperationException("number", tokenType);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ExpectedBoolean(JsonTokenType tokenType)
		{
			throw GetInvalidOperationException("boolean", tokenType);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ExpectedString(JsonTokenType tokenType)
		{
			throw GetInvalidOperationException("string", tokenType);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ExpectedPropertyName(JsonTokenType tokenType)
		{
			throw GetInvalidOperationException("propertyName", tokenType);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ExpectedStringComparison(JsonTokenType tokenType)
		{
			throw GetInvalidOperationException(tokenType);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ExpectedComment(JsonTokenType tokenType)
		{
			throw GetInvalidOperationException("comment", tokenType);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_CannotSkipOnPartial()
		{
			throw GetInvalidOperationException(System.SR.CannotSkip);
		}

		private static InvalidOperationException GetInvalidOperationException(string message, JsonTokenType tokenType)
		{
			return GetInvalidOperationException(System.SR.Format(System.SR.InvalidCast, tokenType, message));
		}

		private static InvalidOperationException GetInvalidOperationException(JsonTokenType tokenType)
		{
			return GetInvalidOperationException(System.SR.Format(System.SR.InvalidComparison, tokenType));
		}

		[DoesNotReturn]
		internal static void ThrowJsonElementWrongTypeException(JsonTokenType expectedType, JsonTokenType actualType)
		{
			throw GetJsonElementWrongTypeException(expectedType.ToValueKind(), actualType.ToValueKind());
		}

		internal static InvalidOperationException GetJsonElementWrongTypeException(JsonValueKind expectedType, JsonValueKind actualType)
		{
			return GetInvalidOperationException(System.SR.Format(System.SR.JsonElementHasWrongType, expectedType, actualType));
		}

		internal static InvalidOperationException GetJsonElementWrongTypeException(string expectedTypeName, JsonValueKind actualType)
		{
			return GetInvalidOperationException(System.SR.Format(System.SR.JsonElementHasWrongType, expectedTypeName, actualType));
		}

		[DoesNotReturn]
		public static void ThrowJsonReaderException(ref Utf8JsonReader json, ExceptionResource resource, byte nextByte = 0, ReadOnlySpan<byte> bytes = default(ReadOnlySpan<byte>))
		{
			throw GetJsonReaderException(ref json, resource, nextByte, bytes);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		public static JsonException GetJsonReaderException(ref Utf8JsonReader json, ExceptionResource resource, byte nextByte, ReadOnlySpan<byte> bytes)
		{
			string resourceString = GetResourceString(ref json, resource, nextByte, JsonHelpers.Utf8GetString(bytes));
			long lineNumber = json.CurrentState._lineNumber;
			long bytePositionInLine = json.CurrentState._bytePositionInLine;
			resourceString += $" LineNumber: {lineNumber} | BytePositionInLine: {bytePositionInLine}.";
			return new JsonReaderException(resourceString, lineNumber, bytePositionInLine);
		}

		private static bool IsPrintable(byte value)
		{
			if (value >= 32)
			{
				return value < 127;
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static string GetPrintableString(byte value)
		{
			if (!IsPrintable(value))
			{
				return $"0x{value:X2}";
			}
			char c = (char)value;
			return c.ToString();
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private static string GetResourceString(ref Utf8JsonReader json, ExceptionResource resource, byte nextByte, string characters)
		{
			string printableString = GetPrintableString(nextByte);
			string result = "";
			switch (resource)
			{
			case ExceptionResource.ArrayDepthTooLarge:
				result = System.SR.Format(System.SR.ArrayDepthTooLarge, json.CurrentState.Options.MaxDepth);
				break;
			case ExceptionResource.MismatchedObjectArray:
				result = System.SR.Format(System.SR.MismatchedObjectArray, printableString);
				break;
			case ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd:
				result = System.SR.TrailingCommaNotAllowedBeforeArrayEnd;
				break;
			case ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd:
				result = System.SR.TrailingCommaNotAllowedBeforeObjectEnd;
				break;
			case ExceptionResource.EndOfStringNotFound:
				result = System.SR.EndOfStringNotFound;
				break;
			case ExceptionResource.RequiredDigitNotFoundAfterSign:
				result = System.SR.Format(System.SR.RequiredDigitNotFoundAfterSign, printableString);
				break;
			case ExceptionResource.RequiredDigitNotFoundAfterDecimal:
				result = System.SR.Format(System.SR.RequiredDigitNotFoundAfterDecimal, printableString);
				break;
			case ExceptionResource.RequiredDigitNotFoundEndOfData:
				result = System.SR.RequiredDigitNotFoundEndOfData;
				break;
			case ExceptionResource.ExpectedEndAfterSingleJson:
				result = System.SR.Format(System.SR.ExpectedEndAfterSingleJson, printableString);
				break;
			case ExceptionResource.ExpectedEndOfDigitNotFound:
				result = System.SR.Format(System.SR.ExpectedEndOfDigitNotFound, printableString);
				break;
			case ExceptionResource.ExpectedNextDigitEValueNotFound:
				result = System.SR.Format(System.SR.ExpectedNextDigitEValueNotFound, printableString);
				break;
			case ExceptionResource.ExpectedSeparatorAfterPropertyNameNotFound:
				result = System.SR.Format(System.SR.ExpectedSeparatorAfterPropertyNameNotFound, printableString);
				break;
			case ExceptionResource.ExpectedStartOfPropertyNotFound:
				result = System.SR.Format(System.SR.ExpectedStartOfPropertyNotFound, printableString);
				break;
			case ExceptionResource.ExpectedStartOfPropertyOrValueNotFound:
				result = System.SR.ExpectedStartOfPropertyOrValueNotFound;
				break;
			case ExceptionResource.ExpectedStartOfPropertyOrValueAfterComment:
				result = System.SR.Format(System.SR.ExpectedStartOfPropertyOrValueAfterComment, printableString);
				break;
			case ExceptionResource.ExpectedStartOfValueNotFound:
				result = System.SR.Format(System.SR.ExpectedStartOfValueNotFound, printableString);
				break;
			case ExceptionResource.ExpectedValueAfterPropertyNameNotFound:
				result = System.SR.ExpectedValueAfterPropertyNameNotFound;
				break;
			case ExceptionResource.FoundInvalidCharacter:
				result = System.SR.Format(System.SR.FoundInvalidCharacter, printableString);
				break;
			case ExceptionResource.InvalidEndOfJsonNonPrimitive:
				result = System.SR.Format(System.SR.InvalidEndOfJsonNonPrimitive, json.TokenType);
				break;
			case ExceptionResource.ObjectDepthTooLarge:
				result = System.SR.Format(System.SR.ObjectDepthTooLarge, json.CurrentState.Options.MaxDepth);
				break;
			case ExceptionResource.ExpectedFalse:
				result = System.SR.Format(System.SR.ExpectedFalse, characters);
				break;
			case ExceptionResource.ExpectedNull:
				result = System.SR.Format(System.SR.ExpectedNull, characters);
				break;
			case ExceptionResource.ExpectedTrue:
				result = System.SR.Format(System.SR.ExpectedTrue, characters);
				break;
			case ExceptionResource.InvalidCharacterWithinString:
				result = System.SR.Format(System.SR.InvalidCharacterWithinString, printableString);
				break;
			case ExceptionResource.InvalidCharacterAfterEscapeWithinString:
				result = System.SR.Format(System.SR.InvalidCharacterAfterEscapeWithinString, printableString);
				break;
			case ExceptionResource.InvalidHexCharacterWithinString:
				result = System.SR.Format(System.SR.InvalidHexCharacterWithinString, printableString);
				break;
			case ExceptionResource.EndOfCommentNotFound:
				result = System.SR.EndOfCommentNotFound;
				break;
			case ExceptionResource.ZeroDepthAtEnd:
				result = System.SR.Format(System.SR.ZeroDepthAtEnd);
				break;
			case ExceptionResource.ExpectedJsonTokens:
				result = System.SR.ExpectedJsonTokens;
				break;
			case ExceptionResource.NotEnoughData:
				result = System.SR.NotEnoughData;
				break;
			case ExceptionResource.ExpectedOneCompleteToken:
				result = System.SR.ExpectedOneCompleteToken;
				break;
			case ExceptionResource.InvalidCharacterAtStartOfComment:
				result = System.SR.Format(System.SR.InvalidCharacterAtStartOfComment, printableString);
				break;
			case ExceptionResource.UnexpectedEndOfDataWhileReadingComment:
				result = System.SR.Format(System.SR.UnexpectedEndOfDataWhileReadingComment);
				break;
			case ExceptionResource.UnexpectedEndOfLineSeparator:
				result = System.SR.Format(System.SR.UnexpectedEndOfLineSeparator);
				break;
			case ExceptionResource.InvalidLeadingZeroInNumber:
				result = System.SR.Format(System.SR.InvalidLeadingZeroInNumber, printableString);
				break;
			}
			return result;
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException(ExceptionResource resource, int currentDepth, int maxDepth, byte token, JsonTokenType tokenType)
		{
			throw GetInvalidOperationException(resource, currentDepth, maxDepth, token, tokenType);
		}

		[DoesNotReturn]
		public static void ThrowArgumentException_InvalidCommentValue()
		{
			throw new ArgumentException(System.SR.CannotWriteCommentWithEmbeddedDelimiter);
		}

		[DoesNotReturn]
		public static void ThrowArgumentException_InvalidUTF8(ReadOnlySpan<byte> value)
		{
			StringBuilder stringBuilder = new StringBuilder();
			int num = Math.Min(value.Length, 10);
			for (int i = 0; i < num; i++)
			{
				byte b = value[i];
				if (IsPrintable(b))
				{
					stringBuilder.Append((char)b);
				}
				else
				{
					stringBuilder.Append($"0x{b:X2}");
				}
			}
			if (num < value.Length)
			{
				stringBuilder.Append("...");
			}
			throw new ArgumentException(System.SR.Format(System.SR.CannotEncodeInvalidUTF8, stringBuilder));
		}

		[DoesNotReturn]
		public static void ThrowArgumentException_InvalidUTF16(int charAsInt)
		{
			throw new ArgumentException(System.SR.Format(System.SR.CannotEncodeInvalidUTF16, $"0x{charAsInt:X2}"));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ReadInvalidUTF16(int charAsInt)
		{
			throw GetInvalidOperationException(System.SR.Format(System.SR.CannotReadInvalidUTF16, $"0x{charAsInt:X2}"));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ReadIncompleteUTF16()
		{
			throw GetInvalidOperationException(System.SR.CannotReadIncompleteUTF16);
		}

		public static InvalidOperationException GetInvalidOperationException_ReadInvalidUTF8(DecoderFallbackException innerException = null)
		{
			return GetInvalidOperationException(System.SR.CannotTranscodeInvalidUtf8, innerException);
		}

		public static ArgumentException GetArgumentException_ReadInvalidUTF16(EncoderFallbackException innerException)
		{
			return new ArgumentException(System.SR.CannotTranscodeInvalidUtf16, innerException);
		}

		public static InvalidOperationException GetInvalidOperationException(string message, Exception innerException)
		{
			InvalidOperationException ex = new InvalidOperationException(message, innerException);
			ex.Source = "System.Text.Json.Rethrowable";
			return ex;
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		public static InvalidOperationException GetInvalidOperationException(ExceptionResource resource, int currentDepth, int maxDepth, byte token, JsonTokenType tokenType)
		{
			string resourceString = GetResourceString(resource, currentDepth, maxDepth, token, tokenType);
			InvalidOperationException invalidOperationException = GetInvalidOperationException(resourceString);
			invalidOperationException.Source = "System.Text.Json.Rethrowable";
			return invalidOperationException;
		}

		[DoesNotReturn]
		public static void ThrowOutOfMemoryException(uint capacity)
		{
			throw new OutOfMemoryException(System.SR.Format(System.SR.BufferMaximumSizeExceeded, capacity));
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private static string GetResourceString(ExceptionResource resource, int currentDepth, int maxDepth, byte token, JsonTokenType tokenType)
		{
			string result = "";
			switch (resource)
			{
			case ExceptionResource.MismatchedObjectArray:
				result = ((tokenType == JsonTokenType.PropertyName) ? System.SR.Format(System.SR.CannotWriteEndAfterProperty, (char)token) : System.SR.Format(System.SR.MismatchedObjectArray, (char)token));
				break;
			case ExceptionResource.DepthTooLarge:
				result = System.SR.Format(System.SR.DepthTooLarge, currentDepth & 0x7FFFFFFF, maxDepth);
				break;
			case ExceptionResource.CannotStartObjectArrayWithoutProperty:
				result = System.SR.Format(System.SR.CannotStartObjectArrayWithoutProperty, tokenType);
				break;
			case ExceptionResource.CannotStartObjectArrayAfterPrimitiveOrClose:
				result = System.SR.Format(System.SR.CannotStartObjectArrayAfterPrimitiveOrClose, tokenType);
				break;
			case ExceptionResource.CannotWriteValueWithinObject:
				result = System.SR.Format(System.SR.CannotWriteValueWithinObject, tokenType);
				break;
			case ExceptionResource.CannotWritePropertyWithinArray:
				result = ((tokenType == JsonTokenType.PropertyName) ? System.SR.Format(System.SR.CannotWritePropertyAfterProperty) : System.SR.Format(System.SR.CannotWritePropertyWithinArray, tokenType));
				break;
			case ExceptionResource.CannotWriteValueAfterPrimitiveOrClose:
				result = System.SR.Format(System.SR.CannotWriteValueAfterPrimitiveOrClose, tokenType);
				break;
			}
			return result;
		}

		[DoesNotReturn]
		public static void ThrowFormatException()
		{
			throw new FormatException
			{
				Source = "System.Text.Json.Rethrowable"
			};
		}

		public static void ThrowFormatException(NumericType numericType)
		{
			string message = "";
			switch (numericType)
			{
			case NumericType.Byte:
				message = System.SR.FormatByte;
				break;
			case NumericType.SByte:
				message = System.SR.FormatSByte;
				break;
			case NumericType.Int16:
				message = System.SR.FormatInt16;
				break;
			case NumericType.Int32:
				message = System.SR.FormatInt32;
				break;
			case NumericType.Int64:
				message = System.SR.FormatInt64;
				break;
			case NumericType.Int128:
				message = System.SR.FormatInt128;
				break;
			case NumericType.UInt16:
				message = System.SR.FormatUInt16;
				break;
			case NumericType.UInt32:
				message = System.SR.FormatUInt32;
				break;
			case NumericType.UInt64:
				message = System.SR.FormatUInt64;
				break;
			case NumericType.UInt128:
				message = System.SR.FormatUInt128;
				break;
			case NumericType.Half:
				message = System.SR.FormatHalf;
				break;
			case NumericType.Single:
				message = System.SR.FormatSingle;
				break;
			case NumericType.Double:
				message = System.SR.FormatDouble;
				break;
			case NumericType.Decimal:
				message = System.SR.FormatDecimal;
				break;
			}
			throw new FormatException(message)
			{
				Source = "System.Text.Json.Rethrowable"
			};
		}

		[DoesNotReturn]
		public static void ThrowFormatException(DataType dataType)
		{
			string message = "";
			switch (dataType)
			{
			case DataType.Boolean:
			case DataType.DateOnly:
			case DataType.DateTime:
			case DataType.DateTimeOffset:
			case DataType.TimeOnly:
			case DataType.TimeSpan:
			case DataType.Guid:
			case DataType.Version:
				message = System.SR.Format(System.SR.UnsupportedFormat, dataType);
				break;
			case DataType.Base64String:
				message = System.SR.CannotDecodeInvalidBase64;
				break;
			}
			throw new FormatException(message)
			{
				Source = "System.Text.Json.Rethrowable"
			};
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ExpectedChar(JsonTokenType tokenType)
		{
			throw GetInvalidOperationException("char", tokenType);
		}

		[DoesNotReturn]
		public static void ThrowObjectDisposedException_Utf8JsonWriter()
		{
			throw new ObjectDisposedException("Utf8JsonWriter");
		}

		[DoesNotReturn]
		public static void ThrowObjectDisposedException_JsonDocument()
		{
			throw new ObjectDisposedException("JsonDocument");
		}

		[DoesNotReturn]
		public static void ThrowArgumentException_NodeValueNotAllowed(string paramName)
		{
			throw new ArgumentException(System.SR.NodeValueNotAllowed, paramName);
		}

		[DoesNotReturn]
		public static void ThrowArgumentException_DuplicateKey(string paramName, string propertyName)
		{
			throw new ArgumentException(System.SR.Format(System.SR.NodeDuplicateKey, propertyName), paramName);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_NodeAlreadyHasParent()
		{
			throw new InvalidOperationException(System.SR.NodeAlreadyHasParent);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_NodeCycleDetected()
		{
			throw new InvalidOperationException(System.SR.NodeCycleDetected);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_NodeElementCannotBeObjectOrArray()
		{
			throw new InvalidOperationException(System.SR.NodeElementCannotBeObjectOrArray);
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException_CollectionIsReadOnly()
		{
			throw GetNotSupportedException_CollectionIsReadOnly();
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_NodeWrongType(string typeName)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.NodeWrongType, typeName));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_NodeParentWrongType(string typeName)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.NodeParentWrongType, typeName));
		}

		public static NotSupportedException GetNotSupportedException_CollectionIsReadOnly()
		{
			return new NotSupportedException(System.SR.CollectionIsReadOnly);
		}

		[DoesNotReturn]
		public static void ThrowArgumentException_DeserializeWrongType(Type type, object value)
		{
			throw new ArgumentException(System.SR.Format(System.SR.DeserializeWrongType, type, value.GetType()));
		}

		[DoesNotReturn]
		public static void ThrowArgumentException_SerializerDoesNotSupportComments(string paramName)
		{
			throw new ArgumentException(System.SR.JsonSerializerDoesNotSupportComments, paramName);
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException_SerializationNotSupported(Type propertyType)
		{
			throw new NotSupportedException(System.SR.Format(System.SR.SerializationNotSupportedType, propertyType));
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException_TypeRequiresAsyncSerialization(Type propertyType)
		{
			throw new NotSupportedException(System.SR.Format(System.SR.TypeRequiresAsyncSerialization, propertyType));
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException_DictionaryKeyTypeNotSupported(Type keyType, JsonConverter converter)
		{
			throw new NotSupportedException(System.SR.Format(System.SR.DictionaryKeyTypeNotSupported, keyType, converter.GetType()));
		}

		[DoesNotReturn]
		public static void ThrowJsonException_DeserializeUnableToConvertValue(Type propertyType)
		{
			throw new JsonException(System.SR.Format(System.SR.DeserializeUnableToConvertValue, propertyType))
			{
				AppendPathInformation = true
			};
		}

		[DoesNotReturn]
		public static void ThrowInvalidCastException_DeserializeUnableToAssignValue(Type typeOfValue, Type declaredType)
		{
			throw new InvalidCastException(System.SR.Format(System.SR.DeserializeUnableToAssignValue, typeOfValue, declaredType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_DeserializeUnableToAssignNull(Type declaredType)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.DeserializeUnableToAssignNull, declaredType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ObjectCreationHandlingPopulateNotSupportedByConverter(JsonPropertyInfo propertyInfo)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.ObjectCreationHandlingPopulateNotSupportedByConverter, propertyInfo.Name, propertyInfo.DeclaringType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ObjectCreationHandlingPropertyMustHaveAGetter(JsonPropertyInfo propertyInfo)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.ObjectCreationHandlingPropertyMustHaveAGetter, propertyInfo.Name, propertyInfo.DeclaringType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ObjectCreationHandlingPropertyValueTypeMustHaveASetter(JsonPropertyInfo propertyInfo)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.ObjectCreationHandlingPropertyValueTypeMustHaveASetter, propertyInfo.Name, propertyInfo.DeclaringType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ObjectCreationHandlingPropertyCannotAllowPolymorphicDeserialization(JsonPropertyInfo propertyInfo)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.ObjectCreationHandlingPropertyCannotAllowPolymorphicDeserialization, propertyInfo.Name, propertyInfo.DeclaringType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ObjectCreationHandlingPropertyCannotAllowReadOnlyMember(JsonPropertyInfo propertyInfo)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.ObjectCreationHandlingPropertyCannotAllowReadOnlyMember, propertyInfo.Name, propertyInfo.DeclaringType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ObjectCreationHandlingPropertyCannotAllowReferenceHandling()
		{
			throw new InvalidOperationException(System.SR.ObjectCreationHandlingPropertyCannotAllowReferenceHandling);
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException_ObjectCreationHandlingPropertyDoesNotSupportParameterizedConstructors()
		{
			throw new NotSupportedException(System.SR.ObjectCreationHandlingPropertyDoesNotSupportParameterizedConstructors);
		}

		[DoesNotReturn]
		public static void ThrowJsonException_SerializationConverterRead(JsonConverter converter)
		{
			throw new JsonException(System.SR.Format(System.SR.SerializationConverterRead, converter))
			{
				AppendPathInformation = true
			};
		}

		[DoesNotReturn]
		public static void ThrowJsonException_SerializationConverterWrite(JsonConverter converter)
		{
			throw new JsonException(System.SR.Format(System.SR.SerializationConverterWrite, converter))
			{
				AppendPathInformation = true
			};
		}

		[DoesNotReturn]
		public static void ThrowJsonException_SerializerCycleDetected(int maxDepth)
		{
			throw new JsonException(System.SR.Format(System.SR.SerializerCycleDetected, maxDepth))
			{
				AppendPathInformation = true
			};
		}

		[DoesNotReturn]
		public static void ThrowJsonException(string message = null)
		{
			throw new JsonException(message)
			{
				AppendPathInformation = true
			};
		}

		[DoesNotReturn]
		public static void ThrowArgumentException_CannotSerializeInvalidType(string paramName, Type typeToConvert, Type declaringType, string propertyName)
		{
			if (declaringType == null)
			{
				throw new ArgumentException(System.SR.Format(System.SR.CannotSerializeInvalidType, typeToConvert), paramName);
			}
			throw new ArgumentException(System.SR.Format(System.SR.CannotSerializeInvalidMember, typeToConvert, propertyName, declaringType), paramName);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_CannotSerializeInvalidType(Type typeToConvert, Type declaringType, MemberInfo memberInfo)
		{
			if (declaringType == null)
			{
				throw new InvalidOperationException(System.SR.Format(System.SR.CannotSerializeInvalidType, typeToConvert));
			}
			throw new InvalidOperationException(System.SR.Format(System.SR.CannotSerializeInvalidMember, typeToConvert, memberInfo.Name, declaringType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_SerializationConverterNotCompatible(Type converterType, Type type)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.SerializationConverterNotCompatible, converterType, type));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ResolverTypeNotCompatible(Type requestedType, Type actualType)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.ResolverTypeNotCompatible, actualType, requestedType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ResolverTypeInfoOptionsNotCompatible()
		{
			throw new InvalidOperationException(System.SR.ResolverTypeInfoOptionsNotCompatible);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_JsonSerializerOptionsNoTypeInfoResolverSpecified()
		{
			throw new InvalidOperationException(System.SR.JsonSerializerOptionsNoTypeInfoResolverSpecified);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_JsonSerializerIsReflectionDisabled()
		{
			throw new InvalidOperationException(System.SR.JsonSerializerIsReflectionDisabled);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_SerializationConverterOnAttributeInvalid(Type classType, MemberInfo memberInfo)
		{
			string text = classType.ToString();
			if (memberInfo != null)
			{
				text = text + "." + memberInfo.Name;
			}
			throw new InvalidOperationException(System.SR.Format(System.SR.SerializationConverterOnAttributeInvalid, text));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_SerializationConverterOnAttributeNotCompatible(Type classTypeAttributeIsOn, MemberInfo memberInfo, Type typeToConvert)
		{
			string text = classTypeAttributeIsOn.ToString();
			if (memberInfo != null)
			{
				text = text + "." + memberInfo.Name;
			}
			throw new InvalidOperationException(System.SR.Format(System.SR.SerializationConverterOnAttributeNotCompatible, text, typeToConvert));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_SerializerOptionsReadOnly(JsonSerializerContext context)
		{
			string message = ((context == null) ? System.SR.SerializerOptionsReadOnly : System.SR.SerializerContextOptionsReadOnly);
			throw new InvalidOperationException(message);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_DefaultTypeInfoResolverImmutable()
		{
			throw new InvalidOperationException(System.SR.DefaultTypeInfoResolverImmutable);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_TypeInfoResolverChainImmutable()
		{
			throw new InvalidOperationException(System.SR.TypeInfoResolverChainImmutable);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_TypeInfoImmutable()
		{
			throw new InvalidOperationException(System.SR.TypeInfoImmutable);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_InvalidChainedResolver()
		{
			throw new InvalidOperationException(System.SR.SerializerOptions_InvalidChainedResolver);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_SerializerPropertyNameConflict(Type type, string propertyName)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.SerializerPropertyNameConflict, type, propertyName));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_SerializerPropertyNameNull(JsonPropertyInfo jsonPropertyInfo)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.SerializerPropertyNameNull, jsonPropertyInfo.DeclaringType, jsonPropertyInfo.MemberName));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_JsonPropertyRequiredAndNotDeserializable(JsonPropertyInfo jsonPropertyInfo)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.JsonPropertyRequiredAndNotDeserializable, jsonPropertyInfo.Name, jsonPropertyInfo.DeclaringType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_JsonPropertyRequiredAndExtensionData(JsonPropertyInfo jsonPropertyInfo)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.JsonPropertyRequiredAndExtensionData, jsonPropertyInfo.Name, jsonPropertyInfo.DeclaringType));
		}

		[DoesNotReturn]
		public static void ThrowJsonException_JsonRequiredPropertyMissing(JsonTypeInfo parent, BitArray requiredPropertiesSet)
		{
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = true;
			foreach (KeyValuePair<string, JsonPropertyInfo> item in parent.PropertyCache.List)
			{
				JsonPropertyInfo value = item.Value;
				if (value.IsRequired && !requiredPropertiesSet[value.RequiredPropertyIndex])
				{
					if (!flag)
					{
						stringBuilder.Append(CultureInfo.CurrentUICulture.TextInfo.ListSeparator);
						stringBuilder.Append(' ');
					}
					stringBuilder.Append(value.Name);
					flag = false;
					if (stringBuilder.Length >= 50)
					{
						break;
					}
				}
			}
			throw new JsonException(System.SR.Format(System.SR.JsonRequiredPropertiesMissing, parent.Type, stringBuilder.ToString()));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_NamingPolicyReturnNull(JsonNamingPolicy namingPolicy)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.NamingPolicyReturnNull, namingPolicy));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_SerializerConverterFactoryReturnsNull(Type converterType)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.SerializerConverterFactoryReturnsNull, converterType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_SerializerConverterFactoryReturnsJsonConverterFactorty(Type converterType)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.SerializerConverterFactoryReturnsJsonConverterFactory, converterType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_MultiplePropertiesBindToConstructorParameters(Type parentType, string parameterName, string firstMatchName, string secondMatchName)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.MultipleMembersBindWithConstructorParameter, firstMatchName, secondMatchName, parentType, parameterName));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ConstructorParameterIncompleteBinding(Type parentType)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.ConstructorParamIncompleteBinding, parentType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ExtensionDataCannotBindToCtorParam(string propertyName, JsonPropertyInfo jsonPropertyInfo)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.ExtensionDataCannotBindToCtorParam, propertyName, jsonPropertyInfo.DeclaringType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_JsonIncludeOnInaccessibleProperty(string memberName, Type declaringType)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.JsonIncludeOnInaccessibleProperty, memberName, declaringType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_IgnoreConditionOnValueTypeInvalid(string clrPropertyName, Type propertyDeclaringType)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.IgnoreConditionOnValueTypeInvalid, clrPropertyName, propertyDeclaringType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_NumberHandlingOnPropertyInvalid(JsonPropertyInfo jsonPropertyInfo)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.NumberHandlingOnPropertyInvalid, jsonPropertyInfo.MemberName, jsonPropertyInfo.DeclaringType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ConverterCanConvertMultipleTypes(Type runtimePropertyType, JsonConverter jsonConverter)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.ConverterCanConvertMultipleTypes, jsonConverter.GetType(), jsonConverter.Type, runtimePropertyType));
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(ReadOnlySpan<byte> propertyName, ref Utf8JsonReader reader, scoped ref ReadStack state)
		{
			JsonTypeInfo topJsonTypeInfoWithParameterizedConstructor = state.GetTopJsonTypeInfoWithParameterizedConstructor();
			state.Current.JsonPropertyName = propertyName.ToArray();
			NotSupportedException ex = new NotSupportedException(System.SR.Format(System.SR.ObjectWithParameterizedCtorRefMetadataNotSupported, topJsonTypeInfoWithParameterizedConstructor.Type));
			ThrowNotSupportedException(ref state, in reader, ex);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(JsonTypeInfoKind kind)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.InvalidJsonTypeInfoOperationForKind, kind));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_CreateObjectConverterNotCompatible(Type type)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.CreateObjectConverterNotCompatible, type));
		}

		[DoesNotReturn]
		public static void ReThrowWithPath(scoped ref ReadStack state, JsonReaderException ex)
		{
			string text = state.JsonPath();
			string message = ex.Message;
			int num = message.LastIndexOf(" LineNumber: ", StringComparison.Ordinal);
			message = ((num < 0) ? (message + " Path: " + text + ".") : (message.Substring(0, num) + " Path: " + text + " |" + message.Substring(num)));
			throw new JsonException(message, text, ex.LineNumber, ex.BytePositionInLine, ex);
		}

		[DoesNotReturn]
		public static void ReThrowWithPath(scoped ref ReadStack state, in Utf8JsonReader reader, Exception ex)
		{
			JsonException ex2 = new JsonException(null, ex);
			AddJsonExceptionInformation(ref state, in reader, ex2);
			throw ex2;
		}

		public static void AddJsonExceptionInformation(scoped ref ReadStack state, in Utf8JsonReader reader, JsonException ex)
		{
			long lineNumber = reader.CurrentState._lineNumber;
			ex.LineNumber = lineNumber;
			long bytePositionInLine = reader.CurrentState._bytePositionInLine;
			ex.BytePositionInLine = bytePositionInLine;
			string arg = (ex.Path = state.JsonPath());
			string text2 = ex._message;
			if (string.IsNullOrEmpty(text2))
			{
				Type p = state.Current.JsonPropertyInfo?.PropertyType ?? state.Current.JsonTypeInfo.Type;
				text2 = System.SR.Format(System.SR.DeserializeUnableToConvertValue, p);
				ex.AppendPathInformation = true;
			}
			if (ex.AppendPathInformation)
			{
				text2 += $" Path: {arg} | LineNumber: {lineNumber} | BytePositionInLine: {bytePositionInLine}.";
				ex.SetMessage(text2);
			}
		}

		[DoesNotReturn]
		public static void ReThrowWithPath(ref WriteStack state, Exception ex)
		{
			JsonException ex2 = new JsonException(null, ex);
			AddJsonExceptionInformation(ref state, ex2);
			throw ex2;
		}

		public static void AddJsonExceptionInformation(ref WriteStack state, JsonException ex)
		{
			string text = (ex.Path = state.PropertyPath());
			string text3 = ex._message;
			if (string.IsNullOrEmpty(text3))
			{
				text3 = System.SR.Format(System.SR.SerializeUnableToSerialize);
				ex.AppendPathInformation = true;
			}
			if (ex.AppendPathInformation)
			{
				text3 = text3 + " Path: " + text + ".";
				ex.SetMessage(text3);
			}
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_SerializationDuplicateAttribute(Type attribute, MemberInfo memberInfo)
		{
			string p = ((memberInfo is Type type) ? type.ToString() : $"{memberInfo.DeclaringType}.{memberInfo.Name}");
			throw new InvalidOperationException(System.SR.Format(System.SR.SerializationDuplicateAttribute, attribute, p));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_SerializationDuplicateTypeAttribute(Type classType, Type attribute)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.SerializationDuplicateTypeAttribute, classType, attribute));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_SerializationDuplicateTypeAttribute<TAttribute>(Type classType)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.SerializationDuplicateTypeAttribute, classType, typeof(TAttribute)));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_ExtensionDataConflictsWithUnmappedMemberHandling(Type classType, JsonPropertyInfo jsonPropertyInfo)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.ExtensionDataConflictsWithUnmappedMemberHandling, classType, jsonPropertyInfo.MemberName));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_SerializationDataExtensionPropertyInvalid(JsonPropertyInfo jsonPropertyInfo)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.SerializationDataExtensionPropertyInvalid, jsonPropertyInfo.PropertyType, jsonPropertyInfo.MemberName));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty()
		{
			throw new InvalidOperationException(System.SR.NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty);
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException(scoped ref ReadStack state, in Utf8JsonReader reader, NotSupportedException ex)
		{
			string text = ex.Message;
			Type type = state.Current.JsonPropertyInfo?.PropertyType ?? state.Current.JsonTypeInfo.Type;
			if (!text.Contains(type.ToString()))
			{
				if (text.Length > 0)
				{
					text += " ";
				}
				text += System.SR.Format(System.SR.SerializationNotSupportedParentType, type);
			}
			long lineNumber = reader.CurrentState._lineNumber;
			long bytePositionInLine = reader.CurrentState._bytePositionInLine;
			text += $" Path: {state.JsonPath()} | LineNumber: {lineNumber} | BytePositionInLine: {bytePositionInLine}.";
			throw new NotSupportedException(text, ex);
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException(ref WriteStack state, NotSupportedException ex)
		{
			string text = ex.Message;
			Type type = state.Current.JsonPropertyInfo?.PropertyType ?? state.Current.JsonTypeInfo.Type;
			if (!text.Contains(type.ToString()))
			{
				if (text.Length > 0)
				{
					text += " ";
				}
				text += System.SR.Format(System.SR.SerializationNotSupportedParentType, type);
			}
			text = text + " Path: " + state.PropertyPath() + ".";
			throw new NotSupportedException(text, ex);
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException_DeserializeNoConstructor(Type type, ref Utf8JsonReader reader, scoped ref ReadStack state)
		{
			string message = ((!type.IsInterface) ? System.SR.Format(System.SR.DeserializeNoConstructor, "JsonConstructorAttribute", type) : System.SR.Format(System.SR.DeserializePolymorphicInterface, type));
			ThrowNotSupportedException(ref state, in reader, new NotSupportedException(message));
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException_CannotPopulateCollection(Type type, ref Utf8JsonReader reader, scoped ref ReadStack state)
		{
			ThrowNotSupportedException(ref state, in reader, new NotSupportedException(System.SR.Format(System.SR.CannotPopulateCollection, type)));
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataValuesInvalidToken(JsonTokenType tokenType)
		{
			ThrowJsonException(System.SR.Format(System.SR.MetadataInvalidTokenAfterValues, tokenType));
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataReferenceNotFound(string id)
		{
			ThrowJsonException(System.SR.Format(System.SR.MetadataReferenceNotFound, id));
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataValueWasNotString(JsonTokenType tokenType)
		{
			ThrowJsonException(System.SR.Format(System.SR.MetadataValueWasNotString, tokenType));
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataValueWasNotString(JsonValueKind valueKind)
		{
			ThrowJsonException(System.SR.Format(System.SR.MetadataValueWasNotString, valueKind));
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties(ReadOnlySpan<byte> propertyName, scoped ref ReadStack state)
		{
			state.Current.JsonPropertyName = propertyName.ToArray();
			ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties();
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataUnexpectedProperty(ReadOnlySpan<byte> propertyName, scoped ref ReadStack state)
		{
			state.Current.JsonPropertyName = propertyName.ToArray();
			ThrowJsonException(System.SR.Format(System.SR.MetadataUnexpectedProperty));
		}

		[DoesNotReturn]
		public static void ThrowJsonException_UnmappedJsonProperty(Type type, string unmappedPropertyName)
		{
			throw new JsonException(System.SR.Format(System.SR.UnmappedJsonProperty, unmappedPropertyName, type));
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties()
		{
			ThrowJsonException(System.SR.MetadataReferenceCannotContainOtherProperties);
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataIdIsNotFirstProperty(ReadOnlySpan<byte> propertyName, scoped ref ReadStack state)
		{
			state.Current.JsonPropertyName = propertyName.ToArray();
			ThrowJsonException(System.SR.MetadataIdIsNotFirstProperty);
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataStandaloneValuesProperty(scoped ref ReadStack state, ReadOnlySpan<byte> propertyName)
		{
			state.Current.JsonPropertyName = propertyName.ToArray();
			ThrowJsonException(System.SR.MetadataStandaloneValuesProperty);
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataInvalidPropertyWithLeadingDollarSign(ReadOnlySpan<byte> propertyName, scoped ref ReadStack state, in Utf8JsonReader reader)
		{
			if (state.Current.IsProcessingDictionary())
			{
				state.Current.JsonPropertyNameAsString = reader.GetString();
			}
			else
			{
				state.Current.JsonPropertyName = propertyName.ToArray();
			}
			ThrowJsonException(System.SR.MetadataInvalidPropertyWithLeadingDollarSign);
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataDuplicateIdFound(string id)
		{
			ThrowJsonException(System.SR.Format(System.SR.MetadataDuplicateIdFound, id));
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataDuplicateTypeProperty()
		{
			ThrowJsonException(System.SR.MetadataDuplicateTypeProperty);
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataInvalidReferenceToValueType(Type propertyType)
		{
			ThrowJsonException(System.SR.Format(System.SR.MetadataInvalidReferenceToValueType, propertyType));
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataInvalidPropertyInArrayMetadata(scoped ref ReadStack state, Type propertyType, in Utf8JsonReader reader)
		{
			state.Current.JsonPropertyName = (reader.HasValueSequence ? reader.ValueSequence.ToArray<byte>() : reader.ValueSpan.ToArray());
			string p = reader.GetString();
			ThrowJsonException(System.SR.Format(System.SR.MetadataPreservedArrayFailed, System.SR.Format(System.SR.MetadataInvalidPropertyInArrayMetadata, p), System.SR.Format(System.SR.DeserializeUnableToConvertValue, propertyType)));
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataPreservedArrayValuesNotFound(scoped ref ReadStack state, Type propertyType)
		{
			state.Current.JsonPropertyName = null;
			ThrowJsonException(System.SR.Format(System.SR.MetadataPreservedArrayFailed, System.SR.MetadataStandaloneValuesProperty, System.SR.Format(System.SR.DeserializeUnableToConvertValue, propertyType)));
		}

		[DoesNotReturn]
		public static void ThrowJsonException_MetadataCannotParsePreservedObjectIntoImmutable(Type propertyType)
		{
			ThrowJsonException(System.SR.Format(System.SR.MetadataCannotParsePreservedObjectToImmutable, propertyType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_MetadataReferenceOfTypeCannotBeAssignedToType(string referenceId, Type currentType, Type typeToConvert)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.MetadataReferenceOfTypeCannotBeAssignedToType, referenceId, currentType, typeToConvert));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_JsonPropertyInfoIsBoundToDifferentJsonTypeInfo(JsonPropertyInfo propertyInfo)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.JsonPropertyInfoBoundToDifferentParent, propertyInfo.Name, propertyInfo.ParentTypeInfo.Type.FullName));
		}

		[DoesNotReturn]
		internal static void ThrowUnexpectedMetadataException(ReadOnlySpan<byte> propertyName, ref Utf8JsonReader reader, scoped ref ReadStack state)
		{
			if (JsonSerializer.GetMetadataPropertyName(propertyName, state.Current.BaseJsonTypeInfo.PolymorphicTypeResolver) != MetadataPropertyName.None)
			{
				ThrowJsonException_MetadataUnexpectedProperty(propertyName, ref state);
			}
			else
			{
				ThrowJsonException_MetadataInvalidPropertyWithLeadingDollarSign(propertyName, ref state, in reader);
			}
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException_NoMetadataForType(Type type, IJsonTypeInfoResolver resolver)
		{
			throw new NotSupportedException(System.SR.Format(System.SR.NoMetadataForType, type, resolver?.ToString() ?? "<null>"));
		}

		public static NotSupportedException GetNotSupportedException_AmbiguousMetadataForType(Type type, Type match1, Type match2)
		{
			return new NotSupportedException(System.SR.Format(System.SR.AmbiguousMetadataForType, type, match1, match2));
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException_ConstructorContainsNullParameterNames(Type declaringType)
		{
			throw new NotSupportedException(System.SR.Format(System.SR.ConstructorContainsNullParameterNames, declaringType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_NoMetadataForType(Type type, IJsonTypeInfoResolver resolver)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.NoMetadataForType, type, resolver?.ToString() ?? "<null>"));
		}

		public static Exception GetInvalidOperationException_NoMetadataForTypeProperties(IJsonTypeInfoResolver resolver, Type type)
		{
			return new InvalidOperationException(System.SR.Format(System.SR.NoMetadataForTypeProperties, resolver?.ToString() ?? "<null>", type));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_NoMetadataForTypeProperties(IJsonTypeInfoResolver resolver, Type type)
		{
			throw GetInvalidOperationException_NoMetadataForTypeProperties(resolver, type);
		}

		[DoesNotReturn]
		public static void ThrowMissingMemberException_MissingFSharpCoreMember(string missingFsharpCoreMember)
		{
			throw new MissingMemberException(System.SR.Format(System.SR.MissingFSharpCoreMember, missingFsharpCoreMember));
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException_BaseConverterDoesNotSupportMetadata(Type derivedType)
		{
			throw new NotSupportedException(System.SR.Format(System.SR.Polymorphism_DerivedConverterDoesNotSupportMetadata, derivedType));
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException_DerivedConverterDoesNotSupportMetadata(Type derivedType)
		{
			throw new NotSupportedException(System.SR.Format(System.SR.Polymorphism_DerivedConverterDoesNotSupportMetadata, derivedType));
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException_RuntimeTypeNotSupported(Type baseType, Type runtimeType)
		{
			throw new NotSupportedException(System.SR.Format(System.SR.Polymorphism_RuntimeTypeNotSupported, runtimeType, baseType));
		}

		[DoesNotReturn]
		public static void ThrowNotSupportedException_RuntimeTypeDiamondAmbiguity(Type baseType, Type runtimeType, Type derivedType1, Type derivedType2)
		{
			throw new NotSupportedException(System.SR.Format(System.SR.Polymorphism_RuntimeTypeDiamondAmbiguity, runtimeType, derivedType1, derivedType2, baseType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_TypeDoesNotSupportPolymorphism(Type baseType)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.Polymorphism_TypeDoesNotSupportPolymorphism, baseType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_DerivedTypeNotSupported(Type baseType, Type derivedType)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.Polymorphism_DerivedTypeIsNotSupported, derivedType, baseType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_DerivedTypeIsAlreadySpecified(Type baseType, Type derivedType)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.Polymorphism_DerivedTypeIsAlreadySpecified, baseType, derivedType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_TypeDicriminatorIdIsAlreadySpecified(Type baseType, object typeDiscriminator)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.Polymorphism_TypeDicriminatorIdIsAlreadySpecified, baseType, typeDiscriminator));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_InvalidCustomTypeDiscriminatorPropertyName()
		{
			throw new InvalidOperationException(System.SR.Polymorphism_InvalidCustomTypeDiscriminatorPropertyName);
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_PolymorphicTypeConfigurationDoesNotSpecifyDerivedTypes(Type baseType)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.Polymorphism_ConfigurationDoesNotSpecifyDerivedTypes, baseType));
		}

		[DoesNotReturn]
		public static void ThrowInvalidOperationException_InvalidEnumTypeWithSpecialChar(Type enumType, string enumName)
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.InvalidEnumTypeWithSpecialChar, enumType.Name, enumName));
		}

		[DoesNotReturn]
		public static void ThrowJsonException_UnrecognizedTypeDiscriminator(object typeDiscriminator)
		{
			ThrowJsonException(System.SR.Format(System.SR.Polymorphism_UnrecognizedTypeDiscriminator, typeDiscriminator));
		}

		[DoesNotReturn]
		public static void ThrowArgumentException_JsonPolymorphismOptionsAssociatedWithDifferentJsonTypeInfo(string parameterName)
		{
			throw new ArgumentException(System.SR.JsonPolymorphismOptionsAssociatedWithDifferentJsonTypeInfo, parameterName);
		}
	}
	internal sealed class JsonCamelCaseNamingPolicy : JsonNamingPolicy
	{
		public override string ConvertName(string name)
		{
			if (string.IsNullOrEmpty(name) || !char.IsUpper(name[0]))
			{
				return name;
			}
			char[] array = name.ToCharArray();
			FixCasing(array);
			return new string(array);
		}

		private static void FixCasing(Span<char> chars)
		{
			for (int i = 0; i < chars.Length && (i != 1 || char.IsUpper(chars[i])); i++)
			{
				bool flag = i + 1 < chars.Length;
				if (i > 0 && flag && !char.IsUpper(chars[i + 1]))
				{
					if (chars[i + 1] == ' ')
					{
						chars[i] = char.ToLowerInvariant(chars[i]);
					}
					break;
				}
				chars[i] = char.ToLowerInvariant(chars[i]);
			}
		}
	}
	public abstract class JsonNamingPolicy
	{
		public static JsonNamingPolicy CamelCase { get; } = new JsonCamelCaseNamingPolicy();

		public static JsonNamingPolicy SnakeCaseLower { get; } = new JsonSnakeCaseLowerNamingPolicy();

		public static JsonNamingPolicy SnakeCaseUpper { get; } = new JsonSnakeCaseUpperNamingPolicy();

		public static JsonNamingPolicy KebabCaseLower { get; } = new JsonKebabCaseLowerNamingPolicy();

		public static JsonNamingPolicy KebabCaseUpper { get; } = new JsonKebabCaseUpperNamingPolicy();

		public abstract string ConvertName(string name);
	}
	public enum JsonCommentHandling : byte
	{
		Disallow,
		Skip,
		Allow
	}
	internal static class JsonConstants
	{
		public const string DoubleFormatString = "G17";

		public const string SingleFormatString = "G9";

		public const int StackallocByteThreshold = 256;

		public const int StackallocCharThreshold = 128;

		public const byte OpenBrace = 123;

		public const byte CloseBrace = 125;

		public const byte OpenBracket = 91;

		public const byte CloseBracket = 93;

		public const byte Space = 32;

		public const byte CarriageReturn = 13;

		public const byte LineFeed = 10;

		public const byte Tab = 9;

		public const byte ListSeparator = 44;

		public const byte KeyValueSeparator = 58;

		public const byte Quote = 34;

		public const byte BackSlash = 92;

		public const byte Slash = 47;

		public const byte BackSpace = 8;

		public const byte FormFeed = 12;

		public const byte Asterisk = 42;

		public const byte Colon = 58;

		public const byte Period = 46;

		public const byte Plus = 43;

		public const byte Hyphen = 45;

		public const byte UtcOffsetToken = 90;

		public const byte TimePrefix = 84;

		public const byte StartingByteOfNonStandardSeparator = 226;

		public const int SpacesPerIndent = 2;

		public const int RemoveFlagsBitMask = int.MaxValue;

		public const int MaxExpansionFactorWhileEscaping = 6;

		public const int MaxExpansionFactorWhileTranscoding = 3;

		public const long ArrayPoolMaxSizeBeforeUsingNormalAlloc = 1048576L;

		public const int MaxUtf16RawValueLength = 715827882;

		public const int MaxEscapedTokenSize = 1000000000;

		public const int MaxUnescapedTokenSize = 166666666;

		public const int MaxCharacterTokenSize = 166666666;

		public const int MaximumFormatBooleanLength = 5;

		public const int MaximumFormatInt64Length = 20;

		public const int MaximumFormatUInt64Length = 20;

		public const int MaximumFormatDoubleLength = 128;

		public const int MaximumFormatSingleLength = 128;

		public const int MaximumFormatDecimalLength = 31;

		public const int MaximumFormatGuidLength = 36;

		public const int MaximumEscapedGuidLength = 216;

		public const int MaximumFormatDateTimeLength = 27;

		public const int MaximumFormatDateTimeOffsetLength = 33;

		public const int MaxDateTimeUtcOffsetHours = 14;

		public const int DateTimeNumFractionDigits = 7;

		public const int MaxDateTimeFraction = 9999999;

		public const int DateTimeParseNumFractionDigits = 16;

		public const int MaximumDateTimeOffsetParseLength = 42;

		public const int MinimumDateTimeParseLength = 10;

		public const int MaximumEscapedDateTimeOffsetParseLength = 252;

		public const int MaximumLiteralLength = 5;

		public const char HighSurrogateStart = '\ud800';

		public const char HighSurrogateEnd = '\udbff';

		public const char LowSurrogateStart = '\udc00';

		public const char LowSurrogateEnd = '\udfff';

		public const int UnicodePlane01StartValue = 65536;

		public const int HighSurrogateStartValue = 55296;

		public const int HighSurrogateEndValue = 56319;

		public const int LowSurrogateStartValue = 56320;

		public const int LowSurrogateEndValue = 57343;

		public const int BitShiftBy10 = 1024;

		public const int UnboxedParameterCountThreshold = 4;

		public static ReadOnlySpan<byte> Utf8Bom => "\ufeff"u8;

		public static ReadOnlySpan<byte> TrueValue => "true"u8;

		public static ReadOnlySpan<byte> FalseValue => "false"u8;

		public static ReadOnlySpan<byte> NullValue => "null"u8;

		public static ReadOnlySpan<byte> NaNValue => "NaN"u8;

		public static ReadOnlySpan<byte> PositiveInfinityValue => "Infinity"u8;

		public static ReadOnlySpan<byte> NegativeInfinityValue => "-Infinity"u8;

		public static ReadOnlySpan<byte> Delimiters => ",}] \n\r\t/"u8;

		public static ReadOnlySpan<byte> EscapableChars => "\"nrt/ubf"u8;
	}
	internal static class JsonHelpers
	{
		[StructLayout(LayoutKind.Auto)]
		private struct DateTimeParseData
		{
			public int Year;

			public int Month;

			public int Day;

			public bool IsCalendarDateOnly;

			public int Hour;

			public int Minute;

			public int Second;

			public int Fraction;

			public int OffsetHours;

			public int OffsetMinutes;

			public byte OffsetToken;

			public bool OffsetNegative => OffsetToken == 45;
		}

		private static ReadOnlySpan<int> DaysToMonth365
		{
			get
			{
				object obj = global::<PrivateImplementationDetails>.5857EE4CE98BFABBD62B385C1098507DD0052FF3951043AAD6A1DABD495F18AA_A6;
				if (obj == null)
				{
					obj = new int[13]
					{
						0, 31, 59, 90, 120, 151, 181, 212, 243, 273,
						304, 334, 365
					};
					global::<PrivateImplementationDetails>.5857EE4CE98BFABBD62B385C1098507DD0052FF3951043AAD6A1DABD495F18AA_A6 = (int[])obj;
				}
				return new ReadOnlySpan<int>((int[])obj);
			}
		}

		private static ReadOnlySpan<int> DaysToMonth366
		{
			get
			{
				object obj = global::<PrivateImplementationDetails>.FADB218011E7702BB9575D0C32A685DA10B5C72EB809BD9A955DB1C76E4D8315_A6;
				if (obj == null)
				{
					obj = new int[13]
					{
						0, 31, 60, 91, 121, 152, 182, 213, 244, 274,
						305, 335, 366
					};
					global::<PrivateImplementationDetails>.FADB218011E7702BB9575D0C32A685DA10B5C72EB809BD9A955DB1C76E4D8315_A6 = (int[])obj;
				}
				return new ReadOnlySpan<int>((int[])obj);
			}
		}

		public static bool TryAdd<TKey, TValue>(this Dictionary<TKey, TValue> dictionary, TKey key, TValue value)
		{
			if (!dictionary.ContainsKey(key))
			{
				dictionary[key] = value;
				return true;
			}
			return false;
		}

		public static bool TryDequeue<T>(this Queue<T> queue, [NotNullWhen(true)] out T result)
		{
			if (queue.Count > 0)
			{
				result = queue.Dequeue();
				return true;
			}
			result = default(T);
			return false;
		}

		internal static bool RequiresSpecialNumberHandlingOnWrite(JsonNumberHandling? handling)
		{
			if (!handling.HasValue)
			{
				return false;
			}
			return (handling.Value & (JsonNumberHandling.WriteAsString | JsonNumberHandling.AllowNamedFloatingPointLiterals)) != 0;
		}

		internal static void StableSortByKey<T, TKey>(this List<T> items, Func<T, TKey> keySelector) where TKey : unmanaged, IComparable<TKey>
		{
			T[] array = items.ToArray();
			(TKey, int)[] array2 = new(TKey, int)[array.Length];
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = (keySelector(array[i]), i);
			}
			Array.Sort(array2, array);
			items.Clear();
			items.AddRange(array);
		}

		public static T[] TraverseGraphWithTopologicalSort<T>(T entryNode, Func<T, ICollection<T>> getChildren, IEqualityComparer<T> comparer = null)
		{
			if (comparer == null)
			{
				comparer = EqualityComparer<T>.Default;
			}
			List<T> list = new List<T> { entryNode };
			Dictionary<T, int> dictionary = new Dictionary<T, int>(comparer) { [entryNode] = 0 };
			List<bool[]> list2 = new List<bool[]>();
			Queue<int> queue = new Queue<int>();
			for (int i = 0; i < list.Count; i++)
			{
				T arg = list[i];
				ICollection<T> collection = getChildren(arg);
				int count = collection.Count;
				if (count == 0)
				{
					list2.Add(null);
					queue.Enqueue(i);
					continue;
				}
				bool[] array = new bool[Math.Max(list.Count, count)];
				foreach (T item in collection)
				{
					if (!dictionary.TryGetValue(item, out var value))
					{
						value = list.Count;
						dictionary.Add(item, value);
						list.Add(item);
					}
					if (value >= array.Length)
					{
						Array.Resize(ref array, value + 1);
					}
					array[value] = true;
				}
				list2.Add(array);
			}
			T[] array2 = new T[list.Count];
			int num = array2.Length;
			do
			{
				int num2 = queue.Dequeue();
				array2[--num] = list[num2];
				for (int j = 0; j < list2.Count; j++)
				{
					bool[] array3 = list2[j];
					if (array3 != null && num2 < array3.Length && array3[num2])
					{
						array3[num2] = false;
						if (MemoryExtensions.AsSpan(array3).IndexOf(value: true) == -1)
						{
							queue.Enqueue(j);
						}
					}
				}
			}
			while (queue.Count > 0);
			return array2;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static ReadOnlySpan<byte> GetSpan(this scoped ref Utf8JsonReader reader)
		{
			if (!reader.HasValueSequence)
			{
				return reader.ValueSpan;
			}
			return reader.ValueSequence.ToArray<byte>();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsValidUnicodeScalar(uint value)
		{
			return IsInRangeInclusive(value ^ 0xD800, 2048u, 1114111u);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsInRangeInclusive(uint value, uint lowerBound, uint upperBound)
		{
			return value - lowerBound <= upperBound - lowerBound;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsInRangeInclusive(int value, int lowerBound, int upperBound)
		{
			return (uint)(value - lowerBound) <= (uint)(upperBound - lowerBound);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsInRangeInclusive(long value, long lowerBound, long upperBound)
		{
			return (ulong)(value - lowerBound) <= (ulong)(upperBound - lowerBound);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsInRangeInclusive(JsonTokenType value, JsonTokenType lowerBound, JsonTokenType upperBound)
		{
			return value - lowerBound <= upperBound - lowerBound;
		}

		public static bool IsDigit(byte value)
		{
			return (uint)(value - 48) <= 9u;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ReadWithVerify(this ref Utf8JsonReader reader)
		{
			bool flag = reader.Read();
		}

		public static string Utf8GetString(ReadOnlySpan<byte> bytes)
		{
			return Encoding.UTF8.GetString(bytes.ToArray());
		}

		public static Dictionary<TKey, TValue> CreateDictionaryFromCollection<TKey, TValue>(IEnumerable<KeyValuePair<TKey, TValue>> collection, IEqualityComparer<TKey> comparer)
		{
			Dictionary<TKey, TValue> dictionary = new Dictionary<TKey, TValue>(comparer);
			foreach (KeyValuePair<TKey, TValue> item in collection)
			{
				dictionary.Add(item.Key, item.Value);
			}
			return dictionary;
		}

		public static bool IsFinite(double value)
		{
			if (!double.IsNaN(value))
			{
				return !double.IsInfinity(value);
			}
			return false;
		}

		public static bool IsFinite(float value)
		{
			if (!float.IsNaN(value))
			{
				return !float.IsInfinity(value);
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ValidateInt32MaxArrayLength(uint length)
		{
			if (length > 2146435071)
			{
				ThrowHelper.ThrowOutOfMemoryException(length);
			}
		}

		public static bool HasAllSet(this BitArray bitArray)
		{
			for (int i = 0; i < bitArray.Count; i++)
			{
				if (!bitArray[i])
				{
					return false;
				}
			}
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsValidDateTimeOffsetParseLength(int length)
		{
			return IsInRangeInclusive(length, 10, 252);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsValidUnescapedDateTimeOffsetParseLength(int length)
		{
			return IsInRangeInclusive(length, 10, 42);
		}

		public static bool TryParseAsISO(ReadOnlySpan<byte> source, out DateTime value)
		{
			if (!TryParseDateTimeOffset(source, out var parseData))
			{
				value = default(DateTime);
				return false;
			}
			if (parseData.OffsetToken == 90)
			{
				return TryCreateDateTime(parseData, DateTimeKind.Utc, out value);
			}
			if (parseData.OffsetToken == 43 || parseData.OffsetToken == 45)
			{
				if (!TryCreateDateTimeOffset(ref parseData, out var value2))
				{
					value = default(DateTime);
					return false;
				}
				value = value2.LocalDateTime;
				return true;
			}
			return TryCreateDateTime(parseData, DateTimeKind.Unspecified, out value);
		}

		public static bool TryParseAsISO(ReadOnlySpan<byte> source, out DateTimeOffset value)
		{
			if (!TryParseDateTimeOffset(source, out var parseData))
			{
				value = default(DateTimeOffset);
				return false;
			}
			if (parseData.OffsetToken == 90 || parseData.OffsetToken == 43 || parseData.OffsetToken == 45)
			{
				return TryCreateDateTimeOffset(ref parseData, out value);
			}
			return TryCreateDateTimeOffsetInterpretingDataAsLocalTime(parseData, out value);
		}

		private static bool TryParseDateTimeOffset(ReadOnlySpan<byte> source, out DateTimeParseData parseData)
		{
			parseData = default(DateTimeParseData);
			uint num = (uint)(source[0] - 48);
			uint num2 = (uint)(source[1] - 48);
			uint num3 = (uint)(source[2] - 48);
			uint num4 = (uint)(source[3] - 48);
			if (num > 9 || num2 > 9 || num3 > 9 || num4 > 9)
			{
				return false;
			}
			parseData.Year = (int)(num * 1000 + num2 * 100 + num3 * 10 + num4);
			if (source[4] != 45 || !TryGetNextTwoDigits(source.Slice(5, 2), ref parseData.Month) || source[7] != 45 || !TryGetNextTwoDigits(source.Slice(8, 2), ref parseData.Day))
			{
				return false;
			}
			if (source.Length == 10)
			{
				parseData.IsCalendarDateOnly = true;
				return true;
			}
			if (source.Length < 16)
			{
				return false;
			}
			if (source[10] != 84 || source[13] != 58 || !TryGetNextTwoDigits(source.Slice(11, 2), ref parseData.Hour) || !TryGetNextTwoDigits(source.Slice(14, 2), ref parseData.Minute))
			{
				return false;
			}
			if (source.Length == 16)
			{
				return true;
			}
			byte b = source[16];
			int num5 = 17;
			switch (b)
			{
			case 90:
				parseData.OffsetToken = 90;
				return num5 == source.Length;
			case 43:
			case 45:
				parseData.OffsetToken = b;
				return ParseOffset(ref parseData, source.Slice(num5));
			default:
				return false;
			case 58:
				if (source.Length < 19 || !TryGetNextTwoDigits(source.Slice(17, 2), ref parseData.Second))
				{
					return false;
				}
				if (source.Length == 19)
				{
					return true;
				}
				b = source[19];
				num5 = 20;
				switch (b)
				{
				case 90:
					parseData.OffsetToken = 90;
					return num5 == source.Length;
				case 43:
				case 45:
					parseData.OffsetToken = b;
					return ParseOffset(ref parseData, source.Slice(num5));
				default:
					return false;
				case 46:
				{
					if (source.Length < 21)
					{
						return false;
					}
					int i = 0;
					for (int num6 = Math.Min(num5 + 16, source.Length); num5 < num6; num5++)
					{
						if (!IsDigit(b = source[num5]))
						{
							break;
						}
						if (i < 7)
						{
							parseData.Fraction = parseData.Fraction * 10 + (b - 48);
							i++;
						}
					}
					if (parseData.Fraction != 0)
					{
						for (; i < 7; i++)
						{
							parseData.Fraction *= 10;
						}
					}
					if (num5 == source.Length)
					{
						return true;
					}
					b = source[num5++];
					switch (b)
					{
					case 90:
						parseData.OffsetToken = 90;
						return num5 == source.Length;
					case 43:
					case 45:
						parseData.OffsetToken = b;
						return ParseOffset(ref parseData, source.Slice(num5));
					default:
						return false;
					}
				}
				}
			}
			static bool ParseOffset(ref DateTimeParseData reference, ReadOnlySpan<byte> offsetData)
			{
				if (offsetData.Length < 2 || !TryGetNextTwoDigits(offsetData.Slice(0, 2), ref reference.OffsetHours))
				{
					return false;
				}
				if (offsetData.Length == 2)
				{
					return true;
				}
				if (offsetData.Length != 5 || offsetData[2] != 58 || !TryGetNextTwoDigits(offsetData.Slice(3), ref reference.OffsetMinutes))
				{
					return false;
				}
				return true;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static bool TryGetNextTwoDigits(ReadOnlySpan<byte> source, ref int value)
		{
			uint num = (uint)(source[0] - 48);
			uint num2 = (uint)(source[1] - 48);
			if (num > 9 || num2 > 9)
			{
				value = 0;
				return false;
			}
			value = (int)(num * 10 + num2);
			return true;
		}

		private static bool TryCreateDateTimeOffset(DateTime dateTime, ref DateTimeParseData parseData, out DateTimeOffset value)
		{
			if ((uint)parseData.OffsetHours > 14u)
			{
				value = default(DateTimeOffset);
				return false;
			}
			if ((uint)parseData.OffsetMinutes > 59u)
			{
				value = default(DateTimeOffset);
				return false;
			}
			if (parseData.OffsetHours == 14 && parseData.OffsetMinutes != 0)
			{
				value = default(DateTimeOffset);
				return false;
			}
			long num = ((long)parseData.OffsetHours * 3600L + (long)parseData.OffsetMinutes * 60L) * 10000000;
			if (parseData.OffsetNegative)
			{
				num = -num;
			}
			try
			{
				value = new DateTimeOffset(dateTime.Ticks, new TimeSpan(num));
			}
			catch (ArgumentOutOfRangeException)
			{
				value = default(DateTimeOffset);
				return false;
			}
			return true;
		}

		private static bool TryCreateDateTimeOffset(ref DateTimeParseData parseData, out DateTimeOffset value)
		{
			if (!TryCreateDateTime(parseData, DateTimeKind.Unspecified, out var value2))
			{
				value = default(DateTimeOffset);
				return false;
			}
			if (!TryCreateDateTimeOffset(value2, ref parseData, out value))
			{
				value = default(DateTimeOffset);
				return false;
			}
			return true;
		}

		private static bool TryCreateDateTimeOffsetInterpretingDataAsLocalTime(DateTimeParseData parseData, out DateTimeOffset value)
		{
			if (!TryCreateDateTime(parseData, DateTimeKind.Local, out var value2))
			{
				value = default(DateTimeOffset);
				return false;
			}
			try
			{
				value = new DateTimeOffset(value2);
			}
			catch (ArgumentOutOfRangeException)
			{
				value = default(DateTimeOffset);
				return false;
			}
			return true;
		}

		private static bool TryCreateDateTime(DateTimeParseData parseData, DateTimeKind kind, out DateTime value)
		{
			if (parseData.Year == 0)
			{
				value = default(DateTime);
				return false;
			}
			if ((uint)(parseData.Month - 1) >= 12u)
			{
				value = default(DateTime);
				return false;
			}
			uint num = (uint)(parseData.Day - 1);
			if (num >= 28 && num >= DateTime.DaysInMonth(parseData.Year, parseData.Month))
			{
				value = default(DateTime);
				return false;
			}
			if ((uint)parseData.Hour > 23u)
			{
				value = default(DateTime);
				return false;
			}
			if ((uint)parseData.Minute > 59u)
			{
				value = default(DateTime);
				return false;
			}
			if ((uint)parseData.Second > 59u)
			{
				value = default(DateTime);
				return false;
			}
			ReadOnlySpan<int> readOnlySpan = (DateTime.IsLeapYear(parseData.Year) ? DaysToMonth366 : DaysToMonth365);
			int num2 = parseData.Year - 1;
			int num3 = num2 * 365 + num2 / 4 - num2 / 100 + num2 / 400 + readOnlySpan[parseData.Month - 1] + parseData.Day - 1;
			long num4 = num3 * 864000000000L;
			int num5 = parseData.Hour * 3600 + parseData.Minute * 60 + parseData.Second;
			num4 += (long)num5 * 10000000L;
			num4 += parseData.Fraction;
			value = new DateTime(num4, kind);
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static byte[] GetEscapedPropertyNameSection(ReadOnlySpan<byte> utf8Value, JavaScriptEncoder encoder)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8Value, encoder);
			if (num != -1)
			{
				return GetEscapedPropertyNameSection(utf8Value, num, encoder);
			}
			return GetPropertyNameSection(utf8Value);
		}

		public static byte[] EscapeValue(ReadOnlySpan<byte> utf8Value, int firstEscapeIndexVal, JavaScriptEncoder encoder)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8Value.Length, firstEscapeIndexVal);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8Value, destination, firstEscapeIndexVal, encoder, out var written);
			byte[] result = destination.Slice(0, written).ToArray();
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
			return result;
		}

		private static byte[] GetEscapedPropertyNameSection(ReadOnlySpan<byte> utf8Value, int firstEscapeIndexVal, JavaScriptEncoder encoder)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8Value.Length, firstEscapeIndexVal);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8Value, destination, firstEscapeIndexVal, encoder, out var written);
			byte[] propertyNameSection = GetPropertyNameSection(destination.Slice(0, written));
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
			return propertyNameSection;
		}

		private static byte[] GetPropertyNameSection(ReadOnlySpan<byte> utf8Value)
		{
			int length = utf8Value.Length;
			byte[] array = new byte[length + 3];
			array[0] = 34;
			utf8Value.CopyTo(MemoryExtensions.AsSpan(array, 1, length));
			array[++length] = 34;
			array[++length] = 58;
			return array;
		}
	}
	internal sealed class JsonKebabCaseLowerNamingPolicy : JsonSeparatorNamingPolicy
	{
		public JsonKebabCaseLowerNamingPolicy()
			: base(lowercase: true, '-')
		{
		}
	}
	internal sealed class JsonKebabCaseUpperNamingPolicy : JsonSeparatorNamingPolicy
	{
		public JsonKebabCaseUpperNamingPolicy()
			: base(lowercase: false, '-')
		{
		}
	}
	internal abstract class JsonSeparatorNamingPolicy : JsonNamingPolicy
	{
		private enum SeparatorState
		{
			NotStarted,
			UppercaseLetter,
			LowercaseLetterOrDigit,
			SpaceSeparator
		}

		private readonly bool _lowercase;

		private readonly char _separator;

		internal JsonSeparatorNamingPolicy(bool lowercase, char separator)
		{
			_lowercase = lowercase;
			_separator = separator;
		}

		public sealed override string ConvertName(string name)
		{
			if (name == null)
			{
				ThrowHelper.ThrowArgumentNullException("name");
			}
			return ConvertNameCore(_separator, _lowercase, MemoryExtensions.AsSpan(name));
		}

		private static string ConvertNameCore(char separator, bool lowercase, ReadOnlySpan<char> chars)
		{
			char[] rentedBuffer = null;
			int num = (int)(1.2 * (double)chars.Length);
			Span<char> span = ((num > 128) ? ((Span<char>)(rentedBuffer = ArrayPool<char>.Shared.Rent(num))) : stackalloc char[128]);
			Span<char> destination = span;
			SeparatorState separatorState = SeparatorState.NotStarted;
			int charsWritten = 0;
			for (int i = 0; i < chars.Length; i++)
			{
				char c = chars[i];
				UnicodeCategory unicodeCategory = char.GetUnicodeCategory(c);
				switch (unicodeCategory)
				{
				case UnicodeCategory.UppercaseLetter:
					switch (separatorState)
					{
					case SeparatorState.LowercaseLetterOrDigit:
					case SeparatorState.SpaceSeparator:
						WriteChar(separator, ref destination);
						break;
					case SeparatorState.UppercaseLetter:
						if (i + 1 < chars.Length && char.IsLower(chars[i + 1]))
						{
							WriteChar(separator, ref destination);
						}
						break;
					}
					if (lowercase)
					{
						c = char.ToLowerInvariant(c);
					}
					WriteChar(c, ref destination);
					separatorState = SeparatorState.UppercaseLetter;
					break;
				case UnicodeCategory.LowercaseLetter:
				case UnicodeCategory.DecimalDigitNumber:
					if (separatorState == SeparatorState.SpaceSeparator)
					{
						WriteChar(separator, ref destination);
					}
					if (!lowercase && unicodeCategory == UnicodeCategory.LowercaseLetter)
					{
						c = char.ToUpperInvariant(c);
					}
					WriteChar(c, ref destination);
					separatorState = SeparatorState.LowercaseLetterOrDigit;
					break;
				case UnicodeCategory.SpaceSeparator:
					if (separatorState != SeparatorState.NotStarted)
					{
						separatorState = SeparatorState.SpaceSeparator;
					}
					break;
				default:
					WriteChar(c, ref destination);
					separatorState = SeparatorState.NotStarted;
					break;
				}
			}
			string result = destination.Slice(0, charsWritten).ToString();
			if (rentedBuffer != null)
			{
				destination.Slice(0, charsWritten).Clear();
				ArrayPool<char>.Shared.Return(rentedBuffer);
			}
			return result;
			void ExpandBuffer(ref Span<char> reference)
			{
				int minimumLength = checked(reference.Length * 2);
				char[] array = ArrayPool<char>.Shared.Rent(minimumLength);
				reference.CopyTo(array);
				if (rentedBuffer != null)
				{
					reference.Slice(0, charsWritten).Clear();
					ArrayPool<char>.Shared.Return(rentedBuffer);
				}
				rentedBuffer = array;
				reference = rentedBuffer;
			}
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			void WriteChar(char value, ref Span<char> reference)
			{
				if (charsWritten == reference.Length)
				{
					ExpandBuffer(ref reference);
				}
				reference[charsWritten++] = value;
			}
		}
	}
	public enum JsonSerializerDefaults
	{
		General,
		Web
	}
	internal sealed class JsonSnakeCaseLowerNamingPolicy : JsonSeparatorNamingPolicy
	{
		public JsonSnakeCaseLowerNamingPolicy()
			: base(lowercase: true, '_')
		{
		}
	}
	internal sealed class JsonSnakeCaseUpperNamingPolicy : JsonSeparatorNamingPolicy
	{
		public JsonSnakeCaseUpperNamingPolicy()
			: base(lowercase: false, '_')
		{
		}
	}
	internal static class AppContextSwitchHelper
	{
		public static bool IsSourceGenReflectionFallbackEnabled { get; } = AppContext.TryGetSwitch("System.Text.Json.Serialization.EnableSourceGenReflectionFallback", out var isEnabled) && isEnabled;
	}
	internal struct BitStack
	{
		private const int AllocationFreeMaxDepth = 64;

		private const int DefaultInitialArraySize = 2;

		private int[] _array;

		private ulong _allocationFreeContainer;

		private int _currentDepth;

		public int CurrentDepth => _currentDepth;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void PushTrue()
		{
			if (_currentDepth < 64)
			{
				_allocationFreeContainer = (_allocationFreeContainer << 1) | 1;
			}
			else
			{
				PushToArray(value: true);
			}
			_currentDepth++;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void PushFalse()
		{
			if (_currentDepth < 64)
			{
				_allocationFreeContainer <<= 1;
			}
			else
			{
				PushToArray(value: false);
			}
			_currentDepth++;
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private void PushToArray(bool value)
		{
			if (_array == null)
			{
				_array = new int[2];
			}
			int number = _currentDepth - 64;
			int remainder;
			int num = Div32Rem(number, out remainder);
			if (num >= _array.Length)
			{
				DoubleArray(num);
			}
			int num2 = _array[num];
			num2 = ((!value) ? (num2 & ~(1 << remainder)) : (num2 | (1 << remainder)));
			_array[num] = num2;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public bool Pop()
		{
			_currentDepth--;
			if (_currentDepth < 64)
			{
				_allocationFreeContainer >>= 1;
				return (_allocationFreeContainer & 1) != 0;
			}
			if (_currentDepth == 64)
			{
				return (_allocationFreeContainer & 1) != 0;
			}
			return PopFromArray();
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private bool PopFromArray()
		{
			int number = _currentDepth - 64 - 1;
			int remainder;
			int num = Div32Rem(number, out remainder);
			return (_array[num] & (1 << remainder)) != 0;
		}

		private void DoubleArray(int minSize)
		{
			int newSize = Math.Max(minSize + 1, _array.Length * 2);
			Array.Resize(ref _array, newSize);
		}

		public void SetFirstBit()
		{
			_currentDepth++;
			_allocationFreeContainer = 1uL;
		}

		public void ResetFirstBit()
		{
			_currentDepth++;
			_allocationFreeContainer = 0uL;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static int Div32Rem(int number, out int remainder)
		{
			uint result = (uint)number / 32u;
			remainder = number & 0x1F;
			return (int)result;
		}
	}
	public sealed class JsonDocument : IDisposable
	{
		internal readonly struct DbRow
		{
			internal const int Size = 12;

			private readonly int _location;

			private readonly int _sizeOrLengthUnion;

			private readonly int _numberOfRowsAndTypeUnion;

			internal const int UnknownSize = -1;

			internal int Location => _location;

			internal int SizeOrLength => _sizeOrLengthUnion & 0x7FFFFFFF;

			internal bool IsUnknownSize => _sizeOrLengthUnion == -1;

			internal bool HasComplexChildren => _sizeOrLengthUnion < 0;

			internal int NumberOfRows => _numberOfRowsAndTypeUnion & 0xFFFFFFF;

			internal JsonTokenType TokenType => (JsonTokenType)((uint)_numberOfRowsAndTypeUnion >> 28);

			internal bool IsSimpleValue => (int)TokenType >= 5;

			internal DbRow(JsonTokenType jsonTokenType, int location, int sizeOrLength)
			{
				_location = location;
				_sizeOrLengthUnion = sizeOrLength;
				_numberOfRowsAndTypeUnion = (int)((uint)jsonTokenType << 28);
			}
		}

		private struct MetadataDb : IDisposable
		{
			private const int SizeOrLengthOffset = 4;

			private const int NumberOfRowsOffset = 8;

			private byte[] _data;

			private bool _convertToAlloc;

			private bool _isLocked;

			internal int Length { get; private set; }

			private MetadataDb(byte[] initialDb, bool isLocked, bool convertToAlloc)
			{
				_data = initialDb;
				_isLocked = isLocked;
				_convertToAlloc = convertToAlloc;
				Length = 0;
			}

			internal MetadataDb(byte[] completeDb)
			{
				_data = completeDb;
				_isLocked = true;
				_convertToAlloc = false;
				Length = completeDb.Length;
			}

			internal static MetadataDb CreateRented(int payloadLength, bool convertToAlloc)
			{
				int num = payloadLength + 12;
				if (num > 1048576 && num <= 4194304)
				{
					num = 1048576;
				}
				byte[] initialDb = ArrayPool<byte>.Shared.Rent(num);
				return new MetadataDb(initialDb, isLocked: false, convertToAlloc);
			}

			internal static MetadataDb CreateLocked(int payloadLength)
			{
				int num = payloadLength + 12;
				byte[] initialDb = new byte[num];
				return new MetadataDb(initialDb, isLocked: true, convertToAlloc: false);
			}

			public void Dispose()
			{
				byte[] array = Interlocked.Exchange(ref _data, null);
				if (array != null)
				{
					ArrayPool<byte>.Shared.Return(array);
					Length = 0;
				}
			}

			internal void CompleteAllocations()
			{
				if (_isLocked)
				{
					return;
				}
				if (_convertToAlloc)
				{
					byte[] data = _data;
					_data = MemoryExtensions.AsSpan(_data, 0, Length).ToArray();
					_isLocked = true;
					_convertToAlloc = false;
					ArrayPool<byte>.Shared.Return(data);
				}
				else if (Length <= _data.Length / 2)
				{
					byte[] array = ArrayPool<byte>.Shared.Rent(Length);
					byte[] array2 = array;
					if (array.Length < _data.Length)
					{
						Buffer.BlockCopy(_data, 0, array, 0, Length);
						array2 = _data;
						_data = array;
					}
					ArrayPool<byte>.Shared.Return(array2);
				}
			}

			internal void Append(JsonTokenType tokenType, int startLocation, int length)
			{
				if (Length >= _data.Length - 12)
				{
					Enlarge();
				}
				DbRow value = new DbRow(tokenType, startLocation, length);
				MemoryMarshal.Write(MemoryExtensions.AsSpan(_data, Length), ref value);
				Length += 12;
			}

			private void Enlarge()
			{
				byte[] data = _data;
				int num = data.Length * 2;
				if ((uint)num > 2147483591u)
				{
					num = 2147483591;
				}
				if (num == data.Length)
				{
					num = int.MaxValue;
				}
				_data = ArrayPool<byte>.Shared.Rent(num);
				Buffer.BlockCopy(data, 0, _data, 0, data.Length);
				ArrayPool<byte>.Shared.Return(data);
			}

			[Conditional("DEBUG")]
			private void AssertValidIndex(int index)
			{
			}

			internal void SetLength(int index, int length)
			{
				Span<byte> destination = MemoryExtensions.AsSpan(_data, index + 4);
				MemoryMarshal.Write(destination, ref length);
			}

			internal void SetNumberOfRows(int index, int numberOfRows)
			{
				Span<byte> span = MemoryExtensions.AsSpan(_data, index + 8);
				int num = MemoryMarshal.Read<int>(span);
				int value = (num & -268435456) | numberOfRows;
				MemoryMarshal.Write(span, ref value);
			}

			internal void SetHasComplexChildren(int index)
			{
				Span<byte> span = MemoryExtensions.AsSpan(_data, index + 4);
				int num = MemoryMarshal.Read<int>(span);
				int value = num | int.MinValue;
				MemoryMarshal.Write(span, ref value);
			}

			internal int FindIndexOfFirstUnsetSizeOrLength(JsonTokenType lookupType)
			{
				return FindOpenElement(lookupType);
			}

			private int FindOpenElement(JsonTokenType lookupType)
			{
				Span<byte> span = MemoryExtensions.AsSpan(_data, 0, Length);
				for (int num = Length - 12; num >= 0; num -= 12)
				{
					DbRow dbRow = MemoryMarshal.Read<DbRow>(span.Slice(num));
					if (dbRow.IsUnknownSize && dbRow.TokenType == lookupType)
					{
						return num;
					}
				}
				return -1;
			}

			internal DbRow Get(int index)
			{
				return MemoryMarshal.Read<DbRow>(MemoryExtensions.AsSpan(_data, index));
			}

			internal JsonTokenType GetJsonTokenType(int index)
			{
				uint num = MemoryMarshal.Read<uint>(MemoryExtensions.AsSpan(_data, index + 8));
				return (JsonTokenType)(num >> 28);
			}

			internal MetadataDb CopySegment(int startIndex, int endIndex)
			{
				DbRow dbRow = Get(startIndex);
				int num = endIndex - startIndex;
				byte[] array = new byte[num];
				MemoryExtensions.AsSpan(_data, startIndex, num).CopyTo(array);
				Span<int> span = MemoryMarshal.Cast<byte, int>(array);
				int num2 = span[0];
				if (dbRow.TokenType == JsonTokenType.String)
				{
					num2--;
				}
				for (int num3 = (num - 12) / 4; num3 >= 0; num3 -= 3)
				{
					span[num3] -= num2;
				}
				return new MetadataDb(array);
			}
		}

		private readonly struct StackRow
		{
			internal const int Size = 8;

			internal readonly int SizeOrLength;

			internal readonly int NumberOfRows;

			internal StackRow(int sizeOrLength = 0, int numberOfRows = -1)
			{
				SizeOrLength = sizeOrLength;
				NumberOfRows = numberOfRows;
			}
		}

		private struct StackRowStack : IDisposable
		{
			private byte[] _rentedBuffer;

			private int _topOfStack;

			public StackRowStack(int initialSize)
			{
				_rentedBuffer = ArrayPool<byte>.Shared.Rent(initialSize);
				_topOfStack = _rentedBuffer.Length;
			}

			public void Dispose()
			{
				byte[] rentedBuffer = _rentedBuffer;
				_rentedBuffer = null;
				_topOfStack = 0;
				if (rentedBuffer != null)
				{
					ArrayPool<byte>.Shared.Return(rentedBuffer);
				}
			}

			internal void Push(StackRow row)
			{
				if (_topOfStack < 8)
				{
					Enlarge();
				}
				_topOfStack -= 8;
				MemoryMarshal.Write(MemoryExtensions.AsSpan(_rentedBuffer, _topOfStack), ref row);
			}

			internal StackRow Pop()
			{
				StackRow result = MemoryMarshal.Read<StackRow>(MemoryExtensions.AsSpan(_rentedBuffer, _topOfStack));
				_topOfStack += 8;
				return result;
			}

			private void Enlarge()
			{
				byte[] rentedBuffer = _rentedBuffer;
				_rentedBuffer = ArrayPool<byte>.Shared.Rent(rentedBuffer.Length * 2);
				Buffer.BlockCopy(rentedBuffer, _topOfStack, _rentedBuffer, _rentedBuffer.Length - rentedBuffer.Length + _topOfStack, rentedBuffer.Length - _topOfStack);
				_topOfStack += _rentedBuffer.Length - rentedBuffer.Length;
				ArrayPool<byte>.Shared.Return(rentedBuffer);
			}
		}

		private ReadOnlyMemory<byte> _utf8Json;

		private MetadataDb _parsedData;

		private byte[] _extraRentedArrayPoolBytes;

		private PooledByteBufferWriter _extraPooledByteBufferWriter;

		private static JsonDocument s_nullLiteral;

		private static JsonDocument s_trueLiteral;

		private static JsonDocument s_falseLiteral;

		private const int UnseekableStreamInitialRentSize = 4096;

		internal bool IsDisposable { get; }

		public JsonElement RootElement => new JsonElement(this, 0);

		private JsonDocument(ReadOnlyMemory<byte> utf8Json, MetadataDb parsedData, byte[] extraRentedArrayPoolBytes = null, PooledByteBufferWriter extraPooledByteBufferWriter = null, bool isDisposable = true)
		{
			_utf8Json = utf8Json;
			_parsedData = parsedData;
			_extraRentedArrayPoolBytes = extraRentedArrayPoolBytes;
			_extraPooledByteBufferWriter = extraPooledByteBufferWriter;
			IsDisposable = isDisposable;
		}

		public void Dispose()
		{
			int length = _utf8Json.Length;
			if (length == 0 || !IsDisposable)
			{
				return;
			}
			_parsedData.Dispose();
			_utf8Json = ReadOnlyMemory<byte>.Empty;
			if (_extraRentedArrayPoolBytes != null)
			{
				byte[] array = Interlocked.Exchange(ref _extraRentedArrayPoolBytes, null);
				if (array != null)
				{
					MemoryExtensions.AsSpan(array, 0, length).Clear();
					ArrayPool<byte>.Shared.Return(array);
				}
			}
			else if (_extraPooledByteBufferWriter != null)
			{
				Interlocked.Exchange(ref _extraPooledByteBufferWriter, null)?.Dispose();
			}
		}

		public void WriteTo(Utf8JsonWriter writer)
		{
			if (writer == null)
			{
				ThrowHelper.ThrowArgumentNullException("writer");
			}
			RootElement.WriteTo(writer);
		}

		internal JsonTokenType GetJsonTokenType(int index)
		{
			CheckNotDisposed();
			return _parsedData.GetJsonTokenType(index);
		}

		internal int GetArrayLength(int index)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.StartArray, dbRow.TokenType);
			return dbRow.SizeOrLength;
		}

		internal JsonElement GetArrayIndexElement(int currentIndex, int arrayIndex)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(currentIndex);
			CheckExpectedType(JsonTokenType.StartArray, dbRow.TokenType);
			int sizeOrLength = dbRow.SizeOrLength;
			if ((uint)arrayIndex >= (uint)sizeOrLength)
			{
				throw new IndexOutOfRangeException();
			}
			if (!dbRow.HasComplexChildren)
			{
				return new JsonElement(this, currentIndex + (arrayIndex + 1) * 12);
			}
			int num = 0;
			for (int i = currentIndex + 12; i < _parsedData.Length; i += 12)
			{
				if (arrayIndex == num)
				{
					return new JsonElement(this, i);
				}
				dbRow = _parsedData.Get(i);
				if (!dbRow.IsSimpleValue)
				{
					i += 12 * dbRow.NumberOfRows;
				}
				num++;
			}
			throw new IndexOutOfRangeException();
		}

		internal int GetEndIndex(int index, bool includeEndElement)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			if (dbRow.IsSimpleValue)
			{
				return index + 12;
			}
			int num = index + 12 * dbRow.NumberOfRows;
			if (includeEndElement)
			{
				num += 12;
			}
			return num;
		}

		internal ReadOnlyMemory<byte> GetRootRawValue()
		{
			return GetRawValue(0, includeQuotes: true);
		}

		internal ReadOnlyMemory<byte> GetRawValue(int index, bool includeQuotes)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			if (dbRow.IsSimpleValue)
			{
				if (includeQuotes && dbRow.TokenType == JsonTokenType.String)
				{
					return _utf8Json.Slice(dbRow.Location - 1, dbRow.SizeOrLength + 2);
				}
				return _utf8Json.Slice(dbRow.Location, dbRow.SizeOrLength);
			}
			int endIndex = GetEndIndex(index, includeEndElement: false);
			int location = dbRow.Location;
			dbRow = _parsedData.Get(endIndex);
			return _utf8Json.Slice(location, dbRow.Location - location + dbRow.SizeOrLength);
		}

		private ReadOnlyMemory<byte> GetPropertyRawValue(int valueIndex)
		{
			CheckNotDisposed();
			int num = _parsedData.Get(valueIndex - 12).Location - 1;
			DbRow dbRow = _parsedData.Get(valueIndex);
			int num2;
			if (dbRow.IsSimpleValue)
			{
				num2 = dbRow.Location + dbRow.SizeOrLength;
				if (dbRow.TokenType == JsonTokenType.String)
				{
					num2++;
				}
				return _utf8Json.Slice(num, num2 - num);
			}
			int endIndex = GetEndIndex(valueIndex, includeEndElement: false);
			dbRow = _parsedData.Get(endIndex);
			num2 = dbRow.Location + dbRow.SizeOrLength;
			return _utf8Json.Slice(num, num2 - num);
		}

		internal string GetString(int index, JsonTokenType expectedType)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			JsonTokenType tokenType = dbRow.TokenType;
			if (tokenType == JsonTokenType.Null)
			{
				return null;
			}
			CheckExpectedType(expectedType, tokenType);
			ReadOnlySpan<byte> readOnlySpan = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (!dbRow.HasComplexChildren)
			{
				return JsonReaderHelper.TranscodeHelper(readOnlySpan);
			}
			return JsonReaderHelper.GetUnescapedString(readOnlySpan);
		}

		internal bool TextEquals(int index, ReadOnlySpan<char> otherText, bool isPropertyName)
		{
			CheckNotDisposed();
			byte[] array = null;
			int num = checked(otherText.Length * 3);
			Span<byte> span = ((num > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(num))) : stackalloc byte[256]);
			Span<byte> destination = span;
			int written;
			OperationStatus operationStatus = JsonWriterHelper.ToUtf8(otherText, destination, out written);
			bool result = operationStatus != OperationStatus.InvalidData && TextEquals(index, destination.Slice(0, written), isPropertyName, shouldUnescape: true);
			if (array != null)
			{
				destination.Slice(0, written).Clear();
				ArrayPool<byte>.Shared.Return(array);
			}
			return result;
		}

		internal bool TextEquals(int index, ReadOnlySpan<byte> otherUtf8Text, bool isPropertyName, bool shouldUnescape)
		{
			CheckNotDisposed();
			int index2 = (isPropertyName ? (index - 12) : index);
			DbRow dbRow = _parsedData.Get(index2);
			CheckExpectedType(isPropertyName ? JsonTokenType.PropertyName : JsonTokenType.String, dbRow.TokenType);
			ReadOnlySpan<byte> span = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (otherUtf8Text.Length > span.Length || (!shouldUnescape && otherUtf8Text.Length != span.Length))
			{
				return false;
			}
			if (dbRow.HasComplexChildren && shouldUnescape)
			{
				if (otherUtf8Text.Length < span.Length / 6)
				{
					return false;
				}
				int num = span.IndexOf<byte>(92);
				if (!otherUtf8Text.StartsWith(span.Slice(0, num)))
				{
					return false;
				}
				return JsonReaderHelper.UnescapeAndCompare(span.Slice(num), otherUtf8Text.Slice(num));
			}
			return span.SequenceEqual(otherUtf8Text);
		}

		internal string GetNameOfPropertyValue(int index)
		{
			return GetString(index - 12, JsonTokenType.PropertyName);
		}

		internal bool TryGetValue(int index, [NotNullWhen(true)] out byte[] value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.String, dbRow.TokenType);
			ReadOnlySpan<byte> readOnlySpan = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (dbRow.HasComplexChildren)
			{
				return JsonReaderHelper.TryGetUnescapedBase64Bytes(readOnlySpan, out value);
			}
			return JsonReaderHelper.TryDecodeBase64(readOnlySpan, out value);
		}

		internal bool TryGetValue(int index, out sbyte value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
			ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (Utf8Parser.TryParse(source, out sbyte value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
			{
				value = value2;
				return true;
			}
			value = 0;
			return false;
		}

		internal bool TryGetValue(int index, out byte value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
			ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (Utf8Parser.TryParse(source, out byte value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
			{
				value = value2;
				return true;
			}
			value = 0;
			return false;
		}

		internal bool TryGetValue(int index, out short value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
			ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (Utf8Parser.TryParse(source, out short value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
			{
				value = value2;
				return true;
			}
			value = 0;
			return false;
		}

		internal bool TryGetValue(int index, out ushort value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
			ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (Utf8Parser.TryParse(source, out ushort value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
			{
				value = value2;
				return true;
			}
			value = 0;
			return false;
		}

		internal bool TryGetValue(int index, out int value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
			ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (Utf8Parser.TryParse(source, out int value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
			{
				value = value2;
				return true;
			}
			value = 0;
			return false;
		}

		internal bool TryGetValue(int index, out uint value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
			ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (Utf8Parser.TryParse(source, out uint value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
			{
				value = value2;
				return true;
			}
			value = 0u;
			return false;
		}

		internal bool TryGetValue(int index, out long value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
			ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (Utf8Parser.TryParse(source, out long value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
			{
				value = value2;
				return true;
			}
			value = 0L;
			return false;
		}

		internal bool TryGetValue(int index, out ulong value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
			ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (Utf8Parser.TryParse(source, out ulong value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
			{
				value = value2;
				return true;
			}
			value = 0uL;
			return false;
		}

		internal bool TryGetValue(int index, out double value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
			ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (Utf8Parser.TryParse(source, out double value2, out int bytesConsumed, '\0') && source.Length == bytesConsumed)
			{
				value = value2;
				return true;
			}
			value = 0.0;
			return false;
		}

		internal bool TryGetValue(int index, out float value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
			ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (Utf8Parser.TryParse(source, out float value2, out int bytesConsumed, '\0') && source.Length == bytesConsumed)
			{
				value = value2;
				return true;
			}
			value = 0f;
			return false;
		}

		internal bool TryGetValue(int index, out decimal value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
			ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (Utf8Parser.TryParse(source, out decimal value2, out int bytesConsumed, '\0') && source.Length == bytesConsumed)
			{
				value = value2;
				return true;
			}
			value = default(decimal);
			return false;
		}

		internal bool TryGetValue(int index, out DateTime value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.String, dbRow.TokenType);
			ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (!JsonHelpers.IsValidDateTimeOffsetParseLength(source.Length))
			{
				value = default(DateTime);
				return false;
			}
			if (dbRow.HasComplexChildren)
			{
				return JsonReaderHelper.TryGetEscapedDateTime(source, out value);
			}
			if (JsonHelpers.TryParseAsISO(source, out DateTime value2))
			{
				value = value2;
				return true;
			}
			value = default(DateTime);
			return false;
		}

		internal bool TryGetValue(int index, out DateTimeOffset value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.String, dbRow.TokenType);
			ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (!JsonHelpers.IsValidDateTimeOffsetParseLength(source.Length))
			{
				value = default(DateTimeOffset);
				return false;
			}
			if (dbRow.HasComplexChildren)
			{
				return JsonReaderHelper.TryGetEscapedDateTimeOffset(source, out value);
			}
			if (JsonHelpers.TryParseAsISO(source, out DateTimeOffset value2))
			{
				value = value2;
				return true;
			}
			value = default(DateTimeOffset);
			return false;
		}

		internal bool TryGetValue(int index, out Guid value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.String, dbRow.TokenType);
			ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
			if (source.Length > 216)
			{
				value = default(Guid);
				return false;
			}
			if (dbRow.HasComplexChildren)
			{
				return JsonReaderHelper.TryGetEscapedGuid(source, out value);
			}
			if (source.Length == 36 && Utf8Parser.TryParse(source, out Guid value2, out int _, 'D'))
			{
				value = value2;
				return true;
			}
			value = default(Guid);
			return false;
		}

		internal string GetRawValueAsString(int index)
		{
			return JsonReaderHelper.TranscodeHelper(GetRawValue(index, includeQuotes: true).Span);
		}

		internal string GetPropertyRawValueAsString(int valueIndex)
		{
			return JsonReaderHelper.TranscodeHelper(GetPropertyRawValue(valueIndex).Span);
		}

		internal JsonElement CloneElement(int index)
		{
			int endIndex = GetEndIndex(index, includeEndElement: true);
			MetadataDb parsedData = _parsedData.CopySegment(index, endIndex);
			ReadOnlyMemory<byte> utf8Json = GetRawValue(index, includeQuotes: true).ToArray();
			JsonDocument jsonDocument = new JsonDocument(utf8Json, parsedData, null, null, isDisposable: false);
			return jsonDocument.RootElement;
		}

		internal void WriteElementTo(int index, Utf8JsonWriter writer)
		{
			CheckNotDisposed();
			DbRow row = _parsedData.Get(index);
			switch (row.TokenType)
			{
			case JsonTokenType.StartObject:
				writer.WriteStartObject();
				WriteComplexElement(index, writer);
				break;
			case JsonTokenType.StartArray:
				writer.WriteStartArray();
				WriteComplexElement(index, writer);
				break;
			case JsonTokenType.String:
				WriteString(in row, writer);
				break;
			case JsonTokenType.Number:
				writer.WriteNumberValue(_utf8Json.Slice(row.Location, row.SizeOrLength).Span);
				break;
			case JsonTokenType.True:
				writer.WriteBooleanValue(value: true);
				break;
			case JsonTokenType.False:
				writer.WriteBooleanValue(value: false);
				break;
			case JsonTokenType.Null:
				writer.WriteNullValue();
				break;
			case JsonTokenType.EndObject:
			case JsonTokenType.EndArray:
			case JsonTokenType.PropertyName:
			case JsonTokenType.Comment:
				break;
			}
		}

		private void WriteComplexElement(int index, Utf8JsonWriter writer)
		{
			int endIndex = GetEndIndex(index, includeEndElement: true);
			for (int i = index + 12; i < endIndex; i += 12)
			{
				DbRow row = _parsedData.Get(i);
				switch (row.TokenType)
				{
				case JsonTokenType.String:
					WriteString(in row, writer);
					break;
				case JsonTokenType.Number:
					writer.WriteNumberValue(_utf8Json.Slice(row.Location, row.SizeOrLength).Span);
					break;
				case JsonTokenType.True:
					writer.WriteBooleanValue(value: true);
					break;
				case JsonTokenType.False:
					writer.WriteBooleanValue(value: false);
					break;
				case JsonTokenType.Null:
					writer.WriteNullValue();
					break;
				case JsonTokenType.StartObject:
					writer.WriteStartObject();
					break;
				case JsonTokenType.EndObject:
					writer.WriteEndObject();
					break;
				case JsonTokenType.StartArray:
					writer.WriteStartArray();
					break;
				case JsonTokenType.EndArray:
					writer.WriteEndArray();
					break;
				case JsonTokenType.PropertyName:
					WritePropertyName(in row, writer);
					break;
				}
			}
		}

		private ReadOnlySpan<byte> UnescapeString(in DbRow row, out ArraySegment<byte> rented)
		{
			int location = row.Location;
			int sizeOrLength = row.SizeOrLength;
			ReadOnlySpan<byte> span = _utf8Json.Slice(location, sizeOrLength).Span;
			if (!row.HasComplexChildren)
			{
				rented = default(ArraySegment<byte>);
				return span;
			}
			byte[] array = ArrayPool<byte>.Shared.Rent(sizeOrLength);
			JsonReaderHelper.Unescape(span, array, out var written);
			rented = new ArraySegment<byte>(array, 0, written);
			return rented.AsSpan();
		}

		private static void ClearAndReturn(ArraySegment<byte> rented)
		{
			if (rented.Array != null)
			{
				rented.AsSpan().Clear();
				ArrayPool<byte>.Shared.Return(rented.Array);
			}
		}

		private void WritePropertyName(in DbRow row, Utf8JsonWriter writer)
		{
			ArraySegment<byte> rented = default(ArraySegment<byte>);
			try
			{
				writer.WritePropertyName(UnescapeString(in row, out rented));
			}
			finally
			{
				ClearAndReturn(rented);
			}
		}

		private void WriteString(in DbRow row, Utf8JsonWriter writer)
		{
			ArraySegment<byte> rented = default(ArraySegment<byte>);
			try
			{
				writer.WriteStringValue(UnescapeString(in row, out rented));
			}
			finally
			{
				ClearAndReturn(rented);
			}
		}

		private static void Parse(ReadOnlySpan<byte> utf8JsonSpan, JsonReaderOptions readerOptions, ref MetadataDb database, ref StackRowStack stack)
		{
			bool flag = false;
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			Utf8JsonReader utf8JsonReader = new Utf8JsonReader(utf8JsonSpan, isFinalBlock: true, new JsonReaderState(readerOptions));
			while (utf8JsonReader.Read())
			{
				JsonTokenType tokenType = utf8JsonReader.TokenType;
				int num4 = (int)utf8JsonReader.TokenStartIndex;
				switch (tokenType)
				{
				case JsonTokenType.StartObject:
				{
					if (flag)
					{
						num++;
					}
					num3++;
					database.Append(tokenType, num4, -1);
					StackRow row2 = new StackRow(num2 + 1);
					stack.Push(row2);
					num2 = 0;
					break;
				}
				case JsonTokenType.EndObject:
				{
					int index = database.FindIndexOfFirstUnsetSizeOrLength(JsonTokenType.StartObject);
					num3++;
					num2++;
					database.SetLength(index, num2);
					int length2 = database.Length;
					database.Append(tokenType, num4, utf8JsonReader.ValueSpan.Length);
					database.SetNumberOfRows(index, num2);
					database.SetNumberOfRows(length2, num2);
					num2 += stack.Pop().SizeOrLength;
					break;
				}
				case JsonTokenType.StartArray:
				{
					if (flag)
					{
						num++;
					}
					num2++;
					database.Append(tokenType, num4, -1);
					StackRow row = new StackRow(num, num3 + 1);
					stack.Push(row);
					num = 0;
					num3 = 0;
					break;
				}
				case JsonTokenType.EndArray:
				{
					int num5 = database.FindIndexOfFirstUnsetSizeOrLength(JsonTokenType.StartArray);
					num3++;
					num2++;
					database.SetLength(num5, num);
					database.SetNumberOfRows(num5, num3);
					if (num + 1 != num3)
					{
						database.SetHasComplexChildren(num5);
					}
					int length = database.Length;
					database.Append(tokenType, num4, utf8JsonReader.ValueSpan.Length);
					database.SetNumberOfRows(length, num3);
					StackRow stackRow = stack.Pop();
					num = stackRow.SizeOrLength;
					num3 += stackRow.NumberOfRows;
					break;
				}
				case JsonTokenType.PropertyName:
					num3++;
					num2++;
					database.Append(tokenType, num4 + 1, utf8JsonReader.ValueSpan.Length);
					if (utf8JsonReader.ValueIsEscaped)
					{
						database.SetHasComplexChildren(database.Length - 12);
					}
					break;
				default:
					num3++;
					num2++;
					if (flag)
					{
						num++;
					}
					if (tokenType == JsonTokenType.String)
					{
						database.Append(tokenType, num4 + 1, utf8JsonReader.ValueSpan.Length);
						if (utf8JsonReader.ValueIsEscaped)
						{
							database.SetHasComplexChildren(database.Length - 12);
						}
					}
					else
					{
						database.Append(tokenType, num4, utf8JsonReader.ValueSpan.Length);
					}
					break;
				}
				flag = utf8JsonReader.IsInArray;
			}
			database.CompleteAllocations();
		}

		private void CheckNotDisposed()
		{
			if (_utf8Json.IsEmpty)
			{
				ThrowHelper.ThrowObjectDisposedException_JsonDocument();
			}
		}

		private static void CheckExpectedType(JsonTokenType expected, JsonTokenType actual)
		{
			if (expected != actual)
			{
				ThrowHelper.ThrowJsonElementWrongTypeException(expected, actual);
			}
		}

		private static void CheckSupportedOptions(JsonReaderOptions readerOptions, string paramName)
		{
			if (readerOptions.CommentHandling == JsonCommentHandling.Allow)
			{
				throw new ArgumentException(System.SR.JsonDocumentDoesNotSupportComments, paramName);
			}
		}

		public static JsonDocument Parse(ReadOnlyMemory<byte> utf8Json, JsonDocumentOptions options = default(JsonDocumentOptions))
		{
			return Parse(utf8Json, options.GetReaderOptions());
		}

		public static JsonDocument Parse(ReadOnlySequence<byte> utf8Json, JsonDocumentOptions options = default(JsonDocumentOptions))
		{
			JsonReaderOptions readerOptions = options.GetReaderOptions();
			if (utf8Json.IsSingleSegment)
			{
				return Parse(utf8Json.First, readerOptions);
			}
			int num = checked((int)utf8Json.Length);
			byte[] array = ArrayPool<byte>.Shared.Rent(num);
			try
			{
				utf8Json.CopyTo(MemoryExtensions.AsSpan(array));
				return Parse(MemoryExtensions.AsMemory(array, 0, num), readerOptions, array);
			}
			catch
			{
				MemoryExtensions.AsSpan(array, 0, num).Clear();
				ArrayPool<byte>.Shared.Return(array);
				throw;
			}
		}

		public static JsonDocument Parse(Stream utf8Json, JsonDocumentOptions options = default(JsonDocumentOptions))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			ArraySegment<byte> segment = ReadToEnd(utf8Json);
			try
			{
				return Parse(segment.AsMemory(), options.GetReaderOptions(), segment.Array);
			}
			catch
			{
				segment.AsSpan().Clear();
				ArrayPool<byte>.Shared.Return(segment.Array);
				throw;
			}
		}

		internal static JsonDocument ParseRented(PooledByteBufferWriter utf8Json, JsonDocumentOptions options = default(JsonDocumentOptions))
		{
			return Parse(utf8Json.WrittenMemory, options.GetReaderOptions(), null, utf8Json);
		}

		internal static JsonDocument ParseValue(Stream utf8Json, JsonDocumentOptions options)
		{
			ArraySegment<byte> segment = ReadToEnd(utf8Json);
			byte[] array = new byte[segment.Count];
			Buffer.BlockCopy(segment.Array, 0, array, 0, segment.Count);
			segment.AsSpan().Clear();
			ArrayPool<byte>.Shared.Return(segment.Array);
			return ParseUnrented(MemoryExtensions.AsMemory(array), options.GetReaderOptions());
		}

		internal static JsonDocument ParseValue(ReadOnlySpan<byte> utf8Json, JsonDocumentOptions options)
		{
			byte[] array = new byte[utf8Json.Length];
			utf8Json.CopyTo(array);
			return ParseUnrented(MemoryExtensions.AsMemory(array), options.GetReaderOptions());
		}

		internal static JsonDocument ParseValue(string json, JsonDocumentOptions options)
		{
			return ParseValue(MemoryExtensions.AsMemory(json), options);
		}

		public static Task<JsonDocument> ParseAsync(Stream utf8Json, JsonDocumentOptions options = default(JsonDocumentOptions), CancellationToken cancellationToken = default(CancellationToken))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			return ParseAsyncCore(utf8Json, options, cancellationToken);
		}

		private static async Task<JsonDocument> ParseAsyncCore(Stream utf8Json, JsonDocumentOptions options = default(JsonDocumentOptions), CancellationToken cancellationToken = default(CancellationToken))
		{
			ArraySegment<byte> segment = await ReadToEndAsync(utf8Json, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			try
			{
				return Parse(segment.AsMemory(), options.GetReaderOptions(), segment.Array);
			}
			catch
			{
				segment.AsSpan().Clear();
				ArrayPool<byte>.Shared.Return(segment.Array);
				throw;
			}
		}

		internal static async Task<JsonDocument> ParseAsyncCoreUnrented(Stream utf8Json, JsonDocumentOptions options = default(JsonDocumentOptions), CancellationToken cancellationToken = default(CancellationToken))
		{
			ArraySegment<byte> segment = await ReadToEndAsync(utf8Json, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			byte[] array = new byte[segment.Count];
			Buffer.BlockCopy(segment.Array, 0, array, 0, segment.Count);
			segment.AsSpan().Clear();
			ArrayPool<byte>.Shared.Return(segment.Array);
			return ParseUnrented(MemoryExtensions.AsMemory(array), options.GetReaderOptions());
		}

		public static JsonDocument Parse([StringSyntax("Json")] ReadOnlyMemory<char> json, JsonDocumentOptions options = default(JsonDocumentOptions))
		{
			ReadOnlySpan<char> span = json.Span;
			int utf8ByteCount = JsonReaderHelper.GetUtf8ByteCount(span);
			byte[] array = ArrayPool<byte>.Shared.Rent(utf8ByteCount);
			try
			{
				int utf8FromText = JsonReaderHelper.GetUtf8FromText(span, array);
				return Parse(MemoryExtensions.AsMemory(array, 0, utf8FromText), options.GetReaderOptions(), array);
			}
			catch
			{
				MemoryExtensions.AsSpan(array, 0, utf8ByteCount).Clear();
				ArrayPool<byte>.Shared.Return(array);
				throw;
			}
		}

		internal static JsonDocument ParseValue(ReadOnlyMemory<char> json, JsonDocumentOptions options)
		{
			ReadOnlySpan<char> span = json.Span;
			int utf8ByteCount = JsonReaderHelper.GetUtf8ByteCount(span);
			byte[] array = ArrayPool<byte>.Shared.Rent(utf8ByteCount);
			byte[] array2;
			try
			{
				int utf8FromText = JsonReaderHelper.GetUtf8FromText(span, array);
				array2 = new byte[utf8FromText];
				Buffer.BlockCopy(array, 0, array2, 0, utf8FromText);
			}
			finally
			{
				MemoryExtensions.AsSpan(array, 0, utf8ByteCount).Clear();
				ArrayPool<byte>.Shared.Return(array);
			}
			return ParseUnrented(MemoryExtensions.AsMemory(array2), options.GetReaderOptions());
		}

		public static JsonDocument Parse([StringSyntax("Json")] string json, JsonDocumentOptions options = default(JsonDocumentOptions))
		{
			if (json == null)
			{
				ThrowHelper.ThrowArgumentNullException("json");
			}
			return Parse(MemoryExtensions.AsMemory(json), options);
		}

		public static bool TryParseValue(ref Utf8JsonReader reader, [NotNullWhen(true)] out JsonDocument? document)
		{
			return TryParseValue(ref reader, out document, shouldThrow: false, useArrayPools: true);
		}

		public static JsonDocument ParseValue(ref Utf8JsonReader reader)
		{
			JsonDocument document;
			bool flag = TryParseValue(ref reader, out document, shouldThrow: true, useArrayPools: true);
			return document;
		}

		internal static bool TryParseValue(ref Utf8JsonReader reader, [NotNullWhen(true)] out JsonDocument document, bool shouldThrow, bool useArrayPools)
		{
			JsonReaderState currentState = reader.CurrentState;
			CheckSupportedOptions(currentState.Options, "reader");
			Utf8JsonReader utf8JsonReader = reader;
			ReadOnlySpan<byte> readOnlySpan = default(ReadOnlySpan<byte>);
			ReadOnlySequence<byte> sequence = default(ReadOnlySequence<byte>);
			try
			{
				JsonTokenType tokenType = reader.TokenType;
				ReadOnlySpan<byte> bytes;
				if ((tokenType == JsonTokenType.None || tokenType == JsonTokenType.PropertyName) && !reader.Read())
				{
					if (shouldThrow)
					{
						bytes = default(ReadOnlySpan<byte>);
						ThrowHelper.ThrowJsonReaderException(ref reader, ExceptionResource.ExpectedJsonTokens, 0, bytes);
					}
					reader = utf8JsonReader;
					document = null;
					return false;
				}
				switch (reader.TokenType)
				{
				case JsonTokenType.StartObject:
				case JsonTokenType.StartArray:
				{
					long tokenStartIndex = reader.TokenStartIndex;
					if (!reader.TrySkip())
					{
						if (shouldThrow)
						{
							bytes = default(ReadOnlySpan<byte>);
							ThrowHelper.ThrowJsonReaderException(ref reader, ExceptionResource.ExpectedJsonTokens, 0, bytes);
						}
						reader = utf8JsonReader;
						document = null;
						return false;
					}
					long num3 = reader.BytesConsumed - tokenStartIndex;
					ReadOnlySequence<byte> originalSequence2 = reader.OriginalSequence;
					if (originalSequence2.IsEmpty)
					{
						bytes = reader.OriginalSpan;
						readOnlySpan = checked(bytes.Slice((int)tokenStartIndex, (int)num3));
					}
					else
					{
						sequence = originalSequence2.Slice(tokenStartIndex, num3);
					}
					break;
				}
				case JsonTokenType.True:
				case JsonTokenType.False:
				case JsonTokenType.Null:
					if (useArrayPools)
					{
						if (reader.HasValueSequence)
						{
							sequence = reader.ValueSequence;
						}
						else
						{
							readOnlySpan = reader.ValueSpan;
						}
						break;
					}
					document = CreateForLiteral(reader.TokenType);
					return true;
				case JsonTokenType.Number:
					if (reader.HasValueSequence)
					{
						sequence = reader.ValueSequence;
					}
					else
					{
						readOnlySpan = reader.ValueSpan;
					}
					break;
				case JsonTokenType.String:
				{
					ReadOnlySequence<byte> originalSequence = reader.OriginalSequence;
					if (originalSequence.IsEmpty)
					{
						bytes = reader.ValueSpan;
						int length = bytes.Length + 2;
						readOnlySpan = reader.OriginalSpan.Slice((int)reader.TokenStartIndex, length);
						break;
					}
					long num = 2L;
					if (reader.HasValueSequence)
					{
						num += reader.ValueSequence.Length;
					}
					else
					{
						long num2 = num;
						bytes = reader.ValueSpan;
						num = num2 + bytes.Length;
					}
					sequence = originalSequence.Slice(reader.TokenStartIndex, num);
					break;
				}
				default:
					if (shouldThrow)
					{
						bytes = reader.ValueSpan;
						byte nextByte = bytes[0];
						bytes = default(ReadOnlySpan<byte>);
						ThrowHelper.ThrowJsonReaderException(ref reader, ExceptionResource.ExpectedStartOfValueNotFound, nextByte, bytes);
					}
					reader = utf8JsonReader;
					document = null;
					return false;
				}
			}
			catch
			{
				reader = utf8JsonReader;
				throw;
			}
			int num4 = (readOnlySpan.IsEmpty ? checked((int)sequence.Length) : readOnlySpan.Length);
			if (useArrayPools)
			{
				byte[] array = ArrayPool<byte>.Shared.Rent(num4);
				Span<byte> destination = MemoryExtensions.AsSpan(array, 0, num4);
				try
				{
					if (readOnlySpan.IsEmpty)
					{
						sequence.CopyTo(destination);
					}
					else
					{
						readOnlySpan.CopyTo(destination);
					}
					document = Parse(MemoryExtensions.AsMemory(array, 0, num4), currentState.Options, array);
				}
				catch
				{
					destination.Clear();
					ArrayPool<byte>.Shared.Return(array);
					throw;
				}
			}
			else
			{
				byte[] array2 = ((!readOnlySpan.IsEmpty) ? readOnlySpan.ToArray() : BuffersExtensions.ToArray(in sequence));
				document = ParseUnrented(array2, currentState.Options, reader.TokenType);
			}
			return true;
		}

		private static JsonDocument CreateForLiteral(JsonTokenType tokenType)
		{
			switch (tokenType)
			{
			case JsonTokenType.False:
				if (s_falseLiteral == null)
				{
					s_falseLiteral = Create(JsonConstants.FalseValue.ToArray());
				}
				return s_falseLiteral;
			case JsonTokenType.True:
				if (s_trueLiteral == null)
				{
					s_trueLiteral = Create(JsonConstants.TrueValue.ToArray());
				}
				return s_trueLiteral;
			default:
				if (s_nullLiteral == null)
				{
					s_nullLiteral = Create(JsonConstants.NullValue.ToArray());
				}
				return s_nullLiteral;
			}
			JsonDocument Create(byte[] utf8Json)
			{
				MetadataDb parsedData = MetadataDb.CreateLocked(utf8Json.Length);
				parsedData.Append(tokenType, 0, utf8Json.Length);
				return new JsonDocument(utf8Json, parsedData, null, null, isDisposable: false);
			}
		}

		private static JsonDocument Parse(ReadOnlyMemory<byte> utf8Json, JsonReaderOptions readerOptions, byte[] extraRentedArrayPoolBytes = null, PooledByteBufferWriter extraPooledByteBufferWriter = null)
		{
			ReadOnlySpan<byte> span = utf8Json.Span;
			MetadataDb database = MetadataDb.CreateRented(utf8Json.Length, convertToAlloc: false);
			StackRowStack stack = new StackRowStack(512);
			try
			{
				Parse(span, readerOptions, ref database, ref stack);
			}
			catch
			{
				database.Dispose();
				throw;
			}
			finally
			{
				stack.Dispose();
			}
			return new JsonDocument(utf8Json, database, extraRentedArrayPoolBytes, extraPooledByteBufferWriter);
		}

		private static JsonDocument ParseUnrented(ReadOnlyMemory<byte> utf8Json, JsonReaderOptions readerOptions, JsonTokenType tokenType = JsonTokenType.None)
		{
			ReadOnlySpan<byte> span = utf8Json.Span;
			MetadataDb database;
			if (tokenType == JsonTokenType.String || tokenType == JsonTokenType.Number)
			{
				database = MetadataDb.CreateLocked(utf8Json.Length);
				StackRowStack stack = default(StackRowStack);
				Parse(span, readerOptions, ref database, ref stack);
			}
			else
			{
				database = MetadataDb.CreateRented(utf8Json.Length, convertToAlloc: true);
				StackRowStack stack2 = new StackRowStack(512);
				try
				{
					Parse(span, readerOptions, ref database, ref stack2);
				}
				finally
				{
					stack2.Dispose();
				}
			}
			return new JsonDocument(utf8Json, database, null, null, isDisposable: false);
		}

		private static ArraySegment<byte> ReadToEnd(Stream stream)
		{
			int num = 0;
			byte[] array = null;
			ReadOnlySpan<byte> utf8Bom = JsonConstants.Utf8Bom;
			try
			{
				if (stream.CanSeek)
				{
					long num2 = Math.Max(utf8Bom.Length, stream.Length - stream.Position) + 1;
					array = ArrayPool<byte>.Shared.Rent(checked((int)num2));
				}
				else
				{
					array = ArrayPool<byte>.Shared.Rent(4096);
				}
				int num3;
				do
				{
					num3 = stream.Read(array, num, utf8Bom.Length - num);
					num += num3;
				}
				while (num3 > 0 && num < utf8Bom.Length);
				if (num == utf8Bom.Length && utf8Bom.SequenceEqual(MemoryExtensions.AsSpan(array, 0, utf8Bom.Length)))
				{
					num = 0;
				}
				do
				{
					if (array.Length == num)
					{
						byte[] array2 = array;
						array = ArrayPool<byte>.Shared.Rent(checked(array2.Length * 2));
						Buffer.BlockCopy(array2, 0, array, 0, array2.Length);
						ArrayPool<byte>.Shared.Return(array2, clearArray: true);
					}
					num3 = stream.Read(array, num, array.Length - num);
					num += num3;
				}
				while (num3 > 0);
				return new ArraySegment<byte>(array, 0, num);
			}
			catch
			{
				if (array != null)
				{
					MemoryExtensions.AsSpan(array, 0, num).Clear();
					ArrayPool<byte>.Shared.Return(array);
				}
				throw;
			}
		}

		private static async Task<ArraySegment<byte>> ReadToEndAsync(Stream stream, CancellationToken cancellationToken)
		{
			int written = 0;
			byte[] rented = null;
			try
			{
				int utf8BomLength = JsonConstants.Utf8Bom.Length;
				if (stream.CanSeek)
				{
					long num = Math.Max(utf8BomLength, stream.Length - stream.Position) + 1;
					rented = ArrayPool<byte>.Shared.Rent(checked((int)num));
				}
				else
				{
					rented = ArrayPool<byte>.Shared.Rent(4096);
				}
				int num2;
				do
				{
					num2 = await stream.ReadAsync(rented, written, utf8BomLength - written, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					written += num2;
				}
				while (num2 > 0 && written < utf8BomLength);
				if (written == utf8BomLength && JsonConstants.Utf8Bom.SequenceEqual(MemoryExtensions.AsSpan(rented, 0, utf8BomLength)))
				{
					written = 0;
				}
				do
				{
					if (rented.Length == written)
					{
						byte[] array = rented;
						rented = ArrayPool<byte>.Shared.Rent(array.Length * 2);
						Buffer.BlockCopy(array, 0, rented, 0, array.Length);
						ArrayPool<byte>.Shared.Return(array, clearArray: true);
					}
					num2 = await stream.ReadAsync(rented, written, rented.Length - written, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					written += num2;
				}
				while (num2 > 0);
				return new ArraySegment<byte>(rented, 0, written);
			}
			catch
			{
				if (rented != null)
				{
					MemoryExtensions.AsSpan(rented, 0, written).Clear();
					ArrayPool<byte>.Shared.Return(rented);
				}
				throw;
			}
		}

		internal bool TryGetNamedPropertyValue(int index, ReadOnlySpan<char> propertyName, out JsonElement value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.StartObject, dbRow.TokenType);
			if (dbRow.NumberOfRows == 1)
			{
				value = default(JsonElement);
				return false;
			}
			int maxByteCount = JsonReaderHelper.s_utf8Encoding.GetMaxByteCount(propertyName.Length);
			int startIndex = index + 12;
			int num = checked(dbRow.NumberOfRows * 12 + index);
			if (maxByteCount < 256)
			{
				Span<byte> span = stackalloc byte[256];
				span = span[..JsonReaderHelper.GetUtf8FromText(propertyName, span)];
				return TryGetNamedPropertyValue(startIndex, num, span, out value);
			}
			int length = propertyName.Length;
			int num2;
			for (num2 = num - 12; num2 > index; num2 -= 12)
			{
				int num3 = num2;
				dbRow = _parsedData.Get(num2);
				num2 = ((!dbRow.IsSimpleValue) ? (num2 - 12 * (dbRow.NumberOfRows + 1)) : (num2 - 12));
				if (_parsedData.Get(num2).SizeOrLength >= length)
				{
					byte[] array = ArrayPool<byte>.Shared.Rent(maxByteCount);
					Span<byte> span2 = default(Span<byte>);
					try
					{
						int utf8FromText = JsonReaderHelper.GetUtf8FromText(propertyName, array);
						span2 = MemoryExtensions.AsSpan(array, 0, utf8FromText);
						return TryGetNamedPropertyValue(startIndex, num3 + 12, span2, out value);
					}
					finally
					{
						span2.Clear();
						ArrayPool<byte>.Shared.Return(array);
					}
				}
			}
			value = default(JsonElement);
			return false;
		}

		internal bool TryGetNamedPropertyValue(int index, ReadOnlySpan<byte> propertyName, out JsonElement value)
		{
			CheckNotDisposed();
			DbRow dbRow = _parsedData.Get(index);
			CheckExpectedType(JsonTokenType.StartObject, dbRow.TokenType);
			if (dbRow.NumberOfRows == 1)
			{
				value = default(JsonElement);
				return false;
			}
			int endIndex = checked(dbRow.NumberOfRows * 12 + index);
			return TryGetNamedPropertyValue(index + 12, endIndex, propertyName, out value);
		}

		private bool TryGetNamedPropertyValue(int startIndex, int endIndex, ReadOnlySpan<byte> propertyName, out JsonElement value)
		{
			ReadOnlySpan<byte> span = _utf8Json.Span;
			Span<byte> span2 = stackalloc byte[256];
			int num;
			for (num = endIndex - 12; num > startIndex; num -= 12)
			{
				DbRow dbRow = _parsedData.Get(num);
				num = ((!dbRow.IsSimpleValue) ? (num - 12 * (dbRow.NumberOfRows + 1)) : (num - 12));
				dbRow = _parsedData.Get(num);
				ReadOnlySpan<byte> span3 = span.Slice(dbRow.Location, dbRow.SizeOrLength);
				if (dbRow.HasComplexChildren)
				{
					if (span3.Length > propertyName.Length)
					{
						int num2 = span3.IndexOf<byte>(92);
						if (propertyName.Length > num2 && span3.Slice(0, num2).SequenceEqual(propertyName.Slice(0, num2)))
						{
							int num3 = span3.Length - num2;
							int written = 0;
							byte[] array = null;
							try
							{
								Span<byte> destination = ((num3 <= span2.Length) ? span2 : ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(num3))));
								JsonReaderHelper.Unescape(span3.Slice(num2), destination, 0, out written);
								if (destination.Slice(0, written).SequenceEqual(propertyName.Slice(num2)))
								{
									value = new JsonElement(this, num + 12);
									return true;
								}
							}
							finally
							{
								if (array != null)
								{
									MemoryExtensions.AsSpan(array, 0, written).Clear();
									ArrayPool<byte>.Shared.Return(array);
								}
							}
						}
					}
				}
				else if (span3.SequenceEqual(propertyName))
				{
					value = new JsonElement(this, num + 12);
					return true;
				}
			}
			value = default(JsonElement);
			return false;
		}
	}
	public struct JsonDocumentOptions
	{
		internal const int DefaultMaxDepth = 64;

		private int _maxDepth;

		private JsonCommentHandling _commentHandling;

		public JsonCommentHandling CommentHandling
		{
			readonly get
			{
				return _commentHandling;
			}
			set
			{
				if ((int)value > 1)
				{
					throw new ArgumentOutOfRangeException("value", System.SR.JsonDocumentDoesNotSupportComments);
				}
				_commentHandling = value;
			}
		}

		public int MaxDepth
		{
			readonly get
			{
				return _maxDepth;
			}
			set
			{
				if (value < 0)
				{
					ThrowHelper.ThrowArgumentOutOfRangeException_MaxDepthMustBePositive("value");
				}
				_maxDepth = value;
			}
		}

		public bool AllowTrailingCommas { get; set; }

		internal JsonReaderOptions GetReaderOptions()
		{
			return new JsonReaderOptions
			{
				AllowTrailingCommas = AllowTrailingCommas,
				CommentHandling = CommentHandling,
				MaxDepth = MaxDepth
			};
		}
	}
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly struct JsonElement
	{
		[DebuggerDisplay("{Current,nq}")]
		public struct ArrayEnumerator : IEnumerable<JsonElement>, IEnumerable, IEnumerator<JsonElement>, IEnumerator, IDisposable
		{
			private readonly JsonElement _target;

			private int _curIdx;

			private readonly int _endIdxOrVersion;

			public JsonElement Current
			{
				get
				{
					if (_curIdx < 0)
					{
						return default(JsonElement);
					}
					return new JsonElement(_target._parent, _curIdx);
				}
			}

			object IEnumerator.Current => Current;

			internal ArrayEnumerator(JsonElement target)
			{
				_target = target;
				_curIdx = -1;
				_endIdxOrVersion = target._parent.GetEndIndex(_target._idx, includeEndElement: false);
			}

			public ArrayEnumerator GetEnumerator()
			{
				ArrayEnumerator result = this;
				result._curIdx = -1;
				return result;
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator<JsonElement> IEnumerable<JsonElement>.GetEnumerator()
			{
				return GetEnumerator();
			}

			public void Dispose()
			{
				_curIdx = _endIdxOrVersion;
			}

			public void Reset()
			{
				_curIdx = -1;
			}

			public bool MoveNext()
			{
				if (_curIdx >= _endIdxOrVersion)
				{
					return false;
				}
				if (_curIdx < 0)
				{
					_curIdx = _target._idx + 12;
				}
				else
				{
					_curIdx = _target._parent.GetEndIndex(_curIdx, includeEndElement: true);
				}
				return _curIdx < _endIdxOrVersion;
			}
		}

		[DebuggerDisplay("{Current,nq}")]
		public struct ObjectEnumerator : IEnumerable<JsonProperty>, IEnumerable, IEnumerator<JsonProperty>, IEnumerator, IDisposable
		{
			private readonly JsonElement _target;

			private int _curIdx;

			private readonly int _endIdxOrVersion;

			public JsonProperty Current
			{
				get
				{
					if (_curIdx < 0)
					{
						return default(JsonProperty);
					}
					return new JsonProperty(new JsonElement(_target._parent, _curIdx));
				}
			}

			object IEnumerator.Current => Current;

			internal ObjectEnumerator(JsonElement target)
			{
				_target = target;
				_curIdx = -1;
				_endIdxOrVersion = target._parent.GetEndIndex(_target._idx, includeEndElement: false);
			}

			public ObjectEnumerator GetEnumerator()
			{
				ObjectEnumerator result = this;
				result._curIdx = -1;
				return result;
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator<JsonProperty> IEnumerable<JsonProperty>.GetEnumerator()
			{
				return GetEnumerator();
			}

			public void Dispose()
			{
				_curIdx = _endIdxOrVersion;
			}

			public void Reset()
			{
				_curIdx = -1;
			}

			public bool MoveNext()
			{
				if (_curIdx >= _endIdxOrVersion)
				{
					return false;
				}
				if (_curIdx < 0)
				{
					_curIdx = _target._idx + 12;
				}
				else
				{
					_curIdx = _target._parent.GetEndIndex(_curIdx, includeEndElement: true);
				}
				_curIdx += 12;
				return _curIdx < _endIdxOrVersion;
			}
		}

		private readonly JsonDocument _parent;

		private readonly int _idx;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private JsonTokenType TokenType => _parent?.GetJsonTokenType(_idx) ?? JsonTokenType.None;

		public JsonValueKind ValueKind => TokenType.ToValueKind();

		public JsonElement this[int index]
		{
			get
			{
				CheckValidInstance();
				return _parent.GetArrayIndexElement(_idx, index);
			}
		}

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private string DebuggerDisplay => $"ValueKind = {ValueKind} : \"{ToString()}\"";

		internal JsonElement(JsonDocument parent, int idx)
		{
			_parent = parent;
			_idx = idx;
		}

		public int GetArrayLength()
		{
			CheckValidInstance();
			return _parent.GetArrayLength(_idx);
		}

		public JsonElement GetProperty(string propertyName)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			if (TryGetProperty(propertyName, out var value))
			{
				return value;
			}
			throw new KeyNotFoundException();
		}

		public JsonElement GetProperty(ReadOnlySpan<char> propertyName)
		{
			if (TryGetProperty(propertyName, out var value))
			{
				return value;
			}
			throw new KeyNotFoundException();
		}

		public JsonElement GetProperty(ReadOnlySpan<byte> utf8PropertyName)
		{
			if (TryGetProperty(utf8PropertyName, out var value))
			{
				return value;
			}
			throw new KeyNotFoundException();
		}

		public bool TryGetProperty(string propertyName, out JsonElement value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			return TryGetProperty(MemoryExtensions.AsSpan(propertyName), out value);
		}

		public bool TryGetProperty(ReadOnlySpan<char> propertyName, out JsonElement value)
		{
			CheckValidInstance();
			return _parent.TryGetNamedPropertyValue(_idx, propertyName, out value);
		}

		public bool TryGetProperty(ReadOnlySpan<byte> utf8PropertyName, out JsonElement value)
		{
			CheckValidInstance();
			return _parent.TryGetNamedPropertyValue(_idx, utf8PropertyName, out value);
		}

		public bool GetBoolean()
		{
			JsonTokenType tokenType = TokenType;
			return tokenType switch
			{
				JsonTokenType.False => false, 
				JsonTokenType.True => true, 
				_ => ThrowJsonElementWrongTypeException(tokenType), 
			};
			static bool ThrowJsonElementWrongTypeException(JsonTokenType actualType)
			{
				throw ThrowHelper.GetJsonElementWrongTypeException("Boolean", actualType.ToValueKind());
			}
		}

		public string? GetString()
		{
			CheckValidInstance();
			return _parent.GetString(_idx, JsonTokenType.String);
		}

		public bool TryGetBytesFromBase64([NotNullWhen(true)] out byte[]? value)
		{
			CheckValidInstance();
			return _parent.TryGetValue(_idx, out value);
		}

		public byte[] GetBytesFromBase64()
		{
			if (!TryGetBytesFromBase64(out byte[] value))
			{
				ThrowHelper.ThrowFormatException();
			}
			return value;
		}

		[CLSCompliant(false)]
		public bool TryGetSByte(out sbyte value)
		{
			CheckValidInstance();
			return _parent.TryGetValue(_idx, out value);
		}

		[CLSCompliant(false)]
		public sbyte GetSByte()
		{
			if (TryGetSByte(out var value))
			{
				return value;
			}
			throw new FormatException();
		}

		public bool TryGetByte(out byte value)
		{
			CheckValidInstance();
			return _parent.TryGetValue(_idx, out value);
		}

		public byte GetByte()
		{
			if (TryGetByte(out var value))
			{
				return value;
			}
			throw new FormatException();
		}

		public bool TryGetInt16(out short value)
		{
			CheckValidInstance();
			return _parent.TryGetValue(_idx, out value);
		}

		public short GetInt16()
		{
			if (TryGetInt16(out var value))
			{
				return value;
			}
			throw new FormatException();
		}

		[CLSCompliant(false)]
		public bool TryGetUInt16(out ushort value)
		{
			CheckValidInstance();
			return _parent.TryGetValue(_idx, out value);
		}

		[CLSCompliant(false)]
		public ushort GetUInt16()
		{
			if (TryGetUInt16(out var value))
			{
				return value;
			}
			throw new FormatException();
		}

		public bool TryGetInt32(out int value)
		{
			CheckValidInstance();
			return _parent.TryGetValue(_idx, out value);
		}

		public int GetInt32()
		{
			if (!TryGetInt32(out var value))
			{
				ThrowHelper.ThrowFormatException();
			}
			return value;
		}

		[CLSCompliant(false)]
		public bool TryGetUInt32(out uint value)
		{
			CheckValidInstance();
			return _parent.TryGetValue(_idx, out value);
		}

		[CLSCompliant(false)]
		public uint GetUInt32()
		{
			if (!TryGetUInt32(out var value))
			{
				ThrowHelper.ThrowFormatException();
			}
			return value;
		}

		public bool TryGetInt64(out long value)
		{
			CheckValidInstance();
			return _parent.TryGetValue(_idx, out value);
		}

		public long GetInt64()
		{
			if (!TryGetInt64(out var value))
			{
				ThrowHelper.ThrowFormatException();
			}
			return value;
		}

		[CLSCompliant(false)]
		public bool TryGetUInt64(out ulong value)
		{
			CheckValidInstance();
			return _parent.TryGetValue(_idx, out value);
		}

		[CLSCompliant(false)]
		public ulong GetUInt64()
		{
			if (!TryGetUInt64(out var value))
			{
				ThrowHelper.ThrowFormatException();
			}
			return value;
		}

		public bool TryGetDouble(out double value)
		{
			CheckValidInstance();
			return _parent.TryGetValue(_idx, out value);
		}

		public double GetDouble()
		{
			if (!TryGetDouble(out var value))
			{
				ThrowHelper.ThrowFormatException();
			}
			return value;
		}

		public bool TryGetSingle(out float value)
		{
			CheckValidInstance();
			return _parent.TryGetValue(_idx, out value);
		}

		public float GetSingle()
		{
			if (!TryGetSingle(out var value))
			{
				ThrowHelper.ThrowFormatException();
			}
			return value;
		}

		public bool TryGetDecimal(out decimal value)
		{
			CheckValidInstance();
			return _parent.TryGetValue(_idx, out value);
		}

		public decimal GetDecimal()
		{
			if (!TryGetDecimal(out var value))
			{
				ThrowHelper.ThrowFormatException();
			}
			return value;
		}

		public bool TryGetDateTime(out DateTime value)
		{
			CheckValidInstance();
			return _parent.TryGetValue(_idx, out value);
		}

		public DateTime GetDateTime()
		{
			if (!TryGetDateTime(out var value))
			{
				ThrowHelper.ThrowFormatException();
			}
			return value;
		}

		public bool TryGetDateTimeOffset(out DateTimeOffset value)
		{
			CheckValidInstance();
			return _parent.TryGetValue(_idx, out value);
		}

		public DateTimeOffset GetDateTimeOffset()
		{
			if (!TryGetDateTimeOffset(out var value))
			{
				ThrowHelper.ThrowFormatException();
			}
			return value;
		}

		public bool TryGetGuid(out Guid value)
		{
			CheckValidInstance();
			return _parent.TryGetValue(_idx, out value);
		}

		public Guid GetGuid()
		{
			if (!TryGetGuid(out var value))
			{
				ThrowHelper.ThrowFormatException();
			}
			return value;
		}

		internal string GetPropertyName()
		{
			CheckValidInstance();
			return _parent.GetNameOfPropertyValue(_idx);
		}

		public string GetRawText()
		{
			CheckValidInstance();
			return _parent.GetRawValueAsString(_idx);
		}

		internal ReadOnlyMemory<byte> GetRawValue()
		{
			CheckValidInstance();
			return _parent.GetRawValue(_idx, includeQuotes: true);
		}

		internal string GetPropertyRawText()
		{
			CheckValidInstance();
			return _parent.GetPropertyRawValueAsString(_idx);
		}

		public bool ValueEquals(string? text)
		{
			if (TokenType == JsonTokenType.Null)
			{
				return text == null;
			}
			return TextEqualsHelper(MemoryExtensions.AsSpan(text), isPropertyName: false);
		}

		public bool ValueEquals(ReadOnlySpan<byte> utf8Text)
		{
			if (TokenType == JsonTokenType.Null)
			{
				return utf8Text == default(ReadOnlySpan<byte>);
			}
			return TextEqualsHelper(utf8Text, isPropertyName: false, shouldUnescape: true);
		}

		public bool ValueEquals(ReadOnlySpan<char> text)
		{
			if (TokenType == JsonTokenType.Null)
			{
				return text == default(ReadOnlySpan<char>);
			}
			return TextEqualsHelper(text, isPropertyName: false);
		}

		internal bool TextEqualsHelper(ReadOnlySpan<byte> utf8Text, bool isPropertyName, bool shouldUnescape)
		{
			CheckValidInstance();
			return _parent.TextEquals(_idx, utf8Text, isPropertyName, shouldUnescape);
		}

		internal bool TextEqualsHelper(ReadOnlySpan<char> text, bool isPropertyName)
		{
			CheckValidInstance();
			return _parent.TextEquals(_idx, text, isPropertyName);
		}

		public void WriteTo(Utf8JsonWriter writer)
		{
			if (writer == null)
			{
				ThrowHelper.ThrowArgumentNullException("writer");
			}
			CheckValidInstance();
			_parent.WriteElementTo(_idx, writer);
		}

		public ArrayEnumerator EnumerateArray()
		{
			CheckValidInstance();
			JsonTokenType tokenType = TokenType;
			if (tokenType != JsonTokenType.StartArray)
			{
				ThrowHelper.ThrowJsonElementWrongTypeException(JsonTokenType.StartArray, tokenType);
			}
			return new ArrayEnumerator(this);
		}

		public ObjectEnumerator EnumerateObject()
		{
			CheckValidInstance();
			JsonTokenType tokenType = TokenType;
			if (tokenType != JsonTokenType.StartObject)
			{
				ThrowHelper.ThrowJsonElementWrongTypeException(JsonTokenType.StartObject, tokenType);
			}
			return new ObjectEnumerator(this);
		}

		public override string ToString()
		{
			switch (TokenType)
			{
			case JsonTokenType.None:
			case JsonTokenType.Null:
				return string.Empty;
			case JsonTokenType.True:
				return bool.TrueString;
			case JsonTokenType.False:
				return bool.FalseString;
			case JsonTokenType.StartObject:
			case JsonTokenType.StartArray:
			case JsonTokenType.Number:
				return _parent.GetRawValueAsString(_idx);
			case JsonTokenType.String:
				return GetString();
			default:
				return string.Empty;
			}
		}

		public JsonElement Clone()
		{
			CheckValidInstance();
			if (!_parent.IsDisposable)
			{
				return this;
			}
			return _parent.CloneElement(_idx);
		}

		private void CheckValidInstance()
		{
			if (_parent == null)
			{
				throw new InvalidOperationException();
			}
		}

		public static JsonElement ParseValue(ref Utf8JsonReader reader)
		{
			JsonDocument document;
			bool flag = JsonDocument.TryParseValue(ref reader, out document, shouldThrow: true, useArrayPools: false);
			return document.RootElement;
		}

		internal static JsonElement ParseValue(Stream utf8Json, JsonDocumentOptions options)
		{
			JsonDocument jsonDocument = JsonDocument.ParseValue(utf8Json, options);
			return jsonDocument.RootElement;
		}

		internal static JsonElement ParseValue(ReadOnlySpan<byte> utf8Json, JsonDocumentOptions options)
		{
			JsonDocument jsonDocument = JsonDocument.ParseValue(utf8Json, options);
			return jsonDocument.RootElement;
		}

		internal static JsonElement ParseValue(string json, JsonDocumentOptions options)
		{
			JsonDocument jsonDocument = JsonDocument.ParseValue(json, options);
			return jsonDocument.RootElement;
		}

		public static bool TryParseValue(ref Utf8JsonReader reader, [NotNullWhen(true)] out JsonElement? element)
		{
			JsonDocument document;
			bool result = JsonDocument.TryParseValue(ref reader, out document, shouldThrow: false, useArrayPools: false);
			element = document?.RootElement;
			return result;
		}
	}
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly struct JsonProperty
	{
		public JsonElement Value { get; }

		private string? _name { get; }

		public string Name => _name ?? Value.GetPropertyName();

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private string DebuggerDisplay
		{
			get
			{
				if (Value.ValueKind != JsonValueKind.Undefined)
				{
					return "\"" + ToString() + "\"";
				}
				return "<Undefined>";
			}
		}

		internal JsonProperty(JsonElement value, string name = null)
		{
			Value = value;
			_name = name;
		}

		public bool NameEquals(string? text)
		{
			return NameEquals(MemoryExtensions.AsSpan(text));
		}

		public bool NameEquals(ReadOnlySpan<byte> utf8Text)
		{
			return Value.TextEqualsHelper(utf8Text, isPropertyName: true, shouldUnescape: true);
		}

		public bool NameEquals(ReadOnlySpan<char> text)
		{
			return Value.TextEqualsHelper(text, isPropertyName: true);
		}

		internal bool EscapedNameEquals(ReadOnlySpan<byte> utf8Text)
		{
			return Value.TextEqualsHelper(utf8Text, isPropertyName: true, shouldUnescape: false);
		}

		public void WriteTo(Utf8JsonWriter writer)
		{
			if (writer == null)
			{
				ThrowHelper.ThrowArgumentNullException("writer");
			}
			writer.WritePropertyName(Name);
			Value.WriteTo(writer);
		}

		public override string ToString()
		{
			return Value.GetPropertyRawText();
		}
	}
	public enum JsonValueKind : byte
	{
		Undefined,
		Object,
		Array,
		String,
		Number,
		True,
		False,
		Null
	}
	public readonly struct JsonEncodedText : IEquatable<JsonEncodedText>
	{
		internal readonly byte[] _utf8Value;

		internal readonly string _value;

		public ReadOnlySpan<byte> EncodedUtf8Bytes => _utf8Value;

		public string Value => _value ?? string.Empty;

		private JsonEncodedText(byte[] utf8Value)
		{
			_value = JsonReaderHelper.GetTextFromUtf8(utf8Value);
			_utf8Value = utf8Value;
		}

		public static JsonEncodedText Encode(string value, JavaScriptEncoder? encoder = null)
		{
			if (value == null)
			{
				ThrowHelper.ThrowArgumentNullException("value");
			}
			return Encode(MemoryExtensions.AsSpan(value), encoder);
		}

		public static JsonEncodedText Encode(ReadOnlySpan<char> value, JavaScriptEncoder? encoder = null)
		{
			if (value.Length == 0)
			{
				return new JsonEncodedText(Array.Empty<byte>());
			}
			return TranscodeAndEncode(value, encoder);
		}

		private static JsonEncodedText TranscodeAndEncode(ReadOnlySpan<char> value, JavaScriptEncoder encoder)
		{
			JsonWriterHelper.ValidateValue(value);
			int utf8ByteCount = JsonReaderHelper.GetUtf8ByteCount(value);
			byte[] array = ArrayPool<byte>.Shared.Rent(utf8ByteCount);
			int utf8FromText = JsonReaderHelper.GetUtf8FromText(value, array);
			JsonEncodedText result = EncodeHelper(MemoryExtensions.AsSpan(array, 0, utf8FromText), encoder);
			MemoryExtensions.AsSpan(array, 0, utf8ByteCount).Clear();
			ArrayPool<byte>.Shared.Return(array);
			return result;
		}

		public static JsonEncodedText Encode(ReadOnlySpan<byte> utf8Value, JavaScriptEncoder? encoder = null)
		{
			if (utf8Value.Length == 0)
			{
				return new JsonEncodedText(Array.Empty<byte>());
			}
			JsonWriterHelper.ValidateValue(utf8Value);
			return EncodeHelper(utf8Value, encoder);
		}

		private static JsonEncodedText EncodeHelper(ReadOnlySpan<byte> utf8Value, JavaScriptEncoder encoder)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8Value, encoder);
			if (num != -1)
			{
				return new JsonEncodedText(JsonHelpers.EscapeValue(utf8Value, num, encoder));
			}
			return new JsonEncodedText(utf8Value.ToArray());
		}

		public bool Equals(JsonEncodedText other)
		{
			if (_value == null)
			{
				return other._value == null;
			}
			return _value.Equals(other._value);
		}

		public override bool Equals([NotNullWhen(true)] object? obj)
		{
			if (obj is JsonEncodedText other)
			{
				return Equals(other);
			}
			return false;
		}

		public override string ToString()
		{
			return _value ?? string.Empty;
		}

		public override int GetHashCode()
		{
			if (_value != null)
			{
				return _value.GetHashCode();
			}
			return 0;
		}
	}
	[Serializable]
	public class JsonException : Exception
	{
		internal string _message;

		internal bool AppendPathInformation { get; set; }

		public long? LineNumber { get; internal set; }

		public long? BytePositionInLine { get; internal set; }

		public string? Path { get; internal set; }

		public override string Message => _message ?? base.Message;

		public JsonException(string? message, string? path, long? lineNumber, long? bytePositionInLine, Exception? innerException)
			: base(message, innerException)
		{
			_message = message;
			LineNumber = lineNumber;
			BytePositionInLine = bytePositionInLine;
			Path = path;
		}

		public JsonException(string? message, string? path, long? lineNumber, long? bytePositionInLine)
			: base(message)
		{
			_message = message;
			LineNumber = lineNumber;
			BytePositionInLine = bytePositionInLine;
			Path = path;
		}

		public JsonException(string? message, Exception? innerException)
			: base(message, innerException)
		{
			_message = message;
		}

		public JsonException(string? message)
			: base(message)
		{
			_message = message;
		}

		public JsonException()
		{
		}

		protected JsonException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			LineNumber = (long?)info.GetValue("LineNumber", typeof(long?));
			BytePositionInLine = (long?)info.GetValue("BytePositionInLine", typeof(long?));
			Path = info.GetString("Path");
			SetMessage(info.GetString("ActualMessage"));
		}

		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("LineNumber", LineNumber, typeof(long?));
			info.AddValue("BytePositionInLine", BytePositionInLine, typeof(long?));
			info.AddValue("Path", Path, typeof(string));
			info.AddValue("ActualMessage", Message, typeof(string));
		}

		internal void SetMessage(string message)
		{
			_message = message;
		}
	}
	internal sealed class JsonPropertyDictionary<T> where T : class
	{
		private sealed class KeyCollection : IList<string>, ICollection<string>, IEnumerable<string>, IEnumerable
		{
			private readonly JsonPropertyDictionary<T> _parent;

			public int Count => _parent.Count;

			public bool IsReadOnly => true;

			public string this[int index]
			{
				get
				{
					return _parent.List[index].Key;
				}
				set
				{
					throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
				}
			}

			public KeyCollection(JsonPropertyDictionary<T> jsonObject)
			{
				_parent = jsonObject;
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				foreach (KeyValuePair<string, T> item in _parent)
				{
					yield return item.Key;
				}
			}

			public void Add(string propertyName)
			{
				ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
			}

			public void Clear()
			{
				ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
			}

			public bool Contains(string propertyName)
			{
				return _parent.ContainsProperty(propertyName);
			}

			public void CopyTo(string[] propertyNameArray, int index)
			{
				if (index < 0)
				{
					ThrowHelper.ThrowArgumentOutOfRangeException_ArrayIndexNegative("index");
				}
				foreach (KeyValuePair<string, T> item in _parent)
				{
					if (index >= propertyNameArray.Length)
					{
						ThrowHelper.ThrowArgumentException_ArrayTooSmall("propertyNameArray");
					}
					propertyNameArray[index++] = item.Key;
				}
			}

			public IEnumerator<string> GetEnumerator()
			{
				foreach (KeyValuePair<string, T> item in _parent)
				{
					yield return item.Key;
				}
			}

			bool ICollection<string>.Remove(string propertyName)
			{
				throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
			}

			public int IndexOf(string item)
			{
				throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
			}

			public void Insert(int index, string item)
			{
				throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
			}

			public void RemoveAt(int index)
			{
				throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
			}
		}

		private sealed class ValueCollection : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
		{
			private readonly JsonPropertyDictionary<T> _parent;

			public int Count => _parent.Count;

			public bool IsReadOnly => true;

			public T this[int index]
			{
				get
				{
					return _parent.List[index].Value;
				}
				set
				{
					throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
				}
			}

			public ValueCollection(JsonPropertyDictionary<T> jsonObject)
			{
				_parent = jsonObject;
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				foreach (KeyValuePair<string, T> item in _parent)
				{
					yield return item.Value;
				}
			}

			public void Add(T jsonNode)
			{
				ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
			}

			public void Clear()
			{
				ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
			}

			public bool Contains(T jsonNode)
			{
				return _parent.ContainsValue(jsonNode);
			}

			public void CopyTo(T[] nodeArray, int index)
			{
				if (index < 0)
				{
					ThrowHelper.ThrowArgumentOutOfRangeException_ArrayIndexNegative("index");
				}
				foreach (KeyValuePair<string, T> item in _parent)
				{
					if (index >= nodeArray.Length)
					{
						ThrowHelper.ThrowArgumentException_ArrayTooSmall("nodeArray");
					}
					nodeArray[index++] = item.Value;
				}
			}

			public IEnumerator<T> GetEnumerator()
			{
				foreach (KeyValuePair<string, T> item in _parent)
				{
					yield return item.Value;
				}
			}

			bool ICollection<T>.Remove(T node)
			{
				throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
			}

			public int IndexOf(T item)
			{
				throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
			}

			public void Insert(int index, T item)
			{
				throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
			}

			public void RemoveAt(int index)
			{
				throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
			}
		}

		private const int ListToDictionaryThreshold = 9;

		private Dictionary<string, T> _propertyDictionary;

		private readonly List<KeyValuePair<string, T>> _propertyList;

		private readonly StringComparer _stringComparer;

		private KeyCollection _keyCollection;

		private ValueCollection _valueCollection;

		public List<KeyValuePair<string, T>> List => _propertyList;

		public int Count => _propertyList.Count;

		public IList<string> Keys => GetKeyCollection();

		public IList<T> Values => GetValueCollection();

		public bool IsReadOnly { get; set; }

		public T this[string propertyName]
		{
			get
			{
				if (TryGetPropertyValue(propertyName, out var value))
				{
					return value;
				}
				return null;
			}
			[param: DisallowNull]
			set
			{
				SetValue(propertyName, value, out var _);
			}
		}

		public JsonPropertyDictionary(bool caseInsensitive)
		{
			_stringComparer = (caseInsensitive ? StringComparer.OrdinalIgnoreCase : StringComparer.Ordinal);
			_propertyList = new List<KeyValuePair<string, T>>();
		}

		public JsonPropertyDictionary(bool caseInsensitive, int capacity)
		{
			_stringComparer = (caseInsensitive ? StringComparer.OrdinalIgnoreCase : StringComparer.Ordinal);
			_propertyList = new List<KeyValuePair<string, T>>(capacity);
		}

		public void Add(string propertyName, T value)
		{
			if (IsReadOnly)
			{
				ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
			}
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			AddValue(propertyName, value);
		}

		public void Add(KeyValuePair<string, T> property)
		{
			if (IsReadOnly)
			{
				ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
			}
			Add(property.Key, property.Value);
		}

		public bool TryAdd(string propertyName, T value)
		{
			if (IsReadOnly)
			{
				ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
			}
			return TryAddValue(propertyName, value);
		}

		public void Clear()
		{
			if (IsReadOnly)
			{
				ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
			}
			_propertyList.Clear();
			_propertyDictionary?.Clear();
		}

		public bool ContainsKey(string propertyName)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			return ContainsProperty(propertyName);
		}

		public bool Remove(string propertyName)
		{
			if (IsReadOnly)
			{
				ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
			}
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			T existing;
			return TryRemoveProperty(propertyName, out existing);
		}

		public bool Contains(KeyValuePair<string, T> item)
		{
			using (List<KeyValuePair<string, T>>.Enumerator enumerator = GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					KeyValuePair<string, T> current = enumerator.Current;
					if (item.Value == current.Value && _stringComparer.Equals(item.Key, current.Key))
					{
						return true;
					}
				}
			}
			return false;
		}

		public void CopyTo(KeyValuePair<string, T>[] array, int index)
		{
			if (index < 0)
			{
				ThrowHelper.ThrowArgumentOutOfRangeException_ArrayIndexNegative("index");
			}
			foreach (KeyValuePair<string, T> property in _propertyList)
			{
				if (index >= array.Length)
				{
					ThrowHelper.ThrowArgumentException_ArrayTooSmall("array");
				}
				array[index++] = property;
			}
		}

		public List<KeyValuePair<string, T>>.Enumerator GetEnumerator()
		{
			return _propertyList.GetEnumerator();
		}

		public bool TryGetValue(string propertyName, [MaybeNullWhen(false)] out T value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			if (_propertyDictionary != null)
			{
				return _propertyDictionary.TryGetValue(propertyName, out value);
			}
			foreach (KeyValuePair<string, T> property in _propertyList)
			{
				if (_stringComparer.Equals(propertyName, property.Key))
				{
					value = property.Value;
					return true;
				}
			}
			value = null;
			return false;
		}

		public T SetValue(string propertyName, T value, out bool valueAlreadyInDictionary)
		{
			if (IsReadOnly)
			{
				ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
			}
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			CreateDictionaryIfThresholdMet();
			valueAlreadyInDictionary = false;
			T val = null;
			if (_propertyDictionary != null)
			{
				if (JsonHelpers.TryAdd(_propertyDictionary, propertyName, value))
				{
					_propertyList.Add(new KeyValuePair<string, T>(propertyName, value));
					return null;
				}
				val = _propertyDictionary[propertyName];
				if (val == value)
				{
					valueAlreadyInDictionary = true;
					return null;
				}
			}
			int num = FindValueIndex(propertyName);
			if (num >= 0)
			{
				if (_propertyDictionary != null)
				{
					_propertyDictionary[propertyName] = value;
				}
				else
				{
					KeyValuePair<string, T> keyValuePair = _propertyList[num];
					if (keyValuePair.Value == value)
					{
						valueAlreadyInDictionary = true;
						return null;
					}
					val = keyValuePair.Value;
				}
				_propertyList[num] = new KeyValuePair<string, T>(propertyName, value);
			}
			else
			{
				_propertyDictionary?.Add(propertyName, value);
				_propertyList.Add(new KeyValuePair<string, T>(propertyName, value));
			}
			return val;
		}

		private void AddValue(string propertyName, T value)
		{
			if (!TryAddValue(propertyName, value))
			{
				ThrowHelper.ThrowArgumentException_DuplicateKey("propertyName", propertyName);
			}
		}

		internal bool TryAddValue(string propertyName, T value)
		{
			if (IsReadOnly)
			{
				ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
			}
			CreateDictionaryIfThresholdMet();
			if (_propertyDictionary == null)
			{
				if (ContainsProperty(propertyName))
				{
					return false;
				}
			}
			else if (!JsonHelpers.TryAdd(_propertyDictionary, propertyName, value))
			{
				return false;
			}
			_propertyList.Add(new KeyValuePair<string, T>(propertyName, value));
			return true;
		}

		private void CreateDictionaryIfThresholdMet()
		{
			if (_propertyDictionary == null && _propertyList.Count > 9)
			{
				_propertyDictionary = JsonHelpers.CreateDictionaryFromCollection(_propertyList, _stringComparer);
			}
		}

		internal bool ContainsValue(T value)
		{
			foreach (T item in GetValueCollection())
			{
				if (item == value)
				{
					return true;
				}
			}
			return false;
		}

		public KeyValuePair<string, T>? FindValue(T value)
		{
			using (List<KeyValuePair<string, T>>.Enumerator enumerator = GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					KeyValuePair<string, T> current = enumerator.Current;
					if (current.Value == value)
					{
						return current;
					}
				}
			}
			return null;
		}

		private bool ContainsProperty(string propertyName)
		{
			if (_propertyDictionary != null)
			{
				return _propertyDictionary.ContainsKey(propertyName);
			}
			foreach (KeyValuePair<string, T> property in _propertyList)
			{
				if (_stringComparer.Equals(propertyName, property.Key))
				{
					return true;
				}
			}
			return false;
		}

		private int FindValueIndex(string propertyName)
		{
			for (int i = 0; i < _propertyList.Count; i++)
			{
				KeyValuePair<string, T> keyValuePair = _propertyList[i];
				if (_stringComparer.Equals(propertyName, keyValuePair.Key))
				{
					return i;
				}
			}
			return -1;
		}

		public bool TryGetPropertyValue(string propertyName, [MaybeNullWhen(false)] out T value)
		{
			return TryGetValue(propertyName, out value);
		}

		public bool TryRemoveProperty(string propertyName, [MaybeNullWhen(false)] out T existing)
		{
			if (IsReadOnly)
			{
				ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
			}
			if (_propertyDictionary != null)
			{
				if (!_propertyDictionary.TryGetValue(propertyName, out existing))
				{
					return false;
				}
				bool flag = _propertyDictionary.Remove(propertyName);
			}
			for (int i = 0; i < _propertyList.Count; i++)
			{
				KeyValuePair<string, T> keyValuePair = _propertyList[i];
				if (_stringComparer.Equals(keyValuePair.Key, propertyName))
				{
					_propertyList.RemoveAt(i);
					existing = keyValuePair.Value;
					return true;
				}
			}
			existing = null;
			return false;
		}

		public IList<string> GetKeyCollection()
		{
			return _keyCollection ?? (_keyCollection = new KeyCollection(this));
		}

		public IList<T> GetValueCollection()
		{
			return _valueCollection ?? (_valueCollection = new ValueCollection(this));
		}
	}
	public enum JsonTokenType : byte
	{
		None,
		StartObject,
		EndObject,
		StartArray,
		EndArray,
		PropertyName,
		Comment,
		String,
		Number,
		True,
		False,
		Null
	}
	internal enum ConsumeNumberResult : byte
	{
		Success,
		OperationIncomplete,
		NeedMoreData
	}
	internal enum ConsumeTokenResult : byte
	{
		Success,
		NotEnoughDataRollBackState,
		IncompleteNoRollBackNecessary
	}
	[Serializable]
	internal sealed class JsonReaderException : JsonException
	{
		public JsonReaderException(string message, long lineNumber, long bytePositionInLine)
			: base(message, null, lineNumber, bytePositionInLine)
		{
		}

		private JsonReaderException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}
	}
	internal static class JsonReaderHelper
	{
		private const string SpecialCharacters = ". '/\"[]()\t\n\r\f\b\\\u0085\u2028\u2029";

		public static readonly UTF8Encoding s_utf8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: true);

		private const ulong XorPowerOfTwoToHighByte = 283686952306184uL;

		public static bool ContainsSpecialCharacters(this ReadOnlySpan<char> text)
		{
			return text.IndexOfAny(MemoryExtensions.AsSpan(". '/\"[]()\t\n\r\f\b\\\u0085\u2028\u2029")) >= 0;
		}

		public static (int, int) CountNewLines(ReadOnlySpan<byte> data)
		{
			int num = data.LastIndexOf<byte>(10);
			int num2 = 0;
			if (num >= 0)
			{
				num2 = 1;
				data = data.Slice(0, num);
				int num3;
				while ((num3 = data.IndexOf<byte>(10)) >= 0)
				{
					num2++;
					data = data.Slice(num3 + 1);
				}
			}
			return (num2, num);
		}

		internal static JsonValueKind ToValueKind(this JsonTokenType tokenType)
		{
			switch (tokenType)
			{
			case JsonTokenType.None:
				return JsonValueKind.Undefined;
			case JsonTokenType.StartArray:
				return JsonValueKind.Array;
			case JsonTokenType.StartObject:
				return JsonValueKind.Object;
			case JsonTokenType.String:
			case JsonTokenType.Number:
			case JsonTokenType.True:
			case JsonTokenType.False:
			case JsonTokenType.Null:
				return (JsonValueKind)(tokenType - 4);
			default:
				return JsonValueKind.Undefined;
			}
		}

		public static bool IsTokenTypePrimitive(JsonTokenType tokenType)
		{
			return (int)(tokenType - 7) <= 4;
		}

		public static bool IsHexDigit(byte nextByte)
		{
			return System.HexConverter.IsHexChar(nextByte);
		}

		public static bool TryGetEscapedDateTime(ReadOnlySpan<byte> source, out DateTime value)
		{
			Span<byte> span = stackalloc byte[252];
			Unescape(source, span, out var written);
			span = span.Slice(0, written);
			if (JsonHelpers.IsValidUnescapedDateTimeOffsetParseLength(span.Length) && JsonHelpers.TryParseAsISO((ReadOnlySpan<byte>)span, out DateTime value2))
			{
				value = value2;
				return true;
			}
			value = default(DateTime);
			return false;
		}

		public static bool TryGetEscapedDateTimeOffset(ReadOnlySpan<byte> source, out DateTimeOffset value)
		{
			Span<byte> span = stackalloc byte[252];
			Unescape(source, span, out var written);
			span = span.Slice(0, written);
			if (JsonHelpers.IsValidUnescapedDateTimeOffsetParseLength(span.Length) && JsonHelpers.TryParseAsISO((ReadOnlySpan<byte>)span, out DateTimeOffset value2))
			{
				value = value2;
				return true;
			}
			value = default(DateTimeOffset);
			return false;
		}

		public static bool TryGetEscapedGuid(ReadOnlySpan<byte> source, out Guid value)
		{
			Span<byte> span = stackalloc byte[216];
			Unescape(source, span, out var written);
			span = span.Slice(0, written);
			if (span.Length == 36 && Utf8Parser.TryParse((ReadOnlySpan<byte>)span, out Guid value2, out int _, 'D'))
			{
				value = value2;
				return true;
			}
			value = default(Guid);
			return false;
		}

		public static bool TryGetFloatingPointConstant(ReadOnlySpan<byte> span, out float value)
		{
			if (span.Length == 3)
			{
				if (span.SequenceEqual(JsonConstants.NaNValue))
				{
					value = float.NaN;
					return true;
				}
			}
			else if (span.Length == 8)
			{
				if (span.SequenceEqual(JsonConstants.PositiveInfinityValue))
				{
					value = float.PositiveInfinity;
					return true;
				}
			}
			else if (span.Length == 9 && span.SequenceEqual(JsonConstants.NegativeInfinityValue))
			{
				value = float.NegativeInfinity;
				return true;
			}
			value = 0f;
			return false;
		}

		public static bool TryGetFloatingPointConstant(ReadOnlySpan<byte> span, out double value)
		{
			if (span.Length == 3)
			{
				if (span.SequenceEqual(JsonConstants.NaNValue))
				{
					value = double.NaN;
					return true;
				}
			}
			else if (span.Length == 8)
			{
				if (span.SequenceEqual(JsonConstants.PositiveInfinityValue))
				{
					value = double.PositiveInfinity;
					return true;
				}
			}
			else if (span.Length == 9 && span.SequenceEqual(JsonConstants.NegativeInfinityValue))
			{
				value = double.NegativeInfinity;
				return true;
			}
			value = 0.0;
			return false;
		}

		public static bool TryGetUnescapedBase64Bytes(ReadOnlySpan<byte> utf8Source, [NotNullWhen(true)] out byte[] bytes)
		{
			byte[] array = null;
			Span<byte> span = ((utf8Source.Length > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(utf8Source.Length))) : stackalloc byte[256]);
			Span<byte> span2 = span;
			Unescape(utf8Source, span2, out var written);
			span2 = span2.Slice(0, written);
			bool result = TryDecodeBase64InPlace(span2, out bytes);
			if (array != null)
			{
				span2.Clear();
				ArrayPool<byte>.Shared.Return(array);
			}
			return result;
		}

		public static string GetUnescapedString(ReadOnlySpan<byte> utf8Source)
		{
			int length = utf8Source.Length;
			byte[] array = null;
			Span<byte> span = ((length > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(length))) : stackalloc byte[256]);
			Span<byte> span2 = span;
			Unescape(utf8Source, span2, out var written);
			span2 = span2.Slice(0, written);
			string result = TranscodeHelper(span2);
			if (array != null)
			{
				span2.Clear();
				ArrayPool<byte>.Shared.Return(array);
			}
			return result;
		}

		public static ReadOnlySpan<byte> GetUnescapedSpan(ReadOnlySpan<byte> utf8Source)
		{
			int length = utf8Source.Length;
			byte[] array = null;
			Span<byte> span = ((length > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(length))) : stackalloc byte[256]);
			Span<byte> destination = span;
			Unescape(utf8Source, destination, out var written);
			ReadOnlySpan<byte> result = destination.Slice(0, written).ToArray();
			if (array != null)
			{
				new Span<byte>(array, 0, written).Clear();
				ArrayPool<byte>.Shared.Return(array);
			}
			return result;
		}

		public static bool UnescapeAndCompare(ReadOnlySpan<byte> utf8Source, ReadOnlySpan<byte> other)
		{
			byte[] array = null;
			Span<byte> span = ((utf8Source.Length > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(utf8Source.Length))) : stackalloc byte[256]);
			Span<byte> span2 = span;
			Unescape(utf8Source, span2, 0, out var written);
			span2 = span2.Slice(0, written);
			bool result = other.SequenceEqual(span2);
			if (array != null)
			{
				span2.Clear();
				ArrayPool<byte>.Shared.Return(array);
			}
			return result;
		}

		public static bool UnescapeAndCompare(ReadOnlySequence<byte> utf8Source, ReadOnlySpan<byte> other)
		{
			byte[] array = null;
			byte[] array2 = null;
			int num = checked((int)utf8Source.Length);
			Span<byte> span = ((num > 256) ? ((Span<byte>)(array2 = ArrayPool<byte>.Shared.Rent(num))) : stackalloc byte[256]);
			Span<byte> span2 = span;
			Span<byte> span3 = ((num > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(num))) : stackalloc byte[256]);
			Span<byte> span4 = span3;
			utf8Source.CopyTo(span4);
			span4 = span4.Slice(0, num);
			Unescape(span4, span2, 0, out var written);
			span2 = span2.Slice(0, written);
			bool result = other.SequenceEqual(span2);
			if (array2 != null)
			{
				span2.Clear();
				ArrayPool<byte>.Shared.Return(array2);
				span4.Clear();
				ArrayPool<byte>.Shared.Return(array);
			}
			return result;
		}

		public static bool TryDecodeBase64InPlace(Span<byte> utf8Unescaped, [NotNullWhen(true)] out byte[] bytes)
		{
			if (Base64.DecodeFromUtf8InPlace(utf8Unescaped, out var bytesWritten) != OperationStatus.Done)
			{
				bytes = null;
				return false;
			}
			bytes = utf8Unescaped.Slice(0, bytesWritten).ToArray();
			return true;
		}

		public static bool TryDecodeBase64(ReadOnlySpan<byte> utf8Unescaped, [NotNullWhen(true)] out byte[] bytes)
		{
			byte[] array = null;
			Span<byte> span = ((utf8Unescaped.Length > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(utf8Unescaped.Length))) : stackalloc byte[256]);
			Span<byte> bytes2 = span;
			if (Base64.DecodeFromUtf8(utf8Unescaped, bytes2, out var _, out var bytesWritten) != OperationStatus.Done)
			{
				bytes = null;
				if (array != null)
				{
					bytes2.Clear();
					ArrayPool<byte>.Shared.Return(array);
				}
				return false;
			}
			bytes = bytes2.Slice(0, bytesWritten).ToArray();
			if (array != null)
			{
				bytes2.Clear();
				ArrayPool<byte>.Shared.Return(array);
			}
			return true;
		}

		public unsafe static string TranscodeHelper(ReadOnlySpan<byte> utf8Unescaped)
		{
			try
			{
				if (utf8Unescaped.IsEmpty)
				{
					return string.Empty;
				}
				fixed (byte* bytes = utf8Unescaped)
				{
					return s_utf8Encoding.GetString(bytes, utf8Unescaped.Length);
				}
			}
			catch (DecoderFallbackException innerException)
			{
				throw ThrowHelper.GetInvalidOperationException_ReadInvalidUTF8(innerException);
			}
		}

		public unsafe static int TranscodeHelper(ReadOnlySpan<byte> utf8Unescaped, Span<char> destination)
		{
			try
			{
				if (utf8Unescaped.IsEmpty)
				{
					return 0;
				}
				fixed (byte* bytes = utf8Unescaped)
				{
					fixed (char* chars = destination)
					{
						return s_utf8Encoding.GetChars(bytes, utf8Unescaped.Length, chars, destination.Length);
					}
				}
			}
			catch (DecoderFallbackException innerException)
			{
				throw ThrowHelper.GetInvalidOperationException_ReadInvalidUTF8(innerException);
			}
			catch (ArgumentException)
			{
				destination.Clear();
				throw;
			}
		}

		public unsafe static void ValidateUtf8(ReadOnlySpan<byte> utf8Buffer)
		{
			try
			{
				if (utf8Buffer.IsEmpty)
				{
					return;
				}
				fixed (byte* bytes = utf8Buffer)
				{
					s_utf8Encoding.GetCharCount(bytes, utf8Buffer.Length);
				}
			}
			catch (DecoderFallbackException innerException)
			{
				throw ThrowHelper.GetInvalidOperationException_ReadInvalidUTF8(innerException);
			}
		}

		internal unsafe static int GetUtf8ByteCount(ReadOnlySpan<char> text)
		{
			try
			{
				if (text.IsEmpty)
				{
					return 0;
				}
				fixed (char* chars = text)
				{
					return s_utf8Encoding.GetByteCount(chars, text.Length);
				}
			}
			catch (EncoderFallbackException innerException)
			{
				throw ThrowHelper.GetArgumentException_ReadInvalidUTF16(innerException);
			}
		}

		internal unsafe static int GetUtf8FromText(ReadOnlySpan<char> text, Span<byte> dest)
		{
			try
			{
				if (text.IsEmpty)
				{
					return 0;
				}
				fixed (char* chars = text)
				{
					fixed (byte* bytes = dest)
					{
						return s_utf8Encoding.GetBytes(chars, text.Length, bytes, dest.Length);
					}
				}
			}
			catch (EncoderFallbackException innerException)
			{
				throw ThrowHelper.GetArgumentException_ReadInvalidUTF16(innerException);
			}
		}

		internal unsafe static string GetTextFromUtf8(ReadOnlySpan<byte> utf8Text)
		{
			if (utf8Text.IsEmpty)
			{
				return string.Empty;
			}
			fixed (byte* bytes = utf8Text)
			{
				return s_utf8Encoding.GetString(bytes, utf8Text.Length);
			}
		}

		internal static void Unescape(ReadOnlySpan<byte> source, Span<byte> destination, out int written)
		{
			int idx = source.IndexOf<byte>(92);
			bool flag = TryUnescape(source, destination, idx, out written);
		}

		internal static void Unescape(ReadOnlySpan<byte> source, Span<byte> destination, int idx, out int written)
		{
			bool flag = TryUnescape(source, destination, idx, out written);
		}

		internal static bool TryUnescape(ReadOnlySpan<byte> source, Span<byte> destination, out int written)
		{
			int idx = source.IndexOf<byte>(92);
			return TryUnescape(source, destination, idx, out written);
		}

		private static bool TryUnescape(ReadOnlySpan<byte> source, Span<byte> destination, int idx, out int written)
		{
			if (!source.Slice(0, idx).TryCopyTo(destination))
			{
				written = 0;
			}
			else
			{
				written = idx;
				while (written != destination.Length)
				{
					byte b = source[++idx];
					if ((uint)b <= 98u)
					{
						if ((uint)b <= 47u)
						{
							if (b != 34)
							{
								if (b != 47)
								{
									goto IL_0179;
								}
								destination[written++] = 47;
							}
							else
							{
								destination[written++] = 34;
							}
						}
						else if (b != 92)
						{
							if (b != 98)
							{
								goto IL_0179;
							}
							destination[written++] = 8;
						}
						else
						{
							destination[written++] = 92;
						}
					}
					else if ((uint)b <= 110u)
					{
						if (b != 102)
						{
							if (b != 110)
							{
								goto IL_0179;
							}
							destination[written++] = 10;
						}
						else
						{
							destination[written++] = 12;
						}
					}
					else if (b != 114)
					{
						if (b != 116)
						{
							goto IL_0179;
						}
						destination[written++] = 9;
					}
					else
					{
						destination[written++] = 13;
					}
					goto IL_025b;
					IL_025b:
					if (++idx != source.Length)
					{
						if (source[idx] == 92)
						{
							continue;
						}
						ReadOnlySpan<byte> span = source.Slice(idx);
						int num = span.IndexOf<byte>(92);
						if (num < 0)
						{
							num = span.Length;
						}
						if ((uint)(written + num) >= (uint)destination.Length)
						{
							break;
						}
						switch (num)
						{
						case 1:
							destination[written++] = source[idx++];
							break;
						case 2:
							destination[written++] = source[idx++];
							destination[written++] = source[idx++];
							break;
						case 3:
							destination[written++] = source[idx++];
							destination[written++] = source[idx++];
							destination[written++] = source[idx++];
							break;
						default:
							span.Slice(0, num).CopyTo(destination.Slice(written));
							written += num;
							idx += num;
							break;
						}
						if (idx != source.Length)
						{
							continue;
						}
					}
					return true;
					IL_0179:
					bool flag = Utf8Parser.TryParse(source.Slice(idx + 1, 4), out int value, out int bytesConsumed, 'x');
					idx += 4;
					if (JsonHelpers.IsInRangeInclusive((uint)value, 55296u, 57343u))
					{
						if (value >= 56320)
						{
							ThrowHelper.ThrowInvalidOperationException_ReadInvalidUTF16(value);
						}
						if (source.Length < idx + 7 || source[idx + 1] != 92 || source[idx + 2] != 117)
						{
							ThrowHelper.ThrowInvalidOperationException_ReadIncompleteUTF16();
						}
						flag = Utf8Parser.TryParse(source.Slice(idx + 3, 4), out int value2, out bytesConsumed, 'x');
						idx += 6;
						if (!JsonHelpers.IsInRangeInclusive((uint)value2, 56320u, 57343u))
						{
							ThrowHelper.ThrowInvalidOperationException_ReadInvalidUTF16(value2);
						}
						value = 1024 * (value - 55296) + (value2 - 56320) + 65536;
					}
					if (!TryEncodeToUtf8Bytes((uint)value, destination.Slice(written), out var bytesWritten))
					{
						break;
					}
					written += bytesWritten;
					goto IL_025b;
				}
			}
			return false;
		}

		private static bool TryEncodeToUtf8Bytes(uint scalar, Span<byte> utf8Destination, out int bytesWritten)
		{
			if (scalar < 128)
			{
				if ((uint)utf8Destination.Length < 1u)
				{
					bytesWritten = 0;
					return false;
				}
				utf8Destination[0] = (byte)scalar;
				bytesWritten = 1;
			}
			else if (scalar < 2048)
			{
				if ((uint)utf8Destination.Length < 2u)
				{
					bytesWritten = 0;
					return false;
				}
				utf8Destination[0] = (byte)(0xC0 | (scalar >> 6));
				utf8Destination[1] = (byte)(0x80 | (scalar & 0x3F));
				bytesWritten = 2;
			}
			else if (scalar < 65536)
			{
				if ((uint)utf8Destination.Length < 3u)
				{
					bytesWritten = 0;
					return false;
				}
				utf8Destination[0] = (byte)(0xE0 | (scalar >> 12));
				utf8Destination[1] = (byte)(0x80 | ((scalar >> 6) & 0x3F));
				utf8Destination[2] = (byte)(0x80 | (scalar & 0x3F));
				bytesWritten = 3;
			}
			else
			{
				if ((uint)utf8Destination.Length < 4u)
				{
					bytesWritten = 0;
					return false;
				}
				utf8Destination[0] = (byte)(0xF0 | (scalar >> 18));
				utf8Destination[1] = (byte)(0x80 | ((scalar >> 12) & 0x3F));
				utf8Destination[2] = (byte)(0x80 | ((scalar >> 6) & 0x3F));
				utf8Destination[3] = (byte)(0x80 | (scalar & 0x3F));
				bytesWritten = 4;
			}
			return true;
		}

		public unsafe static int IndexOfQuoteOrAnyControlOrBackSlash(this ReadOnlySpan<byte> span)
		{
			ref byte reference = ref MemoryMarshal.GetReference(span);
			int length = span.Length;
			IntPtr intPtr = (IntPtr)0;
			IntPtr intPtr2 = (IntPtr)length;
			if (Vector.IsHardwareAccelerated && length >= Vector<byte>.Count * 2)
			{
				int num = (int)Unsafe.AsPointer(ref reference) & (Vector<byte>.Count - 1);
				intPtr2 = (IntPtr)((Vector<byte>.Count - num) & (Vector<byte>.Count - 1));
			}
			while (true)
			{
				if ((nuint)(void*)intPtr2 >= (nuint)8u)
				{
					intPtr2 -= 8;
					uint num2 = Unsafe.AddByteOffset(ref reference, intPtr);
					if (34 == num2 || 92 == num2 || 32 > num2)
					{
						goto IL_03b2;
					}
					num2 = Unsafe.AddByteOffset(ref reference, intPtr + 1);
					if (34 == num2 || 92 == num2 || 32 > num2)
					{
						goto IL_03ba;
					}
					num2 = Unsafe.AddByteOffset(ref reference, intPtr + 2);
					if (34 == num2 || 92 == num2 || 32 > num2)
					{
						goto IL_03c8;
					}
					num2 = Unsafe.AddByteOffset(ref reference, intPtr + 3);
					if (34 != num2 && 92 != num2 && 32 <= num2)
					{
						num2 = Unsafe.AddByteOffset(ref reference, intPtr + 4);
						if (34 != num2 && 92 != num2 && 32 <= num2)
						{
							num2 = Unsafe.AddByteOffset(ref reference, intPtr + 5);
							if (34 != num2 && 92 != num2 && 32 <= num2)
							{
								num2 = Unsafe.AddByteOffset(ref reference, intPtr + 6);
								if (34 != num2 && 92 != num2 && 32 <= num2)
								{
									num2 = Unsafe.AddByteOffset(ref reference, intPtr + 7);
									if (34 == num2 || 92 == num2 || 32 > num2)
									{
										break;
									}
									intPtr += 8;
									continue;
								}
								return (int)(void*)(intPtr + 6);
							}
							return (int)(void*)(intPtr + 5);
						}
						return (int)(void*)(intPtr + 4);
					}
					goto IL_03d6;
				}
				if ((nuint)(void*)intPtr2 >= (nuint)4u)
				{
					intPtr2 -= 4;
					uint num2 = Unsafe.AddByteOffset(ref reference, intPtr);
					if (34 == num2 || 92 == num2 || 32 > num2)
					{
						goto IL_03b2;
					}
					num2 = Unsafe.AddByteOffset(ref reference, intPtr + 1);
					if (34 == num2 || 92 == num2 || 32 > num2)
					{
						goto IL_03ba;
					}
					num2 = Unsafe.AddByteOffset(ref reference, intPtr + 2);
					if (34 == num2 || 92 == num2 || 32 > num2)
					{
						goto IL_03c8;
					}
					num2 = Unsafe.AddByteOffset(ref reference, intPtr + 3);
					if (34 == num2 || 92 == num2 || 32 > num2)
					{
						goto IL_03d6;
					}
					intPtr += 4;
				}
				while ((void*)intPtr2 != null)
				{
					intPtr2 -= 1;
					uint num2 = Unsafe.AddByteOffset(ref reference, intPtr);
					if (34 != num2 && 92 != num2 && 32 <= num2)
					{
						intPtr += 1;
						continue;
					}
					goto IL_03b2;
				}
				if (Vector.IsHardwareAccelerated && (int)(void*)intPtr < length)
				{
					intPtr2 = (IntPtr)((length - (int)(void*)intPtr) & ~(Vector<byte>.Count - 1));
					Vector<byte> right = new Vector<byte>(34);
					Vector<byte> right2 = new Vector<byte>(92);
					Vector<byte> right3 = new Vector<byte>(32);
					for (; (void*)intPtr2 > (void*)intPtr; intPtr += Vector<byte>.Count)
					{
						Vector<byte> left = Unsafe.ReadUnaligned<Vector<byte>>(ref Unsafe.AddByteOffset(ref reference, intPtr));
						Vector<byte> vector = Vector.BitwiseOr(Vector.BitwiseOr(Vector.Equals(left, right), Vector.Equals(left, right2)), Vector.LessThan(left, right3));
						if (!Vector<byte>.Zero.Equals(vector))
						{
							return (int)(void*)intPtr + LocateFirstFoundByte(vector);
						}
					}
					if ((int)(void*)intPtr < length)
					{
						intPtr2 = (IntPtr)(length - (int)(void*)intPtr);
						continue;
					}
				}
				return -1;
				IL_03b2:
				return (int)(void*)intPtr;
				IL_03ba:
				return (int)(void*)(intPtr + 1);
				IL_03d6:
				return (int)(void*)(intPtr + 3);
				IL_03c8:
				return (int)(void*)(intPtr + 2);
			}
			return (int)(void*)(intPtr + 7);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static int LocateFirstFoundByte(Vector<byte> match)
		{
			Vector<ulong> vector = Vector.AsVectorUInt64(match);
			ulong num = 0uL;
			int i;
			for (i = 0; i < Vector<ulong>.Count; i++)
			{
				num = vector[i];
				if (num != 0L)
				{
					break;
				}
			}
			return i * 8 + LocateFirstFoundByte(num);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static int LocateFirstFoundByte(ulong match)
		{
			ulong num = match ^ (match - 1);
			return (int)(num * 283686952306184L >> 57);
		}
	}
	public struct JsonReaderOptions
	{
		internal const int DefaultMaxDepth = 64;

		private int _maxDepth;

		private JsonCommentHandling _commentHandling;

		public JsonCommentHandling CommentHandling
		{
			readonly get
			{
				return _commentHandling;
			}
			set
			{
				if ((int)value > 2)
				{
					ThrowHelper.ThrowArgumentOutOfRangeException_CommentEnumMustBeInRange("value");
				}
				_commentHandling = value;
			}
		}

		public int MaxDepth
		{
			readonly get
			{
				return _maxDepth;
			}
			set
			{
				if (value < 0)
				{
					ThrowHelper.ThrowArgumentOutOfRangeException_MaxDepthMustBePositive("value");
				}
				_maxDepth = value;
			}
		}

		public bool AllowTrailingCommas { get; set; }
	}
	public struct JsonReaderState
	{
		internal long _lineNumber;

		internal long _bytePositionInLine;

		internal bool _inObject;

		internal bool _isNotPrimitive;

		internal bool _valueIsEscaped;

		internal bool _trailingCommaBeforeComment;

		internal JsonTokenType _tokenType;

		internal JsonTokenType _previousTokenType;

		internal JsonReaderOptions _readerOptions;

		internal BitStack _bitStack;

		public JsonReaderOptions Options => _readerOptions;

		public JsonReaderState(JsonReaderOptions options = default(JsonReaderOptions))
		{
			_lineNumber = 0L;
			_bytePositionInLine = 0L;
			_inObject = false;
			_isNotPrimitive = false;
			_valueIsEscaped = false;
			_trailingCommaBeforeComment = false;
			_tokenType = JsonTokenType.None;
			_previousTokenType = JsonTokenType.None;
			_readerOptions = options;
			_bitStack = default(BitStack);
		}
	}
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public ref struct Utf8JsonReader
	{
		private readonly struct PartialStateForRollback
		{
			public readonly long _prevTotalConsumed;

			public readonly long _prevBytePositionInLine;

			public readonly int _prevConsumed;

			public readonly SequencePosition _prevCurrentPosition;

			public PartialStateForRollback(long totalConsumed, long bytePositionInLine, int consumed, SequencePosition currentPosition)
			{
				_prevTotalConsumed = totalConsumed;
				_prevBytePositionInLine = bytePositionInLine;
				_prevConsumed = consumed;
				_prevCurrentPosition = currentPosition;
			}

			public SequencePosition GetStartPosition(int offset = 0)
			{
				return new SequencePosition(_prevCurrentPosition.GetObject(), _prevCurrentPosition.GetInteger() + _prevConsumed + offset);
			}
		}

		private ReadOnlySpan<byte> _buffer;

		private readonly bool _isFinalBlock;

		private readonly bool _isInputSequence;

		private long _lineNumber;

		private long _bytePositionInLine;

		private int _consumed;

		private bool _inObject;

		private bool _isNotPrimitive;

		private JsonTokenType _tokenType;

		private JsonTokenType _previousTokenType;

		private JsonReaderOptions _readerOptions;

		private BitStack _bitStack;

		private long _totalConsumed;

		private bool _isLastSegment;

		private readonly bool _isMultiSegment;

		private bool _trailingCommaBeforeComment;

		private SequencePosition _nextPosition;

		private SequencePosition _currentPosition;

		private readonly ReadOnlySequence<byte> _sequence;

		private bool IsLastSpan
		{
			get
			{
				if (_isFinalBlock)
				{
					if (_isMultiSegment)
					{
						return _isLastSegment;
					}
					return true;
				}
				return false;
			}
		}

		internal ReadOnlySequence<byte> OriginalSequence => _sequence;

		internal ReadOnlySpan<byte> OriginalSpan
		{
			get
			{
				if (!_sequence.IsEmpty)
				{
					return default(ReadOnlySpan<byte>);
				}
				return _buffer;
			}
		}

		internal readonly int ValueLength
		{
			get
			{
				if (!HasValueSequence)
				{
					return ValueSpan.Length;
				}
				return checked((int)ValueSequence.Length);
			}
		}

		public ReadOnlySpan<byte> ValueSpan { get; private set; }

		public readonly long BytesConsumed => _totalConsumed + _consumed;

		public long TokenStartIndex { get; private set; }

		public readonly int CurrentDepth
		{
			get
			{
				int num = _bitStack.CurrentDepth;
				if (TokenType == JsonTokenType.StartArray || TokenType == JsonTokenType.StartObject)
				{
					num--;
				}
				return num;
			}
		}

		internal bool IsInArray => !_inObject;

		public readonly JsonTokenType TokenType => _tokenType;

		public bool HasValueSequence { get; private set; }

		public bool ValueIsEscaped { get; private set; }

		public readonly bool IsFinalBlock => _isFinalBlock;

		public ReadOnlySequence<byte> ValueSequence { get; private set; }

		public readonly SequencePosition Position
		{
			get
			{
				if (_isInputSequence)
				{
					return _sequence.GetPosition(_consumed, _currentPosition);
				}
				return default(SequencePosition);
			}
		}

		public readonly JsonReaderState CurrentState => new JsonReaderState
		{
			_lineNumber = _lineNumber,
			_bytePositionInLine = _bytePositionInLine,
			_inObject = _inObject,
			_isNotPrimitive = _isNotPrimitive,
			_valueIsEscaped = ValueIsEscaped,
			_trailingCommaBeforeComment = _trailingCommaBeforeComment,
			_tokenType = _tokenType,
			_previousTokenType = _previousTokenType,
			_readerOptions = _readerOptions,
			_bitStack = _bitStack
		};

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private string DebuggerDisplay => $"TokenType = {DebugTokenType}, TokenStartIndex = {TokenStartIndex}, Consumed = {BytesConsumed}";

		private string DebugTokenType => TokenType switch
		{
			JsonTokenType.Comment => "Comment", 
			JsonTokenType.EndArray => "EndArray", 
			JsonTokenType.EndObject => "EndObject", 
			JsonTokenType.False => "False", 
			JsonTokenType.None => "None", 
			JsonTokenType.Null => "Null", 
			JsonTokenType.Number => "Number", 
			JsonTokenType.PropertyName => "PropertyName", 
			JsonTokenType.StartArray => "StartArray", 
			JsonTokenType.StartObject => "StartObject", 
			JsonTokenType.String => "String", 
			JsonTokenType.True => "True", 
			_ => ((byte)TokenType).ToString(), 
		};

		public Utf8JsonReader(ReadOnlySpan<byte> jsonData, bool isFinalBlock, JsonReaderState state)
		{
			_buffer = jsonData;
			_isFinalBlock = isFinalBlock;
			_isInputSequence = false;
			_lineNumber = state._lineNumber;
			_bytePositionInLine = state._bytePositionInLine;
			_inObject = state._inObject;
			_isNotPrimitive = state._isNotPrimitive;
			ValueIsEscaped = state._valueIsEscaped;
			_trailingCommaBeforeComment = state._trailingCommaBeforeComment;
			_tokenType = state._tokenType;
			_previousTokenType = state._previousTokenType;
			_readerOptions = state._readerOptions;
			if (_readerOptions.MaxDepth == 0)
			{
				_readerOptions.MaxDepth = 64;
			}
			_bitStack = state._bitStack;
			_consumed = 0;
			TokenStartIndex = 0L;
			_totalConsumed = 0L;
			_isLastSegment = _isFinalBlock;
			_isMultiSegment = false;
			ValueSpan = ReadOnlySpan<byte>.Empty;
			_currentPosition = default(SequencePosition);
			_nextPosition = default(SequencePosition);
			_sequence = default(ReadOnlySequence<byte>);
			HasValueSequence = false;
			ValueSequence = ReadOnlySequence<byte>.Empty;
		}

		public Utf8JsonReader(ReadOnlySpan<byte> jsonData, JsonReaderOptions options = default(JsonReaderOptions))
			: this(jsonData, isFinalBlock: true, new JsonReaderState(options))
		{
		}

		public bool Read()
		{
			bool flag = (_isMultiSegment ? ReadMultiSegment() : ReadSingleSegment());
			if (!flag && _isFinalBlock && TokenType == JsonTokenType.None)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedJsonTokens, 0);
			}
			return flag;
		}

		public void Skip()
		{
			if (!_isFinalBlock)
			{
				ThrowHelper.ThrowInvalidOperationException_CannotSkipOnPartial();
			}
			SkipHelper();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void SkipHelper()
		{
			if (TokenType == JsonTokenType.PropertyName)
			{
				bool flag = Read();
			}
			if (TokenType == JsonTokenType.StartObject || TokenType == JsonTokenType.StartArray)
			{
				int currentDepth = CurrentDepth;
				do
				{
					bool flag2 = Read();
				}
				while (currentDepth < CurrentDepth);
			}
		}

		public bool TrySkip()
		{
			if (_isFinalBlock)
			{
				SkipHelper();
				return true;
			}
			return TrySkipHelper();
		}

		private bool TrySkipHelper()
		{
			Utf8JsonReader utf8JsonReader = this;
			if (TokenType != JsonTokenType.PropertyName || Read())
			{
				if (TokenType != JsonTokenType.StartObject && TokenType != JsonTokenType.StartArray)
				{
					goto IL_0042;
				}
				int currentDepth = CurrentDepth;
				while (Read())
				{
					if (currentDepth < CurrentDepth)
					{
						continue;
					}
					goto IL_0042;
				}
			}
			this = utf8JsonReader;
			return false;
			IL_0042:
			return true;
		}

		public readonly bool ValueTextEquals(ReadOnlySpan<byte> utf8Text)
		{
			if (!IsTokenTypeString(TokenType))
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedStringComparison(TokenType);
			}
			return TextEqualsHelper(utf8Text);
		}

		public readonly bool ValueTextEquals(string? text)
		{
			return ValueTextEquals(MemoryExtensions.AsSpan(text));
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private readonly bool TextEqualsHelper(ReadOnlySpan<byte> otherUtf8Text)
		{
			if (HasValueSequence)
			{
				return CompareToSequence(otherUtf8Text);
			}
			if (ValueIsEscaped)
			{
				return UnescapeAndCompare(otherUtf8Text);
			}
			return otherUtf8Text.SequenceEqual(ValueSpan);
		}

		public readonly bool ValueTextEquals(ReadOnlySpan<char> text)
		{
			if (!IsTokenTypeString(TokenType))
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedStringComparison(TokenType);
			}
			if (MatchNotPossible(text.Length))
			{
				return false;
			}
			byte[] array = null;
			int num = checked(text.Length * 3);
			Span<byte> destination;
			if (num > 256)
			{
				array = ArrayPool<byte>.Shared.Rent(num);
				destination = array;
			}
			else
			{
				destination = stackalloc byte[256];
			}
			int written;
			OperationStatus operationStatus = JsonWriterHelper.ToUtf8(text, destination, out written);
			bool result = operationStatus != OperationStatus.InvalidData && TextEqualsHelper(destination.Slice(0, written));
			if (array != null)
			{
				destination.Slice(0, written).Clear();
				ArrayPool<byte>.Shared.Return(array);
			}
			return result;
		}

		private readonly bool CompareToSequence(ReadOnlySpan<byte> other)
		{
			if (ValueIsEscaped)
			{
				return UnescapeSequenceAndCompare(other);
			}
			ReadOnlySequence<byte> valueSequence = ValueSequence;
			if (valueSequence.Length != other.Length)
			{
				return false;
			}
			int num = 0;
			ReadOnlySequence<byte>.Enumerator enumerator = valueSequence.GetEnumerator();
			while (enumerator.MoveNext())
			{
				ReadOnlySpan<byte> span = enumerator.Current.Span;
				if (other.Slice(num).StartsWith(span))
				{
					num += span.Length;
					continue;
				}
				return false;
			}
			return true;
		}

		private readonly bool UnescapeAndCompare(ReadOnlySpan<byte> other)
		{
			ReadOnlySpan<byte> valueSpan = ValueSpan;
			if (valueSpan.Length < other.Length || valueSpan.Length / 6 > other.Length)
			{
				return false;
			}
			int num = valueSpan.IndexOf<byte>(92);
			if (!other.StartsWith(valueSpan.Slice(0, num)))
			{
				return false;
			}
			return JsonReaderHelper.UnescapeAndCompare(valueSpan.Slice(num), other.Slice(num));
		}

		private readonly bool UnescapeSequenceAndCompare(ReadOnlySpan<byte> other)
		{
			ReadOnlySequence<byte> valueSequence = ValueSequence;
			long length = valueSequence.Length;
			if (length < other.Length || length / 6 > other.Length)
			{
				return false;
			}
			int num = 0;
			bool result = false;
			ReadOnlySequence<byte>.Enumerator enumerator = valueSequence.GetEnumerator();
			while (enumerator.MoveNext())
			{
				ReadOnlySpan<byte> span = enumerator.Current.Span;
				int num2 = span.IndexOf<byte>(92);
				if (num2 != -1)
				{
					if (other.Slice(num).StartsWith(span.Slice(0, num2)))
					{
						num += num2;
						other = other.Slice(num);
						valueSequence = valueSequence.Slice(num);
						result = ((!valueSequence.IsSingleSegment) ? JsonReaderHelper.UnescapeAndCompare(valueSequence, other) : JsonReaderHelper.UnescapeAndCompare(valueSequence.First.Span, other));
					}
					break;
				}
				if (!other.Slice(num).StartsWith(span))
				{
					break;
				}
				num += span.Length;
			}
			return result;
		}

		private static bool IsTokenTypeString(JsonTokenType tokenType)
		{
			if (tokenType != JsonTokenType.PropertyName)
			{
				return tokenType == JsonTokenType.String;
			}
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private readonly bool MatchNotPossible(int charTextLength)
		{
			if (HasValueSequence)
			{
				return MatchNotPossibleSequence(charTextLength);
			}
			int length = ValueSpan.Length;
			if (length < charTextLength || length / (ValueIsEscaped ? 6 : 3) > charTextLength)
			{
				return true;
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private readonly bool MatchNotPossibleSequence(int charTextLength)
		{
			long length = ValueSequence.Length;
			if (length < charTextLength || length / (ValueIsEscaped ? 6 : 3) > charTextLength)
			{
				return true;
			}
			return false;
		}

		private void StartObject()
		{
			if (_bitStack.CurrentDepth >= _readerOptions.MaxDepth)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ObjectDepthTooLarge, 0);
			}
			_bitStack.PushTrue();
			ValueSpan = _buffer.Slice(_consumed, 1);
			_consumed++;
			_bytePositionInLine++;
			_tokenType = JsonTokenType.StartObject;
			_inObject = true;
		}

		private void EndObject()
		{
			if (!_inObject || _bitStack.CurrentDepth <= 0)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.MismatchedObjectArray, 125);
			}
			if (_trailingCommaBeforeComment)
			{
				if (!_readerOptions.AllowTrailingCommas)
				{
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd, 0);
				}
				_trailingCommaBeforeComment = false;
			}
			_tokenType = JsonTokenType.EndObject;
			ValueSpan = _buffer.Slice(_consumed, 1);
			UpdateBitStackOnEndToken();
		}

		private void StartArray()
		{
			if (_bitStack.CurrentDepth >= _readerOptions.MaxDepth)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ArrayDepthTooLarge, 0);
			}
			_bitStack.PushFalse();
			ValueSpan = _buffer.Slice(_consumed, 1);
			_consumed++;
			_bytePositionInLine++;
			_tokenType = JsonTokenType.StartArray;
			_inObject = false;
		}

		private void EndArray()
		{
			if (_inObject || _bitStack.CurrentDepth <= 0)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.MismatchedObjectArray, 93);
			}
			if (_trailingCommaBeforeComment)
			{
				if (!_readerOptions.AllowTrailingCommas)
				{
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd, 0);
				}
				_trailingCommaBeforeComment = false;
			}
			_tokenType = JsonTokenType.EndArray;
			ValueSpan = _buffer.Slice(_consumed, 1);
			UpdateBitStackOnEndToken();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void UpdateBitStackOnEndToken()
		{
			_consumed++;
			_bytePositionInLine++;
			_inObject = _bitStack.Pop();
		}

		private bool ReadSingleSegment()
		{
			bool flag = false;
			ValueSpan = default(ReadOnlySpan<byte>);
			ValueIsEscaped = false;
			if (HasMoreData())
			{
				byte b = _buffer[_consumed];
				if (b <= 32)
				{
					SkipWhiteSpace();
					if (!HasMoreData())
					{
						goto IL_0139;
					}
					b = _buffer[_consumed];
				}
				TokenStartIndex = _consumed;
				if (_tokenType != JsonTokenType.None)
				{
					if (b == 47)
					{
						flag = ConsumeNextTokenOrRollback(b);
					}
					else if (_tokenType == JsonTokenType.StartObject)
					{
						if (b == 125)
						{
							EndObject();
							goto IL_0137;
						}
						if (b != 34)
						{
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
						}
						int consumed = _consumed;
						long bytePositionInLine = _bytePositionInLine;
						long lineNumber = _lineNumber;
						flag = ConsumePropertyName();
						if (!flag)
						{
							_consumed = consumed;
							_tokenType = JsonTokenType.StartObject;
							_bytePositionInLine = bytePositionInLine;
							_lineNumber = lineNumber;
						}
					}
					else if (_tokenType != JsonTokenType.StartArray)
					{
						flag = ((_tokenType != JsonTokenType.PropertyName) ? ConsumeNextTokenOrRollback(b) : ConsumeValue(b));
					}
					else
					{
						if (b == 93)
						{
							EndArray();
							goto IL_0137;
						}
						flag = ConsumeValue(b);
					}
				}
				else
				{
					flag = ReadFirstToken(b);
				}
			}
			goto IL_0139;
			IL_0139:
			return flag;
			IL_0137:
			flag = true;
			goto IL_0139;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private bool HasMoreData()
		{
			if (_consumed >= (uint)_buffer.Length)
			{
				if (_isNotPrimitive && IsLastSpan)
				{
					if (_bitStack.CurrentDepth != 0)
					{
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ZeroDepthAtEnd, 0);
					}
					if (_readerOptions.CommentHandling == JsonCommentHandling.Allow && _tokenType == JsonTokenType.Comment)
					{
						return false;
					}
					if (_tokenType != JsonTokenType.EndArray && _tokenType != JsonTokenType.EndObject)
					{
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidEndOfJsonNonPrimitive, 0);
					}
				}
				return false;
			}
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private bool HasMoreData(ExceptionResource resource)
		{
			if (_consumed >= (uint)_buffer.Length)
			{
				if (IsLastSpan)
				{
					ThrowHelper.ThrowJsonReaderException(ref this, resource, 0);
				}
				return false;
			}
			return true;
		}

		private bool ReadFirstToken(byte first)
		{
			switch (first)
			{
			case 123:
				_bitStack.SetFirstBit();
				_tokenType = JsonTokenType.StartObject;
				ValueSpan = _buffer.Slice(_consumed, 1);
				_consumed++;
				_bytePositionInLine++;
				_inObject = true;
				_isNotPrimitive = true;
				break;
			case 91:
				_bitStack.ResetFirstBit();
				_tokenType = JsonTokenType.StartArray;
				ValueSpan = _buffer.Slice(_consumed, 1);
				_consumed++;
				_bytePositionInLine++;
				_isNotPrimitive = true;
				break;
			default:
			{
				ReadOnlySpan<byte> buffer = _buffer;
				if (JsonHelpers.IsDigit(first) || first == 45)
				{
					if (!TryGetNumber(buffer.Slice(_consumed), out var consumed))
					{
						return false;
					}
					_tokenType = JsonTokenType.Number;
					_consumed += consumed;
					_bytePositionInLine += consumed;
					return true;
				}
				if (!ConsumeValue(first))
				{
					return false;
				}
				if (_tokenType == JsonTokenType.StartObject || _tokenType == JsonTokenType.StartArray)
				{
					_isNotPrimitive = true;
				}
				break;
			}
			}
			return true;
		}

		private void SkipWhiteSpace()
		{
			ReadOnlySpan<byte> buffer = _buffer;
			while (_consumed < buffer.Length)
			{
				byte b = buffer[_consumed];
				if (b == 32 || b == 13 || b == 10 || b == 9)
				{
					if (b == 10)
					{
						_lineNumber++;
						_bytePositionInLine = 0L;
					}
					else
					{
						_bytePositionInLine++;
					}
					_consumed++;
					continue;
				}
				break;
			}
		}

		private bool ConsumeValue(byte marker)
		{
			while (true)
			{
				_trailingCommaBeforeComment = false;
				switch (marker)
				{
				case 34:
					return ConsumeString();
				case 123:
					StartObject();
					break;
				case 91:
					StartArray();
					break;
				default:
					if (JsonHelpers.IsDigit(marker) || marker == 45)
					{
						return ConsumeNumber();
					}
					switch (marker)
					{
					case 102:
						return ConsumeLiteral(JsonConstants.FalseValue, JsonTokenType.False);
					case 116:
						return ConsumeLiteral(JsonConstants.TrueValue, JsonTokenType.True);
					case 110:
						return ConsumeLiteral(JsonConstants.NullValue, JsonTokenType.Null);
					}
					switch (_readerOptions.CommentHandling)
					{
					case JsonCommentHandling.Allow:
						if (marker == 47)
						{
							return ConsumeComment();
						}
						break;
					default:
						if (marker != 47)
						{
							break;
						}
						if (SkipComment())
						{
							if (_consumed >= (uint)_buffer.Length)
							{
								if (_isNotPrimitive && IsLastSpan && _tokenType != JsonTokenType.EndArray && _tokenType != JsonTokenType.EndObject)
								{
									ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidEndOfJsonNonPrimitive, 0);
								}
								return false;
							}
							marker = _buffer[_consumed];
							if (marker <= 32)
							{
								SkipWhiteSpace();
								if (!HasMoreData())
								{
									return false;
								}
								marker = _buffer[_consumed];
							}
							goto IL_0140;
						}
						return false;
					case JsonCommentHandling.Disallow:
						break;
					}
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfValueNotFound, marker);
					break;
				}
				break;
				IL_0140:
				TokenStartIndex = _consumed;
			}
			return true;
		}

		private bool ConsumeLiteral(ReadOnlySpan<byte> literal, JsonTokenType tokenType)
		{
			ReadOnlySpan<byte> span = _buffer.Slice(_consumed);
			if (!span.StartsWith(literal))
			{
				return CheckLiteral(span, literal);
			}
			ValueSpan = span.Slice(0, literal.Length);
			_tokenType = tokenType;
			_consumed += literal.Length;
			_bytePositionInLine += literal.Length;
			return true;
		}

		private bool CheckLiteral(ReadOnlySpan<byte> span, ReadOnlySpan<byte> literal)
		{
			int num = 0;
			for (int i = 1; i < literal.Length; i++)
			{
				if (span.Length > i)
				{
					if (span[i] != literal[i])
					{
						_bytePositionInLine += i;
						ThrowInvalidLiteral(span);
					}
					continue;
				}
				num = i;
				break;
			}
			if (IsLastSpan)
			{
				_bytePositionInLine += num;
				ThrowInvalidLiteral(span);
			}
			return false;
		}

		private void ThrowInvalidLiteral(ReadOnlySpan<byte> span)
		{
			ThrowHelper.ThrowJsonReaderException(ref this, span[0] switch
			{
				116 => ExceptionResource.ExpectedTrue, 
				102 => ExceptionResource.ExpectedFalse, 
				_ => ExceptionResource.ExpectedNull, 
			}, 0, span);
		}

		private bool ConsumeNumber()
		{
			if (!TryGetNumber(_buffer.Slice(_consumed), out var consumed))
			{
				return false;
			}
			_tokenType = JsonTokenType.Number;
			_consumed += consumed;
			_bytePositionInLine += consumed;
			if (_consumed >= (uint)_buffer.Length && _isNotPrimitive)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndOfDigitNotFound, _buffer[_consumed - 1]);
			}
			return true;
		}

		private bool ConsumePropertyName()
		{
			_trailingCommaBeforeComment = false;
			if (!ConsumeString())
			{
				return false;
			}
			if (!HasMoreData(ExceptionResource.ExpectedValueAfterPropertyNameNotFound))
			{
				return false;
			}
			byte b = _buffer[_consumed];
			if (b <= 32)
			{
				SkipWhiteSpace();
				if (!HasMoreData(ExceptionResource.ExpectedValueAfterPropertyNameNotFound))
				{
					return false;
				}
				b = _buffer[_consumed];
			}
			if (b != 58)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedSeparatorAfterPropertyNameNotFound, b);
			}
			_consumed++;
			_bytePositionInLine++;
			_tokenType = JsonTokenType.PropertyName;
			return true;
		}

		private bool ConsumeString()
		{
			ReadOnlySpan<byte> readOnlySpan = _buffer.Slice(_consumed + 1);
			int num = readOnlySpan.IndexOfQuoteOrAnyControlOrBackSlash();
			if (num >= 0)
			{
				byte b = readOnlySpan[num];
				if (b == 34)
				{
					_bytePositionInLine += num + 2;
					ValueSpan = readOnlySpan.Slice(0, num);
					ValueIsEscaped = false;
					_tokenType = JsonTokenType.String;
					_consumed += num + 2;
					return true;
				}
				return ConsumeStringAndValidate(readOnlySpan, num);
			}
			if (IsLastSpan)
			{
				_bytePositionInLine += readOnlySpan.Length + 1;
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
			}
			return false;
		}

		private bool ConsumeStringAndValidate(ReadOnlySpan<byte> data, int idx)
		{
			long bytePositionInLine = _bytePositionInLine;
			long lineNumber = _lineNumber;
			_bytePositionInLine += idx + 1;
			bool flag = false;
			while (true)
			{
				if (idx < data.Length)
				{
					byte b = data[idx];
					if (b == 34)
					{
						if (!flag)
						{
							break;
						}
						flag = false;
					}
					else if (b == 92)
					{
						flag = !flag;
					}
					else if (flag)
					{
						int num = JsonConstants.EscapableChars.IndexOf(b);
						if (num == -1)
						{
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterAfterEscapeWithinString, b);
						}
						if (b == 117)
						{
							_bytePositionInLine++;
							if (!ValidateHexDigits(data, idx + 1))
							{
								idx = data.Length;
								goto IL_00e5;
							}
							idx += 4;
						}
						flag = false;
					}
					else if (b < 32)
					{
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterWithinString, b);
					}
					_bytePositionInLine++;
					idx++;
					continue;
				}
				goto IL_00e5;
				IL_00e5:
				if (idx < data.Length)
				{
					break;
				}
				if (IsLastSpan)
				{
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
				}
				_lineNumber = lineNumber;
				_bytePositionInLine = bytePositionInLine;
				return false;
			}
			_bytePositionInLine++;
			ValueSpan = data.Slice(0, idx);
			ValueIsEscaped = true;
			_tokenType = JsonTokenType.String;
			_consumed += idx + 2;
			return true;
		}

		private bool ValidateHexDigits(ReadOnlySpan<byte> data, int idx)
		{
			for (int i = idx; i < data.Length; i++)
			{
				byte nextByte = data[i];
				if (!JsonReaderHelper.IsHexDigit(nextByte))
				{
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidHexCharacterWithinString, nextByte);
				}
				if (i - idx >= 3)
				{
					return true;
				}
				_bytePositionInLine++;
			}
			return false;
		}

		private bool TryGetNumber(ReadOnlySpan<byte> data, out int consumed)
		{
			consumed = 0;
			int i = 0;
			ConsumeNumberResult consumeNumberResult = ConsumeNegativeSign(ref data, ref i);
			if (consumeNumberResult == ConsumeNumberResult.NeedMoreData)
			{
				return false;
			}
			byte b = data[i];
			if (b == 48)
			{
				ConsumeNumberResult consumeNumberResult2 = ConsumeZero(ref data, ref i);
				if (consumeNumberResult2 == ConsumeNumberResult.NeedMoreData)
				{
					return false;
				}
				if (consumeNumberResult2 != ConsumeNumberResult.Success)
				{
					b = data[i];
					goto IL_00a3;
				}
			}
			else
			{
				i++;
				ConsumeNumberResult consumeNumberResult3 = ConsumeIntegerDigits(ref data, ref i);
				if (consumeNumberResult3 == ConsumeNumberResult.NeedMoreData)
				{
					return false;
				}
				if (consumeNumberResult3 != ConsumeNumberResult.Success)
				{
					b = data[i];
					if (b != 46 && b != 69 && b != 101)
					{
						_bytePositionInLine += i;
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndOfDigitNotFound, b);
					}
					goto IL_00a3;
				}
			}
			goto IL_0152;
			IL_00a3:
			if (b == 46)
			{
				i++;
				ConsumeNumberResult consumeNumberResult4 = ConsumeDecimalDigits(ref data, ref i);
				if (consumeNumberResult4 == ConsumeNumberResult.NeedMoreData)
				{
					return false;
				}
				if (consumeNumberResult4 == ConsumeNumberResult.Success)
				{
					goto IL_0152;
				}
				b = data[i];
				if (b != 69 && b != 101)
				{
					_bytePositionInLine += i;
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedNextDigitEValueNotFound, b);
				}
			}
			i++;
			consumeNumberResult = ConsumeSign(ref data, ref i);
			if (consumeNumberResult == ConsumeNumberResult.NeedMoreData)
			{
				return false;
			}
			i++;
			switch (ConsumeIntegerDigits(ref data, ref i))
			{
			case ConsumeNumberResult.NeedMoreData:
				return false;
			default:
				_bytePositionInLine += i;
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndOfDigitNotFound, data[i]);
				break;
			case ConsumeNumberResult.Success:
				break;
			}
			goto IL_0152;
			IL_0152:
			ValueSpan = data.Slice(0, i);
			consumed = i;
			return true;
		}

		private ConsumeNumberResult ConsumeNegativeSign(ref ReadOnlySpan<byte> data, scoped ref int i)
		{
			byte b = data[i];
			if (b == 45)
			{
				i++;
				if (i >= data.Length)
				{
					if (IsLastSpan)
					{
						_bytePositionInLine += i;
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
					}
					return ConsumeNumberResult.NeedMoreData;
				}
				b = data[i];
				if (!JsonHelpers.IsDigit(b))
				{
					_bytePositionInLine += i;
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundAfterSign, b);
				}
			}
			return ConsumeNumberResult.OperationIncomplete;
		}

		private ConsumeNumberResult ConsumeZero(ref ReadOnlySpan<byte> data, scoped ref int i)
		{
			i++;
			if (i < data.Length)
			{
				byte value = data[i];
				if (JsonConstants.Delimiters.IndexOf(value) >= 0)
				{
					return ConsumeNumberResult.Success;
				}
				value = data[i];
				if (value != 46 && value != 69 && value != 101)
				{
					_bytePositionInLine += i;
					ThrowHelper.ThrowJsonReaderException(ref this, JsonHelpers.IsInRangeInclusive(value, 48, 57) ? ExceptionResource.InvalidLeadingZeroInNumber : ExceptionResource.ExpectedEndOfDigitNotFound, value);
				}
				return ConsumeNumberResult.OperationIncomplete;
			}
			if (IsLastSpan)
			{
				return ConsumeNumberResult.Success;
			}
			return ConsumeNumberResult.NeedMoreData;
		}

		private ConsumeNumberResult ConsumeIntegerDigits(ref ReadOnlySpan<byte> data, scoped ref int i)
		{
			byte value = 0;
			while (i < data.Length)
			{
				value = data[i];
				if (!JsonHelpers.IsDigit(value))
				{
					break;
				}
				i++;
			}
			if (i >= data.Length)
			{
				if (IsLastSpan)
				{
					return ConsumeNumberResult.Success;
				}
				return ConsumeNumberResult.NeedMoreData;
			}
			if (JsonConstants.Delimiters.IndexOf(value) >= 0)
			{
				return ConsumeNumberResult.Success;
			}
			return ConsumeNumberResult.OperationIncomplete;
		}

		private ConsumeNumberResult ConsumeDecimalDigits(ref ReadOnlySpan<byte> data, scoped ref int i)
		{
			if (i >= data.Length)
			{
				if (IsLastSpan)
				{
					_bytePositionInLine += i;
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
				}
				return ConsumeNumberResult.NeedMoreData;
			}
			byte b = data[i];
			if (!JsonHelpers.IsDigit(b))
			{
				_bytePositionInLine += i;
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundAfterDecimal, b);
			}
			i++;
			return ConsumeIntegerDigits(ref data, ref i);
		}

		private ConsumeNumberResult ConsumeSign(ref ReadOnlySpan<byte> data, scoped ref int i)
		{
			if (i >= data.Length)
			{
				if (IsLastSpan)
				{
					_bytePositionInLine += i;
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
				}
				return ConsumeNumberResult.NeedMoreData;
			}
			byte b = data[i];
			if (b == 43 || b == 45)
			{
				i++;
				if (i >= data.Length)
				{
					if (IsLastSpan)
					{
						_bytePositionInLine += i;
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
					}
					return ConsumeNumberResult.NeedMoreData;
				}
				b = data[i];
			}
			if (!JsonHelpers.IsDigit(b))
			{
				_bytePositionInLine += i;
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundAfterSign, b);
			}
			return ConsumeNumberResult.OperationIncomplete;
		}

		private bool ConsumeNextTokenOrRollback(byte marker)
		{
			int consumed = _consumed;
			long bytePositionInLine = _bytePositionInLine;
			long lineNumber = _lineNumber;
			JsonTokenType tokenType = _tokenType;
			bool trailingCommaBeforeComment = _trailingCommaBeforeComment;
			switch (ConsumeNextToken(marker))
			{
			case ConsumeTokenResult.Success:
				return true;
			case ConsumeTokenResult.NotEnoughDataRollBackState:
				_consumed = consumed;
				_tokenType = tokenType;
				_bytePositionInLine = bytePositionInLine;
				_lineNumber = lineNumber;
				_trailingCommaBeforeComment = trailingCommaBeforeComment;
				break;
			}
			return false;
		}

		private ConsumeTokenResult ConsumeNextToken(byte marker)
		{
			if (_readerOptions.CommentHandling != JsonCommentHandling.Disallow)
			{
				if (_readerOptions.CommentHandling != JsonCommentHandling.Allow)
				{
					return ConsumeNextTokenUntilAfterAllCommentsAreSkipped(marker);
				}
				if (marker == 47)
				{
					if (!ConsumeComment())
					{
						return ConsumeTokenResult.NotEnoughDataRollBackState;
					}
					return ConsumeTokenResult.Success;
				}
				if (_tokenType == JsonTokenType.Comment)
				{
					return ConsumeNextTokenFromLastNonCommentToken();
				}
			}
			if (_bitStack.CurrentDepth == 0)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndAfterSingleJson, marker);
			}
			switch (marker)
			{
			case 44:
			{
				_consumed++;
				_bytePositionInLine++;
				if (_consumed >= (uint)_buffer.Length)
				{
					if (IsLastSpan)
					{
						_consumed--;
						_bytePositionInLine--;
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
					}
					return ConsumeTokenResult.NotEnoughDataRollBackState;
				}
				byte b = _buffer[_consumed];
				if (b <= 32)
				{
					SkipWhiteSpace();
					if (!HasMoreData(ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
					{
						return ConsumeTokenResult.NotEnoughDataRollBackState;
					}
					b = _buffer[_consumed];
				}
				TokenStartIndex = _consumed;
				if (_readerOptions.CommentHandling == JsonCommentHandling.Allow && b == 47)
				{
					_trailingCommaBeforeComment = true;
					if (!ConsumeComment())
					{
						return ConsumeTokenResult.NotEnoughDataRollBackState;
					}
					return ConsumeTokenResult.Success;
				}
				if (_inObject)
				{
					if (b != 34)
					{
						if (b == 125)
						{
							if (_readerOptions.AllowTrailingCommas)
							{
								EndObject();
								return ConsumeTokenResult.Success;
							}
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd, 0);
						}
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
					}
					if (!ConsumePropertyName())
					{
						return ConsumeTokenResult.NotEnoughDataRollBackState;
					}
					return ConsumeTokenResult.Success;
				}
				if (b == 93)
				{
					if (_readerOptions.AllowTrailingCommas)
					{
						EndArray();
						return ConsumeTokenResult.Success;
					}
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd, 0);
				}
				if (!ConsumeValue(b))
				{
					return ConsumeTokenResult.NotEnoughDataRollBackState;
				}
				return ConsumeTokenResult.Success;
			}
			case 125:
				EndObject();
				break;
			case 93:
				EndArray();
				break;
			default:
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.FoundInvalidCharacter, marker);
				break;
			}
			return ConsumeTokenResult.Success;
		}

		private ConsumeTokenResult ConsumeNextTokenFromLastNonCommentToken()
		{
			if (JsonReaderHelper.IsTokenTypePrimitive(_previousTokenType))
			{
				_tokenType = (_inObject ? JsonTokenType.StartObject : JsonTokenType.StartArray);
			}
			else
			{
				_tokenType = _previousTokenType;
			}
			if (HasMoreData())
			{
				byte b = _buffer[_consumed];
				if (b <= 32)
				{
					SkipWhiteSpace();
					if (!HasMoreData())
					{
						goto IL_0343;
					}
					b = _buffer[_consumed];
				}
				if (_bitStack.CurrentDepth == 0 && _tokenType != JsonTokenType.None)
				{
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndAfterSingleJson, b);
				}
				TokenStartIndex = _consumed;
				if (b != 44)
				{
					if (b == 125)
					{
						EndObject();
					}
					else
					{
						if (b != 93)
						{
							if (_tokenType == JsonTokenType.None)
							{
								if (ReadFirstToken(b))
								{
									goto IL_0341;
								}
							}
							else if (_tokenType == JsonTokenType.StartObject)
							{
								if (b != 34)
								{
									ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
								}
								int consumed = _consumed;
								long bytePositionInLine = _bytePositionInLine;
								long lineNumber = _lineNumber;
								if (ConsumePropertyName())
								{
									goto IL_0341;
								}
								_consumed = consumed;
								_tokenType = JsonTokenType.StartObject;
								_bytePositionInLine = bytePositionInLine;
								_lineNumber = lineNumber;
							}
							else if (_tokenType == JsonTokenType.StartArray)
							{
								if (ConsumeValue(b))
								{
									goto IL_0341;
								}
							}
							else if (_tokenType == JsonTokenType.PropertyName)
							{
								if (ConsumeValue(b))
								{
									goto IL_0341;
								}
							}
							else if (_inObject)
							{
								if (b != 34)
								{
									ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
								}
								if (ConsumePropertyName())
								{
									goto IL_0341;
								}
							}
							else if (ConsumeValue(b))
							{
								goto IL_0341;
							}
							goto IL_0343;
						}
						EndArray();
					}
					goto IL_0341;
				}
				if ((int)_previousTokenType <= 1 || _previousTokenType == JsonTokenType.StartArray || _trailingCommaBeforeComment)
				{
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueAfterComment, b);
				}
				_consumed++;
				_bytePositionInLine++;
				if (_consumed >= (uint)_buffer.Length)
				{
					if (IsLastSpan)
					{
						_consumed--;
						_bytePositionInLine--;
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
					}
				}
				else
				{
					b = _buffer[_consumed];
					if (b <= 32)
					{
						SkipWhiteSpace();
						if (!HasMoreData(ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
						{
							goto IL_0343;
						}
						b = _buffer[_consumed];
					}
					TokenStartIndex = _consumed;
					if (b == 47)
					{
						_trailingCommaBeforeComment = true;
						if (ConsumeComment())
						{
							goto IL_0341;
						}
					}
					else if (_inObject)
					{
						if (b != 34)
						{
							if (b == 125)
							{
								if (_readerOptions.AllowTrailingCommas)
								{
									EndObject();
									goto IL_0341;
								}
								ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd, 0);
							}
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
						}
						if (ConsumePropertyName())
						{
							goto IL_0341;
						}
					}
					else
					{
						if (b == 93)
						{
							if (_readerOptions.AllowTrailingCommas)
							{
								EndArray();
								goto IL_0341;
							}
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd, 0);
						}
						if (ConsumeValue(b))
						{
							goto IL_0341;
						}
					}
				}
			}
			goto IL_0343;
			IL_0343:
			return ConsumeTokenResult.NotEnoughDataRollBackState;
			IL_0341:
			return ConsumeTokenResult.Success;
		}

		private bool SkipAllComments(scoped ref byte marker)
		{
			while (true)
			{
				if (marker == 47)
				{
					if (!SkipComment() || !HasMoreData())
					{
						break;
					}
					marker = _buffer[_consumed];
					if (marker <= 32)
					{
						SkipWhiteSpace();
						if (!HasMoreData())
						{
							break;
						}
						marker = _buffer[_consumed];
					}
					continue;
				}
				return true;
			}
			return false;
		}

		private bool SkipAllComments(scoped ref byte marker, ExceptionResource resource)
		{
			while (true)
			{
				if (marker == 47)
				{
					if (!SkipComment() || !HasMoreData(resource))
					{
						break;
					}
					marker = _buffer[_consumed];
					if (marker <= 32)
					{
						SkipWhiteSpace();
						if (!HasMoreData(resource))
						{
							break;
						}
						marker = _buffer[_consumed];
					}
					continue;
				}
				return true;
			}
			return false;
		}

		private ConsumeTokenResult ConsumeNextTokenUntilAfterAllCommentsAreSkipped(byte marker)
		{
			if (SkipAllComments(ref marker))
			{
				TokenStartIndex = _consumed;
				if (_tokenType == JsonTokenType.StartObject)
				{
					if (marker == 125)
					{
						EndObject();
					}
					else
					{
						if (marker != 34)
						{
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, marker);
						}
						int consumed = _consumed;
						long bytePositionInLine = _bytePositionInLine;
						long lineNumber = _lineNumber;
						if (!ConsumePropertyName())
						{
							_consumed = consumed;
							_tokenType = JsonTokenType.StartObject;
							_bytePositionInLine = bytePositionInLine;
							_lineNumber = lineNumber;
							goto IL_0281;
						}
					}
				}
				else if (_tokenType == JsonTokenType.StartArray)
				{
					if (marker == 93)
					{
						EndArray();
					}
					else if (!ConsumeValue(marker))
					{
						goto IL_0281;
					}
				}
				else if (_tokenType == JsonTokenType.PropertyName)
				{
					if (!ConsumeValue(marker))
					{
						goto IL_0281;
					}
				}
				else if (_bitStack.CurrentDepth == 0)
				{
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndAfterSingleJson, marker);
				}
				else
				{
					switch (marker)
					{
					case 44:
						_consumed++;
						_bytePositionInLine++;
						if (_consumed >= (uint)_buffer.Length)
						{
							if (IsLastSpan)
							{
								_consumed--;
								_bytePositionInLine--;
								ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
							}
							return ConsumeTokenResult.NotEnoughDataRollBackState;
						}
						marker = _buffer[_consumed];
						if (marker <= 32)
						{
							SkipWhiteSpace();
							if (!HasMoreData(ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
							{
								return ConsumeTokenResult.NotEnoughDataRollBackState;
							}
							marker = _buffer[_consumed];
						}
						if (SkipAllComments(ref marker, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
						{
							TokenStartIndex = _consumed;
							if (_inObject)
							{
								if (marker != 34)
								{
									if (marker == 125)
									{
										if (_readerOptions.AllowTrailingCommas)
										{
											EndObject();
											break;
										}
										ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd, 0);
									}
									ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, marker);
								}
								if (!ConsumePropertyName())
								{
									return ConsumeTokenResult.NotEnoughDataRollBackState;
								}
								return ConsumeTokenResult.Success;
							}
							if (marker == 93)
							{
								if (_readerOptions.AllowTrailingCommas)
								{
									EndArray();
									break;
								}
								ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd, 0);
							}
							if (!ConsumeValue(marker))
							{
								return ConsumeTokenResult.NotEnoughDataRollBackState;
							}
							return ConsumeTokenResult.Success;
						}
						return ConsumeTokenResult.NotEnoughDataRollBackState;
					case 125:
						EndObject();
						break;
					case 93:
						EndArray();
						break;
					default:
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.FoundInvalidCharacter, marker);
						break;
					}
				}
				return ConsumeTokenResult.Success;
			}
			goto IL_0281;
			IL_0281:
			return ConsumeTokenResult.IncompleteNoRollBackNecessary;
		}

		private bool SkipComment()
		{
			ReadOnlySpan<byte> readOnlySpan = _buffer.Slice(_consumed + 1);
			if (readOnlySpan.Length > 0)
			{
				int idx;
				switch (readOnlySpan[0])
				{
				case 47:
					return SkipSingleLineComment(readOnlySpan.Slice(1), out idx);
				case 42:
					return SkipMultiLineComment(readOnlySpan.Slice(1), out idx);
				}
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfValueNotFound, 47);
			}
			if (IsLastSpan)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfValueNotFound, 47);
			}
			return false;
		}

		private bool SkipSingleLineComment(ReadOnlySpan<byte> localBuffer, out int idx)
		{
			idx = FindLineSeparator(localBuffer);
			int num;
			if (idx != -1)
			{
				num = idx;
				if (localBuffer[idx] != 10)
				{
					if (idx < localBuffer.Length - 1)
					{
						if (localBuffer[idx + 1] == 10)
						{
							num++;
						}
					}
					else if (!IsLastSpan)
					{
						return false;
					}
				}
				num++;
				_bytePositionInLine = 0L;
				_lineNumber++;
			}
			else
			{
				if (!IsLastSpan)
				{
					return false;
				}
				idx = localBuffer.Length;
				num = idx;
				_bytePositionInLine += 2 + localBuffer.Length;
			}
			_consumed += 2 + num;
			return true;
		}

		private int FindLineSeparator(ReadOnlySpan<byte> localBuffer)
		{
			int num = 0;
			while (true)
			{
				int num2 = localBuffer.IndexOfAny<byte>(10, 13, 226);
				if (num2 == -1)
				{
					return -1;
				}
				num += num2;
				if (localBuffer[num2] != 226)
				{
					break;
				}
				num++;
				localBuffer = localBuffer.Slice(num2 + 1);
				ThrowOnDangerousLineSeparator(localBuffer);
			}
			return num;
		}

		private void ThrowOnDangerousLineSeparator(ReadOnlySpan<byte> localBuffer)
		{
			if (localBuffer.Length >= 2)
			{
				byte b = localBuffer[1];
				if (localBuffer[0] == 128 && (b == 168 || b == 169))
				{
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfLineSeparator, 0);
				}
			}
		}

		private bool SkipMultiLineComment(ReadOnlySpan<byte> localBuffer, out int idx)
		{
			idx = 0;
			while (true)
			{
				int num = localBuffer.Slice(idx).IndexOf<byte>(47);
				switch (num)
				{
				case -1:
					if (IsLastSpan)
					{
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfCommentNotFound, 0);
					}
					return false;
				default:
					if (localBuffer[num + idx - 1] == 42)
					{
						idx += num - 1;
						_consumed += 4 + idx;
						var (num2, num3) = JsonReaderHelper.CountNewLines(localBuffer.Slice(0, idx));
						_lineNumber += num2;
						if (num3 != -1)
						{
							_bytePositionInLine = idx - num3 + 1;
						}
						else
						{
							_bytePositionInLine += 4 + idx;
						}
						return true;
					}
					break;
				case 0:
					break;
				}
				idx += num + 1;
			}
		}

		private bool ConsumeComment()
		{
			ReadOnlySpan<byte> readOnlySpan = _buffer.Slice(_consumed + 1);
			if (readOnlySpan.Length > 0)
			{
				byte b = readOnlySpan[0];
				switch (b)
				{
				case 47:
					return ConsumeSingleLineComment(readOnlySpan.Slice(1), _consumed);
				case 42:
					return ConsumeMultiLineComment(readOnlySpan.Slice(1), _consumed);
				}
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterAtStartOfComment, b);
			}
			if (IsLastSpan)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfDataWhileReadingComment, 0);
			}
			return false;
		}

		private bool ConsumeSingleLineComment(ReadOnlySpan<byte> localBuffer, int previousConsumed)
		{
			if (!SkipSingleLineComment(localBuffer, out var idx))
			{
				return false;
			}
			ValueSpan = _buffer.Slice(previousConsumed + 2, idx);
			if (_tokenType != JsonTokenType.Comment)
			{
				_previousTokenType = _tokenType;
			}
			_tokenType = JsonTokenType.Comment;
			return true;
		}

		private bool ConsumeMultiLineComment(ReadOnlySpan<byte> localBuffer, int previousConsumed)
		{
			if (!SkipMultiLineComment(localBuffer, out var idx))
			{
				return false;
			}
			ValueSpan = _buffer.Slice(previousConsumed + 2, idx);
			if (_tokenType != JsonTokenType.Comment)
			{
				_previousTokenType = _tokenType;
			}
			_tokenType = JsonTokenType.Comment;
			return true;
		}

		private ReadOnlySpan<byte> GetUnescapedSpan()
		{
			ReadOnlySpan<byte> readOnlySpan = (HasValueSequence ? ((ReadOnlySpan<byte>)ValueSequence.ToArray<byte>()) : ValueSpan);
			if (ValueIsEscaped)
			{
				readOnlySpan = JsonReaderHelper.GetUnescapedSpan(readOnlySpan);
			}
			return readOnlySpan;
		}

		public Utf8JsonReader(ReadOnlySequence<byte> jsonData, bool isFinalBlock, JsonReaderState state)
		{
			ReadOnlyMemory<byte> memory = jsonData.First;
			_buffer = memory.Span;
			_isFinalBlock = isFinalBlock;
			_isInputSequence = true;
			_lineNumber = state._lineNumber;
			_bytePositionInLine = state._bytePositionInLine;
			_inObject = state._inObject;
			_isNotPrimitive = state._isNotPrimitive;
			ValueIsEscaped = state._valueIsEscaped;
			_trailingCommaBeforeComment = state._trailingCommaBeforeComment;
			_tokenType = state._tokenType;
			_previousTokenType = state._previousTokenType;
			_readerOptions = state._readerOptions;
			if (_readerOptions.MaxDepth == 0)
			{
				_readerOptions.MaxDepth = 64;
			}
			_bitStack = state._bitStack;
			_consumed = 0;
			TokenStartIndex = 0L;
			_totalConsumed = 0L;
			ValueSpan = ReadOnlySpan<byte>.Empty;
			_sequence = jsonData;
			HasValueSequence = false;
			ValueSequence = ReadOnlySequence<byte>.Empty;
			if (jsonData.IsSingleSegment)
			{
				_nextPosition = default(SequencePosition);
				_currentPosition = jsonData.Start;
				_isLastSegment = isFinalBlock;
				_isMultiSegment = false;
				return;
			}
			_currentPosition = jsonData.Start;
			_nextPosition = _currentPosition;
			bool flag = _buffer.Length == 0;
			if (flag)
			{
				SequencePosition nextPosition = _nextPosition;
				ReadOnlyMemory<byte> memory2;
				while (jsonData.TryGet(ref _nextPosition, out memory2))
				{
					_currentPosition = nextPosition;
					if (memory2.Length != 0)
					{
						_buffer = memory2.Span;
						break;
					}
					nextPosition = _nextPosition;
				}
			}
			_isLastSegment = !jsonData.TryGet(ref _nextPosition, out memory, !flag) && isFinalBlock;
			_isMultiSegment = true;
		}

		public Utf8JsonReader(ReadOnlySequence<byte> jsonData, JsonReaderOptions options = default(JsonReaderOptions))
			: this(jsonData, isFinalBlock: true, new JsonReaderState(options))
		{
		}

		private bool ReadMultiSegment()
		{
			bool flag = false;
			HasValueSequence = false;
			ValueIsEscaped = false;
			ValueSpan = default(ReadOnlySpan<byte>);
			ValueSequence = default(ReadOnlySequence<byte>);
			if (HasMoreDataMultiSegment())
			{
				byte b = _buffer[_consumed];
				if (b <= 32)
				{
					SkipWhiteSpaceMultiSegment();
					if (!HasMoreDataMultiSegment())
					{
						goto IL_0173;
					}
					b = _buffer[_consumed];
				}
				TokenStartIndex = BytesConsumed;
				if (_tokenType != JsonTokenType.None)
				{
					if (b == 47)
					{
						flag = ConsumeNextTokenOrRollbackMultiSegment(b);
					}
					else if (_tokenType == JsonTokenType.StartObject)
					{
						if (b == 125)
						{
							EndObject();
							goto IL_0171;
						}
						if (b != 34)
						{
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
						}
						long totalConsumed = _totalConsumed;
						int consumed = _consumed;
						long bytePositionInLine = _bytePositionInLine;
						long lineNumber = _lineNumber;
						SequencePosition currentPosition = _currentPosition;
						flag = ConsumePropertyNameMultiSegment();
						if (!flag)
						{
							_consumed = consumed;
							_tokenType = JsonTokenType.StartObject;
							_bytePositionInLine = bytePositionInLine;
							_lineNumber = lineNumber;
							_totalConsumed = totalConsumed;
							_currentPosition = currentPosition;
						}
					}
					else if (_tokenType != JsonTokenType.StartArray)
					{
						flag = ((_tokenType != JsonTokenType.PropertyName) ? ConsumeNextTokenOrRollbackMultiSegment(b) : ConsumeValueMultiSegment(b));
					}
					else
					{
						if (b == 93)
						{
							EndArray();
							goto IL_0171;
						}
						flag = ConsumeValueMultiSegment(b);
					}
				}
				else
				{
					flag = ReadFirstTokenMultiSegment(b);
				}
			}
			goto IL_0173;
			IL_0173:
			return flag;
			IL_0171:
			flag = true;
			goto IL_0173;
		}

		private bool ValidateStateAtEndOfData()
		{
			if (_bitStack.CurrentDepth != 0)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ZeroDepthAtEnd, 0);
			}
			if (_readerOptions.CommentHandling == JsonCommentHandling.Allow && _tokenType == JsonTokenType.Comment)
			{
				return false;
			}
			if (_tokenType != JsonTokenType.EndArray && _tokenType != JsonTokenType.EndObject)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidEndOfJsonNonPrimitive, 0);
			}
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private bool HasMoreDataMultiSegment()
		{
			if (_consumed >= (uint)_buffer.Length)
			{
				if (_isNotPrimitive && IsLastSpan && !ValidateStateAtEndOfData())
				{
					return false;
				}
				if (!GetNextSpan())
				{
					if (_isNotPrimitive && IsLastSpan)
					{
						ValidateStateAtEndOfData();
					}
					return false;
				}
			}
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private bool HasMoreDataMultiSegment(ExceptionResource resource)
		{
			if (_consumed >= (uint)_buffer.Length)
			{
				if (IsLastSpan)
				{
					ThrowHelper.ThrowJsonReaderException(ref this, resource, 0);
				}
				if (!GetNextSpan())
				{
					if (IsLastSpan)
					{
						ThrowHelper.ThrowJsonReaderException(ref this, resource, 0);
					}
					return false;
				}
			}
			return true;
		}

		private bool GetNextSpan()
		{
			ReadOnlyMemory<byte> memory;
			while (true)
			{
				SequencePosition currentPosition = _currentPosition;
				_currentPosition = _nextPosition;
				if (!_sequence.TryGet(ref _nextPosition, out memory))
				{
					_currentPosition = currentPosition;
					_isLastSegment = true;
					return false;
				}
				if (memory.Length != 0)
				{
					break;
				}
				_currentPosition = currentPosition;
			}
			if (_isFinalBlock)
			{
				_isLastSegment = !_sequence.TryGet(ref _nextPosition, out var _, advance: false);
			}
			_buffer = memory.Span;
			_totalConsumed += _consumed;
			_consumed = 0;
			return true;
		}

		private bool ReadFirstTokenMultiSegment(byte first)
		{
			switch (first)
			{
			case 123:
				_bitStack.SetFirstBit();
				_tokenType = JsonTokenType.StartObject;
				ValueSpan = _buffer.Slice(_consumed, 1);
				_consumed++;
				_bytePositionInLine++;
				_inObject = true;
				_isNotPrimitive = true;
				break;
			case 91:
				_bitStack.ResetFirstBit();
				_tokenType = JsonTokenType.StartArray;
				ValueSpan = _buffer.Slice(_consumed, 1);
				_consumed++;
				_bytePositionInLine++;
				_isNotPrimitive = true;
				break;
			default:
				if (JsonHelpers.IsDigit(first) || first == 45)
				{
					if (!TryGetNumberMultiSegment(_buffer.Slice(_consumed), out var consumed))
					{
						return false;
					}
					_tokenType = JsonTokenType.Number;
					_consumed += consumed;
					return true;
				}
				if (!ConsumeValueMultiSegment(first))
				{
					return false;
				}
				if (_tokenType == JsonTokenType.StartObject || _tokenType == JsonTokenType.StartArray)
				{
					_isNotPrimitive = true;
				}
				break;
			}
			return true;
		}

		private void SkipWhiteSpaceMultiSegment()
		{
			do
			{
				SkipWhiteSpace();
			}
			while (_consumed >= _buffer.Length && GetNextSpan());
		}

		private bool ConsumeValueMultiSegment(byte marker)
		{
			while (true)
			{
				_trailingCommaBeforeComment = false;
				switch (marker)
				{
				case 34:
					return ConsumeStringMultiSegment();
				case 123:
					StartObject();
					break;
				case 91:
					StartArray();
					break;
				default:
					if (JsonHelpers.IsDigit(marker) || marker == 45)
					{
						return ConsumeNumberMultiSegment();
					}
					switch (marker)
					{
					case 102:
						return ConsumeLiteralMultiSegment(JsonConstants.FalseValue, JsonTokenType.False);
					case 116:
						return ConsumeLiteralMultiSegment(JsonConstants.TrueValue, JsonTokenType.True);
					case 110:
						return ConsumeLiteralMultiSegment(JsonConstants.NullValue, JsonTokenType.Null);
					}
					switch (_readerOptions.CommentHandling)
					{
					case JsonCommentHandling.Allow:
						if (marker == 47)
						{
							SequencePosition currentPosition2 = _currentPosition;
							if (!SkipOrConsumeCommentMultiSegmentWithRollback())
							{
								_currentPosition = currentPosition2;
								return false;
							}
							return true;
						}
						break;
					default:
					{
						if (marker != 47)
						{
							break;
						}
						SequencePosition currentPosition = _currentPosition;
						if (SkipCommentMultiSegment(out var _))
						{
							if (_consumed >= (uint)_buffer.Length)
							{
								if (_isNotPrimitive && IsLastSpan && _tokenType != JsonTokenType.EndArray && _tokenType != JsonTokenType.EndObject)
								{
									ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidEndOfJsonNonPrimitive, 0);
								}
								if (!GetNextSpan())
								{
									if (_isNotPrimitive && IsLastSpan && _tokenType != JsonTokenType.EndArray && _tokenType != JsonTokenType.EndObject)
									{
										ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidEndOfJsonNonPrimitive, 0);
									}
									_currentPosition = currentPosition;
									return false;
								}
							}
							marker = _buffer[_consumed];
							if (marker <= 32)
							{
								SkipWhiteSpaceMultiSegment();
								if (!HasMoreDataMultiSegment())
								{
									_currentPosition = currentPosition;
									return false;
								}
								marker = _buffer[_consumed];
							}
							goto IL_01a8;
						}
						_currentPosition = currentPosition;
						return false;
					}
					case JsonCommentHandling.Disallow:
						break;
					}
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfValueNotFound, marker);
					break;
				}
				break;
				IL_01a8:
				TokenStartIndex = BytesConsumed;
			}
			return true;
		}

		private bool ConsumeLiteralMultiSegment(ReadOnlySpan<byte> literal, JsonTokenType tokenType)
		{
			ReadOnlySpan<byte> span = _buffer.Slice(_consumed);
			int consumed = literal.Length;
			if (!span.StartsWith(literal))
			{
				int consumed2 = _consumed;
				if (!CheckLiteralMultiSegment(span, literal, out consumed))
				{
					_consumed = consumed2;
					return false;
				}
			}
			else
			{
				ValueSpan = span.Slice(0, literal.Length);
				HasValueSequence = false;
			}
			_tokenType = tokenType;
			_consumed += consumed;
			_bytePositionInLine += consumed;
			return true;
		}

		private bool CheckLiteralMultiSegment(ReadOnlySpan<byte> span, ReadOnlySpan<byte> literal, out int consumed)
		{
			Span<byte> destination = stackalloc byte[5];
			int num = 0;
			long totalConsumed = _totalConsumed;
			SequencePosition currentPosition = _currentPosition;
			if (span.Length >= literal.Length || IsLastSpan)
			{
				_bytePositionInLine += FindMismatch(span, literal);
				int num2 = Math.Min(span.Length, (int)_bytePositionInLine + 1);
				span.Slice(0, num2).CopyTo(destination);
				num += num2;
			}
			else if (!literal.StartsWith(span))
			{
				_bytePositionInLine += FindMismatch(span, literal);
				int num3 = Math.Min(span.Length, (int)_bytePositionInLine + 1);
				span.Slice(0, num3).CopyTo(destination);
				num += num3;
			}
			else
			{
				ReadOnlySpan<byte> readOnlySpan = literal.Slice(span.Length);
				SequencePosition currentPosition2 = _currentPosition;
				int consumed2 = _consumed;
				int num4 = literal.Length - readOnlySpan.Length;
				while (true)
				{
					_totalConsumed += num4;
					_bytePositionInLine += num4;
					if (!GetNextSpan())
					{
						_totalConsumed = totalConsumed;
						consumed = 0;
						_currentPosition = currentPosition;
						if (IsLastSpan)
						{
							break;
						}
						return false;
					}
					int num5 = Math.Min(span.Length, destination.Length - num);
					span.Slice(0, num5).CopyTo(destination.Slice(num));
					num += num5;
					span = _buffer;
					if (span.StartsWith(readOnlySpan))
					{
						HasValueSequence = true;
						SequencePosition start = new SequencePosition(currentPosition2.GetObject(), currentPosition2.GetInteger() + consumed2);
						SequencePosition end = new SequencePosition(_currentPosition.GetObject(), _currentPosition.GetInteger() + readOnlySpan.Length);
						ValueSequence = _sequence.Slice(start, end);
						consumed = readOnlySpan.Length;
						return true;
					}
					if (!readOnlySpan.StartsWith(span))
					{
						_bytePositionInLine += FindMismatch(span, readOnlySpan);
						num5 = Math.Min(span.Length, (int)_bytePositionInLine + 1);
						span.Slice(0, num5).CopyTo(destination.Slice(num));
						num += num5;
						break;
					}
					readOnlySpan = readOnlySpan.Slice(span.Length);
					num4 = span.Length;
				}
			}
			_totalConsumed = totalConsumed;
			consumed = 0;
			_currentPosition = currentPosition;
			throw GetInvalidLiteralMultiSegment(destination.Slice(0, num).ToArray());
		}

		private static int FindMismatch(ReadOnlySpan<byte> span, ReadOnlySpan<byte> literal)
		{
			int num = Math.Min(span.Length, literal.Length);
			int i;
			for (i = 0; i < num && span[i] == literal[i]; i++)
			{
			}
			return i;
		}

		private JsonException GetInvalidLiteralMultiSegment(ReadOnlySpan<byte> span)
		{
			return ThrowHelper.GetJsonReaderException(ref this, span[0] switch
			{
				116 => ExceptionResource.ExpectedTrue, 
				102 => ExceptionResource.ExpectedFalse, 
				_ => ExceptionResource.ExpectedNull, 
			}, 0, span);
		}

		private bool ConsumeNumberMultiSegment()
		{
			if (!TryGetNumberMultiSegment(_buffer.Slice(_consumed), out var consumed))
			{
				return false;
			}
			_tokenType = JsonTokenType.Number;
			_consumed += consumed;
			if (_consumed >= (uint)_buffer.Length && _isNotPrimitive)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndOfDigitNotFound, _buffer[_consumed - 1]);
			}
			return true;
		}

		private bool ConsumePropertyNameMultiSegment()
		{
			_trailingCommaBeforeComment = false;
			if (!ConsumeStringMultiSegment())
			{
				return false;
			}
			if (!HasMoreDataMultiSegment(ExceptionResource.ExpectedValueAfterPropertyNameNotFound))
			{
				return false;
			}
			byte b = _buffer[_consumed];
			if (b <= 32)
			{
				SkipWhiteSpaceMultiSegment();
				if (!HasMoreDataMultiSegment(ExceptionResource.ExpectedValueAfterPropertyNameNotFound))
				{
					return false;
				}
				b = _buffer[_consumed];
			}
			if (b != 58)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedSeparatorAfterPropertyNameNotFound, b);
			}
			_consumed++;
			_bytePositionInLine++;
			_tokenType = JsonTokenType.PropertyName;
			return true;
		}

		private bool ConsumeStringMultiSegment()
		{
			ReadOnlySpan<byte> readOnlySpan = _buffer.Slice(_consumed + 1);
			int num = readOnlySpan.IndexOfQuoteOrAnyControlOrBackSlash();
			if (num >= 0)
			{
				byte b = readOnlySpan[num];
				if (b == 34)
				{
					_bytePositionInLine += num + 2;
					ValueSpan = readOnlySpan.Slice(0, num);
					HasValueSequence = false;
					ValueIsEscaped = false;
					_tokenType = JsonTokenType.String;
					_consumed += num + 2;
					return true;
				}
				return ConsumeStringAndValidateMultiSegment(readOnlySpan, num);
			}
			if (IsLastSpan)
			{
				_bytePositionInLine += readOnlySpan.Length + 1;
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
			}
			return ConsumeStringNextSegment();
		}

		private bool ConsumeStringNextSegment()
		{
			PartialStateForRollback state = CaptureState();
			HasValueSequence = true;
			int num = _buffer.Length - _consumed;
			ReadOnlySpan<byte> buffer;
			int num2;
			while (true)
			{
				if (!GetNextSpan())
				{
					if (IsLastSpan)
					{
						_bytePositionInLine += num;
						RollBackState(in state, isError: true);
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
					}
					RollBackState(in state);
					return false;
				}
				buffer = _buffer;
				num2 = buffer.IndexOfQuoteOrAnyControlOrBackSlash();
				if (num2 >= 0)
				{
					break;
				}
				_totalConsumed += buffer.Length;
				_bytePositionInLine += buffer.Length;
			}
			byte b = buffer[num2];
			SequencePosition end;
			if (b == 34)
			{
				end = new SequencePosition(_currentPosition.GetObject(), _currentPosition.GetInteger() + num2);
				_bytePositionInLine += num + num2 + 1;
				_totalConsumed += num;
				_consumed = num2 + 1;
				ValueIsEscaped = false;
			}
			else
			{
				_bytePositionInLine += num + num2;
				ValueIsEscaped = true;
				bool flag = false;
				while (true)
				{
					if (num2 < buffer.Length)
					{
						byte b2 = buffer[num2];
						if (b2 == 34)
						{
							if (!flag)
							{
								break;
							}
							flag = false;
						}
						else if (b2 == 92)
						{
							flag = !flag;
						}
						else if (flag)
						{
							int num3 = JsonConstants.EscapableChars.IndexOf(b2);
							if (num3 == -1)
							{
								RollBackState(in state, isError: true);
								ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterAfterEscapeWithinString, b2);
							}
							if (b2 == 117)
							{
								_bytePositionInLine++;
								int num4 = 0;
								int num5 = num2 + 1;
								while (true)
								{
									if (num5 < buffer.Length)
									{
										byte nextByte = buffer[num5];
										if (!JsonReaderHelper.IsHexDigit(nextByte))
										{
											RollBackState(in state, isError: true);
											ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidHexCharacterWithinString, nextByte);
										}
										num4++;
										_bytePositionInLine++;
										if (num4 >= 4)
										{
											break;
										}
										num5++;
										continue;
									}
									if (!GetNextSpan())
									{
										if (IsLastSpan)
										{
											RollBackState(in state, isError: true);
											ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
										}
										RollBackState(in state);
										return false;
									}
									_totalConsumed += buffer.Length;
									buffer = _buffer;
									num5 = 0;
								}
								flag = false;
								num2 = num5 + 1;
								continue;
							}
							flag = false;
						}
						else if (b2 < 32)
						{
							RollBackState(in state, isError: true);
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterWithinString, b2);
						}
						_bytePositionInLine++;
						num2++;
						continue;
					}
					if (!GetNextSpan())
					{
						if (IsLastSpan)
						{
							RollBackState(in state, isError: true);
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
						}
						RollBackState(in state);
						return false;
					}
					_totalConsumed += buffer.Length;
					buffer = _buffer;
					num2 = 0;
				}
				_bytePositionInLine++;
				_consumed = num2 + 1;
				_totalConsumed += num;
				end = new SequencePosition(_currentPosition.GetObject(), _currentPosition.GetInteger() + num2);
			}
			SequencePosition startPosition = state.GetStartPosition(1);
			ValueSequence = _sequence.Slice(startPosition, end);
			_tokenType = JsonTokenType.String;
			return true;
		}

		private bool ConsumeStringAndValidateMultiSegment(ReadOnlySpan<byte> data, int idx)
		{
			PartialStateForRollback state = CaptureState();
			HasValueSequence = false;
			int num = _buffer.Length - _consumed;
			_bytePositionInLine += idx + 1;
			bool flag = false;
			while (true)
			{
				if (idx < data.Length)
				{
					byte b = data[idx];
					switch (b)
					{
					case 34:
						if (flag)
						{
							flag = false;
							goto IL_01b7;
						}
						if (HasValueSequence)
						{
							_bytePositionInLine++;
							_consumed = idx + 1;
							_totalConsumed += num;
							SequencePosition end = new SequencePosition(_currentPosition.GetObject(), _currentPosition.GetInteger() + idx);
							SequencePosition startPosition = state.GetStartPosition(1);
							ValueSequence = _sequence.Slice(startPosition, end);
						}
						else
						{
							_bytePositionInLine++;
							_consumed += idx + 2;
							ValueSpan = data.Slice(0, idx);
						}
						ValueIsEscaped = true;
						_tokenType = JsonTokenType.String;
						return true;
					case 92:
						flag = !flag;
						goto IL_01b7;
					default:
						{
							if (flag)
							{
								int num2 = JsonConstants.EscapableChars.IndexOf(b);
								if (num2 == -1)
								{
									RollBackState(in state, isError: true);
									ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterAfterEscapeWithinString, b);
								}
								if (b == 117)
								{
									_bytePositionInLine++;
									int num3 = 0;
									int num4 = idx + 1;
									while (true)
									{
										if (num4 < data.Length)
										{
											byte nextByte = data[num4];
											if (!JsonReaderHelper.IsHexDigit(nextByte))
											{
												RollBackState(in state, isError: true);
												ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidHexCharacterWithinString, nextByte);
											}
											num3++;
											_bytePositionInLine++;
											if (num3 >= 4)
											{
												break;
											}
											num4++;
											continue;
										}
										if (!GetNextSpan())
										{
											if (IsLastSpan)
											{
												RollBackState(in state, isError: true);
												ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
											}
											RollBackState(in state);
											return false;
										}
										if (HasValueSequence)
										{
											_totalConsumed += data.Length;
										}
										data = _buffer;
										num4 = 0;
										HasValueSequence = true;
									}
									flag = false;
									idx = num4 + 1;
									break;
								}
								flag = false;
							}
							else if (b < 32)
							{
								RollBackState(in state, isError: true);
								ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterWithinString, b);
							}
							goto IL_01b7;
						}
						IL_01b7:
						_bytePositionInLine++;
						idx++;
						break;
					}
				}
				else
				{
					if (!GetNextSpan())
					{
						break;
					}
					if (HasValueSequence)
					{
						_totalConsumed += data.Length;
					}
					data = _buffer;
					idx = 0;
					HasValueSequence = true;
				}
			}
			if (IsLastSpan)
			{
				RollBackState(in state, isError: true);
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
			}
			RollBackState(in state);
			return false;
		}

		private void RollBackState(scoped in PartialStateForRollback state, bool isError = false)
		{
			_totalConsumed = state._prevTotalConsumed;
			if (!isError)
			{
				_bytePositionInLine = state._prevBytePositionInLine;
			}
			_consumed = state._prevConsumed;
			_currentPosition = state._prevCurrentPosition;
		}

		private bool TryGetNumberMultiSegment(ReadOnlySpan<byte> data, out int consumed)
		{
			PartialStateForRollback rollBackState = CaptureState();
			consumed = 0;
			int i = 0;
			ConsumeNumberResult consumeNumberResult = ConsumeNegativeSignMultiSegment(ref data, ref i, in rollBackState);
			if (consumeNumberResult == ConsumeNumberResult.NeedMoreData)
			{
				RollBackState(in rollBackState);
				return false;
			}
			byte b = data[i];
			if (b == 48)
			{
				ConsumeNumberResult consumeNumberResult2 = ConsumeZeroMultiSegment(ref data, ref i, in rollBackState);
				if (consumeNumberResult2 == ConsumeNumberResult.NeedMoreData)
				{
					RollBackState(in rollBackState);
					return false;
				}
				if (consumeNumberResult2 != ConsumeNumberResult.Success)
				{
					b = data[i];
					goto IL_00bf;
				}
			}
			else
			{
				ConsumeNumberResult consumeNumberResult3 = ConsumeIntegerDigitsMultiSegment(ref data, ref i);
				if (consumeNumberResult3 == ConsumeNumberResult.NeedMoreData)
				{
					RollBackState(in rollBackState);
					return false;
				}
				if (consumeNumberResult3 != ConsumeNumberResult.Success)
				{
					b = data[i];
					if (b != 46 && b != 69 && b != 101)
					{
						RollBackState(in rollBackState, isError: true);
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndOfDigitNotFound, b);
					}
					goto IL_00bf;
				}
			}
			goto IL_01b1;
			IL_00bf:
			if (b == 46)
			{
				i++;
				_bytePositionInLine++;
				ConsumeNumberResult consumeNumberResult4 = ConsumeDecimalDigitsMultiSegment(ref data, ref i, in rollBackState);
				if (consumeNumberResult4 == ConsumeNumberResult.NeedMoreData)
				{
					RollBackState(in rollBackState);
					return false;
				}
				if (consumeNumberResult4 == ConsumeNumberResult.Success)
				{
					goto IL_01b1;
				}
				b = data[i];
				if (b != 69 && b != 101)
				{
					RollBackState(in rollBackState, isError: true);
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedNextDigitEValueNotFound, b);
				}
			}
			i++;
			_bytePositionInLine++;
			consumeNumberResult = ConsumeSignMultiSegment(ref data, ref i, in rollBackState);
			if (consumeNumberResult == ConsumeNumberResult.NeedMoreData)
			{
				RollBackState(in rollBackState);
				return false;
			}
			i++;
			_bytePositionInLine++;
			switch (ConsumeIntegerDigitsMultiSegment(ref data, ref i))
			{
			case ConsumeNumberResult.NeedMoreData:
				RollBackState(in rollBackState);
				return false;
			default:
				RollBackState(in rollBackState, isError: true);
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndOfDigitNotFound, data[i]);
				break;
			case ConsumeNumberResult.Success:
				break;
			}
			goto IL_01b1;
			IL_01b1:
			if (HasValueSequence)
			{
				SequencePosition startPosition = rollBackState.GetStartPosition();
				SequencePosition end = new SequencePosition(_currentPosition.GetObject(), _currentPosition.GetInteger() + i);
				ValueSequence = _sequence.Slice(startPosition, end);
				consumed = i;
			}
			else
			{
				ValueSpan = data.Slice(0, i);
				consumed = i;
			}
			return true;
		}

		private ConsumeNumberResult ConsumeNegativeSignMultiSegment(ref ReadOnlySpan<byte> data, scoped ref int i, scoped in PartialStateForRollback rollBackState)
		{
			byte b = data[i];
			if (b == 45)
			{
				i++;
				_bytePositionInLine++;
				if (i >= data.Length)
				{
					if (IsLastSpan)
					{
						RollBackState(in rollBackState, isError: true);
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
					}
					if (!GetNextSpan())
					{
						if (IsLastSpan)
						{
							RollBackState(in rollBackState, isError: true);
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
						}
						return ConsumeNumberResult.NeedMoreData;
					}
					_totalConsumed += i;
					HasValueSequence = true;
					i = 0;
					data = _buffer;
				}
				b = data[i];
				if (!JsonHelpers.IsDigit(b))
				{
					RollBackState(in rollBackState, isError: true);
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundAfterSign, b);
				}
			}
			return ConsumeNumberResult.OperationIncomplete;
		}

		private ConsumeNumberResult ConsumeZeroMultiSegment(ref ReadOnlySpan<byte> data, scoped ref int i, scoped in PartialStateForRollback rollBackState)
		{
			i++;
			_bytePositionInLine++;
			byte value;
			if (i < data.Length)
			{
				value = data[i];
				if (JsonConstants.Delimiters.IndexOf(value) >= 0)
				{
					return ConsumeNumberResult.Success;
				}
			}
			else
			{
				if (IsLastSpan)
				{
					return ConsumeNumberResult.Success;
				}
				if (!GetNextSpan())
				{
					if (IsLastSpan)
					{
						return ConsumeNumberResult.Success;
					}
					return ConsumeNumberResult.NeedMoreData;
				}
				_totalConsumed += i;
				HasValueSequence = true;
				i = 0;
				data = _buffer;
				value = data[i];
				if (JsonConstants.Delimiters.IndexOf(value) >= 0)
				{
					return ConsumeNumberResult.Success;
				}
			}
			value = data[i];
			if (value != 46 && value != 69 && value != 101)
			{
				RollBackState(in rollBackState, isError: true);
				ThrowHelper.ThrowJsonReaderException(ref this, JsonHelpers.IsInRangeInclusive(value, 48, 57) ? ExceptionResource.InvalidLeadingZeroInNumber : ExceptionResource.ExpectedEndOfDigitNotFound, value);
			}
			return ConsumeNumberResult.OperationIncomplete;
		}

		private ConsumeNumberResult ConsumeIntegerDigitsMultiSegment(ref ReadOnlySpan<byte> data, scoped ref int i)
		{
			byte value = 0;
			int num = 0;
			while (i < data.Length)
			{
				value = data[i];
				if (!JsonHelpers.IsDigit(value))
				{
					break;
				}
				num++;
				i++;
			}
			if (i >= data.Length)
			{
				if (IsLastSpan)
				{
					_bytePositionInLine += num;
					return ConsumeNumberResult.Success;
				}
				while (true)
				{
					if (!GetNextSpan())
					{
						if (IsLastSpan)
						{
							_bytePositionInLine += num;
							return ConsumeNumberResult.Success;
						}
						return ConsumeNumberResult.NeedMoreData;
					}
					_totalConsumed += i;
					_bytePositionInLine += num;
					num = 0;
					HasValueSequence = true;
					i = 0;
					data = _buffer;
					while (i < data.Length)
					{
						value = data[i];
						if (!JsonHelpers.IsDigit(value))
						{
							break;
						}
						i++;
					}
					_bytePositionInLine += i;
					if (i < data.Length)
					{
						break;
					}
					if (IsLastSpan)
					{
						return ConsumeNumberResult.Success;
					}
				}
			}
			else
			{
				_bytePositionInLine += num;
			}
			if (JsonConstants.Delimiters.IndexOf(value) >= 0)
			{
				return ConsumeNumberResult.Success;
			}
			return ConsumeNumberResult.OperationIncomplete;
		}

		private ConsumeNumberResult ConsumeDecimalDigitsMultiSegment(ref ReadOnlySpan<byte> data, scoped ref int i, scoped in PartialStateForRollback rollBackState)
		{
			if (i >= data.Length)
			{
				if (IsLastSpan)
				{
					RollBackState(in rollBackState, isError: true);
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
				}
				if (!GetNextSpan())
				{
					if (IsLastSpan)
					{
						RollBackState(in rollBackState, isError: true);
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
					}
					return ConsumeNumberResult.NeedMoreData;
				}
				_totalConsumed += i;
				HasValueSequence = true;
				i = 0;
				data = _buffer;
			}
			byte b = data[i];
			if (!JsonHelpers.IsDigit(b))
			{
				RollBackState(in rollBackState, isError: true);
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundAfterDecimal, b);
			}
			i++;
			_bytePositionInLine++;
			return ConsumeIntegerDigitsMultiSegment(ref data, ref i);
		}

		private ConsumeNumberResult ConsumeSignMultiSegment(ref ReadOnlySpan<byte> data, scoped ref int i, scoped in PartialStateForRollback rollBackState)
		{
			if (i >= data.Length)
			{
				if (IsLastSpan)
				{
					RollBackState(in rollBackState, isError: true);
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
				}
				if (!GetNextSpan())
				{
					if (IsLastSpan)
					{
						RollBackState(in rollBackState, isError: true);
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
					}
					return ConsumeNumberResult.NeedMoreData;
				}
				_totalConsumed += i;
				HasValueSequence = true;
				i = 0;
				data = _buffer;
			}
			byte b = data[i];
			if (b == 43 || b == 45)
			{
				i++;
				_bytePositionInLine++;
				if (i >= data.Length)
				{
					if (IsLastSpan)
					{
						RollBackState(in rollBackState, isError: true);
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
					}
					if (!GetNextSpan())
					{
						if (IsLastSpan)
						{
							RollBackState(in rollBackState, isError: true);
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
						}
						return ConsumeNumberResult.NeedMoreData;
					}
					_totalConsumed += i;
					HasValueSequence = true;
					i = 0;
					data = _buffer;
				}
				b = data[i];
			}
			if (!JsonHelpers.IsDigit(b))
			{
				RollBackState(in rollBackState, isError: true);
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundAfterSign, b);
			}
			return ConsumeNumberResult.OperationIncomplete;
		}

		private bool ConsumeNextTokenOrRollbackMultiSegment(byte marker)
		{
			long totalConsumed = _totalConsumed;
			int consumed = _consumed;
			long bytePositionInLine = _bytePositionInLine;
			long lineNumber = _lineNumber;
			JsonTokenType tokenType = _tokenType;
			SequencePosition currentPosition = _currentPosition;
			bool trailingCommaBeforeComment = _trailingCommaBeforeComment;
			switch (ConsumeNextTokenMultiSegment(marker))
			{
			case ConsumeTokenResult.Success:
				return true;
			case ConsumeTokenResult.NotEnoughDataRollBackState:
				_consumed = consumed;
				_tokenType = tokenType;
				_bytePositionInLine = bytePositionInLine;
				_lineNumber = lineNumber;
				_totalConsumed = totalConsumed;
				_currentPosition = currentPosition;
				_trailingCommaBeforeComment = trailingCommaBeforeComment;
				break;
			}
			return false;
		}

		private ConsumeTokenResult ConsumeNextTokenMultiSegment(byte marker)
		{
			if (_readerOptions.CommentHandling != JsonCommentHandling.Disallow)
			{
				if (_readerOptions.CommentHandling != JsonCommentHandling.Allow)
				{
					return ConsumeNextTokenUntilAfterAllCommentsAreSkippedMultiSegment(marker);
				}
				if (marker == 47)
				{
					if (!SkipOrConsumeCommentMultiSegmentWithRollback())
					{
						return ConsumeTokenResult.NotEnoughDataRollBackState;
					}
					return ConsumeTokenResult.Success;
				}
				if (_tokenType == JsonTokenType.Comment)
				{
					return ConsumeNextTokenFromLastNonCommentTokenMultiSegment();
				}
			}
			if (_bitStack.CurrentDepth == 0)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndAfterSingleJson, marker);
			}
			switch (marker)
			{
			case 44:
			{
				_consumed++;
				_bytePositionInLine++;
				if (_consumed >= (uint)_buffer.Length)
				{
					if (IsLastSpan)
					{
						_consumed--;
						_bytePositionInLine--;
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
					}
					if (!GetNextSpan())
					{
						if (IsLastSpan)
						{
							_consumed--;
							_bytePositionInLine--;
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
						}
						return ConsumeTokenResult.NotEnoughDataRollBackState;
					}
				}
				byte b = _buffer[_consumed];
				if (b <= 32)
				{
					SkipWhiteSpaceMultiSegment();
					if (!HasMoreDataMultiSegment(ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
					{
						return ConsumeTokenResult.NotEnoughDataRollBackState;
					}
					b = _buffer[_consumed];
				}
				TokenStartIndex = BytesConsumed;
				if (_readerOptions.CommentHandling == JsonCommentHandling.Allow && b == 47)
				{
					_trailingCommaBeforeComment = true;
					if (!SkipOrConsumeCommentMultiSegmentWithRollback())
					{
						return ConsumeTokenResult.NotEnoughDataRollBackState;
					}
					return ConsumeTokenResult.Success;
				}
				if (_inObject)
				{
					if (b != 34)
					{
						if (b == 125)
						{
							if (_readerOptions.AllowTrailingCommas)
							{
								EndObject();
								return ConsumeTokenResult.Success;
							}
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd, 0);
						}
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
					}
					if (!ConsumePropertyNameMultiSegment())
					{
						return ConsumeTokenResult.NotEnoughDataRollBackState;
					}
					return ConsumeTokenResult.Success;
				}
				if (b == 93)
				{
					if (_readerOptions.AllowTrailingCommas)
					{
						EndArray();
						return ConsumeTokenResult.Success;
					}
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd, 0);
				}
				if (!ConsumeValueMultiSegment(b))
				{
					return ConsumeTokenResult.NotEnoughDataRollBackState;
				}
				return ConsumeTokenResult.Success;
			}
			case 125:
				EndObject();
				break;
			case 93:
				EndArray();
				break;
			default:
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.FoundInvalidCharacter, marker);
				break;
			}
			return ConsumeTokenResult.Success;
		}

		private ConsumeTokenResult ConsumeNextTokenFromLastNonCommentTokenMultiSegment()
		{
			if (JsonReaderHelper.IsTokenTypePrimitive(_previousTokenType))
			{
				_tokenType = (_inObject ? JsonTokenType.StartObject : JsonTokenType.StartArray);
			}
			else
			{
				_tokenType = _previousTokenType;
			}
			if (HasMoreDataMultiSegment())
			{
				byte b = _buffer[_consumed];
				if (b <= 32)
				{
					SkipWhiteSpaceMultiSegment();
					if (!HasMoreDataMultiSegment())
					{
						goto IL_0393;
					}
					b = _buffer[_consumed];
				}
				if (_bitStack.CurrentDepth == 0 && _tokenType != JsonTokenType.None)
				{
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndAfterSingleJson, b);
				}
				TokenStartIndex = BytesConsumed;
				if (b != 44)
				{
					if (b == 125)
					{
						EndObject();
					}
					else
					{
						if (b != 93)
						{
							if (_tokenType == JsonTokenType.None)
							{
								if (ReadFirstTokenMultiSegment(b))
								{
									goto IL_0391;
								}
							}
							else if (_tokenType == JsonTokenType.StartObject)
							{
								if (b != 34)
								{
									ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
								}
								long totalConsumed = _totalConsumed;
								int consumed = _consumed;
								long bytePositionInLine = _bytePositionInLine;
								long lineNumber = _lineNumber;
								if (ConsumePropertyNameMultiSegment())
								{
									goto IL_0391;
								}
								_consumed = consumed;
								_tokenType = JsonTokenType.StartObject;
								_bytePositionInLine = bytePositionInLine;
								_lineNumber = lineNumber;
								_totalConsumed = totalConsumed;
							}
							else if (_tokenType == JsonTokenType.StartArray)
							{
								if (ConsumeValueMultiSegment(b))
								{
									goto IL_0391;
								}
							}
							else if (_tokenType == JsonTokenType.PropertyName)
							{
								if (ConsumeValueMultiSegment(b))
								{
									goto IL_0391;
								}
							}
							else if (_inObject)
							{
								if (b != 34)
								{
									ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
								}
								if (ConsumePropertyNameMultiSegment())
								{
									goto IL_0391;
								}
							}
							else if (ConsumeValueMultiSegment(b))
							{
								goto IL_0391;
							}
							goto IL_0393;
						}
						EndArray();
					}
					goto IL_0391;
				}
				if ((int)_previousTokenType <= 1 || _previousTokenType == JsonTokenType.StartArray || _trailingCommaBeforeComment)
				{
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueAfterComment, b);
				}
				_consumed++;
				_bytePositionInLine++;
				if (_consumed >= (uint)_buffer.Length)
				{
					if (IsLastSpan)
					{
						_consumed--;
						_bytePositionInLine--;
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
					}
					if (!GetNextSpan())
					{
						if (IsLastSpan)
						{
							_consumed--;
							_bytePositionInLine--;
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
						}
						goto IL_0393;
					}
				}
				b = _buffer[_consumed];
				if (b <= 32)
				{
					SkipWhiteSpaceMultiSegment();
					if (!HasMoreDataMultiSegment(ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
					{
						goto IL_0393;
					}
					b = _buffer[_consumed];
				}
				TokenStartIndex = BytesConsumed;
				if (b == 47)
				{
					_trailingCommaBeforeComment = true;
					if (SkipOrConsumeCommentMultiSegmentWithRollback())
					{
						goto IL_0391;
					}
				}
				else if (_inObject)
				{
					if (b != 34)
					{
						if (b == 125)
						{
							if (_readerOptions.AllowTrailingCommas)
							{
								EndObject();
								goto IL_0391;
							}
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd, 0);
						}
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
					}
					if (ConsumePropertyNameMultiSegment())
					{
						goto IL_0391;
					}
				}
				else
				{
					if (b == 93)
					{
						if (_readerOptions.AllowTrailingCommas)
						{
							EndArray();
							goto IL_0391;
						}
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd, 0);
					}
					if (ConsumeValueMultiSegment(b))
					{
						goto IL_0391;
					}
				}
			}
			goto IL_0393;
			IL_0393:
			return ConsumeTokenResult.NotEnoughDataRollBackState;
			IL_0391:
			return ConsumeTokenResult.Success;
		}

		private bool SkipAllCommentsMultiSegment(scoped ref byte marker)
		{
			while (true)
			{
				if (marker == 47)
				{
					if (!SkipOrConsumeCommentMultiSegmentWithRollback() || !HasMoreDataMultiSegment())
					{
						break;
					}
					marker = _buffer[_consumed];
					if (marker <= 32)
					{
						SkipWhiteSpaceMultiSegment();
						if (!HasMoreDataMultiSegment())
						{
							break;
						}
						marker = _buffer[_consumed];
					}
					continue;
				}
				return true;
			}
			return false;
		}

		private bool SkipAllCommentsMultiSegment(scoped ref byte marker, ExceptionResource resource)
		{
			while (true)
			{
				if (marker == 47)
				{
					if (!SkipOrConsumeCommentMultiSegmentWithRollback() || !HasMoreDataMultiSegment(resource))
					{
						break;
					}
					marker = _buffer[_consumed];
					if (marker <= 32)
					{
						SkipWhiteSpaceMultiSegment();
						if (!HasMoreDataMultiSegment(resource))
						{
							break;
						}
						marker = _buffer[_consumed];
					}
					continue;
				}
				return true;
			}
			return false;
		}

		private ConsumeTokenResult ConsumeNextTokenUntilAfterAllCommentsAreSkippedMultiSegment(byte marker)
		{
			if (SkipAllCommentsMultiSegment(ref marker))
			{
				TokenStartIndex = BytesConsumed;
				if (_tokenType == JsonTokenType.StartObject)
				{
					if (marker == 125)
					{
						EndObject();
					}
					else
					{
						if (marker != 34)
						{
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, marker);
						}
						long totalConsumed = _totalConsumed;
						int consumed = _consumed;
						long bytePositionInLine = _bytePositionInLine;
						long lineNumber = _lineNumber;
						SequencePosition currentPosition = _currentPosition;
						if (!ConsumePropertyNameMultiSegment())
						{
							_consumed = consumed;
							_tokenType = JsonTokenType.StartObject;
							_bytePositionInLine = bytePositionInLine;
							_lineNumber = lineNumber;
							_totalConsumed = totalConsumed;
							_currentPosition = currentPosition;
							goto IL_02e7;
						}
					}
				}
				else if (_tokenType == JsonTokenType.StartArray)
				{
					if (marker == 93)
					{
						EndArray();
					}
					else if (!ConsumeValueMultiSegment(marker))
					{
						goto IL_02e7;
					}
				}
				else if (_tokenType == JsonTokenType.PropertyName)
				{
					if (!ConsumeValueMultiSegment(marker))
					{
						goto IL_02e7;
					}
				}
				else if (_bitStack.CurrentDepth == 0)
				{
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndAfterSingleJson, marker);
				}
				else
				{
					switch (marker)
					{
					case 44:
						_consumed++;
						_bytePositionInLine++;
						if (_consumed >= (uint)_buffer.Length)
						{
							if (IsLastSpan)
							{
								_consumed--;
								_bytePositionInLine--;
								ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
							}
							if (!GetNextSpan())
							{
								if (IsLastSpan)
								{
									_consumed--;
									_bytePositionInLine--;
									ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
								}
								return ConsumeTokenResult.NotEnoughDataRollBackState;
							}
						}
						marker = _buffer[_consumed];
						if (marker <= 32)
						{
							SkipWhiteSpaceMultiSegment();
							if (!HasMoreDataMultiSegment(ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
							{
								return ConsumeTokenResult.NotEnoughDataRollBackState;
							}
							marker = _buffer[_consumed];
						}
						if (SkipAllCommentsMultiSegment(ref marker, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
						{
							TokenStartIndex = BytesConsumed;
							if (_inObject)
							{
								if (marker != 34)
								{
									if (marker == 125)
									{
										if (_readerOptions.AllowTrailingCommas)
										{
											EndObject();
											break;
										}
										ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd, 0);
									}
									ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, marker);
								}
								if (!ConsumePropertyNameMultiSegment())
								{
									return ConsumeTokenResult.NotEnoughDataRollBackState;
								}
								return ConsumeTokenResult.Success;
							}
							if (marker == 93)
							{
								if (_readerOptions.AllowTrailingCommas)
								{
									EndArray();
									break;
								}
								ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd, 0);
							}
							if (!ConsumeValueMultiSegment(marker))
							{
								return ConsumeTokenResult.NotEnoughDataRollBackState;
							}
							return ConsumeTokenResult.Success;
						}
						return ConsumeTokenResult.NotEnoughDataRollBackState;
					case 125:
						EndObject();
						break;
					case 93:
						EndArray();
						break;
					default:
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.FoundInvalidCharacter, marker);
						break;
					}
				}
				return ConsumeTokenResult.Success;
			}
			goto IL_02e7;
			IL_02e7:
			return ConsumeTokenResult.IncompleteNoRollBackNecessary;
		}

		private bool SkipOrConsumeCommentMultiSegmentWithRollback()
		{
			long bytesConsumed = BytesConsumed;
			SequencePosition start = new SequencePosition(_currentPosition.GetObject(), _currentPosition.GetInteger() + _consumed);
			int tailBytesToIgnore;
			bool flag = SkipCommentMultiSegment(out tailBytesToIgnore);
			if (flag)
			{
				if (_readerOptions.CommentHandling == JsonCommentHandling.Allow)
				{
					SequencePosition end = new SequencePosition(_currentPosition.GetObject(), _currentPosition.GetInteger() + _consumed);
					ReadOnlySequence<byte> readOnlySequence = _sequence.Slice(start, end);
					readOnlySequence = readOnlySequence.Slice(2L, readOnlySequence.Length - 2 - tailBytesToIgnore);
					HasValueSequence = !readOnlySequence.IsSingleSegment;
					if (HasValueSequence)
					{
						ValueSequence = readOnlySequence;
					}
					else
					{
						ValueSpan = readOnlySequence.First.Span;
					}
					if (_tokenType != JsonTokenType.Comment)
					{
						_previousTokenType = _tokenType;
					}
					_tokenType = JsonTokenType.Comment;
				}
			}
			else
			{
				_totalConsumed = bytesConsumed;
				_consumed = 0;
			}
			return flag;
		}

		private bool SkipCommentMultiSegment(out int tailBytesToIgnore)
		{
			_consumed++;
			_bytePositionInLine++;
			ReadOnlySpan<byte> localBuffer = _buffer.Slice(_consumed);
			if (localBuffer.Length == 0)
			{
				if (IsLastSpan)
				{
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfDataWhileReadingComment, 0);
				}
				if (!GetNextSpan())
				{
					if (IsLastSpan)
					{
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfDataWhileReadingComment, 0);
					}
					tailBytesToIgnore = 0;
					return false;
				}
				localBuffer = _buffer;
			}
			byte b = localBuffer[0];
			if (b != 47 && b != 42)
			{
				ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterAtStartOfComment, b);
			}
			bool flag = b == 42;
			_consumed++;
			_bytePositionInLine++;
			localBuffer = localBuffer.Slice(1);
			if (localBuffer.Length == 0)
			{
				if (IsLastSpan)
				{
					tailBytesToIgnore = 0;
					if (flag)
					{
						ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfDataWhileReadingComment, 0);
					}
					return true;
				}
				if (!GetNextSpan())
				{
					tailBytesToIgnore = 0;
					if (IsLastSpan)
					{
						if (flag)
						{
							ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfDataWhileReadingComment, 0);
						}
						return true;
					}
					return false;
				}
				localBuffer = _buffer;
			}
			if (flag)
			{
				tailBytesToIgnore = 2;
				return SkipMultiLineCommentMultiSegment(localBuffer);
			}
			return SkipSingleLineCommentMultiSegment(localBuffer, out tailBytesToIgnore);
		}

		private bool SkipSingleLineCommentMultiSegment(ReadOnlySpan<byte> localBuffer, out int tailBytesToSkip)
		{
			bool flag = false;
			int dangerousLineSeparatorBytesConsumed = 0;
			tailBytesToSkip = 0;
			while (true)
			{
				if (flag)
				{
					if (localBuffer[0] == 10)
					{
						tailBytesToSkip++;
						_consumed++;
					}
					break;
				}
				int num = FindLineSeparatorMultiSegment(localBuffer, ref dangerousLineSeparatorBytesConsumed);
				if (num != -1)
				{
					tailBytesToSkip++;
					_consumed += num + 1;
					_bytePositionInLine += num + 1;
					if (localBuffer[num] == 10)
					{
						break;
					}
					if (num < localBuffer.Length - 1)
					{
						if (localBuffer[num + 1] == 10)
						{
							tailBytesToSkip++;
							_consumed++;
							_bytePositionInLine++;
						}
						break;
					}
					flag = true;
				}
				else
				{
					_consumed += localBuffer.Length;
					_bytePositionInLine += localBuffer.Length;
				}
				if (IsLastSpan)
				{
					if (flag)
					{
						break;
					}
					return true;
				}
				if (!GetNextSpan())
				{
					if (IsLastSpan)
					{
						if (flag)
						{
							break;
						}
						return true;
					}
					return false;
				}
				localBuffer = _buffer;
			}
			_bytePositionInLine = 0L;
			_lineNumber++;
			return true;
		}

		private int FindLineSeparatorMultiSegment(ReadOnlySpan<byte> localBuffer, scoped ref int dangerousLineSeparatorBytesConsumed)
		{
			if (dangerousLineSeparatorBytesConsumed != 0)
			{
				ThrowOnDangerousLineSeparatorMultiSegment(localBuffer, ref dangerousLineSeparatorBytesConsumed);
				if (dangerousLineSeparatorBytesConsumed != 0)
				{
					return -1;
				}
			}
			int num = 0;
			do
			{
				int num2 = localBuffer.IndexOfAny<byte>(10, 13, 226);
				dangerousLineSeparatorBytesConsumed = 0;
				if (num2 == -1)
				{
					return -1;
				}
				if (localBuffer[num2] != 226)
				{
					return num + num2;
				}
				int num3 = num2 + 1;
				localBuffer = localBuffer.Slice(num3);
				num += num3;
				dangerousLineSeparatorBytesConsumed++;
				ThrowOnDangerousLineSeparatorMultiSegment(localBuffer, ref dangerousLineSeparatorBytesConsumed);
			}
			while (dangerousLineSeparatorBytesConsumed == 0);
			return -1;
		}

		private void ThrowOnDangerousLineSeparatorMultiSegment(ReadOnlySpan<byte> localBuffer, scoped ref int dangerousLineSeparatorBytesConsumed)
		{
			if (localBuffer.IsEmpty)
			{
				return;
			}
			if (dangerousLineSeparatorBytesConsumed == 1)
			{
				if (localBuffer[0] != 128)
				{
					dangerousLineSeparatorBytesConsumed = 0;
					return;
				}
				localBuffer = localBuffer.Slice(1);
				dangerousLineSeparatorBytesConsumed++;
				if (localBuffer.IsEmpty)
				{
					return;
				}
			}
			if (dangerousLineSeparatorBytesConsumed == 2)
			{
				byte b = localBuffer[0];
				if (b == 168 || b == 169)
				{
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfLineSeparator, 0);
				}
				else
				{
					dangerousLineSeparatorBytesConsumed = 0;
				}
			}
		}

		private bool SkipMultiLineCommentMultiSegment(ReadOnlySpan<byte> localBuffer)
		{
			bool flag = false;
			bool flag2 = false;
			while (true)
			{
				if (flag)
				{
					if (localBuffer[0] == 47)
					{
						_consumed++;
						_bytePositionInLine++;
						return true;
					}
					flag = false;
				}
				if (flag2)
				{
					if (localBuffer[0] == 10)
					{
						_consumed++;
						localBuffer = localBuffer.Slice(1);
					}
					flag2 = false;
				}
				int num = localBuffer.IndexOfAny<byte>(42, 10, 13);
				if (num != -1)
				{
					int num2 = num + 1;
					byte b = localBuffer[num];
					localBuffer = localBuffer.Slice(num2);
					_consumed += num2;
					switch (b)
					{
					case 42:
						flag = true;
						_bytePositionInLine += num2;
						break;
					case 10:
						_bytePositionInLine = 0L;
						_lineNumber++;
						break;
					default:
						_bytePositionInLine = 0L;
						_lineNumber++;
						flag2 = true;
						break;
					}
				}
				else
				{
					_consumed += localBuffer.Length;
					_bytePositionInLine += localBuffer.Length;
					localBuffer = ReadOnlySpan<byte>.Empty;
				}
				if (!localBuffer.IsEmpty)
				{
					continue;
				}
				if (IsLastSpan)
				{
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfDataWhileReadingComment, 0);
				}
				if (!GetNextSpan())
				{
					if (!IsLastSpan)
					{
						break;
					}
					ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfDataWhileReadingComment, 0);
				}
				localBuffer = _buffer;
			}
			return false;
		}

		private PartialStateForRollback CaptureState()
		{
			return new PartialStateForRollback(_totalConsumed, _bytePositionInLine, _consumed, _currentPosition);
		}

		public string? GetString()
		{
			if (TokenType == JsonTokenType.Null)
			{
				return null;
			}
			if (TokenType != JsonTokenType.String && TokenType != JsonTokenType.PropertyName)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedString(TokenType);
			}
			ReadOnlySpan<byte> readOnlySpan = (HasValueSequence ? ((ReadOnlySpan<byte>)ValueSequence.ToArray<byte>()) : ValueSpan);
			if (ValueIsEscaped)
			{
				return JsonReaderHelper.GetUnescapedString(readOnlySpan);
			}
			return JsonReaderHelper.TranscodeHelper(readOnlySpan);
		}

		public readonly int CopyString(Span<byte> utf8Destination)
		{
			JsonTokenType tokenType = _tokenType;
			if ((tokenType != JsonTokenType.PropertyName && tokenType != JsonTokenType.String) || 1 == 0)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedString(_tokenType);
			}
			return CopyValue(utf8Destination);
		}

		internal readonly int CopyValue(Span<byte> utf8Destination)
		{
			int bytesWritten;
			if (ValueIsEscaped)
			{
				if (!TryCopyEscapedString(utf8Destination, out bytesWritten))
				{
					utf8Destination.Slice(0, bytesWritten).Clear();
					ThrowHelper.ThrowArgumentException_DestinationTooShort();
				}
			}
			else if (HasValueSequence)
			{
				ReadOnlySequence<byte> source = ValueSequence;
				source.CopyTo(utf8Destination);
				bytesWritten = (int)source.Length;
			}
			else
			{
				ReadOnlySpan<byte> valueSpan = ValueSpan;
				valueSpan.CopyTo(utf8Destination);
				bytesWritten = valueSpan.Length;
			}
			JsonReaderHelper.ValidateUtf8(utf8Destination.Slice(0, bytesWritten));
			return bytesWritten;
		}

		public readonly int CopyString(Span<char> destination)
		{
			JsonTokenType tokenType = _tokenType;
			if ((tokenType != JsonTokenType.PropertyName && tokenType != JsonTokenType.String) || 1 == 0)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedString(_tokenType);
			}
			return CopyValue(destination);
		}

		internal readonly int CopyValue(Span<char> destination)
		{
			byte[] array = null;
			ReadOnlySpan<byte> utf8Unescaped;
			if (ValueIsEscaped)
			{
				int valueLength = ValueLength;
				Span<byte> span = ((valueLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(valueLength))) : stackalloc byte[256]);
				Span<byte> destination2 = span;
				int bytesWritten;
				bool flag = TryCopyEscapedString(destination2, out bytesWritten);
				utf8Unescaped = destination2.Slice(0, bytesWritten);
			}
			else if (HasValueSequence)
			{
				ReadOnlySequence<byte> source = ValueSequence;
				int valueLength = checked((int)source.Length);
				Span<byte> span2 = ((valueLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(valueLength))) : stackalloc byte[256]);
				Span<byte> destination3 = span2;
				source.CopyTo(destination3);
				utf8Unescaped = destination3.Slice(0, valueLength);
			}
			else
			{
				utf8Unescaped = ValueSpan;
			}
			int result = JsonReaderHelper.TranscodeHelper(utf8Unescaped, destination);
			if (array != null)
			{
				new Span<byte>(array, 0, utf8Unescaped.Length).Clear();
				ArrayPool<byte>.Shared.Return(array);
			}
			return result;
		}

		private readonly bool TryCopyEscapedString(Span<byte> destination, out int bytesWritten)
		{
			byte[] array = null;
			ReadOnlySpan<byte> source2;
			if (HasValueSequence)
			{
				ReadOnlySequence<byte> source = ValueSequence;
				int num = checked((int)source.Length);
				Span<byte> span = ((num > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(num))) : stackalloc byte[256]);
				Span<byte> destination2 = span;
				source.CopyTo(destination2);
				source2 = destination2.Slice(0, num);
			}
			else
			{
				source2 = ValueSpan;
			}
			bool result = JsonReaderHelper.TryUnescape(source2, destination, out bytesWritten);
			if (array != null)
			{
				new Span<byte>(array, 0, source2.Length).Clear();
				ArrayPool<byte>.Shared.Return(array);
			}
			return result;
		}

		public string GetComment()
		{
			if (TokenType != JsonTokenType.Comment)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedComment(TokenType);
			}
			ReadOnlySpan<byte> utf8Unescaped = (HasValueSequence ? ((ReadOnlySpan<byte>)ValueSequence.ToArray<byte>()) : ValueSpan);
			return JsonReaderHelper.TranscodeHelper(utf8Unescaped);
		}

		public bool GetBoolean()
		{
			switch (TokenType)
			{
			case JsonTokenType.True:
				return true;
			default:
				ThrowHelper.ThrowInvalidOperationException_ExpectedBoolean(TokenType);
				break;
			case JsonTokenType.False:
				break;
			}
			return false;
		}

		public byte[] GetBytesFromBase64()
		{
			if (!TryGetBytesFromBase64(out byte[] value))
			{
				ThrowHelper.ThrowFormatException(DataType.Base64String);
			}
			return value;
		}

		public byte GetByte()
		{
			if (!TryGetByte(out var value))
			{
				ThrowHelper.ThrowFormatException(NumericType.Byte);
			}
			return value;
		}

		internal byte GetByteWithQuotes()
		{
			ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
			if (!TryGetByteCore(out var value, unescapedSpan))
			{
				ThrowHelper.ThrowFormatException(NumericType.Byte);
			}
			return value;
		}

		[CLSCompliant(false)]
		public sbyte GetSByte()
		{
			if (!TryGetSByte(out var value))
			{
				ThrowHelper.ThrowFormatException(NumericType.SByte);
			}
			return value;
		}

		internal sbyte GetSByteWithQuotes()
		{
			ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
			if (!TryGetSByteCore(out var value, unescapedSpan))
			{
				ThrowHelper.ThrowFormatException(NumericType.SByte);
			}
			return value;
		}

		public short GetInt16()
		{
			if (!TryGetInt16(out var value))
			{
				ThrowHelper.ThrowFormatException(NumericType.Int16);
			}
			return value;
		}

		internal short GetInt16WithQuotes()
		{
			ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
			if (!TryGetInt16Core(out var value, unescapedSpan))
			{
				ThrowHelper.ThrowFormatException(NumericType.Int16);
			}
			return value;
		}

		public int GetInt32()
		{
			if (!TryGetInt32(out var value))
			{
				ThrowHelper.ThrowFormatException(NumericType.Int32);
			}
			return value;
		}

		internal int GetInt32WithQuotes()
		{
			ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
			if (!TryGetInt32Core(out var value, unescapedSpan))
			{
				ThrowHelper.ThrowFormatException(NumericType.Int32);
			}
			return value;
		}

		public long GetInt64()
		{
			if (!TryGetInt64(out var value))
			{
				ThrowHelper.ThrowFormatException(NumericType.Int64);
			}
			return value;
		}

		internal long GetInt64WithQuotes()
		{
			ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
			if (!TryGetInt64Core(out var value, unescapedSpan))
			{
				ThrowHelper.ThrowFormatException(NumericType.Int64);
			}
			return value;
		}

		[CLSCompliant(false)]
		public ushort GetUInt16()
		{
			if (!TryGetUInt16(out var value))
			{
				ThrowHelper.ThrowFormatException(NumericType.UInt16);
			}
			return value;
		}

		internal ushort GetUInt16WithQuotes()
		{
			ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
			if (!TryGetUInt16Core(out var value, unescapedSpan))
			{
				ThrowHelper.ThrowFormatException(NumericType.UInt16);
			}
			return value;
		}

		[CLSCompliant(false)]
		public uint GetUInt32()
		{
			if (!TryGetUInt32(out var value))
			{
				ThrowHelper.ThrowFormatException(NumericType.UInt32);
			}
			return value;
		}

		internal uint GetUInt32WithQuotes()
		{
			ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
			if (!TryGetUInt32Core(out var value, unescapedSpan))
			{
				ThrowHelper.ThrowFormatException(NumericType.UInt32);
			}
			return value;
		}

		[CLSCompliant(false)]
		public ulong GetUInt64()
		{
			if (!TryGetUInt64(out var value))
			{
				ThrowHelper.ThrowFormatException(NumericType.UInt64);
			}
			return value;
		}

		internal ulong GetUInt64WithQuotes()
		{
			ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
			if (!TryGetUInt64Core(out var value, unescapedSpan))
			{
				ThrowHelper.ThrowFormatException(NumericType.UInt64);
			}
			return value;
		}

		public float GetSingle()
		{
			if (!TryGetSingle(out var value))
			{
				ThrowHelper.ThrowFormatException(NumericType.Single);
			}
			return value;
		}

		internal float GetSingleWithQuotes()
		{
			ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
			if (JsonReaderHelper.TryGetFloatingPointConstant(unescapedSpan, out float value))
			{
				return value;
			}
			if (!Utf8Parser.TryParse(unescapedSpan, out value, out int bytesConsumed, '\0') || unescapedSpan.Length != bytesConsumed || !JsonHelpers.IsFinite(value))
			{
				ThrowHelper.ThrowFormatException(NumericType.Single);
			}
			return value;
		}

		internal float GetSingleFloatingPointConstant()
		{
			ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
			if (!JsonReaderHelper.TryGetFloatingPointConstant(unescapedSpan, out float value))
			{
				ThrowHelper.ThrowFormatException(NumericType.Single);
			}
			return value;
		}

		public double GetDouble()
		{
			if (!TryGetDouble(out var value))
			{
				ThrowHelper.ThrowFormatException(NumericType.Double);
			}
			return value;
		}

		internal double GetDoubleWithQuotes()
		{
			ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
			if (JsonReaderHelper.TryGetFloatingPointConstant(unescapedSpan, out double value))
			{
				return value;
			}
			if (!Utf8Parser.TryParse(unescapedSpan, out value, out int bytesConsumed, '\0') || unescapedSpan.Length != bytesConsumed || !JsonHelpers.IsFinite(value))
			{
				ThrowHelper.ThrowFormatException(NumericType.Double);
			}
			return value;
		}

		internal double GetDoubleFloatingPointConstant()
		{
			ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
			if (!JsonReaderHelper.TryGetFloatingPointConstant(unescapedSpan, out double value))
			{
				ThrowHelper.ThrowFormatException(NumericType.Double);
			}
			return value;
		}

		public decimal GetDecimal()
		{
			if (!TryGetDecimal(out var value))
			{
				ThrowHelper.ThrowFormatException(NumericType.Decimal);
			}
			return value;
		}

		internal decimal GetDecimalWithQuotes()
		{
			ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
			if (!TryGetDecimalCore(out var value, unescapedSpan))
			{
				ThrowHelper.ThrowFormatException(NumericType.Decimal);
			}
			return value;
		}

		public DateTime GetDateTime()
		{
			if (!TryGetDateTime(out var value))
			{
				ThrowHelper.ThrowFormatException(DataType.DateTime);
			}
			return value;
		}

		internal DateTime GetDateTimeNoValidation()
		{
			if (!TryGetDateTimeCore(out var value))
			{
				ThrowHelper.ThrowFormatException(DataType.DateTime);
			}
			return value;
		}

		public DateTimeOffset GetDateTimeOffset()
		{
			if (!TryGetDateTimeOffset(out var value))
			{
				ThrowHelper.ThrowFormatException(DataType.DateTimeOffset);
			}
			return value;
		}

		internal DateTimeOffset GetDateTimeOffsetNoValidation()
		{
			if (!TryGetDateTimeOffsetCore(out var value))
			{
				ThrowHelper.ThrowFormatException(DataType.DateTimeOffset);
			}
			return value;
		}

		public Guid GetGuid()
		{
			if (!TryGetGuid(out var value))
			{
				ThrowHelper.ThrowFormatException(DataType.Guid);
			}
			return value;
		}

		internal Guid GetGuidNoValidation()
		{
			if (!TryGetGuidCore(out var value))
			{
				ThrowHelper.ThrowFormatException(DataType.Guid);
			}
			return value;
		}

		public bool TryGetBytesFromBase64([NotNullWhen(true)] out byte[]? value)
		{
			if (TokenType != JsonTokenType.String)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedString(TokenType);
			}
			ReadOnlySpan<byte> readOnlySpan = (HasValueSequence ? ((ReadOnlySpan<byte>)ValueSequence.ToArray<byte>()) : ValueSpan);
			if (ValueIsEscaped)
			{
				return JsonReaderHelper.TryGetUnescapedBase64Bytes(readOnlySpan, out value);
			}
			return JsonReaderHelper.TryDecodeBase64(readOnlySpan, out value);
		}

		public bool TryGetByte(out byte value)
		{
			if (TokenType != JsonTokenType.Number)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
			}
			ReadOnlySpan<byte> span = (HasValueSequence ? ((ReadOnlySpan<byte>)ValueSequence.ToArray<byte>()) : ValueSpan);
			return TryGetByteCore(out value, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool TryGetByteCore(out byte value, ReadOnlySpan<byte> span)
		{
			if (Utf8Parser.TryParse(span, out byte value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
			{
				value = value2;
				return true;
			}
			value = 0;
			return false;
		}

		[CLSCompliant(false)]
		public bool TryGetSByte(out sbyte value)
		{
			if (TokenType != JsonTokenType.Number)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
			}
			ReadOnlySpan<byte> span = (HasValueSequence ? ((ReadOnlySpan<byte>)ValueSequence.ToArray<byte>()) : ValueSpan);
			return TryGetSByteCore(out value, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool TryGetSByteCore(out sbyte value, ReadOnlySpan<byte> span)
		{
			if (Utf8Parser.TryParse(span, out sbyte value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
			{
				value = value2;
				return true;
			}
			value = 0;
			return false;
		}

		public bool TryGetInt16(out short value)
		{
			if (TokenType != JsonTokenType.Number)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
			}
			ReadOnlySpan<byte> span = (HasValueSequence ? ((ReadOnlySpan<byte>)ValueSequence.ToArray<byte>()) : ValueSpan);
			return TryGetInt16Core(out value, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool TryGetInt16Core(out short value, ReadOnlySpan<byte> span)
		{
			if (Utf8Parser.TryParse(span, out short value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
			{
				value = value2;
				return true;
			}
			value = 0;
			return false;
		}

		public bool TryGetInt32(out int value)
		{
			if (TokenType != JsonTokenType.Number)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
			}
			ReadOnlySpan<byte> span = (HasValueSequence ? ((ReadOnlySpan<byte>)ValueSequence.ToArray<byte>()) : ValueSpan);
			return TryGetInt32Core(out value, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool TryGetInt32Core(out int value, ReadOnlySpan<byte> span)
		{
			if (Utf8Parser.TryParse(span, out int value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
			{
				value = value2;
				return true;
			}
			value = 0;
			return false;
		}

		public bool TryGetInt64(out long value)
		{
			if (TokenType != JsonTokenType.Number)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
			}
			ReadOnlySpan<byte> span = (HasValueSequence ? ((ReadOnlySpan<byte>)ValueSequence.ToArray<byte>()) : ValueSpan);
			return TryGetInt64Core(out value, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool TryGetInt64Core(out long value, ReadOnlySpan<byte> span)
		{
			if (Utf8Parser.TryParse(span, out long value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
			{
				value = value2;
				return true;
			}
			value = 0L;
			return false;
		}

		[CLSCompliant(false)]
		public bool TryGetUInt16(out ushort value)
		{
			if (TokenType != JsonTokenType.Number)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
			}
			ReadOnlySpan<byte> span = (HasValueSequence ? ((ReadOnlySpan<byte>)ValueSequence.ToArray<byte>()) : ValueSpan);
			return TryGetUInt16Core(out value, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool TryGetUInt16Core(out ushort value, ReadOnlySpan<byte> span)
		{
			if (Utf8Parser.TryParse(span, out ushort value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
			{
				value = value2;
				return true;
			}
			value = 0;
			return false;
		}

		[CLSCompliant(false)]
		public bool TryGetUInt32(out uint value)
		{
			if (TokenType != JsonTokenType.Number)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
			}
			ReadOnlySpan<byte> span = (HasValueSequence ? ((ReadOnlySpan<byte>)ValueSequence.ToArray<byte>()) : ValueSpan);
			return TryGetUInt32Core(out value, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool TryGetUInt32Core(out uint value, ReadOnlySpan<byte> span)
		{
			if (Utf8Parser.TryParse(span, out uint value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
			{
				value = value2;
				return true;
			}
			value = 0u;
			return false;
		}

		[CLSCompliant(false)]
		public bool TryGetUInt64(out ulong value)
		{
			if (TokenType != JsonTokenType.Number)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
			}
			ReadOnlySpan<byte> span = (HasValueSequence ? ((ReadOnlySpan<byte>)ValueSequence.ToArray<byte>()) : ValueSpan);
			return TryGetUInt64Core(out value, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool TryGetUInt64Core(out ulong value, ReadOnlySpan<byte> span)
		{
			if (Utf8Parser.TryParse(span, out ulong value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
			{
				value = value2;
				return true;
			}
			value = 0uL;
			return false;
		}

		public bool TryGetSingle(out float value)
		{
			if (TokenType != JsonTokenType.Number)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
			}
			ReadOnlySpan<byte> source = (HasValueSequence ? ((ReadOnlySpan<byte>)ValueSequence.ToArray<byte>()) : ValueSpan);
			if (Utf8Parser.TryParse(source, out float value2, out int bytesConsumed, '\0') && source.Length == bytesConsumed)
			{
				value = value2;
				return true;
			}
			value = 0f;
			return false;
		}

		public bool TryGetDouble(out double value)
		{
			if (TokenType != JsonTokenType.Number)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
			}
			ReadOnlySpan<byte> source = (HasValueSequence ? ((ReadOnlySpan<byte>)ValueSequence.ToArray<byte>()) : ValueSpan);
			if (Utf8Parser.TryParse(source, out double value2, out int bytesConsumed, '\0') && source.Length == bytesConsumed)
			{
				value = value2;
				return true;
			}
			value = 0.0;
			return false;
		}

		public bool TryGetDecimal(out decimal value)
		{
			if (TokenType != JsonTokenType.Number)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
			}
			ReadOnlySpan<byte> span = (HasValueSequence ? ((ReadOnlySpan<byte>)ValueSequence.ToArray<byte>()) : ValueSpan);
			return TryGetDecimalCore(out value, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool TryGetDecimalCore(out decimal value, ReadOnlySpan<byte> span)
		{
			if (Utf8Parser.TryParse(span, out decimal value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
			{
				value = value2;
				return true;
			}
			value = default(decimal);
			return false;
		}

		public bool TryGetDateTime(out DateTime value)
		{
			if (TokenType != JsonTokenType.String)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedString(TokenType);
			}
			return TryGetDateTimeCore(out value);
		}

		internal bool TryGetDateTimeCore(out DateTime value)
		{
			ReadOnlySpan<byte> source;
			if (HasValueSequence)
			{
				long length = ValueSequence.Length;
				if (!JsonHelpers.IsInRangeInclusive(length, 10L, 252L))
				{
					value = default(DateTime);
					return false;
				}
				Span<byte> destination = stackalloc byte[252];
				ValueSequence.CopyTo(destination);
				source = destination.Slice(0, (int)length);
			}
			else
			{
				if (!JsonHelpers.IsInRangeInclusive(ValueSpan.Length, 10, 252))
				{
					value = default(DateTime);
					return false;
				}
				source = ValueSpan;
			}
			if (ValueIsEscaped)
			{
				return JsonReaderHelper.TryGetEscapedDateTime(source, out value);
			}
			if (JsonHelpers.TryParseAsISO(source, out DateTime value2))
			{
				value = value2;
				return true;
			}
			value = default(DateTime);
			return false;
		}

		public bool TryGetDateTimeOffset(out DateTimeOffset value)
		{
			if (TokenType != JsonTokenType.String)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedString(TokenType);
			}
			return TryGetDateTimeOffsetCore(out value);
		}

		internal bool TryGetDateTimeOffsetCore(out DateTimeOffset value)
		{
			ReadOnlySpan<byte> source;
			if (HasValueSequence)
			{
				long length = ValueSequence.Length;
				if (!JsonHelpers.IsInRangeInclusive(length, 10L, 252L))
				{
					value = default(DateTimeOffset);
					return false;
				}
				Span<byte> destination = stackalloc byte[252];
				ValueSequence.CopyTo(destination);
				source = destination.Slice(0, (int)length);
			}
			else
			{
				if (!JsonHelpers.IsInRangeInclusive(ValueSpan.Length, 10, 252))
				{
					value = default(DateTimeOffset);
					return false;
				}
				source = ValueSpan;
			}
			if (ValueIsEscaped)
			{
				return JsonReaderHelper.TryGetEscapedDateTimeOffset(source, out value);
			}
			if (JsonHelpers.TryParseAsISO(source, out DateTimeOffset value2))
			{
				value = value2;
				return true;
			}
			value = default(DateTimeOffset);
			return false;
		}

		public bool TryGetGuid(out Guid value)
		{
			if (TokenType != JsonTokenType.String)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedString(TokenType);
			}
			return TryGetGuidCore(out value);
		}

		internal bool TryGetGuidCore(out Guid value)
		{
			ReadOnlySpan<byte> source;
			if (HasValueSequence)
			{
				long length = ValueSequence.Length;
				if (length > 216)
				{
					value = default(Guid);
					return false;
				}
				Span<byte> destination = stackalloc byte[216];
				ValueSequence.CopyTo(destination);
				source = destination.Slice(0, (int)length);
			}
			else
			{
				if (ValueSpan.Length > 216)
				{
					value = default(Guid);
					return false;
				}
				source = ValueSpan;
			}
			if (ValueIsEscaped)
			{
				return JsonReaderHelper.TryGetEscapedGuid(source, out value);
			}
			if (source.Length == 36 && Utf8Parser.TryParse(source, out Guid value2, out int _, 'D'))
			{
				value = value2;
				return true;
			}
			value = default(Guid);
			return false;
		}
	}
	internal sealed class Arguments<TArg0, TArg1, TArg2, TArg3>
	{
		public TArg0 Arg0;

		public TArg1 Arg1;

		public TArg2 Arg2;

		public TArg3 Arg3;
	}
	internal sealed class ArgumentState
	{
		public object Arguments;

		public (JsonPropertyInfo, JsonReaderState, long, byte[], string)[] FoundProperties;

		public (JsonPropertyInfo, object, string)[] FoundPropertiesAsync;

		public int FoundPropertyCount;

		public JsonParameterInfo JsonParameterInfo;

		public int ParameterIndex;

		public List<ParameterRef> ParameterRefCache;
	}
	public static class JsonSerializer
	{
		internal const string SerializationUnreferencedCodeMessage = "JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.";

		internal const string SerializationRequiresDynamicCodeMessage = "JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.";

		internal const string IdPropertyName = "$id";

		internal const string RefPropertyName = "$ref";

		internal const string TypePropertyName = "$type";

		internal const string ValuesPropertyName = "$values";

		private static readonly byte[] s_idPropertyName = "$id"u8.ToArray();

		private static readonly byte[] s_refPropertyName = "$ref"u8.ToArray();

		private static readonly byte[] s_typePropertyName = "$type"u8.ToArray();

		private static readonly byte[] s_valuesPropertyName = "$values"u8.ToArray();

		internal static readonly JsonEncodedText s_metadataId = JsonEncodedText.Encode("$id");

		internal static readonly JsonEncodedText s_metadataRef = JsonEncodedText.Encode("$ref");

		internal static readonly JsonEncodedText s_metadataType = JsonEncodedText.Encode("$type");

		internal static readonly JsonEncodedText s_metadataValues = JsonEncodedText.Encode("$values");

		internal const float FlushThreshold = 0.9f;

		public static bool IsReflectionEnabledByDefault { get; } = !AppContext.TryGetSwitch("System.Text.Json.JsonSerializer.IsReflectionEnabledByDefault", out var isEnabled) || isEnabled;

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static TValue? Deserialize<TValue>(this JsonDocument document, JsonSerializerOptions? options = null)
		{
			if (document == null)
			{
				ThrowHelper.ThrowArgumentNullException("document");
			}
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			ReadOnlySpan<byte> span = document.GetRootRawValue().Span;
			return ReadFromSpan(span, typeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static object? Deserialize(this JsonDocument document, Type returnType, JsonSerializerOptions? options = null)
		{
			if (document == null)
			{
				ThrowHelper.ThrowArgumentNullException("document");
			}
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
			ReadOnlySpan<byte> span = document.GetRootRawValue().Span;
			return ReadFromSpanAsObject(span, typeInfo);
		}

		public static TValue? Deserialize<TValue>(this JsonDocument document, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (document == null)
			{
				ThrowHelper.ThrowArgumentNullException("document");
			}
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			ReadOnlySpan<byte> span = document.GetRootRawValue().Span;
			return ReadFromSpan(span, jsonTypeInfo);
		}

		public static object? Deserialize(this JsonDocument document, JsonTypeInfo jsonTypeInfo)
		{
			if (document == null)
			{
				ThrowHelper.ThrowArgumentNullException("document");
			}
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			ReadOnlySpan<byte> span = document.GetRootRawValue().Span;
			return ReadFromSpanAsObject(span, jsonTypeInfo);
		}

		public static object? Deserialize(this JsonDocument document, Type returnType, JsonSerializerContext context)
		{
			if (document == null)
			{
				ThrowHelper.ThrowArgumentNullException("document");
			}
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(context, returnType);
			ReadOnlySpan<byte> span = document.GetRootRawValue().Span;
			return ReadFromSpanAsObject(span, typeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static TValue? Deserialize<TValue>(this JsonElement element, JsonSerializerOptions? options = null)
		{
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			ReadOnlySpan<byte> span = element.GetRawValue().Span;
			return ReadFromSpan(span, typeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static object? Deserialize(this JsonElement element, Type returnType, JsonSerializerOptions? options = null)
		{
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
			ReadOnlySpan<byte> span = element.GetRawValue().Span;
			return ReadFromSpanAsObject(span, typeInfo);
		}

		public static TValue? Deserialize<TValue>(this JsonElement element, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			ReadOnlySpan<byte> span = element.GetRawValue().Span;
			return ReadFromSpan(span, jsonTypeInfo);
		}

		public static object? Deserialize(this JsonElement element, JsonTypeInfo jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			ReadOnlySpan<byte> span = element.GetRawValue().Span;
			return ReadFromSpanAsObject(span, jsonTypeInfo);
		}

		public static object? Deserialize(this JsonElement element, Type returnType, JsonSerializerContext context)
		{
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(context, returnType);
			ReadOnlySpan<byte> span = element.GetRawValue().Span;
			return ReadFromSpanAsObject(span, typeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static TValue? Deserialize<TValue>(this JsonNode? node, JsonSerializerOptions? options = null)
		{
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			return ReadFromNode(node, typeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static object? Deserialize(this JsonNode? node, Type returnType, JsonSerializerOptions? options = null)
		{
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
			return ReadFromNodeAsObject(node, typeInfo);
		}

		public static TValue? Deserialize<TValue>(this JsonNode? node, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return ReadFromNode(node, jsonTypeInfo);
		}

		public static object? Deserialize(this JsonNode? node, JsonTypeInfo jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return ReadFromNodeAsObject(node, jsonTypeInfo);
		}

		public static object? Deserialize(this JsonNode? node, Type returnType, JsonSerializerContext context)
		{
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(context, returnType);
			return ReadFromNodeAsObject(node, typeInfo);
		}

		private static TValue ReadFromNode<TValue>(JsonNode node, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			JsonSerializerOptions options = jsonTypeInfo.Options;
			using PooledByteBufferWriter pooledByteBufferWriter = new PooledByteBufferWriter(options.DefaultBufferSize);
			using (Utf8JsonWriter utf8JsonWriter = new Utf8JsonWriter(pooledByteBufferWriter, options.GetWriterOptions()))
			{
				if (node == null)
				{
					utf8JsonWriter.WriteNullValue();
				}
				else
				{
					node.WriteTo(utf8JsonWriter, options);
				}
			}
			return ReadFromSpan(pooledByteBufferWriter.WrittenMemory.Span, jsonTypeInfo);
		}

		private static object ReadFromNodeAsObject(JsonNode node, JsonTypeInfo jsonTypeInfo)
		{
			JsonSerializerOptions options = jsonTypeInfo.Options;
			using PooledByteBufferWriter pooledByteBufferWriter = new PooledByteBufferWriter(options.DefaultBufferSize);
			using (Utf8JsonWriter utf8JsonWriter = new Utf8JsonWriter(pooledByteBufferWriter, options.GetWriterOptions()))
			{
				if (node == null)
				{
					utf8JsonWriter.WriteNullValue();
				}
				else
				{
					node.WriteTo(utf8JsonWriter, options);
				}
			}
			return ReadFromSpanAsObject(pooledByteBufferWriter.WrittenMemory.Span, jsonTypeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static JsonDocument SerializeToDocument<TValue>(TValue value, JsonSerializerOptions? options = null)
		{
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			return WriteDocument<TValue>(in value, typeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static JsonDocument SerializeToDocument(object? value, Type inputType, JsonSerializerOptions? options = null)
		{
			ValidateInputType(value, inputType);
			JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
			return WriteDocumentAsObject(value, typeInfo);
		}

		public static JsonDocument SerializeToDocument<TValue>(TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return WriteDocument(in value, jsonTypeInfo);
		}

		public static JsonDocument SerializeToDocument(object? value, JsonTypeInfo jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return WriteDocumentAsObject(value, jsonTypeInfo);
		}

		public static JsonDocument SerializeToDocument(object? value, Type inputType, JsonSerializerContext context)
		{
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			ValidateInputType(value, inputType);
			return WriteDocumentAsObject(value, GetTypeInfo(context, inputType));
		}

		private static JsonDocument WriteDocument<TValue>(in TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			JsonSerializerOptions options = jsonTypeInfo.Options;
			PooledByteBufferWriter pooledByteBufferWriter = new PooledByteBufferWriter(options.DefaultBufferSize);
			Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriter(options, pooledByteBufferWriter);
			try
			{
				jsonTypeInfo.Serialize(writer, in value);
				return JsonDocument.ParseRented(pooledByteBufferWriter, options.GetDocumentOptions());
			}
			finally
			{
				Utf8JsonWriterCache.ReturnWriter(writer);
			}
		}

		private static JsonDocument WriteDocumentAsObject(object value, JsonTypeInfo jsonTypeInfo)
		{
			JsonSerializerOptions options = jsonTypeInfo.Options;
			PooledByteBufferWriter pooledByteBufferWriter = new PooledByteBufferWriter(options.DefaultBufferSize);
			Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriter(options, pooledByteBufferWriter);
			try
			{
				jsonTypeInfo.SerializeAsObject(writer, value);
				return JsonDocument.ParseRented(pooledByteBufferWriter, options.GetDocumentOptions());
			}
			finally
			{
				Utf8JsonWriterCache.ReturnWriter(writer);
			}
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static JsonElement SerializeToElement<TValue>(TValue value, JsonSerializerOptions? options = null)
		{
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			return WriteElement<TValue>(in value, typeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static JsonElement SerializeToElement(object? value, Type inputType, JsonSerializerOptions? options = null)
		{
			ValidateInputType(value, inputType);
			JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
			return WriteElementAsObject(value, typeInfo);
		}

		public static JsonElement SerializeToElement<TValue>(TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return WriteElement(in value, jsonTypeInfo);
		}

		public static JsonElement SerializeToElement(object? value, JsonTypeInfo jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return WriteElementAsObject(value, jsonTypeInfo);
		}

		public static JsonElement SerializeToElement(object? value, Type inputType, JsonSerializerContext context)
		{
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			ValidateInputType(value, inputType);
			JsonTypeInfo typeInfo = GetTypeInfo(context, inputType);
			return WriteElementAsObject(value, typeInfo);
		}

		private static JsonElement WriteElement<TValue>(in TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			JsonSerializerOptions options = jsonTypeInfo.Options;
			PooledByteBufferWriter bufferWriter;
			Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
			try
			{
				jsonTypeInfo.Serialize(writer, in value);
				return JsonElement.ParseValue(bufferWriter.WrittenMemory.Span, options.GetDocumentOptions());
			}
			finally
			{
				Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
			}
		}

		private static JsonElement WriteElementAsObject(object value, JsonTypeInfo jsonTypeInfo)
		{
			JsonSerializerOptions options = jsonTypeInfo.Options;
			PooledByteBufferWriter bufferWriter;
			Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
			try
			{
				jsonTypeInfo.SerializeAsObject(writer, value);
				return JsonElement.ParseValue(bufferWriter.WrittenMemory.Span, options.GetDocumentOptions());
			}
			finally
			{
				Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
			}
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static JsonNode? SerializeToNode<TValue>(TValue value, JsonSerializerOptions? options = null)
		{
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			return WriteNode<TValue>(in value, typeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static JsonNode? SerializeToNode(object? value, Type inputType, JsonSerializerOptions? options = null)
		{
			ValidateInputType(value, inputType);
			JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
			return WriteNodeAsObject(value, typeInfo);
		}

		public static JsonNode? SerializeToNode<TValue>(TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return WriteNode(in value, jsonTypeInfo);
		}

		public static JsonNode? SerializeToNode(object? value, JsonTypeInfo jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return WriteNodeAsObject(value, jsonTypeInfo);
		}

		public static JsonNode? SerializeToNode(object? value, Type inputType, JsonSerializerContext context)
		{
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			ValidateInputType(value, inputType);
			JsonTypeInfo typeInfo = GetTypeInfo(context, inputType);
			return WriteNodeAsObject(value, typeInfo);
		}

		private static JsonNode WriteNode<TValue>(in TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			JsonSerializerOptions options = jsonTypeInfo.Options;
			PooledByteBufferWriter bufferWriter;
			Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
			try
			{
				jsonTypeInfo.Serialize(writer, in value);
				return JsonNode.Parse(bufferWriter.WrittenMemory.Span, options.GetNodeOptions(), options.GetDocumentOptions());
			}
			finally
			{
				Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
			}
		}

		private static JsonNode WriteNodeAsObject(object value, JsonTypeInfo jsonTypeInfo)
		{
			JsonSerializerOptions options = jsonTypeInfo.Options;
			PooledByteBufferWriter bufferWriter;
			Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
			try
			{
				jsonTypeInfo.SerializeAsObject(writer, value);
				return JsonNode.Parse(bufferWriter.WrittenMemory.Span, options.GetNodeOptions(), options.GetDocumentOptions());
			}
			finally
			{
				Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
			}
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private static JsonTypeInfo GetTypeInfo(JsonSerializerOptions options, Type inputType)
		{
			if (options == null)
			{
				options = JsonSerializerOptions.Default;
			}
			options.MakeReadOnly(populateMissingResolver: true);
			if (!(inputType == JsonTypeInfo.ObjectType))
			{
				return options.GetTypeInfoForRootType(inputType);
			}
			return options.ObjectTypeInfo;
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private static JsonTypeInfo<T> GetTypeInfo<T>(JsonSerializerOptions options)
		{
			return (JsonTypeInfo<T>)GetTypeInfo(options, typeof(T));
		}

		private static JsonTypeInfo GetTypeInfo(JsonSerializerContext context, Type inputType)
		{
			JsonTypeInfo typeInfo = context.GetTypeInfo(inputType);
			if (typeInfo == null)
			{
				ThrowHelper.ThrowInvalidOperationException_NoMetadataForType(inputType, context);
			}
			typeInfo.EnsureConfigured();
			return typeInfo;
		}

		private static void ValidateInputType(object value, Type inputType)
		{
			if ((object)inputType == null)
			{
				ThrowHelper.ThrowArgumentNullException("inputType");
			}
			if (value != null)
			{
				Type type = value.GetType();
				if (!inputType.IsAssignableFrom(type))
				{
					ThrowHelper.ThrowArgumentException_DeserializeWrongType(inputType, value);
				}
			}
		}

		internal static bool IsValidNumberHandlingValue(JsonNumberHandling handling)
		{
			return JsonHelpers.IsInRangeInclusive((int)handling, 0, 7);
		}

		internal static bool IsValidCreationHandlingValue(JsonObjectCreationHandling handling)
		{
			if ((uint)handling <= 1u)
			{
				return true;
			}
			return false;
		}

		internal static bool IsValidUnmappedMemberHandlingValue(JsonUnmappedMemberHandling handling)
		{
			if ((uint)handling <= 1u)
			{
				return true;
			}
			return false;
		}

		[return: NotNullIfNotNull("value")]
		internal static T UnboxOnRead<T>(object value)
		{
			if (value == null)
			{
				if (default(T) != null)
				{
					ThrowUnableToCastValue(value);
				}
				return default(T);
			}
			if (value is T)
			{
				return (T)value;
			}
			ThrowUnableToCastValue(value);
			return default(T);
			static void ThrowUnableToCastValue(object obj)
			{
				if (obj == null)
				{
					ThrowHelper.ThrowInvalidOperationException_DeserializeUnableToAssignNull(typeof(T));
				}
				else
				{
					ThrowHelper.ThrowInvalidCastException_DeserializeUnableToAssignValue(obj.GetType(), typeof(T));
				}
			}
		}

		[return: NotNullIfNotNull("value")]
		internal static T UnboxOnWrite<T>(object value)
		{
			if (default(T) != null && value == null)
			{
				ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(typeof(T));
			}
			return (T)value;
		}

		internal static bool TryReadMetadata(JsonConverter converter, JsonTypeInfo jsonTypeInfo, ref Utf8JsonReader reader, scoped ref ReadStack state)
		{
			while (true)
			{
				if (state.Current.PropertyState == StackFramePropertyState.None)
				{
					state.Current.PropertyState = StackFramePropertyState.ReadName;
					if (!reader.Read())
					{
						return false;
					}
				}
				if ((int)state.Current.PropertyState < 2)
				{
					if (reader.TokenType == JsonTokenType.EndObject)
					{
						return true;
					}
					if ((state.Current.MetadataPropertyNames & MetadataPropertyName.Ref) != MetadataPropertyName.None)
					{
						ThrowHelper.ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties(reader.GetSpan(), ref state);
					}
					ReadOnlySpan<byte> span = reader.GetSpan();
					switch (state.Current.LatestMetadataPropertyName = GetMetadataPropertyName(span, jsonTypeInfo.PolymorphicTypeResolver))
					{
					case MetadataPropertyName.Id:
						state.Current.JsonPropertyName = s_idPropertyName;
						if (state.ReferenceResolver == null)
						{
							ThrowHelper.ThrowJsonException_MetadataUnexpectedProperty(span, ref state);
						}
						if ((state.Current.MetadataPropertyNames & (MetadataPropertyName.Id | MetadataPropertyName.Ref)) != MetadataPropertyName.None)
						{
							ThrowHelper.ThrowJsonException_MetadataIdIsNotFirstProperty(span, ref state);
						}
						if (!converter.CanHaveMetadata)
						{
							ThrowHelper.ThrowJsonException_MetadataCannotParsePreservedObjectIntoImmutable(converter.Type);
						}
						break;
					case MetadataPropertyName.Ref:
						state.Current.JsonPropertyName = s_refPropertyName;
						if (state.ReferenceResolver == null)
						{
							ThrowHelper.ThrowJsonException_MetadataUnexpectedProperty(span, ref state);
						}
						if (converter.IsValueType)
						{
							ThrowHelper.ThrowJsonException_MetadataInvalidReferenceToValueType(converter.Type);
						}
						if (state.Current.MetadataPropertyNames != MetadataPropertyName.None)
						{
							ThrowHelper.ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties(reader.GetSpan(), ref state);
						}
						break;
					case MetadataPropertyName.Type:
						state.Current.JsonPropertyName = jsonTypeInfo.PolymorphicTypeResolver?.TypeDiscriminatorPropertyNameUtf8 ?? s_typePropertyName;
						if (jsonTypeInfo.PolymorphicTypeResolver == null)
						{
							ThrowHelper.ThrowJsonException_MetadataUnexpectedProperty(span, ref state);
						}
						if (state.PolymorphicTypeDiscriminator != null)
						{
							ThrowHelper.ThrowJsonException_MetadataDuplicateTypeProperty();
						}
						break;
					case MetadataPropertyName.Values:
						state.Current.JsonPropertyName = s_valuesPropertyName;
						if (state.Current.MetadataPropertyNames == MetadataPropertyName.None)
						{
							ThrowHelper.ThrowJsonException_MetadataStandaloneValuesProperty(ref state, span);
						}
						break;
					default:
						return true;
					}
					state.Current.PropertyState = StackFramePropertyState.Name;
				}
				if ((int)state.Current.PropertyState < 3)
				{
					state.Current.PropertyState = StackFramePropertyState.ReadValue;
					if (!reader.Read())
					{
						break;
					}
				}
				switch (state.Current.LatestMetadataPropertyName)
				{
				case MetadataPropertyName.Id:
					if (reader.TokenType != JsonTokenType.String)
					{
						ThrowHelper.ThrowJsonException_MetadataValueWasNotString(reader.TokenType);
					}
					if (state.ReferenceId != null)
					{
						ThrowHelper.ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(s_refPropertyName, ref reader, ref state);
					}
					state.ReferenceId = reader.GetString();
					break;
				case MetadataPropertyName.Ref:
					if (reader.TokenType != JsonTokenType.String)
					{
						ThrowHelper.ThrowJsonException_MetadataValueWasNotString(reader.TokenType);
					}
					if (state.ReferenceId != null)
					{
						ThrowHelper.ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(s_refPropertyName, ref reader, ref state);
					}
					state.ReferenceId = reader.GetString();
					break;
				case MetadataPropertyName.Type:
					switch (reader.TokenType)
					{
					case JsonTokenType.String:
						state.PolymorphicTypeDiscriminator = reader.GetString();
						break;
					case JsonTokenType.Number:
						state.PolymorphicTypeDiscriminator = reader.GetInt32();
						break;
					default:
						ThrowHelper.ThrowJsonException_MetadataValueWasNotString(reader.TokenType);
						break;
					}
					break;
				case MetadataPropertyName.Values:
					if (reader.TokenType != JsonTokenType.StartArray)
					{
						ThrowHelper.ThrowJsonException_MetadataValuesInvalidToken(reader.TokenType);
					}
					state.Current.PropertyState = StackFramePropertyState.None;
					state.Current.MetadataPropertyNames |= state.Current.LatestMetadataPropertyName;
					return true;
				}
				state.Current.MetadataPropertyNames |= state.Current.LatestMetadataPropertyName;
				state.Current.PropertyState = StackFramePropertyState.None;
				state.Current.JsonPropertyName = null;
			}
			return false;
		}

		internal static bool IsMetadataPropertyName(ReadOnlySpan<byte> propertyName, PolymorphicTypeResolver resolver)
		{
			if (propertyName.Length <= 0 || propertyName[0] != 36)
			{
				if (resolver == null)
				{
					return false;
				}
				byte[] typeDiscriminatorPropertyNameUtf = resolver.TypeDiscriminatorPropertyNameUtf8;
				return ((typeDiscriminatorPropertyNameUtf != null) ? new bool?(MemoryExtensions.AsSpan(typeDiscriminatorPropertyNameUtf).SequenceEqual(propertyName)) : ((bool?)null)) == true;
			}
			return true;
		}

		internal static MetadataPropertyName GetMetadataPropertyName(ReadOnlySpan<byte> propertyName, PolymorphicTypeResolver resolver)
		{
			if (propertyName.Length > 0 && propertyName[0] == 36)
			{
				switch (propertyName.Length)
				{
				case 3:
					if (propertyName[1] == 105 && propertyName[2] == 100)
					{
						return MetadataPropertyName.Id;
					}
					break;
				case 4:
					if (propertyName[1] == 114 && propertyName[2] == 101 && propertyName[3] == 102)
					{
						return MetadataPropertyName.Ref;
					}
					break;
				case 5:
					if (resolver?.TypeDiscriminatorPropertyNameUtf8 == null && propertyName[1] == 116 && propertyName[2] == 121 && propertyName[3] == 112 && propertyName[4] == 101)
					{
						return MetadataPropertyName.Type;
					}
					break;
				case 7:
					if (propertyName[1] == 118 && propertyName[2] == 97 && propertyName[3] == 108 && propertyName[4] == 117 && propertyName[5] == 101 && propertyName[6] == 115)
					{
						return MetadataPropertyName.Values;
					}
					break;
				}
			}
			byte[] array = resolver?.TypeDiscriminatorPropertyNameUtf8;
			if (array != null && propertyName.SequenceEqual(array))
			{
				return MetadataPropertyName.Type;
			}
			return MetadataPropertyName.None;
		}

		internal static bool TryHandleReferenceFromJsonElement(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonElement element, [NotNullWhen(true)] out object referenceValue)
		{
			bool flag = false;
			referenceValue = null;
			if (element.ValueKind == JsonValueKind.Object)
			{
				int num = 0;
				foreach (JsonProperty item in element.EnumerateObject())
				{
					num++;
					if (flag)
					{
						ThrowHelper.ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties();
						continue;
					}
					if (item.EscapedNameEquals(s_idPropertyName))
					{
						if (state.ReferenceId != null)
						{
							ThrowHelper.ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(s_refPropertyName, ref reader, ref state);
						}
						if (item.Value.ValueKind != JsonValueKind.String)
						{
							ThrowHelper.ThrowJsonException_MetadataValueWasNotString(item.Value.ValueKind);
						}
						object obj = element;
						state.ReferenceResolver.AddReference(item.Value.GetString(), obj);
						referenceValue = obj;
						return true;
					}
					if (item.EscapedNameEquals(s_refPropertyName))
					{
						if (state.ReferenceId != null)
						{
							ThrowHelper.ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(s_refPropertyName, ref reader, ref state);
						}
						if (num > 1)
						{
							ThrowHelper.ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties();
						}
						if (item.Value.ValueKind != JsonValueKind.String)
						{
							ThrowHelper.ThrowJsonException_MetadataValueWasNotString(item.Value.ValueKind);
						}
						referenceValue = state.ReferenceResolver.ResolveReference(item.Value.GetString());
						flag = true;
					}
				}
			}
			return flag;
		}

		internal static bool TryHandleReferenceFromJsonNode(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonNode jsonNode, [NotNullWhen(true)] out object referenceValue)
		{
			bool flag = false;
			referenceValue = null;
			if (jsonNode is JsonObject jsonObject)
			{
				int num = 0;
				foreach (KeyValuePair<string, JsonNode> item in jsonObject)
				{
					num++;
					if (flag)
					{
						ThrowHelper.ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties();
						continue;
					}
					if (item.Key == "$id")
					{
						if (state.ReferenceId != null)
						{
							ThrowHelper.ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(s_refPropertyName, ref reader, ref state);
						}
						string referenceId = ReadAsStringMetadataValue(item.Value);
						state.ReferenceResolver.AddReference(referenceId, jsonNode);
						referenceValue = jsonNode;
						return true;
					}
					if (item.Key == "$ref")
					{
						if (state.ReferenceId != null)
						{
							ThrowHelper.ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(s_refPropertyName, ref reader, ref state);
						}
						if (num > 1)
						{
							ThrowHelper.ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties();
						}
						string referenceId2 = ReadAsStringMetadataValue(item.Value);
						referenceValue = state.ReferenceResolver.ResolveReference(referenceId2);
						flag = true;
					}
				}
			}
			return flag;
			static string ReadAsStringMetadataValue(JsonNode jsonNode2)
			{
				if (jsonNode2 is JsonValue jsonValue && jsonValue.TryGetValue<string>(out string value) && value != null)
				{
					return value;
				}
				JsonValueKind jsonValueKind = ((jsonNode2 == null) ? JsonValueKind.Null : ((jsonNode2 is JsonObject) ? JsonValueKind.Object : ((jsonNode2 is JsonArray) ? JsonValueKind.Array : ((jsonNode2 is JsonValue<JsonElement> jsonValue2) ? jsonValue2.Value.ValueKind : JsonValueKind.Undefined))));
				JsonValueKind valueKind = jsonValueKind;
				ThrowHelper.ThrowJsonException_MetadataValueWasNotString(valueKind);
				return null;
			}
		}

		internal static void ValidateMetadataForObjectConverter(ref ReadStack state)
		{
			if ((state.Current.MetadataPropertyNames & MetadataPropertyName.Values) != MetadataPropertyName.None)
			{
				ThrowHelper.ThrowJsonException_MetadataUnexpectedProperty(s_valuesPropertyName, ref state);
			}
		}

		internal static void ValidateMetadataForArrayConverter(JsonConverter converter, ref Utf8JsonReader reader, scoped ref ReadStack state)
		{
			switch (reader.TokenType)
			{
			case JsonTokenType.EndObject:
				if (state.Current.MetadataPropertyNames != MetadataPropertyName.Ref)
				{
					ThrowHelper.ThrowJsonException_MetadataPreservedArrayValuesNotFound(ref state, converter.Type);
				}
				break;
			default:
				ThrowHelper.ThrowJsonException_MetadataInvalidPropertyInArrayMetadata(ref state, converter.Type, in reader);
				break;
			case JsonTokenType.StartArray:
				break;
			}
		}

		internal static T ResolveReferenceId<T>(ref ReadStack state)
		{
			string referenceId = state.ReferenceId;
			object obj = state.ReferenceResolver.ResolveReference(referenceId);
			state.ReferenceId = null;
			try
			{
				return (T)obj;
			}
			catch (InvalidCastException)
			{
				ThrowHelper.ThrowInvalidOperationException_MetadataReferenceOfTypeCannotBeAssignedToType(referenceId, obj.GetType(), typeof(T));
				return default(T);
			}
		}

		internal static JsonPropertyInfo LookupProperty(object obj, ReadOnlySpan<byte> unescapedPropertyName, ref ReadStack state, JsonSerializerOptions options, out bool useExtensionProperty, bool createExtensionProperty = true)
		{
			JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
			useExtensionProperty = false;
			byte[] utf8PropertyName;
			JsonPropertyInfo jsonPropertyInfo = jsonTypeInfo.GetProperty(unescapedPropertyName, ref state.Current, out utf8PropertyName);
			state.Current.PropertyIndex++;
			state.Current.JsonPropertyName = utf8PropertyName;
			if (jsonPropertyInfo == JsonPropertyInfo.s_missingProperty)
			{
				if (jsonTypeInfo.EffectiveUnmappedMemberHandling == JsonUnmappedMemberHandling.Disallow)
				{
					string unmappedPropertyName = JsonHelpers.Utf8GetString(unescapedPropertyName);
					ThrowHelper.ThrowJsonException_UnmappedJsonProperty(jsonTypeInfo.Type, unmappedPropertyName);
				}
				JsonPropertyInfo extensionDataProperty = jsonTypeInfo.ExtensionDataProperty;
				if (extensionDataProperty != null && extensionDataProperty.HasGetter && extensionDataProperty.HasSetter)
				{
					state.Current.JsonPropertyNameAsString = JsonHelpers.Utf8GetString(unescapedPropertyName);
					if (createExtensionProperty)
					{
						CreateExtensionDataProperty(obj, extensionDataProperty, options);
					}
					jsonPropertyInfo = extensionDataProperty;
					useExtensionProperty = true;
				}
			}
			state.Current.JsonPropertyInfo = jsonPropertyInfo;
			state.Current.NumberHandling = jsonPropertyInfo.EffectiveNumberHandling;
			return jsonPropertyInfo;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ReadOnlySpan<byte> GetPropertyName(scoped ref ReadStack state, ref Utf8JsonReader reader)
		{
			ReadOnlySpan<byte> span = reader.GetSpan();
			ReadOnlySpan<byte> result = ((!reader.ValueIsEscaped) ? span : JsonReaderHelper.GetUnescapedSpan(span));
			if (state.Current.CanContainMetadata && IsMetadataPropertyName(span, state.Current.BaseJsonTypeInfo.PolymorphicTypeResolver))
			{
				ThrowHelper.ThrowUnexpectedMetadataException(span, ref reader, ref state);
			}
			return result;
		}

		internal static void CreateExtensionDataProperty(object obj, JsonPropertyInfo jsonPropertyInfo, JsonSerializerOptions options)
		{
			object valueAsObject = jsonPropertyInfo.GetValueAsObject(obj);
			if (valueAsObject != null)
			{
				return;
			}
			Func<object> func = jsonPropertyInfo.JsonTypeInfo.CreateObject ?? jsonPropertyInfo.JsonTypeInfo.CreateObjectForExtensionDataProperty;
			if (func == null)
			{
				if (jsonPropertyInfo.PropertyType.FullName == "System.Text.Json.Nodes.JsonObject")
				{
					ThrowHelper.ThrowInvalidOperationException_NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty();
				}
				else
				{
					ThrowHelper.ThrowNotSupportedException_SerializationNotSupported(jsonPropertyInfo.PropertyType);
				}
			}
			valueAsObject = func();
			jsonPropertyInfo.Set(obj, valueAsObject);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static TValue? Deserialize<TValue>(ReadOnlySpan<byte> utf8Json, JsonSerializerOptions? options = null)
		{
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			return ReadFromSpan(utf8Json, typeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static object? Deserialize(ReadOnlySpan<byte> utf8Json, Type returnType, JsonSerializerOptions? options = null)
		{
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
			return ReadFromSpanAsObject(utf8Json, typeInfo);
		}

		public static TValue? Deserialize<TValue>(ReadOnlySpan<byte> utf8Json, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return ReadFromSpan(utf8Json, jsonTypeInfo);
		}

		public static object? Deserialize(ReadOnlySpan<byte> utf8Json, JsonTypeInfo jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return ReadFromSpanAsObject(utf8Json, jsonTypeInfo);
		}

		public static object? Deserialize(ReadOnlySpan<byte> utf8Json, Type returnType, JsonSerializerContext context)
		{
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			return ReadFromSpanAsObject(utf8Json, GetTypeInfo(context, returnType));
		}

		private static TValue ReadFromSpan<TValue>(ReadOnlySpan<byte> utf8Json, JsonTypeInfo<TValue> jsonTypeInfo, int? actualByteCount = null)
		{
			JsonReaderState state = new JsonReaderState(jsonTypeInfo.Options.GetReaderOptions());
			Utf8JsonReader reader = new Utf8JsonReader(utf8Json, isFinalBlock: true, state);
			ReadStack state2 = default(ReadStack);
			state2.Initialize(jsonTypeInfo);
			return jsonTypeInfo.Deserialize(ref reader, ref state2);
		}

		private static object ReadFromSpanAsObject(ReadOnlySpan<byte> utf8Json, JsonTypeInfo jsonTypeInfo, int? actualByteCount = null)
		{
			JsonReaderState state = new JsonReaderState(jsonTypeInfo.Options.GetReaderOptions());
			Utf8JsonReader reader = new Utf8JsonReader(utf8Json, isFinalBlock: true, state);
			ReadStack state2 = default(ReadStack);
			state2.Initialize(jsonTypeInfo);
			return jsonTypeInfo.DeserializeAsObject(ref reader, ref state2);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static ValueTask<TValue?> DeserializeAsync<TValue>(Stream utf8Json, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			return typeInfo.DeserializeAsync(utf8Json, cancellationToken);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static TValue? Deserialize<TValue>(Stream utf8Json, JsonSerializerOptions? options = null)
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			return typeInfo.Deserialize(utf8Json);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static ValueTask<object?> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
			return typeInfo.DeserializeAsObjectAsync(utf8Json, cancellationToken);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static object? Deserialize(Stream utf8Json, Type returnType, JsonSerializerOptions? options = null)
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
			return typeInfo.DeserializeAsObject(utf8Json);
		}

		public static ValueTask<TValue?> DeserializeAsync<TValue>(Stream utf8Json, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return jsonTypeInfo.DeserializeAsync(utf8Json, cancellationToken);
		}

		public static ValueTask<object?> DeserializeAsync(Stream utf8Json, JsonTypeInfo jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return jsonTypeInfo.DeserializeAsObjectAsync(utf8Json, cancellationToken);
		}

		public static TValue? Deserialize<TValue>(Stream utf8Json, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return jsonTypeInfo.Deserialize(utf8Json);
		}

		public static object? Deserialize(Stream utf8Json, JsonTypeInfo jsonTypeInfo)
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return jsonTypeInfo.DeserializeAsObject(utf8Json);
		}

		public static ValueTask<object?> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerContext context, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(context, returnType);
			return typeInfo.DeserializeAsObjectAsync(utf8Json, cancellationToken);
		}

		public static object? Deserialize(Stream utf8Json, Type returnType, JsonSerializerContext context)
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(context, returnType);
			return typeInfo.DeserializeAsObject(utf8Json);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static IAsyncEnumerable<TValue?> DeserializeAsyncEnumerable<TValue>(Stream utf8Json, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			return DeserializeAsyncEnumerableCore(utf8Json, typeInfo, cancellationToken);
		}

		public static IAsyncEnumerable<TValue?> DeserializeAsyncEnumerable<TValue>(Stream utf8Json, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return DeserializeAsyncEnumerableCore(utf8Json, jsonTypeInfo, cancellationToken);
		}

		private static IAsyncEnumerable<T> DeserializeAsyncEnumerableCore<T>(Stream utf8Json, JsonTypeInfo<T> jsonTypeInfo, CancellationToken cancellationToken)
		{
			JsonTypeInfo asyncEnumerableQueueTypeInfo = jsonTypeInfo._asyncEnumerableQueueTypeInfo;
			JsonTypeInfo<Queue<T>> queueTypeInfo = ((asyncEnumerableQueueTypeInfo != null) ? ((JsonTypeInfo<Queue<T>>)asyncEnumerableQueueTypeInfo) : CreateQueueTypeInfo(jsonTypeInfo));
			return CreateAsyncEnumerable(utf8Json, queueTypeInfo, cancellationToken);
			static async IAsyncEnumerable<T> CreateAsyncEnumerable(Stream utf8Json2, JsonTypeInfo<Queue<T>> jsonTypeInfo2, [EnumeratorCancellation] CancellationToken cancellationToken2)
			{
				JsonSerializerOptions options = jsonTypeInfo2.Options;
				ReadBufferState bufferState = new ReadBufferState(options.DefaultBufferSize);
				ReadStack readStack = default(ReadStack);
				readStack.Initialize(jsonTypeInfo2, supportContinuation: true);
				JsonReaderState jsonReaderState = new JsonReaderState(options.GetReaderOptions());
				try
				{
					do
					{
						bufferState = await bufferState.ReadFromStreamAsync(utf8Json2, cancellationToken2, fillBuffer: false).ConfigureAwait(continueOnCapturedContext: false);
						jsonTypeInfo2.ContinueDeserialize(ref bufferState, ref jsonReaderState, ref readStack);
						object returnValue = readStack.Current.ReturnValue;
						if (returnValue != null)
						{
							Queue<T> queue = (Queue<T>)returnValue;
							T result;
							while (JsonHelpers.TryDequeue(queue, out result))
							{
								yield return result;
							}
						}
					}
					while (!bufferState.IsFinalBlock);
				}
				finally
				{
					bufferState.Dispose();
				}
			}
			static JsonTypeInfo<Queue<T>> CreateQueueTypeInfo(JsonTypeInfo<T> jsonTypeInfo3)
			{
				QueueOfTConverter<Queue<T>, T> converter = new QueueOfTConverter<Queue<T>, T>();
				JsonTypeInfo<Queue<T>> jsonTypeInfo2 = new JsonTypeInfo<Queue<T>>(converter, jsonTypeInfo3.Options)
				{
					CreateObject = () => new Queue<T>(),
					ElementTypeInfo = jsonTypeInfo3,
					NumberHandling = jsonTypeInfo3.Options.NumberHandling
				};
				jsonTypeInfo2.EnsureConfigured();
				jsonTypeInfo3._asyncEnumerableQueueTypeInfo = jsonTypeInfo2;
				return jsonTypeInfo2;
			}
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static TValue? Deserialize<TValue>([StringSyntax("Json")] string json, JsonSerializerOptions? options = null)
		{
			if (json == null)
			{
				ThrowHelper.ThrowArgumentNullException("json");
			}
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			return ReadFromSpan(MemoryExtensions.AsSpan(json), typeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static TValue? Deserialize<TValue>([StringSyntax("Json")] ReadOnlySpan<char> json, JsonSerializerOptions? options = null)
		{
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			return ReadFromSpan(json, typeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static object? Deserialize([StringSyntax("Json")] string json, Type returnType, JsonSerializerOptions? options = null)
		{
			if (json == null)
			{
				ThrowHelper.ThrowArgumentNullException("json");
			}
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
			return ReadFromSpanAsObject(MemoryExtensions.AsSpan(json), typeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static object? Deserialize([StringSyntax("Json")] ReadOnlySpan<char> json, Type returnType, JsonSerializerOptions? options = null)
		{
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
			return ReadFromSpanAsObject(json, typeInfo);
		}

		public static TValue? Deserialize<TValue>([StringSyntax("Json")] string json, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (json == null)
			{
				ThrowHelper.ThrowArgumentNullException("json");
			}
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return ReadFromSpan(MemoryExtensions.AsSpan(json), jsonTypeInfo);
		}

		public static TValue? Deserialize<TValue>([StringSyntax("Json")] ReadOnlySpan<char> json, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return ReadFromSpan(json, jsonTypeInfo);
		}

		public static object? Deserialize([StringSyntax("Json")] string json, JsonTypeInfo jsonTypeInfo)
		{
			if (json == null)
			{
				ThrowHelper.ThrowArgumentNullException("json");
			}
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return ReadFromSpanAsObject(MemoryExtensions.AsSpan(json), jsonTypeInfo);
		}

		public static object? Deserialize([StringSyntax("Json")] ReadOnlySpan<char> json, JsonTypeInfo jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return ReadFromSpanAsObject(json, jsonTypeInfo);
		}

		public static object? Deserialize([StringSyntax("Json")] string json, Type returnType, JsonSerializerContext context)
		{
			if (json == null)
			{
				ThrowHelper.ThrowArgumentNullException("json");
			}
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(context, returnType);
			return ReadFromSpanAsObject(MemoryExtensions.AsSpan(json), typeInfo);
		}

		public static object? Deserialize([StringSyntax("Json")] ReadOnlySpan<char> json, Type returnType, JsonSerializerContext context)
		{
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(context, returnType);
			return ReadFromSpanAsObject(json, typeInfo);
		}

		private static TValue ReadFromSpan<TValue>(ReadOnlySpan<char> json, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			byte[] array = null;
			Span<byte> span = (((long)json.Length > 349525L) ? new byte[JsonReaderHelper.GetUtf8ByteCount(json)] : (array = ArrayPool<byte>.Shared.Rent(json.Length * 3)));
			try
			{
				int utf8FromText = JsonReaderHelper.GetUtf8FromText(json, span);
				span = span.Slice(0, utf8FromText);
				return ReadFromSpan(span, jsonTypeInfo, utf8FromText);
			}
			finally
			{
				if (array != null)
				{
					span.Clear();
					ArrayPool<byte>.Shared.Return(array);
				}
			}
		}

		private static object ReadFromSpanAsObject(ReadOnlySpan<char> json, JsonTypeInfo jsonTypeInfo)
		{
			byte[] array = null;
			Span<byte> span = (((long)json.Length > 349525L) ? new byte[JsonReaderHelper.GetUtf8ByteCount(json)] : (array = ArrayPool<byte>.Shared.Rent(json.Length * 3)));
			try
			{
				int utf8FromText = JsonReaderHelper.GetUtf8FromText(json, span);
				span = span.Slice(0, utf8FromText);
				return ReadFromSpanAsObject(span, jsonTypeInfo, utf8FromText);
			}
			finally
			{
				if (array != null)
				{
					span.Clear();
					ArrayPool<byte>.Shared.Return(array);
				}
			}
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static TValue? Deserialize<TValue>(ref Utf8JsonReader reader, JsonSerializerOptions? options = null)
		{
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			return Read(ref reader, typeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static object? Deserialize(ref Utf8JsonReader reader, Type returnType, JsonSerializerOptions? options = null)
		{
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
			return ReadAsObject(ref reader, typeInfo);
		}

		public static TValue? Deserialize<TValue>(ref Utf8JsonReader reader, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return Read(ref reader, jsonTypeInfo);
		}

		public static object? Deserialize(ref Utf8JsonReader reader, JsonTypeInfo jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return ReadAsObject(ref reader, jsonTypeInfo);
		}

		public static object? Deserialize(ref Utf8JsonReader reader, Type returnType, JsonSerializerContext context)
		{
			if ((object)returnType == null)
			{
				ThrowHelper.ThrowArgumentNullException("returnType");
			}
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			return ReadAsObject(ref reader, GetTypeInfo(context, returnType));
		}

		private static TValue Read<TValue>(ref Utf8JsonReader reader, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (reader.CurrentState.Options.CommentHandling == JsonCommentHandling.Allow)
			{
				ThrowHelper.ThrowArgumentException_SerializerDoesNotSupportComments("reader");
			}
			ReadStack state = default(ReadStack);
			state.Initialize(jsonTypeInfo);
			Utf8JsonReader utf8JsonReader = reader;
			try
			{
				Utf8JsonReader reader2 = GetReaderScopedToNextValue(ref reader, ref state);
				return jsonTypeInfo.Deserialize(ref reader2, ref state);
			}
			catch (JsonException)
			{
				reader = utf8JsonReader;
				throw;
			}
		}

		private static object ReadAsObject(ref Utf8JsonReader reader, JsonTypeInfo jsonTypeInfo)
		{
			if (reader.CurrentState.Options.CommentHandling == JsonCommentHandling.Allow)
			{
				ThrowHelper.ThrowArgumentException_SerializerDoesNotSupportComments("reader");
			}
			ReadStack state = default(ReadStack);
			state.Initialize(jsonTypeInfo);
			Utf8JsonReader utf8JsonReader = reader;
			try
			{
				Utf8JsonReader reader2 = GetReaderScopedToNextValue(ref reader, ref state);
				return jsonTypeInfo.DeserializeAsObject(ref reader2, ref state);
			}
			catch (JsonException)
			{
				reader = utf8JsonReader;
				throw;
			}
		}

		private static Utf8JsonReader GetReaderScopedToNextValue(ref Utf8JsonReader reader, scoped ref ReadStack state)
		{
			ReadOnlySpan<byte> jsonData = default(ReadOnlySpan<byte>);
			ReadOnlySequence<byte> jsonData2 = default(ReadOnlySequence<byte>);
			try
			{
				JsonTokenType tokenType = reader.TokenType;
				ReadOnlySpan<byte> bytes;
				if ((tokenType == JsonTokenType.None || tokenType == JsonTokenType.PropertyName) && !reader.Read())
				{
					bytes = default(ReadOnlySpan<byte>);
					ThrowHelper.ThrowJsonReaderException(ref reader, ExceptionResource.ExpectedOneCompleteToken, 0, bytes);
				}
				switch (reader.TokenType)
				{
				case JsonTokenType.StartObject:
				case JsonTokenType.StartArray:
				{
					long tokenStartIndex = reader.TokenStartIndex;
					if (!reader.TrySkip())
					{
						bytes = default(ReadOnlySpan<byte>);
						ThrowHelper.ThrowJsonReaderException(ref reader, ExceptionResource.NotEnoughData, 0, bytes);
					}
					long num2 = reader.BytesConsumed - tokenStartIndex;
					ReadOnlySequence<byte> originalSequence = reader.OriginalSequence;
					if (originalSequence.IsEmpty)
					{
						bytes = reader.OriginalSpan;
						jsonData = checked(bytes.Slice((int)tokenStartIndex, (int)num2));
					}
					else
					{
						jsonData2 = originalSequence.Slice(tokenStartIndex, num2);
					}
					break;
				}
				case JsonTokenType.Number:
				case JsonTokenType.True:
				case JsonTokenType.False:
				case JsonTokenType.Null:
					if (reader.HasValueSequence)
					{
						jsonData2 = reader.ValueSequence;
					}
					else
					{
						jsonData = reader.ValueSpan;
					}
					break;
				case JsonTokenType.String:
				{
					ReadOnlySequence<byte> originalSequence2 = reader.OriginalSequence;
					if (originalSequence2.IsEmpty)
					{
						bytes = reader.ValueSpan;
						int length = bytes.Length + 2;
						jsonData = reader.OriginalSpan.Slice((int)reader.TokenStartIndex, length);
						break;
					}
					long num3;
					if (!reader.HasValueSequence)
					{
						bytes = reader.ValueSpan;
						num3 = bytes.Length + 2;
					}
					else
					{
						num3 = reader.ValueSequence.Length + 2;
					}
					long length2 = num3;
					jsonData2 = originalSequence2.Slice(reader.TokenStartIndex, length2);
					break;
				}
				default:
				{
					byte num;
					if (!reader.HasValueSequence)
					{
						bytes = reader.ValueSpan;
						num = bytes[0];
					}
					else
					{
						bytes = reader.ValueSequence.First.Span;
						num = bytes[0];
					}
					byte nextByte = num;
					bytes = default(ReadOnlySpan<byte>);
					ThrowHelper.ThrowJsonReaderException(ref reader, ExceptionResource.ExpectedStartOfValueNotFound, nextByte, bytes);
					break;
				}
				}
			}
			catch (JsonReaderException ex)
			{
				ThrowHelper.ReThrowWithPath(ref state, ex);
			}
			if (!jsonData.IsEmpty)
			{
				return new Utf8JsonReader(jsonData, reader.CurrentState.Options);
			}
			return new Utf8JsonReader(jsonData2, reader.CurrentState.Options);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static byte[] SerializeToUtf8Bytes<TValue>(TValue value, JsonSerializerOptions? options = null)
		{
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			return WriteBytes<TValue>(in value, typeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static byte[] SerializeToUtf8Bytes(object? value, Type inputType, JsonSerializerOptions? options = null)
		{
			ValidateInputType(value, inputType);
			JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
			return WriteBytesAsObject(value, typeInfo);
		}

		public static byte[] SerializeToUtf8Bytes<TValue>(TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return WriteBytes(in value, jsonTypeInfo);
		}

		public static byte[] SerializeToUtf8Bytes(object? value, JsonTypeInfo jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return WriteBytesAsObject(value, jsonTypeInfo);
		}

		public static byte[] SerializeToUtf8Bytes(object? value, Type inputType, JsonSerializerContext context)
		{
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			ValidateInputType(value, inputType);
			JsonTypeInfo typeInfo = GetTypeInfo(context, inputType);
			return WriteBytesAsObject(value, typeInfo);
		}

		private static byte[] WriteBytes<TValue>(in TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			PooledByteBufferWriter bufferWriter;
			Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
			try
			{
				jsonTypeInfo.Serialize(writer, in value);
				return bufferWriter.WrittenMemory.ToArray();
			}
			finally
			{
				Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
			}
		}

		private static byte[] WriteBytesAsObject(object value, JsonTypeInfo jsonTypeInfo)
		{
			PooledByteBufferWriter bufferWriter;
			Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
			try
			{
				jsonTypeInfo.SerializeAsObject(writer, value);
				return bufferWriter.WrittenMemory.ToArray();
			}
			finally
			{
				Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
			}
		}

		internal static MetadataPropertyName WriteMetadataForObject(JsonConverter jsonConverter, ref WriteStack state, Utf8JsonWriter writer)
		{
			MetadataPropertyName metadataPropertyName = MetadataPropertyName.None;
			if (state.NewReferenceId != null)
			{
				writer.WriteString(s_metadataId, state.NewReferenceId);
				metadataPropertyName |= MetadataPropertyName.Id;
				state.NewReferenceId = null;
			}
			object polymorphicTypeDiscriminator = state.PolymorphicTypeDiscriminator;
			if (polymorphicTypeDiscriminator != null)
			{
				JsonEncodedText? customTypeDiscriminatorPropertyNameJsonEncoded = state.PolymorphicTypeResolver.CustomTypeDiscriminatorPropertyNameJsonEncoded;
				JsonEncodedText jsonEncodedText;
				if (customTypeDiscriminatorPropertyNameJsonEncoded.HasValue)
				{
					JsonEncodedText valueOrDefault = customTypeDiscriminatorPropertyNameJsonEncoded.GetValueOrDefault();
					jsonEncodedText = valueOrDefault;
				}
				else
				{
					jsonEncodedText = s_metadataType;
				}
				JsonEncodedText propertyName = jsonEncodedText;
				if (polymorphicTypeDiscriminator is string value)
				{
					writer.WriteString(propertyName, value);
				}
				else
				{
					writer.WriteNumber(propertyName, (int)polymorphicTypeDiscriminator);
				}
				metadataPropertyName |= MetadataPropertyName.Type;
				state.PolymorphicTypeDiscriminator = null;
			}
			return metadataPropertyName;
		}

		internal static MetadataPropertyName WriteMetadataForCollection(JsonConverter jsonConverter, ref WriteStack state, Utf8JsonWriter writer)
		{
			writer.WriteStartObject();
			MetadataPropertyName result = WriteMetadataForObject(jsonConverter, ref state, writer);
			writer.WritePropertyName(s_metadataValues);
			return result;
		}

		internal static bool TryGetReferenceForValue(object currentValue, ref WriteStack state, Utf8JsonWriter writer)
		{
			bool alreadyExists;
			string reference = state.ReferenceResolver.GetReference(currentValue, out alreadyExists);
			if (alreadyExists)
			{
				writer.WriteStartObject();
				writer.WriteString(s_metadataRef, reference);
				writer.WriteEndObject();
				state.PolymorphicTypeDiscriminator = null;
				state.PolymorphicTypeResolver = null;
			}
			else
			{
				state.NewReferenceId = reference;
			}
			return alreadyExists;
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static Task SerializeAsync<TValue>(Stream utf8Json, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			return typeInfo.SerializeAsync(utf8Json, value, cancellationToken);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static void Serialize<TValue>(Stream utf8Json, TValue value, JsonSerializerOptions? options = null)
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			typeInfo.Serialize(utf8Json, in value);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static Task SerializeAsync(Stream utf8Json, object? value, Type inputType, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			ValidateInputType(value, inputType);
			JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
			return typeInfo.SerializeAsObjectAsync(utf8Json, value, cancellationToken);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static void Serialize(Stream utf8Json, object? value, Type inputType, JsonSerializerOptions? options = null)
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			ValidateInputType(value, inputType);
			JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
			typeInfo.SerializeAsObject(utf8Json, value);
		}

		public static Task SerializeAsync<TValue>(Stream utf8Json, TValue value, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return jsonTypeInfo.SerializeAsync(utf8Json, value, cancellationToken);
		}

		public static void Serialize<TValue>(Stream utf8Json, TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			jsonTypeInfo.Serialize(utf8Json, in value);
		}

		public static Task SerializeAsync(Stream utf8Json, object? value, JsonTypeInfo jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return jsonTypeInfo.SerializeAsObjectAsync(utf8Json, value, cancellationToken);
		}

		public static void Serialize(Stream utf8Json, object? value, JsonTypeInfo jsonTypeInfo)
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			jsonTypeInfo.SerializeAsObject(utf8Json, value);
		}

		public static Task SerializeAsync(Stream utf8Json, object? value, Type inputType, JsonSerializerContext context, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			ValidateInputType(value, inputType);
			JsonTypeInfo typeInfo = GetTypeInfo(context, inputType);
			return typeInfo.SerializeAsObjectAsync(utf8Json, value, cancellationToken);
		}

		public static void Serialize(Stream utf8Json, object? value, Type inputType, JsonSerializerContext context)
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			ValidateInputType(value, inputType);
			JsonTypeInfo typeInfo = GetTypeInfo(context, inputType);
			typeInfo.SerializeAsObject(utf8Json, value);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static string Serialize<TValue>(TValue value, JsonSerializerOptions? options = null)
		{
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			return WriteString<TValue>(in value, typeInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static string Serialize(object? value, Type inputType, JsonSerializerOptions? options = null)
		{
			ValidateInputType(value, inputType);
			JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
			return WriteStringAsObject(value, typeInfo);
		}

		public static string Serialize<TValue>(TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return WriteString(in value, jsonTypeInfo);
		}

		public static string Serialize(object? value, JsonTypeInfo jsonTypeInfo)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			return WriteStringAsObject(value, jsonTypeInfo);
		}

		public static string Serialize(object? value, Type inputType, JsonSerializerContext context)
		{
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			ValidateInputType(value, inputType);
			JsonTypeInfo typeInfo = GetTypeInfo(context, inputType);
			return WriteStringAsObject(value, typeInfo);
		}

		private static string WriteString<TValue>(in TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			PooledByteBufferWriter bufferWriter;
			Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
			try
			{
				jsonTypeInfo.Serialize(writer, in value);
				return JsonReaderHelper.TranscodeHelper(bufferWriter.WrittenMemory.Span);
			}
			finally
			{
				Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
			}
		}

		private static string WriteStringAsObject(object value, JsonTypeInfo jsonTypeInfo)
		{
			PooledByteBufferWriter bufferWriter;
			Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
			try
			{
				jsonTypeInfo.SerializeAsObject(writer, value);
				return JsonReaderHelper.TranscodeHelper(bufferWriter.WrittenMemory.Span);
			}
			finally
			{
				Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
			}
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static void Serialize<TValue>(Utf8JsonWriter writer, TValue value, JsonSerializerOptions? options = null)
		{
			if (writer == null)
			{
				ThrowHelper.ThrowArgumentNullException("writer");
			}
			JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
			typeInfo.Serialize(writer, in value);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static void Serialize(Utf8JsonWriter writer, object? value, Type inputType, JsonSerializerOptions? options = null)
		{
			if (writer == null)
			{
				ThrowHelper.ThrowArgumentNullException("writer");
			}
			ValidateInputType(value, inputType);
			JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
			typeInfo.SerializeAsObject(writer, value);
		}

		public static void Serialize<TValue>(Utf8JsonWriter writer, TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
		{
			if (writer == null)
			{
				ThrowHelper.ThrowArgumentNullException("writer");
			}
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			jsonTypeInfo.Serialize(writer, in value);
		}

		public static void Serialize(Utf8JsonWriter writer, object? value, JsonTypeInfo jsonTypeInfo)
		{
			if (writer == null)
			{
				ThrowHelper.ThrowArgumentNullException("writer");
			}
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			jsonTypeInfo.EnsureConfigured();
			jsonTypeInfo.SerializeAsObject(writer, value);
		}

		public static void Serialize(Utf8JsonWriter writer, object? value, Type inputType, JsonSerializerContext context)
		{
			if (writer == null)
			{
				ThrowHelper.ThrowArgumentNullException("writer");
			}
			if (context == null)
			{
				ThrowHelper.ThrowArgumentNullException("context");
			}
			ValidateInputType(value, inputType);
			JsonTypeInfo typeInfo = GetTypeInfo(context, inputType);
			typeInfo.SerializeAsObject(writer, value);
		}
	}
	internal enum PolymorphicSerializationState : byte
	{
		None,
		PolymorphicReEntryStarted,
		PolymorphicReEntrySuspended,
		PolymorphicReEntryNotFound
	}
	internal static class Utf8JsonWriterCache
	{
		private sealed class ThreadLocalState
		{
			public readonly PooledByteBufferWriter BufferWriter;

			public readonly Utf8JsonWriter Writer;

			public int RentedWriters;

			public ThreadLocalState()
			{
				BufferWriter = PooledByteBufferWriter.CreateEmptyInstanceForCaching();
				Writer = Utf8JsonWriter.CreateEmptyInstanceForCaching();
			}
		}

		[ThreadStatic]
		private static ThreadLocalState t_threadLocalState;

		public static Utf8JsonWriter RentWriterAndBuffer(JsonSerializerOptions options, out PooledByteBufferWriter bufferWriter)
		{
			ThreadLocalState threadLocalState = t_threadLocalState ?? (t_threadLocalState = new ThreadLocalState());
			Utf8JsonWriter utf8JsonWriter;
			if (threadLocalState.RentedWriters++ == 0)
			{
				bufferWriter = threadLocalState.BufferWriter;
				utf8JsonWriter = threadLocalState.Writer;
				bufferWriter.InitializeEmptyInstance(options.DefaultBufferSize);
				utf8JsonWriter.Reset(bufferWriter, options.GetWriterOptions());
			}
			else
			{
				bufferWriter = new PooledByteBufferWriter(options.DefaultBufferSize);
				utf8JsonWriter = new Utf8JsonWriter(bufferWriter, options.GetWriterOptions());
			}
			return utf8JsonWriter;
		}

		public static Utf8JsonWriter RentWriter(JsonSerializerOptions options, PooledByteBufferWriter bufferWriter)
		{
			ThreadLocalState threadLocalState = t_threadLocalState ?? (t_threadLocalState = new ThreadLocalState());
			Utf8JsonWriter utf8JsonWriter;
			if (threadLocalState.RentedWriters++ == 0)
			{
				utf8JsonWriter = threadLocalState.Writer;
				utf8JsonWriter.Reset(bufferWriter, options.GetWriterOptions());
			}
			else
			{
				utf8JsonWriter = new Utf8JsonWriter(bufferWriter, options.GetWriterOptions());
			}
			return utf8JsonWriter;
		}

		public static void ReturnWriterAndBuffer(Utf8JsonWriter writer, PooledByteBufferWriter bufferWriter)
		{
			ThreadLocalState threadLocalState = t_threadLocalState;
			writer.ResetAllStateForCacheReuse();
			bufferWriter.ClearAndReturnBuffers();
			threadLocalState.RentedWriters--;
		}

		public static void ReturnWriter(Utf8JsonWriter writer)
		{
			ThreadLocalState threadLocalState = t_threadLocalState;
			writer.ResetAllStateForCacheReuse();
			threadLocalState.RentedWriters--;
		}
	}
	internal enum ConverterStrategy : byte
	{
		None = 0,
		Object = 1,
		Value = 2,
		Enumerable = 8,
		Dictionary = 0x10
	}
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public sealed class JsonSerializerOptions
	{
		internal sealed class CachingContext
		{
			private sealed class CacheEntry
			{
				public readonly bool HasResult;

				public readonly JsonTypeInfo TypeInfo;

				public readonly ExceptionDispatchInfo ExceptionDispatchInfo;

				public volatile bool IsNearestAncestorResolved;

				public CacheEntry NearestAncestor;

				public CacheEntry(JsonTypeInfo typeInfo)
				{
					TypeInfo = typeInfo;
					HasResult = typeInfo != null;
				}

				public CacheEntry(ExceptionDispatchInfo exception)
				{
					ExceptionDispatchInfo = exception;
					HasResult = true;
				}

				public JsonTypeInfo GetResult()
				{
					ExceptionDispatchInfo?.Throw();
					return TypeInfo;
				}
			}

			private readonly ConcurrentDictionary<Type, CacheEntry> _cache = new ConcurrentDictionary<Type, CacheEntry>();

			private readonly Func<Type, CacheEntry> _cacheEntryFactory;

			public JsonSerializerOptions Options { get; }

			public int HashCode { get; }

			public int Count => _cache.Count;

			public CachingContext(JsonSerializerOptions options, int hashCode)
			{
				Options = options;
				HashCode = hashCode;
				_cacheEntryFactory = (Type type) => CreateCacheEntry(type, this);
			}

			public JsonTypeInfo GetOrAddTypeInfo(Type type, bool fallBackToNearestAncestorType = false)
			{
				CacheEntry orAddCacheEntry = GetOrAddCacheEntry(type);
				if (!fallBackToNearestAncestorType || orAddCacheEntry.HasResult)
				{
					return orAddCacheEntry.GetResult();
				}
				return FallBackToNearestAncestor(type, orAddCacheEntry);
			}

			public bool TryGetTypeInfo(Type type, [NotNullWhen(true)] out JsonTypeInfo typeInfo)
			{
				_cache.TryGetValue(type, out var value);
				typeInfo = value?.TypeInfo;
				return typeInfo != null;
			}

			public void Clear()
			{
				_cache.Clear();
			}

			private CacheEntry GetOrAddCacheEntry(Type type)
			{
				return _cache.GetOrAdd(type, _cacheEntryFactory);
			}

			private static CacheEntry CreateCacheEntry(Type type, CachingContext context)
			{
				try
				{
					JsonTypeInfo typeInfoNoCaching = context.Options.GetTypeInfoNoCaching(type);
					return new CacheEntry(typeInfoNoCaching);
				}
				catch (Exception source)
				{
					ExceptionDispatchInfo exception = ExceptionDispatchInfo.Capture(source);
					return new CacheEntry(exception);
				}
			}

			private JsonTypeInfo FallBackToNearestAncestor(Type type, CacheEntry entry)
			{
				return (entry.IsNearestAncestorResolved ? entry.NearestAncestor : DetermineNearestAncestor(type, entry))?.GetResult();
			}

			[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern", Justification = "We only need to examine the interface types that are supported by the underlying resolver.")]
			private CacheEntry DetermineNearestAncestor(Type type, CacheEntry entry)
			{
				CacheEntry cacheEntry = null;
				Type type2 = null;
				Type baseType = type.BaseType;
				while (baseType != null && !(baseType == JsonTypeInfo.ObjectType))
				{
					cacheEntry = GetOrAddCacheEntry(baseType);
					if (cacheEntry.HasResult)
					{
						type2 = baseType;
						break;
					}
					baseType = baseType.BaseType;
				}
				Type[] interfaces = type.GetInterfaces();
				foreach (Type type3 in interfaces)
				{
					CacheEntry orAddCacheEntry = GetOrAddCacheEntry(type3);
					if (!orAddCacheEntry.HasResult)
					{
						continue;
					}
					if (type2 != null)
					{
						if (type3.IsAssignableFrom(type2))
						{
							continue;
						}
						if (!type2.IsAssignableFrom(type3))
						{
							NotSupportedException notSupportedException_AmbiguousMetadataForType = ThrowHelper.GetNotSupportedException_AmbiguousMetadataForType(type, type2, type3);
							cacheEntry = new CacheEntry(ExceptionDispatchInfo.Capture(notSupportedException_AmbiguousMetadataForType));
							break;
						}
					}
					cacheEntry = orAddCacheEntry;
					type2 = type3;
				}
				entry.NearestAncestor = cacheEntry;
				entry.IsNearestAncestorResolved = true;
				return cacheEntry;
			}
		}

		internal static class TrackedCachingContexts
		{
			private const int MaxTrackedContexts = 64;

			private static readonly WeakReference<CachingContext>[] s_trackedContexts = new WeakReference<CachingContext>[64];

			private static readonly EqualityComparer s_optionsComparer = new EqualityComparer();

			public static CachingContext GetOrCreate(JsonSerializerOptions options)
			{
				int hashCode = s_optionsComparer.GetHashCode(options);
				if (TryGetContext(options, hashCode, out var firstUnpopulatedIndex, out var result))
				{
					return result;
				}
				if (firstUnpopulatedIndex < 0)
				{
					return new CachingContext(options, hashCode);
				}
				lock (s_trackedContexts)
				{
					if (TryGetContext(options, hashCode, out firstUnpopulatedIndex, out result))
					{
						return result;
					}
					CachingContext cachingContext = new CachingContext(options, hashCode);
					if (firstUnpopulatedIndex >= 0)
					{
						ref WeakReference<CachingContext> reference = ref s_trackedContexts[firstUnpopulatedIndex];
						if (reference == null)
						{
							reference = new WeakReference<CachingContext>(cachingContext);
						}
						else
						{
							reference.SetTarget(cachingContext);
						}
					}
					return cachingContext;
				}
			}

			private static bool TryGetContext(JsonSerializerOptions options, int hashCode, out int firstUnpopulatedIndex, [NotNullWhen(true)] out CachingContext result)
			{
				WeakReference<CachingContext>[] array = s_trackedContexts;
				firstUnpopulatedIndex = -1;
				for (int i = 0; i < array.Length; i++)
				{
					WeakReference<CachingContext> weakReference = array[i];
					if (weakReference == null || !weakReference.TryGetTarget(out var target))
					{
						if (firstUnpopulatedIndex < 0)
						{
							firstUnpopulatedIndex = i;
						}
					}
					else if (hashCode == target.HashCode && s_optionsComparer.Equals(options, target.Options))
					{
						result = target;
						return true;
					}
				}
				result = null;
				return false;
			}
		}

		private sealed class EqualityComparer : IEqualityComparer<JsonSerializerOptions>
		{
			private struct HashCode
			{
				private int _hashCode;

				public void Add<T>(T value)
				{
					_hashCode = (_hashCode, value).GetHashCode();
				}

				public int ToHashCode()
				{
					return _hashCode;
				}
			}

			public bool Equals(JsonSerializerOptions left, JsonSerializerOptions right)
			{
				if (left._dictionaryKeyPolicy == right._dictionaryKeyPolicy && left._jsonPropertyNamingPolicy == right._jsonPropertyNamingPolicy && left._readCommentHandling == right._readCommentHandling && left._referenceHandler == right._referenceHandler && left._encoder == right._encoder && left._defaultIgnoreCondition == right._defaultIgnoreCondition && left._numberHandling == right._numberHandling && left._preferredObjectCreationHandling == right._preferredObjectCreationHandling && left._unknownTypeHandling == right._unknownTypeHandling && left._unmappedMemberHandling == right._unmappedMemberHandling && left._defaultBufferSize == right._defaultBufferSize && left._maxDepth == right._maxDepth && left._allowTrailingCommas == right._allowTrailingCommas && left._ignoreNullValues == right._ignoreNullValues && left._ignoreReadOnlyProperties == right._ignoreReadOnlyProperties && left._ignoreReadonlyFields == right._ignoreReadonlyFields && left._includeFields == right._includeFields && left._propertyNameCaseInsensitive == right._propertyNameCaseInsensitive && left._writeIndented == right._writeIndented && left._typeInfoResolver == right._typeInfoResolver)
				{
					return CompareLists<JsonConverter>(left._converters, right._converters);
				}
				return false;
				static bool CompareLists<TValue>(ConfigurationList<TValue> configurationList, ConfigurationList<TValue> configurationList2) where TValue : class
				{
					if (configurationList == null)
					{
						if (configurationList2 != null)
						{
							return configurationList2.Count == 0;
						}
						return true;
					}
					if (configurationList2 == null)
					{
						return configurationList.Count == 0;
					}
					int count;
					if ((count = configurationList.Count) != configurationList2.Count)
					{
						return false;
					}
					for (int i = 0; i < count; i++)
					{
						if (configurationList[i] != configurationList2[i])
						{
							return false;
						}
					}
					return true;
				}
			}

			public int GetHashCode(JsonSerializerOptions options)
			{
				HashCode hc = default(HashCode);
				AddHashCode<JsonNamingPolicy>(ref hc, options._dictionaryKeyPolicy);
				AddHashCode<JsonNamingPolicy>(ref hc, options._jsonPropertyNamingPolicy);
				AddHashCode<JsonCommentHandling>(ref hc, options._readCommentHandling);
				AddHashCode<ReferenceHandler>(ref hc, options._referenceHandler);
				AddHashCode<JavaScriptEncoder>(ref hc, options._encoder);
				AddHashCode<JsonIgnoreCondition>(ref hc, options._defaultIgnoreCondition);
				AddHashCode<JsonNumberHandling>(ref hc, options._numberHandling);
				AddHashCode<JsonObjectCreationHandling>(ref hc, options._preferredObjectCreationHandling);
				AddHashCode<JsonUnknownTypeHandling>(ref hc, options._unknownTypeHandling);
				AddHashCode<JsonUnmappedMemberHandling>(ref hc, options._unmappedMemberHandling);
				AddHashCode<int>(ref hc, options._defaultBufferSize);
				AddHashCode<int>(ref hc, options._maxDepth);
				AddHashCode<bool>(ref hc, options._allowTrailingCommas);
				AddHashCode<bool>(ref hc, options._ignoreNullValues);
				AddHashCode<bool>(ref hc, options._ignoreReadOnlyProperties);
				AddHashCode<bool>(ref hc, options._ignoreReadonlyFields);
				AddHashCode<bool>(ref hc, options._includeFields);
				AddHashCode<bool>(ref hc, options._propertyNameCaseInsensitive);
				AddHashCode<bool>(ref hc, options._writeIndented);
				AddHashCode<IJsonTypeInfoResolver>(ref hc, options._typeInfoResolver);
				AddListHashCode<JsonConverter>(ref hc, options._converters);
				return hc.ToHashCode();
				static void AddHashCode<TValue>(ref HashCode reference, TValue value)
				{
					if (typeof(TValue).IsValueType)
					{
						reference.Add(value);
					}
					else
					{
						reference.Add(RuntimeHelpers.GetHashCode(value));
					}
				}
				static void AddListHashCode<TValue>(ref HashCode hc2, ConfigurationList<TValue> list)
				{
					if (list != null)
					{
						int count = list.Count;
						for (int i = 0; i < count; i++)
						{
							AddHashCode<TValue>(ref hc2, list[i]);
						}
					}
				}
			}
		}

		internal static class TrackedOptionsInstances
		{
			public static ConditionalWeakTable<JsonSerializerOptions, object> All { get; } = new ConditionalWeakTable<JsonSerializerOptions, object>();
		}

		private sealed class ConverterList : ConfigurationList<JsonConverter>
		{
			private readonly JsonSerializerOptions _options;

			public override bool IsReadOnly => _options.IsReadOnly;

			public ConverterList(JsonSerializerOptions options, IList<JsonConverter> source = null)
				: base((IEnumerable<JsonConverter>)source)
			{
				_options = options;
			}

			protected override void OnCollectionModifying()
			{
				_options.VerifyMutable();
			}
		}

		private sealed class OptionsBoundJsonTypeInfoResolverChain : JsonTypeInfoResolverChain
		{
			private readonly JsonSerializerOptions _options;

			public override bool IsReadOnly => _options.IsReadOnly;

			public OptionsBoundJsonTypeInfoResolverChain(JsonSerializerOptions options)
			{
				_options = options;
				AddFlattened(options._typeInfoResolver);
			}

			protected override void ValidateAddedValue(IJsonTypeInfoResolver item)
			{
				if (item == this || item == _options._typeInfoResolver)
				{
					ThrowHelper.ThrowInvalidOperationException_InvalidChainedResolver();
				}
			}

			protected override void OnCollectionModifying()
			{
				_options.VerifyMutable();
				_options._typeInfoResolver = this;
			}
		}

		private CachingContext _cachingContext;

		private volatile JsonTypeInfo _lastTypeInfo;

		private JsonTypeInfo _objectTypeInfo;

		internal const int BufferSizeDefault = 16384;

		internal const int DefaultMaxDepth = 64;

		private static JsonSerializerOptions s_defaultOptions;

		private IJsonTypeInfoResolver _typeInfoResolver;

		private JsonNamingPolicy _dictionaryKeyPolicy;

		private JsonNamingPolicy _jsonPropertyNamingPolicy;

		private JsonCommentHandling _readCommentHandling;

		private ReferenceHandler _referenceHandler;

		private JavaScriptEncoder _encoder;

		private ConverterList _converters;

		private JsonIgnoreCondition _defaultIgnoreCondition;

		private JsonNumberHandling _numberHandling;

		private JsonObjectCreationHandling _preferredObjectCreationHandling;

		private JsonUnknownTypeHandling _unknownTypeHandling;

		private JsonUnmappedMemberHandling _unmappedMemberHandling;

		private int _defaultBufferSize = 16384;

		private int _maxDepth;

		private bool _allowTrailingCommas;

		private bool _ignoreNullValues;

		private bool _ignoreReadOnlyProperties;

		private bool _ignoreReadonlyFields;

		private bool _includeFields;

		private bool _propertyNameCaseInsensitive;

		private bool _writeIndented;

		private OptionsBoundJsonTypeInfoResolverChain _typeInfoResolverChain;

		private bool? _canUseFastPathSerializationLogic;

		internal ReferenceHandlingStrategy ReferenceHandlingStrategy;

		private volatile bool _isReadOnly;

		private volatile bool _isConfiguredForJsonSerializer;

		private IJsonTypeInfoResolver _effectiveJsonTypeInfoResolver;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		internal CachingContext CacheContext => _cachingContext ?? (_cachingContext = TrackedCachingContexts.GetOrCreate(this));

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		internal JsonTypeInfo ObjectTypeInfo => _objectTypeInfo ?? (_objectTypeInfo = GetTypeInfoInternal(JsonTypeInfo.ObjectType, ensureConfigured: true, true));

		public IList<JsonConverter> Converters => _converters ?? (_converters = new ConverterList(this));

		public static JsonSerializerOptions Default
		{
			[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
			[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
			get
			{
				JsonSerializerOptions orCreateDefaultOptionsInstance = s_defaultOptions;
				if (orCreateDefaultOptionsInstance == null)
				{
					orCreateDefaultOptionsInstance = GetOrCreateDefaultOptionsInstance();
				}
				return orCreateDefaultOptionsInstance;
			}
		}

		public IJsonTypeInfoResolver? TypeInfoResolver
		{
			get
			{
				return _typeInfoResolver;
			}
			set
			{
				VerifyMutable();
				OptionsBoundJsonTypeInfoResolverChain typeInfoResolverChain = _typeInfoResolverChain;
				if (typeInfoResolverChain != null && typeInfoResolverChain != value)
				{
					typeInfoResolverChain.Clear();
					typeInfoResolverChain.AddFlattened(value);
				}
				_typeInfoResolver = value;
			}
		}

		public IList<IJsonTypeInfoResolver> TypeInfoResolverChain => _typeInfoResolverChain ?? (_typeInfoResolverChain = new OptionsBoundJsonTypeInfoResolverChain(this));

		public bool AllowTrailingCommas
		{
			get
			{
				return _allowTrailingCommas;
			}
			set
			{
				VerifyMutable();
				_allowTrailingCommas = value;
			}
		}

		public int DefaultBufferSize
		{
			get
			{
				return _defaultBufferSize;
			}
			set
			{
				VerifyMutable();
				if (value < 1)
				{
					throw new ArgumentException(System.SR.SerializationInvalidBufferSize);
				}
				_defaultBufferSize = value;
			}
		}

		public JavaScriptEncoder? Encoder
		{
			get
			{
				return _encoder;
			}
			set
			{
				VerifyMutable();
				_encoder = value;
			}
		}

		public JsonNamingPolicy? DictionaryKeyPolicy
		{
			get
			{
				return _dictionaryKeyPolicy;
			}
			set
			{
				VerifyMutable();
				_dictionaryKeyPolicy = value;
			}
		}

		[Obsolete("JsonSerializerOptions.IgnoreNullValues is obsolete. To ignore null values when serializing, set DefaultIgnoreCondition to JsonIgnoreCondition.WhenWritingNull.", DiagnosticId = "SYSLIB0020", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool IgnoreNullValues
		{
			get
			{
				return _ignoreNullValues;
			}
			set
			{
				VerifyMutable();
				if (value && _defaultIgnoreCondition != JsonIgnoreCondition.Never)
				{
					throw new InvalidOperationException(System.SR.DefaultIgnoreConditionAlreadySpecified);
				}
				_ignoreNullValues = value;
			}
		}

		public JsonIgnoreCondition DefaultIgnoreCondition
		{
			get
			{
				return _defaultIgnoreCondition;
			}
			set
			{
				VerifyMutable();
				switch (value)
				{
				case JsonIgnoreCondition.Always:
					throw new ArgumentException(System.SR.DefaultIgnoreConditionInvalid);
				default:
					if (_ignoreNullValues)
					{
						throw new InvalidOperationException(System.SR.DefaultIgnoreConditionAlreadySpecified);
					}
					break;
				case JsonIgnoreCondition.Never:
					break;
				}
				_defaultIgnoreCondition = value;
			}
		}

		public JsonNumberHandling NumberHandling
		{
			get
			{
				return _numberHandling;
			}
			set
			{
				VerifyMutable();
				if (!JsonSerializer.IsValidNumberHandlingValue(value))
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_numberHandling = value;
			}
		}

		public JsonObjectCreationHandling PreferredObjectCreationHandling
		{
			get
			{
				return _preferredObjectCreationHandling;
			}
			set
			{
				VerifyMutable();
				if (!JsonSerializer.IsValidCreationHandlingValue(value))
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_preferredObjectCreationHandling = value;
			}
		}

		public bool IgnoreReadOnlyProperties
		{
			get
			{
				return _ignoreReadOnlyProperties;
			}
			set
			{
				VerifyMutable();
				_ignoreReadOnlyProperties = value;
			}
		}

		public bool IgnoreReadOnlyFields
		{
			get
			{
				return _ignoreReadonlyFields;
			}
			set
			{
				VerifyMutable();
				_ignoreReadonlyFields = value;
			}
		}

		public bool IncludeFields
		{
			get
			{
				return _includeFields;
			}
			set
			{
				VerifyMutable();
				_includeFields = value;
			}
		}

		public int MaxDepth
		{
			get
			{
				return _maxDepth;
			}
			set
			{
				VerifyMutable();
				if (value < 0)
				{
					ThrowHelper.ThrowArgumentOutOfRangeException_MaxDepthMustBePositive("value");
				}
				_maxDepth = value;
				EffectiveMaxDepth = ((value == 0) ? 64 : value);
			}
		}

		internal int EffectiveMaxDepth { get; private set; } = 64;

		public JsonNamingPolicy? PropertyNamingPolicy
		{
			get
			{
				return _jsonPropertyNamingPolicy;
			}
			set
			{
				VerifyMutable();
				_jsonPropertyNamingPolicy = value;
			}
		}

		public bool PropertyNameCaseInsensitive
		{
			get
			{
				return _propertyNameCaseInsensitive;
			}
			set
			{
				VerifyMutable();
				_propertyNameCaseInsensitive = value;
			}
		}

		public JsonCommentHandling ReadCommentHandling
		{
			get
			{
				return _readCommentHandling;
			}
			set
			{
				VerifyMutable();
				if ((int)value > 1)
				{
					throw new ArgumentOutOfRangeException("value", System.SR.JsonSerializerDoesNotSupportComments);
				}
				_readCommentHandling = value;
			}
		}

		public JsonUnknownTypeHandling UnknownTypeHandling
		{
			get
			{
				return _unknownTypeHandling;
			}
			set
			{
				VerifyMutable();
				_unknownTypeHandling = value;
			}
		}

		public JsonUnmappedMemberHandling UnmappedMemberHandling
		{
			get
			{
				return _unmappedMemberHandling;
			}
			set
			{
				VerifyMutable();
				_unmappedMemberHandling = value;
			}
		}

		public bool WriteIndented
		{
			get
			{
				return _writeIndented;
			}
			set
			{
				VerifyMutable();
				_writeIndented = value;
			}
		}

		public ReferenceHandler? ReferenceHandler
		{
			get
			{
				return _referenceHandler;
			}
			set
			{
				VerifyMutable();
				_referenceHandler = value;
				ReferenceHandlingStrategy = value?.HandlingStrategy ?? ReferenceHandlingStrategy.None;
			}
		}

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		internal bool CanUseFastPathSerializationLogic
		{
			get
			{
				bool valueOrDefault = _canUseFastPathSerializationLogic == true;
				if (!_canUseFastPathSerializationLogic.HasValue)
				{
					valueOrDefault = TypeInfoResolver.IsCompatibleWithOptions(this);
					_canUseFastPathSerializationLogic = valueOrDefault;
					return valueOrDefault;
				}
				return valueOrDefault;
			}
		}

		public bool IsReadOnly => _isReadOnly;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private string DebuggerDisplay => string.Format("TypeInfoResolver = {0}, IsReadOnly = {1}", TypeInfoResolver?.ToString() ?? "<null>", IsReadOnly);

		public JsonTypeInfo GetTypeInfo(Type type)
		{
			if ((object)type == null)
			{
				ThrowHelper.ThrowArgumentNullException("type");
			}
			if (JsonTypeInfo.IsInvalidForSerialization(type))
			{
				ThrowHelper.ThrowArgumentException_CannotSerializeInvalidType("type", type, null, null);
			}
			return GetTypeInfoInternal(type, ensureConfigured: true, true, resolveIfMutable: true);
		}

		public bool TryGetTypeInfo(Type type, [NotNullWhen(true)] out JsonTypeInfo? typeInfo)
		{
			if ((object)type == null)
			{
				ThrowHelper.ThrowArgumentNullException("type");
			}
			if (JsonTypeInfo.IsInvalidForSerialization(type))
			{
				ThrowHelper.ThrowArgumentException_CannotSerializeInvalidType("type", type, null, null);
			}
			typeInfo = GetTypeInfoInternal(type, ensureConfigured: true, null, resolveIfMutable: true);
			return typeInfo != null;
		}

		[return: NotNullIfNotNull("ensureNotNull")]
		internal JsonTypeInfo GetTypeInfoInternal(Type type, bool ensureConfigured = true, bool? ensureNotNull = true, bool resolveIfMutable = false, bool fallBackToNearestAncestorType = false)
		{
			JsonTypeInfo jsonTypeInfo = null;
			if (IsReadOnly)
			{
				jsonTypeInfo = CacheContext.GetOrAddTypeInfo(type, fallBackToNearestAncestorType);
				if (ensureConfigured)
				{
					jsonTypeInfo?.EnsureConfigured();
				}
			}
			else if (resolveIfMutable)
			{
				jsonTypeInfo = GetTypeInfoNoCaching(type);
			}
			if (jsonTypeInfo == null && ensureNotNull == true)
			{
				ThrowHelper.ThrowNotSupportedException_NoMetadataForType(type, TypeInfoResolver);
			}
			return jsonTypeInfo;
		}

		internal bool TryGetTypeInfoCached(Type type, [NotNullWhen(true)] out JsonTypeInfo typeInfo)
		{
			if (_cachingContext == null)
			{
				typeInfo = null;
				return false;
			}
			return _cachingContext.TryGetTypeInfo(type, out typeInfo);
		}

		internal JsonTypeInfo GetTypeInfoForRootType(Type type, bool fallBackToNearestAncestorType = false)
		{
			JsonTypeInfo jsonTypeInfo = _lastTypeInfo;
			if (jsonTypeInfo?.Type != type)
			{
				bool fallBackToNearestAncestorType2 = fallBackToNearestAncestorType;
				jsonTypeInfo = (_lastTypeInfo = GetTypeInfoInternal(type, ensureConfigured: true, true, resolveIfMutable: false, fallBackToNearestAncestorType2));
			}
			return jsonTypeInfo;
		}

		internal bool TryGetPolymorphicTypeInfoForRootType(object rootValue, [NotNullWhen(true)] out JsonTypeInfo polymorphicTypeInfo)
		{
			Type type = rootValue.GetType();
			if (type != JsonTypeInfo.ObjectType)
			{
				polymorphicTypeInfo = GetTypeInfoForRootType(type, fallBackToNearestAncestorType: true);
				JsonTypeInfo ancestorPolymorphicType = polymorphicTypeInfo.AncestorPolymorphicType;
				if (ancestorPolymorphicType != null)
				{
					polymorphicTypeInfo = ancestorPolymorphicType;
				}
				return true;
			}
			polymorphicTypeInfo = null;
			return false;
		}

		internal void ClearCaches()
		{
			_cachingContext?.Clear();
			_lastTypeInfo = null;
			_objectTypeInfo = null;
		}

		[RequiresUnreferencedCode("Getting a converter for a type may require reflection which depends on unreferenced code.")]
		[RequiresDynamicCode("Getting a converter for a type may require reflection which depends on runtime code generation.")]
		public JsonConverter GetConverter(Type typeToConvert)
		{
			if ((object)typeToConvert == null)
			{
				ThrowHelper.ThrowArgumentNullException("typeToConvert");
			}
			if (JsonSerializer.IsReflectionEnabledByDefault && _typeInfoResolver == null)
			{
				return DefaultJsonTypeInfoResolver.GetConverterForType(typeToConvert, this);
			}
			return GetConverterInternal(typeToConvert);
		}

		internal JsonConverter GetConverterInternal(Type typeToConvert)
		{
			JsonTypeInfo typeInfoInternal = GetTypeInfoInternal(typeToConvert, ensureConfigured: false, true, resolveIfMutable: true);
			return typeInfoInternal.Converter;
		}

		internal JsonConverter GetConverterFromList(Type typeToConvert)
		{
			ConverterList converters = _converters;
			if (converters != null)
			{
				foreach (JsonConverter item in converters)
				{
					if (item.CanConvert(typeToConvert))
					{
						return item;
					}
				}
			}
			return null;
		}

		[return: NotNullIfNotNull("converter")]
		internal JsonConverter ExpandConverterFactory(JsonConverter converter, Type typeToConvert)
		{
			if (converter is JsonConverterFactory jsonConverterFactory)
			{
				converter = jsonConverterFactory.GetConverterInternal(typeToConvert, this);
			}
			return converter;
		}

		internal static void CheckConverterNullabilityIsSameAsPropertyType(JsonConverter converter, Type propertyType)
		{
			if (propertyType.IsValueType && converter.IsValueType && (propertyType.IsNullableOfT() ^ converter.Type.IsNullableOfT()))
			{
				ThrowHelper.ThrowInvalidOperationException_ConverterCanConvertMultipleTypes(propertyType, converter);
			}
		}

		public JsonSerializerOptions()
		{
			TrackOptionsInstance(this);
		}

		public JsonSerializerOptions(JsonSerializerOptions options)
		{
			if (options == null)
			{
				ThrowHelper.ThrowArgumentNullException("options");
			}
			_dictionaryKeyPolicy = options._dictionaryKeyPolicy;
			_jsonPropertyNamingPolicy = options._jsonPropertyNamingPolicy;
			_readCommentHandling = options._readCommentHandling;
			_referenceHandler = options._referenceHandler;
			ConverterList converters = options._converters;
			_converters = ((converters != null) ? new ConverterList(this, converters) : null);
			_encoder = options._encoder;
			_defaultIgnoreCondition = options._defaultIgnoreCondition;
			_numberHandling = options._numberHandling;
			_preferredObjectCreationHandling = options._preferredObjectCreationHandling;
			_unknownTypeHandling = options._unknownTypeHandling;
			_unmappedMemberHandling = options._unmappedMemberHandling;
			_defaultBufferSize = options._defaultBufferSize;
			_maxDepth = options._maxDepth;
			_allowTrailingCommas = options._allowTrailingCommas;
			_ignoreNullValues = options._ignoreNullValues;
			_ignoreReadOnlyProperties = options._ignoreReadOnlyProperties;
			_ignoreReadonlyFields = options._ignoreReadonlyFields;
			_includeFields = options._includeFields;
			_propertyNameCaseInsensitive = options._propertyNameCaseInsensitive;
			_writeIndented = options._writeIndented;
			_typeInfoResolver = options._typeInfoResolver;
			EffectiveMaxDepth = options.EffectiveMaxDepth;
			ReferenceHandlingStrategy = options.ReferenceHandlingStrategy;
			TrackOptionsInstance(this);
		}

		public JsonSerializerOptions(JsonSerializerDefaults defaults)
			: this()
		{
			switch (defaults)
			{
			case JsonSerializerDefaults.Web:
				_propertyNameCaseInsensitive = true;
				_jsonPropertyNamingPolicy = JsonNamingPolicy.CamelCase;
				_numberHandling = JsonNumberHandling.AllowReadingFromString;
				break;
			default:
				throw new ArgumentOutOfRangeException("defaults");
			case JsonSerializerDefaults.General:
				break;
			}
		}

		private static void TrackOptionsInstance(JsonSerializerOptions options)
		{
			TrackedOptionsInstances.All.Add(options, null);
		}

		[Obsolete("JsonSerializerOptions.AddContext is obsolete. To register a JsonSerializerContext, use either the TypeInfoResolver or TypeInfoResolverChain properties.", DiagnosticId = "SYSLIB0049", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public void AddContext<TContext>() where TContext : JsonSerializerContext, new()
		{
			VerifyMutable();
			TContext val = new TContext();
			val.AssociateWithOptions(this);
		}

		public void MakeReadOnly()
		{
			if (_typeInfoResolver == null)
			{
				ThrowHelper.ThrowInvalidOperationException_JsonSerializerOptionsNoTypeInfoResolverSpecified();
			}
			_isReadOnly = true;
		}

		[RequiresUnreferencedCode("Populating unconfigured TypeInfoResolver properties with the reflection resolver requires unreferenced code.")]
		[RequiresDynamicCode("Populating unconfigured TypeInfoResolver properties with the reflection resolver requires runtime code generation.")]
		public void MakeReadOnly(bool populateMissingResolver)
		{
			if (populateMissingResolver)
			{
				if (!_isConfiguredForJsonSerializer)
				{
					ConfigureForJsonSerializer();
				}
			}
			else
			{
				MakeReadOnly();
			}
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private void ConfigureForJsonSerializer()
		{
			if (JsonSerializer.IsReflectionEnabledByDefault)
			{
				DefaultJsonTypeInfoResolver defaultJsonTypeInfoResolver = DefaultJsonTypeInfoResolver.RootDefaultInstance();
				IJsonTypeInfoResolver typeInfoResolver = _typeInfoResolver;
				if (typeInfoResolver != null)
				{
					if (typeInfoResolver is JsonSerializerContext jsonSerializerContext && AppContextSwitchHelper.IsSourceGenReflectionFallbackEnabled)
					{
						_effectiveJsonTypeInfoResolver = JsonTypeInfoResolver.Combine(jsonSerializerContext, defaultJsonTypeInfoResolver);
						CachingContext cachingContext = _cachingContext;
						if (cachingContext != null)
						{
							if (cachingContext.Options != this && !cachingContext.Options._isConfiguredForJsonSerializer)
							{
								cachingContext.Options.ConfigureForJsonSerializer();
							}
							else
							{
								cachingContext.Clear();
							}
						}
					}
				}
				else
				{
					_typeInfoResolver = defaultJsonTypeInfoResolver;
				}
			}
			else
			{
				IJsonTypeInfoResolver typeInfoResolver2 = _typeInfoResolver;
				if ((typeInfoResolver2 == null || typeInfoResolver2 is EmptyJsonTypeInfoResolver) ? true : false)
				{
					ThrowHelper.ThrowInvalidOperationException_JsonSerializerIsReflectionDisabled();
				}
			}
			_isReadOnly = true;
			_isConfiguredForJsonSerializer = true;
		}

		private JsonTypeInfo GetTypeInfoNoCaching(Type type)
		{
			IJsonTypeInfoResolver jsonTypeInfoResolver = _effectiveJsonTypeInfoResolver ?? _typeInfoResolver;
			if (jsonTypeInfoResolver == null)
			{
				return null;
			}
			JsonTypeInfo jsonTypeInfo = jsonTypeInfoResolver.GetTypeInfo(type, this);
			if (jsonTypeInfo != null)
			{
				if (jsonTypeInfo.Type != type)
				{
					ThrowHelper.ThrowInvalidOperationException_ResolverTypeNotCompatible(type, jsonTypeInfo.Type);
				}
				if (jsonTypeInfo.Options != this)
				{
					ThrowHelper.ThrowInvalidOperationException_ResolverTypeInfoOptionsNotCompatible();
				}
			}
			else if (type == JsonTypeInfo.ObjectType)
			{
				SlimObjectConverter converter = new SlimObjectConverter(jsonTypeInfoResolver);
				jsonTypeInfo = new JsonTypeInfo<object>(converter, this);
			}
			return jsonTypeInfo;
		}

		internal JsonDocumentOptions GetDocumentOptions()
		{
			return new JsonDocumentOptions
			{
				AllowTrailingCommas = AllowTrailingCommas,
				CommentHandling = ReadCommentHandling,
				MaxDepth = MaxDepth
			};
		}

		internal JsonNodeOptions GetNodeOptions()
		{
			return new JsonNodeOptions
			{
				PropertyNameCaseInsensitive = PropertyNameCaseInsensitive
			};
		}

		internal JsonReaderOptions GetReaderOptions()
		{
			return new JsonReaderOptions
			{
				AllowTrailingCommas = AllowTrailingCommas,
				CommentHandling = ReadCommentHandling,
				MaxDepth = EffectiveMaxDepth
			};
		}

		internal JsonWriterOptions GetWriterOptions()
		{
			return new JsonWriterOptions
			{
				Encoder = Encoder,
				Indented = WriteIndented,
				MaxDepth = EffectiveMaxDepth,
				SkipValidation = true
			};
		}

		internal void VerifyMutable()
		{
			if (_isReadOnly)
			{
				ThrowHelper.ThrowInvalidOperationException_SerializerOptionsReadOnly(_typeInfoResolver as JsonSerializerContext);
			}
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private static JsonSerializerOptions GetOrCreateDefaultOptionsInstance()
		{
			JsonSerializerOptions jsonSerializerOptions = new JsonSerializerOptions();
			IJsonTypeInfoResolver typeInfoResolver;
			if (!JsonSerializer.IsReflectionEnabledByDefault)
			{
				typeInfoResolver = JsonTypeInfoResolver.Empty;
			}
			else
			{
				IJsonTypeInfoResolver jsonTypeInfoResolver = DefaultJsonTypeInfoResolver.RootDefaultInstance();
				typeInfoResolver = jsonTypeInfoResolver;
			}
			jsonSerializerOptions.TypeInfoResolver = typeInfoResolver;
			jsonSerializerOptions._isReadOnly = true;
			JsonSerializerOptions jsonSerializerOptions2 = jsonSerializerOptions;
			return Interlocked.CompareExchange(ref s_defaultOptions, jsonSerializerOptions2, null) ?? jsonSerializerOptions2;
		}
	}
	[Flags]
	internal enum MetadataPropertyName : byte
	{
		None = 0,
		Values = 1,
		Id = 2,
		Ref = 4,
		Type = 8
	}
	[StructLayout(LayoutKind.Auto)]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	internal struct ReadStack
	{
		public ReadStackFrame Current;

		private ReadStackFrame[] _stack;

		private int _count;

		private int _continuationCount;

		public long BytesConsumed;

		public bool ReadAhead;

		public ReferenceResolver ReferenceResolver;

		public bool SupportContinuation;

		public string ReferenceId;

		public object PolymorphicTypeDiscriminator;

		public bool PreserveReferences;

		public readonly ref ReadStackFrame Parent => ref _stack[_count - 2];

		public readonly JsonPropertyInfo ParentProperty
		{
			get
			{
				if (!Current.HasParentObject)
				{
					return null;
				}
				return Parent.JsonPropertyInfo;
			}
		}

		public bool IsContinuation => _continuationCount != 0;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private string DebuggerDisplay => $"Path = {JsonPath()}, Current = ConverterStrategy.{Current.JsonTypeInfo?.Converter.ConverterStrategy}, {Current.JsonTypeInfo?.Type.Name}";

		private void EnsurePushCapacity()
		{
			if (_stack == null)
			{
				_stack = new ReadStackFrame[4];
			}
			else if (_count - 1 == _stack.Length)
			{
				Array.Resize(ref _stack, 2 * _stack.Length);
			}
		}

		internal void Initialize(JsonTypeInfo jsonTypeInfo, bool supportContinuation = false)
		{
			JsonSerializerOptions options = jsonTypeInfo.Options;
			if (options.ReferenceHandlingStrategy == ReferenceHandlingStrategy.Preserve)
			{
				ReferenceResolver = options.ReferenceHandler.CreateResolver(writing: false);
				PreserveReferences = true;
			}
			Current.JsonTypeInfo = jsonTypeInfo;
			Current.JsonPropertyInfo = jsonTypeInfo.PropertyInfoForTypeInfo;
			Current.NumberHandling = Current.JsonPropertyInfo.EffectiveNumberHandling;
			Current.CanContainMetadata = PreserveReferences || (jsonTypeInfo.PolymorphicTypeResolver?.UsesTypeDiscriminators ?? false);
			SupportContinuation = supportContinuation;
		}

		public void Push()
		{
			if (_continuationCount == 0)
			{
				if (_count == 0)
				{
					_count = 1;
				}
				else
				{
					JsonTypeInfo jsonTypeInfo = Current.JsonPropertyInfo?.JsonTypeInfo ?? Current.CtorArgumentState.JsonParameterInfo.JsonTypeInfo;
					JsonNumberHandling? numberHandling = Current.NumberHandling;
					EnsurePushCapacity();
					_stack[_count - 1] = Current;
					Current = default(ReadStackFrame);
					_count++;
					Current.JsonTypeInfo = jsonTypeInfo;
					Current.JsonPropertyInfo = jsonTypeInfo.PropertyInfoForTypeInfo;
					Current.NumberHandling = numberHandling ?? Current.JsonPropertyInfo.EffectiveNumberHandling;
					Current.CanContainMetadata = PreserveReferences || (jsonTypeInfo.PolymorphicTypeResolver?.UsesTypeDiscriminators ?? false);
				}
			}
			else
			{
				if (_count++ > 0)
				{
					_stack[_count - 2] = Current;
					Current = _stack[_count - 1];
				}
				if (_continuationCount == _count)
				{
					_continuationCount = 0;
				}
			}
			SetConstructorArgumentState();
		}

		public void Pop(bool success)
		{
			if (!success)
			{
				if (_continuationCount == 0)
				{
					if (_count == 1)
					{
						_continuationCount = 1;
						_count = 0;
						return;
					}
					EnsurePushCapacity();
					_continuationCount = _count--;
				}
				else if (--_count == 0)
				{
					return;
				}
				_stack[_count] = Current;
				Current = _stack[_count - 1];
			}
			else if (--_count > 0)
			{
				Current = _stack[_count - 1];
			}
		}

		public JsonConverter InitializePolymorphicReEntry(JsonTypeInfo derivedJsonTypeInfo)
		{
			Current.PolymorphicJsonTypeInfo = Current.JsonTypeInfo;
			Current.JsonTypeInfo = derivedJsonTypeInfo;
			Current.JsonPropertyInfo = derivedJsonTypeInfo.PropertyInfoForTypeInfo;
			ref JsonNumberHandling? numberHandling = ref Current.NumberHandling;
			JsonNumberHandling? jsonNumberHandling = numberHandling;
			if (!jsonNumberHandling.HasValue)
			{
				numberHandling = Current.JsonPropertyInfo.NumberHandling;
			}
			Current.PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryStarted;
			SetConstructorArgumentState();
			return derivedJsonTypeInfo.Converter;
		}

		public JsonConverter ResumePolymorphicReEntry()
		{
			ref JsonTypeInfo jsonTypeInfo = ref Current.JsonTypeInfo;
			ref JsonTypeInfo polymorphicJsonTypeInfo = ref Current.PolymorphicJsonTypeInfo;
			JsonTypeInfo polymorphicJsonTypeInfo2 = Current.PolymorphicJsonTypeInfo;
			JsonTypeInfo jsonTypeInfo2 = Current.JsonTypeInfo;
			jsonTypeInfo = polymorphicJsonTypeInfo2;
			polymorphicJsonTypeInfo = jsonTypeInfo2;
			Current.PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryStarted;
			return Current.JsonTypeInfo.Converter;
		}

		public void ExitPolymorphicConverter(bool success)
		{
			ref JsonTypeInfo jsonTypeInfo = ref Current.JsonTypeInfo;
			ref JsonTypeInfo polymorphicJsonTypeInfo = ref Current.PolymorphicJsonTypeInfo;
			JsonTypeInfo polymorphicJsonTypeInfo2 = Current.PolymorphicJsonTypeInfo;
			JsonTypeInfo jsonTypeInfo2 = Current.JsonTypeInfo;
			jsonTypeInfo = polymorphicJsonTypeInfo2;
			polymorphicJsonTypeInfo = jsonTypeInfo2;
			Current.PolymorphicSerializationState = ((!success) ? PolymorphicSerializationState.PolymorphicReEntrySuspended : PolymorphicSerializationState.None);
		}

		public string JsonPath()
		{
			StringBuilder stringBuilder = new StringBuilder("$");
			int continuationCount = _continuationCount;
			(int, bool) tuple = continuationCount switch
			{
				0 => (_count - 1, true), 
				1 => (0, true), 
				_ => (continuationCount, false), 
			};
			int item = tuple.Item1;
			bool item2 = tuple.Item2;
			for (int i = 0; i < item; i++)
			{
				AppendStackFrame(stringBuilder, ref _stack[i]);
			}
			if (item2)
			{
				AppendStackFrame(stringBuilder, ref Current);
			}
			return stringBuilder.ToString();
			static void AppendPropertyName(StringBuilder sb, string propertyName)
			{
				if (propertyName != null)
				{
					if (MemoryExtensions.AsSpan(propertyName).ContainsSpecialCharacters())
					{
						sb.Append("['");
						sb.Append(propertyName);
						sb.Append("']");
					}
					else
					{
						sb.Append('.');
						sb.Append(propertyName);
					}
				}
			}
			static void AppendStackFrame(StringBuilder sb, ref ReadStackFrame frame)
			{
				string propertyName = GetPropertyName(ref frame);
				AppendPropertyName(sb, propertyName);
				if (frame.JsonTypeInfo != null && frame.IsProcessingEnumerable() && frame.ReturnValue is IEnumerable enumerable && (frame.ObjectState == StackFrameObjectState.None || frame.ObjectState == StackFrameObjectState.CreatedObject || frame.ObjectState == StackFrameObjectState.ReadElements))
				{
					sb.Append('[');
					sb.Append(GetCount(enumerable));
					sb.Append(']');
				}
			}
			static int GetCount(IEnumerable enumerable)
			{
				if (enumerable is ICollection collection)
				{
					return collection.Count;
				}
				int num = 0;
				IEnumerator enumerator = enumerable.GetEnumerator();
				while (enumerator.MoveNext())
				{
					num++;
				}
				return num;
			}
			static string GetPropertyName(ref ReadStackFrame frame)
			{
				string result = null;
				byte[] array = frame.JsonPropertyName;
				if (array == null)
				{
					if (frame.JsonPropertyNameAsString != null)
					{
						result = frame.JsonPropertyNameAsString;
					}
					else
					{
						array = frame.JsonPropertyInfo?.NameAsUtf8Bytes ?? frame.CtorArgumentState?.JsonParameterInfo?.NameAsUtf8Bytes;
					}
				}
				if (array != null)
				{
					result = JsonHelpers.Utf8GetString(array);
				}
				return result;
			}
		}

		public JsonTypeInfo GetTopJsonTypeInfoWithParameterizedConstructor()
		{
			for (int i = 0; i < _count - 1; i++)
			{
				if (_stack[i].JsonTypeInfo.UsesParameterizedConstructor)
				{
					return _stack[i].JsonTypeInfo;
				}
			}
			return Current.JsonTypeInfo;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void SetConstructorArgumentState()
		{
			if (Current.JsonTypeInfo.UsesParameterizedConstructor)
			{
				ref ArgumentState ctorArgumentState = ref Current.CtorArgumentState;
				if (ctorArgumentState == null)
				{
					ctorArgumentState = new ArgumentState();
				}
			}
		}
	}
	[StructLayout(LayoutKind.Auto)]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	internal struct ReadStackFrame
	{
		public JsonPropertyInfo JsonPropertyInfo;

		public StackFramePropertyState PropertyState;

		public bool UseExtensionProperty;

		public byte[] JsonPropertyName;

		public string JsonPropertyNameAsString;

		public object DictionaryKey;

		public object ReturnValue;

		public JsonTypeInfo JsonTypeInfo;

		public StackFrameObjectState ObjectState;

		public bool CanContainMetadata;

		public MetadataPropertyName LatestMetadataPropertyName;

		public MetadataPropertyName MetadataPropertyNames;

		public PolymorphicSerializationState PolymorphicSerializationState;

		public JsonTypeInfo PolymorphicJsonTypeInfo;

		public int PropertyIndex;

		public List<PropertyRef> PropertyRefCache;

		public ArgumentState CtorArgumentState;

		public JsonNumberHandling? NumberHandling;

		public BitArray RequiredPropertiesSet;

		public bool HasParentObject;

		public bool IsPopulating;

		public JsonTypeInfo BaseJsonTypeInfo
		{
			get
			{
				if (PolymorphicSerializationState != PolymorphicSerializationState.PolymorphicReEntryStarted)
				{
					return JsonTypeInfo;
				}
				return PolymorphicJsonTypeInfo;
			}
		}

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private string DebuggerDisplay => $"ConverterStrategy.{JsonTypeInfo?.Converter.ConverterStrategy}, {JsonTypeInfo?.Type.Name}";

		public void EndConstructorParameter()
		{
			CtorArgumentState.JsonParameterInfo = null;
			JsonPropertyName = null;
			PropertyState = StackFramePropertyState.None;
		}

		public void EndProperty()
		{
			JsonPropertyInfo = null;
			JsonPropertyName = null;
			JsonPropertyNameAsString = null;
			PropertyState = StackFramePropertyState.None;
		}

		public void EndElement()
		{
			JsonPropertyNameAsString = null;
			PropertyState = StackFramePropertyState.None;
		}

		public bool IsProcessingDictionary()
		{
			return JsonTypeInfo.Kind == JsonTypeInfoKind.Dictionary;
		}

		public bool IsProcessingEnumerable()
		{
			return JsonTypeInfo.Kind == JsonTypeInfoKind.Enumerable;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void MarkRequiredPropertyAsRead(JsonPropertyInfo propertyInfo)
		{
			if (propertyInfo.IsRequired)
			{
				RequiredPropertiesSet[propertyInfo.RequiredPropertyIndex] = true;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void InitializeRequiredPropertiesValidationState(JsonTypeInfo typeInfo)
		{
			if (typeInfo.NumberOfRequiredProperties > 0)
			{
				RequiredPropertiesSet = new BitArray(typeInfo.NumberOfRequiredProperties);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ValidateAllRequiredPropertiesAreRead(JsonTypeInfo typeInfo)
		{
			if (typeInfo.NumberOfRequiredProperties > 0 && !RequiredPropertiesSet.HasAllSet())
			{
				ThrowHelper.ThrowJsonException_JsonRequiredPropertyMissing(typeInfo, RequiredPropertiesSet);
			}
		}
	}
	internal enum StackFrameObjectState : byte
	{
		None,
		StartToken,
		ReadMetadata,
		ConstructorArguments,
		CreatedObject,
		ReadElements,
		EndToken,
		EndTokenValidation
	}
	internal enum StackFramePropertyState : byte
	{
		None,
		ReadName,
		Name,
		ReadValue,
		ReadValueIsEnd,
		TryRead
	}
	[StructLayout(LayoutKind.Auto)]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	internal struct WriteStack
	{
		public WriteStackFrame Current;

		private WriteStackFrame[] _stack;

		private int _count;

		private int _continuationCount;

		private byte _indexOffset;

		public CancellationToken CancellationToken;

		public bool SuppressFlush;

		public Task PendingTask;

		public List<IAsyncDisposable> CompletedAsyncDisposables;

		public int FlushThreshold;

		public ReferenceResolver ReferenceResolver;

		public bool SupportContinuation;

		public bool SupportAsync;

		public string NewReferenceId;

		public object PolymorphicTypeDiscriminator;

		public PolymorphicTypeResolver PolymorphicTypeResolver;

		public readonly int CurrentDepth => _count;

		public readonly ref WriteStackFrame Parent => ref _stack[_count - _indexOffset - 1];

		public readonly bool IsContinuation => _continuationCount != 0;

		public readonly bool CurrentContainsMetadata
		{
			get
			{
				if (NewReferenceId == null)
				{
					return PolymorphicTypeDiscriminator != null;
				}
				return true;
			}
		}

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private string DebuggerDisplay => $"Path = {PropertyPath()} Current = ConverterStrategy.{Current.JsonPropertyInfo?.EffectiveConverter.ConverterStrategy}, {Current.JsonTypeInfo?.Type.Name}";

		private void EnsurePushCapacity()
		{
			if (_stack == null)
			{
				_stack = new WriteStackFrame[4];
			}
			else if (_count - _indexOffset == _stack.Length)
			{
				Array.Resize(ref _stack, 2 * _stack.Length);
			}
		}

		internal void Initialize(JsonTypeInfo jsonTypeInfo, object rootValueBoxed = null, bool supportContinuation = false, bool supportAsync = false)
		{
			Current.JsonTypeInfo = jsonTypeInfo;
			Current.JsonPropertyInfo = jsonTypeInfo.PropertyInfoForTypeInfo;
			Current.NumberHandling = Current.JsonPropertyInfo.EffectiveNumberHandling;
			SupportContinuation = supportContinuation;
			SupportAsync = supportAsync;
			JsonSerializerOptions options = jsonTypeInfo.Options;
			if (options.ReferenceHandlingStrategy != ReferenceHandlingStrategy.None)
			{
				ReferenceResolver = options.ReferenceHandler.CreateResolver(writing: true);
				if (options.ReferenceHandlingStrategy == ReferenceHandlingStrategy.IgnoreCycles && rootValueBoxed != null && jsonTypeInfo.Type.IsValueType)
				{
					ReferenceResolver.PushReferenceForCycleDetection(rootValueBoxed);
				}
			}
		}

		public readonly JsonTypeInfo PeekNestedJsonTypeInfo()
		{
			if (_count != 0)
			{
				return Current.JsonPropertyInfo.JsonTypeInfo;
			}
			return Current.JsonTypeInfo;
		}

		public void Push()
		{
			if (_continuationCount == 0)
			{
				if (_count == 0 && Current.PolymorphicSerializationState == PolymorphicSerializationState.None)
				{
					_count = 1;
					_indexOffset = 1;
					return;
				}
				JsonTypeInfo nestedJsonTypeInfo = Current.GetNestedJsonTypeInfo();
				JsonNumberHandling? numberHandling = Current.NumberHandling;
				EnsurePushCapacity();
				_stack[_count - _indexOffset] = Current;
				Current = default(WriteStackFrame);
				_count++;
				Current.JsonTypeInfo = nestedJsonTypeInfo;
				Current.JsonPropertyInfo = nestedJsonTypeInfo.PropertyInfoForTypeInfo;
				Current.NumberHandling = numberHandling ?? Current.JsonPropertyInfo.EffectiveNumberHandling;
			}
			else
			{
				if (_count++ > 0 || _indexOffset == 0)
				{
					Current = _stack[_count - _indexOffset];
				}
				if (_continuationCount == _count)
				{
					_continuationCount = 0;
				}
			}
		}

		public void Pop(bool success)
		{
			if (!success)
			{
				if (_continuationCount == 0)
				{
					if (_count == 1 && _indexOffset > 0)
					{
						_continuationCount = 1;
						_count = 0;
						return;
					}
					EnsurePushCapacity();
					_continuationCount = _count--;
				}
				else if (--_count == 0 && _indexOffset > 0)
				{
					return;
				}
				int num = _count - _indexOffset;
				_stack[num + 1] = Current;
				Current = _stack[num];
			}
			else if (--_count > 0 || _indexOffset == 0)
			{
				Current = _stack[_count - _indexOffset];
			}
		}

		public void AddCompletedAsyncDisposable(IAsyncDisposable asyncDisposable)
		{
			(CompletedAsyncDisposables ?? (CompletedAsyncDisposables = new List<IAsyncDisposable>())).Add(asyncDisposable);
		}

		public async ValueTask DisposeCompletedAsyncDisposables()
		{
			Exception exception = null;
			foreach (IAsyncDisposable completedAsyncDisposable in CompletedAsyncDisposables)
			{
				try
				{
					await completedAsyncDisposable.DisposeAsync().ConfigureAwait(continueOnCapturedContext: false);
				}
				catch (Exception ex)
				{
					exception = ex;
				}
			}
			if (exception != null)
			{
				ExceptionDispatchInfo.Capture(exception).Throw();
			}
			CompletedAsyncDisposables.Clear();
		}

		public void DisposePendingDisposablesOnException()
		{
			Exception exception = null;
			DisposeFrame(Current.CollectionEnumerator, ref exception);
			int num = Math.Max(_count, _continuationCount);
			for (int i = 0; i < num - 1; i++)
			{
				DisposeFrame(_stack[i].CollectionEnumerator, ref exception);
			}
			if (exception != null)
			{
				ExceptionDispatchInfo.Capture(exception).Throw();
			}
			static void DisposeFrame(IEnumerator collectionEnumerator, ref Exception reference)
			{
				try
				{
					if (collectionEnumerator is IDisposable disposable)
					{
						disposable.Dispose();
					}
				}
				catch (Exception ex)
				{
					reference = ex;
				}
			}
		}

		public async ValueTask DisposePendingDisposablesOnExceptionAsync()
		{
			Exception exception = null;
			exception = await DisposeFrame(Current.CollectionEnumerator, Current.AsyncDisposable, exception).ConfigureAwait(continueOnCapturedContext: false);
			int stackSize = Math.Max(_count, _continuationCount);
			for (int i = 0; i < stackSize - 1; i++)
			{
				exception = await DisposeFrame(_stack[i].CollectionEnumerator, _stack[i].AsyncDisposable, exception).ConfigureAwait(continueOnCapturedContext: false);
			}
			if (exception != null)
			{
				ExceptionDispatchInfo.Capture(exception).Throw();
			}
			static async ValueTask<Exception> DisposeFrame(IEnumerator collectionEnumerator, IAsyncDisposable asyncDisposable, Exception result)
			{
				try
				{
					if (collectionEnumerator is IDisposable disposable)
					{
						disposable.Dispose();
					}
					else if (asyncDisposable != null)
					{
						await asyncDisposable.DisposeAsync().ConfigureAwait(continueOnCapturedContext: false);
					}
				}
				catch (Exception ex)
				{
					result = ex;
				}
				return result;
			}
		}

		public string PropertyPath()
		{
			StringBuilder stringBuilder = new StringBuilder("$");
			int continuationCount = _continuationCount;
			(int, bool) tuple = continuationCount switch
			{
				0 => (_count - 1, true), 
				1 => (0, true), 
				_ => (continuationCount, false), 
			};
			int item = tuple.Item1;
			bool item2 = tuple.Item2;
			for (int i = 1; i <= item; i++)
			{
				AppendStackFrame(stringBuilder, ref _stack[i - _indexOffset]);
			}
			if (item2)
			{
				AppendStackFrame(stringBuilder, ref Current);
			}
			return stringBuilder.ToString();
			static void AppendPropertyName(StringBuilder sb, string propertyName)
			{
				if (propertyName != null)
				{
					if (MemoryExtensions.AsSpan(propertyName).ContainsSpecialCharacters())
					{
						sb.Append("['");
						sb.Append(propertyName);
						sb.Append("']");
					}
					else
					{
						sb.Append('.');
						sb.Append(propertyName);
					}
				}
			}
			static void AppendStackFrame(StringBuilder sb, ref WriteStackFrame frame)
			{
				string propertyName = frame.JsonPropertyInfo?.MemberName ?? frame.JsonPropertyNameAsString;
				AppendPropertyName(sb, propertyName);
			}
		}
	}
	[StructLayout(LayoutKind.Auto)]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	internal struct WriteStackFrame
	{
		public IEnumerator CollectionEnumerator;

		public IAsyncDisposable AsyncDisposable;

		public bool AsyncEnumeratorIsPendingCompletion;

		public JsonPropertyInfo JsonPropertyInfo;

		public bool IsWritingExtensionDataProperty;

		public JsonTypeInfo JsonTypeInfo;

		public int OriginalDepth;

		public bool ProcessedStartToken;

		public bool ProcessedEndToken;

		public StackFramePropertyState PropertyState;

		public int EnumeratorIndex;

		public string JsonPropertyNameAsString;

		public MetadataPropertyName MetadataPropertyName;

		public PolymorphicSerializationState PolymorphicSerializationState;

		public JsonTypeInfo PolymorphicTypeInfo;

		public JsonNumberHandling? NumberHandling;

		public bool IsPushedReferenceForCycleDetection;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly string DebuggerDisplay => $"ConverterStrategy.{JsonTypeInfo?.Converter.ConverterStrategy}, {JsonTypeInfo?.Type.Name}";

		public void EndCollectionElement()
		{
			PolymorphicSerializationState = PolymorphicSerializationState.None;
		}

		public void EndDictionaryEntry()
		{
			PropertyState = StackFramePropertyState.None;
			PolymorphicSerializationState = PolymorphicSerializationState.None;
		}

		public void EndProperty()
		{
			JsonPropertyInfo = null;
			JsonPropertyNameAsString = null;
			PropertyState = StackFramePropertyState.None;
			PolymorphicSerializationState = PolymorphicSerializationState.None;
		}

		public readonly JsonTypeInfo GetNestedJsonTypeInfo()
		{
			if (PolymorphicSerializationState != PolymorphicSerializationState.PolymorphicReEntryStarted)
			{
				return JsonPropertyInfo.JsonTypeInfo;
			}
			return PolymorphicTypeInfo;
		}

		public JsonTypeInfo InitializePolymorphicReEntry(Type runtimeType, JsonSerializerOptions options)
		{
			if (PolymorphicTypeInfo?.Type != runtimeType)
			{
				JsonTypeInfo typeInfoInternal = options.GetTypeInfoInternal(runtimeType, ensureConfigured: true, true, resolveIfMutable: false, fallBackToNearestAncestorType: true);
				PolymorphicTypeInfo = typeInfoInternal.AncestorPolymorphicType ?? typeInfoInternal;
			}
			PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryStarted;
			return PolymorphicTypeInfo;
		}

		public JsonConverter InitializePolymorphicReEntry(JsonTypeInfo derivedJsonTypeInfo)
		{
			PolymorphicTypeInfo = derivedJsonTypeInfo;
			PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryStarted;
			return derivedJsonTypeInfo.Converter;
		}

		public JsonConverter ResumePolymorphicReEntry()
		{
			PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryStarted;
			return PolymorphicTypeInfo.Converter;
		}

		public void ExitPolymorphicConverter(bool success)
		{
			PolymorphicSerializationState = ((!success) ? PolymorphicSerializationState.PolymorphicReEntrySuspended : PolymorphicSerializationState.None);
		}
	}
	internal enum ExceptionResource
	{
		ArrayDepthTooLarge,
		EndOfCommentNotFound,
		EndOfStringNotFound,
		RequiredDigitNotFoundAfterDecimal,
		RequiredDigitNotFoundAfterSign,
		RequiredDigitNotFoundEndOfData,
		ExpectedEndAfterSingleJson,
		ExpectedEndOfDigitNotFound,
		ExpectedFalse,
		ExpectedNextDigitEValueNotFound,
		ExpectedNull,
		ExpectedSeparatorAfterPropertyNameNotFound,
		ExpectedStartOfPropertyNotFound,
		ExpectedStartOfPropertyOrValueNotFound,
		ExpectedStartOfPropertyOrValueAfterComment,
		ExpectedStartOfValueNotFound,
		ExpectedTrue,
		ExpectedValueAfterPropertyNameNotFound,
		FoundInvalidCharacter,
		InvalidCharacterWithinString,
		InvalidCharacterAfterEscapeWithinString,
		InvalidHexCharacterWithinString,
		InvalidEndOfJsonNonPrimitive,
		MismatchedObjectArray,
		ObjectDepthTooLarge,
		ZeroDepthAtEnd,
		DepthTooLarge,
		CannotStartObjectArrayWithoutProperty,
		CannotStartObjectArrayAfterPrimitiveOrClose,
		CannotWriteValueWithinObject,
		CannotWriteValueAfterPrimitiveOrClose,
		CannotWritePropertyWithinArray,
		ExpectedJsonTokens,
		TrailingCommaNotAllowedBeforeArrayEnd,
		TrailingCommaNotAllowedBeforeObjectEnd,
		InvalidCharacterAtStartOfComment,
		UnexpectedEndOfDataWhileReadingComment,
		UnexpectedEndOfLineSeparator,
		ExpectedOneCompleteToken,
		NotEnoughData,
		InvalidLeadingZeroInNumber
	}
	internal enum NumericType
	{
		Byte,
		SByte,
		Int16,
		Int32,
		Int64,
		Int128,
		UInt16,
		UInt32,
		UInt64,
		UInt128,
		Half,
		Single,
		Double,
		Decimal
	}
	internal enum DataType
	{
		Boolean,
		DateOnly,
		DateTime,
		DateTimeOffset,
		TimeOnly,
		TimeSpan,
		Base64String,
		Guid,
		Version
	}
	internal static class JsonWriterHelper
	{
		private static readonly UTF8Encoding s_utf8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: true);

		private static readonly StandardFormat s_dateTimeStandardFormat = new StandardFormat('O');

		public const int LastAsciiCharacter = 127;

		private static readonly StandardFormat s_hexStandardFormat = new StandardFormat('X', 4);

		private static ReadOnlySpan<byte> AllowList => new byte[256]
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 1, 1, 0, 1, 1, 1, 0, 0,
			1, 1, 1, 0, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 1, 0, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 0, 1, 1, 1, 0, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0
		};

		public static void WriteIndentation(Span<byte> buffer, int indent)
		{
			if (indent < 8)
			{
				int num = 0;
				while (num < indent)
				{
					buffer[num++] = 32;
					buffer[num++] = 32;
				}
			}
			else
			{
				buffer.Slice(0, indent).Fill(32);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ValidateProperty(ReadOnlySpan<byte> propertyName)
		{
			if (propertyName.Length > 166666666)
			{
				ThrowHelper.ThrowArgumentException_PropertyNameTooLarge(propertyName.Length);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ValidateValue(ReadOnlySpan<byte> value)
		{
			if (value.Length > 166666666)
			{
				ThrowHelper.ThrowArgumentException_ValueTooLarge(value.Length);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ValidateDouble(double value)
		{
			if (!JsonHelpers.IsFinite(value))
			{
				ThrowHelper.ThrowArgumentException_ValueNotSupported();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ValidateSingle(float value)
		{
			if (!JsonHelpers.IsFinite(value))
			{
				ThrowHelper.ThrowArgumentException_ValueNotSupported();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ValidateProperty(ReadOnlySpan<char> propertyName)
		{
			if (propertyName.Length > 166666666)
			{
				ThrowHelper.ThrowArgumentException_PropertyNameTooLarge(propertyName.Length);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ValidateValue(ReadOnlySpan<char> value)
		{
			if (value.Length > 166666666)
			{
				ThrowHelper.ThrowArgumentException_ValueTooLarge(value.Length);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ValidatePropertyAndValue(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value)
		{
			if (propertyName.Length > 166666666 || value.Length > 166666666)
			{
				ThrowHelper.ThrowArgumentException(propertyName, value);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ValidatePropertyAndValue(ReadOnlySpan<byte> propertyName, ReadOnlySpan<char> value)
		{
			if (propertyName.Length > 166666666 || value.Length > 166666666)
			{
				ThrowHelper.ThrowArgumentException(propertyName, value);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ValidatePropertyAndValue(ReadOnlySpan<byte> propertyName, ReadOnlySpan<byte> value)
		{
			if (propertyName.Length > 166666666 || value.Length > 166666666)
			{
				ThrowHelper.ThrowArgumentException(propertyName, value);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ValidatePropertyAndValue(ReadOnlySpan<char> propertyName, ReadOnlySpan<char> value)
		{
			if (propertyName.Length > 166666666 || value.Length > 166666666)
			{
				ThrowHelper.ThrowArgumentException(propertyName, value);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ValidatePropertyNameLength(ReadOnlySpan<char> propertyName)
		{
			if (propertyName.Length > 166666666)
			{
				ThrowHelper.ThrowPropertyNameTooLargeArgumentException(propertyName.Length);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void ValidatePropertyNameLength(ReadOnlySpan<byte> propertyName)
		{
			if (propertyName.Length > 166666666)
			{
				ThrowHelper.ThrowPropertyNameTooLargeArgumentException(propertyName.Length);
			}
		}

		internal static void ValidateNumber(ReadOnlySpan<byte> utf8FormattedNumber)
		{
			int i = 0;
			if (utf8FormattedNumber[i] == 45)
			{
				i++;
				if (utf8FormattedNumber.Length <= i)
				{
					throw new ArgumentException(System.SR.RequiredDigitNotFoundEndOfData, "utf8FormattedNumber");
				}
			}
			if (utf8FormattedNumber[i] == 48)
			{
				i++;
			}
			else
			{
				for (; i < utf8FormattedNumber.Length && JsonHelpers.IsDigit(utf8FormattedNumber[i]); i++)
				{
				}
			}
			if (i == utf8FormattedNumber.Length)
			{
				return;
			}
			byte b = utf8FormattedNumber[i];
			if (b == 46)
			{
				i++;
				if (utf8FormattedNumber.Length <= i)
				{
					throw new ArgumentException(System.SR.RequiredDigitNotFoundEndOfData, "utf8FormattedNumber");
				}
				for (; i < utf8FormattedNumber.Length && JsonHelpers.IsDigit(utf8FormattedNumber[i]); i++)
				{
				}
				if (i == utf8FormattedNumber.Length)
				{
					return;
				}
				b = utf8FormattedNumber[i];
			}
			if (b == 101 || b == 69)
			{
				i++;
				if (utf8FormattedNumber.Length <= i)
				{
					throw new ArgumentException(System.SR.RequiredDigitNotFoundEndOfData, "utf8FormattedNumber");
				}
				b = utf8FormattedNumber[i];
				if (b == 43 || b == 45)
				{
					i++;
				}
				if (utf8FormattedNumber.Length <= i)
				{
					throw new ArgumentException(System.SR.RequiredDigitNotFoundEndOfData, "utf8FormattedNumber");
				}
				for (; i < utf8FormattedNumber.Length && JsonHelpers.IsDigit(utf8FormattedNumber[i]); i++)
				{
				}
				if (i == utf8FormattedNumber.Length)
				{
					return;
				}
				throw new ArgumentException(System.SR.Format(System.SR.ExpectedEndOfDigitNotFound, ThrowHelper.GetPrintableString(utf8FormattedNumber[i])), "utf8FormattedNumber");
			}
			throw new ArgumentException(System.SR.Format(System.SR.ExpectedEndOfDigitNotFound, ThrowHelper.GetPrintableString(b)), "utf8FormattedNumber");
		}

		public unsafe static bool IsValidUtf8String(ReadOnlySpan<byte> bytes)
		{
			try
			{
				if (!bytes.IsEmpty)
				{
					fixed (byte* bytes2 = bytes)
					{
						s_utf8Encoding.GetCharCount(bytes2, bytes.Length);
					}
				}
				return true;
			}
			catch (DecoderFallbackException)
			{
				return false;
			}
		}

		internal unsafe static OperationStatus ToUtf8(ReadOnlySpan<char> source, Span<byte> destination, out int written)
		{
			written = 0;
			try
			{
				if (!source.IsEmpty)
				{
					fixed (char* chars = source)
					{
						fixed (byte* bytes = destination)
						{
							written = s_utf8Encoding.GetBytes(chars, source.Length, bytes, destination.Length);
						}
					}
				}
				return OperationStatus.Done;
			}
			catch (EncoderFallbackException)
			{
				return OperationStatus.InvalidData;
			}
			catch (ArgumentException)
			{
				return OperationStatus.DestinationTooSmall;
			}
		}

		public static void WriteDateTimeTrimmed(Span<byte> buffer, DateTime value, out int bytesWritten)
		{
			Span<byte> destination = stackalloc byte[33];
			bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten, s_dateTimeStandardFormat);
			TrimDateTimeOffset(destination.Slice(0, bytesWritten), out bytesWritten);
			destination.Slice(0, bytesWritten).CopyTo(buffer);
		}

		public static void WriteDateTimeOffsetTrimmed(Span<byte> buffer, DateTimeOffset value, out int bytesWritten)
		{
			Span<byte> destination = stackalloc byte[33];
			bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten, s_dateTimeStandardFormat);
			TrimDateTimeOffset(destination.Slice(0, bytesWritten), out bytesWritten);
			destination.Slice(0, bytesWritten).CopyTo(buffer);
		}

		public static void TrimDateTimeOffset(Span<byte> buffer, out int bytesWritten)
		{
			if (buffer[26] != 48)
			{
				bytesWritten = buffer.Length;
				return;
			}
			int num = ((buffer[25] != 48) ? 26 : ((buffer[24] != 48) ? 25 : ((buffer[23] != 48) ? 24 : ((buffer[22] != 48) ? 23 : ((buffer[21] != 48) ? 22 : ((buffer[20] != 48) ? 21 : 19))))));
			if (buffer.Length == 27)
			{
				bytesWritten = num;
			}
			else if (buffer.Length == 33)
			{
				buffer[num] = buffer[27];
				buffer[num + 1] = buffer[28];
				buffer[num + 2] = buffer[29];
				buffer[num + 3] = buffer[30];
				buffer[num + 4] = buffer[31];
				buffer[num + 5] = buffer[32];
				bytesWritten = num + 6;
			}
			else
			{
				buffer[num] = 90;
				bytesWritten = num + 1;
			}
		}

		private static bool NeedsEscaping(byte value)
		{
			return AllowList[value] == 0;
		}

		private static bool NeedsEscapingNoBoundsCheck(char value)
		{
			return AllowList[value] == 0;
		}

		public static int NeedsEscaping(ReadOnlySpan<byte> value, JavaScriptEncoder encoder)
		{
			return (encoder ?? JavaScriptEncoder.Default).FindFirstCharacterToEncodeUtf8(value);
		}

		public unsafe static int NeedsEscaping(ReadOnlySpan<char> value, JavaScriptEncoder encoder)
		{
			if (value.IsEmpty)
			{
				return -1;
			}
			fixed (char* text = value)
			{
				return (encoder ?? JavaScriptEncoder.Default).FindFirstCharacterToEncode(text, value.Length);
			}
		}

		public static int GetMaxEscapedLength(int textLength, int firstIndexToEscape)
		{
			return firstIndexToEscape + 6 * (textLength - firstIndexToEscape);
		}

		private static void EscapeString(ReadOnlySpan<byte> value, Span<byte> destination, JavaScriptEncoder encoder, ref int written)
		{
			if (encoder.EncodeUtf8(value, destination, out var _, out var bytesWritten) != OperationStatus.Done)
			{
				ThrowHelper.ThrowArgumentException_InvalidUTF8(value.Slice(bytesWritten));
			}
			written += bytesWritten;
		}

		public static void EscapeString(ReadOnlySpan<byte> value, Span<byte> destination, int indexOfFirstByteToEscape, JavaScriptEncoder encoder, out int written)
		{
			value.Slice(0, indexOfFirstByteToEscape).CopyTo(destination);
			written = indexOfFirstByteToEscape;
			if (encoder != null)
			{
				destination = destination.Slice(indexOfFirstByteToEscape);
				value = value.Slice(indexOfFirstByteToEscape);
				EscapeString(value, destination, encoder, ref written);
				return;
			}
			while (indexOfFirstByteToEscape < value.Length)
			{
				byte b = value[indexOfFirstByteToEscape];
				if (IsAsciiValue(b))
				{
					if (NeedsEscaping(b))
					{
						EscapeNextBytes(b, destination, ref written);
						indexOfFirstByteToEscape++;
					}
					else
					{
						destination[written] = b;
						written++;
						indexOfFirstByteToEscape++;
					}
					continue;
				}
				destination = destination.Slice(written);
				value = value.Slice(indexOfFirstByteToEscape);
				EscapeString(value, destination, JavaScriptEncoder.Default, ref written);
				break;
			}
		}

		private static void EscapeNextBytes(byte value, Span<byte> destination, ref int written)
		{
			destination[written++] = 92;
			switch (value)
			{
			case 34:
				destination[written++] = 117;
				destination[written++] = 48;
				destination[written++] = 48;
				destination[written++] = 50;
				destination[written++] = 50;
				break;
			case 10:
				destination[written++] = 110;
				break;
			case 13:
				destination[written++] = 114;
				break;
			case 9:
				destination[written++] = 116;
				break;
			case 92:
				destination[written++] = 92;
				break;
			case 8:
				destination[written++] = 98;
				break;
			case 12:
				destination[written++] = 102;
				break;
			default:
			{
				destination[written++] = 117;
				int bytesWritten;
				bool flag = Utf8Formatter.TryFormat(value, destination.Slice(written), out bytesWritten, s_hexStandardFormat);
				written += bytesWritten;
				break;
			}
			}
		}

		private static bool IsAsciiValue(byte value)
		{
			return value <= 127;
		}

		private static bool IsAsciiValue(char value)
		{
			return value <= '\u007f';
		}

		private static void EscapeString(ReadOnlySpan<char> value, Span<char> destination, JavaScriptEncoder encoder, ref int written)
		{
			if (encoder.Encode(value, destination, out var _, out var charsWritten) != OperationStatus.Done)
			{
				ThrowHelper.ThrowArgumentException_InvalidUTF16(value[charsWritten]);
			}
			written += charsWritten;
		}

		public static void EscapeString(ReadOnlySpan<char> value, Span<char> destination, int indexOfFirstByteToEscape, JavaScriptEncoder encoder, out int written)
		{
			value.Slice(0, indexOfFirstByteToEscape).CopyTo(destination);
			written = indexOfFirstByteToEscape;
			if (encoder != null)
			{
				destination = destination.Slice(indexOfFirstByteToEscape);
				value = value.Slice(indexOfFirstByteToEscape);
				EscapeString(value, destination, encoder, ref written);
				return;
			}
			while (indexOfFirstByteToEscape < value.Length)
			{
				char c = value[indexOfFirstByteToEscape];
				if (IsAsciiValue(c))
				{
					if (NeedsEscapingNoBoundsCheck(c))
					{
						EscapeNextChars(c, destination, ref written);
						indexOfFirstByteToEscape++;
					}
					else
					{
						destination[written] = c;
						written++;
						indexOfFirstByteToEscape++;
					}
					continue;
				}
				destination = destination.Slice(written);
				value = value.Slice(indexOfFirstByteToEscape);
				EscapeString(value, destination, JavaScriptEncoder.Default, ref written);
				break;
			}
		}

		private static void EscapeNextChars(char value, Span<char> destination, ref int written)
		{
			destination[written++] = '\\';
			switch ((byte)value)
			{
			case 34:
				destination[written++] = 'u';
				destination[written++] = '0';
				destination[written++] = '0';
				destination[written++] = '2';
				destination[written++] = '2';
				break;
			case 10:
				destination[written++] = 'n';
				break;
			case 13:
				destination[written++] = 'r';
				break;
			case 9:
				destination[written++] = 't';
				break;
			case 92:
				destination[written++] = '\\';
				break;
			case 8:
				destination[written++] = 'b';
				break;
			case 12:
				destination[written++] = 'f';
				break;
			default:
				destination[written++] = 'u';
				written = WriteHex(value, destination, written);
				break;
			}
		}

		private static int WriteHex(int value, Span<char> destination, int written)
		{
			destination[written++] = System.HexConverter.ToCharUpper(value >> 12);
			destination[written++] = System.HexConverter.ToCharUpper(value >> 8);
			destination[written++] = System.HexConverter.ToCharUpper(value >> 4);
			destination[written++] = System.HexConverter.ToCharUpper(value);
			return written;
		}
	}
	public struct JsonWriterOptions
	{
		internal const int DefaultMaxDepth = 1000;

		private int _maxDepth;

		private int _optionsMask;

		private const int IndentBit = 1;

		private const int SkipValidationBit = 2;

		public JavaScriptEncoder? Encoder { get; set; }

		public bool Indented
		{
			get
			{
				return (_optionsMask & 1) != 0;
			}
			set
			{
				if (value)
				{
					_optionsMask |= 1;
				}
				else
				{
					_optionsMask &= -2;
				}
			}
		}

		public int MaxDepth
		{
			readonly get
			{
				return _maxDepth;
			}
			set
			{
				if (value < 0)
				{
					ThrowHelper.ThrowArgumentOutOfRangeException_MaxDepthMustBePositive("value");
				}
				_maxDepth = value;
			}
		}

		public bool SkipValidation
		{
			get
			{
				return (_optionsMask & 2) != 0;
			}
			set
			{
				if (value)
				{
					_optionsMask |= 2;
				}
				else
				{
					_optionsMask &= -3;
				}
			}
		}

		internal bool IndentedOrNotSkipValidation => _optionsMask != 2;
	}
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public sealed class Utf8JsonWriter : IDisposable, IAsyncDisposable
	{
		private static readonly int s_newLineLength = Environment.NewLine.Length;

		private const int DefaultGrowthSize = 4096;

		private const int InitialGrowthSize = 256;

		private IBufferWriter<byte> _output;

		private Stream _stream;

		private ArrayBufferWriter<byte> _arrayBufferWriter;

		private Memory<byte> _memory;

		private bool _inObject;

		private bool _commentAfterNoneOrPropertyName;

		private JsonTokenType _tokenType;

		private BitStack _bitStack;

		private int _currentDepth;

		private JsonWriterOptions _options;

		private static readonly char[] s_singleLineCommentDelimiter = new char[2] { '*', '/' };

		public int BytesPending { get; private set; }

		public long BytesCommitted { get; private set; }

		public JsonWriterOptions Options => _options;

		private int Indentation => CurrentDepth * 2;

		internal JsonTokenType TokenType => _tokenType;

		public int CurrentDepth => _currentDepth & 0x7FFFFFFF;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private string DebuggerDisplay => $"BytesCommitted = {BytesCommitted} BytesPending = {BytesPending} CurrentDepth = {CurrentDepth}";

		private static ReadOnlySpan<byte> SingleLineCommentDelimiterUtf8 => "*/"u8;

		private Utf8JsonWriter()
		{
		}

		public Utf8JsonWriter(IBufferWriter<byte> bufferWriter, JsonWriterOptions options = default(JsonWriterOptions))
		{
			if (bufferWriter == null)
			{
				ThrowHelper.ThrowArgumentNullException("bufferWriter");
			}
			_output = bufferWriter;
			_options = options;
			if (_options.MaxDepth == 0)
			{
				_options.MaxDepth = 1000;
			}
		}

		public Utf8JsonWriter(Stream utf8Json, JsonWriterOptions options = default(JsonWriterOptions))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			if (!utf8Json.CanWrite)
			{
				throw new ArgumentException(System.SR.StreamNotWritable);
			}
			_stream = utf8Json;
			_options = options;
			if (_options.MaxDepth == 0)
			{
				_options.MaxDepth = 1000;
			}
			_arrayBufferWriter = new ArrayBufferWriter<byte>();
		}

		public void Reset()
		{
			CheckNotDisposed();
			_arrayBufferWriter?.Clear();
			ResetHelper();
		}

		public void Reset(Stream utf8Json)
		{
			CheckNotDisposed();
			if (utf8Json == null)
			{
				throw new ArgumentNullException("utf8Json");
			}
			if (!utf8Json.CanWrite)
			{
				throw new ArgumentException(System.SR.StreamNotWritable);
			}
			_stream = utf8Json;
			if (_arrayBufferWriter == null)
			{
				_arrayBufferWriter = new ArrayBufferWriter<byte>();
			}
			else
			{
				_arrayBufferWriter.Clear();
			}
			_output = null;
			ResetHelper();
		}

		public void Reset(IBufferWriter<byte> bufferWriter)
		{
			CheckNotDisposed();
			_output = bufferWriter ?? throw new ArgumentNullException("bufferWriter");
			_stream = null;
			_arrayBufferWriter = null;
			ResetHelper();
		}

		internal void ResetAllStateForCacheReuse()
		{
			ResetHelper();
			_stream = null;
			_arrayBufferWriter = null;
			_output = null;
		}

		internal void Reset(IBufferWriter<byte> bufferWriter, JsonWriterOptions options)
		{
			_output = bufferWriter;
			_options = options;
			if (_options.MaxDepth == 0)
			{
				_options.MaxDepth = 1000;
			}
		}

		internal static Utf8JsonWriter CreateEmptyInstanceForCaching()
		{
			return new Utf8JsonWriter();
		}

		private void ResetHelper()
		{
			BytesPending = 0;
			BytesCommitted = 0L;
			_memory = default(Memory<byte>);
			_inObject = false;
			_tokenType = JsonTokenType.None;
			_commentAfterNoneOrPropertyName = false;
			_currentDepth = 0;
			_bitStack = default(BitStack);
		}

		private void CheckNotDisposed()
		{
			if (_stream == null && _output == null)
			{
				ThrowHelper.ThrowObjectDisposedException_Utf8JsonWriter();
			}
		}

		public void Flush()
		{
			CheckNotDisposed();
			_memory = default(Memory<byte>);
			if (_stream != null)
			{
				if (BytesPending != 0)
				{
					_arrayBufferWriter.Advance(BytesPending);
					BytesPending = 0;
					ArraySegment<byte> segment;
					bool flag = MemoryMarshal.TryGetArray(_arrayBufferWriter.WrittenMemory, out segment);
					_stream.Write(segment.Array, segment.Offset, segment.Count);
					BytesCommitted += _arrayBufferWriter.WrittenCount;
					_arrayBufferWriter.Clear();
				}
				_stream.Flush();
			}
			else if (BytesPending != 0)
			{
				_output.Advance(BytesPending);
				BytesCommitted += BytesPending;
				BytesPending = 0;
			}
		}

		public void Dispose()
		{
			if (_stream != null || _output != null)
			{
				Flush();
				ResetHelper();
				_stream = null;
				_arrayBufferWriter = null;
				_output = null;
			}
		}

		public async ValueTask DisposeAsync()
		{
			if (_stream != null || _output != null)
			{
				await FlushAsync().ConfigureAwait(continueOnCapturedContext: false);
				ResetHelper();
				_stream = null;
				_arrayBufferWriter = null;
				_output = null;
			}
		}

		public async Task FlushAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			CheckNotDisposed();
			_memory = default(Memory<byte>);
			if (_stream != null)
			{
				if (BytesPending != 0)
				{
					_arrayBufferWriter.Advance(BytesPending);
					BytesPending = 0;
					MemoryMarshal.TryGetArray(_arrayBufferWriter.WrittenMemory, out var segment);
					await _stream.WriteAsync(segment.Array, segment.Offset, segment.Count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					BytesCommitted += _arrayBufferWriter.WrittenCount;
					_arrayBufferWriter.Clear();
				}
				await _stream.FlushAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			else if (BytesPending != 0)
			{
				_output.Advance(BytesPending);
				BytesCommitted += BytesPending;
				BytesPending = 0;
			}
		}

		public void WriteStartArray()
		{
			WriteStart(91);
			_tokenType = JsonTokenType.StartArray;
		}

		public void WriteStartObject()
		{
			WriteStart(123);
			_tokenType = JsonTokenType.StartObject;
		}

		private void WriteStart(byte token)
		{
			if (CurrentDepth >= _options.MaxDepth)
			{
				ThrowHelper.ThrowInvalidOperationException(ExceptionResource.DepthTooLarge, _currentDepth, _options.MaxDepth, 0, JsonTokenType.None);
			}
			if (_options.IndentedOrNotSkipValidation)
			{
				WriteStartSlow(token);
			}
			else
			{
				WriteStartMinimized(token);
			}
			_currentDepth &= int.MaxValue;
			_currentDepth++;
		}

		private void WriteStartMinimized(byte token)
		{
			if (_memory.Length - BytesPending < 2)
			{
				Grow(2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = token;
		}

		private void WriteStartSlow(byte token)
		{
			if (_options.Indented)
			{
				if (!_options.SkipValidation)
				{
					ValidateStart();
					UpdateBitStackOnStart(token);
				}
				WriteStartIndented(token);
			}
			else
			{
				ValidateStart();
				UpdateBitStackOnStart(token);
				WriteStartMinimized(token);
			}
		}

		private void ValidateStart()
		{
			if (_inObject)
			{
				if (_tokenType != JsonTokenType.PropertyName)
				{
					ThrowHelper.ThrowInvalidOperationException(ExceptionResource.CannotStartObjectArrayWithoutProperty, 0, _options.MaxDepth, 0, _tokenType);
				}
			}
			else if (CurrentDepth == 0 && _tokenType != JsonTokenType.None)
			{
				ThrowHelper.ThrowInvalidOperationException(ExceptionResource.CannotStartObjectArrayAfterPrimitiveOrClose, 0, _options.MaxDepth, 0, _tokenType);
			}
		}

		private void WriteStartIndented(byte token)
		{
			int indentation = Indentation;
			int num = indentation + 1;
			int num2 = num + 3;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			JsonTokenType tokenType = _tokenType;
			if ((tokenType != JsonTokenType.PropertyName && tokenType != JsonTokenType.None) || _commentAfterNoneOrPropertyName)
			{
				WriteNewLine(span);
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			span[BytesPending++] = token;
		}

		public void WriteStartArray(JsonEncodedText propertyName)
		{
			WriteStartHelper(propertyName.EncodedUtf8Bytes, 91);
			_tokenType = JsonTokenType.StartArray;
		}

		public void WriteStartObject(JsonEncodedText propertyName)
		{
			WriteStartHelper(propertyName.EncodedUtf8Bytes, 123);
			_tokenType = JsonTokenType.StartObject;
		}

		private void WriteStartHelper(ReadOnlySpan<byte> utf8PropertyName, byte token)
		{
			ValidateDepth();
			WriteStartByOptions(utf8PropertyName, token);
			_currentDepth &= int.MaxValue;
			_currentDepth++;
		}

		public void WriteStartArray(ReadOnlySpan<byte> utf8PropertyName)
		{
			ValidatePropertyNameAndDepth(utf8PropertyName);
			WriteStartEscape(utf8PropertyName, 91);
			_currentDepth &= int.MaxValue;
			_currentDepth++;
			_tokenType = JsonTokenType.StartArray;
		}

		public void WriteStartObject(ReadOnlySpan<byte> utf8PropertyName)
		{
			ValidatePropertyNameAndDepth(utf8PropertyName);
			WriteStartEscape(utf8PropertyName, 123);
			_currentDepth &= int.MaxValue;
			_currentDepth++;
			_tokenType = JsonTokenType.StartObject;
		}

		private void WriteStartEscape(ReadOnlySpan<byte> utf8PropertyName, byte token)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num != -1)
			{
				WriteStartEscapeProperty(utf8PropertyName, token, num);
			}
			else
			{
				WriteStartByOptions(utf8PropertyName, token);
			}
		}

		private void WriteStartByOptions(ReadOnlySpan<byte> utf8PropertyName, byte token)
		{
			ValidateWritingProperty(token);
			if (_options.Indented)
			{
				WritePropertyNameIndented(utf8PropertyName, token);
			}
			else
			{
				WritePropertyNameMinimized(utf8PropertyName, token);
			}
		}

		private void WriteStartEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, byte token, int firstEscapeIndexProp)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteStartByOptions(destination.Slice(0, written), token);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		public void WriteStartArray(string propertyName)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteStartArray(MemoryExtensions.AsSpan(propertyName));
		}

		public void WriteStartObject(string propertyName)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteStartObject(MemoryExtensions.AsSpan(propertyName));
		}

		public void WriteStartArray(ReadOnlySpan<char> propertyName)
		{
			ValidatePropertyNameAndDepth(propertyName);
			WriteStartEscape(propertyName, 91);
			_currentDepth &= int.MaxValue;
			_currentDepth++;
			_tokenType = JsonTokenType.StartArray;
		}

		public void WriteStartObject(ReadOnlySpan<char> propertyName)
		{
			ValidatePropertyNameAndDepth(propertyName);
			WriteStartEscape(propertyName, 123);
			_currentDepth &= int.MaxValue;
			_currentDepth++;
			_tokenType = JsonTokenType.StartObject;
		}

		private void WriteStartEscape(ReadOnlySpan<char> propertyName, byte token)
		{
			int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num != -1)
			{
				WriteStartEscapeProperty(propertyName, token, num);
			}
			else
			{
				WriteStartByOptions(propertyName, token);
			}
		}

		private void WriteStartByOptions(ReadOnlySpan<char> propertyName, byte token)
		{
			ValidateWritingProperty(token);
			if (_options.Indented)
			{
				WritePropertyNameIndented(propertyName, token);
			}
			else
			{
				WritePropertyNameMinimized(propertyName, token);
			}
		}

		private void WriteStartEscapeProperty(ReadOnlySpan<char> propertyName, byte token, int firstEscapeIndexProp)
		{
			char[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
			Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
			Span<char> destination = span;
			JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteStartByOptions(destination.Slice(0, written), token);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		public void WriteEndArray()
		{
			WriteEnd(93);
			_tokenType = JsonTokenType.EndArray;
		}

		public void WriteEndObject()
		{
			WriteEnd(125);
			_tokenType = JsonTokenType.EndObject;
		}

		private void WriteEnd(byte token)
		{
			if (_options.IndentedOrNotSkipValidation)
			{
				WriteEndSlow(token);
			}
			else
			{
				WriteEndMinimized(token);
			}
			SetFlagToAddListSeparatorBeforeNextItem();
			if (CurrentDepth != 0)
			{
				_currentDepth--;
			}
		}

		private void WriteEndMinimized(byte token)
		{
			if (_memory.Length - BytesPending < 1)
			{
				Grow(1);
			}
			_memory.Span[BytesPending++] = token;
		}

		private void WriteEndSlow(byte token)
		{
			if (_options.Indented)
			{
				if (!_options.SkipValidation)
				{
					ValidateEnd(token);
				}
				WriteEndIndented(token);
			}
			else
			{
				ValidateEnd(token);
				WriteEndMinimized(token);
			}
		}

		private void ValidateEnd(byte token)
		{
			if (_bitStack.CurrentDepth <= 0 || _tokenType == JsonTokenType.PropertyName)
			{
				ThrowHelper.ThrowInvalidOperationException(ExceptionResource.MismatchedObjectArray, 0, _options.MaxDepth, token, _tokenType);
			}
			if (token == 93)
			{
				if (_inObject)
				{
					ThrowHelper.ThrowInvalidOperationException(ExceptionResource.MismatchedObjectArray, 0, _options.MaxDepth, token, _tokenType);
				}
			}
			else if (!_inObject)
			{
				ThrowHelper.ThrowInvalidOperationException(ExceptionResource.MismatchedObjectArray, 0, _options.MaxDepth, token, _tokenType);
			}
			_inObject = _bitStack.Pop();
		}

		private void WriteEndIndented(byte token)
		{
			if (_tokenType == JsonTokenType.StartObject || _tokenType == JsonTokenType.StartArray)
			{
				WriteEndMinimized(token);
				return;
			}
			int num = Indentation;
			if (num != 0)
			{
				num -= 2;
			}
			int num2 = num + 3;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			WriteNewLine(span);
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), num);
			BytesPending += num;
			span[BytesPending++] = token;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void WriteNewLine(Span<byte> output)
		{
			if (s_newLineLength == 2)
			{
				output[BytesPending++] = 13;
			}
			output[BytesPending++] = 10;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void UpdateBitStackOnStart(byte token)
		{
			if (token == 91)
			{
				_bitStack.PushFalse();
				_inObject = false;
			}
			else
			{
				_bitStack.PushTrue();
				_inObject = true;
			}
		}

		private void Grow(int requiredSize)
		{
			if (_memory.Length == 0)
			{
				FirstCallToGetMemory(requiredSize);
				return;
			}
			int num = Math.Max(4096, requiredSize);
			if (_stream != null)
			{
				int num2 = BytesPending + num;
				JsonHelpers.ValidateInt32MaxArrayLength((uint)num2);
				_memory = _arrayBufferWriter.GetMemory(num2);
				return;
			}
			_output.Advance(BytesPending);
			BytesCommitted += BytesPending;
			BytesPending = 0;
			_memory = _output.GetMemory(num);
			if (_memory.Length < num)
			{
				ThrowHelper.ThrowInvalidOperationException_NeedLargerSpan();
			}
		}

		private void FirstCallToGetMemory(int requiredSize)
		{
			int num = Math.Max(256, requiredSize);
			if (_stream != null)
			{
				_memory = _arrayBufferWriter.GetMemory(num);
				return;
			}
			_memory = _output.GetMemory(num);
			if (_memory.Length < num)
			{
				ThrowHelper.ThrowInvalidOperationException_NeedLargerSpan();
			}
		}

		private void SetFlagToAddListSeparatorBeforeNextItem()
		{
			_currentDepth |= int.MinValue;
		}

		public void WriteBase64String(JsonEncodedText propertyName, ReadOnlySpan<byte> bytes)
		{
			ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
			WriteBase64ByOptions(encodedUtf8Bytes, bytes);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteBase64String(string propertyName, ReadOnlySpan<byte> bytes)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteBase64String(MemoryExtensions.AsSpan(propertyName), bytes);
		}

		public void WriteBase64String(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> bytes)
		{
			JsonWriterHelper.ValidatePropertyNameLength(propertyName);
			WriteBase64Escape(propertyName, bytes);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteBase64String(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> bytes)
		{
			JsonWriterHelper.ValidatePropertyNameLength(utf8PropertyName);
			WriteBase64Escape(utf8PropertyName, bytes);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		private void WriteBase64Escape(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> bytes)
		{
			int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num != -1)
			{
				WriteBase64EscapeProperty(propertyName, bytes, num);
			}
			else
			{
				WriteBase64ByOptions(propertyName, bytes);
			}
		}

		private void WriteBase64Escape(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> bytes)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num != -1)
			{
				WriteBase64EscapeProperty(utf8PropertyName, bytes, num);
			}
			else
			{
				WriteBase64ByOptions(utf8PropertyName, bytes);
			}
		}

		private void WriteBase64EscapeProperty(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> bytes, int firstEscapeIndexProp)
		{
			char[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
			Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
			Span<char> destination = span;
			JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteBase64ByOptions(destination.Slice(0, written), bytes);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		private void WriteBase64EscapeProperty(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> bytes, int firstEscapeIndexProp)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteBase64ByOptions(destination.Slice(0, written), bytes);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		private void WriteBase64ByOptions(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> bytes)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteBase64Indented(propertyName, bytes);
			}
			else
			{
				WriteBase64Minimized(propertyName, bytes);
			}
		}

		private void WriteBase64ByOptions(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> bytes)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteBase64Indented(utf8PropertyName, bytes);
			}
			else
			{
				WriteBase64Minimized(utf8PropertyName, bytes);
			}
		}

		private void WriteBase64Minimized(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<byte> bytes)
		{
			int maxEncodedToUtf8Length = Base64.GetMaxEncodedToUtf8Length(bytes.Length);
			int num = escapedPropertyName.Length * 3 + maxEncodedToUtf8Length + 6;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 34;
			Base64EncodeAndWrite(bytes, span, maxEncodedToUtf8Length);
			span[BytesPending++] = 34;
		}

		private void WriteBase64Minimized(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<byte> bytes)
		{
			int maxEncodedToUtf8Length = Base64.GetMaxEncodedToUtf8Length(bytes.Length);
			int num = escapedPropertyName.Length + maxEncodedToUtf8Length + 6;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 34;
			Base64EncodeAndWrite(bytes, span, maxEncodedToUtf8Length);
			span[BytesPending++] = 34;
		}

		private void WriteBase64Indented(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<byte> bytes)
		{
			int indentation = Indentation;
			int maxEncodedToUtf8Length = Base64.GetMaxEncodedToUtf8Length(bytes.Length);
			int num = indentation + escapedPropertyName.Length * 3 + maxEncodedToUtf8Length + 7 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			span[BytesPending++] = 34;
			Base64EncodeAndWrite(bytes, span, maxEncodedToUtf8Length);
			span[BytesPending++] = 34;
		}

		private void WriteBase64Indented(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<byte> bytes)
		{
			int indentation = Indentation;
			int maxEncodedToUtf8Length = Base64.GetMaxEncodedToUtf8Length(bytes.Length);
			int num = indentation + escapedPropertyName.Length + maxEncodedToUtf8Length + 7 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			span[BytesPending++] = 34;
			Base64EncodeAndWrite(bytes, span, maxEncodedToUtf8Length);
			span[BytesPending++] = 34;
		}

		public void WriteString(JsonEncodedText propertyName, DateTime value)
		{
			ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
			WriteStringByOptions(encodedUtf8Bytes, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteString(string propertyName, DateTime value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteString(MemoryExtensions.AsSpan(propertyName), value);
		}

		public void WriteString(ReadOnlySpan<char> propertyName, DateTime value)
		{
			JsonWriterHelper.ValidateProperty(propertyName);
			WriteStringEscape(propertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteString(ReadOnlySpan<byte> utf8PropertyName, DateTime value)
		{
			JsonWriterHelper.ValidateProperty(utf8PropertyName);
			WriteStringEscape(utf8PropertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		private void WriteStringEscape(ReadOnlySpan<char> propertyName, DateTime value)
		{
			int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num != -1)
			{
				WriteStringEscapeProperty(propertyName, value, num);
			}
			else
			{
				WriteStringByOptions(propertyName, value);
			}
		}

		private void WriteStringEscape(ReadOnlySpan<byte> utf8PropertyName, DateTime value)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num != -1)
			{
				WriteStringEscapeProperty(utf8PropertyName, value, num);
			}
			else
			{
				WriteStringByOptions(utf8PropertyName, value);
			}
		}

		private void WriteStringEscapeProperty(ReadOnlySpan<char> propertyName, DateTime value, int firstEscapeIndexProp)
		{
			char[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
			Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
			Span<char> destination = span;
			JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteStringByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		private void WriteStringEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, DateTime value, int firstEscapeIndexProp)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteStringByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		private void WriteStringByOptions(ReadOnlySpan<char> propertyName, DateTime value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteStringIndented(propertyName, value);
			}
			else
			{
				WriteStringMinimized(propertyName, value);
			}
		}

		private void WriteStringByOptions(ReadOnlySpan<byte> utf8PropertyName, DateTime value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteStringIndented(utf8PropertyName, value);
			}
			else
			{
				WriteStringMinimized(utf8PropertyName, value);
			}
		}

		private void WriteStringMinimized(ReadOnlySpan<char> escapedPropertyName, DateTime value)
		{
			int num = escapedPropertyName.Length * 3 + 33 + 6;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 34;
			JsonWriterHelper.WriteDateTimeTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		private void WriteStringMinimized(ReadOnlySpan<byte> escapedPropertyName, DateTime value)
		{
			int num = escapedPropertyName.Length + 33 + 5;
			int num2 = num + 1;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 34;
			JsonWriterHelper.WriteDateTimeTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		private void WriteStringIndented(ReadOnlySpan<char> escapedPropertyName, DateTime value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length * 3 + 33 + 7 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			span[BytesPending++] = 34;
			JsonWriterHelper.WriteDateTimeTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		private void WriteStringIndented(ReadOnlySpan<byte> escapedPropertyName, DateTime value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length + 33 + 6;
			int num2 = num + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			span[BytesPending++] = 34;
			JsonWriterHelper.WriteDateTimeTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		internal void WritePropertyName(DateTime value)
		{
			Span<byte> buffer = stackalloc byte[33];
			JsonWriterHelper.WriteDateTimeTrimmed(buffer, value, out var bytesWritten);
			WritePropertyNameUnescaped(buffer.Slice(0, bytesWritten));
		}

		public void WriteString(JsonEncodedText propertyName, DateTimeOffset value)
		{
			ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
			WriteStringByOptions(encodedUtf8Bytes, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteString(string propertyName, DateTimeOffset value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteString(MemoryExtensions.AsSpan(propertyName), value);
		}

		public void WriteString(ReadOnlySpan<char> propertyName, DateTimeOffset value)
		{
			JsonWriterHelper.ValidateProperty(propertyName);
			WriteStringEscape(propertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteString(ReadOnlySpan<byte> utf8PropertyName, DateTimeOffset value)
		{
			JsonWriterHelper.ValidateProperty(utf8PropertyName);
			WriteStringEscape(utf8PropertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		private void WriteStringEscape(ReadOnlySpan<char> propertyName, DateTimeOffset value)
		{
			int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num != -1)
			{
				WriteStringEscapeProperty(propertyName, value, num);
			}
			else
			{
				WriteStringByOptions(propertyName, value);
			}
		}

		private void WriteStringEscape(ReadOnlySpan<byte> utf8PropertyName, DateTimeOffset value)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num != -1)
			{
				WriteStringEscapeProperty(utf8PropertyName, value, num);
			}
			else
			{
				WriteStringByOptions(utf8PropertyName, value);
			}
		}

		private void WriteStringEscapeProperty(ReadOnlySpan<char> propertyName, DateTimeOffset value, int firstEscapeIndexProp)
		{
			char[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
			Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
			Span<char> destination = span;
			JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteStringByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		private void WriteStringEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, DateTimeOffset value, int firstEscapeIndexProp)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteStringByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		private void WriteStringByOptions(ReadOnlySpan<char> propertyName, DateTimeOffset value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteStringIndented(propertyName, value);
			}
			else
			{
				WriteStringMinimized(propertyName, value);
			}
		}

		private void WriteStringByOptions(ReadOnlySpan<byte> utf8PropertyName, DateTimeOffset value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteStringIndented(utf8PropertyName, value);
			}
			else
			{
				WriteStringMinimized(utf8PropertyName, value);
			}
		}

		private void WriteStringMinimized(ReadOnlySpan<char> escapedPropertyName, DateTimeOffset value)
		{
			int num = escapedPropertyName.Length * 3 + 33 + 6;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 34;
			JsonWriterHelper.WriteDateTimeOffsetTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		private void WriteStringMinimized(ReadOnlySpan<byte> escapedPropertyName, DateTimeOffset value)
		{
			int num = escapedPropertyName.Length + 33 + 5;
			int num2 = num + 1;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 34;
			JsonWriterHelper.WriteDateTimeOffsetTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		private void WriteStringIndented(ReadOnlySpan<char> escapedPropertyName, DateTimeOffset value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length * 3 + 33 + 7 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			span[BytesPending++] = 34;
			JsonWriterHelper.WriteDateTimeOffsetTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		private void WriteStringIndented(ReadOnlySpan<byte> escapedPropertyName, DateTimeOffset value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length + 33 + 6;
			int num2 = num + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			span[BytesPending++] = 34;
			JsonWriterHelper.WriteDateTimeOffsetTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		internal void WritePropertyName(DateTimeOffset value)
		{
			Span<byte> buffer = stackalloc byte[33];
			JsonWriterHelper.WriteDateTimeOffsetTrimmed(buffer, value, out var bytesWritten);
			WritePropertyNameUnescaped(buffer.Slice(0, bytesWritten));
		}

		public void WriteNumber(JsonEncodedText propertyName, decimal value)
		{
			ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
			WriteNumberByOptions(encodedUtf8Bytes, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		public void WriteNumber(string propertyName, decimal value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteNumber(MemoryExtensions.AsSpan(propertyName), value);
		}

		public void WriteNumber(ReadOnlySpan<char> propertyName, decimal value)
		{
			JsonWriterHelper.ValidateProperty(propertyName);
			WriteNumberEscape(propertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, decimal value)
		{
			JsonWriterHelper.ValidateProperty(utf8PropertyName);
			WriteNumberEscape(utf8PropertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		private void WriteNumberEscape(ReadOnlySpan<char> propertyName, decimal value)
		{
			int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num != -1)
			{
				WriteNumberEscapeProperty(propertyName, value, num);
			}
			else
			{
				WriteNumberByOptions(propertyName, value);
			}
		}

		private void WriteNumberEscape(ReadOnlySpan<byte> utf8PropertyName, decimal value)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num != -1)
			{
				WriteNumberEscapeProperty(utf8PropertyName, value, num);
			}
			else
			{
				WriteNumberByOptions(utf8PropertyName, value);
			}
		}

		private void WriteNumberEscapeProperty(ReadOnlySpan<char> propertyName, decimal value, int firstEscapeIndexProp)
		{
			char[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
			Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
			Span<char> destination = span;
			JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteNumberByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		private void WriteNumberEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, decimal value, int firstEscapeIndexProp)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteNumberByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		private void WriteNumberByOptions(ReadOnlySpan<char> propertyName, decimal value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteNumberIndented(propertyName, value);
			}
			else
			{
				WriteNumberMinimized(propertyName, value);
			}
		}

		private void WriteNumberByOptions(ReadOnlySpan<byte> utf8PropertyName, decimal value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteNumberIndented(utf8PropertyName, value);
			}
			else
			{
				WriteNumberMinimized(utf8PropertyName, value);
			}
		}

		private void WriteNumberMinimized(ReadOnlySpan<char> escapedPropertyName, decimal value)
		{
			int num = escapedPropertyName.Length * 3 + 31 + 4;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberMinimized(ReadOnlySpan<byte> escapedPropertyName, decimal value)
		{
			int num = escapedPropertyName.Length + 31 + 3;
			int num2 = num + 1;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberIndented(ReadOnlySpan<char> escapedPropertyName, decimal value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length * 3 + 31 + 5 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberIndented(ReadOnlySpan<byte> escapedPropertyName, decimal value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length + 31 + 4;
			int num2 = num + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		internal void WritePropertyName(decimal value)
		{
			Span<byte> destination = stackalloc byte[31];
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
			WritePropertyNameUnescaped(destination.Slice(0, bytesWritten));
		}

		public void WriteNumber(JsonEncodedText propertyName, double value)
		{
			ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
			JsonWriterHelper.ValidateDouble(value);
			WriteNumberByOptions(encodedUtf8Bytes, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		public void WriteNumber(string propertyName, double value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteNumber(MemoryExtensions.AsSpan(propertyName), value);
		}

		public void WriteNumber(ReadOnlySpan<char> propertyName, double value)
		{
			JsonWriterHelper.ValidateProperty(propertyName);
			JsonWriterHelper.ValidateDouble(value);
			WriteNumberEscape(propertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, double value)
		{
			JsonWriterHelper.ValidateProperty(utf8PropertyName);
			JsonWriterHelper.ValidateDouble(value);
			WriteNumberEscape(utf8PropertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		private void WriteNumberEscape(ReadOnlySpan<char> propertyName, double value)
		{
			int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num != -1)
			{
				WriteNumberEscapeProperty(propertyName, value, num);
			}
			else
			{
				WriteNumberByOptions(propertyName, value);
			}
		}

		private void WriteNumberEscape(ReadOnlySpan<byte> utf8PropertyName, double value)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num != -1)
			{
				WriteNumberEscapeProperty(utf8PropertyName, value, num);
			}
			else
			{
				WriteNumberByOptions(utf8PropertyName, value);
			}
		}

		private void WriteNumberEscapeProperty(ReadOnlySpan<char> propertyName, double value, int firstEscapeIndexProp)
		{
			char[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
			Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
			Span<char> destination = span;
			JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteNumberByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		private void WriteNumberEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, double value, int firstEscapeIndexProp)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteNumberByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		private void WriteNumberByOptions(ReadOnlySpan<char> propertyName, double value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteNumberIndented(propertyName, value);
			}
			else
			{
				WriteNumberMinimized(propertyName, value);
			}
		}

		private void WriteNumberByOptions(ReadOnlySpan<byte> utf8PropertyName, double value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteNumberIndented(utf8PropertyName, value);
			}
			else
			{
				WriteNumberMinimized(utf8PropertyName, value);
			}
		}

		private void WriteNumberMinimized(ReadOnlySpan<char> escapedPropertyName, double value)
		{
			int num = escapedPropertyName.Length * 3 + 128 + 4;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			int bytesWritten;
			bool flag = TryFormatDouble(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberMinimized(ReadOnlySpan<byte> escapedPropertyName, double value)
		{
			int num = escapedPropertyName.Length + 128 + 3;
			int num2 = num + 1;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			int bytesWritten;
			bool flag = TryFormatDouble(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberIndented(ReadOnlySpan<char> escapedPropertyName, double value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length * 3 + 128 + 5 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			int bytesWritten;
			bool flag = TryFormatDouble(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberIndented(ReadOnlySpan<byte> escapedPropertyName, double value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length + 128 + 4;
			int num2 = num + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			int bytesWritten;
			bool flag = TryFormatDouble(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		internal void WritePropertyName(double value)
		{
			JsonWriterHelper.ValidateDouble(value);
			Span<byte> destination = stackalloc byte[128];
			int bytesWritten;
			bool flag = TryFormatDouble(value, destination, out bytesWritten);
			WritePropertyNameUnescaped(destination.Slice(0, bytesWritten));
		}

		public void WriteNumber(JsonEncodedText propertyName, float value)
		{
			ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
			JsonWriterHelper.ValidateSingle(value);
			WriteNumberByOptions(encodedUtf8Bytes, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		public void WriteNumber(string propertyName, float value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteNumber(MemoryExtensions.AsSpan(propertyName), value);
		}

		public void WriteNumber(ReadOnlySpan<char> propertyName, float value)
		{
			JsonWriterHelper.ValidateProperty(propertyName);
			JsonWriterHelper.ValidateSingle(value);
			WriteNumberEscape(propertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, float value)
		{
			JsonWriterHelper.ValidateProperty(utf8PropertyName);
			JsonWriterHelper.ValidateSingle(value);
			WriteNumberEscape(utf8PropertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		private void WriteNumberEscape(ReadOnlySpan<char> propertyName, float value)
		{
			int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num != -1)
			{
				WriteNumberEscapeProperty(propertyName, value, num);
			}
			else
			{
				WriteNumberByOptions(propertyName, value);
			}
		}

		private void WriteNumberEscape(ReadOnlySpan<byte> utf8PropertyName, float value)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num != -1)
			{
				WriteNumberEscapeProperty(utf8PropertyName, value, num);
			}
			else
			{
				WriteNumberByOptions(utf8PropertyName, value);
			}
		}

		private void WriteNumberEscapeProperty(ReadOnlySpan<char> propertyName, float value, int firstEscapeIndexProp)
		{
			char[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
			Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
			Span<char> destination = span;
			JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteNumberByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		private void WriteNumberEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, float value, int firstEscapeIndexProp)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteNumberByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		private void WriteNumberByOptions(ReadOnlySpan<char> propertyName, float value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteNumberIndented(propertyName, value);
			}
			else
			{
				WriteNumberMinimized(propertyName, value);
			}
		}

		private void WriteNumberByOptions(ReadOnlySpan<byte> utf8PropertyName, float value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteNumberIndented(utf8PropertyName, value);
			}
			else
			{
				WriteNumberMinimized(utf8PropertyName, value);
			}
		}

		private void WriteNumberMinimized(ReadOnlySpan<char> escapedPropertyName, float value)
		{
			int num = escapedPropertyName.Length * 3 + 128 + 4;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			int bytesWritten;
			bool flag = TryFormatSingle(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberMinimized(ReadOnlySpan<byte> escapedPropertyName, float value)
		{
			int num = escapedPropertyName.Length + 128 + 3;
			int num2 = num + 1;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			int bytesWritten;
			bool flag = TryFormatSingle(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberIndented(ReadOnlySpan<char> escapedPropertyName, float value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length * 3 + 128 + 5 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			int bytesWritten;
			bool flag = TryFormatSingle(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberIndented(ReadOnlySpan<byte> escapedPropertyName, float value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length + 128 + 4;
			int num2 = num + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			int bytesWritten;
			bool flag = TryFormatSingle(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		internal void WritePropertyName(float value)
		{
			Span<byte> destination = stackalloc byte[128];
			int bytesWritten;
			bool flag = TryFormatSingle(value, destination, out bytesWritten);
			WritePropertyNameUnescaped(destination.Slice(0, bytesWritten));
		}

		internal void WriteNumber(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> utf8FormattedNumber)
		{
			JsonWriterHelper.ValidateProperty(propertyName);
			JsonWriterHelper.ValidateValue(utf8FormattedNumber);
			JsonWriterHelper.ValidateNumber(utf8FormattedNumber);
			WriteNumberEscape(propertyName, utf8FormattedNumber);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		internal void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> utf8FormattedNumber)
		{
			JsonWriterHelper.ValidateProperty(utf8PropertyName);
			JsonWriterHelper.ValidateValue(utf8FormattedNumber);
			JsonWriterHelper.ValidateNumber(utf8FormattedNumber);
			WriteNumberEscape(utf8PropertyName, utf8FormattedNumber);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		internal void WriteNumber(JsonEncodedText propertyName, ReadOnlySpan<byte> utf8FormattedNumber)
		{
			JsonWriterHelper.ValidateValue(utf8FormattedNumber);
			JsonWriterHelper.ValidateNumber(utf8FormattedNumber);
			WriteNumberByOptions(propertyName.EncodedUtf8Bytes, utf8FormattedNumber);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		private void WriteNumberEscape(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value)
		{
			int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num != -1)
			{
				WriteNumberEscapeProperty(propertyName, value, num);
			}
			else
			{
				WriteNumberByOptions(propertyName, value);
			}
		}

		private void WriteNumberEscape(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> value)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num != -1)
			{
				WriteNumberEscapeProperty(utf8PropertyName, value, num);
			}
			else
			{
				WriteNumberByOptions(utf8PropertyName, value);
			}
		}

		private void WriteNumberEscapeProperty(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value, int firstEscapeIndexProp)
		{
			char[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
			Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
			Span<char> destination = span;
			JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteNumberByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		private void WriteNumberEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> value, int firstEscapeIndexProp)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteNumberByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		private void WriteNumberByOptions(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteLiteralIndented(propertyName, value);
			}
			else
			{
				WriteLiteralMinimized(propertyName, value);
			}
		}

		private void WriteNumberByOptions(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteLiteralIndented(utf8PropertyName, value);
			}
			else
			{
				WriteLiteralMinimized(utf8PropertyName, value);
			}
		}

		public void WriteString(JsonEncodedText propertyName, Guid value)
		{
			ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
			WriteStringByOptions(encodedUtf8Bytes, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteString(string propertyName, Guid value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteString(MemoryExtensions.AsSpan(propertyName), value);
		}

		public void WriteString(ReadOnlySpan<char> propertyName, Guid value)
		{
			JsonWriterHelper.ValidateProperty(propertyName);
			WriteStringEscape(propertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteString(ReadOnlySpan<byte> utf8PropertyName, Guid value)
		{
			JsonWriterHelper.ValidateProperty(utf8PropertyName);
			WriteStringEscape(utf8PropertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		private void WriteStringEscape(ReadOnlySpan<char> propertyName, Guid value)
		{
			int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num != -1)
			{
				WriteStringEscapeProperty(propertyName, value, num);
			}
			else
			{
				WriteStringByOptions(propertyName, value);
			}
		}

		private void WriteStringEscape(ReadOnlySpan<byte> utf8PropertyName, Guid value)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num != -1)
			{
				WriteStringEscapeProperty(utf8PropertyName, value, num);
			}
			else
			{
				WriteStringByOptions(utf8PropertyName, value);
			}
		}

		private void WriteStringEscapeProperty(ReadOnlySpan<char> propertyName, Guid value, int firstEscapeIndexProp)
		{
			char[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
			Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
			Span<char> destination = span;
			JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteStringByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		private void WriteStringEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, Guid value, int firstEscapeIndexProp)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteStringByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		private void WriteStringByOptions(ReadOnlySpan<char> propertyName, Guid value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteStringIndented(propertyName, value);
			}
			else
			{
				WriteStringMinimized(propertyName, value);
			}
		}

		private void WriteStringByOptions(ReadOnlySpan<byte> utf8PropertyName, Guid value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteStringIndented(utf8PropertyName, value);
			}
			else
			{
				WriteStringMinimized(utf8PropertyName, value);
			}
		}

		private void WriteStringMinimized(ReadOnlySpan<char> escapedPropertyName, Guid value)
		{
			int num = escapedPropertyName.Length * 3 + 36 + 6;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 34;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		private void WriteStringMinimized(ReadOnlySpan<byte> escapedPropertyName, Guid value)
		{
			int num = escapedPropertyName.Length + 36 + 5;
			int num2 = num + 1;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 34;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		private void WriteStringIndented(ReadOnlySpan<char> escapedPropertyName, Guid value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length * 3 + 36 + 7 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			span[BytesPending++] = 34;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		private void WriteStringIndented(ReadOnlySpan<byte> escapedPropertyName, Guid value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length + 36 + 6;
			int num2 = num + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			span[BytesPending++] = 34;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		internal void WritePropertyName(Guid value)
		{
			Span<byte> destination = stackalloc byte[36];
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
			WritePropertyNameUnescaped(destination.Slice(0, bytesWritten));
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void ValidatePropertyNameAndDepth(ReadOnlySpan<char> propertyName)
		{
			if (propertyName.Length > 166666666 || CurrentDepth >= _options.MaxDepth)
			{
				ThrowHelper.ThrowInvalidOperationOrArgumentException(propertyName, _currentDepth, _options.MaxDepth);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void ValidatePropertyNameAndDepth(ReadOnlySpan<byte> utf8PropertyName)
		{
			if (utf8PropertyName.Length > 166666666 || CurrentDepth >= _options.MaxDepth)
			{
				ThrowHelper.ThrowInvalidOperationOrArgumentException(utf8PropertyName, _currentDepth, _options.MaxDepth);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void ValidateDepth()
		{
			if (CurrentDepth >= _options.MaxDepth)
			{
				ThrowHelper.ThrowInvalidOperationException(_currentDepth, _options.MaxDepth);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void ValidateWritingProperty()
		{
			if (!_options.SkipValidation && (!_inObject || _tokenType == JsonTokenType.PropertyName))
			{
				ThrowHelper.ThrowInvalidOperationException(ExceptionResource.CannotWritePropertyWithinArray, 0, _options.MaxDepth, 0, _tokenType);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void ValidateWritingProperty(byte token)
		{
			if (!_options.SkipValidation)
			{
				if (!_inObject || _tokenType == JsonTokenType.PropertyName)
				{
					ThrowHelper.ThrowInvalidOperationException(ExceptionResource.CannotWritePropertyWithinArray, 0, _options.MaxDepth, 0, _tokenType);
				}
				UpdateBitStackOnStart(token);
			}
		}

		private void WritePropertyNameMinimized(ReadOnlySpan<byte> escapedPropertyName, byte token)
		{
			int num = escapedPropertyName.Length + 4;
			int num2 = num + 1;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = token;
		}

		private void WritePropertyNameIndented(ReadOnlySpan<byte> escapedPropertyName, byte token)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length + 5;
			int num2 = num + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			span[BytesPending++] = token;
		}

		private void WritePropertyNameMinimized(ReadOnlySpan<char> escapedPropertyName, byte token)
		{
			int num = escapedPropertyName.Length * 3 + 5;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = token;
		}

		private void WritePropertyNameIndented(ReadOnlySpan<char> escapedPropertyName, byte token)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length * 3 + 6 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			span[BytesPending++] = token;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void TranscodeAndWrite(ReadOnlySpan<char> escapedPropertyName, Span<byte> output)
		{
			int written;
			OperationStatus operationStatus = JsonWriterHelper.ToUtf8(escapedPropertyName, output.Slice(BytesPending), out written);
			BytesPending += written;
		}

		public void WriteNull(JsonEncodedText propertyName)
		{
			WriteLiteralHelper(propertyName.EncodedUtf8Bytes, JsonConstants.NullValue);
			_tokenType = JsonTokenType.Null;
		}

		internal void WriteNullSection(ReadOnlySpan<byte> escapedPropertyNameSection)
		{
			if (_options.Indented)
			{
				ReadOnlySpan<byte> utf8PropertyName = escapedPropertyNameSection.Slice(1, escapedPropertyNameSection.Length - 3);
				WriteLiteralHelper(utf8PropertyName, JsonConstants.NullValue);
				_tokenType = JsonTokenType.Null;
			}
			else
			{
				ReadOnlySpan<byte> nullValue = JsonConstants.NullValue;
				WriteLiteralSection(escapedPropertyNameSection, nullValue);
				SetFlagToAddListSeparatorBeforeNextItem();
				_tokenType = JsonTokenType.Null;
			}
		}

		private void WriteLiteralHelper(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> value)
		{
			WriteLiteralByOptions(utf8PropertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
		}

		public void WriteNull(string propertyName)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteNull(MemoryExtensions.AsSpan(propertyName));
		}

		public void WriteNull(ReadOnlySpan<char> propertyName)
		{
			JsonWriterHelper.ValidateProperty(propertyName);
			ReadOnlySpan<byte> nullValue = JsonConstants.NullValue;
			WriteLiteralEscape(propertyName, nullValue);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Null;
		}

		public void WriteNull(ReadOnlySpan<byte> utf8PropertyName)
		{
			JsonWriterHelper.ValidateProperty(utf8PropertyName);
			ReadOnlySpan<byte> nullValue = JsonConstants.NullValue;
			WriteLiteralEscape(utf8PropertyName, nullValue);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Null;
		}

		public void WriteBoolean(JsonEncodedText propertyName, bool value)
		{
			if (value)
			{
				WriteLiteralHelper(propertyName.EncodedUtf8Bytes, JsonConstants.TrueValue);
				_tokenType = JsonTokenType.True;
			}
			else
			{
				WriteLiteralHelper(propertyName.EncodedUtf8Bytes, JsonConstants.FalseValue);
				_tokenType = JsonTokenType.False;
			}
		}

		public void WriteBoolean(string propertyName, bool value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteBoolean(MemoryExtensions.AsSpan(propertyName), value);
		}

		public void WriteBoolean(ReadOnlySpan<char> propertyName, bool value)
		{
			JsonWriterHelper.ValidateProperty(propertyName);
			ReadOnlySpan<byte> value2 = (value ? JsonConstants.TrueValue : JsonConstants.FalseValue);
			WriteLiteralEscape(propertyName, value2);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = (value ? JsonTokenType.True : JsonTokenType.False);
		}

		public void WriteBoolean(ReadOnlySpan<byte> utf8PropertyName, bool value)
		{
			JsonWriterHelper.ValidateProperty(utf8PropertyName);
			ReadOnlySpan<byte> value2 = (value ? JsonConstants.TrueValue : JsonConstants.FalseValue);
			WriteLiteralEscape(utf8PropertyName, value2);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = (value ? JsonTokenType.True : JsonTokenType.False);
		}

		private void WriteLiteralEscape(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value)
		{
			int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num != -1)
			{
				WriteLiteralEscapeProperty(propertyName, value, num);
			}
			else
			{
				WriteLiteralByOptions(propertyName, value);
			}
		}

		private void WriteLiteralEscape(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> value)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num != -1)
			{
				WriteLiteralEscapeProperty(utf8PropertyName, value, num);
			}
			else
			{
				WriteLiteralByOptions(utf8PropertyName, value);
			}
		}

		private void WriteLiteralEscapeProperty(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value, int firstEscapeIndexProp)
		{
			char[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
			Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
			Span<char> destination = span;
			JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteLiteralByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		private void WriteLiteralEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> value, int firstEscapeIndexProp)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteLiteralByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		private void WriteLiteralByOptions(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteLiteralIndented(propertyName, value);
			}
			else
			{
				WriteLiteralMinimized(propertyName, value);
			}
		}

		private void WriteLiteralByOptions(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteLiteralIndented(utf8PropertyName, value);
			}
			else
			{
				WriteLiteralMinimized(utf8PropertyName, value);
			}
		}

		private void WriteLiteralMinimized(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<byte> value)
		{
			int num = escapedPropertyName.Length * 3 + value.Length + 4;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			value.CopyTo(span.Slice(BytesPending));
			BytesPending += value.Length;
		}

		private void WriteLiteralMinimized(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<byte> value)
		{
			int num = escapedPropertyName.Length + value.Length + 3;
			int num2 = num + 1;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			value.CopyTo(span.Slice(BytesPending));
			BytesPending += value.Length;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void WriteLiteralSection(ReadOnlySpan<byte> escapedPropertyNameSection, ReadOnlySpan<byte> value)
		{
			int num = escapedPropertyNameSection.Length + value.Length;
			int num2 = num + 1;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			escapedPropertyNameSection.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyNameSection.Length;
			value.CopyTo(span.Slice(BytesPending));
			BytesPending += value.Length;
		}

		private void WriteLiteralIndented(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<byte> value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length * 3 + value.Length + 5 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			value.CopyTo(span.Slice(BytesPending));
			BytesPending += value.Length;
		}

		private void WriteLiteralIndented(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<byte> value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length + value.Length + 4;
			int num2 = num + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			value.CopyTo(span.Slice(BytesPending));
			BytesPending += value.Length;
		}

		internal void WritePropertyName(bool value)
		{
			Span<byte> destination = stackalloc byte[5];
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
			WritePropertyNameUnescaped(destination.Slice(0, bytesWritten));
		}

		public void WriteNumber(JsonEncodedText propertyName, long value)
		{
			ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
			WriteNumberByOptions(encodedUtf8Bytes, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		public void WriteNumber(string propertyName, long value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteNumber(MemoryExtensions.AsSpan(propertyName), value);
		}

		public void WriteNumber(ReadOnlySpan<char> propertyName, long value)
		{
			JsonWriterHelper.ValidateProperty(propertyName);
			WriteNumberEscape(propertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, long value)
		{
			JsonWriterHelper.ValidateProperty(utf8PropertyName);
			WriteNumberEscape(utf8PropertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		public void WriteNumber(JsonEncodedText propertyName, int value)
		{
			WriteNumber(propertyName, (long)value);
		}

		public void WriteNumber(string propertyName, int value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteNumber(MemoryExtensions.AsSpan(propertyName), (long)value);
		}

		public void WriteNumber(ReadOnlySpan<char> propertyName, int value)
		{
			WriteNumber(propertyName, (long)value);
		}

		public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, int value)
		{
			WriteNumber(utf8PropertyName, (long)value);
		}

		private void WriteNumberEscape(ReadOnlySpan<char> propertyName, long value)
		{
			int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num != -1)
			{
				WriteNumberEscapeProperty(propertyName, value, num);
			}
			else
			{
				WriteNumberByOptions(propertyName, value);
			}
		}

		private void WriteNumberEscape(ReadOnlySpan<byte> utf8PropertyName, long value)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num != -1)
			{
				WriteNumberEscapeProperty(utf8PropertyName, value, num);
			}
			else
			{
				WriteNumberByOptions(utf8PropertyName, value);
			}
		}

		private void WriteNumberEscapeProperty(ReadOnlySpan<char> propertyName, long value, int firstEscapeIndexProp)
		{
			char[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
			Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
			Span<char> destination = span;
			JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteNumberByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		private void WriteNumberEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, long value, int firstEscapeIndexProp)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteNumberByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		private void WriteNumberByOptions(ReadOnlySpan<char> propertyName, long value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteNumberIndented(propertyName, value);
			}
			else
			{
				WriteNumberMinimized(propertyName, value);
			}
		}

		private void WriteNumberByOptions(ReadOnlySpan<byte> utf8PropertyName, long value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteNumberIndented(utf8PropertyName, value);
			}
			else
			{
				WriteNumberMinimized(utf8PropertyName, value);
			}
		}

		private void WriteNumberMinimized(ReadOnlySpan<char> escapedPropertyName, long value)
		{
			int num = escapedPropertyName.Length * 3 + 20 + 4;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberMinimized(ReadOnlySpan<byte> escapedPropertyName, long value)
		{
			int num = escapedPropertyName.Length + 20 + 3;
			int num2 = num + 1;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberIndented(ReadOnlySpan<char> escapedPropertyName, long value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length * 3 + 20 + 5 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberIndented(ReadOnlySpan<byte> escapedPropertyName, long value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length + 20 + 4;
			int num2 = num + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		internal void WritePropertyName(int value)
		{
			WritePropertyName((long)value);
		}

		internal void WritePropertyName(long value)
		{
			Span<byte> destination = stackalloc byte[20];
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
			WritePropertyNameUnescaped(destination.Slice(0, bytesWritten));
		}

		public void WritePropertyName(JsonEncodedText propertyName)
		{
			WritePropertyNameHelper(propertyName.EncodedUtf8Bytes);
		}

		internal void WritePropertyNameSection(ReadOnlySpan<byte> escapedPropertyNameSection)
		{
			if (_options.Indented)
			{
				ReadOnlySpan<byte> utf8PropertyName = escapedPropertyNameSection.Slice(1, escapedPropertyNameSection.Length - 3);
				WritePropertyNameHelper(utf8PropertyName);
				return;
			}
			WriteStringPropertyNameSection(escapedPropertyNameSection);
			_currentDepth &= int.MaxValue;
			_tokenType = JsonTokenType.PropertyName;
			_commentAfterNoneOrPropertyName = false;
		}

		private void WritePropertyNameHelper(ReadOnlySpan<byte> utf8PropertyName)
		{
			WriteStringByOptionsPropertyName(utf8PropertyName);
			_currentDepth &= int.MaxValue;
			_tokenType = JsonTokenType.PropertyName;
			_commentAfterNoneOrPropertyName = false;
		}

		public void WritePropertyName(string propertyName)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WritePropertyName(MemoryExtensions.AsSpan(propertyName));
		}

		public void WritePropertyName(ReadOnlySpan<char> propertyName)
		{
			JsonWriterHelper.ValidateProperty(propertyName);
			int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num != -1)
			{
				WriteStringEscapeProperty(propertyName, num);
			}
			else
			{
				WriteStringByOptionsPropertyName(propertyName);
			}
			_currentDepth &= int.MaxValue;
			_tokenType = JsonTokenType.PropertyName;
			_commentAfterNoneOrPropertyName = false;
		}

		private void WriteStringEscapeProperty(scoped ReadOnlySpan<char> propertyName, int firstEscapeIndexProp)
		{
			char[] array = null;
			if (firstEscapeIndexProp != -1)
			{
				int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
				Span<char> destination;
				if (maxEscapedLength > 128)
				{
					array = ArrayPool<char>.Shared.Rent(maxEscapedLength);
					destination = array;
				}
				else
				{
					destination = stackalloc char[128];
				}
				JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
				propertyName = destination.Slice(0, written);
			}
			WriteStringByOptionsPropertyName(propertyName);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		private void WriteStringByOptionsPropertyName(ReadOnlySpan<char> propertyName)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteStringIndentedPropertyName(propertyName);
			}
			else
			{
				WriteStringMinimizedPropertyName(propertyName);
			}
		}

		private void WriteStringMinimizedPropertyName(ReadOnlySpan<char> escapedPropertyName)
		{
			int num = escapedPropertyName.Length * 3 + 4;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
		}

		private void WriteStringIndentedPropertyName(ReadOnlySpan<char> escapedPropertyName)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length * 3 + 5 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
		}

		public void WritePropertyName(ReadOnlySpan<byte> utf8PropertyName)
		{
			JsonWriterHelper.ValidateProperty(utf8PropertyName);
			int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num != -1)
			{
				WriteStringEscapeProperty(utf8PropertyName, num);
			}
			else
			{
				WriteStringByOptionsPropertyName(utf8PropertyName);
			}
			_currentDepth &= int.MaxValue;
			_tokenType = JsonTokenType.PropertyName;
			_commentAfterNoneOrPropertyName = false;
		}

		private void WritePropertyNameUnescaped(ReadOnlySpan<byte> utf8PropertyName)
		{
			JsonWriterHelper.ValidateProperty(utf8PropertyName);
			WriteStringByOptionsPropertyName(utf8PropertyName);
			_currentDepth &= int.MaxValue;
			_tokenType = JsonTokenType.PropertyName;
			_commentAfterNoneOrPropertyName = false;
		}

		private void WriteStringEscapeProperty(scoped ReadOnlySpan<byte> utf8PropertyName, int firstEscapeIndexProp)
		{
			byte[] array = null;
			if (firstEscapeIndexProp != -1)
			{
				int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
				Span<byte> destination;
				if (maxEscapedLength > 256)
				{
					array = ArrayPool<byte>.Shared.Rent(maxEscapedLength);
					destination = array;
				}
				else
				{
					destination = stackalloc byte[256];
				}
				JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
				utf8PropertyName = destination.Slice(0, written);
			}
			WriteStringByOptionsPropertyName(utf8PropertyName);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		private void WriteStringByOptionsPropertyName(ReadOnlySpan<byte> utf8PropertyName)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteStringIndentedPropertyName(utf8PropertyName);
			}
			else
			{
				WriteStringMinimizedPropertyName(utf8PropertyName);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void WriteStringMinimizedPropertyName(ReadOnlySpan<byte> escapedPropertyName)
		{
			int num = escapedPropertyName.Length + 3;
			int num2 = num + 1;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void WriteStringPropertyNameSection(ReadOnlySpan<byte> escapedPropertyNameSection)
		{
			int num = escapedPropertyNameSection.Length + 1;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			escapedPropertyNameSection.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyNameSection.Length;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void WriteStringIndentedPropertyName(ReadOnlySpan<byte> escapedPropertyName)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length + 4;
			int num2 = num + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
		}

		public void WriteString(JsonEncodedText propertyName, JsonEncodedText value)
		{
			WriteStringHelper(propertyName.EncodedUtf8Bytes, value.EncodedUtf8Bytes);
		}

		private void WriteStringHelper(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> utf8Value)
		{
			WriteStringByOptions(utf8PropertyName, utf8Value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteString(string propertyName, JsonEncodedText value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteString(MemoryExtensions.AsSpan(propertyName), value);
		}

		public void WriteString(string propertyName, string? value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			if (value == null)
			{
				WriteNull(MemoryExtensions.AsSpan(propertyName));
			}
			else
			{
				WriteString(MemoryExtensions.AsSpan(propertyName), MemoryExtensions.AsSpan(value));
			}
		}

		public void WriteString(ReadOnlySpan<char> propertyName, ReadOnlySpan<char> value)
		{
			JsonWriterHelper.ValidatePropertyAndValue(propertyName, value);
			WriteStringEscape(propertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteString(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> utf8Value)
		{
			JsonWriterHelper.ValidatePropertyAndValue(utf8PropertyName, utf8Value);
			WriteStringEscape(utf8PropertyName, utf8Value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteString(JsonEncodedText propertyName, string? value)
		{
			if (value == null)
			{
				WriteNull(propertyName);
			}
			else
			{
				WriteString(propertyName, MemoryExtensions.AsSpan(value));
			}
		}

		public void WriteString(JsonEncodedText propertyName, ReadOnlySpan<char> value)
		{
			WriteStringHelperEscapeValue(propertyName.EncodedUtf8Bytes, value);
		}

		private void WriteStringHelperEscapeValue(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<char> value)
		{
			JsonWriterHelper.ValidateValue(value);
			int num = JsonWriterHelper.NeedsEscaping(value, _options.Encoder);
			if (num != -1)
			{
				WriteStringEscapeValueOnly(utf8PropertyName, value, num);
			}
			else
			{
				WriteStringByOptions(utf8PropertyName, value);
			}
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteString(string propertyName, ReadOnlySpan<char> value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteString(MemoryExtensions.AsSpan(propertyName), value);
		}

		public void WriteString(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<char> value)
		{
			JsonWriterHelper.ValidatePropertyAndValue(utf8PropertyName, value);
			WriteStringEscape(utf8PropertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteString(JsonEncodedText propertyName, ReadOnlySpan<byte> utf8Value)
		{
			WriteStringHelperEscapeValue(propertyName.EncodedUtf8Bytes, utf8Value);
		}

		private void WriteStringHelperEscapeValue(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> utf8Value)
		{
			JsonWriterHelper.ValidateValue(utf8Value);
			int num = JsonWriterHelper.NeedsEscaping(utf8Value, _options.Encoder);
			if (num != -1)
			{
				WriteStringEscapeValueOnly(utf8PropertyName, utf8Value, num);
			}
			else
			{
				WriteStringByOptions(utf8PropertyName, utf8Value);
			}
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteString(string propertyName, ReadOnlySpan<byte> utf8Value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteString(MemoryExtensions.AsSpan(propertyName), utf8Value);
		}

		public void WriteString(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> utf8Value)
		{
			JsonWriterHelper.ValidatePropertyAndValue(propertyName, utf8Value);
			WriteStringEscape(propertyName, utf8Value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteString(ReadOnlySpan<char> propertyName, JsonEncodedText value)
		{
			WriteStringHelperEscapeProperty(propertyName, value.EncodedUtf8Bytes);
		}

		private void WriteStringHelperEscapeProperty(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> utf8Value)
		{
			JsonWriterHelper.ValidateProperty(propertyName);
			int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num != -1)
			{
				WriteStringEscapePropertyOnly(propertyName, utf8Value, num);
			}
			else
			{
				WriteStringByOptions(propertyName, utf8Value);
			}
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteString(ReadOnlySpan<char> propertyName, string? value)
		{
			if (value == null)
			{
				WriteNull(propertyName);
			}
			else
			{
				WriteString(propertyName, MemoryExtensions.AsSpan(value));
			}
		}

		public void WriteString(ReadOnlySpan<byte> utf8PropertyName, JsonEncodedText value)
		{
			WriteStringHelperEscapeProperty(utf8PropertyName, value.EncodedUtf8Bytes);
		}

		private void WriteStringHelperEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> utf8Value)
		{
			JsonWriterHelper.ValidateProperty(utf8PropertyName);
			int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num != -1)
			{
				WriteStringEscapePropertyOnly(utf8PropertyName, utf8Value, num);
			}
			else
			{
				WriteStringByOptions(utf8PropertyName, utf8Value);
			}
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteString(ReadOnlySpan<byte> utf8PropertyName, string? value)
		{
			if (value == null)
			{
				WriteNull(utf8PropertyName);
			}
			else
			{
				WriteString(utf8PropertyName, MemoryExtensions.AsSpan(value));
			}
		}

		private void WriteStringEscapeValueOnly(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<byte> utf8Value, int firstEscapeIndex)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8Value.Length, firstEscapeIndex);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8Value, destination, firstEscapeIndex, _options.Encoder, out var written);
			WriteStringByOptions(escapedPropertyName, destination.Slice(0, written));
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		private void WriteStringEscapeValueOnly(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<char> value, int firstEscapeIndex)
		{
			char[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(value.Length, firstEscapeIndex);
			Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
			Span<char> destination = span;
			JsonWriterHelper.EscapeString(value, destination, firstEscapeIndex, _options.Encoder, out var written);
			WriteStringByOptions(escapedPropertyName, destination.Slice(0, written));
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		private void WriteStringEscapePropertyOnly(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> escapedValue, int firstEscapeIndex)
		{
			char[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndex);
			Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
			Span<char> destination = span;
			JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndex, _options.Encoder, out var written);
			WriteStringByOptions(destination.Slice(0, written), escapedValue);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		private void WriteStringEscapePropertyOnly(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> escapedValue, int firstEscapeIndex)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndex);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndex, _options.Encoder, out var written);
			WriteStringByOptions(destination.Slice(0, written), escapedValue);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		private void WriteStringEscape(ReadOnlySpan<char> propertyName, ReadOnlySpan<char> value)
		{
			int num = JsonWriterHelper.NeedsEscaping(value, _options.Encoder);
			int num2 = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num + num2 != -2)
			{
				WriteStringEscapePropertyOrValue(propertyName, value, num2, num);
			}
			else
			{
				WriteStringByOptions(propertyName, value);
			}
		}

		private void WriteStringEscape(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> utf8Value)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8Value, _options.Encoder);
			int num2 = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num + num2 != -2)
			{
				WriteStringEscapePropertyOrValue(utf8PropertyName, utf8Value, num2, num);
			}
			else
			{
				WriteStringByOptions(utf8PropertyName, utf8Value);
			}
		}

		private void WriteStringEscape(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> utf8Value)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8Value, _options.Encoder);
			int num2 = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num + num2 != -2)
			{
				WriteStringEscapePropertyOrValue(propertyName, utf8Value, num2, num);
			}
			else
			{
				WriteStringByOptions(propertyName, utf8Value);
			}
		}

		private void WriteStringEscape(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<char> value)
		{
			int num = JsonWriterHelper.NeedsEscaping(value, _options.Encoder);
			int num2 = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num + num2 != -2)
			{
				WriteStringEscapePropertyOrValue(utf8PropertyName, value, num2, num);
			}
			else
			{
				WriteStringByOptions(utf8PropertyName, value);
			}
		}

		private void WriteStringEscapePropertyOrValue(scoped ReadOnlySpan<char> propertyName, scoped ReadOnlySpan<char> value, int firstEscapeIndexProp, int firstEscapeIndexVal)
		{
			char[] array = null;
			char[] array2 = null;
			if (firstEscapeIndexVal != -1)
			{
				int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(value.Length, firstEscapeIndexVal);
				Span<char> destination;
				if (maxEscapedLength > 128)
				{
					array = ArrayPool<char>.Shared.Rent(maxEscapedLength);
					destination = array;
				}
				else
				{
					destination = stackalloc char[128];
				}
				JsonWriterHelper.EscapeString(value, destination, firstEscapeIndexVal, _options.Encoder, out var written);
				value = destination.Slice(0, written);
			}
			if (firstEscapeIndexProp != -1)
			{
				int maxEscapedLength2 = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
				Span<char> destination2;
				if (maxEscapedLength2 > 128)
				{
					array2 = ArrayPool<char>.Shared.Rent(maxEscapedLength2);
					destination2 = array2;
				}
				else
				{
					destination2 = stackalloc char[128];
				}
				JsonWriterHelper.EscapeString(propertyName, destination2, firstEscapeIndexProp, _options.Encoder, out var written2);
				propertyName = destination2.Slice(0, written2);
			}
			WriteStringByOptions(propertyName, value);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
			if (array2 != null)
			{
				ArrayPool<char>.Shared.Return(array2);
			}
		}

		private void WriteStringEscapePropertyOrValue(scoped ReadOnlySpan<byte> utf8PropertyName, scoped ReadOnlySpan<byte> utf8Value, int firstEscapeIndexProp, int firstEscapeIndexVal)
		{
			byte[] array = null;
			byte[] array2 = null;
			if (firstEscapeIndexVal != -1)
			{
				int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8Value.Length, firstEscapeIndexVal);
				Span<byte> destination;
				if (maxEscapedLength > 256)
				{
					array = ArrayPool<byte>.Shared.Rent(maxEscapedLength);
					destination = array;
				}
				else
				{
					destination = stackalloc byte[256];
				}
				JsonWriterHelper.EscapeString(utf8Value, destination, firstEscapeIndexVal, _options.Encoder, out var written);
				utf8Value = destination.Slice(0, written);
			}
			if (firstEscapeIndexProp != -1)
			{
				int maxEscapedLength2 = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
				Span<byte> destination2;
				if (maxEscapedLength2 > 256)
				{
					array2 = ArrayPool<byte>.Shared.Rent(maxEscapedLength2);
					destination2 = array2;
				}
				else
				{
					destination2 = stackalloc byte[256];
				}
				JsonWriterHelper.EscapeString(utf8PropertyName, destination2, firstEscapeIndexProp, _options.Encoder, out var written2);
				utf8PropertyName = destination2.Slice(0, written2);
			}
			WriteStringByOptions(utf8PropertyName, utf8Value);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
			if (array2 != null)
			{
				ArrayPool<byte>.Shared.Return(array2);
			}
		}

		private void WriteStringEscapePropertyOrValue(scoped ReadOnlySpan<char> propertyName, scoped ReadOnlySpan<byte> utf8Value, int firstEscapeIndexProp, int firstEscapeIndexVal)
		{
			byte[] array = null;
			char[] array2 = null;
			if (firstEscapeIndexVal != -1)
			{
				int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8Value.Length, firstEscapeIndexVal);
				Span<byte> destination;
				if (maxEscapedLength > 256)
				{
					array = ArrayPool<byte>.Shared.Rent(maxEscapedLength);
					destination = array;
				}
				else
				{
					destination = stackalloc byte[256];
				}
				JsonWriterHelper.EscapeString(utf8Value, destination, firstEscapeIndexVal, _options.Encoder, out var written);
				utf8Value = destination.Slice(0, written);
			}
			if (firstEscapeIndexProp != -1)
			{
				int maxEscapedLength2 = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
				Span<char> destination2;
				if (maxEscapedLength2 > 128)
				{
					array2 = ArrayPool<char>.Shared.Rent(maxEscapedLength2);
					destination2 = array2;
				}
				else
				{
					destination2 = stackalloc char[128];
				}
				JsonWriterHelper.EscapeString(propertyName, destination2, firstEscapeIndexProp, _options.Encoder, out var written2);
				propertyName = destination2.Slice(0, written2);
			}
			WriteStringByOptions(propertyName, utf8Value);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
			if (array2 != null)
			{
				ArrayPool<char>.Shared.Return(array2);
			}
		}

		private void WriteStringEscapePropertyOrValue(scoped ReadOnlySpan<byte> utf8PropertyName, scoped ReadOnlySpan<char> value, int firstEscapeIndexProp, int firstEscapeIndexVal)
		{
			char[] array = null;
			byte[] array2 = null;
			if (firstEscapeIndexVal != -1)
			{
				int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(value.Length, firstEscapeIndexVal);
				Span<char> destination;
				if (maxEscapedLength > 128)
				{
					array = ArrayPool<char>.Shared.Rent(maxEscapedLength);
					destination = array;
				}
				else
				{
					destination = stackalloc char[128];
				}
				JsonWriterHelper.EscapeString(value, destination, firstEscapeIndexVal, _options.Encoder, out var written);
				value = destination.Slice(0, written);
			}
			if (firstEscapeIndexProp != -1)
			{
				int maxEscapedLength2 = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
				Span<byte> destination2;
				if (maxEscapedLength2 > 256)
				{
					array2 = ArrayPool<byte>.Shared.Rent(maxEscapedLength2);
					destination2 = array2;
				}
				else
				{
					destination2 = stackalloc byte[256];
				}
				JsonWriterHelper.EscapeString(utf8PropertyName, destination2, firstEscapeIndexProp, _options.Encoder, out var written2);
				utf8PropertyName = destination2.Slice(0, written2);
			}
			WriteStringByOptions(utf8PropertyName, value);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
			if (array2 != null)
			{
				ArrayPool<byte>.Shared.Return(array2);
			}
		}

		private void WriteStringByOptions(ReadOnlySpan<char> propertyName, ReadOnlySpan<char> value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteStringIndented(propertyName, value);
			}
			else
			{
				WriteStringMinimized(propertyName, value);
			}
		}

		private void WriteStringByOptions(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> utf8Value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteStringIndented(utf8PropertyName, utf8Value);
			}
			else
			{
				WriteStringMinimized(utf8PropertyName, utf8Value);
			}
		}

		private void WriteStringByOptions(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> utf8Value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteStringIndented(propertyName, utf8Value);
			}
			else
			{
				WriteStringMinimized(propertyName, utf8Value);
			}
		}

		private void WriteStringByOptions(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<char> value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteStringIndented(utf8PropertyName, value);
			}
			else
			{
				WriteStringMinimized(utf8PropertyName, value);
			}
		}

		private void WriteStringMinimized(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<char> escapedValue)
		{
			int num = (escapedPropertyName.Length + escapedValue.Length) * 3 + 6;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedValue, span);
			span[BytesPending++] = 34;
		}

		private void WriteStringMinimized(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<byte> escapedValue)
		{
			int num = escapedPropertyName.Length + escapedValue.Length + 5;
			int num2 = num + 1;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 34;
			escapedValue.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedValue.Length;
			span[BytesPending++] = 34;
		}

		private void WriteStringMinimized(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<byte> escapedValue)
		{
			int num = escapedPropertyName.Length * 3 + escapedValue.Length + 6;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 34;
			escapedValue.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedValue.Length;
			span[BytesPending++] = 34;
		}

		private void WriteStringMinimized(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<char> escapedValue)
		{
			int num = escapedValue.Length * 3 + escapedPropertyName.Length + 6;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedValue, span);
			span[BytesPending++] = 34;
		}

		private void WriteStringIndented(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<char> escapedValue)
		{
			int indentation = Indentation;
			int num = indentation + (escapedPropertyName.Length + escapedValue.Length) * 3 + 7 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedValue, span);
			span[BytesPending++] = 34;
		}

		private void WriteStringIndented(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<byte> escapedValue)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length + escapedValue.Length + 6;
			int num2 = num + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			span[BytesPending++] = 34;
			escapedValue.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedValue.Length;
			span[BytesPending++] = 34;
		}

		private void WriteStringIndented(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<byte> escapedValue)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length * 3 + escapedValue.Length + 7 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			span[BytesPending++] = 34;
			escapedValue.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedValue.Length;
			span[BytesPending++] = 34;
		}

		private void WriteStringIndented(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<char> escapedValue)
		{
			int indentation = Indentation;
			int num = indentation + escapedValue.Length * 3 + escapedPropertyName.Length + 7 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedValue, span);
			span[BytesPending++] = 34;
		}

		[CLSCompliant(false)]
		public void WriteNumber(JsonEncodedText propertyName, ulong value)
		{
			ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
			WriteNumberByOptions(encodedUtf8Bytes, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		[CLSCompliant(false)]
		public void WriteNumber(string propertyName, ulong value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteNumber(MemoryExtensions.AsSpan(propertyName), value);
		}

		[CLSCompliant(false)]
		public void WriteNumber(ReadOnlySpan<char> propertyName, ulong value)
		{
			JsonWriterHelper.ValidateProperty(propertyName);
			WriteNumberEscape(propertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		[CLSCompliant(false)]
		public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, ulong value)
		{
			JsonWriterHelper.ValidateProperty(utf8PropertyName);
			WriteNumberEscape(utf8PropertyName, value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		[CLSCompliant(false)]
		public void WriteNumber(JsonEncodedText propertyName, uint value)
		{
			WriteNumber(propertyName, (ulong)value);
		}

		[CLSCompliant(false)]
		public void WriteNumber(string propertyName, uint value)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			WriteNumber(MemoryExtensions.AsSpan(propertyName), (ulong)value);
		}

		[CLSCompliant(false)]
		public void WriteNumber(ReadOnlySpan<char> propertyName, uint value)
		{
			WriteNumber(propertyName, (ulong)value);
		}

		[CLSCompliant(false)]
		public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, uint value)
		{
			WriteNumber(utf8PropertyName, (ulong)value);
		}

		private void WriteNumberEscape(ReadOnlySpan<char> propertyName, ulong value)
		{
			int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
			if (num != -1)
			{
				WriteNumberEscapeProperty(propertyName, value, num);
			}
			else
			{
				WriteNumberByOptions(propertyName, value);
			}
		}

		private void WriteNumberEscape(ReadOnlySpan<byte> utf8PropertyName, ulong value)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
			if (num != -1)
			{
				WriteNumberEscapeProperty(utf8PropertyName, value, num);
			}
			else
			{
				WriteNumberByOptions(utf8PropertyName, value);
			}
		}

		private void WriteNumberEscapeProperty(ReadOnlySpan<char> propertyName, ulong value, int firstEscapeIndexProp)
		{
			char[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
			Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
			Span<char> destination = span;
			JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteNumberByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		private void WriteNumberEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, ulong value, int firstEscapeIndexProp)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
			WriteNumberByOptions(destination.Slice(0, written), value);
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		private void WriteNumberByOptions(ReadOnlySpan<char> propertyName, ulong value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteNumberIndented(propertyName, value);
			}
			else
			{
				WriteNumberMinimized(propertyName, value);
			}
		}

		private void WriteNumberByOptions(ReadOnlySpan<byte> utf8PropertyName, ulong value)
		{
			ValidateWritingProperty();
			if (_options.Indented)
			{
				WriteNumberIndented(utf8PropertyName, value);
			}
			else
			{
				WriteNumberMinimized(utf8PropertyName, value);
			}
		}

		private void WriteNumberMinimized(ReadOnlySpan<char> escapedPropertyName, ulong value)
		{
			int num = escapedPropertyName.Length * 3 + 20 + 4;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberMinimized(ReadOnlySpan<byte> escapedPropertyName, ulong value)
		{
			int num = escapedPropertyName.Length + 20 + 3;
			int num2 = num + 1;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberIndented(ReadOnlySpan<char> escapedPropertyName, ulong value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length * 3 + 20 + 5 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedPropertyName, span);
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberIndented(ReadOnlySpan<byte> escapedPropertyName, ulong value)
		{
			int indentation = Indentation;
			int num = indentation + escapedPropertyName.Length + 20 + 4;
			int num2 = num + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.None)
			{
				WriteNewLine(span);
			}
			JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
			BytesPending += indentation;
			span[BytesPending++] = 34;
			escapedPropertyName.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedPropertyName.Length;
			span[BytesPending++] = 34;
			span[BytesPending++] = 58;
			span[BytesPending++] = 32;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		internal void WritePropertyName(uint value)
		{
			WritePropertyName((ulong)value);
		}

		internal void WritePropertyName(ulong value)
		{
			Span<byte> destination = stackalloc byte[20];
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
			WritePropertyNameUnescaped(destination.Slice(0, bytesWritten));
		}

		public void WriteBase64StringValue(ReadOnlySpan<byte> bytes)
		{
			WriteBase64ByOptions(bytes);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		private void WriteBase64ByOptions(ReadOnlySpan<byte> bytes)
		{
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			if (_options.Indented)
			{
				WriteBase64Indented(bytes);
			}
			else
			{
				WriteBase64Minimized(bytes);
			}
		}

		private void WriteBase64Minimized(ReadOnlySpan<byte> bytes)
		{
			if (bytes.Length > 1610612733)
			{
				ThrowHelper.ThrowArgumentException_ValueTooLarge(bytes.Length);
			}
			int maxEncodedToUtf8Length = Base64.GetMaxEncodedToUtf8Length(bytes.Length);
			int num = maxEncodedToUtf8Length + 3;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			Base64EncodeAndWrite(bytes, span, maxEncodedToUtf8Length);
			span[BytesPending++] = 34;
		}

		private void WriteBase64Indented(ReadOnlySpan<byte> bytes)
		{
			int indentation = Indentation;
			int num = indentation + 3 + s_newLineLength;
			int num2 = 1610612733 - num;
			if (bytes.Length > num2)
			{
				ThrowHelper.ThrowArgumentException_ValueTooLarge(bytes.Length);
			}
			int maxEncodedToUtf8Length = Base64.GetMaxEncodedToUtf8Length(bytes.Length);
			int num3 = maxEncodedToUtf8Length + num;
			if (_memory.Length - BytesPending < num3)
			{
				Grow(num3);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.PropertyName)
			{
				if (_tokenType != JsonTokenType.None)
				{
					WriteNewLine(span);
				}
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			span[BytesPending++] = 34;
			Base64EncodeAndWrite(bytes, span, maxEncodedToUtf8Length);
			span[BytesPending++] = 34;
		}

		public void WriteCommentValue(string value)
		{
			if (value == null)
			{
				ThrowHelper.ThrowArgumentNullException("value");
			}
			WriteCommentValue(MemoryExtensions.AsSpan(value));
		}

		public void WriteCommentValue(ReadOnlySpan<char> value)
		{
			JsonWriterHelper.ValidateValue(value);
			if (value.IndexOf(s_singleLineCommentDelimiter) != -1)
			{
				ThrowHelper.ThrowArgumentException_InvalidCommentValue();
			}
			WriteCommentByOptions(value);
			JsonTokenType tokenType = _tokenType;
			if ((tokenType == JsonTokenType.None || tokenType == JsonTokenType.PropertyName) ? true : false)
			{
				_commentAfterNoneOrPropertyName = true;
			}
		}

		private void WriteCommentByOptions(ReadOnlySpan<char> value)
		{
			if (_options.Indented)
			{
				WriteCommentIndented(value);
			}
			else
			{
				WriteCommentMinimized(value);
			}
		}

		private void WriteCommentMinimized(ReadOnlySpan<char> value)
		{
			int num = value.Length * 3 + 4;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			span[BytesPending++] = 47;
			span[BytesPending++] = 42;
			int written;
			OperationStatus operationStatus = JsonWriterHelper.ToUtf8(value, span.Slice(BytesPending), out written);
			if (operationStatus == OperationStatus.InvalidData)
			{
				ThrowHelper.ThrowArgumentException_InvalidUTF16(value[written]);
			}
			BytesPending += written;
			span[BytesPending++] = 42;
			span[BytesPending++] = 47;
		}

		private void WriteCommentIndented(ReadOnlySpan<char> value)
		{
			int indentation = Indentation;
			int num = indentation + value.Length * 3 + 4 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_tokenType != JsonTokenType.None || _commentAfterNoneOrPropertyName)
			{
				WriteNewLine(span);
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			span[BytesPending++] = 47;
			span[BytesPending++] = 42;
			int written;
			OperationStatus operationStatus = JsonWriterHelper.ToUtf8(value, span.Slice(BytesPending), out written);
			if (operationStatus == OperationStatus.InvalidData)
			{
				ThrowHelper.ThrowArgumentException_InvalidUTF16(value[written]);
			}
			BytesPending += written;
			span[BytesPending++] = 42;
			span[BytesPending++] = 47;
		}

		public void WriteCommentValue(ReadOnlySpan<byte> utf8Value)
		{
			JsonWriterHelper.ValidateValue(utf8Value);
			if (utf8Value.IndexOf(SingleLineCommentDelimiterUtf8) != -1)
			{
				ThrowHelper.ThrowArgumentException_InvalidCommentValue();
			}
			if (!JsonWriterHelper.IsValidUtf8String(utf8Value))
			{
				ThrowHelper.ThrowArgumentException_InvalidUTF8(utf8Value);
			}
			WriteCommentByOptions(utf8Value);
			JsonTokenType tokenType = _tokenType;
			if ((tokenType == JsonTokenType.None || tokenType == JsonTokenType.PropertyName) ? true : false)
			{
				_commentAfterNoneOrPropertyName = true;
			}
		}

		private void WriteCommentByOptions(ReadOnlySpan<byte> utf8Value)
		{
			if (_options.Indented)
			{
				WriteCommentIndented(utf8Value);
			}
			else
			{
				WriteCommentMinimized(utf8Value);
			}
		}

		private void WriteCommentMinimized(ReadOnlySpan<byte> utf8Value)
		{
			int num = utf8Value.Length + 4;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			span[BytesPending++] = 47;
			span[BytesPending++] = 42;
			utf8Value.CopyTo(span.Slice(BytesPending));
			BytesPending += utf8Value.Length;
			span[BytesPending++] = 42;
			span[BytesPending++] = 47;
		}

		private void WriteCommentIndented(ReadOnlySpan<byte> utf8Value)
		{
			int indentation = Indentation;
			int num = indentation + utf8Value.Length + 4;
			int num2 = num + s_newLineLength;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_tokenType != JsonTokenType.None || _commentAfterNoneOrPropertyName)
			{
				WriteNewLine(span);
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			span[BytesPending++] = 47;
			span[BytesPending++] = 42;
			utf8Value.CopyTo(span.Slice(BytesPending));
			BytesPending += utf8Value.Length;
			span[BytesPending++] = 42;
			span[BytesPending++] = 47;
		}

		public void WriteStringValue(DateTime value)
		{
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			if (_options.Indented)
			{
				WriteStringValueIndented(value);
			}
			else
			{
				WriteStringValueMinimized(value);
			}
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		private void WriteStringValueMinimized(DateTime value)
		{
			int num = 36;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			JsonWriterHelper.WriteDateTimeTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		private void WriteStringValueIndented(DateTime value)
		{
			int indentation = Indentation;
			int num = indentation + 33 + 3 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.PropertyName)
			{
				if (_tokenType != JsonTokenType.None)
				{
					WriteNewLine(span);
				}
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			span[BytesPending++] = 34;
			JsonWriterHelper.WriteDateTimeTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		public void WriteStringValue(DateTimeOffset value)
		{
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			if (_options.Indented)
			{
				WriteStringValueIndented(value);
			}
			else
			{
				WriteStringValueMinimized(value);
			}
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		private void WriteStringValueMinimized(DateTimeOffset value)
		{
			int num = 36;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			JsonWriterHelper.WriteDateTimeOffsetTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		private void WriteStringValueIndented(DateTimeOffset value)
		{
			int indentation = Indentation;
			int num = indentation + 33 + 3 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.PropertyName)
			{
				if (_tokenType != JsonTokenType.None)
				{
					WriteNewLine(span);
				}
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			span[BytesPending++] = 34;
			JsonWriterHelper.WriteDateTimeOffsetTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		public void WriteNumberValue(decimal value)
		{
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			if (_options.Indented)
			{
				WriteNumberValueIndented(value);
			}
			else
			{
				WriteNumberValueMinimized(value);
			}
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		private void WriteNumberValueMinimized(decimal value)
		{
			int num = 32;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberValueIndented(decimal value)
		{
			int indentation = Indentation;
			int num = indentation + 31 + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.PropertyName)
			{
				if (_tokenType != JsonTokenType.None)
				{
					WriteNewLine(span);
				}
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		internal void WriteNumberValueAsString(decimal value)
		{
			Span<byte> destination = stackalloc byte[31];
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
			WriteNumberValueAsStringUnescaped(destination.Slice(0, bytesWritten));
		}

		public void WriteNumberValue(double value)
		{
			JsonWriterHelper.ValidateDouble(value);
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			if (_options.Indented)
			{
				WriteNumberValueIndented(value);
			}
			else
			{
				WriteNumberValueMinimized(value);
			}
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		private void WriteNumberValueMinimized(double value)
		{
			int num = 129;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			int bytesWritten;
			bool flag = TryFormatDouble(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberValueIndented(double value)
		{
			int indentation = Indentation;
			int num = indentation + 128 + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.PropertyName)
			{
				if (_tokenType != JsonTokenType.None)
				{
					WriteNewLine(span);
				}
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			int bytesWritten;
			bool flag = TryFormatDouble(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private static bool TryFormatDouble(double value, Span<byte> destination, out int bytesWritten)
		{
			string text = value.ToString("G17", CultureInfo.InvariantCulture);
			if (text.Length > destination.Length)
			{
				bytesWritten = 0;
				return false;
			}
			try
			{
				byte[] bytes = Encoding.UTF8.GetBytes(text);
				if (bytes.Length > destination.Length)
				{
					bytesWritten = 0;
					return false;
				}
				bytes.CopyTo(destination);
				bytesWritten = bytes.Length;
				return true;
			}
			catch
			{
				bytesWritten = 0;
				return false;
			}
		}

		internal void WriteNumberValueAsString(double value)
		{
			Span<byte> destination = stackalloc byte[128];
			int bytesWritten;
			bool flag = TryFormatDouble(value, destination, out bytesWritten);
			WriteNumberValueAsStringUnescaped(destination.Slice(0, bytesWritten));
		}

		internal void WriteFloatingPointConstant(double value)
		{
			if (double.IsNaN(value))
			{
				WriteNumberValueAsStringUnescaped(JsonConstants.NaNValue);
			}
			else if (double.IsPositiveInfinity(value))
			{
				WriteNumberValueAsStringUnescaped(JsonConstants.PositiveInfinityValue);
			}
			else if (double.IsNegativeInfinity(value))
			{
				WriteNumberValueAsStringUnescaped(JsonConstants.NegativeInfinityValue);
			}
			else
			{
				WriteNumberValue(value);
			}
		}

		public void WriteNumberValue(float value)
		{
			JsonWriterHelper.ValidateSingle(value);
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			if (_options.Indented)
			{
				WriteNumberValueIndented(value);
			}
			else
			{
				WriteNumberValueMinimized(value);
			}
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		private void WriteNumberValueMinimized(float value)
		{
			int num = 129;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			int bytesWritten;
			bool flag = TryFormatSingle(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberValueIndented(float value)
		{
			int indentation = Indentation;
			int num = indentation + 128 + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.PropertyName)
			{
				if (_tokenType != JsonTokenType.None)
				{
					WriteNewLine(span);
				}
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			int bytesWritten;
			bool flag = TryFormatSingle(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private static bool TryFormatSingle(float value, Span<byte> destination, out int bytesWritten)
		{
			string text = value.ToString("G9", CultureInfo.InvariantCulture);
			if (text.Length > destination.Length)
			{
				bytesWritten = 0;
				return false;
			}
			try
			{
				byte[] bytes = Encoding.UTF8.GetBytes(text);
				if (bytes.Length > destination.Length)
				{
					bytesWritten = 0;
					return false;
				}
				bytes.CopyTo(destination);
				bytesWritten = bytes.Length;
				return true;
			}
			catch
			{
				bytesWritten = 0;
				return false;
			}
		}

		internal void WriteNumberValueAsString(float value)
		{
			Span<byte> destination = stackalloc byte[128];
			int bytesWritten;
			bool flag = TryFormatSingle(value, destination, out bytesWritten);
			WriteNumberValueAsStringUnescaped(destination.Slice(0, bytesWritten));
		}

		internal void WriteFloatingPointConstant(float value)
		{
			if (float.IsNaN(value))
			{
				WriteNumberValueAsStringUnescaped(JsonConstants.NaNValue);
			}
			else if (float.IsPositiveInfinity(value))
			{
				WriteNumberValueAsStringUnescaped(JsonConstants.PositiveInfinityValue);
			}
			else if (float.IsNegativeInfinity(value))
			{
				WriteNumberValueAsStringUnescaped(JsonConstants.NegativeInfinityValue);
			}
			else
			{
				WriteNumberValue(value);
			}
		}

		internal void WriteNumberValue(ReadOnlySpan<byte> utf8FormattedNumber)
		{
			JsonWriterHelper.ValidateValue(utf8FormattedNumber);
			JsonWriterHelper.ValidateNumber(utf8FormattedNumber);
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			if (_options.Indented)
			{
				WriteNumberValueIndented(utf8FormattedNumber);
			}
			else
			{
				WriteNumberValueMinimized(utf8FormattedNumber);
			}
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		private void WriteNumberValueMinimized(ReadOnlySpan<byte> utf8Value)
		{
			int num = utf8Value.Length + 1;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			utf8Value.CopyTo(span.Slice(BytesPending));
			BytesPending += utf8Value.Length;
		}

		private void WriteNumberValueIndented(ReadOnlySpan<byte> utf8Value)
		{
			int indentation = Indentation;
			int num = indentation + utf8Value.Length + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.PropertyName)
			{
				if (_tokenType != JsonTokenType.None)
				{
					WriteNewLine(span);
				}
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			utf8Value.CopyTo(span.Slice(BytesPending));
			BytesPending += utf8Value.Length;
		}

		public void WriteStringValue(Guid value)
		{
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			if (_options.Indented)
			{
				WriteStringValueIndented(value);
			}
			else
			{
				WriteStringValueMinimized(value);
			}
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		private void WriteStringValueMinimized(Guid value)
		{
			int num = 39;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		private void WriteStringValueIndented(Guid value)
		{
			int indentation = Indentation;
			int num = indentation + 36 + 3 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.PropertyName)
			{
				if (_tokenType != JsonTokenType.None)
				{
					WriteNewLine(span);
				}
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			span[BytesPending++] = 34;
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
			span[BytesPending++] = 34;
		}

		private void ValidateWritingValue()
		{
			if (_inObject)
			{
				if (_tokenType != JsonTokenType.PropertyName)
				{
					ThrowHelper.ThrowInvalidOperationException(ExceptionResource.CannotWriteValueWithinObject, 0, _options.MaxDepth, 0, _tokenType);
				}
			}
			else if (CurrentDepth == 0 && _tokenType != JsonTokenType.None)
			{
				ThrowHelper.ThrowInvalidOperationException(ExceptionResource.CannotWriteValueAfterPrimitiveOrClose, 0, _options.MaxDepth, 0, _tokenType);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void Base64EncodeAndWrite(ReadOnlySpan<byte> bytes, Span<byte> output, int encodingLength)
		{
			byte[] array = null;
			Span<byte> span = ((encodingLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(encodingLength))) : stackalloc byte[256]);
			Span<byte> utf = span;
			int bytesConsumed;
			int bytesWritten;
			OperationStatus operationStatus = Base64.EncodeToUtf8(bytes, utf, out bytesConsumed, out bytesWritten);
			utf = utf.Slice(0, bytesWritten);
			Span<byte> destination = output.Slice(BytesPending);
			utf.Slice(0, bytesWritten).CopyTo(destination);
			BytesPending += bytesWritten;
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		public void WriteNullValue()
		{
			WriteLiteralByOptions(JsonConstants.NullValue);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Null;
		}

		public void WriteBooleanValue(bool value)
		{
			if (value)
			{
				WriteLiteralByOptions(JsonConstants.TrueValue);
				_tokenType = JsonTokenType.True;
			}
			else
			{
				WriteLiteralByOptions(JsonConstants.FalseValue);
				_tokenType = JsonTokenType.False;
			}
			SetFlagToAddListSeparatorBeforeNextItem();
		}

		private void WriteLiteralByOptions(ReadOnlySpan<byte> utf8Value)
		{
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			if (_options.Indented)
			{
				WriteLiteralIndented(utf8Value);
			}
			else
			{
				WriteLiteralMinimized(utf8Value);
			}
		}

		private void WriteLiteralMinimized(ReadOnlySpan<byte> utf8Value)
		{
			int num = utf8Value.Length + 1;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			utf8Value.CopyTo(span.Slice(BytesPending));
			BytesPending += utf8Value.Length;
		}

		private void WriteLiteralIndented(ReadOnlySpan<byte> utf8Value)
		{
			int indentation = Indentation;
			int num = indentation + utf8Value.Length + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.PropertyName)
			{
				if (_tokenType != JsonTokenType.None)
				{
					WriteNewLine(span);
				}
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			utf8Value.CopyTo(span.Slice(BytesPending));
			BytesPending += utf8Value.Length;
		}

		public void WriteRawValue([StringSyntax("Json")] string json, bool skipInputValidation = false)
		{
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			if (json == null)
			{
				throw new ArgumentNullException("json");
			}
			TranscodeAndWriteRawValue(MemoryExtensions.AsSpan(json), skipInputValidation);
		}

		public void WriteRawValue([StringSyntax("Json")] ReadOnlySpan<char> json, bool skipInputValidation = false)
		{
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			TranscodeAndWriteRawValue(json, skipInputValidation);
		}

		public void WriteRawValue(ReadOnlySpan<byte> utf8Json, bool skipInputValidation = false)
		{
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			if (utf8Json.Length == int.MaxValue)
			{
				ThrowHelper.ThrowArgumentException_ValueTooLarge(2147483647L);
			}
			WriteRawValueCore(utf8Json, skipInputValidation);
		}

		public void WriteRawValue(ReadOnlySequence<byte> utf8Json, bool skipInputValidation = false)
		{
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			long length = utf8Json.Length;
			if (length == 0L)
			{
				ThrowHelper.ThrowArgumentException(System.SR.ExpectedJsonTokens);
			}
			if (length >= int.MaxValue)
			{
				ThrowHelper.ThrowArgumentException_ValueTooLarge(length);
			}
			if (skipInputValidation)
			{
				_tokenType = JsonTokenType.String;
			}
			else
			{
				Utf8JsonReader utf8JsonReader = new Utf8JsonReader(utf8Json);
				while (utf8JsonReader.Read())
				{
				}
				_tokenType = utf8JsonReader.TokenType;
			}
			int num = (int)length;
			int num2 = num + 1;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			utf8Json.CopyTo(span.Slice(BytesPending));
			BytesPending += num;
			SetFlagToAddListSeparatorBeforeNextItem();
		}

		private void TranscodeAndWriteRawValue(ReadOnlySpan<char> json, bool skipInputValidation)
		{
			if (json.Length > 715827882)
			{
				ThrowHelper.ThrowArgumentException_ValueTooLarge(json.Length);
			}
			byte[] array = null;
			Span<byte> span = (((long)json.Length > 349525L) ? new byte[JsonReaderHelper.GetUtf8ByteCount(json)] : (array = ArrayPool<byte>.Shared.Rent(json.Length * 3)));
			try
			{
				span = span[..JsonReaderHelper.GetUtf8FromText(json, span)];
				WriteRawValueCore(span, skipInputValidation);
			}
			finally
			{
				if (array != null)
				{
					span.Clear();
					ArrayPool<byte>.Shared.Return(array);
				}
			}
		}

		private void WriteRawValueCore(ReadOnlySpan<byte> utf8Json, bool skipInputValidation)
		{
			int length = utf8Json.Length;
			if (length == 0)
			{
				ThrowHelper.ThrowArgumentException(System.SR.ExpectedJsonTokens);
			}
			if (skipInputValidation)
			{
				_tokenType = JsonTokenType.String;
			}
			else
			{
				Utf8JsonReader utf8JsonReader = new Utf8JsonReader(utf8Json);
				while (utf8JsonReader.Read())
				{
				}
				_tokenType = utf8JsonReader.TokenType;
			}
			int num = length + 1;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			utf8Json.CopyTo(span.Slice(BytesPending));
			BytesPending += length;
			SetFlagToAddListSeparatorBeforeNextItem();
		}

		public void WriteNumberValue(int value)
		{
			WriteNumberValue((long)value);
		}

		public void WriteNumberValue(long value)
		{
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			if (_options.Indented)
			{
				WriteNumberValueIndented(value);
			}
			else
			{
				WriteNumberValueMinimized(value);
			}
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		private void WriteNumberValueMinimized(long value)
		{
			int num = 21;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberValueIndented(long value)
		{
			int indentation = Indentation;
			int num = indentation + 20 + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.PropertyName)
			{
				if (_tokenType != JsonTokenType.None)
				{
					WriteNewLine(span);
				}
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		internal void WriteNumberValueAsString(long value)
		{
			Span<byte> destination = stackalloc byte[20];
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
			WriteNumberValueAsStringUnescaped(destination.Slice(0, bytesWritten));
		}

		public void WriteStringValue(JsonEncodedText value)
		{
			ReadOnlySpan<byte> encodedUtf8Bytes = value.EncodedUtf8Bytes;
			WriteStringByOptions(encodedUtf8Bytes);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		public void WriteStringValue(string? value)
		{
			if (value == null)
			{
				WriteNullValue();
			}
			else
			{
				WriteStringValue(MemoryExtensions.AsSpan(value));
			}
		}

		public void WriteStringValue(ReadOnlySpan<char> value)
		{
			JsonWriterHelper.ValidateValue(value);
			WriteStringEscape(value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		private void WriteStringEscape(ReadOnlySpan<char> value)
		{
			int num = JsonWriterHelper.NeedsEscaping(value, _options.Encoder);
			if (num != -1)
			{
				WriteStringEscapeValue(value, num);
			}
			else
			{
				WriteStringByOptions(value);
			}
		}

		private void WriteStringByOptions(ReadOnlySpan<char> value)
		{
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			if (_options.Indented)
			{
				WriteStringIndented(value);
			}
			else
			{
				WriteStringMinimized(value);
			}
		}

		private void WriteStringMinimized(ReadOnlySpan<char> escapedValue)
		{
			int num = escapedValue.Length * 3 + 3;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedValue, span);
			span[BytesPending++] = 34;
		}

		private void WriteStringIndented(ReadOnlySpan<char> escapedValue)
		{
			int indentation = Indentation;
			int num = indentation + escapedValue.Length * 3 + 3 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.PropertyName)
			{
				if (_tokenType != JsonTokenType.None)
				{
					WriteNewLine(span);
				}
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			span[BytesPending++] = 34;
			TranscodeAndWrite(escapedValue, span);
			span[BytesPending++] = 34;
		}

		private void WriteStringEscapeValue(ReadOnlySpan<char> value, int firstEscapeIndexVal)
		{
			char[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(value.Length, firstEscapeIndexVal);
			Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
			Span<char> destination = span;
			JsonWriterHelper.EscapeString(value, destination, firstEscapeIndexVal, _options.Encoder, out var written);
			WriteStringByOptions(destination.Slice(0, written));
			if (array != null)
			{
				ArrayPool<char>.Shared.Return(array);
			}
		}

		public void WriteStringValue(ReadOnlySpan<byte> utf8Value)
		{
			JsonWriterHelper.ValidateValue(utf8Value);
			WriteStringEscape(utf8Value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		private void WriteStringEscape(ReadOnlySpan<byte> utf8Value)
		{
			int num = JsonWriterHelper.NeedsEscaping(utf8Value, _options.Encoder);
			if (num != -1)
			{
				WriteStringEscapeValue(utf8Value, num);
			}
			else
			{
				WriteStringByOptions(utf8Value);
			}
		}

		private void WriteStringByOptions(ReadOnlySpan<byte> utf8Value)
		{
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			if (_options.Indented)
			{
				WriteStringIndented(utf8Value);
			}
			else
			{
				WriteStringMinimized(utf8Value);
			}
		}

		private void WriteStringMinimized(ReadOnlySpan<byte> escapedValue)
		{
			int num = escapedValue.Length + 2;
			int num2 = num + 1;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			span[BytesPending++] = 34;
			escapedValue.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedValue.Length;
			span[BytesPending++] = 34;
		}

		private void WriteStringIndented(ReadOnlySpan<byte> escapedValue)
		{
			int indentation = Indentation;
			int num = indentation + escapedValue.Length + 2;
			int num2 = num + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num2)
			{
				Grow(num2);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.PropertyName)
			{
				if (_tokenType != JsonTokenType.None)
				{
					WriteNewLine(span);
				}
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			span[BytesPending++] = 34;
			escapedValue.CopyTo(span.Slice(BytesPending));
			BytesPending += escapedValue.Length;
			span[BytesPending++] = 34;
		}

		private void WriteStringEscapeValue(ReadOnlySpan<byte> utf8Value, int firstEscapeIndexVal)
		{
			byte[] array = null;
			int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8Value.Length, firstEscapeIndexVal);
			Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
			Span<byte> destination = span;
			JsonWriterHelper.EscapeString(utf8Value, destination, firstEscapeIndexVal, _options.Encoder, out var written);
			WriteStringByOptions(destination.Slice(0, written));
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		internal void WriteNumberValueAsStringUnescaped(ReadOnlySpan<byte> utf8Value)
		{
			WriteStringByOptions(utf8Value);
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.String;
		}

		[CLSCompliant(false)]
		public void WriteNumberValue(uint value)
		{
			WriteNumberValue((ulong)value);
		}

		[CLSCompliant(false)]
		public void WriteNumberValue(ulong value)
		{
			if (!_options.SkipValidation)
			{
				ValidateWritingValue();
			}
			if (_options.Indented)
			{
				WriteNumberValueIndented(value);
			}
			else
			{
				WriteNumberValueMinimized(value);
			}
			SetFlagToAddListSeparatorBeforeNextItem();
			_tokenType = JsonTokenType.Number;
		}

		private void WriteNumberValueMinimized(ulong value)
		{
			int num = 21;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		private void WriteNumberValueIndented(ulong value)
		{
			int indentation = Indentation;
			int num = indentation + 20 + 1 + s_newLineLength;
			if (_memory.Length - BytesPending < num)
			{
				Grow(num);
			}
			Span<byte> span = _memory.Span;
			if (_currentDepth < 0)
			{
				span[BytesPending++] = 44;
			}
			if (_tokenType != JsonTokenType.PropertyName)
			{
				if (_tokenType != JsonTokenType.None)
				{
					WriteNewLine(span);
				}
				JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
				BytesPending += indentation;
			}
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
			BytesPending += bytesWritten;
		}

		internal void WriteNumberValueAsString(ulong value)
		{
			Span<byte> destination = stackalloc byte[20];
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
			WriteNumberValueAsStringUnescaped(destination.Slice(0, bytesWritten));
		}
	}
}
namespace System.Text.Json.Nodes
{
	[DebuggerDisplay("JsonArray[{List.Count}]")]
	[DebuggerTypeProxy(typeof(DebugView))]
	public sealed class JsonArray : JsonNode, IList<JsonNode?>, ICollection<JsonNode?>, IEnumerable<JsonNode?>, IEnumerable
	{
		[ExcludeFromCodeCoverage]
		private sealed class DebugView
		{
			[DebuggerDisplay("{Display,nq}")]
			private struct DebugViewItem
			{
				[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
				public JsonNode Value;

				[DebuggerBrowsable(DebuggerBrowsableState.Never)]
				public string Display
				{
					get
					{
						if (Value == null)
						{
							return "null";
						}
						if (Value is JsonValue)
						{
							return Value.ToJsonString();
						}
						if (Value is JsonObject jsonObject)
						{
							return $"JsonObject[{jsonObject.Count}]";
						}
						JsonArray jsonArray = (JsonArray)Value;
						return $"JsonArray[{jsonArray.List.Count}]";
					}
				}
			}

			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private readonly JsonArray _node;

			public string Json => _node.ToJsonString();

			public string Path => _node.GetPath();

			[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
			private DebugViewItem[] Items
			{
				get
				{
					DebugViewItem[] array = new DebugViewItem[_node.List.Count];
					for (int i = 0; i < _node.List.Count; i++)
					{
						array[i].Value = _node.List[i];
					}
					return array;
				}
			}

			public DebugView(JsonArray node)
			{
				_node = node;
			}
		}

		private JsonElement? _jsonElement;

		private List<JsonNode> _list;

		internal List<JsonNode?> List
		{
			get
			{
				List<JsonNode> list = _list;
				if (list == null)
				{
					return InitializeList();
				}
				return list;
			}
		}

		public int Count => List.Count;

		bool ICollection<JsonNode>.IsReadOnly => false;

		public JsonArray(JsonNodeOptions? options = null)
			: base(options)
		{
		}

		public JsonArray(JsonNodeOptions options, params JsonNode?[] items)
			: base(options)
		{
			InitializeFromArray(items);
		}

		public JsonArray(params JsonNode?[] items)
		{
			InitializeFromArray(items);
		}

		internal override JsonValueKind GetValueKindCore()
		{
			return JsonValueKind.Array;
		}

		internal override JsonNode DeepCloneCore()
		{
			GetUnderlyingRepresentation(out var list, out var jsonElement);
			if (list == null)
			{
				if (!jsonElement.HasValue)
				{
					return new JsonArray(base.Options);
				}
				return new JsonArray(jsonElement.Value.Clone(), base.Options);
			}
			JsonArray jsonArray = new JsonArray(base.Options)
			{
				_list = new List<JsonNode>(list.Count)
			};
			for (int i = 0; i < list.Count; i++)
			{
				jsonArray.Add(list[i]?.DeepCloneCore());
			}
			return jsonArray;
		}

		internal override bool DeepEqualsCore(JsonNode node)
		{
			if (node != null && !(node is JsonObject))
			{
				if (!(node is JsonValue jsonValue))
				{
					if (node is JsonArray jsonArray)
					{
						List<JsonNode> list = List;
						List<JsonNode> list2 = jsonArray.List;
						if (list.Count != list2.Count)
						{
							return false;
						}
						for (int i = 0; i < list.Count; i++)
						{
							if (!JsonNode.DeepEquals(list[i], list2[i]))
							{
								return false;
							}
						}
						return true;
					}
					return false;
				}
				return jsonValue.DeepEqualsCore(this);
			}
			return false;
		}

		internal int GetElementIndex(JsonNode node)
		{
			return List.IndexOf(node);
		}

		public IEnumerable<T> GetValues<T>()
		{
			foreach (JsonNode item in List)
			{
				yield return (item == null) ? ((T)(object)null) : item.GetValue<T>();
			}
		}

		private void InitializeFromArray(JsonNode[] items)
		{
			List<JsonNode> list = new List<JsonNode>(items);
			for (int i = 0; i < items.Length; i++)
			{
				items[i]?.AssignParent(this);
			}
			_list = list;
		}

		public static JsonArray? Create(JsonElement element, JsonNodeOptions? options = null)
		{
			return element.ValueKind switch
			{
				JsonValueKind.Null => null, 
				JsonValueKind.Array => new JsonArray(element, options), 
				_ => throw new InvalidOperationException(System.SR.Format(System.SR.NodeElementWrongType, "Array")), 
			};
		}

		internal JsonArray(JsonElement element, JsonNodeOptions? options = null)
			: base(options)
		{
			_jsonElement = element;
		}

		[RequiresUnreferencedCode("Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed.")]
		[RequiresDynamicCode("Creating JsonValue instances with non-primitive types requires generating code at runtime.")]
		public void Add<T>(T? value)
		{
			JsonNode item = JsonNode.ConvertFromValue(value, base.Options);
			Add(item);
		}

		internal JsonNode GetItem(int index)
		{
			return List[index];
		}

		internal void SetItem(int index, JsonNode value)
		{
			value?.AssignParent(this);
			DetachParent(List[index]);
			List[index] = value;
		}

		internal override void GetPath(List<string> path, JsonNode child)
		{
			if (child != null)
			{
				int num = List.IndexOf(child);
				path.Add($"[{num}]");
			}
			base.Parent?.GetPath(path, this);
		}

		public override void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions? options = null)
		{
			if (writer == null)
			{
				ThrowHelper.ThrowArgumentNullException("writer");
			}
			GetUnderlyingRepresentation(out var list, out var jsonElement);
			if (list == null && jsonElement.HasValue)
			{
				jsonElement.Value.WriteTo(writer);
				return;
			}
			writer.WriteStartArray();
			foreach (JsonNode item in List)
			{
				if (item == null)
				{
					writer.WriteNullValue();
				}
				else
				{
					item.WriteTo(writer, options);
				}
			}
			writer.WriteEndArray();
		}

		private List<JsonNode> InitializeList()
		{
			GetUnderlyingRepresentation(out var list, out var jsonElement);
			if (list == null)
			{
				if (jsonElement.HasValue)
				{
					JsonElement value = jsonElement.Value;
					list = new List<JsonNode>(value.GetArrayLength());
					foreach (JsonElement item in value.EnumerateArray())
					{
						JsonNode jsonNode = JsonNodeConverter.Create(item, base.Options);
						jsonNode?.AssignParent(this);
						list.Add(jsonNode);
					}
				}
				else
				{
					list = new List<JsonNode>();
				}
				_list = list;
				Interlocked.MemoryBarrier();
				_jsonElement = null;
			}
			return list;
		}

		private void GetUnderlyingRepresentation(out List<JsonNode> list, out JsonElement? jsonElement)
		{
			jsonElement = _jsonElement;
			Interlocked.MemoryBarrier();
			list = _list;
		}

		public void Add(JsonNode? item)
		{
			item?.AssignParent(this);
			List.Add(item);
		}

		public void Clear()
		{
			List<JsonNode> list = _list;
			if (list == null)
			{
				_jsonElement = null;
				return;
			}
			for (int i = 0; i < list.Count; i++)
			{
				DetachParent(list[i]);
			}
			list.Clear();
		}

		public bool Contains(JsonNode? item)
		{
			return List.Contains(item);
		}

		public int IndexOf(JsonNode? item)
		{
			return List.IndexOf(item);
		}

		public void Insert(int index, JsonNode? item)
		{
			item?.AssignParent(this);
			List.Insert(index, item);
		}

		public bool Remove(JsonNode? item)
		{
			if (List.Remove(item))
			{
				DetachParent(item);
				return true;
			}
			return false;
		}

		public void RemoveAt(int index)
		{
			JsonNode item = List[index];
			List.RemoveAt(index);
			DetachParent(item);
		}

		void ICollection<JsonNode>.CopyTo(JsonNode[] array, int index)
		{
			List.CopyTo(array, index);
		}

		public IEnumerator<JsonNode?> GetEnumerator()
		{
			return List.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable)List).GetEnumerator();
		}

		private static void DetachParent(JsonNode item)
		{
			if (item != null)
			{
				item.Parent = null;
			}
		}
	}
	public abstract class JsonNode
	{
		private JsonNode _parent;

		private JsonNodeOptions? _options;

		public JsonNodeOptions? Options
		{
			get
			{
				if (!_options.HasValue && Parent != null)
				{
					_options = Parent.Options;
				}
				return _options;
			}
		}

		public JsonNode? Parent
		{
			get
			{
				return _parent;
			}
			internal set
			{
				_parent = value;
			}
		}

		public JsonNode Root
		{
			get
			{
				JsonNode parent = Parent;
				if (parent == null)
				{
					return this;
				}
				while (parent.Parent != null)
				{
					parent = parent.Parent;
				}
				return parent;
			}
		}

		public JsonNode? this[int index]
		{
			get
			{
				return AsArray().GetItem(index);
			}
			set
			{
				AsArray().SetItem(index, value);
			}
		}

		public JsonNode? this[string propertyName]
		{
			get
			{
				return AsObject().GetItem(propertyName);
			}
			set
			{
				AsObject().SetItem(propertyName, value);
			}
		}

		internal JsonNode(JsonNodeOptions? options = null)
		{
			_options = options;
		}

		public JsonArray AsArray()
		{
			JsonArray jsonArray = this as JsonArray;
			if (jsonArray == null)
			{
				ThrowHelper.ThrowInvalidOperationException_NodeWrongType("JsonArray");
			}
			return jsonArray;
		}

		public JsonObject AsObject()
		{
			JsonObject jsonObject = this as JsonObject;
			if (jsonObject == null)
			{
				ThrowHelper.ThrowInvalidOperationException_NodeWrongType("JsonObject");
			}
			return jsonObject;
		}

		public JsonValue AsValue()
		{
			JsonValue jsonValue = this as JsonValue;
			if (jsonValue == null)
			{
				ThrowHelper.ThrowInvalidOperationException_NodeWrongType("JsonValue");
			}
			return jsonValue;
		}

		public string GetPath()
		{
			if (Parent == null)
			{
				return "$";
			}
			List<string> list = new List<string>();
			GetPath(list, null);
			StringBuilder stringBuilder = new StringBuilder("$");
			for (int num = list.Count - 1; num >= 0; num--)
			{
				stringBuilder.Append(list[num]);
			}
			return stringBuilder.ToString();
		}

		internal abstract void GetPath(List<string> path, JsonNode child);

		public virtual T GetValue<T>()
		{
			throw new InvalidOperationException(System.SR.Format(System.SR.NodeWrongType, "JsonValue"));
		}

		public JsonNode DeepClone()
		{
			return DeepCloneCore();
		}

		internal abstract JsonNode DeepCloneCore();

		public JsonValueKind GetValueKind()
		{
			return GetValueKindCore();
		}

		internal abstract JsonValueKind GetValueKindCore();

		public string GetPropertyName()
		{
			JsonObject jsonObject = _parent as JsonObject;
			if (jsonObject == null)
			{
				ThrowHelper.ThrowInvalidOperationException_NodeParentWrongType("JsonObject");
			}
			return jsonObject.GetPropertyName(this);
		}

		public int GetElementIndex()
		{
			JsonArray jsonArray = _parent as JsonArray;
			if (jsonArray == null)
			{
				ThrowHelper.ThrowInvalidOperationException_NodeParentWrongType("JsonArray");
			}
			return jsonArray.GetElementIndex(this);
		}

		public static bool DeepEquals(JsonNode? node1, JsonNode? node2)
		{
			return node1?.DeepEqualsCore(node2) ?? (node2 == null);
		}

		internal abstract bool DeepEqualsCore(JsonNode node);

		[RequiresUnreferencedCode("Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed.")]
		[RequiresDynamicCode("Creating JsonValue instances with non-primitive types requires generating code at runtime.")]
		public void ReplaceWith<T>(T value)
		{
			JsonNode parent = _parent;
			if (!(parent is JsonObject jsonObject))
			{
				if (parent is JsonArray jsonArray)
				{
					JsonNode value2 = ConvertFromValue(value);
					jsonArray.SetItem(GetElementIndex(), value2);
				}
			}
			else
			{
				JsonNode value2 = ConvertFromValue(value);
				jsonObject.SetItem(GetPropertyName(), value2);
			}
		}

		internal void AssignParent(JsonNode parent)
		{
			if (Parent != null)
			{
				ThrowHelper.ThrowInvalidOperationException_NodeAlreadyHasParent();
			}
			for (JsonNode jsonNode = parent; jsonNode != null; jsonNode = jsonNode.Parent)
			{
				if (jsonNode == this)
				{
					ThrowHelper.ThrowInvalidOperationException_NodeCycleDetected();
				}
			}
			Parent = parent;
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		internal static JsonNode ConvertFromValue<T>(T value, JsonNodeOptions? options = null)
		{
			if (value == null)
			{
				return null;
			}
			if (value is JsonNode result)
			{
				return result;
			}
			if (value is JsonElement element)
			{
				return JsonNodeConverter.Create(element, options);
			}
			JsonTypeInfo<T> jsonTypeInfo = (JsonTypeInfo<T>)JsonSerializerOptions.Default.GetTypeInfo(typeof(T));
			return new JsonValueCustomized<T>(value, jsonTypeInfo, options);
		}

		public static implicit operator JsonNode(bool value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode?(bool? value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode(byte value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode?(byte? value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode(char value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode?(char? value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode(DateTime value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode?(DateTime? value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode(DateTimeOffset value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode?(DateTimeOffset? value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode(decimal value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode?(decimal? value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode(double value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode?(double? value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode(Guid value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode?(Guid? value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode(short value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode?(short? value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode(int value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode?(int? value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode(long value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode?(long? value)
		{
			return JsonValue.Create(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JsonNode(sbyte value)
		{
			return JsonValue.Create(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JsonNode?(sbyte? value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode(float value)
		{
			return JsonValue.Create(value);
		}

		public static implicit operator JsonNode?(float? value)
		{
			return JsonValue.Create(value);
		}

		[return: NotNullIfNotNull("value")]
		public static implicit operator JsonNode?(string? value)
		{
			return JsonValue.Create(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JsonNode(ushort value)
		{
			return JsonValue.Create(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JsonNode?(ushort? value)
		{
			return JsonValue.Create(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JsonNode(uint value)
		{
			return JsonValue.Create(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JsonNode?(uint? value)
		{
			return JsonValue.Create(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JsonNode(ulong value)
		{
			return JsonValue.Create(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JsonNode?(ulong? value)
		{
			return JsonValue.Create(value);
		}

		public static explicit operator bool(JsonNode value)
		{
			return value.GetValue<bool>();
		}

		public static explicit operator bool?(JsonNode? value)
		{
			return value?.GetValue<bool>();
		}

		public static explicit operator byte(JsonNode value)
		{
			return value.GetValue<byte>();
		}

		public static explicit operator byte?(JsonNode? value)
		{
			return value?.GetValue<byte>();
		}

		public static explicit operator char(JsonNode value)
		{
			return value.GetValue<char>();
		}

		public static explicit operator char?(JsonNode? value)
		{
			return value?.GetValue<char>();
		}

		public static explicit operator DateTime(JsonNode value)
		{
			return value.GetValue<DateTime>();
		}

		public static explicit operator DateTime?(JsonNode? value)
		{
			return value?.GetValue<DateTime>();
		}

		public static explicit operator DateTimeOffset(JsonNode value)
		{
			return value.GetValue<DateTimeOffset>();
		}

		public static explicit operator DateTimeOffset?(JsonNode? value)
		{
			return value?.GetValue<DateTimeOffset>();
		}

		public static explicit operator decimal(JsonNode value)
		{
			return value.GetValue<decimal>();
		}

		public static explicit operator decimal?(JsonNode? value)
		{
			return value?.GetValue<decimal>();
		}

		public static explicit operator double(JsonNode value)
		{
			return value.GetValue<double>();
		}

		public static explicit operator double?(JsonNode? value)
		{
			return value?.GetValue<double>();
		}

		public static explicit operator Guid(JsonNode value)
		{
			return value.GetValue<Guid>();
		}

		public static explicit operator Guid?(JsonNode? value)
		{
			return value?.GetValue<Guid>();
		}

		public static explicit operator short(JsonNode value)
		{
			return value.GetValue<short>();
		}

		public static explicit operator short?(JsonNode? value)
		{
			return value?.GetValue<short>();
		}

		public static explicit operator int(JsonNode value)
		{
			return value.GetValue<int>();
		}

		public static explicit operator int?(JsonNode? value)
		{
			return value?.GetValue<int>();
		}

		public static explicit operator long(JsonNode value)
		{
			return value.GetValue<long>();
		}

		public static explicit operator long?(JsonNode? value)
		{
			return value?.GetValue<long>();
		}

		[CLSCompliant(false)]
		public static explicit operator sbyte(JsonNode value)
		{
			return value.GetValue<sbyte>();
		}

		[CLSCompliant(false)]
		public static explicit operator sbyte?(JsonNode? value)
		{
			return value?.GetValue<sbyte>();
		}

		public static explicit operator float(JsonNode value)
		{
			return value.GetValue<float>();
		}

		public static explicit operator float?(JsonNode? value)
		{
			return value?.GetValue<float>();
		}

		public static explicit operator string?(JsonNode? value)
		{
			return value?.GetValue<string>();
		}

		[CLSCompliant(false)]
		public static explicit operator ushort(JsonNode value)
		{
			return value.GetValue<ushort>();
		}

		[CLSCompliant(false)]
		public static explicit operator ushort?(JsonNode? value)
		{
			return value?.GetValue<ushort>();
		}

		[CLSCompliant(false)]
		public static explicit operator uint(JsonNode value)
		{
			return value.GetValue<uint>();
		}

		[CLSCompliant(false)]
		public static explicit operator uint?(JsonNode? value)
		{
			return value?.GetValue<uint>();
		}

		[CLSCompliant(false)]
		public static explicit operator ulong(JsonNode value)
		{
			return value.GetValue<ulong>();
		}

		[CLSCompliant(false)]
		public static explicit operator ulong?(JsonNode? value)
		{
			return value?.GetValue<ulong>();
		}

		public static JsonNode? Parse(ref Utf8JsonReader reader, JsonNodeOptions? nodeOptions = null)
		{
			JsonElement element = JsonElement.ParseValue(ref reader);
			return JsonNodeConverter.Create(element, nodeOptions);
		}

		public static JsonNode? Parse([StringSyntax("Json")] string json, JsonNodeOptions? nodeOptions = null, JsonDocumentOptions documentOptions = default(JsonDocumentOptions))
		{
			if (json == null)
			{
				ThrowHelper.ThrowArgumentNullException("json");
			}
			JsonElement element = JsonElement.ParseValue(json, documentOptions);
			return JsonNodeConverter.Create(element, nodeOptions);
		}

		public static JsonNode? Parse(ReadOnlySpan<byte> utf8Json, JsonNodeOptions? nodeOptions = null, JsonDocumentOptions documentOptions = default(JsonDocumentOptions))
		{
			JsonElement element = JsonElement.ParseValue(utf8Json, documentOptions);
			return JsonNodeConverter.Create(element, nodeOptions);
		}

		public static JsonNode? Parse(Stream utf8Json, JsonNodeOptions? nodeOptions = null, JsonDocumentOptions documentOptions = default(JsonDocumentOptions))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			JsonElement element = JsonElement.ParseValue(utf8Json, documentOptions);
			return JsonNodeConverter.Create(element, nodeOptions);
		}

		public static async Task<JsonNode?> ParseAsync(Stream utf8Json, JsonNodeOptions? nodeOptions = null, JsonDocumentOptions documentOptions = default(JsonDocumentOptions), CancellationToken cancellationToken = default(CancellationToken))
		{
			if (utf8Json == null)
			{
				ThrowHelper.ThrowArgumentNullException("utf8Json");
			}
			return JsonNodeConverter.Create((await JsonDocument.ParseAsyncCoreUnrented(utf8Json, documentOptions, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).RootElement, nodeOptions);
		}

		public string ToJsonString(JsonSerializerOptions? options = null)
		{
			using PooledByteBufferWriter pooledByteBufferWriter = WriteToPooledBuffer(options, options?.GetWriterOptions() ?? default(JsonWriterOptions));
			return JsonHelpers.Utf8GetString(pooledByteBufferWriter.WrittenMemory.Span);
		}

		public override string ToString()
		{
			if (this is JsonValue)
			{
				if (this is JsonValue<string> jsonValue)
				{
					return jsonValue.Value;
				}
				if (this is JsonValue<JsonElement> jsonValue2 && jsonValue2.Value.ValueKind == JsonValueKind.String)
				{
					return jsonValue2.Value.GetString();
				}
			}
			using PooledByteBufferWriter pooledByteBufferWriter = WriteToPooledBuffer(null, new JsonWriterOptions
			{
				Indented = true
			});
			return JsonHelpers.Utf8GetString(pooledByteBufferWriter.WrittenMemory.Span);
		}

		public abstract void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions? options = null);

		internal PooledByteBufferWriter WriteToPooledBuffer(JsonSerializerOptions options = null, JsonWriterOptions writerOptions = default(JsonWriterOptions), int bufferSize = 16384)
		{
			PooledByteBufferWriter pooledByteBufferWriter = new PooledByteBufferWriter(bufferSize);
			using Utf8JsonWriter writer = new Utf8JsonWriter(pooledByteBufferWriter, writerOptions);
			WriteTo(writer, options);
			return pooledByteBufferWriter;
		}
	}
	public struct JsonNodeOptions
	{
		public bool PropertyNameCaseInsensitive { get; set; }
	}
	[DebuggerDisplay("JsonObject[{Count}]")]
	[DebuggerTypeProxy(typeof(DebugView))]
	public sealed class JsonObject : JsonNode, IDictionary<string, JsonNode?>, ICollection<KeyValuePair<string, JsonNode?>>, IEnumerable<KeyValuePair<string, JsonNode?>>, IEnumerable
	{
		[ExcludeFromCodeCoverage]
		private sealed class DebugView
		{
			[DebuggerDisplay("{Display,nq}")]
			private struct DebugViewProperty
			{
				[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
				public JsonNode Value;

				[DebuggerBrowsable(DebuggerBrowsableState.Never)]
				public string PropertyName;

				[DebuggerBrowsable(DebuggerBrowsableState.Never)]
				public string Display
				{
					get
					{
						if (Value == null)
						{
							return PropertyName + " = null";
						}
						if (Value is JsonValue)
						{
							return PropertyName + " = " + Value.ToJsonString();
						}
						if (Value is JsonObject jsonObject)
						{
							return $"{PropertyName} = JsonObject[{jsonObject.Count}]";
						}
						JsonArray jsonArray = (JsonArray)Value;
						return $"{PropertyName} = JsonArray[{jsonArray.Count}]";
					}
				}
			}

			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private readonly JsonObject _node;

			public string Json => _node.ToJsonString();

			public string Path => _node.GetPath();

			[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
			private DebugViewProperty[] Items
			{
				get
				{
					DebugViewProperty[] array = new DebugViewProperty[_node.Count];
					int num = 0;
					foreach (KeyValuePair<string, JsonNode> item in _node)
					{
						array[num].PropertyName = item.Key;
						array[num].Value = item.Value;
						num++;
					}
					return array;
				}
			}

			public DebugView(JsonObject node)
			{
				_node = node;
			}
		}

		private JsonElement? _jsonElement;

		private JsonPropertyDictionary<JsonNode> _dictionary;

		internal JsonPropertyDictionary<JsonNode?> Dictionary
		{
			get
			{
				JsonPropertyDictionary<JsonNode> dictionary = _dictionary;
				if (dictionary == null)
				{
					return InitializeDictionary();
				}
				return dictionary;
			}
		}

		public int Count => Dictionary.Count;

		ICollection<string> IDictionary<string, JsonNode>.Keys => Dictionary.Keys;

		ICollection<JsonNode?> IDictionary<string, JsonNode>.Values => Dictionary.Values;

		bool ICollection<KeyValuePair<string, JsonNode>>.IsReadOnly => false;

		public JsonObject(JsonNodeOptions? options = null)
			: base(options)
		{
		}

		public JsonObject(IEnumerable<KeyValuePair<string, JsonNode?>> properties, JsonNodeOptions? options = null)
			: this(options)
		{
			foreach (KeyValuePair<string, JsonNode> property in properties)
			{
				Add(property.Key, property.Value);
			}
		}

		public static JsonObject? Create(JsonElement element, JsonNodeOptions? options = null)
		{
			return element.ValueKind switch
			{
				JsonValueKind.Null => null, 
				JsonValueKind.Object => new JsonObject(element, options), 
				_ => throw new InvalidOperationException(System.SR.Format(System.SR.NodeElementWrongType, "Object")), 
			};
		}

		internal JsonObject(JsonElement element, JsonNodeOptions? options = null)
			: this(options)
		{
			_jsonElement = element;
		}

		internal override JsonNode DeepCloneCore()
		{
			GetUnderlyingRepresentation(out var dictionary, out var jsonElement);
			if (dictionary == null)
			{
				if (!jsonElement.HasValue)
				{
					return new JsonObject(base.Options);
				}
				return new JsonObject(jsonElement.Value.Clone(), base.Options);
			}
			bool caseInsensitive = base.Options.HasValue && base.Options.Value.PropertyNameCaseInsensitive;
			JsonObject jsonObject = new JsonObject(base.Options)
			{
				_dictionary = new JsonPropertyDictionary<JsonNode>(caseInsensitive, dictionary.Count)
			};
			foreach (KeyValuePair<string, JsonNode> item in dictionary)
			{
				jsonObject.Add(item.Key, item.Value?.DeepCloneCore());
			}
			return jsonObject;
		}

		internal string GetPropertyName(JsonNode node)
		{
			KeyValuePair<string, JsonNode>? keyValuePair = Dictionary.FindValue(node);
			if (!keyValuePair.HasValue)
			{
				return string.Empty;
			}
			return keyValuePair.Value.Key;
		}

		public bool TryGetPropertyValue(string propertyName, out JsonNode? jsonNode)
		{
			return ((IDictionary<string, JsonNode>)this).TryGetValue(propertyName, out jsonNode);
		}

		public override void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions? options = null)
		{
			if (writer == null)
			{
				ThrowHelper.ThrowArgumentNullException("writer");
			}
			GetUnderlyingRepresentation(out var dictionary, out var jsonElement);
			if (dictionary == null && jsonElement.HasValue)
			{
				jsonElement.Value.WriteTo(writer);
				return;
			}
			writer.WriteStartObject();
			foreach (KeyValuePair<string, JsonNode> item in Dictionary)
			{
				writer.WritePropertyName(item.Key);
				if (item.Value == null)
				{
					writer.WriteNullValue();
				}
				else
				{
					item.Value.WriteTo(writer, options);
				}
			}
			writer.WriteEndObject();
		}

		internal override JsonValueKind GetValueKindCore()
		{
			return JsonValueKind.Object;
		}

		internal override bool DeepEqualsCore(JsonNode node)
		{
			if (node != null && !(node is JsonArray))
			{
				if (!(node is JsonValue jsonValue))
				{
					if (node is JsonObject jsonObject)
					{
						JsonPropertyDictionary<JsonNode> dictionary = Dictionary;
						JsonPropertyDictionary<JsonNode> dictionary2 = jsonObject.Dictionary;
						if (dictionary.Count != dictionary2.Count)
						{
							return false;
						}
						foreach (KeyValuePair<string, JsonNode> item in dictionary)
						{
							JsonNode node2 = dictionary2[item.Key];
							if (!JsonNode.DeepEquals(item.Value, node2))
							{
								return false;
							}
						}
						return true;
					}
					return false;
				}
				return jsonValue.DeepEqualsCore(this);
			}
			return false;
		}

		internal JsonNode GetItem(string propertyName)
		{
			if (TryGetPropertyValue(propertyName, out JsonNode jsonNode))
			{
				return jsonNode;
			}
			return null;
		}

		internal override void GetPath(List<string> path, JsonNode child)
		{
			if (child != null)
			{
				string key = Dictionary.FindValue(child).Value.Key;
				if (MemoryExtensions.AsSpan(key).ContainsSpecialCharacters())
				{
					path.Add("['" + key + "']");
				}
				else
				{
					path.Add("." + key);
				}
			}
			base.Parent?.GetPath(path, this);
		}

		internal void SetItem(string propertyName, JsonNode value)
		{
			bool valueAlreadyInDictionary;
			JsonNode item = Dictionary.SetValue(propertyName, value, out valueAlreadyInDictionary);
			if (!valueAlreadyInDictionary)
			{
				value?.AssignParent(this);
			}
			DetachParent(item);
		}

		private void DetachParent(JsonNode item)
		{
			if (item != null)
			{
				item.Parent = null;
			}
		}

		public void Add(string propertyName, JsonNode? value)
		{
			Dictionary.Add(propertyName, value);
			value?.AssignParent(this);
		}

		public void Add(KeyValuePair<string, JsonNode?> property)
		{
			Add(property.Key, property.Value);
		}

		public void Clear()
		{
			JsonPropertyDictionary<JsonNode> dictionary = _dictionary;
			if (dictionary == null)
			{
				_jsonElement = null;
				return;
			}
			foreach (JsonNode item in dictionary.GetValueCollection())
			{
				DetachParent(item);
			}
			dictionary.Clear();
		}

		public bool ContainsKey(string propertyName)
		{
			return Dictionary.ContainsKey(propertyName);
		}

		public bool Remove(string propertyName)
		{
			if (propertyName == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyName");
			}
			JsonNode existing;
			bool flag = Dictionary.TryRemoveProperty(propertyName, out existing);
			if (flag)
			{
				DetachParent(existing);
			}
			return flag;
		}

		bool ICollection<KeyValuePair<string, JsonNode>>.Contains(KeyValuePair<string, JsonNode> item)
		{
			return Dictionary.Contains(item);
		}

		void ICollection<KeyValuePair<string, JsonNode>>.CopyTo(KeyValuePair<string, JsonNode>[] array, int index)
		{
			Dictionary.CopyTo(array, index);
		}

		public IEnumerator<KeyValuePair<string, JsonNode?>> GetEnumerator()
		{
			return Dictionary.GetEnumerator();
		}

		bool ICollection<KeyValuePair<string, JsonNode>>.Remove(KeyValuePair<string, JsonNode> item)
		{
			return Remove(item.Key);
		}

		bool IDictionary<string, JsonNode>.TryGetValue(string propertyName, out JsonNode jsonNode)
		{
			return Dictionary.TryGetValue(propertyName, out jsonNode);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return Dictionary.GetEnumerator();
		}

		private JsonPropertyDictionary<JsonNode> InitializeDictionary()
		{
			GetUnderlyingRepresentation(out var dictionary, out var jsonElement);
			if (dictionary == null)
			{
				bool caseInsensitive = base.Options.HasValue && base.Options.Value.PropertyNameCaseInsensitive;
				dictionary = new JsonPropertyDictionary<JsonNode>(caseInsensitive);
				if (jsonElement.HasValue)
				{
					foreach (JsonProperty item in jsonElement.Value.EnumerateObject())
					{
						JsonNode jsonNode = JsonNodeConverter.Create(item.Value, base.Options);
						if (jsonNode != null)
						{
							jsonNode.Parent = this;
						}
						dictionary.Add(new KeyValuePair<string, JsonNode>(item.Name, jsonNode));
					}
				}
				_dictionary = dictionary;
				Interlocked.MemoryBarrier();
				_jsonElement = null;
			}
			return dictionary;
		}

		private void GetUnderlyingRepresentation(out JsonPropertyDictionary<JsonNode> dictionary, out JsonElement? jsonElement)
		{
			jsonElement = _jsonElement;
			Interlocked.MemoryBarrier();
			dictionary = _dictionary;
		}
	}
	public abstract class JsonValue : JsonNode
	{
		internal const string CreateUnreferencedCodeMessage = "Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed.";

		internal const string CreateDynamicCodeMessage = "Creating JsonValue instances with non-primitive types requires generating code at runtime.";

		public static JsonValue Create(bool value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<bool>(value, JsonMetadataServices.BooleanConverter);
		}

		public static JsonValue? Create(bool? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<bool>(value.Value, JsonMetadataServices.BooleanConverter);
		}

		public static JsonValue Create(byte value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<byte>(value, JsonMetadataServices.ByteConverter);
		}

		public static JsonValue? Create(byte? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<byte>(value.Value, JsonMetadataServices.ByteConverter);
		}

		public static JsonValue Create(char value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<char>(value, JsonMetadataServices.CharConverter);
		}

		public static JsonValue? Create(char? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<char>(value.Value, JsonMetadataServices.CharConverter);
		}

		public static JsonValue Create(DateTime value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<DateTime>(value, JsonMetadataServices.DateTimeConverter);
		}

		public static JsonValue? Create(DateTime? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<DateTime>(value.Value, JsonMetadataServices.DateTimeConverter);
		}

		public static JsonValue Create(DateTimeOffset value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<DateTimeOffset>(value, JsonMetadataServices.DateTimeOffsetConverter);
		}

		public static JsonValue? Create(DateTimeOffset? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<DateTimeOffset>(value.Value, JsonMetadataServices.DateTimeOffsetConverter);
		}

		public static JsonValue Create(decimal value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<decimal>(value, JsonMetadataServices.DecimalConverter);
		}

		public static JsonValue? Create(decimal? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<decimal>(value.Value, JsonMetadataServices.DecimalConverter);
		}

		public static JsonValue Create(double value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<double>(value, JsonMetadataServices.DoubleConverter);
		}

		public static JsonValue? Create(double? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<double>(value.Value, JsonMetadataServices.DoubleConverter);
		}

		public static JsonValue Create(Guid value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<Guid>(value, JsonMetadataServices.GuidConverter);
		}

		public static JsonValue? Create(Guid? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<Guid>(value.Value, JsonMetadataServices.GuidConverter);
		}

		public static JsonValue Create(short value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<short>(value, JsonMetadataServices.Int16Converter);
		}

		public static JsonValue? Create(short? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<short>(value.Value, JsonMetadataServices.Int16Converter);
		}

		public static JsonValue Create(int value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<int>(value, JsonMetadataServices.Int32Converter);
		}

		public static JsonValue? Create(int? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<int>(value.Value, JsonMetadataServices.Int32Converter);
		}

		public static JsonValue Create(long value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<long>(value, JsonMetadataServices.Int64Converter);
		}

		public static JsonValue? Create(long? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<long>(value.Value, JsonMetadataServices.Int64Converter);
		}

		[CLSCompliant(false)]
		public static JsonValue Create(sbyte value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<sbyte>(value, JsonMetadataServices.SByteConverter);
		}

		[CLSCompliant(false)]
		public static JsonValue? Create(sbyte? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<sbyte>(value.Value, JsonMetadataServices.SByteConverter);
		}

		public static JsonValue Create(float value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<float>(value, JsonMetadataServices.SingleConverter);
		}

		public static JsonValue? Create(float? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<float>(value.Value, JsonMetadataServices.SingleConverter);
		}

		[return: NotNullIfNotNull("value")]
		public static JsonValue? Create(string? value, JsonNodeOptions? options = null)
		{
			if (value == null)
			{
				return null;
			}
			return new JsonValuePrimitive<string>(value, JsonMetadataServices.StringConverter);
		}

		[CLSCompliant(false)]
		public static JsonValue Create(ushort value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<ushort>(value, JsonMetadataServices.UInt16Converter);
		}

		[CLSCompliant(false)]
		public static JsonValue? Create(ushort? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<ushort>(value.Value, JsonMetadataServices.UInt16Converter);
		}

		[CLSCompliant(false)]
		public static JsonValue Create(uint value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<uint>(value, JsonMetadataServices.UInt32Converter);
		}

		[CLSCompliant(false)]
		public static JsonValue? Create(uint? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<uint>(value.Value, JsonMetadataServices.UInt32Converter);
		}

		[CLSCompliant(false)]
		public static JsonValue Create(ulong value, JsonNodeOptions? options = null)
		{
			return new JsonValuePrimitive<ulong>(value, JsonMetadataServices.UInt64Converter);
		}

		[CLSCompliant(false)]
		public static JsonValue? Create(ulong? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			return new JsonValuePrimitive<ulong>(value.Value, JsonMetadataServices.UInt64Converter);
		}

		public static JsonValue? Create(JsonElement value, JsonNodeOptions? options = null)
		{
			if (value.ValueKind == JsonValueKind.Null)
			{
				return null;
			}
			VerifyJsonElementIsNotArrayOrObject(ref value);
			return new JsonValuePrimitive<JsonElement>(value, JsonMetadataServices.JsonElementConverter);
		}

		public static JsonValue? Create(JsonElement? value, JsonNodeOptions? options = null)
		{
			if (!value.HasValue)
			{
				return null;
			}
			JsonElement element = value.Value;
			if (element.ValueKind == JsonValueKind.Null)
			{
				return null;
			}
			VerifyJsonElementIsNotArrayOrObject(ref element);
			return new JsonValuePrimitive<JsonElement>(element, JsonMetadataServices.JsonElementConverter);
		}

		private protected JsonValue(JsonNodeOptions? options = null)
			: base(options)
		{
		}

		[RequiresUnreferencedCode("Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed. Use the overload that takes a JsonTypeInfo, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("Creating JsonValue instances with non-primitive types requires generating code at runtime.")]
		public static JsonValue? Create<T>(T? value, JsonNodeOptions? options = null)
		{
			if (value == null)
			{
				return null;
			}
			if (value is JsonElement)
			{
				object obj = value;
				JsonElement element = (JsonElement)((obj is JsonElement) ? obj : null);
				if (element.ValueKind == JsonValueKind.Null)
				{
					return null;
				}
				VerifyJsonElementIsNotArrayOrObject(ref element);
				return new JsonValuePrimitive<JsonElement>(element, JsonMetadataServices.JsonElementConverter, options);
			}
			JsonTypeInfo<T> jsonTypeInfo = (JsonTypeInfo<T>)JsonSerializerOptions.Default.GetTypeInfo(typeof(T));
			return new JsonValueCustomized<T>(value, jsonTypeInfo, options);
		}

		public static JsonValue? Create<T>(T? value, JsonTypeInfo<T> jsonTypeInfo, JsonNodeOptions? options = null)
		{
			if (jsonTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
			}
			if (value == null)
			{
				return null;
			}
			if (value is JsonElement)
			{
				object obj = value;
				JsonElement element = (JsonElement)((obj is JsonElement) ? obj : null);
				if (element.ValueKind == JsonValueKind.Null)
				{
					return null;
				}
				VerifyJsonElementIsNotArrayOrObject(ref element);
			}
			jsonTypeInfo.EnsureConfigured();
			return new JsonValueCustomized<T>(value, jsonTypeInfo, options);
		}

		internal override void GetPath(List<string> path, JsonNode child)
		{
			base.Parent?.GetPath(path, this);
		}

		public abstract bool TryGetValue<T>([NotNullWhen(true)] out T? value);

		private static void VerifyJsonElementIsNotArrayOrObject(ref JsonElement element)
		{
			JsonValueKind valueKind = element.ValueKind;
			if (valueKind - 1 <= JsonValueKind.Object)
			{
				ThrowHelper.ThrowInvalidOperationException_NodeElementCannotBeObjectOrArray();
			}
		}
	}
	internal sealed class JsonValueCustomized<TValue> : JsonValue<TValue>
	{
		private readonly JsonTypeInfo<TValue> _jsonTypeInfo;

		public JsonValueCustomized(TValue value, JsonTypeInfo<TValue> jsonTypeInfo, JsonNodeOptions? options = null)
			: base(value, options)
		{
			_jsonTypeInfo = jsonTypeInfo;
		}

		public override void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options = null)
		{
			if (writer == null)
			{
				ThrowHelper.ThrowArgumentNullException("writer");
			}
			JsonTypeInfo<TValue> jsonTypeInfo = _jsonTypeInfo;
			if (options != null && options != jsonTypeInfo.Options)
			{
				options.MakeReadOnly();
				jsonTypeInfo = (JsonTypeInfo<TValue>)options.GetTypeInfoInternal(typeof(TValue), ensureConfigured: true, true);
			}
			jsonTypeInfo.Serialize(writer, in Value);
		}

		internal override JsonNode DeepCloneCore()
		{
			return JsonSerializer.SerializeToNode(Value, _jsonTypeInfo);
		}
	}
	[DebuggerDisplay("{ToJsonString(),nq}")]
	[DebuggerTypeProxy(typeof(JsonValue<>.DebugView))]
	internal abstract class JsonValue<TValue> : JsonValue
	{
		[ExcludeFromCodeCoverage]
		[DebuggerDisplay("{Json,nq}")]
		private sealed class DebugView
		{
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			public JsonValue<TValue> _node;

			public string Json => _node.ToJsonString();

			public string Path => _node.GetPath();

			public TValue Value => _node.Value;

			public DebugView(JsonValue<TValue> node)
			{
				_node = node;
			}
		}

		internal readonly TValue Value;

		protected JsonValue(TValue value, JsonNodeOptions? options = null)
			: base(options)
		{
			if (value is JsonNode)
			{
				ThrowHelper.ThrowArgumentException_NodeValueNotAllowed("value");
			}
			Value = value;
		}

		public override T GetValue<T>()
		{
			TValue value = Value;
			if (value is T)
			{
				object obj = value;
				return (T)((obj is T) ? obj : null);
			}
			if (Value is JsonElement)
			{
				return ConvertJsonElement<T>();
			}
			throw new InvalidOperationException(System.SR.Format(System.SR.NodeUnableToConvert, Value.GetType(), typeof(T)));
		}

		public override bool TryGetValue<T>([NotNullWhen(true)] out T value)
		{
			TValue value2 = Value;
			if (value2 is T val)
			{
				value = val;
				return true;
			}
			if (Value is JsonElement)
			{
				return TryConvertJsonElement<T>(out value);
			}
			value = default(T);
			return false;
		}

		internal sealed override JsonValueKind GetValueKindCore()
		{
			TValue value = Value;
			if (value is JsonElement jsonElement)
			{
				return jsonElement.ValueKind;
			}
			using PooledByteBufferWriter pooledByteBufferWriter = WriteToPooledBuffer();
			return JsonElement.ParseValue(pooledByteBufferWriter.WrittenMemory.Span, default(JsonDocumentOptions)).ValueKind;
		}

		internal sealed override bool DeepEqualsCore(JsonNode otherNode)
		{
			if (otherNode == null)
			{
				return false;
			}
			TValue value = Value;
			ReadOnlyMemory<byte> readOnlyMemory;
			if (value is JsonElement jsonElement && otherNode is JsonValue<JsonElement> { Value: var value2 })
			{
				if (jsonElement.ValueKind != value2.ValueKind)
				{
					return false;
				}
				switch (jsonElement.ValueKind)
				{
				case JsonValueKind.True:
				case JsonValueKind.False:
				case JsonValueKind.Null:
					return true;
				case JsonValueKind.String:
					return jsonElement.ValueEquals(value2.GetString());
				case JsonValueKind.Number:
				{
					readOnlyMemory = jsonElement.GetRawValue();
					ReadOnlySpan<byte> span = readOnlyMemory.Span;
					readOnlyMemory = value2.GetRawValue();
					return span.SequenceEqual(readOnlyMemory.Span);
				}
				default:
					return false;
				}
			}
			using PooledByteBufferWriter pooledByteBufferWriter = WriteToPooledBuffer();
			using PooledByteBufferWriter pooledByteBufferWriter2 = otherNode.WriteToPooledBuffer();
			readOnlyMemory = pooledByteBufferWriter.WrittenMemory;
			ReadOnlySpan<byte> span2 = readOnlyMemory.Span;
			readOnlyMemory = pooledByteBufferWriter2.WrittenMemory;
			return span2.SequenceEqual(readOnlyMemory.Span);
		}

		internal TypeToConvert ConvertJsonElement<TypeToConvert>()
		{
			JsonElement jsonElement = (JsonElement)(object)Value;
			switch (jsonElement.ValueKind)
			{
			case JsonValueKind.Number:
				if (typeof(TypeToConvert) == typeof(int) || typeof(TypeToConvert) == typeof(int?))
				{
					return (TypeToConvert)(object)jsonElement.GetInt32();
				}
				if (typeof(TypeToConvert) == typeof(long) || typeof(TypeToConvert) == typeof(long?))
				{
					return (TypeToConvert)(object)jsonElement.GetInt64();
				}
				if (typeof(TypeToConvert) == typeof(double) || typeof(TypeToConvert) == typeof(double?))
				{
					return (TypeToConvert)(object)jsonElement.GetDouble();
				}
				if (typeof(TypeToConvert) == typeof(short) || typeof(TypeToConvert) == typeof(short?))
				{
					return (TypeToConvert)(object)jsonElement.GetInt16();
				}
				if (typeof(TypeToConvert) == typeof(decimal) || typeof(TypeToConvert) == typeof(decimal?))
				{
					return (TypeToConvert)(object)jsonElement.GetDecimal();
				}
				if (typeof(TypeToConvert) == typeof(byte) || typeof(TypeToConvert) == typeof(byte?))
				{
					return (TypeToConvert)(object)jsonElement.GetByte();
				}
				if (typeof(TypeToConvert) == typeof(float) || typeof(TypeToConvert) == typeof(float?))
				{
					return (TypeToConvert)(object)jsonElement.GetSingle();
				}
				if (typeof(TypeToConvert) == typeof(uint) || typeof(TypeToConvert) == typeof(uint?))
				{
					return (TypeToConvert)(object)jsonElement.GetUInt32();
				}
				if (typeof(TypeToConvert) == typeof(ushort) || typeof(TypeToConvert) == typeof(ushort?))
				{
					return (TypeToConvert)(object)jsonElement.GetUInt16();
				}
				if (typeof(TypeToConvert) == typeof(ulong) || typeof(TypeToConvert) == typeof(ulong?))
				{
					return (TypeToConvert)(object)jsonElement.GetUInt64();
				}
				if (typeof(TypeToConvert) == typeof(sbyte) || typeof(TypeToConvert) == typeof(sbyte?))
				{
					return (TypeToConvert)(object)jsonElement.GetSByte();
				}
				break;
			case JsonValueKind.String:
				if (typeof(TypeToConvert) == typeof(string))
				{
					return (TypeToConvert)(object)jsonElement.GetString();
				}
				if (typeof(TypeToConvert) == typeof(DateTime) || typeof(TypeToConvert) == typeof(DateTime?))
				{
					return (TypeToConvert)(object)jsonElement.GetDateTime();
				}
				if (typeof(TypeToConvert) == typeof(DateTimeOffset) || typeof(TypeToConvert) == typeof(DateTimeOffset?))
				{
					return (TypeToConvert)(object)jsonElement.GetDateTimeOffset();
				}
				if (typeof(TypeToConvert) == typeof(Guid) || typeof(TypeToConvert) == typeof(Guid?))
				{
					return (TypeToConvert)(object)jsonElement.GetGuid();
				}
				if (typeof(TypeToConvert) == typeof(char) || typeof(TypeToConvert) == typeof(char?))
				{
					string text = jsonElement.GetString();
					if (text.Length == 1)
					{
						return (TypeToConvert)(object)text[0];
					}
				}
				break;
			case JsonValueKind.True:
			case JsonValueKind.False:
				if (typeof(TypeToConvert) == typeof(bool) || typeof(TypeToConvert) == typeof(bool?))
				{
					return (TypeToConvert)(object)jsonElement.GetBoolean();
				}
				break;
			}
			throw new InvalidOperationException(System.SR.Format(System.SR.NodeUnableToConvertElement, jsonElement.ValueKind, typeof(TypeToConvert)));
		}

		internal bool TryConvertJsonElement<TypeToConvert>([NotNullWhen(true)] out TypeToConvert result)
		{
			JsonElement jsonElement = (JsonElement)(object)Value;
			switch (jsonElement.ValueKind)
			{
			case JsonValueKind.Number:
				if (typeof(TypeToConvert) == typeof(int) || typeof(TypeToConvert) == typeof(int?))
				{
					int value;
					bool result2 = jsonElement.TryGetInt32(out value);
					result = (TypeToConvert)(object)value;
					return result2;
				}
				if (typeof(TypeToConvert) == typeof(long) || typeof(TypeToConvert) == typeof(long?))
				{
					long value2;
					bool result2 = jsonElement.TryGetInt64(out value2);
					result = (TypeToConvert)(object)value2;
					return result2;
				}
				if (typeof(TypeToConvert) == typeof(double) || typeof(TypeToConvert) == typeof(double?))
				{
					double value3;
					bool result2 = jsonElement.TryGetDouble(out value3);
					result = (TypeToConvert)(object)value3;
					return result2;
				}
				if (typeof(TypeToConvert) == typeof(short) || typeof(TypeToConvert) == typeof(short?))
				{
					short value4;
					bool result2 = jsonElement.TryGetInt16(out value4);
					result = (TypeToConvert)(object)value4;
					return result2;
				}
				if (typeof(TypeToConvert) == typeof(decimal) || typeof(TypeToConvert) == typeof(decimal?))
				{
					decimal value5;
					bool result2 = jsonElement.TryGetDecimal(out value5);
					result = (TypeToConvert)(object)value5;
					return result2;
				}
				if (typeof(TypeToConvert) == typeof(byte) || typeof(TypeToConvert) == typeof(byte?))
				{
					byte value6;
					bool result2 = jsonElement.TryGetByte(out value6);
					result = (TypeToConvert)(object)value6;
					return result2;
				}
				if (typeof(TypeToConvert) == typeof(float) || typeof(TypeToConvert) == typeof(float?))
				{
					float value7;
					bool result2 = jsonElement.TryGetSingle(out value7);
					result = (TypeToConvert)(object)value7;
					return result2;
				}
				if (typeof(TypeToConvert) == typeof(uint) || typeof(TypeToConvert) == typeof(uint?))
				{
					uint value8;
					bool result2 = jsonElement.TryGetUInt32(out value8);
					result = (TypeToConvert)(object)value8;
					return result2;
				}
				if (typeof(TypeToConvert) == typeof(ushort) || typeof(TypeToConvert) == typeof(ushort?))
				{
					ushort value9;
					bool result2 = jsonElement.TryGetUInt16(out value9);
					result = (TypeToConvert)(object)value9;
					return result2;
				}
				if (typeof(TypeToConvert) == typeof(ulong) || typeof(TypeToConvert) == typeof(ulong?))
				{
					ulong value10;
					bool result2 = jsonElement.TryGetUInt64(out value10);
					result = (TypeToConvert)(object)value10;
					return result2;
				}
				if (typeof(TypeToConvert) == typeof(sbyte) || typeof(TypeToConvert) == typeof(sbyte?))
				{
					sbyte value11;
					bool result2 = jsonElement.TryGetSByte(out value11);
					result = (TypeToConvert)(object)value11;
					return result2;
				}
				break;
			case JsonValueKind.String:
				if (typeof(TypeToConvert) == typeof(string))
				{
					string text = jsonElement.GetString();
					result = (TypeToConvert)(object)text;
					return true;
				}
				if (typeof(TypeToConvert) == typeof(DateTime) || typeof(TypeToConvert) == typeof(DateTime?))
				{
					DateTime value12;
					bool result2 = jsonElement.TryGetDateTime(out value12);
					result = (TypeToConvert)(object)value12;
					return result2;
				}
				if (typeof(TypeToConvert) == typeof(DateTimeOffset) || typeof(TypeToConvert) == typeof(DateTimeOffset?))
				{
					DateTimeOffset value13;
					bool result2 = jsonElement.TryGetDateTimeOffset(out value13);
					result = (TypeToConvert)(object)value13;
					return result2;
				}
				if (typeof(TypeToConvert) == typeof(Guid) || typeof(TypeToConvert) == typeof(Guid?))
				{
					Guid value14;
					bool result2 = jsonElement.TryGetGuid(out value14);
					result = (TypeToConvert)(object)value14;
					return result2;
				}
				if (typeof(TypeToConvert) == typeof(char) || typeof(TypeToConvert) == typeof(char?))
				{
					string text2 = jsonElement.GetString();
					if (text2.Length == 1)
					{
						result = (TypeToConvert)(object)text2[0];
						return true;
					}
				}
				break;
			case JsonValueKind.True:
			case JsonValueKind.False:
				if (typeof(TypeToConvert) == typeof(bool) || typeof(TypeToConvert) == typeof(bool?))
				{
					result = (TypeToConvert)(object)jsonElement.GetBoolean();
					return true;
				}
				break;
			}
			result = default(TypeToConvert);
			return false;
		}
	}
	internal sealed class JsonValuePrimitive<TValue> : JsonValue<TValue>
	{
		private static readonly JsonSerializerOptions s_defaultOptions = new JsonSerializerOptions();

		private readonly JsonConverter<TValue> _converter;

		public JsonValuePrimitive(TValue value, JsonConverter<TValue> converter, JsonNodeOptions? options = null)
			: base(value, options)
		{
			_converter = converter;
		}

		public override void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options = null)
		{
			if (writer == null)
			{
				ThrowHelper.ThrowArgumentNullException("writer");
			}
			JsonConverter<TValue> converter = _converter;
			if (options == null)
			{
				options = s_defaultOptions;
			}
			if (converter.IsInternalConverterForNumberType)
			{
				converter.WriteNumberWithCustomHandling(writer, Value, options.NumberHandling);
			}
			else
			{
				converter.Write(writer, Value, options);
			}
		}

		internal override JsonNode DeepCloneCore()
		{
			TValue value = Value;
			if (!(value is JsonElement jsonElement))
			{
				return new JsonValuePrimitive<TValue>(Value, _converter, base.Options);
			}
			return new JsonValuePrimitive<JsonElement>(jsonElement.Clone(), JsonMetadataServices.JsonElementConverter, base.Options);
		}
	}
}
namespace System.Text.Json.Reflection
{
	internal static class ReflectionExtensions
	{
		private const string ImmutableArrayGenericTypeName = "System.Collections.Immutable.ImmutableArray`1";

		private const string ImmutableListGenericTypeName = "System.Collections.Immutable.ImmutableList`1";

		private const string ImmutableListGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableList`1";

		private const string ImmutableStackGenericTypeName = "System.Collections.Immutable.ImmutableStack`1";

		private const string ImmutableStackGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableStack`1";

		private const string ImmutableQueueGenericTypeName = "System.Collections.Immutable.ImmutableQueue`1";

		private const string ImmutableQueueGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableQueue`1";

		private const string ImmutableSortedSetGenericTypeName = "System.Collections.Immutable.ImmutableSortedSet`1";

		private const string ImmutableHashSetGenericTypeName = "System.Collections.Immutable.ImmutableHashSet`1";

		private const string ImmutableSetGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableSet`1";

		private const string ImmutableDictionaryGenericTypeName = "System.Collections.Immutable.ImmutableDictionary`2";

		private const string ImmutableDictionaryGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableDictionary`2";

		private const string ImmutableSortedDictionaryGenericTypeName = "System.Collections.Immutable.ImmutableSortedDictionary`2";

		private const string ImmutableArrayTypeName = "System.Collections.Immutable.ImmutableArray";

		private const string ImmutableListTypeName = "System.Collections.Immutable.ImmutableList";

		private const string ImmutableStackTypeName = "System.Collections.Immutable.ImmutableStack";

		private const string ImmutableQueueTypeName = "System.Collections.Immutable.ImmutableQueue";

		private const string ImmutableSortedSetTypeName = "System.Collections.Immutable.ImmutableSortedSet";

		private const string ImmutableHashSetTypeName = "System.Collections.Immutable.ImmutableHashSet";

		private const string ImmutableDictionaryTypeName = "System.Collections.Immutable.ImmutableDictionary";

		private const string ImmutableSortedDictionaryTypeName = "System.Collections.Immutable.ImmutableSortedDictionary";

		public const string CreateRangeMethodName = "CreateRange";

		private static readonly Type s_nullableType = typeof(Nullable<>);

		public static Type GetCompatibleGenericBaseClass(this Type type, Type baseType)
		{
			if ((object)baseType == null)
			{
				return null;
			}
			Type type2 = type;
			while (type2 != null && type2 != typeof(object))
			{
				if (type2.IsGenericType)
				{
					Type genericTypeDefinition = type2.GetGenericTypeDefinition();
					if (genericTypeDefinition == baseType)
					{
						return type2;
					}
				}
				type2 = type2.BaseType;
			}
			return null;
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern", Justification = "The 'interfaceType' must exist and so trimmer kept it. In which case It also kept it on any type which implements it. The below call to GetInterfaces may return fewer results when trimmed but it will return the 'interfaceType' if the type implemented it, even after trimming.")]
		public static Type GetCompatibleGenericInterface(this Type type, Type interfaceType)
		{
			if ((object)interfaceType == null)
			{
				return null;
			}
			Type type2 = type;
			if (type2.IsGenericType)
			{
				type2 = type2.GetGenericTypeDefinition();
			}
			if (type2 == interfaceType)
			{
				return type;
			}
			Type[] interfaces = type.GetInterfaces();
			foreach (Type type3 in interfaces)
			{
				if (type3.IsGenericType)
				{
					Type genericTypeDefinition = type3.GetGenericTypeDefinition();
					if (genericTypeDefinition == interfaceType)
					{
						return type3;
					}
				}
			}
			return null;
		}

		public static bool IsImmutableDictionaryType(this Type type)
		{
			if (!type.IsGenericType || !type.Assembly.FullName.StartsWith("System.Collections.Immutable", StringComparison.Ordinal))
			{
				return false;
			}
			switch (GetBaseNameFromGenericType(type))
			{
			case "System.Collections.Immutable.ImmutableDictionary`2":
			case "System.Collections.Immutable.IImmutableDictionary`2":
			case "System.Collections.Immutable.ImmutableSortedDictionary`2":
				return true;
			default:
				return false;
			}
		}

		public static bool IsImmutableEnumerableType(this Type type)
		{
			if (!type.IsGenericType || !type.Assembly.FullName.StartsWith("System.Collections.Immutable", StringComparison.Ordinal))
			{
				return false;
			}
			switch (GetBaseNameFromGenericType(type))
			{
			case "System.Collections.Immutable.ImmutableStack`1":
			case "System.Collections.Immutable.IImmutableList`1":
			case "System.Collections.Immutable.ImmutableArray`1":
			case "System.Collections.Immutable.ImmutableQueue`1":
			case "System.Collections.Immutable.IImmutableSet`1":
			case "System.Collections.Immutable.ImmutableList`1":
			case "System.Collections.Immutable.IImmutableQueue`1":
			case "System.Collections.Immutable.IImmutableStack`1":
			case "System.Collections.Immutable.ImmutableSortedSet`1":
			case "System.Collections.Immutable.ImmutableHashSet`1":
				return true;
			default:
				return false;
			}
		}

		public static string GetImmutableDictionaryConstructingTypeName(this Type type)
		{
			switch (GetBaseNameFromGenericType(type))
			{
			case "System.Collections.Immutable.ImmutableDictionary`2":
			case "System.Collections.Immutable.IImmutableDictionary`2":
				return "System.Collections.Immutable.ImmutableDictionary";
			case "System.Collections.Immutable.ImmutableSortedDictionary`2":
				return "System.Collections.Immutable.ImmutableSortedDictionary";
			default:
				return null;
			}
		}

		public static string GetImmutableEnumerableConstructingTypeName(this Type type)
		{
			switch (GetBaseNameFromGenericType(type))
			{
			case "System.Collections.Immutable.ImmutableArray`1":
				return "System.Collections.Immutable.ImmutableArray";
			case "System.Collections.Immutable.IImmutableList`1":
			case "System.Collections.Immutable.ImmutableList`1":
				return "System.Collections.Immutable.ImmutableList";
			case "System.Collections.Immutable.ImmutableStack`1":
			case "System.Collections.Immutable.IImmutableStack`1":
				return "System.Collections.Immutable.ImmutableStack";
			case "System.Collections.Immutable.ImmutableQueue`1":
			case "System.Collections.Immutable.IImmutableQueue`1":
				return "System.Collections.Immutable.ImmutableQueue";
			case "System.Collections.Immutable.ImmutableSortedSet`1":
				return "System.Collections.Immutable.ImmutableSortedSet";
			case "System.Collections.Immutable.IImmutableSet`1":
			case "System.Collections.Immutable.ImmutableHashSet`1":
				return "System.Collections.Immutable.ImmutableHashSet";
			default:
				return null;
			}
		}

		private static string GetBaseNameFromGenericType(Type genericType)
		{
			Type genericTypeDefinition = genericType.GetGenericTypeDefinition();
			return genericTypeDefinition.FullName;
		}

		public static bool IsVirtual(this PropertyInfo propertyInfo)
		{
			MethodInfo getMethod = propertyInfo.GetMethod;
			if ((object)getMethod == null || !getMethod.IsVirtual)
			{
				return propertyInfo.SetMethod?.IsVirtual ?? false;
			}
			return true;
		}

		public static bool IsKeyValuePair(this Type type)
		{
			if (type.IsGenericType)
			{
				return type.GetGenericTypeDefinition() == typeof(KeyValuePair<, >);
			}
			return false;
		}

		public static bool TryGetDeserializationConstructor([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.NonPublicConstructors)] this Type type, bool useDefaultCtorInAnnotatedStructs, out ConstructorInfo deserializationCtor)
		{
			ConstructorInfo constructorInfo = null;
			ConstructorInfo constructorInfo2 = null;
			ConstructorInfo constructorInfo3 = null;
			ConstructorInfo[] constructors = type.GetConstructors(BindingFlags.Instance | BindingFlags.Public);
			if (constructors.Length == 1)
			{
				constructorInfo3 = constructors[0];
			}
			ConstructorInfo[] array = constructors;
			foreach (ConstructorInfo constructorInfo4 in array)
			{
				if (HasJsonConstructorAttribute(constructorInfo4))
				{
					if (constructorInfo != null)
					{
						deserializationCtor = null;
						return false;
					}
					constructorInfo = constructorInfo4;
				}
				else if (constructorInfo4.GetParameters().Length == 0)
				{
					constructorInfo2 = constructorInfo4;
				}
			}
			ConstructorInfo[] constructors2 = type.GetConstructors(BindingFlags.Instance | BindingFlags.NonPublic);
			foreach (ConstructorInfo constructorInfo5 in constructors2)
			{
				if (HasJsonConstructorAttribute(constructorInfo5))
				{
					if (constructorInfo != null)
					{
						deserializationCtor = null;
						return false;
					}
					constructorInfo = constructorInfo5;
				}
			}
			if (useDefaultCtorInAnnotatedStructs && type.IsValueType && constructorInfo == null)
			{
				deserializationCtor = null;
				return true;
			}
			deserializationCtor = constructorInfo ?? constructorInfo2 ?? constructorInfo3;
			return true;
		}

		public static object GetDefaultValue(this ParameterInfo parameterInfo)
		{
			Type parameterType = parameterInfo.ParameterType;
			object defaultValue = parameterInfo.DefaultValue;
			if (defaultValue == null)
			{
				return null;
			}
			if (defaultValue == DBNull.Value && parameterType != typeof(DBNull))
			{
				return null;
			}
			if (parameterType.IsEnum)
			{
				return Enum.ToObject(parameterType, defaultValue);
			}
			Type underlyingType = Nullable.GetUnderlyingType(parameterType);
			if ((object)underlyingType != null && underlyingType.IsEnum)
			{
				return Enum.ToObject(underlyingType, defaultValue);
			}
			return defaultValue;
		}

		[RequiresUnreferencedCode("Should only be used by the reflection-based serializer.")]
		public static Type[] GetSortedTypeHierarchy(this Type type)
		{
			if (!type.IsInterface)
			{
				List<Type> list = new List<Type>();
				Type type2 = type;
				while (type2 != null)
				{
					list.Add(type2);
					type2 = type2.BaseType;
				}
				return list.ToArray();
			}
			return JsonHelpers.TraverseGraphWithTopologicalSort(type, (Type t) => t.GetInterfaces());
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsNullableOfT(this Type type)
		{
			if (type.IsGenericType)
			{
				return type.GetGenericTypeDefinition() == s_nullableType;
			}
			return false;
		}

		public static bool IsAssignableFromInternal(this Type type, Type from)
		{
			if (from.IsNullableOfT() && type.IsInterface)
			{
				return type.IsAssignableFrom(from.GetGenericArguments()[0]);
			}
			return type.IsAssignableFrom(from);
		}

		public static bool IsInSubtypeRelationshipWith(this Type type, Type other)
		{
			if (!type.IsAssignableFromInternal(other))
			{
				return other.IsAssignableFromInternal(type);
			}
			return true;
		}

		private static bool HasJsonConstructorAttribute(ConstructorInfo constructorInfo)
		{
			return constructorInfo.GetCustomAttribute<JsonConstructorAttribute>() != null;
		}

		public static bool HasRequiredMemberAttribute(this MemberInfo memberInfo)
		{
			return memberInfo.HasCustomAttributeWithName("System.Runtime.CompilerServices.RequiredMemberAttribute", inherit: false);
		}

		public static bool HasSetsRequiredMembersAttribute(this MemberInfo memberInfo)
		{
			return memberInfo.HasCustomAttributeWithName("System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute", inherit: false);
		}

		private static bool HasCustomAttributeWithName(this MemberInfo memberInfo, string fullName, bool inherit)
		{
			object[] customAttributes = memberInfo.GetCustomAttributes(inherit);
			foreach (object obj in customAttributes)
			{
				if (obj.GetType().FullName == fullName)
				{
					return true;
				}
			}
			return false;
		}

		public static TAttribute GetUniqueCustomAttribute<TAttribute>(this MemberInfo memberInfo, bool inherit) where TAttribute : Attribute
		{
			object[] customAttributes = memberInfo.GetCustomAttributes(typeof(TAttribute), inherit);
			if (customAttributes.Length == 0)
			{
				return null;
			}
			if (customAttributes.Length == 1)
			{
				return (TAttribute)customAttributes[0];
			}
			ThrowHelper.ThrowInvalidOperationException_SerializationDuplicateAttribute(typeof(TAttribute), memberInfo);
			return null;
		}

		public static object CreateInstanceNoWrapExceptions([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.NonPublicConstructors)] this Type type, Type[] parameterTypes, object[] parameters)
		{
			ConstructorInfo constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, null, parameterTypes, null);
			object result = null;
			try
			{
				result = constructor.Invoke(parameters);
			}
			catch (TargetInvocationException ex)
			{
				ExceptionDispatchInfo.Capture(ex.InnerException).Throw();
			}
			return result;
		}
	}
}
namespace System.Text.Json.Serialization
{
	public abstract class JsonAttribute : Attribute
	{
	}
	public enum JsonIgnoreCondition
	{
		Never,
		Always,
		WhenWritingDefault,
		WhenWritingNull
	}
	public enum JsonKnownNamingPolicy
	{
		Unspecified,
		CamelCase,
		SnakeCaseLower,
		SnakeCaseUpper,
		KebabCaseLower,
		KebabCaseUpper
	}
	[Flags]
	public enum JsonNumberHandling
	{
		Strict = 0,
		AllowReadingFromString = 1,
		WriteAsString = 2,
		AllowNamedFloatingPointLiterals = 4
	}
	public enum JsonObjectCreationHandling
	{
		Replace,
		Populate
	}
	public enum JsonUnmappedMemberHandling
	{
		Skip,
		Disallow
	}
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
	public sealed class JsonSerializableAttribute : JsonAttribute
	{
		public string? TypeInfoPropertyName { get; set; }

		public JsonSourceGenerationMode GenerationMode { get; set; }

		public JsonSerializableAttribute(Type type)
		{
		}
	}
	[Flags]
	public enum JsonSourceGenerationMode
	{
		Default = 0,
		Metadata = 1,
		Serialization = 2
	}
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
	public sealed class JsonSourceGenerationOptionsAttribute : JsonAttribute
	{
		public bool AllowTrailingCommas { get; set; }

		public Type[]? Converters { get; set; }

		public int DefaultBufferSize { get; set; }

		public JsonIgnoreCondition DefaultIgnoreCondition { get; set; }

		public JsonKnownNamingPolicy DictionaryKeyPolicy { get; set; }

		public bool IgnoreReadOnlyFields { get; set; }

		public bool IgnoreReadOnlyProperties { get; set; }

		public bool IncludeFields { get; set; }

		public int MaxDepth { get; set; }

		public JsonNumberHandling NumberHandling { get; set; }

		public JsonObjectCreationHandling PreferredObjectCreationHandling { get; set; }

		public bool PropertyNameCaseInsensitive { get; set; }

		public JsonKnownNamingPolicy PropertyNamingPolicy { get; set; }

		public JsonCommentHandling ReadCommentHandling { get; set; }

		public JsonUnknownTypeHandling UnknownTypeHandling { get; set; }

		public JsonUnmappedMemberHandling UnmappedMemberHandling { get; set; }

		public bool WriteIndented { get; set; }

		public JsonSourceGenerationMode GenerationMode { get; set; }

		public bool UseStringEnumConverter { get; set; }

		public JsonSourceGenerationOptionsAttribute()
		{
		}

		public JsonSourceGenerationOptionsAttribute(JsonSerializerDefaults defaults)
		{
			switch (defaults)
			{
			case JsonSerializerDefaults.Web:
				PropertyNameCaseInsensitive = true;
				PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase;
				NumberHandling = JsonNumberHandling.AllowReadingFromString;
				break;
			default:
				throw new ArgumentOutOfRangeException("defaults");
			case JsonSerializerDefaults.General:
				break;
			}
		}
	}
	public enum JsonUnknownTypeHandling
	{
		JsonElement,
		JsonNode
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Interface, AllowMultiple = false)]
	public sealed class JsonObjectCreationHandlingAttribute : JsonAttribute
	{
		public JsonObjectCreationHandling Handling { get; }

		public JsonObjectCreationHandlingAttribute(JsonObjectCreationHandling handling)
		{
			if (!JsonSerializer.IsValidCreationHandlingValue(handling))
			{
				throw new ArgumentOutOfRangeException("handling");
			}
			Handling = handling;
		}
	}
	[AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false)]
	public sealed class JsonConstructorAttribute : JsonAttribute
	{
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Interface, AllowMultiple = false)]
	public class JsonConverterAttribute : JsonAttribute
	{
		[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)]
		public Type? ConverterType { get; private set; }

		public JsonConverterAttribute([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] Type converterType)
		{
			ConverterType = converterType;
		}

		protected JsonConverterAttribute()
		{
		}

		public virtual JsonConverter? CreateConverter(Type typeToConvert)
		{
			return null;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = true, Inherited = false)]
	public class JsonDerivedTypeAttribute : JsonAttribute
	{
		public Type DerivedType { get; }

		public object? TypeDiscriminator { get; }

		public JsonDerivedTypeAttribute(Type derivedType)
		{
			DerivedType = derivedType;
		}

		public JsonDerivedTypeAttribute(Type derivedType, string typeDiscriminator)
		{
			DerivedType = derivedType;
			TypeDiscriminator = typeDiscriminator;
		}

		public JsonDerivedTypeAttribute(Type derivedType, int typeDiscriminator)
		{
			DerivedType = derivedType;
			TypeDiscriminator = typeDiscriminator;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	public sealed class JsonExtensionDataAttribute : JsonAttribute
	{
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	public sealed class JsonIgnoreAttribute : JsonAttribute
	{
		public JsonIgnoreCondition Condition { get; set; } = JsonIgnoreCondition.Always;
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	public sealed class JsonIncludeAttribute : JsonAttribute
	{
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	public sealed class JsonNumberHandlingAttribute : JsonAttribute
	{
		public JsonNumberHandling Handling { get; }

		public JsonNumberHandlingAttribute(JsonNumberHandling handling)
		{
			if (!JsonSerializer.IsValidNumberHandlingValue(handling))
			{
				throw new ArgumentOutOfRangeException("handling");
			}
			Handling = handling;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false, Inherited = false)]
	public sealed class JsonPolymorphicAttribute : JsonAttribute
	{
		public string? TypeDiscriminatorPropertyName { get; set; }

		public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; set; }

		public bool IgnoreUnrecognizedTypeDiscriminators { get; set; }
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	public sealed class JsonPropertyNameAttribute : JsonAttribute
	{
		public string Name { get; }

		public JsonPropertyNameAttribute(string name)
		{
			Name = name;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	public sealed class JsonRequiredAttribute : JsonAttribute
	{
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	public sealed class JsonPropertyOrderAttribute : JsonAttribute
	{
		public int Order { get; }

		public JsonPropertyOrderAttribute(int order)
		{
			Order = order;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface, AllowMultiple = false, Inherited = false)]
	public class JsonUnmappedMemberHandlingAttribute : JsonAttribute
	{
		public JsonUnmappedMemberHandling UnmappedMemberHandling { get; }

		public JsonUnmappedMemberHandlingAttribute(JsonUnmappedMemberHandling unmappedMemberHandling)
		{
			UnmappedMemberHandling = unmappedMemberHandling;
		}
	}
	internal sealed class IgnoreReferenceResolver : ReferenceResolver
	{
		private Stack<ReferenceEqualsWrapper> _stackForCycleDetection;

		internal override void PopReferenceForCycleDetection()
		{
			_stackForCycleDetection.Pop();
		}

		internal override bool ContainsReferenceForCycleDetection(object value)
		{
			return _stackForCycleDetection?.Contains(new ReferenceEqualsWrapper(value)) ?? false;
		}

		internal override void PushReferenceForCycleDetection(object value)
		{
			ReferenceEqualsWrapper item = new ReferenceEqualsWrapper(value);
			if (_stackForCycleDetection == null)
			{
				_stackForCycleDetection = new Stack<ReferenceEqualsWrapper>();
			}
			_stackForCycleDetection.Push(item);
		}

		public override void AddReference(string referenceId, object value)
		{
			throw new InvalidOperationException();
		}

		public override string GetReference(object value, out bool alreadyExists)
		{
			throw new InvalidOperationException();
		}

		public override object ResolveReference(string referenceId)
		{
			throw new InvalidOperationException();
		}
	}
	public interface IJsonOnDeserialized
	{
		void OnDeserialized();
	}
	public interface IJsonOnDeserializing
	{
		void OnDeserializing();
	}
	public interface IJsonOnSerialized
	{
		void OnSerialized();
	}
	public interface IJsonOnSerializing
	{
		void OnSerializing();
	}
	public sealed class JsonNumberEnumConverter<TEnum> : JsonConverterFactory where TEnum : struct, Enum
	{
		public override bool CanConvert(Type typeToConvert)
		{
			return typeToConvert == typeof(TEnum);
		}

		public override JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options)
		{
			if (typeToConvert != typeof(TEnum))
			{
				ThrowHelper.ThrowArgumentOutOfRangeException_JsonConverterFactory_TypeNotSupported(typeToConvert);
			}
			return new EnumConverter<TEnum>(EnumConverterOptions.AllowNumbers, options);
		}
	}
	public abstract class JsonSerializerContext : IJsonTypeInfoResolver, IBuiltInJsonTypeInfoResolver
	{
		private JsonSerializerOptions _options;

		public JsonSerializerOptions Options
		{
			get
			{
				JsonSerializerOptions jsonSerializerOptions = _options;
				if (jsonSerializerOptions == null)
				{
					jsonSerializerOptions = new JsonSerializerOptions
					{
						TypeInfoResolver = this
					};
					jsonSerializerOptions.MakeReadOnly();
					_options = jsonSerializerOptions;
				}
				return jsonSerializerOptions;
			}
		}

		protected abstract JsonSerializerOptions? GeneratedSerializerOptions { get; }

		internal void AssociateWithOptions(JsonSerializerOptions options)
		{
			options.TypeInfoResolver = this;
			options.MakeReadOnly();
			_options = options;
		}

		bool IBuiltInJsonTypeInfoResolver.IsCompatibleWithOptions(JsonSerializerOptions options)
		{
			JsonSerializerOptions generatedSerializerOptions = GeneratedSerializerOptions;
			if (generatedSerializerOptions != null && options.Converters.Count == 0 && options.Encoder == null && !JsonHelpers.RequiresSpecialNumberHandlingOnWrite(options.NumberHandling) && options.ReferenceHandlingStrategy == ReferenceHandlingStrategy.None && !options.IgnoreNullValues && options.DefaultIgnoreCondition == generatedSerializerOptions.DefaultIgnoreCondition && options.IgnoreReadOnlyFields == generatedSerializerOptions.IgnoreReadOnlyFields && options.IgnoreReadOnlyProperties == generatedSerializerOptions.IgnoreReadOnlyProperties && options.IncludeFields == generatedSerializerOptions.IncludeFields && options.PropertyNamingPolicy == generatedSerializerOptions.PropertyNamingPolicy)
			{
				return options.DictionaryKeyPolicy == null;
			}
			return false;
		}

		protected JsonSerializerContext(JsonSerializerOptions? options)
		{
			if (options != null)
			{
				options.VerifyMutable();
				AssociateWithOptions(options);
			}
		}

		public abstract JsonTypeInfo? GetTypeInfo(Type type);

		JsonTypeInfo IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options)
		{
			if (options != null && options != _options)
			{
				ThrowHelper.ThrowInvalidOperationException_ResolverTypeInfoOptionsNotCompatible();
			}
			return GetTypeInfo(type);
		}
	}
	public enum JsonUnknownDerivedTypeHandling
	{
		FailSerialization,
		FallBackToBaseType,
		FallBackToNearestAncestor
	}
	internal readonly struct ReferenceEqualsWrapper : IEquatable<ReferenceEqualsWrapper>
	{
		private readonly object _object;

		public ReferenceEqualsWrapper(object obj)
		{
			_object = obj;
		}

		public override bool Equals([NotNullWhen(true)] object obj)
		{
			if (obj is ReferenceEqualsWrapper obj2)
			{
				return Equals(obj2);
			}
			return false;
		}

		public bool Equals(ReferenceEqualsWrapper obj)
		{
			return _object == obj._object;
		}

		public override int GetHashCode()
		{
			return RuntimeHelpers.GetHashCode(_object);
		}
	}
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	[DebuggerTypeProxy(typeof(ConfigurationList<>.ConfigurationListDebugView))]
	internal abstract class ConfigurationList<TItem> : IList<TItem>, ICollection<TItem>, IEnumerable<TItem>, IEnumerable
	{
		private sealed class ConfigurationListDebugView(ConfigurationList<TItem> collection)
		{
			[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
			public TItem[] Items => <collection>P._list.ToArray();
		}

		protected readonly List<TItem> _list;

		public abstract bool IsReadOnly { get; }

		public TItem this[int index]
		{
			get
			{
				return _list[index];
			}
			set
			{
				if (value == null)
				{
					ThrowHelper.ThrowArgumentNullException("value");
				}
				ValidateAddedValue(value);
				OnCollectionModifying();
				_list[index] = value;
			}
		}

		public int Count => _list.Count;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private string DebuggerDisplay => $"Count = {Count}, IsReadOnly = {IsReadOnly}";

		public ConfigurationList(IEnumerable<TItem> source = null)
		{
			_list = ((source == null) ? new List<TItem>() : new List<TItem>(source));
		}

		protected abstract void OnCollectionModifying();

		protected virtual void ValidateAddedValue(TItem item)
		{
		}

		public void Add(TItem item)
		{
			if (item == null)
			{
				ThrowHelper.ThrowArgumentNullException("item");
			}
			ValidateAddedValue(item);
			OnCollectionModifying();
			_list.Add(item);
		}

		public void Clear()
		{
			OnCollectionModifying();
			_list.Clear();
		}

		public bool Contains(TItem item)
		{
			return _list.Contains(item);
		}

		public void CopyTo(TItem[] array, int arrayIndex)
		{
			_list.CopyTo(array, arrayIndex);
		}

		public List<TItem>.Enumerator GetEnumerator()
		{
			return _list.GetEnumerator();
		}

		public int IndexOf(TItem item)
		{
			return _list.IndexOf(item);
		}

		public void Insert(int index, TItem item)
		{
			if (item == null)
			{
				ThrowHelper.ThrowArgumentNullException("item");
			}
			ValidateAddedValue(item);
			OnCollectionModifying();
			_list.Insert(index, item);
		}

		public bool Remove(TItem item)
		{
			OnCollectionModifying();
			return _list.Remove(item);
		}

		public void RemoveAt(int index)
		{
			OnCollectionModifying();
			_list.RemoveAt(index);
		}

		IEnumerator<TItem> IEnumerable<TItem>.GetEnumerator()
		{
			return _list.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return _list.GetEnumerator();
		}
	}
	[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
	internal sealed class IAsyncEnumerableConverterFactory : JsonConverterFactory
	{
		public override bool CanConvert(Type typeToConvert)
		{
			return (object)GetAsyncEnumerableInterface(typeToConvert) != null;
		}

		public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
		{
			Type asyncEnumerableInterface = GetAsyncEnumerableInterface(typeToConvert);
			Type type = asyncEnumerableInterface.GetGenericArguments()[0];
			Type type2 = typeof(IAsyncEnumerableOfTConverter<, >).MakeGenericType(typeToConvert, type);
			return (JsonConverter)Activator.CreateInstance(type2);
		}

		private static Type GetAsyncEnumerableInterface(Type type)
		{
			return type.GetCompatibleGenericInterface(typeof(IAsyncEnumerable<>));
		}
	}
	internal static class IEnumerableConverterFactoryHelpers
	{
		internal const string ImmutableConvertersUnreferencedCodeMessage = "System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.";

		[RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		[RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		public static MethodInfo GetImmutableEnumerableCreateRangeMethod(this Type type, Type elementType)
		{
			Type immutableEnumerableConstructingType = GetImmutableEnumerableConstructingType(type);
			if (immutableEnumerableConstructingType != null)
			{
				MethodInfo[] methods = immutableEnumerableConstructingType.GetMethods();
				MethodInfo[] array = methods;
				foreach (MethodInfo methodInfo in array)
				{
					if (methodInfo.Name == "CreateRange" && methodInfo.GetParameters().Length == 1 && methodInfo.IsGenericMethod && methodInfo.GetGenericArguments().Length == 1)
					{
						return methodInfo.MakeGenericMethod(elementType);
					}
				}
			}
			ThrowHelper.ThrowNotSupportedException_SerializationNotSupported(type);
			return null;
		}

		[RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		[RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		public static MethodInfo GetImmutableDictionaryCreateRangeMethod(this Type type, Type keyType, Type valueType)
		{
			Type immutableDictionaryConstructingType = GetImmutableDictionaryConstructingType(type);
			if (immutableDictionaryConstructingType != null)
			{
				MethodInfo[] methods = immutableDictionaryConstructingType.GetMethods();
				MethodInfo[] array = methods;
				foreach (MethodInfo methodInfo in array)
				{
					if (methodInfo.Name == "CreateRange" && methodInfo.GetParameters().Length == 1 && methodInfo.IsGenericMethod && methodInfo.GetGenericArguments().Length == 2)
					{
						return methodInfo.MakeGenericMethod(keyType, valueType);
					}
				}
			}
			ThrowHelper.ThrowNotSupportedException_SerializationNotSupported(type);
			return null;
		}

		[RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		[RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		private static Type GetImmutableEnumerableConstructingType(Type type)
		{
			string immutableEnumerableConstructingTypeName = type.GetImmutableEnumerableConstructingTypeName();
			if (immutableEnumerableConstructingTypeName != null)
			{
				return type.Assembly.GetType(immutableEnumerableConstructingTypeName);
			}
			return null;
		}

		[RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		[RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		private static Type GetImmutableDictionaryConstructingType(Type type)
		{
			string immutableDictionaryConstructingTypeName = type.GetImmutableDictionaryConstructingTypeName();
			if (immutableDictionaryConstructingTypeName != null)
			{
				return type.Assembly.GetType(immutableDictionaryConstructingTypeName);
			}
			return null;
		}

		public static bool IsNonGenericStackOrQueue(this Type type)
		{
			Type typeIfExists = GetTypeIfExists("System.Collections.Stack, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
			if ((object)typeIfExists != null && typeIfExists.IsAssignableFrom(type))
			{
				return true;
			}
			Type typeIfExists2 = GetTypeIfExists("System.Collections.Queue, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
			if ((object)typeIfExists2 != null && typeIfExists2.IsAssignableFrom(type))
			{
				return true;
			}
			return false;
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2057:TypeGetType", Justification = "This method exists to allow for 'weak references' to the Stack and Queue types. If those types are used in the app, they will be preserved by the app and Type.GetType will return them. If those types are not used in the app, we don't want to preserve them here.")]
		private static Type GetTypeIfExists(string name)
		{
			return Type.GetType(name, throwOnError: false);
		}
	}
	internal abstract class JsonCollectionConverter<TCollection, TElement> : JsonResumableConverter<TCollection>
	{
		internal override bool SupportsCreateObjectDelegate => true;

		internal override Type ElementType => typeof(TElement);

		private protected sealed override ConverterStrategy GetDefaultConverterStrategy()
		{
			return ConverterStrategy.Enumerable;
		}

		protected abstract void Add(in TElement value, ref ReadStack state);

		protected virtual void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			JsonPropertyInfo parentProperty = state.ParentProperty;
			if (parentProperty != null && parentProperty.TryGetPrePopulatedValue(ref state))
			{
				return;
			}
			JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
			if (jsonTypeInfo.CreateObject == null)
			{
				if (Type.IsAbstract || Type.IsInterface)
				{
					ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(Type, ref reader, ref state);
				}
				else
				{
					ThrowHelper.ThrowNotSupportedException_DeserializeNoConstructor(Type, ref reader, ref state);
				}
			}
			state.Current.ReturnValue = jsonTypeInfo.CreateObject();
		}

		protected virtual void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
		{
		}

		protected static JsonConverter<TElement> GetElementConverter(JsonTypeInfo elementTypeInfo)
		{
			return ((JsonTypeInfo<TElement>)elementTypeInfo).EffectiveConverter;
		}

		protected static JsonConverter<TElement> GetElementConverter(ref WriteStack state)
		{
			return (JsonConverter<TElement>)state.Current.JsonPropertyInfo.EffectiveConverter;
		}

		internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, [MaybeNullWhen(false)] out TCollection value)
		{
			JsonTypeInfo elementTypeInfo = state.Current.JsonTypeInfo.ElementTypeInfo;
			bool isPopulatedValue;
			if (!state.SupportContinuation && !state.Current.CanContainMetadata)
			{
				if (reader.TokenType != JsonTokenType.StartArray)
				{
					ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(Type);
				}
				CreateCollection(ref reader, ref state, options);
				state.Current.JsonPropertyInfo = elementTypeInfo.PropertyInfoForTypeInfo;
				JsonConverter<TElement> elementConverter = GetElementConverter(elementTypeInfo);
				if (elementConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
				{
					while (true)
					{
						reader.ReadWithVerify();
						if (reader.TokenType == JsonTokenType.EndArray)
						{
							break;
						}
						Add(elementConverter.Read(ref reader, elementConverter.Type, options), ref state);
					}
				}
				else
				{
					while (true)
					{
						reader.ReadWithVerify();
						if (reader.TokenType == JsonTokenType.EndArray)
						{
							break;
						}
						elementConverter.TryRead(ref reader, typeof(TElement), options, ref state, out var value2, out isPopulatedValue);
						Add(in value2, ref state);
					}
				}
			}
			else
			{
				JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
				if (state.Current.ObjectState == StackFrameObjectState.None)
				{
					if (reader.TokenType == JsonTokenType.StartArray)
					{
						state.Current.ObjectState = StackFrameObjectState.ReadMetadata;
					}
					else if (state.Current.CanContainMetadata)
					{
						if (reader.TokenType != JsonTokenType.StartObject)
						{
							ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(Type);
						}
						state.Current.ObjectState = StackFrameObjectState.StartToken;
					}
					else
					{
						ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(Type);
					}
				}
				if (state.Current.CanContainMetadata && (int)state.Current.ObjectState < 2)
				{
					if (!JsonSerializer.TryReadMetadata(this, jsonTypeInfo, ref reader, ref state))
					{
						value = default(TCollection);
						return false;
					}
					if (state.Current.MetadataPropertyNames == MetadataPropertyName.Ref)
					{
						value = JsonSerializer.ResolveReferenceId<TCollection>(ref state);
						return true;
					}
					state.Current.ObjectState = StackFrameObjectState.ReadMetadata;
				}
				if ((state.Current.MetadataPropertyNames & MetadataPropertyName.Type) != MetadataPropertyName.None && state.Current.PolymorphicSerializationState != PolymorphicSerializationState.PolymorphicReEntryStarted)
				{
					JsonConverter jsonConverter = ResolvePolymorphicConverter(jsonTypeInfo, ref state);
					if (jsonConverter != null)
					{
						object value3;
						bool flag = jsonConverter.OnTryReadAsObject(ref reader, jsonConverter.Type, options, ref state, out value3);
						value = (TCollection)value3;
						state.ExitPolymorphicConverter(flag);
						return flag;
					}
				}
				if ((int)state.Current.ObjectState < 4)
				{
					if (state.Current.CanContainMetadata)
					{
						JsonSerializer.ValidateMetadataForArrayConverter(this, ref reader, ref state);
					}
					CreateCollection(ref reader, ref state, options);
					if ((state.Current.MetadataPropertyNames & MetadataPropertyName.Id) != MetadataPropertyName.None)
					{
						state.ReferenceResolver.AddReference(state.ReferenceId, state.Current.ReturnValue);
						state.ReferenceId = null;
					}
					state.Current.ObjectState = StackFrameObjectState.CreatedObject;
				}
				if ((int)state.Current.ObjectState < 5)
				{
					JsonConverter<TElement> elementConverter2 = GetElementConverter(elementTypeInfo);
					state.Current.JsonPropertyInfo = elementTypeInfo.PropertyInfoForTypeInfo;
					while (true)
					{
						if ((int)state.Current.PropertyState < 3)
						{
							state.Current.PropertyState = StackFramePropertyState.ReadValue;
							if (!JsonConverter.SingleValueReadWithReadAhead(elementConverter2.RequiresReadAhead, ref reader, ref state))
							{
								value = default(TCollection);
								return false;
							}
						}
						if ((int)state.Current.PropertyState < 4)
						{
							if (reader.TokenType == JsonTokenType.EndArray)
							{
								break;
							}
							state.Current.PropertyState = StackFramePropertyState.ReadValueIsEnd;
						}
						if ((int)state.Current.PropertyState < 5)
						{
							if (!elementConverter2.TryRead(ref reader, typeof(TElement), options, ref state, out var value4, out isPopulatedValue))
							{
								value = default(TCollection);
								return false;
							}
							Add(in value4, ref state);
							state.Current.EndElement();
						}
					}
					state.Current.ObjectState = StackFrameObjectState.ReadElements;
				}
				if ((int)state.Current.ObjectState < 6)
				{
					state.Current.ObjectState = StackFrameObjectState.EndToken;
					if ((state.Current.MetadataPropertyNames & MetadataPropertyName.Values) != MetadataPropertyName.None && !reader.Read())
					{
						value = default(TCollection);
						return false;
					}
				}
				if ((int)state.Current.ObjectState < 7 && (state.Current.MetadataPropertyNames & MetadataPropertyName.Values) != MetadataPropertyName.None && reader.TokenType != JsonTokenType.EndObject)
				{
					ThrowHelper.ThrowJsonException_MetadataInvalidPropertyInArrayMetadata(ref state, typeToConvert, in reader);
				}
			}
			ConvertCollection(ref state, options);
			value = (TCollection)state.Current.ReturnValue;
			return true;
		}

		internal override bool OnTryWrite(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state)
		{
			bool flag;
			if (value == null)
			{
				writer.WriteNullValue();
				flag = true;
			}
			else
			{
				if (!state.Current.ProcessedStartToken)
				{
					state.Current.ProcessedStartToken = true;
					if (state.CurrentContainsMetadata && CanHaveMetadata)
					{
						state.Current.MetadataPropertyName = JsonSerializer.WriteMetadataForCollection(this, ref state, writer);
					}
					writer.WriteStartArray();
					state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
				}
				flag = OnWriteResume(writer, value, options, ref state);
				if (flag && !state.Current.ProcessedEndToken)
				{
					state.Current.ProcessedEndToken = true;
					writer.WriteEndArray();
					if (state.Current.MetadataPropertyName != MetadataPropertyName.None)
					{
						writer.WriteEndObject();
					}
				}
			}
			return flag;
		}

		protected abstract bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state);
	}
	internal abstract class JsonDictionaryConverter<TDictionary> : JsonResumableConverter<TDictionary>
	{
		internal override bool SupportsCreateObjectDelegate => true;

		private protected sealed override ConverterStrategy GetDefaultConverterStrategy()
		{
			return ConverterStrategy.Dictionary;
		}

		protected internal abstract bool OnWriteResume(Utf8JsonWriter writer, TDictionary dictionary, JsonSerializerOptions options, ref WriteStack state);
	}
	internal abstract class JsonDictionaryConverter<TDictionary, TKey, TValue> : JsonDictionaryConverter<TDictionary>
	{
		protected JsonConverter<TKey> _keyConverter;

		protected JsonConverter<TValue> _valueConverter;

		internal override Type ElementType => typeof(TValue);

		internal override Type KeyType => typeof(TKey);

		protected abstract void Add(TKey key, in TValue value, JsonSerializerOptions options, ref ReadStack state);

		protected virtual void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
		{
		}

		protected virtual void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state)
		{
			JsonPropertyInfo parentProperty = state.ParentProperty;
			if (parentProperty != null && parentProperty.TryGetPrePopulatedValue(ref state))
			{
				return;
			}
			JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
			if (jsonTypeInfo.CreateObject == null)
			{
				if (Type.IsAbstract || Type.IsInterface)
				{
					ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(Type, ref reader, ref state);
				}
				else
				{
					ThrowHelper.ThrowNotSupportedException_DeserializeNoConstructor(Type, ref reader, ref state);
				}
			}
			state.Current.ReturnValue = jsonTypeInfo.CreateObject();
		}

		protected static JsonConverter<T> GetConverter<T>(JsonTypeInfo typeInfo)
		{
			return ((JsonTypeInfo<T>)typeInfo).EffectiveConverter;
		}

		internal sealed override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, [MaybeNullWhen(false)] out TDictionary value)
		{
			JsonTypeInfo keyTypeInfo = state.Current.JsonTypeInfo.KeyTypeInfo;
			JsonTypeInfo elementTypeInfo = state.Current.JsonTypeInfo.ElementTypeInfo;
			bool isPopulatedValue;
			if (!state.SupportContinuation && !state.Current.CanContainMetadata)
			{
				if (reader.TokenType != JsonTokenType.StartObject)
				{
					ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(Type);
				}
				CreateCollection(ref reader, ref state);
				if (_keyConverter == null)
				{
					_keyConverter = GetConverter<TKey>(keyTypeInfo);
				}
				if (_valueConverter == null)
				{
					_valueConverter = GetConverter<TValue>(elementTypeInfo);
				}
				if (_valueConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
				{
					while (true)
					{
						reader.ReadWithVerify();
						if (reader.TokenType == JsonTokenType.EndObject)
						{
							break;
						}
						state.Current.JsonPropertyInfo = keyTypeInfo.PropertyInfoForTypeInfo;
						TKey key = ReadDictionaryKey(_keyConverter, ref reader, ref state, options);
						reader.ReadWithVerify();
						state.Current.JsonPropertyInfo = elementTypeInfo.PropertyInfoForTypeInfo;
						Add(key, _valueConverter.Read(ref reader, ElementType, options), options, ref state);
					}
				}
				else
				{
					while (true)
					{
						reader.ReadWithVerify();
						if (reader.TokenType == JsonTokenType.EndObject)
						{
							break;
						}
						state.Current.JsonPropertyInfo = keyTypeInfo.PropertyInfoForTypeInfo;
						TKey key2 = ReadDictionaryKey(_keyConverter, ref reader, ref state, options);
						reader.ReadWithVerify();
						state.Current.JsonPropertyInfo = elementTypeInfo.PropertyInfoForTypeInfo;
						_valueConverter.TryRead(ref reader, ElementType, options, ref state, out var value2, out isPopulatedValue);
						Add(key2, in value2, options, ref state);
					}
				}
			}
			else
			{
				JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
				if (state.Current.ObjectState == StackFrameObjectState.None)
				{
					if (reader.TokenType != JsonTokenType.StartObject)
					{
						ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(Type);
					}
					state.Current.ObjectState = StackFrameObjectState.StartToken;
				}
				if (state.Current.CanContainMetadata && (int)state.Current.ObjectState < 2)
				{
					if (!JsonSerializer.TryReadMetadata(this, jsonTypeInfo, ref reader, ref state))
					{
						value = default(TDictionary);
						return false;
					}
					if (state.Current.MetadataPropertyNames == MetadataPropertyName.Ref)
					{
						value = JsonSerializer.ResolveReferenceId<TDictionary>(ref state);
						return true;
					}
					state.Current.ObjectState = StackFrameObjectState.ReadMetadata;
				}
				if ((state.Current.MetadataPropertyNames & MetadataPropertyName.Type) != MetadataPropertyName.None && state.Current.PolymorphicSerializationState != PolymorphicSerializationState.PolymorphicReEntryStarted)
				{
					JsonConverter jsonConverter = ResolvePolymorphicConverter(jsonTypeInfo, ref state);
					if (jsonConverter != null)
					{
						object value3;
						bool flag = jsonConverter.OnTryReadAsObject(ref reader, jsonConverter.Type, options, ref state, out value3);
						value = (TDictionary)value3;
						state.ExitPolymorphicConverter(flag);
						return flag;
					}
				}
				if ((int)state.Current.ObjectState < 4)
				{
					if (state.Current.CanContainMetadata)
					{
						JsonSerializer.ValidateMetadataForObjectConverter(ref state);
					}
					CreateCollection(ref reader, ref state);
					if ((state.Current.MetadataPropertyNames & MetadataPropertyName.Id) != MetadataPropertyName.None)
					{
						state.ReferenceResolver.AddReference(state.ReferenceId, state.Current.ReturnValue);
						state.ReferenceId = null;
					}
					state.Current.ObjectState = StackFrameObjectState.CreatedObject;
				}
				if (_keyConverter == null)
				{
					_keyConverter = GetConverter<TKey>(keyTypeInfo);
				}
				if (_valueConverter == null)
				{
					_valueConverter = GetConverter<TValue>(elementTypeInfo);
				}
				while (true)
				{
					if (state.Current.PropertyState == StackFramePropertyState.None)
					{
						state.Current.PropertyState = StackFramePropertyState.ReadName;
						if (!reader.Read())
						{
							value = default(TDictionary);
							return false;
						}
					}
					TKey val;
					if ((int)state.Current.PropertyState < 2)
					{
						if (reader.TokenType == JsonTokenType.EndObject)
						{
							break;
						}
						state.Current.PropertyState = StackFramePropertyState.Name;
						if (state.Current.CanContainMetadata)
						{
							ReadOnlySpan<byte> span = reader.GetSpan();
							if (JsonSerializer.IsMetadataPropertyName(span, state.Current.BaseJsonTypeInfo.PolymorphicTypeResolver))
							{
								ThrowHelper.ThrowUnexpectedMetadataException(span, ref reader, ref state);
							}
						}
						state.Current.JsonPropertyInfo = keyTypeInfo.PropertyInfoForTypeInfo;
						val = ReadDictionaryKey(_keyConverter, ref reader, ref state, options);
					}
					else
					{
						val = (TKey)state.Current.DictionaryKey;
					}
					if ((int)state.Current.PropertyState < 3)
					{
						state.Current.PropertyState = StackFramePropertyState.ReadValue;
						if (!JsonConverter.SingleValueReadWithReadAhead(_valueConverter.RequiresReadAhead, ref reader, ref state))
						{
							state.Current.DictionaryKey = val;
							value = default(TDictionary);
							return false;
						}
					}
					if ((int)state.Current.PropertyState < 5)
					{
						state.Current.JsonPropertyInfo = elementTypeInfo.PropertyInfoForTypeInfo;
						if (!_valueConverter.TryRead(ref reader, typeof(TValue), options, ref state, out var value4, out isPopulatedValue))
						{
							state.Current.DictionaryKey = val;
							value = default(TDictionary);
							return false;
						}
						Add(val, in value4, options, ref state);
						state.Current.EndElement();
					}
				}
			}
			ConvertCollection(ref state, options);
			value = (TDictionary)state.Current.ReturnValue;
			return true;
			static TKey ReadDictionaryKey(JsonConverter<TKey> keyConverter, ref Utf8JsonReader reference, scoped ref ReadStack reference2, JsonSerializerOptions options2)
			{
				string text = reference.GetString();
				reference2.Current.JsonPropertyNameAsString = text;
				if (keyConverter.IsInternalConverter && keyConverter.Type == typeof(string))
				{
					return (TKey)(object)text;
				}
				return keyConverter.ReadAsPropertyNameCore(ref reference, keyConverter.Type, options2);
			}
		}

		internal sealed override bool OnTryWrite(Utf8JsonWriter writer, TDictionary dictionary, JsonSerializerOptions options, ref WriteStack state)
		{
			if (dictionary == null)
			{
				writer.WriteNullValue();
				return true;
			}
			if (!state.Current.ProcessedStartToken)
			{
				state.Current.ProcessedStartToken = true;
				writer.WriteStartObject();
				if (state.CurrentContainsMetadata && CanHaveMetadata)
				{
					JsonSerializer.WriteMetadataForObject(this, ref state, writer);
				}
				state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
			}
			bool flag = OnWriteResume(writer, dictionary, options, ref state);
			if (flag && !state.Current.ProcessedEndToken)
			{
				state.Current.ProcessedEndToken = true;
				writer.WriteEndObject();
			}
			return flag;
		}
	}
	internal abstract class JsonObjectConverter<T> : JsonResumableConverter<T>
	{
		internal override bool CanPopulate => true;

		internal sealed override Type ElementType => null;

		private protected sealed override ConverterStrategy GetDefaultConverterStrategy()
		{
			return ConverterStrategy.Object;
		}
	}
	internal sealed class IgnoreReferenceHandler : ReferenceHandler
	{
		public IgnoreReferenceHandler()
		{
			HandlingStrategy = ReferenceHandlingStrategy.IgnoreCycles;
		}

		public override ReferenceResolver CreateResolver()
		{
			return new IgnoreReferenceResolver();
		}
	}
	public abstract class JsonConverter
	{
		private ConverterStrategy _converterStrategy;

		public abstract Type? Type { get; }

		internal ConverterStrategy ConverterStrategy
		{
			get
			{
				return _converterStrategy;
			}
			init
			{
				CanUseDirectReadOrWrite = value == ConverterStrategy.Value && IsInternalConverter;
				RequiresReadAhead = value == ConverterStrategy.Value;
				_converterStrategy = value;
			}
		}

		internal virtual bool SupportsCreateObjectDelegate => false;

		internal virtual bool CanPopulate => false;

		internal bool CanUseDirectReadOrWrite { get; set; }

		internal virtual bool CanHaveMetadata => false;

		internal bool CanBePolymorphic { get; set; }

		internal bool RequiresReadAhead { get; set; }

		internal bool UsesDefaultHandleNull { get; private protected set; }

		internal bool HandleNullOnRead { get; private protected init; }

		internal bool HandleNullOnWrite { get; private protected init; }

		internal virtual JsonConverter? SourceConverterForCastingConverter => null;

		internal abstract Type? ElementType { get; }

		internal abstract Type? KeyType { get; }

		internal bool IsValueType { get; init; }

		internal bool IsInternalConverter { get; init; }

		internal bool IsInternalConverterForNumberType { get; init; }

		internal virtual bool ConstructorIsParameterized { get; }

		internal ConstructorInfo? ConstructorInfo { get; set; }

		internal JsonConverter()
		{
			IsInternalConverter = GetType().Assembly == typeof(JsonConverter).Assembly;
			ConverterStrategy = GetDefaultConverterStrategy();
		}

		public abstract bool CanConvert(Type typeToConvert);

		private protected abstract ConverterStrategy GetDefaultConverterStrategy();

		internal virtual void ReadElementAndSetProperty(object obj, string propertyName, ref Utf8JsonReader reader, JsonSerializerOptions options, scoped ref ReadStack state)
		{
			throw new InvalidOperationException();
		}

		internal virtual JsonTypeInfo CreateJsonTypeInfo(JsonSerializerOptions options)
		{
			throw new InvalidOperationException();
		}

		internal JsonConverter<TTarget> CreateCastingConverter<TTarget>()
		{
			if (this is JsonConverter<TTarget> result)
			{
				return result;
			}
			JsonSerializerOptions.CheckConverterNullabilityIsSameAsPropertyType(this, typeof(TTarget));
			return SourceConverterForCastingConverter?.CreateCastingConverter<TTarget>() ?? new CastingConverter<TTarget>(this);
		}

		internal static bool ShouldFlush(Utf8JsonWriter writer, ref WriteStack state)
		{
			if (state.FlushThreshold > 0)
			{
				return writer.BytesPending > state.FlushThreshold;
			}
			return false;
		}

		internal abstract object ReadAsObject(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options);

		internal abstract bool OnTryReadAsObject(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out object value);

		internal abstract bool TryReadAsObject(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out object value);

		internal abstract object ReadAsPropertyNameAsObject(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options);

		internal abstract object ReadAsPropertyNameCoreAsObject(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options);

		internal abstract object ReadNumberWithCustomHandlingAsObject(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options);

		internal abstract void WriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options);

		internal abstract bool OnTryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, ref WriteStack state);

		internal abstract bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, ref WriteStack state);

		internal abstract void WriteAsPropertyNameAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options);

		internal abstract void WriteAsPropertyNameCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);

		internal abstract void WriteNumberWithCustomHandlingAsObject(Utf8JsonWriter writer, object value, JsonNumberHandling handling);

		internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
		{
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		internal virtual void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
		{
		}

		internal JsonConverter ResolvePolymorphicConverter(JsonTypeInfo jsonTypeInfo, ref ReadStack state)
		{
			JsonConverter jsonConverter = null;
			switch (state.Current.PolymorphicSerializationState)
			{
			case PolymorphicSerializationState.None:
			{
				PolymorphicTypeResolver polymorphicTypeResolver = jsonTypeInfo.PolymorphicTypeResolver;
				if (polymorphicTypeResolver.TryGetDerivedJsonTypeInfo(state.PolymorphicTypeDiscriminator, out var jsonTypeInfo2))
				{
					jsonConverter = state.InitializePolymorphicReEntry(jsonTypeInfo2);
					if (!jsonConverter.CanHaveMetadata)
					{
						ThrowHelper.ThrowNotSupportedException_DerivedConverterDoesNotSupportMetadata(jsonTypeInfo2.Type);
					}
				}
				else
				{
					state.Current.PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryNotFound;
				}
				state.PolymorphicTypeDiscriminator = null;
				break;
			}
			case PolymorphicSerializationState.PolymorphicReEntrySuspended:
				jsonConverter = state.ResumePolymorphicReEntry();
				break;
			}
			return jsonConverter;
		}

		internal JsonConverter ResolvePolymorphicConverter(object value, JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options, ref WriteStack state)
		{
			JsonConverter jsonConverter = null;
			switch (state.Current.PolymorphicSerializationState)
			{
			case PolymorphicSerializationState.None:
			{
				Type type = value.GetType();
				if (CanBePolymorphic && type != Type)
				{
					jsonTypeInfo = state.Current.InitializePolymorphicReEntry(type, options);
					jsonConverter = jsonTypeInfo.Converter;
				}
				PolymorphicTypeResolver polymorphicTypeResolver = jsonTypeInfo.PolymorphicTypeResolver;
				if (polymorphicTypeResolver != null && polymorphicTypeResolver.TryGetDerivedJsonTypeInfo(type, out var jsonTypeInfo2, out var typeDiscriminator))
				{
					jsonConverter = state.Current.InitializePolymorphicReEntry(jsonTypeInfo2);
					if (typeDiscriminator != null)
					{
						if (!jsonConverter.CanHaveMetadata)
						{
							ThrowHelper.ThrowNotSupportedException_DerivedConverterDoesNotSupportMetadata(jsonTypeInfo2.Type);
						}
						state.PolymorphicTypeDiscriminator = typeDiscriminator;
						state.PolymorphicTypeResolver = polymorphicTypeResolver;
					}
				}
				if (jsonConverter == null)
				{
					state.Current.PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryNotFound;
				}
				break;
			}
			case PolymorphicSerializationState.PolymorphicReEntrySuspended:
				jsonConverter = state.Current.ResumePolymorphicReEntry();
				break;
			}
			return jsonConverter;
		}

		internal bool TryHandleSerializedObjectReference(Utf8JsonWriter writer, object value, JsonSerializerOptions options, JsonConverter polymorphicConverter, ref WriteStack state)
		{
			switch (options.ReferenceHandlingStrategy)
			{
			case ReferenceHandlingStrategy.IgnoreCycles:
			{
				ReferenceResolver referenceResolver = state.ReferenceResolver;
				if (referenceResolver.ContainsReferenceForCycleDetection(value))
				{
					writer.WriteNullValue();
					return true;
				}
				referenceResolver.PushReferenceForCycleDetection(value);
				state.Current.IsPushedReferenceForCycleDetection = state.CurrentDepth > 0;
				break;
			}
			case ReferenceHandlingStrategy.Preserve:
				if ((polymorphicConverter?.CanHaveMetadata ?? CanHaveMetadata) && JsonSerializer.TryGetReferenceForValue(value, ref state, writer))
				{
					return true;
				}
				break;
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool SingleValueReadWithReadAhead(bool requiresReadAhead, ref Utf8JsonReader reader, scoped ref ReadStack state)
		{
			if (!requiresReadAhead || !state.ReadAhead)
			{
				return reader.Read();
			}
			return DoSingleValueReadWithReadAhead(ref reader);
		}

		internal static bool DoSingleValueReadWithReadAhead(ref Utf8JsonReader reader)
		{
			Utf8JsonReader utf8JsonReader = reader;
			if (!reader.Read())
			{
				return false;
			}
			JsonTokenType tokenType = reader.TokenType;
			if ((tokenType == JsonTokenType.StartObject || tokenType == JsonTokenType.StartArray) ? true : false)
			{
				bool flag = reader.TrySkip();
				reader = utf8JsonReader;
				if (!flag)
				{
					return false;
				}
				reader.ReadWithVerify();
			}
			return true;
		}
	}
	public abstract class JsonConverterFactory : JsonConverter
	{
		internal sealed override Type? KeyType => null;

		internal sealed override Type? ElementType => null;

		public sealed override Type? Type => null;

		private protected override ConverterStrategy GetDefaultConverterStrategy()
		{
			return ConverterStrategy.None;
		}

		public abstract JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options);

		internal JsonConverter GetConverterInternal(Type typeToConvert, JsonSerializerOptions options)
		{
			JsonConverter jsonConverter = CreateConverter(typeToConvert, options);
			if (jsonConverter != null)
			{
				if (jsonConverter is JsonConverterFactory)
				{
					ThrowHelper.ThrowInvalidOperationException_SerializerConverterFactoryReturnsJsonConverterFactorty(GetType());
				}
			}
			else
			{
				ThrowHelper.ThrowInvalidOperationException_SerializerConverterFactoryReturnsNull(GetType());
			}
			return jsonConverter;
		}

		internal sealed override object ReadAsObject(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			throw new InvalidOperationException();
		}

		internal sealed override bool OnTryReadAsObject(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out object value)
		{
			throw new InvalidOperationException();
		}

		internal sealed override bool TryReadAsObject(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out object value)
		{
			throw new InvalidOperationException();
		}

		internal sealed override object ReadAsPropertyNameAsObject(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			throw new InvalidOperationException();
		}

		internal sealed override object ReadAsPropertyNameCoreAsObject(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			throw new InvalidOperationException();
		}

		internal sealed override object ReadNumberWithCustomHandlingAsObject(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
		{
			throw new InvalidOperationException();
		}

		internal sealed override void WriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options)
		{
			throw new InvalidOperationException();
		}

		internal sealed override bool OnTryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, ref WriteStack state)
		{
			throw new InvalidOperationException();
		}

		internal sealed override bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, ref WriteStack state)
		{
			throw new InvalidOperationException();
		}

		internal sealed override void WriteAsPropertyNameAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options)
		{
			throw new InvalidOperationException();
		}

		internal sealed override void WriteAsPropertyNameCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			throw new InvalidOperationException();
		}

		internal sealed override void WriteNumberWithCustomHandlingAsObject(Utf8JsonWriter writer, object value, JsonNumberHandling handling)
		{
			throw new InvalidOperationException();
		}
	}
	public abstract class JsonConverter<T> : JsonConverter
	{
		private JsonConverter<T> _fallbackConverterForPropertyNameSerialization;

		internal override Type? KeyType => null;

		internal override Type? ElementType => null;

		public virtual bool HandleNull
		{
			get
			{
				base.UsesDefaultHandleNull = true;
				return false;
			}
		}

		public sealed override Type Type { get; } = typeof(T);

		internal T ReadCore(ref Utf8JsonReader reader, JsonSerializerOptions options, ref ReadStack state)
		{
			try
			{
				if (!state.IsContinuation)
				{
					if (!JsonConverter.SingleValueReadWithReadAhead(base.RequiresReadAhead, ref reader, ref state))
					{
						if (state.SupportContinuation)
						{
							state.BytesConsumed += reader.BytesConsumed;
							if (state.Current.ReturnValue == null)
							{
								return default(T);
							}
							return (T)state.Current.ReturnValue;
						}
						state.BytesConsumed += reader.BytesConsumed;
						return default(T);
					}
				}
				else if (!JsonConverter.SingleValueReadWithReadAhead(requiresReadAhead: true, ref reader, ref state))
				{
					state.BytesConsumed += reader.BytesConsumed;
					return default(T);
				}
				if (TryRead(ref reader, state.Current.JsonTypeInfo.Type, options, ref state, out var value, out var _) && !reader.Read() && !reader.IsFinalBlock)
				{
					state.Current.ReturnValue = value;
				}
				state.BytesConsumed += reader.BytesConsumed;
				return value;
			}
			catch (JsonReaderException ex)
			{
				ThrowHelper.ReThrowWithPath(ref state, ex);
				return default(T);
			}
			catch (FormatException ex2) when (ex2.Source == "System.Text.Json.Rethrowable")
			{
				ThrowHelper.ReThrowWithPath(ref state, in reader, ex2);
				return default(T);
			}
			catch (InvalidOperationException ex3) when (ex3.Source == "System.Text.Json.Rethrowable")
			{
				ThrowHelper.ReThrowWithPath(ref state, in reader, ex3);
				return default(T);
			}
			catch (JsonException ex4) when (ex4.Path == null)
			{
				ThrowHelper.AddJsonExceptionInformation(ref state, in reader, ex4);
				throw;
			}
			catch (NotSupportedException ex5)
			{
				if (ex5.Message.Contains(" Path: "))
				{
					throw;
				}
				ThrowHelper.ThrowNotSupportedException(ref state, in reader, ex5);
				return default(T);
			}
		}

		internal bool WriteCore(Utf8JsonWriter writer, in T value, JsonSerializerOptions options, ref WriteStack state)
		{
			try
			{
				return TryWrite(writer, in value, options, ref state);
			}
			catch (InvalidOperationException ex) when (ex.Source == "System.Text.Json.Rethrowable")
			{
				ThrowHelper.ReThrowWithPath(ref state, ex);
				throw;
			}
			catch (JsonException ex2) when (ex2.Path == null)
			{
				ThrowHelper.AddJsonExceptionInformation(ref state, ex2);
				throw;
			}
			catch (NotSupportedException ex3)
			{
				if (ex3.Message.Contains(" Path: "))
				{
					throw;
				}
				ThrowHelper.ThrowNotSupportedException(ref state, ex3);
				return false;
			}
		}

		protected internal JsonConverter()
		{
			base.IsValueType = typeof(T).IsValueType;
			if (HandleNull)
			{
				base.HandleNullOnRead = true;
				base.HandleNullOnWrite = true;
			}
			else if (base.UsesDefaultHandleNull)
			{
				base.HandleNullOnRead = default(T) != null;
				base.HandleNullOnWrite = false;
			}
		}

		public override bool CanConvert(Type typeToConvert)
		{
			return typeToConvert == typeof(T);
		}

		private protected override ConverterStrategy GetDefaultConverterStrategy()
		{
			return ConverterStrategy.Value;
		}

		internal sealed override JsonTypeInfo CreateJsonTypeInfo(JsonSerializerOptions options)
		{
			return new JsonTypeInfo<T>(this, options);
		}

		internal sealed override void WriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options)
		{
			T value2 = JsonSerializer.UnboxOnWrite<T>(value);
			Write(writer, value2, options);
		}

		internal sealed override bool OnTryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, ref WriteStack state)
		{
			T value2 = JsonSerializer.UnboxOnWrite<T>(value);
			return OnTryWrite(writer, value2, options, ref state);
		}

		internal sealed override void WriteAsPropertyNameAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options)
		{
			T value2 = JsonSerializer.UnboxOnWrite<T>(value);
			WriteAsPropertyName(writer, value2, options);
		}

		internal sealed override void WriteAsPropertyNameCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			T value2 = JsonSerializer.UnboxOnWrite<T>(value);
			WriteAsPropertyNameCore(writer, value2, options, isWritingExtensionDataProperty);
		}

		internal sealed override void WriteNumberWithCustomHandlingAsObject(Utf8JsonWriter writer, object value, JsonNumberHandling handling)
		{
			T value2 = JsonSerializer.UnboxOnWrite<T>(value);
			WriteNumberWithCustomHandling(writer, value2, handling);
		}

		internal sealed override bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, ref WriteStack state)
		{
			return TryWrite(writer, JsonSerializer.UnboxOnWrite<T>(value), options, ref state);
		}

		internal virtual bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, ref WriteStack state)
		{
			Write(writer, value, options);
			return true;
		}

		internal virtual bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out T value)
		{
			value = Read(ref reader, typeToConvert, options);
			return true;
		}

		public abstract T? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options);

		internal bool TryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out T value, out bool isPopulatedValue)
		{
			if (reader.TokenType == JsonTokenType.Null && !base.HandleNullOnRead && !state.IsContinuation)
			{
				if (default(T) != null)
				{
					ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(Type);
				}
				value = default(T);
				isPopulatedValue = false;
				return true;
			}
			if (base.ConverterStrategy == ConverterStrategy.Value)
			{
				if (base.IsInternalConverter)
				{
					if (state.Current.NumberHandling.HasValue && base.IsInternalConverterForNumberType)
					{
						value = ReadNumberWithCustomHandling(ref reader, state.Current.NumberHandling.Value, options);
					}
					else
					{
						value = Read(ref reader, typeToConvert, options);
					}
				}
				else
				{
					JsonTokenType tokenType = reader.TokenType;
					int currentDepth = reader.CurrentDepth;
					long bytesConsumed = reader.BytesConsumed;
					if (state.Current.NumberHandling.HasValue && base.IsInternalConverterForNumberType)
					{
						value = ReadNumberWithCustomHandling(ref reader, state.Current.NumberHandling.Value, options);
					}
					else
					{
						value = Read(ref reader, typeToConvert, options);
					}
					VerifyRead(tokenType, currentDepth, bytesConsumed, isValueConverter: true, ref reader);
				}
				isPopulatedValue = false;
				return true;
			}
			bool isContinuation = state.IsContinuation;
			bool flag;
			if (base.CanBePolymorphic)
			{
				flag = OnTryRead(ref reader, typeToConvert, options, ref state, out value);
				isPopulatedValue = false;
				return true;
			}
			JsonPropertyInfo jsonPropertyInfo = state.Current.JsonPropertyInfo;
			object returnValue = state.Current.ReturnValue;
			state.Push();
			if (returnValue != null && jsonPropertyInfo != null && !jsonPropertyInfo.IsForTypeInfo)
			{
				state.Current.HasParentObject = true;
			}
			flag = OnTryRead(ref reader, typeToConvert, options, ref state, out value);
			isPopulatedValue = state.Current.IsPopulating;
			state.Pop(flag);
			return flag;
		}

		internal sealed override bool OnTryReadAsObject(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out object value)
		{
			T value2;
			bool result = OnTryRead(ref reader, typeToConvert, options, ref state, out value2);
			value = value2;
			return result;
		}

		internal sealed override bool TryReadAsObject(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out object value)
		{
			T value2;
			bool isPopulatedValue;
			bool result = TryRead(ref reader, typeToConvert, options, ref state, out value2, out isPopulatedValue);
			value = value2;
			return result;
		}

		internal sealed override object ReadAsObject(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			T val = Read(ref reader, typeToConvert, options);
			return val;
		}

		internal sealed override object ReadAsPropertyNameAsObject(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			T val = ReadAsPropertyName(ref reader, typeToConvert, options);
			return val;
		}

		internal sealed override object ReadAsPropertyNameCoreAsObject(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			T val = ReadAsPropertyNameCore(ref reader, typeToConvert, options);
			return val;
		}

		internal sealed override object ReadNumberWithCustomHandlingAsObject(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
		{
			T val = ReadNumberWithCustomHandling(ref reader, handling, options);
			return val;
		}

		private static bool IsNull(T value)
		{
			return value == null;
		}

		internal bool TryWrite(Utf8JsonWriter writer, in T value, JsonSerializerOptions options, ref WriteStack state)
		{
			if (writer.CurrentDepth >= options.EffectiveMaxDepth)
			{
				ThrowHelper.ThrowJsonException_SerializerCycleDetected(options.EffectiveMaxDepth);
			}
			if (default(T) == null && !base.HandleNullOnWrite && IsNull(value))
			{
				writer.WriteNullValue();
				return true;
			}
			if (base.ConverterStrategy == ConverterStrategy.Value)
			{
				int currentDepth = writer.CurrentDepth;
				if (state.Current.NumberHandling.HasValue && base.IsInternalConverterForNumberType)
				{
					WriteNumberWithCustomHandling(writer, value, state.Current.NumberHandling.Value);
				}
				else
				{
					Write(writer, value, options);
				}
				VerifyWrite(currentDepth, writer);
				return true;
			}
			bool isContinuation = state.IsContinuation;
			bool flag;
			if (!base.IsValueType && value != null && state.Current.PolymorphicSerializationState != PolymorphicSerializationState.PolymorphicReEntryStarted)
			{
				JsonTypeInfo jsonTypeInfo = state.PeekNestedJsonTypeInfo();
				JsonConverter jsonConverter = ((base.CanBePolymorphic || jsonTypeInfo.PolymorphicTypeResolver != null) ? ResolvePolymorphicConverter(value, jsonTypeInfo, options, ref state) : null);
				if (!isContinuation && options.ReferenceHandlingStrategy != ReferenceHandlingStrategy.None && TryHandleSerializedObjectReference(writer, value, options, jsonConverter, ref state))
				{
					return true;
				}
				if (jsonConverter != null)
				{
					flag = jsonConverter.TryWriteAsObject(writer, value, options, ref state);
					state.Current.ExitPolymorphicConverter(flag);
					if (flag && state.Current.IsPushedReferenceForCycleDetection)
					{
						state.ReferenceResolver.PopReferenceForCycleDetection();
						state.Current.IsPushedReferenceForCycleDetection = false;
					}
					return flag;
				}
			}
			state.Push();
			flag = OnTryWrite(writer, value, options, ref state);
			state.Pop(flag);
			if (flag && state.Current.IsPushedReferenceForCycleDetection)
			{
				state.ReferenceResolver.PopReferenceForCycleDetection();
				state.Current.IsPushedReferenceForCycleDetection = false;
			}
			return flag;
		}

		internal bool TryWriteDataExtensionProperty(Utf8JsonWriter writer, T value, JsonSerializerOptions options, ref WriteStack state)
		{
			if (!base.IsInternalConverter)
			{
				return TryWrite(writer, in value, options, ref state);
			}
			JsonDictionaryConverter<T> jsonDictionaryConverter = (this as JsonDictionaryConverter<T>) ?? ((this as JsonMetadataServicesConverter<T>)?.Converter as JsonDictionaryConverter<T>);
			if (jsonDictionaryConverter == null)
			{
				return TryWrite(writer, in value, options, ref state);
			}
			if (writer.CurrentDepth >= options.EffectiveMaxDepth)
			{
				ThrowHelper.ThrowJsonException_SerializerCycleDetected(options.EffectiveMaxDepth);
			}
			bool isContinuation = state.IsContinuation;
			state.Push();
			if (!isContinuation)
			{
				state.Current.OriginalDepth = writer.CurrentDepth;
			}
			state.Current.IsWritingExtensionDataProperty = true;
			state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
			bool flag = jsonDictionaryConverter.OnWriteResume(writer, value, options, ref state);
			if (flag)
			{
				VerifyWrite(state.Current.OriginalDepth, writer);
			}
			state.Pop(flag);
			return flag;
		}

		internal void VerifyRead(JsonTokenType tokenType, int depth, long bytesConsumed, bool isValueConverter, ref Utf8JsonReader reader)
		{
			switch (tokenType)
			{
			case JsonTokenType.StartArray:
				if (reader.TokenType != JsonTokenType.EndArray)
				{
					ThrowHelper.ThrowJsonException_SerializationConverterRead(this);
				}
				else if (depth != reader.CurrentDepth)
				{
					ThrowHelper.ThrowJsonException_SerializationConverterRead(this);
				}
				return;
			case JsonTokenType.StartObject:
				if (reader.TokenType != JsonTokenType.EndObject)
				{
					ThrowHelper.ThrowJsonException_SerializationConverterRead(this);
				}
				else if (depth != reader.CurrentDepth)
				{
					ThrowHelper.ThrowJsonException_SerializationConverterRead(this);
				}
				return;
			}
			if (isValueConverter)
			{
				if (reader.BytesConsumed != bytesConsumed)
				{
					ThrowHelper.ThrowJsonException_SerializationConverterRead(this);
				}
			}
			else if (!base.CanBePolymorphic && (!base.HandleNullOnRead || tokenType != JsonTokenType.Null))
			{
				ThrowHelper.ThrowJsonException_SerializationConverterRead(this);
			}
		}

		internal void VerifyWrite(int originalDepth, Utf8JsonWriter writer)
		{
			if (originalDepth != writer.CurrentDepth)
			{
				ThrowHelper.ThrowJsonException_SerializationConverterWrite(this);
			}
		}

		public abstract void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);

		public virtual T ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			JsonConverter<T> fallbackConverterForPropertyNameSerialization = GetFallbackConverterForPropertyNameSerialization(options);
			if (fallbackConverterForPropertyNameSerialization == null)
			{
				ThrowHelper.ThrowNotSupportedException_DictionaryKeyTypeNotSupported(Type, this);
			}
			return fallbackConverterForPropertyNameSerialization.ReadAsPropertyNameCore(ref reader, typeToConvert, options);
		}

		internal virtual T ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			long bytesConsumed = reader.BytesConsumed;
			T result = ReadAsPropertyName(ref reader, typeToConvert, options);
			if (reader.BytesConsumed != bytesConsumed)
			{
				ThrowHelper.ThrowJsonException_SerializationConverterRead(this);
			}
			return result;
		}

		public virtual void WriteAsPropertyName(Utf8JsonWriter writer, [DisallowNull] T value, JsonSerializerOptions options)
		{
			JsonConverter<T> fallbackConverterForPropertyNameSerialization = GetFallbackConverterForPropertyNameSerialization(options);
			if (fallbackConverterForPropertyNameSerialization == null)
			{
				ThrowHelper.ThrowNotSupportedException_DictionaryKeyTypeNotSupported(Type, this);
			}
			fallbackConverterForPropertyNameSerialization.WriteAsPropertyNameCore(writer, value, options, isWritingExtensionDataProperty: false);
		}

		internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, [DisallowNull] T value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			if (value == null)
			{
				ThrowHelper.ThrowArgumentNullException("value");
			}
			if (isWritingExtensionDataProperty)
			{
				writer.WritePropertyName((string)(object)value);
				return;
			}
			int currentDepth = writer.CurrentDepth;
			WriteAsPropertyName(writer, value, options);
			if (currentDepth != writer.CurrentDepth || writer.TokenType != JsonTokenType.PropertyName)
			{
				ThrowHelper.ThrowJsonException_SerializationConverterWrite(this);
			}
		}

		private JsonConverter<T> GetFallbackConverterForPropertyNameSerialization(JsonSerializerOptions options)
		{
			JsonConverter<T> jsonConverter = null;
			if (!base.IsInternalConverter && !(options.TypeInfoResolver is JsonSerializerContext))
			{
				jsonConverter = _fallbackConverterForPropertyNameSerialization;
				if (jsonConverter == null && DefaultJsonTypeInfoResolver.TryGetDefaultSimpleConverter(Type, out var converter))
				{
					jsonConverter = (_fallbackConverterForPropertyNameSerialization = (JsonConverter<T>)converter);
				}
			}
			return jsonConverter;
		}

		internal virtual T ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
		{
			throw new InvalidOperationException();
		}

		internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, T value, JsonNumberHandling handling)
		{
			throw new InvalidOperationException();
		}
	}
	internal abstract class JsonResumableConverter<T> : JsonConverter<T>
	{
		public sealed override bool HandleNull => false;

		public sealed override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			if (options == null)
			{
				ThrowHelper.ThrowArgumentNullException("options");
			}
			ReadStack state = default(ReadStack);
			JsonTypeInfo typeInfoInternal = options.GetTypeInfoInternal(typeToConvert, ensureConfigured: true, true);
			state.Initialize(typeInfoInternal);
			TryRead(ref reader, typeToConvert, options, ref state, out var value, out var _);
			return value;
		}

		public sealed override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
		{
			if (options == null)
			{
				ThrowHelper.ThrowArgumentNullException("options");
			}
			WriteStack state = default(WriteStack);
			JsonTypeInfo typeInfoInternal = options.GetTypeInfoInternal(typeof(T), ensureConfigured: true, true);
			state.Initialize(typeInfoInternal);
			try
			{
				TryWrite(writer, in value, options, ref state);
			}
			catch
			{
				state.DisposePendingDisposablesOnException();
				throw;
			}
		}
	}
	public class JsonStringEnumConverter<TEnum> : JsonConverterFactory where TEnum : struct, Enum
	{
		private readonly JsonNamingPolicy _namingPolicy;

		private readonly EnumConverterOptions _converterOptions;

		public JsonStringEnumConverter()
			: this((JsonNamingPolicy?)null, allowIntegerValues: true)
		{
		}

		public JsonStringEnumConverter(JsonNamingPolicy? namingPolicy = null, bool allowIntegerValues = true)
		{
			_namingPolicy = namingPolicy;
			_converterOptions = ((!allowIntegerValues) ? EnumConverterOptions.AllowStrings : (EnumConverterOptions.AllowStrings | EnumConverterOptions.AllowNumbers));
		}

		public sealed override bool CanConvert(Type typeToConvert)
		{
			return typeToConvert == typeof(TEnum);
		}

		public sealed override JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options)
		{
			if (typeToConvert != typeof(TEnum))
			{
				ThrowHelper.ThrowArgumentOutOfRangeException_JsonConverterFactory_TypeNotSupported(typeToConvert);
			}
			return new EnumConverter<TEnum>(_converterOptions, _namingPolicy, options);
		}
	}
	[RequiresDynamicCode("JsonStringEnumConverter cannot be statically analyzed and requires runtime code generation. Applications should use the generic JsonStringEnumConverter<TEnum> instead.")]
	public class JsonStringEnumConverter : JsonConverterFactory
	{
		private readonly JsonNamingPolicy _namingPolicy;

		private readonly EnumConverterOptions _converterOptions;

		public JsonStringEnumConverter()
			: this(null, allowIntegerValues: true)
		{
		}

		public JsonStringEnumConverter(JsonNamingPolicy? namingPolicy = null, bool allowIntegerValues = true)
		{
			_namingPolicy = namingPolicy;
			_converterOptions = ((!allowIntegerValues) ? EnumConverterOptions.AllowStrings : (EnumConverterOptions.AllowStrings | EnumConverterOptions.AllowNumbers));
		}

		public sealed override bool CanConvert(Type typeToConvert)
		{
			return typeToConvert.IsEnum;
		}

		public sealed override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
		{
			if (!typeToConvert.IsEnum)
			{
				ThrowHelper.ThrowArgumentOutOfRangeException_JsonConverterFactory_TypeNotSupported(typeToConvert);
			}
			return EnumConverterFactory.Create(typeToConvert, _converterOptions, _namingPolicy, options);
		}
	}
	internal sealed class PreserveReferenceHandler : ReferenceHandler
	{
		public override ReferenceResolver CreateResolver()
		{
			throw new InvalidOperationException();
		}

		internal override ReferenceResolver CreateResolver(bool writing)
		{
			return new PreserveReferenceResolver(writing);
		}
	}
	internal sealed class PreserveReferenceResolver : ReferenceResolver
	{
		private uint _referenceCount;

		private readonly Dictionary<string, object> _referenceIdToObjectMap;

		private readonly Dictionary<object, string> _objectToReferenceIdMap;

		public PreserveReferenceResolver(bool writing)
		{
			if (writing)
			{
				_objectToReferenceIdMap = new Dictionary<object, string>(ReferenceEqualityComparer.Instance);
			}
			else
			{
				_referenceIdToObjectMap = new Dictionary<string, object>();
			}
		}

		public override void AddReference(string referenceId, object value)
		{
			if (!JsonHelpers.TryAdd(_referenceIdToObjectMap, referenceId, value))
			{
				ThrowHelper.ThrowJsonException_MetadataDuplicateIdFound(referenceId);
			}
		}

		public override string GetReference(object value, out bool alreadyExists)
		{
			if (_objectToReferenceIdMap.TryGetValue(value, out var value2))
			{
				alreadyExists = true;
			}
			else
			{
				_referenceCount++;
				value2 = _referenceCount.ToString();
				_objectToReferenceIdMap.Add(value, value2);
				alreadyExists = false;
			}
			return value2;
		}

		public override object ResolveReference(string referenceId)
		{
			if (!_referenceIdToObjectMap.TryGetValue(referenceId, out var value))
			{
				ThrowHelper.ThrowJsonException_MetadataReferenceNotFound(referenceId);
			}
			return value;
		}
	}
	[StructLayout(LayoutKind.Auto)]
	internal struct ReadBufferState : IDisposable
	{
		private byte[] _buffer;

		private byte _offset;

		private int _count;

		private int _maxCount;

		private bool _isFirstBlock;

		private bool _isFinalBlock;

		public bool IsFinalBlock => _isFinalBlock;

		public ReadOnlySpan<byte> Bytes => MemoryExtensions.AsSpan(_buffer, _offset, _count);

		public ReadBufferState(int initialBufferSize)
		{
			_buffer = ArrayPool<byte>.Shared.Rent(Math.Max(initialBufferSize, JsonConstants.Utf8Bom.Length));
			_maxCount = (_count = (_offset = 0));
			_isFirstBlock = true;
			_isFinalBlock = false;
		}

		public readonly async ValueTask<ReadBufferState> ReadFromStreamAsync(Stream utf8Json, CancellationToken cancellationToken, bool fillBuffer = true)
		{
			ReadBufferState bufferState = this;
			do
			{
				int num = await utf8Json.ReadAsync(bufferState._buffer, bufferState._count, bufferState._buffer.Length - bufferState._count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (num == 0)
				{
					bufferState._isFinalBlock = true;
					break;
				}
				bufferState._count += num;
			}
			while (fillBuffer && bufferState._count < bufferState._buffer.Length);
			bufferState.ProcessReadBytes();
			return bufferState;
		}

		public void ReadFromStream(Stream utf8Json)
		{
			do
			{
				int num = utf8Json.Read(_buffer, _count, _buffer.Length - _count);
				if (num == 0)
				{
					_isFinalBlock = true;
					break;
				}
				_count += num;
			}
			while (_count < _buffer.Length);
			ProcessReadBytes();
		}

		public void AdvanceBuffer(int bytesConsumed)
		{
			_count -= bytesConsumed;
			if (!_isFinalBlock)
			{
				if ((uint)_count > (uint)_buffer.Length / 2u)
				{
					byte[] buffer = _buffer;
					int maxCount = _maxCount;
					byte[] array = ArrayPool<byte>.Shared.Rent((_buffer.Length < 1073741823) ? (_buffer.Length * 2) : int.MaxValue);
					Buffer.BlockCopy(buffer, _offset + bytesConsumed, array, 0, _count);
					_buffer = array;
					_maxCount = _count;
					new Span<byte>(buffer, 0, maxCount).Clear();
					ArrayPool<byte>.Shared.Return(buffer);
				}
				else if (_count != 0)
				{
					Buffer.BlockCopy(_buffer, _offset + bytesConsumed, _buffer, 0, _count);
				}
			}
			_offset = 0;
		}

		private void ProcessReadBytes()
		{
			if (_count > _maxCount)
			{
				_maxCount = _count;
			}
			if (_isFirstBlock)
			{
				_isFirstBlock = false;
				if (MemoryExtensions.AsSpan(_buffer, 0, _count).StartsWith(JsonConstants.Utf8Bom))
				{
					_offset = (byte)JsonConstants.Utf8Bom.Length;
					_count -= JsonConstants.Utf8Bom.Length;
				}
			}
		}

		public void Dispose()
		{
			new Span<byte>(_buffer, 0, _maxCount).Clear();
			byte[] buffer = _buffer;
			_buffer = null;
			ArrayPool<byte>.Shared.Return(buffer);
		}
	}
	public abstract class ReferenceHandler
	{
		internal ReferenceHandlingStrategy HandlingStrategy = ReferenceHandlingStrategy.Preserve;

		public static ReferenceHandler Preserve { get; } = new PreserveReferenceHandler();

		public static ReferenceHandler IgnoreCycles { get; } = new IgnoreReferenceHandler();

		public abstract ReferenceResolver CreateResolver();

		internal virtual ReferenceResolver CreateResolver(bool writing)
		{
			return CreateResolver();
		}
	}
	public sealed class ReferenceHandler<T> : ReferenceHandler where T : ReferenceResolver, new()
	{
		public override ReferenceResolver CreateResolver()
		{
			return new T();
		}
	}
	internal enum ReferenceHandlingStrategy
	{
		None,
		Preserve,
		IgnoreCycles
	}
	public abstract class ReferenceResolver
	{
		public abstract void AddReference(string referenceId, object value);

		public abstract string GetReference(object value, out bool alreadyExists);

		public abstract object ResolveReference(string referenceId);

		internal virtual void PopReferenceForCycleDetection()
		{
			throw new InvalidOperationException();
		}

		internal virtual void PushReferenceForCycleDetection(object value)
		{
			throw new InvalidOperationException();
		}

		internal virtual bool ContainsReferenceForCycleDetection(object value)
		{
			throw new InvalidOperationException();
		}
	}
}
namespace System.Text.Json.Serialization.Metadata
{
	public class DefaultJsonTypeInfoResolver : IJsonTypeInfoResolver, IBuiltInJsonTypeInfoResolver
	{
		private sealed class ModifierCollection : ConfigurationList<Action<JsonTypeInfo>>
		{
			private readonly DefaultJsonTypeInfoResolver _resolver;

			public override bool IsReadOnly => !_resolver._mutable;

			public ModifierCollection(DefaultJsonTypeInfoResolver resolver)
				: base((IEnumerable<Action<JsonTypeInfo>>)null)
			{
				_resolver = resolver;
			}

			protected override void OnCollectionModifying()
			{
				if (!_resolver._mutable)
				{
					ThrowHelper.ThrowInvalidOperationException_DefaultTypeInfoResolverImmutable();
				}
			}
		}

		private static Dictionary<Type, JsonConverter> s_defaultSimpleConverters;

		private static JsonConverterFactory[] s_defaultFactoryConverters;

		private static MemberAccessor s_memberAccessor;

		private bool _mutable;

		private ModifierCollection _modifiers;

		private static DefaultJsonTypeInfoResolver s_defaultInstance;

		internal static MemberAccessor MemberAccessor
		{
			[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
			get
			{
				return s_memberAccessor ?? (s_memberAccessor = new ReflectionMemberAccessor());
			}
		}

		public IList<Action<JsonTypeInfo>> Modifiers => _modifiers ?? (_modifiers = new ModifierCollection(this));

		internal static bool IsDefaultInstanceRooted => s_defaultInstance != null;

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private static JsonConverterFactory[] GetDefaultFactoryConverters()
		{
			return new JsonConverterFactory[9]
			{
				new UnsupportedTypeConverterFactory(),
				new NullableConverterFactory(),
				new EnumConverterFactory(),
				new JsonNodeConverterFactory(),
				new FSharpTypeConverterFactory(),
				new MemoryConverterFactory(),
				new IAsyncEnumerableConverterFactory(),
				new IEnumerableConverterFactory(),
				new ObjectConverterFactory()
			};
		}

		private static Dictionary<Type, JsonConverter> GetDefaultSimpleConverters()
		{
			Dictionary<Type, JsonConverter> converters = new Dictionary<Type, JsonConverter>(31);
			Add(JsonMetadataServices.BooleanConverter);
			Add(JsonMetadataServices.ByteConverter);
			Add(JsonMetadataServices.ByteArrayConverter);
			Add(JsonMetadataServices.CharConverter);
			Add(JsonMetadataServices.DateTimeConverter);
			Add(JsonMetadataServices.DateTimeOffsetConverter);
			Add(JsonMetadataServices.DoubleConverter);
			Add(JsonMetadataServices.DecimalConverter);
			Add(JsonMetadataServices.GuidConverter);
			Add(JsonMetadataServices.Int16Converter);
			Add(JsonMetadataServices.Int32Converter);
			Add(JsonMetadataServices.Int64Converter);
			Add(JsonMetadataServices.JsonElementConverter);
			Add(JsonMetadataServices.JsonDocumentConverter);
			Add(JsonMetadataServices.MemoryByteConverter);
			Add(JsonMetadataServices.ReadOnlyMemoryByteConverter);
			Add(JsonMetadataServices.ObjectConverter);
			Add(JsonMetadataServices.SByteConverter);
			Add(JsonMetadataServices.SingleConverter);
			Add(JsonMetadataServices.StringConverter);
			Add(JsonMetadataServices.TimeSpanConverter);
			Add(JsonMetadataServices.UInt16Converter);
			Add(JsonMetadataServices.UInt32Converter);
			Add(JsonMetadataServices.UInt64Converter);
			Add(JsonMetadataServices.UriConverter);
			Add(JsonMetadataServices.VersionConverter);
			return converters;
			void Add(JsonConverter converter)
			{
				converters.Add(converter.Type, converter);
			}
		}

		private static JsonConverter GetBuiltInConverter(Type typeToConvert)
		{
			if (s_defaultSimpleConverters.TryGetValue(typeToConvert, out var value))
			{
				return value;
			}
			JsonConverterFactory[] array = s_defaultFactoryConverters;
			foreach (JsonConverterFactory jsonConverterFactory in array)
			{
				if (jsonConverterFactory.CanConvert(typeToConvert))
				{
					return jsonConverterFactory;
				}
			}
			return value;
		}

		internal static bool TryGetDefaultSimpleConverter(Type typeToConvert, [NotNullWhen(true)] out JsonConverter converter)
		{
			if (s_defaultSimpleConverters == null)
			{
				converter = null;
				return false;
			}
			return s_defaultSimpleConverters.TryGetValue(typeToConvert, out converter);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private static JsonConverter GetCustomConverterForMember(Type typeToConvert, MemberInfo memberInfo, JsonSerializerOptions options)
		{
			JsonConverterAttribute uniqueCustomAttribute = memberInfo.GetUniqueCustomAttribute<JsonConverterAttribute>(inherit: false);
			if (uniqueCustomAttribute != null)
			{
				return GetConverterFromAttribute(uniqueCustomAttribute, typeToConvert, memberInfo, options);
			}
			return null;
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		internal static JsonConverter GetConverterForType(Type typeToConvert, JsonSerializerOptions options, bool resolveJsonConverterAttribute = true)
		{
			RootDefaultInstance();
			JsonConverter jsonConverter = options.GetConverterFromList(typeToConvert);
			if (resolveJsonConverterAttribute && jsonConverter == null)
			{
				JsonConverterAttribute uniqueCustomAttribute = typeToConvert.GetUniqueCustomAttribute<JsonConverterAttribute>(inherit: false);
				if (uniqueCustomAttribute != null)
				{
					jsonConverter = GetConverterFromAttribute(uniqueCustomAttribute, typeToConvert, null, options);
				}
			}
			if (jsonConverter == null)
			{
				jsonConverter = GetBuiltInConverter(typeToConvert);
			}
			jsonConverter = options.ExpandConverterFactory(jsonConverter, typeToConvert);
			if (!jsonConverter.Type.IsInSubtypeRelationshipWith(typeToConvert))
			{
				ThrowHelper.ThrowInvalidOperationException_SerializationConverterNotCompatible(jsonConverter.GetType(), typeToConvert);
			}
			JsonSerializerOptions.CheckConverterNullabilityIsSameAsPropertyType(jsonConverter, typeToConvert);
			return jsonConverter;
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private static JsonConverter GetConverterFromAttribute(JsonConverterAttribute converterAttribute, Type typeToConvert, MemberInfo memberInfo, JsonSerializerOptions options)
		{
			Type type = memberInfo?.DeclaringType ?? typeToConvert;
			Type converterType = converterAttribute.ConverterType;
			JsonConverter jsonConverter;
			if (converterType == null)
			{
				jsonConverter = converterAttribute.CreateConverter(typeToConvert);
				if (jsonConverter == null)
				{
					ThrowHelper.ThrowInvalidOperationException_SerializationConverterOnAttributeNotCompatible(type, memberInfo, typeToConvert);
				}
			}
			else
			{
				ConstructorInfo constructor = converterType.GetConstructor(Type.EmptyTypes);
				if (!typeof(JsonConverter).IsAssignableFrom(converterType) || constructor == null || !constructor.IsPublic)
				{
					ThrowHelper.ThrowInvalidOperationException_SerializationConverterOnAttributeInvalid(type, memberInfo);
				}
				jsonConverter = (JsonConverter)Activator.CreateInstance(converterType);
			}
			if (!jsonConverter.CanConvert(typeToConvert))
			{
				Type underlyingType = Nullable.GetUnderlyingType(typeToConvert);
				if (underlyingType != null && jsonConverter.CanConvert(underlyingType))
				{
					if (jsonConverter is JsonConverterFactory jsonConverterFactory)
					{
						jsonConverter = jsonConverterFactory.GetConverterInternal(underlyingType, options);
					}
					return NullableConverterFactory.CreateValueConverter(underlyingType, jsonConverter);
				}
				ThrowHelper.ThrowInvalidOperationException_SerializationConverterOnAttributeNotCompatible(type, memberInfo, typeToConvert);
			}
			return jsonConverter;
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private static JsonTypeInfo CreateTypeInfoCore(Type type, JsonConverter converter, JsonSerializerOptions options)
		{
			JsonTypeInfo jsonTypeInfo = JsonTypeInfo.CreateJsonTypeInfo(type, converter, options);
			JsonNumberHandling? numberHandlingForType = GetNumberHandlingForType(jsonTypeInfo.Type);
			if (numberHandlingForType.HasValue)
			{
				JsonNumberHandling valueOrDefault = numberHandlingForType.GetValueOrDefault();
				jsonTypeInfo.NumberHandling = valueOrDefault;
			}
			JsonObjectCreationHandling? objectCreationHandlingForType = GetObjectCreationHandlingForType(jsonTypeInfo.Type);
			if (objectCreationHandlingForType.HasValue)
			{
				JsonObjectCreationHandling valueOrDefault2 = objectCreationHandlingForType.GetValueOrDefault();
				jsonTypeInfo.PreferredPropertyObjectCreationHandling = valueOrDefault2;
			}
			JsonUnmappedMemberHandling? unmappedMemberHandling = GetUnmappedMemberHandling(jsonTypeInfo.Type);
			if (unmappedMemberHandling.HasValue)
			{
				JsonUnmappedMemberHandling valueOrDefault3 = unmappedMemberHandling.GetValueOrDefault();
				jsonTypeInfo.UnmappedMemberHandling = valueOrDefault3;
			}
			jsonTypeInfo.PopulatePolymorphismMetadata();
			jsonTypeInfo.MapInterfaceTypesToCallbacks();
			Func<object> func = DetermineCreateObjectDelegate(type, converter);
			jsonTypeInfo.SetCreateObjectIfCompatible(func);
			jsonTypeInfo.CreateObjectForExtensionDataProperty = func;
			if (jsonTypeInfo.Kind == JsonTypeInfoKind.Object)
			{
				PopulateProperties(jsonTypeInfo);
				if (converter.ConstructorIsParameterized)
				{
					PopulateParameterInfoValues(jsonTypeInfo);
				}
			}
			converter.ConfigureJsonTypeInfo(jsonTypeInfo, options);
			converter.ConfigureJsonTypeInfoUsingReflection(jsonTypeInfo, options);
			return jsonTypeInfo;
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private static void PopulateProperties(JsonTypeInfo typeInfo)
		{
			bool constructorHasSetsRequiredMembersAttribute = typeInfo.Converter.ConstructorInfo?.HasSetsRequiredMembersAttribute() ?? false;
			JsonTypeInfo.PropertyHierarchyResolutionState state = new JsonTypeInfo.PropertyHierarchyResolutionState(typeInfo.Options);
			Type[] sortedTypeHierarchy = typeInfo.Type.GetSortedTypeHierarchy();
			foreach (Type type in sortedTypeHierarchy)
			{
				if (type == JsonTypeInfo.ObjectType || type == typeof(ValueType))
				{
					break;
				}
				AddMembersDeclaredBySuperType(typeInfo, type, constructorHasSetsRequiredMembersAttribute, ref state);
			}
			if (state.IsPropertyOrderSpecified)
			{
				typeInfo.PropertyList.SortProperties();
			}
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private static void AddMembersDeclaredBySuperType(JsonTypeInfo typeInfo, Type currentType, bool constructorHasSetsRequiredMembersAttribute, ref JsonTypeInfo.PropertyHierarchyResolutionState state)
		{
			bool shouldCheckForRequiredKeyword = !constructorHasSetsRequiredMembersAttribute && currentType.HasRequiredMemberAttribute();
			PropertyInfo[] properties = currentType.GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (propertyInfo.GetIndexParameters().Length == 0 && !PropertyIsOverriddenAndIgnored(propertyInfo, state.IgnoredProperties))
				{
					bool flag = propertyInfo.GetCustomAttribute<JsonIncludeAttribute>(inherit: false) != null;
					MethodInfo getMethod = propertyInfo.GetMethod;
					if (((object)getMethod != null && getMethod.IsPublic) || (propertyInfo.SetMethod?.IsPublic ?? false) || flag)
					{
						AddMember(typeInfo, propertyInfo.PropertyType, propertyInfo, shouldCheckForRequiredKeyword, flag, ref state);
					}
				}
			}
			FieldInfo[] fields = currentType.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (FieldInfo fieldInfo in fields)
			{
				bool flag2 = fieldInfo.GetCustomAttribute<JsonIncludeAttribute>(inherit: false) != null;
				if (flag2 || (fieldInfo.IsPublic && typeInfo.Options.IncludeFields))
				{
					AddMember(typeInfo, fieldInfo.FieldType, fieldInfo, shouldCheckForRequiredKeyword, flag2, ref state);
				}
			}
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private static void AddMember(JsonTypeInfo typeInfo, Type typeToConvert, MemberInfo memberInfo, bool shouldCheckForRequiredKeyword, bool hasJsonIncludeAttribute, ref JsonTypeInfo.PropertyHierarchyResolutionState state)
		{
			JsonPropertyInfo jsonPropertyInfo = CreatePropertyInfo(typeInfo, typeToConvert, memberInfo, typeInfo.Options, shouldCheckForRequiredKeyword, hasJsonIncludeAttribute);
			if (jsonPropertyInfo != null)
			{
				typeInfo.PropertyList.AddPropertyWithConflictResolution(jsonPropertyInfo, ref state);
			}
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private static JsonPropertyInfo CreatePropertyInfo(JsonTypeInfo typeInfo, Type typeToConvert, MemberInfo memberInfo, JsonSerializerOptions options, bool shouldCheckForRequiredKeyword, bool hasJsonIncludeAttribute)
		{
			JsonIgnoreCondition? jsonIgnoreCondition = memberInfo.GetCustomAttribute<JsonIgnoreAttribute>(inherit: false)?.Condition;
			if (JsonTypeInfo.IsInvalidForSerialization(typeToConvert))
			{
				if (jsonIgnoreCondition == JsonIgnoreCondition.Always)
				{
					return null;
				}
				ThrowHelper.ThrowInvalidOperationException_CannotSerializeInvalidType(typeToConvert, memberInfo.DeclaringType, memberInfo);
			}
			JsonConverter customConverterForMember;
			try
			{
				customConverterForMember = GetCustomConverterForMember(typeToConvert, memberInfo, options);
			}
			catch (InvalidOperationException) when (jsonIgnoreCondition == JsonIgnoreCondition.Always)
			{
				return null;
			}
			JsonPropertyInfo jsonPropertyInfo = typeInfo.CreatePropertyUsingReflection(typeToConvert, memberInfo.DeclaringType);
			PopulatePropertyInfo(jsonPropertyInfo, memberInfo, customConverterForMember, jsonIgnoreCondition, shouldCheckForRequiredKeyword, hasJsonIncludeAttribute);
			return jsonPropertyInfo;
		}

		private static JsonNumberHandling? GetNumberHandlingForType(Type type)
		{
			return type.GetUniqueCustomAttribute<JsonNumberHandlingAttribute>(inherit: false)?.Handling;
		}

		private static JsonObjectCreationHandling? GetObjectCreationHandlingForType(Type type)
		{
			return type.GetUniqueCustomAttribute<JsonObjectCreationHandlingAttribute>(inherit: false)?.Handling;
		}

		private static JsonUnmappedMemberHandling? GetUnmappedMemberHandling(Type type)
		{
			return type.GetUniqueCustomAttribute<JsonUnmappedMemberHandlingAttribute>(inherit: false)?.UnmappedMemberHandling;
		}

		private static bool PropertyIsOverriddenAndIgnored(PropertyInfo propertyInfo, Dictionary<string, JsonPropertyInfo> ignoredMembers)
		{
			if (propertyInfo.IsVirtual() && ignoredMembers != null && ignoredMembers.TryGetValue(propertyInfo.Name, out var value) && value.IsVirtual)
			{
				return propertyInfo.PropertyType == value.PropertyType;
			}
			return false;
		}

		private static void PopulateParameterInfoValues(JsonTypeInfo typeInfo)
		{
			ParameterInfo[] parameters = typeInfo.Converter.ConstructorInfo.GetParameters();
			int num = parameters.Length;
			JsonParameterInfoValues[] array = new JsonParameterInfoValues[num];
			for (int i = 0; i < num; i++)
			{
				ParameterInfo parameterInfo = parameters[i];
				if (string.IsNullOrEmpty(parameterInfo.Name))
				{
					ThrowHelper.ThrowNotSupportedException_ConstructorContainsNullParameterNames(typeInfo.Converter.ConstructorInfo.DeclaringType);
				}
				JsonParameterInfoValues jsonParameterInfoValues = new JsonParameterInfoValues
				{
					Name = parameterInfo.Name,
					ParameterType = parameterInfo.ParameterType,
					Position = parameterInfo.Position,
					HasDefaultValue = parameterInfo.HasDefaultValue,
					DefaultValue = parameterInfo.GetDefaultValue()
				};
				array[i] = jsonParameterInfoValues;
			}
			typeInfo.ParameterInfoValues = array;
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private static void PopulatePropertyInfo(JsonPropertyInfo jsonPropertyInfo, MemberInfo memberInfo, JsonConverter customConverter, JsonIgnoreCondition? ignoreCondition, bool shouldCheckForRequiredKeyword, bool hasJsonIncludeAttribute)
		{
			ICustomAttributeProvider customAttributeProvider = (jsonPropertyInfo.AttributeProvider = memberInfo);
			ICustomAttributeProvider customAttributeProvider3 = customAttributeProvider;
			if (!(customAttributeProvider3 is PropertyInfo propertyInfo))
			{
				if (customAttributeProvider3 is FieldInfo fieldInfo)
				{
					jsonPropertyInfo.MemberName = fieldInfo.Name;
					jsonPropertyInfo.MemberType = MemberTypes.Field;
				}
			}
			else
			{
				jsonPropertyInfo.MemberName = propertyInfo.Name;
				jsonPropertyInfo.IsVirtual = propertyInfo.IsVirtual();
				jsonPropertyInfo.MemberType = MemberTypes.Property;
			}
			jsonPropertyInfo.CustomConverter = customConverter;
			DeterminePropertyPolicies(jsonPropertyInfo, memberInfo);
			DeterminePropertyName(jsonPropertyInfo, memberInfo);
			DeterminePropertyIsRequired(jsonPropertyInfo, memberInfo, shouldCheckForRequiredKeyword);
			if (ignoreCondition != JsonIgnoreCondition.Always)
			{
				jsonPropertyInfo.DetermineReflectionPropertyAccessors(memberInfo, hasJsonIncludeAttribute);
			}
			jsonPropertyInfo.IgnoreCondition = ignoreCondition;
			jsonPropertyInfo.IsExtensionData = memberInfo.GetCustomAttribute<JsonExtensionDataAttribute>(inherit: false) != null;
		}

		private static void DeterminePropertyPolicies(JsonPropertyInfo propertyInfo, MemberInfo memberInfo)
		{
			propertyInfo.Order = memberInfo.GetCustomAttribute<JsonPropertyOrderAttribute>(inherit: false)?.Order ?? 0;
			propertyInfo.NumberHandling = memberInfo.GetCustomAttribute<JsonNumberHandlingAttribute>(inherit: false)?.Handling;
			propertyInfo.ObjectCreationHandling = memberInfo.GetCustomAttribute<JsonObjectCreationHandlingAttribute>(inherit: false)?.Handling;
		}

		private static void DeterminePropertyName(JsonPropertyInfo propertyInfo, MemberInfo memberInfo)
		{
			JsonPropertyNameAttribute customAttribute = memberInfo.GetCustomAttribute<JsonPropertyNameAttribute>(inherit: false);
			string text = ((customAttribute != null) ? customAttribute.Name : ((propertyInfo.Options.PropertyNamingPolicy == null) ? memberInfo.Name : propertyInfo.Options.PropertyNamingPolicy.ConvertName(memberInfo.Name)));
			if (text == null)
			{
				ThrowHelper.ThrowInvalidOperationException_SerializerPropertyNameNull(propertyInfo);
			}
			propertyInfo.Name = text;
		}

		private static void DeterminePropertyIsRequired(JsonPropertyInfo propertyInfo, MemberInfo memberInfo, bool shouldCheckForRequiredKeyword)
		{
			propertyInfo.IsRequired = memberInfo.GetCustomAttribute<JsonRequiredAttribute>(inherit: false) != null || (shouldCheckForRequiredKeyword && memberInfo.HasRequiredMemberAttribute());
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		internal static void DeterminePropertyAccessors<T>(JsonPropertyInfo<T> jsonPropertyInfo, MemberInfo memberInfo, bool useNonPublicAccessors)
		{
			if (!(memberInfo is PropertyInfo { GetMethod: var getMethod } propertyInfo))
			{
				if (memberInfo is FieldInfo fieldInfo)
				{
					jsonPropertyInfo.Get = MemberAccessor.CreateFieldGetter<T>(fieldInfo);
					if (!fieldInfo.IsInitOnly)
					{
						jsonPropertyInfo.Set = MemberAccessor.CreateFieldSetter<T>(fieldInfo);
					}
				}
				return;
			}
			if (getMethod != null && (getMethod.IsPublic || useNonPublicAccessors))
			{
				jsonPropertyInfo.Get = MemberAccessor.CreatePropertyGetter<T>(propertyInfo);
			}
			MethodInfo setMethod = propertyInfo.SetMethod;
			if (setMethod != null && (setMethod.IsPublic || useNonPublicAccessors))
			{
				jsonPropertyInfo.Set = MemberAccessor.CreatePropertySetter<T>(propertyInfo);
			}
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private static Func<object> DetermineCreateObjectDelegate(Type type, JsonConverter converter)
		{
			ConstructorInfo constructorInfo = null;
			if (converter.ConstructorInfo != null && !converter.ConstructorIsParameterized)
			{
				constructorInfo = converter.ConstructorInfo;
			}
			if ((object)constructorInfo == null)
			{
				constructorInfo = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public, null, Type.EmptyTypes, null);
			}
			return MemberAccessor.CreateParameterlessConstructor(type, constructorInfo);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public DefaultJsonTypeInfoResolver()
			: this(mutable: true)
		{
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private DefaultJsonTypeInfoResolver(bool mutable)
		{
			_mutable = mutable;
			if (s_defaultFactoryConverters == null)
			{
				s_defaultFactoryConverters = GetDefaultFactoryConverters();
			}
			if (s_defaultSimpleConverters == null)
			{
				s_defaultSimpleConverters = GetDefaultSimpleConverters();
			}
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The ctor is marked RequiresUnreferencedCode.")]
		[UnconditionalSuppressMessage("AotAnalysis", "IL3050:RequiresDynamicCode", Justification = "The ctor is marked RequiresDynamicCode.")]
		public virtual JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options)
		{
			if (type == null)
			{
				ThrowHelper.ThrowArgumentNullException("type");
			}
			if (options == null)
			{
				ThrowHelper.ThrowArgumentNullException("options");
			}
			_mutable = false;
			JsonTypeInfo.ValidateType(type);
			JsonTypeInfo jsonTypeInfo = CreateJsonTypeInfo(type, options);
			jsonTypeInfo.OriginatingResolver = this;
			jsonTypeInfo.IsCustomized = false;
			if (_modifiers != null)
			{
				foreach (Action<JsonTypeInfo> modifier in _modifiers)
				{
					modifier(jsonTypeInfo);
				}
			}
			return jsonTypeInfo;
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		private static JsonTypeInfo CreateJsonTypeInfo(Type type, JsonSerializerOptions options)
		{
			JsonConverter converterForType = GetConverterForType(type, options);
			return CreateTypeInfoCore(type, converterForType, options);
		}

		bool IBuiltInJsonTypeInfoResolver.IsCompatibleWithOptions(JsonSerializerOptions _)
		{
			ModifierCollection modifiers = _modifiers;
			if ((modifiers == null || modifiers.Count == 0) ? true : false)
			{
				return GetType() == typeof(DefaultJsonTypeInfoResolver);
			}
			return false;
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		internal static DefaultJsonTypeInfoResolver RootDefaultInstance()
		{
			DefaultJsonTypeInfoResolver defaultJsonTypeInfoResolver = s_defaultInstance;
			if (defaultJsonTypeInfoResolver != null)
			{
				return defaultJsonTypeInfoResolver;
			}
			DefaultJsonTypeInfoResolver defaultJsonTypeInfoResolver2 = new DefaultJsonTypeInfoResolver(mutable: false);
			DefaultJsonTypeInfoResolver defaultJsonTypeInfoResolver3 = Interlocked.CompareExchange(ref s_defaultInstance, defaultJsonTypeInfoResolver2, null);
			return defaultJsonTypeInfoResolver3 ?? defaultJsonTypeInfoResolver2;
		}
	}
	public interface IJsonTypeInfoResolver
	{
		JsonTypeInfo? GetTypeInfo(Type type, JsonSerializerOptions options);
	}
	public readonly struct JsonDerivedType
	{
		public Type DerivedType { get; }

		public object? TypeDiscriminator { get; }

		public JsonDerivedType(Type derivedType)
		{
			DerivedType = derivedType;
			TypeDiscriminator = null;
		}

		public JsonDerivedType(Type derivedType, int typeDiscriminator)
		{
			DerivedType = derivedType;
			TypeDiscriminator = typeDiscriminator;
		}

		public JsonDerivedType(Type derivedType, string typeDiscriminator)
		{
			DerivedType = derivedType;
			TypeDiscriminator = typeDiscriminator;
		}

		internal JsonDerivedType(Type derivedType, object typeDiscriminator)
		{
			DerivedType = derivedType;
			TypeDiscriminator = typeDiscriminator;
		}

		internal void Deconstruct(out Type derivedType, out object typeDiscriminator)
		{
			derivedType = DerivedType;
			typeDiscriminator = TypeDiscriminator;
		}
	}
	public class JsonPolymorphismOptions
	{
		private sealed class DerivedTypeList : ConfigurationList<JsonDerivedType>
		{
			private readonly JsonPolymorphismOptions _parent;

			public override bool IsReadOnly => _parent.DeclaringTypeInfo?.IsReadOnly ?? false;

			public DerivedTypeList(JsonPolymorphismOptions parent)
				: base((IEnumerable<JsonDerivedType>)null)
			{
				_parent = parent;
			}

			protected override void OnCollectionModifying()
			{
				_parent.DeclaringTypeInfo?.VerifyMutable();
			}
		}

		private DerivedTypeList _derivedTypes;

		private bool _ignoreUnrecognizedTypeDiscriminators;

		private JsonUnknownDerivedTypeHandling _unknownDerivedTypeHandling;

		private string _typeDiscriminatorPropertyName;

		public IList<JsonDerivedType> DerivedTypes => _derivedTypes ?? (_derivedTypes = new DerivedTypeList(this));

		public bool IgnoreUnrecognizedTypeDiscriminators
		{
			get
			{
				return _ignoreUnrecognizedTypeDiscriminators;
			}
			set
			{
				VerifyMutable();
				_ignoreUnrecognizedTypeDiscriminators = value;
			}
		}

		public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling
		{
			get
			{
				return _unknownDerivedTypeHandling;
			}
			set
			{
				VerifyMutable();
				_unknownDerivedTypeHandling = value;
			}
		}

		public string TypeDiscriminatorPropertyName
		{
			get
			{
				return _typeDiscriminatorPropertyName ?? "$type";
			}
			[param: AllowNull]
			set
			{
				VerifyMutable();
				_typeDiscriminatorPropertyName = value;
			}
		}

		internal JsonTypeInfo? DeclaringTypeInfo { get; set; }

		private void VerifyMutable()
		{
			DeclaringTypeInfo?.VerifyMutable();
		}

		internal static JsonPolymorphismOptions CreateFromAttributeDeclarations(Type baseType)
		{
			JsonPolymorphismOptions jsonPolymorphismOptions = null;
			JsonPolymorphicAttribute customAttribute = baseType.GetCustomAttribute<JsonPolymorphicAttribute>(inherit: false);
			if (customAttribute != null)
			{
				jsonPolymorphismOptions = new JsonPolymorphismOptions
				{
					IgnoreUnrecognizedTypeDiscriminators = customAttribute.IgnoreUnrecognizedTypeDiscriminators,
					UnknownDerivedTypeHandling = customAttribute.UnknownDerivedTypeHandling,
					TypeDiscriminatorPropertyName = customAttribute.TypeDiscriminatorPropertyName
				};
			}
			foreach (JsonDerivedTypeAttribute customAttribute2 in baseType.GetCustomAttributes<JsonDerivedTypeAttribute>(inherit: false))
			{
				(jsonPolymorphismOptions ?? (jsonPolymorphismOptions = new JsonPolymorphismOptions())).DerivedTypes.Add(new JsonDerivedType(customAttribute2.DerivedType, customAttribute2.TypeDiscriminator));
			}
			return jsonPolymorphismOptions;
		}
	}
	public sealed class JsonTypeInfo<T> : JsonTypeInfo
	{
		internal JsonTypeInfo _asyncEnumerableQueueTypeInfo;

		private volatile int _canUseSerializeHandlerInStreamingState;

		private const int MinSerializationsSampleSize = 10;

		private volatile int _serializationCount;

		private Action<Utf8JsonWriter, T> _serialize;

		private Func<T> _typedCreateObject;

		private bool CanUseSerializeHandlerInStreaming => _canUseSerializeHandlerInStreamingState == 1;

		internal JsonConverter<T> EffectiveConverter { get; }

		public new Func<T>? CreateObject
		{
			get
			{
				return _typedCreateObject;
			}
			set
			{
				SetCreateObject(value);
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public Action<Utf8JsonWriter, T>? SerializeHandler
		{
			get
			{
				return _serialize;
			}
			internal set
			{
				_serialize = value;
				base.HasSerializeHandler = value != null;
			}
		}

		internal T Deserialize(ref Utf8JsonReader reader, ref ReadStack state)
		{
			return EffectiveConverter.ReadCore(ref reader, base.Options, ref state);
		}

		internal async ValueTask<T> DeserializeAsync(Stream utf8Json, CancellationToken cancellationToken)
		{
			JsonSerializerOptions options = base.Options;
			ReadBufferState bufferState = new ReadBufferState(options.DefaultBufferSize);
			ReadStack readStack = default(ReadStack);
			readStack.Initialize(this, supportContinuation: true);
			JsonReaderState jsonReaderState = new JsonReaderState(options.GetReaderOptions());
			try
			{
				T result;
				do
				{
					bufferState = await bufferState.ReadFromStreamAsync(utf8Json, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					result = ContinueDeserialize(ref bufferState, ref jsonReaderState, ref readStack);
				}
				while (!bufferState.IsFinalBlock);
				return result;
			}
			finally
			{
				bufferState.Dispose();
			}
		}

		internal T Deserialize(Stream utf8Json)
		{
			JsonSerializerOptions options = base.Options;
			ReadBufferState bufferState = new ReadBufferState(options.DefaultBufferSize);
			ReadStack readStack = default(ReadStack);
			readStack.Initialize(this, supportContinuation: true);
			JsonReaderState jsonReaderState = new JsonReaderState(options.GetReaderOptions());
			try
			{
				T result;
				do
				{
					bufferState.ReadFromStream(utf8Json);
					result = ContinueDeserialize(ref bufferState, ref jsonReaderState, ref readStack);
				}
				while (!bufferState.IsFinalBlock);
				return result;
			}
			finally
			{
				bufferState.Dispose();
			}
		}

		internal sealed override object DeserializeAsObject(ref Utf8JsonReader reader, ref ReadStack state)
		{
			return Deserialize(ref reader, ref state);
		}

		internal sealed override async ValueTask<object> DeserializeAsObjectAsync(Stream utf8Json, CancellationToken cancellationToken)
		{
			return await DeserializeAsync(utf8Json, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal sealed override object DeserializeAsObject(Stream utf8Json)
		{
			return Deserialize(utf8Json);
		}

		internal T ContinueDeserialize(ref ReadBufferState bufferState, ref JsonReaderState jsonReaderState, ref ReadStack readStack)
		{
			Utf8JsonReader reader = new Utf8JsonReader(bufferState.Bytes, bufferState.IsFinalBlock, jsonReaderState);
			readStack.ReadAhead = !bufferState.IsFinalBlock;
			readStack.BytesConsumed = 0L;
			T result = EffectiveConverter.ReadCore(ref reader, base.Options, ref readStack);
			bufferState.AdvanceBuffer((int)readStack.BytesConsumed);
			jsonReaderState = reader.CurrentState;
			return result;
		}

		internal void Serialize(Utf8JsonWriter writer, in T rootValue, object rootValueBoxed = null)
		{
			if (base.CanUseSerializeHandler)
			{
				SerializeHandler(writer, rootValue);
				writer.Flush();
				return;
			}
			if (base.Converter.CanBePolymorphic && rootValue != null && base.Options.TryGetPolymorphicTypeInfoForRootType(rootValue, out var polymorphicTypeInfo))
			{
				polymorphicTypeInfo.SerializeAsObject(writer, rootValue);
				return;
			}
			WriteStack state = default(WriteStack);
			state.Initialize(this, rootValueBoxed);
			bool flag = EffectiveConverter.WriteCore(writer, in rootValue, base.Options, ref state);
			writer.Flush();
		}

		internal async Task SerializeAsync(Stream utf8Json, T rootValue, CancellationToken cancellationToken, object rootValueBoxed = null)
		{
			if (CanUseSerializeHandlerInStreaming)
			{
				using (PooledByteBufferWriter bufferWriter = new PooledByteBufferWriter(base.Options.DefaultBufferSize))
				{
					Utf8JsonWriter utf8JsonWriter = Utf8JsonWriterCache.RentWriter(base.Options, bufferWriter);
					try
					{
						SerializeHandler(utf8JsonWriter, rootValue);
						utf8JsonWriter.Flush();
					}
					finally
					{
						OnRootLevelAsyncSerializationCompleted(utf8JsonWriter.BytesCommitted + utf8JsonWriter.BytesPending);
						Utf8JsonWriterCache.ReturnWriter(utf8JsonWriter);
					}
					await bufferWriter.WriteToStreamAsync(utf8Json, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				return;
			}
			if (base.Converter.CanBePolymorphic && rootValue != null && base.Options.TryGetPolymorphicTypeInfoForRootType(rootValue, out var polymorphicTypeInfo))
			{
				await polymorphicTypeInfo.SerializeAsObjectAsync(utf8Json, rootValue, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				return;
			}
			WriteStack state = default(WriteStack);
			state.Initialize(this, rootValueBoxed, supportContinuation: true, supportAsync: true);
			state.CancellationToken = cancellationToken;
			using PooledByteBufferWriter bufferWriter = new PooledByteBufferWriter(base.Options.DefaultBufferSize);
			using Utf8JsonWriter writer = new Utf8JsonWriter(bufferWriter, base.Options.GetWriterOptions());
			try
			{
				bool isFinalBlock = default(bool);
				do
				{
					state.FlushThreshold = (int)((float)bufferWriter.Capacity * 0.9f);
					object obj = null;
					try
					{
						isFinalBlock = EffectiveConverter.WriteCore(writer, in rootValue, base.Options, ref state);
						writer.Flush();
						if (state.SuppressFlush)
						{
							state.SuppressFlush = false;
						}
						else
						{
							await bufferWriter.WriteToStreamAsync(utf8Json, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
							bufferWriter.Clear();
						}
					}
					catch (object obj2)
					{
						obj = obj2;
					}
					if (state.PendingTask != null)
					{
						try
						{
							await state.PendingTask.ConfigureAwait(continueOnCapturedContext: false);
						}
						catch
						{
						}
					}
					List<IAsyncDisposable> completedAsyncDisposables = state.CompletedAsyncDisposables;
					if (completedAsyncDisposables != null && completedAsyncDisposables.Count > 0)
					{
						await state.DisposeCompletedAsyncDisposables().ConfigureAwait(continueOnCapturedContext: false);
					}
					object obj4 = obj;
					if (obj4 != null)
					{
						if (!(obj4 is Exception source))
						{
							throw obj4;
						}
						ExceptionDispatchInfo.Capture(source).Throw();
					}
				}
				while (!isFinalBlock);
			}
			catch (object obj5)
			{
				await state.DisposePendingDisposablesOnExceptionAsync().ConfigureAwait(continueOnCapturedContext: false);
				if (!(obj5 is Exception source2))
				{
					throw obj5;
				}
				ExceptionDispatchInfo.Capture(source2).Throw();
			}
			if (base.CanUseSerializeHandler)
			{
				OnRootLevelAsyncSerializationCompleted(writer.BytesCommitted);
			}
		}

		internal void Serialize(Stream utf8Json, in T rootValue, object rootValueBoxed = null)
		{
			if (CanUseSerializeHandlerInStreaming)
			{
				PooledByteBufferWriter bufferWriter;
				Utf8JsonWriter utf8JsonWriter = Utf8JsonWriterCache.RentWriterAndBuffer(base.Options, out bufferWriter);
				try
				{
					SerializeHandler(utf8JsonWriter, rootValue);
					utf8JsonWriter.Flush();
					bufferWriter.WriteToStream(utf8Json);
					return;
				}
				finally
				{
					OnRootLevelAsyncSerializationCompleted(utf8JsonWriter.BytesCommitted + utf8JsonWriter.BytesPending);
					Utf8JsonWriterCache.ReturnWriterAndBuffer(utf8JsonWriter, bufferWriter);
				}
			}
			if (base.Converter.CanBePolymorphic && rootValue != null && base.Options.TryGetPolymorphicTypeInfoForRootType(rootValue, out var polymorphicTypeInfo))
			{
				polymorphicTypeInfo.SerializeAsObject(utf8Json, rootValue);
				return;
			}
			WriteStack state = default(WriteStack);
			state.Initialize(this, rootValueBoxed, supportContinuation: true);
			using PooledByteBufferWriter pooledByteBufferWriter = new PooledByteBufferWriter(base.Options.DefaultBufferSize);
			using Utf8JsonWriter utf8JsonWriter2 = new Utf8JsonWriter(pooledByteBufferWriter, base.Options.GetWriterOptions());
			bool flag;
			do
			{
				state.FlushThreshold = (int)((float)pooledByteBufferWriter.Capacity * 0.9f);
				flag = EffectiveConverter.WriteCore(utf8JsonWriter2, in rootValue, base.Options, ref state);
				utf8JsonWriter2.Flush();
				pooledByteBufferWriter.WriteToStream(utf8Json);
				pooledByteBufferWriter.Clear();
			}
			while (!flag);
			if (base.CanUseSerializeHandler)
			{
				OnRootLevelAsyncSerializationCompleted(utf8JsonWriter2.BytesCommitted);
			}
		}

		internal sealed override void SerializeAsObject(Utf8JsonWriter writer, object rootValue)
		{
			Serialize(writer, JsonSerializer.UnboxOnWrite<T>(rootValue), rootValue);
		}

		internal sealed override Task SerializeAsObjectAsync(Stream utf8Json, object rootValue, CancellationToken cancellationToken)
		{
			return SerializeAsync(utf8Json, JsonSerializer.UnboxOnWrite<T>(rootValue), cancellationToken, rootValue);
		}

		internal sealed override void SerializeAsObject(Stream utf8Json, object rootValue)
		{
			Serialize(utf8Json, JsonSerializer.UnboxOnWrite<T>(rootValue), rootValue);
		}

		private void OnRootLevelAsyncSerializationCompleted(long serializationSize)
		{
			if (_canUseSerializeHandlerInStreamingState != 2)
			{
				if ((ulong)serializationSize > (ulong)(base.Options.DefaultBufferSize / 2))
				{
					_canUseSerializeHandlerInStreamingState = 2;
				}
				else if ((uint)_serializationCount < 10u && Interlocked.Increment(ref _serializationCount) == 10)
				{
					Interlocked.CompareExchange(ref _canUseSerializeHandlerInStreamingState, 1, 0);
				}
			}
		}

		internal JsonTypeInfo(JsonConverter converter, JsonSerializerOptions options)
			: base(typeof(T), converter, options)
		{
			EffectiveConverter = converter.CreateCastingConverter<T>();
		}

		private protected override void SetCreateObject(Delegate createObject)
		{
			VerifyMutable();
			if (base.Kind == JsonTypeInfoKind.None)
			{
				ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(base.Kind);
			}
			if (!base.Converter.SupportsCreateObjectDelegate)
			{
				ThrowHelper.ThrowInvalidOperationException_CreateObjectConverterNotCompatible(base.Type);
			}
			Func<object> untypedCreateObject;
			Func<T> typedCreateObject;
			if ((object)createObject == null)
			{
				untypedCreateObject = null;
				typedCreateObject = null;
			}
			else
			{
				Func<T> typedDelegate = createObject as Func<T>;
				if (typedDelegate != null)
				{
					typedCreateObject = typedDelegate;
					untypedCreateObject = ((createObject is Func<object> func) ? func : ((Func<object>)(() => typedDelegate())));
				}
				else
				{
					untypedCreateObject = (Func<object>)createObject;
					typedCreateObject = () => (T)untypedCreateObject();
				}
			}
			_createObject = untypedCreateObject;
			_typedCreateObject = typedCreateObject;
		}

		private protected override JsonPropertyInfo CreatePropertyInfoForTypeInfo()
		{
			return new JsonPropertyInfo<T>(typeof(T), this, base.Options)
			{
				JsonTypeInfo = this,
				IsForTypeInfo = true
			};
		}

		private protected override JsonPropertyInfo CreateJsonPropertyInfo(JsonTypeInfo declaringTypeInfo, Type declaringType, JsonSerializerOptions options)
		{
			return new JsonPropertyInfo<T>(declaringType ?? declaringTypeInfo.Type, declaringTypeInfo, options)
			{
				JsonTypeInfo = this
			};
		}
	}
	public static class JsonTypeInfoResolver
	{
		internal static IJsonTypeInfoResolver Empty { get; } = new EmptyJsonTypeInfoResolver();

		public static IJsonTypeInfoResolver Combine(params IJsonTypeInfoResolver?[] resolvers)
		{
			if (resolvers == null)
			{
				ThrowHelper.ThrowArgumentNullException("resolvers");
			}
			JsonTypeInfoResolverChain jsonTypeInfoResolverChain = new JsonTypeInfoResolverChain();
			foreach (IJsonTypeInfoResolver resolver in resolvers)
			{
				jsonTypeInfoResolverChain.AddFlattened(resolver);
			}
			if (jsonTypeInfoResolverChain.Count != 1)
			{
				return jsonTypeInfoResolverChain;
			}
			return jsonTypeInfoResolverChain[0];
		}

		public static IJsonTypeInfoResolver WithAddedModifier(this IJsonTypeInfoResolver resolver, Action<JsonTypeInfo> modifier)
		{
			if (resolver == null)
			{
				ThrowHelper.ThrowArgumentNullException("resolver");
			}
			if (modifier == null)
			{
				ThrowHelper.ThrowArgumentNullException("modifier");
			}
			if (!(resolver is JsonTypeInfoResolverWithAddedModifiers jsonTypeInfoResolverWithAddedModifiers))
			{
				return new JsonTypeInfoResolverWithAddedModifiers(resolver, new Action<JsonTypeInfo>[1] { modifier });
			}
			return jsonTypeInfoResolverWithAddedModifiers.WithAddedModifier(modifier);
		}

		internal static bool IsCompatibleWithOptions(this IJsonTypeInfoResolver resolver, JsonSerializerOptions options)
		{
			if (resolver is IBuiltInJsonTypeInfoResolver builtInJsonTypeInfoResolver)
			{
				return builtInJsonTypeInfoResolver.IsCompatibleWithOptions(options);
			}
			return false;
		}
	}
	internal sealed class EmptyJsonTypeInfoResolver : IJsonTypeInfoResolver, IBuiltInJsonTypeInfoResolver
	{
		public JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options)
		{
			return null;
		}

		public bool IsCompatibleWithOptions(JsonSerializerOptions _)
		{
			return true;
		}
	}
	internal interface IBuiltInJsonTypeInfoResolver
	{
		bool IsCompatibleWithOptions(JsonSerializerOptions options);
	}
	public enum JsonTypeInfoKind
	{
		None,
		Object,
		Enumerable,
		Dictionary
	}
	internal class JsonTypeInfoResolverChain : ConfigurationList<IJsonTypeInfoResolver>, IJsonTypeInfoResolver, IBuiltInJsonTypeInfoResolver
	{
		public override bool IsReadOnly => true;

		public JsonTypeInfoResolverChain()
			: base((IEnumerable<IJsonTypeInfoResolver>)null)
		{
		}

		protected override void OnCollectionModifying()
		{
			ThrowHelper.ThrowInvalidOperationException_TypeInfoResolverChainImmutable();
		}

		public JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options)
		{
			foreach (IJsonTypeInfoResolver item in _list)
			{
				JsonTypeInfo typeInfo = item.GetTypeInfo(type, options);
				if (typeInfo != null)
				{
					return typeInfo;
				}
			}
			return null;
		}

		internal void AddFlattened(IJsonTypeInfoResolver resolver)
		{
			if (resolver != null && !(resolver is EmptyJsonTypeInfoResolver))
			{
				if (resolver is JsonTypeInfoResolverChain collection)
				{
					_list.AddRange(collection);
				}
				else
				{
					_list.Add(resolver);
				}
			}
		}

		bool IBuiltInJsonTypeInfoResolver.IsCompatibleWithOptions(JsonSerializerOptions options)
		{
			foreach (IJsonTypeInfoResolver item in _list)
			{
				if (!item.IsCompatibleWithOptions(options))
				{
					return false;
				}
			}
			return true;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder("[");
			foreach (IJsonTypeInfoResolver item in _list)
			{
				stringBuilder.Append(item);
				stringBuilder.Append(", ");
			}
			if (_list.Count > 0)
			{
				stringBuilder.Length -= 2;
			}
			stringBuilder.Append(']');
			return stringBuilder.ToString();
		}
	}
	internal sealed class JsonTypeInfoResolverWithAddedModifiers : IJsonTypeInfoResolver
	{
		private readonly IJsonTypeInfoResolver _source;

		private readonly Action<JsonTypeInfo>[] _modifiers;

		public JsonTypeInfoResolverWithAddedModifiers(IJsonTypeInfoResolver source, Action<JsonTypeInfo>[] modifiers)
		{
			_source = source;
			_modifiers = modifiers;
		}

		public JsonTypeInfoResolverWithAddedModifiers WithAddedModifier(Action<JsonTypeInfo> modifier)
		{
			Action<JsonTypeInfo>[] array = new Action<JsonTypeInfo>[_modifiers.Length + 1];
			_modifiers.CopyTo(array, 0);
			array[_modifiers.Length] = modifier;
			return new JsonTypeInfoResolverWithAddedModifiers(_source, array);
		}

		public JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options)
		{
			JsonTypeInfo typeInfo = _source.GetTypeInfo(type, options);
			if (typeInfo != null)
			{
				Action<JsonTypeInfo>[] modifiers = _modifiers;
				foreach (Action<JsonTypeInfo> action in modifiers)
				{
					action(typeInfo);
				}
			}
			return typeInfo;
		}
	}
	internal sealed class FSharpCoreReflectionProxy
	{
		public enum FSharpKind
		{
			Unrecognized,
			Option,
			ValueOption,
			List,
			Set,
			Map,
			Record,
			Union
		}

		public delegate TResult StructGetter<TStruct, TResult>(ref TStruct @this) where TStruct : struct;

		private enum SourceConstructFlags
		{
			None = 0,
			SumType = 1,
			RecordType = 2,
			ObjectType = 3,
			Field = 4,
			Exception = 5,
			Closure = 6,
			Module = 7,
			UnionCase = 8,
			Value = 9,
			KindMask = 31,
			NonPublicRepresentation = 32
		}

		public const string FSharpCoreUnreferencedCodeMessage = "Uses Reflection to access FSharp.Core components at runtime.";

		private static FSharpCoreReflectionProxy s_singletonInstance;

		private const string CompilationMappingAttributeTypeName = "Microsoft.FSharp.Core.CompilationMappingAttribute";

		private readonly Type _compilationMappingAttributeType;

		private readonly MethodInfo _sourceConstructFlagsGetter;

		private readonly Type _fsharpOptionType;

		private readonly Type _fsharpValueOptionType;

		private readonly Type _fsharpListType;

		private readonly Type _fsharpSetType;

		private readonly Type _fsharpMapType;

		private readonly MethodInfo _fsharpListCtor;

		private readonly MethodInfo _fsharpSetCtor;

		private readonly MethodInfo _fsharpMapCtor;

		public static FSharpCoreReflectionProxy Instance => s_singletonInstance;

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
		public static bool IsFSharpType(Type type)
		{
			if (s_singletonInstance == null)
			{
				Assembly fSharpCoreAssembly = GetFSharpCoreAssembly(type);
				if ((object)fSharpCoreAssembly != null)
				{
					if (s_singletonInstance == null)
					{
						s_singletonInstance = new FSharpCoreReflectionProxy(fSharpCoreAssembly);
					}
					return true;
				}
				return false;
			}
			return s_singletonInstance.GetFSharpCompilationMappingAttribute(type) != null;
		}

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
		private FSharpCoreReflectionProxy(Assembly fsharpCoreAssembly)
		{
			Type type = fsharpCoreAssembly.GetType("Microsoft.FSharp.Core.CompilationMappingAttribute");
			_sourceConstructFlagsGetter = type.GetMethod("get_SourceConstructFlags", BindingFlags.Instance | BindingFlags.Public);
			_compilationMappingAttributeType = type;
			_fsharpOptionType = fsharpCoreAssembly.GetType("Microsoft.FSharp.Core.FSharpOption`1");
			_fsharpValueOptionType = fsharpCoreAssembly.GetType("Microsoft.FSharp.Core.FSharpValueOption`1");
			_fsharpListType = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.FSharpList`1");
			_fsharpSetType = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.FSharpSet`1");
			_fsharpMapType = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.FSharpMap`2");
			_fsharpListCtor = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.ListModule")?.GetMethod("OfSeq", BindingFlags.Static | BindingFlags.Public);
			_fsharpSetCtor = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.SetModule")?.GetMethod("OfSeq", BindingFlags.Static | BindingFlags.Public);
			_fsharpMapCtor = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.MapModule")?.GetMethod("OfSeq", BindingFlags.Static | BindingFlags.Public);
		}

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
		public FSharpKind DetectFSharpKind(Type type)
		{
			Attribute fSharpCompilationMappingAttribute = GetFSharpCompilationMappingAttribute(type);
			if (fSharpCompilationMappingAttribute == null)
			{
				return FSharpKind.Unrecognized;
			}
			if (type.IsGenericType)
			{
				Type genericTypeDefinition = type.GetGenericTypeDefinition();
				if (genericTypeDefinition == _fsharpOptionType)
				{
					return FSharpKind.Option;
				}
				if (genericTypeDefinition == _fsharpValueOptionType)
				{
					return FSharpKind.ValueOption;
				}
				if (genericTypeDefinition == _fsharpListType)
				{
					return FSharpKind.List;
				}
				if (genericTypeDefinition == _fsharpSetType)
				{
					return FSharpKind.Set;
				}
				if (genericTypeDefinition == _fsharpMapType)
				{
					return FSharpKind.Map;
				}
			}
			return (GetSourceConstructFlags(fSharpCompilationMappingAttribute) & SourceConstructFlags.KindMask) switch
			{
				SourceConstructFlags.RecordType => FSharpKind.Record, 
				SourceConstructFlags.SumType => FSharpKind.Union, 
				_ => FSharpKind.Unrecognized, 
			};
		}

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
		public Func<TFSharpOption, T> CreateFSharpOptionValueGetter<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TFSharpOption, T>()
		{
			MethodInfo methodInfo = EnsureMemberExists(typeof(TFSharpOption).GetMethod("get_Value", BindingFlags.Instance | BindingFlags.Public), "Microsoft.FSharp.Core.FSharpOption<T>.get_Value()");
			return CreateDelegate<Func<TFSharpOption, T>>(methodInfo);
		}

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
		public Func<TElement, TFSharpOption> CreateFSharpOptionSomeConstructor<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TFSharpOption, TElement>()
		{
			MethodInfo methodInfo = EnsureMemberExists(typeof(TFSharpOption).GetMethod("Some", BindingFlags.Static | BindingFlags.Public), "Microsoft.FSharp.Core.FSharpOption<T>.Some(T value)");
			return CreateDelegate<Func<TElement, TFSharpOption>>(methodInfo);
		}

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
		public StructGetter<TFSharpValueOption, TElement> CreateFSharpValueOptionValueGetter<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TFSharpValueOption, TElement>() where TFSharpValueOption : struct
		{
			MethodInfo methodInfo = EnsureMemberExists(typeof(TFSharpValueOption).GetMethod("get_Value", BindingFlags.Instance | BindingFlags.Public), "Microsoft.FSharp.Core.FSharpValueOption<T>.get_Value()");
			return CreateDelegate<StructGetter<TFSharpValueOption, TElement>>(methodInfo);
		}

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
		public Func<TElement, TFSharpOption> CreateFSharpValueOptionSomeConstructor<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TFSharpOption, TElement>()
		{
			MethodInfo methodInfo = EnsureMemberExists(typeof(TFSharpOption).GetMethod("Some", BindingFlags.Static | BindingFlags.Public), "Microsoft.FSharp.Core.FSharpValueOption<T>.ValueSome(T value)");
			return CreateDelegate<Func<TElement, TFSharpOption>>(methodInfo);
		}

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
		public Func<IEnumerable<TElement>, TFSharpList> CreateFSharpListConstructor<TFSharpList, TElement>()
		{
			return CreateDelegate<Func<IEnumerable<TElement>, TFSharpList>>(EnsureMemberExists(_fsharpListCtor, "Microsoft.FSharp.Collections.ListModule.OfSeq<T>(IEnumerable<T> source)").MakeGenericMethod(typeof(TElement)));
		}

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
		public Func<IEnumerable<TElement>, TFSharpSet> CreateFSharpSetConstructor<TFSharpSet, TElement>()
		{
			return CreateDelegate<Func<IEnumerable<TElement>, TFSharpSet>>(EnsureMemberExists(_fsharpSetCtor, "Microsoft.FSharp.Collections.SetModule.OfSeq<T>(IEnumerable<T> source)").MakeGenericMethod(typeof(TElement)));
		}

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
		public Func<IEnumerable<Tuple<TKey, TValue>>, TFSharpMap> CreateFSharpMapConstructor<TFSharpMap, TKey, TValue>()
		{
			return CreateDelegate<Func<IEnumerable<Tuple<TKey, TValue>>, TFSharpMap>>(EnsureMemberExists(_fsharpMapCtor, "Microsoft.FSharp.Collections.MapModule.OfSeq<TKey, TValue>(IEnumerable<Tuple<TKey, TValue>> source)").MakeGenericMethod(typeof(TKey), typeof(TValue)));
		}

		private Attribute GetFSharpCompilationMappingAttribute(Type type)
		{
			return type.GetCustomAttribute(_compilationMappingAttributeType, inherit: true);
		}

		private SourceConstructFlags GetSourceConstructFlags(Attribute compilationMappingAttribute)
		{
			if ((object)_sourceConstructFlagsGetter != null)
			{
				return (SourceConstructFlags)_sourceConstructFlagsGetter.Invoke(compilationMappingAttribute, null);
			}
			return SourceConstructFlags.None;
		}

		private static Assembly GetFSharpCoreAssembly(Type type)
		{
			object[] customAttributes = type.GetCustomAttributes(inherit: true);
			for (int i = 0; i < customAttributes.Length; i++)
			{
				Attribute attribute = (Attribute)customAttributes[i];
				Type type2 = attribute.GetType();
				if (type2.FullName == "Microsoft.FSharp.Core.CompilationMappingAttribute")
				{
					return type2.Assembly;
				}
			}
			return null;
		}

		private static TDelegate CreateDelegate<TDelegate>(MethodInfo methodInfo) where TDelegate : Delegate
		{
			return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), methodInfo, throwOnBindFailure: true);
		}

		private static TMemberInfo EnsureMemberExists<TMemberInfo>(TMemberInfo memberInfo, string memberName) where TMemberInfo : MemberInfo
		{
			if ((object)memberInfo == null)
			{
				ThrowHelper.ThrowMissingMemberException_MissingFSharpCoreMember(memberName);
			}
			return memberInfo;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class JsonCollectionInfoValues<TCollection>
	{
		public Func<TCollection>? ObjectCreator { get; init; }

		public JsonTypeInfo? KeyInfo { get; init; }

		public JsonTypeInfo ElementInfo { get; init; }

		public JsonNumberHandling NumberHandling { get; init; }

		public Action<Utf8JsonWriter, TCollection>? SerializeHandler { get; init; }
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static class JsonMetadataServices
	{
		private static JsonConverter<bool> s_booleanConverter;

		private static JsonConverter<byte[]> s_byteArrayConverter;

		private static JsonConverter<byte> s_byteConverter;

		private static JsonConverter<char> s_charConverter;

		private static JsonConverter<DateTime> s_dateTimeConverter;

		private static JsonConverter<DateTimeOffset> s_dateTimeOffsetConverter;

		private static JsonConverter<decimal> s_decimalConverter;

		private static JsonConverter<double> s_doubleConverter;

		private static JsonConverter<Guid> s_guidConverter;

		private static JsonConverter<short> s_int16Converter;

		private static JsonConverter<int> s_int32Converter;

		private static JsonConverter<long> s_int64Converter;

		private static JsonConverter<JsonArray> s_jsonArrayConverter;

		private static JsonConverter<JsonElement> s_jsonElementConverter;

		private static JsonConverter<JsonNode> s_jsonNodeConverter;

		private static JsonConverter<JsonObject> s_jsonObjectConverter;

		private static JsonConverter<JsonValue> s_jsonValueConverter;

		private static JsonConverter<JsonDocument> s_jsonDocumentConverter;

		private static JsonConverter<Memory<byte>> s_memoryByteConverter;

		private static JsonConverter<ReadOnlyMemory<byte>> s_readOnlyMemoryByteConverter;

		private static JsonConverter<object> s_objectConverter;

		private static JsonConverter<float> s_singleConverter;

		private static JsonConverter<sbyte> s_sbyteConverter;

		private static JsonConverter<string> s_stringConverter;

		private static JsonConverter<TimeSpan> s_timeSpanConverter;

		private static JsonConverter<ushort> s_uint16Converter;

		private static JsonConverter<uint> s_uint32Converter;

		private static JsonConverter<ulong> s_uint64Converter;

		private static JsonConverter<Uri> s_uriConverter;

		private static JsonConverter<Version> s_versionConverter;

		public static JsonConverter<bool> BooleanConverter => s_booleanConverter ?? (s_booleanConverter = new System.Text.Json.Serialization.Converters.BooleanConverter());

		public static JsonConverter<byte[]?> ByteArrayConverter => s_byteArrayConverter ?? (s_byteArrayConverter = new ByteArrayConverter());

		public static JsonConverter<byte> ByteConverter => s_byteConverter ?? (s_byteConverter = new System.Text.Json.Serialization.Converters.ByteConverter());

		public static JsonConverter<char> CharConverter => s_charConverter ?? (s_charConverter = new System.Text.Json.Serialization.Converters.CharConverter());

		public static JsonConverter<DateTime> DateTimeConverter => s_dateTimeConverter ?? (s_dateTimeConverter = new System.Text.Json.Serialization.Converters.DateTimeConverter());

		public static JsonConverter<DateTimeOffset> DateTimeOffsetConverter => s_dateTimeOffsetConverter ?? (s_dateTimeOffsetConverter = new System.Text.Json.Serialization.Converters.DateTimeOffsetConverter());

		public static JsonConverter<decimal> DecimalConverter => s_decimalConverter ?? (s_decimalConverter = new System.Text.Json.Serialization.Converters.DecimalConverter());

		public static JsonConverter<double> DoubleConverter => s_doubleConverter ?? (s_doubleConverter = new System.Text.Json.Serialization.Converters.DoubleConverter());

		public static JsonConverter<Guid> GuidConverter => s_guidConverter ?? (s_guidConverter = new System.Text.Json.Serialization.Converters.GuidConverter());

		public static JsonConverter<short> Int16Converter => s_int16Converter ?? (s_int16Converter = new System.Text.Json.Serialization.Converters.Int16Converter());

		public static JsonConverter<int> Int32Converter => s_int32Converter ?? (s_int32Converter = new System.Text.Json.Serialization.Converters.Int32Converter());

		public static JsonConverter<long> Int64Converter => s_int64Converter ?? (s_int64Converter = new System.Text.Json.Serialization.Converters.Int64Converter());

		public static JsonConverter<JsonArray?> JsonArrayConverter => s_jsonArrayConverter ?? (s_jsonArrayConverter = new JsonArrayConverter());

		public static JsonConverter<JsonElement> JsonElementConverter => s_jsonElementConverter ?? (s_jsonElementConverter = new JsonElementConverter());

		public static JsonConverter<JsonNode?> JsonNodeConverter => s_jsonNodeConverter ?? (s_jsonNodeConverter = new JsonNodeConverter());

		public static JsonConverter<JsonObject?> JsonObjectConverter => s_jsonObjectConverter ?? (s_jsonObjectConverter = new JsonObjectConverter());

		public static JsonConverter<JsonValue?> JsonValueConverter => s_jsonValueConverter ?? (s_jsonValueConverter = new JsonValueConverter());

		public static JsonConverter<JsonDocument?> JsonDocumentConverter => s_jsonDocumentConverter ?? (s_jsonDocumentConverter = new JsonDocumentConverter());

		public static JsonConverter<Memory<byte>> MemoryByteConverter => s_memoryByteConverter ?? (s_memoryByteConverter = new MemoryByteConverter());

		public static JsonConverter<ReadOnlyMemory<byte>> ReadOnlyMemoryByteConverter => s_readOnlyMemoryByteConverter ?? (s_readOnlyMemoryByteConverter = new ReadOnlyMemoryByteConverter());

		public static JsonConverter<object?> ObjectConverter => s_objectConverter ?? (s_objectConverter = new DefaultObjectConverter());

		public static JsonConverter<float> SingleConverter => s_singleConverter ?? (s_singleConverter = new System.Text.Json.Serialization.Converters.SingleConverter());

		[CLSCompliant(false)]
		public static JsonConverter<sbyte> SByteConverter => s_sbyteConverter ?? (s_sbyteConverter = new System.Text.Json.Serialization.Converters.SByteConverter());

		public static JsonConverter<string?> StringConverter => s_stringConverter ?? (s_stringConverter = new System.Text.Json.Serialization.Converters.StringConverter());

		public static JsonConverter<TimeSpan> TimeSpanConverter => s_timeSpanConverter ?? (s_timeSpanConverter = new System.Text.Json.Serialization.Converters.TimeSpanConverter());

		[CLSCompliant(false)]
		public static JsonConverter<ushort> UInt16Converter => s_uint16Converter ?? (s_uint16Converter = new System.Text.Json.Serialization.Converters.UInt16Converter());

		[CLSCompliant(false)]
		public static JsonConverter<uint> UInt32Converter => s_uint32Converter ?? (s_uint32Converter = new System.Text.Json.Serialization.Converters.UInt32Converter());

		[CLSCompliant(false)]
		public static JsonConverter<ulong> UInt64Converter => s_uint64Converter ?? (s_uint64Converter = new System.Text.Json.Serialization.Converters.UInt64Converter());

		public static JsonConverter<Uri?> UriConverter => s_uriConverter ?? (s_uriConverter = new UriConverter());

		public static JsonConverter<Version?> VersionConverter => s_versionConverter ?? (s_versionConverter = new VersionConverter());

		public static JsonTypeInfo<TElement[]> CreateArrayInfo<TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TElement[]> collectionInfo)
		{
			return CreateCore<TElement[]>(options, collectionInfo, new ArrayConverter<TElement[], TElement>());
		}

		public static JsonTypeInfo<TCollection> CreateListInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : List<TElement>
		{
			return CreateCore<TCollection>(options, collectionInfo, new ListOfTConverter<TCollection, TElement>());
		}

		public static JsonTypeInfo<TCollection> CreateDictionaryInfo<TCollection, TKey, TValue>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : Dictionary<TKey, TValue> where TKey : notnull
		{
			return CreateCore<TCollection>(options, collectionInfo, new DictionaryOfTKeyTValueConverter<TCollection, TKey, TValue>());
		}

		public static JsonTypeInfo<TCollection> CreateImmutableDictionaryInfo<TCollection, TKey, TValue>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo, Func<IEnumerable<KeyValuePair<TKey, TValue>>, TCollection> createRangeFunc) where TCollection : IReadOnlyDictionary<TKey, TValue> where TKey : notnull
		{
			if (createRangeFunc == null)
			{
				ThrowHelper.ThrowArgumentNullException("createRangeFunc");
			}
			return CreateCore<TCollection>(options, collectionInfo, new ImmutableDictionaryOfTKeyTValueConverter<TCollection, TKey, TValue>(), createRangeFunc);
		}

		public static JsonTypeInfo<TCollection> CreateIDictionaryInfo<TCollection, TKey, TValue>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IDictionary<TKey, TValue> where TKey : notnull
		{
			return CreateCore<TCollection>(options, collectionInfo, new IDictionaryOfTKeyTValueConverter<TCollection, TKey, TValue>());
		}

		public static JsonTypeInfo<TCollection> CreateIReadOnlyDictionaryInfo<TCollection, TKey, TValue>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IReadOnlyDictionary<TKey, TValue> where TKey : notnull
		{
			return CreateCore<TCollection>(options, collectionInfo, new IReadOnlyDictionaryOfTKeyTValueConverter<TCollection, TKey, TValue>());
		}

		public static JsonTypeInfo<TCollection> CreateImmutableEnumerableInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo, Func<IEnumerable<TElement>, TCollection> createRangeFunc) where TCollection : IEnumerable<TElement>
		{
			if (createRangeFunc == null)
			{
				ThrowHelper.ThrowArgumentNullException("createRangeFunc");
			}
			return CreateCore<TCollection>(options, collectionInfo, new ImmutableEnumerableOfTConverter<TCollection, TElement>(), createRangeFunc);
		}

		public static JsonTypeInfo<TCollection> CreateIListInfo<TCollection>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IList
		{
			return CreateCore<TCollection>(options, collectionInfo, new IListConverter<TCollection>());
		}

		public static JsonTypeInfo<TCollection> CreateIListInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IList<TElement>
		{
			return CreateCore<TCollection>(options, collectionInfo, new IListOfTConverter<TCollection, TElement>());
		}

		public static JsonTypeInfo<TCollection> CreateISetInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : ISet<TElement>
		{
			return CreateCore<TCollection>(options, collectionInfo, new ISetOfTConverter<TCollection, TElement>());
		}

		public static JsonTypeInfo<TCollection> CreateICollectionInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : ICollection<TElement>
		{
			return CreateCore<TCollection>(options, collectionInfo, new ICollectionOfTConverter<TCollection, TElement>());
		}

		public static JsonTypeInfo<TCollection> CreateStackInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : Stack<TElement>
		{
			return CreateCore<TCollection>(options, collectionInfo, new StackOfTConverter<TCollection, TElement>());
		}

		public static JsonTypeInfo<TCollection> CreateQueueInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : Queue<TElement>
		{
			return CreateCore<TCollection>(options, collectionInfo, new QueueOfTConverter<TCollection, TElement>());
		}

		public static JsonTypeInfo<TCollection> CreateConcurrentStackInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : ConcurrentStack<TElement>
		{
			return CreateCore<TCollection>(options, collectionInfo, new ConcurrentStackOfTConverter<TCollection, TElement>());
		}

		public static JsonTypeInfo<TCollection> CreateConcurrentQueueInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : ConcurrentQueue<TElement>
		{
			return CreateCore<TCollection>(options, collectionInfo, new ConcurrentQueueOfTConverter<TCollection, TElement>());
		}

		public static JsonTypeInfo<TCollection> CreateIEnumerableInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IEnumerable<TElement>
		{
			return CreateCore<TCollection>(options, collectionInfo, new IEnumerableOfTConverter<TCollection, TElement>());
		}

		public static JsonTypeInfo<TCollection> CreateIAsyncEnumerableInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IAsyncEnumerable<TElement>
		{
			return CreateCore<TCollection>(options, collectionInfo, new IAsyncEnumerableOfTConverter<TCollection, TElement>());
		}

		public static JsonTypeInfo<TCollection> CreateIDictionaryInfo<TCollection>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IDictionary
		{
			return CreateCore<TCollection>(options, collectionInfo, new IDictionaryConverter<TCollection>());
		}

		public static JsonTypeInfo<TCollection> CreateStackInfo<TCollection>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo, Action<TCollection, object?> addFunc) where TCollection : IEnumerable
		{
			return CreateStackOrQueueInfo(options, collectionInfo, addFunc);
		}

		public static JsonTypeInfo<TCollection> CreateQueueInfo<TCollection>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo, Action<TCollection, object?> addFunc) where TCollection : IEnumerable
		{
			return CreateStackOrQueueInfo(options, collectionInfo, addFunc);
		}

		private static JsonTypeInfo<TCollection> CreateStackOrQueueInfo<TCollection>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo, Action<TCollection, object> addFunc) where TCollection : IEnumerable
		{
			if (addFunc == null)
			{
				ThrowHelper.ThrowArgumentNullException("addFunc");
			}
			return CreateCore(options, collectionInfo, new StackOrQueueConverter<TCollection>(), null, addFunc);
		}

		public static JsonTypeInfo<TCollection> CreateIEnumerableInfo<TCollection>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IEnumerable
		{
			return CreateCore<TCollection>(options, collectionInfo, new IEnumerableConverter<TCollection>());
		}

		public static JsonTypeInfo<Memory<TElement>> CreateMemoryInfo<TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<Memory<TElement>> collectionInfo)
		{
			return CreateCore<Memory<TElement>>(options, collectionInfo, new MemoryConverter<TElement>());
		}

		public static JsonTypeInfo<ReadOnlyMemory<TElement>> CreateReadOnlyMemoryInfo<TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<ReadOnlyMemory<TElement>> collectionInfo)
		{
			return CreateCore<ReadOnlyMemory<TElement>>(options, collectionInfo, new ReadOnlyMemoryConverter<TElement>());
		}

		public static JsonConverter<T> GetUnsupportedTypeConverter<T>()
		{
			return new UnsupportedTypeConverter<T>();
		}

		public static JsonConverter<T> GetEnumConverter<T>(JsonSerializerOptions options) where T : struct, Enum
		{
			if (options == null)
			{
				ThrowHelper.ThrowArgumentNullException("options");
			}
			return new EnumConverter<T>(EnumConverterOptions.AllowNumbers, options);
		}

		public static JsonConverter<T?> GetNullableConverter<T>(JsonTypeInfo<T> underlyingTypeInfo) where T : struct
		{
			if (underlyingTypeInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("underlyingTypeInfo");
			}
			JsonConverter<T> typedConverter = GetTypedConverter<T>(underlyingTypeInfo.Converter);
			return new NullableConverter<T>(typedConverter);
		}

		public static JsonConverter<T?> GetNullableConverter<T>(JsonSerializerOptions options) where T : struct
		{
			if (options == null)
			{
				ThrowHelper.ThrowArgumentNullException("options");
			}
			JsonConverter<T> typedConverter = GetTypedConverter<T>(options.GetConverterInternal(typeof(T)));
			return new NullableConverter<T>(typedConverter);
		}

		internal static JsonConverter<T> GetTypedConverter<T>(JsonConverter converter)
		{
			JsonConverter<T> jsonConverter = converter as JsonConverter<T>;
			if (jsonConverter == null)
			{
				throw new InvalidOperationException(System.SR.Format(System.SR.SerializationConverterNotCompatible, jsonConverter, typeof(T)));
			}
			return jsonConverter;
		}

		private static JsonTypeInfo<T> CreateCore<T>(JsonConverter converter, JsonSerializerOptions options)
		{
			JsonTypeInfo<T> jsonTypeInfo = new JsonTypeInfo<T>(converter, options);
			jsonTypeInfo.PopulatePolymorphismMetadata();
			jsonTypeInfo.MapInterfaceTypesToCallbacks();
			converter.ConfigureJsonTypeInfo(jsonTypeInfo, options);
			return jsonTypeInfo;
		}

		private static JsonTypeInfo<T> CreateCore<T>(JsonSerializerOptions options, JsonObjectInfoValues<T> objectInfo)
		{
			JsonConverter<T> converter = GetConverter(objectInfo);
			JsonTypeInfo<T> jsonTypeInfo = new JsonTypeInfo<T>(converter, options);
			if (objectInfo.ObjectWithParameterizedConstructorCreator != null)
			{
				jsonTypeInfo.CreateObjectWithArgs = objectInfo.ObjectWithParameterizedConstructorCreator;
				PopulateParameterInfoValues(jsonTypeInfo, objectInfo.ConstructorParameterMetadataInitializer);
			}
			else
			{
				jsonTypeInfo.SetCreateObjectIfCompatible(objectInfo.ObjectCreator);
				jsonTypeInfo.CreateObjectForExtensionDataProperty = ((JsonTypeInfo)jsonTypeInfo).CreateObject;
			}
			if (objectInfo.PropertyMetadataInitializer != null)
			{
				jsonTypeInfo.SourceGenDelayedPropertyInitializer = objectInfo.PropertyMetadataInitializer;
			}
			else
			{
				jsonTypeInfo.PropertyMetadataSerializationNotSupported = true;
			}
			jsonTypeInfo.SerializeHandler = objectInfo.SerializeHandler;
			jsonTypeInfo.NumberHandling = objectInfo.NumberHandling;
			jsonTypeInfo.PopulatePolymorphismMetadata();
			jsonTypeInfo.MapInterfaceTypesToCallbacks();
			converter.ConfigureJsonTypeInfo(jsonTypeInfo, options);
			return jsonTypeInfo;
		}

		private static JsonTypeInfo<T> CreateCore<T>(JsonSerializerOptions options, JsonCollectionInfoValues<T> collectionInfo, JsonConverter<T> converter, object createObjectWithArgs = null, object addFunc = null)
		{
			if (collectionInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("collectionInfo");
			}
			converter = ((collectionInfo.SerializeHandler != null) ? new JsonMetadataServicesConverter<T>(converter) : converter);
			JsonTypeInfo<T> jsonTypeInfo = new JsonTypeInfo<T>(converter, options);
			jsonTypeInfo.KeyTypeInfo = collectionInfo.KeyInfo;
			jsonTypeInfo.ElementTypeInfo = collectionInfo.ElementInfo;
			jsonTypeInfo.NumberHandling = collectionInfo.NumberHandling;
			jsonTypeInfo.SerializeHandler = collectionInfo.SerializeHandler;
			jsonTypeInfo.CreateObjectWithArgs = createObjectWithArgs;
			jsonTypeInfo.AddMethodDelegate = addFunc;
			jsonTypeInfo.SetCreateObjectIfCompatible(collectionInfo.ObjectCreator);
			jsonTypeInfo.PopulatePolymorphismMetadata();
			jsonTypeInfo.MapInterfaceTypesToCallbacks();
			converter.ConfigureJsonTypeInfo(jsonTypeInfo, options);
			return jsonTypeInfo;
		}

		private static JsonConverter<T> GetConverter<T>(JsonObjectInfoValues<T> objectInfo)
		{
			JsonConverter<T> jsonConverter = ((objectInfo.ObjectWithParameterizedConstructorCreator != null) ? new LargeObjectWithParameterizedConstructorConverter<T>() : new ObjectDefaultConverter<T>());
			if (objectInfo.SerializeHandler == null)
			{
				return jsonConverter;
			}
			return new JsonMetadataServicesConverter<T>(jsonConverter);
		}

		private static void PopulateParameterInfoValues(JsonTypeInfo typeInfo, Func<JsonParameterInfoValues[]> paramFactory)
		{
			JsonParameterInfoValues[] array = paramFactory?.Invoke();
			if (array != null)
			{
				typeInfo.ParameterInfoValues = array;
			}
			else
			{
				typeInfo.PropertyMetadataSerializationNotSupported = true;
			}
		}

		internal static void PopulateProperties(JsonTypeInfo typeInfo, JsonTypeInfo.JsonPropertyInfoList propertyList, Func<JsonSerializerContext, JsonPropertyInfo[]> propInitFunc)
		{
			JsonSerializerContext arg = typeInfo.Options.TypeInfoResolver as JsonSerializerContext;
			JsonPropertyInfo[] array = propInitFunc(arg);
			JsonTypeInfo.PropertyHierarchyResolutionState state = new JsonTypeInfo.PropertyHierarchyResolutionState(typeInfo.Options);
			JsonPropertyInfo[] array2 = array;
			foreach (JsonPropertyInfo jsonPropertyInfo in array2)
			{
				if (!jsonPropertyInfo.SrcGen_IsPublic)
				{
					if (jsonPropertyInfo.SrcGen_HasJsonInclude)
					{
						ThrowHelper.ThrowInvalidOperationException_JsonIncludeOnInaccessibleProperty(jsonPropertyInfo.MemberName, jsonPropertyInfo.DeclaringType);
					}
				}
				else if (jsonPropertyInfo.MemberType != MemberTypes.Field || jsonPropertyInfo.SrcGen_HasJsonInclude || typeInfo.Options.IncludeFields)
				{
					propertyList.AddPropertyWithConflictResolution(jsonPropertyInfo, ref state);
				}
			}
			if (state.IsPropertyOrderSpecified)
			{
				propertyList.SortProperties();
			}
		}

		private static JsonPropertyInfo<T> CreatePropertyInfoCore<T>(JsonPropertyInfoValues<T> propertyInfoValues, JsonSerializerOptions options)
		{
			JsonPropertyInfo<T> jsonPropertyInfo = new JsonPropertyInfo<T>(propertyInfoValues.DeclaringType, null, options);
			DeterminePropertyName(jsonPropertyInfo, propertyInfoValues.PropertyName, propertyInfoValues.JsonPropertyName);
			jsonPropertyInfo.MemberName = propertyInfoValues.PropertyName;
			jsonPropertyInfo.MemberType = (propertyInfoValues.IsProperty ? MemberTypes.Property : MemberTypes.Field);
			jsonPropertyInfo.SrcGen_IsPublic = propertyInfoValues.IsPublic;
			jsonPropertyInfo.SrcGen_HasJsonInclude = propertyInfoValues.HasJsonInclude;
			jsonPropertyInfo.IsExtensionData = propertyInfoValues.IsExtensionData;
			jsonPropertyInfo.CustomConverter = propertyInfoValues.Converter;
			if (jsonPropertyInfo.IgnoreCondition != JsonIgnoreCondition.Always)
			{
				jsonPropertyInfo.Get = propertyInfoValues.Getter;
				jsonPropertyInfo.Set = propertyInfoValues.Setter;
			}
			jsonPropertyInfo.IgnoreCondition = propertyInfoValues.IgnoreCondition;
			jsonPropertyInfo.JsonTypeInfo = propertyInfoValues.PropertyTypeInfo;
			jsonPropertyInfo.NumberHandling = propertyInfoValues.NumberHandling;
			return jsonPropertyInfo;
		}

		private static void DeterminePropertyName(JsonPropertyInfo propertyInfo, string declaredPropertyName, string declaredJsonPropertyName)
		{
			string text = ((declaredJsonPropertyName != null) ? declaredJsonPropertyName : ((propertyInfo.Options.PropertyNamingPolicy != null) ? propertyInfo.Options.PropertyNamingPolicy.ConvertName(declaredPropertyName) : declaredPropertyName));
			if (text == null)
			{
				ThrowHelper.ThrowInvalidOperationException_SerializerPropertyNameNull(propertyInfo);
			}
			propertyInfo.Name = text;
		}

		public static JsonPropertyInfo CreatePropertyInfo<T>(JsonSerializerOptions options, JsonPropertyInfoValues<T> propertyInfo)
		{
			if (options == null)
			{
				ThrowHelper.ThrowArgumentNullException("options");
			}
			if (propertyInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyInfo");
			}
			Type declaringType = propertyInfo.DeclaringType;
			if (declaringType == null)
			{
				throw new ArgumentException("DeclaringType");
			}
			string propertyName = propertyInfo.PropertyName;
			if (propertyName == null)
			{
				throw new ArgumentException("PropertyName");
			}
			if (!propertyInfo.IsProperty && propertyInfo.IsVirtual)
			{
				throw new InvalidOperationException(System.SR.Format(System.SR.FieldCannotBeVirtual, "IsProperty", "IsVirtual"));
			}
			return CreatePropertyInfoCore(propertyInfo, options);
		}

		public static JsonTypeInfo<T> CreateObjectInfo<T>(JsonSerializerOptions options, JsonObjectInfoValues<T> objectInfo) where T : notnull
		{
			if (options == null)
			{
				ThrowHelper.ThrowArgumentNullException("options");
			}
			if (objectInfo == null)
			{
				ThrowHelper.ThrowArgumentNullException("objectInfo");
			}
			return CreateCore(options, objectInfo);
		}

		public static JsonTypeInfo<T> CreateValueInfo<T>(JsonSerializerOptions options, JsonConverter converter)
		{
			if (options == null)
			{
				ThrowHelper.ThrowArgumentNullException("options");
			}
			if (converter == null)
			{
				ThrowHelper.ThrowArgumentNullException("converter");
			}
			return CreateCore<T>(converter, options);
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class JsonObjectInfoValues<T>
	{
		public Func<T>? ObjectCreator { get; init; }

		public Func<object[], T>? ObjectWithParameterizedConstructorCreator { get; init; }

		public Func<JsonSerializerContext, JsonPropertyInfo[]>? PropertyMetadataInitializer { get; init; }

		public Func<JsonParameterInfoValues[]>? ConstructorParameterMetadataInitializer { get; init; }

		public JsonNumberHandling NumberHandling { get; init; }

		public Action<Utf8JsonWriter, T>? SerializeHandler { get; init; }
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class JsonParameterInfoValues
	{
		public string Name { get; init; }

		public Type ParameterType { get; init; }

		public int Position { get; init; }

		public bool HasDefaultValue { get; init; }

		public object? DefaultValue { get; init; }
	}
	internal abstract class JsonParameterInfo
	{
		public JsonConverter EffectiveConverter => MatchingProperty.EffectiveConverter;

		public object DefaultValue { get; private protected init; }

		public bool IgnoreNullTokensOnRead { get; }

		public JsonSerializerOptions Options { get; }

		public byte[] NameAsUtf8Bytes { get; }

		public JsonNumberHandling? NumberHandling { get; }

		public int Position { get; }

		public JsonTypeInfo JsonTypeInfo => MatchingProperty.JsonTypeInfo;

		public Type ParameterType { get; }

		public bool ShouldDeserialize { get; }

		public JsonPropertyInfo MatchingProperty { get; }

		public JsonParameterInfo(JsonParameterInfoValues parameterInfoValues, JsonPropertyInfo matchingProperty)
		{
			MatchingProperty = matchingProperty;
			ShouldDeserialize = !matchingProperty.IsIgnored;
			Options = matchingProperty.Options;
			Position = parameterInfoValues.Position;
			ParameterType = matchingProperty.PropertyType;
			NameAsUtf8Bytes = matchingProperty.NameAsUtf8Bytes;
			IgnoreNullTokensOnRead = matchingProperty.IgnoreNullTokensOnRead;
			NumberHandling = matchingProperty.EffectiveNumberHandling;
		}
	}
	internal sealed class JsonParameterInfo<T> : JsonParameterInfo
	{
		public new JsonConverter<T> EffectiveConverter => MatchingProperty.EffectiveConverter;

		public new JsonPropertyInfo<T> MatchingProperty { get; }

		public new T DefaultValue { get; }

		public JsonParameterInfo(JsonParameterInfoValues parameterInfoValues, JsonPropertyInfo<T> matchingPropertyInfo)
			: base(parameterInfoValues, matchingPropertyInfo)
		{
			MatchingProperty = matchingPropertyInfo;
			DefaultValue = ((parameterInfoValues.HasDefaultValue && parameterInfoValues.DefaultValue != null) ? ((T)parameterInfoValues.DefaultValue) : default(T));
			base.DefaultValue = DefaultValue;
		}
	}
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public abstract class JsonPropertyInfo
	{
		internal static readonly JsonPropertyInfo s_missingProperty = GetPropertyPlaceholder();

		private protected JsonConverter _effectiveConverter;

		private JsonConverter _customConverter;

		private protected Func<object, object> _untypedGet;

		private protected Action<object, object> _untypedSet;

		private bool _isUserSpecifiedSetter;

		private protected Func<object, object, bool> _shouldSerialize;

		private bool _isUserSpecifiedShouldSerialize;

		private JsonIgnoreCondition? _ignoreCondition;

		private JsonObjectCreationHandling? _objectCreationHandling;

		private ICustomAttributeProvider _attributeProvider;

		private bool _isExtensionDataProperty;

		private bool _isRequired;

		private string _name;

		private int _order;

		private JsonTypeInfo _jsonTypeInfo;

		private JsonNumberHandling? _numberHandling;

		private int _index;

		internal JsonTypeInfo? ParentTypeInfo { get; private set; }

		internal JsonConverter EffectiveConverter => _effectiveConverter;

		public JsonConverter? CustomConverter
		{
			get
			{
				return _customConverter;
			}
			set
			{
				VerifyMutable();
				_customConverter = value;
			}
		}

		public Func<object, object?>? Get
		{
			get
			{
				return _untypedGet;
			}
			set
			{
				VerifyMutable();
				SetGetter(value);
			}
		}

		public Action<object, object?>? Set
		{
			get
			{
				return _untypedSet;
			}
			set
			{
				VerifyMutable();
				SetSetter(value);
				_isUserSpecifiedSetter = true;
			}
		}

		public Func<object, object?, bool>? ShouldSerialize
		{
			get
			{
				return _shouldSerialize;
			}
			set
			{
				VerifyMutable();
				SetShouldSerialize(value);
				_isUserSpecifiedShouldSerialize = true;
				IgnoreDefaultValuesOnWrite = false;
			}
		}

		internal JsonIgnoreCondition? IgnoreCondition
		{
			get
			{
				return _ignoreCondition;
			}
			set
			{
				ConfigureIgnoreCondition(value);
				_ignoreCondition = value;
			}
		}

		public ICustomAttributeProvider? AttributeProvider
		{
			get
			{
				return _attributeProvider;
			}
			set
			{
				VerifyMutable();
				_attributeProvider = value;
			}
		}

		internal JsonObjectCreationHandling EffectiveObjectCreationHandling { get; private set; }

		public JsonObjectCreationHandling? ObjectCreationHandling
		{
			get
			{
				return _objectCreationHandling;
			}
			set
			{
				VerifyMutable();
				if (value.HasValue && !JsonSerializer.IsValidCreationHandlingValue(value.Value))
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_objectCreationHandling = value;
			}
		}

		internal string? MemberName { get; set; }

		internal MemberTypes MemberType { get; set; }

		internal bool IsVirtual { get; set; }

		public bool IsExtensionData
		{
			get
			{
				return _isExtensionDataProperty;
			}
			set
			{
				VerifyMutable();
				if (value && !System.Text.Json.Serialization.Metadata.JsonTypeInfo.IsValidExtensionDataProperty(PropertyType))
				{
					ThrowHelper.ThrowInvalidOperationException_SerializationDataExtensionPropertyInvalid(this);
				}
				_isExtensionDataProperty = value;
			}
		}

		public bool IsRequired
		{
			get
			{
				return _isRequired;
			}
			set
			{
				VerifyMutable();
				_isRequired = value;
			}
		}

		public Type PropertyType { get; }

		internal bool IsConfigured { get; private set; }

		internal bool HasGetter => _untypedGet != null;

		internal bool HasSetter => _untypedSet != null;

		internal bool IgnoreNullTokensOnRead { get; private protected set; }

		internal bool IgnoreDefaultValuesOnWrite { get; private protected set; }

		internal bool IgnoreReadOnlyMember => MemberType switch
		{
			MemberTypes.Property => Options.IgnoreReadOnlyProperties, 
			MemberTypes.Field => Options.IgnoreReadOnlyFields, 
			_ => false, 
		};

		internal bool IsForTypeInfo { get; set; }

		public string Name
		{
			get
			{
				return _name;
			}
			set
			{
				VerifyMutable();
				if (value == null)
				{
					ThrowHelper.ThrowArgumentNullException("value");
				}
				_name = value;
			}
		}

		internal byte[] NameAsUtf8Bytes { get; set; }

		internal byte[] EscapedNameSection { get; set; }

		public JsonSerializerOptions Options { get; }

		public int Order
		{
			get
			{
				return _order;
			}
			set
			{
				VerifyMutable();
				_order = value;
			}
		}

		internal Type DeclaringType { get; }

		internal JsonTypeInfo JsonTypeInfo
		{
			get
			{
				JsonTypeInfo jsonTypeInfo = _jsonTypeInfo;
				jsonTypeInfo.EnsureConfigured();
				return jsonTypeInfo;
			}
			set
			{
				_jsonTypeInfo = value;
			}
		}

		internal bool IsPropertyTypeInfoConfigured => _jsonTypeInfo?.IsConfigured ?? false;

		internal bool IsIgnored
		{
			get
			{
				JsonIgnoreCondition? ignoreCondition = _ignoreCondition;
				if (ignoreCondition.HasValue && ignoreCondition == JsonIgnoreCondition.Always && Get == null)
				{
					return Set == null;
				}
				return false;
			}
		}

		internal bool CanSerialize { get; private set; }

		internal bool CanDeserialize { get; private set; }

		internal bool CanDeserializeOrPopulate { get; private set; }

		internal bool SrcGen_HasJsonInclude { get; set; }

		internal bool SrcGen_IsPublic { get; set; }

		public JsonNumberHandling? NumberHandling
		{
			get
			{
				return _numberHandling;
			}
			set
			{
				VerifyMutable();
				_numberHandling = value;
			}
		}

		internal JsonNumberHandling? EffectiveNumberHandling { get; set; }

		internal abstract bool PropertyTypeCanBeNull { get; }

		internal abstract object? DefaultValue { get; }

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		internal int RequiredPropertyIndex
		{
			get
			{
				return _index;
			}
			set
			{
				_index = value;
			}
		}

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private string DebuggerDisplay => $"Name = {Name}, PropertyType = {PropertyType}";

		private protected abstract void SetGetter(Delegate getter);

		private protected abstract void SetSetter(Delegate setter);

		private protected abstract void SetShouldSerialize(Delegate predicate);

		private protected abstract void ConfigureIgnoreCondition(JsonIgnoreCondition? ignoreCondition);

		internal JsonPropertyInfo(Type declaringType, Type propertyType, JsonTypeInfo declaringTypeInfo, JsonSerializerOptions options)
		{
			DeclaringType = declaringType;
			PropertyType = propertyType;
			ParentTypeInfo = declaringTypeInfo;
			Options = options;
		}

		internal static JsonPropertyInfo GetPropertyPlaceholder()
		{
			JsonPropertyInfo jsonPropertyInfo = new JsonPropertyInfo<object>(typeof(object), null, null);
			jsonPropertyInfo.Name = string.Empty;
			return jsonPropertyInfo;
		}

		private protected void VerifyMutable()
		{
			ParentTypeInfo?.VerifyMutable();
		}

		internal void Configure()
		{
			if (IsIgnored)
			{
				CanSerialize = false;
				CanDeserialize = false;
			}
			else
			{
				if (_jsonTypeInfo == null)
				{
					_jsonTypeInfo = Options.GetTypeInfoInternal(PropertyType, ensureConfigured: true, true);
				}
				_jsonTypeInfo.EnsureConfigured();
				DetermineEffectiveConverter(_jsonTypeInfo);
				DetermineNumberHandlingForProperty();
				DetermineEffectiveObjectCreationHandlingForProperty();
				DetermineSerializationCapabilities();
				DetermineIgnoreCondition();
			}
			if (IsForTypeInfo)
			{
				DetermineNumberHandlingForTypeInfo();
			}
			else
			{
				CacheNameAsUtf8BytesAndEscapedNameSection();
			}
			if (IsRequired)
			{
				if (!CanDeserialize)
				{
					ThrowHelper.ThrowInvalidOperationException_JsonPropertyRequiredAndNotDeserializable(this);
				}
				if (IsExtensionData)
				{
					ThrowHelper.ThrowInvalidOperationException_JsonPropertyRequiredAndExtensionData(this);
				}
			}
			IsConfigured = true;
		}

		private protected abstract void DetermineEffectiveConverter(JsonTypeInfo jsonTypeInfo);

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		internal abstract void DetermineReflectionPropertyAccessors(MemberInfo memberInfo, bool useNonPublicAccessors);

		private void CacheNameAsUtf8BytesAndEscapedNameSection()
		{
			NameAsUtf8Bytes = Encoding.UTF8.GetBytes(Name);
			EscapedNameSection = JsonHelpers.GetEscapedPropertyNameSection(NameAsUtf8Bytes, Options.Encoder);
		}

		private void DetermineIgnoreCondition()
		{
			if (_ignoreCondition.HasValue)
			{
				return;
			}
			if (Options.IgnoreNullValues)
			{
				if (PropertyTypeCanBeNull)
				{
					IgnoreNullTokensOnRead = !_isUserSpecifiedSetter && !IsRequired;
					IgnoreDefaultValuesOnWrite = ShouldSerialize == null;
				}
			}
			else if (Options.DefaultIgnoreCondition == JsonIgnoreCondition.WhenWritingNull)
			{
				if (PropertyTypeCanBeNull)
				{
					IgnoreDefaultValuesOnWrite = ShouldSerialize == null;
				}
			}
			else if (Options.DefaultIgnoreCondition == JsonIgnoreCondition.WhenWritingDefault)
			{
				IgnoreDefaultValuesOnWrite = ShouldSerialize == null;
			}
		}

		private void DetermineSerializationCapabilities()
		{
			CanSerialize = HasGetter;
			CanDeserialize = HasSetter;
			if (MemberType == (MemberTypes)0 || _ignoreCondition.HasValue)
			{
				CanDeserializeOrPopulate = CanDeserialize || EffectiveObjectCreationHandling == JsonObjectCreationHandling.Populate;
				return;
			}
			if ((EffectiveConverter.ConverterStrategy & (ConverterStrategy)24) != ConverterStrategy.None)
			{
				if (Get == null && Set != null && !_isUserSpecifiedSetter)
				{
					CanDeserialize = false;
				}
			}
			else if (Get != null && Set == null && IgnoreReadOnlyMember && !_isUserSpecifiedShouldSerialize)
			{
				CanSerialize = false;
			}
			CanDeserializeOrPopulate = CanDeserialize || EffectiveObjectCreationHandling == JsonObjectCreationHandling.Populate;
		}

		private void DetermineNumberHandlingForTypeInfo()
		{
			JsonNumberHandling? numberHandling = ParentTypeInfo.NumberHandling;
			if (numberHandling.HasValue && numberHandling != JsonNumberHandling.Strict && !EffectiveConverter.IsInternalConverter)
			{
				ThrowHelper.ThrowInvalidOperationException_NumberHandlingOnPropertyInvalid(this);
			}
			if (NumberHandingIsApplicable())
			{
				EffectiveNumberHandling = numberHandling;
				if (!EffectiveNumberHandling.HasValue && Options.NumberHandling != JsonNumberHandling.Strict)
				{
					EffectiveNumberHandling = Options.NumberHandling;
				}
			}
		}

		private void DetermineNumberHandlingForProperty()
		{
			if (NumberHandingIsApplicable())
			{
				JsonNumberHandling? effectiveNumberHandling = NumberHandling ?? ParentTypeInfo.NumberHandling ?? _jsonTypeInfo.NumberHandling;
				if (!effectiveNumberHandling.HasValue && Options.NumberHandling != JsonNumberHandling.Strict)
				{
					effectiveNumberHandling = Options.NumberHandling;
				}
				EffectiveNumberHandling = effectiveNumberHandling;
			}
			else if (NumberHandling.HasValue && NumberHandling != JsonNumberHandling.Strict)
			{
				ThrowHelper.ThrowInvalidOperationException_NumberHandlingOnPropertyInvalid(this);
			}
		}

		private void DetermineEffectiveObjectCreationHandlingForProperty()
		{
			JsonObjectCreationHandling jsonObjectCreationHandling = JsonObjectCreationHandling.Replace;
			if (!ObjectCreationHandling.HasValue)
			{
				JsonObjectCreationHandling jsonObjectCreationHandling2 = ParentTypeInfo.PreferredPropertyObjectCreationHandling ?? ((!ParentTypeInfo.DetermineUsesParameterizedConstructor()) ? Options.PreferredObjectCreationHandling : JsonObjectCreationHandling.Replace);
				jsonObjectCreationHandling = ((jsonObjectCreationHandling2 == JsonObjectCreationHandling.Populate && EffectiveConverter.CanPopulate && Get != null && (!PropertyType.IsValueType || Set != null) && !ParentTypeInfo.SupportsPolymorphicDeserialization && (Set != null || !IgnoreReadOnlyMember)) ? JsonObjectCreationHandling.Populate : JsonObjectCreationHandling.Replace);
			}
			else if (ObjectCreationHandling == JsonObjectCreationHandling.Populate)
			{
				if (!EffectiveConverter.CanPopulate)
				{
					ThrowHelper.ThrowInvalidOperationException_ObjectCreationHandlingPopulateNotSupportedByConverter(this);
				}
				if (Get == null)
				{
					ThrowHelper.ThrowInvalidOperationException_ObjectCreationHandlingPropertyMustHaveAGetter(this);
				}
				if (PropertyType.IsValueType && Set == null)
				{
					ThrowHelper.ThrowInvalidOperationException_ObjectCreationHandlingPropertyValueTypeMustHaveASetter(this);
				}
				if (JsonTypeInfo.SupportsPolymorphicDeserialization)
				{
					ThrowHelper.ThrowInvalidOperationException_ObjectCreationHandlingPropertyCannotAllowPolymorphicDeserialization(this);
				}
				if (Set == null && IgnoreReadOnlyMember)
				{
					ThrowHelper.ThrowInvalidOperationException_ObjectCreationHandlingPropertyCannotAllowReadOnlyMember(this);
				}
				jsonObjectCreationHandling = JsonObjectCreationHandling.Populate;
			}
			if (jsonObjectCreationHandling == JsonObjectCreationHandling.Populate)
			{
				if (ParentTypeInfo.DetermineUsesParameterizedConstructor())
				{
					ThrowHelper.ThrowNotSupportedException_ObjectCreationHandlingPropertyDoesNotSupportParameterizedConstructors();
				}
				if (Options.ReferenceHandlingStrategy != ReferenceHandlingStrategy.None)
				{
					ThrowHelper.ThrowInvalidOperationException_ObjectCreationHandlingPropertyCannotAllowReferenceHandling();
				}
			}
			EffectiveObjectCreationHandling = jsonObjectCreationHandling;
		}

		private bool NumberHandingIsApplicable()
		{
			if (EffectiveConverter.IsInternalConverterForNumberType)
			{
				return true;
			}
			Type type = ((EffectiveConverter.IsInternalConverter && ((ConverterStrategy)24 & EffectiveConverter.ConverterStrategy) != ConverterStrategy.None) ? EffectiveConverter.ElementType : PropertyType);
			type = Nullable.GetUnderlyingType(type) ?? type;
			if (!(type == typeof(byte)) && !(type == typeof(decimal)) && !(type == typeof(double)) && !(type == typeof(short)) && !(type == typeof(int)) && !(type == typeof(long)) && !(type == typeof(sbyte)) && !(type == typeof(float)) && !(type == typeof(ushort)) && !(type == typeof(uint)) && !(type == typeof(ulong)))
			{
				return type == System.Text.Json.Serialization.Metadata.JsonTypeInfo.ObjectType;
			}
			return true;
		}

		internal abstract JsonParameterInfo CreateJsonParameterInfo(JsonParameterInfoValues parameterInfoValues);

		internal abstract bool GetMemberAndWriteJson(object obj, ref WriteStack state, Utf8JsonWriter writer);

		internal abstract bool GetMemberAndWriteJsonExtensionData(object obj, ref WriteStack state, Utf8JsonWriter writer);

		internal abstract object GetValueAsObject(object obj);

		internal bool ReadJsonAndAddExtensionProperty(object obj, scoped ref ReadStack state, ref Utf8JsonReader reader)
		{
			object valueAsObject = GetValueAsObject(obj);
			if (valueAsObject is IDictionary<string, object> dictionary)
			{
				if (reader.TokenType == JsonTokenType.Null)
				{
					dictionary[state.Current.JsonPropertyNameAsString] = null;
				}
				else
				{
					JsonConverter<object> jsonConverter = GetDictionaryValueConverter<object>();
					object value = jsonConverter.Read(ref reader, System.Text.Json.Serialization.Metadata.JsonTypeInfo.ObjectType, Options);
					dictionary[state.Current.JsonPropertyNameAsString] = value;
				}
			}
			else if (valueAsObject is IDictionary<string, JsonElement> dictionary2)
			{
				JsonConverter<JsonElement> jsonConverter2 = GetDictionaryValueConverter<JsonElement>();
				JsonElement value2 = jsonConverter2.Read(ref reader, typeof(JsonElement), Options);
				dictionary2[state.Current.JsonPropertyNameAsString] = value2;
			}
			else
			{
				EffectiveConverter.ReadElementAndSetProperty(valueAsObject, state.Current.JsonPropertyNameAsString, ref reader, Options, ref state);
			}
			return true;
			JsonConverter<TValue> GetDictionaryValueConverter<TValue>()
			{
				JsonTypeInfo jsonTypeInfo = JsonTypeInfo.ElementTypeInfo ?? Options.GetTypeInfoInternal(typeof(TValue), ensureConfigured: true, true);
				return ((JsonTypeInfo<TValue>)jsonTypeInfo).EffectiveConverter;
			}
		}

		internal abstract bool ReadJsonAndSetMember(object obj, scoped ref ReadStack state, ref Utf8JsonReader reader);

		internal abstract bool ReadJsonAsObject(scoped ref ReadStack state, ref Utf8JsonReader reader, out object value);

		internal bool ReadJsonExtensionDataValue(scoped ref ReadStack state, ref Utf8JsonReader reader, out object value)
		{
			if (JsonTypeInfo.ElementType == System.Text.Json.Serialization.Metadata.JsonTypeInfo.ObjectType && reader.TokenType == JsonTokenType.Null)
			{
				value = null;
				return true;
			}
			JsonConverter<JsonElement> jsonConverter = (JsonConverter<JsonElement>)Options.GetConverterInternal(typeof(JsonElement));
			if (!jsonConverter.TryRead(ref reader, typeof(JsonElement), Options, ref state, out var value2, out var _))
			{
				value = null;
				return false;
			}
			value = value2;
			return true;
		}

		internal void EnsureChildOf(JsonTypeInfo parent)
		{
			if (ParentTypeInfo == null)
			{
				ParentTypeInfo = parent;
			}
			else if (ParentTypeInfo != parent)
			{
				ThrowHelper.ThrowInvalidOperationException_JsonPropertyInfoIsBoundToDifferentJsonTypeInfo(this);
			}
		}

		internal bool TryGetPrePopulatedValue(scoped ref ReadStack state)
		{
			if (EffectiveObjectCreationHandling != JsonObjectCreationHandling.Populate)
			{
				return false;
			}
			object obj = Get(state.Parent.ReturnValue);
			state.Current.ReturnValue = obj;
			state.Current.IsPopulating = obj != null;
			return obj != null;
		}

		internal bool IsOverriddenOrShadowedBy(JsonPropertyInfo other)
		{
			if (MemberName == other.MemberName)
			{
				return DeclaringType.IsAssignableFrom(other.DeclaringType);
			}
			return false;
		}
	}
	internal sealed class JsonPropertyInfo<T> : JsonPropertyInfo
	{
		private Func<object, T> _typedGet;

		private Action<object, T> _typedSet;

		private Func<object, T, bool> _shouldSerializeTyped;

		private JsonConverter<T> _typedEffectiveConverter;

		internal new Func<object, T> Get
		{
			get
			{
				return _typedGet;
			}
			set
			{
				SetGetter(value);
			}
		}

		internal new Action<object, T> Set
		{
			get
			{
				return _typedSet;
			}
			set
			{
				SetSetter(value);
			}
		}

		internal new Func<object, T, bool> ShouldSerialize
		{
			get
			{
				return _shouldSerializeTyped;
			}
			set
			{
				SetShouldSerialize(value);
			}
		}

		internal override object DefaultValue => default(T);

		internal override bool PropertyTypeCanBeNull => default(T) == null;

		internal new JsonConverter<T> EffectiveConverter => _typedEffectiveConverter;

		internal JsonPropertyInfo(Type declaringType, JsonTypeInfo declaringTypeInfo, JsonSerializerOptions options)
			: base(declaringType, typeof(T), declaringTypeInfo, options)
		{
		}

		private protected override void SetGetter(Delegate getter)
		{
			if ((object)getter == null)
			{
				_typedGet = null;
				_untypedGet = null;
				return;
			}
			Func<object, T> typedGetter = getter as Func<object, T>;
			if (typedGetter != null)
			{
				_typedGet = typedGetter;
				_untypedGet = ((getter is Func<object, object> func) ? func : ((Func<object, object>)((object obj) => typedGetter(obj))));
				return;
			}
			Func<object, object> untypedGet = (Func<object, object>)getter;
			_typedGet = (object obj) => (T)untypedGet(obj);
			_untypedGet = untypedGet;
		}

		private protected override void SetSetter(Delegate setter)
		{
			if ((object)setter == null)
			{
				_typedSet = null;
				_untypedSet = null;
				return;
			}
			Action<object, T> typedSetter = setter as Action<object, T>;
			if (typedSetter != null)
			{
				_typedSet = typedSetter;
				_untypedSet = ((setter is Action<object, object> action) ? action : ((Action<object, object>)delegate(object obj, object value)
				{
					typedSetter(obj, (T)value);
				}));
				return;
			}
			Action<object, object> untypedSet = (Action<object, object>)setter;
			_typedSet = delegate(object obj, T value)
			{
				untypedSet(obj, value);
			};
			_untypedSet = untypedSet;
		}

		private protected override void SetShouldSerialize(Delegate predicate)
		{
			if ((object)predicate == null)
			{
				_shouldSerializeTyped = null;
				_shouldSerialize = null;
				return;
			}
			Func<object, T, bool> typedPredicate = predicate as Func<object, T, bool>;
			if (typedPredicate != null)
			{
				_shouldSerializeTyped = typedPredicate;
				_shouldSerialize = ((typedPredicate is Func<object, object, bool> func) ? func : ((Func<object, object, bool>)((object obj, object value) => typedPredicate(obj, (T)value))));
				return;
			}
			Func<object, object, bool> untypedPredicate = (Func<object, object, bool>)predicate;
			_shouldSerializeTyped = (object obj, T value) => untypedPredicate(obj, value);
			_shouldSerialize = untypedPredicate;
		}

		internal override JsonParameterInfo CreateJsonParameterInfo(JsonParameterInfoValues parameterInfoValues)
		{
			return new JsonParameterInfo<T>(parameterInfoValues, this);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		internal override void DetermineReflectionPropertyAccessors(MemberInfo memberInfo, bool useNonPublicAccessors)
		{
			DefaultJsonTypeInfoResolver.DeterminePropertyAccessors(this, memberInfo, useNonPublicAccessors);
		}

		private protected override void DetermineEffectiveConverter(JsonTypeInfo jsonTypeInfo)
		{
			_typedEffectiveConverter = (JsonConverter<T>)(_effectiveConverter = base.Options.ExpandConverterFactory(base.CustomConverter, base.PropertyType)?.CreateCastingConverter<T>() ?? ((JsonTypeInfo<T>)jsonTypeInfo).EffectiveConverter);
		}

		internal override object GetValueAsObject(object obj)
		{
			if (base.IsForTypeInfo)
			{
				return obj;
			}
			return Get(obj);
		}

		internal override bool GetMemberAndWriteJson(object obj, ref WriteStack state, Utf8JsonWriter writer)
		{
			T value = Get(obj);
			if (!EffectiveConverter.IsValueType && base.Options.ReferenceHandlingStrategy == ReferenceHandlingStrategy.IgnoreCycles && value != null && !state.IsContinuation && EffectiveConverter.ConverterStrategy != ConverterStrategy.Value && state.ReferenceResolver.ContainsReferenceForCycleDetection(value))
			{
				value = default(T);
			}
			if (base.IgnoreDefaultValuesOnWrite)
			{
				if (IsDefaultValue(value))
				{
					return true;
				}
			}
			else
			{
				Func<object, T, bool> shouldSerialize = ShouldSerialize;
				if (shouldSerialize != null && !shouldSerialize(obj, value))
				{
					return true;
				}
			}
			if (value == null)
			{
				if (EffectiveConverter.HandleNullOnWrite)
				{
					if ((int)state.Current.PropertyState < 2)
					{
						state.Current.PropertyState = StackFramePropertyState.Name;
						writer.WritePropertyNameSection(base.EscapedNameSection);
					}
					int currentDepth = writer.CurrentDepth;
					EffectiveConverter.Write(writer, value, base.Options);
					if (currentDepth != writer.CurrentDepth)
					{
						ThrowHelper.ThrowJsonException_SerializationConverterWrite(EffectiveConverter);
					}
				}
				else
				{
					writer.WriteNullSection(base.EscapedNameSection);
				}
				return true;
			}
			if ((int)state.Current.PropertyState < 2)
			{
				state.Current.PropertyState = StackFramePropertyState.Name;
				writer.WritePropertyNameSection(base.EscapedNameSection);
			}
			return EffectiveConverter.TryWrite(writer, in value, base.Options, ref state);
		}

		internal override bool GetMemberAndWriteJsonExtensionData(object obj, ref WriteStack state, Utf8JsonWriter writer)
		{
			T val = Get(obj);
			Func<object, T, bool> shouldSerialize = ShouldSerialize;
			if (shouldSerialize != null && !shouldSerialize(obj, val))
			{
				return true;
			}
			if (val == null)
			{
				return true;
			}
			return EffectiveConverter.TryWriteDataExtensionProperty(writer, val, base.Options, ref state);
		}

		internal override bool ReadJsonAndSetMember(object obj, scoped ref ReadStack state, ref Utf8JsonReader reader)
		{
			bool flag = reader.TokenType == JsonTokenType.Null;
			bool flag2;
			if (flag && !EffectiveConverter.HandleNullOnRead && !state.IsContinuation)
			{
				if (default(T) != null || !base.CanDeserialize)
				{
					if (default(T) == null)
					{
						ThrowHelper.ThrowInvalidOperationException_DeserializeUnableToAssignNull(EffectiveConverter.Type);
					}
					ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(EffectiveConverter.Type);
				}
				if (!base.IgnoreNullTokensOnRead)
				{
					Set(obj, default(T));
				}
				flag2 = true;
				state.Current.MarkRequiredPropertyAsRead(this);
			}
			else if (EffectiveConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
			{
				if (!flag || !base.IgnoreNullTokensOnRead || default(T) != null)
				{
					T arg = EffectiveConverter.Read(ref reader, base.PropertyType, base.Options);
					Set(obj, arg);
				}
				flag2 = true;
				state.Current.MarkRequiredPropertyAsRead(this);
			}
			else
			{
				flag2 = true;
				if (!flag || !base.IgnoreNullTokensOnRead || default(T) != null || state.IsContinuation)
				{
					state.Current.ReturnValue = obj;
					flag2 = EffectiveConverter.TryRead(ref reader, base.PropertyType, base.Options, ref state, out var value, out var isPopulatedValue);
					if (flag2)
					{
						if ((typeof(T).IsValueType || !isPopulatedValue) && base.CanDeserialize)
						{
							Set(obj, value);
						}
						state.Current.MarkRequiredPropertyAsRead(this);
					}
				}
			}
			return flag2;
		}

		internal override bool ReadJsonAsObject(scoped ref ReadStack state, ref Utf8JsonReader reader, out object value)
		{
			bool result;
			if (reader.TokenType == JsonTokenType.Null && !EffectiveConverter.HandleNullOnRead && !state.IsContinuation)
			{
				if (default(T) != null)
				{
					ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(EffectiveConverter.Type);
				}
				value = default(T);
				result = true;
			}
			else if (EffectiveConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
			{
				value = EffectiveConverter.Read(ref reader, base.PropertyType, base.Options);
				result = true;
			}
			else
			{
				result = EffectiveConverter.TryRead(ref reader, base.PropertyType, base.Options, ref state, out var value2, out var _);
				value = value2;
			}
			return result;
		}

		private protected override void ConfigureIgnoreCondition(JsonIgnoreCondition? ignoreCondition)
		{
			if (!ignoreCondition.HasValue)
			{
				return;
			}
			switch (ignoreCondition.GetValueOrDefault())
			{
			case JsonIgnoreCondition.Never:
				ShouldSerialize = ShouldSerializeIgnoreConditionNever;
				break;
			case JsonIgnoreCondition.Always:
				ShouldSerialize = ShouldSerializeIgnoreConditionAlways;
				break;
			case JsonIgnoreCondition.WhenWritingNull:
				if (PropertyTypeCanBeNull)
				{
					ShouldSerialize = ShouldSerializeIgnoreWhenWritingDefault;
					base.IgnoreDefaultValuesOnWrite = true;
				}
				else
				{
					ThrowHelper.ThrowInvalidOperationException_IgnoreConditionOnValueTypeInvalid(base.MemberName, base.DeclaringType);
				}
				break;
			case JsonIgnoreCondition.WhenWritingDefault:
				ShouldSerialize = ShouldSerializeIgnoreWhenWritingDefault;
				base.IgnoreDefaultValuesOnWrite = true;
				break;
			}
			static bool ShouldSerializeIgnoreConditionAlways(object _, T value)
			{
				return false;
			}
			static bool ShouldSerializeIgnoreConditionNever(object _, T value)
			{
				return true;
			}
			static bool ShouldSerializeIgnoreWhenWritingDefault(object _, T value)
			{
				if (default(T) != null)
				{
					return !EqualityComparer<T>.Default.Equals(default(T), value);
				}
				return value != null;
			}
		}

		private static bool IsDefaultValue(T value)
		{
			if (default(T) != null)
			{
				return EqualityComparer<T>.Default.Equals(default(T), value);
			}
			return value == null;
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class JsonPropertyInfoValues<T>
	{
		public bool IsProperty { get; init; }

		public bool IsPublic { get; init; }

		public bool IsVirtual { get; init; }

		public Type DeclaringType { get; init; }

		public JsonTypeInfo PropertyTypeInfo { get; init; }

		public JsonConverter<T>? Converter { get; init; }

		public Func<object, T?>? Getter { get; init; }

		public Action<object, T?>? Setter { get; init; }

		public JsonIgnoreCondition? IgnoreCondition { get; init; }

		public bool HasJsonInclude { get; init; }

		public bool IsExtensionData { get; init; }

		public JsonNumberHandling? NumberHandling { get; init; }

		public string PropertyName { get; init; }

		public string? JsonPropertyName { get; init; }
	}
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public abstract class JsonTypeInfo
	{
		internal delegate T ParameterizedConstructorDelegate<T, TArg0, TArg1, TArg2, TArg3>(TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3);

		private enum ConfigurationState : byte
		{
			NotConfigured,
			Configuring,
			Configured
		}

		internal ref struct PropertyHierarchyResolutionState
		{
			public Dictionary<string, (JsonPropertyInfo, int index)> AddedProperties;

			public Dictionary<string, JsonPropertyInfo> IgnoredProperties;

			public bool IsPropertyOrderSpecified;

			public PropertyHierarchyResolutionState(JsonSerializerOptions options)
			{
				IgnoredProperties = null;
				IsPropertyOrderSpecified = false;
				AddedProperties = new Dictionary<string, (JsonPropertyInfo, int)>(options.PropertyNameCaseInsensitive ? StringComparer.OrdinalIgnoreCase : StringComparer.Ordinal);
			}
		}

		private sealed class ParameterLookupKey
		{
			public string Name { get; }

			public Type Type { get; }

			public ParameterLookupKey(string name, Type type)
			{
				Name = name;
				Type = type;
			}

			public override int GetHashCode()
			{
				return StringComparer.OrdinalIgnoreCase.GetHashCode(Name);
			}

			public override bool Equals([NotNullWhen(true)] object obj)
			{
				ParameterLookupKey parameterLookupKey = (ParameterLookupKey)obj;
				if (Type == parameterLookupKey.Type)
				{
					return string.Equals(Name, parameterLookupKey.Name, StringComparison.OrdinalIgnoreCase);
				}
				return false;
			}
		}

		private sealed class ParameterLookupValue
		{
			public string DuplicateName { get; set; }

			public JsonPropertyInfo JsonPropertyInfo { get; }

			public ParameterLookupValue(JsonPropertyInfo jsonPropertyInfo)
			{
				JsonPropertyInfo = jsonPropertyInfo;
			}
		}

		internal sealed class JsonPropertyInfoList : ConfigurationList<JsonPropertyInfo>
		{
			private readonly JsonTypeInfo _jsonTypeInfo;

			public override bool IsReadOnly
			{
				get
				{
					if (_jsonTypeInfo._properties != this || !_jsonTypeInfo.IsReadOnly)
					{
						return _jsonTypeInfo.Kind != JsonTypeInfoKind.Object;
					}
					return true;
				}
			}

			public JsonPropertyInfoList(JsonTypeInfo jsonTypeInfo)
				: base((IEnumerable<JsonPropertyInfo>)null)
			{
				_jsonTypeInfo = jsonTypeInfo;
			}

			protected override void OnCollectionModifying()
			{
				if (_jsonTypeInfo._properties == this)
				{
					_jsonTypeInfo.VerifyMutable();
				}
				if (_jsonTypeInfo.Kind != JsonTypeInfoKind.Object)
				{
					ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(_jsonTypeInfo.Kind);
				}
			}

			protected override void ValidateAddedValue(JsonPropertyInfo item)
			{
				item.EnsureChildOf(_jsonTypeInfo);
			}

			public void SortProperties()
			{
				_list.StableSortByKey((JsonPropertyInfo propInfo) => propInfo.Order);
			}

			public void AddPropertyWithConflictResolution(JsonPropertyInfo jsonPropertyInfo, ref PropertyHierarchyResolutionState state)
			{
				string memberName = jsonPropertyInfo.MemberName;
				if (JsonHelpers.TryAdd(state.AddedProperties, jsonPropertyInfo.Name, (jsonPropertyInfo, base.Count)))
				{
					Add(jsonPropertyInfo);
					state.IsPropertyOrderSpecified |= jsonPropertyInfo.Order != 0;
				}
				else
				{
					var (jsonPropertyInfo2, num) = state.AddedProperties[jsonPropertyInfo.Name];
					if (jsonPropertyInfo2.IsIgnored)
					{
						state.AddedProperties[jsonPropertyInfo.Name] = (jsonPropertyInfo, num);
						base[num] = jsonPropertyInfo;
						state.IsPropertyOrderSpecified |= jsonPropertyInfo.Order != 0;
					}
					else if (!jsonPropertyInfo.IsIgnored && !jsonPropertyInfo.IsOverriddenOrShadowedBy(jsonPropertyInfo2))
					{
						Dictionary<string, JsonPropertyInfo> ignoredProperties = state.IgnoredProperties;
						if (ignoredProperties == null || !ignoredProperties.TryGetValue(memberName, out var value) || !jsonPropertyInfo.IsOverriddenOrShadowedBy(value))
						{
							ThrowHelper.ThrowInvalidOperationException_SerializerPropertyNameConflict(_jsonTypeInfo.Type, jsonPropertyInfo.Name);
						}
					}
				}
				if (jsonPropertyInfo.IsIgnored)
				{
					ref Dictionary<string, JsonPropertyInfo> ignoredProperties2 = ref state.IgnoredProperties;
					(ignoredProperties2 ?? (ignoredProperties2 = new Dictionary<string, JsonPropertyInfo>()))[memberName] = jsonPropertyInfo;
				}
			}
		}

		internal static readonly Type ObjectType = typeof(object);

		private const int PropertyNameKeyLength = 7;

		private const int ParameterNameCountCacheThreshold = 32;

		private const int PropertyNameCountCacheThreshold = 64;

		private volatile ParameterRef[] _parameterRefsSorted;

		private volatile PropertyRef[] _propertyRefsSorted;

		internal const string MetadataFactoryRequiresUnreferencedCode = "JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.";

		internal const string JsonObjectTypeName = "System.Text.Json.Nodes.JsonObject";

		private Action<object> _onSerializing;

		private Action<object> _onSerialized;

		private Action<object> _onDeserializing;

		private Action<object> _onDeserialized;

		private protected Func<object> _createObject;

		private Func<JsonSerializerContext, JsonPropertyInfo[]> _sourceGenDelayedPropertyInitializer;

		private JsonPropertyInfoList _properties;

		private protected JsonPolymorphismOptions _polymorphismOptions;

		private JsonTypeInfo _elementTypeInfo;

		private JsonTypeInfo _keyTypeInfo;

		private JsonNumberHandling? _numberHandling;

		private JsonUnmappedMemberHandling? _unmappedMemberHandling;

		private JsonObjectCreationHandling? _preferredPropertyObjectCreationHandling;

		private IJsonTypeInfoResolver _originatingResolver;

		private volatile ConfigurationState _configurationState;

		private ExceptionDispatchInfo _cachedConfigureError;

		private JsonTypeInfo _ancestorPolymorhicType;

		private volatile bool _isAncestorPolymorphicTypeResolved;

		internal int ParameterCount { get; private set; }

		internal JsonPropertyDictionary<JsonParameterInfo>? ParameterCache { get; private set; }

		internal bool UsesParameterizedConstructor => ParameterCache != null;

		internal JsonPropertyDictionary<JsonPropertyInfo>? PropertyCache { get; private set; }

		internal int NumberOfRequiredProperties { get; private set; }

		public Func<object>? CreateObject
		{
			get
			{
				return _createObject;
			}
			set
			{
				SetCreateObject(value);
			}
		}

		internal Func<object>? CreateObjectForExtensionDataProperty { get; set; }

		public Action<object>? OnSerializing
		{
			get
			{
				return _onSerializing;
			}
			set
			{
				VerifyMutable();
				if (Kind != JsonTypeInfoKind.Object)
				{
					ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(Kind);
				}
				_onSerializing = value;
			}
		}

		public Action<object>? OnSerialized
		{
			get
			{
				return _onSerialized;
			}
			set
			{
				VerifyMutable();
				if (Kind != JsonTypeInfoKind.Object)
				{
					ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(Kind);
				}
				_onSerialized = value;
			}
		}

		public Action<object>? OnDeserializing
		{
			get
			{
				return _onDeserializing;
			}
			set
			{
				VerifyMutable();
				if (Kind != JsonTypeInfoKind.Object)
				{
					ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(Kind);
				}
				_onDeserializing = value;
			}
		}

		public Action<object>? OnDeserialized
		{
			get
			{
				return _onDeserialized;
			}
			set
			{
				VerifyMutable();
				if (Kind != JsonTypeInfoKind.Object)
				{
					ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(Kind);
				}
				_onDeserialized = value;
			}
		}

		public IList<JsonPropertyInfo> Properties => PropertyList;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		internal JsonPropertyInfoList PropertyList
		{
			get
			{
				return _properties ?? CreatePropertyList();
				JsonPropertyInfoList CreatePropertyList()
				{
					JsonPropertyInfoList jsonPropertyInfoList = new JsonPropertyInfoList(this);
					Func<JsonSerializerContext, JsonPropertyInfo[]> sourceGenDelayedPropertyInitializer = _sourceGenDelayedPropertyInitializer;
					if (sourceGenDelayedPropertyInitializer != null)
					{
						JsonMetadataServices.PopulateProperties(this, jsonPropertyInfoList, sourceGenDelayedPropertyInitializer);
					}
					JsonPropertyInfoList jsonPropertyInfoList2 = Interlocked.CompareExchange(ref _properties, jsonPropertyInfoList, null);
					_sourceGenDelayedPropertyInitializer = null;
					return jsonPropertyInfoList2 ?? jsonPropertyInfoList;
				}
			}
		}

		internal Func<JsonSerializerContext, JsonPropertyInfo[]>? SourceGenDelayedPropertyInitializer
		{
			get
			{
				return _sourceGenDelayedPropertyInitializer;
			}
			set
			{
				_sourceGenDelayedPropertyInitializer = value;
			}
		}

		public JsonPolymorphismOptions? PolymorphismOptions
		{
			get
			{
				return _polymorphismOptions;
			}
			set
			{
				VerifyMutable();
				if (value != null)
				{
					if (Kind == JsonTypeInfoKind.None)
					{
						ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(Kind);
					}
					if (value.DeclaringTypeInfo != null && value.DeclaringTypeInfo != this)
					{
						ThrowHelper.ThrowArgumentException_JsonPolymorphismOptionsAssociatedWithDifferentJsonTypeInfo("value");
					}
					value.DeclaringTypeInfo = this;
				}
				_polymorphismOptions = value;
			}
		}

		public bool IsReadOnly { get; private set; }

		internal object? CreateObjectWithArgs { get; set; }

		internal object? AddMethodDelegate { get; set; }

		internal JsonPropertyInfo? ExtensionDataProperty { get; private set; }

		internal PolymorphicTypeResolver? PolymorphicTypeResolver { get; private set; }

		internal bool HasSerializeHandler { get; private protected set; }

		internal bool CanUseSerializeHandler { get; private set; }

		internal bool PropertyMetadataSerializationNotSupported { get; set; }

		internal Type? ElementType { get; }

		internal Type? KeyType { get; }

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		internal JsonTypeInfo? ElementTypeInfo
		{
			get
			{
				JsonTypeInfo elementTypeInfo = _elementTypeInfo;
				elementTypeInfo?.EnsureConfigured();
				return elementTypeInfo;
			}
			set
			{
				_elementTypeInfo = value;
			}
		}

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		internal JsonTypeInfo? KeyTypeInfo
		{
			get
			{
				JsonTypeInfo keyTypeInfo = _keyTypeInfo;
				keyTypeInfo?.EnsureConfigured();
				return keyTypeInfo;
			}
			set
			{
				_keyTypeInfo = value;
			}
		}

		public JsonSerializerOptions Options { get; }

		public Type Type { get; }

		public JsonConverter Converter { get; }

		public JsonTypeInfoKind Kind { get; private set; }

		internal JsonPropertyInfo PropertyInfoForTypeInfo { get; }

		public JsonNumberHandling? NumberHandling
		{
			get
			{
				return _numberHandling;
			}
			set
			{
				VerifyMutable();
				if (value.HasValue && !JsonSerializer.IsValidNumberHandlingValue(value.Value))
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_numberHandling = value;
			}
		}

		public JsonUnmappedMemberHandling? UnmappedMemberHandling
		{
			get
			{
				return _unmappedMemberHandling;
			}
			set
			{
				VerifyMutable();
				if (Kind != JsonTypeInfoKind.Object)
				{
					ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(Kind);
				}
				if (value.HasValue && !JsonSerializer.IsValidUnmappedMemberHandlingValue(value.Value))
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_unmappedMemberHandling = value;
			}
		}

		internal JsonUnmappedMemberHandling EffectiveUnmappedMemberHandling { get; private set; }

		public JsonObjectCreationHandling? PreferredPropertyObjectCreationHandling
		{
			get
			{
				return _preferredPropertyObjectCreationHandling;
			}
			set
			{
				VerifyMutable();
				if (Kind != JsonTypeInfoKind.Object)
				{
					ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(Kind);
				}
				if (value.HasValue && !JsonSerializer.IsValidCreationHandlingValue(value.Value))
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_preferredPropertyObjectCreationHandling = value;
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public IJsonTypeInfoResolver? OriginatingResolver
		{
			get
			{
				return _originatingResolver;
			}
			set
			{
				VerifyMutable();
				if (value is JsonSerializerContext)
				{
					IsCustomized = false;
				}
				_originatingResolver = value;
			}
		}

		internal bool IsCustomized { get; set; } = true;

		internal bool IsConfigured => _configurationState == ConfigurationState.Configured;

		internal bool IsConfigurationStarted => _configurationState != ConfigurationState.NotConfigured;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		internal JsonTypeInfo? AncestorPolymorphicType
		{
			get
			{
				if (!_isAncestorPolymorphicTypeResolved)
				{
					_ancestorPolymorhicType = System.Text.Json.Serialization.Metadata.PolymorphicTypeResolver.FindNearestPolymorphicBaseType(this);
					_isAncestorPolymorphicTypeResolved = true;
				}
				return _ancestorPolymorhicType;
			}
		}

		private bool IsCompatibleWithCurrentOptions { get; set; } = true;

		internal JsonParameterInfoValues[]? ParameterInfoValues { get; set; }

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		internal bool SupportsPolymorphicDeserialization => PolymorphicTypeResolver?.UsesTypeDiscriminators ?? false;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private string DebuggerDisplay => $"Type = {Type.Name}, Kind = {Kind}";

		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		internal JsonPropertyInfo CreatePropertyUsingReflection(Type propertyType, Type declaringType)
		{
			if (Options.TryGetTypeInfoCached(propertyType, out var typeInfo))
			{
				return typeInfo.CreateJsonPropertyInfo(this, declaringType, Options);
			}
			Type type = typeof(JsonPropertyInfo<>).MakeGenericType(propertyType);
			return (JsonPropertyInfo)type.CreateInstanceNoWrapExceptions(new Type[3]
			{
				typeof(Type),
				typeof(JsonTypeInfo),
				typeof(JsonSerializerOptions)
			}, new object[3]
			{
				declaringType ?? Type,
				this,
				Options
			});
		}

		private protected abstract JsonPropertyInfo CreateJsonPropertyInfo(JsonTypeInfo declaringTypeInfo, Type declaringType, JsonSerializerOptions options);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal JsonPropertyInfo GetProperty(ReadOnlySpan<byte> propertyName, ref ReadStackFrame frame, out byte[] utf8PropertyName)
		{
			ValidateCanBeUsedForPropertyMetadataSerialization();
			ulong key = GetKey(propertyName);
			PropertyRef[] propertyRefsSorted = _propertyRefsSorted;
			if (propertyRefsSorted != null)
			{
				int propertyIndex = frame.PropertyIndex;
				int num = propertyRefsSorted.Length;
				int num2 = Math.Min(propertyIndex, num);
				int num3 = num2 - 1;
				while (true)
				{
					if (num2 < num)
					{
						PropertyRef propertyRef = propertyRefsSorted[num2];
						if (IsPropertyRefEqual(in propertyRef, propertyName, key))
						{
							utf8PropertyName = propertyRef.NameFromJson;
							return propertyRef.Info;
						}
						num2++;
						if (num3 >= 0)
						{
							propertyRef = propertyRefsSorted[num3];
							if (IsPropertyRefEqual(in propertyRef, propertyName, key))
							{
								utf8PropertyName = propertyRef.NameFromJson;
								return propertyRef.Info;
							}
							num3--;
						}
					}
					else
					{
						if (num3 < 0)
						{
							break;
						}
						PropertyRef propertyRef = propertyRefsSorted[num3];
						if (IsPropertyRefEqual(in propertyRef, propertyName, key))
						{
							utf8PropertyName = propertyRef.NameFromJson;
							return propertyRef.Info;
						}
						num3--;
					}
				}
			}
			if (PropertyCache.TryGetValue(JsonHelpers.Utf8GetString(propertyName), out JsonPropertyInfo value))
			{
				if (Options.PropertyNameCaseInsensitive)
				{
					if (propertyName.SequenceEqual(value.NameAsUtf8Bytes))
					{
						utf8PropertyName = value.NameAsUtf8Bytes;
					}
					else
					{
						utf8PropertyName = propertyName.ToArray();
					}
				}
				else
				{
					utf8PropertyName = value.NameAsUtf8Bytes;
				}
			}
			else
			{
				value = JsonPropertyInfo.s_missingProperty;
				utf8PropertyName = propertyName.ToArray();
			}
			int num4 = 0;
			if (propertyRefsSorted != null)
			{
				num4 = propertyRefsSorted.Length;
			}
			if (num4 < 64)
			{
				if (frame.PropertyRefCache != null)
				{
					num4 += frame.PropertyRefCache.Count;
				}
				if (num4 < 64)
				{
					ref List<PropertyRef> propertyRefCache = ref frame.PropertyRefCache;
					if (propertyRefCache == null)
					{
						propertyRefCache = new List<PropertyRef>();
					}
					PropertyRef propertyRef = new PropertyRef(key, value, utf8PropertyName);
					frame.PropertyRefCache.Add(propertyRef);
				}
			}
			return value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal JsonParameterInfo GetParameter(ReadOnlySpan<byte> propertyName, ref ReadStackFrame frame, out byte[] utf8PropertyName)
		{
			ulong key = GetKey(propertyName);
			ParameterRef[] parameterRefsSorted = _parameterRefsSorted;
			if (parameterRefsSorted != null)
			{
				int parameterIndex = frame.CtorArgumentState.ParameterIndex;
				int num = parameterRefsSorted.Length;
				int num2 = Math.Min(parameterIndex, num);
				int num3 = num2 - 1;
				while (true)
				{
					if (num2 < num)
					{
						ParameterRef parameterRef = parameterRefsSorted[num2];
						if (IsParameterRefEqual(in parameterRef, propertyName, key))
						{
							utf8PropertyName = parameterRef.NameFromJson;
							return parameterRef.Info;
						}
						num2++;
						if (num3 >= 0)
						{
							parameterRef = parameterRefsSorted[num3];
							if (IsParameterRefEqual(in parameterRef, propertyName, key))
							{
								utf8PropertyName = parameterRef.NameFromJson;
								return parameterRef.Info;
							}
							num3--;
						}
					}
					else
					{
						if (num3 < 0)
						{
							break;
						}
						ParameterRef parameterRef = parameterRefsSorted[num3];
						if (IsParameterRefEqual(in parameterRef, propertyName, key))
						{
							utf8PropertyName = parameterRef.NameFromJson;
							return parameterRef.Info;
						}
						num3--;
					}
				}
			}
			if (ParameterCache.TryGetValue(JsonHelpers.Utf8GetString(propertyName), out JsonParameterInfo value))
			{
				if (Options.PropertyNameCaseInsensitive)
				{
					if (propertyName.SequenceEqual(value.NameAsUtf8Bytes))
					{
						utf8PropertyName = value.NameAsUtf8Bytes;
					}
					else
					{
						utf8PropertyName = propertyName.ToArray();
					}
				}
				else
				{
					utf8PropertyName = value.NameAsUtf8Bytes;
				}
			}
			else
			{
				utf8PropertyName = propertyName.ToArray();
			}
			int num4 = 0;
			if (parameterRefsSorted != null)
			{
				num4 = parameterRefsSorted.Length;
			}
			if (num4 < 32)
			{
				if (frame.CtorArgumentState.ParameterRefCache != null)
				{
					num4 += frame.CtorArgumentState.ParameterRefCache.Count;
				}
				if (num4 < 32)
				{
					ArgumentState ctorArgumentState = frame.CtorArgumentState;
					if (ctorArgumentState.ParameterRefCache == null)
					{
						ctorArgumentState.ParameterRefCache = new List<ParameterRef>();
					}
					ParameterRef parameterRef = new ParameterRef(key, value, utf8PropertyName);
					frame.CtorArgumentState.ParameterRefCache.Add(parameterRef);
				}
			}
			return value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static bool IsPropertyRefEqual(in PropertyRef propertyRef, ReadOnlySpan<byte> propertyName, ulong key)
		{
			if (key == propertyRef.Key && (propertyName.Length <= 7 || propertyName.SequenceEqual(propertyRef.NameFromJson)))
			{
				return true;
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static bool IsParameterRefEqual(in ParameterRef parameterRef, ReadOnlySpan<byte> parameterName, ulong key)
		{
			if (key == parameterRef.Key && (parameterName.Length <= 7 || parameterName.SequenceEqual(parameterRef.NameFromJson)))
			{
				return true;
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetKey(ReadOnlySpan<byte> name)
		{
			ref byte reference = ref MemoryMarshal.GetReference(name);
			int length = name.Length;
			ulong num;
			if (length > 7)
			{
				num = Unsafe.ReadUnaligned<ulong>(ref reference) & 0xFFFFFFFFFFFFFFL;
				num |= (ulong)((long)Math.Min(length, 255) << 56);
			}
			else
			{
				num = ((length > 5) ? (Unsafe.ReadUnaligned<uint>(ref reference) | ((ulong)Unsafe.ReadUnaligned<ushort>(ref Unsafe.Add(ref reference, 4)) << 32)) : ((length > 3) ? ((ulong)Unsafe.ReadUnaligned<uint>(ref reference)) : ((ulong)((length > 1) ? Unsafe.ReadUnaligned<ushort>(ref reference) : 0))));
				num |= (ulong)((long)length << 56);
				if ((length & 1) != 0)
				{
					int num2 = length - 1;
					num |= (ulong)Unsafe.Add(ref reference, num2) << num2 * 8;
				}
			}
			return num;
		}

		internal void UpdateSortedPropertyCache(ref ReadStackFrame frame)
		{
			List<PropertyRef> propertyRefCache = frame.PropertyRefCache;
			if (_propertyRefsSorted != null)
			{
				List<PropertyRef> list = new List<PropertyRef>(_propertyRefsSorted);
				while (list.Count + propertyRefCache.Count > 64)
				{
					propertyRefCache.RemoveAt(propertyRefCache.Count - 1);
				}
				list.AddRange(propertyRefCache);
				_propertyRefsSorted = list.ToArray();
			}
			else
			{
				_propertyRefsSorted = propertyRefCache.ToArray();
			}
			frame.PropertyRefCache = null;
		}

		internal void UpdateSortedParameterCache(ref ReadStackFrame frame)
		{
			List<ParameterRef> parameterRefCache = frame.CtorArgumentState.ParameterRefCache;
			if (_parameterRefsSorted != null)
			{
				List<ParameterRef> list = new List<ParameterRef>(_parameterRefsSorted);
				while (list.Count + parameterRefCache.Count > 32)
				{
					parameterRefCache.RemoveAt(parameterRefCache.Count - 1);
				}
				list.AddRange(parameterRefCache);
				_parameterRefsSorted = list.ToArray();
			}
			else
			{
				_parameterRefsSorted = parameterRefCache.ToArray();
			}
			frame.CtorArgumentState.ParameterRefCache = null;
		}

		internal JsonTypeInfo(Type type, JsonConverter converter, JsonSerializerOptions options)
		{
			Type = type;
			Options = options;
			Converter = converter;
			Kind = GetTypeInfoKind(type, converter);
			PropertyInfoForTypeInfo = CreatePropertyInfoForTypeInfo();
			ElementType = converter.ElementType;
			KeyType = converter.KeyType;
		}

		private protected abstract void SetCreateObject(Delegate createObject);

		public void MakeReadOnly()
		{
			IsReadOnly = true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ValidateCanBeUsedForPropertyMetadataSerialization()
		{
			if (PropertyMetadataSerializationNotSupported)
			{
				ThrowHelper.ThrowInvalidOperationException_NoMetadataForTypeProperties(Options.TypeInfoResolver, Type);
			}
		}

		private protected abstract JsonPropertyInfo CreatePropertyInfoForTypeInfo();

		internal void VerifyMutable()
		{
			if (IsReadOnly)
			{
				ThrowHelper.ThrowInvalidOperationException_TypeInfoImmutable();
			}
			IsCustomized = true;
		}

		internal void EnsureConfigured()
		{
			if (!IsConfigured)
			{
				ConfigureSynchronized();
			}
			void ConfigureSynchronized()
			{
				Options.MakeReadOnly();
				MakeReadOnly();
				_cachedConfigureError?.Throw();
				lock (Options.CacheContext)
				{
					if (_configurationState != ConfigurationState.NotConfigured)
					{
						return;
					}
					_cachedConfigureError?.Throw();
					try
					{
						_configurationState = ConfigurationState.Configuring;
						Configure();
						_configurationState = ConfigurationState.Configured;
					}
					catch (Exception source)
					{
						_cachedConfigureError = ExceptionDispatchInfo.Capture(source);
						_configurationState = ConfigurationState.NotConfigured;
						throw;
					}
				}
			}
		}

		private void Configure()
		{
			PropertyInfoForTypeInfo.Configure();
			if (PolymorphismOptions != null)
			{
				PolymorphicTypeResolver = new PolymorphicTypeResolver(Options, PolymorphismOptions, Type, Converter.CanHaveMetadata);
			}
			if (Kind == JsonTypeInfoKind.Object)
			{
				ConfigureProperties();
				if (DetermineUsesParameterizedConstructor())
				{
					ConfigureConstructorParameters();
				}
			}
			if (ElementType != null)
			{
				if (_elementTypeInfo == null)
				{
					_elementTypeInfo = Options.GetTypeInfoInternal(ElementType, ensureConfigured: true, true);
				}
				_elementTypeInfo.EnsureConfigured();
			}
			if (KeyType != null)
			{
				if (_keyTypeInfo == null)
				{
					_keyTypeInfo = Options.GetTypeInfoInternal(KeyType, ensureConfigured: true, true);
				}
				_keyTypeInfo.EnsureConfigured();
			}
			DetermineIsCompatibleWithCurrentOptions();
			CanUseSerializeHandler = HasSerializeHandler && IsCompatibleWithCurrentOptions;
		}

		private void DetermineIsCompatibleWithCurrentOptions()
		{
			if (!IsCurrentNodeCompatible())
			{
				IsCompatibleWithCurrentOptions = false;
				return;
			}
			if (_properties != null)
			{
				foreach (JsonPropertyInfo property in _properties)
				{
					if (property.IsPropertyTypeInfoConfigured && !property.JsonTypeInfo.IsCompatibleWithCurrentOptions)
					{
						IsCompatibleWithCurrentOptions = false;
						return;
					}
				}
			}
			JsonTypeInfo elementTypeInfo = _elementTypeInfo;
			if (elementTypeInfo == null || elementTypeInfo.IsCompatibleWithCurrentOptions)
			{
				JsonTypeInfo keyTypeInfo = _keyTypeInfo;
				if (keyTypeInfo == null || keyTypeInfo.IsCompatibleWithCurrentOptions)
				{
					return;
				}
			}
			IsCompatibleWithCurrentOptions = false;
			bool IsCurrentNodeCompatible()
			{
				if (Options.CanUseFastPathSerializationLogic)
				{
					return true;
				}
				if (IsCustomized)
				{
					return false;
				}
				return OriginatingResolver.IsCompatibleWithOptions(Options);
			}
		}

		internal bool DetermineUsesParameterizedConstructor()
		{
			if (Converter.ConstructorIsParameterized)
			{
				return CreateObject == null;
			}
			return false;
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static JsonTypeInfo<T> CreateJsonTypeInfo<T>(JsonSerializerOptions options)
		{
			if (options == null)
			{
				ThrowHelper.ThrowArgumentNullException("options");
			}
			JsonConverter converterForType = DefaultJsonTypeInfoResolver.GetConverterForType(typeof(T), options, resolveJsonConverterAttribute: false);
			return new JsonTypeInfo<T>(converterForType, options);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public static JsonTypeInfo CreateJsonTypeInfo(Type type, JsonSerializerOptions options)
		{
			if (type == null)
			{
				ThrowHelper.ThrowArgumentNullException("type");
			}
			if (options == null)
			{
				ThrowHelper.ThrowArgumentNullException("options");
			}
			if (IsInvalidForSerialization(type))
			{
				ThrowHelper.ThrowArgumentException_CannotSerializeInvalidType("type", type, null, null);
			}
			JsonConverter converterForType = DefaultJsonTypeInfoResolver.GetConverterForType(type, options, resolveJsonConverterAttribute: false);
			return CreateJsonTypeInfo(type, converterForType, options);
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		internal static JsonTypeInfo CreateJsonTypeInfo(Type type, JsonConverter converter, JsonSerializerOptions options)
		{
			if (converter.Type == type)
			{
				return converter.CreateJsonTypeInfo(options);
			}
			Type type2 = typeof(JsonTypeInfo<>).MakeGenericType(type);
			return (JsonTypeInfo)type2.CreateInstanceNoWrapExceptions(new Type[2]
			{
				typeof(JsonConverter),
				typeof(JsonSerializerOptions)
			}, new object[2] { converter, options });
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public JsonPropertyInfo CreateJsonPropertyInfo(Type propertyType, string name)
		{
			if (propertyType == null)
			{
				ThrowHelper.ThrowArgumentNullException("propertyType");
			}
			if (name == null)
			{
				ThrowHelper.ThrowArgumentNullException("name");
			}
			if (IsInvalidForSerialization(propertyType))
			{
				ThrowHelper.ThrowArgumentException_CannotSerializeInvalidType("propertyType", propertyType, Type, name);
			}
			VerifyMutable();
			JsonPropertyInfo jsonPropertyInfo = CreatePropertyUsingReflection(propertyType, null);
			jsonPropertyInfo.Name = name;
			return jsonPropertyInfo;
		}

		internal abstract void SerializeAsObject(Utf8JsonWriter writer, object rootValue);

		internal abstract Task SerializeAsObjectAsync(Stream utf8Json, object rootValue, CancellationToken cancellationToken);

		internal abstract void SerializeAsObject(Stream utf8Json, object rootValue);

		internal abstract object DeserializeAsObject(ref Utf8JsonReader reader, ref ReadStack state);

		internal abstract ValueTask<object> DeserializeAsObjectAsync(Stream utf8Json, CancellationToken cancellationToken);

		internal abstract object DeserializeAsObject(Stream utf8Json);

		internal void ConfigureProperties()
		{
			JsonPropertyInfoList propertyList = PropertyList;
			JsonPropertyDictionary<JsonPropertyInfo> jsonPropertyDictionary = CreatePropertyCache(propertyList.Count);
			int numberOfRequiredProperties = 0;
			bool flag = true;
			int num = int.MinValue;
			foreach (JsonPropertyInfo item in propertyList)
			{
				if (item.IsExtensionData)
				{
					JsonUnmappedMemberHandling? unmappedMemberHandling = UnmappedMemberHandling;
					if (unmappedMemberHandling.HasValue && unmappedMemberHandling == JsonUnmappedMemberHandling.Disallow)
					{
						ThrowHelper.ThrowInvalidOperationException_ExtensionDataConflictsWithUnmappedMemberHandling(Type, item);
					}
					if (ExtensionDataProperty != null)
					{
						ThrowHelper.ThrowInvalidOperationException_SerializationDuplicateTypeAttribute(Type, typeof(JsonExtensionDataAttribute));
					}
					ExtensionDataProperty = item;
				}
				else
				{
					if (item.IsRequired)
					{
						item.RequiredPropertyIndex = numberOfRequiredProperties++;
					}
					if (flag)
					{
						flag = num <= item.Order;
						num = item.Order;
					}
					if (!jsonPropertyDictionary.TryAddValue(item.Name, item))
					{
						ThrowHelper.ThrowInvalidOperationException_SerializerPropertyNameConflict(Type, item.Name);
					}
				}
				item.Configure();
			}
			if (!flag)
			{
				propertyList.SortProperties();
				jsonPropertyDictionary.List.StableSortByKey((KeyValuePair<string, JsonPropertyInfo> propInfo) => propInfo.Value.Order);
			}
			NumberOfRequiredProperties = numberOfRequiredProperties;
			PropertyCache = jsonPropertyDictionary;
			EffectiveUnmappedMemberHandling = UnmappedMemberHandling ?? ((ExtensionDataProperty == null) ? Options.UnmappedMemberHandling : JsonUnmappedMemberHandling.Skip);
		}

		internal void ConfigureConstructorParameters()
		{
			JsonParameterInfoValues[] array = ParameterInfoValues ?? Array.Empty<JsonParameterInfoValues>();
			JsonPropertyDictionary<JsonParameterInfo> jsonPropertyDictionary = new JsonPropertyDictionary<JsonParameterInfo>(Options.PropertyNameCaseInsensitive, array.Length);
			Dictionary<ParameterLookupKey, ParameterLookupValue> dictionary = new Dictionary<ParameterLookupKey, ParameterLookupValue>(PropertyCache.Count);
			foreach (KeyValuePair<string, JsonPropertyInfo> item in PropertyCache.List)
			{
				JsonPropertyInfo value = item.Value;
				string text = value.MemberName ?? value.Name;
				ParameterLookupKey key = new ParameterLookupKey(text, value.PropertyType);
				ParameterLookupValue value2 = new ParameterLookupValue(value);
				if (!JsonHelpers.TryAdd(dictionary, key, value2))
				{
					ParameterLookupValue parameterLookupValue = dictionary[key];
					parameterLookupValue.DuplicateName = text;
				}
			}
			JsonParameterInfoValues[] array2 = array;
			foreach (JsonParameterInfoValues jsonParameterInfoValues in array2)
			{
				ParameterLookupKey parameterLookupKey = new ParameterLookupKey(jsonParameterInfoValues.Name, jsonParameterInfoValues.ParameterType);
				if (dictionary.TryGetValue(parameterLookupKey, out var value3))
				{
					if (value3.DuplicateName != null)
					{
						ThrowHelper.ThrowInvalidOperationException_MultiplePropertiesBindToConstructorParameters(Type, jsonParameterInfoValues.Name, value3.JsonPropertyInfo.Name, value3.DuplicateName);
					}
					JsonPropertyInfo jsonPropertyInfo = value3.JsonPropertyInfo;
					JsonParameterInfo value4 = jsonPropertyInfo.CreateJsonParameterInfo(jsonParameterInfoValues);
					jsonPropertyDictionary.Add(jsonPropertyInfo.Name, value4);
				}
				else if (ExtensionDataProperty != null && StringComparer.OrdinalIgnoreCase.Equals(parameterLookupKey.Name, ExtensionDataProperty.Name))
				{
					ThrowHelper.ThrowInvalidOperationException_ExtensionDataCannotBindToCtorParam(ExtensionDataProperty.MemberName, ExtensionDataProperty);
				}
			}
			ParameterCount = array.Length;
			ParameterCache = jsonPropertyDictionary;
			ParameterInfoValues = null;
		}

		internal static void ValidateType(Type type)
		{
			if (IsInvalidForSerialization(type))
			{
				ThrowHelper.ThrowInvalidOperationException_CannotSerializeInvalidType(type, null, null);
			}
		}

		internal static bool IsInvalidForSerialization(Type type)
		{
			if (!(type == typeof(void)) && !type.IsPointer && !type.IsByRef && !IsByRefLike(type))
			{
				return type.ContainsGenericParameters;
			}
			return true;
		}

		internal void PopulatePolymorphismMetadata()
		{
			JsonPolymorphismOptions jsonPolymorphismOptions = JsonPolymorphismOptions.CreateFromAttributeDeclarations(Type);
			if (jsonPolymorphismOptions != null)
			{
				jsonPolymorphismOptions.DeclaringTypeInfo = this;
				_polymorphismOptions = jsonPolymorphismOptions;
			}
		}

		internal void MapInterfaceTypesToCallbacks()
		{
			if (Kind != JsonTypeInfoKind.Object)
			{
				return;
			}
			if (typeof(IJsonOnSerializing).IsAssignableFrom(Type))
			{
				OnSerializing = delegate(object obj)
				{
					((IJsonOnSerializing)obj).OnSerializing();
				};
			}
			if (typeof(IJsonOnSerialized).IsAssignableFrom(Type))
			{
				OnSerialized = delegate(object obj)
				{
					((IJsonOnSerialized)obj).OnSerialized();
				};
			}
			if (typeof(IJsonOnDeserializing).IsAssignableFrom(Type))
			{
				OnDeserializing = delegate(object obj)
				{
					((IJsonOnDeserializing)obj).OnDeserializing();
				};
			}
			if (typeof(IJsonOnDeserialized).IsAssignableFrom(Type))
			{
				OnDeserialized = delegate(object obj)
				{
					((IJsonOnDeserialized)obj).OnDeserialized();
				};
			}
		}

		internal void SetCreateObjectIfCompatible(Delegate createObject)
		{
			if (Converter.SupportsCreateObjectDelegate && !Converter.ConstructorIsParameterized)
			{
				SetCreateObject(createObject);
			}
		}

		private static bool IsByRefLike(Type type)
		{
			if (!type.IsValueType)
			{
				return false;
			}
			object[] customAttributes = type.GetCustomAttributes(inherit: false);
			for (int i = 0; i < customAttributes.Length; i++)
			{
				if (customAttributes[i].GetType().FullName == "System.Runtime.CompilerServices.IsByRefLikeAttribute")
				{
					return true;
				}
			}
			return false;
		}

		internal static bool IsValidExtensionDataProperty(Type propertyType)
		{
			if (!typeof(IDictionary<string, object>).IsAssignableFrom(propertyType) && !typeof(IDictionary<string, JsonElement>).IsAssignableFrom(propertyType))
			{
				if (propertyType.FullName == "System.Text.Json.Nodes.JsonObject")
				{
					return (object)propertyType.Assembly == typeof(JsonTypeInfo).Assembly;
				}
				return false;
			}
			return true;
		}

		internal JsonPropertyDictionary<JsonPropertyInfo> CreatePropertyCache(int capacity)
		{
			return new JsonPropertyDictionary<JsonPropertyInfo>(Options.PropertyNameCaseInsensitive, capacity);
		}

		private static JsonTypeInfoKind GetTypeInfoKind(Type type, JsonConverter converter)
		{
			if (type == typeof(object) && converter.CanBePolymorphic)
			{
				return JsonTypeInfoKind.None;
			}
			switch (converter.ConverterStrategy)
			{
			case ConverterStrategy.Value:
				return JsonTypeInfoKind.None;
			case ConverterStrategy.Object:
				return JsonTypeInfoKind.Object;
			case ConverterStrategy.Enumerable:
				return JsonTypeInfoKind.Enumerable;
			case ConverterStrategy.Dictionary:
				return JsonTypeInfoKind.Dictionary;
			case ConverterStrategy.None:
				ThrowHelper.ThrowNotSupportedException_SerializationNotSupported(type);
				return JsonTypeInfoKind.None;
			default:
				throw new InvalidOperationException();
			}
		}
	}
	internal abstract class MemberAccessor
	{
		public abstract Func<object> CreateParameterlessConstructor([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] Type type, ConstructorInfo constructorInfo);

		public abstract Func<object[], T> CreateParameterizedConstructor<T>(ConstructorInfo constructor);

		public abstract JsonTypeInfo.ParameterizedConstructorDelegate<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor<T, TArg0, TArg1, TArg2, TArg3>(ConstructorInfo constructor);

		public abstract Action<TCollection, object> CreateAddMethodDelegate<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TCollection>();

		[RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		[RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		public abstract Func<IEnumerable<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate<TCollection, TElement>();

		[RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		[RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		public abstract Func<IEnumerable<KeyValuePair<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate<TCollection, TKey, TValue>();

		public abstract Func<object, TProperty> CreatePropertyGetter<TProperty>(PropertyInfo propertyInfo);

		public abstract Action<object, TProperty> CreatePropertySetter<TProperty>(PropertyInfo propertyInfo);

		public abstract Func<object, TProperty> CreateFieldGetter<TProperty>(FieldInfo fieldInfo);

		public abstract Action<object, TProperty> CreateFieldSetter<TProperty>(FieldInfo fieldInfo);
	}
	internal readonly struct ParameterRef
	{
		public readonly ulong Key;

		public readonly JsonParameterInfo Info;

		public readonly byte[] NameFromJson;

		public ParameterRef(ulong key, JsonParameterInfo info, byte[] nameFromJson)
		{
			Key = key;
			Info = info;
			NameFromJson = nameFromJson;
		}
	}
	internal sealed class PolymorphicTypeResolver
	{
		private sealed class DerivedJsonTypeInfo
		{
			private volatile JsonTypeInfo _jsonTypeInfo;

			public Type DerivedType { get; }

			public object TypeDiscriminator { get; }

			public DerivedJsonTypeInfo(Type type, object typeDiscriminator)
			{
				DerivedType = type;
				TypeDiscriminator = typeDiscriminator;
			}

			public JsonTypeInfo GetJsonTypeInfo(JsonSerializerOptions options)
			{
				return _jsonTypeInfo ?? (_jsonTypeInfo = options.GetTypeInfoInternal(DerivedType, ensureConfigured: true, true));
			}
		}

		private readonly ConcurrentDictionary<Type, DerivedJsonTypeInfo> _typeToDiscriminatorId = new ConcurrentDictionary<Type, DerivedJsonTypeInfo>();

		private readonly Dictionary<object, DerivedJsonTypeInfo> _discriminatorIdtoType;

		private readonly JsonSerializerOptions _options;

		public Type BaseType { get; }

		public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; }

		public bool UsesTypeDiscriminators { get; }

		public bool IgnoreUnrecognizedTypeDiscriminators { get; }

		public string TypeDiscriminatorPropertyName { get; }

		public byte[] TypeDiscriminatorPropertyNameUtf8 { get; }

		public JsonEncodedText? CustomTypeDiscriminatorPropertyNameJsonEncoded { get; }

		public PolymorphicTypeResolver(JsonSerializerOptions options, JsonPolymorphismOptions polymorphismOptions, Type baseType, bool converterCanHaveMetadata)
		{
			UnknownDerivedTypeHandling = polymorphismOptions.UnknownDerivedTypeHandling;
			IgnoreUnrecognizedTypeDiscriminators = polymorphismOptions.IgnoreUnrecognizedTypeDiscriminators;
			BaseType = baseType;
			_options = options;
			if (!IsSupportedPolymorphicBaseType(BaseType))
			{
				ThrowHelper.ThrowInvalidOperationException_TypeDoesNotSupportPolymorphism(BaseType);
			}
			bool flag = false;
			foreach (var (type2, obj2) in polymorphismOptions.DerivedTypes)
			{
				if (!IsSupportedDerivedType(BaseType, type2) || (type2.IsAbstract && UnknownDerivedTypeHandling != JsonUnknownDerivedTypeHandling.FallBackToNearestAncestor))
				{
					ThrowHelper.ThrowInvalidOperationException_DerivedTypeNotSupported(BaseType, type2);
				}
				DerivedJsonTypeInfo value = new DerivedJsonTypeInfo(type2, obj2);
				if (!_typeToDiscriminatorId.TryAdd(type2, value))
				{
					ThrowHelper.ThrowInvalidOperationException_DerivedTypeIsAlreadySpecified(BaseType, type2);
				}
				if (obj2 != null)
				{
					if (!JsonHelpers.TryAdd(_discriminatorIdtoType ?? (_discriminatorIdtoType = new Dictionary<object, DerivedJsonTypeInfo>()), obj2, value))
					{
						ThrowHelper.ThrowInvalidOperationException_TypeDicriminatorIdIsAlreadySpecified(BaseType, obj2);
					}
					UsesTypeDiscriminators = true;
				}
				flag = true;
			}
			if (!flag)
			{
				ThrowHelper.ThrowInvalidOperationException_PolymorphicTypeConfigurationDoesNotSpecifyDerivedTypes(BaseType);
			}
			if (UsesTypeDiscriminators)
			{
				if (!converterCanHaveMetadata)
				{
					ThrowHelper.ThrowNotSupportedException_BaseConverterDoesNotSupportMetadata(BaseType);
				}
				string typeDiscriminatorPropertyName = polymorphismOptions.TypeDiscriminatorPropertyName;
				JsonEncodedText value2 = ((typeDiscriminatorPropertyName == "$type") ? JsonSerializer.s_metadataType : JsonEncodedText.Encode(typeDiscriminatorPropertyName, options.Encoder));
				if ((JsonSerializer.GetMetadataPropertyName(value2.EncodedUtf8Bytes, null) & ~MetadataPropertyName.Type) != MetadataPropertyName.None)
				{
					ThrowHelper.ThrowInvalidOperationException_InvalidCustomTypeDiscriminatorPropertyName();
				}
				TypeDiscriminatorPropertyName = typeDiscriminatorPropertyName;
				TypeDiscriminatorPropertyNameUtf8 = value2.EncodedUtf8Bytes.ToArray();
				CustomTypeDiscriminatorPropertyNameJsonEncoded = value2;
			}
		}

		public bool TryGetDerivedJsonTypeInfo(Type runtimeType, [NotNullWhen(true)] out JsonTypeInfo jsonTypeInfo, out object typeDiscriminator)
		{
			if (!_typeToDiscriminatorId.TryGetValue(runtimeType, out var value))
			{
				switch (UnknownDerivedTypeHandling)
				{
				case JsonUnknownDerivedTypeHandling.FallBackToNearestAncestor:
					value = CalculateNearestAncestor(runtimeType);
					_typeToDiscriminatorId[runtimeType] = value;
					break;
				case JsonUnknownDerivedTypeHandling.FallBackToBaseType:
					_typeToDiscriminatorId.TryGetValue(BaseType, out value);
					_typeToDiscriminatorId[runtimeType] = value;
					break;
				default:
					if (runtimeType != BaseType)
					{
						ThrowHelper.ThrowNotSupportedException_RuntimeTypeNotSupported(BaseType, runtimeType);
					}
					break;
				}
			}
			if (value == null)
			{
				jsonTypeInfo = null;
				typeDiscriminator = null;
				return false;
			}
			jsonTypeInfo = value.GetJsonTypeInfo(_options);
			typeDiscriminator = value.TypeDiscriminator;
			return true;
		}

		public bool TryGetDerivedJsonTypeInfo(object typeDiscriminator, [NotNullWhen(true)] out JsonTypeInfo jsonTypeInfo)
		{
			if (_discriminatorIdtoType.TryGetValue(typeDiscriminator, out var value))
			{
				jsonTypeInfo = value.GetJsonTypeInfo(_options);
				return true;
			}
			if (!IgnoreUnrecognizedTypeDiscriminators)
			{
				ThrowHelper.ThrowJsonException_UnrecognizedTypeDiscriminator(typeDiscriminator);
			}
			jsonTypeInfo = null;
			return false;
		}

		public static bool IsSupportedPolymorphicBaseType(Type type)
		{
			if (type != null && (type.IsClass || type.IsInterface) && !type.IsSealed && !type.IsGenericTypeDefinition && !type.IsPointer)
			{
				return type != JsonTypeInfo.ObjectType;
			}
			return false;
		}

		public static bool IsSupportedDerivedType(Type baseType, Type derivedType)
		{
			if (baseType.IsAssignableFrom(derivedType))
			{
				return !derivedType.IsGenericTypeDefinition;
			}
			return false;
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern", Justification = "The call to GetInterfaces will cross-reference results with interface types already declared as derived types of the polymorphic base type.")]
		private DerivedJsonTypeInfo CalculateNearestAncestor(Type type)
		{
			if (type == BaseType)
			{
				return null;
			}
			DerivedJsonTypeInfo value = null;
			Type baseType = type.BaseType;
			while (BaseType.IsAssignableFrom(baseType) && !_typeToDiscriminatorId.TryGetValue(baseType, out value))
			{
				baseType = baseType.BaseType;
			}
			if (BaseType.IsInterface)
			{
				Type[] interfaces = type.GetInterfaces();
				foreach (Type type2 in interfaces)
				{
					if (type2 != BaseType && BaseType.IsAssignableFrom(type2) && _typeToDiscriminatorId.TryGetValue(type2, out var value2) && value2 != null)
					{
						if (value == null)
						{
							value = value2;
						}
						else
						{
							ThrowHelper.ThrowNotSupportedException_RuntimeTypeDiamondAmbiguity(BaseType, type, value.DerivedType, value2.DerivedType);
						}
					}
				}
			}
			return value;
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern", Justification = "The call to GetInterfaces will cross-reference results with interface types already declared as derived types of the polymorphic base type.")]
		internal static JsonTypeInfo FindNearestPolymorphicBaseType(JsonTypeInfo typeInfo)
		{
			if (typeInfo.PolymorphismOptions != null)
			{
				return null;
			}
			JsonTypeInfo jsonTypeInfo = null;
			Type baseType = typeInfo.Type.BaseType;
			while (baseType != null)
			{
				JsonTypeInfo jsonTypeInfo2 = ResolveAncestorTypeInfo(baseType, typeInfo.Options);
				if (jsonTypeInfo2?.PolymorphismOptions != null)
				{
					jsonTypeInfo = jsonTypeInfo2;
					break;
				}
				baseType = baseType.BaseType;
			}
			Type[] interfaces = typeInfo.Type.GetInterfaces();
			foreach (Type type in interfaces)
			{
				JsonTypeInfo jsonTypeInfo3 = ResolveAncestorTypeInfo(type, typeInfo.Options);
				if (jsonTypeInfo3?.PolymorphismOptions == null)
				{
					continue;
				}
				if (jsonTypeInfo != null)
				{
					if (jsonTypeInfo.Type.IsAssignableFrom(type))
					{
						jsonTypeInfo = jsonTypeInfo3;
					}
					else if (!type.IsAssignableFrom(jsonTypeInfo.Type))
					{
						return null;
					}
				}
				else
				{
					jsonTypeInfo = jsonTypeInfo3;
				}
			}
			return jsonTypeInfo;
			static JsonTypeInfo ResolveAncestorTypeInfo(Type type2, JsonSerializerOptions options)
			{
				try
				{
					return options.GetTypeInfoInternal(type2, ensureConfigured: true, null);
				}
				catch
				{
					return null;
				}
			}
		}
	}
	internal readonly struct PropertyRef
	{
		public readonly ulong Key;

		public readonly JsonPropertyInfo Info;

		public readonly byte[] NameFromJson;

		public PropertyRef(ulong key, JsonPropertyInfo info, byte[] nameFromJson)
		{
			Key = key;
			Info = info;
			NameFromJson = nameFromJson;
		}
	}
	internal sealed class ReflectionMemberAccessor : MemberAccessor
	{
		public override Func<object> CreateParameterlessConstructor([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] Type type, ConstructorInfo ctorInfo)
		{
			if (type.IsAbstract)
			{
				return null;
			}
			if ((object)ctorInfo == null)
			{
				if (!type.IsValueType)
				{
					return null;
				}
				return () => Activator.CreateInstance(type, nonPublic: false);
			}
			return () => ctorInfo.Invoke(null);
		}

		public override Func<object[], T> CreateParameterizedConstructor<T>(ConstructorInfo constructor)
		{
			Type typeFromHandle = typeof(T);
			int parameterCount = constructor.GetParameters().Length;
			return delegate(object[] arguments)
			{
				object[] array = new object[parameterCount];
				for (int i = 0; i < parameterCount; i++)
				{
					array[i] = arguments[i];
				}
				try
				{
					return (T)constructor.Invoke(array);
				}
				catch (TargetInvocationException ex)
				{
					throw ex.InnerException ?? ex;
				}
			};
		}

		public override JsonTypeInfo.ParameterizedConstructorDelegate<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor<T, TArg0, TArg1, TArg2, TArg3>(ConstructorInfo constructor)
		{
			Type typeFromHandle = typeof(T);
			int parameterCount = constructor.GetParameters().Length;
			return delegate(TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3)
			{
				object[] array = new object[parameterCount];
				for (int i = 0; i < parameterCount; i++)
				{
					switch (i)
					{
					case 0:
						array[0] = arg0;
						break;
					case 1:
						array[1] = arg1;
						break;
					case 2:
						array[2] = arg2;
						break;
					case 3:
						array[3] = arg3;
						break;
					default:
						throw new InvalidOperationException();
					}
				}
				return (T)constructor.Invoke(array);
			};
		}

		public override Action<TCollection, object> CreateAddMethodDelegate<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TCollection>()
		{
			Type typeFromHandle = typeof(TCollection);
			Type objectType = JsonTypeInfo.ObjectType;
			MethodInfo addMethod = typeFromHandle.GetMethod("Push") ?? typeFromHandle.GetMethod("Enqueue");
			return delegate(TCollection collection, object element)
			{
				addMethod.Invoke(collection, new object[1] { element });
			};
		}

		[RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		[RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		public override Func<IEnumerable<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate<TCollection, TElement>()
		{
			MethodInfo immutableEnumerableCreateRangeMethod = typeof(TCollection).GetImmutableEnumerableCreateRangeMethod(typeof(TElement));
			return (Func<IEnumerable<TElement>, TCollection>)immutableEnumerableCreateRangeMethod.CreateDelegate(typeof(Func<IEnumerable<TElement>, TCollection>));
		}

		[RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		[RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		public override Func<IEnumerable<KeyValuePair<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate<TCollection, TKey, TValue>()
		{
			MethodInfo immutableDictionaryCreateRangeMethod = typeof(TCollection).GetImmutableDictionaryCreateRangeMethod(typeof(TKey), typeof(TValue));
			return (Func<IEnumerable<KeyValuePair<TKey, TValue>>, TCollection>)immutableDictionaryCreateRangeMethod.CreateDelegate(typeof(Func<IEnumerable<KeyValuePair<TKey, TValue>>, TCollection>));
		}

		public override Func<object, TProperty> CreatePropertyGetter<TProperty>(PropertyInfo propertyInfo)
		{
			MethodInfo getMethodInfo = propertyInfo.GetMethod;
			return (object obj) => (TProperty)getMethodInfo.Invoke(obj, null);
		}

		public override Action<object, TProperty> CreatePropertySetter<TProperty>(PropertyInfo propertyInfo)
		{
			MethodInfo setMethodInfo = propertyInfo.SetMethod;
			return delegate(object obj, TProperty value)
			{
				setMethodInfo.Invoke(obj, new object[1] { value });
			};
		}

		public override Func<object, TProperty> CreateFieldGetter<TProperty>(FieldInfo fieldInfo)
		{
			return (object obj) => (TProperty)fieldInfo.GetValue(obj);
		}

		public override Action<object, TProperty> CreateFieldSetter<TProperty>(FieldInfo fieldInfo)
		{
			return delegate(object obj, TProperty value)
			{
				fieldInfo.SetValue(obj, value);
			};
		}
	}
}
namespace System.Text.Json.Serialization.Converters
{
	internal sealed class CastingConverter<T> : JsonConverter<T>
	{
		private readonly JsonConverter _sourceConverter;

		internal override Type KeyType => _sourceConverter.KeyType;

		internal override Type ElementType => _sourceConverter.ElementType;

		public override bool HandleNull { get; }

		internal override bool SupportsCreateObjectDelegate => _sourceConverter.SupportsCreateObjectDelegate;

		internal override JsonConverter SourceConverterForCastingConverter => _sourceConverter;

		internal CastingConverter(JsonConverter sourceConverter)
		{
			_sourceConverter = sourceConverter;
			base.IsInternalConverter = sourceConverter.IsInternalConverter;
			base.IsInternalConverterForNumberType = sourceConverter.IsInternalConverterForNumberType;
			base.ConverterStrategy = sourceConverter.ConverterStrategy;
			base.CanBePolymorphic = sourceConverter.CanBePolymorphic;
			base.HandleNullOnRead = sourceConverter.HandleNullOnRead;
			base.HandleNullOnWrite = sourceConverter.HandleNullOnWrite;
			HandleNull = sourceConverter.HandleNullOnWrite;
		}

		public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return JsonSerializer.UnboxOnRead<T>(_sourceConverter.ReadAsObject(ref reader, typeToConvert, options));
		}

		public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
		{
			_sourceConverter.WriteAsObject(writer, value, options);
		}

		internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out T value)
		{
			object value2;
			bool result = _sourceConverter.OnTryReadAsObject(ref reader, typeToConvert, options, ref state, out value2);
			value = JsonSerializer.UnboxOnRead<T>(value2);
			return result;
		}

		internal override bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, ref WriteStack state)
		{
			return _sourceConverter.OnTryWriteAsObject(writer, value, options, ref state);
		}

		public override T ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return JsonSerializer.UnboxOnRead<T>(_sourceConverter.ReadAsPropertyNameAsObject(ref reader, typeToConvert, options));
		}

		internal override T ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return JsonSerializer.UnboxOnRead<T>(_sourceConverter.ReadAsPropertyNameCoreAsObject(ref reader, typeToConvert, options));
		}

		public override void WriteAsPropertyName(Utf8JsonWriter writer, [DisallowNull] T value, JsonSerializerOptions options)
		{
			_sourceConverter.WriteAsPropertyNameAsObject(writer, value, options);
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, T value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			_sourceConverter.WriteAsPropertyNameCoreAsObject(writer, value, options, isWritingExtensionDataProperty);
		}

		internal override T ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
		{
			return JsonSerializer.UnboxOnRead<T>(_sourceConverter.ReadNumberWithCustomHandlingAsObject(ref reader, handling, options));
		}

		internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, T value, JsonNumberHandling handling)
		{
			_sourceConverter.WriteNumberWithCustomHandlingAsObject(writer, value, handling);
		}
	}
	internal sealed class ImmutableDictionaryOfTKeyTValueConverterWithReflection<TCollection, TKey, TValue> : ImmutableDictionaryOfTKeyTValueConverter<TCollection, TKey, TValue> where TCollection : IReadOnlyDictionary<TKey, TValue>
	{
		[RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		[RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		public ImmutableDictionaryOfTKeyTValueConverterWithReflection()
		{
		}

		[RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		[RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		internal override void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
		{
			jsonTypeInfo.CreateObjectWithArgs = DefaultJsonTypeInfoResolver.MemberAccessor.CreateImmutableDictionaryCreateRangeDelegate<TCollection, TKey, TValue>();
		}
	}
	internal sealed class ImmutableEnumerableOfTConverterWithReflection<TCollection, TElement> : ImmutableEnumerableOfTConverter<TCollection, TElement> where TCollection : IEnumerable<TElement>
	{
		[RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		[RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		public ImmutableEnumerableOfTConverterWithReflection()
		{
		}

		[RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		[RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
		internal override void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
		{
			jsonTypeInfo.CreateObjectWithArgs = DefaultJsonTypeInfoResolver.MemberAccessor.CreateImmutableEnumerableCreateRangeDelegate<TCollection, TElement>();
		}
	}
	internal sealed class ReadOnlyMemoryConverter<T> : JsonCollectionConverter<ReadOnlyMemory<T>, T>
	{
		internal override bool CanHaveMetadata => false;

		protected override void Add(in T value, ref ReadStack state)
		{
			((List<T>)state.Current.ReturnValue).Add(value);
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			state.Current.ReturnValue = new List<T>();
		}

		protected override void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
		{
			ReadOnlyMemory<T> readOnlyMemory = MemoryExtensions.AsMemory(((List<T>)state.Current.ReturnValue).ToArray());
			state.Current.ReturnValue = readOnlyMemory;
		}

		protected override bool OnWriteResume(Utf8JsonWriter writer, ReadOnlyMemory<T> value, JsonSerializerOptions options, ref WriteStack state)
		{
			return OnWriteResume(writer, value.Span, options, ref state);
		}

		internal static bool OnWriteResume(Utf8JsonWriter writer, ReadOnlySpan<T> value, JsonSerializerOptions options, ref WriteStack state)
		{
			int i = state.Current.EnumeratorIndex;
			JsonConverter<T> elementConverter = JsonCollectionConverter<ReadOnlyMemory<T>, T>.GetElementConverter(ref state);
			if (elementConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
			{
				for (; i < value.Length; i++)
				{
					elementConverter.Write(writer, value[i], options);
				}
			}
			else
			{
				for (; i < value.Length; i++)
				{
					if (!elementConverter.TryWrite(writer, in value[i], options, ref state))
					{
						state.Current.EnumeratorIndex = i;
						return false;
					}
					state.Current.EndCollectionElement();
					if (JsonConverter.ShouldFlush(writer, ref state))
					{
						i = (state.Current.EnumeratorIndex = i + 1);
						return false;
					}
				}
			}
			return true;
		}
	}
	[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
	internal sealed class MemoryConverterFactory : JsonConverterFactory
	{
		public override bool CanConvert(Type typeToConvert)
		{
			if (!typeToConvert.IsGenericType || !typeToConvert.IsValueType)
			{
				return false;
			}
			Type genericTypeDefinition = typeToConvert.GetGenericTypeDefinition();
			if (!(genericTypeDefinition == typeof(Memory<>)))
			{
				return genericTypeDefinition == typeof(ReadOnlyMemory<>);
			}
			return true;
		}

		public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
		{
			Type type = ((typeToConvert.GetGenericTypeDefinition() == typeof(Memory<>)) ? typeof(MemoryConverter<>) : typeof(ReadOnlyMemoryConverter<>));
			Type type2 = typeToConvert.GetGenericArguments()[0];
			return (JsonConverter)Activator.CreateInstance(type.MakeGenericType(type2));
		}
	}
	internal sealed class StackOrQueueConverterWithReflection<TCollection> : StackOrQueueConverter<TCollection> where TCollection : IEnumerable
	{
		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public StackOrQueueConverterWithReflection()
		{
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		internal override void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
		{
			jsonTypeInfo.AddMethodDelegate = DefaultJsonTypeInfoResolver.MemberAccessor.CreateAddMethodDelegate<TCollection>();
		}
	}
	internal sealed class JsonMetadataServicesConverter<T> : JsonResumableConverter<T>
	{
		internal JsonConverter<T> Converter { get; }

		internal override Type KeyType => Converter.KeyType;

		internal override Type ElementType => Converter.ElementType;

		internal override bool ConstructorIsParameterized => Converter.ConstructorIsParameterized;

		internal override bool SupportsCreateObjectDelegate => Converter.SupportsCreateObjectDelegate;

		internal override bool CanHaveMetadata => Converter.CanHaveMetadata;

		internal override bool CanPopulate => Converter.CanPopulate;

		public JsonMetadataServicesConverter(JsonConverter<T> converter)
		{
			base.ConverterStrategy = converter.ConverterStrategy;
			Converter = converter;
		}

		internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out T value)
		{
			return Converter.OnTryRead(ref reader, typeToConvert, options, ref state, out value);
		}

		internal override bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, ref WriteStack state)
		{
			JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
			if (!state.SupportContinuation && jsonTypeInfo.CanUseSerializeHandler && !JsonHelpers.RequiresSpecialNumberHandlingOnWrite(state.Current.NumberHandling) && !state.CurrentContainsMetadata)
			{
				((JsonTypeInfo<T>)jsonTypeInfo).SerializeHandler(writer, value);
				return true;
			}
			return Converter.OnTryWrite(writer, value, options, ref state);
		}

		internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
		{
			Converter.ConfigureJsonTypeInfo(jsonTypeInfo, options);
		}
	}
	internal sealed class LargeObjectWithParameterizedConstructorConverterWithReflection<T> : LargeObjectWithParameterizedConstructorConverter<T>
	{
		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		public LargeObjectWithParameterizedConstructorConverterWithReflection()
		{
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		internal override void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
		{
			jsonTypeInfo.CreateObjectWithArgs = DefaultJsonTypeInfoResolver.MemberAccessor.CreateParameterizedConstructor<T>(base.ConstructorInfo);
		}
	}
	internal sealed class MemoryConverter<T> : JsonCollectionConverter<Memory<T>, T>
	{
		internal override bool CanHaveMetadata => false;

		protected override void Add(in T value, ref ReadStack state)
		{
			((List<T>)state.Current.ReturnValue).Add(value);
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			state.Current.ReturnValue = new List<T>();
		}

		protected override void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
		{
			Memory<T> memory = MemoryExtensions.AsMemory(((List<T>)state.Current.ReturnValue).ToArray());
			state.Current.ReturnValue = memory;
		}

		protected override bool OnWriteResume(Utf8JsonWriter writer, Memory<T> value, JsonSerializerOptions options, ref WriteStack state)
		{
			return ReadOnlyMemoryConverter<T>.OnWriteResume(writer, value.Span, options, ref state);
		}
	}
	internal sealed class ReadOnlyMemoryByteConverter : JsonConverter<ReadOnlyMemory<byte>>
	{
		public override ReadOnlyMemory<byte> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetBytesFromBase64();
		}

		public override void Write(Utf8JsonWriter writer, ReadOnlyMemory<byte> value, JsonSerializerOptions options)
		{
			writer.WriteBase64StringValue(value.Span);
		}
	}
	internal sealed class MemoryByteConverter : JsonConverter<Memory<byte>>
	{
		public override Memory<byte> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetBytesFromBase64();
		}

		public override void Write(Utf8JsonWriter writer, Memory<byte> value, JsonSerializerOptions options)
		{
			writer.WriteBase64StringValue(value.Span);
		}
	}
	internal abstract class JsonPrimitiveConverter<T> : JsonConverter<T>
	{
		public sealed override void WriteAsPropertyName(Utf8JsonWriter writer, [DisallowNull] T value, JsonSerializerOptions options)
		{
			if (value == null)
			{
				ThrowHelper.ThrowArgumentNullException("value");
			}
			WriteAsPropertyNameCore(writer, value, options, isWritingExtensionDataProperty: false);
		}

		public sealed override T ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedPropertyName(reader.TokenType);
			}
			return ReadAsPropertyNameCore(ref reader, typeToConvert, options);
		}
	}
	internal sealed class ArrayConverter<TCollection, TElement> : IEnumerableDefaultConverter<TElement[], TElement>
	{
		internal override bool CanHaveMetadata => false;

		internal override bool SupportsCreateObjectDelegate => false;

		protected override void Add(in TElement value, ref ReadStack state)
		{
			((List<TElement>)state.Current.ReturnValue).Add(value);
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			state.Current.ReturnValue = new List<TElement>();
		}

		protected override void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
		{
			List<TElement> list = (List<TElement>)state.Current.ReturnValue;
			state.Current.ReturnValue = list.ToArray();
		}

		protected override bool OnWriteResume(Utf8JsonWriter writer, TElement[] array, JsonSerializerOptions options, ref WriteStack state)
		{
			int i = state.Current.EnumeratorIndex;
			JsonConverter<TElement> elementConverter = JsonCollectionConverter<TElement[], TElement>.GetElementConverter(ref state);
			if (elementConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
			{
				for (; i < array.Length; i++)
				{
					elementConverter.Write(writer, array[i], options);
				}
			}
			else
			{
				for (; i < array.Length; i++)
				{
					TElement value = array[i];
					if (!elementConverter.TryWrite(writer, in value, options, ref state))
					{
						state.Current.EnumeratorIndex = i;
						return false;
					}
					state.Current.EndCollectionElement();
					if (JsonConverter.ShouldFlush(writer, ref state))
					{
						i = (state.Current.EnumeratorIndex = i + 1);
						return false;
					}
				}
			}
			return true;
		}
	}
	internal sealed class ConcurrentQueueOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : ConcurrentQueue<TElement>
	{
		internal override bool CanPopulate => true;

		protected override void Add(in TElement value, ref ReadStack state)
		{
			((TCollection)state.Current.ReturnValue).Enqueue(value);
		}
	}
	internal sealed class ConcurrentStackOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : ConcurrentStack<TElement>
	{
		internal override bool CanPopulate => true;

		protected override void Add(in TElement value, ref ReadStack state)
		{
			((TCollection)state.Current.ReturnValue).Push(value);
		}
	}
	internal abstract class DictionaryDefaultConverter<TDictionary, TKey, TValue> : JsonDictionaryConverter<TDictionary, TKey, TValue> where TDictionary : IEnumerable<KeyValuePair<TKey, TValue>>
	{
		internal override bool CanHaveMetadata => true;

		protected internal override bool OnWriteResume(Utf8JsonWriter writer, TDictionary value, JsonSerializerOptions options, ref WriteStack state)
		{
			IEnumerator<KeyValuePair<TKey, TValue>> enumerator;
			if (state.Current.CollectionEnumerator == null)
			{
				enumerator = value.GetEnumerator();
				if (!enumerator.MoveNext())
				{
					enumerator.Dispose();
					return true;
				}
			}
			else
			{
				enumerator = (IEnumerator<KeyValuePair<TKey, TValue>>)state.Current.CollectionEnumerator;
			}
			JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
			if (_keyConverter == null)
			{
				_keyConverter = JsonDictionaryConverter<TDictionary, TKey, TValue>.GetConverter<TKey>(jsonTypeInfo.KeyTypeInfo);
			}
			if (_valueConverter == null)
			{
				_valueConverter = JsonDictionaryConverter<TDictionary, TKey, TValue>.GetConverter<TValue>(jsonTypeInfo.ElementTypeInfo);
			}
			do
			{
				if (JsonConverter.ShouldFlush(writer, ref state))
				{
					state.Current.CollectionEnumerator = enumerator;
					return false;
				}
				if ((int)state.Current.PropertyState < 2)
				{
					state.Current.PropertyState = StackFramePropertyState.Name;
					TKey key = enumerator.Current.Key;
					_keyConverter.WriteAsPropertyNameCore(writer, key, options, state.Current.IsWritingExtensionDataProperty);
				}
				TValue value2 = enumerator.Current.Value;
				if (!_valueConverter.TryWrite(writer, in value2, options, ref state))
				{
					state.Current.CollectionEnumerator = enumerator;
					return false;
				}
				state.Current.EndDictionaryEntry();
			}
			while (enumerator.MoveNext());
			enumerator.Dispose();
			return true;
		}
	}
	internal sealed class DictionaryOfTKeyTValueConverter<TCollection, TKey, TValue> : DictionaryDefaultConverter<TCollection, TKey, TValue> where TCollection : Dictionary<TKey, TValue>
	{
		internal override bool CanPopulate => true;

		protected override void Add(TKey key, in TValue value, JsonSerializerOptions options, ref ReadStack state)
		{
			((TCollection)state.Current.ReturnValue)[key] = value;
		}

		protected internal override bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state)
		{
			Dictionary<TKey, TValue>.Enumerator enumerator;
			if (state.Current.CollectionEnumerator == null)
			{
				enumerator = value.GetEnumerator();
				if (!enumerator.MoveNext())
				{
					enumerator.Dispose();
					return true;
				}
			}
			else
			{
				enumerator = (Dictionary<TKey, TValue>.Enumerator)(object)state.Current.CollectionEnumerator;
			}
			JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
			if (_keyConverter == null)
			{
				_keyConverter = JsonDictionaryConverter<TCollection, TKey, TValue>.GetConverter<TKey>(jsonTypeInfo.KeyTypeInfo);
			}
			if (_valueConverter == null)
			{
				_valueConverter = JsonDictionaryConverter<TCollection, TKey, TValue>.GetConverter<TValue>(jsonTypeInfo.ElementTypeInfo);
			}
			if (!state.SupportContinuation && _valueConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
			{
				do
				{
					TKey key = enumerator.Current.Key;
					_keyConverter.WriteAsPropertyNameCore(writer, key, options, state.Current.IsWritingExtensionDataProperty);
					_valueConverter.Write(writer, enumerator.Current.Value, options);
				}
				while (enumerator.MoveNext());
			}
			else
			{
				do
				{
					if (JsonConverter.ShouldFlush(writer, ref state))
					{
						state.Current.CollectionEnumerator = enumerator;
						return false;
					}
					if ((int)state.Current.PropertyState < 2)
					{
						state.Current.PropertyState = StackFramePropertyState.Name;
						TKey key2 = enumerator.Current.Key;
						_keyConverter.WriteAsPropertyNameCore(writer, key2, options, state.Current.IsWritingExtensionDataProperty);
					}
					TValue value2 = enumerator.Current.Value;
					if (!_valueConverter.TryWrite(writer, in value2, options, ref state))
					{
						state.Current.CollectionEnumerator = enumerator;
						return false;
					}
					state.Current.EndDictionaryEntry();
				}
				while (enumerator.MoveNext());
			}
			enumerator.Dispose();
			return true;
		}
	}
	internal sealed class IAsyncEnumerableOfTConverter<TAsyncEnumerable, TElement> : JsonCollectionConverter<TAsyncEnumerable, TElement> where TAsyncEnumerable : IAsyncEnumerable<TElement>
	{
		private sealed class BufferedAsyncEnumerable : IAsyncEnumerable<TElement>
		{
			public readonly List<TElement> _buffer = new List<TElement>();

			public async IAsyncEnumerator<TElement> GetAsyncEnumerator(CancellationToken _)
			{
				foreach (TElement item in _buffer)
				{
					yield return item;
				}
			}
		}

		internal override bool SupportsCreateObjectDelegate => false;

		internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out TAsyncEnumerable value)
		{
			if (!typeToConvert.IsAssignableFrom(typeof(IAsyncEnumerable<TElement>)))
			{
				ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(Type, ref reader, ref state);
			}
			return base.OnTryRead(ref reader, typeToConvert, options, ref state, out value);
		}

		protected override void Add(in TElement value, ref ReadStack state)
		{
			((BufferedAsyncEnumerable)state.Current.ReturnValue)._buffer.Add(value);
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			state.Current.ReturnValue = new BufferedAsyncEnumerable();
		}

		internal override bool OnTryWrite(Utf8JsonWriter writer, TAsyncEnumerable value, JsonSerializerOptions options, ref WriteStack state)
		{
			if (!state.SupportAsync)
			{
				ThrowHelper.ThrowNotSupportedException_TypeRequiresAsyncSerialization(Type);
			}
			return base.OnTryWrite(writer, value, options, ref state);
		}

		protected override bool OnWriteResume(Utf8JsonWriter writer, TAsyncEnumerable value, JsonSerializerOptions options, ref WriteStack state)
		{
			IAsyncEnumerator<TElement> asyncEnumerator;
			ValueTask<bool> valueTask;
			if (state.Current.AsyncDisposable == null)
			{
				asyncEnumerator = value.GetAsyncEnumerator(state.CancellationToken);
				state.Current.AsyncDisposable = asyncEnumerator;
				valueTask = asyncEnumerator.MoveNextAsync();
				if (!valueTask.IsCompleted)
				{
					state.SuppressFlush = true;
					goto IL_0106;
				}
			}
			else
			{
				asyncEnumerator = (IAsyncEnumerator<TElement>)state.Current.AsyncDisposable;
				if (state.Current.AsyncEnumeratorIsPendingCompletion)
				{
					valueTask = new ValueTask<bool>((Task<bool>)state.PendingTask);
					state.Current.AsyncEnumeratorIsPendingCompletion = false;
					state.PendingTask = null;
				}
				else
				{
					valueTask = new ValueTask<bool>(result: true);
				}
			}
			JsonConverter<TElement> elementConverter = JsonCollectionConverter<TAsyncEnumerable, TElement>.GetElementConverter(ref state);
			do
			{
				if (!valueTask.Result)
				{
					state.Current.AsyncDisposable = null;
					state.AddCompletedAsyncDisposable(asyncEnumerator);
					return true;
				}
				if (JsonConverter.ShouldFlush(writer, ref state))
				{
					return false;
				}
				if (!elementConverter.TryWrite(writer, asyncEnumerator.Current, options, ref state))
				{
					return false;
				}
				state.Current.EndCollectionElement();
				valueTask = asyncEnumerator.MoveNextAsync();
			}
			while (valueTask.IsCompleted);
			goto IL_0106;
			IL_0106:
			state.PendingTask = valueTask.AsTask();
			state.Current.AsyncEnumeratorIsPendingCompletion = true;
			return false;
		}
	}
	internal sealed class ICollectionOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : ICollection<TElement>
	{
		internal override bool CanPopulate => true;

		protected override void Add(in TElement value, ref ReadStack state)
		{
			TCollection val = (TCollection)state.Current.ReturnValue;
			val.Add(value);
			if (base.IsValueType)
			{
				state.Current.ReturnValue = val;
			}
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			base.CreateCollection(ref reader, ref state, options);
			if (((TCollection)state.Current.ReturnValue).IsReadOnly)
			{
				state.Current.ReturnValue = null;
				ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(Type, ref reader, ref state);
			}
		}

		internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
		{
			if (jsonTypeInfo.CreateObject == null && Type.IsAssignableFrom(typeof(List<TElement>)))
			{
				jsonTypeInfo.CreateObject = () => new List<TElement>();
			}
		}
	}
	internal sealed class IDictionaryConverter<TDictionary> : JsonDictionaryConverter<TDictionary, string, object> where TDictionary : IDictionary
	{
		internal override bool CanPopulate => true;

		protected override void Add(string key, in object value, JsonSerializerOptions options, ref ReadStack state)
		{
			TDictionary val = (TDictionary)state.Current.ReturnValue;
			val[key] = value;
			if (base.IsValueType)
			{
				state.Current.ReturnValue = val;
			}
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state)
		{
			base.CreateCollection(ref reader, ref state);
			if (((TDictionary)state.Current.ReturnValue).IsReadOnly)
			{
				state.Current.ReturnValue = null;
				ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(Type, ref reader, ref state);
			}
		}

		protected internal override bool OnWriteResume(Utf8JsonWriter writer, TDictionary value, JsonSerializerOptions options, ref WriteStack state)
		{
			IDictionaryEnumerator dictionaryEnumerator;
			if (state.Current.CollectionEnumerator == null)
			{
				dictionaryEnumerator = value.GetEnumerator();
				if (!dictionaryEnumerator.MoveNext())
				{
					return true;
				}
			}
			else
			{
				dictionaryEnumerator = (IDictionaryEnumerator)state.Current.CollectionEnumerator;
			}
			JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
			if (_valueConverter == null)
			{
				_valueConverter = JsonDictionaryConverter<TDictionary, string, object>.GetConverter<object>(jsonTypeInfo.ElementTypeInfo);
			}
			do
			{
				if (JsonConverter.ShouldFlush(writer, ref state))
				{
					state.Current.CollectionEnumerator = dictionaryEnumerator;
					return false;
				}
				if ((int)state.Current.PropertyState < 2)
				{
					state.Current.PropertyState = StackFramePropertyState.Name;
					object key = dictionaryEnumerator.Key;
					if (key is string value2)
					{
						if (_keyConverter == null)
						{
							_keyConverter = JsonDictionaryConverter<TDictionary, string, object>.GetConverter<string>(jsonTypeInfo.KeyTypeInfo);
						}
						_keyConverter.WriteAsPropertyNameCore(writer, value2, options, state.Current.IsWritingExtensionDataProperty);
					}
					else
					{
						_valueConverter.WriteAsPropertyNameCore(writer, key, options, state.Current.IsWritingExtensionDataProperty);
					}
				}
				object value3 = dictionaryEnumerator.Value;
				if (!_valueConverter.TryWrite(writer, in value3, options, ref state))
				{
					state.Current.CollectionEnumerator = dictionaryEnumerator;
					return false;
				}
				state.Current.EndDictionaryEntry();
			}
			while (dictionaryEnumerator.MoveNext());
			return true;
		}

		internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
		{
			if (jsonTypeInfo.CreateObject == null && Type.IsAssignableFrom(typeof(Dictionary<string, object>)))
			{
				jsonTypeInfo.CreateObject = () => new Dictionary<string, object>();
			}
		}
	}
	internal sealed class IDictionaryOfTKeyTValueConverter<TDictionary, TKey, TValue> : DictionaryDefaultConverter<TDictionary, TKey, TValue> where TDictionary : IDictionary<TKey, TValue>
	{
		internal override bool CanPopulate => true;

		protected override void Add(TKey key, in TValue value, JsonSerializerOptions options, ref ReadStack state)
		{
			TDictionary val = (TDictionary)state.Current.ReturnValue;
			val[key] = value;
			if (base.IsValueType)
			{
				state.Current.ReturnValue = val;
			}
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state)
		{
			base.CreateCollection(ref reader, ref state);
			if (((TDictionary)state.Current.ReturnValue).IsReadOnly)
			{
				state.Current.ReturnValue = null;
				ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(Type, ref reader, ref state);
			}
		}

		internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
		{
			if (jsonTypeInfo.CreateObject == null && Type.IsAssignableFrom(typeof(Dictionary<TKey, TValue>)))
			{
				jsonTypeInfo.CreateObject = () => new Dictionary<TKey, TValue>();
			}
		}
	}
	internal sealed class IEnumerableConverter<TCollection> : JsonCollectionConverter<TCollection, object> where TCollection : IEnumerable
	{
		private readonly bool _isDeserializable = typeof(TCollection).IsAssignableFrom(typeof(List<object>));

		internal override bool SupportsCreateObjectDelegate => false;

		protected override void Add(in object value, ref ReadStack state)
		{
			((List<object>)state.Current.ReturnValue).Add(value);
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			if (!_isDeserializable)
			{
				ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(Type, ref reader, ref state);
			}
			state.Current.ReturnValue = new List<object>();
		}

		protected override bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state)
		{
			IEnumerator enumerator;
			if (state.Current.CollectionEnumerator == null)
			{
				enumerator = value.GetEnumerator();
				if (!enumerator.MoveNext())
				{
					return true;
				}
			}
			else
			{
				enumerator = state.Current.CollectionEnumerator;
			}
			JsonConverter<object> elementConverter = JsonCollectionConverter<TCollection, object>.GetElementConverter(ref state);
			do
			{
				if (JsonConverter.ShouldFlush(writer, ref state))
				{
					state.Current.CollectionEnumerator = enumerator;
					return false;
				}
				if (!elementConverter.TryWrite(writer, enumerator.Current, options, ref state))
				{
					state.Current.CollectionEnumerator = enumerator;
					return false;
				}
				state.Current.EndCollectionElement();
			}
			while (enumerator.MoveNext());
			return true;
		}
	}
	[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
	internal sealed class IEnumerableConverterFactory : JsonConverterFactory
	{
		private static readonly IDictionaryConverter<IDictionary> s_converterForIDictionary = new IDictionaryConverter<IDictionary>();

		private static readonly IEnumerableConverter<IEnumerable> s_converterForIEnumerable = new IEnumerableConverter<IEnumerable>();

		private static readonly IListConverter<IList> s_converterForIList = new IListConverter<IList>();

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		public IEnumerableConverterFactory()
		{
		}

		public override bool CanConvert(Type typeToConvert)
		{
			return typeof(IEnumerable).IsAssignableFrom(typeToConvert);
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The ctor is marked RequiresUnreferencedCode.")]
		public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
		{
			Type type = null;
			Type type2 = null;
			Type typeFromHandle;
			Type compatibleGenericBaseClass;
			if (typeToConvert.IsArray)
			{
				if (typeToConvert.GetArrayRank() > 1)
				{
					return UnsupportedTypeConverterFactory.CreateUnsupportedConverterForType(typeToConvert);
				}
				typeFromHandle = typeof(ArrayConverter<, >);
				type = typeToConvert.GetElementType();
			}
			else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericBaseClass(typeof(List<>))) != null)
			{
				typeFromHandle = typeof(ListOfTConverter<, >);
				type = compatibleGenericBaseClass.GetGenericArguments()[0];
			}
			else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericBaseClass(typeof(Dictionary<, >))) != null)
			{
				Type[] genericArguments = compatibleGenericBaseClass.GetGenericArguments();
				typeFromHandle = typeof(DictionaryOfTKeyTValueConverter<, , >);
				type2 = genericArguments[0];
				type = genericArguments[1];
			}
			else if (typeToConvert.IsImmutableDictionaryType())
			{
				Type[] genericArguments = typeToConvert.GetGenericArguments();
				typeFromHandle = typeof(ImmutableDictionaryOfTKeyTValueConverterWithReflection<, , >);
				type2 = genericArguments[0];
				type = genericArguments[1];
			}
			else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericInterface(typeof(IDictionary<, >))) != null)
			{
				Type[] genericArguments = compatibleGenericBaseClass.GetGenericArguments();
				typeFromHandle = typeof(IDictionaryOfTKeyTValueConverter<, , >);
				type2 = genericArguments[0];
				type = genericArguments[1];
			}
			else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericInterface(typeof(IReadOnlyDictionary<, >))) != null)
			{
				Type[] genericArguments = compatibleGenericBaseClass.GetGenericArguments();
				typeFromHandle = typeof(IReadOnlyDictionaryOfTKeyTValueConverter<, , >);
				type2 = genericArguments[0];
				type = genericArguments[1];
			}
			else if (typeToConvert.IsImmutableEnumerableType())
			{
				typeFromHandle = typeof(ImmutableEnumerableOfTConverterWithReflection<, >);
				type = typeToConvert.GetGenericArguments()[0];
			}
			else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericInterface(typeof(IList<>))) != null)
			{
				typeFromHandle = typeof(IListOfTConverter<, >);
				type = compatibleGenericBaseClass.GetGenericArguments()[0];
			}
			else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericInterface(typeof(ISet<>))) != null)
			{
				typeFromHandle = typeof(ISetOfTConverter<, >);
				type = compatibleGenericBaseClass.GetGenericArguments()[0];
			}
			else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericInterface(typeof(ICollection<>))) != null)
			{
				typeFromHandle = typeof(ICollectionOfTConverter<, >);
				type = compatibleGenericBaseClass.GetGenericArguments()[0];
			}
			else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericBaseClass(typeof(Stack<>))) != null)
			{
				typeFromHandle = typeof(StackOfTConverter<, >);
				type = compatibleGenericBaseClass.GetGenericArguments()[0];
			}
			else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericBaseClass(typeof(Queue<>))) != null)
			{
				typeFromHandle = typeof(QueueOfTConverter<, >);
				type = compatibleGenericBaseClass.GetGenericArguments()[0];
			}
			else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericBaseClass(typeof(ConcurrentStack<>))) != null)
			{
				typeFromHandle = typeof(ConcurrentStackOfTConverter<, >);
				type = compatibleGenericBaseClass.GetGenericArguments()[0];
			}
			else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericBaseClass(typeof(ConcurrentQueue<>))) != null)
			{
				typeFromHandle = typeof(ConcurrentQueueOfTConverter<, >);
				type = compatibleGenericBaseClass.GetGenericArguments()[0];
			}
			else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericInterface(typeof(IEnumerable<>))) != null)
			{
				typeFromHandle = typeof(IEnumerableOfTConverter<, >);
				type = compatibleGenericBaseClass.GetGenericArguments()[0];
			}
			else if (typeof(IDictionary).IsAssignableFrom(typeToConvert))
			{
				if (typeToConvert == typeof(IDictionary))
				{
					return s_converterForIDictionary;
				}
				typeFromHandle = typeof(IDictionaryConverter<>);
			}
			else if (typeof(IList).IsAssignableFrom(typeToConvert))
			{
				if (typeToConvert == typeof(IList))
				{
					return s_converterForIList;
				}
				typeFromHandle = typeof(IListConverter<>);
			}
			else if (typeToConvert.IsNonGenericStackOrQueue())
			{
				typeFromHandle = typeof(StackOrQueueConverterWithReflection<>);
			}
			else
			{
				if (typeToConvert == typeof(IEnumerable))
				{
					return s_converterForIEnumerable;
				}
				typeFromHandle = typeof(IEnumerableConverter<>);
			}
			return (JsonConverter)Activator.CreateInstance(typeFromHandle.GetGenericArguments().Length switch
			{
				1 => typeFromHandle.MakeGenericType(typeToConvert), 
				2 => typeFromHandle.MakeGenericType(typeToConvert, type), 
				_ => typeFromHandle.MakeGenericType(typeToConvert, type2, type), 
			}, BindingFlags.Instance | BindingFlags.Public, null, null, null);
		}
	}
	internal abstract class IEnumerableDefaultConverter<TCollection, TElement> : JsonCollectionConverter<TCollection, TElement> where TCollection : IEnumerable<TElement>
	{
		internal override bool CanHaveMetadata => true;

		protected override bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state)
		{
			IEnumerator<TElement> enumerator;
			if (state.Current.CollectionEnumerator == null)
			{
				enumerator = value.GetEnumerator();
				if (!enumerator.MoveNext())
				{
					enumerator.Dispose();
					return true;
				}
			}
			else
			{
				enumerator = (IEnumerator<TElement>)state.Current.CollectionEnumerator;
			}
			JsonConverter<TElement> elementConverter = JsonCollectionConverter<TCollection, TElement>.GetElementConverter(ref state);
			do
			{
				if (JsonConverter.ShouldFlush(writer, ref state))
				{
					state.Current.CollectionEnumerator = enumerator;
					return false;
				}
				if (!elementConverter.TryWrite(writer, enumerator.Current, options, ref state))
				{
					state.Current.CollectionEnumerator = enumerator;
					return false;
				}
				state.Current.EndCollectionElement();
			}
			while (enumerator.MoveNext());
			enumerator.Dispose();
			return true;
		}
	}
	internal sealed class IEnumerableOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : IEnumerable<TElement>
	{
		private readonly bool _isDeserializable = typeof(TCollection).IsAssignableFrom(typeof(List<TElement>));

		internal override bool SupportsCreateObjectDelegate => false;

		protected override void Add(in TElement value, ref ReadStack state)
		{
			((List<TElement>)state.Current.ReturnValue).Add(value);
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			if (!_isDeserializable)
			{
				ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(Type, ref reader, ref state);
			}
			state.Current.ReturnValue = new List<TElement>();
		}
	}
	internal class StackOrQueueConverter<TCollection> : JsonCollectionConverter<TCollection, object> where TCollection : IEnumerable
	{
		internal override bool CanPopulate => true;

		protected sealed override void Add(in object value, ref ReadStack state)
		{
			Action<TCollection, object> action = (Action<TCollection, object>)state.Current.JsonTypeInfo.AddMethodDelegate;
			action((TCollection)state.Current.ReturnValue, value);
		}

		protected sealed override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			JsonPropertyInfo parentProperty = state.ParentProperty;
			if (parentProperty == null || !parentProperty.TryGetPrePopulatedValue(ref state))
			{
				JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
				Func<object> createObject = jsonTypeInfo.CreateObject;
				if (createObject == null)
				{
					ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(Type, ref reader, ref state);
				}
				state.Current.ReturnValue = createObject();
			}
		}

		protected sealed override bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state)
		{
			IEnumerator enumerator;
			if (state.Current.CollectionEnumerator == null)
			{
				enumerator = value.GetEnumerator();
				if (!enumerator.MoveNext())
				{
					return true;
				}
			}
			else
			{
				enumerator = state.Current.CollectionEnumerator;
			}
			JsonConverter<object> elementConverter = JsonCollectionConverter<TCollection, object>.GetElementConverter(ref state);
			do
			{
				if (JsonConverter.ShouldFlush(writer, ref state))
				{
					state.Current.CollectionEnumerator = enumerator;
					return false;
				}
				if (!elementConverter.TryWrite(writer, enumerator.Current, options, ref state))
				{
					state.Current.CollectionEnumerator = enumerator;
					return false;
				}
				state.Current.EndCollectionElement();
			}
			while (enumerator.MoveNext());
			return true;
		}
	}
	internal sealed class IListConverter<TCollection> : JsonCollectionConverter<TCollection, object> where TCollection : IList
	{
		internal override bool CanPopulate => true;

		protected override void Add(in object value, ref ReadStack state)
		{
			TCollection val = (TCollection)state.Current.ReturnValue;
			val.Add(value);
			if (base.IsValueType)
			{
				state.Current.ReturnValue = val;
			}
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			base.CreateCollection(ref reader, ref state, options);
			if (((TCollection)state.Current.ReturnValue).IsReadOnly)
			{
				state.Current.ReturnValue = null;
				ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(Type, ref reader, ref state);
			}
		}

		protected override bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state)
		{
			IList list = value;
			int i = state.Current.EnumeratorIndex;
			JsonConverter<object> elementConverter = JsonCollectionConverter<TCollection, object>.GetElementConverter(ref state);
			if (elementConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
			{
				for (; i < list.Count; i++)
				{
					elementConverter.Write(writer, list[i], options);
				}
			}
			else
			{
				for (; i < list.Count; i++)
				{
					if (!elementConverter.TryWrite(writer, list[i], options, ref state))
					{
						state.Current.EnumeratorIndex = i;
						return false;
					}
					state.Current.EndCollectionElement();
					if (JsonConverter.ShouldFlush(writer, ref state))
					{
						i = (state.Current.EnumeratorIndex = i + 1);
						return false;
					}
				}
			}
			return true;
		}

		internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
		{
			if (jsonTypeInfo.CreateObject == null && Type.IsAssignableFrom(typeof(List<object>)))
			{
				jsonTypeInfo.CreateObject = () => new List<object>();
			}
		}
	}
	internal sealed class IListOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : IList<TElement>
	{
		internal override bool CanPopulate => true;

		protected override void Add(in TElement value, ref ReadStack state)
		{
			TCollection val = (TCollection)state.Current.ReturnValue;
			val.Add(value);
			if (base.IsValueType)
			{
				state.Current.ReturnValue = val;
			}
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			base.CreateCollection(ref reader, ref state, options);
			if (((TCollection)state.Current.ReturnValue).IsReadOnly)
			{
				state.Current.ReturnValue = null;
				ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(Type, ref reader, ref state);
			}
		}

		internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
		{
			if (jsonTypeInfo.CreateObject == null && Type.IsAssignableFrom(typeof(List<TElement>)))
			{
				jsonTypeInfo.CreateObject = () => new List<TElement>();
			}
		}
	}
	internal class ImmutableDictionaryOfTKeyTValueConverter<TDictionary, TKey, TValue> : DictionaryDefaultConverter<TDictionary, TKey, TValue> where TDictionary : IReadOnlyDictionary<TKey, TValue>
	{
		internal sealed override bool CanHaveMetadata => false;

		internal override bool SupportsCreateObjectDelegate => false;

		protected sealed override void Add(TKey key, in TValue value, JsonSerializerOptions options, ref ReadStack state)
		{
			((Dictionary<TKey, TValue>)state.Current.ReturnValue)[key] = value;
		}

		protected sealed override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state)
		{
			state.Current.ReturnValue = new Dictionary<TKey, TValue>();
		}

		protected sealed override void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
		{
			Func<IEnumerable<KeyValuePair<TKey, TValue>>, TDictionary> func = (Func<IEnumerable<KeyValuePair<TKey, TValue>>, TDictionary>)state.Current.JsonTypeInfo.CreateObjectWithArgs;
			state.Current.ReturnValue = func((Dictionary<TKey, TValue>)state.Current.ReturnValue);
		}
	}
	internal class ImmutableEnumerableOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : IEnumerable<TElement>
	{
		internal sealed override bool CanHaveMetadata => false;

		internal override bool SupportsCreateObjectDelegate => false;

		protected sealed override void Add(in TElement value, ref ReadStack state)
		{
			((List<TElement>)state.Current.ReturnValue).Add(value);
		}

		protected sealed override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			state.Current.ReturnValue = new List<TElement>();
		}

		protected sealed override void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
		{
			JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
			Func<IEnumerable<TElement>, TCollection> func = (Func<IEnumerable<TElement>, TCollection>)jsonTypeInfo.CreateObjectWithArgs;
			state.Current.ReturnValue = func((List<TElement>)state.Current.ReturnValue);
		}
	}
	internal sealed class IReadOnlyDictionaryOfTKeyTValueConverter<TDictionary, TKey, TValue> : DictionaryDefaultConverter<TDictionary, TKey, TValue> where TDictionary : IReadOnlyDictionary<TKey, TValue>
	{
		private readonly bool _isDeserializable = typeof(TDictionary).IsAssignableFrom(typeof(Dictionary<TKey, TValue>));

		internal override bool SupportsCreateObjectDelegate => false;

		protected override void Add(TKey key, in TValue value, JsonSerializerOptions options, ref ReadStack state)
		{
			((Dictionary<TKey, TValue>)state.Current.ReturnValue)[key] = value;
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state)
		{
			if (!_isDeserializable)
			{
				ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(Type, ref reader, ref state);
			}
			state.Current.ReturnValue = new Dictionary<TKey, TValue>();
		}
	}
	internal sealed class ISetOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : ISet<TElement>
	{
		internal override bool CanPopulate => true;

		protected override void Add(in TElement value, ref ReadStack state)
		{
			TCollection val = (TCollection)state.Current.ReturnValue;
			val.Add(value);
			if (base.IsValueType)
			{
				state.Current.ReturnValue = val;
			}
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			base.CreateCollection(ref reader, ref state, options);
			if (((TCollection)state.Current.ReturnValue).IsReadOnly)
			{
				state.Current.ReturnValue = null;
				ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(Type, ref reader, ref state);
			}
		}

		internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
		{
			if (jsonTypeInfo.CreateObject == null && Type.IsAssignableFrom(typeof(HashSet<TElement>)))
			{
				jsonTypeInfo.CreateObject = () => new HashSet<TElement>();
			}
		}
	}
	internal sealed class ListOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : List<TElement>
	{
		internal override bool CanPopulate => true;

		protected override void Add(in TElement value, ref ReadStack state)
		{
			((TCollection)state.Current.ReturnValue).Add(value);
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			JsonPropertyInfo parentProperty = state.ParentProperty;
			if (parentProperty == null || !parentProperty.TryGetPrePopulatedValue(ref state))
			{
				if (state.Current.JsonTypeInfo.CreateObject == null)
				{
					ThrowHelper.ThrowNotSupportedException_SerializationNotSupported(state.Current.JsonTypeInfo.Type);
				}
				state.Current.ReturnValue = state.Current.JsonTypeInfo.CreateObject();
			}
		}

		protected override bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state)
		{
			int i = state.Current.EnumeratorIndex;
			JsonConverter<TElement> elementConverter = JsonCollectionConverter<TCollection, TElement>.GetElementConverter(ref state);
			if (elementConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
			{
				for (; i < value.Count; i++)
				{
					elementConverter.Write(writer, value[i], options);
				}
			}
			else
			{
				for (; i < value.Count; i++)
				{
					if (!elementConverter.TryWrite(writer, value[i], options, ref state))
					{
						state.Current.EnumeratorIndex = i;
						return false;
					}
					state.Current.EndCollectionElement();
					if (JsonConverter.ShouldFlush(writer, ref state))
					{
						i = (state.Current.EnumeratorIndex = i + 1);
						return false;
					}
				}
			}
			return true;
		}
	}
	internal sealed class QueueOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : Queue<TElement>
	{
		internal override bool CanPopulate => true;

		protected override void Add(in TElement value, ref ReadStack state)
		{
			((TCollection)state.Current.ReturnValue).Enqueue(value);
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			JsonPropertyInfo parentProperty = state.ParentProperty;
			if (parentProperty == null || !parentProperty.TryGetPrePopulatedValue(ref state))
			{
				if (state.Current.JsonTypeInfo.CreateObject == null)
				{
					ThrowHelper.ThrowNotSupportedException_SerializationNotSupported(state.Current.JsonTypeInfo.Type);
				}
				state.Current.ReturnValue = state.Current.JsonTypeInfo.CreateObject();
			}
		}
	}
	internal sealed class StackOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : Stack<TElement>
	{
		internal override bool CanPopulate => true;

		protected override void Add(in TElement value, ref ReadStack state)
		{
			((TCollection)state.Current.ReturnValue).Push(value);
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			JsonPropertyInfo parentProperty = state.ParentProperty;
			if (parentProperty == null || !parentProperty.TryGetPrePopulatedValue(ref state))
			{
				if (state.Current.JsonTypeInfo.CreateObject == null)
				{
					ThrowHelper.ThrowNotSupportedException_SerializationNotSupported(state.Current.JsonTypeInfo.Type);
				}
				state.Current.ReturnValue = state.Current.JsonTypeInfo.CreateObject();
			}
		}
	}
	internal sealed class FSharpListConverter<TList, TElement> : IEnumerableDefaultConverter<TList, TElement> where TList : IEnumerable<TElement>
	{
		private readonly Func<IEnumerable<TElement>, TList> _listConstructor;

		internal override bool SupportsCreateObjectDelegate => false;

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
		public FSharpListConverter()
		{
			_listConstructor = FSharpCoreReflectionProxy.Instance.CreateFSharpListConstructor<TList, TElement>();
		}

		protected override void Add(in TElement value, ref ReadStack state)
		{
			((List<TElement>)state.Current.ReturnValue).Add(value);
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			state.Current.ReturnValue = new List<TElement>();
		}

		protected override void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
		{
			state.Current.ReturnValue = _listConstructor((List<TElement>)state.Current.ReturnValue);
		}
	}
	internal sealed class FSharpMapConverter<TMap, TKey, TValue> : DictionaryDefaultConverter<TMap, TKey, TValue> where TMap : IEnumerable<KeyValuePair<TKey, TValue>>
	{
		private readonly Func<IEnumerable<Tuple<TKey, TValue>>, TMap> _mapConstructor;

		internal override bool CanHaveMetadata => false;

		internal override bool SupportsCreateObjectDelegate => false;

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
		public FSharpMapConverter()
		{
			_mapConstructor = FSharpCoreReflectionProxy.Instance.CreateFSharpMapConstructor<TMap, TKey, TValue>();
		}

		protected override void Add(TKey key, in TValue value, JsonSerializerOptions options, ref ReadStack state)
		{
			((List<Tuple<TKey, TValue>>)state.Current.ReturnValue).Add(new Tuple<TKey, TValue>(key, value));
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state)
		{
			state.Current.ReturnValue = new List<Tuple<TKey, TValue>>();
		}

		protected override void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
		{
			state.Current.ReturnValue = _mapConstructor((List<Tuple<TKey, TValue>>)state.Current.ReturnValue);
		}
	}
	internal sealed class FSharpSetConverter<TSet, TElement> : IEnumerableDefaultConverter<TSet, TElement> where TSet : IEnumerable<TElement>
	{
		private readonly Func<IEnumerable<TElement>, TSet> _setConstructor;

		internal override bool SupportsCreateObjectDelegate => false;

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
		public FSharpSetConverter()
		{
			_setConstructor = FSharpCoreReflectionProxy.Instance.CreateFSharpSetConstructor<TSet, TElement>();
		}

		protected override void Add(in TElement value, ref ReadStack state)
		{
			((List<TElement>)state.Current.ReturnValue).Add(value);
		}

		protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
		{
			state.Current.ReturnValue = new List<TElement>();
		}

		protected override void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
		{
			state.Current.ReturnValue = _setConstructor((List<TElement>)state.Current.ReturnValue);
		}
	}
	[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
	internal sealed class FSharpTypeConverterFactory : JsonConverterFactory
	{
		private ObjectConverterFactory _recordConverterFactory;

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		public FSharpTypeConverterFactory()
		{
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The ctor is marked RequiresUnreferencedCode.")]
		public override bool CanConvert(Type typeToConvert)
		{
			if (FSharpCoreReflectionProxy.IsFSharpType(typeToConvert))
			{
				return FSharpCoreReflectionProxy.Instance.DetectFSharpKind(typeToConvert) != FSharpCoreReflectionProxy.FSharpKind.Unrecognized;
			}
			return false;
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The ctor is marked RequiresUnreferencedCode.")]
		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2055:MakeGenericType", Justification = "The ctor is marked RequiresUnreferencedCode.")]
		public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
		{
			object[] args = null;
			Type type2;
			switch (FSharpCoreReflectionProxy.Instance.DetectFSharpKind(typeToConvert))
			{
			case FSharpCoreReflectionProxy.FSharpKind.Option:
			{
				Type type = typeToConvert.GetGenericArguments()[0];
				type2 = typeof(FSharpOptionConverter<, >).MakeGenericType(typeToConvert, type);
				args = new object[1] { options.GetConverterInternal(type) };
				break;
			}
			case FSharpCoreReflectionProxy.FSharpKind.ValueOption:
			{
				Type type = typeToConvert.GetGenericArguments()[0];
				type2 = typeof(FSharpValueOptionConverter<, >).MakeGenericType(typeToConvert, type);
				args = new object[1] { options.GetConverterInternal(type) };
				break;
			}
			case FSharpCoreReflectionProxy.FSharpKind.List:
			{
				Type type = typeToConvert.GetGenericArguments()[0];
				type2 = typeof(FSharpListConverter<, >).MakeGenericType(typeToConvert, type);
				break;
			}
			case FSharpCoreReflectionProxy.FSharpKind.Set:
			{
				Type type = typeToConvert.GetGenericArguments()[0];
				type2 = typeof(FSharpSetConverter<, >).MakeGenericType(typeToConvert, type);
				break;
			}
			case FSharpCoreReflectionProxy.FSharpKind.Map:
			{
				Type[] genericArguments = typeToConvert.GetGenericArguments();
				Type type3 = genericArguments[0];
				Type type4 = genericArguments[1];
				type2 = typeof(FSharpMapConverter<, , >).MakeGenericType(typeToConvert, type3, type4);
				break;
			}
			case FSharpCoreReflectionProxy.FSharpKind.Record:
			{
				ObjectConverterFactory objectConverterFactory = _recordConverterFactory ?? (_recordConverterFactory = new ObjectConverterFactory(useDefaultConstructorInUnannotatedStructs: false));
				return objectConverterFactory.CreateConverter(typeToConvert, options);
			}
			case FSharpCoreReflectionProxy.FSharpKind.Union:
				return UnsupportedTypeConverterFactory.CreateUnsupportedConverterForType(typeToConvert, System.SR.FSharpDiscriminatedUnionsNotSupported);
			default:
				throw new Exception();
			}
			return (JsonConverter)Activator.CreateInstance(type2, args);
		}
	}
	internal sealed class FSharpOptionConverter<TOption, TElement> : JsonConverter<TOption> where TOption : class
	{
		private readonly JsonConverter<TElement> _elementConverter;

		private readonly Func<TOption, TElement> _optionValueGetter;

		private readonly Func<TElement, TOption> _optionConstructor;

		internal override Type ElementType => typeof(TElement);

		public override bool HandleNull => true;

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
		public FSharpOptionConverter(JsonConverter<TElement> elementConverter)
		{
			_elementConverter = elementConverter;
			_optionValueGetter = FSharpCoreReflectionProxy.Instance.CreateFSharpOptionValueGetter<TOption, TElement>();
			_optionConstructor = FSharpCoreReflectionProxy.Instance.CreateFSharpOptionSomeConstructor<TOption, TElement>();
			base.ConverterStrategy = elementConverter.ConverterStrategy;
		}

		internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out TOption value)
		{
			if (!state.IsContinuation && reader.TokenType == JsonTokenType.Null)
			{
				value = null;
				return true;
			}
			state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
			if (_elementConverter.TryRead(ref reader, typeof(TElement), options, ref state, out var value2, out var _))
			{
				value = _optionConstructor(value2);
				return true;
			}
			value = null;
			return false;
		}

		internal override bool OnTryWrite(Utf8JsonWriter writer, TOption value, JsonSerializerOptions options, ref WriteStack state)
		{
			if (value == null)
			{
				writer.WriteNullValue();
				return true;
			}
			TElement value2 = _optionValueGetter(value);
			state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
			return _elementConverter.TryWrite(writer, in value2, options, ref state);
		}

		public override void Write(Utf8JsonWriter writer, TOption value, JsonSerializerOptions options)
		{
			if (value == null)
			{
				writer.WriteNullValue();
				return;
			}
			TElement value2 = _optionValueGetter(value);
			_elementConverter.Write(writer, value2, options);
		}

		public override TOption Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.Null)
			{
				return null;
			}
			TElement arg = _elementConverter.Read(ref reader, typeToConvert, options);
			return _optionConstructor(arg);
		}
	}
	internal sealed class FSharpValueOptionConverter<TValueOption, TElement> : JsonConverter<TValueOption> where TValueOption : struct, IEquatable<TValueOption>
	{
		private readonly JsonConverter<TElement> _elementConverter;

		private readonly FSharpCoreReflectionProxy.StructGetter<TValueOption, TElement> _optionValueGetter;

		private readonly Func<TElement, TValueOption> _optionConstructor;

		internal override Type ElementType => typeof(TElement);

		public override bool HandleNull => true;

		[RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
		[RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
		public FSharpValueOptionConverter(JsonConverter<TElement> elementConverter)
		{
			_elementConverter = elementConverter;
			_optionValueGetter = FSharpCoreReflectionProxy.Instance.CreateFSharpValueOptionValueGetter<TValueOption, TElement>();
			_optionConstructor = FSharpCoreReflectionProxy.Instance.CreateFSharpValueOptionSomeConstructor<TValueOption, TElement>();
			base.ConverterStrategy = elementConverter.ConverterStrategy;
		}

		internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out TValueOption value)
		{
			if (!state.IsContinuation && reader.TokenType == JsonTokenType.Null)
			{
				value = default(TValueOption);
				return true;
			}
			state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
			if (_elementConverter.TryRead(ref reader, typeof(TElement), options, ref state, out var value2, out var _))
			{
				value = _optionConstructor(value2);
				return true;
			}
			value = default(TValueOption);
			return false;
		}

		internal override bool OnTryWrite(Utf8JsonWriter writer, TValueOption value, JsonSerializerOptions options, ref WriteStack state)
		{
			if (value.Equals(default(TValueOption)))
			{
				writer.WriteNullValue();
				return true;
			}
			TElement value2 = _optionValueGetter(ref value);
			state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
			return _elementConverter.TryWrite(writer, in value2, options, ref state);
		}

		public override void Write(Utf8JsonWriter writer, TValueOption value, JsonSerializerOptions options)
		{
			if (value.Equals(default(TValueOption)))
			{
				writer.WriteNullValue();
				return;
			}
			TElement value2 = _optionValueGetter(ref value);
			_elementConverter.Write(writer, value2, options);
		}

		public override TValueOption Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.Null)
			{
				return default(TValueOption);
			}
			TElement arg = _elementConverter.Read(ref reader, typeToConvert, options);
			return _optionConstructor(arg);
		}
	}
	internal sealed class JsonArrayConverter : JsonConverter<JsonArray>
	{
		public override void Write(Utf8JsonWriter writer, JsonArray value, JsonSerializerOptions options)
		{
			if (value == null)
			{
				writer.WriteNullValue();
			}
			else
			{
				value.WriteTo(writer, options);
			}
		}

		public override JsonArray Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.TokenType switch
			{
				JsonTokenType.StartArray => ReadList(ref reader, options.GetNodeOptions()), 
				JsonTokenType.Null => null, 
				_ => throw ThrowHelper.GetInvalidOperationException_ExpectedArray(reader.TokenType), 
			};
		}

		public static JsonArray ReadList(ref Utf8JsonReader reader, JsonNodeOptions? options = null)
		{
			JsonElement element = JsonElement.ParseValue(ref reader);
			return new JsonArray(element, options);
		}
	}
	internal sealed class JsonNodeConverter : JsonConverter<JsonNode>
	{
		private static JsonNodeConverter s_nodeConverter;

		private static JsonArrayConverter s_arrayConverter;

		private static JsonObjectConverter s_objectConverter;

		private static JsonValueConverter s_valueConverter;

		public static JsonNodeConverter Instance => s_nodeConverter ?? (s_nodeConverter = new JsonNodeConverter());

		public static JsonArrayConverter ArrayConverter => s_arrayConverter ?? (s_arrayConverter = new JsonArrayConverter());

		public static JsonObjectConverter ObjectConverter => s_objectConverter ?? (s_objectConverter = new JsonObjectConverter());

		public static JsonValueConverter ValueConverter => s_valueConverter ?? (s_valueConverter = new JsonValueConverter());

		public override void Write(Utf8JsonWriter writer, JsonNode value, JsonSerializerOptions options)
		{
			if (value == null)
			{
				writer.WriteNullValue();
			}
			else
			{
				value.WriteTo(writer, options);
			}
		}

		public override JsonNode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			switch (reader.TokenType)
			{
			case JsonTokenType.String:
			case JsonTokenType.Number:
			case JsonTokenType.True:
			case JsonTokenType.False:
				return ValueConverter.Read(ref reader, typeToConvert, options);
			case JsonTokenType.StartObject:
				return ObjectConverter.Read(ref reader, typeToConvert, options);
			case JsonTokenType.StartArray:
				return ArrayConverter.Read(ref reader, typeToConvert, options);
			case JsonTokenType.Null:
				return null;
			default:
				throw new JsonException();
			}
		}

		public static JsonNode Create(JsonElement element, JsonNodeOptions? options)
		{
			return element.ValueKind switch
			{
				JsonValueKind.Null => null, 
				JsonValueKind.Object => new JsonObject(element, options), 
				JsonValueKind.Array => new JsonArray(element, options), 
				_ => new JsonValuePrimitive<JsonElement>(element, JsonMetadataServices.JsonElementConverter, options), 
			};
		}
	}
	internal sealed class JsonNodeConverterFactory : JsonConverterFactory
	{
		public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
		{
			if (typeof(JsonValue).IsAssignableFrom(typeToConvert))
			{
				return JsonNodeConverter.ValueConverter;
			}
			if (typeof(JsonObject) == typeToConvert)
			{
				return JsonNodeConverter.ObjectConverter;
			}
			if (typeof(JsonArray) == typeToConvert)
			{
				return JsonNodeConverter.ArrayConverter;
			}
			return JsonNodeConverter.Instance;
		}

		public override bool CanConvert(Type typeToConvert)
		{
			return typeof(JsonNode).IsAssignableFrom(typeToConvert);
		}
	}
	internal sealed class JsonObjectConverter : JsonConverter<JsonObject>
	{
		internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
		{
			jsonTypeInfo.CreateObjectForExtensionDataProperty = () => new JsonObject(options.GetNodeOptions());
		}

		internal override void ReadElementAndSetProperty(object obj, string propertyName, ref Utf8JsonReader reader, JsonSerializerOptions options, scoped ref ReadStack state)
		{
			JsonNode value;
			bool isPopulatedValue;
			bool flag = JsonNodeConverter.Instance.TryRead(ref reader, typeof(JsonNode), options, ref state, out value, out isPopulatedValue);
			JsonObject jsonObject = (JsonObject)obj;
			JsonNode value2 = value;
			jsonObject[propertyName] = value2;
		}

		public override void Write(Utf8JsonWriter writer, JsonObject value, JsonSerializerOptions options)
		{
			if (value == null)
			{
				writer.WriteNullValue();
			}
			else
			{
				value.WriteTo(writer, options);
			}
		}

		public override JsonObject Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.TokenType switch
			{
				JsonTokenType.StartObject => ReadObject(ref reader, options.GetNodeOptions()), 
				JsonTokenType.Null => null, 
				_ => throw ThrowHelper.GetInvalidOperationException_ExpectedObject(reader.TokenType), 
			};
		}

		public static JsonObject ReadObject(ref Utf8JsonReader reader, JsonNodeOptions? options)
		{
			JsonElement element = JsonElement.ParseValue(ref reader);
			return new JsonObject(element, options);
		}
	}
	internal sealed class JsonValueConverter : JsonConverter<JsonValue>
	{
		public override void Write(Utf8JsonWriter writer, JsonValue value, JsonSerializerOptions options)
		{
			if (value == null)
			{
				writer.WriteNullValue();
			}
			else
			{
				value.WriteTo(writer, options);
			}
		}

		public override JsonValue Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.Null)
			{
				return null;
			}
			JsonElement value = JsonElement.ParseValue(ref reader);
			return new JsonValuePrimitive<JsonElement>(value, JsonMetadataServices.JsonElementConverter, options.GetNodeOptions());
		}
	}
	internal abstract class ObjectConverter : JsonConverter<object>
	{
		private protected override ConverterStrategy GetDefaultConverterStrategy()
		{
			return ConverterStrategy.Object;
		}

		public ObjectConverter()
		{
			base.CanBePolymorphic = true;
		}

		public sealed override object ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			ThrowHelper.ThrowNotSupportedException_DictionaryKeyTypeNotSupported(Type, this);
			return null;
		}

		internal sealed override object ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			ThrowHelper.ThrowNotSupportedException_DictionaryKeyTypeNotSupported(Type, this);
			return null;
		}

		public sealed override void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options)
		{
			if (value == null)
			{
				writer.WriteNullValue();
				return;
			}
			writer.WriteStartObject();
			writer.WriteEndObject();
		}

		public sealed override void WriteAsPropertyName(Utf8JsonWriter writer, object value, JsonSerializerOptions options)
		{
			WriteAsPropertyNameCore(writer, value, options, isWritingExtensionDataProperty: false);
		}

		internal sealed override void WriteAsPropertyNameCore(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			if (value == null)
			{
				ThrowHelper.ThrowArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == Type)
			{
				ThrowHelper.ThrowNotSupportedException_DictionaryKeyTypeNotSupported(type, this);
			}
			JsonConverter converterInternal = options.GetConverterInternal(type);
			converterInternal.WriteAsPropertyNameCoreAsObject(writer, value, options, isWritingExtensionDataProperty);
		}
	}
	internal sealed class SlimObjectConverter : ObjectConverter
	{
		private readonly IJsonTypeInfoResolver _originatingResolver;

		public SlimObjectConverter(IJsonTypeInfoResolver originatingResolver)
		{
			_originatingResolver = originatingResolver;
		}

		public override object Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			ThrowHelper.ThrowNotSupportedException_NoMetadataForType(typeToConvert, _originatingResolver);
			return null;
		}
	}
	internal sealed class DefaultObjectConverter : ObjectConverter
	{
		public DefaultObjectConverter()
		{
			base.RequiresReadAhead = true;
		}

		public override object Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			if (options.UnknownTypeHandling == JsonUnknownTypeHandling.JsonElement)
			{
				return JsonElement.ParseValue(ref reader);
			}
			return JsonNodeConverter.Instance.Read(ref reader, typeToConvert, options);
		}

		internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out object value)
		{
			object referenceValue;
			if (options.UnknownTypeHandling == JsonUnknownTypeHandling.JsonElement)
			{
				JsonElement jsonElement = JsonElement.ParseValue(ref reader);
				if (options.ReferenceHandlingStrategy == ReferenceHandlingStrategy.Preserve && JsonSerializer.TryHandleReferenceFromJsonElement(ref reader, ref state, jsonElement, out referenceValue))
				{
					value = referenceValue;
				}
				else
				{
					value = jsonElement;
				}
				return true;
			}
			JsonNode jsonNode = JsonNodeConverter.Instance.Read(ref reader, typeToConvert, options);
			if (options.ReferenceHandlingStrategy == ReferenceHandlingStrategy.Preserve && JsonSerializer.TryHandleReferenceFromJsonNode(ref reader, ref state, jsonNode, out referenceValue))
			{
				value = referenceValue;
			}
			else
			{
				value = jsonNode;
			}
			return true;
		}
	}
	[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
	internal sealed class ObjectConverterFactory : JsonConverterFactory
	{
		private readonly bool _useDefaultConstructorInUnannotatedStructs;

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		public ObjectConverterFactory(bool useDefaultConstructorInUnannotatedStructs = true)
		{
			_useDefaultConstructorInUnannotatedStructs = useDefaultConstructorInUnannotatedStructs;
		}

		public override bool CanConvert(Type typeToConvert)
		{
			return true;
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The ctor is marked RequiresUnreferencedCode.")]
		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2067:UnrecognizedReflectionPattern", Justification = "The ctor is marked RequiresUnreferencedCode.")]
		public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
		{
			bool useDefaultCtorInAnnotatedStructs = _useDefaultConstructorInUnannotatedStructs && !typeToConvert.IsKeyValuePair();
			if (!typeToConvert.TryGetDeserializationConstructor(useDefaultCtorInAnnotatedStructs, out var deserializationCtor))
			{
				ThrowHelper.ThrowInvalidOperationException_SerializationDuplicateTypeAttribute<JsonConstructorAttribute>(typeToConvert);
			}
			ParameterInfo[] array = deserializationCtor?.GetParameters();
			Type type;
			if (deserializationCtor == null || typeToConvert.IsAbstract || array.Length == 0)
			{
				type = typeof(ObjectDefaultConverter<>).MakeGenericType(typeToConvert);
			}
			else
			{
				int num = array.Length;
				if (num <= 4)
				{
					Type objectType = JsonTypeInfo.ObjectType;
					Type[] array2 = new Type[5] { typeToConvert, null, null, null, null };
					for (int i = 0; i < 4; i++)
					{
						if (i < num)
						{
							array2[i + 1] = array[i].ParameterType;
						}
						else
						{
							array2[i + 1] = objectType;
						}
					}
					type = typeof(SmallObjectWithParameterizedConstructorConverter<, , , , >).MakeGenericType(array2);
				}
				else
				{
					type = typeof(LargeObjectWithParameterizedConstructorConverterWithReflection<>).MakeGenericType(typeToConvert);
				}
			}
			JsonConverter jsonConverter = (JsonConverter)Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Public, null, null, null);
			jsonConverter.ConstructorInfo = deserializationCtor;
			return jsonConverter;
		}
	}
	internal class ObjectDefaultConverter<T> : JsonObjectConverter<T>
	{
		internal override bool CanHaveMetadata => true;

		internal override bool SupportsCreateObjectDelegate => true;

		internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, [MaybeNullWhen(false)] out T value)
		{
			JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
			object obj;
			if (!state.SupportContinuation && !state.Current.CanContainMetadata)
			{
				if (reader.TokenType != JsonTokenType.StartObject)
				{
					ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(Type);
				}
				JsonPropertyInfo parentProperty = state.ParentProperty;
				if (parentProperty != null && parentProperty.TryGetPrePopulatedValue(ref state))
				{
					obj = state.Current.ReturnValue;
				}
				else
				{
					if (jsonTypeInfo.CreateObject == null)
					{
						ThrowHelper.ThrowNotSupportedException_DeserializeNoConstructor(jsonTypeInfo.Type, ref reader, ref state);
					}
					obj = jsonTypeInfo.CreateObject();
				}
				PopulatePropertiesFastPath(obj, jsonTypeInfo, options, ref reader, ref state);
				value = (T)obj;
				return true;
			}
			if (state.Current.ObjectState == StackFrameObjectState.None)
			{
				if (reader.TokenType != JsonTokenType.StartObject)
				{
					ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(Type);
				}
				state.Current.ObjectState = StackFrameObjectState.StartToken;
			}
			if (state.Current.CanContainMetadata && (int)state.Current.ObjectState < 2)
			{
				if (!JsonSerializer.TryReadMetadata(this, jsonTypeInfo, ref reader, ref state))
				{
					value = default(T);
					return false;
				}
				if (state.Current.MetadataPropertyNames == MetadataPropertyName.Ref)
				{
					value = JsonSerializer.ResolveReferenceId<T>(ref state);
					return true;
				}
				state.Current.ObjectState = StackFrameObjectState.ReadMetadata;
			}
			if ((state.Current.MetadataPropertyNames & MetadataPropertyName.Type) != MetadataPropertyName.None && state.Current.PolymorphicSerializationState != PolymorphicSerializationState.PolymorphicReEntryStarted)
			{
				JsonConverter jsonConverter = ResolvePolymorphicConverter(jsonTypeInfo, ref state);
				if (jsonConverter != null)
				{
					object value2;
					bool flag = jsonConverter.OnTryReadAsObject(ref reader, jsonConverter.Type, options, ref state, out value2);
					value = (T)value2;
					state.ExitPolymorphicConverter(flag);
					return flag;
				}
			}
			if ((int)state.Current.ObjectState < 4)
			{
				if (state.Current.CanContainMetadata)
				{
					JsonSerializer.ValidateMetadataForObjectConverter(ref state);
				}
				if (state.Current.MetadataPropertyNames == MetadataPropertyName.Ref)
				{
					value = JsonSerializer.ResolveReferenceId<T>(ref state);
					return true;
				}
				JsonPropertyInfo parentProperty2 = state.ParentProperty;
				if (parentProperty2 != null && parentProperty2.TryGetPrePopulatedValue(ref state))
				{
					obj = state.Current.ReturnValue;
				}
				else
				{
					if (jsonTypeInfo.CreateObject == null)
					{
						ThrowHelper.ThrowNotSupportedException_DeserializeNoConstructor(jsonTypeInfo.Type, ref reader, ref state);
					}
					obj = jsonTypeInfo.CreateObject();
				}
				if ((state.Current.MetadataPropertyNames & MetadataPropertyName.Id) != MetadataPropertyName.None)
				{
					state.ReferenceResolver.AddReference(state.ReferenceId, obj);
					state.ReferenceId = null;
				}
				jsonTypeInfo.OnDeserializing?.Invoke(obj);
				state.Current.ReturnValue = obj;
				state.Current.ObjectState = StackFrameObjectState.CreatedObject;
				state.Current.InitializeRequiredPropertiesValidationState(jsonTypeInfo);
			}
			else
			{
				obj = state.Current.ReturnValue;
			}
			while (true)
			{
				if (state.Current.PropertyState == StackFramePropertyState.None)
				{
					state.Current.PropertyState = StackFramePropertyState.ReadName;
					if (!reader.Read())
					{
						state.Current.ReturnValue = obj;
						value = default(T);
						return false;
					}
				}
				JsonPropertyInfo jsonPropertyInfo;
				if ((int)state.Current.PropertyState < 2)
				{
					state.Current.PropertyState = StackFramePropertyState.Name;
					JsonTokenType tokenType = reader.TokenType;
					if (tokenType == JsonTokenType.EndObject)
					{
						break;
					}
					ReadOnlySpan<byte> propertyName = JsonSerializer.GetPropertyName(ref state, ref reader);
					jsonPropertyInfo = JsonSerializer.LookupProperty(obj, propertyName, ref state, options, out var useExtensionProperty);
					state.Current.UseExtensionProperty = useExtensionProperty;
				}
				else
				{
					jsonPropertyInfo = state.Current.JsonPropertyInfo;
				}
				if ((int)state.Current.PropertyState < 3)
				{
					if (!jsonPropertyInfo.CanDeserializeOrPopulate)
					{
						if (!reader.TrySkip())
						{
							state.Current.ReturnValue = obj;
							value = default(T);
							return false;
						}
						state.Current.EndProperty();
						continue;
					}
					if (!ReadAheadPropertyValue(ref state, ref reader, jsonPropertyInfo))
					{
						state.Current.ReturnValue = obj;
						value = default(T);
						return false;
					}
				}
				if ((int)state.Current.PropertyState >= 5)
				{
					continue;
				}
				if (!state.Current.UseExtensionProperty)
				{
					if (!jsonPropertyInfo.ReadJsonAndSetMember(obj, ref state, ref reader))
					{
						state.Current.ReturnValue = obj;
						value = default(T);
						return false;
					}
				}
				else if (!jsonPropertyInfo.ReadJsonAndAddExtensionProperty(obj, ref state, ref reader))
				{
					state.Current.ReturnValue = obj;
					value = default(T);
					return false;
				}
				state.Current.EndProperty();
			}
			jsonTypeInfo.OnDeserialized?.Invoke(obj);
			state.Current.ValidateAllRequiredPropertiesAreRead(jsonTypeInfo);
			value = (T)obj;
			if (state.Current.PropertyRefCache != null)
			{
				jsonTypeInfo.UpdateSortedPropertyCache(ref state.Current);
			}
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopulatePropertiesFastPath(object obj, JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options, ref Utf8JsonReader reader, scoped ref ReadStack state)
		{
			jsonTypeInfo.OnDeserializing?.Invoke(obj);
			state.Current.InitializeRequiredPropertiesValidationState(jsonTypeInfo);
			while (true)
			{
				reader.ReadWithVerify();
				JsonTokenType tokenType = reader.TokenType;
				if (tokenType == JsonTokenType.EndObject)
				{
					break;
				}
				ReadOnlySpan<byte> propertyName = JsonSerializer.GetPropertyName(ref state, ref reader);
				bool useExtensionProperty;
				JsonPropertyInfo jsonPropertyInfo = JsonSerializer.LookupProperty(obj, propertyName, ref state, options, out useExtensionProperty);
				ReadPropertyValue(obj, ref state, ref reader, jsonPropertyInfo, useExtensionProperty);
			}
			jsonTypeInfo.OnDeserialized?.Invoke(obj);
			state.Current.ValidateAllRequiredPropertiesAreRead(jsonTypeInfo);
			if (state.Current.PropertyRefCache != null)
			{
				jsonTypeInfo.UpdateSortedPropertyCache(ref state.Current);
			}
		}

		internal sealed override bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, ref WriteStack state)
		{
			JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
			jsonTypeInfo.ValidateCanBeUsedForPropertyMetadataSerialization();
			object obj = value;
			if (!state.SupportContinuation)
			{
				writer.WriteStartObject();
				if (state.CurrentContainsMetadata && CanHaveMetadata)
				{
					JsonSerializer.WriteMetadataForObject(this, ref state, writer);
				}
				jsonTypeInfo.OnSerializing?.Invoke(obj);
				List<KeyValuePair<string, JsonPropertyInfo>> list = jsonTypeInfo.PropertyCache.List;
				for (int i = 0; i < list.Count; i++)
				{
					JsonPropertyInfo value2 = list[i].Value;
					if (value2.CanSerialize)
					{
						state.Current.JsonPropertyInfo = value2;
						state.Current.NumberHandling = value2.EffectiveNumberHandling;
						bool memberAndWriteJson = value2.GetMemberAndWriteJson(obj, ref state, writer);
						state.Current.EndProperty();
					}
				}
				JsonPropertyInfo extensionDataProperty = jsonTypeInfo.ExtensionDataProperty;
				if (extensionDataProperty != null && extensionDataProperty.CanSerialize)
				{
					state.Current.JsonPropertyInfo = extensionDataProperty;
					state.Current.NumberHandling = extensionDataProperty.EffectiveNumberHandling;
					bool memberAndWriteJsonExtensionData = extensionDataProperty.GetMemberAndWriteJsonExtensionData(obj, ref state, writer);
					state.Current.EndProperty();
				}
				writer.WriteEndObject();
			}
			else
			{
				if (!state.Current.ProcessedStartToken)
				{
					writer.WriteStartObject();
					if (state.CurrentContainsMetadata && CanHaveMetadata)
					{
						JsonSerializer.WriteMetadataForObject(this, ref state, writer);
					}
					jsonTypeInfo.OnSerializing?.Invoke(obj);
					state.Current.ProcessedStartToken = true;
				}
				List<KeyValuePair<string, JsonPropertyInfo>> list2 = jsonTypeInfo.PropertyCache.List;
				while (state.Current.EnumeratorIndex < list2.Count)
				{
					JsonPropertyInfo value3 = list2[state.Current.EnumeratorIndex].Value;
					if (value3.CanSerialize)
					{
						state.Current.JsonPropertyInfo = value3;
						state.Current.NumberHandling = value3.EffectiveNumberHandling;
						if (!value3.GetMemberAndWriteJson(obj, ref state, writer))
						{
							return false;
						}
						state.Current.EndProperty();
						state.Current.EnumeratorIndex++;
						if (JsonConverter.ShouldFlush(writer, ref state))
						{
							return false;
						}
					}
					else
					{
						state.Current.EnumeratorIndex++;
					}
				}
				if (state.Current.EnumeratorIndex == list2.Count)
				{
					JsonPropertyInfo extensionDataProperty2 = jsonTypeInfo.ExtensionDataProperty;
					if (extensionDataProperty2 != null && extensionDataProperty2.CanSerialize)
					{
						state.Current.JsonPropertyInfo = extensionDataProperty2;
						state.Current.NumberHandling = extensionDataProperty2.EffectiveNumberHandling;
						if (!extensionDataProperty2.GetMemberAndWriteJsonExtensionData(obj, ref state, writer))
						{
							return false;
						}
						state.Current.EndProperty();
						state.Current.EnumeratorIndex++;
						if (JsonConverter.ShouldFlush(writer, ref state))
						{
							return false;
						}
					}
					else
					{
						state.Current.EnumeratorIndex++;
					}
				}
				if (!state.Current.ProcessedEndToken)
				{
					state.Current.ProcessedEndToken = true;
					writer.WriteEndObject();
				}
			}
			jsonTypeInfo.OnSerialized?.Invoke(obj);
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		protected static void ReadPropertyValue(object obj, scoped ref ReadStack state, ref Utf8JsonReader reader, JsonPropertyInfo jsonPropertyInfo, bool useExtensionProperty)
		{
			if (!jsonPropertyInfo.CanDeserializeOrPopulate)
			{
				bool flag = reader.TrySkip();
			}
			else
			{
				reader.ReadWithVerify();
				if (!useExtensionProperty)
				{
					jsonPropertyInfo.ReadJsonAndSetMember(obj, ref state, ref reader);
				}
				else
				{
					jsonPropertyInfo.ReadJsonAndAddExtensionProperty(obj, ref state, ref reader);
				}
			}
			state.Current.EndProperty();
		}

		protected static bool ReadAheadPropertyValue(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonPropertyInfo jsonPropertyInfo)
		{
			state.Current.PropertyState = StackFramePropertyState.ReadValue;
			if (!state.Current.UseExtensionProperty)
			{
				if (!JsonConverter.SingleValueReadWithReadAhead(jsonPropertyInfo.EffectiveConverter.RequiresReadAhead, ref reader, ref state))
				{
					return false;
				}
			}
			else if (!JsonConverter.SingleValueReadWithReadAhead(requiresReadAhead: true, ref reader, ref state))
			{
				return false;
			}
			return true;
		}
	}
	internal abstract class ObjectWithParameterizedConstructorConverter<T> : ObjectDefaultConverter<T>
	{
		internal sealed override bool ConstructorIsParameterized => true;

		internal sealed override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, [MaybeNullWhen(false)] out T value)
		{
			JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
			if (!jsonTypeInfo.UsesParameterizedConstructor || state.Current.IsPopulating)
			{
				return base.OnTryRead(ref reader, typeToConvert, options, ref state, out value);
			}
			ArgumentState ctorArgumentState = state.Current.CtorArgumentState;
			object obj;
			if (!state.SupportContinuation && !state.Current.CanContainMetadata)
			{
				if (reader.TokenType != JsonTokenType.StartObject)
				{
					ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(Type);
				}
				JsonPropertyInfo parentProperty = state.ParentProperty;
				if (parentProperty != null && parentProperty.TryGetPrePopulatedValue(ref state))
				{
					object returnValue = state.Current.ReturnValue;
					ObjectDefaultConverter<T>.PopulatePropertiesFastPath(returnValue, jsonTypeInfo, options, ref reader, ref state);
					value = (T)returnValue;
					return true;
				}
				ReadOnlySpan<byte> originalSpan = reader.OriginalSpan;
				ReadOnlySequence<byte> originalSequence = reader.OriginalSequence;
				ReadConstructorArguments(ref state, ref reader, options);
				obj = (T)CreateObject(ref state.Current);
				jsonTypeInfo.OnDeserializing?.Invoke(obj);
				if (ctorArgumentState.FoundPropertyCount > 0)
				{
					(JsonPropertyInfo, JsonReaderState, long, byte[], string)[] foundProperties = ctorArgumentState.FoundProperties;
					for (int i = 0; i < ctorArgumentState.FoundPropertyCount; i++)
					{
						JsonPropertyInfo item = foundProperties[i].Item1;
						long item2 = foundProperties[i].Item3;
						byte[] item3 = foundProperties[i].Item4;
						string item4 = foundProperties[i].Item5;
						Utf8JsonReader reader2 = (originalSequence.IsEmpty ? new Utf8JsonReader(originalSpan.Slice(checked((int)item2)), isFinalBlock: true, foundProperties[i].Item2) : new Utf8JsonReader(originalSequence.Slice(item2), isFinalBlock: true, foundProperties[i].Item2));
						state.Current.JsonPropertyName = item3;
						state.Current.JsonPropertyInfo = item;
						state.Current.NumberHandling = item.EffectiveNumberHandling;
						bool flag = item4 != null;
						if (flag)
						{
							state.Current.JsonPropertyNameAsString = item4;
							JsonSerializer.CreateExtensionDataProperty(obj, item, options);
						}
						ObjectDefaultConverter<T>.ReadPropertyValue(obj, ref state, ref reader2, item, flag);
					}
					(JsonPropertyInfo, JsonReaderState, long, byte[], string)[] foundProperties2 = ctorArgumentState.FoundProperties;
					ctorArgumentState.FoundProperties = null;
					ArrayPool<(JsonPropertyInfo, JsonReaderState, long, byte[], string)>.Shared.Return(foundProperties2, clearArray: true);
				}
			}
			else
			{
				if (state.Current.ObjectState == StackFrameObjectState.None)
				{
					if (reader.TokenType != JsonTokenType.StartObject)
					{
						ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(Type);
					}
					state.Current.ObjectState = StackFrameObjectState.StartToken;
				}
				if (state.Current.CanContainMetadata && (int)state.Current.ObjectState < 2)
				{
					if (!JsonSerializer.TryReadMetadata(this, jsonTypeInfo, ref reader, ref state))
					{
						value = default(T);
						return false;
					}
					if (state.Current.MetadataPropertyNames == MetadataPropertyName.Ref)
					{
						value = JsonSerializer.ResolveReferenceId<T>(ref state);
						return true;
					}
					state.Current.ObjectState = StackFrameObjectState.ReadMetadata;
				}
				if ((state.Current.MetadataPropertyNames & MetadataPropertyName.Type) != MetadataPropertyName.None && state.Current.PolymorphicSerializationState != PolymorphicSerializationState.PolymorphicReEntryStarted)
				{
					JsonConverter jsonConverter = ResolvePolymorphicConverter(jsonTypeInfo, ref state);
					if (jsonConverter != null)
					{
						object value2;
						bool flag2 = jsonConverter.OnTryReadAsObject(ref reader, jsonConverter.Type, options, ref state, out value2);
						value = (T)value2;
						state.ExitPolymorphicConverter(flag2);
						return flag2;
					}
				}
				JsonPropertyInfo parentProperty2 = state.ParentProperty;
				if (parentProperty2 != null && parentProperty2.TryGetPrePopulatedValue(ref state))
				{
					object returnValue2 = state.Current.ReturnValue;
					jsonTypeInfo.OnDeserializing?.Invoke(returnValue2);
					state.Current.ObjectState = StackFrameObjectState.CreatedObject;
					state.Current.InitializeRequiredPropertiesValidationState(jsonTypeInfo);
					return base.OnTryRead(ref reader, typeToConvert, options, ref state, out value);
				}
				if ((int)state.Current.ObjectState < 3)
				{
					if (state.Current.CanContainMetadata)
					{
						JsonSerializer.ValidateMetadataForObjectConverter(ref state);
					}
					if (state.Current.MetadataPropertyNames == MetadataPropertyName.Ref)
					{
						value = JsonSerializer.ResolveReferenceId<T>(ref state);
						return true;
					}
					BeginRead(ref state, options);
					state.Current.ObjectState = StackFrameObjectState.ConstructorArguments;
				}
				if (!ReadConstructorArgumentsWithContinuation(ref state, ref reader, options))
				{
					value = default(T);
					return false;
				}
				obj = (T)CreateObject(ref state.Current);
				if ((state.Current.MetadataPropertyNames & MetadataPropertyName.Id) != MetadataPropertyName.None)
				{
					state.ReferenceResolver.AddReference(state.ReferenceId, obj);
					state.ReferenceId = null;
				}
				jsonTypeInfo.OnDeserializing?.Invoke(obj);
				if (ctorArgumentState.FoundPropertyCount > 0)
				{
					for (int j = 0; j < ctorArgumentState.FoundPropertyCount; j++)
					{
						JsonPropertyInfo item5 = ctorArgumentState.FoundPropertiesAsync[j].Item1;
						object item6 = ctorArgumentState.FoundPropertiesAsync[j].Item2;
						string item7 = ctorArgumentState.FoundPropertiesAsync[j].Item3;
						if (item7 == null)
						{
							if (item6 != null || !item5.IgnoreNullTokensOnRead || default(T) != null)
							{
								item5.Set(obj, item6);
								state.Current.MarkRequiredPropertyAsRead(item5);
							}
							continue;
						}
						JsonSerializer.CreateExtensionDataProperty(obj, item5, options);
						object valueAsObject = item5.GetValueAsObject(obj);
						if (valueAsObject is IDictionary<string, JsonElement> dictionary)
						{
							dictionary[item7] = (JsonElement)item6;
						}
						else
						{
							((IDictionary<string, object>)valueAsObject)[item7] = item6;
						}
					}
					(JsonPropertyInfo, object, string)[] foundPropertiesAsync = ctorArgumentState.FoundPropertiesAsync;
					ctorArgumentState.FoundPropertiesAsync = null;
					ArrayPool<(JsonPropertyInfo, object, string)>.Shared.Return(foundPropertiesAsync, clearArray: true);
				}
			}
			jsonTypeInfo.OnDeserialized?.Invoke(obj);
			state.Current.ValidateAllRequiredPropertiesAreRead(jsonTypeInfo);
			value = (T)obj;
			if (state.Current.PropertyRefCache != null)
			{
				state.Current.JsonTypeInfo.UpdateSortedPropertyCache(ref state.Current);
			}
			if (ctorArgumentState.ParameterRefCache != null)
			{
				state.Current.JsonTypeInfo.UpdateSortedParameterCache(ref state.Current);
			}
			return true;
		}

		protected abstract void InitializeConstructorArgumentCaches(ref ReadStack state, JsonSerializerOptions options);

		protected abstract bool ReadAndCacheConstructorArgument(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonParameterInfo jsonParameterInfo);

		protected abstract object CreateObject(ref ReadStackFrame frame);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void ReadConstructorArguments(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonSerializerOptions options)
		{
			BeginRead(ref state, options);
			while (true)
			{
				reader.ReadWithVerify();
				JsonTokenType tokenType = reader.TokenType;
				if (tokenType == JsonTokenType.EndObject)
				{
					break;
				}
				if (TryLookupConstructorParameter(ref state, ref reader, options, out var jsonParameterInfo))
				{
					reader.ReadWithVerify();
					if (!jsonParameterInfo.ShouldDeserialize)
					{
						bool flag = reader.TrySkip();
						state.Current.EndConstructorParameter();
					}
					else
					{
						ReadAndCacheConstructorArgument(ref state, ref reader, jsonParameterInfo);
						state.Current.EndConstructorParameter();
					}
					continue;
				}
				ReadOnlySpan<byte> propertyName = JsonSerializer.GetPropertyName(ref state, ref reader);
				bool useExtensionProperty;
				JsonPropertyInfo jsonPropertyInfo = JsonSerializer.LookupProperty(null, propertyName, ref state, options, out useExtensionProperty, createExtensionProperty: false);
				if (jsonPropertyInfo.CanDeserialize)
				{
					ArgumentState ctorArgumentState = state.Current.CtorArgumentState;
					if (ctorArgumentState.FoundProperties == null)
					{
						ctorArgumentState.FoundProperties = ArrayPool<(JsonPropertyInfo, JsonReaderState, long, byte[], string)>.Shared.Rent(Math.Max(1, state.Current.JsonTypeInfo.PropertyCache.Count));
					}
					else if (ctorArgumentState.FoundPropertyCount == ctorArgumentState.FoundProperties.Length)
					{
						(JsonPropertyInfo, JsonReaderState, long, byte[], string)[] array = ArrayPool<(JsonPropertyInfo, JsonReaderState, long, byte[], string)>.Shared.Rent(ctorArgumentState.FoundProperties.Length * 2);
						ctorArgumentState.FoundProperties.CopyTo(array, 0);
						(JsonPropertyInfo, JsonReaderState, long, byte[], string)[] foundProperties = ctorArgumentState.FoundProperties;
						ctorArgumentState.FoundProperties = array;
						ArrayPool<(JsonPropertyInfo, JsonReaderState, long, byte[], string)>.Shared.Return(foundProperties, clearArray: true);
					}
					ctorArgumentState.FoundProperties[ctorArgumentState.FoundPropertyCount++] = (jsonPropertyInfo, reader.CurrentState, reader.BytesConsumed, state.Current.JsonPropertyName, state.Current.JsonPropertyNameAsString);
				}
				bool flag2 = reader.TrySkip();
				state.Current.EndProperty();
			}
		}

		private bool ReadConstructorArgumentsWithContinuation(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonSerializerOptions options)
		{
			while (true)
			{
				if (state.Current.PropertyState == StackFramePropertyState.None)
				{
					state.Current.PropertyState = StackFramePropertyState.ReadName;
					if (!reader.Read())
					{
						return false;
					}
				}
				JsonParameterInfo jsonParameterInfo;
				JsonPropertyInfo jsonPropertyInfo;
				if ((int)state.Current.PropertyState < 2)
				{
					state.Current.PropertyState = StackFramePropertyState.Name;
					JsonTokenType tokenType = reader.TokenType;
					if (tokenType == JsonTokenType.EndObject)
					{
						return true;
					}
					if (TryLookupConstructorParameter(ref state, ref reader, options, out jsonParameterInfo))
					{
						jsonPropertyInfo = null;
					}
					else
					{
						ReadOnlySpan<byte> propertyName = JsonSerializer.GetPropertyName(ref state, ref reader);
						jsonPropertyInfo = JsonSerializer.LookupProperty(null, propertyName, ref state, options, out var useExtensionProperty, createExtensionProperty: false);
						state.Current.UseExtensionProperty = useExtensionProperty;
					}
				}
				else
				{
					jsonParameterInfo = state.Current.CtorArgumentState.JsonParameterInfo;
					jsonPropertyInfo = state.Current.JsonPropertyInfo;
				}
				if (jsonParameterInfo != null)
				{
					if (!HandleConstructorArgumentWithContinuation(ref state, ref reader, jsonParameterInfo))
					{
						return false;
					}
				}
				else if (!HandlePropertyWithContinuation(ref state, ref reader, jsonPropertyInfo))
				{
					break;
				}
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private bool HandleConstructorArgumentWithContinuation(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonParameterInfo jsonParameterInfo)
		{
			if ((int)state.Current.PropertyState < 3)
			{
				if (!jsonParameterInfo.ShouldDeserialize)
				{
					if (!reader.TrySkip())
					{
						return false;
					}
					state.Current.EndConstructorParameter();
					return true;
				}
				state.Current.PropertyState = StackFramePropertyState.ReadValue;
				if (!JsonConverter.SingleValueReadWithReadAhead(jsonParameterInfo.EffectiveConverter.RequiresReadAhead, ref reader, ref state))
				{
					return false;
				}
			}
			if (!ReadAndCacheConstructorArgument(ref state, ref reader, jsonParameterInfo))
			{
				return false;
			}
			state.Current.EndConstructorParameter();
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static bool HandlePropertyWithContinuation(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonPropertyInfo jsonPropertyInfo)
		{
			if ((int)state.Current.PropertyState < 3)
			{
				if (!jsonPropertyInfo.CanDeserialize)
				{
					if (!reader.TrySkip())
					{
						return false;
					}
					state.Current.EndProperty();
					return true;
				}
				if (!ObjectDefaultConverter<T>.ReadAheadPropertyValue(ref state, ref reader, jsonPropertyInfo))
				{
					return false;
				}
			}
			object value;
			if (state.Current.UseExtensionProperty)
			{
				if (!jsonPropertyInfo.ReadJsonExtensionDataValue(ref state, ref reader, out value))
				{
					return false;
				}
			}
			else if (!jsonPropertyInfo.ReadJsonAsObject(ref state, ref reader, out value))
			{
				return false;
			}
			ArgumentState ctorArgumentState = state.Current.CtorArgumentState;
			if (ctorArgumentState.FoundPropertiesAsync == null)
			{
				ctorArgumentState.FoundPropertiesAsync = ArrayPool<(JsonPropertyInfo, object, string)>.Shared.Rent(Math.Max(1, state.Current.JsonTypeInfo.PropertyCache.Count));
			}
			else if (ctorArgumentState.FoundPropertyCount == ctorArgumentState.FoundPropertiesAsync.Length)
			{
				(JsonPropertyInfo, object, string)[] array = ArrayPool<(JsonPropertyInfo, object, string)>.Shared.Rent(ctorArgumentState.FoundPropertiesAsync.Length * 2);
				ctorArgumentState.FoundPropertiesAsync.CopyTo(array, 0);
				(JsonPropertyInfo, object, string)[] foundPropertiesAsync = ctorArgumentState.FoundPropertiesAsync;
				ctorArgumentState.FoundPropertiesAsync = array;
				ArrayPool<(JsonPropertyInfo, object, string)>.Shared.Return(foundPropertiesAsync, clearArray: true);
			}
			ctorArgumentState.FoundPropertiesAsync[ctorArgumentState.FoundPropertyCount++] = (jsonPropertyInfo, value, state.Current.JsonPropertyNameAsString);
			state.Current.EndProperty();
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void BeginRead(scoped ref ReadStack state, JsonSerializerOptions options)
		{
			JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
			jsonTypeInfo.ValidateCanBeUsedForPropertyMetadataSerialization();
			if (jsonTypeInfo.ParameterCount != jsonTypeInfo.ParameterCache.Count)
			{
				ThrowHelper.ThrowInvalidOperationException_ConstructorParameterIncompleteBinding(Type);
			}
			state.Current.InitializeRequiredPropertiesValidationState(jsonTypeInfo);
			state.Current.JsonPropertyInfo = null;
			InitializeConstructorArgumentCaches(ref state, options);
		}

		protected virtual bool TryLookupConstructorParameter(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonSerializerOptions options, out JsonParameterInfo jsonParameterInfo)
		{
			ReadOnlySpan<byte> propertyName = JsonSerializer.GetPropertyName(ref state, ref reader);
			jsonParameterInfo = state.Current.JsonTypeInfo.GetParameter(propertyName, ref state.Current, out var utf8PropertyName);
			state.Current.CtorArgumentState.ParameterIndex++;
			state.Current.JsonPropertyName = utf8PropertyName;
			state.Current.CtorArgumentState.JsonParameterInfo = jsonParameterInfo;
			state.Current.NumberHandling = jsonParameterInfo?.NumberHandling;
			return jsonParameterInfo != null;
		}
	}
	internal class LargeObjectWithParameterizedConstructorConverter<T> : ObjectWithParameterizedConstructorConverter<T>
	{
		protected sealed override bool ReadAndCacheConstructorArgument(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonParameterInfo jsonParameterInfo)
		{
			object value;
			bool flag = jsonParameterInfo.EffectiveConverter.TryReadAsObject(ref reader, jsonParameterInfo.ParameterType, jsonParameterInfo.Options, ref state, out value);
			if (flag && (value != null || !jsonParameterInfo.IgnoreNullTokensOnRead))
			{
				((object[])state.Current.CtorArgumentState.Arguments)[jsonParameterInfo.Position] = value;
				state.Current.MarkRequiredPropertyAsRead(jsonParameterInfo.MatchingProperty);
			}
			return flag;
		}

		protected sealed override object CreateObject(ref ReadStackFrame frame)
		{
			object[] array = (object[])frame.CtorArgumentState.Arguments;
			frame.CtorArgumentState.Arguments = null;
			Func<object[], T> func = (Func<object[], T>)frame.JsonTypeInfo.CreateObjectWithArgs;
			object result = func(array);
			ArrayPool<object>.Shared.Return(array, clearArray: true);
			return result;
		}

		protected sealed override void InitializeConstructorArgumentCaches(ref ReadStack state, JsonSerializerOptions options)
		{
			JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
			List<KeyValuePair<string, JsonParameterInfo>> list = jsonTypeInfo.ParameterCache.List;
			object[] array = ArrayPool<object>.Shared.Rent(list.Count);
			for (int i = 0; i < jsonTypeInfo.ParameterCount; i++)
			{
				JsonParameterInfo value = list[i].Value;
				array[value.Position] = value.DefaultValue;
			}
			state.Current.CtorArgumentState.Arguments = array;
		}
	}
	internal sealed class SmallObjectWithParameterizedConstructorConverter<T, TArg0, TArg1, TArg2, TArg3> : ObjectWithParameterizedConstructorConverter<T>
	{
		protected override object CreateObject(ref ReadStackFrame frame)
		{
			JsonTypeInfo.ParameterizedConstructorDelegate<T, TArg0, TArg1, TArg2, TArg3> parameterizedConstructorDelegate = (JsonTypeInfo.ParameterizedConstructorDelegate<T, TArg0, TArg1, TArg2, TArg3>)frame.JsonTypeInfo.CreateObjectWithArgs;
			Arguments<TArg0, TArg1, TArg2, TArg3> arguments = (Arguments<TArg0, TArg1, TArg2, TArg3>)frame.CtorArgumentState.Arguments;
			return parameterizedConstructorDelegate(arguments.Arg0, arguments.Arg1, arguments.Arg2, arguments.Arg3);
		}

		protected override bool ReadAndCacheConstructorArgument(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonParameterInfo jsonParameterInfo)
		{
			Arguments<TArg0, TArg1, TArg2, TArg3> arguments = (Arguments<TArg0, TArg1, TArg2, TArg3>)state.Current.CtorArgumentState.Arguments;
			return jsonParameterInfo.Position switch
			{
				0 => TryRead<TArg0>(ref state, ref reader, jsonParameterInfo, out arguments.Arg0), 
				1 => TryRead<TArg1>(ref state, ref reader, jsonParameterInfo, out arguments.Arg1), 
				2 => TryRead<TArg2>(ref state, ref reader, jsonParameterInfo, out arguments.Arg2), 
				3 => TryRead<TArg3>(ref state, ref reader, jsonParameterInfo, out arguments.Arg3), 
				_ => throw new InvalidOperationException(), 
			};
		}

		private static bool TryRead<TArg>(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonParameterInfo jsonParameterInfo, out TArg arg)
		{
			JsonParameterInfo<TArg> jsonParameterInfo2 = (JsonParameterInfo<TArg>)jsonParameterInfo;
			TArg value;
			bool isPopulatedValue;
			bool flag = jsonParameterInfo2.EffectiveConverter.TryRead(ref reader, jsonParameterInfo2.ParameterType, jsonParameterInfo2.Options, ref state, out value, out isPopulatedValue);
			arg = ((value == null && jsonParameterInfo.IgnoreNullTokensOnRead) ? jsonParameterInfo2.DefaultValue : value);
			if (flag)
			{
				state.Current.MarkRequiredPropertyAsRead(jsonParameterInfo.MatchingProperty);
			}
			return flag;
		}

		protected override void InitializeConstructorArgumentCaches(ref ReadStack state, JsonSerializerOptions options)
		{
			JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
			Arguments<TArg0, TArg1, TArg2, TArg3> arguments = new Arguments<TArg0, TArg1, TArg2, TArg3>();
			List<KeyValuePair<string, JsonParameterInfo>> list = jsonTypeInfo.ParameterCache.List;
			for (int i = 0; i < jsonTypeInfo.ParameterCount; i++)
			{
				JsonParameterInfo value = list[i].Value;
				switch (value.Position)
				{
				case 0:
					arguments.Arg0 = ((JsonParameterInfo<TArg0>)value).DefaultValue;
					break;
				case 1:
					arguments.Arg1 = ((JsonParameterInfo<TArg1>)value).DefaultValue;
					break;
				case 2:
					arguments.Arg2 = ((JsonParameterInfo<TArg2>)value).DefaultValue;
					break;
				case 3:
					arguments.Arg3 = ((JsonParameterInfo<TArg3>)value).DefaultValue;
					break;
				default:
					throw new InvalidOperationException();
				}
			}
			state.Current.CtorArgumentState.Arguments = arguments;
		}

		[RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
		[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
		internal override void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
		{
			jsonTypeInfo.CreateObjectWithArgs = DefaultJsonTypeInfoResolver.MemberAccessor.CreateParameterizedConstructor<T, TArg0, TArg1, TArg2, TArg3>(base.ConstructorInfo);
		}
	}
	internal sealed class BooleanConverter : JsonPrimitiveConverter<bool>
	{
		public override bool Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetBoolean();
		}

		public override void Write(Utf8JsonWriter writer, bool value, JsonSerializerOptions options)
		{
			writer.WriteBooleanValue(value);
		}

		internal override bool ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			ReadOnlySpan<byte> span = reader.GetSpan();
			if (!Utf8Parser.TryParse(span, out bool value, out int bytesConsumed, '\0') || span.Length != bytesConsumed)
			{
				ThrowHelper.ThrowFormatException(DataType.Boolean);
			}
			return value;
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, bool value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value);
		}
	}
	internal sealed class ByteArrayConverter : JsonConverter<byte[]>
	{
		public override byte[] Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.Null)
			{
				return null;
			}
			return reader.GetBytesFromBase64();
		}

		public override void Write(Utf8JsonWriter writer, byte[] value, JsonSerializerOptions options)
		{
			if (value == null)
			{
				writer.WriteNullValue();
			}
			else
			{
				writer.WriteBase64StringValue(value);
			}
		}
	}
	internal sealed class ByteConverter : JsonPrimitiveConverter<byte>
	{
		public ByteConverter()
		{
			base.IsInternalConverterForNumberType = true;
		}

		public override byte Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetByte();
		}

		public override void Write(Utf8JsonWriter writer, byte value, JsonSerializerOptions options)
		{
			writer.WriteNumberValue(value);
		}

		internal override byte ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetByteWithQuotes();
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, byte value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value);
		}

		internal override byte ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != JsonNumberHandling.Strict)
			{
				return reader.GetByteWithQuotes();
			}
			return reader.GetByte();
		}

		internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, byte value, JsonNumberHandling handling)
		{
			if ((JsonNumberHandling.WriteAsString & handling) != JsonNumberHandling.Strict)
			{
				writer.WriteNumberValueAsString(value);
			}
			else
			{
				writer.WriteNumberValue(value);
			}
		}
	}
	internal sealed class CharConverter : JsonPrimitiveConverter<char>
	{
		private const int MaxEscapedCharacterLength = 6;

		public override char Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			JsonTokenType tokenType = reader.TokenType;
			if ((tokenType != JsonTokenType.PropertyName && tokenType != JsonTokenType.String) || 1 == 0)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedString(reader.TokenType);
			}
			if (!JsonHelpers.IsInRangeInclusive(reader.ValueLength, 1, 6))
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedChar(reader.TokenType);
			}
			Span<char> destination = stackalloc char[6];
			int num = reader.CopyString(destination);
			if (num != 1)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedChar(reader.TokenType);
			}
			return destination[0];
		}

		public override void Write(Utf8JsonWriter writer, char value, JsonSerializerOptions options)
		{
			writer.WriteStringValue(value.ToString());
		}

		internal override char ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return Read(ref reader, typeToConvert, options);
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, char value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value.ToString());
		}
	}
	internal sealed class DateTimeConverter : JsonPrimitiveConverter<DateTime>
	{
		public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetDateTime();
		}

		public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)
		{
			writer.WriteStringValue(value);
		}

		internal override DateTime ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetDateTimeNoValidation();
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value);
		}
	}
	internal sealed class DateTimeOffsetConverter : JsonPrimitiveConverter<DateTimeOffset>
	{
		public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetDateTimeOffset();
		}

		public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
		{
			writer.WriteStringValue(value);
		}

		internal override DateTimeOffset ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetDateTimeOffsetNoValidation();
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value);
		}
	}
	internal sealed class DecimalConverter : JsonPrimitiveConverter<decimal>
	{
		public DecimalConverter()
		{
			base.IsInternalConverterForNumberType = true;
		}

		public override decimal Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetDecimal();
		}

		public override void Write(Utf8JsonWriter writer, decimal value, JsonSerializerOptions options)
		{
			writer.WriteNumberValue(value);
		}

		internal override decimal ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetDecimalWithQuotes();
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, decimal value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value);
		}

		internal override decimal ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != JsonNumberHandling.Strict)
			{
				return reader.GetDecimalWithQuotes();
			}
			return reader.GetDecimal();
		}

		internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, decimal value, JsonNumberHandling handling)
		{
			if ((JsonNumberHandling.WriteAsString & handling) != JsonNumberHandling.Strict)
			{
				writer.WriteNumberValueAsString(value);
			}
			else
			{
				writer.WriteNumberValue(value);
			}
		}
	}
	internal sealed class DoubleConverter : JsonPrimitiveConverter<double>
	{
		public DoubleConverter()
		{
			base.IsInternalConverterForNumberType = true;
		}

		public override double Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetDouble();
		}

		public override void Write(Utf8JsonWriter writer, double value, JsonSerializerOptions options)
		{
			writer.WriteNumberValue(value);
		}

		internal override double ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetDoubleWithQuotes();
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, double value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value);
		}

		internal override double ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.String)
			{
				if ((JsonNumberHandling.AllowReadingFromString & handling) != JsonNumberHandling.Strict)
				{
					return reader.GetDoubleWithQuotes();
				}
				if ((JsonNumberHandling.AllowNamedFloatingPointLiterals & handling) != JsonNumberHandling.Strict)
				{
					return reader.GetDoubleFloatingPointConstant();
				}
			}
			return reader.GetDouble();
		}

		internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, double value, JsonNumberHandling handling)
		{
			if ((JsonNumberHandling.WriteAsString & handling) != JsonNumberHandling.Strict)
			{
				writer.WriteNumberValueAsString(value);
			}
			else if ((JsonNumberHandling.AllowNamedFloatingPointLiterals & handling) != JsonNumberHandling.Strict)
			{
				writer.WriteFloatingPointConstant(value);
			}
			else
			{
				writer.WriteNumberValue(value);
			}
		}
	}
	internal sealed class EnumConverter<T> : JsonPrimitiveConverter<T> where T : struct, Enum
	{
		private static readonly TypeCode s_enumTypeCode = System.Type.GetTypeCode(typeof(T));

		private static readonly bool s_isSignedEnum = (int)s_enumTypeCode % 2 == 1;

		private const string ValueSeparator = ", ";

		private readonly EnumConverterOptions _converterOptions;

		private readonly JsonNamingPolicy _namingPolicy;

		private readonly ConcurrentDictionary<ulong, JsonEncodedText> _nameCacheForWriting;

		private readonly ConcurrentDictionary<string, T> _nameCacheForReading;

		private const int NameCacheSizeSoftLimit = 64;

		public override bool CanConvert(Type type)
		{
			return type.IsEnum;
		}

		public EnumConverter(EnumConverterOptions converterOptions, JsonSerializerOptions serializerOptions)
			: this(converterOptions, (JsonNamingPolicy)null, serializerOptions)
		{
		}

		public EnumConverter(EnumConverterOptions converterOptions, JsonNamingPolicy namingPolicy, JsonSerializerOptions serializerOptions)
		{
			_converterOptions = converterOptions;
			_namingPolicy = namingPolicy;
			_nameCacheForWriting = new ConcurrentDictionary<ulong, JsonEncodedText>();
			if (namingPolicy != null)
			{
				_nameCacheForReading = new ConcurrentDictionary<string, T>();
			}
			string[] names = Enum.GetNames(Type);
			Array values = Enum.GetValues(Type);
			JavaScriptEncoder encoder = serializerOptions.Encoder;
			for (int i = 0; i < names.Length; i++)
			{
				T val = (T)values.GetValue(i);
				ulong key = ConvertToUInt64(val);
				string text = names[i];
				string text2 = FormatJsonName(text, namingPolicy);
				_nameCacheForWriting.TryAdd(key, JsonEncodedText.Encode(text2, encoder));
				_nameCacheForReading?.TryAdd(text2, val);
				if (MemoryExtensions.AsSpan(text).IndexOfAny(',', ' ') >= 0)
				{
					ThrowHelper.ThrowInvalidOperationException_InvalidEnumTypeWithSpecialChar(typeof(T), text);
				}
			}
		}

		public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			switch (reader.TokenType)
			{
			case JsonTokenType.String:
			{
				if ((_converterOptions & EnumConverterOptions.AllowStrings) == 0)
				{
					ThrowHelper.ThrowJsonException();
					return default(T);
				}
				string enumString = reader.GetString();
				if (TryParseEnumCore(enumString, options, out var value9))
				{
					return value9;
				}
				return ReadEnumUsingNamingPolicy(enumString);
			}
			case JsonTokenType.Number:
				if ((_converterOptions & EnumConverterOptions.AllowNumbers) != 0)
				{
					switch (s_enumTypeCode)
					{
					case TypeCode.Int32:
					{
						if (reader.TryGetInt32(out var value8))
						{
							return Unsafe.As<int, T>(ref value8);
						}
						break;
					}
					case TypeCode.UInt32:
					{
						if (reader.TryGetUInt32(out var value4))
						{
							return Unsafe.As<uint, T>(ref value4);
						}
						break;
					}
					case TypeCode.UInt64:
					{
						if (reader.TryGetUInt64(out var value6))
						{
							return Unsafe.As<ulong, T>(ref value6);
						}
						break;
					}
					case TypeCode.Int64:
					{
						if (reader.TryGetInt64(out var value2))
						{
							return Unsafe.As<long, T>(ref value2);
						}
						break;
					}
					case TypeCode.SByte:
					{
						if (reader.TryGetSByte(out var value7))
						{
							return Unsafe.As<sbyte, T>(ref value7);
						}
						break;
					}
					case TypeCode.Byte:
					{
						if (reader.TryGetByte(out var value5))
						{
							return Unsafe.As<byte, T>(ref value5);
						}
						break;
					}
					case TypeCode.Int16:
					{
						if (reader.TryGetInt16(out var value3))
						{
							return Unsafe.As<short, T>(ref value3);
						}
						break;
					}
					case TypeCode.UInt16:
					{
						if (reader.TryGetUInt16(out var value))
						{
							return Unsafe.As<ushort, T>(ref value);
						}
						break;
					}
					}
					ThrowHelper.ThrowJsonException();
					return default(T);
				}
				goto default;
			default:
				ThrowHelper.ThrowJsonException();
				return default(T);
			}
		}

		public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
		{
			if ((_converterOptions & EnumConverterOptions.AllowStrings) != 0)
			{
				ulong key = ConvertToUInt64(value);
				if (_nameCacheForWriting.TryGetValue(key, out var value2))
				{
					writer.WriteStringValue(value2);
					return;
				}
				string value3 = value.ToString();
				if (IsValidIdentifier(value3))
				{
					value3 = FormatJsonName(value3, _namingPolicy);
					if (_nameCacheForWriting.Count < 64)
					{
						value2 = JsonEncodedText.Encode(value3, options.Encoder);
						writer.WriteStringValue(value2);
						_nameCacheForWriting.TryAdd(key, value2);
					}
					else
					{
						writer.WriteStringValue(value3);
					}
					return;
				}
			}
			if ((_converterOptions & EnumConverterOptions.AllowNumbers) == 0)
			{
				ThrowHelper.ThrowJsonException();
			}
			switch (s_enumTypeCode)
			{
			case TypeCode.Int32:
				writer.WriteNumberValue(Unsafe.As<T, int>(ref value));
				break;
			case TypeCode.UInt32:
				writer.WriteNumberValue(Unsafe.As<T, uint>(ref value));
				break;
			case TypeCode.UInt64:
				writer.WriteNumberValue(Unsafe.As<T, ulong>(ref value));
				break;
			case TypeCode.Int64:
				writer.WriteNumberValue(Unsafe.As<T, long>(ref value));
				break;
			case TypeCode.Int16:
				writer.WriteNumberValue(Unsafe.As<T, short>(ref value));
				break;
			case TypeCode.UInt16:
				writer.WriteNumberValue(Unsafe.As<T, ushort>(ref value));
				break;
			case TypeCode.Byte:
				writer.WriteNumberValue(Unsafe.As<T, byte>(ref value));
				break;
			case TypeCode.SByte:
				writer.WriteNumberValue(Unsafe.As<T, sbyte>(ref value));
				break;
			default:
				ThrowHelper.ThrowJsonException();
				break;
			}
		}

		internal override T ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			if (!TryParseEnumCore(reader.GetString(), options, out var value))
			{
				ThrowHelper.ThrowJsonException();
			}
			return value;
		}

		internal unsafe override void WriteAsPropertyNameCore(Utf8JsonWriter writer, T value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			ulong key = ConvertToUInt64(value);
			if (options.DictionaryKeyPolicy == null && _nameCacheForWriting.TryGetValue(key, out var value2))
			{
				writer.WritePropertyName(value2);
				return;
			}
			string value3 = value.ToString();
			if (IsValidIdentifier(value3))
			{
				if (options.DictionaryKeyPolicy != null)
				{
					value3 = FormatJsonName(value3, options.DictionaryKeyPolicy);
					writer.WritePropertyName(value3);
					return;
				}
				value3 = FormatJsonName(value3, _namingPolicy);
				if (_nameCacheForWriting.Count < 64)
				{
					value2 = JsonEncodedText.Encode(value3, options.Encoder);
					writer.WritePropertyName(value2);
					_nameCacheForWriting.TryAdd(key, value2);
				}
				else
				{
					writer.WritePropertyName(value3);
				}
				return;
			}
			switch (s_enumTypeCode)
			{
			case TypeCode.Int32:
				writer.WritePropertyName(*(int*)(&value));
				break;
			case TypeCode.UInt32:
				writer.WritePropertyName(*(uint*)(&value));
				break;
			case TypeCode.UInt64:
				writer.WritePropertyName(*(ulong*)(&value));
				break;
			case TypeCode.Int64:
				writer.WritePropertyName(*(long*)(&value));
				break;
			case TypeCode.Int16:
				writer.WritePropertyName(*(short*)(&value));
				break;
			case TypeCode.UInt16:
				writer.WritePropertyName(*(ushort*)(&value));
				break;
			case TypeCode.Byte:
				writer.WritePropertyName(*(byte*)(&value));
				break;
			case TypeCode.SByte:
				writer.WritePropertyName(*(sbyte*)(&value));
				break;
			default:
				ThrowHelper.ThrowJsonException();
				break;
			}
		}

		private static bool TryParseEnumCore(string enumString, JsonSerializerOptions _, out T value)
		{
			T result2;
			bool result = Enum.TryParse<T>(enumString, out result2) || Enum.TryParse<T>(enumString, ignoreCase: true, out result2);
			value = result2;
			return result;
		}

		private T ReadEnumUsingNamingPolicy(string enumString)
		{
			if (_namingPolicy == null)
			{
				ThrowHelper.ThrowJsonException();
			}
			if (enumString == null)
			{
				ThrowHelper.ThrowJsonException();
			}
			bool flag;
			if (!(flag = _nameCacheForReading.TryGetValue(enumString, out var value)) && enumString.Contains(", "))
			{
				string[] array = SplitFlagsEnum(enumString);
				ulong num = 0uL;
				for (int i = 0; i < array.Length; i++)
				{
					flag = _nameCacheForReading.TryGetValue(array[i], out value);
					if (!flag)
					{
						break;
					}
					num |= ConvertToUInt64(value);
				}
				value = (T)Enum.ToObject(typeof(T), num);
				if (flag && _nameCacheForReading.Count < 64)
				{
					_nameCacheForReading[enumString] = value;
				}
			}
			if (!flag)
			{
				ThrowHelper.ThrowJsonException();
			}
			return value;
		}

		private static ulong ConvertToUInt64(object value)
		{
			return s_enumTypeCode switch
			{
				TypeCode.Int32 => (ulong)(int)value, 
				TypeCode.UInt32 => (uint)value, 
				TypeCode.UInt64 => (ulong)value, 
				TypeCode.Int64 => (ulong)(long)value, 
				TypeCode.SByte => (ulong)(sbyte)value, 
				TypeCode.Byte => (byte)value, 
				TypeCode.Int16 => (ulong)(short)value, 
				TypeCode.UInt16 => (ushort)value, 
				_ => throw new InvalidOperationException(), 
			};
		}

		private static bool IsValidIdentifier(string value)
		{
			if (value[0] >= 'A')
			{
				if (s_isSignedEnum)
				{
					return !value.StartsWith(NumberFormatInfo.CurrentInfo.NegativeSign);
				}
				return true;
			}
			return false;
		}

		private static string FormatJsonName(string value, JsonNamingPolicy namingPolicy)
		{
			if (namingPolicy == null)
			{
				return value;
			}
			string text;
			if (!value.Contains(", "))
			{
				text = namingPolicy.ConvertName(value);
				if (text == null)
				{
					ThrowHelper.ThrowInvalidOperationException_NamingPolicyReturnNull(namingPolicy);
				}
			}
			else
			{
				string[] array = SplitFlagsEnum(value);
				for (int i = 0; i < array.Length; i++)
				{
					string text2 = namingPolicy.ConvertName(array[i]);
					if (text2 == null)
					{
						ThrowHelper.ThrowInvalidOperationException_NamingPolicyReturnNull(namingPolicy);
					}
					array[i] = text2;
				}
				text = string.Join(", ", array);
			}
			return text;
		}

		private static string[] SplitFlagsEnum(string value)
		{
			return value.Split(new string[1] { ", " }, StringSplitOptions.None);
		}
	}
	[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
	internal sealed class EnumConverterFactory : JsonConverterFactory
	{
		public override bool CanConvert(Type type)
		{
			return type.IsEnum;
		}

		public override JsonConverter CreateConverter(Type type, JsonSerializerOptions options)
		{
			return Create(type, EnumConverterOptions.AllowNumbers, null, options);
		}

		internal static JsonConverter Create(Type enumType, EnumConverterOptions converterOptions, JsonNamingPolicy namingPolicy, JsonSerializerOptions options)
		{
			return (JsonConverter)Activator.CreateInstance(GetEnumConverterType(enumType), converterOptions, namingPolicy, options);
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern", Justification = "'EnumConverter<T> where T : struct' implies 'T : new()', so the trimmer is warning calling MakeGenericType here because enumType's constructors are not annotated. But EnumConverter doesn't call new T(), so this is safe.")]
		[return: DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)]
		private static Type GetEnumConverterType(Type enumType)
		{
			return typeof(EnumConverter<>).MakeGenericType(enumType);
		}
	}
	[Flags]
	internal enum EnumConverterOptions
	{
		AllowStrings = 1,
		AllowNumbers = 2
	}
	internal sealed class GuidConverter : JsonPrimitiveConverter<Guid>
	{
		public override Guid Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetGuid();
		}

		public override void Write(Utf8JsonWriter writer, Guid value, JsonSerializerOptions options)
		{
			writer.WriteStringValue(value);
		}

		internal override Guid ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetGuidNoValidation();
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, Guid value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value);
		}
	}
	internal sealed class Int16Converter : JsonPrimitiveConverter<short>
	{
		public Int16Converter()
		{
			base.IsInternalConverterForNumberType = true;
		}

		public override short Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetInt16();
		}

		public override void Write(Utf8JsonWriter writer, short value, JsonSerializerOptions options)
		{
			writer.WriteNumberValue((long)value);
		}

		internal override short ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetInt16WithQuotes();
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, short value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value);
		}

		internal override short ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != JsonNumberHandling.Strict)
			{
				return reader.GetInt16WithQuotes();
			}
			return reader.GetInt16();
		}

		internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, short value, JsonNumberHandling handling)
		{
			if ((JsonNumberHandling.WriteAsString & handling) != JsonNumberHandling.Strict)
			{
				writer.WriteNumberValueAsString(value);
			}
			else
			{
				writer.WriteNumberValue((long)value);
			}
		}
	}
	internal sealed class Int32Converter : JsonPrimitiveConverter<int>
	{
		public Int32Converter()
		{
			base.IsInternalConverterForNumberType = true;
		}

		public override int Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetInt32();
		}

		public override void Write(Utf8JsonWriter writer, int value, JsonSerializerOptions options)
		{
			writer.WriteNumberValue((long)value);
		}

		internal override int ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetInt32WithQuotes();
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, int value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value);
		}

		internal override int ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != JsonNumberHandling.Strict)
			{
				return reader.GetInt32WithQuotes();
			}
			return reader.GetInt32();
		}

		internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, int value, JsonNumberHandling handling)
		{
			if ((JsonNumberHandling.WriteAsString & handling) != JsonNumberHandling.Strict)
			{
				writer.WriteNumberValueAsString(value);
			}
			else
			{
				writer.WriteNumberValue((long)value);
			}
		}
	}
	internal sealed class Int64Converter : JsonPrimitiveConverter<long>
	{
		public Int64Converter()
		{
			base.IsInternalConverterForNumberType = true;
		}

		public override long Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetInt64();
		}

		public override void Write(Utf8JsonWriter writer, long value, JsonSerializerOptions options)
		{
			writer.WriteNumberValue(value);
		}

		internal override long ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetInt64WithQuotes();
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, long value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value);
		}

		internal override long ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != JsonNumberHandling.Strict)
			{
				return reader.GetInt64WithQuotes();
			}
			return reader.GetInt64();
		}

		internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, long value, JsonNumberHandling handling)
		{
			if ((JsonNumberHandling.WriteAsString & handling) != JsonNumberHandling.Strict)
			{
				writer.WriteNumberValueAsString(value);
			}
			else
			{
				writer.WriteNumberValue(value);
			}
		}
	}
	internal sealed class JsonDocumentConverter : JsonConverter<JsonDocument>
	{
		public override JsonDocument Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return JsonDocument.ParseValue(ref reader);
		}

		public override void Write(Utf8JsonWriter writer, JsonDocument value, JsonSerializerOptions options)
		{
			if (value == null)
			{
				writer.WriteNullValue();
			}
			else
			{
				value.WriteTo(writer);
			}
		}
	}
	internal sealed class JsonElementConverter : JsonConverter<JsonElement>
	{
		public override JsonElement Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return JsonElement.ParseValue(ref reader);
		}

		public override void Write(Utf8JsonWriter writer, JsonElement value, JsonSerializerOptions options)
		{
			value.WriteTo(writer);
		}
	}
	internal sealed class NullableConverter<T> : JsonConverter<T?> where T : struct
	{
		private readonly JsonConverter<T> _elementConverter;

		internal override Type ElementType => typeof(T);

		public override bool HandleNull => true;

		internal override bool CanPopulate => _elementConverter.CanPopulate;

		internal override bool ConstructorIsParameterized => _elementConverter.ConstructorIsParameterized;

		public NullableConverter(JsonConverter<T> elementConverter)
		{
			_elementConverter = elementConverter;
			base.IsInternalConverterForNumberType = elementConverter.IsInternalConverterForNumberType;
			base.ConverterStrategy = elementConverter.ConverterStrategy;
			base.ConstructorInfo = elementConverter.ConstructorInfo;
		}

		internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out T? value)
		{
			if (!state.IsContinuation && reader.TokenType == JsonTokenType.Null)
			{
				value = null;
				return true;
			}
			JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
			state.Current.JsonTypeInfo = state.Current.JsonTypeInfo.ElementTypeInfo;
			if (_elementConverter.OnTryRead(ref reader, typeof(T), options, ref state, out var value2))
			{
				value = value2;
				state.Current.JsonTypeInfo = jsonTypeInfo;
				return true;
			}
			state.Current.JsonTypeInfo = jsonTypeInfo;
			value = null;
			return false;
		}

		internal override bool OnTryWrite(Utf8JsonWriter writer, T? value, JsonSerializerOptions options, ref WriteStack state)
		{
			if (!value.HasValue)
			{
				writer.WriteNullValue();
				return true;
			}
			state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
			return _elementConverter.TryWrite(writer, value.Value, options, ref state);
		}

		public override T? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.Null)
			{
				return null;
			}
			return _elementConverter.Read(ref reader, typeof(T), options);
		}

		public override void Write(Utf8JsonWriter writer, T? value, JsonSerializerOptions options)
		{
			if (!value.HasValue)
			{
				writer.WriteNullValue();
			}
			else
			{
				_elementConverter.Write(writer, value.Value, options);
			}
		}

		internal override T? ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling numberHandling, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.Null)
			{
				return null;
			}
			return _elementConverter.ReadNumberWithCustomHandling(ref reader, numberHandling, options);
		}

		internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, T? value, JsonNumberHandling handling)
		{
			if (!value.HasValue)
			{
				writer.WriteNullValue();
			}
			else
			{
				_elementConverter.WriteNumberWithCustomHandling(writer, value.Value, handling);
			}
		}
	}
	[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
	internal sealed class NullableConverterFactory : JsonConverterFactory
	{
		public override bool CanConvert(Type typeToConvert)
		{
			return typeToConvert.IsNullableOfT();
		}

		public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
		{
			Type type = typeToConvert.GetGenericArguments()[0];
			JsonConverter converterInternal = options.GetConverterInternal(type);
			if (!converterInternal.Type.IsValueType && type.IsValueType)
			{
				return converterInternal;
			}
			return CreateValueConverter(type, converterInternal);
		}

		public static JsonConverter CreateValueConverter(Type valueTypeToConvert, JsonConverter valueConverter)
		{
			return (JsonConverter)Activator.CreateInstance(GetNullableConverterType(valueTypeToConvert), BindingFlags.Instance | BindingFlags.Public, null, new object[1] { valueConverter }, null);
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern", Justification = "'NullableConverter<T> where T : struct' implies 'T : new()', so the trimmer is warning calling MakeGenericType here because valueTypeToConvert's constructors are not annotated. But NullableConverter doesn't call new T(), so this is safe.")]
		[return: DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)]
		private static Type GetNullableConverterType(Type valueTypeToConvert)
		{
			return typeof(NullableConverter<>).MakeGenericType(valueTypeToConvert);
		}
	}
	internal sealed class SByteConverter : JsonPrimitiveConverter<sbyte>
	{
		public SByteConverter()
		{
			base.IsInternalConverterForNumberType = true;
		}

		public override sbyte Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetSByte();
		}

		public override void Write(Utf8JsonWriter writer, sbyte value, JsonSerializerOptions options)
		{
			writer.WriteNumberValue(value);
		}

		internal override sbyte ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetSByteWithQuotes();
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, sbyte value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value);
		}

		internal override sbyte ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != JsonNumberHandling.Strict)
			{
				return reader.GetSByteWithQuotes();
			}
			return reader.GetSByte();
		}

		internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, sbyte value, JsonNumberHandling handling)
		{
			if ((JsonNumberHandling.WriteAsString & handling) != JsonNumberHandling.Strict)
			{
				writer.WriteNumberValueAsString(value);
			}
			else
			{
				writer.WriteNumberValue(value);
			}
		}
	}
	internal sealed class SingleConverter : JsonPrimitiveConverter<float>
	{
		public SingleConverter()
		{
			base.IsInternalConverterForNumberType = true;
		}

		public override float Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetSingle();
		}

		public override void Write(Utf8JsonWriter writer, float value, JsonSerializerOptions options)
		{
			writer.WriteNumberValue(value);
		}

		internal override float ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetSingleWithQuotes();
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, float value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value);
		}

		internal override float ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.String)
			{
				if ((JsonNumberHandling.AllowReadingFromString & handling) != JsonNumberHandling.Strict)
				{
					return reader.GetSingleWithQuotes();
				}
				if ((JsonNumberHandling.AllowNamedFloatingPointLiterals & handling) != JsonNumberHandling.Strict)
				{
					return reader.GetSingleFloatingPointConstant();
				}
			}
			return reader.GetSingle();
		}

		internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, float value, JsonNumberHandling handling)
		{
			if ((JsonNumberHandling.WriteAsString & handling) != JsonNumberHandling.Strict)
			{
				writer.WriteNumberValueAsString(value);
			}
			else if ((JsonNumberHandling.AllowNamedFloatingPointLiterals & handling) != JsonNumberHandling.Strict)
			{
				writer.WriteFloatingPointConstant(value);
			}
			else
			{
				writer.WriteNumberValue(value);
			}
		}
	}
	internal sealed class StringConverter : JsonPrimitiveConverter<string>
	{
		public override string Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetString();
		}

		public override void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options)
		{
			if (value == null)
			{
				writer.WriteNullValue();
			}
			else
			{
				writer.WriteStringValue(MemoryExtensions.AsSpan(value));
			}
		}

		internal override string ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetString();
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, string value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			if (value == null)
			{
				ThrowHelper.ThrowArgumentNullException("value");
			}
			if (options.DictionaryKeyPolicy != null && !isWritingExtensionDataProperty)
			{
				value = options.DictionaryKeyPolicy.ConvertName(value);
				if (value == null)
				{
					ThrowHelper.ThrowInvalidOperationException_NamingPolicyReturnNull(options.DictionaryKeyPolicy);
				}
			}
			writer.WritePropertyName(value);
		}
	}
	internal sealed class TimeSpanConverter : JsonPrimitiveConverter<TimeSpan>
	{
		private const int MinimumTimeSpanFormatLength = 8;

		private const int MaximumTimeSpanFormatLength = 26;

		private const int MaximumEscapedTimeSpanFormatLength = 156;

		public override TimeSpan Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			if (reader.TokenType != JsonTokenType.String)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedString(reader.TokenType);
			}
			return ReadCore(ref reader);
		}

		internal override TimeSpan ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return ReadCore(ref reader);
		}

		private static TimeSpan ReadCore(ref Utf8JsonReader reader)
		{
			if (!JsonHelpers.IsInRangeInclusive(reader.ValueLength, 8, 156))
			{
				ThrowHelper.ThrowFormatException(DataType.TimeSpan);
			}
			ReadOnlySpan<byte> source;
			if (!reader.HasValueSequence && !reader.ValueIsEscaped)
			{
				source = reader.ValueSpan;
			}
			else
			{
				Span<byte> utf8Destination = stackalloc byte[156];
				source = utf8Destination[..reader.CopyString(utf8Destination)];
			}
			byte b = source[0];
			if (!JsonHelpers.IsDigit(b) && b != 45)
			{
				ThrowHelper.ThrowFormatException(DataType.TimeSpan);
			}
			if (!Utf8Parser.TryParse(source, out TimeSpan value, out int bytesConsumed, 'c') || source.Length != bytesConsumed)
			{
				ThrowHelper.ThrowFormatException(DataType.TimeSpan);
			}
			return value;
		}

		public override void Write(Utf8JsonWriter writer, TimeSpan value, JsonSerializerOptions options)
		{
			Span<byte> destination = stackalloc byte[26];
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten, 'c');
			writer.WriteStringValue(destination.Slice(0, bytesWritten));
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, TimeSpan value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			Span<byte> destination = stackalloc byte[26];
			int bytesWritten;
			bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten, 'c');
			writer.WritePropertyName(destination.Slice(0, bytesWritten));
		}
	}
	internal sealed class UInt16Converter : JsonPrimitiveConverter<ushort>
	{
		public UInt16Converter()
		{
			base.IsInternalConverterForNumberType = true;
		}

		public override ushort Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetUInt16();
		}

		public override void Write(Utf8JsonWriter writer, ushort value, JsonSerializerOptions options)
		{
			writer.WriteNumberValue((long)value);
		}

		internal override ushort ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetUInt16WithQuotes();
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, ushort value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value);
		}

		internal override ushort ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != JsonNumberHandling.Strict)
			{
				return reader.GetUInt16WithQuotes();
			}
			return reader.GetUInt16();
		}

		internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, ushort value, JsonNumberHandling handling)
		{
			if ((JsonNumberHandling.WriteAsString & handling) != JsonNumberHandling.Strict)
			{
				writer.WriteNumberValueAsString(value);
			}
			else
			{
				writer.WriteNumberValue((long)value);
			}
		}
	}
	internal sealed class UInt32Converter : JsonPrimitiveConverter<uint>
	{
		public UInt32Converter()
		{
			base.IsInternalConverterForNumberType = true;
		}

		public override uint Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetUInt32();
		}

		public override void Write(Utf8JsonWriter writer, uint value, JsonSerializerOptions options)
		{
			writer.WriteNumberValue((ulong)value);
		}

		internal override uint ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetUInt32WithQuotes();
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, uint value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value);
		}

		internal override uint ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != JsonNumberHandling.Strict)
			{
				return reader.GetUInt32WithQuotes();
			}
			return reader.GetUInt32();
		}

		internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, uint value, JsonNumberHandling handling)
		{
			if ((JsonNumberHandling.WriteAsString & handling) != JsonNumberHandling.Strict)
			{
				writer.WriteNumberValueAsString(value);
			}
			else
			{
				writer.WriteNumberValue((ulong)value);
			}
		}
	}
	internal sealed class UInt64Converter : JsonPrimitiveConverter<ulong>
	{
		public UInt64Converter()
		{
			base.IsInternalConverterForNumberType = true;
		}

		public override ulong Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetUInt64();
		}

		public override void Write(Utf8JsonWriter writer, ulong value, JsonSerializerOptions options)
		{
			writer.WriteNumberValue(value);
		}

		internal override ulong ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return reader.GetUInt64WithQuotes();
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, ulong value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			writer.WritePropertyName(value);
		}

		internal override ulong ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != JsonNumberHandling.Strict)
			{
				return reader.GetUInt64WithQuotes();
			}
			return reader.GetUInt64();
		}

		internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, ulong value, JsonNumberHandling handling)
		{
			if ((JsonNumberHandling.WriteAsString & handling) != JsonNumberHandling.Strict)
			{
				writer.WriteNumberValueAsString(value);
			}
			else
			{
				writer.WriteNumberValue(value);
			}
		}
	}
	internal sealed class UnsupportedTypeConverter<T> : JsonConverter<T>
	{
		private readonly string _errorMessage;

		public string ErrorMessage => _errorMessage ?? System.SR.Format(System.SR.SerializeTypeInstanceNotSupported, typeof(T).FullName);

		public UnsupportedTypeConverter(string errorMessage = null)
		{
			_errorMessage = errorMessage;
		}

		public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			throw new NotSupportedException(ErrorMessage);
		}

		public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
		{
			throw new NotSupportedException(ErrorMessage);
		}
	}
	[RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
	internal sealed class UnsupportedTypeConverterFactory : JsonConverterFactory
	{
		public override bool CanConvert(Type type)
		{
			if (!typeof(MemberInfo).IsAssignableFrom(type) && !(type == typeof(SerializationInfo)) && !(type == typeof(IntPtr)) && !(type == typeof(UIntPtr)))
			{
				return typeof(Delegate).IsAssignableFrom(type);
			}
			return true;
		}

		public override JsonConverter CreateConverter(Type type, JsonSerializerOptions options)
		{
			return CreateUnsupportedConverterForType(type);
		}

		internal static JsonConverter CreateUnsupportedConverterForType(Type type, string errorMessage = null)
		{
			return (JsonConverter)Activator.CreateInstance(typeof(UnsupportedTypeConverter<>).MakeGenericType(type), BindingFlags.Instance | BindingFlags.Public, null, new object[1] { errorMessage }, null);
		}
	}
	internal sealed class UriConverter : JsonPrimitiveConverter<Uri>
	{
		public override Uri Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			if (reader.TokenType != JsonTokenType.Null)
			{
				return ReadCore(ref reader);
			}
			return null;
		}

		public override void Write(Utf8JsonWriter writer, Uri value, JsonSerializerOptions options)
		{
			if ((object)value == null)
			{
				writer.WriteNullValue();
			}
			else
			{
				writer.WriteStringValue(value.OriginalString);
			}
		}

		internal override Uri ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return ReadCore(ref reader);
		}

		private static Uri ReadCore(ref Utf8JsonReader reader)
		{
			string uriString = reader.GetString();
			if (!Uri.TryCreate(uriString, UriKind.RelativeOrAbsolute, out var result))
			{
				ThrowHelper.ThrowJsonException();
			}
			return result;
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, Uri value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			if ((object)value == null)
			{
				ThrowHelper.ThrowArgumentNullException("value");
			}
			writer.WritePropertyName(value.OriginalString);
		}
	}
	internal sealed class VersionConverter : JsonPrimitiveConverter<Version>
	{
		public override Version Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			if (reader.TokenType == JsonTokenType.Null)
			{
				return null;
			}
			if (reader.TokenType != JsonTokenType.String)
			{
				ThrowHelper.ThrowInvalidOperationException_ExpectedString(reader.TokenType);
			}
			return ReadCore(ref reader);
		}

		private static Version ReadCore(ref Utf8JsonReader reader)
		{
			string text = reader.GetString();
			if (!string.IsNullOrEmpty(text) && (!char.IsDigit(text[0]) || !char.IsDigit(text[text.Length - 1])))
			{
				ThrowHelper.ThrowFormatException(DataType.Version);
			}
			if (Version.TryParse(text, out var result))
			{
				return result;
			}
			ThrowHelper.ThrowJsonException();
			return null;
		}

		public override void Write(Utf8JsonWriter writer, Version value, JsonSerializerOptions options)
		{
			if ((object)value == null)
			{
				writer.WriteNullValue();
			}
			else
			{
				writer.WriteStringValue(value.ToString());
			}
		}

		internal override Version ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			return ReadCore(ref reader);
		}

		internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, Version value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
		{
			if ((object)value == null)
			{
				ThrowHelper.ThrowArgumentNullException("value");
			}
			writer.WritePropertyName(value.ToString());
		}
	}
}
