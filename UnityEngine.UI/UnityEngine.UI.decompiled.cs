using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Rendering;
using UnityEngine.Serialization;
using UnityEngine.Sprites;
using UnityEngine.U2D;
using UnityEngine.UI;
using UnityEngine.UI.Collections;
using UnityEngine.UI.CoroutineTween;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyTitle("guisystem")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("guisystem")]
[assembly: AssemblyCopyright("Copyright Â© Microsoft 2013")]
[assembly: AssemblyTrademark("")]
[assembly: InternalsVisibleTo("UnityEngine.UI.Tests")]
[assembly: ComVisible(false)]
[assembly: Guid("d4f464c7-9b15-460d-b4bc-2cacd1c1df73")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: AssemblyVersion("1.0.0.0")]
[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		return new MonoScriptData
		{
			FilePathsData = new byte[5353]
			{
				0, 0, 0, 1, 0, 0, 0, 67, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 117, 110,
				105, 116, 121, 46, 117, 103, 117, 105, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 69, 118, 101,
				110, 116, 83, 121, 115, 116, 101, 109, 92, 69,
				118, 101, 110, 116, 68, 97, 116, 97, 92, 65,
				120, 105, 115, 69, 118, 101, 110, 116, 68, 97,
				116, 97, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 67, 92, 80, 97, 99, 107, 97, 103,
				101, 115, 92, 117, 110, 105, 116, 121, 46, 117,
				103, 117, 105, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 69, 118, 101, 110, 116, 83, 121, 115,
				116, 101, 109, 92, 69, 118, 101, 110, 116, 68,
				97, 116, 97, 92, 66, 97, 115, 101, 69, 118,
				101, 110, 116, 68, 97, 116, 97, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 70, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 117, 110,
				105, 116, 121, 46, 117, 103, 117, 105, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 69, 118, 101,
				110, 116, 83, 121, 115, 116, 101, 109, 92, 69,
				118, 101, 110, 116, 68, 97, 116, 97, 92, 80,
				111, 105, 110, 116, 101, 114, 69, 118, 101, 110,
				116, 68, 97, 116, 97, 46, 99, 115, 0, 0,
				0, 18, 0, 0, 0, 59, 92, 80, 97, 99,
				107, 97, 103, 101, 115, 92, 117, 110, 105, 116,
				121, 46, 117, 103, 117, 105, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 69, 118, 101, 110, 116,
				83, 121, 115, 116, 101, 109, 92, 69, 118, 101,
				110, 116, 73, 110, 116, 101, 114, 102, 97, 99,
				101, 115, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 55, 92, 80, 97, 99, 107, 97, 103,
				101, 115, 92, 117, 110, 105, 116, 121, 46, 117,
				103, 117, 105, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 69, 118, 101, 110, 116, 83, 121, 115,
				116, 101, 109, 92, 69, 118, 101, 110, 116, 83,
				121, 115, 116, 101, 109, 46, 99, 115, 0, 0,
				0, 3, 0, 0, 0, 56, 92, 80, 97, 99,
				107, 97, 103, 101, 115, 92, 117, 110, 105, 116,
				121, 46, 117, 103, 117, 105, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 69, 118, 101, 110, 116,
				83, 121, 115, 116, 101, 109, 92, 69, 118, 101,
				110, 116, 84, 114, 105, 103, 103, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 57,
				92, 80, 97, 99, 107, 97, 103, 101, 115, 92,
				117, 110, 105, 116, 121, 46, 117, 103, 117, 105,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 69,
				118, 101, 110, 116, 83, 121, 115, 116, 101, 109,
				92, 69, 120, 101, 99, 117, 116, 101, 69, 118,
				101, 110, 116, 115, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 66, 92, 80, 97, 99, 107,
				97, 103, 101, 115, 92, 117, 110, 105, 116, 121,
				46, 117, 103, 117, 105, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 69, 118, 101, 110, 116, 83,
				121, 115, 116, 101, 109, 92, 73, 110, 112, 117,
				116, 77, 111, 100, 117, 108, 101, 115, 92, 66,
				97, 115, 101, 73, 110, 112, 117, 116, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 72, 92,
				80, 97, 99, 107, 97, 103, 101, 115, 92, 117,
				110, 105, 116, 121, 46, 117, 103, 117, 105, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 69, 118,
				101, 110, 116, 83, 121, 115, 116, 101, 109, 92,
				73, 110, 112, 117, 116, 77, 111, 100, 117, 108,
				101, 115, 92, 66, 97, 115, 101, 73, 110, 112,
				117, 116, 77, 111, 100, 117, 108, 101, 46, 99,
				115, 0, 0, 0, 4, 0, 0, 0, 75, 92,
				80, 97, 99, 107, 97, 103, 101, 115, 92, 117,
				110, 105, 116, 121, 46, 117, 103, 117, 105, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 69, 118,
				101, 110, 116, 83, 121, 115, 116, 101, 109, 92,
				73, 110, 112, 117, 116, 77, 111, 100, 117, 108,
				101, 115, 92, 80, 111, 105, 110, 116, 101, 114,
				73, 110, 112, 117, 116, 77, 111, 100, 117, 108,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 78, 92, 80, 97, 99, 107, 97, 103, 101,
				115, 92, 117, 110, 105, 116, 121, 46, 117, 103,
				117, 105, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 69, 118, 101, 110, 116, 83, 121, 115, 116,
				101, 109, 92, 73, 110, 112, 117, 116, 77, 111,
				100, 117, 108, 101, 115, 92, 83, 116, 97, 110,
				100, 97, 108, 111, 110, 101, 73, 110, 112, 117,
				116, 77, 111, 100, 117, 108, 101, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 73, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 117, 110,
				105, 116, 121, 46, 117, 103, 117, 105, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 69, 118, 101,
				110, 116, 83, 121, 115, 116, 101, 109, 92, 73,
				110, 112, 117, 116, 77, 111, 100, 117, 108, 101,
				115, 92, 84, 111, 117, 99, 104, 73, 110, 112,
				117, 116, 77, 111, 100, 117, 108, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 60, 92,
				80, 97, 99, 107, 97, 103, 101, 115, 92, 117,
				110, 105, 116, 121, 46, 117, 103, 117, 105, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 69, 118,
				101, 110, 116, 83, 121, 115, 116, 101, 109, 92,
				82, 97, 121, 99, 97, 115, 116, 101, 114, 77,
				97, 110, 97, 103, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 68, 92, 80, 97,
				99, 107, 97, 103, 101, 115, 92, 117, 110, 105,
				116, 121, 46, 117, 103, 117, 105, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 69, 118, 101, 110,
				116, 83, 121, 115, 116, 101, 109, 92, 82, 97,
				121, 99, 97, 115, 116, 101, 114, 115, 92, 66,
				97, 115, 101, 82, 97, 121, 99, 97, 115, 116,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 73, 92, 80, 97, 99, 107, 97, 103,
				101, 115, 92, 117, 110, 105, 116, 121, 46, 117,
				103, 117, 105, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 69, 118, 101, 110, 116, 83, 121, 115,
				116, 101, 109, 92, 82, 97, 121, 99, 97, 115,
				116, 101, 114, 115, 92, 80, 104, 121, 115, 105,
				99, 115, 50, 68, 82, 97, 121, 99, 97, 115,
				116, 101, 114, 46, 99, 115, 0, 0, 0, 2,
				0, 0, 0, 71, 92, 80, 97, 99, 107, 97,
				103, 101, 115, 92, 117, 110, 105, 116, 121, 46,
				117, 103, 117, 105, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 69, 118, 101, 110, 116, 83, 121,
				115, 116, 101, 109, 92, 82, 97, 121, 99, 97,
				115, 116, 101, 114, 115, 92, 80, 104, 121, 115,
				105, 99, 115, 82, 97, 121, 99, 97, 115, 116,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 57, 92, 80, 97, 99, 107, 97, 103,
				101, 115, 92, 117, 110, 105, 116, 121, 46, 117,
				103, 117, 105, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 69, 118, 101, 110, 116, 83, 121, 115,
				116, 101, 109, 92, 82, 97, 121, 99, 97, 115,
				116, 82, 101, 115, 117, 108, 116, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 55, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 117, 110,
				105, 116, 121, 46, 117, 103, 117, 105, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 69, 118, 101,
				110, 116, 83, 121, 115, 116, 101, 109, 92, 85,
				73, 66, 101, 104, 97, 118, 105, 111, 117, 114,
				46, 99, 115, 0, 0, 0, 6, 0, 0, 0,
				59, 92, 80, 97, 99, 107, 97, 103, 101, 115,
				92, 117, 110, 105, 116, 121, 46, 117, 103, 117,
				105, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				85, 73, 92, 65, 110, 105, 109, 97, 116, 105,
				111, 110, 92, 67, 111, 114, 111, 117, 116, 105,
				110, 101, 84, 119, 101, 101, 110, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 57, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 117, 110,
				105, 116, 121, 46, 117, 103, 117, 105, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 85, 73, 92,
				67, 111, 114, 101, 92, 65, 110, 105, 109, 97,
				116, 105, 111, 110, 84, 114, 105, 103, 103, 101,
				114, 115, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 46, 92, 80, 97, 99, 107, 97, 103,
				101, 115, 92, 117, 110, 105, 116, 121, 46, 117,
				103, 117, 105, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 85, 73, 92, 67, 111, 114, 101, 92,
				66, 117, 116, 116, 111, 110, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 60, 92, 80, 97,
				99, 107, 97, 103, 101, 115, 92, 117, 110, 105,
				116, 121, 46, 117, 103, 117, 105, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 85, 73, 92, 67,
				111, 114, 101, 92, 67, 97, 110, 118, 97, 115,
				85, 112, 100, 97, 116, 101, 82, 101, 103, 105,
				115, 116, 114, 121, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 50, 92, 80, 97, 99, 107,
				97, 103, 101, 115, 92, 117, 110, 105, 116, 121,
				46, 117, 103, 117, 105, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 85, 73, 92, 67, 111, 114,
				101, 92, 67, 111, 108, 111, 114, 66, 108, 111,
				99, 107, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 63, 92, 80, 97, 99, 107, 97, 103,
				101, 115, 92, 117, 110, 105, 116, 121, 46, 117,
				103, 117, 105, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 85, 73, 92, 67, 111, 114, 101, 92,
				67, 117, 108, 108, 105, 110, 103, 92, 67, 108,
				105, 112, 112, 101, 114, 82, 101, 103, 105, 115,
				116, 114, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 56, 92, 80, 97, 99, 107, 97,
				103, 101, 115, 92, 117, 110, 105, 116, 121, 46,
				117, 103, 117, 105, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 85, 73, 92, 67, 111, 114, 101,
				92, 67, 117, 108, 108, 105, 110, 103, 92, 67,
				108, 105, 112, 112, 105, 110, 103, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 59, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 117, 110,
				105, 116, 121, 46, 117, 103, 117, 105, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 85, 73, 92,
				67, 111, 114, 101, 92, 67, 117, 108, 108, 105,
				110, 103, 92, 73, 67, 108, 105, 112, 82, 101,
				103, 105, 111, 110, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 63, 92, 80, 97, 99, 107,
				97, 103, 101, 115, 92, 117, 110, 105, 116, 121,
				46, 117, 103, 117, 105, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 85, 73, 92, 67, 111, 114,
				101, 92, 67, 117, 108, 108, 105, 110, 103, 92,
				77, 97, 115, 107, 85, 112, 100, 97, 116, 101,
				71, 114, 111, 117, 112, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 72, 92, 80, 97, 99,
				107, 97, 103, 101, 115, 92, 117, 110, 105, 116,
				121, 46, 117, 103, 117, 105, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 85, 73, 92, 67, 111,
				114, 101, 92, 67, 117, 108, 108, 105, 110, 103,
				92, 82, 101, 99, 116, 97, 110, 103, 117, 108,
				97, 114, 86, 101, 114, 116, 101, 120, 67, 108,
				105, 112, 112, 101, 114, 46, 99, 115, 0, 0,
				0, 4, 0, 0, 0, 55, 92, 80, 97, 99,
				107, 97, 103, 101, 115, 92, 117, 110, 105, 116,
				121, 46, 117, 103, 117, 105, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 85, 73, 92, 67, 111,
				114, 101, 92, 68, 101, 102, 97, 117, 108, 116,
				67, 111, 110, 116, 114, 111, 108, 115, 46, 99,
				115, 0, 0, 0, 5, 0, 0, 0, 48, 92,
				80, 97, 99, 107, 97, 103, 101, 115, 92, 117,
				110, 105, 116, 121, 46, 117, 103, 117, 105, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 85, 73,
				92, 67, 111, 114, 101, 92, 68, 114, 111, 112,
				100, 111, 119, 110, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 48, 92, 80, 97, 99, 107,
				97, 103, 101, 115, 92, 117, 110, 105, 116, 121,
				46, 117, 103, 117, 105, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 85, 73, 92, 67, 111, 114,
				101, 92, 70, 111, 110, 116, 68, 97, 116, 97,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				57, 92, 80, 97, 99, 107, 97, 103, 101, 115,
				92, 117, 110, 105, 116, 121, 46, 117, 103, 117,
				105, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				85, 73, 92, 67, 111, 114, 101, 92, 70, 111,
				110, 116, 85, 112, 100, 97, 116, 101, 84, 114,
				97, 99, 107, 101, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 47, 92, 80, 97, 99,
				107, 97, 103, 101, 115, 92, 117, 110, 105, 116,
				121, 46, 117, 103, 117, 105, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 85, 73, 92, 67, 111,
				114, 101, 92, 71, 114, 97, 112, 104, 105, 99,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				56, 92, 80, 97, 99, 107, 97, 103, 101, 115,
				92, 117, 110, 105, 116, 121, 46, 117, 103, 117,
				105, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				85, 73, 92, 67, 111, 114, 101, 92, 71, 114,
				97, 112, 104, 105, 99, 82, 97, 121, 99, 97,
				115, 116, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 55, 92, 80, 97, 99, 107,
				97, 103, 101, 115, 92, 117, 110, 105, 116, 121,
				46, 117, 103, 117, 105, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 85, 73, 92, 67, 111, 114,
				101, 92, 71, 114, 97, 112, 104, 105, 99, 82,
				101, 103, 105, 115, 116, 114, 121, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 63, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 117, 110,
				105, 116, 121, 46, 117, 103, 117, 105, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 85, 73, 92,
				67, 111, 114, 101, 92, 73, 71, 114, 97, 112,
				104, 105, 99, 69, 110, 97, 98, 108, 101, 100,
				68, 105, 115, 97, 98, 108, 101, 100, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 45, 92,
				80, 97, 99, 107, 97, 103, 101, 115, 92, 117,
				110, 105, 116, 121, 46, 117, 103, 117, 105, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 85, 73,
				92, 67, 111, 114, 101, 92, 73, 109, 97, 103,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 45, 92, 80, 97, 99, 107, 97, 103, 101,
				115, 92, 117, 110, 105, 116, 121, 46, 117, 103,
				117, 105, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 85, 73, 92, 67, 111, 114, 101, 92, 73,
				77, 97, 115, 107, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 49, 92, 80, 97, 99, 107,
				97, 103, 101, 115, 92, 117, 110, 105, 116, 121,
				46, 117, 103, 117, 105, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 85, 73, 92, 67, 111, 114,
				101, 92, 73, 77, 97, 115, 107, 97, 98, 108,
				101, 46, 99, 115, 0, 0, 0, 3, 0, 0,
				0, 50, 92, 80, 97, 99, 107, 97, 103, 101,
				115, 92, 117, 110, 105, 116, 121, 46, 117, 103,
				117, 105, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 85, 73, 92, 67, 111, 114, 101, 92, 73,
				110, 112, 117, 116, 70, 105, 101, 108, 100, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 64,
				92, 80, 97, 99, 107, 97, 103, 101, 115, 92,
				117, 110, 105, 116, 121, 46, 117, 103, 117, 105,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 85,
				73, 92, 67, 111, 114, 101, 92, 76, 97, 121,
				111, 117, 116, 92, 65, 115, 112, 101, 99, 116,
				82, 97, 116, 105, 111, 70, 105, 116, 116, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 59, 92, 80, 97, 99, 107, 97, 103, 101,
				115, 92, 117, 110, 105, 116, 121, 46, 117, 103,
				117, 105, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 85, 73, 92, 67, 111, 114, 101, 92, 76,
				97, 121, 111, 117, 116, 92, 67, 97, 110, 118,
				97, 115, 83, 99, 97, 108, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 64, 92,
				80, 97, 99, 107, 97, 103, 101, 115, 92, 117,
				110, 105, 116, 121, 46, 117, 103, 117, 105, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 85, 73,
				92, 67, 111, 114, 101, 92, 76, 97, 121, 111,
				117, 116, 92, 67, 111, 110, 116, 101, 110, 116,
				83, 105, 122, 101, 70, 105, 116, 116, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				62, 92, 80, 97, 99, 107, 97, 103, 101, 115,
				92, 117, 110, 105, 116, 121, 46, 117, 103, 117,
				105, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				85, 73, 92, 67, 111, 114, 101, 92, 76, 97,
				121, 111, 117, 116, 92, 71, 114, 105, 100, 76,
				97, 121, 111, 117, 116, 71, 114, 111, 117, 112,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				68, 92, 80, 97, 99, 107, 97, 103, 101, 115,
				92, 117, 110, 105, 116, 121, 46, 117, 103, 117,
				105, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				85, 73, 92, 67, 111, 114, 101, 92, 76, 97,
				121, 111, 117, 116, 92, 72, 111, 114, 105, 122,
				111, 110, 116, 97, 108, 76, 97, 121, 111, 117,
				116, 71, 114, 111, 117, 112, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 78, 92, 80, 97,
				99, 107, 97, 103, 101, 115, 92, 117, 110, 105,
				116, 121, 46, 117, 103, 117, 105, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 85, 73, 92, 67,
				111, 114, 101, 92, 76, 97, 121, 111, 117, 116,
				92, 72, 111, 114, 105, 122, 111, 110, 116, 97,
				108, 79, 114, 86, 101, 114, 116, 105, 99, 97,
				108, 76, 97, 121, 111, 117, 116, 71, 114, 111,
				117, 112, 46, 99, 115, 0, 0, 0, 5, 0,
				0, 0, 61, 92, 80, 97, 99, 107, 97, 103,
				101, 115, 92, 117, 110, 105, 116, 121, 46, 117,
				103, 117, 105, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 85, 73, 92, 67, 111, 114, 101, 92,
				76, 97, 121, 111, 117, 116, 92, 73, 76, 97,
				121, 111, 117, 116, 69, 108, 101, 109, 101, 110,
				116, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 60, 92, 80, 97, 99, 107, 97, 103, 101,
				115, 92, 117, 110, 105, 116, 121, 46, 117, 103,
				117, 105, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 85, 73, 92, 67, 111, 114, 101, 92, 76,
				97, 121, 111, 117, 116, 92, 76, 97, 121, 111,
				117, 116, 69, 108, 101, 109, 101, 110, 116, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 58,
				92, 80, 97, 99, 107, 97, 103, 101, 115, 92,
				117, 110, 105, 116, 121, 46, 117, 103, 117, 105,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 85,
				73, 92, 67, 111, 114, 101, 92, 76, 97, 121,
				111, 117, 116, 92, 76, 97, 121, 111, 117, 116,
				71, 114, 111, 117, 112, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 62, 92, 80, 97, 99,
				107, 97, 103, 101, 115, 92, 117, 110, 105, 116,
				121, 46, 117, 103, 117, 105, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 85, 73, 92, 67, 111,
				114, 101, 92, 76, 97, 121, 111, 117, 116, 92,
				76, 97, 121, 111, 117, 116, 82, 101, 98, 117,
				105, 108, 100, 101, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 60, 92, 80, 97, 99,
				107, 97, 103, 101, 115, 92, 117, 110, 105, 116,
				121, 46, 117, 103, 117, 105, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 85, 73, 92, 67, 111,
				114, 101, 92, 76, 97, 121, 111, 117, 116, 92,
				76, 97, 121, 111, 117, 116, 85, 116, 105, 108,
				105, 116, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 66, 92, 80, 97, 99, 107, 97,
				103, 101, 115, 92, 117, 110, 105, 116, 121, 46,
				117, 103, 117, 105, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 85, 73, 92, 67, 111, 114, 101,
				92, 76, 97, 121, 111, 117, 116, 92, 86, 101,
				114, 116, 105, 99, 97, 108, 76, 97, 121, 111,
				117, 116, 71, 114, 111, 117, 112, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 44, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 117, 110,
				105, 116, 121, 46, 117, 103, 117, 105, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 85, 73, 92,
				67, 111, 114, 101, 92, 77, 97, 115, 107, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 55,
				92, 80, 97, 99, 107, 97, 103, 101, 115, 92,
				117, 110, 105, 116, 121, 46, 117, 103, 117, 105,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 85,
				73, 92, 67, 111, 114, 101, 92, 77, 97, 115,
				107, 97, 98, 108, 101, 71, 114, 97, 112, 104,
				105, 99, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 53, 92, 80, 97, 99, 107, 97, 103,
				101, 115, 92, 117, 110, 105, 116, 121, 46, 117,
				103, 117, 105, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 85, 73, 92, 67, 111, 114, 101, 92,
				77, 97, 115, 107, 85, 116, 105, 108, 105, 116,
				105, 101, 115, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 75, 92, 80, 97, 99, 107, 97,
				103, 101, 115, 92, 117, 110, 105, 116, 121, 46,
				117, 103, 117, 105, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 85, 73, 92, 67, 111, 114, 101,
				92, 77, 97, 116, 101, 114, 105, 97, 108, 77,
				111, 100, 105, 102, 105, 101, 114, 115, 92, 73,
				77, 97, 116, 101, 114, 105, 97, 108, 77, 111,
				100, 105, 102, 105, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 44, 92, 80, 97,
				99, 107, 97, 103, 101, 115, 92, 117, 110, 105,
				116, 121, 46, 117, 103, 117, 105, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 85, 73, 92, 67,
				111, 114, 101, 92, 77, 105, 115, 99, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 50, 92,
				80, 97, 99, 107, 97, 103, 101, 115, 92, 117,
				110, 105, 116, 121, 46, 117, 103, 117, 105, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 85, 73,
				92, 67, 111, 114, 101, 92, 78, 97, 118, 105,
				103, 97, 116, 105, 111, 110, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 48, 92, 80, 97,
				99, 107, 97, 103, 101, 115, 92, 117, 110, 105,
				116, 121, 46, 117, 103, 117, 105, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 85, 73, 92, 67,
				111, 114, 101, 92, 82, 97, 119, 73, 109, 97,
				103, 101, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 50, 92, 80, 97, 99, 107, 97, 103,
				101, 115, 92, 117, 110, 105, 116, 121, 46, 117,
				103, 117, 105, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 85, 73, 92, 67, 111, 114, 101, 92,
				82, 101, 99, 116, 77, 97, 115, 107, 50, 68,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				49, 92, 80, 97, 99, 107, 97, 103, 101, 115,
				92, 117, 110, 105, 116, 121, 46, 117, 103, 117,
				105, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				85, 73, 92, 67, 111, 114, 101, 92, 83, 99,
				114, 111, 108, 108, 98, 97, 114, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 50, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 117, 110,
				105, 116, 121, 46, 117, 103, 117, 105, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 85, 73, 92,
				67, 111, 114, 101, 92, 83, 99, 114, 111, 108,
				108, 82, 101, 99, 116, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 50, 92, 80, 97, 99,
				107, 97, 103, 101, 115, 92, 117, 110, 105, 116,
				121, 46, 117, 103, 117, 105, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 85, 73, 92, 67, 111,
				114, 101, 92, 83, 101, 108, 101, 99, 116, 97,
				98, 108, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 58, 92, 80, 97, 99, 107, 97,
				103, 101, 115, 92, 117, 110, 105, 116, 121, 46,
				117, 103, 117, 105, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 85, 73, 92, 67, 111, 114, 101,
				92, 83, 101, 116, 80, 114, 111, 112, 101, 114,
				116, 121, 85, 116, 105, 108, 105, 116, 121, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 46,
				92, 80, 97, 99, 107, 97, 103, 101, 115, 92,
				117, 110, 105, 116, 121, 46, 117, 103, 117, 105,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 85,
				73, 92, 67, 111, 114, 101, 92, 83, 108, 105,
				100, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 73, 92, 80, 97, 99, 107, 97,
				103, 101, 115, 92, 117, 110, 105, 116, 121, 46,
				117, 103, 117, 105, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 85, 73, 92, 67, 111, 114, 101,
				92, 83, 112, 101, 99, 105, 97, 108, 105, 122,
				101, 100, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 115, 92, 73, 110, 100, 101, 120, 101,
				100, 83, 101, 116, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 51, 92, 80, 97, 99, 107,
				97, 103, 101, 115, 92, 117, 110, 105, 116, 121,
				46, 117, 103, 117, 105, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 85, 73, 92, 67, 111, 114,
				101, 92, 83, 112, 114, 105, 116, 101, 83, 116,
				97, 116, 101, 46, 99, 115, 0, 0, 0, 2,
				0, 0, 0, 55, 92, 80, 97, 99, 107, 97,
				103, 101, 115, 92, 117, 110, 105, 116, 121, 46,
				117, 103, 117, 105, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 85, 73, 92, 67, 111, 114, 101,
				92, 83, 116, 101, 110, 99, 105, 108, 77, 97,
				116, 101, 114, 105, 97, 108, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 44, 92, 80, 97,
				99, 107, 97, 103, 101, 115, 92, 117, 110, 105,
				116, 121, 46, 117, 103, 117, 105, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 85, 73, 92, 67,
				111, 114, 101, 92, 84, 101, 120, 116, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 46, 92,
				80, 97, 99, 107, 97, 103, 101, 115, 92, 117,
				110, 105, 116, 121, 46, 117, 103, 117, 105, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 85, 73,
				92, 67, 111, 114, 101, 92, 84, 111, 103, 103,
				108, 101, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 51, 92, 80, 97, 99, 107, 97, 103,
				101, 115, 92, 117, 110, 105, 116, 121, 46, 117,
				103, 117, 105, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 85, 73, 92, 67, 111, 114, 101, 92,
				84, 111, 103, 103, 108, 101, 71, 114, 111, 117,
				112, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 56, 92, 80, 97, 99, 107, 97, 103, 101,
				115, 92, 117, 110, 105, 116, 121, 46, 117, 103,
				117, 105, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 85, 73, 92, 67, 111, 114, 101, 92, 85,
				116, 105, 108, 105, 116, 121, 92, 76, 105, 115,
				116, 80, 111, 111, 108, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 58, 92, 80, 97, 99,
				107, 97, 103, 101, 115, 92, 117, 110, 105, 116,
				121, 46, 117, 103, 117, 105, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 85, 73, 92, 67, 111,
				114, 101, 92, 85, 116, 105, 108, 105, 116, 121,
				92, 79, 98, 106, 101, 99, 116, 80, 111, 111,
				108, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 70, 92, 80, 97, 99, 107, 97, 103, 101,
				115, 92, 117, 110, 105, 116, 121, 46, 117, 103,
				117, 105, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 85, 73, 92, 67, 111, 114, 101, 92, 85,
				116, 105, 108, 105, 116, 121, 92, 82, 101, 102,
				108, 101, 99, 116, 105, 111, 110, 77, 101, 116,
				104, 111, 100, 115, 67, 97, 99, 104, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 60,
				92, 80, 97, 99, 107, 97, 103, 101, 115, 92,
				117, 110, 105, 116, 121, 46, 117, 103, 117, 105,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 85,
				73, 92, 67, 111, 114, 101, 92, 85, 116, 105,
				108, 105, 116, 121, 92, 86, 101, 114, 116, 101,
				120, 72, 101, 108, 112, 101, 114, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 70, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 117, 110,
				105, 116, 121, 46, 117, 103, 117, 105, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 85, 73, 92,
				67, 111, 114, 101, 92, 86, 101, 114, 116, 101,
				120, 77, 111, 100, 105, 102, 105, 101, 114, 115,
				92, 66, 97, 115, 101, 77, 101, 115, 104, 69,
				102, 102, 101, 99, 116, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 69, 92, 80, 97, 99,
				107, 97, 103, 101, 115, 92, 117, 110, 105, 116,
				121, 46, 117, 103, 117, 105, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 85, 73, 92, 67, 111,
				114, 101, 92, 86, 101, 114, 116, 101, 120, 77,
				111, 100, 105, 102, 105, 101, 114, 115, 92, 73,
				77, 101, 115, 104, 77, 111, 100, 105, 102, 105,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 63, 92, 80, 97, 99, 107, 97, 103,
				101, 115, 92, 117, 110, 105, 116, 121, 46, 117,
				103, 117, 105, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 85, 73, 92, 67, 111, 114, 101, 92,
				86, 101, 114, 116, 101, 120, 77, 111, 100, 105,
				102, 105, 101, 114, 115, 92, 79, 117, 116, 108,
				105, 110, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 69, 92, 80, 97, 99, 107, 97,
				103, 101, 115, 92, 117, 110, 105, 116, 121, 46,
				117, 103, 117, 105, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 85, 73, 92, 67, 111, 114, 101,
				92, 86, 101, 114, 116, 101, 120, 77, 111, 100,
				105, 102, 105, 101, 114, 115, 92, 80, 111, 115,
				105, 116, 105, 111, 110, 65, 115, 85, 86, 49,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				62, 92, 80, 97, 99, 107, 97, 103, 101, 115,
				92, 117, 110, 105, 116, 121, 46, 117, 103, 117,
				105, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				85, 73, 92, 67, 111, 114, 101, 92, 86, 101,
				114, 116, 101, 120, 77, 111, 100, 105, 102, 105,
				101, 114, 115, 92, 83, 104, 97, 100, 111, 119,
				46, 99, 115
			},
			TypesData = new byte[5314]
			{
				0, 0, 0, 0, 38, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 69, 118, 101,
				110, 116, 83, 121, 115, 116, 101, 109, 115, 124,
				65, 120, 105, 115, 69, 118, 101, 110, 116, 68,
				97, 116, 97, 0, 0, 0, 0, 42, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				69, 118, 101, 110, 116, 83, 121, 115, 116, 101,
				109, 115, 124, 65, 98, 115, 116, 114, 97, 99,
				116, 69, 118, 101, 110, 116, 68, 97, 116, 97,
				0, 0, 0, 0, 38, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 69, 118, 101,
				110, 116, 83, 121, 115, 116, 101, 109, 115, 124,
				66, 97, 115, 101, 69, 118, 101, 110, 116, 68,
				97, 116, 97, 0, 0, 0, 0, 41, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				69, 118, 101, 110, 116, 83, 121, 115, 116, 101,
				109, 115, 124, 80, 111, 105, 110, 116, 101, 114,
				69, 118, 101, 110, 116, 68, 97, 116, 97, 0,
				0, 0, 0, 44, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 69, 118, 101, 110,
				116, 83, 121, 115, 116, 101, 109, 115, 124, 73,
				69, 118, 101, 110, 116, 83, 121, 115, 116, 101,
				109, 72, 97, 110, 100, 108, 101, 114, 0, 0,
				0, 0, 45, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 69, 118, 101, 110, 116,
				83, 121, 115, 116, 101, 109, 115, 124, 73, 80,
				111, 105, 110, 116, 101, 114, 69, 110, 116, 101,
				114, 72, 97, 110, 100, 108, 101, 114, 0, 0,
				0, 0, 44, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 69, 118, 101, 110, 116,
				83, 121, 115, 116, 101, 109, 115, 124, 73, 80,
				111, 105, 110, 116, 101, 114, 69, 120, 105, 116,
				72, 97, 110, 100, 108, 101, 114, 0, 0, 0,
				0, 44, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 69, 118, 101, 110, 116, 83,
				121, 115, 116, 101, 109, 115, 124, 73, 80, 111,
				105, 110, 116, 101, 114, 68, 111, 119, 110, 72,
				97, 110, 100, 108, 101, 114, 0, 0, 0, 0,
				42, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 69, 118, 101, 110, 116, 83, 121,
				115, 116, 101, 109, 115, 124, 73, 80, 111, 105,
				110, 116, 101, 114, 85, 112, 72, 97, 110, 100,
				108, 101, 114, 0, 0, 0, 0, 45, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				69, 118, 101, 110, 116, 83, 121, 115, 116, 101,
				109, 115, 124, 73, 80, 111, 105, 110, 116, 101,
				114, 67, 108, 105, 99, 107, 72, 97, 110, 100,
				108, 101, 114, 0, 0, 0, 0, 42, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				69, 118, 101, 110, 116, 83, 121, 115, 116, 101,
				109, 115, 124, 73, 66, 101, 103, 105, 110, 68,
				114, 97, 103, 72, 97, 110, 100, 108, 101, 114,
				0, 0, 0, 0, 56, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 69, 118, 101,
				110, 116, 83, 121, 115, 116, 101, 109, 115, 124,
				73, 73, 110, 105, 116, 105, 97, 108, 105, 122,
				101, 80, 111, 116, 101, 110, 116, 105, 97, 108,
				68, 114, 97, 103, 72, 97, 110, 100, 108, 101,
				114, 0, 0, 0, 0, 37, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 69, 118,
				101, 110, 116, 83, 121, 115, 116, 101, 109, 115,
				124, 73, 68, 114, 97, 103, 72, 97, 110, 100,
				108, 101, 114, 0, 0, 0, 0, 40, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				69, 118, 101, 110, 116, 83, 121, 115, 116, 101,
				109, 115, 124, 73, 69, 110, 100, 68, 114, 97,
				103, 72, 97, 110, 100, 108, 101, 114, 0, 0,
				0, 0, 37, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 69, 118, 101, 110, 116,
				83, 121, 115, 116, 101, 109, 115, 124, 73, 68,
				114, 111, 112, 72, 97, 110, 100, 108, 101, 114,
				0, 0, 0, 0, 39, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 69, 118, 101,
				110, 116, 83, 121, 115, 116, 101, 109, 115, 124,
				73, 83, 99, 114, 111, 108, 108, 72, 97, 110,
				100, 108, 101, 114, 0, 0, 0, 0, 47, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 69, 118, 101, 110, 116, 83, 121, 115, 116,
				101, 109, 115, 124, 73, 85, 112, 100, 97, 116,
				101, 83, 101, 108, 101, 99, 116, 101, 100, 72,
				97, 110, 100, 108, 101, 114, 0, 0, 0, 0,
				39, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 69, 118, 101, 110, 116, 83, 121,
				115, 116, 101, 109, 115, 124, 73, 83, 101, 108,
				101, 99, 116, 72, 97, 110, 100, 108, 101, 114,
				0, 0, 0, 0, 41, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 69, 118, 101,
				110, 116, 83, 121, 115, 116, 101, 109, 115, 124,
				73, 68, 101, 115, 101, 108, 101, 99, 116, 72,
				97, 110, 100, 108, 101, 114, 0, 0, 0, 0,
				37, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 69, 118, 101, 110, 116, 83, 121,
				115, 116, 101, 109, 115, 124, 73, 77, 111, 118,
				101, 72, 97, 110, 100, 108, 101, 114, 0, 0,
				0, 0, 39, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 69, 118, 101, 110, 116,
				83, 121, 115, 116, 101, 109, 115, 124, 73, 83,
				117, 98, 109, 105, 116, 72, 97, 110, 100, 108,
				101, 114, 0, 0, 0, 0, 39, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 69,
				118, 101, 110, 116, 83, 121, 115, 116, 101, 109,
				115, 124, 73, 67, 97, 110, 99, 101, 108, 72,
				97, 110, 100, 108, 101, 114, 0, 0, 0, 0,
				36, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 69, 118, 101, 110, 116, 83, 121,
				115, 116, 101, 109, 115, 124, 69, 118, 101, 110,
				116, 83, 121, 115, 116, 101, 109, 0, 0, 0,
				0, 37, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 69, 118, 101, 110, 116, 83,
				121, 115, 116, 101, 109, 115, 124, 69, 118, 101,
				110, 116, 84, 114, 105, 103, 103, 101, 114, 0,
				0, 0, 0, 50, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 69, 118, 101, 110,
				116, 83, 121, 115, 116, 101, 109, 115, 46, 69,
				118, 101, 110, 116, 84, 114, 105, 103, 103, 101,
				114, 124, 84, 114, 105, 103, 103, 101, 114, 69,
				118, 101, 110, 116, 0, 0, 0, 0, 43, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 69, 118, 101, 110, 116, 83, 121, 115, 116,
				101, 109, 115, 46, 69, 118, 101, 110, 116, 84,
				114, 105, 103, 103, 101, 114, 124, 69, 110, 116,
				114, 121, 0, 0, 0, 0, 38, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 69,
				118, 101, 110, 116, 83, 121, 115, 116, 101, 109,
				115, 124, 69, 120, 101, 99, 117, 116, 101, 69,
				118, 101, 110, 116, 115, 0, 0, 0, 0, 34,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 69, 118, 101, 110, 116, 83, 121, 115,
				116, 101, 109, 115, 124, 66, 97, 115, 101, 73,
				110, 112, 117, 116, 0, 0, 0, 0, 40, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 69, 118, 101, 110, 116, 83, 121, 115, 116,
				101, 109, 115, 124, 66, 97, 115, 101, 73, 110,
				112, 117, 116, 77, 111, 100, 117, 108, 101, 0,
				0, 0, 0, 43, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 69, 118, 101, 110,
				116, 83, 121, 115, 116, 101, 109, 115, 124, 80,
				111, 105, 110, 116, 101, 114, 73, 110, 112, 117,
				116, 77, 111, 100, 117, 108, 101, 0, 0, 0,
				0, 55, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 69, 118, 101, 110, 116, 83,
				121, 115, 116, 101, 109, 115, 46, 80, 111, 105,
				110, 116, 101, 114, 73, 110, 112, 117, 116, 77,
				111, 100, 117, 108, 101, 124, 66, 117, 116, 116,
				111, 110, 83, 116, 97, 116, 101, 0, 0, 0,
				0, 54, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 69, 118, 101, 110, 116, 83,
				121, 115, 116, 101, 109, 115, 46, 80, 111, 105,
				110, 116, 101, 114, 73, 110, 112, 117, 116, 77,
				111, 100, 117, 108, 101, 124, 77, 111, 117, 115,
				101, 83, 116, 97, 116, 101, 0, 0, 0, 0,
				64, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 69, 118, 101, 110, 116, 83, 121,
				115, 116, 101, 109, 115, 46, 80, 111, 105, 110,
				116, 101, 114, 73, 110, 112, 117, 116, 77, 111,
				100, 117, 108, 101, 124, 77, 111, 117, 115, 101,
				66, 117, 116, 116, 111, 110, 69, 118, 101, 110,
				116, 68, 97, 116, 97, 0, 0, 0, 0, 46,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 69, 118, 101, 110, 116, 83, 121, 115,
				116, 101, 109, 115, 124, 83, 116, 97, 110, 100,
				97, 108, 111, 110, 101, 73, 110, 112, 117, 116,
				77, 111, 100, 117, 108, 101, 0, 0, 0, 0,
				41, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 69, 118, 101, 110, 116, 83, 121,
				115, 116, 101, 109, 115, 124, 84, 111, 117, 99,
				104, 73, 110, 112, 117, 116, 77, 111, 100, 117,
				108, 101, 0, 0, 0, 0, 41, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 69,
				118, 101, 110, 116, 83, 121, 115, 116, 101, 109,
				115, 124, 82, 97, 121, 99, 97, 115, 116, 101,
				114, 77, 97, 110, 97, 103, 101, 114, 0, 0,
				0, 0, 38, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 69, 118, 101, 110, 116,
				83, 121, 115, 116, 101, 109, 115, 124, 66, 97,
				115, 101, 82, 97, 121, 99, 97, 115, 116, 101,
				114, 0, 0, 0, 0, 43, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 69, 118,
				101, 110, 116, 83, 121, 115, 116, 101, 109, 115,
				124, 80, 104, 121, 115, 105, 99, 115, 50, 68,
				82, 97, 121, 99, 97, 115, 116, 101, 114, 0,
				0, 0, 0, 41, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 69, 118, 101, 110,
				116, 83, 121, 115, 116, 101, 109, 115, 124, 80,
				104, 121, 115, 105, 99, 115, 82, 97, 121, 99,
				97, 115, 116, 101, 114, 0, 0, 0, 0, 60,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 69, 118, 101, 110, 116, 83, 121, 115,
				116, 101, 109, 115, 46, 80, 104, 121, 115, 105,
				99, 115, 82, 97, 121, 99, 97, 115, 116, 101,
				114, 124, 82, 97, 121, 99, 97, 115, 116, 72,
				105, 116, 67, 111, 109, 112, 97, 114, 101, 114,
				0, 0, 0, 0, 38, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 69, 118, 101,
				110, 116, 83, 121, 115, 116, 101, 109, 115, 124,
				82, 97, 121, 99, 97, 115, 116, 82, 101, 115,
				117, 108, 116, 0, 0, 0, 0, 36, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				69, 118, 101, 110, 116, 83, 121, 115, 116, 101,
				109, 115, 124, 85, 73, 66, 101, 104, 97, 118,
				105, 111, 117, 114, 0, 0, 0, 0, 41, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 85, 73, 46, 67, 111, 114, 111, 117, 116,
				105, 110, 101, 84, 119, 101, 101, 110, 124, 73,
				84, 119, 101, 101, 110, 86, 97, 108, 117, 101,
				0, 0, 0, 0, 40, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 85, 73, 46,
				67, 111, 114, 111, 117, 116, 105, 110, 101, 84,
				119, 101, 101, 110, 124, 67, 111, 108, 111, 114,
				84, 119, 101, 101, 110, 0, 0, 0, 0, 49,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 85, 73, 46, 67, 111, 114, 111, 117,
				116, 105, 110, 101, 84, 119, 101, 101, 110, 46,
				124, 67, 111, 108, 111, 114, 84, 119, 101, 101,
				110, 67, 97, 108, 108, 98, 97, 99, 107, 0,
				0, 0, 0, 40, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 85, 73, 46, 67,
				111, 114, 111, 117, 116, 105, 110, 101, 84, 119,
				101, 101, 110, 124, 70, 108, 111, 97, 116, 84,
				119, 101, 101, 110, 0, 0, 0, 0, 49, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 85, 73, 46, 67, 111, 114, 111, 117, 116,
				105, 110, 101, 84, 119, 101, 101, 110, 46, 124,
				70, 108, 111, 97, 116, 84, 119, 101, 101, 110,
				67, 97, 108, 108, 98, 97, 99, 107, 0, 0,
				0, 0, 41, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 85, 73, 46, 67, 111,
				114, 111, 117, 116, 105, 110, 101, 84, 119, 101,
				101, 110, 124, 84, 119, 101, 101, 110, 82, 117,
				110, 110, 101, 114, 0, 0, 0, 0, 32, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 85, 73, 124, 65, 110, 105, 109, 97, 116,
				105, 111, 110, 84, 114, 105, 103, 103, 101, 114,
				115, 0, 0, 0, 0, 21, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 85, 73,
				124, 66, 117, 116, 116, 111, 110, 0, 0, 0,
				0, 40, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 85, 73, 46, 66, 117, 116,
				116, 111, 110, 124, 66, 117, 116, 116, 111, 110,
				67, 108, 105, 99, 107, 101, 100, 69, 118, 101,
				110, 116, 0, 0, 0, 0, 29, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 85,
				73, 124, 73, 67, 97, 110, 118, 97, 115, 69,
				108, 101, 109, 101, 110, 116, 0, 0, 0, 0,
				35, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 85, 73, 124, 67, 97, 110, 118,
				97, 115, 85, 112, 100, 97, 116, 101, 82, 101,
				103, 105, 115, 116, 114, 121, 0, 0, 0, 0,
				25, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 85, 73, 124, 67, 111, 108, 111,
				114, 66, 108, 111, 99, 107, 0, 0, 0, 0,
				30, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 85, 73, 124, 67, 108, 105, 112,
				112, 101, 114, 82, 101, 103, 105, 115, 116, 114,
				121, 0, 0, 0, 0, 23, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 85, 73,
				124, 67, 108, 105, 112, 112, 105, 110, 103, 0,
				0, 0, 0, 23, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 85, 73, 124, 73,
				67, 108, 105, 112, 112, 101, 114, 0, 0, 0,
				0, 25, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 85, 73, 124, 73, 67, 108,
				105, 112, 112, 97, 98, 108, 101, 0, 0, 0,
				0, 35, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 85, 73, 124, 73, 77, 97,
				115, 107, 71, 114, 111, 117, 112, 86, 105, 115,
				105, 98, 105, 108, 105, 116, 121, 0, 0, 0,
				0, 30, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 85, 73, 124, 77, 97, 115,
				107, 85, 112, 100, 97, 116, 101, 71, 114, 111,
				117, 112, 0, 0, 0, 0, 39, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 85,
				73, 124, 82, 101, 99, 116, 97, 110, 103, 117,
				108, 97, 114, 86, 101, 114, 116, 101, 120, 67,
				108, 105, 112, 112, 101, 114, 0, 0, 0, 0,
				30, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 85, 73, 124, 68, 101, 102, 97,
				117, 108, 116, 67, 111, 110, 116, 114, 111, 108,
				115, 0, 0, 0, 0, 47, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 85, 73,
				46, 68, 101, 102, 97, 117, 108, 116, 67, 111,
				110, 116, 114, 111, 108, 115, 124, 73, 70, 97,
				99, 116, 111, 114, 121, 67, 111, 110, 116, 114,
				111, 108, 115, 0, 0, 0, 0, 52, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				85, 73, 46, 68, 101, 102, 97, 117, 108, 116,
				67, 111, 110, 116, 114, 111, 108, 115, 124, 68,
				101, 102, 97, 117, 108, 116, 82, 117, 110, 116,
				105, 109, 101, 70, 97, 99, 116, 111, 114, 121,
				0, 0, 0, 0, 40, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 85, 73, 46,
				68, 101, 102, 97, 117, 108, 116, 67, 111, 110,
				116, 114, 111, 108, 115, 124, 82, 101, 115, 111,
				117, 114, 99, 101, 115, 0, 0, 0, 0, 23,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 85, 73, 124, 68, 114, 111, 112, 100,
				111, 119, 110, 0, 0, 0, 0, 36, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				85, 73, 46, 68, 114, 111, 112, 100, 111, 119,
				110, 124, 68, 114, 111, 112, 100, 111, 119, 110,
				73, 116, 101, 109, 0, 0, 0, 0, 34, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 85, 73, 46, 68, 114, 111, 112, 100, 111,
				119, 110, 124, 79, 112, 116, 105, 111, 110, 68,
				97, 116, 97, 0, 0, 0, 0, 38, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				85, 73, 46, 68, 114, 111, 112, 100, 111, 119,
				110, 124, 79, 112, 116, 105, 111, 110, 68, 97,
				116, 97, 76, 105, 115, 116, 0, 0, 0, 0,
				37, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 85, 73, 46, 68, 114, 111, 112,
				100, 111, 119, 110, 124, 68, 114, 111, 112, 100,
				111, 119, 110, 69, 118, 101, 110, 116, 0, 0,
				0, 0, 23, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 85, 73, 124, 70, 111,
				110, 116, 68, 97, 116, 97, 0, 0, 0, 0,
				32, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 85, 73, 124, 70, 111, 110, 116,
				85, 112, 100, 97, 116, 101, 84, 114, 97, 99,
				107, 101, 114, 0, 0, 0, 0, 22, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				85, 73, 124, 71, 114, 97, 112, 104, 105, 99,
				0, 0, 0, 0, 31, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 85, 73, 124,
				71, 114, 97, 112, 104, 105, 99, 82, 97, 121,
				99, 97, 115, 116, 101, 114, 0, 0, 0, 0,
				30, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 85, 73, 124, 71, 114, 97, 112,
				104, 105, 99, 82, 101, 103, 105, 115, 116, 114,
				121, 0, 0, 0, 0, 38, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 85, 73,
				124, 73, 71, 114, 97, 112, 104, 105, 99, 69,
				110, 97, 98, 108, 101, 100, 68, 105, 115, 97,
				98, 108, 101, 100, 0, 0, 0, 0, 20, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 85, 73, 124, 73, 109, 97, 103, 101, 0,
				0, 0, 0, 20, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 85, 73, 124, 73,
				77, 97, 115, 107, 0, 0, 0, 0, 24, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 85, 73, 124, 73, 77, 97, 115, 107, 97,
				98, 108, 101, 0, 0, 0, 0, 25, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				85, 73, 124, 73, 110, 112, 117, 116, 70, 105,
				101, 108, 100, 0, 0, 0, 0, 37, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				85, 73, 46, 73, 110, 112, 117, 116, 70, 105,
				101, 108, 100, 124, 83, 117, 98, 109, 105, 116,
				69, 118, 101, 110, 116, 0, 0, 0, 0, 39,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 85, 73, 46, 73, 110, 112, 117, 116,
				70, 105, 101, 108, 100, 124, 79, 110, 67, 104,
				97, 110, 103, 101, 69, 118, 101, 110, 116, 0,
				0, 0, 0, 32, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 85, 73, 124, 65,
				115, 112, 101, 99, 116, 82, 97, 116, 105, 111,
				70, 105, 116, 116, 101, 114, 0, 0, 0, 0,
				27, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 85, 73, 124, 67, 97, 110, 118,
				97, 115, 83, 99, 97, 108, 101, 114, 0, 0,
				0, 0, 32, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 85, 73, 124, 67, 111,
				110, 116, 101, 110, 116, 83, 105, 122, 101, 70,
				105, 116, 116, 101, 114, 0, 0, 0, 0, 30,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 85, 73, 124, 71, 114, 105, 100, 76,
				97, 121, 111, 117, 116, 71, 114, 111, 117, 112,
				0, 0, 0, 0, 36, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 85, 73, 124,
				72, 111, 114, 105, 122, 111, 110, 116, 97, 108,
				76, 97, 121, 111, 117, 116, 71, 114, 111, 117,
				112, 0, 0, 0, 0, 46, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 85, 73,
				124, 72, 111, 114, 105, 122, 111, 110, 116, 97,
				108, 79, 114, 86, 101, 114, 116, 105, 99, 97,
				108, 76, 97, 121, 111, 117, 116, 71, 114, 111,
				117, 112, 0, 0, 0, 0, 29, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 85,
				73, 124, 73, 76, 97, 121, 111, 117, 116, 69,
				108, 101, 109, 101, 110, 116, 0, 0, 0, 0,
				32, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 85, 73, 124, 73, 76, 97, 121,
				111, 117, 116, 67, 111, 110, 116, 114, 111, 108,
				108, 101, 114, 0, 0, 0, 0, 27, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				85, 73, 124, 73, 76, 97, 121, 111, 117, 116,
				71, 114, 111, 117, 112, 0, 0, 0, 0, 36,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 85, 73, 124, 73, 76, 97, 121, 111,
				117, 116, 83, 101, 108, 102, 67, 111, 110, 116,
				114, 111, 108, 108, 101, 114, 0, 0, 0, 0,
				29, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 85, 73, 124, 73, 76, 97, 121,
				111, 117, 116, 73, 103, 110, 111, 114, 101, 114,
				0, 0, 0, 0, 28, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 85, 73, 124,
				76, 97, 121, 111, 117, 116, 69, 108, 101, 109,
				101, 110, 116, 0, 0, 0, 0, 26, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				85, 73, 124, 76, 97, 121, 111, 117, 116, 71,
				114, 111, 117, 112, 0, 0, 0, 0, 30, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 85, 73, 124, 76, 97, 121, 111, 117, 116,
				82, 101, 98, 117, 105, 108, 100, 101, 114, 0,
				0, 0, 0, 28, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 85, 73, 124, 76,
				97, 121, 111, 117, 116, 85, 116, 105, 108, 105,
				116, 121, 0, 0, 0, 0, 34, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 85,
				73, 124, 86, 101, 114, 116, 105, 99, 97, 108,
				76, 97, 121, 111, 117, 116, 71, 114, 111, 117,
				112, 0, 0, 0, 0, 19, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 85, 73,
				124, 77, 97, 115, 107, 0, 0, 0, 0, 30,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 85, 73, 124, 77, 97, 115, 107, 97,
				98, 108, 101, 71, 114, 97, 112, 104, 105, 99,
				0, 0, 0, 0, 52, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 85, 73, 46,
				77, 97, 115, 107, 97, 98, 108, 101, 71, 114,
				97, 112, 104, 105, 99, 124, 67, 117, 108, 108,
				83, 116, 97, 116, 101, 67, 104, 97, 110, 103,
				101, 100, 69, 118, 101, 110, 116, 0, 0, 0,
				0, 28, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 85, 73, 124, 77, 97, 115,
				107, 85, 116, 105, 108, 105, 116, 105, 101, 115,
				0, 0, 0, 0, 32, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 85, 73, 124,
				73, 77, 97, 116, 101, 114, 105, 97, 108, 77,
				111, 100, 105, 102, 105, 101, 114, 0, 0, 0,
				0, 19, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 85, 73, 124, 77, 105, 115,
				99, 0, 0, 0, 0, 25, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 85, 73,
				124, 78, 97, 118, 105, 103, 97, 116, 105, 111,
				110, 0, 0, 0, 0, 23, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 85, 73,
				124, 82, 97, 119, 73, 109, 97, 103, 101, 0,
				0, 0, 0, 25, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 85, 73, 124, 82,
				101, 99, 116, 77, 97, 115, 107, 50, 68, 0,
				0, 0, 0, 24, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 85, 73, 124, 83,
				99, 114, 111, 108, 108, 98, 97, 114, 0, 0,
				0, 0, 36, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 85, 73, 46, 83, 99,
				114, 111, 108, 108, 98, 97, 114, 124, 83, 99,
				114, 111, 108, 108, 69, 118, 101, 110, 116, 0,
				0, 0, 0, 25, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 85, 73, 124, 83,
				99, 114, 111, 108, 108, 82, 101, 99, 116, 0,
				0, 0, 0, 41, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 85, 73, 46, 83,
				99, 114, 111, 108, 108, 82, 101, 99, 116, 124,
				83, 99, 114, 111, 108, 108, 82, 101, 99, 116,
				69, 118, 101, 110, 116, 0, 0, 0, 0, 25,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 85, 73, 124, 83, 101, 108, 101, 99,
				116, 97, 98, 108, 101, 0, 0, 0, 0, 33,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 85, 73, 124, 83, 101, 116, 80, 114,
				111, 112, 101, 114, 116, 121, 85, 116, 105, 108,
				105, 116, 121, 0, 0, 0, 0, 21, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				85, 73, 124, 83, 108, 105, 100, 101, 114, 0,
				0, 0, 0, 33, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 85, 73, 46, 83,
				108, 105, 100, 101, 114, 124, 83, 108, 105, 100,
				101, 114, 69, 118, 101, 110, 116, 0, 0, 0,
				0, 37, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 85, 73, 46, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 115, 124, 73,
				110, 100, 101, 120, 101, 100, 83, 101, 116, 0,
				0, 0, 0, 26, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 85, 73, 124, 83,
				112, 114, 105, 116, 101, 83, 116, 97, 116, 101,
				0, 0, 0, 0, 30, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 85, 73, 124,
				83, 116, 101, 110, 99, 105, 108, 77, 97, 116,
				101, 114, 105, 97, 108, 0, 0, 0, 0, 39,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 85, 73, 46, 83, 116, 101, 110, 99,
				105, 108, 77, 97, 116, 101, 114, 105, 97, 108,
				124, 77, 97, 116, 69, 110, 116, 114, 121, 0,
				0, 0, 0, 19, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 85, 73, 124, 84,
				101, 120, 116, 0, 0, 0, 0, 21, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				85, 73, 124, 84, 111, 103, 103, 108, 101, 0,
				0, 0, 0, 33, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 85, 73, 46, 84,
				111, 103, 103, 108, 101, 124, 84, 111, 103, 103,
				108, 101, 69, 118, 101, 110, 116, 0, 0, 0,
				0, 26, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 85, 73, 124, 84, 111, 103,
				103, 108, 101, 71, 114, 111, 117, 112, 0, 0,
				0, 0, 23, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 85, 73, 124, 76, 105,
				115, 116, 80, 111, 111, 108, 0, 0, 0, 0,
				25, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 85, 73, 124, 79, 98, 106, 101,
				99, 116, 80, 111, 111, 108, 0, 0, 0, 0,
				37, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 85, 73, 124, 82, 101, 102, 108,
				101, 99, 116, 105, 111, 110, 77, 101, 116, 104,
				111, 100, 115, 67, 97, 99, 104, 101, 0, 0,
				0, 0, 27, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 85, 73, 124, 86, 101,
				114, 116, 101, 120, 72, 101, 108, 112, 101, 114,
				0, 0, 0, 0, 31, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 85, 73, 124,
				66, 97, 115, 101, 86, 101, 114, 116, 101, 120,
				69, 102, 102, 101, 99, 116, 0, 0, 0, 0,
				29, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 85, 73, 124, 66, 97, 115, 101,
				77, 101, 115, 104, 69, 102, 102, 101, 99, 116,
				0, 0, 0, 0, 30, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 85, 73, 124,
				73, 86, 101, 114, 116, 101, 120, 77, 111, 100,
				105, 102, 105, 101, 114, 0, 0, 0, 0, 28,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 85, 73, 124, 73, 77, 101, 115, 104,
				77, 111, 100, 105, 102, 105, 101, 114, 0, 0,
				0, 0, 22, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 85, 73, 124, 79, 117,
				116, 108, 105, 110, 101, 0, 0, 0, 0, 28,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 85, 73, 124, 80, 111, 115, 105, 116,
				105, 111, 110, 65, 115, 85, 86, 49, 0, 0,
				0, 0, 21, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 85, 73, 124, 83, 104,
				97, 100, 111, 119
			},
			TotalFiles = 80,
			TotalTypes = 134,
			IsEditorOnly = false
		};
	}
}
namespace UnityEngine.UI
{
	[Serializable]
	public class AnimationTriggers
	{
		private const string kDefaultNormalAnimName = "Normal";

		private const string kDefaultHighlightedAnimName = "Highlighted";

		private const string kDefaultPressedAnimName = "Pressed";

		private const string kDefaultSelectedAnimName = "Selected";

		private const string kDefaultDisabledAnimName = "Disabled";

		[FormerlySerializedAs("normalTrigger")]
		[SerializeField]
		private string m_NormalTrigger = "Normal";

		[FormerlySerializedAs("highlightedTrigger")]
		[SerializeField]
		private string m_HighlightedTrigger = "Highlighted";

		[FormerlySerializedAs("pressedTrigger")]
		[SerializeField]
		private string m_PressedTrigger = "Pressed";

		[FormerlySerializedAs("m_HighlightedTrigger")]
		[SerializeField]
		private string m_SelectedTrigger = "Selected";

		[FormerlySerializedAs("disabledTrigger")]
		[SerializeField]
		private string m_DisabledTrigger = "Disabled";

		public string normalTrigger
		{
			get
			{
				return m_NormalTrigger;
			}
			set
			{
				m_NormalTrigger = value;
			}
		}

		public string highlightedTrigger
		{
			get
			{
				return m_HighlightedTrigger;
			}
			set
			{
				m_HighlightedTrigger = value;
			}
		}

		public string pressedTrigger
		{
			get
			{
				return m_PressedTrigger;
			}
			set
			{
				m_PressedTrigger = value;
			}
		}

		public string selectedTrigger
		{
			get
			{
				return m_SelectedTrigger;
			}
			set
			{
				m_SelectedTrigger = value;
			}
		}

		public string disabledTrigger
		{
			get
			{
				return m_DisabledTrigger;
			}
			set
			{
				m_DisabledTrigger = value;
			}
		}
	}
	[AddComponentMenu("", 30)]
	public class Button : Selectable, IPointerClickHandler, IEventSystemHandler, ISubmitHandler
	{
		[Serializable]
		public class ButtonClickedEvent : UnityEvent
		{
		}

		[FormerlySerializedAs("onClick")]
		[SerializeField]
		private ButtonClickedEvent m_OnClick = new ButtonClickedEvent();

		public ButtonClickedEvent onClick
		{
			get
			{
				return m_OnClick;
			}
			set
			{
				m_OnClick = value;
			}
		}

		protected Button()
		{
		}

		private void Press()
		{
			if (IsActive() && IsInteractable())
			{
				UISystemProfilerApi.AddMarker("Button.onClick", this);
				m_OnClick.Invoke();
			}
		}

		public virtual void OnPointerClick(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left)
			{
				Press();
			}
		}

		public virtual void OnSubmit(BaseEventData eventData)
		{
			Press();
			if (IsActive() && IsInteractable())
			{
				DoStateTransition(SelectionState.Pressed, instant: false);
				StartCoroutine(OnFinishSubmit());
			}
		}

		private IEnumerator OnFinishSubmit()
		{
			float fadeTime = base.colors.fadeDuration;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime += Time.unscaledDeltaTime;
				yield return null;
			}
			DoStateTransition(base.currentSelectionState, instant: false);
		}
	}
	public enum CanvasUpdate
	{
		Prelayout,
		Layout,
		PostLayout,
		PreRender,
		LatePreRender,
		MaxUpdateValue
	}
	public interface ICanvasElement
	{
		Transform transform { get; }

		void Rebuild(CanvasUpdate executing);

		void LayoutComplete();

		void GraphicUpdateComplete();

		bool IsDestroyed();
	}
	public class CanvasUpdateRegistry
	{
		private static CanvasUpdateRegistry s_Instance;

		private bool m_PerformingLayoutUpdate;

		private bool m_PerformingGraphicUpdate;

		private readonly IndexedSet<ICanvasElement> m_LayoutRebuildQueue = new IndexedSet<ICanvasElement>();

		private readonly IndexedSet<ICanvasElement> m_GraphicRebuildQueue = new IndexedSet<ICanvasElement>();

		private static readonly Comparison<ICanvasElement> s_SortLayoutFunction = SortLayoutList;

		public static CanvasUpdateRegistry instance
		{
			get
			{
				if (s_Instance == null)
				{
					s_Instance = new CanvasUpdateRegistry();
				}
				return s_Instance;
			}
		}

		protected CanvasUpdateRegistry()
		{
			Canvas.willRenderCanvases += PerformUpdate;
		}

		private bool ObjectValidForUpdate(ICanvasElement element)
		{
			bool result = element != null;
			if (element is Object)
			{
				result = element as Object != null;
			}
			return result;
		}

		private void CleanInvalidItems()
		{
			for (int num = m_LayoutRebuildQueue.Count - 1; num >= 0; num--)
			{
				ICanvasElement canvasElement = m_LayoutRebuildQueue[num];
				if (canvasElement == null)
				{
					m_LayoutRebuildQueue.RemoveAt(num);
				}
				else if (canvasElement.IsDestroyed())
				{
					m_LayoutRebuildQueue.RemoveAt(num);
					canvasElement.LayoutComplete();
				}
			}
			for (int num2 = m_GraphicRebuildQueue.Count - 1; num2 >= 0; num2--)
			{
				ICanvasElement canvasElement2 = m_GraphicRebuildQueue[num2];
				if (canvasElement2 == null)
				{
					m_GraphicRebuildQueue.RemoveAt(num2);
				}
				else if (canvasElement2.IsDestroyed())
				{
					m_GraphicRebuildQueue.RemoveAt(num2);
					canvasElement2.GraphicUpdateComplete();
				}
			}
		}

		private void PerformUpdate()
		{
			UISystemProfilerApi.BeginSample(UISystemProfilerApi.SampleType.Layout);
			CleanInvalidItems();
			m_PerformingLayoutUpdate = true;
			m_LayoutRebuildQueue.Sort(s_SortLayoutFunction);
			for (int i = 0; i <= 2; i++)
			{
				for (int j = 0; j < m_LayoutRebuildQueue.Count; j++)
				{
					ICanvasElement canvasElement = instance.m_LayoutRebuildQueue[j];
					try
					{
						if (ObjectValidForUpdate(canvasElement))
						{
							canvasElement.Rebuild((CanvasUpdate)i);
						}
					}
					catch (Exception exception)
					{
						Debug.LogException(exception, canvasElement.transform);
					}
				}
			}
			for (int k = 0; k < m_LayoutRebuildQueue.Count; k++)
			{
				m_LayoutRebuildQueue[k].LayoutComplete();
			}
			instance.m_LayoutRebuildQueue.Clear();
			m_PerformingLayoutUpdate = false;
			ClipperRegistry.instance.Cull();
			m_PerformingGraphicUpdate = true;
			for (int l = 3; l < 5; l++)
			{
				for (int m = 0; m < instance.m_GraphicRebuildQueue.Count; m++)
				{
					try
					{
						ICanvasElement canvasElement2 = instance.m_GraphicRebuildQueue[m];
						if (ObjectValidForUpdate(canvasElement2))
						{
							canvasElement2.Rebuild((CanvasUpdate)l);
						}
					}
					catch (Exception exception2)
					{
						Debug.LogException(exception2, instance.m_GraphicRebuildQueue[m].transform);
					}
				}
			}
			for (int n = 0; n < m_GraphicRebuildQueue.Count; n++)
			{
				m_GraphicRebuildQueue[n].GraphicUpdateComplete();
			}
			instance.m_GraphicRebuildQueue.Clear();
			m_PerformingGraphicUpdate = false;
			UISystemProfilerApi.EndSample(UISystemProfilerApi.SampleType.Layout);
		}

		private static int ParentCount(Transform child)
		{
			if (child == null)
			{
				return 0;
			}
			Transform parent = child.parent;
			int num = 0;
			while (parent != null)
			{
				num++;
				parent = parent.parent;
			}
			return num;
		}

		private static int SortLayoutList(ICanvasElement x, ICanvasElement y)
		{
			Transform transform = x.transform;
			Transform transform2 = y.transform;
			return ParentCount(transform) - ParentCount(transform2);
		}

		public static void RegisterCanvasElementForLayoutRebuild(ICanvasElement element)
		{
			instance.InternalRegisterCanvasElementForLayoutRebuild(element);
		}

		public static bool TryRegisterCanvasElementForLayoutRebuild(ICanvasElement element)
		{
			return instance.InternalRegisterCanvasElementForLayoutRebuild(element);
		}

		private bool InternalRegisterCanvasElementForLayoutRebuild(ICanvasElement element)
		{
			if (m_LayoutRebuildQueue.Contains(element))
			{
				return false;
			}
			return m_LayoutRebuildQueue.AddUnique(element);
		}

		public static void RegisterCanvasElementForGraphicRebuild(ICanvasElement element)
		{
			instance.InternalRegisterCanvasElementForGraphicRebuild(element);
		}

		public static bool TryRegisterCanvasElementForGraphicRebuild(ICanvasElement element)
		{
			return instance.InternalRegisterCanvasElementForGraphicRebuild(element);
		}

		private bool InternalRegisterCanvasElementForGraphicRebuild(ICanvasElement element)
		{
			if (m_PerformingGraphicUpdate)
			{
				Debug.LogError($"Trying to add {element} for graphic rebuild while we are already inside a graphic rebuild loop. This is not supported.");
				return false;
			}
			return m_GraphicRebuildQueue.AddUnique(element);
		}

		public static void UnRegisterCanvasElementForRebuild(ICanvasElement element)
		{
			instance.InternalUnRegisterCanvasElementForLayoutRebuild(element);
			instance.InternalUnRegisterCanvasElementForGraphicRebuild(element);
		}

		private void InternalUnRegisterCanvasElementForLayoutRebuild(ICanvasElement element)
		{
			if (m_PerformingLayoutUpdate)
			{
				Debug.LogError($"Trying to remove {element} from rebuild list while we are already inside a rebuild loop. This is not supported.");
				return;
			}
			element.LayoutComplete();
			instance.m_LayoutRebuildQueue.Remove(element);
		}

		private void InternalUnRegisterCanvasElementForGraphicRebuild(ICanvasElement element)
		{
			if (m_PerformingGraphicUpdate)
			{
				Debug.LogError($"Trying to remove {element} from rebuild list while we are already inside a rebuild loop. This is not supported.");
				return;
			}
			element.GraphicUpdateComplete();
			instance.m_GraphicRebuildQueue.Remove(element);
		}

		public static bool IsRebuildingLayout()
		{
			return instance.m_PerformingLayoutUpdate;
		}

		public static bool IsRebuildingGraphics()
		{
			return instance.m_PerformingGraphicUpdate;
		}
	}
	[Serializable]
	public struct ColorBlock : IEquatable<ColorBlock>
	{
		[FormerlySerializedAs("normalColor")]
		[SerializeField]
		private Color m_NormalColor;

		[FormerlySerializedAs("highlightedColor")]
		[SerializeField]
		private Color m_HighlightedColor;

		[FormerlySerializedAs("pressedColor")]
		[SerializeField]
		private Color m_PressedColor;

		[FormerlySerializedAs("m_HighlightedColor")]
		[SerializeField]
		private Color m_SelectedColor;

		[FormerlySerializedAs("disabledColor")]
		[SerializeField]
		private Color m_DisabledColor;

		[Range(1f, 5f)]
		[SerializeField]
		private float m_ColorMultiplier;

		[FormerlySerializedAs("fadeDuration")]
		[SerializeField]
		private float m_FadeDuration;

		public Color normalColor
		{
			get
			{
				return m_NormalColor;
			}
			set
			{
				m_NormalColor = value;
			}
		}

		public Color highlightedColor
		{
			get
			{
				return m_HighlightedColor;
			}
			set
			{
				m_HighlightedColor = value;
			}
		}

		public Color pressedColor
		{
			get
			{
				return m_PressedColor;
			}
			set
			{
				m_PressedColor = value;
			}
		}

		public Color selectedColor
		{
			get
			{
				return m_SelectedColor;
			}
			set
			{
				m_SelectedColor = value;
			}
		}

		public Color disabledColor
		{
			get
			{
				return m_DisabledColor;
			}
			set
			{
				m_DisabledColor = value;
			}
		}

		public float colorMultiplier
		{
			get
			{
				return m_ColorMultiplier;
			}
			set
			{
				m_ColorMultiplier = value;
			}
		}

		public float fadeDuration
		{
			get
			{
				return m_FadeDuration;
			}
			set
			{
				m_FadeDuration = value;
			}
		}

		public static ColorBlock defaultColorBlock => new ColorBlock
		{
			m_NormalColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue),
			m_HighlightedColor = new Color32(245, 245, 245, byte.MaxValue),
			m_PressedColor = new Color32(200, 200, 200, byte.MaxValue),
			m_SelectedColor = new Color32(245, 245, 245, byte.MaxValue),
			m_DisabledColor = new Color32(200, 200, 200, 128),
			colorMultiplier = 1f,
			fadeDuration = 0.1f
		};

		public override bool Equals(object obj)
		{
			if (!(obj is ColorBlock))
			{
				return false;
			}
			return Equals((ColorBlock)obj);
		}

		public bool Equals(ColorBlock other)
		{
			if (normalColor == other.normalColor && highlightedColor == other.highlightedColor && pressedColor == other.pressedColor && selectedColor == other.selectedColor && disabledColor == other.disabledColor && colorMultiplier == other.colorMultiplier)
			{
				return fadeDuration == other.fadeDuration;
			}
			return false;
		}

		public static bool operator ==(ColorBlock point1, ColorBlock point2)
		{
			return point1.Equals(point2);
		}

		public static bool operator !=(ColorBlock point1, ColorBlock point2)
		{
			return !point1.Equals(point2);
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}
	}
	public class ClipperRegistry
	{
		private static ClipperRegistry s_Instance;

		private readonly IndexedSet<IClipper> m_Clippers = new IndexedSet<IClipper>();

		private readonly List<MaskUpdateGroup> groups = new List<MaskUpdateGroup>(4);

		public static ClipperRegistry instance
		{
			get
			{
				if (s_Instance == null)
				{
					s_Instance = new ClipperRegistry();
				}
				return s_Instance;
			}
		}

		protected ClipperRegistry()
		{
		}

		public void Cull()
		{
			for (int i = 0; i < groups.Count; i++)
			{
				MaskUpdateGroup maskUpdateGroup = groups[i];
				if (maskUpdateGroup.ShouldUpdate)
				{
					List<IClipper> masks = maskUpdateGroup.Masks;
					int count = masks.Count;
					for (int j = 0; j < count; j++)
					{
						masks[j].PerformClipping();
					}
				}
			}
			for (int k = 0; k < m_Clippers.Count; k++)
			{
				m_Clippers[k].PerformClipping();
			}
		}

		public static void Register(IClipper c)
		{
			if (c != null)
			{
				instance.m_Clippers.AddUnique(c);
			}
		}

		public static void Unregister(IClipper c)
		{
			instance.m_Clippers.Remove(c);
		}

		public static void RegisterGroup(MaskUpdateGroup group)
		{
			if (!instance.groups.Contains(group))
			{
				instance.groups.Add(group);
			}
		}

		public static void UnregisterGroup(MaskUpdateGroup group)
		{
			instance.groups.Remove(group);
		}

		public static int GetUnGroupedMaskCount()
		{
			return instance.m_Clippers.Count;
		}

		public static List<IClipper> GetUngroupedMasks()
		{
			List<IClipper> list = new List<IClipper>();
			for (int i = 0; i < instance.m_Clippers.Count; i++)
			{
				IClipper item = instance.m_Clippers[i];
				list.Add(item);
			}
			return list;
		}
	}
	public static class Clipping
	{
		public static Rect FindCullAndClipWorldRect(List<RectMask2D> rectMaskParents, out bool validRect)
		{
			if (rectMaskParents.Count == 0)
			{
				validRect = false;
				return default(Rect);
			}
			Rect canvasRect = rectMaskParents[0].canvasRect;
			float xMin = canvasRect.xMin;
			float xMax = canvasRect.xMax;
			float yMin = canvasRect.yMin;
			float yMax = canvasRect.yMax;
			for (int i = 1; i < rectMaskParents.Count; i++)
			{
				canvasRect = rectMaskParents[i].canvasRect;
				if (xMin < canvasRect.xMin)
				{
					xMin = canvasRect.xMin;
				}
				if (yMin < canvasRect.yMin)
				{
					yMin = canvasRect.yMin;
				}
				if (xMax > canvasRect.xMax)
				{
					xMax = canvasRect.xMax;
				}
				if (yMax > canvasRect.yMax)
				{
					yMax = canvasRect.yMax;
				}
			}
			validRect = xMax > xMin && yMax > yMin;
			if (validRect)
			{
				return new Rect(xMin, yMin, xMax - xMin, yMax - yMin);
			}
			return default(Rect);
		}
	}
	public interface IClipper
	{
		void PerformClipping();
	}
	public interface IClippable
	{
		GameObject gameObject { get; }

		RectTransform rectTransform { get; }

		void RecalculateClipping();

		void Cull(Rect clipRect, bool validRect);

		void SetClipRect(Rect value, bool validRect);
	}
	public interface IMaskGroupVisibility
	{
		bool ShouldUpdateMasks { get; }
	}
	[DefaultExecutionOrder(-1000)]
	public class MaskUpdateGroup : MonoBehaviour
	{
		public static Dictionary<string, MaskUpdateGroup> Groups = new Dictionary<string, MaskUpdateGroup>();

		[SerializeField]
		private string groupId;

		[SerializeField]
		private MonoBehaviour visibilityProvider;

		private readonly List<IClipper> masks = new List<IClipper>();

		private IMaskGroupVisibility visibility;

		public List<IClipper> Masks => masks;

		public bool ShouldUpdate
		{
			get
			{
				if (visibility != null)
				{
					return visibility.ShouldUpdateMasks;
				}
				return false;
			}
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]
		private static void ResetStaticFields()
		{
			Groups = new Dictionary<string, MaskUpdateGroup>();
		}

		private void Awake()
		{
			visibility = visibilityProvider as IMaskGroupVisibility;
			Groups[groupId] = this;
			ClipperRegistry.RegisterGroup(this);
		}

		private void OnDestroy()
		{
			Groups.Remove(groupId);
			ClipperRegistry.UnregisterGroup(this);
		}

		public void Register(IClipper clipper)
		{
			masks.Add(clipper);
		}

		public void Unregister(IClipper clipper)
		{
			masks.Remove(clipper);
		}
	}
	internal class RectangularVertexClipper
	{
		private readonly Vector3[] m_WorldCorners = new Vector3[4];

		private readonly Vector3[] m_CanvasCorners = new Vector3[4];

		public Rect GetCanvasRect(RectTransform t, Canvas c)
		{
			if (c == null)
			{
				return default(Rect);
			}
			t.GetWorldCorners(m_WorldCorners);
			Transform component = c.GetComponent<Transform>();
			for (int i = 0; i < 4; i++)
			{
				m_CanvasCorners[i] = component.InverseTransformPoint(m_WorldCorners[i]);
			}
			return new Rect(m_CanvasCorners[0].x, m_CanvasCorners[0].y, m_CanvasCorners[2].x - m_CanvasCorners[0].x, m_CanvasCorners[2].y - m_CanvasCorners[0].y);
		}
	}
	public static class DefaultControls
	{
		public interface IFactoryControls
		{
			GameObject CreateGameObject(string name, params Type[] components);
		}

		private class DefaultRuntimeFactory : IFactoryControls
		{
			public static IFactoryControls Default = new DefaultRuntimeFactory();

			public GameObject CreateGameObject(string name, params Type[] components)
			{
				return new GameObject(name, components);
			}
		}

		public struct Resources
		{
			public Sprite standard;

			public Sprite background;

			public Sprite inputField;

			public Sprite knob;

			public Sprite checkmark;

			public Sprite dropdown;

			public Sprite mask;
		}

		private static IFactoryControls m_CurrentFactory = DefaultRuntimeFactory.Default;

		private const float kWidth = 160f;

		private const float kThickHeight = 30f;

		private const float kThinHeight = 20f;

		private static Vector2 s_ThickElementSize = new Vector2(160f, 30f);

		private static Vector2 s_ThinElementSize = new Vector2(160f, 20f);

		private static Vector2 s_ImageElementSize = new Vector2(100f, 100f);

		private static Color s_DefaultSelectableColor = new Color(1f, 1f, 1f, 1f);

		private static Color s_PanelColor = new Color(1f, 1f, 1f, 0.392f);

		private static Color s_TextColor = new Color(10f / 51f, 10f / 51f, 10f / 51f, 1f);

		public static IFactoryControls factory => m_CurrentFactory;

		private static GameObject CreateUIElementRoot(string name, Vector2 size, params Type[] components)
		{
			GameObject gameObject = factory.CreateGameObject(name, components);
			gameObject.GetComponent<RectTransform>().sizeDelta = size;
			return gameObject;
		}

		private static GameObject CreateUIObject(string name, GameObject parent, params Type[] components)
		{
			GameObject gameObject = factory.CreateGameObject(name, components);
			SetParentAndAlign(gameObject, parent);
			return gameObject;
		}

		private static void SetDefaultTextValues(Text lbl)
		{
			lbl.color = s_TextColor;
			lbl.AssignDefaultFont();
		}

		private static void SetDefaultColorTransitionValues(Selectable slider)
		{
			ColorBlock colors = slider.colors;
			colors.highlightedColor = new Color(0.882f, 0.882f, 0.882f);
			colors.pressedColor = new Color(0.698f, 0.698f, 0.698f);
			colors.disabledColor = new Color(0.521f, 0.521f, 0.521f);
		}

		private static void SetParentAndAlign(GameObject child, GameObject parent)
		{
			if (!(parent == null))
			{
				child.transform.SetParent(parent.transform, worldPositionStays: false);
				SetLayerRecursively(child, parent.layer);
			}
		}

		private static void SetLayerRecursively(GameObject go, int layer)
		{
			go.layer = layer;
			Transform transform = go.transform;
			for (int i = 0; i < transform.childCount; i++)
			{
				SetLayerRecursively(transform.GetChild(i).gameObject, layer);
			}
		}

		public static GameObject CreatePanel(Resources resources)
		{
			GameObject gameObject = CreateUIElementRoot("Panel", s_ThickElementSize, typeof(Image));
			RectTransform component = gameObject.GetComponent<RectTransform>();
			component.anchorMin = Vector2.zero;
			component.anchorMax = Vector2.one;
			component.anchoredPosition = Vector2.zero;
			component.sizeDelta = Vector2.zero;
			Image component2 = gameObject.GetComponent<Image>();
			component2.sprite = resources.background;
			component2.type = Image.Type.Sliced;
			component2.color = s_PanelColor;
			return gameObject;
		}

		public static GameObject CreateButton(Resources resources)
		{
			GameObject gameObject = CreateUIElementRoot("Button", s_ThickElementSize, typeof(Image), typeof(Button));
			GameObject gameObject2 = CreateUIObject("Text", gameObject, typeof(Text));
			Image component = gameObject.GetComponent<Image>();
			component.sprite = resources.standard;
			component.type = Image.Type.Sliced;
			component.color = s_DefaultSelectableColor;
			SetDefaultColorTransitionValues(gameObject.GetComponent<Button>());
			Text component2 = gameObject2.GetComponent<Text>();
			component2.text = "Button";
			component2.alignment = TextAnchor.MiddleCenter;
			SetDefaultTextValues(component2);
			RectTransform component3 = gameObject2.GetComponent<RectTransform>();
			component3.anchorMin = Vector2.zero;
			component3.anchorMax = Vector2.one;
			component3.sizeDelta = Vector2.zero;
			return gameObject;
		}

		public static GameObject CreateText(Resources resources)
		{
			GameObject gameObject = CreateUIElementRoot("Text", s_ThickElementSize, typeof(Text));
			Text component = gameObject.GetComponent<Text>();
			component.text = "New Text";
			SetDefaultTextValues(component);
			return gameObject;
		}

		public static GameObject CreateImage(Resources resources)
		{
			return CreateUIElementRoot("Image", s_ImageElementSize, typeof(Image));
		}

		public static GameObject CreateRawImage(Resources resources)
		{
			return CreateUIElementRoot("RawImage", s_ImageElementSize, typeof(RawImage));
		}

		public static GameObject CreateSlider(Resources resources)
		{
			GameObject gameObject = CreateUIElementRoot("Slider", s_ThinElementSize, typeof(Slider));
			GameObject gameObject2 = CreateUIObject("Background", gameObject, typeof(Image));
			GameObject gameObject3 = CreateUIObject("Fill Area", gameObject, typeof(RectTransform));
			GameObject gameObject4 = CreateUIObject("Fill", gameObject3, typeof(Image));
			GameObject gameObject5 = CreateUIObject("Handle Slide Area", gameObject, typeof(RectTransform));
			GameObject gameObject6 = CreateUIObject("Handle", gameObject5, typeof(Image));
			Image component = gameObject2.GetComponent<Image>();
			component.sprite = resources.background;
			component.type = Image.Type.Sliced;
			component.color = s_DefaultSelectableColor;
			RectTransform component2 = gameObject2.GetComponent<RectTransform>();
			component2.anchorMin = new Vector2(0f, 0.25f);
			component2.anchorMax = new Vector2(1f, 0.75f);
			component2.sizeDelta = new Vector2(0f, 0f);
			RectTransform component3 = gameObject3.GetComponent<RectTransform>();
			component3.anchorMin = new Vector2(0f, 0.25f);
			component3.anchorMax = new Vector2(1f, 0.75f);
			component3.anchoredPosition = new Vector2(-5f, 0f);
			component3.sizeDelta = new Vector2(-20f, 0f);
			Image component4 = gameObject4.GetComponent<Image>();
			component4.sprite = resources.standard;
			component4.type = Image.Type.Sliced;
			component4.color = s_DefaultSelectableColor;
			gameObject4.GetComponent<RectTransform>().sizeDelta = new Vector2(10f, 0f);
			RectTransform component5 = gameObject5.GetComponent<RectTransform>();
			component5.sizeDelta = new Vector2(-20f, 0f);
			component5.anchorMin = new Vector2(0f, 0f);
			component5.anchorMax = new Vector2(1f, 1f);
			Image component6 = gameObject6.GetComponent<Image>();
			component6.sprite = resources.knob;
			component6.color = s_DefaultSelectableColor;
			gameObject6.GetComponent<RectTransform>().sizeDelta = new Vector2(20f, 0f);
			Slider component7 = gameObject.GetComponent<Slider>();
			component7.fillRect = gameObject4.GetComponent<RectTransform>();
			component7.handleRect = gameObject6.GetComponent<RectTransform>();
			component7.targetGraphic = component6;
			component7.direction = Slider.Direction.LeftToRight;
			SetDefaultColorTransitionValues(component7);
			return gameObject;
		}

		public static GameObject CreateScrollbar(Resources resources)
		{
			GameObject gameObject = CreateUIElementRoot("Scrollbar", s_ThinElementSize, typeof(Image), typeof(Scrollbar));
			GameObject gameObject2 = CreateUIObject("Sliding Area", gameObject, typeof(RectTransform));
			GameObject gameObject3 = CreateUIObject("Handle", gameObject2, typeof(Image));
			Image component = gameObject.GetComponent<Image>();
			component.sprite = resources.background;
			component.type = Image.Type.Sliced;
			component.color = s_DefaultSelectableColor;
			Image component2 = gameObject3.GetComponent<Image>();
			component2.sprite = resources.standard;
			component2.type = Image.Type.Sliced;
			component2.color = s_DefaultSelectableColor;
			RectTransform component3 = gameObject2.GetComponent<RectTransform>();
			component3.sizeDelta = new Vector2(-20f, -20f);
			component3.anchorMin = Vector2.zero;
			component3.anchorMax = Vector2.one;
			RectTransform component4 = gameObject3.GetComponent<RectTransform>();
			component4.sizeDelta = new Vector2(20f, 20f);
			Scrollbar component5 = gameObject.GetComponent<Scrollbar>();
			component5.handleRect = component4;
			component5.targetGraphic = component2;
			SetDefaultColorTransitionValues(component5);
			return gameObject;
		}

		public static GameObject CreateToggle(Resources resources)
		{
			GameObject gameObject = CreateUIElementRoot("Toggle", s_ThinElementSize, typeof(Toggle));
			GameObject gameObject2 = CreateUIObject("Background", gameObject, typeof(Image));
			GameObject gameObject3 = CreateUIObject("Checkmark", gameObject2, typeof(Image));
			GameObject gameObject4 = CreateUIObject("Label", gameObject, typeof(Text));
			Toggle component = gameObject.GetComponent<Toggle>();
			component.isOn = true;
			Image component2 = gameObject2.GetComponent<Image>();
			component2.sprite = resources.standard;
			component2.type = Image.Type.Sliced;
			component2.color = s_DefaultSelectableColor;
			Image component3 = gameObject3.GetComponent<Image>();
			component3.sprite = resources.checkmark;
			Text component4 = gameObject4.GetComponent<Text>();
			component4.text = "Toggle";
			SetDefaultTextValues(component4);
			component.graphic = component3;
			component.targetGraphic = component2;
			SetDefaultColorTransitionValues(component);
			RectTransform component5 = gameObject2.GetComponent<RectTransform>();
			component5.anchorMin = new Vector2(0f, 1f);
			component5.anchorMax = new Vector2(0f, 1f);
			component5.anchoredPosition = new Vector2(10f, -10f);
			component5.sizeDelta = new Vector2(20f, 20f);
			RectTransform component6 = gameObject3.GetComponent<RectTransform>();
			component6.anchorMin = new Vector2(0.5f, 0.5f);
			component6.anchorMax = new Vector2(0.5f, 0.5f);
			component6.anchoredPosition = Vector2.zero;
			component6.sizeDelta = new Vector2(20f, 20f);
			RectTransform component7 = gameObject4.GetComponent<RectTransform>();
			component7.anchorMin = new Vector2(0f, 0f);
			component7.anchorMax = new Vector2(1f, 1f);
			component7.offsetMin = new Vector2(23f, 1f);
			component7.offsetMax = new Vector2(-5f, -2f);
			return gameObject;
		}

		public static GameObject CreateInputField(Resources resources)
		{
			GameObject gameObject = CreateUIElementRoot("InputField", s_ThickElementSize, typeof(Image), typeof(InputField));
			GameObject gameObject2 = CreateUIObject("Placeholder", gameObject, typeof(Text));
			GameObject gameObject3 = CreateUIObject("Text", gameObject, typeof(Text));
			Image component = gameObject.GetComponent<Image>();
			component.sprite = resources.inputField;
			component.type = Image.Type.Sliced;
			component.color = s_DefaultSelectableColor;
			InputField component2 = gameObject.GetComponent<InputField>();
			SetDefaultColorTransitionValues(component2);
			Text component3 = gameObject3.GetComponent<Text>();
			component3.text = "";
			component3.supportRichText = false;
			SetDefaultTextValues(component3);
			Text component4 = gameObject2.GetComponent<Text>();
			component4.text = "Enter text...";
			component4.fontStyle = FontStyle.Italic;
			Color color = component3.color;
			color.a *= 0.5f;
			component4.color = color;
			RectTransform component5 = gameObject3.GetComponent<RectTransform>();
			component5.anchorMin = Vector2.zero;
			component5.anchorMax = Vector2.one;
			component5.sizeDelta = Vector2.zero;
			component5.offsetMin = new Vector2(10f, 6f);
			component5.offsetMax = new Vector2(-10f, -7f);
			RectTransform component6 = gameObject2.GetComponent<RectTransform>();
			component6.anchorMin = Vector2.zero;
			component6.anchorMax = Vector2.one;
			component6.sizeDelta = Vector2.zero;
			component6.offsetMin = new Vector2(10f, 6f);
			component6.offsetMax = new Vector2(-10f, -7f);
			component2.textComponent = component3;
			component2.placeholder = component4;
			return gameObject;
		}

		public static GameObject CreateDropdown(Resources resources)
		{
			GameObject gameObject = CreateUIElementRoot("Dropdown", s_ThickElementSize, typeof(Image), typeof(Dropdown));
			GameObject gameObject2 = CreateUIObject("Label", gameObject, typeof(Text));
			GameObject gameObject3 = CreateUIObject("Arrow", gameObject, typeof(Image));
			GameObject gameObject4 = CreateUIObject("Template", gameObject, typeof(Image), typeof(ScrollRect));
			GameObject gameObject5 = CreateUIObject("Viewport", gameObject4, typeof(Image), typeof(Mask));
			GameObject gameObject6 = CreateUIObject("Content", gameObject5, typeof(RectTransform));
			GameObject gameObject7 = CreateUIObject("Item", gameObject6, typeof(Toggle));
			GameObject gameObject8 = CreateUIObject("Item Background", gameObject7, typeof(Image));
			GameObject gameObject9 = CreateUIObject("Item Checkmark", gameObject7, typeof(Image));
			GameObject gameObject10 = CreateUIObject("Item Label", gameObject7, typeof(Text));
			GameObject gameObject11 = CreateScrollbar(resources);
			gameObject11.name = "Scrollbar";
			SetParentAndAlign(gameObject11, gameObject4);
			Scrollbar component = gameObject11.GetComponent<Scrollbar>();
			component.SetDirection(Scrollbar.Direction.BottomToTop, includeRectLayouts: true);
			RectTransform component2 = gameObject11.GetComponent<RectTransform>();
			component2.anchorMin = Vector2.right;
			component2.anchorMax = Vector2.one;
			component2.pivot = Vector2.one;
			component2.sizeDelta = new Vector2(component2.sizeDelta.x, 0f);
			Text component3 = gameObject10.GetComponent<Text>();
			SetDefaultTextValues(component3);
			component3.alignment = TextAnchor.MiddleLeft;
			Image component4 = gameObject8.GetComponent<Image>();
			component4.color = new Color32(245, 245, 245, byte.MaxValue);
			Image component5 = gameObject9.GetComponent<Image>();
			component5.sprite = resources.checkmark;
			Toggle component6 = gameObject7.GetComponent<Toggle>();
			component6.targetGraphic = component4;
			component6.graphic = component5;
			component6.isOn = true;
			Image component7 = gameObject4.GetComponent<Image>();
			component7.sprite = resources.standard;
			component7.type = Image.Type.Sliced;
			ScrollRect component8 = gameObject4.GetComponent<ScrollRect>();
			component8.content = gameObject6.GetComponent<RectTransform>();
			component8.viewport = gameObject5.GetComponent<RectTransform>();
			component8.horizontal = false;
			component8.movementType = ScrollRect.MovementType.Clamped;
			component8.verticalScrollbar = component;
			component8.verticalScrollbarVisibility = ScrollRect.ScrollbarVisibility.AutoHideAndExpandViewport;
			component8.verticalScrollbarSpacing = -3f;
			gameObject5.GetComponent<Mask>().showMaskGraphic = false;
			Image component9 = gameObject5.GetComponent<Image>();
			component9.sprite = resources.mask;
			component9.type = Image.Type.Sliced;
			Text component10 = gameObject2.GetComponent<Text>();
			SetDefaultTextValues(component10);
			component10.alignment = TextAnchor.MiddleLeft;
			gameObject3.GetComponent<Image>().sprite = resources.dropdown;
			Image component11 = gameObject.GetComponent<Image>();
			component11.sprite = resources.standard;
			component11.color = s_DefaultSelectableColor;
			component11.type = Image.Type.Sliced;
			Dropdown component12 = gameObject.GetComponent<Dropdown>();
			component12.targetGraphic = component11;
			SetDefaultColorTransitionValues(component12);
			component12.template = gameObject4.GetComponent<RectTransform>();
			component12.captionText = component10;
			component12.itemText = component3;
			component3.text = "Option A";
			component12.options.Add(new Dropdown.OptionData
			{
				text = "Option A"
			});
			component12.options.Add(new Dropdown.OptionData
			{
				text = "Option B"
			});
			component12.options.Add(new Dropdown.OptionData
			{
				text = "Option C"
			});
			component12.RefreshShownValue();
			RectTransform component13 = gameObject2.GetComponent<RectTransform>();
			component13.anchorMin = Vector2.zero;
			component13.anchorMax = Vector2.one;
			component13.offsetMin = new Vector2(10f, 6f);
			component13.offsetMax = new Vector2(-25f, -7f);
			RectTransform component14 = gameObject3.GetComponent<RectTransform>();
			component14.anchorMin = new Vector2(1f, 0.5f);
			component14.anchorMax = new Vector2(1f, 0.5f);
			component14.sizeDelta = new Vector2(20f, 20f);
			component14.anchoredPosition = new Vector2(-15f, 0f);
			RectTransform component15 = gameObject4.GetComponent<RectTransform>();
			component15.anchorMin = new Vector2(0f, 0f);
			component15.anchorMax = new Vector2(1f, 0f);
			component15.pivot = new Vector2(0.5f, 1f);
			component15.anchoredPosition = new Vector2(0f, 2f);
			component15.sizeDelta = new Vector2(0f, 150f);
			RectTransform component16 = gameObject5.GetComponent<RectTransform>();
			component16.anchorMin = new Vector2(0f, 0f);
			component16.anchorMax = new Vector2(1f, 1f);
			component16.sizeDelta = new Vector2(-18f, 0f);
			component16.pivot = new Vector2(0f, 1f);
			RectTransform component17 = gameObject6.GetComponent<RectTransform>();
			component17.anchorMin = new Vector2(0f, 1f);
			component17.anchorMax = new Vector2(1f, 1f);
			component17.pivot = new Vector2(0.5f, 1f);
			component17.anchoredPosition = new Vector2(0f, 0f);
			component17.sizeDelta = new Vector2(0f, 28f);
			RectTransform component18 = gameObject7.GetComponent<RectTransform>();
			component18.anchorMin = new Vector2(0f, 0.5f);
			component18.anchorMax = new Vector2(1f, 0.5f);
			component18.sizeDelta = new Vector2(0f, 20f);
			RectTransform component19 = gameObject8.GetComponent<RectTransform>();
			component19.anchorMin = Vector2.zero;
			component19.anchorMax = Vector2.one;
			component19.sizeDelta = Vector2.zero;
			RectTransform component20 = gameObject9.GetComponent<RectTransform>();
			component20.anchorMin = new Vector2(0f, 0.5f);
			component20.anchorMax = new Vector2(0f, 0.5f);
			component20.sizeDelta = new Vector2(20f, 20f);
			component20.anchoredPosition = new Vector2(10f, 0f);
			RectTransform component21 = gameObject10.GetComponent<RectTransform>();
			component21.anchorMin = Vector2.zero;
			component21.anchorMax = Vector2.one;
			component21.offsetMin = new Vector2(20f, 1f);
			component21.offsetMax = new Vector2(-10f, -2f);
			gameObject4.SetActive(value: false);
			return gameObject;
		}

		public static GameObject CreateScrollView(Resources resources)
		{
			GameObject gameObject = CreateUIElementRoot("Scroll View", new Vector2(200f, 200f), typeof(Image), typeof(ScrollRect));
			GameObject gameObject2 = CreateUIObject("Viewport", gameObject, typeof(Image), typeof(Mask));
			GameObject gameObject3 = CreateUIObject("Content", gameObject2, typeof(RectTransform));
			GameObject gameObject4 = CreateScrollbar(resources);
			gameObject4.name = "Scrollbar Horizontal";
			SetParentAndAlign(gameObject4, gameObject);
			RectTransform component = gameObject4.GetComponent<RectTransform>();
			component.anchorMin = Vector2.zero;
			component.anchorMax = Vector2.right;
			component.pivot = Vector2.zero;
			component.sizeDelta = new Vector2(0f, component.sizeDelta.y);
			GameObject gameObject5 = CreateScrollbar(resources);
			gameObject5.name = "Scrollbar Vertical";
			SetParentAndAlign(gameObject5, gameObject);
			gameObject5.GetComponent<Scrollbar>().SetDirection(Scrollbar.Direction.BottomToTop, includeRectLayouts: true);
			RectTransform component2 = gameObject5.GetComponent<RectTransform>();
			component2.anchorMin = Vector2.right;
			component2.anchorMax = Vector2.one;
			component2.pivot = Vector2.one;
			component2.sizeDelta = new Vector2(component2.sizeDelta.x, 0f);
			RectTransform component3 = gameObject2.GetComponent<RectTransform>();
			component3.anchorMin = Vector2.zero;
			component3.anchorMax = Vector2.one;
			component3.sizeDelta = Vector2.zero;
			component3.pivot = Vector2.up;
			RectTransform component4 = gameObject3.GetComponent<RectTransform>();
			component4.anchorMin = Vector2.up;
			component4.anchorMax = Vector2.one;
			component4.sizeDelta = new Vector2(0f, 300f);
			component4.pivot = Vector2.up;
			ScrollRect component5 = gameObject.GetComponent<ScrollRect>();
			component5.content = component4;
			component5.viewport = component3;
			component5.horizontalScrollbar = gameObject4.GetComponent<Scrollbar>();
			component5.verticalScrollbar = gameObject5.GetComponent<Scrollbar>();
			component5.horizontalScrollbarVisibility = ScrollRect.ScrollbarVisibility.AutoHideAndExpandViewport;
			component5.verticalScrollbarVisibility = ScrollRect.ScrollbarVisibility.AutoHideAndExpandViewport;
			component5.horizontalScrollbarSpacing = -3f;
			component5.verticalScrollbarSpacing = -3f;
			Image component6 = gameObject.GetComponent<Image>();
			component6.sprite = resources.background;
			component6.type = Image.Type.Sliced;
			component6.color = s_PanelColor;
			gameObject2.GetComponent<Mask>().showMaskGraphic = false;
			Image component7 = gameObject2.GetComponent<Image>();
			component7.sprite = resources.mask;
			component7.type = Image.Type.Sliced;
			return gameObject;
		}
	}
	[AddComponentMenu("")]
	[RequireComponent(typeof(RectTransform))]
	public class Dropdown : Selectable, IPointerClickHandler, IEventSystemHandler, ISubmitHandler, ICancelHandler
	{
		protected internal class DropdownItem : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, ICancelHandler
		{
			[SerializeField]
			private Text m_Text;

			[SerializeField]
			private Image m_Image;

			[SerializeField]
			private RectTransform m_RectTransform;

			[SerializeField]
			private Toggle m_Toggle;

			public Text text
			{
				get
				{
					return m_Text;
				}
				set
				{
					m_Text = value;
				}
			}

			public Image image
			{
				get
				{
					return m_Image;
				}
				set
				{
					m_Image = value;
				}
			}

			public RectTransform rectTransform
			{
				get
				{
					return m_RectTransform;
				}
				set
				{
					m_RectTransform = value;
				}
			}

			public Toggle toggle
			{
				get
				{
					return m_Toggle;
				}
				set
				{
					m_Toggle = value;
				}
			}

			public virtual void OnPointerEnter(PointerEventData eventData)
			{
				EventSystem.current.SetSelectedGameObject(base.gameObject);
			}

			public virtual void OnCancel(BaseEventData eventData)
			{
				Dropdown componentInParent = GetComponentInParent<Dropdown>();
				if ((bool)componentInParent)
				{
					componentInParent.Hide();
				}
			}
		}

		[Serializable]
		public class OptionData
		{
			[SerializeField]
			private string m_Text;

			[SerializeField]
			private Sprite m_Image;

			public string text
			{
				get
				{
					return m_Text;
				}
				set
				{
					m_Text = value;
				}
			}

			public Sprite image
			{
				get
				{
					return m_Image;
				}
				set
				{
					m_Image = value;
				}
			}

			public OptionData()
			{
			}

			public OptionData(string text)
			{
				this.text = text;
			}

			public OptionData(Sprite image)
			{
				this.image = image;
			}

			public OptionData(string text, Sprite image)
			{
				this.text = text;
				this.image = image;
			}
		}

		[Serializable]
		public class OptionDataList
		{
			[SerializeField]
			private List<OptionData> m_Options;

			public List<OptionData> options
			{
				get
				{
					return m_Options;
				}
				set
				{
					m_Options = value;
				}
			}

			public OptionDataList()
			{
				options = new List<OptionData>();
			}
		}

		[Serializable]
		public class DropdownEvent : UnityEvent<int>
		{
		}

		[SerializeField]
		private RectTransform m_Template;

		[SerializeField]
		private Text m_CaptionText;

		[SerializeField]
		private Image m_CaptionImage;

		[Space]
		[SerializeField]
		private Text m_ItemText;

		[SerializeField]
		private Image m_ItemImage;

		[Space]
		[SerializeField]
		private int m_Value;

		[Space]
		[SerializeField]
		private OptionDataList m_Options = new OptionDataList();

		[Space]
		[SerializeField]
		private DropdownEvent m_OnValueChanged = new DropdownEvent();

		[SerializeField]
		private float m_AlphaFadeSpeed = 0.15f;

		private GameObject m_Dropdown;

		private GameObject m_Blocker;

		private List<DropdownItem> m_Items = new List<DropdownItem>();

		private TweenRunner<FloatTween> m_AlphaTweenRunner;

		private bool validTemplate;

		private static OptionData s_NoOptionData = new OptionData();

		public RectTransform template
		{
			get
			{
				return m_Template;
			}
			set
			{
				m_Template = value;
				RefreshShownValue();
			}
		}

		public Text captionText
		{
			get
			{
				return m_CaptionText;
			}
			set
			{
				m_CaptionText = value;
				RefreshShownValue();
			}
		}

		public Image captionImage
		{
			get
			{
				return m_CaptionImage;
			}
			set
			{
				m_CaptionImage = value;
				RefreshShownValue();
			}
		}

		public Text itemText
		{
			get
			{
				return m_ItemText;
			}
			set
			{
				m_ItemText = value;
				RefreshShownValue();
			}
		}

		public Image itemImage
		{
			get
			{
				return m_ItemImage;
			}
			set
			{
				m_ItemImage = value;
				RefreshShownValue();
			}
		}

		public List<OptionData> options
		{
			get
			{
				return m_Options.options;
			}
			set
			{
				m_Options.options = value;
				RefreshShownValue();
			}
		}

		public DropdownEvent onValueChanged
		{
			get
			{
				return m_OnValueChanged;
			}
			set
			{
				m_OnValueChanged = value;
			}
		}

		public float alphaFadeSpeed
		{
			get
			{
				return m_AlphaFadeSpeed;
			}
			set
			{
				m_AlphaFadeSpeed = value;
			}
		}

		public int value
		{
			get
			{
				return m_Value;
			}
			set
			{
				Set(value);
			}
		}

		public void SetValueWithoutNotify(int input)
		{
			Set(input, sendCallback: false);
		}

		private void Set(int value, bool sendCallback = true)
		{
			if (!Application.isPlaying || (value != m_Value && options.Count != 0))
			{
				m_Value = Mathf.Clamp(value, 0, options.Count - 1);
				RefreshShownValue();
				if (sendCallback)
				{
					UISystemProfilerApi.AddMarker("Dropdown.value", this);
					m_OnValueChanged.Invoke(m_Value);
				}
			}
		}

		protected Dropdown()
		{
		}

		protected override void Awake()
		{
			m_AlphaTweenRunner = new TweenRunner<FloatTween>();
			m_AlphaTweenRunner.Init(this);
			if ((bool)m_CaptionImage)
			{
				m_CaptionImage.enabled = m_CaptionImage.sprite != null;
			}
			if ((bool)m_Template)
			{
				m_Template.gameObject.SetActive(value: false);
			}
		}

		protected override void Start()
		{
			base.Start();
			RefreshShownValue();
		}

		protected override void OnDisable()
		{
			ImmediateDestroyDropdownList();
			if (m_Blocker != null)
			{
				DestroyBlocker(m_Blocker);
			}
			m_Blocker = null;
			base.OnDisable();
		}

		public void RefreshShownValue()
		{
			OptionData optionData = s_NoOptionData;
			if (options.Count > 0)
			{
				optionData = options[Mathf.Clamp(m_Value, 0, options.Count - 1)];
			}
			if ((bool)m_CaptionText)
			{
				if (optionData != null && optionData.text != null)
				{
					m_CaptionText.text = optionData.text;
				}
				else
				{
					m_CaptionText.text = "";
				}
			}
			if ((bool)m_CaptionImage)
			{
				if (optionData != null)
				{
					m_CaptionImage.sprite = optionData.image;
				}
				else
				{
					m_CaptionImage.sprite = null;
				}
				m_CaptionImage.enabled = m_CaptionImage.sprite != null;
			}
		}

		public void AddOptions(List<OptionData> options)
		{
			this.options.AddRange(options);
			RefreshShownValue();
		}

		public void AddOptions(List<string> options)
		{
			for (int i = 0; i < options.Count; i++)
			{
				this.options.Add(new OptionData(options[i]));
			}
			RefreshShownValue();
		}

		public void AddOptions(List<Sprite> options)
		{
			for (int i = 0; i < options.Count; i++)
			{
				this.options.Add(new OptionData(options[i]));
			}
			RefreshShownValue();
		}

		public void ClearOptions()
		{
			options.Clear();
			m_Value = 0;
			RefreshShownValue();
		}

		private void SetupTemplate()
		{
			validTemplate = false;
			if (!m_Template)
			{
				Debug.LogError("The dropdown template is not assigned. The template needs to be assigned and must have a child GameObject with a Toggle component serving as the item.", this);
				return;
			}
			GameObject gameObject = m_Template.gameObject;
			gameObject.SetActive(value: true);
			Toggle componentInChildren = m_Template.GetComponentInChildren<Toggle>();
			validTemplate = true;
			if (!componentInChildren || componentInChildren.transform == template)
			{
				validTemplate = false;
				Debug.LogError("The dropdown template is not valid. The template must have a child GameObject with a Toggle component serving as the item.", template);
			}
			else if (!(componentInChildren.transform.parent is RectTransform))
			{
				validTemplate = false;
				Debug.LogError("The dropdown template is not valid. The child GameObject with a Toggle component (the item) must have a RectTransform on its parent.", template);
			}
			else if (itemText != null && !itemText.transform.IsChildOf(componentInChildren.transform))
			{
				validTemplate = false;
				Debug.LogError("The dropdown template is not valid. The Item Text must be on the item GameObject or children of it.", template);
			}
			else if (itemImage != null && !itemImage.transform.IsChildOf(componentInChildren.transform))
			{
				validTemplate = false;
				Debug.LogError("The dropdown template is not valid. The Item Image must be on the item GameObject or children of it.", template);
			}
			if (!validTemplate)
			{
				gameObject.SetActive(value: false);
				return;
			}
			DropdownItem dropdownItem = componentInChildren.gameObject.AddComponent<DropdownItem>();
			dropdownItem.text = m_ItemText;
			dropdownItem.image = m_ItemImage;
			dropdownItem.toggle = componentInChildren;
			dropdownItem.rectTransform = (RectTransform)componentInChildren.transform;
			Canvas canvas = null;
			Transform parent = m_Template.parent;
			while (parent != null)
			{
				canvas = parent.GetComponent<Canvas>();
				if (canvas != null)
				{
					break;
				}
				parent = parent.parent;
			}
			Canvas orAddComponent = GetOrAddComponent<Canvas>(gameObject);
			orAddComponent.overrideSorting = true;
			orAddComponent.sortingOrder = 30000;
			if (canvas != null)
			{
				Component[] components = canvas.GetComponents<BaseRaycaster>();
				Component[] array = components;
				for (int i = 0; i < array.Length; i++)
				{
					Type type = array[i].GetType();
					if (gameObject.GetComponent(type) == null)
					{
						gameObject.AddComponent(type);
					}
				}
			}
			else
			{
				GetOrAddComponent<GraphicRaycaster>(gameObject);
			}
			GetOrAddComponent<CanvasGroup>(gameObject);
			gameObject.SetActive(value: false);
			validTemplate = true;
		}

		private static T GetOrAddComponent<T>(GameObject go) where T : Component
		{
			T val = go.GetComponent<T>();
			if (!val)
			{
				val = go.AddComponent<T>();
			}
			return val;
		}

		public virtual void OnPointerClick(PointerEventData eventData)
		{
			Show();
		}

		public virtual void OnSubmit(BaseEventData eventData)
		{
			Show();
		}

		public virtual void OnCancel(BaseEventData eventData)
		{
			Hide();
		}

		public void Show()
		{
			if (!IsActive() || !IsInteractable() || m_Dropdown != null)
			{
				return;
			}
			List<Canvas> list = ListPool<Canvas>.Get();
			base.gameObject.GetComponentsInParent(includeInactive: false, list);
			if (list.Count == 0)
			{
				return;
			}
			Canvas canvas = list[list.Count - 1];
			for (int i = 0; i < list.Count; i++)
			{
				if (list[i].isRootCanvas)
				{
					canvas = list[i];
					break;
				}
			}
			ListPool<Canvas>.Release(list);
			if (!validTemplate)
			{
				SetupTemplate();
				if (!validTemplate)
				{
					return;
				}
			}
			m_Template.gameObject.SetActive(value: true);
			m_Template.GetComponent<Canvas>().sortingLayerID = canvas.sortingLayerID;
			m_Dropdown = CreateDropdownList(m_Template.gameObject);
			m_Dropdown.name = "Dropdown List";
			m_Dropdown.SetActive(value: true);
			RectTransform rectTransform = m_Dropdown.transform as RectTransform;
			rectTransform.SetParent(m_Template.transform.parent, worldPositionStays: false);
			DropdownItem componentInChildren = m_Dropdown.GetComponentInChildren<DropdownItem>();
			RectTransform rectTransform2 = componentInChildren.rectTransform.parent.gameObject.transform as RectTransform;
			componentInChildren.rectTransform.gameObject.SetActive(value: true);
			Rect rect = rectTransform2.rect;
			Rect rect2 = componentInChildren.rectTransform.rect;
			Vector2 vector = rect2.min - rect.min + (Vector2)componentInChildren.rectTransform.localPosition;
			Vector2 vector2 = rect2.max - rect.max + (Vector2)componentInChildren.rectTransform.localPosition;
			Vector2 size = rect2.size;
			m_Items.Clear();
			Toggle toggle = null;
			for (int j = 0; j < options.Count; j++)
			{
				OptionData data = options[j];
				DropdownItem item = AddItem(data, value == j, componentInChildren, m_Items);
				if (!(item == null))
				{
					item.toggle.isOn = value == j;
					item.toggle.onValueChanged.AddListener(delegate
					{
						OnSelectItem(item.toggle);
					});
					if (item.toggle.isOn)
					{
						item.toggle.Select();
					}
					if (toggle != null)
					{
						Navigation navigation = toggle.navigation;
						Navigation navigation2 = item.toggle.navigation;
						navigation.mode = Navigation.Mode.Explicit;
						navigation2.mode = Navigation.Mode.Explicit;
						navigation.selectOnDown = item.toggle;
						navigation.selectOnRight = item.toggle;
						navigation2.selectOnLeft = toggle;
						navigation2.selectOnUp = toggle;
						toggle.navigation = navigation;
						item.toggle.navigation = navigation2;
					}
					toggle = item.toggle;
				}
			}
			Vector2 sizeDelta = rectTransform2.sizeDelta;
			sizeDelta.y = size.y * (float)m_Items.Count + vector.y - vector2.y;
			rectTransform2.sizeDelta = sizeDelta;
			float num = rectTransform.rect.height - rectTransform2.rect.height;
			if (num > 0f)
			{
				rectTransform.sizeDelta = new Vector2(rectTransform.sizeDelta.x, rectTransform.sizeDelta.y - num);
			}
			Vector3[] array = new Vector3[4];
			rectTransform.GetWorldCorners(array);
			RectTransform rectTransform3 = canvas.transform as RectTransform;
			Rect rect3 = rectTransform3.rect;
			for (int num2 = 0; num2 < 2; num2++)
			{
				bool flag = false;
				for (int num3 = 0; num3 < 4; num3++)
				{
					Vector3 vector3 = rectTransform3.InverseTransformPoint(array[num3]);
					if ((vector3[num2] < rect3.min[num2] && !Mathf.Approximately(vector3[num2], rect3.min[num2])) || (vector3[num2] > rect3.max[num2] && !Mathf.Approximately(vector3[num2], rect3.max[num2])))
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					RectTransformUtility.FlipLayoutOnAxis(rectTransform, num2, keepPositioning: false, recursive: false);
				}
			}
			for (int num4 = 0; num4 < m_Items.Count; num4++)
			{
				RectTransform rectTransform4 = m_Items[num4].rectTransform;
				rectTransform4.anchorMin = new Vector2(rectTransform4.anchorMin.x, 0f);
				rectTransform4.anchorMax = new Vector2(rectTransform4.anchorMax.x, 0f);
				rectTransform4.anchoredPosition = new Vector2(rectTransform4.anchoredPosition.x, vector.y + size.y * (float)(m_Items.Count - 1 - num4) + size.y * rectTransform4.pivot.y);
				rectTransform4.sizeDelta = new Vector2(rectTransform4.sizeDelta.x, size.y);
			}
			AlphaFadeList(m_AlphaFadeSpeed, 0f, 1f);
			m_Template.gameObject.SetActive(value: false);
			componentInChildren.gameObject.SetActive(value: false);
			m_Blocker = CreateBlocker(canvas);
		}

		protected virtual GameObject CreateBlocker(Canvas rootCanvas)
		{
			GameObject gameObject = new GameObject("Blocker");
			RectTransform rectTransform = gameObject.AddComponent<RectTransform>();
			rectTransform.SetParent(rootCanvas.transform, worldPositionStays: false);
			rectTransform.anchorMin = Vector3.zero;
			rectTransform.anchorMax = Vector3.one;
			rectTransform.sizeDelta = Vector2.zero;
			Canvas canvas = gameObject.AddComponent<Canvas>();
			canvas.overrideSorting = true;
			Canvas component = m_Dropdown.GetComponent<Canvas>();
			canvas.sortingLayerID = component.sortingLayerID;
			canvas.sortingOrder = component.sortingOrder - 1;
			Canvas canvas2 = null;
			Transform parent = m_Template.parent;
			while (parent != null)
			{
				canvas2 = parent.GetComponent<Canvas>();
				if (canvas2 != null)
				{
					break;
				}
				parent = parent.parent;
			}
			if (canvas2 != null)
			{
				Component[] components = canvas2.GetComponents<BaseRaycaster>();
				Component[] array = components;
				for (int i = 0; i < array.Length; i++)
				{
					Type type = array[i].GetType();
					if (gameObject.GetComponent(type) == null)
					{
						gameObject.AddComponent(type);
					}
				}
			}
			else
			{
				GetOrAddComponent<GraphicRaycaster>(gameObject);
			}
			gameObject.AddComponent<Image>().color = Color.clear;
			gameObject.AddComponent<Button>().onClick.AddListener(Hide);
			return gameObject;
		}

		protected virtual void DestroyBlocker(GameObject blocker)
		{
			Object.Destroy(blocker);
		}

		protected virtual GameObject CreateDropdownList(GameObject template)
		{
			return Object.Instantiate(template);
		}

		protected virtual void DestroyDropdownList(GameObject dropdownList)
		{
			Object.Destroy(dropdownList);
		}

		protected virtual DropdownItem CreateItem(DropdownItem itemTemplate)
		{
			return Object.Instantiate(itemTemplate);
		}

		protected virtual void DestroyItem(DropdownItem item)
		{
		}

		private DropdownItem AddItem(OptionData data, bool selected, DropdownItem itemTemplate, List<DropdownItem> items)
		{
			DropdownItem dropdownItem = CreateItem(itemTemplate);
			dropdownItem.rectTransform.SetParent(itemTemplate.rectTransform.parent, worldPositionStays: false);
			dropdownItem.gameObject.SetActive(value: true);
			dropdownItem.gameObject.name = "Item " + items.Count + ((data.text != null) ? (": " + data.text) : "");
			if (dropdownItem.toggle != null)
			{
				dropdownItem.toggle.isOn = false;
			}
			if ((bool)dropdownItem.text)
			{
				dropdownItem.text.text = data.text;
			}
			if ((bool)dropdownItem.image)
			{
				dropdownItem.image.sprite = data.image;
				dropdownItem.image.enabled = dropdownItem.image.sprite != null;
			}
			items.Add(dropdownItem);
			return dropdownItem;
		}

		private void AlphaFadeList(float duration, float alpha)
		{
			CanvasGroup component = m_Dropdown.GetComponent<CanvasGroup>();
			AlphaFadeList(duration, component.alpha, alpha);
		}

		private void AlphaFadeList(float duration, float start, float end)
		{
			if (!end.Equals(start))
			{
				FloatTween info = new FloatTween
				{
					duration = duration,
					startValue = start,
					targetValue = end
				};
				info.AddOnChangedCallback(SetAlpha);
				info.ignoreTimeScale = true;
				m_AlphaTweenRunner.StartTween(info);
			}
		}

		private void SetAlpha(float alpha)
		{
			if ((bool)m_Dropdown)
			{
				m_Dropdown.GetComponent<CanvasGroup>().alpha = alpha;
			}
		}

		public void Hide()
		{
			if (m_Dropdown != null)
			{
				AlphaFadeList(m_AlphaFadeSpeed, 0f);
				if (IsActive())
				{
					StartCoroutine(DelayedDestroyDropdownList(m_AlphaFadeSpeed));
				}
			}
			if (m_Blocker != null)
			{
				DestroyBlocker(m_Blocker);
			}
			m_Blocker = null;
			Select();
		}

		private IEnumerator DelayedDestroyDropdownList(float delay)
		{
			yield return new WaitForSecondsRealtime(delay);
			ImmediateDestroyDropdownList();
		}

		private void ImmediateDestroyDropdownList()
		{
			for (int i = 0; i < m_Items.Count; i++)
			{
				if (m_Items[i] != null)
				{
					DestroyItem(m_Items[i]);
				}
			}
			m_Items.Clear();
			if (m_Dropdown != null)
			{
				DestroyDropdownList(m_Dropdown);
			}
			m_Dropdown = null;
		}

		private void OnSelectItem(Toggle toggle)
		{
			if (!toggle.isOn)
			{
				toggle.isOn = true;
			}
			int num = -1;
			Transform transform = toggle.transform;
			Transform parent = transform.parent;
			for (int i = 0; i < parent.childCount; i++)
			{
				if (parent.GetChild(i) == transform)
				{
					num = i - 1;
					break;
				}
			}
			if (num >= 0)
			{
				value = num;
				Hide();
			}
		}
	}
	[Serializable]
	public class FontData : ISerializationCallbackReceiver
	{
		[SerializeField]
		[FormerlySerializedAs("font")]
		private Font m_Font;

		[SerializeField]
		[FormerlySerializedAs("fontSize")]
		private int m_FontSize;

		[SerializeField]
		[FormerlySerializedAs("fontStyle")]
		private FontStyle m_FontStyle;

		[SerializeField]
		private bool m_BestFit;

		[SerializeField]
		private int m_MinSize;

		[SerializeField]
		private int m_MaxSize;

		[SerializeField]
		[FormerlySerializedAs("alignment")]
		private TextAnchor m_Alignment;

		[SerializeField]
		private bool m_AlignByGeometry;

		[SerializeField]
		[FormerlySerializedAs("richText")]
		private bool m_RichText;

		[SerializeField]
		private HorizontalWrapMode m_HorizontalOverflow;

		[SerializeField]
		private VerticalWrapMode m_VerticalOverflow;

		[SerializeField]
		private float m_LineSpacing;

		public static FontData defaultFontData => new FontData
		{
			m_FontSize = 14,
			m_LineSpacing = 1f,
			m_FontStyle = FontStyle.Normal,
			m_BestFit = false,
			m_MinSize = 10,
			m_MaxSize = 40,
			m_Alignment = TextAnchor.UpperLeft,
			m_HorizontalOverflow = HorizontalWrapMode.Wrap,
			m_VerticalOverflow = VerticalWrapMode.Truncate,
			m_RichText = true,
			m_AlignByGeometry = false
		};

		public Font font
		{
			get
			{
				return m_Font;
			}
			set
			{
				m_Font = value;
			}
		}

		public int fontSize
		{
			get
			{
				return m_FontSize;
			}
			set
			{
				m_FontSize = value;
			}
		}

		public FontStyle fontStyle
		{
			get
			{
				return m_FontStyle;
			}
			set
			{
				m_FontStyle = value;
			}
		}

		public bool bestFit
		{
			get
			{
				return m_BestFit;
			}
			set
			{
				m_BestFit = value;
			}
		}

		public int minSize
		{
			get
			{
				return m_MinSize;
			}
			set
			{
				m_MinSize = value;
			}
		}

		public int maxSize
		{
			get
			{
				return m_MaxSize;
			}
			set
			{
				m_MaxSize = value;
			}
		}

		public TextAnchor alignment
		{
			get
			{
				return m_Alignment;
			}
			set
			{
				m_Alignment = value;
			}
		}

		public bool alignByGeometry
		{
			get
			{
				return m_AlignByGeometry;
			}
			set
			{
				m_AlignByGeometry = value;
			}
		}

		public bool richText
		{
			get
			{
				return m_RichText;
			}
			set
			{
				m_RichText = value;
			}
		}

		public HorizontalWrapMode horizontalOverflow
		{
			get
			{
				return m_HorizontalOverflow;
			}
			set
			{
				m_HorizontalOverflow = value;
			}
		}

		public VerticalWrapMode verticalOverflow
		{
			get
			{
				return m_VerticalOverflow;
			}
			set
			{
				m_VerticalOverflow = value;
			}
		}

		public float lineSpacing
		{
			get
			{
				return m_LineSpacing;
			}
			set
			{
				m_LineSpacing = value;
			}
		}

		void ISerializationCallbackReceiver.OnBeforeSerialize()
		{
		}

		void ISerializationCallbackReceiver.OnAfterDeserialize()
		{
			m_FontSize = Mathf.Clamp(m_FontSize, 0, 300);
			m_MinSize = Mathf.Clamp(m_MinSize, 0, m_FontSize);
			m_MaxSize = Mathf.Clamp(m_MaxSize, m_FontSize, 300);
		}
	}
	public static class FontUpdateTracker
	{
		private static Dictionary<Font, HashSet<Text>> m_Tracked = new Dictionary<Font, HashSet<Text>>();

		public static void TrackText(Text t)
		{
			if (t.font == null)
			{
				return;
			}
			m_Tracked.TryGetValue(t.font, out var value);
			if (value == null)
			{
				if (m_Tracked.Count == 0)
				{
					Font.textureRebuilt += RebuildForFont;
				}
				value = new HashSet<Text>();
				m_Tracked.Add(t.font, value);
			}
			value.Add(t);
		}

		private static void RebuildForFont(Font f)
		{
			m_Tracked.TryGetValue(f, out var value);
			if (value == null)
			{
				return;
			}
			foreach (Text item in value)
			{
				item.FontTextureChanged();
			}
		}

		public static void UntrackText(Text t)
		{
			if (t.font == null)
			{
				return;
			}
			m_Tracked.TryGetValue(t.font, out var value);
			if (value == null)
			{
				return;
			}
			value.Remove(t);
			if (value.Count == 0)
			{
				m_Tracked.Remove(t.font);
				if (m_Tracked.Count == 0)
				{
					Font.textureRebuilt -= RebuildForFont;
				}
			}
		}
	}
	[DisallowMultipleComponent]
	[RequireComponent(typeof(CanvasRenderer))]
	[RequireComponent(typeof(RectTransform))]
	[ExecuteAlways]
	public abstract class Graphic : UIBehaviour, ICanvasElement
	{
		protected static Material s_DefaultUI = null;

		protected static Texture2D s_WhiteTexture = null;

		[FormerlySerializedAs("m_Mat")]
		[SerializeField]
		protected Material m_Material;

		[SerializeField]
		private Color m_Color = Color.white;

		[NonSerialized]
		protected bool m_SkipLayoutUpdate;

		[NonSerialized]
		protected bool m_SkipMaterialUpdate;

		[SerializeField]
		private bool m_RaycastTarget = true;

		[NonSerialized]
		private RectTransform m_RectTransform;

		[NonSerialized]
		private CanvasRenderer m_CanvasRenderer;

		[NonSerialized]
		private Canvas m_Canvas;

		[NonSerialized]
		private bool m_VertsDirty;

		[NonSerialized]
		private bool m_MaterialDirty;

		[NonSerialized]
		protected UnityAction m_OnDirtyLayoutCallback;

		[NonSerialized]
		protected UnityAction m_OnDirtyVertsCallback;

		[NonSerialized]
		protected UnityAction m_OnDirtyMaterialCallback;

		[NonSerialized]
		protected static Mesh s_Mesh;

		[NonSerialized]
		private static readonly VertexHelper s_VertexHelper = new VertexHelper();

		[NonSerialized]
		protected Mesh m_CachedMesh;

		[NonSerialized]
		protected Vector2[] m_CachedUvs;

		[NonSerialized]
		private readonly TweenRunner<ColorTween> m_ColorTweenRunner;

		public static Material defaultGraphicMaterial
		{
			get
			{
				if (s_DefaultUI == null)
				{
					s_DefaultUI = Canvas.GetDefaultCanvasMaterial();
				}
				return s_DefaultUI;
			}
		}

		public virtual Color color
		{
			get
			{
				return m_Color;
			}
			set
			{
				if (SetPropertyUtility.SetColor(ref m_Color, value))
				{
					SetVerticesDirty();
				}
			}
		}

		public virtual bool raycastTarget
		{
			get
			{
				return m_RaycastTarget;
			}
			set
			{
				m_RaycastTarget = value;
			}
		}

		protected bool useLegacyMeshGeneration { get; set; }

		public int depth => canvasRenderer.absoluteDepth;

		public RectTransform rectTransform
		{
			get
			{
				if ((object)m_RectTransform == null)
				{
					m_RectTransform = GetComponent<RectTransform>();
				}
				return m_RectTransform;
			}
		}

		public Canvas canvas
		{
			get
			{
				if (m_Canvas == null)
				{
					CacheCanvas();
				}
				return m_Canvas;
			}
		}

		public CanvasRenderer canvasRenderer
		{
			get
			{
				if ((object)m_CanvasRenderer == null)
				{
					m_CanvasRenderer = GetComponent<CanvasRenderer>();
				}
				return m_CanvasRenderer;
			}
		}

		public virtual Material defaultMaterial => defaultGraphicMaterial;

		public virtual Material material
		{
			get
			{
				if (!(m_Material != null))
				{
					return defaultMaterial;
				}
				return m_Material;
			}
			set
			{
				if (!(m_Material == value))
				{
					m_Material = value;
					SetMaterialDirty();
				}
			}
		}

		public virtual Material materialForRendering
		{
			get
			{
				List<Component> list = ListPool<Component>.Get();
				GetComponents(typeof(IMaterialModifier), list);
				Material modifiedMaterial = material;
				for (int i = 0; i < list.Count; i++)
				{
					modifiedMaterial = (list[i] as IMaterialModifier).GetModifiedMaterial(modifiedMaterial);
				}
				ListPool<Component>.Release(list);
				return modifiedMaterial;
			}
		}

		public virtual Texture mainTexture => s_WhiteTexture;

		protected static Mesh workerMesh
		{
			get
			{
				if (s_Mesh == null)
				{
					s_Mesh = new Mesh();
					s_Mesh.name = "Shared UI Mesh";
					s_Mesh.hideFlags = HideFlags.HideAndDontSave;
				}
				return s_Mesh;
			}
		}

		protected Graphic()
		{
			if (m_ColorTweenRunner == null)
			{
				m_ColorTweenRunner = new TweenRunner<ColorTween>();
			}
			m_ColorTweenRunner.Init(this);
			useLegacyMeshGeneration = true;
		}

		public virtual void SetAllDirty()
		{
			if (m_SkipLayoutUpdate)
			{
				m_SkipLayoutUpdate = false;
			}
			else
			{
				SetLayoutDirty();
			}
			if (m_SkipMaterialUpdate)
			{
				m_SkipMaterialUpdate = false;
			}
			else
			{
				SetMaterialDirty();
			}
			SetVerticesDirty();
		}

		public virtual void SetLayoutDirty()
		{
			if (IsActive())
			{
				LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
				if (m_OnDirtyLayoutCallback != null)
				{
					m_OnDirtyLayoutCallback();
				}
			}
		}

		public virtual void SetVerticesDirty()
		{
			if (IsActive())
			{
				m_VertsDirty = true;
				CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);
				if (m_OnDirtyVertsCallback != null)
				{
					m_OnDirtyVertsCallback();
				}
			}
		}

		public virtual void SetMaterialDirty()
		{
			if (IsActive())
			{
				m_MaterialDirty = true;
				CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);
				if (m_OnDirtyMaterialCallback != null)
				{
					m_OnDirtyMaterialCallback();
				}
			}
		}

		protected override void OnRectTransformDimensionsChange()
		{
			if (base.gameObject.activeInHierarchy)
			{
				if (CanvasUpdateRegistry.IsRebuildingLayout())
				{
					SetVerticesDirty();
					return;
				}
				SetVerticesDirty();
				SetLayoutDirty();
			}
		}

		protected override void OnBeforeTransformParentChanged()
		{
			GraphicRegistry.UnregisterGraphicForCanvas(canvas, this);
			LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
		}

		protected override void OnTransformParentChanged()
		{
			base.OnTransformParentChanged();
			m_Canvas = null;
			if (IsActive())
			{
				CacheCanvas();
				GraphicRegistry.RegisterGraphicForCanvas(canvas, this);
				SetAllDirty();
			}
		}

		private void CacheCanvas()
		{
			List<Canvas> list = ListPool<Canvas>.Get();
			base.gameObject.GetComponentsInParent(includeInactive: false, list);
			if (list.Count > 0)
			{
				for (int i = 0; i < list.Count; i++)
				{
					if (list[i].isActiveAndEnabled)
					{
						m_Canvas = list[i];
						break;
					}
				}
			}
			else
			{
				m_Canvas = null;
			}
			ListPool<Canvas>.Release(list);
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			CacheCanvas();
			GraphicRegistry.RegisterGraphicForCanvas(canvas, this);
			if (s_WhiteTexture == null)
			{
				s_WhiteTexture = Texture2D.whiteTexture;
			}
			SetAllDirty();
		}

		protected override void OnDisable()
		{
			GraphicRegistry.UnregisterGraphicForCanvas(canvas, this);
			CanvasUpdateRegistry.UnRegisterCanvasElementForRebuild(this);
			if (canvasRenderer != null)
			{
				canvasRenderer.Clear();
			}
			LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
			base.OnDisable();
		}

		protected override void OnDestroy()
		{
			if ((bool)m_CachedMesh)
			{
				Object.Destroy(m_CachedMesh);
			}
			m_CachedMesh = null;
			base.OnDestroy();
		}

		protected override void OnCanvasHierarchyChanged()
		{
			Canvas canvas = m_Canvas;
			m_Canvas = null;
			if (!IsActive())
			{
				return;
			}
			CacheCanvas();
			if (canvas != m_Canvas)
			{
				GraphicRegistry.UnregisterGraphicForCanvas(canvas, this);
				if (IsActive())
				{
					GraphicRegistry.RegisterGraphicForCanvas(this.canvas, this);
				}
			}
		}

		public virtual void OnCullingChanged()
		{
			if (!canvasRenderer.cull && (m_VertsDirty || m_MaterialDirty))
			{
				CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);
			}
		}

		public virtual void Rebuild(CanvasUpdate update)
		{
			if (!(canvasRenderer == null) && !canvasRenderer.cull && update == CanvasUpdate.PreRender)
			{
				if (m_VertsDirty)
				{
					UpdateGeometry();
					m_VertsDirty = false;
				}
				if (m_MaterialDirty)
				{
					UpdateMaterial();
					m_MaterialDirty = false;
				}
			}
		}

		public virtual void LayoutComplete()
		{
		}

		public virtual void GraphicUpdateComplete()
		{
		}

		protected virtual void UpdateMaterial()
		{
			if (IsActive())
			{
				canvasRenderer.materialCount = 1;
				canvasRenderer.SetMaterial(materialForRendering, 0);
				canvasRenderer.SetTexture(mainTexture);
			}
		}

		protected virtual void UpdateGeometry()
		{
			if (useLegacyMeshGeneration)
			{
				DoLegacyMeshGeneration();
			}
			else
			{
				DoMeshGeneration();
			}
		}

		private void DoMeshGeneration()
		{
			if (rectTransform != null && rectTransform.rect.width >= 0f && rectTransform.rect.height >= 0f)
			{
				OnPopulateMesh(s_VertexHelper);
			}
			else
			{
				s_VertexHelper.Clear();
			}
			List<Component> list = ListPool<Component>.Get();
			GetComponents(typeof(IMeshModifier), list);
			for (int i = 0; i < list.Count; i++)
			{
				((IMeshModifier)list[i]).ModifyMesh(s_VertexHelper);
			}
			ListPool<Component>.Release(list);
			s_VertexHelper.FillMesh(workerMesh);
			canvasRenderer.SetMesh(workerMesh);
		}

		private void DoLegacyMeshGeneration()
		{
			if (rectTransform != null && rectTransform.rect.width >= 0f && rectTransform.rect.height >= 0f)
			{
				OnPopulateMesh(workerMesh);
			}
			else
			{
				workerMesh.Clear();
			}
			List<Component> list = ListPool<Component>.Get();
			GetComponents(typeof(IMeshModifier), list);
			for (int i = 0; i < list.Count; i++)
			{
				((IMeshModifier)list[i]).ModifyMesh(workerMesh);
			}
			ListPool<Component>.Release(list);
			canvasRenderer.SetMesh(workerMesh);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use OnPopulateMesh instead.", true)]
		protected virtual void OnFillVBO(List<UIVertex> vbo)
		{
		}

		[Obsolete("Use OnPopulateMesh(VertexHelper vh) instead.", false)]
		protected virtual void OnPopulateMesh(Mesh m)
		{
			OnPopulateMesh(s_VertexHelper);
			s_VertexHelper.FillMesh(m);
		}

		protected virtual void OnPopulateMesh(VertexHelper vh)
		{
			Rect pixelAdjustedRect = GetPixelAdjustedRect();
			Vector4 vector = new Vector4(pixelAdjustedRect.x, pixelAdjustedRect.y, pixelAdjustedRect.x + pixelAdjustedRect.width, pixelAdjustedRect.y + pixelAdjustedRect.height);
			Color32 color = this.color;
			vh.Clear();
			vh.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			vh.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			vh.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			vh.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			vh.AddTriangle(0, 1, 2);
			vh.AddTriangle(2, 3, 0);
		}

		protected override void OnDidApplyAnimationProperties()
		{
			SetAllDirty();
		}

		public virtual void SetNativeSize()
		{
		}

		public virtual bool Raycast(Vector2 sp, Camera eventCamera)
		{
			if (!base.isActiveAndEnabled)
			{
				return false;
			}
			Transform transform = base.transform;
			List<Component> list = ListPool<Component>.Get();
			bool flag = false;
			bool flag2 = true;
			while (transform != null)
			{
				transform.GetComponents(list);
				for (int i = 0; i < list.Count; i++)
				{
					Canvas canvas = list[i] as Canvas;
					if (canvas != null && canvas.overrideSorting)
					{
						flag2 = false;
					}
					if (!(list[i] is ICanvasRaycastFilter canvasRaycastFilter))
					{
						continue;
					}
					bool flag3 = true;
					CanvasGroup canvasGroup = list[i] as CanvasGroup;
					if (canvasGroup != null)
					{
						if (!flag && canvasGroup.ignoreParentGroups)
						{
							flag = true;
							flag3 = canvasRaycastFilter.IsRaycastLocationValid(sp, eventCamera);
						}
						else if (!flag)
						{
							flag3 = canvasRaycastFilter.IsRaycastLocationValid(sp, eventCamera);
						}
					}
					else
					{
						flag3 = canvasRaycastFilter.IsRaycastLocationValid(sp, eventCamera);
					}
					if (!flag3)
					{
						ListPool<Component>.Release(list);
						return false;
					}
				}
				transform = (flag2 ? transform.parent : null);
			}
			ListPool<Component>.Release(list);
			return true;
		}

		public Vector2 PixelAdjustPoint(Vector2 point)
		{
			if (!canvas || canvas.renderMode == RenderMode.WorldSpace || canvas.scaleFactor == 0f || !canvas.pixelPerfect)
			{
				return point;
			}
			return RectTransformUtility.PixelAdjustPoint(point, base.transform, canvas);
		}

		public Rect GetPixelAdjustedRect()
		{
			if (!canvas || canvas.renderMode == RenderMode.WorldSpace || canvas.scaleFactor == 0f || !canvas.pixelPerfect)
			{
				return rectTransform.rect;
			}
			return RectTransformUtility.PixelAdjustRect(rectTransform, canvas);
		}

		public virtual void CrossFadeColor(Color targetColor, float duration, bool ignoreTimeScale, bool useAlpha)
		{
			CrossFadeColor(targetColor, duration, ignoreTimeScale, useAlpha, useRGB: true);
		}

		public virtual void CrossFadeColor(Color targetColor, float duration, bool ignoreTimeScale, bool useAlpha, bool useRGB)
		{
			if (!(canvasRenderer == null) && (useRGB || useAlpha))
			{
				if (canvasRenderer.GetColor().Equals(targetColor))
				{
					m_ColorTweenRunner.StopTween();
					return;
				}
				ColorTween.ColorTweenMode tweenMode = ((!(useRGB && useAlpha)) ? (useRGB ? ColorTween.ColorTweenMode.RGB : ColorTween.ColorTweenMode.Alpha) : ColorTween.ColorTweenMode.All);
				ColorTween info = new ColorTween
				{
					duration = duration,
					startColor = canvasRenderer.GetColor(),
					targetColor = targetColor
				};
				info.AddOnChangedCallback(canvasRenderer.SetColor);
				info.ignoreTimeScale = ignoreTimeScale;
				info.tweenMode = tweenMode;
				m_ColorTweenRunner.StartTween(info);
			}
		}

		private static Color CreateColorFromAlpha(float alpha)
		{
			Color black = Color.black;
			black.a = alpha;
			return black;
		}

		public virtual void CrossFadeAlpha(float alpha, float duration, bool ignoreTimeScale)
		{
			CrossFadeColor(CreateColorFromAlpha(alpha), duration, ignoreTimeScale, useAlpha: true, useRGB: false);
		}

		public void RegisterDirtyLayoutCallback(UnityAction action)
		{
			m_OnDirtyLayoutCallback = (UnityAction)Delegate.Combine(m_OnDirtyLayoutCallback, action);
		}

		public void UnregisterDirtyLayoutCallback(UnityAction action)
		{
			m_OnDirtyLayoutCallback = (UnityAction)Delegate.Remove(m_OnDirtyLayoutCallback, action);
		}

		public void RegisterDirtyVerticesCallback(UnityAction action)
		{
			m_OnDirtyVertsCallback = (UnityAction)Delegate.Combine(m_OnDirtyVertsCallback, action);
		}

		public void UnregisterDirtyVerticesCallback(UnityAction action)
		{
			m_OnDirtyVertsCallback = (UnityAction)Delegate.Remove(m_OnDirtyVertsCallback, action);
		}

		public void RegisterDirtyMaterialCallback(UnityAction action)
		{
			m_OnDirtyMaterialCallback = (UnityAction)Delegate.Combine(m_OnDirtyMaterialCallback, action);
		}

		public void UnregisterDirtyMaterialCallback(UnityAction action)
		{
			m_OnDirtyMaterialCallback = (UnityAction)Delegate.Remove(m_OnDirtyMaterialCallback, action);
		}

		Transform ICanvasElement.get_transform()
		{
			return base.transform;
		}
	}
	[AddComponentMenu("Event/Graphic Raycaster")]
	[RequireComponent(typeof(Canvas))]
	public class GraphicRaycaster : BaseRaycaster
	{
		public enum BlockingObjects
		{
			None,
			TwoD,
			ThreeD,
			All
		}

		protected const int kNoEventMaskSet = -1;

		[FormerlySerializedAs("ignoreReversedGraphics")]
		[SerializeField]
		private bool m_IgnoreReversedGraphics = true;

		[FormerlySerializedAs("blockingObjects")]
		[SerializeField]
		private BlockingObjects m_BlockingObjects;

		[SerializeField]
		protected LayerMask m_BlockingMask = -1;

		private Canvas m_Canvas;

		[NonSerialized]
		private List<Graphic> m_RaycastResults = new List<Graphic>();

		[NonSerialized]
		private static readonly List<Graphic> s_SortedGraphics = new List<Graphic>();

		public override int sortOrderPriority
		{
			get
			{
				if (canvas.renderMode == RenderMode.ScreenSpaceOverlay)
				{
					return canvas.sortingOrder;
				}
				return base.sortOrderPriority;
			}
		}

		public override int renderOrderPriority
		{
			get
			{
				if (canvas.renderMode == RenderMode.ScreenSpaceOverlay)
				{
					return canvas.rootCanvas.renderOrder;
				}
				return base.renderOrderPriority;
			}
		}

		public bool ignoreReversedGraphics
		{
			get
			{
				return m_IgnoreReversedGraphics;
			}
			set
			{
				m_IgnoreReversedGraphics = value;
			}
		}

		public BlockingObjects blockingObjects
		{
			get
			{
				return m_BlockingObjects;
			}
			set
			{
				m_BlockingObjects = value;
			}
		}

		private Canvas canvas
		{
			get
			{
				if (m_Canvas != null)
				{
					return m_Canvas;
				}
				m_Canvas = GetComponent<Canvas>();
				return m_Canvas;
			}
		}

		public override Camera eventCamera
		{
			get
			{
				if (canvas.renderMode == RenderMode.ScreenSpaceOverlay || (canvas.renderMode == RenderMode.ScreenSpaceCamera && canvas.worldCamera == null))
				{
					return null;
				}
				if (!(canvas.worldCamera != null))
				{
					return Camera.main;
				}
				return canvas.worldCamera;
			}
		}

		protected GraphicRaycaster()
		{
		}

		public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
		{
			if (canvas == null)
			{
				return;
			}
			IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(canvas);
			if (graphicsForCanvas == null || graphicsForCanvas.Count == 0)
			{
				return;
			}
			Camera camera = eventCamera;
			int num = ((canvas.renderMode != RenderMode.ScreenSpaceOverlay && !(camera == null)) ? camera.targetDisplay : canvas.targetDisplay);
			Vector3 vector = Display.RelativeMouseAt(eventData.position);
			if (vector != Vector3.zero)
			{
				if ((int)vector.z != num)
				{
					return;
				}
			}
			else
			{
				vector = eventData.position;
			}
			Vector2 vector2;
			if (camera == null)
			{
				float num2 = Screen.width;
				float num3 = Screen.height;
				if (num > 0 && num < Display.displays.Length)
				{
					num2 = Display.displays[num].systemWidth;
					num3 = Display.displays[num].systemHeight;
				}
				vector2 = new Vector2(vector.x / num2, vector.y / num3);
			}
			else
			{
				vector2 = camera.ScreenToViewportPoint(vector);
			}
			if (vector2.x < 0f || vector2.x > 1f || vector2.y < 0f || vector2.y > 1f)
			{
				return;
			}
			float num4 = float.MaxValue;
			Ray r = default(Ray);
			if (camera != null)
			{
				r = camera.ScreenPointToRay(vector);
			}
			if (canvas.renderMode != RenderMode.ScreenSpaceOverlay && blockingObjects != BlockingObjects.None)
			{
				float f = 100f;
				if (camera != null)
				{
					float z = r.direction.z;
					f = (Mathf.Approximately(0f, z) ? float.PositiveInfinity : Mathf.Abs((camera.farClipPlane - camera.nearClipPlane) / z));
				}
				if ((blockingObjects == BlockingObjects.ThreeD || blockingObjects == BlockingObjects.All) && ReflectionMethodsCache.Singleton.raycast3D != null)
				{
					RaycastHit[] array = ReflectionMethodsCache.Singleton.raycast3DAll(r, f, m_BlockingMask);
					if (array.Length != 0)
					{
						num4 = array[0].distance;
					}
				}
				if ((blockingObjects == BlockingObjects.TwoD || blockingObjects == BlockingObjects.All) && ReflectionMethodsCache.Singleton.raycast2D != null)
				{
					RaycastHit2D[] array2 = ReflectionMethodsCache.Singleton.getRayIntersectionAll(r, f, m_BlockingMask);
					if (array2.Length != 0)
					{
						num4 = array2[0].distance;
					}
				}
			}
			m_RaycastResults.Clear();
			Raycast(canvas, camera, vector, graphicsForCanvas, m_RaycastResults);
			int count = m_RaycastResults.Count;
			for (int i = 0; i < count; i++)
			{
				GameObject gameObject = m_RaycastResults[i].gameObject;
				bool flag = true;
				if (ignoreReversedGraphics)
				{
					if (camera == null)
					{
						Vector3 rhs = gameObject.transform.rotation * Vector3.forward;
						flag = Vector3.Dot(Vector3.forward, rhs) > 0f;
					}
					else
					{
						Vector3 lhs = camera.transform.rotation * Vector3.forward;
						Vector3 rhs2 = gameObject.transform.rotation * Vector3.forward;
						flag = Vector3.Dot(lhs, rhs2) > 0f;
					}
				}
				if (!flag)
				{
					continue;
				}
				float num5 = 0f;
				Transform transform = gameObject.transform;
				Vector3 forward = transform.forward;
				if (camera == null || canvas.renderMode == RenderMode.ScreenSpaceOverlay)
				{
					num5 = 0f;
				}
				else
				{
					num5 = Vector3.Dot(forward, transform.position - r.origin) / Vector3.Dot(forward, r.direction);
					if (num5 < 0f)
					{
						continue;
					}
				}
				if (!(num5 >= num4))
				{
					RaycastResult item = new RaycastResult
					{
						gameObject = gameObject,
						module = this,
						distance = num5,
						screenPosition = vector,
						index = resultAppendList.Count,
						depth = m_RaycastResults[i].depth,
						sortingLayer = canvas.sortingLayerID,
						sortingOrder = canvas.sortingOrder,
						worldPosition = r.origin + r.direction * num5,
						worldNormal = -forward
					};
					resultAppendList.Add(item);
				}
			}
		}

		private static void Raycast(Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList<Graphic> foundGraphics, List<Graphic> results)
		{
			int count = foundGraphics.Count;
			for (int i = 0; i < count; i++)
			{
				Graphic graphic = foundGraphics[i];
				if (graphic.depth != -1 && graphic.raycastTarget && !graphic.canvasRenderer.cull && RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, pointerPosition, eventCamera) && (!(eventCamera != null) || !(eventCamera.WorldToScreenPoint(graphic.rectTransform.position).z > eventCamera.farClipPlane)) && graphic.Raycast(pointerPosition, eventCamera))
				{
					s_SortedGraphics.Add(graphic);
				}
			}
			s_SortedGraphics.Sort((Graphic g1, Graphic g2) => g2.depth.CompareTo(g1.depth));
			count = s_SortedGraphics.Count;
			for (int num = 0; num < count; num++)
			{
				results.Add(s_SortedGraphics[num]);
			}
			s_SortedGraphics.Clear();
		}
	}
	public class GraphicRegistry
	{
		private static GraphicRegistry s_Instance;

		private readonly Dictionary<Canvas, IndexedSet<Graphic>> m_Graphics = new Dictionary<Canvas, IndexedSet<Graphic>>();

		private static readonly List<Graphic> s_EmptyList = new List<Graphic>();

		public static GraphicRegistry instance
		{
			get
			{
				if (s_Instance == null)
				{
					s_Instance = new GraphicRegistry();
				}
				return s_Instance;
			}
		}

		protected GraphicRegistry()
		{
			GC.KeepAlive(new Dictionary<Graphic, int>());
			GC.KeepAlive(new Dictionary<ICanvasElement, int>());
			GC.KeepAlive(new Dictionary<IClipper, int>());
		}

		public static void RegisterGraphicForCanvas(Canvas c, Graphic graphic)
		{
			if (!(c == null))
			{
				instance.m_Graphics.TryGetValue(c, out var value);
				if (value != null)
				{
					value.AddUnique(graphic);
					return;
				}
				value = new IndexedSet<Graphic>();
				value.Add(graphic);
				instance.m_Graphics.Add(c, value);
			}
		}

		public static void UnregisterGraphicForCanvas(Canvas c, Graphic graphic)
		{
			if (!(c == null) && instance.m_Graphics.TryGetValue(c, out var value))
			{
				value.Remove(graphic);
				if (value.Count == 0)
				{
					instance.m_Graphics.Remove(c);
				}
			}
		}

		public static IList<Graphic> GetGraphicsForCanvas(Canvas canvas)
		{
			if (instance.m_Graphics.TryGetValue(canvas, out var value))
			{
				return value;
			}
			return s_EmptyList;
		}
	}
	[Obsolete("Not supported anymore")]
	internal interface IGraphicEnabledDisabled
	{
		void OnSiblingGraphicEnabledDisabled();
	}
	[AddComponentMenu("UI/Image", 11)]
	public class Image : MaskableGraphic, ISerializationCallbackReceiver, ILayoutElement, ICanvasRaycastFilter
	{
		public enum Type
		{
			Simple,
			Sliced,
			Tiled,
			Filled
		}

		public enum FillMethod
		{
			Horizontal,
			Vertical,
			Radial90,
			Radial180,
			Radial360
		}

		public enum OriginHorizontal
		{
			Left,
			Right
		}

		public enum OriginVertical
		{
			Bottom,
			Top
		}

		public enum Origin90
		{
			BottomLeft,
			TopLeft,
			TopRight,
			BottomRight
		}

		public enum Origin180
		{
			Bottom,
			Left,
			Top,
			Right
		}

		public enum Origin360
		{
			Bottom,
			Right,
			Top,
			Left
		}

		protected static Material s_ETC1DefaultUI = null;

		[FormerlySerializedAs("m_Frame")]
		[SerializeField]
		private Sprite m_Sprite;

		[NonSerialized]
		private Sprite m_OverrideSprite;

		[SerializeField]
		private Type m_Type;

		[SerializeField]
		private bool m_PreserveAspect;

		[SerializeField]
		private bool m_FillCenter = true;

		[SerializeField]
		private FillMethod m_FillMethod = FillMethod.Radial360;

		[Range(0f, 1f)]
		[SerializeField]
		private float m_FillAmount = 1f;

		[SerializeField]
		private bool m_FillClockwise = true;

		[SerializeField]
		private int m_FillOrigin;

		private float m_AlphaHitTestMinimumThreshold;

		private bool m_Tracked;

		[SerializeField]
		private bool m_UseSpriteMesh;

		[SerializeField]
		private float m_PixelsPerUnitMultiplier = 1f;

		private float m_CachedReferencePixelsPerUnit = 100f;

		private static readonly Vector2[] s_VertScratch = new Vector2[4];

		private static readonly Vector2[] s_UVScratch = new Vector2[4];

		private static readonly Vector3[] s_Xy = new Vector3[4];

		private static readonly Vector3[] s_Uv = new Vector3[4];

		private static List<Image> m_TrackedTexturelessImages = new List<Image>();

		private static bool s_Initialized;

		public Sprite sprite
		{
			get
			{
				return m_Sprite;
			}
			set
			{
				if (m_Sprite != null)
				{
					if (m_Sprite != value)
					{
						m_SkipLayoutUpdate = m_Sprite.rect.size.Equals(value ? value.rect.size : Vector2.zero);
						m_SkipMaterialUpdate = m_Sprite.texture == (value ? value.texture : null);
						m_Sprite = value;
						SetAllDirty();
						TrackSprite();
					}
				}
				else if (value != null)
				{
					m_SkipLayoutUpdate = value.rect.size == Vector2.zero;
					m_SkipMaterialUpdate = value.texture == null;
					m_Sprite = value;
					SetAllDirty();
					TrackSprite();
				}
			}
		}

		public Sprite overrideSprite
		{
			get
			{
				return activeSprite;
			}
			set
			{
				if (SetPropertyUtility.SetClass(ref m_OverrideSprite, value))
				{
					SetAllDirty();
					TrackSprite();
				}
			}
		}

		private Sprite activeSprite
		{
			get
			{
				if (!(m_OverrideSprite != null))
				{
					return sprite;
				}
				return m_OverrideSprite;
			}
		}

		public Type type
		{
			get
			{
				return m_Type;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_Type, value))
				{
					SetVerticesDirty();
				}
			}
		}

		public bool preserveAspect
		{
			get
			{
				return m_PreserveAspect;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_PreserveAspect, value))
				{
					SetVerticesDirty();
				}
			}
		}

		public bool fillCenter
		{
			get
			{
				return m_FillCenter;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_FillCenter, value))
				{
					SetVerticesDirty();
				}
			}
		}

		public FillMethod fillMethod
		{
			get
			{
				return m_FillMethod;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_FillMethod, value))
				{
					SetVerticesDirty();
					m_FillOrigin = 0;
				}
			}
		}

		public float fillAmount
		{
			get
			{
				return m_FillAmount;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_FillAmount, Mathf.Clamp01(value)))
				{
					SetVerticesDirty();
				}
			}
		}

		public bool fillClockwise
		{
			get
			{
				return m_FillClockwise;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_FillClockwise, value))
				{
					SetVerticesDirty();
				}
			}
		}

		public int fillOrigin
		{
			get
			{
				return m_FillOrigin;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_FillOrigin, value))
				{
					SetVerticesDirty();
				}
			}
		}

		[Obsolete("eventAlphaThreshold has been deprecated. Use eventMinimumAlphaThreshold instead (UnityUpgradable) -> alphaHitTestMinimumThreshold")]
		public float eventAlphaThreshold
		{
			get
			{
				return 1f - alphaHitTestMinimumThreshold;
			}
			set
			{
				alphaHitTestMinimumThreshold = 1f - value;
			}
		}

		public float alphaHitTestMinimumThreshold
		{
			get
			{
				return m_AlphaHitTestMinimumThreshold;
			}
			set
			{
				m_AlphaHitTestMinimumThreshold = value;
			}
		}

		public bool useSpriteMesh
		{
			get
			{
				return m_UseSpriteMesh;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_UseSpriteMesh, value))
				{
					SetVerticesDirty();
				}
			}
		}

		public static Material defaultETC1GraphicMaterial
		{
			get
			{
				if (s_ETC1DefaultUI == null)
				{
					s_ETC1DefaultUI = Canvas.GetETC1SupportedCanvasMaterial();
				}
				return s_ETC1DefaultUI;
			}
		}

		public override Texture mainTexture
		{
			get
			{
				if (activeSprite == null)
				{
					if (material != null && material.mainTexture != null)
					{
						return material.mainTexture;
					}
					return Graphic.s_WhiteTexture;
				}
				return activeSprite.texture;
			}
		}

		public bool hasBorder
		{
			get
			{
				if (activeSprite != null)
				{
					return activeSprite.border.sqrMagnitude > 0f;
				}
				return false;
			}
		}

		public float pixelsPerUnitMultiplier
		{
			get
			{
				return m_PixelsPerUnitMultiplier;
			}
			set
			{
				m_PixelsPerUnitMultiplier = Mathf.Max(0.01f, value);
			}
		}

		public float pixelsPerUnit
		{
			get
			{
				float num = 100f;
				if ((bool)activeSprite)
				{
					num = activeSprite.pixelsPerUnit;
				}
				if ((bool)base.canvas)
				{
					m_CachedReferencePixelsPerUnit = base.canvas.referencePixelsPerUnit;
				}
				return num / m_CachedReferencePixelsPerUnit;
			}
		}

		protected float multipliedPixelsPerUnit => pixelsPerUnit * m_PixelsPerUnitMultiplier;

		public override Material material
		{
			get
			{
				if (m_Material != null)
				{
					return m_Material;
				}
				if ((bool)activeSprite && activeSprite.associatedAlphaSplitTexture != null)
				{
					return defaultETC1GraphicMaterial;
				}
				return defaultMaterial;
			}
			set
			{
				base.material = value;
			}
		}

		public virtual float minWidth => 0f;

		public virtual float preferredWidth
		{
			get
			{
				if (activeSprite == null)
				{
					return 0f;
				}
				if (type == Type.Sliced || type == Type.Tiled)
				{
					return DataUtility.GetMinSize(activeSprite).x / pixelsPerUnit;
				}
				return activeSprite.rect.size.x / pixelsPerUnit;
			}
		}

		public virtual float flexibleWidth => -1f;

		public virtual float minHeight => 0f;

		public virtual float preferredHeight
		{
			get
			{
				if (activeSprite == null)
				{
					return 0f;
				}
				if (type == Type.Sliced || type == Type.Tiled)
				{
					return DataUtility.GetMinSize(activeSprite).y / pixelsPerUnit;
				}
				return activeSprite.rect.size.y / pixelsPerUnit;
			}
		}

		public virtual float flexibleHeight => -1f;

		public virtual int layoutPriority => 0;

		public void DisableSpriteOptimizations()
		{
			m_SkipLayoutUpdate = false;
			m_SkipMaterialUpdate = false;
		}

		protected Image()
		{
			base.useLegacyMeshGeneration = false;
		}

		public virtual void OnBeforeSerialize()
		{
		}

		public virtual void OnAfterDeserialize()
		{
			if (m_FillOrigin < 0)
			{
				m_FillOrigin = 0;
			}
			else if (m_FillMethod == FillMethod.Horizontal && m_FillOrigin > 1)
			{
				m_FillOrigin = 0;
			}
			else if (m_FillMethod == FillMethod.Vertical && m_FillOrigin > 1)
			{
				m_FillOrigin = 0;
			}
			else if (m_FillOrigin > 3)
			{
				m_FillOrigin = 0;
			}
			m_FillAmount = Mathf.Clamp(m_FillAmount, 0f, 1f);
		}

		private void PreserveSpriteAspectRatio(ref Rect rect, Vector2 spriteSize)
		{
			float num = spriteSize.x / spriteSize.y;
			float num2 = rect.width / rect.height;
			if (num > num2)
			{
				float height = rect.height;
				rect.height = rect.width * (1f / num);
				rect.y += (height - rect.height) * base.rectTransform.pivot.y;
			}
			else
			{
				float width = rect.width;
				rect.width = rect.height * num;
				rect.x += (width - rect.width) * base.rectTransform.pivot.x;
			}
		}

		private Vector4 GetDrawingDimensions(bool shouldPreserveAspect)
		{
			Vector4 vector = ((activeSprite == null) ? Vector4.zero : DataUtility.GetPadding(activeSprite));
			Vector2 spriteSize = ((activeSprite == null) ? Vector2.zero : new Vector2(activeSprite.rect.width, activeSprite.rect.height));
			Rect rect = GetPixelAdjustedRect();
			int num = Mathf.RoundToInt(spriteSize.x);
			int num2 = Mathf.RoundToInt(spriteSize.y);
			Vector4 vector2 = new Vector4(vector.x / (float)num, vector.y / (float)num2, ((float)num - vector.z) / (float)num, ((float)num2 - vector.w) / (float)num2);
			if (shouldPreserveAspect && spriteSize.sqrMagnitude > 0f)
			{
				PreserveSpriteAspectRatio(ref rect, spriteSize);
			}
			return new Vector4(rect.x + rect.width * vector2.x, rect.y + rect.height * vector2.y, rect.x + rect.width * vector2.z, rect.y + rect.height * vector2.w);
		}

		public override void SetNativeSize()
		{
			if (activeSprite != null)
			{
				float x = activeSprite.rect.width / pixelsPerUnit;
				float y = activeSprite.rect.height / pixelsPerUnit;
				base.rectTransform.anchorMax = base.rectTransform.anchorMin;
				base.rectTransform.sizeDelta = new Vector2(x, y);
				SetAllDirty();
			}
		}

		protected override void OnRectTransformDimensionsChange()
		{
			base.OnRectTransformDimensionsChange();
			DisableSpriteOptimizations();
		}

		protected override void OnTransformParentChanged()
		{
			base.OnTransformParentChanged();
			DisableSpriteOptimizations();
		}

		protected override void OnPopulateMesh(VertexHelper toFill)
		{
			if (activeSprite == null)
			{
				base.OnPopulateMesh(toFill);
				return;
			}
			switch (type)
			{
			case Type.Simple:
				if (!useSpriteMesh)
				{
					GenerateSimpleSprite(toFill, m_PreserveAspect);
				}
				else
				{
					GenerateSprite(toFill, m_PreserveAspect);
				}
				break;
			case Type.Sliced:
				GenerateSlicedSprite(toFill);
				break;
			case Type.Tiled:
				GenerateTiledSprite(toFill);
				break;
			case Type.Filled:
				GenerateFilledSprite(toFill, m_PreserveAspect);
				break;
			}
		}

		private void TrackSprite()
		{
			if (activeSprite != null && activeSprite.texture == null)
			{
				TrackImage(this);
				m_Tracked = true;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			TrackSprite();
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			if (m_Tracked)
			{
				UnTrackImage(this);
			}
		}

		protected override void UpdateMaterial()
		{
			base.UpdateMaterial();
			if (activeSprite == null)
			{
				base.canvasRenderer.SetAlphaTexture(null);
				return;
			}
			Texture2D associatedAlphaSplitTexture = activeSprite.associatedAlphaSplitTexture;
			if (associatedAlphaSplitTexture != null)
			{
				base.canvasRenderer.SetAlphaTexture(associatedAlphaSplitTexture);
			}
		}

		protected override void OnCanvasHierarchyChanged()
		{
			base.OnCanvasHierarchyChanged();
			if (base.canvas == null)
			{
				m_CachedReferencePixelsPerUnit = 100f;
			}
			else if (base.canvas.referencePixelsPerUnit != m_CachedReferencePixelsPerUnit)
			{
				m_CachedReferencePixelsPerUnit = base.canvas.referencePixelsPerUnit;
				if (type == Type.Sliced || type == Type.Tiled)
				{
					SetVerticesDirty();
					SetLayoutDirty();
				}
			}
		}

		private void GenerateSimpleSprite(VertexHelper vh, bool lPreserveAspect)
		{
			Vector4 drawingDimensions = GetDrawingDimensions(lPreserveAspect);
			Vector4 vector = ((activeSprite != null) ? DataUtility.GetOuterUV(activeSprite) : Vector4.zero);
			Color color = this.color;
			vh.Clear();
			vh.AddVert(new Vector3(drawingDimensions.x, drawingDimensions.y), color, new Vector2(vector.x, vector.y));
			vh.AddVert(new Vector3(drawingDimensions.x, drawingDimensions.w), color, new Vector2(vector.x, vector.w));
			vh.AddVert(new Vector3(drawingDimensions.z, drawingDimensions.w), color, new Vector2(vector.z, vector.w));
			vh.AddVert(new Vector3(drawingDimensions.z, drawingDimensions.y), color, new Vector2(vector.z, vector.y));
			vh.AddTriangle(0, 1, 2);
			vh.AddTriangle(2, 3, 0);
		}

		private void GenerateSprite(VertexHelper vh, bool lPreserveAspect)
		{
			Vector2 vector = new Vector2(activeSprite.rect.width, activeSprite.rect.height);
			Vector2 vector2 = activeSprite.pivot / vector;
			Vector2 pivot = base.rectTransform.pivot;
			Rect rect = GetPixelAdjustedRect();
			if (lPreserveAspect & (vector.sqrMagnitude > 0f))
			{
				PreserveSpriteAspectRatio(ref rect, vector);
			}
			Vector2 vector3 = new Vector2(rect.width, rect.height);
			Vector3 size = activeSprite.bounds.size;
			Vector2 vector4 = (pivot - vector2) * vector3;
			Color color = this.color;
			vh.Clear();
			Vector2[] vertices = activeSprite.vertices;
			Vector2[] uv = activeSprite.uv;
			for (int i = 0; i < vertices.Length; i++)
			{
				vh.AddVert(new Vector3(vertices[i].x / size.x * vector3.x - vector4.x, vertices[i].y / size.y * vector3.y - vector4.y), color, new Vector2(uv[i].x, uv[i].y));
			}
			ushort[] triangles = activeSprite.triangles;
			for (int j = 0; j < triangles.Length; j += 3)
			{
				vh.AddTriangle(triangles[j], triangles[j + 1], triangles[j + 2]);
			}
		}

		private void GenerateSlicedSprite(VertexHelper toFill)
		{
			if (!hasBorder)
			{
				GenerateSimpleSprite(toFill, lPreserveAspect: false);
				return;
			}
			Vector4 vector;
			Vector4 vector2;
			Vector4 vector3;
			Vector4 vector4;
			if (activeSprite != null)
			{
				vector = DataUtility.GetOuterUV(activeSprite);
				vector2 = DataUtility.GetInnerUV(activeSprite);
				vector3 = DataUtility.GetPadding(activeSprite);
				vector4 = activeSprite.border;
			}
			else
			{
				vector = Vector4.zero;
				vector2 = Vector4.zero;
				vector3 = Vector4.zero;
				vector4 = Vector4.zero;
			}
			Rect pixelAdjustedRect = GetPixelAdjustedRect();
			Vector4 adjustedBorders = GetAdjustedBorders(vector4 / multipliedPixelsPerUnit, pixelAdjustedRect);
			vector3 /= multipliedPixelsPerUnit;
			s_VertScratch[0] = new Vector2(vector3.x, vector3.y);
			s_VertScratch[3] = new Vector2(pixelAdjustedRect.width - vector3.z, pixelAdjustedRect.height - vector3.w);
			s_VertScratch[1].x = adjustedBorders.x;
			s_VertScratch[1].y = adjustedBorders.y;
			s_VertScratch[2].x = pixelAdjustedRect.width - adjustedBorders.z;
			s_VertScratch[2].y = pixelAdjustedRect.height - adjustedBorders.w;
			for (int i = 0; i < 4; i++)
			{
				s_VertScratch[i].x += pixelAdjustedRect.x;
				s_VertScratch[i].y += pixelAdjustedRect.y;
			}
			s_UVScratch[0] = new Vector2(vector.x, vector.y);
			s_UVScratch[1] = new Vector2(vector2.x, vector2.y);
			s_UVScratch[2] = new Vector2(vector2.z, vector2.w);
			s_UVScratch[3] = new Vector2(vector.z, vector.w);
			toFill.Clear();
			for (int j = 0; j < 3; j++)
			{
				int num = j + 1;
				for (int k = 0; k < 3; k++)
				{
					if (m_FillCenter || j != 1 || k != 1)
					{
						int num2 = k + 1;
						AddQuad(toFill, new Vector2(s_VertScratch[j].x, s_VertScratch[k].y), new Vector2(s_VertScratch[num].x, s_VertScratch[num2].y), color, new Vector2(s_UVScratch[j].x, s_UVScratch[k].y), new Vector2(s_UVScratch[num].x, s_UVScratch[num2].y));
					}
				}
			}
		}

		private void GenerateTiledSprite(VertexHelper toFill)
		{
			Vector4 vector;
			Vector4 vector2;
			Vector2 vector4;
			Vector4 vector3;
			if (activeSprite != null)
			{
				vector = DataUtility.GetOuterUV(activeSprite);
				vector2 = DataUtility.GetInnerUV(activeSprite);
				vector3 = activeSprite.border;
				vector4 = activeSprite.rect.size;
			}
			else
			{
				vector = Vector4.zero;
				vector2 = Vector4.zero;
				vector3 = Vector4.zero;
				vector4 = Vector2.one * 100f;
			}
			Rect pixelAdjustedRect = GetPixelAdjustedRect();
			float num = (vector4.x - vector3.x - vector3.z) / multipliedPixelsPerUnit;
			float num2 = (vector4.y - vector3.y - vector3.w) / multipliedPixelsPerUnit;
			vector3 = GetAdjustedBorders(vector3 / multipliedPixelsPerUnit, pixelAdjustedRect);
			Vector2 vector5 = new Vector2(vector2.x, vector2.y);
			Vector2 vector6 = new Vector2(vector2.z, vector2.w);
			float x = vector3.x;
			float num3 = pixelAdjustedRect.width - vector3.z;
			float y = vector3.y;
			float num4 = pixelAdjustedRect.height - vector3.w;
			toFill.Clear();
			Vector2 uvMax = vector6;
			if (num <= 0f)
			{
				num = num3 - x;
			}
			if (num2 <= 0f)
			{
				num2 = num4 - y;
			}
			if (activeSprite != null && (hasBorder || activeSprite.packed || activeSprite.texture.wrapMode != TextureWrapMode.Repeat))
			{
				long num5 = 0L;
				long num6 = 0L;
				if (m_FillCenter)
				{
					num5 = (long)Math.Ceiling((num3 - x) / num);
					num6 = (long)Math.Ceiling((num4 - y) / num2);
					double num7 = 0.0;
					num7 = ((!hasBorder) ? ((double)(num5 * num6) * 4.0) : (((double)num5 + 2.0) * ((double)num6 + 2.0) * 4.0));
					if (num7 > 65000.0)
					{
						Debug.LogError("Too many sprite tiles on Image \"" + base.name + "\". The tile size will be increased. To remove the limit on the number of tiles, set the Wrap mode to Repeat in the Image Import Settings", this);
						double num8 = ((!hasBorder) ? ((double)num5 / (double)num6) : (((double)num5 + 2.0) / ((double)num6 + 2.0)));
						double num9 = Math.Sqrt(16250.0 / num8);
						double num10 = num9 * num8;
						if (hasBorder)
						{
							num9 -= 2.0;
							num10 -= 2.0;
						}
						num5 = (long)Math.Floor(num9);
						num6 = (long)Math.Floor(num10);
						num = (num3 - x) / (float)num5;
						num2 = (num4 - y) / (float)num6;
					}
				}
				else if (hasBorder)
				{
					num5 = (long)Math.Ceiling((num3 - x) / num);
					num6 = (long)Math.Ceiling((num4 - y) / num2);
					if (((double)(num6 + num5) + 2.0) * 2.0 * 4.0 > 65000.0)
					{
						Debug.LogError("Too many sprite tiles on Image \"" + base.name + "\". The tile size will be increased. To remove the limit on the number of tiles, set the Wrap mode to Repeat in the Image Import Settings", this);
						double num11 = (double)num5 / (double)num6;
						double num12 = (16250.0 - 4.0) / (2.0 * (1.0 + num11));
						double d = num12 * num11;
						num5 = (long)Math.Floor(num12);
						num6 = (long)Math.Floor(d);
						num = (num3 - x) / (float)num5;
						num2 = (num4 - y) / (float)num6;
					}
				}
				else
				{
					num6 = (num5 = 0L);
				}
				if (m_FillCenter)
				{
					for (long num13 = 0L; num13 < num6; num13++)
					{
						float num14 = y + (float)num13 * num2;
						float num15 = y + (float)(num13 + 1) * num2;
						if (num15 > num4)
						{
							uvMax.y = vector5.y + (vector6.y - vector5.y) * (num4 - num14) / (num15 - num14);
							num15 = num4;
						}
						uvMax.x = vector6.x;
						for (long num16 = 0L; num16 < num5; num16++)
						{
							float num17 = x + (float)num16 * num;
							float num18 = x + (float)(num16 + 1) * num;
							if (num18 > num3)
							{
								uvMax.x = vector5.x + (vector6.x - vector5.x) * (num3 - num17) / (num18 - num17);
								num18 = num3;
							}
							AddQuad(toFill, new Vector2(num17, num14) + pixelAdjustedRect.position, new Vector2(num18, num15) + pixelAdjustedRect.position, color, vector5, uvMax);
						}
					}
				}
				if (!hasBorder)
				{
					return;
				}
				uvMax = vector6;
				for (long num19 = 0L; num19 < num6; num19++)
				{
					float num20 = y + (float)num19 * num2;
					float num21 = y + (float)(num19 + 1) * num2;
					if (num21 > num4)
					{
						uvMax.y = vector5.y + (vector6.y - vector5.y) * (num4 - num20) / (num21 - num20);
						num21 = num4;
					}
					AddQuad(toFill, new Vector2(0f, num20) + pixelAdjustedRect.position, new Vector2(x, num21) + pixelAdjustedRect.position, color, new Vector2(vector.x, vector5.y), new Vector2(vector5.x, uvMax.y));
					AddQuad(toFill, new Vector2(num3, num20) + pixelAdjustedRect.position, new Vector2(pixelAdjustedRect.width, num21) + pixelAdjustedRect.position, color, new Vector2(vector6.x, vector5.y), new Vector2(vector.z, uvMax.y));
				}
				uvMax = vector6;
				for (long num22 = 0L; num22 < num5; num22++)
				{
					float num23 = x + (float)num22 * num;
					float num24 = x + (float)(num22 + 1) * num;
					if (num24 > num3)
					{
						uvMax.x = vector5.x + (vector6.x - vector5.x) * (num3 - num23) / (num24 - num23);
						num24 = num3;
					}
					AddQuad(toFill, new Vector2(num23, 0f) + pixelAdjustedRect.position, new Vector2(num24, y) + pixelAdjustedRect.position, color, new Vector2(vector5.x, vector.y), new Vector2(uvMax.x, vector5.y));
					AddQuad(toFill, new Vector2(num23, num4) + pixelAdjustedRect.position, new Vector2(num24, pixelAdjustedRect.height) + pixelAdjustedRect.position, color, new Vector2(vector5.x, vector6.y), new Vector2(uvMax.x, vector.w));
				}
				AddQuad(toFill, new Vector2(0f, 0f) + pixelAdjustedRect.position, new Vector2(x, y) + pixelAdjustedRect.position, color, new Vector2(vector.x, vector.y), new Vector2(vector5.x, vector5.y));
				AddQuad(toFill, new Vector2(num3, 0f) + pixelAdjustedRect.position, new Vector2(pixelAdjustedRect.width, y) + pixelAdjustedRect.position, color, new Vector2(vector6.x, vector.y), new Vector2(vector.z, vector5.y));
				AddQuad(toFill, new Vector2(0f, num4) + pixelAdjustedRect.position, new Vector2(x, pixelAdjustedRect.height) + pixelAdjustedRect.position, color, new Vector2(vector.x, vector6.y), new Vector2(vector5.x, vector.w));
				AddQuad(toFill, new Vector2(num3, num4) + pixelAdjustedRect.position, new Vector2(pixelAdjustedRect.width, pixelAdjustedRect.height) + pixelAdjustedRect.position, color, new Vector2(vector6.x, vector6.y), new Vector2(vector.z, vector.w));
			}
			else
			{
				Vector2 b = new Vector2((num3 - x) / num, (num4 - y) / num2);
				if (m_FillCenter)
				{
					AddQuad(toFill, new Vector2(x, y) + pixelAdjustedRect.position, new Vector2(num3, num4) + pixelAdjustedRect.position, color, Vector2.Scale(vector5, b), Vector2.Scale(vector6, b));
				}
			}
		}

		private static void AddQuad(VertexHelper vertexHelper, Vector3[] quadPositions, Color32 color, Vector3[] quadUVs)
		{
			int currentVertCount = vertexHelper.currentVertCount;
			for (int i = 0; i < 4; i++)
			{
				vertexHelper.AddVert(quadPositions[i], color, quadUVs[i]);
			}
			vertexHelper.AddTriangle(currentVertCount, currentVertCount + 1, currentVertCount + 2);
			vertexHelper.AddTriangle(currentVertCount + 2, currentVertCount + 3, currentVertCount);
		}

		private static void AddQuad(VertexHelper vertexHelper, Vector2 posMin, Vector2 posMax, Color32 color, Vector2 uvMin, Vector2 uvMax)
		{
			int currentVertCount = vertexHelper.currentVertCount;
			vertexHelper.AddVert(new Vector3(posMin.x, posMin.y, 0f), color, new Vector2(uvMin.x, uvMin.y));
			vertexHelper.AddVert(new Vector3(posMin.x, posMax.y, 0f), color, new Vector2(uvMin.x, uvMax.y));
			vertexHelper.AddVert(new Vector3(posMax.x, posMax.y, 0f), color, new Vector2(uvMax.x, uvMax.y));
			vertexHelper.AddVert(new Vector3(posMax.x, posMin.y, 0f), color, new Vector2(uvMax.x, uvMin.y));
			vertexHelper.AddTriangle(currentVertCount, currentVertCount + 1, currentVertCount + 2);
			vertexHelper.AddTriangle(currentVertCount + 2, currentVertCount + 3, currentVertCount);
		}

		private Vector4 GetAdjustedBorders(Vector4 border, Rect adjustedRect)
		{
			Rect rect = base.rectTransform.rect;
			for (int i = 0; i <= 1; i++)
			{
				if (rect.size[i] != 0f)
				{
					float num = adjustedRect.size[i] / rect.size[i];
					border[i] *= num;
					border[i + 2] *= num;
				}
				float num2 = border[i] + border[i + 2];
				if (adjustedRect.size[i] < num2 && num2 != 0f)
				{
					float num = adjustedRect.size[i] / num2;
					border[i] *= num;
					border[i + 2] *= num;
				}
			}
			return border;
		}

		private void GenerateFilledSprite(VertexHelper toFill, bool preserveAspect)
		{
			toFill.Clear();
			if (m_FillAmount < 0.001f)
			{
				return;
			}
			Vector4 drawingDimensions = GetDrawingDimensions(preserveAspect);
			Vector4 obj = ((activeSprite != null) ? DataUtility.GetOuterUV(activeSprite) : Vector4.zero);
			UIVertex simpleVert = UIVertex.simpleVert;
			simpleVert.color = color;
			float num = obj.x;
			float num2 = obj.y;
			float num3 = obj.z;
			float num4 = obj.w;
			if (m_FillMethod == FillMethod.Horizontal || m_FillMethod == FillMethod.Vertical)
			{
				if (fillMethod == FillMethod.Horizontal)
				{
					float num5 = (num3 - num) * m_FillAmount;
					if (m_FillOrigin == 1)
					{
						drawingDimensions.x = drawingDimensions.z - (drawingDimensions.z - drawingDimensions.x) * m_FillAmount;
						num = num3 - num5;
					}
					else
					{
						drawingDimensions.z = drawingDimensions.x + (drawingDimensions.z - drawingDimensions.x) * m_FillAmount;
						num3 = num + num5;
					}
				}
				else if (fillMethod == FillMethod.Vertical)
				{
					float num6 = (num4 - num2) * m_FillAmount;
					if (m_FillOrigin == 1)
					{
						drawingDimensions.y = drawingDimensions.w - (drawingDimensions.w - drawingDimensions.y) * m_FillAmount;
						num2 = num4 - num6;
					}
					else
					{
						drawingDimensions.w = drawingDimensions.y + (drawingDimensions.w - drawingDimensions.y) * m_FillAmount;
						num4 = num2 + num6;
					}
				}
			}
			s_Xy[0] = new Vector2(drawingDimensions.x, drawingDimensions.y);
			s_Xy[1] = new Vector2(drawingDimensions.x, drawingDimensions.w);
			s_Xy[2] = new Vector2(drawingDimensions.z, drawingDimensions.w);
			s_Xy[3] = new Vector2(drawingDimensions.z, drawingDimensions.y);
			s_Uv[0] = new Vector2(num, num2);
			s_Uv[1] = new Vector2(num, num4);
			s_Uv[2] = new Vector2(num3, num4);
			s_Uv[3] = new Vector2(num3, num2);
			if (m_FillAmount < 1f && m_FillMethod != FillMethod.Horizontal && m_FillMethod != FillMethod.Vertical)
			{
				if (fillMethod == FillMethod.Radial90)
				{
					if (RadialCut(s_Xy, s_Uv, m_FillAmount, m_FillClockwise, m_FillOrigin))
					{
						AddQuad(toFill, s_Xy, color, s_Uv);
					}
				}
				else if (fillMethod == FillMethod.Radial180)
				{
					for (int i = 0; i < 2; i++)
					{
						int num7 = ((m_FillOrigin > 1) ? 1 : 0);
						float t;
						float t2;
						float t3;
						float t4;
						if (m_FillOrigin == 0 || m_FillOrigin == 2)
						{
							t = 0f;
							t2 = 1f;
							if (i == num7)
							{
								t3 = 0f;
								t4 = 0.5f;
							}
							else
							{
								t3 = 0.5f;
								t4 = 1f;
							}
						}
						else
						{
							t3 = 0f;
							t4 = 1f;
							if (i == num7)
							{
								t = 0.5f;
								t2 = 1f;
							}
							else
							{
								t = 0f;
								t2 = 0.5f;
							}
						}
						s_Xy[0].x = Mathf.Lerp(drawingDimensions.x, drawingDimensions.z, t3);
						s_Xy[1].x = s_Xy[0].x;
						s_Xy[2].x = Mathf.Lerp(drawingDimensions.x, drawingDimensions.z, t4);
						s_Xy[3].x = s_Xy[2].x;
						s_Xy[0].y = Mathf.Lerp(drawingDimensions.y, drawingDimensions.w, t);
						s_Xy[1].y = Mathf.Lerp(drawingDimensions.y, drawingDimensions.w, t2);
						s_Xy[2].y = s_Xy[1].y;
						s_Xy[3].y = s_Xy[0].y;
						s_Uv[0].x = Mathf.Lerp(num, num3, t3);
						s_Uv[1].x = s_Uv[0].x;
						s_Uv[2].x = Mathf.Lerp(num, num3, t4);
						s_Uv[3].x = s_Uv[2].x;
						s_Uv[0].y = Mathf.Lerp(num2, num4, t);
						s_Uv[1].y = Mathf.Lerp(num2, num4, t2);
						s_Uv[2].y = s_Uv[1].y;
						s_Uv[3].y = s_Uv[0].y;
						float value = (m_FillClockwise ? (fillAmount * 2f - (float)i) : (m_FillAmount * 2f - (float)(1 - i)));
						if (RadialCut(s_Xy, s_Uv, Mathf.Clamp01(value), m_FillClockwise, (i + m_FillOrigin + 3) % 4))
						{
							AddQuad(toFill, s_Xy, color, s_Uv);
						}
					}
				}
				else
				{
					if (fillMethod != FillMethod.Radial360)
					{
						return;
					}
					for (int j = 0; j < 4; j++)
					{
						float t5;
						float t6;
						if (j < 2)
						{
							t5 = 0f;
							t6 = 0.5f;
						}
						else
						{
							t5 = 0.5f;
							t6 = 1f;
						}
						float t7;
						float t8;
						if (j == 0 || j == 3)
						{
							t7 = 0f;
							t8 = 0.5f;
						}
						else
						{
							t7 = 0.5f;
							t8 = 1f;
						}
						s_Xy[0].x = Mathf.Lerp(drawingDimensions.x, drawingDimensions.z, t5);
						s_Xy[1].x = s_Xy[0].x;
						s_Xy[2].x = Mathf.Lerp(drawingDimensions.x, drawingDimensions.z, t6);
						s_Xy[3].x = s_Xy[2].x;
						s_Xy[0].y = Mathf.Lerp(drawingDimensions.y, drawingDimensions.w, t7);
						s_Xy[1].y = Mathf.Lerp(drawingDimensions.y, drawingDimensions.w, t8);
						s_Xy[2].y = s_Xy[1].y;
						s_Xy[3].y = s_Xy[0].y;
						s_Uv[0].x = Mathf.Lerp(num, num3, t5);
						s_Uv[1].x = s_Uv[0].x;
						s_Uv[2].x = Mathf.Lerp(num, num3, t6);
						s_Uv[3].x = s_Uv[2].x;
						s_Uv[0].y = Mathf.Lerp(num2, num4, t7);
						s_Uv[1].y = Mathf.Lerp(num2, num4, t8);
						s_Uv[2].y = s_Uv[1].y;
						s_Uv[3].y = s_Uv[0].y;
						float value2 = (m_FillClockwise ? (m_FillAmount * 4f - (float)((j + m_FillOrigin) % 4)) : (m_FillAmount * 4f - (float)(3 - (j + m_FillOrigin) % 4)));
						if (RadialCut(s_Xy, s_Uv, Mathf.Clamp01(value2), m_FillClockwise, (j + 2) % 4))
						{
							AddQuad(toFill, s_Xy, color, s_Uv);
						}
					}
				}
			}
			else
			{
				AddQuad(toFill, s_Xy, color, s_Uv);
			}
		}

		private static bool RadialCut(Vector3[] xy, Vector3[] uv, float fill, bool invert, int corner)
		{
			if (fill < 0.001f)
			{
				return false;
			}
			if ((corner & 1) == 1)
			{
				invert = !invert;
			}
			if (!invert && fill > 0.999f)
			{
				return true;
			}
			float num = Mathf.Clamp01(fill);
			if (invert)
			{
				num = 1f - num;
			}
			num *= MathF.PI / 2f;
			float cos = Mathf.Cos(num);
			float sin = Mathf.Sin(num);
			RadialCut(xy, cos, sin, invert, corner);
			RadialCut(uv, cos, sin, invert, corner);
			return true;
		}

		private static void RadialCut(Vector3[] xy, float cos, float sin, bool invert, int corner)
		{
			int num = (corner + 1) % 4;
			int num2 = (corner + 2) % 4;
			int num3 = (corner + 3) % 4;
			if ((corner & 1) == 1)
			{
				if (sin > cos)
				{
					cos /= sin;
					sin = 1f;
					if (invert)
					{
						xy[num].x = Mathf.Lerp(xy[corner].x, xy[num2].x, cos);
						xy[num2].x = xy[num].x;
					}
				}
				else if (cos > sin)
				{
					sin /= cos;
					cos = 1f;
					if (!invert)
					{
						xy[num2].y = Mathf.Lerp(xy[corner].y, xy[num2].y, sin);
						xy[num3].y = xy[num2].y;
					}
				}
				else
				{
					cos = 1f;
					sin = 1f;
				}
				if (!invert)
				{
					xy[num3].x = Mathf.Lerp(xy[corner].x, xy[num2].x, cos);
				}
				else
				{
					xy[num].y = Mathf.Lerp(xy[corner].y, xy[num2].y, sin);
				}
				return;
			}
			if (cos > sin)
			{
				sin /= cos;
				cos = 1f;
				if (!invert)
				{
					xy[num].y = Mathf.Lerp(xy[corner].y, xy[num2].y, sin);
					xy[num2].y = xy[num].y;
				}
			}
			else if (sin > cos)
			{
				cos /= sin;
				sin = 1f;
				if (invert)
				{
					xy[num2].x = Mathf.Lerp(xy[corner].x, xy[num2].x, cos);
					xy[num3].x = xy[num2].x;
				}
			}
			else
			{
				cos = 1f;
				sin = 1f;
			}
			if (invert)
			{
				xy[num3].y = Mathf.Lerp(xy[corner].y, xy[num2].y, sin);
			}
			else
			{
				xy[num].x = Mathf.Lerp(xy[corner].x, xy[num2].x, cos);
			}
		}

		public virtual void CalculateLayoutInputHorizontal()
		{
		}

		public virtual void CalculateLayoutInputVertical()
		{
		}

		public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)
		{
			if (alphaHitTestMinimumThreshold <= 0f)
			{
				return true;
			}
			if (alphaHitTestMinimumThreshold > 1f)
			{
				return false;
			}
			if (activeSprite == null)
			{
				return true;
			}
			if (!RectTransformUtility.ScreenPointToLocalPointInRectangle(base.rectTransform, screenPoint, eventCamera, out var localPoint))
			{
				return false;
			}
			Rect pixelAdjustedRect = GetPixelAdjustedRect();
			localPoint.x += base.rectTransform.pivot.x * pixelAdjustedRect.width;
			localPoint.y += base.rectTransform.pivot.y * pixelAdjustedRect.height;
			localPoint = MapCoordinate(localPoint, pixelAdjustedRect);
			Rect textureRect = activeSprite.textureRect;
			float u = (textureRect.x + localPoint.x) / (float)activeSprite.texture.width;
			float v = (textureRect.y + localPoint.y) / (float)activeSprite.texture.height;
			try
			{
				return activeSprite.texture.GetPixelBilinear(u, v).a >= alphaHitTestMinimumThreshold;
			}
			catch (UnityException ex)
			{
				Debug.LogError("Using alphaHitTestMinimumThreshold greater than 0 on Image whose sprite texture cannot be read. " + ex.Message + " Also make sure to disable sprite packing for this sprite.", this);
				return true;
			}
		}

		private Vector2 MapCoordinate(Vector2 local, Rect rect)
		{
			Rect rect2 = activeSprite.rect;
			if (type == Type.Simple || type == Type.Filled)
			{
				return new Vector2(local.x * rect2.width / rect.width, local.y * rect2.height / rect.height);
			}
			Vector4 border = activeSprite.border;
			Vector4 adjustedBorders = GetAdjustedBorders(border / pixelsPerUnit, rect);
			for (int i = 0; i < 2; i++)
			{
				if (!(local[i] <= adjustedBorders[i]))
				{
					if (rect.size[i] - local[i] <= adjustedBorders[i + 2])
					{
						local[i] -= rect.size[i] - rect2.size[i];
					}
					else if (type == Type.Sliced)
					{
						float t = Mathf.InverseLerp(adjustedBorders[i], rect.size[i] - adjustedBorders[i + 2], local[i]);
						local[i] = Mathf.Lerp(border[i], rect2.size[i] - border[i + 2], t);
					}
					else
					{
						local[i] -= adjustedBorders[i];
						local[i] = Mathf.Repeat(local[i], rect2.size[i] - border[i] - border[i + 2]);
						local[i] += border[i];
					}
				}
			}
			return local;
		}

		private static void RebuildImage(SpriteAtlas spriteAtlas)
		{
			for (int num = m_TrackedTexturelessImages.Count - 1; num >= 0; num--)
			{
				Image image = m_TrackedTexturelessImages[num];
				if (spriteAtlas.CanBindTo(image.activeSprite))
				{
					image.SetAllDirty();
					m_TrackedTexturelessImages.RemoveAt(num);
				}
			}
		}

		private static void TrackImage(Image g)
		{
			if (!s_Initialized)
			{
				SpriteAtlasManager.atlasRegistered += RebuildImage;
				s_Initialized = true;
			}
			m_TrackedTexturelessImages.Add(g);
		}

		private static void UnTrackImage(Image g)
		{
			m_TrackedTexturelessImages.Remove(g);
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	[Obsolete("Not supported anymore.", true)]
	public interface IMask
	{
		RectTransform rectTransform { get; }

		bool Enabled();
	}
	public interface IMaskable
	{
		void RecalculateMasking();
	}
	[AddComponentMenu("")]
	public class InputField : Selectable, IUpdateSelectedHandler, IEventSystemHandler, IBeginDragHandler, IDragHandler, IEndDragHandler, IPointerClickHandler, ISubmitHandler, ICanvasElement, ILayoutElement
	{
		public enum ContentType
		{
			Standard,
			Autocorrected,
			IntegerNumber,
			DecimalNumber,
			Alphanumeric,
			Name,
			EmailAddress,
			Password,
			Pin,
			Custom
		}

		public enum InputType
		{
			Standard,
			AutoCorrect,
			Password
		}

		public enum CharacterValidation
		{
			None,
			Integer,
			Decimal,
			Alphanumeric,
			Name,
			EmailAddress
		}

		public enum LineType
		{
			SingleLine,
			MultiLineSubmit,
			MultiLineNewline
		}

		public delegate char OnValidateInput(string text, int charIndex, char addedChar);

		[Serializable]
		public class SubmitEvent : UnityEvent<string>
		{
		}

		[Serializable]
		public class OnChangeEvent : UnityEvent<string>
		{
		}

		protected enum EditState
		{
			Continue,
			Finish
		}

		protected TouchScreenKeyboard m_Keyboard;

		private static readonly char[] kSeparators = new char[6] { ' ', '.', ',', '\t', '\r', '\n' };

		[SerializeField]
		[FormerlySerializedAs("text")]
		protected Text m_TextComponent;

		[SerializeField]
		protected Graphic m_Placeholder;

		[SerializeField]
		private ContentType m_ContentType;

		[FormerlySerializedAs("inputType")]
		[SerializeField]
		private InputType m_InputType;

		[FormerlySerializedAs("asteriskChar")]
		[SerializeField]
		private char m_AsteriskChar = '*';

		[FormerlySerializedAs("keyboardType")]
		[SerializeField]
		private TouchScreenKeyboardType m_KeyboardType;

		[SerializeField]
		private LineType m_LineType;

		[FormerlySerializedAs("hideMobileInput")]
		[SerializeField]
		private bool m_HideMobileInput;

		[FormerlySerializedAs("validation")]
		[SerializeField]
		private CharacterValidation m_CharacterValidation;

		[FormerlySerializedAs("characterLimit")]
		[SerializeField]
		private int m_CharacterLimit;

		[FormerlySerializedAs("onSubmit")]
		[FormerlySerializedAs("m_OnSubmit")]
		[FormerlySerializedAs("m_EndEdit")]
		[SerializeField]
		private SubmitEvent m_OnEndEdit = new SubmitEvent();

		[FormerlySerializedAs("onValueChange")]
		[FormerlySerializedAs("m_OnValueChange")]
		[SerializeField]
		private OnChangeEvent m_OnValueChanged = new OnChangeEvent();

		[FormerlySerializedAs("onValidateInput")]
		[SerializeField]
		private OnValidateInput m_OnValidateInput;

		[FormerlySerializedAs("selectionColor")]
		[SerializeField]
		private Color m_CaretColor = new Color(10f / 51f, 10f / 51f, 10f / 51f, 1f);

		[SerializeField]
		private bool m_CustomCaretColor;

		[SerializeField]
		private Color m_SelectionColor = new Color(56f / 85f, 0.80784315f, 1f, 64f / 85f);

		[SerializeField]
		[FormerlySerializedAs("mValue")]
		protected string m_Text = string.Empty;

		[SerializeField]
		[Range(0f, 4f)]
		private float m_CaretBlinkRate = 0.85f;

		[SerializeField]
		[Range(1f, 5f)]
		private int m_CaretWidth = 1;

		[SerializeField]
		private bool m_ReadOnly;

		protected int m_CaretPosition;

		protected int m_CaretSelectPosition;

		private RectTransform caretRectTrans;

		protected UIVertex[] m_CursorVerts;

		private TextGenerator m_InputTextCache;

		private CanvasRenderer m_CachedInputRenderer;

		private bool m_PreventFontCallback;

		[NonSerialized]
		protected Mesh m_Mesh;

		private bool m_AllowInput;

		private bool m_ShouldActivateNextUpdate;

		private bool m_UpdateDrag;

		private bool m_DragPositionOutOfBounds;

		private const float kHScrollSpeed = 0.05f;

		private const float kVScrollSpeed = 0.1f;

		protected bool m_CaretVisible;

		private Coroutine m_BlinkCoroutine;

		private float m_BlinkStartTime;

		protected int m_DrawStart;

		protected int m_DrawEnd;

		private Coroutine m_DragCoroutine;

		private string m_OriginalText = "";

		private bool m_WasCanceled;

		private bool m_HasDoneFocusTransition;

		private WaitForSecondsRealtime m_WaitForSecondsRealtime;

		private bool m_TouchKeyboardAllowsInPlaceEditing;

		private const string kEmailSpecialCharacters = "!#$%&'*+-/=?^_`{|}~";

		private Event m_ProcessingEvent = new Event();

		private const int k_MaxTextLength = 16382;

		private BaseInput input
		{
			get
			{
				if ((bool)EventSystem.current && (bool)EventSystem.current.currentInputModule)
				{
					return EventSystem.current.currentInputModule.input;
				}
				return null;
			}
		}

		private string compositionString
		{
			get
			{
				if (!(input != null))
				{
					return Input.compositionString;
				}
				return input.compositionString;
			}
		}

		protected Mesh mesh
		{
			get
			{
				if (m_Mesh == null)
				{
					m_Mesh = new Mesh();
				}
				return m_Mesh;
			}
		}

		protected TextGenerator cachedInputTextGenerator
		{
			get
			{
				if (m_InputTextCache == null)
				{
					m_InputTextCache = new TextGenerator();
				}
				return m_InputTextCache;
			}
		}

		public bool shouldHideMobileInput
		{
			get
			{
				RuntimePlatform platform = Application.platform;
				if (platform == RuntimePlatform.IPhonePlayer || platform == RuntimePlatform.Android || platform == RuntimePlatform.tvOS)
				{
					return m_HideMobileInput;
				}
				return true;
			}
			set
			{
				SetPropertyUtility.SetStruct(ref m_HideMobileInput, value);
			}
		}

		private bool shouldActivateOnSelect => Application.platform != RuntimePlatform.tvOS;

		public string text
		{
			get
			{
				return m_Text;
			}
			set
			{
				SetText(value);
			}
		}

		public bool isFocused => m_AllowInput;

		public float caretBlinkRate
		{
			get
			{
				return m_CaretBlinkRate;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_CaretBlinkRate, value) && m_AllowInput)
				{
					SetCaretActive();
				}
			}
		}

		public int caretWidth
		{
			get
			{
				return m_CaretWidth;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_CaretWidth, value))
				{
					MarkGeometryAsDirty();
				}
			}
		}

		public Text textComponent
		{
			get
			{
				return m_TextComponent;
			}
			set
			{
				if (m_TextComponent != null)
				{
					m_TextComponent.UnregisterDirtyVerticesCallback(MarkGeometryAsDirty);
					m_TextComponent.UnregisterDirtyVerticesCallback(UpdateLabel);
					m_TextComponent.UnregisterDirtyMaterialCallback(UpdateCaretMaterial);
				}
				if (SetPropertyUtility.SetClass(ref m_TextComponent, value))
				{
					EnforceTextHOverflow();
					if (m_TextComponent != null)
					{
						m_TextComponent.RegisterDirtyVerticesCallback(MarkGeometryAsDirty);
						m_TextComponent.RegisterDirtyVerticesCallback(UpdateLabel);
						m_TextComponent.RegisterDirtyMaterialCallback(UpdateCaretMaterial);
					}
				}
			}
		}

		public Graphic placeholder
		{
			get
			{
				return m_Placeholder;
			}
			set
			{
				SetPropertyUtility.SetClass(ref m_Placeholder, value);
			}
		}

		public Color caretColor
		{
			get
			{
				if (!customCaretColor)
				{
					return textComponent.color;
				}
				return m_CaretColor;
			}
			set
			{
				if (SetPropertyUtility.SetColor(ref m_CaretColor, value))
				{
					MarkGeometryAsDirty();
				}
			}
		}

		public bool customCaretColor
		{
			get
			{
				return m_CustomCaretColor;
			}
			set
			{
				if (m_CustomCaretColor != value)
				{
					m_CustomCaretColor = value;
					MarkGeometryAsDirty();
				}
			}
		}

		public Color selectionColor
		{
			get
			{
				return m_SelectionColor;
			}
			set
			{
				if (SetPropertyUtility.SetColor(ref m_SelectionColor, value))
				{
					MarkGeometryAsDirty();
				}
			}
		}

		public SubmitEvent onEndEdit
		{
			get
			{
				return m_OnEndEdit;
			}
			set
			{
				SetPropertyUtility.SetClass(ref m_OnEndEdit, value);
			}
		}

		[Obsolete("onValueChange has been renamed to onValueChanged")]
		public OnChangeEvent onValueChange
		{
			get
			{
				return onValueChanged;
			}
			set
			{
				onValueChanged = value;
			}
		}

		public OnChangeEvent onValueChanged
		{
			get
			{
				return m_OnValueChanged;
			}
			set
			{
				SetPropertyUtility.SetClass(ref m_OnValueChanged, value);
			}
		}

		public OnValidateInput onValidateInput
		{
			get
			{
				return m_OnValidateInput;
			}
			set
			{
				SetPropertyUtility.SetClass(ref m_OnValidateInput, value);
			}
		}

		public int characterLimit
		{
			get
			{
				return m_CharacterLimit;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_CharacterLimit, Math.Max(0, value)))
				{
					UpdateLabel();
					if (m_Keyboard != null)
					{
						m_Keyboard.characterLimit = value;
					}
				}
			}
		}

		public ContentType contentType
		{
			get
			{
				return m_ContentType;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_ContentType, value))
				{
					EnforceContentType();
				}
			}
		}

		public LineType lineType
		{
			get
			{
				return m_LineType;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_LineType, value))
				{
					SetToCustomIfContentTypeIsNot(ContentType.Standard, ContentType.Autocorrected);
					EnforceTextHOverflow();
				}
			}
		}

		public InputType inputType
		{
			get
			{
				return m_InputType;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_InputType, value))
				{
					SetToCustom();
				}
			}
		}

		public TouchScreenKeyboard touchScreenKeyboard => m_Keyboard;

		public TouchScreenKeyboardType keyboardType
		{
			get
			{
				return m_KeyboardType;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_KeyboardType, value))
				{
					SetToCustom();
				}
			}
		}

		public CharacterValidation characterValidation
		{
			get
			{
				return m_CharacterValidation;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_CharacterValidation, value))
				{
					SetToCustom();
				}
			}
		}

		public bool readOnly
		{
			get
			{
				return m_ReadOnly;
			}
			set
			{
				m_ReadOnly = value;
			}
		}

		public bool multiLine
		{
			get
			{
				if (m_LineType != LineType.MultiLineNewline)
				{
					return lineType == LineType.MultiLineSubmit;
				}
				return true;
			}
		}

		public char asteriskChar
		{
			get
			{
				return m_AsteriskChar;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_AsteriskChar, value))
				{
					UpdateLabel();
				}
			}
		}

		public bool wasCanceled => m_WasCanceled;

		protected int caretPositionInternal
		{
			get
			{
				return m_CaretPosition + compositionString.Length;
			}
			set
			{
				m_CaretPosition = value;
				ClampPos(ref m_CaretPosition);
			}
		}

		protected int caretSelectPositionInternal
		{
			get
			{
				return m_CaretSelectPosition + compositionString.Length;
			}
			set
			{
				m_CaretSelectPosition = value;
				ClampPos(ref m_CaretSelectPosition);
			}
		}

		private bool hasSelection => caretPositionInternal != caretSelectPositionInternal;

		public int caretPosition
		{
			get
			{
				return m_CaretSelectPosition + compositionString.Length;
			}
			set
			{
				selectionAnchorPosition = value;
				selectionFocusPosition = value;
			}
		}

		public int selectionAnchorPosition
		{
			get
			{
				return m_CaretPosition + compositionString.Length;
			}
			set
			{
				if (compositionString.Length == 0)
				{
					m_CaretPosition = value;
					ClampPos(ref m_CaretPosition);
				}
			}
		}

		public int selectionFocusPosition
		{
			get
			{
				return m_CaretSelectPosition + compositionString.Length;
			}
			set
			{
				if (compositionString.Length == 0)
				{
					m_CaretSelectPosition = value;
					ClampPos(ref m_CaretSelectPosition);
				}
			}
		}

		private static string clipboard
		{
			get
			{
				return GUIUtility.systemCopyBuffer;
			}
			set
			{
				GUIUtility.systemCopyBuffer = value;
			}
		}

		public virtual float minWidth => 0f;

		public virtual float preferredWidth
		{
			get
			{
				if (textComponent == null)
				{
					return 0f;
				}
				TextGenerationSettings generationSettings = textComponent.GetGenerationSettings(Vector2.zero);
				return textComponent.cachedTextGeneratorForLayout.GetPreferredWidth(m_Text, generationSettings) / textComponent.pixelsPerUnit;
			}
		}

		public virtual float flexibleWidth => -1f;

		public virtual float minHeight => 0f;

		public virtual float preferredHeight
		{
			get
			{
				if (textComponent == null)
				{
					return 0f;
				}
				TextGenerationSettings generationSettings = textComponent.GetGenerationSettings(new Vector2(textComponent.rectTransform.rect.size.x, 0f));
				return textComponent.cachedTextGeneratorForLayout.GetPreferredHeight(m_Text, generationSettings) / textComponent.pixelsPerUnit;
			}
		}

		public virtual float flexibleHeight => -1f;

		public virtual int layoutPriority => 1;

		protected InputField()
		{
			EnforceTextHOverflow();
		}

		public void SetTextWithoutNotify(string input)
		{
			SetText(input, sendCallback: false);
		}

		private void SetText(string value, bool sendCallback = true)
		{
			if (text == value)
			{
				return;
			}
			if (value == null)
			{
				value = "";
			}
			value = value.Replace("\0", string.Empty);
			if (m_LineType == LineType.SingleLine)
			{
				value = value.Replace("\n", "").Replace("\t", "");
			}
			if (this.onValidateInput != null || characterValidation != CharacterValidation.None)
			{
				m_Text = "";
				OnValidateInput onValidateInput = this.onValidateInput ?? new OnValidateInput(Validate);
				m_CaretPosition = (m_CaretSelectPosition = value.Length);
				int num = ((characterLimit > 0) ? Math.Min(characterLimit, value.Length) : value.Length);
				for (int i = 0; i < num; i++)
				{
					char c = onValidateInput(m_Text, m_Text.Length, value[i]);
					if (c != 0)
					{
						m_Text += c;
					}
				}
			}
			else
			{
				m_Text = ((characterLimit > 0 && value.Length > characterLimit) ? value.Substring(0, characterLimit) : value);
			}
			if (m_Keyboard != null)
			{
				m_Keyboard.text = m_Text;
			}
			if (m_CaretPosition > m_Text.Length)
			{
				m_CaretPosition = (m_CaretSelectPosition = m_Text.Length);
			}
			else if (m_CaretSelectPosition > m_Text.Length)
			{
				m_CaretSelectPosition = m_Text.Length;
			}
			if (sendCallback)
			{
				SendOnValueChanged();
			}
			UpdateLabel();
		}

		protected void ClampPos(ref int pos)
		{
			if (pos < 0)
			{
				pos = 0;
			}
			else if (pos > text.Length)
			{
				pos = text.Length;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			if (m_Text == null)
			{
				m_Text = string.Empty;
			}
			m_DrawStart = 0;
			m_DrawEnd = m_Text.Length;
			if (m_CachedInputRenderer != null)
			{
				m_CachedInputRenderer.SetMaterial(m_TextComponent.GetModifiedMaterial(Graphic.defaultGraphicMaterial), Texture2D.whiteTexture);
			}
			if (m_TextComponent != null)
			{
				m_TextComponent.RegisterDirtyVerticesCallback(MarkGeometryAsDirty);
				m_TextComponent.RegisterDirtyVerticesCallback(UpdateLabel);
				m_TextComponent.RegisterDirtyMaterialCallback(UpdateCaretMaterial);
				UpdateLabel();
			}
		}

		protected override void OnDisable()
		{
			m_BlinkCoroutine = null;
			DeactivateInputField();
			if (m_TextComponent != null)
			{
				m_TextComponent.UnregisterDirtyVerticesCallback(MarkGeometryAsDirty);
				m_TextComponent.UnregisterDirtyVerticesCallback(UpdateLabel);
				m_TextComponent.UnregisterDirtyMaterialCallback(UpdateCaretMaterial);
			}
			CanvasUpdateRegistry.UnRegisterCanvasElementForRebuild(this);
			if (m_CachedInputRenderer != null)
			{
				m_CachedInputRenderer.Clear();
			}
			if (m_Mesh != null)
			{
				Object.DestroyImmediate(m_Mesh);
			}
			m_Mesh = null;
			base.OnDisable();
		}

		private IEnumerator CaretBlink()
		{
			m_CaretVisible = true;
			yield return null;
			while (isFocused && m_CaretBlinkRate > 0f)
			{
				float num = 1f / m_CaretBlinkRate;
				bool flag = (Time.unscaledTime - m_BlinkStartTime) % num < num / 2f;
				if (m_CaretVisible != flag)
				{
					m_CaretVisible = flag;
					if (!hasSelection)
					{
						MarkGeometryAsDirty();
					}
				}
				yield return null;
			}
			m_BlinkCoroutine = null;
		}

		private void SetCaretVisible()
		{
			if (m_AllowInput)
			{
				m_CaretVisible = true;
				m_BlinkStartTime = Time.unscaledTime;
				SetCaretActive();
			}
		}

		private void SetCaretActive()
		{
			if (!m_AllowInput)
			{
				return;
			}
			if (m_CaretBlinkRate > 0f)
			{
				if (m_BlinkCoroutine == null)
				{
					m_BlinkCoroutine = StartCoroutine(CaretBlink());
				}
			}
			else
			{
				m_CaretVisible = true;
			}
		}

		private void UpdateCaretMaterial()
		{
			if (m_TextComponent != null && m_CachedInputRenderer != null)
			{
				m_CachedInputRenderer.SetMaterial(m_TextComponent.GetModifiedMaterial(Graphic.defaultGraphicMaterial), Texture2D.whiteTexture);
			}
		}

		protected void OnFocus()
		{
			SelectAll();
		}

		protected void SelectAll()
		{
			caretPositionInternal = text.Length;
			caretSelectPositionInternal = 0;
		}

		public void MoveTextEnd(bool shift)
		{
			int length = text.Length;
			if (shift)
			{
				caretSelectPositionInternal = length;
			}
			else
			{
				caretPositionInternal = length;
				caretSelectPositionInternal = caretPositionInternal;
			}
			UpdateLabel();
		}

		public void MoveTextStart(bool shift)
		{
			int num = 0;
			if (shift)
			{
				caretSelectPositionInternal = num;
			}
			else
			{
				caretPositionInternal = num;
				caretSelectPositionInternal = caretPositionInternal;
			}
			UpdateLabel();
		}

		private bool InPlaceEditing()
		{
			if (TouchScreenKeyboard.isSupported)
			{
				return m_TouchKeyboardAllowsInPlaceEditing;
			}
			return true;
		}

		private void UpdateCaretFromKeyboard()
		{
			RangeInt selection = m_Keyboard.selection;
			int start = selection.start;
			int end = selection.end;
			bool flag = false;
			if (caretPositionInternal != start)
			{
				flag = true;
				caretPositionInternal = start;
			}
			if (caretSelectPositionInternal != end)
			{
				caretSelectPositionInternal = end;
				flag = true;
			}
			if (flag)
			{
				m_BlinkStartTime = Time.unscaledTime;
				UpdateLabel();
			}
		}

		protected virtual void LateUpdate()
		{
			if (m_ShouldActivateNextUpdate)
			{
				if (!isFocused)
				{
					ActivateInputFieldInternal();
					m_ShouldActivateNextUpdate = false;
					return;
				}
				m_ShouldActivateNextUpdate = false;
			}
			AssignPositioningIfNeeded();
			if (!isFocused || InPlaceEditing())
			{
				return;
			}
			if (m_Keyboard == null || m_Keyboard.status != TouchScreenKeyboard.Status.Visible)
			{
				if (m_Keyboard != null)
				{
					if (!m_ReadOnly)
					{
						this.text = m_Keyboard.text;
					}
					if (m_Keyboard.status == TouchScreenKeyboard.Status.Canceled)
					{
						m_WasCanceled = true;
					}
				}
				OnDeselect(null);
				return;
			}
			string text = m_Keyboard.text;
			if (m_Text != text)
			{
				if (m_ReadOnly)
				{
					m_Keyboard.text = m_Text;
				}
				else
				{
					m_Text = "";
					for (int i = 0; i < text.Length; i++)
					{
						char c = text[i];
						if (c == '\r' || c == '\u0003')
						{
							c = '\n';
						}
						if (onValidateInput != null)
						{
							c = onValidateInput(m_Text, m_Text.Length, c);
						}
						else if (characterValidation != CharacterValidation.None)
						{
							c = Validate(m_Text, m_Text.Length, c);
						}
						if (lineType == LineType.MultiLineSubmit && c == '\n')
						{
							m_Keyboard.text = m_Text;
							OnDeselect(null);
							return;
						}
						if (c != 0)
						{
							m_Text += c;
						}
					}
					if (characterLimit > 0 && m_Text.Length > characterLimit)
					{
						m_Text = m_Text.Substring(0, characterLimit);
					}
					if (m_Keyboard.canGetSelection)
					{
						UpdateCaretFromKeyboard();
					}
					else
					{
						int num = (caretSelectPositionInternal = m_Text.Length);
						caretPositionInternal = num;
					}
					if (m_Text != text)
					{
						m_Keyboard.text = m_Text;
					}
					SendOnValueChangedAndUpdateLabel();
				}
			}
			else if (m_HideMobileInput && m_Keyboard.canSetSelection)
			{
				m_Keyboard.selection = new RangeInt(caretPositionInternal, caretSelectPositionInternal - caretPositionInternal);
			}
			else if (m_Keyboard.canGetSelection && !m_HideMobileInput)
			{
				UpdateCaretFromKeyboard();
			}
			if (m_Keyboard.status != TouchScreenKeyboard.Status.Visible)
			{
				if (m_Keyboard.status == TouchScreenKeyboard.Status.Canceled)
				{
					m_WasCanceled = true;
				}
				OnDeselect(null);
			}
		}

		[Obsolete("This function is no longer used. Please use RectTransformUtility.ScreenPointToLocalPointInRectangle() instead.")]
		public Vector2 ScreenToLocal(Vector2 screen)
		{
			Canvas canvas = m_TextComponent.canvas;
			if (canvas == null)
			{
				return screen;
			}
			Vector3 vector = Vector3.zero;
			if (canvas.renderMode == RenderMode.ScreenSpaceOverlay)
			{
				vector = m_TextComponent.transform.InverseTransformPoint(screen);
			}
			else if (canvas.worldCamera != null)
			{
				Ray ray = canvas.worldCamera.ScreenPointToRay(screen);
				new Plane(m_TextComponent.transform.forward, m_TextComponent.transform.position).Raycast(ray, out var enter);
				vector = m_TextComponent.transform.InverseTransformPoint(ray.GetPoint(enter));
			}
			return new Vector2(vector.x, vector.y);
		}

		private int GetUnclampedCharacterLineFromPosition(Vector2 pos, TextGenerator generator)
		{
			if (!multiLine)
			{
				return 0;
			}
			float num = pos.y * m_TextComponent.pixelsPerUnit;
			float num2 = 0f;
			for (int i = 0; i < generator.lineCount; i++)
			{
				float topY = generator.lines[i].topY;
				float num3 = topY - (float)generator.lines[i].height;
				if (num > topY)
				{
					float num4 = topY - num2;
					if (num > topY - 0.5f * num4)
					{
						return i - 1;
					}
					return i;
				}
				if (num > num3)
				{
					return i;
				}
				num2 = num3;
			}
			return generator.lineCount;
		}

		protected int GetCharacterIndexFromPosition(Vector2 pos)
		{
			TextGenerator cachedTextGenerator = m_TextComponent.cachedTextGenerator;
			if (cachedTextGenerator.lineCount == 0)
			{
				return 0;
			}
			int unclampedCharacterLineFromPosition = GetUnclampedCharacterLineFromPosition(pos, cachedTextGenerator);
			if (unclampedCharacterLineFromPosition < 0)
			{
				return 0;
			}
			if (unclampedCharacterLineFromPosition >= cachedTextGenerator.lineCount)
			{
				return cachedTextGenerator.characterCountVisible;
			}
			int startCharIdx = cachedTextGenerator.lines[unclampedCharacterLineFromPosition].startCharIdx;
			int lineEndPosition = GetLineEndPosition(cachedTextGenerator, unclampedCharacterLineFromPosition);
			for (int i = startCharIdx; i < lineEndPosition && i < cachedTextGenerator.characterCountVisible; i++)
			{
				UICharInfo uICharInfo = cachedTextGenerator.characters[i];
				Vector2 vector = uICharInfo.cursorPos / m_TextComponent.pixelsPerUnit;
				float num = pos.x - vector.x;
				float num2 = vector.x + uICharInfo.charWidth / m_TextComponent.pixelsPerUnit - pos.x;
				if (num < num2)
				{
					return i;
				}
			}
			return lineEndPosition;
		}

		private bool MayDrag(PointerEventData eventData)
		{
			if (IsActive() && IsInteractable() && eventData.button == PointerEventData.InputButton.Left && m_TextComponent != null)
			{
				if (!InPlaceEditing())
				{
					return m_HideMobileInput;
				}
				return true;
			}
			return false;
		}

		public virtual void OnBeginDrag(PointerEventData eventData)
		{
			if (MayDrag(eventData))
			{
				m_UpdateDrag = true;
			}
		}

		public virtual void OnDrag(PointerEventData eventData)
		{
			if (MayDrag(eventData))
			{
				RectTransformUtility.ScreenPointToLocalPointInRectangle(textComponent.rectTransform, eventData.position, eventData.pressEventCamera, out var localPoint);
				caretSelectPositionInternal = GetCharacterIndexFromPosition(localPoint) + m_DrawStart;
				MarkGeometryAsDirty();
				m_DragPositionOutOfBounds = !RectTransformUtility.RectangleContainsScreenPoint(textComponent.rectTransform, eventData.position, eventData.pressEventCamera);
				if (m_DragPositionOutOfBounds && m_DragCoroutine == null)
				{
					m_DragCoroutine = StartCoroutine(MouseDragOutsideRect(eventData));
				}
				eventData.Use();
			}
		}

		private IEnumerator MouseDragOutsideRect(PointerEventData eventData)
		{
			while (m_UpdateDrag && m_DragPositionOutOfBounds)
			{
				RectTransformUtility.ScreenPointToLocalPointInRectangle(textComponent.rectTransform, eventData.position, eventData.pressEventCamera, out var localPoint);
				Rect rect = textComponent.rectTransform.rect;
				if (multiLine)
				{
					if (localPoint.y > rect.yMax)
					{
						MoveUp(shift: true, goToFirstChar: true);
					}
					else if (localPoint.y < rect.yMin)
					{
						MoveDown(shift: true, goToLastChar: true);
					}
				}
				else if (localPoint.x < rect.xMin)
				{
					MoveLeft(shift: true, ctrl: false);
				}
				else if (localPoint.x > rect.xMax)
				{
					MoveRight(shift: true, ctrl: false);
				}
				UpdateLabel();
				float num = (multiLine ? 0.1f : 0.05f);
				if (m_WaitForSecondsRealtime == null)
				{
					m_WaitForSecondsRealtime = new WaitForSecondsRealtime(num);
				}
				else
				{
					m_WaitForSecondsRealtime.waitTime = num;
				}
				yield return m_WaitForSecondsRealtime;
			}
			m_DragCoroutine = null;
		}

		public virtual void OnEndDrag(PointerEventData eventData)
		{
			if (MayDrag(eventData))
			{
				m_UpdateDrag = false;
			}
		}

		public override void OnPointerDown(PointerEventData eventData)
		{
			if (!MayDrag(eventData))
			{
				return;
			}
			EventSystem.current.SetSelectedGameObject(base.gameObject, eventData);
			bool allowInput = m_AllowInput;
			base.OnPointerDown(eventData);
			if (!InPlaceEditing() && (m_Keyboard == null || !m_Keyboard.active))
			{
				OnSelect(eventData);
				return;
			}
			if (allowInput)
			{
				RectTransformUtility.ScreenPointToLocalPointInRectangle(textComponent.rectTransform, eventData.position, eventData.pressEventCamera, out var localPoint);
				int num = (caretPositionInternal = GetCharacterIndexFromPosition(localPoint) + m_DrawStart);
				caretSelectPositionInternal = num;
			}
			UpdateLabel();
			eventData.Use();
		}

		protected EditState KeyPressed(Event evt)
		{
			EventModifiers modifiers = evt.modifiers;
			bool flag = ((SystemInfo.operatingSystemFamily == OperatingSystemFamily.MacOSX) ? ((modifiers & EventModifiers.Command) != 0) : ((modifiers & EventModifiers.Control) != 0));
			bool flag2 = (modifiers & EventModifiers.Shift) != 0;
			bool flag3 = (modifiers & EventModifiers.Alt) != 0;
			bool flag4 = flag && !flag3 && !flag2;
			switch (evt.keyCode)
			{
			case KeyCode.Backspace:
				Backspace();
				return EditState.Continue;
			case KeyCode.Delete:
				ForwardSpace();
				return EditState.Continue;
			case KeyCode.Home:
				MoveTextStart(flag2);
				return EditState.Continue;
			case KeyCode.End:
				MoveTextEnd(flag2);
				return EditState.Continue;
			case KeyCode.A:
				if (flag4)
				{
					SelectAll();
					return EditState.Continue;
				}
				break;
			case KeyCode.C:
				if (flag4)
				{
					if (inputType != InputType.Password)
					{
						clipboard = GetSelectedString();
					}
					else
					{
						clipboard = "";
					}
					return EditState.Continue;
				}
				break;
			case KeyCode.V:
				if (flag4)
				{
					Append(clipboard);
					UpdateLabel();
					return EditState.Continue;
				}
				break;
			case KeyCode.X:
				if (flag4)
				{
					if (inputType != InputType.Password)
					{
						clipboard = GetSelectedString();
					}
					else
					{
						clipboard = "";
					}
					Delete();
					UpdateTouchKeyboardFromEditChanges();
					SendOnValueChangedAndUpdateLabel();
					return EditState.Continue;
				}
				break;
			case KeyCode.LeftArrow:
				MoveLeft(flag2, flag);
				return EditState.Continue;
			case KeyCode.RightArrow:
				MoveRight(flag2, flag);
				return EditState.Continue;
			case KeyCode.UpArrow:
				MoveUp(flag2);
				return EditState.Continue;
			case KeyCode.DownArrow:
				MoveDown(flag2);
				return EditState.Continue;
			case KeyCode.Return:
			case KeyCode.KeypadEnter:
				if (lineType != LineType.MultiLineNewline)
				{
					return EditState.Finish;
				}
				break;
			case KeyCode.Escape:
				m_WasCanceled = true;
				return EditState.Finish;
			}
			char c = evt.character;
			if (!multiLine && (c == '\t' || c == '\r' || c == '\n'))
			{
				return EditState.Continue;
			}
			if (c == '\r' || c == '\u0003')
			{
				c = '\n';
			}
			if (IsValidChar(c))
			{
				Append(c);
			}
			if (c == '\0' && compositionString.Length > 0)
			{
				UpdateLabel();
			}
			return EditState.Continue;
		}

		private bool IsValidChar(char c)
		{
			switch (c)
			{
			case '\u007f':
				return false;
			case '\t':
			case '\n':
				return true;
			default:
				return m_TextComponent.font.HasCharacter(c);
			}
		}

		public void ProcessEvent(Event e)
		{
			KeyPressed(e);
		}

		public virtual void OnUpdateSelected(BaseEventData eventData)
		{
			if (!isFocused)
			{
				return;
			}
			bool flag = false;
			while (Event.PopEvent(m_ProcessingEvent))
			{
				if (m_ProcessingEvent.rawType == EventType.KeyDown)
				{
					flag = true;
					if (KeyPressed(m_ProcessingEvent) == EditState.Finish)
					{
						DeactivateInputField();
						break;
					}
				}
				EventType type = m_ProcessingEvent.type;
				if ((uint)(type - 13) <= 1u && m_ProcessingEvent.commandName == "SelectAll")
				{
					SelectAll();
					flag = true;
				}
			}
			if (flag)
			{
				UpdateLabel();
			}
			eventData.Use();
		}

		private string GetSelectedString()
		{
			if (!hasSelection)
			{
				return "";
			}
			int num = caretPositionInternal;
			int num2 = caretSelectPositionInternal;
			if (num > num2)
			{
				int num3 = num;
				num = num2;
				num2 = num3;
			}
			return text.Substring(num, num2 - num);
		}

		private int FindtNextWordBegin()
		{
			if (caretSelectPositionInternal + 1 >= text.Length)
			{
				return text.Length;
			}
			int num = text.IndexOfAny(kSeparators, caretSelectPositionInternal + 1);
			if (num == -1)
			{
				return text.Length;
			}
			return num + 1;
		}

		private void MoveRight(bool shift, bool ctrl)
		{
			int num;
			if (hasSelection && !shift)
			{
				num = (caretSelectPositionInternal = Mathf.Max(caretPositionInternal, caretSelectPositionInternal));
				caretPositionInternal = num;
				return;
			}
			int num3 = ((!ctrl) ? (caretSelectPositionInternal + 1) : FindtNextWordBegin());
			if (shift)
			{
				caretSelectPositionInternal = num3;
				return;
			}
			num = (caretPositionInternal = num3);
			caretSelectPositionInternal = num;
		}

		private int FindtPrevWordBegin()
		{
			if (caretSelectPositionInternal - 2 < 0)
			{
				return 0;
			}
			int num = text.LastIndexOfAny(kSeparators, caretSelectPositionInternal - 2);
			if (num == -1)
			{
				return 0;
			}
			return num + 1;
		}

		private void MoveLeft(bool shift, bool ctrl)
		{
			int num;
			if (hasSelection && !shift)
			{
				num = (caretSelectPositionInternal = Mathf.Min(caretPositionInternal, caretSelectPositionInternal));
				caretPositionInternal = num;
				return;
			}
			int num3 = ((!ctrl) ? (caretSelectPositionInternal - 1) : FindtPrevWordBegin());
			if (shift)
			{
				caretSelectPositionInternal = num3;
				return;
			}
			num = (caretPositionInternal = num3);
			caretSelectPositionInternal = num;
		}

		private int DetermineCharacterLine(int charPos, TextGenerator generator)
		{
			for (int i = 0; i < generator.lineCount - 1; i++)
			{
				if (generator.lines[i + 1].startCharIdx > charPos)
				{
					return i;
				}
			}
			return generator.lineCount - 1;
		}

		private int LineUpCharacterPosition(int originalPos, bool goToFirstChar)
		{
			if (originalPos >= cachedInputTextGenerator.characters.Count)
			{
				return 0;
			}
			UICharInfo uICharInfo = cachedInputTextGenerator.characters[originalPos];
			int num = DetermineCharacterLine(originalPos, cachedInputTextGenerator);
			if (num <= 0)
			{
				if (!goToFirstChar)
				{
					return originalPos;
				}
				return 0;
			}
			int num2 = cachedInputTextGenerator.lines[num].startCharIdx - 1;
			for (int i = cachedInputTextGenerator.lines[num - 1].startCharIdx; i < num2; i++)
			{
				if (cachedInputTextGenerator.characters[i].cursorPos.x >= uICharInfo.cursorPos.x)
				{
					return i;
				}
			}
			return num2;
		}

		private int LineDownCharacterPosition(int originalPos, bool goToLastChar)
		{
			if (originalPos >= cachedInputTextGenerator.characterCountVisible)
			{
				return text.Length;
			}
			UICharInfo uICharInfo = cachedInputTextGenerator.characters[originalPos];
			int num = DetermineCharacterLine(originalPos, cachedInputTextGenerator);
			if (num + 1 >= cachedInputTextGenerator.lineCount)
			{
				if (!goToLastChar)
				{
					return originalPos;
				}
				return text.Length;
			}
			int lineEndPosition = GetLineEndPosition(cachedInputTextGenerator, num + 1);
			for (int i = cachedInputTextGenerator.lines[num + 1].startCharIdx; i < lineEndPosition; i++)
			{
				if (cachedInputTextGenerator.characters[i].cursorPos.x >= uICharInfo.cursorPos.x)
				{
					return i;
				}
			}
			return lineEndPosition;
		}

		private void MoveDown(bool shift)
		{
			MoveDown(shift, goToLastChar: true);
		}

		private void MoveDown(bool shift, bool goToLastChar)
		{
			int num;
			if (hasSelection && !shift)
			{
				num = (caretSelectPositionInternal = Mathf.Max(caretPositionInternal, caretSelectPositionInternal));
				caretPositionInternal = num;
			}
			int num3 = (multiLine ? LineDownCharacterPosition(caretSelectPositionInternal, goToLastChar) : text.Length);
			if (shift)
			{
				caretSelectPositionInternal = num3;
				return;
			}
			num = (caretSelectPositionInternal = num3);
			caretPositionInternal = num;
		}

		private void MoveUp(bool shift)
		{
			MoveUp(shift, goToFirstChar: true);
		}

		private void MoveUp(bool shift, bool goToFirstChar)
		{
			int num;
			if (hasSelection && !shift)
			{
				num = (caretSelectPositionInternal = Mathf.Min(caretPositionInternal, caretSelectPositionInternal));
				caretPositionInternal = num;
			}
			int num3 = (multiLine ? LineUpCharacterPosition(caretSelectPositionInternal, goToFirstChar) : 0);
			if (shift)
			{
				caretSelectPositionInternal = num3;
				return;
			}
			num = (caretPositionInternal = num3);
			caretSelectPositionInternal = num;
		}

		private void Delete()
		{
			if (!m_ReadOnly && caretPositionInternal != caretSelectPositionInternal)
			{
				if (caretPositionInternal < caretSelectPositionInternal)
				{
					m_Text = text.Substring(0, caretPositionInternal) + text.Substring(caretSelectPositionInternal, text.Length - caretSelectPositionInternal);
					caretSelectPositionInternal = caretPositionInternal;
				}
				else
				{
					m_Text = text.Substring(0, caretSelectPositionInternal) + text.Substring(caretPositionInternal, text.Length - caretPositionInternal);
					caretPositionInternal = caretSelectPositionInternal;
				}
			}
		}

		private void ForwardSpace()
		{
			if (!m_ReadOnly)
			{
				if (hasSelection)
				{
					Delete();
					UpdateTouchKeyboardFromEditChanges();
					SendOnValueChangedAndUpdateLabel();
				}
				else if (caretPositionInternal < text.Length)
				{
					m_Text = text.Remove(caretPositionInternal, 1);
					UpdateTouchKeyboardFromEditChanges();
					SendOnValueChangedAndUpdateLabel();
				}
			}
		}

		private void Backspace()
		{
			if (!m_ReadOnly)
			{
				if (hasSelection)
				{
					Delete();
					UpdateTouchKeyboardFromEditChanges();
					SendOnValueChangedAndUpdateLabel();
				}
				else if (caretPositionInternal > 0)
				{
					m_Text = text.Remove(caretPositionInternal - 1, 1);
					caretSelectPositionInternal = --caretPositionInternal;
					UpdateTouchKeyboardFromEditChanges();
					SendOnValueChangedAndUpdateLabel();
				}
			}
		}

		private void Insert(char c)
		{
			if (!m_ReadOnly)
			{
				string text = c.ToString();
				Delete();
				if (characterLimit <= 0 || this.text.Length < characterLimit)
				{
					m_Text = this.text.Insert(m_CaretPosition, text);
					caretSelectPositionInternal = (caretPositionInternal += text.Length);
					UpdateTouchKeyboardFromEditChanges();
					SendOnValueChanged();
				}
			}
		}

		private void UpdateTouchKeyboardFromEditChanges()
		{
			if (m_Keyboard != null && InPlaceEditing())
			{
				m_Keyboard.text = m_Text;
			}
		}

		private void SendOnValueChangedAndUpdateLabel()
		{
			SendOnValueChanged();
			UpdateLabel();
		}

		private void SendOnValueChanged()
		{
			UISystemProfilerApi.AddMarker("InputField.value", this);
			if (onValueChanged != null)
			{
				onValueChanged.Invoke(text);
			}
		}

		protected void SendOnSubmit()
		{
			UISystemProfilerApi.AddMarker("InputField.onSubmit", this);
			if (onEndEdit != null)
			{
				onEndEdit.Invoke(m_Text);
			}
		}

		protected virtual void Append(string input)
		{
			if (m_ReadOnly || !InPlaceEditing())
			{
				return;
			}
			int i = 0;
			for (int length = input.Length; i < length; i++)
			{
				char c = input[i];
				if (c >= ' ' || c == '\t' || c == '\r' || c == '\n' || c == '\n')
				{
					Append(c);
				}
			}
		}

		protected virtual void Append(char input)
		{
			if (!char.IsSurrogate(input) && !m_ReadOnly && text.Length < 16382 && InPlaceEditing())
			{
				int num = Math.Min(selectionFocusPosition, selectionAnchorPosition);
				if (onValidateInput != null)
				{
					input = onValidateInput(text, num, input);
				}
				else if (characterValidation != CharacterValidation.None)
				{
					input = Validate(text, num, input);
				}
				if (input != 0)
				{
					Insert(input);
				}
			}
		}

		protected void UpdateLabel()
		{
			if (m_TextComponent != null && m_TextComponent.font != null && !m_PreventFontCallback)
			{
				m_PreventFontCallback = true;
				string text = ((compositionString.Length <= 0) ? this.text : (this.text.Substring(0, m_CaretPosition) + compositionString + this.text.Substring(m_CaretPosition)));
				string text2 = ((inputType != InputType.Password) ? text : new string(asteriskChar, text.Length));
				bool flag = string.IsNullOrEmpty(text);
				if (m_Placeholder != null)
				{
					m_Placeholder.enabled = flag;
				}
				if (!m_AllowInput)
				{
					m_DrawStart = 0;
					m_DrawEnd = m_Text.Length;
				}
				if (!flag)
				{
					Vector2 size = m_TextComponent.rectTransform.rect.size;
					TextGenerationSettings generationSettings = m_TextComponent.GetGenerationSettings(size);
					generationSettings.generateOutOfBounds = true;
					cachedInputTextGenerator.PopulateWithErrors(text2, generationSettings, base.gameObject);
					SetDrawRangeToContainCaretPosition(caretSelectPositionInternal);
					text2 = text2.Substring(m_DrawStart, Mathf.Min(m_DrawEnd, text2.Length) - m_DrawStart);
					SetCaretVisible();
				}
				m_TextComponent.text = text2;
				MarkGeometryAsDirty();
				m_PreventFontCallback = false;
			}
		}

		private bool IsSelectionVisible()
		{
			if (m_DrawStart > caretPositionInternal || m_DrawStart > caretSelectPositionInternal)
			{
				return false;
			}
			if (m_DrawEnd < caretPositionInternal || m_DrawEnd < caretSelectPositionInternal)
			{
				return false;
			}
			return true;
		}

		private static int GetLineStartPosition(TextGenerator gen, int line)
		{
			line = Mathf.Clamp(line, 0, gen.lines.Count - 1);
			return gen.lines[line].startCharIdx;
		}

		private static int GetLineEndPosition(TextGenerator gen, int line)
		{
			line = Mathf.Max(line, 0);
			if (line + 1 < gen.lines.Count)
			{
				return gen.lines[line + 1].startCharIdx - 1;
			}
			return gen.characterCountVisible;
		}

		private void SetDrawRangeToContainCaretPosition(int caretPos)
		{
			if (cachedInputTextGenerator.lineCount <= 0)
			{
				return;
			}
			Vector2 size = cachedInputTextGenerator.rectExtents.size;
			if (multiLine)
			{
				IList<UILineInfo> lines = cachedInputTextGenerator.lines;
				int num = DetermineCharacterLine(caretPos, cachedInputTextGenerator);
				if (caretPos > m_DrawEnd)
				{
					m_DrawEnd = GetLineEndPosition(cachedInputTextGenerator, num);
					float num2 = lines[num].topY - (float)lines[num].height;
					if (num == lines.Count - 1)
					{
						num2 += lines[num].leading;
					}
					int num3 = num;
					while (num3 > 0 && !(lines[num3 - 1].topY - num2 > size.y))
					{
						num3--;
					}
					m_DrawStart = GetLineStartPosition(cachedInputTextGenerator, num3);
					return;
				}
				if (caretPos < m_DrawStart)
				{
					m_DrawStart = GetLineStartPosition(cachedInputTextGenerator, num);
				}
				int num4 = DetermineCharacterLine(m_DrawStart, cachedInputTextGenerator);
				int i = num4;
				float topY = lines[num4].topY;
				float num5 = lines[i].topY - (float)lines[i].height;
				if (i == lines.Count - 1)
				{
					num5 += lines[i].leading;
				}
				for (; i < lines.Count - 1; i++)
				{
					num5 = lines[i + 1].topY - (float)lines[i + 1].height;
					if (i + 1 == lines.Count - 1)
					{
						num5 += lines[i + 1].leading;
					}
					if (topY - num5 > size.y)
					{
						break;
					}
				}
				m_DrawEnd = GetLineEndPosition(cachedInputTextGenerator, i);
				while (num4 > 0)
				{
					topY = lines[num4 - 1].topY;
					if (topY - num5 > size.y)
					{
						break;
					}
					num4--;
				}
				m_DrawStart = GetLineStartPosition(cachedInputTextGenerator, num4);
				return;
			}
			IList<UICharInfo> characters = cachedInputTextGenerator.characters;
			if (m_DrawEnd > cachedInputTextGenerator.characterCountVisible)
			{
				m_DrawEnd = cachedInputTextGenerator.characterCountVisible;
			}
			float num6 = 0f;
			if (caretPos > m_DrawEnd || (caretPos == m_DrawEnd && m_DrawStart > 0))
			{
				m_DrawEnd = caretPos;
				m_DrawStart = m_DrawEnd - 1;
				while (m_DrawStart >= 0 && !(num6 + characters[m_DrawStart].charWidth > size.x))
				{
					num6 += characters[m_DrawStart].charWidth;
					m_DrawStart--;
				}
				m_DrawStart++;
			}
			else
			{
				if (caretPos < m_DrawStart)
				{
					m_DrawStart = caretPos;
				}
				m_DrawEnd = m_DrawStart;
			}
			while (m_DrawEnd < cachedInputTextGenerator.characterCountVisible)
			{
				num6 += characters[m_DrawEnd].charWidth;
				if (!(num6 > size.x))
				{
					m_DrawEnd++;
					continue;
				}
				break;
			}
		}

		public void ForceLabelUpdate()
		{
			UpdateLabel();
		}

		private void MarkGeometryAsDirty()
		{
			CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);
		}

		public virtual void Rebuild(CanvasUpdate update)
		{
			if (update == CanvasUpdate.LatePreRender)
			{
				UpdateGeometry();
			}
		}

		public virtual void LayoutComplete()
		{
		}

		public virtual void GraphicUpdateComplete()
		{
		}

		private void UpdateGeometry()
		{
			if (shouldHideMobileInput)
			{
				if (m_CachedInputRenderer == null && m_TextComponent != null)
				{
					GameObject gameObject = new GameObject(base.transform.name + " Input Caret", typeof(RectTransform), typeof(CanvasRenderer));
					gameObject.hideFlags = HideFlags.DontSave;
					gameObject.transform.SetParent(m_TextComponent.transform.parent);
					gameObject.transform.SetAsFirstSibling();
					gameObject.layer = base.gameObject.layer;
					caretRectTrans = gameObject.GetComponent<RectTransform>();
					m_CachedInputRenderer = gameObject.GetComponent<CanvasRenderer>();
					m_CachedInputRenderer.SetMaterial(m_TextComponent.GetModifiedMaterial(Graphic.defaultGraphicMaterial), Texture2D.whiteTexture);
					gameObject.AddComponent<LayoutElement>().ignoreLayout = true;
					AssignPositioningIfNeeded();
				}
				if (!(m_CachedInputRenderer == null))
				{
					OnFillVBO(mesh);
					m_CachedInputRenderer.SetMesh(mesh);
				}
			}
		}

		private void AssignPositioningIfNeeded()
		{
			if (m_TextComponent != null && caretRectTrans != null && (caretRectTrans.localPosition != m_TextComponent.rectTransform.localPosition || caretRectTrans.localRotation != m_TextComponent.rectTransform.localRotation || caretRectTrans.localScale != m_TextComponent.rectTransform.localScale || caretRectTrans.anchorMin != m_TextComponent.rectTransform.anchorMin || caretRectTrans.anchorMax != m_TextComponent.rectTransform.anchorMax || caretRectTrans.anchoredPosition != m_TextComponent.rectTransform.anchoredPosition || caretRectTrans.sizeDelta != m_TextComponent.rectTransform.sizeDelta || caretRectTrans.pivot != m_TextComponent.rectTransform.pivot))
			{
				caretRectTrans.localPosition = m_TextComponent.rectTransform.localPosition;
				caretRectTrans.localRotation = m_TextComponent.rectTransform.localRotation;
				caretRectTrans.localScale = m_TextComponent.rectTransform.localScale;
				caretRectTrans.anchorMin = m_TextComponent.rectTransform.anchorMin;
				caretRectTrans.anchorMax = m_TextComponent.rectTransform.anchorMax;
				caretRectTrans.anchoredPosition = m_TextComponent.rectTransform.anchoredPosition;
				caretRectTrans.sizeDelta = m_TextComponent.rectTransform.sizeDelta;
				caretRectTrans.pivot = m_TextComponent.rectTransform.pivot;
			}
		}

		private void OnFillVBO(Mesh vbo)
		{
			using VertexHelper vertexHelper = new VertexHelper();
			if (!isFocused)
			{
				vertexHelper.FillMesh(vbo);
				return;
			}
			Vector2 roundingOffset = m_TextComponent.PixelAdjustPoint(Vector2.zero);
			if (!hasSelection)
			{
				GenerateCaret(vertexHelper, roundingOffset);
			}
			else
			{
				GenerateHighlight(vertexHelper, roundingOffset);
			}
			vertexHelper.FillMesh(vbo);
		}

		private void GenerateCaret(VertexHelper vbo, Vector2 roundingOffset)
		{
			if (!m_CaretVisible)
			{
				return;
			}
			if (m_CursorVerts == null)
			{
				CreateCursorVerts();
			}
			float num = m_CaretWidth;
			int num2 = Mathf.Max(0, caretPositionInternal - m_DrawStart);
			TextGenerator cachedTextGenerator = m_TextComponent.cachedTextGenerator;
			if (cachedTextGenerator == null || cachedTextGenerator.lineCount == 0)
			{
				return;
			}
			Vector2 zero = Vector2.zero;
			if (num2 < cachedTextGenerator.characters.Count)
			{
				zero.x = cachedTextGenerator.characters[num2].cursorPos.x;
			}
			zero.x /= m_TextComponent.pixelsPerUnit;
			if (zero.x > m_TextComponent.rectTransform.rect.xMax)
			{
				zero.x = m_TextComponent.rectTransform.rect.xMax;
			}
			int index = DetermineCharacterLine(num2, cachedTextGenerator);
			zero.y = cachedTextGenerator.lines[index].topY / m_TextComponent.pixelsPerUnit;
			float num3 = (float)cachedTextGenerator.lines[index].height / m_TextComponent.pixelsPerUnit;
			for (int i = 0; i < m_CursorVerts.Length; i++)
			{
				m_CursorVerts[i].color = caretColor;
			}
			m_CursorVerts[0].position = new Vector3(zero.x, zero.y - num3, 0f);
			m_CursorVerts[1].position = new Vector3(zero.x + num, zero.y - num3, 0f);
			m_CursorVerts[2].position = new Vector3(zero.x + num, zero.y, 0f);
			m_CursorVerts[3].position = new Vector3(zero.x, zero.y, 0f);
			if (roundingOffset != Vector2.zero)
			{
				for (int j = 0; j < m_CursorVerts.Length; j++)
				{
					UIVertex uIVertex = m_CursorVerts[j];
					uIVertex.position.x += roundingOffset.x;
					uIVertex.position.y += roundingOffset.y;
				}
			}
			vbo.AddUIVertexQuad(m_CursorVerts);
			int num4 = Screen.height;
			int targetDisplay = m_TextComponent.canvas.targetDisplay;
			if (targetDisplay > 0 && targetDisplay < Display.displays.Length)
			{
				num4 = Display.displays[targetDisplay].renderingHeight;
			}
			zero.y = (float)num4 - zero.y;
			input.compositionCursorPos = zero;
		}

		private void CreateCursorVerts()
		{
			m_CursorVerts = new UIVertex[4];
			for (int i = 0; i < m_CursorVerts.Length; i++)
			{
				m_CursorVerts[i] = UIVertex.simpleVert;
				m_CursorVerts[i].uv0 = Vector2.zero;
			}
		}

		private void GenerateHighlight(VertexHelper vbo, Vector2 roundingOffset)
		{
			int num = Mathf.Max(0, caretPositionInternal - m_DrawStart);
			int num2 = Mathf.Max(0, caretSelectPositionInternal - m_DrawStart);
			if (num > num2)
			{
				int num3 = num;
				num = num2;
				num2 = num3;
			}
			num2--;
			TextGenerator cachedTextGenerator = m_TextComponent.cachedTextGenerator;
			if (cachedTextGenerator.lineCount <= 0)
			{
				return;
			}
			int num4 = DetermineCharacterLine(num, cachedTextGenerator);
			int lineEndPosition = GetLineEndPosition(cachedTextGenerator, num4);
			UIVertex simpleVert = UIVertex.simpleVert;
			simpleVert.uv0 = Vector2.zero;
			simpleVert.color = selectionColor;
			for (int i = num; i <= num2 && i < cachedTextGenerator.characterCount; i++)
			{
				if (i == lineEndPosition || i == num2)
				{
					UICharInfo uICharInfo = cachedTextGenerator.characters[num];
					UICharInfo uICharInfo2 = cachedTextGenerator.characters[i];
					Vector2 vector = new Vector2(uICharInfo.cursorPos.x / m_TextComponent.pixelsPerUnit, cachedTextGenerator.lines[num4].topY / m_TextComponent.pixelsPerUnit);
					Vector2 vector2 = new Vector2((uICharInfo2.cursorPos.x + uICharInfo2.charWidth) / m_TextComponent.pixelsPerUnit, vector.y - (float)cachedTextGenerator.lines[num4].height / m_TextComponent.pixelsPerUnit);
					if (vector2.x > m_TextComponent.rectTransform.rect.xMax || vector2.x < m_TextComponent.rectTransform.rect.xMin)
					{
						vector2.x = m_TextComponent.rectTransform.rect.xMax;
					}
					int currentVertCount = vbo.currentVertCount;
					simpleVert.position = new Vector3(vector.x, vector2.y, 0f) + (Vector3)roundingOffset;
					vbo.AddVert(simpleVert);
					simpleVert.position = new Vector3(vector2.x, vector2.y, 0f) + (Vector3)roundingOffset;
					vbo.AddVert(simpleVert);
					simpleVert.position = new Vector3(vector2.x, vector.y, 0f) + (Vector3)roundingOffset;
					vbo.AddVert(simpleVert);
					simpleVert.position = new Vector3(vector.x, vector.y, 0f) + (Vector3)roundingOffset;
					vbo.AddVert(simpleVert);
					vbo.AddTriangle(currentVertCount, currentVertCount + 1, currentVertCount + 2);
					vbo.AddTriangle(currentVertCount + 2, currentVertCount + 3, currentVertCount);
					num = i + 1;
					num4++;
					lineEndPosition = GetLineEndPosition(cachedTextGenerator, num4);
				}
			}
		}

		protected char Validate(string text, int pos, char ch)
		{
			if (characterValidation == CharacterValidation.None || !base.enabled)
			{
				return ch;
			}
			if (characterValidation == CharacterValidation.Integer || characterValidation == CharacterValidation.Decimal)
			{
				bool num = pos == 0 && text.Length > 0 && text[0] == '-';
				bool flag = text.Length > 0 && text[0] == '-' && ((caretPositionInternal == 0 && caretSelectPositionInternal > 0) || (caretSelectPositionInternal == 0 && caretPositionInternal > 0));
				bool flag2 = caretPositionInternal == 0 || caretSelectPositionInternal == 0;
				if (!num || flag)
				{
					if (ch >= '0' && ch <= '9')
					{
						return ch;
					}
					if (ch == '-' && (pos == 0 || flag2))
					{
						return ch;
					}
					if ((ch == '.' || ch == ',') && characterValidation == CharacterValidation.Decimal && text.IndexOfAny(new char[2] { '.', ',' }) == -1)
					{
						return ch;
					}
				}
			}
			else if (characterValidation == CharacterValidation.Alphanumeric)
			{
				if (ch >= 'A' && ch <= 'Z')
				{
					return ch;
				}
				if (ch >= 'a' && ch <= 'z')
				{
					return ch;
				}
				if (ch >= '0' && ch <= '9')
				{
					return ch;
				}
			}
			else if (characterValidation == CharacterValidation.Name)
			{
				if (char.IsLetter(ch))
				{
					if (char.IsLower(ch) && (pos == 0 || text[pos - 1] == ' '))
					{
						return char.ToUpper(ch);
					}
					if (char.IsUpper(ch) && pos > 0 && text[pos - 1] != ' ' && text[pos - 1] != '\'')
					{
						return char.ToLower(ch);
					}
					return ch;
				}
				if (ch == '\'' && !text.Contains("'") && (pos <= 0 || (text[pos - 1] != ' ' && text[pos - 1] != '\'')) && (pos >= text.Length || (text[pos] != ' ' && text[pos] != '\'')))
				{
					return ch;
				}
				if (ch == ' ' && pos != 0 && (pos <= 0 || (text[pos - 1] != ' ' && text[pos - 1] != '\'')) && (pos >= text.Length || (text[pos] != ' ' && text[pos] != '\'')))
				{
					return ch;
				}
			}
			else if (characterValidation == CharacterValidation.EmailAddress)
			{
				if (ch >= 'A' && ch <= 'Z')
				{
					return ch;
				}
				if (ch >= 'a' && ch <= 'z')
				{
					return ch;
				}
				if (ch >= '0' && ch <= '9')
				{
					return ch;
				}
				if (ch == '@' && text.IndexOf('@') == -1)
				{
					return ch;
				}
				if ("!#$%&'*+-/=?^_`{|}~".IndexOf(ch) != -1)
				{
					return ch;
				}
				if (ch == '.')
				{
					char num2 = ((text.Length > 0) ? text[Mathf.Clamp(pos, 0, text.Length - 1)] : ' ');
					char c = ((text.Length > 0) ? text[Mathf.Clamp(pos + 1, 0, text.Length - 1)] : '\n');
					if (num2 != '.' && c != '.')
					{
						return ch;
					}
				}
			}
			return '\0';
		}

		public void ActivateInputField()
		{
			if (!(m_TextComponent == null) && !(m_TextComponent.font == null) && IsActive() && IsInteractable())
			{
				if (isFocused && m_Keyboard != null && !m_Keyboard.active)
				{
					m_Keyboard.active = true;
					m_Keyboard.text = m_Text;
				}
				m_ShouldActivateNextUpdate = true;
			}
		}

		private void ActivateInputFieldInternal()
		{
			if (EventSystem.current == null)
			{
				return;
			}
			if (EventSystem.current.currentSelectedGameObject != base.gameObject)
			{
				EventSystem.current.SetSelectedGameObject(base.gameObject);
			}
			if (TouchScreenKeyboard.isSupported)
			{
				if (input.touchSupported)
				{
					TouchScreenKeyboard.hideInput = shouldHideMobileInput;
				}
				m_Keyboard = ((inputType == InputType.Password) ? TouchScreenKeyboard.Open(m_Text, keyboardType, autocorrection: false, multiLine, secure: true, alert: false, "", characterLimit) : TouchScreenKeyboard.Open(m_Text, keyboardType, inputType == InputType.AutoCorrect, multiLine, secure: false, alert: false, "", characterLimit));
				m_TouchKeyboardAllowsInPlaceEditing = TouchScreenKeyboard.isInPlaceEditingAllowed;
				MoveTextEnd(shift: false);
			}
			else
			{
				input.imeCompositionMode = IMECompositionMode.On;
				OnFocus();
			}
			m_AllowInput = true;
			m_OriginalText = text;
			m_WasCanceled = false;
			SetCaretVisible();
			UpdateLabel();
		}

		public override void OnSelect(BaseEventData eventData)
		{
			base.OnSelect(eventData);
			if (shouldActivateOnSelect)
			{
				ActivateInputField();
			}
		}

		public virtual void OnPointerClick(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left)
			{
				ActivateInputField();
			}
		}

		public void DeactivateInputField()
		{
			if (!m_AllowInput)
			{
				return;
			}
			m_HasDoneFocusTransition = false;
			m_AllowInput = false;
			if (m_Placeholder != null)
			{
				m_Placeholder.enabled = string.IsNullOrEmpty(m_Text);
			}
			if (m_TextComponent != null && IsInteractable())
			{
				if (m_WasCanceled)
				{
					text = m_OriginalText;
				}
				SendOnSubmit();
				if (m_Keyboard != null)
				{
					m_Keyboard.active = false;
					m_Keyboard = null;
				}
				m_CaretPosition = (m_CaretSelectPosition = 0);
				input.imeCompositionMode = IMECompositionMode.Auto;
			}
			MarkGeometryAsDirty();
		}

		public override void OnDeselect(BaseEventData eventData)
		{
			DeactivateInputField();
			base.OnDeselect(eventData);
		}

		public virtual void OnSubmit(BaseEventData eventData)
		{
			if (IsActive() && IsInteractable() && !isFocused)
			{
				m_ShouldActivateNextUpdate = true;
			}
		}

		private void EnforceContentType()
		{
			switch (contentType)
			{
			case ContentType.Standard:
				m_InputType = InputType.Standard;
				m_KeyboardType = TouchScreenKeyboardType.Default;
				m_CharacterValidation = CharacterValidation.None;
				break;
			case ContentType.Autocorrected:
				m_InputType = InputType.AutoCorrect;
				m_KeyboardType = TouchScreenKeyboardType.Default;
				m_CharacterValidation = CharacterValidation.None;
				break;
			case ContentType.IntegerNumber:
				m_LineType = LineType.SingleLine;
				m_InputType = InputType.Standard;
				m_KeyboardType = TouchScreenKeyboardType.NumberPad;
				m_CharacterValidation = CharacterValidation.Integer;
				break;
			case ContentType.DecimalNumber:
				m_LineType = LineType.SingleLine;
				m_InputType = InputType.Standard;
				m_KeyboardType = TouchScreenKeyboardType.NumbersAndPunctuation;
				m_CharacterValidation = CharacterValidation.Decimal;
				break;
			case ContentType.Alphanumeric:
				m_LineType = LineType.SingleLine;
				m_InputType = InputType.Standard;
				m_KeyboardType = TouchScreenKeyboardType.ASCIICapable;
				m_CharacterValidation = CharacterValidation.Alphanumeric;
				break;
			case ContentType.Name:
				m_LineType = LineType.SingleLine;
				m_InputType = InputType.Standard;
				m_KeyboardType = TouchScreenKeyboardType.NamePhonePad;
				m_CharacterValidation = CharacterValidation.Name;
				break;
			case ContentType.EmailAddress:
				m_LineType = LineType.SingleLine;
				m_InputType = InputType.Standard;
				m_KeyboardType = TouchScreenKeyboardType.EmailAddress;
				m_CharacterValidation = CharacterValidation.EmailAddress;
				break;
			case ContentType.Password:
				m_LineType = LineType.SingleLine;
				m_InputType = InputType.Password;
				m_KeyboardType = TouchScreenKeyboardType.Default;
				m_CharacterValidation = CharacterValidation.None;
				break;
			case ContentType.Pin:
				m_LineType = LineType.SingleLine;
				m_InputType = InputType.Password;
				m_KeyboardType = TouchScreenKeyboardType.NumberPad;
				m_CharacterValidation = CharacterValidation.Integer;
				break;
			}
			EnforceTextHOverflow();
		}

		private void EnforceTextHOverflow()
		{
			if (m_TextComponent != null)
			{
				if (multiLine)
				{
					m_TextComponent.horizontalOverflow = HorizontalWrapMode.Wrap;
				}
				else
				{
					m_TextComponent.horizontalOverflow = HorizontalWrapMode.Overflow;
				}
			}
		}

		private void SetToCustomIfContentTypeIsNot(params ContentType[] allowedContentTypes)
		{
			if (contentType == ContentType.Custom)
			{
				return;
			}
			for (int i = 0; i < allowedContentTypes.Length; i++)
			{
				if (contentType == allowedContentTypes[i])
				{
					return;
				}
			}
			contentType = ContentType.Custom;
		}

		private void SetToCustom()
		{
			if (contentType != ContentType.Custom)
			{
				contentType = ContentType.Custom;
			}
		}

		protected override void DoStateTransition(SelectionState state, bool instant)
		{
			if (m_HasDoneFocusTransition)
			{
				state = SelectionState.Selected;
			}
			else if (state == SelectionState.Pressed)
			{
				m_HasDoneFocusTransition = true;
			}
			base.DoStateTransition(state, instant);
		}

		public virtual void CalculateLayoutInputHorizontal()
		{
		}

		public virtual void CalculateLayoutInputVertical()
		{
		}

		Transform ICanvasElement.get_transform()
		{
			return base.transform;
		}
	}
	[AddComponentMenu("Layout/Aspect Ratio Fitter", 142)]
	[ExecuteAlways]
	[RequireComponent(typeof(RectTransform))]
	[DisallowMultipleComponent]
	public class AspectRatioFitter : UIBehaviour, ILayoutSelfController, ILayoutController
	{
		public enum AspectMode
		{
			None,
			WidthControlsHeight,
			HeightControlsWidth,
			FitInParent,
			EnvelopeParent
		}

		[SerializeField]
		private AspectMode m_AspectMode;

		[SerializeField]
		private float m_AspectRatio = 1f;

		[NonSerialized]
		private RectTransform m_Rect;

		private bool m_DelayedSetDirty;

		private DrivenRectTransformTracker m_Tracker;

		public AspectMode aspectMode
		{
			get
			{
				return m_AspectMode;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_AspectMode, value))
				{
					SetDirty();
				}
			}
		}

		public float aspectRatio
		{
			get
			{
				return m_AspectRatio;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_AspectRatio, value))
				{
					SetDirty();
				}
			}
		}

		private RectTransform rectTransform
		{
			get
			{
				if (m_Rect == null)
				{
					m_Rect = GetComponent<RectTransform>();
				}
				return m_Rect;
			}
		}

		protected AspectRatioFitter()
		{
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			SetDirty();
		}

		protected override void OnDisable()
		{
			m_Tracker.Clear();
			LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
			base.OnDisable();
		}

		protected virtual void Update()
		{
			if (m_DelayedSetDirty)
			{
				m_DelayedSetDirty = false;
				SetDirty();
			}
		}

		protected override void OnRectTransformDimensionsChange()
		{
			UpdateRect();
		}

		private void UpdateRect()
		{
			if (!IsActive())
			{
				return;
			}
			m_Tracker.Clear();
			switch (m_AspectMode)
			{
			case AspectMode.HeightControlsWidth:
				m_Tracker.Add(this, rectTransform, DrivenTransformProperties.SizeDeltaX);
				rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, rectTransform.rect.height * m_AspectRatio);
				break;
			case AspectMode.WidthControlsHeight:
				m_Tracker.Add(this, rectTransform, DrivenTransformProperties.SizeDeltaY);
				rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, rectTransform.rect.width / m_AspectRatio);
				break;
			case AspectMode.FitInParent:
			case AspectMode.EnvelopeParent:
			{
				m_Tracker.Add(this, rectTransform, DrivenTransformProperties.Anchors | DrivenTransformProperties.AnchoredPosition | DrivenTransformProperties.SizeDelta);
				rectTransform.anchorMin = Vector2.zero;
				rectTransform.anchorMax = Vector2.one;
				rectTransform.anchoredPosition = Vector2.zero;
				Vector2 zero = Vector2.zero;
				Vector2 parentSize = GetParentSize();
				if ((parentSize.y * aspectRatio < parentSize.x) ^ (m_AspectMode == AspectMode.FitInParent))
				{
					zero.y = GetSizeDeltaToProduceSize(parentSize.x / aspectRatio, 1);
				}
				else
				{
					zero.x = GetSizeDeltaToProduceSize(parentSize.y * aspectRatio, 0);
				}
				rectTransform.sizeDelta = zero;
				break;
			}
			}
		}

		private float GetSizeDeltaToProduceSize(float size, int axis)
		{
			return size - GetParentSize()[axis] * (rectTransform.anchorMax[axis] - rectTransform.anchorMin[axis]);
		}

		private Vector2 GetParentSize()
		{
			RectTransform rectTransform = this.rectTransform.parent as RectTransform;
			if (!rectTransform)
			{
				return Vector2.zero;
			}
			return rectTransform.rect.size;
		}

		public virtual void SetLayoutHorizontal()
		{
		}

		public virtual void SetLayoutVertical()
		{
		}

		protected void SetDirty()
		{
			UpdateRect();
		}
	}
	[RequireComponent(typeof(Canvas))]
	[ExecuteAlways]
	[AddComponentMenu("Layout/Canvas Scaler", 101)]
	[DisallowMultipleComponent]
	public class CanvasScaler : UIBehaviour
	{
		public enum ScaleMode
		{
			ConstantPixelSize,
			ScaleWithScreenSize,
			ConstantPhysicalSize
		}

		public enum ScreenMatchMode
		{
			MatchWidthOrHeight,
			Expand,
			Shrink
		}

		public enum Unit
		{
			Centimeters,
			Millimeters,
			Inches,
			Points,
			Picas
		}

		[Tooltip("Determines how UI elements in the Canvas are scaled.")]
		[SerializeField]
		private ScaleMode m_UiScaleMode;

		[Tooltip("If a sprite has this 'Pixels Per Unit' setting, then one pixel in the sprite will cover one unit in the UI.")]
		[SerializeField]
		protected float m_ReferencePixelsPerUnit = 100f;

		[Tooltip("Scales all UI elements in the Canvas by this factor.")]
		[SerializeField]
		protected float m_ScaleFactor = 1f;

		[Tooltip("The resolution the UI layout is designed for. If the screen resolution is larger, the UI will be scaled up, and if it's smaller, the UI will be scaled down. This is done in accordance with the Screen Match Mode.")]
		[SerializeField]
		protected Vector2 m_ReferenceResolution = new Vector2(800f, 600f);

		[Tooltip("A mode used to scale the canvas area if the aspect ratio of the current resolution doesn't fit the reference resolution.")]
		[SerializeField]
		protected ScreenMatchMode m_ScreenMatchMode;

		[Tooltip("Determines if the scaling is using the width or height as reference, or a mix in between.")]
		[Range(0f, 1f)]
		[SerializeField]
		protected float m_MatchWidthOrHeight;

		private const float kLogBase = 2f;

		[Tooltip("The physical unit to specify positions and sizes in.")]
		[SerializeField]
		protected Unit m_PhysicalUnit = Unit.Points;

		[Tooltip("The DPI to assume if the screen DPI is not known.")]
		[SerializeField]
		protected float m_FallbackScreenDPI = 96f;

		[Tooltip("The pixels per inch to use for sprites that have a 'Pixels Per Unit' setting that matches the 'Reference Pixels Per Unit' setting.")]
		[SerializeField]
		protected float m_DefaultSpriteDPI = 96f;

		[Tooltip("The amount of pixels per unit to use for dynamically created bitmaps in the UI, such as Text.")]
		[SerializeField]
		protected float m_DynamicPixelsPerUnit = 1f;

		private Canvas m_Canvas;

		[NonSerialized]
		private float m_PrevScaleFactor = 1f;

		[NonSerialized]
		private float m_PrevReferencePixelsPerUnit = 100f;

		public ScaleMode uiScaleMode
		{
			get
			{
				return m_UiScaleMode;
			}
			set
			{
				m_UiScaleMode = value;
			}
		}

		public float referencePixelsPerUnit
		{
			get
			{
				return m_ReferencePixelsPerUnit;
			}
			set
			{
				m_ReferencePixelsPerUnit = value;
			}
		}

		public float scaleFactor
		{
			get
			{
				return m_ScaleFactor;
			}
			set
			{
				m_ScaleFactor = Mathf.Max(0.01f, value);
			}
		}

		public Vector2 referenceResolution
		{
			get
			{
				return m_ReferenceResolution;
			}
			set
			{
				m_ReferenceResolution = value;
				if (m_ReferenceResolution.x > -1E-05f && m_ReferenceResolution.x < 1E-05f)
				{
					m_ReferenceResolution.x = 1E-05f * Mathf.Sign(m_ReferenceResolution.x);
				}
				if (m_ReferenceResolution.y > -1E-05f && m_ReferenceResolution.y < 1E-05f)
				{
					m_ReferenceResolution.y = 1E-05f * Mathf.Sign(m_ReferenceResolution.y);
				}
			}
		}

		public ScreenMatchMode screenMatchMode
		{
			get
			{
				return m_ScreenMatchMode;
			}
			set
			{
				m_ScreenMatchMode = value;
			}
		}

		public float matchWidthOrHeight
		{
			get
			{
				return m_MatchWidthOrHeight;
			}
			set
			{
				m_MatchWidthOrHeight = value;
			}
		}

		public Unit physicalUnit
		{
			get
			{
				return m_PhysicalUnit;
			}
			set
			{
				m_PhysicalUnit = value;
			}
		}

		public float fallbackScreenDPI
		{
			get
			{
				return m_FallbackScreenDPI;
			}
			set
			{
				m_FallbackScreenDPI = value;
			}
		}

		public float defaultSpriteDPI
		{
			get
			{
				return m_DefaultSpriteDPI;
			}
			set
			{
				m_DefaultSpriteDPI = Mathf.Max(1f, value);
			}
		}

		public float dynamicPixelsPerUnit
		{
			get
			{
				return m_DynamicPixelsPerUnit;
			}
			set
			{
				m_DynamicPixelsPerUnit = value;
			}
		}

		protected CanvasScaler()
		{
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			m_Canvas = GetComponent<Canvas>();
			Handle();
		}

		protected override void OnDisable()
		{
			SetScaleFactor(1f);
			SetReferencePixelsPerUnit(100f);
			base.OnDisable();
		}

		protected virtual void Update()
		{
			Handle();
		}

		protected virtual void Handle()
		{
			if (m_Canvas == null || !m_Canvas.isRootCanvas)
			{
				return;
			}
			if (m_Canvas.renderMode == RenderMode.WorldSpace)
			{
				HandleWorldCanvas();
				return;
			}
			switch (m_UiScaleMode)
			{
			case ScaleMode.ConstantPixelSize:
				HandleConstantPixelSize();
				break;
			case ScaleMode.ScaleWithScreenSize:
				HandleScaleWithScreenSize();
				break;
			case ScaleMode.ConstantPhysicalSize:
				HandleConstantPhysicalSize();
				break;
			}
		}

		protected virtual void HandleWorldCanvas()
		{
			SetScaleFactor(m_DynamicPixelsPerUnit);
			SetReferencePixelsPerUnit(m_ReferencePixelsPerUnit);
		}

		protected virtual void HandleConstantPixelSize()
		{
			SetScaleFactor(m_ScaleFactor);
			SetReferencePixelsPerUnit(m_ReferencePixelsPerUnit);
		}

		protected virtual void HandleScaleWithScreenSize()
		{
			Vector2 vector = new Vector2(Screen.width, Screen.height);
			int targetDisplay = m_Canvas.targetDisplay;
			if (targetDisplay > 0 && targetDisplay < Display.displays.Length)
			{
				Display display = Display.displays[targetDisplay];
				vector = new Vector2(display.renderingWidth, display.renderingHeight);
			}
			float num = 0f;
			switch (m_ScreenMatchMode)
			{
			case ScreenMatchMode.MatchWidthOrHeight:
			{
				float a = Mathf.Log(vector.x / m_ReferenceResolution.x, 2f);
				float b = Mathf.Log(vector.y / m_ReferenceResolution.y, 2f);
				float p = Mathf.Lerp(a, b, m_MatchWidthOrHeight);
				num = Mathf.Pow(2f, p);
				break;
			}
			case ScreenMatchMode.Expand:
				num = Mathf.Min(vector.x / m_ReferenceResolution.x, vector.y / m_ReferenceResolution.y);
				break;
			case ScreenMatchMode.Shrink:
				num = Mathf.Max(vector.x / m_ReferenceResolution.x, vector.y / m_ReferenceResolution.y);
				break;
			}
			SetScaleFactor(num);
			SetReferencePixelsPerUnit(m_ReferencePixelsPerUnit);
		}

		protected virtual void HandleConstantPhysicalSize()
		{
			float dpi = Screen.dpi;
			float num = ((dpi == 0f) ? m_FallbackScreenDPI : dpi);
			float num2 = 1f;
			switch (m_PhysicalUnit)
			{
			case Unit.Centimeters:
				num2 = 2.54f;
				break;
			case Unit.Millimeters:
				num2 = 25.4f;
				break;
			case Unit.Inches:
				num2 = 1f;
				break;
			case Unit.Points:
				num2 = 72f;
				break;
			case Unit.Picas:
				num2 = 6f;
				break;
			}
			SetScaleFactor(num / num2);
			SetReferencePixelsPerUnit(m_ReferencePixelsPerUnit * num2 / m_DefaultSpriteDPI);
		}

		protected void SetScaleFactor(float scaleFactor)
		{
			if (scaleFactor != m_PrevScaleFactor)
			{
				m_Canvas.scaleFactor = scaleFactor;
				m_PrevScaleFactor = scaleFactor;
			}
		}

		protected void SetReferencePixelsPerUnit(float referencePixelsPerUnit)
		{
			if (referencePixelsPerUnit != m_PrevReferencePixelsPerUnit)
			{
				m_Canvas.referencePixelsPerUnit = referencePixelsPerUnit;
				m_PrevReferencePixelsPerUnit = referencePixelsPerUnit;
			}
		}
	}
	[AddComponentMenu("Layout/Content Size Fitter", 141)]
	[ExecuteAlways]
	[RequireComponent(typeof(RectTransform))]
	public class ContentSizeFitter : UIBehaviour, ILayoutSelfController, ILayoutController
	{
		public enum FitMode
		{
			Unconstrained,
			MinSize,
			PreferredSize
		}

		[SerializeField]
		protected FitMode m_HorizontalFit;

		[SerializeField]
		protected FitMode m_VerticalFit;

		[NonSerialized]
		private RectTransform m_Rect;

		private DrivenRectTransformTracker m_Tracker;

		public FitMode horizontalFit
		{
			get
			{
				return m_HorizontalFit;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_HorizontalFit, value))
				{
					SetDirty();
				}
			}
		}

		public FitMode verticalFit
		{
			get
			{
				return m_VerticalFit;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_VerticalFit, value))
				{
					SetDirty();
				}
			}
		}

		private RectTransform rectTransform
		{
			get
			{
				if (m_Rect == null)
				{
					m_Rect = GetComponent<RectTransform>();
				}
				return m_Rect;
			}
		}

		protected ContentSizeFitter()
		{
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			SetDirty();
		}

		protected override void OnDisable()
		{
			m_Tracker.Clear();
			LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
			base.OnDisable();
		}

		protected override void OnRectTransformDimensionsChange()
		{
			SetDirty();
		}

		private void HandleSelfFittingAlongAxis(int axis)
		{
			FitMode fitMode = ((axis == 0) ? horizontalFit : verticalFit);
			if (fitMode == FitMode.Unconstrained)
			{
				m_Tracker.Add(this, rectTransform, DrivenTransformProperties.None);
				return;
			}
			m_Tracker.Add(this, rectTransform, (axis == 0) ? DrivenTransformProperties.SizeDeltaX : DrivenTransformProperties.SizeDeltaY);
			if (fitMode == FitMode.MinSize)
			{
				rectTransform.SetSizeWithCurrentAnchors((RectTransform.Axis)axis, LayoutUtility.GetMinSize(m_Rect, axis));
			}
			else
			{
				rectTransform.SetSizeWithCurrentAnchors((RectTransform.Axis)axis, LayoutUtility.GetPreferredSize(m_Rect, axis));
			}
		}

		public virtual void SetLayoutHorizontal()
		{
			m_Tracker.Clear();
			HandleSelfFittingAlongAxis(0);
		}

		public virtual void SetLayoutVertical()
		{
			HandleSelfFittingAlongAxis(1);
		}

		protected void SetDirty()
		{
			if (IsActive())
			{
				LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
			}
		}
	}
	[AddComponentMenu("Layout/Grid Layout Group", 152)]
	public class GridLayoutGroup : LayoutGroup
	{
		public enum Corner
		{
			UpperLeft,
			UpperRight,
			LowerLeft,
			LowerRight
		}

		public enum Axis
		{
			Horizontal,
			Vertical
		}

		public enum Constraint
		{
			Flexible,
			FixedColumnCount,
			FixedRowCount
		}

		[SerializeField]
		protected Corner m_StartCorner;

		[SerializeField]
		protected Axis m_StartAxis;

		[SerializeField]
		protected Vector2 m_CellSize = new Vector2(100f, 100f);

		[SerializeField]
		protected Vector2 m_Spacing = Vector2.zero;

		[SerializeField]
		protected Constraint m_Constraint;

		[SerializeField]
		protected int m_ConstraintCount = 2;

		public Corner startCorner
		{
			get
			{
				return m_StartCorner;
			}
			set
			{
				SetProperty(ref m_StartCorner, value);
			}
		}

		public Axis startAxis
		{
			get
			{
				return m_StartAxis;
			}
			set
			{
				SetProperty(ref m_StartAxis, value);
			}
		}

		public Vector2 cellSize
		{
			get
			{
				return m_CellSize;
			}
			set
			{
				SetProperty(ref m_CellSize, value);
			}
		}

		public Vector2 spacing
		{
			get
			{
				return m_Spacing;
			}
			set
			{
				SetProperty(ref m_Spacing, value);
			}
		}

		public Constraint constraint
		{
			get
			{
				return m_Constraint;
			}
			set
			{
				SetProperty(ref m_Constraint, value);
			}
		}

		public int constraintCount
		{
			get
			{
				return m_ConstraintCount;
			}
			set
			{
				SetProperty(ref m_ConstraintCount, Mathf.Max(1, value));
			}
		}

		protected GridLayoutGroup()
		{
		}

		public override void CalculateLayoutInputHorizontal()
		{
			base.CalculateLayoutInputHorizontal();
			int num = 0;
			int num2 = 0;
			if (m_Constraint == Constraint.FixedColumnCount)
			{
				num = (num2 = m_ConstraintCount);
			}
			else if (m_Constraint == Constraint.FixedRowCount)
			{
				num = (num2 = Mathf.CeilToInt((float)base.rectChildren.Count / (float)m_ConstraintCount - 0.001f));
			}
			else
			{
				num = 1;
				num2 = Mathf.CeilToInt(Mathf.Sqrt(base.rectChildren.Count));
			}
			SetLayoutInputForAxis((float)base.padding.horizontal + (cellSize.x + spacing.x) * (float)num - spacing.x, (float)base.padding.horizontal + (cellSize.x + spacing.x) * (float)num2 - spacing.x, -1f, 0);
		}

		public override void CalculateLayoutInputVertical()
		{
			int num = 0;
			if (m_Constraint == Constraint.FixedColumnCount)
			{
				num = Mathf.CeilToInt((float)base.rectChildren.Count / (float)m_ConstraintCount - 0.001f);
			}
			else if (m_Constraint == Constraint.FixedRowCount)
			{
				num = m_ConstraintCount;
			}
			else
			{
				float width = base.rectTransform.rect.width;
				int num2 = Mathf.Max(1, Mathf.FloorToInt((width - (float)base.padding.horizontal + spacing.x + 0.001f) / (cellSize.x + spacing.x)));
				num = Mathf.CeilToInt((float)base.rectChildren.Count / (float)num2);
			}
			float num3 = (float)base.padding.vertical + (cellSize.y + spacing.y) * (float)num - spacing.y;
			SetLayoutInputForAxis(num3, num3, -1f, 1);
		}

		public override void SetLayoutHorizontal()
		{
			SetCellsAlongAxis(0);
		}

		public override void SetLayoutVertical()
		{
			SetCellsAlongAxis(1);
		}

		private void SetCellsAlongAxis(int axis)
		{
			if (axis == 0)
			{
				for (int i = 0; i < base.rectChildren.Count; i++)
				{
					RectTransform rectTransform = base.rectChildren[i];
					m_Tracker.Add(this, rectTransform, DrivenTransformProperties.Anchors | DrivenTransformProperties.AnchoredPosition | DrivenTransformProperties.SizeDelta);
					rectTransform.anchorMin = Vector2.up;
					rectTransform.anchorMax = Vector2.up;
					rectTransform.sizeDelta = cellSize;
				}
				return;
			}
			float x = base.rectTransform.rect.size.x;
			float y = base.rectTransform.rect.size.y;
			int num = 1;
			int num2 = 1;
			if (m_Constraint == Constraint.FixedColumnCount)
			{
				num = m_ConstraintCount;
				if (base.rectChildren.Count > num)
				{
					num2 = base.rectChildren.Count / num + ((base.rectChildren.Count % num > 0) ? 1 : 0);
				}
			}
			else if (m_Constraint != Constraint.FixedRowCount)
			{
				num = ((!(cellSize.x + spacing.x <= 0f)) ? Mathf.Max(1, Mathf.FloorToInt((x - (float)base.padding.horizontal + spacing.x + 0.001f) / (cellSize.x + spacing.x))) : int.MaxValue);
				num2 = ((!(cellSize.y + spacing.y <= 0f)) ? Mathf.Max(1, Mathf.FloorToInt((y - (float)base.padding.vertical + spacing.y + 0.001f) / (cellSize.y + spacing.y))) : int.MaxValue);
			}
			else
			{
				num2 = m_ConstraintCount;
				if (base.rectChildren.Count > num2)
				{
					num = base.rectChildren.Count / num2 + ((base.rectChildren.Count % num2 > 0) ? 1 : 0);
				}
			}
			int num3 = (int)startCorner % 2;
			int num4 = (int)startCorner / 2;
			int num5;
			int num6;
			int num7;
			if (startAxis == Axis.Horizontal)
			{
				num5 = num;
				num6 = Mathf.Clamp(num, 1, base.rectChildren.Count);
				num7 = Mathf.Clamp(num2, 1, Mathf.CeilToInt((float)base.rectChildren.Count / (float)num5));
			}
			else
			{
				num5 = num2;
				num7 = Mathf.Clamp(num2, 1, base.rectChildren.Count);
				num6 = Mathf.Clamp(num, 1, Mathf.CeilToInt((float)base.rectChildren.Count / (float)num5));
			}
			Vector2 vector = new Vector2((float)num6 * cellSize.x + (float)(num6 - 1) * spacing.x, (float)num7 * cellSize.y + (float)(num7 - 1) * spacing.y);
			Vector2 vector2 = new Vector2(GetStartOffset(0, vector.x), GetStartOffset(1, vector.y));
			for (int j = 0; j < base.rectChildren.Count; j++)
			{
				int num8;
				int num9;
				if (startAxis == Axis.Horizontal)
				{
					num8 = j % num5;
					num9 = j / num5;
				}
				else
				{
					num8 = j / num5;
					num9 = j % num5;
				}
				if (num3 == 1)
				{
					num8 = num6 - 1 - num8;
				}
				if (num4 == 1)
				{
					num9 = num7 - 1 - num9;
				}
				SetChildAlongAxis(base.rectChildren[j], 0, vector2.x + (cellSize[0] + spacing[0]) * (float)num8, cellSize[0]);
				SetChildAlongAxis(base.rectChildren[j], 1, vector2.y + (cellSize[1] + spacing[1]) * (float)num9, cellSize[1]);
			}
		}
	}
	[AddComponentMenu("Layout/Horizontal Layout Group", 150)]
	public class HorizontalLayoutGroup : HorizontalOrVerticalLayoutGroup
	{
		protected HorizontalLayoutGroup()
		{
		}

		public override void CalculateLayoutInputHorizontal()
		{
			base.CalculateLayoutInputHorizontal();
			CalcAlongAxis(0, isVertical: false);
		}

		public override void CalculateLayoutInputVertical()
		{
			CalcAlongAxis(1, isVertical: false);
		}

		public override void SetLayoutHorizontal()
		{
			SetChildrenAlongAxis(0, isVertical: false);
		}

		public override void SetLayoutVertical()
		{
			SetChildrenAlongAxis(1, isVertical: false);
		}
	}
	[ExecuteAlways]
	public abstract class HorizontalOrVerticalLayoutGroup : LayoutGroup
	{
		[SerializeField]
		protected float m_Spacing;

		[SerializeField]
		protected bool m_ChildForceExpandWidth = true;

		[SerializeField]
		protected bool m_ChildForceExpandHeight = true;

		[SerializeField]
		protected bool m_ChildControlWidth = true;

		[SerializeField]
		protected bool m_ChildControlHeight = true;

		[SerializeField]
		protected bool m_ChildScaleWidth;

		[SerializeField]
		protected bool m_ChildScaleHeight;

		public float spacing
		{
			get
			{
				return m_Spacing;
			}
			set
			{
				SetProperty(ref m_Spacing, value);
			}
		}

		public bool childForceExpandWidth
		{
			get
			{
				return m_ChildForceExpandWidth;
			}
			set
			{
				SetProperty(ref m_ChildForceExpandWidth, value);
			}
		}

		public bool childForceExpandHeight
		{
			get
			{
				return m_ChildForceExpandHeight;
			}
			set
			{
				SetProperty(ref m_ChildForceExpandHeight, value);
			}
		}

		public bool childControlWidth
		{
			get
			{
				return m_ChildControlWidth;
			}
			set
			{
				SetProperty(ref m_ChildControlWidth, value);
			}
		}

		public bool childControlHeight
		{
			get
			{
				return m_ChildControlHeight;
			}
			set
			{
				SetProperty(ref m_ChildControlHeight, value);
			}
		}

		public bool childScaleWidth
		{
			get
			{
				return m_ChildScaleWidth;
			}
			set
			{
				SetProperty(ref m_ChildScaleWidth, value);
			}
		}

		public bool childScaleHeight
		{
			get
			{
				return m_ChildScaleHeight;
			}
			set
			{
				SetProperty(ref m_ChildScaleHeight, value);
			}
		}

		protected void CalcAlongAxis(int axis, bool isVertical)
		{
			float num = ((axis == 0) ? base.padding.horizontal : base.padding.vertical);
			bool controlSize = ((axis == 0) ? m_ChildControlWidth : m_ChildControlHeight);
			bool flag = ((axis == 0) ? m_ChildScaleWidth : m_ChildScaleHeight);
			bool childForceExpand = ((axis == 0) ? m_ChildForceExpandWidth : m_ChildForceExpandHeight);
			float num2 = num;
			float num3 = num;
			float num4 = 0f;
			bool flag2 = isVertical ^ (axis == 1);
			for (int i = 0; i < base.rectChildren.Count; i++)
			{
				RectTransform rectTransform = base.rectChildren[i];
				GetChildSizes(rectTransform, axis, controlSize, childForceExpand, out var min, out var preferred, out var flexible);
				if (flag)
				{
					float num5 = rectTransform.localScale[axis];
					min *= num5;
					preferred *= num5;
					flexible *= num5;
				}
				if (flag2)
				{
					num2 = Mathf.Max(min + num, num2);
					num3 = Mathf.Max(preferred + num, num3);
					num4 = Mathf.Max(flexible, num4);
				}
				else
				{
					num2 += min + spacing;
					num3 += preferred + spacing;
					num4 += flexible;
				}
			}
			if (!flag2 && base.rectChildren.Count > 0)
			{
				num2 -= spacing;
				num3 -= spacing;
			}
			num3 = Mathf.Max(num2, num3);
			SetLayoutInputForAxis(num2, num3, num4, axis);
		}

		protected void SetChildrenAlongAxis(int axis, bool isVertical)
		{
			float num = base.rectTransform.rect.size[axis];
			bool flag = ((axis == 0) ? m_ChildControlWidth : m_ChildControlHeight);
			bool flag2 = ((axis == 0) ? m_ChildScaleWidth : m_ChildScaleHeight);
			bool childForceExpand = ((axis == 0) ? m_ChildForceExpandWidth : m_ChildForceExpandHeight);
			float alignmentOnAxis = GetAlignmentOnAxis(axis);
			if (isVertical ^ (axis == 1))
			{
				float value = num - (float)((axis == 0) ? base.padding.horizontal : base.padding.vertical);
				for (int i = 0; i < base.rectChildren.Count; i++)
				{
					RectTransform rectTransform = base.rectChildren[i];
					GetChildSizes(rectTransform, axis, flag, childForceExpand, out var min, out var preferred, out var flexible);
					float num2 = (flag2 ? rectTransform.localScale[axis] : 1f);
					float num3 = Mathf.Clamp(value, min, (flexible > 0f) ? num : preferred);
					float startOffset = GetStartOffset(axis, num3 * num2);
					if (flag)
					{
						SetChildAlongAxisWithScale(rectTransform, axis, startOffset, num3, num2);
						continue;
					}
					float num4 = (num3 - rectTransform.sizeDelta[axis]) * alignmentOnAxis;
					SetChildAlongAxisWithScale(rectTransform, axis, startOffset + num4, num2);
				}
				return;
			}
			float num5 = ((axis == 0) ? base.padding.left : base.padding.top);
			float num6 = 0f;
			float num7 = num - GetTotalPreferredSize(axis);
			if (num7 > 0f)
			{
				if (GetTotalFlexibleSize(axis) == 0f)
				{
					num5 = GetStartOffset(axis, GetTotalPreferredSize(axis) - (float)((axis == 0) ? base.padding.horizontal : base.padding.vertical));
				}
				else if (GetTotalFlexibleSize(axis) > 0f)
				{
					num6 = num7 / GetTotalFlexibleSize(axis);
				}
			}
			float t = 0f;
			if (GetTotalMinSize(axis) != GetTotalPreferredSize(axis))
			{
				t = Mathf.Clamp01((num - GetTotalMinSize(axis)) / (GetTotalPreferredSize(axis) - GetTotalMinSize(axis)));
			}
			for (int j = 0; j < base.rectChildren.Count; j++)
			{
				RectTransform rectTransform2 = base.rectChildren[j];
				GetChildSizes(rectTransform2, axis, flag, childForceExpand, out var min2, out var preferred2, out var flexible2);
				float num8 = (flag2 ? rectTransform2.localScale[axis] : 1f);
				float num9 = Mathf.Lerp(min2, preferred2, t);
				num9 += flexible2 * num6;
				if (flag)
				{
					SetChildAlongAxisWithScale(rectTransform2, axis, num5, num9, num8);
				}
				else
				{
					float num10 = (num9 - rectTransform2.sizeDelta[axis]) * alignmentOnAxis;
					SetChildAlongAxisWithScale(rectTransform2, axis, num5 + num10, num8);
				}
				num5 += num9 * num8 + spacing;
			}
		}

		private void GetChildSizes(RectTransform child, int axis, bool controlSize, bool childForceExpand, out float min, out float preferred, out float flexible)
		{
			if (!controlSize)
			{
				min = child.sizeDelta[axis];
				preferred = min;
				flexible = 0f;
			}
			else
			{
				min = LayoutUtility.GetMinSize(child, axis);
				preferred = LayoutUtility.GetPreferredSize(child, axis);
				flexible = LayoutUtility.GetFlexibleSize(child, axis);
			}
			if (childForceExpand)
			{
				flexible = Mathf.Max(flexible, 1f);
			}
		}
	}
	public interface ILayoutElement
	{
		float minWidth { get; }

		float preferredWidth { get; }

		float flexibleWidth { get; }

		float minHeight { get; }

		float preferredHeight { get; }

		float flexibleHeight { get; }

		int layoutPriority { get; }

		void CalculateLayoutInputHorizontal();

		void CalculateLayoutInputVertical();
	}
	public interface ILayoutController
	{
		void SetLayoutHorizontal();

		void SetLayoutVertical();
	}
	public interface ILayoutGroup : ILayoutController
	{
	}
	public interface ILayoutSelfController : ILayoutController
	{
	}
	public interface ILayoutIgnorer
	{
		bool ignoreLayout { get; }
	}
	[AddComponentMenu("Layout/Layout Element", 140)]
	[RequireComponent(typeof(RectTransform))]
	[ExecuteAlways]
	public class LayoutElement : UIBehaviour, ILayoutElement, ILayoutIgnorer
	{
		[SerializeField]
		private bool m_IgnoreLayout;

		[SerializeField]
		private float m_MinWidth = -1f;

		[SerializeField]
		private float m_MinHeight = -1f;

		[SerializeField]
		private float m_PreferredWidth = -1f;

		[SerializeField]
		private float m_PreferredHeight = -1f;

		[SerializeField]
		private float m_FlexibleWidth = -1f;

		[SerializeField]
		private float m_FlexibleHeight = -1f;

		[SerializeField]
		private int m_LayoutPriority = 1;

		public virtual bool ignoreLayout
		{
			get
			{
				return m_IgnoreLayout;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_IgnoreLayout, value))
				{
					SetDirty();
				}
			}
		}

		public virtual float minWidth
		{
			get
			{
				return m_MinWidth;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_MinWidth, value))
				{
					SetDirty();
				}
			}
		}

		public virtual float minHeight
		{
			get
			{
				return m_MinHeight;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_MinHeight, value))
				{
					SetDirty();
				}
			}
		}

		public virtual float preferredWidth
		{
			get
			{
				return m_PreferredWidth;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_PreferredWidth, value))
				{
					SetDirty();
				}
			}
		}

		public virtual float preferredHeight
		{
			get
			{
				return m_PreferredHeight;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_PreferredHeight, value))
				{
					SetDirty();
				}
			}
		}

		public virtual float flexibleWidth
		{
			get
			{
				return m_FlexibleWidth;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_FlexibleWidth, value))
				{
					SetDirty();
				}
			}
		}

		public virtual float flexibleHeight
		{
			get
			{
				return m_FlexibleHeight;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_FlexibleHeight, value))
				{
					SetDirty();
				}
			}
		}

		public virtual int layoutPriority
		{
			get
			{
				return m_LayoutPriority;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_LayoutPriority, value))
				{
					SetDirty();
				}
			}
		}

		public virtual void CalculateLayoutInputHorizontal()
		{
		}

		public virtual void CalculateLayoutInputVertical()
		{
		}

		protected LayoutElement()
		{
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			SetDirty();
		}

		protected override void OnTransformParentChanged()
		{
			SetDirty();
		}

		protected override void OnDisable()
		{
			SetDirty();
			base.OnDisable();
		}

		protected override void OnDidApplyAnimationProperties()
		{
			SetDirty();
		}

		protected override void OnBeforeTransformParentChanged()
		{
			SetDirty();
		}

		protected void SetDirty()
		{
			if (IsActive())
			{
				LayoutRebuilder.MarkLayoutForRebuild(base.transform as RectTransform);
			}
		}
	}
	[DisallowMultipleComponent]
	[ExecuteAlways]
	[RequireComponent(typeof(RectTransform))]
	public abstract class LayoutGroup : UIBehaviour, ILayoutElement, ILayoutGroup, ILayoutController
	{
		[SerializeField]
		protected RectOffset m_Padding = new RectOffset();

		[SerializeField]
		protected TextAnchor m_ChildAlignment;

		[NonSerialized]
		private RectTransform m_Rect;

		protected DrivenRectTransformTracker m_Tracker;

		private Vector2 m_TotalMinSize = Vector2.zero;

		private Vector2 m_TotalPreferredSize = Vector2.zero;

		private Vector2 m_TotalFlexibleSize = Vector2.zero;

		[NonSerialized]
		private List<RectTransform> m_RectChildren = new List<RectTransform>();

		public RectOffset padding
		{
			get
			{
				return m_Padding;
			}
			set
			{
				SetProperty(ref m_Padding, value);
			}
		}

		public TextAnchor childAlignment
		{
			get
			{
				return m_ChildAlignment;
			}
			set
			{
				SetProperty(ref m_ChildAlignment, value);
			}
		}

		protected RectTransform rectTransform
		{
			get
			{
				if (m_Rect == null)
				{
					m_Rect = GetComponent<RectTransform>();
				}
				return m_Rect;
			}
		}

		protected List<RectTransform> rectChildren => m_RectChildren;

		public virtual float minWidth => GetTotalMinSize(0);

		public virtual float preferredWidth => GetTotalPreferredSize(0);

		public virtual float flexibleWidth => GetTotalFlexibleSize(0);

		public virtual float minHeight => GetTotalMinSize(1);

		public virtual float preferredHeight => GetTotalPreferredSize(1);

		public virtual float flexibleHeight => GetTotalFlexibleSize(1);

		public virtual int layoutPriority => 0;

		private bool isRootLayoutGroup
		{
			get
			{
				if (base.transform.parent == null)
				{
					return true;
				}
				return base.transform.parent.GetComponent(typeof(ILayoutGroup)) == null;
			}
		}

		public virtual void CalculateLayoutInputHorizontal()
		{
			m_RectChildren.Clear();
			List<Component> list = ListPool<Component>.Get();
			for (int i = 0; i < this.rectTransform.childCount; i++)
			{
				RectTransform rectTransform = this.rectTransform.GetChild(i) as RectTransform;
				if (rectTransform == null || !rectTransform.gameObject.activeInHierarchy)
				{
					continue;
				}
				rectTransform.GetComponents(typeof(ILayoutIgnorer), list);
				if (list.Count == 0)
				{
					m_RectChildren.Add(rectTransform);
					continue;
				}
				for (int j = 0; j < list.Count; j++)
				{
					if (!((ILayoutIgnorer)list[j]).ignoreLayout)
					{
						m_RectChildren.Add(rectTransform);
						break;
					}
				}
			}
			ListPool<Component>.Release(list);
			m_Tracker.Clear();
		}

		public abstract void CalculateLayoutInputVertical();

		public abstract void SetLayoutHorizontal();

		public abstract void SetLayoutVertical();

		protected LayoutGroup()
		{
			if (m_Padding == null)
			{
				m_Padding = new RectOffset();
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			SetDirty();
		}

		protected override void OnDisable()
		{
			m_Tracker.Clear();
			LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
			base.OnDisable();
		}

		protected override void OnDidApplyAnimationProperties()
		{
			SetDirty();
		}

		protected float GetTotalMinSize(int axis)
		{
			return m_TotalMinSize[axis];
		}

		protected float GetTotalPreferredSize(int axis)
		{
			return m_TotalPreferredSize[axis];
		}

		protected float GetTotalFlexibleSize(int axis)
		{
			return m_TotalFlexibleSize[axis];
		}

		protected float GetStartOffset(int axis, float requiredSpaceWithoutPadding)
		{
			float num = requiredSpaceWithoutPadding + (float)((axis == 0) ? padding.horizontal : padding.vertical);
			float num2 = rectTransform.rect.size[axis] - num;
			float alignmentOnAxis = GetAlignmentOnAxis(axis);
			return (float)((axis == 0) ? padding.left : padding.top) + num2 * alignmentOnAxis;
		}

		protected float GetAlignmentOnAxis(int axis)
		{
			if (axis == 0)
			{
				return (float)((int)childAlignment % 3) * 0.5f;
			}
			return (float)((int)childAlignment / 3) * 0.5f;
		}

		protected void SetLayoutInputForAxis(float totalMin, float totalPreferred, float totalFlexible, int axis)
		{
			m_TotalMinSize[axis] = totalMin;
			m_TotalPreferredSize[axis] = totalPreferred;
			m_TotalFlexibleSize[axis] = totalFlexible;
		}

		protected void SetChildAlongAxis(RectTransform rect, int axis, float pos)
		{
			if (!(rect == null))
			{
				SetChildAlongAxisWithScale(rect, axis, pos, 1f);
			}
		}

		protected void SetChildAlongAxisWithScale(RectTransform rect, int axis, float pos, float scaleFactor)
		{
			if (!(rect == null))
			{
				m_Tracker.Add(this, rect, (DrivenTransformProperties)(0xF00 | ((axis == 0) ? 2 : 4)));
				rect.anchorMin = Vector2.up;
				rect.anchorMax = Vector2.up;
				Vector2 anchoredPosition = rect.anchoredPosition;
				anchoredPosition[axis] = ((axis == 0) ? (pos + rect.sizeDelta[axis] * rect.pivot[axis] * scaleFactor) : (0f - pos - rect.sizeDelta[axis] * (1f - rect.pivot[axis]) * scaleFactor));
				rect.anchoredPosition = anchoredPosition;
			}
		}

		protected void SetChildAlongAxis(RectTransform rect, int axis, float pos, float size)
		{
			if (!(rect == null))
			{
				SetChildAlongAxisWithScale(rect, axis, pos, size, 1f);
			}
		}

		protected void SetChildAlongAxisWithScale(RectTransform rect, int axis, float pos, float size, float scaleFactor)
		{
			if (!(rect == null))
			{
				m_Tracker.Add(this, rect, (DrivenTransformProperties)(0xF00 | ((axis == 0) ? 4098 : 8196)));
				rect.anchorMin = Vector2.up;
				rect.anchorMax = Vector2.up;
				Vector2 sizeDelta = rect.sizeDelta;
				sizeDelta[axis] = size;
				rect.sizeDelta = sizeDelta;
				Vector2 anchoredPosition = rect.anchoredPosition;
				anchoredPosition[axis] = ((axis == 0) ? (pos + size * rect.pivot[axis] * scaleFactor) : (0f - pos - size * (1f - rect.pivot[axis]) * scaleFactor));
				rect.anchoredPosition = anchoredPosition;
			}
		}

		protected override void OnRectTransformDimensionsChange()
		{
			base.OnRectTransformDimensionsChange();
			if (isRootLayoutGroup)
			{
				SetDirty();
			}
		}

		protected virtual void OnTransformChildrenChanged()
		{
			SetDirty();
		}

		protected void SetProperty<T>(ref T currentValue, T newValue)
		{
			if (currentValue == null && newValue == null)
			{
				return;
			}
			if (currentValue != null)
			{
				object obj = newValue;
				if (currentValue.Equals(obj))
				{
					return;
				}
			}
			currentValue = newValue;
			SetDirty();
		}

		protected void SetDirty()
		{
			if (IsActive())
			{
				if (!CanvasUpdateRegistry.IsRebuildingLayout())
				{
					LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
				}
				else
				{
					StartCoroutine(DelayedSetDirty(rectTransform));
				}
			}
		}

		private IEnumerator DelayedSetDirty(RectTransform rectTransform)
		{
			yield return null;
			LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
		}
	}
	public class LayoutRebuilder : ICanvasElement
	{
		private RectTransform m_ToRebuild;

		private int m_CachedHashFromTransform;

		private static ObjectPool<LayoutRebuilder> s_Rebuilders;

		public Transform transform => m_ToRebuild;

		private void Initialize(RectTransform controller)
		{
			m_ToRebuild = controller;
			m_CachedHashFromTransform = controller.GetHashCode();
		}

		private void Clear()
		{
			m_ToRebuild = null;
			m_CachedHashFromTransform = 0;
		}

		static LayoutRebuilder()
		{
			s_Rebuilders = new ObjectPool<LayoutRebuilder>(null, delegate(LayoutRebuilder x)
			{
				x.Clear();
			});
			RectTransform.reapplyDrivenProperties += ReapplyDrivenProperties;
		}

		private static void ReapplyDrivenProperties(RectTransform driven)
		{
			MarkLayoutForRebuild(driven);
		}

		public bool IsDestroyed()
		{
			return m_ToRebuild == null;
		}

		private static void StripDisabledBehavioursFromList(List<Component> components)
		{
			components.RemoveAll((Component e) => e is Behaviour && !((Behaviour)e).isActiveAndEnabled);
		}

		public static void ForceRebuildLayoutImmediate(RectTransform layoutRoot)
		{
			LayoutRebuilder layoutRebuilder = s_Rebuilders.Get();
			layoutRebuilder.Initialize(layoutRoot);
			layoutRebuilder.Rebuild(CanvasUpdate.Layout);
			s_Rebuilders.Release(layoutRebuilder);
		}

		public void Rebuild(CanvasUpdate executing)
		{
			if (executing == CanvasUpdate.Layout)
			{
				PerformLayoutCalculation(m_ToRebuild, delegate(Component e)
				{
					(e as ILayoutElement).CalculateLayoutInputHorizontal();
				});
				PerformLayoutControl(m_ToRebuild, delegate(Component e)
				{
					(e as ILayoutController).SetLayoutHorizontal();
				});
				PerformLayoutCalculation(m_ToRebuild, delegate(Component e)
				{
					(e as ILayoutElement).CalculateLayoutInputVertical();
				});
				PerformLayoutControl(m_ToRebuild, delegate(Component e)
				{
					(e as ILayoutController).SetLayoutVertical();
				});
			}
		}

		private void PerformLayoutControl(RectTransform rect, UnityAction<Component> action)
		{
			if (rect == null)
			{
				return;
			}
			List<Component> list = ListPool<Component>.Get();
			rect.GetComponents(typeof(ILayoutController), list);
			StripDisabledBehavioursFromList(list);
			if (list.Count > 0)
			{
				for (int i = 0; i < list.Count; i++)
				{
					if (list[i] is ILayoutSelfController)
					{
						action(list[i]);
					}
				}
				for (int j = 0; j < list.Count; j++)
				{
					if (!(list[j] is ILayoutSelfController))
					{
						action(list[j]);
					}
				}
				for (int k = 0; k < rect.childCount; k++)
				{
					PerformLayoutControl(rect.GetChild(k) as RectTransform, action);
				}
			}
			ListPool<Component>.Release(list);
		}

		private void PerformLayoutCalculation(RectTransform rect, UnityAction<Component> action)
		{
			if (rect == null)
			{
				return;
			}
			List<Component> list = ListPool<Component>.Get();
			rect.GetComponents(typeof(ILayoutElement), list);
			StripDisabledBehavioursFromList(list);
			if (list.Count > 0 || (bool)rect.GetComponent(typeof(ILayoutGroup)))
			{
				for (int i = 0; i < rect.childCount; i++)
				{
					PerformLayoutCalculation(rect.GetChild(i) as RectTransform, action);
				}
				for (int j = 0; j < list.Count; j++)
				{
					action(list[j]);
				}
			}
			ListPool<Component>.Release(list);
		}

		public static void MarkLayoutForRebuild(RectTransform rect)
		{
			if (rect == null || rect.gameObject == null)
			{
				return;
			}
			List<Component> list = ListPool<Component>.Get();
			bool flag = true;
			RectTransform rectTransform = rect;
			RectTransform rectTransform2 = rectTransform.parent as RectTransform;
			while (flag && !(rectTransform2 == null) && !(rectTransform2.gameObject == null))
			{
				flag = false;
				rectTransform2.GetComponents(typeof(ILayoutGroup), list);
				for (int i = 0; i < list.Count; i++)
				{
					Component component = list[i];
					if (component != null && component is Behaviour && ((Behaviour)component).isActiveAndEnabled)
					{
						flag = true;
						rectTransform = rectTransform2;
						break;
					}
				}
				rectTransform2 = rectTransform2.parent as RectTransform;
			}
			if (rectTransform == rect && !ValidController(rectTransform, list))
			{
				ListPool<Component>.Release(list);
				return;
			}
			MarkLayoutRootForRebuild(rectTransform);
			ListPool<Component>.Release(list);
		}

		private static bool ValidController(RectTransform layoutRoot, List<Component> comps)
		{
			if (layoutRoot == null || layoutRoot.gameObject == null)
			{
				return false;
			}
			layoutRoot.GetComponents(typeof(ILayoutController), comps);
			for (int i = 0; i < comps.Count; i++)
			{
				Component component = comps[i];
				if (component != null && component is Behaviour && ((Behaviour)component).isActiveAndEnabled)
				{
					return true;
				}
			}
			return false;
		}

		private static void MarkLayoutRootForRebuild(RectTransform controller)
		{
			if (!(controller == null))
			{
				LayoutRebuilder layoutRebuilder = s_Rebuilders.Get();
				layoutRebuilder.Initialize(controller);
				if (!CanvasUpdateRegistry.TryRegisterCanvasElementForLayoutRebuild(layoutRebuilder))
				{
					s_Rebuilders.Release(layoutRebuilder);
				}
			}
		}

		public void LayoutComplete()
		{
			s_Rebuilders.Release(this);
		}

		public void GraphicUpdateComplete()
		{
		}

		public override int GetHashCode()
		{
			return m_CachedHashFromTransform;
		}

		public override bool Equals(object obj)
		{
			return obj.GetHashCode() == GetHashCode();
		}

		public override string ToString()
		{
			return "(Layout Rebuilder for) " + m_ToRebuild;
		}
	}
	public static class LayoutUtility
	{
		public static float GetMinSize(RectTransform rect, int axis)
		{
			if (axis == 0)
			{
				return GetMinWidth(rect);
			}
			return GetMinHeight(rect);
		}

		public static float GetPreferredSize(RectTransform rect, int axis)
		{
			if (axis == 0)
			{
				return GetPreferredWidth(rect);
			}
			return GetPreferredHeight(rect);
		}

		public static float GetFlexibleSize(RectTransform rect, int axis)
		{
			if (axis == 0)
			{
				return GetFlexibleWidth(rect);
			}
			return GetFlexibleHeight(rect);
		}

		public static float GetMinWidth(RectTransform rect)
		{
			return GetLayoutProperty(rect, (ILayoutElement e) => e.minWidth, 0f);
		}

		public static float GetPreferredWidth(RectTransform rect)
		{
			return Mathf.Max(GetLayoutProperty(rect, (ILayoutElement e) => e.minWidth, 0f), GetLayoutProperty(rect, (ILayoutElement e) => e.preferredWidth, 0f));
		}

		public static float GetFlexibleWidth(RectTransform rect)
		{
			return GetLayoutProperty(rect, (ILayoutElement e) => e.flexibleWidth, 0f);
		}

		public static float GetMinHeight(RectTransform rect)
		{
			return GetLayoutProperty(rect, (ILayoutElement e) => e.minHeight, 0f);
		}

		public static float GetPreferredHeight(RectTransform rect)
		{
			return Mathf.Max(GetLayoutProperty(rect, (ILayoutElement e) => e.minHeight, 0f), GetLayoutProperty(rect, (ILayoutElement e) => e.preferredHeight, 0f));
		}

		public static float GetFlexibleHeight(RectTransform rect)
		{
			return GetLayoutProperty(rect, (ILayoutElement e) => e.flexibleHeight, 0f);
		}

		public static float GetLayoutProperty(RectTransform rect, Func<ILayoutElement, float> property, float defaultValue)
		{
			ILayoutElement source;
			return GetLayoutProperty(rect, property, defaultValue, out source);
		}

		public static float GetLayoutProperty(RectTransform rect, Func<ILayoutElement, float> property, float defaultValue, out ILayoutElement source)
		{
			source = null;
			if (rect == null)
			{
				return 0f;
			}
			float num = defaultValue;
			int num2 = int.MinValue;
			List<Component> list = ListPool<Component>.Get();
			rect.GetComponents(typeof(ILayoutElement), list);
			for (int i = 0; i < list.Count; i++)
			{
				ILayoutElement layoutElement = list[i] as ILayoutElement;
				if (layoutElement is Behaviour && !((Behaviour)layoutElement).isActiveAndEnabled)
				{
					continue;
				}
				int layoutPriority = layoutElement.layoutPriority;
				if (layoutPriority < num2)
				{
					continue;
				}
				float num3 = property(layoutElement);
				if (!(num3 < 0f))
				{
					if (layoutPriority > num2)
					{
						num = num3;
						num2 = layoutPriority;
						source = layoutElement;
					}
					else if (num3 > num)
					{
						num = num3;
						source = layoutElement;
					}
				}
			}
			ListPool<Component>.Release(list);
			return num;
		}
	}
	[AddComponentMenu("Layout/Vertical Layout Group", 151)]
	public class VerticalLayoutGroup : HorizontalOrVerticalLayoutGroup
	{
		protected VerticalLayoutGroup()
		{
		}

		public override void CalculateLayoutInputHorizontal()
		{
			base.CalculateLayoutInputHorizontal();
			CalcAlongAxis(0, isVertical: true);
		}

		public override void CalculateLayoutInputVertical()
		{
			CalcAlongAxis(1, isVertical: true);
		}

		public override void SetLayoutHorizontal()
		{
			SetChildrenAlongAxis(0, isVertical: true);
		}

		public override void SetLayoutVertical()
		{
			SetChildrenAlongAxis(1, isVertical: true);
		}
	}
	[AddComponentMenu("UI/Mask", 13)]
	[ExecuteAlways]
	[RequireComponent(typeof(RectTransform))]
	[DisallowMultipleComponent]
	public class Mask : UIBehaviour, ICanvasRaycastFilter, IMaterialModifier
	{
		[NonSerialized]
		private RectTransform m_RectTransform;

		[SerializeField]
		private bool m_ShowMaskGraphic = true;

		[NonSerialized]
		private Graphic m_Graphic;

		[NonSerialized]
		private Material m_MaskMaterial;

		[NonSerialized]
		private Material m_UnmaskMaterial;

		public RectTransform rectTransform => m_RectTransform ?? (m_RectTransform = GetComponent<RectTransform>());

		public bool showMaskGraphic
		{
			get
			{
				return m_ShowMaskGraphic;
			}
			set
			{
				if (m_ShowMaskGraphic != value)
				{
					m_ShowMaskGraphic = value;
					if (graphic != null)
					{
						graphic.SetMaterialDirty();
					}
				}
			}
		}

		public Graphic graphic => m_Graphic ?? (m_Graphic = GetComponent<Graphic>());

		protected Mask()
		{
		}

		public virtual bool MaskEnabled()
		{
			if (IsActive())
			{
				return graphic != null;
			}
			return false;
		}

		[Obsolete("Not used anymore.")]
		public virtual void OnSiblingGraphicEnabledDisabled()
		{
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			if (graphic != null)
			{
				graphic.canvasRenderer.hasPopInstruction = true;
				graphic.SetMaterialDirty();
			}
			MaskUtilities.NotifyStencilStateChanged(this);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			if (graphic != null)
			{
				graphic.SetMaterialDirty();
				graphic.canvasRenderer.hasPopInstruction = false;
				graphic.canvasRenderer.popMaterialCount = 0;
			}
			StencilMaterial.Remove(m_MaskMaterial);
			m_MaskMaterial = null;
			StencilMaterial.Remove(m_UnmaskMaterial);
			m_UnmaskMaterial = null;
			MaskUtilities.NotifyStencilStateChanged(this);
		}

		public virtual bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera)
		{
			if (!base.isActiveAndEnabled)
			{
				return true;
			}
			return RectTransformUtility.RectangleContainsScreenPoint(rectTransform, sp, eventCamera);
		}

		public virtual Material GetModifiedMaterial(Material baseMaterial)
		{
			if (!MaskEnabled())
			{
				return baseMaterial;
			}
			Transform stopAfter = MaskUtilities.FindRootSortOverrideCanvas(base.transform);
			int stencilDepth = MaskUtilities.GetStencilDepth(base.transform, stopAfter);
			if (stencilDepth >= 8)
			{
				Debug.LogWarning("Attempting to use a stencil mask with depth > 8", base.gameObject);
				return baseMaterial;
			}
			int num = 1 << stencilDepth;
			if (num == 1)
			{
				Material maskMaterial = StencilMaterial.Add(baseMaterial, 1, StencilOp.Replace, CompareFunction.Always, m_ShowMaskGraphic ? ColorWriteMask.All : ((ColorWriteMask)0));
				StencilMaterial.Remove(m_MaskMaterial);
				m_MaskMaterial = maskMaterial;
				Material unmaskMaterial = StencilMaterial.Add(baseMaterial, 1, StencilOp.Zero, CompareFunction.Always, (ColorWriteMask)0);
				StencilMaterial.Remove(m_UnmaskMaterial);
				m_UnmaskMaterial = unmaskMaterial;
				graphic.canvasRenderer.popMaterialCount = 1;
				graphic.canvasRenderer.SetPopMaterial(m_UnmaskMaterial, 0);
				return m_MaskMaterial;
			}
			Material maskMaterial2 = StencilMaterial.Add(baseMaterial, num | (num - 1), StencilOp.Replace, CompareFunction.Equal, m_ShowMaskGraphic ? ColorWriteMask.All : ((ColorWriteMask)0), num - 1, num | (num - 1));
			StencilMaterial.Remove(m_MaskMaterial);
			m_MaskMaterial = maskMaterial2;
			graphic.canvasRenderer.hasPopInstruction = true;
			Material unmaskMaterial2 = StencilMaterial.Add(baseMaterial, num - 1, StencilOp.Replace, CompareFunction.Equal, (ColorWriteMask)0, num - 1, num | (num - 1));
			StencilMaterial.Remove(m_UnmaskMaterial);
			m_UnmaskMaterial = unmaskMaterial2;
			graphic.canvasRenderer.popMaterialCount = 1;
			graphic.canvasRenderer.SetPopMaterial(m_UnmaskMaterial, 0);
			return m_MaskMaterial;
		}
	}
	public abstract class MaskableGraphic : Graphic, IClippable, IMaskable, IMaterialModifier
	{
		[Serializable]
		public class CullStateChangedEvent : UnityEvent<bool>
		{
		}

		[NonSerialized]
		protected bool m_ShouldRecalculateStencil = true;

		[NonSerialized]
		protected Material m_MaskMaterial;

		[NonSerialized]
		private RectMask2D m_ParentMask;

		[SerializeField]
		private bool m_Maskable = true;

		[NonSerialized]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Not used anymore.", true)]
		protected bool m_IncludeForMasking;

		[SerializeField]
		private CullStateChangedEvent m_OnCullStateChanged = new CullStateChangedEvent();

		[NonSerialized]
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Not used anymore", true)]
		protected bool m_ShouldRecalculate = true;

		[NonSerialized]
		protected int m_StencilValue;

		private readonly Vector3[] m_Corners = new Vector3[4];

		public CullStateChangedEvent onCullStateChanged
		{
			get
			{
				return m_OnCullStateChanged;
			}
			set
			{
				m_OnCullStateChanged = value;
			}
		}

		public bool maskable
		{
			get
			{
				return m_Maskable;
			}
			set
			{
				if (value != m_Maskable)
				{
					m_Maskable = value;
					m_ShouldRecalculateStencil = true;
					SetMaterialDirty();
				}
			}
		}

		private Rect rootCanvasRect
		{
			get
			{
				base.rectTransform.GetWorldCorners(m_Corners);
				if ((bool)base.canvas)
				{
					Matrix4x4 worldToLocalMatrix = base.canvas.rootCanvas.transform.worldToLocalMatrix;
					for (int i = 0; i < 4; i++)
					{
						m_Corners[i] = worldToLocalMatrix.MultiplyPoint(m_Corners[i]);
					}
				}
				Vector2 vector = m_Corners[0];
				Vector2 vector2 = m_Corners[0];
				for (int j = 1; j < 4; j++)
				{
					vector.x = Mathf.Min(m_Corners[j].x, vector.x);
					vector.y = Mathf.Min(m_Corners[j].y, vector.y);
					vector2.x = Mathf.Max(m_Corners[j].x, vector2.x);
					vector2.y = Mathf.Max(m_Corners[j].y, vector2.y);
				}
				return new Rect(vector, vector2 - vector);
			}
		}

		public virtual Material GetModifiedMaterial(Material baseMaterial)
		{
			Material material = baseMaterial;
			if (m_ShouldRecalculateStencil)
			{
				Transform stopAfter = MaskUtilities.FindRootSortOverrideCanvas(base.transform);
				m_StencilValue = (maskable ? MaskUtilities.GetStencilDepth(base.transform, stopAfter) : 0);
				m_ShouldRecalculateStencil = false;
			}
			Mask component = GetComponent<Mask>();
			if (m_StencilValue > 0 && (component == null || !component.IsActive()))
			{
				Material maskMaterial = StencilMaterial.Add(material, (1 << m_StencilValue) - 1, StencilOp.Keep, CompareFunction.Equal, ColorWriteMask.All, (1 << m_StencilValue) - 1, 0);
				StencilMaterial.Remove(m_MaskMaterial);
				m_MaskMaterial = maskMaterial;
				material = m_MaskMaterial;
			}
			return material;
		}

		public virtual void Cull(Rect clipRect, bool validRect)
		{
			bool cull = !validRect || !clipRect.Overlaps(rootCanvasRect, allowInverse: true);
			UpdateCull(cull);
		}

		private void UpdateCull(bool cull)
		{
			if (base.canvasRenderer.cull != cull)
			{
				base.canvasRenderer.cull = cull;
				UISystemProfilerApi.AddMarker("MaskableGraphic.cullingChanged", this);
				m_OnCullStateChanged.Invoke(cull);
				OnCullingChanged();
			}
		}

		public virtual void SetClipRect(Rect clipRect, bool validRect)
		{
			if (validRect)
			{
				base.canvasRenderer.EnableRectClipping(clipRect);
			}
			else
			{
				base.canvasRenderer.DisableRectClipping();
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			m_ShouldRecalculateStencil = true;
			UpdateClipParent();
			SetMaterialDirty();
			if (GetComponent<Mask>() != null)
			{
				MaskUtilities.NotifyStencilStateChanged(this);
			}
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			m_ShouldRecalculateStencil = true;
			SetMaterialDirty();
			UpdateClipParent();
			StencilMaterial.Remove(m_MaskMaterial);
			m_MaskMaterial = null;
			if (GetComponent<Mask>() != null)
			{
				MaskUtilities.NotifyStencilStateChanged(this);
			}
		}

		protected override void OnTransformParentChanged()
		{
			base.OnTransformParentChanged();
			if (base.isActiveAndEnabled)
			{
				m_ShouldRecalculateStencil = true;
				UpdateClipParent();
				SetMaterialDirty();
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Not used anymore.", true)]
		public virtual void ParentMaskStateChanged()
		{
		}

		protected override void OnCanvasHierarchyChanged()
		{
			base.OnCanvasHierarchyChanged();
			if (base.isActiveAndEnabled)
			{
				m_ShouldRecalculateStencil = true;
				UpdateClipParent();
				SetMaterialDirty();
			}
		}

		private void UpdateClipParent()
		{
			RectMask2D rectMask2D = ((maskable && IsActive()) ? MaskUtilities.GetRectMaskForClippable(this) : null);
			if (m_ParentMask != null && (rectMask2D != m_ParentMask || !rectMask2D.IsActive()))
			{
				m_ParentMask.RemoveClippable(this);
				UpdateCull(cull: false);
			}
			if (rectMask2D != null && rectMask2D.IsActive())
			{
				rectMask2D.AddClippable(this);
			}
			m_ParentMask = rectMask2D;
		}

		public virtual void RecalculateClipping()
		{
			UpdateClipParent();
		}

		public virtual void RecalculateMasking()
		{
			StencilMaterial.Remove(m_MaskMaterial);
			m_MaskMaterial = null;
			m_ShouldRecalculateStencil = true;
			SetMaterialDirty();
		}

		GameObject IClippable.get_gameObject()
		{
			return base.gameObject;
		}
	}
	public class MaskUtilities
	{
		public static void Notify2DMaskStateChanged(Component mask)
		{
			List<Component> list = ListPool<Component>.Get();
			mask.GetComponentsInChildren(list);
			for (int i = 0; i < list.Count; i++)
			{
				if (!(list[i] == null) && !(list[i].gameObject == mask.gameObject) && list[i] is IClippable clippable)
				{
					clippable.RecalculateClipping();
				}
			}
			ListPool<Component>.Release(list);
		}

		public static void NotifyStencilStateChanged(Component mask)
		{
			List<Component> list = ListPool<Component>.Get();
			mask.GetComponentsInChildren(list);
			for (int i = 0; i < list.Count; i++)
			{
				if (!(list[i] == null) && !(list[i].gameObject == mask.gameObject) && list[i] is IMaskable maskable)
				{
					maskable.RecalculateMasking();
				}
			}
			ListPool<Component>.Release(list);
		}

		public static Transform FindRootSortOverrideCanvas(Transform start)
		{
			List<Canvas> list = ListPool<Canvas>.Get();
			start.GetComponentsInParent(includeInactive: false, list);
			Canvas canvas = null;
			for (int i = 0; i < list.Count; i++)
			{
				canvas = list[i];
				if (canvas.overrideSorting)
				{
					break;
				}
			}
			ListPool<Canvas>.Release(list);
			if (!(canvas != null))
			{
				return null;
			}
			return canvas.transform;
		}

		public static int GetStencilDepth(Transform transform, Transform stopAfter)
		{
			int num = 0;
			if (transform == stopAfter)
			{
				return num;
			}
			Transform parent = transform.parent;
			List<Mask> list = ListPool<Mask>.Get();
			while (parent != null)
			{
				parent.GetComponents(list);
				for (int i = 0; i < list.Count; i++)
				{
					if (list[i] != null && list[i].MaskEnabled() && list[i].graphic.IsActive())
					{
						num++;
						break;
					}
				}
				if (parent == stopAfter)
				{
					break;
				}
				parent = parent.parent;
			}
			ListPool<Mask>.Release(list);
			return num;
		}

		public static bool IsDescendantOrSelf(Transform father, Transform child)
		{
			if (father == null || child == null)
			{
				return false;
			}
			if (father == child)
			{
				return true;
			}
			while (child.parent != null)
			{
				if (child.parent == father)
				{
					return true;
				}
				child = child.parent;
			}
			return false;
		}

		public static RectMask2D GetRectMaskForClippable(IClippable clippable)
		{
			List<RectMask2D> list = ListPool<RectMask2D>.Get();
			List<Canvas> list2 = ListPool<Canvas>.Get();
			RectMask2D rectMask2D = null;
			clippable.gameObject.GetComponentsInParent(includeInactive: false, list);
			if (list.Count > 0)
			{
				for (int i = 0; i < list.Count; i++)
				{
					rectMask2D = list[i];
					if (rectMask2D.gameObject == clippable.gameObject)
					{
						rectMask2D = null;
						continue;
					}
					if (!rectMask2D.isActiveAndEnabled)
					{
						rectMask2D = null;
						continue;
					}
					clippable.gameObject.GetComponentsInParent(includeInactive: false, list2);
					for (int num = list2.Count - 1; num >= 0; num--)
					{
						if (!IsDescendantOrSelf(list2[num].transform, rectMask2D.transform) && list2[num].overrideSorting)
						{
							rectMask2D = null;
							break;
						}
					}
					break;
				}
			}
			ListPool<RectMask2D>.Release(list);
			ListPool<Canvas>.Release(list2);
			return rectMask2D;
		}

		public static void GetRectMasksForClip(RectMask2D clipper, List<RectMask2D> masks)
		{
			masks.Clear();
			List<Canvas> list = ListPool<Canvas>.Get();
			List<RectMask2D> list2 = ListPool<RectMask2D>.Get();
			clipper.transform.GetComponentsInParent(includeInactive: false, list2);
			if (list2.Count > 0)
			{
				clipper.transform.GetComponentsInParent(includeInactive: false, list);
				for (int num = list2.Count - 1; num >= 0; num--)
				{
					if (list2[num].IsActive())
					{
						bool flag = true;
						for (int num2 = list.Count - 1; num2 >= 0; num2--)
						{
							if (!IsDescendantOrSelf(list[num2].transform, list2[num].transform) && list[num2].overrideSorting)
							{
								flag = false;
								break;
							}
						}
						if (flag)
						{
							masks.Add(list2[num]);
						}
					}
				}
			}
			ListPool<RectMask2D>.Release(list2);
			ListPool<Canvas>.Release(list);
		}
	}
	public interface IMaterialModifier
	{
		Material GetModifiedMaterial(Material baseMaterial);
	}
	internal static class Misc
	{
		public static void Destroy(Object obj)
		{
			if (!(obj != null))
			{
				return;
			}
			if (Application.isPlaying)
			{
				if (obj is GameObject)
				{
					(obj as GameObject).transform.parent = null;
				}
				Object.Destroy(obj);
			}
			else
			{
				Object.DestroyImmediate(obj);
			}
		}

		public static void DestroyImmediate(Object obj)
		{
			if (obj != null)
			{
				if (Application.isEditor)
				{
					Object.DestroyImmediate(obj);
				}
				else
				{
					Object.Destroy(obj);
				}
			}
		}
	}
	[Serializable]
	public struct Navigation : IEquatable<Navigation>
	{
		[Flags]
		public enum Mode
		{
			None = 0,
			Horizontal = 1,
			Vertical = 2,
			Automatic = 3,
			Explicit = 4
		}

		[SerializeField]
		private Mode m_Mode;

		[SerializeField]
		private Selectable m_SelectOnUp;

		[SerializeField]
		private Selectable m_SelectOnDown;

		[SerializeField]
		private Selectable m_SelectOnLeft;

		[SerializeField]
		private Selectable m_SelectOnRight;

		public Mode mode
		{
			get
			{
				return m_Mode;
			}
			set
			{
				m_Mode = value;
			}
		}

		public Selectable selectOnUp
		{
			get
			{
				return m_SelectOnUp;
			}
			set
			{
				m_SelectOnUp = value;
			}
		}

		public Selectable selectOnDown
		{
			get
			{
				return m_SelectOnDown;
			}
			set
			{
				m_SelectOnDown = value;
			}
		}

		public Selectable selectOnLeft
		{
			get
			{
				return m_SelectOnLeft;
			}
			set
			{
				m_SelectOnLeft = value;
			}
		}

		public Selectable selectOnRight
		{
			get
			{
				return m_SelectOnRight;
			}
			set
			{
				m_SelectOnRight = value;
			}
		}

		public static Navigation defaultNavigation => new Navigation
		{
			m_Mode = Mode.Automatic
		};

		public bool Equals(Navigation other)
		{
			if (mode == other.mode && selectOnUp == other.selectOnUp && selectOnDown == other.selectOnDown && selectOnLeft == other.selectOnLeft)
			{
				return selectOnRight == other.selectOnRight;
			}
			return false;
		}
	}
	[AddComponentMenu("UI/Raw Image", 12)]
	public class RawImage : MaskableGraphic
	{
		[FormerlySerializedAs("m_Tex")]
		[SerializeField]
		private Texture m_Texture;

		[SerializeField]
		private Rect m_UVRect = new Rect(0f, 0f, 1f, 1f);

		public override Texture mainTexture
		{
			get
			{
				if (m_Texture == null)
				{
					if (material != null && material.mainTexture != null)
					{
						return material.mainTexture;
					}
					return Graphic.s_WhiteTexture;
				}
				return m_Texture;
			}
		}

		public Texture texture
		{
			get
			{
				return m_Texture;
			}
			set
			{
				if (!(m_Texture == value))
				{
					m_Texture = value;
					SetVerticesDirty();
					SetMaterialDirty();
				}
			}
		}

		public Rect uvRect
		{
			get
			{
				return m_UVRect;
			}
			set
			{
				if (!(m_UVRect == value))
				{
					m_UVRect = value;
					SetVerticesDirty();
				}
			}
		}

		protected RawImage()
		{
			base.useLegacyMeshGeneration = false;
		}

		public override void SetNativeSize()
		{
			Texture texture = mainTexture;
			if (texture != null)
			{
				int num = Mathf.RoundToInt((float)texture.width * uvRect.width);
				int num2 = Mathf.RoundToInt((float)texture.height * uvRect.height);
				base.rectTransform.anchorMax = base.rectTransform.anchorMin;
				base.rectTransform.sizeDelta = new Vector2(num, num2);
			}
		}

		protected override void OnPopulateMesh(VertexHelper vh)
		{
			Texture texture = mainTexture;
			vh.Clear();
			if (texture != null)
			{
				Rect pixelAdjustedRect = GetPixelAdjustedRect();
				Vector4 vector = new Vector4(pixelAdjustedRect.x, pixelAdjustedRect.y, pixelAdjustedRect.x + pixelAdjustedRect.width, pixelAdjustedRect.y + pixelAdjustedRect.height);
				float num = (float)texture.width * texture.texelSize.x;
				float num2 = (float)texture.height * texture.texelSize.y;
				Color color = this.color;
				vh.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(m_UVRect.xMin * num, m_UVRect.yMin * num2));
				vh.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(m_UVRect.xMin * num, m_UVRect.yMax * num2));
				vh.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(m_UVRect.xMax * num, m_UVRect.yMax * num2));
				vh.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(m_UVRect.xMax * num, m_UVRect.yMin * num2));
				vh.AddTriangle(0, 1, 2);
				vh.AddTriangle(2, 3, 0);
			}
		}

		protected override void OnDidApplyAnimationProperties()
		{
			SetMaterialDirty();
			SetVerticesDirty();
		}
	}
	[AddComponentMenu("UI/Rect Mask 2D", 13)]
	[ExecuteAlways]
	[DisallowMultipleComponent]
	[RequireComponent(typeof(RectTransform))]
	public class RectMask2D : UIBehaviour, IClipper, ICanvasRaycastFilter
	{
		[NonSerialized]
		private readonly RectangularVertexClipper m_VertexClipper = new RectangularVertexClipper();

		[NonSerialized]
		private RectTransform m_RectTransform;

		[NonSerialized]
		private HashSet<MaskableGraphic> m_MaskableTargets = new HashSet<MaskableGraphic>();

		[NonSerialized]
		private HashSet<IClippable> m_ClipTargets = new HashSet<IClippable>();

		[NonSerialized]
		private bool m_ShouldRecalculateClipRects;

		[NonSerialized]
		private List<RectMask2D> m_Clippers = new List<RectMask2D>();

		[NonSerialized]
		private Rect m_LastClipRectCanvasSpace;

		[NonSerialized]
		private bool m_ForceClip;

		[NonSerialized]
		private Canvas m_Canvas;

		public string updateGroupId;

		private MaskUpdateGroup currentGroup;

		private Vector3[] m_Corners = new Vector3[4];

		private Canvas Canvas
		{
			get
			{
				if (m_Canvas == null)
				{
					List<Canvas> list = ListPool<Canvas>.Get();
					base.gameObject.GetComponentsInParent(includeInactive: false, list);
					if (list.Count > 0)
					{
						m_Canvas = list[list.Count - 1];
					}
					else
					{
						m_Canvas = null;
					}
					ListPool<Canvas>.Release(list);
				}
				return m_Canvas;
			}
		}

		public Rect canvasRect => m_VertexClipper.GetCanvasRect(rectTransform, Canvas);

		public RectTransform rectTransform => m_RectTransform ?? (m_RectTransform = GetComponent<RectTransform>());

		private Rect rootCanvasRect
		{
			get
			{
				rectTransform.GetWorldCorners(m_Corners);
				if ((object)Canvas != null)
				{
					Canvas rootCanvas = Canvas.rootCanvas;
					for (int i = 0; i < 4; i++)
					{
						m_Corners[i] = rootCanvas.transform.InverseTransformPoint(m_Corners[i]);
					}
				}
				return new Rect(m_Corners[0].x, m_Corners[0].y, m_Corners[2].x - m_Corners[0].x, m_Corners[2].y - m_Corners[0].y);
			}
		}

		protected RectMask2D()
		{
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			m_ShouldRecalculateClipRects = true;
			if (!string.IsNullOrEmpty(updateGroupId) && MaskUpdateGroup.Groups.TryGetValue(updateGroupId, out var value))
			{
				currentGroup = value;
				value.Register(this);
			}
			else
			{
				ClipperRegistry.Register(this);
			}
			MaskUtilities.Notify2DMaskStateChanged(this);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			m_ClipTargets.Clear();
			m_MaskableTargets.Clear();
			m_Clippers.Clear();
			if (currentGroup != null)
			{
				currentGroup.Unregister(this);
			}
			else
			{
				ClipperRegistry.Unregister(this);
			}
			MaskUtilities.Notify2DMaskStateChanged(this);
		}

		public virtual bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera)
		{
			if (!base.isActiveAndEnabled)
			{
				return true;
			}
			return RectTransformUtility.RectangleContainsScreenPoint(rectTransform, sp, eventCamera);
		}

		public virtual void PerformClipping()
		{
			if ((object)Canvas == null)
			{
				return;
			}
			if (m_ShouldRecalculateClipRects)
			{
				MaskUtilities.GetRectMasksForClip(this, m_Clippers);
				m_ShouldRecalculateClipRects = false;
			}
			bool validRect = true;
			Rect rect = Clipping.FindCullAndClipWorldRect(m_Clippers, out validRect);
			RenderMode renderMode = Canvas.rootCanvas.renderMode;
			if ((renderMode == RenderMode.ScreenSpaceCamera || renderMode == RenderMode.ScreenSpaceOverlay) && !rect.Overlaps(rootCanvasRect, allowInverse: true))
			{
				rect = Rect.zero;
				validRect = false;
			}
			if (rect != m_LastClipRectCanvasSpace)
			{
				foreach (IClippable clipTarget in m_ClipTargets)
				{
					clipTarget.SetClipRect(rect, validRect);
				}
				foreach (MaskableGraphic maskableTarget in m_MaskableTargets)
				{
					maskableTarget.SetClipRect(rect, validRect);
					maskableTarget.Cull(rect, validRect);
				}
			}
			else if (m_ForceClip)
			{
				foreach (IClippable clipTarget2 in m_ClipTargets)
				{
					clipTarget2.SetClipRect(rect, validRect);
				}
				foreach (MaskableGraphic maskableTarget2 in m_MaskableTargets)
				{
					maskableTarget2.SetClipRect(rect, validRect);
					if (maskableTarget2.canvasRenderer.hasMoved)
					{
						maskableTarget2.Cull(rect, validRect);
					}
				}
			}
			else
			{
				foreach (MaskableGraphic maskableTarget3 in m_MaskableTargets)
				{
					if (maskableTarget3.canvasRenderer.hasMoved)
					{
						maskableTarget3.Cull(rect, validRect);
					}
				}
			}
			m_LastClipRectCanvasSpace = rect;
			m_ForceClip = false;
		}

		public void AddClippable(IClippable clippable)
		{
			if (clippable != null)
			{
				m_ShouldRecalculateClipRects = true;
				MaskableGraphic maskableGraphic = clippable as MaskableGraphic;
				if (maskableGraphic == null)
				{
					m_ClipTargets.Add(clippable);
				}
				else
				{
					m_MaskableTargets.Add(maskableGraphic);
				}
				m_ForceClip = true;
			}
		}

		public void RemoveClippable(IClippable clippable)
		{
			if (clippable != null)
			{
				m_ShouldRecalculateClipRects = true;
				clippable.SetClipRect(default(Rect), validRect: false);
				MaskableGraphic maskableGraphic = clippable as MaskableGraphic;
				if (maskableGraphic == null)
				{
					m_ClipTargets.Remove(clippable);
				}
				else
				{
					m_MaskableTargets.Remove(maskableGraphic);
				}
				m_ForceClip = true;
			}
		}

		protected override void OnTransformParentChanged()
		{
			base.OnTransformParentChanged();
			m_ShouldRecalculateClipRects = true;
		}

		protected override void OnCanvasHierarchyChanged()
		{
			m_Canvas = null;
			base.OnCanvasHierarchyChanged();
			m_ShouldRecalculateClipRects = true;
		}
	}
	[AddComponentMenu("UI/Scrollbar", 34)]
	[ExecuteAlways]
	[RequireComponent(typeof(RectTransform))]
	public class Scrollbar : Selectable, IBeginDragHandler, IEventSystemHandler, IDragHandler, IInitializePotentialDragHandler, ICanvasElement
	{
		public enum Direction
		{
			LeftToRight,
			RightToLeft,
			BottomToTop,
			TopToBottom
		}

		[Serializable]
		public class ScrollEvent : UnityEvent<float>
		{
		}

		private enum Axis
		{
			Horizontal,
			Vertical
		}

		[SerializeField]
		private RectTransform m_HandleRect;

		[SerializeField]
		private Direction m_Direction;

		[Range(0f, 1f)]
		[SerializeField]
		private float m_Value;

		[Range(0f, 1f)]
		[SerializeField]
		private float m_Size = 0.2f;

		[Range(0f, 11f)]
		[SerializeField]
		private int m_NumberOfSteps;

		[Space(6f)]
		[SerializeField]
		private ScrollEvent m_OnValueChanged = new ScrollEvent();

		private RectTransform m_ContainerRect;

		private Vector2 m_Offset = Vector2.zero;

		private DrivenRectTransformTracker m_Tracker;

		private Coroutine m_PointerDownRepeat;

		private bool isPointerDownAndNotDragging;

		private bool m_DelayedUpdateVisuals;

		public RectTransform handleRect
		{
			get
			{
				return m_HandleRect;
			}
			set
			{
				if (SetPropertyUtility.SetClass(ref m_HandleRect, value))
				{
					UpdateCachedReferences();
					UpdateVisuals();
				}
			}
		}

		public Direction direction
		{
			get
			{
				return m_Direction;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_Direction, value))
				{
					UpdateVisuals();
				}
			}
		}

		public float value
		{
			get
			{
				float num = m_Value;
				if (m_NumberOfSteps > 1)
				{
					num = Mathf.Round(num * (float)(m_NumberOfSteps - 1)) / (float)(m_NumberOfSteps - 1);
				}
				return num;
			}
			set
			{
				Set(value);
			}
		}

		public float size
		{
			get
			{
				return m_Size;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_Size, Mathf.Clamp01(value)))
				{
					UpdateVisuals();
				}
			}
		}

		public int numberOfSteps
		{
			get
			{
				return m_NumberOfSteps;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_NumberOfSteps, value))
				{
					Set(m_Value);
					UpdateVisuals();
				}
			}
		}

		public ScrollEvent onValueChanged
		{
			get
			{
				return m_OnValueChanged;
			}
			set
			{
				m_OnValueChanged = value;
			}
		}

		private float stepSize
		{
			get
			{
				if (m_NumberOfSteps <= 1)
				{
					return 0.1f;
				}
				return 1f / (float)(m_NumberOfSteps - 1);
			}
		}

		private Axis axis
		{
			get
			{
				if (m_Direction != Direction.LeftToRight && m_Direction != Direction.RightToLeft)
				{
					return Axis.Vertical;
				}
				return Axis.Horizontal;
			}
		}

		private bool reverseValue
		{
			get
			{
				if (m_Direction != Direction.RightToLeft)
				{
					return m_Direction == Direction.TopToBottom;
				}
				return true;
			}
		}

		protected Scrollbar()
		{
		}

		public virtual void SetValueWithoutNotify(float input)
		{
			Set(input, sendCallback: false);
		}

		public virtual void Rebuild(CanvasUpdate executing)
		{
		}

		public virtual void LayoutComplete()
		{
		}

		public virtual void GraphicUpdateComplete()
		{
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			UpdateCachedReferences();
			Set(m_Value, sendCallback: false);
			UpdateVisuals();
		}

		protected override void OnDisable()
		{
			m_Tracker.Clear();
			base.OnDisable();
		}

		protected virtual void Update()
		{
			if (m_DelayedUpdateVisuals)
			{
				m_DelayedUpdateVisuals = false;
				UpdateVisuals();
			}
		}

		private void UpdateCachedReferences()
		{
			if ((bool)m_HandleRect && m_HandleRect.parent != null)
			{
				m_ContainerRect = m_HandleRect.parent.GetComponent<RectTransform>();
			}
			else
			{
				m_ContainerRect = null;
			}
		}

		private void Set(float input, bool sendCallback = true)
		{
			float num = m_Value;
			m_Value = input;
			if (num != value)
			{
				UpdateVisuals();
				if (sendCallback)
				{
					UISystemProfilerApi.AddMarker("Scrollbar.value", this);
					m_OnValueChanged.Invoke(value);
				}
			}
		}

		protected override void OnRectTransformDimensionsChange()
		{
			base.OnRectTransformDimensionsChange();
			if (IsActive())
			{
				UpdateVisuals();
			}
		}

		private void UpdateVisuals()
		{
			m_Tracker.Clear();
			if (m_ContainerRect != null)
			{
				m_Tracker.Add(this, m_HandleRect, DrivenTransformProperties.Anchors);
				Vector2 zero = Vector2.zero;
				Vector2 one = Vector2.one;
				float num = Mathf.Clamp01(value) * (1f - size);
				if (reverseValue)
				{
					zero[(int)axis] = 1f - num - size;
					one[(int)axis] = 1f - num;
				}
				else
				{
					zero[(int)axis] = num;
					one[(int)axis] = num + size;
				}
				m_HandleRect.anchorMin = zero;
				m_HandleRect.anchorMax = one;
			}
		}

		private void UpdateDrag(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left && !(m_ContainerRect == null) && RectTransformUtility.ScreenPointToLocalPointInRectangle(m_ContainerRect, eventData.position, eventData.pressEventCamera, out var localPoint))
			{
				Vector2 handleCorner = localPoint - m_Offset - m_ContainerRect.rect.position - (m_HandleRect.rect.size - m_HandleRect.sizeDelta) * 0.5f;
				float num = ((axis == Axis.Horizontal) ? m_ContainerRect.rect.width : m_ContainerRect.rect.height) * (1f - size);
				if (!(num <= 0f))
				{
					DoUpdateDrag(handleCorner, num);
				}
			}
		}

		private void DoUpdateDrag(Vector2 handleCorner, float remainingSize)
		{
			switch (m_Direction)
			{
			case Direction.LeftToRight:
				Set(Mathf.Clamp01(handleCorner.x / remainingSize));
				break;
			case Direction.RightToLeft:
				Set(Mathf.Clamp01(1f - handleCorner.x / remainingSize));
				break;
			case Direction.BottomToTop:
				Set(Mathf.Clamp01(handleCorner.y / remainingSize));
				break;
			case Direction.TopToBottom:
				Set(Mathf.Clamp01(1f - handleCorner.y / remainingSize));
				break;
			}
		}

		private bool MayDrag(PointerEventData eventData)
		{
			if (IsActive() && IsInteractable())
			{
				return eventData.button == PointerEventData.InputButton.Left;
			}
			return false;
		}

		public virtual void OnBeginDrag(PointerEventData eventData)
		{
			isPointerDownAndNotDragging = false;
			if (MayDrag(eventData) && !(m_ContainerRect == null))
			{
				m_Offset = Vector2.zero;
				if (RectTransformUtility.RectangleContainsScreenPoint(m_HandleRect, eventData.position, eventData.enterEventCamera) && RectTransformUtility.ScreenPointToLocalPointInRectangle(m_HandleRect, eventData.position, eventData.pressEventCamera, out var localPoint))
				{
					m_Offset = localPoint - m_HandleRect.rect.center;
				}
			}
		}

		public virtual void OnDrag(PointerEventData eventData)
		{
			if (MayDrag(eventData) && m_ContainerRect != null)
			{
				UpdateDrag(eventData);
			}
		}

		public override void OnPointerDown(PointerEventData eventData)
		{
			if (MayDrag(eventData))
			{
				base.OnPointerDown(eventData);
				isPointerDownAndNotDragging = true;
				m_PointerDownRepeat = StartCoroutine(ClickRepeat(eventData));
			}
		}

		protected IEnumerator ClickRepeat(PointerEventData eventData)
		{
			while (isPointerDownAndNotDragging)
			{
				if (!RectTransformUtility.RectangleContainsScreenPoint(m_HandleRect, eventData.position, eventData.enterEventCamera) && RectTransformUtility.ScreenPointToLocalPointInRectangle(m_HandleRect, eventData.position, eventData.pressEventCamera, out var localPoint))
				{
					float num = ((((axis == Axis.Horizontal) ? localPoint.x : localPoint.y) < 0f) ? size : (0f - size));
					value += (reverseValue ? num : (0f - num));
				}
				yield return new WaitForEndOfFrame();
			}
			StopCoroutine(m_PointerDownRepeat);
		}

		public override void OnPointerUp(PointerEventData eventData)
		{
			base.OnPointerUp(eventData);
			isPointerDownAndNotDragging = false;
		}

		public override void OnMove(AxisEventData eventData)
		{
			if (!IsActive() || !IsInteractable())
			{
				base.OnMove(eventData);
				return;
			}
			switch (eventData.moveDir)
			{
			case MoveDirection.Left:
				if (axis == Axis.Horizontal && FindSelectableOnLeft() == null)
				{
					Set(Mathf.Clamp01(reverseValue ? (value + stepSize) : (value - stepSize)));
				}
				else
				{
					base.OnMove(eventData);
				}
				break;
			case MoveDirection.Right:
				if (axis == Axis.Horizontal && FindSelectableOnRight() == null)
				{
					Set(Mathf.Clamp01(reverseValue ? (value - stepSize) : (value + stepSize)));
				}
				else
				{
					base.OnMove(eventData);
				}
				break;
			case MoveDirection.Up:
				if (axis == Axis.Vertical && FindSelectableOnUp() == null)
				{
					Set(Mathf.Clamp01(reverseValue ? (value - stepSize) : (value + stepSize)));
				}
				else
				{
					base.OnMove(eventData);
				}
				break;
			case MoveDirection.Down:
				if (axis == Axis.Vertical && FindSelectableOnDown() == null)
				{
					Set(Mathf.Clamp01(reverseValue ? (value + stepSize) : (value - stepSize)));
				}
				else
				{
					base.OnMove(eventData);
				}
				break;
			}
		}

		public override Selectable FindSelectableOnLeft()
		{
			if (base.navigation.mode == Navigation.Mode.Automatic && axis == Axis.Horizontal)
			{
				return null;
			}
			return base.FindSelectableOnLeft();
		}

		public override Selectable FindSelectableOnRight()
		{
			if (base.navigation.mode == Navigation.Mode.Automatic && axis == Axis.Horizontal)
			{
				return null;
			}
			return base.FindSelectableOnRight();
		}

		public override Selectable FindSelectableOnUp()
		{
			if (base.navigation.mode == Navigation.Mode.Automatic && axis == Axis.Vertical)
			{
				return null;
			}
			return base.FindSelectableOnUp();
		}

		public override Selectable FindSelectableOnDown()
		{
			if (base.navigation.mode == Navigation.Mode.Automatic && axis == Axis.Vertical)
			{
				return null;
			}
			return base.FindSelectableOnDown();
		}

		public virtual void OnInitializePotentialDrag(PointerEventData eventData)
		{
			eventData.useDragThreshold = false;
		}

		public void SetDirection(Direction direction, bool includeRectLayouts)
		{
			Axis axis = this.axis;
			bool flag = reverseValue;
			this.direction = direction;
			if (includeRectLayouts)
			{
				if (this.axis != axis)
				{
					RectTransformUtility.FlipLayoutAxes(base.transform as RectTransform, keepPositioning: true, recursive: true);
				}
				if (reverseValue != flag)
				{
					RectTransformUtility.FlipLayoutOnAxis(base.transform as RectTransform, (int)this.axis, keepPositioning: true, recursive: true);
				}
			}
		}

		Transform ICanvasElement.get_transform()
		{
			return base.transform;
		}
	}
	[AddComponentMenu("UI/Scroll Rect", 37)]
	[SelectionBase]
	[ExecuteAlways]
	[DisallowMultipleComponent]
	[RequireComponent(typeof(RectTransform))]
	public class ScrollRect : UIBehaviour, IInitializePotentialDragHandler, IEventSystemHandler, IBeginDragHandler, IEndDragHandler, IDragHandler, IScrollHandler, ICanvasElement, ILayoutElement, ILayoutGroup, ILayoutController
	{
		public enum MovementType
		{
			Unrestricted,
			Elastic,
			Clamped
		}

		public enum ScrollbarVisibility
		{
			Permanent,
			AutoHide,
			AutoHideAndExpandViewport
		}

		[Serializable]
		public class ScrollRectEvent : UnityEvent<Vector2>
		{
		}

		[SerializeField]
		private RectTransform m_Content;

		[SerializeField]
		private bool m_Horizontal = true;

		[SerializeField]
		private bool m_Vertical = true;

		[SerializeField]
		private MovementType m_MovementType = MovementType.Elastic;

		[SerializeField]
		private float m_Elasticity = 0.1f;

		[SerializeField]
		private bool m_Inertia = true;

		[SerializeField]
		private float m_DecelerationRate = 0.135f;

		[SerializeField]
		private float m_ScrollSensitivity = 1f;

		[SerializeField]
		private RectTransform m_Viewport;

		[SerializeField]
		private Scrollbar m_HorizontalScrollbar;

		[SerializeField]
		private Scrollbar m_VerticalScrollbar;

		[SerializeField]
		private ScrollbarVisibility m_HorizontalScrollbarVisibility;

		[SerializeField]
		private ScrollbarVisibility m_VerticalScrollbarVisibility;

		[SerializeField]
		private float m_HorizontalScrollbarSpacing;

		[SerializeField]
		private float m_VerticalScrollbarSpacing;

		[SerializeField]
		private ScrollRectEvent m_OnValueChanged = new ScrollRectEvent();

		private Vector2 m_PointerStartLocalCursor = Vector2.zero;

		protected Vector2 m_ContentStartPosition = Vector2.zero;

		private RectTransform m_ViewRect;

		protected Bounds m_ContentBounds;

		private Bounds m_ViewBounds;

		private Vector2 m_Velocity;

		private bool m_Dragging;

		private bool m_Scrolling;

		private Vector2 m_PrevPosition = Vector2.zero;

		private Bounds m_PrevContentBounds;

		private Bounds m_PrevViewBounds;

		[NonSerialized]
		private bool m_HasRebuiltLayout;

		private bool m_HSliderExpand;

		private bool m_VSliderExpand;

		private float m_HSliderHeight;

		private float m_VSliderWidth;

		[NonSerialized]
		private RectTransform m_Rect;

		private RectTransform m_HorizontalScrollbarRect;

		private RectTransform m_VerticalScrollbarRect;

		private DrivenRectTransformTracker m_Tracker;

		public static float GlobalSensitivity = 1f;

		private readonly Vector3[] m_Corners = new Vector3[4];

		public RectTransform content
		{
			get
			{
				return m_Content;
			}
			set
			{
				m_Content = value;
			}
		}

		public bool horizontal
		{
			get
			{
				return m_Horizontal;
			}
			set
			{
				m_Horizontal = value;
			}
		}

		public bool vertical
		{
			get
			{
				return m_Vertical;
			}
			set
			{
				m_Vertical = value;
			}
		}

		public MovementType movementType
		{
			get
			{
				return m_MovementType;
			}
			set
			{
				m_MovementType = value;
			}
		}

		public float elasticity
		{
			get
			{
				return m_Elasticity;
			}
			set
			{
				m_Elasticity = value;
			}
		}

		public bool inertia
		{
			get
			{
				return m_Inertia;
			}
			set
			{
				m_Inertia = value;
			}
		}

		public float decelerationRate
		{
			get
			{
				return m_DecelerationRate;
			}
			set
			{
				m_DecelerationRate = value;
			}
		}

		public float scrollSensitivity
		{
			get
			{
				return m_ScrollSensitivity;
			}
			set
			{
				m_ScrollSensitivity = value;
			}
		}

		public RectTransform viewport
		{
			get
			{
				return m_Viewport;
			}
			set
			{
				m_Viewport = value;
				SetDirtyCaching();
			}
		}

		public Scrollbar horizontalScrollbar
		{
			get
			{
				return m_HorizontalScrollbar;
			}
			set
			{
				if ((bool)m_HorizontalScrollbar)
				{
					m_HorizontalScrollbar.onValueChanged.RemoveListener(SetHorizontalNormalizedPosition);
				}
				m_HorizontalScrollbar = value;
				if ((bool)m_HorizontalScrollbar)
				{
					m_HorizontalScrollbar.onValueChanged.AddListener(SetHorizontalNormalizedPosition);
				}
				SetDirtyCaching();
			}
		}

		public Scrollbar verticalScrollbar
		{
			get
			{
				return m_VerticalScrollbar;
			}
			set
			{
				if ((bool)m_VerticalScrollbar)
				{
					m_VerticalScrollbar.onValueChanged.RemoveListener(SetVerticalNormalizedPosition);
				}
				m_VerticalScrollbar = value;
				if ((bool)m_VerticalScrollbar)
				{
					m_VerticalScrollbar.onValueChanged.AddListener(SetVerticalNormalizedPosition);
				}
				SetDirtyCaching();
			}
		}

		public ScrollbarVisibility horizontalScrollbarVisibility
		{
			get
			{
				return m_HorizontalScrollbarVisibility;
			}
			set
			{
				m_HorizontalScrollbarVisibility = value;
				SetDirtyCaching();
			}
		}

		public ScrollbarVisibility verticalScrollbarVisibility
		{
			get
			{
				return m_VerticalScrollbarVisibility;
			}
			set
			{
				m_VerticalScrollbarVisibility = value;
				SetDirtyCaching();
			}
		}

		public float horizontalScrollbarSpacing
		{
			get
			{
				return m_HorizontalScrollbarSpacing;
			}
			set
			{
				m_HorizontalScrollbarSpacing = value;
				SetDirty();
			}
		}

		public float verticalScrollbarSpacing
		{
			get
			{
				return m_VerticalScrollbarSpacing;
			}
			set
			{
				m_VerticalScrollbarSpacing = value;
				SetDirty();
			}
		}

		public ScrollRectEvent onValueChanged
		{
			get
			{
				return m_OnValueChanged;
			}
			set
			{
				m_OnValueChanged = value;
			}
		}

		protected RectTransform viewRect
		{
			get
			{
				if (m_ViewRect == null)
				{
					m_ViewRect = m_Viewport;
				}
				if (m_ViewRect == null)
				{
					m_ViewRect = (RectTransform)base.transform;
				}
				return m_ViewRect;
			}
		}

		public Vector2 velocity
		{
			get
			{
				return m_Velocity;
			}
			set
			{
				m_Velocity = value;
			}
		}

		private RectTransform rectTransform
		{
			get
			{
				if (m_Rect == null)
				{
					m_Rect = GetComponent<RectTransform>();
				}
				return m_Rect;
			}
		}

		public Vector2 normalizedPosition
		{
			get
			{
				return new Vector2(horizontalNormalizedPosition, verticalNormalizedPosition);
			}
			set
			{
				SetNormalizedPosition(value.x, 0);
				SetNormalizedPosition(value.y, 1);
			}
		}

		public float horizontalNormalizedPosition
		{
			get
			{
				UpdateBounds();
				if (m_ContentBounds.size.x <= m_ViewBounds.size.x || Mathf.Approximately(m_ContentBounds.size.x, m_ViewBounds.size.x))
				{
					return (m_ViewBounds.min.x > m_ContentBounds.min.x) ? 1 : 0;
				}
				return (m_ViewBounds.min.x - m_ContentBounds.min.x) / (m_ContentBounds.size.x - m_ViewBounds.size.x);
			}
			set
			{
				SetNormalizedPosition(value, 0);
			}
		}

		public float verticalNormalizedPosition
		{
			get
			{
				UpdateBounds();
				if (m_ContentBounds.size.y <= m_ViewBounds.size.y || Mathf.Approximately(m_ContentBounds.size.y, m_ViewBounds.size.y))
				{
					return (m_ViewBounds.min.y > m_ContentBounds.min.y) ? 1 : 0;
				}
				return (m_ViewBounds.min.y - m_ContentBounds.min.y) / (m_ContentBounds.size.y - m_ViewBounds.size.y);
			}
			set
			{
				SetNormalizedPosition(value, 1);
			}
		}

		private bool hScrollingNeeded
		{
			get
			{
				if (Application.isPlaying)
				{
					return m_ContentBounds.size.x > m_ViewBounds.size.x + 0.01f;
				}
				return true;
			}
		}

		private bool vScrollingNeeded
		{
			get
			{
				if (Application.isPlaying)
				{
					return m_ContentBounds.size.y > m_ViewBounds.size.y + 0.01f;
				}
				return true;
			}
		}

		public virtual float minWidth => -1f;

		public virtual float preferredWidth => -1f;

		public virtual float flexibleWidth => -1f;

		public virtual float minHeight => -1f;

		public virtual float preferredHeight => -1f;

		public virtual float flexibleHeight => -1f;

		public virtual int layoutPriority => -1;

		protected ScrollRect()
		{
		}

		public virtual void Rebuild(CanvasUpdate executing)
		{
			if (executing == CanvasUpdate.Prelayout)
			{
				UpdateCachedData();
			}
			if (executing == CanvasUpdate.PostLayout)
			{
				UpdateBounds();
				UpdateScrollbars(Vector2.zero);
				UpdatePrevData();
				m_HasRebuiltLayout = true;
			}
		}

		public virtual void LayoutComplete()
		{
		}

		public virtual void GraphicUpdateComplete()
		{
		}

		private void UpdateCachedData()
		{
			Transform transform = base.transform;
			m_HorizontalScrollbarRect = ((m_HorizontalScrollbar == null) ? null : (m_HorizontalScrollbar.transform as RectTransform));
			m_VerticalScrollbarRect = ((m_VerticalScrollbar == null) ? null : (m_VerticalScrollbar.transform as RectTransform));
			bool num = viewRect.parent == transform;
			bool flag = !m_HorizontalScrollbarRect || m_HorizontalScrollbarRect.parent == transform;
			bool flag2 = !m_VerticalScrollbarRect || m_VerticalScrollbarRect.parent == transform;
			bool flag3 = num && flag && flag2;
			m_HSliderExpand = flag3 && (bool)m_HorizontalScrollbarRect && horizontalScrollbarVisibility == ScrollbarVisibility.AutoHideAndExpandViewport;
			m_VSliderExpand = flag3 && (bool)m_VerticalScrollbarRect && verticalScrollbarVisibility == ScrollbarVisibility.AutoHideAndExpandViewport;
			m_HSliderHeight = ((m_HorizontalScrollbarRect == null) ? 0f : m_HorizontalScrollbarRect.rect.height);
			m_VSliderWidth = ((m_VerticalScrollbarRect == null) ? 0f : m_VerticalScrollbarRect.rect.width);
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			if ((bool)m_HorizontalScrollbar)
			{
				m_HorizontalScrollbar.onValueChanged.AddListener(SetHorizontalNormalizedPosition);
			}
			if ((bool)m_VerticalScrollbar)
			{
				m_VerticalScrollbar.onValueChanged.AddListener(SetVerticalNormalizedPosition);
			}
			CanvasUpdateRegistry.RegisterCanvasElementForLayoutRebuild(this);
			SetDirty();
		}

		protected override void OnDisable()
		{
			CanvasUpdateRegistry.UnRegisterCanvasElementForRebuild(this);
			if ((bool)m_HorizontalScrollbar)
			{
				m_HorizontalScrollbar.onValueChanged.RemoveListener(SetHorizontalNormalizedPosition);
			}
			if ((bool)m_VerticalScrollbar)
			{
				m_VerticalScrollbar.onValueChanged.RemoveListener(SetVerticalNormalizedPosition);
			}
			m_Dragging = false;
			m_Scrolling = false;
			m_HasRebuiltLayout = false;
			m_Tracker.Clear();
			m_Velocity = Vector2.zero;
			LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
			base.OnDisable();
		}

		public override bool IsActive()
		{
			if (base.IsActive())
			{
				return m_Content != null;
			}
			return false;
		}

		private void EnsureLayoutHasRebuilt()
		{
			if (!m_HasRebuiltLayout && !CanvasUpdateRegistry.IsRebuildingLayout())
			{
				Canvas.ForceUpdateCanvases();
			}
		}

		public virtual void StopMovement()
		{
			m_Velocity = Vector2.zero;
		}

		public virtual void OnScroll(PointerEventData data)
		{
			if (!IsActive())
			{
				return;
			}
			EnsureLayoutHasRebuilt();
			UpdateBounds();
			Vector2 scrollDelta = data.scrollDelta;
			scrollDelta.y *= -1f;
			if (vertical && !horizontal)
			{
				if (Mathf.Abs(scrollDelta.x) > Mathf.Abs(scrollDelta.y))
				{
					scrollDelta.y = scrollDelta.x;
				}
				scrollDelta.x = 0f;
			}
			if (horizontal && !vertical)
			{
				if (Mathf.Abs(scrollDelta.y) > Mathf.Abs(scrollDelta.x))
				{
					scrollDelta.x = scrollDelta.y;
				}
				scrollDelta.y = 0f;
			}
			if (data.IsScrolling())
			{
				m_Scrolling = true;
			}
			Vector2 anchoredPosition = m_Content.anchoredPosition;
			anchoredPosition += scrollDelta * (GlobalSensitivity * 65f);
			if (m_MovementType == MovementType.Clamped)
			{
				anchoredPosition += CalculateOffset(anchoredPosition - m_Content.anchoredPosition);
			}
			SetContentAnchoredPosition(anchoredPosition);
			UpdateBounds();
		}

		public virtual void OnInitializePotentialDrag(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left)
			{
				m_Velocity = Vector2.zero;
			}
		}

		public virtual void OnBeginDrag(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left && IsActive())
			{
				UpdateBounds();
				m_PointerStartLocalCursor = Vector2.zero;
				RectTransformUtility.ScreenPointToLocalPointInRectangle(viewRect, eventData.position, eventData.pressEventCamera, out m_PointerStartLocalCursor);
				m_ContentStartPosition = m_Content.anchoredPosition;
				m_Dragging = true;
			}
		}

		public virtual void OnEndDrag(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left)
			{
				m_Dragging = false;
			}
		}

		public virtual void OnDrag(PointerEventData eventData)
		{
			if (!m_Dragging || eventData.button != PointerEventData.InputButton.Left || !IsActive() || !RectTransformUtility.ScreenPointToLocalPointInRectangle(viewRect, eventData.position, eventData.pressEventCamera, out var localPoint))
			{
				return;
			}
			UpdateBounds();
			Vector2 vector = localPoint - m_PointerStartLocalCursor;
			Vector2 vector2 = m_ContentStartPosition + vector;
			Vector2 vector3 = CalculateOffset(vector2 - m_Content.anchoredPosition);
			vector2 += vector3;
			if (m_MovementType == MovementType.Elastic)
			{
				if (vector3.x != 0f)
				{
					vector2.x -= RubberDelta(vector3.x, m_ViewBounds.size.x);
				}
				if (vector3.y != 0f)
				{
					vector2.y -= RubberDelta(vector3.y, m_ViewBounds.size.y);
				}
			}
			SetContentAnchoredPosition(vector2);
		}

		protected virtual void SetContentAnchoredPosition(Vector2 position)
		{
			if (!m_Horizontal)
			{
				position.x = m_Content.anchoredPosition.x;
			}
			if (!m_Vertical)
			{
				position.y = m_Content.anchoredPosition.y;
			}
			if (position != m_Content.anchoredPosition)
			{
				m_Content.anchoredPosition = position;
				UpdateBounds();
			}
		}

		protected virtual void LateUpdate()
		{
			if (!m_Content)
			{
				return;
			}
			EnsureLayoutHasRebuilt();
			UpdateBounds();
			float unscaledDeltaTime = Time.unscaledDeltaTime;
			Vector2 vector = CalculateOffset(Vector2.zero);
			if (!m_Dragging && (vector != Vector2.zero || m_Velocity != Vector2.zero))
			{
				Vector2 anchoredPosition = m_Content.anchoredPosition;
				for (int i = 0; i < 2; i++)
				{
					if (m_MovementType == MovementType.Elastic && vector[i] != 0f)
					{
						float currentVelocity = m_Velocity[i];
						float num = m_Elasticity;
						if (m_Scrolling)
						{
							num *= 3f;
						}
						anchoredPosition[i] = Mathf.SmoothDamp(m_Content.anchoredPosition[i], m_Content.anchoredPosition[i] + vector[i], ref currentVelocity, num, float.PositiveInfinity, unscaledDeltaTime);
						if (Mathf.Abs(currentVelocity) < 1f)
						{
							currentVelocity = 0f;
						}
						m_Velocity[i] = currentVelocity;
					}
					else if (m_Inertia)
					{
						m_Velocity[i] *= Mathf.Pow(m_DecelerationRate, unscaledDeltaTime);
						if (Mathf.Abs(m_Velocity[i]) < 1f)
						{
							m_Velocity[i] = 0f;
						}
						anchoredPosition[i] += m_Velocity[i] * unscaledDeltaTime;
					}
					else
					{
						m_Velocity[i] = 0f;
					}
				}
				if (m_MovementType == MovementType.Clamped)
				{
					vector = CalculateOffset(anchoredPosition - m_Content.anchoredPosition);
					anchoredPosition += vector;
				}
				SetContentAnchoredPosition(anchoredPosition);
			}
			if (m_Dragging && m_Inertia)
			{
				Vector3 b = (m_Content.anchoredPosition - m_PrevPosition) / unscaledDeltaTime;
				m_Velocity = Vector3.Lerp(m_Velocity, b, unscaledDeltaTime * 10f);
			}
			if (m_ViewBounds != m_PrevViewBounds || m_ContentBounds != m_PrevContentBounds || m_Content.anchoredPosition != m_PrevPosition)
			{
				UpdateScrollbars(vector);
				UISystemProfilerApi.AddMarker("ScrollRect.value", this);
				m_OnValueChanged.Invoke(normalizedPosition);
				UpdatePrevData();
			}
			UpdateScrollbarVisibility();
			m_Scrolling = false;
		}

		protected void UpdatePrevData()
		{
			if (m_Content == null)
			{
				m_PrevPosition = Vector2.zero;
			}
			else
			{
				m_PrevPosition = m_Content.anchoredPosition;
			}
			m_PrevViewBounds = m_ViewBounds;
			m_PrevContentBounds = m_ContentBounds;
		}

		private void UpdateScrollbars(Vector2 offset)
		{
			if ((bool)m_HorizontalScrollbar)
			{
				if (m_ContentBounds.size.x > 0f)
				{
					m_HorizontalScrollbar.size = Mathf.Clamp01((m_ViewBounds.size.x - Mathf.Abs(offset.x)) / m_ContentBounds.size.x);
				}
				else
				{
					m_HorizontalScrollbar.size = 1f;
				}
				m_HorizontalScrollbar.value = horizontalNormalizedPosition;
			}
			if ((bool)m_VerticalScrollbar)
			{
				if (m_ContentBounds.size.y > 0f)
				{
					m_VerticalScrollbar.size = Mathf.Clamp01((m_ViewBounds.size.y - Mathf.Abs(offset.y)) / m_ContentBounds.size.y);
				}
				else
				{
					m_VerticalScrollbar.size = 1f;
				}
				m_VerticalScrollbar.value = verticalNormalizedPosition;
			}
		}

		private void SetHorizontalNormalizedPosition(float value)
		{
			SetNormalizedPosition(value, 0);
		}

		private void SetVerticalNormalizedPosition(float value)
		{
			SetNormalizedPosition(value, 1);
		}

		protected virtual void SetNormalizedPosition(float value, int axis)
		{
			EnsureLayoutHasRebuilt();
			UpdateBounds();
			float num = m_ContentBounds.size[axis] - m_ViewBounds.size[axis];
			float num2 = m_ViewBounds.min[axis] - value * num;
			float num3 = m_Content.localPosition[axis] + num2 - m_ContentBounds.min[axis];
			Vector3 localPosition = m_Content.localPosition;
			if (Mathf.Abs(localPosition[axis] - num3) > 0.01f)
			{
				localPosition[axis] = num3;
				m_Content.localPosition = localPosition;
				m_Velocity[axis] = 0f;
				UpdateBounds();
			}
		}

		private static float RubberDelta(float overStretching, float viewSize)
		{
			return (1f - 1f / (Mathf.Abs(overStretching) * 0.55f / viewSize + 1f)) * viewSize * Mathf.Sign(overStretching);
		}

		protected override void OnRectTransformDimensionsChange()
		{
			SetDirty();
		}

		public virtual void CalculateLayoutInputHorizontal()
		{
		}

		public virtual void CalculateLayoutInputVertical()
		{
		}

		public virtual void SetLayoutHorizontal()
		{
			m_Tracker.Clear();
			if (m_HSliderExpand || m_VSliderExpand)
			{
				m_Tracker.Add(this, viewRect, DrivenTransformProperties.Anchors | DrivenTransformProperties.AnchoredPosition | DrivenTransformProperties.SizeDelta);
				viewRect.anchorMin = Vector2.zero;
				viewRect.anchorMax = Vector2.one;
				viewRect.sizeDelta = Vector2.zero;
				viewRect.anchoredPosition = Vector2.zero;
				LayoutRebuilder.ForceRebuildLayoutImmediate(content);
				m_ViewBounds = new Bounds(viewRect.rect.center, viewRect.rect.size);
				m_ContentBounds = GetBounds();
			}
			if (m_VSliderExpand && vScrollingNeeded)
			{
				viewRect.sizeDelta = new Vector2(0f - (m_VSliderWidth + m_VerticalScrollbarSpacing), viewRect.sizeDelta.y);
				LayoutRebuilder.ForceRebuildLayoutImmediate(content);
				m_ViewBounds = new Bounds(viewRect.rect.center, viewRect.rect.size);
				m_ContentBounds = GetBounds();
			}
			if (m_HSliderExpand && hScrollingNeeded)
			{
				viewRect.sizeDelta = new Vector2(viewRect.sizeDelta.x, 0f - (m_HSliderHeight + m_HorizontalScrollbarSpacing));
				m_ViewBounds = new Bounds(viewRect.rect.center, viewRect.rect.size);
				m_ContentBounds = GetBounds();
			}
			if (m_VSliderExpand && vScrollingNeeded && viewRect.sizeDelta.x == 0f && viewRect.sizeDelta.y < 0f)
			{
				viewRect.sizeDelta = new Vector2(0f - (m_VSliderWidth + m_VerticalScrollbarSpacing), viewRect.sizeDelta.y);
			}
		}

		public virtual void SetLayoutVertical()
		{
			UpdateScrollbarLayout();
			m_ViewBounds = new Bounds(viewRect.rect.center, viewRect.rect.size);
			m_ContentBounds = GetBounds();
		}

		private void UpdateScrollbarVisibility()
		{
			UpdateOneScrollbarVisibility(vScrollingNeeded, m_Vertical, m_VerticalScrollbarVisibility, m_VerticalScrollbar);
			UpdateOneScrollbarVisibility(hScrollingNeeded, m_Horizontal, m_HorizontalScrollbarVisibility, m_HorizontalScrollbar);
		}

		private static void UpdateOneScrollbarVisibility(bool xScrollingNeeded, bool xAxisEnabled, ScrollbarVisibility scrollbarVisibility, Scrollbar scrollbar)
		{
			if (!scrollbar)
			{
				return;
			}
			if (scrollbarVisibility == ScrollbarVisibility.Permanent)
			{
				if (scrollbar.gameObject.activeSelf != xAxisEnabled)
				{
					scrollbar.gameObject.SetActive(xAxisEnabled);
				}
			}
			else if (scrollbar.gameObject.activeSelf != xScrollingNeeded)
			{
				scrollbar.gameObject.SetActive(xScrollingNeeded);
			}
		}

		private void UpdateScrollbarLayout()
		{
			if (m_VSliderExpand && (bool)m_HorizontalScrollbar)
			{
				m_Tracker.Add(this, m_HorizontalScrollbarRect, DrivenTransformProperties.AnchoredPositionX | DrivenTransformProperties.AnchorMinX | DrivenTransformProperties.AnchorMaxX | DrivenTransformProperties.SizeDeltaX);
				m_HorizontalScrollbarRect.anchorMin = new Vector2(0f, m_HorizontalScrollbarRect.anchorMin.y);
				m_HorizontalScrollbarRect.anchorMax = new Vector2(1f, m_HorizontalScrollbarRect.anchorMax.y);
				m_HorizontalScrollbarRect.anchoredPosition = new Vector2(0f, m_HorizontalScrollbarRect.anchoredPosition.y);
				if (vScrollingNeeded)
				{
					m_HorizontalScrollbarRect.sizeDelta = new Vector2(0f - (m_VSliderWidth + m_VerticalScrollbarSpacing), m_HorizontalScrollbarRect.sizeDelta.y);
				}
				else
				{
					m_HorizontalScrollbarRect.sizeDelta = new Vector2(0f, m_HorizontalScrollbarRect.sizeDelta.y);
				}
			}
			if (m_HSliderExpand && (bool)m_VerticalScrollbar)
			{
				m_Tracker.Add(this, m_VerticalScrollbarRect, DrivenTransformProperties.AnchoredPositionY | DrivenTransformProperties.AnchorMinY | DrivenTransformProperties.AnchorMaxY | DrivenTransformProperties.SizeDeltaY);
				m_VerticalScrollbarRect.anchorMin = new Vector2(m_VerticalScrollbarRect.anchorMin.x, 0f);
				m_VerticalScrollbarRect.anchorMax = new Vector2(m_VerticalScrollbarRect.anchorMax.x, 1f);
				m_VerticalScrollbarRect.anchoredPosition = new Vector2(m_VerticalScrollbarRect.anchoredPosition.x, 0f);
				if (hScrollingNeeded)
				{
					m_VerticalScrollbarRect.sizeDelta = new Vector2(m_VerticalScrollbarRect.sizeDelta.x, 0f - (m_HSliderHeight + m_HorizontalScrollbarSpacing));
				}
				else
				{
					m_VerticalScrollbarRect.sizeDelta = new Vector2(m_VerticalScrollbarRect.sizeDelta.x, 0f);
				}
			}
		}

		protected void UpdateBounds()
		{
			m_ViewBounds = new Bounds(viewRect.rect.center, viewRect.rect.size);
			m_ContentBounds = GetBounds();
			if (m_Content == null)
			{
				return;
			}
			Vector3 contentSize = m_ContentBounds.size;
			Vector3 contentPos = m_ContentBounds.center;
			Vector2 contentPivot = m_Content.pivot;
			AdjustBounds(ref m_ViewBounds, ref contentPivot, ref contentSize, ref contentPos);
			m_ContentBounds.size = contentSize;
			m_ContentBounds.center = contentPos;
			if (movementType != MovementType.Clamped)
			{
				return;
			}
			Vector2 zero = Vector2.zero;
			if (m_ViewBounds.max.x > m_ContentBounds.max.x)
			{
				zero.x = Math.Min(m_ViewBounds.min.x - m_ContentBounds.min.x, m_ViewBounds.max.x - m_ContentBounds.max.x);
			}
			else if (m_ViewBounds.min.x < m_ContentBounds.min.x)
			{
				zero.x = Math.Max(m_ViewBounds.min.x - m_ContentBounds.min.x, m_ViewBounds.max.x - m_ContentBounds.max.x);
			}
			if (m_ViewBounds.min.y < m_ContentBounds.min.y)
			{
				zero.y = Math.Max(m_ViewBounds.min.y - m_ContentBounds.min.y, m_ViewBounds.max.y - m_ContentBounds.max.y);
			}
			else if (m_ViewBounds.max.y > m_ContentBounds.max.y)
			{
				zero.y = Math.Min(m_ViewBounds.min.y - m_ContentBounds.min.y, m_ViewBounds.max.y - m_ContentBounds.max.y);
			}
			if (zero.sqrMagnitude > float.Epsilon)
			{
				contentPos = m_Content.anchoredPosition + zero;
				if (!m_Horizontal)
				{
					contentPos.x = m_Content.anchoredPosition.x;
				}
				if (!m_Vertical)
				{
					contentPos.y = m_Content.anchoredPosition.y;
				}
				AdjustBounds(ref m_ViewBounds, ref contentPivot, ref contentSize, ref contentPos);
			}
		}

		internal static void AdjustBounds(ref Bounds viewBounds, ref Vector2 contentPivot, ref Vector3 contentSize, ref Vector3 contentPos)
		{
			Vector3 vector = viewBounds.size - contentSize;
			if (vector.x > 0f)
			{
				contentPos.x -= vector.x * (contentPivot.x - 0.5f);
				contentSize.x = viewBounds.size.x;
			}
			if (vector.y > 0f)
			{
				contentPos.y -= vector.y * (contentPivot.y - 0.5f);
				contentSize.y = viewBounds.size.y;
			}
		}

		private Bounds GetBounds()
		{
			if (m_Content == null)
			{
				return default(Bounds);
			}
			m_Content.GetWorldCorners(m_Corners);
			Matrix4x4 viewWorldToLocalMatrix = viewRect.worldToLocalMatrix;
			return InternalGetBounds(m_Corners, ref viewWorldToLocalMatrix);
		}

		internal static Bounds InternalGetBounds(Vector3[] corners, ref Matrix4x4 viewWorldToLocalMatrix)
		{
			Vector3 vector = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
			Vector3 vector2 = new Vector3(float.MinValue, float.MinValue, float.MinValue);
			for (int i = 0; i < 4; i++)
			{
				Vector3 lhs = viewWorldToLocalMatrix.MultiplyPoint3x4(corners[i]);
				vector = Vector3.Min(lhs, vector);
				vector2 = Vector3.Max(lhs, vector2);
			}
			Bounds result = new Bounds(vector, Vector3.zero);
			result.Encapsulate(vector2);
			return result;
		}

		private Vector2 CalculateOffset(Vector2 delta)
		{
			return InternalCalculateOffset(ref m_ViewBounds, ref m_ContentBounds, m_Horizontal, m_Vertical, m_MovementType, ref delta);
		}

		internal static Vector2 InternalCalculateOffset(ref Bounds viewBounds, ref Bounds contentBounds, bool horizontal, bool vertical, MovementType movementType, ref Vector2 delta)
		{
			Vector2 zero = Vector2.zero;
			if (movementType == MovementType.Unrestricted)
			{
				return zero;
			}
			Vector2 vector = contentBounds.min;
			Vector2 vector2 = contentBounds.max;
			if (horizontal)
			{
				vector.x += delta.x;
				vector2.x += delta.x;
				float num = viewBounds.max.x - vector2.x;
				float num2 = viewBounds.min.x - vector.x;
				if (num2 < -0.001f)
				{
					zero.x = num2;
				}
				else if (num > 0.001f)
				{
					zero.x = num;
				}
			}
			if (vertical)
			{
				vector.y += delta.y;
				vector2.y += delta.y;
				float num3 = viewBounds.max.y - vector2.y;
				float num4 = viewBounds.min.y - vector.y;
				if (num3 > 0.001f)
				{
					zero.y = num3;
				}
				else if (num4 < -0.001f)
				{
					zero.y = num4;
				}
			}
			return zero;
		}

		protected void SetDirty()
		{
			if (IsActive())
			{
				LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
			}
		}

		protected void SetDirtyCaching()
		{
			if (IsActive())
			{
				CanvasUpdateRegistry.RegisterCanvasElementForLayoutRebuild(this);
				LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
			}
		}

		Transform ICanvasElement.get_transform()
		{
			return base.transform;
		}
	}
	[AddComponentMenu("", 70)]
	[ExecuteAlways]
	[SelectionBase]
	[DisallowMultipleComponent]
	public class Selectable : UIBehaviour, IMoveHandler, IEventSystemHandler, IPointerDownHandler, IPointerUpHandler, IPointerEnterHandler, IPointerExitHandler, ISelectHandler, IDeselectHandler
	{
		public enum Transition
		{
			None,
			ColorTint,
			SpriteSwap,
			Animation
		}

		protected enum SelectionState
		{
			Normal,
			Highlighted,
			Pressed,
			Selected,
			Disabled
		}

		private static Selectable[] s_Selectables = new Selectable[10];

		private static int s_SelectableCount = 0;

		private static bool s_IsDirty = false;

		[FormerlySerializedAs("navigation")]
		[SerializeField]
		private Navigation m_Navigation = Navigation.defaultNavigation;

		[FormerlySerializedAs("transition")]
		[SerializeField]
		private Transition m_Transition = Transition.ColorTint;

		[FormerlySerializedAs("colors")]
		[SerializeField]
		private ColorBlock m_Colors = ColorBlock.defaultColorBlock;

		[FormerlySerializedAs("spriteState")]
		[SerializeField]
		private SpriteState m_SpriteState;

		[FormerlySerializedAs("animationTriggers")]
		[SerializeField]
		private AnimationTriggers m_AnimationTriggers = new AnimationTriggers();

		[Tooltip("Can the Selectable be interacted with?")]
		[SerializeField]
		private bool m_Interactable = true;

		[FormerlySerializedAs("highlightGraphic")]
		[FormerlySerializedAs("m_HighlightGraphic")]
		[SerializeField]
		private Graphic m_TargetGraphic;

		private bool m_GroupsAllowInteraction = true;

		private bool m_WillRemove;

		private readonly List<CanvasGroup> m_CanvasGroupCache = new List<CanvasGroup>();

		public static Selectable[] allSelectablesArray
		{
			get
			{
				if (s_IsDirty)
				{
					RemoveInvalidSelectables();
				}
				Selectable[] array = new Selectable[s_SelectableCount];
				Array.Copy(s_Selectables, array, s_SelectableCount);
				return array;
			}
		}

		public static int allSelectableCount => s_SelectableCount;

		[Obsolete("Replaced with allSelectablesArray to have better performance when disabling a element", false)]
		public static List<Selectable> allSelectables => new List<Selectable>(allSelectablesArray);

		public Navigation navigation
		{
			get
			{
				return m_Navigation;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_Navigation, value))
				{
					OnSetProperty();
				}
			}
		}

		public Transition transition
		{
			get
			{
				return m_Transition;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_Transition, value))
				{
					OnSetProperty();
				}
			}
		}

		public ColorBlock colors
		{
			get
			{
				return m_Colors;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_Colors, value))
				{
					OnSetProperty();
				}
			}
		}

		public SpriteState spriteState
		{
			get
			{
				return m_SpriteState;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_SpriteState, value))
				{
					OnSetProperty();
				}
			}
		}

		public AnimationTriggers animationTriggers
		{
			get
			{
				return m_AnimationTriggers;
			}
			set
			{
				if (SetPropertyUtility.SetClass(ref m_AnimationTriggers, value))
				{
					OnSetProperty();
				}
			}
		}

		public Graphic targetGraphic
		{
			get
			{
				return m_TargetGraphic;
			}
			set
			{
				if (SetPropertyUtility.SetClass(ref m_TargetGraphic, value))
				{
					OnSetProperty();
				}
			}
		}

		public bool interactable
		{
			get
			{
				return m_Interactable;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_Interactable, value))
				{
					if (!m_Interactable && EventSystem.current != null && EventSystem.current.currentSelectedGameObject == base.gameObject)
					{
						EventSystem.current.SetSelectedGameObject(null);
					}
					OnSetProperty();
				}
			}
		}

		private bool isPointerInside { get; set; }

		private bool isPointerDown { get; set; }

		private bool hasSelection { get; set; }

		public Image image
		{
			get
			{
				return m_TargetGraphic as Image;
			}
			set
			{
				m_TargetGraphic = value;
			}
		}

		public Animator animator => GetComponent<Animator>();

		protected SelectionState currentSelectionState
		{
			get
			{
				if (!IsInteractable())
				{
					return SelectionState.Disabled;
				}
				if (isPointerDown)
				{
					return SelectionState.Pressed;
				}
				if (hasSelection)
				{
					return SelectionState.Selected;
				}
				if (isPointerInside)
				{
					return SelectionState.Highlighted;
				}
				return SelectionState.Normal;
			}
		}

		public static int AllSelectablesNoAlloc(Selectable[] selectables)
		{
			if (s_IsDirty)
			{
				RemoveInvalidSelectables();
			}
			int num = ((selectables.Length < s_SelectableCount) ? selectables.Length : s_SelectableCount);
			Array.Copy(s_Selectables, selectables, num);
			return num;
		}

		protected Selectable()
		{
		}

		protected override void Awake()
		{
			if (m_TargetGraphic == null)
			{
				m_TargetGraphic = GetComponent<Graphic>();
			}
		}

		protected override void OnCanvasGroupChanged()
		{
			bool flag = true;
			Transform parent = base.transform;
			while (parent != null)
			{
				parent.GetComponents(m_CanvasGroupCache);
				bool flag2 = false;
				for (int i = 0; i < m_CanvasGroupCache.Count; i++)
				{
					if (!m_CanvasGroupCache[i].interactable)
					{
						flag = false;
						flag2 = true;
					}
					if (m_CanvasGroupCache[i].ignoreParentGroups)
					{
						flag2 = true;
					}
				}
				if (flag2)
				{
					break;
				}
				parent = parent.parent;
			}
			if (flag != m_GroupsAllowInteraction)
			{
				m_GroupsAllowInteraction = flag;
				OnSetProperty();
			}
		}

		public virtual bool IsInteractable()
		{
			if (m_GroupsAllowInteraction)
			{
				return m_Interactable;
			}
			return false;
		}

		protected override void OnDidApplyAnimationProperties()
		{
			OnSetProperty();
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			if (s_IsDirty)
			{
				RemoveInvalidSelectables();
			}
			m_WillRemove = false;
			if (s_SelectableCount == s_Selectables.Length)
			{
				Selectable[] destinationArray = new Selectable[s_Selectables.Length * 2];
				Array.Copy(s_Selectables, destinationArray, s_Selectables.Length);
				s_Selectables = destinationArray;
			}
			s_Selectables[s_SelectableCount++] = this;
			isPointerDown = false;
			DoStateTransition(currentSelectionState, instant: true);
		}

		protected override void OnTransformParentChanged()
		{
			base.OnTransformParentChanged();
			OnCanvasGroupChanged();
		}

		private void OnSetProperty()
		{
			DoStateTransition(currentSelectionState, instant: false);
		}

		protected override void OnDisable()
		{
			m_WillRemove = true;
			s_IsDirty = true;
			InstantClearState();
			base.OnDisable();
		}

		private static void RemoveInvalidSelectables()
		{
			for (int num = s_SelectableCount - 1; num >= 0; num--)
			{
				if (s_Selectables[num] == null || s_Selectables[num].m_WillRemove)
				{
					s_Selectables[num] = s_Selectables[--s_SelectableCount];
				}
			}
			s_IsDirty = false;
		}

		protected virtual void InstantClearState()
		{
			string normalTrigger = m_AnimationTriggers.normalTrigger;
			isPointerInside = false;
			isPointerDown = false;
			hasSelection = false;
			switch (m_Transition)
			{
			case Transition.ColorTint:
				StartColorTween(Color.white, instant: true);
				break;
			case Transition.SpriteSwap:
				DoSpriteSwap(null);
				break;
			case Transition.Animation:
				TriggerAnimation(normalTrigger);
				break;
			}
		}

		protected virtual void DoStateTransition(SelectionState state, bool instant)
		{
			if (base.gameObject.activeInHierarchy)
			{
				Color color;
				Sprite newSprite;
				string triggername;
				switch (state)
				{
				case SelectionState.Normal:
					color = m_Colors.normalColor;
					newSprite = null;
					triggername = m_AnimationTriggers.normalTrigger;
					break;
				case SelectionState.Highlighted:
					color = m_Colors.highlightedColor;
					newSprite = m_SpriteState.highlightedSprite;
					triggername = m_AnimationTriggers.highlightedTrigger;
					break;
				case SelectionState.Pressed:
					color = m_Colors.pressedColor;
					newSprite = m_SpriteState.pressedSprite;
					triggername = m_AnimationTriggers.pressedTrigger;
					break;
				case SelectionState.Selected:
					color = m_Colors.selectedColor;
					newSprite = m_SpriteState.selectedSprite;
					triggername = m_AnimationTriggers.selectedTrigger;
					break;
				case SelectionState.Disabled:
					color = m_Colors.disabledColor;
					newSprite = m_SpriteState.disabledSprite;
					triggername = m_AnimationTriggers.disabledTrigger;
					break;
				default:
					color = Color.black;
					newSprite = null;
					triggername = string.Empty;
					break;
				}
				switch (m_Transition)
				{
				case Transition.ColorTint:
					StartColorTween(color * m_Colors.colorMultiplier, instant);
					break;
				case Transition.SpriteSwap:
					DoSpriteSwap(newSprite);
					break;
				case Transition.Animation:
					TriggerAnimation(triggername);
					break;
				}
			}
		}

		public Selectable FindSelectable(Vector3 dir)
		{
			dir = dir.normalized;
			Vector3 vector = Quaternion.Inverse(base.transform.rotation) * dir;
			Vector3 vector2 = base.transform.TransformPoint(GetPointOnRectEdge(base.transform as RectTransform, vector));
			float num = float.NegativeInfinity;
			Selectable result = null;
			if (s_IsDirty)
			{
				RemoveInvalidSelectables();
			}
			for (int i = 0; i < s_SelectableCount; i++)
			{
				Selectable selectable = s_Selectables[i];
				if (selectable == this || !selectable.IsInteractable() || selectable.navigation.mode == Navigation.Mode.None)
				{
					continue;
				}
				RectTransform rectTransform = selectable.transform as RectTransform;
				Vector3 position = ((rectTransform != null) ? ((Vector3)rectTransform.rect.center) : Vector3.zero);
				Vector3 rhs = selectable.transform.TransformPoint(position) - vector2;
				float num2 = Vector3.Dot(dir, rhs);
				if (!(num2 <= 0f))
				{
					float num3 = num2 / rhs.sqrMagnitude;
					if (num3 > num)
					{
						num = num3;
						result = selectable;
					}
				}
			}
			return result;
		}

		private static Vector3 GetPointOnRectEdge(RectTransform rect, Vector2 dir)
		{
			if (rect == null)
			{
				return Vector3.zero;
			}
			if (dir != Vector2.zero)
			{
				dir /= Mathf.Max(Mathf.Abs(dir.x), Mathf.Abs(dir.y));
			}
			dir = rect.rect.center + Vector2.Scale(rect.rect.size, dir * 0.5f);
			return dir;
		}

		private void Navigate(AxisEventData eventData, Selectable sel)
		{
			if (sel != null && sel.IsActive())
			{
				eventData.selectedObject = sel.gameObject;
			}
		}

		public virtual Selectable FindSelectableOnLeft()
		{
			if (m_Navigation.mode == Navigation.Mode.Explicit)
			{
				return m_Navigation.selectOnLeft;
			}
			if ((m_Navigation.mode & Navigation.Mode.Horizontal) != Navigation.Mode.None)
			{
				return FindSelectable(base.transform.rotation * Vector3.left);
			}
			return null;
		}

		public virtual Selectable FindSelectableOnRight()
		{
			if (m_Navigation.mode == Navigation.Mode.Explicit)
			{
				return m_Navigation.selectOnRight;
			}
			if ((m_Navigation.mode & Navigation.Mode.Horizontal) != Navigation.Mode.None)
			{
				return FindSelectable(base.transform.rotation * Vector3.right);
			}
			return null;
		}

		public virtual Selectable FindSelectableOnUp()
		{
			if (m_Navigation.mode == Navigation.Mode.Explicit)
			{
				return m_Navigation.selectOnUp;
			}
			if ((m_Navigation.mode & Navigation.Mode.Vertical) != Navigation.Mode.None)
			{
				return FindSelectable(base.transform.rotation * Vector3.up);
			}
			return null;
		}

		public virtual Selectable FindSelectableOnDown()
		{
			if (m_Navigation.mode == Navigation.Mode.Explicit)
			{
				return m_Navigation.selectOnDown;
			}
			if ((m_Navigation.mode & Navigation.Mode.Vertical) != Navigation.Mode.None)
			{
				return FindSelectable(base.transform.rotation * Vector3.down);
			}
			return null;
		}

		public virtual void OnMove(AxisEventData eventData)
		{
			switch (eventData.moveDir)
			{
			case MoveDirection.Right:
				Navigate(eventData, FindSelectableOnRight());
				break;
			case MoveDirection.Up:
				Navigate(eventData, FindSelectableOnUp());
				break;
			case MoveDirection.Left:
				Navigate(eventData, FindSelectableOnLeft());
				break;
			case MoveDirection.Down:
				Navigate(eventData, FindSelectableOnDown());
				break;
			}
		}

		private void StartColorTween(Color targetColor, bool instant)
		{
			if (!(m_TargetGraphic == null))
			{
				m_TargetGraphic.CrossFadeColor(targetColor, instant ? 0f : m_Colors.fadeDuration, ignoreTimeScale: true, useAlpha: true);
			}
		}

		private void DoSpriteSwap(Sprite newSprite)
		{
			if (!(image == null))
			{
				image.overrideSprite = newSprite;
			}
		}

		private void TriggerAnimation(string triggername)
		{
			if (transition == Transition.Animation && !(animator == null) && animator.isActiveAndEnabled && animator.hasBoundPlayables && !string.IsNullOrEmpty(triggername))
			{
				animator.ResetTrigger(m_AnimationTriggers.normalTrigger);
				animator.ResetTrigger(m_AnimationTriggers.highlightedTrigger);
				animator.ResetTrigger(m_AnimationTriggers.pressedTrigger);
				animator.ResetTrigger(m_AnimationTriggers.selectedTrigger);
				animator.ResetTrigger(m_AnimationTriggers.disabledTrigger);
				animator.SetTrigger(triggername);
			}
		}

		protected bool IsHighlighted()
		{
			if (!IsActive() || !IsInteractable())
			{
				return false;
			}
			if (isPointerInside && !isPointerDown)
			{
				return !hasSelection;
			}
			return false;
		}

		protected bool IsPressed()
		{
			if (!IsActive() || !IsInteractable())
			{
				return false;
			}
			return isPointerDown;
		}

		private void EvaluateAndTransitionToSelectionState()
		{
			if (IsActive() && IsInteractable())
			{
				DoStateTransition(currentSelectionState, instant: false);
			}
		}

		public virtual void OnPointerDown(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left)
			{
				if (IsInteractable() && navigation.mode != Navigation.Mode.None && EventSystem.current != null)
				{
					EventSystem.current.SetSelectedGameObject(base.gameObject, eventData);
				}
				isPointerDown = true;
				EvaluateAndTransitionToSelectionState();
			}
		}

		public virtual void OnPointerUp(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left)
			{
				isPointerDown = false;
				EvaluateAndTransitionToSelectionState();
			}
		}

		public virtual void OnPointerEnter(PointerEventData eventData)
		{
			isPointerInside = true;
			EvaluateAndTransitionToSelectionState();
		}

		public virtual void OnPointerExit(PointerEventData eventData)
		{
			isPointerInside = false;
			EvaluateAndTransitionToSelectionState();
		}

		public virtual void OnSelect(BaseEventData eventData)
		{
			hasSelection = true;
			EvaluateAndTransitionToSelectionState();
		}

		public virtual void OnDeselect(BaseEventData eventData)
		{
			hasSelection = false;
			EvaluateAndTransitionToSelectionState();
		}

		public virtual void Select()
		{
			if (!(EventSystem.current == null) && !EventSystem.current.alreadySelecting)
			{
				EventSystem.current.SetSelectedGameObject(base.gameObject);
			}
		}
	}
	internal static class SetPropertyUtility
	{
		public static bool SetColor(ref Color currentValue, Color newValue)
		{
			if (currentValue.r == newValue.r && currentValue.g == newValue.g && currentValue.b == newValue.b && currentValue.a == newValue.a)
			{
				return false;
			}
			currentValue = newValue;
			return true;
		}

		public static bool SetStruct<T>(ref T currentValue, T newValue) where T : struct
		{
			if (EqualityComparer<T>.Default.Equals(currentValue, newValue))
			{
				return false;
			}
			currentValue = newValue;
			return true;
		}

		public static bool SetClass<T>(ref T currentValue, T newValue) where T : class
		{
			if ((currentValue == null && newValue == null) || (currentValue != null && currentValue.Equals(newValue)))
			{
				return false;
			}
			currentValue = newValue;
			return true;
		}
	}
	[AddComponentMenu("", 33)]
	[ExecuteInEditMode]
	[RequireComponent(typeof(RectTransform))]
	public class Slider : Selectable, IDragHandler, IEventSystemHandler, IInitializePotentialDragHandler, ICanvasElement
	{
		public enum Direction
		{
			LeftToRight,
			RightToLeft,
			BottomToTop,
			TopToBottom
		}

		[Serializable]
		public class SliderEvent : UnityEvent<float>
		{
		}

		private enum Axis
		{
			Horizontal,
			Vertical
		}

		[SerializeField]
		private RectTransform m_FillRect;

		[SerializeField]
		private RectTransform m_HandleRect;

		[Space]
		[SerializeField]
		private Direction m_Direction;

		[SerializeField]
		private float m_MinValue;

		[SerializeField]
		private float m_MaxValue = 1f;

		[SerializeField]
		private bool m_WholeNumbers;

		[SerializeField]
		protected float m_Value;

		[Space]
		[SerializeField]
		private SliderEvent m_OnValueChanged = new SliderEvent();

		private Image m_FillImage;

		private Transform m_FillTransform;

		private RectTransform m_FillContainerRect;

		private Transform m_HandleTransform;

		private RectTransform m_HandleContainerRect;

		private Vector2 m_Offset = Vector2.zero;

		private DrivenRectTransformTracker m_Tracker;

		private bool m_DelayedUpdateVisuals;

		public RectTransform fillRect
		{
			get
			{
				return m_FillRect;
			}
			set
			{
				if (SetPropertyUtility.SetClass(ref m_FillRect, value))
				{
					UpdateCachedReferences();
					UpdateVisuals();
				}
			}
		}

		public RectTransform handleRect
		{
			get
			{
				return m_HandleRect;
			}
			set
			{
				if (SetPropertyUtility.SetClass(ref m_HandleRect, value))
				{
					UpdateCachedReferences();
					UpdateVisuals();
				}
			}
		}

		public Direction direction
		{
			get
			{
				return m_Direction;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_Direction, value))
				{
					UpdateVisuals();
				}
			}
		}

		public float minValue
		{
			get
			{
				return m_MinValue;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_MinValue, value))
				{
					Set(m_Value);
					UpdateVisuals();
				}
			}
		}

		public float maxValue
		{
			get
			{
				return m_MaxValue;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_MaxValue, value))
				{
					Set(m_Value);
					UpdateVisuals();
				}
			}
		}

		public bool wholeNumbers
		{
			get
			{
				return m_WholeNumbers;
			}
			set
			{
				if (SetPropertyUtility.SetStruct(ref m_WholeNumbers, value))
				{
					Set(m_Value);
					UpdateVisuals();
				}
			}
		}

		public virtual float value
		{
			get
			{
				if (wholeNumbers)
				{
					return Mathf.Round(m_Value);
				}
				return m_Value;
			}
			set
			{
				Set(value);
			}
		}

		public float normalizedValue
		{
			get
			{
				if (Mathf.Approximately(minValue, maxValue))
				{
					return 0f;
				}
				return Mathf.InverseLerp(minValue, maxValue, value);
			}
			set
			{
				this.value = Mathf.Lerp(minValue, maxValue, value);
			}
		}

		public SliderEvent onValueChanged
		{
			get
			{
				return m_OnValueChanged;
			}
			set
			{
				m_OnValueChanged = value;
			}
		}

		private float stepSize
		{
			get
			{
				if (!wholeNumbers)
				{
					return (maxValue - minValue) * 0.1f;
				}
				return 1f;
			}
		}

		private Axis axis
		{
			get
			{
				if (m_Direction != Direction.LeftToRight && m_Direction != Direction.RightToLeft)
				{
					return Axis.Vertical;
				}
				return Axis.Horizontal;
			}
		}

		private bool reverseValue
		{
			get
			{
				if (m_Direction != Direction.RightToLeft)
				{
					return m_Direction == Direction.TopToBottom;
				}
				return true;
			}
		}

		public virtual void SetValueWithoutNotify(float input)
		{
			Set(input, sendCallback: false);
		}

		protected Slider()
		{
		}

		public virtual void Rebuild(CanvasUpdate executing)
		{
		}

		public virtual void LayoutComplete()
		{
		}

		public virtual void GraphicUpdateComplete()
		{
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			UpdateCachedReferences();
			Set(m_Value, sendCallback: false);
			UpdateVisuals();
		}

		protected override void OnDisable()
		{
			m_Tracker.Clear();
			base.OnDisable();
		}

		protected virtual void Update()
		{
			if (m_DelayedUpdateVisuals)
			{
				m_DelayedUpdateVisuals = false;
				UpdateVisuals();
			}
		}

		protected override void OnDidApplyAnimationProperties()
		{
			m_Value = ClampValue(m_Value);
			float num = normalizedValue;
			if (m_FillContainerRect != null)
			{
				num = ((!(m_FillImage != null) || m_FillImage.type != Image.Type.Filled) ? (reverseValue ? (1f - m_FillRect.anchorMin[(int)axis]) : m_FillRect.anchorMax[(int)axis]) : m_FillImage.fillAmount);
			}
			else if (m_HandleContainerRect != null)
			{
				num = (reverseValue ? (1f - m_HandleRect.anchorMin[(int)axis]) : m_HandleRect.anchorMin[(int)axis]);
			}
			UpdateVisuals();
			if (num != normalizedValue)
			{
				UISystemProfilerApi.AddMarker("Slider.value", this);
				onValueChanged.Invoke(m_Value);
			}
		}

		private void UpdateCachedReferences()
		{
			if ((bool)m_FillRect && m_FillRect != (RectTransform)base.transform)
			{
				m_FillTransform = m_FillRect.transform;
				m_FillImage = m_FillRect.GetComponent<Image>();
				if (m_FillTransform.parent != null)
				{
					m_FillContainerRect = m_FillTransform.parent.GetComponent<RectTransform>();
				}
			}
			else
			{
				m_FillRect = null;
				m_FillContainerRect = null;
				m_FillImage = null;
			}
			if ((bool)m_HandleRect && m_HandleRect != (RectTransform)base.transform)
			{
				m_HandleTransform = m_HandleRect.transform;
				if (m_HandleTransform.parent != null)
				{
					m_HandleContainerRect = m_HandleTransform.parent.GetComponent<RectTransform>();
				}
			}
			else
			{
				m_HandleRect = null;
				m_HandleContainerRect = null;
			}
		}

		private float ClampValue(float input)
		{
			float num = Mathf.Clamp(input, minValue, maxValue);
			if (wholeNumbers)
			{
				num = Mathf.Round(num);
			}
			return num;
		}

		protected virtual void Set(float input, bool sendCallback = true)
		{
			float num = ClampValue(input);
			if (m_Value != num)
			{
				m_Value = num;
				UpdateVisuals();
				if (sendCallback)
				{
					UISystemProfilerApi.AddMarker("Slider.value", this);
					m_OnValueChanged.Invoke(num);
				}
			}
		}

		protected override void OnRectTransformDimensionsChange()
		{
			base.OnRectTransformDimensionsChange();
			if (IsActive())
			{
				UpdateVisuals();
			}
		}

		private void UpdateVisuals()
		{
			m_Tracker.Clear();
			if (m_FillContainerRect != null)
			{
				m_Tracker.Add(this, m_FillRect, DrivenTransformProperties.Anchors);
				Vector2 zero = Vector2.zero;
				Vector2 one = Vector2.one;
				if (m_FillImage != null && m_FillImage.type == Image.Type.Filled)
				{
					m_FillImage.fillAmount = normalizedValue;
				}
				else if (reverseValue)
				{
					zero[(int)axis] = 1f - normalizedValue;
				}
				else
				{
					one[(int)axis] = normalizedValue;
				}
				m_FillRect.anchorMin = zero;
				m_FillRect.anchorMax = one;
			}
			if (m_HandleContainerRect != null)
			{
				m_Tracker.Add(this, m_HandleRect, DrivenTransformProperties.Anchors);
				Vector2 zero2 = Vector2.zero;
				Vector2 one2 = Vector2.one;
				Axis index = axis;
				float num = (one2[(int)axis] = (reverseValue ? (1f - normalizedValue) : normalizedValue));
				zero2[(int)index] = num;
				m_HandleRect.anchorMin = zero2;
				m_HandleRect.anchorMax = one2;
			}
		}

		private void UpdateDrag(PointerEventData eventData, Camera cam)
		{
			RectTransform rectTransform = m_HandleContainerRect ?? m_FillContainerRect;
			if (rectTransform != null && rectTransform.rect.size[(int)axis] > 0f && RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, eventData.position, cam, out var localPoint))
			{
				localPoint -= rectTransform.rect.position;
				float num = Mathf.Clamp01((localPoint - m_Offset)[(int)axis] / rectTransform.rect.size[(int)axis]);
				normalizedValue = (reverseValue ? (1f - num) : num);
			}
		}

		private bool MayDrag(PointerEventData eventData)
		{
			if (IsActive() && IsInteractable())
			{
				return eventData.button == PointerEventData.InputButton.Left;
			}
			return false;
		}

		public override void OnPointerDown(PointerEventData eventData)
		{
			if (!MayDrag(eventData))
			{
				return;
			}
			base.OnPointerDown(eventData);
			m_Offset = Vector2.zero;
			if (m_HandleContainerRect != null && RectTransformUtility.RectangleContainsScreenPoint(m_HandleRect, eventData.position, eventData.enterEventCamera))
			{
				if (RectTransformUtility.ScreenPointToLocalPointInRectangle(m_HandleRect, eventData.position, eventData.pressEventCamera, out var localPoint))
				{
					m_Offset = localPoint;
				}
			}
			else
			{
				UpdateDrag(eventData, eventData.pressEventCamera);
			}
		}

		public virtual void OnDrag(PointerEventData eventData)
		{
			if (MayDrag(eventData))
			{
				UpdateDrag(eventData, eventData.pressEventCamera);
			}
		}

		public override void OnMove(AxisEventData eventData)
		{
			if (!IsActive() || !IsInteractable())
			{
				base.OnMove(eventData);
				return;
			}
			switch (eventData.moveDir)
			{
			case MoveDirection.Left:
				if (axis == Axis.Horizontal && FindSelectableOnLeft() == null)
				{
					Set(reverseValue ? (value + stepSize) : (value - stepSize));
				}
				else
				{
					base.OnMove(eventData);
				}
				break;
			case MoveDirection.Right:
				if (axis == Axis.Horizontal && FindSelectableOnRight() == null)
				{
					Set(reverseValue ? (value - stepSize) : (value + stepSize));
				}
				else
				{
					base.OnMove(eventData);
				}
				break;
			case MoveDirection.Up:
				if (axis == Axis.Vertical && FindSelectableOnUp() == null)
				{
					Set(reverseValue ? (value - stepSize) : (value + stepSize));
				}
				else
				{
					base.OnMove(eventData);
				}
				break;
			case MoveDirection.Down:
				if (axis == Axis.Vertical && FindSelectableOnDown() == null)
				{
					Set(reverseValue ? (value + stepSize) : (value - stepSize));
				}
				else
				{
					base.OnMove(eventData);
				}
				break;
			}
		}

		public override Selectable FindSelectableOnLeft()
		{
			if (base.navigation.mode == Navigation.Mode.Automatic && axis == Axis.Horizontal)
			{
				return null;
			}
			return base.FindSelectableOnLeft();
		}

		public override Selectable FindSelectableOnRight()
		{
			if (base.navigation.mode == Navigation.Mode.Automatic && axis == Axis.Horizontal)
			{
				return null;
			}
			return base.FindSelectableOnRight();
		}

		public override Selectable FindSelectableOnUp()
		{
			if (base.navigation.mode == Navigation.Mode.Automatic && axis == Axis.Vertical)
			{
				return null;
			}
			return base.FindSelectableOnUp();
		}

		public override Selectable FindSelectableOnDown()
		{
			if (base.navigation.mode == Navigation.Mode.Automatic && axis == Axis.Vertical)
			{
				return null;
			}
			return base.FindSelectableOnDown();
		}

		public virtual void OnInitializePotentialDrag(PointerEventData eventData)
		{
			eventData.useDragThreshold = false;
		}

		public void SetDirection(Direction direction, bool includeRectLayouts)
		{
			Axis axis = this.axis;
			bool flag = reverseValue;
			this.direction = direction;
			if (includeRectLayouts)
			{
				if (this.axis != axis)
				{
					RectTransformUtility.FlipLayoutAxes(base.transform as RectTransform, keepPositioning: true, recursive: true);
				}
				if (reverseValue != flag)
				{
					RectTransformUtility.FlipLayoutOnAxis(base.transform as RectTransform, (int)this.axis, keepPositioning: true, recursive: true);
				}
			}
		}

		Transform ICanvasElement.get_transform()
		{
			return base.transform;
		}
	}
	[Serializable]
	public struct SpriteState : IEquatable<SpriteState>
	{
		[SerializeField]
		private Sprite m_HighlightedSprite;

		[SerializeField]
		private Sprite m_PressedSprite;

		[FormerlySerializedAs("m_HighlightedSprite")]
		[SerializeField]
		private Sprite m_SelectedSprite;

		[SerializeField]
		private Sprite m_DisabledSprite;

		public Sprite highlightedSprite
		{
			get
			{
				return m_HighlightedSprite;
			}
			set
			{
				m_HighlightedSprite = value;
			}
		}

		public Sprite pressedSprite
		{
			get
			{
				return m_PressedSprite;
			}
			set
			{
				m_PressedSprite = value;
			}
		}

		public Sprite selectedSprite
		{
			get
			{
				return m_SelectedSprite;
			}
			set
			{
				m_SelectedSprite = value;
			}
		}

		public Sprite disabledSprite
		{
			get
			{
				return m_DisabledSprite;
			}
			set
			{
				m_DisabledSprite = value;
			}
		}

		public bool Equals(SpriteState other)
		{
			if (highlightedSprite == other.highlightedSprite && pressedSprite == other.pressedSprite && selectedSprite == other.selectedSprite)
			{
				return disabledSprite == other.disabledSprite;
			}
			return false;
		}
	}
	public static class StencilMaterial
	{
		private class MatEntry
		{
			public Material baseMat;

			public Material customMat;

			public int count;

			public int stencilId;

			public StencilOp operation;

			public CompareFunction compareFunction = CompareFunction.Always;

			public int readMask;

			public int writeMask;

			public bool useAlphaClip;

			public ColorWriteMask colorMask;
		}

		private static List<MatEntry> m_List = new List<MatEntry>();

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use Material.Add instead.", true)]
		public static Material Add(Material baseMat, int stencilID)
		{
			return null;
		}

		public static Material Add(Material baseMat, int stencilID, StencilOp operation, CompareFunction compareFunction, ColorWriteMask colorWriteMask)
		{
			return Add(baseMat, stencilID, operation, compareFunction, colorWriteMask, 255, 255);
		}

		public static Material Add(Material baseMat, int stencilID, StencilOp operation, CompareFunction compareFunction, ColorWriteMask colorWriteMask, int readMask, int writeMask)
		{
			if ((stencilID <= 0 && colorWriteMask == ColorWriteMask.All) || baseMat == null)
			{
				return baseMat;
			}
			if (!baseMat.HasProperty("_Stencil"))
			{
				Debug.LogWarning("Material " + baseMat.name + " doesn't have _Stencil property", baseMat);
				return baseMat;
			}
			if (!baseMat.HasProperty("_StencilOp"))
			{
				Debug.LogWarning("Material " + baseMat.name + " doesn't have _StencilOp property", baseMat);
				return baseMat;
			}
			if (!baseMat.HasProperty("_StencilComp"))
			{
				Debug.LogWarning("Material " + baseMat.name + " doesn't have _StencilComp property", baseMat);
				return baseMat;
			}
			if (!baseMat.HasProperty("_StencilReadMask"))
			{
				Debug.LogWarning("Material " + baseMat.name + " doesn't have _StencilReadMask property", baseMat);
				return baseMat;
			}
			if (!baseMat.HasProperty("_StencilWriteMask"))
			{
				Debug.LogWarning("Material " + baseMat.name + " doesn't have _StencilWriteMask property", baseMat);
				return baseMat;
			}
			if (!baseMat.HasProperty("_ColorMask"))
			{
				Debug.LogWarning("Material " + baseMat.name + " doesn't have _ColorMask property", baseMat);
				return baseMat;
			}
			for (int i = 0; i < m_List.Count; i++)
			{
				MatEntry matEntry = m_List[i];
				if (matEntry.baseMat == baseMat && matEntry.stencilId == stencilID && matEntry.operation == operation && matEntry.compareFunction == compareFunction && matEntry.readMask == readMask && matEntry.writeMask == writeMask && matEntry.colorMask == colorWriteMask)
				{
					matEntry.count++;
					return matEntry.customMat;
				}
			}
			MatEntry matEntry2 = new MatEntry();
			matEntry2.count = 1;
			matEntry2.baseMat = baseMat;
			matEntry2.customMat = new Material(baseMat);
			matEntry2.customMat.hideFlags = HideFlags.HideAndDontSave;
			matEntry2.stencilId = stencilID;
			matEntry2.operation = operation;
			matEntry2.compareFunction = compareFunction;
			matEntry2.readMask = readMask;
			matEntry2.writeMask = writeMask;
			matEntry2.colorMask = colorWriteMask;
			matEntry2.useAlphaClip = operation != StencilOp.Keep && writeMask > 0;
			matEntry2.customMat.name = $"Stencil Id:{stencilID}, Op:{operation}, Comp:{compareFunction}, WriteMask:{writeMask}, ReadMask:{readMask}, ColorMask:{colorWriteMask} AlphaClip:{matEntry2.useAlphaClip} ({baseMat.name})";
			matEntry2.customMat.SetInt("_Stencil", stencilID);
			matEntry2.customMat.SetInt("_StencilOp", (int)operation);
			matEntry2.customMat.SetInt("_StencilComp", (int)compareFunction);
			matEntry2.customMat.SetInt("_StencilReadMask", readMask);
			matEntry2.customMat.SetInt("_StencilWriteMask", writeMask);
			matEntry2.customMat.SetInt("_ColorMask", (int)colorWriteMask);
			matEntry2.customMat.SetInt("_UseUIAlphaClip", matEntry2.useAlphaClip ? 1 : 0);
			if (matEntry2.useAlphaClip)
			{
				matEntry2.customMat.EnableKeyword("UNITY_UI_ALPHACLIP");
			}
			else
			{
				matEntry2.customMat.DisableKeyword("UNITY_UI_ALPHACLIP");
			}
			m_List.Add(matEntry2);
			return matEntry2.customMat;
		}

		public static void Remove(Material customMat)
		{
			if (customMat == null)
			{
				return;
			}
			for (int i = 0; i < m_List.Count; i++)
			{
				MatEntry matEntry = m_List[i];
				if (!(matEntry.customMat != customMat))
				{
					if (--matEntry.count == 0)
					{
						Misc.DestroyImmediate(matEntry.customMat);
						matEntry.baseMat = null;
						m_List.RemoveAt(i);
					}
					break;
				}
			}
		}

		public static void ClearAll()
		{
			for (int i = 0; i < m_List.Count; i++)
			{
				MatEntry matEntry = m_List[i];
				Misc.DestroyImmediate(matEntry.customMat);
				matEntry.baseMat = null;
			}
			m_List.Clear();
		}
	}
	[AddComponentMenu("")]
	public class Text : MaskableGraphic, ILayoutElement
	{
		[SerializeField]
		private FontData m_FontData = FontData.defaultFontData;

		[TextArea(3, 10)]
		[SerializeField]
		protected string m_Text = string.Empty;

		private TextGenerator m_TextCache;

		private TextGenerator m_TextCacheForLayout;

		protected static Material s_DefaultText;

		[NonSerialized]
		protected bool m_DisableFontTextureRebuiltCallback;

		private readonly UIVertex[] m_TempVerts = new UIVertex[4];

		public TextGenerator cachedTextGenerator => m_TextCache ?? (m_TextCache = ((m_Text.Length != 0) ? new TextGenerator(m_Text.Length) : new TextGenerator()));

		public TextGenerator cachedTextGeneratorForLayout => m_TextCacheForLayout ?? (m_TextCacheForLayout = new TextGenerator());

		public override Texture mainTexture
		{
			get
			{
				if (font != null && font.material != null && font.material.mainTexture != null)
				{
					return font.material.mainTexture;
				}
				if (m_Material != null)
				{
					return m_Material.mainTexture;
				}
				return base.mainTexture;
			}
		}

		public Font font
		{
			get
			{
				return m_FontData.font;
			}
			set
			{
				if (!(m_FontData.font == value))
				{
					FontUpdateTracker.UntrackText(this);
					m_FontData.font = value;
					FontUpdateTracker.TrackText(this);
					SetAllDirty();
				}
			}
		}

		public virtual string text
		{
			get
			{
				return m_Text;
			}
			set
			{
				if (string.IsNullOrEmpty(value))
				{
					if (!string.IsNullOrEmpty(m_Text))
					{
						m_Text = "";
						SetVerticesDirty();
					}
				}
				else if (m_Text != value)
				{
					m_Text = value;
					SetVerticesDirty();
					SetLayoutDirty();
				}
			}
		}

		public bool supportRichText
		{
			get
			{
				return m_FontData.richText;
			}
			set
			{
				if (m_FontData.richText != value)
				{
					m_FontData.richText = value;
					SetVerticesDirty();
					SetLayoutDirty();
				}
			}
		}

		public bool resizeTextForBestFit
		{
			get
			{
				return m_FontData.bestFit;
			}
			set
			{
				if (m_FontData.bestFit != value)
				{
					m_FontData.bestFit = value;
					SetVerticesDirty();
					SetLayoutDirty();
				}
			}
		}

		public int resizeTextMinSize
		{
			get
			{
				return m_FontData.minSize;
			}
			set
			{
				if (m_FontData.minSize != value)
				{
					m_FontData.minSize = value;
					SetVerticesDirty();
					SetLayoutDirty();
				}
			}
		}

		public int resizeTextMaxSize
		{
			get
			{
				return m_FontData.maxSize;
			}
			set
			{
				if (m_FontData.maxSize != value)
				{
					m_FontData.maxSize = value;
					SetVerticesDirty();
					SetLayoutDirty();
				}
			}
		}

		public TextAnchor alignment
		{
			get
			{
				return m_FontData.alignment;
			}
			set
			{
				if (m_FontData.alignment != value)
				{
					m_FontData.alignment = value;
					SetVerticesDirty();
					SetLayoutDirty();
				}
			}
		}

		public bool alignByGeometry
		{
			get
			{
				return m_FontData.alignByGeometry;
			}
			set
			{
				if (m_FontData.alignByGeometry != value)
				{
					m_FontData.alignByGeometry = value;
					SetVerticesDirty();
				}
			}
		}

		public int fontSize
		{
			get
			{
				return m_FontData.fontSize;
			}
			set
			{
				if (m_FontData.fontSize != value)
				{
					m_FontData.fontSize = value;
					SetVerticesDirty();
					SetLayoutDirty();
				}
			}
		}

		public HorizontalWrapMode horizontalOverflow
		{
			get
			{
				return m_FontData.horizontalOverflow;
			}
			set
			{
				if (m_FontData.horizontalOverflow != value)
				{
					m_FontData.horizontalOverflow = value;
					SetVerticesDirty();
					SetLayoutDirty();
				}
			}
		}

		public VerticalWrapMode verticalOverflow
		{
			get
			{
				return m_FontData.verticalOverflow;
			}
			set
			{
				if (m_FontData.verticalOverflow != value)
				{
					m_FontData.verticalOverflow = value;
					SetVerticesDirty();
					SetLayoutDirty();
				}
			}
		}

		public float lineSpacing
		{
			get
			{
				return m_FontData.lineSpacing;
			}
			set
			{
				if (m_FontData.lineSpacing != value)
				{
					m_FontData.lineSpacing = value;
					SetVerticesDirty();
					SetLayoutDirty();
				}
			}
		}

		public FontStyle fontStyle
		{
			get
			{
				return m_FontData.fontStyle;
			}
			set
			{
				if (m_FontData.fontStyle != value)
				{
					m_FontData.fontStyle = value;
					SetVerticesDirty();
					SetLayoutDirty();
				}
			}
		}

		public float pixelsPerUnit
		{
			get
			{
				Canvas canvas = base.canvas;
				if (!canvas)
				{
					return 1f;
				}
				if (!font || font.dynamic)
				{
					return canvas.scaleFactor;
				}
				if (m_FontData.fontSize <= 0 || font.fontSize <= 0)
				{
					return 1f;
				}
				return (float)font.fontSize / (float)m_FontData.fontSize;
			}
		}

		public virtual float minWidth => 0f;

		public virtual float preferredWidth
		{
			get
			{
				TextGenerationSettings generationSettings = GetGenerationSettings(Vector2.zero);
				return cachedTextGeneratorForLayout.GetPreferredWidth(m_Text, generationSettings) / pixelsPerUnit;
			}
		}

		public virtual float flexibleWidth => -1f;

		public virtual float minHeight => 0f;

		public virtual float preferredHeight
		{
			get
			{
				TextGenerationSettings generationSettings = GetGenerationSettings(new Vector2(GetPixelAdjustedRect().size.x, 0f));
				return cachedTextGeneratorForLayout.GetPreferredHeight(m_Text, generationSettings) / pixelsPerUnit;
			}
		}

		public virtual float flexibleHeight => -1f;

		public virtual int layoutPriority => 0;

		protected Text()
		{
			base.useLegacyMeshGeneration = false;
		}

		public void FontTextureChanged()
		{
			if (!this || m_DisableFontTextureRebuiltCallback)
			{
				return;
			}
			cachedTextGenerator.Invalidate();
			if (IsActive())
			{
				if (CanvasUpdateRegistry.IsRebuildingGraphics() || CanvasUpdateRegistry.IsRebuildingLayout())
				{
					UpdateGeometry();
				}
				else
				{
					SetAllDirty();
				}
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			cachedTextGenerator.Invalidate();
			FontUpdateTracker.TrackText(this);
		}

		protected override void OnDisable()
		{
			FontUpdateTracker.UntrackText(this);
			base.OnDisable();
		}

		protected override void UpdateGeometry()
		{
			if (font != null)
			{
				base.UpdateGeometry();
			}
		}

		internal void AssignDefaultFont()
		{
			font = Resources.GetBuiltinResource<Font>("Arial.ttf");
		}

		public TextGenerationSettings GetGenerationSettings(Vector2 extents)
		{
			TextGenerationSettings result = new TextGenerationSettings
			{
				generationExtents = extents
			};
			if (font != null && font.dynamic)
			{
				result.fontSize = m_FontData.fontSize;
				result.resizeTextMinSize = m_FontData.minSize;
				result.resizeTextMaxSize = m_FontData.maxSize;
			}
			result.textAnchor = m_FontData.alignment;
			result.alignByGeometry = m_FontData.alignByGeometry;
			result.scaleFactor = pixelsPerUnit;
			result.color = color;
			result.font = font;
			result.pivot = base.rectTransform.pivot;
			result.richText = m_FontData.richText;
			result.lineSpacing = m_FontData.lineSpacing;
			result.fontStyle = m_FontData.fontStyle;
			result.resizeTextForBestFit = m_FontData.bestFit;
			result.updateBounds = false;
			result.horizontalOverflow = m_FontData.horizontalOverflow;
			result.verticalOverflow = m_FontData.verticalOverflow;
			return result;
		}

		public static Vector2 GetTextAnchorPivot(TextAnchor anchor)
		{
			return anchor switch
			{
				TextAnchor.LowerLeft => new Vector2(0f, 0f), 
				TextAnchor.LowerCenter => new Vector2(0.5f, 0f), 
				TextAnchor.LowerRight => new Vector2(1f, 0f), 
				TextAnchor.MiddleLeft => new Vector2(0f, 0.5f), 
				TextAnchor.MiddleCenter => new Vector2(0.5f, 0.5f), 
				TextAnchor.MiddleRight => new Vector2(1f, 0.5f), 
				TextAnchor.UpperLeft => new Vector2(0f, 1f), 
				TextAnchor.UpperCenter => new Vector2(0.5f, 1f), 
				TextAnchor.UpperRight => new Vector2(1f, 1f), 
				_ => Vector2.zero, 
			};
		}

		protected override void OnPopulateMesh(VertexHelper toFill)
		{
			if (font == null)
			{
				return;
			}
			m_DisableFontTextureRebuiltCallback = true;
			Vector2 size = base.rectTransform.rect.size;
			TextGenerationSettings generationSettings = GetGenerationSettings(size);
			cachedTextGenerator.PopulateWithErrors(text, generationSettings, base.gameObject);
			IList<UIVertex> verts = cachedTextGenerator.verts;
			float num = 1f / pixelsPerUnit;
			int count = verts.Count;
			if (count <= 0)
			{
				toFill.Clear();
				return;
			}
			Vector2 vector = new Vector2(verts[0].position.x, verts[0].position.y) * num;
			vector = PixelAdjustPoint(vector) - vector;
			toFill.Clear();
			if (vector != Vector2.zero)
			{
				for (int i = 0; i < count; i++)
				{
					int num2 = i & 3;
					m_TempVerts[num2] = verts[i];
					m_TempVerts[num2].position *= num;
					m_TempVerts[num2].position.x += vector.x;
					m_TempVerts[num2].position.y += vector.y;
					if (num2 == 3)
					{
						toFill.AddUIVertexQuad(m_TempVerts);
					}
				}
			}
			else
			{
				for (int j = 0; j < count; j++)
				{
					int num3 = j & 3;
					m_TempVerts[num3] = verts[j];
					m_TempVerts[num3].position *= num;
					if (num3 == 3)
					{
						toFill.AddUIVertexQuad(m_TempVerts);
					}
				}
			}
			m_DisableFontTextureRebuiltCallback = false;
		}

		public virtual void CalculateLayoutInputHorizontal()
		{
		}

		public virtual void CalculateLayoutInputVertical()
		{
		}
	}
	[AddComponentMenu("", 31)]
	[RequireComponent(typeof(RectTransform))]
	public class Toggle : Selectable, IPointerClickHandler, IEventSystemHandler, ISubmitHandler, ICanvasElement
	{
		public enum ToggleTransition
		{
			None,
			Fade
		}

		[Serializable]
		public class ToggleEvent : UnityEvent<bool>
		{
		}

		public ToggleTransition toggleTransition = ToggleTransition.Fade;

		public Graphic graphic;

		[SerializeField]
		private ToggleGroup m_Group;

		public ToggleEvent onValueChanged = new ToggleEvent();

		[Tooltip("Is the toggle currently on or off?")]
		[SerializeField]
		private bool m_IsOn;

		public ToggleGroup group
		{
			get
			{
				return m_Group;
			}
			set
			{
				m_Group = value;
				SetToggleGroup(m_Group, setMemberValue: true);
				PlayEffect(instant: true);
			}
		}

		public bool isOn
		{
			get
			{
				return m_IsOn;
			}
			set
			{
				Set(value);
			}
		}

		protected Toggle()
		{
		}

		public virtual void Rebuild(CanvasUpdate executing)
		{
		}

		public virtual void LayoutComplete()
		{
		}

		public virtual void GraphicUpdateComplete()
		{
		}

		protected override void OnDestroy()
		{
			if (m_Group != null)
			{
				m_Group.EnsureValidState();
			}
			base.OnDestroy();
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			SetToggleGroup(m_Group, setMemberValue: false);
			PlayEffect(instant: true);
		}

		protected override void OnDisable()
		{
			SetToggleGroup(null, setMemberValue: false);
			base.OnDisable();
		}

		protected override void OnDidApplyAnimationProperties()
		{
			if (graphic != null)
			{
				bool flag = !Mathf.Approximately(graphic.canvasRenderer.GetColor().a, 0f);
				if (m_IsOn != flag)
				{
					m_IsOn = flag;
					Set(!flag);
				}
			}
			base.OnDidApplyAnimationProperties();
		}

		private void SetToggleGroup(ToggleGroup newGroup, bool setMemberValue)
		{
			if (m_Group != null)
			{
				m_Group.UnregisterToggle(this);
			}
			if (setMemberValue)
			{
				m_Group = newGroup;
			}
			if (newGroup != null && IsActive())
			{
				newGroup.RegisterToggle(this);
			}
			if (newGroup != null && isOn && IsActive())
			{
				newGroup.NotifyToggleOn(this);
			}
		}

		public void SetIsOnWithoutNotify(bool value)
		{
			Set(value, sendCallback: false);
		}

		private void Set(bool value, bool sendCallback = true)
		{
			if (m_IsOn != value)
			{
				m_IsOn = value;
				if (m_Group != null && IsActive() && (m_IsOn || (!m_Group.AnyTogglesOn() && !m_Group.allowSwitchOff)))
				{
					m_IsOn = true;
					m_Group.NotifyToggleOn(this, sendCallback);
				}
				PlayEffect(toggleTransition == ToggleTransition.None);
				if (sendCallback)
				{
					UISystemProfilerApi.AddMarker("Toggle.value", this);
					onValueChanged.Invoke(m_IsOn);
				}
			}
		}

		private void PlayEffect(bool instant)
		{
			if (!(graphic == null))
			{
				graphic.CrossFadeAlpha(m_IsOn ? 1f : 0f, instant ? 0f : 0.1f, ignoreTimeScale: true);
			}
		}

		protected override void Start()
		{
			PlayEffect(instant: true);
		}

		private void InternalToggle()
		{
			if (IsActive() && IsInteractable())
			{
				isOn = !isOn;
			}
		}

		public virtual void OnPointerClick(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left)
			{
				InternalToggle();
			}
		}

		public virtual void OnSubmit(BaseEventData eventData)
		{
			InternalToggle();
		}

		Transform ICanvasElement.get_transform()
		{
			return base.transform;
		}
	}
	[AddComponentMenu("", 32)]
	[DisallowMultipleComponent]
	public class ToggleGroup : UIBehaviour
	{
		[SerializeField]
		private bool m_AllowSwitchOff;

		private List<Toggle> m_Toggles = new List<Toggle>();

		public bool allowSwitchOff
		{
			get
			{
				return m_AllowSwitchOff;
			}
			set
			{
				m_AllowSwitchOff = value;
			}
		}

		protected ToggleGroup()
		{
		}

		protected override void Start()
		{
			EnsureValidState();
			base.Start();
		}

		private void ValidateToggleIsInGroup(Toggle toggle)
		{
			if (toggle == null || !m_Toggles.Contains(toggle))
			{
				throw new ArgumentException(string.Format("Toggle {0} is not part of ToggleGroup {1}", new object[2] { toggle, this }));
			}
		}

		public void NotifyToggleOn(Toggle toggle, bool sendCallback = true)
		{
			ValidateToggleIsInGroup(toggle);
			for (int i = 0; i < m_Toggles.Count; i++)
			{
				if (!(m_Toggles[i] == toggle))
				{
					if (sendCallback)
					{
						m_Toggles[i].isOn = false;
					}
					else
					{
						m_Toggles[i].SetIsOnWithoutNotify(value: false);
					}
				}
			}
		}

		public void UnregisterToggle(Toggle toggle)
		{
			if (m_Toggles.Contains(toggle))
			{
				m_Toggles.Remove(toggle);
			}
		}

		public void RegisterToggle(Toggle toggle)
		{
			if (!m_Toggles.Contains(toggle))
			{
				m_Toggles.Add(toggle);
			}
		}

		public void EnsureValidState()
		{
			if (!allowSwitchOff && !AnyTogglesOn() && m_Toggles.Count != 0)
			{
				m_Toggles[0].isOn = true;
				NotifyToggleOn(m_Toggles[0]);
			}
		}

		public bool AnyTogglesOn()
		{
			return m_Toggles.Find((Toggle x) => x.isOn) != null;
		}

		public IEnumerable<Toggle> ActiveToggles()
		{
			return m_Toggles.Where((Toggle x) => x.isOn);
		}

		public void SetAllTogglesOff(bool sendCallback = true)
		{
			bool flag = m_AllowSwitchOff;
			m_AllowSwitchOff = true;
			if (sendCallback)
			{
				for (int i = 0; i < m_Toggles.Count; i++)
				{
					m_Toggles[i].isOn = false;
				}
			}
			else
			{
				for (int j = 0; j < m_Toggles.Count; j++)
				{
					m_Toggles[j].SetIsOnWithoutNotify(value: false);
				}
			}
			m_AllowSwitchOff = flag;
		}
	}
	public static class ListPool<T>
	{
		private static readonly ObjectPool<List<T>> s_ListPool = new ObjectPool<List<T>>(null, Clear);

		private static void Clear(List<T> l)
		{
			l.Clear();
		}

		public static List<T> Get()
		{
			return s_ListPool.Get();
		}

		public static void Release(List<T> toRelease)
		{
			s_ListPool.Release(toRelease);
		}
	}
	internal class ObjectPool<T> where T : new()
	{
		private readonly Stack<T> m_Stack = new Stack<T>();

		private readonly UnityAction<T> m_ActionOnGet;

		private readonly UnityAction<T> m_ActionOnRelease;

		public int countAll { get; private set; }

		public int countActive => countAll - countInactive;

		public int countInactive => m_Stack.Count;

		public ObjectPool(UnityAction<T> actionOnGet, UnityAction<T> actionOnRelease)
		{
			m_ActionOnGet = actionOnGet;
			m_ActionOnRelease = actionOnRelease;
		}

		public T Get()
		{
			T val;
			if (m_Stack.Count == 0)
			{
				val = new T();
				countAll++;
			}
			else
			{
				val = m_Stack.Pop();
			}
			if (m_ActionOnGet != null)
			{
				m_ActionOnGet(val);
			}
			return val;
		}

		public void Release(T element)
		{
			if (m_Stack.Count > 0 && (object)m_Stack.Peek() == (object)element)
			{
				Debug.LogError("Internal error. Trying to destroy object that is already released to pool.");
			}
			if (m_ActionOnRelease != null)
			{
				m_ActionOnRelease(element);
			}
			m_Stack.Push(element);
		}
	}
	internal class ReflectionMethodsCache
	{
		public delegate bool Raycast3DCallback(Ray r, out RaycastHit hit, float f, int i);

		public delegate RaycastHit2D Raycast2DCallback(Vector2 p1, Vector2 p2, float f, int i);

		public delegate RaycastHit[] RaycastAllCallback(Ray r, float f, int i);

		public delegate RaycastHit2D[] GetRayIntersectionAllCallback(Ray r, float f, int i);

		public delegate int GetRayIntersectionAllNonAllocCallback(Ray r, RaycastHit2D[] results, float f, int i);

		public delegate int GetRaycastNonAllocCallback(Ray r, RaycastHit[] results, float f, int i);

		public Raycast3DCallback raycast3D;

		public RaycastAllCallback raycast3DAll;

		public Raycast2DCallback raycast2D;

		public GetRayIntersectionAllCallback getRayIntersectionAll;

		public GetRayIntersectionAllNonAllocCallback getRayIntersectionAllNonAlloc;

		public GetRaycastNonAllocCallback getRaycastNonAlloc;

		private static ReflectionMethodsCache s_ReflectionMethodsCache;

		public static ReflectionMethodsCache Singleton
		{
			get
			{
				if (s_ReflectionMethodsCache == null)
				{
					s_ReflectionMethodsCache = new ReflectionMethodsCache();
				}
				return s_ReflectionMethodsCache;
			}
		}

		public ReflectionMethodsCache()
		{
			MethodInfo method = typeof(Physics).GetMethod("Raycast", new Type[4]
			{
				typeof(Ray),
				typeof(RaycastHit).MakeByRefType(),
				typeof(float),
				typeof(int)
			});
			if (method != null)
			{
				raycast3D = (Raycast3DCallback)Delegate.CreateDelegate(typeof(Raycast3DCallback), method);
			}
			MethodInfo method2 = typeof(Physics2D).GetMethod("Raycast", new Type[4]
			{
				typeof(Vector2),
				typeof(Vector2),
				typeof(float),
				typeof(int)
			});
			if (method2 != null)
			{
				raycast2D = (Raycast2DCallback)Delegate.CreateDelegate(typeof(Raycast2DCallback), method2);
			}
			MethodInfo method3 = typeof(Physics).GetMethod("RaycastAll", new Type[3]
			{
				typeof(Ray),
				typeof(float),
				typeof(int)
			});
			if (method3 != null)
			{
				raycast3DAll = (RaycastAllCallback)Delegate.CreateDelegate(typeof(RaycastAllCallback), method3);
			}
			MethodInfo method4 = typeof(Physics2D).GetMethod("GetRayIntersectionAll", new Type[3]
			{
				typeof(Ray),
				typeof(float),
				typeof(int)
			});
			if (method4 != null)
			{
				getRayIntersectionAll = (GetRayIntersectionAllCallback)Delegate.CreateDelegate(typeof(GetRayIntersectionAllCallback), method4);
			}
			MethodInfo method5 = typeof(Physics2D).GetMethod("GetRayIntersectionNonAlloc", new Type[4]
			{
				typeof(Ray),
				typeof(RaycastHit2D[]),
				typeof(float),
				typeof(int)
			});
			if (method5 != null)
			{
				getRayIntersectionAllNonAlloc = (GetRayIntersectionAllNonAllocCallback)Delegate.CreateDelegate(typeof(GetRayIntersectionAllNonAllocCallback), method5);
			}
			MethodInfo method6 = typeof(Physics).GetMethod("RaycastNonAlloc", new Type[4]
			{
				typeof(Ray),
				typeof(RaycastHit[]),
				typeof(float),
				typeof(int)
			});
			if (method6 != null)
			{
				getRaycastNonAlloc = (GetRaycastNonAllocCallback)Delegate.CreateDelegate(typeof(GetRaycastNonAllocCallback), method6);
			}
		}
	}
	public class VertexHelper : IDisposable
	{
		private List<Vector3> m_Positions;

		private List<Color32> m_Colors;

		private List<Vector4> m_Uv0S;

		private List<Vector4> m_Uv1S;

		private List<Vector4> m_Uv2S;

		private List<Vector4> m_Uv3S;

		private List<Vector3> m_Normals;

		private List<Vector4> m_Tangents;

		private List<int> m_Indices;

		private static readonly Vector4 s_DefaultTangent = new Vector4(1f, 0f, 0f, -1f);

		private static readonly Vector3 s_DefaultNormal = Vector3.back;

		private bool m_ListsInitalized;

		public int currentVertCount
		{
			get
			{
				if (m_Positions == null)
				{
					return 0;
				}
				return m_Positions.Count;
			}
		}

		public int currentIndexCount
		{
			get
			{
				if (m_Indices == null)
				{
					return 0;
				}
				return m_Indices.Count;
			}
		}

		public VertexHelper()
		{
		}

		public VertexHelper(Mesh m)
		{
			InitializeListIfRequired();
			m.GetVertices(m_Positions);
			m.GetColors(m_Colors);
			m.GetUVs(0, m_Uv0S);
			m.GetUVs(1, m_Uv1S);
			m.GetUVs(2, m_Uv2S);
			m.GetUVs(3, m_Uv3S);
			m.GetNormals(m_Normals);
			m.GetTangents(m_Tangents);
			m.GetIndices(m_Indices, 0);
		}

		private void InitializeListIfRequired()
		{
			if (!m_ListsInitalized)
			{
				m_Positions = ListPool<Vector3>.Get();
				m_Colors = ListPool<Color32>.Get();
				m_Uv0S = ListPool<Vector4>.Get();
				m_Uv1S = ListPool<Vector4>.Get();
				m_Uv2S = ListPool<Vector4>.Get();
				m_Uv3S = ListPool<Vector4>.Get();
				m_Normals = ListPool<Vector3>.Get();
				m_Tangents = ListPool<Vector4>.Get();
				m_Indices = ListPool<int>.Get();
				m_ListsInitalized = true;
			}
		}

		public void Dispose()
		{
			if (m_ListsInitalized)
			{
				ListPool<Vector3>.Release(m_Positions);
				ListPool<Color32>.Release(m_Colors);
				ListPool<Vector4>.Release(m_Uv0S);
				ListPool<Vector4>.Release(m_Uv1S);
				ListPool<Vector4>.Release(m_Uv2S);
				ListPool<Vector4>.Release(m_Uv3S);
				ListPool<Vector3>.Release(m_Normals);
				ListPool<Vector4>.Release(m_Tangents);
				ListPool<int>.Release(m_Indices);
				m_Positions = null;
				m_Colors = null;
				m_Uv0S = null;
				m_Uv1S = null;
				m_Uv2S = null;
				m_Uv3S = null;
				m_Normals = null;
				m_Tangents = null;
				m_Indices = null;
				m_ListsInitalized = false;
			}
		}

		public void Clear()
		{
			if (m_ListsInitalized)
			{
				m_Positions.Clear();
				m_Colors.Clear();
				m_Uv0S.Clear();
				m_Uv1S.Clear();
				m_Uv2S.Clear();
				m_Uv3S.Clear();
				m_Normals.Clear();
				m_Tangents.Clear();
				m_Indices.Clear();
			}
		}

		public void PopulateUIVertex(ref UIVertex vertex, int i)
		{
			InitializeListIfRequired();
			vertex.position = m_Positions[i];
			vertex.color = m_Colors[i];
			vertex.uv0 = m_Uv0S[i];
			vertex.uv1 = m_Uv1S[i];
			vertex.uv2 = m_Uv2S[i];
			vertex.uv3 = m_Uv3S[i];
			vertex.normal = m_Normals[i];
			vertex.tangent = m_Tangents[i];
		}

		public void SetUIVertex(UIVertex vertex, int i)
		{
			InitializeListIfRequired();
			m_Positions[i] = vertex.position;
			m_Colors[i] = vertex.color;
			m_Uv0S[i] = vertex.uv0;
			m_Uv1S[i] = vertex.uv1;
			m_Uv2S[i] = vertex.uv2;
			m_Uv3S[i] = vertex.uv3;
			m_Normals[i] = vertex.normal;
			m_Tangents[i] = vertex.tangent;
		}

		public void FillMesh(Mesh mesh)
		{
			InitializeListIfRequired();
			mesh.Clear();
			if (m_Positions.Count >= 65000)
			{
				throw new ArgumentException("Mesh can not have more than 65000 vertices");
			}
			mesh.SetVertices(m_Positions);
			mesh.SetColors(m_Colors);
			mesh.SetUVs(0, m_Uv0S);
			mesh.SetUVs(1, m_Uv1S);
			mesh.SetUVs(2, m_Uv2S);
			mesh.SetUVs(3, m_Uv3S);
			mesh.SetNormals(m_Normals);
			mesh.SetTangents(m_Tangents);
			mesh.SetTriangles(m_Indices, 0);
			mesh.RecalculateBounds();
		}

		public void AddVert(Vector3 position, Color32 color, Vector2 uv0, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector3 normal, Vector4 tangent)
		{
			InitializeListIfRequired();
			m_Positions.Add(position);
			m_Colors.Add(color);
			m_Uv0S.Add(uv0);
			m_Uv1S.Add(uv1);
			m_Uv2S.Add(uv2);
			m_Uv3S.Add(uv3);
			m_Normals.Add(normal);
			m_Tangents.Add(tangent);
		}

		public void AddVert(Vector3 position, Color32 color, Vector2 uv0, Vector2 uv1, Vector3 normal, Vector4 tangent)
		{
			AddVert(position, color, uv0, uv1, Vector2.zero, Vector2.zero, normal, tangent);
		}

		public void AddVert(Vector3 position, Color32 color, Vector2 uv0)
		{
			AddVert(position, color, uv0, Vector2.zero, s_DefaultNormal, s_DefaultTangent);
		}

		public void AddVert(UIVertex v)
		{
			AddVert(v.position, v.color, v.uv0, v.uv1, v.uv2, v.uv3, v.normal, v.tangent);
		}

		public void AddTriangle(int idx0, int idx1, int idx2)
		{
			InitializeListIfRequired();
			m_Indices.Add(idx0);
			m_Indices.Add(idx1);
			m_Indices.Add(idx2);
		}

		public void AddUIVertexQuad(UIVertex[] verts)
		{
			int num = currentVertCount;
			for (int i = 0; i < 4; i++)
			{
				AddVert(verts[i].position, verts[i].color, verts[i].uv0, verts[i].uv1, verts[i].normal, verts[i].tangent);
			}
			AddTriangle(num, num + 1, num + 2);
			AddTriangle(num + 2, num + 3, num);
		}

		public void AddUIVertexStream(List<UIVertex> verts, List<int> indices)
		{
			InitializeListIfRequired();
			if (verts != null)
			{
				CanvasRenderer.AddUIVertexStream(verts, m_Positions, m_Colors, m_Uv0S, m_Uv1S, m_Uv2S, m_Uv3S, m_Normals, m_Tangents);
			}
			if (indices != null)
			{
				m_Indices.AddRange(indices);
			}
		}

		public void AddUIVertexTriangleStream(List<UIVertex> verts)
		{
			if (verts != null)
			{
				InitializeListIfRequired();
				CanvasRenderer.SplitUIVertexStreams(verts, m_Positions, m_Colors, m_Uv0S, m_Uv1S, m_Uv2S, m_Uv3S, m_Normals, m_Tangents, m_Indices);
			}
		}

		public void GetUIVertexStream(List<UIVertex> stream)
		{
			if (stream != null)
			{
				InitializeListIfRequired();
				CanvasRenderer.CreateUIVertexStream(stream, m_Positions, m_Colors, m_Uv0S, m_Uv1S, m_Uv2S, m_Uv3S, m_Normals, m_Tangents, m_Indices);
			}
		}
	}
	[Obsolete("Use BaseMeshEffect instead", true)]
	public abstract class BaseVertexEffect
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Use BaseMeshEffect.ModifyMeshes instead", true)]
		public abstract void ModifyVertices(List<UIVertex> vertices);
	}
	[ExecuteAlways]
	public abstract class BaseMeshEffect : UIBehaviour, IMeshModifier
	{
		[NonSerialized]
		private Graphic m_Graphic;

		protected Graphic graphic
		{
			get
			{
				if (m_Graphic == null)
				{
					m_Graphic = GetComponent<Graphic>();
				}
				return m_Graphic;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			if (graphic != null)
			{
				graphic.SetVerticesDirty();
			}
		}

		protected override void OnDisable()
		{
			if (graphic != null)
			{
				graphic.SetVerticesDirty();
			}
			base.OnDisable();
		}

		protected override void OnDidApplyAnimationProperties()
		{
			if (graphic != null)
			{
				graphic.SetVerticesDirty();
			}
			base.OnDidApplyAnimationProperties();
		}

		public virtual void ModifyMesh(Mesh mesh)
		{
			using VertexHelper vertexHelper = new VertexHelper(mesh);
			ModifyMesh(vertexHelper);
			vertexHelper.FillMesh(mesh);
		}

		public abstract void ModifyMesh(VertexHelper vh);
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	[Obsolete("Use IMeshModifier instead", true)]
	public interface IVertexModifier
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("use IMeshModifier.ModifyMesh (VertexHelper verts)  instead", true)]
		void ModifyVertices(List<UIVertex> verts);
	}
	public interface IMeshModifier
	{
		[Obsolete("use IMeshModifier.ModifyMesh (VertexHelper verts) instead", false)]
		void ModifyMesh(Mesh mesh);

		void ModifyMesh(VertexHelper verts);
	}
	[AddComponentMenu("UI/Effects/Outline", 15)]
	public class Outline : Shadow
	{
		protected Outline()
		{
		}

		public override void ModifyMesh(VertexHelper vh)
		{
			if (IsActive())
			{
				List<UIVertex> list = ListPool<UIVertex>.Get();
				vh.GetUIVertexStream(list);
				int num = list.Count * 5;
				if (list.Capacity < num)
				{
					list.Capacity = num;
				}
				int start = 0;
				int count = list.Count;
				ApplyShadowZeroAlloc(list, base.effectColor, start, list.Count, base.effectDistance.x, base.effectDistance.y);
				start = count;
				int count2 = list.Count;
				ApplyShadowZeroAlloc(list, base.effectColor, start, list.Count, base.effectDistance.x, 0f - base.effectDistance.y);
				start = count2;
				int count3 = list.Count;
				ApplyShadowZeroAlloc(list, base.effectColor, start, list.Count, 0f - base.effectDistance.x, base.effectDistance.y);
				start = count3;
				_ = list.Count;
				ApplyShadowZeroAlloc(list, base.effectColor, start, list.Count, 0f - base.effectDistance.x, 0f - base.effectDistance.y);
				vh.Clear();
				vh.AddUIVertexTriangleStream(list);
				ListPool<UIVertex>.Release(list);
			}
		}
	}
	[AddComponentMenu("UI/Effects/Position As UV1", 16)]
	public class PositionAsUV1 : BaseMeshEffect
	{
		protected PositionAsUV1()
		{
		}

		public override void ModifyMesh(VertexHelper vh)
		{
			UIVertex vertex = default(UIVertex);
			for (int i = 0; i < vh.currentVertCount; i++)
			{
				vh.PopulateUIVertex(ref vertex, i);
				vertex.uv1 = new Vector2(vertex.position.x, vertex.position.y);
				vh.SetUIVertex(vertex, i);
			}
		}
	}
	[AddComponentMenu("UI/Effects/Shadow", 14)]
	public class Shadow : BaseMeshEffect
	{
		[SerializeField]
		private Color m_EffectColor = new Color(0f, 0f, 0f, 0.5f);

		[SerializeField]
		private Vector2 m_EffectDistance = new Vector2(1f, -1f);

		[SerializeField]
		private bool m_UseGraphicAlpha = true;

		private const float kMaxEffectDistance = 600f;

		public Color effectColor
		{
			get
			{
				return m_EffectColor;
			}
			set
			{
				m_EffectColor = value;
				if (base.graphic != null)
				{
					base.graphic.SetVerticesDirty();
				}
			}
		}

		public Vector2 effectDistance
		{
			get
			{
				return m_EffectDistance;
			}
			set
			{
				if (value.x > 600f)
				{
					value.x = 600f;
				}
				if (value.x < -600f)
				{
					value.x = -600f;
				}
				if (value.y > 600f)
				{
					value.y = 600f;
				}
				if (value.y < -600f)
				{
					value.y = -600f;
				}
				if (!(m_EffectDistance == value))
				{
					m_EffectDistance = value;
					if (base.graphic != null)
					{
						base.graphic.SetVerticesDirty();
					}
				}
			}
		}

		public bool useGraphicAlpha
		{
			get
			{
				return m_UseGraphicAlpha;
			}
			set
			{
				m_UseGraphicAlpha = value;
				if (base.graphic != null)
				{
					base.graphic.SetVerticesDirty();
				}
			}
		}

		protected Shadow()
		{
		}

		protected void ApplyShadowZeroAlloc(List<UIVertex> verts, Color32 color, int start, int end, float x, float y)
		{
			int num = verts.Count + end - start;
			if (verts.Capacity < num)
			{
				verts.Capacity = num;
			}
			for (int i = start; i < end; i++)
			{
				UIVertex uIVertex = verts[i];
				verts.Add(uIVertex);
				Vector3 position = uIVertex.position;
				position.x += x;
				position.y += y;
				uIVertex.position = position;
				Color32 color2 = color;
				if (m_UseGraphicAlpha)
				{
					color2.a = (byte)(color2.a * verts[i].color.a / 255);
				}
				uIVertex.color = color2;
				verts[i] = uIVertex;
			}
		}

		protected void ApplyShadow(List<UIVertex> verts, Color32 color, int start, int end, float x, float y)
		{
			ApplyShadowZeroAlloc(verts, color, start, end, x, y);
		}

		public override void ModifyMesh(VertexHelper vh)
		{
			if (IsActive())
			{
				List<UIVertex> list = ListPool<UIVertex>.Get();
				vh.GetUIVertexStream(list);
				ApplyShadow(list, effectColor, 0, list.Count, effectDistance.x, effectDistance.y);
				vh.Clear();
				vh.AddUIVertexTriangleStream(list);
				ListPool<UIVertex>.Release(list);
			}
		}
	}
}
namespace UnityEngine.UI.Collections
{
	internal class IndexedSet<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		private readonly List<T> m_List = new List<T>();

		private Dictionary<T, int> m_Dictionary = new Dictionary<T, int>();

		public int Count => m_List.Count;

		public bool IsReadOnly => false;

		public T this[int index]
		{
			get
			{
				return m_List[index];
			}
			set
			{
				T key = m_List[index];
				m_Dictionary.Remove(key);
				m_List[index] = value;
				m_Dictionary.Add(key, index);
			}
		}

		public void Add(T item)
		{
			m_List.Add(item);
			m_Dictionary.Add(item, m_List.Count - 1);
		}

		public bool AddUnique(T item)
		{
			if (m_Dictionary.ContainsKey(item))
			{
				return false;
			}
			m_List.Add(item);
			m_Dictionary.Add(item, m_List.Count - 1);
			return true;
		}

		public bool Remove(T item)
		{
			int value = -1;
			if (!m_Dictionary.TryGetValue(item, out value))
			{
				return false;
			}
			RemoveAt(value);
			return true;
		}

		public IEnumerator<T> GetEnumerator()
		{
			throw new NotImplementedException();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public void Clear()
		{
			m_List.Clear();
			m_Dictionary.Clear();
		}

		public bool Contains(T item)
		{
			return m_Dictionary.ContainsKey(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			m_List.CopyTo(array, arrayIndex);
		}

		public int IndexOf(T item)
		{
			int value = -1;
			if (m_Dictionary.TryGetValue(item, out value))
			{
				return value;
			}
			return -1;
		}

		public void Insert(int index, T item)
		{
			throw new NotSupportedException("Random Insertion is semantically invalid, since this structure does not guarantee ordering.");
		}

		public void RemoveAt(int index)
		{
			T key = m_List[index];
			m_Dictionary.Remove(key);
			if (index == m_List.Count - 1)
			{
				m_List.RemoveAt(index);
				return;
			}
			int index2 = m_List.Count - 1;
			T val = m_List[index2];
			m_List[index] = val;
			m_Dictionary[val] = index;
			m_List.RemoveAt(index2);
		}

		public void RemoveAll(Predicate<T> match)
		{
			int num = 0;
			while (num < m_List.Count)
			{
				T val = m_List[num];
				if (match(val))
				{
					Remove(val);
				}
				else
				{
					num++;
				}
			}
		}

		public void Sort(Comparison<T> sortLayoutFunction)
		{
			m_List.Sort(sortLayoutFunction);
			for (int i = 0; i < m_List.Count; i++)
			{
				T key = m_List[i];
				m_Dictionary[key] = i;
			}
		}
	}
}
namespace UnityEngine.UI.CoroutineTween
{
	internal interface ITweenValue
	{
		bool ignoreTimeScale { get; }

		float duration { get; }

		void TweenValue(float floatPercentage);

		bool ValidTarget();
	}
	internal struct ColorTween : ITweenValue
	{
		public enum ColorTweenMode
		{
			All,
			RGB,
			Alpha
		}

		public class ColorTweenCallback : UnityEvent<Color>
		{
		}

		private ColorTweenCallback m_Target;

		private Color m_StartColor;

		private Color m_TargetColor;

		private ColorTweenMode m_TweenMode;

		private float m_Duration;

		private bool m_IgnoreTimeScale;

		public Color startColor
		{
			get
			{
				return m_StartColor;
			}
			set
			{
				m_StartColor = value;
			}
		}

		public Color targetColor
		{
			get
			{
				return m_TargetColor;
			}
			set
			{
				m_TargetColor = value;
			}
		}

		public ColorTweenMode tweenMode
		{
			get
			{
				return m_TweenMode;
			}
			set
			{
				m_TweenMode = value;
			}
		}

		public float duration
		{
			get
			{
				return m_Duration;
			}
			set
			{
				m_Duration = value;
			}
		}

		public bool ignoreTimeScale
		{
			get
			{
				return m_IgnoreTimeScale;
			}
			set
			{
				m_IgnoreTimeScale = value;
			}
		}

		public void TweenValue(float floatPercentage)
		{
			if (ValidTarget())
			{
				Color arg = Color.Lerp(m_StartColor, m_TargetColor, floatPercentage);
				if (m_TweenMode == ColorTweenMode.Alpha)
				{
					arg.r = m_StartColor.r;
					arg.g = m_StartColor.g;
					arg.b = m_StartColor.b;
				}
				else if (m_TweenMode == ColorTweenMode.RGB)
				{
					arg.a = m_StartColor.a;
				}
				m_Target.Invoke(arg);
			}
		}

		public void AddOnChangedCallback(UnityAction<Color> callback)
		{
			if (m_Target == null)
			{
				m_Target = new ColorTweenCallback();
			}
			m_Target.AddListener(callback);
		}

		public bool GetIgnoreTimescale()
		{
			return m_IgnoreTimeScale;
		}

		public float GetDuration()
		{
			return m_Duration;
		}

		public bool ValidTarget()
		{
			return m_Target != null;
		}
	}
	internal struct FloatTween : ITweenValue
	{
		public class FloatTweenCallback : UnityEvent<float>
		{
		}

		private FloatTweenCallback m_Target;

		private float m_StartValue;

		private float m_TargetValue;

		private float m_Duration;

		private bool m_IgnoreTimeScale;

		public float startValue
		{
			get
			{
				return m_StartValue;
			}
			set
			{
				m_StartValue = value;
			}
		}

		public float targetValue
		{
			get
			{
				return m_TargetValue;
			}
			set
			{
				m_TargetValue = value;
			}
		}

		public float duration
		{
			get
			{
				return m_Duration;
			}
			set
			{
				m_Duration = value;
			}
		}

		public bool ignoreTimeScale
		{
			get
			{
				return m_IgnoreTimeScale;
			}
			set
			{
				m_IgnoreTimeScale = value;
			}
		}

		public void TweenValue(float floatPercentage)
		{
			if (ValidTarget())
			{
				float arg = Mathf.Lerp(m_StartValue, m_TargetValue, floatPercentage);
				m_Target.Invoke(arg);
			}
		}

		public void AddOnChangedCallback(UnityAction<float> callback)
		{
			if (m_Target == null)
			{
				m_Target = new FloatTweenCallback();
			}
			m_Target.AddListener(callback);
		}

		public bool GetIgnoreTimescale()
		{
			return m_IgnoreTimeScale;
		}

		public float GetDuration()
		{
			return m_Duration;
		}

		public bool ValidTarget()
		{
			return m_Target != null;
		}
	}
	internal class TweenRunner<T> where T : struct, ITweenValue
	{
		protected MonoBehaviour m_CoroutineContainer;

		protected IEnumerator m_Tween;

		private static IEnumerator Start(T tweenInfo)
		{
			if (tweenInfo.ValidTarget())
			{
				float elapsedTime = 0f;
				while (elapsedTime < tweenInfo.duration)
				{
					elapsedTime += (tweenInfo.ignoreTimeScale ? Time.unscaledDeltaTime : Time.deltaTime);
					float floatPercentage = Mathf.Clamp01(elapsedTime / tweenInfo.duration);
					tweenInfo.TweenValue(floatPercentage);
					yield return null;
				}
				tweenInfo.TweenValue(1f);
			}
		}

		public void Init(MonoBehaviour coroutineContainer)
		{
			m_CoroutineContainer = coroutineContainer;
		}

		public void StartTween(T info)
		{
			if (m_CoroutineContainer == null)
			{
				Debug.LogWarning("Coroutine container not configured... did you forget to call Init?");
				return;
			}
			StopTween();
			if (!m_CoroutineContainer.gameObject.activeInHierarchy)
			{
				info.TweenValue(1f);
				return;
			}
			m_Tween = Start(info);
			m_CoroutineContainer.StartCoroutine(m_Tween);
		}

		public void StopTween()
		{
			if (m_Tween != null)
			{
				m_CoroutineContainer.StopCoroutine(m_Tween);
				m_Tween = null;
			}
		}
	}
}
namespace UnityEngine.EventSystems
{
	public class AxisEventData : BaseEventData
	{
		public Vector2 moveVector { get; set; }

		public MoveDirection moveDir { get; set; }

		public AxisEventData(EventSystem eventSystem)
			: base(eventSystem)
		{
			moveVector = Vector2.zero;
			moveDir = MoveDirection.None;
		}
	}
	public abstract class AbstractEventData
	{
		protected bool m_Used;

		public virtual bool used => m_Used;

		public virtual void Reset()
		{
			m_Used = false;
		}

		public virtual void Use()
		{
			m_Used = true;
		}
	}
	public class BaseEventData : AbstractEventData
	{
		private readonly EventSystem m_EventSystem;

		public BaseInputModule currentInputModule => m_EventSystem.currentInputModule;

		public GameObject selectedObject
		{
			get
			{
				return m_EventSystem.currentSelectedGameObject;
			}
			set
			{
				m_EventSystem.SetSelectedGameObject(value, this);
			}
		}

		public BaseEventData(EventSystem eventSystem)
		{
			m_EventSystem = eventSystem;
		}
	}
	public class PointerEventData : BaseEventData
	{
		public enum InputButton
		{
			Left,
			Right,
			Middle
		}

		public enum FramePressState
		{
			Pressed,
			Released,
			PressedAndReleased,
			NotChanged
		}

		private GameObject m_PointerPress;

		public List<GameObject> hovered = new List<GameObject>();

		public GameObject pointerEnter { get; set; }

		public GameObject lastPress { get; private set; }

		public GameObject rawPointerPress { get; set; }

		public GameObject pointerDrag { get; set; }

		public RaycastResult pointerCurrentRaycast { get; set; }

		public RaycastResult pointerPressRaycast { get; set; }

		public bool eligibleForClick { get; set; }

		public int pointerId { get; set; }

		public Vector2 position { get; set; }

		public Vector2 delta { get; set; }

		public Vector2 pressPosition { get; set; }

		[Obsolete("Use either pointerCurrentRaycast.worldPosition or pointerPressRaycast.worldPosition")]
		public Vector3 worldPosition { get; set; }

		[Obsolete("Use either pointerCurrentRaycast.worldNormal or pointerPressRaycast.worldNormal")]
		public Vector3 worldNormal { get; set; }

		public float clickTime { get; set; }

		public int clickCount { get; set; }

		public Vector2 scrollDelta { get; set; }

		public bool useDragThreshold { get; set; }

		public bool dragging { get; set; }

		public InputButton button { get; set; }

		public Camera enterEventCamera
		{
			get
			{
				if (!(pointerCurrentRaycast.module == null))
				{
					return pointerCurrentRaycast.module.eventCamera;
				}
				return null;
			}
		}

		public Camera pressEventCamera
		{
			get
			{
				if (!(pointerPressRaycast.module == null))
				{
					return pointerPressRaycast.module.eventCamera;
				}
				return null;
			}
		}

		public GameObject pointerPress
		{
			get
			{
				return m_PointerPress;
			}
			set
			{
				if (!(m_PointerPress == value))
				{
					lastPress = m_PointerPress;
					m_PointerPress = value;
				}
			}
		}

		public PointerEventData(EventSystem eventSystem)
			: base(eventSystem)
		{
			eligibleForClick = false;
			pointerId = -1;
			position = Vector2.zero;
			delta = Vector2.zero;
			pressPosition = Vector2.zero;
			clickTime = 0f;
			clickCount = 0;
			scrollDelta = Vector2.zero;
			useDragThreshold = true;
			dragging = false;
			button = InputButton.Left;
		}

		public bool IsPointerMoving()
		{
			return delta.sqrMagnitude > 0f;
		}

		public bool IsScrolling()
		{
			return scrollDelta.sqrMagnitude > 0f;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("<b>Position</b>: " + position.ToString());
			stringBuilder.AppendLine("<b>delta</b>: " + delta.ToString());
			stringBuilder.AppendLine("<b>eligibleForClick</b>: " + eligibleForClick);
			stringBuilder.AppendLine("<b>pointerEnter</b>: " + pointerEnter);
			stringBuilder.AppendLine("<b>pointerPress</b>: " + pointerPress);
			stringBuilder.AppendLine("<b>lastPointerPress</b>: " + lastPress);
			stringBuilder.AppendLine("<b>pointerDrag</b>: " + pointerDrag);
			stringBuilder.AppendLine("<b>Use Drag Threshold</b>: " + useDragThreshold);
			stringBuilder.AppendLine("<b>Current Raycast:</b>");
			stringBuilder.AppendLine(pointerCurrentRaycast.ToString());
			stringBuilder.AppendLine("<b>Press Raycast:</b>");
			stringBuilder.AppendLine(pointerPressRaycast.ToString());
			return stringBuilder.ToString();
		}
	}
	[Flags]
	public enum EventHandle
	{
		Unused = 0,
		Used = 1
	}
	public interface IEventSystemHandler
	{
	}
	public interface IPointerEnterHandler : IEventSystemHandler
	{
		void OnPointerEnter(PointerEventData eventData);
	}
	public interface IPointerExitHandler : IEventSystemHandler
	{
		void OnPointerExit(PointerEventData eventData);
	}
	public interface IPointerDownHandler : IEventSystemHandler
	{
		void OnPointerDown(PointerEventData eventData);
	}
	public interface IPointerUpHandler : IEventSystemHandler
	{
		void OnPointerUp(PointerEventData eventData);
	}
	public interface IPointerClickHandler : IEventSystemHandler
	{
		void OnPointerClick(PointerEventData eventData);
	}
	public interface IBeginDragHandler : IEventSystemHandler
	{
		void OnBeginDrag(PointerEventData eventData);
	}
	public interface IInitializePotentialDragHandler : IEventSystemHandler
	{
		void OnInitializePotentialDrag(PointerEventData eventData);
	}
	public interface IDragHandler : IEventSystemHandler
	{
		void OnDrag(PointerEventData eventData);
	}
	public interface IEndDragHandler : IEventSystemHandler
	{
		void OnEndDrag(PointerEventData eventData);
	}
	public interface IDropHandler : IEventSystemHandler
	{
		void OnDrop(PointerEventData eventData);
	}
	public interface IScrollHandler : IEventSystemHandler
	{
		void OnScroll(PointerEventData eventData);
	}
	public interface IUpdateSelectedHandler : IEventSystemHandler
	{
		void OnUpdateSelected(BaseEventData eventData);
	}
	public interface ISelectHandler : IEventSystemHandler
	{
		void OnSelect(BaseEventData eventData);
	}
	public interface IDeselectHandler : IEventSystemHandler
	{
		void OnDeselect(BaseEventData eventData);
	}
	public interface IMoveHandler : IEventSystemHandler
	{
		void OnMove(AxisEventData eventData);
	}
	public interface ISubmitHandler : IEventSystemHandler
	{
		void OnSubmit(BaseEventData eventData);
	}
	public interface ICancelHandler : IEventSystemHandler
	{
		void OnCancel(BaseEventData eventData);
	}
	[AddComponentMenu("Event/Event System")]
	public class EventSystem : UIBehaviour
	{
		private List<BaseInputModule> m_SystemInputModules = new List<BaseInputModule>();

		private BaseInputModule m_CurrentInputModule;

		private static List<EventSystem> m_EventSystems = new List<EventSystem>();

		[SerializeField]
		[FormerlySerializedAs("m_Selected")]
		private GameObject m_FirstSelected;

		[SerializeField]
		private bool m_sendNavigationEvents = true;

		[SerializeField]
		private int m_DragThreshold = 10;

		private GameObject m_CurrentSelected;

		private bool m_HasFocus = true;

		private bool m_SelectionGuard;

		private BaseEventData m_DummyData;

		private static readonly Comparison<RaycastResult> s_RaycastComparer = RaycastComparer;

		public static EventSystem current
		{
			get
			{
				if (m_EventSystems.Count <= 0)
				{
					return null;
				}
				return m_EventSystems[0];
			}
			set
			{
				int num = m_EventSystems.IndexOf(value);
				if (num >= 0)
				{
					m_EventSystems.RemoveAt(num);
					m_EventSystems.Insert(0, value);
				}
			}
		}

		public bool sendNavigationEvents
		{
			get
			{
				return m_sendNavigationEvents;
			}
			set
			{
				m_sendNavigationEvents = value;
			}
		}

		public int pixelDragThreshold
		{
			get
			{
				return m_DragThreshold;
			}
			set
			{
				m_DragThreshold = value;
			}
		}

		public BaseInputModule currentInputModule => m_CurrentInputModule;

		public GameObject firstSelectedGameObject
		{
			get
			{
				return m_FirstSelected;
			}
			set
			{
				m_FirstSelected = value;
			}
		}

		public GameObject currentSelectedGameObject => m_CurrentSelected;

		[Obsolete("lastSelectedGameObject is no longer supported")]
		public GameObject lastSelectedGameObject => null;

		public bool isFocused => m_HasFocus;

		public bool alreadySelecting => m_SelectionGuard;

		private BaseEventData baseEventDataCache
		{
			get
			{
				if (m_DummyData == null)
				{
					m_DummyData = new BaseEventData(this);
				}
				return m_DummyData;
			}
		}

		protected EventSystem()
		{
		}

		public void UpdateModules()
		{
			GetComponents(m_SystemInputModules);
			for (int num = m_SystemInputModules.Count - 1; num >= 0; num--)
			{
				if (!m_SystemInputModules[num] || !m_SystemInputModules[num].IsActive())
				{
					m_SystemInputModules.RemoveAt(num);
				}
			}
		}

		public void SetSelectedGameObject(GameObject selected, BaseEventData pointer)
		{
			if (m_SelectionGuard)
			{
				Debug.LogError("Attempting to select " + selected?.ToString() + "while already selecting an object.");
				return;
			}
			m_SelectionGuard = true;
			if (selected == m_CurrentSelected)
			{
				m_SelectionGuard = false;
				return;
			}
			ExecuteEvents.Execute(m_CurrentSelected, pointer, ExecuteEvents.deselectHandler);
			m_CurrentSelected = selected;
			ExecuteEvents.Execute(m_CurrentSelected, pointer, ExecuteEvents.selectHandler);
			m_SelectionGuard = false;
		}

		public void SetSelectedGameObject(GameObject selected)
		{
			SetSelectedGameObject(selected, baseEventDataCache);
		}

		private static int RaycastComparer(RaycastResult lhs, RaycastResult rhs)
		{
			if (lhs.module != rhs.module)
			{
				Camera eventCamera = lhs.module.eventCamera;
				Camera eventCamera2 = rhs.module.eventCamera;
				if (eventCamera != null && eventCamera2 != null && eventCamera.depth != eventCamera2.depth)
				{
					if (eventCamera.depth < eventCamera2.depth)
					{
						return 1;
					}
					if (eventCamera.depth == eventCamera2.depth)
					{
						return 0;
					}
					return -1;
				}
				if (lhs.module.sortOrderPriority != rhs.module.sortOrderPriority)
				{
					return rhs.module.sortOrderPriority.CompareTo(lhs.module.sortOrderPriority);
				}
				if (lhs.module.renderOrderPriority != rhs.module.renderOrderPriority)
				{
					return rhs.module.renderOrderPriority.CompareTo(lhs.module.renderOrderPriority);
				}
			}
			if (lhs.sortingLayer != rhs.sortingLayer)
			{
				int layerValueFromID = SortingLayer.GetLayerValueFromID(rhs.sortingLayer);
				int layerValueFromID2 = SortingLayer.GetLayerValueFromID(lhs.sortingLayer);
				return layerValueFromID.CompareTo(layerValueFromID2);
			}
			if (lhs.sortingOrder != rhs.sortingOrder)
			{
				return rhs.sortingOrder.CompareTo(lhs.sortingOrder);
			}
			if (lhs.depth != rhs.depth && lhs.module.rootRaycaster == rhs.module.rootRaycaster)
			{
				return rhs.depth.CompareTo(lhs.depth);
			}
			if (lhs.distance != rhs.distance)
			{
				return lhs.distance.CompareTo(rhs.distance);
			}
			return lhs.index.CompareTo(rhs.index);
		}

		public void RaycastAll(PointerEventData eventData, List<RaycastResult> raycastResults)
		{
			raycastResults.Clear();
			List<BaseRaycaster> raycasters = RaycasterManager.GetRaycasters();
			for (int i = 0; i < raycasters.Count; i++)
			{
				BaseRaycaster baseRaycaster = raycasters[i];
				if (!(baseRaycaster == null) && baseRaycaster.IsActive())
				{
					baseRaycaster.Raycast(eventData, raycastResults);
				}
			}
			raycastResults.Sort(s_RaycastComparer);
		}

		public bool IsPointerOverGameObject()
		{
			return IsPointerOverGameObject(-1);
		}

		public bool IsPointerOverGameObject(int pointerId)
		{
			if (m_CurrentInputModule == null)
			{
				return false;
			}
			return m_CurrentInputModule.IsPointerOverGameObject(pointerId);
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			m_EventSystems.Add(this);
		}

		protected override void OnDisable()
		{
			if (m_CurrentInputModule != null)
			{
				m_CurrentInputModule.DeactivateModule();
				m_CurrentInputModule = null;
			}
			m_EventSystems.Remove(this);
			base.OnDisable();
		}

		private void TickModules()
		{
			for (int i = 0; i < m_SystemInputModules.Count; i++)
			{
				if (m_SystemInputModules[i] != null)
				{
					m_SystemInputModules[i].UpdateModule();
				}
			}
		}

		protected virtual void OnApplicationFocus(bool hasFocus)
		{
			m_HasFocus = hasFocus;
		}

		protected virtual void Update()
		{
			if (current != this)
			{
				return;
			}
			TickModules();
			bool flag = false;
			for (int i = 0; i < m_SystemInputModules.Count; i++)
			{
				BaseInputModule baseInputModule = m_SystemInputModules[i];
				if (baseInputModule.IsModuleSupported() && baseInputModule.ShouldActivateModule())
				{
					if (m_CurrentInputModule != baseInputModule)
					{
						ChangeEventModule(baseInputModule);
						flag = true;
					}
					break;
				}
			}
			if (m_CurrentInputModule == null)
			{
				for (int j = 0; j < m_SystemInputModules.Count; j++)
				{
					BaseInputModule baseInputModule2 = m_SystemInputModules[j];
					if (baseInputModule2.IsModuleSupported())
					{
						ChangeEventModule(baseInputModule2);
						flag = true;
						break;
					}
				}
			}
			if (!flag && m_CurrentInputModule != null)
			{
				m_CurrentInputModule.Process();
			}
		}

		private void ChangeEventModule(BaseInputModule module)
		{
			if (!(m_CurrentInputModule == module))
			{
				if (m_CurrentInputModule != null)
				{
					m_CurrentInputModule.DeactivateModule();
				}
				if (module != null)
				{
					module.ActivateModule();
				}
				m_CurrentInputModule = module;
			}
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("<b>Selected:</b>" + currentSelectedGameObject);
			stringBuilder.AppendLine();
			stringBuilder.AppendLine();
			stringBuilder.AppendLine((m_CurrentInputModule != null) ? m_CurrentInputModule.ToString() : "No module");
			return stringBuilder.ToString();
		}
	}
	[AddComponentMenu("Event/Event Trigger")]
	public class EventTrigger : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler, IPointerClickHandler, IInitializePotentialDragHandler, IBeginDragHandler, IDragHandler, IEndDragHandler, IDropHandler, IScrollHandler, IUpdateSelectedHandler, ISelectHandler, IDeselectHandler, IMoveHandler, ISubmitHandler, ICancelHandler
	{
		[Serializable]
		public class TriggerEvent : UnityEvent<BaseEventData>
		{
		}

		[Serializable]
		public class Entry
		{
			public EventTriggerType eventID = EventTriggerType.PointerClick;

			public TriggerEvent callback = new TriggerEvent();
		}

		[FormerlySerializedAs("delegates")]
		[SerializeField]
		private List<Entry> m_Delegates;

		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("Please use triggers instead (UnityUpgradable) -> triggers", true)]
		public List<Entry> delegates
		{
			get
			{
				return triggers;
			}
			set
			{
				triggers = value;
			}
		}

		public List<Entry> triggers
		{
			get
			{
				if (m_Delegates == null)
				{
					m_Delegates = new List<Entry>();
				}
				return m_Delegates;
			}
			set
			{
				m_Delegates = value;
			}
		}

		protected EventTrigger()
		{
		}

		private void Execute(EventTriggerType id, BaseEventData eventData)
		{
			int i = 0;
			for (int count = triggers.Count; i < count; i++)
			{
				Entry entry = triggers[i];
				if (entry.eventID == id && entry.callback != null)
				{
					entry.callback.Invoke(eventData);
				}
			}
		}

		public virtual void OnPointerEnter(PointerEventData eventData)
		{
			Execute(EventTriggerType.PointerEnter, eventData);
		}

		public virtual void OnPointerExit(PointerEventData eventData)
		{
			Execute(EventTriggerType.PointerExit, eventData);
		}

		public virtual void OnDrag(PointerEventData eventData)
		{
			Execute(EventTriggerType.Drag, eventData);
		}

		public virtual void OnDrop(PointerEventData eventData)
		{
			Execute(EventTriggerType.Drop, eventData);
		}

		public virtual void OnPointerDown(PointerEventData eventData)
		{
			Execute(EventTriggerType.PointerDown, eventData);
		}

		public virtual void OnPointerUp(PointerEventData eventData)
		{
			Execute(EventTriggerType.PointerUp, eventData);
		}

		public virtual void OnPointerClick(PointerEventData eventData)
		{
			Execute(EventTriggerType.PointerClick, eventData);
		}

		public virtual void OnSelect(BaseEventData eventData)
		{
			Execute(EventTriggerType.Select, eventData);
		}

		public virtual void OnDeselect(BaseEventData eventData)
		{
			Execute(EventTriggerType.Deselect, eventData);
		}

		public virtual void OnScroll(PointerEventData eventData)
		{
			Execute(EventTriggerType.Scroll, eventData);
		}

		public virtual void OnMove(AxisEventData eventData)
		{
			Execute(EventTriggerType.Move, eventData);
		}

		public virtual void OnUpdateSelected(BaseEventData eventData)
		{
			Execute(EventTriggerType.UpdateSelected, eventData);
		}

		public virtual void OnInitializePotentialDrag(PointerEventData eventData)
		{
			Execute(EventTriggerType.InitializePotentialDrag, eventData);
		}

		public virtual void OnBeginDrag(PointerEventData eventData)
		{
			Execute(EventTriggerType.BeginDrag, eventData);
		}

		public virtual void OnEndDrag(PointerEventData eventData)
		{
			Execute(EventTriggerType.EndDrag, eventData);
		}

		public virtual void OnSubmit(BaseEventData eventData)
		{
			Execute(EventTriggerType.Submit, eventData);
		}

		public virtual void OnCancel(BaseEventData eventData)
		{
			Execute(EventTriggerType.Cancel, eventData);
		}
	}
	public enum EventTriggerType
	{
		PointerEnter,
		PointerExit,
		PointerDown,
		PointerUp,
		PointerClick,
		Drag,
		Drop,
		Scroll,
		UpdateSelected,
		Select,
		Deselect,
		Move,
		InitializePotentialDrag,
		BeginDrag,
		EndDrag,
		Submit,
		Cancel
	}
	public static class ExecuteEvents
	{
		public delegate void EventFunction<T1>(T1 handler, BaseEventData eventData);

		private static readonly EventFunction<IPointerEnterHandler> s_PointerEnterHandler = Execute;

		private static readonly EventFunction<IPointerExitHandler> s_PointerExitHandler = Execute;

		private static readonly EventFunction<IPointerDownHandler> s_PointerDownHandler = Execute;

		private static readonly EventFunction<IPointerUpHandler> s_PointerUpHandler = Execute;

		private static readonly EventFunction<IPointerClickHandler> s_PointerClickHandler = Execute;

		private static readonly EventFunction<IInitializePotentialDragHandler> s_InitializePotentialDragHandler = Execute;

		private static readonly EventFunction<IBeginDragHandler> s_BeginDragHandler = Execute;

		private static readonly EventFunction<IDragHandler> s_DragHandler = Execute;

		private static readonly EventFunction<IEndDragHandler> s_EndDragHandler = Execute;

		private static readonly EventFunction<IDropHandler> s_DropHandler = Execute;

		private static readonly EventFunction<IScrollHandler> s_ScrollHandler = Execute;

		private static readonly EventFunction<IUpdateSelectedHandler> s_UpdateSelectedHandler = Execute;

		private static readonly EventFunction<ISelectHandler> s_SelectHandler = Execute;

		private static readonly EventFunction<IDeselectHandler> s_DeselectHandler = Execute;

		private static readonly EventFunction<IMoveHandler> s_MoveHandler = Execute;

		private static readonly EventFunction<ISubmitHandler> s_SubmitHandler = Execute;

		private static readonly EventFunction<ICancelHandler> s_CancelHandler = Execute;

		private static readonly ObjectPool<List<IEventSystemHandler>> s_HandlerListPool = new ObjectPool<List<IEventSystemHandler>>(null, delegate(List<IEventSystemHandler> l)
		{
			l.Clear();
		});

		private static readonly List<Transform> s_InternalTransformList = new List<Transform>(30);

		public static EventFunction<IPointerEnterHandler> pointerEnterHandler => s_PointerEnterHandler;

		public static EventFunction<IPointerExitHandler> pointerExitHandler => s_PointerExitHandler;

		public static EventFunction<IPointerDownHandler> pointerDownHandler => s_PointerDownHandler;

		public static EventFunction<IPointerUpHandler> pointerUpHandler => s_PointerUpHandler;

		public static EventFunction<IPointerClickHandler> pointerClickHandler => s_PointerClickHandler;

		public static EventFunction<IInitializePotentialDragHandler> initializePotentialDrag => s_InitializePotentialDragHandler;

		public static EventFunction<IBeginDragHandler> beginDragHandler => s_BeginDragHandler;

		public static EventFunction<IDragHandler> dragHandler => s_DragHandler;

		public static EventFunction<IEndDragHandler> endDragHandler => s_EndDragHandler;

		public static EventFunction<IDropHandler> dropHandler => s_DropHandler;

		public static EventFunction<IScrollHandler> scrollHandler => s_ScrollHandler;

		public static EventFunction<IUpdateSelectedHandler> updateSelectedHandler => s_UpdateSelectedHandler;

		public static EventFunction<ISelectHandler> selectHandler => s_SelectHandler;

		public static EventFunction<IDeselectHandler> deselectHandler => s_DeselectHandler;

		public static EventFunction<IMoveHandler> moveHandler => s_MoveHandler;

		public static EventFunction<ISubmitHandler> submitHandler => s_SubmitHandler;

		public static EventFunction<ICancelHandler> cancelHandler => s_CancelHandler;

		public static T ValidateEventData<T>(BaseEventData data) where T : class
		{
			if (data as T == null)
			{
				throw new ArgumentException($"Invalid type: {data.GetType()} passed to event expecting {typeof(T)}");
			}
			return data as T;
		}

		private static void Execute(IPointerEnterHandler handler, BaseEventData eventData)
		{
			handler.OnPointerEnter(ValidateEventData<PointerEventData>(eventData));
		}

		private static void Execute(IPointerExitHandler handler, BaseEventData eventData)
		{
			handler.OnPointerExit(ValidateEventData<PointerEventData>(eventData));
		}

		private static void Execute(IPointerDownHandler handler, BaseEventData eventData)
		{
			handler.OnPointerDown(ValidateEventData<PointerEventData>(eventData));
		}

		private static void Execute(IPointerUpHandler handler, BaseEventData eventData)
		{
			handler.OnPointerUp(ValidateEventData<PointerEventData>(eventData));
		}

		private static void Execute(IPointerClickHandler handler, BaseEventData eventData)
		{
			handler.OnPointerClick(ValidateEventData<PointerEventData>(eventData));
		}

		private static void Execute(IInitializePotentialDragHandler handler, BaseEventData eventData)
		{
			handler.OnInitializePotentialDrag(ValidateEventData<PointerEventData>(eventData));
		}

		private static void Execute(IBeginDragHandler handler, BaseEventData eventData)
		{
			handler.OnBeginDrag(ValidateEventData<PointerEventData>(eventData));
		}

		private static void Execute(IDragHandler handler, BaseEventData eventData)
		{
			handler.OnDrag(ValidateEventData<PointerEventData>(eventData));
		}

		private static void Execute(IEndDragHandler handler, BaseEventData eventData)
		{
			handler.OnEndDrag(ValidateEventData<PointerEventData>(eventData));
		}

		private static void Execute(IDropHandler handler, BaseEventData eventData)
		{
			handler.OnDrop(ValidateEventData<PointerEventData>(eventData));
		}

		private static void Execute(IScrollHandler handler, BaseEventData eventData)
		{
			handler.OnScroll(ValidateEventData<PointerEventData>(eventData));
		}

		private static void Execute(IUpdateSelectedHandler handler, BaseEventData eventData)
		{
			handler.OnUpdateSelected(eventData);
		}

		private static void Execute(ISelectHandler handler, BaseEventData eventData)
		{
			handler.OnSelect(eventData);
		}

		private static void Execute(IDeselectHandler handler, BaseEventData eventData)
		{
			handler.OnDeselect(eventData);
		}

		private static void Execute(IMoveHandler handler, BaseEventData eventData)
		{
			handler.OnMove(ValidateEventData<AxisEventData>(eventData));
		}

		private static void Execute(ISubmitHandler handler, BaseEventData eventData)
		{
			handler.OnSubmit(eventData);
		}

		private static void Execute(ICancelHandler handler, BaseEventData eventData)
		{
			handler.OnCancel(eventData);
		}

		private static void GetEventChain(GameObject root, IList<Transform> eventChain)
		{
			eventChain.Clear();
			if (!(root == null))
			{
				Transform transform = root.transform;
				while (transform != null)
				{
					eventChain.Add(transform);
					transform = transform.parent;
				}
			}
		}

		public static bool Execute<T>(GameObject target, BaseEventData eventData, EventFunction<T> functor) where T : IEventSystemHandler
		{
			List<IEventSystemHandler> list = s_HandlerListPool.Get();
			GetEventList<T>(target, list);
			for (int i = 0; i < list.Count; i++)
			{
				T handler;
				try
				{
					handler = (T)list[i];
				}
				catch (Exception innerException)
				{
					IEventSystemHandler eventSystemHandler = list[i];
					Debug.LogException(new Exception($"Type {typeof(T).Name} expected {eventSystemHandler.GetType().Name} received.", innerException));
					continue;
				}
				try
				{
					functor(handler, eventData);
				}
				catch (Exception exception)
				{
					Debug.LogException(exception);
				}
			}
			int count = list.Count;
			s_HandlerListPool.Release(list);
			return count > 0;
		}

		public static GameObject ExecuteHierarchy<T>(GameObject root, BaseEventData eventData, EventFunction<T> callbackFunction) where T : IEventSystemHandler
		{
			GetEventChain(root, s_InternalTransformList);
			for (int i = 0; i < s_InternalTransformList.Count; i++)
			{
				Transform transform = s_InternalTransformList[i];
				if (Execute(transform.gameObject, eventData, callbackFunction))
				{
					return transform.gameObject;
				}
			}
			return null;
		}

		private static bool ShouldSendToComponent<T>(Component component) where T : IEventSystemHandler
		{
			if (!(component is T))
			{
				return false;
			}
			Behaviour behaviour = component as Behaviour;
			if (behaviour != null)
			{
				return behaviour.isActiveAndEnabled;
			}
			return true;
		}

		private static void GetEventList<T>(GameObject go, IList<IEventSystemHandler> results) where T : IEventSystemHandler
		{
			if (results == null)
			{
				throw new ArgumentException("Results array is null", "results");
			}
			if (go == null || !go.activeInHierarchy)
			{
				return;
			}
			List<Component> list = ListPool<Component>.Get();
			go.GetComponents(list);
			for (int i = 0; i < list.Count; i++)
			{
				if (ShouldSendToComponent<T>(list[i]))
				{
					results.Add(list[i] as IEventSystemHandler);
				}
			}
			ListPool<Component>.Release(list);
		}

		public static bool CanHandleEvent<T>(GameObject go) where T : IEventSystemHandler
		{
			List<IEventSystemHandler> list = s_HandlerListPool.Get();
			GetEventList<T>(go, list);
			int count = list.Count;
			s_HandlerListPool.Release(list);
			return count != 0;
		}

		public static GameObject GetEventHandler<T>(GameObject root) where T : IEventSystemHandler
		{
			if (root == null)
			{
				return null;
			}
			Transform transform = root.transform;
			while (transform != null)
			{
				if (CanHandleEvent<T>(transform.gameObject))
				{
					return transform.gameObject;
				}
				transform = transform.parent;
			}
			return null;
		}
	}
	public class BaseInput : UIBehaviour
	{
		public virtual string compositionString => Input.compositionString;

		public virtual IMECompositionMode imeCompositionMode
		{
			get
			{
				return Input.imeCompositionMode;
			}
			set
			{
				Input.imeCompositionMode = value;
			}
		}

		public virtual Vector2 compositionCursorPos
		{
			get
			{
				return Input.compositionCursorPos;
			}
			set
			{
				Input.compositionCursorPos = value;
			}
		}

		public virtual bool mousePresent => Input.mousePresent;

		public virtual Vector2 mousePosition => Input.mousePosition;

		public virtual Vector2 mouseScrollDelta => Input.mouseScrollDelta;

		public virtual bool touchSupported => Input.touchSupported;

		public virtual int touchCount => Input.touchCount;

		public virtual bool GetMouseButtonDown(int button)
		{
			return Input.GetMouseButtonDown(button);
		}

		public virtual bool GetMouseButtonUp(int button)
		{
			return Input.GetMouseButtonUp(button);
		}

		public virtual bool GetMouseButton(int button)
		{
			return Input.GetMouseButton(button);
		}

		public virtual Touch GetTouch(int index)
		{
			return Input.GetTouch(index);
		}

		public virtual float GetAxisRaw(string axisName)
		{
			return Input.GetAxisRaw(axisName);
		}

		public virtual bool GetButtonDown(string buttonName)
		{
			return Input.GetButtonDown(buttonName);
		}
	}
	[RequireComponent(typeof(EventSystem))]
	public abstract class BaseInputModule : UIBehaviour
	{
		[NonSerialized]
		protected List<RaycastResult> m_RaycastResultCache = new List<RaycastResult>();

		private AxisEventData m_AxisEventData;

		private EventSystem m_EventSystem;

		private BaseEventData m_BaseEventData;

		protected BaseInput m_InputOverride;

		private BaseInput m_DefaultInput;

		public BaseInput input
		{
			get
			{
				if (m_InputOverride != null)
				{
					return m_InputOverride;
				}
				if (m_DefaultInput == null)
				{
					BaseInput[] components = GetComponents<BaseInput>();
					foreach (BaseInput baseInput in components)
					{
						if (baseInput != null && baseInput.GetType() == typeof(BaseInput))
						{
							m_DefaultInput = baseInput;
							break;
						}
					}
					if (m_DefaultInput == null)
					{
						m_DefaultInput = base.gameObject.AddComponent<BaseInput>();
					}
				}
				return m_DefaultInput;
			}
		}

		public BaseInput inputOverride
		{
			get
			{
				return m_InputOverride;
			}
			set
			{
				m_InputOverride = value;
			}
		}

		protected EventSystem eventSystem => m_EventSystem;

		protected override void OnEnable()
		{
			base.OnEnable();
			m_EventSystem = GetComponent<EventSystem>();
			m_EventSystem.UpdateModules();
		}

		protected override void OnDisable()
		{
			m_EventSystem.UpdateModules();
			base.OnDisable();
		}

		public abstract void Process();

		protected static RaycastResult FindFirstRaycast(List<RaycastResult> candidates)
		{
			for (int i = 0; i < candidates.Count; i++)
			{
				if (!(candidates[i].gameObject == null))
				{
					return candidates[i];
				}
			}
			return default(RaycastResult);
		}

		protected static MoveDirection DetermineMoveDirection(float x, float y)
		{
			return DetermineMoveDirection(x, y, 0.6f);
		}

		protected static MoveDirection DetermineMoveDirection(float x, float y, float deadZone)
		{
			if (new Vector2(x, y).sqrMagnitude < deadZone * deadZone)
			{
				return MoveDirection.None;
			}
			if (Mathf.Abs(x) > Mathf.Abs(y))
			{
				if (x > 0f)
				{
					return MoveDirection.Right;
				}
				return MoveDirection.Left;
			}
			if (y > 0f)
			{
				return MoveDirection.Up;
			}
			return MoveDirection.Down;
		}

		protected static GameObject FindCommonRoot(GameObject g1, GameObject g2)
		{
			if (g1 == null || g2 == null)
			{
				return null;
			}
			Transform parent = g1.transform;
			while (parent != null)
			{
				Transform parent2 = g2.transform;
				while (parent2 != null)
				{
					if (parent == parent2)
					{
						return parent.gameObject;
					}
					parent2 = parent2.parent;
				}
				parent = parent.parent;
			}
			return null;
		}

		protected void HandlePointerExitAndEnter(PointerEventData currentPointerData, GameObject newEnterTarget)
		{
			if (newEnterTarget == null || currentPointerData.pointerEnter == null)
			{
				for (int i = 0; i < currentPointerData.hovered.Count; i++)
				{
					ExecuteEvents.Execute(currentPointerData.hovered[i], currentPointerData, ExecuteEvents.pointerExitHandler);
				}
				currentPointerData.hovered.Clear();
				if (newEnterTarget == null)
				{
					currentPointerData.pointerEnter = null;
					return;
				}
			}
			if (currentPointerData.pointerEnter == newEnterTarget && (bool)newEnterTarget)
			{
				return;
			}
			GameObject gameObject = FindCommonRoot(currentPointerData.pointerEnter, newEnterTarget);
			if (currentPointerData.pointerEnter != null)
			{
				Transform parent = currentPointerData.pointerEnter.transform;
				while (parent != null && (!(gameObject != null) || !(gameObject.transform == parent)))
				{
					ExecuteEvents.Execute(parent.gameObject, currentPointerData, ExecuteEvents.pointerExitHandler);
					currentPointerData.hovered.Remove(parent.gameObject);
					parent = parent.parent;
				}
			}
			currentPointerData.pointerEnter = newEnterTarget;
			if (newEnterTarget != null)
			{
				Transform parent2 = newEnterTarget.transform;
				while (parent2 != null && parent2.gameObject != gameObject)
				{
					ExecuteEvents.Execute(parent2.gameObject, currentPointerData, ExecuteEvents.pointerEnterHandler);
					currentPointerData.hovered.Add(parent2.gameObject);
					parent2 = parent2.parent;
				}
			}
		}

		protected virtual AxisEventData GetAxisEventData(float x, float y, float moveDeadZone)
		{
			if (m_AxisEventData == null)
			{
				m_AxisEventData = new AxisEventData(eventSystem);
			}
			m_AxisEventData.Reset();
			m_AxisEventData.moveVector = new Vector2(x, y);
			m_AxisEventData.moveDir = DetermineMoveDirection(x, y, moveDeadZone);
			return m_AxisEventData;
		}

		protected virtual BaseEventData GetBaseEventData()
		{
			if (m_BaseEventData == null)
			{
				m_BaseEventData = new BaseEventData(eventSystem);
			}
			m_BaseEventData.Reset();
			return m_BaseEventData;
		}

		public virtual bool IsPointerOverGameObject(int pointerId)
		{
			return false;
		}

		public virtual bool ShouldActivateModule()
		{
			if (base.enabled)
			{
				return base.gameObject.activeInHierarchy;
			}
			return false;
		}

		public virtual void DeactivateModule()
		{
		}

		public virtual void ActivateModule()
		{
		}

		public virtual void UpdateModule()
		{
		}

		public virtual bool IsModuleSupported()
		{
			return true;
		}
	}
	public abstract class PointerInputModule : BaseInputModule
	{
		protected class ButtonState
		{
			private PointerEventData.InputButton m_Button;

			private MouseButtonEventData m_EventData;

			public MouseButtonEventData eventData
			{
				get
				{
					return m_EventData;
				}
				set
				{
					m_EventData = value;
				}
			}

			public PointerEventData.InputButton button
			{
				get
				{
					return m_Button;
				}
				set
				{
					m_Button = value;
				}
			}
		}

		protected class MouseState
		{
			private List<ButtonState> m_TrackedButtons = new List<ButtonState>();

			public bool AnyPressesThisFrame()
			{
				for (int i = 0; i < m_TrackedButtons.Count; i++)
				{
					if (m_TrackedButtons[i].eventData.PressedThisFrame())
					{
						return true;
					}
				}
				return false;
			}

			public bool AnyReleasesThisFrame()
			{
				for (int i = 0; i < m_TrackedButtons.Count; i++)
				{
					if (m_TrackedButtons[i].eventData.ReleasedThisFrame())
					{
						return true;
					}
				}
				return false;
			}

			public ButtonState GetButtonState(PointerEventData.InputButton button)
			{
				ButtonState buttonState = null;
				for (int i = 0; i < m_TrackedButtons.Count; i++)
				{
					if (m_TrackedButtons[i].button == button)
					{
						buttonState = m_TrackedButtons[i];
						break;
					}
				}
				if (buttonState == null)
				{
					buttonState = new ButtonState
					{
						button = button,
						eventData = new MouseButtonEventData()
					};
					m_TrackedButtons.Add(buttonState);
				}
				return buttonState;
			}

			public void SetButtonState(PointerEventData.InputButton button, PointerEventData.FramePressState stateForMouseButton, PointerEventData data)
			{
				ButtonState buttonState = GetButtonState(button);
				buttonState.eventData.buttonState = stateForMouseButton;
				buttonState.eventData.buttonData = data;
			}
		}

		public class MouseButtonEventData
		{
			public PointerEventData.FramePressState buttonState;

			public PointerEventData buttonData;

			public bool PressedThisFrame()
			{
				if (buttonState != PointerEventData.FramePressState.Pressed)
				{
					return buttonState == PointerEventData.FramePressState.PressedAndReleased;
				}
				return true;
			}

			public bool ReleasedThisFrame()
			{
				if (buttonState != PointerEventData.FramePressState.Released)
				{
					return buttonState == PointerEventData.FramePressState.PressedAndReleased;
				}
				return true;
			}
		}

		public const int kMouseLeftId = -1;

		public const int kMouseRightId = -2;

		public const int kMouseMiddleId = -3;

		public const int kFakeTouchesId = -4;

		protected Dictionary<int, PointerEventData> m_PointerData = new Dictionary<int, PointerEventData>();

		private readonly MouseState m_MouseState = new MouseState();

		protected bool GetPointerData(int id, out PointerEventData data, bool create)
		{
			if (!m_PointerData.TryGetValue(id, out data) && create)
			{
				data = new PointerEventData(base.eventSystem)
				{
					pointerId = id
				};
				m_PointerData.Add(id, data);
				return true;
			}
			return false;
		}

		protected void RemovePointerData(PointerEventData data)
		{
			m_PointerData.Remove(data.pointerId);
		}

		protected PointerEventData GetTouchPointerEventData(Touch input, out bool pressed, out bool released)
		{
			PointerEventData data;
			bool pointerData = GetPointerData(input.fingerId, out data, create: true);
			data.Reset();
			pressed = pointerData || input.phase == TouchPhase.Began;
			released = input.phase == TouchPhase.Canceled || input.phase == TouchPhase.Ended;
			if (pointerData)
			{
				data.position = input.position;
			}
			if (pressed)
			{
				data.delta = Vector2.zero;
			}
			else
			{
				data.delta = input.position - data.position;
			}
			data.position = input.position;
			data.button = PointerEventData.InputButton.Left;
			if (input.phase == TouchPhase.Canceled)
			{
				data.pointerCurrentRaycast = default(RaycastResult);
			}
			else
			{
				base.eventSystem.RaycastAll(data, m_RaycastResultCache);
				RaycastResult pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
				data.pointerCurrentRaycast = pointerCurrentRaycast;
				m_RaycastResultCache.Clear();
			}
			return data;
		}

		protected void CopyFromTo(PointerEventData from, PointerEventData to)
		{
			to.position = from.position;
			to.delta = from.delta;
			to.scrollDelta = from.scrollDelta;
			to.pointerCurrentRaycast = from.pointerCurrentRaycast;
			to.pointerEnter = from.pointerEnter;
		}

		protected PointerEventData.FramePressState StateForMouseButton(int buttonId)
		{
			bool mouseButtonDown = base.input.GetMouseButtonDown(buttonId);
			bool mouseButtonUp = base.input.GetMouseButtonUp(buttonId);
			if (mouseButtonDown && mouseButtonUp)
			{
				return PointerEventData.FramePressState.PressedAndReleased;
			}
			if (mouseButtonDown)
			{
				return PointerEventData.FramePressState.Pressed;
			}
			if (mouseButtonUp)
			{
				return PointerEventData.FramePressState.Released;
			}
			return PointerEventData.FramePressState.NotChanged;
		}

		protected virtual MouseState GetMousePointerEventData()
		{
			return GetMousePointerEventData(0);
		}

		protected virtual MouseState GetMousePointerEventData(int id)
		{
			PointerEventData data;
			bool pointerData = GetPointerData(-1, out data, create: true);
			data.Reset();
			if (pointerData)
			{
				data.position = base.input.mousePosition;
			}
			Vector2 mousePosition = base.input.mousePosition;
			if (Cursor.lockState == CursorLockMode.Locked)
			{
				data.position = new Vector2(-1f, -1f);
				data.delta = Vector2.zero;
			}
			else
			{
				data.delta = mousePosition - data.position;
				data.position = mousePosition;
			}
			data.scrollDelta = base.input.mouseScrollDelta;
			data.button = PointerEventData.InputButton.Left;
			base.eventSystem.RaycastAll(data, m_RaycastResultCache);
			RaycastResult pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
			data.pointerCurrentRaycast = pointerCurrentRaycast;
			m_RaycastResultCache.Clear();
			GetPointerData(-2, out var data2, create: true);
			CopyFromTo(data, data2);
			data2.button = PointerEventData.InputButton.Right;
			GetPointerData(-3, out var data3, create: true);
			CopyFromTo(data, data3);
			data3.button = PointerEventData.InputButton.Middle;
			m_MouseState.SetButtonState(PointerEventData.InputButton.Left, StateForMouseButton(0), data);
			m_MouseState.SetButtonState(PointerEventData.InputButton.Right, StateForMouseButton(1), data2);
			m_MouseState.SetButtonState(PointerEventData.InputButton.Middle, StateForMouseButton(2), data3);
			return m_MouseState;
		}

		protected PointerEventData GetLastPointerEventData(int id)
		{
			GetPointerData(id, out var data, create: false);
			return data;
		}

		private static bool ShouldStartDrag(Vector2 pressPos, Vector2 currentPos, float threshold, bool useDragThreshold)
		{
			if (!useDragThreshold)
			{
				return true;
			}
			return (pressPos - currentPos).sqrMagnitude >= threshold * threshold;
		}

		protected virtual void ProcessMove(PointerEventData pointerEvent)
		{
			GameObject newEnterTarget = ((Cursor.lockState == CursorLockMode.Locked) ? null : pointerEvent.pointerCurrentRaycast.gameObject);
			HandlePointerExitAndEnter(pointerEvent, newEnterTarget);
		}

		protected virtual void ProcessDrag(PointerEventData pointerEvent)
		{
			if (!pointerEvent.IsPointerMoving() || Cursor.lockState == CursorLockMode.Locked || pointerEvent.pointerDrag == null)
			{
				return;
			}
			if (!pointerEvent.dragging && ShouldStartDrag(pointerEvent.pressPosition, pointerEvent.position, base.eventSystem.pixelDragThreshold, pointerEvent.useDragThreshold))
			{
				ExecuteEvents.Execute(pointerEvent.pointerDrag, pointerEvent, ExecuteEvents.beginDragHandler);
				pointerEvent.dragging = true;
			}
			if (pointerEvent.dragging)
			{
				if (pointerEvent.pointerPress != pointerEvent.pointerDrag)
				{
					ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerUpHandler);
					pointerEvent.eligibleForClick = false;
					pointerEvent.pointerPress = null;
					pointerEvent.rawPointerPress = null;
				}
				ExecuteEvents.Execute(pointerEvent.pointerDrag, pointerEvent, ExecuteEvents.dragHandler);
			}
		}

		public override bool IsPointerOverGameObject(int pointerId)
		{
			PointerEventData lastPointerEventData = GetLastPointerEventData(pointerId);
			if (lastPointerEventData != null)
			{
				return lastPointerEventData.pointerEnter != null;
			}
			return false;
		}

		protected void ClearSelection()
		{
			BaseEventData baseEventData = GetBaseEventData();
			foreach (PointerEventData value in m_PointerData.Values)
			{
				HandlePointerExitAndEnter(value, null);
			}
			m_PointerData.Clear();
			base.eventSystem.SetSelectedGameObject(null, baseEventData);
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder("<b>Pointer Input Module of type: </b>" + GetType());
			stringBuilder.AppendLine();
			foreach (KeyValuePair<int, PointerEventData> pointerDatum in m_PointerData)
			{
				if (pointerDatum.Value != null)
				{
					stringBuilder.AppendLine("<B>Pointer:</b> " + pointerDatum.Key);
					stringBuilder.AppendLine(pointerDatum.Value.ToString());
				}
			}
			return stringBuilder.ToString();
		}

		protected void DeselectIfSelectionChanged(GameObject currentOverGo, BaseEventData pointerEvent)
		{
			if (ExecuteEvents.GetEventHandler<ISelectHandler>(currentOverGo) != base.eventSystem.currentSelectedGameObject)
			{
				base.eventSystem.SetSelectedGameObject(null, pointerEvent);
			}
		}
	}
	[AddComponentMenu("Event/Standalone Input Module")]
	public class StandaloneInputModule : PointerInputModule
	{
		[Obsolete("Mode is no longer needed on input module as it handles both mouse and keyboard simultaneously.", false)]
		public enum InputMode
		{
			Mouse,
			Buttons
		}

		private float m_PrevActionTime;

		private Vector2 m_LastMoveVector;

		private int m_ConsecutiveMoveCount;

		private Vector2 m_LastMousePosition;

		private Vector2 m_MousePosition;

		private GameObject m_CurrentFocusedGameObject;

		private PointerEventData m_InputPointerEvent;

		[SerializeField]
		private string m_HorizontalAxis = "Horizontal";

		[SerializeField]
		private string m_VerticalAxis = "Vertical";

		[SerializeField]
		private string m_SubmitButton = "Submit";

		[SerializeField]
		private string m_CancelButton = "Cancel";

		[SerializeField]
		private float m_InputActionsPerSecond = 10f;

		[SerializeField]
		private float m_RepeatDelay = 0.5f;

		[SerializeField]
		[FormerlySerializedAs("m_AllowActivationOnMobileDevice")]
		private bool m_ForceModuleActive;

		[Obsolete("Mode is no longer needed on input module as it handles both mouse and keyboard simultaneously.", false)]
		public InputMode inputMode => InputMode.Mouse;

		[Obsolete("allowActivationOnMobileDevice has been deprecated. Use forceModuleActive instead (UnityUpgradable) -> forceModuleActive")]
		public bool allowActivationOnMobileDevice
		{
			get
			{
				return m_ForceModuleActive;
			}
			set
			{
				m_ForceModuleActive = value;
			}
		}

		public bool forceModuleActive
		{
			get
			{
				return m_ForceModuleActive;
			}
			set
			{
				m_ForceModuleActive = value;
			}
		}

		public float inputActionsPerSecond
		{
			get
			{
				return m_InputActionsPerSecond;
			}
			set
			{
				m_InputActionsPerSecond = value;
			}
		}

		public float repeatDelay
		{
			get
			{
				return m_RepeatDelay;
			}
			set
			{
				m_RepeatDelay = value;
			}
		}

		public string horizontalAxis
		{
			get
			{
				return m_HorizontalAxis;
			}
			set
			{
				m_HorizontalAxis = value;
			}
		}

		public string verticalAxis
		{
			get
			{
				return m_VerticalAxis;
			}
			set
			{
				m_VerticalAxis = value;
			}
		}

		public string submitButton
		{
			get
			{
				return m_SubmitButton;
			}
			set
			{
				m_SubmitButton = value;
			}
		}

		public string cancelButton
		{
			get
			{
				return m_CancelButton;
			}
			set
			{
				m_CancelButton = value;
			}
		}

		protected StandaloneInputModule()
		{
		}

		private bool ShouldIgnoreEventsOnNoFocus()
		{
			OperatingSystemFamily operatingSystemFamily = SystemInfo.operatingSystemFamily;
			if ((uint)(operatingSystemFamily - 1) <= 2u)
			{
				return true;
			}
			return false;
		}

		public override void UpdateModule()
		{
			if (!base.eventSystem.isFocused && ShouldIgnoreEventsOnNoFocus())
			{
				if (m_InputPointerEvent != null && m_InputPointerEvent.pointerDrag != null && m_InputPointerEvent.dragging)
				{
					ReleaseMouse(m_InputPointerEvent, m_InputPointerEvent.pointerCurrentRaycast.gameObject);
				}
				m_InputPointerEvent = null;
			}
			else
			{
				m_LastMousePosition = m_MousePosition;
				m_MousePosition = base.input.mousePosition;
			}
		}

		private void ReleaseMouse(PointerEventData pointerEvent, GameObject currentOverGo)
		{
			ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerUpHandler);
			GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(currentOverGo);
			if (pointerEvent.pointerPress == eventHandler && pointerEvent.eligibleForClick)
			{
				ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerClickHandler);
			}
			else if (pointerEvent.pointerDrag != null && pointerEvent.dragging)
			{
				ExecuteEvents.ExecuteHierarchy(currentOverGo, pointerEvent, ExecuteEvents.dropHandler);
			}
			pointerEvent.eligibleForClick = false;
			pointerEvent.pointerPress = null;
			pointerEvent.rawPointerPress = null;
			if (pointerEvent.pointerDrag != null && pointerEvent.dragging)
			{
				ExecuteEvents.Execute(pointerEvent.pointerDrag, pointerEvent, ExecuteEvents.endDragHandler);
			}
			pointerEvent.dragging = false;
			pointerEvent.pointerDrag = null;
			if (currentOverGo != pointerEvent.pointerEnter)
			{
				HandlePointerExitAndEnter(pointerEvent, null);
				HandlePointerExitAndEnter(pointerEvent, currentOverGo);
			}
			m_InputPointerEvent = pointerEvent;
		}

		public override bool IsModuleSupported()
		{
			if (!m_ForceModuleActive && !base.input.mousePresent)
			{
				return base.input.touchSupported;
			}
			return true;
		}

		public override bool ShouldActivateModule()
		{
			if (!base.ShouldActivateModule())
			{
				return false;
			}
			bool flag = m_ForceModuleActive;
			flag |= base.input.GetButtonDown(m_SubmitButton);
			flag |= base.input.GetButtonDown(m_CancelButton);
			flag |= !Mathf.Approximately(base.input.GetAxisRaw(m_HorizontalAxis), 0f);
			flag |= !Mathf.Approximately(base.input.GetAxisRaw(m_VerticalAxis), 0f);
			flag |= (m_MousePosition - m_LastMousePosition).sqrMagnitude > 0f;
			flag |= base.input.GetMouseButtonDown(0);
			if (base.input.touchCount > 0)
			{
				flag = true;
			}
			return flag;
		}

		public override void ActivateModule()
		{
			if (base.eventSystem.isFocused || !ShouldIgnoreEventsOnNoFocus())
			{
				base.ActivateModule();
				m_MousePosition = base.input.mousePosition;
				m_LastMousePosition = base.input.mousePosition;
				GameObject gameObject = base.eventSystem.currentSelectedGameObject;
				if (gameObject == null)
				{
					gameObject = base.eventSystem.firstSelectedGameObject;
				}
				base.eventSystem.SetSelectedGameObject(gameObject, GetBaseEventData());
			}
		}

		public override void DeactivateModule()
		{
			base.DeactivateModule();
			ClearSelection();
		}

		public override void Process()
		{
			if (!base.eventSystem.isFocused && ShouldIgnoreEventsOnNoFocus())
			{
				return;
			}
			bool flag = SendUpdateEventToSelectedObject();
			if (!ProcessTouchEvents() && base.input.mousePresent)
			{
				ProcessMouseEvent();
			}
			if (base.eventSystem.sendNavigationEvents)
			{
				if (!flag)
				{
					flag |= SendMoveEventToSelectedObject();
				}
				if (!flag)
				{
					SendSubmitEventToSelectedObject();
				}
			}
		}

		private bool ProcessTouchEvents()
		{
			for (int i = 0; i < base.input.touchCount; i++)
			{
				Touch touch = base.input.GetTouch(i);
				if (touch.type != TouchType.Indirect)
				{
					bool pressed;
					bool released;
					PointerEventData touchPointerEventData = GetTouchPointerEventData(touch, out pressed, out released);
					ProcessTouchPress(touchPointerEventData, pressed, released);
					if (!released)
					{
						ProcessMove(touchPointerEventData);
						ProcessDrag(touchPointerEventData);
					}
					else
					{
						RemovePointerData(touchPointerEventData);
					}
				}
			}
			return base.input.touchCount > 0;
		}

		protected void ProcessTouchPress(PointerEventData pointerEvent, bool pressed, bool released)
		{
			GameObject gameObject = pointerEvent.pointerCurrentRaycast.gameObject;
			if (pressed)
			{
				pointerEvent.eligibleForClick = true;
				pointerEvent.delta = Vector2.zero;
				pointerEvent.dragging = false;
				pointerEvent.useDragThreshold = true;
				pointerEvent.pressPosition = pointerEvent.position;
				pointerEvent.pointerPressRaycast = pointerEvent.pointerCurrentRaycast;
				DeselectIfSelectionChanged(gameObject, pointerEvent);
				if (pointerEvent.pointerEnter != gameObject)
				{
					HandlePointerExitAndEnter(pointerEvent, gameObject);
					pointerEvent.pointerEnter = gameObject;
				}
				GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(gameObject, pointerEvent, ExecuteEvents.pointerDownHandler);
				if (gameObject2 == null)
				{
					gameObject2 = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				}
				float unscaledTime = Time.unscaledTime;
				if (gameObject2 == pointerEvent.lastPress)
				{
					if (unscaledTime - pointerEvent.clickTime < 0.3f)
					{
						int clickCount = pointerEvent.clickCount + 1;
						pointerEvent.clickCount = clickCount;
					}
					else
					{
						pointerEvent.clickCount = 1;
					}
					pointerEvent.clickTime = unscaledTime;
				}
				else
				{
					pointerEvent.clickCount = 1;
				}
				pointerEvent.pointerPress = gameObject2;
				pointerEvent.rawPointerPress = gameObject;
				pointerEvent.clickTime = unscaledTime;
				pointerEvent.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(gameObject);
				if (pointerEvent.pointerDrag != null)
				{
					ExecuteEvents.Execute(pointerEvent.pointerDrag, pointerEvent, ExecuteEvents.initializePotentialDrag);
				}
				m_InputPointerEvent = pointerEvent;
			}
			if (released)
			{
				ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerUpHandler);
				GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				if (pointerEvent.pointerPress == eventHandler && pointerEvent.eligibleForClick)
				{
					ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerClickHandler);
				}
				else if (pointerEvent.pointerDrag != null && pointerEvent.dragging)
				{
					ExecuteEvents.ExecuteHierarchy(gameObject, pointerEvent, ExecuteEvents.dropHandler);
				}
				pointerEvent.eligibleForClick = false;
				pointerEvent.pointerPress = null;
				pointerEvent.rawPointerPress = null;
				if (pointerEvent.pointerDrag != null && pointerEvent.dragging)
				{
					ExecuteEvents.Execute(pointerEvent.pointerDrag, pointerEvent, ExecuteEvents.endDragHandler);
				}
				pointerEvent.dragging = false;
				pointerEvent.pointerDrag = null;
				ExecuteEvents.ExecuteHierarchy(pointerEvent.pointerEnter, pointerEvent, ExecuteEvents.pointerExitHandler);
				pointerEvent.pointerEnter = null;
				m_InputPointerEvent = pointerEvent;
			}
		}

		protected bool SendSubmitEventToSelectedObject()
		{
			if (base.eventSystem.currentSelectedGameObject == null)
			{
				return false;
			}
			BaseEventData baseEventData = GetBaseEventData();
			if (base.input.GetButtonDown(m_SubmitButton))
			{
				ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, baseEventData, ExecuteEvents.submitHandler);
			}
			if (base.input.GetButtonDown(m_CancelButton))
			{
				ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, baseEventData, ExecuteEvents.cancelHandler);
			}
			return baseEventData.used;
		}

		private Vector2 GetRawMoveVector()
		{
			Vector2 zero = Vector2.zero;
			zero.x = base.input.GetAxisRaw(m_HorizontalAxis);
			zero.y = base.input.GetAxisRaw(m_VerticalAxis);
			if (base.input.GetButtonDown(m_HorizontalAxis))
			{
				if (zero.x < 0f)
				{
					zero.x = -1f;
				}
				if (zero.x > 0f)
				{
					zero.x = 1f;
				}
			}
			if (base.input.GetButtonDown(m_VerticalAxis))
			{
				if (zero.y < 0f)
				{
					zero.y = -1f;
				}
				if (zero.y > 0f)
				{
					zero.y = 1f;
				}
			}
			return zero;
		}

		protected bool SendMoveEventToSelectedObject()
		{
			float unscaledTime = Time.unscaledTime;
			Vector2 rawMoveVector = GetRawMoveVector();
			if (Mathf.Approximately(rawMoveVector.x, 0f) && Mathf.Approximately(rawMoveVector.y, 0f))
			{
				m_ConsecutiveMoveCount = 0;
				return false;
			}
			bool flag = Vector2.Dot(rawMoveVector, m_LastMoveVector) > 0f;
			if (flag && m_ConsecutiveMoveCount == 1)
			{
				if (unscaledTime <= m_PrevActionTime + m_RepeatDelay)
				{
					return false;
				}
			}
			else if (unscaledTime <= m_PrevActionTime + 1f / m_InputActionsPerSecond)
			{
				return false;
			}
			AxisEventData axisEventData = GetAxisEventData(rawMoveVector.x, rawMoveVector.y, 0.6f);
			if (axisEventData.moveDir != MoveDirection.None)
			{
				ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, axisEventData, ExecuteEvents.moveHandler);
				if (!flag)
				{
					m_ConsecutiveMoveCount = 0;
				}
				m_ConsecutiveMoveCount++;
				m_PrevActionTime = unscaledTime;
				m_LastMoveVector = rawMoveVector;
			}
			else
			{
				m_ConsecutiveMoveCount = 0;
			}
			return axisEventData.used;
		}

		protected void ProcessMouseEvent()
		{
			ProcessMouseEvent(0);
		}

		[Obsolete("This method is no longer checked, overriding it with return true does nothing!")]
		protected virtual bool ForceAutoSelect()
		{
			return false;
		}

		protected void ProcessMouseEvent(int id)
		{
			MouseState mousePointerEventData = GetMousePointerEventData(id);
			MouseButtonEventData eventData = mousePointerEventData.GetButtonState(PointerEventData.InputButton.Left).eventData;
			m_CurrentFocusedGameObject = eventData.buttonData.pointerCurrentRaycast.gameObject;
			ProcessMousePress(eventData);
			ProcessMove(eventData.buttonData);
			ProcessDrag(eventData.buttonData);
			ProcessMousePress(mousePointerEventData.GetButtonState(PointerEventData.InputButton.Right).eventData);
			ProcessDrag(mousePointerEventData.GetButtonState(PointerEventData.InputButton.Right).eventData.buttonData);
			ProcessMousePress(mousePointerEventData.GetButtonState(PointerEventData.InputButton.Middle).eventData);
			ProcessDrag(mousePointerEventData.GetButtonState(PointerEventData.InputButton.Middle).eventData.buttonData);
			if (!Mathf.Approximately(eventData.buttonData.scrollDelta.sqrMagnitude, 0f))
			{
				ExecuteEvents.ExecuteHierarchy(ExecuteEvents.GetEventHandler<IScrollHandler>(eventData.buttonData.pointerCurrentRaycast.gameObject), eventData.buttonData, ExecuteEvents.scrollHandler);
			}
		}

		protected bool SendUpdateEventToSelectedObject()
		{
			if (base.eventSystem.currentSelectedGameObject == null)
			{
				return false;
			}
			BaseEventData baseEventData = GetBaseEventData();
			ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, baseEventData, ExecuteEvents.updateSelectedHandler);
			return baseEventData.used;
		}

		protected void ProcessMousePress(MouseButtonEventData data)
		{
			PointerEventData buttonData = data.buttonData;
			GameObject gameObject = buttonData.pointerCurrentRaycast.gameObject;
			if (data.PressedThisFrame())
			{
				buttonData.eligibleForClick = true;
				buttonData.delta = Vector2.zero;
				buttonData.dragging = false;
				buttonData.useDragThreshold = true;
				buttonData.pressPosition = buttonData.position;
				buttonData.pointerPressRaycast = buttonData.pointerCurrentRaycast;
				DeselectIfSelectionChanged(gameObject, buttonData);
				GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(gameObject, buttonData, ExecuteEvents.pointerDownHandler);
				if (gameObject2 == null)
				{
					gameObject2 = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				}
				float unscaledTime = Time.unscaledTime;
				if (gameObject2 == buttonData.lastPress)
				{
					if (unscaledTime - buttonData.clickTime < 0.3f)
					{
						int clickCount = buttonData.clickCount + 1;
						buttonData.clickCount = clickCount;
					}
					else
					{
						buttonData.clickCount = 1;
					}
					buttonData.clickTime = unscaledTime;
				}
				else
				{
					buttonData.clickCount = 1;
				}
				buttonData.pointerPress = gameObject2;
				buttonData.rawPointerPress = gameObject;
				buttonData.clickTime = unscaledTime;
				buttonData.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(gameObject);
				if (buttonData.pointerDrag != null)
				{
					ExecuteEvents.Execute(buttonData.pointerDrag, buttonData, ExecuteEvents.initializePotentialDrag);
				}
				m_InputPointerEvent = buttonData;
			}
			if (data.ReleasedThisFrame())
			{
				ReleaseMouse(buttonData, gameObject);
			}
		}

		protected GameObject GetCurrentFocusedGameObject()
		{
			return m_CurrentFocusedGameObject;
		}
	}
	[Obsolete("TouchInputModule is no longer required as Touch input is now handled in StandaloneInputModule.")]
	[AddComponentMenu("Event/Touch Input Module")]
	public class TouchInputModule : PointerInputModule
	{
		private Vector2 m_LastMousePosition;

		private Vector2 m_MousePosition;

		private PointerEventData m_InputPointerEvent;

		[SerializeField]
		[FormerlySerializedAs("m_AllowActivationOnStandalone")]
		private bool m_ForceModuleActive;

		[Obsolete("allowActivationOnStandalone has been deprecated. Use forceModuleActive instead (UnityUpgradable) -> forceModuleActive")]
		public bool allowActivationOnStandalone
		{
			get
			{
				return m_ForceModuleActive;
			}
			set
			{
				m_ForceModuleActive = value;
			}
		}

		public bool forceModuleActive
		{
			get
			{
				return m_ForceModuleActive;
			}
			set
			{
				m_ForceModuleActive = value;
			}
		}

		protected TouchInputModule()
		{
		}

		public override void UpdateModule()
		{
			if (!base.eventSystem.isFocused)
			{
				if (m_InputPointerEvent != null && m_InputPointerEvent.pointerDrag != null && m_InputPointerEvent.dragging)
				{
					ExecuteEvents.Execute(m_InputPointerEvent.pointerDrag, m_InputPointerEvent, ExecuteEvents.endDragHandler);
				}
				m_InputPointerEvent = null;
			}
			m_LastMousePosition = m_MousePosition;
			m_MousePosition = base.input.mousePosition;
		}

		public override bool IsModuleSupported()
		{
			if (!forceModuleActive)
			{
				return base.input.touchSupported;
			}
			return true;
		}

		public override bool ShouldActivateModule()
		{
			if (!base.ShouldActivateModule())
			{
				return false;
			}
			if (m_ForceModuleActive)
			{
				return true;
			}
			if (UseFakeInput())
			{
				return base.input.GetMouseButtonDown(0) | ((m_MousePosition - m_LastMousePosition).sqrMagnitude > 0f);
			}
			if (base.input.touchCount > 0)
			{
				return true;
			}
			return false;
		}

		private bool UseFakeInput()
		{
			return !base.input.touchSupported;
		}

		public override void Process()
		{
			if (UseFakeInput())
			{
				FakeTouches();
			}
			else
			{
				ProcessTouchEvents();
			}
		}

		private void FakeTouches()
		{
			MouseButtonEventData eventData = GetMousePointerEventData(0).GetButtonState(PointerEventData.InputButton.Left).eventData;
			if (eventData.PressedThisFrame())
			{
				eventData.buttonData.delta = Vector2.zero;
			}
			ProcessTouchPress(eventData.buttonData, eventData.PressedThisFrame(), eventData.ReleasedThisFrame());
			if (base.input.GetMouseButton(0))
			{
				ProcessMove(eventData.buttonData);
				ProcessDrag(eventData.buttonData);
			}
		}

		private void ProcessTouchEvents()
		{
			for (int i = 0; i < base.input.touchCount; i++)
			{
				Touch touch = base.input.GetTouch(i);
				if (touch.type != TouchType.Indirect)
				{
					bool pressed;
					bool released;
					PointerEventData touchPointerEventData = GetTouchPointerEventData(touch, out pressed, out released);
					ProcessTouchPress(touchPointerEventData, pressed, released);
					if (!released)
					{
						ProcessMove(touchPointerEventData);
						ProcessDrag(touchPointerEventData);
					}
					else
					{
						RemovePointerData(touchPointerEventData);
					}
				}
			}
		}

		protected void ProcessTouchPress(PointerEventData pointerEvent, bool pressed, bool released)
		{
			GameObject gameObject = pointerEvent.pointerCurrentRaycast.gameObject;
			if (pressed)
			{
				pointerEvent.eligibleForClick = true;
				pointerEvent.delta = Vector2.zero;
				pointerEvent.dragging = false;
				pointerEvent.useDragThreshold = true;
				pointerEvent.pressPosition = pointerEvent.position;
				pointerEvent.pointerPressRaycast = pointerEvent.pointerCurrentRaycast;
				DeselectIfSelectionChanged(gameObject, pointerEvent);
				if (pointerEvent.pointerEnter != gameObject)
				{
					HandlePointerExitAndEnter(pointerEvent, gameObject);
					pointerEvent.pointerEnter = gameObject;
				}
				GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(gameObject, pointerEvent, ExecuteEvents.pointerDownHandler);
				if (gameObject2 == null)
				{
					gameObject2 = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				}
				float unscaledTime = Time.unscaledTime;
				if (gameObject2 == pointerEvent.lastPress)
				{
					if (unscaledTime - pointerEvent.clickTime < 0.3f)
					{
						int clickCount = pointerEvent.clickCount + 1;
						pointerEvent.clickCount = clickCount;
					}
					else
					{
						pointerEvent.clickCount = 1;
					}
					pointerEvent.clickTime = unscaledTime;
				}
				else
				{
					pointerEvent.clickCount = 1;
				}
				pointerEvent.pointerPress = gameObject2;
				pointerEvent.rawPointerPress = gameObject;
				pointerEvent.clickTime = unscaledTime;
				pointerEvent.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(gameObject);
				if (pointerEvent.pointerDrag != null)
				{
					ExecuteEvents.Execute(pointerEvent.pointerDrag, pointerEvent, ExecuteEvents.initializePotentialDrag);
				}
				m_InputPointerEvent = pointerEvent;
			}
			if (released)
			{
				ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerUpHandler);
				GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				if (pointerEvent.pointerPress == eventHandler && pointerEvent.eligibleForClick)
				{
					ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerClickHandler);
				}
				else if (pointerEvent.pointerDrag != null && pointerEvent.dragging)
				{
					ExecuteEvents.ExecuteHierarchy(gameObject, pointerEvent, ExecuteEvents.dropHandler);
				}
				pointerEvent.eligibleForClick = false;
				pointerEvent.pointerPress = null;
				pointerEvent.rawPointerPress = null;
				if (pointerEvent.pointerDrag != null && pointerEvent.dragging)
				{
					ExecuteEvents.Execute(pointerEvent.pointerDrag, pointerEvent, ExecuteEvents.endDragHandler);
				}
				pointerEvent.dragging = false;
				pointerEvent.pointerDrag = null;
				ExecuteEvents.ExecuteHierarchy(pointerEvent.pointerEnter, pointerEvent, ExecuteEvents.pointerExitHandler);
				pointerEvent.pointerEnter = null;
				m_InputPointerEvent = pointerEvent;
			}
		}

		public override void DeactivateModule()
		{
			base.DeactivateModule();
			ClearSelection();
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine(UseFakeInput() ? "Input: Faked" : "Input: Touch");
			if (UseFakeInput())
			{
				PointerEventData lastPointerEventData = GetLastPointerEventData(-1);
				if (lastPointerEventData != null)
				{
					stringBuilder.AppendLine(lastPointerEventData.ToString());
				}
			}
			else
			{
				foreach (KeyValuePair<int, PointerEventData> pointerDatum in m_PointerData)
				{
					stringBuilder.AppendLine(pointerDatum.ToString());
				}
			}
			return stringBuilder.ToString();
		}
	}
	public enum MoveDirection
	{
		Left,
		Up,
		Right,
		Down,
		None
	}
	internal static class RaycasterManager
	{
		private static readonly List<BaseRaycaster> s_Raycasters = new List<BaseRaycaster>();

		public static void AddRaycaster(BaseRaycaster baseRaycaster)
		{
			if (!s_Raycasters.Contains(baseRaycaster))
			{
				s_Raycasters.Add(baseRaycaster);
			}
		}

		public static List<BaseRaycaster> GetRaycasters()
		{
			return s_Raycasters;
		}

		public static void RemoveRaycasters(BaseRaycaster baseRaycaster)
		{
			if (s_Raycasters.Contains(baseRaycaster))
			{
				s_Raycasters.Remove(baseRaycaster);
			}
		}
	}
	public abstract class BaseRaycaster : UIBehaviour
	{
		private BaseRaycaster m_RootRaycaster;

		public abstract Camera eventCamera { get; }

		[Obsolete("Please use sortOrderPriority and renderOrderPriority", false)]
		public virtual int priority => 0;

		public virtual int sortOrderPriority => int.MinValue;

		public virtual int renderOrderPriority => int.MinValue;

		public BaseRaycaster rootRaycaster
		{
			get
			{
				if (m_RootRaycaster == null)
				{
					BaseRaycaster[] componentsInParent = GetComponentsInParent<BaseRaycaster>();
					if (componentsInParent.Length != 0)
					{
						m_RootRaycaster = componentsInParent[^1];
					}
				}
				return m_RootRaycaster;
			}
		}

		public abstract void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList);

		public override string ToString()
		{
			return "Name: " + base.gameObject?.ToString() + "\neventCamera: " + eventCamera?.ToString() + "\nsortOrderPriority: " + sortOrderPriority + "\nrenderOrderPriority: " + renderOrderPriority;
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			RaycasterManager.AddRaycaster(this);
		}

		protected override void OnDisable()
		{
			RaycasterManager.RemoveRaycasters(this);
			base.OnDisable();
		}

		protected override void OnCanvasHierarchyChanged()
		{
			base.OnCanvasHierarchyChanged();
			m_RootRaycaster = null;
		}

		protected override void OnTransformParentChanged()
		{
			base.OnTransformParentChanged();
			m_RootRaycaster = null;
		}
	}
	[AddComponentMenu("Event/Physics 2D Raycaster")]
	[RequireComponent(typeof(Camera))]
	public class Physics2DRaycaster : PhysicsRaycaster
	{
		private RaycastHit2D[] m_Hits;

		protected Physics2DRaycaster()
		{
		}

		public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
		{
			Ray ray = default(Ray);
			float distanceToClipPlane = 0f;
			if (!ComputeRayAndDistance(eventData, ref ray, ref distanceToClipPlane))
			{
				return;
			}
			int num = 0;
			if (base.maxRayIntersections == 0)
			{
				if (ReflectionMethodsCache.Singleton.getRayIntersectionAll == null)
				{
					return;
				}
				m_Hits = ReflectionMethodsCache.Singleton.getRayIntersectionAll(ray, distanceToClipPlane, base.finalEventMask);
				num = m_Hits.Length;
			}
			else
			{
				if (ReflectionMethodsCache.Singleton.getRayIntersectionAllNonAlloc == null)
				{
					return;
				}
				if (m_LastMaxRayIntersections != m_MaxRayIntersections)
				{
					m_Hits = new RaycastHit2D[base.maxRayIntersections];
					m_LastMaxRayIntersections = m_MaxRayIntersections;
				}
				num = ReflectionMethodsCache.Singleton.getRayIntersectionAllNonAlloc(ray, m_Hits, distanceToClipPlane, base.finalEventMask);
			}
			if (num != 0)
			{
				int i = 0;
				for (int num2 = num; i < num2; i++)
				{
					SpriteRenderer component = m_Hits[i].collider.gameObject.GetComponent<SpriteRenderer>();
					RaycastResult item = new RaycastResult
					{
						gameObject = m_Hits[i].collider.gameObject,
						module = this,
						distance = Vector3.Distance(eventCamera.transform.position, m_Hits[i].point),
						worldPosition = m_Hits[i].point,
						worldNormal = m_Hits[i].normal,
						screenPosition = eventData.position,
						index = resultAppendList.Count,
						sortingLayer = ((component != null) ? component.sortingLayerID : 0),
						sortingOrder = ((component != null) ? component.sortingOrder : 0)
					};
					resultAppendList.Add(item);
				}
			}
		}
	}
	[AddComponentMenu("Event/Physics Raycaster")]
	[RequireComponent(typeof(Camera))]
	public class PhysicsRaycaster : BaseRaycaster
	{
		private class RaycastHitComparer : IComparer<RaycastHit>
		{
			public static RaycastHitComparer instance = new RaycastHitComparer();

			public int Compare(RaycastHit x, RaycastHit y)
			{
				return x.distance.CompareTo(y.distance);
			}
		}

		protected const int kNoEventMaskSet = -1;

		protected Camera m_EventCamera;

		[SerializeField]
		protected LayerMask m_EventMask = -1;

		[SerializeField]
		protected int m_MaxRayIntersections;

		protected int m_LastMaxRayIntersections;

		private RaycastHit[] m_Hits;

		public override Camera eventCamera
		{
			get
			{
				if (m_EventCamera == null)
				{
					m_EventCamera = GetComponent<Camera>();
				}
				return m_EventCamera ?? Camera.main;
			}
		}

		public virtual int depth
		{
			get
			{
				if (!(eventCamera != null))
				{
					return 16777215;
				}
				return (int)eventCamera.depth;
			}
		}

		public int finalEventMask
		{
			get
			{
				if (!(eventCamera != null))
				{
					return -1;
				}
				return eventCamera.cullingMask & (int)m_EventMask;
			}
		}

		public LayerMask eventMask
		{
			get
			{
				return m_EventMask;
			}
			set
			{
				m_EventMask = value;
			}
		}

		public int maxRayIntersections
		{
			get
			{
				return m_MaxRayIntersections;
			}
			set
			{
				m_MaxRayIntersections = value;
			}
		}

		protected PhysicsRaycaster()
		{
		}

		protected bool ComputeRayAndDistance(PointerEventData eventData, ref Ray ray, ref float distanceToClipPlane)
		{
			if (eventCamera == null)
			{
				return false;
			}
			Vector3 vector = Display.RelativeMouseAt(eventData.position);
			if (vector != Vector3.zero)
			{
				if ((int)vector.z != eventCamera.targetDisplay)
				{
					return false;
				}
			}
			else
			{
				vector = eventData.position;
			}
			if (!eventCamera.pixelRect.Contains(vector))
			{
				return false;
			}
			ray = eventCamera.ScreenPointToRay(vector);
			float z = ray.direction.z;
			distanceToClipPlane = (Mathf.Approximately(0f, z) ? float.PositiveInfinity : Mathf.Abs((eventCamera.farClipPlane - eventCamera.nearClipPlane) / z));
			return true;
		}

		public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
		{
			Ray ray = default(Ray);
			float distanceToClipPlane = 0f;
			if (!ComputeRayAndDistance(eventData, ref ray, ref distanceToClipPlane))
			{
				return;
			}
			int num = 0;
			if (m_MaxRayIntersections == 0)
			{
				if (ReflectionMethodsCache.Singleton.raycast3DAll == null)
				{
					return;
				}
				m_Hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, finalEventMask);
				num = m_Hits.Length;
			}
			else
			{
				if (ReflectionMethodsCache.Singleton.getRaycastNonAlloc == null)
				{
					return;
				}
				if (m_LastMaxRayIntersections != m_MaxRayIntersections)
				{
					m_Hits = new RaycastHit[m_MaxRayIntersections];
					m_LastMaxRayIntersections = m_MaxRayIntersections;
				}
				num = ReflectionMethodsCache.Singleton.getRaycastNonAlloc(ray, m_Hits, distanceToClipPlane, finalEventMask);
			}
			if (num != 0)
			{
				if (num > 1)
				{
					Array.Sort(m_Hits, 0, num, RaycastHitComparer.instance);
				}
				int i = 0;
				for (int num2 = num; i < num2; i++)
				{
					RaycastResult item = new RaycastResult
					{
						gameObject = m_Hits[i].collider.gameObject,
						module = this,
						distance = m_Hits[i].distance,
						worldPosition = m_Hits[i].point,
						worldNormal = m_Hits[i].normal,
						screenPosition = eventData.position,
						index = resultAppendList.Count,
						sortingLayer = 0,
						sortingOrder = 0
					};
					resultAppendList.Add(item);
				}
			}
		}
	}
	public struct RaycastResult
	{
		private GameObject m_GameObject;

		public BaseRaycaster module;

		public float distance;

		public float index;

		public int depth;

		public int sortingLayer;

		public int sortingOrder;

		public Vector3 worldPosition;

		public Vector3 worldNormal;

		public Vector2 screenPosition;

		public GameObject gameObject
		{
			get
			{
				return m_GameObject;
			}
			set
			{
				m_GameObject = value;
			}
		}

		public bool isValid
		{
			get
			{
				if (module != null)
				{
					return gameObject != null;
				}
				return false;
			}
		}

		public void Clear()
		{
			gameObject = null;
			module = null;
			distance = 0f;
			index = 0f;
			depth = 0;
			sortingLayer = 0;
			sortingOrder = 0;
			worldNormal = Vector3.up;
			worldPosition = Vector3.zero;
			screenPosition = Vector2.zero;
		}

		public override string ToString()
		{
			if (!isValid)
			{
				return "";
			}
			string[] obj = new string[24]
			{
				"Name: ",
				gameObject?.ToString(),
				"\nmodule: ",
				module?.ToString(),
				"\ndistance: ",
				distance.ToString(),
				"\nindex: ",
				index.ToString(),
				"\ndepth: ",
				depth.ToString(),
				"\nworldNormal: ",
				null,
				null,
				null,
				null,
				null,
				null,
				null,
				null,
				null,
				null,
				null,
				null,
				null
			};
			Vector3 vector = worldNormal;
			obj[11] = vector.ToString();
			obj[12] = "\nworldPosition: ";
			vector = worldPosition;
			obj[13] = vector.ToString();
			obj[14] = "\nscreenPosition: ";
			Vector2 vector2 = screenPosition;
			obj[15] = vector2.ToString();
			obj[16] = "\nmodule.sortOrderPriority: ";
			obj[17] = module.sortOrderPriority.ToString();
			obj[18] = "\nmodule.renderOrderPriority: ";
			obj[19] = module.renderOrderPriority.ToString();
			obj[20] = "\nsortingLayer: ";
			obj[21] = sortingLayer.ToString();
			obj[22] = "\nsortingOrder: ";
			obj[23] = sortingOrder.ToString();
			return string.Concat(obj);
		}
	}
	public abstract class UIBehaviour : MonoBehaviour
	{
		protected virtual void Awake()
		{
		}

		protected virtual void OnEnable()
		{
		}

		protected virtual void Start()
		{
		}

		protected virtual void OnDisable()
		{
		}

		protected virtual void OnDestroy()
		{
		}

		public virtual bool IsActive()
		{
			return base.isActiveAndEnabled;
		}

		protected virtual void OnRectTransformDimensionsChange()
		{
		}

		protected virtual void OnBeforeTransformParentChanged()
		{
		}

		protected virtual void OnTransformParentChanged()
		{
		}

		protected virtual void OnDidApplyAnimationProperties()
		{
		}

		protected virtual void OnCanvasGroupChanged()
		{
		}

		protected virtual void OnCanvasHierarchyChanged()
		{
		}

		public bool IsDestroyed()
		{
			return this == null;
		}
	}
}
