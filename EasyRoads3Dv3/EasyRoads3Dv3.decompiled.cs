using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using UnityEngine;
using UnityEngine.Rendering;

[assembly: UnityAPICompatibilityVersion("2019.3.0f3", new string[] { "UnityEngine:AA14855DB712517357DDFDBA80949A28372E5F2C" })]
[assembly: AssemblyCompany("AndaSoft")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Guid("82025ffa-a302-445c-a95f-98b5746502e5")]
[assembly: ComVisible(false)]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCopyright("Copyright Â© AndaSoft 2009 - 2020")]
[assembly: AssemblyTitle("EasyRoads v3")]
[assembly: AssemblyDescription("RoadNetwork Creation for the Unity Engine")]
[assembly: AssemblyProduct("EasyRoads v3")]
[assembly: AssemblyConfiguration("")]
[assembly: CompilationRelaxations(8)]
[assembly: AssemblyVersion("1.0.0.0")]
[AddComponentMenu("")]
public class ERSurfaceScript : MonoBehaviour
{
	private void Start()
	{
	}
}
namespace EasyRoads3Dv3;

[AddComponentMenu("")]
public class OOQOQOODQC : MonoBehaviour
{
	public static void OCDCCCCCCQ(ERCrossings scr, QDOQDSQOOQDDD corner, List<List<Vector3>> sourceVecs, List<List<Vector2>> sourceUVs, List<List<int>> sourceTris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<List<int>> triList, int triArrayElement, int leftrightroad, bool hardEdge)
	{
		float num = 2.5f;
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		Vector3 vector;
		float y;
		if (!hardEdge)
		{
			Vector3 normalized = (sourceVecs[0][0] - sourceVecs[0][1]).normalized;
			vector = sourceVecs[0][0] + normalized * corner.curbDepth;
			list.Add(vector);
			list.Add(vector);
			float num2 = OQDDDOODCQ(sourceVecs[0][0], vector, num, sourceUVs[0][0].y, -1f);
			list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
			list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
			normalized = (sourceVecs[1][0] - sourceVecs[1][1]).normalized;
			vector = sourceVecs[1][0] + normalized * corner.curbDepth;
			list.Add(vector);
			list.Add(vector);
			list2.Add(new Vector2(corner.sidewalkUVs[1], num2));
			list2.Add(new Vector2(corner.sidewalkUVs[1], num2));
			list.Add(sourceVecs[2][0]);
			y = num2 - corner.curbDepth / num;
			list2.Add(new Vector2(corner.sidewalkUVs[2], y));
			vector = sourceVecs[3][0] + normalized * corner.curbDepth;
			list.Add(sourceVecs[3][0]);
			y = num2 - (corner.sidewalkWidth1 - corner.curbDepth) / num;
			list2.Add(new Vector2(corner.sidewalkUVs[2], y));
			normalized = (sourceVecs[4][0] - sourceVecs[4][1]).normalized;
			vector = sourceVecs[4][0] + normalized * corner.curbDepth;
			list.Add(vector);
			list.Add(vector);
			y = num2 - corner.sidewalkWidth1 / num;
			list2.Add(new Vector2(corner.sidewalkUVs[4], num2));
			list2.Add(new Vector2(corner.sidewalkUVs[1], y));
			vector.y = 0f;
			list.Add(vector);
			list.Add(vector);
			if (corner.outerCurb)
			{
				list2.Add(new Vector2(corner.sidewalkUVs[5], num2));
			}
			else
			{
				list2.Add(new Vector2(0f, num2));
			}
			list2.Add(new Vector2(corner.sidewalkUVs[0], y));
			if (scr != null)
			{
				scr.debugVecs.AddRange(list);
			}
			int count = vecs.Count;
			vecs.AddRange(list);
			uvs.AddRange(list2);
			if (leftrightroad == 0)
			{
				triList[triArrayElement].Add(sourceTris[0][0]);
				triList[triArrayElement].Add(count);
				triList[triArrayElement].Add(sourceTris[1][0]);
				triList[triArrayElement].Add(sourceTris[1][0]);
				triList[triArrayElement].Add(count);
				triList[triArrayElement].Add(count + 2);
				triList[triArrayElement].Add(count + 2);
				triList[triArrayElement].Add(sourceTris[2][0]);
				triList[triArrayElement].Add(sourceTris[1][0]);
				if (corner.outerCurb)
				{
					triList[triArrayElement].Add(sourceTris[5][0]);
					triList[triArrayElement].Add(sourceTris[4][0]);
					triList[triArrayElement].Add(count + 8);
					triList[triArrayElement].Add(sourceTris[4][0]);
					triList[triArrayElement].Add(count + 6);
					triList[triArrayElement].Add(count + 8);
				}
				triList[triArrayElement].Add(sourceTris[4][0]);
				triList[triArrayElement].Add(sourceTris[3][0]);
				triList[triArrayElement].Add(count + 6);
				triList[triArrayElement].Add(count + 1);
				triList[triArrayElement].Add(count + 9);
				triList[triArrayElement].Add(count + 7);
				triList[triArrayElement].Add(count + 1);
				triList[triArrayElement].Add(count + 7);
				triList[triArrayElement].Add(count + 3);
				triList[triArrayElement].Add(count + 3);
				triList[triArrayElement].Add(count + 7);
				triList[triArrayElement].Add(count + 5);
				triList[triArrayElement].Add(count + 3);
				triList[triArrayElement].Add(count + 5);
				triList[triArrayElement].Add(count + 4);
			}
			else
			{
				triList[triArrayElement].Add(sourceTris[0][0]);
				triList[triArrayElement].Add(sourceTris[1][0]);
				triList[triArrayElement].Add(count);
				triList[triArrayElement].Add(sourceTris[1][0]);
				triList[triArrayElement].Add(count + 2);
				triList[triArrayElement].Add(count);
				triList[triArrayElement].Add(count + 2);
				triList[triArrayElement].Add(sourceTris[1][0]);
				triList[triArrayElement].Add(sourceTris[2][0]);
				if (corner.outerCurb)
				{
					triList[triArrayElement].Add(sourceTris[5][0]);
					triList[triArrayElement].Add(count + 8);
					triList[triArrayElement].Add(sourceTris[4][0]);
					triList[triArrayElement].Add(sourceTris[4][0]);
					triList[triArrayElement].Add(count + 8);
					triList[triArrayElement].Add(count + 6);
				}
				triList[triArrayElement].Add(sourceTris[4][0]);
				triList[triArrayElement].Add(count + 6);
				triList[triArrayElement].Add(sourceTris[3][0]);
				triList[triArrayElement].Add(count + 1);
				triList[triArrayElement].Add(count + 7);
				triList[triArrayElement].Add(count + 9);
				triList[triArrayElement].Add(count + 1);
				triList[triArrayElement].Add(count + 3);
				triList[triArrayElement].Add(count + 7);
				triList[triArrayElement].Add(count + 3);
				triList[triArrayElement].Add(count + 5);
				triList[triArrayElement].Add(count + 7);
				triList[triArrayElement].Add(count + 3);
				triList[triArrayElement].Add(count + 4);
				triList[triArrayElement].Add(count + 5);
			}
			return;
		}
		Vector3 normalized2 = (sourceVecs[0][0] - sourceVecs[0][1]).normalized;
		vector = sourceVecs[0][0] + normalized2 * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		float num3 = OQDDDOODCQ(sourceVecs[0][0], vector, num, sourceUVs[0][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[0], num3));
		list2.Add(new Vector2(corner.sidewalkUVs[0], num3));
		normalized2 = (sourceVecs[1][0] - sourceVecs[1][1]).normalized;
		vector = sourceVecs[1][0] + normalized2 * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		list2.Add(new Vector2(corner.sidewalkUVs[1], num3));
		list2.Add(new Vector2(corner.sidewalkUVs[1], num3));
		list.Add(vector);
		list.Add(vector);
		list2.Add(new Vector2(corner.sidewalkUVs[1], num3));
		list2.Add(new Vector2(corner.sidewalkUVs[1], num3));
		list.Add(sourceVecs[2][0]);
		y = num3 - corner.curbDepth / num;
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		vector = sourceVecs[3][0] + normalized2 * corner.curbDepth;
		list.Add(sourceVecs[3][0]);
		y = num3 - (corner.sidewalkWidth1 - corner.curbDepth) / num;
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		normalized2 = (sourceVecs[4][0] - sourceVecs[4][1]).normalized;
		vector = sourceVecs[4][0] + normalized2 * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		y = num3 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[4], num3));
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		list.Add(vector);
		list.Add(vector);
		list2.Add(new Vector2(corner.sidewalkUVs[4], num3));
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		vector.y = 0f;
		list.Add(vector);
		list.Add(vector);
		if (corner.outerCurb)
		{
			list2.Add(new Vector2(corner.sidewalkUVs[5], num3));
		}
		else
		{
			list2.Add(new Vector2(0f, num3));
		}
		list2.Add(new Vector2(corner.sidewalkUVs[0], y));
		if (scr != null)
		{
			scr.debugVecs.AddRange(list);
		}
		int count2 = vecs.Count;
		vecs.AddRange(list);
		uvs.AddRange(list2);
		if (leftrightroad == 0)
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(count2);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count2);
			triList[triArrayElement].Add(count2 + 2);
			triList[triArrayElement].Add(count2 + 4);
			triList[triArrayElement].Add(sourceTris[3][0]);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(sourceTris[7][0]);
			triList[triArrayElement].Add(sourceTris[6][0]);
			triList[triArrayElement].Add(count2 + 12);
			triList[triArrayElement].Add(sourceTris[6][0]);
			triList[triArrayElement].Add(count2 + 10);
			triList[triArrayElement].Add(count2 + 12);
			triList[triArrayElement].Add(sourceTris[5][0]);
			triList[triArrayElement].Add(sourceTris[4][0]);
			triList[triArrayElement].Add(count2 + 8);
			triList[triArrayElement].Add(count2 + 1);
			triList[triArrayElement].Add(count2 + 13);
			triList[triArrayElement].Add(count2 + 11);
			triList[triArrayElement].Add(count2 + 1);
			triList[triArrayElement].Add(count2 + 11);
			triList[triArrayElement].Add(count2 + 3);
			triList[triArrayElement].Add(count2 + 6);
			triList[triArrayElement].Add(count2 + 4);
			triList[triArrayElement].Add(count2 + 9);
			triList[triArrayElement].Add(count2 + 6);
			triList[triArrayElement].Add(count2 + 9);
			triList[triArrayElement].Add(count2 + 7);
		}
		else
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count2);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count2 + 2);
			triList[triArrayElement].Add(count2);
			triList[triArrayElement].Add(count2 + 4);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(sourceTris[3][0]);
			triList[triArrayElement].Add(sourceTris[7][0]);
			triList[triArrayElement].Add(count2 + 12);
			triList[triArrayElement].Add(sourceTris[6][0]);
			triList[triArrayElement].Add(sourceTris[6][0]);
			triList[triArrayElement].Add(count2 + 12);
			triList[triArrayElement].Add(count2 + 10);
			triList[triArrayElement].Add(sourceTris[5][0]);
			triList[triArrayElement].Add(count2 + 8);
			triList[triArrayElement].Add(sourceTris[4][0]);
			triList[triArrayElement].Add(count2 + 1);
			triList[triArrayElement].Add(count2 + 11);
			triList[triArrayElement].Add(count2 + 13);
			triList[triArrayElement].Add(count2 + 1);
			triList[triArrayElement].Add(count2 + 3);
			triList[triArrayElement].Add(count2 + 11);
			triList[triArrayElement].Add(count2 + 6);
			triList[triArrayElement].Add(count2 + 9);
			triList[triArrayElement].Add(count2 + 4);
			triList[triArrayElement].Add(count2 + 6);
			triList[triArrayElement].Add(count2 + 7);
			triList[triArrayElement].Add(count2 + 9);
		}
	}

	public static void ODCQCQQQCQ(ERCrossings scr, QDOQDSQOOQDDD corner, List<List<Vector3>> sourceVecs, List<List<Vector2>> sourceUVs, List<List<int>> sourceTris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<List<int>> triList, int triArrayElement, int leftrightroad, bool hardEdge)
	{
		float num = 2.5f;
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		Vector3 normalized = (sourceVecs[0][0] - sourceVecs[0][1]).normalized;
		Vector3 vector = sourceVecs[0][0] + normalized * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		float num2 = OQDDDOODCQ(sourceVecs[0][0], vector, num, sourceUVs[0][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[corner.sidewalkUVs.Count - 1], num2));
		list2.Add(new Vector2(corner.sidewalkUVs[corner.sidewalkUVs.Count - 1], num2));
		normalized = (sourceVecs[1][0] - sourceVecs[1][1]).normalized;
		vector = sourceVecs[1][0] + normalized * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		list2.Add(new Vector2(corner.sidewalkUVs[corner.sidewalkUVs.Count - 2], num2));
		list2.Add(new Vector2(corner.sidewalkUVs[corner.sidewalkUVs.Count - 2], num2));
		normalized = (sourceVecs[2][0] - sourceVecs[2][1]).normalized;
		vector = sourceVecs[2][0] + normalized * (corner.curbDepth - corner.beveledDepth);
		list.Add(vector);
		list.Add(vector);
		float y = OQDDDOODCQ(sourceVecs[2][0], vector, num, sourceUVs[2][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[corner.sidewalkUVs.Count - 3], y));
		y = num2 - corner.beveledDepth / num;
		list2.Add(new Vector2(corner.sidewalkUVs[corner.sidewalkUVs.Count - 3], y));
		list.Add(sourceVecs[3][0]);
		y = num2 - corner.curbDepth / num;
		list2.Add(new Vector2(corner.sidewalkUVs[corner.sidewalkUVs.Count - 4], y));
		list.Add(sourceVecs[4][0]);
		y = num2 - (corner.sidewalkWidth1 - corner.curbDepth) / num;
		list2.Add(new Vector2(corner.sidewalkUVs[corner.sidewalkUVs.Count - 4], y));
		normalized = (sourceVecs[5][0] - sourceVecs[5][1]).normalized;
		vector = sourceVecs[5][0] + normalized * (corner.curbDepth - corner.beveledDepth);
		list.Add(vector);
		list.Add(vector);
		y = OQDDDOODCQ(sourceVecs[5][0], vector, num, sourceUVs[5][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		y = num2 - (corner.sidewalkWidth1 - corner.beveledDepth) / num;
		list2.Add(new Vector2(corner.sidewalkUVs[corner.sidewalkUVs.Count - 3], y));
		normalized = (sourceVecs[6][0] - sourceVecs[6][1]).normalized;
		vector = sourceVecs[6][0] + normalized * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		y = OQDDDOODCQ(sourceVecs[6][0], vector, num, sourceUVs[6][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		y = num2 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[corner.sidewalkUVs.Count - 2], y));
		normalized = (sourceVecs[7][0] - sourceVecs[7][1]).normalized;
		vector = sourceVecs[7][0] + normalized * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		y = OQDDDOODCQ(sourceVecs[7][0], vector, num, sourceUVs[7][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[0], y));
		y = num2 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[corner.sidewalkUVs.Count - 1], y));
		int count = vecs.Count;
		vecs.AddRange(list);
		uvs.AddRange(list2);
		if (leftrightroad == 0)
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(sourceTris[3][0]);
			triList[triArrayElement].Add(sourceTris[7][0]);
			triList[triArrayElement].Add(sourceTris[6][0]);
			triList[triArrayElement].Add(count + 12);
			triList[triArrayElement].Add(count + 12);
			triList[triArrayElement].Add(sourceTris[6][0]);
			triList[triArrayElement].Add(count + 10);
			triList[triArrayElement].Add(sourceTris[6][0]);
			triList[triArrayElement].Add(count + 8);
			triList[triArrayElement].Add(count + 10);
			triList[triArrayElement].Add(sourceTris[6][0]);
			triList[triArrayElement].Add(sourceTris[5][0]);
			triList[triArrayElement].Add(count + 8);
			triList[triArrayElement].Add(sourceTris[5][0]);
			triList[triArrayElement].Add(sourceTris[4][0]);
			triList[triArrayElement].Add(count + 8);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 13);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 13);
			triList[triArrayElement].Add(count + 11);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 11);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 11);
			triList[triArrayElement].Add(count + 9);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 9);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 6);
		}
		else
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(sourceTris[3][0]);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(sourceTris[7][0]);
			triList[triArrayElement].Add(count + 12);
			triList[triArrayElement].Add(sourceTris[6][0]);
			triList[triArrayElement].Add(count + 12);
			triList[triArrayElement].Add(count + 10);
			triList[triArrayElement].Add(sourceTris[6][0]);
			triList[triArrayElement].Add(sourceTris[6][0]);
			triList[triArrayElement].Add(count + 10);
			triList[triArrayElement].Add(count + 8);
			triList[triArrayElement].Add(sourceTris[6][0]);
			triList[triArrayElement].Add(count + 8);
			triList[triArrayElement].Add(sourceTris[5][0]);
			triList[triArrayElement].Add(sourceTris[5][0]);
			triList[triArrayElement].Add(count + 8);
			triList[triArrayElement].Add(sourceTris[4][0]);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 13);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 11);
			triList[triArrayElement].Add(count + 13);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 11);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 9);
			triList[triArrayElement].Add(count + 11);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 9);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 7);
		}
		if (scr != null)
		{
			scr.debugVecs.AddRange(list);
		}
	}

	public static void OQDDCCCQQQ(ERCrossings scr, QDOQDSQOOQDDD corner, List<List<Vector3>> sourceVecs, List<List<Vector2>> sourceUVs, List<List<int>> sourceTris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<List<int>> triList, int triArrayElement, int leftrightroad, bool hardEdge)
	{
		float num = 2.5f;
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		Vector3 normalized = (sourceVecs[0][0] - sourceVecs[0][1]).normalized;
		Vector3 vector = sourceVecs[0][0] + normalized * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		float num2 = OQDDDOODCQ(sourceVecs[0][0], vector, num, sourceUVs[0][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
		list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
		normalized = (sourceVecs[1][0] - sourceVecs[1][1]).normalized;
		vector = sourceVecs[1][0] + normalized * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		list2.Add(new Vector2(corner.sidewalkUVs[1], num2));
		list2.Add(new Vector2(corner.sidewalkUVs[1], num2));
		list.Add(sourceVecs[2][0]);
		float y = num2 - corner.curbDepth / num;
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		vector = sourceVecs[3][0] + normalized * corner.curbDepth;
		list.Add(sourceVecs[3][0]);
		y = num2 - (corner.sidewalkWidth1 - corner.curbDepth) / num;
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		normalized = (sourceVecs[4][0] - sourceVecs[4][1]).normalized;
		vector = sourceVecs[4][0] + normalized * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		y = num2 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[4], num2));
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		vector.y = 0f;
		list.Add(vector);
		list.Add(vector);
		list2.Add(new Vector2(corner.sidewalkUVs[5], num2));
		list2.Add(new Vector2(corner.sidewalkUVs[0], y));
		if (scr != null)
		{
			scr.debugVecs.AddRange(list);
		}
		int count = vecs.Count;
		vecs.AddRange(list);
		uvs.AddRange(list2);
		if (leftrightroad == 0)
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			if (corner.outerCurb)
			{
				triList[triArrayElement].Add(sourceTris[5][0]);
				triList[triArrayElement].Add(sourceTris[4][0]);
				triList[triArrayElement].Add(count + 8);
				triList[triArrayElement].Add(sourceTris[4][0]);
				triList[triArrayElement].Add(count + 6);
				triList[triArrayElement].Add(count + 8);
			}
			triList[triArrayElement].Add(sourceTris[4][0]);
			triList[triArrayElement].Add(sourceTris[3][0]);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 9);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 4);
		}
		else
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(sourceTris[2][0]);
			if (corner.outerCurb)
			{
				triList[triArrayElement].Add(sourceTris[5][0]);
				triList[triArrayElement].Add(count + 8);
				triList[triArrayElement].Add(sourceTris[4][0]);
				triList[triArrayElement].Add(sourceTris[4][0]);
				triList[triArrayElement].Add(count + 8);
				triList[triArrayElement].Add(count + 6);
			}
			triList[triArrayElement].Add(sourceTris[4][0]);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(sourceTris[3][0]);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 9);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(count + 5);
		}
	}

	public static void OODCCQQDOO(ERCrossings scr, QDOQDSQOOQDDD corner, List<List<Vector3>> sourceVecs, List<List<Vector2>> sourceUVs, List<List<int>> sourceTris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<List<int>> triList, int triArrayElement, int leftrightroad, bool hardEdge)
	{
		float num = 2.5f;
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		Vector3 normalized = (sourceVecs[0][0] - sourceVecs[0][1]).normalized;
		Vector3 vector = sourceVecs[0][0] + normalized * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		float num2 = OQDDDOODCQ(sourceVecs[0][0], vector, num, sourceUVs[0][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
		list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
		normalized = (sourceVecs[1][0] - sourceVecs[1][1]).normalized;
		vector = sourceVecs[1][0] + normalized * (corner.curbDepth - corner.beveledDepth);
		list.Add(vector);
		list.Add(vector);
		float y = OQDDDOODCQ(sourceVecs[1][0], vector, num, sourceUVs[1][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		y = num2 - corner.beveledDepth / num;
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		list.Add(sourceVecs[2][0]);
		y = num2 - corner.curbDepth / num;
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		vector = sourceVecs[3][0] + normalized * corner.curbDepth;
		list.Add(sourceVecs[3][0]);
		y = num2 - (corner.sidewalkWidth1 - corner.curbDepth) / num;
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		normalized = (sourceVecs[4][0] - sourceVecs[4][1]).normalized;
		vector = sourceVecs[4][0] + normalized * (corner.curbDepth - corner.beveledDepth);
		list.Add(vector);
		list.Add(vector);
		y = OQDDDOODCQ(sourceVecs[4][0], vector, num, sourceUVs[4][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[4], y));
		y = num2 - (corner.sidewalkWidth1 - corner.beveledDepth) / num;
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		normalized = (sourceVecs[5][0] - sourceVecs[5][1]).normalized;
		vector = sourceVecs[5][0] + normalized * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		list2.Add(new Vector2(corner.sidewalkUVs[5], num2));
		y = num2 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[0], y));
		if (scr != null)
		{
			scr.debugVecs.AddRange(list);
		}
		int count = vecs.Count;
		vecs.AddRange(list);
		uvs.AddRange(list2);
		if (leftrightroad == 0)
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			if (corner.outerCurb)
			{
				triList[triArrayElement].Add(sourceTris[5][0]);
				triList[triArrayElement].Add(sourceTris[4][0]);
				triList[triArrayElement].Add(count + 8);
				triList[triArrayElement].Add(sourceTris[4][0]);
				triList[triArrayElement].Add(count + 6);
				triList[triArrayElement].Add(count + 8);
			}
			triList[triArrayElement].Add(sourceTris[4][0]);
			triList[triArrayElement].Add(sourceTris[3][0]);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 9);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 4);
		}
		else
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(sourceTris[2][0]);
			if (corner.outerCurb)
			{
				triList[triArrayElement].Add(sourceTris[5][0]);
				triList[triArrayElement].Add(count + 8);
				triList[triArrayElement].Add(sourceTris[4][0]);
				triList[triArrayElement].Add(sourceTris[4][0]);
				triList[triArrayElement].Add(count + 8);
				triList[triArrayElement].Add(count + 6);
			}
			triList[triArrayElement].Add(sourceTris[4][0]);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(sourceTris[3][0]);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 9);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(count + 5);
		}
	}

	public static void OQCDQQODOD(ERCrossings scr, QDOQDSQOOQDDD corner, List<List<Vector3>> sourceVecs, List<List<Vector2>> sourceUVs, List<List<int>> sourceTris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<List<int>> triList, int triArrayElement, int leftrightroad, bool hardEdge)
	{
		float num = 2.5f;
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		Vector3 normalized = (sourceVecs[0][0] - sourceVecs[0][1]).normalized;
		Vector3 vector = sourceVecs[0][0] + normalized * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		float num2 = OQDDDOODCQ(sourceVecs[0][0], vector, num, sourceUVs[0][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
		list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
		Vector3 vector2 = sourceVecs[sourceVecs.Count - 1][0];
		vector2.y = 0f;
		normalized = (vector2 - sourceVecs[0][0]).normalized;
		Vector3 item = vector + normalized * corner.sidewalkWidth1;
		list.Add(item);
		list.Add(item);
		list2.Add(new Vector2(corner.sidewalkUVs[3], num2));
		float y = num2 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[0], y));
		list.Add(sourceVecs[1][0]);
		y = num2 - corner.curbDepth / num;
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		list.Add(sourceVecs[2][0]);
		y = num2 - (corner.sidewalkWidth1 - corner.curbDepth) / num;
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		if (scr != null)
		{
			scr.debugVecs.AddRange(list);
		}
		int count = vecs.Count;
		vecs.AddRange(list);
		uvs.AddRange(list2);
		if (leftrightroad == 0)
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(sourceTris[3][0]);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 4);
		}
		else
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[3][0]);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(count + 5);
		}
	}

	public static void OCQDQCQDCC(ERCrossings scr, QDOQDSQOOQDDD corner, List<List<Vector3>> sourceVecs, List<List<Vector2>> sourceUVs, List<List<int>> sourceTris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<List<int>> triList, int triArrayElement, int leftrightroad, int startEnd, bool hardEdge)
	{
		float num = 2.5f;
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		int num2 = 0;
		Vector3 vector;
		Vector3 vector2;
		Vector3 normalized;
		Vector3 vector3;
		float y;
		if (!hardEdge)
		{
			if (startEnd == 0)
			{
				vector = sourceVecs[0][0];
				vector2 = sourceVecs[0][1];
			}
			else
			{
				vector = sourceVecs[0][sourceVecs[0].Count - 1];
				vector2 = sourceVecs[0][sourceVecs[0].Count - 2];
			}
			normalized = (vector - vector2).normalized;
			vector3 = vector + normalized * corner.curbDepth;
			list.Add(vector3);
			list.Add(vector3);
			float num3 = OQDDDOODCQ(vector, vector3, num, vector.y, -1f);
			list2.Add(new Vector2(corner.sidewalkUVs[0], num3));
			list2.Add(new Vector2(corner.sidewalkUVs[0], num3));
			if (startEnd == 0)
			{
				vector = sourceVecs[1][0];
				vector2 = sourceVecs[1][1];
			}
			else
			{
				vector = sourceVecs[1][sourceVecs[1].Count - 1];
				vector2 = sourceVecs[1][sourceVecs[1].Count - 2];
			}
			normalized = (vector - vector2).normalized;
			vector3 = vector + normalized * corner.curbDepth;
			list.Add(vector3);
			list.Add(vector3);
			list2.Add(new Vector2(corner.sidewalkUVs[1], num3));
			list2.Add(new Vector2(corner.sidewalkUVs[1], num3));
			vector = ((startEnd != 0) ? sourceVecs[2][sourceVecs[2].Count - 1] : sourceVecs[2][0]);
			list.Add(vector);
			y = num3 - corner.curbDepth / num;
			list2.Add(new Vector2(corner.sidewalkUVs[2], y));
			vector = ((startEnd != 0) ? sourceVecs[3][sourceVecs[3].Count - 1] : sourceVecs[3][0]);
			vector3 = vector + normalized * corner.curbDepth;
			list.Add(vector);
			y = num3 - (corner.sidewalkWidth1 - corner.curbDepth) / num;
			list2.Add(new Vector2(corner.sidewalkUVs[2], y));
			if (startEnd == 0)
			{
				vector = sourceVecs[4][0];
				vector2 = sourceVecs[4][1];
			}
			else
			{
				vector = sourceVecs[4][sourceVecs[4].Count - 1];
				vector2 = sourceVecs[4][sourceVecs[4].Count - 2];
			}
			normalized = (vector - vector2).normalized;
			vector3 = vector;
			list.Add(vector3);
			y = num3 - corner.sidewalkWidth1 / num;
			list2.Add(new Vector2(corner.sidewalkUVs[2], y));
			normalized = (vector - vector2).normalized;
			vector3 = vector + normalized * corner.curbDepth;
			list.Add(vector3);
			list2.Add(new Vector2(corner.sidewalkUVs[1], y));
			vector3.y = 0f;
			list.Add(vector3);
			list2.Add(new Vector2(corner.sidewalkUVs[0], y));
			if (scr != null)
			{
				scr.debugVecs.AddRange(list);
			}
			int count = vecs.Count;
			vecs.AddRange(list);
			uvs.AddRange(list2);
			if ((leftrightroad == 0 && startEnd == 0) || (leftrightroad == 1 && startEnd == 1))
			{
				triList[triArrayElement].Add(sourceTris[0][0]);
				triList[triArrayElement].Add(count);
				triList[triArrayElement].Add(sourceTris[1][0]);
				triList[triArrayElement].Add(sourceTris[1][0]);
				triList[triArrayElement].Add(count);
				triList[triArrayElement].Add(count + 2);
				triList[triArrayElement].Add(count + 2);
				triList[triArrayElement].Add(sourceTris[2][0]);
				triList[triArrayElement].Add(sourceTris[1][0]);
				triList[triArrayElement].Add(count + 1);
				triList[triArrayElement].Add(count + 8);
				triList[triArrayElement].Add(count + 7);
				triList[triArrayElement].Add(count + 1);
				triList[triArrayElement].Add(count + 7);
				triList[triArrayElement].Add(count + 3);
				triList[triArrayElement].Add(count + 3);
				triList[triArrayElement].Add(count + 7);
				triList[triArrayElement].Add(count + 5);
				triList[triArrayElement].Add(count + 3);
				triList[triArrayElement].Add(count + 5);
				triList[triArrayElement].Add(count + 4);
				triList[triArrayElement].Add(count + 5);
				triList[triArrayElement].Add(count + 7);
				triList[triArrayElement].Add(count + 6);
			}
			else
			{
				triList[triArrayElement].Add(sourceTris[0][0]);
				triList[triArrayElement].Add(sourceTris[1][0]);
				triList[triArrayElement].Add(count);
				triList[triArrayElement].Add(sourceTris[1][0]);
				triList[triArrayElement].Add(count + 2);
				triList[triArrayElement].Add(count);
				triList[triArrayElement].Add(count + 2);
				triList[triArrayElement].Add(sourceTris[1][0]);
				triList[triArrayElement].Add(sourceTris[2][0]);
				triList[triArrayElement].Add(count + 1);
				triList[triArrayElement].Add(count + 7);
				triList[triArrayElement].Add(count + 8);
				triList[triArrayElement].Add(count + 1);
				triList[triArrayElement].Add(count + 3);
				triList[triArrayElement].Add(count + 7);
				triList[triArrayElement].Add(count + 3);
				triList[triArrayElement].Add(count + 5);
				triList[triArrayElement].Add(count + 7);
				triList[triArrayElement].Add(count + 3);
				triList[triArrayElement].Add(count + 4);
				triList[triArrayElement].Add(count + 5);
				triList[triArrayElement].Add(count + 5);
				triList[triArrayElement].Add(count + 6);
				triList[triArrayElement].Add(count + 7);
			}
			return;
		}
		if (startEnd == 0)
		{
			vector = sourceVecs[0][0];
			vector2 = sourceVecs[0][1];
			num2 = 0;
		}
		else
		{
			vector = sourceVecs[0][sourceVecs[0].Count - 1];
			vector2 = sourceVecs[0][sourceVecs[0].Count - 2];
			num2 = 1;
		}
		float y2 = vector.y;
		float num4 = ((startEnd != 0) ? (sourceVecs[1][sourceVecs[1].Count - 1].y - sourceVecs[0][sourceVecs[0].Count - 1].y) : (sourceVecs[1][0].y - sourceVecs[0][0].y));
		float num5 = 0f;
		normalized = (vector - vector2).normalized;
		vector3 = vector + normalized * corner.curbDepth;
		list.Add(vector3);
		list.Add(vector3);
		num5 = ((startEnd != 0) ? OQDDDOODCQ(vector, vector3, num, sourceUVs[0][sourceVecs[0].Count - 1].y, 1f) : OQDDDOODCQ(vector, vector3, num, sourceUVs[0][0].y, -1f));
		list2.Add(new Vector2(corner.sidewalkUVs[0], num5));
		list2.Add(new Vector2(corner.sidewalkUVs[0], num5));
		if (startEnd == 0)
		{
			vector = sourceVecs[1][0];
			vector2 = sourceVecs[1][1];
		}
		else
		{
			vector = sourceVecs[1][sourceVecs[1].Count - 1];
			vector2 = sourceVecs[1][sourceVecs[1].Count - 2];
		}
		normalized = (vector - vector2).normalized;
		vector3 = vector + normalized * corner.curbDepth;
		list.Add(vector3);
		list.Add(vector3);
		list2.Add(new Vector2(corner.sidewalkUVs[1], num5));
		list2.Add(new Vector2(corner.sidewalkUVs[1], num5));
		list.Add(vector3);
		list.Add(vector3);
		list2.Add(new Vector2(corner.sidewalkUVs[1], num5));
		list2.Add(new Vector2(corner.sidewalkUVs[1], num5));
		vector = ((startEnd != 0) ? sourceVecs[2][sourceVecs[2].Count - 1] : sourceVecs[2][0]);
		list.Add(vector);
		y = num5 - corner.curbDepth / num;
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		if (startEnd == 0)
		{
			vector = sourceVecs[3][0];
		}
		else
		{
			vector = sourceVecs[3][sourceVecs[3].Count - 1];
		}
		vector3 = sourceVecs[3][0] + normalized * corner.curbDepth;
		if (startEnd == 0)
		{
			list.Add(sourceVecs[3][0]);
		}
		else
		{
			list.Add(sourceVecs[3][sourceVecs[3].Count - 1]);
		}
		y = num5 - (corner.sidewalkWidth1 - corner.curbDepth) / num;
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		if (startEnd == 0)
		{
			vector = sourceVecs[4][0];
			vector2 = sourceVecs[4][1];
		}
		else
		{
			vector = sourceVecs[4][sourceVecs[4].Count - 1];
			vector2 = sourceVecs[4][sourceVecs[4].Count - 2];
		}
		normalized = (vector - vector2).normalized;
		vector3 = vector + normalized * corner.curbDepth;
		list.Add(vector3);
		list.Add(vector3);
		y = num5 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[4], num5));
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		list.Add(vector3);
		list.Add(vector3);
		list2.Add(new Vector2(corner.sidewalkUVs[4], num5));
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		vector3.y -= num4;
		list.Add(vector3);
		list.Add(vector3);
		if (corner.outerCurb)
		{
			list2.Add(new Vector2(corner.sidewalkUVs[4], num5));
		}
		else
		{
			list2.Add(new Vector2(0f, num5));
		}
		list2.Add(new Vector2(corner.sidewalkUVs[0], y));
		if (scr != null)
		{
			scr.debugVecs.AddRange(list);
		}
		int count2 = vecs.Count;
		vecs.AddRange(list);
		uvs.AddRange(list2);
		if ((leftrightroad == 0 && startEnd == 0) || (leftrightroad == 1 && startEnd == 1))
		{
			triList[triArrayElement].Add(sourceTris[0][num2]);
			triList[triArrayElement].Add(count2);
			triList[triArrayElement].Add(sourceTris[1][num2]);
			triList[triArrayElement].Add(sourceTris[1][num2]);
			triList[triArrayElement].Add(count2);
			triList[triArrayElement].Add(count2 + 2);
			triList[triArrayElement].Add(count2 + 4);
			triList[triArrayElement].Add(sourceTris[3][num2]);
			triList[triArrayElement].Add(sourceTris[2][num2]);
			triList[triArrayElement].Add(sourceTris[5][num2]);
			triList[triArrayElement].Add(sourceTris[4][num2]);
			triList[triArrayElement].Add(count2 + 8);
			triList[triArrayElement].Add(count2 + 1);
			triList[triArrayElement].Add(count2 + 13);
			triList[triArrayElement].Add(count2 + 11);
			triList[triArrayElement].Add(count2 + 1);
			triList[triArrayElement].Add(count2 + 11);
			triList[triArrayElement].Add(count2 + 3);
			triList[triArrayElement].Add(count2 + 6);
			triList[triArrayElement].Add(count2 + 4);
			triList[triArrayElement].Add(count2 + 9);
			triList[triArrayElement].Add(count2 + 6);
			triList[triArrayElement].Add(count2 + 9);
			triList[triArrayElement].Add(count2 + 7);
		}
		else
		{
			triList[triArrayElement].Add(sourceTris[0][num2]);
			triList[triArrayElement].Add(sourceTris[1][num2]);
			triList[triArrayElement].Add(count2);
			triList[triArrayElement].Add(sourceTris[1][num2]);
			triList[triArrayElement].Add(count2 + 2);
			triList[triArrayElement].Add(count2);
			triList[triArrayElement].Add(count2 + 4);
			triList[triArrayElement].Add(sourceTris[2][num2]);
			triList[triArrayElement].Add(sourceTris[3][num2]);
			triList[triArrayElement].Add(sourceTris[5][num2]);
			triList[triArrayElement].Add(count2 + 8);
			triList[triArrayElement].Add(sourceTris[4][num2]);
			triList[triArrayElement].Add(count2 + 1);
			triList[triArrayElement].Add(count2 + 11);
			triList[triArrayElement].Add(count2 + 13);
			triList[triArrayElement].Add(count2 + 1);
			triList[triArrayElement].Add(count2 + 3);
			triList[triArrayElement].Add(count2 + 11);
			triList[triArrayElement].Add(count2 + 6);
			triList[triArrayElement].Add(count2 + 9);
			triList[triArrayElement].Add(count2 + 4);
			triList[triArrayElement].Add(count2 + 6);
			triList[triArrayElement].Add(count2 + 7);
			triList[triArrayElement].Add(count2 + 9);
		}
	}

	public static void ODOODOCDOD(ERCrossings scr, QDOQDSQOOQDDD corner, List<List<Vector3>> sourceVecs, List<List<Vector2>> sourceUVs, List<List<int>> sourceTris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<List<int>> triList, int triArrayElement, int leftrightroad, bool hardEdge)
	{
		float num = 2.5f;
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		Vector3 normalized = (sourceVecs[0][0] - sourceVecs[0][1]).normalized;
		Vector3 vector = sourceVecs[0][0] + normalized * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		float num2 = OQDDDOODCQ(sourceVecs[0][0], vector, num, sourceUVs[0][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
		list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
		normalized = (sourceVecs[1][0] - sourceVecs[1][1]).normalized;
		vector = sourceVecs[1][0] + normalized * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		list2.Add(new Vector2(corner.sidewalkUVs[1], num2));
		list2.Add(new Vector2(corner.sidewalkUVs[1], num2));
		normalized = (sourceVecs[2][0] - sourceVecs[2][1]).normalized;
		vector = sourceVecs[2][0] + normalized * (corner.curbDepth - corner.beveledDepth);
		list.Add(vector);
		list.Add(vector);
		float y = OQDDDOODCQ(sourceVecs[2][0], vector, num, sourceUVs[2][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		y = num2 - corner.beveledDepth / num;
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		list.Add(sourceVecs[3][0]);
		y = num2 - corner.curbDepth / num;
		list2.Add(new Vector2(corner.sidewalkUVs[3], y));
		list.Add(sourceVecs[4][0]);
		y = num2 - (corner.sidewalkWidth1 - corner.curbDepth) / num;
		list2.Add(new Vector2(corner.sidewalkUVs[3], y));
		list.Add(sourceVecs[5][0]);
		y = num2 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[3], y));
		normalized = (sourceVecs[5][0] - sourceVecs[5][1]).normalized;
		vector = sourceVecs[5][0] + normalized * (corner.curbDepth - corner.beveledDepth);
		list.Add(vector);
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		normalized = (sourceVecs[5][0] - sourceVecs[5][1]).normalized;
		vector = sourceVecs[5][0] + normalized * corner.curbDepth;
		vector.y = corner.beveledHeight;
		list.Add(vector);
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		vector.y = 0f;
		list.Add(vector);
		y = num2 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[0], y));
		int count = vecs.Count;
		vecs.AddRange(list);
		uvs.AddRange(list2);
		if (leftrightroad == 0)
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(sourceTris[3][0]);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 11);
			triList[triArrayElement].Add(count + 10);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 10);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 10);
			triList[triArrayElement].Add(count + 9);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 9);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 9);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 9);
			triList[triArrayElement].Add(count + 8);
		}
		else
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(sourceTris[3][0]);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 10);
			triList[triArrayElement].Add(count + 11);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 10);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 9);
			triList[triArrayElement].Add(count + 10);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 9);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 9);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 8);
			triList[triArrayElement].Add(count + 9);
		}
		if (scr != null)
		{
			scr.debugVecs.AddRange(list);
		}
	}

	public static void OODDQQQDDQ(ERCrossings scr, QDOQDSQOOQDDD corner, List<List<Vector3>> sourceVecs, List<List<Vector2>> sourceUVs, List<List<int>> sourceTris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<List<int>> triList, int triArrayElement, int leftrightroad, bool hardEdge)
	{
		float num = 2.5f;
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		Vector3 normalized = (sourceVecs[0][0] - sourceVecs[0][1]).normalized;
		Vector3 vector = sourceVecs[0][0] + normalized * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		float num2 = OQDDDOODCQ(sourceVecs[0][0], vector, num, sourceUVs[0][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
		list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
		normalized = (sourceVecs[1][0] - sourceVecs[1][1]).normalized;
		vector = sourceVecs[1][0] + normalized * (corner.curbDepth - corner.beveledDepth);
		list.Add(vector);
		list.Add(vector);
		float y = OQDDDOODCQ(sourceVecs[1][0], vector, num, sourceUVs[1][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		y = num2 - corner.beveledDepth / num;
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		list.Add(sourceVecs[2][0]);
		y = num2 - corner.curbDepth / num;
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		vector = sourceVecs[3][0] + normalized * corner.curbDepth;
		list.Add(sourceVecs[3][0]);
		y = num2 - (corner.sidewalkWidth1 - corner.curbDepth) / num;
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		normalized = (sourceVecs[4][0] - sourceVecs[4][1]).normalized;
		vector = sourceVecs[4][0] + normalized * corner.curbDepth;
		vector.y = corner.beveledHeight;
		list.Add(vector);
		y = num2 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		normalized = (sourceVecs[4][0] - sourceVecs[4][1]).normalized;
		vector = sourceVecs[4][0] + normalized * corner.curbDepth;
		vector.y = 0f;
		list.Add(vector);
		y = num2 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[0], y));
		vector = sourceVecs[4][0];
		list.Add(vector);
		y = num2 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		if (scr != null)
		{
			scr.debugVecs.AddRange(list);
		}
		int count = vecs.Count;
		vecs.AddRange(list);
		uvs.AddRange(list2);
		if (leftrightroad == 0)
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 8);
		}
		else
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 8);
			triList[triArrayElement].Add(count + 6);
		}
	}

	public static void OCCDCDCODO(ERCrossings scr, QDOQDSQOOQDDD corner, List<List<Vector3>> sourceVecs, List<List<Vector2>> sourceUVs, List<List<int>> sourceTris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<List<int>> triList, int triArrayElement, int leftrightroad, bool hardEdge)
	{
		float num = 2.5f;
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		Vector3 normalized = (sourceVecs[0][0] - sourceVecs[0][1]).normalized;
		Vector3 vector = sourceVecs[0][0] + normalized * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		float num2 = OQDDDOODCQ(sourceVecs[0][0], vector, num, sourceUVs[0][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
		list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
		normalized = (sourceVecs[1][0] - sourceVecs[1][1]).normalized;
		vector = sourceVecs[1][0] + normalized * (corner.curbDepth - corner.beveledDepth);
		list.Add(vector);
		list.Add(vector);
		float y = OQDDDOODCQ(sourceVecs[1][0], vector, num, sourceUVs[1][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		y = num2 - corner.beveledDepth / num;
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		list.Add(sourceVecs[2][0]);
		y = num2 - corner.curbDepth / num;
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		vector = sourceVecs[3][0] + normalized * corner.curbDepth;
		list.Add(sourceVecs[3][0]);
		y = num2 - (corner.sidewalkWidth1 - corner.curbDepth) / num;
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		normalized = (sourceVecs[4][0] - sourceVecs[4][1]).normalized;
		vector = sourceVecs[4][0] + normalized * (corner.curbDepth - corner.beveledDepth);
		list.Add(vector);
		y = num2 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		normalized = (sourceVecs[4][0] - sourceVecs[4][1]).normalized;
		vector = sourceVecs[4][0] + normalized * corner.curbDepth;
		vector.y = 0f;
		list.Add(vector);
		y = num2 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[0], y));
		vector = sourceVecs[4][0];
		list.Add(vector);
		y = num2 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[2], y));
		if (scr != null)
		{
			scr.debugVecs.AddRange(list);
		}
		int count = vecs.Count;
		vecs.AddRange(list);
		uvs.AddRange(list2);
		if (leftrightroad == 0)
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 8);
		}
		else
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(sourceTris[2][0]);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 7);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 6);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 8);
			triList[triArrayElement].Add(count + 6);
		}
	}

	public static void ODOQCDCCOQ(ERCrossings scr, QDOQDSQOOQDDD corner, List<List<Vector3>> sourceVecs, List<List<Vector2>> sourceUVs, List<List<int>> sourceTris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<List<int>> triList, int triArrayElement, int leftrightroad, bool hardEdge)
	{
		float num = 2.5f;
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		Vector3 normalized = (sourceVecs[0][0] - sourceVecs[0][1]).normalized;
		Vector3 vector = sourceVecs[0][0] + normalized * corner.curbDepth;
		list.Add(vector);
		list.Add(vector);
		float num2 = OQDDDOODCQ(sourceVecs[0][0], vector, num, sourceUVs[0][0].y, -1f);
		list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
		list2.Add(new Vector2(corner.sidewalkUVs[0], num2));
		Vector3 vector2 = sourceVecs[sourceVecs.Count - 1][0];
		vector2.y = 0f;
		normalized = (vector2 - sourceVecs[0][0]).normalized;
		Vector3 item = vector + normalized * corner.sidewalkWidth1;
		list.Add(item);
		float y = num2 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[0], y));
		list.Add(sourceVecs[1][0]);
		y = num2 - corner.curbDepth / num;
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		list.Add(sourceVecs[2][0]);
		y = num2 - (corner.sidewalkWidth1 - corner.curbDepth) / num;
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		list.Add(sourceVecs[3][0]);
		y = num2 - corner.sidewalkWidth1 / num;
		list2.Add(new Vector2(corner.sidewalkUVs[1], y));
		if (scr != null)
		{
			scr.debugVecs.AddRange(list);
		}
		int count = vecs.Count;
		vecs.AddRange(list);
		uvs.AddRange(list2);
		if (leftrightroad == 0)
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count + 5);
			triList[triArrayElement].Add(count + 4);
		}
		else
		{
			triList[triArrayElement].Add(sourceTris[0][0]);
			triList[triArrayElement].Add(sourceTris[1][0]);
			triList[triArrayElement].Add(count);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count + 1);
			triList[triArrayElement].Add(count + 3);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(count + 2);
			triList[triArrayElement].Add(count + 4);
			triList[triArrayElement].Add(count + 5);
		}
	}

	public static float OQDDDOODCQ(Vector3 v1, Vector3 v2, float uvRatio, float startUV, float dir)
	{
		float num = Vector3.Distance(v1, v2);
		return startUV + dir * num / uvRatio;
	}
}
[AddComponentMenu("")]
public class ERCrossings : MonoBehaviour
{
	[Serializable]
	[CompilerGenerated]
	private sealed class á
	{
		public static readonly á <>9 = new á();

		public static Comparison<ERConnectionSibling> <>9__203_0;

		internal int <OQDOOCDOCD>b__203_0(ERConnectionSibling x, ERConnectionSibling y)
		{
			return x.angle.CompareTo(y.angle);
		}
	}

	[SerializeField]
	public ERConnectionData cdata;

	public List<List<Vector3>> startConnectionV3 = new List<List<Vector3>>();

	public List<List<Vector3>> endConnectionV3 = new List<List<Vector3>>();

	public List<List<Vector3>> leftConnectionV3 = new List<List<Vector3>>();

	public List<List<Vector3>> rightConnectionV3 = new List<List<Vector3>>();

	public List<List<Vector2>> startConnectionUV = new List<List<Vector2>>();

	public List<List<Vector2>> endConnectionUV = new List<List<Vector2>>();

	public List<List<Vector2>> leftConnectionUV = new List<List<Vector2>>();

	public List<List<Vector2>> rightConnectionUV = new List<List<Vector2>>();

	public List<List<int>> startConnectionTris = new List<List<int>>();

	public List<List<int>> endConnectionTris = new List<List<int>>();

	public List<List<int>> leftConnectionTris = new List<List<int>>();

	public List<List<int>> rightConnectionTris = new List<List<int>>();

	public List<List<Vector3>> leftSidewalkStartV3 = new List<List<Vector3>>();

	public List<List<Vector3>> rightSidewalkStartV3 = new List<List<Vector3>>();

	public List<List<Vector3>> leftSidewalkEndV3 = new List<List<Vector3>>();

	public List<List<Vector3>> rightSidewalkEndV3 = new List<List<Vector3>>();

	public List<List<Vector2>> leftSidewalkStartUV = new List<List<Vector2>>();

	public List<List<Vector2>> rightSidewalkStartUV = new List<List<Vector2>>();

	public List<List<Vector2>> leftSidewalkEndUV = new List<List<Vector2>>();

	public List<List<Vector2>> rightSidewalkEndUV = new List<List<Vector2>>();

	public List<List<Vector3>> leftSidewalkLeftV3 = new List<List<Vector3>>();

	public List<List<Vector3>> leftSidewalkRightV3 = new List<List<Vector3>>();

	public List<List<Vector3>> rightSidewalkLeftV3 = new List<List<Vector3>>();

	public List<List<Vector3>> rightSidewalkRightV3 = new List<List<Vector3>>();

	public List<List<Vector2>> leftSidewalkLeftUV = new List<List<Vector2>>();

	public List<List<Vector2>> leftSidewalkRightUV = new List<List<Vector2>>();

	public List<List<Vector2>> rightSidewalkLeftUV = new List<List<Vector2>>();

	public List<List<Vector2>> rightSidewalkRightUV = new List<List<Vector2>>();

	public List<List<int>> leftSidewalkStartTris = new List<List<int>>();

	public List<List<int>> rightSidewalkStartTris = new List<List<int>>();

	public List<List<int>> leftSidewalkEndTris = new List<List<int>>();

	public List<List<int>> rightSidewalkEndTris = new List<List<int>>();

	public List<List<int>> leftSidewalkLeftTris = new List<List<int>>();

	public List<List<int>> leftSidewalkRightTris = new List<List<int>>();

	public List<List<int>> rightSidewalkLeftTris = new List<List<int>>();

	public List<List<int>> rightSidewalkRightTris = new List<List<int>>();

	public List<float> uvArrayFront = new List<float>();

	public List<float> uvArrayBack = new List<float>();

	public List<float> uvArrayLeft = new List<float>();

	public List<float> uvArrayRight = new List<float>();

	public List<int> OCCODQDOQO = new List<int>();

	public List<int> OOQODQDOQC = new List<int>();

	public List<int> OQCCQOCQDQ = new List<int>();

	public List<int> OQDQOQOCQD = new List<int>();

	public List<int> ODQDCCQOQD = new List<int>();

	public List<int> ODOQODQODO = new List<int>();

	public List<int> OOOQCQDOCD = new List<int>();

	public List<int> OQCDOOCDCD = new List<int>();

	public List<int> OCCODQDOQOStart = new List<int>();

	public List<int> OOQODQDOQCStart = new List<int>();

	public List<int> OQCCQOCQDQStart = new List<int>();

	public List<int> OQDQOQOCQDStart = new List<int>();

	public List<int> ODQDCCQOQDStart = new List<int>();

	public List<int> ODOQODQODOStart = new List<int>();

	public List<int> OOOQCQDOCDStart = new List<int>();

	public List<int> OQCDOOCDCDStart = new List<int>();

	public List<int> frontLeftRoadInts = new List<int>();

	public List<int> frontRightRoadInts = new List<int>();

	public List<int> backLeftRoadInts = new List<int>();

	public List<int> backRightRoadInts = new List<int>();

	public List<int> leftLeftRoadInts = new List<int>();

	public List<int> leftRightRoadInts = new List<int>();

	public List<int> rightLeftRoadInts = new List<int>();

	public List<int> rightRightRoadInts = new List<int>();

	public List<ERSideWalk> sidewalkCorners = new List<ERSideWalk>();

	public List<float> sidewalkWidths = new List<float>();

	public List<float> curbHeights = new List<float>();

	public List<float> curbDepths = new List<float>();

	public List<bool> beveledCurbs = new List<bool>();

	public List<float> beveledHeights = new List<float>();

	public List<float> beveledDepths = new List<float>();

	public List<bool> outerCurbs = new List<bool>();

	public List<bool> lockUVs = new List<bool>();

	public List<Material> materials = new List<Material>();

	public int leftStartSidewalkCornerInt = 0;

	public int rightStartSidewalkCornerInt = 0;

	public int leftEndSidewalkCornerInt = 0;

	public int rightEndSidewalkCornerInt = 0;

	public int leftLeftSidewalkCornerInt = 0;

	public int rightLeftSidewalkCornerInt = 0;

	public int leftRightSidewalkCornerInt = 0;

	public int rightRightSidewalkCornerInt = 0;

	public Vector3[] sidewalkControlPoints = new Vector3[12];

	public bool[] sidewalkControlStatus = new bool[0];

	public bool copySettingsFlag = false;

	public bool generalSettingsFlag = false;

	public bool connectionSettingsFlag = false;

	public bool cornerSettingsFlag = false;

	public bool sidewalkSettingsFlag = false;

	public string[] QDOOOQOOQQQQD;

	public int selectedConnection = 0;

	public float startAngle = 0f;

	public bool roundedCorners = true;

	public float roundingRadius = 1f;

	public int roundingSegments = 5;

	public float innerSegmentDistance = 0.5f;

	public bool tCrossing = false;

	public bool tStraightBending = true;

	public bool oldTCrossing = false;

	public int tCrossingLeftRight = 1;

	public int oldtCrossingLeftRight = 1;

	public int geometryType = 0;

	public float resolution = 1f;

	public bool includeSidewalks = true;

	public bool defaultSidewalkEnabledStatus = true;

	public bool planarUVs = false;

	public float planarTiling = 1f;

	public bool isSceneObject = true;

	public int connectionHandling = 0;

	public List<QDQDOOQQDQODD> roadTypesDynamic = new List<QDQDOOQQDQODD>();

	public int frontRoadTypeInt = 0;

	public double frontRoadTypeID = 0.0;

	public float frontRoadWidth = 8f;

	public Material frontMaterial;

	public Material frontRoadMaterial;

	public float frontRoadUVTiling = 1f;

	public int backRoadTypeInt = 0;

	public double backRoadTypeID = 0.0;

	public float backRoadWidth = 8f;

	public Material backMaterial;

	public Material backRoadMaterial;

	public float backRoadUVTiling = 1f;

	public int leftRoadTypeInt = 0;

	public double leftRoadTypeID = 0.0;

	public float leftRoadWidth = 8f;

	public Material leftMaterial;

	public Material leftRoadMaterial;

	public float leftRoadUVTiling = 1f;

	public int rightRoadTypeInt = 0;

	public double rightRoadTypeID = 0.0;

	public float rightRoadWidth = 8f;

	public Material rightMaterial;

	public Material rightRoadMaterial;

	public float rightRoadUVTiling = 1f;

	public int selectedRoadType = 0;

	public bool uniformCornersFlag;

	public int selectedCorner = 0;

	public int selectedCornerPreset = 0;

	public string cornerPresetName;

	public int selectedSidewalkPreset = 0;

	public string sidewalkPresetName;

	public int OCOQDODDQQCorner = 0;

	public Vector3 leftBottom;

	public Vector3 rightBottom;

	public Vector3 leftTop;

	public Vector3 rightTop;

	public Vector3 frontCenter;

	public Vector3 backCenter;

	public Vector3 leftCenter;

	public Vector3 rightCenter;

	public int prefabId = 0;

	public ERCrossingPrefabs prefabScript;

	public QDOODOQQDQODD connectionElement;

	public int crossingOuterElement = 0;

	public string crossingName;

	public bool guiChanged;

	public bool includeSidewalkChangeFlag = false;

	public List<Vector3> debugVecs = new List<Vector3>();

	public List<NormalPairs> normalPairs = new List<NormalPairs>();

	public float maxConnectionWidth = 75f;

	public int crossingStructure = 0;

	public ERModularBase baseScript;

	public List<ERConnectionSibling> siblings1 = new List<ERConnectionSibling>();

	public List<ERConnectionSibling> prioritySiblings = new List<ERConnectionSibling>();

	public Vector3 crossPointCenter;

	public List<Vector3> edges = new List<Vector3>();

	public ERConnectionSibling primaryPriorityConnection;

	public ERConnectionSibling secondPriorityConnection;

	public bool adjustMainRadiusFlag = false;

	public bool disableAdjustMainRadiusFlag = false;

	public bool showScaleSliderAtPrimary = false;

	public bool showScaleSliderAtSecondary = false;

	public ERRoadWayType priorityWayType;

	public float leftIntOffset = 0f;

	public float rightIntOffset = 0f;

	public bool isUpdating = false;

	public int serializeTest = 5;

	public int updateQueue = 0;

	public void Refresh()
	{
		OCQDQODOQD(sidewalkSceneHandleFlag: true, rebuildRoads: true);
	}

	public void ODOCCDCQOC()
	{
		if (baseScript == null)
		{
			baseScript = UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase;
		}
		if (updateQueue != baseScript.updateQueue)
		{
			updateQueue = baseScript.updateQueue;
			QDDDQODDQDQDQDD.OQODQQQCOC(this);
			QDDDQODDQDQDQDD.ODODCOOQDO();
		}
	}

	public Vector3 OOQCQDQCOO(int index, Vector3 p0, Vector3 p1, Vector3 p2, bool update)
	{
		if (update)
		{
			if (baseScript == null)
			{
				baseScript = UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase;
			}
			if (updateQueue == baseScript.updateQueue)
			{
				return base.transform.TransformPoint(prefabScript.crossingElements[index].centerPoint);
			}
		}
		if (prefabScript.siblings.Count == 0)
		{
			UnityEngine.Debug.Log("EasyRoads3Dv3 Warning: No Flex Connector data available, please report this");
		}
		Vector3 cp = base.transform.TransformPoint(Vector3.zero);
		Vector3 angleControlPoint = ERConnectionSibling.GetAngleControlPoint(cp, p0, p1, p2);
		angleControlPoint = base.transform.InverseTransformPoint(angleControlPoint);
		float num = Vector3.Distance(angleControlPoint, prefabScript.siblings[index].angleControlPoint);
		if ((double)num < 0.25)
		{
			update = false;
		}
		else
		{
			prefabScript.siblings[index].angleControlPoint = angleControlPoint;
		}
		if (update || prefabScript.siblings[index].hasChanged)
		{
			ODOCCDCQOC();
		}
		if (prefabScript == null)
		{
			prefabScript = base.gameObject.GetComponent<ERCrossingPrefabs>();
		}
		return base.transform.TransformPoint(prefabScript.crossingElements[index].centerPoint);
	}

	public void UpdateAllConnectionAngles()
	{
		for (int i = 0; i < prefabScript.siblings.Count; i++)
		{
			if (prefabScript.crossingElements[i].connectedRoad != null)
			{
				Vector3 position;
				Vector3 position2;
				Vector3 p;
				if (prefabScript.crossingElements[i].connectedRoad.startPrefabScript == prefabScript)
				{
					position = prefabScript.crossingElements[i].connectedRoad.markersExt[0].position;
					position2 = prefabScript.crossingElements[i].connectedRoad.markersExt[1].position;
					p = ((prefabScript.crossingElements[i].connectedRoad.markersExt.Count <= 2) ? position2 : prefabScript.crossingElements[i].connectedRoad.markersExt[2].position);
				}
				else
				{
					int count = prefabScript.crossingElements[i].connectedRoad.markersExt.Count;
					position = prefabScript.crossingElements[i].connectedRoad.markersExt[count - 1].position;
					position2 = prefabScript.crossingElements[i].connectedRoad.markersExt[count - 2].position;
					p = ((count <= 2) ? position2 : prefabScript.crossingElements[i].connectedRoad.markersExt[count - 3].position);
				}
				OOQCQDQCOO(i, position, position2, p, update: false);
			}
			prefabScript.siblings[i].hasChanged = true;
		}
	}

	public void OOOCDCQQCO()
	{
		OCQDQODOQD(sidewalkSceneHandleFlag: true, rebuildRoads: true);
	}

	public bool UpdateToRoadType(QDQDOOQQDQODD sourcePreset, ref List<ERModularRoad> updatedRoads)
	{
		if (prefabScript == null)
		{
			UnityEngine.Debug.LogWarning("EasyRoads3Dv3 Warning: Missing ER Crossing Prefabs script on: " + base.gameObject.name);
			return false;
		}
		if (prefabScript.isFlexConnector)
		{
			ODOCCDCQOC();
			return false;
		}
		Material material = sourcePreset.connectionMaterial;
		if (material == null)
		{
			material = sourcePreset.roadMaterial;
		}
		List<int> list = new List<int>();
		bool flag = false;
		if (prefabScript.crossingElements[0].roadType == sourcePreset.id && prefabScript.crossingElements[0].roadType != 0.0)
		{
			flag = true;
			frontRoadWidth = sourcePreset.roadWidth;
			frontMaterial = material;
			frontRoadMaterial = sourcePreset.roadMaterial;
			prefabScript.crossingElements[0].roadTypeTimestamp = sourcePreset.timestamp;
			if (prefabScript.crossingElements[0].connectedRoad != null && prefabScript.crossingElements[0].connectedRoad.roadType == prefabScript.crossingElements[0].roadType && !RoadIsUpdated(prefabScript.crossingElements[0].connectedRoad, ref updatedRoads))
			{
				list.Add(0);
			}
		}
		if (prefabScript.crossingElements[1].roadType == sourcePreset.id && prefabScript.crossingElements[1].roadType != 0.0)
		{
			flag = true;
			backRoadWidth = sourcePreset.roadWidth;
			backMaterial = material;
			backRoadMaterial = sourcePreset.roadMaterial;
			prefabScript.crossingElements[1].roadTypeTimestamp = sourcePreset.timestamp;
			if (prefabScript.crossingElements[1].connectedRoad != null && prefabScript.crossingElements[1].connectedRoad.roadType == prefabScript.crossingElements[1].roadType && !RoadIsUpdated(prefabScript.crossingElements[1].connectedRoad, ref updatedRoads))
			{
				list.Add(1);
			}
		}
		if (prefabScript.crossingElements[2].roadType == sourcePreset.id && prefabScript.crossingElements[2].roadType != 0.0)
		{
			flag = true;
			leftRoadWidth = sourcePreset.roadWidth;
			leftMaterial = material;
			leftRoadMaterial = sourcePreset.roadMaterial;
			prefabScript.crossingElements[2].roadTypeTimestamp = sourcePreset.timestamp;
			if (prefabScript.crossingElements[2].connectedRoad != null && prefabScript.crossingElements[2].connectedRoad.roadType == prefabScript.crossingElements[2].roadType && !RoadIsUpdated(prefabScript.crossingElements[2].connectedRoad, ref updatedRoads))
			{
				list.Add(2);
			}
		}
		if (prefabScript.crossingElements[3].roadType == sourcePreset.id && prefabScript.crossingElements[3].roadType != 0.0)
		{
			flag = true;
			rightRoadWidth = sourcePreset.roadWidth;
			rightMaterial = material;
			rightRoadMaterial = sourcePreset.roadMaterial;
			prefabScript.crossingElements[3].roadTypeTimestamp = sourcePreset.timestamp;
			if (prefabScript.crossingElements[3].connectedRoad != null && prefabScript.crossingElements[3].connectedRoad.roadType == prefabScript.crossingElements[3].roadType && !RoadIsUpdated(prefabScript.crossingElements[3].connectedRoad, ref updatedRoads))
			{
				list.Add(3);
			}
		}
		if (flag)
		{
			crossingName = base.gameObject.name;
			OCQDQODOQD(sidewalkSceneHandleFlag: false, rebuildRoads: true);
			for (int i = 0; i < list.Count; i++)
			{
				ERModularRoad connectedRoad = prefabScript.crossingElements[list[i]].connectedRoad;
				if ((bool)connectedRoad.startPrefabScript && (bool)connectedRoad.endPrefabScript)
				{
					connectedRoad.ODDDCDQCCO(prefabScript, list[i], reverse: true, uvReverse: true, UpdateResolutionFlag: false);
					if (connectedRoad.roadShape[0].x < 0f)
					{
						connectedRoad.ODDDCDQCCO(prefabScript, list[i], reverse: false, uvReverse: false, UpdateResolutionFlag: false);
					}
				}
				else if (prefabScript.crossingElements[list[i]].connectedMarker == 0)
				{
					connectedRoad.ODDDCDQCCO(prefabScript, list[i], reverse: true, uvReverse: true, UpdateResolutionFlag: false);
					if (connectedRoad.roadShape[0].x < 0f)
					{
						connectedRoad.ODDDCDQCCO(prefabScript, list[i], reverse: false, uvReverse: false, UpdateResolutionFlag: false);
					}
				}
				else
				{
					connectedRoad.ODDDCDQCCO(prefabScript, list[i], reverse: false, uvReverse: false, UpdateResolutionFlag: false);
					if (connectedRoad.roadShape[0].x < 0f)
					{
						connectedRoad.ODDDCDQCCO(prefabScript, list[i], reverse: true, uvReverse: true, UpdateResolutionFlag: false);
					}
				}
				if (connectedRoad.flipRoadUVs)
				{
					connectedRoad.FlipRoadUVs(update: false);
				}
				connectedRoad.OCQOQCDCQC(ignorePrefabAlignment: false, forceAutoRotate: false);
			}
		}
		return flag;
	}

	public bool RoadIsUpdated(ERModularRoad rd, ref List<ERModularRoad> updatedRoads)
	{
		foreach (ERModularRoad updatedRoad in updatedRoads)
		{
			if (updatedRoad == rd)
			{
				return true;
			}
		}
		updatedRoads.Add(rd);
		return false;
	}

	public int SetRoadTypeInt(double id)
	{
		int num = 1;
		foreach (QDQDOOQQDQODD item in roadTypesDynamic)
		{
			if (id == item.id)
			{
				return num;
			}
			num++;
		}
		return 0;
	}

	public void OCQCQODOQC(ERCrossings source, bool refreshFlag)
	{
		roadTypesDynamic.Clear();
		if (prefabScript == null)
		{
			prefabScript = base.gameObject.GetComponent<ERCrossingPrefabs>();
		}
		if (prefabScript.baseScript == null)
		{
			prefabScript.baseScript = UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase;
		}
		foreach (QDQDOOQQDQODD roadType in prefabScript.baseScript.roadTypes)
		{
			if (roadType.roadShape.Count == 2 && !roadType.isSideObject && !roadType.isCustomRoad)
			{
				roadTypesDynamic.Add(roadType);
			}
		}
		prefabId = source.prefabId;
		uvArrayFront = new List<float>(source.uvArrayFront.Count);
		uvArrayBack = new List<float>(source.uvArrayBack.Count);
		uvArrayLeft = new List<float>(source.uvArrayLeft.Count);
		uvArrayRight = new List<float>(source.uvArrayRight.Count);
		sidewalkControlPoints = new Vector3[source.sidewalkControlPoints.Length];
		Array.Copy(source.sidewalkControlPoints, sidewalkControlPoints, source.sidewalkControlPoints.Length);
		sidewalkControlStatus = new bool[source.sidewalkControlStatus.Length];
		Array.Copy(source.sidewalkControlStatus, sidewalkControlStatus, source.sidewalkControlStatus.Length);
		QDOOOQOOQQQQD = new string[source.QDOOOQOOQQQQD.Length];
		Array.Copy(source.QDOOOQOOQQQQD, QDOOOQOOQQQQD, source.QDOOOQOOQQQQD.Length);
		selectedConnection = source.selectedConnection;
		startAngle = source.startAngle;
		roundedCorners = source.roundedCorners;
		roundingRadius = source.roundingRadius;
		roundingSegments = source.roundingSegments;
		innerSegmentDistance = source.innerSegmentDistance;
		if (!refreshFlag)
		{
			tCrossing = source.tCrossing;
		}
		geometryType = source.geometryType;
		resolution = source.resolution;
		connectionHandling = source.connectionHandling;
		frontRoadTypeInt = source.frontRoadTypeInt;
		frontRoadTypeID = source.frontRoadTypeID;
		frontRoadWidth = source.frontRoadWidth;
		frontMaterial = source.frontMaterial;
		frontRoadMaterial = source.frontRoadMaterial;
		frontRoadUVTiling = source.frontRoadUVTiling;
		backRoadTypeInt = source.backRoadTypeInt;
		backRoadTypeID = source.backRoadTypeID;
		backRoadWidth = source.backRoadWidth;
		backMaterial = source.backMaterial;
		backRoadMaterial = source.backRoadMaterial;
		backRoadUVTiling = source.backRoadUVTiling;
		leftRoadTypeInt = source.leftRoadTypeInt;
		leftRoadTypeID = source.leftRoadTypeID;
		leftRoadWidth = source.leftRoadWidth;
		leftMaterial = source.leftMaterial;
		leftRoadMaterial = source.leftRoadMaterial;
		leftRoadUVTiling = source.leftRoadUVTiling;
		rightRoadTypeInt = source.rightRoadTypeInt;
		rightRoadTypeID = source.rightRoadTypeID;
		rightRoadWidth = source.rightRoadWidth;
		rightMaterial = source.rightMaterial;
		rightRoadMaterial = source.rightRoadMaterial;
		rightRoadUVTiling = source.rightRoadUVTiling;
		frontRoadTypeInt = SetRoadTypeInt(frontRoadTypeID);
		backRoadTypeInt = SetRoadTypeInt(backRoadTypeID);
		leftRoadTypeInt = SetRoadTypeInt(leftRoadTypeID);
		rightRoadTypeInt = SetRoadTypeInt(rightRoadTypeID);
		selectedRoadType = source.selectedRoadType;
		uniformCornersFlag = source.uniformCornersFlag;
		selectedCorner = source.selectedCorner;
		selectedCornerPreset = source.selectedCornerPreset;
		cornerPresetName = source.cornerPresetName;
		selectedSidewalkPreset = source.selectedSidewalkPreset;
		sidewalkPresetName = source.sidewalkPresetName;
		OCOQDODDQQCorner = source.OCOQDODDQQCorner;
		leftBottom = source.leftBottom;
		rightBottom = source.rightBottom;
		leftTop = source.leftTop;
		rightTop = source.rightTop;
		frontCenter = source.frontCenter;
		backCenter = source.backCenter;
		leftCenter = source.leftCenter;
		rightCenter = source.rightCenter;
		includeSidewalks = source.defaultSidewalkEnabledStatus;
		defaultSidewalkEnabledStatus = source.defaultSidewalkEnabledStatus;
		if (source.sidewalkControlPoints != null)
		{
			sidewalkControlPoints = new Vector3[source.sidewalkControlPoints.Length];
			Array.Copy(source.sidewalkControlPoints, sidewalkControlPoints, source.sidewalkControlPoints.Length);
		}
		if (source.sidewalkControlStatus != null)
		{
			sidewalkControlStatus = new bool[source.sidewalkControlStatus.Length];
			Array.Copy(source.sidewalkControlStatus, sidewalkControlStatus, source.sidewalkControlStatus.Length);
		}
		prefabScript.crossingElements.Clear();
		prefabScript.sidewalkControlElements.Clear();
		ERCrossingPrefabs component = source.gameObject.GetComponent<ERCrossingPrefabs>();
		if (component != null)
		{
			for (int i = 0; i < component.crossingElements.Count; i++)
			{
				prefabScript.crossingElements.Add(new QDOODOQQDQODD());
				prefabScript.crossingElements[i].rotationPriority = component.crossingElements[i].rotationPriority;
				prefabScript.crossingElements[i].includeLeftSidewalk = component.crossingElements[i].includeLeftSidewalk;
				prefabScript.crossingElements[i].includeRightSidewalk = component.crossingElements[i].includeRightSidewalk;
				prefabScript.crossingElements[i].roadMaterial = component.crossingElements[i].roadMaterial;
				prefabScript.crossingElements[i].roadType = component.crossingElements[i].roadType;
				prefabScript.crossingElements[i].roadTypeTimestamp = component.crossingElements[i].roadTypeTimestamp;
				prefabScript.sidewalkControlElements.Add(new QDOQDSQOOQDDD(UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase));
				if (component.sidewalkControlElements.Count > i)
				{
					prefabScript.sidewalkControlElements[i].crossingElementLeftIndex = component.sidewalkControlElements[i].crossingElementLeftIndex;
					prefabScript.sidewalkControlElements[i].crossingElementRightIndex = component.sidewalkControlElements[i].crossingElementRightIndex;
					prefabScript.sidewalkControlElements[i].centerHandleV3 = component.sidewalkControlElements[i].centerHandleV3;
					prefabScript.sidewalkControlElements[i].leftHandleV3 = component.sidewalkControlElements[i].leftHandleV3;
					prefabScript.sidewalkControlElements[i].rightHandleV3 = component.sidewalkControlElements[i].rightHandleV3;
					prefabScript.sidewalkControlElements[i].renderFlag = component.sidewalkControlElements[i].renderFlag;
					prefabScript.sidewalkControlElements[i].leftConnectionHandle = component.sidewalkControlElements[i].leftConnectionHandle;
					prefabScript.sidewalkControlElements[i].rightConnectionHandle = component.sidewalkControlElements[i].rightConnectionHandle;
					prefabScript.sidewalkControlElements[i].sidewalkWidth1 = component.sidewalkControlElements[i].sidewalkWidth1;
					prefabScript.sidewalkControlElements[i].sidewalkWidth2 = component.sidewalkControlElements[i].sidewalkWidth2;
					prefabScript.sidewalkControlElements[i].curbHeight = component.sidewalkControlElements[i].curbHeight;
					prefabScript.sidewalkControlElements[i].curbDepth = component.sidewalkControlElements[i].curbDepth;
					prefabScript.sidewalkControlElements[i].beveledCurb = component.sidewalkControlElements[i].beveledCurb;
					prefabScript.sidewalkControlElements[i].beveledHeight = component.sidewalkControlElements[i].beveledHeight;
					prefabScript.sidewalkControlElements[i].beveledDepth = component.sidewalkControlElements[i].beveledDepth;
					prefabScript.sidewalkControlElements[i].outerCurb = component.sidewalkControlElements[i].outerCurb;
					prefabScript.sidewalkControlElements[i].roadSideCurbUVControl = component.sidewalkControlElements[i].roadSideCurbUVControl;
					prefabScript.sidewalkControlElements[i].outerSideCurbUVControl = component.sidewalkControlElements[i].outerSideCurbUVControl;
					prefabScript.sidewalkControlElements[i].sidewalkMaterial = component.sidewalkControlElements[i].sidewalkMaterial;
					prefabScript.sidewalkControlElements[i].sidewalkUVs = new List<float>(component.sidewalkControlElements[i].sidewalkUVs);
					prefabScript.sidewalkControlElements[i].curbUVs = new List<float>(component.sidewalkControlElements[i].curbUVs);
					prefabScript.sidewalkControlElements[i].lockUVs = component.sidewalkControlElements[i].lockUVs;
					prefabScript.sidewalkControlElements[i].cornerRadius = component.sidewalkControlElements[i].cornerRadius;
					prefabScript.sidewalkControlElements[i].cornerSegments = component.sidewalkControlElements[i].cornerSegments;
					prefabScript.sidewalkControlElements[i].innerSegmentDistance = component.sidewalkControlElements[i].innerSegmentDistance;
					prefabScript.sidewalkControlElements[i].startAngle = component.sidewalkControlElements[i].startAngle;
				}
			}
		}
		if (!defaultSidewalkEnabledStatus)
		{
			for (int j = 0; j < prefabScript.sidewalkControlElements.Count; j++)
			{
				prefabScript.sidewalkControlElements[j].renderFlag = false;
				prefabScript.sidewalkControlElements[j].leftConnectionHandle = false;
				prefabScript.sidewalkControlElements[j].rightConnectionHandle = false;
			}
			for (int k = 0; k < prefabScript.crossingElements.Count; k++)
			{
				prefabScript.crossingElements[k].includeLeftSidewalk = false;
				prefabScript.crossingElements[k].includeRightSidewalk = false;
			}
		}
		if (base.gameObject.name != "")
		{
			crossingName = base.gameObject.name;
		}
		OCQDQODOQD(sidewalkSceneHandleFlag: true, rebuildRoads: false);
	}

	public void OQCQCOOCDD()
	{
		debugVecs.Clear();
		normalPairs.Clear();
		startConnectionV3.Clear();
		endConnectionV3.Clear();
		leftConnectionV3.Clear();
		rightConnectionV3.Clear();
		startConnectionUV.Clear();
		endConnectionUV.Clear();
		leftConnectionUV.Clear();
		rightConnectionUV.Clear();
		startConnectionTris.Clear();
		endConnectionTris.Clear();
		leftConnectionTris.Clear();
		rightConnectionTris.Clear();
		leftSidewalkStartV3.Clear();
		rightSidewalkStartV3.Clear();
		leftSidewalkEndV3.Clear();
		rightSidewalkEndV3.Clear();
		leftSidewalkStartUV.Clear();
		rightSidewalkStartUV.Clear();
		leftSidewalkEndUV.Clear();
		rightSidewalkEndUV.Clear();
		leftSidewalkLeftV3.Clear();
		leftSidewalkRightV3.Clear();
		rightSidewalkLeftV3.Clear();
		rightSidewalkRightV3.Clear();
		leftSidewalkLeftUV.Clear();
		leftSidewalkRightUV.Clear();
		rightSidewalkLeftUV.Clear();
		rightSidewalkRightUV.Clear();
		leftSidewalkStartTris.Clear();
		rightSidewalkStartTris.Clear();
		leftSidewalkEndTris.Clear();
		rightSidewalkEndTris.Clear();
		leftSidewalkLeftTris.Clear();
		leftSidewalkRightTris.Clear();
		rightSidewalkLeftTris.Clear();
		rightSidewalkRightTris.Clear();
		OCCODQDOQO.Clear();
		OOQODQDOQC.Clear();
		OQCCQOCQDQ.Clear();
		OQDQOQOCQD.Clear();
		ODQDCCQOQD.Clear();
		ODOQODQODO.Clear();
		OOOQCQDOCD.Clear();
		OQCDOOCDCD.Clear();
		OCCODQDOQOStart.Clear();
		OOQODQDOQCStart.Clear();
		OQCCQOCQDQStart.Clear();
		OQDQOQOCQDStart.Clear();
		ODQDCCQOQDStart.Clear();
		ODOQODQODOStart.Clear();
		OOOQCQDOCDStart.Clear();
		OQCDOOCDCDStart.Clear();
		frontLeftRoadInts.Clear();
		frontRightRoadInts.Clear();
		backLeftRoadInts.Clear();
		backRightRoadInts.Clear();
		leftLeftRoadInts.Clear();
		leftRightRoadInts.Clear();
		rightLeftRoadInts.Clear();
		rightRightRoadInts.Clear();
		prefabScript.tCrossingBlendData.Clear();
	}

	public void OCQDQODOQD(bool sidewalkSceneHandleFlag, bool rebuildRoads)
	{
		if (prefabScript.isFlexConnector)
		{
			return;
		}
		prefabScript.isERCrossing = true;
		if (oldTCrossing != tCrossing || oldtCrossingLeftRight != tCrossingLeftRight)
		{
			OODOQQQQCO();
			oldTCrossing = tCrossing;
			oldtCrossingLeftRight = tCrossingLeftRight;
		}
		if (tCrossing)
		{
			if (tCrossingLeftRight == 1)
			{
				prefabScript.sidewalkControlElements[2].renderFlag = prefabScript.sidewalkControlElements[1].renderFlag;
			}
			else
			{
				prefabScript.sidewalkControlElements[3].renderFlag = prefabScript.sidewalkControlElements[0].renderFlag;
			}
		}
		if (uniformCornersFlag)
		{
			for (int i = 0; i < prefabScript.sidewalkControlElements.Count; i++)
			{
				if (i != selectedCorner)
				{
					prefabScript.sidewalkControlElements[i].cornerRadius = prefabScript.sidewalkControlElements[selectedCorner].cornerRadius;
					prefabScript.sidewalkControlElements[i].cornerSegments = prefabScript.sidewalkControlElements[selectedCorner].cornerSegments;
					prefabScript.sidewalkControlElements[i].innerSegmentDistance = prefabScript.sidewalkControlElements[selectedCorner].innerSegmentDistance;
					prefabScript.sidewalkControlElements[i].sidewalkWidth1 = prefabScript.sidewalkControlElements[selectedCorner].sidewalkWidth1;
					prefabScript.sidewalkControlElements[i].sidewalkWidth2 = prefabScript.sidewalkControlElements[selectedCorner].sidewalkWidth2;
					prefabScript.sidewalkControlElements[i].curbHeight = prefabScript.sidewalkControlElements[selectedCorner].curbHeight;
					prefabScript.sidewalkControlElements[i].curbDepth = prefabScript.sidewalkControlElements[selectedCorner].curbDepth;
					prefabScript.sidewalkControlElements[i].beveledCurb = prefabScript.sidewalkControlElements[selectedCorner].beveledCurb;
					prefabScript.sidewalkControlElements[i].beveledHeight = prefabScript.sidewalkControlElements[selectedCorner].beveledHeight;
					prefabScript.sidewalkControlElements[i].beveledDepth = prefabScript.sidewalkControlElements[selectedCorner].beveledDepth;
					prefabScript.sidewalkControlElements[i].outerCurb = prefabScript.sidewalkControlElements[selectedCorner].outerCurb;
					prefabScript.sidewalkControlElements[i].roadSideCurbUVControl = prefabScript.sidewalkControlElements[selectedCorner].roadSideCurbUVControl;
					prefabScript.sidewalkControlElements[i].outerSideCurbUVControl = prefabScript.sidewalkControlElements[selectedCorner].outerSideCurbUVControl;
					prefabScript.sidewalkControlElements[i].sidewalkMaterial = prefabScript.sidewalkControlElements[selectedCorner].sidewalkMaterial;
					prefabScript.sidewalkControlElements[i].sidewalkUVs.Clear();
					prefabScript.sidewalkControlElements[i].sidewalkUVs.AddRange(prefabScript.sidewalkControlElements[selectedCorner].sidewalkUVs);
					prefabScript.sidewalkControlElements[i].curbUVs.Clear();
					prefabScript.sidewalkControlElements[i].curbUVs.AddRange(prefabScript.sidewalkControlElements[selectedCorner].curbUVs);
					prefabScript.sidewalkControlElements[i].lockUVs = prefabScript.sidewalkControlElements[selectedCorner].lockUVs;
				}
			}
		}
		if (sidewalkSceneHandleFlag && includeSidewalkChangeFlag)
		{
			for (int j = 0; j < prefabScript.sidewalkControlElements.Count; j++)
			{
				prefabScript.crossingElements[prefabScript.sidewalkControlElements[j].crossingElementLeftIndex].includeLeftSidewalk = includeSidewalks;
				prefabScript.crossingElements[prefabScript.sidewalkControlElements[j].crossingElementRightIndex].includeRightSidewalk = includeSidewalks;
			}
		}
		OQCQCOOCDD();
		float firstSegmentDistance = 0f;
		if (!tCrossing)
		{
			ODOCDOQDCO.OQQQQQODDO(this, ref firstSegmentDistance);
			ODOCDOQDCO.OQODOQQCOO(this);
			ODOCDOQDCO.OOOCDOCQQO(this);
			ODOCDOQDCO.OCOOOQQQQO(this);
			ODOCDOQDCO.OOCCOQQDQQ(this);
			leftBottom = startConnectionV3[0][startConnectionV3[0].Count - 1];
			rightBottom = startConnectionV3[startConnectionV3.Count - 1][startConnectionV3[startConnectionV3.Count - 1].Count - 1];
			rightTop = endConnectionV3[0][endConnectionV3[0].Count - 1];
			leftTop = endConnectionV3[endConnectionV3.Count - 1][endConnectionV3[endConnectionV3.Count - 1].Count - 1];
			leftBottom.y = (rightBottom.y = (rightTop.y = (leftTop.y = 0.5f)));
			frontCenter = startConnectionV3[2][0];
			backCenter = endConnectionV3[2][0];
			leftCenter = leftConnectionV3[2][0];
			rightCenter = rightConnectionV3[2][0];
			ODDDDDCCQQ.InitODCOCQQDDC(this);
			ERSideWalkVecs.OQOQDODDCD(this);
			ODDDOCDCQO(rebuildRoads);
			return;
		}
		OQOQQODODO.OQQQQQODDO(this, ref firstSegmentDistance);
		OQOQQODODO.OQODOQQCOO(this);
		OQOQQODODO.OOOCDOCQQO(this);
		OQOQQODODO.OCOOOQQQQO(this);
		OQOQQODODO.OOCCOQQDQQ(this);
		OQQDOCQOCO.InitODCOCQQDDC(this);
		ODDCOQCOOO.OQOQDODDCD(this);
		leftBottom = startConnectionV3[0][startConnectionV3[0].Count - 1];
		rightBottom = startConnectionV3[startConnectionV3.Count - 1][startConnectionV3[startConnectionV3.Count - 1].Count - 1];
		rightTop = endConnectionV3[0][endConnectionV3[0].Count - 1];
		leftTop = endConnectionV3[endConnectionV3.Count - 1][endConnectionV3[endConnectionV3.Count - 1].Count - 1];
		leftBottom.y = (rightBottom.y = (rightTop.y = (leftTop.y = 0.5f)));
		if (tCrossingLeftRight == 1)
		{
			leftTop = Vector3.zero;
			prefabScript.tConnectionRoadWidth = rightRoadWidth;
		}
		if (tCrossingLeftRight == 0)
		{
			rightTop = Vector3.zero;
			prefabScript.tConnectionRoadWidth = leftRoadWidth;
		}
		prefabScript.tMainRoadWidth = frontRoadWidth;
		ODDDOCDCQO(rebuildRoads);
	}

	public void OQCQDQDCOD()
	{
	}

	public void ODDDOCDCQO(bool rebuildRoads)
	{
		if (base.gameObject.GetComponent<MeshFilter>() == null)
		{
			base.gameObject.AddComponent<MeshFilter>();
		}
		if (base.gameObject.GetComponent<MeshRenderer>() == null)
		{
			base.gameObject.AddComponent<MeshRenderer>();
		}
		if (base.gameObject.GetComponent<MeshCollider>() == null)
		{
			base.gameObject.AddComponent<MeshCollider>();
		}
		Mesh mesh;
		if (base.gameObject.GetComponent<MeshFilter>().sharedMesh != null)
		{
			mesh = base.gameObject.GetComponent<MeshFilter>().sharedMesh;
		}
		else
		{
			mesh = new Mesh();
			mesh.name = base.gameObject.name + "_Mesh";
			base.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
			base.gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
		}
		if (crossingName != "")
		{
			base.gameObject.name = crossingName;
		}
		List<Vector3> meshVecs = new List<Vector3>();
		List<Vector2> meshUVs = new List<Vector2>();
		List<List<int>> triList = new List<List<int>>();
		List<Material> materialList = new List<Material>();
		List<Material> list = new List<Material>();
		triList.Add(new List<int>());
		materialList.Add(frontMaterial);
		list.Add(frontMaterial);
		list.Add(backMaterial);
		list.Add(leftMaterial);
		list.Add(rightMaterial);
		int triArrayElement = 0;
		OQOQCCCDDQ.ODOOOODDOO(ref materialList, ref triList, backMaterial, ref triArrayElement);
		if (!tCrossing || tCrossingLeftRight == 0)
		{
			OQOQCCCDDQ.ODOOOODDOO(ref materialList, ref triList, leftMaterial, ref triArrayElement);
		}
		if (!tCrossing || tCrossingLeftRight == 1)
		{
			OQOQCCCDDQ.ODOOOODDOO(ref materialList, ref triList, rightMaterial, ref triArrayElement);
		}
		if (!tCrossing)
		{
			ODDDDDCCQQ.OQDCOQDQDO(this, ref meshVecs, ref meshUVs, ref triList, materialList, list);
		}
		else
		{
			OQQDOCQOCO.OQDCOQDQDO(this, ref meshVecs, ref meshUVs, ref triList, materialList, list);
		}
		int num = 1;
		for (int i = 0; i < startConnectionV3.Count; i++)
		{
			for (int j = 0; j < startConnectionV3[i].Count; j++)
			{
				num++;
			}
		}
		int num2 = (prefabScript.lastVecRoadIndex = meshVecs.Count - 1);
		OQOQCCCDDQ.OQDCOQDQDO(this, ref meshVecs, ref meshUVs, ref triList, ref materialList);
		float num3 = 10000f;
		float num4 = -10000f;
		float num5 = 10000f;
		float num6 = -10000f;
		for (int k = 0; k <= num2; k++)
		{
			if (meshVecs[k].x < num3)
			{
				num3 = meshVecs[k].x;
			}
			if (meshVecs[k].x > num4)
			{
				num4 = meshVecs[k].x;
			}
			if (meshVecs[k].z < num5)
			{
				num5 = meshVecs[k].z;
			}
			if (meshVecs[k].z > num6)
			{
				num6 = meshVecs[k].z;
			}
		}
		float num7 = num4 - num3;
		float num8 = num6 - num5;
		List<Vector2> list2 = new List<Vector2>();
		for (int l = 0; l < meshVecs.Count; l++)
		{
			list2.Add(new Vector2((meshVecs[l].x - num3) / num7, (meshVecs[l].z - num5) / num8));
		}
		mesh.Clear();
		mesh.subMeshCount = triList.Count;
		mesh.vertices = meshVecs.ToArray();
		mesh.uv = meshUVs.ToArray();
		mesh.uv4 = list2.ToArray();
		mesh.tangents = new Vector4[mesh.vertices.Length];
		for (int m = 0; m < triList.Count; m++)
		{
			mesh.SetTriangles(triList[m].ToArray(), m);
		}
		mesh.RecalculateBounds();
		mesh.RecalculateNormals();
		mesh.name = "mesh";
		mesh.normals = ERSideWalkVecs.OODDQOQDCC(this, mesh.normals);
		ODCCODOCQQ.OCDCQCOQQO(mesh);
		mesh.tangents = ERSideWalkVecs.AdjustSidewalkTangents(this, mesh.tangents);
		base.gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
		base.gameObject.GetComponent<MeshRenderer>().sharedMaterials = materialList.ToArray();
		prefabScript.meshVecs = meshVecs.ToArray();
		prefabScript.tmpMeshVecs = new Vector3[prefabScript.meshVecs.Length];
		Array.Copy(prefabScript.meshVecs, prefabScript.tmpMeshVecs, prefabScript.meshVecs.Length);
		prefabScript.tmpFullMeshVecs = new Vector3[prefabScript.meshVecs.Length];
		Array.Copy(prefabScript.meshVecs, prefabScript.tmpFullMeshVecs, prefabScript.meshVecs.Length);
		prefabScript.fullMeshVecs = new Vector3[prefabScript.meshVecs.Length];
		Array.Copy(prefabScript.meshVecs, prefabScript.fullMeshVecs, prefabScript.meshVecs.Length);
		prefabScript.tCrossingTmpFullMeshVecs = new Vector3[prefabScript.meshVecs.Length];
		Array.Copy(prefabScript.meshVecs, prefabScript.tCrossingTmpFullMeshVecs, prefabScript.meshVecs.Length);
		prefabScript.tCrossing = tCrossing;
		prefabScript.tStraightBending = tStraightBending;
		prefabScript.tCrossingLeftRight = tCrossingLeftRight;
		prefabScript.planarUVs = planarUVs;
		prefabScript.planarTiling = planarTiling;
		int index = Mathf.RoundToInt(Mathf.Floor((float)startConnectionV3.Count * 0.5f));
		prefabScript.crossingElements[0].centerPoint = (prefabScript.crossingElements[0].tmpCenterPoint = startConnectionV3[index][0]);
		index = Mathf.RoundToInt(Mathf.Floor((float)endConnectionV3.Count * 0.5f));
		prefabScript.crossingElements[1].centerPoint = (prefabScript.crossingElements[1].tmpCenterPoint = endConnectionV3[index][0]);
		if (!tCrossing || tCrossingLeftRight == 0)
		{
			index = Mathf.RoundToInt(Mathf.Floor((float)leftConnectionV3.Count * 0.5f));
			prefabScript.crossingElements[2].centerPoint = (prefabScript.crossingElements[2].tmpCenterPoint = leftConnectionV3[index][0]);
		}
		else
		{
			prefabScript.crossingElements[2].centerPoint = (prefabScript.crossingElements[2].tmpCenterPoint = Vector3.zero);
		}
		if (!tCrossing || tCrossingLeftRight == 1)
		{
			index = Mathf.RoundToInt(Mathf.Floor((float)rightConnectionV3.Count * 0.5f));
			prefabScript.crossingElements[3].centerPoint = (prefabScript.crossingElements[3].tmpCenterPoint = rightConnectionV3[index][0]);
		}
		else
		{
			prefabScript.crossingElements[3].centerPoint = (prefabScript.crossingElements[3].tmpCenterPoint = Vector3.zero);
		}
		prefabScript.crossingElements[0].controlPointV3 = Vector3.zero;
		prefabScript.crossingElements[1].controlPointV3 = Vector3.zero;
		prefabScript.crossingElements[2].controlPointV3 = Vector3.zero;
		prefabScript.crossingElements[3].controlPointV3 = Vector3.zero;
		prefabScript.crossingElements[0].leftRoadpoint = startConnectionV3[0][0];
		prefabScript.crossingElements[0].rightRoadpoint = startConnectionV3[startConnectionV3.Count - 1][0];
		prefabScript.crossingElements[1].leftRoadpoint = endConnectionV3[0][0];
		prefabScript.crossingElements[1].rightRoadpoint = endConnectionV3[endConnectionV3.Count - 1][0];
		if (!tCrossing || tCrossingLeftRight == 0)
		{
			prefabScript.crossingElements[2].leftRoadpoint = leftConnectionV3[0][0];
			prefabScript.crossingElements[2].rightRoadpoint = leftConnectionV3[leftConnectionV3.Count - 1][0];
		}
		else
		{
			prefabScript.crossingElements[2].leftRoadpoint = Vector3.zero;
			prefabScript.crossingElements[2].rightRoadpoint = Vector3.zero;
		}
		if (!tCrossing || tCrossingLeftRight == 1)
		{
			prefabScript.crossingElements[3].leftRoadpoint = rightConnectionV3[0][0];
			prefabScript.crossingElements[3].rightRoadpoint = rightConnectionV3[rightConnectionV3.Count - 1][0];
		}
		else
		{
			prefabScript.crossingElements[3].leftRoadpoint = Vector3.zero;
			prefabScript.crossingElements[3].rightRoadpoint = Vector3.zero;
		}
		OQCQQCQDCQ(0, startConnectionTris, uvArrayFront, leftSidewalkStartTris, rightSidewalkStartTris, 0);
		OQCQQCQDCQ(1, endConnectionTris, uvArrayBack, leftSidewalkEndTris, rightSidewalkEndTris, 1);
		if (!tCrossing || tCrossingLeftRight == 0)
		{
			OQCQQCQDCQ(2, leftConnectionTris, uvArrayLeft, leftSidewalkLeftTris, rightSidewalkLeftTris, 0);
		}
		if (!tCrossing || tCrossingLeftRight == 1)
		{
			OQCQQCQDCQ(3, rightConnectionTris, uvArrayRight, leftSidewalkRightTris, rightSidewalkRightTris, 1);
		}
		OCDDOCDDOQ(meshVecs, prefabScript.crossingElements[0].connectionVecInts, ref prefabScript.crossingElements[0].roadShapeVecs, startConnectionV3, leftSidewalkStartV3, rightSidewalkStartV3, 0, 0);
		prefabScript.crossingElements[0].roadShapeVecsString = GetRoadShapeVecString(prefabScript.crossingElements[0].roadShapeVecs, prefabScript.crossingElements[0].sidewalkLeftVecs, prefabScript.crossingElements[0].sidewalkRightVecs, ref prefabScript.crossingElements[0].roadShapeMatchCount);
		OCDDOCDDOQ(meshVecs, prefabScript.crossingElements[1].connectionVecInts, ref prefabScript.crossingElements[1].roadShapeVecs, endConnectionV3, leftSidewalkEndV3, rightSidewalkEndV3, 1, 1);
		prefabScript.crossingElements[1].roadShapeVecsString = GetRoadShapeVecString(prefabScript.crossingElements[1].roadShapeVecs, prefabScript.crossingElements[1].sidewalkLeftVecs, prefabScript.crossingElements[1].sidewalkRightVecs, ref prefabScript.crossingElements[1].roadShapeMatchCount);
		if (!tCrossing || tCrossingLeftRight == 0)
		{
			OCDDOCDDOQ(meshVecs, prefabScript.crossingElements[2].connectionVecInts, ref prefabScript.crossingElements[2].roadShapeVecs, leftConnectionV3, leftSidewalkLeftV3, rightSidewalkLeftV3, 2, 0);
			prefabScript.crossingElements[2].roadShapeVecsString = GetRoadShapeVecString(prefabScript.crossingElements[2].roadShapeVecs, prefabScript.crossingElements[2].sidewalkLeftVecs, prefabScript.crossingElements[2].sidewalkRightVecs, ref prefabScript.crossingElements[2].roadShapeMatchCount);
			if (tCrossing)
			{
				prefabScript.crossingElements[3].roadShapeMatchCount = -1;
			}
		}
		if (!tCrossing || tCrossingLeftRight == 1)
		{
			OCDDOCDDOQ(meshVecs, prefabScript.crossingElements[3].connectionVecInts, ref prefabScript.crossingElements[3].roadShapeVecs, rightConnectionV3, leftSidewalkRightV3, rightSidewalkRightV3, 3, 1);
			prefabScript.crossingElements[3].roadShapeVecsString = GetRoadShapeVecString(prefabScript.crossingElements[3].roadShapeVecs, prefabScript.crossingElements[3].sidewalkLeftVecs, prefabScript.crossingElements[3].sidewalkRightVecs, ref prefabScript.crossingElements[3].roadShapeMatchCount);
			if (tCrossing)
			{
				prefabScript.crossingElements[2].roadShapeMatchCount = -1;
			}
		}
		prefabScript.crossingElements[0].alignmentHandleVec = Vector3.zero;
		prefabScript.crossingElements[1].alignmentHandleVec = Vector3.zero;
		prefabScript.crossingElements[2].alignmentHandleVec = Vector3.zero;
		prefabScript.crossingElements[3].alignmentHandleVec = Vector3.zero;
		ODQCODQDDQ(0, frontRoadMaterial, 0, 1, leftSidewalkStartV3.Count, rightSidewalkStartV3.Count);
		ODQCODQDDQ(1, backRoadMaterial, 3, 2, leftSidewalkEndV3.Count, rightSidewalkEndV3.Count);
		if (!tCrossing || tCrossingLeftRight == 0)
		{
			ODQCODQDDQ(2, leftRoadMaterial, 2, 0, leftSidewalkLeftV3.Count, rightSidewalkLeftV3.Count);
		}
		if (!tCrossing || tCrossingLeftRight == 1)
		{
			ODQCODQDDQ(3, rightRoadMaterial, 1, 3, leftSidewalkRightV3.Count, rightSidewalkRightV3.Count);
		}
		ODCCCQCQOO();
		if (prefabScript.doTerrainDeformation)
		{
			prefabScript.OQQODODQCQ();
		}
		prefabScript.tmpSurfaceVecsTCrossings = new Vector3[prefabScript.surfaceMeshVecs.Length];
		Array.Copy(prefabScript.surfaceMeshVecs, prefabScript.tmpSurfaceVecsTCrossings, prefabScript.surfaceMeshVecs.Length);
		OCCODQDOCO();
		OQCOOQQOOD();
		if (roadTypesDynamic.Count >= 1)
		{
			if (frontRoadTypeInt > 0)
			{
				if (prefabScript.crossingElements[0].roadType != roadTypesDynamic[frontRoadTypeInt - 1].id)
				{
					frontRoadTypeID = roadTypesDynamic[frontRoadTypeInt - 1].id;
					prefabScript.crossingElements[0].roadType = frontRoadTypeID;
					prefabScript.crossingElements[0].roadTypeTimestamp = roadTypesDynamic[frontRoadTypeInt - 1].timestamp;
				}
			}
			else
			{
				prefabScript.crossingElements[0].roadType = 0.0;
			}
			if (backRoadTypeInt == 0 && (connectionHandling == 0 || connectionHandling == 1))
			{
				backRoadTypeInt = frontRoadTypeInt;
			}
			if (backRoadTypeInt > 0)
			{
				if (prefabScript.crossingElements[1].roadType != roadTypesDynamic[backRoadTypeInt - 1].id)
				{
					backRoadTypeID = roadTypesDynamic[backRoadTypeInt - 1].id;
					prefabScript.crossingElements[1].roadType = backRoadTypeID;
					prefabScript.crossingElements[1].roadTypeTimestamp = roadTypesDynamic[backRoadTypeInt - 1].timestamp;
				}
			}
			else
			{
				prefabScript.crossingElements[1].roadType = 0.0;
			}
			if (leftRoadTypeInt == 0 && connectionHandling == 0)
			{
				leftRoadTypeInt = frontRoadTypeInt;
			}
			if (leftRoadTypeInt != 0)
			{
				if (prefabScript.crossingElements[2].roadType != roadTypesDynamic[leftRoadTypeInt - 1].id)
				{
					leftRoadTypeID = roadTypesDynamic[leftRoadTypeInt - 1].id;
					prefabScript.crossingElements[2].roadType = leftRoadTypeID;
					prefabScript.crossingElements[2].roadTypeTimestamp = roadTypesDynamic[leftRoadTypeInt - 1].timestamp;
				}
			}
			else
			{
				prefabScript.crossingElements[2].roadType = 0.0;
			}
			if (rightRoadTypeInt == 0 && (connectionHandling == 0 || connectionHandling == 1))
			{
				rightRoadTypeInt = leftRoadTypeInt;
			}
			if (rightRoadTypeInt != 0)
			{
				if (prefabScript.crossingElements[3].roadType != roadTypesDynamic[rightRoadTypeInt - 1].id)
				{
					rightRoadTypeID = roadTypesDynamic[rightRoadTypeInt - 1].id;
					prefabScript.crossingElements[3].roadType = rightRoadTypeID;
					prefabScript.crossingElements[3].roadTypeTimestamp = roadTypesDynamic[rightRoadTypeInt - 1].timestamp;
				}
			}
			else
			{
				prefabScript.crossingElements[3].roadType = 0.0;
			}
		}
		if (rebuildRoads)
		{
			prefabScript.OQOQDDOCDC(ignorePriority: true, null);
		}
	}

	public void OQCQQCQDCQ(int el, List<List<int>> trIntArray, List<float> uvArray, List<List<int>> leftSidewalkIntArray, List<List<int>> rightSidewalkIntArray, int startend)
	{
		QDOODOQQDQODD qDOODOQQDQODD = prefabScript.crossingElements[el];
		qDOODOQQDQODD.connectionVecInts.Clear();
		qDOODOQQDQODD.blendCornerPointInts.Clear();
		qDOODOQQDQODD.blendCornerPointWeights.Clear();
		qDOODOQQDQODD.roadShapeUVY.Clear();
		QDOQDSQOOQDDD qDOQDSQOOQDDD = null;
		QDOQDSQOOQDDD qDOQDSQOOQDDD2 = null;
		switch (el)
		{
		case 0:
			qDOQDSQOOQDDD = prefabScript.sidewalkControlElements[0];
			qDOQDSQOOQDDD2 = prefabScript.sidewalkControlElements[1];
			break;
		case 1:
			qDOQDSQOOQDDD = prefabScript.sidewalkControlElements[3];
			qDOQDSQOOQDDD2 = prefabScript.sidewalkControlElements[2];
			qDOQDSQOOQDDD2 = prefabScript.sidewalkControlElements[0];
			break;
		case 2:
			qDOQDSQOOQDDD = prefabScript.sidewalkControlElements[2];
			qDOQDSQOOQDDD2 = prefabScript.sidewalkControlElements[0];
			break;
		case 3:
			qDOQDSQOOQDDD = prefabScript.sidewalkControlElements[1];
			qDOQDSQOOQDDD2 = prefabScript.sidewalkControlElements[3];
			break;
		}
		qDOODOQQDQODD.sidewalkLeftUVY.Clear();
		qDOODOQQDQODD.sidewalkLeftConnectionVecInts.Clear();
		if (qDOODOQQDQODD.includeLeftSidewalk)
		{
			for (int i = 0; i < leftSidewalkIntArray.Count; i++)
			{
				qDOODOQQDQODD.sidewalkLeftConnectionVecInts.Add(leftSidewalkIntArray[i][0]);
			}
			qDOODOQQDQODD.sidewalkLeftConnectionVecInts.Reverse();
			qDOODOQQDQODD.sidewalkLeftUVY.AddRange(qDOQDSQOOQDDD.sidewalkUVs);
			qDOODOQQDQODD.sidewalkLeftUVY.Reverse();
		}
		qDOODOQQDQODD.connectionVecInts.Add(trIntArray[0][0]);
		qDOODOQQDQODD.connectionVecInts.Add(trIntArray[trIntArray.Count - 1][0]);
		qDOODOQQDQODD.roadShapeUVY.Add(uvArray[0]);
		qDOODOQQDQODD.roadShapeUVY.Add(uvArray[uvArray.Count - 1]);
		if (startend == 1)
		{
			qDOODOQQDQODD.roadShapeUVY[0] = 1f - qDOODOQQDQODD.roadShapeUVY[0];
			qDOODOQQDQODD.roadShapeUVY[1] = 1f - qDOODOQQDQODD.roadShapeUVY[1];
		}
		qDOODOQQDQODD.sidewalkRightUVY.Clear();
		qDOODOQQDQODD.sidewalkRightConnectionVecInts.Clear();
		if (qDOODOQQDQODD.includeRightSidewalk)
		{
			for (int j = 0; j < rightSidewalkIntArray.Count; j++)
			{
				qDOODOQQDQODD.sidewalkRightConnectionVecInts.Add(rightSidewalkIntArray[j][0]);
			}
			qDOODOQQDQODD.sidewalkRightUVY.AddRange(qDOQDSQOOQDDD2.sidewalkUVs);
		}
		qDOODOQQDQODD.connectionVecInts.InsertRange(0, qDOODOQQDQODD.sidewalkLeftConnectionVecInts);
		qDOODOQQDQODD.connectionVecInts.AddRange(qDOODOQQDQODD.sidewalkRightConnectionVecInts);
		qDOODOQQDQODD.fullConnectionVecInts = new List<int>(qDOODOQQDQODD.connectionVecInts);
		qDOODOQQDQODD.leftInt = 0;
		qDOODOQQDQODD.leftIntFull = 0;
		qDOODOQQDQODD.rightInt = qDOODOQQDQODD.connectionVecInts.Count - 1;
		qDOODOQQDQODD.rightIntFull = qDOODOQQDQODD.fullConnectionVecInts.Count - 1;
		if (startend != 1)
		{
		}
	}

	public void ODQCODQDDQ(int el, Material roadMaterial, int leftCorner, int rightCorner, int leftVecCount, int rightVecCount)
	{
		QDOODOQQDQODD qDOODOQQDQODD = prefabScript.crossingElements[el];
		QDOQDSQOOQDDD qDOQDSQOOQDDD = prefabScript.sidewalkControlElements[leftCorner];
		QDOQDSQOOQDDD qDOQDSQOOQDDD2 = prefabScript.sidewalkControlElements[rightCorner];
		qDOODOQQDQODD.roadMaterial = roadMaterial;
		List<Material> list = new List<Material>();
		List<int> list2 = new List<int>();
		list.Add(roadMaterial);
		if (qDOODOQQDQODD.includeLeftSidewalk)
		{
			if (list[0] != qDOQDSQOOQDDD.sidewalkMaterial)
			{
				list.Add(qDOQDSQOOQDDD.sidewalkMaterial);
				for (int i = 0; i < leftVecCount; i++)
				{
					list2.Add(1);
				}
			}
			else
			{
				for (int j = 0; j < leftVecCount; j++)
				{
					list2.Add(0);
				}
			}
		}
		list2.Add(0);
		list2.Add(0);
		if (qDOODOQQDQODD.includeRightSidewalk)
		{
			if (list[0] != qDOQDSQOOQDDD2.sidewalkMaterial && qDOQDSQOOQDDD.sidewalkMaterial != qDOQDSQOOQDDD2.sidewalkMaterial && qDOODOQQDQODD.includeLeftSidewalk)
			{
				list.Add(qDOQDSQOOQDDD2.sidewalkMaterial);
				for (int k = 0; k < rightVecCount; k++)
				{
					list2.Add(2);
				}
			}
			else if (list[0] == qDOQDSQOOQDDD2.sidewalkMaterial)
			{
				for (int l = 0; l < rightVecCount; l++)
				{
					list2.Add(0);
				}
			}
			else if (qDOQDSQOOQDDD.sidewalkMaterial == qDOQDSQOOQDDD2.sidewalkMaterial || !qDOODOQQDQODD.includeLeftSidewalk)
			{
				if (!qDOODOQQDQODD.includeLeftSidewalk)
				{
					list.Add(qDOQDSQOOQDDD2.sidewalkMaterial);
				}
				for (int m = 0; m < rightVecCount; m++)
				{
					list2.Add(1);
				}
			}
		}
		qDOODOQQDQODD.roadMaterials = list.ToArray();
		qDOODOQQDQODD.roadShapeMaterialInts.Clear();
		qDOODOQQDQODD.roadShapeMaterialInts.AddRange(list2);
		switch (el)
		{
		case 0:
			qDOODOQQDQODD.alignmentHandleVec = Vector3.Lerp(Vector3.zero, startConnectionV3[2][0], 0.5f);
			break;
		case 1:
			qDOODOQQDQODD.alignmentHandleVec = Vector3.Lerp(Vector3.zero, endConnectionV3[2][0], 0.5f);
			break;
		case 2:
			qDOODOQQDQODD.alignmentHandleVec = Vector3.Lerp(Vector3.zero, leftConnectionV3[2][0], 0.5f);
			break;
		case 3:
			qDOODOQQDQODD.alignmentHandleVec = Vector3.Lerp(Vector3.zero, rightConnectionV3[2][0], 0.5f);
			break;
		}
	}

	public void OCDDOCDDOQ(List<Vector3> meshVecs, List<int> connectionVecInts, ref List<Vector2> roadShapeVecs, List<List<Vector3>> vecArrays, List<List<Vector3>> leftSidewalkArray, List<List<Vector3>> rightSidewalkArray, int connectionElement, int startend)
	{
		QDOODOQQDQODD qDOODOQQDQODD = prefabScript.crossingElements[connectionElement];
		roadShapeVecs.Clear();
		qDOODOQQDQODD.sidewalkLeftVecs.Clear();
		qDOODOQQDQODD.sidewalkRightVecs.Clear();
		Vector3 zero;
		Vector3 vector = (zero = Vector3.zero);
		Vector3 vector2 = vecArrays[0][0];
		Vector3 b = vecArrays[vecArrays.Count - 1][0];
		vector2.y = 0f;
		b.y = 0f;
		Vector3 vector3 = Vector3.Lerp(vector2, b, 0.5f);
		float num = Vector3.Distance(vector2, vector3);
		for (int i = 0; i < connectionVecInts.Count - 1; i++)
		{
		}
		List<Vector3> list = new List<Vector3>();
		if (qDOODOQQDQODD.includeLeftSidewalk)
		{
			for (int j = 0; j < leftSidewalkArray.Count; j++)
			{
				list.Add(leftSidewalkArray[j][0]);
			}
			list.Reverse();
			vector = list[0];
			vector2 = vector;
			vector2.y = 0f;
			num = Vector3.Distance(vector2, vector3);
			ODOODQDCCQ(list, ref qDOODOQQDQODD.sidewalkLeftVecs, vector3, vector2, num);
		}
		list.Clear();
		list.Add(vecArrays[0][0]);
		list.Add(vecArrays[vecArrays.Count - 1][0]);
		if (vector == Vector3.zero)
		{
			vector = list[0];
		}
		zero = list[list.Count - 1];
		ODOODQDCCQ(list, ref roadShapeVecs, vector3, vector2, num);
		if (qDOODOQQDQODD.includeRightSidewalk)
		{
			list.Clear();
			for (int k = 0; k < rightSidewalkArray.Count; k++)
			{
				list.Add(rightSidewalkArray[k][0]);
			}
			zero = list[list.Count - 1];
			ODOODQDCCQ(list, ref qDOODOQQDQODD.sidewalkRightVecs, vector3, vector2, num);
		}
		vector.y = 0f;
		zero.y = 0f;
		float num2 = Vector3.Distance(vector, zero);
		qDOODOQQDQODD.centerPointPercentage = num / num2;
	}

	public static void ODOODQDCCQ(List<Vector3> sourceVecs, ref List<Vector2> roadShapeVecs, Vector3 centerPoint, Vector3 startPoint, float halfWayDistance)
	{
		Vector2 zero = Vector2.zero;
		for (int i = 0; i < sourceVecs.Count; i++)
		{
			Vector3 vector = sourceVecs[i];
			float y = vector.y;
			vector.y = 0f;
			zero.x = Vector3.Distance(vector, centerPoint);
			if (Vector3.Distance(startPoint, vector) < halfWayDistance)
			{
				zero.x *= -1f;
			}
			zero.y = y;
			roadShapeVecs.Add(zero);
		}
	}

	public static string GetRoadShapeVecString(List<Vector2> vecs, List<Vector2> lvecs, List<Vector2> rvecs, ref int matchCount)
	{
		List<Vector2> list = new List<Vector2>(lvecs);
		list.AddRange(vecs);
		list.AddRange(rvecs);
		matchCount = 0;
		string text = "";
		bool flag = true;
		for (int i = 0; i < list.Count; i++)
		{
			flag = true;
			if (i > 0 && (double)Vector2.Distance(list[i - 1], list[i]) < 0.01)
			{
				flag = false;
			}
			if (flag)
			{
				Vector2 vector = list[i];
				vector.x = (float)Math.Round(vector.x, 1, MidpointRounding.AwayFromZero);
				vector.y = (float)Math.Round(vector.y, 1, MidpointRounding.AwayFromZero);
				text = text + vector.x + ", " + vector.y + ";";
				matchCount++;
			}
		}
		return text;
	}

	public void ODCCCQCQOO()
	{
		prefabScript.surfaceInts = new int[16];
		List<int> list = new List<int>();
		if (prefabScript.sidewalkControlElements[0].renderFlag)
		{
			List<int> list2 = rightSidewalkStartTris[rightSidewalkStartTris.Count - 1];
			prefabScript.surfaceInts[2] = list2[list2.Count - 1];
			prefabScript.surfaceInts[3] = list2[0];
			if (!tCrossing || tCrossingLeftRight == 1)
			{
				list2 = leftSidewalkRightTris[leftSidewalkRightTris.Count - 1];
				prefabScript.surfaceInts[12] = list2[list2.Count - 1];
				prefabScript.surfaceInts[13] = list2[0];
			}
			else
			{
				list.AddRange(list2);
				list2.Clear();
				list2.AddRange(leftSidewalkEndTris[leftSidewalkEndTris.Count - 1]);
				prefabScript.surfaceInts[12] = list2[list2.Count - 1];
				prefabScript.surfaceInts[13] = list2[0];
				list2.Reverse();
				list.AddRange(list2);
			}
		}
		else
		{
			List<int> list2 = startConnectionTris[startConnectionTris.Count - 1];
			prefabScript.surfaceInts[2] = list2[list2.Count - 1];
			prefabScript.surfaceInts[3] = list2[0];
			if (!tCrossing || tCrossingLeftRight == 1)
			{
				list2 = rightConnectionTris[0];
				prefabScript.surfaceInts[12] = list2[list2.Count - 1];
				prefabScript.surfaceInts[13] = list2[0];
			}
			else
			{
				list.AddRange(list2);
				list2.Clear();
				list2.AddRange(endConnectionTris[0]);
				prefabScript.surfaceInts[12] = list2[list2.Count - 1];
				prefabScript.surfaceInts[13] = list2[0];
				list2.Reverse();
				list.AddRange(list2);
			}
		}
		if (prefabScript.sidewalkControlElements[1].renderFlag)
		{
			List<int> list2 = leftSidewalkStartTris[leftSidewalkStartTris.Count - 1];
			prefabScript.surfaceInts[0] = list2[list2.Count - 1];
			prefabScript.surfaceInts[1] = list2[0];
			if (!tCrossing || tCrossingLeftRight == 0)
			{
				list2 = rightSidewalkLeftTris[rightSidewalkLeftTris.Count - 1];
				prefabScript.surfaceInts[10] = list2[list2.Count - 1];
				prefabScript.surfaceInts[11] = list2[0];
			}
			else
			{
				list.AddRange(list2);
				list2.Clear();
				list2.AddRange(rightSidewalkEndTris[rightSidewalkEndTris.Count - 1]);
				prefabScript.surfaceInts[10] = list2[list2.Count - 1];
				prefabScript.surfaceInts[11] = list2[0];
				list2.Reverse();
				list.AddRange(list2);
			}
		}
		else
		{
			List<int> list2 = startConnectionTris[0];
			prefabScript.surfaceInts[0] = list2[list2.Count - 1];
			prefabScript.surfaceInts[1] = list2[0];
			if (!tCrossing || tCrossingLeftRight == 0)
			{
				list2 = leftConnectionTris[leftConnectionTris.Count - 1];
				prefabScript.surfaceInts[10] = list2[list2.Count - 1];
				prefabScript.surfaceInts[11] = list2[0];
			}
			else
			{
				list.AddRange(list2);
				list2.Clear();
				list2.AddRange(endConnectionTris[endConnectionTris.Count - 1]);
				prefabScript.surfaceInts[10] = list2[list2.Count - 1];
				prefabScript.surfaceInts[11] = list2[0];
				list2.Reverse();
				list.AddRange(list2);
			}
		}
		if (prefabScript.sidewalkControlElements[2].renderFlag)
		{
			List<int> list2 = rightSidewalkEndTris[rightSidewalkEndTris.Count - 1];
			prefabScript.surfaceInts[4] = list2[list2.Count - 1];
			prefabScript.surfaceInts[5] = list2[0];
			if (!tCrossing || tCrossingLeftRight == 0)
			{
				list2 = leftSidewalkLeftTris[leftSidewalkLeftTris.Count - 1];
				prefabScript.surfaceInts[8] = list2[list2.Count - 1];
				prefabScript.surfaceInts[9] = list2[0];
			}
			else
			{
				list2 = leftSidewalkStartTris[leftSidewalkStartTris.Count - 1];
				prefabScript.surfaceInts[8] = list2[list2.Count - 1];
				prefabScript.surfaceInts[9] = list2[0];
			}
		}
		else
		{
			List<int> list2 = endConnectionTris[endConnectionTris.Count - 1];
			prefabScript.surfaceInts[4] = list2[list2.Count - 1];
			prefabScript.surfaceInts[5] = list2[0];
			if (!tCrossing || tCrossingLeftRight == 0)
			{
				list2 = leftConnectionTris[0];
				prefabScript.surfaceInts[8] = list2[list2.Count - 1];
				prefabScript.surfaceInts[9] = list2[0];
			}
			else
			{
				list2 = startConnectionTris[0];
				prefabScript.surfaceInts[8] = list2[list2.Count - 1];
				prefabScript.surfaceInts[9] = list2[0];
			}
		}
		if (prefabScript.sidewalkControlElements[3].renderFlag)
		{
			List<int> list2 = leftSidewalkEndTris[leftSidewalkEndTris.Count - 1];
			prefabScript.surfaceInts[6] = list2[list2.Count - 1];
			prefabScript.surfaceInts[7] = list2[0];
			if (!tCrossing || tCrossingLeftRight == 1)
			{
				list2 = rightSidewalkRightTris[rightSidewalkRightTris.Count - 1];
				prefabScript.surfaceInts[14] = list2[list2.Count - 1];
				prefabScript.surfaceInts[15] = list2[0];
			}
			else
			{
				list2 = rightSidewalkStartTris[rightSidewalkStartTris.Count - 1];
				prefabScript.surfaceInts[14] = list2[list2.Count - 1];
				prefabScript.surfaceInts[15] = list2[0];
			}
		}
		else
		{
			List<int> list2 = endConnectionTris[0];
			prefabScript.surfaceInts[6] = list2[list2.Count - 1];
			prefabScript.surfaceInts[7] = list2[0];
			if (!tCrossing || tCrossingLeftRight == 1)
			{
				list2 = rightConnectionTris[rightConnectionTris.Count - 1];
				prefabScript.surfaceInts[14] = list2[list2.Count - 1];
				prefabScript.surfaceInts[15] = list2[0];
			}
			else
			{
				list2 = startConnectionTris[startConnectionTris.Count - 1];
				prefabScript.surfaceInts[14] = list2[list2.Count - 1];
				prefabScript.surfaceInts[15] = list2[0];
			}
		}
		if (tCrossing)
		{
			List<int> collection = new List<int>(prefabScript.surfaceInts);
			list.InsertRange(0, collection);
			prefabScript.surfaceInts = list.ToArray();
		}
	}

	public void ODCDCDDOCC(List<SidewalkPresetClass> sidewalkPresets, int el)
	{
		selectedSidewalkPreset = el;
		if (!uniformCornersFlag)
		{
			prefabScript.sidewalkControlElements[selectedCorner].sidewalkWidth1 = sidewalkPresets[selectedSidewalkPreset - 1].sidewalkWidth1;
			prefabScript.sidewalkControlElements[selectedCorner].sidewalkWidth2 = sidewalkPresets[selectedSidewalkPreset - 1].sidewalkWidth2;
			prefabScript.sidewalkControlElements[selectedCorner].curbHeight = sidewalkPresets[selectedSidewalkPreset - 1].curbHeight;
			prefabScript.sidewalkControlElements[selectedCorner].curbDepth = sidewalkPresets[selectedSidewalkPreset - 1].curbDepth;
			prefabScript.sidewalkControlElements[selectedCorner].beveledCurb = sidewalkPresets[selectedSidewalkPreset - 1].beveledCurb;
			prefabScript.sidewalkControlElements[selectedCorner].beveledHeight = sidewalkPresets[selectedSidewalkPreset - 1].beveledHeight;
			prefabScript.sidewalkControlElements[selectedCorner].beveledDepth = sidewalkPresets[selectedSidewalkPreset - 1].beveledDepth;
			prefabScript.sidewalkControlElements[selectedCorner].outerCurb = sidewalkPresets[selectedSidewalkPreset - 1].outerCurb;
			prefabScript.sidewalkControlElements[selectedCorner].roadSideCurbUVControl = sidewalkPresets[selectedSidewalkPreset - 1].roadSideCurbUVControl;
			prefabScript.sidewalkControlElements[selectedCorner].outerSideCurbUVControl = sidewalkPresets[selectedSidewalkPreset - 1].outerSideCurbUVControl;
			prefabScript.sidewalkControlElements[selectedCorner].sidewalkMaterial = sidewalkPresets[selectedSidewalkPreset - 1].sidewalkMaterial;
			prefabScript.sidewalkControlElements[selectedCorner].sidewalkUVs.Clear();
			prefabScript.sidewalkControlElements[selectedCorner].sidewalkUVs.AddRange(sidewalkPresets[selectedSidewalkPreset - 1].sidewalkUVs);
			prefabScript.sidewalkControlElements[selectedCorner].curbUVs.Clear();
			prefabScript.sidewalkControlElements[selectedCorner].curbUVs.AddRange(sidewalkPresets[selectedSidewalkPreset - 1].curbUVs);
			prefabScript.sidewalkControlElements[selectedCorner].lockUVs = sidewalkPresets[selectedSidewalkPreset - 1].lockUVs;
			return;
		}
		for (int i = 0; i < prefabScript.sidewalkControlElements.Count; i++)
		{
			prefabScript.sidewalkControlElements[i].sidewalkWidth1 = sidewalkPresets[selectedSidewalkPreset - 1].sidewalkWidth1;
			prefabScript.sidewalkControlElements[i].sidewalkWidth2 = sidewalkPresets[selectedSidewalkPreset - 1].sidewalkWidth2;
			prefabScript.sidewalkControlElements[i].curbHeight = sidewalkPresets[selectedSidewalkPreset - 1].curbHeight;
			prefabScript.sidewalkControlElements[i].curbDepth = sidewalkPresets[selectedSidewalkPreset - 1].curbDepth;
			prefabScript.sidewalkControlElements[i].beveledCurb = sidewalkPresets[selectedSidewalkPreset - 1].beveledCurb;
			prefabScript.sidewalkControlElements[i].beveledHeight = sidewalkPresets[selectedSidewalkPreset - 1].beveledHeight;
			prefabScript.sidewalkControlElements[i].beveledDepth = sidewalkPresets[selectedSidewalkPreset - 1].beveledDepth;
			prefabScript.sidewalkControlElements[i].outerCurb = sidewalkPresets[selectedSidewalkPreset - 1].outerCurb;
			prefabScript.sidewalkControlElements[i].roadSideCurbUVControl = sidewalkPresets[selectedSidewalkPreset - 1].roadSideCurbUVControl;
			prefabScript.sidewalkControlElements[i].outerSideCurbUVControl = sidewalkPresets[selectedSidewalkPreset - 1].outerSideCurbUVControl;
			prefabScript.sidewalkControlElements[i].sidewalkMaterial = sidewalkPresets[selectedSidewalkPreset - 1].sidewalkMaterial;
			prefabScript.sidewalkControlElements[i].sidewalkUVs.Clear();
			prefabScript.sidewalkControlElements[i].sidewalkUVs.AddRange(sidewalkPresets[selectedSidewalkPreset - 1].sidewalkUVs);
			prefabScript.sidewalkControlElements[i].curbUVs.Clear();
			prefabScript.sidewalkControlElements[i].curbUVs.AddRange(sidewalkPresets[selectedSidewalkPreset - 1].curbUVs);
			prefabScript.sidewalkControlElements[i].lockUVs = sidewalkPresets[selectedSidewalkPreset - 1].lockUVs;
		}
	}

	public void OCCODQDOCO()
	{
		sidewalkControlPoints = new Vector3[12];
		prefabScript.sidewalkControlElements[0].centerHandleV3 = prefabScript.meshVecs[prefabScript.surfaceInts[2]];
		prefabScript.sidewalkControlElements[0].leftHandleV3 = prefabScript.meshVecs[prefabScript.surfaceInts[13]];
		prefabScript.sidewalkControlElements[0].rightHandleV3 = prefabScript.meshVecs[prefabScript.surfaceInts[3]];
		prefabScript.sidewalkControlElements[1].centerHandleV3 = prefabScript.meshVecs[prefabScript.surfaceInts[0]];
		prefabScript.sidewalkControlElements[1].leftHandleV3 = prefabScript.meshVecs[prefabScript.surfaceInts[1]];
		prefabScript.sidewalkControlElements[1].rightHandleV3 = prefabScript.meshVecs[prefabScript.surfaceInts[11]];
		prefabScript.sidewalkControlElements[2].centerHandleV3 = prefabScript.meshVecs[prefabScript.surfaceInts[4]];
		prefabScript.sidewalkControlElements[2].leftHandleV3 = prefabScript.meshVecs[prefabScript.surfaceInts[9]];
		prefabScript.sidewalkControlElements[2].rightHandleV3 = prefabScript.meshVecs[prefabScript.surfaceInts[5]];
		prefabScript.sidewalkControlElements[3].centerHandleV3 = prefabScript.meshVecs[prefabScript.surfaceInts[6]];
		prefabScript.sidewalkControlElements[3].leftHandleV3 = prefabScript.meshVecs[prefabScript.surfaceInts[7]];
		prefabScript.sidewalkControlElements[3].rightHandleV3 = prefabScript.meshVecs[prefabScript.surfaceInts[15]];
	}

	public void OQDOQDQQQQ(int el)
	{
		switch (el)
		{
		case 0:
			sidewalkControlStatus[1] = (sidewalkControlStatus[11] = sidewalkControlStatus[0]);
			prefabScript.crossingElements[0].includeRightSidewalk = sidewalkControlStatus[0];
			prefabScript.crossingElements[3].includeRightSidewalk = sidewalkControlStatus[0];
			break;
		case 1:
			if (sidewalkControlStatus[1])
			{
				sidewalkControlStatus[0] = true;
			}
			else if (!sidewalkControlStatus[1] && !sidewalkControlStatus[11])
			{
				sidewalkControlStatus[0] = false;
			}
			prefabScript.crossingElements[0].includeRightSidewalk = sidewalkControlStatus[1];
			break;
		case 2:
			if (sidewalkControlStatus[2])
			{
				sidewalkControlStatus[3] = true;
			}
			else if (!sidewalkControlStatus[2] && !sidewalkControlStatus[4])
			{
				sidewalkControlStatus[3] = false;
			}
			prefabScript.crossingElements[0].includeLeftSidewalk = sidewalkControlStatus[2];
			break;
		case 3:
			sidewalkControlStatus[2] = (sidewalkControlStatus[4] = sidewalkControlStatus[3]);
			prefabScript.crossingElements[0].includeLeftSidewalk = sidewalkControlStatus[3];
			prefabScript.crossingElements[2].includeRightSidewalk = sidewalkControlStatus[3];
			break;
		case 4:
			if (sidewalkControlStatus[4])
			{
				sidewalkControlStatus[3] = true;
			}
			else if (!sidewalkControlStatus[4] && !sidewalkControlStatus[2])
			{
				sidewalkControlStatus[3] = false;
			}
			prefabScript.crossingElements[2].includeRightSidewalk = sidewalkControlStatus[4];
			break;
		case 5:
			if (sidewalkControlStatus[5])
			{
				sidewalkControlStatus[6] = true;
			}
			else if (!sidewalkControlStatus[5] && !sidewalkControlStatus[7])
			{
				sidewalkControlStatus[6] = false;
			}
			prefabScript.crossingElements[2].includeLeftSidewalk = sidewalkControlStatus[5];
			break;
		case 6:
			sidewalkControlStatus[5] = (sidewalkControlStatus[7] = sidewalkControlStatus[6]);
			prefabScript.crossingElements[1].includeLeftSidewalk = sidewalkControlStatus[6];
			prefabScript.crossingElements[2].includeLeftSidewalk = sidewalkControlStatus[6];
			break;
		case 7:
			if (sidewalkControlStatus[7])
			{
				sidewalkControlStatus[6] = true;
			}
			else if (!sidewalkControlStatus[7] && !sidewalkControlStatus[5])
			{
				sidewalkControlStatus[6] = false;
			}
			prefabScript.crossingElements[1].includeLeftSidewalk = sidewalkControlStatus[7];
			break;
		case 8:
			if (sidewalkControlStatus[8])
			{
				sidewalkControlStatus[9] = true;
			}
			else if (!sidewalkControlStatus[8] && !sidewalkControlStatus[10])
			{
				sidewalkControlStatus[9] = false;
			}
			prefabScript.crossingElements[1].includeRightSidewalk = sidewalkControlStatus[8];
			break;
		case 9:
			sidewalkControlStatus[8] = (sidewalkControlStatus[10] = sidewalkControlStatus[9]);
			prefabScript.crossingElements[1].includeRightSidewalk = sidewalkControlStatus[9];
			prefabScript.crossingElements[3].includeLeftSidewalk = sidewalkControlStatus[9];
			break;
		case 10:
			if (sidewalkControlStatus[10])
			{
				sidewalkControlStatus[9] = true;
			}
			else if (!sidewalkControlStatus[10] && !sidewalkControlStatus[8])
			{
				sidewalkControlStatus[9] = false;
			}
			prefabScript.crossingElements[3].includeLeftSidewalk = sidewalkControlStatus[10];
			break;
		case 11:
			if (sidewalkControlStatus[11])
			{
				sidewalkControlStatus[0] = true;
			}
			else if (!sidewalkControlStatus[11] && !sidewalkControlStatus[1])
			{
				sidewalkControlStatus[0] = false;
			}
			prefabScript.crossingElements[3].includeRightSidewalk = sidewalkControlStatus[11];
			break;
		}
	}

	public void OODOQQQQCO()
	{
		if (prefabScript.sidewalkControlElements.Count != 4)
		{
			prefabScript.sidewalkControlElements.Clear();
			for (int i = 0; i < prefabScript.crossingElements.Count; i++)
			{
				prefabScript.sidewalkControlElements.Add(new QDOQDSQOOQDDD(UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase));
			}
		}
		prefabScript.sidewalkControlElements[0].crossingElementLeftIndex = 3;
		prefabScript.sidewalkControlElements[0].crossingElementRightIndex = 0;
		prefabScript.sidewalkControlElements[1].crossingElementLeftIndex = 0;
		prefabScript.sidewalkControlElements[1].crossingElementRightIndex = 2;
		prefabScript.sidewalkControlElements[2].crossingElementLeftIndex = 2;
		prefabScript.sidewalkControlElements[2].crossingElementRightIndex = 1;
		prefabScript.sidewalkControlElements[3].crossingElementLeftIndex = 1;
		prefabScript.sidewalkControlElements[3].crossingElementRightIndex = 3;
		if (tCrossing && tCrossingLeftRight == 1)
		{
			prefabScript.sidewalkControlElements[1].crossingElementRightIndex = 1;
		}
		else if (tCrossing && tCrossingLeftRight == 0)
		{
			prefabScript.sidewalkControlElements[0].crossingElementLeftIndex = 1;
		}
	}

	public void OQCOOQQOOD()
	{
		float num = 0f;
		QDOQDSQOOQDDD qDOQDSQOOQDDD = prefabScript.sidewalkControlElements[0];
		prefabScript.bottomLeftSidewalkWidth = qDOQDSQOOQDDD.sidewalkWidth1;
		prefabScript.bottomLeftSidewalkOuterOffset = qDOQDSQOOQDDD.sidewalkWidth1 - qDOQDSQOOQDDD.curbDepth;
		prefabScript.bottomLeftSidewalkCurbDepth = qDOQDSQOOQDDD.curbDepth;
		qDOQDSQOOQDDD = prefabScript.sidewalkControlElements[1];
		prefabScript.bottomRightSidewalkWidth = qDOQDSQOOQDDD.sidewalkWidth1;
		prefabScript.bottomRightSidewalkOuterOffset = qDOQDSQOOQDDD.sidewalkWidth1 - qDOQDSQOOQDDD.curbDepth;
		prefabScript.bottomRightSidewalkCurbDepth = qDOQDSQOOQDDD.curbDepth;
		qDOQDSQOOQDDD = prefabScript.sidewalkControlElements[2];
		prefabScript.topLeftSidewalkWidth = qDOQDSQOOQDDD.sidewalkWidth1;
		prefabScript.topLeftSidewalkOuterOffset = qDOQDSQOOQDDD.sidewalkWidth1 - qDOQDSQOOQDDD.curbDepth;
		prefabScript.topLeftSidewalkCurbDepth = qDOQDSQOOQDDD.curbDepth;
		qDOQDSQOOQDDD = prefabScript.sidewalkControlElements[3];
		prefabScript.topRightSidewalkWidth = qDOQDSQOOQDDD.sidewalkWidth1;
		prefabScript.topRightSidewalkOuterOffset = qDOQDSQOOQDDD.sidewalkWidth1 - qDOQDSQOOQDDD.curbDepth;
		prefabScript.topRightSidewalkCurbDepth = qDOQDSQOOQDDD.curbDepth;
	}

	public bool OQDOOCDOCD(ERModularRoad road, float angle)
	{
		float num = 40f;
		bool flag = false;
		if (primaryPriorityConnection == null && secondPriorityConnection == null && prioritySiblings.Count > 0 && road.roadType == prioritySiblings[0].roadType.id)
		{
			flag = true;
		}
		if (road.roadType <= 0.0)
		{
			return false;
		}
		QDQDOOQQDQODD roadTypeElByID = QDQDOOQQDQODD.GetRoadTypeElByID(road.baseScript.roadTypes, road.roadType);
		if (roadTypeElByID == null)
		{
			return false;
		}
		if (road.roadShape.Count != roadTypeElByID.roadShape.Count)
		{
			return false;
		}
		double num2 = 0.0;
		if (prioritySiblings.Count > 0)
		{
			num2 = prioritySiblings[0].roadType.id;
		}
		else
		{
			if (prefabScript.siblings.Count <= 0)
			{
				return true;
			}
			num2 = prefabScript.siblings[0].roadType.id;
		}
		List<ERConnectionSibling> list = new List<ERConnectionSibling>(prefabScript.siblings);
		list.Sort((ERConnectionSibling x, ERConnectionSibling y) => x.angle.CompareTo(y.angle));
		float num3 = 0f;
		float num4 = 0f;
		for (int num5 = 1; num5 < list.Count; num5++)
		{
			if (angle > list[num5 - 1].angle && angle < list[num5].angle)
			{
				if ((list[num5 - 1].roadType.id != num2 || list[num5].roadType.id != num2) && !flag)
				{
					return false;
				}
				if (list[num5].angle - angle < num)
				{
					return false;
				}
				if (angle - list[num5 - 1].angle < num)
				{
					return false;
				}
				return true;
			}
		}
		if ((list[list.Count - 1].roadType.id != num2 || list[0].roadType.id != num2) && !flag)
		{
			return false;
		}
		if (list[0].angle > angle)
		{
			if (list[0].angle - angle < num)
			{
				return false;
			}
			return true;
		}
		if (angle - list[list.Count - 1].angle < num)
		{
			return false;
		}
		return true;
	}
}
[Serializable]
public class QDOQDSQOOQDDD
{
	public int crossingElementLeftIndex = 0;

	public int crossingElementRightIndex = 0;

	public Vector3 centerHandleV3;

	public Vector3 centerHandleV3_2;

	public Vector3 leftHandleV3;

	public Vector3 rightHandleV3;

	public bool renderFlag = true;

	public bool leftConnectionHandle = true;

	public bool rightConnectionHandle = true;

	public float sidewalkWidth1 = 1.5f;

	public float sidewalkWidth2 = 1.5f;

	public float curbHeight = 0.25f;

	public float curbDepth = 0.25f;

	public bool beveledCurb = false;

	public float beveledHeight = 0f;

	public float beveledDepth = 0f;

	public bool outerCurb = false;

	public bool roadSideCurbUVControl = false;

	public bool outerSideCurbUVControl = false;

	public Material sidewalkMaterial;

	public List<float> sidewalkUVs = new List<float>();

	public List<float> curbUVs = new List<float>();

	public bool lockUVs = false;

	public float cornerRadius = 1f;

	public int cornerSegments = 5;

	public float innerSegmentDistance = 0.5f;

	public float startAngle = 0f;

	public QDOQDSQOOQDDD(ERModularBase scr)
	{
		if (scr != null)
		{
			sidewalkMaterial = scr.sidewalkMaterial;
		}
	}

	public void CopyFromSidewalk(ERSideWalk sw)
	{
		sidewalkWidth1 = sw.sidewalkWidth;
		sidewalkWidth2 = sw.sidewalkWidth;
		curbHeight = sw.curbHeight;
		curbDepth = sw.curbDepth;
		beveledCurb = sw.beveledCurb;
		beveledHeight = sw.beveledHeight;
		beveledDepth = sw.beveledDepth;
		outerCurb = sw.outerCurb;
		roadSideCurbUVControl = sw.roadSideCurbUVControl;
		outerSideCurbUVControl = sw.outerSideCurbUVControl;
		sidewalkMaterial = sw.material;
		sidewalkUVs = new List<float>(sw.sidewalkUVs);
	}

	public static bool ERSidewalkMatch(QDOQDSQOOQDDD sw1, QDOQDSQOOQDDD sw2)
	{
		bool result = true;
		if (sw1.beveledHeight != sw2.beveledHeight)
		{
			result = false;
		}
		if (sw1.beveledDepth != sw2.beveledDepth)
		{
			result = false;
		}
		if (sw1.outerCurb != sw2.outerCurb)
		{
			result = false;
		}
		return result;
	}
}
public class EasyRoads3DTerrainIDv3 : MonoBehaviour
{
	public string terrainid;
}
[AddComponentMenu("")]
public class ERBend : MonoBehaviour
{
	public float roundAboutRadius = 10f;

	public float roundAboutResolution = 1f;

	public float rDist = 0f;

	public Vector3 raStartPos;

	public float roundaboutWidth = 5f;

	public float bendAngle = 90f;

	public bool meshInstance = false;

	public float roadWidth = 5f;

	public bool lockLeftRightRoundingRadius = true;

	public float leftRoundingRadius = 2f;

	public float rightRoundingRadius = 2f;

	public int roundingSegments = 5;

	public float connectionLength = 5f;

	public float maxRoadWidth = 0f;

	public float maxRoundingRadius = 0f;

	public List<Vector3> meshVecs = new List<Vector3>();

	public List<Vector3> mainRightPoints = new List<Vector3>();

	public List<Vector3> mainCenterPoints = new List<Vector3>();

	public List<Vector3> mainLeftPoints = new List<Vector3>();

	public List<Vector3> OCCDQOCCDQ = new List<Vector3>();

	public List<Vector3> splinePoints = new List<Vector3>();

	public List<Vector2> mainRightPointsUVs = new List<Vector2>();

	public List<Vector2> mainCenterPointsUVs = new List<Vector2>();

	public List<Vector2> mainLeftPointsUVs = new List<Vector2>();

	public List<Vector2> OCCDQOCCDQUVs = new List<Vector2>();

	public Vector3 leftPoint;

	public Vector3 leftPoint1;

	public Vector3 rightPoint;

	public Vector3 rightPoint1;

	public Vector3 centerOnLine;

	public Vector3 leftOuterPoint;

	public Vector3 rightOuterPoint;

	public Vector3 pl;

	public Vector3 pr;

	public List<Vector3> edgePoints = new List<Vector3>();

	public int newSegmentInt = 0;

	public List<ERRoundaboutElement> connections = new List<ERRoundaboutElement>();

	public string[] QDOOOQOOQQQQD;

	public int selectedConnection = 0;

	public int tmpSelectedConnection = 0;

	public int centerInt = 0;

	public int leftOuterInt = 0;

	public int rightOuterInt = 0;

	public List<Vector3> leftOuterSegments = new List<Vector3>();

	public List<Vector3> leftInnerSegments = new List<Vector3>();

	public List<Vector3> rightOuterSegments = new List<Vector3>();

	public List<Vector3> rightInnerSegments = new List<Vector3>();

	public List<Vector2> leftOuterSegmentsUVs = new List<Vector2>();

	public List<Vector2> leftInnerSegmentsUVs = new List<Vector2>();

	public List<Vector2> rightOuterSegmentsUVs = new List<Vector2>();

	public List<Vector2> rightInnerSegmentsUVs = new List<Vector2>();

	public Material roadMaterial;

	public List<Vector3> innerRoundaboutPoints = new List<Vector3>();

	public List<Vector2> innerRoundaboutUVs = new List<Vector2>();

	public float innerSegmentDistance = 0.5f;

	public bool leftFlag = true;

	public bool rightFlag = true;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void OOCCCDQDCQ()
	{
		if (base.gameObject.GetComponent<MeshFilter>() == null)
		{
			base.gameObject.AddComponent<MeshFilter>();
		}
		if (base.gameObject.GetComponent<MeshRenderer>() == null)
		{
			base.gameObject.AddComponent<MeshRenderer>();
		}
		if (base.gameObject.GetComponent<MeshCollider>() == null)
		{
			base.gameObject.AddComponent<MeshCollider>();
		}
		Mesh mesh;
		if (base.gameObject.GetComponent<MeshFilter>().sharedMesh != null)
		{
			if (!meshInstance)
			{
				mesh = UnityEngine.Object.Instantiate(base.gameObject.GetComponent<MeshFilter>().sharedMesh);
				base.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
				base.gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
				meshInstance = true;
			}
			else
			{
				mesh = base.gameObject.GetComponent<MeshFilter>().sharedMesh;
			}
		}
		else
		{
			mesh = new Mesh();
			base.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
			base.gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
			meshInstance = true;
		}
		leftOuterSegments.Clear();
		leftInnerSegments.Clear();
		rightOuterSegments.Clear();
		rightInnerSegments.Clear();
		leftOuterSegmentsUVs.Clear();
		leftInnerSegmentsUVs.Clear();
		rightOuterSegmentsUVs.Clear();
		rightInnerSegmentsUVs.Clear();
		splinePoints.Clear();
		float num = roundAboutRadius;
		Vector3 vector = new Vector3(roadWidth * 0.5f, 0f, 0f);
		Vector3 vector2 = new Vector3(roadWidth * 0.5f - innerSegmentDistance, 0f, 0f);
		Vector3 vector3 = new Vector3(roadWidth * -0.5f, 0f, 0f);
		Vector3 vector4 = new Vector3(roadWidth * -0.5f + innerSegmentDistance, 0f, 0f);
		Vector3 pivot = vector + Vector3.right * num;
		float num2 = bendAngle / ((float)roundingSegments * 1f);
		float num3 = 0f;
		rightOuterSegments.Add(vector);
		rightInnerSegments.Add(vector2);
		leftOuterSegments.Add(vector3);
		leftInnerSegments.Add(vector4);
		splinePoints.Add(Vector3.Lerp(rightOuterSegments[0], leftOuterSegments[0], 0.5f));
		for (int i = 0; i <= roundingSegments; i++)
		{
			rightOuterSegments.Add(ERRoundabouts.OQDDDODCOC(vector, pivot, Quaternion.Euler(0f, num3 + (float)i * num2, 0f)));
			rightInnerSegments.Add(ERRoundabouts.OQDDDODCOC(vector2, pivot, Quaternion.Euler(0f, num3 + (float)i * num2, 0f)));
			leftOuterSegments.Add(ERRoundabouts.OQDDDODCOC(vector3, pivot, Quaternion.Euler(0f, num3 + (float)i * num2, 0f)));
			leftInnerSegments.Add(ERRoundabouts.OQDDDODCOC(vector4, pivot, Quaternion.Euler(0f, num3 + (float)i * num2, 0f)));
			splinePoints.Add(Vector3.Lerp(rightOuterSegments[i + 1], leftOuterSegments[i + 1], 0.5f));
		}
		float num4 = 5f;
		float num5 = 0f;
		List<float> list = new List<float>();
		list.Add(0f);
		List<Vector3> list2 = new List<Vector3>();
		for (int j = 0; j < rightOuterSegments.Count; j++)
		{
			list2.Add(leftOuterSegments[j]);
			list2.Add(rightOuterSegments[j]);
			if (j > 0)
			{
				num5 += Vector3.Distance(splinePoints[j - 1], splinePoints[j]);
				list.Add(num5);
			}
		}
		List<Vector2> list3 = new List<Vector2>();
		for (int k = 0; k < list.Count; k++)
		{
			list3.Add(new Vector2(0f, list[k] / num4));
			list3.Add(new Vector2(1f, list[k] / num4));
		}
		List<int> list4 = new List<int>();
		int count = splinePoints.Count;
		int num6 = 2;
		int num7 = 1;
		for (int l = 0; l < count - 1; l += num7)
		{
			for (int m = 0; m < num6 - 1; m++)
			{
				list4.Add(l * num6 + m);
				list4.Add((l + num7) * num6 + m + 1);
				list4.Add(l * num6 + m + 1);
				list4.Add((l + num7) * num6 + m);
				list4.Add((l + num7) * num6 + m + 1);
				list4.Add(l * num6 + m);
			}
		}
		mesh.Clear();
		mesh.vertices = list2.ToArray();
		mesh.uv = list3.ToArray();
		mesh.tangents = new Vector4[mesh.vertices.Length];
		mesh.triangles = list4.ToArray();
		mesh.RecalculateBounds();
		mesh.RecalculateNormals();
		base.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
	}
}
[Serializable]
public class ERRoundaboutElement
{
	public float roadWidth = 5f;

	public float prevRoadWidth = 5f;

	public int roundingSegments = 10;

	public bool lockLeftRightRoundingRadius = true;

	public float leftRoundingRadius = 3f;

	public float prevLeftRoundingRadius = 3f;

	public float rightRoundingRadius = 3f;

	public float prevRightRoundingRadius = 3f;

	public float connectionLength = 5f;

	public int centerInt = 0;

	public int prevCenterInt = 0;

	public float positionPercentage = 0f;

	public int leftOuterInt = 0;

	public int rightOuterInt = 0;

	public int intsFromCenter = 0;

	public List<Vector3> leftOuterSegments = new List<Vector3>();

	public List<Vector3> leftInnerSegments = new List<Vector3>();

	public List<Vector3> rightOuterSegments = new List<Vector3>();

	public List<Vector3> rightInnerSegments = new List<Vector3>();

	public List<Vector2> leftOuterSegmentsUVs = new List<Vector2>();

	public List<Vector2> leftInnerSegmentsUVs = new List<Vector2>();

	public List<Vector2> rightOuterSegmentsUVs = new List<Vector2>();

	public List<Vector2> rightInnerSegmentsUVs = new List<Vector2>();

	public List<List<Vector3>> leftSidewalkV3 = new List<List<Vector3>>();

	public List<List<Vector3>> rightSidewalkV3 = new List<List<Vector3>>();

	public List<List<Vector2>> leftSidewalkUV = new List<List<Vector2>>();

	public List<List<Vector2>> rightSidewalkUV = new List<List<Vector2>>();

	public List<List<int>> leftSidewalkTris = new List<List<int>>();

	public List<List<int>> rightSidewalkTris = new List<List<int>>();

	public List<int> leftSidewalkNormalsStart = new List<int>();

	public List<int> leftSidewalkNormalsEnd = new List<int>();

	public List<int> rightSidewalkNormalsStart = new List<int>();

	public List<int> rightSidewalkNormalsEnd = new List<int>();

	public List<List<int>> roadConnectionTris = new List<List<int>>();

	public List<Vector3> leftSidewalkSourceVecs = new List<Vector3>();

	public List<Vector3> rightSidewalkSourceVecs = new List<Vector3>();

	public Vector3 outerCenterPoint;

	public List<Vector3> innerRoundaboutPoints = new List<Vector3>();

	public List<Vector2> innerRoundaboutUVs = new List<Vector2>();

	public bool leftFlag = true;

	public bool rightFlag = true;

	public bool blendFlag = false;

	public Material roadMaterial;

	public Material connectionMaterial;

	public int prefabElement = 0;

	public List<int> connectionVecInts = new List<int>();

	public List<int> fullConnectionVecInts = new List<int>();

	public Vector3 centerPoint;

	public Vector3 controlPointV3;

	public List<Vector2> roadShapeVecs = new List<Vector2>();

	public string roadShapeVecsString = "";

	public List<float> roadShapeUVY = new List<float>();

	public List<int> blendCornerPointInts = new List<int>();

	public List<float> blendCornerPointWeights = new List<float>();

	public Vector3 sceneSelectionV3 = Vector3.zero;

	public Vector3 sceneSelectionV3Global = Vector3.zero;

	public List<Vector3> rightIndentvecs = new List<Vector3>();

	public List<Vector3> rightSurroundingvecs = new List<Vector3>();

	public List<Vector3> leftIndentvecs = new List<Vector3>();

	public List<Vector3> leftSurroundingvecs = new List<Vector3>();

	public int rightIndentBorderInt = 0;

	public int leftIndentBorderInt = 0;

	public double roadType = 0.0;

	public double prevRoadType = 0.0;

	public double roadTypeTimestamp = 0.0;

	public double prevTimestamp = 0.0;
}
[AddComponentMenu("")]
public class ERRoundabouts : MonoBehaviour
{
	public float roundAboutRadius = 10f;

	public float prevRoundAboutRadius = 10f;

	public float roundAboutResolution = 1f;

	public float prevRoundAboutResolution = 1f;

	public float rDist = 0f;

	public Vector3 raStartPos;

	public float roundaboutWidth = 5f;

	public float prevRoundaboutWidth = 5f;

	public int roadTypeInt = 0;

	public int prevRoadTypeInt = 0;

	public float roadWidth = 5f;

	public float prevRoadWidth = 5f;

	public bool lockLeftRightRoundingRadius = true;

	public float leftRoundingRadius = 2f;

	public float prevLeftRoundingRadius = 2f;

	public float rightRoundingRadius = 2f;

	public float prevRightRoundingRadius = 2f;

	public int roundingSegments = 5;

	public float connectionLength = 5f;

	public float maxRoadWidth = 0f;

	public float maxRoundingRadius = 0f;

	public List<Vector3> meshVecs = new List<Vector3>();

	public List<Vector3> mainRightPoints = new List<Vector3>();

	public List<Vector3> mainCenterPoints = new List<Vector3>();

	public List<Vector3> mainLeftPoints = new List<Vector3>();

	public List<Vector3> OCCDQOCCDQ = new List<Vector3>();

	public List<Vector2> mainRightPointsUVs = new List<Vector2>();

	public List<Vector2> mainCenterPointsUVs = new List<Vector2>();

	public List<Vector2> mainLeftPointsUVs = new List<Vector2>();

	public List<Vector2> OCCDQOCCDQUVs = new List<Vector2>();

	public List<Vector3> innerRoundaboutSidewalkV3 = new List<Vector3>();

	public List<Vector2> innerRoundaboutSidewalUV = new List<Vector2>();

	public List<int> innerRoundaboutSidewalTris = new List<int>();

	public Material innerRoundaboutSidewalkMaterial;

	public List<int> innerRoundaboutSidewalkIntsStart = new List<int>();

	public List<int> innerRoundaboutSidewalkIntsEnd = new List<int>();

	public int innerSidewalkSegments = 0;

	public Vector3 leftPoint;

	public Vector3 leftPoint1;

	public Vector3 rightPoint;

	public Vector3 rightPoint1;

	public Vector3 centerOnLine;

	public Vector3 leftOuterPoint;

	public Vector3 rightOuterPoint;

	public Vector3 pl;

	public Vector3 pr;

	public List<Vector3> edgePoints = new List<Vector3>();

	public int newSegmentInt = -1;

	public int prevNewSegmentInt = -1;

	public List<ERRoundaboutElement> connections = new List<ERRoundaboutElement>();

	public string[] QDOOOQOOQQQQD;

	public int selectedConnection = 0;

	public int activeConnection = 0;

	public int tmpSelectedConnection = 0;

	public int minStartInt = 1;

	public int maxEndInt = 0;

	public int centerInt = 0;

	public int leftOuterInt = 0;

	public int rightOuterInt = 0;

	public List<Vector3> leftOuterSegments = new List<Vector3>();

	public List<Vector3> leftInnerSegments = new List<Vector3>();

	public List<Vector3> rightOuterSegments = new List<Vector3>();

	public List<Vector3> rightInnerSegments = new List<Vector3>();

	public List<Vector2> leftOuterSegmentsUVs = new List<Vector2>();

	public List<Vector2> leftInnerSegmentsUVs = new List<Vector2>();

	public List<Vector2> rightOuterSegmentsUVs = new List<Vector2>();

	public List<Vector2> rightInnerSegmentsUVs = new List<Vector2>();

	public Vector3 outerCenterPoint;

	public bool blendFlag = false;

	public Material mainRoadMaterial;

	public Material roadMaterial;

	public Material connectionMaterial;

	public Material defaultConnectionMaterial;

	public double roadType = 0.0;

	public double roadTypeTimestamp = 0.0;

	public List<Vector3> innerRoundaboutPoints = new List<Vector3>();

	public List<Vector2> innerRoundaboutUVs = new List<Vector2>();

	public float innerSegmentDistance = 0.5f;

	public float innerSidewalkWidth1 = 1.5f;

	public float innerSidewalkWidth2 = 1.5f;

	public float innerCurbHeight = 0.25f;

	public float innerCurbDepth = 0.25f;

	public bool innerBeveledCurb = false;

	public float innerBeveledHeight = 0f;

	public float innerBeveledDepth = 0f;

	public bool innerOuterCurb = false;

	public bool innerRoadSideCurbUVControl = false;

	public bool innerOuterSideCurbUVControl = false;

	public Material innerSidewalkMaterial;

	public List<float> innerSidewalkUVs = new List<float>();

	public List<float> innerCurbUVs = new List<float>();

	public int selectedCorner = 0;

	public int selectedCornerPreset = 0;

	public int selectedSidewalkPreset = 0;

	public string sidewalkPresetName = "";

	public int innerRoundaboutPreset = 0;

	public bool leftFlag = true;

	public bool rightFlag = true;

	private bool á = false;

	public ERCrossingPrefabs prefabScript;

	public QDOODOQQDQODD connectionElement;

	public ERModularBase baseScript;

	public bool isSceneObject = true;

	public bool guiChanged = true;

	public string crossingName = "";

	public bool activeSidewalks = true;

	public bool newConnectionFlag = false;

	public Vector3 testIndentMiddlePoint = Vector3.zero;

	public List<QDQDOOQQDQODD> roadTypesDynamic = new List<QDQDOOQQDQODD>();

	private void Start()
	{
	}

	public bool UpdateToRoadType(QDQDOOQQDQODD sourcePreset)
	{
		if (prefabScript == null)
		{
			UnityEngine.Debug.LogWarning("EasyRoads3Dv3 Warning: Missing ER Crossing Prefabs script on: " + base.gameObject.name);
			return false;
		}
		bool flag = false;
		Material material = sourcePreset.connectionMaterial;
		if (material == null)
		{
			material = sourcePreset.roadMaterial;
		}
		List<int> list = new List<int>();
		for (int i = 0; i < connections.Count; i++)
		{
			if (connections[i].roadType == sourcePreset.id && connections[i].roadType != 0.0)
			{
				flag = true;
				prefabScript.crossingElements[i].roadTypeTimestamp = sourcePreset.timestamp;
				if (sourcePreset.roadWidth < maxRoadWidth)
				{
					connections[i].roadWidth = sourcePreset.roadWidth;
				}
				else
				{
					UnityEngine.Debug.LogError("EasyRoads3Dv3 Alert: The '" + sourcePreset.roadTypeName + "' road width is too wide for roundabout: " + base.gameObject.name);
				}
				connections[i].roadMaterial = sourcePreset.roadMaterial;
				connections[i].connectionMaterial = material;
				if (selectedConnection == i && sourcePreset.roadWidth < maxRoadWidth)
				{
					roadWidth = sourcePreset.roadWidth;
					connectionMaterial = sourcePreset.connectionMaterial;
				}
				if (prefabScript.crossingElements[i].connectedRoad != null && prefabScript.crossingElements[i].connectedRoad.roadType == prefabScript.crossingElements[i].roadType)
				{
					list.Add(i);
				}
			}
		}
		if (flag)
		{
			OOCDDOQDDO();
			OQQCDOQOOQ();
			if (leftFlag && rightFlag)
			{
				ODDDOCDCQO();
				OOQQDCCCCC();
			}
			else
			{
				UnityEngine.Debug.LogError("EasyRoads3Dv3 Alert: The '" + sourcePreset.roadTypeName + "' road width is too wide for roundabout: " + base.gameObject.name);
			}
		}
		for (int j = 0; j < list.Count; j++)
		{
			ERModularRoad connectedRoad = prefabScript.crossingElements[list[j]].connectedRoad;
			if ((bool)connectedRoad.startPrefabScript && (bool)connectedRoad.endPrefabScript)
			{
				if (connectedRoad.startPrefabScript == prefabScript)
				{
					connectedRoad.ODDDCDQCCO(prefabScript, list[j], reverse: true, uvReverse: true, UpdateResolutionFlag: false);
					if (connectedRoad.roadShape[0].x < 0f)
					{
						connectedRoad.ODDDCDQCCO(prefabScript, list[j], reverse: false, uvReverse: false, UpdateResolutionFlag: false);
					}
				}
			}
			else if (prefabScript.crossingElements[list[j]].connectedMarker == 0)
			{
				connectedRoad.ODDDCDQCCO(prefabScript, list[j], reverse: true, uvReverse: true, UpdateResolutionFlag: false);
				if (connectedRoad.roadShape[0].x < 0f)
				{
					connectedRoad.ODDDCDQCCO(prefabScript, list[j], reverse: false, uvReverse: false, UpdateResolutionFlag: false);
				}
			}
			else
			{
				connectedRoad.ODDDCDQCCO(prefabScript, list[j], reverse: false, uvReverse: false, UpdateResolutionFlag: false);
				if (connectedRoad.roadShape[0].x < 0f)
				{
					connectedRoad.ODDDCDQCCO(prefabScript, list[j], reverse: true, uvReverse: true, UpdateResolutionFlag: false);
				}
			}
			if (connectedRoad.flipRoadUVs)
			{
				connectedRoad.FlipRoadUVs(update: false);
			}
			connectedRoad.OCQOQCDCQC(ignorePrefabAlignment: true, forceAutoRotate: false);
		}
		return flag;
	}

	public void ResetData()
	{
		roundAboutRadius = prevRoundAboutRadius;
		roundAboutResolution = prevRoundAboutResolution;
		roundaboutWidth = prevRoundaboutWidth;
		newSegmentInt = prevNewSegmentInt;
		roadWidth = prevRoadWidth;
		leftRoundingRadius = prevLeftRoundingRadius;
		rightRoundingRadius = prevRightRoundingRadius;
		roadTypeInt = prevRoadTypeInt;
		if (connections.Count > 0 && selectedConnection >= 0 && connections.Count > selectedConnection)
		{
			connections[selectedConnection].roadWidth = connections[selectedConnection].prevRoadWidth;
			connections[selectedConnection].centerInt = connections[selectedConnection].prevCenterInt;
			connections[selectedConnection].leftRoundingRadius = connections[selectedConnection].prevLeftRoundingRadius;
			connections[selectedConnection].rightRoundingRadius = connections[selectedConnection].prevRightRoundingRadius;
			connections[selectedConnection].roadType = connections[selectedConnection].prevRoadType;
			connections[selectedConnection].roadTypeTimestamp = connections[selectedConnection].prevTimestamp;
		}
	}

	public void ODQDCCOQOD()
	{
		if (connections.Count > 0)
		{
			int num = connections[connections.Count - 1].rightOuterInt;
			if (mainLeftPoints.Count - num < 16)
			{
				UnityEngine.Debug.LogWarning("EasyRoads3Dv3 Warning: Conenctions are added clockwise. There is no room for more connections, please increase the radius or reposition existing connections first");
				return;
			}
		}
		connections.Add(new ERRoundaboutElement());
		selectedConnection = (selectedCorner = connections.Count - 1);
		QDOOOQOOQQQQD = (prefabScript.QDOOOQOOQQQQD = new string[connections.Count]);
		int num2 = 0;
		for (int i = 0; i < connections.Count; i++)
		{
			QDOOOQOOQQQQD[i] = (prefabScript.QDOOOQOOQQQQD[i] = "Connection " + (i + 1));
			if (connections[i].rightOuterInt > num2)
			{
				num2 = connections[i].rightOuterInt;
			}
		}
		if (selectedConnection == 0)
		{
			num2 = 5;
		}
		prefabScript.crossingElements.Add(new QDOODOQQDQODD());
		QDOODOQQDQODD qDOODOQQDQODD = prefabScript.crossingElements[prefabScript.crossingElements.Count - 1];
		prefabScript.sidewalkControlElements.Add(new QDOQDSQOOQDDD(baseScript));
		if (prefabScript.sidewalkControlElements[prefabScript.sidewalkControlElements.Count - 1].sidewalkMaterial == null && prefabScript.sidewalkControlElements.Count > 1)
		{
			prefabScript.sidewalkControlElements[prefabScript.sidewalkControlElements.Count - 1].sidewalkMaterial = prefabScript.sidewalkControlElements[prefabScript.sidewalkControlElements.Count - 2].sidewalkMaterial;
		}
		connections[selectedConnection].prefabElement = prefabScript.crossingElements.Count - 1;
		connections[selectedConnection].connectionMaterial = defaultConnectionMaterial;
		if (roadMaterial == null)
		{
			roadMaterial = Resources.Load("Materials/roads/road material") as Material;
		}
		connections[selectedConnection].roadMaterial = roadMaterial;
		newSegmentInt = (connections[selectedConnection].centerInt = num2 + Mathf.RoundToInt((float)(mainCenterPoints.Count - num2) / 2f));
		connections[selectedConnection].positionPercentage = (float)newSegmentInt * 1f / ((float)mainLeftPoints.Count * 1f);
		GetConnectionData();
		newConnectionFlag = true;
	}

	public void OOQQDCCCCC()
	{
		if (connections.Count != 0)
		{
			connections[selectedConnection].roadWidth = roadWidth;
			connections[selectedConnection].roundingSegments = roundingSegments;
			connections[selectedConnection].lockLeftRightRoundingRadius = lockLeftRightRoundingRadius;
			connections[selectedConnection].leftRoundingRadius = leftRoundingRadius;
			connections[selectedConnection].rightRoundingRadius = rightRoundingRadius;
			connections[selectedConnection].connectionLength = connectionLength;
			connections[selectedConnection].centerInt = centerInt;
			connections[selectedConnection].outerCenterPoint = outerCenterPoint;
			connections[selectedConnection].leftOuterSegments = leftOuterSegments;
			connections[selectedConnection].leftInnerSegments = leftInnerSegments;
			connections[selectedConnection].rightOuterSegments = rightOuterSegments;
			connections[selectedConnection].rightInnerSegments = rightInnerSegments;
			connections[selectedConnection].leftFlag = leftFlag;
			connections[selectedConnection].rightFlag = rightFlag;
			connections[selectedConnection].blendFlag = blendFlag;
			connections[selectedConnection].connectionMaterial = connectionMaterial;
		}
	}

	public void GetConnectionData()
	{
		roadWidth = connections[selectedConnection].roadWidth;
		roundingSegments = connections[selectedConnection].roundingSegments;
		lockLeftRightRoundingRadius = connections[selectedConnection].lockLeftRightRoundingRadius;
		leftRoundingRadius = connections[selectedConnection].leftRoundingRadius;
		rightRoundingRadius = connections[selectedConnection].rightRoundingRadius;
		centerInt = connections[selectedConnection].centerInt;
		outerCenterPoint = connections[selectedConnection].outerCenterPoint;
		connectionLength = connections[selectedConnection].connectionLength;
		centerInt = connections[selectedConnection].centerInt;
		leftOuterSegments = connections[selectedConnection].leftOuterSegments;
		leftInnerSegments = connections[selectedConnection].leftInnerSegments;
		rightOuterSegments = connections[selectedConnection].rightOuterSegments;
		rightInnerSegments = connections[selectedConnection].rightInnerSegments;
		leftFlag = connections[selectedConnection].leftFlag;
		rightFlag = connections[selectedConnection].rightFlag;
		blendFlag = connections[selectedConnection].blendFlag;
		roadMaterial = connections[selectedConnection].roadMaterial;
		connectionMaterial = connections[selectedConnection].connectionMaterial;
		roadType = connections[selectedConnection].roadType;
		roadTypeInt = GetRoadPresetInt(roadType);
		roadTypeTimestamp = connections[selectedConnection].roadTypeTimestamp;
		newSegmentInt = centerInt;
		UpdateMinMaxInts();
	}

	public void UpdateMinMaxInts()
	{
		if (selectedConnection == 0)
		{
			minStartInt = 0;
		}
		else
		{
			minStartInt = connections[selectedConnection - 1].rightOuterInt;
		}
		if (minStartInt < 0 || minStartInt > mainLeftPoints.Count)
		{
			minStartInt = 0;
		}
		if (selectedConnection == connections.Count - 1)
		{
			maxEndInt = mainLeftPoints.Count - 2;
		}
		else
		{
			maxEndInt = connections[selectedConnection + 1].leftOuterInt;
		}
		if (maxEndInt < 0 || maxEndInt > mainLeftPoints.Count - 1)
		{
			maxEndInt = mainLeftPoints.Count - 1;
		}
		leftOuterInt = connections[selectedConnection].leftOuterInt;
		rightOuterInt = connections[selectedConnection].rightOuterInt;
	}

	public void ChecknewSegmentInt()
	{
		if (newSegmentInt - connections[selectedConnection].intsFromCenter < minStartInt)
		{
			newSegmentInt = minStartInt + connections[selectedConnection].intsFromCenter;
		}
		if (newSegmentInt + connections[selectedConnection].intsFromCenter > maxEndInt)
		{
			newSegmentInt = maxEndInt - connections[selectedConnection].intsFromCenter;
		}
	}

	public int GetRoadPresetInt(double id)
	{
		string text = "";
		int result = 0;
		for (int i = 0; i < baseScript.roadTypes.Count; i++)
		{
			if (baseScript.roadTypes[i].id == id)
			{
				text = baseScript.roadTypes[i].roadTypeName;
				break;
			}
		}
		for (int j = 0; j < roadTypesDynamic.Count; j++)
		{
			if (roadTypesDynamic[j].id == id)
			{
				result = j + 1;
				break;
			}
		}
		return result;
	}

	public void OCQCQODOQC(ERRoundabouts source, bool refreshFlag)
	{
		roadTypesDynamic.Clear();
		if (prefabScript == null)
		{
			prefabScript = base.gameObject.GetComponent<ERCrossingPrefabs>();
		}
		if (prefabScript.baseScript == null)
		{
			prefabScript.baseScript = UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase;
		}
		foreach (QDQDOOQQDQODD roadType in prefabScript.baseScript.roadTypes)
		{
			if (roadType.roadShape.Count == 2 && !roadType.isSideObject && !roadType.isCustomRoad)
			{
				roadTypesDynamic.Add(roadType);
			}
		}
		connections.Clear();
		for (int i = 0; i < source.connections.Count; i++)
		{
			connections.Add(new ERRoundaboutElement());
			connections[i].roadWidth = source.connections[i].roadWidth;
			connections[i].prevRoadWidth = source.connections[i].prevRoadWidth;
			connections[i].roundingSegments = source.connections[i].roundingSegments;
			connections[i].lockLeftRightRoundingRadius = source.connections[i].lockLeftRightRoundingRadius;
			connections[i].leftRoundingRadius = source.connections[i].leftRoundingRadius;
			connections[i].prevLeftRoundingRadius = source.connections[i].prevLeftRoundingRadius;
			connections[i].rightRoundingRadius = source.connections[i].rightRoundingRadius;
			connections[i].prevRightRoundingRadius = source.connections[i].prevRightRoundingRadius;
			connections[i].connectionLength = source.connections[i].connectionLength;
			connections[i].centerInt = source.connections[i].centerInt;
			connections[i].prevCenterInt = source.connections[i].prevCenterInt;
			connections[i].positionPercentage = source.connections[i].positionPercentage;
			connections[i].leftOuterInt = source.connections[i].leftOuterInt;
			connections[i].rightOuterInt = source.connections[i].rightOuterInt;
			connections[i].intsFromCenter = source.connections[i].intsFromCenter;
			connections[i].outerCenterPoint = source.connections[i].outerCenterPoint;
			connections[i].blendFlag = source.connections[i].blendFlag;
			connections[i].roadMaterial = source.connections[i].roadMaterial;
			connections[i].connectionMaterial = source.connections[i].connectionMaterial;
			connections[i].prefabElement = source.connections[i].prefabElement;
			connections[i].roadType = source.connections[i].roadType;
			connections[i].prevRoadType = source.connections[i].prevRoadType;
			connections[i].roadTypeTimestamp = source.connections[i].roadTypeTimestamp;
			connections[i].prevTimestamp = source.connections[i].prevTimestamp;
		}
		ERCrossingPrefabs component = source.gameObject.GetComponent<ERCrossingPrefabs>();
		if (component != null)
		{
			for (int j = 0; j < component.crossingElements.Count; j++)
			{
				prefabScript.crossingElements.Add(new QDOODOQQDQODD());
				prefabScript.crossingElements[j].rotationPriority = component.crossingElements[j].rotationPriority;
				prefabScript.crossingElements[j].includeLeftSidewalk = component.crossingElements[j].includeLeftSidewalk;
				prefabScript.crossingElements[j].includeRightSidewalk = component.crossingElements[j].includeRightSidewalk;
				prefabScript.crossingElements[j].roadMaterial = component.crossingElements[j].roadMaterial;
				prefabScript.crossingElements[j].roadType = component.crossingElements[j].roadType;
				prefabScript.crossingElements[j].roadTypeTimestamp = component.crossingElements[j].roadTypeTimestamp;
				prefabScript.sidewalkControlElements.Add(new QDOQDSQOOQDDD(UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase));
				if (component.sidewalkControlElements.Count > j)
				{
					prefabScript.sidewalkControlElements[j].crossingElementLeftIndex = component.sidewalkControlElements[j].crossingElementLeftIndex;
					prefabScript.sidewalkControlElements[j].crossingElementRightIndex = component.sidewalkControlElements[j].crossingElementRightIndex;
					prefabScript.sidewalkControlElements[j].centerHandleV3 = component.sidewalkControlElements[j].centerHandleV3;
					prefabScript.sidewalkControlElements[j].leftHandleV3 = component.sidewalkControlElements[j].leftHandleV3;
					prefabScript.sidewalkControlElements[j].rightHandleV3 = component.sidewalkControlElements[j].rightHandleV3;
					prefabScript.sidewalkControlElements[j].renderFlag = component.sidewalkControlElements[j].renderFlag;
					prefabScript.sidewalkControlElements[j].leftConnectionHandle = component.sidewalkControlElements[j].leftConnectionHandle;
					prefabScript.sidewalkControlElements[j].rightConnectionHandle = component.sidewalkControlElements[j].rightConnectionHandle;
					prefabScript.sidewalkControlElements[j].sidewalkWidth1 = component.sidewalkControlElements[j].sidewalkWidth1;
					prefabScript.sidewalkControlElements[j].sidewalkWidth2 = component.sidewalkControlElements[j].sidewalkWidth2;
					prefabScript.sidewalkControlElements[j].curbHeight = component.sidewalkControlElements[j].curbHeight;
					prefabScript.sidewalkControlElements[j].curbDepth = component.sidewalkControlElements[j].curbDepth;
					prefabScript.sidewalkControlElements[j].beveledCurb = component.sidewalkControlElements[j].beveledCurb;
					prefabScript.sidewalkControlElements[j].beveledHeight = component.sidewalkControlElements[j].beveledHeight;
					prefabScript.sidewalkControlElements[j].beveledDepth = component.sidewalkControlElements[j].beveledDepth;
					prefabScript.sidewalkControlElements[j].outerCurb = component.sidewalkControlElements[j].outerCurb;
					prefabScript.sidewalkControlElements[j].roadSideCurbUVControl = component.sidewalkControlElements[j].roadSideCurbUVControl;
					prefabScript.sidewalkControlElements[j].outerSideCurbUVControl = component.sidewalkControlElements[j].outerSideCurbUVControl;
					prefabScript.sidewalkControlElements[j].sidewalkMaterial = component.sidewalkControlElements[j].sidewalkMaterial;
					prefabScript.sidewalkControlElements[j].sidewalkUVs = new List<float>(component.sidewalkControlElements[j].sidewalkUVs);
					prefabScript.sidewalkControlElements[j].curbUVs = new List<float>(component.sidewalkControlElements[j].curbUVs);
					prefabScript.sidewalkControlElements[j].lockUVs = component.sidewalkControlElements[j].lockUVs;
					prefabScript.sidewalkControlElements[j].cornerRadius = component.sidewalkControlElements[j].cornerRadius;
					prefabScript.sidewalkControlElements[j].cornerSegments = component.sidewalkControlElements[j].cornerSegments;
					prefabScript.sidewalkControlElements[j].innerSegmentDistance = component.sidewalkControlElements[j].innerSegmentDistance;
					prefabScript.sidewalkControlElements[j].startAngle = component.sidewalkControlElements[j].startAngle;
				}
			}
		}
		for (int k = 0; k < prefabScript.sidewalkControlElements.Count; k++)
		{
			prefabScript.sidewalkControlElements[k].renderFlag = component.sidewalkControlElements[k].renderFlag;
			prefabScript.sidewalkControlElements[k].leftConnectionHandle = component.sidewalkControlElements[k].leftConnectionHandle;
			prefabScript.sidewalkControlElements[k].rightConnectionHandle = component.sidewalkControlElements[k].rightConnectionHandle;
		}
		for (int l = 0; l < prefabScript.crossingElements.Count; l++)
		{
			prefabScript.crossingElements[l].includeLeftSidewalk = component.crossingElements[l].includeLeftSidewalk;
			prefabScript.crossingElements[l].includeRightSidewalk = component.crossingElements[l].includeRightSidewalk;
		}
		OOCDDOQDDO();
		OQQCDOQOOQ();
		ODDDOCDCQO();
	}

	public void OCDCOQOOQO()
	{
		ERCrossingPrefabs component = base.gameObject.GetComponent<ERCrossingPrefabs>();
		QDOODOQQDQODD qDOODOQQDQODD = component.crossingElements[connections[selectedConnection].prefabElement];
	}

	public void ODCDCDDOCC(List<SidewalkPresetClass> sidewalkPresets, int el)
	{
		selectedSidewalkPreset = el;
		prefabScript.sidewalkControlElements[selectedCorner].sidewalkWidth1 = sidewalkPresets[selectedSidewalkPreset - 1].sidewalkWidth1;
		prefabScript.sidewalkControlElements[selectedCorner].sidewalkWidth2 = sidewalkPresets[selectedSidewalkPreset - 1].sidewalkWidth2;
		prefabScript.sidewalkControlElements[selectedCorner].curbHeight = sidewalkPresets[selectedSidewalkPreset - 1].curbHeight;
		prefabScript.sidewalkControlElements[selectedCorner].curbDepth = sidewalkPresets[selectedSidewalkPreset - 1].curbDepth;
		prefabScript.sidewalkControlElements[selectedCorner].beveledCurb = sidewalkPresets[selectedSidewalkPreset - 1].beveledCurb;
		prefabScript.sidewalkControlElements[selectedCorner].beveledHeight = sidewalkPresets[selectedSidewalkPreset - 1].beveledHeight;
		prefabScript.sidewalkControlElements[selectedCorner].beveledDepth = sidewalkPresets[selectedSidewalkPreset - 1].beveledDepth;
		prefabScript.sidewalkControlElements[selectedCorner].outerCurb = sidewalkPresets[selectedSidewalkPreset - 1].outerCurb;
		prefabScript.sidewalkControlElements[selectedCorner].roadSideCurbUVControl = sidewalkPresets[selectedSidewalkPreset - 1].roadSideCurbUVControl;
		prefabScript.sidewalkControlElements[selectedCorner].outerSideCurbUVControl = sidewalkPresets[selectedSidewalkPreset - 1].outerSideCurbUVControl;
		prefabScript.sidewalkControlElements[selectedCorner].sidewalkMaterial = sidewalkPresets[selectedSidewalkPreset - 1].sidewalkMaterial;
		prefabScript.sidewalkControlElements[selectedCorner].sidewalkUVs.Clear();
		prefabScript.sidewalkControlElements[selectedCorner].sidewalkUVs.AddRange(sidewalkPresets[selectedSidewalkPreset - 1].sidewalkUVs);
		prefabScript.sidewalkControlElements[selectedCorner].curbUVs.Clear();
		prefabScript.sidewalkControlElements[selectedCorner].curbUVs.AddRange(sidewalkPresets[selectedSidewalkPreset - 1].curbUVs);
		prefabScript.sidewalkControlElements[selectedCorner].lockUVs = sidewalkPresets[selectedSidewalkPreset - 1].lockUVs;
	}

	public void OOCDDOQDDO()
	{
		á = false;
		if (QDOOOQOOQQQQD.Length != connections.Count)
		{
			QDOOOQOOQQQQD = new string[connections.Count];
			prefabScript.QDOOOQOOQQQQD = new string[connections.Count];
			for (int i = 0; i < connections.Count; i++)
			{
				QDOOOQOOQQQQD[i] = "Connection " + (i + 1);
				prefabScript.QDOOOQOOQQQQD[i] = "Connection " + (i + 1);
			}
			selectedConnection = 0;
		}
		if (selectedConnection >= connections.Count)
		{
			selectedConnection = 0;
		}
		int count = mainLeftPoints.Count;
		mainRightPoints.Clear();
		mainCenterPoints.Clear();
		mainLeftPoints.Clear();
		OCCDQOCCDQ.Clear();
		mainRightPointsUVs.Clear();
		mainCenterPointsUVs.Clear();
		mainLeftPointsUVs.Clear();
		OCCDQOCCDQUVs.Clear();
		innerRoundaboutPoints.Clear();
		int num = Mathf.RoundToInt(2f * roundAboutRadius * (float)Math.PI);
		float num2 = 360f / ((float)num * 1f) * roundAboutResolution;
		Vector3 position = base.transform.position;
		rDist = 0f;
		float num3 = 0f;
		Vector3 zero = Vector3.zero;
		int num4 = 0;
		float num5 = 0f;
		Vector3 zero2;
		Vector3 a = (zero2 = Vector3.zero);
		float num6 = roundaboutWidth * 0.5f;
		while (num3 < 360f + num5)
		{
			zero.x = roundAboutRadius * Mathf.Cos((0f - num3 + num5) * ((float)Math.PI / 180f));
			zero.z = roundAboutRadius * Mathf.Sin((0f - num3 + num5) * ((float)Math.PI / 180f));
			Vector3 normalized = (zero - Vector3.zero).normalized;
			mainLeftPoints.Add(zero + normalized * num6);
			mainRightPoints.Add(zero + -normalized * num6);
			mainCenterPoints.Add(zero);
			mainLeftPointsUVs.Add(new Vector2(0f, num3 * 0.01f));
			mainCenterPointsUVs.Add(new Vector2(0.5f, num3 * 0.01f));
			mainRightPointsUVs.Add(new Vector2(1f, num3 * 0.01f));
			num3 += num2;
			if (num4 == 0)
			{
				zero2 = (raStartPos = zero);
			}
			else
			{
				rDist += Vector3.Distance(a, zero);
			}
			num4++;
			a = zero;
		}
		if (mainLeftPoints[0] != mainLeftPoints[mainLeftPoints.Count - 1])
		{
			mainLeftPoints.Add(mainLeftPoints[0]);
			mainRightPoints.Add(mainRightPoints[0]);
			mainCenterPoints.Add(mainCenterPoints[0]);
			mainLeftPointsUVs.Add(new Vector2(0f, num3 * 0.01f));
			mainCenterPointsUVs.Add(new Vector2(0.5f, num3 * 0.01f));
			mainRightPointsUVs.Add(new Vector2(1f, num3 * 0.01f));
		}
		float num7 = Vector3.Distance(mainLeftPoints[0], Vector3.zero) * 2f;
		maxRoadWidth = 0.5f * num7;
		maxRoundingRadius = (num7 - roadWidth) / 4f;
		if (count != 0 && mainLeftPoints.Count != count)
		{
			float num8 = (float)mainLeftPoints.Count * 1f / ((float)count * 1f);
			for (int j = 0; j < connections.Count; j++)
			{
				if (connections[j].positionPercentage == 0f)
				{
					connections[j].positionPercentage = (float)connections[j].centerInt * 1f / ((float)count * 1f);
				}
				connections[j].centerInt = Mathf.RoundToInt(connections[j].positionPercentage * (float)mainLeftPoints.Count);
				if (j == selectedConnection)
				{
					newSegmentInt = connections[j].centerInt;
				}
			}
		}
		innerRoundaboutSidewalkV3.Clear();
		innerRoundaboutSidewalUV.Clear();
		innerRoundaboutSidewalTris.Clear();
		innerRoundaboutSidewalkIntsStart.Clear();
		innerRoundaboutSidewalkIntsEnd.Clear();
		if (innerRoundaboutPreset != 0)
		{
			ERRoundaboutsFunctions.BuildInnerRoundaboutSidewalkData(this, baseScript, mainRightPoints, ref innerRoundaboutSidewalkV3, ref innerRoundaboutSidewalUV, ref innerRoundaboutSidewalTris, ref innerSidewalkSegments);
		}
	}

	public void OQQCDOQOOQ()
	{
		if (QDOOOQOOQQQQD.Length != connections.Count)
		{
			QDOOOQOOQQQQD = new string[connections.Count];
			prefabScript.QDOOOQOOQQQQD = new string[connections.Count];
			for (int i = 0; i < connections.Count; i++)
			{
				QDOOOQOOQQQQD[i] = "Connection " + (i + 1);
				prefabScript.QDOOOQOOQQQQD[i] = "Connection " + (i + 1);
			}
			selectedConnection = 0;
		}
		if (selectedConnection >= connections.Count)
		{
			selectedConnection = 0;
		}
		centerInt = newSegmentInt;
		OOQQDCCCCC();
		activeConnection = selectedConnection;
		leftFlag = (rightFlag = true);
		for (int j = 0; j < connections.Count; j++)
		{
			if (connections[j].roadMaterial == null)
			{
			}
			OQCQDQDCOD(j);
			if (!connections[j].leftFlag)
			{
				leftFlag = false;
			}
			if (!connections[j].rightFlag)
			{
				rightFlag = false;
			}
		}
		newConnectionFlag = false;
		if (leftFlag && rightFlag)
		{
			ERRoundaboutsFunctions.OCCQQQDDDQ(this);
		}
	}

	public void OQCQDQDCOD(int currentIndex)
	{
		if (connections.Count == 0)
		{
			return;
		}
		connections[currentIndex].leftSidewalkV3.Clear();
		connections[currentIndex].rightSidewalkV3.Clear();
		connections[currentIndex].leftSidewalkUV.Clear();
		connections[currentIndex].rightSidewalkUV.Clear();
		connections[currentIndex].leftSidewalkTris.Clear();
		connections[currentIndex].rightSidewalkTris.Clear();
		connections[currentIndex].roadConnectionTris.Clear();
		connections[currentIndex].leftSidewalkSourceVecs.Clear();
		connections[currentIndex].rightSidewalkSourceVecs.Clear();
		connections[currentIndex].rightIndentvecs.Clear();
		connections[currentIndex].rightSurroundingvecs.Clear();
		connections[currentIndex].leftIndentvecs.Clear();
		connections[currentIndex].leftSurroundingvecs.Clear();
		connections[currentIndex].innerRoundaboutPoints.Clear();
		connections[currentIndex].leftFlag = true;
		connections[currentIndex].rightFlag = true;
		int num = connections[currentIndex].centerInt;
		int num2 = connections[currentIndex].leftOuterInt;
		int num3 = connections[currentIndex].rightOuterInt;
		if (prefabScript.sidewalkControlElements.Count < connections.Count)
		{
			for (int i = prefabScript.sidewalkControlElements.Count; i < connections.Count; i++)
			{
				prefabScript.sidewalkControlElements.Add(new QDOQDSQOOQDDD(baseScript));
			}
		}
		float num4 = connections[currentIndex].roadWidth + 2f * connections[currentIndex].leftRoundingRadius;
		float num5 = 0f;
		int num6 = 1;
		bool flag = true;
		while (num5 < num4)
		{
			if (connections[currentIndex].centerInt - num6 < 0)
			{
				rightFlag = (connections[currentIndex].rightFlag = false);
				flag = false;
				return;
			}
			if (connections[currentIndex].centerInt + num6 >= mainLeftPoints.Count)
			{
				leftFlag = (connections[currentIndex].leftFlag = false);
				flag = false;
				return;
			}
			leftOuterPoint = mainLeftPoints[connections[currentIndex].centerInt - num6];
			rightOuterPoint = mainLeftPoints[connections[currentIndex].centerInt + num6];
			num5 = Vector3.Distance(leftOuterPoint, rightOuterPoint);
			if (num5 > num4)
			{
				break;
			}
			num6++;
			if (connections[currentIndex].centerInt - num6 <= 0)
			{
				leftFlag = (connections[currentIndex].leftFlag = false);
				UnityEngine.Debug.Log("connection " + currentIndex + " cannot be updated, move the position forward");
				flag = false;
				ResetData();
				break;
			}
			if (newSegmentInt + num6 >= mainLeftPoints.Count - 1)
			{
				rightFlag = (connections[currentIndex].rightFlag = false);
				UnityEngine.Debug.Log("connection " + currentIndex + " cannot be updated, move the position backwards");
				flag = false;
				if (!newConnectionFlag)
				{
					ResetData();
				}
				break;
			}
		}
		if (!flag)
		{
			return;
		}
		centerOnLine = Vector3.Lerp(leftOuterPoint, rightOuterPoint, 0.5f);
		Vector3 normalized = (rightOuterPoint - leftOuterPoint).normalized;
		leftPoint = centerOnLine - normalized * 0.5f * num4;
		rightPoint = centerOnLine + normalized * 0.5f * num4;
		normalized = (mainLeftPoints[connections[currentIndex].centerInt] - mainCenterPoints[connections[currentIndex].centerInt]).normalized;
		pl = leftPoint + normalized * 15f;
		pr = rightPoint + normalized * 15f;
		Vector3 p = mainLeftPoints[connections[currentIndex].centerInt - num6];
		Vector3 p2 = mainLeftPoints[connections[currentIndex].centerInt - num6 + 1];
		leftPoint1 = OODOQDOODO(leftPoint, pl, p, p2);
		Vector3 p3 = mainLeftPoints[connections[currentIndex].centerInt + num6];
		Vector3 p4 = mainLeftPoints[connections[currentIndex].centerInt + num6 - 1];
		rightPoint1 = OODOQDOODO(rightPoint, pr, p3, p4);
		if (currentIndex == activeConnection)
		{
			edgePoints.Clear();
			edgePoints.Add(leftPoint1);
			edgePoints.Add(rightPoint1);
		}
		connections[currentIndex].centerInt = connections[currentIndex].centerInt;
		connections[currentIndex].leftOuterInt = connections[currentIndex].centerInt - num6;
		connections[currentIndex].rightOuterInt = connections[currentIndex].centerInt + num6;
		connections[currentIndex].intsFromCenter = num6;
		if (selectedConnection == currentIndex && connections[currentIndex].centerInt != connections[currentIndex].prevCenterInt)
		{
			connections[currentIndex].positionPercentage = (float)connections[currentIndex].centerInt * 1f / ((float)mainLeftPoints.Count * 1f);
		}
		connections[currentIndex].outerCenterPoint = mainLeftPoints[connections[currentIndex].centerInt];
		for (int j = 0; j < connections.Count; j++)
		{
			if (j != currentIndex)
			{
				if (connections[currentIndex].leftOuterInt < connections[j].rightOuterInt + 1 && connections[currentIndex].leftOuterInt >= connections[j].leftOuterInt)
				{
					connections[currentIndex].leftFlag = false;
				}
				if (connections[currentIndex].rightOuterInt <= connections[j].rightOuterInt && connections[currentIndex].rightOuterInt >= connections[j].leftOuterInt)
				{
					connections[currentIndex].rightFlag = false;
				}
			}
		}
		if (connections[currentIndex].leftOuterInt < 0)
		{
			leftFlag = (connections[currentIndex].leftFlag = false);
		}
		if (connections[currentIndex].rightOuterInt >= mainLeftPoints.Count)
		{
			rightFlag = (connections[currentIndex].rightFlag = false);
		}
		for (int k = connections[currentIndex].leftOuterInt + 1; k < connections[currentIndex].rightOuterInt; k++)
		{
			connections[currentIndex].innerRoundaboutPoints.Add(mainLeftPoints[k]);
		}
		if (!connections[currentIndex].leftFlag || !connections[currentIndex].rightFlag)
		{
			if (currentIndex == selectedConnection)
			{
				newSegmentInt = num;
			}
			connections[currentIndex].centerInt = num;
			connections[currentIndex].leftOuterInt = num2;
			connections[currentIndex].rightOuterInt = num3;
			return;
		}
		OQQOCQQDOQ(ref connections[currentIndex].leftOuterSegments, ref connections[currentIndex].leftInnerSegments, -1, connections[currentIndex].centerInt - num6, leftPoint1, rightPoint1, normalized, currentIndex);
		OQQOCQQDOQ(ref connections[currentIndex].rightOuterSegments, ref connections[currentIndex].rightInnerSegments, 1, connections[currentIndex].centerInt + num6, leftPoint1, rightPoint1, normalized, currentIndex);
		ERRoundaboutsFunctions.ODCCQQODCO(this, currentIndex);
		OOCCDCDOQC(currentIndex);
		ERRoundaboutsFunctions.OQQDDDCCDO(this, currentIndex);
		connections[currentIndex].sceneSelectionV3 = Vector3.Lerp(connections[currentIndex].leftOuterSegments[connections[currentIndex].leftOuterSegments.Count - 1], connections[currentIndex].rightOuterSegments[connections[currentIndex].rightOuterSegments.Count - 1], 0.5f);
		float num7 = Vector3.Angle(Vector3.forward, mainLeftPoints[connections[currentIndex].centerInt]);
		if (ODQDQDQDQO.OCCQDCCCOD(Vector3.forward, mainLeftPoints[connections[currentIndex].centerInt], Vector3.up) == -1f)
		{
			num7 = 360f - num7;
		}
		prefabScript.crossingElements[currentIndex].connectionAngle = num7;
	}

	public void OQQOCQQDOQ(ref List<Vector3> OCCDQOCCDQ, ref List<Vector3> innerSegmentPoints, int leftRight, int startElement, Vector3 leftPoint, Vector3 rightPoint, Vector3 forward, int currentIndex)
	{
		OCCDQOCCDQ.Clear();
		innerSegmentPoints.Clear();
		float num = roundAboutRadius + 0.5f * roundaboutWidth;
		Vector3 vector = mainLeftPoints[startElement];
		Vector3 vector2 = mainLeftPoints[startElement + leftRight * -1];
		Vector3 normalized = (vector2 - vector).normalized;
		if (leftRight == 1)
		{
			normalized = (vector - vector2).normalized;
		}
		Vector3 normalized2 = (rightPoint - leftPoint).normalized;
		float num2 = Vector3.Angle(normalized, normalized2);
		float num3 = 90f / ((float)connections[currentIndex].roundingSegments * 1f);
		float num4 = (90f - num2) / ((float)connections[currentIndex].roundingSegments * 1f);
		num4 = num3;
		if (leftRight == 1)
		{
			num4 *= -1f;
		}
		float num5 = connections[currentIndex].leftRoundingRadius * (num2 / 90f + 1f);
		centerOnLine = Vector3.Lerp(rightPoint, leftPoint, 0.5f);
		Vector3 vector3 = centerOnLine - normalized2 * (0.5f * connections[currentIndex].roadWidth + num5);
		if (leftRight == 1)
		{
			vector3 = centerOnLine + normalized2 * (0.5f * connections[currentIndex].roadWidth + num5);
		}
		Vector3 pivot = vector3 + forward * num5;
		vector3 = centerOnLine - normalized2 * 0.5f * connections[currentIndex].roadWidth;
		if (leftRight == 1)
		{
			vector3 = centerOnLine + normalized2 * 0.5f * connections[currentIndex].roadWidth;
		}
		Vector3 vector4 = vector3 + forward * num5;
		OCCDQOCCDQ.Add(vector4);
		float num6 = 10000f;
		float num7 = 10000f;
		Vector3 vector5;
		for (int i = 1; i < connections[currentIndex].roundingSegments - 1; i++)
		{
			vector5 = OQDDDODCOC(vector4, pivot, Quaternion.Euler(0f, num4 * (float)i, 0f));
			num6 = Vector3.Distance(Vector3.zero, vector5);
			if (num6 > num7)
			{
				break;
			}
			num7 = num6;
			OCCDQOCCDQ.Add(vector5);
			if (num6 < num)
			{
				break;
			}
		}
		Vector3 normalized3 = OCCDQOCCDQ[OCCDQOCCDQ.Count - 1].normalized;
		vector5 = Vector3.zero + normalized3 * num;
		OCCDQOCCDQ[OCCDQOCCDQ.Count - 1] = vector5;
		int num8 = connections[currentIndex].leftOuterInt - 2;
		if (num8 < 0)
		{
			num8 = 0;
		}
		for (int j = num8; j < mainLeftPoints.Count - 1; j++)
		{
			num6 = Vector3.Distance(mainLeftPoints[j], mainLeftPoints[j + 1]);
			num7 = Vector3.Distance(mainLeftPoints[j], vector5);
			if (num7 < num6)
			{
				if (leftRight == -1)
				{
					connections[currentIndex].leftOuterInt = j;
				}
				else
				{
					connections[currentIndex].rightOuterInt = j + 1;
				}
				break;
			}
		}
		if (leftRight == -1)
		{
			OCCDQOCCDQ.Reverse();
		}
		else
		{
			OCCDQOCCDQ.Reverse();
		}
		Vector3 normalized4 = (leftPoint - mainLeftPoints[startElement]).normalized;
		if (leftRight == 1)
		{
			normalized4 = (rightPoint - mainLeftPoints[startElement]).normalized;
		}
		normalized4 = new Vector3(normalized4.z, 0f, 0f - normalized4.x);
		if (leftRight == -1)
		{
			innerSegmentPoints.Add(leftPoint + normalized4 * innerSegmentDistance);
		}
		else
		{
			innerSegmentPoints.Add(rightPoint + -normalized4 * innerSegmentDistance);
		}
		for (int k = 1; k < OCCDQOCCDQ.Count - 1; k++)
		{
			normalized4 = (OCCDQOCCDQ[k] - OCCDQOCCDQ[k - 1]).normalized;
			normalized4 = new Vector3(normalized4.z, 0f, 0f - normalized4.x);
			if (leftRight == -1)
			{
				innerSegmentPoints.Add(OCCDQOCCDQ[k] + normalized4 * innerSegmentDistance);
			}
			else
			{
				innerSegmentPoints.Add(OCCDQOCCDQ[k] + -normalized4 * innerSegmentDistance);
			}
		}
		vector5 = OCCDQOCCDQ[OCCDQOCCDQ.Count - 1];
		vector4 = vector5 + forward * roundAboutResolution;
		normalized4 = (vector4 - OCCDQOCCDQ[OCCDQOCCDQ.Count - 1]).normalized;
		normalized4 = new Vector3(normalized4.z, 0f, 0f - normalized4.x);
		if (leftRight == -1)
		{
			innerSegmentPoints.Add(OCCDQOCCDQ[OCCDQOCCDQ.Count - 1] + normalized4 * innerSegmentDistance);
		}
		else
		{
			innerSegmentPoints.Add(OCCDQOCCDQ[OCCDQOCCDQ.Count - 1] + -normalized4 * innerSegmentDistance);
		}
		OCCDQOCCDQ.Add(vector4);
		innerSegmentPoints.Add(Vector3.zero);
	}

	public void OOCCDCDOQC(int currentIndex)
	{
		connections[currentIndex].leftOuterSegmentsUVs.Clear();
		connections[currentIndex].rightOuterSegmentsUVs.Clear();
		connections[currentIndex].innerRoundaboutUVs.Clear();
		Vector3 vA = connections[currentIndex].leftOuterSegments[connections[currentIndex].leftOuterSegments.Count - 1];
		Vector3 vB = connections[currentIndex].rightOuterSegments[connections[currentIndex].rightOuterSegments.Count - 1];
		Vector3 a = ODDCQDDCDD.OQQCQOCCOQ(vA, vB, connections[currentIndex].leftOuterSegments[0]);
		float num = Vector3.Distance(a, connections[currentIndex].leftOuterSegments[0]);
		Vector3 vector = connections[currentIndex].rightOuterSegments[0];
		Vector3 vector2 = connections[currentIndex].leftOuterSegments[0];
		float num2 = Vector3.Distance(vector, vector2);
		for (int i = 0; i < connections[currentIndex].leftOuterSegments.Count; i++)
		{
			a = ODDCQDDCDD.OQQCQOCCOQ(vA, vB, connections[currentIndex].leftOuterSegments[i]);
			float y = Vector3.Distance(a, connections[currentIndex].leftOuterSegments[i]) / num;
			a = ODDCQDDCDD.OQQCQOCCOQ(vector, vector2, connections[currentIndex].leftOuterSegments[i]);
			float num3 = Vector3.Distance(a, connections[currentIndex].leftOuterSegments[i]) / num2;
			connections[currentIndex].leftOuterSegmentsUVs.Add(new Vector2(1f, y));
		}
		for (int j = 0; j < connections[currentIndex].rightOuterSegments.Count; j++)
		{
			a = ODDCQDDCDD.OQQCQOCCOQ(vA, vB, connections[currentIndex].rightOuterSegments[j]);
			float y = Vector3.Distance(a, connections[currentIndex].rightOuterSegments[j]) / num;
			a = ODDCQDDCDD.OQQCQOCCOQ(vector, vector2, connections[currentIndex].rightOuterSegments[j]);
			float num3 = Vector3.Distance(a, connections[currentIndex].rightOuterSegments[j]) / num2;
			connections[currentIndex].rightOuterSegmentsUVs.Add(new Vector2(0f, y));
		}
		for (int k = 0; k < connections[currentIndex].innerRoundaboutPoints.Count; k++)
		{
			a = ODDCQDDCDD.OQQCQOCCOQ(vA, vB, connections[currentIndex].innerRoundaboutPoints[k]);
			float y = Vector3.Distance(a, connections[currentIndex].innerRoundaboutPoints[k]) / num;
			a = ODDCQDDCDD.OQQCQOCCOQ(vector, vector2, connections[currentIndex].innerRoundaboutPoints[k]);
			float num3 = Vector3.Distance(a, vector) / num2;
			connections[currentIndex].innerRoundaboutUVs.Add(new Vector2(num3, y));
		}
	}

	public void ODDDOCDCQO()
	{
		if (base.gameObject.GetComponent<MeshFilter>() == null)
		{
			base.gameObject.AddComponent<MeshFilter>();
		}
		if (base.gameObject.GetComponent<MeshRenderer>() == null)
		{
			base.gameObject.AddComponent<MeshRenderer>();
		}
		if (base.gameObject.GetComponent<MeshCollider>() == null)
		{
			base.gameObject.AddComponent<MeshCollider>();
		}
		Mesh mesh;
		if (base.gameObject.GetComponent<MeshFilter>().sharedMesh != null)
		{
			mesh = base.gameObject.GetComponent<MeshFilter>().sharedMesh;
		}
		else
		{
			mesh = new Mesh();
			base.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
			base.gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
		}
		if (base.gameObject.GetComponent<MeshRenderer>().sharedMaterial == null)
		{
			if (mainRoadMaterial == null)
			{
				mainRoadMaterial = Resources.Load("Materials/roundabouts/roundabout 2 lane") as Material;
			}
			base.gameObject.GetComponent<MeshRenderer>().sharedMaterial = mainRoadMaterial;
		}
		if (defaultConnectionMaterial == null)
		{
			defaultConnectionMaterial = Resources.Load("Materials/roads/road material") as Material;
		}
		meshVecs = new List<Vector3>();
		List<Vector2> meshUVs = new List<Vector2>();
		for (int i = 0; i < mainRightPoints.Count; i++)
		{
			meshVecs.Add(mainLeftPoints[i]);
			meshVecs.Add(mainCenterPoints[i]);
			meshVecs.Add(mainRightPoints[i]);
			meshUVs.Add(mainLeftPointsUVs[i]);
			meshUVs.Add(mainCenterPointsUVs[i]);
			meshUVs.Add(mainRightPointsUVs[i]);
		}
		List<int> fullTris = new List<int>();
		List<Vector3> connectionVecs = new List<Vector3>();
		List<Vector2> connectionUVs = new List<Vector2>();
		List<int> connectionTris = new List<int>();
		List<List<int>> triList = new List<List<int>>();
		List<Material> materialList = new List<Material>();
		materialList.Add(mainRoadMaterial);
		ODDCQDDCDD.ODQQCQOODQ(connections, mainLeftPoints, ref meshVecs, ref meshUVs, ref fullTris);
		triList.Add(fullTris);
		if (connections.Count > 0)
		{
			ODDCQDDCDD.OODQCCOOQC(connections, meshVecs, meshVecs.Count, ref connectionVecs, ref connectionUVs, ref connectionTris, ref triList, ref materialList);
		}
		meshUVs.AddRange(connectionUVs);
		OQOQCCCDDQ.OQCDQOQCOQ(this, ref meshVecs, ref meshUVs, ref triList, ref materialList);
		if (innerRoundaboutPreset != 0)
		{
			OQOQCCCDDQ.OQCCQQOCCO(this, innerRoundaboutSidewalkV3, innerRoundaboutSidewalUV, innerRoundaboutSidewalTris, ref meshVecs, ref meshUVs, ref triList, ref materialList);
		}
		mesh.Clear();
		mesh.subMeshCount = triList.Count;
		mesh.vertices = meshVecs.ToArray();
		mesh.uv = meshUVs.ToArray();
		mesh.uv2 = meshUVs.ToArray();
		mesh.tangents = new Vector4[mesh.vertices.Length];
		for (int j = 0; j < triList.Count; j++)
		{
			mesh.SetTriangles(triList[j].ToArray(), j);
		}
		mesh.RecalculateBounds();
		mesh.RecalculateNormals();
		mesh.normals = ERSideWalkVecs.ODDQQCCODD(this, mesh.normals);
		ODCCODOCQQ.OCDCQCOQQO(mesh);
		base.gameObject.GetComponent<MeshCollider>().sharedMesh = null;
		base.gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
		base.gameObject.GetComponent<MeshRenderer>().sharedMaterials = materialList.ToArray();
		prefabScript.isRoundabout = true;
		prefabScript.roundaboutScript = this;
		prefabScript.meshVecs = (prefabScript.tmpMeshVecs = (prefabScript.tmpFullMeshVecs = (prefabScript.fullMeshVecs = meshVecs.ToArray())));
		for (int k = 0; k < connections.Count; k++)
		{
			if (connections[k].leftFlag && connections[k].rightFlag)
			{
				if (prefabScript.crossingElements.Count < k + 1)
				{
					prefabScript.crossingElements.Add(new QDOODOQQDQODD());
					connections[k].prefabElement = prefabScript.crossingElements.Count - 1;
				}
				if (prefabScript.sidewalkControlElements.Count < k + 1)
				{
					prefabScript.sidewalkControlElements.Add(new QDOQDSQOOQDDD(baseScript));
				}
				QDOODOQQDQODD qDOODOQQDQODD = prefabScript.crossingElements[k];
				qDOODOQQDQODD.centerPoint = (qDOODOQQDQODD.tmpCenterPoint = connections[k].centerPoint);
				qDOODOQQDQODD.controlPointV3 = connections[k].outerCenterPoint;
				OQCQQCQDCQ(k, connections[k].connectionVecInts, connections[k].roadShapeUVY, connections[k].leftSidewalkTris, connections[k].rightSidewalkTris, 0);
				OCDDOCDDOQ(meshVecs, prefabScript.crossingElements[k].connectionVecInts, ref prefabScript.crossingElements[k].roadShapeVecs, connections[k].roadShapeVecs, connections[k].leftSidewalkV3, connections[k].rightSidewalkV3, k, 0);
				prefabScript.crossingElements[k].roadShapeVecsString = ERCrossings.GetRoadShapeVecString(prefabScript.crossingElements[k].roadShapeVecs, prefabScript.crossingElements[k].sidewalkLeftVecs, prefabScript.crossingElements[k].sidewalkRightVecs, ref prefabScript.crossingElements[k].roadShapeMatchCount);
				ODQCODQDDQ(k, connections[k].roadMaterial, connections[k].leftSidewalkV3.Count, connections[k].rightSidewalkV3.Count);
				qDOODOQQDQODD.roadMaterial = connections[k].roadMaterial;
				qDOODOQQDQODD.blendCornerPointInts = connections[k].blendCornerPointInts;
				qDOODOQQDQODD.blendCornerPointWeights = connections[k].blendCornerPointWeights;
				qDOODOQQDQODD.alignmentHandleVecRotationGizmo = mainLeftPoints[connections[k].centerInt];
				qDOODOQQDQODD.roadType = connections[k].roadType;
				qDOODOQQDQODD.roadTypeTimestamp = connections[k].roadTypeTimestamp;
				OCQOCDQQQD(k);
				prefabScript.sidewalkControlElements[k].crossingElementRightIndex = k;
				if (k == 0)
				{
					prefabScript.sidewalkControlElements[k].crossingElementLeftIndex = connections.Count - 1;
				}
				else
				{
					prefabScript.sidewalkControlElements[k].crossingElementLeftIndex = k - 1;
				}
			}
		}
		ODCQOCOOQO();
		prefabScript.OQQODODQCQ();
		prevRoundAboutRadius = roundAboutRadius;
		prevRoundAboutResolution = roundAboutResolution;
		prevRoundaboutWidth = roundaboutWidth;
		prevNewSegmentInt = newSegmentInt;
		prevRoadWidth = roadWidth;
		prevLeftRoundingRadius = leftRoundingRadius;
		prevRightRoundingRadius = rightRoundingRadius;
		prevRoadTypeInt = roadTypeInt;
		if (connections.Count > 0 && selectedConnection >= 0 && connections.Count > selectedConnection)
		{
			connections[selectedConnection].prevRoadWidth = connections[selectedConnection].roadWidth;
			connections[selectedConnection].prevCenterInt = connections[selectedConnection].centerInt;
			connections[selectedConnection].prevLeftRoundingRadius = connections[selectedConnection].leftRoundingRadius;
			connections[selectedConnection].prevRightRoundingRadius = connections[selectedConnection].rightRoundingRadius;
			connections[selectedConnection].prevRoadType = connections[selectedConnection].roadType;
		}
		UpdateMinMaxInts();
	}

	public void OQCQQCQDCQ(int el, List<int> trIntArray, List<float> uvArray, List<List<int>> leftSidewalkIntArray, List<List<int>> rightSidewalkIntArray, int startend)
	{
		QDOODOQQDQODD qDOODOQQDQODD = prefabScript.crossingElements[el];
		qDOODOQQDQODD.connectionVecInts.Clear();
		qDOODOQQDQODD.blendCornerPointInts.Clear();
		qDOODOQQDQODD.blendCornerPointWeights.Clear();
		qDOODOQQDQODD.roadShapeUVY.Clear();
		QDOQDSQOOQDDD qDOQDSQOOQDDD = null;
		QDOQDSQOOQDDD qDOQDSQOOQDDD2 = null;
		qDOQDSQOOQDDD2 = prefabScript.sidewalkControlElements[el];
		qDOQDSQOOQDDD = ((el >= connections.Count - 1) ? prefabScript.sidewalkControlElements[0] : prefabScript.sidewalkControlElements[el + 1]);
		qDOODOQQDQODD.sidewalkLeftUVY.Clear();
		qDOODOQQDQODD.sidewalkLeftConnectionVecInts.Clear();
		if (qDOODOQQDQODD.includeLeftSidewalk)
		{
			for (int i = 0; i < leftSidewalkIntArray.Count; i++)
			{
				qDOODOQQDQODD.sidewalkLeftConnectionVecInts.Add(leftSidewalkIntArray[i][0]);
			}
			qDOODOQQDQODD.sidewalkLeftConnectionVecInts.Reverse();
			qDOODOQQDQODD.sidewalkLeftUVY.AddRange(qDOQDSQOOQDDD.sidewalkUVs);
			qDOODOQQDQODD.sidewalkLeftUVY.Reverse();
		}
		qDOODOQQDQODD.connectionVecInts.Add(trIntArray[0]);
		qDOODOQQDQODD.connectionVecInts.Add(trIntArray[trIntArray.Count - 1]);
		qDOODOQQDQODD.roadShapeUVY.Add(uvArray[0]);
		qDOODOQQDQODD.roadShapeUVY.Add(uvArray[uvArray.Count - 1]);
		qDOODOQQDQODD.sidewalkRightUVY.Clear();
		qDOODOQQDQODD.sidewalkRightConnectionVecInts.Clear();
		if (qDOODOQQDQODD.includeRightSidewalk)
		{
			for (int j = 0; j < rightSidewalkIntArray.Count; j++)
			{
				qDOODOQQDQODD.sidewalkRightConnectionVecInts.Add(rightSidewalkIntArray[j][0]);
			}
			qDOODOQQDQODD.sidewalkRightUVY.AddRange(qDOQDSQOOQDDD2.sidewalkUVs);
		}
		qDOODOQQDQODD.connectionVecInts.InsertRange(0, qDOODOQQDQODD.sidewalkLeftConnectionVecInts);
		qDOODOQQDQODD.connectionVecInts.AddRange(qDOODOQQDQODD.sidewalkRightConnectionVecInts);
		qDOODOQQDQODD.fullConnectionVecInts = new List<int>(qDOODOQQDQODD.connectionVecInts);
		qDOODOQQDQODD.leftInt = 0;
		qDOODOQQDQODD.leftIntFull = 0;
		qDOODOQQDQODD.rightInt = qDOODOQQDQODD.connectionVecInts.Count - 1;
		qDOODOQQDQODD.rightIntFull = qDOODOQQDQODD.fullConnectionVecInts.Count - 1;
	}

	public void OCDDOCDDOQ(List<Vector3> meshVecs, List<int> connectionVecInts, ref List<Vector2> roadShapeVecs, List<Vector2> vecArrays, List<List<Vector3>> leftSidewalkArray, List<List<Vector3>> rightSidewalkArray, int connectionElement, int startend)
	{
		QDOODOQQDQODD qDOODOQQDQODD = prefabScript.crossingElements[connectionElement];
		roadShapeVecs.Clear();
		qDOODOQQDQODD.sidewalkLeftVecs.Clear();
		qDOODOQQDQODD.sidewalkRightVecs.Clear();
		Vector3 zero;
		Vector3 vector = (zero = Vector3.zero);
		Vector3 vector2 = leftSidewalkArray[0][0];
		Vector3 centerPoint = connections[connectionElement].centerPoint;
		float num = Vector3.Distance(leftSidewalkArray[0][0], rightSidewalkArray[0][0]) * 0.5f;
		for (int i = 0; i < connectionVecInts.Count - 1; i++)
		{
		}
		List<Vector3> list = new List<Vector3>();
		if (qDOODOQQDQODD.includeLeftSidewalk)
		{
			for (int j = 0; j < leftSidewalkArray.Count; j++)
			{
				list.Add(leftSidewalkArray[j][0]);
			}
			list.Reverse();
			vector = list[0];
			vector2 = vector;
			vector2.y = 0f;
			num = Vector3.Distance(vector2, centerPoint);
			ERCrossings.ODOODQDCCQ(list, ref qDOODOQQDQODD.sidewalkLeftVecs, centerPoint, vector2, num);
		}
		list.Clear();
		list.Add(leftSidewalkArray[0][0]);
		list.Add(rightSidewalkArray[0][0]);
		if (vector == Vector3.zero)
		{
			vector = list[0];
		}
		zero = list[list.Count - 1];
		ERCrossings.ODOODQDCCQ(list, ref roadShapeVecs, centerPoint, vector2, num);
		if (qDOODOQQDQODD.includeRightSidewalk)
		{
			list.Clear();
			for (int k = 0; k < rightSidewalkArray.Count; k++)
			{
				list.Add(rightSidewalkArray[k][0]);
			}
			zero = list[list.Count - 1];
			ERCrossings.ODOODQDCCQ(list, ref qDOODOQQDQODD.sidewalkRightVecs, centerPoint, vector2, num);
		}
		vector.y = 0f;
		zero.y = 0f;
		float num2 = Vector3.Distance(vector, zero);
		qDOODOQQDQODD.centerPointPercentage = num / num2;
	}

	public void ODQCODQDDQ(int el, Material roadMaterial, int leftVecCount, int rightVecCount)
	{
		QDOODOQQDQODD qDOODOQQDQODD = prefabScript.crossingElements[el];
		QDOQDSQOOQDDD qDOQDSQOOQDDD = prefabScript.sidewalkControlElements[el];
		QDOQDSQOOQDDD qDOQDSQOOQDDD2 = null;
		qDOQDSQOOQDDD2 = ((el >= connections.Count - 1) ? prefabScript.sidewalkControlElements[0] : prefabScript.sidewalkControlElements[el + 1]);
		qDOODOQQDQODD.roadMaterial = roadMaterial;
		List<Material> list = new List<Material>();
		List<int> list2 = new List<int>();
		list.Add(roadMaterial);
		if (qDOODOQQDQODD.includeLeftSidewalk)
		{
			if (list[0] != qDOQDSQOOQDDD2.sidewalkMaterial)
			{
				list.Add(qDOQDSQOOQDDD2.sidewalkMaterial);
				for (int i = 0; i < leftVecCount; i++)
				{
					list2.Add(1);
				}
			}
			else
			{
				for (int j = 0; j < leftVecCount; j++)
				{
					list2.Add(0);
				}
			}
		}
		list2.Add(0);
		list2.Add(0);
		if (qDOODOQQDQODD.includeRightSidewalk)
		{
			if (list[0] != qDOQDSQOOQDDD.sidewalkMaterial && qDOQDSQOOQDDD2.sidewalkMaterial != qDOQDSQOOQDDD.sidewalkMaterial && qDOODOQQDQODD.includeLeftSidewalk)
			{
				list.Add(qDOQDSQOOQDDD.sidewalkMaterial);
				for (int k = 0; k < rightVecCount; k++)
				{
					list2.Add(2);
				}
			}
			else if (list[0] == qDOQDSQOOQDDD.sidewalkMaterial)
			{
				for (int l = 0; l < rightVecCount; l++)
				{
					list2.Add(0);
				}
			}
			else if (qDOQDSQOOQDDD2.sidewalkMaterial == qDOQDSQOOQDDD.sidewalkMaterial || !qDOODOQQDQODD.includeLeftSidewalk)
			{
				if (!qDOODOQQDQODD.includeLeftSidewalk)
				{
					list.Add(qDOQDSQOOQDDD.sidewalkMaterial);
				}
				for (int m = 0; m < rightVecCount; m++)
				{
					list2.Add(1);
				}
			}
		}
		qDOODOQQDQODD.roadMaterials = list.ToArray();
		qDOODOQQDQODD.roadShapeMaterialInts.Clear();
		qDOODOQQDQODD.roadShapeMaterialInts.AddRange(list2);
	}

	public void ODCQOCOOQO()
	{
	}

	public void OCQOCDQQQD(int el)
	{
		QDOODOQQDQODD qDOODOQQDQODD = prefabScript.crossingElements[el];
		QDOQDSQOOQDDD qDOQDSQOOQDDD = prefabScript.sidewalkControlElements[el];
		QDOQDSQOOQDDD qDOQDSQOOQDDD2 = null;
		qDOQDSQOOQDDD2 = ((el >= connections.Count - 1) ? prefabScript.sidewalkControlElements[0] : prefabScript.sidewalkControlElements[el + 1]);
		float num = roundAboutRadius + 0.5f * roundaboutWidth;
		float num2 = 0f;
		Vector3 prevVec = Vector3.zero;
		Vector3 firstIndent = Vector3.zero;
		Vector3 vector = Vector3.zero;
		List<Vector3> list = new List<Vector3>();
		if (baseScript == null)
		{
			baseScript = UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase;
		}
		float num3 = num + baseScript.minIndent;
		float num4 = num3 + baseScript.minSurrounding;
		float num5 = baseScript.minIndent;
		Vector3 vector2 = connections[el].leftSidewalkV3[0][connections[el].leftSidewalkV3[0].Count - 1];
		Vector3 vector3 = connections[el].rightSidewalkV3[0][connections[el].rightSidewalkV3[0].Count - 1];
		if (el == 0 || el == connections.Count - 1)
		{
			int num6 = connections[0].leftOuterInt;
			int num7 = mainLeftPoints.Count - connections[connections.Count - 1].rightOuterInt;
			int num8 = Mathf.RoundToInt((float)(num6 + num7) * 0.5f);
			num8 = ((num8 >= num6) ? (mainLeftPoints.Count - (num8 - num6)) : (num6 - num8));
			if (num8 >= mainLeftPoints.Count)
			{
				num8 = mainLeftPoints.Count - 1;
			}
			if (el == 0)
			{
				vector3 = mainLeftPoints[num8];
			}
			else
			{
				vector2 = mainLeftPoints[num8];
			}
		}
		if (qDOQDSQOOQDDD.renderFlag)
		{
			num3 += qDOQDSQOOQDDD.sidewalkWidth1;
			num2 = qDOQDSQOOQDDD.sidewalkWidth1;
			num5 += qDOQDSQOOQDDD.sidewalkWidth1;
		}
		num4 = num3 + baseScript.minSurrounding;
		list.AddRange(connections[el].rightSidewalkV3[0]);
		connections[el].rightIndentBorderInt = -1;
		for (int i = 0; i < list.Count; i++)
		{
			Vector3 vector4 = ((i == 0) ? (list[i + 1] - list[i]).normalized : ((i >= list.Count - 1) ? (list[i] - list[i - 1]).normalized : (list[i + 1] - list[i - 1]).normalized));
			vector4 = new Vector3(vector4.z, 0f, 0f - vector4.x).normalized;
			Vector3 vec = list[i] + vector4 * num5;
			if (OQQCODDOOQ(i, num3, prevVec, boolCheck: true, ref vec, ref connections[el].rightIndentBorderInt))
			{
				if (i == 0 && connections[el].rightIndentBorderInt == 0)
				{
					vec = list[i].normalized * num3;
					vec += vector4 * num5;
				}
				connections[el].rightIndentvecs.Add(vec);
				prevVec = vec;
				if (i == 0)
				{
					firstIndent = vec;
				}
				vec += vector4 * baseScript.minSurrounding;
				vec = OCQOCDODDQ.ODCCDOCDQD(base.transform, vec, baseScript);
				if (connections[el].rightIndentBorderInt <= 0 && vector3 != list[i])
				{
					ODQOOCQDDD(num4, vector3, list[i], boolCheck: true, ref vec);
				}
				if (vector != Vector3.zero)
				{
					CheckAgainstFirstSurroundingVec(firstIndent, vector, boolCheck: true, ref vec);
				}
				connections[el].rightSurroundingvecs.Add(vec);
				if (i == 0)
				{
					vector = vec;
				}
			}
		}
		num3 = num + baseScript.minIndent;
		num4 = num3 + baseScript.minSurrounding;
		num5 = baseScript.minIndent;
		prevVec = Vector3.zero;
		firstIndent = Vector3.zero;
		vector = Vector3.zero;
		if (qDOQDSQOOQDDD2.renderFlag)
		{
			num3 += qDOQDSQOOQDDD2.sidewalkWidth1;
			num2 = qDOQDSQOOQDDD2.sidewalkWidth1;
			num5 += qDOQDSQOOQDDD2.sidewalkWidth1;
		}
		num4 = num3 + baseScript.minSurrounding;
		list.Clear();
		list.AddRange(connections[el].leftSidewalkV3[0]);
		connections[el].leftIndentBorderInt = -1;
		for (int j = 0; j < list.Count; j++)
		{
			Vector3 vector4 = ((j == 0) ? (list[j + 1] - list[j]).normalized : ((j >= list.Count - 1) ? (list[j] - list[j - 1]).normalized : (list[j + 1] - list[j - 1]).normalized));
			vector4 = new Vector3(vector4.z, 0f, 0f - vector4.x).normalized * -1f;
			Vector3 vec = list[j] + vector4 * num5;
			if (OQQCODDOOQ(j, num3, prevVec, boolCheck: false, ref vec, ref connections[el].leftIndentBorderInt))
			{
				if (j == 0 && connections[el].leftIndentBorderInt == 0)
				{
					vec = list[j].normalized * num3;
					vec += vector4 * num5;
				}
				connections[el].leftIndentvecs.Add(vec);
				prevVec = vec;
				if (j == 0)
				{
					firstIndent = vec;
				}
				vec += vector4 * baseScript.minSurrounding;
				vec = OCQOCDODDQ.ODCCDOCDQD(base.transform, vec, baseScript);
				if (connections[el].leftIndentBorderInt <= 0 && vector2 != list[j])
				{
					ODQOOCQDDD(num4, vector2, list[j], boolCheck: false, ref vec);
				}
				if (vector != Vector3.zero)
				{
					CheckAgainstFirstSurroundingVec(firstIndent, vector, boolCheck: false, ref vec);
				}
				connections[el].leftSurroundingvecs.Add(vec);
				if (j == 0)
				{
					vector = vec;
				}
			}
		}
	}

	public static bool OQQCODDOOQ(int el, float roundaboutIndent, Vector3 prevVec, bool boolCheck, ref Vector3 vec, ref int indentBorderInt)
	{
		float num = Vector3.Distance(vec, Vector3.zero) + 0.2f;
		if (num < roundaboutIndent)
		{
			if (indentBorderInt == -1)
			{
				indentBorderInt = el - 1;
			}
			if (indentBorderInt == -1)
			{
				indentBorderInt = 0;
				Vector3 normalized = vec.normalized;
				vec += normalized * (roundaboutIndent - num);
				return true;
			}
			return false;
		}
		if (prevVec != Vector3.zero)
		{
			if (ODQDQDQDQO.OQCDCDOOCD(vec, Vector3.zero, prevVec) == boolCheck)
			{
				return true;
			}
			return false;
		}
		return true;
	}

	public void ODQOOCQDDD(float minSurrounding, Vector3 middleVec, Vector3 origVec, bool boolCheck, ref Vector3 vec)
	{
		float num = Vector3.Distance(vec, Vector3.zero);
		if (num < minSurrounding)
		{
			Vector3 normalized = vec.normalized;
			vec = normalized * minSurrounding;
			vec = OCQOCDODDQ.ODCCDOCDQD(base.transform, vec, baseScript);
		}
		if (ODQDQDQDQO.OQCDCDOOCD(middleVec, Vector3.zero, vec) != boolCheck && ODQDQDQDQO.OQCDCDOOCD(middleVec, Vector3.zero, origVec) == boolCheck)
		{
			vec = ODQDQDQDQO.OODOQDOODO(Vector3.zero, middleVec, origVec, vec, flag: false);
			vec = OCQOCDODDQ.ODCCDOCDQD(base.transform, vec, baseScript);
		}
	}

	public void CheckAgainstFirstSurroundingVec(Vector3 firstIndent, Vector3 firstSurrounding, bool boolCheck, ref Vector3 vec)
	{
		if (ODQDQDQDQO.OQCDCDOOCD(firstSurrounding, firstIndent, vec) == boolCheck)
		{
			vec = firstSurrounding;
		}
	}

	public static Vector3 OODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4)
	{
		float num = p1.x - p3.x;
		float num2 = p1.z - p3.z;
		float num3 = p2.z - p1.z;
		float num4 = p2.x - p1.x;
		float num5 = num3 * p1.x + num4 * p1.z;
		float num6 = p4.z - p3.z;
		float num7 = p4.x - p3.x;
		float num8 = num6 * p3.x + num7 * p3.z;
		float num9 = num3 * num7 - num6 * num4;
		if (num9 == 0f)
		{
			return Vector3.zero;
		}
		float num10 = num6 * num4 - num7 * num3;
		float num11 = (num7 * num2 - num6 * num) / num10;
		float num12 = (num4 * num2 - num3 * num) / num10;
		float x = p1.x + num11 * num4;
		float z = p1.z + num11 * num3;
		return new Vector3(x, p1.y, z);
	}

	public static Vector3 OQDDDODCOC(Vector3 point, Vector3 pivot, Quaternion angle)
	{
		Vector3 vector = point - pivot;
		vector = angle * vector;
		return vector + pivot;
	}
}
[AddComponentMenu("")]
public class OODODOQDCC : MonoBehaviour
{
	public static void OQCCCDDOQO(ERBend scr, ref List<Vector3> leftOuterSegments, ref List<Vector3> leftInnerSegments, ref List<Vector3> rightOuterSegments, ref List<Vector3> rightInnerSegments)
	{
		float roundAboutRadius = scr.roundAboutRadius;
		Vector3 vector = new Vector3(scr.roadWidth * 0.5f, 0f, 0f);
		Vector3 vector2 = new Vector3(scr.roadWidth * 0.5f - scr.innerSegmentDistance, 0f, 0f);
		Vector3 pivot = vector + Vector3.right * roundAboutRadius;
		float num = scr.bendAngle / ((float)scr.roundingSegments * 1f);
		float num2 = 0f;
		rightOuterSegments.Add(vector);
		rightInnerSegments.Add(vector2);
		for (int i = 0; i <= scr.roundingSegments; i++)
		{
			rightOuterSegments.Add(ERRoundabouts.OQDDDODCOC(vector, pivot, Quaternion.Euler(0f, num2 + (float)i * num, 0f)));
			rightInnerSegments.Add(ERRoundabouts.OQDDDODCOC(vector2, pivot, Quaternion.Euler(0f, num2 + (float)i * num, 0f)));
		}
		vector = new Vector3(scr.roadWidth * -0.5f, 0f, 0f);
		vector2 = new Vector3(scr.roadWidth * -0.5f + scr.innerSegmentDistance, 0f, 0f);
		leftOuterSegments.Add(vector);
		leftInnerSegments.Add(vector2);
		float num3 = roundAboutRadius * 4f;
		vector += Vector3.forward * ((roundAboutRadius + scr.roadWidth - num3) * (scr.bendAngle / 90f));
		leftOuterSegments.Add(vector);
		vector2 += Vector3.forward * ((roundAboutRadius + scr.roadWidth - num3) * (scr.bendAngle / 90f));
		leftInnerSegments.Add(vector2);
		pivot = vector + Vector3.right * num3;
		for (int j = 0; j <= scr.roundingSegments; j++)
		{
			leftOuterSegments.Add(ERRoundabouts.OQDDDODCOC(vector, pivot, Quaternion.Euler(0f, num2 + (float)j * num, 0f)));
			leftInnerSegments.Add(ERRoundabouts.OQDDDODCOC(vector2, pivot, Quaternion.Euler(0f, num2 + (float)j * num, 0f)));
		}
		Vector3 normalized = (rightInnerSegments[rightInnerSegments.Count - 1] - rightOuterSegments[rightOuterSegments.Count - 1]).normalized;
		vector = rightOuterSegments[rightOuterSegments.Count - 1] + normalized * scr.roadWidth;
		leftOuterSegments.Add(vector);
		vector2 = rightOuterSegments[rightOuterSegments.Count - 1] + normalized * (scr.roadWidth - scr.innerSegmentDistance);
		leftInnerSegments.Add(vector2);
	}

	public static List<Vector3> OOOOOOODCO(Vector3 prefabCenterpos, Vector3 cpCenterposV3, Vector3 v1, Vector3 cp, ref float totalDistance, ref List<Vector3> controlPoints)
	{
		Vector3 vector = prefabCenterpos - cpCenterposV3;
		vector = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
		Vector3 vA = prefabCenterpos + vector * 1000f;
		Vector3 vB = prefabCenterpos + -vector * 1000f;
		vA = ODQDQDQDQO.OQQCQOCCOQ(vA, vB, v1);
		vector = (vA - v1).normalized;
		float num = Vector3.Distance(v1, vA);
		vA += vector * num;
		List<Vector3> list = new List<Vector3>();
		List<Vector3> list2 = new List<Vector3>();
		controlPoints.Add(cp);
		controlPoints.Add(v1);
		controlPoints.Add(prefabCenterpos);
		controlPoints.Add(vA);
		Vector3 vector2;
		Vector3 a = (vector2 = Vector3.zero);
		for (int i = 1; i < controlPoints.Count - 2; i++)
		{
			float num2 = 0.01f;
			for (float num3 = 0f; num3 <= 1f; num3 += num2)
			{
				vector2 = ERModularRoad.OODODQQQCD(controlPoints[i - 1], controlPoints[i], controlPoints[i + 1], controlPoints[i + 2], num3, 0.5f);
				if (Vector3.Distance(a, vector2) > 1f)
				{
					if (list.Count > 0)
					{
						totalDistance += Vector3.Distance(a, vector2);
					}
					list.Add(vector2);
					a = vector2;
				}
			}
		}
		totalDistance += Vector3.Distance(a, vector2);
		float num4 = Vector3.Distance(prefabCenterpos, cpCenterposV3);
		return controlPoints;
	}

	public static List<Vector3> ODQOQQOQOC(Vector3 prefabCenterpos, Vector3 cpCenterposV3, Vector3 v1, Vector3 cp, ref float totalDistance, ref List<Vector3> controlPoints, float angle, float multiplyFactor)
	{
		angle *= 0.55f;
		Vector3 normalized = (prefabCenterpos - cpCenterposV3).normalized;
		Vector3 zero = Vector3.zero;
		zero = ((!ODQDQDQDQO.OQCDCDOOCD(cpCenterposV3, prefabCenterpos, v1)) ? ODQDQDQDQO.OQDDDODCOC(cpCenterposV3, prefabCenterpos, Quaternion.Euler(0f, 0f - angle, 0f)) : ODQDQDQDQO.OQDDDODCOC(cpCenterposV3, prefabCenterpos, Quaternion.Euler(0f, angle, 0f)));
		normalized = new Vector3(normalized.z, 0f, 0f - normalized.x).normalized;
		Vector3 vA = prefabCenterpos + normalized * 1000f;
		Vector3 vB = prefabCenterpos + -normalized * 1000f;
		vA = ODQDQDQDQO.OQQCQOCCOQ(vA, vB, zero);
		normalized = (vA - zero).normalized;
		float num = Vector3.Distance(zero, vA);
		vA += normalized * num;
		normalized = (v1 - zero).normalized;
		v1 = zero + normalized * Vector3.Distance(zero, prefabCenterpos);
		List<Vector3> list = new List<Vector3>();
		List<Vector3> list2 = new List<Vector3>();
		Vector3 normalized2 = (v1 - zero).normalized;
		normalized = (zero - prefabCenterpos).normalized;
		float num2 = Vector3.Distance(zero, v1);
		controlPoints.Add(v1);
		controlPoints.Add(zero);
		controlPoints.Add(prefabCenterpos);
		controlPoints.Add(vA);
		Vector3 vector;
		Vector3 a = (vector = Vector3.zero);
		for (int i = 1; i < controlPoints.Count - 2; i++)
		{
			float num3 = 0.01f;
			for (float num4 = 0f; num4 <= 1f; num4 += num3)
			{
				vector = ERModularRoad.OODODQQQCD(controlPoints[i - 1], controlPoints[i], controlPoints[i + 1], controlPoints[i + 2], num4, 0.5f);
				if (Vector3.Distance(a, vector) > 1f)
				{
					if (list.Count > 0)
					{
						totalDistance += Vector3.Distance(a, vector);
					}
					list.Add(vector);
					a = vector;
				}
			}
		}
		totalDistance += Vector3.Distance(a, vector);
		return controlPoints;
	}

	public static Vector3[] OOOOCDQODC(ERCrossingPrefabs scr, int connection, List<Vector3> controlPoints, float segmentDistance, float defaultDistance, Vector3[] meshVecs, ref Vector3[] tCrossingTmpFullMeshVecs, float multiplyFactor, float angle, float curveStrength)
	{
		Transform transform = scr.transform;
		Vector3[] array = new Vector3[meshVecs.Length];
		Array.Copy(meshVecs, array, meshVecs.Length);
		int tCrossingLeftRight = scr.tCrossingLeftRight;
		Vector3 pTarget = scr.transform.TransformPoint(new Vector3(0f, 0f, 1f));
		Vector3 pSource = scr.transform.TransformPoint(Vector3.zero);
		if (!ODQDQDQDQO.OQCDCDOOCD(pTarget, pSource, controlPoints[2]))
		{
			angle *= -1f;
		}
		float num = angle;
		if (num < 0f)
		{
			num *= -1f;
		}
		float num2 = 1000f;
		float num3 = -1000f;
		Vector3 zero = Vector3.zero;
		float num4 = 0f;
		bool flag = false;
		for (int i = 0; i < array.Length; i++)
		{
			if ((array[i].z > 0f && connection == 1) || ((array[i].z < 0f && connection == 0) ? true : false))
			{
				Vector3 vector = array[i];
				float z = array[i].z;
				if ((tCrossingLeftRight == 0 && angle > 0f) || (tCrossingLeftRight == 1 && angle < 0f))
				{
					num4 = array[i].z / segmentDistance * Mathf.Lerp(1.15f, 0.5f, num / 90f) * multiplyFactor;
				}
				else
				{
					num4 = array[i].z / segmentDistance * Mathf.Lerp(1f, 2.1f, num / 90f) * multiplyFactor;
					if (i < scr.tCrossingBlendData.Count && scr.tCrossingBlendData[i].blendWeight == 1f && !flag)
					{
						flag = true;
					}
				}
				if (connection == 0)
				{
					num4 *= -1f;
				}
				zero = ERModularRoad.OODODQQQCD(controlPoints[0], controlPoints[1], controlPoints[2], controlPoints[3], num4, curveStrength);
				Vector3 vector2 = ERModularRoad.OODODQQQCD(controlPoints[0], controlPoints[1], controlPoints[2], controlPoints[3], num4 - 0.001f, curveStrength);
				Vector3 vector3 = ERModularRoad.OODODQQQCD(controlPoints[0], controlPoints[1], controlPoints[2], controlPoints[3], num4 + 0.001f, curveStrength);
				Vector3 vector4 = vector3 - vector2;
				vector4 = ((connection != 1) ? new Vector3(0f - vector4.z, 0f, vector4.x).normalized : new Vector3(vector4.z, 0f, 0f - vector4.x).normalized);
				zero += vector4 * array[i].x;
				zero = transform.InverseTransformPoint(zero);
				zero.y = meshVecs[i].y;
				if (scr.tCrossingBlendData.Count > i)
				{
					if (meshVecs[i].x < num2)
					{
						num2 = meshVecs[i].x;
					}
					if (meshVecs[i].x > num3)
					{
						num3 = meshVecs[i].x;
					}
					if (scr.tCrossingBlendData[i].blendWeight > 0f)
					{
						zero.z = Mathf.Lerp(array[i].z, zero.z, scr.tCrossingBlendData[i].blendWeight);
					}
					else if (scr.tCrossingBlendData[i].blendWeight < 0f)
					{
						if ((tCrossingLeftRight == 0 && angle < 0f) || (tCrossingLeftRight == 1 && angle > 0f))
						{
							zero.z = array[i].z;
						}
						else
						{
							zero.z = array[i].z;
							zero.x = Mathf.Lerp(array[i].x, zero.x, 0.5f);
						}
					}
					else
					{
						zero = array[i];
					}
				}
				else if (meshVecs[i].x <= num2 || meshVecs[i].x >= num3)
				{
					zero = array[i];
				}
				tCrossingTmpFullMeshVecs[i] = zero;
			}
			array[i] = tCrossingTmpFullMeshVecs[i];
		}
		return array;
	}

	public static Vector3[] OCOOCQDCDD(ERCrossingPrefabs scr, int connection, List<Vector3> controlPoints, float segmentDistance, float defaultDistance, Vector3[] meshVecs, ref Vector3[] tmpSurfaceVecsTCrossings, float multiplyFactor, float angle, float curveStrength)
	{
		Transform transform = scr.transform;
		Vector3[] array = new Vector3[meshVecs.Length];
		Array.Copy(meshVecs, array, meshVecs.Length);
		int tCrossingLeftRight = scr.tCrossingLeftRight;
		Vector3 pTarget = scr.transform.TransformPoint(new Vector3(0f, 0f, 1f));
		Vector3 pSource = scr.transform.TransformPoint(Vector3.zero);
		if (!ODQDQDQDQO.OQCDCDOOCD(pTarget, pSource, controlPoints[2]))
		{
			angle *= -1f;
		}
		float num = 0f;
		for (int i = 0; i < array.Length; i++)
		{
			if ((array[i].z > 0f && connection == 1) || ((array[i].z < 0f && connection == 0) ? true : false))
			{
				float z = array[i].z;
				num = (((tCrossingLeftRight != 0 || !(angle > 0f)) && (tCrossingLeftRight != 1 || !(angle < 0f))) ? (array[i].z / segmentDistance * Mathf.Lerp(1f, 1.9f, angle / 90f) * multiplyFactor) : (array[i].z / segmentDistance * 1f));
				if (connection == 0)
				{
					num *= -1f;
				}
				Vector3 position = ERModularRoad.OODODQQQCD(controlPoints[0], controlPoints[1], controlPoints[2], controlPoints[3], num, curveStrength);
				Vector3 vector = ERModularRoad.OODODQQQCD(controlPoints[0], controlPoints[1], controlPoints[2], controlPoints[3], num - 0.001f, curveStrength);
				Vector3 vector2 = ERModularRoad.OODODQQQCD(controlPoints[0], controlPoints[1], controlPoints[2], controlPoints[3], num + 0.001f, curveStrength);
				Vector3 vector3 = vector2 - vector;
				vector3 = ((connection != 1) ? new Vector3(0f - vector3.z, 0f, vector3.x).normalized : new Vector3(vector3.z, 0f, 0f - vector3.x).normalized);
				position += vector3 * array[i].x;
				position = transform.InverseTransformPoint(position);
				position.y = array[i].y;
				array[i] = (tmpSurfaceVecsTCrossings[i] = position);
			}
			else
			{
				array[i] = tmpSurfaceVecsTCrossings[i];
			}
		}
		return array;
	}

	public static Vector3[] OCDDOQCCQC(ERCrossingPrefabs scr, int connection, List<Vector3> controlPoints, float segmentDistance, Vector3[] meshVecs, float multiplyFactor, float angle, Vector3 cpCenterPoint)
	{
		multiplyFactor *= multiplyFactor * multiplyFactor * multiplyFactor;
		Transform transform = scr.transform;
		Vector3 pCheck = transform.InverseTransformPoint(controlPoints[3]);
		cpCenterPoint = transform.InverseTransformPoint(cpCenterPoint);
		if (!ODQDQDQDQO.OQCDCDOOCD(new Vector3(0f, 0f, 1f), Vector3.zero, pCheck))
		{
			angle *= -1f;
		}
		Vector3[] array = new Vector3[meshVecs.Length];
		Array.Copy(meshVecs, array, meshVecs.Length);
		float num = scr.tConnectionRoadWidth * 0.5f;
		float num2 = scr.tMainRoadWidth * 0.5f;
		int tCrossingLeftRight = scr.tCrossingLeftRight;
		float topRightSidewalkWidth = scr.topRightSidewalkWidth;
		float topRightSidewalkCurbDepth = scr.topRightSidewalkCurbDepth;
		float num3 = 0f;
		Vector3 vec = Vector3.zero;
		if (tCrossingLeftRight == 0)
		{
			num3 = array[scr.crossingElements[2].connectionVecInts[0]].x + 0.5f;
			switch (connection)
			{
			case 0:
				vec = array[scr.crossingElements[connection].connectionVecInts[0]];
				break;
			case 1:
				vec = array[scr.crossingElements[connection].connectionVecInts[scr.crossingElements[connection].connectionVecInts.Count - 1]];
				break;
			}
		}
		else
		{
			num3 = array[scr.crossingElements[3].connectionVecInts[0]].x - 0.5f;
			switch (connection)
			{
			case 0:
				vec = array[scr.crossingElements[connection].connectionVecInts[scr.crossingElements[connection].connectionVecInts.Count - 1]];
				break;
			case 1:
				vec = array[scr.crossingElements[connection].connectionVecInts[0]];
				break;
			}
		}
		UnityEngine.Debug.Log(num3 + " " + num);
		Vector3 zero = Vector3.zero;
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 0f;
		bool flag = false;
		for (int i = 0; i < array.Length; i++)
		{
			if (!(array[i].z > 0f))
			{
				continue;
			}
			bool flag2 = true;
			if (tCrossingLeftRight == 0)
			{
				if (array[i].x < num3)
				{
					flag2 = false;
				}
				else if (array[i].x < 0f && array[i].z <= num)
				{
					flag2 = false;
				}
			}
			else if (array[i].x > num3)
			{
				flag2 = false;
			}
			else if (array[i].x > 0f && array[i].z <= num)
			{
				flag2 = false;
			}
			if (!flag2)
			{
				continue;
			}
			float x = array[i].x;
			float z = array[i].z;
			Vector3 vector = array[i];
			float num7 = angle;
			float num8 = array[i].z - num;
			float z2 = array[i].z;
			if (angle > 0f)
			{
				if (tCrossingLeftRight == 1)
				{
					if (!(x <= 0f))
					{
					}
				}
				else
				{
					num5 = GetZAdjust(vec, num7);
				}
			}
			else if (tCrossingLeftRight == 1)
			{
				num5 = GetZAdjust(vec, num7);
			}
			num7 = array[i].z / cpCenterPoint.z * num7;
			array[i] = ODQDQDQDQO.OQDDDODCOC(array[i], zero, Quaternion.Euler(0f, num7, 0f));
			if ((angle < 0f && tCrossingLeftRight == 1) || (angle > 0f && tCrossingLeftRight == 0))
			{
				if ((x < 0f && tCrossingLeftRight == 1) || (x > 0f && tCrossingLeftRight == 0))
				{
					num6 = vector.z / cpCenterPoint.z;
					flag = false;
				}
				else
				{
					num6 = (vector.z - num) / (cpCenterPoint.z - num);
					flag = true;
				}
			}
			if ((x < 0f && tCrossingLeftRight == 0) || (x > 0f && tCrossingLeftRight == 1))
			{
				if (!(vector.z >= num + topRightSidewalkWidth - topRightSidewalkCurbDepth) || !(vector.z <= num + topRightSidewalkWidth) || !(vector.x >= num2 + topRightSidewalkWidth - topRightSidewalkCurbDepth) || vector.x <= num2 + topRightSidewalkWidth)
				{
				}
				if (vector.z >= num + topRightSidewalkWidth - topRightSidewalkCurbDepth && vector.z <= num + topRightSidewalkWidth && !(vector.x >= num2 + topRightSidewalkWidth - topRightSidewalkCurbDepth))
				{
				}
			}
		}
		return array;
	}

	private static float GetZAdjust(Vector3 vec, float angle)
	{
		Vector3 vector = ODQDQDQDQO.OQDDDODCOC(vec, Vector3.zero, Quaternion.Euler(0f, angle, 0f));
		return Mathf.Abs(vec.z - vector.z);
	}

	public static void OCQQDDOCCD(ERCrossings scr, int connection, int x, int y, List<List<Vector3>> vecArray)
	{
		float num = 1f;
		int tCrossingLeftRight = scr.prefabScript.tCrossingLeftRight;
		float num2 = scr.frontRoadWidth * 0.5f;
		float num3 = 0f;
		if (tCrossingLeftRight == 0)
		{
			num3 = scr.leftRoadWidth * 0.5f;
		}
		num3 = scr.rightRoadWidth * 0.5f;
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 0f;
		float num7 = 0f;
		float num8 = 0f;
		float num9 = 0f;
		float num10 = 0f;
		float num11 = 0f;
		float num12 = 0f;
		if (connection == 0 && tCrossingLeftRight == 0)
		{
			num4 = scr.prefabScript.sidewalkControlElements[0].cornerRadius;
			num5 = scr.prefabScript.sidewalkControlElements[0].sidewalkWidth1;
			num6 = scr.prefabScript.sidewalkControlElements[0].curbDepth;
		}
		else if (connection == 0 && tCrossingLeftRight == 1)
		{
			num4 = scr.prefabScript.sidewalkControlElements[1].cornerRadius;
			num5 = scr.prefabScript.sidewalkControlElements[1].sidewalkWidth1;
			num6 = scr.prefabScript.sidewalkControlElements[1].curbDepth;
		}
		else if (connection == 1 && tCrossingLeftRight == 0)
		{
			num4 = scr.prefabScript.sidewalkControlElements[2].cornerRadius;
			num5 = scr.prefabScript.sidewalkControlElements[2].sidewalkWidth1;
			num6 = scr.prefabScript.sidewalkControlElements[2].curbDepth;
		}
		else if (connection == 1 && tCrossingLeftRight == 1)
		{
			num4 = scr.prefabScript.sidewalkControlElements[3].cornerRadius;
			num5 = scr.prefabScript.sidewalkControlElements[3].sidewalkWidth1;
			num6 = scr.prefabScript.sidewalkControlElements[3].curbDepth;
		}
		else
		{
			switch (connection)
			{
			case 2:
				num7 = scr.prefabScript.sidewalkControlElements[2].cornerRadius;
				num8 = scr.prefabScript.sidewalkControlElements[2].sidewalkWidth1;
				num9 = scr.prefabScript.sidewalkControlElements[2].curbDepth;
				num10 = scr.prefabScript.sidewalkControlElements[0].cornerRadius;
				num11 = scr.prefabScript.sidewalkControlElements[0].sidewalkWidth1;
				num12 = scr.prefabScript.sidewalkControlElements[0].curbDepth;
				break;
			case 3:
				num7 = scr.prefabScript.sidewalkControlElements[3].cornerRadius;
				num8 = scr.prefabScript.sidewalkControlElements[3].sidewalkWidth1;
				num9 = scr.prefabScript.sidewalkControlElements[3].curbDepth;
				num10 = scr.prefabScript.sidewalkControlElements[1].cornerRadius;
				num11 = scr.prefabScript.sidewalkControlElements[1].sidewalkWidth1;
				num12 = scr.prefabScript.sidewalkControlElements[1].curbDepth;
				break;
			}
		}
		float num13 = num5 - num6;
		float num14 = num8 - num9;
		float num15 = num11 - num12;
		if (num4 < num5)
		{
			num4 = num5;
		}
		if (num7 < num8)
		{
			num7 = num8;
		}
		if (num10 < num11)
		{
			num10 = num11;
		}
		if (connection <= 1)
		{
			num4 = Mathf.Abs(vecArray[0][0].z) - num3;
		}
		else
		{
			num7 = scr.leftSidewalkEndV3[0][0].z;
			num10 = -1f * scr.leftSidewalkStartV3[0][0].z;
		}
		for (int i = 0; i < vecArray.Count; i++)
		{
			for (int j = 0; j < vecArray[i].Count; j++)
			{
				num = 1f;
				float num16 = Mathf.Abs(vecArray[i][j].x);
				float num17 = Mathf.Abs(vecArray[i][j].z);
				if (connection < 2)
				{
					if (((tCrossingLeftRight == 0 && vecArray[i][j].x < 0f) || (tCrossingLeftRight == 1 && vecArray[i][j].x > 0f)) && num16 <= num2 + num4 && num17 <= num3 + num4)
					{
						num = (num17 - num3) / num4;
					}
					if (((tCrossingLeftRight != 0 || !(vecArray[i][j].x < 0f)) && (tCrossingLeftRight != 1 || !(vecArray[i][j].x > 0f))) || !(num16 >= num2 + num13) || !(num16 <= num2 + num5) || !(num17 <= num3 + num5) || num17 >= num3 + num13)
					{
					}
					if (connection >= 2 && vecArray[0][j].z == vecArray[0][0].z)
					{
						num = 0f;
					}
				}
				else
				{
					if (num17 < num3)
					{
						if (i == 1)
						{
							num16 = Mathf.Abs(vecArray[0][j].x);
							num17 = Mathf.Abs(vecArray[0][j].z);
						}
						if (i == 3)
						{
							num16 = Mathf.Abs(vecArray[4][j].x);
							num17 = Mathf.Abs(vecArray[4][j].z);
						}
					}
					if ((tCrossingLeftRight == 0 && vecArray[i][j].x < 0f) || (tCrossingLeftRight == 1 && vecArray[i][j].x > 0f))
					{
						num = ((!(vecArray[i][j].z > 0f)) ? ((num17 - num3) / num10) : ((num17 - num3) / num7));
					}
					if ((vecArray[i][j].z > 0f && tCrossingLeftRight == 1) || (vecArray[i][j].z < 0f && tCrossingLeftRight == 0))
					{
						if (vecArray[4].Count > j && vecArray[4][j].z == vecArray[4][0].z)
						{
							num = 0f;
						}
					}
					else if (vecArray[0].Count > j && vecArray[0][j].z == vecArray[0][0].z)
					{
						num = 0f;
					}
				}
				scr.prefabScript.tCrossingBlendData.Add(new ERBlendVecs(scr.prefabScript.tCrossingBlendData.Count, 0, num, connection, 0));
			}
		}
	}

	public static void OQDDOCOOOO(ERCrossings scr, int connection, List<List<Vector3>> vecArray, int leftright)
	{
		float num = 1f;
		int tCrossingLeftRight = scr.prefabScript.tCrossingLeftRight;
		float num2 = scr.frontRoadWidth * 0.5f;
		float num3 = 0f;
		if (tCrossingLeftRight == 0)
		{
			num3 = scr.leftRoadWidth * 0.5f;
		}
		num3 = scr.rightRoadWidth * 0.5f;
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 0f;
		if ((connection == 0 && leftright == 0 && tCrossingLeftRight == 0) || (connection == 2 && leftright == 1 && tCrossingLeftRight == 0) || (connection == 1 && leftright == 0 && tCrossingLeftRight == 1))
		{
			num4 = scr.prefabScript.sidewalkControlElements[0].cornerRadius;
			num5 = scr.prefabScript.sidewalkControlElements[0].sidewalkWidth1;
			num6 = scr.prefabScript.sidewalkControlElements[0].curbDepth;
		}
		else if ((connection == 0 && leftright == 1 && tCrossingLeftRight == 1) || (connection == 3 && leftright == 0 && tCrossingLeftRight == 1) || (connection == 1 && leftright == 0 && tCrossingLeftRight == 0))
		{
			num4 = scr.prefabScript.sidewalkControlElements[1].cornerRadius;
			num5 = scr.prefabScript.sidewalkControlElements[1].sidewalkWidth1;
			num6 = scr.prefabScript.sidewalkControlElements[1].curbDepth;
		}
		else if ((connection == 1 && leftright == 1 && tCrossingLeftRight == 0) || (connection == 2 && leftright == 1 && tCrossingLeftRight == 0))
		{
			num4 = scr.prefabScript.sidewalkControlElements[2].cornerRadius;
			num5 = scr.prefabScript.sidewalkControlElements[2].sidewalkWidth1;
			num6 = scr.prefabScript.sidewalkControlElements[2].curbDepth;
		}
		else if ((connection == 1 && leftright == 0 && tCrossingLeftRight == 1) || (connection == 3 && leftright == 1 && tCrossingLeftRight == 1))
		{
			num4 = scr.prefabScript.sidewalkControlElements[3].cornerRadius;
			num5 = scr.prefabScript.sidewalkControlElements[3].sidewalkWidth1;
			num6 = scr.prefabScript.sidewalkControlElements[3].curbDepth;
		}
		float num7 = num5 - num6;
		if (num4 < num5)
		{
			num4 = num5;
		}
		num4 = ((connection <= 1) ? (Mathf.Abs(vecArray[0][0].z) - num3) : (((connection != 2 || leftright != 0) && (connection != 3 || leftright != 1)) ? (-1f * scr.leftSidewalkStartV3[0][0].z) : scr.leftSidewalkEndV3[0][0].z));
		bool flag = false;
		for (int i = 0; i < vecArray.Count; i++)
		{
			for (int j = 0; j < vecArray[i].Count; j++)
			{
				num = 1f;
				flag = false;
				float num8 = Mathf.Abs(vecArray[i][j].x);
				float num9 = Mathf.Abs(vecArray[i][j].z);
				if (((tCrossingLeftRight == 0 && vecArray[i][j].x < 0f) || (tCrossingLeftRight == 1 && vecArray[i][j].x > 0f)) && num8 <= num2 + num4 && num9 <= num3 + num4)
				{
					num = (num9 - num3) / num4;
				}
				if (((tCrossingLeftRight == 0 && vecArray[i][j].x < 0f) || (tCrossingLeftRight == 1 && vecArray[i][j].x > 0f)) && num8 >= num2 + num7 - 0.2f && num8 <= num2 + num5 + 0.1f && num9 <= num3 + num5 + 0.1f && num9 >= num3 + num7 - 0.2f)
				{
					num = -1f;
					flag = true;
				}
				if (connection >= 2 && vecArray[0][j].z == vecArray[0][0].z)
				{
					num = 0f;
				}
				scr.prefabScript.tCrossingBlendData.Add(new ERBlendVecs(scr.prefabScript.tCrossingBlendData.Count, 0, num, connection, 0));
			}
		}
	}
}
[AddComponentMenu("")]
public class ODQDQDQDQO : MonoBehaviour
{
	public static Vector3 OODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, bool flag)
	{
		float num = p1.x - p3.x;
		float num2 = p1.z - p3.z;
		float num3 = p2.z - p1.z;
		float num4 = p2.x - p1.x;
		float num5 = num3 * p1.x + num4 * p1.z;
		float num6 = p4.z - p3.z;
		float num7 = p4.x - p3.x;
		float num8 = num6 * p3.x + num7 * p3.z;
		float num9 = num3 * num7 - num6 * num4;
		if (num9 == 0f)
		{
			return Vector3.zero;
		}
		float num10 = num6 * num4 - num7 * num3;
		float num11 = (num7 * num2 - num6 * num) / num10;
		float num12 = (num4 * num2 - num3 * num) / num10;
		float x = p1.x + num11 * num4;
		float z = p1.z + num11 * num3;
		if (!flag || (num11 >= 0f && num11 <= 1f && num12 >= 0f && num12 <= 1f))
		{
			return new Vector3(x, p1.y, z);
		}
		return Vector3.zero;
	}

	public static float OQDDCCCOQD(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p)
	{
		float x = p.x;
		float z = p.z;
		float num = (p2.z - p3.z) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.z - p3.z);
		float num2 = ((p2.z - p3.z) * (x - p3.x) + (p3.x - p2.x) * (z - p3.z)) / num;
		float num3 = ((p3.z - p1.z) * (x - p3.x) + (p1.x - p3.x) * (z - p3.z)) / num;
		float num4 = 1f - num2 - num3;
		return num2 * p1.y + num3 * p2.y + num4 * p3.y;
	}

	public static bool OQCDCDOOCD(Vector3 pTarget, Vector3 pSource, Vector3 pCheck)
	{
		Vector3 normalized = (pTarget - pSource).normalized;
		Vector3 normalized2 = (pCheck - pSource).normalized;
		if (Vector3.Cross(normalized, normalized2).y < 0f)
		{
			return false;
		}
		return true;
	}

	public static Vector3 OQQCQOCCOQ(Vector3 vA, Vector3 vB, Vector3 vPoint)
	{
		Vector3 rhs = vPoint - vA;
		Vector3 normalized = (vB - vA).normalized;
		float num = Vector3.Distance(vA, vB);
		float num2 = Vector3.Dot(normalized, rhs);
		if (num2 <= 0f)
		{
			return vA;
		}
		if (num2 >= num)
		{
			return vB;
		}
		Vector3 vector = normalized * num2;
		return vA + vector;
	}

	public static Vector3 OQDDDODCOC(Vector3 point, Vector3 pivot, Quaternion angle)
	{
		Vector3 vector = point - pivot;
		vector = angle * vector;
		return vector + pivot;
	}

	public static float GetYAngleByDir(Vector3 dir)
	{
		return Mathf.Atan2(dir.x, dir.z) * 57.29578f;
	}

	public static Vector3 OCOOCOOODQ(Vector3 point, float angle, Vector3 axis)
	{
		Quaternion quaternion = Quaternion.AngleAxis(angle, axis);
		return quaternion * point;
	}

	public static Vector3 OQQDCOCCCO(Vector3 source, float angle)
	{
		Quaternion quaternion = Quaternion.AngleAxis(angle, Vector3.up);
		return quaternion * source;
	}

	public static int ODOCOCDQCO(List<Material> mats, Material mat)
	{
		for (int i = 0; i < mats.Count; i++)
		{
			if (mats[i] == mat)
			{
				return i;
			}
		}
		return 0;
	}

	public static float OCCQDCCCOD(Vector3 fwd, Vector3 targetDir, Vector3 up)
	{
		Vector3 lhs = Vector3.Cross(fwd, targetDir);
		float num = Vector3.Dot(lhs, up);
		if ((double)num > 0.0)
		{
			return 1f;
		}
		if ((double)num < 0.0)
		{
			return -1f;
		}
		return 0f;
	}

	public static bool OQOQCCCODC(GameObject go, ref Bounds bounds)
	{
		Renderer component = go.GetComponent<Renderer>();
		if (component != null)
		{
			bounds = component.bounds;
			return true;
		}
		foreach (Transform item in go.transform)
		{
			component = item.GetComponent<Renderer>();
			if (component != null && component.bounds.size.z > bounds.size.z)
			{
				bounds = component.bounds;
			}
		}
		if (bounds.size.z > 0f)
		{
			return true;
		}
		return false;
	}

	public static float OOCQOOCOQC(Vector3 pos, ERModularBase scr)
	{
		if (!scr.isInBuildMode)
		{
			LayerMask layerMask = 1 << scr.sLayer;
			Ray ray = new Ray
			{
				direction = Vector3.down
			};
			Vector3 origin = pos;
			origin.y += 50f;
			if (Physics.Raycast(origin, -Vector3.up, out var hitInfo, 100f, layerMask))
			{
				pos.y = hitInfo.point.y;
			}
			else
			{
				scr.OCDDQOCDCO(ref pos);
			}
		}
		else
		{
			scr.OCDDQOCDCO(ref pos);
		}
		return pos.y;
	}

	public static Vector3 ODCCDOCDQD(Vector3 pos, Vector3 dir)
	{
		Ray ray = new Ray
		{
			direction = dir
		};
		Vector3 origin = pos;
		if (Physics.Raycast(origin, dir, out var hitInfo, 100f))
		{
			pos = hitInfo.point;
		}
		else
		{
			pos += 5f * dir;
		}
		return pos;
	}

	public static Vector3 OCCDCCQDDO(Vector3 pos, Vector3 dir)
	{
		Ray ray = new Ray
		{
			direction = dir
		};
		Vector3 origin = pos - dir * 5f;
		if (Physics.Raycast(origin, dir, out var hitInfo, 100f))
		{
			pos = hitInfo.point;
		}
		return pos;
	}

	public static Vector3 OOQODCCOQD(Vector3 pos, ERModularRoad scr)
	{
		Collider component = scr.gameObject.GetComponent<MeshCollider>();
		Vector3 result = Vector3.up;
		if (component != null)
		{
			Ray ray = new Ray
			{
				direction = Vector3.down
			};
			Vector3 origin = pos;
			origin.y += 50f;
			ray.origin = origin;
			if (component.Raycast(ray, out var hitInfo, 100f))
			{
				result = hitInfo.normal;
			}
		}
		return result;
	}

	public static int ODQCDQOOCO(int segmentCount, SideObject so, bool newSegment, ERMesh mobject, bool lastSegment, bool skipStartBlend, bool skipEndBlend)
	{
		if (segmentCount == 1 && so.includeStartSegment && !newSegment && !skipStartBlend)
		{
			return 0;
		}
		if ((((segmentCount > 1 && !lastSegment) || (!so.includeStartSegment && segmentCount == 1)) && !newSegment) || (skipStartBlend && segmentCount == 1 && !lastSegment))
		{
			return 1;
		}
		if (lastSegment && !newSegment)
		{
			return 2;
		}
		return -1;
	}

	public static void OCCQCDQQOQ(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, ERModularRoad roadScr, Vector3 randomRotation)
	{
		Vector3 vector = roadScr.baseScript.OQOODODDQO(v);
		Vector3 vector2 = dir - Vector3.Dot(dir, vector) * vector;
		if (vector2 != Vector3.zero)
		{
			Quaternion quaternion = Quaternion.LookRotation(vector2, vector);
			Vector3 eulerAngles = OCQOQOOOCO.GetEulerAngles(dir);
			v2 = OCQOQOOOCO.ODOQCDQQCC(v, vec, 180f + quaternion.eulerAngles.z + randomRotation.x, eulerAngles);
			if (n != Vector3.zero)
			{
				n = OCOOCOOODQ(n, quaternion.eulerAngles.z + randomRotation.x, dir);
			}
		}
	}

	public static void OQODQODDOQ(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, float angle, Vector3 randomRotation)
	{
		Vector3 eulerAngles = OCQOQOOOCO.GetEulerAngles(dir);
		v2 = OCQOQOOOCO.ODOQCDQQCC(v, vec, 180f - angle + randomRotation.x, eulerAngles);
	}

	public static void RandomAlignment(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, Vector3 randomRotation)
	{
		dir = new Vector3(dir.x, 0f, dir.z).normalized;
		Vector3 eulerAngles = OCQOQOOOCO.GetEulerAngles(dir);
		v2 = OCQOQOOOCO.ODOQCDQQCC(v, vec, 180f + randomRotation.x, eulerAngles);
	}

	public static void OCCDCDCQQQ(GameObject go, Vector3 v, ERModularRoad roadScr, Vector3 randomRotation)
	{
		Vector3 vector = roadScr.baseScript.OQOODODDQO(v);
		Vector3 forward = go.transform.forward;
		Vector3 vector2 = forward - Vector3.Dot(forward, vector) * vector;
		if (vector2 != Vector3.zero)
		{
			go.transform.rotation = Quaternion.LookRotation(vector2, vector);
		}
		if (randomRotation.x != 0f)
		{
			go.transform.Rotate(new Vector3(0f, 0f, randomRotation.x));
		}
	}

	public static void OQQOODCODQ(GameObject go, Vector3 v1, Vector3 v3, Vector3 dir, Vector3 randomRotation)
	{
		Vector3 vector = v3 + new Vector3(dir.z, 0f, 0f - dir.x) * 2f;
		Vector3 lhs = v1 - vector;
		Vector3 rhs = v3 - vector;
		Vector3 vector2 = -Vector3.Cross(lhs, rhs).normalized;
		Vector3 forward = go.transform.forward;
		Vector3 vector3 = forward - Vector3.Dot(forward, vector2) * vector2;
		if (vector3 != Vector3.zero)
		{
			go.transform.rotation = Quaternion.LookRotation(vector3, vector2);
		}
		if (randomRotation.x != 0f)
		{
			go.transform.Rotate(new Vector3(0f, 0f, randomRotation.x));
		}
	}

	public static void OCOQCDDODO(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation, Vector3 cp2, Vector3 cp3)
	{
		Vector3 lhs = cp2 - v1;
		Vector3 rhs = cp3 - v1;
		Vector3 vector = Vector3.Cross(lhs, rhs).normalized * -1f;
		Vector3 forward = go.transform.forward;
		Vector3 vector2 = forward - Vector3.Dot(forward, vector) * vector;
		if (vector2 != Vector3.zero)
		{
			go.transform.rotation = Quaternion.LookRotation(vector2, vector);
		}
		if (randomRotation.x != 0f)
		{
			go.transform.Rotate(new Vector3(0f, 0f, randomRotation.x));
		}
	}

	public static void InstantiatedRandomRotation(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation)
	{
		if (!float.IsNaN(randomRotation.x))
		{
			go.transform.Rotate(new Vector3(0f, 0f, 0f - randomRotation.x));
		}
	}

	public static bool RayTriangleOODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Ray ray)
	{
		Vector3 vector = p2 - p1;
		Vector3 vector2 = p3 - p1;
		Vector3 rhs = Vector3.Cross(ray.direction, vector2);
		float num = Vector3.Dot(vector, rhs);
		if (num > 0f - Mathf.Epsilon && num < Mathf.Epsilon)
		{
			return false;
		}
		float num2 = 1f / num;
		Vector3 lhs = ray.origin - p1;
		float num3 = Vector3.Dot(lhs, rhs) * num2;
		if (num3 < 0f || num3 > 1f)
		{
			return false;
		}
		Vector3 rhs2 = Vector3.Cross(lhs, vector);
		float num4 = Vector3.Dot(ray.direction, rhs2) * num2;
		if (num4 < 0f || num3 + num4 > 1f)
		{
			return false;
		}
		if (Vector3.Dot(vector2, rhs2) * num2 > Mathf.Epsilon)
		{
			return true;
		}
		return false;
	}

	public static void OCDODCQDDO(ERModularBase scr, Vector3 v1, Vector3 v2, ref float minY, ref float maxY)
	{
		float num = Vector3.Distance(v1, v2);
		float num2 = 1f / (num / 0.5f);
		float num3 = 0f;
		for (float num4 = 0f; num4 <= 1f; num4 += num2)
		{
			num3 = OOCQOOCOQC(Vector3.Lerp(v1, v2, num4), scr);
			if (num3 < minY)
			{
				minY = num3;
			}
			if (num3 > maxY)
			{
				maxY = num3;
			}
		}
	}

	public static List<Vector3> GetSoSplinePoints(ERModularRoad scr, List<float> sidewaysList, ref List<int> markerInts, ref List<float> tValues, ref List<float> markerDistances, ref List<Vector3> tmpMarkers)
	{
		List<Vector3> list = new List<Vector3>();
		List<bool> list2 = new List<bool>();
		List<Vector3> list3 = new List<Vector3>();
		List<Vector3> list4 = new List<Vector3>();
		Vector3 vector;
		Vector3 item;
		for (int i = 0; i < scr.markersExt.Count - 1; i++)
		{
			vector = ((i != 0) ? (scr.splinePoints[scr.markersExt[i].startSplinePoint + 1] - scr.markersExt[i].position) : (scr.splinePoints[1] - scr.markersExt[i].position));
			vector = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
			item = scr.markersExt[i].position + vector * sidewaysList[i];
			list3.Add(scr.markersExt[i].position);
			list4.Add(scr.markersExt[i].position + vector * 1f);
			if (sidewaysList[i] != -1E+10f)
			{
				list.Add(item);
				list2.Add(item: true);
			}
			else
			{
				list2.Add(item: false);
			}
		}
		vector = scr.splinePoints[scr.splinePoints.Count - 1] - scr.splinePoints[scr.splinePoints.Count - 2];
		vector = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
		item = scr.markersExt[scr.markersExt.Count - 1].position + vector * sidewaysList[sidewaysList.Count - 1];
		list3.Add(scr.markersExt[scr.markersExt.Count - 1].position);
		list4.Add(scr.markersExt[scr.markersExt.Count - 1].position + vector * 1f);
		list.Add(item);
		tmpMarkers = new List<Vector3>(list);
		if (scr.closedTrack)
		{
			list.Add(list[0]);
			list.Add(list[1]);
			list.Insert(0, list[list.Count - 3]);
			list3.Add(list3[0]);
			list4.Add(list4[0]);
		}
		else
		{
			list.Add(list[list.Count - 1]);
			list.Insert(0, list[0]);
		}
		Vector3 a = list[1];
		float num = 0f;
		List<Vector3> list5 = new List<Vector3>();
		int num2 = 1;
		markerDistances.Add(0f);
		float num3 = 0f;
		for (int j = 1; j < list.Count - 2; j++)
		{
			if (num > 0f)
			{
				num -= 1f;
			}
			num = 0f;
			float num4 = 0.0005f;
			for (float num5 = num; num5 < 1f; num5 += num4)
			{
				Vector3 vector2 = ERModularRoad.OODODQQQCD(list[j - 1], list[j], list[j + 1], list[j + 2], num5, 0.5f);
				if (Vector3.Distance(a, vector2) > 1f || (j == 1 && num5 == 0f))
				{
					list5.Add(vector2);
					num3 += Vector3.Distance(a, vector2);
					a = vector2;
					if (!OQCDCDOOCD(list4[num2], list3[num2], vector2))
					{
						num2++;
						if (num2 >= list3.Count)
						{
							num2 = list3.Count - 1;
						}
					}
					markerInts.Add(num2 - 1);
					tValues.Add(num5);
				}
				num = num5;
			}
			markerDistances.Add(num3);
		}
		return list5;
	}

	public static List<Vector3> OOODQCOOCC(List<Vector3> points, float tension, float incr)
	{
		List<Vector3> list = new List<Vector3>();
		float num = 0f;
		for (int i = 1; i < points.Count - 2; i++)
		{
			for (float num2 = num; num2 < 1f; num2 += incr)
			{
				Vector3 item = ERModularRoad.OODODQQQCD(points[i - 1], points[i], points[i + 1], points[i + 2], num2, tension);
				list.Add(item);
				if (num2 + incr > 1f)
				{
					num = num2 + incr - 1f;
					break;
				}
			}
		}
		return list;
	}

	public static List<Vector3> OOODQCOOCC(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, float incr)
	{
		List<Vector3> list = new List<Vector3>();
		float num = 0f;
		for (float num2 = incr; (double)num2 < 0.99; num2 += incr)
		{
			list.Add(ERModularRoad.OODODQQQCD(p1, p2, p3, p4, num2, 0.5f));
		}
		return list;
	}

	public static List<List<Vector2>> GetRoadShapeValues(List<float> tValues, List<float> markerDistances, List<List<Vector2>> nodeListValues, int startMarker, int endMarker, List<Vector2> roadShape, List<int> shapeTransitionTypes, bool closedTrack)
	{
		List<List<Vector2>> list = new List<List<Vector2>>();
		List<List<Vector3>> list2 = new List<List<Vector3>>();
		List<List<Vector3>> list3 = new List<List<Vector3>>();
		List<float> list4 = new List<float>();
		bool flag = false;
		for (int i = 0; i < roadShape.Count; i++)
		{
			list2.Add(new List<Vector3>());
			list3.Add(new List<Vector3>());
		}
		for (int j = startMarker; j < endMarker; j++)
		{
			list4.Add(shapeTransitionTypes[j - startMarker]);
			for (int k = 0; k < roadShape.Count; k++)
			{
				Vector3 item = new Vector3(markerDistances[j - startMarker], nodeListValues[j][k].x, 0f);
				list2[k].Add(item);
				item = new Vector3(markerDistances[j - startMarker], nodeListValues[j][k].y, 0f);
				list3[k].Add(item);
			}
		}
		for (int l = 0; l < list2.Count; l++)
		{
			if (!closedTrack)
			{
				list2[l].Insert(0, list2[l][0]);
				list2[l].Add(list2[l][list2[l].Count - 1]);
			}
			else
			{
				list2[l].Insert(0, list2[l][list2[l].Count - 2]);
				list2[l].Add(list2[l][2]);
			}
			if (!closedTrack)
			{
				list3[l].Insert(0, list3[l][0]);
				list3[l].Add(list3[l][list3[l].Count - 1]);
			}
			else
			{
				list3[l].Insert(0, list3[l][list3[l].Count - 2]);
				list3[l].Add(list3[l][2]);
			}
		}
		if (!closedTrack)
		{
			list4.Insert(0, list4[0]);
			list4.Add(list4[list4.Count - 1]);
		}
		else
		{
			list4.Insert(0, list4[list4.Count - 2]);
			list4.Add(list4[2]);
		}
		for (int m = 0; m < roadShape.Count; m++)
		{
			list.Add(new List<Vector2>());
		}
		int num = 0;
		int n = 1;
		bool flag2 = false;
		for (; n < list2[0].Count - 2; n++)
		{
			while (!flag2)
			{
				if (num < tValues.Count)
				{
					for (int num2 = 0; num2 < roadShape.Count; num2++)
					{
						Vector3 vector;
						Vector3 vector2;
						if (list4[n] == 0f)
						{
							vector = ERModularRoad.OODODQQQCD(list2[num2][n - 1], list2[num2][n], list2[num2][n + 1], list2[num2][n + 2], tValues[num], 0.5f);
							vector2 = ERModularRoad.OODODQQQCD(list3[num2][n - 1], list3[num2][n], list3[num2][n + 1], list3[num2][n + 2], tValues[num], 0.5f);
						}
						else if (list4[n] == 1f)
						{
							vector = Vector3.Lerp(list2[num2][n], list2[num2][n + 1], Mathf.SmoothStep(0f, 1f, tValues[num]));
							vector2 = Vector3.Lerp(list3[num2][n], list3[num2][n + 1], Mathf.SmoothStep(0f, 1f, tValues[num]));
						}
						else
						{
							vector = Vector3.Lerp(list2[num2][n], list2[num2][n + 1], tValues[num]);
							vector2 = Vector3.Lerp(list3[num2][n], list3[num2][n + 1], tValues[num]);
						}
						list[num2].Add(new Vector2(vector.y, vector2.y));
					}
					if (num + 1 < tValues.Count)
					{
						if (tValues[num + 1] <= tValues[num])
						{
							flag2 = true;
						}
					}
					else
					{
						flag2 = true;
					}
					num++;
				}
				else
				{
					flag2 = true;
				}
			}
			flag2 = false;
		}
		return list;
	}

	public static List<Vector3> GetSoMarkerPositionVecs(ERModularRoad scr, List<float> sidewaysList, ref List<Vector3> soMarkerDir, ref List<int> soMarkerInt)
	{
		List<Vector3> list = new List<Vector3>();
		Vector3 vector;
		Vector3 item;
		for (int i = 0; i < scr.markersExt.Count - 1; i++)
		{
			if (sidewaysList[i] == -1E+10f)
			{
				continue;
			}
			vector = ((i != 0) ? (scr.splinePoints[scr.markersExt[i].startSplinePoint + 1] - scr.markersExt[i].position) : (scr.splinePoints[1] - scr.markersExt[i].position));
			vector = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
			item = scr.markersExt[i].position + vector * sidewaysList[i];
			if (soMarkerDir != null)
			{
				if (sidewaysList[i] >= 0f)
				{
					soMarkerDir.Add(vector);
				}
				else
				{
					soMarkerDir.Add(-vector);
				}
			}
			if (soMarkerInt != null)
			{
				soMarkerInt.Add(i);
			}
			list.Add(item);
		}
		vector = scr.splinePoints[scr.splinePoints.Count - 1] - scr.splinePoints[scr.splinePoints.Count - 2];
		vector = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
		item = scr.markersExt[scr.markersExt.Count - 1].position + vector * sidewaysList[sidewaysList.Count - 1];
		list.Add(item);
		if (soMarkerDir != null)
		{
			if (sidewaysList[sidewaysList.Count - 1] >= 0f)
			{
				soMarkerDir.Add(vector);
			}
			else
			{
				soMarkerDir.Add(-vector);
			}
		}
		if (soMarkerInt != null)
		{
			soMarkerInt.Add(scr.markersExt.Count - 1);
		}
		return list;
	}

	public static void CheckGetSoMarkerPositionVecs(ERModularRoad scr, int marker, ref List<Vector3> soMarkerVecs, ref List<Vector3> soMarkerDir, ref List<int> soMarkerInt)
	{
		if (scr == null)
		{
			UnityEngine.Debug.Log("Road script is null: check this situation (did this happen after crossing settings changes?)");
		}
		else
		{
			if (marker >= scr.markersExt.Count)
			{
				return;
			}
			if (marker < 0 && scr.markersExt.Count > 1)
			{
				marker = 0;
			}
			else if (scr.markersExt.Count <= 1)
			{
				return;
			}
			List<float> sidewaysList = new List<float>();
			soMarkerInt.Clear();
			soMarkerDir.Clear();
			bool customNodelistFlag = false;
			List<List<Vector2>> nodeListValues = new List<List<Vector2>>();
			List<int> shapeTransitionTypes = new List<int>();
			if (scr.markersExt[marker].soData.Count > 0)
			{
				if (scr.markersExt[marker].soData[scr.selectedSO] != null)
				{
					if (ODDQODOOOC.GetSidewaysPosition(scr, scr.markersExt[marker].soData[scr.selectedSO].sideObject, ref sidewaysList, ref customNodelistFlag, ref nodeListValues, ref shapeTransitionTypes))
					{
						soMarkerVecs = GetSoMarkerPositionVecs(scr, sidewaysList, ref soMarkerDir, ref soMarkerInt);
						if (scr.markersExt[marker].soData[scr.selectedSO].sideObject.snapToTerrain)
						{
							for (int i = 0; i < soMarkerVecs.Count; i++)
							{
								Vector3 vector = soMarkerVecs[i];
								vector.y = OOCQOOCOQC(vector, scr.baseScript);
								soMarkerVecs[i] = vector;
							}
						}
					}
					else
					{
						soMarkerVecs.Clear();
					}
				}
				else
				{
					soMarkerVecs.Clear();
				}
			}
			else
			{
				soMarkerVecs.Clear();
			}
		}
	}

	public static void TerrainSmooth(Terrain terrain, ERModularRoad road, float size, int type, ref int smoothStep)
	{
		TerrainData terrainData = terrain.terrainData;
		int heightmapResolution = terrainData.heightmapResolution;
		float x = terrainData.heightmapScale.x;
		float z = terrainData.heightmapScale.z;
		Vector3 position = terrain.gameObject.transform.position;
		int num = Convert.ToInt32(Mathf.Ceil(size / x));
		int num2 = Convert.ToInt32(Mathf.Ceil(size / z));
		float t = 1f;
		float x2 = position.x;
		float z2 = position.z;
		int num3 = 0;
		int heightmapResolution2 = terrainData.heightmapResolution;
		int heightmapResolution3 = terrainData.heightmapResolution;
		float[,] heights = terrainData.GetHeights(0, 0, terrainData.heightmapResolution, terrainData.heightmapResolution);
		bool[,] array = new bool[terrainData.heightmapResolution, terrainData.heightmapResolution];
		bool[,] array2 = new bool[terrainData.heightmapResolution, terrainData.heightmapResolution];
		float num4 = x2 + 1.5f * size;
		float num5 = z2 + 1.5f * size;
		float num6 = x2 + terrainData.size.x - 1.5f * size;
		float num7 = z2 + terrainData.size.z - 1.5f * size;
		float y = terrainData.size.y;
		ERTerrain component = terrain.gameObject.GetComponent<ERTerrain>();
		if (component == null)
		{
			UnityEngine.Debug.Log("EasyRoads3Dv3 Warning: ERTerrain component is missing on terrain: " + terrain.gameObject);
			return;
		}
		int[] array3 = new int[terrainData.heightmapResolution * terrainData.heightmapResolution];
		for (int i = 0; i < component.terrainChanges.Count; i++)
		{
			array3[component.terrainChanges[i].index] = component.terrainChanges[i].value;
		}
		int xStart = component.xStart;
		int zStart = component.zStart;
		bool flag = false;
		int num8 = 0;
		Vector3 zero = Vector3.zero;
		List<Vector3> list;
		List<Vector3> list2;
		if (type == 0)
		{
			list = road.rightIndentVecs;
			list2 = road.leftIndentVecs;
		}
		else
		{
			list = road.rightSurroundingVecs;
			list2 = road.leftSurroundingVecs;
		}
		List<Vector3> leftIndentVecs = road.leftIndentVecs;
		List<Vector3> rightIndentVecs = road.rightIndentVecs;
		List<Vector3> leftSurroundingVecs = road.leftSurroundingVecs;
		List<Vector3> rightSurroundingVecs = road.rightSurroundingVecs;
		for (int j = 0; j < list.Count; j++)
		{
			if (road.bridgeElement[j])
			{
				continue;
			}
			zero = list2[j];
			if (zero.x >= num4 && zero.x < num6 && zero.z >= num5 && zero.z <= num7)
			{
				float num9 = (zero.x - position.x) / terrainData.size.x;
				float num10 = (zero.z - position.z) / terrainData.size.z;
				int num11 = Convert.ToInt32(num9 * (float)terrainData.heightmapResolution) - num - smoothStep;
				int num12 = Convert.ToInt32(num10 * (float)terrainData.heightmapResolution) - num2 - smoothStep;
				if (smoothStep == 0)
				{
					smoothStep = -1;
				}
				else
				{
					smoothStep = 0;
				}
				if (num11 < 0)
				{
					num11 = 0;
				}
				if (num12 < 0)
				{
					num12 = 0;
				}
				int num13 = 0;
				int num14 = 0;
				int num15 = 0;
				for (int k = 0; k < 2 * num2; k++)
				{
					for (int l = 0; l < 2 * num; l++)
					{
						num14 = k + num12;
						num15 = l + num11;
						if (heightmapResolution2 <= l + num11 || heightmapResolution3 <= k + num12)
						{
							continue;
						}
						float num16 = heights[k + num12, l + num11];
						flag = true;
						if (!array[k + num12, l + num11] && flag && array3[(k + num12) * heightmapResolution + l + num11] != 2)
						{
							if (type != 0)
							{
								num16 = Mathf.Lerp(num16, Smooth(l + num11, k + num12, terrainData), t);
							}
							else
							{
								num16 = Mathf.Lerp(num16, (leftIndentVecs[j].y - position.y) / y, Smooth1(leftIndentVecs[j].y, leftSurroundingVecs[j].y, num16 * y + position.y));
								array[k + num12, l + num11] = true;
							}
							if (array3[(k + num12) * heightmapResolution + l + num11] == 0)
							{
								component.terrainDataStored.Add(new ERTerrainData(k + num12 - zStart, l + num11 - xStart, heights[k + num12, l + num11], num16, m_critical: false, 0f, 0f, Vector3.zero, Vector3.zero));
								array3[(k + num12) * heightmapResolution + l + num11] = 1;
							}
							heights[k + num12, l + num11] = num16;
						}
					}
				}
			}
			zero = list[j];
			if (!(zero.x >= num4) || !(zero.x < num6) || !(zero.z >= num5) || !(zero.z <= num7))
			{
				continue;
			}
			float num17 = (zero.x - position.x) / terrainData.size.x;
			float num18 = (zero.z - position.z) / terrainData.size.z;
			int num19 = Convert.ToInt32(num17 * (float)terrainData.heightmapResolution) - num;
			int num20 = Convert.ToInt32(num18 * (float)terrainData.heightmapResolution) - num2;
			int num21 = 0;
			int num22 = 0;
			int num23 = 0;
			for (int m = 0; m < 2 * num2; m++)
			{
				for (int n = 0; n < 2 * num; n++)
				{
					num22 = m + num20;
					num23 = n + num19;
					if (heightmapResolution2 <= num23 || heightmapResolution3 <= num22)
					{
						continue;
					}
					float num24 = heights[num22, num23];
					flag = true;
					if (!array2[m + num20, n + num19] && flag && array3[(m + num20) * heightmapResolution + n + num19] != 2)
					{
						if (type != 0)
						{
							num24 = Mathf.Lerp(num24, Smooth(n + num19, m + num20, terrainData), t);
						}
						else
						{
							num24 = Mathf.Lerp(num24, (rightIndentVecs[j].y - position.y) / y, Smooth1(rightIndentVecs[j].y, rightSurroundingVecs[j].y, num24 * y + position.y));
							array2[m + num20, n + num19] = true;
						}
						if (array3[(m + num20) * heightmapResolution + n + num19] == 0)
						{
							component.terrainDataStored.Add(new ERTerrainData(m + num20 - zStart, n + num19 - xStart, heights[m + num20, n + num19], num24, m_critical: false, 0f, 0f, Vector3.zero, Vector3.zero));
							array3[(m + num20) * heightmapResolution + n + num19] = 1;
						}
						heights[m + num20, n + num19] = num24;
					}
				}
			}
		}
		terrainData.SetHeights(0, 0, heights);
	}

	public static bool CheckSmoothPoint(int x, int z, float sampleWidth, float sampleHeight, ERModularBase scr)
	{
		bool result = true;
		Vector3 pos = Vector3.zero;
		pos.x = Terrain.activeTerrain.gameObject.transform.position.x + (float)x * sampleWidth;
		pos.z = Terrain.activeTerrain.gameObject.transform.position.z + (float)z * sampleHeight;
		scr.OCDDQOCDCO(ref pos);
		LayerMask layerMask = 1 << scr.sLayer;
		pos.y += 20f;
		if (Physics.Raycast(pos, -Vector3.up, out var _, 30f, layerMask))
		{
			result = false;
		}
		return result;
	}

	private static float Smooth(int x, int y, TerrainData terrainInfo)
	{
		float num = 0f;
		float num2 = 1f / terrainInfo.size.y;
		num += terrainInfo.GetHeight(x, y) * num2;
		num += terrainInfo.GetHeight(x + 1, y) * num2;
		num += terrainInfo.GetHeight(x - 1, y) * num2;
		num += terrainInfo.GetHeight(x + 1, y + 1) * num2 * 0.75f;
		num += terrainInfo.GetHeight(x - 1, y + 1) * num2 * 0.75f;
		num += terrainInfo.GetHeight(x + 1, y - 1) * num2 * 0.75f;
		num += terrainInfo.GetHeight(x - 1, y - 1) * num2 * 0.75f;
		num += terrainInfo.GetHeight(x, y + 1) * num2;
		num += terrainInfo.GetHeight(x, y - 1) * num2;
		return num / 8f;
	}

	private static float Smooth1(float indent, float surrounding, float posY)
	{
		float num = 1f - Mathf.Abs(indent - posY) / Mathf.Abs(indent - surrounding);
		return num * 0.5f;
	}

	public static bool CompareVector2List(List<Vector2> list1, List<Vector2> list2)
	{
		if (list1.Count != list2.Count)
		{
			return false;
		}
		for (int i = 0; i < list1.Count; i++)
		{
			if (list1[i] != list2[i])
			{
				return false;
			}
		}
		return true;
	}

	public static string CheckMesh(GameObject go)
	{
		if (go != null)
		{
			return go.name + " " + go.GetComponent<MeshFilter>().sharedMesh.vertices.Length;
		}
		return " ";
	}

	public static void OCQOQODOCQ(Mesh m, MeshRenderer ren)
	{
		Material[] sharedMaterials = ren.sharedMaterials;
		List<Material> list = new List<Material>();
		Material[] array = sharedMaterials;
		foreach (Material material in array)
		{
			bool flag = false;
			foreach (Material item in list)
			{
				if (material == item)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				list.Add(material);
			}
		}
		if (list.Count >= sharedMaterials.Length)
		{
			return;
		}
		List<List<int>> list2 = new List<List<int>>();
		list2.Add(new List<int>());
		list2[0] = new List<int>(m.GetTriangles(0));
		for (int j = 1; j < sharedMaterials.Length; j++)
		{
			bool flag2 = false;
			for (int k = 0; k < j; k++)
			{
				if (sharedMaterials[j] == sharedMaterials[k])
				{
					flag2 = true;
					list2[k].AddRange(m.GetTriangles(j));
					break;
				}
			}
			if (!flag2)
			{
				list2.Add(new List<int>(m.GetTriangles(j)));
			}
		}
		ren.sharedMaterials = list.ToArray();
		m.subMeshCount = list.Count;
		for (int l = 0; l < list2.Count; l++)
		{
			m.SetTriangles(list2[l].ToArray(), l);
		}
	}

	public static List<float> OCOCDCOQCD(List<Vector2> nodes)
	{
		float num = 0f;
		List<float> list = new List<float>();
		list.Add(0f);
		for (int i = 1; i < nodes.Count; i++)
		{
			num += Vector2.Distance(nodes[i - 1], nodes[i]);
			list.Add(num);
		}
		List<float> list2 = new List<float>();
		for (int j = 0; j < nodes.Count; j++)
		{
			list2.Add(list[j] / num);
		}
		return list2;
	}

	public List<Vector2> ODCOCDCDQC(List<Vector3> vecs, float x)
	{
		List<Vector2> list = new List<Vector2>();
		list.Add(new Vector2(x, 0f));
		float num = 0f;
		for (int i = 0; i < vecs.Count - 1; i++)
		{
			num += Vector3.Distance(vecs[i], vecs[i + 1]);
			list.Add(new Vector2(x, num * 0.1f));
		}
		return list;
	}

	public static bool CheckConnectAngle(Vector3 r1, Vector3 p1, Vector3 p2)
	{
		Vector3 normalized = (p2 - r1).normalized;
		Vector3 normalized2 = (p2 - p1).normalized;
		float num = Vector3.Angle(normalized, normalized2);
		float num2 = Vector3.Distance(r1, p2);
		UnityEngine.Debug.Log("angle: " + num + " dist: " + num2);
		if ((num2 < 10f && num < 160f) || num < 135f)
		{
			return false;
		}
		if (num2 > 30f)
		{
			return true;
		}
		float num3 = (num2 - 10f) / 20f;
		float num4 = 155f - num3 * 25f;
		if (num > num4)
		{
			return true;
		}
		return false;
	}

	public static void OOQQCCOQOC(Transform parent, ref GameObject go, string name, List<Vector3> OCDCOCQQOO, Material mat, float OOCODCCCOQ, float OQQDDDQDOQ, float OCCOCCCODQ, float ODCCDDDODQ, float ODDQQCDDOD, float OCQCODCDCO, Vector2 OQCOCDQODQ, Vector2 ODDCOOCQCO, float uvRatio)
	{
		Mesh mesh = null;
		if (go == null)
		{
			go = new GameObject(name);
		}
		if (!go.GetComponent<MeshRenderer>())
		{
			go.AddComponent<MeshRenderer>();
			go.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.Off;
		}
		go.GetComponent<MeshRenderer>().sharedMaterial = mat;
		if (!go.GetComponent<MeshFilter>())
		{
			go.AddComponent<MeshFilter>();
		}
		if (go.GetComponent<MeshFilter>().sharedMesh != null)
		{
			mesh = go.GetComponent<MeshFilter>().sharedMesh;
		}
		else
		{
			mesh = new Mesh();
			go.GetComponent<MeshFilter>().sharedMesh = mesh;
		}
		go.transform.position = parent.position;
		go.transform.parent = parent;
		go.transform.localEulerAngles = Vector3.zero;
		List<Vector2> list = new List<Vector2>();
		list.Add(new Vector2((0f - OCQCODCDCO) * 0.5f, ODCCDDDODQ));
		list.Add(new Vector2(OCQCODCDCO * 0.5f, ODCCDDDODQ));
		List<float> list2 = new List<float>();
		list2.Add(OQCOCDQODQ.x);
		list2.Add(ODDCOOCQCO.x);
		List<Vector3> list3 = new List<Vector3>();
		List<Vector2> list4 = new List<Vector2>();
		List<Vector2> list5 = new List<Vector2>();
		List<Vector2> list6 = new List<Vector2>();
		List<Color> list7 = new List<Color>();
		List<int> list8 = new List<int>();
		List<int> list9 = new List<int>();
		Vector3 zero = Vector3.zero;
		float num2;
		float num3;
		float num = (num2 = (num3 = 0f));
		float num4 = ODDCOOCQCO.y;
		float num5 = 0f;
		float y = ODDCOOCQCO.y;
		int num6 = 0;
		bool flag = false;
		for (int i = 0; i < OCDCOCQQOO.Count; i++)
		{
			Vector3 vector;
			Vector3 vector2;
			if (i == 0)
			{
				vector = (vector2 = OCDCOCQQOO[i + 1] - OCDCOCQQOO[i]);
			}
			else if (i == OCDCOCQQOO.Count - 1)
			{
				vector = (vector2 = OCDCOCQQOO[i] - OCDCOCQQOO[i - 1]);
			}
			else
			{
				vector = OCDCOCQQOO[i + 1] - OCDCOCQQOO[i - 1];
				vector2 = OCDCOCQQOO[i] - OCDCOCQQOO[i - 1];
			}
			Vector3 normalized = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
			vector2 = vector2.normalized;
			if (i > 0)
			{
				num = Vector3.Distance(OCDCOCQQOO[i], OCDCOCQQOO[i - 1]);
			}
			num3 += num;
			float num7 = num2 + num;
			float num8 = num7 / uvRatio;
			if (num8 > OQCOCDQODQ.y)
			{
				list9.Add(num6);
				float num9 = (OQCOCDQODQ.y - num4) * uvRatio;
				Vector3 vector3 = OCDCOCQQOO[i - 1] + vector2 * num9;
				num8 = OQCOCDQODQ.y;
				for (int j = 0; j < list.Count; j++)
				{
					Vector3 item = vector3 + normalized * list[j].x;
					item.y += list[j].y;
					list3.Add(item);
					list4.Add(new Vector2(list2[j], num8));
				}
				num8 = ODDCOOCQCO.y;
				for (int k = 0; k < list.Count; k++)
				{
					Vector3 item = vector3 + normalized * list[k].x;
					item.y += list[k].y;
					list3.Add(item);
					list4.Add(new Vector2(list2[k], num8));
				}
				num2 = num - num9;
				num6 += 2;
			}
			else
			{
				num2 += num;
			}
			num8 = num2 / uvRatio;
			for (int l = 0; l < list.Count; l++)
			{
				Vector3 item = OCDCOCQQOO[i] + normalized * list[l].x;
				item.y += list[l].y;
				list3.Add(item);
				list4.Add(new Vector2(list2[l], num8));
			}
			num4 = num8;
			num6++;
		}
		int num10 = num6 - 1;
		int count = list.Count;
		int num11 = 1;
		int num12 = 0;
		if (list9.Count == 0)
		{
			list9.Add(-1);
		}
		for (int m = 0; m < num10; m += num11)
		{
			if (m != list9[num12])
			{
				for (int n = 0; n < count - 1; n++)
				{
					list8.Add(m * count + n);
					list8.Add((m + num11) * count + n + 1);
					list8.Add(m * count + n + 1);
					list8.Add((m + num11) * count + n);
					list8.Add((m + num11) * count + n + 1);
					list8.Add(m * count + n);
				}
			}
			else if (list9.Count > num12 + 1)
			{
				num12++;
			}
		}
		mesh.Clear();
		mesh.vertices = list3.ToArray();
		mesh.uv = list4.ToArray();
		mesh.triangles = list8.ToArray();
		mesh.RecalculateBounds();
		mesh.RecalculateNormals();
		ODCCODOCQQ.OCDCQCOQQO(mesh);
		go.GetComponent<MeshFilter>().sharedMesh = mesh;
	}

	public static bool InIntArray(int v, List<int> arr)
	{
		for (int i = 0; i < arr.Count; i++)
		{
			if (v == arr[i])
			{
				return true;
			}
		}
		return false;
	}

	public static void OOQCCQCCCC(ERModularBase scr)
	{
		string text = "";
		ERModularRoad[] componentsInChildren = scr.gameObject.GetComponentsInChildren<ERModularRoad>();
		ERModularRoad[] array = componentsInChildren;
		foreach (ERModularRoad obj in array)
		{
			UnityEngine.Object.DestroyImmediate(obj);
		}
		foreach (GameObject surfaceObject in scr.surfaceObjects)
		{
			UnityEngine.Object.DestroyImmediate(surfaceObject);
		}
		ERSurfaceScript[] componentsInChildren2 = scr.gameObject.GetComponentsInChildren<ERSurfaceScript>();
		ERSurfaceScript[] array2 = componentsInChildren2;
		foreach (ERSurfaceScript eRSurfaceScript in array2)
		{
			UnityEngine.Object.DestroyImmediate(eRSurfaceScript.gameObject);
		}
		ERCrossingPrefabs[] componentsInChildren3 = scr.gameObject.GetComponentsInChildren<ERCrossingPrefabs>();
		ERCrossingPrefabs[] array3 = componentsInChildren3;
		foreach (ERCrossingPrefabs obj2 in array3)
		{
			UnityEngine.Object.DestroyImmediate(obj2);
		}
		ERCrossings[] componentsInChildren4 = scr.gameObject.GetComponentsInChildren<ERCrossings>();
		ERCrossings[] array4 = componentsInChildren4;
		foreach (ERCrossings obj3 in array4)
		{
			UnityEngine.Object.DestroyImmediate(obj3);
		}
		ERRoundabouts[] componentsInChildren5 = scr.gameObject.GetComponentsInChildren<ERRoundabouts>();
		ERRoundabouts[] array5 = componentsInChildren5;
		foreach (ERRoundabouts obj4 in array5)
		{
			UnityEngine.Object.DestroyImmediate(obj4);
		}
		ERConnectionParent[] componentsInChildren6 = scr.gameObject.GetComponentsInChildren<ERConnectionParent>();
		ERConnectionParent[] array6 = componentsInChildren6;
		foreach (ERConnectionParent obj5 in array6)
		{
			UnityEngine.Object.DestroyImmediate(obj5);
		}
		ERTerrain[] array7 = UnityEngine.Object.FindObjectsOfType(typeof(ERTerrain)) as ERTerrain[];
		ERTerrain[] array8 = array7;
		foreach (ERTerrain obj6 in array8)
		{
			UnityEngine.Object.DestroyImmediate(obj6);
		}
		ERSideObjectInstance[] componentsInChildren7 = scr.gameObject.GetComponentsInChildren<ERSideObjectInstance>();
		ERSideObjectInstance[] array9 = componentsInChildren7;
		foreach (ERSideObjectInstance obj7 in array9)
		{
			UnityEngine.Object.DestroyImmediate(obj7);
		}
		ERPrefabInstance[] componentsInChildren8 = scr.gameObject.GetComponentsInChildren<ERPrefabInstance>();
		ERPrefabInstance[] array10 = componentsInChildren8;
		foreach (ERPrefabInstance obj8 in array10)
		{
			UnityEngine.Object.DestroyImmediate(obj8);
		}
		ERSideObjectSection[] componentsInChildren9 = scr.gameObject.GetComponentsInChildren<ERSideObjectSection>();
		ERSideObjectSection[] array11 = componentsInChildren9;
		foreach (ERSideObjectSection obj9 in array11)
		{
			UnityEngine.Object.DestroyImmediate(obj9);
		}
		ERRoadNetworkObject[] componentsInChildren10 = scr.gameObject.GetComponentsInChildren<ERRoadNetworkObject>();
		ERRoadNetworkObject[] array12 = componentsInChildren10;
		foreach (ERRoadNetworkObject obj10 in array12)
		{
			UnityEngine.Object.DestroyImmediate(obj10);
		}
	}

	public static OQQCCQCDQQ OQQOCDDDCC(ERModularRoad road, Vector3 pos, QDQDOOQQDQODD rt, int splineIndex)
	{
		if (rt == null)
		{
			return null;
		}
		GameObject gameObject = new GameObject("Exit Road");
		gameObject.AddComponent<MeshFilter>();
		gameObject.AddComponent<MeshRenderer>();
		gameObject.AddComponent<MeshCollider>();
		gameObject.transform.parent = road.transform;
		gameObject.layer = road.baseScript.sLayer;
		if (rt.roadMaterial == null)
		{
			UnityEngine.Debug.LogWarning("EasyRoads3Dv3 Warning: No material is assigned to Motorway ramp: " + rt.roadTypeName);
		}
		else
		{
			gameObject.GetComponent<MeshRenderer>().material = rt.roadMaterial;
		}
		Mesh mesh = new Mesh();
		MeshFilter component = gameObject.GetComponent<MeshFilter>();
		Mesh sharedMesh = (gameObject.GetComponent<MeshCollider>().sharedMesh = mesh);
		component.sharedMesh = sharedMesh;
		gameObject.transform.parent = road.transform;
		OQQCCQCDQQ oQQCCQCDQQ = gameObject.AddComponent<OQQCCQCDQQ>();
		road.exitRoads.Add(oQQCCQCDQQ);
		oQQCCQCDQQ.road = road;
		oQQCCQCDQQ.roadType = rt;
		int num = 0;
		if (road.markersExt.Count > 2)
		{
			for (int i = 0; i < road.markersExt.Count; i++)
			{
				if (road.markersExt[i].startSplinePoint > splineIndex)
				{
					oQQCCQCDQQ.markerIndex = i - 1;
					break;
				}
			}
		}
		else
		{
			oQQCCQCDQQ.markerIndex = 0;
		}
		float totalDistance = road.markersExt[oQQCCQCDQQ.markerIndex].totalDistance;
		float num2 = Vector3.Distance(road.markersExt[oQQCCQCDQQ.markerIndex].position, pos);
		float num3 = Vector3.Distance(road.markersExt[oQQCCQCDQQ.markerIndex + 1].position, pos);
		oQQCCQCDQQ.offset = num2 / (num2 + num3);
		Vector3 pos2 = Vector3.zero;
		int num4 = OCOODQDDDO(road.soSplinePoints, oQQCCQCDQQ.offset * road.markersExt[oQQCCQCDQQ.markerIndex].totalDistance, road.markersExt[oQQCCQCDQQ.markerIndex].startSplinePoint, ref pos2);
		oQQCCQCDQQ.OCODOQDODQ = OQQCQOCCOQ(road.soSplinePointsRight[num4], road.soSplinePointsRight[num4 + 1], pos);
		oQQCCQCDQQ.OCODOQDODQ = oQQCCQCDQQ.ODCCQQDQQQ();
		float distance = 0.5f * (oQQCCQCDQQ.extrusionDistance + oQQCCQCDQQ.fixedDistance);
		oQQCCQCDQQ.startSplineIndex = GetSplinePointIndex(road.soSplinePoints, distance, num4, -1);
		oQQCCQCDQQ.endSplineIndex = GetSplinePointIndex(road.soSplinePoints, distance, num4, 1);
		GameObject gameObject2 = new GameObject("Exit Road Connector");
		ERConnectionParent eRConnectionParent = (ERConnectionParent)UnityEngine.Object.FindObjectOfType(typeof(ERConnectionParent));
		if (eRConnectionParent != null)
		{
			gameObject2.transform.parent = eRConnectionParent.transform;
		}
		oQQCCQCDQQ.connector = gameObject2.AddComponent<ERCrossingPrefabs>();
		oQQCCQCDQQ.connector.crossingElements.Add(new QDOODOQQDQODD());
		oQQCCQCDQQ.connector.isExitRoadConnector = true;
		oQQCCQCDQQ.connector.isSnapConnector = true;
		UnityEngine.Debug.Log(oQQCCQCDQQ);
		return oQQCCQCDQQ;
	}

	public static int GetEdgePositionByDistance(List<Vector3> splinePoints, float distance, int startSplinePoint)
	{
		float num = 0f;
		for (int i = startSplinePoint; i < splinePoints.Count - 1; i++)
		{
			float num2 = Vector3.Distance(splinePoints[i], splinePoints[i + 1]);
			if (!(num + num2 > distance))
			{
				num += num2;
			}
		}
		return 0;
	}

	public static int OCOODQDDDO(List<Vector3> splinePoints, float distance, int startSplinePoint, ref Vector3 pos)
	{
		float num = 0f;
		for (int i = startSplinePoint; i < splinePoints.Count - 1; i++)
		{
			float num2 = Vector3.Distance(splinePoints[i], splinePoints[i + 1]);
			if (num + num2 > distance)
			{
				Vector3 normalized = (splinePoints[i + 1] - splinePoints[i]).normalized;
				pos = splinePoints[i] + normalized * (distance - num);
				return i;
			}
			num += num2;
		}
		return 0;
	}

	public static int GetSplinePointIndex(List<Vector3> splinePoints, float distance, int startIndex, int dir)
	{
		int result = 0;
		for (int i = startIndex; i < splinePoints.Count && i >= 0; i += dir)
		{
		}
		return result;
	}

	public static float OQQOQODCCC(Terrain terrain, Vector3 p1, Vector3 p2)
	{
		float num = Mathf.Abs(p1.x - p2.x);
		float num2 = Mathf.Abs(p1.z - p2.z);
		float num3;
		float num4;
		if (num > num2)
		{
			num3 = num2 / num;
			num4 = terrain.terrainData.heightmapScale.z;
		}
		else
		{
			num3 = num / num2;
			num4 = terrain.terrainData.heightmapScale.x;
		}
		return num4 * (1f + num3 * 0.5f);
	}

	public static bool RaycastRoadsSurfaces(int layer, Vector3 pos, ref Vector2 uv, ref GameObject go, bool checkHeightFlag)
	{
		LayerMask layerMask = 1 << layer;
		Ray ray = new Ray
		{
			direction = Vector3.down
		};
		Vector3 origin = pos;
		origin.y += 50f;
		ray.origin = origin;
		if (Physics.Raycast(origin, -Vector3.up, out var hitInfo, 500f, layerMask))
		{
			if (hitInfo.point.y < pos.y || !checkHeightFlag)
			{
				uv = hitInfo.textureCoord;
				return true;
			}
			go = hitInfo.collider.gameObject;
			return true;
		}
		return false;
	}

	public static void GetIndexAndFraction(List<Vector3> points, float fraction, int index, float dist, ref int targetIndex, ref float targetFraction, int dir)
	{
		float num = 0f;
		float num2 = 0f;
		bool flag = false;
		int count = points.Count;
		for (int i = index; i > 0 && i < count; i += dir)
		{
			num2 = Vector3.Distance(points[i + dir], points[i]);
			if (num + num2 > dist)
			{
				if (dir < 0)
				{
					targetIndex = i - 1;
					targetFraction = num2 - (dist - num);
				}
				else
				{
					targetIndex = i;
					targetFraction = dist - num;
				}
				break;
			}
			num += num2;
		}
		if (flag)
		{
		}
	}

	public static ERPoint ODCDDDCCDD(ERPoint source)
	{
		double num = Math.PI / 180.0;
		double a = source.y * num;
		double num2 = Math.Sin(a);
		double num3 = 0.017453292519943;
		double num4 = 6378137.0;
		double y = num4 / 2.0 * Math.Log((1.0 + num2) / (1.0 - num2));
		double x = source.x * num3 * num4;
		return new ERPoint(x, y);
	}

	public static void MergeVertices(Mesh m)
	{
		Vector3[] vertices = m.vertices;
		Vector2[] uv = m.uv;
		int[] triangles = m.triangles;
		Color[] colors = m.colors;
		List<Vector3> list = new List<Vector3>();
		List<Color> list2 = new List<Color>();
		List<Vector2> list3 = new List<Vector2>();
		for (int i = 0; i < vertices.Length; i++)
		{
			int num = in_array(list, list2, vertices[i], colors[i]);
			if (num == -1)
			{
				list.Add(vertices[i]);
				list2.Add(colors[i]);
				list3.Add(uv[i]);
				num = list.Count - 1;
			}
			for (int j = 0; j < triangles.Length; j++)
			{
				if (triangles[j] == i)
				{
					triangles[j] = num;
				}
			}
		}
		m.Clear();
		m.vertices = list.ToArray();
		m.colors = list2.ToArray();
		m.uv = list3.ToArray();
		m.triangles = triangles;
		m.RecalculateNormals();
		m.RecalculateTangents();
		UnityEngine.Debug.Log(list.Count + " " + vertices.Length);
	}

	public static int in_array(List<Vector3> vecs, List<Color> colors, Vector3 v, Color c)
	{
		for (int i = 0; i < vecs.Count; i++)
		{
			if (vecs[i] == v && colors[i] == c)
			{
				return i;
			}
		}
		return -1;
	}

	public static bool Vector2ListComparer(List<Vector2> list1, List<Vector2> list2)
	{
		List<Vector2> source = list1.Except(list2).ToList();
		List<Vector2> source2 = list2.Except(list1).ToList();
		return !source.Any() && !source2.Any();
	}

	public static bool FloatListComparer(List<float> list1, List<float> list2)
	{
		List<float> source = list1.Except(list2).ToList();
		List<float> source2 = list2.Except(list1).ToList();
		return !source.Any() && !source2.Any();
	}
}
[AddComponentMenu("")]
public class ERModularRoad : MonoBehaviour
{
	public ERModularBase baseScript;

	public string roadName;

	public bool locked = false;

	public double roadType = 0.0;

	public QDQDOOQQDQODD rt;

	public int defaultControlType = 0;

	public bool isCustomRoadSet = false;

	public bool isCustomRoad = false;

	public List<ERMarker> markers = new List<ERMarker>();

	public List<ERMarker> tmpMarkers = new List<ERMarker>();

	public List<ERMarkerExt> markersExt = new List<ERMarkerExt>();

	public List<ERMarkerExt> tmpMarkersExt = new List<ERMarkerExt>();

	public List<float> tValues = new List<float>();

	public float roadWidth = 5f;

	public float faceDistance = 2f;

	public float angleTreshold = 45f;

	public bool resolutionFlag = false;

	public bool angleThresholdFlag = false;

	public bool closedTrack = false;

	public float minNodeDistance = 5f;

	public int nodeWithinRange = -1;

	public float uvTiling = 1f;

	public bool planarUVs = false;

	public bool flipNormals = false;

	public int defaultLeftSidewalk = 0;

	public int defaultRightSidewalk = 0;

	public bool leftSidewalkActive = false;

	public bool rightSidewalkActive = false;

	public List<ERSideWalkInstance> leftSidewalks = new List<ERSideWalkInstance>();

	public List<ERSideWalkInstance> rightSidewalks = new List<ERSideWalkInstance>();

	public List<OQQCCQCDQQ> exitRoads = new List<OQQCCQCDQQ>();

	public int selectedExit = 0;

	public bool randomnessFlag = false;

	public bool randomnessMarkerFlag = false;

	public float randomYPosition = 0f;

	public float randomMinYPosition = -0.02f;

	public float randomMaxYPosition = 0.02f;

	public float minRandomYPositionDistance = 15f;

	public float maxRandomYPositionDistance = 35f;

	public float randomMinRotation = 0f;

	public float randomMaxRotation = 0f;

	public float minRandomRotationDistance = 15f;

	public float maxRandomRotationDistance = 35f;

	public bool vegetationStudioMaskLineActive = true;

	public float vegetationStudioGrassPerimeter = 2f;

	public float vegetationStudioPlantPerimeter = 3f;

	public float vegetationStudioTreePerimeter = 4f;

	public float vegetationStudioObjectPerimeter = 3f;

	public float vegetationStudioLargeObjectPerimeter = 4f;

	public bool vegetationStudioBiomeMaskActive = false;

	public float vegetationStudioBiomeMaskDistance = 0f;

	public float vegetationStudioBiomeMaskBlendDistance = 0f;

	public float vegetationStudioBiomeMaskNoiseScale = 0f;

	public int vertsStats = 0;

	public int trisStats = 0;

	public float indent = 0.5f;

	public float surrounding = 0.5f;

	public bool followTerrainContours;

	public float terrainContoursOffset = 5f;

	public List<Vector2> roadShape = new List<Vector2>();

	public List<int> roadShapeIntsStart = new List<int>();

	public List<int> roadShapeIntsEnd = new List<int>();

	public List<int> roadShapeIntsStartFull = new List<int>();

	public List<int> roadShapeIntsEndFull = new List<int>();

	public string roadShapeString = "";

	public string roadShapeReversedString = "";

	public int roadShapeMatchCount = 0;

	public int geoReversed = -1;

	public int roadShapeCols = 0;

	public bool flipRoadUVs = false;

	public int subSegments = 1;

	public List<float> nodeDistance = new List<float>();

	public List<float> roadShapeUVs = new List<float>();

	public List<float> roadShapeUVs2 = new List<float>();

	public List<bool> doConnectionTri = new List<bool>();

	public List<float> randomRotations = new List<float>();

	public List<bool> hardEdge = new List<bool>();

	public List<int> roadShapeMaterialInts = new List<int>();

	public int subMeshCount = 1;

	public List<int> roadShapeMaterialIntCounts = new List<int>();

	public List<Vector3> controlPoints = new List<Vector3>();

	public List<Vector3> splinePoints = new List<Vector3>();

	public List<float> distances = new List<float>();

	public List<int> markerInts = new List<int>();

	public List<Vector3> insertSplinePoints = new List<Vector3>();

	public List<Vector3> soSplinePoints = new List<Vector3>();

	public List<Vector3> soSplinePointsLeft = new List<Vector3>();

	public List<Vector3> soSplinePointsRight = new List<Vector3>();

	public List<Vector3> soSplinePointsLeftClamped = new List<Vector3>();

	public List<Vector3> soSplinePointsRightClamped = new List<Vector3>();

	public List<float> OQCOCCQCCD = new List<float>();

	public List<float> OQQOODQCCC = new List<float>();

	public List<float> bendAngles = new List<float>();

	public List<Vector3> meshVecs = new List<Vector3>();

	public List<Vector2> meshUVs = new List<Vector2>();

	public List<Vector2> meshUVs2 = new List<Vector2>();

	public List<List<int>> tris = new List<List<int>>();

	public List<Vector3> surfaceMeshVecs = new List<Vector3>();

	public List<Vector3> leftIndentVecs = new List<Vector3>();

	public List<Vector3> rightIndentVecs = new List<Vector3>();

	public List<Vector3> middleIndentVecs = new List<Vector3>();

	public List<Vector3> leftSurroundingVecs = new List<Vector3>();

	public List<Vector3> rightSurroundingVecs = new List<Vector3>();

	public List<Vector3> leftIndentVecsSV = new List<Vector3>();

	public List<Vector3> rightIndentVecsSV = new List<Vector3>();

	public List<bool> bridgeElement = new List<bool>();

	public List<Vector3> vecsBelowTerrain = new List<Vector3>();

	public List<Vector3> treeVecs = new List<Vector3>();

	public List<Vector3> detailVecs = new List<Vector3>();

	public List<int> vegetationTris = new List<int>();

	public List<bool> doLeftSurrounding = new List<bool>();

	public List<bool> doRightSurrounding = new List<bool>();

	public float totalDistance = 0f;

	public List<int> nodeSplinePoint = new List<int>();

	public string totalDistanceString = "";

	public ERCrossingPrefabs startPrefabScript;

	public ERCrossingPrefabs endPrefabScript;

	public int startConnectionSegment = 0;

	public bool startConnectionFlag = true;

	public int endConnectionSegment = 0;

	public bool endConnectionFlag = true;

	public bool startSegmentIntAdjusted;

	public bool endSegmentIntAdjusted;

	public bool tCrossingConnected = false;

	public Material roadMaterial;

	public Material[] roadMaterials;

	public PhysicMaterial roadPhysicsMaterial;

	public PhysicMaterial[] roadPhysicsMaterials;

	public Vector3 startDir;

	public Vector3 endDir;

	public float startAngle;

	public float endAngle;

	private int á;

	private int á;

	public int startbendLeftRight = 0;

	public int endbendLeftRight = 0;

	public float connectionAdjustDistanceStart = 30f;

	public float connectionAdjustDistanceEnd = 30f;

	public Vector3 pivotp;

	public Vector3 p1;

	public Vector3 p2;

	public Vector3 p3;

	public Vector3 p4;

	public Vector3 p5;

	public Vector3 p6;

	public Vector3 p7;

	public Vector3 cp1;

	public Vector3 cp2;

	public Vector3 cp3;

	public Vector3 cp4;

	public Vector3 cp5;

	public Vector3 cp6;

	public Vector3 cp7;

	public Vector3 cp8;

	public Vector3 cp9;

	public Vector3 cpcenter;

	public Vector3 p1Circle;

	public Vector3 p2Circle;

	public float cpradius;

	public float cpangle;

	public Vector3 dp1;

	public Vector3 dp2;

	public Vector3 dp3;

	public Vector3 dp4;

	public List<Vector3> segPoints = new List<Vector3>();

	public List<Vector3> testPoints = new List<Vector3>();

	public List<Vector3> testPoints2 = new List<Vector3>();

	public Vector3 OQOQODDQCC = Vector3.zero;

	public Vector3 ODQCDQCCOD = Vector3.zero;

	public Vector3 endLeft = Vector3.zero;

	public Vector3 endRight = Vector3.zero;

	public Mesh testmesh;

	public GameObject surfaceMesh;

	public Vector3 sv1;

	public Vector3 sv2;

	public Vector3 prefabIndentLeft;

	public Vector3 prefabIndentRight;

	public Vector3 roadIndent1;

	public static int ODQQCDOQOD;

	public static int OCOQCCDDQC;

	public static int ODCDCCQCQC;

	public static int OQDCDCOCQC;

	public static int OQQQOQOQOQ;

	public static int OQOQDOCQCD;

	public Vector3 tmpPerpCP;

	public Vector3 tmpCP;

	private int á = 0;

	private int 4AAAA = 0;

	public float splinePos = 0.001f;

	public float camHeight = 2f;

	public Vector3[] flyOverPoints;

	public Vector3 splinePosV3;

	public List<float> markerDistances = new List<float>();

	public string osmRoadType = "";

	public List<ERSORoad> soData = new List<ERSORoad>();

	public List<ERSORoadExt> soDataExt = new List<ERSORoadExt>();

	public string[] sideObjectNames = new string[0];

	public int selectedSO = 0;

	public bool rebuildSos = false;

	public bool sosCleared = false;

	public bool isSideObject = false;

	public int startOffsetActiveMarker = -1;

	public int endOffsetActiveMarker = -1;

	public float leftToCenterPerc = 0f;

	public ERRoad road;

	public bool splatMapActive = false;

	public int splatIndex = 0;

	public int expandLevel = 0;

	public int smoothLevel = 1;

	public float splatOpacity = 1f;

	public int layer = 0;

	public bool isStatic = true;

	public new string tag = "Untagged";

	public int tagInt = 0;

	public bool castShadow = false;

	public bool fadeInFlag = false;

	public float fadeInDistance = 0f;

	public bool fadeOutFlag = false;

	public float fadeOutDistance = 0f;

	public bool doSurroundingSurfaces = false;

	public bool terrainDeformation = true;

	public bool snapToTerrain = false;

	public List<ERSOSection> soSectionList1 = new List<ERSOSection>();

	public List<ERSOSection> soSectionList2 = new List<ERSOSection>();

	public List<ERSOSection> soSectionList3 = new List<ERSOSection>();

	public List<ERSOSection> soSectionList4 = new List<ERSOSection>();

	public List<ERSOSection> soSectionList5 = new List<ERSOSection>();

	public List<ERSOSection> soSectionList6 = new List<ERSOSection>();

	public List<ERSOSection> soSectionList7 = new List<ERSOSection>();

	public List<ERSOSection> soSectionList8 = new List<ERSOSection>();

	public bool snapVertices = false;

	public float snapOffset = 0.01f;

	public bool hasMeshCollider = true;

	public bool isUpdated = false;

	public bool QDDDQODQQDQDQQD = false;

	public int uv4Type = 0;

	public float detailDistance = 50f;

	public bool startDecalCollapsed = false;

	public ERDecal startDecal;

	public ERDecal endDecal;

	public GameObject startDecalPrefab;

	public GameObject startDecalPrefabSource;

	public bool endDecalCollapsed = false;

	public GameObject endDecalPrefab;

	public GameObject endDecalPrefabSource;

	public int startDecalID = -1;

	public int endDecalID = -1;

	public Vector3 lastForward;

	public bool roadUpdate = false;

	public Bounds bounds;

	public List<Vector3> debugVecs = new List<Vector3>();

	public List<float> debugFloats = new List<float>();

	public Vector3 exitExtrudeEnd;

	public Vector3 exitFixedEnd;

	public Vector3 exitSplitEnd;

	public Texture2D splatTextureMask;

	public bool lockUVs = false;

	public List<ERLaneData> laneData = new List<ERLaneData>();

	public bool oneWayRoad = false;

	public ERLaneDirection oneWayDirection = ERLaneDirection.Right;

	public bool ODDQCOCDQQ(ERCrossingPrefabs prefabScript)
	{
		if (startPrefabScript == prefabScript)
		{
			if (endPrefabScript != null)
			{
				return endPrefabScript.isCustomPrefab;
			}
		}
		else if (startPrefabScript != null)
		{
			return startPrefabScript.isCustomPrefab;
		}
		return true;
	}

	public void ODQCQCDCDQ(List<ERDecal> decalPresets)
	{
		if (startDecalPrefab != null)
		{
			if (Application.isEditor && !Application.isPlaying)
			{
				UnityEngine.Object.DestroyImmediate(startDecalPrefab);
			}
			else
			{
				UnityEngine.Object.Destroy(startDecalPrefab);
			}
		}
		if (endDecalPrefab != null)
		{
			if (Application.isEditor && !Application.isPlaying)
			{
				UnityEngine.Object.DestroyImmediate(endDecalPrefab);
			}
			else
			{
				UnityEngine.Object.Destroy(endDecalPrefab);
			}
		}
		startDecalID = -1;
		endDecalID = -1;
		List<int> list = new List<int>();
		int num = 0;
		foreach (ERDecal decalPreset in decalPresets)
		{
			if (decalPreset != null && decalPreset.type == ERDecalType.StartEnd)
			{
				if (decalPreset.priority == 0)
				{
					list.Add(num);
					list.Add(num);
					list.Add(num);
				}
				else if (decalPreset.priority == 1)
				{
					list.Add(num);
					list.Add(num);
				}
				else if (decalPreset.priority == 2)
				{
					list.Add(num);
				}
				num++;
			}
		}
		if (list.Count > 0)
		{
			int minInclusive = 0;
			int count = list.Count;
			int index = UnityEngine.Random.Range(minInclusive, count);
			startDecalID = decalPresets[list[index]].id;
			startDecal = decalPresets[list[index]];
			index = UnityEngine.Random.Range(minInclusive, count);
			endDecalID = decalPresets[list[index]].id;
			endDecal = decalPresets[list[index]];
		}
	}

	public void OOQOCCOOOD()
	{
		List<GameObject> list = new List<GameObject>();
		foreach (Transform item in base.transform)
		{
			if (item.name.IndexOf("_ERDecal_Start") != -1 || item.name.IndexOf("_ERDecal_End") != -1)
			{
				list.Add(item.gameObject);
			}
		}
		if (Application.isEditor && !Application.isPlaying)
		{
			foreach (GameObject item2 in list)
			{
				UnityEngine.Object.DestroyImmediate(item2);
			}
			return;
		}
		foreach (GameObject item3 in list)
		{
			UnityEngine.Object.Destroy(item3);
		}
	}

	public float GetRoadWidth()
	{
		if (roadType != 0.0)
		{
			rt = QDQDOOQQDQODD.GetRoadTypeElByID(baseScript.roadTypes, roadType);
			if (rt != null)
			{
				return rt.roadWidth;
			}
			return roadWidth;
		}
		return roadWidth;
	}

	public void OQQOCOQDCQ(Vector3 pos)
	{
		float num = 10000f;
		nodeWithinRange = -1;
		float num2 = 10000f;
		for (int i = 0; i < markersExt.Count; i++)
		{
			float num3 = Vector3.Distance(markersExt[i].position, pos);
			if (num3 < minNodeDistance && num2 > num3)
			{
				num2 = num3;
				nodeWithinRange = i;
			}
			if (num3 < num)
			{
				num = num3;
			}
		}
	}

	public int OCDQCCCDCC(Vector3 pos)
	{
		float num = 10000f;
		nodeWithinRange = -1;
		float num2 = 10000f;
		for (int i = 0; i < markersExt.Count; i++)
		{
			float num3 = Vector3.Distance(markersExt[i].position, pos);
			if (num > num3)
			{
				num = num3;
				nodeWithinRange = i;
			}
		}
		return nodeWithinRange;
	}

	public void GetInsertPointExt(Vector3 pos, ref int n1, int marker)
	{
		OCOOCCODDD(pos, ref n1);
	}

	public void OCOOCCODDD(Vector3 pos, ref int n1)
	{
		float num = 10000f;
		int num2 = 0;
		float num3 = 0f;
		for (int i = 1; i < insertSplinePoints.Count - 1; i++)
		{
			num3 = Vector3.Distance(insertSplinePoints[i], pos);
			if (num3 < num)
			{
				num2 = i;
				num = num3;
			}
		}
		int num4 = 0;
		for (int j = 0; j < markersExt.Count - 1; j++)
		{
			if (j > 0)
			{
				num4 = markersExt[j].startSplinePoint;
			}
			if (num2 >= num4 - 1 && num2 < markersExt[j + 1].startSplinePoint - 1)
			{
				n1 = j + 1;
				break;
			}
		}
	}

	public void OOODDDDQQO(Vector3 pos, ref int n1, int selectedMarker, bool sameRoad)
	{
		int num = -1;
		int num2 = -1;
		int num3 = -1;
		if (sameRoad)
		{
			if (selectedMarker > 0)
			{
				num = markersExt[selectedMarker - 1].startSplinePoint;
			}
			num2 = ((selectedMarker >= markersExt.Count - 1) ? markersExt[selectedMarker].startSplinePoint : markersExt[selectedMarker + 1].startSplinePoint);
		}
		float num4 = 10000f;
		int num5 = 0;
		float num6 = 0f;
		for (int i = 1; i < insertSplinePoints.Count - 1; i++)
		{
			num6 = Vector3.Distance(insertSplinePoints[i], pos);
			if (num6 < num4 && (i < num || i > num2))
			{
				num5 = i;
				num4 = num6;
			}
		}
		for (int j = 0; j < markersExt.Count - 1; j++)
		{
			if (num5 >= markersExt[j].startSplinePoint - 1 && num5 < markersExt[j + 1].startSplinePoint - 1)
			{
				n1 = j + 1;
				break;
			}
		}
	}

	public int OQCCQDDOQD(Vector3 pos)
	{
		bool flag = false;
		int result = -1;
		if (markersExt.Count < 2)
		{
			markersExt.Add(ERMarkerExt.CreateInstance(pos, this, markersExt.Count));
			flag = true;
		}
		else if (nodeWithinRange == -1)
		{
			if (insertSplinePoints.Count == 0)
			{
				UnityEngine.Debug.Log("no splinepoints available, insert point cannot be calculated");
				return 0;
			}
			int n = 0;
			OCOOCCODDD(pos, ref n);
			switch (n)
			{
			case 0:
			{
				float num3 = Vector3.Distance(markersExt[0].position, pos);
				float num4 = Vector3.Distance(markersExt[markersExt.Count - 1].position, pos);
				if (num3 <= num4)
				{
					if (startPrefabScript == null)
					{
						HandleAddMarkerAtStart(pos, 0);
						return 0;
					}
				}
				else if (endPrefabScript == null)
				{
					OOCDODCOOD(pos, 0);
					return markersExt.Count - 1;
				}
				break;
			}
			case 1:
			{
				float num = Vector3.Distance(markersExt[1].position, pos);
				float num2 = Vector3.Distance(markersExt[0].position, markersExt[1].position);
				if (num > num2)
				{
					if (startPrefabScript == null)
					{
						HandleAddMarkerAtStart(pos, 0);
					}
					return 0;
				}
				break;
			}
			}
			flag = true;
			markersExt.Insert(n, ERMarkerExt.CreateInstance(pos, this, n));
			if (endPrefabScript != null)
			{
				endPrefabScript.crossingElements[endConnectionSegment].connectedMarker = markersExt.Count - 1;
			}
			result = n;
		}
		if (markersExt.Count >= 2 && flag)
		{
			OCQOQCDCQC(ignorePrefabAlignment: false, forceAutoRotate: false);
		}
		return result;
	}

	public int OOCDODCOOD(Vector3 pos, int selectedMarker)
	{
		if (endPrefabScript == null)
		{
			markersExt.Add(ERMarkerExt.CreateInstance(pos, this, markersExt.Count));
			nodeWithinRange++;
			OCQOQCDCQC(ignorePrefabAlignment: false, forceAutoRotate: false);
			selectedMarker = markersExt.Count - 1;
		}
		return selectedMarker;
	}

	public int HandleAddMarkerAtStart(Vector3 pos, int selectedMarker)
	{
		if (startPrefabScript == null)
		{
			markersExt.Insert(0, ERMarkerExt.CreateInstance(pos, this, 0));
			OCQOQCDCQC(ignorePrefabAlignment: false, forceAutoRotate: false);
			selectedMarker = 0;
		}
		return selectedMarker;
	}

	public void ODDDCDQCCO(ERCrossingPrefabs ODCQDOOOCC, int targetElement, bool reverse, bool uvReverse, bool UpdateResolutionFlag)
	{
		OCQOQOOOCO.OCDCDQQQDO(this, ODCQDOOOCC, targetElement, reverse, uvReverse, UpdateResolutionFlag);
	}

	public void OOOCDCQQCO(bool ignorePrefabAlignment, int selectedMarker)
	{
	}

	public void PrintRoadShape(List<Vector2> lst)
	{
		string text = "";
		for (int i = 0; i < lst.Count; i++)
		{
			text = text + lst[i].x + " " + lst[i].y + "; ";
		}
		UnityEngine.Debug.Log(text);
	}

	public void OCQOQCDCQC(bool ignorePrefabAlignment, bool forceAutoRotate)
	{
		if (baseScript == null)
		{
			if ((bool)base.transform.parent.parent.gameObject.GetComponent<ERModularBase>())
			{
				baseScript = base.transform.parent.parent.gameObject.GetComponent<ERModularBase>();
			}
			else if ((bool)base.transform.parent.parent.parent.gameObject.GetComponent<ERModularBase>())
			{
				baseScript = base.transform.parent.parent.parent.gameObject.GetComponent<ERModularBase>();
			}
			else if ((bool)base.transform.parent.parent.parent.parent.gameObject.GetComponent<ERModularBase>())
			{
				baseScript = base.transform.parent.parent.parent.parent.gameObject.GetComponent<ERModularBase>();
			}
			if (baseScript == null)
			{
				UnityEngine.Debug.Log("EasyRoads3Dv3 Warning: Unable to find road network script, please report. Are you using deeply nested connection prefabs?");
				roadUpdate = false;
				return;
			}
		}
		if (surfaceMesh != null && surfaceMesh.GetComponent<MeshFilter>() != null)
		{
			surfaceMesh.GetComponent<MeshFilter>().sharedMesh.Clear();
		}
		float num = baseScript.terrainMinIndent;
		if (markersExt.Count > 0)
		{
			foreach (ERSOMarkerExt soDatum in markersExt[0].soData)
			{
				float num2 = 0f;
				if (soDatum != null && soDatum.sideObject.indentExt > num2)
				{
					num2 = soDatum.sideObject.indentExt;
				}
				num += num2;
			}
		}
		isUpdated = true;
		if (roadUpdate)
		{
			return;
		}
		roadUpdate = true;
		debugVecs.Clear();
		base.transform.position = Vector3.zero;
		lastForward = Vector3.zero;
		if (!isCustomRoadSet && roadType != 0.0)
		{
			isCustomRoadSet = true;
			for (int i = 0; i < baseScript.roadTypes.Count; i++)
			{
				if (baseScript.roadTypes[i].id == roadType)
				{
					if (baseScript.roadTypes[i].isCustomRoad)
					{
						isCustomRoad = true;
					}
					break;
				}
			}
		}
		if (markersExt.Count <= 1)
		{
			if ((bool)base.gameObject.GetComponent<MeshFilter>().sharedMesh)
			{
				base.gameObject.GetComponent<MeshFilter>().sharedMesh.Clear();
			}
			if (surfaceMesh != null)
			{
				surfaceMesh.GetComponent<MeshFilter>().sharedMesh.Clear();
			}
			roadUpdate = false;
			return;
		}
		if ((rt == null && roadType != 0.0) || (rt != null && rt.id != roadType))
		{
			rt = QDQDOOQQDQODD.GetRoadTypeElByID(baseScript.roadTypes, roadType);
		}
		baseScript.dirtyOnSceneBool = true;
		if (!sosCleared && baseScript != null)
		{
			rebuildSos = ODDQODOOOC.OOQOOQCQQO(baseScript, this);
			if (rebuildSos && !isSideObject && baseScript.buildSOinEditMode)
			{
				baseScript.RoadObjectsSoUpdates.Add(this);
			}
			sosCleared = true;
		}
		if (markersExt.Count > 0 && markersExt[markersExt.Count - 1].controlType == 3)
		{
			markersExt[markersExt.Count - 1].controlType = 0;
			UnityEngine.Debug.Log("EasyRoads3Dv3 Warning: The Contol Type the last marker of a road cannot be Circular. Road: " + base.gameObject.name);
		}
		vecsBelowTerrain.Clear();
		if (base.gameObject == null)
		{
			roadUpdate = false;
			return;
		}
		if (base.gameObject.GetComponent<MeshFilter>() == null)
		{
			base.gameObject.AddComponent<MeshFilter>();
		}
		if (base.gameObject.GetComponent<MeshRenderer>() == null)
		{
			base.gameObject.AddComponent<MeshRenderer>();
			if (roadMaterials.Length != 0)
			{
				base.gameObject.GetComponent<MeshRenderer>().sharedMaterials = roadMaterials;
			}
		}
		if (base.gameObject.GetComponent<MeshCollider>() == null && hasMeshCollider)
		{
			base.gameObject.AddComponent<MeshCollider>();
		}
		if (base.gameObject.GetComponent<MeshCollider>() != null && roadPhysicsMaterial != null)
		{
			try
			{
				if (roadPhysicsMaterial == roadMaterial)
				{
					roadPhysicsMaterial = null;
				}
				base.gameObject.GetComponent<MeshCollider>().material = null;
				base.gameObject.GetComponent<MeshCollider>().material = roadPhysicsMaterial;
			}
			catch
			{
			}
		}
		else if (!(base.gameObject.GetComponent<MeshCollider>() != null))
		{
		}
		Mesh mesh;
		if (base.gameObject.GetComponent<MeshFilter>().sharedMesh != null)
		{
			mesh = base.gameObject.GetComponent<MeshFilter>().sharedMesh;
		}
		else
		{
			mesh = new Mesh();
			mesh.name = "ER Road Mesh";
			base.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
		}
		base.gameObject.isStatic = isStatic;
		if ((startPrefabScript != null && startConnectionSegment == -1) || (startPrefabScript == null && startConnectionSegment != -1) || (startPrefabScript != null && startConnectionSegment >= startPrefabScript.crossingElements.Count))
		{
			startPrefabScript = null;
			startConnectionSegment = -1;
		}
		if ((endPrefabScript != null && endConnectionSegment == -1) || (endPrefabScript == null && endConnectionSegment != -1) || (endPrefabScript != null && endConnectionSegment >= endPrefabScript.crossingElements.Count))
		{
			endPrefabScript = null;
			endConnectionSegment = -1;
		}
		Transform transform = null;
		Transform transform2 = null;
		if (startPrefabScript != null)
		{
			transform = startPrefabScript.transform;
			if (startPrefabScript.surfaceObject != null)
			{
				transform = startPrefabScript.surfaceObject.transform;
			}
		}
		if (endPrefabScript != null)
		{
			transform2 = endPrefabScript.transform;
			if (endPrefabScript.surfaceObject != null)
			{
				transform2 = endPrefabScript.surfaceObject.transform;
			}
		}
		bool flag = false;
		if (roadShape == null)
		{
			flag = true;
		}
		else if (roadShape.Count <= 1)
		{
			flag = true;
		}
		if (flag || roadShape.Count != roadShapeUVs.Count)
		{
			ODCCODOCQQ.GetRoadShape(roadWidth, subSegments, ref roadShape, ref roadShapeUVs, ref roadShapeUVs2, -1f);
			roadShapeMaterialInts.Add(0);
			roadShapeMaterialInts.Add(0);
			if (roadMaterials == null)
			{
				roadMaterials = new Material[1];
			}
			else if (roadMaterials.Length != 1)
			{
				roadMaterials = new Material[1];
			}
			roadShapeMatchCount = subSegments + 1;
			int num3 = 1;
			for (int j = 1; j < roadShape.Count; j++)
			{
				if ((double)Vector2.Distance(roadShape[j - 1], roadShape[j]) > 0.01)
				{
					num3++;
				}
			}
			roadShapeMatchCount = num3;
			for (int k = 0; k < markersExt.Count; k++)
			{
				markersExt[k].roadShape = new List<Vector2>(roadShape);
			}
		}
		if (roadShapeUVs.Count != roadShape.Count)
		{
			roadShapeUVs.Clear();
			roadShapeUVs2.Clear();
			float num4 = 0f;
			for (int l = 0; l < roadShape.Count - 1; l++)
			{
				num4 += Vector2.Distance(roadShape[l], roadShape[l + 1]);
			}
			float num5 = 0f;
			roadShapeUVs.Add(0f);
			roadShapeUVs2.Add(0f);
			for (int m = 0; m < roadShape.Count - 1; m++)
			{
				num5 += Vector2.Distance(roadShape[m], roadShape[m + 1]);
				roadShapeUVs.Add(num5 / num4);
				roadShapeUVs2.Add(num5 / num4);
			}
		}
		if (roadShapeUVs.Count != roadShapeUVs2.Count)
		{
			roadShapeUVs2 = new List<float>(roadShapeUVs);
		}
		if (roadShapeMatchCount == 0)
		{
			int num6 = 1;
			for (int n = 1; n < roadShape.Count; n++)
			{
				if ((double)Vector2.Distance(roadShape[n - 1], roadShape[n]) > 0.01)
				{
					num6++;
				}
			}
			roadShapeMatchCount = num6;
		}
		int num7 = 0;
		if (startPrefabScript != null && (roadShapeIntsStart.Count == 0 || roadShapeIntsStart.Count != roadShape.Count))
		{
			OCQOQOOOCO.OCCCDQCDOC(this, roadShape, null, 0);
		}
		if (endPrefabScript != null && (roadShapeIntsEnd.Count == 0 || roadShapeIntsEnd.Count != roadShape.Count))
		{
			OCQOQOOOCO.OCCCDQCDOC(this, roadShape, null, 1);
		}
		if (roadShape.Count != roadShapeMaterialInts.Count)
		{
			roadShapeMaterialInts.Clear();
			for (int num8 = 0; num8 < roadShape.Count; num8++)
			{
				roadShapeMaterialInts.Add(0);
			}
			num7 = 0;
		}
		if (roadShapeMaterialIntCounts.Count != roadMaterials.Length && roadShapeMaterialInts.Count > 0)
		{
			roadShapeMaterialIntCounts.Clear();
			for (int num9 = 0; num9 < roadShapeMaterialInts.Count; num9++)
			{
				if (roadShapeMaterialInts[num9] >= roadShapeMaterialIntCounts.Count)
				{
					while (roadShapeMaterialInts[num9] >= roadShapeMaterialIntCounts.Count)
					{
						roadShapeMaterialIntCounts.Add(0);
					}
				}
				roadShapeMaterialIntCounts[roadShapeMaterialInts[num9]]++;
			}
		}
		if (roadMaterials.Length == 0)
		{
			roadMaterials = new Material[1];
			roadMaterials[0] = roadMaterial;
			base.gameObject.GetComponent<MeshRenderer>().sharedMaterials = roadMaterials;
		}
		if (markersExt.Count < controlPoints.Count)
		{
			markersExt.Clear();
			for (int num10 = 0; num10 < controlPoints.Count; num10++)
			{
				markersExt.Add(ERMarkerExt.CreateInstance(controlPoints[num10], this, markersExt.Count));
			}
		}
		tValues.Clear();
		markerDistances.Clear();
		bendAngles.Clear();
		doLeftSurrounding.Clear();
		doRightSurrounding.Clear();
		List<float> leftIndents = new List<float>();
		List<float> rightIndents = new List<float>();
		List<float> leftSurrounding = new List<float>();
		List<float> rightSurrounding = new List<float>();
		if (markersExt[0].roadShape.Count == 0)
		{
			foreach (ERMarkerExt item6 in markersExt)
			{
				item6.roadShape = new List<Vector2>(roadShape);
			}
		}
		if (angleTreshold < 1f)
		{
			angleTreshold = 1f;
		}
		randomRotations.Clear();
		if (startConnectionFlag && startPrefabScript == null)
		{
			markersExt[0].roadShape = new List<Vector2>(roadShape);
			markersExt[0].roadShapeDistanceMin = 0f;
			markersExt[0].roadShapeDistanceMax = 1f;
			startConnectionFlag = false;
		}
		if (endConnectionFlag && endPrefabScript == null)
		{
			markersExt[markersExt.Count - 1].roadShape = new List<Vector2>(roadShape);
			markersExt[markersExt.Count - 1].roadShapeDistanceMin = 0f;
			markersExt[markersExt.Count - 1].roadShapeDistanceMax = 1f;
			endConnectionFlag = false;
		}
		if (startPrefabScript != null && endPrefabScript != null && startPrefabScript.crossingElements[startConnectionSegment].roadShapeMatchCount != endPrefabScript.crossingElements[endConnectionSegment].roadShapeMatchCount && !startPrefabScript.isIConnector && !endPrefabScript.isIConnector)
		{
			UnityEngine.Debug.LogWarning("EasyRoads3Dv3 Warning: The geometry structure of the connection at the start does not match the geometry at the end, road update aborted: " + base.gameObject.name);
			roadUpdate = false;
			return;
		}
		splinePoints = OQDDOOOOQD(markersExt, faceDistance, ignorePrefabAlignment, ref tValues, ref markerDistances, forceAutoRotate, ref randomRotations, ref bendAngles);
		if (splinePoints == null)
		{
			roadUpdate = false;
			return;
		}
		if (splinePoints.Count == 1)
		{
			roadUpdate = false;
			return;
		}
		if (splinePoints.Count == 2)
		{
			splinePoints.Insert(0, Vector3.Lerp(splinePoints[0], splinePoints[1], 0.5f));
			tValues.Insert(0, Mathf.Lerp(tValues[0], tValues[1], 0.5f));
		}
		bool flag2 = true;
		bool flag3 = false;
		bool startSurfacesSafe = false;
		Vector3 vector = Vector3.zero;
		Vector3 startPrefabIndent = Vector3.zero;
		Vector3 oDCQDOOOCCIndent = Vector3.zero;
		Vector3 a = Vector3.zero;
		Vector3 zero = Vector3.zero;
		bool flag4 = false;
		float num11 = 0f;
		int num12 = -1;
		float num13 = 0f;
		Vector3 a2 = Vector3.zero;
		Vector3 startPrefabIndent2 = Vector3.zero;
		Vector3 oDCQDOOOCCIndent2 = Vector3.zero;
		Vector3 vector2 = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		float num14 = 0f;
		int num15 = -1;
		int endAdjustInt = 0;
		float num16 = 0f;
		float num17 = 30f;
		if (totalDistance < num17)
		{
			num17 = totalDistance;
		}
		if (totalDistance * 0.5f < num17)
		{
			num17 = totalDistance * 0.5f;
		}
		bool flag5 = false;
		if (startPrefabScript != null && endPrefabScript != null && markersExt.Count == 2)
		{
			flag5 = true;
			if (num17 > totalDistance - baseScript.minIndent * 2f * 0.5f)
			{
				num17 = totalDistance - baseScript.minIndent * 2f * 0.5f;
			}
		}
		if (flag5 && totalDistance * 0.5f < num17)
		{
			num17 = totalDistance * 0.5f;
		}
		float num18 = num17;
		if (num18 < markersExt[0].totalDistance && !flag5)
		{
			num18 = markersExt[0].totalDistance;
		}
		float endAdjustDistance = num17;
		if (!closedTrack)
		{
			markersExt[markersExt.Count - 2].totalDistance = totalDistance - markersExt[markersExt.Count - 2].startDistance;
		}
		if (endAdjustDistance < markersExt[markersExt.Count - 2].totalDistance && !flag5)
		{
			endAdjustDistance = markersExt[markersExt.Count - 2].totalDistance;
		}
		int num19 = 0;
		int num20 = roadShape.Count - 1;
		if (startPrefabScript == null && endPrefabScript == null)
		{
			float num21 = 100000f;
			float num22 = -100000f;
			for (int num23 = 0; num23 < roadShape.Count; num23++)
			{
				if (roadShape[num23].x < num21 || (roadShape[num23].x == num21 && roadShape[num23].y < roadShape[num20].y))
				{
					num20 = num23;
					num21 = roadShape[num23].x;
				}
				if (roadShape[num23].x > num22 || (roadShape[num23].x == num22 && roadShape[num23].y < roadShape[num19].y))
				{
					num19 = num23;
					num22 = roadShape[num23].x;
				}
			}
		}
		bool flag6 = false;
		if (startPrefabScript != null && (!startPrefabScript.isSnapConnector || startPrefabScript.isExitRoadConnector))
		{
			QDOODOQQDQODD qDOODOQQDQODD = startPrefabScript.crossingElements[startConnectionSegment];
			if (qDOODOQQDQODD.rightInt == 0 && qDOODOQQDQODD.leftInt == 0)
			{
				qDOODOQQDQODD.leftInt = 0;
				qDOODOQQDQODD.rightInt = qDOODOQQDQODD.connectionVecInts.Count - 1;
				qDOODOQQDQODD.leftIntFull = 0;
				qDOODOQQDQODD.rightIntFull = qDOODOQQDQODD.fullConnectionVecInts.Count - 1;
			}
			if (roadShape.Count > qDOODOQQDQODD.leftInt && roadShape.Count > qDOODOQQDQODD.rightInt)
			{
				num19 = qDOODOQQDQODD.leftInt;
				num20 = qDOODOQQDQODD.rightInt;
			}
			if (roadShape.Count == qDOODOQQDQODD.connectionVecInts.Count)
			{
				flag6 = true;
			}
			if (!isSideObject || startPrefabScript.tmpMeshVecs.Length != 0)
			{
				if (startPrefabScript.isCustomPrefab)
				{
					OQOQODDQCC = startPrefabScript.tmpMeshVecs[qDOODOQQDQODD.connectionVecInts[qDOODOQQDQODD.rightInt]];
				}
				else if (startPrefabScript.tmpFullMeshVecs.Length != 0)
				{
					OQOQODDQCC = startPrefabScript.tmpFullMeshVecs[qDOODOQQDQODD.connectionVecInts[qDOODOQQDQODD.rightInt]];
				}
			}
			Vector3 oQOQODDQCC = OQOQODDQCC;
			OQOQODDQCC = startPrefabScript.transform.TransformPoint(OQOQODDQCC);
			if (!isSideObject || startPrefabScript.tmpMeshVecs.Length != 0)
			{
				if (startPrefabScript.isCustomPrefab)
				{
					ODQCDQCCOD = startPrefabScript.tmpMeshVecs[qDOODOQQDQODD.connectionVecInts[qDOODOQQDQODD.leftInt]];
				}
				else if (startPrefabScript.tmpFullMeshVecs.Length != 0)
				{
					ODQCDQCCOD = startPrefabScript.tmpFullMeshVecs[qDOODOQQDQODD.connectionVecInts[qDOODOQQDQODD.leftInt]];
				}
			}
			Vector3 oDQCDQCCOD = ODQCDQCCOD;
			ODQCDQCCOD = startPrefabScript.transform.TransformPoint(ODQCDQCCOD);
			if (startPrefabScript.crossingElements[startConnectionSegment].leftIndentV3 != Vector3.zero)
			{
				startPrefabIndent = startPrefabScript.transform.TransformPoint(startPrefabScript.crossingElements[startConnectionSegment].leftIndentV3);
			}
			else
			{
				startPrefabIndent = oQOQODDQCC;
				startPrefabIndent.y = 0f;
				startPrefabIndent = startPrefabScript.transform.TransformPoint(startPrefabIndent);
			}
			if (startPrefabScript.crossingElements[startConnectionSegment].rightIndentV3 != Vector3.zero)
			{
				oDCQDOOOCCIndent = startPrefabScript.transform.TransformPoint(startPrefabScript.crossingElements[startConnectionSegment].rightIndentV3);
			}
			else
			{
				oDCQDOOOCCIndent = oDQCDQCCOD;
				oDCQDOOOCCIndent.y = 0f;
				oDCQDOOOCCIndent = startPrefabScript.transform.TransformPoint(oDCQDOOOCCIndent);
			}
			a = startPrefabScript.transform.TransformPoint(Vector3.zero);
			zero = startPrefabScript.transform.TransformPoint(startPrefabScript.crossingElements[startConnectionSegment].tmpCenterPoint);
			num11 = startPrefabScript.crossingElements[startConnectionSegment].additionalIndentDistance;
			flag4 = false;
			if (startPrefabScript.isExitRoadConnector)
			{
				a = startPrefabScript.prefabCenterDummy;
			}
			float num24 = Vector3.Distance(splinePoints[0], zero) - 0.75f * faceDistance;
			Vector3 a3 = splinePoints[0];
			if (startPrefabScript.tCrossing && startConnectionSegment <= 1)
			{
				float num25 = Vector3.Distance(a, zero);
				for (int num26 = 0; num26 < splinePoints.Count && Vector3.Distance(a3, splinePoints[num26]) < num24; num26++)
				{
					splinePoints.RemoveAt(0);
					tValues.RemoveAt(0);
					num26--;
				}
			}
			num12 = ((startbendLeftRight != -1) ? OCQOQOOOCO.OCCCDCOQCC(this, splinePoints, baseScript.terrainMinIndent, roadShape[roadShape.Count - 1].x, oDCQDOOOCCIndent, startPrefabIndent, startbendLeftRight) : OCQOQOOOCO.OCCCDCOQCC(this, splinePoints, baseScript.terrainMinIndent, roadShape[0].x, oDCQDOOOCCIndent, startPrefabIndent, startbendLeftRight));
		}
		else
		{
			flag3 = true;
			startSurfacesSafe = true;
		}
		int num27 = 0;
		bool surfacesSafe = true;
		bool flag7 = false;
		if (endPrefabScript != null && (!endPrefabScript.isSnapConnector || endPrefabScript.isExitRoadConnector))
		{
			surfacesSafe = false;
			QDOODOQQDQODD qDOODOQQDQODD2 = endPrefabScript.crossingElements[endConnectionSegment];
			qDOODOQQDQODD2.connectedMarker = markersExt.Count - 1;
			if (qDOODOQQDQODD2.rightInt == 0 && qDOODOQQDQODD2.leftInt == 0)
			{
				qDOODOQQDQODD2.leftInt = 0;
				qDOODOQQDQODD2.rightInt = qDOODOQQDQODD2.connectionVecInts.Count - 1;
				qDOODOQQDQODD2.leftIntFull = 0;
				qDOODOQQDQODD2.rightIntFull = qDOODOQQDQODD2.fullConnectionVecInts.Count - 1;
			}
			if (roadShape.Count > qDOODOQQDQODD2.leftInt && roadShape.Count > qDOODOQQDQODD2.rightInt)
			{
				num19 = qDOODOQQDQODD2.leftInt;
				num20 = qDOODOQQDQODD2.rightInt;
			}
			if (roadShape.Count == qDOODOQQDQODD2.connectionVecInts.Count)
			{
				flag7 = true;
			}
			if (endPrefabScript.isCustomPrefab)
			{
				endLeft = endPrefabScript.tmpMeshVecs[qDOODOQQDQODD2.connectionVecInts[qDOODOQQDQODD2.leftInt]];
			}
			else
			{
				endLeft = endPrefabScript.tmpFullMeshVecs[qDOODOQQDQODD2.connectionVecInts[qDOODOQQDQODD2.leftInt]];
			}
			Vector3 vector3 = endLeft;
			endLeft = endPrefabScript.transform.TransformPoint(endLeft);
			if (!isSideObject || endPrefabScript.tmpMeshVecs.Length != 0)
			{
				if (endPrefabScript.isCustomPrefab)
				{
					endRight = endPrefabScript.tmpMeshVecs[qDOODOQQDQODD2.connectionVecInts[qDOODOQQDQODD2.rightInt]];
				}
				else
				{
					endRight = endPrefabScript.tmpFullMeshVecs[qDOODOQQDQODD2.connectionVecInts[qDOODOQQDQODD2.rightInt]];
				}
			}
			Vector3 vector4 = endRight;
			endRight = endPrefabScript.transform.TransformPoint(endRight);
			num27 = Mathf.RoundToInt(Mathf.Ceil(roadWidth / (faceDistance * 1f)));
			if (endPrefabScript.crossingElements[endConnectionSegment].leftIndentV3 != Vector3.zero)
			{
				startPrefabIndent2 = endPrefabScript.transform.TransformPoint(endPrefabScript.crossingElements[endConnectionSegment].leftIndentV3);
			}
			else
			{
				startPrefabIndent2 = vector3;
				startPrefabIndent2.y = 0f;
				startPrefabIndent2 = endPrefabScript.transform.TransformPoint(startPrefabIndent2);
			}
			if (endPrefabScript.crossingElements[endConnectionSegment].rightIndentV3 != Vector3.zero)
			{
				oDCQDOOOCCIndent2 = endPrefabScript.transform.TransformPoint(endPrefabScript.crossingElements[endConnectionSegment].rightIndentV3);
			}
			else
			{
				oDCQDOOOCCIndent2 = vector4;
				oDCQDOOOCCIndent2.y = 0f;
				oDCQDOOOCCIndent2 = endPrefabScript.transform.TransformPoint(oDCQDOOOCCIndent2);
			}
			vector2 = endPrefabScript.transform.TransformPoint(Vector3.zero);
			zero2 = endPrefabScript.transform.TransformPoint(endPrefabScript.crossingElements[endConnectionSegment].tmpCenterPoint);
			num14 = endPrefabScript.crossingElements[endConnectionSegment].additionalIndentDistance;
			if (endPrefabScript.isExitRoadConnector)
			{
				vector2 = endPrefabScript.prefabCenterDummy;
			}
			if (endPrefabScript.tCrossing && endConnectionSegment <= 1)
			{
				float num28 = Vector3.Distance(vector2, zero2);
				for (int count = splinePoints.Count; count < splinePoints.Count; count--)
				{
					if (!(num28 > -1f + Vector3.Distance(splinePoints[0], vector2)))
					{
						break;
					}
					splinePoints.RemoveAt(count);
					tValues.RemoveAt(count);
					count++;
				}
			}
			num15 = ((endbendLeftRight != -1) ? OCQOQOOOCO.OOQQDDDOQC(this, splinePoints, baseScript.minIndent, roadShape[0].x, oDCQDOOOCCIndent2, startPrefabIndent2, endbendLeftRight, ref endAdjustInt, ref endAdjustDistance) : OCQOQOOOCO.OOQQDDDOQC(this, splinePoints, baseScript.minIndent, roadShape[roadShape.Count - 1].x, oDCQDOOOCCIndent2, startPrefabIndent2, endbendLeftRight, ref endAdjustInt, ref endAdjustDistance));
		}
		bool flag8 = false;
		if (startPrefabScript != null && startPrefabScript.surfaceMeshVecs.Length == 0 && startPrefabScript.doTerrainDeformation)
		{
			flag8 = true;
		}
		bool flag9 = false;
		if (endPrefabScript != null && endPrefabScript.surfaceMeshVecs.Length == 0 && endPrefabScript.doTerrainDeformation)
		{
			flag9 = true;
		}
		if (!isSideObject)
		{
			OQQCCQCDQQ.OOOCDQDQDC(markersExt, exitRoads, ref splinePoints, ref tValues);
		}
		soSplinePoints = new List<Vector3>(splinePoints);
		soSplinePointsLeft = new List<Vector3>(splinePoints);
		soSplinePointsRight = new List<Vector3>(splinePoints);
		soSplinePointsLeftClamped = new List<Vector3>(splinePoints);
		soSplinePointsRightClamped = new List<Vector3>(splinePoints);
		distances.Clear();
		if (isSideObject)
		{
			insertSplinePoints.Clear();
			insertSplinePoints.AddRange(splinePoints);
			lastForward = (soSplinePoints[soSplinePoints.Count - 1] - soSplinePoints[soSplinePoints.Count - 2]).normalized;
			OCDCOOQOQD(null);
			if (markerInts.Count != splinePoints.Count)
			{
				markerInts.Clear();
				int num29 = 0;
				for (int num30 = 0; num30 < splinePoints.Count; num30++)
				{
					markerInts.Add(num29);
					if (num29 + 1 < markersExt.Count && num30 == markersExt[num29 + 1].startSplinePoint)
					{
						num29++;
					}
				}
			}
			ODDQODOOOC.ODOODCCDOC(baseScript, this, isSideObjectFlag: true);
			roadUpdate = false;
			return;
		}
		List<List<Vector2>> roadShapeValues = GetRoadShapeValues(tValues, markerDistances, markersExt, 0, tmpMarkersExt.Count, roadShape);
		if (roadShapeValues[0].Count != splinePoints.Count)
		{
			for (int num31 = 0; num31 < roadShapeValues.Count; num31++)
			{
				for (int count2 = roadShapeValues[num31].Count; count2 < splinePoints.Count; count2++)
				{
					roadShapeValues[num31].Add(roadShapeValues[num31][0]);
				}
			}
		}
		if (markersExt.Count > 1)
		{
			GetSurfaceValues(tValues, markerDistances, markersExt, 0, tmpMarkersExt.Count, ref leftIndents, ref rightIndents, ref leftSurrounding, ref rightSurrounding, num);
		}
		if (leftIndents.Count < splinePoints.Count)
		{
			for (int count3 = leftIndents.Count; count3 < splinePoints.Count; count3++)
			{
				leftIndents.Add(leftIndents[0]);
				rightIndents.Add(rightIndents[0]);
				leftSurrounding.Add(leftSurrounding[0]);
				rightSurrounding.Add(rightSurrounding[0]);
			}
		}
		List<Vector3> vecs = new List<Vector3>();
		List<Vector2> uvs = new List<Vector2>();
		List<Vector2> uvs2 = new List<Vector2>();
		List<Vector3> surfaceVecs = new List<Vector3>();
		List<Vector2> list = new List<Vector2>();
		if (indent < baseScript.terrainMinIndent)
		{
			indent = baseScript.terrainMinIndent;
		}
		if (surrounding < 1f)
		{
			surrounding = 1f;
		}
		float terrainMinIndent = baseScript.terrainMinIndent;
		treeVecs.Clear();
		detailVecs.Clear();
		vegetationTris.Clear();
		leftIndentVecs.Clear();
		rightIndentVecs.Clear();
		middleIndentVecs.Clear();
		leftSurroundingVecs.Clear();
		rightSurroundingVecs.Clear();
		leftIndentVecsSV.Clear();
		rightIndentVecsSV.Clear();
		tris.Clear();
		for (int num32 = 0; num32 < roadMaterials.Length; num32++)
		{
			tris.Add(new List<int>());
		}
		int num33 = 0;
		float num34 = 0f;
		float num35 = 0f;
		float num36 = 0f;
		float num37 = 0f;
		float num38 = 0f;
		if (uvTiling == 0f)
		{
			uvTiling = 1f;
		}
		float num39 = 5f * uvTiling;
		if (roadShape[0].x != roadShape[roadShape.Count - 1].x)
		{
			roadWidth = Vector2.Distance(new Vector2(roadShape[0].x, 0f), new Vector2(roadShape[roadShape.Count - 1].x, 0f));
		}
		else
		{
			float num40 = 10000f;
			float num41 = -10000f;
			for (int num42 = 0; num42 < roadShape.Count; num42++)
			{
				if (roadShape[num42].x < num40)
				{
					num40 = roadShape[num42].x;
				}
				if (roadShape[num42].x > num41)
				{
					num41 = roadShape[num42].x;
				}
			}
			roadWidth = num41 - num40;
		}
		leftToCenterPerc = 0f;
		if (leftToCenterPerc == 0f)
		{
			if (num19 >= roadShape.Count || num20 >= roadShape.Count)
			{
				UnityEngine.Debug.LogWarning("EasyRoasds3D Warning: the road shape does not match: " + base.gameObject.name);
				roadUpdate = false;
				return;
			}
			if (num20 == -1)
			{
				num20 = roadShape.Count - 1;
			}
			leftToCenterPerc = OCCQQCCDDD.GetleftToCenterPerc(roadShape, num19, num20);
		}
		nodeDistance.Clear();
		nodeDistance.Add(0f);
		for (int num43 = 1; num43 < roadShape.Count; num43++)
		{
			nodeDistance.Add(Vector2.Distance(new Vector2(roadShape[0].x, 0f), new Vector2(roadShape[num43].x, 0f)) / roadWidth);
			if (roadShape[num43 - 1].x <= 0f && roadShape[num43].x >= 0f)
			{
				num7 = roadShapeMaterialInts[num43];
			}
		}
		Vector3 zero3 = Vector3.zero;
		int num44 = 0;
		bool flag10 = false;
		bool flag11 = false;
		List<bool> list2 = new List<bool>();
		List<float> list3 = new List<float>();
		Vector3 firstDir = Vector3.zero;
		Vector3 vector5 = Vector3.zero;
		á = -1;
		4AAAA = -1;
		if (hardEdge.Count == 0 || hardEdge.Count != roadShape.Count)
		{
			hardEdge.Clear();
			for (int num45 = 0; num45 < roadShape.Count; num45++)
			{
				hardEdge.Add(item: false);
			}
		}
		if (doConnectionTri.Count != roadShape.Count)
		{
			doConnectionTri.Clear();
			for (int num46 = 0; num46 < roadShape.Count; num46++)
			{
				doConnectionTri.Add(item: true);
			}
		}
		int num47 = num19;
		int num48 = num20;
		int count4 = roadShape.Count;
		int num49 = 0;
		List<int> list4 = new List<int>();
		for (int num50 = 0; num50 < hardEdge.Count; num50++)
		{
			if (hardEdge[num50] && num50 > 0 && num50 < hardEdge.Count - 1)
			{
				count4++;
				list4.Add(num49);
				num49++;
			}
			if (num50 == num19)
			{
				num47 = num19 + num49;
			}
			if (num50 == num20)
			{
				num48 = num20 + num49;
			}
			list4.Add(num49);
		}
		float y = roadShape[num19].y;
		float y2 = roadShape[num20].y;
		int count5 = hardEdge.Count;
		roadShapeCols = count4;
		int[] array = new int[count4];
		int[] array2 = new int[count4];
		bool[] array3 = new bool[count4];
		bool[] array4 = new bool[count4];
		List<bool> isPlanar = new List<bool>();
		float num51 = 0.5f;
		if (baseScript.terrainMinIndent > 0.5f * roadWidth)
		{
			num51 = baseScript.terrainMinIndent / roadWidth;
			if ((double)num51 > 0.9)
			{
				num51 = 0.9f;
			}
		}
		num51 = 0.2f;
		Vector2 zero4 = Vector2.zero;
		bool flag12 = true;
		bool flag13 = true;
		bool flag14 = true;
		float num52 = 0f;
		float num53 = 0f;
		float num54 = 0f;
		bool flag15 = true;
		List<Color> colors = new List<Color>();
		Color customColor = markersExt[0].customColor;
		float num55 = 0f;
		float num56 = 0f;
		float num57 = 0f;
		if (uv4Type == 1)
		{
			num57 = Mathf.Floor(totalDistance / detailDistance);
			num55 = ((num57 != 0f) ? (totalDistance / num57) : totalDistance);
		}
		if (roadShapeUVs.Count != roadShapeUVs2.Count)
		{
			roadShapeUVs2 = new List<float>(roadShapeUVs);
		}
		Vector2 item = new Vector2(0f, 0f);
		if (rt != null && rt.type == ERRoadWayType.MotorwayRamp)
		{
			item = new Vector2(0f, 1f);
		}
		int num58 = 0;
		int addedRows = 0;
		float num59 = 0f;
		float roadUvThreshold = baseScript.roadUvThreshold;
		bool flag16 = false;
		List<int> list5 = new List<int>();
		int count6 = roadShape.Count;
		int num60 = num19;
		int num61 = num20;
		List<float> list6 = new List<float>(roadShapeUVs);
		List<bool> list7 = new List<bool>(hardEdge);
		List<Vector2> list8 = new List<Vector2>();
		List<Vector2> list9 = new List<Vector2>();
		List<float> collection = new List<float>();
		List<bool> list10 = new List<bool>();
		List<bool> list11 = new List<bool>();
		int currentMostLeftInt = 0;
		int currentMostRightInt = 0;
		int sectionRoadShapeCols = 0;
		List<Vector2> list12 = new List<Vector2>();
		List<float> collection2 = new List<float>();
		List<bool> list13 = new List<bool>();
		List<bool> list14 = new List<bool>();
		int currentMostLeftInt2 = 0;
		int currentMostRightInt2 = 0;
		int sectionRoadShapeCols2 = 0;
		List<Vector2> list15 = new List<Vector2>();
		List<float> collection3 = new List<float>();
		List<bool> list16 = new List<bool>();
		List<bool> list17 = new List<bool>();
		int num62 = 0;
		int num63 = 0;
		int num64 = 0;
		bool flag17 = false;
		int num65 = 0;
		int num66 = -1;
		int num67 = -1;
		int num68 = -1;
		if (exitRoads.Count > 0)
		{
			flag17 = true;
			num66 = exitRoads[num65].startSplineIndex;
			num67 = exitRoads[num65].fixedDistanceIndex;
			num68 = exitRoads[num65].endSplineIndex;
		}
		bool flag18 = false;
		int num69 = 0;
		List<SideObject> list18 = new List<SideObject>();
		List<SideObject> list19 = new List<SideObject>();
		List<SideObject> list20 = new List<SideObject>();
		List<SideObject> list21 = new List<SideObject>();
		List<SideObject> list22 = new List<SideObject>();
		float num70 = 1000f;
		float num71 = 1000f;
		float num72 = 1000f;
		float num73 = 1000f;
		float num74 = 1000f;
		float num75 = 1000f;
		float num76 = 1000f;
		bool flag19 = false;
		bool flag20 = false;
		bool flag21 = false;
		bool flag22 = false;
		bool flag23 = false;
		bool flag24 = false;
		List<float> list23 = new List<float>();
		List<float> list24 = new List<float>();
		List<float> list25 = new List<float>();
		bool flag25 = false;
		bool flag26 = false;
		for (int num77 = 0; num77 < soDataExt.Count; num77++)
		{
			if (!soDataExt[num77].active || !(soDataExt[num77].sideObject != null) || !soDataExt[num77].autoGenerate)
			{
				continue;
			}
			if (soDataExt[num77].sideObject.tunnelObject)
			{
				list18.Add(soDataExt[num77].sideObject);
				num74 = soDataExt[num77].sideObject.heightThreshold;
				if (num74 < soDataExt[num77].sideObject.y1)
				{
					num74 = soDataExt[num77].sideObject.y1 + 1f;
				}
				flag26 = true;
			}
			if (soDataExt[num77].sideObject.bridgeObject)
			{
				list19.Add(soDataExt[num77].sideObject);
				if (soDataExt[num77].sideObject.heightThreshold < num75)
				{
					num75 = soDataExt[num77].sideObject.heightThreshold;
				}
				flag26 = true;
			}
			if (soDataExt[num77].sideObject.category == 0 && !soDataExt[num77].sideObject.tunnelObject && !soDataExt[num77].sideObject.bridgeObject)
			{
				list20.Add(soDataExt[num77].sideObject);
				if (soDataExt[num77].sideObject.angleThreshold < num71)
				{
					num71 = soDataExt[num77].sideObject.angleThreshold;
				}
				if (soDataExt[num77].sideObject.heightThreshold < num73)
				{
					num73 = soDataExt[num77].sideObject.heightThreshold;
				}
				flag26 = true;
			}
			if (soDataExt[num77].sideObject.category == 4 && soDataExt[num77].sideObject.autoGenerate && !soDataExt[num77].sideObject.tunnelObject && !soDataExt[num77].sideObject.bridgeObject)
			{
				list21.Add(soDataExt[num77].sideObject);
				if (soDataExt[num77].sideObject.angleThreshold < num72)
				{
					num72 = soDataExt[num77].sideObject.angleThreshold;
				}
				flag26 = true;
			}
			if (soDataExt[num77].sideObject.category == 2 && soDataExt[num77].sideObject.autoGenerate && soDataExt[num77].sideObject.retainingWall && !soDataExt[num77].sideObject.tunnelObject && !soDataExt[num77].sideObject.bridgeObject)
			{
				list22.Add(soDataExt[num77].sideObject);
				if (soDataExt[num77].sideObject.heightThreshold < num76)
				{
					num76 = soDataExt[num77].sideObject.heightThreshold;
				}
				flag26 = true;
			}
		}
		int num78 = 0;
		bool flag27 = false;
		ERSOSection eRSOSection = new ERSOSection(Vector3.zero, Vector3.zero, -1, -1, 0f, 0f, 0f, 0f);
		ERSOSection eRSOSection2 = new ERSOSection(Vector3.zero, Vector3.zero, -1, -1, 0f, 0f, 0f, 0f);
		ERSOSection eRSOSection3 = new ERSOSection(Vector3.zero, Vector3.zero, -1, -1, 0f, 0f, 0f, 0f);
		OQCOCCQCCD = OQDOOOQODD(tValues, markerDistances, markersExt, 0, tmpMarkersExt.Count, ref OQQOODQCCC, randomRotations);
		if (OQCOCCQCCD.Count != splinePoints.Count)
		{
			for (int count7 = OQCOCCQCCD.Count; count7 < splinePoints.Count; count7++)
			{
				OQCOCCQCCD.Add(OQCOCCQCCD[0]);
			}
		}
		if (markerInts.Count != splinePoints.Count)
		{
			for (int count8 = markerInts.Count; count8 < splinePoints.Count; count8++)
			{
				markerInts.Add(markerInts[0]);
			}
		}
		float num79 = Mathf.Lerp(50f, 0f, connectionAdjustDistanceEnd / 50f);
		if (bridgeElement.Count != splinePoints.Count)
		{
			int count9 = bridgeElement.Count;
			for (int num80 = count9; num80 < splinePoints.Count; num80++)
			{
				bridgeElement.Add(item: false);
			}
		}
		bool flag28 = false;
		int num81 = 0;
		int num82 = -1;
		int num83 = -1;
		int num84 = -1;
		bool flag29 = false;
		if (soSectionList1.Count > 0)
		{
			flag29 = true;
		}
		if (flag29)
		{
			num82 = soSectionList1[0].startSplinePoint;
			num83 = soSectionList1[0].endSplinePoint + 1;
			if (num82 == 0)
			{
				flag28 = true;
			}
		}
		List<bool> list26 = new List<bool>();
		list26.Add(flag28);
		float num85 = 0f;
		if (lockUVs && markersExt.Count > 1)
		{
			num85 = markersExt[1].markerStartUVY - Mathf.Floor(markersExt[1].markerStartUVY);
			flag16 = true;
		}
		for (int num86 = 0; num86 < splinePoints.Count; num86++)
		{
			if (num86 > 0)
			{
				num35 = Vector3.Distance(splinePoints[num86 - 1], splinePoints[num86]);
				num34 += num35;
			}
			if (flag29)
			{
				if (num86 == num82)
				{
					flag28 = true;
				}
				else if (num86 == num83)
				{
					flag28 = false;
					num84 = num83;
					if (soSectionList1.Count > num81 + 1)
					{
						flag28 = false;
						num81++;
						num82 = soSectionList1[num81].startSplinePoint;
						num83 = soSectionList1[num81].endSplinePoint + 1;
					}
				}
			}
			list26.Add(flag28);
			if (num44 + 1 >= tmpMarkersExt.Count)
			{
				num44 = tmpMarkersExt.Count - 2;
			}
			if (num86 == tmpMarkersExt[num44 + 1].startSplinePoint - 1)
			{
				flag10 = tmpMarkersExt[num44 + 1].bridgeObject;
				if (tmpMarkersExt[num44 + 1].bridgeObject)
				{
					if (tmpMarkersExt[num44 + 1].bridgeStartLevelDistance == 0f || tmpMarkersExt[num44].bridgeObject)
					{
						flag11 = true;
					}
					else
					{
						num53 = tmpMarkersExt[num44 + 1].bridgeStartLevelDistance;
					}
				}
				else
				{
					flag11 = false;
				}
				flag12 = true;
				flag8 = true;
				if (tmpMarkersExt.Count > num44 + 1 && num86 != 0)
				{
					num44++;
				}
				if (num44 >= markersExt.Count)
				{
					num44 = markersExt.Count - 1;
				}
				customColor = markersExt[num44].customColor;
				if (num44 == 1 && lockUVs)
				{
					float num87 = num34 / num39;
					num87 -= Mathf.Floor(num87);
					num59 = (num85 - num87) * -1f;
				}
			}
			else if (num86 != 0)
			{
				if (tmpMarkersExt[num44].bridgeObject)
				{
					flag11 = true;
				}
				flag12 = false;
				num54 = 0f;
				num52 = num53;
				num53 = 0f;
				if (flag11 && tmpMarkersExt.Count > num44 + 1 && splinePoints.Count > num86 + 1 && num86 + 2 == tmpMarkersExt[num44 + 1].startSplinePoint && !tmpMarkersExt[num44 + 1].bridgeObject && tmpMarkersExt[num44].bridgeEndLevelDistance > 0f)
				{
					num54 = tmpMarkersExt[num44].bridgeEndLevelDistance;
					flag11 = false;
				}
			}
			if (bridgeElement[num86])
			{
				list2.Add(item: true);
			}
			else
			{
				list2.Add(flag11);
			}
			if (num52 > 0f)
			{
				list2[num86 - 1] = false;
				bridgeElement[num86 - 1] = false;
			}
			if (num54 > 0f)
			{
				list2[num86] = false;
				bridgeElement[num86] = false;
			}
			doLeftSurrounding.Add(item: true);
			doRightSurrounding.Add(item: true);
			num38 = num34 / num39 - num59;
			num56 = num34 / num55;
			if (flag12)
			{
				markersExt[num44].markerStartUVY = num38 - Mathf.Floor(num38);
			}
			Vector3 vector6 = ((num86 == 0) ? (splinePoints[num86 + 1] - splinePoints[num86]).normalized : ((num86 != splinePoints.Count - 1) ? (splinePoints[num86 + 1] - splinePoints[num86 - 1]).normalized : (splinePoints[num86] - splinePoints[num86 - 1]).normalized));
			if (num86 == 0)
			{
				firstDir = vector6;
			}
			vector5 = vector6;
			zero3 = OCQOQOOOCO.GetEulerAngles(vector6);
			vector6 = new Vector3(0f - vector6.z, 0f, vector6.x);
			if (!flag3 && num86 < splinePoints.Count - 2)
			{
				vector = (splinePoints[num86 + 1] - splinePoints[num86]).normalized;
				vector = new Vector3(0f - vector.z, 0f, vector.x);
			}
			Vector3 vector8;
			Vector3 zero5;
			Vector3 vector7 = (vector8 = (zero5 = Vector3.zero));
			Vector3 position = Vector3.zero;
			float num88 = 0f;
			if (OQCOCCQCCD[num86] != 0f)
			{
				Vector3 a4 = splinePoints[num86] + vector6 * roadShape[num60].x;
				Vector3 b = splinePoints[num86] + vector6 * roadShape[num61].x;
				position = Vector3.Lerp(a4, b, OQQOODQCCC[num86]);
				num88 = Mathf.Lerp(roadShape[num60].x, roadShape[num61].x, OQQOODQCCC[num86]);
			}
			num58 = vecs.Count;
			if (num38 > roadUvThreshold)
			{
				list5.Add(num58);
				num58 += count4;
			}
			num69 = 0;
			flag18 = false;
			if (flag17)
			{
				if (num86 >= num66 && num86 <= num68)
				{
					flag18 = true;
				}
				if (num86 == num66 - 1)
				{
					sectionRoadShapeCols2 = 0;
					ODCCODOCQQ.OQDCDQDCQC(rt, ref list12, ref collection2, ref list14, ref list13, ref currentMostLeftInt2, ref currentMostRightInt2, ref sectionRoadShapeCols2, 1, 0, transition: true, roadShape);
					num69 = 1;
					List<int> list27 = tris[0];
					ODCCODOCQQ.OODCQDDQDC(roadShape, hardEdge, count4, list12, list13, sectionRoadShapeCols2, ref list27, flipNormals, vecs.Count, 0, 0, roadShape.Count, list12.Count);
				}
				else if (num86 == num66)
				{
					count6 = list12.Count;
					list8 = new List<Vector2>(list12);
					list6 = new List<float>(collection2);
					list7 = new List<bool>(list13);
					roadShapeCols = sectionRoadShapeCols2;
					List<int> list28 = tris[0];
					int last = rt.roadShapeData.outerLaneMarkingRightIndex + 1;
					if (!rt.roadShapeData.includeOuterlaneLeftInShape)
					{
						last--;
					}
					last--;
					sectionRoadShapeCols = 0;
					ODCCODOCQQ.OQDCDQDCQC(rt, ref list9, ref collection, ref list11, ref list10, ref currentMostLeftInt, ref currentMostRightInt, ref sectionRoadShapeCols, 1, 0, transition: false, roadShape);
					ODCCODOCQQ.OODCQDDQDC(list12, list13, sectionRoadShapeCols2, list9, list10, sectionRoadShapeCols, ref list28, flipNormals, vecs.Count, 0, 0, last, list9.Count);
					if (roadShapeCols != count4)
					{
						flag16 = true;
					}
					num69 = 2;
				}
				else if (num86 == num66 + 1)
				{
					count6 = list9.Count;
					list8 = new List<Vector2>(list9);
					list6 = new List<float>(collection);
					list7 = new List<bool>(list10);
					roadShapeCols = sectionRoadShapeCols;
					num69 = 0;
				}
				else if (num86 == num67 - 1)
				{
					List<int> list29 = tris[0];
					int last2 = rt.roadShapeData.outerLaneMarkingRightIndex + 1;
					if (!rt.roadShapeData.includeOuterlaneLeftInShape)
					{
						last2--;
					}
					last2--;
					ODCCODOCQQ.OODCQDDQDC(list9, list10, sectionRoadShapeCols, list15, list16, num64, ref list29, flipNormals, vecs.Count, 0, 0, roadShape.Count, last2);
					num69 = 1;
				}
				else if (num86 == num67)
				{
					count6 = list15.Count;
					list8 = new List<Vector2>(list15);
					list6 = new List<float>(collection3);
					list7 = new List<bool>(list16);
					roadShapeCols = num64;
					List<int> list30 = tris[0];
					ODCCODOCQQ.OODCQDDQDC(list15, list16, num64, list9, list10, sectionRoadShapeCols, ref list30, flipNormals, vecs.Count, 0, 0, list15.Count, list9.Count);
					num69 = 1;
				}
				else if (num86 == num67 + 1)
				{
					sectionRoadShapeCols = 0;
					ODCCODOCQQ.OQDCDQDCQC(rt, ref list9, ref collection, ref list11, ref list10, ref currentMostLeftInt, ref currentMostRightInt, ref sectionRoadShapeCols, 1, 1, transition: false, roadShape);
					count6 = list9.Count;
					list8 = new List<Vector2>(list9);
					list6 = new List<float>(collection);
					list7 = new List<bool>(list10);
					roadShapeCols = sectionRoadShapeCols;
					num69 = 0;
				}
				else if (num86 > num68 && num86 < num68 - 1)
				{
					num69 = 0;
				}
				else if (num86 == num68 - 1)
				{
					sectionRoadShapeCols2 = 0;
					ODCCODOCQQ.OQDCDQDCQC(rt, ref list12, ref collection2, ref list14, ref list13, ref currentMostLeftInt2, ref currentMostRightInt2, ref sectionRoadShapeCols2, 1, 2, transition: true, roadShape);
					List<int> list31 = tris[0];
					int last3 = rt.roadShapeData.outerLaneMarkingRightIndex + 1;
					if (!rt.roadShapeData.includeOuterlaneLeftInShape)
					{
						last3--;
					}
					last3--;
					ODCCODOCQQ.OODCQDDQDC(list9, list10, sectionRoadShapeCols, list12, list13, sectionRoadShapeCols2, ref list31, flipNormals, vecs.Count, 0, 0, list9.Count, last3);
					num69 = 3;
				}
				else if (num86 == num68)
				{
					count6 = list12.Count;
					list8 = new List<Vector2>(list12);
					list6 = new List<float>(collection2);
					list7 = new List<bool>(list13);
					roadShapeCols = sectionRoadShapeCols2;
					List<int> list32 = tris[0];
					ODCCODOCQQ.OODCQDDQDC(list12, list13, sectionRoadShapeCols2, roadShape, hardEdge, count4, ref list32, flipNormals, vecs.Count, 0, 0, list12.Count, roadShape.Count);
					num69 = 3;
				}
				else if (num86 == num68 + 1)
				{
					count6 = roadShape.Count;
					list6 = new List<float>(roadShapeUVs);
					list7 = new List<bool>(hardEdge);
					roadShapeCols = count4;
					num69 = 0;
					num65++;
					if (num65 < exitRoads.Count - 1)
					{
						num66 = exitRoads[num65].startSplineIndex;
						num68 = exitRoads[num65].endSplineIndex;
						num67 = exitRoads[num65].fixedDistanceIndex;
					}
					else
					{
						flag17 = false;
					}
				}
			}
			int num89 = 0;
			Vector3 pos;
			for (int num90 = 0; num90 < count6; num90++)
			{
				zero4 = ((!flag18) ? roadShapeValues[num90][num86] : list8[num90]);
				bool flag30 = false;
				if (count5 > 0 && list7[num90] && num90 > 0 && num90 < count6 - 1)
				{
					flag30 = true;
				}
				if (OQCOCCQCCD[num86] != 0f)
				{
					float x = zero4.x - num88;
					pos = OCQOQOOOCO.OQOCQCOCQQ(position, new Vector2(x, zero4.y), 180f - OQCOCCQCCD[num86], zero3);
				}
				else
				{
					pos = splinePoints[num86] + vector6 * zero4.x;
				}
				if (terrainDeformation && startPrefabScript != null && num86 < num12 && !flag8 && !startPrefabScript.isIConnector)
				{
					pos.y = ODQDQDQDQO.OQDDCCCOQD(startPrefabIndent, oDCQDOOOCCIndent, a, pos);
					num13 = num34;
					if (OQCOCCQCCD[num86] != 0f)
					{
						pos.y += zero4.y;
					}
				}
				else if (terrainDeformation && startPrefabScript != null && num34 - num13 < num18 - num13 && !flag8 && !startPrefabScript.isIConnector)
				{
					Vector3 p = pos;
					p.y = ODQDQDQDQO.OQDDCCCOQD(startPrefabIndent, oDCQDOOOCCIndent, a, p);
					float t = (num34 - num13) / (num18 - num13);
					if (OQCOCCQCCD[num86] != 0f)
					{
						p.y += zero4.y;
					}
					p.y = Mathf.Lerp(p.y, pos.y, t);
					pos.y = Mathf.Lerp(p.y, pos.y, Mathf.SmoothStep(0f, 1f, t));
				}
				if (terrainDeformation && endPrefabScript != null && num86 > num15 && !flag9 && !endPrefabScript.isIConnector)
				{
					pos.y = ODQDQDQDQO.OQDDCCCOQD(startPrefabIndent2, oDCQDOOOCCIndent2, vector2, pos);
					if (OQCOCCQCCD[num86] != 0f)
					{
						pos.y += zero4.y;
					}
				}
				else if (terrainDeformation && endPrefabScript != null && num86 >= endAdjustInt && !flag9 && !endPrefabScript.isIConnector)
				{
					if (num90 == 0)
					{
						num36 += num35;
					}
					Vector3 p2 = pos;
					p2.y = ODQDQDQDQO.OQDDCCCOQD(startPrefabIndent2, oDCQDOOOCCIndent2, vector2, p2);
					float t = num36 / endAdjustDistance;
					if (OQCOCCQCCD[num86] != 0f)
					{
						p2.y += zero4.y;
					}
					p2.y = Mathf.Lerp(pos.y, p2.y, t);
					pos.y = Mathf.Lerp(pos.y, p2.y, Mathf.SmoothStep(0f, 1f, t));
				}
				if (OQCOCCQCCD[num86] != 0f)
				{
					pos.y -= zero4.y;
				}
				if (num90 == num60)
				{
					vector7 = pos;
					if (OQCOCCQCCD[num86] != 0f)
					{
						vector7.y -= 0.02f;
					}
				}
				if (num90 == num61)
				{
					vector8 = pos;
					if (OQCOCCQCCD[num86] != 0f)
					{
						vector8.y -= 0.02f;
					}
				}
				if (num90 == num60)
				{
					soSplinePointsLeft[num86] = pos;
					if (flag12)
					{
						markersExt[num44].rl = pos + vector6;
					}
				}
				if (num90 == num61)
				{
					soSplinePointsRight[num86] = pos;
					if (flag12)
					{
						markersExt[num44].rr = pos - vector6;
					}
				}
				if (num90 == num60)
				{
					soSplinePointsLeftClamped[num86] = pos;
				}
				else if (num90 == num61)
				{
					soSplinePointsRightClamped[num86] = pos;
				}
				pos.y += zero4.y;
				if (snapVertices)
				{
					baseScript.OCDDQOCDCO(ref pos);
					pos.y += snapOffset + zero4.y;
				}
				vecs.Add(pos);
				colors.Add(customColor);
				if (flag12 || num86 == 0)
				{
					tmpMarkersExt[num44].roadShapeVecsGlobal.Add(pos);
				}
				if (!planarUVs || roadShapeMaterialInts[num90] != num7)
				{
					uvs.Add(new Vector2(list6[num90], num38));
					isPlanar.Add(item: false);
				}
				else
				{
					uvs.Add(new Vector2(pos.x * uvTiling, pos.z * uvTiling));
					isPlanar.Add(item: true);
				}
				if (uv4Type == 1)
				{
					uvs2.Add(new Vector2(list6[num90], num56));
				}
				else
				{
					uvs2.Add(baseScript.GetTerrainUV(pos));
				}
				if (flag30)
				{
					vecs.Add(pos);
					colors.Add(customColor);
					if (!planarUVs || roadShapeMaterialInts[num90] != num7)
					{
						uvs.Add(new Vector2(roadShapeUVs2[num90], num38));
						isPlanar.Add(item: false);
					}
					else
					{
						uvs.Add(new Vector2(pos.x * uvTiling, pos.z * uvTiling));
						isPlanar.Add(item: true);
					}
					if (uv4Type == 1)
					{
						uvs2.Add(new Vector2(list6[num90], num56));
					}
					else
					{
						uvs2.Add(baseScript.GetTerrainUV(pos));
					}
				}
				if (num86 < splinePoints.Count - 1 && num90 < count6 - 1)
				{
					flag2 = true;
					if (!flag3)
					{
						flag2 = false;
						if (!array3[num90 + num89] || !array3[num90 + 1 + num89])
						{
							if (num86 == 0)
							{
								array[num90 + num89] = -1;
								array[num90 + 1 + num89] = -1;
								if (flag30)
								{
									array[num90 + num89 + 1] = -1;
									array[num90 + 1 + num89 + 1] = -1;
								}
							}
							if (!array3[num90 + num89])
							{
								Vector3 pCheck = splinePoints[num86 + 1] + vector * zero4.x;
								if (ERCrossingPrefabs.OQCDCDOOCD(OQOQODDQCC, ODQCDQCCOD, pCheck))
								{
									array3[num90 + num89] = true;
								}
							}
							if (!array3[num90 + 1 + num89])
							{
								Vector3 pCheck = splinePoints[num86 + 1] + vector * roadShape[num90 + 1].x;
								if (ERCrossingPrefabs.OQCDCDOOCD(OQOQODDQCC, ODQCDQCCOD, pCheck))
								{
									array3[num90 + 1 + num89] = true;
								}
							}
							if (array3[num90 + num89] && array3[num90 + 1 + num89])
							{
								flag2 = true;
								if (array[num90 + num89] == -1)
								{
									array[num90 + num89] = num86;
									if (flag30)
									{
										array[num90 + num89 + 1] = num86;
									}
								}
								if (array[num90 + 1 + num89] == -1)
								{
									array[num90 + 1 + num89] = num86;
									if (flag30)
									{
										array[num90 + 1 + num89 + 1] = num86;
									}
								}
							}
						}
						if (num90 == count6 - 2 && num90 + 1 + num89 < roadShapeCols - 1 && array3[^2])
						{
							array3[^1] = true;
							array[^1] = array[^2];
						}
						flag2 = true;
					}
					if (endPrefabScript != null && num86 > splinePoints.Count - num27)
					{
						flag2 = true;
						Vector3 pCheck = splinePoints[num86] + vector6 * roadShape[num90].x;
						if (ERCrossingPrefabs.OQCDCDOOCD(endRight, endLeft, pCheck))
						{
							pCheck = splinePoints[num86] + vector6 * roadShape[num90 + 1].x;
							if (ERCrossingPrefabs.OQCDCDOOCD(endRight, endLeft, pCheck))
							{
								flag2 = true;
							}
						}
					}
					num33 = roadShapeMaterialInts[num90];
					if (num90 < roadShapeMaterialInts.Count - 2 && num33 != roadShapeMaterialInts[num90 + 1])
					{
						flag2 = false;
					}
					if (doConnectionTri.Count > 0 && !doConnectionTri[num90])
					{
						flag2 = false;
					}
					if (flag30)
					{
						num89++;
					}
					if (flag2 && num69 == 0)
					{
						if (!flipNormals)
						{
							tris[num33].Add(num58 + num90 + num89);
							tris[num33].Add(num58 + roadShapeCols + num90 + 1 + num89);
							tris[num33].Add(num58 + num90 + 1 + num89);
							tris[num33].Add(num58 + roadShapeCols + num90 + num89);
							tris[num33].Add(num58 + roadShapeCols + num90 + 1 + num89);
							tris[num33].Add(num58 + num90 + num89);
						}
						else
						{
							tris[num33].Add(num58 + num90 + num89);
							tris[num33].Add(num58 + num90 + 1 + num89);
							tris[num33].Add(num58 + roadShapeCols + num90 + 1 + num89);
							tris[num33].Add(num58 + roadShapeCols + num90 + num89);
							tris[num33].Add(num58 + num90 + num89);
							tris[num33].Add(num58 + roadShapeCols + num90 + 1 + num89);
						}
					}
				}
				if (flag3)
				{
					continue;
				}
				flag3 = true;
				for (int num91 = 0; num91 < array3.Length; num91++)
				{
					if (!array3[num91])
					{
						flag3 = false;
					}
				}
			}
			if (num38 > roadUvThreshold && num86 < splinePoints.Count - 1)
			{
				float num92 = num38;
				OCODCOOQOC(ref vecs, ref uvs, ref uvs2, count4, ref addedRows, ref isPlanar, ref colors, ref num38, ref num56);
				num59 += num92 - num38;
				flag16 = true;
			}
			if (flag12 || num86 == 0)
			{
				tmpMarkersExt[num44].perpDir = vector6;
				tmpMarkersExt[num44].perpDirRotated = (vector7 - vector8).normalized;
			}
			soSplinePoints[num86] = Vector3.Lerp(soSplinePointsLeft[num86], soSplinePointsRight[num86], leftToCenterPerc);
			if (startPrefabScript != null && num37 < num11 * 6f)
			{
				if (startbendLeftRight == -1)
				{
					if (num86 > 0)
					{
						num37 += Vector3.Distance(a2, vector7);
					}
					a2 = vector7;
				}
				else
				{
					if (num86 > 0)
					{
						num37 += Vector3.Distance(a2, vector8);
					}
					a2 = vector8;
				}
			}
			Vector3 normalized = (vector7 - vector8).normalized;
			if (flag12 && num54 > 0f)
			{
				Vector3 pos2 = vector7 + normalized * (leftIndents[num86] + leftSurrounding[num86]);
				pos2 += -vector5 * num54;
				baseScript.OCDDQOCDCO(ref pos2);
				surfaceVecs[surfaceVecs.Count - 5] = pos2;
				leftSurroundingVecs[leftSurroundingVecs.Count - 1] = pos2;
				pos2 = vector7 + normalized * leftIndents[num86];
				pos2 += -vector5 * num54;
				baseScript.OCDDQOCDCO(ref pos2);
				surfaceVecs[surfaceVecs.Count - 4] = pos2;
				leftIndentVecs[leftIndentVecs.Count - 1] = pos2;
				leftIndentVecsSV[leftIndentVecsSV.Count - 1] = pos2;
				pos2 = splinePoints[num86];
				pos2 += -vector5 * num54;
				baseScript.OCDDQOCDCO(ref pos2);
				surfaceVecs[surfaceVecs.Count - 3] = pos2;
				pos2 = vector8 + -normalized * rightIndents[num86];
				pos2 += -vector5 * num54;
				baseScript.OCDDQOCDCO(ref pos2);
				surfaceVecs[surfaceVecs.Count - 2] = pos2;
				rightIndentVecs[rightIndentVecs.Count - 1] = pos2;
				rightIndentVecsSV[rightIndentVecsSV.Count - 1] = pos2;
				pos2 = vector8 + -normalized * (rightIndents[num86] + rightSurrounding[num86]);
				pos2 += -vector5 * num54;
				baseScript.OCDDQOCDCO(ref pos2);
				surfaceVecs[surfaceVecs.Count - 1] = pos2;
				rightSurroundingVecs[rightSurroundingVecs.Count - 1] = pos2;
				num54 = 0f;
			}
			pos = vector7 + normalized * (leftIndents[num86] + leftSurrounding[num86]);
			if (num52 > 0f)
			{
				pos += vector5 * num52;
			}
			else if (num54 > 0f)
			{
				pos += -vector5 * num54;
			}
			baseScript.OCDDQOCDCO(ref pos);
			surfaceVecs.Add(pos);
			list.Add(item);
			leftSurroundingVecs.Add(pos);
			pos = vector7 + normalized * leftIndents[num86];
			if (tmpMarkersExt[markerInts[num86]].leftIndentAlignment == 1)
			{
				baseScript.OCDDQOCDCO(ref pos);
			}
			else if (tmpMarkersExt[markerInts[num86]].leftIndentAlignment == 2)
			{
				pos.y = surfaceVecs[surfaceVecs.Count - 1].y;
			}
			else if (tmpMarkersExt[markerInts[num86]].leftIndentAlignment != 3)
			{
			}
			if (num52 > 0f)
			{
				pos += vector5 * num52;
				baseScript.OCDDQOCDCO(ref pos);
			}
			else if (num54 > 0f)
			{
				pos += -vector5 * num54;
				baseScript.OCDDQOCDCO(ref pos);
			}
			surfaceVecs.Add(pos);
			list.Add(new Vector2(0f, 1f));
			leftIndentVecs.Add(pos);
			leftIndentVecsSV.Add(pos);
			if (pos.y < baseScript.terrainY - 0.02f && terrainDeformation)
			{
				vecsBelowTerrain.Add(soSplinePointsLeft[num86]);
			}
			pos = ((tmpMarkersExt[markerInts[num86]].leftIndentAlignment != 0 && tmpMarkersExt[markerInts[num86]].rightIndentAlignment == 0) ? Vector3.Lerp(vector7, vector8, num51) : ((tmpMarkersExt[markerInts[num86]].leftIndentAlignment != 0 || tmpMarkersExt[markerInts[num86]].rightIndentAlignment == 0) ? Vector3.Lerp(vector7, vector8, 0.5f) : Vector3.Lerp(vector8, vector7, num51)));
			if (num52 > 0f)
			{
				pos += vector5 * num52;
				baseScript.OCDDQOCDCO(ref pos);
			}
			else if (num54 > 0f)
			{
				pos += -vector5 * num54;
				baseScript.OCDDQOCDCO(ref pos);
			}
			surfaceVecs.Add(pos);
			list.Add(new Vector2(0f, 1f));
			middleIndentVecs.Add(pos);
			Vector3 pos3;
			pos = (pos3 = vector8 + -normalized * rightIndents[num86]);
			if (num52 > 0f)
			{
				pos += vector5 * num52;
				baseScript.OCDDQOCDCO(ref pos);
			}
			else if (num54 > 0f)
			{
				pos += -vector5 * num54;
				baseScript.OCDDQOCDCO(ref pos);
			}
			surfaceVecs.Add(pos);
			list.Add(new Vector2(0f, 1f));
			rightIndentVecs.Add(pos + -normalized);
			rightIndentVecsSV.Add(pos);
			if (pos.y < baseScript.terrainY - 0.02f && terrainDeformation)
			{
				vecsBelowTerrain.Add(soSplinePointsRight[num86]);
			}
			pos = vector8 + -normalized * (rightIndents[num86] + rightSurrounding[num86]);
			if (num52 > 0f)
			{
				pos += vector5 * num52;
			}
			else if (num54 > 0f)
			{
				pos += -vector5 * num54;
			}
			baseScript.OCDDQOCDCO(ref pos);
			surfaceVecs.Add(pos);
			list.Add(item);
			rightSurroundingVecs.Add(pos);
			if (tmpMarkersExt[markerInts[num86]].rightIndentAlignment == 1)
			{
				baseScript.OCDDQOCDCO(ref pos3);
				surfaceVecs[surfaceVecs.Count - 2] = pos3;
			}
			else if (tmpMarkersExt[markerInts[num86]].rightIndentAlignment == 2)
			{
				pos3.y = pos.y;
				surfaceVecs[surfaceVecs.Count - 2] = pos3;
			}
			else if (tmpMarkersExt[markerInts[num86]].rightIndentAlignment != 3)
			{
			}
			if (!startSurfacesSafe && !flag8)
			{
				if (num86 == 0 && startPrefabScript.doTerrainDeformation)
				{
					surfaceVecs[4] = transform.TransformPoint(startPrefabScript.crossingElements[startConnectionSegment].leftSurroundingV3);
					surfaceVecs[0] = transform.TransformPoint(startPrefabScript.crossingElements[startConnectionSegment].rightSurroundingV3);
					surfaceVecs[3] = transform.TransformPoint(startPrefabScript.crossingElements[startConnectionSegment].leftIndentV3);
					surfaceVecs[1] = transform.TransformPoint(startPrefabScript.crossingElements[startConnectionSegment].rightIndentV3);
					surfaceVecs[2] = Vector3.Lerp(surfaceVecs[1], surfaceVecs[3], 0.5f);
					leftSurroundingVecs[0] = surfaceVecs[4];
					leftIndentVecs[0] = surfaceVecs[3];
					middleIndentVecs[0] = surfaceVecs[2];
					rightIndentVecs[0] = surfaceVecs[1];
					rightSurroundingVecs[0] = surfaceVecs[0];
				}
				else if (terrainDeformation && startPrefabScript.doTerrainDeformation)
				{
					OCQOQOOOCO.OODCOQOQOD(this, ref surfaceVecs, startPrefabScript, ref startSurfacesSafe, num34, baseScript.minIndent);
				}
			}
			if (num86 == 0)
			{
				sv1 = vector7;
				sv2 = vector8;
				sv1 = vector7 + vector6 * indent;
				sv2 = vector8 + -vector6 * indent;
			}
			treeVecs.Add(soSplinePointsLeft[num86] + vector6 * baseScript.treeDistance);
			treeVecs.Add(soSplinePointsRight[num86] + -vector6 * baseScript.treeDistance);
			detailVecs.Add(soSplinePointsLeft[num86] + vector6 * baseScript.detailDistance - baseScript.detailOffsetVec);
			detailVecs.Add(soSplinePointsRight[num86] + -vector6 * baseScript.detailDistance - baseScript.detailOffsetVec);
			if (num86 < splinePoints.Count - 1 && !flag10 && !flag28)
			{
				vegetationTris.Add(num86 * 2);
				vegetationTris.Add((num86 + 1) * 2 + 1);
				vegetationTris.Add(num86 * 2 + 1);
				vegetationTris.Add((num86 + 1) * 2);
				vegetationTris.Add((num86 + 1) * 2 + 1);
				vegetationTris.Add(num86 * 2);
			}
		}
		float num93 = 0f;
		float num94 = 0f;
		if (startPrefabScript != null && startPrefabScript.siblings.Count > startConnectionSegment && startPrefabScript.siblings[startConnectionSegment] != null)
		{
			num93 = startPrefabScript.siblings[startConnectionSegment].uvy;
		}
		if (endPrefabScript != null && endPrefabScript.siblings.Count > endConnectionSegment && endPrefabScript.siblings[endConnectionSegment] != null)
		{
			num94 = 1f - endPrefabScript.siblings[endConnectionSegment].uvy;
		}
		Vector2[] array5 = uvs.ToArray();
		Vector2[] collection4 = uvs2.ToArray();
		float num95 = Mathf.Round(array5[^1].y) / array5[^count4].y;
		if (!flag16 && (num93 != 0f || num94 != 0f))
		{
			if (totalDistance > 5f)
			{
				num95 = array5[^1].y / array5[^count4].y;
				for (int num96 = 0; num96 < array5.Length - 1; num96 += count4)
				{
					for (int num97 = 0; num97 < count4; num97++)
					{
						if (isPlanar[num96 + num97])
						{
							continue;
						}
						if (!planarUVs)
						{
							if (num97 == 0)
							{
								array5[num96 + num97].y = num93 + array5[num96].y * num95;
							}
							else
							{
								array5[num96 + num97].y = array5[num96].y;
							}
						}
						else
						{
							array5[num96 + num97].y = array5[num96 + num97].y * num95;
						}
					}
				}
			}
		}
		else if (!flag16 && totalDistance > 5f && baseScript.clampUVs)
		{
			for (int num98 = 0; num98 < array5.Length - 1; num98 += count4)
			{
				for (int num99 = 0; num99 < count4; num99++)
				{
					if (isPlanar[num98 + num99])
					{
						continue;
					}
					if (!planarUVs)
					{
						if (num99 == 0)
						{
							array5[num98 + num99].y = array5[num98].y * num95;
						}
						else
						{
							array5[num98 + num99].y = array5[num98].y;
						}
					}
					else
					{
						array5[num98 + num99].y = array5[num98 + num99].y * num95;
					}
				}
			}
		}
		List<int> list33 = new List<int>();
		List<int> list34 = new List<int>();
		if (startPrefabScript != null && (!startPrefabScript.isSnapConnector || startPrefabScript.isExitRoadConnector))
		{
			if (startPrefabScript.meshVecs.Length == 0)
			{
			}
			int num100 = vecs.Count - 1;
			int num101 = count4;
			bool flag31 = false;
			if (ERCrossingPrefabs.OQCDCDOOCD(vecs[num101], vecs[0], vecs[num101 * 2]))
			{
				flag31 = true;
			}
			List<int> connectionVecInts = startPrefabScript.crossingElements[startConnectionSegment].connectionVecInts;
			List<int> fullConnectionVecInts = startPrefabScript.crossingElements[startConnectionSegment].fullConnectionVecInts;
			List<Vector3> list35 = new List<Vector3>();
			List<Vector3> list36 = new List<Vector3>();
			List<int> list37 = new List<int>();
			for (int num102 = 0; num102 < count4; num102++)
			{
				if (num102 + array[num102] * count4 < 0)
				{
					UnityEngine.Debug.LogError(base.gameObject.name + ": The angle with the crossing is too sharp " + startPrefabScript);
					flag15 = false;
					break;
				}
				bool flag32 = false;
				if (startPrefabScript.isIConnector && endPrefabScript != null && endPrefabScript.isCustomPrefab)
				{
					flag32 = true;
				}
				Vector3 value = ((startPrefabScript.isCustomPrefab || flag32) ? startPrefabScript.transform.TransformPoint(startPrefabScript.tmpMeshVecs[connectionVecInts[connectionVecInts.Count - roadShapeIntsStart[num102 - list4[num102]] - 1]]) : startPrefabScript.transform.TransformPoint(startPrefabScript.tmpFullMeshVecs[connectionVecInts[connectionVecInts.Count - roadShapeIntsStart[num102 - list4[num102]] - 1]]));
				if (fullConnectionVecInts.Count - num102 - 1 >= 0)
				{
					list34.Add(fullConnectionVecInts[fullConnectionVecInts.Count - num102 - 1]);
				}
				else
				{
					flag13 = false;
				}
				vecs[num102 + array[num102] * count4] = value;
				list33.Add(num102 + array[num102] * count4);
				if (!startPrefabScript.crossingElements[startConnectionSegment].rotationPriority)
				{
					float num103 = roadWidth / Mathf.Tan(startAngle * ((float)Math.PI / 180f));
					float num104 = (flag31 ? (10f + (1f - nodeDistance[num102 - list4[num102]]) * num103 * 2f) : (10f + nodeDistance[num102 - list4[num102]] * num103 * 2f));
					float num105 = 0f;
					int num106 = 1;
					Vector3 a5;
					Vector3 vector9 = (a5 = vecs[num102 + array[num102] * count4]);
					while (num105 < num104)
					{
						Vector3 vector10 = vecs[num102 + (array[num102] + num106) * count4];
						num105 += Vector3.Distance(a5, vector10);
						Vector3 normalized2 = (vector10 - vector9).normalized;
						Vector3 vector11 = Vector3.Lerp(-startDir, normalized2, num105 / num104);
						Vector3 vector12 = vector9 + vector11 * num105;
						a5 = vector10;
						if (num102 == num47)
						{
							Vector3 item2 = vecs[num102 + (array[num102] + num106) * count4];
							item2.y -= y;
							list35.Add(item2);
							list37.Add(array[num102] + num106);
						}
						if (num102 == num48)
						{
							Vector3 item3 = vecs[num102 + (array[num102] + num106) * count4];
							item3.y -= y2;
							list36.Add(item3);
						}
						num106++;
						if (num102 + (array[num102] + num106) * count4 > vecs.Count - 1)
						{
							break;
						}
					}
				}
				if (num93 == 0f && num94 == 0f)
				{
					if (!isPlanar[num102 + array[num102] * count4])
					{
						float num107 = Vector3.Distance(vecs[num102 + array[num102] * count4], vecs[num102 + count4 + array[num102] * count4]);
						float y3 = array5[num102 + count4 + array[num102] * count4].y - num107 / num39;
						array5[num102 + array[num102] * count4].y = y3;
						array5[num102 + array[num102] * count4].y = 0f;
					}
					else
					{
						value = vecs[num102 + array[num102] * count4];
						array5[num102 + array[num102] * count4] = new Vector2(value.x * uvTiling, value.z * uvTiling);
					}
				}
			}
			int count10 = list35.Count;
			if (list36.Count < list35.Count)
			{
				count10 = list36.Count;
			}
			for (int num108 = 0; num108 < count10; num108++)
			{
				soSplinePoints[list37[num108]] = Vector3.Lerp(list35[num108], list36[num108], leftToCenterPerc);
				soSplinePointsLeft[list37[num108]] = list35[num108];
				soSplinePointsRight[list37[num108]] = list36[num108];
				soSplinePointsLeftClamped[list37[num108]] = list35[num108];
				soSplinePointsRightClamped[list37[num108]] = list36[num108];
			}
			List<Vector3> list38 = soSplinePointsLeft;
			List<Vector3> list39 = soSplinePointsLeftClamped;
			List<Vector3> list40 = vecs;
			int num109 = num47;
			_ = array[0];
			Vector3 value2 = (list39[0] = list40[num109 + 0]);
			list38[0] = value2;
			if (roadShape[num19].y != 0f)
			{
				Vector3 vector14 = soSplinePointsLeft[0];
				vector14.y -= roadShape[num19].y;
				List<Vector3> list41 = soSplinePointsLeft;
				value2 = (soSplinePointsLeftClamped[0] = vector14);
				list41[0] = value2;
			}
			if (num48 + array[num48] * count4 >= 0)
			{
				List<Vector3> list42 = soSplinePointsRight;
				value2 = (soSplinePointsRightClamped[0] = vecs[num48 + array[num48] * count4]);
				list42[0] = value2;
				if (roadShape[num20].y != 0f)
				{
					Vector3 vector17 = soSplinePointsRight[0];
					vector17.y -= roadShape[num20].y;
					List<Vector3> list43 = soSplinePointsRight;
					value2 = (soSplinePointsRightClamped[0] = vector17);
					list43[0] = value2;
				}
				soSplinePoints[0] = Vector3.Lerp(soSplinePointsLeft[0], soSplinePointsRight[0], leftToCenterPerc);
			}
		}
		List<int> list44 = new List<int>();
		List<int> list45 = new List<int>();
		if (endPrefabScript != null && (!endPrefabScript.isSnapConnector || endPrefabScript.isExitRoadConnector))
		{
			if (endPrefabScript.meshVecs.Length == 0)
			{
				endPrefabScript.OCOODQQDQO();
			}
			int num110 = vecs.Count - 1;
			int num111 = count4;
			bool flag33 = false;
			if (ERCrossingPrefabs.OQCDCDOOCD(vecs[num110], vecs[num110 - num111], vecs[num110 - num111 * 2]))
			{
				flag33 = true;
			}
			int num112 = vecs.Count - count4;
			List<int> connectionVecInts2 = endPrefabScript.crossingElements[endConnectionSegment].connectionVecInts;
			List<int> fullConnectionVecInts2 = endPrefabScript.crossingElements[endConnectionSegment].fullConnectionVecInts;
			List<Vector3> list46 = new List<Vector3>();
			List<Vector3> list47 = new List<Vector3>();
			List<int> list48 = new List<int>();
			for (int num113 = 0; num113 < count4; num113++)
			{
				if (!endPrefabScript.isCustomPrefab && !endPrefabScript.isIConnector)
				{
					vecs[num112 + num113] = endPrefabScript.transform.TransformPoint(endPrefabScript.tmpFullMeshVecs[connectionVecInts2[roadShapeIntsEnd[num113 - list4[num113]]]]);
				}
				else
				{
					vecs[num112 + num113] = endPrefabScript.transform.TransformPoint(endPrefabScript.tmpMeshVecs[connectionVecInts2[roadShapeIntsEnd[num113 - list4[num113]]]]);
				}
				list44.Add(num112 + num113);
				if (fullConnectionVecInts2.Count > num113)
				{
					list45.Add(fullConnectionVecInts2[num113]);
				}
				else
				{
					flag14 = false;
				}
				if (!endPrefabScript.crossingElements[endConnectionSegment].rotationPriority)
				{
					float num114 = roadWidth / Mathf.Tan(endAngle * ((float)Math.PI / 180f));
					float num115 = (flag33 ? (10f + (1f - nodeDistance[num113 - list4[num113]]) * num114 * 2f) : (3f + nodeDistance[num113 - list4[num113]] * num114 * 2f));
					float num116 = 0f;
					int num117 = 0;
					Vector3 a6;
					Vector3 vector19 = (a6 = vecs[num112 + num113 - num117 * count4]);
					num117 = 1;
					while (num116 < num115 && num112 + num113 - num117 * count4 >= 0)
					{
						Vector3 vector20 = vecs[num112 + num113 - num117 * count4];
						num116 += Vector3.Distance(a6, vector20);
						Vector3 normalized3 = (vector20 - vector19).normalized;
						Vector3 vector21 = Vector3.Lerp(-endDir, normalized3, num116 / num115);
						Vector3 vector22 = vector19 + vector21 * num116;
						a6 = vector20;
						if (num113 == num47)
						{
							Vector3 item4 = vecs[num112 + num113 - num117 * count4];
							item4.y -= y;
							list46.Add(item4);
							list48.Add(splinePoints.Count - 1 - num117);
						}
						if (num113 == num48)
						{
							Vector3 item5 = vecs[num112 + num113 - num117 * count4];
							item5.y -= y2;
							list47.Add(item5);
						}
						num117++;
						if (num112 + num113 - num117 * count4 > vecs.Count - 1)
						{
							break;
						}
					}
				}
				if (num93 == 0f && num94 == 0f)
				{
					if (!isPlanar[num112 + num113])
					{
						float num118 = Vector3.Distance(vecs[num112 + num113], vecs[num112 + num113 - count4]);
						float y4 = array5[num112 + num113 - count4].y + num118 / num39;
						array5[num112 + num113].y = y4;
					}
					else
					{
						Vector3 vector23 = vecs[num112 + num113];
						array5[num112 + num113] = new Vector2(vector23.x * uvTiling, vector23.z * uvTiling);
					}
				}
			}
			if (endPrefabScript.isIConnector)
			{
				num95 = 1f / array5[^1].y * Mathf.Round(array5[^1].y);
				num95 = Mathf.Round(array5[^1].y) / array5[^count4].y;
				if (totalDistance > 5f && baseScript.clampUVs)
				{
					for (int num119 = 0; num119 < array5.Length; num119 += count4)
					{
						for (int num120 = 0; num120 < count4; num120++)
						{
							if (isPlanar[num119 + num120])
							{
								continue;
							}
							if (!planarUVs)
							{
								if (num120 == 0)
								{
									array5[num119 + num120].y = array5[num119].y * num95;
								}
								else
								{
									array5[num119 + num120].y = array5[num119].y;
								}
							}
							else
							{
								array5[num119 + num120].y = array5[num119 + num120].y * num95;
							}
						}
					}
				}
			}
			if (leftToCenterPerc == 0f)
			{
				leftToCenterPerc = OCCQQCCDDD.GetleftToCenterPerc(roadShape, num19, num20);
			}
			int count11 = list46.Count;
			if (list47.Count < list46.Count)
			{
				count11 = list47.Count;
			}
			for (int num121 = 0; num121 < count11; num121++)
			{
				soSplinePoints[list48[num121]] = Vector3.Lerp(list46[num121], list47[num121], leftToCenterPerc);
				soSplinePointsLeft[list48[num121]] = list46[num121];
				soSplinePointsRight[list48[num121]] = list47[num121];
				soSplinePointsLeftClamped[list48[num121]] = list46[num121];
				soSplinePointsRightClamped[list48[num121]] = list47[num121];
			}
			soSplinePointsLeft[soSplinePointsLeft.Count - 1] = vecs[num112 + num47];
			soSplinePointsLeftClamped[soSplinePointsLeft.Count - 1] = vecs[num112 + num47];
			soSplinePointsRight[soSplinePointsRight.Count - 1] = vecs[num112 + num48];
			soSplinePointsRightClamped[soSplinePointsRight.Count - 1] = vecs[num112 + num48];
			if (roadShape[num19].y != 0f)
			{
				Vector3 vector24 = soSplinePointsLeft[soSplinePointsLeft.Count - 1];
				vector24.y -= roadShape[num19].y;
				List<Vector3> list49 = soSplinePointsLeft;
				int index = soSplinePointsLeft.Count - 1;
				Vector3 value2 = (soSplinePointsLeftClamped[soSplinePointsLeft.Count - 1] = vector24);
				list49[index] = value2;
			}
			if (roadShape[num20].y != 0f)
			{
				Vector3 vector26 = soSplinePointsRight[soSplinePointsRight.Count - 1];
				vector26.y -= roadShape[num20].y;
				List<Vector3> list50 = soSplinePointsRight;
				int index2 = soSplinePointsRight.Count - 1;
				Vector3 value2 = (soSplinePointsRightClamped[soSplinePointsRight.Count - 1] = vector26);
				list50[index2] = value2;
			}
			soSplinePoints[soSplinePoints.Count - 1] = Vector3.Lerp(soSplinePointsLeft[soSplinePointsLeft.Count - 1], soSplinePointsRight[soSplinePointsRight.Count - 1], leftToCenterPerc);
		}
		Color[] array6 = new Color[vecs.Count];
		for (int num122 = 0; num122 < array6.Length; num122++)
		{
			array6[num122] = Color.white;
		}
		if (closedTrack)
		{
			for (int num123 = 0; num123 < count4; num123++)
			{
				vecs[vecs.Count - count4 + num123] = vecs[num123];
			}
		}
		else
		{
			if ((double)fadeInDistance > 0.5)
			{
				float num124 = 0f;
				float a7 = 0f;
				int num125 = 0;
				while (num124 < fadeInDistance)
				{
					for (int num126 = 0; num126 < count4; num126++)
					{
						array6[num125 * count4 + num126].a = a7;
					}
					if (vecs.Count > (num125 + 2) * count4)
					{
						num124 += faceDistance;
						a7 = num124 / fadeInDistance;
						a7 *= a7;
						num125++;
						continue;
					}
					break;
				}
			}
			if ((double)fadeOutDistance > 0.5)
			{
				if (array6 == null)
				{
				}
				float num127 = 0f;
				float a8 = 0f;
				int num128 = 0;
				int count12 = vecs.Count;
				while (num127 < fadeOutDistance)
				{
					for (int num129 = 0; num129 < count4; num129++)
					{
						array6[count12 - 1 - num128 * count4 - num129].a = a8;
					}
					if (vecs.Count > (num128 + 2) * count4)
					{
						num127 += faceDistance;
						a8 = num127 / fadeOutDistance;
						a8 *= a8;
						num128++;
						continue;
					}
					break;
				}
			}
		}
		if (tCrossingConnected)
		{
			float num130 = totalDistance;
			totalDistance = 0f;
			for (int num131 = 1; num131 < soSplinePoints.Count; num131++)
			{
				totalDistance += Vector3.Distance(soSplinePoints[num131 - 1], soSplinePoints[num131]);
			}
			if (totalDistance < 1000f)
			{
				totalDistanceString = totalDistance.ToString("N2") + " m";
			}
			else
			{
				totalDistanceString = (totalDistance / 1000f).ToString("N3") + " km";
			}
		}
		meshVecs.Clear();
		meshVecs.AddRange(vecs);
		meshUVs.Clear();
		meshUVs = new List<Vector2>(array5);
		meshUVs2.Clear();
		meshUVs2 = new List<Vector2>(collection4);
		if (roadMaterials == null)
		{
			roadMaterials = new List<Material>(base.gameObject.GetComponent<MeshRenderer>().sharedMaterials).ToArray();
		}
		else if (roadMaterials[0] == null)
		{
			roadMaterials = new List<Material>(base.gameObject.GetComponent<MeshRenderer>().sharedMaterials).ToArray();
		}
		if (base.gameObject.GetComponent<MeshRenderer>().sharedMaterials != null)
		{
			int num132 = 0;
			Material[] sharedMaterials = base.gameObject.GetComponent<MeshRenderer>().sharedMaterials;
			foreach (Material material in sharedMaterials)
			{
				if (roadMaterials.Length > num132 && material != roadMaterials[num132])
				{
					roadMaterials[num132] = material;
				}
				num132++;
			}
		}
		Material[] array7 = new List<Material>(roadMaterials).ToArray();
		if (!isSideObject)
		{
			bool hasExits = false;
			OQQCCQCDQQ.OQCCQOQDDO(baseScript, this, exitRoads, markersExt, ref soSplinePointsLeft, ref soSplinePointsRight, ref hasExits, leftIndents, rightIndents, leftSurrounding, rightSurrounding, ref surfaceVecs);
			if (roadMaterials == null)
			{
				roadMaterials = new List<Material>(base.gameObject.GetComponent<MeshRenderer>().sharedMaterials).ToArray();
			}
			else if (roadMaterials.Length != 0 && roadMaterials[0] == null)
			{
				roadMaterials = new List<Material>(base.gameObject.GetComponent<MeshRenderer>().sharedMaterials).ToArray();
			}
			if (hasExits)
			{
				List<Color> list51 = new List<Color>(array6);
				array6 = list51.ToArray();
			}
		}
		if (uv4Type == 1 && (double)Mathf.Abs(num57 - meshUVs2[meshUVs2.Count - 1].y) > 0.01)
		{
			float num134 = num57 / meshUVs2[meshUVs2.Count - 1].y;
			for (int num135 = 0; num135 < meshUVs2.Count; num135++)
			{
				meshUVs2[num135] = new Vector2(meshUVs2[num135].x, meshUVs2[num135].y * num134);
			}
		}
		if (vecs.Count < 65000)
		{
			mesh.Clear();
			mesh.vertices = vecs.ToArray();
			mesh.uv = meshUVs.ToArray();
			mesh.uv4 = meshUVs2.ToArray();
			if (fadeInDistance == 0f && fadeOutDistance == 0f)
			{
				mesh.colors = colors.ToArray();
			}
			else if (array6.Length == vecs.Count)
			{
				mesh.colors = array6;
			}
			else
			{
				mesh.colors = new Color[vecs.Count];
				UnityEngine.Debug.Log("Road: " + base.gameObject.name + " , colors array is out of bounds ");
			}
			mesh.tangents = new Vector4[vecs.Count];
			int num136 = 0;
			for (int num137 = 0; num137 < tris.Count; num137++)
			{
				if (tris[num137].Count > 0)
				{
					num136++;
				}
			}
			mesh.subMeshCount = num136;
			trisStats = 0;
			for (int num138 = 0; num138 < tris.Count; num138++)
			{
				if (num138 >= num136)
				{
					continue;
				}
				for (int num139 = 0; num139 < tris[num138].Count; num139++)
				{
					if (tris[num138][num139] > vecs.Count)
					{
						UnityEngine.Debug.Log("tri out of bounds:" + tris[num138][num139] + " > " + (vecs.Count - 1));
					}
				}
				mesh.SetTriangles(tris[num138].ToArray(), num138);
				trisStats += tris[num138].Count;
			}
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			OCDCOOQOQD(mesh);
			if (mesh.name == "")
			{
				mesh.name = "ER Road Mesh";
			}
			ODCCODOCQQ.OCDCQCOQQO(mesh);
			if (closedTrack)
			{
				int num140 = vecs.Count - 1;
				int count13 = roadShape.Count;
				for (int num141 = 0; num141 < count13; num141++)
				{
					mesh.normals[num141] = (mesh.normals[num140 - count13 + num141] = Vector3.Lerp(mesh.normals[num141], mesh.normals[num140 - count13 + num141], 0.5f));
				}
			}
			if (!closedTrack && ((bool)startPrefabScript || (bool)endPrefabScript))
			{
				mesh.normals = AdjustNormals(mesh.normals);
			}
			if ((bool)startPrefabScript && flag6 && flag13 && startPrefabScript.averageNormals)
			{
				AdjustPrefabNormals(list33, list34, mesh.normals, startPrefabScript.gameObject, mesh.vertices);
			}
			if ((bool)endPrefabScript && flag7 && flag14 && endPrefabScript.averageNormals)
			{
				AdjustPrefabNormals(list44, list45, mesh.normals, endPrefabScript.gameObject, mesh.vertices);
			}
			vertsStats = vecs.Count;
			trisStats /= 3;
			if (hasMeshCollider && flag15)
			{
				base.gameObject.GetComponent<MeshCollider>().sharedMesh = null;
				base.gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
			}
			else if (hasMeshCollider)
			{
				base.gameObject.GetComponent<MeshCollider>().sharedMesh = null;
			}
			if (array7.Length != num136)
			{
				List<Material> list52 = new List<Material>();
				for (int num142 = 0; num142 < num136; num142++)
				{
					if (array7.Length > num142)
					{
						list52.Add(array7[num142]);
					}
				}
				array7 = list52.ToArray();
			}
			base.gameObject.GetComponent<MeshRenderer>().sharedMaterials = array7;
			if ((bool)base.gameObject.GetComponent<MeshRenderer>())
			{
				base.gameObject.GetComponent<MeshRenderer>().enabled = true;
			}
			if ((bool)base.gameObject.GetComponent<MeshCollider>())
			{
				base.gameObject.GetComponent<MeshCollider>().enabled = true;
			}
			testmesh = mesh;
		}
		else
		{
			UnityEngine.Debug.Log("The new road mesh exceeds Unityâs vertices limit of 65.000, updating the mesh is aborted");
		}
		num34 = 0f;
		if ((bool)endPrefabScript && !flag9)
		{
			for (int num143 = 0; (!surfacesSafe || num143 < surfaceVecs.Count - 5) && surfaceVecs.Count - num143 - 6 >= 0; num143 += 5)
			{
				if (!surfacesSafe && terrainDeformation && endPrefabScript.doTerrainDeformation)
				{
					OCQOQOOOCO.ODOCCQDCQO(this, ref surfaceVecs, endPrefabScript, num143, ref surfacesSafe, num34, baseScript.minIndent);
				}
				num34 += Vector3.Distance(surfaceVecs[surfaceVecs.Count - 2 - num143], surfaceVecs[surfaceVecs.Count - 2 - num143 - 5]);
			}
		}
		if (closedTrack)
		{
			surfaceVecs[surfaceVecs.Count - 5] = surfaceVecs[0];
			surfaceVecs[surfaceVecs.Count - 4] = surfaceVecs[1];
			surfaceVecs[surfaceVecs.Count - 3] = surfaceVecs[2];
			surfaceVecs[surfaceVecs.Count - 2] = surfaceVecs[3];
			surfaceVecs[surfaceVecs.Count - 1] = surfaceVecs[4];
			leftSurroundingVecs[leftSurroundingVecs.Count - 1] = leftSurroundingVecs[0];
			leftIndentVecs[leftIndentVecs.Count - 1] = leftIndentVecs[0];
			middleIndentVecs[middleIndentVecs.Count - 1] = middleIndentVecs[0];
			rightIndentVecs[rightIndentVecs.Count - 1] = rightIndentVecs[0];
			rightSurroundingVecs[rightSurroundingVecs.Count - 1] = rightSurroundingVecs[0];
			if (endDecalPrefab != null)
			{
				if (Application.isEditor && !Application.isPlaying)
				{
					UnityEngine.Object.DestroyImmediate(endDecalPrefab);
				}
				else
				{
					UnityEngine.Object.Destroy(endDecalPrefab);
				}
			}
		}
		else
		{
			if (endDecalPrefab == null && endDecalID != -1)
			{
				QDQDOOQQDQODD roadTypeElByID = QDQDOOQQDQODD.GetRoadTypeElByID(baseScript.roadTypes, roadType);
				if (roadTypeElByID != null)
				{
					endDecal = ERDecal.OCQCDQDODQ(endDecalID, roadTypeElByID.decalPresets);
					if (endDecal != null && endDecal.decalPrefab != null)
					{
						OQOOOOOOCQ(endDecal, ref endDecalPrefab, "_ERDecal_End");
					}
				}
			}
			if (endDecalPrefab != null)
			{
				OCDDDDQDQQ(1);
				OQOCCDCCDD(endDecalPrefab, soSplinePoints.Count - 1);
			}
		}
		if (startDecalPrefab == null && startDecalID != -1)
		{
			QDQDOOQQDQODD roadTypeElByID2 = QDQDOOQQDQODD.GetRoadTypeElByID(baseScript.roadTypes, roadType);
			if (roadTypeElByID2 != null)
			{
				startDecal = ERDecal.OCQCDQDODQ(startDecalID, roadTypeElByID2.decalPresets);
				if (startDecal != null && startDecal.decalPrefab != null)
				{
					OQOOOOOOCQ(startDecal, ref startDecalPrefab, "_ERDecal_Start");
				}
			}
		}
		if (startDecalPrefab != null)
		{
			OCDDDDQDQQ(0);
			OQOCCDCCDD(startDecalPrefab, 0);
		}
		if (markersExt.Count > 2)
		{
			doSurroundingSurfaces = true;
		}
		if (doSurroundingSurfaces)
		{
			OCQOQQCDOD(surfaceVecs, list, splinePoints.Count, list2, firstDir, vector5, indent, surrounding, list26);
		}
		insertSplinePoints.Clear();
		insertSplinePoints.AddRange(splinePoints);
		for (int num144 = 0; num144 < markersExt.Count; num144++)
		{
			if (markersExt[num144].controlTypeTmp == 3)
			{
				markersExt[num144].controlType = 3;
				markersExt[num144].controlTypeTmp = 0;
			}
		}
		if (lastForward == Vector3.zero)
		{
			lastForward = (soSplinePoints[soSplinePoints.Count - 1] - soSplinePoints[soSplinePoints.Count - 2]).normalized;
		}
		if (startPrefabScript != null)
		{
			Vector3 value3 = leftSurroundingVecs[0];
			leftSurroundingVecs[0] = rightSurroundingVecs[0];
			rightSurroundingVecs[0] = value3;
		}
		doLeftSurrounding.Clear();
		doRightSurrounding.Clear();
		if (road == null)
		{
			road = new ERRoad(this);
		}
		if (ERRoadNetwork.onRoadUpdate != null)
		{
			ERRoadNetwork.OnRoadUpdated(road);
		}
		roadUpdate = false;
	}

	private void OCODCOOQOC(ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<Vector2> uvs2, int cols, ref int addedRows, ref List<bool> isPlanar, ref List<Color> colors, ref float uv, ref float uv4)
	{
		uv -= Mathf.Floor(uv);
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		List<Vector2> list3 = new List<Vector2>();
		List<bool> list4 = new List<bool>();
		List<Color> list5 = new List<Color>();
		int num = vecs.Count - cols;
		for (int i = num; i < vecs.Count; i++)
		{
			list.Add(vecs[i]);
			Vector2 item = uvs[i];
			item.y = uv;
			list2.Add(item);
			list3.Add(uvs2[i]);
			list4.Add(isPlanar[i]);
			list5.Add(colors[i]);
		}
		vecs.AddRange(list);
		uvs.AddRange(list2);
		uvs2.AddRange(list3);
		isPlanar.AddRange(list4);
		colors.AddRange(list5);
		addedRows++;
	}

	public void OCDCOOQOQD(Mesh m)
	{
		if (m != null)
		{
			bounds = m.bounds;
		}
		else
		{
			bounds = default(Bounds);
			foreach (ERMarkerExt item in markersExt)
			{
				bounds.Encapsulate(item.position);
			}
		}
		bounds.Expand(baseScript.markerDistance);
		Vector3 min = bounds.min;
		min.y = -1000000f;
		bounds.min = min;
		min = bounds.max;
		min.y = 10000000f;
		bounds.max = min;
	}

	public void OQOOOOOOCQ(ERDecal decal, ref GameObject decalPrefab, string name)
	{
		decalPrefab = UnityEngine.Object.Instantiate(decal.decalPrefab);
		decalPrefab.name = decal.decalPrefab.name + name;
		decalPrefab.transform.parent = base.transform;
		decalPrefab.transform.localScale *= decal.scale;
	}

	public float ODCDOQOOOO(ERDecal decal, float roadWidth)
	{
		return 1f;
	}

	public void OOOCOODQCO(string type)
	{
		List<GameObject> list = new List<GameObject>();
		foreach (Transform item in base.transform)
		{
			if (item.name.IndexOf("_ERDecal_" + type) != -1)
			{
				list.Add(item.gameObject);
			}
		}
		if (Application.isEditor && !Application.isPlaying)
		{
			foreach (GameObject item2 in list)
			{
				UnityEngine.Object.DestroyImmediate(item2);
			}
		}
		else
		{
			foreach (GameObject item3 in list)
			{
				UnityEngine.Object.Destroy(item3);
			}
		}
		if (startDecalPrefab == null && startDecalID != -1)
		{
			QDQDOOQQDQODD roadTypeElByID = QDQDOOQQDQODD.GetRoadTypeElByID(baseScript.roadTypes, roadType);
			if (roadTypeElByID != null)
			{
				ERDecal eRDecal = ERDecal.OCQCDQDODQ(startDecalID, roadTypeElByID.decalPresets);
				if (eRDecal != null && eRDecal.decalPrefab != null)
				{
					OQOOOOOOCQ(eRDecal, ref startDecalPrefab, "_ERDecal_Start");
				}
				OQOCCDCCDD(startDecalPrefab, 0);
			}
		}
		if (!(endDecalPrefab == null) || endDecalID == -1)
		{
			return;
		}
		QDQDOOQQDQODD roadTypeElByID2 = QDQDOOQQDQODD.GetRoadTypeElByID(baseScript.roadTypes, roadType);
		if (roadTypeElByID2 == null)
		{
			return;
		}
		ERDecal eRDecal2 = ERDecal.OCQCDQDODQ(endDecalID, roadTypeElByID2.decalPresets);
		if (eRDecal2 != null)
		{
			if (eRDecal2.decalPrefab != null)
			{
				OQOOOOOOCQ(eRDecal2, ref endDecalPrefab, "_ERDecal_End");
			}
			OQOCCDCCDD(endDecalPrefab, soSplinePoints.Count - 1);
		}
	}

	public void OQOCCDCCDD(GameObject decal, int index)
	{
		int index2 = 0;
		int num = 1;
		bool flag = false;
		int num2 = 0;
		ERDecal eRDecal = null;
		if (index != 0)
		{
			num = -1;
			index2 = markersExt.Count - 1;
			num2 = endDecalID;
			eRDecal = endDecal;
			if (endPrefabScript != null && endPrefabScript.isIConnector)
			{
				flag = true;
			}
		}
		else
		{
			num2 = startDecalID;
			eRDecal = startDecal;
			if (startPrefabScript != null && startPrefabScript.isIConnector)
			{
				flag = true;
			}
		}
		if (eRDecal == null)
		{
			QDQDOOQQDQODD roadTypeElByID = QDQDOOQQDQODD.GetRoadTypeElByID(baseScript.roadTypes, roadType);
			if (roadTypeElByID != null)
			{
				eRDecal = ERDecal.OCQCDQDODQ(num2, roadTypeElByID.decalPresets);
			}
		}
		Vector3 position = soSplinePoints[index];
		if (eRDecal != null)
		{
			position.y += eRDecal.heightOffset;
		}
		decal.transform.position = position;
		Vector3 vector = soSplinePointsLeft[index] - soSplinePointsRight[index];
		Vector3 vector2 = Vector3.zero;
		Vector3 zero = Vector3.zero;
		if (index == 0)
		{
			vector = new Vector3(0f - vector.z, 0f, vector.x).normalized;
			if (eRDecal.startOffset != 0f)
			{
				vector2 = (soSplinePoints[1] - soSplinePoints[0]).normalized;
			}
		}
		else
		{
			vector = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
			if (eRDecal.startOffset != 0f)
			{
				vector2 = (soSplinePoints[index - 1] - soSplinePoints[index]).normalized;
			}
		}
		decal.transform.forward = vector;
		if (eRDecal.startOffset != 0f)
		{
			decal.transform.position += vector2 * eRDecal.startOffset;
		}
		position = Vector3.Lerp(soSplinePoints[index], soSplinePoints[index + num], 0.5f);
		if (!flag)
		{
			zero = markersExt[index2].position;
			if (eRDecal.startOffset != 0f)
			{
				zero += vector2 * eRDecal.startOffset;
				position = zero;
			}
			decal.transform.position = zero;
		}
		if (index != 0 && eRDecal.endRotation != 0f)
		{
			Vector3 eulerAngles = decal.transform.eulerAngles;
			eulerAngles.y += eRDecal.endRotation;
			decal.transform.eulerAngles = eulerAngles;
		}
		Vector3 vector3 = ODQDQDQDQO.OOQODCCOQD(position, this);
		Vector3 forward = decal.transform.forward;
		Vector3 vector4 = forward - Vector3.Dot(forward, vector3) * vector3;
		if (vector4 != Vector3.zero)
		{
			decal.transform.rotation = Quaternion.LookRotation(vector4, vector3);
		}
		if (eRDecal != null)
		{
			if (eRDecal.meshWidth == 0f)
			{
				eRDecal.OCQCQCOCOO();
			}
			float num3 = OCDDDDQDQQ(index);
			decal.transform.localScale = num3 / eRDecal.meshWidth * new Vector3(1f, 1f, 1f) * eRDecal.scale;
		}
		if (!flag && eRDecal != null)
		{
			zero = decal.transform.position;
			zero.y += eRDecal.heightOffset;
			decal.transform.position = zero;
		}
	}

	public float OCDDDDQDQQ(int startEnd)
	{
		float num = 0f;
		QDQDOOQQDQODD roadTypeElByID = QDQDOOQQDQODD.GetRoadTypeElByID(baseScript.roadTypes, roadType);
		if (roadTypeElByID == null)
		{
			return 0f;
		}
		List<Vector2> list = null;
		Vector3 a;
		Vector3 b;
		if (startEnd == 0)
		{
			list = markersExt[0].roadShape;
			a = soSplinePointsLeft[0];
			b = soSplinePointsRight[0];
		}
		else
		{
			list = markersExt[markersExt.Count - 1].roadShape;
			a = soSplinePointsLeft[soSplinePointsLeft.Count - 1];
			b = soSplinePointsRight[soSplinePointsRight.Count - 1];
		}
		if (roadTypeElByID.roadShape.Count == list.Count)
		{
			return Vector3.Distance(a, b);
		}
		int num2 = 0;
		int num3 = 0;
		for (int i = 0; i < roadTypeElByID.roadShape.Count; i++)
		{
			if (list[0].x < 0f)
			{
				if (roadTypeElByID.roadShape[i].x < 0f)
				{
					num2++;
				}
				else
				{
					num3++;
				}
			}
			else if (roadTypeElByID.roadShape[i].x > 0f)
			{
				num3++;
			}
			else
			{
				num2++;
			}
		}
		if (list[0].x < 0f)
		{
			num2--;
		}
		else
		{
			num3--;
		}
		int num4 = 0;
		for (int j = 0; j < list.Count; j++)
		{
			if (list[0].x < 0f)
			{
				if (list[j].x < 0f)
				{
					num4++;
				}
			}
			else if (list[j].x > 0f)
			{
				num4++;
			}
		}
		int num5 = 0;
		int index = 0;
		for (int k = 0; k < list.Count; k++)
		{
			if (list[0].x < 0f)
			{
				if (list[k].x >= 0f && num5 == 0)
				{
					num5 = k - num2 - 1;
					index = k + num3 - 1;
					break;
				}
			}
			else if (list[k].x <= 0f && num5 == 0)
			{
				index = k - num3 - 1;
				num5 = k + num2 - 1;
				break;
			}
		}
		return Vector3.Distance(list[num5], list[index]);
	}

	public Vector3[] AdjustNormals(Vector3[] normals)
	{
		int num = roadShapeCols;
		if (startPrefabScript != null)
		{
			for (int i = 0; i < roadShapeCols; i++)
			{
				normals[i] = normals[i + num];
			}
		}
		if (endPrefabScript != null)
		{
			for (int j = 0; j < roadShapeCols; j++)
			{
				normals[normals.Length - num - j - 1] = normals[normals.Length - j - 1 - num];
			}
		}
		return normals;
	}

	public void AdjustPrefabNormals(List<int> roadInts, List<int> prefabInts, Vector3[] normals, GameObject prefab, Vector3[] verts)
	{
		if (!(prefab.GetComponent<MeshFilter>() == null) && (bool)prefab.GetComponent<MeshFilter>().sharedMesh)
		{
			Mesh sharedMesh = prefab.GetComponent<MeshFilter>().sharedMesh;
			Vector3[] normals2 = sharedMesh.normals;
			for (int i = 0; i < roadInts.Count; i++)
			{
				normals2[prefabInts[i]] = prefab.transform.InverseTransformDirection(normals[roadInts[i]]);
			}
			sharedMesh.normals = normals2;
		}
	}

	public bool OQCDCDOOCD(Vector3 pTarget, Vector3 pSource, Vector3 pCheck)
	{
		Vector3 normalized = (pTarget - pSource).normalized;
		Vector3 normalized2 = (pCheck - pSource).normalized;
		if (Vector3.Cross(normalized, normalized2).y < 0f)
		{
			return false;
		}
		return true;
	}

	public void OODCOQOQOD(ref List<Vector3> surfaceVecs, ERCrossingPrefabs prefabScript, ref bool startSurfacesSafe, float distance, float minIndent)
	{
	}

	public void ODOCCQDCQO(ref List<Vector3> surfaceVecs, ERCrossingPrefabs prefabScript, int el, ref bool surfacesSafe, float distance, float minIndent)
	{
	}

	public bool OQCODQODCO(Vector3 ODCQDOOOCCIndent, Vector3 otherPrefabIndent, Vector3 v)
	{
		return false;
	}

	public void OCQOQQCDOD(List<Vector3> surfaceVecs, List<Vector2> uvs, int h, List<bool> doBridge, Vector3 firstDir, Vector3 lastDir, float indent, float surrounding, List<bool> tunnelSegments)
	{
		List<ERVSData> list = new List<ERVSData>();
		Vector3 a = Vector3.zero;
		bool flag = true;
		if (!baseScript.vegetationStudio || baseScript.vegetationStudioActive)
		{
		}
		if (surfaceMesh == null)
		{
			ERSurfaceScript componentInChildren = base.gameObject.GetComponentInChildren<ERSurfaceScript>();
			if (componentInChildren != null && componentInChildren.transform.parent.gameObject == base.gameObject)
			{
				surfaceMesh = componentInChildren.gameObject;
			}
		}
		if (surfaceMesh == null)
		{
			surfaceMesh = new GameObject("surface");
			surfaceMesh.hideFlags = HideFlags.HideInHierarchy;
			surfaceMesh.AddComponent<MeshFilter>();
			surfaceMesh.AddComponent<MeshRenderer>();
			surfaceMesh.AddComponent<MeshCollider>();
			surfaceMesh.AddComponent<ERSurfaceScript>();
			surfaceMesh.GetComponent<MeshRenderer>().material = Resources.Load("Materials/surfaceMaterial") as Material;
			surfaceMesh.transform.parent = base.transform;
			surfaceMesh.GetComponent<MeshRenderer>().enabled = !baseScript.hideSurfaces;
			surfaceMesh.layer = baseScript.sLayer;
		}
		surfaceMesh.hideFlags = HideFlags.None;
		if (surfaceMesh.GetComponent<MeshFilter>() == null)
		{
			surfaceMesh.AddComponent<MeshFilter>();
		}
		Mesh mesh;
		if (surfaceMesh.GetComponent<MeshFilter>().sharedMesh != null)
		{
			mesh = surfaceMesh.GetComponent<MeshFilter>().sharedMesh;
		}
		else
		{
			mesh = new Mesh();
			surfaceMesh.GetComponent<MeshFilter>().sharedMesh = mesh;
			if (surfaceMesh.GetComponent<MeshCollider>() == null)
			{
				surfaceMesh.AddComponent<MeshCollider>();
			}
			surfaceMesh.GetComponent<MeshCollider>().sharedMesh = mesh;
		}
		if (surfaceMesh.GetComponent<MeshCollider>() == null)
		{
			surfaceMesh.AddComponent<MeshCollider>();
			surfaceMesh.GetComponent<MeshCollider>().sharedMesh = mesh;
		}
		if (!terrainDeformation)
		{
			if (Application.isEditor && !Application.isPlaying)
			{
				UnityEngine.Object.DestroyImmediate(surfaceMesh);
			}
			else
			{
				UnityEngine.Object.Destroy(surfaceMesh);
			}
			return;
		}
		surfaceMesh.hideFlags = HideFlags.HideInHierarchy;
		surfaceMesh.layer = baseScript.sLayer;
		List<int> list2 = new List<int>();
		int num = 5;
		int num2 = 1;
		float num3 = 0f;
		int num4 = 0;
		bool flag2 = false;
		int num5 = 0;
		int num6 = 0;
		bool flag3 = false;
		for (int i = 0; i < h - 1; i += num2)
		{
			if (!doBridge[i])
			{
				num3 = ((i == 0) ? 0f : (doBridge[i + 1] ? 1f : ((!doBridge[i - 1]) ? 0f : 2f)));
				for (int j = 0; j < num - 1; j++)
				{
					int num7 = i * num + j;
					int num8 = i * num + j + 1;
					int num9 = (i + num2) * num + j;
					int num10 = (i + num2) * num + j + 1;
					if ((num3 == 2f && j == 3) || (num3 == 1f && j == 0))
					{
						if (surfaceVecs[num7] != surfaceVecs[num8])
						{
							list2.Add(num7);
							list2.Add(num9);
							list2.Add(num8);
						}
						if (surfaceVecs[num8] != surfaceVecs[num10])
						{
							list2.Add(num8);
							list2.Add(num9);
							list2.Add(num10);
						}
					}
					else if ((j == 0 && doLeftSurrounding[i + 1]) || (j >= num - 2 && doRightSurrounding[i + 1]) || (j > 0 && j < num - 2))
					{
						if (surfaceVecs[num10] != surfaceVecs[num8])
						{
							list2.Add(num7);
							list2.Add(num10);
							list2.Add(num8);
						}
						if (surfaceVecs[num9] != surfaceVecs[num7])
						{
							list2.Add(num9);
							list2.Add(num10);
							list2.Add(num7);
						}
					}
				}
			}
			if (!baseScript.vegetationStudio && !baseScript.vegetationStudioPro)
			{
				continue;
			}
			flag = false;
			if (i > 1)
			{
				if (doBridge[i] && !doBridge[i - 1])
				{
					flag = true;
				}
				if (!doBridge[i] && doBridge[i - 1])
				{
					flag = true;
				}
			}
			if (Vector3.Distance(a, soSplinePoints[i]) > 10f || flag)
			{
				Vector3 node = Vector3.Lerp(soSplinePointsLeft[i], soSplinePointsRight[i], 0.5f);
				float width = Vector3.Distance(soSplinePointsLeft[i], soSplinePointsRight[i]);
				flag3 = !doBridge[i];
				list.Add(new ERVSData(node, flag3, width, soSplinePointsLeft[i], soSplinePointsRight[i]));
				a = soSplinePoints[i];
			}
		}
		int count = surfaceVecs.Count;
		if (startPrefabScript == null && !doBridge[0] && !closedTrack)
		{
			InterpolateSurfaces(ref surfaceVecs, ref uvs, ref list2, firstDir, count, 0, indent, surrounding);
		}
		if (endPrefabScript == null && !doBridge[h - 2] && !closedTrack)
		{
			InterpolateSurfaces(ref surfaceVecs, ref uvs, ref list2, lastDir, count, 1, indent, surrounding);
		}
		surfaceMesh.GetComponent<MeshCollider>().sharedMesh = null;
		for (int k = 0; k < surfaceVecs.Count; k++)
		{
			if (surfaceVecs[k].x != surfaceVecs[k].x)
			{
				Vector3 value = surfaceVecs[k - 1];
				value += new Vector3(0.2f, 0.2f, 0.2f);
				surfaceVecs[k] = value;
			}
		}
		mesh.Clear();
		mesh.vertices = surfaceVecs.ToArray();
		mesh.uv = uvs.ToArray();
		mesh.tangents = new Vector4[surfaceVecs.Count];
		mesh.triangles = list2.ToArray();
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();
		surfaceMesh.GetComponent<MeshCollider>().sharedMesh = null;
		surfaceMesh.GetComponent<MeshCollider>().sharedMesh = mesh;
		if (surfaceMesh.GetComponent<MeshCollider>().sharedMesh == null)
		{
			UnityEngine.Object.DestroyImmediate(surfaceMesh.GetComponent<MeshCollider>());
			surfaceMesh.AddComponent<MeshCollider>();
			if (surfaceMesh.GetComponent<MeshCollider>().sharedMesh == null)
			{
				UnityEngine.Debug.LogWarning("EasyRoads3Dv3 Warning: No mesh assigned to the surface mesh Collider");
			}
		}
		if (baseScript.hideSurfaces)
		{
			surfaceMesh.GetComponent<MeshCollider>().enabled = false;
			surfaceMesh.SetActive(value: false);
			surfaceMesh.SetActive(value: true);
		}
		else
		{
			if ((bool)surfaceMesh.GetComponent<MeshRenderer>())
			{
				surfaceMesh.GetComponent<MeshRenderer>().enabled = true;
			}
			if ((bool)surfaceMesh.GetComponent<MeshCollider>())
			{
				surfaceMesh.GetComponent<MeshCollider>().enabled = true;
			}
		}
		testmesh = mesh;
		if ((!baseScript.vegetationStudio && !baseScript.vegetationStudioPro) || !baseScript.vegetationStudioActive)
		{
			return;
		}
		Vector3 node2 = Vector3.Lerp(soSplinePointsLeft[h - 1], soSplinePointsRight[h - 1], 0.5f);
		float num11 = Vector3.Distance(soSplinePointsLeft[h - 1], soSplinePointsRight[h - 1]);
		list.Add(new ERVSData(node2, !doBridge[h - 1], num11, soSplinePointsLeft[h - 1], soSplinePointsRight[h - 1]));
		if (startPrefabScript != null && !doBridge[0])
		{
			Vector3 normalized = (soSplinePointsLeft[0] - soSplinePointsRight[0]).normalized;
			Vector3 leftPosition = startPrefabScript.transform.position + normalized * 0.5f * list[0].width;
			Vector3 rightPosition = startPrefabScript.transform.position + -normalized * 0.5f * list[0].width;
			list.Insert(0, new ERVSData(startPrefabScript.transform.position, active: true, list[0].width, leftPosition, rightPosition));
		}
		if (endPrefabScript != null && !doBridge[h - 1])
		{
			Vector3 normalized2 = (soSplinePointsLeft[h - 1] - soSplinePointsRight[h - 1]).normalized;
			Vector3 leftPosition2 = endPrefabScript.transform.position + normalized2 * 0.5f * num11;
			Vector3 rightPosition2 = endPrefabScript.transform.position + -normalized2 * 0.5f * num11;
			list.Add(new ERVSData(endPrefabScript.transform.position, active: true, num11, leftPosition2, rightPosition2));
		}
		object[] array = null;
		if (vegetationStudioMaskLineActive)
		{
			array = new object[7]
			{
				base.gameObject,
				list.ToArray(),
				2f * vegetationStudioGrassPerimeter,
				2f * vegetationStudioPlantPerimeter,
				2f * vegetationStudioTreePerimeter,
				2f * vegetationStudioObjectPerimeter,
				2f * vegetationStudioLargeObjectPerimeter
			};
		}
		else if (vegetationStudioBiomeMaskActive)
		{
			array = new object[5]
			{
				base.gameObject,
				list.ToArray(),
				vegetationStudioBiomeMaskDistance,
				vegetationStudioBiomeMaskBlendDistance,
				vegetationStudioBiomeMaskNoiseScale
			};
		}
		if (vegetationStudioMaskLineActive && array != null)
		{
			if ((object)baseScript.upMethod != null)
			{
				baseScript.upMethod.Invoke(null, array);
			}
		}
		else if (vegetationStudioBiomeMaskActive && array != null && (object)baseScript.upBiomeMethod != null)
		{
			baseScript.upBiomeMethod.Invoke(null, array);
		}
	}

	public void InterpolateSurfaces(ref List<Vector3> surfaceVecs, ref List<Vector2> uvs, ref List<int> tris, Vector3 dir, int vecCount, int startEnd, float indent, float surrounding)
	{
		int count = surfaceVecs.Count;
		int num = 0;
		if (startEnd == 0)
		{
			dir *= -1f;
			num = 0;
		}
		else
		{
			num = vecCount - 5;
		}
		surfaceVecs.Add(surfaceVecs[num]);
		surfaceVecs.Add(surfaceVecs[num + 1]);
		surfaceVecs.Add(surfaceVecs[num + 2]);
		surfaceVecs.Add(surfaceVecs[num + 3]);
		surfaceVecs.Add(surfaceVecs[num + 4]);
		uvs.Add(new Vector2(0f, 0f));
		uvs.Add(new Vector2(0f, 1f));
		uvs.Add(new Vector2(0f, 1f));
		uvs.Add(new Vector2(0f, 1f));
		uvs.Add(new Vector2(0f, 0f));
		surfaceVecs.Add(surfaceVecs[num] + dir * indent);
		surfaceVecs.Add(surfaceVecs[num + 1] + dir * indent);
		surfaceVecs.Add(surfaceVecs[num + 2] + dir * indent);
		surfaceVecs.Add(surfaceVecs[num + 3] + dir * indent);
		surfaceVecs.Add(surfaceVecs[num + 4] + dir * indent);
		uvs.Add(new Vector2(0f, 0f));
		uvs.Add(new Vector2(0f, 1f));
		uvs.Add(new Vector2(0f, 1f));
		uvs.Add(new Vector2(0f, 1f));
		uvs.Add(new Vector2(0f, 0f));
		Vector3 pos = surfaceVecs[num] + dir * (indent + surrounding);
		baseScript.OCDDQOCDCO(ref pos);
		surfaceVecs.Add(pos);
		pos = surfaceVecs[num + 1] + dir * (indent + surrounding);
		baseScript.OCDDQOCDCO(ref pos);
		surfaceVecs.Add(pos);
		pos = surfaceVecs[num + 2] + dir * (indent + surrounding);
		baseScript.OCDDQOCDCO(ref pos);
		surfaceVecs.Add(pos);
		pos = surfaceVecs[num + 3] + dir * (indent + surrounding);
		baseScript.OCDDQOCDCO(ref pos);
		surfaceVecs.Add(pos);
		pos = surfaceVecs[num + 4] + dir * (indent + surrounding);
		baseScript.OCDDQOCDCO(ref pos);
		surfaceVecs.Add(pos);
		uvs.Add(new Vector2(0f, 0f));
		uvs.Add(new Vector2(0f, 0f));
		uvs.Add(new Vector2(0f, 0f));
		uvs.Add(new Vector2(0f, 0f));
		uvs.Add(new Vector2(0f, 0f));
		int count2 = tris.Count;
		int num2 = 5;
		int num3 = 1;
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < num2 - 1; j++)
			{
				if (num == 0)
				{
					tris.Add(count + i * num2 + j);
					tris.Add(count + i * num2 + j + 1);
					tris.Add(count + (i + num3) * num2 + j + 1);
					tris.Add(count + (i + num3) * num2 + j);
					tris.Add(count + i * num2 + j);
					tris.Add(count + (i + num3) * num2 + j + 1);
				}
				else
				{
					tris.Add(count + i * num2 + j);
					tris.Add(count + (i + num3) * num2 + j + 1);
					tris.Add(count + i * num2 + j + 1);
					tris.Add(count + (i + num3) * num2 + j);
					tris.Add(count + (i + num3) * num2 + j + 1);
					tris.Add(count + i * num2 + j);
				}
			}
		}
	}

	public void OOCCDCDCQD()
	{
		if (!baseScript.aiTraffic)
		{
			return;
		}
		laneData.Clear();
		QDQDOOQQDQODD roadTypeElByID = QDQDOOQQDQODD.GetRoadTypeElByID(baseScript.roadTypes, roadType);
		if (roadTypeElByID == null || !roadTypeElByID.roadShapeData.isset)
		{
			return;
		}
		List<Vector3> list = new List<Vector3>();
		float num = roadTypeElByID.roadWidth * 0.5f;
		for (int i = 0; i < roadTypeElByID.roadShapeData.lanes.Count; i++)
		{
			ERLaneData eRLaneData = ERLaneData.CreateInstance();
			list.Clear();
			for (int j = 0; j < soSplinePoints.Count; j++)
			{
				Vector3 normalized = (soSplinePointsRight[j] - soSplinePoints[j]).normalized;
				Vector3 item = soSplinePoints[j] + normalized * roadTypeElByID.roadShapeData.lanes[i].position * num;
				list.Add(item);
			}
			if ((roadTypeElByID.roadShapeData.lanes[i].direction == ERLaneDirection.Left && baseScript.rightHandDriving == 1) || (roadTypeElByID.roadShapeData.lanes[i].direction == ERLaneDirection.Right && baseScript.rightHandDriving == 0))
			{
				list.Reverse();
			}
			eRLaneData.points = list.ToArray();
			eRLaneData.direction = roadTypeElByID.roadShapeData.lanes[i].direction;
			eRLaneData.laneIndex = roadTypeElByID.roadShapeData.lanes[i].laneIndex;
			laneData.Add(eRLaneData);
		}
	}

	public List<Vector3> OQDDOOOOQD(List<ERMarkerExt> markersExt, float faceDist, bool ignorePrefabAlignment, ref List<float> tValues, ref List<float> markerDistances, bool forceAutoRotate, ref List<float> rotationArray, ref List<float> bendAngles)
	{
		if (testPoints != null)
		{
			testPoints.Clear();
		}
		List<Vector3> list = new List<Vector3>();
		if (markersExt[0].oldPosition == Vector3.zero)
		{
			for (int i = 0; i < markersExt.Count; i++)
			{
				markersExt[i].oldPosition = markersExt[i].position;
			}
		}
		if (!baseScript.localGridActive && !baseScript.globalGridActive)
		{
			for (int j = 1; j < markersExt.Count - 2; j++)
			{
				if (markersExt[j].controlType == 3)
				{
					bool flag = true;
					if (!(markersExt[j].oldPosition != markersExt[j].position) && !(markersExt[j + 1].oldPosition != markersExt[j + 1].position) && !(markersExt[j + 2].oldPosition != markersExt[j + 2].position))
					{
					}
				}
			}
		}
		bool flag2 = false;
		bool flag3 = false;
		if (forceAutoRotate)
		{
			if (nodeWithinRange == 0)
			{
				flag2 = true;
			}
			else
			{
				flag3 = true;
			}
		}
		startDir = (endDir = Vector3.zero);
		tmpMarkersExt.Clear();
		tmpMarkersExt.AddRange(markersExt);
		if (closedTrack)
		{
			tmpMarkersExt.Add(tmpMarkersExt[0]);
		}
		List<Vector3> tmpNodes = new List<Vector3>();
		List<float> list2 = new List<float>();
		for (int k = 0; k < tmpMarkersExt.Count; k++)
		{
			tmpNodes.Add(tmpMarkersExt[k].position);
			if (tmpMarkersExt[k].splineStrength == 0f)
			{
				tmpMarkersExt[k].splineStrength = 0.5f;
			}
			list2.Add(tmpMarkersExt[k].splineStrength);
		}
		if (tmpNodes.Count != list2.Count)
		{
			UnityEngine.Debug.Log("array lengths " + tmpNodes.Count + " " + list2.Count);
		}
		float num = 0f;
		float num2 = 1f;
		bool flag4 = false;
		bool flag5 = false;
		Vector3 vector = Vector3.zero;
		Vector3 vector2 = Vector3.zero;
		bool flag6 = false;
		if (startPrefabScript == null)
		{
			if (closedTrack && tmpMarkersExt[0].controlType == 0)
			{
				tmpNodes.Insert(0, tmpNodes[tmpNodes.Count - 2]);
				list2.Insert(0, list2[0]);
			}
			else
			{
				tmpNodes.Insert(0, tmpNodes[0]);
				list2.Insert(0, list2[0]);
			}
		}
		else
		{
			if ((!ignorePrefabAlignment && startPrefabScript.crossingElements[startConnectionSegment].rotationPriority) || flag2)
			{
				tmpNodes.Insert(0, tmpNodes[0]);
				list2.Insert(0, list2[0]);
				Vector3 vector3 = tmpNodes[2];
				if (tmpNodes.Count >= 4)
				{
					vector3 = tmpNodes[3];
				}
				Vector3 v = OODODQQQCD(tmpNodes[0], tmpNodes[1], tmpNodes[2], vector3, 0.5f, 0.5f);
				startPrefabScript.OOCQCCQDOQ(tmpNodes[0], v, startConnectionSegment, this);
			}
			else
			{
				if (startPrefabScript.isFlexConnector)
				{
					if (endPrefabScript != null && endPrefabScript.isFlexConnector)
					{
						if (tmpNodes.Count > 2)
						{
							tmpNodes[tmpNodes.Count - 1] = endPrefabScript.crossingsScript.OOQCQDQCOO(endConnectionSegment, tmpNodes[tmpNodes.Count - 1], tmpNodes[tmpNodes.Count - 2], tmpNodes[tmpNodes.Count - 3], update: false);
						}
						else
						{
							tmpNodes[tmpNodes.Count - 1] = endPrefabScript.crossingsScript.OOQCQDQCOO(endConnectionSegment, tmpNodes[tmpNodes.Count - 1], tmpNodes[tmpNodes.Count - 2], tmpNodes[tmpNodes.Count - 2], update: false);
						}
						flag6 = true;
					}
					if (tmpNodes.Count > 2)
					{
						tmpNodes[0] = startPrefabScript.crossingsScript.OOQCQDQCOO(startConnectionSegment, tmpNodes[0], tmpNodes[1], tmpNodes[2], update: true);
					}
					else
					{
						tmpNodes[0] = startPrefabScript.crossingsScript.OOQCQDQCOO(startConnectionSegment, tmpNodes[0], tmpNodes[1], tmpNodes[1], update: true);
					}
				}
				if (startPrefabScript.isIConnector)
				{
					ERIConnector component = startPrefabScript.gameObject.GetComponent<ERIConnector>();
					if (!ignorePrefabAlignment)
					{
						component.OCQOQCDCQC(this);
					}
					tmpNodes[0] = startPrefabScript.transform.position;
					Vector3 item = startPrefabScript.transform.position;
					int index = 1;
					if (startConnectionSegment == 1)
					{
						index = 0;
					}
					if (startPrefabScript.crossingElements[index].connectedRoad != null)
					{
						ERModularRoad connectedRoad = startPrefabScript.crossingElements[index].connectedRoad;
						if (connectedRoad.markersExt.Count > 0)
						{
							item = ((startPrefabScript.crossingElements[index].connectedMarker != 0) ? connectedRoad.markersExt[connectedRoad.markersExt.Count - 2].position : connectedRoad.markersExt[1].position);
						}
					}
					tmpNodes.Insert(0, item);
					num = ((!(component.road1 == this)) ? component.t2 : component.t1);
				}
				else
				{
					Vector3 zero = Vector3.zero;
					OCQOQOOOCO.OQCQQDCDQO(this, ref tmpNodes, list2, startPrefabScript, startConnectionSegment, ref startDir, ref zero, 0);
					if (startPrefabScript.isFlexConnector)
					{
						tmpNodes[0] = startPrefabScript.transform.TransformPoint(startPrefabScript.crossingElements[startConnectionSegment].controlPointV3);
						flag4 = true;
						vector = (startPrefabScript.transform.TransformPoint(startPrefabScript.crossingElements[startConnectionSegment].centerPoint) - tmpNodes[0]).normalized;
					}
				}
			}
			if (startPrefabScript.tStraightBending)
			{
				tCrossingConnected = true;
			}
		}
		if (endPrefabScript == null)
		{
			if (closedTrack && tmpMarkersExt[0].controlType == 0)
			{
				tmpNodes.Add(tmpNodes[2]);
				list2.Add(list2[2]);
			}
			else if (closedTrack && (tmpMarkersExt[0].controlType == 1 || tmpMarkersExt[0].controlType == 2))
			{
				Vector3 endCP = Vector3.zero;
				OOCCQCCDQC(ref endCP, tmpNodes[tmpNodes.Count - 2], tmpNodes[tmpNodes.Count - 1], tmpNodes[2]);
				tmpNodes.Add(endCP);
				list2.Add(list2[list2.Count - 1]);
			}
			else
			{
				tmpNodes.Add(tmpNodes[tmpNodes.Count - 1]);
				list2.Add(list2[list2.Count - 1]);
			}
		}
		else
		{
			if (endPrefabScript.isFlexConnector)
			{
				if (!flag6)
				{
					if (tmpNodes.Count > 2)
					{
						tmpNodes[tmpNodes.Count - 1] = endPrefabScript.crossingsScript.OOQCQDQCOO(endConnectionSegment, tmpNodes[tmpNodes.Count - 1], tmpNodes[tmpNodes.Count - 2], tmpNodes[tmpNodes.Count - 3], update: true);
					}
					else
					{
						tmpNodes[tmpNodes.Count - 1] = endPrefabScript.crossingsScript.OOQCQDQCOO(startConnectionSegment, tmpNodes[tmpNodes.Count - 1], tmpNodes[tmpNodes.Count - 2], tmpNodes[tmpNodes.Count - 2], update: true);
					}
				}
				else
				{
					endPrefabScript.crossingsScript.ODOCCDCQOC();
				}
			}
			if ((!ignorePrefabAlignment && endPrefabScript.crossingElements[endConnectionSegment].rotationPriority) || flag3)
			{
				tmpNodes.Add(tmpNodes[tmpNodes.Count - 1]);
				list2.Add(list2[list2.Count - 1]);
				Vector3 p = tmpNodes[tmpNodes.Count - 3];
				if (tmpNodes.Count >= 4)
				{
					p = tmpNodes[tmpNodes.Count - 4];
				}
				Vector3 v2 = OODODQQQCD(p, tmpNodes[tmpNodes.Count - 3], tmpNodes[tmpNodes.Count - 2], tmpNodes[tmpNodes.Count - 1], 0.5f, 0.5f);
				endPrefabScript.OOCQCCQDOQ(tmpNodes[tmpNodes.Count - 1], v2, endConnectionSegment, this);
			}
			else if (endPrefabScript.isIConnector)
			{
				ERIConnector component2 = endPrefabScript.gameObject.GetComponent<ERIConnector>();
				if (!ignorePrefabAlignment)
				{
					component2.OCQOQCDCQC(this);
				}
				tmpNodes[tmpNodes.Count - 1] = endPrefabScript.transform.position;
				Vector3 item2 = endPrefabScript.transform.position;
				int index2 = 1;
				if (endConnectionSegment == 1)
				{
					index2 = 0;
				}
				if (endPrefabScript.crossingElements[index2].connectedRoad != null)
				{
					ERModularRoad connectedRoad2 = endPrefabScript.crossingElements[index2].connectedRoad;
					if (connectedRoad2.markersExt.Count > 0)
					{
						item2 = ((endPrefabScript.crossingElements[index2].connectedMarker != 0) ? connectedRoad2.markersExt[connectedRoad2.markersExt.Count - 2].position : connectedRoad2.markersExt[1].position);
					}
				}
				tmpNodes.Add(item2);
				num2 = ((!(component2.road1 == this)) ? (1f - component2.t2) : (1f - component2.t1));
				if (num2 < 0f)
				{
					num2 = 0.2f;
				}
			}
			else
			{
				OCQOQOOOCO.OQCQQDCDQO(this, ref tmpNodes, list2, endPrefabScript, endConnectionSegment, ref endDir, ref lastForward, 1);
				if (endPrefabScript.isFlexConnector)
				{
					tmpNodes[tmpNodes.Count - 1] = endPrefabScript.transform.TransformPoint(endPrefabScript.crossingElements[endConnectionSegment].controlPointV3);
					flag5 = true;
					vector2 = (endPrefabScript.transform.TransformPoint(endPrefabScript.crossingElements[endConnectionSegment].centerPoint) - tmpNodes[tmpNodes.Count - 1]).normalized;
				}
			}
			if (endPrefabScript.tStraightBending)
			{
				tCrossingConnected = true;
			}
		}
		Vector3[] array = tmpNodes.ToArray();
		float num3 = 0f;
		Vector3 vector4 = array[1];
		Vector3 v3 = Vector3.zero;
		Vector3 circleDir = Vector3.zero;
		bool flag7 = false;
		totalDistance = 0f;
		int num4 = 0;
		Vector3 startCP = array[0];
		Vector3 endCP2 = array[3];
		Vector3 lastHeightAdjustCP = Vector3.zero;
		if (tmpMarkersExt.Count == 0)
		{
			return null;
		}
		nodeSplinePoint.Clear();
		nodeSplinePoint.Add(0);
		if (tmpMarkersExt[1].controlType == 3 && tmpMarkersExt.Count > 2)
		{
			Vector3 normalized = (array[2] - array[1]).normalized;
			endCP2 = array[2] + normalized * Vector3.Distance(array[2], array[3]);
			endCP2.y = array[3].y;
		}
		markerDistances.Add(0f);
		segPoints.Clear();
		testPoints.Clear();
		List<float> list3 = new List<float>();
		List<Vector3> vecs = new List<Vector3>();
		float num5 = 0f;
		int num6 = 0;
		Vector3 b = vector4;
		b.y = 0f;
		Vector3 to = new Vector3(0f, 50f, 0f);
		float xzDistance = 0f;
		Vector3 vector6;
		Vector3 vector5 = (vector6 = Vector3.zero);
		float num7 = 0f;
		float num8 = 0f;
		Vector3 zero2 = Vector3.zero;
		bool flag8 = false;
		bool flag9 = false;
		float randomYDistanceStart = 0f;
		float randomYDistanceEnd = 0f;
		float randomYDistanceMiddle = 0f;
		Vector3 randomYDistanceV = Vector3.zero;
		float num9 = 0f;
		float currentRandomYDistance = 0f;
		float randomRotationStart = 0f;
		float randomRotationEnd = 0f;
		float randomRotationMiddle = 0f;
		Vector3 randomRotationV = Vector3.zero;
		float currentRandomRotation = 0f;
		float num10 = 0f;
		float num11 = faceDistance;
		for (int l = 1; l < array.Length - 2; l++)
		{
			float totalDist = 0f;
			markersExt[l - 1].startSplinePoint = list.Count;
			markersExt[l - 1].startDistance = totalDistance;
			if (l > 1)
			{
				if (l > 2)
				{
					markersExt[l - 2].totalDistance = totalDistance - markersExt[l - 2].startDistance;
				}
				else
				{
					markersExt[l - 2].totalDistance = totalDistance;
				}
				if (markersExt[l - 2].totalDistance < 1000f)
				{
					markersExt[l - 2].totalDistanceString = markersExt[l - 2].totalDistance.ToString("N2") + " m";
				}
				else
				{
					markersExt[l - 2].totalDistanceString = (markersExt[l - 2].totalDistance / 1000f).ToString("N3") + " km";
				}
				Vector3 vector7 = new Vector3(0f, Mathf.Abs(markersExt[l - 2].position.y - markersExt[l - 1].position.y), xzDistance);
				float num12 = 90f - Vector3.Angle(vector7, to);
				if (num12 > 10f)
				{
					markersExt[l - 2].angleString = Mathf.Round(num12).ToString();
				}
				else
				{
					markersExt[l - 2].angleString = num12.ToString("N2");
				}
				float num13 = Mathf.Abs(markersExt[l - 2].position.y - markersExt[l - 1].position.y);
				float num14 = Vector3.Distance(new Vector3(markersExt[l - 2].position.x, 0f, markersExt[l - 2].position.z), new Vector3(markersExt[l - 1].position.x, 0f, markersExt[l - 1].position.z));
				markersExt[l - 2].gradeString = (num13 / num14 * 100f).ToString("N2");
				if (list.Count > 2)
				{
					vector5 = (list[list.Count - 1] - list[list.Count - 2]).normalized;
				}
			}
			list3.Clear();
			vecs.Clear();
			xzDistance = 0f;
			num9 = totalDistance + Vector3.Distance(array[l], array[l + 1]);
			if (tmpMarkersExt[l - 1].controlType == 0)
			{
				float num15 = Vector3.Distance(array[l], array[l + 1]);
				float num16 = 0.2f / num15;
				if (num3 > 0f)
				{
					num3 -= 1f;
				}
				num3 = 0f;
				bool flag10 = false;
				if (l > 1 && (tmpMarkersExt[l - 2].controlType == 1 || tmpMarkersExt[l - 2].controlType == 2))
				{
					flag10 = true;
				}
				if (l == 1)
				{
					num3 = num;
				}
				float num17 = ((l != array.Length - 3) ? 1f : num2);
				float num18 = 0.5f;
				for (float num19 = num3; num19 < num17; num19 += num16)
				{
					flag7 = false;
					flag8 = false;
					if (num19 + num16 > 1f && l == array.Length - 3 && !closedTrack)
					{
						flag7 = true;
						flag8 = true;
						num19 = 1f;
					}
					Vector3 pos = OODODQQQCD(startCP, array[l], array[l + 1], endCP2, num19, list2[l]);
					if (num6 == 3)
					{
						vector4 = pos;
						b = vector4;
						b.y = 0f;
						num6 = 0;
					}
					num7 = Vector3.Distance(vector4, pos);
					num8 = Vector3.Distance(pos, array[l + 1]);
					if (vecs.Count > 0 || list.Count > 0)
					{
						zero2 = ((vecs.Count <= 0) ? list[list.Count - 1] : vecs[vecs.Count - 1]);
						vector6 = (pos - zero2).normalized;
						if (vector5 != Vector3.zero)
						{
							num10 = Vector3.Angle(vector5, vector6);
							if (num10 > angleTreshold && num7 >= 1f && (double)num8 > 1.5)
							{
								flag7 = true;
								flag8 = true;
							}
						}
					}
					if (snapToTerrain)
					{
						baseScript.OCDDQOCDCO(ref pos);
					}
					if (num19 + num16 + 0.1f > num17 && num8 < 0.5f * num11 && !flag8 && !flag9)
					{
						pos = array[l + 1];
						flag7 = true;
						num19 = 1f;
					}
					if (num19 + num16 > num17)
					{
						pos = array[l + 1];
						flag7 = true;
						num19 = 1f;
					}
					if (!(Vector3.Distance(vector4, pos) > faceDist || flag7) && (l != 1 || num19 != 0f))
					{
						continue;
					}
					num15 = Vector3.Distance(vector4, pos);
					totalDistance += num15;
					totalDist += num15;
					Vector3 vector8 = pos;
					vector8.y = 0f;
					xzDistance += Vector3.Distance(vector8, b);
					vector4 = pos;
					v3 = pos;
					b = vector8;
					flag9 = flag8;
					if (tmpMarkersExt[l - 1].randomMinYPosition != 0f || tmpMarkersExt[l - 1].randomMaxYPosition != 0f || tmpMarkersExt[l - 1].randomMinRotation != 0f || tmpMarkersExt[l - 1].randomMaxRotation != 0f)
					{
						RoadSmoothness(totalDistance, tmpMarkersExt[l - 1], num9, ref randomYDistanceStart, ref randomYDistanceEnd, ref randomYDistanceMiddle, ref randomYDistanceV, ref v3, ref currentRandomYDistance, ref randomRotationStart, ref randomRotationEnd, ref randomRotationMiddle, ref randomRotationV, ref currentRandomRotation, ref rotationArray);
					}
					else
					{
						rotationArray.Add(0f);
					}
					if (num15 > 5f)
					{
						bendAngles.Add(num10);
					}
					else
					{
						bendAngles.Add(num10 / num15 * 5f);
					}
					if (flag10)
					{
						if (bendAngles.Count > 1)
						{
							bendAngles[bendAngles.Count - 2] = bendAngles[bendAngles.Count - 1];
						}
						flag10 = false;
					}
					vecs.Add(v3);
					list3.Add(num19);
					if (flag7)
					{
						nodeSplinePoint.Add(num4);
					}
					num4++;
					vector5 = vector6;
				}
				num6 = 0;
			}
			else if (tmpMarkersExt[l - 1].controlType == 1 || tmpMarkersExt[l - 1].controlType == 2)
			{
				if (l == 1)
				{
					v3 = array[l];
				}
				Vector3 normalized2 = (array[l + 1] - array[l]).normalized;
				totalDist = Vector3.Distance(array[l + 1], array[l]);
				b = v3;
				b.y = 0f;
				Vector3 vector8 = array[l + 1];
				vector8.y = 0f;
				xzDistance += Vector3.Distance(vector8, b);
				float num15 = faceDist;
				if (l == 1)
				{
					num15 = 0f;
				}
				List<float> list4 = new List<float>();
				for (; num15 < totalDist - faceDist; num15 += faceDist)
				{
					currentRandomYDistance = 0f;
					Vector3 a = v3 + normalized2 * num15;
					if (Vector3.Distance(a, array[l + 1]) > 0.5f * faceDist)
					{
						Vector3 pos2 = v3 + normalized2 * num15;
						if (snapToTerrain)
						{
							baseScript.OCDDQOCDCO(ref pos2);
						}
						if (tmpMarkersExt[l - 1].randomMinYPosition != 0f || tmpMarkersExt[l - 1].randomMaxYPosition != 0f || tmpMarkersExt[l - 1].randomMinRotation != 0f || tmpMarkersExt[l - 1].randomMaxRotation != 0f)
						{
							RoadSmoothness(totalDistance + num15, tmpMarkersExt[l - 1], num9, ref randomYDistanceStart, ref randomYDistanceEnd, ref randomYDistanceMiddle, ref randomYDistanceV, ref pos2, ref currentRandomYDistance, ref randomRotationStart, ref randomRotationEnd, ref randomRotationMiddle, ref randomRotationV, ref currentRandomRotation, ref rotationArray);
						}
						else
						{
							rotationArray.Add(0f);
						}
						vecs.Add(pos2);
						list4.Add(currentRandomYDistance);
						bendAngles.Add(0f);
						num5 = num15 / totalDist;
						list3.Add(num5);
					}
				}
				if (!snapToTerrain && tmpMarkersExt[l - 1].controlType == 1)
				{
					for (int m = 0; m < list3.Count; m++)
					{
						Vector3 a = OODODQQQCD(array[l - 1], array[l], array[l + 1], array[l + 2], list3[m], 0.5f);
						Vector3 value = vecs[m];
						value.y = a.y + list4[m];
						vecs[m] = value;
					}
				}
				if (vecs.Count == 0)
				{
					vecs.Add(array[l + 1]);
					totalDist = Vector3.Distance(v3, array[l + 1]);
					list3.Add(1f);
					rotationArray.Add(0f);
					bendAngles.Add(0f);
				}
				if (vecs.Count > 0 && vecs[vecs.Count - 1] != array[l + 1])
				{
					if (Vector3.Distance(vecs[vecs.Count - 1], array[l + 1]) < 0.5f * faceDist)
					{
						vecs[vecs.Count - 1] = array[l + 1];
						list3[list3.Count - 1] = 1f;
					}
					else
					{
						vecs.Add(array[l + 1]);
						totalDist += Vector3.Distance(vecs[vecs.Count - 1], array[l + 1]);
						list3.Add(1f);
						rotationArray.Add(0f);
					}
				}
				num4 += vecs.Count;
				vector4 = (v3 = vecs[vecs.Count - 1]);
				totalDistance += totalDist;
				nodeSplinePoint.Add(num4);
				num6 = tmpMarkersExt[l - 1].controlType;
			}
			else if (tmpMarkersExt[l - 1].controlType == 3)
			{
				float radius = 0f;
				if (l - 1 < tmpMarkersExt.Count - 2 || closedTrack || endPrefabScript != null)
				{
					OCQOQOOOCO.OCOCQCDDCD(ref list, this, l, ref vecs, ref list3, ref totalDist, 0, ref xzDistance, getDistance: false, ref radius, ref bendAngles);
				}
				else
				{
					OCQOQOOOCO.ODOCQOODDO(ref list, this, l, ref vecs, ref list3, ref totalDist, 0, ref xzDistance, getDistance: false, ref bendAngles);
				}
				tmpMarkersExt[l - 1].radius = radius;
				float num20 = 0f;
				for (int n = 0; n < list3.Count; n++)
				{
					Vector3 pos3 = vecs[n];
					if (!snapToTerrain)
					{
						pos3.y = OODODQQQCD(array[l - 1], array[l], array[l + 1], array[l + 2], list3[n], 0.5f).y;
						vecs[n] = pos3;
					}
					else
					{
						baseScript.OCDDQOCDCO(ref pos3);
					}
					if (n > 0)
					{
						if (tmpMarkersExt[l - 1].randomMinYPosition != 0f || tmpMarkersExt[l - 1].randomMaxYPosition != 0f || tmpMarkersExt[l - 1].randomMinRotation != 0f || tmpMarkersExt[l - 1].randomMaxRotation != 0f)
						{
							num20 += Vector3.Distance(vecs[n - 1], vecs[n]);
							RoadSmoothness(totalDistance + num20, tmpMarkersExt[l - 1], num9, ref randomYDistanceStart, ref randomYDistanceEnd, ref randomYDistanceMiddle, ref randomYDistanceV, ref pos3, ref currentRandomYDistance, ref randomRotationStart, ref randomRotationEnd, ref randomRotationMiddle, ref randomRotationV, ref currentRandomRotation, ref rotationArray);
						}
						else
						{
							rotationArray.Add(0f);
						}
					}
					else
					{
						rotationArray.Add(0f);
					}
					vecs[n] = pos3;
				}
				if (list3.Count > 0)
				{
					if (list3[list3.Count - 1] > 1f)
					{
						list3[list3.Count - 1] = 1f;
						vecs[vecs.Count - 1] = array[l + 1];
					}
					else if (vecs[vecs.Count - 1] != array[l + 1])
					{
						if (Vector3.Distance(vecs[vecs.Count - 1], array[l + 1]) < 0.5f * faceDist)
						{
							vecs[vecs.Count - 1] = array[l + 1];
							list3[list3.Count - 1] = 1f;
						}
						else
						{
							vecs.Add(array[l + 1]);
							totalDist += Vector3.Distance(vecs[vecs.Count - 1], array[l + 1]);
							list3.Add(1f);
							rotationArray.Add(0f);
						}
					}
				}
				else
				{
					vecs.Add(array[l + 1]);
					totalDist += Vector3.Distance(array[l], array[l + 1]);
					list3.Add(1f);
					rotationArray.Add(0f);
				}
				num4 += vecs.Count;
				v3 = vecs[vecs.Count - 1];
				if (vecs.Count >= 2)
				{
					circleDir = (vecs[vecs.Count - 2] - vecs[vecs.Count - 1]).normalized;
				}
				totalDistance += totalDist;
				nodeSplinePoint.Add(num4);
				b = v3;
				b.y = 0f;
				float num21 = 0f;
				if (list.Count > 0)
				{
					num21 = (float)list.Count - (float)markersExt[l - 2].startSplinePoint;
					float num22 = markerDistances[markerDistances.Count - 1];
					if (markerDistances.Count > 1)
					{
						num22 -= markerDistances[markerDistances.Count - 2];
					}
					Vector3 normalized3 = (list[list.Count - 1] - vecs[0]).normalized;
					Vector3 vector9 = list[list.Count - 1];
					float num23 = num22 / num21 * 1f;
					Vector3 b2 = list[list.Count - 1];
					float num24 = 0f;
					int count = list.Count;
					for (int num25 = 1; (float)num25 <= num21; num25++)
					{
						if (count - 1 - num25 >= 0)
						{
							vector9 += normalized3 * num23;
							Vector3 vector10 = list[list.Count - 1 - num25];
							num24 += Vector3.Distance(vector10, b2);
							float f = num24 / num22;
							vector10.y = Mathf.Lerp(vector9.y, vector10.y, Mathf.Sqrt(f));
							list[list.Count - 1 - num25] = vector10;
							b2 = vector10;
						}
					}
				}
				num6 = 3;
			}
			else if (tmpMarkersExt[l - 1].controlType == 4)
			{
				vecs = tmpMarkersExt[l - 1].customPoints;
				totalDist = 0f;
				List<float> list5 = new List<float>();
				list5.Add(0f);
				for (int num26 = 1; num26 < vecs.Count; num26++)
				{
					totalDist += Vector3.Distance(vecs[num26 - 1], vecs[num26]);
					list5.Add(totalDist);
				}
				totalDistance += totalDist;
				list3.Add(0f);
				rotationArray.Add(0f);
				for (int num27 = 0; num27 < vecs.Count; num27++)
				{
					list3.Add(list5[num27] / totalDist);
					rotationArray.Add(0f);
				}
				num6 = 4;
			}
			if (tmpMarkersExt[l - 1].followTerrainContours)
			{
				OCQOQOOOCO.OCDDCDDCQC(baseScript, ref vecs, list3, terrainContoursOffset, ref lastHeightAdjustCP, num11, totalDist, tmpMarkersExt[l].followTerrainContours, list, ref testPoints, ref rotationArray);
			}
			list.AddRange(vecs);
			tValues.AddRange(list3);
			OCQOOCCQDD(tmpMarkersExt, l, array, circleDir, totalDist, ref startCP, 0, list);
			if (array.Length > l + 3)
			{
				OQDOQOCDDQ(tmpMarkersExt, l, array, ref endCP2, 0);
			}
			markerDistances.Add(totalDistance);
			try
			{
				if (markersExt.Count > l)
				{
					markersExt[l].direction = (markersExt[l].direction1 = (list[list.Count - 1] - list[list.Count - 2]).normalized);
				}
				if (l > 1 && markersExt.Count > l && list.Count > markersExt[l - 1].startSplinePoint + 1 && markersExt[l - 1].controlType != 3)
				{
					Vector3 vector11 = list[markersExt[l - 1].startSplinePoint + 1];
					Vector3 vector12 = list[markersExt[l - 1].startSplinePoint];
					markersExt[l - 1].direction = (vector11 - vector12).normalized;
					if (l != markersExt.Count)
					{
						vector11.y = vector12.y;
					}
					markersExt[l - 1].direction1 = (vector11 - vector12).normalized;
				}
			}
			catch
			{
				if (markersExt.Count > 2)
				{
					UnityEngine.Debug.LogWarning("road error: " + base.gameObject.name + " please check the distances between markers, it seems two markers are located at the same position");
				}
				else if (list.Count <= 1)
				{
					UnityEngine.Debug.LogWarning("road error: only 1 spline point was extracted, please check the marker positions against the road resolution value");
				}
				else
				{
					UnityEngine.Debug.LogError("road error: " + list.Count);
				}
			}
			if (l == 1)
			{
				try
				{
					markersExt[l - 1].direction = (markersExt[l - 1].direction1 = (list[1] - list[0]).normalized);
				}
				catch
				{
					if (list.Count <= 1)
					{
						UnityEngine.Debug.LogWarning("EasyRoads3Dv3 warning: only 1 spline point was extracted, please check the marker positions against the road resolution value: " + base.gameObject.name);
					}
					else
					{
						UnityEngine.Debug.LogError("EasyRoads3Dv3 warning: road error: " + list.Count + " " + base.gameObject.name);
					}
				}
			}
			if (markersExt.Count > l)
			{
				markersExt[l].oldPosition = markersExt[l].position;
			}
		}
		if (!closedTrack)
		{
			markersExt[markersExt.Count - 1].startSplinePoint = list.Count;
			markersExt[markersExt.Count - 1].startDistance = totalDistance;
			markersExt[0].startSplinePoint = 0;
			markersExt[0].startDistance = 0f;
			if (markersExt.Count > 2)
			{
				markersExt[markersExt.Count - 2].totalDistance = totalDistance - markersExt[markersExt.Count - 2].startDistance;
				if (markersExt[markersExt.Count - 2].totalDistance < 1000f)
				{
					markersExt[markersExt.Count - 2].totalDistanceString = markersExt[markersExt.Count - 2].totalDistance.ToString("N2") + " m";
				}
				else
				{
					markersExt[markersExt.Count - 2].totalDistanceString = (markersExt[markersExt.Count - 2].totalDistance / 1000f).ToString("N3") + " km";
				}
				Vector3 vector7 = new Vector3(0f, Mathf.Abs(markersExt[markersExt.Count - 2].position.y - markersExt[markersExt.Count - 1].position.y), xzDistance);
				float num12 = 90f - Vector3.Angle(vector7, to);
				if (num12 > 10f)
				{
					markersExt[markersExt.Count - 2].angleString = Mathf.Round(num12).ToString();
				}
				else
				{
					markersExt[markersExt.Count - 2].angleString = num12.ToString("N2");
				}
				float num28 = Mathf.Abs(markersExt[markersExt.Count - 2].position.y - markersExt[markersExt.Count - 1].position.y);
				float num29 = Vector3.Distance(new Vector3(markersExt[markersExt.Count - 2].position.x, 0f, markersExt[markersExt.Count - 2].position.z), new Vector3(markersExt[markersExt.Count - 1].position.x, 0f, markersExt[markersExt.Count - 1].position.z));
				markersExt[markersExt.Count - 2].gradeString = (num28 / num29 * 100f).ToString("N2");
			}
		}
		else
		{
			markersExt[0].startSplinePoint = list.Count;
			markersExt[0].startDistance = totalDistance;
			if (markersExt.Count > 2)
			{
				markersExt[markersExt.Count - 1].totalDistance = totalDistance - markersExt[markersExt.Count - 1].startDistance;
				if (markersExt[markersExt.Count - 1].totalDistance < 1000f)
				{
					markersExt[markersExt.Count - 1].totalDistanceString = markersExt[markersExt.Count - 1].totalDistance.ToString("N2") + " m";
				}
				else
				{
					markersExt[markersExt.Count - 1].totalDistanceString = (markersExt[markersExt.Count - 1].totalDistance / 1000f).ToString("N3") + " km";
				}
				Vector3 vector7 = new Vector3(0f, Mathf.Abs(markersExt[markersExt.Count - 1].position.y - markersExt[0].position.y), xzDistance);
				float num12 = 90f - Vector3.Angle(vector7, to);
				if (num12 > 10f)
				{
					markersExt[markersExt.Count - 1].angleString = Mathf.Round(num12).ToString();
				}
				else
				{
					markersExt[markersExt.Count - 1].angleString = num12.ToString("N2");
				}
				float num30 = Mathf.Abs(markersExt[markersExt.Count - 2].position.y - markersExt[markersExt.Count - 1].position.y);
				float num31 = Vector3.Distance(new Vector3(markersExt[markersExt.Count - 2].position.x, 0f, markersExt[markersExt.Count - 2].position.z), new Vector3(markersExt[markersExt.Count - 1].position.x, 0f, markersExt[markersExt.Count - 1].position.z));
				markersExt[markersExt.Count - 1].gradeString = (num30 / num31 * 100f).ToString("N2");
			}
		}
		if (totalDistance < 1000f)
		{
			totalDistanceString = totalDistance.ToString("N2") + " m";
		}
		else
		{
			totalDistanceString = (totalDistance / 1000f).ToString("N3") + " km";
		}
		if (markersExt.Count == 2)
		{
			if (markersExt[0].totalDistance < 1000f)
			{
				markersExt[0].totalDistanceString = markersExt[0].totalDistance.ToString("N2") + " m";
			}
			else
			{
				markersExt[0].totalDistanceString = (markersExt[0].totalDistance / 1000f).ToString("N3") + " km";
			}
		}
		if (!closedTrack)
		{
			markersExt[markersExt.Count - 1].totalDistanceString = "0";
		}
		if (flag4)
		{
			Vector3 vB = list[0] + vector * 10f;
			vB.y = list[0].y;
			float num32 = markersExt[0].totalDistance * 0.5f;
			if (num32 > 5f)
			{
				num32 = 5f;
			}
			float num33 = 0f;
			for (int num34 = 1; num34 < list.Count; num34++)
			{
				num33 += Vector3.Distance(list[num34 - 1], list[num34]);
				if (num33 > num32)
				{
					break;
				}
				Vector3 a2 = ODQDQDQDQO.OQQCQOCCOQ(list[0], vB, list[num34]);
				a2 = Vector3.Lerp(a2, list[num34], num33 / num32);
				a2.y = list[num34].y;
				list[num34] = a2;
			}
		}
		if (flag5)
		{
			Vector3 vector13 = list[list.Count - 1];
			Vector3 vB2 = vector13 + vector2 * 10f;
			vB2.y = list[0].y;
			float num35 = markersExt[markersExt.Count - 2].totalDistance * 0.5f;
			if (num35 > 5f)
			{
				num35 = 5f;
			}
			float num36 = 0f;
			for (int num37 = list.Count - 2; num37 > 0; num37--)
			{
				num36 += Vector3.Distance(list[num37 + 1], list[num37]);
				if (num36 > num35)
				{
					break;
				}
				Vector3 a3 = ODQDQDQDQO.OQQCQOCCOQ(vector13, vB2, list[num37]);
				a3 = Vector3.Lerp(a3, list[num37], num36 / num35);
				a3.y = list[num37].y;
				list[num37] = a3;
			}
		}
		markersExt[0].direction1 = new Vector3(markersExt[0].direction1.x, 0f, markersExt[0].direction1.z).normalized;
		markersExt[markersExt.Count - 1].direction1 = new Vector3(markersExt[markersExt.Count - 1].direction1.x, 0f, markersExt[markersExt.Count - 1].direction1.z).normalized;
		return list;
	}

	public void OCQOOCCQDD(List<ERMarkerExt> tmpMarkers, int j, Vector3[] tr, Vector3 circleDir, float totalDist, ref Vector3 startCP, int startMarker, List<Vector3> p)
	{
		startCP = tr[j];
		if (tmpMarkersExt[startMarker + j - 1].controlType == 1 || tmpMarkersExt[startMarker + j - 1].controlType == 2)
		{
			Vector3 vector = tr[j] - tr[j + 1];
			vector = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
			Vector3 vA = tr[j + 1] + vector * 1500f;
			Vector3 vB = tr[j + 1] + -vector * 1500f;
			Vector3 vector2 = ODQDQDQDQO.OQQCQOCCOQ(vA, vB, tr[j + 2]);
			Vector3 vector3 = tr[j + 2];
			vector3.y = vector2.y;
			float num = Vector3.Distance(vector3, vector2);
			tmpPerpCP = tr[j + 1];
			vector = (vector2 - vector3).normalized;
			startCP = vector2 + vector * num;
			startCP.y = tr[j + 2].y;
			tmpCP = startCP;
		}
		else if (tmpMarkersExt[startMarker + j - 1].controlType == 3)
		{
			float num2 = Vector3.Distance(tmpMarkersExt[startMarker + j - 1].position, tmpMarkersExt[startMarker + j].position);
			Vector3 vector4 = circleDir;
			startCP = tmpMarkersExt[startMarker + j].position + vector4 * num2;
			vector4 = (p[p.Count - 2] - tr[j + 1]).normalized;
		}
	}

	public void OQDOQOCDDQ(List<ERMarkerExt> tmpMarkersExt, int j, Vector3[] tr, ref Vector3 endCP, int startMarker)
	{
		if (tr.Length <= j + 3)
		{
			return;
		}
		endCP = tr[j + 3];
		if (tmpMarkersExt.Count <= startMarker + j + 1)
		{
			endCP = tr[j + 3];
		}
		else if (tmpMarkersExt[startMarker + j + 1].controlType == 3)
		{
			endCP = tr[j + 2];
			Vector3 normalized = (tmpMarkersExt[startMarker + j + 1].position - tmpMarkersExt[startMarker + j].position).normalized;
			endCP = tmpMarkersExt[startMarker + j + 1].position + normalized * Vector3.Distance(tmpMarkersExt[startMarker + j].position, tmpMarkersExt[startMarker + j + 1].position);
			if (startMarker + j + 2 < tmpMarkersExt.Count)
			{
				endCP.y = tmpMarkersExt[startMarker + j + 2].position.y;
			}
			else if (closedTrack)
			{
				endCP.y = markersExt[0].position.y;
			}
			else
			{
				endCP.y = tmpMarkersExt[startMarker + j + 1].position.y;
			}
			p5 = endCP;
			testPoints.Add(endCP);
		}
		else if (tmpMarkersExt.Count > startMarker + j + 2 && (tmpMarkersExt[startMarker + j + 1].controlType == 1 || tmpMarkersExt[startMarker + j + 1].controlType == 2))
		{
			Vector3 vector = tr[j + 3] - tr[j + 2];
			vector = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
			Vector3 vA = tr[j + 2] + vector * 1500f;
			Vector3 vB = tr[j + 2] + -vector * 1500f;
			Vector3 vector2 = ODQDQDQDQO.OQQCQOCCOQ(vA, vB, tr[j + 1]);
			Vector3 vector3 = tr[j + 1];
			vector3.y = vector2.y;
			float num = Vector3.Distance(vector3, vector2);
			vector = (vector2 - vector3).normalized;
			endCP = vector2 + vector * num;
			endCP.y = tr[j + 1].y;
		}
	}

	public void OOCCQCCDQC(ref Vector3 endCP, Vector3 curV3, Vector3 nextV3, Vector3 nextNextV3)
	{
		Vector3 vector = nextNextV3 - nextV3;
		vector = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
		Vector3 vA = nextV3 + vector * 1500f;
		Vector3 vB = nextV3 + -vector * 1500f;
		Vector3 vector2 = ODQDQDQDQO.OQQCQOCCOQ(vA, vB, curV3);
		Vector3 vector3 = curV3;
		vector3.y = vector2.y;
		float num = Vector3.Distance(vector3, vector2);
		vector = (vector2 - vector3).normalized;
		endCP = vector2 + vector * num;
		endCP.y = curV3.y;
	}

	public List<float> OQDOOOQODD(List<float> tValues, List<float> markerDistances, List<ERMarkerExt> markers, int startMarker, int endMarker, ref List<float> OQQOODQCCC, List<float> randomRotations)
	{
		List<float> list = new List<float>();
		List<Vector3> list2 = new List<Vector3>();
		List<float> list3 = new List<float>();
		List<float> list4 = new List<float>();
		markerInts.Clear();
		bridgeElement.Clear();
		for (int i = startMarker; i < endMarker; i++)
		{
			list.Add(tmpMarkersExt[i].rotation);
			list3.Add(tmpMarkersExt[i].rotationCenter);
		}
		list.Insert(0, list[0]);
		list.Add(list[list.Count - 1]);
		list3.Insert(0, list3[0]);
		list3.Add(list3[list3.Count - 1]);
		List<float> list5 = new List<float>();
		OQQOODQCCC.Clear();
		int num = -1;
		int num2 = -1;
		int num3 = 0;
		if (soSectionList1.Count > 0)
		{
			num = soSectionList1[num3].startSplinePoint;
			num2 = soSectionList1[num3].endSplinePoint;
		}
		int num4 = -1;
		int num5 = -1;
		int num6 = 0;
		if (soSectionList2.Count > 0)
		{
			num4 = soSectionList2[num6].startSplinePoint;
			num5 = soSectionList2[num6].endSplinePoint;
		}
		int num7 = 0;
		int num8 = 1;
		bool flag = false;
		bool flag2 = false;
		while (num8 < list.Count - 2)
		{
			while (!flag)
			{
				if (num7 < tValues.Count)
				{
					float num9 = Mathf.Lerp(list[num8], list[num8 + 1], Mathf.SmoothStep(0f, 1f, tValues[num7]));
					float item = Mathf.Lerp(list3[num8], list3[num8 + 1], Mathf.SmoothStep(0f, 1f, tValues[num7]));
					if (randomRotations.Count > num7)
					{
						list5.Add(num9 + randomRotations[num7]);
					}
					else
					{
						list5.Add(num9);
					}
					OQQOODQCCC.Add(item);
					if (num7 + 1 < tValues.Count)
					{
						if (tValues[num7 + 1] <= tValues[num7])
						{
							flag = true;
						}
					}
					else
					{
						flag = true;
					}
					num7++;
				}
				else
				{
					flag = true;
				}
				try
				{
					flag2 = false;
					if (!flag)
					{
						markerInts.Add(num8 - 1);
						flag2 = tmpMarkersExt[num8 - 1].bridgeObject;
						if (num7 > num && num7 <= num2)
						{
							flag2 = true;
						}
						if (num7 > num4 && num7 <= num5)
						{
							flag2 = true;
						}
						bridgeElement.Add(flag2);
					}
					else
					{
						markerInts.Add(num8);
						flag2 = tmpMarkersExt[num8].bridgeObject;
						if (num7 > num && num7 <= num2)
						{
							flag2 = true;
						}
						if (num7 > num4 && num7 <= num5)
						{
							flag2 = true;
						}
						bridgeElement.Add(flag2);
					}
				}
				catch
				{
					UnityEngine.Debug.Log(num8 + " " + tmpMarkersExt.Count);
				}
				if (num7 == num2)
				{
					num3++;
					if (soSectionList1.Count > num3)
					{
						num = soSectionList1[num3].startSplinePoint;
						num2 = soSectionList1[num3].endSplinePoint;
					}
				}
				if (num7 == num5)
				{
					num6++;
					if (soSectionList2.Count > num6)
					{
						num4 = soSectionList2[num6].startSplinePoint;
						num5 = soSectionList2[num6].endSplinePoint;
					}
				}
			}
			flag = false;
			num8++;
			if (list[num8] == 360f && list[num8 + 1] < 360f)
			{
				list[num8] = 0f;
			}
			else if (list[num8] == -360f && list[num8 + 1] > -360f)
			{
				list[num8] = 0f;
			}
		}
		return list5;
	}

	public void RoadSmoothness(float curDist, ERMarkerExt marker, float totalDistance, ref float randomYDistanceStart, ref float randomYDistanceEnd, ref float randomYDistanceMiddle, ref Vector3 randomYDistanceV3, ref Vector3 v, ref float currentRandomYDistance, ref float randomRotationStart, ref float randomRotationEnd, ref float randomRotationMiddle, ref Vector3 randomRotationV3, ref float currentRandomRotation, ref List<float> rotationArray)
	{
		if (marker.minRandomYPositionDistance != 0f || marker.maxRandomYPositionDistance != 0f)
		{
			if (curDist >= randomYDistanceEnd)
			{
				if (marker.maxRandomYPositionDistance == 0f)
				{
					marker.maxRandomYPositionDistance = 25f;
				}
				randomYDistanceStart = (randomYDistanceEnd = curDist);
				float num = UnityEngine.Random.Range(marker.minRandomYPositionDistance, marker.maxRandomYPositionDistance);
				randomYDistanceEnd += num;
				randomYDistanceMiddle = Mathf.Lerp(randomYDistanceStart, randomYDistanceEnd, 0.5f);
				randomYDistanceV3.x = UnityEngine.Random.Range(marker.randomMinYPosition, marker.randomMaxYPosition);
				if (randomYDistanceEnd > totalDistance)
				{
					randomYDistanceEnd = totalDistance;
					if (randomYDistanceEnd - randomYDistanceStart < marker.minRandomYPositionDistance)
					{
						randomYDistanceV3.x = 0f;
					}
				}
				if (randomYDistanceMiddle > totalDistance)
				{
					randomYDistanceMiddle = Mathf.Lerp(randomYDistanceStart, randomYDistanceEnd, 0.5f);
				}
			}
			if (randomYDistanceV3.x != 0f)
			{
				float num2 = 0f;
				if (curDist < randomYDistanceMiddle)
				{
					num2 = (curDist - randomYDistanceStart) / (randomYDistanceMiddle - randomYDistanceStart);
					currentRandomYDistance = Mathf.Lerp(0f, randomYDistanceV3.x, Mathf.SmoothStep(0f, 1f, num2));
				}
				else
				{
					num2 = (curDist - randomYDistanceMiddle) / (randomYDistanceEnd - randomYDistanceMiddle);
					currentRandomYDistance = Mathf.Lerp(randomYDistanceV3.x, 0f, Mathf.SmoothStep(0f, 1f, num2));
				}
			}
			v.y += currentRandomYDistance;
		}
		currentRandomRotation = 0f;
		if (marker.minRandomRotationDistance != 0f || marker.maxRandomRotationDistance != 0f)
		{
			if (curDist >= randomRotationEnd)
			{
				if (marker.maxRandomRotationDistance == 0f)
				{
					marker.maxRandomRotationDistance = 25f;
				}
				randomRotationStart = (randomRotationEnd = curDist);
				float num3 = UnityEngine.Random.Range(marker.minRandomRotationDistance, marker.maxRandomRotationDistance);
				randomRotationEnd += num3;
				randomRotationMiddle = Mathf.Lerp(randomRotationStart, randomRotationEnd, 0.5f);
				randomRotationV3.x = UnityEngine.Random.Range(marker.randomMinRotation, marker.randomMaxRotation);
				if (randomRotationEnd > totalDistance)
				{
					randomRotationEnd = totalDistance;
					if (randomRotationEnd - randomRotationStart < marker.minRandomRotationDistance)
					{
						randomRotationV3.x = 0f;
					}
				}
				if (randomRotationMiddle > totalDistance)
				{
					randomRotationMiddle = Mathf.Lerp(randomRotationStart, randomRotationEnd, 0.5f);
				}
			}
			if (randomRotationV3.x != 0f)
			{
				float num4 = 0f;
				if (curDist < randomRotationMiddle)
				{
					num4 = (curDist - randomRotationStart) / (randomRotationMiddle - randomRotationStart);
					currentRandomRotation = Mathf.Lerp(0f, randomRotationV3.x, Mathf.SmoothStep(0f, 1f, num4));
				}
				else
				{
					num4 = (curDist - randomRotationMiddle) / (randomRotationEnd - randomRotationMiddle);
					currentRandomRotation = Mathf.Lerp(randomRotationV3.x, 0f, Mathf.SmoothStep(0f, 1f, num4));
				}
			}
		}
		rotationArray.Add(currentRandomRotation);
	}

	public List<List<Vector2>> GetRoadShapeValues(List<float> tValues, List<float> markerDistances, List<ERMarkerExt> markers, int startMarker, int endMarker, List<Vector2> roadShape)
	{
		List<List<Vector2>> list = new List<List<Vector2>>();
		List<List<Vector3>> list2 = new List<List<Vector3>>();
		List<List<Vector3>> list3 = new List<List<Vector3>>();
		List<float> list4 = new List<float>();
		List<float> list5 = new List<float>();
		bool flag = false;
		for (int i = 0; i < roadShape.Count; i++)
		{
			list2.Add(new List<Vector3>());
			list3.Add(new List<Vector3>());
		}
		int count = roadShape.Count;
		for (int j = startMarker; j < endMarker; j++)
		{
			list4.Add(tmpMarkersExt[j].roadShapeDistanceMin);
			list5.Add(tmpMarkersExt[j].roadShapeDistanceMax);
			if (tmpMarkersExt[j].roadShape.Count != count)
			{
				tmpMarkersExt[j].roadShape = new List<Vector2>(roadShape);
			}
			for (int k = 0; k < roadShape.Count; k++)
			{
				Vector3 item = new Vector3(markerDistances[j - startMarker], tmpMarkersExt[j].roadShape[k].x, 0f);
				list2[k].Add(item);
				item = new Vector3(markerDistances[j - startMarker], tmpMarkersExt[j].roadShape[k].y, 0f);
				list3[k].Add(item);
				if (tmpMarkersExt[j].roadShape[k] != roadShape[k])
				{
					flag = true;
				}
			}
			tmpMarkersExt[j].roadShapeVecsGlobal.Clear();
		}
		for (int l = 0; l < list2.Count; l++)
		{
			if (!closedTrack)
			{
				list2[l].Insert(0, list2[l][0]);
				list2[l].Add(list2[l][list2[l].Count - 1]);
			}
			else
			{
				list2[l].Insert(0, list2[l][list2[l].Count - 2]);
				list2[l].Add(list2[l][2]);
			}
			if (!closedTrack)
			{
				list3[l].Insert(0, list3[l][0]);
				list3[l].Add(list3[l][list3[l].Count - 1]);
			}
			else
			{
				list3[l].Insert(0, list3[l][list3[l].Count - 2]);
				list3[l].Add(list3[l][2]);
			}
		}
		if (!closedTrack)
		{
			list4.Insert(0, list4[0]);
			list4.Add(list4[list4.Count - 1]);
		}
		else
		{
			list4.Insert(0, list4[list4.Count - 2]);
			list4.Add(list4[2]);
		}
		if (!closedTrack)
		{
			list5.Insert(0, list5[0]);
			list5.Add(list5[list5.Count - 1]);
		}
		else
		{
			list5.Insert(0, list5[list5.Count - 2]);
			list5.Add(list5[2]);
		}
		for (int m = 0; m < roadShape.Count; m++)
		{
			list.Add(new List<Vector2>());
		}
		int num = 0;
		int n = 1;
		bool flag2 = false;
		for (; n < list2[0].Count - 2; n++)
		{
			while (!flag2)
			{
				if (num < tValues.Count)
				{
					float t;
					if (tValues[num] < list4[n])
					{
						t = 0f;
					}
					else if (tValues[num] < list5[n])
					{
						t = tValues[num] - list4[n];
						t /= list5[n] - list4[n];
					}
					else
					{
						t = 1f;
					}
					for (int num2 = 0; num2 < roadShape.Count; num2++)
					{
						Vector3 vector;
						Vector3 vector2;
						if (list2[num2][n] != list2[num2][n + 1] || list3[num2][n] != list3[num2][n + 1])
						{
							vector = OODODQQQCD(list2[num2][n - 1], list2[num2][n], list2[num2][n + 1], list2[num2][n + 2], t, 0.5f);
							vector2 = OODODQQQCD(list3[num2][n - 1], list3[num2][n], list3[num2][n + 1], list3[num2][n + 2], t, 0.5f);
						}
						else
						{
							vector = list2[num2][n];
							vector2 = list3[num2][n];
						}
						list[num2].Add(new Vector2(vector.y, vector2.y));
					}
					if (num + 1 < tValues.Count)
					{
						if (tValues[num + 1] <= tValues[num])
						{
							flag2 = true;
						}
					}
					else
					{
						flag2 = true;
					}
					num++;
				}
				else
				{
					flag2 = true;
				}
			}
			flag2 = false;
		}
		return list;
	}

	public List<float> GetSurfaceValues(List<float> tValues, List<float> markerDistances, List<ERMarkerExt> markers, int startMarker, int endMarker, ref List<float> leftIndents, ref List<float> rightIndents, ref List<float> leftSurrounding, ref List<float> rightSurrounding, float minRequiredIndent)
	{
		List<Vector3> list = new List<Vector3>();
		List<Vector3> list2 = new List<Vector3>();
		List<Vector3> list3 = new List<Vector3>();
		List<Vector3> list4 = new List<Vector3>();
		List<Vector3> list5 = new List<Vector3>();
		List<float> list6 = new List<float>();
		float num = 0f;
		float num2 = 0f;
		for (int i = startMarker; i < endMarker; i++)
		{
			num = tmpMarkersExt[i].leftIndent;
			num2 = tmpMarkersExt[i].rightIndent;
			if (num < minRequiredIndent)
			{
				num = minRequiredIndent;
			}
			if (num2 < minRequiredIndent)
			{
				num2 = minRequiredIndent;
			}
			Vector3 item = new Vector3(markerDistances[i - startMarker], num, 0f);
			list2.Add(item);
			item = new Vector3(markerDistances[i - startMarker], num2, 0f);
			list3.Add(item);
			item = new Vector3(markerDistances[i - startMarker], tmpMarkersExt[i].leftSurrounding, 0f);
			list4.Add(item);
			item = new Vector3(markerDistances[i - startMarker], tmpMarkersExt[i].rightSurrounding, 0f);
			list5.Add(item);
		}
		list2.Insert(0, list2[0]);
		list2.Add(list2[list2.Count - 1]);
		list3.Insert(0, list3[0]);
		list3.Add(list3[list3.Count - 1]);
		list4.Insert(0, list4[0]);
		list4.Add(list4[list4.Count - 1]);
		list5.Insert(0, list5[0]);
		list5.Add(list5[list5.Count - 1]);
		List<float> result = new List<float>();
		int num3 = 0;
		int j = 1;
		bool flag = false;
		for (; j < list2.Count - 2; j++)
		{
			while (!flag)
			{
				if (num3 < tValues.Count)
				{
					Vector3 vector = OODODQQQCD(list2[j - 1], list2[j], list2[j + 1], list2[j + 2], tValues[num3], 0.5f);
					leftIndents.Add(vector.y);
					vector = OODODQQQCD(list3[j - 1], list3[j], list3[j + 1], list3[j + 2], tValues[num3], 0.5f);
					rightIndents.Add(vector.y);
					vector = OODODQQQCD(list4[j - 1], list4[j], list4[j + 1], list4[j + 2], tValues[num3], 0.5f);
					leftSurrounding.Add(vector.y);
					vector = OODODQQQCD(list5[j - 1], list5[j], list5[j + 1], list5[j + 2], tValues[num3], 0.5f);
					rightSurrounding.Add(vector.y);
					if (num3 + 1 < tValues.Count)
					{
						if (tValues[num3 + 1] <= tValues[num3])
						{
							flag = true;
						}
					}
					else
					{
						flag = true;
					}
					num3++;
				}
				else
				{
					flag = true;
				}
			}
			flag = false;
		}
		return result;
	}

	public bool OCCQQDDDQC(SideObject obj, bool flag)
	{
		foreach (ERSORoadExt item in soDataExt)
		{
			if (item != null && item.sideObject == obj)
			{
				if (item.active != flag)
				{
					item.active = flag;
					ODDQODOOOC.ODQCOCOCOQ(baseScript, this, obj);
					if (flag)
					{
						ODDQODOOOC.ODOOCCCOQD(this, obj, item.markerActive);
						ODDQODOOOC.OODQCDDCQO(baseScript, this, obj);
					}
					else
					{
						bool terrainSurfaceFlag = false;
						ODDQODOOOC.ODODCDDCOD(this, obj, ref terrainSurfaceFlag);
					}
					return true;
				}
				break;
			}
		}
		return false;
	}

	public bool ODQCOQQDCD(SideObject obj, int marker, bool flag)
	{
		if (marker >= 0 && marker < markersExt.Count)
		{
			bool flag2 = false;
			foreach (ERSOMarkerExt soDatum in markersExt[marker].soData)
			{
				if (soDatum != null && soDatum.sideObject == obj)
				{
					if (soDatum.active != flag)
					{
						soDatum.active = flag;
						ODDQODOOOC.ODQCOCOCOQ(baseScript, this, obj);
						ODDQODOOOC.OODQCDDCQO(baseScript, this, obj);
					}
					flag2 = true;
				}
			}
			if (!flag2 && OCCQQDDDQC(obj, flag: true))
			{
				ODQCOQQDCD(obj, marker, flag);
			}
		}
		if (obj.bridgeObject)
		{
			markersExt[marker].bridgeObject = flag;
			if (!terrainDeformation)
			{
				markersExt[marker].bridgeObject = false;
			}
			return true;
		}
		return false;
	}

	public bool ERSetSideObjectOffset(SideObject obj, int marker, OffsetPosition position, float value)
	{
		bool result = false;
		if (marker >= 0 && marker < markersExt.Count)
		{
			foreach (ERSOMarkerExt soDatum in markersExt[marker].soData)
			{
				if (soDatum != null && soDatum.sideObject == obj)
				{
					if (position == OffsetPosition.Start)
					{
						soDatum.startOffset = value;
					}
					else
					{
						soDatum.endOffset = value;
					}
					ODDQODOOOC.OODQCDDCQO(baseScript, this, obj);
					result = true;
					break;
				}
			}
		}
		return result;
	}

	public bool ODQCOQQDCD(SideObject obj, int[] markers, bool flag)
	{
		bool flag2 = false;
		bool result = false;
		bool flag3 = false;
		bool flag4 = false;
		foreach (int num in markers)
		{
			if (num >= 0 && num < markersExt.Count)
			{
				foreach (ERSOMarkerExt soDatum in markersExt[num].soData)
				{
					if (soDatum != null && soDatum.sideObject == obj)
					{
						if (soDatum.active != flag)
						{
							soDatum.active = flag;
							flag2 = true;
						}
						flag3 = true;
						break;
					}
				}
				flag4 = true;
			}
			if (obj.bridgeObject)
			{
				markersExt[num].bridgeObject = flag;
				if (!terrainDeformation)
				{
					markersExt[num].bridgeObject = false;
				}
				result = true;
			}
		}
		if (!flag3 && flag4 && OCCQQDDDQC(obj, flag: true))
		{
			ODQCOQQDCD(obj, markers, flag);
		}
		if (flag2)
		{
			ODDQODOOOC.ODQCOCOCOQ(baseScript, this, obj);
			ODDQODOOOC.OODQCDDCQO(baseScript, this, obj);
		}
		return result;
	}

	public List<Vector3> OQOQDCODCD(bool flag)
	{
		List<Vector3> list = new List<Vector3>();
		foreach (ERMarkerExt item in markersExt)
		{
			list.Add(item.position);
		}
		if (flag)
		{
			if (closedTrack)
			{
				list.Insert(0, list[list.Count - 1]);
				list.Add(list[1]);
				list.Add(list[2]);
			}
			else
			{
				list.Add(list[list.Count - 1]);
				list.Insert(0, list[0]);
			}
		}
		flyOverPoints = list.ToArray();
		return list;
	}

	public void OQOQDQCDCQ()
	{
		List<float> list = new List<float>();
		markerDistances = ODQQOQQDOO(flyOverPoints);
	}

	public List<float> ODQQOQQDOO(Vector3[] tr)
	{
		List<float> list = new List<float>();
		list.Add(0f);
		List<Vector3> list2 = new List<Vector3>();
		float num = 0f;
		float num2 = 0f;
		Vector3 vector = Vector3.zero;
		float num3 = 0f;
		for (int i = 1; i < tr.Length - 2; i++)
		{
			if (num3 > 0f)
			{
				num3 -= 1f;
			}
			num3 = 0f;
			float num4 = 0.0005f;
			for (float num5 = num3; num5 < 1f; num5 += num4)
			{
				Vector3 vector2 = OODODQQQCD(tr[i - 1], tr[i], tr[i + 1], tr[i + 2], num5, 0.5f);
				list2.Add(vector2);
				if (vector != Vector3.zero)
				{
					float num6 = Vector3.Distance(vector, vector2);
					num += num6;
					num2 += num6;
				}
				vector = vector2;
				num3 = num5;
			}
			list.Add(num2);
		}
		return list;
	}

	public Vector3 OOOOQCODCQ(float offset)
	{
		float num = offset * totalDistance;
		int num2 = 0;
		for (int i = 0; i < markerDistances.Count; i++)
		{
			if (markerDistances[i] > num)
			{
				num2 = i - 1;
				break;
			}
		}
		if (num2 < 0)
		{
			num2 = 0;
		}
		float t = (num - markerDistances[num2]) / (markerDistances[num2 + 1] - markerDistances[num2]);
		num2++;
		return OODODQQQCD(flyOverPoints[num2 - 1], flyOverPoints[num2], flyOverPoints[num2 + 1], flyOverPoints[num2 + 2], t, 0.5f);
	}

	public static Vector3 OODODQQQCD(Vector3 P0, Vector3 P1, Vector3 P2, Vector3 P3, float t, float tension)
	{
		float num = t * t;
		float num2 = num * t;
		Vector3 vector = tension * (P2 - P0);
		Vector3 vector2 = tension * (P3 - P1);
		float num3 = 2f * num2 - 3f * num + 1f;
		float num4 = -2f * num2 + 3f * num;
		float num5 = num2 - 2f * num + t;
		float num6 = num2 - num;
		return num3 * P1 + num4 * P2 + num5 * vector + num6 * vector2;
	}

	public Vector3 OCCDDOCCDQ(int startend, ERCrossingPrefabs prefab)
	{
		Vector3 position;
		Vector3 position2;
		Vector3 vector;
		if (startend == 0)
		{
			position = markersExt[0].position;
			position2 = markersExt[1].position;
			vector = ((markersExt.Count <= 2) ? position2 : markersExt[2].position);
		}
		else
		{
			position = markersExt[markersExt.Count - 1].position;
			position2 = markersExt[markersExt.Count - 2].position;
			vector = ((markersExt.Count <= 2) ? position2 : markersExt[markersExt.Count - 3].position);
		}
		Vector3 vector2 = prefab.transform.InverseTransformPoint(position2);
		vector2.y = 0f;
		vector2 = prefab.transform.position;
		Vector3 angleControlPoint = ERConnectionSibling.GetAngleControlPoint(vector2, position, position2, vector);
		return prefab.transform.InverseTransformPoint(angleControlPoint);
	}

	public void OQDQOOQODD(bool lineMask, bool biomeMask)
	{
		if (baseScript != null)
		{
			if (!lineMask && (object)baseScript.rmMethod != null)
			{
				object[] parameters = new object[1] { base.gameObject };
				baseScript.rmMethod.Invoke(null, parameters);
			}
			if (!biomeMask && (object)baseScript.rmBiomeMethod != null)
			{
				object[] parameters2 = new object[1] { base.gameObject };
				baseScript.rmBiomeMethod.Invoke(null, parameters2);
			}
		}
	}

	public void SetMarkerShape(List<Vector2> conVecs, Vector3 scale, ERCrossingPrefabs prefab, int connectionIndex)
	{
		for (int i = 0; i < conVecs.Count; i++)
		{
			conVecs[i] = new Vector2(conVecs[i].x * scale.x, conVecs[i].y * scale.y);
		}
		conVecs.Reverse();
		if (startPrefabScript == prefab && startConnectionSegment == connectionIndex)
		{
			markersExt[0].roadShape = conVecs;
		}
		else if (endPrefabScript == prefab && endConnectionSegment == connectionIndex)
		{
			markersExt[markersExt.Count - 1].roadShape = conVecs;
		}
	}

	public void ODQOCQCCDC(ERIndentAlignment value, int marker, ERRoadSide type)
	{
		if (marker < 0 || marker >= markersExt.Count)
		{
			return;
		}
		if (type == ERRoadSide.Left || type == ERRoadSide.Both)
		{
			switch (value)
			{
			case ERIndentAlignment.Road:
				markersExt[marker].leftIndentAlignment = 0;
				break;
			case ERIndentAlignment.Terrain:
				markersExt[marker].leftIndentAlignment = 1;
				break;
			case ERIndentAlignment.Surrounding:
				markersExt[marker].leftIndentAlignment = 2;
				break;
			}
		}
		if (type == ERRoadSide.Right || type == ERRoadSide.Both)
		{
			switch (value)
			{
			case ERIndentAlignment.Road:
				markersExt[marker].rightIndentAlignment = 0;
				break;
			case ERIndentAlignment.Terrain:
				markersExt[marker].rightIndentAlignment = 1;
				break;
			case ERIndentAlignment.Surrounding:
				markersExt[marker].rightIndentAlignment = 2;
				break;
			}
		}
	}

	public ERIndentAlignment ERGetIndentAlignment(int marker, ERRoadSide type)
	{
		if (marker >= 0 && marker < markersExt.Count)
		{
			if (type == ERRoadSide.Left || type == ERRoadSide.Both)
			{
				if (markersExt[marker].leftIndentAlignment == 0)
				{
					return ERIndentAlignment.Road;
				}
				if (markersExt[marker].leftIndentAlignment == 1)
				{
					return ERIndentAlignment.Terrain;
				}
				if (markersExt[marker].leftIndentAlignment == 2)
				{
					return ERIndentAlignment.Surrounding;
				}
			}
			if (type == ERRoadSide.Right || type == ERRoadSide.Both)
			{
				if (markersExt[marker].rightIndentAlignment == 0)
				{
					return ERIndentAlignment.Road;
				}
				if (markersExt[marker].rightIndentAlignment == 1)
				{
					return ERIndentAlignment.Terrain;
				}
				if (markersExt[marker].rightIndentAlignment == 2)
				{
					return ERIndentAlignment.Surrounding;
				}
			}
		}
		return ERIndentAlignment.Road;
	}

	public void FlipRoadUVs(bool update)
	{
		if (update)
		{
			flipRoadUVs = !flipRoadUVs;
		}
		roadMaterials = base.gameObject.GetComponent<MeshRenderer>().sharedMaterials;
		int num = 0;
		for (int i = 0; i < roadMaterials.Length; i++)
		{
			if (roadMaterials[i] == roadMaterial)
			{
				num = i;
				break;
			}
		}
		if (roadMaterials.Length > 1)
		{
			for (int j = 0; j < roadShapeUVs.Count; j++)
			{
				if (roadShapeMaterialInts[j] == num)
				{
					roadShapeUVs[j] = 1f - roadShapeUVs[j];
					roadShapeUVs2[j] = 1f - roadShapeUVs2[j];
				}
			}
		}
		else
		{
			OCQOQOOOCO.ODQOCCDCOC(ref roadShapeUVs, ref roadShapeUVs2);
		}
	}

	public ERRoadType GetRoadType(ERRoadType[] roadTypes)
	{
		foreach (ERRoadType eRRoadType in roadTypes)
		{
			if (eRRoadType.id == roadType)
			{
				return eRRoadType;
			}
		}
		return null;
	}
}
[AddComponentMenu("")]
public class ERCrossingPrefabs : MonoBehaviour
{
	public List<QDOODOQQDQODD> crossingElements = new List<QDOODOQQDQODD>();

	public List<QDOQDSQOOQDDD> sidewalkControlElements = new List<QDOQDSQOOQDDD>();

	public List<ERConnectionSibling> siblings = new List<ERConnectionSibling>();

	public Vector3[] meshVecs = new Vector3[0];

	public Vector3[] fullMeshVecs = new Vector3[0];

	public Vector3[] tmpMeshVecs = new Vector3[0];

	public Vector3[] tmpFullMeshVecs = new Vector3[0];

	public Vector3[] tCrossingTmpFullMeshVecs = new Vector3[0];

	public int[] outerVecInts = new int[0];

	public List<Vector3> surfaceVecs = new List<Vector3>();

	public List<int> surfaceVecType = new List<int>();

	public List<int> surfaceConnectionInt = new List<int>();

	public List<ERBlendVecs> tCrossingBlendData = new List<ERBlendVecs>();

	public List<Vector3> indentVecs = new List<Vector3>();

	public GameObject sourcePrefab;

	public int prefabId = 0;

	public string guid = "";

	public List<int> prioritySegments = new List<int>();

	public float minNodeDistance = 3f;

	public int nodeWithinRange = -1;

	public GameObject sourceObject;

	public bool meshInstance = false;

	public int selectedConnection = -1;

	public string[] QDOOOQOOQQQQD = new string[0];

	public bool deformTerrain = true;

	public bool isRoundabout = false;

	public bool isERCrossing = false;

	public bool isYConnector = false;

	public bool isIConnector = false;

	public bool isFlexConnector = false;

	public bool isSnapConnector = false;

	public bool isExitRoadConnector = false;

	public Vector3 prefabCenterDummy;

	public float snapRadius = 3f;

	public ERRoundabouts roundaboutScript;

	public ERCrossings crossingsScript;

	public ERIConnector iConnectorScript;

	public bool isCustomPrefab = false;

	public int customPrefabVersion = 0;

	public bool recalculateNormals = false;

	public bool planarUVs = false;

	public float planarTiling = 1f;

	public int lastVecRoadIndex = 0;

	public bool isSceneObject = true;

	public GameObject surfaceObject;

	public Vector3[] surfaceMeshVecs = null;

	public Vector3[] tmpSurfaceMeshVecs = null;

	public Vector3[] tmpSurfaceVecsTCrossings = new Vector3[0];

	public int[] surfaceInts;

	public Vector3 leftBottomCorner;

	public Vector3 leftTopCorner;

	public Vector3 rightBottomCorner;

	public Vector3 rightTopCorner;

	public bool tCrossing = false;

	public bool tStraightBending = true;

	public int tCrossingLeftRight = 1;

	public float tMainRoadWidth = 0f;

	public float tConnectionRoadWidth = 0f;

	public float bottomLeftSidewalkWidth = 0f;

	public float bottomLeftSidewalkOuterOffset = 0f;

	public float bottomLeftSidewalkCurbDepth = 0f;

	public float bottomRightSidewalkWidth = 0f;

	public float bottomRightSidewalkOuterOffset = 0f;

	public float bottomRightSidewalkCurbDepth = 0f;

	public float topLeftSidewalkWidth = 0f;

	public float topLeftSidewalkOuterOffset = 0f;

	public float topLeftSidewalkCurbDepth = 0f;

	public float topRightSidewalkWidth = 0f;

	public float topRightSidewalkOuterOffset = 0f;

	public float topRightSidewalkCurbDepth = 0f;

	public ERConnection connObject;

	public Vector3 testVec;

	public List<int> surfaceSurroundingInts = new List<int>();

	public int rotationPriorityElement = -1;

	public Vector3 cornerPos;

	public Vector3 mainCorner;

	public Vector3 connectedCorner;

	public Vector3 mainVecOuter;

	public Vector3 connectionVecOuter;

	public Vector3 indentTopVec;

	public Vector3 indentRightVec;

	public Vector3 mainIndent;

	public Vector3 connectionIndent;

	public int selectedRotationConnection = 0;

	public Vector3 bottomVec;

	public Vector3 rightVec;

	public Vector3 bottomIndent;

	public Vector3 rightIndent;

	public float sAngle = 90f;

	public ERModularBase baseScript;

	public bool QDQDQOOQQDQOQQ = false;

	public Vector3 tp1;

	public Vector3 tp2;

	public bool doTerrainDeformation = true;

	public bool includeOuterVertices = true;

	public bool averageNormals = true;

	public float surroundingDistance = 0f;

	public Mesh surfaceMesh = null;

	public List<Vector3> debugVecs1 = new List<Vector3>();

	public List<Vector3> debugVecs2 = new List<Vector3>();

	public bool lightmapAdjusted = false;

	public bool isFlexUpdating = false;

	public Vector3 oldPosition;

	public Vector3 oldRotation;

	public bool lockScale = true;

	public float extraIndentMargin = 0f;

	public float indent = 0f;

	public float surrounding = 0f;

	public void OCOODQQDQO()
	{
		Vector3[] vertices = base.gameObject.GetComponent<MeshFilter>().sharedMesh.vertices;
		meshVecs = new Vector3[vertices.Length];
		Array.Copy(vertices, meshVecs, 0);
		meshVecs = vertices;
	}

	public void OOCQCCQDOQ(Vector3 v1, Vector3 v2, int connectionElement, ERModularRoad road)
	{
		OCQDDQODCC(connectionElement);
		Vector3 normalized = (v1 - v2).normalized;
		Vector3 normalized2 = new Vector3(normalized.z, 0f, 0f - normalized.x).normalized;
		Vector3 vector = v2 + normalized2;
		float num = Mathf.Atan2(normalized.x, normalized.z) * 57.29578f;
		num -= crossingElements[connectionElement].centerPointAngle;
		Vector3 eulerAngles = base.transform.eulerAngles;
		if (OQCDCDOOCD(base.transform.position, v1, v2))
		{
			eulerAngles.y += num;
		}
		else
		{
			eulerAngles.y -= num;
		}
		base.transform.eulerAngles = new Vector3(0f, num, 0f);
		Vector3 vector2 = v1 + new Vector3(normalized.z, 0f, 0f - normalized.x) * 2f;
		Vector3 lhs = v1 - vector2;
		Vector3 rhs = v2 - vector2;
		Vector3 vector3 = -Vector3.Cross(lhs, rhs).normalized;
		Vector3 forward = base.transform.forward;
		Vector3 forward2 = forward - Vector3.Dot(forward, vector3) * vector3;
		base.transform.rotation = Quaternion.LookRotation(forward2, vector3);
		Vector3 vector4 = base.transform.TransformPoint(crossingElements[connectionElement].centerPoint);
		base.transform.position += v1 - vector4;
		OQOQDDOCDC(ignorePriority: true, road);
	}

	public void OCQDDQODCC(int el)
	{
		Vector3 normalized = (crossingElements[el].controlPointV3 - crossingElements[el].centerPoint).normalized;
		crossingElements[el].centerPointAngle = Mathf.Atan2(normalized.x, normalized.z) * 57.29578f;
	}

	public void OCDOCCODOC(int elInt, float distance)
	{
	}

	public void DeformTCossingConnection(int elInt, float distance, float defaultDistance, List<Vector3> controlPoints, float multiplyFactor, float angle, Vector3 cpCenterPoint, float curveStrength)
	{
		if (!tCrossing)
		{
			return;
		}
		controlPoints.Reverse();
		if (fullMeshVecs.Length == 0)
		{
			if (baseScript == null)
			{
				if ((bool)base.transform.parent && (bool)base.transform.parent.parent)
				{
					baseScript = base.transform.parent.parent.GetComponent<ERModularBase>();
				}
				if (baseScript == null)
				{
					baseScript = UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase;
					if (baseScript == null)
					{
						return;
					}
				}
			}
			baseScript.OQOCDOOQCQ(this);
		}
		if (crossingElements[elInt].rotationPriority)
		{
			return;
		}
		if (tCrossingTmpFullMeshVecs.Length == 0)
		{
			tCrossingTmpFullMeshVecs = new Vector3[fullMeshVecs.Length];
			Array.Copy(fullMeshVecs, tCrossingTmpFullMeshVecs, fullMeshVecs.Length);
			tmpSurfaceVecsTCrossings = new Vector3[surfaceMeshVecs.Length];
			Array.Copy(surfaceMeshVecs, tmpSurfaceVecsTCrossings, surfaceMeshVecs.Length);
		}
		QDOODOQQDQODD qDOODOQQDQODD = crossingElements[elInt];
		if (qDOODOQQDQODD.connectionVecInts.Count != 0)
		{
			Vector3 normalized = (meshVecs[qDOODOQQDQODD.connectionVecInts[0]] - meshVecs[qDOODOQQDQODD.connectionVecInts[qDOODOQQDQODD.connectionVecInts.Count - 1]]).normalized;
			Mesh mesh = null;
			if (!meshInstance)
			{
				mesh = UnityEngine.Object.Instantiate(base.gameObject.GetComponent<MeshFilter>().sharedMesh);
				base.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
				base.gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
				meshInstance = true;
			}
			else
			{
				mesh = base.gameObject.GetComponent<MeshFilter>().sharedMesh;
			}
			tmpFullMeshVecs = mesh.vertices;
			tmpFullMeshVecs = OODODOQDCC.OOOOCDQODC(this, elInt, controlPoints, distance, defaultDistance, fullMeshVecs, ref tCrossingTmpFullMeshVecs, multiplyFactor, angle, curveStrength);
			if (crossingsScript == null)
			{
				crossingsScript = base.gameObject.GetComponent<ERCrossings>();
			}
			tmpFullMeshVecs = ODDDDDCCQQ.OOQOODDQCC(crossingsScript, tmpFullMeshVecs);
			tmpFullMeshVecs = ERSideWalkVecs.SnapSidewalkCornersVecs(crossingsScript, tmpFullMeshVecs);
			mesh.vertices = tmpFullMeshVecs;
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			mesh.normals = ERSideWalkVecs.OODDQOQDCC(crossingsScript, mesh.normals);
			if (baseScript.tangentsInEditMode)
			{
				ODCCODOCQQ.OCDCQCOQQO(mesh);
			}
			qDOODOQQDQODD.tmpCenterPoint = Vector3.Lerp(tmpFullMeshVecs[qDOODOQQDQODD.fullConnectionVecInts[0]], tmpFullMeshVecs[qDOODOQQDQODD.fullConnectionVecInts[qDOODOQQDQODD.fullConnectionVecInts.Count - 1]], qDOODOQQDQODD.centerPointPercentage);
			qDOODOQQDQODD.tmpCenterPoint.y = 0f;
			if (tmpSurfaceMeshVecs == null)
			{
				tmpSurfaceMeshVecs = new Vector3[surfaceMeshVecs.Length];
				Array.Copy(surfaceMeshVecs, tmpSurfaceMeshVecs, surfaceMeshVecs.Length);
				tmpSurfaceVecsTCrossings = new Vector3[surfaceMeshVecs.Length];
				Array.Copy(surfaceMeshVecs, tmpSurfaceVecsTCrossings, surfaceMeshVecs.Length);
			}
			tmpSurfaceMeshVecs = OODODOQDCC.OCOOCQDCDD(this, elInt, controlPoints, distance, defaultDistance, surfaceMeshVecs, ref tmpSurfaceVecsTCrossings, multiplyFactor, angle, curveStrength);
			OCQOCDODDQ.ODQQQCOCCD(this, elInt);
			OCQOCDODDQ.OCDOQOOCCC(this);
			if (crossingElements[2].connectedRoad != null && crossingElements[elInt].connectedRoad != crossingElements[2].connectedRoad)
			{
				crossingElements[2].connectedRoad.OCQOQCDCQC(ignorePrefabAlignment: true, forceAutoRotate: false);
			}
			if (crossingElements[3].connectedRoad != null && crossingElements[elInt].connectedRoad != crossingElements[3].connectedRoad)
			{
				crossingElements[3].connectedRoad.OCQOQCDCQC(ignorePrefabAlignment: true, forceAutoRotate: false);
			}
		}
	}

	public void OOODCOOOCQ(List<int> affectedVecs, List<Vector2> tmpVecs)
	{
		Vector3[] array = (Vector3[])meshVecs.Clone();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].x = tmpVecs[i].x;
			array[i].z = tmpVecs[i].y;
		}
		base.gameObject.GetComponent<MeshFilter>().sharedMesh.vertices = array;
	}

	public void OQOQDDOCDC(bool ignorePriority, ERModularRoad road)
	{
		OQQCDODDQQ(forceFlag: false);
		if (tmpSurfaceMeshVecs == null)
		{
			tmpSurfaceMeshVecs = new Vector3[surfaceMeshVecs.Length];
			Array.Copy(surfaceMeshVecs, tmpSurfaceMeshVecs, surfaceMeshVecs.Length);
		}
		else if (tmpSurfaceMeshVecs.Length == 0)
		{
			tmpSurfaceMeshVecs = new Vector3[surfaceMeshVecs.Length];
			Array.Copy(surfaceMeshVecs, tmpSurfaceMeshVecs, surfaceMeshVecs.Length);
		}
		OCQOCDODDQ.OCDOQOOCCC(this);
		CheckPlanarUVs();
		if (baseScript == null)
		{
			if ((bool)base.transform.parent && (bool)base.transform.parent.parent)
			{
				baseScript = base.transform.parent.parent.GetComponent<ERModularBase>();
			}
			if (baseScript == null)
			{
				baseScript = UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase;
				if (baseScript == null)
				{
					return;
				}
			}
		}
		if (baseScript.aiTraffic && !isFlexConnector && !isCustomPrefab && crossingsScript != null)
		{
			if (siblings.Count == 0)
			{
				PopulateSiblingsList();
			}
			bool hasLaneControlData = false;
			for (int i = 0; i < siblings.Count; i++)
			{
				if (siblings[i] == null)
				{
					return;
				}
				if (siblings[i].laneData == null)
				{
					siblings[i].laneData = ERLaneData.CreateInstance();
				}
				ERLaneData laneData = siblings[i].laneData;
				if (laneData.connectors.Count > 0)
				{
					hasLaneControlData = true;
				}
				siblings[i].dir = -crossingElements[i].centerPoint.normalized;
				if (siblings[i].rightRoundingPoints.Count == 0)
				{
					siblings[i].rightRoundingPoints.Add(crossingElements[i].rightRoadpoint);
				}
				else
				{
					siblings[i].rightRoundingPoints[0] = crossingElements[i].rightRoadpoint;
				}
				if (siblings[i].leftRoundingPoints.Count == 0)
				{
					siblings[i].leftRoundingPoints.Add(crossingElements[i].leftRoadpoint);
				}
				else
				{
					siblings[i].leftRoundingPoints[0] = crossingElements[i].leftRoadpoint;
				}
			}
			if (crossingsScript == null)
			{
				crossingsScript = base.gameObject.GetComponent<ERCrossings>();
			}
			QDDDQODDQDQDQDD.OQODQQQCOC(crossingsScript);
			QDDDQODDQDQDQDD.OQCDQDQOOO(hasLaneControlData);
		}
		Vector3 position = base.transform.position;
		Vector3 eulerAngles = base.transform.eulerAngles;
		List<ERModularRoad> list = new List<ERModularRoad>();
		for (int j = 0; j < crossingElements.Count; j++)
		{
			if (!(crossingElements[j].connectedRoad != null) || !(!crossingElements[j].rotationPriority || ignorePriority))
			{
				continue;
			}
			ERModularRoad component = crossingElements[j].connectedRoad.GetComponent<ERModularRoad>();
			bool flag = false;
			if (crossingElements[j].connectedMarker == 0)
			{
				if (component.startConnectionSegment == j && component.startPrefabScript == this)
				{
					flag = true;
				}
			}
			else if (component.endConnectionSegment == j && component.endPrefabScript == this)
			{
				flag = true;
			}
			if (!flag)
			{
				continue;
			}
			Vector3 position2 = base.transform.TransformPoint(crossingElements[j].centerPoint);
			if (!isIConnector)
			{
				if (component.markersExt.Count <= crossingElements[j].connectedMarker || crossingElements[j].connectedMarker < 0)
				{
					crossingElements[j].connectedRoad = null;
					return;
				}
				component.markersExt[crossingElements[j].connectedMarker].position = position2;
			}
			int num = crossingElements[j].roadShapeVecs.Count + crossingElements[j].sidewalkLeftVecs.Count + crossingElements[j].sidewalkRightVecs.Count;
			if (crossingElements[j].roadType == crossingElements[j].connectedRoad.roadType || crossingElements[j].connectedRoad.roadType == 0.0)
			{
				bool flag2 = false;
				if (!isIConnector && !isCustomPrefab && crossingElements[j].roadShapeVecsString != crossingElements[j].connectedRoad.roadShapeString)
				{
					flag2 = true;
				}
				if (!isIConnector && isCustomPrefab && crossingElements[j].roadShapeMatchCount != crossingElements[j].connectedRoad.roadShapeMatchCount)
				{
					flag2 = true;
				}
				if (flag2)
				{
					crossingElements[j].connectedRoad.nodeWithinRange = crossingElements[j].connectedMarker;
					if (crossingElements[j].connectedMarker == 0)
					{
						crossingElements[j].connectedRoad.ODDDCDQCCO(this, j, reverse: true, uvReverse: true, UpdateResolutionFlag: false);
						OOCQQOOQOD.OCOCOCCDOO(baseScript, this, j, crossingElements[j].connectedRoad, 0);
					}
					else
					{
						crossingElements[j].connectedRoad.ODDDCDQCCO(this, j, reverse: false, uvReverse: false, UpdateResolutionFlag: false);
						OOCQQOOQOD.OCOCOCCDOO(baseScript, this, j, crossingElements[j].connectedRoad, 1);
					}
				}
			}
			bool flag3 = false;
			if (isFlexConnector && siblings.Count > j && !siblings[j].hasChanged && oldPosition == position && oldRotation == eulerAngles)
			{
				flag3 = true;
			}
			if (OOCCOODCOO(list, component) && !flag3)
			{
				list.Add(component);
			}
		}
		oldPosition = position;
		oldRotation = eulerAngles;
		for (int k = 0; k < list.Count; k++)
		{
			if (road != list[k])
			{
				list[k].OCQOQCDCQC(ignorePrefabAlignment: true, forceAutoRotate: false);
			}
		}
		ERCrossingPrefabs[] componentsInChildren = base.gameObject.GetComponentsInChildren<ERCrossingPrefabs>();
		ERCrossingPrefabs[] array = componentsInChildren;
		foreach (ERCrossingPrefabs eRCrossingPrefabs in array)
		{
			if (eRCrossingPrefabs != this && eRCrossingPrefabs.transform != base.transform)
			{
				eRCrossingPrefabs.OQOQDDOCDC(ignorePriority: true, null);
			}
		}
	}

	public void OQQODODQCQ()
	{
		OQQCDODDQQ(forceFlag: false);
		CheckPlanarUVs();
		if (!isRoundabout)
		{
			OCQOCDODDQ.ODCOOOQQQD(this, tmpMeshVecs, ref surfaceMeshVecs);
		}
		else
		{
			OQCDCDQCCD.OQQODODQCQ(this, tmpMeshVecs, ref surfaceMeshVecs);
		}
	}

	public void OQQCDODDQQ(bool forceFlag)
	{
		if (baseScript == null)
		{
			if ((bool)base.transform.parent && (bool)base.transform.parent.parent)
			{
				baseScript = base.transform.parent.parent.GetComponent<ERModularBase>();
			}
			if (baseScript == null)
			{
				return;
			}
		}
		if (doTerrainDeformation)
		{
			if ((isCustomPrefab && surroundingDistance != baseScript.minSurrounding) || (isCustomPrefab && surfaceMesh == null) || forceFlag)
			{
				if (crossingElements.Count > 0)
				{
					OOODCDOCOC.OCCCOOOCDO(this, baseScript);
				}
				else
				{
					OOODCDOCOC.OCCCOOOCDO(this, baseScript);
					doTerrainDeformation = false;
					UnityEngine.Debug.Log("EasyRoads3Dv3 Alert: this prefab does not have connections, terrain deformation is not supported yet for this type of prefabs");
				}
				surroundingDistance = baseScript.minSurrounding;
				surfaceMesh = base.gameObject.GetComponent<MeshFilter>().sharedMesh;
				OCQOCDODDQ.OCDOQOOCCC(this);
			}
		}
		else if ((bool)base.transform.Find("surface"))
		{
			UnityEngine.Object.DestroyImmediate(base.transform.Find("surface").gameObject);
		}
	}

	public void CheckPlanarUVs()
	{
		if (planarUVs && (bool)base.gameObject.GetComponent<MeshFilter>() && (bool)base.gameObject.GetComponent<MeshFilter>().sharedMesh)
		{
			Mesh sharedMesh = base.gameObject.GetComponent<MeshFilter>().sharedMesh;
			Vector2[] uv = sharedMesh.uv;
			for (int i = 0; i <= lastVecRoadIndex; i++)
			{
				Vector3 vector = base.transform.TransformPoint(sharedMesh.vertices[i]);
				uv[i] = new Vector2(vector.x, vector.z) * planarTiling;
			}
			sharedMesh.uv = uv;
		}
	}

	public static bool OOCCOODCOO(List<ERModularRoad> affectedObjects, ERModularRoad roadScr)
	{
		for (int i = 0; i < affectedObjects.Count; i++)
		{
			if (affectedObjects[i] == roadScr)
			{
				return false;
			}
		}
		return true;
	}

	public void OCCDCDDOOQ(bool flag)
	{
		for (int i = 0; i < sidewalkControlElements.Count; i++)
		{
			sidewalkControlElements[i].renderFlag = flag;
			sidewalkControlElements[i].leftConnectionHandle = flag;
			crossingElements[sidewalkControlElements[i].crossingElementLeftIndex].includeLeftSidewalk = flag;
			sidewalkControlElements[i].rightConnectionHandle = flag;
			crossingElements[sidewalkControlElements[i].crossingElementRightIndex].includeRightSidewalk = flag;
		}
	}

	public void OODODQQCOD(int el)
	{
		for (int i = 0; i < crossingElements.Count; i++)
		{
			if (i != el)
			{
				crossingElements[i].rotationPriority = false;
			}
		}
	}

	public bool HasConnections()
	{
		for (int i = 0; i < crossingElements.Count; i++)
		{
			if (crossingElements[i].connectedRoad != null)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasConnectionsFull()
	{
		for (int i = 0; i < crossingElements.Count; i++)
		{
			if (!(crossingElements[i].connectedRoad != null))
			{
				continue;
			}
			if (crossingElements[i].connectedRoad.startPrefabScript == this)
			{
				if (crossingElements[i].connectedRoad.endPrefabScript != null && crossingElements[i].connectedRoad.endPrefabScript.isCustomPrefab)
				{
					return true;
				}
			}
			else if (crossingElements[i].connectedRoad.startPrefabScript != null && crossingElements[i].connectedRoad.startPrefabScript.isCustomPrefab)
			{
				return true;
			}
		}
		return false;
	}

	public void OOQOQQODCD()
	{
		for (int i = 0; i < siblings.Count; i++)
		{
			QDOODOQQDQODD qDOODOQQDQODD = crossingElements[i];
			List<Vector3> list = new List<Vector3>();
			if (!(qDOODOQQDQODD.connectedRoad != null))
			{
				continue;
			}
			if (qDOODOQQDQODD.connectedRoad.startPrefabScript == this && qDOODOQQDQODD.connectedRoad.startConnectionSegment == i)
			{
				for (int j = 0; j < 3; j++)
				{
					if (qDOODOQQDQODD.connectedRoad.markersExt.Count > j)
					{
						list.Add(qDOODOQQDQODD.connectedRoad.markersExt[j].position);
					}
					else
					{
						list.Add(qDOODOQQDQODD.connectedRoad.markersExt[1].position);
					}
				}
			}
			else if (qDOODOQQDQODD.connectedRoad.endPrefabScript == this && qDOODOQQDQODD.connectedRoad.endConnectionSegment == i)
			{
				for (int num = qDOODOQQDQODD.connectedRoad.markersExt.Count - 1; num >= 0; num--)
				{
					list.Add(qDOODOQQDQODD.connectedRoad.markersExt[num].position);
				}
				if (list.Count == 2)
				{
					list.Add(qDOODOQQDQODD.connectedRoad.markersExt[0].position);
				}
			}
			crossingsScript.OOQCQDQCOO(i, list[0], list[1], list[2], update: false);
			siblings[i].angle = 360f - QDDDQODDQDQDQDD.OOCDQCOCQO(siblings[i].angleControlPoint, Vector3.forward, Vector3.up);
		}
	}

	public void OCODDQDQCC(int el, int startend)
	{
		if (startend == 0)
		{
			crossingElements[el].connectedRoad.startPrefabScript = null;
			crossingElements[el].connectedRoad.startConnectionSegment = 0;
		}
		else
		{
			crossingElements[el].connectedRoad.endPrefabScript = null;
			crossingElements[el].connectedRoad.endConnectionSegment = 0;
		}
		crossingElements[el].connectedRoad = null;
		crossingElements[el].connectedMarker = -1;
		if (el == 0)
		{
			if (crossingElements[1].connectedRoad == null)
			{
				UnityEngine.Object.DestroyImmediate(base.gameObject);
			}
			else
			{
				base.gameObject.GetComponent<ERIConnector>().OCQOQCDCQC(null);
			}
		}
		else if (crossingElements[0].connectedRoad == null)
		{
			UnityEngine.Object.DestroyImmediate(base.gameObject);
		}
		else
		{
			base.gameObject.GetComponent<ERIConnector>().OCQOQCDCQC(null);
		}
	}

	public void PopulateSiblingsList()
	{
		for (int i = 0; i < crossingElements.Count; i++)
		{
			siblings.Add(ERConnectionSibling.CreateInstance(null, 0f, crossingElements[i].centerPoint, null, null));
			if (crossingElements[i].connectedRoad != null)
			{
				siblings[i].road = crossingElements[i].connectedRoad;
			}
			siblings[i].roadTypeIndex = QDQDOOQQDQODD.GetRoadTypeByID(baseScript.roadTypes, crossingElements[i].roadType);
			siblings[i].roadType = QDQDOOQQDQODD.GetRoadTypeElByID(baseScript.roadTypes, crossingElements[i].roadType);
		}
		QDDDQODDQDQDQDD.OQODQQQCOC(crossingsScript);
	}

	public void InitFlexConnector()
	{
		for (int i = 0; i < crossingElements.Count; i++)
		{
			int num = 0;
			int num2 = 0;
			if (!(crossingElements[i].connectedRoad != null))
			{
				continue;
			}
			if (crossingElements[i].connectedRoad.startPrefabScript == this)
			{
				if (crossingElements[i].connectedRoad.endPrefabScript == this && crossingElements[i].connectedRoad.endConnectionSegment == i)
				{
					if (tCrossing && i == 3)
					{
						crossingElements[i].connectedRoad.endConnectionSegment--;
					}
					continue;
				}
				crossingElements[i].connectedRoad.startConnectionSegment = i;
				if (tCrossing && i == 3)
				{
					crossingElements[i].connectedRoad.startConnectionSegment--;
				}
			}
			else if (crossingElements[i].connectedRoad.endPrefabScript == this)
			{
				crossingElements[i].connectedRoad.endConnectionSegment = i;
				if (tCrossing && i == 3)
				{
					crossingElements[i].connectedRoad.endConnectionSegment--;
				}
			}
		}
		siblings.Clear();
		bool flag = false;
		int num3 = 0;
		for (int j = 0; j < crossingElements.Count; j++)
		{
			if (crossingElements[j].connectedRoad != null)
			{
				flag = true;
				num3++;
			}
		}
		if (num3 <= 8)
		{
			for (int k = 0; k < crossingElements.Count; k++)
			{
				if (tCrossing)
				{
					if (tCrossingLeftRight == 1 && k == 2)
					{
						if (crossingElements[3].connectedRoad != null)
						{
						}
						crossingElements.RemoveAt(k);
						tCrossing = false;
						k--;
						continue;
					}
					if (tCrossingLeftRight == 0 && k == 3)
					{
						crossingElements.RemoveAt(k);
						tCrossing = false;
						continue;
					}
				}
				siblings.Add(ERConnectionSibling.CreateInstance(null, 0f, crossingElements[k].centerPoint, null, null));
				if (crossingElements[k].connectedRoad != null)
				{
					siblings[k].road = crossingElements[k].connectedRoad;
				}
				siblings[k].roadTypeIndex = QDQDOOQQDQODD.GetRoadTypeByID(baseScript.roadTypes, crossingElements[k].roadType);
				siblings[k].roadType = QDQDOOQQDQODD.GetRoadTypeElByID(baseScript.roadTypes, crossingElements[k].roadType);
			}
		}
		OOQOQQODCD();
		crossingsScript.ODOCCDCQOC();
	}

	public void AttachRoadToFlexConnector(ERModularBase scr, float OCCDOQCODC, Vector3 OCCQOCQOQD)
	{
		siblings.Add(ERConnectionSibling.CreateInstance(scr.OCCQOOOQQO, OCCDOQCODC, OCCQOCQOQD, null, siblings));
		if (scr.OCODDDQOQC == 0)
		{
			scr.OCCQOOOQQO.startPrefabScript = this;
			scr.OCCQOOOQQO.startConnectionSegment = siblings.Count - 1;
		}
		else
		{
			scr.OCCQOOOQQO.endPrefabScript = this;
			scr.OCCQOOOQQO.endConnectionSegment = siblings.Count - 1;
		}
		if (crossingElements.Count < siblings.Count)
		{
			crossingElements.Add(new QDOODOQQDQODD());
			crossingElements[crossingElements.Count - 1].roadShapeMatchCount = scr.OCCQOOOQQO.roadShape.Count;
		}
		crossingElements[siblings.Count - 1].connectedRoad = scr.OCCQOOOQQO;
		crossingElements[siblings.Count - 1].connectedMarker = scr.OCODDDQOQC;
		siblings[siblings.Count - 1].hasChanged = true;
	}

	public void OQQQQOOCDO(int index)
	{
		for (int i = 0; i < crossingElements.Count; i++)
		{
			if (siblings[i].laneData == null)
			{
				continue;
			}
			ERLaneData laneData = siblings[i].laneData;
			for (int j = 0; j < laneData.connectors.Count; j++)
			{
				if (laneData.connectors[j].endConnectionIndex == index)
				{
					laneData.connectors.RemoveAt(j);
					j--;
				}
				else if (laneData.connectors[j].endConnectionIndex > index)
				{
					laneData.connectors[j].endConnectionIndex--;
				}
			}
		}
		for (int k = 0; k < crossingElements.Count; k++)
		{
			if (crossingElements[k].connectedRoad != null)
			{
				if (crossingElements[k].connectedRoad.startPrefabScript == this)
				{
				}
				if (crossingElements[k].connectedRoad.endPrefabScript == this)
				{
				}
				crossingElements[k].connectedRoad.startSegmentIntAdjusted = false;
				crossingElements[k].connectedRoad.endSegmentIntAdjusted = false;
			}
		}
		for (int l = index; l < crossingElements.Count; l++)
		{
			if (crossingElements[l].connectedRoad != null)
			{
				if (crossingElements[l].connectedRoad.startPrefabScript == this && crossingElements[l].connectedRoad.startConnectionSegment >= l && !crossingElements[l].connectedRoad.startSegmentIntAdjusted)
				{
					crossingElements[l].connectedRoad.startConnectionSegment--;
					crossingElements[l].connectedRoad.startSegmentIntAdjusted = true;
				}
				if (crossingElements[l].connectedRoad.endPrefabScript == this && crossingElements[l].connectedRoad.endConnectionSegment >= l && !crossingElements[l].connectedRoad.endSegmentIntAdjusted)
				{
					crossingElements[l].connectedRoad.endConnectionSegment--;
					crossingElements[l].connectedRoad.endSegmentIntAdjusted = true;
				}
			}
		}
	}

	public void SetElementInfo(int index, int sourceIndex)
	{
		int num = 0;
		if (isIConnector)
		{
			sourceIndex = ((index == 0) ? 1 : 0);
		}
		crossingElements[index].roadType = crossingElements[sourceIndex].roadType;
		crossingElements[index].roadMaterials = new Material[crossingElements[sourceIndex].roadMaterials.Length];
		Array.Copy(crossingElements[sourceIndex].roadMaterials, crossingElements[index].roadMaterials, crossingElements[sourceIndex].roadMaterials.Length);
	}

	public static void ODDQDDQOOD()
	{
		ERCrossingPrefabs[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERCrossingPrefabs)) as ERCrossingPrefabs[];
		ERCrossingPrefabs[] array2 = array;
		foreach (ERCrossingPrefabs eRCrossingPrefabs in array2)
		{
			if (eRCrossingPrefabs.surfaceObject != null)
			{
				if (eRCrossingPrefabs.gameObject.GetComponent<ERCrossings>() != null && eRCrossingPrefabs.surfaceObject != null)
				{
					OCQOCDODDQ.ODCOOOQQQD(eRCrossingPrefabs, eRCrossingPrefabs.tmpMeshVecs, ref eRCrossingPrefabs.surfaceMeshVecs);
				}
			}
			else if (eRCrossingPrefabs.gameObject.GetComponent<ERRoundabouts>() != null && eRCrossingPrefabs.surfaceObject != null)
			{
				OQCDCDQCCD.OQQODODQCQ(eRCrossingPrefabs, eRCrossingPrefabs.tmpMeshVecs, ref eRCrossingPrefabs.surfaceMeshVecs);
			}
			else if (eRCrossingPrefabs.isCustomPrefab && eRCrossingPrefabs.doTerrainDeformation && eRCrossingPrefabs.surfaceObject != null && eRCrossingPrefabs.crossingElements.Count > 0)
			{
				OOODCDOCOC.OCCCOOOCDO(eRCrossingPrefabs, eRCrossingPrefabs.baseScript);
			}
		}
	}

	public static bool OQCDCDOOCD(Vector3 pTarget, Vector3 pSource, Vector3 pCheck)
	{
		Vector3 normalized = (pTarget - pSource).normalized;
		Vector3 normalized2 = (pCheck - pSource).normalized;
		if (Vector3.Cross(normalized, normalized2).y < 0f)
		{
			return false;
		}
		return true;
	}
}
[Serializable]
public class ERBlendVecs
{
	public int verticeIndex;

	public int meshIndex;

	public float blendWeight;

	public int connection;

	public int blendType;

	public ERBlendVecs(int index, int mIndex, float weight, int conn, int type)
	{
		verticeIndex = index;
		meshIndex = mIndex;
		blendWeight = weight;
		connection = conn;
		blendType = type;
	}
}
[Serializable]
public class QDOODOQQDQODD
{
	public Vector3 centerPoint = Vector3.zero;

	public Vector3 tmpCenterPoint = Vector3.zero;

	public Vector3 stageCenterPoint = Vector3.zero;

	public Vector3 tmpStageCenterPoint = Vector3.zero;

	public List<ERBlendVecs> blendData = new List<ERBlendVecs>();

	public Vector3 controlPointV3 = Vector3.zero;

	public Vector2 controlPoint = Vector2.zero;

	public float blendDistance = 0f;

	public float extendBounds = 0f;

	public List<Vector3> blendCornerPoints = new List<Vector3>();

	public List<int> blendCornerPointInts = new List<int>();

	public List<float> blendCornerPointWeights = new List<float>();

	public List<Vector3> blendCornerPointsTransformed = new List<Vector3>();

	public float blendRatio = 1f;

	public float curveStrength = 0f;

	public List<Vector2> roadShapeVecs = new List<Vector2>();

	public string roadShapeVecsString = "";

	public int roadShapeMatchCount = 0;

	public List<float> roadShapeUVY = new List<float>();

	public List<float> roadShapeUVY2 = new List<float>();

	public List<bool> hardEdge = new List<bool>();

	public List<int> roadShapeMaterialInts = new List<int>();

	public List<Vector2> sidewalkLeftVecs = new List<Vector2>();

	public List<float> sidewalkLeftUVY = new List<float>();

	public List<int> sidewalkLeftMaterialInts = new List<int>();

	public List<Vector2> sidewalkRightVecs = new List<Vector2>();

	public List<float> sidewalkRightUVY = new List<float>();

	public List<int> sidewalkRightMaterialInts = new List<int>();

	public List<ERConnectionVecs> connectionVecs = new List<ERConnectionVecs>();

	public List<int> connectionVecInts = new List<int>();

	public List<int> fullConnectionVecInts = new List<int>();

	public List<int> sidewalkLeftConnectionVecInts = new List<int>();

	public List<int> sidewalkRightConnectionVecInts = new List<int>();

	public List<bool> doConnectionTri = new List<bool>();

	public List<int> outerVecInts = new List<int>();

	public bool rotationPriority = false;

	public float centerPointAngle = 1000f;

	public ERModularRoad connectedRoad = null;

	public int connectedMarker = -1;

	public GameObject connectedRoadGO = null;

	public bool includeLeftSidewalk = true;

	public bool includeRightSidewalk = true;

	public Material roadMaterial;

	public Material[] roadMaterials;

	public float centerPointPercentage = 0.5f;

	private float á = 0f;

	public int leftIndent = -1;

	public int rightIndent = -1;

	public int leftSurrounding = -1;

	public int rightSurrounding = -1;

	public Vector3 leftIndentV3;

	public Vector3 leftSurroundingV3;

	public Vector3 rightIndentV3;

	public Vector3 rightSurroundingV3;

	public Vector3 leftRoadpoint;

	public Vector3 rightRoadpoint;

	public int leftCornerInt = -1;

	public int rightCornerInt = -1;

	public int leftIndentInt = 0;

	public int rightIndentInt = 0;

	public int leftInt = 0;

	public int rightInt = 0;

	public int leftIntFull = 0;

	public int rightIntFull = 0;

	public Vector3 alignmentHandleVec;

	public float additionalIndentDistance = 0f;

	public float connectionAngle = 0f;

	public Vector3 alignmentHandleVecRotationGizmo = Vector3.zero;

	public bool inwards = false;

	public double roadType = 0.0;

	public double roadTypeTimestamp = 0.0;
}
[Serializable]
public class ERConnectionData
{
	public ERRoad road;

	public int marker;

	public int connectionIndex;

	public Vector3 position;

	public ERConnectionData(ERRoad rd, int rm, int index)
	{
		road = rd;
		marker = rm;
		connectionIndex = index;
	}
}
public class ERRoad
{
	public ERModularRoad roadScript;

	public GameObject gameObject;

	public string str = "EasyRoads3Dv3v3 Warning: The free version does not support API calls";

	public ERRoad()
	{
	}

	public ERRoad(ERModularRoad scr)
	{
		roadScript = scr;
		gameObject = scr.gameObject;
	}

	public void AddInititialMarkers(Vector3 pos)
	{
		roadScript.markersExt.Add(ERMarkerExt.CreateInstance(pos, roadScript, 0));
	}

	public void AddMarker(Vector3 pos)
	{
		if (roadScript.endPrefabScript == null)
		{
			if (roadScript.snapToTerrain)
			{
				roadScript.baseScript.OCDDQOCDCO(ref pos);
			}
			roadScript.markersExt.Add(ERMarkerExt.CreateInstance(pos, roadScript, roadScript.markersExt.Count));
		}
		Refresh();
	}

	public void ClampUVs(bool value)
	{
		roadScript.lockUVs = !value;
	}

	public void FlipTexture()
	{
		Material[] sharedMaterials = roadScript.gameObject.GetComponent<MeshRenderer>().sharedMaterials;
		int num = 0;
		for (int i = 0; i < sharedMaterials.Length; i++)
		{
			if (sharedMaterials[i] == roadScript.roadMaterial)
			{
				num = i;
				break;
			}
		}
		for (int j = 0; j < roadScript.roadShapeUVs.Count; j++)
		{
			if (roadScript.roadShapeMaterialInts[j] == num)
			{
				roadScript.roadShapeUVs[j] = 1f - roadScript.roadShapeUVs[j];
				if (roadScript.roadShapeUVs2.Count > j)
				{
					roadScript.roadShapeUVs2[j] = 1f - roadScript.roadShapeUVs2[j];
				}
			}
		}
		Refresh();
	}

	public void AddMarkers(Vector3[] pos)
	{
		if (roadScript.endPrefabScript == null)
		{
			for (int i = 0; i < pos.Length; i++)
			{
				roadScript.markersExt.Add(ERMarkerExt.CreateInstance(pos[i], roadScript, roadScript.markersExt.Count));
			}
		}
		Refresh();
	}

	public void InsertMarker(Vector3 pos)
	{
		roadScript.OQCCQDDOQD(pos);
		Refresh();
	}

	public void InsertMarkerAt(Vector3 pos, int index)
	{
		if (roadScript.markersExt.Count >= index + 1 && index >= 0)
		{
			roadScript.markersExt.Insert(index, ERMarkerExt.CreateInstance(pos, roadScript, index));
			Refresh();
		}
	}

	public void DeleteMarker(int i)
	{
		if (roadScript.markersExt.Count > i && i >= 0)
		{
			roadScript.markersExt.RemoveAt(i);
			Refresh();
		}
	}

	public void SetLayer(int layer)
	{
		roadScript.gameObject.layer = (roadScript.layer = layer);
	}

	public void SetTag(string tag)
	{
		if (!string.IsNullOrEmpty(tag))
		{
			roadScript.gameObject.tag = (roadScript.tag = tag);
		}
	}

	public void SetWidth(float width)
	{
		roadScript.roadWidth = width;
		roadScript.roadShape.Clear();
		Refresh();
	}

	public float GetWidth()
	{
		if (roadScript != null)
		{
			return roadScript.roadWidth;
		}
		return 0f;
	}

	public ERRoadType GetRoadType(ERRoadType[] roadTypes)
	{
		ERRoadType[] roadTypes2 = roadScript.baseScript.GetRoadTypes();
		return roadScript.GetRoadType(roadTypes2);
	}

	public ERRoadType GetRoadType()
	{
		ERRoadType[] roadTypes = roadScript.baseScript.GetRoadTypes();
		return roadScript.GetRoadType(roadTypes);
	}

	public bool SetRoadType(ERRoadType roadType)
	{
		if (roadType == null)
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3: the passed road type is null");
			return false;
		}
		ERRoadType[] roadTypes = roadScript.baseScript.GetRoadTypes();
		QDQDOOQQDQODD roadType2 = ERRoadType.GetRoadType(roadType, roadScript.baseScript);
		if (roadType2 != null)
		{
			ODCCODOCQQ.UpdateRoadTypeByRoad(roadScript.baseScript, roadScript, -1, roadType2);
			return true;
		}
		return false;
	}

	public bool SetMarkerControlType(int marker, ERMarkerControlType type)
	{
		if (type == ERMarkerControlType.Circular && roadScript.markersExt.Count <= 2)
		{
			UnityEngine.Debug.Log("The circular controller type cannot be used on a two marker road");
			return false;
		}
		if (roadScript.markersExt.Count > marker && marker >= 0)
		{
			roadScript.markersExt[marker].SetControlType(type);
			Refresh();
			return true;
		}
		return false;
	}

	public bool SetSplineStrength(int marker, float strength)
	{
		if (roadScript.markersExt.Count > marker && marker >= 0)
		{
			if (strength < 0.01f)
			{
				strength = 0.01f;
			}
			if (strength > 1f)
			{
				strength = 1f;
			}
			roadScript.markersExt[marker].splineStrength = strength;
			Refresh();
			return true;
		}
		return false;
	}

	public float GetSplineStrength(int marker)
	{
		if (roadScript.markersExt.Count > marker && marker >= 0)
		{
			return roadScript.markersExt[marker].splineStrength;
		}
		return 0f;
	}

	public void IsSideObject(bool isSideObject)
	{
		roadScript.isSideObject = isSideObject;
	}

	public ERRoad InsertIConnector(int index)
	{
		ERCrossingPrefabs pScript = null;
		return InsertIConnectorCore(index, ref pScript);
	}

	public ERRoad InsertIConnector(int index, string connectionName)
	{
		ERCrossingPrefabs pScript = null;
		ERRoad result = InsertIConnectorCore(index, ref pScript);
		pScript.gameObject.name = connectionName;
		return result;
	}

	public ERRoad InsertIConnector(int index, string connectionName, out ERConnection connection)
	{
		ERCrossingPrefabs pScript = null;
		ERRoad result = InsertIConnectorCore(index, ref pScript);
		pScript.gameObject.name = connectionName;
		connection = new ERConnection(pScript.gameObject, pScript.gameObject.name);
		return result;
	}

	private ERRoad InsertIConnectorCore(int index, ref ERCrossingPrefabs pScript)
	{
		ERModularRoad eRModularRoad = roadScript;
		if (index < 0 || index >= eRModularRoad.markersExt.Count)
		{
			UnityEngine.Debug.LogWarning("EasyRoads3Dv3: road " + eRModularRoad.name + " no marker exists at index: " + index);
			return null;
		}
		int num = 0;
		ERModularRoad eRModularRoad2 = null;
		if (index != 0 && index != eRModularRoad.markersExt.Count - 1)
		{
			eRModularRoad2 = OCQOQOOOCO.OCQDOCOODD(eRModularRoad, index);
		}
		pScript = eRModularRoad.baseScript.AttachConnector(eRModularRoad, index);
		ERRoad result = null;
		if (eRModularRoad2 != null)
		{
			eRModularRoad2.nodeWithinRange = 0;
			OCQOQOOOCO.ODQDCODODC(eRModularRoad2, pScript.transform.position, pScript, 1, reverse: true, uvReverse: true, forceAutoRotate: false);
			result = new ERRoad(eRModularRoad2);
		}
		Refresh();
		return result;
	}

	public ERRoad SplitRoad(int markerIndex)
	{
		ERModularRoad eRModularRoad = SplitRoadExt(markerIndex);
		if (eRModularRoad != null)
		{
			eRModularRoad.road = new ERRoad(eRModularRoad);
			return eRModularRoad.road;
		}
		return null;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	private ERModularRoad SplitRoadExt(int markerIndex)
	{
		if (markerIndex < 1 || markerIndex >= roadScript.markersExt.Count - 1)
		{
			UnityEngine.Debug.LogWarning("EasyRoads3Dv3: the road cannot be split at marker " + markerIndex);
			return null;
		}
		return OCQOQOOOCO.OCQDOCOODD(roadScript, markerIndex);
	}

	public void SetSideObjects(List<ERSORoadExt> soDataExt)
	{
		roadScript.soDataExt.Clear();
		roadScript.soDataExt = new List<ERSORoadExt>();
		for (int i = 0; i < soDataExt.Count; i++)
		{
			roadScript.soDataExt.Add(ERSORoadExt.CreateInstance(soDataExt[i].sideObject));
			if (soDataExt[i].active)
			{
				roadScript.soDataExt[roadScript.soDataExt.Count - 1].active = true;
			}
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].autoGenerate = soDataExt[i].autoGenerate;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].markerActive = soDataExt[i].markerActive;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].xPosition = soDataExt[i].xPosition;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].randomMinXPosition = soDataExt[i].randomMinXPosition;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].randomMaxXPosition = soDataExt[i].randomMaxXPosition;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].yPosition = soDataExt[i].yPosition;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].randomMinYPosition = soDataExt[i].randomMinYPosition;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].randomMaxYPosition = soDataExt[i].randomMaxYPosition;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].minRandomXPositionDistance = soDataExt[i].minRandomXPositionDistance;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].maxRandomXPositionDistance = soDataExt[i].maxRandomXPositionDistance;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].minRandomYPositionDistance = soDataExt[i].minRandomYPositionDistance;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].maxRandomYPositionDistance = soDataExt[i].maxRandomYPositionDistance;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].randomMinRotation = soDataExt[i].randomMinRotation;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].randomMaxRotation = soDataExt[i].randomMaxRotation;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].minRandomRotationDistance = soDataExt[i].minRandomRotationDistance;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].maxRandomRotationDistance = soDataExt[i].maxRandomRotationDistance;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].lockRandomRotations = soDataExt[i].lockRandomRotations;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].distanceChange = soDataExt[i].distanceChange;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].xPosChange = soDataExt[i].xPosChange;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].yPosChange = soDataExt[i].yPosChange;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].rotationAngleChange = soDataExt[i].rotationAngleChange;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].rotationDistanceChange = soDataExt[i].rotationDistanceChange;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].randomXPositionChange = soDataExt[i].randomXPositionChange;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].xPositionDistanceChange = soDataExt[i].xPositionDistanceChange;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].yPositionDistanceChange = soDataExt[i].yPositionDistanceChange;
			roadScript.soDataExt[roadScript.soDataExt.Count - 1].randomXPositionChange = soDataExt[i].randomXPositionChange;
		}
	}

	public void SetSplatmap(bool active)
	{
		roadScript.splatMapActive = active;
	}

	public void SetSplatmap(bool active, int splatIndex, int expand, int smoothLevel, float opacity)
	{
		roadScript.splatMapActive = active;
		roadScript.splatIndex = splatIndex;
		roadScript.expandLevel = expand;
		roadScript.smoothLevel = smoothLevel;
		roadScript.splatOpacity = opacity;
	}

	public void SetMaterial(Material mat)
	{
		roadScript.roadMaterial = mat;
		if (roadScript.roadMaterials == null)
		{
			roadScript.roadMaterials = new Material[1];
		}
		roadScript.roadMaterials[0] = (roadScript.roadMaterial = mat);
		roadScript.gameObject.GetComponent<MeshRenderer>().sharedMaterials = roadScript.roadMaterials;
		Refresh();
	}

	public void SetMarkerPosition(int marker, Vector3 vec)
	{
		if (roadScript.markersExt.Count > marker && marker >= 0)
		{
			roadScript.markersExt[marker].position = vec;
			Refresh();
		}
	}

	public void SetResolution(float res)
	{
		roadScript.faceDistance = res;
		Refresh();
	}

	public void IsStatic(bool value)
	{
		roadScript.gameObject.isStatic = value;
	}

	public bool IsStatic()
	{
		return roadScript.gameObject.isStatic;
	}

	public float GetResolution()
	{
		return roadScript.faceDistance;
	}

	public void SetAngleThreshold(float res)
	{
		roadScript.angleTreshold = res;
		Refresh();
	}

	public float GetAngleTreshold(float res)
	{
		return roadScript.angleTreshold;
	}

	public bool ClosedTrack(bool value)
	{
		if (roadScript.startPrefabScript == null && roadScript.endPrefabScript == null)
		{
			roadScript.closedTrack = value;
			Refresh();
			return true;
		}
		return false;
	}

	public void FollowTerrainContours(bool value)
	{
		roadScript.followTerrainContours = value;
		for (int i = 0; i < roadScript.markersExt.Count; i++)
		{
			roadScript.markersExt[i].followTerrainContours = value;
			if (value && roadScript.baseScript != null)
			{
				Vector3 pos = roadScript.markersExt[i].position;
				roadScript.baseScript.OCDDQOCDCO(ref pos);
				roadScript.markersExt[i].position = pos;
			}
		}
		Refresh();
	}

	[Obsolete("obsolete")]
	public void SetFollowTerrainContoursOffset(float value)
	{
		roadScript.terrainContoursOffset = value;
		Refresh();
	}

	public void FollowTerrainContourThreshold(float value)
	{
		roadScript.terrainContoursOffset = value;
		Refresh();
	}

	public void FollowTerrainContours(int markerIndex, bool value)
	{
		if (roadScript.markersExt.Count > markerIndex && markerIndex >= 0)
		{
			roadScript.markersExt[markerIndex].followTerrainContours = value;
		}
	}

	public bool IsClosedTrack()
	{
		return roadScript.closedTrack;
	}

	public void SetMarkerPositions(Vector3[] vecs)
	{
		if (vecs.Length != roadScript.markersExt.Count)
		{
			return;
		}
		int num = 0;
		foreach (ERMarkerExt item in roadScript.markersExt)
		{
			item.position = vecs[num];
			num++;
		}
		Refresh();
	}

	public void SetMarkerPositions(Vector3[] vecs, int index)
	{
		if (index + vecs.Length < roadScript.markersExt.Count && index >= 0)
		{
			for (int i = index; i < index + vecs.Length; i++)
			{
				roadScript.markersExt[i].position = vecs[i - index];
			}
			Refresh();
		}
	}

	public Vector3 GetMarkerPosition(int marker)
	{
		if (roadScript.markersExt.Count > marker && marker >= 0)
		{
			return roadScript.markersExt[marker].position;
		}
		return Vector3.zero;
	}

	public Vector3[] GetMarkerPositions()
	{
		List<Vector3> list = new List<Vector3>();
		foreach (ERMarkerExt item in roadScript.markersExt)
		{
			list.Add(item.position);
		}
		return list.ToArray();
	}

	public int GetMarkerCount()
	{
		return roadScript.markersExt.Count;
	}

	public void SetMarkerTilting(float value, int index)
	{
		if (roadScript.markersExt.Count > index && index >= 0)
		{
			roadScript.markersExt[index].rotation = value;
			Refresh();
		}
	}

	public float GetMarkerTilting(int index)
	{
		if (roadScript.markersExt.Count > index && index >= 0)
		{
			return roadScript.markersExt[index].rotation;
		}
		return 0f;
	}

	public void SetMarkerTiltingCenter(float value, int index)
	{
		if (roadScript.markersExt.Count > index && index >= 0)
		{
			if (value > 1f)
			{
				value = 1f;
			}
			else if (value < 0f)
			{
				value = 0f;
			}
			roadScript.markersExt[index].rotationCenter = value;
			Refresh();
		}
	}

	public float GetRadius(int markerIndex)
	{
		if (roadScript.markersExt.Count > markerIndex && markerIndex >= 0)
		{
			if (roadScript.markersExt[markerIndex].controlType == 3)
			{
				return roadScript.markersExt[markerIndex].radius;
			}
			return 0f;
		}
		return 0f;
	}

	public float GetMarkerTiltingCenter(int index)
	{
		if (roadScript.markersExt.Count > index && index >= 0)
		{
			return roadScript.markersExt[index].rotationCenter;
		}
		return 0f;
	}

	public Color GetVertexColor(int index)
	{
		if (roadScript.markersExt.Count > index && index >= 0)
		{
			return roadScript.markersExt[index].customColor;
		}
		return Color.red;
	}

	public void SetVertexColor(int index, Color color)
	{
		if (roadScript.markersExt.Count > index && index >= 0)
		{
			roadScript.markersExt[index].customColor = color;
			Refresh();
		}
	}

	public void SetDistances()
	{
		float num = 0f;
		roadScript.distances.Add(0f);
		for (int i = 1; i < roadScript.soSplinePoints.Count; i++)
		{
			num += Vector3.Distance(roadScript.soSplinePoints[i - 1], roadScript.soSplinePoints[i]);
			roadScript.distances.Add(num);
		}
	}

	public Vector3 GetPosition(float distance, ref int currentElement)
	{
		if (roadScript.distances.Count == 0)
		{
			SetDistances();
		}
		float num = roadScript.distances[currentElement];
		if (distance < 0f)
		{
			return roadScript.soSplinePoints[0];
		}
		if (num <= distance)
		{
			for (int i = currentElement; i < roadScript.distances.Count; i++)
			{
				if (roadScript.distances[i] > distance)
				{
					currentElement = i - 1;
					break;
				}
			}
		}
		else
		{
			for (int num2 = currentElement; num2 < roadScript.distances.Count; num2--)
			{
				if (roadScript.distances[num2] < distance)
				{
					currentElement = num2;
					break;
				}
			}
		}
		if (distance >= roadScript.distances[roadScript.distances.Count - 1])
		{
			currentElement = roadScript.distances.Count - 1;
		}
		Vector3 vector = roadScript.soSplinePoints[0];
		if (currentElement < roadScript.distances.Count - 1)
		{
			float num3 = distance - roadScript.distances[currentElement];
			float num4 = roadScript.distances[currentElement + 1] - roadScript.distances[currentElement];
			vector = Vector3.Lerp(roadScript.soSplinePoints[currentElement], roadScript.soSplinePoints[currentElement + 1], num3 / num4);
		}
		else
		{
			vector = roadScript.soSplinePoints[roadScript.soSplinePoints.Count - 1];
		}
		return vector;
	}

	public Vector3 GetLookatSmooth(float distance, int currentElement)
	{
		if (roadScript.distances.Count == 0)
		{
			SetDistances();
		}
		float num = roadScript.distances[currentElement];
		if (distance < 0f)
		{
			return (roadScript.soSplinePoints[1] - roadScript.soSplinePoints[0]).normalized;
		}
		if (num <= distance)
		{
			for (int i = currentElement; i < roadScript.distances.Count; i++)
			{
				if (roadScript.distances[i] > distance)
				{
					currentElement = i - 1;
					break;
				}
			}
		}
		else
		{
			for (int num2 = currentElement; num2 < roadScript.distances.Count; num2--)
			{
				if (roadScript.distances[num2] < distance)
				{
					currentElement = num2;
					break;
				}
			}
		}
		if (distance >= roadScript.distances[roadScript.distances.Count - 1])
		{
			currentElement = roadScript.distances.Count - 1;
		}
		Vector3 vector = roadScript.soSplinePoints[0];
		Vector3 result;
		if (currentElement < roadScript.distances.Count - 1)
		{
			float num3 = distance - roadScript.distances[currentElement];
			float num4 = roadScript.distances[currentElement + 1] - roadScript.distances[currentElement];
			float num5 = num3 / num4;
			Vector3 normalized = (roadScript.soSplinePoints[currentElement + 1] - roadScript.soSplinePoints[currentElement]).normalized;
			if ((double)num5 > 0.5)
			{
				if (currentElement + 1 < roadScript.distances.Count - 1)
				{
					Vector3 normalized2 = (roadScript.soSplinePoints[currentElement + 2] - roadScript.soSplinePoints[currentElement + 1]).normalized;
					num5 -= 0.5f;
					result = Vector3.Lerp(normalized, normalized2, num5);
				}
				else
				{
					result = normalized;
				}
			}
			else if (currentElement > 0)
			{
				Vector3 normalized3 = (roadScript.soSplinePoints[currentElement] - roadScript.soSplinePoints[currentElement - 1]).normalized;
				num5 += 0.5f;
				result = Vector3.Lerp(normalized3, normalized, num5);
			}
			else
			{
				result = normalized;
			}
		}
		else
		{
			result = (roadScript.soSplinePoints[roadScript.soSplinePoints.Count - 1] - roadScript.soSplinePoints[roadScript.soSplinePoints.Count - 2]).normalized;
		}
		return result;
	}

	[Obsolete("obsolete")]
	public Vector3 GetLookatAtDistanceSmooth(float distance, ref int currentElement)
	{
		if (roadScript.distances.Count == 0)
		{
			SetDistances();
		}
		float num = roadScript.distances[currentElement];
		if (distance < 0f)
		{
			return roadScript.soSplinePoints[0];
		}
		if (num <= distance)
		{
			for (int i = currentElement; i < roadScript.distances.Count; i++)
			{
				if (roadScript.distances[i] > distance)
				{
					currentElement = i - 1;
					break;
				}
			}
		}
		else
		{
			for (int num2 = currentElement; num2 < roadScript.distances.Count; num2--)
			{
				if (roadScript.distances[num2] < distance)
				{
					currentElement = num2;
					break;
				}
			}
		}
		if (distance >= roadScript.distances[roadScript.distances.Count - 1])
		{
			currentElement = roadScript.distances.Count - 1;
		}
		Vector3 vector = roadScript.soSplinePoints[0];
		Vector3 result;
		if (currentElement < roadScript.distances.Count - 1)
		{
			float num3 = distance - roadScript.distances[currentElement];
			float num4 = roadScript.distances[currentElement + 1] - roadScript.distances[currentElement];
			float num5 = num3 / num4;
			Vector3 normalized = (roadScript.soSplinePoints[currentElement + 1] - roadScript.soSplinePoints[currentElement]).normalized;
			if ((double)num5 > 0.5)
			{
				if (currentElement + 1 < roadScript.distances.Count - 1)
				{
					Vector3 normalized2 = (roadScript.soSplinePoints[currentElement + 2] - roadScript.soSplinePoints[currentElement + 1]).normalized;
					num5 -= 0.5f;
					result = Vector3.Lerp(normalized, normalized2, num5);
				}
				else
				{
					result = normalized;
				}
			}
			else if (currentElement > 0)
			{
				Vector3 normalized3 = (roadScript.soSplinePoints[currentElement] - roadScript.soSplinePoints[currentElement - 1]).normalized;
				num5 += 0.5f;
				result = Vector3.Lerp(normalized3, normalized, num5);
			}
			else
			{
				result = normalized;
			}
		}
		else
		{
			result = (roadScript.soSplinePoints[roadScript.soSplinePoints.Count - 2] - roadScript.soSplinePoints[roadScript.soSplinePoints.Count - 1]).normalized;
		}
		return result;
	}

	public int GetMarkerByPoint(int el)
	{
		UnityEngine.Debug.Log(roadScript.markersExt.Count + " el " + roadScript.markersExt[1].startSplinePoint);
		for (int i = 1; i < roadScript.markersExt.Count - 1; i++)
		{
			if (roadScript.markersExt[i].startSplinePoint <= el && roadScript.markersExt[i + 1].startSplinePoint > el)
			{
				return i;
			}
		}
		return roadScript.markersExt.Count - 1;
	}

	public Vector3[] GetSplinePointsCenter()
	{
		return roadScript.soSplinePoints.ToArray();
	}

	public Vector3[] GetSplinePointsRightSide()
	{
		return roadScript.soSplinePointsRight.ToArray();
	}

	public Vector3[] GetSplinePointsRightSideExt()
	{
		return roadScript.soSplinePointsRight.ToArray();
	}

	public Vector3[] GetSplinePointsLeftSide()
	{
		return roadScript.soSplinePointsLeft.ToArray();
	}

	public float SetIndent(float value, int marker)
	{
		if (marker >= 0 && marker < roadScript.markersExt.Count)
		{
			if (value < roadScript.baseScript.minIndent)
			{
				value = roadScript.baseScript.minIndent;
			}
			roadScript.markersExt[marker].rightIndent = value;
			roadScript.markersExt[marker].leftIndent = value;
			return value;
		}
		return -1f;
	}

	public float SetIndent(float value, int marker, ERRoadSide type)
	{
		if (marker >= 0 && marker < roadScript.markersExt.Count)
		{
			if (value < roadScript.baseScript.minIndent)
			{
				value = roadScript.baseScript.minIndent;
			}
			if (type != ERRoadSide.Left)
			{
				roadScript.markersExt[marker].rightIndent = value;
			}
			if (type != ERRoadSide.Right)
			{
				roadScript.markersExt[marker].leftIndent = value;
			}
			return value;
		}
		return -1f;
	}

	[Obsolete("obsolete")]
	public float SetRightIndent(float value, int marker)
	{
		if (marker >= 0 && marker < roadScript.markersExt.Count)
		{
			if (value < roadScript.baseScript.minIndent)
			{
				value = roadScript.baseScript.minIndent;
			}
			roadScript.markersExt[marker].rightIndent = value;
			return value;
		}
		return -1f;
	}

	[Obsolete("obsolete")]
	public float SetLeftIndent(float value, int marker)
	{
		if (marker >= 0 && marker < roadScript.markersExt.Count)
		{
			if (value < roadScript.baseScript.minIndent)
			{
				value = roadScript.baseScript.minIndent;
			}
			roadScript.markersExt[marker].leftIndent = value;
			return value;
		}
		return -1f;
	}

	public float SetSurrounding(float value, int marker)
	{
		if (marker >= 0 && marker < roadScript.markersExt.Count)
		{
			if (value < roadScript.baseScript.minIndent)
			{
				value = roadScript.baseScript.minIndent;
			}
			roadScript.markersExt[marker].rightSurrounding = value;
			roadScript.markersExt[marker].leftSurrounding = value;
			return value;
		}
		return -1f;
	}

	public float SetSurrounding(float value, int marker, ERRoadSide type)
	{
		if (marker >= 0 && marker < roadScript.markersExt.Count)
		{
			if (value < roadScript.baseScript.minIndent)
			{
				value = roadScript.baseScript.minIndent;
			}
			if (type != ERRoadSide.Left)
			{
				roadScript.markersExt[marker].rightSurrounding = value;
			}
			if (type != ERRoadSide.Right)
			{
				roadScript.markersExt[marker].leftSurrounding = value;
			}
			return value;
		}
		return -1f;
	}

	public void SetIndentAlignment(ERIndentAlignment value, int marker, ERRoadSide type)
	{
		roadScript.ODQOCQCCDC(value, marker, type);
	}

	public ERIndentAlignment GetIndentAlignment(int marker, ERRoadSide type)
	{
		return roadScript.ERGetIndentAlignment(marker, type);
	}

	[Obsolete("obsolete")]
	public float SetRightSurrouding(float value, int marker)
	{
		if (marker >= 0 && marker < roadScript.markersExt.Count)
		{
			if (value < 0f)
			{
				value = 0f;
			}
			roadScript.markersExt[marker].rightSurrounding = value;
			return value;
		}
		return -1f;
	}

	[Obsolete("obsolete")]
	public float SetLeftSurrouding(float value, int marker)
	{
		if (marker >= 0 && marker < roadScript.markersExt.Count)
		{
			if (value < 0f)
			{
				value = 0f;
			}
			roadScript.markersExt[marker].leftSurrounding = value;
			return value;
		}
		return -1f;
	}

	public Vector3[] GetRightIndentPoints()
	{
		return roadScript.rightIndentVecsSV.ToArray();
	}

	public Vector3[] GetLeftIndentPoints()
	{
		return roadScript.leftIndentVecsSV.ToArray();
	}

	public Vector3[] GetRightSurroundingPoints()
	{
		return roadScript.rightSurroundingVecs.ToArray();
	}

	public Vector3[] GetLeftSurroudingPoints()
	{
		return roadScript.leftSurroundingVecs.ToArray();
	}

	[Obsolete("obsolete")]
	public float GetLength()
	{
		return roadScript.totalDistance;
	}

	public float GetDistance()
	{
		return roadScript.totalDistance;
	}

	public float GetDistance(int markerIndex)
	{
		if (markerIndex >= 0 && markerIndex < roadScript.markersExt.Count)
		{
			return roadScript.markersExt[markerIndex].totalDistance;
		}
		return 0f;
	}

	public void SideObjectSetActive(SideObject obj, bool value)
	{
		if (obj != null)
		{
			roadScript.OCCQQDDDQC(obj, value);
		}
		else
		{
			UnityEngine.Debug.Log("EasyRoads3Dv3 Warning: The side object is null");
		}
	}

	public void SideObjectMarkerSetActive(SideObject obj, int marker, bool value)
	{
		if (obj != null)
		{
			if (roadScript.ODQCOQQDCD(obj, marker, value))
			{
				Refresh();
			}
		}
		else
		{
			UnityEngine.Debug.Log("EasyRoads3Dv3 Warning: The side object is null");
		}
	}

	public void SideObjectMarkerSetActive(SideObject obj, int[] markers, bool value)
	{
		if (obj != null)
		{
			if (roadScript.ODQCOQQDCD(obj, markers, value))
			{
				Refresh();
			}
		}
		else
		{
			UnityEngine.Debug.Log("EasyRoads3Dv3 Warning: The side object is null");
		}
	}

	public void SetSideObjectOffset(SideObject obj, int marker, OffsetPosition position, float value)
	{
		if (obj != null)
		{
			roadScript.ERSetSideObjectOffset(obj, marker, position, value);
		}
		else
		{
			UnityEngine.Debug.Log("EasyRoads3Dv3 Warning: The side object is null");
		}
	}

	public void SetTerrainDeformation(bool value)
	{
		roadScript.terrainDeformation = value;
		Refresh();
	}

	public void SetTerrainDeformation(int markerIndex, bool value)
	{
		if (markerIndex >= 0 && markerIndex < roadScript.markersExt.Count)
		{
			if (value)
			{
				roadScript.terrainDeformation = value;
			}
			roadScript.markersExt[markerIndex].bridgeObject = !value;
		}
	}

	public void SetMeshCollider(bool flag)
	{
		roadScript.hasMeshCollider = flag;
		if (flag)
		{
			if (roadScript.gameObject.GetComponent<MeshCollider>() == null)
			{
				roadScript.gameObject.AddComponent<MeshCollider>();
			}
		}
		else if ((bool)roadScript.gameObject.GetComponent<MeshCollider>())
		{
			UnityEngine.Object.Destroy(roadScript.gameObject.GetComponent<MeshCollider>());
		}
	}

	public void Refresh()
	{
		if (roadScript.baseScript == null)
		{
			if ((bool)roadScript.transform.parent.parent.gameObject.GetComponent<ERModularBase>())
			{
				roadScript.baseScript = roadScript.transform.parent.parent.gameObject.GetComponent<ERModularBase>();
			}
			else if (roadScript.baseScript == null)
			{
				roadScript.baseScript = roadScript.transform.parent.parent.parent.gameObject.GetComponent<ERModularBase>();
			}
		}
		roadScript.baseScript.UpdateQueue();
		roadScript.OCQOQCDCQC(ignorePrefabAlignment: false, forceAutoRotate: false);
		roadScript.baseScript.UpdateSideObjectsInScene();
	}

	public ERConnection GetConnectionAtStart()
	{
		if (roadScript.startPrefabScript != null)
		{
			if (roadScript.startPrefabScript.connObject == null)
			{
				roadScript.startPrefabScript.connObject = ERConnection.Create(roadScript.startPrefabScript.gameObject);
			}
			return roadScript.startPrefabScript.connObject;
		}
		return null;
	}

	public GameObject GetConnectionObjectAtStart()
	{
		if (roadScript.startPrefabScript != null)
		{
			return roadScript.startPrefabScript.gameObject;
		}
		return null;
	}

	public ERConnection GetConnectionAtStart(out int connectionIndex)
	{
		if (roadScript.startPrefabScript != null)
		{
			connectionIndex = roadScript.startConnectionSegment;
			if (roadScript.startPrefabScript.connObject == null)
			{
				roadScript.startPrefabScript.connObject = ERConnection.Create(roadScript.startPrefabScript.gameObject);
			}
			return roadScript.startPrefabScript.connObject;
		}
		connectionIndex = -1;
		return null;
	}

	public ERConnection GetConnectionObjectAtEnd()
	{
		if (roadScript.endPrefabScript != null)
		{
			if (roadScript.endPrefabScript.connObject == null)
			{
				roadScript.endPrefabScript.connObject = ERConnection.Create(roadScript.endPrefabScript.gameObject);
			}
			return roadScript.endPrefabScript.connObject;
		}
		return null;
	}

	public ERConnection GetConnectionAtEnd()
	{
		if (roadScript.endPrefabScript != null)
		{
			if (roadScript.endPrefabScript.connObject == null)
			{
				roadScript.endPrefabScript.connObject = ERConnection.Create(roadScript.endPrefabScript.gameObject);
			}
			return roadScript.endPrefabScript.connObject;
		}
		return null;
	}

	public ERConnection GetConnectionAtEnd(out int connectionIndex)
	{
		if (roadScript.endPrefabScript != null)
		{
			connectionIndex = roadScript.endConnectionSegment;
			if (roadScript.endPrefabScript.connObject == null)
			{
				roadScript.endPrefabScript.connObject = ERConnection.Create(roadScript.endPrefabScript.gameObject);
			}
			return roadScript.endPrefabScript.connObject;
		}
		connectionIndex = -1;
		return null;
	}

	public GameObject GetConnectionObjectAtEnd(out int connection)
	{
		if (roadScript.endPrefabScript != null)
		{
			connection = roadScript.endConnectionSegment;
			return roadScript.endPrefabScript.gameObject;
		}
		connection = -1;
		return null;
	}

	public bool ConnectionCheck(ERCrossingPrefabs prefab, int index, int startEnd)
	{
		if (roadScript == null)
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3 Error: the passed road object is null");
			return false;
		}
		if (roadScript.soSplinePoints.Count < 2)
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3 Error: the passed road does not have road data");
			return false;
		}
		if (prefab == null)
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3 Error: the passed connection prefab is null");
			return false;
		}
		if (prefab.crossingElements.Count < index || index < 0)
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3 Error: the passed connection index does not exist on the prefab");
			return false;
		}
		if (prefab.crossingElements[index].connectedRoad != null)
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3 Error: a road object is already attached to the passed connection index");
			return false;
		}
		if ((startEnd == 0 && roadScript.startPrefabScript != null) || (startEnd == 1 && roadScript.endPrefabScript != null))
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3 Error: a connection prefab is already attached on this end of the road");
			return false;
		}
		if (prefab.crossingElements[index].centerPoint == Vector3.zero && !prefab.isIConnector)
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3 Error: connection index " + index + " is not a valid connection");
			return false;
		}
		return true;
	}

	public bool ConnectToStart(ERConnection connectionObject, int connectionIndex)
	{
		if (connectionObject != null)
		{
			if (ConnectionCheck(connectionObject.prefabScript, connectionIndex, 0))
			{
				return ConnectToStartExt(connectionObject, connectionIndex, autoAlign: false);
			}
			return false;
		}
		return false;
	}

	public bool ConnectToStart(ERConnection connectionObject, int connectionIndex, bool autoAlign)
	{
		if (connectionObject != null)
		{
			if (ConnectionCheck(connectionObject.prefabScript, connectionIndex, 0))
			{
				OCQOQOOOCO.ODQCQCOOCQ(connectionObject.prefabScript, roadScript, connectionIndex, 0);
				return ConnectToStartExt(connectionObject, connectionIndex, autoAlign);
			}
			return false;
		}
		return false;
	}

	public bool ConnectToStartExt(ERConnection connectionObject, int connectionIndex, bool autoAlign)
	{
		if (roadScript.closedTrack)
		{
			return false;
		}
		if (roadScript.startPrefabScript != null)
		{
			return false;
		}
		if (roadScript.endPrefabScript != null && !ConnectionMatch(connectionObject, connectionIndex))
		{
			return false;
		}
		roadScript.nodeWithinRange = 0;
		Vector3 tmpCenterPoint = connectionObject.prefabScript.crossingElements[connectionIndex].tmpCenterPoint;
		tmpCenterPoint = connectionObject.prefabScript.transform.TransformPoint(tmpCenterPoint);
		OCQOQOOOCO.ODQDCODODC(roadScript, tmpCenterPoint, connectionObject.prefabScript, connectionIndex, reverse: true, uvReverse: true, autoAlign);
		return true;
	}

	public bool ConnectToEnd(ERConnection connectionObject, int connectionIndex)
	{
		if (connectionObject != null)
		{
			if (ConnectionCheck(connectionObject.prefabScript, connectionIndex, 1))
			{
				return ConnectToEndEx(connectionObject, connectionIndex, autoAlign: false);
			}
			return false;
		}
		return false;
	}

	public bool ConnectToEnd(ERConnection connectionObject, int connectionIndex, bool autoAlign)
	{
		if (connectionObject != null)
		{
			if (ConnectionCheck(connectionObject.prefabScript, connectionIndex, 1))
			{
				OCQOQOOOCO.ODQCQCOOCQ(connectionObject.prefabScript, roadScript, connectionIndex, 1);
				return ConnectToEndEx(connectionObject, connectionIndex, autoAlign);
			}
			return false;
		}
		return false;
	}

	public bool ConnectToEndEx(ERConnection connectionObject, int connectionIndex, bool autoAlign)
	{
		if (roadScript.closedTrack)
		{
			return false;
		}
		if (roadScript.endPrefabScript != null)
		{
			return false;
		}
		if (roadScript.startPrefabScript != null && !ConnectionMatch(connectionObject, connectionIndex))
		{
			return false;
		}
		roadScript.nodeWithinRange = roadScript.markersExt.Count - 1;
		Vector3 tmpCenterPoint = connectionObject.prefabScript.crossingElements[connectionIndex].tmpCenterPoint;
		tmpCenterPoint = connectionObject.prefabScript.transform.TransformPoint(tmpCenterPoint);
		OCQOQOOOCO.ODQDCODODC(roadScript, tmpCenterPoint, connectionObject.prefabScript, connectionIndex, reverse: false, uvReverse: false, autoAlign);
		return true;
	}

	public ERConnection AttachToStart(ERConnection connectionObject)
	{
		ERConnection eRConnection = null;
		if (roadScript.closedTrack)
		{
			return null;
		}
		if (roadScript.startPrefabScript != null)
		{
			return null;
		}
		if (roadScript.endPrefabScript != null && !ConnectionMatch(connectionObject))
		{
			return null;
		}
		ERCrossingPrefabs eRCrossingPrefabs = roadScript.baseScript.OCDQQCQCQQ(connectionObject.prefabScript.gameObject, roadScript, 0, -1);
		return new ERConnection(eRCrossingPrefabs.gameObject, eRCrossingPrefabs.gameObject.name);
	}

	public ERConnection AttachToEnd(ERConnection connectionObject)
	{
		if (roadScript.closedTrack)
		{
			return null;
		}
		if (roadScript.endPrefabScript != null)
		{
			return null;
		}
		if (roadScript.startPrefabScript != null && !ConnectionMatch(connectionObject))
		{
			return null;
		}
		ERCrossingPrefabs eRCrossingPrefabs = roadScript.baseScript.OCDQQCQCQQ(connectionObject.prefabScript.gameObject, roadScript, roadScript.markersExt.Count - 1, -1);
		return new ERConnection(eRCrossingPrefabs.gameObject, eRCrossingPrefabs.gameObject.name);
	}

	public ERConnection AttachToStart(ERConnection OQQCOQOCDO, int connectionIndex)
	{
		if (roadScript.closedTrack)
		{
			return null;
		}
		if (roadScript.startPrefabScript != null)
		{
			return null;
		}
		if (roadScript.endPrefabScript != null && !ConnectionMatch(OQQCOQOCDO))
		{
			return null;
		}
		ERCrossingPrefabs eRCrossingPrefabs = roadScript.baseScript.OCDQQCQCQQ(OQQCOQOCDO.prefabScript.gameObject, roadScript, 0, connectionIndex);
		return new ERConnection(eRCrossingPrefabs.gameObject, eRCrossingPrefabs.gameObject.name);
	}

	public ERConnection AttachToEnd(ERConnection connectionInstance, int connectionIndex)
	{
		if (connectionInstance == null)
		{
			UnityEngine.Debug.LogError("EasyRoad3D: NullReferenceException: The connectionInstance is not set to an instance of ERConnection");
			return null;
		}
		if (roadScript.closedTrack)
		{
			return null;
		}
		if (roadScript.endPrefabScript != null)
		{
			return null;
		}
		if (roadScript.startPrefabScript != null && !ConnectionMatch(connectionInstance))
		{
			return null;
		}
		ERCrossingPrefabs eRCrossingPrefabs = roadScript.baseScript.OCDQQCQCQQ(connectionInstance.prefabScript.gameObject, roadScript, roadScript.markersExt.Count - 1, connectionIndex);
		return new ERConnection(eRCrossingPrefabs.gameObject, eRCrossingPrefabs.gameObject.name);
	}

	public bool ConnectionMatch(ERConnection connection)
	{
		for (int i = 0; i < connection.prefabScript.crossingElements.Count; i++)
		{
			if (roadScript.roadShapeMatchCount == connection.prefabScript.crossingElements[i].roadShapeMatchCount || roadScript.roadShapeMatchCount == 0 || connection.prefabScript.crossingElements[i].roadShapeMatchCount == 0)
			{
				return true;
			}
		}
		return false;
	}

	public void SetCustomMarkerPoints(int markerIndex, List<Vector3> points)
	{
		if (markerIndex >= 0 && markerIndex < roadScript.markersExt.Count)
		{
			roadScript.markersExt[markerIndex].customPoints.Clear();
			roadScript.markersExt[markerIndex].customPoints.AddRange(points);
		}
	}

	public ERConnection InsertConnector(ERConnection connectionObject, int markerIndex, int connectionIndex1, int connectionIndex2, out ERRoad road)
	{
		if (roadScript.closedTrack)
		{
			roadScript.closedTrack = false;
		}
		ERModularRoad eRModularRoad = roadScript;
		if (markerIndex < 0 || markerIndex >= eRModularRoad.markersExt.Count)
		{
			UnityEngine.Debug.LogWarning("EasyRoads3Dv3: road " + eRModularRoad.name + " no marker exists at index: " + markerIndex);
			road = null;
			return null;
		}
		int num = 0;
		ERModularRoad eRModularRoad2 = null;
		if (markerIndex != 0 && markerIndex != eRModularRoad.markersExt.Count - 1)
		{
			eRModularRoad2 = OCQOQOOOCO.OCQDOCOODD(eRModularRoad, markerIndex);
		}
		ERCrossingPrefabs eRCrossingPrefabs = roadScript.baseScript.OCDQQCQCQQ(connectionObject.prefabScript.gameObject, roadScript, roadScript.markersExt.Count - 1, connectionIndex1);
		ERConnection result = new ERConnection(eRCrossingPrefabs.gameObject, eRCrossingPrefabs.gameObject.name);
		ERRoad eRRoad = null;
		if (eRModularRoad2 != null)
		{
			eRModularRoad2.nodeWithinRange = 0;
			OCQOQOOOCO.ODQDCODODC(eRModularRoad2, eRCrossingPrefabs.transform.position, eRCrossingPrefabs, connectionIndex2, reverse: true, uvReverse: true, forceAutoRotate: false);
			eRRoad = new ERRoad(eRModularRoad2);
		}
		road = new ERRoad();
		road.roadScript = eRModularRoad2;
		eRModularRoad2.road = road;
		Refresh();
		return result;
	}

	public void UnConnectStart()
	{
		bool flag = false;
		if (roadScript.startPrefabScript != null)
		{
			OCQOQOOOCO.OOCQODCOOQ(roadScript.baseScript, roadScript, 1, 0, 0);
			Refresh();
		}
	}

	public void UnConnectEnd()
	{
		bool flag = false;
		if (roadScript.endPrefabScript != null)
		{
			OCQOQOOOCO.ODQDQOQQCO(roadScript.baseScript, roadScript, roadScript.markersExt.Count - 2, roadScript.markersExt.Count - 1, roadScript.markersExt.Count - 1);
			Refresh();
		}
	}

	public bool ConnectionMatch(ERConnection connection, int connectionIndex)
	{
		if (roadScript.roadShapeMatchCount == connection.prefabScript.crossingElements[connectionIndex].roadShapeMatchCount || roadScript.roadShapeMatchCount == 0 || connection.prefabScript.crossingElements[connectionIndex].roadShapeMatchCount == 0)
		{
			return true;
		}
		return false;
	}

	public void SnapToTerrain(bool flag)
	{
		roadScript.snapVertices = flag;
		roadScript.terrainDeformation = !flag;
		Refresh();
	}

	public void SnapToTerrain(bool flag, float offset)
	{
		roadScript.snapVertices = flag;
		roadScript.snapOffset = offset;
		roadScript.terrainDeformation = !flag;
		Refresh();
	}

	public string GetName()
	{
		if (gameObject != null)
		{
			return gameObject.name;
		}
		return "";
	}

	public void SetName(string name)
	{
		if (gameObject != null)
		{
			gameObject.name = name;
			roadScript.roadName = name;
		}
	}

	public Vector2[] GetShapeNodes()
	{
		if (roadScript != null)
		{
			return roadScript.roadShape.ToArray();
		}
		return null;
	}

	public Vector2[] GetRoadShapeNodes(int markerIndex)
	{
		if (roadScript != null && roadScript.markersExt.Count > markerIndex)
		{
			return roadScript.markersExt[markerIndex].roadShape.ToArray();
		}
		return null;
	}

	public void SetRoadShapeNodes(int markerIndex, Vector2[] nodes)
	{
		if (roadScript != null && roadScript.markersExt.Count > markerIndex && nodes.Length == roadScript.markersExt[markerIndex].roadShape.Count)
		{
			roadScript.markersExt[markerIndex].roadShape = new List<Vector2>(nodes);
			Refresh();
		}
	}

	public void SetRoadShapeNodes(int[] markerIndexes, Vector2[] nodes)
	{
		if (!(roadScript != null) || nodes.Length != roadScript.roadShape.Count)
		{
			return;
		}
		for (int i = 0; i < markerIndexes.Length; i++)
		{
			if (roadScript.markersExt.Count > markerIndexes[i])
			{
				roadScript.markersExt[markerIndexes[i]].roadShape = new List<Vector2>(nodes);
			}
			Refresh();
		}
	}

	public void Clear()
	{
		if (roadScript != null)
		{
			roadScript.markersExt.Clear();
			if (roadScript.surfaceMesh != null && roadScript.surfaceMesh.GetComponent<MeshFilter>() != null && roadScript.surfaceMesh.GetComponent<MeshFilter>().sharedMesh != null)
			{
				roadScript.surfaceMesh.GetComponent<MeshFilter>().sharedMesh.Clear();
			}
			if (roadScript.gameObject.GetComponent<MeshFilter>() != null && roadScript.gameObject.GetComponent<MeshFilter>().sharedMesh != null)
			{
				roadScript.gameObject.GetComponent<MeshFilter>().sharedMesh.Clear();
			}
			int childCount = roadScript.transform.childCount;
			for (int num = childCount - 1; num > 0; num--)
			{
				UnityEngine.Object.DestroyImmediate(roadScript.transform.GetChild(num).gameObject);
			}
			if (roadScript.baseScript != null && roadScript.baseScript.OCCQOOOQQO == roadScript)
			{
				roadScript.baseScript.OCODDDQOQC = -1;
			}
		}
	}

	public void Destroy()
	{
		ERCrossingPrefabs startPrefabScript = roadScript.startPrefabScript;
		ERCrossingPrefabs endPrefabScript = roadScript.endPrefabScript;
		if (startPrefabScript != null && startPrefabScript.isIConnector && (bool)startPrefabScript.gameObject.GetComponent<ERIConnector>())
		{
			startPrefabScript.gameObject.GetComponent<ERIConnector>().OCQOQCDCQC(null);
		}
		if (endPrefabScript != null && endPrefabScript.isIConnector && (bool)endPrefabScript.gameObject.GetComponent<ERIConnector>())
		{
			endPrefabScript.gameObject.GetComponent<ERIConnector>().OCQOQCDCQC(null);
		}
		if (gameObject != null)
		{
			UnityEngine.Object.DestroyImmediate(gameObject);
		}
		roadScript = null;
	}
}
public class ERPoint
{
	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private double á;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private double á;

	public double x
	{
		[CompilerGenerated]
		get
		{
			return á;
		}
		[CompilerGenerated]
		set
		{
			á = value;
		}
	}

	public double y
	{
		[CompilerGenerated]
		get
		{
			return á;
		}
		[CompilerGenerated]
		set
		{
			á = value;
		}
	}

	public ERPoint(double x, double y)
	{
		this.x = x;
		this.y = y;
	}
}
public class ERDebug
{
	public static List<Vector3> leftTHandles = new List<Vector3>();

	public static List<Vector3> rightTHandles = new List<Vector3>();
}
[Serializable]
public struct ERConnectionGUIStatus
{
	public int id;

	public bool favourite;

	public ERConnectionGUIStatus(int _id, bool value)
	{
		id = _id;
		favourite = value;
	}
}
[Serializable]
public struct ERCell
{
	public int x;

	public int y;

	public ERCell(int _x, int _y)
	{
		x = _x;
		y = _y;
	}
}
[Serializable]
public struct ERSOSection
{
	public Vector3 startPosition;

	public Vector3 endPosition;

	public Vector3 p2;

	public Vector3 p3;

	public Vector3 ms1;

	public Vector3 ms2;

	public Vector3 ms3;

	public Vector3 ms4;

	public Vector3 me1;

	public Vector3 me2;

	public Vector3 me3;

	public Vector3 me4;

	public Vector3 startSplinePointOrig;

	public float startDistance;

	public int startSplinePointObject;

	public int startSplinePoint;

	public int endSplinePoint;

	public float startFraction;

	public float endFraction;

	public float hsStart;

	public float hsEnd;

	public int startSplinePointGeo;

	public float startDistanceGeo;

	public int endSplinePointGeo;

	public float endDistanceGeo;

	public float maxHeightDifference;

	public SideObject so;

	public bool forceSo;

	public ERRoadSide roadSide;

	public double soid;

	public bool acceptBarriers;

	public bool active;

	public double linkedSoId1;

	public double linkedSoId2;

	public ERSOSection(Vector3 _startPos, Vector3 _endPos, int _startIndex, int _endIndex, float _startFraction, float _endFraction, float _hsStart, float _hsEnd)
	{
		startPosition = _startPos;
		endPosition = _endPos;
		p2 = Vector3.zero;
		p3 = Vector3.zero;
		ms1 = Vector3.zero;
		ms2 = Vector3.zero;
		ms3 = Vector3.zero;
		ms4 = Vector3.zero;
		me1 = Vector3.zero;
		me2 = Vector3.zero;
		me3 = Vector3.zero;
		me4 = Vector3.zero;
		startSplinePoint = (startSplinePointObject = _startIndex);
		endSplinePoint = _endIndex;
		startFraction = _startFraction;
		endFraction = _endFraction;
		hsStart = _hsStart;
		hsEnd = _hsEnd;
		so = null;
		soid = 0.0;
		active = true;
		roadSide = ERRoadSide.Left;
		startSplinePointOrig = Vector3.zero;
		startDistance = 0f;
		acceptBarriers = false;
		startSplinePointGeo = 0;
		startDistanceGeo = 0f;
		endSplinePointGeo = 0;
		maxHeightDifference = 0f;
		endDistanceGeo = 0f;
		linkedSoId1 = 0.0;
		linkedSoId2 = 0.0;
		forceSo = false;
	}

	public static ERSOSection GetERSOSection(ERModularRoad road, int listIndex, ref int index, int leftright, ref string soType, ref List<ERSOSection> sections)
	{
		List<ERSOSection> list;
		switch (listIndex)
		{
		case 1:
			soType = "Tunnel";
			sections = road.soSectionList1;
			list = road.soSectionList1;
			break;
		case 2:
			soType = "Bridge";
			sections = road.soSectionList2;
			list = road.soSectionList2;
			break;
		case 3:
			soType = "Barrier";
			sections = road.soSectionList3;
			list = road.soSectionList3;
			break;
		case 4:
			soType = "Barrier";
			sections = road.soSectionList4;
			list = road.soSectionList4;
			break;
		case 5:
			soType = "Prop";
			sections = road.soSectionList5;
			list = road.soSectionList5;
			break;
		case 6:
			soType = "Retaining Wall";
			sections = road.soSectionList6;
			list = road.soSectionList6;
			break;
		case 7:
			soType = "Retaining Wall";
			sections = road.soSectionList7;
			list = road.soSectionList7;
			break;
		default:
			soType = "Vegetation";
			sections = road.soSectionList8;
			list = road.soSectionList8;
			break;
		}
		if (list.Count > index)
		{
			return list[index];
		}
		return default(ERSOSection);
	}

	public static ERSOSection AdjustEndOffset(ERSOSection target, ERSOSection source)
	{
		if (target.endSplinePoint >= source.startSplinePoint)
		{
			target.endSplinePoint = source.startSplinePoint - 1;
			target.endFraction = 1f - source.startFraction;
		}
		return target;
	}
}
[Serializable]
public class SideObject : ScriptableObject
{
	public string version = "2.0.0";

	public new string name;

	public double id;

	public double timestamp;

	public int objectType = 0;

	public string gameobjectGUID;

	public string textureGUID;

	public float m_distance = 10f;

	public float uvx = 0.1f;

	public float uvy = 1f;

	public int position = 0;

	public float splinePosition = 0f;

	public int selectedRotation = 0;

	public float randomYAxisMinRotation = 0f;

	public float randomYAxisMaxRotation = 0f;

	public List<Vector2> nodeList = new List<Vector2>();

	public List<float> uvs = new List<float>();

	public List<float> uvDistances = new List<float>();

	public bool clampUVs = true;

	public bool clampUVY = true;

	public float clampUVYValue = 1f;

	public float totalDistance = 0f;

	public bool reverseUVs = false;

	public bool terrainUVs = false;

	public List<bool> snapList = new List<bool>();

	public List<float> snapWeightList = new List<float>();

	public List<Color> colorList = new List<Color>();

	public string gameobjectStartGUID;

	public string gameobjectEndGUID;

	public int align = 0;

	public int alignPoint = 0;

	public bool weld = true;

	public bool combine = false;

	public bool combineInstantiated = true;

	public bool markerActive = true;

	public int uvType = 0;

	public float uv = 1f;

	public bool randomObjects = false;

	public float forwardStartOffset = 0f;

	public float sidewaysOffset = 0f;

	public float density = 0f;

	public string goPath = "";

	public string startPath = "";

	public string endPath = "";

	public string texturePath = "";

	public int terrainTree = 0;

	public float minScale = 1f;

	public float maxScale = 1f;

	public bool childOrderActive = false;

	public int childOrder = 0;

	public bool meshBoundsAlignment = false;

	public float xPosition = 0f;

	public float xPosition2 = 0f;

	public int relativeTo = 0;

	public float yPosition = 0f;

	public float yRotation = 0f;

	public float oldSidwaysDistance = 0f;

	public int sidewaysDistanceUpdate = 0;

	public float uvYRound = 0f;

	public bool adjustUV = true;

	public bool collider = false;

	public bool boxcollider = false;

	public bool tangents = false;

	public GameObject sourceObject;

	public bool flipMesh = false;

	public GameObject startObject;

	public GameObject endObject;

	public GameObject connectionObject;

	public Material material;

	public List<ERMesh> meshObjects = new List<ERMesh>();

	public Vector2 boxSize;

	public Vector2 boxOffset;

	public bool includeStartSegment = false;

	public float startSegmentOffset = 0f;

	public bool includeStartEdgeTris = false;

	public bool includeEndSegment = false;

	public float endSegmentOffset = 0f;

	public bool includeEndEdgeTris = false;

	public bool adjustToRoadWidth = false;

	public float xOffset = 0f;

	public float startOffset = 0f;

	public float endOffset = 0f;

	public float defaultStartOffset = 0f;

	public float defaultEndOffset = 0f;

	public float totalZDistance = 0f;

	public float middleZDistance = 0f;

	public float startZDistance = 0f;

	public float endZDistance = 0f;

	public float minStartZ = 10000f;

	public float maxStartZ = -10000f;

	public float minMiddleZ = 10000f;

	public float maxMiddleZ = -10000f;

	public float minEndZ = 10000f;

	public float maxEndZ = -10000f;

	public bool smoothStart = false;

	public bool smoothMiddle = false;

	public bool smoothEnd = false;

	public GameObject targetObject;

	public bool bridgeObject = false;

	public bool tunnelObject = false;

	public bool snapToTerrain = false;

	public int layer = 0;

	public bool deformationObject = false;

	public bool isStatic = false;

	public bool castShadows = true;

	public bool scaleToRoad = false;

	public bool splitInBatches = false;

	public List<GameObject> instantiatedObjects = new List<GameObject>();

	public int maxVertices = 0;

	public bool doTestmesh = false;

	public Vector3 testMeshPos = Vector3.zero;

	public Vector3 randomRotation = Vector3.zero;

	public float randomMinRotation = 0f;

	public float randomMaxRotation = 0f;

	public float minRandomRotationDistance = 0f;

	public float maxRandomRotationDistance = 0f;

	public float randomXPosition = 0f;

	public float randomMinXPosition = 0f;

	public float randomMaxXPosition = 0f;

	public float minRandomXPositionDistance = 0f;

	public float maxRandomXPositionDistance = 0f;

	public Vector3 boxColliderScale = new Vector3(1f, 1f, 1f);

	public float randomYPosition = 0f;

	public float randomMinYPosition = 0f;

	public float randomMaxYPosition = 0f;

	public float minRandomYPositionDistance = 0f;

	public float maxRandomYPositionDistance = 0f;

	public bool indentController = false;

	public bool excludeTerrainSplats = false;

	public float x1 = 0f;

	public float x2 = 0f;

	public float xf1 = 0f;

	public float xf2 = 0f;

	public float y1 = 0f;

	public float bridgeHeight = 5f;

	public int markerSplineController = 2;

	public float bridgeLength = 20f;

	public float deformationOffset = 0f;

	public float markerIndent = 0f;

	public float markerSurrounding = 0f;

	public Vector3 scale = Vector3.one;

	public float indentExt = 0f;

	public int category = 0;

	public Texture2D densityMap;

	public float densitySize = 50f;

	public float densitySize2 = 50f;

	public float densityStrength = 0.5f;

	public float densityStrength2 = 0.5f;

	public float terrainNormal = 0f;

	public float terrainNormal2 = 1f;

	public List<ERChildsSO> childObjects = new List<ERChildsSO>();

	public bool autoGenerate = false;

	public float heightThreshold = 10f;

	public float autogenerateStartOffset = 0f;

	public float autogenerateEndOffset = 0f;

	public bool snapIndents = false;

	public float snapIndentWidth = 0f;

	public bool cutHoles = true;

	public float innerStartOffset = 0f;

	public float innerEndOffset = 0f;

	public bool ignoredForRetainingWalls = false;

	public float heightMaxThreshold = 100f;

	public float heightMaxStartThreshold = 1f;

	public float heightMaxEndThreshold = 1f;

	public float xThresholdDistance = 5f;

	public float angleThreshold = 10f;

	public int connectionRatio = 1;

	public bool retainingWall = false;

	public int surroundingControl = 0;

	public int indentControl = 0;

	public List<Vector2> nodeListMirrored = new List<Vector2>();

	public List<float> uvsMirrored = new List<float>();

	public List<float> snapWeightListMirrored = new List<float>();

	public List<Color> colorListMirrored = new List<Color>();

	public bool hasVertexColors = false;

	public float deformationOffsetForward = 0f;

	public float deformationOffsetSideways = 0f;

	public int connectionObjectRotation = 0;

	public bool subMesh = false;

	public bool acceptBarriers = true;

	public bool activeOnBridges = true;

	public bool dualSided = false;

	public int mirrorType = 0;

	public bool snapVertexColors = false;

	public float minSnapRange = 0f;

	public float maxSnapRange = 0f;

	public bool clampUV4 = false;

	public float geoStartOffset = 0f;

	public float geoEndOffset = 0f;

	public float startOverlapOffset = 0f;

	public float endOverlapOffset = 0f;

	public int lodLevels = 0;

	public List<bool> hardEdge = new List<bool>();

	public float hardEdgePadding = 0f;

	public bool startEndCaps = false;

	public List<Vector2> endCapUVs = new List<Vector2>();

	public List<Vector2> startCapUVs = new List<Vector2>();

	public List<int> startCapTris = new List<int>();

	public List<int> startCapTrisMirrored = new List<int>();

	public Vector2 startCapUVOffset = new Vector2(0.5f, 0.5f);

	public Vector2 endCapUVOffset = new Vector2(0.5f, 0.5f);

	public float startCapUVScale = 1f;

	public float endCapUVScale = 1f;

	public float startCapUVRotation = 0f;

	public float endCapUVRotation = 0f;

	public bool namedChilds = false;

	public bool startSection = false;

	public bool endSection = false;

	public bool stepDown = false;

	public bool stepUp = false;

	public float stepDistance = 0f;

	public float startDirZOffset = 0f;

	public float endDirZOffset = 0f;

	public bool buildOtherSideObject1 = false;

	public double defaultOtherSoId1 = 0.0;

	public bool buildOtherSideObject2 = false;

	public double defaultOtherSoId2 = 0.0;

	public List<double> buildOtherSideObjects = new List<double>();

	public bool averageDistance = true;

	public bool randomUVx = false;

	public bool isUsedAsChild = false;

	public void SetSideObject(int count, int scategory)
	{
		id = (timestamp = DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds);
		name = "Side Object " + count;
		category = scategory;
	}

	public void UpdateTimeStamp()
	{
		timestamp = DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
	}

	public void OOCCDCDOQC()
	{
		uvs.Clear();
		float num = 0f;
		for (int i = 0; i < nodeList.Count - 1; i++)
		{
			num += Vector2.Distance(nodeList[i], nodeList[i + 1]);
		}
		float num2 = 0f;
		uvs.Add(0f);
		for (int j = 0; j < nodeList.Count - 1; j++)
		{
			num2 += Vector2.Distance(nodeList[j], nodeList[j + 1]);
			uvs.Add(num2 / num);
		}
		OQOQOQOODC();
	}

	public void OQOQOQOODC()
	{
		nodeListMirrored = new List<Vector2>(nodeList);
		nodeListMirrored.Reverse();
		for (int i = 0; i < nodeListMirrored.Count; i++)
		{
			Vector2 value = nodeListMirrored[i];
			value.x *= -1f;
			nodeListMirrored[i] = value;
		}
		uvsMirrored = new List<float>(uvs);
		uvsMirrored.Reverse();
		snapWeightListMirrored = new List<float>(snapWeightList);
		snapWeightListMirrored.Reverse();
		colorListMirrored = new List<Color>(colorList);
		colorListMirrored.Reverse();
	}

	public void SetMaxVertices()
	{
		maxVertices = 0;
		GameObject gameObject = sourceObject;
		if (objectType != 0)
		{
			gameObject = connectionObject;
		}
		if (!(gameObject != null))
		{
			return;
		}
		MeshFilter component = gameObject.GetComponent<MeshFilter>();
		if (component != null && component.sharedMesh != null && component.sharedMesh.vertices.Length > maxVertices)
		{
			maxVertices = component.sharedMesh.vertices.Length;
		}
		MeshFilter[] componentsInChildren = gameObject.GetComponentsInChildren<MeshFilter>();
		foreach (Transform item in gameObject.transform)
		{
			if ((bool)item.GetComponent<MeshFilter>())
			{
				MeshFilter component2 = item.GetComponent<MeshFilter>();
				if (component2.sharedMesh != null && component2.sharedMesh.vertices.Length > maxVertices)
				{
					maxVertices = component2.sharedMesh.vertices.Length;
				}
			}
		}
	}

	public static bool CheckSOChildActive(List<ERSOSection> sections, SideObject so)
	{
		for (int i = 0; i < sections.Count; i++)
		{
			if (!sections[i].active || !(sections[i].so != null) || sections[i].so.buildOtherSideObjects.Count <= 0)
			{
				continue;
			}
			for (int j = 0; j < sections[i].so.buildOtherSideObjects.Count; j++)
			{
				if (sections[i].so.buildOtherSideObjects[j] == so.id)
				{
					return true;
				}
			}
		}
		return false;
	}

	public void OOOCDOQOOC(bool updateTimeStamp)
	{
		meshObjects.Clear();
		subMesh = false;
		meshObjects.Add(new ERMesh(null, this, 0f, null, Vector3.one, null, null));
		totalDistance = 0f;
		for (int i = 0; i < nodeList.Count - 1; i++)
		{
			totalDistance += Vector2.Distance(nodeList[i], nodeList[i + 1]);
		}
		uvDistances.Clear();
		uvDistances.Add(0f);
		float num = 0f;
		for (int j = 0; j < nodeList.Count - 1; j++)
		{
			num += Vector2.Distance(nodeList[j], nodeList[j + 1]);
			uvDistances.Add(num / totalDistance);
		}
		if (updateTimeStamp)
		{
			UpdateTimeStamp();
		}
	}

	public void OQDODCOODC()
	{
		x1 = (x2 = (xf1 = (xf2 = (y1 = 0f))));
		foreach (ERMesh meshObject in meshObjects)
		{
			foreach (Vector3 vec in meshObject.vecs)
			{
				if (vec.y > 0f)
				{
					if (vec.x < x1)
					{
						x1 = vec.x;
					}
					else if (vec.x > x2)
					{
						x2 = vec.x;
					}
					if (vec.y > y1)
					{
						y1 = vec.y;
					}
				}
			}
		}
		foreach (ERMesh meshObject2 in meshObjects)
		{
			foreach (Vector3 startVec in meshObject2.startVecs)
			{
				if (startVec.x < xf1)
				{
					xf1 = startVec.x;
				}
				else if (startVec.x > xf2)
				{
					xf2 = startVec.x;
				}
			}
		}
		y1 += 0.05f;
	}

	public void OQDDDDOOQD(Vector3 m_testMeshPos, bool updateTimeStamp)
	{
		if (updateTimeStamp)
		{
			UpdateTimeStamp();
		}
		testMeshPos = m_testMeshPos;
		minStartZ = 10000f;
		maxStartZ = -10000f;
		minMiddleZ = 10000f;
		maxMiddleZ = -10000f;
		minEndZ = 10000f;
		maxEndZ = -10000f;
		startOverlapOffset = 0f;
		endOverlapOffset = 0f;
		hasVertexColors = (startSection = (endSection = false));
		if (sourceObject == null && objectType != 1)
		{
			return;
		}
		if (sourceObject != null)
		{
			sourceObject.transform.position = Vector3.zero;
		}
		if (objectType == 1)
		{
			OOOCDOQOOC(updateTimeStamp);
			return;
		}
		meshObjects.Clear();
		subMesh = false;
		List<GameObject> list = new List<GameObject>();
		MeshFilter meshFilter = null;
		if ((bool)sourceObject.GetComponent<MeshFilter>())
		{
			if (sourceObject.GetComponent<MeshFilter>().sharedMesh != null)
			{
				list.Add(sourceObject);
			}
			else
			{
				UnityEngine.Debug.LogError(string.Concat(sourceObject, ": This object does not have a mesh assigned to the meshfilter!"));
			}
		}
		bool flag = false;
		foreach (Transform item in sourceObject.transform)
		{
			if (!item.GetComponent<MeshFilter>())
			{
				continue;
			}
			if (item.GetComponent<MeshFilter>().sharedMesh != null)
			{
				string text = item.name;
				if (text.IndexOf("_start") >= 0 || text.IndexOf("_middle") >= 0 || text.IndexOf("_end") >= 0)
				{
					flag = true;
					includeStartSegment = (includeEndSegment = false);
				}
				list.Add(item.gameObject);
			}
			else
			{
				UnityEngine.Debug.LogError(string.Concat(sourceObject, "> ", item, ": This object does not have a mesh assigned to the meshfilter!"));
			}
		}
		if (list.Count == 0)
		{
			UnityEngine.Debug.LogError(string.Concat(sourceObject, ": This object does not have a meshfilter component!"));
			return;
		}
		Mesh mesh = null;
		float num = 10000f;
		float num2 = -10000f;
		float num3 = 100000f;
		float num4 = -100000f;
		float num5 = 100000f;
		float num6 = -100000f;
		startZDistance = 0f;
		middleZDistance = 0f;
		endZDistance = 0f;
		bool rotate = false;
		float num7 = 10000f;
		float num8 = 10000f;
		float num9 = 10000f;
		if (list.Count > 0)
		{
			Bounds bounds = default(Bounds);
			for (int i = 0; i < list.Count; i++)
			{
				bounds.Encapsulate(list[i].GetComponent<MeshFilter>().sharedMesh.bounds);
				if (flag)
				{
					float z = list[i].GetComponent<MeshFilter>().sharedMesh.bounds.min.z;
					if (list[i].name.IndexOf("_start") >= 0)
					{
						num7 = z;
					}
					else if (list[i].name.IndexOf("_middle") >= 0)
					{
						num8 = z;
					}
					else if (list[i].name.IndexOf("_end") >= 0)
					{
						num9 = z;
					}
				}
			}
			if (flag)
			{
				if (num7 != 10000f && num8 != 10000f && num7 > num8)
				{
					rotate = true;
				}
				else if (num9 != 10000f && num8 != 10000f && num9 < num8)
				{
					rotate = true;
				}
				num7 = OQQDDOCDDQ(list, rotate);
				namedChilds = true;
			}
			num = 100000f;
			num2 = -100000f;
			num3 = 100000f;
			num4 = -100000f;
			num5 = 100000f;
			num6 = -100000f;
			foreach (GameObject item2 in list)
			{
				mesh = item2.GetComponent<MeshFilter>().sharedMesh;
				for (int j = 0; j < mesh.vertices.Length; j++)
				{
					Vector3 vector = item2.transform.TransformPoint(mesh.vertices[j]);
					if (vector.z < num)
					{
						num = vector.z;
					}
					if (vector.z > num2)
					{
						num2 = vector.z;
					}
					if (vector.x < num5)
					{
						num5 = vector.x;
					}
					if (vector.x > num6)
					{
						num6 = vector.x;
					}
					if (vector.y < num3)
					{
						num3 = vector.y;
					}
					if (vector.y > num4)
					{
						num4 = vector.y;
					}
				}
				if (mesh.colors.Length != 0)
				{
					hasVertexColors = true;
				}
			}
			bounds.min = new Vector3(bounds.min.x, bounds.min.y, num);
			bounds.max = new Vector3(bounds.max.x, bounds.max.y, num2);
			totalZDistance = bounds.max.z - bounds.min.z;
			mesh = null;
			Mesh mesh2 = null;
			for (int k = 0; k < list.Count; k++)
			{
				mesh = null;
				Material[] array = null;
				if ((bool)list[k].GetComponent<MeshFilter>())
				{
					mesh = list[k].GetComponent<MeshFilter>().sharedMesh;
				}
				if ((bool)list[k].GetComponent<MeshRenderer>())
				{
					array = list[k].GetComponent<MeshRenderer>().sharedMaterials;
				}
				if (!(mesh != null))
				{
					continue;
				}
				mesh2 = UnityEngine.Object.Instantiate(mesh);
				for (int l = 0; l < mesh.subMeshCount; l++)
				{
					mesh2.triangles = mesh.GetTriangles(l);
					meshObjects.Add(new ERMesh(list[k], this, num, sourceObject.transform, scale, mesh2, array[l], num7, rotate));
					meshObjects[meshObjects.Count - 1].name = list[k].name;
					if (list[k].name.Contains("_terrain"))
					{
						meshObjects[meshObjects.Count - 1].terrainMesh = true;
					}
					meshObjects[meshObjects.Count - 1].castShadows = castShadows;
					if (list[k].name.Contains("_castShadowsOff"))
					{
						meshObjects[meshObjects.Count - 1].castShadows = false;
					}
				}
			}
			UnityEngine.Object.DestroyImmediate(mesh2);
			if (meshObjects.Count == 0)
			{
				UnityEngine.Debug.LogError("EasyRoads3Dv3: " + name + " Unable to extract mesh data, the source mesh does not have valid mesh data");
			}
			boxSize = new Vector2(bounds.size.x, bounds.size.y);
			boxSize = new Vector2(num6 - num5, num4 - num3);
			boxOffset = new Vector2(bounds.center.x, bounds.center.y);
		}
		startZDistance = maxStartZ - minStartZ;
		middleZDistance = maxMiddleZ - minMiddleZ;
		endZDistance = maxEndZ - minEndZ;
		if (includeStartSegment && namedChilds)
		{
			startOverlapOffset = maxStartZ - minMiddleZ;
		}
		if (includeEndSegment && namedChilds)
		{
			endOverlapOffset = maxMiddleZ - minEndZ;
		}
		if ((startZDistance < 0f && includeStartSegment) || middleZDistance < 0f)
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3: " + name + " Unable to extract mesh data, is the center of the bounding box positioned near (0,0)? Otherwise please contact us with details ideally including the source prefab so we can test it.");
		}
		if (tunnelObject)
		{
			OQDODCOODC();
		}
	}

	private void OQOODQQQQC(List<Vector3> vecs, float startDistance, List<Vector3> vecs1, float endDistance, ref List<int> startArray, ref List<int> endArray, int section)
	{
		List<int> list = new List<int>();
		List<int> list2 = new List<int>();
		startArray.Clear();
		endArray.Clear();
		for (int i = 0; i < vecs.Count; i++)
		{
			if (vecs[i].z - startDistance < 0.005f && vecs[i].z - startDistance > -0.005f)
			{
				list.Add(i);
			}
		}
		for (int j = 0; j < vecs.Count; j++)
		{
			if (vecs1[j].z > endDistance - 0.005f && vecs1[j].z < endDistance + 0.005f)
			{
				list2.Add(j);
			}
		}
		for (int k = 0; k < list.Count; k++)
		{
			Vector3 a = vecs[list[k]];
			for (int l = 0; l < list2.Count; l++)
			{
				Vector3 b = vecs1[list2[l]];
				b.z = a.z;
				if (Vector3.Distance(a, b) < 0.005f)
				{
					startArray.Add(list[k]);
					endArray.Add(list2[l]);
					break;
				}
			}
		}
	}

	private float OQQDDOCDDQ(List<GameObject> goObjects, bool rotate180)
	{
		float num = 10000f;
		for (int i = 0; i < goObjects.Count; i++)
		{
			if (goObjects[i].name.IndexOf("_start") < 0)
			{
				continue;
			}
			Mesh sharedMesh = goObjects[i].GetComponent<MeshFilter>().sharedMesh;
			for (int j = 0; j < sharedMesh.vertices.Length; j++)
			{
				Vector3 point = sharedMesh.vertices[j];
				if (rotate180)
				{
					point = ODQDQDQDQO.OQDDDODCOC(point, Vector3.zero, Quaternion.Euler(0f, 180f, 0f));
				}
				if (point.z < num)
				{
					num = point.z;
				}
			}
		}
		return num;
	}

	private bool HasMissingData(ERMesh meshData, ERMesh meshData2, int ignore)
	{
		switch (ignore)
		{
		case 0:
			if (meshData.lodIndex == meshData2.lodIndex && meshData.startVecs.Count == 0 && (meshData.vecs.Count != 0 || meshData.endVecs.Count != 0 || meshData.suVecs.Count != 0 || meshData.sdVecs.Count != 0))
			{
				meshData.startVecs = meshData2.startVecs;
				meshData.startUv = meshData2.startUv;
				meshData.startUv2 = meshData2.startUv2;
				meshData.startColors = meshData2.startColors;
				meshData.startNormals = meshData2.startNormals;
				meshData.startTangents = meshData2.startTangents;
				meshData.startTriangles = meshData2.startTriangles;
				meshData.zValueVecIndexesStart = meshData2.zValueVecIndexesStart;
				meshData.zValuesStart = meshData2.zValuesStart;
				return true;
			}
			break;
		case 1:
			if (meshData.lodIndex == meshData2.lodIndex && meshData.vecs.Count == 0 && (meshData.startVecs.Count != 0 || meshData.endVecs.Count != 0 || meshData.suVecs.Count != 0 || meshData.sdVecs.Count != 0))
			{
				meshData.vecs = meshData2.vecs;
				meshData.uv = meshData2.uv;
				meshData.uv2 = meshData2.uv2;
				meshData.colors = meshData2.colors;
				meshData.normals = meshData2.normals;
				meshData.tangents = meshData2.tangents;
				meshData.triangles = meshData2.triangles;
				meshData.zValueVecIndexes = meshData2.zValueVecIndexes;
				meshData.zValues = meshData2.zValues;
				return true;
			}
			break;
		case 2:
			if (meshData.lodIndex == meshData2.lodIndex && meshData.endVecs.Count == 0 && (meshData.startVecs.Count != 0 || meshData.vecs.Count != 0 || meshData.suVecs.Count != 0 || meshData.sdVecs.Count != 0))
			{
				meshData.endVecs = meshData2.endVecs;
				meshData.endUv = meshData2.endUv;
				meshData.endUv2 = meshData2.endUv2;
				meshData.endColors = meshData2.endColors;
				meshData.endNormals = meshData2.endNormals;
				meshData.endTangents = meshData2.endTangents;
				meshData.endTriangles = meshData2.endTriangles;
				meshData.zValueVecIndexesEnd = meshData2.zValueVecIndexesEnd;
				meshData.zValuesEnd = meshData2.zValuesEnd;
				return true;
			}
			break;
		case 3:
			if (meshData.lodIndex == meshData2.lodIndex && meshData.suVecs.Count == 0 && (meshData.startVecs.Count != 0 || meshData.vecs.Count != 0 || meshData.endVecs.Count != 0 || meshData.sdVecs.Count != 0))
			{
				meshData.suVecs = meshData2.suVecs;
				meshData.suUv = meshData2.suUv;
				meshData.suUv2 = meshData2.suUv2;
				meshData.suColors = meshData2.suColors;
				meshData.suNormals = meshData2.suNormals;
				meshData.suTangents = meshData2.suTangents;
				meshData.suTriangles = meshData2.suTriangles;
				meshData.zValueVecIndexesStepUp = meshData2.zValueVecIndexesStepUp;
				meshData.zValuesStepUp = meshData2.zValuesStepUp;
				return true;
			}
			break;
		case 4:
			if (meshData.lodIndex == meshData2.lodIndex && meshData.sdVecs.Count == 0 && (meshData.startVecs.Count != 0 || meshData.vecs.Count != 0 || meshData.endVecs.Count != 0 || meshData.suVecs.Count != 0))
			{
				meshData.sdVecs = meshData2.sdVecs;
				meshData.sdUv = meshData2.sdUv;
				meshData.sdUv2 = meshData2.sdUv2;
				meshData.sdColors = meshData2.sdColors;
				meshData.sdNormals = meshData2.sdNormals;
				meshData.sdTangents = meshData2.sdTangents;
				meshData.sdTriangles = meshData2.sdTriangles;
				meshData.zValueVecIndexesStepDown = meshData2.zValueVecIndexesStepDown;
				meshData.zValuesStepDown = meshData2.zValuesStepDown;
				return true;
			}
			break;
		}
		return false;
	}

	public void OODOOOQQCO(SideObject so)
	{
		name = so.name + " [duplicate]";
		id = so.id;
		id = (timestamp = DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds);
		objectType = so.objectType;
		gameobjectGUID = so.gameobjectGUID;
		textureGUID = so.textureGUID;
		m_distance = so.m_distance;
		uvx = so.uvx;
		uvy = so.uvy;
		position = so.position;
		splinePosition = so.splinePosition;
		selectedRotation = so.selectedRotation;
		randomYAxisMinRotation = so.randomYAxisMinRotation;
		randomYAxisMaxRotation = so.randomYAxisMaxRotation;
		nodeList = new List<Vector2>(so.nodeList);
		uvs = new List<float>(so.uvs);
		uvDistances = new List<float>(so.uvDistances);
		clampUVs = so.clampUVs;
		clampUVY = so.clampUVY;
		clampUVYValue = so.clampUVYValue;
		terrainUVs = so.terrainUVs;
		totalDistance = so.totalDistance;
		snapList = new List<bool>(so.snapList);
		snapWeightList = new List<float>(so.snapWeightList);
		colorList = new List<Color>(so.colorList);
		gameobjectStartGUID = so.gameobjectStartGUID;
		gameobjectEndGUID = so.gameobjectEndGUID;
		align = so.align;
		alignPoint = so.alignPoint;
		weld = so.weld;
		combine = so.combine;
		combineInstantiated = so.combineInstantiated;
		markerActive = so.markerActive;
		uvType = so.uvType;
		uv = so.uv;
		randomObjects = so.randomObjects;
		forwardStartOffset = so.forwardStartOffset;
		sidewaysOffset = so.sidewaysOffset;
		density = so.density;
		goPath = so.goPath;
		startPath = so.startPath;
		endPath = so.endPath;
		texturePath = so.texturePath;
		terrainTree = so.terrainTree;
		minScale = so.minScale;
		maxScale = so.maxScale;
		childOrderActive = so.childOrderActive;
		childOrder = so.childOrder;
		xPosition = so.xPosition;
		xPosition2 = so.xPosition2;
		relativeTo = so.relativeTo;
		yPosition = so.yPosition;
		yRotation = so.yRotation;
		oldSidwaysDistance = so.oldSidwaysDistance;
		sidewaysDistanceUpdate = so.sidewaysDistanceUpdate;
		uvYRound = so.uvYRound;
		adjustUV = so.adjustUV;
		collider = so.collider;
		boxcollider = so.boxcollider;
		tangents = so.tangents;
		sourceObject = so.sourceObject;
		flipMesh = so.flipMesh;
		startObject = so.startObject;
		endObject = so.endObject;
		connectionObject = so.connectionObject;
		material = so.material;
		boxSize = so.boxSize;
		boxOffset = so.boxOffset;
		includeStartSegment = so.includeStartSegment;
		startSegmentOffset = so.startSegmentOffset;
		includeStartEdgeTris = so.includeStartEdgeTris;
		includeEndSegment = so.includeEndSegment;
		endSegmentOffset = so.endSegmentOffset;
		includeEndEdgeTris = so.includeEndEdgeTris;
		adjustToRoadWidth = so.adjustToRoadWidth;
		xOffset = so.xOffset;
		startOffset = so.startOffset;
		endOffset = so.endOffset;
		defaultStartOffset = so.defaultStartOffset;
		defaultEndOffset = so.defaultEndOffset;
		totalZDistance = so.totalZDistance;
		middleZDistance = so.middleZDistance;
		startZDistance = so.startZDistance;
		endZDistance = so.endZDistance;
		minStartZ = so.minStartZ;
		maxStartZ = so.maxStartZ;
		minMiddleZ = so.minMiddleZ;
		maxMiddleZ = so.maxMiddleZ;
		minEndZ = so.minEndZ;
		maxEndZ = so.maxEndZ;
		smoothStart = so.smoothStart;
		smoothMiddle = so.smoothMiddle;
		smoothEnd = so.smoothEnd;
		layer = so.layer;
		isStatic = so.isStatic;
		castShadows = so.castShadows;
		bridgeObject = so.bridgeObject;
		tunnelObject = so.tunnelObject;
		snapToTerrain = so.snapToTerrain;
		deformationObject = so.deformationObject;
		scaleToRoad = so.scaleToRoad;
		splitInBatches = so.splitInBatches;
		meshBoundsAlignment = so.meshBoundsAlignment;
		randomRotation = so.randomRotation;
		randomMinRotation = so.randomMinRotation;
		randomMaxRotation = so.randomMaxRotation;
		minRandomRotationDistance = so.minRandomRotationDistance;
		maxRandomRotationDistance = so.maxRandomRotationDistance;
		randomXPosition = so.randomXPosition;
		randomMinXPosition = so.randomMinXPosition;
		randomMaxXPosition = so.randomMaxXPosition;
		minRandomXPositionDistance = so.minRandomXPositionDistance;
		maxRandomXPositionDistance = so.maxRandomXPositionDistance;
		boxColliderScale = so.boxColliderScale;
		randomYPosition = so.randomYPosition;
		randomMinYPosition = so.randomMinYPosition;
		randomMaxYPosition = so.randomMaxYPosition;
		minRandomYPositionDistance = so.minRandomYPositionDistance;
		maxRandomYPositionDistance = so.maxRandomYPositionDistance;
		indentController = so.indentController;
		excludeTerrainSplats = so.excludeTerrainSplats;
		bridgeHeight = so.bridgeHeight;
		markerSplineController = so.markerSplineController;
		bridgeLength = so.bridgeLength;
		deformationOffset = so.deformationOffset;
		markerIndent = so.markerIndent;
		markerSurrounding = so.markerSurrounding;
		scale = so.scale;
		indentExt = so.indentExt;
		targetObject = so.targetObject;
		category = so.category;
		densityMap = so.densityMap;
		densitySize = so.densitySize;
		densitySize2 = so.densitySize2;
		densityStrength = so.densityStrength;
		densityStrength2 = so.densityStrength2;
		terrainNormal = so.terrainNormal;
		terrainNormal2 = so.terrainNormal2;
		childObjects = new List<ERChildsSO>(so.childObjects);
		autoGenerate = so.autoGenerate;
		heightThreshold = so.heightThreshold;
		autogenerateStartOffset = so.autogenerateStartOffset;
		autogenerateEndOffset = so.autogenerateEndOffset;
		snapIndents = so.snapIndents;
		snapIndentWidth = so.snapIndentWidth;
		cutHoles = so.cutHoles;
		innerStartOffset = so.innerStartOffset;
		innerEndOffset = so.innerEndOffset;
		ignoredForRetainingWalls = so.ignoredForRetainingWalls;
		heightMaxThreshold = so.heightMaxThreshold;
		heightMaxStartThreshold = so.heightMaxStartThreshold;
		heightMaxEndThreshold = so.heightMaxEndThreshold;
		xThresholdDistance = so.xThresholdDistance;
		angleThreshold = so.angleThreshold;
		connectionRatio = so.connectionRatio;
		retainingWall = so.retainingWall;
		surroundingControl = so.surroundingControl;
		indentControl = so.indentControl;
		nodeListMirrored = new List<Vector2>(so.nodeListMirrored);
		uvsMirrored = new List<float>(so.uvsMirrored);
		snapWeightListMirrored = new List<float>(so.snapWeightListMirrored);
		colorListMirrored = so.colorListMirrored;
		hasVertexColors = so.hasVertexColors;
		deformationOffsetForward = so.deformationOffsetForward;
		deformationOffsetSideways = so.deformationOffsetSideways;
		connectionObjectRotation = so.connectionObjectRotation;
		subMesh = so.subMesh;
		acceptBarriers = so.acceptBarriers;
		activeOnBridges = so.activeOnBridges;
		dualSided = so.dualSided;
		mirrorType = so.mirrorType;
		snapVertexColors = so.snapVertexColors;
		minSnapRange = so.minSnapRange;
		maxSnapRange = so.maxSnapRange;
		clampUV4 = so.clampUV4;
		geoStartOffset = so.geoStartOffset;
		geoEndOffset = so.geoEndOffset;
		startOverlapOffset = so.startOverlapOffset;
		endOverlapOffset = so.endOverlapOffset;
		lodLevels = so.lodLevels;
		hardEdge = new List<bool>(so.hardEdge);
		hardEdgePadding = so.hardEdgePadding;
		startEndCaps = so.startEndCaps;
		endCapUVs = new List<Vector2>(so.endCapUVs);
		startCapUVs = new List<Vector2>(so.startCapUVs);
		startCapTris = new List<int>(so.startCapTris);
		startCapTrisMirrored = new List<int>(so.startCapTrisMirrored);
		startCapUVOffset = so.startCapUVOffset;
		endCapUVOffset = so.endCapUVOffset;
		startCapUVScale = so.startCapUVScale;
		endCapUVScale = so.endCapUVScale;
		startCapUVRotation = so.startCapUVRotation;
		endCapUVRotation = so.endCapUVRotation;
		namedChilds = so.namedChilds;
		startSection = so.startSection;
		endSection = so.endSection;
		stepDown = so.stepDown;
		stepUp = so.stepUp;
		stepDistance = so.stepDistance;
		startDirZOffset = so.startDirZOffset;
		endDirZOffset = so.endDirZOffset;
		buildOtherSideObject1 = so.buildOtherSideObject1;
		defaultOtherSoId1 = so.defaultOtherSoId1;
		buildOtherSideObject2 = so.buildOtherSideObject2;
		defaultOtherSoId2 = so.defaultOtherSoId2;
		buildOtherSideObjects = new List<double>(so.buildOtherSideObjects);
		averageDistance = so.averageDistance;
		randomUVx = so.randomUVx;
		isUsedAsChild = so.isUsedAsChild;
		if (so.meshObjects.Count > 0)
		{
			OQDDDDOOQD(Vector3.zero, updateTimeStamp: false);
		}
	}

	public void OCDOCDQQQO(SideObjectLog so)
	{
		name = so.name;
		id = so.id;
		timestamp = so.timestamp;
		objectType = so.objectType;
		gameobjectGUID = so.gameobjectGUID;
		textureGUID = so.textureGUID;
		m_distance = so.m_distance;
		uvx = so.uvx;
		uvy = so.uvy;
		position = so.position;
		splinePosition = so.splinePosition;
		selectedRotation = so.selectedRotation;
		randomYAxisMinRotation = so.randomYAxisMinRotation;
		randomYAxisMaxRotation = so.randomYAxisMaxRotation;
		nodeList = new List<Vector2>(so.nodeList);
		uvs = new List<float>(so.uvs);
		uvDistances = new List<float>(so.uvDistances);
		clampUVs = so.clampUVs;
		clampUVY = so.clampUVY;
		clampUVYValue = so.clampUVYValue;
		terrainUVs = so.terrainUVs;
		totalDistance = so.totalDistance;
		snapList = new List<bool>(so.snapList);
		snapWeightList = new List<float>(so.snapWeightList);
		colorList = new List<Color>(so.colorList);
		gameobjectStartGUID = so.gameobjectStartGUID;
		gameobjectEndGUID = so.gameobjectEndGUID;
		align = so.align;
		alignPoint = so.alignPoint;
		weld = so.weld;
		combine = so.combine;
		combineInstantiated = so.combineInstantiated;
		markerActive = so.markerActive;
		uvType = so.uvType;
		uv = so.uv;
		randomObjects = so.randomObjects;
		forwardStartOffset = so.forwardStartOffset;
		sidewaysOffset = so.sidewaysOffset;
		density = so.density;
		goPath = so.goPath;
		startPath = so.startPath;
		endPath = so.endPath;
		texturePath = so.texturePath;
		terrainTree = so.terrainTree;
		minScale = so.minScale;
		maxScale = so.maxScale;
		childOrderActive = so.childOrderActive;
		childOrder = so.childOrder;
		xPosition = so.xPosition;
		xPosition2 = so.xPosition2;
		relativeTo = so.relativeTo;
		yPosition = so.yPosition;
		yRotation = so.yRotation;
		oldSidwaysDistance = so.oldSidwaysDistance;
		sidewaysDistanceUpdate = so.sidewaysDistanceUpdate;
		uvYRound = so.uvYRound;
		adjustUV = so.adjustUV;
		collider = so.collider;
		boxcollider = so.boxcollider;
		tangents = so.tangents;
		sourceObject = so.sourceObject;
		flipMesh = so.flipMesh;
		startObject = so.startObject;
		endObject = so.endObject;
		connectionObject = so.connectionObject;
		material = so.material;
		boxSize = so.boxSize;
		boxOffset = so.boxOffset;
		includeStartSegment = so.includeStartSegment;
		startSegmentOffset = so.startSegmentOffset;
		includeStartEdgeTris = so.includeStartEdgeTris;
		includeEndSegment = so.includeEndSegment;
		endSegmentOffset = so.endSegmentOffset;
		includeEndEdgeTris = so.includeEndEdgeTris;
		adjustToRoadWidth = so.adjustToRoadWidth;
		xOffset = so.xOffset;
		startOffset = so.startOffset;
		endOffset = so.endOffset;
		defaultStartOffset = so.defaultStartOffset;
		defaultEndOffset = so.defaultEndOffset;
		totalZDistance = so.totalZDistance;
		middleZDistance = so.middleZDistance;
		startZDistance = so.startZDistance;
		endZDistance = so.endZDistance;
		minStartZ = so.minStartZ;
		maxStartZ = so.maxStartZ;
		minMiddleZ = so.minMiddleZ;
		maxMiddleZ = so.maxMiddleZ;
		minEndZ = so.minEndZ;
		maxEndZ = so.maxEndZ;
		smoothStart = so.smoothStart;
		smoothMiddle = so.smoothMiddle;
		smoothEnd = so.smoothEnd;
		layer = so.layer;
		isStatic = so.isStatic;
		castShadows = so.castShadows;
		bridgeObject = so.bridgeObject;
		tunnelObject = so.tunnelObject;
		snapToTerrain = so.snapToTerrain;
		deformationObject = so.deformationObject;
		scaleToRoad = so.scaleToRoad;
		splitInBatches = so.splitInBatches;
		meshBoundsAlignment = so.meshBoundsAlignment;
		randomRotation = so.randomRotation;
		randomMinRotation = so.randomMinRotation;
		randomMaxRotation = so.randomMaxRotation;
		minRandomRotationDistance = so.minRandomRotationDistance;
		maxRandomRotationDistance = so.maxRandomRotationDistance;
		randomXPosition = so.randomXPosition;
		randomMinXPosition = so.randomMinXPosition;
		randomMaxXPosition = so.randomMaxXPosition;
		minRandomXPositionDistance = so.minRandomXPositionDistance;
		maxRandomXPositionDistance = so.maxRandomXPositionDistance;
		boxColliderScale = so.boxColliderScale;
		randomYPosition = so.randomYPosition;
		randomMinYPosition = so.randomMinYPosition;
		randomMaxYPosition = so.randomMaxYPosition;
		minRandomYPositionDistance = so.minRandomYPositionDistance;
		maxRandomYPositionDistance = so.maxRandomYPositionDistance;
		indentController = so.indentController;
		excludeTerrainSplats = so.excludeTerrainSplats;
		bridgeHeight = so.bridgeHeight;
		markerSplineController = so.markerSplineController;
		bridgeLength = so.bridgeLength;
		deformationOffset = so.deformationOffset;
		markerIndent = so.markerIndent;
		markerSurrounding = so.markerSurrounding;
		scale = so.scale;
		targetObject = so.targetObject;
		category = so.category;
		densityMap = so.densityMap;
		densitySize = so.densitySize;
		densitySize2 = so.densitySize2;
		densityStrength = so.densityStrength;
		densityStrength2 = so.densityStrength2;
		terrainNormal = so.terrainNormal;
		terrainNormal2 = so.terrainNormal2;
		childObjects = new List<ERChildsSO>(so.childObjects);
		autoGenerate = so.autoGenerate;
		heightThreshold = so.heightThreshold;
		autogenerateStartOffset = so.autogenerateStartOffset;
		autogenerateEndOffset = so.autogenerateEndOffset;
		snapIndents = so.snapIndents;
		snapIndentWidth = so.snapIndentWidth;
		cutHoles = so.cutHoles;
		innerStartOffset = so.innerStartOffset;
		innerEndOffset = so.innerEndOffset;
		ignoredForRetainingWalls = so.ignoredForRetainingWalls;
		heightMaxThreshold = so.heightMaxThreshold;
		heightMaxStartThreshold = so.heightMaxStartThreshold;
		heightMaxEndThreshold = so.heightMaxEndThreshold;
		xThresholdDistance = so.xThresholdDistance;
		angleThreshold = so.angleThreshold;
		connectionRatio = so.connectionRatio;
		retainingWall = so.retainingWall;
		surroundingControl = so.surroundingControl;
		indentControl = so.indentControl;
		nodeListMirrored = new List<Vector2>(so.nodeListMirrored);
		uvsMirrored = new List<float>(so.uvsMirrored);
		snapWeightListMirrored = new List<float>(so.snapWeightListMirrored);
		colorListMirrored = so.colorListMirrored;
		hasVertexColors = so.hasVertexColors;
		deformationOffsetForward = so.deformationOffsetForward;
		deformationOffsetSideways = so.deformationOffsetSideways;
		connectionObjectRotation = so.connectionObjectRotation;
		subMesh = so.subMesh;
		acceptBarriers = so.acceptBarriers;
		activeOnBridges = so.activeOnBridges;
		dualSided = so.dualSided;
		mirrorType = so.mirrorType;
		snapVertexColors = so.snapVertexColors;
		minSnapRange = so.minSnapRange;
		maxSnapRange = so.maxSnapRange;
		clampUV4 = so.clampUV4;
		geoStartOffset = so.geoStartOffset;
		geoEndOffset = so.geoEndOffset;
		startOverlapOffset = so.startOverlapOffset;
		endOverlapOffset = so.endOverlapOffset;
		lodLevels = so.lodLevels;
		hardEdge = new List<bool>(so.hardEdge);
		hardEdgePadding = so.hardEdgePadding;
		startEndCaps = so.startEndCaps;
		endCapUVs = new List<Vector2>(so.endCapUVs);
		startCapUVs = new List<Vector2>(so.startCapUVs);
		startCapTris = new List<int>(so.startCapTris);
		startCapTrisMirrored = new List<int>(so.startCapTrisMirrored);
		startCapUVOffset = so.startCapUVOffset;
		endCapUVOffset = so.endCapUVOffset;
		startCapUVScale = so.startCapUVScale;
		endCapUVScale = so.endCapUVScale;
		startCapUVRotation = so.startCapUVRotation;
		endCapUVRotation = so.endCapUVRotation;
		namedChilds = so.namedChilds;
		startSection = so.startSection;
		endSection = so.endSection;
		stepDown = so.stepDown;
		stepUp = so.stepUp;
		stepDistance = so.stepDistance;
		startDirZOffset = so.startDirZOffset;
		endDirZOffset = so.endDirZOffset;
		buildOtherSideObject1 = so.buildOtherSideObject1;
		defaultOtherSoId1 = so.defaultOtherSoId1;
		buildOtherSideObject2 = so.buildOtherSideObject2;
		defaultOtherSoId2 = so.defaultOtherSoId2;
		buildOtherSideObjects = new List<double>(so.buildOtherSideObjects);
		averageDistance = so.averageDistance;
		randomUVx = so.randomUVx;
		isUsedAsChild = so.isUsedAsChild;
		if (objectType > 0 && (bool)sourceObject)
		{
			if (objectType == 1)
			{
				OOOCDOQOOC(updateTimeStamp: false);
			}
			else
			{
				OQDDDDOOQD(Vector3.zero, updateTimeStamp: false);
			}
		}
		if (objectType == 1 && nodeList.Count > 0)
		{
			OOOCDOQOOC(updateTimeStamp: false);
		}
	}

	public void Clear()
	{
		for (int i = 0; i < meshObjects.Count; i++)
		{
			meshObjects[i].Clear();
		}
	}
}
[Serializable]
public enum ERRoadSide
{
	Left,
	Right,
	Both
}
[Serializable]
public class ERConnectionSibling
{
	private class á : IComparer
	{
		int IComparer.Compare(object a, object b)
		{
			ERConnectionSibling eRConnectionSibling = (ERConnectionSibling)a;
			ERConnectionSibling eRConnectionSibling2 = (ERConnectionSibling)b;
			if (eRConnectionSibling.roadType.type > eRConnectionSibling2.roadType.type)
			{
				return 1;
			}
			if (eRConnectionSibling.roadType.type < eRConnectionSibling2.roadType.type)
			{
				return -1;
			}
			if (eRConnectionSibling.angle < eRConnectionSibling2.angle)
			{
				return -1;
			}
			return 1;
		}
	}

	[Serializable]
	[CompilerGenerated]
	private sealed class á
	{
		public static readonly á <>9 = new á();

		public static Comparison<ERConnectionSibling> <>9__109_0;

		internal int <CreateInstance>b__109_0(ERConnectionSibling x, ERConnectionSibling y)
		{
			return x.angle.CompareTo(y.angle);
		}
	}

	public string name = "";

	public ERModularRoad road;

	public Transform transform;

	public Vector3 angleControlPoint = Vector3.zero;

	public QDQDOOQQDQODD roadType;

	public double roadTypeID = 0.0;

	public QDQDOOQQDQODD roadTypeAI;

	public double roadTypeAIid = 0.0;

	public bool aIInit = false;

	public int roadTypeIndex = 0;

	public int priorityLevel = 0;

	public bool priorityRoad = false;

	public int prioritySectionStart = -1;

	public int prioritySectionEnd = -1;

	public float angle;

	public float prevAngle;

	public float roadWidth;

	public Vector3 controlPoint;

	public List<Vector2> roadShape = new List<Vector2>();

	public List<bool> hardEdge = new List<bool>();

	public List<float> roadShapeUVs = new List<float>();

	public List<bool> originalShapeVecs = new List<bool>();

	public bool includeOuterLaneOffset = true;

	public float leftFixedDistance = 0f;

	public float rightFixedDistance = 0f;

	public int buildPriority = 0;

	public bool highPriorityConnection = false;

	public int triangulationType = 0;

	public bool adjustRadius = false;

	public float resolution = 1f;

	public int defaultSegments = 5;

	public int segments = 5;

	public float radius = 3f;

	public float leftCornerAngle = 1f;

	public float rightCornerAngle = 1f;

	public Vector3 leftCurvatureDir;

	public Vector3 leftCurvatureVec;

	public Vector3 rightCurvatureDir;

	public Vector3 rightCurvatureVec;

	public ERFlexConnectionType leftConnectionType;

	public ERFlexConnectionType rightConnectionType;

	public Vector3 cp;

	public Vector3 oldCP;

	public Vector3 cp1;

	public Vector3 lStart;

	public Vector3 lEnd;

	public Vector3 rStart;

	public Vector3 rEnd;

	public Vector3 ip;

	public Vector3 dir;

	public Vector3 outerCorner;

	public float cornerHandleScale = 1f;

	public List<Vector3> leftRoundingPoints = new List<Vector3>();

	public List<Vector3> rightRoundingPoints = new List<Vector3>();

	public List<Vector3> innerRoundingPoints = new List<Vector3>();

	public List<Vector3> priorityLeftPoints = new List<Vector3>();

	public List<Vector3> priorityRightPoints = new List<Vector3>();

	public List<Vector3> priorityPointsMain = new List<Vector3>();

	public List<Vector2> priorityPointsMainUVs = new List<Vector2>();

	public List<List<Vector3>> roadVecs = new List<List<Vector3>>();

	public List<List<Vector3>> roadVecsRight = new List<List<Vector3>>();

	public List<List<Vector3>> roadVecsLeft = new List<List<Vector3>>();

	public List<List<Vector2>> roadUVs = new List<List<Vector2>>();

	public List<List<Vector2>> roadUVsLeft = new List<List<Vector2>>();

	public List<List<Vector2>> roadUVsRight = new List<List<Vector2>>();

	public List<int> connectionVecInts = new List<int>();

	public List<float> roadVecPerc = new List<float>();

	public int leftFixedIndex = 0;

	public int rightFixedIndex = 0;

	public int middleIndex = 0;

	public int middleIndentIndexLeft = -1;

	public int middleIndentIndexRight = -1;

	public ERSideWalk leftSidewalk;

	public ERSideWalk rightSidewalk;

	public bool leftSidewalkActive = false;

	public bool rightSidewalkActive = false;

	public List<List<Vector3>> leftSidewalkVecs = new List<List<Vector3>>();

	public List<List<Vector2>> leftSidewalkUVs = new List<List<Vector2>>();

	public List<List<Vector3>> rightSidewalkVecs = new List<List<Vector3>>();

	public List<List<Vector2>> rightSidewalkUVs = new List<List<Vector2>>();

	public List<Vector3> leftIndentvecs = new List<Vector3>();

	public List<Vector3> rightIndentvecs = new List<Vector3>();

	public List<Vector3> leftSurroundingvecs = new List<Vector3>();

	public List<Vector3> rightSurroundingvecs = new List<Vector3>();

	public int leftIndent = 0;

	public int rightIndent = 0;

	public Vector3 leftIndentV3;

	public Vector3 rightIndentV3;

	public int leftSurrounding = 0;

	public int rightSurrounding = 0;

	public Vector3 leftSurroundingV3;

	public Vector3 rightSurroundingV3;

	public float uvRatio = 0.2f;

	public float uvy = 0f;

	public int mainRoadConnectionEdgeDecal = 0;

	public GameObject mainConnectionDecal;

	public List<Vector3> mainConnectionDecalVecs = new List<Vector3>();

	public Vector3 mainConnectionDecalEndDir;

	public int middleInt = 0;

	public bool primaryPriorityConnection = false;

	public bool secondaryPriorityConnection = false;

	public bool shapeSubSegments = false;

	public List<int> normalIndexes = new List<int>();

	public bool primarySection = false;

	public ERLaneData laneData;

	public bool hasChanged = false;

	public void Clear()
	{
		leftRoundingPoints.Clear();
		rightRoundingPoints.Clear();
		innerRoundingPoints.Clear();
		priorityLeftPoints.Clear();
		priorityRightPoints.Clear();
		priorityPointsMain = new List<Vector3>();
		priorityPointsMainUVs.Clear();
		roadVecs.Clear();
		roadUVs.Clear();
		hardEdge.Clear();
		roadVecsRight.Clear();
		roadVecsLeft.Clear();
		roadUVsLeft.Clear();
		roadUVsRight.Clear();
		originalShapeVecs.Clear();
		connectionVecInts.Clear();
		leftSidewalkVecs.Clear();
		leftSidewalkUVs.Clear();
		rightSidewalkVecs.Clear();
		rightSidewalkUVs.Clear();
		leftIndentvecs.Clear();
		rightIndentvecs.Clear();
		leftSurroundingvecs.Clear();
		rightSurroundingvecs.Clear();
		middleIndentIndexLeft = -1;
		middleIndentIndexRight = -1;
		prioritySectionStart = -1;
		prioritySectionEnd = -1;
		mainConnectionDecalVecs.Clear();
		normalIndexes.Clear();
		hasChanged = false;
	}

	private void Init(ERModularRoad scr, float angle, Vector3 controlPoint, Transform transform)
	{
		road = scr;
		this.angle = angle;
		angleControlPoint = controlPoint;
		this.transform = transform;
		if (scr != null)
		{
			GetRoadTypeIndex(scr.roadType, scr.baseScript.roadTypes);
		}
	}

	public static ERConnectionSibling CreateInstance(ERModularRoad scr, float angle, Vector3 controlPoint, Transform transform, List<ERConnectionSibling> siblings)
	{
		ERConnectionSibling eRConnectionSibling = new ERConnectionSibling();
		if (siblings != null && angle == 0f)
		{
			angle = 0f;
			if (siblings.Count == 1)
			{
				angle = siblings[0].angle + 180f;
			}
			else if (siblings.Count > 1)
			{
				float num = 0f;
				List<ERConnectionSibling> list = new List<ERConnectionSibling>(siblings);
				list.Sort((ERConnectionSibling x, ERConnectionSibling y) => x.angle.CompareTo(y.angle));
				for (int num2 = 0; num2 < list.Count; num2++)
				{
					if (num2 < list.Count - 1)
					{
						if (list[num2 + 1].angle - list[num2].angle > num)
						{
							num = list[num2 + 1].angle - list[num2].angle;
							angle = list[num2].angle + num * 0.5f;
						}
					}
					else if (list[0].angle + 360f - list[num2].angle > num)
					{
						angle = list[num2].angle + num * 0.5f;
					}
				}
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
		}
		eRConnectionSibling.Init(scr, angle, controlPoint, transform);
		return eRConnectionSibling;
	}

	private void GetRoadTypeIndex(double id, List<QDQDOOQQDQODD> types)
	{
		for (int i = 0; i < types.Count; i++)
		{
			if (id == types[i].id)
			{
				roadTypeIndex = i + 1;
				roadType = (roadTypeAI = types[i]);
				roadTypeID = (roadTypeAIid = roadTypeAI.id);
				break;
			}
		}
	}

	public void ODDQDOCDCC(int index, List<QDQDOOQQDQODD> types)
	{
		roadTypeIndex = index;
		roadType = types[index - 1];
	}

	public void OCQQDCCOQO(List<QDQDOOQQDQODD> types)
	{
		if ((float)defaultSegments * 0.5f == Mathf.Round((float)defaultSegments * 0.5f))
		{
		}
		if (roadTypeIndex == 0 || types.Count < roadTypeIndex)
		{
			return;
		}
		if (types[roadTypeIndex - 1] != roadType)
		{
			for (int i = 0; i < types.Count; i++)
			{
				if (types[i] == roadType)
				{
					roadTypeIndex = i + 1;
					break;
				}
			}
			if (types[roadTypeIndex - 1] != roadType)
			{
				roadType = types[roadTypeIndex - 1];
			}
		}
		if (roadType != null)
		{
			roadTypeID = roadType.id;
		}
		roadWidth = roadType.roadWidth;
		uvRatio = 5f * roadType.uvTiling;
		if (roadType.roadShape.Count == 0)
		{
			roadType.roadShape = new List<Vector2>();
			roadType.roadShape.Add(new Vector2((0f - roadWidth) * 0.5f, 0f));
			roadType.roadShape.Add(new Vector2(roadWidth * 0.5f, 0f));
			UnityEngine.Debug.Log("EasyRoads3Dv3: The road shape for road type '" + roadType.roadTypeName + "' is not set correctly");
		}
		if (!roadType.roadShapeData.isset)
		{
			roadType.roadShapeData = new ERRoadShape(roadType.roadWidth);
			roadType.roadShapeData.OCCQQDOQOD(roadType.roadShape);
			if (roadType.roadShape.Count == 0)
			{
				roadType.roadShape = new List<Vector2>(roadType.roadShapeData.nodes);
			}
		}
		if (roadType.roadShapeData.isset)
		{
			roadShape = new List<Vector2>(roadType.roadShapeExt2);
			roadShapeUVs = new List<float>(roadType.roadShapeExtUVs2);
			hardEdge = new List<bool>(roadType.roadShapeData.hardEdge);
			if (roadShape.Count == 0)
			{
				if (roadType.roadShapeData.nodes.Count > 0)
				{
					roadType.roadShapeExt2 = new List<Vector2>(roadType.roadShapeData.nodes);
					roadType.roadShapeExtUVs2 = ODQDQDQDQO.OCOCDCOQCD(roadType.roadShapeData.nodes);
					ODCCODOCQQ.RebuildMainRoadShape(roadType);
				}
				else
				{
					roadType.roadShapeData = new ERRoadShape(roadType.roadWidth);
					roadType.roadShapeData.OCCQQDOQOD(roadType.roadShape);
				}
				roadShape = new List<Vector2>(roadType.roadShapeExt2);
				roadShapeUVs = new List<float>(roadType.roadShapeExtUVs2);
				hardEdge = new List<bool>(roadType.roadShapeData.hardEdge);
			}
			if (roadType.roadShapeData.isSymmetrical == 0)
			{
				roadType.roadShapeData.IsSymmetrical();
			}
		}
		else
		{
			roadShape = new List<Vector2>(roadType.roadShape);
			roadShapeUVs = new List<float>(roadType.roadShapeUVs);
			hardEdge.Clear();
			foreach (Vector2 item in roadShape)
			{
				hardEdge.Add(item: false);
			}
		}
		BuildRoadShape();
	}

	private void BuildRoadShape()
	{
		foreach (Vector2 item2 in roadShape)
		{
			originalShapeVecs.Add(item: true);
		}
		leftFixedIndex = 0;
		rightFixedIndex = roadShape.Count - 1;
		if (roadType.roadShapeData.isset)
		{
			if (roadType.roadShapeData.outerLaneMarkingLeftIndex != -1)
			{
				includeOuterLaneOffset = true;
				leftFixedDistance = roadShape[0].x - roadShape[roadType.roadShapeData.outerLaneMarkingLeftIndex].x;
				leftFixedIndex = roadType.roadShapeData.outerLaneMarkingLeftIndex;
				if (!roadType.roadShapeData.includeOuterlaneLeftInShape)
				{
					originalShapeVecs[roadType.roadShapeData.outerLaneMarkingLeftIndex] = false;
				}
			}
			if (roadType.roadShapeData.outerLaneMarkingRightIndex != -1)
			{
				includeOuterLaneOffset = true;
				rightFixedDistance = roadShape[roadShape.Count - 1].x - roadShape[roadType.roadShapeData.outerLaneMarkingRightIndex].x;
				rightFixedIndex = roadType.roadShapeData.outerLaneMarkingRightIndex;
				if (!roadType.roadShapeData.includeOuterlaneRightInShape)
				{
					originalShapeVecs[roadType.roadShapeData.outerLaneMarkingRightIndex] = false;
				}
			}
		}
		if (includeOuterLaneOffset && !roadType.roadShapeData.isset)
		{
			leftFixedDistance = roadShape[0].x - 0.1f * roadShape[0].x;
			rightFixedDistance = roadShape[roadShape.Count - 1].x - 0.1f * roadShape[roadShape.Count - 1].x;
			bool flag = false;
			bool flag2 = false;
			for (int i = 0; i < roadShape.Count; i++)
			{
				if (roadShape[i].x > leftFixedDistance && !flag)
				{
					Vector2 vector = GetVector2(roadShape[i - 1], roadShape[i], new Vector2(leftFixedDistance, 0f));
					roadShape.Insert(i, vector);
					roadShapeUVs.Insert(i, 0.05f);
					hardEdge.Insert(i, item: false);
					originalShapeVecs.Insert(i, item: false);
					flag = true;
					leftFixedIndex = i;
					leftFixedDistance = Vector2.Distance(roadShape[0], roadShape[leftFixedIndex]);
					middleIndex++;
				}
				if (roadShape[i].x > rightFixedDistance && !flag2)
				{
					Vector2 vector2 = GetVector2(roadShape[i - 1], roadShape[i], new Vector2(rightFixedDistance, 0f));
					roadShape.Insert(i, vector2);
					roadShapeUVs.Insert(i, 0.95f);
					hardEdge.Insert(i, item: false);
					originalShapeVecs.Insert(i, item: false);
					flag2 = true;
					rightFixedIndex = i;
					rightFixedDistance = Vector2.Distance(roadShape[roadShape.Count - 1], roadShape[rightFixedIndex]);
				}
			}
			leftFixedIndex = 1;
			rightFixedIndex = 2;
		}
		float x = roadShape[0].x;
		float x2 = roadShape[0].x;
		int num = -1;
		for (int j = 0; j < roadShape.Count; j++)
		{
			if (roadShape[j].x <= 0.01f)
			{
				x = roadShape[j].x;
			}
			if (roadShape[j].x > 0f && x2 < 0f)
			{
				x2 = roadShape[j].x;
			}
			if (num == -1 && roadShape[j].x >= 0f)
			{
				num = (middleIndex = j);
			}
		}
		if (x < x * 0.1f && x2 > x2 * 0.1f)
		{
			Vector2 item = roadShape[num - 1];
			item.x = 0f;
			roadShape.Insert(num, item);
			roadShapeUVs.Insert(num, 0.5f);
			originalShapeVecs.Insert(num, item: false);
			hardEdge.Insert(num, item: false);
			if (rightFixedIndex >= 0)
			{
				rightFixedIndex++;
			}
		}
		else
		{
			for (int k = 0; k < roadShape.Count; k++)
			{
				if (roadShape[k].x >= 0f)
				{
					middleIndex = k;
					break;
				}
			}
		}
		float num2 = Mathf.Abs(roadShape[middleIndex - 1].x);
		float num3 = Mathf.Abs(roadShape[middleIndex - 1].x) / Mathf.Abs(roadShape[0].x);
		if ((double)num3 < 0.6)
		{
			shapeSubSegments = true;
		}
	}

	public static void SetPriorityConnection(List<ERConnectionSibling> siblings, int index)
	{
		for (int i = 0; i < siblings.Count; i++)
		{
			if (i == index)
			{
				siblings[i].priorityRoad = true;
			}
			else
			{
				siblings[i].priorityRoad = false;
			}
		}
	}

	public Vector2 GetVector2(Vector2 v1, Vector2 v2, Vector2 v3)
	{
		Vector2 vector = v1;
		vector.y = 0f;
		Vector2 vector2 = v2;
		vector2.y = 0f;
		Vector3 vector3 = v3;
		vector3.y = 0f;
		float num = Vector2.Distance(v1, v2);
		float num2 = Vector2.Distance(v1, v3);
		return Vector2.Lerp(v1, v2, num2 / num);
	}

	public void OCQODDOQQC(double type, List<QDQDOOQQDQODD> roadTypes)
	{
		for (int i = 0; i < roadTypes.Count; i++)
		{
			if (roadTypes[i].id == type)
			{
				roadTypeIndex = i + 1;
				break;
			}
		}
	}

	public static Vector3 GetAngleControlPoint(Vector3 cp, Vector3 p0, Vector3 p1, Vector3 p2)
	{
		float num = Vector3.Distance(cp, p1);
		float num2 = Vector3.Distance(cp, p0);
		if (num2 == 0f)
		{
			num2 = 5f;
		}
		float num3 = num2 / num;
		num3 = 0.5f;
		float num4 = Vector3.Distance(p1, p2);
		Vector3 vector = cp + (cp - p1).normalized * Vector3.Distance(p1, p2);
		return ERModularRoad.OODODQQQCD(cp, cp, p1, p2, num3, 0.75f);
	}
}
[Serializable]
public class QDQDOOQQDQODD
{
	public string roadTypeName = "New Road";

	public double id;

	public double timestamp;

	public float roadWidth = 6f;

	public float faceDistance = 2f;

	public float angleTreshold = 45f;

	public float uvTiling = 1f;

	public int uv4Type = 0;

	public ERRoadWayType type = ERRoadWayType.Primary;

	public float detailDistance = 50f;

	public bool planarUVs = false;

	public float outerIndent = 0.5f;

	public bool roadShapeDataActive = false;

	public ERRoadShape roadShapeData;

	public float minSpeed = 45f;

	public float maxSpeed = 55f;

	public float speedLimit = 50f;

	public List<Vector2> roadShape = new List<Vector2>();

	public List<Vector2> roadShapeExt = new List<Vector2>();

	public List<Vector2> roadShapeExt2 = new List<Vector2>();

	public List<bool> doConnectionTri = new List<bool>();

	public List<bool> doConnectionTriExt = new List<bool>();

	public List<float> roadShapeUVs = new List<float>();

	public List<float> roadShapeExtUVs = new List<float>();

	public List<float> roadShapeExtUVs2 = new List<float>();

	public List<float> roadShapeUVs2 = new List<float>();

	public bool preserveUVs = false;

	public List<bool> hardEdge = new List<bool>();

	public string roadShapeVecsString = "";

	public double defaultSidewalk = 0.0;

	public bool sidewalks = false;

	public float sidewalkHeight = 0.2f;

	public float sidewalkWidth = 2f;

	public Material roadMaterial;

	public Material[] roadMaterials;

	public PhysicMaterial roadPhysicsMaterial;

	public PhysicMaterial[] roadPhysicsMaterials;

	public Material connectionMaterial;

	public bool isSideObject = false;

	public bool isCustomRoad = false;

	public int subSegments = 1;

	public List<ERSORoad> soData = new List<ERSORoad>();

	public List<ERSORoadExt> soDataExt = new List<ERSORoadExt>();

	public List<ERSORoadLog> soDataLog = new List<ERSORoadLog>();

	public int layer = 0;

	public bool isStatic = true;

	public string tag = "Untagged";

	public bool splatMapActive = false;

	public int splatIndex = 0;

	public int expandLevel = 0;

	public int smoothLevel = 1;

	public float splatOpacity = 1f;

	public bool followTerrainContours;

	public float terrainContoursOffset = 5f;

	public bool terrainDeformation = true;

	public float defaultIndent = 2f;

	public float defaultSurrounding = 2f;

	public bool castShadow = false;

	public bool randomnessFlag = false;

	public float randomYPosition = 0f;

	public float randomMinYPosition = -0.02f;

	public float randomMaxYPosition = 0.02f;

	public float minRandomYPositionDistance = 15f;

	public float maxRandomYPositionDistance = 35f;

	public float randomMinRotation = -1f;

	public float randomMaxRotation = 1f;

	public float minRandomRotationDistance = 15f;

	public float maxRandomRotationDistance = 30f;

	public bool vegetationStudioMaskLineActive = true;

	public float vegetationStudioGrassPerimeter = 2f;

	public float vegetationStudioPlantPerimeter = 3f;

	public float vegetationStudioTreePerimeter = 4f;

	public float vegetationStudioObjectPerimeter = 3f;

	public float vegetationStudioLargeObjectPerimeter = 4f;

	public bool vegetationStudioBiomeMaskActive = false;

	public float vegetationStudioBiomeMaskDistance = 0f;

	public float vegetationStudioBiomeMaskBlendDistance = 0f;

	public float vegetationStudioBiomeMaskNoiseScale = 0f;

	public List<ERDecal> decalPresets = new List<ERDecal>();

	public List<ERDecalClass> decalClassPresets = new List<ERDecalClass>();

	public double defaultRamp = 0.0;

	public int extrusionType = 0;

	public float extrusionDistance = 10f;

	public float fixedDistance = 5f;

	public float connectionAngle = 25f;

	public float connectionRadius = 10f;

	public int isRoadShape = -1;

	public int controlType = 0;

	public void RoadTypeUpgrade()
	{
		type = ERRoadWayType.Primary;
		roadShapeExt2 = new List<Vector2>(roadShape);
		roadShapeExtUVs2 = new List<float>(roadShapeUVs);
		roadShapeData = new ERRoadShape(roadWidth);
		roadShapeData.nodes.Clear();
		for (int i = 0; i < roadShape.Count; i++)
		{
			roadShapeData.nodes.Add(roadShape[i]);
		}
	}

	public int GetTagIndex(string[] tags)
	{
		for (int i = 0; i < tags.Length; i++)
		{
			if (tags[i] == tag)
			{
				return i;
			}
		}
		return 0;
	}

	public static int GetTagIndex(string[] tags, string tag)
	{
		for (int i = 0; i < tags.Length; i++)
		{
			if (tags[i] == tag)
			{
				return i;
			}
		}
		return 0;
	}

	public void OQQOCCODOD()
	{
		isRoadShape = 1;
		if (doConnectionTri.Count != roadShape.Count)
		{
			return;
		}
		for (int i = 0; i < roadShape.Count - 1; i++)
		{
			if (roadShape[i].x <= roadShape[i + 1].x)
			{
				if (roadShape[i].x < roadShape[i + 1].x && !doConnectionTri[i])
				{
					isRoadShape = 0;
					break;
				}
				continue;
			}
			isRoadShape = 0;
			break;
		}
	}

	public QDQDOOQQDQODD(int count)
	{
		roadTypeName = "Road Type " + count;
		UpdateTimestamp();
		id = timestamp;
	}

	public void UpdateTimestamp()
	{
		timestamp = DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
		OQQOCCODOD();
	}

	public static bool ODQDDOCDDC(ERModularBase scr)
	{
		bool result = false;
		for (int i = 0; i < scr.roadTypes.Count; i++)
		{
			for (int j = i + 1; j < scr.roadTypes.Count; j++)
			{
				if (scr.roadTypes[i].id == scr.roadTypes[j].id)
				{
					scr.roadTypes[j].id = DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
					result = true;
					string text = "";
					string text2 = scr.roadTypes[j].roadTypeName;
					if (scr.roadTypes[i].roadTypeName == scr.roadTypes[j].roadTypeName)
					{
						text = "and renamed to '" + scr.roadTypes[j].roadTypeName + " [Duplicate]'";
						scr.roadTypes[j].roadTypeName = scr.roadTypes[j].roadTypeName + " [Duplicate]";
					}
					UnityEngine.Debug.Log("EasyRoads3Dv3 Warning: Duplicated road type conflict detected between '" + scr.roadTypes[i].roadTypeName + "' and '" + text2 + "'. '" + text2 + "' has been updated " + text + ". Please review the scene if this road type is currently used, otherwise you may want to delete it.");
				}
			}
		}
		return result;
	}

	public static string[] RoadNames(List<QDQDOOQQDQODD> roadTypes)
	{
		List<string> list = new List<string>();
		if (roadTypes.Count > 0)
		{
			list.Add("Select Road Type");
			int num = 1;
			for (int i = 0; i < roadTypes.Count; i++)
			{
				list.Add(num + ". " + roadTypes[i].roadTypeName);
				num++;
			}
		}
		else
		{
			list.Add("No Road Types Available");
		}
		return list.ToArray();
	}

	public static string[] Nodes(ERRoadShape data)
	{
		List<string> list = new List<string>();
		if (data.nodes.Count > 0)
		{
			for (int i = 0; i < data.nodes.Count; i++)
			{
				list.Add("Node " + (i + 1));
			}
		}
		else
		{
			list.Add("No Nodes Available");
		}
		return list.ToArray();
	}

	public static string[] LaneNodes(ERRoadShape data)
	{
		List<string> list = new List<string>();
		if (data.lanes.Count > 0)
		{
			for (int i = 0; i < data.lanes.Count; i++)
			{
				list.Add("Lane " + (i + 1));
			}
		}
		else
		{
			list.Add("No lanes Available");
		}
		return list.ToArray();
	}

	public static GUIContent[] LaneNodesContents(ERRoadShape data)
	{
		List<GUIContent> list = new List<GUIContent>();
		if (data.lanes.Count > 0)
		{
			for (int i = 0; i < data.lanes.Count; i++)
			{
				list.Add(new GUIContent("Lane " + (i + 1), ""));
			}
		}
		else
		{
			list.Add(new GUIContent("No lanes Available", ""));
		}
		return list.ToArray();
	}

	public void ODQQQODOQD()
	{
		roadShapeData.leftLanes = (roadShapeData.rightLanes = 0);
		for (int i = 0; i < roadShapeData.lanes.Count; i++)
		{
			ERLane value = roadShapeData.lanes[i];
			if (roadShapeData.lanes[i].direction == ERLaneDirection.Right)
			{
				value.laneIndex = roadShapeData.rightLanes;
				roadShapeData.rightLanes++;
			}
			else
			{
				value.laneIndex = roadShapeData.leftLanes;
				roadShapeData.leftLanes++;
			}
			roadShapeData.lanes[i] = value;
		}
		for (int j = 0; j < roadShapeData.lanes.Count; j++)
		{
			if (roadShapeData.lanes[j].direction == ERLaneDirection.Right)
			{
				ERLane value2 = roadShapeData.lanes[j];
				value2.laneIndex = roadShapeData.rightLanes - roadShapeData.lanes[j].laneIndex - 1;
				roadShapeData.lanes[j] = value2;
			}
		}
	}

	public static int SetRoadType(List<QDQDOOQQDQODD> roadTypes, double roadType)
	{
		if (roadTypes.Count > 0)
		{
			for (int i = 0; i < roadTypes.Count; i++)
			{
				if (roadTypes[i].id == roadType)
				{
					return i + 1;
				}
			}
			return 0;
		}
		return 0;
	}

	public void UpdateUVs()
	{
		int outerLaneMarkingLeftIndex = roadShapeData.outerLaneMarkingLeftIndex;
		int outerLaneMarkingRightIndex = roadShapeData.outerLaneMarkingRightIndex;
		bool includeOuterlaneLeftInShape = roadShapeData.includeOuterlaneLeftInShape;
		bool includeOuterlaneRightInShape = roadShapeData.includeOuterlaneRightInShape;
		int num = 0;
		for (int i = 0; i < roadShapeExtUVs2.Count; i++)
		{
			if ((i != outerLaneMarkingLeftIndex || includeOuterlaneLeftInShape) && (i != outerLaneMarkingRightIndex || includeOuterlaneRightInShape))
			{
				roadShapeUVs[num] = roadShapeExtUVs2[i];
				num++;
			}
		}
	}

	public static QDQDOOQQDQODD GetRoadTypeElByID(List<QDQDOOQQDQODD> roadTypes, double id)
	{
		for (int i = 0; i < roadTypes.Count; i++)
		{
			if (roadTypes[i].id == id)
			{
				return roadTypes[i];
			}
		}
		return null;
	}

	public static int ODDQDCOODD(List<QDQDOOQQDQODD> roadTypes, double id, ref string[] ramps, ref QDQDOOQQDQODD[] rampTypes)
	{
		int result = 0;
		List<string> list = new List<string>();
		List<QDQDOOQQDQODD> list2 = new List<QDQDOOQQDQODD>();
		for (int i = 0; i < roadTypes.Count; i++)
		{
			if (roadTypes[i].type == ERRoadWayType.MotorwayRamp)
			{
				list.Add(list.Count + ". " + roadTypes[i].roadTypeName);
				list2.Add(roadTypes[i]);
				if (roadTypes[i].id == id)
				{
					result = list.Count;
				}
			}
		}
		if (list.Count == 0)
		{
			list.Add("No Motorway Ramps available");
		}
		else
		{
			list.Insert(0, "Select Motorway Ramp");
		}
		ramps = list.ToArray();
		rampTypes = list2.ToArray();
		return result;
	}

	public static int GetRoadTypeByID(List<QDQDOOQQDQODD> roadTypes, double id)
	{
		for (int i = 0; i < roadTypes.Count; i++)
		{
			if (roadTypes[i].id == id)
			{
				return i + 1;
			}
		}
		UnityEngine.Debug.LogWarning("EasyRoads3Dv3: The with this connection associated road type is not available in this road network");
		return 0;
	}

	public static bool OOQDCODDCO(List<QDQDOOQQDQODD> roadTypes, double id, ref QDQDOOQQDQODD motorwayLink)
	{
		QDQDOOQQDQODD roadTypeElByID = GetRoadTypeElByID(roadTypes, id);
		return false;
	}

	public static string[] ODODCOQODO(List<QDQDOOQQDQODD> roadTypes)
	{
		List<string> list = new List<string>();
		if (roadTypes.Count > 0)
		{
			int num = 1;
			for (int i = 0; i < roadTypes.Count; i++)
			{
				if (roadTypes[i].type == ERRoadWayType.MotorwayRamp)
				{
					list.Add(num + ". " + roadTypes[i].roadTypeName);
					num++;
				}
			}
		}
		else
		{
			list.Add("No Ramp Types Available");
		}
		return list.ToArray();
	}

	public static bool GetTerrainDeformationByID(List<QDQDOOQQDQODD> roadTypes, double id, ref int element)
	{
		for (int i = 0; i < roadTypes.Count; i++)
		{
			if (roadTypes[i].id == id)
			{
				element = i;
				return roadTypes[i].terrainDeformation;
			}
		}
		return true;
	}

	public static void UpdateUVTiling(List<QDQDOOQQDQODD> roadTypes, double id, float tiling)
	{
		for (int i = 0; i < roadTypes.Count; i++)
		{
			if (roadTypes[i].id == id)
			{
				roadTypes[i].uvTiling = tiling;
				roadTypes[i].UpdateTimestamp();
				break;
			}
		}
	}

	public static void UpdateResolution(List<QDQDOOQQDQODD> roadTypes, double id, ref float resolution, ref float threshold)
	{
		for (int i = 0; i < roadTypes.Count; i++)
		{
			if (roadTypes[i].id == id)
			{
				resolution = roadTypes[i].faceDistance;
				threshold = roadTypes[i].angleTreshold;
				break;
			}
		}
	}

	public void OCDOCDQQQO(QDQDOOQQDQODD sourcePreset, List<SideObject> sceneSideObjects, List<SideObjectLog> projectSideObjects, bool copyShapeData)
	{
		roadTypeName = sourcePreset.roadTypeName;
		id = sourcePreset.id;
		type = sourcePreset.type;
		if (copyShapeData)
		{
			roadShapeData = sourcePreset.roadShapeData;
		}
		roadShapeDataActive = sourcePreset.roadShapeDataActive;
		timestamp = sourcePreset.timestamp;
		roadWidth = sourcePreset.roadWidth;
		faceDistance = sourcePreset.faceDistance;
		angleTreshold = sourcePreset.angleTreshold;
		uvTiling = sourcePreset.uvTiling;
		planarUVs = sourcePreset.planarUVs;
		outerIndent = sourcePreset.outerIndent;
		roadShape = new List<Vector2>(sourcePreset.roadShape);
		roadShapeExt = new List<Vector2>(sourcePreset.roadShapeExt);
		roadShapeExt2 = new List<Vector2>(sourcePreset.roadShapeExt2);
		doConnectionTri = new List<bool>(sourcePreset.doConnectionTri);
		roadShapeUVs = new List<float>(sourcePreset.roadShapeUVs);
		roadShapeUVs2 = new List<float>(sourcePreset.roadShapeUVs2);
		roadShapeExtUVs = new List<float>(sourcePreset.roadShapeExtUVs);
		roadShapeExtUVs2 = new List<float>(sourcePreset.roadShapeExtUVs2);
		hardEdge = new List<bool>(sourcePreset.hardEdge);
		roadShapeVecsString = sourcePreset.roadShapeVecsString;
		sidewalks = sourcePreset.sidewalks;
		sidewalkHeight = sourcePreset.sidewalkHeight;
		sidewalkWidth = sourcePreset.sidewalkWidth;
		subSegments = sourcePreset.subSegments;
		roadMaterial = sourcePreset.roadMaterial;
		if (sourcePreset.roadMaterials != null)
		{
			roadMaterials = new Material[sourcePreset.roadMaterials.Length];
			Array.Copy(sourcePreset.roadMaterials, roadMaterials, sourcePreset.roadMaterials.Length);
		}
		roadPhysicsMaterial = sourcePreset.roadPhysicsMaterial;
		if (sourcePreset.roadPhysicsMaterials != null)
		{
			roadPhysicsMaterials = new PhysicMaterial[sourcePreset.roadPhysicsMaterials.Length];
			Array.Copy(sourcePreset.roadPhysicsMaterials, roadPhysicsMaterials, sourcePreset.roadPhysicsMaterials.Length);
		}
		connectionMaterial = sourcePreset.connectionMaterial;
		isSideObject = sourcePreset.isSideObject;
		layer = sourcePreset.layer;
		if (!string.IsNullOrEmpty(sourcePreset.tag))
		{
			tag = sourcePreset.tag;
		}
		castShadow = sourcePreset.castShadow;
		splatMapActive = sourcePreset.splatMapActive;
		splatIndex = sourcePreset.splatIndex;
		expandLevel = sourcePreset.expandLevel;
		smoothLevel = sourcePreset.smoothLevel;
		splatOpacity = sourcePreset.splatOpacity;
		terrainDeformation = sourcePreset.terrainDeformation;
		defaultIndent = sourcePreset.defaultIndent;
		defaultSurrounding = sourcePreset.defaultSurrounding;
		followTerrainContours = sourcePreset.followTerrainContours;
		terrainContoursOffset = sourcePreset.terrainContoursOffset;
		randomYPosition = sourcePreset.randomYPosition;
		randomMinYPosition = sourcePreset.randomMinYPosition;
		randomMaxYPosition = sourcePreset.randomMaxYPosition;
		minRandomYPositionDistance = sourcePreset.minRandomYPositionDistance;
		maxRandomYPositionDistance = sourcePreset.maxRandomYPositionDistance;
		randomMinRotation = sourcePreset.randomMinRotation;
		randomMaxRotation = sourcePreset.randomMaxRotation;
		minRandomRotationDistance = sourcePreset.minRandomRotationDistance;
		maxRandomRotationDistance = sourcePreset.maxRandomRotationDistance;
		vegetationStudioMaskLineActive = sourcePreset.vegetationStudioMaskLineActive;
		vegetationStudioGrassPerimeter = sourcePreset.vegetationStudioGrassPerimeter;
		vegetationStudioPlantPerimeter = sourcePreset.vegetationStudioPlantPerimeter;
		vegetationStudioTreePerimeter = sourcePreset.vegetationStudioTreePerimeter;
		vegetationStudioObjectPerimeter = sourcePreset.vegetationStudioObjectPerimeter;
		vegetationStudioLargeObjectPerimeter = sourcePreset.vegetationStudioLargeObjectPerimeter;
		vegetationStudioBiomeMaskActive = sourcePreset.vegetationStudioBiomeMaskActive;
		vegetationStudioBiomeMaskDistance = sourcePreset.vegetationStudioBiomeMaskDistance;
		vegetationStudioBiomeMaskBlendDistance = sourcePreset.vegetationStudioBiomeMaskBlendDistance;
		vegetationStudioBiomeMaskNoiseScale = sourcePreset.vegetationStudioBiomeMaskNoiseScale;
		defaultRamp = sourcePreset.defaultRamp;
		extrusionType = sourcePreset.extrusionType;
		extrusionDistance = sourcePreset.extrusionDistance;
		fixedDistance = sourcePreset.fixedDistance;
		connectionAngle = sourcePreset.connectionAngle;
		connectionRadius = sourcePreset.connectionRadius;
		isRoadShape = sourcePreset.isRoadShape;
		for (int i = 0; i < sourcePreset.decalClassPresets.Count; i++)
		{
			bool flag = false;
			for (int j = 0; j < decalPresets.Count; j++)
			{
				if (decalPresets[j] != null && sourcePreset.decalClassPresets[i] != null && decalPresets[j].id == sourcePreset.decalClassPresets[i].id)
				{
					ERDecal.CopyDecal(sourcePreset.decalClassPresets[i], decalPresets[j]);
					flag = true;
					break;
				}
			}
			if (!flag && sourcePreset.decalClassPresets[i] != null)
			{
				ERDecal eRDecal = ERDecal.CreateInstance(sourcePreset.decalClassPresets[i].decalPrefab, sourcePreset.decalClassPresets[i].baseWidth);
				ERDecal.CopyDecal(sourcePreset.decalClassPresets[i], eRDecal);
				decalPresets.Add(eRDecal);
			}
		}
		for (int k = 0; k < decalPresets.Count; k++)
		{
			bool flag2 = false;
			for (int l = 0; l < sourcePreset.decalClassPresets.Count; l++)
			{
				if (decalPresets[k] != null && sourcePreset.decalClassPresets[l] != null && decalPresets[k].id == sourcePreset.decalClassPresets[l].id)
				{
					flag2 = true;
					break;
				}
			}
			if (!flag2)
			{
				decalPresets.RemoveAt(k);
				k--;
			}
		}
		soDataExt.Clear();
		for (int m = 0; m < sceneSideObjects.Count; m++)
		{
			soDataExt.Add(ERSORoadExt.CreateInstance(sceneSideObjects[m]));
		}
		for (int n = 0; n < sourcePreset.soDataLog.Count; n++)
		{
			if (!sourcePreset.soDataLog[n].active)
			{
				continue;
			}
			for (int num = 0; num < soDataExt.Count; num++)
			{
				if (sourcePreset.soDataLog[n].id == soDataExt[num].sideObject.id)
				{
					soDataExt[num].active = true;
					break;
				}
			}
		}
	}

	public static void OOOCDCQQCO(QDQDOOQQDQODD sourcePreset, ERModularRoad road, bool update, int customShapeHandling, bool checkRoadWidth)
	{
		road.subSegments = sourcePreset.subSegments;
		List<Vector2> list = new List<Vector2>(road.roadShape);
		list.Reverse();
		if ((sourcePreset.roadWidth != road.roadWidth || !ODQDQDQDQO.Vector2ListComparer(list, sourcePreset.roadShape)) && !sourcePreset.isCustomRoad && checkRoadWidth)
		{
			float num = road.roadWidth;
			List<Vector2> list2 = new List<Vector2>(road.roadShape);
			road.roadWidth = sourcePreset.roadWidth;
			ODCCODOCQQ.GetRoadShape(road.roadWidth, road.subSegments, ref road.roadShape, ref road.roadShapeUVs, ref road.roadShapeUVs2, -1f);
			road.roadShapeMatchCount = road.subSegments + 1;
			int num2 = 1;
			for (int i = 1; i < road.roadShape.Count; i++)
			{
				if ((double)Vector2.Distance(road.roadShape[i - 1], road.roadShape[i]) > 0.01)
				{
					num2++;
				}
			}
			road.roadShapeMatchCount = num2;
			bool flag = false;
			float num3 = road.roadWidth / num;
			for (int j = 0; j < road.markersExt.Count; j++)
			{
				if (!ODQDQDQDQO.Vector2ListComparer(list2, road.markersExt[j].roadShape))
				{
					switch (customShapeHandling)
					{
					case 1:
						road.markersExt[j].roadShape.Clear();
						road.markersExt[j].roadShape = new List<Vector2>(road.roadShape);
						break;
					case 2:
					{
						for (int k = 0; k < road.markersExt[j].roadShape.Count; k++)
						{
							Vector2 value = road.markersExt[j].roadShape[k];
							value.x *= num3;
							road.markersExt[j].roadShape[k] = value;
						}
						break;
					}
					}
				}
				else
				{
					road.markersExt[j].roadShape.Clear();
					road.markersExt[j].roadShape = new List<Vector2>(road.roadShape);
				}
			}
		}
		else if (road.roadShapeMatchCount == 0)
		{
			int num4 = 1;
			for (int l = 1; l < road.roadShape.Count; l++)
			{
				if ((double)Vector2.Distance(road.roadShape[l - 1], road.roadShape[l]) > 0.01)
				{
					num4++;
				}
			}
			road.roadShapeMatchCount = num4;
		}
		if (!road.resolutionFlag)
		{
			road.faceDistance = sourcePreset.faceDistance;
		}
		if (!road.angleThresholdFlag)
		{
			road.angleTreshold = sourcePreset.angleTreshold;
		}
		road.uvTiling = sourcePreset.uvTiling;
		road.planarUVs = sourcePreset.planarUVs;
		road.roadMaterial = sourcePreset.roadMaterial;
		if (sourcePreset.roadMaterials != null)
		{
			road.roadMaterials = new Material[sourcePreset.roadMaterials.Length];
			Array.Copy(sourcePreset.roadMaterials, road.roadMaterials, sourcePreset.roadMaterials.Length);
		}
		road.roadPhysicsMaterial = sourcePreset.roadPhysicsMaterial;
		if (sourcePreset.roadPhysicsMaterials != null)
		{
			road.roadPhysicsMaterials = new PhysicMaterial[sourcePreset.roadPhysicsMaterials.Length];
			Array.Copy(sourcePreset.roadPhysicsMaterials, road.roadPhysicsMaterials, sourcePreset.roadPhysicsMaterials.Length);
		}
		if (sourcePreset.isSideObject && !road.isSideObject)
		{
			if ((bool)road.gameObject.GetComponent<MeshFilter>())
			{
				UnityEngine.Object.DestroyImmediate(road.gameObject.GetComponent<MeshFilter>());
			}
			if ((bool)road.gameObject.GetComponent<MeshRenderer>())
			{
				UnityEngine.Object.DestroyImmediate(road.gameObject.GetComponent<MeshRenderer>());
			}
			if ((bool)road.gameObject.GetComponent<MeshCollider>())
			{
				UnityEngine.Object.DestroyImmediate(road.gameObject.GetComponent<MeshCollider>());
			}
		}
		road.isSideObject = sourcePreset.isSideObject;
		int num5 = (road.gameObject.layer = sourcePreset.layer);
		road.layer = num5;
		if (!string.IsNullOrEmpty(sourcePreset.tag))
		{
			string text = (road.gameObject.tag = sourcePreset.tag);
			road.tag = text;
		}
		road.castShadow = sourcePreset.castShadow;
		road.splatMapActive = sourcePreset.splatMapActive;
		road.splatIndex = sourcePreset.splatIndex;
		road.expandLevel = sourcePreset.expandLevel;
		road.smoothLevel = sourcePreset.smoothLevel;
		road.splatOpacity = sourcePreset.splatOpacity;
		road.terrainDeformation = sourcePreset.terrainDeformation;
		bool flag2 = false;
		if (road.followTerrainContours != sourcePreset.followTerrainContours)
		{
			flag2 = true;
		}
		road.followTerrainContours = sourcePreset.followTerrainContours;
		road.terrainContoursOffset = sourcePreset.terrainContoursOffset;
		if (road.indent != sourcePreset.defaultIndent || road.surrounding != sourcePreset.defaultSurrounding)
		{
			for (int m = 0; m < road.markersExt.Count; m++)
			{
				if (road.indent != sourcePreset.defaultIndent && road.baseScript != null)
				{
					if (road.baseScript.terrainMinIndent <= sourcePreset.defaultIndent)
					{
						if (road.indent == road.markersExt[m].leftIndent)
						{
							road.markersExt[m].leftIndent = sourcePreset.defaultIndent;
						}
						if (road.indent == road.markersExt[m].rightIndent)
						{
							road.markersExt[m].rightIndent = sourcePreset.defaultIndent;
						}
					}
					else
					{
						if (road.indent == road.markersExt[m].leftIndent)
						{
							road.markersExt[m].leftIndent = road.baseScript.terrainMinIndent;
						}
						if (road.indent == road.markersExt[m].rightIndent)
						{
							road.markersExt[m].rightIndent = road.baseScript.terrainMinIndent;
						}
					}
				}
				if (road.surrounding != sourcePreset.defaultSurrounding)
				{
					if (road.surrounding == road.markersExt[m].leftSurrounding)
					{
						road.markersExt[m].leftSurrounding = sourcePreset.defaultSurrounding;
					}
					if (road.surrounding == road.markersExt[m].rightSurrounding)
					{
						road.markersExt[m].rightSurrounding = sourcePreset.defaultSurrounding;
					}
				}
			}
		}
		if (road.baseScript != null)
		{
			if (road.baseScript.terrainMinIndent <= sourcePreset.defaultIndent)
			{
				road.indent = sourcePreset.defaultIndent;
			}
			else
			{
				road.indent = road.baseScript.terrainMinIndent;
			}
		}
		else
		{
			road.indent = sourcePreset.defaultIndent;
		}
		road.surrounding = sourcePreset.defaultSurrounding;
		road.randomYPosition = sourcePreset.randomYPosition;
		road.randomMinYPosition = sourcePreset.randomMinYPosition;
		road.randomMaxYPosition = sourcePreset.randomMaxYPosition;
		road.minRandomYPositionDistance = sourcePreset.minRandomYPositionDistance;
		road.maxRandomYPositionDistance = sourcePreset.maxRandomYPositionDistance;
		road.randomMinRotation = sourcePreset.randomMinRotation;
		road.randomMaxRotation = sourcePreset.randomMaxRotation;
		road.minRandomRotationDistance = sourcePreset.minRandomRotationDistance;
		road.maxRandomRotationDistance = sourcePreset.maxRandomRotationDistance;
		for (int n = 0; n < road.markersExt.Count; n++)
		{
			road.markersExt[n].randomYPosition = sourcePreset.randomYPosition;
			road.markersExt[n].randomMinYPosition = sourcePreset.randomMinYPosition;
			road.markersExt[n].randomMaxYPosition = sourcePreset.randomMaxYPosition;
			road.markersExt[n].minRandomYPositionDistance = sourcePreset.minRandomYPositionDistance;
			road.markersExt[n].maxRandomYPositionDistance = sourcePreset.maxRandomYPositionDistance;
			road.markersExt[n].randomMinRotation = sourcePreset.randomMinRotation;
			road.markersExt[n].randomMaxRotation = sourcePreset.randomMaxRotation;
			road.markersExt[n].minRandomRotationDistance = sourcePreset.minRandomRotationDistance;
			road.markersExt[n].maxRandomRotationDistance = sourcePreset.maxRandomRotationDistance;
			if (flag2)
			{
				road.markersExt[n].followTerrainContours = road.followTerrainContours;
			}
		}
		road.vegetationStudioMaskLineActive = sourcePreset.vegetationStudioMaskLineActive;
		road.vegetationStudioGrassPerimeter = sourcePreset.vegetationStudioGrassPerimeter;
		road.vegetationStudioPlantPerimeter = sourcePreset.vegetationStudioPlantPerimeter;
		road.vegetationStudioTreePerimeter = sourcePreset.vegetationStudioTreePerimeter;
		road.vegetationStudioObjectPerimeter = sourcePreset.vegetationStudioObjectPerimeter;
		road.vegetationStudioLargeObjectPerimeter = sourcePreset.vegetationStudioLargeObjectPerimeter;
		road.vegetationStudioBiomeMaskActive = sourcePreset.vegetationStudioBiomeMaskActive;
		road.vegetationStudioBiomeMaskDistance = sourcePreset.vegetationStudioBiomeMaskDistance;
		road.vegetationStudioBiomeMaskBlendDistance = sourcePreset.vegetationStudioBiomeMaskBlendDistance;
		road.vegetationStudioBiomeMaskNoiseScale = sourcePreset.vegetationStudioBiomeMaskNoiseScale;
		road.OQDQOOQODD(road.vegetationStudioMaskLineActive, road.vegetationStudioBiomeMaskActive);
		if (road.baseScript != null && (road.baseScript.vegetationStudio || road.baseScript.vegetationStudioPro))
		{
			if (road.vegetationStudioMaskLineActive)
			{
				float num7 = sourcePreset.roadWidth;
				object[] parameters = new object[6]
				{
					road.gameObject,
					2f * road.vegetationStudioGrassPerimeter,
					2f * road.vegetationStudioPlantPerimeter,
					2f * road.vegetationStudioTreePerimeter,
					2f * road.vegetationStudioObjectPerimeter,
					2f * road.vegetationStudioLargeObjectPerimeter
				};
				road.baseScript.crMethod.Invoke(null, parameters);
			}
			if (road.vegetationStudioBiomeMaskActive)
			{
				float num8 = sourcePreset.roadWidth;
				object[] parameters2 = new object[4] { road.gameObject, road.vegetationStudioBiomeMaskDistance, road.vegetationStudioBiomeMaskBlendDistance, road.vegetationStudioBiomeMaskNoiseScale };
				road.baseScript.crBiomeMethod.Invoke(null, parameters2);
			}
		}
		bool flag3 = false;
		bool flag4 = false;
		foreach (ERDecal decalPreset in sourcePreset.decalPresets)
		{
			if (decalPreset.id == road.startDecalID)
			{
				flag3 = true;
			}
			if (decalPreset.id == road.endDecalID)
			{
				flag4 = true;
			}
			if (flag3 && flag4)
			{
				break;
			}
		}
		if (!flag3)
		{
			road.startDecalID = -1;
			if (road.startDecalPrefab != null)
			{
				if (Application.isEditor && !Application.isPlaying)
				{
					UnityEngine.Object.DestroyImmediate(road.startDecalPrefab);
				}
				else
				{
					UnityEngine.Object.Destroy(road.startDecalPrefab);
				}
			}
		}
		if (!flag4)
		{
			road.endDecalID = -1;
			if (road.endDecalPrefab != null)
			{
				if (Application.isEditor && !Application.isPlaying)
				{
					UnityEngine.Object.DestroyImmediate(road.endDecalPrefab);
				}
				else
				{
					UnityEngine.Object.Destroy(road.endDecalPrefab);
				}
			}
		}
		if (sourcePreset.decalPresets.Count == 0)
		{
			road.startDecalID = -1;
			road.startDecal = null;
			road.startDecalPrefabSource = null;
			road.endDecalID = -1;
			road.endDecal = null;
			road.endDecalPrefabSource = null;
		}
		else
		{
			if (road.startDecalID == -1)
			{
				int minInclusive = 0;
				int count = sourcePreset.decalPresets.Count;
				int index = UnityEngine.Random.Range(minInclusive, count);
				road.startDecalID = sourcePreset.decalPresets[index].id;
				road.startDecal = sourcePreset.decalPresets[index];
			}
			if (road.endDecalID == -1)
			{
				int minInclusive2 = 0;
				int count2 = sourcePreset.decalPresets.Count;
				int index2 = UnityEngine.Random.Range(minInclusive2, count2);
				road.endDecalID = sourcePreset.decalPresets[index2].id;
				road.endDecal = sourcePreset.decalPresets[index2];
			}
		}
		if (!update)
		{
			return;
		}
		road.OCQOQCDCQC(ignorePrefabAlignment: false, forceAutoRotate: false);
		int num9 = -1;
		for (int num10 = 0; num10 < road.baseScript.roadTypes.Count; num10++)
		{
			if (road.baseScript.roadTypes[num10] == sourcePreset)
			{
				num9 = num10 + 1;
				break;
			}
		}
		if (num9 != -1)
		{
			AssignSideObjects(road.baseScript, num9, road);
		}
	}

	public static void AssignSideObjects(ERModularBase scr, int roadTypeInt, ERModularRoad OCCQOOOQQO)
	{
		for (int i = 0; i < scr.roadTypes[roadTypeInt - 1].soDataExt.Count; i++)
		{
			if (!(scr.roadTypes[roadTypeInt - 1].soDataExt[i] != null))
			{
				continue;
			}
			bool flag = true;
			foreach (ERSORoadExt item in OCCQOOOQQO.soDataExt)
			{
				if (!(item.sideObject == scr.roadTypes[roadTypeInt - 1].soDataExt[i].sideObject))
				{
					continue;
				}
				flag = false;
				if (scr.roadTypes[roadTypeInt - 1].soDataExt[i].active && !item.active)
				{
					item.active = true;
					if (scr.roadTypes[roadTypeInt - 1].soDataExt[i].markerActive)
					{
						ODDQODOOOC.ODOOCCCOQD(OCCQOOOQQO, scr.roadTypes[roadTypeInt - 1].soDataExt[i].sideObject, scr.roadTypes[roadTypeInt - 1].soDataExt[i].markerActive);
					}
				}
				else if (item.active)
				{
					OCCQOOOQQO.sosCleared = false;
				}
				if (!scr.roadTypes[roadTypeInt - 1].soDataExt[i].active)
				{
					break;
				}
				ERSORoadExt.Copy(scr.roadTypes[roadTypeInt - 1].soDataExt[i], item);
				OOQQQDOCDD.OOQQCOQDQC(item, scr.roadTypes[roadTypeInt - 1].soDataExt[i]);
				if (!item.active || scr.roadTypes[roadTypeInt - 1].soDataExt[i].xPosition == scr.roadTypes[roadTypeInt - 1].soDataExt[i].oldXPosition)
				{
					break;
				}
				int num = -1;
				for (int j = 0; j < OCCQOOOQQO.markersExt.Count; j++)
				{
					if (num == -1)
					{
						for (int k = 0; k < OCCQOOOQQO.markersExt.Count; k++)
						{
							if (OCCQOOOQQO.markersExt.Count > 0 && OCCQOOOQQO.markersExt[0].soData.Count > k && OCCQOOOQQO.markersExt[0].soData[k].id == item.id)
							{
								num = k;
								break;
							}
						}
					}
					if (num >= 0)
					{
						OCCQOOOQQO.markersExt[j].soData[num].xPosition = item.xPosition;
						if (OCCQOOOQQO.markersExt[j].soData[num].otherSide != null)
						{
							OCCQOOOQQO.markersExt[j].soData[num].otherSide.xPosition = 0f - item.xPosition;
						}
					}
				}
				break;
			}
			if (!flag)
			{
				continue;
			}
			OCCQOOOQQO.soDataExt.Add(ERSORoadExt.CreateInstance(scr.roadTypes[roadTypeInt - 1].soDataExt[i].sideObject));
			if (scr.roadTypes[roadTypeInt - 1].soDataExt[i].active)
			{
				OCCQOOOQQO.soDataExt[OCCQOOOQQO.soDataExt.Count - 1].active = true;
				OCCQOOOQQO.soDataExt[OCCQOOOQQO.soDataExt.Count - 1].autoGenerate = scr.roadTypes[roadTypeInt - 1].soDataExt[i].autoGenerate;
				if (scr.roadTypes[roadTypeInt - 1].soDataExt[i].sideObject.markerActive && scr.QOQDQOOQDDQOOQ.Count > 0)
				{
					ODDQODOOOC.ODOOCCCOQD(OCCQOOOQQO, scr.roadTypes[roadTypeInt - 1].soDataExt[i].sideObject, scr.roadTypes[roadTypeInt - 1].soDataExt[i].markerActive);
				}
			}
			OOQQQDOCDD.OOQQCOQDQC(OCCQOOOQQO.soDataExt[OCCQOOOQQO.soDataExt.Count - 1], scr.roadTypes[roadTypeInt - 1].soDataExt[i]);
		}
		OCCQOOOQQO.sideObjectNames = ODDQODOOOC.OODDQDQDOQ(OCCQOOOQQO);
	}

	public static void HasActiveSideObjects(List<ERSORoadExt> sos1, List<ERSORoadExt> sos2, ref bool flag1, ref bool flag2)
	{
		bool flag3 = false;
		if (sos1 != null)
		{
			foreach (ERSORoadExt item in sos1)
			{
				if (item != null && item.active)
				{
					foreach (ERSORoadExt item2 in sos2)
					{
						if (item.id == item2.id && item2.active)
						{
							flag1 = true;
						}
					}
				}
				else
				{
					foreach (ERSORoadExt item3 in sos2)
					{
						if (item != null && item3 != null && item.id == item3.id && item3.active)
						{
							flag2 = true;
						}
					}
				}
			}
			return;
		}
		foreach (ERSORoadExt item4 in sos2)
		{
			if (item4 != null && item4.active)
			{
				flag2 = true;
			}
		}
	}

	public int OOOOCQCDDC(int index, ERLaneDirection direction)
	{
		if (roadShapeData.isset)
		{
			int num = roadShapeData.lanes.Count - 1;
			if (direction == ERLaneDirection.Right)
			{
				if (roadShapeData.lanes[num].laneIndex > 0)
				{
					ODQQQODOQD();
				}
				for (int num2 = num; num2 >= 0; num2--)
				{
					if (roadShapeData.lanes[num2].laneIndex == index)
					{
						return num2;
					}
				}
			}
			else
			{
				for (int i = 0; i <= num; i++)
				{
					if (roadShapeData.lanes[i].laneIndex == index)
					{
						return i;
					}
				}
			}
		}
		return 0;
	}

	public static bool ODCDDDQCQQ(QDQDOOQQDQODD rt1, QDQDOOQQDQODD rt2)
	{
		if (rt1.roadShapeData.leftLanes != rt1.roadShapeData.leftLanes)
		{
			return false;
		}
		if (rt1.roadShapeData.rightLanes != rt1.roadShapeData.rightLanes)
		{
			return false;
		}
		return true;
	}
}
[Serializable]
public enum ERRoadWayType
{
	Primary = 1,
	Secondary,
	Tertiary,
	Path,
	MotorwayRamp
}
[Serializable]
public enum ERFlexConnectionType
{
	Priority,
	SameType
}
[Serializable]
public class ERSideWalk
{
	public string name = "";

	public double id;

	public double timestamp;

	public float sidewalkWidth = 1.5f;

	public float curbHeight = 0.25f;

	public float curbDepth = 0.25f;

	public bool beveledCurb = false;

	public float beveledHeight = 0f;

	public float beveledDepth = 0f;

	public bool outerCurb = false;

	public bool roadSideCurbUVControl = false;

	public bool outerSideCurbUVControl = false;

	public Material material;

	public bool hardEdges = false;

	public List<Vector2> shape = new List<Vector2>();

	public List<float> sidewalkUVs = new List<float>();

	public List<float> curbUVs = new List<float>();

	public List<bool> doConnectionTri = new List<bool>();

	public Rect tileRect = default(Rect);

	public float tileSize = 1f;

	public float tiling = 1f;

	public float uvRatio = 1f;

	public float minEnd = 1f;

	public float maxEnd = 1f;

	public bool lockUVs = false;

	public float cornerRadius = 1f;

	public int cornerSegments = 5;

	public float innerSegmentDistance = 0.5f;

	public static ERSideWalk CreateInstance(int count)
	{
		ERSideWalk eRSideWalk = new ERSideWalk();
		eRSideWalk.name = "Sidewalk " + count;
		eRSideWalk.timestamp = DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
		eRSideWalk.id = eRSideWalk.timestamp;
		return eRSideWalk;
	}

	public void UpdateTimestamp()
	{
		timestamp = DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
	}

	public static string[] SidewalkNames(List<ERSideWalk> sidewalks)
	{
		List<string> list = new List<string>();
		if (sidewalks.Count > 0)
		{
			list.Add("Select Sidewalk");
			int num = 1;
			for (int i = 0; i < sidewalks.Count; i++)
			{
				list.Add(num + ".  " + sidewalks[i].name);
				num++;
			}
		}
		else
		{
			list.Add("No Sidewalks Available");
		}
		return list.ToArray();
	}

	public static void CopySidewalk(ERSideWalk source, ERSideWalk target)
	{
		target.name = source.name;
		target.id = source.id;
		target.timestamp = source.timestamp;
		target.sidewalkWidth = source.sidewalkWidth;
		target.curbHeight = source.curbHeight;
		target.curbDepth = source.curbDepth;
		target.beveledCurb = source.beveledCurb;
		target.beveledHeight = source.beveledHeight;
		target.beveledDepth = source.beveledDepth;
		target.outerCurb = source.outerCurb;
		target.roadSideCurbUVControl = source.roadSideCurbUVControl;
		target.outerSideCurbUVControl = source.outerSideCurbUVControl;
		target.material = source.material;
		target.hardEdges = source.hardEdges;
		target.shape = new List<Vector2>(source.shape);
		target.sidewalkUVs = new List<float>(source.sidewalkUVs);
		target.curbUVs = new List<float>(source.curbUVs);
		target.doConnectionTri = new List<bool>(source.doConnectionTri);
		target.tileRect = source.tileRect;
		target.tileSize = source.tileSize;
		target.tiling = source.tiling;
		target.minEnd = source.minEnd;
		target.maxEnd = source.maxEnd;
		target.lockUVs = source.lockUVs;
	}

	public static void RefreshSidewalks(List<ERSideWalk> sidewalks)
	{
		ERSideWalkInstanceScript[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERSideWalkInstanceScript)) as ERSideWalkInstanceScript[];
		ERSideWalkInstanceScript[] array2 = array;
		foreach (ERSideWalkInstanceScript eRSideWalkInstanceScript in array2)
		{
			if (eRSideWalkInstanceScript.instance == null)
			{
				continue;
			}
			foreach (ERSideWalk sidewalk in sidewalks)
			{
				if (eRSideWalkInstanceScript.instance.id == sidewalk.id)
				{
					if (eRSideWalkInstanceScript.instance.sidewalk != sidewalk)
					{
						eRSideWalkInstanceScript.instance.sidewalk = sidewalk;
					}
					break;
				}
			}
		}
	}

	public void OOQQDCCDQO()
	{
		float num = Mathf.Abs(sidewalkUVs[sidewalkUVs.Count - 1] - sidewalkUVs[0]);
		float num2 = 0f;
		for (int i = 0; i < shape.Count - 1; i++)
		{
			num2 += Vector2.Distance(shape[i], shape[i + 1]);
		}
		uvRatio = num2 / num;
	}
}
[Serializable]
public class ERLaneData
{
	public Vector3[] points;

	public List<ERLaneConnector> connectors = new List<ERLaneConnector>();

	public ERLane laneType;

	public int laneIndex = 0;

	public ERLaneDirection direction;

	public static ERLaneData CreateInstance()
	{
		return new ERLaneData();
	}

	public static ERLaneData OOOOCQCDDC(List<ERLaneData> laneData, int index)
	{
		for (int i = 0; i < laneData.Count; i++)
		{
			if (laneData[i].laneIndex == index)
			{
				return laneData[i];
			}
		}
		return null;
	}

	public bool Exists(int index, int lane)
	{
		for (int i = 0; i < connectors.Count; i++)
		{
			if (connectors[i].endConnectionIndex == index && connectors[i].endLaneIndex == lane)
			{
				return true;
			}
		}
		return false;
	}
}
[AddComponentMenu("")]
public class ERModularBase : MonoBehaviour
{
	public delegate void RoadUpdate(ERRoad road);

	public delegate void OnBuildMode();

	public int updateInt = 11;

	public bool newSplatMapRestoreCode = false;

	public int toolbarInt = 0;

	public int oldToolbarInt = 0;

	public int roadToolbarInt = 0;

	public int markerToolbarInt = 0;

	public Texture[] menuTexs;

	public Texture[] subMenuTexs;

	public GameObject cprefab;

	public Texture nodeHandleTexture;

	public Texture lockedTexture;

	public Texture unLockedTexture;

	public Texture favOffTexture;

	public Texture favOffFreeTexture;

	public Texture favOnTexture;

	public Texture selRoadTexture;

	public Texture headerTexture;

	public Texture sceneGUITex;

	public Texture soIcon;

	public Transform roadObjectsParent;

	public Transform connectionObjectsParent;

	public GameObject OCOQDODDQQ;

	public List<QDQDOOQQDQODD> roadTypes = new List<QDQDOOQQDQODD>();

	public int selectedRoadType = 0;

	public int selectedNewRoadType = 0;

	public List<QDQDOOQQDQODD> inspRoadTypes = new List<QDQDOOQQDQODD>();

	public List<int> inspRoadTypeInts = new List<int>();

	public List<ERDecal> decalPresets = new List<ERDecal>();

	public float roadWidth = 5f;

	public Material roadMaterial;

	public Material crossingMaterial;

	public Material roundAboutMaterial;

	public Material roundAboutConnectionMaterial;

	public Material roundAboutRoadMaterial;

	public Material sidewalkMaterial;

	public Material targetMaterial;

	public Terrain sourceTerrain;

	public string[] roadMaterials;

	public string[] connectionMaterials;

	public int selectedMaterial = 0;

	public int selectedConnectionMaterial = 0;

	public List<ERMaterial> materials = new List<ERMaterial>();

	public int selectedRoadRoadType = 0;

	public bool roadOptions = true;

	public bool sidewalkOptions = false;

	public bool markerOptions = true;

	public bool showRoadSideObjects = false;

	public bool markerSOOptions = true;

	public bool roadTerrainOptions = true;

	public bool camFlyOver = true;

	public int selectedRoadMaterial = 0;

	public int roadTextureInfoIndex = 0;

	public Texture2D selectedRoadTexture;

	public float selectedRoadWidth = 0f;

	public float selectedRoadLeftOffset = 0f;

	public float selectedRoadRightOffset = 0f;

	public float selectedRoadLeftInnerOffset = 0f;

	public float selectedRoadRightInnerOffset = 0f;

	public int selectedCrossingMaterial = 0;

	public int crossingTextureInfoIndex = 0;

	public int handleSelection = 0;

	public int positionHandleSelection = 0;

	public bool markerDirXZ = false;

	public GameObject defaultCrossing;

	public GameObject defaultTCrossing;

	public GameObject defaultCulDeSac;

	public GameObject defaultRoundabout;

	public Texture2D tex;

	public Texture2D infoTexture = null;

	public bool showAllPrefabs = true;

	public bool standardPrefabsFlag;

	public bool sceneSettingsFoldOut;

	public bool sceneRoadsFoldOut;

	public bool scenePrefabsFoldOut;

	public bool sidewalksFoldOut;

	public bool terrainManagementFoldOut;

	public bool importRoadDataFoldOut;

	public bool lodGroupsFoldOut;

	public bool defaultMaterialsFoldOut;

	public bool aiTrafficFoldout;

	public bool kmlFlag = false;

	public bool osmFlag = false;

	public bool useOSMHeights = false;

	public float heightRatio = 1f;

	public bool dynamicPrefabsFoldOut = true;

	public bool customPrefabsFoldOut = true;

	public List<ERConnectionGUIStatus> dynamicFavList = new List<ERConnectionGUIStatus>();

	public List<ERConnectionGUIStatus> customFavList = new List<ERConnectionGUIStatus>();

	public float prefabsDisplayType = 0f;

	public bool ignoreTerrainAlerts = false;

	public double osmTerrainTopLon;

	public double osmTerrainBottomLon;

	public double osmTerrainLeftLat;

	public double osmTerrainRightLat;

	public float terrainMinIndent = 0.5f;

	public float minIndent = 0.5f;

	public float minSurrounding = 0.5f;

	public float maxIndentSurrounding = 50f;

	public float terrainY = 0f;

	public float terrainDetailSplatX = 0f;

	public float terrainDetailSplatY = 0f;

	public Vector3 detailOffsetVec;

	public float raise = 0.02f;

	public Vector3 baseVector = Vector3.zero;

	public bool mirrorCrossings = true;

	public string[] terrainNames;

	public Terrain[] terrainObjects;

	public string[] terrainSplatTextures;

	public Terrain activeTerrain;

	public float activeTerrainY;

	public int selectedTerrain = 0;

	public bool selectedRoadsOnly = false;

	public bool terrainDone;

	public bool enableBackWithoutRestore = false;

	public float detailDistance = 3f;

	public float treeDistance = 5f;

	public bool doHeightmap = true;

	public bool doTrees = true;

	public bool soTrees = true;

	public bool doDetail = true;

	public Rect terrainRect = default(Rect);

	public List<GameObject> tunnelObjects = new List<GameObject>();

	public List<GameObject> surfaceObjects = new List<GameObject>();

	public float preserveTerrainFloat = 1f;

	public float terrainSmoothIndentDistance = 1f;

	public float terrainSmoothSurroundingDistance = 1f;

	public int indentSmoothStep = 0;

	public int surroundingSmoothStep = 0;

	public bool doTangents = true;

	public bool doLightmapUVs = false;

	public bool doLODGroups = false;

	public bool doSplatmaps = false;

	public int sLayer = 31;

	public List<Vector3> terrainHits = new List<Vector3>();

	public List<Vector3> osmCrossingPoints = new List<Vector3>();

	public List<CrossingCornerClass> cornerPresets = new List<CrossingCornerClass>();

	public List<SidewalkPresetClass> sidewalkPresets = new List<SidewalkPresetClass>();

	public List<ERSideWalk> sidewalks = new List<ERSideWalk>();

	public int selectedSidewalk = 0;

	public int selectedRoadTypeSidewalk = 0;

	public int osmMotorway = 0;

	public int osmMotorwayLink = 0;

	public int osmTrunk = 0;

	public int osmPrimary = 0;

	public int osmSecondary = 0;

	public int osmTertiary = 0;

	public int osmUnclassified = 0;

	public int osmResidential = 0;

	public int osmService = 0;

	public int osmTrack = 0;

	public int osmPath = 0;

	public int osmWalkway = 0;

	public int osmRaceway = 0;

	public int osmHighwayStringInt = 0;

	public bool osmMotorwayFlag = true;

	public bool osmMotorwayLinkFlag = true;

	public bool osmTrunkFlag = true;

	public bool osmPrimaryFlag = true;

	public bool osmSecondaryFlag = true;

	public bool osmTertiaryFlag = true;

	public bool osmUnclassifiedFlag = true;

	public bool osmResidentialFlag = true;

	public bool osmServiceFlag = true;

	public bool osmTrackFlag = true;

	public bool osmPathFlag = true;

	public bool osmWalkwayFlag = false;

	public bool osmRacewayFlag = true;

	public string osmHighwayString = "";

	public int kmlRoadType = 0;

	public bool lodGroups = false;

	public int LODLevels = 4;

	public List<float> LODLevelValues = new List<float>();

	public List<float> LODLevelResolution = new List<float>();

	public bool embedRoadShape = false;

	public bool hideSurfaces = false;

	public bool showSurfaces = false;

	public bool useLightProbes = false;

	public bool hideLockedObjects = false;

	public bool ODQCODODDD = false;

	public bool isInBuildMode = false;

	public bool progressFlag = false;

	public int progressTerrain = 1;

	public float progressStatus = 1f;

	public float progressMax = 1f;

	[SerializeField]
	public List<SideObject> QOQDQOOQDDQOOQ = new List<SideObject>();

	public string[] sideObjectNames = new string[0];

	public int selSideObject = 0;

	public int selSubSideObject = 0;

	public string soID = "";

	public string sideObjectName = "";

	[SerializeField]
	public int sideObjectType = 0;

	public GameObject sideObjectSource;

	public GameObject soEndObject;

	public int sideObjectTerrainVegetationInt = 0;

	public int prefabChildHandling = 0;

	public float sideObjectDistance = 1f;

	public int soYAxisRotation = 0;

	public float soSidewaysDistance = 0f;

	public int soSidewaysDistanceHandling = 0;

	public float soDensity = 1f;

	public float soOffset = 0f;

	public int soTerrainAligment = 0;

	public bool soCombine = false;

	public bool soWeld = false;

	public int soControllerType = 0;

	public Material soMaterial;

	public float soXPosition = 0f;

	public float soYPosition = 0f;

	public bool soMarkerActive = true;

	public bool enableSOHandles = false;

	public bool enableShapeNodeHandles = false;

	public bool enableSOShapeNodeHandles = false;

	public bool displayCriticalPoints = true;

	public bool highlightRoad = true;

	public bool highlightIndents = true;

	public bool highlightSurroundings = true;

	public bool highlightSideObject = true;

	public Color highlightRoadColor = new Color(0.39f, 0.53f, 0.9f, 0.1f);

	public Color highlightIndentColor = new Color(1f, 1f, 1f, 0.1f);

	public Color highlightSurroundingColor = new Color(1f, 1f, 1f, 0.05f);

	public bool onlyShowSelectedRoad = false;

	public List<GameObject> soDeformationObjects = new List<GameObject>();

	public List<GameObject> soSplatmapObjects = new List<GameObject>();

	public bool buildSOinEditMode = true;

	public bool tangentsInEditMode = true;

	public bool calculateSmoothNormals = true;

	public bool importSideObjectsAlert = false;

	public bool importRoadPresetsAlert = false;

	public bool importCrossingPresetsAlert = false;

	public bool importSidewalkPresetsAlert = false;

	public bool updateSideObjectsAlert = false;

	public bool updateRoadPresetsAlert = false;

	public bool updateCrossingPresetsAlert = false;

	public bool updateSidewalkPresetsAlert = false;

	public float waypointDistance = 10f;

	public List<ERModularRoad> RoadObjectsSoUpdates = new List<ERModularRoad>();

	public string assetsFolderID = "";

	public GameObject meshSurface;

	public Collider meshTerrainCollider;

	public float markerScale = 1f;

	public float markerDistance = 400f;

	public float minMarkerDistance = 100f;

	public float maxMarkerDistance = 500f;

	public bool debugFlag = false;

	public List<Vector3> leftTHandles = new List<Vector3>();

	public List<Vector3> rightTHandles = new List<Vector3>();

	public float roadNetworkY = 0f;

	public bool ignoreMinIndents = false;

	public Vector3 zoomStart;

	public Vector3 zoomEnd;

	public Vector3 lookAtStart;

	public Vector3 lookAtEnd;

	public Quaternion zoomRot;

	public float zoomStartTime = 0f;

	public bool hideSurfaceHandles = false;

	public bool dirtyBool = false;

	public bool dirtyOnSceneBool = false;

	public bool forceRoadNetworkSelect = false;

	public bool ODQDQDQDCO = true;

	public ERCrossingPrefabs OCOQDODDQQScript = null;

	public ERCrossings OOOQDOQCCOCrossingsScript;

	public ERCrossingPrefabs OOOQDOQCCOScript;

	public int OCOQDODDQQElement = -1;

	public int OQCOQCOQQQ = -1;

	public ERModularRoad OCCQOOOQQO;

	public ERModularRoad OODDQOOCOD;

	public int OCODDDQOQC = -1;

	public int selectedRoadSOMarker = -1;

	public int selectedMarkerNode = -1;

	public List<int> selectedMarkerNodes = new List<int>();

	public int selectedMarkerSONode = -1;

	public List<int> selectedMarkerSONodes = new List<int>();

	public List<SelectedObject> selectedObjects = new List<SelectedObject>();

	public int selectedExitRoad = -1;

	public bool newRoadFlag = false;

	public bool roadTypeUpdateFlag = false;

	public List<ERModularRoad> roadScripts = new List<ERModularRoad>();

	public List<ERCrossingPrefabs> prefabScripts = new List<ERCrossingPrefabs>();

	public bool globalGridActive = false;

	public bool gridGUIActive = false;

	public Color globalGridColor = new Color(0.35f, 0.5f, 0.9f, 0.9f);

	public float globalGridSize = 50f;

	public float globalGridRadius = 1000f;

	public float globalGridRotation = 0f;

	public Vector2 gridOffset;

	public Vector3 ggTL;

	public Vector3 ggBL;

	public Vector3 ggBR;

	public bool localGridActive = false;

	public List<ERLocalGrid> localGrids = new List<ERLocalGrid>();

	public int selectedLocalGrid = 0;

	public MethodInfo crMethod;

	public MethodInfo upMethod;

	public MethodInfo hmMethod;

	public MethodInfo rmMethod;

	public MethodInfo crBiomeMethod;

	public MethodInfo upBiomeMethod;

	public MethodInfo rmBiomeMethod;

	public MethodInfo thMethodGet;

	public MethodInfo thMethodSet;

	public ERSideWalk sw;

	public bool roadUpdated = false;

	public bool clampUVs = true;

	public int soCategoryInt = 0;

	public int soRoadCategoryInt = 0;

	public float minRoadWidth = 1f;

	public float maxRoadWidth = 75f;

	public float maxCurbHeight = 0.5f;

	public float minCornerRadius = 0.5f;

	public float maxCornerRadius = 5f;

	public GameObject SoTestObject;

	public bool lockRoadNetwork = false;

	public bool showNotifications = true;

	public bool multipleTerrainsWarning = false;

	public Texture2D[] OCDCDDQDQC = new Texture2D[0];

	public Texture2D[] OCDCOCCCCC = new Texture2D[0];

	public int textureCounter = 0;

	public static bool AssembliesSet = false;

	public bool vegetationStudio = false;

	public bool vegetationStudioPro = false;

	public bool vegetationStudioActive = false;

	public bool vegetationStudioMaskLineActive = true;

	public float vegetationStudioGrassPerimeter = 2f;

	public float vegetationStudioPlantPerimeter = 3f;

	public float vegetationStudioTreePerimeter = 4f;

	public float vegetationStudioObjectPerimeter = 3f;

	public float vegetationStudioLargeObjectPerimeter = 4f;

	public bool vegetationStudioBiomeMaskActive = false;

	public float vegetationStudioBiomeMaskDistance = 0f;

	public float vegetationStudioBiomeMaskBlendDistance = 0f;

	public float vegetationStudioBiomeMaskNoiseScale = 0f;

	public bool aiTraffic = false;

	public bool aiMatchingLanesOnly = true;

	public bool aiconnectNonMatchinglaneCounts = true;

	public bool aiIgnoreConnections = true;

	public bool displayLaneData = false;

	public int rightHandDriving = 1;

	public Color leftLaneHandleColour = new Color(0.1f, 0.1f, 0.1f, 0.75f);

	public Color rightLaneHandleColour = new Color(1f, 1f, 1f, 0.75f);

	public Color laneHandleSelectedColour = new Color(1f, 1f, 0f, 0.5f);

	public float roadUvThreshold = 1750f;

	public int updateQueue = 0;

	public static bool checkPresets = false;

	public bool logChange = false;

	public bool debugMode = false;

	public bool RoadNetworkInitFlag = false;

	public static RoadUpdate onRoadUpdate;

	public static OnBuildMode onBuildModeEnter;

	public List<GameObject> excludeFromSelection = new List<GameObject>();

	public GameObject addExcludeFromSelection;

	public Color shapeUVColor = Color.black;

	public Color startCapColor = new Color(0.35f, 0.5f, 0.9f, 1f);

	public Color endCapColor = new Color(0.35f, 0.5f, 0.9f, 1f);

	public Material soSectionMaterial;

	public bool v32b4Flag = false;

	public void OnBuildModeEnter()
	{
		if (onBuildModeEnter != null)
		{
			onBuildModeEnter();
		}
	}

	public void OnRoadUpdate(ERRoad road)
	{
		if (onRoadUpdate != null)
		{
			onRoadUpdate(road);
		}
	}

	public void RoadNetworkInit()
	{
		importSideObjectsAlert = false;
		importRoadPresetsAlert = false;
		importCrossingPresetsAlert = false;
		importSidewalkPresetsAlert = false;
		rightHandDriving = 1;
		RoadNetworkInitFlag = true;
	}

	public void UpdateQueue()
	{
		int minInclusive = 1;
		int maxExclusive = 999999999;
		updateQueue = UnityEngine.Random.Range(minInclusive, maxExclusive);
	}

	public void SetRoadTypeList()
	{
		OODDQOOCOD = OCCQOOOQQO;
		roadTypeUpdateFlag = true;
		if (OCCQOOOQQO != null)
		{
			bool flag = true;
			if (OCCQOOOQQO.startPrefabScript != null && !OCCQOOOQQO.startPrefabScript.isFlexConnector && !OCCQOOOQQO.startPrefabScript.isIConnector)
			{
				flag = false;
			}
			bool flag2 = true;
			if (OCCQOOOQQO.endPrefabScript != null && !OCCQOOOQQO.endPrefabScript.isFlexConnector && !OCCQOOOQQO.endPrefabScript.isIConnector)
			{
				flag2 = false;
			}
			if (!flag || !flag2)
			{
				inspRoadTypes.Clear();
				inspRoadTypeInts.Clear();
				for (int i = 0; i < roadTypes.Count; i++)
				{
					if (ODCCODOCQQ.OCDQQQDDQO(roadTypes[i].roadShape) == OCCQOOOQQO.roadShapeMatchCount)
					{
						inspRoadTypes.Add(roadTypes[i]);
						inspRoadTypeInts.Add(i);
						if (roadTypes[i].id == OCCQOOOQQO.roadType)
						{
							selectedRoadRoadType = inspRoadTypes.Count;
						}
					}
				}
				if (OCCQOOOQQO.startPrefabScript != null && OCCQOOOQQO.startPrefabScript.crossingElements.Count > OCCQOOOQQO.startConnectionSegment && OCCQOOOQQO.startConnectionSegment >= 0 && OCCQOOOQQO.startPrefabScript.crossingElements[OCCQOOOQQO.startConnectionSegment].roadShapeMatchCount != 2 && !flag)
				{
					roadTypeUpdateFlag = false;
				}
				if (OCCQOOOQQO.endPrefabScript != null && OCCQOOOQQO.endPrefabScript.crossingElements.Count > OCCQOOOQQO.endConnectionSegment && OCCQOOOQQO.endConnectionSegment >= 0 && OCCQOOOQQO.endPrefabScript.crossingElements[OCCQOOOQQO.endConnectionSegment].roadShapeMatchCount != 2 && !flag2)
				{
					roadTypeUpdateFlag = false;
				}
			}
			else
			{
				inspRoadTypes = new List<QDQDOOQQDQODD>(roadTypes);
				inspRoadTypeInts.Clear();
				for (int j = 0; j < roadTypes.Count; j++)
				{
					inspRoadTypeInts.Add(j);
					if (roadTypes[j].id == OCCQOOOQQO.roadType)
					{
						selectedRoadRoadType = j + 1;
					}
				}
			}
		}
		if (roadTypeUpdateFlag || !(OCCQOOOQQO != null))
		{
			return;
		}
		inspRoadTypes.Clear();
		inspRoadTypeInts.Clear();
		if (OCCQOOOQQO.roadType == 0.0)
		{
			return;
		}
		for (int k = 0; k < roadTypes.Count; k++)
		{
			if (roadTypes[k].id == OCCQOOOQQO.roadType)
			{
				inspRoadTypes.Add(roadTypes[k]);
				inspRoadTypeInts.Add(k);
				selectedRoadRoadType = 1;
			}
		}
	}

	public void UpdateRoadTypeStatus()
	{
		roadTypeUpdateFlag = true;
		if (OCCQOOOQQO != null)
		{
			if (OCCQOOOQQO.startPrefabScript != null && OCCQOOOQQO.startPrefabScript.crossingElements[OCCQOOOQQO.startConnectionSegment].roadShapeMatchCount == 2)
			{
				roadTypeUpdateFlag = false;
			}
			if (OCCQOOOQQO.endPrefabScript != null && OCCQOOOQQO.endPrefabScript.crossingElements[OCCQOOOQQO.endConnectionSegment].roadShapeMatchCount == 2)
			{
				roadTypeUpdateFlag = false;
			}
		}
	}

	public void OCOCQOODCO()
	{
		int num = 0;
		foreach (QDOODOQQDQODD crossingElement in OOOQDOQCCOScript.crossingElements)
		{
			if (crossingElement.connectedRoad != null)
			{
				if (crossingElement.connectedMarker == 0 && crossingElement.connectedRoad.startPrefabScript == null)
				{
					crossingElement.connectedRoad.startPrefabScript = OOOQDOQCCOScript;
					crossingElement.connectedRoad.startConnectionSegment = num;
				}
				else if (crossingElement.connectedMarker != 0 && crossingElement.connectedRoad.endPrefabScript == null)
				{
					crossingElement.connectedRoad.endPrefabScript = OOOQDOQCCOScript;
					crossingElement.connectedRoad.endConnectionSegment = num;
				}
			}
			num++;
		}
	}

	public void OCQODDDCQQ()
	{
		AssembliesSet = true;
		vegetationStudio = false;
		vegetationStudioPro = false;
		Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
		foreach (Assembly assembly in assemblies)
		{
			try
			{
				Type[] types = assembly.GetTypes();
				foreach (Type type in types)
				{
					if (type.Name == "ERVegetationStudio" && (object)type.GetMethod("VegetationStudio") != null)
					{
						vegetationStudio = (bool)type.GetMethod("VegetationStudio").Invoke(null, null);
						if (vegetationStudio)
						{
							crMethod = type.GetMethod("CreateVegetationMaskLine");
							upMethod = type.GetMethod("UpdateVegetationMaskLine");
							hmMethod = type.GetMethod("UpdateHeightmap");
							rmMethod = type.GetMethod("RemoveVegetationMaskLine");
						}
					}
					if ((object)type.GetMethod("VegetationStudioPro") != null)
					{
						vegetationStudioPro = (bool)type.GetMethod("VegetationStudioPro").Invoke(null, null);
						if (vegetationStudioPro)
						{
							crMethod = type.GetMethod("CreateVegetationMaskLine");
							upMethod = type.GetMethod("UpdateVegetationMaskLine");
							hmMethod = type.GetMethod("UpdateHeightmap");
							rmMethod = type.GetMethod("RemoveVegetationMaskLine");
							crBiomeMethod = type.GetMethod("CreateBiomeArea");
							upBiomeMethod = type.GetMethod("UpdateBiomeArea");
							rmBiomeMethod = type.GetMethod("RemoveBiomeArea");
						}
					}
					if (type.Name == "TerrainData")
					{
						thMethodGet = type.GetMethod("GetHoles");
						thMethodSet = type.GetMethod("SetHoles");
					}
				}
			}
			catch
			{
			}
		}
	}

	public void ODODOQOODO()
	{
		try
		{
			if (doHeightmap && (vegetationStudio || vegetationStudioPro) && vegetationStudioActive && (object)hmMethod != null)
			{
				Bounds bounds = default(Bounds);
				object[] parameters = new object[1] { bounds };
				hmMethod.Invoke(null, parameters);
			}
		}
		catch
		{
		}
	}

	public void OOCQCCCQCD()
	{
		if (roadMaterial == null)
		{
			roadMaterial = Resources.Load("Materials/roads/road material") as Material;
		}
		if (crossingMaterial == null)
		{
			crossingMaterial = Resources.Load("Materials/roads/road material") as Material;
		}
		if (roundAboutMaterial == null)
		{
			roundAboutMaterial = Resources.Load("Materials/roundabouts/roundabout 2 lane") as Material;
		}
		if (roundAboutConnectionMaterial == null)
		{
			roundAboutConnectionMaterial = Resources.Load("Materials/roundabouts/roundaboutconnect 1") as Material;
		}
		if (roundAboutRoadMaterial == null)
		{
			roundAboutRoadMaterial = Resources.Load("Materials/roads/road material") as Material;
		}
	}

	public void OQDQQODDCD(GameObject go, Vector3 pos)
	{
		pos.y += 1f;
		GameObject gameObject = UnityEngine.Object.Instantiate(go);
		gameObject.name = "crossing";
		gameObject.transform.position = pos;
	}

	public void ODCDQQCQOC()
	{
		foreach (Transform item in base.transform)
		{
			if (item.name == "Connection Objects")
			{
				connectionObjectsParent = item;
			}
			else if (item.name == "Road Objects")
			{
				roadObjectsParent = item;
			}
		}
		if (connectionObjectsParent == null)
		{
			GameObject gameObject = new GameObject("Connection Objects");
			gameObject.transform.parent = base.transform;
			connectionObjectsParent = gameObject.transform;
			gameObject.transform.position = Vector3.zero;
		}
		if (roadObjectsParent == null)
		{
			GameObject gameObject2 = new GameObject("Road Objects");
			gameObject2.transform.parent = base.transform;
			roadObjectsParent = gameObject2.transform;
			gameObject2.transform.position = Vector3.zero;
		}
		ODQCODODDD = Application.isPlaying;
	}

	public ERCrossingPrefabs OCDQQCQCQQ(GameObject prefab, ERModularRoad OCCQOOOQQO, int OCODDDQOQC, int connectionSegment)
	{
		GameObject gameObject = null;
		ERConnectionParent eRConnectionParent = (ERConnectionParent)UnityEngine.Object.FindObjectOfType(typeof(ERConnectionParent));
		ERCrossingPrefabs eRCrossingPrefabs = null;
		ERCrossings eRCrossings = null;
		if ((bool)prefab.GetComponent<ERRoundabouts>())
		{
			eRCrossingPrefabs.GetComponent<ERRoundabouts>().isSceneObject = true;
		}
		else if ((bool)prefab.GetComponent<ERCrossings>())
		{
			gameObject = new GameObject(prefab.name);
			if (eRConnectionParent != null)
			{
				gameObject.transform.parent = eRConnectionParent.transform;
			}
			eRCrossingPrefabs = gameObject.AddComponent<ERCrossingPrefabs>();
			eRCrossings = gameObject.AddComponent<ERCrossings>();
			eRCrossings.prefabScript = eRCrossingPrefabs;
			eRCrossings.OCQCQODOQC(prefab.GetComponent<ERCrossings>(), refreshFlag: false);
			List<ERModularRoad> updatedRoads = new List<ERModularRoad>();
			foreach (QDQDOOQQDQODD roadType in roadTypes)
			{
				eRCrossings.UpdateToRoadType(roadType, ref updatedRoads);
			}
			if (connectionSegment == 2 && eRCrossingPrefabs.tCrossing && eRCrossings.tCrossingLeftRight == 1)
			{
				connectionSegment = 3;
			}
			else if (connectionSegment == 3 && eRCrossingPrefabs.tCrossing && eRCrossings.tCrossingLeftRight == 0)
			{
				connectionSegment = 2;
			}
			eRCrossings.isSceneObject = true;
		}
		else
		{
			gameObject = UnityEngine.Object.Instantiate(prefab);
			eRCrossingPrefabs = gameObject.GetComponent<ERCrossingPrefabs>();
			gameObject.name = prefab.name;
			eRCrossingPrefabs.transform.parent = eRConnectionParent.transform;
			if ((bool)gameObject.GetComponent<MeshFilter>() && (bool)gameObject.GetComponent<MeshFilter>().sharedMesh)
			{
				gameObject.GetComponent<MeshFilter>().sharedMesh = UnityEngine.Object.Instantiate(prefab.GetComponent<MeshFilter>().sharedMesh);
				if ((bool)gameObject.GetComponent<MeshCollider>())
				{
					gameObject.GetComponent<MeshCollider>().sharedMesh = gameObject.GetComponent<MeshFilter>().sharedMesh;
					gameObject.GetComponent<MeshCollider>().sharedMesh.name = gameObject.GetComponent<MeshFilter>().sharedMesh.name;
				}
				gameObject.GetComponent<MeshFilter>().sharedMesh.RecalculateBounds();
			}
		}
		if ((bool)gameObject.GetComponent<MeshRenderer>())
		{
			gameObject.GetComponent<MeshRenderer>().lightProbeUsage = LightProbeUsage.BlendProbes;
			gameObject.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.Off;
		}
		if (!eRCrossingPrefabs.isCustomPrefab)
		{
			OQCDDCDDQC(gameObject, prefab);
		}
		if (eRCrossingPrefabs.fullMeshVecs.Length == 0)
		{
			OQOCDOOQCQ(eRCrossingPrefabs);
		}
		if (connectionSegment == -1)
		{
			for (int i = 0; i < eRCrossingPrefabs.crossingElements.Count; i++)
			{
				if (eRCrossingPrefabs.crossingElements[i].rotationPriority)
				{
					connectionSegment = i;
					break;
				}
			}
		}
		if ((bool)gameObject.GetComponent<ERCrossings>())
		{
			gameObject.GetComponent<ERCrossings>().OOOCDCQQCO();
		}
		if (connectionSegment != -1 || eRCrossingPrefabs.crossingElements.Count > 1)
		{
		}
		if (connectionSegment == -1)
		{
			connectionSegment = OOOCOQQDQO(OCCQOOOQQO, eRCrossingPrefabs, OCODDDQOQC, 0, swapFlag: false);
		}
		if ((bool)prefab.GetComponent<ERCrossings>())
		{
			Vector3 v = OCCQOOOQQO.soSplinePoints[0];
			Vector3 v2 = OCCQOOOQQO.soSplinePoints[1];
			if (OCODDDQOQC != 0)
			{
				v = OCCQOOOQQO.soSplinePoints[OCCQOOOQQO.soSplinePoints.Count - 1];
				v2 = OCCQOOOQQO.soSplinePoints[OCCQOOOQQO.soSplinePoints.Count - 2];
			}
			eRCrossingPrefabs.OOCQCCQDOQ(v, v2, connectionSegment, OCCQOOOQQO);
			ODQDQDQDQOExt.OCCCQODODQ(eRCrossingPrefabs, OCCQOOOQQO, OCODDDQOQC, connectionSegment);
		}
		OCCQOOOQQO.nodeWithinRange = OCODDDQOQC;
		if (OCODDDQOQC == 0)
		{
			OCQOQOOOCO.ODQDCODODC(OCCQOOOQQO, OCCQOOOQQO.markersExt[OCODDDQOQC].position, eRCrossingPrefabs, connectionSegment, reverse: true, uvReverse: false, forceAutoRotate: true);
		}
		else
		{
			OCQOQOOOCO.ODQDCODODC(OCCQOOOQQO, OCCQOOOQQO.markersExt[OCODDDQOQC].position, eRCrossingPrefabs, connectionSegment, reverse: false, uvReverse: false, forceAutoRotate: true);
		}
		eRCrossingPrefabs.isSceneObject = true;
		eRCrossingPrefabs.baseScript = this;
		eRCrossingPrefabs.surroundingDistance = 0f;
		eRCrossingPrefabs.OQQCDODDQQ(forceFlag: false);
		eRCrossingPrefabs.prefabId = prefab.GetComponent<ERCrossingPrefabs>().prefabId;
		return eRCrossingPrefabs;
	}

	public ERCrossingPrefabs AttachConnector(ERModularRoad OCCQOOOQQO, int OCODDDQOQC)
	{
		GameObject gameObject = new GameObject("I Connector");
		ERConnectionParent eRConnectionParent = (ERConnectionParent)UnityEngine.Object.FindObjectOfType(typeof(ERConnectionParent));
		if (eRConnectionParent != null)
		{
			gameObject.transform.parent = eRConnectionParent.transform;
		}
		ERCrossingPrefabs eRCrossingPrefabs = gameObject.AddComponent<ERCrossingPrefabs>();
		ERIConnector iConnectorScript = gameObject.AddComponent<ERIConnector>();
		gameObject.AddComponent<MeshRenderer>();
		if ((bool)gameObject.GetComponent<MeshRenderer>())
		{
			gameObject.GetComponent<MeshRenderer>().lightProbeUsage = LightProbeUsage.BlendProbes;
			gameObject.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.Off;
		}
		int num = 0;
		OCCQOOOQQO.nodeWithinRange = OCODDDQOQC;
		if (OCODDDQOQC == 0)
		{
		}
		if (OCODDDQOQC == 0)
		{
			OCCQOOOQQO.startPrefabScript = eRCrossingPrefabs;
			OCCQOOOQQO.startConnectionSegment = 0;
		}
		else if (OCODDDQOQC == OCCQOOOQQO.markersExt.Count - 1)
		{
			OCCQOOOQQO.endPrefabScript = eRCrossingPrefabs;
			OCCQOOOQQO.endConnectionSegment = 0;
		}
		eRCrossingPrefabs.crossingElements.Add(new QDOODOQQDQODD());
		eRCrossingPrefabs.crossingElements.Add(new QDOODOQQDQODD());
		eRCrossingPrefabs.crossingElements[0].connectedRoad = OCCQOOOQQO;
		eRCrossingPrefabs.crossingElements[0].connectedMarker = OCODDDQOQC;
		eRCrossingPrefabs.crossingElements[0].connectedRoadGO = gameObject;
		gameObject.transform.position = OCCQOOOQQO.markersExt[OCODDDQOQC].position;
		eRCrossingPrefabs.baseScript = this;
		eRCrossingPrefabs.surroundingDistance = 0f;
		eRCrossingPrefabs.isIConnector = true;
		eRCrossingPrefabs.iConnectorScript = iConnectorScript;
		return eRCrossingPrefabs;
	}

	public void OCCDCDQOOD(ERModularRoad OCCQOOOQQO, int selectedMarker)
	{
		if (selectedMarker == 0)
		{
			if (OCCQOOOQQO.startPrefabScript != null)
			{
				int num = OOOCOQQDQO(OCCQOOOQQO, OCCQOOOQQO.startPrefabScript, selectedMarker, OCCQOOOQQO.startConnectionSegment + 1, swapFlag: true);
				if (num != -1 && num != OCCQOOOQQO.startConnectionSegment)
				{
					OCQOQOOOCO.ODQDCODODC(OCCQOOOQQO, OCCQOOOQQO.markersExt[selectedMarker].position, OCCQOOOQQO.startPrefabScript, num, reverse: true, uvReverse: false, forceAutoRotate: true);
				}
			}
		}
		else if (selectedMarker == OCCQOOOQQO.markersExt.Count - 1 && OCCQOOOQQO.endPrefabScript != null)
		{
			int num2 = OOOCOQQDQO(OCCQOOOQQO, OCCQOOOQQO.endPrefabScript, selectedMarker, OCCQOOOQQO.endConnectionSegment + 1, swapFlag: true);
			if (num2 != -1 && num2 != OCCQOOOQQO.endConnectionSegment)
			{
				OCQOQOOOCO.ODQDCODODC(OCCQOOOQQO, OCCQOOOQQO.markersExt[selectedMarker].position, OCCQOOOQQO.endPrefabScript, num2, reverse: false, uvReverse: false, forceAutoRotate: true);
			}
		}
	}

	public int OOOCOQQDQO(ERModularRoad OCCQOOOQQO, ERCrossingPrefabs prefabScript, int OCODDDQOQC, int startConnection, bool swapFlag)
	{
		int num = -1;
		List<Vector2> list = new List<Vector2>(OCCQOOOQQO.roadShape);
		if (OCODDDQOQC != 0)
		{
			for (int i = 0; i < list.Count; i++)
			{
				Vector2 value = list[i];
				value.x *= -1f;
				list[i] = value;
			}
		}
		string text = OCCQOOOQQO.roadShapeString;
		if (OCODDDQOQC != 0)
		{
			text = OCCQOOOQQO.roadShapeReversedString;
		}
		List<string> list2 = new List<string>();
		for (int j = startConnection; j < prefabScript.crossingElements.Count; j++)
		{
			if (text == prefabScript.crossingElements[j].roadShapeVecsString && prefabScript.crossingElements[j].connectionVecInts.Count > 0)
			{
				num = j;
				break;
			}
			list2.Add(prefabScript.crossingElements[j].roadShapeVecsString);
		}
		if (swapFlag && num == -1)
		{
			num = ((OCODDDQOQC != 0) ? OOOCOQQDQO(OCCQOOOQQO, OCCQOOOQQO.endPrefabScript, OCODDDQOQC, 0, swapFlag: true) : OOOCOQQDQO(OCCQOOOQQO, OCCQOOOQQO.startPrefabScript, OCODDDQOQC, 0, swapFlag: true));
		}
		if (swapFlag)
		{
			return num;
		}
		if (num == -1)
		{
			num = OOQQQQCCOC(text, list2, prefabScript.crossingElements);
		}
		if (num == -1)
		{
			num = ((OCODDDQOQC == 0 && prefabScript.isCustomPrefab && prefabScript.crossingElements.Count == 2) ? 1 : 0);
		}
		return num;
	}

	public int OOQQQQCCOC(string roadShapeString, List<string> strings, List<QDOODOQQDQODD> crossingElements)
	{
		int result = -1;
		string[] array = roadShapeString.Split(new char[1] { ';' });
		List<float> list = new List<float>();
		List<float> list2 = new List<float>();
		for (int i = 0; i < array.Length; i++)
		{
			string[] array2 = array[i].Split(new string[1] { ", " }, StringSplitOptions.None);
			if (array2[0] != "")
			{
				list.Add(float.Parse(array2[0]));
				list2.Add(float.Parse(array2[1]));
			}
		}
		for (int j = 0; j < strings.Count; j++)
		{
			if (crossingElements[j].connectionVecInts.Count <= 0)
			{
				continue;
			}
			List<float> list3 = new List<float>();
			List<float> list4 = new List<float>();
			array = strings[j].Split(new char[1] { ';' });
			for (int k = 0; k < array.Length; k++)
			{
				string[] array3 = array[k].Split(new string[1] { ", " }, StringSplitOptions.None);
				if (array3[0] != "")
				{
					list3.Add(float.Parse(array3[0]));
					list4.Add(float.Parse(array3[1]));
				}
			}
			float num = 1000f;
			if (list.Count == list3.Count)
			{
				num = 0f;
				for (int l = 0; l < list.Count; l++)
				{
					num += Math.Abs(list[l] - list3[l]);
					num += Math.Abs(list2[l] - list4[l]);
				}
			}
			if ((double)num < 0.5)
			{
				result = j;
				break;
			}
		}
		return result;
	}

	public GameObject OOQDQOOQQQ(GameObject prefab, Vector3 hitPos, ref GameObject newPrefab, ref ERCrossingPrefabs prefabScript, ref ERCrossings crossingsScript)
	{
		ERConnectionParent eRConnectionParent = (ERConnectionParent)UnityEngine.Object.FindObjectOfType(typeof(ERConnectionParent));
		if (prefab == null)
		{
			UnityEngine.Debug.Log("This is an empty prefab");
			return null;
		}
		if ((bool)prefab.GetComponent<ERCrossings>())
		{
			newPrefab = new GameObject(prefab.name);
			if (eRConnectionParent != null)
			{
				newPrefab.transform.parent = eRConnectionParent.transform;
			}
			newPrefab.transform.position = hitPos;
			prefabScript = newPrefab.AddComponent<ERCrossingPrefabs>();
			crossingsScript = newPrefab.AddComponent<ERCrossings>();
			crossingsScript.prefabScript = prefabScript;
			crossingsScript.OCQCQODOQC(prefab.GetComponent<ERCrossings>(), refreshFlag: false);
			List<ERModularRoad> updatedRoads = new List<ERModularRoad>();
			foreach (QDQDOOQQDQODD roadType in roadTypes)
			{
				crossingsScript.UpdateToRoadType(roadType, ref updatedRoads);
			}
		}
		else
		{
			newPrefab = UnityEngine.Object.Instantiate(prefab);
			newPrefab.name = prefab.name;
			prefabScript = newPrefab.GetComponent<ERCrossingPrefabs>();
			newPrefab.transform.position = hitPos;
			newPrefab.transform.parent = eRConnectionParent.transform;
			if ((bool)newPrefab.GetComponent<ERRoundabouts>())
			{
				if ((bool)newPrefab.GetComponent<MeshFilter>())
				{
					newPrefab.GetComponent<MeshFilter>().sharedMesh = null;
				}
				if ((bool)newPrefab.GetComponent<MeshCollider>())
				{
					newPrefab.GetComponent<MeshCollider>().sharedMesh = null;
				}
				newPrefab.GetComponent<ERRoundabouts>().baseScript = this;
				newPrefab.GetComponent<ERRoundabouts>().OOCDDOQDDO();
				newPrefab.GetComponent<ERRoundabouts>().OQQCDOQOOQ();
				newPrefab.GetComponent<ERRoundabouts>().ODDDOCDCQO();
				List<ERModularRoad> list = new List<ERModularRoad>();
				foreach (QDQDOOQQDQODD roadType2 in roadTypes)
				{
					newPrefab.GetComponent<ERRoundabouts>().UpdateToRoadType(roadType2);
				}
			}
			else
			{
				if (prefab.GetComponent<MeshFilter>().sharedMesh == null)
				{
					UnityEngine.Debug.LogError("EasyRoads3Dv3 Error: No mesh is assigned to custom prefab: " + prefab.name);
					return newPrefab;
				}
				newPrefab.GetComponent<MeshFilter>().sharedMesh = UnityEngine.Object.Instantiate(prefab.GetComponent<MeshFilter>().sharedMesh);
				if ((bool)newPrefab.GetComponent<MeshCollider>())
				{
					newPrefab.GetComponent<MeshCollider>().sharedMesh = newPrefab.GetComponent<MeshFilter>().sharedMesh;
					newPrefab.GetComponent<MeshCollider>().sharedMesh.name = newPrefab.GetComponent<MeshFilter>().sharedMesh.name;
				}
				if ((bool)newPrefab.GetComponent<MeshFilter>() && (bool)newPrefab.GetComponent<MeshFilter>().sharedMesh)
				{
					newPrefab.GetComponent<MeshFilter>().sharedMesh.RecalculateBounds();
				}
			}
		}
		if ((bool)newPrefab.GetComponent<MeshRenderer>())
		{
			newPrefab.GetComponent<MeshRenderer>().lightProbeUsage = LightProbeUsage.BlendProbes;
			newPrefab.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.Off;
		}
		if (!prefabScript.isCustomPrefab)
		{
			OQCDDCDDQC(newPrefab, prefab);
		}
		if (prefabScript.fullMeshVecs.Length == 0)
		{
			OQOCDOOQCQ(prefabScript);
		}
		prefabScript.baseScript = this;
		prefabScript.surroundingDistance = 0f;
		prefabScript.OQQCDODDQQ(forceFlag: false);
		prefabScript.prefabId = prefab.GetComponent<ERCrossingPrefabs>().prefabId;
		return newPrefab;
	}

	public void OQOCDOOQCQ(ERCrossingPrefabs prefabScript)
	{
		prefabScript.fullMeshVecs = new Vector3[prefabScript.meshVecs.Length];
		Array.Copy(prefabScript.meshVecs, prefabScript.fullMeshVecs, prefabScript.meshVecs.Length);
		prefabScript.tmpFullMeshVecs = new Vector3[prefabScript.tmpMeshVecs.Length];
		Array.Copy(prefabScript.tmpMeshVecs, prefabScript.tmpFullMeshVecs, prefabScript.tmpMeshVecs.Length);
		for (int i = 0; i < prefabScript.crossingElements.Count; i++)
		{
			prefabScript.crossingElements[i].fullConnectionVecInts = new List<int>(prefabScript.crossingElements[i].connectionVecInts);
		}
	}

	public void OQCDDCDDQC(GameObject newPrefab, GameObject prefab)
	{
		List<GameObject> list = new List<GameObject>();
		foreach (Transform item in newPrefab.transform)
		{
			if (item.name != "surface")
			{
				list.Add(item.gameObject);
			}
		}
		if (Application.isEditor && !Application.isPlaying)
		{
			foreach (GameObject item2 in list)
			{
				UnityEngine.Object.DestroyImmediate(item2);
			}
		}
		else
		{
			foreach (GameObject item3 in list)
			{
				UnityEngine.Object.Destroy(item3);
			}
		}
		foreach (Transform item4 in prefab.transform)
		{
			if (item4.name != "surface")
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(item4.gameObject);
				gameObject.name = item4.name;
				gameObject.transform.parent = newPrefab.transform;
				gameObject.transform.localPosition = item4.transform.localPosition;
				gameObject.transform.localScale = item4.transform.localScale;
				gameObject.transform.localEulerAngles = item4.transform.localEulerAngles;
			}
		}
	}

	public void ODDQCOQCQC()
	{
		ERModularRoad[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERModularRoad)) as ERModularRoad[];
		ERModularRoad[] array2 = array;
		foreach (ERModularRoad eRModularRoad in array2)
		{
			try
			{
				if (eRModularRoad.startPrefabScript != null && eRModularRoad.startPrefabScript.crossingElements.Count > eRModularRoad.startConnectionSegment)
				{
					eRModularRoad.startPrefabScript.crossingElements[eRModularRoad.startConnectionSegment].connectedRoad = eRModularRoad;
					eRModularRoad.startPrefabScript.crossingElements[eRModularRoad.startConnectionSegment].connectedMarker = 0;
				}
			}
			catch
			{
				UnityEngine.Debug.Log("EasyRoads3Dv3 Error: Road: " + eRModularRoad.name + " Connection at start: " + eRModularRoad.startPrefabScript.name + " connection index " + eRModularRoad.startConnectionSegment);
			}
			try
			{
				if (eRModularRoad.endPrefabScript != null && eRModularRoad.endPrefabScript.crossingElements.Count > eRModularRoad.endConnectionSegment)
				{
					eRModularRoad.endPrefabScript.crossingElements[eRModularRoad.endConnectionSegment].connectedRoad = eRModularRoad;
					eRModularRoad.endPrefabScript.crossingElements[eRModularRoad.endConnectionSegment].connectedMarker = eRModularRoad.markersExt.Count - 1;
				}
			}
			catch
			{
				UnityEngine.Debug.Log("EasyRoads3Dv3 Error: Road: " + eRModularRoad.name + " Connection at end: " + eRModularRoad.endPrefabScript.name + " connection index " + eRModularRoad.endConnectionSegment);
			}
		}
	}

	public List<ERTerrain> OODQQODOOC(ref bool multTerrainResFlag)
	{
		List<string> list = new List<string>();
		List<Terrain> list2 = new List<Terrain>();
		list.Add("All Terrains");
		list2.Add(null);
		List<ERTerrain> list3 = new List<ERTerrain>();
		float num = 0f;
		float num2 = (terrainDetailSplatX = 100f);
		float num3 = (terrainDetailSplatY = 100f);
		Terrain[] array = UnityEngine.Object.FindObjectsOfType(typeof(Terrain)) as Terrain[];
		int num4 = 0;
		float num5 = 0f;
		Terrain[] array2 = array;
		foreach (Terrain terrain in array2)
		{
			if (!(terrain.terrainData != null))
			{
				continue;
			}
			if (terrain.gameObject.GetComponent<ERTerrain>() == null)
			{
				terrain.gameObject.AddComponent<ERTerrain>();
				list3.Add(terrain.gameObject.GetComponent<ERTerrain>());
				terrain.gameObject.GetComponent<ERTerrain>().terrainData = terrain.terrainData;
			}
			else if (terrain.gameObject.GetComponent<ERTerrain>().terrainData != terrain.terrainData)
			{
				terrain.gameObject.GetComponent<ERTerrain>().terrainData = terrain.terrainData;
				list3.Add(terrain.gameObject.GetComponent<ERTerrain>());
			}
			if (!(terrain.gameObject.GetComponent<ERTerrain>() != null) || terrain.gameObject.GetComponent<ERTerrain>().ignore)
			{
				continue;
			}
			list.Add(terrain.name);
			list2.Add(terrain);
			float num6 = terrain.terrainData.size.x / ((float)terrain.terrainData.heightmapResolution * 1f - 1f);
			if (num4 != terrain.terrainData.heightmapResolution || num6 != num5)
			{
				if (num4 != 0 && num6 != num5)
				{
					multTerrainResFlag = true;
				}
				num4 = terrain.terrainData.heightmapResolution;
				num5 = num6;
			}
			if (terrain.terrainData.heightmapScale.x > num)
			{
				num = terrain.terrainData.heightmapScale.x;
			}
			if (terrain.terrainData.heightmapScale.z > num)
			{
				num = terrain.terrainData.heightmapScale.z;
			}
			num2 = terrain.terrainData.size.x / ((float)terrain.terrainData.detailResolution * 1f);
			num3 = terrain.terrainData.size.z / ((float)terrain.terrainData.detailResolution * 1f);
			if (num2 < terrainDetailSplatX)
			{
				terrainDetailSplatX = num2;
			}
			if (num3 < terrainDetailSplatY)
			{
				terrainDetailSplatY = num3;
			}
		}
		terrainNames = list.ToArray();
		terrainObjects = list2.ToArray();
		num *= 1.5f;
		if (!ignoreMinIndents)
		{
			terrainMinIndent = num;
			if (num > minIndent)
			{
				minIndent = num;
			}
		}
		else
		{
			minIndent = 0f;
		}
		terrainDetailSplatX *= 0.5f;
		terrainDetailSplatY *= 0.5f;
		detailOffsetVec = new Vector3(terrainDetailSplatX, 0f, terrainDetailSplatY);
		if (array.Length != 0)
		{
			List<string> list4 = new List<string>();
			TerrainLayer[] terrainLayers = array[0].terrainData.terrainLayers;
			foreach (TerrainLayer terrainLayer in terrainLayers)
			{
				Texture2D diffuseTexture = terrainLayer.diffuseTexture;
				if (diffuseTexture != null)
				{
					list4.Add("Splat " + (list4.Count + 1) + " - " + diffuseTexture.name);
				}
				else
				{
					list4.Add("Splat " + (list4.Count + 1) + " - Empty");
				}
			}
			terrainSplatTextures = list4.ToArray();
		}
		return list3;
	}

	public void ODDCCODOOC()
	{
		QDQDOOQQOOQDD.ODDCCODOOC(this, terrainObjects[selectedTerrain]);
	}

	public void OQQQDCQOOC(bool restoreTerrain)
	{
		ERTerrain[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERTerrain)) as ERTerrain[];
		if (restoreTerrain)
		{
			ERTerrain[] array2 = array;
			foreach (ERTerrain eRTerrain in array2)
			{
				if (eRTerrain.terrainDone)
				{
					QDQDOOQQOOQDD.ODODDDDCOQ(this, eRTerrain, eRTerrain.gameObject.GetComponent<Terrain>());
				}
			}
		}
		if (this != null)
		{
			baseVector = Vector3.zero;
			Transform transform = base.transform.Find("Connection Objects");
			transform.position = baseVector;
			transform = base.transform.Find("Road Objects");
			transform.position = baseVector;
		}
		int num = 0;
		List<int> list = new List<int>();
		foreach (GameObject surfaceObject in surfaceObjects)
		{
			num++;
			if (surfaceObject != null)
			{
				surfaceObject.SetActive(value: true);
				bool flag = !hideSurfaces;
				if (surfaceObject.GetComponent<MeshCollider>() != null)
				{
					surfaceObject.GetComponent<MeshCollider>().enabled = flag;
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("Missing surface detected [" + num + "]: Are all objects correctly restored?");
				list.Add(num - 1);
			}
		}
		if (list.Count > 0)
		{
			for (int j = 0; j < list.Count; j++)
			{
				if (surfaceObjects.Count > list[j])
				{
					surfaceObjects.RemoveAt(list[j]);
					j--;
				}
			}
		}
		ERTerrain[] array3 = UnityEngine.Object.FindObjectsOfType(typeof(ERTerrain)) as ERTerrain[];
		ERSideObjectInstance[] array4 = ((!(this != null)) ? (UnityEngine.Object.FindObjectsOfType(typeof(ERSideObjectInstance)) as ERSideObjectInstance[]) : base.gameObject.GetComponentsInChildren<ERSideObjectInstance>());
		if (soTrees)
		{
			ERSideObjectInstance[] array5 = array4;
			foreach (ERSideObjectInstance eRSideObjectInstance in array5)
			{
				if (!(eRSideObjectInstance.so != null) || eRSideObjectInstance.so.terrainTree == 0 || !buildSOinEditMode)
				{
					continue;
				}
				foreach (GameObject child in eRSideObjectInstance.childs)
				{
					if (child != null)
					{
						child.SetActive(value: true);
					}
				}
			}
			ERTerrain[] array6 = array3;
			foreach (ERTerrain eRTerrain2 in array6)
			{
				try
				{
					TerrainData terrainData = eRTerrain2.gameObject.GetComponent<Terrain>().terrainData;
					List<TreeInstance> list2 = new List<TreeInstance>(terrainData.treeInstances);
					foreach (ERTreeInstance addedTree in eRTerrain2.addedTrees)
					{
						for (int m = 0; m < list2.Count; m++)
						{
							if (addedTree.position.x == list2[m].position.x && addedTree.position.z == list2[m].position.z)
							{
								list2.RemoveAt(m);
								break;
							}
						}
					}
					eRTerrain2.addedTrees.Clear();
					terrainData.treeInstances = list2.ToArray();
				}
				catch
				{
					UnityEngine.Debug.LogError("EasyRoads3Dv3: Removing trees added from side objects from terrain " + eRTerrain2.gameObject.name + " failed, please report with details!");
				}
			}
		}
		isInBuildMode = false;
		if (doLightmapUVs)
		{
			ERCrossings[] array7 = UnityEngine.Object.FindObjectsOfType(typeof(ERCrossings)) as ERCrossings[];
			ERCrossings[] array8 = array7;
			foreach (ERCrossings eRCrossings in array8)
			{
				try
				{
					eRCrossings.OCQDQODOQD(sidewalkSceneHandleFlag: false, rebuildRoads: true);
				}
				catch
				{
					UnityEngine.Debug.Log("Refresh failed: " + eRCrossings.gameObject.name);
				}
			}
			ERRoundabouts[] array9 = UnityEngine.Object.FindObjectsOfType(typeof(ERRoundabouts)) as ERRoundabouts[];
			ERRoundabouts[] array10 = array9;
			foreach (ERRoundabouts eRRoundabouts in array10)
			{
				try
				{
					eRRoundabouts.OOCDDOQDDO();
					eRRoundabouts.OQQCDOQOOQ();
					if (eRRoundabouts.leftFlag && eRRoundabouts.rightFlag)
					{
						eRRoundabouts.ODDDOCDCQO();
						if (eRRoundabouts.connections.Count > 0)
						{
							eRRoundabouts.OOQQDCCCCC();
						}
					}
				}
				catch
				{
					UnityEngine.Debug.Log("Refresh failed: " + eRRoundabouts.gameObject.name);
				}
			}
		}
		ERSideObjectInstance[] array11 = array4;
		foreach (ERSideObjectInstance eRSideObjectInstance2 in array11)
		{
			try
			{
				if (!(eRSideObjectInstance2.so != null) || eRSideObjectInstance2.so.terrainTree != 0)
				{
					continue;
				}
				ERModularRoad component = eRSideObjectInstance2.transform.parent.GetComponent<ERModularRoad>();
				bool flag2 = true;
				if (selectedRoadsOnly)
				{
					flag2 = false;
					for (int num4 = 0; num4 < selectedObjects.Count; num4++)
					{
						if (selectedObjects[num4].roadScr == component)
						{
							flag2 = true;
							break;
						}
					}
				}
				if (!(component != null && flag2))
				{
					continue;
				}
				bool flag3 = false;
				for (int num5 = 0; num5 < component.soDataExt.Count; num5++)
				{
					if (component.soDataExt[num5].sideObject.id == eRSideObjectInstance2.so.id && component.soDataExt[num5].active)
					{
						flag3 = true;
						break;
					}
				}
				if (flag3 && flag2)
				{
					ODDQODOOOC.ODQCOCOCOQ(this, component, eRSideObjectInstance2.so);
					if (buildSOinEditMode || component.isSideObject)
					{
						ODDQODOOOC.OODQCDDCQO(this, component, eRSideObjectInstance2.so);
					}
				}
				component.sosCleared = false;
			}
			catch
			{
				string text = "[none]";
				if (eRSideObjectInstance2 != null)
				{
					if (eRSideObjectInstance2.transform.parent != null)
					{
						text = eRSideObjectInstance2.transform.parent.name;
					}
					UnityEngine.Debug.LogError("EasyRoads3Dv3: Rebuilding side object " + eRSideObjectInstance2.gameObject.name + " on object " + text + " failed, please report with details!");
				}
			}
		}
		if (soDeformationObjects.Count > 0)
		{
			foreach (GameObject soDeformationObject in soDeformationObjects)
			{
				if (soDeformationObject != null)
				{
					soDeformationObject.SetActive(value: true);
					if ((bool)soDeformationObject.GetComponent<MeshCollider>())
					{
						soDeformationObject.GetComponent<MeshCollider>().enabled = true;
					}
				}
			}
			soDeformationObjects.Clear();
		}
		if (doSplatmaps && restoreTerrain)
		{
			ERTerrain[] array12 = array3;
			foreach (ERTerrain eRTerrain3 in array12)
			{
				try
				{
					if (eRTerrain3.splatData.Count > 0)
					{
						TerrainData terrainData2 = eRTerrain3.gameObject.GetComponent<Terrain>().terrainData;
						float[,,] alphamaps = terrainData2.GetAlphamaps(0, 0, terrainData2.alphamapWidth, terrainData2.alphamapHeight);
						foreach (ERSplatmap splatDatum in eRTerrain3.splatData)
						{
							if (!newSplatMapRestoreCode)
							{
								if (splatDatum.index <= 4)
								{
									if (terrainData2.alphamapLayers > 0)
									{
										alphamaps[splatDatum.x, splatDatum.y, 0] = splatDatum.tValue1;
									}
									if (terrainData2.alphamapLayers > 1)
									{
										alphamaps[splatDatum.x, splatDatum.y, 1] = splatDatum.tValue2;
									}
									if (terrainData2.alphamapLayers > 2)
									{
										alphamaps[splatDatum.x, splatDatum.y, 2] = splatDatum.tValue3;
									}
									if (terrainData2.alphamapLayers > 3)
									{
										alphamaps[splatDatum.x, splatDatum.y, 3] = splatDatum.tValue4;
									}
								}
								else if (splatDatum.index <= 8)
								{
									if (terrainData2.alphamapLayers > 4)
									{
										alphamaps[splatDatum.x, splatDatum.y, 4] = splatDatum.tValue1;
									}
									if (terrainData2.alphamapLayers > 5)
									{
										alphamaps[splatDatum.x, splatDatum.y, 5] = splatDatum.tValue2;
									}
									if (terrainData2.alphamapLayers > 6)
									{
										alphamaps[splatDatum.x, splatDatum.y, 6] = splatDatum.tValue3;
									}
									if (terrainData2.alphamapLayers > 7)
									{
										alphamaps[splatDatum.x, splatDatum.y, 7] = splatDatum.tValue4;
									}
								}
								else if (splatDatum.index <= 12)
								{
									if (terrainData2.alphamapLayers > 8)
									{
										alphamaps[splatDatum.x, splatDatum.y, 8] = splatDatum.tValue1;
									}
									if (terrainData2.alphamapLayers > 9)
									{
										alphamaps[splatDatum.x, splatDatum.y, 9] = splatDatum.tValue2;
									}
									if (terrainData2.alphamapLayers > 10)
									{
										alphamaps[splatDatum.x, splatDatum.y, 10] = splatDatum.tValue3;
									}
									if (terrainData2.alphamapLayers > 11)
									{
										alphamaps[splatDatum.x, splatDatum.y, 11] = splatDatum.tValue4;
									}
								}
							}
							else
							{
								if (terrainData2.alphamapLayers > 0)
								{
									alphamaps[splatDatum.x, splatDatum.y, 0] = splatDatum.tValue1;
								}
								if (terrainData2.alphamapLayers > 1)
								{
									alphamaps[splatDatum.x, splatDatum.y, 1] = splatDatum.tValue2;
								}
								if (terrainData2.alphamapLayers > 2)
								{
									alphamaps[splatDatum.x, splatDatum.y, 2] = splatDatum.tValue3;
								}
								if (terrainData2.alphamapLayers > 3)
								{
									alphamaps[splatDatum.x, splatDatum.y, 3] = splatDatum.tValue4;
								}
								if (terrainData2.alphamapLayers > 4)
								{
									alphamaps[splatDatum.x, splatDatum.y, 4] = splatDatum.tValue5;
								}
								if (terrainData2.alphamapLayers > 5)
								{
									alphamaps[splatDatum.x, splatDatum.y, 5] = splatDatum.tValue6;
								}
								if (terrainData2.alphamapLayers > 6)
								{
									alphamaps[splatDatum.x, splatDatum.y, 6] = splatDatum.tValue7;
								}
								if (terrainData2.alphamapLayers > 7)
								{
									alphamaps[splatDatum.x, splatDatum.y, 7] = splatDatum.tValue8;
								}
								if (terrainData2.alphamapLayers > 8)
								{
									alphamaps[splatDatum.x, splatDatum.y, 8] = splatDatum.tValue9;
								}
								if (terrainData2.alphamapLayers > 9)
								{
									alphamaps[splatDatum.x, splatDatum.y, 9] = splatDatum.tValue10;
								}
								if (terrainData2.alphamapLayers > 10)
								{
									alphamaps[splatDatum.x, splatDatum.y, 10] = splatDatum.tValue11;
								}
								if (terrainData2.alphamapLayers > 11)
								{
									alphamaps[splatDatum.x, splatDatum.y, 11] = splatDatum.tValue12;
								}
							}
						}
						terrainData2.SetAlphamaps(0, 0, alphamaps);
					}
				}
				catch
				{
					UnityEngine.Debug.LogError("EasyRoads3Dv3: Restoring the splatmap for terrain " + eRTerrain3.gameObject.name + " failed, please report with details!");
				}
				eRTerrain3.splatmapFlag = false;
			}
		}
		if (lodGroups)
		{
			ERModularRoad[] array13 = UnityEngine.Object.FindObjectsOfType(typeof(ERModularRoad)) as ERModularRoad[];
			ERModularRoad[] array14 = array13;
			foreach (ERModularRoad eRModularRoad in array14)
			{
				bool flag4 = true;
				if (selectedRoadsOnly)
				{
					flag4 = false;
					for (int num8 = 0; num8 < selectedObjects.Count; num8++)
					{
						if (selectedObjects[num8].roadScr == eRModularRoad)
						{
							flag4 = true;
							break;
						}
					}
				}
				if (!flag4)
				{
					continue;
				}
				if ((bool)eRModularRoad.gameObject.GetComponent<LODGroup>())
				{
					UnityEngine.Object.DestroyImmediate(eRModularRoad.gameObject.GetComponent<LODGroup>());
				}
				for (int num9 = 0; num9 < LODLevels; num9++)
				{
					Transform transform2 = eRModularRoad.transform.Find("LOD " + num9);
					if ((bool)transform2)
					{
						if (Application.isEditor && !Application.isPlaying)
						{
							UnityEngine.Object.DestroyImmediate(transform2.gameObject);
						}
						else
						{
							UnityEngine.Object.Destroy(transform2.gameObject);
						}
					}
				}
				if ((bool)eRModularRoad.GetComponent<MeshRenderer>())
				{
					eRModularRoad.GetComponent<MeshRenderer>().enabled = true;
				}
				if ((bool)eRModularRoad.GetComponent<MeshCollider>())
				{
					eRModularRoad.GetComponent<MeshCollider>().enabled = true;
				}
			}
		}
		try
		{
			if (doHeightmap && vegetationStudio && vegetationStudioActive && (object)hmMethod != null)
			{
				Bounds bounds = default(Bounds);
				object[] parameters = new object[1] { bounds };
				hmMethod.Invoke(null, parameters);
			}
		}
		catch
		{
		}
		ERTerrain[] array15 = array3;
		foreach (ERTerrain eRTerrain4 in array15)
		{
			eRTerrain4.splatData.Clear();
			eRTerrain4.terrainChanges.Clear();
			eRTerrain4.addedTrees.Clear();
			eRTerrain4.terrainTrees.Clear();
			eRTerrain4.detailInstances.Clear();
			eRTerrain4.holes.Clear();
		}
		surfaceObjects.Clear();
		tunnelObjects.Clear();
		ODODOQOODO();
		ERRoadNetwork.OnEditModeEnter();
	}

	public void OQQOOCQQCD(Vector3 pos)
	{
		if (meshSurface == null)
		{
			if (pos.x < terrainRect.x || pos.x > terrainRect.x + terrainRect.width || pos.z < terrainRect.y || pos.z > terrainRect.y + terrainRect.height || activeTerrain == null)
			{
				OQOQDDOQOD(ref pos, setSelected: false);
			}
		}
		else
		{
			activeTerrain = null;
		}
	}

	public void OCDDQOCDCO(ref Vector3 pos)
	{
		if (meshSurface == null)
		{
			if (pos.x < terrainRect.x || pos.x > terrainRect.x + terrainRect.width || pos.z < terrainRect.y || pos.z > terrainRect.y + terrainRect.height || activeTerrain == null)
			{
				OQOQDDOQOD(ref pos, setSelected: false);
			}
			if (activeTerrain != null)
			{
				pos.y = activeTerrainY + activeTerrain.SampleHeight(pos);
			}
			return;
		}
		Ray ray = default(Ray);
		Vector3 vector = pos;
		vector.y += 1f;
		ray.origin = pos;
		ray.direction = Vector3.down;
		if (meshTerrainCollider != null && meshTerrainCollider.Raycast(ray, out var hitInfo, 10f))
		{
			pos.y = hitInfo.point.y;
		}
	}

	public Vector3 OQOODODDQO(Vector3 pos)
	{
		if (pos.x < terrainRect.x || pos.x > terrainRect.x + terrainRect.width || pos.z < terrainRect.y || pos.z > terrainRect.y + terrainRect.height)
		{
			OQOQDDOQOD(ref pos, setSelected: false);
		}
		OQOQDDOQOD(ref pos, setSelected: false);
		if (activeTerrain != null)
		{
			float x = (pos.x - terrainRect.x) / activeTerrain.terrainData.size.x;
			float y = (pos.z - terrainRect.y) / activeTerrain.terrainData.size.z;
			return activeTerrain.terrainData.GetInterpolatedNormal(x, y);
		}
		return Vector3.up;
	}

	public Vector2 GetTerrainUV(Vector3 pos)
	{
		Vector2 zero = Vector2.zero;
		if (meshSurface == null)
		{
			if (pos.x < terrainRect.x || pos.x > terrainRect.x + terrainRect.width || pos.z < terrainRect.y || pos.z > terrainRect.y + terrainRect.height || activeTerrain == null)
			{
				OQOQDDOQOD(ref pos, setSelected: false);
			}
			zero.x = (pos.x - terrainRect.x) / terrainRect.width;
			zero.y = (pos.z - terrainRect.y) / terrainRect.height;
		}
		else
		{
			zero = Vector2.zero;
		}
		return zero;
	}

	public Terrain OQOQDDOQOD(ref Vector3 pos, bool setSelected)
	{
		if (terrainObjects == null)
		{
			bool multTerrainResFlag = false;
			OODQQODOOC(ref multTerrainResFlag);
			if (terrainObjects == null)
			{
				UnityEngine.Debug.LogWarning("No terrain found, EasyRoads3Dv3 requires at least one terrain object!");
			}
		}
		int num = 0;
		Terrain[] array = terrainObjects;
		foreach (Terrain terrain in array)
		{
			if (terrain != null && pos.x > terrain.transform.position.x && pos.x < terrain.transform.position.x + terrain.terrainData.size.x && pos.z > terrain.transform.position.z && pos.z < terrain.transform.position.z + terrain.terrainData.size.z)
			{
				if (setSelected)
				{
					if (selectedTerrain == num)
					{
						selectedTerrain = 0;
						return null;
					}
					selectedTerrain = num;
					return terrain;
				}
				terrainRect.x = terrain.transform.position.x;
				terrainRect.width = terrain.terrainData.size.x;
				terrainRect.y = terrain.transform.position.z;
				terrainRect.height = terrain.terrainData.size.z;
				activeTerrain = terrain;
				activeTerrainY = (terrainY = activeTerrain.transform.position.y);
			}
			num++;
		}
		return null;
	}

	public void OQCQQQDQQD()
	{
		LODLevels = 4;
		LODLevelValues.Clear();
		LODLevelValues.Add(0.6f);
		LODLevelValues.Add(0.4f);
		LODLevelValues.Add(0.2f);
		LODLevelValues.Add(0f);
		LODLevelResolution.Clear();
		LODLevelResolution.Add(0.9f);
		LODLevelResolution.Add(0.8f);
		LODLevelResolution.Add(0.6f);
		LODLevelResolution.Add(0.4f);
	}

	public void UpdateLODLevels(int levels)
	{
		if (levels < LODLevelValues.Count)
		{
			while (levels < LODLevelValues.Count)
			{
				LODLevelValues.RemoveAt(LODLevelValues.Count - 1);
				LODLevelResolution.RemoveAt(LODLevelResolution.Count - 1);
			}
		}
		else
		{
			while (levels > LODLevelValues.Count)
			{
				LODLevelValues.Add(0f);
				LODLevelResolution.Add(0f);
			}
		}
	}

	public void UpdateSideObjectsInScene()
	{
		if (RoadObjectsSoUpdates.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < RoadObjectsSoUpdates.Count; i++)
		{
			if (RoadObjectsSoUpdates[i] != null)
			{
				ODDQODOOOC.ODOODCCDOC(this, RoadObjectsSoUpdates[i], isSideObjectFlag: false);
			}
		}
		RoadObjectsSoUpdates.Clear();
	}

	public void OOCDOOCQQC()
	{
		bool flag = !hideSurfaces;
		ERSurfaceScript[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERSurfaceScript)) as ERSurfaceScript[];
		ERSurfaceScript[] array2 = array;
		foreach (ERSurfaceScript eRSurfaceScript in array2)
		{
			eRSurfaceScript.gameObject.GetComponent<MeshRenderer>().enabled = flag;
			eRSurfaceScript.gameObject.GetComponent<MeshCollider>().enabled = flag;
		}
	}

	public void OQQDDOQQOO()
	{
		ERSurfaceScript[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERSurfaceScript)) as ERSurfaceScript[];
		ERSurfaceScript[] array2 = array;
		foreach (ERSurfaceScript eRSurfaceScript in array2)
		{
			if ((bool)eRSurfaceScript.transform.parent.gameObject.GetComponent<MeshRenderer>())
			{
				eRSurfaceScript.transform.parent.gameObject.GetComponent<MeshRenderer>().lightProbeUsage = LightProbeUsage.BlendProbes;
				eRSurfaceScript.transform.parent.gameObject.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.Off;
			}
		}
	}

	public ERRoadType[] GetRoadTypes()
	{
		List<ERRoadType> list = new List<ERRoadType>();
		foreach (QDQDOOQQDQODD roadType in roadTypes)
		{
			ERRoadType eRRoadType = new ERRoadType();
			eRRoadType.id = roadType.id;
			eRRoadType.roadTypeName = roadType.roadTypeName;
			eRRoadType.roadWidth = roadType.roadWidth;
			eRRoadType.roadShape = new List<Vector2>(roadType.roadShape);
			eRRoadType.doConnectionTri = new List<bool>(roadType.doConnectionTri);
			eRRoadType.roadShapeUVs = new List<float>(roadType.roadShapeUVs);
			eRRoadType.hardEdge = new List<bool>(roadType.hardEdge);
			eRRoadType.sidewalks = roadType.sidewalks;
			eRRoadType.sidewalkHeight = roadType.sidewalkHeight;
			eRRoadType.sidewalkWidth = roadType.sidewalkWidth;
			eRRoadType.roadMaterial = roadType.roadMaterial;
			eRRoadType.connectionMaterial = roadType.connectionMaterial;
			eRRoadType.terrainDeformation = roadType.terrainDeformation;
			eRRoadType.faceDistance = roadType.faceDistance;
			eRRoadType.isSideObject = roadType.isSideObject;
			eRRoadType.soDataExt = new List<ERSORoadExt>();
			for (int i = 0; i < roadType.soDataExt.Count; i++)
			{
				if (roadType.soDataExt[i] != null && roadType.soDataExt[i].sideObject != null)
				{
					eRRoadType.soDataExt.Add(ERSORoadExt.CreateInstance(roadType.soDataExt[i].sideObject));
					if (roadType.soDataExt[i].active)
					{
						eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].active = true;
					}
				}
			}
			list.Add(eRRoadType);
		}
		return list.ToArray();
	}

	public ERRoadType GetRoadTypeByName(string name)
	{
		List<ERRoadType> list = new List<ERRoadType>();
		foreach (QDQDOOQQDQODD roadType in roadTypes)
		{
			if (!(roadType.roadTypeName == name))
			{
				continue;
			}
			ERRoadType eRRoadType = new ERRoadType();
			eRRoadType.id = roadType.id;
			eRRoadType.roadTypeName = roadType.roadTypeName;
			eRRoadType.roadWidth = roadType.roadWidth;
			eRRoadType.roadShape = new List<Vector2>(roadType.roadShape);
			eRRoadType.doConnectionTri = new List<bool>(roadType.doConnectionTri);
			eRRoadType.roadShapeUVs = new List<float>(roadType.roadShapeUVs);
			eRRoadType.hardEdge = new List<bool>(roadType.hardEdge);
			eRRoadType.sidewalks = roadType.sidewalks;
			eRRoadType.sidewalkHeight = roadType.sidewalkHeight;
			eRRoadType.sidewalkWidth = roadType.sidewalkWidth;
			eRRoadType.roadMaterial = roadType.roadMaterial;
			eRRoadType.connectionMaterial = roadType.connectionMaterial;
			eRRoadType.terrainDeformation = roadType.terrainDeformation;
			eRRoadType.faceDistance = roadType.faceDistance;
			eRRoadType.isSideObject = roadType.isSideObject;
			eRRoadType.soDataExt = new List<ERSORoadExt>();
			for (int i = 0; i < roadType.soDataExt.Count; i++)
			{
				eRRoadType.soDataExt.Add(ERSORoadExt.CreateInstance(roadType.soDataExt[i].sideObject));
				if (roadType.soDataExt[i].active)
				{
					eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].active = true;
				}
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].markerActive = roadType.soDataExt[i].markerActive;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].autoGenerate = roadType.soDataExt[i].autoGenerate;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].xPosition = roadType.soDataExt[i].xPosition;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].randomMinXPosition = roadType.soDataExt[i].randomMinXPosition;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].randomMaxXPosition = roadType.soDataExt[i].randomMaxXPosition;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].yPosition = roadType.soDataExt[i].yPosition;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].randomMinYPosition = roadType.soDataExt[i].randomMinYPosition;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].randomMaxYPosition = roadType.soDataExt[i].randomMaxYPosition;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].minRandomXPositionDistance = roadType.soDataExt[i].minRandomXPositionDistance;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].maxRandomXPositionDistance = roadType.soDataExt[i].maxRandomXPositionDistance;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].minRandomYPositionDistance = roadType.soDataExt[i].minRandomYPositionDistance;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].maxRandomYPositionDistance = roadType.soDataExt[i].maxRandomYPositionDistance;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].randomMinRotation = roadType.soDataExt[i].randomMinRotation;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].randomMaxRotation = roadType.soDataExt[i].randomMaxRotation;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].minRandomRotationDistance = roadType.soDataExt[i].minRandomRotationDistance;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].maxRandomRotationDistance = roadType.soDataExt[i].maxRandomRotationDistance;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].lockRandomRotations = roadType.soDataExt[i].lockRandomRotations;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].distanceChange = roadType.soDataExt[i].distanceChange;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].xPosChange = roadType.soDataExt[i].xPosChange;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].yPosChange = roadType.soDataExt[i].yPosChange;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].rotationAngleChange = roadType.soDataExt[i].rotationAngleChange;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].rotationDistanceChange = roadType.soDataExt[i].rotationDistanceChange;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].randomXPositionChange = roadType.soDataExt[i].randomXPositionChange;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].xPositionDistanceChange = roadType.soDataExt[i].xPositionDistanceChange;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].yPositionDistanceChange = roadType.soDataExt[i].yPositionDistanceChange;
				eRRoadType.soDataExt[eRRoadType.soDataExt.Count - 1].randomXPositionChange = roadType.soDataExt[i].randomXPositionChange;
			}
			return eRRoadType;
		}
		return null;
	}

	public string GetNewRoadName(double id)
	{
		string roadNameByID = GetRoadNameByID(id);
		if (roadNameByID == "new road")
		{
			Transform transform = base.transform.Find("Road Objects");
			if (transform != null)
			{
				return "new road " + (transform.childCount + 1);
			}
			return "new road";
		}
		ERModularRoad[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERModularRoad)) as ERModularRoad[];
		int num = 1;
		ERModularRoad[] array2 = array;
		foreach (ERModularRoad eRModularRoad in array2)
		{
			if (eRModularRoad.roadType == id)
			{
				num++;
			}
		}
		if (num < 1000)
		{
			return roadNameByID + " 00" + num;
		}
		if (num < 100)
		{
			return roadNameByID + " 0" + num;
		}
		return roadNameByID + " " + num;
	}

	public string GetRoadNameByID(double id)
	{
		foreach (QDQDOOQQDQODD roadType in roadTypes)
		{
			if (roadType.id == id)
			{
				return roadType.roadTypeName;
			}
		}
		return "new road";
	}

	public SideObject OQCDCQCDCQ(string name)
	{
		foreach (SideObject item in QOQDQOOQDDQOOQ)
		{
			if (item.name == name)
			{
				return item;
			}
		}
		return null;
	}

	public void InitLoadImage(string url)
	{
		StartCoroutine(LoadImage(url));
	}

	private IEnumerator LoadImage(string url)
	{
		tex = new Texture2D(750, 200, TextureFormat.DXT1, mipChain: false);
		WWW wWW = new WWW(url);
		yield return wWW;
		infoTexture = wWW.texture;
	}

	public IEnumerator BuildTerrainRoutine(ERRoadNetwork roadNetwork)
	{
		roadNetwork.BuildRoadNetwork();
		UnityEngine.Debug.Log("done");
		yield return null;
	}

	public float OCCQDCCCOD(Vector3 fwd, Vector3 targetDir, Vector3 up)
	{
		Vector3 lhs = Vector3.Cross(fwd, targetDir);
		float num = Vector3.Dot(lhs, up);
		if ((double)num > 0.0)
		{
			return 1f;
		}
		if ((double)num < 0.0)
		{
			return -1f;
		}
		return 0f;
	}
}
[Serializable]
public struct ERRoadShape
{
	public List<Vector2> nodes;

	public List<bool> hardEdge;

	public int priorityNodeIndexLeft;

	public int priorityNodeIndexRight;

	public List<Vector3> nodesV3;

	public List<ERLane> lanes;

	public int leftLanes;

	public int rightLanes;

	public bool symmetrical;

	public float leftSidewalkOffset;

	public float rightSidewalkOffset;

	public int outerLaneMarkingLeftIndex;

	public bool includeOuterlaneLeftInShape;

	public bool includeOuterlaneRightInShape;

	public int outerLaneMarkingRightIndex;

	public int outerOuterLaneMarkingLeftIndex;

	public int outerOuterLaneMarkingRightIndex;

	public int selectedNode;

	public int selectedLaneNode;

	public int isSymmetrical;

	public bool isset;

	public ERRoadShape(float width)
	{
		nodes = new List<Vector2>();
		nodes.Add(new Vector2((0f - width) * 0.5f, 0f));
		nodes.Add(new Vector2(width * 0.5f, 0f));
		hardEdge = new List<bool> { false, false };
		symmetrical = true;
		leftSidewalkOffset = 0f;
		rightSidewalkOffset = 0f;
		selectedNode = (selectedLaneNode = 0);
		lanes = new List<ERLane>();
		nodesV3 = new List<Vector3>();
		priorityNodeIndexLeft = 0;
		priorityNodeIndexRight = 1;
		outerLaneMarkingLeftIndex = -1;
		outerLaneMarkingRightIndex = -1;
		outerOuterLaneMarkingLeftIndex = -1;
		outerOuterLaneMarkingRightIndex = -1;
		includeOuterlaneLeftInShape = false;
		includeOuterlaneRightInShape = false;
		leftLanes = -1;
		rightLanes = -1;
		isSymmetrical = 0;
		isset = true;
	}

	public void OCCQQDOQOD(List<Vector2> _nodes)
	{
		nodes = new List<Vector2>(_nodes);
	}

	public void Copy(ERRoadShape shape)
	{
		nodes = new List<Vector2>(shape.nodes);
		hardEdge = new List<bool>(shape.hardEdge);
		symmetrical = shape.symmetrical;
		leftSidewalkOffset = shape.leftSidewalkOffset;
		rightSidewalkOffset = shape.rightSidewalkOffset;
		selectedNode = (selectedLaneNode = 0);
		lanes.Clear();
		foreach (ERLane lane in shape.lanes)
		{
			lanes.Add(new ERLane(lane));
		}
		nodesV3 = new List<Vector3>(shape.nodesV3);
		priorityNodeIndexLeft = shape.priorityNodeIndexLeft;
		priorityNodeIndexRight = shape.priorityNodeIndexRight;
		outerLaneMarkingLeftIndex = shape.outerLaneMarkingLeftIndex;
		includeOuterlaneLeftInShape = shape.includeOuterlaneLeftInShape;
		includeOuterlaneRightInShape = shape.includeOuterlaneRightInShape;
		outerLaneMarkingRightIndex = shape.outerLaneMarkingRightIndex;
		outerOuterLaneMarkingLeftIndex = shape.outerOuterLaneMarkingLeftIndex;
		outerOuterLaneMarkingRightIndex = shape.outerOuterLaneMarkingRightIndex;
		isSymmetrical = shape.isSymmetrical;
		leftLanes = shape.leftLanes;
		rightLanes = shape.rightLanes;
		isset = true;
	}

	public void IsSymmetrical()
	{
		float num = Mathf.Floor((float)nodes.Count * 0.5f);
		isSymmetrical = 2;
		for (int i = 0; (float)i < num; i++)
		{
			Vector2 vector = nodes[nodes.Count - 1 - i];
			vector.x *= -1f;
			if (nodes[i] != vector)
			{
				isSymmetrical = 1;
				break;
			}
		}
	}
}
[AddComponentMenu("")]
public class ODCCODOCQQ : MonoBehaviour
{
	public static GameObject rtg;

	public static GameObject swgLeft;

	public static GameObject swgRight;

	public static Vector3 camdir;

	public static List<List<Vector3>> vecs = new List<List<Vector3>>();

	public static void OODDQCQQDQ(ERModularBase baseScript, ERModularRoad scr)
	{
		LODGroup lODGroup = null;
		lODGroup = ((!(scr.gameObject.GetComponent<LODGroup>() == null)) ? scr.gameObject.GetComponent<LODGroup>() : scr.gameObject.AddComponent<LODGroup>());
		ERModularRoad[] array = (ERModularRoad[])UnityEngine.Object.FindObjectsOfType(typeof(ERModularRoad));
		LOD[] array2 = new LOD[baseScript.LODLevelValues.Count];
		for (int i = 0; i < baseScript.LODLevelValues.Count; i++)
		{
			Transform transform = scr.transform.Find("LOD " + i);
			array2[i] = new LOD(renderers: new Renderer[1] { transform.gameObject.GetComponent<Renderer>() }, screenRelativeTransitionHeight: baseScript.LODLevelValues[i]);
		}
		lODGroup.SetLODs(array2);
		lODGroup.RecalculateBounds();
		if ((bool)scr.GetComponent<MeshRenderer>())
		{
			scr.GetComponent<MeshRenderer>().enabled = false;
		}
		if ((bool)scr.GetComponent<MeshCollider>())
		{
			scr.GetComponent<MeshCollider>().enabled = false;
		}
	}

	public static void CleanMeshData(Mesh m, List<List<int>> mtris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<Vector2> uvs2, ref List<Vector3> normals, ref List<Vector4> tangents, ref List<Color> colors, ref List<List<int>> tris)
	{
		int[] array = new int[m.vertices.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = -1;
		}
		int num = 0;
		foreach (List<int> mtri in mtris)
		{
			tris.Add(new List<int>());
			for (int j = 0; j < mtri.Count; j++)
			{
				if (array.Length <= mtri[j])
				{
					continue;
				}
				if (array[mtri[j]] == -1)
				{
					vecs.Add(m.vertices[mtri[j]]);
					uvs.Add(m.uv[mtri[j]]);
					if (m.uv2.Length == 0)
					{
						uvs2.Add(m.uv[mtri[j]]);
					}
					else
					{
						uvs2.Add(m.uv2[mtri[j]]);
					}
					normals.Add(m.normals[mtri[j]]);
					tangents.Add(m.tangents[mtri[j]]);
					colors.Add(m.colors[mtri[j]]);
					array[mtri[j]] = vecs.Count - 1;
					tris[num].Add(vecs.Count - 1);
				}
				else
				{
					tris[num].Add(array[mtri[j]]);
				}
			}
			num++;
		}
	}

	public static void OCDCQCOQQO(Mesh mesh)
	{
		int[] triangles = mesh.triangles;
		Vector3[] vertices = mesh.vertices;
		Vector2[] array = mesh.uv;
		Vector3[] normals = mesh.normals;
		if (array == null)
		{
			array = new Vector2[vertices.Length];
		}
		if (array.Length != vertices.Length)
		{
			array = new Vector2[vertices.Length];
		}
		int num = triangles.Length;
		int num2 = vertices.Length;
		Vector3[] array2 = new Vector3[num2];
		Vector3[] array3 = new Vector3[num2];
		Vector4[] array4 = new Vector4[num2];
		for (long num3 = 0L; num3 < num; num3 += 3)
		{
			long num4 = triangles[num3];
			long num5 = triangles[num3 + 1];
			long num6 = triangles[num3 + 2];
			Vector3 vector = vertices[num4];
			Vector3 vector2 = vertices[num5];
			Vector3 vector3 = vertices[num6];
			Vector2 vector4 = array[num4];
			Vector2 vector5 = array[num5];
			Vector2 vector6 = array[num6];
			float num7 = vector2.x - vector.x;
			float num8 = vector3.x - vector.x;
			float num9 = vector2.y - vector.y;
			float num10 = vector3.y - vector.y;
			float num11 = vector2.z - vector.z;
			float num12 = vector3.z - vector.z;
			float num13 = vector5.x - vector4.x;
			float num14 = vector6.x - vector4.x;
			float num15 = vector5.y - vector4.y;
			float num16 = vector6.y - vector4.y;
			float num17 = 1f / (num13 * num16 - num14 * num15);
			Vector3 vector7 = new Vector3((num16 * num7 - num15 * num8) * num17, (num16 * num9 - num15 * num10) * num17, (num16 * num11 - num15 * num12) * num17);
			Vector3 vector8 = new Vector3((num13 * num8 - num14 * num7) * num17, (num13 * num10 - num14 * num9) * num17, (num13 * num12 - num14 * num11) * num17);
			array2[num4] += vector7;
			array2[num5] += vector7;
			array2[num6] += vector7;
			array3[num4] += vector8;
			array3[num5] += vector8;
			array3[num6] += vector8;
		}
		for (long num18 = 0L; num18 < num2; num18++)
		{
			Vector3 normal = normals[num18];
			Vector3 tangent = array2[num18];
			Vector3.OrthoNormalize(ref normal, ref tangent);
			array4[num18].x = tangent.x;
			array4[num18].y = tangent.y;
			array4[num18].z = tangent.z;
			array4[num18].w = ((Vector3.Dot(Vector3.Cross(normal, tangent), array3[num18]) < 0f) ? (-1f) : 1f);
		}
		mesh.tangents = array4;
	}

	public static void OOCQQCOQQC(Mesh mesh)
	{
		Vector2[] array = (Vector2[])mesh.uv.Clone();
		float y = array[^1].y;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].y = array[i].y / y;
		}
		mesh.uv2 = array;
	}

	public static void GenerateWaypoints(ERModularRoad scr, float distance)
	{
		for (int i = 0; i < scr.transform.childCount; i++)
		{
			GameObject gameObject = scr.transform.GetChild(i).gameObject;
			if (gameObject.name.IndexOf("Waypoint") != -1)
			{
				UnityEngine.Object.DestroyImmediate(gameObject);
				i--;
			}
		}
		float num = 0f;
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0f;
		int num5 = 1;
		GameObject gameObject2;
		for (int j = 1; j < scr.soSplinePoints.Count; j++)
		{
			num2 = Vector3.Distance(scr.soSplinePoints[j - 1], scr.soSplinePoints[j]);
			if (j == 1)
			{
				gameObject2 = new GameObject("Waypoint " + num5);
				gameObject2.transform.parent = scr.transform;
				gameObject2.transform.position = scr.soSplinePoints[0];
				num5++;
			}
			if (num + num2 > distance)
			{
				num3 = num + num2 - distance;
				num4 = num3 / num2;
				Vector3 position = Vector3.Lerp(scr.soSplinePoints[j - 1], scr.soSplinePoints[j], num4);
				gameObject2 = new GameObject("Waypoint " + num5);
				gameObject2.transform.parent = scr.transform;
				gameObject2.transform.position = position;
				num = num2 - num3;
				num5++;
			}
			else
			{
				num += num2;
			}
		}
		gameObject2 = new GameObject("Waypoint " + num5);
		gameObject2.transform.parent = scr.transform;
		gameObject2.transform.position = scr.soSplinePoints[scr.soSplinePoints.Count - 1];
		UnityEngine.Debug.Log(num5 + " waypoint created as child objects of the selected road");
	}

	public static void OOQDCQODOD(List<SelectedObject> selectedObjects, int alignType)
	{
		if (selectedObjects.Count == 0 || (selectedObjects[0].markers.Count < 2 && selectedObjects.Count == 1))
		{
			return;
		}
		if (selectedObjects.Count == 1)
		{
			List<int> list = new List<int>();
			list.Add(selectedObjects[0].markers[0]);
			selectedObjects[0].markers.RemoveAt(0);
			bool flag = false;
			int num;
			for (num = 0; num < selectedObjects[0].markers.Count; num++)
			{
				flag = false;
				for (int i = 0; i < list.Count; i++)
				{
					if (selectedObjects[0].markers[num] < list[i])
					{
						list.Insert(i, selectedObjects[0].markers[num]);
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					list.Add(selectedObjects[0].markers[num]);
				}
				selectedObjects[0].markers.RemoveAt(num);
				num--;
			}
			ERModularRoad roadScr = selectedObjects[0].roadScr;
			for (int j = 0; j < list.Count; j++)
			{
				if (list[j] >= roadScr.markersExt.Count)
				{
					list.RemoveAt(j);
					j--;
				}
			}
			if (alignType == 0 || alignType == 1)
			{
				Vector3 position = roadScr.markersExt[list[0]].position;
				Vector3 position2 = roadScr.markersExt[list[list.Count - 1]].position;
				for (int k = list[0] + 1; k < list[list.Count - 1]; k++)
				{
					Vector3 position3 = roadScr.markersExt[k].position;
					position3 = ODQDQDQDQO.OQQCQOCCOQ(position, position2, position3);
					if (alignType == 1)
					{
						roadScr.baseScript.OCDDQOCDCO(ref position3);
					}
					roadScr.markersExt[k].position = position3;
				}
			}
			else if (alignType == 2)
			{
				float num2 = 0f;
				for (int l = list[0]; l < list[list.Count - 1]; l++)
				{
					num2 += roadScr.markersExt[l].totalDistance;
				}
				float y = roadScr.markersExt[list[0]].position.y;
				float y2 = roadScr.markersExt[list[list.Count - 1]].position.y;
				float num3 = 0f;
				for (int m = list[0]; m < list[list.Count - 1]; m++)
				{
					roadScr.markersExt[m].position.y = Mathf.Lerp(y, y2, num3 / num2);
					num3 += roadScr.markersExt[m].totalDistance;
				}
			}
			return;
		}
		if (alignType == 0 || alignType == 1)
		{
			Vector3 position4 = selectedObjects[0].roadScr.markersExt[selectedObjects[0].markers[0]].position;
			Vector3 position5 = selectedObjects[1].roadScr.markersExt[selectedObjects[1].markers[0]].position;
			int num4 = 1;
			if (selectedObjects[0].startEnd == 0)
			{
				num4 = -1;
			}
			int num5 = selectedObjects[0].markers[0];
			int count = selectedObjects[0].roadScr.markersExt.Count;
			for (int n = num5; n >= 0 && n < count; n += num4)
			{
				Vector3 position6 = selectedObjects[0].roadScr.markersExt[n].position;
				position6 = ODQDQDQDQO.OQQCQOCCOQ(position4, position5, position6);
				if (alignType == 1)
				{
					selectedObjects[0].roadScr.baseScript.OCDDQOCDCO(ref position6);
				}
				selectedObjects[0].roadScr.markersExt[n].position = position6;
			}
			num4 = 1;
			if (selectedObjects[1].startEnd == 0)
			{
				num4 = -1;
			}
			num5 = selectedObjects[1].markers[0];
			count = selectedObjects[1].roadScr.markersExt.Count;
			for (int num6 = num5; num6 >= 0 && num6 < count; num6 += num4)
			{
				Vector3 position6 = selectedObjects[1].roadScr.markersExt[num6].position;
				position6 = ODQDQDQDQO.OQQCQOCCOQ(position4, position5, position6);
				if (alignType == 1)
				{
					selectedObjects[1].roadScr.baseScript.OCDDQOCDCO(ref position6);
				}
				selectedObjects[1].roadScr.markersExt[num6].position = position6;
			}
			ERCrossingPrefabs eRCrossingPrefabs = null;
			if (selectedObjects[0].startEnd == 0)
			{
				eRCrossingPrefabs = selectedObjects[0].roadScr.startPrefabScript;
			}
			else if (selectedObjects[0].startEnd == 1)
			{
				eRCrossingPrefabs = selectedObjects[0].roadScr.endPrefabScript;
			}
			if (eRCrossingPrefabs != null)
			{
				Vector3 position6 = eRCrossingPrefabs.transform.position;
				position6 = ODQDQDQDQO.OQQCQOCCOQ(position4, position5, position6);
				if (alignType == 1)
				{
					selectedObjects[0].roadScr.baseScript.OCDDQOCDCO(ref position6);
				}
				eRCrossingPrefabs.transform.position = position6;
			}
			return;
		}
		float y3 = selectedObjects[0].roadScr.markersExt[selectedObjects[0].markers[0]].position.y;
		float y4 = selectedObjects[1].roadScr.markersExt[selectedObjects[1].markers[0]].position.y;
		float num7 = 0f;
		float num8 = 0f;
		int num9 = 1;
		if (selectedObjects[0].startEnd == 0)
		{
			num9 = -1;
		}
		int num10 = selectedObjects[0].markers[0];
		if (num9 == -1)
		{
			num10--;
		}
		int count2 = selectedObjects[0].roadScr.markersExt.Count;
		for (int num11 = num10; num11 >= 0 && num11 < count2; num11 += num9)
		{
			num8 += selectedObjects[0].roadScr.markersExt[num11].totalDistance;
		}
		num9 = 1;
		if (selectedObjects[1].startEnd == 0)
		{
			num9 = -1;
		}
		num10 = selectedObjects[1].markers[0];
		if (num9 == -1)
		{
			num10--;
		}
		count2 = selectedObjects[1].roadScr.markersExt.Count;
		for (int num12 = num10; num12 >= 0 && num12 < count2; num12 += num9)
		{
			num8 += selectedObjects[0].roadScr.markersExt[num12].totalDistance;
		}
		UnityEngine.Debug.Log("To Do: we have to add distances to I Connector ");
		num9 = 1;
		if (selectedObjects[0].startEnd == 0)
		{
			num9 = -1;
		}
		num10 = selectedObjects[0].markers[0];
		if (num9 == -1)
		{
			num10--;
		}
		count2 = selectedObjects[0].roadScr.markersExt.Count;
		num7 += selectedObjects[0].roadScr.markersExt[num10].totalDistance;
		for (int num13 = num10; num13 >= 0 && num13 < count2; num13 += num9)
		{
			selectedObjects[0].roadScr.markersExt[num13].position.y = Mathf.Lerp(y3, y4, num7 / num8);
			num7 += selectedObjects[0].roadScr.markersExt[num13].totalDistance;
		}
		int num14 = 0;
		num9 = 1;
		if (selectedObjects[1].startEnd == 0)
		{
			num14 = selectedObjects[1].roadScr.markersExt.Count - 1;
			num9 = -1;
		}
		for (int num15 = num14; num15 >= 0 && num15 < count2; num15 += num9)
		{
			selectedObjects[1].roadScr.markersExt[num15].position.y = Mathf.Lerp(y3, y4, num7 / num8);
			if (num15 > 0 && num15 < selectedObjects[1].roadScr.markersExt.Count - 1)
			{
				num7 += selectedObjects[1].roadScr.markersExt[num15 + num9].totalDistance;
			}
		}
	}

	public static void OOCDQDQDCQ(GameObject go, SideObject so, List<Vector3> vecs, List<Vector2> uvs, List<Vector2> uvs1, List<Color> color, List<Vector4> tangents, List<int> triangles, List<Vector3> normals, List<int> normalArray1, List<int> normalArray2)
	{
		Mesh mesh = null;
		mesh.Clear();
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();
		List<Vector3> list = new List<Vector3>(mesh.normals);
		for (int i = 0; i < normalArray1.Count; i++)
		{
			int index = normalArray1[i];
			Vector3 value = (list[normalArray2[i]] = (mesh.normals[normalArray1[i]] + mesh.normals[normalArray2[i]]) * 0.5f);
			list[index] = value;
		}
		if (list.Count == mesh.normals.Length)
		{
			mesh.normals = list.ToArray();
		}
		if (so.collider)
		{
			if ((bool)go.GetComponent<MeshCollider>())
			{
				go.GetComponent<MeshCollider>().sharedMesh = null;
			}
			else
			{
				go.AddComponent<MeshCollider>();
			}
			go.GetComponent<MeshCollider>().sharedMesh = mesh;
		}
	}

	public static void GetRoadShape(float width, int subSegments, ref List<Vector2> roadShape, ref List<float> uvs, ref List<float> uvs1, float dir)
	{
		float num = width / ((float)subSegments * dir);
		float num2 = (0f - width) * 0.5f * dir;
		roadShape.Clear();
		uvs.Clear();
		uvs1.Clear();
		for (int i = 0; i <= subSegments; i++)
		{
			roadShape.Add(new Vector2(num2 + (float)i * num, 0f));
			uvs.Add((float)i / ((float)subSegments * 1f));
			uvs1.Add((float)i / ((float)subSegments * 1f));
		}
	}

	public static void GetRoadShape(float oldWidth, QDQDOOQQDQODD roadType, float dir)
	{
		float num = roadType.roadWidth / oldWidth;
		if (roadType.roadShape.Count > 0 && roadType.roadShapeExt2.Count > 0)
		{
			for (int i = 0; i < roadType.roadShape.Count; i++)
			{
				Vector2 value = roadType.roadShape[i];
				value.x *= num;
				roadType.roadShape[i] = value;
			}
			if (roadType.roadShapeExt2.Count == 0)
			{
				RebuildMainRoadShape(roadType);
				return;
			}
			for (int j = 0; j < roadType.roadShapeExt2.Count; j++)
			{
				Vector2 value2 = roadType.roadShapeExt2[j];
				value2.x *= num;
				roadType.roadShapeExt2[j] = value2;
				roadType.roadShapeData.nodes[j] = value2;
			}
		}
		else
		{
			GetRoadShape(roadType.roadWidth, roadType.subSegments, ref roadType.roadShape, ref roadType.roadShapeUVs, ref roadType.roadShapeUVs2, -1f);
		}
	}

	public static void UpdateRoadType(ERModularBase scr, int index)
	{
		UpdateRoadTypeByRoad(scr, scr.OCCQOOOQQO, index, null);
	}

	public static bool UpdateRoadTypeByRoad(ERModularBase scr, ERModularRoad road, int index, QDQDOOQQDQODD type)
	{
		if (index == 0)
		{
			road.roadType = 0.0;
			return false;
		}
		if (type == null)
		{
			type = scr.roadTypes[index - 1];
		}
		road.faceDistance = type.faceDistance;
		road.roadWidth = type.roadWidth;
		road.subSegments = type.subSegments;
		if (road.subSegments == 0)
		{
			road.subSegments = 1;
		}
		road.uvTiling = type.uvTiling;
		road.planarUVs = type.planarUVs;
		road.roadMaterial = type.roadMaterial;
		road.roadMaterials = type.roadMaterials;
		road.isSideObject = type.isSideObject;
		int layer = (road.gameObject.layer = type.layer);
		road.layer = layer;
		if (!string.IsNullOrEmpty(type.tag))
		{
			string text = (road.gameObject.tag = type.tag);
			road.tag = text;
		}
		road.castShadow = type.castShadow;
		road.splatMapActive = type.splatMapActive;
		road.splatIndex = type.splatIndex;
		road.expandLevel = type.expandLevel;
		road.smoothLevel = type.smoothLevel;
		road.splatOpacity = type.splatOpacity;
		road.angleTreshold = type.angleTreshold;
		road.isCustomRoad = type.isCustomRoad;
		road.followTerrainContours = type.followTerrainContours;
		road.terrainContoursOffset = type.terrainContoursOffset;
		road.roadShape = new List<Vector2>(type.roadShape);
		road.doConnectionTri = new List<bool>(type.doConnectionTri);
		road.roadShapeUVs = new List<float>(type.roadShapeUVs);
		road.roadShapeUVs2 = new List<float>(type.roadShapeUVs2);
		if (road.roadShape.Count > 0 && road.roadShape[0].x <= road.roadShape[road.roadShape.Count - 1].x)
		{
			road.roadShape.Reverse();
		}
		road.roadShapeMatchCount = OCDQQQDDQO(road.roadShape);
		if (road.roadShapeUVs.Count == 0)
		{
			road.roadShapeUVs.Clear();
			road.roadShapeUVs.Add(0f);
			road.roadShapeUVs.Add(1f);
		}
		foreach (ERMarkerExt item in road.markersExt)
		{
			item.roadShape = new List<Vector2>(road.roadShape);
			item.followTerrainContours = road.followTerrainContours;
		}
		if (road.startPrefabScript != null)
		{
			QDOODOQQDQODD qDOODOQQDQODD = null;
			if (road.startPrefabScript != null && !road.startPrefabScript.isIConnector)
			{
				qDOODOQQDQODD = road.startPrefabScript.crossingElements[road.startConnectionSegment];
			}
			if (qDOODOQQDQODD != null && !road.startPrefabScript.isFlexConnector)
			{
				Vector3 localScale = road.startPrefabScript.transform.localScale;
				if (type.id != qDOODOQQDQODD.roadType || localScale != new Vector3(1f, 1f, 1f))
				{
					List<Vector2> list = new List<Vector2>(qDOODOQQDQODD.roadShapeVecs);
					if (road.roadShape[0].x > 0f)
					{
						list.Reverse();
					}
					for (int i = 0; i < list.Count; i++)
					{
						list[i] = new Vector2(list[i].x * localScale.x, list[i].y * localScale.y);
					}
					road.markersExt[0].roadShape = list;
					road.markersExt[0].roadShapeDistanceMin = 0f;
					road.markersExt[0].roadShapeDistanceMax = 0.3f;
				}
			}
		}
		if (road.endPrefabScript != null)
		{
			QDOODOQQDQODD qDOODOQQDQODD2 = null;
			if (road.endPrefabScript != null && !road.endPrefabScript.isIConnector)
			{
				qDOODOQQDQODD2 = road.endPrefabScript.crossingElements[road.endConnectionSegment];
			}
			if (qDOODOQQDQODD2 != null && !road.endPrefabScript.isFlexConnector)
			{
				Vector3 localScale2 = road.endPrefabScript.transform.localScale;
				if ((type.id != qDOODOQQDQODD2.roadType && road.roadType != 0.0) || localScale2 != new Vector3(1f, 1f, 1f))
				{
					List<Vector2> list2 = new List<Vector2>(qDOODOQQDQODD2.roadShapeVecs);
					if (road.roadShape[0].x > 0f)
					{
						list2.Reverse();
					}
					for (int j = 0; j < list2.Count; j++)
					{
						list2[j] = new Vector2(list2[j].x * localScale2.x, list2[j].y * localScale2.y);
					}
					road.markersExt[road.markersExt.Count - 1].roadShape = list2;
					road.markersExt[road.markersExt.Count - 1].roadShapeDistanceMin = 0.7f;
					road.markersExt[road.markersExt.Count - 1].roadShapeDistanceMax = 1f;
					road.markersExt[road.markersExt.Count - 2].roadShapeDistanceMin = 0.7f;
					road.markersExt[road.markersExt.Count - 2].roadShapeDistanceMax = 1f;
				}
			}
		}
		road.hardEdge = new List<bool>(type.hardEdge);
		road.terrainDeformation = type.terrainDeformation;
		GameObject gameObject = road.gameObject;
		gameObject.GetComponent<MeshRenderer>().sharedMaterial = type.roadMaterial;
		if (type.castShadow)
		{
			gameObject.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.On;
		}
		else
		{
			gameObject.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.Off;
		}
		gameObject.layer = type.layer;
		road.roadType = type.id;
		road.roadMaterials = new Material[1];
		road.roadMaterials[0] = type.roadMaterial;
		road.ODQCQCDCDQ(type.decalPresets);
		if (type.isSideObject)
		{
			if ((bool)gameObject.GetComponent<MeshRenderer>())
			{
				UnityEngine.Object.DestroyImmediate(gameObject.GetComponent<MeshRenderer>());
			}
			if ((bool)gameObject.GetComponent<MeshCollider>())
			{
				UnityEngine.Object.DestroyImmediate(gameObject.GetComponent<MeshCollider>());
			}
			if ((bool)gameObject.GetComponent<MeshFilter>())
			{
				UnityEngine.Object.DestroyImmediate(gameObject.GetComponent<MeshFilter>());
			}
			if (road.surfaceMesh != null)
			{
				UnityEngine.Object.DestroyImmediate(road.surfaceMesh);
			}
			road.snapToTerrain = true;
		}
		else
		{
			road.snapToTerrain = false;
		}
		return true;
	}

	public static int OCDQQQDDQO(List<Vector2> roadShape)
	{
		int num = 1;
		for (int i = 1; i < roadShape.Count; i++)
		{
			if ((double)Vector2.Distance(roadShape[i - 1], roadShape[i]) > 0.01)
			{
				num++;
			}
		}
		return num;
	}

	public static void OCDQCDQQDD(ref List<ERMarkerExt> tmpMarkersExt)
	{
		for (int i = 0; i < tmpMarkersExt.Count; i++)
		{
			if (tmpMarkersExt[i].controlType == 3 && tmpMarkersExt.Count > i + 2)
			{
				Vector3 position = tmpMarkersExt[i].position;
				Vector3 position2 = tmpMarkersExt[i + 1].position;
				Vector3 position3 = tmpMarkersExt[i + 2].position;
				position2.y = (position3.y = position.y);
				float num = Vector3.Distance(position, position2);
				float num2 = Vector3.Distance(position, position2);
				Vector3 normalized = (position2 - position).normalized;
				Vector3 normalized2 = (position2 - position3).normalized;
				float num3 = Vector3.Angle(normalized, normalized2);
			}
		}
	}

	public static void ODOCDOQDDQ(QDQDOOQQDQODD roadType)
	{
		if (roadType.roadShapeData.symmetrical)
		{
			List<Vector2> nodes = roadType.roadShapeData.nodes;
			int selectedNode = roadType.roadShapeData.selectedNode;
			Vector2 value = roadType.roadShapeData.nodes[selectedNode];
			if (value.y < -0.05f)
			{
				value.y = -0.05f;
				roadType.roadShapeData.nodes[selectedNode] = value;
			}
			value.x = 0f - roadType.roadShapeData.nodes[selectedNode].x;
			if (selectedNode != nodes.Count - selectedNode - 1)
			{
				roadType.roadShapeData.nodes[nodes.Count - selectedNode - 1] = value;
			}
		}
		int count = roadType.roadShapeExt2.Count;
		roadType.roadShapeExt2 = new List<Vector2>(roadType.roadShapeData.nodes);
		if (count != roadType.roadShapeExt2.Count || !roadType.preserveUVs)
		{
			roadType.roadShapeExtUVs2 = ODQDQDQDQO.OCOCDCOQCD(roadType.roadShapeData.nodes);
		}
		roadType.roadShapeData.IsSymmetrical();
		RebuildMainRoadShape(roadType);
	}

	public static void RebuildMainRoadShape(QDQDOOQQDQODD roadType)
	{
		int outerLaneMarkingLeftIndex = roadType.roadShapeData.outerLaneMarkingLeftIndex;
		int outerLaneMarkingRightIndex = roadType.roadShapeData.outerLaneMarkingRightIndex;
		bool includeOuterlaneLeftInShape = roadType.roadShapeData.includeOuterlaneLeftInShape;
		bool includeOuterlaneRightInShape = roadType.roadShapeData.includeOuterlaneRightInShape;
		int outerOuterLaneMarkingLeftIndex = roadType.roadShapeData.outerOuterLaneMarkingLeftIndex;
		int outerOuterLaneMarkingRightIndex = roadType.roadShapeData.outerOuterLaneMarkingRightIndex;
		roadType.roadShape.Clear();
		roadType.roadShapeUVs.Clear();
		roadType.hardEdge.Clear();
		roadType.doConnectionTri.Clear();
		roadType.doConnectionTriExt.Clear();
		for (int i = 0; i < roadType.roadShapeExt2.Count; i++)
		{
			roadType.doConnectionTriExt.Add(item: true);
			if (i == 0 || i == roadType.roadShapeExt2.Count - 1 || ((i != outerLaneMarkingLeftIndex || includeOuterlaneLeftInShape) && (i != outerLaneMarkingRightIndex || includeOuterlaneRightInShape) && i != outerOuterLaneMarkingLeftIndex && i != outerOuterLaneMarkingRightIndex))
			{
				roadType.roadShape.Add(roadType.roadShapeExt2[i]);
				roadType.roadShapeUVs.Add(roadType.roadShapeExtUVs2[i]);
				roadType.hardEdge.Add(roadType.roadShapeData.hardEdge[i]);
				roadType.doConnectionTri.Add(roadType.doConnectionTriExt[i]);
			}
		}
		Vector2 a = roadType.roadShape[0];
		a.y = 0f;
		Vector2 b = roadType.roadShape[roadType.roadShape.Count - 1];
		b.y = 0f;
		roadType.roadWidth = Vector2.Distance(a, b);
	}

	public static void OQDCDQDCQC(QDQDOOQQDQODD roadType, ref List<Vector2> roadShape, ref List<float> roadShapeUVs, ref List<bool> doConnectionTri, ref List<bool> hardEdge, ref int currentMostLeftInt, ref int currentMostRightInt, ref int sectionRoadShapeCols, int leftright, int lineIndexTarget, bool transition, List<Vector2> origRoadShape)
	{
		if (roadType == null)
		{
			return;
		}
		int outerLaneMarkingLeftIndex = roadType.roadShapeData.outerLaneMarkingLeftIndex;
		int outerLaneMarkingRightIndex = roadType.roadShapeData.outerLaneMarkingRightIndex;
		bool flag = roadType.roadShapeData.includeOuterlaneLeftInShape;
		bool flag2 = roadType.roadShapeData.includeOuterlaneRightInShape;
		int outerOuterLaneMarkingLeftIndex = roadType.roadShapeData.outerOuterLaneMarkingLeftIndex;
		int outerOuterLaneMarkingRightIndex = roadType.roadShapeData.outerOuterLaneMarkingRightIndex;
		bool flag3 = false;
		bool flag4 = false;
		int num = 0;
		int num2 = roadType.roadShapeExt2.Count - 1;
		roadShape.Clear();
		roadShapeUVs.Clear();
		hardEdge.Clear();
		doConnectionTri.Clear();
		if (roadType.roadShapeExt2 == null || roadType.roadShapeExt2.Count < 2)
		{
			UnityEngine.Debug.Log("EasyRoads3Dv3: Road type " + roadType.roadTypeName + ", missing road shape data");
			return;
		}
		bool flag5 = false;
		if (origRoadShape.Count > 0 && origRoadShape[0].x > origRoadShape[origRoadShape.Count - 1].x)
		{
			flag5 = true;
		}
		if (!flag5)
		{
			if (leftright == 0)
			{
				if (lineIndexTarget == 0 || (transition && lineIndexTarget != 2))
				{
					flag = true;
				}
				if (lineIndexTarget == 1)
				{
					num = outerOuterLaneMarkingLeftIndex;
					flag3 = true;
				}
				if (lineIndexTarget == 2)
				{
					flag3 = true;
				}
			}
			else
			{
				if (lineIndexTarget == 0 || (transition && lineIndexTarget != 2))
				{
					flag2 = true;
				}
				if (lineIndexTarget == 1)
				{
					flag4 = true;
					num2 = outerOuterLaneMarkingRightIndex;
				}
				if (lineIndexTarget == 2)
				{
					flag4 = true;
				}
			}
		}
		else if (leftright == 1)
		{
			if (lineIndexTarget == 0 || (transition && lineIndexTarget != 2))
			{
				flag = true;
			}
			if (lineIndexTarget == 1)
			{
				flag3 = true;
				num = outerOuterLaneMarkingLeftIndex;
			}
			if (lineIndexTarget == 2)
			{
				flag3 = true;
			}
		}
		else
		{
			if (lineIndexTarget == 0 || (transition && lineIndexTarget != 2))
			{
				flag2 = true;
			}
			if (lineIndexTarget == 1)
			{
				flag4 = true;
				num2 = outerOuterLaneMarkingRightIndex;
			}
			if (lineIndexTarget == 2)
			{
				flag4 = true;
			}
		}
		for (int i = 0; i < roadType.roadShapeExt2.Count; i++)
		{
			if (!(i != outerLaneMarkingLeftIndex || flag) || !(i != outerLaneMarkingRightIndex || flag2) || !(i != outerOuterLaneMarkingLeftIndex || flag3) || !(i != outerOuterLaneMarkingRightIndex || flag4))
			{
				continue;
			}
			if (!flag5)
			{
				if ((leftright == 0 && (i >= outerLaneMarkingLeftIndex || transition) && i >= num) || (leftright == 1 && (i <= outerLaneMarkingRightIndex || transition) && i <= num2))
				{
					sectionRoadShapeCols++;
					if (roadType.roadShapeData.hardEdge[i])
					{
						sectionRoadShapeCols++;
					}
					roadShape.Add(roadType.roadShapeExt2[i]);
					roadShapeUVs.Add(roadType.roadShapeExtUVs2[i]);
					hardEdge.Add(roadType.roadShapeData.hardEdge[i]);
					doConnectionTri.Add(roadType.doConnectionTriExt[i]);
				}
			}
			else if ((leftright == 0 && (i <= outerLaneMarkingRightIndex || transition || (i == outerOuterLaneMarkingRightIndex && flag4)) && i <= num2) || (leftright == 1 && (i >= outerLaneMarkingLeftIndex || transition || (i == outerOuterLaneMarkingLeftIndex && flag3)) && i >= num))
			{
				sectionRoadShapeCols++;
				if (roadType.roadShapeData.hardEdge[i])
				{
					sectionRoadShapeCols++;
				}
				roadShape.Add(roadType.roadShapeExt2[i]);
				roadShapeUVs.Add(roadType.roadShapeExtUVs2[roadType.roadShapeExt2.Count - i - 1]);
				hardEdge.Add(roadType.roadShapeData.hardEdge[i]);
				doConnectionTri.Add(roadType.doConnectionTriExt[i]);
			}
		}
		if (origRoadShape.Count > 0 && origRoadShape[0].x > origRoadShape[origRoadShape.Count - 1].x)
		{
			roadShape.Reverse();
			roadShapeUVs.Reverse();
			hardEdge.Reverse();
			doConnectionTri.Reverse();
		}
		currentMostLeftInt = 0;
		currentMostRightInt = roadShape.Count - 1;
	}

	public static List<int> OODCQDDQDC(List<Vector2> _rs1, List<bool> _hd1, int cols1, List<Vector2> _rs2, List<bool> _hd2, int cols2, ref List<int> tris, bool flipNormals, int vecCount, int i1, int i2, int last1, int last2)
	{
		List<Vector2> list = new List<Vector2>(_rs1);
		List<bool> list2 = new List<bool>(_hd1);
		List<Vector2> list3 = new List<Vector2>(_rs2);
		List<bool> list4 = new List<bool>(_hd2);
		if (list[0].x > list[list.Count - 1].x)
		{
			list.Reverse();
			list2.Reverse();
			list3.Reverse();
			list4.Reverse();
		}
		int num = vecCount + cols1;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		while (i1 < cols1 && i2 < cols2 && num4 < 10)
		{
			if (i1 < last1 - 2 && list[i1].x == list3[i2].x && i2 < last2 - 2 && list[i1 + 1].x == list3[i2 + 1].x)
			{
				tris.Add(vecCount + i1 + num2);
				tris.Add(num + i2 + num3);
				tris.Add(num + i2 + num3 + 1);
				tris.Add(vecCount + i1 + num2);
				tris.Add(num + i2 + num3 + 1);
				tris.Add(vecCount + i1 + num2 + 1);
				if (i2 < list3.Count)
				{
					i2++;
				}
				if (list2[i1])
				{
					num2++;
				}
				if (list4[i2])
				{
					num3++;
				}
			}
			else if (i1 < last1 - 1 && i2 < last2 - 1 && list3[i2 + 1].x < list[i1 + 1].x)
			{
				tris.Add(vecCount + i1 + num2);
				tris.Add(num + i2 + num3);
				tris.Add(num + i2 + num3 + 1);
				i2++;
				float num5 = list3[i2 + 1].x - list3[i2].x;
				float num6 = list[i1 + 1].x - list[i1].x;
				if (2f * num5 > num6)
				{
					tris.Add(vecCount + num2 + i1);
					tris.Add(num + num3 + i2);
					tris.Add(vecCount + num2 + i1 + 1);
					i1++;
				}
				if (list[i1].x == list3[i2].x)
				{
					if (list2[i1])
					{
						num2++;
					}
					if (list4[i2])
					{
						num3++;
					}
				}
			}
			else if (i1 < last1 - 1 && i2 < last2 - 1 && list[i1 + 1].x < list3[i2 + 1].x)
			{
				tris.Add(vecCount + i1 + num2);
				tris.Add(num + i2 + num3);
				tris.Add(vecCount + i1 + num2 + 1);
				i1++;
				float num7 = list3[i2 + 1].x - list3[i2].x;
				float num8 = list[i1 + 1].x - list[i1].x;
				if (2f * num8 > num7)
				{
					tris.Add(num + num3 + i2);
					tris.Add(num + num3 + i2 + 1);
					tris.Add(vecCount + num2 + i1);
					i2++;
				}
				if (list[i1].x == list3[i2].x)
				{
					if (list2[i1])
					{
						num2++;
					}
					if (list4[i2])
					{
						num3++;
					}
				}
			}
			else if (i1 < last1 && i2 < last2 - 1 && list3[i2].x < list[i1].x)
			{
				tris.Add(vecCount + i1 + num2);
				tris.Add(num + i2 + num3);
				tris.Add(num + i2 + num3 + 1);
				i2++;
				if (list[i1].x == list3[i2].x)
				{
					if (list2[i1])
					{
						num2++;
					}
					if (list4[i2])
					{
						num3++;
					}
				}
			}
			else if (i1 < last1 - 1 && i2 < last2 && list[i1].x < list3[i2].x)
			{
				tris.Add(vecCount + i1 + num2);
				tris.Add(num + i2 + num3);
				tris.Add(vecCount + i1 + num2 + 1);
				i1++;
				if (list[i1].x == list3[i2].x)
				{
					if (list2[i1])
					{
						num2++;
					}
					if (list4[i2])
					{
						num3++;
					}
				}
			}
			num4++;
		}
		return tris;
	}

	public static void OOQCCCDODD(QDQDOOQQDQODD roadType, ref List<Vector2> roadShapeVecs, ref List<float> roadShapeUVs, ref List<bool> hardEdge, ref int rightOuterIndex)
	{
		int outerLaneMarkingLeftIndex = roadType.roadShapeData.outerLaneMarkingLeftIndex;
		int outerLaneMarkingRightIndex = roadType.roadShapeData.outerLaneMarkingRightIndex;
		bool includeOuterlaneLeftInShape = roadType.roadShapeData.includeOuterlaneLeftInShape;
		bool includeOuterlaneRightInShape = roadType.roadShapeData.includeOuterlaneRightInShape;
		int outerOuterLaneMarkingLeftIndex = roadType.roadShapeData.outerOuterLaneMarkingLeftIndex;
		int outerOuterLaneMarkingRightIndex = roadType.roadShapeData.outerOuterLaneMarkingRightIndex;
		roadShapeVecs.Clear();
		roadShapeUVs.Clear();
		hardEdge.Clear();
		for (int i = 0; i < roadType.roadShapeExt2.Count; i++)
		{
			if ((i != outerLaneMarkingLeftIndex || includeOuterlaneLeftInShape) && i != outerOuterLaneMarkingRightIndex)
			{
				roadShapeVecs.Add(roadType.roadShapeExt2[i]);
				roadShapeUVs.Add(roadType.roadShapeExtUVs2[i]);
				hardEdge.Add(roadType.roadShapeData.hardEdge[i]);
				if (i == outerLaneMarkingRightIndex)
				{
					rightOuterIndex = roadShapeVecs.Count - 1;
				}
			}
		}
	}

	public static void VisualizeRoadType(ERModularBase baseScript, GameObject prefab, QDQDOOQQDQODD rt, Vector3 pos, Vector3 dir)
	{
		Transform transform = null;
		if (baseScript != null)
		{
			transform = baseScript.transform.Find("Temp Road Type");
			if (transform == null)
			{
				GameObject gameObject = new GameObject("Temp Road Type");
				transform = gameObject.transform;
				transform.parent = baseScript.transform;
			}
			else
			{
				rtg = GameObject.Find(rt.roadTypeName);
			}
		}
		else
		{
			rtg = prefab;
		}
		if (rtg == null)
		{
			rtg = new GameObject(rt.roadTypeName);
		}
		if (baseScript != null)
		{
			rtg.transform.parent = transform;
			pos.y -= 2f;
		}
		dir.y = 0f;
		camdir = dir.normalized;
		rtg.transform.position = pos;
		if (rtg.GetComponent<MeshRenderer>() == null)
		{
			rtg.AddComponent<MeshRenderer>();
		}
		if (rt.roadMaterial != null && rtg.GetComponent<MeshRenderer>().sharedMaterial == null)
		{
			rtg.GetComponent<MeshRenderer>().sharedMaterial = rt.roadMaterial;
		}
		if (rtg.GetComponent<MeshFilter>() == null)
		{
			rtg.AddComponent<MeshFilter>().sharedMesh = new Mesh();
		}
		rtg.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.Off;
		ODODDQCQQC(rt);
	}

	public static void ODODDQCQQC(QDQDOOQQDQODD rt)
	{
		List<Vector3> list = new List<Vector3>();
		vecs.Clear();
		List<List<Vector2>> list2 = new List<List<Vector2>>();
		rt.roadShapeData.nodesV3.Clear();
		if (rt.roadShapeExt2.Count == 0)
		{
			rt.roadShapeExt2 = new List<Vector2>(rt.roadShape);
			rt.roadShapeExtUVs2 = new List<float>(rt.roadShapeUVs);
		}
		for (int i = 0; i < rt.roadShapeExt2.Count; i++)
		{
			vecs.Add(new List<Vector3>());
			list2.Add(new List<Vector2>());
		}
		float num = 0f;
		float num2 = rt.roadWidth * 1f;
		if (num2 < 5f)
		{
			num2 = 5f;
		}
		for (int j = 0; (float)j < num2; j++)
		{
			list.Add(camdir * num);
			num += 2f;
		}
		float num3 = rt.roadWidth * rt.uvTiling;
		num = 0f;
		for (int k = 0; k < list.Count; k++)
		{
			Vector3 vector = ((k > 0 && k < list.Count - 1) ? (list[k + 1] - list[k - 1]) : ((k != 0) ? (list[k] - list[k - 1]) : (list[k + 1] - list[0])));
			Vector3 normalized = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
			if (k > 0)
			{
				num += Vector3.Distance(list[k - 1], list[k]);
			}
			float y = num / num3;
			Vector3 vector2 = list[k];
			for (int l = 0; l < rt.roadShapeExt2.Count; l++)
			{
				Vector3 vector3 = vector2;
				vector3.y += rt.roadShapeExt2[l].y;
				Vector3 item = vector3 + rt.roadShapeExt2[l].x * normalized;
				vecs[l].Add(item);
				list2[l].Add(new Vector2(rt.roadShapeExtUVs2[l], y));
				if (k == 0)
				{
					rt.roadShapeData.nodesV3.Add(item);
				}
			}
		}
		if (rt.doConnectionTri.Count != rt.roadShape.Count)
		{
			rt.doConnectionTri.Clear();
			int num4 = 0;
			foreach (Vector2 item2 in rt.roadShape)
			{
				rt.doConnectionTri.Add(item: true);
				num4++;
			}
		}
		if (rt.doConnectionTriExt.Count != rt.roadShapeExt2.Count)
		{
			rt.doConnectionTriExt.Clear();
			int num5 = 0;
			foreach (Vector2 item3 in rt.roadShapeExt2)
			{
				rt.doConnectionTriExt.Add(item: true);
				num5++;
			}
		}
		int num6 = 0;
		int num7 = 0;
		foreach (bool item4 in rt.roadShapeData.hardEdge)
		{
			if (rt.roadShapeData.hardEdge[num6])
			{
				num7++;
			}
			num6++;
		}
		List<Vector3> list3 = new List<Vector3>();
		List<Vector2> list4 = new List<Vector2>();
		List<int> list5 = new List<int>();
		int count = vecs.Count;
		int num8 = 0;
		if (vecs.Count == 0)
		{
			UnityEngine.Debug.Log("EasyRoads3Dv3: creating road type preview failed. The roadd type is not upgraded to v3.2");
			return;
		}
		int num9 = 0;
		for (int m = 0; m < vecs[0].Count; m++)
		{
			num9 = 0;
			for (int n = 0; n < count; n++)
			{
				list3.Add(vecs[n][m]);
				list4.Add(list2[n][m]);
				if (n < count - 1 && m < vecs[0].Count)
				{
					if (rt.roadShapeData.hardEdge[n])
					{
						list3.Add(vecs[n][m]);
						list4.Add(list2[n][m]);
						num9++;
					}
					list5.Add(num8 + n + num9);
					list5.Add(num8 + n + num9 + count + num7);
					list5.Add(num8 + n + num9 + count + 1 + num7);
					list5.Add(num8 + n + num9);
					list5.Add(num8 + n + num9 + count + 1 + num7);
					list5.Add(num8 + n + num9 + 1);
				}
			}
			num8 = m * (count + num7);
		}
		Mesh sharedMesh = rtg.GetComponent<MeshFilter>().sharedMesh;
		sharedMesh.Clear();
		sharedMesh.vertices = list3.ToArray();
		sharedMesh.uv = list4.ToArray();
		sharedMesh.triangles = list5.ToArray();
		sharedMesh.RecalculateNormals();
		sharedMesh.RecalculateTangents();
		sharedMesh.RecalculateBounds();
		rtg.GetComponent<MeshFilter>().sharedMesh = sharedMesh;
	}

	public static void OODDDCCOQO(List<Vector3> cvecs, float OOCODCCCOQ, float OQQDDDQDOQ, float OCCOCCCODQ, List<float> breakpoints, float OQQOOQOOQQ, Vector3 startDir, Vector3 endDir, ref List<Vector3> vecs, float length, Vector3 firstRounding, float uvRatio)
	{
		List<Vector3> list = new List<Vector3>();
		float num = 0f;
		for (int i = 0; i < cvecs.Count; i++)
		{
			Vector3 vector = ((i == 0) ? (cvecs[i + 1] - cvecs[i]) : ((i != cvecs.Count - 1) ? (cvecs[i + 1] - cvecs[i - 1]) : (cvecs[i] - cvecs[i - 1])));
			Vector3 normalized = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
			list.Add(cvecs[i] + normalized * (0f - OOCODCCCOQ));
			if (i > 0)
			{
				num += Vector3.Distance(list[i - 1], list[i]);
			}
		}
		float num2 = num;
		num = num - OQQDDDQDOQ - OCCOCCCODQ;
		float f = num / length;
		float num3 = num - Mathf.Floor(f) * length;
		for (int j = 0; j < breakpoints.Count; j++)
		{
			if (breakpoints[j] > num3 || j == breakpoints.Count - 1)
			{
				if (j != breakpoints.Count - 1)
				{
					num = ((j != 0) ? ((!(num3 - breakpoints[j - 1] < breakpoints[j] - num3)) ? (Mathf.Floor(f) * length + breakpoints[j]) : (Mathf.Floor(f) * length + breakpoints[j - 1])) : (Mathf.Floor(f) * length + breakpoints[0]));
					break;
				}
				num = Mathf.Floor(f) * length + breakpoints[j];
			}
		}
		float num4 = num2 - num;
		float num5 = OQQDDDQDOQ + OCCOCCCODQ;
		if (num5 != 0f)
		{
			OQQDDDQDOQ = OQQDDDQDOQ / num5 * num4;
			OCCOCCCODQ = OCCOCCCODQ / num5 * num4;
		}
		else
		{
			OQQDDDQDOQ = 0.5f * num4;
			OCCOCCCODQ = 0.5f * num4;
		}
		float num6 = Vector3.Distance(firstRounding, cvecs[0]);
		float num7 = Vector3.Distance(firstRounding, cvecs[cvecs.Count - 1]);
		if (num7 > num6)
		{
			Vector3 vector2 = startDir;
			startDir = endDir;
			endDir = vector2;
		}
		if (OQQDDDQDOQ != 0f)
		{
			if (OQQDDDQDOQ < 0f)
			{
				list.Insert(0, list[0] + startDir * OQQDDDQDOQ);
			}
			else
			{
				num = 0f;
				float num8 = 0f;
				for (int k = 0; k < list.Count - 1; k++)
				{
					num = Vector3.Distance(list[k], list[k + 1]);
					if (num8 + num > OQQDDDQDOQ)
					{
						num = OQQDDDQDOQ - num8;
						Vector3 vector = (list[k + 1] - list[k]).normalized;
						list[k] += vector * num;
					}
					else
					{
						list.RemoveAt(k);
						k--;
						num8 += num;
					}
				}
			}
		}
		if (OCCOCCCODQ != 0f)
		{
			if (OCCOCCCODQ < 0f)
			{
				list.Add(list[list.Count - 1] + endDir * OCCOCCCODQ);
			}
			else
			{
				num = 0f;
				float num9 = 0f;
				for (int num10 = list.Count - 1; num10 > 0; num10--)
				{
					num = Vector3.Distance(list[num10], list[num10 - 1]);
					if (num9 + num > OCCOCCCODQ)
					{
						num = OCCOCCCODQ - num9;
						Vector3 vector = (list[num10 - 1] - list[num10]).normalized;
						list[num10] += vector * num;
					}
					else
					{
						list.RemoveAt(num10);
						num9 += num;
					}
				}
			}
		}
		vecs = list;
	}

	public static void RoadShapeChangeTriangulation(List<Vector3> shape1, List<Vector3> shape2, int startIndex1, int endIndex1, int startIndex2, int endIndex2, ref List<int> tris)
	{
	}
}
[Serializable]
public enum ERExitType
{
	RightExit,
	RightEntry,
	LeftExit,
	LeftEntry,
	BusStop
}
[Serializable]
public enum ConnectedTo
{
	Start,
	End,
	None
}
[Serializable]
public enum ERDecalPosition
{
	Start,
	End,
	Both
}
[Serializable]
public enum OffsetPosition
{
	Start,
	End
}
[Serializable]
public enum ERTrafficDirection
{
	LHT,
	RHT
}
[Serializable]
public enum ERIndentAlignment
{
	Road,
	Terrain,
	Surrounding
}
[Serializable]
public class ERLocalGrid : ScriptableObject
{
	public int id = 0;

	public new string name;

	public bool gridActive = false;

	public bool gridGUIActive = false;

	public Color gridColor = new Color(0.35f, 0.5f, 0.9f, 0.9f);

	public float gridSize = 50f;

	public float gridRadius = 500f;

	public float gridRotation = 0f;

	public Vector3 tl;

	public Vector3 bl;

	public Vector3 br;

	public float xOffset = 0f;

	public float yOffset = 0f;

	public Vector3 OOCDQCOOQC;

	public void Init(ERModularBase scr)
	{
		int minInclusive = 1;
		int maxExclusive = 999999999;
		id = UnityEngine.Random.Range(minInclusive, maxExclusive);
		name = "Local Grid " + (scr.localGrids.Count + 1);
	}

	public static ERLocalGrid CreateInstance(ERModularBase scr)
	{
		ERLocalGrid eRLocalGrid = ScriptableObject.CreateInstance<ERLocalGrid>();
		eRLocalGrid.Init(scr);
		return eRLocalGrid;
	}

	public static string[] GridNames(ERModularBase scr)
	{
		List<string> list = new List<string>();
		int num = 1;
		foreach (ERLocalGrid localGrid in scr.localGrids)
		{
			if (localGrid != null)
			{
				list.Add(num + ". " + localGrid.name);
				num++;
			}
		}
		if (list.Count == 0)
		{
			list.Add("No Local Grids available");
		}
		return list.ToArray();
	}

	public void SetOffsets(ERModularBase scr, Vector3 pos, Vector3 v)
	{
		xOffset = 0f;
		yOffset = 0f;
		xOffset = pos.x - v.x;
		yOffset = pos.z - v.z;
		OOCDQCOOQC = pos;
	}
}
[Serializable]
public class ERDecal : ScriptableObject
{
	public int id = 0;

	public new string name = "No Name";

	public ERDecalType type = ERDecalType.StartEnd;

	public double roadType1 = 0.0;

	public double roadType2 = 0.0;

	public int connection = 0;

	public GameObject decalPrefab;

	public float baseWidth = 6f;

	public float meshWidth = 0f;

	public float scale = 1f;

	public Vector3 localScale = new Vector3(1f, 1f, 1f);

	public int priority = 0;

	public bool collapsed = false;

	public float heightOffset = 0.005f;

	public Material material;

	public Vector2 uvLeftTop = new Vector2(0.45f, 0.75f);

	public Vector2 uvRightBottom = new Vector2(0.55f, 0.25f);

	public float width = 0f;

	public float length = 0f;

	public float xOffset = 0f;

	public float startOffset = 0f;

	public float endOffset = 0f;

	public float endRotation = 0f;

	public List<Vector2> uvBreakPoints = new List<Vector2>();

	public List<float> distances = new List<float>();

	public ERDecalPosition position = ERDecalPosition.Both;

	public Vector2 uvLeftTop1 = new Vector2(0.45f, 0.75f);

	public Vector2 uvRightBottom1 = new Vector2(0.55f, 0.25f);

	public Vector2 uvLeftTop2 = new Vector2(0.45f, 0.75f);

	public Vector2 uvRightBottom2 = new Vector2(0.55f, 0.25f);

	public float width1 = 0f;

	public float width2 = 0f;

	public void Init(GameObject prefab, float baseWidth)
	{
		int minInclusive = 1;
		int maxExclusive = 999999999;
		id = UnityEngine.Random.Range(minInclusive, maxExclusive);
		decalPrefab = prefab;
		this.baseWidth = baseWidth;
		if (prefab != null)
		{
			OCQCQCOCOO();
		}
	}

	public static ERDecal CreateInstance(GameObject prefab, float baseWidth)
	{
		ERDecal eRDecal = ScriptableObject.CreateInstance<ERDecal>();
		eRDecal.Init(prefab, baseWidth);
		return eRDecal;
	}

	public static void CopyDecal(ERDecalClass source, ERDecal target)
	{
		target.id = source.id;
		target.name = source.name;
		target.type = source.type;
		target.roadType1 = source.roadType1;
		target.roadType2 = source.roadType2;
		target.connection = source.connection;
		target.decalPrefab = source.decalPrefab;
		target.baseWidth = source.baseWidth;
		target.meshWidth = source.meshWidth;
		target.scale = source.scale;
		target.localScale = source.localScale;
		target.priority = source.priority;
		target.collapsed = source.collapsed;
		target.heightOffset = source.heightOffset;
		target.material = source.material;
		target.uvLeftTop = source.uvLeftTop;
		target.uvRightBottom = source.uvRightBottom;
		target.width = source.width;
		target.length = source.length;
		target.xOffset = source.xOffset;
		target.startOffset = source.startOffset;
		target.endOffset = source.endOffset;
		target.uvBreakPoints = new List<Vector2>(source.uvBreakPoints);
		target.distances = new List<float>(source.distances);
		target.uvLeftTop1 = source.uvLeftTop1;
		target.uvRightBottom1 = source.uvRightBottom1;
		target.uvLeftTop2 = source.uvLeftTop2;
		target.uvRightBottom2 = source.uvRightBottom2;
		target.width1 = source.width1;
		target.width2 = source.width2;
	}

	public static void OODDOCCOCC(ERDecal source, ERDecal target)
	{
		target.id = source.id;
		target.name = source.name;
		target.type = source.type;
		target.roadType1 = source.roadType1;
		target.roadType2 = source.roadType2;
		target.connection = source.connection;
		target.decalPrefab = source.decalPrefab;
		target.baseWidth = source.baseWidth;
		target.meshWidth = source.meshWidth;
		target.scale = source.scale;
		target.localScale = source.localScale;
		target.priority = source.priority;
		target.collapsed = source.collapsed;
		target.heightOffset = source.heightOffset;
		target.material = source.material;
		target.uvLeftTop = source.uvLeftTop;
		target.uvRightBottom = source.uvRightBottom;
		target.width = source.width;
		target.length = source.length;
		target.xOffset = source.xOffset;
		target.startOffset = source.startOffset;
		target.endOffset = source.endOffset;
		target.uvBreakPoints = new List<Vector2>(source.uvBreakPoints);
		target.distances = new List<float>(source.distances);
	}

	public void OCQCQCOCOO()
	{
		if (!(decalPrefab != null))
		{
			return;
		}
		Bounds bounds = default(Bounds);
		MeshFilter[] componentsInChildren = decalPrefab.GetComponentsInChildren<MeshFilter>();
		float num = 0f;
		MeshFilter[] array = componentsInChildren;
		foreach (MeshFilter meshFilter in array)
		{
			if (meshFilter.sharedMesh != null)
			{
				float num2 = meshFilter.sharedMesh.bounds.size.x * meshFilter.transform.localScale.x;
				if (num2 > num)
				{
					num = num2;
				}
			}
		}
		meshWidth = num;
	}

	public static ERDecal OCQCDQDODQ(int id, List<ERDecal> decalPresets)
	{
		foreach (ERDecal decalPreset in decalPresets)
		{
			if (decalPreset != null && decalPreset.id == id)
			{
				return decalPreset;
			}
		}
		return null;
	}

	public static List<ERDecal> FilterByType(List<ERDecal> lst, ERDecalType type)
	{
		List<ERDecal> list = new List<ERDecal>();
		foreach (ERDecal item in lst)
		{
			if (item != null && item.type == type)
			{
				list.Add(item);
			}
		}
		return list;
	}

	public static string[] OQDOCOQOQD(ref List<ERDecal> decals, string firstItem, int id1, int id2, ref int _index1, ref int _index2, ERDecalType type, ERDecalPosition position)
	{
		List<string> list = new List<string>();
		List<ERDecal> list2 = new List<ERDecal>();
		int num = 0;
		string text = "";
		foreach (ERDecal decal in decals)
		{
			if (decal != null && decal.type == type && (type != ERDecalType.StartEnd || position == decal.position || decal.position == ERDecalPosition.Both))
			{
				list.Add(string.Concat(arg2: (!(decal.decalPrefab != null) && type == ERDecalType.StartEnd) ? "missing prefab" : ((!(decal.decalPrefab != null)) ? decal.name : decal.decalPrefab.name), arg0: num, arg1: ". "));
				if (decal.id == id1)
				{
					_index1 = num + 1;
				}
				if (decal.id == id2)
				{
					_index2 = num + 1;
				}
				list2.Add(decal);
				num++;
			}
		}
		if (list.Count == 0)
		{
			list.Add("No Decal Presets Available");
		}
		else if (firstItem != "")
		{
			list.Insert(0, firstItem);
		}
		decals = list2;
		return list.ToArray();
	}

	public static int ODCOCCOOOO(List<ERDecal> decals, int tindex, ERDecalType type)
	{
		List<string> list = new List<string>();
		int num = 0;
		foreach (ERDecal decal in decals)
		{
			if (decal != null && decal.type == type)
			{
				num++;
				if (num == tindex)
				{
					return decal.id;
				}
			}
		}
		return -1;
	}

	public static GameObject[] OCCODDOQDO(List<ERDecal> decals, ref List<int> priority, ref List<float> scale)
	{
		List<GameObject> list = new List<GameObject>();
		foreach (ERDecal decal in decals)
		{
			if (decal != null)
			{
				list.Add(decal.decalPrefab);
				priority.Add(decal.priority);
				scale.Add(decal.scale);
			}
		}
		return list.ToArray();
	}

	public void MatchDistances(ref List<float> distances, List<Vector2> uvBreakPoints, float length)
	{
		if (distances.Count != uvBreakPoints.Count)
		{
			if (uvBreakPoints.Count > distances.Count)
			{
				for (int i = distances.Count; i < uvBreakPoints.Count; i++)
				{
					distances.Add(0f);
				}
			}
			else if (uvBreakPoints.Count == 0)
			{
				distances.Clear();
			}
			else
			{
				int num;
				for (num = uvBreakPoints.Count; num < distances.Count; num++)
				{
					distances.RemoveAt(num);
					num--;
				}
			}
		}
		SetBreakPointDistances(ref distances, uvBreakPoints, length);
	}

	public void SetBreakPointDistances(ref List<float> distances, List<Vector2> uvBreakPoints, float length)
	{
		for (int i = 0; i < uvBreakPoints.Count; i++)
		{
			distances[i] = uvBreakPoints[i].y * length;
		}
	}
}
[Serializable]
public enum ERDecalType
{
	StartEnd,
	LineMarking,
	StopMarking,
	MainConnectionLineMarking,
	MotorwayRampLineMarking,
	MotorwayRampSplitMarking
}
[Serializable]
public class ERDecalClass
{
	public int id = 0;

	public ERDecalType type = ERDecalType.StartEnd;

	public string name = "";

	public double roadType1 = 0.0;

	public double roadType2 = 0.0;

	public int connection = 0;

	public GameObject decalPrefab;

	public float baseWidth = 6f;

	public float meshWidth = 0f;

	public float scale = 1f;

	public Vector3 localScale = new Vector3(1f, 1f, 1f);

	public int priority = 0;

	public bool collapsed = false;

	public float heightOffset = 0f;

	public Material material;

	public Vector2 uvLeftTop = new Vector2(0.45f, 0.75f);

	public Vector2 uvRightBottom = new Vector2(0.55f, 0.25f);

	public float width = 0f;

	public float length = 0f;

	public float xOffset = 0f;

	public float startOffset = 0f;

	public float endOffset = 0f;

	public List<Vector2> uvBreakPoints = new List<Vector2>();

	public List<float> distances = new List<float>();

	public Vector2 uvLeftTop1 = new Vector2(0.45f, 0.75f);

	public Vector2 uvRightBottom1 = new Vector2(0.55f, 0.25f);

	public Vector2 uvLeftTop2 = new Vector2(0.45f, 0.75f);

	public Vector2 uvRightBottom2 = new Vector2(0.55f, 0.25f);

	public float width1 = 0f;

	public float width2 = 0f;

	public static void CopyDecal(ERDecal source, ERDecalClass target)
	{
		target.id = source.id;
		target.name = source.name;
		target.type = source.type;
		target.roadType1 = source.roadType1;
		target.roadType2 = source.roadType2;
		target.connection = source.connection;
		target.decalPrefab = source.decalPrefab;
		target.baseWidth = source.baseWidth;
		target.meshWidth = source.meshWidth;
		target.scale = source.scale;
		target.localScale = source.localScale;
		target.priority = source.priority;
		target.collapsed = source.collapsed;
		target.heightOffset = source.heightOffset;
		target.material = source.material;
		target.uvLeftTop = source.uvLeftTop;
		target.uvRightBottom = source.uvRightBottom;
		target.width = source.width;
		target.length = source.length;
		target.xOffset = source.xOffset;
		target.startOffset = source.startOffset;
		target.endOffset = source.endOffset;
		if (source.uvBreakPoints != null)
		{
			target.uvBreakPoints = new List<Vector2>(source.uvBreakPoints);
		}
		if (source.distances != null)
		{
			target.distances = new List<float>(source.distances);
		}
		target.uvLeftTop1 = source.uvLeftTop1;
		target.uvRightBottom1 = source.uvRightBottom1;
		target.uvLeftTop2 = source.uvLeftTop2;
		target.uvRightBottom2 = source.uvRightBottom2;
		target.width1 = source.width1;
		target.width2 = source.width2;
	}
}
[Serializable]
public class ERTreeInstance
{
	public int prototypeIndex;

	public Vector3 position;

	public ERTreeInstance(TreeInstance tree)
	{
		prototypeIndex = tree.prototypeIndex;
		position = tree.position;
	}
}
[Serializable]
public class ERCamNodes : ScriptableObject
{
	[SerializeField]
	public float sleep = 0f;

	[SerializeField]
	public float speed = 0f;

	[SerializeField]
	public float easeOutDistance = 0f;

	[SerializeField]
	public float easeInDistance = 0f;

	[SerializeField]
	public GameObject startLookat;

	[SerializeField]
	public GameObject endLookat;
}
[Serializable]
public enum ERMarkerControlType
{
	Spline,
	StraightXZ,
	StraightXZY,
	Circular
}
[Serializable]
public struct ERLane
{
	public float position;

	public ERLaneDirection direction;

	public ERDirectionType turnDirection;

	public int laneIndex;

	public ERLane(float position, ERLaneDirection direction, int index)
	{
		this.position = position;
		this.direction = direction;
		turnDirection = ERDirectionType.Straight;
		laneIndex = index;
	}

	public ERLane(ERLane lane)
	{
		position = lane.position;
		direction = lane.direction;
		turnDirection = lane.turnDirection;
		laneIndex = lane.laneIndex;
	}

	public void Copy(ERLane lane)
	{
		position = lane.position;
		direction = lane.direction;
		turnDirection = lane.turnDirection;
		laneIndex = lane.laneIndex;
	}
}
[Serializable]
public struct ERVSData
{
	public Vector3 position;

	public bool active;

	public float width;

	public Vector3 leftPosition;

	public Vector3 rightPosition;

	public Vector3 dir;

	public ERVSData(Vector3 node, bool active, float width, Vector3 leftPosition, Vector3 rightPosition)
	{
		position = node;
		this.active = active;
		this.width = width;
		this.leftPosition = leftPosition;
		this.rightPosition = rightPosition;
		dir = (rightPosition - leftPosition).normalized;
	}
}
public class ERSideWalkInstanceScript : MonoBehaviour
{
	public ERSideWalkInstance instance;
}
[Serializable]
[AddComponentMenu("")]
public class ERSideWalkInstance
{
	public ERSideWalk sidewalk;

	public GameObject swObject;

	public double id;

	[HideInInspector]
	public float start = 0f;

	[HideInInspector]
	public float end = 1f;

	[HideInInspector]
	public Vector3 startPos = Vector3.zero;

	[HideInInspector]
	public Vector3 endPos = Vector3.zero;

	public ERSideWalkInstance(ERSideWalk msidewalk, float mStart, float mEnd, Vector3 mStartPos, Vector3 mEndPos, ERModularRoad road, string side)
	{
		sidewalk = msidewalk;
		id = sidewalk.id;
		start = mStart;
		end = mEnd;
		startPos = mStartPos;
		endPos = mEndPos;
		CreateObject(road, side);
	}

	public void CreateObject(ERModularRoad road, string side)
	{
		swObject = new GameObject(sidewalk.name + " " + side);
		swObject.transform.parent = road.transform;
		swObject.AddComponent<MeshRenderer>().sharedMaterial = sidewalk.material;
		swObject.AddComponent<MeshFilter>().sharedMesh = new Mesh();
		swObject.AddComponent<MeshCollider>().sharedMesh = swObject.GetComponent<MeshFilter>().sharedMesh;
		swObject.AddComponent<ERSideWalkInstanceScript>().instance = this;
		swObject.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.On;
	}

	public void GetObject(ERModularRoad road, string side)
	{
		if (road.gameObject.GetComponentsInChildren(typeof(ERSideWalkInstanceScript)) is ERSideWalkInstanceScript[] array)
		{
			ERSideWalkInstanceScript[] array2 = array;
			foreach (ERSideWalkInstanceScript eRSideWalkInstanceScript in array2)
			{
				if (eRSideWalkInstanceScript.instance == this)
				{
					swObject = eRSideWalkInstanceScript.gameObject;
					return;
				}
			}
		}
		if (swObject == null)
		{
			CreateObject(road, side);
		}
	}
}
[Serializable]
public class ERMaterial : ScriptableObject
{
	public int id = 0;

	public new string name;

	public double roadType1ID;

	public double roadType2ID;

	public double roadType3ID;

	public Material road1Material;

	public Material road2Material;

	public Material road3Material;

	public float connectorLength1 = 0f;

	public float connectorLength2 = 0f;

	public float connectorLength3 = 0f;

	public float road1Stretch = 1f;

	public float road2Stretch = 1f;

	public float road3Stretch = 1f;

	public int road1StretchType = 0;

	public int road2StretchType = 0;

	public int road3StretchType = 0;

	public int subdivide1 = 0;

	public int subdivide2 = 0;

	public int subdivide3 = 0;

	public float resolution = 1f;

	public bool blend = false;

	public float blendDistance = 1f;

	public int blendSection = 0;

	public bool triangleStrip = false;

	public float triangleStripDistance = 1f;

	public float triangleStripUVStart = 0f;

	public float triangleStripUVEnd = 1f;

	public Material triangleStripMaterial;

	public void Init(ERModularBase scr)
	{
		int minInclusive = 1;
		int maxExclusive = 999999999;
		id = UnityEngine.Random.Range(minInclusive, maxExclusive);
		name = "Material " + (scr.materials.Count + 1);
	}

	public static ERMaterial CreateInstance(ERModularBase scr)
	{
		ERMaterial eRMaterial = ScriptableObject.CreateInstance<ERMaterial>();
		eRMaterial.Init(scr);
		return eRMaterial;
	}

	public static string[] OCQOOCOQQC(ERModularBase scr)
	{
		List<string> list = new List<string>();
		for (int i = 0; i < scr.materials.Count; i++)
		{
			list.Add(i + ". " + scr.materials[i].name);
		}
		_ = list.Count;
		if (false)
		{
			list.Add("No procedural materials available yet");
		}
		return list.ToArray();
	}

	public static ERMaterial OQDQOCCODO(ERModularBase scr, ERIConnector prefab, ref int targetRoad, ref int index)
	{
		ERMaterial result = null;
		for (int i = 0; i < scr.materials.Count; i++)
		{
			if ((prefab.roadType1ID == scr.materials[i].roadType1ID && prefab.roadType2ID == scr.materials[i].roadType2ID) || (prefab.roadType1ID == scr.materials[i].roadType2ID && prefab.roadType2ID == scr.materials[i].roadType1ID))
			{
				if (prefab.roadType1ID == scr.materials[i].roadType1ID)
				{
					targetRoad = 0;
				}
				else
				{
					targetRoad = 1;
				}
				result = scr.materials[i];
				index = i;
			}
		}
		return result;
	}

	public static Material OOQCDDQODC(ERModularBase scr, ERIConnector prefab)
	{
		ERMaterial eRMaterial = CreateInstance(scr);
		eRMaterial.roadType1ID = prefab.roadType1ID;
		eRMaterial.roadType2ID = prefab.roadType2ID;
		eRMaterial.road1Material = prefab.road1Material;
		eRMaterial.road2Material = prefab.road2Material;
		eRMaterial.connectorLength1 = prefab.connectorLength1;
		eRMaterial.connectorLength2 = prefab.connectorLength2;
		eRMaterial.road1Stretch = prefab.road1Stretch;
		eRMaterial.road2Stretch = prefab.road2Stretch;
		eRMaterial.road1StretchType = prefab.road1StretchType;
		eRMaterial.road2StretchType = prefab.road2StretchType;
		eRMaterial.subdivide1 = prefab.subdivide1;
		eRMaterial.subdivide2 = prefab.subdivide2;
		eRMaterial.resolution = prefab.resolution;
		eRMaterial.blend = prefab.blend;
		eRMaterial.blendDistance = prefab.blendDistance;
		eRMaterial.blendSection = prefab.blendSection;
		eRMaterial.triangleStrip = prefab.triangleStrip;
		eRMaterial.triangleStripDistance = prefab.triangleStripDistance;
		eRMaterial.triangleStripUVStart = prefab.triangleStripUVStart;
		eRMaterial.triangleStripUVEnd = prefab.triangleStripUVEnd;
		eRMaterial.triangleStripMaterial = prefab.triangleStripMaterial;
		eRMaterial.triangleStripMaterial = new Material(Shader.Find("EasyRoads3Dv3/Road Blend"));
		eRMaterial.triangleStripMaterial.name = eRMaterial.name;
		eRMaterial.triangleStripMaterial.shader = Shader.Find("EasyRoads3Dv3/Road Blend");
		if (prefab.road1Material.HasProperty("_MainTex"))
		{
			eRMaterial.triangleStripMaterial.SetTexture("_MainTex", prefab.road1Material.GetTexture("_MainTex"));
		}
		if (prefab.road1Material.HasProperty("_BumpMap"))
		{
			eRMaterial.triangleStripMaterial.SetTexture("_BumpMap", prefab.road1Material.GetTexture("_BumpMap"));
		}
		if (prefab.road2Material.HasProperty("_MainTex"))
		{
			eRMaterial.triangleStripMaterial.SetTexture("_MainTex2", prefab.road2Material.GetTexture("_MainTex"));
		}
		if (prefab.road2Material.HasProperty("_BumpMap"))
		{
			eRMaterial.triangleStripMaterial.SetTexture("_BumpMap2", prefab.road2Material.GetTexture("_BumpMap"));
		}
		if (prefab.road1Material.HasProperty("_MetallicRoad"))
		{
			eRMaterial.triangleStripMaterial.SetFloat("_MetallicRoad", prefab.road1Material.GetFloat("_MetallicRoad"));
		}
		if (prefab.road1Material.HasProperty("_SmoothnessRoad"))
		{
			eRMaterial.triangleStripMaterial.SetFloat("_SmoothnessRoad", prefab.road1Material.GetFloat("_SmoothnessRoad"));
		}
		if (prefab.road1Material.HasProperty("_Color"))
		{
			eRMaterial.triangleStripMaterial.SetColor("_Color", prefab.road1Material.GetColor("_Color"));
		}
		if (prefab.road2Material.HasProperty("_Color"))
		{
			eRMaterial.triangleStripMaterial.SetColor("_Color2", prefab.road2Material.GetColor("_Color"));
		}
		scr.materials.Add(eRMaterial);
		return eRMaterial.triangleStripMaterial;
	}
}
[AddComponentMenu("")]
public class ERIConnector : MonoBehaviour
{
	public float roadWidth1 = 6f;

	public float leftIndentInner1 = 0.1f;

	public float leftIndent1 = 0.1f;

	public float leftUVXInner1 = 0.1f;

	public float leftUVX1 = 0.1f;

	public float rightUVX1 = 0.1f;

	public float rightUVXInner1 = 0.1f;

	public float rightIndentInner1 = 0.1f;

	public float rightIndent1 = 0.1f;

	public float cornerRadius1 = 1f;

	public int cornerSegments1 = 5;

	public float angle1 = 0f;

	public float prevAngle1 = 0f;

	public Material road1Material;

	public Material road1MaterialActive;

	public int roadType1;

	public double roadType1ID;

	public ERTexture road1ERTexture;

	private float á = 0.1f;

	private float á = 0f;

	private float á = 0.05f;

	private float 4AAAA = 0f;

	public float road1Stretch = 1f;

	public int road1StretchType = 0;

	public int subdivide1 = 0;

	public float roadWidth2 = 6f;

	public float leftIndentInner2 = 0.1f;

	public float leftIndent2 = 0.1f;

	public float leftUVXInner2 = 0.1f;

	public float leftUVX2 = 0.1f;

	public float rightUVX2 = 0.1f;

	public float rightUVXInner2 = 0.1f;

	public float rightIndentInner2 = 0.1f;

	public float rightIndent2 = 0.1f;

	public float cornerRadius2 = 1f;

	public int cornerSegments2 = 5;

	public float angle2 = 120f;

	public float prevAngle2 = 0f;

	public Material road2Material;

	public Material road2MaterialActive;

	public int roadType2;

	public double roadType2ID;

	public ERTexture road2ERTexture;

	private float 5AAA1 = 0.1f;

	private float 6AAAA = 0f;

	private float 7AAA1 = 0.05f;

	private float 8AAAA = 0f;

	public float road2Stretch = 1f;

	public int road2StretchType = 0;

	public int subdivide2 = 0;

	public float resolution = 1f;

	public int crossingStructure = 0;

	public bool blend = false;

	public int textureType = 0;

	public int roadStructureType = -1;

	public string[] crossingStructureStrings = new string[4] { "3 Connections", "1 and 2 form road", "1 and 3 form road", "2 and 3 form road" };

	public bool clampUVs = false;

	public float attachAngle = 1f;

	public List<QDQDOOQQDQODD> roadTypesDynamic = new List<QDQDOOQQDQODD>();

	public List<Vector3> splinePoints1 = new List<Vector3>();

	public List<Vector3> splinePoints2 = new List<Vector3>();

	public List<int> roadShapeMaterialInts1 = new List<int>();

	public List<int> roadShapeMaterialInts2 = new List<int>();

	public List<Vector3> leftRoundingPoints1 = new List<Vector3>();

	public List<Vector3> centerPoints1 = new List<Vector3>();

	public List<Vector3> rightRoundingPoints1 = new List<Vector3>();

	public List<Vector3> leftPointsIndents1 = new List<Vector3>();

	public List<Vector3> rightPointsIndents1 = new List<Vector3>();

	public List<Vector3> middlePoints1 = new List<Vector3>();

	public List<Vector3> leftPoints13 = new List<Vector3>();

	public List<Vector3> rightPoints12 = new List<Vector3>();

	public List<Vector2> leftRoundingPointsUV1 = new List<Vector2>();

	private List<Vector2> 9AAA1 = new List<Vector2>();

	public List<Vector2> rightRoundingPointsUV1 = new List<Vector2>();

	public List<Vector2> leftPointsIndentsUV1 = new List<Vector2>();

	public List<Vector2> rightPointsIndentsUV1 = new List<Vector2>();

	public List<Vector3> leftRoundingPoints2 = new List<Vector3>();

	public List<Vector3> centerPoints2 = new List<Vector3>();

	public List<Vector3> rightRoundingPoints2 = new List<Vector3>();

	public List<Vector3> leftPointsIndents2 = new List<Vector3>();

	public List<Vector3> rightPointsIndents2 = new List<Vector3>();

	public List<Vector3> middlePoints2 = new List<Vector3>();

	public List<Vector3> rightPoints23 = new List<Vector3>();

	public List<Vector2> leftRoundingPointsUV2 = new List<Vector2>();

	private List<Vector2> BAAAA = new List<Vector2>();

	public List<Vector2> rightRoundingPointsUV2 = new List<Vector2>();

	public List<Vector2> leftPointsIndentsUV2 = new List<Vector2>();

	public List<Vector2> rightPointsIndentsUV2 = new List<Vector2>();

	public List<Vector3> priorityConnectionPoints = new List<Vector3>();

	public List<Vector2> priorityConnectionPointsUV = new List<Vector2>();

	public float minAngle12 = 45f;

	public float minAngle13 = 45f;

	public float minAngle23 = 45f;

	public Vector2 cpUV1;

	public Vector2 cpUV2;

	public Vector2 cpUV3;

	public List<Vector3> ll1 = new List<Vector3>();

	public List<Vector3> ll2 = new List<Vector3>();

	public List<Vector3> ll3 = new List<Vector3>();

	public List<Vector3> ll4 = new List<Vector3>();

	public Vector3 l1Start;

	public Vector3 l1End;

	public Vector3 l2Start;

	public Vector3 l2End;

	public Vector3 l3Start;

	public Vector3 l3End;

	public Vector3 r1Start;

	public Vector3 r1End;

	public Vector3 r2Start;

	public Vector3 r2End;

	public Vector3 r3Start;

	public Vector3 r3End;

	public Vector3 ip12;

	public Vector3 ip23;

	public Vector3 ip13;

	public Vector3 ip13Left;

	public Vector3 ip12right;

	public Vector3 ip23right;

	public Vector3 cp1Left;

	public Vector3 cp1Right;

	public Vector3 cp2Left;

	public Vector3 cp2Right;

	public Vector3 cp3Left;

	public Vector3 cp3Right;

	public bool lock1 = false;

	public bool lock2 = false;

	public bool lock3 = false;

	private float CAAA1 = 0f;

	private float 00AAA = 0f;

	public ERModularRoad road1 = null;

	public ERModularRoad road2 = null;

	public List<Vector2> roadShape1 = new List<Vector2>();

	public List<Vector2> roadShape2 = new List<Vector2>();

	public List<float> roadShapeUVs1 = new List<float>();

	public List<float> roadShapeUVs2 = new List<float>();

	public List<Material> roadMaterials1 = new List<Material>();

	public List<Material> roadMaterials2 = new List<Material>();

	public List<Vector3> leftPoints = new List<Vector3>();

	public List<Vector3> rightPoints = new List<Vector3>();

	public float connectorLength1 = 0f;

	public float connectorLength2 = 0f;

	public float blendDistance = 0f;

	public int blendSection = 1;

	public bool triangleStrip = false;

	public float triangleStripDistance = 1f;

	public float triangleStripUVStart = 0f;

	public float triangleStripUVEnd = 1f;

	public Material triangleStripMaterial;

	public Material blendMaterial;

	public Material transitionMaterial;

	public bool transitionSwap = false;

	public int proceduralMaterialIndex = 0;

	public bool presetSwapped = false;

	public float t1 = 0f;

	public float t2 = 0f;

	public GameObject go1;

	public GameObject go2;

	public GameObject go3;

	public GameObject go4;

	public ERCrossingPrefabs prefabScript;

	public List<Vector3> surfaceVecs = new List<Vector3>();

	public Vector3 testPoint;

	public GameObject surfaceMesh;

	public ERModularBase baseScript;

	public Vector3 centerDir;

	public Vector3 cp1 = Vector3.zero;

	public Vector3 cp2 = Vector3.zero;

	public Vector3 cp3 = Vector3.zero;

	public Vector3 cp4 = Vector3.zero;

	public Vector3 tv = Vector3.zero;

	public List<Vector3> tvecs = new List<Vector3>();

	public void UpdateERTexture(int road)
	{
		switch (road)
		{
		case 1:
			OOOQQDDCCQ(road1ERTexture, ref roadWidth1, ref leftIndent1, ref rightIndent1, ref leftUVX1, ref rightUVX1, ref leftIndentInner1, ref rightIndentInner1, ref 4AAAA, cornerRadius1);
			break;
		case 2:
			OOOQQDDCCQ(road2ERTexture, ref roadWidth2, ref leftIndent2, ref rightIndent2, ref leftUVX2, ref rightUVX2, ref leftIndentInner2, ref rightIndentInner2, ref 8AAAA, cornerRadius2);
			break;
		}
	}

	public void OCQOQCDCQC(ERModularRoad sourceRoad)
	{
		if (baseScript == null)
		{
			baseScript = UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase;
		}
		if (roadTypesDynamic.Count == 0)
		{
			roadTypesDynamic.Clear();
			foreach (QDQDOOQQDQODD roadType in baseScript.roadTypes)
			{
				if (roadType.roadShape.Count == 2)
				{
					roadTypesDynamic.Add(roadType);
				}
			}
		}
		Clear();
		cp1 = Vector3.zero;
		cp2 = Vector3.zero;
		cp3 = Vector3.zero;
		cp4 = Vector3.zero;
		float indentLeftStart = 0f;
		float indentLeftEnd = 0f;
		float surroundingLeftStart = 0f;
		float surroundingLeftEnd = 0f;
		float indentRightStart = 0f;
		float indentRightEnd = 0f;
		float surroundingRightStart = 0f;
		float surroundingRightEnd = 0f;
		bool flag = false;
		bool flag2 = false;
		int startEnd = 0;
		int startEnd2 = 0;
		float uvRatio = 5f;
		float uvRatio2 = 5f;
		if (prefabScript == null)
		{
			prefabScript = base.gameObject.GetComponent<ERCrossingPrefabs>();
			prefabScript.iConnectorScript = this;
		}
		road1 = null;
		road2 = null;
		if (prefabScript.crossingElements[0].connectedRoad != null)
		{
			ERModularRoad eRModularRoad = (road1 = prefabScript.crossingElements[0].connectedRoad);
			roadShape1 = new List<Vector2>(eRModularRoad.markersExt[prefabScript.crossingElements[0].connectedMarker].roadShape);
			roadShapeUVs1 = new List<float>(eRModularRoad.roadShapeUVs);
			uvRatio = 5f * road1.uvTiling;
			if (prefabScript.crossingElements[0].connectedMarker == 0)
			{
				cp3 = (cp4 = eRModularRoad.markersExt[prefabScript.crossingElements[0].connectedMarker + 1].position);
				if (eRModularRoad.markersExt.Count > prefabScript.crossingElements[0].connectedMarker + 2)
				{
					cp4 = eRModularRoad.markersExt[prefabScript.crossingElements[0].connectedMarker + 2].position;
				}
				ERMarkerExt eRMarkerExt = eRModularRoad.markersExt[prefabScript.crossingElements[0].connectedMarker];
				indentLeftStart = (indentLeftEnd = eRMarkerExt.rightIndent);
				indentRightStart = (indentRightEnd = eRMarkerExt.leftIndent);
				surroundingLeftStart = (surroundingLeftEnd = eRMarkerExt.rightSurrounding);
				surroundingRightStart = (surroundingRightEnd = eRMarkerExt.leftSurrounding);
				for (int i = 0; i < roadShape1.Count; i++)
				{
					Vector2 value = roadShape1[i];
					value.x *= -1f;
					roadShape1[i] = value;
				}
				flag = true;
			}
			else
			{
				cp3 = (cp4 = eRModularRoad.markersExt[prefabScript.crossingElements[0].connectedMarker - 1].position);
				if (prefabScript.crossingElements[0].connectedMarker - 2 >= 0)
				{
					cp4 = eRModularRoad.markersExt[prefabScript.crossingElements[0].connectedMarker - 2].position;
				}
				ERMarkerExt eRMarkerExt2 = eRModularRoad.markersExt[prefabScript.crossingElements[0].connectedMarker];
				indentLeftStart = (indentLeftEnd = eRMarkerExt2.leftIndent);
				indentRightStart = (indentRightEnd = eRMarkerExt2.rightIndent);
				surroundingLeftStart = (surroundingLeftEnd = eRMarkerExt2.leftSurrounding);
				surroundingRightStart = (surroundingRightEnd = eRMarkerExt2.rightSurrounding);
				startEnd = 1;
			}
			bool flag3 = false;
			if (roadType1 == 0)
			{
				flag3 = true;
			}
			else if (road1.roadType != baseScript.roadTypes[roadType1 - 1].id)
			{
				flag3 = true;
			}
			if (flag3)
			{
				roadType1 = 0;
				for (int j = 0; j < baseScript.roadTypes.Count; j++)
				{
					if (baseScript.roadTypes[j].id == road1.roadType)
					{
						roadType1 = j + 1;
						roadType1ID = road1.roadType;
						break;
					}
				}
			}
			float num = 1000f;
			float num2 = -1000f;
			for (int k = 0; k < roadShape1.Count; k++)
			{
				if (num > roadShape1[k].x)
				{
					num = roadShape1[k].x;
				}
				if (num2 < roadShape1[k].x)
				{
					num2 = roadShape1[k].x;
				}
			}
			roadWidth1 = num2 - num;
			road1Material = eRModularRoad.roadMaterial;
			roadMaterials1 = new List<Material>(eRModularRoad.roadMaterials);
			if (roadMaterials1.Count == 0)
			{
				roadMaterials1.Add(eRModularRoad.roadMaterial);
			}
			if (road1MaterialActive == null)
			{
				road1MaterialActive = road1Material;
			}
			road1MaterialActive = road1Material;
			roadShapeMaterialInts1 = new List<int>(eRModularRoad.roadShapeMaterialInts);
		}
		else
		{
			connectorLength1 = 0f;
			if (roadType1 > 0)
			{
				roadShape1 = new List<Vector2>(baseScript.roadTypes[roadType1 - 1].roadShape);
				roadShapeUVs1 = new List<float>(baseScript.roadTypes[roadType1 - 1].roadShapeUVs);
				roadMaterials1 = new List<Material>(baseScript.roadTypes[roadType1 - 1].roadMaterials);
				if (roadMaterials1.Count == 0)
				{
					roadMaterials1.Add(baseScript.roadTypes[roadType1 - 1].roadMaterial);
				}
			}
			else
			{
				connectorLength1 = 0f;
			}
			road1MaterialActive = road1Material;
			roadShapeMaterialInts1.Add(0);
			roadShapeMaterialInts1.Add(0);
		}
		if (prefabScript.crossingElements[1].connectedRoad != null)
		{
			ERModularRoad eRModularRoad2 = (road2 = prefabScript.crossingElements[1].connectedRoad);
			roadShape2 = new List<Vector2>(eRModularRoad2.markersExt[prefabScript.crossingElements[1].connectedMarker].roadShape);
			roadShapeUVs2 = new List<float>(eRModularRoad2.roadShapeUVs);
			uvRatio2 = 5f * road2.uvTiling;
			if (prefabScript.crossingElements[1].connectedMarker == 0)
			{
				cp1 = (cp2 = eRModularRoad2.markersExt[prefabScript.crossingElements[1].connectedMarker + 1].position);
				ERMarkerExt eRMarkerExt3 = eRModularRoad2.markersExt[prefabScript.crossingElements[1].connectedMarker + 1];
				if (eRModularRoad2.markersExt.Count > prefabScript.crossingElements[1].connectedMarker + 2)
				{
					cp2 = eRModularRoad2.markersExt[prefabScript.crossingElements[1].connectedMarker + 2].position;
					eRMarkerExt3 = eRModularRoad2.markersExt[prefabScript.crossingElements[1].connectedMarker + 2];
				}
				roadShape2.Reverse();
				roadShapeUVs2.Reverse();
			}
			else
			{
				cp1 = (cp2 = eRModularRoad2.markersExt[prefabScript.crossingElements[1].connectedMarker - 1].position);
				ERMarkerExt eRMarkerExt4 = eRModularRoad2.markersExt[prefabScript.crossingElements[1].connectedMarker - 1];
				if (prefabScript.crossingElements[1].connectedMarker - 2 >= 0)
				{
					cp2 = eRModularRoad2.markersExt[prefabScript.crossingElements[1].connectedMarker - 2].position;
					eRMarkerExt4 = eRModularRoad2.markersExt[prefabScript.crossingElements[1].connectedMarker - 2];
				}
				flag2 = true;
				startEnd2 = 1;
			}
			bool flag4 = false;
			if (roadType2 == 0)
			{
				flag4 = true;
			}
			else if (road2.roadType != baseScript.roadTypes[roadType2 - 1].id)
			{
				flag4 = true;
			}
			if (flag4)
			{
				roadType2 = 0;
				for (int l = 0; l < baseScript.roadTypes.Count; l++)
				{
					if (baseScript.roadTypes[l].id == road2.roadType)
					{
						roadType2 = l + 1;
						roadType2ID = road2.roadType;
						break;
					}
				}
			}
			float num3 = 1000f;
			float num4 = -1000f;
			for (int m = 0; m < roadShape2.Count; m++)
			{
				if (num3 > roadShape2[m].x)
				{
					num3 = roadShape2[m].x;
				}
				if (num4 < roadShape2[m].x)
				{
					num4 = roadShape2[m].x;
				}
			}
			roadWidth2 = num4 - num3;
			road2Material = eRModularRoad2.roadMaterial;
			roadMaterials2 = new List<Material>(eRModularRoad2.roadMaterials);
			if (roadMaterials2.Count == 0)
			{
				roadMaterials2.Add(eRModularRoad2.roadMaterial);
			}
			road2Material = roadMaterials2[0];
			roadShapeMaterialInts2 = new List<int>(eRModularRoad2.roadShapeMaterialInts);
			if (road2MaterialActive == null)
			{
				road2MaterialActive = road2Material;
			}
			road2MaterialActive = road2Material;
		}
		else
		{
			connectorLength2 = 0f;
			if (roadType2 > 0)
			{
				roadShape2 = new List<Vector2>(baseScript.roadTypes[roadType2 - 1].roadShape);
				roadShapeUVs2 = new List<float>(baseScript.roadTypes[roadType2 - 1].roadShapeUVs);
				roadMaterials2 = new List<Material>(baseScript.roadTypes[roadType2 - 1].roadMaterials);
				if (roadMaterials2.Count == 0)
				{
					roadMaterials2.Add(baseScript.roadTypes[roadType2 - 1].roadMaterial);
				}
			}
			else
			{
				connectorLength2 = 0f;
			}
			if (road2MaterialActive == null)
			{
				road2MaterialActive = road2Material;
			}
			road2MaterialActive = road2Material;
			roadShapeMaterialInts2.Add(0);
			roadShapeMaterialInts2.Add(0);
			cp1 = base.transform.position;
		}
		if (road1 == null || road2 == null)
		{
			connectorLength1 = 0f;
			connectorLength2 = 0f;
			blend = false;
			textureType = 0;
		}
		if (roadMaterials1.Count > 0)
		{
			if (road1MaterialActive != roadMaterials1[0])
			{
				roadMaterials1.Clear();
				roadMaterials1.Add(road1MaterialActive);
			}
		}
		else
		{
			roadMaterials1.Clear();
			roadMaterials1.Add(road1MaterialActive);
		}
		if (roadMaterials2.Count > 0)
		{
			if (road2MaterialActive != roadMaterials2[0])
			{
				roadMaterials2.Clear();
				roadMaterials2.Add(road2MaterialActive);
			}
		}
		else
		{
			roadMaterials2.Clear();
			roadMaterials2.Add(road2MaterialActive);
		}
		if (cp2 == Vector3.zero)
		{
			cp2 = base.transform.position;
		}
		centerDir = Vector3.zero;
		if (road1 == null && roadType1 == 0)
		{
			roadType1 = roadType2;
			roadType1ID = roadType2ID;
		}
		if (road2 == null && roadType2 == 0)
		{
			roadType2 = roadType1;
			roadType2ID = roadType1ID;
		}
		if (connectorLength1 > 0f)
		{
			splinePoints1 = OQDDOOOOQD(cp1, base.transform.position, cp3, cp4, 0.5f, resolution, connectorLength1, ref t1);
		}
		else
		{
			Vector3 vector = (tv = ERModularRoad.OODODQQQCD(cp1, base.transform.position, cp3, cp4, 0.05f, 0.5f));
			centerDir = (base.transform.position - vector).normalized;
			splinePoints1.Add(base.transform.position);
			t1 = 0f;
		}
		if (cp3 == Vector3.zero)
		{
			cp3 = base.transform.position;
		}
		if (cp1 != Vector3.zero && cp1 != base.transform.position)
		{
			if (connectorLength2 > 0f)
			{
				splinePoints2 = OQDDOOOOQD(cp3, base.transform.position, cp1, cp2, 0.5f, resolution, connectorLength2, ref t2);
			}
			else
			{
				splinePoints2.Add(base.transform.position);
				t2 = 0f;
			}
		}
		if (splinePoints1.Count == 0 || splinePoints2.Count == 0)
		{
			if (splinePoints1.Count > 1)
			{
				centerDir = (splinePoints1[0] - splinePoints1[1]).normalized;
			}
			else if (centerDir == Vector3.zero)
			{
				Vector3 vector2 = ERModularRoad.OODODQQQCD(cp3, base.transform.position, cp1, cp2, 0.01f, 0.5f);
				centerDir = (base.transform.position - vector2).normalized;
			}
		}
		if (cp1 != Vector3.zero && cp3 != Vector3.zero)
		{
			centerDir = (cp1 - cp3).normalized;
		}
		splinePoints1.Reverse();
		splinePoints2.Reverse();
		if (blendDistance > 0f)
		{
			if (blendDistance > resolution)
			{
				if (blendSection == 0)
				{
					OQCDDQOCOD(ref splinePoints1, 0.5f * blendDistance);
					OQCDDQOCOD(ref splinePoints2, 0.5f * blendDistance);
				}
				else if (blendSection == 1)
				{
					OQCDDQOCOD(ref splinePoints1, blendDistance);
				}
				else if (blendSection == 2)
				{
					OQCDDQOCOD(ref splinePoints2, blendDistance);
				}
			}
			else
			{
				OQCDDQOCOD(ref splinePoints1, blendDistance);
				if (!((double)(blendDistance / resolution) > 0.9))
				{
				}
			}
		}
		List<Vector3> vecs = new List<Vector3>();
		List<Vector2> uvs = new List<Vector2>();
		List<Vector2> list = new List<Vector2>();
		List<Vector3> vecs2 = new List<Vector3>();
		List<Vector2> uvs2 = new List<Vector2>();
		List<Vector2> list2 = new List<Vector2>();
		List<Color> colors = new List<Color>();
		List<Vector2> list3 = new List<Vector2>();
		List<Vector2> list4 = new List<Vector2>();
		List<int> list5 = new List<int>();
		List<float> list6 = new List<float>();
		List<float> list7 = new List<float>();
		List<int> list8 = new List<int>();
		List<bool> list9 = new List<bool>();
		List<bool> list10 = new List<bool>();
		int num5 = 1;
		int index = 0;
		int index2 = 1;
		list3.Add(roadShape1[0]);
		list6.Add(roadShapeUVs1[0]);
		list5.Add(roadShapeMaterialInts1[0]);
		list9.Add(item: true);
		if (roadShape1.Count > 2)
		{
			num5 = 2;
			index = 1;
			index2 = 2;
			list3.Add(roadShape1[1]);
			list6.Add(roadShapeUVs1[1]);
			list5.Add(roadShapeMaterialInts1[1]);
			list9.Add(item: true);
		}
		for (int n = num5; n < num5 + subdivide1; n++)
		{
			list3.Add(Vector2.Lerp(roadShape1[index], roadShape1[index2], (float)(n - num5 + 1) / ((float)subdivide1 + 1f)));
			list6.Add(Mathf.Lerp(roadShapeUVs1[index], roadShapeUVs1[index2], (float)(n - num5 + 1) / ((float)subdivide1 + 1f)));
			list5.Add(roadShapeMaterialInts1[index]);
			list9.Add(item: false);
		}
		if (roadShape1.Count > 2)
		{
			list3.Add(roadShape1[2]);
			list6.Add(roadShapeUVs1[2]);
			if (roadShapeMaterialInts1.Count > 2)
			{
				list5.Add(roadShapeMaterialInts1[2]);
			}
			list9.Add(item: true);
			if (roadShape1.Count > 3)
			{
				list3.Add(roadShape1[3]);
				list6.Add(roadShapeUVs1[3]);
				if (roadShapeMaterialInts1.Count > 3)
				{
					list5.Add(roadShapeMaterialInts1[3]);
				}
				list9.Add(item: true);
			}
		}
		else
		{
			list3.Add(roadShape1[1]);
			list6.Add(roadShapeUVs1[1]);
			list5.Add(roadShapeMaterialInts1[1]);
			list9.Add(item: true);
		}
		if (roadShape1.Count >= 3)
		{
			list3.Clear();
			list6.Clear();
			list5.Clear();
			list9.Clear();
			for (int num6 = 0; num6 < roadShape1.Count; num6++)
			{
				list3.Add(roadShape1[num6]);
				list6.Add(roadShapeUVs1[num6]);
				if (roadShapeMaterialInts1.Count > num6)
				{
					list5.Add(roadShapeMaterialInts1[num6]);
				}
				list9.Add(item: true);
			}
		}
		if (splinePoints2.Count > 0)
		{
			num5 = 1;
			index = 0;
			index2 = 1;
			list4.Add(roadShape2[0]);
			list7.Add(roadShapeUVs2[0]);
			list8.Add(roadShapeMaterialInts2[0]);
			list10.Add(item: true);
			if (roadShape2.Count > 2)
			{
				num5 = 2;
				index = 1;
				index2 = 2;
				list4.Add(roadShape2[1]);
				list7.Add(roadShapeUVs2[1]);
				list8.Add(roadShapeMaterialInts2[1]);
				list10.Add(item: true);
			}
			if (subdivide2 > 0)
			{
				for (int num7 = num5; num7 < num5 + subdivide2; num7++)
				{
					list4.Add(Vector2.Lerp(roadShape2[index], roadShape2[index2], (float)(num7 - num5 + 1) / ((float)subdivide2 + 1f)));
					list7.Add(Mathf.Lerp(roadShapeUVs2[index], roadShapeUVs2[index2], (float)(num7 - num5 + 1) / ((float)subdivide2 + 1f)));
					list8.Add(roadShapeMaterialInts2[index]);
					list10.Add(item: false);
				}
			}
			if (roadShape2.Count > 2)
			{
				list4.Add(roadShape2[2]);
				list7.Add(roadShapeUVs2[2]);
				list8.Add(roadShapeMaterialInts2[2]);
				list10.Add(item: true);
				if (roadShape2.Count > 3)
				{
					list4.Add(roadShape2[3]);
					list7.Add(roadShapeUVs2[3]);
					list8.Add(roadShapeMaterialInts2[3]);
					list10.Add(item: true);
				}
			}
			else
			{
				list4.Add(roadShape2[1]);
				list7.Add(roadShapeUVs2[1]);
				list8.Add(roadShapeMaterialInts2[1]);
				list10.Add(item: true);
			}
			if (roadShape2.Count >= 3)
			{
				list4.Clear();
				list7.Clear();
				list8.Clear();
				list10.Clear();
				for (int num8 = 0; num8 < roadShape2.Count; num8++)
				{
					list4.Add(roadShape2[num8]);
					list7.Add(roadShapeUVs2[num8]);
					list8.Add(roadShapeMaterialInts2[num8]);
					list10.Add(item: true);
				}
			}
		}
		List<List<int>> tris = new List<List<int>>();
		for (int num9 = 0; num9 < roadMaterials1.Count; num9++)
		{
			tris.Add(new List<int>());
		}
		List<List<int>> tris2 = new List<List<int>>();
		for (int num10 = 0; num10 < roadMaterials2.Count; num10++)
		{
			tris2.Add(new List<int>());
		}
		int num11 = 0;
		float num12 = 0f;
		float num13 = 0f;
		float num14 = 0f;
		List<Vector3> list11 = new List<Vector3>();
		List<Vector3> list12 = new List<Vector3>();
		OQQCQCCODO(splinePoints1, splinePoints2, ref vecs, ref uvs, ref tris, list3, list6, list5, uvRatio, road1Stretch, road1StretchType, ref list11, ref list12, flag, centerDir, 0, startEnd);
		leftPoints.AddRange(list12);
		rightPoints.AddRange(list11);
		list11.Clear();
		list12.Clear();
		if (splinePoints2.Count > 0)
		{
			OQQCQCCODO(splinePoints2, splinePoints1, ref vecs2, ref uvs2, ref tris2, list4, list7, list8, uvRatio2, road2Stretch, road2StretchType, ref list11, ref list12, !flag2, -centerDir, 1, startEnd2);
		}
		list11.Reverse();
		list12.Reverse();
		leftPoints.AddRange(list11);
		rightPoints.AddRange(list12);
		int count = vecs.Count;
		int road2Start = count;
		list2.AddRange(uvs2);
		if (blendDistance >= 0f && road1 != null && road2 != null && textureType == 1)
		{
			uvs2.Clear();
			uvs2 = OODCQQQQCQ(uvs[uvs.Count - 1].y, splinePoints2, list7, uvRatio, flag, list6[0]);
			if (splinePoints2.Count > 0)
			{
				list = OODCQQQQCQ(uvs2[uvs2.Count - 1].y, splinePoints1, list6, uvRatio2, flag2, list7[0]);
			}
			OCOQOQOCOQ(ref colors, splinePoints1, splinePoints2, list3, list4);
		}
		else if (textureType != 2)
		{
		}
		vecs.AddRange(vecs2);
		if (connectorLength1 == 0f || blendSection == 1)
		{
			uvs.AddRange(list2);
		}
		else
		{
			uvs.AddRange(uvs2);
		}
		list.AddRange(list2);
		if (connectorLength1 == 0f)
		{
			roadMaterials1 = roadMaterials2;
		}
		for (int num15 = 0; num15 < tris2.Count; num15++)
		{
			if (tris2[num15].Count <= 0)
			{
				continue;
			}
			int num16 = -1;
			for (int num17 = 0; num17 < tris.Count; num17++)
			{
				if (roadMaterials2[num15] == roadMaterials1[num17] || roadMaterials2[num15] == null)
				{
					num16 = num17;
					break;
				}
				if (num16 == -1)
				{
					tris.Add(new List<int>());
					num16 = tris.Count - 1;
					roadMaterials1.Add(roadMaterials2[num15]);
				}
			}
			for (int num18 = 0; num18 < tris2[num15].Count; num18++)
			{
				tris[num16].Add(tris2[num15][num18] + count);
			}
		}
		if (textureType == 1 && blendMaterial != null)
		{
			for (int num19 = 0; num19 < roadMaterials1.Count; num19++)
			{
				if (blendSection == 0)
				{
					if (roadMaterials1[num19] == road1Material || roadMaterials1[num19] == road2Material)
					{
						roadMaterials1[num19] = blendMaterial;
					}
				}
				else if (blendSection == 1 && roadMaterials1[num19] == road1Material)
				{
					roadMaterials1[num19] = blendMaterial;
				}
				else if (blendSection == 2 && roadMaterials1[num19] == road2Material)
				{
					roadMaterials1[num19] = blendMaterial;
				}
			}
		}
		else if (textureType == 2 && transitionMaterial != null)
		{
			for (int num20 = 0; num20 < roadMaterials1.Count; num20++)
			{
				roadMaterials1[num20] = transitionMaterial;
			}
		}
		bool hasMesh = true;
		if (splinePoints1.Count <= 1 && splinePoints2.Count <= 1)
		{
			if ((bool)base.gameObject.GetComponent<MeshRenderer>())
			{
				UnityEngine.Object.DestroyImmediate(base.gameObject.GetComponent<MeshRenderer>());
			}
			if ((bool)base.gameObject.GetComponent<MeshFilter>())
			{
				UnityEngine.Object.DestroyImmediate(base.gameObject.GetComponent<MeshFilter>());
			}
			if ((bool)base.gameObject.GetComponent<MeshCollider>())
			{
				UnityEngine.Object.DestroyImmediate(base.gameObject.GetComponent<MeshCollider>());
			}
			hasMesh = false;
		}
		else
		{
			Mesh mesh = ODDDOCDCQO();
			base.gameObject.GetComponent<MeshRenderer>().sharedMaterials = roadMaterials1.ToArray();
			mesh.vertices = vecs.ToArray();
			mesh.uv = uvs.ToArray();
			if (list.Count > 0 && textureType == 1)
			{
				mesh.uv4 = list.ToArray();
			}
			if (colors.Count > 0)
			{
				mesh.colors = colors.ToArray();
			}
			mesh.tangents = new Vector4[vecs.Count];
			mesh.subMeshCount = tris.Count;
			for (int num21 = 0; num21 < tris.Count; num21++)
			{
				mesh.SetTriangles(tris[num21].ToArray(), num21);
			}
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			ODCCODOCQQ.OCDCQCOQQO(mesh);
			base.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
		}
		OCDCCQQQCO(leftPoints, rightPoints, ref surfaceMesh, base.transform, ref surfaceVecs, indentLeftStart, indentLeftEnd, surroundingLeftStart, surroundingLeftEnd, indentRightStart, indentRightEnd, surroundingRightStart, surroundingRightEnd, baseScript, hasMesh);
		if (connectorLength2 == 0f)
		{
			flag2 = false;
		}
		GetIConnectionData(vecs, list9, list10, flag, flag2, road2Start);
		if (sourceRoad != null)
		{
			if (sourceRoad == road1 && road2 != null)
			{
				road2.OCQOQCDCQC(ignorePrefabAlignment: true, forceAutoRotate: false);
			}
			else if (sourceRoad == road2 && road1 != null)
			{
				road1.OCQOQCDCQC(ignorePrefabAlignment: true, forceAutoRotate: false);
			}
		}
	}

	public void GetIConnectionData(List<Vector3> vecs1, List<bool> conInts1, List<bool> conInts2, bool reversed1, bool reversed2, int road2Start)
	{
		if (base.gameObject.GetComponent<ERCrossingPrefabs>() == null)
		{
			base.gameObject.AddComponent<ERCrossingPrefabs>();
		}
		if (prefabScript == null)
		{
			prefabScript = base.gameObject.GetComponent<ERCrossingPrefabs>();
		}
		if (prefabScript.crossingElements.Count < 4)
		{
			for (int i = prefabScript.crossingElements.Count; i < 4; i++)
			{
				prefabScript.crossingElements.Add(new QDOODOQQDQODD());
			}
		}
		prefabScript.meshVecs = vecs1.ToArray();
		prefabScript.tmpMeshVecs = new Vector3[prefabScript.meshVecs.Length];
		Array.Copy(prefabScript.meshVecs, prefabScript.tmpMeshVecs, prefabScript.meshVecs.Length);
		prefabScript.tmpFullMeshVecs = new Vector3[prefabScript.meshVecs.Length];
		Array.Copy(prefabScript.meshVecs, prefabScript.tmpFullMeshVecs, prefabScript.meshVecs.Length);
		prefabScript.fullMeshVecs = new Vector3[prefabScript.meshVecs.Length];
		Array.Copy(prefabScript.meshVecs, prefabScript.fullMeshVecs, prefabScript.meshVecs.Length);
		prefabScript.surfaceMeshVecs = (prefabScript.tmpSurfaceMeshVecs = surfaceVecs.ToArray());
		prefabScript.crossingElements[0].centerPoint = (prefabScript.crossingElements[0].tmpCenterPoint = splinePoints1[0]);
		prefabScript.crossingElements[0].controlPointV3 = Vector3.zero;
		prefabScript.crossingElements[0].alignmentHandleVec = Vector3.zero;
		if (splinePoints2.Count > 0)
		{
			prefabScript.crossingElements[1].centerPoint = (prefabScript.crossingElements[1].tmpCenterPoint = splinePoints2[0]);
		}
		else
		{
			prefabScript.crossingElements[1].centerPoint = (prefabScript.crossingElements[1].tmpCenterPoint = Vector3.zero);
		}
		prefabScript.crossingElements[1].controlPointV3 = Vector3.zero;
		prefabScript.crossingElements[1].alignmentHandleVec = Vector3.zero;
		prefabScript.surfaceInts = new int[16];
		prefabScript.surfaceInts[0] = 1;
		prefabScript.surfaceInts[1] = 0;
		prefabScript.surfaceInts[2] = 2;
		prefabScript.surfaceInts[3] = 3;
		prefabScript.surfaceInts[4] = surfaceVecs.Count - 2;
		prefabScript.surfaceInts[5] = surfaceVecs.Count - 1;
		prefabScript.surfaceInts[6] = surfaceVecs.Count - 3;
		prefabScript.surfaceInts[7] = surfaceVecs.Count - 4;
		prefabScript.surfaceVecs = new List<Vector3>(surfaceVecs);
		prefabScript.crossingElements[0].connectionVecInts.Clear();
		prefabScript.crossingElements[0].fullConnectionVecInts.Clear();
		prefabScript.crossingElements[1].connectionVecInts.Clear();
		prefabScript.crossingElements[2].fullConnectionVecInts.Clear();
		List<int> list = new List<int>();
		for (int j = 0; j < conInts1.Count; j++)
		{
			if (conInts1[j])
			{
				list.Add(j);
			}
		}
		if (reversed1)
		{
			list.Reverse();
		}
		prefabScript.crossingElements[0].connectionVecInts = new List<int>(list);
		prefabScript.crossingElements[0].fullConnectionVecInts = new List<int>(list);
		int mostLeftInt = 0;
		int mostRightInt = list.Count - 1;
		GetLeftRightInts(roadShape1, ref mostLeftInt, ref mostRightInt);
		prefabScript.crossingElements[0].leftInt = mostLeftInt;
		prefabScript.crossingElements[0].leftIntFull = mostLeftInt;
		prefabScript.crossingElements[0].rightInt = mostRightInt;
		prefabScript.crossingElements[0].rightIntFull = mostRightInt;
		prefabScript.crossingElements[0].leftSurroundingV3 = surfaceVecs[0];
		prefabScript.crossingElements[0].rightSurroundingV3 = surfaceVecs[3];
		prefabScript.crossingElements[0].leftIndentV3 = surfaceVecs[1];
		prefabScript.crossingElements[0].rightIndentV3 = surfaceVecs[2];
		prefabScript.crossingElements[0].centerPoint = (prefabScript.crossingElements[0].tmpCenterPoint = base.transform.InverseTransformPoint(splinePoints1[0]));
		if (prefabScript.crossingElements[0].centerPoint == Vector3.zero)
		{
			prefabScript.crossingElements[0].centerPoint = (prefabScript.crossingElements[0].tmpCenterPoint = -centerDir * 3f);
		}
		if (prefabScript.crossingElements[0].connectedRoad != null && prefabScript.crossingElements[0].connectedMarker < prefabScript.crossingElements[0].connectedRoad.markersExt.Count)
		{
			if (splinePoints1[0] != base.transform.position)
			{
				prefabScript.crossingElements[0].connectedRoad.markersExt[prefabScript.crossingElements[0].connectedMarker].position = splinePoints1[0];
			}
			else
			{
				prefabScript.crossingElements[0].connectedRoad.markersExt[prefabScript.crossingElements[0].connectedMarker].position = splinePoints1[0] + -centerDir * 3f;
			}
		}
		prefabScript.crossingElements[1].leftSurroundingV3 = prefabScript.crossingElements[0].rightSurroundingV3;
		prefabScript.crossingElements[1].rightSurroundingV3 = prefabScript.crossingElements[0].leftSurroundingV3;
		prefabScript.crossingElements[1].leftIndentV3 = prefabScript.crossingElements[0].rightIndentV3;
		prefabScript.crossingElements[1].rightIndentV3 = prefabScript.crossingElements[0].leftIndentV3;
		if (splinePoints2.Count > 0)
		{
			list.Clear();
			for (int k = 0; k < conInts2.Count; k++)
			{
				if (conInts2[k])
				{
					list.Add(road2Start + k);
				}
			}
			if (reversed2)
			{
				list.Reverse();
			}
			prefabScript.crossingElements[1].connectionVecInts = new List<int>(list);
			prefabScript.crossingElements[1].fullConnectionVecInts = new List<int>(list);
			mostLeftInt = 0;
			mostRightInt = list.Count - 1;
			GetLeftRightInts(roadShape2, ref mostLeftInt, ref mostRightInt);
			prefabScript.crossingElements[1].leftInt = mostLeftInt;
			prefabScript.crossingElements[1].leftIntFull = mostLeftInt;
			prefabScript.crossingElements[1].rightInt = mostRightInt;
			prefabScript.crossingElements[1].rightIntFull = mostRightInt;
			if (splinePoints2.Count == 1)
			{
				float num = Vector3.Distance(surfaceVecs[surfaceVecs.Count - 1], surfaceVecs[0]);
				float num2 = Vector3.Distance(surfaceVecs[surfaceVecs.Count - 1], surfaceVecs[3]);
				if (connectorLength1 == 0f && num2 < num)
				{
					prefabScript.crossingElements[1].leftSurroundingV3 = surfaceVecs[surfaceVecs.Count - 1];
					prefabScript.crossingElements[1].rightSurroundingV3 = surfaceVecs[surfaceVecs.Count - 4];
					prefabScript.crossingElements[1].leftIndentV3 = surfaceVecs[surfaceVecs.Count - 2];
					prefabScript.crossingElements[1].rightIndentV3 = surfaceVecs[surfaceVecs.Count - 3];
				}
				else
				{
					prefabScript.crossingElements[1].leftSurroundingV3 = surfaceVecs[surfaceVecs.Count - 4];
					prefabScript.crossingElements[1].rightSurroundingV3 = surfaceVecs[surfaceVecs.Count - 1];
					prefabScript.crossingElements[1].leftIndentV3 = surfaceVecs[surfaceVecs.Count - 3];
					prefabScript.crossingElements[1].rightIndentV3 = surfaceVecs[surfaceVecs.Count - 2];
				}
			}
			else
			{
				prefabScript.crossingElements[1].leftSurroundingV3 = surfaceVecs[surfaceVecs.Count - 1];
				prefabScript.crossingElements[1].rightSurroundingV3 = surfaceVecs[surfaceVecs.Count - 4];
				prefabScript.crossingElements[1].leftIndentV3 = surfaceVecs[surfaceVecs.Count - 2];
				prefabScript.crossingElements[1].rightIndentV3 = surfaceVecs[surfaceVecs.Count - 3];
				prefabScript.crossingElements[1].connectionVecInts.Reverse();
				prefabScript.crossingElements[1].fullConnectionVecInts.Reverse();
			}
			prefabScript.crossingElements[1].centerPoint = (prefabScript.crossingElements[1].tmpCenterPoint = base.transform.InverseTransformPoint(splinePoints2[0]));
		}
		else
		{
			prefabScript.crossingElements[1].centerPoint = (prefabScript.crossingElements[1].tmpCenterPoint = centerDir * 3f);
		}
		if (prefabScript.crossingElements[1].connectedRoad != null && prefabScript.crossingElements[1].connectedMarker < prefabScript.crossingElements[1].connectedRoad.markersExt.Count)
		{
			if (splinePoints2[0] != base.transform.position)
			{
				prefabScript.crossingElements[1].connectedRoad.markersExt[prefabScript.crossingElements[1].connectedMarker].position = splinePoints2[0];
			}
			else
			{
				prefabScript.crossingElements[1].connectedRoad.markersExt[prefabScript.crossingElements[1].connectedMarker].position = splinePoints2[0] + centerDir * 3f;
			}
		}
	}

	public void GetLeftRightInts(List<Vector2> roadShape, ref int mostLeftInt, ref int mostRightInt)
	{
		float num = 100000f;
		float num2 = -100000f;
		for (int i = 0; i < roadShape.Count; i++)
		{
			if (roadShape[i].x < num)
			{
				mostRightInt = i;
				num = roadShape[i].x;
			}
			if (roadShape[i].x > num2)
			{
				mostLeftInt = i;
				num2 = roadShape[i].x;
			}
		}
		if (mostLeftInt > mostRightInt)
		{
			int num3 = mostLeftInt;
			mostLeftInt = mostRightInt;
			mostRightInt = num3;
		}
	}

	public void OQQCQCCODO(List<Vector3> splinePoints, List<Vector3> splinePointsOther, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<List<int>> tris, List<Vector2> roadShape, List<float> roadShapeUVs, List<int> roadShapeMaterialInts, float uvRatio, float stretchRatio, float stretchType, ref List<Vector3> leftPoints, ref List<Vector3> rightPoints, bool reversed, Vector3 cDir, int firstSecond, int startEnd)
	{
		float num = 100f;
		float num2 = -100f;
		for (int i = 0; i < roadShape.Count; i++)
		{
			if (roadShape[i].x < num)
			{
				num = roadShape[i].x;
			}
			if (roadShape[i].x > num2)
			{
				num2 = roadShape[i].x;
			}
		}
		int count = roadShape.Count;
		int num3 = 0;
		int num4 = 0;
		float num5 = 0f;
		float num6 = 0f;
		float num7 = 0f;
		float num8 = 0f;
		for (int j = 1; j < splinePoints.Count; j++)
		{
			num8 += Vector3.Distance(splinePoints[j - 1], splinePoints[j]);
		}
		if (reversed)
		{
			uvRatio *= -1f;
		}
		List<float> list = new List<float>(roadShapeUVs);
		if (reversed)
		{
			list.Reverse();
		}
		float a = 0f;
		float b = 1f;
		if (textureType == 2)
		{
			if (connectorLength1 == 0f || connectorLength2 == 0f)
			{
				if (transitionSwap)
				{
					a = 1f;
					b = 0f;
				}
			}
			else
			{
				float num9 = connectorLength1 + connectorLength2;
				float num10 = connectorLength1 / num9;
				float num11 = connectorLength2 / num9;
				if (firstSecond == 0)
				{
					b = num10;
					if (transitionSwap)
					{
						a = 1f;
						b = 1f - num10;
					}
				}
				else
				{
					a = 1f;
					b = 1f - num11;
					if (transitionSwap)
					{
						a = 0f;
						b = num11;
					}
				}
			}
		}
		Vector3 vector;
		if (splinePoints.Count > 1)
		{
			for (int k = 0; k < splinePoints.Count; k++)
			{
				if (k > 0)
				{
					num7 = Vector3.Distance(splinePoints[k - 1], splinePoints[k]);
					num5 += num7;
				}
				num6 = num5 / uvRatio;
				vector = ((k == 0) ? (splinePoints[k + 1] - splinePoints[k]).normalized : ((k != splinePoints.Count - 1) ? (splinePoints[k + 1] - splinePoints[k - 1]).normalized : ((splinePointsOther.Count != 0) ? cDir : (splinePoints[k] - splinePoints[k - 1]).normalized)));
				Vector3 vector2 = splinePoints[k];
				if (k == splinePoints.Count - 1 && textureType == 2)
				{
					vector2 += vector * 0.0025f;
				}
				vector = new Vector3(0f - vector.z, 0f, vector.x).normalized;
				if (firstSecond != 1 || startEnd == 0)
				{
				}
				for (int l = 0; l < roadShape.Count; l++)
				{
					float num12 = num5 / num8;
					if (stretchType == 1f)
					{
						num12 *= num12;
					}
					else if (stretchType == 2f)
					{
						num12 = Mathf.SmoothStep(0f, 1f, num12);
					}
					float num13 = Mathf.Lerp(roadShape[l].x, roadShape[l].x * stretchRatio, num12);
					Vector3 position = vector2 + vector * num13;
					position.y += roadShape[l].y;
					vecs.Add(base.transform.InverseTransformPoint(position));
					if (textureType != 2)
					{
						uvs.Add(new Vector2(list[l], num6));
					}
					else
					{
						uvs.Add(new Vector2(list[l], Mathf.Lerp(a, b, num5 / num8)));
					}
					if (l == 0)
					{
						num13 = Mathf.Lerp(num, num * stretchRatio, num12);
						leftPoints.Add(base.transform.InverseTransformPoint(splinePoints[k] + vector * num13));
						num13 = Mathf.Lerp(num2, num2 * stretchRatio, num12);
						rightPoints.Add(base.transform.InverseTransformPoint(splinePoints[k] + vector * num13));
					}
					bool flag = true;
					num4 = roadShapeMaterialInts[l];
					if (l < roadShapeMaterialInts.Count - 2 && num4 != roadShapeMaterialInts[l + 1])
					{
						flag = false;
					}
					if (l == roadShape.Count - 1 || k == splinePoints.Count - 1)
					{
						flag = false;
					}
					if (flag)
					{
						if (!reversed)
						{
							tris[num4].Add(k * count + l + num3);
							tris[num4].Add((k + 1) * count + l + 1 + num3);
							tris[num4].Add(k * count + l + 1 + num3);
							tris[num4].Add((k + 1) * count + l + num3);
							tris[num4].Add((k + 1) * count + l + 1 + num3);
							tris[num4].Add(k * count + l + num3);
						}
						else
						{
							tris[num4].Add(k * count + l + num3);
							tris[num4].Add(k * count + l + 1 + num3);
							tris[num4].Add((k + 1) * count + l + 1 + num3);
							tris[num4].Add((k + 1) * count + l + num3);
							tris[num4].Add(k * count + l + num3);
							tris[num4].Add((k + 1) * count + l + 1 + num3);
						}
					}
				}
			}
			return;
		}
		vector = new Vector3(0f - centerDir.z, 0f, centerDir.x).normalized;
		if (firstSecond == 1 && startEnd == 1)
		{
			vector *= -1f;
		}
		for (int m = 0; m < roadShape.Count; m++)
		{
			Vector3 position = splinePoints[0] + vector * roadShape[m].x;
			position.y += roadShape[m].y;
			vecs.Add(base.transform.InverseTransformPoint(position));
			uvs.Add(Vector2.zero);
			if (m == 0)
			{
				leftPoints.Add(base.transform.InverseTransformPoint(splinePoints[0] + vector * num));
				rightPoints.Add(base.transform.InverseTransformPoint(splinePoints[0] + vector * num2));
			}
		}
	}

	public List<Vector2> OODCQQQQCQ(float startY, List<Vector3> splinePoints, List<float> roadShapeUVs, float uvRatio, bool reversed, float sourceUV)
	{
		float num = 0f;
		float num2 = 0f;
		List<Vector2> list = new List<Vector2>();
		List<Vector2> list2 = new List<Vector2>();
		splinePoints.Reverse();
		if (reversed)
		{
			uvRatio *= -1f;
		}
		List<float> list3 = new List<float>(roadShapeUVs);
		if (((double)sourceUV < 0.5 && (double)list3[0] > 0.5) || ((double)sourceUV > 0.5 && (double)list3[0] < 0.5))
		{
			list3.Reverse();
		}
		for (int i = 0; i < splinePoints.Count; i++)
		{
			if (i > 0)
			{
				num += Vector3.Distance(splinePoints[i - 1], splinePoints[i]);
			}
			num2 = num / uvRatio;
			list2.Clear();
			for (int j = 0; j < list3.Count; j++)
			{
				list2.Add(new Vector2(1f - list3[j], startY + num2));
			}
			list.InsertRange(0, list2);
		}
		splinePoints.Reverse();
		return list;
	}

	public void OCOQOQOCOQ(ref List<Color> colors, List<Vector3> splinePoints1, List<Vector3> splinePoints2, List<Vector2> roadShape1, List<Vector2> roadShape2)
	{
		Vector3 position = base.transform.position;
		float num = blendDistance * 0.5f;
		Color white = Color.white;
		float a = 0.5f;
		if (blendSection == 1)
		{
			a = 1f;
		}
		else if (blendSection == 2)
		{
			a = 0f;
		}
		for (int i = 0; i < splinePoints1.Count; i++)
		{
			float num2 = Vector3.Distance(splinePoints1[i], position);
			if (num2 > num)
			{
				white.a = 0f;
			}
			else
			{
				white.a = Mathf.Lerp(a, 0f, num2 / num);
			}
			for (int j = 0; j < roadShape1.Count; j++)
			{
				colors.Add(white);
			}
		}
		a = 0.5f;
		if (blendSection == 1)
		{
			a = 1f;
		}
		else if (blendSection == 2)
		{
			a = 0f;
		}
		for (int k = 0; k < splinePoints2.Count; k++)
		{
			float num3 = Vector3.Distance(splinePoints2[k], position);
			if (num3 > num)
			{
				white.a = 1f;
			}
			else
			{
				white.a = Mathf.Lerp(a, 1f, num3 / num);
			}
			for (int l = 0; l < roadShape2.Count; l++)
			{
				colors.Add(white);
			}
		}
	}

	public void ODDCCDQDCO(ref List<Vector3> targetArray, List<Vector3> otherArray)
	{
		List<Vector3> list = new List<Vector3>(otherArray);
		list.Reverse();
		list.RemoveAt(0);
		targetArray.AddRange(list);
	}

	public void SetUVS(List<Vector3> leftRoundingPoints, List<Vector3> leftPointsIndents, List<Vector3> centerPoints, List<Vector3> rightPointsIndents, List<Vector3> rightRoundingPoints, ref List<Vector2> leftRoundingPointsUV, ref List<Vector2> leftPointsIndentsUV, ref List<Vector2> centerPointsUV, ref List<Vector2> rightPointsIndentsUV, ref List<Vector2> rightRoundingPointsUV, ref Vector2 cp, float leftIndentUVX, float rightIndentUVX)
	{
		centerPointsUV.Clear();
		leftRoundingPointsUV.Clear();
		leftPointsIndentsUV.Clear();
		rightRoundingPointsUV.Clear();
		rightPointsIndentsUV.Clear();
		float num = 0.2f;
		float num2 = 0f;
		centerPointsUV.Add(new Vector2(0.5f, 0f));
		for (int i = 1; i < centerPoints.Count; i++)
		{
			num2 += Vector3.Distance(centerPoints[i - 1], centerPoints[i]);
			centerPointsUV.Add(new Vector2(0.5f, num2 * num));
		}
		num2 += Vector3.Distance(centerPoints[centerPoints.Count - 1], Vector3.zero);
		cp = new Vector2(0.5f, num2 * num);
		num2 = 0f;
		leftRoundingPointsUV.Add(new Vector2(0f, 0f));
		leftPointsIndentsUV.Add(new Vector2(leftIndentUVX, 0f));
		for (int j = 1; j < leftRoundingPoints.Count; j++)
		{
			num2 += Vector3.Distance(leftRoundingPoints[j - 1], leftRoundingPoints[j]);
			leftRoundingPointsUV.Add(new Vector2(0f, num2 * num));
			leftPointsIndentsUV.Add(new Vector2(leftIndentUVX, num2 * num));
		}
		num2 = 0f;
		rightRoundingPointsUV.Add(new Vector2(1f, 0f));
		rightPointsIndentsUV.Add(new Vector2(rightIndentUVX, 0f));
		for (int k = 1; k < rightRoundingPoints.Count; k++)
		{
			num2 += Vector3.Distance(rightRoundingPoints[k - 1], rightRoundingPoints[k]);
			rightRoundingPointsUV.Add(new Vector2(1f, num2 * num));
			rightPointsIndentsUV.Add(new Vector2(rightIndentUVX, num2 * num));
		}
	}

	public Mesh ODDDOCDCQO()
	{
		Mesh mesh = null;
		if (!base.gameObject.GetComponent<MeshRenderer>())
		{
			base.gameObject.AddComponent<MeshRenderer>();
			base.gameObject.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.Off;
		}
		if (!base.gameObject.GetComponent<MeshFilter>())
		{
			base.gameObject.AddComponent<MeshFilter>();
		}
		if (!base.gameObject.GetComponent<MeshCollider>())
		{
			base.gameObject.AddComponent<MeshCollider>();
		}
		if (base.gameObject.GetComponent<MeshFilter>().sharedMesh != null)
		{
			mesh = base.gameObject.GetComponent<MeshFilter>().sharedMesh;
		}
		else
		{
			mesh = new Mesh();
			base.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
			base.gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
		}
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		List<Vector2> list3 = new List<Vector2>();
		List<Vector2> list4 = new List<Vector2>();
		List<int> list5 = new List<int>();
		List<Vector3> list6 = new List<Vector3>();
		List<Vector2> list7 = new List<Vector2>();
		List<Vector2> list8 = new List<Vector2>();
		List<Vector2> list9 = new List<Vector2>();
		List<int> list10 = new List<int>();
		List<Color> list11 = new List<Color>();
		List<Color> list12 = new List<Color>();
		bool flag = false;
		int num = 0;
		mesh.Clear();
		return mesh;
	}

	private void OCOQOCDCCQ(ref List<int> tris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<Vector2> uvs1, ref List<Vector2> uvs2, ref List<Color> colors, ref List<int> trisTmp, ref List<Vector3> vecsTmp, ref List<Vector2> uvsTmp, ref List<Vector2> uvsTmp1, ref List<Vector2> uvsTmp2, ref List<Color> colorsTmp, bool skipMiddles, bool weldVecs)
	{
		int count = vecs.Count;
		bool[] array = new bool[trisTmp.Count];
		int num = -1;
		for (int i = 0; i < vecsTmp.Count; i++)
		{
			vecs.Add(vecsTmp[i]);
			uvs.Add(uvsTmp[i]);
			num = vecs.Count - 1;
			for (int j = 0; j < trisTmp.Count; j++)
			{
				if (trisTmp[j] == i && !array[j])
				{
					trisTmp[j] = num;
					array[j] = true;
				}
			}
		}
		tris.AddRange(trisTmp);
		trisTmp.Clear();
		vecsTmp.Clear();
		uvsTmp.Clear();
		uvsTmp1.Clear();
		uvsTmp2.Clear();
		colorsTmp.Clear();
	}

	private void OCQODCOQDO(ref List<int> tris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<Vector2> uvs1, ref List<Vector2> uvs2, ref List<Color> colors, ref List<int> trisTmp, ref List<Vector3> vecsTmp, ref List<Vector2> uvsTmp, ref List<Vector2> uvsTmp1, ref List<Vector2> uvsTmp2, ref List<Color> colorsTmp, bool skipMiddles, bool weldVecs)
	{
		bool[] array = new bool[trisTmp.Count];
		int num = -1;
		for (int i = 0; i < vecsTmp.Count; i++)
		{
			num = -1;
			if ((!skipMiddles || vecsTmp[i].x != 0f) && weldVecs)
			{
				for (int j = 0; j < vecs.Count; j++)
				{
					if (vecsTmp[i] == vecs[j])
					{
						num = j;
						break;
					}
				}
			}
			if (num == -1 || !weldVecs)
			{
				vecs.Add(vecsTmp[i]);
				uvs.Add(uvsTmp[i]);
				num = vecs.Count - 1;
			}
			for (int k = 0; k < trisTmp.Count; k++)
			{
				if (trisTmp[k] == i && !array[k])
				{
					trisTmp[k] = num;
					array[k] = true;
				}
			}
		}
		tris.AddRange(trisTmp);
		trisTmp.Clear();
		vecsTmp.Clear();
		uvsTmp.Clear();
		uvsTmp1.Clear();
		uvsTmp2.Clear();
		colorsTmp.Clear();
	}

	private List<int> Triangulate(List<Vector3> vecs, List<Vector3> edges)
	{
		List<Vector2> list = new List<Vector2>();
		List<PointER> list2 = new List<PointER>();
		for (int i = 0; i < vecs.Count; i++)
		{
			Vector3 vector = vecs[i];
			list2.Add(new PointER(vector.x, vector.z, 0f));
		}
		for (int j = 0; j < edges.Count; j++)
		{
			Vector3 vector = vecs[j];
			list.Add(new Vector2(vector.x, vector.z));
		}
		List<int> list3 = new List<int>();
		List<int> list4 = new List<int>();
		List<TriangleER> list5 = delaunayER.Triangulate(list2);
		for (int k = 0; k < list5.Count; k++)
		{
			list3.Add(delaunayER.FindVertice(new Vector3(list5[k].Vertex1.x, list5[k].Vertex1.z, list5[k].Vertex1.y), vecs));
			list3.Add(delaunayER.FindVertice(new Vector3(list5[k].Vertex3.x, list5[k].Vertex3.z, list5[k].Vertex3.y), vecs));
			list3.Add(delaunayER.FindVertice(new Vector3(list5[k].Vertex2.x, list5[k].Vertex2.z, list5[k].Vertex2.y), vecs));
		}
		for (int l = 0; l < list3.Count; l += 3)
		{
			if (list.Count == 0)
			{
				list4.Add(list3[l]);
				list4.Add(list3[l + 1]);
				list4.Add(list3[l + 2]);
				continue;
			}
			Vector3 vector2 = (vecs[list3[l]] + vecs[list3[l + 1]] + vecs[list3[l + 2]]) / 3f;
			if (ODDCQDDCDD.OCCQDQQDCC(list.Count, list, vector2.x, vector2.z))
			{
				list4.Add(list3[l]);
				list4.Add(list3[l + 1]);
				list4.Add(list3[l + 2]);
			}
		}
		return list4;
	}

	public List<Vector3> OQDDOOOOQD(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, float tension, float res, float distance, ref float tValue)
	{
		List<Vector3> list = new List<Vector3>();
		float num = 0.01f;
		float num2 = 0f;
		Vector3 a = p2;
		bool flag = false;
		bool flag2 = false;
		for (float num3 = 0f; num3 < 1f; num3 += num)
		{
			Vector3 vector = ERModularRoad.OODODQQQCD(p1, p2, p3, p4, num3, tension);
			if (flag && num2 + Vector3.Distance(a, vector) > distance)
			{
				flag2 = true;
			}
			if (Vector3.Distance(a, vector) > res || num3 == 0f || flag2)
			{
				list.Add(vector);
				num2 += Vector3.Distance(a, vector);
				a = vector;
				tValue = num3;
				if (num2 + res > distance)
				{
					flag = true;
				}
				if (flag2)
				{
					break;
				}
			}
		}
		float num4 = num2 / (float)(list.Count - 1);
		for (int i = 1; i < list.Count - 1; i++)
		{
			Vector3 normalized = (list[i] - list[i - 1]).normalized;
			list[i] = list[i - 1] + normalized * num4;
		}
		return list;
	}

	public void OQCDDQOCOD(ref List<Vector3> splinePoints, float distance)
	{
		float num = 0f;
		float num2 = 0f;
		for (int num3 = splinePoints.Count - 1; num3 > 0; num3--)
		{
			num2 = Vector3.Distance(splinePoints[num3], splinePoints[num3 - 1]);
			if (num + num2 > distance)
			{
				if (num + num2 != distance)
				{
					Vector3 normalized = (splinePoints[num3 - 1] - splinePoints[num3]).normalized;
					splinePoints.Insert(num3, splinePoints[num3] + normalized * (distance - num));
				}
				break;
			}
			num += num2;
		}
	}

	public void Clear()
	{
		tvecs.Clear();
		splinePoints1.Clear();
		splinePoints2.Clear();
		surfaceVecs.Clear();
		roadShapeMaterialInts1.Clear();
		roadShapeMaterialInts2.Clear();
		leftRoundingPoints1.Clear();
		centerPoints1.Clear();
		rightRoundingPoints1.Clear();
		leftPointsIndents1.Clear();
		rightPointsIndents1.Clear();
		middlePoints1.Clear();
		leftRoundingPointsUV1.Clear();
		9AAA1.Clear();
		rightRoundingPointsUV1.Clear();
		leftPointsIndentsUV1.Clear();
		rightPointsIndentsUV1.Clear();
		leftRoundingPoints2.Clear();
		centerPoints2.Clear();
		rightRoundingPoints2.Clear();
		leftPointsIndents2.Clear();
		rightPointsIndents2.Clear();
		middlePoints2.Clear();
		leftRoundingPointsUV2.Clear();
		BAAAA.Clear();
		rightRoundingPointsUV2.Clear();
		leftPointsIndentsUV2.Clear();
		rightPointsIndentsUV2.Clear();
		leftPoints.Clear();
		rightPoints.Clear();
		priorityConnectionPoints.Clear();
		priorityConnectionPointsUV.Clear();
		rightPoints12.Clear();
		ll1.Clear();
		ll2.Clear();
		ll3.Clear();
		ll4.Clear();
		cp1Left = Vector3.zero;
		cp1Right = Vector3.zero;
		cp2Left = Vector3.zero;
		cp2Right = Vector3.zero;
		CAAA1 = 0f;
		00AAA = 0f;
	}

	public void OOODDOCOOO()
	{
		if (road1ERTexture != null)
		{
			á = road1ERTexture.roadWidth * road1ERTexture.leftOffset;
			á = road1ERTexture.leftOffset;
			á = road1ERTexture.roadWidth * road1ERTexture.leftInnerOffset;
			4AAAA = road1ERTexture.leftInnerOffset;
			UnityEngine.Debug.Log(road1ERTexture.leftOffset + " " + á + " " + á + " " + á + " " + 4AAAA);
		}
		else
		{
			á = 0.25f;
			á = 0.25f / cornerRadius1;
			á = 0.1f;
			4AAAA = 0.1f / cornerRadius1;
		}
	}

	public void OOOQQDDCCQ(ERTexture roadERTexture, ref float roadWidth, ref float leftIndent, ref float rightIndent, ref float leftUVX, ref float rightUVX, ref float leftIndentInner, ref float rightIndentInner, ref float roadOuterUVXInner, float cornerRadius)
	{
		if (roadERTexture != null)
		{
			roadWidth = roadERTexture.roadWidth;
			leftIndent = roadERTexture.roadWidth * roadERTexture.leftOffset;
			leftUVX = roadERTexture.leftOffset;
			leftIndentInner = roadERTexture.roadWidth * roadERTexture.leftInnerOffset;
			roadOuterUVXInner = roadERTexture.leftInnerOffset;
			rightIndent = roadERTexture.roadWidth * roadERTexture.rightOffset;
			rightIndentInner = roadERTexture.roadWidth * roadERTexture.rightInnerOffset;
			rightUVX = 1f - roadERTexture.rightOffset;
		}
		else
		{
			leftIndent = 0.25f;
			leftUVX = 0.25f / cornerRadius;
			leftIndentInner = 0.1f;
			roadOuterUVXInner = 0.1f / cornerRadius;
			rightIndent = 0.25f;
			rightIndentInner = 0.1f;
			rightUVX = 0.25f / cornerRadius;
		}
	}

	public static void OCDCCQQQCO(List<Vector3> leftPoints, List<Vector3> rightPoints, ref GameObject surfaceMesh, Transform tr, ref List<Vector3> surfaceVecs, float indentLeftStart, float indentLeftEnd, float surroundingLeftStart, float surroundingLeftEnd, float indentRightStart, float indentRightEnd, float surroundingRightStart, float surroundingRightEnd, ERModularBase baseScript, bool hasMesh)
	{
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		List<int> list3 = new List<int>();
		if (leftPoints.Count > 2)
		{
			float num = 0f;
			float num2 = 0f;
			for (int i = 0; i < leftPoints.Count - 1; i++)
			{
				num += Vector3.Distance(leftPoints[i], leftPoints[i + 1]);
			}
			int num3 = 4;
			for (int j = 0; j < leftPoints.Count; j++)
			{
				if (j > 0)
				{
					num2 += Vector3.Distance(leftPoints[j], leftPoints[j - 1]);
				}
				float t = num2 / num;
				t = Mathf.SmoothStep(0f, 1f, t);
				float num4 = Mathf.Lerp(indentLeftStart, indentLeftEnd, t);
				float num5 = Mathf.Lerp(surroundingLeftStart, surroundingLeftEnd, t);
				Vector3 normalized = (leftPoints[j] - rightPoints[j]).normalized;
				Vector3 pos = tr.TransformPoint(leftPoints[j] + normalized * (num4 + num5));
				baseScript.OCDDQOCDCO(ref pos);
				list.Add(tr.InverseTransformPoint(pos));
				list2.Add(new Vector2(0f, 0f));
				pos = leftPoints[j] + normalized * num4;
				list.Add(pos);
				pos.y -= 0.02f;
				list2.Add(new Vector2(0f, 1f));
				num4 = Mathf.Lerp(indentRightStart, indentRightEnd, t);
				num5 = Mathf.Lerp(surroundingRightStart, surroundingRightEnd, t);
				pos = rightPoints[j] + -normalized * num4;
				pos.y -= 0.02f;
				list.Add(pos);
				list2.Add(new Vector2(0f, 1f));
				pos = tr.TransformPoint(rightPoints[j] + -normalized * (num4 + num5));
				baseScript.OCDDQOCDCO(ref pos);
				list.Add(tr.InverseTransformPoint(pos));
				list2.Add(new Vector2(0f, 0f));
				if (j < leftPoints.Count - 1)
				{
					for (int k = 0; k < num3 - 1; k++)
					{
						list3.Add(j * num3 + k);
						list3.Add((j + 1) * num3 + k + 1);
						list3.Add(j * num3 + k + 1);
						list3.Add((j + 1) * num3 + k);
						list3.Add((j + 1) * num3 + k + 1);
						list3.Add(j * num3 + k);
					}
				}
			}
		}
		else
		{
			float num4 = indentLeftStart;
			float num5 = surroundingLeftStart;
			Vector3 normalized = (leftPoints[0] - rightPoints[0]).normalized;
			Vector3 pos = tr.TransformPoint(leftPoints[0] + normalized * (num4 + num5));
			baseScript.OCDDQOCDCO(ref pos);
			list.Add(tr.InverseTransformPoint(pos));
			list2.Add(new Vector2(0f, 0f));
			pos = leftPoints[0] + normalized * num4;
			list.Add(pos);
			pos.y -= 0.02f;
			list2.Add(new Vector2(0f, 0f));
			num4 = indentRightStart;
			num5 = surroundingRightStart;
			pos = rightPoints[0] + -normalized * num4;
			pos.y -= 0.02f;
			list.Add(pos);
			list2.Add(new Vector2(0f, 0f));
			pos = tr.TransformPoint(rightPoints[0] + -normalized * (num4 + num5));
			baseScript.OCDDQOCDCO(ref pos);
			list.Add(tr.InverseTransformPoint(pos));
			list2.Add(new Vector2(0f, 0f));
			num4 = indentLeftEnd;
			num5 = surroundingLeftEnd;
			normalized = (leftPoints[0] - rightPoints[0]).normalized;
			pos = tr.TransformPoint(leftPoints[0] + normalized * (num4 + num5));
			baseScript.OCDDQOCDCO(ref pos);
			list.Add(tr.InverseTransformPoint(pos));
			list2.Add(new Vector2(0f, 0f));
			pos = leftPoints[0] + normalized * num4;
			list.Add(pos);
			pos.y -= 0.02f;
			list2.Add(new Vector2(0f, 0f));
			num4 = indentRightEnd;
			num5 = surroundingRightEnd;
			pos = rightPoints[0] + -normalized * num4;
			pos.y -= 0.02f;
			list.Add(pos);
			list2.Add(new Vector2(0f, 0f));
			pos = tr.TransformPoint(rightPoints[0] + -normalized * (num4 + num5));
			baseScript.OCDDQOCDCO(ref pos);
			list.Add(tr.InverseTransformPoint(pos));
			list2.Add(new Vector2(0f, 0f));
		}
		surfaceVecs = list;
		if (!hasMesh)
		{
			if (surfaceMesh != null)
			{
				UnityEngine.Object.DestroyImmediate(surfaceMesh);
			}
			else if ((bool)tr.Find("surface"))
			{
				surfaceMesh = tr.Find("surface").gameObject;
				if (surfaceMesh != null)
				{
					UnityEngine.Object.DestroyImmediate(surfaceMesh);
				}
			}
			return;
		}
		Mesh mesh = null;
		if (surfaceMesh == null)
		{
			surfaceMesh = new GameObject("surface");
			surfaceMesh.hideFlags = HideFlags.HideInHierarchy;
			surfaceMesh.AddComponent<MeshFilter>();
			surfaceMesh.AddComponent<MeshRenderer>();
			surfaceMesh.AddComponent<MeshCollider>();
			surfaceMesh.AddComponent<ERSurfaceScript>();
			surfaceMesh.GetComponent<MeshRenderer>().material = Resources.Load("Materials/surfaceMaterial") as Material;
			surfaceMesh.transform.parent = tr;
			surfaceMesh.GetComponent<MeshRenderer>().enabled = !baseScript.hideSurfaces;
			surfaceMesh.GetComponent<MeshCollider>().enabled = !baseScript.hideSurfaces;
			surfaceMesh.layer = baseScript.sLayer;
		}
		if (!surfaceMesh.GetComponent<MeshRenderer>())
		{
			surfaceMesh.AddComponent<MeshRenderer>();
		}
		if (!surfaceMesh.GetComponent<MeshFilter>())
		{
			surfaceMesh.AddComponent<MeshFilter>();
		}
		if (!surfaceMesh.GetComponent<MeshCollider>())
		{
			surfaceMesh.AddComponent<MeshCollider>();
		}
		if (surfaceMesh.GetComponent<MeshFilter>().sharedMesh != null)
		{
			mesh = surfaceMesh.GetComponent<MeshFilter>().sharedMesh;
		}
		else
		{
			mesh = new Mesh();
			surfaceMesh.GetComponent<MeshFilter>().sharedMesh = mesh;
			surfaceMesh.GetComponent<MeshCollider>().sharedMesh = mesh;
		}
		surfaceMesh.transform.position = tr.position;
		mesh.Clear();
		mesh.vertices = list.ToArray();
		mesh.uv = list2.ToArray();
		mesh.triangles = list3.ToArray();
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();
		surfaceMesh.GetComponent<MeshCollider>().sharedMesh = null;
		surfaceMesh.GetComponent<MeshCollider>().sharedMesh = mesh;
		if (baseScript.hideSurfaces)
		{
			surfaceMesh.GetComponent<MeshCollider>().enabled = false;
			surfaceMesh.SetActive(value: false);
			surfaceMesh.SetActive(value: true);
		}
	}
}
[Serializable]
public class ERTexture
{
	public Texture2D texture;

	public float roadWidth = 6f;

	public float leftOffset = 0f;

	public float rightOffset = 1f;

	public float leftInnerOffset = 0.1f;

	public float rightInnerOffset = 0.9f;

	public ERTexture(Texture2D _texture, float _roadWidth, float _leftOffset, float _rightOffset, float _leftInnerOffset, float _rightInnerOffset)
	{
		texture = _texture;
		roadWidth = _roadWidth;
		leftOffset = _leftOffset;
		rightOffset = _rightOffset;
		leftInnerOffset = _leftInnerOffset;
		rightInnerOffset = _rightInnerOffset;
	}

	public static ERTexture GetERTexture(Material mat)
	{
		if (mat == null)
		{
			return null;
		}
		if (mat.mainTexture == null)
		{
			return null;
		}
		GameObject gameObject = Resources.Load("ERSideObjectsLog") as GameObject;
		ERSideObjectLog component = gameObject.GetComponent<ERSideObjectLog>();
		for (int i = 0; i < component.textureData.Count; i++)
		{
			if (component.textureData[i].texture == mat.mainTexture)
			{
				return component.textureData[i];
			}
		}
		return null;
	}
}
[AddComponentMenu("")]
public class ERSideObjectLog : MonoBehaviour
{
	public List<SideObjectLog> QOQDQOOQDDQOOQ = new List<SideObjectLog>();

	public List<int> ints = new List<int>();

	public List<QDQDOOQQDQODD> roadPresets = new List<QDQDOOQQDQODD>();

	public List<CrossingCornerClass> crossingCornerPresets = new List<CrossingCornerClass>();

	public List<ERSideWalk> sidewalkPresets = new List<ERSideWalk>();

	public List<ERTexture> textureData = new List<ERTexture>();

	public List<string> presetAssets = new List<string>();

	public int logIndex = 0;

	public int updateInt = 2;

	public void AddRoadPreset(List<SideObject> sceneSideObjects, List<SideObjectLog> projectSideObjects, QDQDOOQQDQODD sourcePreset)
	{
		roadPresets.Add(new QDQDOOQQDQODD(0));
		UpdateRoadPreset(sourcePreset, roadPresets.Count - 1, sceneSideObjects, projectSideObjects, copyShapeData: true);
	}

	public void UpdateRoadPreset(QDQDOOQQDQODD sourcePreset, int element, List<SideObject> sceneSideObjects, List<SideObjectLog> projectSideObjects, bool copyShapeData)
	{
		roadPresets[element].roadTypeName = sourcePreset.roadTypeName;
		roadPresets[element].id = sourcePreset.id;
		roadPresets[element].type = sourcePreset.type;
		if (copyShapeData)
		{
			roadPresets[element].roadShapeData = sourcePreset.roadShapeData;
		}
		roadPresets[element].roadShapeDataActive = sourcePreset.roadShapeDataActive;
		roadPresets[element].timestamp = sourcePreset.timestamp;
		roadPresets[element].roadWidth = sourcePreset.roadWidth;
		roadPresets[element].faceDistance = sourcePreset.faceDistance;
		roadPresets[element].angleTreshold = sourcePreset.angleTreshold;
		roadPresets[element].uvTiling = sourcePreset.uvTiling;
		roadPresets[element].planarUVs = sourcePreset.planarUVs;
		roadPresets[element].outerIndent = sourcePreset.outerIndent;
		roadPresets[element].roadShape = new List<Vector2>(sourcePreset.roadShape);
		roadPresets[element].roadShapeExt = new List<Vector2>(sourcePreset.roadShapeExt);
		roadPresets[element].roadShapeExt2 = new List<Vector2>(sourcePreset.roadShapeExt2);
		roadPresets[element].doConnectionTri = new List<bool>(sourcePreset.doConnectionTri);
		roadPresets[element].roadShapeUVs = new List<float>(sourcePreset.roadShapeUVs);
		roadPresets[element].roadShapeUVs2 = new List<float>(sourcePreset.roadShapeUVs2);
		roadPresets[element].roadShapeExtUVs = new List<float>(sourcePreset.roadShapeExtUVs);
		roadPresets[element].roadShapeExtUVs2 = new List<float>(sourcePreset.roadShapeExtUVs2);
		roadPresets[element].hardEdge = new List<bool>(sourcePreset.hardEdge);
		roadPresets[element].roadShapeVecsString = sourcePreset.roadShapeVecsString;
		roadPresets[element].sidewalks = sourcePreset.sidewalks;
		roadPresets[element].sidewalkHeight = sourcePreset.sidewalkHeight;
		roadPresets[element].sidewalkWidth = sourcePreset.sidewalkWidth;
		roadPresets[element].subSegments = sourcePreset.subSegments;
		roadPresets[element].roadMaterial = sourcePreset.roadMaterial;
		if (sourcePreset.roadMaterials != null)
		{
			roadPresets[element].roadMaterials = new Material[sourcePreset.roadMaterials.Length];
			Array.Copy(sourcePreset.roadMaterials, roadPresets[element].roadMaterials, sourcePreset.roadMaterials.Length);
		}
		roadPresets[element].roadPhysicsMaterial = sourcePreset.roadPhysicsMaterial;
		if (sourcePreset.roadPhysicsMaterials != null)
		{
			roadPresets[element].roadPhysicsMaterials = new PhysicMaterial[sourcePreset.roadPhysicsMaterials.Length];
			Array.Copy(sourcePreset.roadPhysicsMaterials, roadPresets[element].roadPhysicsMaterials, sourcePreset.roadPhysicsMaterials.Length);
		}
		roadPresets[element].connectionMaterial = sourcePreset.connectionMaterial;
		roadPresets[element].isSideObject = sourcePreset.isSideObject;
		roadPresets[element].layer = sourcePreset.layer;
		if (!string.IsNullOrEmpty(sourcePreset.tag))
		{
			roadPresets[element].tag = sourcePreset.tag;
		}
		roadPresets[element].castShadow = sourcePreset.castShadow;
		roadPresets[element].splatMapActive = sourcePreset.splatMapActive;
		roadPresets[element].splatIndex = sourcePreset.splatIndex;
		roadPresets[element].expandLevel = sourcePreset.expandLevel;
		roadPresets[element].smoothLevel = sourcePreset.smoothLevel;
		roadPresets[element].splatOpacity = sourcePreset.splatOpacity;
		roadPresets[element].terrainDeformation = sourcePreset.terrainDeformation;
		roadPresets[element].defaultIndent = sourcePreset.defaultIndent;
		roadPresets[element].defaultSurrounding = sourcePreset.defaultSurrounding;
		roadPresets[element].followTerrainContours = sourcePreset.followTerrainContours;
		roadPresets[element].terrainContoursOffset = sourcePreset.terrainContoursOffset;
		roadPresets[element].randomYPosition = sourcePreset.randomYPosition;
		roadPresets[element].randomMinYPosition = sourcePreset.randomMinYPosition;
		roadPresets[element].randomMaxYPosition = sourcePreset.randomMaxYPosition;
		roadPresets[element].minRandomYPositionDistance = sourcePreset.minRandomYPositionDistance;
		roadPresets[element].maxRandomYPositionDistance = sourcePreset.maxRandomYPositionDistance;
		roadPresets[element].randomMinRotation = sourcePreset.randomMinRotation;
		roadPresets[element].randomMaxRotation = sourcePreset.randomMaxRotation;
		roadPresets[element].minRandomRotationDistance = sourcePreset.minRandomRotationDistance;
		roadPresets[element].maxRandomRotationDistance = sourcePreset.maxRandomRotationDistance;
		roadPresets[element].vegetationStudioMaskLineActive = sourcePreset.vegetationStudioMaskLineActive;
		roadPresets[element].vegetationStudioGrassPerimeter = sourcePreset.vegetationStudioGrassPerimeter;
		roadPresets[element].vegetationStudioPlantPerimeter = sourcePreset.vegetationStudioPlantPerimeter;
		roadPresets[element].vegetationStudioTreePerimeter = sourcePreset.vegetationStudioTreePerimeter;
		roadPresets[element].vegetationStudioObjectPerimeter = sourcePreset.vegetationStudioObjectPerimeter;
		roadPresets[element].vegetationStudioLargeObjectPerimeter = sourcePreset.vegetationStudioLargeObjectPerimeter;
		roadPresets[element].vegetationStudioBiomeMaskActive = sourcePreset.vegetationStudioBiomeMaskActive;
		roadPresets[element].vegetationStudioBiomeMaskDistance = sourcePreset.vegetationStudioBiomeMaskDistance;
		roadPresets[element].vegetationStudioBiomeMaskBlendDistance = sourcePreset.vegetationStudioBiomeMaskBlendDistance;
		roadPresets[element].vegetationStudioBiomeMaskNoiseScale = sourcePreset.vegetationStudioBiomeMaskNoiseScale;
		roadPresets[element].defaultRamp = sourcePreset.defaultRamp;
		roadPresets[element].extrusionType = sourcePreset.extrusionType;
		roadPresets[element].extrusionDistance = sourcePreset.extrusionDistance;
		roadPresets[element].fixedDistance = sourcePreset.fixedDistance;
		roadPresets[element].connectionAngle = sourcePreset.connectionAngle;
		roadPresets[element].connectionRadius = sourcePreset.connectionRadius;
		roadPresets[element].isRoadShape = sourcePreset.isRoadShape;
		for (int i = 0; i < sourcePreset.decalPresets.Count; i++)
		{
			bool flag = false;
			for (int j = 0; j < roadPresets[element].decalClassPresets.Count; j++)
			{
				if (roadPresets[element].decalClassPresets[j].id == sourcePreset.decalPresets[i].id)
				{
					ERDecalClass.CopyDecal(sourcePreset.decalPresets[i], roadPresets[element].decalClassPresets[j]);
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				ERDecalClass eRDecalClass = new ERDecalClass();
				ERDecalClass.CopyDecal(sourcePreset.decalPresets[i], eRDecalClass);
				roadPresets[element].decalClassPresets.Add(eRDecalClass);
			}
		}
		for (int k = 0; k < roadPresets[element].decalPresets.Count; k++)
		{
			bool flag2 = false;
			for (int l = 0; l < sourcePreset.decalPresets.Count; l++)
			{
				if (roadPresets[element].decalPresets[k] != null && sourcePreset.decalPresets[l] != null && roadPresets[element].decalPresets[k].id == sourcePreset.decalPresets[l].id)
				{
					flag2 = true;
					break;
				}
			}
			if (!flag2)
			{
				roadPresets[element].decalPresets.RemoveAt(k);
				k--;
			}
		}
		roadPresets[element].soDataLog.Clear();
		for (int m = 0; m < sceneSideObjects.Count; m++)
		{
			roadPresets[element].soDataLog.Add(new ERSORoadLog(sceneSideObjects[m].id));
		}
		bool flag3 = false;
		for (int n = 0; n < sourcePreset.soDataExt.Count; n++)
		{
			if (sourcePreset.soDataExt[n] != null)
			{
				if (!sourcePreset.soDataExt[n].active)
				{
					continue;
				}
				for (int num = 0; num < roadPresets[element].soDataLog.Count; num++)
				{
					if (sourcePreset.soDataExt[n].sideObject.id == roadPresets[element].soDataLog[num].id)
					{
						roadPresets[element].soDataLog[num].active = true;
						break;
					}
				}
			}
			else
			{
				if (!flag3)
				{
					UnityEngine.Debug.LogWarning("EasyRoads3Dv3 Warning: empty side object data for source preset: " + sourcePreset.roadTypeName);
				}
				flag3 = true;
			}
		}
	}

	public void UpdateTextureList(int element, Texture2D _texture, float _roadWidth, float _leftOffset, float _rightOffset, float _leftInnerOffset, float _rightInnerOffset)
	{
		textureData[element].texture = _texture;
		textureData[element].roadWidth = _roadWidth;
		textureData[element].leftOffset = _leftOffset;
		textureData[element].rightOffset = _rightOffset;
		textureData[element].leftInnerOffset = _leftInnerOffset;
		textureData[element].rightInnerOffset = _rightInnerOffset;
	}
}
[Serializable]
public class ERRoadType
{
	public double id;

	public string roadTypeName = "New Road";

	public List<Vector2> roadShape = new List<Vector2>();

	public List<Vector2> roadShapeExt = new List<Vector2>();

	public List<bool> doConnectionTri = new List<bool>();

	public List<float> roadShapeUVs = new List<float>();

	public List<float> roadShapeExtUVs = new List<float>();

	public List<float> roadShapeUVs2 = new List<float>();

	public List<bool> hardEdge = new List<bool>();

	public float roadWidth = 6f;

	public float faceDistance = 2f;

	public float angleTreshold = 45f;

	public bool sidewalks = false;

	public float sidewalkHeight = 0.2f;

	public float sidewalkWidth = 2f;

	public Material roadMaterial;

	public PhysicMaterial roadPhysicsMaterial;

	public Material connectionMaterial;

	public bool isSideObject = false;

	public List<ERSORoad> soData = new List<ERSORoad>();

	public List<ERSORoadExt> soDataExt = new List<ERSORoadExt>();

	public List<ERSORoadLog> soDataLog = new List<ERSORoadLog>();

	public int layer = 0;

	public string tag = "";

	public bool hasMeshCollider = true;

	public bool terrainDeformation = true;

	private ERRoadShape á;

	public ERRoadType()
	{
		id = DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
	}

	public void Update()
	{
		ERModularBase eRModularBase = UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase;
		if (eRModularBase == null)
		{
			UnityEngine.Debug.Log("No Road Network object was found");
			return;
		}
		bool flag = false;
		foreach (QDQDOOQQDQODD roadType in eRModularBase.roadTypes)
		{
			if (roadType != null && roadType.id == id)
			{
				roadType.roadTypeName = roadTypeName;
				roadType.faceDistance = faceDistance;
				roadType.angleTreshold = angleTreshold;
				roadType.roadWidth = roadWidth;
				roadType.roadMaterial = roadMaterial;
				roadType.roadMaterials = new Material[1];
				roadType.roadMaterials[0] = roadMaterial;
				roadType.roadPhysicsMaterial = roadPhysicsMaterial;
				roadType.isSideObject = isSideObject;
				roadType.layer = layer;
				if (!string.IsNullOrEmpty(tag))
				{
					roadType.tag = tag;
				}
				roadType.terrainDeformation = terrainDeformation;
				roadType.UpdateTimestamp();
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			eRModularBase.roadTypes.Add(new QDQDOOQQDQODD(eRModularBase.roadTypes.Count + 1));
			ODDQODOOOC.OOCOCOOQCC(eRModularBase.QOQDQOOQDDQOOQ, ref eRModularBase.roadTypes[eRModularBase.roadTypes.Count - 1].soDataExt);
			QDQDOOQQDQODD qDQDOOQQDQODD = eRModularBase.roadTypes[eRModularBase.roadTypes.Count - 1];
			qDQDOOQQDQODD.roadTypeName = roadTypeName;
			qDQDOOQQDQODD.roadWidth = roadWidth;
			qDQDOOQQDQODD.faceDistance = faceDistance;
			qDQDOOQQDQODD.angleTreshold = angleTreshold;
			qDQDOOQQDQODD.roadMaterial = roadMaterial;
			qDQDOOQQDQODD.roadMaterials = new Material[1];
			qDQDOOQQDQODD.roadMaterials[0] = roadMaterial;
			qDQDOOQQDQODD.roadPhysicsMaterial = roadPhysicsMaterial;
			qDQDOOQQDQODD.isSideObject = isSideObject;
			qDQDOOQQDQODD.layer = layer;
			if (!string.IsNullOrEmpty(tag))
			{
				qDQDOOQQDQODD.tag = tag;
			}
			qDQDOOQQDQODD.terrainDeformation = terrainDeformation;
			qDQDOOQQDQODD.UpdateTimestamp();
		}
	}

	public static QDQDOOQQDQODD GetRoadType(ERRoadType t, ERModularBase baseScript)
	{
		foreach (QDQDOOQQDQODD roadType in baseScript.roadTypes)
		{
			if (roadType != null && roadType.id == t.id)
			{
				return roadType;
			}
		}
		return null;
	}
}
[Serializable]
public class ERSORoad
{
	public SideObject sideObject;

	public double id;

	public bool active = false;

	public List<Vector3> vecPositions = new List<Vector3>();

	public bool toggleActive = false;

	public float xPosition = 0f;

	public float yPosition = 0f;

	public Vector3 randomRotation = Vector3.zero;

	public float randomMinRotation = 0f;

	public float randomMaxRotation = 0f;

	public float minRandomRotationDistance = 0f;

	public float maxRandomRotationDistance = 0f;

	public bool xPosChange = false;

	public bool yPosChange = false;

	public bool rotationAngleChange = false;

	public bool rotationDistanceChange = false;

	public bool lockRandomRotations = false;

	public bool randomXPositionChange = false;

	public bool xPositionDistanceChange = false;

	public bool randomYPositionChange = false;

	public bool yPositionDistanceChange = false;

	public float randomXPosition = 0f;

	public float randomMinXPosition = 0f;

	public float randomMaxXPosition = 0f;

	public float minRandomXPositionDistance = 0f;

	public float maxRandomXPositionDistance = 0f;

	public float randomYPosition = 0f;

	public float randomMinYPosition = 0f;

	public float randomMaxYPosition = 0f;

	public float minRandomYPositionDistance = 0f;

	public float maxRandomYPositionDistance = 0f;

	public ERSORoad(SideObject so)
	{
		sideObject = so;
		id = so.id;
	}
}
[Serializable]
public class ERSORoadExt : ScriptableObject
{
	public SideObject sideObject;

	public double id;

	public bool active = false;

	public List<Vector3> vecPositions = new List<Vector3>();

	public bool toggleActive = false;

	public bool autoGenerate = false;

	public bool markerActive = true;

	public float m_distance = 0f;

	public float xPosition = 0f;

	[HideInInspector]
	public float oldXPosition = 0f;

	public float yPosition = 0f;

	public Vector3 randomRotation = Vector3.zero;

	public float randomMinRotation = 0f;

	public float randomMaxRotation = 0f;

	public float minRandomRotationDistance = 0f;

	public float maxRandomRotationDistance = 0f;

	public bool distanceChange = false;

	public bool xPosChange = false;

	public bool yPosChange = false;

	public bool rotationAngleChange = false;

	public bool rotationDistanceChange = false;

	public bool lockRandomRotations = false;

	public bool randomXPositionChange = false;

	public bool randomYPositionChange = false;

	public bool xPositionDistanceChange = false;

	public float randomXPosition = 0f;

	public float randomMinXPosition = 0f;

	public float randomMaxXPosition = 0f;

	public float minRandomXPositionDistance = 0f;

	public float maxRandomXPositionDistance = 0f;

	public Vector3 boxColliderScale = new Vector3(1f, 1f, 1f);

	public bool yPositionDistanceChange = false;

	public float randomYPosition = 0f;

	public float randomMinYPosition = 0f;

	public float randomMaxYPosition = 0f;

	public float minRandomYPositionDistance = 0f;

	public float maxRandomYPositionDistance = 0f;

	public GameObject sourceObject;

	public List<ERSOSection> sections = new List<ERSOSection>();

	public List<GameObject> objects = new List<GameObject>();

	public bool clampToMarkers = false;

	public void Init(SideObject so)
	{
		if (so != null)
		{
			id = so.id;
		}
		else
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3 Error: The side object is not assigned");
		}
		sideObject = so;
	}

	public static ERSORoadExt CreateInstance(SideObject so)
	{
		ERSORoadExt eRSORoadExt = ScriptableObject.CreateInstance<ERSORoadExt>();
		eRSORoadExt.Init(so);
		return eRSORoadExt;
	}

	public static void Copy(ERSORoadExt source, ERSORoadExt target)
	{
		target.m_distance = source.m_distance;
		target.xPosition = source.xPosition;
		target.yPosition = source.yPosition;
		target.randomRotation = source.randomRotation;
		target.randomMinRotation = source.randomMinRotation;
		target.randomMaxRotation = source.randomMaxRotation;
		target.minRandomRotationDistance = source.minRandomRotationDistance;
		target.maxRandomRotationDistance = source.maxRandomRotationDistance;
		target.randomXPosition = source.randomXPosition;
		target.randomMinXPosition = source.randomMinXPosition;
		target.randomMaxXPosition = source.randomMaxXPosition;
		target.minRandomXPositionDistance = source.minRandomXPositionDistance;
		target.maxRandomXPositionDistance = source.maxRandomXPositionDistance;
		target.randomYPosition = source.randomYPosition;
		target.randomMinYPosition = source.randomMinYPosition;
		target.randomMaxYPosition = source.randomMaxYPosition;
		target.minRandomYPositionDistance = source.minRandomYPositionDistance;
		target.maxRandomYPositionDistance = source.maxRandomYPositionDistance;
		target.sourceObject = source.sourceObject;
	}
}
[Serializable]
public class ERSORoadLog
{
	public double id = 0.0;

	public bool active = false;

	public ERSORoadLog(double so)
	{
		id = so;
	}
}
[AddComponentMenu("")]
public class ODDQODOOOC : MonoBehaviour
{
	public static List<Vector3> debugvecs = new List<Vector3>();

	public static bool sidewaysFlag = false;

	public static bool useLastFowardFlag = false;

	public static bool lastvecPositionsArray = false;

	public static int currentSplineInt = 0;

	private static float á = 0f;

	private static float á = 0f;

	private static float á = 0f;

	private static float 4AAAA = 0f;

	private static Vector3 5AAA1 = Vector3.zero;

	private static Vector3 6AAAA = Vector3.zero;

	private static float 7AAA1 = 0.25f;

	private static float 8AAAA = 0f;

	private static float 9AAA1 = 0f;

	private static float BAAAA = 0f;

	private static float CAAA1 = 0f;

	private static Vector3 00AAA = Vector3.zero;

	private static Vector3 10AA1 = Vector3.zero;

	private static float 20AAA = 0.25f;

	private static float 30AA1 = 0f;

	private static float 40AAA = 0f;

	private static float 50AA1 = 0f;

	private static float 60AAA = 0f;

	private static Vector3 70AA1 = Vector3.zero;

	private static Vector3 80AAA = Vector3.zero;

	private static float 90AA1 = 0.25f;

	private static float B0AAA;

	private static float C0AA1 = 0f;

	private static float 01AAA = 0f;

	private static float 11AA1 = 0f;

	private static float 21AAA = 0f;

	private static Vector3 31AA1 = Vector3.zero;

	private static Vector3 41AAA = Vector3.zero;

	private static float 51AA1 = 0.25f;

	private static Bounds 61AAA;

	private static int 71AA1 = 0;

	private static int 81AAA = 1;

	private static int 91AA1 = 0;

	private static bool B1AAA = true;

	private static bool C1AA1 = false;

	private static bool 02AAA = false;

	public static void OOCOCOOQCC(List<SideObject> QOQDQOOQDDQOOQ, ref List<ERSORoadExt> soDataExt)
	{
		for (int i = 0; i < soDataExt.Count; i++)
		{
			if (soDataExt[i] == null)
			{
				soDataExt.RemoveAt(i);
				i--;
				continue;
			}
			bool flag = false;
			for (int j = 0; j < QOQDQOOQDDQOOQ.Count; j++)
			{
				if (QOQDQOOQDDQOOQ[j] != null && soDataExt[i].id == QOQDQOOQDDQOOQ[j].id)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				soDataExt.RemoveAt(i);
				i--;
			}
		}
		for (int k = 0; k < QOQDQOOQDDQOOQ.Count; k++)
		{
			bool flag2 = false;
			for (int l = 0; l < soDataExt.Count; l++)
			{
				if (QOQDQOOQDDQOOQ[k] != null && soDataExt[l].id == QOQDQOOQDDQOOQ[k].id)
				{
					flag2 = true;
					break;
				}
			}
			if (!flag2)
			{
				soDataExt.Add(ERSORoadExt.CreateInstance(QOQDQOOQDDQOOQ[k]));
			}
		}
	}

	public static void OOCDDOCODO(ERModularBase scr, SideObject so)
	{
		for (int i = 0; i < scr.roadTypes.Count; i++)
		{
			bool flag = false;
			for (int j = 0; j < scr.roadTypes[i].soDataExt.Count; j++)
			{
				if (scr.roadTypes[i].soDataExt[j] != null && scr.roadTypes[i].soDataExt[j].id == so.id)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				scr.roadTypes[i].soDataExt.Add(ERSORoadExt.CreateInstance(so));
			}
		}
		ERModularRoad[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERModularRoad)) as ERModularRoad[];
		ERModularRoad[] array2 = array;
		foreach (ERModularRoad eRModularRoad in array2)
		{
			bool flag2 = false;
			foreach (ERSORoadExt item in eRModularRoad.soDataExt)
			{
				if (item.id == so.id)
				{
					flag2 = true;
					break;
				}
			}
			if (!flag2)
			{
				eRModularRoad.soDataExt.Add(ERSORoadExt.CreateInstance(so));
			}
			foreach (ERMarkerExt item2 in eRModularRoad.markersExt)
			{
			}
			eRModularRoad.sideObjectNames = OODDQDQDOQ(eRModularRoad);
		}
	}

	public static void OQOCQOCDOO(ERModularBase scr, SideObject so)
	{
		if (so == null)
		{
			return;
		}
		for (int i = 0; i < scr.roadTypes.Count; i++)
		{
			for (int j = 0; j < scr.roadTypes[i].soDataExt.Count; j++)
			{
				try
				{
					if (scr.roadTypes[i].soDataExt[j].sideObject.id == so.id)
					{
						scr.roadTypes[i].soDataExt.RemoveAt(j);
						break;
					}
				}
				catch
				{
					if (scr.roadTypes[i] != null && scr.roadTypes[i].soDataExt[j] != null)
					{
						UnityEngine.Debug.Log("Removing side object " + so.name + " from road type " + scr.roadTypes[i].roadTypeName + " failed! " + i + " " + j + " " + scr.roadTypes[i].soDataExt[j].sideObject);
					}
					else if (scr.roadTypes[i] != null)
					{
					}
				}
			}
		}
		ERModularRoad[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERModularRoad)) as ERModularRoad[];
		bool terrainSurfaceFlag = false;
		ERModularRoad[] array2 = array;
		foreach (ERModularRoad eRModularRoad in array2)
		{
			for (int l = 0; l < eRModularRoad.soDataExt.Count; l++)
			{
				try
				{
					if (eRModularRoad.soDataExt[l].sideObject.id == so.id)
					{
						eRModularRoad.soDataExt.RemoveAt(l);
						break;
					}
					ODODCDDCOD(eRModularRoad, so, ref terrainSurfaceFlag);
					scr.sideObjectNames = OODDQDQDOQ(eRModularRoad);
				}
				catch
				{
					UnityEngine.Debug.Log(string.Concat("Removing side object ", so.name, " from road ", eRModularRoad.gameObject.name, " failed! ", l, " ", eRModularRoad.soDataExt[l].sideObject, " ", so.name));
				}
			}
		}
	}

	public static bool ODOOCCCOQD(ERModularRoad scr, SideObject so, bool forceMarkerActive)
	{
		if (scr.markersExt.Count == 0)
		{
			return false;
		}
		int num = 0;
		int num2 = scr.markersExt.Count - 2;
		bool result = false;
		foreach (ERMarkerExt item in scr.markersExt)
		{
			bool flag = true;
			for (int i = 0; i < item.soData.Count; i++)
			{
				if (item.soData[i] != null)
				{
					if (item.soData[i].sideObject == so)
					{
						flag = false;
						break;
					}
				}
				else
				{
					item.soData.RemoveAt(i);
				}
			}
			if (flag)
			{
				item.soData.Add(ERSOMarkerExt.CreateInstance(so, flag: true));
				if (scr.isSideObject || forceMarkerActive)
				{
					item.soData[item.soData.Count - 1].active = true;
				}
				item.soData[item.soData.Count - 1].startOffset = so.defaultStartOffset;
				item.soData[item.soData.Count - 1].endOffset = so.defaultEndOffset;
				item.soData[item.soData.Count - 1].xPosition = so.xPosition;
				OCCQDQOQCO(scr, num);
				if (so.markerActive && so.indentController)
				{
					OCCQQCCDDD.SetMarkerIndentAlignment(item, scr);
					result = true;
				}
				if (so.dualSided)
				{
					item.soData[item.soData.Count - 1].otherSide = ERSOMarkerExt.CreateInstance(so, flag: true);
					InitOtherMarkerSO(scr, item.soData[item.soData.Count - 1], so);
				}
			}
			num++;
		}
		scr.sideObjectNames = OODDQDQDOQ(scr);
		OODQCDDCQO(scr.baseScript, scr, so);
		scr.sosCleared = false;
		return result;
	}

	public static void InitOtherMarkerSO(ERModularRoad scr, ERSOMarkerExt soData, SideObject so)
	{
		if (scr.isSideObject || soData.active)
		{
			soData.otherSide.active = true;
		}
		soData.otherSide.startOffset = soData.startOffset;
		soData.otherSide.endOffset = soData.endOffset;
		soData.otherSide.xPosition = 0f - soData.xPosition;
	}

	public static ERSOMarkerExt[] ODODCDDCOD(ERModularRoad scr, SideObject so, ref bool terrainSurfaceFlag)
	{
		List<ERSOMarkerExt> list = new List<ERSOMarkerExt>();
		if (so == null)
		{
			return list.ToArray();
		}
		int num = 0;
		foreach (ERMarkerExt item in scr.markersExt)
		{
			for (int i = 0; i < item.soData.Count; i++)
			{
				try
				{
					if (item.soData[i].sideObject.id == so.id)
					{
						if (so.markerActive && so.indentController)
						{
							item.leftIndentAlignment = 0;
							item.rightIndentAlignment = 0;
							terrainSurfaceFlag = true;
						}
						list.Add(item.soData[i]);
						item.soData.RemoveAt(i);
						i--;
					}
				}
				catch
				{
					if (item.soData[i] != null)
					{
						UnityEngine.Debug.Log(string.Concat("Removing side object ", so.name, " from road ", scr.gameObject.name, " [markers] failed! ", i, " ", item.soData[i].sideObject, " ", so.name));
					}
				}
			}
			num++;
		}
		scr.sideObjectNames = OODDQDQDOQ(scr);
		ERSideObjectInstance[] componentsInChildren = scr.gameObject.GetComponentsInChildren<ERSideObjectInstance>();
		ERSideObjectInstance[] array = componentsInChildren;
		foreach (ERSideObjectInstance eRSideObjectInstance in array)
		{
			if (eRSideObjectInstance.so != null)
			{
				if (eRSideObjectInstance.so.id == so.id)
				{
					if (Application.isEditor && !Application.isPlaying)
					{
						UnityEngine.Object.DestroyImmediate(eRSideObjectInstance.gameObject);
					}
					else
					{
						UnityEngine.Object.Destroy(eRSideObjectInstance.gameObject);
					}
				}
			}
			else
			{
				string text = "";
				if (eRSideObjectInstance.transform.parent != null)
				{
					text = ", parent object: " + eRSideObjectInstance.transform.parent.gameObject.name;
				}
				UnityEngine.Debug.LogWarning("Side Object detected with empty Side Object Instance: " + eRSideObjectInstance.gameObject.name + text);
			}
		}
		return list.ToArray();
	}

	public static void SynchSideObjects(ERModularRoad scr1, ERModularRoad scr2)
	{
		if (scr1.soDataExt.Count != scr2.soDataExt.Count)
		{
			return;
		}
		for (int i = 0; i < scr1.soDataExt.Count; i++)
		{
			if (!scr2.soDataExt[i].active || scr1.soDataExt[i].active)
			{
				continue;
			}
			scr1.soDataExt[i].active = true;
			int num = 0;
			foreach (ERMarkerExt item in scr1.markersExt)
			{
				item.soData.Add(ERSOMarkerExt.CreateInstance(scr1.soDataExt[i].sideObject, flag: false));
				OCCQDQOQCO(scr1, num);
				num++;
			}
			scr1.sideObjectNames = OODDQDQDOQ(scr1);
		}
		for (int j = 0; j < scr1.soDataExt.Count; j++)
		{
			if (!scr1.soDataExt[j].active || scr2.soDataExt[j].active)
			{
				continue;
			}
			scr2.soDataExt[j].active = true;
			int num2 = 0;
			foreach (ERMarkerExt item2 in scr2.markersExt)
			{
				item2.soData.Add(ERSOMarkerExt.CreateInstance(scr2.soDataExt[j].sideObject, flag: false));
				OCCQDQOQCO(scr2, num2);
				num2++;
			}
			scr2.sideObjectNames = OODDQDQDOQ(scr2);
		}
	}

	public static void OCCQDQOQCO(ERModularRoad scr, int marker)
	{
		List<ERSOMarkerExt> list = new List<ERSOMarkerExt>();
		for (int i = 0; i < scr.soDataExt.Count; i++)
		{
			for (int j = 0; j < scr.markersExt[marker].soData.Count; j++)
			{
				if (scr.markersExt[marker].soData[j] != null && scr.markersExt[marker].soData[j].sideObject != null)
				{
					if (scr.soDataExt[i].sideObject.id == scr.markersExt[marker].soData[j].sideObject.id)
					{
						list.Add(scr.markersExt[marker].soData[j]);
					}
				}
				else
				{
					scr.markersExt[marker].soData.RemoveAt(j);
					j--;
				}
			}
		}
		scr.markersExt[marker].soData = new List<ERSOMarkerExt>(list);
	}

	public static string[] OODDQDQDOQ(ERModularRoad scr)
	{
		List<string> list = new List<string>();
		for (int i = 0; i < scr.soDataExt.Count; i++)
		{
			if (scr.soDataExt[i] != null)
			{
				if (scr.soDataExt[i].sideObject != null)
				{
					if (scr.soDataExt[i].active)
					{
						list.Add(scr.soDataExt[i].sideObject.name);
					}
				}
				else
				{
					scr.soDataExt.RemoveAt(i);
					i--;
				}
			}
			else
			{
				scr.soDataExt.RemoveAt(i);
				i--;
			}
		}
		return list.ToArray();
	}

	public static bool OOQDOCDDCO(ERModularRoad scr, SideObject so, int marker, bool mirrored)
	{
		if (so == null)
		{
			return false;
		}
		foreach (ERSOMarkerExt soDatum in scr.markersExt[marker].soData)
		{
			if (soDatum.id == so.id)
			{
				if (!mirrored)
				{
					return soDatum.active;
				}
				if (mirrored && soDatum.otherSide == null)
				{
					OOQQQDOCDD.OQOQCQQCQQ(scr, so);
					soDatum.otherSide.Copy(soDatum);
				}
				return soDatum.otherSide.active;
			}
		}
		return false;
	}

	public static bool OOQDOCDDCO(ERModularRoad scr, SideObject so, int marker, ref float startOffset, ref float endOffset, ref ERSOMarkerExt soMarker, bool mirrored)
	{
		if (so == null || marker >= scr.markersExt.Count)
		{
			return false;
		}
		bool flag = false;
		if (!scr.closedTrack && marker == scr.markersExt.Count - 1)
		{
			flag = true;
		}
		bool flag2 = true;
		if (marker == 0)
		{
			flag2 = false;
		}
		bool flag3 = true;
		if (marker >= scr.markersExt.Count - 1)
		{
			flag3 = false;
		}
		int num = 0;
		foreach (ERSOMarkerExt soDatum in scr.markersExt[marker].soData)
		{
			if (soDatum == null)
			{
				return false;
			}
			if (soDatum.id == so.id)
			{
				if (mirrored && soDatum.otherSide == null)
				{
					OOQQQDOCDD.OQOQCQQCQQ(scr, so);
					soDatum.otherSide.Copy(soDatum);
				}
				if (flag2)
				{
					if (!mirrored)
					{
						if (scr.markersExt[marker - 1].soData[num].active || !soDatum.active)
						{
							startOffset = 0f;
						}
						else
						{
							startOffset = soDatum.startOffset;
						}
					}
					else
					{
						if (scr.markersExt[marker - 1].soData[num].otherSide == null)
						{
							OOQQQDOCDD.OQOQCQQCQQ(scr, so);
							scr.markersExt[marker - 1].soData[num].otherSide.Copy(scr.markersExt[marker - 1].soData[num]);
						}
						if (scr.markersExt[marker - 1].soData[num].otherSide.active || !soDatum.otherSide.active)
						{
							startOffset = 0f;
						}
						else
						{
							startOffset = soDatum.otherSide.startOffset;
						}
					}
				}
				else if (!mirrored)
				{
					startOffset = soDatum.startOffset;
				}
				else
				{
					startOffset = soDatum.otherSide.startOffset;
				}
				if (flag3 && marker + 1 < scr.markersExt.Count && scr.markersExt[marker + 1].soData.Count != scr.markersExt[marker].soData.Count)
				{
					ERMarkerExt.OOQQCOQDQC(scr.markersExt[marker], scr.markersExt[marker + 1], scr.gameObject.name);
				}
				if (!mirrored)
				{
					if ((flag3 && marker + 1 < scr.markersExt.Count && scr.markersExt[marker + 1].soData[num].active) || !soDatum.active)
					{
						endOffset = 0f;
					}
					else
					{
						endOffset = soDatum.endOffset;
					}
				}
				else
				{
					if (mirrored && marker + 1 <= scr.markersExt.Count - 1 && scr.markersExt[marker + 1].soData[num].otherSide == null)
					{
						OOQQQDOCDD.OQOQCQQCQQ(scr, scr.markersExt[marker + 1].soData[num].sideObject);
						scr.markersExt[marker + 1].soData[num].otherSide.Copy(scr.markersExt[marker + 1].soData[num]);
					}
					if ((flag3 && marker + 1 < scr.markersExt.Count && scr.markersExt[marker + 1].soData[num].otherSide.active) || !soDatum.otherSide.active)
					{
						endOffset = 0f;
					}
					else
					{
						endOffset = soDatum.otherSide.endOffset;
					}
				}
				if (!mirrored)
				{
					soMarker = soDatum;
				}
				else
				{
					soMarker = soDatum.otherSide;
				}
				if (marker == scr.markersExt.Count - 2 && soDatum.endOffset == 0f && soDatum.active)
				{
					useLastFowardFlag = true;
				}
				if (flag)
				{
					return false;
				}
				if (!mirrored)
				{
					return soDatum.active;
				}
				return soDatum.otherSide.active;
			}
			num++;
		}
		return false;
	}

	public static bool GetSidewaysPosition(ERModularRoad scr, SideObject so, ref List<float> sidewaysList, ref bool customNodelistFlag, ref List<List<Vector2>> nodeListValues, ref List<int> shapeTransitionTypes)
	{
		if (so == null)
		{
			return false;
		}
		bool result = false;
		for (int i = 0; i < scr.markersExt.Count; i++)
		{
			if (i > 0 && scr.markersExt[i - 1].soData.Count != scr.markersExt[i].soData.Count)
			{
				ERMarkerExt.OOQQCOQDQC(scr.markersExt[i - 1], scr.markersExt[i], scr.gameObject.name);
			}
			int num = 0;
			foreach (ERSOMarkerExt soDatum in scr.markersExt[i].soData)
			{
				if (soDatum == null)
				{
					return false;
				}
				if (soDatum.id == so.id)
				{
					if (soDatum.splineActive)
					{
						sidewaysList.Add(soDatum.sidewaysDistance);
					}
					else
					{
						sidewaysList.Add(-1E+10f);
					}
					if (soDatum.sidewaysDistance != 0f)
					{
						result = true;
					}
					if (so.objectType == 1)
					{
						if (soDatum.nodeList.Count != so.nodeList.Count)
						{
							soDatum.nodeList = new List<Vector2>(so.nodeList);
						}
						if (ODQDQDQDQO.CompareVector2List(soDatum.nodeList, so.nodeList))
						{
							customNodelistFlag = true;
						}
						nodeListValues.Add(soDatum.nodeList);
						shapeTransitionTypes.Add(soDatum.shapeTransitionType);
						customNodelistFlag = true;
					}
				}
				num++;
			}
		}
		if (scr.closedTrack && nodeListValues.Count > 0)
		{
			nodeListValues.Add(nodeListValues[0]);
			shapeTransitionTypes.Add(shapeTransitionTypes[0]);
		}
		return result;
	}

	public static bool OOQOOQCQQO(ERModularBase scr, ERModularRoad roadScr)
	{
		ERSideObjectInstance[] componentsInChildren = roadScr.gameObject.GetComponentsInChildren<ERSideObjectInstance>();
		ERSideObjectInstance[] array = componentsInChildren;
		foreach (ERSideObjectInstance eRSideObjectInstance in array)
		{
			if ((bool)eRSideObjectInstance.gameObject.GetComponent<MeshFilter>() && eRSideObjectInstance.gameObject.GetComponent<MeshFilter>().sharedMesh != null)
			{
				eRSideObjectInstance.gameObject.GetComponent<MeshFilter>().sharedMesh.Clear();
			}
			if ((bool)eRSideObjectInstance.gameObject.GetComponent<MeshCollider>() && eRSideObjectInstance.gameObject.GetComponent<MeshCollider>().sharedMesh != null)
			{
				eRSideObjectInstance.gameObject.GetComponent<MeshCollider>().sharedMesh.Clear();
			}
			if (eRSideObjectInstance.so != null)
			{
				if (eRSideObjectInstance.so.objectType == 0)
				{
					List<GameObject> list = new List<GameObject>();
					foreach (Transform item in eRSideObjectInstance.transform)
					{
						list.Add(item.gameObject);
					}
					foreach (GameObject item2 in list)
					{
						if (Application.isEditor && !Application.isPlaying)
						{
							UnityEngine.Object.DestroyImmediate(item2);
						}
						else
						{
							UnityEngine.Object.Destroy(item2);
						}
					}
					continue;
				}
				List<GameObject> list2 = new List<GameObject>();
				for (int j = 0; j < eRSideObjectInstance.transform.childCount; j++)
				{
					Transform child = eRSideObjectInstance.transform.GetChild(j);
					list2.Add(child.gameObject);
					if ((bool)child.GetComponent<MeshFilter>() && child.GetComponent<MeshFilter>().sharedMesh != null)
					{
						child.GetComponent<MeshFilter>().sharedMesh = null;
					}
					if ((bool)child.GetComponent<MeshCollider>() && child.GetComponent<MeshCollider>().sharedMesh != null)
					{
						child.GetComponent<MeshCollider>().sharedMesh = null;
					}
					if ((bool)child.GetComponent<BoxCollider>())
					{
						if (Application.isEditor && !Application.isPlaying)
						{
							UnityEngine.Object.DestroyImmediate(child.gameObject);
						}
						else
						{
							UnityEngine.Object.Destroy(child.gameObject);
						}
						j--;
					}
				}
				if (Application.isEditor && !Application.isPlaying)
				{
					foreach (GameObject item3 in list2)
					{
						UnityEngine.Object.DestroyImmediate(item3);
					}
					continue;
				}
				foreach (GameObject item4 in list2)
				{
					UnityEngine.Object.Destroy(item4);
				}
				continue;
			}
			List<GameObject> list3 = new List<GameObject>();
			foreach (Transform item5 in eRSideObjectInstance.transform)
			{
				list3.Add(item5.gameObject);
			}
			if (Application.isEditor && !Application.isPlaying)
			{
				foreach (GameObject item6 in list3)
				{
					UnityEngine.Object.DestroyImmediate(item6);
				}
				continue;
			}
			foreach (GameObject item7 in list3)
			{
				UnityEngine.Object.Destroy(item7);
			}
		}
		for (int k = 0; k < roadScr.soDataExt.Count; k++)
		{
			if (roadScr.soDataExt[k].active)
			{
				return true;
			}
		}
		return false;
	}

	public static void ODQOCCQQCQ(ERModularRoad rScr, SideObject so)
	{
		if (so == null)
		{
			return;
		}
		foreach (ERMarkerExt item in rScr.markersExt)
		{
			for (int i = 0; i < item.soData.Count; i++)
			{
				if (item.soData[i].id == so.id)
				{
					if (so.sidewaysDistanceUpdate == 1 || item.soData[i].sidewaysDistance == so.oldSidwaysDistance)
					{
						item.soData[i].sidewaysDistance = so.splinePosition;
					}
					break;
				}
			}
		}
	}

	public static bool ODOOODCQCD(ERModularRoad road, int marker, int soIndex)
	{
		if (marker == road.markersExt.Count - 1 || !road.markersExt[marker].soData[soIndex].active)
		{
			return false;
		}
		if (marker == 0)
		{
			if (!road.closedTrack)
			{
				return true;
			}
			if (road.markersExt[road.markersExt.Count - 1].soData[soIndex].active)
			{
				return false;
			}
			return true;
		}
		if (road.markersExt[marker - 1].soData[soIndex].active)
		{
			return false;
		}
		return true;
	}

	public static bool OCCODCQODC(ERModularRoad road, int marker, int soIndex)
	{
		if (marker == road.markersExt.Count - 1 || !road.markersExt[marker].soData[soIndex].active)
		{
			return false;
		}
		if (marker == road.markersExt.Count - 2)
		{
			if (!road.closedTrack || !road.markersExt[road.markersExt.Count - 1].soData[soIndex].active)
			{
				return true;
			}
			if (road.markersExt[0].soData[soIndex].active)
			{
				return false;
			}
			return true;
		}
		if (road.markersExt[marker + 1].soData[soIndex].active)
		{
			return false;
		}
		return true;
	}

	public static bool OCOCCOODQC(List<SideObject> list, SideObject so)
	{
		for (int i = 0; i < list.Count; i++)
		{
			if (list[i] == so)
			{
				return true;
			}
		}
		return false;
	}

	public static void ODQCOCOCOQ(ERModularBase scr, ERModularRoad roadScr, SideObject so)
	{
		ERSideObjectInstance[] componentsInChildren = roadScr.gameObject.GetComponentsInChildren<ERSideObjectInstance>();
		ERSideObjectInstance[] array = componentsInChildren;
		foreach (ERSideObjectInstance eRSideObjectInstance in array)
		{
			if (so != null)
			{
				if (eRSideObjectInstance.id != so.id)
				{
					continue;
				}
				if ((bool)eRSideObjectInstance.gameObject.GetComponent<MeshFilter>() && eRSideObjectInstance.gameObject.GetComponent<MeshFilter>().sharedMesh != null)
				{
					eRSideObjectInstance.gameObject.GetComponent<MeshFilter>().sharedMesh.Clear();
				}
				if ((bool)eRSideObjectInstance.gameObject.GetComponent<MeshCollider>() && eRSideObjectInstance.gameObject.GetComponent<MeshCollider>().sharedMesh != null)
				{
					eRSideObjectInstance.gameObject.GetComponent<MeshCollider>().sharedMesh.Clear();
				}
				List<GameObject> list = new List<GameObject>();
				foreach (Transform item in eRSideObjectInstance.transform)
				{
					list.Add(item.gameObject);
				}
				if (Application.isEditor && !Application.isPlaying)
				{
					foreach (GameObject item2 in list)
					{
						UnityEngine.Object.DestroyImmediate(item2);
					}
					continue;
				}
				foreach (GameObject item3 in list)
				{
					UnityEngine.Object.Destroy(item3);
				}
			}
			else
			{
				string text = "";
				if (eRSideObjectInstance.transform.parent != null)
				{
					text = ", parent object: " + eRSideObjectInstance.transform.parent.gameObject.name;
				}
				UnityEngine.Debug.LogWarning("Side Object detected with empty Side Object Instance: " + eRSideObjectInstance.gameObject.name + text);
			}
		}
	}

	public static void ODOODCCDOC(ERModularBase scr, ERModularRoad roadScr, bool isSideObjectFlag)
	{
		for (int i = 0; i < roadScr.soDataExt.Count; i++)
		{
			if (roadScr.soDataExt[i] != null && roadScr.soDataExt[i].active && (!roadScr.isSideObject || isSideObjectFlag))
			{
				OODQCDDCQO(scr, roadScr, roadScr.soDataExt[i].sideObject);
			}
		}
		roadScr.sosCleared = false;
	}

	public static void OODQCDDCQO(ERModularBase scr, ERModularRoad roadScr, SideObject so, bool isParent = true)
	{
		GameObject gameObject = null;
		if (so == null)
		{
			return;
		}
		ERSideObjectInstance[] componentsInChildren = roadScr.gameObject.GetComponentsInChildren<ERSideObjectInstance>();
		ERSideObjectInstance[] array = componentsInChildren;
		foreach (ERSideObjectInstance eRSideObjectInstance in array)
		{
			if (eRSideObjectInstance.so != null)
			{
				if (eRSideObjectInstance.so == so)
				{
					gameObject = eRSideObjectInstance.gameObject;
					break;
				}
				continue;
			}
			string text = "";
			if (eRSideObjectInstance.transform.parent != null)
			{
				text = ", parent object: " + eRSideObjectInstance.transform.parent.gameObject.name;
			}
			UnityEngine.Debug.LogWarning("Side Object detected with empty Side Object Instance: " + eRSideObjectInstance.gameObject.name + text);
		}
		if (gameObject == null || (bool)so.targetObject)
		{
			if ((bool)so.targetObject)
			{
				if ((bool)gameObject)
				{
					if (Application.isEditor && !Application.isPlaying)
					{
						UnityEngine.Object.DestroyImmediate(gameObject);
					}
					else
					{
						UnityEngine.Object.Destroy(gameObject);
					}
				}
				gameObject = UnityEngine.Object.Instantiate(so.targetObject);
				if ((bool)gameObject.GetComponent<MeshFilter>())
				{
					if ((bool)gameObject.GetComponent<MeshFilter>().sharedMesh)
					{
						Mesh sharedMesh = UnityEngine.Object.Instantiate(gameObject.GetComponent<MeshFilter>().sharedMesh);
						gameObject.GetComponent<MeshFilter>().sharedMesh = sharedMesh;
						if ((bool)gameObject.GetComponent<MeshCollider>() && (bool)gameObject.GetComponent<MeshCollider>().sharedMesh)
						{
							gameObject.GetComponent<MeshCollider>().sharedMesh = sharedMesh;
						}
					}
				}
				else
				{
					foreach (Transform item in gameObject.transform)
					{
						if ((bool)item.GetComponent<MeshFilter>().sharedMesh)
						{
							Mesh sharedMesh2 = UnityEngine.Object.Instantiate(item.GetComponent<MeshFilter>().sharedMesh);
							item.GetComponent<MeshFilter>().sharedMesh = sharedMesh2;
							if ((bool)item.GetComponent<MeshCollider>() && (bool)item.GetComponent<MeshCollider>().sharedMesh)
							{
								item.GetComponent<MeshCollider>().sharedMesh = sharedMesh2;
							}
						}
					}
				}
				gameObject.transform.position = Vector3.zero;
				gameObject.transform.eulerAngles = Vector3.zero;
				gameObject.transform.localScale = new Vector3(1f, 1f, 1f);
			}
			else
			{
				gameObject = new GameObject(so.name);
			}
			gameObject.transform.parent = roadScr.transform;
			gameObject.AddComponent<ERSideObjectInstance>();
			gameObject.GetComponent<ERSideObjectInstance>().so = so;
			gameObject.GetComponent<ERSideObjectInstance>().id = so.id;
			gameObject.GetComponent<ERSideObjectInstance>().roadScript = roadScr;
		}
		else
		{
			gameObject.transform.position = Vector3.zero;
			if ((bool)gameObject.GetComponent<MeshRenderer>() && so.material != null && so.material != gameObject.GetComponent<MeshRenderer>().sharedMaterial)
			{
				gameObject.GetComponent<MeshRenderer>().sharedMaterial = so.material;
			}
		}
		gameObject.layer = so.layer;
		gameObject.isStatic = so.isStatic;
		ERSORoadExt soData = null;
		foreach (ERSORoadExt item2 in roadScr.soDataExt)
		{
			if (item2.sideObject == so)
			{
				soData = item2;
				break;
			}
		}
		if (so.objectType == 0)
		{
			if (so.sourceObject == null)
			{
				UnityEngine.Debug.Log("EasyRoads3Dv3: No Source Object has been assigned to this side object (" + so.name + "), side object creation aborted");
				return;
			}
		}
		else if (so.objectType == 1)
		{
			if (so.meshObjects.Count == 0)
			{
				UnityEngine.Debug.Log("EasyRoads3Dv3: no shape is defined for this side object (" + so.name + "), side object creation aborted");
				return;
			}
			if (so.snapList.Count < so.nodeList.Count)
			{
				for (int j = so.snapList.Count; j < so.nodeList.Count; j++)
				{
					so.snapList.Add(item: false);
				}
				so.UpdateTimeStamp();
			}
			if (so.colorList.Count < so.nodeList.Count)
			{
				for (int k = so.colorList.Count; k < so.nodeList.Count; k++)
				{
					so.colorList.Add(Color.white);
				}
				so.UpdateTimeStamp();
			}
			if (so.snapWeightList.Count < so.nodeList.Count)
			{
				for (int l = 0; l < so.nodeList.Count; l++)
				{
					if (so.snapList[l])
					{
						so.snapWeightList.Add(1f);
					}
					else
					{
						so.snapWeightList.Add(0f);
					}
				}
				so.UpdateTimeStamp();
			}
		}
		else if (so.objectType == 2)
		{
			if (so.meshObjects.Count == 0)
			{
				UnityEngine.Debug.Log("EasyRoads3Dv3: no source mesh is defined for this side object (" + so.name + "), side object creation aborted");
				return;
			}
			int childCount = gameObject.transform.childCount;
			if (Application.isEditor && !Application.isPlaying)
			{
				int num;
				for (num = 0; num < gameObject.transform.childCount; num++)
				{
					UnityEngine.Object.DestroyImmediate(gameObject.transform.GetChild(num).gameObject);
					num--;
				}
			}
			else
			{
				int num2;
				for (num2 = 0; num2 < gameObject.transform.childCount; num2++)
				{
					UnityEngine.Object.Destroy(gameObject.transform.GetChild(num2).gameObject);
					num2--;
				}
			}
		}
		if (so.relativeTo != 0)
		{
			if (so.relativeTo == 1)
			{
				OOOCCQDQCC(gameObject, so, roadScr, soData, mirrored: false, !isParent);
			}
			else
			{
				OOOCCQDQCC(gameObject, so, roadScr, soData, mirrored: false, !isParent);
			}
		}
		else
		{
			OOOCCQDQCC(gameObject, so, roadScr, soData, mirrored: false, !isParent);
		}
		if (so.buildOtherSideObjects.Count <= 0)
		{
			return;
		}
		for (int m = 0; m < so.buildOtherSideObjects.Count; m++)
		{
			SideObject sideObject = null;
			for (int n = 0; n < scr.QOQDQOOQDDQOOQ.Count; n++)
			{
				if (scr.QOQDQOOQDDQOOQ[n] != null && scr.QOQDQOOQDDQOOQ[n].id == so.buildOtherSideObjects[m])
				{
					sideObject = scr.QOQDQOOQDDQOOQ[n];
					break;
				}
			}
			if (!(sideObject != null))
			{
				continue;
			}
			bool flag = false;
			for (int num3 = 0; num3 < roadScr.soDataExt.Count; num3++)
			{
				if (roadScr.soDataExt[num3].id == sideObject.id)
				{
					flag = roadScr.soDataExt[num3].active;
					break;
				}
			}
			if (!flag)
			{
				ODQCOCOCOQ(scr, roadScr, sideObject);
				OODQCDDCQO(scr, roadScr, sideObject, isParent: false);
			}
		}
	}

	public static void OOOCCQDQCC(GameObject go, SideObject so, ERModularRoad roadScr, ERSORoadExt soData, bool mirrored, bool isChild)
	{
		if (!isChild && !so.bridgeObject && !so.tunnelObject)
		{
			List<double> list = new List<double>();
			bool flag = false;
			if (SideObject.CheckSOChildActive(roadScr.soSectionList6, so))
			{
				isChild = (flag = true);
			}
			if (!flag && SideObject.CheckSOChildActive(roadScr.soSectionList7, so))
			{
				isChild = (flag = true);
			}
			if (!flag && SideObject.CheckSOChildActive(roadScr.soSectionList2, so))
			{
				isChild = (flag = true);
			}
			if (!flag && SideObject.CheckSOChildActive(roadScr.soSectionList1, so))
			{
				isChild = (flag = true);
			}
		}
		bool flag2 = false;
		02AAA = false;
		foreach (ERSOMarkerExt soDatum in roadScr.markersExt[0].soData)
		{
			if (soDatum == null)
			{
				OOQQQDOCDD.ResetMarkerSOData(roadScr);
			}
			if (mirrored && soDatum.sideObject == so && soDatum.otherSide == null)
			{
				OOQQQDOCDD.OQOQCQQCQQ(roadScr, so);
				soDatum.otherSide.Copy(soDatum);
			}
		}
		debugvecs.Clear();
		List<Vector3> list2 = new List<Vector3>();
		List<Vector2> list3 = new List<Vector2>();
		List<Vector2> list4 = new List<Vector2>();
		List<Color> list5 = new List<Color>();
		List<Vector4> list6 = new List<Vector4>();
		List<float> list7 = new List<float>();
		List<float> list8 = new List<float>();
		List<Vector3> list9 = null;
		List<Vector3> list10 = null;
		List<Vector3> list11 = null;
		List<Vector3> list12 = null;
		List<float> list13 = null;
		6AAAA = Vector2.zero;
		31AA1 = Vector2.zero;
		41AAA = Vector2.zero;
		31AA1 = Vector2.zero;
		useLastFowardFlag = false;
		lastvecPositionsArray = false;
		if (soData != null)
		{
			OOQQQDOCDD.SynchSoData(soData, flag: false);
			list9 = (((so.relativeTo != 1 || mirrored) && !(so.relativeTo == 2 && mirrored) && so.position != 1) ? (((so.relativeTo != 2 || mirrored) && !(so.relativeTo == 1 && mirrored) && so.position != 2) ? new List<Vector3>(roadScr.soSplinePoints) : (so.scaleToRoad ? new List<Vector3>(roadScr.soSplinePointsRightClamped) : new List<Vector3>(roadScr.soSplinePointsRight))) : (so.scaleToRoad ? new List<Vector3>(roadScr.soSplinePointsLeftClamped) : new List<Vector3>(roadScr.soSplinePointsLeft)));
			list12 = new List<Vector3>(roadScr.soSplinePoints);
			if (roadScr.OQCOCCQCCD.Count == 0)
			{
				if (list12.Count == 0)
				{
					return;
				}
				roadScr.OQQOODQCCC = new List<float>();
				roadScr.OQCOCCQCCD = roadScr.OQDOOOQODD(roadScr.tValues, roadScr.markerDistances, roadScr.markersExt, 0, roadScr.tmpMarkersExt.Count, ref roadScr.OQQOODQCCC, roadScr.randomRotations);
			}
			list13 = new List<float>(roadScr.OQCOCCQCCD);
			if (list9.Count > list13.Count)
			{
				int count = list13.Count;
				for (int i = count; i < list9.Count; i++)
				{
					list13.Add(0f);
				}
			}
			if (!so.scaleToRoad)
			{
				list10 = new List<Vector3>(roadScr.soSplinePointsLeft);
				list11 = new List<Vector3>(roadScr.soSplinePointsRight);
			}
			else
			{
				list10 = new List<Vector3>(roadScr.soSplinePointsLeftClamped);
				list11 = new List<Vector3>(roadScr.soSplinePointsRightClamped);
			}
			List<int> markerInts = new List<int>(roadScr.markerInts);
			List<float> sidewaysList = new List<float>();
			sidewaysFlag = false;
			bool customNodelistFlag = false;
			List<List<Vector2>> nodeListValues = new List<List<Vector2>>();
			List<int> shapeTransitionTypes = new List<int>();
			List<float> tValues = new List<float>();
			List<Vector3> tmpMarkers = new List<Vector3>();
			List<float> markerDistances = new List<float>();
			List<List<Vector2>> nodeList = new List<List<Vector2>>();
			if (GetSidewaysPosition(roadScr, so, ref sidewaysList, ref customNodelistFlag, ref nodeListValues, ref shapeTransitionTypes))
			{
				sidewaysFlag = true;
				markerInts.Clear();
				list9 = ODQDQDQDQO.GetSoSplinePoints(roadScr, sidewaysList, ref markerInts, ref tValues, ref markerDistances, ref tmpMarkers);
				list10.Clear();
				list11.Clear();
				for (int j = 0; j < list9.Count; j++)
				{
					Vector3 vector = ((j != 0) ? ((j != list9.Count - 1) ? (list9[j + 1] - list9[j - 1]) : (list9[list9.Count - 1] - list9[list9.Count - 2])) : (list9[j + 1] - list9[j]));
					vector = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
					list10.Add(list9[j] - vector);
					list11.Add(list9[j] + vector);
				}
				list12 = new List<Vector3>(list9);
			}
			else
			{
				sidewaysList.Clear();
				tValues = roadScr.tValues;
				markerDistances = roadScr.markerDistances;
			}
			int num = -1;
			for (int k = 0; k < roadScr.markersExt[0].soData.Count; k++)
			{
				if (roadScr.markersExt[0].soData[k].sideObject == so)
				{
					num = k;
					break;
				}
			}
			if (num == -1 && !isChild)
			{
				return;
			}
			if (so.objectType == 1)
			{
				if (so.hardEdge.Count < so.nodeList.Count)
				{
					so.hardEdge = new List<bool>(new bool[so.nodeList.Count]);
				}
				if (mirrored && so.nodeListMirrored.Count == 0)
				{
					so.OQOQOQOODC();
				}
				if (shapeTransitionTypes.Count < markerDistances.Count)
				{
					if (shapeTransitionTypes.Count == 0)
					{
						shapeTransitionTypes.Add(0);
					}
					for (int l = shapeTransitionTypes.Count; l < markerDistances.Count; l++)
					{
						shapeTransitionTypes.Add(shapeTransitionTypes[shapeTransitionTypes.Count - 1]);
					}
				}
				if (nodeListValues.Count < markerDistances.Count)
				{
					if (nodeListValues.Count == 0)
					{
						nodeListValues.Add(new List<Vector2>(so.nodeList));
					}
					for (int m = nodeListValues.Count; m < markerDistances.Count; m++)
					{
						nodeListValues.Add(new List<Vector2>(nodeListValues[nodeListValues.Count - 1]));
					}
				}
				if (so.nodeList.Count == 0)
				{
					return;
				}
				if (so.clampUVs && so.nodeList.Count != so.uvs.Count)
				{
					so.OOCCDCDOQC();
				}
				if (!customNodelistFlag)
				{
					for (int n = 0; n < so.nodeList.Count; n++)
					{
						nodeList.Add(new List<Vector2>());
						for (int num2 = 0; num2 < list12.Count; num2++)
						{
							nodeList[n].Add(so.nodeList[n]);
						}
					}
				}
				else if (markerDistances.Count != 0)
				{
					nodeList = ODQDQDQDQO.GetRoadShapeValues(tValues, markerDistances, nodeListValues, 0, roadScr.tmpMarkersExt.Count, so.nodeList, shapeTransitionTypes, roadScr.closedTrack);
				}
				else
				{
					UnityEngine.Debug.LogError("EasyRoads3Dv3: Please Refresh the Road Network: General Settings > Scene Settings");
				}
				List<Vector3> list14 = new List<Vector3>();
				if (!isChild)
				{
					for (int num3 = 0; num3 < roadScr.markersExt.Count; num3++)
					{
						int num4 = roadScr.markersExt[num3].startSplinePoint - 1;
						if (num4 >= list9.Count)
						{
							num4 = list9.Count - 1;
						}
						if (num3 == 0)
						{
							num4 = 0;
						}
						Vector3 v = Vector3.zero;
						Vector3 n2 = Vector3.zero;
						Vector3 v2 = list9[num4];
						Vector3 dir = ((list9.Count <= num4 + 1) ? (list9[num4] - list9[num4 - 1]).normalized : (list9[num4 + 1] - list9[num4]).normalized);
						list14.Clear();
						for (int num5 = 0; num5 < so.nodeList.Count; num5++)
						{
							List<Vector2> list15 = null;
							if (roadScr.markersExt[num3].soData.Count <= num)
							{
								list15 = so.nodeList;
							}
							else
							{
								list15 = roadScr.markersExt[num3].soData[num].nodeList;
								if (list15.Count != so.nodeList.Count)
								{
									list15 = so.nodeList;
								}
							}
							if (so.align == 1 || (sidewaysFlag && so.align != 0))
							{
								ODQDQDQDQO.OCCQCDQQOQ(ref v, ref n2, v2, dir, list15[num5], roadScr, 6AAAA);
							}
							else if (so.align == 2 || so.align == 0)
							{
								ODQDQDQDQO.OQODQODDOQ(ref v, ref n2, v2, dir, list15[num5], 0f, 6AAAA);
							}
							else if (so.align == 3)
							{
								ODQDQDQDQO.OQODQODDOQ(ref v, ref n2, v2, dir, list15[num5], list13[num4], 6AAAA);
							}
							list14.Add(v);
						}
						if (roadScr.markersExt[num3].soData.Count > num)
						{
							roadScr.markersExt[num3].soData[num].nodeShapeVecsGlobal = new List<Vector3>(list14);
						}
					}
				}
			}
			List<Vector3> vecPositions = new List<Vector3>(list9);
			List<Vector3> list16 = new List<Vector3>();
			List<Vector3> list17 = new List<Vector3>();
			List<Vector3> list18 = new List<Vector3>(list12);
			List<float> list19 = new List<float>(list13);
			List<float> list20 = new List<float>();
			List<float> list21 = new List<float>();
			List<float> list22 = new List<float>();
			List<List<Vector3>> list23 = new List<List<Vector3>>();
			List<List<Vector3>> list24 = new List<List<Vector3>>();
			List<List<Vector3>> list25 = new List<List<Vector3>>();
			List<List<Vector3>> list26 = new List<List<Vector3>>();
			List<List<float>> list27 = new List<List<float>>();
			List<List<List<Vector2>>> list28 = new List<List<List<Vector2>>>();
			List<List<float>> list29 = new List<List<float>>();
			List<List<float>> list30 = new List<List<float>>();
			List<List<float>> list31 = new List<List<float>>();
			List<List<int>> list32 = new List<List<int>>();
			if (vecPositions.Count != list18.Count || (list18.Count > list19.Count && !sidewaysFlag))
			{
				UnityEngine.Debug.LogWarning("EasyRoads3Dv3 Warning: incomplete spline data, generating " + so.name + " aborted. Please try to refresh the road network (General Settings > Scene Settings)");
				return;
			}
			Vector3 pTarget = Vector3.zero;
			if (roadScr.markerInts.Count == 0)
			{
				return;
			}
			bool flag3 = false;
			if (soData.xPosition == 0f && !isChild)
			{
				for (int num6 = 0; num6 < roadScr.markersExt.Count; num6++)
				{
					if (mirrored && roadScr.markersExt[num6].soData[num].otherSide == null)
					{
						OOQQQDOCDD.OQOQCQQCQQ(roadScr, so);
						roadScr.markersExt[num6].soData[num].otherSide.Copy(roadScr.markersExt[num6].soData[num]);
					}
					if ((!mirrored && roadScr.markersExt[num6].soData[num].xPosition != 0f) || (mirrored && roadScr.markersExt[num6].soData[num].otherSide.xPosition != 0f))
					{
						flag3 = true;
						break;
					}
				}
			}
			if ((soData.xPosition != 0f && so.position == 0 && sidewaysList.Count == 0) || flag3)
			{
				float num7 = soData.xPosition;
				if (mirrored)
				{
					num7 *= -1f;
				}
				vecPositions.Clear();
				markerInts.Clear();
				int num8 = 1;
				int num9 = roadScr.markersExt.Count - 1;
				float num10 = 0f;
				for (int num11 = 0; num11 < list9.Count; num11++)
				{
					if (num8 < num9 && num11 == roadScr.markersExt[num8].startSplinePoint)
					{
						num8++;
					}
					Vector3 vector;
					if (!roadScr.isSideObject)
					{
						vector = (list11[num11] - list10[num11]).normalized;
					}
					else
					{
						vector = ((num11 == 0) ? (list9[1] - list9[0]) : ((num11 != list9.Count - 1) ? (list9[num11 + 1] - list9[num11 - 1]) : (list9[list9.Count - 1] - list9[list9.Count - 2])));
						vector = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
					}
					Vector3 v2 = list9[num11] + num7 * vector;
					if (num11 == 0)
					{
						vecPositions.Add(v2);
						markerInts.Add(roadScr.markerInts[0]);
						pTarget = v2;
					}
					else if (num7 > 0f)
					{
						if (!ODQDQDQDQO.OQCDCDOOCD(pTarget, list9[num11 - 1], v2))
						{
							vecPositions.Add(v2);
							markerInts.Add(roadScr.markerInts[num11]);
							pTarget = v2;
						}
					}
					else if (ODQDQDQDQO.OQCDCDOOCD(pTarget, list9[num11 - 1], v2))
					{
						vecPositions.Add(v2);
						markerInts.Add(roadScr.markerInts[num11]);
						pTarget = v2;
					}
				}
				if (vecPositions.Count <= 1 && list9.Count > 1)
				{
					UnityEngine.Debug.LogError("EasyRoads3Dv3 Error: side object: " + so.name + " - could not extract side object spline points. Please report with full details");
					return;
				}
			}
			else if (so.sidewaysOffset == 0f)
			{
			}
			int num12 = 0;
			float startOffset = 0f;
			float endOffset = 0f;
			int startInt = 0;
			ERSOMarkerExt soMarker = null;
			if (markerInts.Count != vecPositions.Count)
			{
				UnityEngine.Debug.Log("EasyRoads3Dv3 Warning: " + roadScr.name + " Side Object: " + so.name + " Please review the side object status for this road");
				return;
			}
			bool flag4 = OOQDOCDDCO(roadScr, so, 0, ref startOffset, ref endOffset, ref soMarker, mirrored);
			if (flag4 && (startOffset != 0f || roadScr.startOffsetActiveMarker != -1))
			{
				OOQQQDOCDD.OCODDOCODQ(ref startInt, startOffset, ref markerInts, ref vecPositions, ref list10, list11, ref soMarker, roadScr, ref nodeList);
			}
			else if (flag4)
			{
				OOQQQDOCDD.OCQQDCQQCO(0, vecPositions, markerInts, ref soMarker, startFlag: true, roadScr);
			}
			if (flag4 && endOffset != 0f)
			{
				OOQQQDOCDD.OCQCDCDCQC(startInt, endOffset, ref markerInts, ref vecPositions, ref list10, list11, ref soMarker, roadScr, ref nodeList);
			}
			else if (flag4)
			{
				OOQQQDOCDD.OCQQDCQQCO(0, vecPositions, markerInts, ref soMarker, startFlag: false, roadScr);
			}
			bool flag5 = flag4;
			bool flag6 = flag4;
			bool flag7 = false;
			list23.Add(new List<Vector3>());
			list24.Add(new List<Vector3>());
			list25.Add(new List<Vector3>());
			list26.Add(new List<Vector3>());
			list27.Add(new List<float>());
			list29.Add(new List<float>());
			list30.Add(new List<float>());
			list31.Add(new List<float>());
			list32.Add(new List<int>());
			list28.Add(new List<List<Vector2>>());
			for (int num13 = 0; num13 < nodeList.Count; num13++)
			{
				list28[0].Add(new List<Vector2>());
			}
			float num14 = 0f;
			int num15 = 0;
			if (soMarker == null && !isChild)
			{
				return;
			}
			if (soMarker != null && soMarker.rotationAngle != 0f)
			{
				float num16 = soMarker.rotationDistance;
				if (num16 < 3f * so.middleZDistance)
				{
					num16 = 3f * so.middleZDistance;
				}
				list29[0].Add(num14 + soMarker.rotationCenter - num16 * 0.5f);
				list30[0].Add(num16);
				if (!mirrored)
				{
					list31[0].Add(soMarker.rotationAngle);
				}
				else
				{
					list31[0].Add(0f - soMarker.rotationAngle);
				}
			}
			bool flag8 = false;
			int num17 = -1;
			int num18 = -1;
			int num19 = roadScr.exitRoads.Count - 1;
			int num20 = 0;
			if (roadScr.exitRoads.Count > 0)
			{
				flag8 = true;
				num18 = roadScr.exitRoads[0].startSplineIndex;
				num17 = roadScr.exitRoads[0].endSplineIndex;
			}
			int num21 = 0;
			for (int startInt2 = startInt; startInt2 < vecPositions.Count; startInt2++)
			{
				if (flag4)
				{
					if (startInt2 == num18 && so.relativeTo == 2)
					{
						int num22 = roadScr.exitRoads[num20].soPointsRightStart.Count - 1;
						for (int num23 = 0; num23 < roadScr.exitRoads[num20].soPointsRightStart.Count; num23++)
						{
							Vector3 v2 = roadScr.exitRoads[num20].soPointsRightStart[num23];
							if (so.xPosition != 0f)
							{
								Vector3 vector = ((num23 == 0) ? (roadScr.exitRoads[num20].soPointsRightStart[1] - roadScr.exitRoads[num20].soPointsRightStart[0]) : ((num23 != num22) ? (roadScr.exitRoads[num20].soPointsRightStart[startInt2 + 1] - roadScr.exitRoads[num20].soPointsRightStart[startInt2 - 1]) : (roadScr.exitRoads[num20].soPointsRightStart[num22] - roadScr.exitRoads[num20].soPointsRightStart[num22 - 1])));
								vector = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
								v2 = roadScr.exitRoads[num20].soPointsRightStart[num23] + vector * so.xPosition;
							}
							list23[num21].Add(v2);
							list24[num21].Add(v2);
							list25[num21].Add(v2);
						}
						list23.Add(new List<Vector3>());
						list24.Add(new List<Vector3>());
						list25.Add(new List<Vector3>());
						list26.Add(new List<Vector3>());
						list27.Add(new List<float>());
						list28.Add(new List<List<Vector2>>());
						for (int num24 = 0; num24 < nodeList.Count; num24++)
						{
							list28[num21 + 1].Add(new List<Vector2>());
						}
						list29.Add(new List<float>());
						list30.Add(new List<float>());
						list31.Add(new List<float>());
						list32.Add(new List<int>());
						num21++;
						num14 = 0f;
						num15 = 0;
						startInt2 = num17 - 1;
						if (num20 < num19)
						{
							num20++;
							num17 = roadScr.exitRoads[num20].endSplineIndex;
						}
					}
					else
					{
						list23[num21].Add(vecPositions[startInt2]);
						list24[num21].Add(list10[startInt2]);
						list25[num21].Add(list11[startInt2]);
					}
					if (!sidewaysFlag)
					{
						if (list18.Count > startInt2)
						{
							list26[num21].Add(list18[startInt2]);
						}
						else if (list26[num21].Count - 1 < list18.Count)
						{
							list26[num21].Add(list18[list26[num21].Count - 1]);
						}
						if (list19.Count > startInt2)
						{
							list27[num21].Add(list19[startInt2]);
						}
						else
						{
							list27[num21].Add(0f);
						}
					}
					for (int num25 = 0; num25 < nodeList.Count; num25++)
					{
						list28[num21][num25].Add(nodeList[num25][startInt2]);
					}
					if (startInt2 == num17 - 1 && so.relativeTo != 2)
					{
					}
				}
				if (startInt2 >= vecPositions.Count - 1)
				{
					continue;
				}
				if (num12 != markerInts[startInt2])
				{
					flag4 = OOQDOCDDCO(roadScr, so, markerInts[startInt2], ref startOffset, ref endOffset, ref soMarker, mirrored);
					if (list32.Count <= num21)
					{
						list32.Add(new List<int>());
					}
					list32[num21].Add(startInt2 - 2);
					if (flag4 && startOffset != 0f)
					{
						OOQQQDOCDD.OCODDOCODQ(ref startInt2, startOffset, ref markerInts, ref vecPositions, ref list10, list11, ref soMarker, roadScr, ref nodeList);
					}
					else if (flag4)
					{
						OOQQQDOCDD.OCQQDCQQCO(startInt2, vecPositions, markerInts, ref soMarker, startFlag: true, roadScr);
					}
					if (flag4 && endOffset != 0f)
					{
						OOQQQDOCDD.OCQCDCDCQC(startInt2, endOffset, ref markerInts, ref vecPositions, ref list10, list11, ref soMarker, roadScr, ref nodeList);
					}
					else if (flag4)
					{
						OOQQQDOCDD.OCQQDCQQCO(startInt2, vecPositions, markerInts, ref soMarker, startFlag: false, roadScr);
					}
					if (!flag6 && flag4 && list23[num21].Count > 0)
					{
						list23.Add(new List<Vector3>());
						list24.Add(new List<Vector3>());
						list25.Add(new List<Vector3>());
						list26.Add(new List<Vector3>());
						list27.Add(new List<float>());
						list28.Add(new List<List<Vector2>>());
						for (int num26 = 0; num26 < nodeList.Count; num26++)
						{
							list28[num21 + 1].Add(new List<Vector2>());
						}
						list29.Add(new List<float>());
						list30.Add(new List<float>());
						list31.Add(new List<float>());
						num21++;
						num14 = 0f;
						num15 = 0;
						list23[num21].Add(vecPositions[startInt2]);
						list24[num21].Add(list10[startInt2]);
						list25[num21].Add(list11[startInt2]);
						list26[num21].Add(list18[startInt2]);
						if (list19.Count > startInt2)
						{
							list27[num21].Add(list19[startInt2]);
						}
						else
						{
							list27[num21].Add(0f);
						}
						for (int num27 = 0; num27 < nodeList.Count; num27++)
						{
							list28[num21][num27].Add(nodeList[num27][startInt2]);
						}
					}
					else if (!flag6 && flag4)
					{
						list23[num21].Add(vecPositions[startInt2]);
						list24[num21].Add(list10[startInt2]);
						list25[num21].Add(list11[startInt2]);
						list26[num21].Add(list18[startInt2]);
						if (list19.Count > startInt2)
						{
							list27[num21].Add(list19[startInt2]);
						}
						else
						{
							list27[num21].Add(0f);
						}
						for (int num28 = 0; num28 < nodeList.Count; num28++)
						{
							list28[num21][num28].Add(nodeList[num28][startInt2]);
						}
					}
					if (flag4 && startInt2 > 0 && num15 > 0 && soMarker.rotationAngle != 0f)
					{
						float num29 = soMarker.rotationDistance;
						if (num29 < 3f * so.middleZDistance)
						{
							num29 = 3f * so.middleZDistance;
						}
						list29[num21].Add(num14 + soMarker.rotationCenter - num29 * 0.5f);
						list30[num21].Add(num29);
						if (!mirrored)
						{
							list31[num21].Add(soMarker.rotationAngle);
						}
						else
						{
							list31[num21].Add(0f - soMarker.rotationAngle);
						}
					}
					flag6 = flag4;
					num12 = markerInts[startInt2];
				}
				else
				{
					if (flag4 && startInt2 > 0 && num15 > 0)
					{
						num14 += Vector3.Distance(vecPositions[startInt2 - 1], vecPositions[startInt2]);
					}
					num15++;
				}
			}
			List<int> list33 = new List<int>();
			List<bool> list34 = new List<bool>();
			int num30 = list23.Count;
			if (num30 == 1 && list23[0].Count == 0)
			{
				num30 = 0;
			}
			int num31 = -1;
			81AAA = -1;
			if (soData.autoGenerate || isChild)
			{
				bool flag9 = true;
				bool flag10 = false;
				bool flag11 = false;
				bool flag12 = false;
				flag11 = false;
				flag12 = false;
				if (so.tunnelObject || isChild)
				{
					flag5 = (flag6 = false);
					num31 = (81AAA = 1);
					num21 = 0;
					int num32 = 0;
					for (int num33 = 0; num33 < roadScr.soSectionList1.Count; num33++)
					{
						if ((roadScr.soSectionList1[num33].soid != so.id && !OOQQQDOCDD.IsActiveAsChild(roadScr.baseScript, roadScr.soSectionList1[num33].soid, so.id)) || (roadScr.baseScript.isInBuildMode && !roadScr.soSectionList1[num33].active))
						{
							continue;
						}
						flag11 = true;
						if (num32 > 0 || list23[0].Count > 0)
						{
							list23.Add(new List<Vector3>());
							list24.Add(new List<Vector3>());
							list25.Add(new List<Vector3>());
							list26.Add(new List<Vector3>());
							list27.Add(new List<float>());
							list28.Add(new List<List<Vector2>>());
							for (int num34 = 0; num34 < nodeList.Count; num34++)
							{
								list28[num21 + 1].Add(new List<Vector2>());
							}
							list29.Add(new List<float>());
							list30.Add(new List<float>());
							list31.Add(new List<float>());
							num14 = 0f;
							num15 = 0;
							num21++;
						}
						num32++;
						list33.Add(num33);
						int num35 = roadScr.soSectionList1[num33].startSplinePoint;
						int num36 = roadScr.soSectionList1[num33].endSplinePoint;
						if (num35 <= 0)
						{
							num35 = 1;
						}
						if (num35 >= vecPositions.Count)
						{
							num35 = vecPositions.Count - 1;
						}
						if (num36 >= vecPositions.Count - 1)
						{
							num36 = vecPositions.Count - 2;
						}
						Vector3 vector2 = roadScr.soSectionList1[num33].startPosition;
						Vector3 vector3 = roadScr.soSectionList1[num33].endPosition;
						if (roadScr.baseScript.activeTerrain == null)
						{
							roadScr.baseScript.OQQOOCQQCD(vecPositions[num35]);
						}
						float num37 = ODQDQDQDQO.OQQOQODCCC(roadScr.baseScript.activeTerrain, vecPositions[num35 - 1], vecPositions[num35]);
						if (so.innerStartOffset + num37 != 0f)
						{
							float num38 = 0f;
							Vector3 vector4 = roadScr.soSectionList1[num33].startPosition;
							float num39 = num37 * 1f + so.geoStartOffset;
							int num40 = num35 - 1;
							bool flag13 = true;
							while (num39 > 0f && num40 > 0)
							{
								num38 = Vector3.Distance(vecPositions[num40], vector4);
								if (num38 > num39)
								{
									float t = num39 / num38;
									vector2 = Vector3.Lerp(vector4, vecPositions[num40], t);
									num35 = num40 + 1;
									flag13 = false;
									break;
								}
								num39 -= num38;
								vector4 = vecPositions[num40];
								num40--;
							}
							if (flag13)
							{
								UnityEngine.Debug.Log("EasyRoads3Dv3 Warning: Side object '" + so.name + "' Start Offset is too large, not enough room in front of the tunnel start");
							}
						}
						num37 = ODQDQDQDQO.OQQOQODCCC(roadScr.baseScript.activeTerrain, vecPositions[num36 - 1], vecPositions[num36]);
						if (so.innerEndOffset + num37 != 0f)
						{
							float num41 = 0f;
							Vector3 vector5 = roadScr.soSectionList1[num33].endPosition;
							float num42 = num37 + so.geoEndOffset;
							int num43 = num36 + 1;
							bool flag14 = true;
							while (num42 > 0f && num43 < vecPositions.Count)
							{
								num41 = Vector3.Distance(vecPositions[num43], vector5);
								if (num41 > num42)
								{
									float t2 = num42 / num41;
									vector3 = Vector3.Lerp(vector5, vecPositions[num43], t2);
									num36 = num43 - 1;
									flag14 = false;
									break;
								}
								num42 -= num41;
								vector5 = vecPositions[num43];
								num43++;
							}
							if (flag14)
							{
								UnityEngine.Debug.Log("EasyRoads3Dv3 Warning: Side object '" + so.name + "' End Offset is too large, not enough room after of the tunnel end");
							}
						}
						float num44 = Vector3.Distance(vecPositions[num35], list10[num35]);
						Vector3 vector = (list10[num35] - list11[num35]).normalized;
						list23[num21].Add(vector2);
						list24[num21].Add(vector2 + vector * num44);
						num44 = Vector3.Distance(vecPositions[num35], list11[num35]);
						list25[num21].Add(vector2 + -vector * num44);
						list26[num21].Add(vector2);
						if (list19.Count > num35)
						{
							list27[num21].Add(list19[num35]);
						}
						else
						{
							list27[num21].Add(0f);
						}
						for (int num45 = num35; num45 <= num36; num45++)
						{
							list23[num21].Add(vecPositions[num45]);
							list24[num21].Add(list10[num45]);
							list25[num21].Add(list11[num45]);
							list26[num21].Add(list18[num45]);
							if (list19.Count > num35)
							{
								list27[num21].Add(list19[num45]);
							}
							else
							{
								list27[num21].Add(0f);
							}
						}
						num44 = Vector3.Distance(vecPositions[num36], list10[num36]);
						vector = (list10[num36] - list11[num36]).normalized;
						list23[num21].Add(vector3);
						list24[num21].Add(vector3 + vector * num44);
						num44 = Vector3.Distance(vecPositions[num36], list11[num36]);
						list25[num21].Add(vector3 + -vector * num44);
						list26[num21].Add(vector3);
						if (list19.Count > num35)
						{
							list27[num21].Add(list19[num35]);
						}
						else
						{
							list27[num21].Add(0f);
						}
					}
				}
				if (so.bridgeObject || isChild)
				{
					flag5 = (flag6 = false);
					num31 = (81AAA = 2);
					num21 = 0;
					int num46 = 0;
					for (int num47 = 0; num47 < roadScr.soSectionList2.Count; num47++)
					{
						if ((roadScr.soSectionList2[num47].soid != so.id && !OOQQQDOCDD.IsActiveAsChild(roadScr.baseScript, roadScr.soSectionList2[num47].soid, so.id)) || (roadScr.baseScript.isInBuildMode && !roadScr.soSectionList2[num47].active))
						{
							continue;
						}
						flag11 = true;
						if ((num46 > 0 || list23[0].Count > 0) && (flag10 || (flag9 && list23[0].Count > 0)))
						{
							list23.Add(new List<Vector3>());
							list24.Add(new List<Vector3>());
							list25.Add(new List<Vector3>());
							list26.Add(new List<Vector3>());
							list27.Add(new List<float>());
							list28.Add(new List<List<Vector2>>());
							for (int num48 = 0; num48 < nodeList.Count; num48++)
							{
								list28[num21 + 1].Add(new List<Vector2>());
							}
							list29.Add(new List<float>());
							list30.Add(new List<float>());
							list31.Add(new List<float>());
							num14 = 0f;
							num15 = 0;
							num21++;
						}
						num46++;
						list33.Add(num47);
						int num49 = roadScr.soSectionList2[num47].startSplinePoint;
						int num50 = roadScr.soSectionList2[num47].endSplinePoint;
						if (num49 <= 0)
						{
							num49 = 1;
						}
						if (num49 >= vecPositions.Count)
						{
							num49 = vecPositions.Count - 1;
						}
						if (num50 >= vecPositions.Count - 1 || num50 < 0)
						{
							num50 = vecPositions.Count - 2;
						}
						Vector3 vector6 = vecPositions[num49];
						Vector3 vector7 = vecPositions[num50];
						if (roadScr.baseScript.activeTerrain == null)
						{
							roadScr.baseScript.OQQOOCQQCD(vecPositions[num49]);
						}
						float num51 = ODQDQDQDQO.OQQOQODCCC(roadScr.baseScript.activeTerrain, vecPositions[num49 - 1], vecPositions[num49]);
						int num52 = num49;
						float num53 = num51;
						float num54 = 0f;
						bool flag15 = false;
						float num56;
						for (int num55 = num52; num55 > 0; num55--)
						{
							num54 = Vector3.Distance(vecPositions[num55], vecPositions[num55 + 1]);
							num56 = num53;
							num53 -= num54;
							if (num53 < 0f)
							{
								num49 = num55;
								vector6 = Vector3.Lerp(vecPositions[num55], vecPositions[num55 - 1], num56 / num54);
								flag15 = true;
								break;
							}
						}
						if (!flag15)
						{
							vector6 = vecPositions[0];
							num49 = 0;
						}
						num51 = ODQDQDQDQO.OQQOQODCCC(roadScr.baseScript.activeTerrain, vecPositions[num50 - 1], vecPositions[num50]);
						int num57 = num50;
						num56 = 0f;
						num53 = num51;
						for (int num58 = num57; num58 < vecPositions.Count - 1; num58++)
						{
							num54 = Vector3.Distance(vecPositions[num58], vecPositions[num58 + 1]);
							num56 = num53;
							num53 -= num54;
							if (num53 < 0f)
							{
								if (num58 < vecPositions.Count - 2)
								{
									num50 = num58;
								}
								vector7 = Vector3.Lerp(vecPositions[num50], vecPositions[num50 + 1], num56 / num54);
								flag15 = true;
								break;
							}
						}
						if (!flag15)
						{
							vector7 = vecPositions[vecPositions.Count - 1];
							num50 = vecPositions.Count - 1;
						}
						num53 = Vector3.Distance(vecPositions[num49], list10[num49]);
						Vector3 vector = (list10[num49] - list11[num49]).normalized;
						list23[num21].Add(vector6);
						list24[num21].Add(vector6 + vector * num53);
						num53 = Vector3.Distance(vecPositions[num49], list11[num49]);
						list25[num21].Add(vector6 + -vector * num53);
						list26[num21].Add(vector6);
						if (list19.Count > num49)
						{
							list27[num21].Add(list19[num49]);
						}
						else
						{
							list27[num21].Add(0f);
						}
						for (int num59 = num49; num59 <= num50; num59++)
						{
							list23[num21].Add(vecPositions[num59]);
							list24[num21].Add(list10[num59]);
							list25[num21].Add(list11[num59]);
							list26[num21].Add(list18[num59]);
							if (list19.Count > num49)
							{
								list27[num21].Add(list19[num59]);
							}
							else
							{
								list27[num21].Add(0f);
							}
						}
						num53 = Vector3.Distance(vecPositions[num50], list10[num50]);
						vector = (list10[num50] - list11[num50]).normalized;
						list23[num21].Add(vector7);
						list24[num21].Add(vector7 + vector * num53);
						num53 = Vector3.Distance(vecPositions[num50], list11[num50]);
						list25[num21].Add(vector7 + -vector * num53);
						list26[num21].Add(vector7);
						if (list19.Count > num49)
						{
							list27[num21].Add(list19[num49]);
						}
						else
						{
							list27[num21].Add(0f);
						}
					}
				}
				if (so.category == 0)
				{
					flag6 = false;
					num31 = (81AAA = 3);
					num21 = 0;
					int num60 = 0;
					for (int num61 = 0; num61 < roadScr.soSectionList3.Count; num61++)
					{
						if (roadScr.soSectionList3[num61].soid != so.id || (roadScr.baseScript.isInBuildMode && !roadScr.soSectionList3[num61].active))
						{
							continue;
						}
						flag11 = true;
						if (so.relativeTo != 0 && ((mirrored && so.relativeTo == 1 && roadScr.soSectionList3[num61].roadSide == ERRoadSide.Left) || (mirrored && so.relativeTo == 2 && roadScr.soSectionList3[num61].roadSide == ERRoadSide.Right) || (!mirrored && so.relativeTo == 1 && roadScr.soSectionList3[num61].roadSide == ERRoadSide.Right) || (!mirrored && so.relativeTo == 2 && roadScr.soSectionList3[num61].roadSide == ERRoadSide.Left)))
						{
							continue;
						}
						if ((num60 > 0 || list23[0].Count > 0) && (flag10 || (flag9 && list23[0].Count > 0)))
						{
							list23.Add(new List<Vector3>());
							list24.Add(new List<Vector3>());
							list25.Add(new List<Vector3>());
							list26.Add(new List<Vector3>());
							list27.Add(new List<float>());
							list28.Add(new List<List<Vector2>>());
							for (int num62 = 0; num62 < nodeList.Count; num62++)
							{
								list28[num21 + 1].Add(new List<Vector2>());
							}
							list29.Add(new List<float>());
							list30.Add(new List<float>());
							list31.Add(new List<float>());
							num14 = 0f;
							num15 = 0;
							num21++;
						}
						num60++;
						list33.Add(num61);
						flag10 = true;
						flag9 = false;
						int num63 = roadScr.soSectionList3[num61].startSplinePoint;
						int num64 = roadScr.soSectionList3[num61].endSplinePoint;
						if (num63 <= 0)
						{
							num63 = 1;
						}
						if (num63 >= vecPositions.Count)
						{
							num63 = vecPositions.Count - 1;
						}
						if (num64 >= vecPositions.Count - 1)
						{
							num64 = vecPositions.Count - 2;
						}
						Vector3 vector8 = vecPositions[num63];
						Vector3 vector9 = vecPositions[num64];
						if (roadScr.baseScript.activeTerrain == null)
						{
							roadScr.baseScript.OQQOOCQQCD(vecPositions[num63]);
						}
						if (roadScr.soSectionList3[num61].startFraction != 0f)
						{
							vector8 = Vector3.Lerp(vecPositions[num63], vecPositions[num63 - 1], roadScr.soSectionList3[num61].startFraction);
						}
						if (roadScr.soSectionList3[num61].endFraction != 0f)
						{
							float t3 = roadScr.soSectionList3[num61].endFraction;
							if (num64 >= vecPositions.Count - 1)
							{
								num64 = vecPositions.Count - 2;
								t3 = 1f;
							}
							vector9 = Vector3.Lerp(vecPositions[num64], vecPositions[num64 + 1], t3);
						}
						float num65 = Vector3.Distance(vecPositions[num63], list10[num63]);
						Vector3 vector = (list10[num63] - list11[num63]).normalized;
						list23[num21].Add(vector8);
						list24[num21].Add(vector8 + vector * num65);
						num65 = Vector3.Distance(vecPositions[num63], list11[num63]);
						list25[num21].Add(vector8 + -vector * num65);
						list26[num21].Add(vector8);
						if (list19.Count > num63)
						{
							list27[num21].Add(list19[num63]);
						}
						else
						{
							list27[num21].Add(0f);
						}
						for (int num66 = num63; num66 <= num64; num66++)
						{
							list23[num21].Add(vecPositions[num66]);
							list24[num21].Add(list10[num66]);
							list25[num21].Add(list11[num66]);
							list26[num21].Add(list18[num66]);
							if (list19.Count > num63)
							{
								list27[num21].Add(list19[num66]);
							}
							else
							{
								list27[num21].Add(0f);
							}
						}
						num65 = Vector3.Distance(vecPositions[num64], list10[num64]);
						vector = (list10[num64] - list11[num64]).normalized;
						list23[num21].Add(vector9);
						list24[num21].Add(vector9 + vector * num65);
						num65 = Vector3.Distance(vecPositions[num64], list11[num64]);
						list25[num21].Add(vector9 + -vector * num65);
						list26[num21].Add(vector9);
						if (list19.Count > num63)
						{
							list27[num21].Add(list19[num63]);
						}
						else
						{
							list27[num21].Add(0f);
						}
					}
					flag5 = (flag6 = false);
					num21 = 0;
					num60 = 0;
					for (int num67 = 0; num67 < roadScr.soSectionList4.Count; num67++)
					{
						if (roadScr.soSectionList4[num67].soid != so.id || (roadScr.baseScript.isInBuildMode && !roadScr.soSectionList4[num67].active))
						{
							continue;
						}
						flag11 = true;
						81AAA = 4;
						if (so.relativeTo != 0 && ((mirrored && so.relativeTo == 1 && roadScr.soSectionList4[num67].roadSide == ERRoadSide.Left) || (mirrored && so.relativeTo == 2 && roadScr.soSectionList4[num67].roadSide == ERRoadSide.Right) || (!mirrored && so.relativeTo == 1 && roadScr.soSectionList4[num67].roadSide == ERRoadSide.Right) || (!mirrored && so.relativeTo == 2 && roadScr.soSectionList4[num67].roadSide == ERRoadSide.Left)))
						{
							continue;
						}
						if ((num60 > 0 || list23[0].Count > 0) && (flag10 || (flag9 && list23[0].Count > 0)))
						{
							list23.Add(new List<Vector3>());
							list24.Add(new List<Vector3>());
							list25.Add(new List<Vector3>());
							list26.Add(new List<Vector3>());
							list27.Add(new List<float>());
							list28.Add(new List<List<Vector2>>());
							for (int num68 = 0; num68 < nodeList.Count; num68++)
							{
								list28[num21 + 1].Add(new List<Vector2>());
							}
							list29.Add(new List<float>());
							list30.Add(new List<float>());
							list31.Add(new List<float>());
							num14 = 0f;
							num15 = 0;
							num21++;
						}
						num60++;
						list33.Add(num67);
						flag10 = true;
						flag9 = false;
						int num69 = roadScr.soSectionList4[num67].startSplinePoint;
						int num70 = roadScr.soSectionList4[num67].endSplinePoint;
						if (num69 <= 0)
						{
							num69 = 1;
						}
						if (num69 >= vecPositions.Count)
						{
							num69 = vecPositions.Count - 1;
						}
						if (num70 >= vecPositions.Count - 1)
						{
							num70 = vecPositions.Count - 2;
						}
						Vector3 vector10 = vecPositions[num69];
						Vector3 vector11 = vecPositions[num70];
						if (roadScr.baseScript.activeTerrain == null)
						{
							roadScr.baseScript.OQQOOCQQCD(vecPositions[num69]);
						}
						if (roadScr.soSectionList4[num67].startFraction != 0f)
						{
							vector10 = Vector3.Lerp(vecPositions[num69], vecPositions[num69 - 1], roadScr.soSectionList4[num67].startFraction);
						}
						if (roadScr.soSectionList4[num67].endFraction != 0f)
						{
							float t4 = roadScr.soSectionList4[num67].endFraction;
							if (num70 >= vecPositions.Count - 1)
							{
								num70 = vecPositions.Count - 2;
								t4 = 1f;
							}
							vector11 = Vector3.Lerp(vecPositions[num70], vecPositions[num70 + 1], t4);
						}
						float num71 = Vector3.Distance(vecPositions[num69], list10[num69]);
						Vector3 vector = (list10[num69] - list11[num69]).normalized;
						list23[num21].Add(vector10);
						list24[num21].Add(vector10 + vector * num71);
						num71 = Vector3.Distance(vecPositions[num69], list11[num69]);
						list25[num21].Add(vector10 + -vector * num71);
						list26[num21].Add(vector10);
						if (list19.Count > num69)
						{
							list27[num21].Add(list19[num69]);
						}
						else
						{
							list27[num21].Add(0f);
						}
						for (int num72 = num69; num72 <= num70; num72++)
						{
							list23[num21].Add(vecPositions[num72]);
							list24[num21].Add(list10[num72]);
							list25[num21].Add(list11[num72]);
							list26[num21].Add(list18[num72]);
							if (list19.Count > num69)
							{
								list27[num21].Add(list19[num72]);
							}
							else
							{
								list27[num21].Add(0f);
							}
						}
						num71 = Vector3.Distance(vecPositions[num70], list10[num70]);
						vector = (list10[num70] - list11[num70]).normalized;
						list23[num21].Add(vector11);
						list24[num21].Add(vector11 + vector * num71);
						num71 = Vector3.Distance(vecPositions[num70], list11[num70]);
						list25[num21].Add(vector11 + -vector * num71);
						list26[num21].Add(vector11);
						if (list19.Count > num69)
						{
							list27[num21].Add(list19[num69]);
						}
						else
						{
							list27[num21].Add(0f);
						}
					}
				}
				if (so.category == 4)
				{
					flag5 = (flag6 = false);
					num31 = (81AAA = 5);
					num21 = 0;
					int num73 = 0;
					for (int num74 = 0; num74 < roadScr.soSectionList5.Count; num74++)
					{
						if (roadScr.soSectionList5[num74].soid != so.id || (roadScr.baseScript.isInBuildMode && !roadScr.soSectionList5[num74].active))
						{
							continue;
						}
						flag12 = true;
						if (so.relativeTo != 0 && ((mirrored && so.relativeTo == 1 && roadScr.soSectionList5[num74].roadSide == ERRoadSide.Left) || (mirrored && so.relativeTo == 2 && roadScr.soSectionList5[num74].roadSide == ERRoadSide.Right) || (!mirrored && so.relativeTo == 1 && roadScr.soSectionList5[num74].roadSide == ERRoadSide.Right) || (!mirrored && so.relativeTo == 2 && roadScr.soSectionList5[num74].roadSide == ERRoadSide.Left)))
						{
							continue;
						}
						if ((num73 > 0 || list23[0].Count > 0) && (flag10 || (flag9 && list23[0].Count > 0)))
						{
							list23.Add(new List<Vector3>());
							list24.Add(new List<Vector3>());
							list25.Add(new List<Vector3>());
							list26.Add(new List<Vector3>());
							list27.Add(new List<float>());
							list28.Add(new List<List<Vector2>>());
							for (int num75 = 0; num75 < nodeList.Count; num75++)
							{
								list28[num21 + 1].Add(new List<Vector2>());
							}
							list29.Add(new List<float>());
							list30.Add(new List<float>());
							list31.Add(new List<float>());
							num14 = 0f;
							num15 = 0;
							num21++;
						}
						list33.Add(num74);
						num73++;
						if (roadScr.soSectionList5[num74].roadSide == ERRoadSide.Left)
						{
							if ((!roadScr.oneWayRoad && roadScr.baseScript.rightHandDriving == 1) || roadScr.oneWayDirection == ERLaneDirection.Left)
							{
								list34.Add(item: true);
							}
							else
							{
								list34.Add(item: false);
							}
						}
						else if (roadScr.soSectionList5[num74].roadSide == ERRoadSide.Left)
						{
							if ((!roadScr.oneWayRoad && roadScr.baseScript.rightHandDriving == 0) || roadScr.oneWayDirection == ERLaneDirection.Left)
							{
								list34.Add(item: true);
							}
							else
							{
								list34.Add(item: false);
							}
						}
						flag10 = true;
						flag9 = false;
						int num76 = roadScr.soSectionList5[num74].startSplinePoint;
						int num77 = roadScr.soSectionList5[num74].endSplinePoint;
						if (num76 <= 0)
						{
							num76 = 1;
						}
						if (num76 >= vecPositions.Count)
						{
							num76 = vecPositions.Count - 1;
						}
						if (num77 >= vecPositions.Count - 1)
						{
							num77 = vecPositions.Count - 2;
						}
						Vector3 vector12 = vecPositions[num76];
						Vector3 vector13 = vecPositions[num77];
						if (roadScr.baseScript.activeTerrain == null)
						{
							roadScr.baseScript.OQQOOCQQCD(vecPositions[num76]);
						}
						if (roadScr.soSectionList5[num74].startFraction != 0f)
						{
							vector12 = Vector3.Lerp(vecPositions[num76], vecPositions[num76 - 1], roadScr.soSectionList5[num74].startFraction);
						}
						if (roadScr.soSectionList5[num74].endFraction != 0f)
						{
							vector13 = Vector3.Lerp(vecPositions[num77], vecPositions[num77 + 1], roadScr.soSectionList5[num74].endFraction);
						}
						float num78 = Vector3.Distance(vecPositions[num76], list10[num76]);
						Vector3 vector = (list10[num76] - list11[num76]).normalized;
						list23[num21].Add(vector12);
						list24[num21].Add(vector12 + vector * num78);
						num78 = Vector3.Distance(vecPositions[num76], list11[num76]);
						list25[num21].Add(vector12 + -vector * num78);
						list26[num21].Add(vector12);
						if (list19.Count > num76)
						{
							list27[num21].Add(list19[num76]);
						}
						else
						{
							list27[num21].Add(0f);
						}
						for (int num79 = num76; num79 <= num77; num79++)
						{
							list23[num21].Add(vecPositions[num79]);
							list24[num21].Add(list10[num79]);
							list25[num21].Add(list11[num79]);
							list26[num21].Add(list18[num79]);
							if (list19.Count > num76)
							{
								list27[num21].Add(list19[num79]);
							}
							else
							{
								list27[num21].Add(0f);
							}
						}
						num78 = Vector3.Distance(vecPositions[num77], list10[num77]);
						vector = (list10[num77] - list11[num77]).normalized;
						list23[num21].Add(vector13);
						list24[num21].Add(vector13 + vector * num78);
						num78 = Vector3.Distance(vecPositions[num77], list11[num77]);
						list25[num21].Add(vector13 + -vector * num78);
						list26[num21].Add(vector13);
						if (list19.Count > num76)
						{
							list27[num21].Add(list19[num76]);
						}
						else
						{
							list27[num21].Add(0f);
						}
					}
				}
				if ((so.category == 2 && so.retainingWall) || isChild)
				{
					flag5 = (flag6 = false);
					num31 = (81AAA = 6);
					num21 = 0;
					int num80 = 0;
					for (int num81 = 0; num81 < roadScr.soSectionList6.Count; num81++)
					{
						if ((roadScr.soSectionList6[num81].soid != so.id && !OOQQQDOCDD.IsActiveAsChild(roadScr.baseScript, roadScr.soSectionList6[num81].soid, so.id)) || (roadScr.baseScript.isInBuildMode && !roadScr.soSectionList6[num81].active))
						{
							continue;
						}
						flag12 = true;
						if (so.relativeTo != 0 && ((mirrored && so.relativeTo == 1 && roadScr.soSectionList6[num81].roadSide == ERRoadSide.Left) || (mirrored && so.relativeTo == 2 && roadScr.soSectionList6[num81].roadSide == ERRoadSide.Right) || (!mirrored && so.relativeTo == 1 && roadScr.soSectionList6[num81].roadSide == ERRoadSide.Right) || (!mirrored && so.relativeTo == 2 && roadScr.soSectionList6[num81].roadSide == ERRoadSide.Left)))
						{
							continue;
						}
						if ((num80 > 0 || list23[0].Count > 0) && (flag10 || (flag9 && list23[0].Count > 0)))
						{
							list23.Add(new List<Vector3>());
							list24.Add(new List<Vector3>());
							list25.Add(new List<Vector3>());
							list26.Add(new List<Vector3>());
							list27.Add(new List<float>());
							list28.Add(new List<List<Vector2>>());
							for (int num82 = 0; num82 < nodeList.Count; num82++)
							{
								list28[num21 + 1].Add(new List<Vector2>());
							}
							list29.Add(new List<float>());
							list30.Add(new List<float>());
							list31.Add(new List<float>());
							num14 = 0f;
							num15 = 0;
							num21++;
						}
						num80++;
						list33.Add(num81);
						flag10 = true;
						flag9 = false;
						int num83 = roadScr.soSectionList6[num81].startSplinePoint;
						int num84 = roadScr.soSectionList6[num81].endSplinePoint;
						if (num83 >= vecPositions.Count)
						{
							num83 = vecPositions.Count - 1;
						}
						Vector3 vector14 = vecPositions[num83];
						Vector3 vector15 = vecPositions[num84];
						if (roadScr.baseScript.activeTerrain == null)
						{
							roadScr.baseScript.OQQOOCQQCD(vecPositions[num83]);
						}
						if (roadScr.soSectionList6[num81].startFraction != 0f)
						{
							vector14 = Vector3.Lerp(vecPositions[num83], vecPositions[num83 - 1], roadScr.soSectionList6[num81].startFraction);
						}
						if (roadScr.soSectionList6[num81].endFraction != 0f)
						{
							float t5 = roadScr.soSectionList6[num81].endFraction;
							if (num84 >= vecPositions.Count - 1)
							{
								num84 = vecPositions.Count - 2;
								t5 = 1f;
							}
							vector15 = Vector3.Lerp(vecPositions[num84], vecPositions[num84 + 1], t5);
						}
						float num85 = Vector3.Distance(vecPositions[num83], list10[num83]);
						Vector3 vector = (list10[num83] - list11[num83]).normalized;
						list23[num21].Add(vector14);
						list24[num21].Add(vector14 + vector * num85);
						num85 = Vector3.Distance(vecPositions[num83], list11[num83]);
						list25[num21].Add(vector14 + -vector * num85);
						list26[num21].Add(vector14);
						if (list19.Count > num83)
						{
							list27[num21].Add(list19[num83]);
						}
						else
						{
							list27[num21].Add(0f);
						}
						for (int num86 = num83; num86 <= num84; num86++)
						{
							list23[num21].Add(vecPositions[num86]);
							list24[num21].Add(list10[num86]);
							list25[num21].Add(list11[num86]);
							list26[num21].Add(list18[num86]);
							if (list19.Count > num83)
							{
								list27[num21].Add(list19[num86]);
							}
							else
							{
								list27[num21].Add(0f);
							}
						}
						num85 = Vector3.Distance(vecPositions[num84], list10[num84]);
						vector = (list10[num84] - list11[num84]).normalized;
						list23[num21].Add(vector15);
						list24[num21].Add(vector15 + vector * num85);
						num85 = Vector3.Distance(vecPositions[num84], list11[num84]);
						list25[num21].Add(vector15 + -vector * num85);
						list26[num21].Add(vector15);
						if (list19.Count > num83)
						{
							list27[num21].Add(list19[num83]);
						}
						else
						{
							list27[num21].Add(0f);
						}
					}
					num21 = 0;
					num80 = 0;
					for (int num87 = 0; num87 < roadScr.soSectionList7.Count; num87++)
					{
						if ((roadScr.soSectionList7[num87].soid != so.id && !OOQQQDOCDD.IsActiveAsChild(roadScr.baseScript, roadScr.soSectionList7[num87].soid, so.id)) || (roadScr.baseScript.isInBuildMode && !roadScr.soSectionList7[num87].active))
						{
							continue;
						}
						flag12 = true;
						81AAA = 7;
						if (so.relativeTo != 0 && ((mirrored && so.relativeTo == 1 && roadScr.soSectionList7[num87].roadSide == ERRoadSide.Left) || (mirrored && so.relativeTo == 2 && roadScr.soSectionList7[num87].roadSide == ERRoadSide.Right) || (!mirrored && so.relativeTo == 1 && roadScr.soSectionList7[num87].roadSide == ERRoadSide.Right) || (!mirrored && so.relativeTo == 2 && roadScr.soSectionList7[num87].roadSide == ERRoadSide.Left)))
						{
							continue;
						}
						if ((num80 > 0 || list23[0].Count > 0) && (flag10 || (flag9 && list23[0].Count > 0)))
						{
							list23.Add(new List<Vector3>());
							list24.Add(new List<Vector3>());
							list25.Add(new List<Vector3>());
							list26.Add(new List<Vector3>());
							list27.Add(new List<float>());
							list28.Add(new List<List<Vector2>>());
							for (int num88 = 0; num88 < nodeList.Count; num88++)
							{
								list28[num21 + 1].Add(new List<Vector2>());
							}
							list29.Add(new List<float>());
							list30.Add(new List<float>());
							list31.Add(new List<float>());
							num14 = 0f;
							num15 = 0;
							num21++;
						}
						num80++;
						list33.Add(num87);
						flag10 = true;
						flag9 = false;
						int num89 = roadScr.soSectionList7[num87].startSplinePoint;
						int num90 = roadScr.soSectionList7[num87].endSplinePoint;
						if (num89 >= vecPositions.Count)
						{
							num89 = vecPositions.Count - 1;
						}
						Vector3 vector16 = vecPositions[num89];
						Vector3 vector17 = vecPositions[num90];
						if (roadScr.baseScript.activeTerrain == null)
						{
							roadScr.baseScript.OQQOOCQQCD(vecPositions[num89]);
						}
						if (roadScr.soSectionList7[num87].startFraction != 0f)
						{
							vector16 = Vector3.Lerp(vecPositions[num89], vecPositions[num89 - 1], roadScr.soSectionList7[num87].startFraction);
						}
						if (roadScr.soSectionList7[num87].endFraction != 0f)
						{
							float t6 = roadScr.soSectionList7[num87].endFraction;
							if (num90 >= vecPositions.Count - 1)
							{
								num90 = vecPositions.Count - 2;
								t6 = 1f;
							}
							vector17 = Vector3.Lerp(vecPositions[num90], vecPositions[num90 + 1], t6);
						}
						float num91 = Vector3.Distance(vecPositions[num89], list10[num89]);
						Vector3 vector = (list10[num89] - list11[num89]).normalized;
						list23[num21].Add(vector16);
						list24[num21].Add(vector16 + vector * num91);
						num91 = Vector3.Distance(vecPositions[num89], list11[num89]);
						list25[num21].Add(vector16 + -vector * num91);
						list26[num21].Add(vector16);
						if (list19.Count > num89)
						{
							list27[num21].Add(list19[num89]);
						}
						else
						{
							list27[num21].Add(0f);
						}
						for (int num92 = num89; num92 <= num90; num92++)
						{
							list23[num21].Add(vecPositions[num92]);
							list24[num21].Add(list10[num92]);
							list25[num21].Add(list11[num92]);
							list26[num21].Add(list18[num92]);
							if (list19.Count > num89)
							{
								list27[num21].Add(list19[num92]);
							}
							else
							{
								list27[num21].Add(0f);
							}
						}
						num91 = Vector3.Distance(vecPositions[num90], list10[num90]);
						vector = (list10[num90] - list11[num90]).normalized;
						list23[num21].Add(vector17);
						list24[num21].Add(vector17 + vector * num91);
						num91 = Vector3.Distance(vecPositions[num90], list11[num90]);
						list25[num21].Add(vector17 + -vector * num91);
						list26[num21].Add(vector17);
						if (list19.Count > num89)
						{
							list27[num21].Add(list19[num89]);
						}
						else
						{
							list27[num21].Add(0f);
						}
					}
				}
				if (flag11 && flag12)
				{
					for (int num93 = 0; num93 < list23.Count; num93++)
					{
						for (int num94 = num93 + 1; num94 < list23.Count; num94++)
						{
							if (list23[num93].Count <= 1 || list23[num94].Count <= 1)
							{
								continue;
							}
							if (Vector3.Distance(list23[num93][0], list23[num94][list23[num94].Count - 1]) < 5f)
							{
								int num95 = 0;
								int count2 = list23[num93].Count;
								Vector3 pTarget2 = list24[num94][list24[num94].Count - 1];
								Vector3 pSource = list25[num94][list24[num94].Count - 1];
								for (; num95 < count2; num95++)
								{
									if (!ODQDQDQDQO.OQCDCDOOCD(pTarget2, pSource, list23[num93][num95]))
									{
										list23[num93].RemoveAt(num95);
										list24[num93].RemoveAt(num95);
										list25[num93].RemoveAt(num95);
										list26[num93].RemoveAt(num95);
										list27[num93].RemoveAt(num95);
									}
								}
								list23[num94].AddRange(list23[num93]);
								list24[num94].AddRange(list24[num93]);
								list25[num94].AddRange(list25[num93]);
								list26[num94].AddRange(list26[num93]);
								list27[num94].AddRange(list27[num93]);
								list23.RemoveAt(num93);
								list24.RemoveAt(num93);
								list25.RemoveAt(num93);
								list26.RemoveAt(num93);
								list27.RemoveAt(num93);
								num93--;
								break;
							}
							if (!(Vector3.Distance(list23[num94][0], list23[num93][list23[num93].Count - 1]) < 5f))
							{
								continue;
							}
							int num96 = list23[num93].Count - 1;
							Vector3 pTarget3 = list24[num94][0];
							Vector3 pSource2 = list25[num94][0];
							for (; num96 >= 0; num96--)
							{
								if (ODQDQDQDQO.OQCDCDOOCD(pTarget3, pSource2, list23[num93][num96]))
								{
									list23[num93].RemoveAt(num96);
									list24[num93].RemoveAt(num96);
									list25[num93].RemoveAt(num96);
									list26[num93].RemoveAt(num96);
									list27[num93].RemoveAt(num96);
								}
							}
							list23[num94].InsertRange(0, list23[num93]);
							list24[num94].InsertRange(0, list24[num93]);
							list25[num94].InsertRange(0, list25[num93]);
							list26[num94].InsertRange(0, list26[num93]);
							list27[num94].InsertRange(0, list27[num93]);
							list23.RemoveAt(num93);
							list24.RemoveAt(num93);
							list25.RemoveAt(num93);
							list26.RemoveAt(num93);
							list27.RemoveAt(num93);
							num93--;
							break;
						}
					}
				}
			}
			if (so.snapToTerrain)
			{
				for (int num97 = 0; num97 < vecPositions.Count; num97++)
				{
					Vector3 v2 = vecPositions[num97];
					v2.y = ODQDQDQDQO.OOCQOOCOQC(v2, roadScr.baseScript);
					vecPositions[num97] = v2;
				}
			}
			for (int num98 = 0; num98 < roadScr.soDataExt.Count; num98++)
			{
				if (roadScr.soDataExt[num98].id == so.id)
				{
					roadScr.soDataExt[num98].vecPositions = new List<Vector3>(vecPositions);
				}
			}
			bool flag16 = true;
			bool flag17 = true;
			if (roadScr.closedTrack && flag5 && flag6)
			{
				flag16 = false;
				flag17 = false;
			}
			if (so.objectType == 0 && so.bridgeObject)
			{
				flag17 = false;
			}
			if (soData.yPosition != 0f)
			{
				for (int num99 = 0; num99 < list23.Count; num99++)
				{
					for (int num100 = 0; num100 < list23[num99].Count; num100++)
					{
						Vector3 v2 = list23[num99][num100];
						v2.y += soData.yPosition;
						list23[num99][num100] = v2;
					}
				}
			}
			List<float> list35 = new List<float>();
			List<List<float>> list36 = new List<List<float>>();
			List<float> list37 = new List<float>();
			float num101 = 0f;
			List<int> list38 = new List<int>();
			if (mirrored && so.objectType == 2)
			{
				for (int num102 = 0; num102 < so.meshObjects.Count; num102++)
				{
					if (so.meshObjects[num102].triangles2.Count == 0)
					{
						so.meshObjects[num102].OCQQQCQQDD();
					}
				}
			}
			for (int num103 = 0; num103 < list23.Count; num103++)
			{
				list7.Add(0f);
				list8.Add(0f);
				float num104 = 0f;
				num101 = 0f;
				float num105 = 0f;
				Vector3 position = roadScr.markersExt[0].position;
				Vector3 zero = Vector3.zero;
				Vector3 vector18 = new Vector3(-1000000f, 0f, -1000000f);
				list36.Add(new List<float>());
				list36[num103].Add(0f);
				for (int num106 = 1; num106 < list23[num103].Count; num106++)
				{
					num101 += Vector3.Distance(list23[num103][num106 - 1], list23[num103][num106]);
					list36[num103].Add(num101);
				}
				if (list23[num103].Count < 2)
				{
					break;
				}
				Vector3 normalized = (list23[num103][list23[num103].Count - 1] - list23[num103][list23[num103].Count - 2]).normalized;
				if (normalized == Vector3.zero)
				{
					normalized = (list23[num103][list23[num103].Count - 1] - list23[num103][list23[num103].Count - 3]).normalized;
				}
				zero = list23[num103][list23[num103].Count - 1] + 100f * normalized;
				list23[num103].Add(zero);
				zero = list24[num103][list24[num103].Count - 1] + 100f * normalized;
				list24[num103].Add(zero);
				zero = list25[num103][list25[num103].Count - 1] + 100f * normalized;
				list25[num103].Add(zero);
				list36[num103].Add(num101 + Vector3.Distance(list23[num103][list23[num103].Count - 2], list23[num103][list23[num103].Count - 1]));
				list37.Add(num101);
			}
			if (go == null)
			{
				return;
			}
			for (int num107 = 0; num107 < so.meshObjects.Count; num107++)
			{
				so.meshObjects[num107].Clear();
			}
			so.instantiatedObjects.Clear();
			so.SetMaxVertices();
			float halfRoadWidth = 0.5f * roadScr.roadWidth;
			bool flag18 = true;
			Vector3 forward = Vector3.zero;
			Vector3 startPos = Vector3.zero;
			float clampUVYPerc = 1f;
			go.GetComponent<ERSideObjectInstance>().startEndPositions.Clear();
			bool rotateFlag = false;
			B0AAA = 0f;
			string text = "";
			if (so.relativeTo > 0)
			{
				text = ((!(so.relativeTo == 1 && mirrored) && (so.relativeTo != 2 || mirrored)) ? " - Left" : " - Right");
			}
			if (list37.Count == 0)
			{
				return;
			}
			for (int num108 = 0; num108 < list23.Count; num108++)
			{
				if (num108 > 0 && so.objectType > 0 && (!so.combine || num31 != -1))
				{
					CheckVertexLimit(so, 1, force: true);
				}
				bool flag19 = false;
				bool flag20 = false;
				if (num108 == 0 && flag5 && flag6 && roadScr.closedTrack)
				{
					flag19 = true;
				}
				if (num108 == list23.Count - 1 && flag5 && flag6 && roadScr.closedTrack)
				{
					flag20 = true;
				}
				num101 = list37[num108];
				vecPositions = list23[num108];
				list16 = list24[num108];
				list17 = list25[num108];
				list18 = list26[num108];
				list19 = list27[num108];
				nodeList = list28[num108];
				if (list32.Count > num108)
				{
					list38 = list32[num108];
				}
				71AA1 = num108;
				if (so.tunnelObject)
				{
					if (soData.autoGenerate && roadScr.soSectionList1.Count > num108)
					{
						Vector3 startPosition = roadScr.soSectionList1[num108].startPosition;
						Vector3 vector19 = roadScr.soSplinePoints[roadScr.soSectionList1[num108].startSplinePoint];
						Vector3 vector20 = roadScr.soSplinePoints[roadScr.soSectionList1[num108].endSplinePoint];
						Vector3 endPosition = roadScr.soSectionList1[num108].endPosition;
						OCCQQCCDDD.ODOCOCQODQ(roadScr, go.GetComponent<ERSideObjectInstance>().transform, startPosition, vector19, so.x1, so.x2, so.y1, Terrain.activeTerrain.terrainData.heightmapScale);
						OCCQQCCDDD.ODOCOCQODQ(roadScr, go.GetComponent<ERSideObjectInstance>().transform, endPosition, vector20, so.x1, so.x2, so.y1, Terrain.activeTerrain.terrainData.heightmapScale);
						go.GetComponent<ERSideObjectInstance>().startEndPositions.Add(startPosition);
						go.GetComponent<ERSideObjectInstance>().startEndPositions.Add(vector19);
						go.GetComponent<ERSideObjectInstance>().startEndPositions.Add(vector20);
						go.GetComponent<ERSideObjectInstance>().startEndPositions.Add(endPosition);
					}
					else
					{
						OCCQQCCDDD.ODOCOCQODQ(roadScr, go.GetComponent<ERSideObjectInstance>().transform, vecPositions[0], vecPositions[1], so.x1, so.x2, so.y1, Terrain.activeTerrain.terrainData.heightmapScale);
						OCCQQCCDDD.ODOCOCQODQ(roadScr, go.GetComponent<ERSideObjectInstance>().transform, vecPositions[2], vecPositions[3], so.x1, so.x2, so.y1, Terrain.activeTerrain.terrainData.heightmapScale);
						go.GetComponent<ERSideObjectInstance>().startEndPositions.Add(vecPositions[0]);
						go.GetComponent<ERSideObjectInstance>().startEndPositions.Add(vecPositions[1]);
						go.GetComponent<ERSideObjectInstance>().startEndPositions.Add(vecPositions[vecPositions.Count - 2]);
						go.GetComponent<ERSideObjectInstance>().startEndPositions.Add(vecPositions[vecPositions.Count - 1]);
					}
				}
				list35 = list36[num108];
				float num109 = 0f;
				float num110 = 0f;
				for (int num111 = 0; num111 < so.nodeList.Count - 1; num111++)
				{
					num110 += Vector2.Distance(so.nodeList[num111], so.nodeList[num111 + 1]);
				}
				num109 = 1f / num110;
				if (so.clampUVY && so.objectType == 1 && roadScr.baseScript.clampUVs)
				{
					float num112 = list35[list35.Count - 2] * so.uvy * num109;
					clampUVYPerc = (Mathf.Round(num112) - (1f - so.clampUVYValue)) / num112;
				}
				if (so.objectType < 2)
				{
					so.middleZDistance = so.m_distance;
					if (so.objectType == 0)
					{
						if (soData.m_distance == 0f)
						{
							soData.m_distance = so.m_distance;
						}
						so.middleZDistance = soData.m_distance;
					}
				}
				if (so.middleZDistance == 0f)
				{
					so.middleZDistance = 1f;
				}
				float num113 = num101;
				if (num108 == 0 && flag16 && so.includeStartSegment && so.startZDistance != 2000f)
				{
					num113 -= so.startZDistance + so.startOverlapOffset;
				}
				else if (num108 != 0 && so.includeStartSegment && so.startZDistance != 2000f)
				{
					num113 -= so.startZDistance + so.startOverlapOffset;
				}
				if (num108 == list23.Count - 1 && flag17 && so.includeEndSegment && so.endZDistance != -2000f)
				{
					num113 -= so.endZDistance;
				}
				else if (num108 != list23.Count - 1 && so.includeEndSegment && so.endZDistance != -2000f)
				{
					num113 -= so.endZDistance;
				}
				float num114 = Mathf.Round(num113 / so.middleZDistance);
				if (num114 == 0f)
				{
					num114 = 1f;
				}
				float num115 = num113 / (num114 * so.middleZDistance / so.scale.z);
				if (!so.averageDistance && so.objectType == 0)
				{
					num115 = 1f;
					flag17 = false;
				}
				if (so.objectType == 0 && so.bridgeObject)
				{
					num115 = 1f;
				}
				if (so.objectType == 1 || so.tunnelObject)
				{
					Terrain[] array = UnityEngine.Object.FindObjectsOfType(typeof(Terrain)) as Terrain[];
					Terrain terrain = OQQOOCQQCD(vecPositions[0]);
					if (terrain != null)
					{
						Vector3 vector21 = (61AAA.min = new Vector3(terrain.transform.position.x, 0f, terrain.transform.position.z));
						vector21.x += terrain.terrainData.size.x;
						vector21.z += terrain.terrainData.size.z;
						61AAA.max = vector21;
						vector21.x = terrain.terrainData.size.x;
						vector21.z = terrain.terrainData.size.z;
						61AAA.size = vector21;
					}
					else if (!02AAA)
					{
						UnityEngine.Debug.LogWarning("EasyRoads3Dv3 Warning: No terrain object in scene. Side object '" + so.name + "' requires a terrain object");
						02AAA = true;
					}
				}
				float num116 = 0f;
				float num117 = 0f;
				float num118 = 0f;
				int num119 = 1;
				int num120 = 0;
				int segmentCount = 0;
				bool flag21 = false;
				int currentVecArrayInt = 0;
				int num121 = 0;
				int num122 = 0;
				int num123 = 1;
				int num124 = 0;
				bool skipStartBlend = false;
				bool skipEndBlend = false;
				if (num108 == 0 && !flag16)
				{
					skipStartBlend = true;
				}
				if (num108 == list23.Count - 1 && !flag17)
				{
					skipEndBlend = true;
				}
				if (num108 == list23.Count - 1)
				{
					lastvecPositionsArray = true;
					if (!flag17)
					{
						skipEndBlend = true;
					}
				}
				flag18 = true;
				á = 0f;
				á = 0f;
				á = 0f;
				4AAAA = 0f;
				5AAA1 = Vector3.zero;
				7AAA1 = 0.25f;
				8AAAA = 0f;
				9AAA1 = 0f;
				BAAAA = 0f;
				CAAA1 = 0f;
				00AAA = Vector3.zero;
				10AA1 = Vector3.zero;
				20AAA = 0.25f;
				30AA1 = 0f;
				40AAA = 0f;
				50AA1 = 0f;
				60AAA = 0f;
				70AA1 = Vector3.zero;
				80AAA = Vector3.zero;
				90AA1 = 0.25f;
				C0AA1 = 0f;
				01AAA = 0f;
				11AA1 = 0f;
				21AAA = 0f;
				31AA1 = Vector3.zero;
				41AAA = Vector3.zero;
				int num125 = 0;
				float steppedHeight = vecPositions[0].y;
				C1AA1 = false;
				float num126 = 0f;
				int lastStep = 0;
				GameObject gameObject = go;
				if (num31 >= 0 && so.objectType == 0)
				{
					gameObject = new GameObject("Section " + num108 + text);
					gameObject.transform.parent = go.transform;
				}
				if (so.randomUVx)
				{
					B0AAA = UnityEngine.Random.value * 0.5f;
				}
				bool shapeDirFlag = false;
				B1AAA = true;
				if (num31 > 0 && num108 - num30 >= 0 && !ERMesh.OQCQCDQDOO(roadScr, num31, list33[num108 - num30], so, mirrored))
				{
					B1AAA = false;
				}
				while (num116 + 0.1f < num101)
				{
					shapeDirFlag = false;
					if (num116 < 0f)
					{
						UnityEngine.Debug.LogError("EasyRoads3Dv3: " + so.name + " - unable to generate side object, please check the side objects setting in the Side Object Manager");
						return;
					}
					num121++;
					num125++;
					if (num116 >= BAAAA)
					{
						9AAA1 = (BAAAA = num116);
						float num127 = UnityEngine.Random.Range(soData.minRandomXPositionDistance, soData.maxRandomXPositionDistance);
						if (num127 < 3f * so.middleZDistance)
						{
							num127 = 3f * so.middleZDistance;
						}
						8AAAA = 0.5f * num127;
						BAAAA += num127;
						CAAA1 = Mathf.Lerp(9AAA1, BAAAA, 0.5f);
						if (!mirrored)
						{
							00AAA.x = UnityEngine.Random.Range(soData.randomMinXPosition, soData.randomMaxXPosition);
						}
						else
						{
							00AAA.x = UnityEngine.Random.Range(0f - soData.randomMaxXPosition, 0f - soData.randomMinXPosition);
						}
						if (BAAAA > num101)
						{
							BAAAA = num101;
							if (BAAAA - 9AAA1 < 3f * so.middleZDistance)
							{
								00AAA.x = 0f;
							}
						}
						if (CAAA1 > num101)
						{
							CAAA1 = num101;
							if (CAAA1 - 9AAA1 < 2f * so.middleZDistance)
							{
								00AAA.x = 0f;
							}
						}
					}
					if (00AAA.x != 0f)
					{
						if (num116 < CAAA1)
						{
							float t7 = (num116 - CAAA1) / (CAAA1 - 9AAA1);
							10AA1.x = Mathf.Lerp(0f, 00AAA.x, Mathf.SmoothStep(0f, 1f, t7));
						}
						else
						{
							float t8 = (num116 - CAAA1) / (BAAAA - CAAA1);
							10AA1.x = Mathf.Lerp(00AAA.x, 0f, Mathf.SmoothStep(0f, 1f, t8));
						}
					}
					if (num116 >= 50AA1)
					{
						40AAA = (50AA1 = num116);
						float num128 = UnityEngine.Random.Range(soData.minRandomYPositionDistance, soData.maxRandomYPositionDistance);
						if (num128 < 3f * so.middleZDistance)
						{
							num128 = 3f * so.middleZDistance;
						}
						30AA1 = 0.5f * num128;
						50AA1 += num128;
						60AAA = Mathf.Lerp(40AAA, 50AA1, 0.5f);
						70AA1.x = UnityEngine.Random.Range(soData.randomMinYPosition, soData.randomMaxYPosition);
						if (50AA1 > num101)
						{
							50AA1 = num101;
							if (50AA1 - 40AAA < 3f * so.middleZDistance)
							{
								70AA1.x = 0f;
							}
						}
						if (60AAA > num101)
						{
							60AAA = num101;
							if (60AAA - 40AAA < 2f * so.middleZDistance)
							{
								70AA1.x = 0f;
							}
						}
					}
					if (70AA1.x != 0f)
					{
						if (num116 < 60AAA)
						{
							float t9 = (num116 - 60AAA) / (60AAA - 40AAA);
							80AAA.x = Mathf.Lerp(0f, 70AA1.x, Mathf.SmoothStep(0f, 1f, t9));
						}
						else
						{
							float t10 = (num116 - 60AAA) / (50AA1 - 60AAA);
							80AAA.x = Mathf.Lerp(70AA1.x, 0f, Mathf.SmoothStep(0f, 1f, t10));
						}
					}
					if (num116 >= á)
					{
						á = (á = num116);
						float num129 = UnityEngine.Random.Range(soData.minRandomRotationDistance, soData.maxRandomRotationDistance);
						if (num129 < 3f * so.middleZDistance)
						{
							num129 = 3f * so.middleZDistance;
						}
						á = 0.5f * num129;
						á += num129;
						4AAAA = Mathf.Lerp(á, á, 0.5f);
						if (!mirrored)
						{
							5AAA1.x = UnityEngine.Random.Range(soData.randomMinRotation, soData.randomMaxRotation);
						}
						else
						{
							5AAA1.x = UnityEngine.Random.Range(0f - soData.randomMaxRotation, 0f - soData.randomMinRotation);
						}
						if (á > num101)
						{
							á = num101;
							if (á - á < 3f * so.middleZDistance)
							{
								5AAA1.x = 0f;
							}
						}
						if (4AAAA > num101)
						{
							4AAAA = num101;
							if (4AAAA - á < 2f * so.middleZDistance)
							{
								5AAA1.x = 0f;
							}
						}
						if (5AAA1.x != 0f && list29[num108].Count > 0 && á > list29[num108][0])
						{
							á = 11AA1 + so.middleZDistance;
							4AAAA = Mathf.Lerp(á, á, 0.5f);
							5AAA1.x = 0f;
						}
					}
					if (list29[num108].Count > 0 && num116 > list29[num108][0])
					{
						01AAA = (11AA1 = num116);
						11AA1 += list30[num108][0];
						21AAA = Mathf.Lerp(01AAA, 11AA1, 0.5f);
						31AA1.x = list31[num108][0];
						C0AA1 = 0.5f * list30[num108][0];
						list29[num108].RemoveAt(0);
						list30[num108].RemoveAt(0);
						list31[num108].RemoveAt(0);
					}
					if (5AAA1.x != 0f)
					{
						if (num116 < 4AAAA)
						{
							float t11 = (num116 - á) / (4AAAA - á);
							6AAAA.x = Mathf.Lerp(0f, 5AAA1.x, Mathf.SmoothStep(0f, 1f, t11));
						}
						else
						{
							float t12 = (num116 - 4AAAA) / (á - 4AAAA);
							6AAAA.x = Mathf.Lerp(5AAA1.x, 0f, Mathf.SmoothStep(0f, 1f, t12));
						}
					}
					rotateFlag = list34.Count > num108 && list34[num108];
					if (so.objectType == 0)
					{
						float num130 = num116;
						if (so.density != 0f)
						{
							num130 += UnityEngine.Random.value * so.density;
							if (num130 + 0.1f > num101)
							{
								num130 = num101 + 0.01f;
							}
						}
						ODOODODODO(gameObject, num130, num115, so, vecPositions, list16, list17, list18, list19, list35, currentVecArrayInt, num121, roadScr, -1, soData, mirrored, rotateFlag, list33, shapeDirFlag, num108);
						if (!(num116 + soData.m_distance * num115 + 1f >= num101) || !roadScr.closedTrack || num108 < list23.Count - 1 || !OOQDOCDDCO(roadScr, so, 0, mirrored) || !flag6)
						{
						}
						num116 += soData.m_distance * num115;
						OCQCOOQCDO(num116, list35, ref currentVecArrayInt);
					}
					else if (so.objectType == 1)
					{
						ODCQCCDOQO(num116, so.meshObjects[0], 1, roadScr.markersExt, list7, list8, num119, vecPositions, list16, list17, list18, list19, list35, currentVecArrayInt, debugFlag: false, segmentCount, flag21, num115, so, roadScr, nodeList, clampUVYPerc, num109, soData, mirrored, shapeDirFlag);
						if (so.startObject != null && num121 == 1)
						{
							ODOODODODO(gameObject, num116, num115, so, vecPositions, list16, list17, list18, list19, list35, currentVecArrayInt, num121, roadScr, 0, soData, mirrored, rotateFlag, list33, shapeDirFlag, num108);
						}
						else if (so.connectionObject != null && num121 > 1 && !flag21)
						{
							ODOODODODO(gameObject, num116, num115, so, vecPositions, list16, list17, list18, list19, list35, currentVecArrayInt, num121, roadScr, 1, soData, mirrored, rotateFlag, list33, shapeDirFlag, num108);
						}
						else if (flag21 && so.endObject != null && flag17)
						{
							ODOODODODO(gameObject, num116, num115, so, vecPositions, list16, list17, list18, list19, list35, currentVecArrayInt, num121, roadScr, 2, soData, mirrored, rotateFlag, list33, shapeDirFlag, num108);
						}
						if (so.position == 0)
						{
							int num131 = currentVecArrayInt;
							OCQCOOQCDO(num116, list35, ref currentVecArrayInt);
							if (so.scaleToRoad)
							{
								if (num131 < currentVecArrayInt)
								{
									num122 = 0;
								}
								else
								{
									num122++;
								}
								if (num122 >= 1 && currentVecArrayInt > 0)
								{
									num116 = 0.2f + num101;
								}
								num116 += Vector3.Distance(vecPositions[currentVecArrayInt], vecPositions[currentVecArrayInt + 1]);
							}
							else
							{
								num116 += so.middleZDistance * num115;
							}
						}
						else
						{
							currentVecArrayInt++;
							num116 = list35[currentVecArrayInt];
						}
						if (num116 + 0.1f > num101 && num116 - 0.25f < num101)
						{
							num116 = num101 - 0.11f;
							flag21 = true;
						}
						if (!flag21 || num108 < list23.Count - 1)
						{
							CheckVertexLimit(so, 0, force: false);
						}
					}
					else
					{
						for (int num132 = 0; num132 < so.meshObjects.Count; num132++)
						{
							so.meshObjects[num132].vecCount = so.meshObjects[num132].sVecs.Count;
							if (num116 == 0f && so.includeStartSegment && (flag16 || num108 != 0))
							{
								if (so.meshObjects[num132].zValuesStart.Count > 0)
								{
									ODOCOOOQOC(num116, so.meshObjects[num132], 0, roadScr.markersExt, list7, list8, num119, vecPositions, list16, list17, list18, list19, list35, currentVecArrayInt, debugFlag: false, segmentCount, lastSegment: false, 1f, so, halfRoadWidth, roadScr, flag18, skipStartBlend, skipEndBlend, ref forward, ref startPos, soData, mirrored, ref steppedHeight, ref lastStep);
									if (so.boxcollider)
									{
										AddBoxCollider(go, so, so.startZDistance, num116, vecPositions, list35, currentVecArrayInt, roadScr, list18, list17, soData);
									}
								}
							}
							else if (!flag21 || !so.includeEndSegment || (!flag17 && num108 == list23.Count - 1))
							{
								ODOCOOOQOC(num116, so.meshObjects[num132], 1, roadScr.markersExt, list7, list8, num119, vecPositions, list16, list17, list18, list19, list35, currentVecArrayInt, debugFlag: false, segmentCount, lastSegment: false, num115, so, halfRoadWidth, roadScr, flag18, skipStartBlend, skipEndBlend, ref forward, ref startPos, soData, mirrored, ref steppedHeight, ref lastStep);
								if (so.boxcollider)
								{
									AddBoxCollider(go, so, so.middleZDistance, num116, vecPositions, list35, currentVecArrayInt, roadScr, list18, list17, soData);
								}
							}
							else if (so.meshObjects[num132].zValuesEnd.Count > 0)
							{
								ODOCOOOQOC(num116, so.meshObjects[num132], 2, roadScr.markersExt, list7, list8, num119, vecPositions, list16, list17, list18, list19, list35, currentVecArrayInt, debugFlag: true, segmentCount, lastSegment: true, 1f, so, halfRoadWidth, roadScr, flag18, skipStartBlend, skipEndBlend, ref forward, ref startPos, soData, mirrored, ref steppedHeight, ref lastStep);
								if (so.boxcollider)
								{
									AddBoxCollider(go, so, so.endZDistance, num116, vecPositions, list35, currentVecArrayInt, roadScr, list18, list17, soData);
								}
							}
						}
						if (so.startObject != null && num121 == 1)
						{
							ODOODODODO(go, num116, num115, so, vecPositions, list16, list17, list18, list19, list35, currentVecArrayInt, num121, roadScr, 0, soData, mirrored, rotateFlag, list33, shapeDirFlag, num108);
						}
						else if (so.connectionObject != null && num121 > 1 && num123 == so.connectionRatio)
						{
							ODOODODODO(go, num116, num115, so, vecPositions, list16, list17, list18, list19, list35, currentVecArrayInt, num121, roadScr, 1, soData, mirrored, rotateFlag, list33, shapeDirFlag, num108);
						}
						num123++;
						if (num123 > so.connectionRatio)
						{
							num123 = 1;
						}
						bool flag22 = flag21;
						if (num116 == 0f && so.includeStartSegment && !flag19)
						{
							num116 = (so.scaleToRoad ? (num116 + Vector3.Distance(vecPositions[currentVecArrayInt], vecPositions[currentVecArrayInt + 1])) : (num116 + (so.startZDistance - so.startOverlapOffset)));
							OCQCOOQCDO(num116, list35, ref currentVecArrayInt);
						}
						else if (flag21 && so.includeEndSegment)
						{
							num116 = (so.scaleToRoad ? (num116 + Vector3.Distance(vecPositions[currentVecArrayInt], vecPositions[currentVecArrayInt + 1])) : (num116 + (so.endZDistance + so.endOverlapOffset)));
						}
						else
						{
							num116 = (so.scaleToRoad ? (num116 + Vector3.Distance(vecPositions[currentVecArrayInt], vecPositions[currentVecArrayInt + 1])) : (num116 + so.middleZDistance * num115));
							int num133 = currentVecArrayInt;
							OCQCOOQCDO(num116, list35, ref currentVecArrayInt);
							if (!so.scaleToRoad)
							{
							}
						}
						if (num116 + so.endZDistance + so.endOverlapOffset + 0.1f >= num101)
						{
							flag21 = true;
						}
						if (so.scaleToRoad && currentVecArrayInt >= vecPositions.Count - 3)
						{
							flag21 = true;
						}
						if (flag21)
						{
							if (so.includeEndSegment)
							{
								CheckVertexLimit(so, 2, force: false);
							}
							else
							{
								CheckVertexLimit(so, 1, force: false);
							}
						}
						else if (flag22)
						{
							if (num108 < list23.Count - 1)
							{
								if (so.includeStartSegment)
								{
									CheckVertexLimit(so, 0, force: false);
								}
								else
								{
									CheckVertexLimit(so, 1, force: false);
								}
							}
						}
						else
						{
							CheckVertexLimit(so, 1, force: false);
						}
					}
					if (list8.Count > num119 && num116 > list8[num119])
					{
						num119++;
					}
					segmentCount++;
					flag18 = false;
				}
				if ((so.objectType == 0 || so.connectionObject != null || so.endObject != null) && flag17 && so.objectType != 1)
				{
					C1AA1 = true;
					ODOODODODO(gameObject, num116, num115, so, vecPositions, list16, list17, list18, list19, list35, currentVecArrayInt, num121, roadScr, 2, soData, mirrored, rotateFlag, list33, shapeDirFlag, num108);
				}
				if (num108 >= num30 && so.objectType == 0 && ((so.combine && num31 > 0) || (num31 > 0 && !B1AAA)))
				{
					int num134 = 65000;
					if (gameObject.transform.childCount * so.maxVertices <= num134)
					{
						ERMeshCombineUtility.CombineMesh(gameObject, null, gameObject.transform, roadScr.isSideObject);
						go.GetComponent<ERSideObjectInstance>().batchedObjects.Clear();
						go.GetComponent<ERSideObjectInstance>().batches = false;
					}
					if (!B1AAA)
					{
						gameObject.GetComponent<MeshRenderer>().sharedMaterial = roadScr.baseScript.soSectionMaterial;
					}
					ERSideObjectSection eRSideObjectSection = gameObject.AddComponent<ERSideObjectSection>();
					eRSideObjectSection.road = roadScr;
					eRSideObjectSection.sectionIndex = list33[num108 - num30];
					eRSideObjectSection.mirrored = mirrored;
					eRSideObjectSection.sectionListIndex = num31;
					if ((so.relativeTo == 1 && !mirrored) || (so.relativeTo == 2 && mirrored))
					{
						eRSideObjectSection.leftright = 0;
					}
					else
					{
						eRSideObjectSection.leftright = 1;
					}
					eRSideObjectSection.soId = so.id;
				}
				if (so.objectType != 1 || so.clampUVY)
				{
				}
			}
			if (so.objectType != 0)
			{
				if (!flag17)
				{
					for (int num135 = 0; num135 < so.meshObjects.Count; num135++)
					{
						for (int num136 = 0; num136 < so.meshObjects[num135].middleStartInts.Count; num136++)
						{
							List<Vector3> sVecs = so.meshObjects[num135].sVecs;
							int index = so.meshObjects[num135].middleStartInts[num136];
							Vector3 value = (so.meshObjects[num135].sVecs[so.meshObjects[num135].sVecs.Count - so.meshObjects[num135].vecs.Count + so.meshObjects[num135].middleEndInts[num136]] = Vector3.Lerp(so.meshObjects[num135].sVecs[so.meshObjects[num135].middleStartInts[num136]], so.meshObjects[num135].sVecs[so.meshObjects[num135].sVecs.Count - so.meshObjects[num135].vecs.Count + so.meshObjects[num135].middleEndInts[num136]], 0.5f));
							sVecs[index] = value;
							if (so.smoothMiddle)
							{
								so.meshObjects[num135].normalArray1.Add(so.meshObjects[num135].middleStartInts[num136]);
								so.meshObjects[num135].normalArray2.Add(so.meshObjects[num135].sVecs.Count - so.meshObjects[num135].vecs.Count + so.meshObjects[num135].middleEndInts[num136]);
							}
						}
					}
				}
				if (so.objectType == 1 && roadScr.closedTrack && flag5 && flag6)
				{
					for (int num137 = 0; num137 < so.nodeList.Count; num137++)
					{
						List<Vector3> sVecs2 = so.meshObjects[0].sVecs;
						int index2 = num137;
						Vector3 value = (so.meshObjects[0].sVecs[so.meshObjects[0].sVecs.Count - so.nodeList.Count + num137] = Vector3.Lerp(so.meshObjects[0].sVecs[num137], so.meshObjects[0].sVecs[so.meshObjects[0].sVecs.Count - so.nodeList.Count + num137], 0.5f));
						sVecs2[index2] = value;
						so.meshObjects[0].normalArray1.Add(num137);
						so.meshObjects[0].normalArray2.Add(so.meshObjects[0].sVecs.Count - so.nodeList.Count + num137);
					}
				}
				if (so.objectType == 1 && so.startEndCaps && so.meshObjects[0].sVecs.Count > 0)
				{
					int count3 = so.nodeList.Count;
					int num138 = count3;
					for (int num139 = 0; num139 < count3; num139++)
					{
						if (so.hardEdge[num139])
						{
							num138++;
						}
					}
					int num140 = so.meshObjects[0].sVecs.Count - num138;
					List<Vector3> list39 = new List<Vector3>();
					List<Vector3> list40 = new List<Vector3>();
					List<Vector2> list41 = new List<Vector2>();
					List<Vector2> list42 = new List<Vector2>();
					List<Color> list43 = new List<Color>();
					int num141 = 0;
					int num142 = so.meshObjects[0].sTriangles[0];
					int num143 = 0;
					for (int num144 = 0; num144 < count3; num144++)
					{
						if (so.meshObjects[0].sVecs.Count > num142)
						{
							list39.Add(so.meshObjects[0].sVecs[num142]);
						}
						list42.Add(Vector2.zero);
						list43.Add(Color.white);
						if (so.meshObjects[0].sVecs.Count > num140 + num143)
						{
							list40.Add(so.meshObjects[0].sVecs[num140 + num143]);
						}
						num142++;
						num143++;
						if (so.hardEdge[num144])
						{
							num142++;
							num143++;
						}
					}
					List<int> list44 = new List<int>(so.startCapTris);
					if (mirrored)
					{
						list44 = new List<int>(so.startCapTrisMirrored);
					}
					int count4 = so.meshObjects[0].sVecs.Count;
					for (int num145 = 0; num145 < list44.Count; num145++)
					{
						list44[num145] += count4;
					}
					List<Vector2> list45 = new List<Vector2>(so.startCapUVs);
					if (mirrored)
					{
						list45.Reverse();
					}
					so.meshObjects[0].sVecs.AddRange(list39);
					so.meshObjects[0].sUv.AddRange(list45);
					so.meshObjects[0].sUv2.AddRange(list42);
					so.meshObjects[0].sTriangles.AddRange(list44);
					so.meshObjects[0].sColors.AddRange(list43);
					count4 = list39.Count;
					int num146 = 0;
					for (int num147 = 0; num147 < list44.Count; num147 += 3)
					{
						list44[num147] += count4;
						list44[num147 + 1] += count4;
						list44[num147 + 2] += count4;
						num146 = list44[num147 + 1];
						list44[num147 + 1] = list44[num147 + 2];
						list44[num147 + 2] = num146;
					}
					List<Vector2> list46 = new List<Vector2>(so.endCapUVs);
					if (mirrored)
					{
						list46.Reverse();
					}
					so.meshObjects[0].sVecs.AddRange(list40);
					so.meshObjects[0].sUv.AddRange(list46);
					so.meshObjects[0].sUv2.AddRange(list42);
					so.meshObjects[0].sTriangles.AddRange(list44);
					so.meshObjects[0].sColors.AddRange(list43);
					for (int num148 = 0; num148 < so.meshObjects[0].sVecsGroups.Count; num148++)
					{
						count3 = so.nodeList.Count;
						num140 = so.meshObjects[0].sVecsGroups[num148].Count - num138;
						list39 = new List<Vector3>();
						list40 = new List<Vector3>();
						list41 = new List<Vector2>();
						list42 = new List<Vector2>();
						list43 = new List<Color>();
						num141 = 0;
						num142 = so.meshObjects[0].sTrianglesGroups[num148][0];
						num143 = 0;
						for (int num149 = 0; num149 < count3; num149++)
						{
							if (so.meshObjects[0].sVecsGroups[num148].Count > num142)
							{
								list39.Add(so.meshObjects[0].sVecsGroups[num148][num142]);
							}
							list42.Add(Vector2.zero);
							list43.Add(Color.white);
							if (so.meshObjects[0].sVecsGroups[num148].Count > num140 + num143)
							{
								list40.Add(so.meshObjects[0].sVecsGroups[num148][num140 + num143]);
							}
							num143++;
							num142++;
							if (so.hardEdge[num149])
							{
								num143++;
								num142++;
							}
						}
						list44 = new List<int>(so.startCapTris);
						if (mirrored)
						{
							list44 = new List<int>(so.startCapTrisMirrored);
						}
						count4 = so.meshObjects[0].sVecsGroups[num148].Count;
						so.meshObjects[0].sVecsGroups[num148].AddRange(list39);
						so.meshObjects[0].sUvGroups[num148].AddRange(so.startCapUVs);
						so.meshObjects[0].sUv2Groups[num148].AddRange(list42);
						so.meshObjects[0].sColorsGroups[num148].AddRange(list43);
						for (int num150 = 0; num150 < list44.Count; num150++)
						{
							list44[num150] += count4;
						}
						so.meshObjects[0].sTrianglesGroups[num148].AddRange(list44);
						so.meshObjects[0].sVecsGroups[num148].AddRange(list40);
						so.meshObjects[0].sUvGroups[num148].AddRange(so.endCapUVs);
						so.meshObjects[0].sUv2Groups[num148].AddRange(list42);
						so.meshObjects[0].sColorsGroups[num148].AddRange(list43);
						list44 = new List<int>(so.startCapTris);
						if (mirrored)
						{
							list44 = new List<int>(so.startCapTrisMirrored);
						}
						count4 = num140 + num138 + list39.Count;
						num146 = 0;
						for (int num151 = 0; num151 < list44.Count; num151 += 3)
						{
							list44[num151] += count4;
							list44[num151 + 1] += count4;
							list44[num151 + 2] += count4;
							num146 = list44[num151 + 1];
							list44[num151 + 1] = list44[num151 + 2];
							list44[num151 + 2] = num146;
						}
						so.meshObjects[0].sTrianglesGroups[num148].AddRange(list44);
					}
				}
				so.meshObjects[0].ODDDOCDCQO(roadScr, go, so, roadScr.baseScript, mirrored, num31, list33, num30);
				go.GetComponent<ERSideObjectInstance>().vecs = debugvecs;
				if (so.snapVertexColors && so.tunnelObject && so.objectType == 2)
				{
					go.GetComponent<ERSideObjectInstance>().postProcess = true;
				}
				return;
			}
			Transform transform = go.transform.Find("container");
			if (so.combine && num31 < 0)
			{
				int num152 = 65000;
				if (so.instantiatedObjects.Count * so.maxVertices > num152)
				{
					List<GameObject> list47 = new List<GameObject>();
					float num153 = Mathf.Ceil(so.instantiatedObjects.Count * so.maxVertices / num152);
					int num154 = 1;
					int num155 = 0;
					GameObject gameObject2 = new GameObject("Batch 1");
					list47.Add(gameObject2);
					gameObject2.transform.parent = go.transform;
					while (so.instantiatedObjects.Count > 0)
					{
						if ((num155 + 1) * so.maxVertices > num152)
						{
							ERMeshCombineUtility.CombineMesh(gameObject2, null, transform, roadScr.isSideObject);
							num154++;
							num155 = 0;
							gameObject2 = new GameObject("Batch " + num154);
							list47.Add(gameObject2);
							gameObject2.transform.parent = go.transform;
						}
						so.instantiatedObjects[0].transform.parent = gameObject2.transform;
						num155++;
						so.instantiatedObjects.RemoveAt(0);
					}
					if (num155 > 0)
					{
						ERMeshCombineUtility.CombineMesh(gameObject2, null, transform, roadScr.isSideObject);
					}
					go.GetComponent<ERSideObjectInstance>().batchedObjects = new List<GameObject>(list47);
					go.GetComponent<ERSideObjectInstance>().batches = true;
				}
				else
				{
					ERMeshCombineUtility.CombineMesh(go, null, transform, roadScr.isSideObject);
					go.GetComponent<ERSideObjectInstance>().batchedObjects.Clear();
					go.GetComponent<ERSideObjectInstance>().batches = false;
				}
				go.GetComponent<ERSideObjectInstance>().combined = true;
			}
			else
			{
				if (transform != null)
				{
					UnityEngine.Object.DestroyImmediate(transform.gameObject);
				}
				if ((bool)go.GetComponent<MeshFilter>())
				{
					UnityEngine.Object.DestroyImmediate(go.GetComponent<MeshFilter>());
				}
				if ((bool)go.GetComponent<MeshRenderer>())
				{
					UnityEngine.Object.DestroyImmediate(go.GetComponent<MeshRenderer>());
				}
			}
		}
		else
		{
			UnityEngine.Debug.LogError("Missing side object data: " + go.name + " for road: " + roadScr.gameObject.name);
			if (Application.isEditor && !Application.isPlaying)
			{
				UnityEngine.Object.DestroyImmediate(go);
			}
			else
			{
				UnityEngine.Object.Destroy(go);
			}
		}
	}

	public static void AddBoxCollider(GameObject go, SideObject so, float zDist, float curDist, List<Vector3> vecPositions, List<float> vecDistances, int currentVecArrayInt, ERModularRoad roadScr, List<Vector3> vecPositionsCenter, List<Vector3> vecPositionsRight, ERSORoadExt soData)
	{
		Vector3 v2;
		Vector3 zero;
		Vector3 v = (v2 = (zero = Vector3.zero));
		if (!so.scaleToRoad)
		{
			ODCCQODCOQ(curDist, vecPositions, vecDistances, currentVecArrayInt, ref v, ref v2, doSecond: false, debugFlag: false);
			ODCCQODCOQ(curDist + zDist, vecPositions, vecDistances, currentVecArrayInt, ref v2, ref v2, doSecond: false, debugFlag: false);
		}
		else
		{
			if (currentVecArrayInt < 0 || currentVecArrayInt >= vecPositions.Count)
			{
				return;
			}
			v = vecPositions[currentVecArrayInt];
			v2 = vecPositions[currentVecArrayInt + 1];
			zDist = Vector3.Distance(v, v2);
		}
		if (!roadScr.baseScript.isInBuildMode && !roadScr.isSideObject)
		{
			if (so.snapToTerrain)
			{
				v.y = ODQDQDQDQO.OOCQOOCOQC(v, roadScr.baseScript) + soData.yPosition;
			}
			if (so.snapToTerrain)
			{
				v2.y = ODQDQDQDQO.OOCQOOCOQC(v2, roadScr.baseScript) + soData.yPosition;
			}
		}
		else if (roadScr.snapToTerrain || !roadScr.isSideObject)
		{
			if (so.snapToTerrain)
			{
				v.y = ODQDQDQDQO.OOCQOOCOQC(v, roadScr.baseScript) + soData.yPosition;
			}
			if (so.snapToTerrain)
			{
				v2.y = ODQDQDQDQO.OOCQOOCOQC(v2, roadScr.baseScript) + soData.yPosition;
			}
		}
		zero = (v2 - v).normalized;
		if ((double)so.boxSize.x < 0.01)
		{
			so.boxSize.x = 0.01f;
		}
		GameObject gameObject = new GameObject("BoxCollider");
		gameObject.transform.position = Vector3.Lerp(v, v2, 0.5f);
		gameObject.transform.forward = zero;
		BoxCollider boxCollider = gameObject.AddComponent<BoxCollider>();
		boxCollider.size = new Vector3(so.boxSize.x * so.scale.x * so.boxColliderScale.x, so.boxSize.y * so.scale.y * so.boxColliderScale.y, zDist * so.scale.z * so.boxColliderScale.z);
		boxCollider.center = new Vector3(so.boxOffset.x * so.scale.x, so.boxOffset.y * so.scale.y, 0f);
		Vector3 adjustedRotation = Vector3.zero;
		Vector3 adjustedRotation2 = Vector3.zero;
		Vector3 adjustedRotation3 = Vector3.zero;
		if (00AAA.x != 0f)
		{
			OCQQCOOQDQ(curDist, ref adjustedRotation, ref 10AA1, 9AAA1, CAAA1, BAAAA, 8AAAA, 00AAA);
		}
		if (70AA1.x != 0f)
		{
			OCQQCOOQDQ(curDist, ref adjustedRotation2, ref 80AAA, 40AAA, 60AAA, 50AA1, 30AA1, 70AA1);
		}
		if (5AAA1.x != 0f)
		{
			OCQQCOOQDQ(curDist, ref adjustedRotation3, ref 6AAAA, á, 4AAAA, á, á, 5AAA1);
		}
		if (31AA1.x != 0f)
		{
			OCCOOCDCQQ(curDist, ref adjustedRotation3);
		}
		if (so.align == 1 || (sidewaysFlag && so.align != 0))
		{
			ODQDQDQDQO.OCCDCDCQQQ(gameObject, v, roadScr, adjustedRotation3);
		}
		else if (so.align == 2)
		{
			ODQDQDQDQO.OQQOODCODQ(gameObject, v2, v, zero, adjustedRotation3);
		}
		else if (so.align == 3)
		{
			if (currentSplineInt >= vecPositionsCenter.Count - 1)
			{
				currentSplineInt = vecPositionsCenter.Count - 2;
			}
			ODQDQDQDQO.OCOQCDDODO(gameObject, vecPositionsCenter[currentSplineInt], roadScr, adjustedRotation3, vecPositionsCenter[currentSplineInt + 1], vecPositionsRight[currentSplineInt]);
		}
		else if (adjustedRotation3 != Vector3.zero)
		{
			ODQDQDQDQO.OQQOODCODQ(gameObject, v2, v, zero, adjustedRotation3);
		}
		gameObject.transform.parent = go.transform;
	}

	public static void CheckVertexLimit(SideObject so, int segment, bool force)
	{
		float num = 65000f;
		bool flag = false;
		if (so.objectType == 1)
		{
			if ((float)(so.meshObjects[0].sVecs.Count + so.nodeList.Count) >= num)
			{
				flag = true;
			}
		}
		else
		{
			foreach (ERMesh meshObject in so.meshObjects)
			{
				int num2 = 0;
				switch (segment)
				{
				case 0:
					num2 = meshObject.sStartVecs.Count;
					break;
				case 1:
					num2 = meshObject.vecsInt.Count;
					break;
				case 2:
					num2 = meshObject.endVecsInt.Count;
					break;
				}
				if ((float)(meshObject.sVecs.Count + num2) > num)
				{
					flag = true;
				}
			}
		}
		if (!(flag || force))
		{
			return;
		}
		foreach (ERMesh meshObject2 in so.meshObjects)
		{
			meshObject2.sVecsGroups.Add(new List<Vector3>(meshObject2.sVecs));
			meshObject2.sUvGroups.Add(new List<Vector2>(meshObject2.sUv));
			meshObject2.sUv2Groups.Add(new List<Vector2>(meshObject2.sUv2));
			meshObject2.sColorsGroups.Add(new List<Color>(meshObject2.sColors));
			meshObject2.sNormalsGroups.Add(new List<Vector3>(meshObject2.sNormals));
			meshObject2.sTangentsGroups.Add(new List<Vector4>(meshObject2.sTangents));
			meshObject2.sTrianglesGroups.Add(new List<int>(meshObject2.sTriangles));
			meshObject2.normalArray1Group.Add(new List<int>(meshObject2.normalArray1));
			meshObject2.normalArray2Group.Add(new List<int>(meshObject2.normalArray2));
			meshObject2.sTerrainNormalsGroups.Add(new List<Vector3>(meshObject2.sTerrainNormals));
			if (so.objectType == 1)
			{
				int count = Math.Max(0, meshObject2.sVecs.Count - so.nodeList.Count);
				if (meshObject2.sVecs.Count > 0)
				{
					meshObject2.sVecs.RemoveRange(0, count);
				}
				if (meshObject2.sUv.Count > 0)
				{
					meshObject2.sUv.RemoveRange(0, count);
				}
				if (meshObject2.sUv2.Count > 0)
				{
					meshObject2.sUv2.RemoveRange(0, count);
				}
				if (meshObject2.sColors.Count > 0)
				{
					meshObject2.sColors.RemoveRange(0, count);
				}
				if (meshObject2.sNormals.Count > 0)
				{
					meshObject2.sNormals.RemoveRange(0, count);
				}
				if (meshObject2.sTangents.Count > 0)
				{
					meshObject2.sTangents.RemoveRange(0, count);
				}
				meshObject2.sTriangles.Clear();
				if (meshObject2.normalArray1.Count > 0)
				{
					meshObject2.normalArray1.RemoveRange(0, count);
				}
				if (meshObject2.normalArray2.Count > 0)
				{
					meshObject2.normalArray2.RemoveRange(0, count);
				}
				if (meshObject2.sTerrainNormals.Count > 0)
				{
					meshObject2.sTerrainNormals.RemoveRange(0, count);
				}
			}
			else
			{
				meshObject2.sVecs.Clear();
				meshObject2.sUv.Clear();
				meshObject2.sUv2.Clear();
				meshObject2.sColors.Clear();
				meshObject2.sNormals.Clear();
				meshObject2.sTangents.Clear();
				meshObject2.sTriangles.Clear();
				meshObject2.normalArray1.Clear();
				meshObject2.normalArray2.Clear();
				meshObject2.sTerrainNormals.Clear();
			}
		}
	}

	public static void ODOCOOOQOC(float curDist, ERMesh mobject, int meshSegment, List<ERMarkerExt> markers, List<float> segmentDistances, List<float> segmentAccDistances, int markerIndex, List<Vector3> vecPositions, List<Vector3> vecPositionsLeft, List<Vector3> vecPositionsRight, List<Vector3> vecPositionsCenter, List<float> vecAngles, List<float> vecDistances, int currentVecArrayInt, bool debugFlag, int segmentCount, bool lastSegment, float scaleFactor, SideObject so, float halfRoadWidth, ERModularRoad roadScr, bool newSegment, bool skipStartBlend, bool skipEndBlend, ref Vector3 forward, ref Vector3 startPos, ERSORoadExt soData, bool mirrored, ref float steppedHeight, ref int lastStep)
	{
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		List<Vector2> list3 = new List<Vector2>();
		List<Color> list4 = new List<Color>();
		List<Vector3> list5 = new List<Vector3>();
		List<Vector4> list6 = new List<Vector4>();
		List<int> list7 = new List<int>();
		List<Vector3> list8 = new List<Vector3>();
		List<Vector2> list9 = new List<Vector2>();
		List<Vector2> list10 = new List<Vector2>();
		List<Color> list11 = new List<Color>();
		List<Vector3> list12 = new List<Vector3>();
		List<Vector4> collection = new List<Vector4>();
		List<int> list13 = new List<int>();
		List<float> list14 = new List<float>();
		List<ZIndexArray> list15 = new List<ZIndexArray>();
		List<Vector3> list16 = new List<Vector3>();
		List<Vector3> list17 = new List<Vector3>();
		int num = 0;
		bool flag = true;
		switch (meshSegment)
		{
		case 0:
			list16 = new List<Vector3>(mobject.startVecs);
			list17 = new List<Vector3>(mobject.startNormals);
			list = mobject.sVecs;
			list2 = mobject.sUv;
			list3 = mobject.sUv2;
			list4 = mobject.sColors;
			list5 = mobject.sNormals;
			list6 = mobject.sTangents;
			list7 = mobject.sTriangles;
			list14 = mobject.zValuesStart;
			list15 = mobject.zValueVecIndexesStart;
			list8 = mobject.startVecs;
			list9 = mobject.startUv;
			list10 = mobject.startUv2;
			list11 = mobject.startColors;
			list12 = mobject.startNormals;
			collection = mobject.startTangents;
			list13 = (mirrored ? mobject.startTriangles2 : mobject.startTriangles);
			break;
		case 1:
			if (so.stepDown && so.stepUp)
			{
				float tmpDist = curDist + so.middleZDistance * scaleFactor;
				Vector3 v2;
				Vector3 v = (v2 = Vector3.zero);
				ODCCQODCOQ(tmpDist, vecPositions, vecDistances, currentVecArrayInt, ref v, ref v2, doSecond: true, debugFlag);
				float num2 = v.y - steppedHeight;
				if (num2 > so.stepDistance)
				{
					num = 1;
				}
				else if (num2 < 0f)
				{
					num = 2;
				}
				if (lastStep > 0 || num > 0)
				{
					flag = false;
				}
				lastStep = num;
			}
			switch (num)
			{
			case 0:
				list16 = new List<Vector3>(mobject.vecs);
				list17 = new List<Vector3>(mobject.normals);
				list = mobject.sVecs;
				list2 = mobject.sUv;
				list3 = mobject.sUv2;
				list4 = mobject.sColors;
				list5 = mobject.sNormals;
				list6 = mobject.sTangents;
				list7 = mobject.sTriangles;
				list14 = mobject.zValues;
				list15 = mobject.zValueVecIndexes;
				list8 = mobject.vecs;
				list9 = mobject.uv;
				list10 = mobject.uv2;
				list11 = mobject.colors;
				list12 = mobject.normals;
				collection = mobject.tangents;
				list13 = (mirrored ? mobject.triangles2 : mobject.triangles);
				break;
			case 1:
				list16 = new List<Vector3>(mobject.suVecs);
				list17 = new List<Vector3>(mobject.suNormals);
				list = mobject.sVecs;
				list2 = mobject.sUv;
				list3 = mobject.sUv2;
				list4 = mobject.sColors;
				list5 = mobject.sNormals;
				list6 = mobject.sTangents;
				list7 = mobject.sTriangles;
				list14 = mobject.zValuesStepUp;
				list15 = mobject.zValueVecIndexesStepUp;
				list8 = mobject.suVecs;
				list9 = mobject.suUv;
				list10 = mobject.suUv2;
				list11 = mobject.suColors;
				list12 = mobject.suNormals;
				collection = mobject.suTangents;
				list13 = (mirrored ? mobject.suTriangles2 : mobject.suTriangles);
				break;
			case 2:
				list16 = new List<Vector3>(mobject.sdVecs);
				list17 = new List<Vector3>(mobject.sdNormals);
				list = mobject.sVecs;
				list2 = mobject.sUv;
				list3 = mobject.sUv2;
				list4 = mobject.sColors;
				list5 = mobject.sNormals;
				list6 = mobject.sTangents;
				list7 = mobject.sTriangles;
				list14 = mobject.zValuesStepDown;
				list15 = mobject.zValueVecIndexesStepDown;
				list8 = mobject.sdVecs;
				list9 = mobject.sdUv;
				list10 = mobject.sdUv2;
				list11 = mobject.sdColors;
				list12 = mobject.sdNormals;
				collection = mobject.sdTangents;
				list13 = (mirrored ? mobject.sdTriangles2 : mobject.sdTriangles);
				break;
			}
			break;
		case 2:
			list16 = new List<Vector3>(mobject.endVecs);
			list17 = new List<Vector3>(mobject.endNormals);
			list = mobject.sVecs;
			list2 = mobject.sUv;
			list3 = mobject.sUv2;
			list4 = mobject.sColors;
			list5 = mobject.sNormals;
			list6 = mobject.sTangents;
			list7 = mobject.sTriangles;
			list14 = mobject.zValuesEnd;
			list15 = mobject.zValueVecIndexesEnd;
			list8 = mobject.endVecs;
			list9 = mobject.endUv;
			list10 = mobject.endUv2;
			list11 = mobject.endColors;
			list12 = mobject.endNormals;
			collection = mobject.endTangents;
			list13 = (mirrored ? mobject.endTriangles2 : mobject.endTriangles);
			curDist -= so.endOverlapOffset;
			break;
		}
		flag = false;
		if (so.tunnelObject && so.hasVertexColors && list10.Count < list9.Count)
		{
			list10 = new List<Vector2>(list9);
		}
		try
		{
			float num3 = 0f;
			if (so.scaleToRoad)
			{
				num3 = Vector3.Distance(vecPositions[currentVecArrayInt], vecPositions[currentVecArrayInt + 1]);
				switch (meshSegment)
				{
				case 0:
					scaleFactor = num3 / so.startZDistance;
					break;
				case 1:
					scaleFactor = num3 / so.middleZDistance;
					break;
				case 2:
					scaleFactor = num3 / so.endZDistance;
					break;
				}
				curDist = vecDistances[currentVecArrayInt];
			}
			Vector3 zero = Vector3.zero;
			Vector3 zero2 = Vector3.zero;
			Vector3 zero3 = Vector3.zero;
			Vector3 v4;
			Vector3 v3 = (v4 = Vector3.zero);
			Vector3 vector = meshSegment switch
			{
				0 => (vecPositions[1] - vecPositions[0]).normalized, 
				2 => (vecPositions[vecPositions.Count - 1] - vecPositions[vecPositions.Count - 2]).normalized, 
				_ => Vector3.zero, 
			};
			Vector2 value = default(Vector2);
			for (int i = 0; i < list14.Count; i++)
			{
				float num4 = curDist + list14[i] * scaleFactor;
				ODCCQODCOQ(num4, vecPositions, vecDistances, currentVecArrayInt, ref v3, ref v4, doSecond: true, debugFlag);
				if (currentSplineInt >= vecAngles.Count)
				{
					currentSplineInt = vecAngles.Count - 1;
				}
				if (currentSplineInt >= vecPositionsRight.Count)
				{
					currentSplineInt = vecPositionsRight.Count - 1;
				}
				Vector3 vector2 = (lastSegment ? forward : (forward = v4 - v3));
				vector2 = new Vector3(vector2.z, 0f, 0f - vector2.x).normalized;
				float yAngleByDir = ODQDQDQDQO.GetYAngleByDir(forward);
				if (useLastFowardFlag && lastvecPositionsArray && currentSplineInt >= vecPositions.Count - 2)
				{
					forward = roadScr.lastForward;
				}
				if (!roadScr.baseScript.isInBuildMode && !roadScr.isSideObject)
				{
					if (so.snapToTerrain)
					{
						v3.y = (v4.y = ODQDQDQDQO.OOCQOOCOQC(v3, roadScr.baseScript) + soData.yPosition);
					}
					vector2 = (vecPositionsRight[currentSplineInt] - vecPositionsLeft[currentSplineInt]).normalized;
				}
				else if ((roadScr.snapToTerrain || !roadScr.isSideObject) && so.snapToTerrain)
				{
					v3.y = (v4.y = ODQDQDQDQO.OOCQOOCOQC(v3, roadScr.baseScript) + soData.yPosition);
				}
				startPos = v3;
				Vector3 zero4 = Vector3.zero;
				zero = Vector3.zero;
				zero2 = Vector3.zero;
				zero3 = Vector3.zero;
				if (00AAA.x != 0f)
				{
					GetRandomXDistance(num4, ref zero, ref 10AA1, 9AAA1, CAAA1, BAAAA, 8AAAA, 00AAA);
					v3 += vector2 * zero.x;
					v4 += vector2 * zero.x;
				}
				if (70AA1.x != 0f)
				{
					GetRandomXDistance(num4, ref zero2, ref 80AAA, 40AAA, 60AAA, 50AA1, 30AA1, 70AA1);
				}
				if (5AAA1.x != 0f)
				{
					OCQQCOOQDQ(num4, ref zero3, ref 6AAAA, á, 4AAAA, á, á, 5AAA1);
				}
				if (31AA1.x != 0f)
				{
					OCCOOCDCQQ(num4, ref zero3);
				}
				if (so.stepDown && so.stepUp)
				{
					v3.y = steppedHeight;
				}
				for (int j = 0; j < list15[i].index.Count; j++)
				{
					Vector2 vec = list8[list15[i].index[j]];
					Vector3 source = list12[list15[i].index[j]];
					if (mirrored)
					{
						source.x *= -1f;
					}
					source = ODQDQDQDQO.OQQDCOCCCO(source, yAngleByDir).normalized;
					if (mirrored)
					{
						vec.x *= -1f;
					}
					Vector3 v5;
					if (!so.adjustToRoadWidth || Mathf.Abs(vec.x) < so.xOffset)
					{
						v5 = v3 + vector2 * vec.x;
					}
					else if (vec.x < 0f)
					{
						vec.x = vec.x + so.xOffset - halfRoadWidth;
						v5 = v3 + vector2 * vec.x;
					}
					else
					{
						vec.x = vec.x - so.xOffset + halfRoadWidth;
						v5 = v3 + vector2 * vec.x;
					}
					v5.y += vec.y;
					if (so.align == 1 || (sidewaysFlag && so.align != 0))
					{
						ODQDQDQDQO.OCCQCDQQOQ(ref v5, ref source, v3, forward, vec, roadScr, zero3);
					}
					else if (so.align == 2)
					{
						ODQDQDQDQO.OQODQODDOQ(ref v5, ref source, v3, forward, vec, 0f, zero3);
						source = ODQDQDQDQO.OCOOCOOODQ(source, zero3.x, forward);
					}
					else if (so.align == 3)
					{
						ODQDQDQDQO.OQODQODDOQ(ref v5, ref source, v3, forward, vec, vecAngles[currentSplineInt], zero3);
						source = ODQDQDQDQO.OCOOCOOODQ(source, vecAngles[currentSplineInt] + zero3.x, forward);
					}
					else if (zero3.x != 0f)
					{
						ODQDQDQDQO.RandomAlignment(ref v5, ref source, v3, forward, vec, zero3);
						source = ODQDQDQDQO.OCOOCOOODQ(source, zero3.x, forward);
					}
					if (70AA1.x != 0f)
					{
						v5.y += zero2.x;
					}
					list16[list15[i].index[j]] = v5;
					list17[list15[i].index[j]] = source;
					if (so.tunnelObject && so.hasVertexColors)
					{
						if (meshSegment == 0 && so.snapVertexColors && mobject.terrainMesh)
						{
							Color color = list11[list15[i].index[j]];
							float r = list11[list15[i].index[j]].r;
							if (color.g > 0f)
							{
								Vector3 b = ODQDQDQDQO.OCCDCCQDDO(v5, vector);
								if ((double)color.g > 0.9)
								{
									b += 0.5f * vector;
								}
								v5 = Vector3.Lerp(v5, b, color.g);
								list16[list15[i].index[j]] = v5;
							}
							if (color.b > 0f)
							{
								Vector3 pos = v5;
								pos.y += 5f;
								Vector3 b2 = ODQDQDQDQO.ODCCDOCDQD(pos, Vector3.down);
								v5 = Vector3.Lerp(v5, b2, color.b);
								if (color.b == 1f)
								{
									v5.y -= 0.15f;
								}
								list16[list15[i].index[j]] = v5;
							}
						}
						else if (meshSegment == 2 && so.snapVertexColors && mobject.terrainMesh)
						{
							Color color2 = list11[list15[i].index[j]];
							if (color2.g > 0f)
							{
								Vector3 b3 = ODQDQDQDQO.OCCDCCQDDO(v5, -vector);
								if ((double)color2.g > 0.9)
								{
									b3 -= 0.5f * vector;
								}
								v5 = Vector3.Lerp(v5, b3, color2.g);
								list16[list15[i].index[j]] = v5;
							}
							if (color2.b > 0f)
							{
								Vector3 pos2 = v5;
								pos2.y += 5f;
								Vector3 b4 = ODQDQDQDQO.ODCCDOCDQD(pos2, Vector3.down);
								v5 = Vector3.Lerp(v5, b4, color2.b);
								if (color2.b == 1f)
								{
									v5.y -= 0.15f;
								}
								list16[list15[i].index[j]] = v5;
							}
						}
						value.x = (v5.x - 61AAA.min.x) / 61AAA.size.x;
						value.y = (v5.z - 61AAA.min.z) / 61AAA.size.z;
						list10[list15[i].index[j]] = value;
					}
					if (so.tunnelObject && so.randomUVx)
					{
						value = list9[list15[i].index[j]];
						value.x += B0AAA;
						list9[list15[i].index[j]] = value;
					}
				}
			}
			if (debugFlag)
			{
			}
			list.AddRange(list16);
			list2.AddRange(list9);
			list3.AddRange(list10);
			list4.AddRange(list11);
			list5.AddRange(list17);
			list6.AddRange(collection);
			int count = list.Count;
			int num5 = ODQDQDQDQO.ODQCDQOOCO(segmentCount, so, newSegment, mobject, lastSegment, skipStartBlend, skipEndBlend);
			if (num5 == 0 && flag)
			{
				if (count - mobject.vecs.Count - mobject.startVecs.Count >= 0)
				{
					for (int k = 0; k < mobject.startEndInts.Count; k++)
					{
						List<Vector3> list18 = list;
						int index = count - mobject.vecs.Count + mobject.middleStartStartInts[k];
						Vector3 value2 = (list[count - mobject.vecs.Count - mobject.startVecs.Count + mobject.startEndInts[k]] = Vector3.Lerp(list[count - mobject.vecs.Count + mobject.middleStartStartInts[k]], list[count - mobject.vecs.Count - mobject.startVecs.Count + mobject.startEndInts[k]], 0.5f));
						list18[index] = value2;
						if (so.smoothStart)
						{
							mobject.normalArray1.Add(count - mobject.vecs.Count + mobject.middleStartStartInts[k]);
							mobject.normalArray2.Add(count - mobject.vecs.Count - mobject.startVecs.Count + mobject.startEndInts[k]);
						}
					}
				}
			}
			else if (num5 == 1 && num == 0 && flag)
			{
				if (count - 2 * mobject.vecs.Count >= 0)
				{
					for (int l = 0; l < mobject.middleStartInts.Count; l++)
					{
						if (segmentCount == 2)
						{
						}
						List<Vector3> list19 = list;
						int index2 = count - mobject.vecs.Count + mobject.middleStartInts[l];
						Vector3 value2 = (list[count - 2 * mobject.vecs.Count + mobject.middleEndInts[l]] = Vector3.Lerp(list[count - mobject.vecs.Count + mobject.middleStartInts[l]], list[count - 2 * mobject.vecs.Count + mobject.middleEndInts[l]], 0.5f));
						list19[index2] = value2;
						if (so.smoothMiddle)
						{
							mobject.normalArray1.Add(count - mobject.vecs.Count + mobject.middleStartInts[l]);
							mobject.normalArray2.Add(count - 2 * mobject.vecs.Count + mobject.middleEndInts[l]);
						}
					}
				}
			}
			else if (num5 == 2 && flag && count - mobject.endVecs.Count - mobject.vecs.Count >= 0)
			{
				for (int m = 0; m < mobject.middleEndEndInts.Count; m++)
				{
					List<Vector3> list20 = list;
					int index3 = count - mobject.endVecs.Count + mobject.endStartInts[m];
					Vector3 value2 = (list[count - mobject.endVecs.Count - mobject.vecs.Count + mobject.middleEndEndInts[m]] = Vector3.Lerp(list[count - mobject.endVecs.Count + mobject.endStartInts[m]], list[count - mobject.endVecs.Count - mobject.vecs.Count + mobject.middleEndEndInts[m]], 0.5f));
					list20[index3] = value2;
					if (so.smoothEnd)
					{
						mobject.normalArray1.Add(count - mobject.endVecs.Count + mobject.endStartInts[m]);
						mobject.normalArray2.Add(count - mobject.endVecs.Count - mobject.vecs.Count + mobject.middleEndEndInts[m]);
					}
				}
			}
			for (int n = 0; n < list13.Count; n++)
			{
				list7.Add(mobject.vecCount + list13[n]);
			}
		}
		catch
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3 Error: Road: " + roadScr.name + " - Side Object: " + so.name);
		}
		switch (num)
		{
		case 1:
			steppedHeight += so.stepDistance;
			break;
		case 2:
			steppedHeight -= so.stepDistance;
			break;
		}
	}

	public static void ODCQCCDOQO(float curDist, ERMesh mobject, int meshSegment, List<ERMarkerExt> markers, List<float> segmentDistances, List<float> segmentAccDistances, int markerIndex, List<Vector3> vecPositions, List<Vector3> vecPositionsLeft, List<Vector3> vecPositionsRight, List<Vector3> vecPositionsCenter, List<float> vecAngles, List<float> vecDistances, int currentVecArrayInt, bool debugFlag, int segmentCount, bool lastSegment, float scaleFactor, SideObject so, ERModularRoad roadScr, List<List<Vector2>> fullNodeList, float clampUVYPerc, float uvyShapeRatio, ERSORoadExt soData, bool mirrored, bool shapeDirFlag)
	{
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		List<Vector2> list3 = new List<Vector2>();
		List<Color> list4 = new List<Color>();
		List<Vector3> list5 = new List<Vector3>();
		List<Vector4> list6 = new List<Vector4>();
		List<int> list7 = new List<int>();
		List<Vector3> list8 = new List<Vector3>();
		List<Vector3> list9 = new List<Vector3>();
		List<Vector2> list10 = new List<Vector2>();
		List<Vector2> list11 = new List<Vector2>();
		List<Color> list12 = new List<Color>();
		List<Vector3> list13 = new List<Vector3>();
		List<Vector4> list14 = new List<Vector4>();
		List<int> list15 = new List<int>();
		List<float> list16 = new List<float>();
		List<ZIndexArray> list17 = new List<ZIndexArray>();
		List<Vector3> list18 = new List<Vector3>();
		List<Vector2> list19 = new List<Vector2>();
		List<Vector2> list20 = new List<Vector2>();
		list = mobject.sVecs;
		list2 = mobject.sUv;
		list3 = mobject.sUv2;
		list4 = mobject.sColors;
		list5 = mobject.sNormals;
		list6 = mobject.sTangents;
		list7 = mobject.sTriangles;
		list8 = mobject.sTerrainNormals;
		list9 = mobject.vecs;
		list10 = mobject.uv;
		list11 = mobject.uv2;
		list12 = mobject.colors;
		list13 = mobject.normals;
		list14 = mobject.tangents;
		list15 = mobject.triangles;
		list18.Clear();
		Vector2 item = Vector2.zero;
		Vector2 item2 = Vector2.zero;
		Vector3 v2;
		Vector3 n;
		Vector3 v = (v2 = (n = Vector3.zero));
		if (so.position == 0)
		{
			ODCCQODCOQ(curDist, vecPositions, vecDistances, currentVecArrayInt, ref v, ref v2, doSecond: true, debugFlag);
		}
		else
		{
			v = vecPositions[currentVecArrayInt];
			v2 = vecPositions[currentVecArrayInt + 1];
		}
		if (lastSegment)
		{
			v = vecPositions[vecPositions.Count - 2];
			v2 = vecPositions[vecPositions.Count - 1];
		}
		Vector3 vector;
		Vector3 dir = (vector = v2 - v);
		if (shapeDirFlag)
		{
			vector = vecPositions[currentVecArrayInt + 1] - vecPositions[currentVecArrayInt - 1];
		}
		vector = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
		int num = 0;
		if (so.scaleToRoad)
		{
			if (v == vecPositions[currentVecArrayInt])
			{
				vector = (vecPositionsRight[currentVecArrayInt] - vecPositionsLeft[currentVecArrayInt]).normalized;
			}
			else
			{
				num = 1;
				vector = (vecPositionsRight[currentVecArrayInt + 1] - vecPositionsLeft[currentVecArrayInt + 1]).normalized;
			}
			vector = new Vector3(vector.x, 0f, vector.z).normalized;
			dir = new Vector3(0f - vector.z, 0f, vector.x).normalized;
		}
		debugvecs.Add(vecPositionsRight[currentVecArrayInt]);
		debugvecs.Add(vecPositionsLeft[currentVecArrayInt]);
		if (10AA1.x != 0f)
		{
			v += 10AA1.x * vector;
			v2 += 10AA1.x * vector;
		}
		if (!roadScr.baseScript.isInBuildMode && !roadScr.isSideObject)
		{
			if (!so.scaleToRoad)
			{
				vector = new Vector3(vector.x, 0f, vector.z).normalized;
			}
		}
		else if (roadScr.snapToTerrain)
		{
			roadScr.baseScript.OCDDQOCDCO(ref v);
			v.y += soData.yPosition;
		}
		else if ((roadScr.snapToTerrain || !roadScr.isSideObject) && so.snapToTerrain)
		{
			v.y = (v2.y = ODQDQDQDQO.OOCQOOCOQC(v, roadScr.baseScript) + soData.yPosition);
		}
		if (currentSplineInt >= vecAngles.Count)
		{
			currentSplineInt = vecAngles.Count - 1;
		}
		if (vecPositions.Count <= currentVecArrayInt + 2)
		{
			lastSegment = true;
		}
		bool flag = false;
		if (fullNodeList[0].Count == 0 || mirrored)
		{
			flag = true;
		}
		List<float> list21 = new List<float>();
		list21.Add(0f);
		float num2 = 0f;
		List<Vector2> list22;
		List<float> list23;
		List<float> list24;
		List<Color> list25;
		if (!mirrored)
		{
			list22 = so.nodeList;
			list23 = new List<float>(so.uvs);
			list24 = so.snapWeightList;
			list25 = so.colorList;
		}
		else
		{
			list22 = so.nodeListMirrored;
			list23 = new List<float>(so.uvsMirrored);
			list24 = so.snapWeightListMirrored;
			list25 = so.colorListMirrored;
		}
		if (so.reverseUVs)
		{
			float num3 = 1f;
			float num4 = 0f;
			for (int i = 0; i < list23.Count; i++)
			{
				if (list23[i] < num3)
				{
					num3 = list23[i];
				}
				if (list23[i] > num4)
				{
					num4 = list23[i];
				}
			}
			for (int j = 0; j < list23.Count; j++)
			{
				list23[j] = Mathf.Lerp(num4, num3, (list23[j] - num3) / (num4 - num3));
			}
		}
		int num5 = so.nodeList.Count;
		int num6 = 0;
		for (int k = 0; k < so.nodeList.Count; k++)
		{
			Vector2 vec = (flag ? list22[k] : fullNodeList[k][currentVecArrayInt]);
			Vector3 v3 = v + vector * vec.x;
			v3.y += vec.y;
			if (so.align == 1 || (sidewaysFlag && so.align != 0))
			{
				ODQDQDQDQO.OCCQCDQQOQ(ref v3, ref n, v, dir, vec, roadScr, 6AAAA);
			}
			else if (so.align == 2)
			{
				ODQDQDQDQO.OQODQODDOQ(ref v3, ref n, v, dir, vec, 0f, 6AAAA);
			}
			else if (so.align == 3)
			{
				ODQDQDQDQO.OQODQODDOQ(ref v3, ref n, v, dir, vec, vecAngles[currentSplineInt], 6AAAA);
			}
			else if (6AAAA != Vector3.zero)
			{
				ODQDQDQDQO.OQODQODDOQ(ref v3, ref n, v, dir, vec, 0f, 6AAAA);
			}
			if (list24[k] > 0f)
			{
				Vector3 pos = v3;
				roadScr.baseScript.OCDDQOCDCO(ref pos);
				v3.y = Mathf.Lerp(v3.y, pos.y, list24[k]);
				if ((double)list24[k] > 0.95)
				{
					list8.Add(roadScr.baseScript.OQOODODDQO(pos));
					if (so.hardEdge[k])
					{
						list8.Add(list8[list8.Count - 1]);
					}
				}
				else
				{
					list8.Add(Vector3.zero);
					if (so.hardEdge[k])
					{
						list8.Add(Vector3.zero);
					}
				}
			}
			else
			{
				list8.Add(Vector3.zero);
				if (so.hardEdge[k])
				{
					list8.Add(Vector3.zero);
				}
			}
			list18.Add(v3);
			list4.Add(list25[k]);
			if (so.hardEdge[k])
			{
				list18.Add(v3);
				list4.Add(list25[k]);
				num5++;
				num6++;
			}
			if (k > 0)
			{
				num2 += Vector3.Distance(v3, list18[list18.Count - 2 - num6]);
				list21.Add(num2);
			}
			if (so.clampUVs && !so.terrainUVs)
			{
				item = new Vector2(list23[k], curDist * so.uvy * clampUVYPerc * uvyShapeRatio);
				if (lastSegment && so.clampUVY)
				{
					item.y = Mathf.Ceil(item.y) - (1f - so.clampUVYValue);
				}
			}
			if (so.clampUV4)
			{
				item2 = new Vector2(list23[k], curDist * so.uvy * clampUVYPerc * uvyShapeRatio);
			}
			else
			{
				item2.x = (v3.x - 61AAA.min.x) / 61AAA.size.x;
				item2.y = (v3.z - 61AAA.min.z) / 61AAA.size.z;
			}
			list20.Add(item2);
			if (so.hardEdge[k])
			{
				list20.Add(item2);
			}
			if (so.clampUVs && !so.terrainUVs)
			{
				list19.Add(item);
				if (so.hardEdge[k])
				{
					item.x += so.hardEdgePadding;
					list19.Add(item);
				}
			}
			else if (so.terrainUVs)
			{
				list19.Add(item2);
				if (so.hardEdge[k])
				{
					list19.Add(item2);
				}
			}
		}
		if (!so.clampUVs && !so.terrainUVs)
		{
			float num7 = list21[list21.Count - 1];
			for (int l = 0; l < so.nodeList.Count; l++)
			{
				item = (so.reverseUVs ? new Vector2((num7 - list21[l]) / so.totalDistance, curDist * so.uvy * clampUVYPerc * uvyShapeRatio) : new Vector2(list21[l] / so.totalDistance, curDist * so.uvy * clampUVYPerc * uvyShapeRatio));
				list19.Add(item);
				if (so.hardEdge[l])
				{
					list19.Add(item);
				}
			}
		}
		if (debugFlag)
		{
		}
		int count = list.Count;
		list.AddRange(list18);
		list2.AddRange(list19);
		list3.AddRange(list20);
		int count2 = so.nodeList.Count;
		int num8 = 0;
		if (segmentCount <= 0)
		{
			return;
		}
		for (int m = 0; m < count2 - 1; m++)
		{
			if (so.hardEdge[m])
			{
				num8++;
			}
			list7.Add(count - num5 + m + num8);
			list7.Add(count + m + num8);
			list7.Add(count + m + 1 + num8);
			list7.Add(count - num5 + m + num8);
			list7.Add(count + m + 1 + num8);
			list7.Add(count - num5 + m + 1 + num8);
		}
	}

	public static void ODOODODODO(GameObject parentGo, float curDist, float scaleFactor, SideObject so, List<Vector3> vecPositions, List<Vector3> vecPositionsLeft, List<Vector3> vecPositionsRight, List<Vector3> vecPositionsCenter, List<float> vecAngles, List<float> vecDistances, int currentVecArrayInt, int num, ERModularRoad roadScr, int startConnectionEnd, ERSORoadExt soData, bool mirrored, bool rotateFlag, List<int> sectionIndexes, bool shapeDirFlag, int k)
	{
		float num2 = 1f;
		if (mirrored)
		{
			num2 = -1f;
		}
		int num3 = num;
		GameObject gameObject = null;
		GameObject gameObject2 = null;
		string text = "";
		string text2 = "";
		if (so.objectType == 0)
		{
			if (startConnectionEnd != 2 || so.endObject == null || !so.meshBoundsAlignment)
			{
				gameObject2 = so.sourceObject;
				if (soData.sourceObject != null)
				{
					gameObject2 = soData.sourceObject;
				}
				if (so.childOrder == 0)
				{
					gameObject = UnityEngine.Object.Instantiate(gameObject2);
					text2 = so.sourceObject.name;
				}
				else if (so.childOrder == 1)
				{
					int childCount = gameObject2.transform.childCount;
					if (childCount > 1)
					{
						num--;
						num -= Mathf.RoundToInt(Mathf.Floor(num / childCount) * (float)childCount);
						if (C1AA1)
						{
							num++;
							if (num >= childCount)
							{
								num = 0;
							}
						}
						gameObject = UnityEngine.Object.Instantiate(gameObject2.transform.GetChild(num).gameObject);
						text2 = gameObject2.transform.GetChild(num).gameObject.name;
					}
					else
					{
						gameObject = UnityEngine.Object.Instantiate(gameObject2);
						text2 = gameObject2.name;
					}
				}
				else
				{
					int childCount2 = gameObject2.transform.childCount;
					if (childCount2 > 1)
					{
						int index = Mathf.RoundToInt(UnityEngine.Random.Range(0, childCount2));
						gameObject = UnityEngine.Object.Instantiate(gameObject2.transform.GetChild(index).gameObject);
						text2 = gameObject2.transform.GetChild(index).gameObject.name;
					}
					else
					{
						gameObject = UnityEngine.Object.Instantiate(gameObject2);
						text2 = gameObject2.name;
					}
				}
			}
			else
			{
				gameObject = UnityEngine.Object.Instantiate(so.endObject);
				gameObject2 = so.endObject;
				text2 = so.endObject.name;
			}
		}
		else
		{
			text2 = so.name;
			switch (startConnectionEnd)
			{
			case 0:
				if (so.startObject != null)
				{
					gameObject = (gameObject2 = so.startObject);
					text = " Start Object";
				}
				break;
			case 1:
				if (so.connectionObject != null)
				{
					gameObject = (gameObject2 = so.connectionObject);
					text = " Connection Object";
				}
				break;
			case 2:
				if (so.endObject != null)
				{
					gameObject = (gameObject2 = so.endObject);
					text = " End Object";
				}
				break;
			}
			if (gameObject != null)
			{
				if (so.childOrder == 0)
				{
					gameObject = UnityEngine.Object.Instantiate(gameObject);
				}
				else if (so.childOrder == 1)
				{
					int childCount3 = gameObject.transform.childCount;
					if (childCount3 > 1)
					{
						num--;
						num -= Mathf.RoundToInt(Mathf.Floor(num / childCount3) * (float)childCount3);
						gameObject = UnityEngine.Object.Instantiate(gameObject.transform.GetChild(num).gameObject);
					}
					else
					{
						gameObject = UnityEngine.Object.Instantiate(gameObject);
					}
				}
				else
				{
					int childCount4 = gameObject.transform.childCount;
					gameObject = ((childCount4 <= 1) ? UnityEngine.Object.Instantiate(gameObject) : UnityEngine.Object.Instantiate(gameObject.transform.GetChild(Mathf.RoundToInt(UnityEngine.Random.Range(0, childCount4))).gameObject));
				}
			}
		}
		if (gameObject == null)
		{
			return;
		}
		ERPrefabInstance eRPrefabInstance = gameObject.AddComponent<ERPrefabInstance>();
		eRPrefabInstance.roadScript = roadScr;
		eRPrefabInstance.so = so;
		eRPrefabInstance.prefab = gameObject2;
		eRPrefabInstance.soData = soData;
		if (so.objectType != 0)
		{
			eRPrefabInstance.child = true;
		}
		if (k >= 91AA1 && 81AAA != -1 && sectionIndexes.Count > 71AA1)
		{
			ERSideObjectSection eRSideObjectSection = gameObject.AddComponent<ERSideObjectSection>();
			eRSideObjectSection.road = roadScr;
			eRSideObjectSection.sectionIndex = sectionIndexes[71AA1];
			eRSideObjectSection.mirrored = mirrored;
			eRSideObjectSection.sectionListIndex = 81AAA;
			if ((so.relativeTo == 1 && !mirrored) || (so.relativeTo == 2 && mirrored))
			{
				eRSideObjectSection.leftright = 0;
			}
			else
			{
				eRSideObjectSection.leftright = 1;
			}
			eRSideObjectSection.soId = so.id;
		}
		so.instantiatedObjects.Add(gameObject);
		gameObject.name = text2 + text;
		gameObject.transform.parent = parentGo.transform;
		gameObject.isStatic = so.isStatic;
		gameObject.layer = so.layer;
		Vector3 v2;
		Vector3 v = (v2 = Vector3.zero);
		Vector3 zero = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		Vector3 zero3 = Vector3.zero;
		Vector3 vector;
		if (!so.meshBoundsAlignment)
		{
			ODCCQODCOQ(curDist, vecPositions, vecDistances, currentVecArrayInt, ref v, ref v2, doSecond: true, debugFlag: false);
			zero2 = (zero = (zero3 = (v2 - v).normalized));
			vector = v;
			if (!roadScr.baseScript.isInBuildMode && !roadScr.isSideObject)
			{
				if (so.snapToTerrain)
				{
					v.y = (v2.y = ODQDQDQDQO.OOCQOOCOQC(v, roadScr.baseScript) + soData.yPosition);
				}
			}
			else if ((roadScr.snapToTerrain || !roadScr.isSideObject) && so.snapToTerrain)
			{
				v.y = (v2.y = ODQDQDQDQO.OOCQOOCOQC(v, roadScr.baseScript) + soData.yPosition);
			}
			zero = (vecPositionsRight[currentVecArrayInt] - vecPositionsLeft[currentVecArrayInt]).normalized;
		}
		else
		{
			Bounds bounds = default(Bounds);
			if (ODQDQDQDQO.OQOQCCCODC(gameObject, ref bounds))
			{
				ODCCQODCOQ(curDist, vecPositions, vecDistances, currentVecArrayInt, ref v, ref v2, doSecond: false, debugFlag: false);
				ODCCQODCOQ(curDist + bounds.size.z, vecPositions, vecDistances, currentVecArrayInt, ref v2, ref v2, doSecond: false, debugFlag: false);
				zero2 = (zero = (zero3 = (v2 - v).normalized));
				vector = v;
				if ((roadScr.baseScript.isInBuildMode || roadScr.isSideObject) && (roadScr.snapToTerrain || !roadScr.isSideObject) && roadScr.terrainDeformation && so.snapToTerrain)
				{
					v.y = ODQDQDQDQO.OOCQOOCOQC(v, roadScr.baseScript) + soData.yPosition;
					v2.y = ODQDQDQDQO.OOCQOOCOQC(v, roadScr.baseScript) + soData.yPosition;
				}
				zero = (vecPositionsRight[currentVecArrayInt] - vecPositionsLeft[currentVecArrayInt]).normalized;
			}
			else
			{
				ODCCQODCOQ(curDist, vecPositions, vecDistances, currentVecArrayInt, ref v, ref v2, doSecond: true, debugFlag: false);
				zero2 = (zero = (zero3 = (v2 - v).normalized));
				vector = v;
				if ((roadScr.baseScript.isInBuildMode || roadScr.isSideObject) && (roadScr.snapToTerrain || !roadScr.isSideObject) && roadScr.terrainDeformation && so.snapToTerrain)
				{
					v.y = (v2.y = ODQDQDQDQO.OOCQOOCOQC(v, roadScr.baseScript) + soData.yPosition);
				}
				zero = (vecPositionsRight[currentVecArrayInt] - vecPositionsLeft[currentVecArrayInt]).normalized;
			}
		}
		if (shapeDirFlag)
		{
			zero = vecPositions[currentVecArrayInt + 1] - vecPositions[currentVecArrayInt - 1];
			zero = new Vector3(zero.z, 0f, 0f - zero.x).normalized;
		}
		if (so.objectType != 0)
		{
			if (10AA1.x != 0f)
			{
				if (zero == Vector3.zero)
				{
					zero = new Vector3(zero2.z, 0f, 0f - zero2.x);
				}
				v += 10AA1.x * zero;
				v2 += 10AA1.x * zero;
			}
		}
		else if (soData.randomMinXPosition != 0f || soData.randomMaxXPosition != 0f)
		{
			float num4 = 0f;
			num4 = (mirrored ? Mathf.Lerp(0f - soData.randomMaxXPosition, 0f - soData.randomMinXPosition, UnityEngine.Random.value) : Mathf.Lerp(soData.randomMinXPosition, soData.randomMaxXPosition, UnityEngine.Random.value));
			if (zero == Vector3.zero)
			{
				zero = new Vector3(zero2.z, 0f, 0f - zero2.x);
			}
			v += zero * num4;
			v2 += zero * num4;
		}
		if (so.selectedRotation == 0 && !shapeDirFlag)
		{
			zero = new Vector3(zero3.x, 0f, zero3.z).normalized;
			float num5 = Vector3.Angle(Vector3.forward, zero);
			if (ODQDQDQDQO.OCCQDCCCOD(Vector3.forward, zero, Vector3.up) == -1f)
			{
				num5 = 360f - num5;
			}
			gameObject.transform.eulerAngles = new Vector3(0f, num5 + so.yRotation * num2, 0f);
		}
		else if (so.selectedRotation == 1)
		{
			gameObject.transform.eulerAngles = new Vector3(0f, so.yRotation * num2, 0f);
		}
		else if (so.selectedRotation == 2)
		{
			gameObject.transform.eulerAngles = new Vector3(0f, UnityEngine.Random.value * 360f, 0f);
		}
		else if (shapeDirFlag)
		{
			float num6 = Vector3.Angle(Vector3.forward, zero) - 90f;
			if (ODQDQDQDQO.OCCQDCCCOD(Vector3.forward, zero, Vector3.up) == -1f)
			{
				num6 = 360f - num6;
			}
			gameObject.transform.eulerAngles = new Vector3(0f, num6 + so.yRotation * num2, 0f);
		}
		gameObject.transform.position = v;
		Vector3 adjustedRotation = Vector3.zero;
		if (5AAA1.x != 0f)
		{
			OCQQCOOQDQ(curDist, ref adjustedRotation, ref 6AAAA, á, 4AAAA, á, á, 5AAA1);
		}
		if (31AA1.x != 0f)
		{
			OCCOOCDCQQ(curDist, ref adjustedRotation);
		}
		int num7 = so.align;
		if (so.objectType == 2 && so.connectionObjectRotation == 1)
		{
			num7 = 0;
		}
		if (num7 == 1 || (sidewaysFlag && num7 != 0))
		{
			ODQDQDQDQO.OCCDCDCQQQ(gameObject, v, roadScr, adjustedRotation);
		}
		else
		{
			switch (num7)
			{
			case 2:
				ODQDQDQDQO.OQQOODCODQ(gameObject, v2, vector, zero2, adjustedRotation);
				break;
			case 3:
				if (!roadScr.isSideObject)
				{
					if (currentSplineInt < vecPositionsCenter.Count)
					{
						ODQDQDQDQO.OCOQCDDODO(gameObject, vecPositionsCenter[currentSplineInt], roadScr, adjustedRotation, vecPositionsCenter[currentSplineInt - 1], vecPositionsRight[currentSplineInt]);
					}
					else
					{
						ODQDQDQDQO.OCOQCDDODO(gameObject, vecPositionsCenter[vecPositionsCenter.Count - 1], roadScr, adjustedRotation, vecPositionsCenter[vecPositionsCenter.Count - 1], vecPositionsRight[vecPositionsCenter.Count - 2]);
					}
				}
				else if (currentSplineInt < vecPositionsCenter.Count)
				{
					ODQDQDQDQO.OCOQCDDODO(gameObject, vecPositionsCenter[currentSplineInt], roadScr, new Vector3(0f - vecAngles[currentSplineInt] + adjustedRotation.x, adjustedRotation.y, adjustedRotation.z), vecPositionsCenter[currentSplineInt - 1], vecPositionsRight[currentSplineInt]);
				}
				else
				{
					ODQDQDQDQO.OCOQCDDODO(gameObject, vecPositionsCenter[vecPositionsCenter.Count - 1], roadScr, new Vector3(0f - vecAngles[vecAngles.Count - 1] + adjustedRotation.x, adjustedRotation.y, adjustedRotation.z), vecPositionsCenter[vecPositionsCenter.Count - 1], vecPositionsRight[vecPositionsCenter.Count - 2]);
				}
				break;
			default:
				if (so.meshBoundsAlignment)
				{
					float minY = 20000f;
					float maxY = -20000f;
					ODQDQDQDQO.OCDODCQDDO(roadScr.baseScript, v2, vector, ref minY, ref maxY);
					if (so.alignPoint == 0)
					{
						v.y = minY;
					}
					else if (so.alignPoint == 1)
					{
						v.y = maxY;
					}
					else if (so.alignPoint == 2)
					{
						v.y = (minY + maxY) * 0.5f;
					}
					if (adjustedRotation.x != 0f)
					{
						ODQDQDQDQO.InstantiatedRandomRotation(gameObject, Vector3.zero, roadScr, adjustedRotation);
					}
					v.y += soData.yPosition;
					gameObject.transform.position = v;
				}
				else if (adjustedRotation.x != 0f)
				{
					ODQDQDQDQO.InstantiatedRandomRotation(gameObject, Vector3.zero, roadScr, -adjustedRotation);
				}
				break;
			}
		}
		if (80AAA.x != 0f)
		{
			v = gameObject.transform.position;
			v.y += 80AAA.x;
			gameObject.transform.position = v;
		}
		if (so.minScale != 1f || so.maxScale != 1f)
		{
			float num8 = so.minScale + (so.maxScale - so.minScale) * UnityEngine.Random.value;
			gameObject.transform.localScale = new Vector3(num8, num8, num8);
		}
		if (mirrored)
		{
			if (so.mirrorType == 0)
			{
				if (!rotateFlag)
				{
					gameObject.transform.localScale = new Vector3(0f - gameObject.transform.localScale.x, gameObject.transform.localScale.y, gameObject.transform.localScale.z);
				}
			}
			else
			{
				gameObject.transform.eulerAngles = new Vector3(gameObject.transform.eulerAngles.x, gameObject.transform.eulerAngles.y + 180f, gameObject.transform.eulerAngles.z);
			}
		}
		if (rotateFlag)
		{
			gameObject.transform.eulerAngles = new Vector3(gameObject.transform.eulerAngles.x, gameObject.transform.eulerAngles.y - 90f, gameObject.transform.eulerAngles.z);
		}
		if (B1AAA)
		{
			soData.objects.Add(gameObject);
		}
	}

	public static void ODCCQODCOQ(float tmpDist, List<Vector3> vecPositions, List<float> vecDistances, int currentVecArrayInt, ref Vector3 v, ref Vector3 v1, bool doSecond, bool debugFlag)
	{
		if (currentVecArrayInt == 0)
		{
			currentVecArrayInt = 1;
		}
		if (currentVecArrayInt + 1 >= vecDistances.Count)
		{
			return;
		}
		for (int i = currentVecArrayInt; i < vecDistances.Count; i++)
		{
			if (!(vecDistances[i] > tmpDist))
			{
				continue;
			}
			float num = (tmpDist - vecDistances[i - 1]) / (vecDistances[i] - vecDistances[i - 1]);
			v = Vector3.Lerp(vecPositions[i - 1], vecPositions[i], num);
			if (doSecond)
			{
				if ((double)num < 0.99)
				{
					v1 = Vector3.Lerp(vecPositions[i - 1], vecPositions[i], num + 0.01f);
				}
				else
				{
					v1 = Vector3.Lerp(vecPositions[i], vecPositions[i + 1], 0.01f);
				}
			}
			currentSplineInt = i;
			break;
		}
	}

	public static void GetSplinePositionsMin(float tmpDist, List<Vector3> vecPositions, List<float> vecDistances, int currentVecArrayInt, ref Vector3 v, ref Vector3 v1, bool doSecond, bool debugFlag)
	{
		Vector3 vector = vecPositions[currentVecArrayInt];
		int num = 0;
		bool flag = false;
		if (currentVecArrayInt + 1 < vecDistances.Count)
		{
			for (int num2 = currentVecArrayInt; num2 >= 0; num2--)
			{
				if (vecDistances[num2] <= tmpDist)
				{
					float t = (tmpDist - vecDistances[num2]) / (vecDistances[num2 + 1] - vecDistances[num2]);
					v = (v1 = Vector3.Lerp(vecPositions[num2], vecPositions[num2 + 1], t));
					currentSplineInt = num2;
					flag = true;
					break;
				}
				num++;
			}
		}
		if (!flag)
		{
			Vector3 zero = Vector3.zero;
			if (num > 0 && currentVecArrayInt - num >= 0)
			{
				UnityEngine.Debug.Log(num + " " + currentVecArrayInt + " " + vecPositions.Count);
				zero = (vecPositions[currentVecArrayInt - num] - vector).normalized;
			}
			else
			{
				zero = (vecPositions[currentVecArrayInt] - vecPositions[currentVecArrayInt + 1]).normalized;
			}
			v = (v1 = vector + zero * (vecDistances[currentVecArrayInt] - tmpDist));
		}
	}

	public static void OCQCOOQCDO(float curDist, List<float> vecDistances, ref int currentVecArrayInt)
	{
		if (currentVecArrayInt < vecDistances.Count)
		{
			for (int i = currentVecArrayInt; i < vecDistances.Count; i++)
			{
				if (vecDistances[i] > curDist)
				{
					currentVecArrayInt = i - 1;
					break;
				}
			}
		}
		else
		{
			currentVecArrayInt = vecDistances.Count - 1;
		}
	}

	private static void GetRandomXDistance(float distance, ref Vector3 adjustedRotation, ref Vector3 currentRandomRotation, float randomRotationStart, float randomRotationMiddle, float randomRotationEnd, float randomRotationDistance, Vector3 randomRotation)
	{
		if (distance <= randomRotationMiddle)
		{
			float num = (distance - randomRotationStart) / (randomRotationMiddle - randomRotationStart);
			float num2 = num * randomRotationDistance;
			if ((double)num2 < 0.25)
			{
				num = 0f;
			}
			else if ((double)(randomRotationDistance - num2) < 0.25)
			{
				num = 1f;
			}
			currentRandomRotation.x = Mathf.Lerp(0f, randomRotation.x, Mathf.SmoothStep(0f, 1f, num));
		}
		else
		{
			float num3 = (distance - randomRotationMiddle) / (randomRotationEnd - randomRotationMiddle);
			float num4 = num3 * randomRotationDistance;
			if ((double)num4 < 0.25)
			{
				num3 = 0f;
			}
			else if ((double)(randomRotationDistance - num4) < 0.25)
			{
				num3 = 1f;
			}
			currentRandomRotation.x = Mathf.Lerp(randomRotation.x, 0f, Mathf.SmoothStep(0f, 1f, num3));
		}
		adjustedRotation = currentRandomRotation;
	}

	private static void OCQQCOOQDQ(float distance, ref Vector3 adjustedRotation, ref Vector3 currentRandomRotation, float randomRotationStart, float randomRotationMiddle, float randomRotationEnd, float randomRotationDistance, Vector3 randomRotation)
	{
		if (distance <= randomRotationMiddle)
		{
			float num = (distance - randomRotationStart) / (randomRotationMiddle - randomRotationStart);
			float num2 = num * randomRotationDistance;
			if ((double)num2 < 0.25)
			{
				num = 0f;
			}
			else if ((double)(randomRotationDistance - num2) < 0.25)
			{
				num = 1f;
			}
			currentRandomRotation.x = Mathf.Lerp(0f, randomRotation.x, Mathf.SmoothStep(0f, 1f, num));
		}
		else
		{
			float num3 = (distance - randomRotationMiddle) / (randomRotationEnd - randomRotationMiddle);
			float num4 = num3 * randomRotationDistance;
			if ((double)num4 < 0.25)
			{
				num3 = 0f;
			}
			else if ((double)(randomRotationDistance - num4) < 0.25)
			{
				num3 = 1f;
			}
			currentRandomRotation.x = Mathf.Lerp(randomRotation.x, 0f, Mathf.SmoothStep(0f, 1f, num3));
		}
		adjustedRotation = currentRandomRotation;
	}

	private static void OCCOOCDCQQ(float distance, ref Vector3 adjustedRotation)
	{
		if (distance <= 21AAA)
		{
			float num = (distance - 01AAA) / (21AAA - 01AAA);
			float num2 = num * C0AA1;
			if ((double)num2 < 0.25)
			{
				num = 0f;
			}
			else if ((double)(C0AA1 - num2) < 0.25)
			{
				num = 1f;
			}
			41AAA.x = Mathf.Lerp(0f, 31AA1.x, Mathf.SmoothStep(0f, 1f, num));
			if (adjustedRotation == Vector3.zero)
			{
				adjustedRotation = 41AAA;
			}
			else
			{
				adjustedRotation = Vector3.Lerp(adjustedRotation, 41AAA, num);
			}
		}
		else
		{
			float num3 = (distance - 21AAA) / (11AA1 - 21AAA);
			float num4 = num3 * C0AA1;
			if ((double)num4 < 0.25)
			{
				num3 = 0f;
			}
			else if ((double)(C0AA1 - num4) < 0.25)
			{
				num3 = 1f;
			}
			41AAA.x = Mathf.Lerp(31AA1.x, 0f, Mathf.SmoothStep(0f, 1f, num3));
			if (adjustedRotation == Vector3.zero)
			{
				adjustedRotation = 41AAA;
			}
			else
			{
				adjustedRotation = Vector3.Lerp(41AAA, adjustedRotation, num3);
			}
		}
	}

	public static Terrain OQQOOCQQCD(Vector3 pos)
	{
		Terrain[] array = UnityEngine.Object.FindObjectsOfType(typeof(Terrain)) as Terrain[];
		Terrain[] array2 = array;
		foreach (Terrain terrain in array2)
		{
			if (terrain != null && pos.x > terrain.transform.position.x && pos.x < terrain.transform.position.x + terrain.terrainData.size.x && pos.z > terrain.transform.position.z && pos.z < terrain.transform.position.z + terrain.terrainData.size.z)
			{
				return terrain;
			}
		}
		if (array.Length == 0)
		{
			return null;
		}
		return array[0];
	}
}
public struct ERCPUpdate
{
	public ERModularRoad road;

	public ERCrossingPrefabs prefab;

	public int startEnd;

	public int connection;

	public Vector3 cp;

	public ERCPUpdate(ERModularRoad v_road, ERCrossingPrefabs v_prefab, int v_startEnd, int v_connection, Vector3 v_cp)
	{
		road = v_road;
		prefab = v_prefab;
		startEnd = v_startEnd;
		connection = v_connection;
		cp = v_cp;
	}
}
public struct CRedge
{
	public int v1;

	public int v2;

	public int count;

	public CRedge(int v_1, int v_2)
	{
		v1 = v_1;
		v2 = v_2;
		count = 1;
	}
}
[Serializable]
public struct ERTerrainChange
{
	public int index;

	public int value;

	public ERTerrainChange(int v_index, int v_value)
	{
		index = v_index;
		value = v_value;
	}
}
[Serializable]
public class SelectedObject : ScriptableObject
{
	public ERModularRoad roadScr;

	public ERCrossingPrefabs prefabScr;

	public List<int> markers;

	public int startEnd;

	public ERCrossingPrefabs prefab;

	public void Init(ERModularRoad rScr, ERCrossingPrefabs pScr, int marker)
	{
		if (rScr != null)
		{
			roadScr = rScr;
			markers = new List<int>();
			markers.Add(marker);
			prefabScr = pScr;
		}
		else
		{
			prefabScr = pScr;
			roadScr = rScr;
			markers = null;
		}
		startEnd = 0;
	}

	public static SelectedObject CreateInstance(ERModularRoad rScr, ERCrossingPrefabs pScr, int marker)
	{
		SelectedObject selectedObject = ScriptableObject.CreateInstance<SelectedObject>();
		selectedObject.Init(rScr, pScr, marker);
		return selectedObject;
	}
}
[Serializable]
public class ERSOMarker
{
	public SideObject sideObject;

	public double id;

	public bool active;

	public float startOffset = 0f;

	public float endOffset = 0f;

	public bool splineActive;

	public float sidewaysDistance;

	public Vector3 startOffsetV3 = Vector3.zero;

	public Vector3 endOffsetV3 = Vector3.zero;

	public Vector3 startOffsetDir = Vector3.zero;

	public Vector3 endOffsetDir = Vector3.zero;

	public Vector3 startOffsetV3nb = Vector3.zero;

	public Vector3 endOffsetV3nb = Vector3.zero;

	public int curStartInt = -1;

	public int curEndInt = -1;

	public bool startOffsetActive = false;

	public bool endOffsetActive = false;

	public List<Vector2> nodeList = new List<Vector2>();

	public List<Vector3> nodeShapeVecsGlobal = new List<Vector3>();

	public Vector3 rotation = Vector3.zero;

	public float rotationAngle = 0f;

	public float rotationDistance = 0f;

	public float rotationCenter = 0f;

	public ERSOMarker(SideObject so, bool flag)
	{
		sideObject = so;
		id = so.id;
		if (!flag)
		{
			active = false;
		}
		else
		{
			active = so.markerActive;
		}
		splineActive = true;
		sidewaysDistance = so.splinePosition;
		nodeList = new List<Vector2>(so.nodeList);
	}

	public void OODOOOQQCO(ERSOMarkerExt source)
	{
		active = source.active;
		startOffset = source.startOffset;
		endOffset = source.endOffset;
		splineActive = source.splineActive;
		sidewaysDistance = source.sidewaysDistance;
	}
}
[Serializable]
public class ERSOMarkerExt : ScriptableObject
{
	public SideObject sideObject;

	public double id;

	public bool active;

	public float startOffset = 0f;

	public float endOffset = 0f;

	public bool splineActive;

	public float sidewaysDistance;

	public float xPosition;

	public Vector3 startOffsetV3 = Vector3.zero;

	public Vector3 endOffsetV3 = Vector3.zero;

	public Vector3 startOffsetDir = Vector3.zero;

	public Vector3 endOffsetDir = Vector3.zero;

	public Vector3 startOffsetV3nb = Vector3.zero;

	public Vector3 endOffsetV3nb = Vector3.zero;

	public int curStartInt = -1;

	public int curEndInt = -1;

	public bool startOffsetActive = false;

	public bool endOffsetActive = false;

	public List<Vector2> nodeList = new List<Vector2>();

	public List<Vector3> nodeShapeVecsGlobal = new List<Vector3>();

	public int shapeTransitionType = 0;

	public Vector3 rotation = Vector3.zero;

	public float rotationAngle = 0f;

	public float rotationDistance = 0f;

	public float rotationCenter = 0f;

	public ERRoadSide side;

	public ERSOMarkerExt otherSide;

	public void Init(SideObject so, bool flag)
	{
		sideObject = so;
		id = so.id;
		if (!flag)
		{
			active = false;
		}
		else
		{
			active = so.markerActive;
		}
		splineActive = true;
		xPosition = so.xPosition;
		sidewaysDistance = so.splinePosition;
		startOffset = so.defaultStartOffset;
		endOffset = so.defaultEndOffset;
		nodeList = new List<Vector2>(so.nodeList);
	}

	public void OODOOOQQCO(ERSOMarkerExt source)
	{
		active = source.active;
		xPosition = source.xPosition;
		startOffset = source.startOffset;
		endOffset = source.endOffset;
		splineActive = source.splineActive;
		sidewaysDistance = source.sidewaysDistance;
		if (source.otherSide != null)
		{
			if (otherSide == null)
			{
				otherSide = CreateInstance(source.otherSide.sideObject, flag: true);
			}
			otherSide.active = source.otherSide.active;
			otherSide.xPosition = source.otherSide.xPosition;
			otherSide.startOffset = source.otherSide.startOffset;
			endOffset = source.otherSide.endOffset;
			otherSide.splineActive = source.otherSide.splineActive;
			otherSide.sidewaysDistance = source.otherSide.sidewaysDistance;
		}
	}

	public void Copy(ERSOMarkerExt source)
	{
		xPosition = source.xPosition;
		startOffset = source.startOffset;
		endOffset = source.endOffset;
	}

	public static ERSOMarkerExt CreateInstance(SideObject so, bool flag)
	{
		ERSOMarkerExt eRSOMarkerExt = ScriptableObject.CreateInstance<ERSOMarkerExt>();
		eRSOMarkerExt.Init(so, flag);
		return eRSOMarkerExt;
	}

	public void ODCOCDOOCQ(SideObject so)
	{
		sideObject = so;
		startOffset = so.startOffset;
		endOffset = so.endOffset;
	}
}
public struct CombineClass
{
	public Material m;

	public List<ERMeshCombineUtility.MeshInstance> objects;
}
public class ERMeshCombineUtility
{
	public struct MeshInstance
	{
		public Mesh mesh;

		public int subMeshIndex;

		public Matrix4x4 transform;

		public int vertexCount;

		public bool flipTriangles;
	}

	public static Mesh Combine(Transform container, MeshInstance[] combines, bool generateStrips)
	{
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		for (int i = 0; i < combines.Length; i++)
		{
			MeshInstance meshInstance = combines[i];
			if (!meshInstance.mesh)
			{
				continue;
			}
			num += meshInstance.mesh.vertexCount;
			if (!generateStrips)
			{
				continue;
			}
			int num4 = meshInstance.mesh.GetTriangles(meshInstance.subMeshIndex).Length;
			if (num4 != 0)
			{
				if (num3 != 0)
				{
					num3 = (((num3 & 1) != 1) ? (num3 + 2) : (num3 + 3));
				}
				num3 += num4;
			}
			else
			{
				generateStrips = false;
			}
		}
		if (!generateStrips)
		{
			for (int j = 0; j < combines.Length; j++)
			{
				MeshInstance meshInstance2 = combines[j];
				if ((bool)meshInstance2.mesh && meshInstance2.mesh.GetTopology(meshInstance2.subMeshIndex) == MeshTopology.Triangles)
				{
					num2 += meshInstance2.mesh.GetTriangles(meshInstance2.subMeshIndex).Length;
				}
			}
		}
		Vector3[] array = new Vector3[num];
		Vector3[] array2 = new Vector3[num];
		Vector4[] array3 = new Vector4[num];
		Vector2[] array4 = new Vector2[num];
		Vector2[] array5 = new Vector2[num];
		int[] array6 = new int[num2];
		int[] array7 = new int[num3];
		int offset = 0;
		for (int k = 0; k < combines.Length; k++)
		{
			MeshInstance meshInstance3 = combines[k];
			if ((bool)meshInstance3.mesh)
			{
				Copy(meshInstance3.mesh.vertexCount, meshInstance3.mesh.vertices, array, ref offset, meshInstance3.transform);
			}
		}
		offset = 0;
		for (int l = 0; l < combines.Length; l++)
		{
			MeshInstance meshInstance4 = combines[l];
			if ((bool)meshInstance4.mesh)
			{
				Matrix4x4 transform = meshInstance4.transform;
				transform = transform.inverse.transpose;
				CopyNormal(meshInstance4.mesh.vertexCount, meshInstance4.mesh.normals, array2, ref offset, transform);
			}
		}
		offset = 0;
		for (int m = 0; m < combines.Length; m++)
		{
			MeshInstance meshInstance5 = combines[m];
			if ((bool)meshInstance5.mesh)
			{
				Matrix4x4 transform2 = meshInstance5.transform;
				transform2 = transform2.inverse.transpose;
				CopyTangents(meshInstance5.mesh.vertexCount, meshInstance5.mesh.tangents, array3, ref offset, transform2);
			}
		}
		offset = 0;
		for (int n = 0; n < combines.Length; n++)
		{
			MeshInstance meshInstance6 = combines[n];
			if ((bool)meshInstance6.mesh)
			{
				Copy(meshInstance6.mesh.vertexCount, meshInstance6.mesh.uv, array4, ref offset);
			}
		}
		offset = 0;
		for (int num5 = 0; num5 < combines.Length; num5++)
		{
			MeshInstance meshInstance7 = combines[num5];
			if ((bool)meshInstance7.mesh)
			{
				Copy(meshInstance7.mesh.vertexCount, meshInstance7.mesh.uv2, array5, ref offset);
			}
		}
		int num6 = 0;
		int num7 = 0;
		int num8 = 0;
		for (int num9 = 0; num9 < combines.Length; num9++)
		{
			MeshInstance meshInstance8 = combines[num9];
			if (!meshInstance8.mesh)
			{
				continue;
			}
			if (generateStrips)
			{
				int[] triangles = meshInstance8.mesh.GetTriangles(meshInstance8.subMeshIndex);
				if (num7 != 0)
				{
					if ((num7 & 1) == 1)
					{
						array7[num7] = array7[num7 - 1];
						array7[num7 + 1] = triangles[0] + num8;
						array7[num7 + 2] = triangles[0] + num8;
						num7 += 3;
					}
					else
					{
						array7[num7] = array7[num7 - 1];
						array7[num7 + 1] = triangles[0] + num8;
						num7 += 2;
					}
				}
				for (int num10 = 0; num10 < triangles.Length; num10++)
				{
					array7[num10 + num7] = triangles[num10] + num8;
				}
				num7 += triangles.Length;
			}
			else if (meshInstance8.mesh.GetTopology(meshInstance8.subMeshIndex) == MeshTopology.Triangles)
			{
				int[] triangles2 = meshInstance8.mesh.GetTriangles(meshInstance8.subMeshIndex);
				if (!meshInstance8.flipTriangles)
				{
					for (int num11 = 0; num11 < triangles2.Length; num11++)
					{
						array6[num11 + num6] = triangles2[num11] + num8;
					}
				}
				else
				{
					int num12 = 0;
					for (int num13 = 0; num13 < triangles2.Length; num13 += 3)
					{
						array6[num13 + num6] = triangles2[num13] + num8;
						num12 = triangles2[num13 + 1] + num8;
						array6[num13 + num6 + 1] = triangles2[num13 + 2] + num8;
						array6[num13 + num6 + 2] = num12;
					}
				}
				num6 += triangles2.Length;
			}
			num8 += meshInstance8.mesh.vertexCount;
		}
		Mesh mesh = new Mesh();
		if (array.Length >= 65000)
		{
			if (container != null && container.parent != null && container.parent.parent != null)
			{
				UnityEngine.Debug.Log("EasyRoads3D: " + container.parent.name + " (" + container.parent.parent.name + ") too many vertices, Unity does not allow more then 65000 vertices for a mesh, mesh combine aborted.");
			}
			return mesh;
		}
		mesh.name = "Combined Mesh";
		mesh.vertices = array;
		mesh.normals = array2;
		mesh.tangents = array3;
		mesh.uv = array4;
		mesh.uv2 = array5;
		if (generateStrips)
		{
			mesh.SetTriangles(array7, 0);
		}
		else
		{
			mesh.triangles = array6;
		}
		return mesh;
	}

	private static void Copy(int vertexcount, Vector3[] src, Vector3[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = transform.MultiplyPoint(src[i]);
		}
		offset += vertexcount;
	}

	private static void CopyNormal(int vertexcount, Vector3[] src, Vector3[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = transform.MultiplyVector(src[i]).normalized;
		}
		offset += vertexcount;
	}

	private static void Copy(int vertexcount, Vector2[] src, Vector2[] dst, ref int offset)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = src[i];
		}
		offset += vertexcount;
	}

	private static void CopyTangents(int vertexcount, Vector4[] src, Vector4[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			Vector4 vector = src[i];
			Vector3 vector2 = new Vector3(vector.x, vector.y, vector.z);
			vector2 = transform.MultiplyVector(vector2);
			dst[i + offset] = new Vector4(vector2.x, vector2.y, vector2.z, vector.w);
		}
		offset += vertexcount;
	}

	public static void CombineMesh(GameObject go, Mesh mesh, Transform container, bool isSideObject)
	{
		Transform transform = go.transform;
		bool generateStrips = false;
		UnityEngine.Component[] componentsInChildren = transform.GetComponentsInChildren(typeof(MeshFilter));
		Matrix4x4 worldToLocalMatrix = transform.transform.worldToLocalMatrix;
		List<CombineClass> list = new List<CombineClass>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			MeshFilter meshFilter = (MeshFilter)componentsInChildren[i];
			Renderer component = componentsInChildren[i].GetComponent<Renderer>();
			MeshInstance item = new MeshInstance
			{
				mesh = meshFilter.sharedMesh
			};
			if (meshFilter.transform.localScale.x == -1f || (meshFilter.transform.parent != null && meshFilter.transform.parent.localScale.x == -1f))
			{
				item.flipTriangles = true;
			}
			else
			{
				item.flipTriangles = false;
			}
			if (!(component != null) || !component.enabled || !(item.mesh != null))
			{
				continue;
			}
			item.transform = worldToLocalMatrix * meshFilter.transform.localToWorldMatrix;
			Material[] sharedMaterials = component.sharedMaterials;
			for (int j = 0; j < sharedMaterials.Length; j++)
			{
				item.subMeshIndex = Math.Min(j, item.mesh.subMeshCount - 1);
				List<MeshInstance> combinedInstances = GetCombinedInstances(list, sharedMaterials[j]);
				if (combinedInstances != null)
				{
					combinedInstances.Add(item);
					continue;
				}
				combinedInstances = new List<MeshInstance>();
				combinedInstances.Add(item);
				list.Add(new CombineClass
				{
					m = sharedMaterials[j],
					objects = combinedInstances
				});
			}
			component.enabled = false;
		}
		int num = 0;
		foreach (CombineClass item2 in list)
		{
			MeshInstance[] array = item2.objects.ToArray();
			bool flag = false;
			for (int k = 0; k < array.Length; k++)
			{
				if (mesh == array[k].mesh)
				{
					flag = true;
					break;
				}
			}
			if (list.Count == 1 || flag)
			{
				if (transform.GetComponent(typeof(MeshFilter)) == null)
				{
					transform.gameObject.AddComponent(typeof(MeshFilter));
				}
				if (!transform.GetComponent<MeshRenderer>())
				{
					transform.gameObject.AddComponent<MeshRenderer>();
				}
				MeshFilter meshFilter2 = (MeshFilter)transform.GetComponent(typeof(MeshFilter));
				meshFilter2.mesh = Combine(container, array, generateStrips);
				transform.GetComponent<MeshRenderer>().material = item2.m;
				transform.GetComponent<MeshRenderer>().enabled = true;
				continue;
			}
			num++;
			string text = "";
			text = ((list.Count <= 2) ? "Instantiated Objects" : ("Instantiated Objects " + num));
			go = new GameObject(text);
			go.transform.parent = transform.transform;
			go.AddComponent(typeof(MeshFilter));
			go.AddComponent<MeshRenderer>();
			go.transform.localScale = Vector3.one;
			go.transform.localRotation = Quaternion.identity;
			go.transform.localPosition = Vector3.zero;
			go.GetComponent<MeshRenderer>().material = item2.m;
			MeshFilter meshFilter3 = (MeshFilter)go.GetComponent(typeof(MeshFilter));
			meshFilter3.mesh = Combine(container, array, generateStrips);
			if ((bool)go.GetComponent<MeshRenderer>().sharedMaterial)
			{
				go.name = go.GetComponent<MeshRenderer>().sharedMaterial.name;
			}
		}
	}

	public static List<MeshInstance> GetCombinedInstances(List<CombineClass> mToMesh, Material m)
	{
		foreach (CombineClass item in mToMesh)
		{
			if (item.m == m)
			{
				return item.objects;
			}
		}
		return null;
	}
}
[Serializable]
public class SideObjectParams
{
	public bool[] soActive;

	public float[] soDistanceSideWays;

	public bool[] soSplineActive;
}
[Serializable]
public class ZIndexArray
{
	public List<int> index = new List<int>();
}
[Serializable]
public class ERLaneConnector
{
	public Vector3 connectorStart;

	public Vector3 connectorEnd;

	public Vector3 connectorStartLocal;

	public Vector3 connectorEndLocal;

	public Vector3[] points;

	public int startLaneIndex = 0;

	public int endLaneIndex = 0;

	public int endConnectionIndex;

	public ERLane laneType;

	public ERDirectionType laneDirection;

	public float startOffset = 0f;

	public float endOffset = 0f;

	public float strength = 1.5f;

	public bool mainConnection = false;

	public bool stop = false;

	public float speedLimit = 0f;

	public float minSpeed = 0f;

	public float maxSpeed = 0f;

	public static ERLaneConnector CreateInstance()
	{
		return new ERLaneConnector();
	}

	public static List<ERLaneConnector> GetLaneConnectors(ERLaneData laneData, int index)
	{
		List<ERLaneConnector> list = new List<ERLaneConnector>();
		for (int i = 0; i < laneData.connectors.Count; i++)
		{
			if (laneData.connectors[i].startLaneIndex == index)
			{
				list.Add(laneData.connectors[i]);
			}
		}
		return list;
	}
}
[Serializable]
public enum ERLaneDirection
{
	Left,
	Right
}
public enum ERDirectionType
{
	Straight,
	Left,
	Right
}
[Serializable]
public struct ERChildsSO
{
	public double id;

	public float startOffset;

	public float endOffset;

	public float xOffset;

	public float yOffset;

	public ERChildsSO(int _id)
	{
		id = _id;
		startOffset = 0f;
		endOffset = 0f;
		xOffset = 0f;
		yOffset = 0f;
	}
}
[Serializable]
public class ERMesh
{
	public List<int> vecsInt = new List<int>();

	public List<Vector3> vecs = new List<Vector3>();

	public List<Vector2> uv = new List<Vector2>();

	public List<Vector2> uv2 = new List<Vector2>();

	public List<Color> colors = new List<Color>();

	public List<Vector3> normals = new List<Vector3>();

	public List<Vector4> tangents = new List<Vector4>();

	public List<int> triangles = new List<int>();

	public List<int> triangles2 = new List<int>();

	public List<int> startVecsInt = new List<int>();

	public List<Vector3> startVecs = new List<Vector3>();

	public List<Vector2> startUv = new List<Vector2>();

	public List<Vector2> startUv2 = new List<Vector2>();

	public List<Color> startColors = new List<Color>();

	public List<Vector3> startNormals = new List<Vector3>();

	public List<Vector4> startTangents = new List<Vector4>();

	public List<int> startTriangles = new List<int>();

	public List<int> startTriangles2 = new List<int>();

	public List<int> endVecsInt = new List<int>();

	public List<Vector3> endVecs = new List<Vector3>();

	public List<Vector2> endUv = new List<Vector2>();

	public List<Vector2> endUv2 = new List<Vector2>();

	public List<Color> endColors = new List<Color>();

	public List<Vector3> endNormals = new List<Vector3>();

	public List<Vector4> endTangents = new List<Vector4>();

	public List<int> endTriangles = new List<int>();

	public List<int> endTriangles2 = new List<int>();

	public List<int> suVecsInt = new List<int>();

	public List<Vector3> suVecs = new List<Vector3>();

	public List<Vector2> suUv = new List<Vector2>();

	public List<Vector2> suUv2 = new List<Vector2>();

	public List<Color> suColors = new List<Color>();

	public List<Vector3> suNormals = new List<Vector3>();

	public List<Vector4> suTangents = new List<Vector4>();

	public List<int> suTriangles = new List<int>();

	public List<int> suTriangles2 = new List<int>();

	public List<int> sdVecsInt = new List<int>();

	public List<Vector3> sdVecs = new List<Vector3>();

	public List<Vector2> sdUv = new List<Vector2>();

	public List<Vector2> sdUv2 = new List<Vector2>();

	public List<Color> sdColors = new List<Color>();

	public List<Vector3> sdNormals = new List<Vector3>();

	public List<Vector4> sdTangents = new List<Vector4>();

	public List<int> sdTriangles = new List<int>();

	public List<int> sdTriangles2 = new List<int>();

	public List<Material> materials = new List<Material>();

	public List<Vector3> sVecs = new List<Vector3>();

	public List<Vector2> sUv = new List<Vector2>();

	public List<Vector2> sUv2 = new List<Vector2>();

	public List<Color> sColors = new List<Color>();

	public List<Vector3> sNormals = new List<Vector3>();

	public List<Vector4> sTangents = new List<Vector4>();

	public List<int> sTriangles = new List<int>();

	public List<Vector3> sTerrainNormals = new List<Vector3>();

	public List<List<Vector3>> sVecsGroups = new List<List<Vector3>>();

	public List<List<Vector2>> sUvGroups = new List<List<Vector2>>();

	public List<List<Vector2>> sUv2Groups = new List<List<Vector2>>();

	public List<List<Color>> sColorsGroups = new List<List<Color>>();

	public List<List<Vector3>> sNormalsGroups = new List<List<Vector3>>();

	public List<List<Vector4>> sTangentsGroups = new List<List<Vector4>>();

	public List<List<int>> sTrianglesGroups = new List<List<int>>();

	public List<List<Vector3>> sTerrainNormalsGroups = new List<List<Vector3>>();

	public List<Vector3> sStartVecs = new List<Vector3>();

	public List<Vector2> sStartUv = new List<Vector2>();

	public List<Vector2> sStartUv2 = new List<Vector2>();

	public List<Color> sStartColors = new List<Color>();

	public List<Vector3> sStartNormals = new List<Vector3>();

	public List<Vector4> sStartTangents = new List<Vector4>();

	public List<int> sStartTriangles = new List<int>();

	public List<Vector3> sEndVecs = new List<Vector3>();

	public List<Vector2> sEndUv = new List<Vector2>();

	public List<Vector2> sEndUv2 = new List<Vector2>();

	public List<Color> sEndColors = new List<Color>();

	public List<Vector3> sEndNormals = new List<Vector3>();

	public List<Vector4> sEndTangents = new List<Vector4>();

	public List<int> sEndTriangles = new List<int>();

	public List<Vector3> sSuVecs = new List<Vector3>();

	public List<Vector2> sSuUv = new List<Vector2>();

	public List<Vector2> sSuUv2 = new List<Vector2>();

	public List<Color> sSuColors = new List<Color>();

	public List<Vector3> sSuNormals = new List<Vector3>();

	public List<Vector4> sSuTangents = new List<Vector4>();

	public List<int> sSuTriangles = new List<int>();

	public List<Vector3> sSdVecs = new List<Vector3>();

	public List<Vector2> sSdUv = new List<Vector2>();

	public List<Vector2> sSdUv2 = new List<Vector2>();

	public List<Color> sSdColors = new List<Color>();

	public List<Vector3> sSdNormals = new List<Vector3>();

	public List<Vector4> sSdTangents = new List<Vector4>();

	public List<int> sSdTriangles = new List<int>();

	public int startEndVecCount = 0;

	public int middleStartVecCount = 0;

	public int middleEndVecCount = 0;

	public int endStartVecCount = 0;

	public List<Vector3> middleEndVecs = new List<Vector3>();

	public List<int> startEndInts = new List<int>();

	public List<int> middleStartInts = new List<int>();

	public List<int> middleEndInts = new List<int>();

	public List<int> middleStartStartInts = new List<int>();

	public List<int> middleEndEndInts = new List<int>();

	public List<int> endStartInts = new List<int>();

	public List<int> startEndIntsNC = new List<int>();

	public List<int> middleStartStartIntsNC = new List<int>();

	public List<int> middleStartIntsNC = new List<int>();

	public List<int> middleEndIntsNC = new List<int>();

	public List<int> middleEndEndIntsNC = new List<int>();

	public List<int> endStartIntsNC = new List<int>();

	public int OQOQODDQCCInt = 0;

	public int ODQCDQCCODInt = 0;

	public int middleLeftInt = 0;

	public int middleRightInt = 0;

	public int endLeftInt = 0;

	public int endRightInt = 0;

	public List<int> normalArray1 = new List<int>();

	public List<int> normalArray2 = new List<int>();

	public List<List<int>> normalArray1Group = new List<List<int>>();

	public List<List<int>> normalArray2Group = new List<List<int>>();

	public int vecCount = 0;

	public List<float> zValues = new List<float>();

	public List<ZIndexArray> zValueVecIndexes = new List<ZIndexArray>();

	public List<float> zValuesStart = new List<float>();

	public List<ZIndexArray> zValueVecIndexesStart = new List<ZIndexArray>();

	public List<float> zValuesEnd = new List<float>();

	public List<ZIndexArray> zValueVecIndexesEnd = new List<ZIndexArray>();

	public List<float> zValuesStepUp = new List<float>();

	public List<ZIndexArray> zValueVecIndexesStepUp = new List<ZIndexArray>();

	public List<float> zValuesStepDown = new List<float>();

	public List<ZIndexArray> zValueVecIndexesStepDown = new List<ZIndexArray>();

	public float minZ = 10000f;

	public float minMiddleZ = 10000f;

	public float maxZ = -10000f;

	public float maxMiddleZ = -10000f;

	public float totalZDistance = -10000f;

	public float offset1 = 0.01f;

	public float offset2 = 0.001f;

	public List<int> vertexBatches = new List<int>();

	public List<int> triangleBatches = new List<int>();

	public int lodIndex = 0;

	public bool castShadows = true;

	public string name = "";

	public bool terrainMesh = false;

	public void OCQQQCQQDD()
	{
		startTriangles2 = new List<int>(startTriangles);
		int num = 0;
		for (int i = 0; i < startTriangles2.Count; i += 3)
		{
			num = startTriangles2[i + 1];
			startTriangles2[i + 1] = startTriangles2[i + 2];
			startTriangles2[i + 2] = num;
		}
		endTriangles2 = new List<int>(endTriangles);
		for (int j = 0; j < endTriangles2.Count; j += 3)
		{
			num = endTriangles2[j + 1];
			endTriangles2[j + 1] = endTriangles2[j + 2];
			endTriangles2[j + 2] = num;
		}
		triangles2 = new List<int>(triangles);
		for (int k = 0; k < triangles2.Count; k += 3)
		{
			num = triangles2[k + 1];
			triangles2[k + 1] = triangles2[k + 2];
			triangles2[k + 2] = num;
		}
		suTriangles2 = new List<int>(suTriangles);
		for (int l = 0; l < suTriangles2.Count; l += 3)
		{
			num = suTriangles2[l + 1];
			suTriangles2[l + 1] = suTriangles2[l + 2];
			suTriangles2[l + 2] = num;
		}
		sdTriangles2 = new List<int>(sdTriangles);
		for (int m = 0; m < sdTriangles2.Count; m += 3)
		{
			num = sdTriangles2[m + 1];
			sdTriangles2[m + 1] = sdTriangles2[m + 2];
			sdTriangles2[m + 2] = num;
		}
	}

	public ERMesh(GameObject m_go, SideObject soScript, float minZ, Transform sourceTransform, Vector3 scale, Mesh m, Material mat, float startMin = 0f, bool rotate180 = false)
	{
		if (m_go == null)
		{
			if (soScript.material != null)
			{
				materials.Add(soScript.material);
			}
			return;
		}
		totalZDistance = soScript.totalZDistance;
		float startOffset = soScript.startOffset;
		float num = soScript.endOffset;
		float num2 = totalZDistance - num;
		startOffset += 0.0001f;
		num2 -= 0.0001f;
		if (!soScript.includeStartSegment)
		{
			startOffset = 0f;
		}
		if (!soScript.includeEndSegment)
		{
			num = 0f;
		}
		soScript.lodLevels = 0;
		sVecs.Clear();
		sUv.Clear();
		sUv2.Clear();
		sColors.Clear();
		sNormals.Clear();
		sTangents.Clear();
		sTriangles.Clear();
		sStartVecs.Clear();
		sStartUv.Clear();
		sStartUv2.Clear();
		sStartColors.Clear();
		sStartNormals.Clear();
		sStartTangents.Clear();
		sStartTriangles.Clear();
		sEndVecs.Clear();
		sEndUv.Clear();
		sEndUv2.Clear();
		sEndColors.Clear();
		sEndNormals.Clear();
		sEndTangents.Clear();
		sEndTriangles.Clear();
		sSuVecs.Clear();
		sSuUv.Clear();
		sSuUv2.Clear();
		sSuColors.Clear();
		sSuNormals.Clear();
		sSuTangents.Clear();
		sSuTriangles.Clear();
		sSdVecs.Clear();
		sSdUv.Clear();
		sSdUv2.Clear();
		sSdColors.Clear();
		sSdNormals.Clear();
		sSdTangents.Clear();
		sSdTriangles.Clear();
		if (m.uv.Length == 0)
		{
			m.uv = new Vector2[m.vertices.Length];
			UnityEngine.Debug.Log("EasyRoads3Dv3 warning: Mesh " + m_go.name + " does not have uv data assigned");
		}
		if (m.tangents.Length == 0)
		{
			ODCCODOCQQ.OCDCQCOQQO(m);
		}
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < m.vertices.Length; i++)
		{
			Vector3 item = m_go.transform.TransformPoint(m.vertices[i]);
			item.z -= minZ;
			if (soScript.flipMesh)
			{
				item.x *= -1f;
			}
			list.Add(item);
		}
		List<Vector3> list2 = new List<Vector3>();
		for (int j = 0; j < m.normals.Length; j++)
		{
			Vector3 item2 = m_go.transform.TransformPoint(m.normals[j]);
			if (soScript.flipMesh)
			{
				item2.x *= -1f;
			}
			list2.Add(item2);
		}
		List<CRedge> vecsInts = new List<CRedge>();
		List<CRedge> vecsInts2 = new List<CRedge>();
		List<CRedge> vecsInts3 = new List<CRedge>();
		List<CRedge> vecsInts4 = new List<CRedge>();
		float num3 = 1000f;
		float num4 = -1000f;
		float num5 = 1000f;
		float num6 = -1000f;
		float num7 = 1000f;
		float num8 = -1000f;
		if (startOffset == 0f && num == 0f)
		{
			GetMiddleSementInfo(list, ref num5, ref num6, ref middleStartInts, ref middleEndInts);
			int tri = 0;
			int tri2 = 0;
			int tri3 = 0;
			Color white = Color.white;
			Vector2 zero = Vector2.zero;
			for (int k = 0; k < m.triangles.Length; k += 3)
			{
				try
				{
					OCDQOQOCCD(m.triangles[k], list[m.triangles[k]], ref vecsInt, ref vecs, ref uv, ref uv2, ref normals, ref colors, ref tangents, m.uv[m.triangles[k]], zero, list2[m.triangles[k]], white, m.tangents[m.triangles[k]], ref tri);
				}
				catch
				{
				}
				if (Mathf.Abs(list[m.triangles[k]].z - startOffset) < offset2 && (list[m.triangles[k + 1]].z > startOffset || list[m.triangles[k + 2]].z > startOffset))
				{
					ODDDDDQDOQ(tri, ref middleStartInts);
				}
				if (Mathf.Abs(list[m.triangles[k]].z - num2) < offset2 && (list[m.triangles[k + 1]].z < num2 || list[m.triangles[k + 2]].z < num2))
				{
					ODDDDDQDOQ(tri, ref middleEndInts);
				}
				OCDQOQOCCD(m.triangles[k + 1], list[m.triangles[k + 1]], ref vecsInt, ref vecs, ref uv, ref uv2, ref normals, ref colors, ref tangents, m.uv[m.triangles[k + 1]], zero, list2[m.triangles[k + 1]], white, m.tangents[m.triangles[k + 1]], ref tri2);
				if (Mathf.Abs(list[m.triangles[k + 1]].z - startOffset) < offset2 && (list[m.triangles[k]].z > startOffset || list[m.triangles[k + 2]].z > startOffset))
				{
					ODDDDDQDOQ(tri2, ref middleStartInts);
				}
				if (Mathf.Abs(list[m.triangles[k + 1]].z - num2) < offset2 && (list[m.triangles[k]].z < num2 || list[m.triangles[k + 2]].z < num2))
				{
					ODDDDDQDOQ(tri2, ref middleEndInts);
				}
				OCDQOQOCCD(m.triangles[k + 2], list[m.triangles[k + 2]], ref vecsInt, ref vecs, ref uv, ref uv2, ref normals, ref colors, ref tangents, m.uv[m.triangles[k + 2]], zero, list2[m.triangles[k + 2]], white, m.tangents[m.triangles[k + 2]], ref tri3);
				if (Mathf.Abs(list[m.triangles[k + 2]].z - startOffset) < offset2 && (list[m.triangles[k + 1]].z > startOffset || list[m.triangles[k]].z > startOffset))
				{
					ODDDDDQDOQ(tri3, ref middleStartInts);
				}
				if (Mathf.Abs(list[m.triangles[k + 2]].z - num2) < offset2 && (list[m.triangles[k]].z < num2 || list[m.triangles[k + 1]].z < num2))
				{
					ODDDDDQDOQ(tri3, ref middleEndInts);
				}
				if (Mathf.Abs(list[m.triangles[k]].z - startOffset) < offset2 && Mathf.Abs(list[m.triangles[k + 1]].z - startOffset) < offset2)
				{
					InEdgePairArray(tri, tri2, ref vecsInts2);
				}
				if (Mathf.Abs(list[m.triangles[k]].z - startOffset) < offset2 && Mathf.Abs(list[m.triangles[k + 2]].z - startOffset) < offset2)
				{
					InEdgePairArray(tri, tri3, ref vecsInts2);
				}
				if (Mathf.Abs(list[m.triangles[k + 1]].z - startOffset) < offset2 && Mathf.Abs(list[m.triangles[k + 2]].z - startOffset) < offset2)
				{
					InEdgePairArray(tri2, tri3, ref vecsInts2);
				}
				if (Mathf.Abs(list[m.triangles[k]].z - num2) < offset2 && Mathf.Abs(list[m.triangles[k + 1]].z - num2) < offset2)
				{
					InEdgePairArray(tri, tri2, ref vecsInts3);
				}
				if (Mathf.Abs(list[m.triangles[k]].z - num2) < offset2 && Mathf.Abs(list[m.triangles[k + 2]].z - num2) < offset2)
				{
					InEdgePairArray(tri, tri3, ref vecsInts3);
				}
				if (Mathf.Abs(list[m.triangles[k + 1]].z - num2) < offset2 && Mathf.Abs(list[m.triangles[k + 2]].z - num2) < offset2)
				{
					InEdgePairArray(tri2, tri3, ref vecsInts3);
				}
			}
			vecs = new List<Vector3>(list);
			uv = new List<Vector2>(m.uv);
			uv2 = new List<Vector2>(m.uv2);
			normals = new List<Vector3>(list2);
			tangents = new List<Vector4>(m.tangents);
			colors = new List<Color>(m.colors);
			triangles = new List<int>(m.triangles);
			soScript.middleZDistance = totalZDistance;
			if (soScript.flipMesh)
			{
				int num9 = 0;
				for (int l = 0; l < triangles.Count; l += 3)
				{
					num9 = triangles[l];
					triangles[l] = triangles[l + 1];
					triangles[l + 1] = num9;
				}
			}
		}
		else
		{
			int tri4 = 0;
			int tri5 = 0;
			int tri6 = 0;
			Color sourceColor = Color.white;
			Vector2 sourceUv = Vector2.zero;
			for (int n = 0; n < m.triangles.Length; n += 3)
			{
				bool flag = false;
				if (list[m.triangles[n]].z < num2 || list[m.triangles[n + 1]].z < num2 || (list[m.triangles[n + 2]].z < num2 && list[m.triangles[n]].z <= num2 + offset1 && list[m.triangles[n + 1]].z <= num2 + offset1 && list[m.triangles[n + 2]].z <= num2 + offset1))
				{
					flag = true;
				}
				if (soScript.includeEndEdgeTris && list[m.triangles[n]].z <= num2 + offset1 && list[m.triangles[n + 1]].z <= num2 + offset1 && list[m.triangles[n + 2]].z <= num2 + offset1)
				{
					flag = true;
				}
				if (flag)
				{
					if (m.colors.Length > m.triangles[n])
					{
						sourceColor = m.colors[m.triangles[n]];
					}
					if (m.uv2.Length > m.triangles[n])
					{
						sourceUv = m.uv2[m.triangles[n]];
					}
					try
					{
						OCDQOQOCCD(m.triangles[n], list[m.triangles[n]], ref startVecsInt, ref startVecs, ref startUv, ref startUv2, ref startNormals, ref startColors, ref startTangents, m.uv[m.triangles[n]], sourceUv, list2[m.triangles[n]], sourceColor, m.tangents[m.triangles[n]], ref tri4);
					}
					catch
					{
					}
					if (Mathf.Abs(list[m.triangles[n]].z - num2) < offset2 && (list[m.triangles[n + 1]].z < num2 || list[m.triangles[n + 2]].z < num2))
					{
						ODDDDDQDOQ(tri4, ref startEndInts);
					}
					if (m.colors.Length > m.triangles[n + 1])
					{
						sourceColor = m.colors[m.triangles[n + 1]];
					}
					if (m.uv2.Length > m.triangles[n + 1])
					{
						sourceUv = m.uv2[m.triangles[n + 1]];
					}
					OCDQOQOCCD(m.triangles[n + 1], list[m.triangles[n + 1]], ref startVecsInt, ref startVecs, ref startUv, ref startUv2, ref startNormals, ref startColors, ref startTangents, m.uv[m.triangles[n + 1]], sourceUv, list2[m.triangles[n + 1]], sourceColor, m.tangents[m.triangles[n + 1]], ref tri5);
					if (Mathf.Abs(list[m.triangles[n + 1]].z - num2) < offset2 && (list[m.triangles[n]].z < num2 || list[m.triangles[n + 2]].z < num2))
					{
						ODDDDDQDOQ(tri5, ref startEndInts);
					}
					if (m.colors.Length > m.triangles[n + 2])
					{
						sourceColor = m.colors[m.triangles[n + 2]];
					}
					if (m.uv2.Length > m.triangles[n + 2])
					{
						sourceUv = m.uv2[m.triangles[n + 2]];
					}
					OCDQOQOCCD(m.triangles[n + 2], list[m.triangles[n + 2]], ref startVecsInt, ref startVecs, ref startUv, ref startUv2, ref startNormals, ref startColors, ref startTangents, m.uv[m.triangles[n + 2]], sourceUv, list2[m.triangles[n + 2]], sourceColor, m.tangents[m.triangles[n + 2]], ref tri6);
					if (Mathf.Abs(list[m.triangles[n + 2]].z - num2) < offset2 && (list[m.triangles[n]].z < num2 || list[m.triangles[n + 1]].z < num2))
					{
						ODDDDDQDOQ(tri6, ref startEndInts);
					}
					if (Mathf.Abs(list[m.triangles[n]].z - num2) < offset2 && Mathf.Abs(list[m.triangles[n + 1]].z - num2) < offset2)
					{
						InEdgePairArray(tri4, tri5, ref vecsInts);
					}
					if (Mathf.Abs(list[m.triangles[n]].z - num2) < offset2 && Mathf.Abs(list[m.triangles[n + 2]].z - num2) < offset2)
					{
						InEdgePairArray(tri4, tri6, ref vecsInts);
					}
					if (Mathf.Abs(list[m.triangles[n + 1]].z - num2) < offset2 && Mathf.Abs(list[m.triangles[n + 2]].z - num2) < offset2)
					{
						InEdgePairArray(tri5, tri6, ref vecsInts);
					}
					if (!soScript.flipMesh)
					{
						startTriangles.Add(tri4);
						startTriangles.Add(tri5);
						startTriangles.Add(tri6);
					}
					else
					{
						startTriangles.Add(tri5);
						startTriangles.Add(tri4);
						startTriangles.Add(tri6);
					}
					if (list[m.triangles[n]].z <= num3)
					{
						num3 = list[m.triangles[n]].z;
					}
					if (list[m.triangles[n + 1]].z <= num3)
					{
						num3 = list[m.triangles[n + 1]].z;
					}
					if (list[m.triangles[n + 2]].z <= num3)
					{
						num3 = list[m.triangles[n + 2]].z;
					}
					if (list[m.triangles[n]].z >= num4)
					{
						num4 = list[m.triangles[n]].z;
					}
					if (list[m.triangles[n + 1]].z >= num4)
					{
						num4 = list[m.triangles[n + 1]].z;
					}
					if (list[m.triangles[n + 2]].z >= num4)
					{
						num4 = list[m.triangles[n + 2]].z;
					}
				}
				bool flag2 = false;
				if (list[m.triangles[n]].z > startOffset || list[m.triangles[n + 1]].z > startOffset || (list[m.triangles[n + 2]].z > startOffset && list[m.triangles[n]].z > startOffset - offset1 && list[m.triangles[n + 1]].z > startOffset - offset1 && list[m.triangles[n + 2]].z > startOffset - offset1))
				{
					flag2 = true;
				}
				if (soScript.includeStartEdgeTris && list[m.triangles[n]].z >= startOffset - offset1 && list[m.triangles[n + 1]].z >= startOffset - offset1 && list[m.triangles[n + 2]].z >= startOffset - offset1)
				{
					flag2 = true;
				}
				if (!flag2)
				{
					continue;
				}
				if (m.colors.Length > m.triangles[n])
				{
					sourceColor = m.colors[m.triangles[n]];
				}
				if (m.uv2.Length > m.triangles[n])
				{
					sourceUv = m.uv2[m.triangles[n]];
				}
				OCDQOQOCCD(m.triangles[n], list[m.triangles[n]], ref endVecsInt, ref endVecs, ref endUv, ref endUv2, ref endNormals, ref endColors, ref endTangents, m.uv[m.triangles[n]], sourceUv, list2[m.triangles[n]], sourceColor, m.tangents[m.triangles[n]], ref tri4);
				if (Mathf.Abs(list[m.triangles[n]].z - startOffset) < offset2 && (list[m.triangles[n + 1]].z > startOffset || list[m.triangles[n + 2]].z > startOffset))
				{
					ODDDDDQDOQ(tri4, ref endStartInts);
				}
				if (m.colors.Length > m.triangles[n + 1])
				{
					sourceColor = m.colors[m.triangles[n + 1]];
				}
				if (m.uv2.Length > m.triangles[n + 1])
				{
					sourceUv = m.uv2[m.triangles[n + 1]];
				}
				OCDQOQOCCD(m.triangles[n + 1], list[m.triangles[n + 1]], ref endVecsInt, ref endVecs, ref endUv, ref endUv2, ref endNormals, ref endColors, ref endTangents, m.uv[m.triangles[n + 1]], sourceUv, list2[m.triangles[n + 1]], sourceColor, m.tangents[m.triangles[n + 1]], ref tri5);
				if (Mathf.Abs(list[m.triangles[n + 1]].z - startOffset) < offset2 && (list[m.triangles[n]].z > startOffset || list[m.triangles[n + 2]].z > startOffset))
				{
					ODDDDDQDOQ(tri5, ref endStartInts);
				}
				if (m.colors.Length > m.triangles[n + 2])
				{
					sourceColor = m.colors[m.triangles[n + 2]];
				}
				if (m.uv2.Length > m.triangles[n + 2])
				{
					sourceUv = m.uv2[m.triangles[n + 2]];
				}
				OCDQOQOCCD(m.triangles[n + 2], list[m.triangles[n + 2]], ref endVecsInt, ref endVecs, ref endUv, ref endUv2, ref endNormals, ref endColors, ref endTangents, m.uv[m.triangles[n + 2]], sourceUv, list2[m.triangles[n + 2]], sourceColor, m.tangents[m.triangles[n + 2]], ref tri6);
				if (Mathf.Abs(list[m.triangles[n + 2]].z - startOffset) < offset2 && (list[m.triangles[n + 1]].z > startOffset || list[m.triangles[n]].z > startOffset))
				{
					ODDDDDQDOQ(tri6, ref endStartInts);
				}
				if (Mathf.Abs(list[m.triangles[n]].z - startOffset) < offset2 && Mathf.Abs(list[m.triangles[n + 1]].z - startOffset) < offset2)
				{
					InEdgePairArray(tri4, tri5, ref vecsInts4);
				}
				if (Mathf.Abs(list[m.triangles[n]].z - startOffset) < offset2 && Mathf.Abs(list[m.triangles[n + 2]].z - startOffset) < offset2)
				{
					InEdgePairArray(tri4, tri6, ref vecsInts4);
				}
				if (Mathf.Abs(list[m.triangles[n + 1]].z - startOffset) < offset2 && Mathf.Abs(list[m.triangles[n + 2]].z - startOffset) < offset2)
				{
					InEdgePairArray(tri5, tri6, ref vecsInts4);
				}
				if (!soScript.flipMesh)
				{
					endTriangles.Add(tri4);
					endTriangles.Add(tri5);
					endTriangles.Add(tri6);
				}
				else
				{
					endTriangles.Add(tri5);
					endTriangles.Add(tri4);
					endTriangles.Add(tri6);
				}
				if (list[m.triangles[n]].z <= num7)
				{
					num7 = list[m.triangles[n]].z;
				}
				if (list[m.triangles[n + 1]].z <= num7)
				{
					num7 = list[m.triangles[n + 1]].z;
				}
				if (list[m.triangles[n + 2]].z <= num7)
				{
					num7 = list[m.triangles[n + 2]].z;
				}
				if (list[m.triangles[n]].z >= num8)
				{
					num8 = list[m.triangles[n]].z;
				}
				if (list[m.triangles[n + 1]].z >= num8)
				{
					num8 = list[m.triangles[n + 1]].z;
				}
				if (list[m.triangles[n + 2]].z >= num8)
				{
					num8 = list[m.triangles[n + 2]].z;
				}
				if (flag)
				{
					if (m.colors.Length > m.triangles[n])
					{
						sourceColor = m.colors[m.triangles[n]];
					}
					if (m.uv2.Length > m.triangles[n])
					{
						sourceUv = m.uv2[m.triangles[n]];
					}
					OCDQOQOCCD(m.triangles[n], list[m.triangles[n]], ref vecsInt, ref vecs, ref uv, ref uv2, ref normals, ref colors, ref tangents, m.uv[m.triangles[n]], sourceUv, list2[m.triangles[n]], sourceColor, m.tangents[m.triangles[n]], ref tri4);
					if (Mathf.Abs(list[m.triangles[n]].z - startOffset) < offset2 && (list[m.triangles[n + 1]].z > startOffset || list[m.triangles[n + 2]].z > startOffset))
					{
						ODDDDDQDOQ(tri4, ref middleStartInts);
					}
					if (Mathf.Abs(list[m.triangles[n]].z - num2) < offset2 && (list[m.triangles[n + 1]].z < num2 || list[m.triangles[n + 2]].z < num2))
					{
						ODDDDDQDOQ(tri4, ref middleEndInts);
					}
					if (m.colors.Length > m.triangles[n + 1])
					{
						sourceColor = m.colors[m.triangles[n + 1]];
					}
					if (m.uv2.Length > m.triangles[n + 1])
					{
						sourceUv = m.uv2[m.triangles[n + 1]];
					}
					OCDQOQOCCD(m.triangles[n + 1], list[m.triangles[n + 1]], ref vecsInt, ref vecs, ref uv, ref uv2, ref normals, ref colors, ref tangents, m.uv[m.triangles[n + 1]], sourceUv, list2[m.triangles[n + 1]], sourceColor, m.tangents[m.triangles[n + 1]], ref tri5);
					if (Mathf.Abs(list[m.triangles[n + 1]].z - startOffset) < offset2 && (list[m.triangles[n]].z > startOffset || list[m.triangles[n + 2]].z > startOffset))
					{
						ODDDDDQDOQ(tri5, ref middleStartInts);
					}
					if (Mathf.Abs(list[m.triangles[n + 1]].z - num2) < offset2 && (list[m.triangles[n]].z < num2 || list[m.triangles[n + 2]].z < num2))
					{
						ODDDDDQDOQ(tri5, ref middleEndInts);
					}
					if (m.colors.Length > m.triangles[n + 2])
					{
						sourceColor = m.colors[m.triangles[n + 2]];
					}
					if (m.uv2.Length > m.triangles[n + 2])
					{
						sourceUv = m.uv2[m.triangles[n + 2]];
					}
					OCDQOQOCCD(m.triangles[n + 2], list[m.triangles[n + 2]], ref vecsInt, ref vecs, ref uv, ref uv2, ref normals, ref colors, ref tangents, m.uv[m.triangles[n + 2]], sourceUv, list2[m.triangles[n + 2]], sourceColor, m.tangents[m.triangles[n + 2]], ref tri6);
					if (Mathf.Abs(list[m.triangles[n + 2]].z - startOffset) < offset2 && (list[m.triangles[n + 1]].z > startOffset || list[m.triangles[n]].z > startOffset))
					{
						ODDDDDQDOQ(tri6, ref middleStartInts);
					}
					if (Mathf.Abs(list[m.triangles[n + 2]].z - num2) < offset2 && (list[m.triangles[n]].z < num2 || list[m.triangles[n + 1]].z < num2))
					{
						ODDDDDQDOQ(tri6, ref middleEndInts);
					}
					if (Mathf.Abs(list[m.triangles[n]].z - startOffset) < offset2 && Mathf.Abs(list[m.triangles[n + 1]].z - startOffset) < offset2)
					{
						InEdgePairArray(tri4, tri5, ref vecsInts2);
					}
					if (Mathf.Abs(list[m.triangles[n]].z - startOffset) < offset2 && Mathf.Abs(list[m.triangles[n + 2]].z - startOffset) < offset2)
					{
						InEdgePairArray(tri4, tri6, ref vecsInts2);
					}
					if (Mathf.Abs(list[m.triangles[n + 1]].z - startOffset) < offset2 && Mathf.Abs(list[m.triangles[n + 2]].z - startOffset) < offset2)
					{
						InEdgePairArray(tri5, tri6, ref vecsInts2);
					}
					if (Mathf.Abs(list[m.triangles[n]].z - num2) < offset2 && Mathf.Abs(list[m.triangles[n + 1]].z - num2) < offset2)
					{
						InEdgePairArray(tri4, tri5, ref vecsInts3);
					}
					if (Mathf.Abs(list[m.triangles[n]].z - num2) < offset2 && Mathf.Abs(list[m.triangles[n + 2]].z - num2) < offset2)
					{
						InEdgePairArray(tri4, tri6, ref vecsInts3);
					}
					if (Mathf.Abs(list[m.triangles[n + 1]].z - num2) < offset2 && Mathf.Abs(list[m.triangles[n + 2]].z - num2) < offset2)
					{
						InEdgePairArray(tri5, tri6, ref vecsInts3);
					}
					if (!soScript.flipMesh)
					{
						triangles.Add(tri4);
						triangles.Add(tri5);
						triangles.Add(tri6);
					}
					else
					{
						triangles.Add(tri5);
						triangles.Add(tri4);
						triangles.Add(tri6);
					}
					if (list[m.triangles[n]].z <= num5)
					{
						num5 = list[m.triangles[n]].z;
					}
					if (list[m.triangles[n + 1]].z <= num5)
					{
						num5 = list[m.triangles[n + 1]].z;
					}
					if (list[m.triangles[n + 2]].z <= num5)
					{
						num5 = list[m.triangles[n + 2]].z;
					}
					if (list[m.triangles[n]].z >= num6)
					{
						num6 = list[m.triangles[n]].z;
					}
					if (list[m.triangles[n + 1]].z >= num6)
					{
						num6 = list[m.triangles[n + 1]].z;
					}
					if (list[m.triangles[n + 2]].z >= num6)
					{
						num6 = list[m.triangles[n + 2]].z;
					}
				}
			}
			for (int num10 = 0; num10 < endVecs.Count; num10++)
			{
				Vector3 item = endVecs[num10];
				item.z -= startOffset;
				endVecs[num10] = item;
			}
		}
		if (soScript.minStartZ > num3)
		{
			soScript.minStartZ = num3;
		}
		if (soScript.maxStartZ < num4)
		{
			soScript.maxStartZ = num4;
		}
		if (soScript.minMiddleZ > num5)
		{
			soScript.minMiddleZ = num5;
		}
		if (soScript.maxMiddleZ < num6)
		{
			soScript.maxMiddleZ = num6;
		}
		if (soScript.minEndZ > num7)
		{
			soScript.minEndZ = num7;
		}
		if (soScript.maxEndZ < num8)
		{
			soScript.maxEndZ = num8;
		}
		for (int num11 = 0; num11 < vecs.Count; num11++)
		{
			Vector3 item = vecs[num11];
			item.z -= startOffset;
			vecs[num11] = item;
		}
		materials = new List<Material>();
		materials.Add(mat);
		zValuesStart.Clear();
		zValueVecIndexesStart.Clear();
		zValuesEnd.Clear();
		zValueVecIndexesEnd.Clear();
		OCDCQCQQOC(vecs, ref zValueVecIndexes, ref zValues);
		OCDCQCQQOC(startVecs, ref zValueVecIndexesStart, ref zValuesStart);
		OCDCQCQQOC(endVecs, ref zValueVecIndexesEnd, ref zValuesEnd);
		startEndInts.Clear();
		middleStartStartInts.Clear();
		middleStartInts.Clear();
		middleEndInts.Clear();
		middleEndEndInts.Clear();
		endStartInts.Clear();
		startEndIntsNC.Clear();
		middleStartStartIntsNC.Clear();
		middleStartIntsNC.Clear();
		middleEndIntsNC.Clear();
		middleEndEndIntsNC.Clear();
		endStartIntsNC.Clear();
		if (soScript.includeStartSegment)
		{
			MatchEdgePairs(vecsInts, new List<CRedge>(vecsInts2), ref startEndInts, ref middleStartStartInts, ref startEndIntsNC, ref middleStartStartIntsNC, startVecs, vecs, startNormals, normals, ref OQOQODDQCCInt, ref ODQCDQCCODInt);
		}
		MatchEdgePairs(vecsInts2, new List<CRedge>(vecsInts3), ref middleStartInts, ref middleEndInts, ref middleStartIntsNC, ref middleEndIntsNC, vecs, vecs, normals, normals, ref middleLeftInt, ref middleRightInt);
		if (soScript.includeEndSegment)
		{
			MatchEdgePairs(vecsInts3, vecsInts4, ref middleEndEndInts, ref endStartInts, ref middleEndEndIntsNC, ref endStartIntsNC, vecs, endVecs, normals, endNormals, ref endLeftInt, ref endRightInt);
		}
		if (scale != Vector3.one)
		{
			for (int num12 = 0; num12 < startVecs.Count; num12++)
			{
				Vector3 item = startVecs[num12];
				item.x *= scale.x;
				item.y *= scale.y;
				item.z *= scale.z;
				startVecs[num12] = item;
			}
			for (int num13 = 0; num13 < vecs.Count; num13++)
			{
				Vector3 item = vecs[num13];
				item.x *= scale.x;
				item.y *= scale.y;
				item.z *= scale.z;
				vecs[num13] = item;
			}
			for (int num14 = 0; num14 < endVecs.Count; num14++)
			{
				Vector3 item = endVecs[num14];
				item.x *= scale.x;
				item.y *= scale.y;
				item.z *= scale.z;
				endVecs[num14] = item;
			}
		}
		if (soScript.doTestmesh)
		{
			ERModularBase eRModularBase = UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase;
			Transform transform = eRModularBase.transform;
			Transform transform2 = transform.Find("tmp folder");
			if ((bool)transform2)
			{
				UnityEngine.Object.DestroyImmediate(transform2.gameObject);
			}
			GameObject gameObject = new GameObject("tmp folder");
			gameObject.transform.position = Vector3.zero;
			gameObject.transform.parent = transform;
			GameObject gameObject2;
			if (soScript.includeStartSegment)
			{
				gameObject2 = new GameObject("start object");
				gameObject2.transform.parent = gameObject.transform;
				gameObject2.transform.position = soScript.testMeshPos;
				gameObject2.AddComponent<MeshRenderer>();
				gameObject2.AddComponent<MeshFilter>();
				m = new Mesh();
				gameObject2.GetComponent<MeshRenderer>().sharedMaterial = materials[0];
				gameObject2.GetComponent<MeshFilter>().sharedMesh = m;
				m.vertices = startVecs.ToArray();
				m.uv = startUv.ToArray();
				m.uv2 = startUv2.ToArray();
				m.colors = startColors.ToArray();
				m.normals = startNormals.ToArray();
				m.tangents = startTangents.ToArray();
				m.triangles = startTriangles.ToArray();
				m.RecalculateNormals();
				m.RecalculateBounds();
			}
			Vector3 testMeshPos;
			if (soScript.includeEndSegment)
			{
				gameObject2 = new GameObject("end object");
				gameObject2.transform.parent = gameObject.transform;
				testMeshPos = soScript.testMeshPos;
				testMeshPos.z += num2 + num2 - startOffset;
				gameObject2.transform.position = testMeshPos;
				gameObject2.AddComponent<MeshRenderer>();
				gameObject2.AddComponent<MeshFilter>();
				m = new Mesh();
				gameObject2.GetComponent<MeshRenderer>().sharedMaterial = materials[0];
				gameObject2.GetComponent<MeshFilter>().sharedMesh = m;
				m.vertices = endVecs.ToArray();
				m.uv = endUv.ToArray();
				m.uv2 = endUv2.ToArray();
				m.colors = endColors.ToArray();
				m.normals = endNormals.ToArray();
				m.tangents = endTangents.ToArray();
				m.triangles = endTriangles.ToArray();
				m.RecalculateNormals();
				m.RecalculateBounds();
			}
			gameObject2 = new GameObject("middle object");
			gameObject2.transform.parent = gameObject.transform;
			testMeshPos = soScript.testMeshPos;
			testMeshPos.z += num2;
			gameObject2.transform.position = testMeshPos;
			gameObject2.AddComponent<MeshRenderer>();
			gameObject2.AddComponent<MeshFilter>();
			m = new Mesh();
			gameObject2.GetComponent<MeshRenderer>().sharedMaterial = materials[0];
			gameObject2.GetComponent<MeshFilter>().sharedMesh = m;
			m.vertices = vecs.ToArray();
			m.uv = uv.ToArray();
			m.uv2 = uv2.ToArray();
			m.colors = colors.ToArray();
			m.normals = normals.ToArray();
			m.tangents = tangents.ToArray();
			m.triangles = triangles.ToArray();
			m.RecalculateNormals();
			m.RecalculateBounds();
		}
		OCQQQCQQDD();
	}

	private void OCDCDCQQDQ(GameObject m_go, SideObject soScript, float minZ, Transform sourceTransform, Vector3 scale, Mesh m, Material mat, float startMin, bool namingConvention)
	{
		List<float> list = new List<float>();
		List<ZIndexArray> list2 = new List<ZIndexArray>();
		List<Vector3> list3 = new List<Vector3>(m.vertices);
		List<Vector2> list4 = new List<Vector2>(m.uv);
		List<Vector2> list5 = new List<Vector2>(m.uv4);
		List<Color> list6 = new List<Color>(m.colors);
		List<Vector3> list7 = new List<Vector3>(m.normals);
		List<Vector4> list8 = new List<Vector4>(m.tangents);
		List<int> list9 = new List<int>(m.triangles);
		float num = 10000f;
		float num2 = -10000f;
		bool flag = false;
		if (m_go.name.Contains("_start"))
		{
			flag = true;
		}
		for (int i = 0; i < list3.Count; i++)
		{
			if (namingConvention)
			{
			}
			list3[i] = m_go.transform.TransformPoint(list3[i]);
			if (list3[i].z < num)
			{
				num = list3[i].z;
			}
			if (list3[i].z > num2)
			{
				num2 = list3[i].z;
			}
		}
		float num3 = Mathf.Abs(num2 - num);
		for (int j = 0; j < list3.Count; j++)
		{
			Vector3 value = list3[j];
			value.z -= num;
			list3[j] = value;
		}
		lodIndex = -1;
		string text = m_go.name;
		if (text.Contains("_lod"))
		{
			int num4 = text.ToUpper().IndexOf("_LOD");
			if (text.Length >= num4 + 5)
			{
				string s = text.Substring(num4 + 4, 1);
				lodIndex = -1;
				if (int.TryParse(s, out lodIndex) && lodIndex > soScript.lodLevels)
				{
					soScript.lodLevels = lodIndex;
				}
			}
		}
		if (m_go.name.Contains("_start"))
		{
			soScript.includeStartSegment = true;
			startVecs = list3;
			startUv = list4;
			startUv2 = list5;
			startColors = list6;
			startNormals = list7;
			startTangents = list8;
			startTriangles = list9;
			soScript.startZDistance = num3;
			if (soScript.maxStartZ < num2)
			{
				soScript.maxStartZ = num2;
			}
			if (soScript.minStartZ > num)
			{
				soScript.minStartZ = num;
			}
			soScript.startSection = true;
		}
		else if (m_go.name.Contains("_end"))
		{
			soScript.includeEndSegment = true;
			endVecs = list3;
			endUv = list4;
			endUv2 = list5;
			endColors = list6;
			endNormals = list7;
			endTangents = list8;
			endTriangles = list9;
			soScript.endZDistance = num3;
			if (soScript.maxEndZ < num2)
			{
				soScript.maxEndZ = num2;
			}
			if (soScript.minEndZ > num)
			{
				soScript.minEndZ = num;
			}
			soScript.endSection = true;
		}
		else if (m_go.name.Contains("_middle"))
		{
			vecs = list3;
			uv = list4;
			uv2 = list5;
			colors = list6;
			normals = list7;
			tangents = list8;
			triangles = list9;
			soScript.middleZDistance = num3;
			soScript.maxMiddleZ = num2;
			soScript.minMiddleZ = num;
			if (soScript.maxMiddleZ < num2)
			{
				soScript.maxMiddleZ = num2;
			}
			if (soScript.minMiddleZ > num)
			{
				soScript.minMiddleZ = num;
			}
		}
		else if (m_go.name.Contains("_stepUp"))
		{
			suVecs = list3;
			suUv = list4;
			suUv2 = list5;
			suColors = list6;
			suNormals = list7;
			suTangents = list8;
			suTriangles = list9;
			soScript.stepUp = true;
		}
		else if (m_go.name.Contains("_stepDown"))
		{
			sdVecs = list3;
			sdUv = list4;
			sdUv2 = list5;
			sdColors = list6;
			sdNormals = list7;
			sdTangents = list8;
			sdTriangles = list9;
			soScript.stepDown = true;
		}
		materials = new List<Material>();
		materials.Add(mat);
		zValuesStart.Clear();
		zValueVecIndexesStart.Clear();
		zValues.Clear();
		zValueVecIndexes.Clear();
		zValuesEnd.Clear();
		zValueVecIndexesEnd.Clear();
		zValuesStepUp.Clear();
		zValueVecIndexesStepUp.Clear();
		zValuesStepDown.Clear();
		zValueVecIndexesStepDown.Clear();
		OCDCQCQQOC(vecs, ref zValueVecIndexes, ref zValues);
		OCDCQCQQOC(startVecs, ref zValueVecIndexesStart, ref zValuesStart);
		OCDCQCQQOC(endVecs, ref zValueVecIndexesEnd, ref zValuesEnd);
		OCDCQCQQOC(suVecs, ref zValueVecIndexesStepUp, ref zValuesStepUp);
		OCDCQCQQOC(sdVecs, ref zValueVecIndexesStepDown, ref zValuesStepDown);
		OCQQQCQQDD();
	}

	private void OCDCQCQQOC(List<Vector3> vecs, ref List<ZIndexArray> zValueVecIndexes, ref List<float> zValues)
	{
		for (int i = 0; i < vecs.Count; i++)
		{
			if (!OOCDOCOCQO(vecs[i], i, zValues, ref zValueVecIndexes))
			{
				zValues.Add(vecs[i].z);
				zValueVecIndexes.Add(new ZIndexArray());
				zValueVecIndexes[zValueVecIndexes.Count - 1].index.Add(i);
			}
		}
	}

	public void GetMiddleSementInfo(List<Vector3> vecs, ref float minMiddleZ, ref float maxMiddleZ, ref List<int> middleStartInts, ref List<int> middleEndInts)
	{
		for (int i = 0; i < vecs.Count; i++)
		{
			if (vecs[i].z < minMiddleZ)
			{
				minMiddleZ = vecs[i].z;
			}
			if (vecs[i].z > maxMiddleZ)
			{
				maxMiddleZ = vecs[i].z;
			}
		}
		GetMiddleEdges(vecs, minMiddleZ, ref middleStartInts);
		GetMiddleEdges(vecs, maxMiddleZ, ref middleEndInts);
	}

	public void GetMiddleEdges(List<Vector3> vecs, float z, ref List<int> edgeInts)
	{
		for (int i = 0; i < vecs.Count; i++)
		{
			if (Mathf.Abs(vecs[i].z - z) < offset2)
			{
				edgeInts.Add(i);
			}
		}
	}

	public bool OOCDOCOCQO(Vector3 v, int index, List<float> zV, ref List<ZIndexArray> zVIndexes)
	{
		for (int i = 0; i < zV.Count; i++)
		{
			if (zV[i] == v.z)
			{
				zVIndexes[i].index.Add(index);
				return true;
			}
		}
		return false;
	}

	public void OCDQOQOCCD(int index, Vector3 v, ref List<int> vecsInts, ref List<Vector3> vecs, ref List<Vector2> uv, ref List<Vector2> uv2, ref List<Vector3> normals, ref List<Color> colors, ref List<Vector4> tangents, Vector2 sourceUv, Vector2 sourceUv2, Vector3 sourceNormal, Color sourceColor, Vector4 sourceTangent, ref int tri)
	{
		for (int i = 0; i < vecsInts.Count; i++)
		{
			if (index == vecsInts[i])
			{
				tri = i;
				return;
			}
		}
		vecsInts.Add(index);
		vecs.Add(v);
		uv.Add(sourceUv);
		uv2.Add(sourceUv2);
		normals.Add(sourceNormal);
		colors.Add(sourceColor);
		tangents.Add(sourceTangent);
		tri = vecs.Count - 1;
	}

	public void ODDDDDQDOQ(int index, ref List<int> vecsInts)
	{
		for (int i = 0; i < vecsInts.Count; i++)
		{
			if (index == vecsInts[i])
			{
				return;
			}
		}
		vecsInts.Add(index);
	}

	public void InEdgePairArray(int index1, int index2, ref List<CRedge> vecsInts)
	{
		for (int i = 0; i < vecsInts.Count; i++)
		{
			if ((index1 == vecsInts[i].v1 && index2 == vecsInts[i].v2) || (index1 == vecsInts[i].v2 && index2 == vecsInts[i].v1))
			{
				return;
			}
		}
		vecsInts.Add(new CRedge(index1, index2));
	}

	public void OQCDQOQOCQ(float adjustZ)
	{
		for (int i = 0; i < zValues.Count; i++)
		{
			zValues[i] -= adjustZ;
			for (int j = 0; j < zValueVecIndexes[i].index.Count; j++)
			{
				Vector3 value = vecs[zValueVecIndexes[i].index[j]];
				value.z -= adjustZ;
				vecs[zValueVecIndexes[i].index[j]] = value;
			}
		}
	}

	public void OCDDCDODQQ(ref List<List<int>> groups, List<int> triInts, List<int> edgeInts)
	{
		List<CRedge> list = new List<CRedge>();
		for (int i = 0; i < edgeInts.Count; i++)
		{
			for (int j = 0; j < triInts.Count; j += 3)
			{
				if (triInts[j] == edgeInts[i])
				{
					if (ODDDDDQDOQ(triInts[j + 1], edgeInts))
					{
						if (!OCDOQODCCQ(list, edgeInts[i], triInts[j + 1]))
						{
							list.Add(new CRedge(edgeInts[i], triInts[j + 1]));
						}
					}
					else if (ODDDDDQDOQ(triInts[j + 2], edgeInts) && !OCDOQODCCQ(list, edgeInts[i], triInts[j + 2]))
					{
						list.Add(new CRedge(edgeInts[i], triInts[j + 2]));
					}
				}
				else if (triInts[j + 1] == edgeInts[i])
				{
					if (ODDDDDQDOQ(triInts[j], edgeInts))
					{
						if (!OCDOQODCCQ(list, edgeInts[i], triInts[j]))
						{
							list.Add(new CRedge(edgeInts[i], triInts[j]));
						}
					}
					else if (ODDDDDQDOQ(triInts[j + 2], edgeInts) && !OCDOQODCCQ(list, edgeInts[i], triInts[j + 2]))
					{
						list.Add(new CRedge(edgeInts[i], triInts[j + 2]));
					}
				}
				else
				{
					if (triInts[j + 2] != edgeInts[i])
					{
						continue;
					}
					if (ODDDDDQDOQ(triInts[j + 1], edgeInts))
					{
						if (!OCDOQODCCQ(list, edgeInts[i], triInts[j + 1]))
						{
							list.Add(new CRedge(edgeInts[i], triInts[j + 1]));
						}
					}
					else if (ODDDDDQDOQ(triInts[j], edgeInts) && !OCDOQODCCQ(list, edgeInts[i], triInts[j]))
					{
						list.Add(new CRedge(edgeInts[i], triInts[j]));
					}
				}
			}
		}
		int curInt = -1;
		int num = -1;
		bool flag = false;
		while (list.Count > 0)
		{
			if (curInt == -1)
			{
				OOQOCOQOOO(list, ref curInt);
				groups.Add(new List<int>());
				num++;
				groups[num].Add(curInt);
			}
			flag = false;
			for (int k = 0; k < list.Count; k++)
			{
				if (list[k].v1 == curInt)
				{
					groups[num].Add(list[k].v2);
					curInt = list[k].v2;
					list.RemoveAt(k);
					flag = true;
					break;
				}
				if (list[k].v2 == curInt)
				{
					groups[num].Add(list[k].v1);
					curInt = list[k].v1;
					list.RemoveAt(k);
					flag = true;
					break;
				}
			}
			if (!flag && list.Count > 0)
			{
				curInt = -1;
			}
		}
	}

	public void OOQOCOQOOO(List<CRedge> edges, ref int curInt)
	{
		if (edges.Count > 1)
		{
			for (int i = 0; i < edges.Count; i++)
			{
				curInt = edges[i].v1;
				if (!OCCCOQOCQO(edges, i + 1, curInt))
				{
					break;
				}
				curInt = edges[i].v2;
				if (!OCCCOQOCQO(edges, i + 1, curInt))
				{
					break;
				}
			}
		}
		else
		{
			curInt = edges[0].v1;
		}
	}

	public bool OCCCOQOCQO(List<CRedge> edges, int index, int curInt)
	{
		for (int i = index; i < edges.Count; i++)
		{
			if (edges[i].v1 == curInt)
			{
				return true;
			}
			if (edges[i].v2 == curInt)
			{
				return true;
			}
		}
		return false;
	}

	public bool ODDDDDQDOQ(int index, List<int> edgeInts)
	{
		for (int i = 0; i < edgeInts.Count; i++)
		{
			if (index == edgeInts[i])
			{
				return true;
			}
		}
		return false;
	}

	public bool OCDOQODCCQ(List<CRedge> edges, int index1, int index2)
	{
		for (int i = 0; i < edges.Count; i++)
		{
			if ((edges[i].v1 == index1 && edges[i].v2 == index2) || (edges[i].v2 == index1 && edges[i].v1 == index2))
			{
				return true;
			}
		}
		return false;
	}

	public void MatchEdgePairs(List<CRedge> startEdgePairs, List<CRedge> endEdgePairs, ref List<int> startInts, ref List<int> endInts, ref List<int> startIntsNC, ref List<int> endIntsNC, List<Vector3> startVecs, List<Vector3> endVecs, List<Vector3> startNormals, List<Vector3> normals, ref int OQOQODDQCCInt, ref int ODQCDQCCODInt)
	{
		for (int i = 0; i < startEdgePairs.Count; i++)
		{
			for (int j = 0; j < endEdgePairs.Count; j++)
			{
				Vector3 b = endVecs[endEdgePairs[j].v1];
				Vector3 b2 = endVecs[endEdgePairs[j].v2];
				b.z = (b2.z = startVecs[startEdgePairs[i].v1].z);
				float num = Vector3.Distance(startVecs[startEdgePairs[i].v1], b);
				float num2 = Vector3.Distance(startVecs[startEdgePairs[i].v2], b2);
				if (num < offset2 && num2 < offset2)
				{
					if (!ODDDDDQDOQ(startEdgePairs[i].v1, startInts))
					{
						startInts.Add(startEdgePairs[i].v1);
						endInts.Add(endEdgePairs[j].v1);
					}
					if (!ODDDDDQDOQ(startEdgePairs[i].v2, startInts))
					{
						startInts.Add(startEdgePairs[i].v2);
						endInts.Add(endEdgePairs[j].v2);
					}
					startEdgePairs.RemoveAt(i);
					endEdgePairs.RemoveAt(j);
					i--;
					break;
				}
				num = Vector3.Distance(startVecs[startEdgePairs[i].v1], b2);
				num2 = Vector3.Distance(startVecs[startEdgePairs[i].v2], b);
				if (num < offset2 && num2 < offset2)
				{
					if (!ODDDDDQDOQ(startEdgePairs[i].v1, startInts))
					{
						startInts.Add(startEdgePairs[i].v1);
						endInts.Add(endEdgePairs[j].v2);
					}
					if (!ODDDDDQDOQ(startEdgePairs[i].v2, startInts))
					{
						startInts.Add(startEdgePairs[i].v2);
						endInts.Add(endEdgePairs[j].v1);
					}
					startEdgePairs.RemoveAt(i);
					endEdgePairs.RemoveAt(j);
					i--;
					break;
				}
			}
		}
		if (startEdgePairs.Count > 0)
		{
			for (int k = 0; k < startEdgePairs.Count; k++)
			{
				if (!ODDDDDQDOQ(startEdgePairs[k].v1, startInts) && !ODDDDDQDOQ(startEdgePairs[k].v1, startIntsNC))
				{
					startIntsNC.Add(startEdgePairs[k].v1);
				}
				if (!ODDDDDQDOQ(startEdgePairs[k].v2, startInts) && !ODDDDDQDOQ(startEdgePairs[k].v2, startIntsNC))
				{
					startIntsNC.Add(startEdgePairs[k].v2);
				}
			}
		}
		if (endEdgePairs.Count > 0)
		{
			for (int l = 0; l < endEdgePairs.Count; l++)
			{
				if (!ODDDDDQDOQ(endEdgePairs[l].v1, endInts) && !ODDDDDQDOQ(endEdgePairs[l].v1, endIntsNC))
				{
					endIntsNC.Add(endEdgePairs[l].v1);
				}
				if (!ODDDDDQDOQ(endEdgePairs[l].v2, endInts) && !ODDDDDQDOQ(endEdgePairs[l].v2, endIntsNC))
				{
					endIntsNC.Add(endEdgePairs[l].v2);
				}
			}
		}
		if ((startEdgePairs.Count <= 0 && endEdgePairs.Count <= 0) || startInts.Count <= 0)
		{
			return;
		}
		float num3 = 10000f;
		float num4 = -10000f;
		for (int m = 0; m < startInts.Count; m++)
		{
			if (startVecs[startInts[m]].x < num3)
			{
				num3 = startVecs[startInts[m]].x;
				OQOQODDQCCInt = m;
			}
			if (startVecs[startInts[m]].x > num4)
			{
				num4 = startVecs[startInts[m]].x;
				OQOQODDQCCInt = m;
			}
		}
	}

	public void OQOCDDCQDD(List<List<int>> startGroups, List<List<int>> endGroups, ref List<int> startInts, ref List<int> endInts, List<Vector3> startVecs, List<Vector3> endVecs)
	{
		startInts.Clear();
		endInts.Clear();
		bool flag = true;
		for (int i = 0; i < startGroups.Count; i++)
		{
			bool flag2 = false;
			for (int j = 0; j < endGroups.Count; j++)
			{
				if (startGroups[i].Count == endGroups[j].Count)
				{
					if (Mathf.Abs(startVecs[startGroups[i][0]].x - endVecs[endGroups[j][0]].x) < offset2 && Mathf.Abs(startVecs[startGroups[i][0]].y - endVecs[endGroups[j][0]].y) < offset2 && Mathf.Abs(startVecs[startGroups[i][startGroups[i].Count - 1]].x - endVecs[endGroups[j][endGroups[j].Count - 1]].x) < offset2 && Mathf.Abs(startVecs[startGroups[i][startGroups[i].Count - 1]].y - endVecs[endGroups[j][endGroups[j].Count - 1]].y) < offset2)
					{
						flag2 = true;
						startInts.AddRange(startGroups[i]);
						endInts.AddRange(endGroups[j]);
						break;
					}
					if (Mathf.Abs(startVecs[startGroups[i][0]].x - endVecs[endGroups[j][endGroups[j].Count - 1]].x) < offset2 && Mathf.Abs(startVecs[startGroups[i][0]].y - endVecs[endGroups[j][endGroups[j].Count - 1]].y) < offset2 && Mathf.Abs(startVecs[startGroups[i][startGroups[i].Count - 1]].x - endVecs[endGroups[j][0]].x) < offset2 && Mathf.Abs(startVecs[startGroups[i][startGroups[i].Count - 1]].y - endVecs[endGroups[j][0]].y) < offset2)
					{
						flag2 = true;
						startInts.AddRange(startGroups[i]);
						endGroups[j].Reverse();
						endInts.AddRange(endGroups[j]);
						break;
					}
				}
			}
			if (!flag2)
			{
				flag = false;
			}
		}
		if (flag)
		{
			return;
		}
		startInts.Clear();
		endInts.Clear();
		List<int> list = new List<int>();
		List<int> list2 = new List<int>();
		for (int k = 0; k < startGroups.Count; k++)
		{
			list.AddRange(startGroups[k]);
		}
		for (int l = 0; l < endGroups.Count; l++)
		{
			list2.AddRange(endGroups[l]);
		}
		for (int m = 0; m < list.Count; m++)
		{
			for (int n = m + 1; n < list.Count; n++)
			{
				if (list[m] == list[n])
				{
					list.RemoveAt(n);
					n--;
				}
			}
		}
		for (int num = 0; num < list2.Count; num++)
		{
			for (int num2 = num + 1; num2 < list2.Count; num2++)
			{
				if (list2[num] == list2[num2])
				{
					list2.RemoveAt(num2);
					num2--;
				}
			}
		}
		for (int num3 = 0; num3 < list.Count; num3++)
		{
			for (int num4 = 0; num4 < list2.Count; num4++)
			{
				if (Mathf.Abs(startVecs[list[num3]].x - endVecs[list2[num4]].x) < offset2 && Mathf.Abs(startVecs[list[num3]].y - endVecs[list2[num4]].y) < offset2)
				{
					startInts.Add(list[num3]);
					endInts.Add(list2[num4]);
					list2.RemoveAt(num4);
					break;
				}
			}
		}
	}

	public void ODDDOCDCQO(ERModularRoad roadScr, GameObject go, SideObject so, ERModularBase scr, bool mirrored, int sectionListIndex, List<int> sectionIndexes, int autoSectionStart)
	{
		int num = 0;
		if (sectionListIndex >= 0)
		{
			if (sectionListIndex == 3 && ((so.relativeTo == 1 && mirrored) || (so.relativeTo == 2 && !mirrored)))
			{
				sectionListIndex = 4;
			}
			if (sectionListIndex == 6 && ((so.relativeTo == 1 && mirrored) || (so.relativeTo == 2 && !mirrored)))
			{
				sectionListIndex = 7;
			}
			if (sectionListIndex == 5 && so.relativeTo == 2)
			{
				num = 1;
			}
		}
		if (so.meshObjects.Count == 1 && so.meshObjects[0].sVecsGroups.Count == 0 && !mirrored && sectionListIndex <= 0)
		{
			if (go.GetComponent<MeshRenderer>() == null)
			{
				go.AddComponent<MeshRenderer>();
			}
			if (go.GetComponent<MeshFilter>() == null)
			{
				go.AddComponent<MeshFilter>();
			}
			go.layer = so.layer;
			go.isStatic = so.isStatic;
			if (so.castShadows && so.meshObjects[0].castShadows)
			{
				go.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.On;
			}
			else
			{
				go.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.Off;
			}
			if (so.objectType == 1 && so.meshObjects[0].materials.Count > 0)
			{
				if (so.meshObjects[0].materials[0] != so.material)
				{
					so.meshObjects[0].materials[0] = so.material;
				}
				else if (so.objectType == 1 && so.meshObjects[0].materials.Count == 0)
				{
					so.meshObjects[0].materials.Add(so.material);
				}
			}
			OODCCOCQOC(go, so, scr, so.meshObjects[0].sVecs, so.meshObjects[0].sUv, so.meshObjects[0].sUv2, so.meshObjects[0].sColors, so.meshObjects[0].sNormals, so.meshObjects[0].sTangents, so.meshObjects[0].sTriangles, so.meshObjects[0].normalArray1, so.meshObjects[0].normalArray2, so.meshObjects[0].materials, so.meshObjects[0].sTerrainNormals);
		}
		else
		{
			for (int i = 0; i < so.meshObjects.Count; i++)
			{
				GameObject gameObject;
				for (int j = 0; j < so.meshObjects[i].sVecsGroups.Count; j++)
				{
					gameObject = ((so.meshObjects.Count == 1) ? new GameObject(so.name + " Batch " + (j + 1)) : ((so.meshObjects[i].sVecsGroups.Count <= 0) ? new GameObject(so.name + " Mesh " + (i + 1)) : new GameObject(so.name + " Mesh " + (i + 1) + " Batch " + (j + 1))));
					gameObject.transform.parent = go.transform;
					gameObject.AddComponent<MeshRenderer>();
					gameObject.AddComponent<MeshFilter>();
					gameObject.transform.parent = go.transform;
					gameObject.layer = so.layer;
					gameObject.isStatic = so.isStatic;
					if (so.castShadows && so.meshObjects[i].castShadows)
					{
						gameObject.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.On;
					}
					else
					{
						gameObject.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.Off;
					}
					OODCCOCQOC(gameObject, so, scr, so.meshObjects[i].sVecsGroups[j], so.meshObjects[i].sUvGroups[j], so.meshObjects[i].sUv2Groups[j], so.meshObjects[i].sColorsGroups[j], so.meshObjects[i].sNormalsGroups[j], so.meshObjects[i].sTangentsGroups[j], so.meshObjects[i].sTrianglesGroups[j], so.meshObjects[i].normalArray1Group[j], so.meshObjects[i].normalArray2Group[j], so.meshObjects[i].materials, so.meshObjects[i].sTerrainNormals);
				}
				gameObject = ((so.meshObjects.Count == 1) ? new GameObject(so.name + " Batch " + (so.meshObjects[i].sVecsGroups.Count + 1)) : ((so.meshObjects[i].sVecsGroups.Count <= 0) ? new GameObject(so.name + " Mesh " + (i + 1)) : new GameObject(so.name + " Mesh " + (i + 1) + " Batch " + (so.meshObjects[i].sVecsGroups.Count + 1))));
				gameObject.transform.parent = go.transform;
				gameObject.AddComponent<MeshRenderer>();
				gameObject.AddComponent<MeshFilter>();
				gameObject.transform.parent = go.transform;
				gameObject.layer = so.layer;
				gameObject.isStatic = so.isStatic;
				if (so.castShadows && so.meshObjects[i].castShadows)
				{
					gameObject.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.On;
				}
				else
				{
					gameObject.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.Off;
				}
				OODCCOCQOC(gameObject, so, scr, so.meshObjects[i].sVecs, so.meshObjects[i].sUv, so.meshObjects[i].sUv2, so.meshObjects[i].sColors, so.meshObjects[i].sNormals, so.meshObjects[i].sTangents, so.meshObjects[i].sTriangles, so.meshObjects[i].normalArray1, so.meshObjects[i].normalArray2, so.meshObjects[i].materials, so.meshObjects[i].sTerrainNormals);
			}
			if (!mirrored)
			{
				if ((bool)go.GetComponent<MeshRenderer>())
				{
					UnityEngine.Object.DestroyImmediate(go.GetComponent<MeshRenderer>());
				}
				if ((bool)go.GetComponent<MeshFilter>())
				{
					UnityEngine.Object.DestroyImmediate(go.GetComponent<MeshFilter>());
				}
				if ((bool)go.GetComponent<MeshCollider>())
				{
					UnityEngine.Object.DestroyImmediate(go.GetComponent<MeshCollider>());
				}
			}
		}
		Clear();
	}

	public static bool OQCQCDQDOO(ERModularRoad rd, int listIndex, int listItemIndex, SideObject so, bool mirrored)
	{
		if (listIndex == 1 && rd.soSectionList1.Count > listItemIndex)
		{
			return rd.soSectionList1[listItemIndex].active;
		}
		if (listIndex == 2 && rd.soSectionList2.Count > listItemIndex)
		{
			return rd.soSectionList2[listItemIndex].active;
		}
		if (listIndex == 3 && rd.soSectionList3.Count > listItemIndex)
		{
			return rd.soSectionList3[listItemIndex].active;
		}
		if (listIndex == 4 && rd.soSectionList4.Count > listItemIndex)
		{
			return rd.soSectionList4[listItemIndex].active;
		}
		if (listIndex == 5 && rd.soSectionList5.Count > listItemIndex)
		{
			return rd.soSectionList5[listItemIndex].active;
		}
		if (listIndex == 6 && rd.soSectionList6.Count > listItemIndex)
		{
			return rd.soSectionList6[listItemIndex].active;
		}
		if (listIndex == 7 && rd.soSectionList7.Count > listItemIndex)
		{
			return rd.soSectionList7[listItemIndex].active;
		}
		return true;
	}

	private void OODCCOCQOC(GameObject go, SideObject so, ERModularBase scr, List<Vector3> sVecs, List<Vector2> sUv, List<Vector2> sUv2, List<Color> sColors, List<Vector3> sNormals, List<Vector4> sTangents, List<int> sTriangles, List<int> normalArray1, List<int> normalArray2, List<Material> materials, List<Vector3> sTerrainNormals)
	{
		if (go.GetComponent<MeshFilter>() == null)
		{
			go.AddComponent<MeshFilter>();
		}
		Mesh mesh = go.GetComponent<MeshFilter>().sharedMesh;
		if (mesh == null)
		{
			mesh = new Mesh();
			go.GetComponent<MeshFilter>().sharedMesh = mesh;
		}
		if (materials.Count > 0)
		{
			go.GetComponent<MeshRenderer>().sharedMaterial = materials[0];
		}
		mesh.Clear();
		mesh.vertices = sVecs.ToArray();
		mesh.uv = sUv.ToArray();
		mesh.uv4 = sUv2.ToArray();
		mesh.colors = sColors.ToArray();
		mesh.normals = new Vector3[mesh.vertices.Length];
		mesh.tangents = sTangents.ToArray();
		mesh.triangles = sTriangles.ToArray();
		if (so.objectType == 1 || sNormals.Count != sVecs.Count)
		{
			mesh.RecalculateNormals();
		}
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();
		sNormals = new List<Vector3>(mesh.normals);
		Vector3 zero = Vector3.zero;
		int[] array = normalArray1.ToArray();
		int[] array2 = normalArray2.ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			List<Vector3> list = sNormals;
			int index = normalArray1[i];
			Vector3 value = (sNormals[array[i]] = (sNormals[array[i]] + sNormals[array2[i]]) * 0.5f);
			list[index] = value;
		}
		if (so.objectType == 1 && so.indentController)
		{
			for (int j = 0; j < sTerrainNormals.Count; j++)
			{
				if (sTerrainNormals[j] != Vector3.zero)
				{
					sNormals[j] = sTerrainNormals[j];
				}
			}
		}
		if (so.tunnelObject && so.hasVertexColors && sVecs.Count <= sColors.Count && sVecs.Count <= sNormals.Count)
		{
			for (int k = 0; k < sVecs.Count; k++)
			{
				if (sColors[k].r != 0f)
				{
					Vector3 b = scr.OQOODODDQO(sVecs[k]);
					sNormals[k] = Vector3.Lerp(sNormals[k], b, sColors[k].r);
				}
			}
		}
		if (sNormals.Count == mesh.normals.Length)
		{
			mesh.normals = sNormals.ToArray();
		}
		if (so.collider)
		{
			if ((bool)go.GetComponent<MeshCollider>())
			{
				go.GetComponent<MeshCollider>().sharedMesh = null;
			}
			else
			{
				go.AddComponent<MeshCollider>();
			}
			go.GetComponent<MeshCollider>().sharedMesh = mesh;
		}
		ODCCODOCQQ.OCDCQCOQQO(mesh);
		if (sVecs.Count == 0)
		{
			if (go.GetComponent<MeshFilter>() != null)
			{
				UnityEngine.Object.DestroyImmediate(go.GetComponent<MeshFilter>());
			}
			if (go.GetComponent<MeshRenderer>() != null)
			{
				UnityEngine.Object.DestroyImmediate(go.GetComponent<MeshRenderer>());
			}
			if (go.GetComponent<MeshCollider>() != null)
			{
				UnityEngine.Object.DestroyImmediate(go.GetComponent<MeshCollider>());
			}
		}
	}

	private void OCOCOQQOOO(ref int vecCount, ref List<int> intList, List<Vector3> vecsList, float zValue)
	{
		for (int i = 0; i < vecsList.Count; i++)
		{
			Vector3 a = vecsList[i];
			a.z = zValue;
			if (Vector3.Distance(a, vecsList[i]) < offset1)
			{
				intList.Add(i);
			}
		}
		vecCount = intList.Count;
	}

	private void OCODQQOCDD(ref List<int> targetIntList, List<int> sourceIntList, List<Vector3> targetVecs, List<Vector3> sourceVecs)
	{
		List<int> list = new List<int>(targetIntList);
		int num = 0;
		float num2 = 1000f;
		float num3 = 1000f;
		int num4 = -1;
		for (int i = 0; i < targetIntList.Count; i++)
		{
			Vector2 a = new Vector2(targetVecs[targetIntList[i]].x, targetVecs[targetIntList[i]].y);
			num2 = 1000f;
			num4 = -1;
			for (int j = 0; j < sourceIntList.Count; j++)
			{
				Vector2 b = new Vector2(sourceVecs[sourceIntList[j]].x, sourceVecs[sourceIntList[j]].y);
				num3 = Vector2.Distance(a, b);
				if ((double)num3 < 0.005 && num3 < num2)
				{
					num4 = j;
					break;
				}
				if (num4 != -1)
				{
					list[num4] = targetIntList[i];
					num++;
				}
			}
		}
		targetIntList = new List<int>(list);
	}

	public void Clear()
	{
		sVecs.Clear();
		sUv.Clear();
		sUv2.Clear();
		sColors.Clear();
		sNormals.Clear();
		sTangents.Clear();
		sTriangles.Clear();
		normalArray1.Clear();
		normalArray2.Clear();
		sTerrainNormals.Clear();
		if (sVecsGroups != null)
		{
			sVecsGroups.Clear();
		}
		else
		{
			sVecsGroups = new List<List<Vector3>>();
		}
		if (sUvGroups != null)
		{
			sUvGroups.Clear();
		}
		else
		{
			sUvGroups = new List<List<Vector2>>();
		}
		if (sUv2Groups != null)
		{
			sUv2Groups.Clear();
		}
		else
		{
			sUv2Groups = new List<List<Vector2>>();
		}
		if (sColorsGroups != null)
		{
			sColorsGroups.Clear();
		}
		else
		{
			sColorsGroups = new List<List<Color>>();
		}
		if (sNormalsGroups != null)
		{
			sNormalsGroups.Clear();
		}
		else
		{
			sNormalsGroups = new List<List<Vector3>>();
		}
		if (sTangentsGroups != null)
		{
			sTangentsGroups.Clear();
		}
		else
		{
			sTangentsGroups = new List<List<Vector4>>();
		}
		if (sTrianglesGroups != null)
		{
			sTrianglesGroups.Clear();
		}
		else
		{
			sTrianglesGroups = new List<List<int>>();
		}
		if (normalArray1Group != null)
		{
			normalArray1Group.Clear();
		}
		else
		{
			normalArray1Group = new List<List<int>>();
		}
		if (normalArray2Group != null)
		{
			normalArray2Group.Clear();
		}
		else
		{
			normalArray2Group = new List<List<int>>();
		}
		if (sTerrainNormalsGroups != null)
		{
			sTerrainNormalsGroups.Clear();
		}
		else
		{
			sTerrainNormalsGroups = new List<List<Vector3>>();
		}
		vecCount = 0;
	}
}
[Serializable]
public class SideObjectLog
{
	public string version = "2.0.0";

	public string name;

	public double id;

	public double timestamp;

	public int objectType = 0;

	public string gameobjectGUID;

	public string textureGUID;

	public float m_distance = 10f;

	public float uvx = 0.1f;

	public float uvy = 1f;

	public int position = 0;

	public float splinePosition = 0f;

	public int selectedRotation = 0;

	public float randomYAxisMinRotation = 0f;

	public float randomYAxisMaxRotation = 0f;

	public List<Vector2> nodeList = new List<Vector2>();

	public List<float> uvs = new List<float>();

	public List<float> uvDistances = new List<float>();

	public bool clampUVs = true;

	public bool clampUVY = true;

	public float clampUVYValue = 1f;

	public bool terrainUVs = false;

	public bool reverseUVs = false;

	public float totalDistance = 0f;

	public List<bool> snapList = new List<bool>();

	public List<float> snapWeightList = new List<float>();

	public List<Color> colorList = new List<Color>();

	public string gameobjectStartGUID;

	public string gameobjectEndGUID;

	public int align = 1;

	public int alignPoint = 0;

	public bool weld = true;

	public bool combine = true;

	public bool combineInstantiated = true;

	public bool markerActive = true;

	public int uvType = 0;

	public float uv = 1f;

	public bool randomObjects = false;

	public float forwardStartOffset = 0f;

	public float sidewaysOffset = 0f;

	public float density = 0f;

	public string goPath = "";

	public string startPath = "";

	public string endPath = "";

	public string texturePath = "";

	public int terrainTree = 0;

	public float minScale = 1f;

	public float maxScale = 1f;

	public bool childOrderActive = false;

	public int childOrder = 0;

	public bool meshBoundsAlignment = false;

	public float xPosition = 0f;

	public float xPosition2 = 0f;

	public int relativeTo = 0;

	public float yPosition = 0f;

	public float yRotation = 0f;

	public float oldSidwaysDistance = 0f;

	public int sidewaysDistanceUpdate = 0;

	public float uvYRound = 0f;

	public bool adjustUV = true;

	public bool collider = false;

	public bool boxcollider = false;

	public bool tangents = false;

	public GameObject sourceObject;

	public bool flipMesh = false;

	public GameObject startObject;

	public GameObject endObject;

	public GameObject connectionObject;

	public Material material;

	public List<ERMesh> meshObjects = new List<ERMesh>();

	public Vector2 boxSize;

	public Vector2 boxOffset;

	public bool includeStartSegment = false;

	public float startSegmentOffset = 0f;

	public bool includeStartEdgeTris = false;

	public bool includeEndSegment = false;

	public float endSegmentOffset = 0f;

	public bool includeEndEdgeTris = false;

	public bool adjustToRoadWidth = false;

	public float xOffset = 0f;

	public float startOffset = 0.5f;

	public float endOffset = 0.5f;

	public float defaultStartOffset = 0f;

	public float defaultEndOffset = 0f;

	public float totalZDistance = 0f;

	public float middleZDistance = 0f;

	public float startZDistance = 0f;

	public float endZDistance = 0f;

	public float minStartZ = 10000f;

	public float maxStartZ = -10000f;

	public float minMiddleZ = 10000f;

	public float maxMiddleZ = -10000f;

	public float minEndZ = 10000f;

	public float maxEndZ = -10000f;

	public bool smoothStart = false;

	public bool smoothMiddle = false;

	public bool smoothEnd = false;

	public GameObject targetObject;

	public bool bridgeObject = false;

	public bool tunnelObject = false;

	public bool snapToTerrain = false;

	public int layer = 0;

	public bool deformationObject = false;

	public bool isStatic = false;

	public bool castShadows = true;

	public bool scaleToRoad = false;

	public bool splitInBatches = false;

	public Vector3 randomRotation = Vector3.zero;

	public float randomMinRotation = 0f;

	public float randomMaxRotation = 0f;

	public float minRandomRotationDistance = 0f;

	public float maxRandomRotationDistance = 0f;

	public float randomXPosition = 0f;

	public float randomMinXPosition = 0f;

	public float randomMaxXPosition = 0f;

	public float minRandomXPositionDistance = 0f;

	public float maxRandomXPositionDistance = 0f;

	public Vector3 boxColliderScale = new Vector3(1f, 1f, 1f);

	public float randomYPosition = 0f;

	public float randomMinYPosition = 0f;

	public float randomMaxYPosition = 0f;

	public float minRandomYPositionDistance = 0f;

	public float maxRandomYPositionDistance = 0f;

	public float bridgeHeight = 5f;

	public int markerSplineController = 2;

	public float bridgeLength = 20f;

	public float deformationOffset = 20f;

	public float markerIndent = 20f;

	public float markerSurrounding = 10f;

	public bool indentController = false;

	public bool excludeTerrainSplats = false;

	public Vector3 scale = Vector3.one;

	public float indentExt = 0f;

	public int category = 0;

	public Texture2D densityMap;

	public float densitySize = 50f;

	public float densitySize2 = 50f;

	public float densityStrength = 0.5f;

	public float densityStrength2 = 0.5f;

	public float terrainNormal = 0f;

	public float terrainNormal2 = 1f;

	public List<ERChildsSO> childObjects = new List<ERChildsSO>();

	public bool autoGenerate = false;

	public float heightThreshold = 10f;

	public float autogenerateStartOffset = 0f;

	public float autogenerateEndOffset = 0f;

	public bool snapIndents = false;

	public float snapIndentWidth = 0f;

	public bool cutHoles = true;

	public float innerStartOffset = 0f;

	public float innerEndOffset = 0f;

	public bool ignoredForRetainingWalls = false;

	public float heightMaxThreshold = 100f;

	public float heightMaxStartThreshold = 1f;

	public float heightMaxEndThreshold = 1f;

	public float xThresholdDistance = 5f;

	public float angleThreshold = 10f;

	public int connectionRatio = 1;

	public bool retainingWall = false;

	public int surroundingControl = 0;

	public int indentControl = 0;

	public List<Vector2> nodeListMirrored = new List<Vector2>();

	public List<float> uvsMirrored = new List<float>();

	public List<float> snapWeightListMirrored = new List<float>();

	public List<Color> colorListMirrored = new List<Color>();

	public bool hasVertexColors = false;

	public float deformationOffsetForward = 0f;

	public float deformationOffsetSideways = 0f;

	public int connectionObjectRotation = 0;

	public bool subMesh = false;

	public bool acceptBarriers = true;

	public bool activeOnBridges = true;

	public bool dualSided = false;

	public int mirrorType = 0;

	public bool snapVertexColors = false;

	public float minSnapRange = 0f;

	public float maxSnapRange = 0f;

	public bool clampUV4 = false;

	public float geoStartOffset = 0f;

	public float geoEndOffset = 0f;

	public float startOverlapOffset = 0f;

	public float endOverlapOffset = 0f;

	public int lodLevels = 0;

	public List<bool> hardEdge = new List<bool>();

	public float hardEdgePadding = 0f;

	public bool startEndCaps = false;

	public List<Vector2> endCapUVs = new List<Vector2>();

	public List<Vector2> startCapUVs = new List<Vector2>();

	public List<int> startCapTris = new List<int>();

	public List<int> startCapTrisMirrored = new List<int>();

	public Vector2 startCapUVOffset = new Vector2(0.5f, 0.5f);

	public Vector2 endCapUVOffset = new Vector2(0.5f, 0.5f);

	public float startCapUVScale = 1f;

	public float endCapUVScale = 1f;

	public float startCapUVRotation = 0f;

	public float endCapUVRotation = 0f;

	public bool namedChilds = false;

	public bool startSection = false;

	public bool endSection = false;

	public bool stepDown = false;

	public bool stepUp = false;

	public float stepDistance = 0f;

	public float startDirZOffset = 0f;

	public float endDirZOffset = 0f;

	public bool buildOtherSideObject1 = false;

	public double defaultOtherSoId1 = 0.0;

	public bool buildOtherSideObject2 = false;

	public double defaultOtherSoId2 = 0.0;

	public List<double> buildOtherSideObjects = new List<double>();

	public bool averageDistance = true;

	public bool randomUVx = false;

	public bool isUsedAsChild = false;

	public void OODOOOQQCO(SideObject so)
	{
		name = so.name;
		id = so.id;
		timestamp = so.timestamp;
		objectType = so.objectType;
		gameobjectGUID = so.gameobjectGUID;
		textureGUID = so.textureGUID;
		m_distance = so.m_distance;
		uvx = so.uvx;
		uvy = so.uvy;
		position = so.position;
		splinePosition = so.splinePosition;
		selectedRotation = so.selectedRotation;
		randomYAxisMinRotation = so.randomYAxisMinRotation;
		randomYAxisMaxRotation = so.randomYAxisMaxRotation;
		if (so.nodeList != null)
		{
			nodeList = new List<Vector2>(so.nodeList);
		}
		if (so.uvs != null)
		{
			uvs = new List<float>(so.uvs);
		}
		if (so.uvDistances != null)
		{
			uvDistances = new List<float>(so.uvDistances);
		}
		clampUVs = so.clampUVs;
		clampUVY = so.clampUVY;
		clampUVYValue = so.clampUVYValue;
		terrainUVs = so.terrainUVs;
		reverseUVs = so.reverseUVs;
		totalDistance = so.totalDistance;
		if (so.snapList != null)
		{
			snapList = new List<bool>(so.snapList);
		}
		if (so.snapWeightList != null)
		{
			snapWeightList = new List<float>(so.snapWeightList);
		}
		if (so.colorList != null)
		{
			colorList = new List<Color>(so.colorList);
		}
		gameobjectStartGUID = so.gameobjectStartGUID;
		gameobjectEndGUID = so.gameobjectEndGUID;
		align = so.align;
		alignPoint = so.alignPoint;
		weld = so.weld;
		combine = so.combine;
		combineInstantiated = so.combineInstantiated;
		markerActive = so.markerActive;
		uvType = so.uvType;
		uv = so.uv;
		randomObjects = so.randomObjects;
		forwardStartOffset = so.forwardStartOffset;
		sidewaysOffset = so.sidewaysOffset;
		density = so.density;
		goPath = so.goPath;
		startPath = so.startPath;
		endPath = so.endPath;
		texturePath = so.texturePath;
		terrainTree = so.terrainTree;
		minScale = so.minScale;
		maxScale = so.maxScale;
		childOrderActive = so.childOrderActive;
		childOrder = so.childOrder;
		xPosition = so.xPosition;
		xPosition2 = so.xPosition2;
		relativeTo = so.relativeTo;
		yPosition = so.yPosition;
		yRotation = so.yRotation;
		oldSidwaysDistance = so.oldSidwaysDistance;
		sidewaysDistanceUpdate = so.sidewaysDistanceUpdate;
		uvYRound = so.uvYRound;
		adjustUV = so.adjustUV;
		collider = so.collider;
		boxcollider = so.boxcollider;
		tangents = so.tangents;
		sourceObject = so.sourceObject;
		flipMesh = so.flipMesh;
		startObject = so.startObject;
		endObject = so.endObject;
		connectionObject = so.connectionObject;
		material = so.material;
		boxSize = so.boxSize;
		boxOffset = so.boxOffset;
		includeStartSegment = so.includeStartSegment;
		startSegmentOffset = so.startSegmentOffset;
		includeStartEdgeTris = so.includeStartEdgeTris;
		includeEndSegment = so.includeEndSegment;
		endSegmentOffset = so.endSegmentOffset;
		includeEndEdgeTris = so.includeEndEdgeTris;
		startOffset = so.startOffset;
		endOffset = so.endOffset;
		defaultStartOffset = so.defaultStartOffset;
		defaultEndOffset = so.defaultEndOffset;
		totalZDistance = so.totalZDistance;
		middleZDistance = so.middleZDistance;
		startZDistance = so.startZDistance;
		endZDistance = so.endZDistance;
		minStartZ = so.minStartZ;
		maxStartZ = so.maxStartZ;
		minMiddleZ = so.minMiddleZ;
		maxMiddleZ = so.maxMiddleZ;
		minEndZ = so.minEndZ;
		maxEndZ = so.maxEndZ;
		smoothStart = so.smoothStart;
		smoothMiddle = so.smoothMiddle;
		smoothEnd = so.smoothEnd;
		adjustToRoadWidth = so.adjustToRoadWidth;
		xOffset = so.xOffset;
		layer = so.layer;
		isStatic = so.isStatic;
		bridgeObject = so.bridgeObject;
		tunnelObject = so.tunnelObject;
		snapToTerrain = so.snapToTerrain;
		deformationObject = so.deformationObject;
		scaleToRoad = so.scaleToRoad;
		splitInBatches = so.splitInBatches;
		targetObject = so.targetObject;
		meshBoundsAlignment = so.meshBoundsAlignment;
		randomRotation = so.randomRotation;
		randomMinRotation = so.randomMinRotation;
		randomMaxRotation = so.randomMaxRotation;
		minRandomRotationDistance = so.minRandomRotationDistance;
		maxRandomRotationDistance = so.maxRandomRotationDistance;
		randomXPosition = so.randomXPosition;
		randomMinXPosition = so.randomMinXPosition;
		randomMaxXPosition = so.randomMaxXPosition;
		minRandomXPositionDistance = so.minRandomXPositionDistance;
		maxRandomXPositionDistance = so.maxRandomXPositionDistance;
		boxColliderScale = so.boxColliderScale;
		randomYPosition = so.randomYPosition;
		randomMinYPosition = so.randomMinYPosition;
		randomMaxYPosition = so.randomMaxYPosition;
		minRandomYPositionDistance = so.minRandomYPositionDistance;
		maxRandomYPositionDistance = so.maxRandomYPositionDistance;
		bridgeHeight = so.bridgeHeight;
		markerSplineController = so.markerSplineController;
		bridgeLength = so.bridgeLength;
		deformationOffset = so.deformationOffset;
		markerIndent = so.markerIndent;
		markerSurrounding = so.markerSurrounding;
		indentController = so.indentController;
		excludeTerrainSplats = so.excludeTerrainSplats;
		scale = so.scale;
		indentExt = so.indentExt;
		category = so.category;
		densityMap = so.densityMap;
		densitySize = so.densitySize;
		densitySize2 = so.densitySize2;
		densityStrength = so.densityStrength;
		densityStrength2 = so.densityStrength2;
		terrainNormal = so.terrainNormal;
		terrainNormal2 = so.terrainNormal2;
		childObjects = new List<ERChildsSO>(so.childObjects);
		autoGenerate = so.autoGenerate;
		heightThreshold = so.heightThreshold;
		autogenerateStartOffset = so.autogenerateStartOffset;
		autogenerateEndOffset = so.autogenerateEndOffset;
		snapIndents = so.snapIndents;
		snapIndentWidth = so.snapIndentWidth;
		cutHoles = so.cutHoles;
		innerStartOffset = so.innerStartOffset;
		innerEndOffset = so.innerEndOffset;
		ignoredForRetainingWalls = so.ignoredForRetainingWalls;
		heightMaxThreshold = so.heightMaxThreshold;
		heightMaxStartThreshold = so.heightMaxStartThreshold;
		heightMaxEndThreshold = so.heightMaxEndThreshold;
		xThresholdDistance = so.xThresholdDistance;
		angleThreshold = so.angleThreshold;
		connectionRatio = so.connectionRatio;
		retainingWall = so.retainingWall;
		surroundingControl = so.surroundingControl;
		indentControl = so.indentControl;
		nodeListMirrored = new List<Vector2>(so.nodeListMirrored);
		uvsMirrored = new List<float>(so.uvsMirrored);
		snapWeightListMirrored = new List<float>(so.snapWeightListMirrored);
		colorListMirrored = so.colorListMirrored;
		hasVertexColors = so.hasVertexColors;
		deformationOffsetForward = so.deformationOffsetForward;
		deformationOffsetSideways = so.deformationOffsetSideways;
		connectionObjectRotation = so.connectionObjectRotation;
		subMesh = so.subMesh;
		acceptBarriers = so.acceptBarriers;
		activeOnBridges = so.activeOnBridges;
		dualSided = so.dualSided;
		mirrorType = so.mirrorType;
		snapVertexColors = so.snapVertexColors;
		minSnapRange = so.minSnapRange;
		maxSnapRange = so.maxSnapRange;
		clampUV4 = so.clampUV4;
		geoStartOffset = so.geoStartOffset;
		geoEndOffset = so.geoEndOffset;
		startOverlapOffset = so.startOverlapOffset;
		endOverlapOffset = so.endOverlapOffset;
		lodLevels = so.lodLevels;
		hardEdge = new List<bool>(so.hardEdge);
		hardEdgePadding = so.hardEdgePadding;
		startEndCaps = so.startEndCaps;
		endCapUVs = new List<Vector2>(so.endCapUVs);
		startCapUVs = new List<Vector2>(so.startCapUVs);
		startCapTris = new List<int>(so.startCapTris);
		startCapTrisMirrored = new List<int>(so.startCapTrisMirrored);
		startCapUVOffset = so.startCapUVOffset;
		endCapUVOffset = so.endCapUVOffset;
		startCapUVScale = so.startCapUVScale;
		endCapUVScale = so.endCapUVScale;
		startCapUVRotation = so.startCapUVRotation;
		endCapUVRotation = so.endCapUVRotation;
		namedChilds = so.namedChilds;
		startSection = so.startSection;
		endSection = so.endSection;
		stepDown = so.stepDown;
		stepUp = so.stepUp;
		stepDistance = so.stepDistance;
		startDirZOffset = so.startDirZOffset;
		endDirZOffset = so.endDirZOffset;
		buildOtherSideObject1 = so.buildOtherSideObject1;
		defaultOtherSoId1 = so.defaultOtherSoId1;
		buildOtherSideObject2 = so.buildOtherSideObject2;
		defaultOtherSoId2 = so.defaultOtherSoId2;
		buildOtherSideObjects = new List<double>(so.buildOtherSideObjects);
		averageDistance = so.averageDistance;
		randomUVx = so.randomUVx;
		isUsedAsChild = so.isUsedAsChild;
	}
}
[AddComponentMenu("")]
public class ERConnectionParent : MonoBehaviour
{
}
[AddComponentMenu("")]
public class ODOCDOQDCO : MonoBehaviour
{
	public static void OQQQQQODDO(ERCrossings scr, ref float firstSegmentDistance)
	{
		float cornerRadius = scr.prefabScript.sidewalkControlElements[0].cornerRadius;
		float angle = 90f / ((float)(scr.prefabScript.sidewalkControlElements[0].cornerSegments - 1) * 1f);
		float num = 0.5f * scr.frontRoadWidth;
		float num2 = 0.5f * scr.leftRoadWidth;
		List<Vector3> vecs = new List<Vector3>();
		for (int i = 0; i < scr.prefabScript.sidewalkControlElements[0].cornerSegments; i++)
		{
			Vector3 vector = OCCDQDCQCD(i, cornerRadius, angle);
			Vector3 item = new Vector3(0f - vector.x - num, 0f, vector.z - num2 - cornerRadius);
			vecs.Add(item);
		}
		OODDQCQOQQ(ref vecs, 0f, -1f, -1f, 0f);
		scr.startConnectionV3.Add(new List<Vector3>());
		scr.startConnectionV3[0].AddRange(vecs);
		cornerRadius = scr.prefabScript.sidewalkControlElements[1].cornerRadius;
		angle = 90f / ((float)(scr.prefabScript.sidewalkControlElements[1].cornerSegments - 1) * 1f);
		num = 0.5f * scr.frontRoadWidth;
		num2 = 0.5f * scr.rightRoadWidth;
		vecs.Clear();
		for (int j = 0; j < scr.prefabScript.sidewalkControlElements[1].cornerSegments; j++)
		{
			Vector3 vector = OCCDQDCQCD(j, cornerRadius, angle);
			Vector3 item = new Vector3(vector.x + num, 0f, vector.z - num2 - cornerRadius);
			vecs.Add(item);
		}
		OODDQCQOQQ(ref vecs, 0f, -1f, 1f, 0f);
		scr.startConnectionV3.Add(new List<Vector3>());
		scr.startConnectionV3[1].AddRange(vecs);
		cornerRadius = scr.prefabScript.sidewalkControlElements[3].cornerRadius;
		angle = 90f / ((float)(scr.prefabScript.sidewalkControlElements[3].cornerSegments - 1) * 1f);
		num = 0.5f * scr.backRoadWidth;
		num2 = 0.5f * scr.rightRoadWidth;
		vecs.Clear();
		for (int k = 0; k < scr.prefabScript.sidewalkControlElements[3].cornerSegments; k++)
		{
			Vector3 vector = OCCDQDCQCD(k, cornerRadius, 0f - angle);
			Vector3 item = new Vector3(vector.x + num, 0f, vector.z + num2 + cornerRadius);
			vecs.Add(item);
		}
		OODDQCQOQQ(ref vecs, 0f, 1f, 1f, 0f);
		scr.endConnectionV3.Add(new List<Vector3>());
		scr.endConnectionV3[0].AddRange(vecs);
		cornerRadius = scr.prefabScript.sidewalkControlElements[2].cornerRadius;
		angle = 90f / ((float)(scr.prefabScript.sidewalkControlElements[2].cornerSegments - 1) * 1f);
		num = 0.5f * scr.backRoadWidth;
		num2 = 0.5f * scr.leftRoadWidth;
		vecs.Clear();
		for (int l = 0; l < scr.prefabScript.sidewalkControlElements[2].cornerSegments; l++)
		{
			Vector3 vector = OCCDQDCQCD(l, cornerRadius, 0f - angle);
			Vector3 item = new Vector3(0f - vector.x - num, 0f, vector.z + num2 + cornerRadius);
			vecs.Add(item);
		}
		OODDQCQOQQ(ref vecs, 0f, 1f, -1f, 0f);
		scr.endConnectionV3.Add(new List<Vector3>());
		scr.endConnectionV3[1].AddRange(vecs);
		int num3 = Mathf.RoundToInt(Mathf.Ceil((float)scr.endConnectionV3[1].Count * 0.5f));
		vecs.Clear();
		vecs.AddRange(scr.endConnectionV3[1]);
		vecs.RemoveRange(0, num3 - 1);
		scr.leftConnectionV3.Add(new List<Vector3>());
		vecs.Reverse();
		scr.leftConnectionV3[0].AddRange(vecs);
		scr.endConnectionV3[1].RemoveRange(num3, scr.endConnectionV3[1].Count - num3);
		num3 = Mathf.RoundToInt(Mathf.Ceil((float)scr.startConnectionV3[0].Count * 0.5f));
		vecs.Clear();
		vecs.AddRange(scr.startConnectionV3[0]);
		vecs.RemoveRange(0, num3 - 1);
		scr.leftConnectionV3.Add(new List<Vector3>());
		vecs.Reverse();
		scr.leftConnectionV3[1].AddRange(vecs);
		scr.startConnectionV3[0].RemoveRange(num3, scr.startConnectionV3[0].Count - num3);
		num3 = Mathf.RoundToInt(Mathf.Ceil((float)scr.startConnectionV3[1].Count * 0.5f));
		vecs.Clear();
		vecs.AddRange(scr.startConnectionV3[1]);
		vecs.RemoveRange(0, num3 - 1);
		scr.rightConnectionV3.Add(new List<Vector3>());
		vecs.Reverse();
		scr.rightConnectionV3[0].AddRange(vecs);
		scr.startConnectionV3[1].RemoveRange(num3, scr.startConnectionV3[1].Count - num3);
		num3 = Mathf.RoundToInt(Mathf.Ceil((float)scr.endConnectionV3[0].Count * 0.5f));
		vecs.Clear();
		vecs.AddRange(scr.endConnectionV3[0]);
		vecs.RemoveRange(0, num3 - 1);
		scr.rightConnectionV3.Add(new List<Vector3>());
		vecs.Reverse();
		scr.rightConnectionV3[1].AddRange(vecs);
		scr.endConnectionV3[0].RemoveRange(num3, scr.endConnectionV3[0].Count - num3);
	}

	public static void OODDQCQOQQ(ref List<Vector3> vecs, float firstX, float firstZ, float lastX, float lastZ)
	{
		float num = Vector3.Distance(vecs[0], vecs[1]);
		vecs.Insert(0, vecs[0] + new Vector3(firstX, 0f, firstZ).normalized * num);
		vecs.Add(vecs[vecs.Count - 1] + new Vector3(lastX, 0f, lastZ).normalized * num);
	}

	public static Vector3 OCCDQDCQCD(int i, float radius, float angle)
	{
		return ERRoundabouts.OQDDDODCOC(Vector3.zero, new Vector3(radius, 0f, 0f), Quaternion.Euler(0f, angle * (float)i, 0f));
	}

	public static void OQODOQQCOO(ERCrossings scr)
	{
		float num = scr.prefabScript.sidewalkControlElements[0].cornerRadius + Vector3.Distance(scr.startConnectionV3[0][0], scr.startConnectionV3[0][1]);
		if (scr.prefabScript.sidewalkControlElements[0].sidewalkWidth1 > num)
		{
			ODOODDOQOQ(scr.startConnectionV3[0], 0f, -1f, scr.prefabScript.sidewalkControlElements[0].sidewalkWidth1, 1f, num);
			ODOODDOQOQ(scr.leftConnectionV3[1], -1f, 0f, scr.prefabScript.sidewalkControlElements[0].sidewalkWidth1, 1f, num);
		}
		num = scr.prefabScript.sidewalkControlElements[1].cornerRadius + Vector3.Distance(scr.startConnectionV3[1][0], scr.startConnectionV3[1][1]);
		if (scr.prefabScript.sidewalkControlElements[1].sidewalkWidth1 > num)
		{
			ODOODDOQOQ(scr.startConnectionV3[1], 0f, -1f, scr.prefabScript.sidewalkControlElements[1].sidewalkWidth1, 1f, num);
			ODOODDOQOQ(scr.rightConnectionV3[0], 1f, 0f, scr.prefabScript.sidewalkControlElements[1].sidewalkWidth1, 1f, num);
		}
		num = scr.prefabScript.sidewalkControlElements[3].cornerRadius + Vector3.Distance(scr.endConnectionV3[0][0], scr.endConnectionV3[0][1]);
		if (scr.prefabScript.sidewalkControlElements[3].sidewalkWidth1 > num)
		{
			ODOODDOQOQ(scr.endConnectionV3[0], 0f, 1f, scr.prefabScript.sidewalkControlElements[3].sidewalkWidth1, 1f, num);
			ODOODDOQOQ(scr.rightConnectionV3[1], 1f, 0f, scr.prefabScript.sidewalkControlElements[3].sidewalkWidth1, 1f, num);
		}
		num = scr.prefabScript.sidewalkControlElements[2].cornerRadius + Vector3.Distance(scr.endConnectionV3[1][0], scr.endConnectionV3[1][1]);
		if (scr.prefabScript.sidewalkControlElements[2].sidewalkWidth1 > num)
		{
			ODOODDOQOQ(scr.endConnectionV3[1], 0f, 1f, scr.prefabScript.sidewalkControlElements[2].sidewalkWidth1, 1f, num);
			ODOODDOQOQ(scr.leftConnectionV3[0], -1f, 0f, scr.prefabScript.sidewalkControlElements[2].sidewalkWidth1, 1f, num);
		}
	}

	public static void ODOODDOQOQ(List<Vector3> vecs, float firstX, float firstZ, float sidewalkWidth, float resolution, float currentDist)
	{
		Vector3 normalized = new Vector3(firstX, 0f, firstZ).normalized;
		float num = 0f;
		bool flag = false;
		while (!flag)
		{
			if (currentDist + resolution < sidewalkWidth)
			{
				num = resolution;
			}
			else if (currentDist == sidewalkWidth)
			{
				num = resolution;
				flag = true;
			}
			else if (currentDist + resolution > sidewalkWidth)
			{
				num = sidewalkWidth - currentDist;
			}
			Vector3 vector = vecs[0] + normalized * num;
			if (Vector3.Distance(vector, vecs[0]) < 0.25f * resolution)
			{
				vecs[0] = vector;
			}
			else
			{
				vecs.Insert(0, vector);
			}
			currentDist += num;
		}
	}

	public static void OOOCDOCQQO(ERCrossings scr)
	{
		if (scr.startConnectionV3[0][0].z != scr.startConnectionV3[1][0].z)
		{
			if (scr.startConnectionV3[0][0].z > scr.startConnectionV3[1][0].z)
			{
				OOOCOQODOO(scr.startConnectionV3[0], scr.startConnectionV3[1][0].z, 0f, -1f, 1f, 1);
			}
			else
			{
				OOOCOQODOO(scr.startConnectionV3[1], scr.startConnectionV3[0][0].z, 0f, -1f, 1f, 1);
			}
		}
		if (scr.endConnectionV3[0][0].z != scr.endConnectionV3[1][0].z)
		{
			if (scr.endConnectionV3[0][0].z < scr.endConnectionV3[1][0].z)
			{
				OOOCOQODOO(scr.endConnectionV3[0], scr.endConnectionV3[1][0].z, 0f, 1f, 1f, 1);
			}
			else
			{
				OOOCOQODOO(scr.endConnectionV3[1], scr.endConnectionV3[0][0].z, 0f, 1f, 1f, 1);
			}
		}
		if (scr.leftConnectionV3[0][0].x != scr.leftConnectionV3[1][0].x)
		{
			if (scr.leftConnectionV3[0][0].x > scr.leftConnectionV3[1][0].x)
			{
				OOOCOQODOO(scr.leftConnectionV3[0], scr.leftConnectionV3[1][0].x, -1f, 0f, 1f, 0);
			}
			else
			{
				OOOCOQODOO(scr.leftConnectionV3[1], scr.leftConnectionV3[0][0].x, -1f, 0f, 1f, 0);
			}
		}
		if (scr.rightConnectionV3[0][0].x != scr.rightConnectionV3[1][0].x)
		{
			if (scr.rightConnectionV3[0][0].x < scr.rightConnectionV3[1][0].x)
			{
				OOOCOQODOO(scr.rightConnectionV3[0], scr.rightConnectionV3[1][0].x, 1f, 0f, 1f, 0);
			}
			else
			{
				OOOCOQODOO(scr.rightConnectionV3[1], scr.rightConnectionV3[0][0].x, 1f, 0f, 1f, 0);
			}
		}
	}

	public static void OOOCOQODOO(List<Vector3> targetVecs, float targetValue, float firstX, float firstZ, float resolution, int xorz)
	{
		bool flag = false;
		while (!flag)
		{
			Vector3 item = targetVecs[0];
			if (xorz == 0)
			{
				item.x += resolution * firstX;
				if (firstX < 0f)
				{
					if (item.x <= targetValue)
					{
						item.x = targetValue;
						flag = true;
					}
				}
				else if (item.x >= targetValue)
				{
					item.x = targetValue;
					flag = true;
				}
			}
			else
			{
				item.z += resolution * firstZ;
				if (firstZ < 0f)
				{
					if (item.z <= targetValue)
					{
						item.z = targetValue;
						flag = true;
					}
				}
				else if (item.z >= targetValue)
				{
					item.z = targetValue;
					flag = true;
				}
			}
			targetVecs.Insert(0, item);
		}
	}

	public static void OCOOOQQQQO(ERCrossings scr)
	{
		float innerSegmentDistance = scr.prefabScript.sidewalkControlElements[0].innerSegmentDistance;
		scr.startConnectionV3.Insert(1, OOOCCCCDDQ(scr.startConnectionV3[0], 1f, innerSegmentDistance));
		innerSegmentDistance = scr.prefabScript.sidewalkControlElements[1].innerSegmentDistance;
		scr.startConnectionV3.Insert(2, OOOCCCCDDQ(scr.startConnectionV3[2], -1f, innerSegmentDistance));
		innerSegmentDistance = scr.prefabScript.sidewalkControlElements[3].innerSegmentDistance;
		scr.endConnectionV3.Insert(1, OOOCCCCDDQ(scr.endConnectionV3[0], 1f, innerSegmentDistance));
		innerSegmentDistance = scr.prefabScript.sidewalkControlElements[2].innerSegmentDistance;
		scr.endConnectionV3.Insert(2, OOOCCCCDDQ(scr.endConnectionV3[2], -1f, innerSegmentDistance));
		innerSegmentDistance = scr.prefabScript.sidewalkControlElements[2].innerSegmentDistance;
		scr.leftConnectionV3.Insert(1, OOOCCCCDDQ(scr.leftConnectionV3[0], 1f, innerSegmentDistance));
		innerSegmentDistance = scr.prefabScript.sidewalkControlElements[0].innerSegmentDistance;
		scr.leftConnectionV3.Insert(2, OOOCCCCDDQ(scr.leftConnectionV3[2], -1f, innerSegmentDistance));
		innerSegmentDistance = scr.prefabScript.sidewalkControlElements[1].innerSegmentDistance;
		scr.rightConnectionV3.Insert(1, OOOCCCCDDQ(scr.rightConnectionV3[0], 1f, innerSegmentDistance));
		innerSegmentDistance = scr.prefabScript.sidewalkControlElements[3].innerSegmentDistance;
		scr.rightConnectionV3.Insert(2, OOOCCCCDDQ(scr.rightConnectionV3[2], -1f, innerSegmentDistance));
	}

	public static List<Vector3> OOOCCCCDDQ(List<Vector3> sourceVecs, float leftRight, float distance)
	{
		List<Vector3> list = new List<Vector3>();
		Vector3 zero = Vector3.zero;
		for (int i = 0; i < sourceVecs.Count; i++)
		{
			if (i == 0)
			{
				zero = sourceVecs[i + 1] - sourceVecs[i];
				zero = new Vector3(zero.z, 0f, 0f - zero.x).normalized * leftRight;
			}
			else if (i == sourceVecs.Count - 1)
			{
				zero = (Vector3.zero - sourceVecs[i]).normalized;
			}
			else
			{
				zero = sourceVecs[i + 1] - sourceVecs[i - 1];
				zero = new Vector3(zero.z, 0f, 0f - zero.x).normalized * leftRight;
			}
			list.Add(sourceVecs[i] + zero * distance);
		}
		return list;
	}

	public static void OOCCOQQDQQ(ERCrossings scr)
	{
		if (scr.startConnectionV3[0].Count > scr.startConnectionV3[3].Count)
		{
			scr.startConnectionV3.Insert(2, OOOODDQDCC(scr.startConnectionV3[1], 1));
		}
		else
		{
			scr.startConnectionV3.Insert(2, OOOODDQDCC(scr.startConnectionV3[2], 1));
		}
		if (scr.endConnectionV3[0].Count > scr.endConnectionV3[3].Count)
		{
			scr.endConnectionV3.Insert(2, OOOODDQDCC(scr.endConnectionV3[1], 1));
		}
		else
		{
			scr.endConnectionV3.Insert(2, OOOODDQDCC(scr.endConnectionV3[2], 1));
		}
		if (scr.leftConnectionV3[0].Count > scr.leftConnectionV3[3].Count)
		{
			scr.leftConnectionV3.Insert(2, OOOODDQDCC(scr.leftConnectionV3[1], 0));
		}
		else
		{
			scr.leftConnectionV3.Insert(2, OOOODDQDCC(scr.leftConnectionV3[2], 0));
		}
		if (scr.rightConnectionV3[0].Count > scr.rightConnectionV3[3].Count)
		{
			scr.rightConnectionV3.Insert(2, OOOODDQDCC(scr.rightConnectionV3[1], 0));
		}
		else
		{
			scr.rightConnectionV3.Insert(2, OOOODDQDCC(scr.rightConnectionV3[2], 0));
		}
	}

	public static List<Vector3> OOOODDQDCC(List<Vector3> sourceVecs, int xorz)
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < sourceVecs.Count; i++)
		{
			if (xorz == 0)
			{
				list.Add(new Vector3(sourceVecs[i].x, 0f, 0f));
			}
			else
			{
				list.Add(new Vector3(0f, 0f, sourceVecs[i].z));
			}
		}
		return list;
	}
}
[AddComponentMenu("")]
public class ERCrossingMainRoad : MonoBehaviour
{
	public ERModularBase baseScript;

	public double roadType1;

	public int roadTypeInt1 = 0;

	public double roadType2;

	public int roadTypeInt2 = 0;

	public double roadType3;

	public int roadTypeInt3 = 0;

	public float indent1 = 0f;

	public float indent2 = 0f;

	public float roadWidth1 = 8f;

	public float roadWidth2 = 6f;

	public float roadWidth3 = 5f;

	public bool tCrossing = true;

	public List<Vector3> leftOuter1 = new List<Vector3>();

	public List<Vector3> rightOuter1 = new List<Vector3>();

	public List<Vector2> leftOuterUV1 = new List<Vector2>();

	public List<Vector2> rightOuterUV1 = new List<Vector2>();

	public List<Vector3> leftOuter2 = new List<Vector3>();

	public List<Vector3> rightOuter2 = new List<Vector3>();

	public List<Vector2> leftOuterUV2 = new List<Vector2>();

	public List<Vector2> rightOuterUV2 = new List<Vector2>();

	public List<Vector3> leftOuter3 = new List<Vector3>();

	public List<Vector3> rightOuter3 = new List<Vector3>();

	public List<Vector2> leftOuterUV3 = new List<Vector2>();

	public List<Vector2> rightOuterUV3 = new List<Vector2>();

	public Material sourceMaterial;

	public Material sourceMaterial1;

	public Material targetMaterial;

	public float bottom2 = 0f;

	public float bottom2Inner = 0f;

	public float bottom3 = 0f;

	public float bottom3Inner = 0f;

	public float top2 = 0f;

	public float top2Inner = 0f;

	public float top3 = 0f;

	public float top3Inner = 0f;

	public float left2 = 0f;

	public float left3 = 0f;

	public float right2 = 0f;

	public float right3 = 0f;

	public int vec2Count = 0;

	public int vec3Count = 0;

	public float uvStart1 = 0f;

	public float uvEnd1 = 0f;

	public float uvStart2 = 0f;

	public float uvEnd2 = 0f;

	public Vector2 rightTopL;

	public Vector2 rightTopR;

	public Vector2 rightBottomL;

	public Vector2 rightBottomR;

	public Vector2 leftTopL;

	public Vector2 leftTopR;

	public Vector2 leftBottomL;

	public Vector2 leftBottomR;

	public float rightLeftUV;

	public float rightRightUV;

	public float leftLeftUV;

	public float leftRightUV;

	public float bottomuvInner2 = 0f;

	public float topuvInner2 = 0f;

	public float innerHeight2 = 0f;

	public float outerHeight2 = 0f;

	public float bottomuvInner3 = 0f;

	public float topuvInner3 = 0f;

	public float innerHeight3 = 0f;

	public float outerHeight3 = 0f;

	public float rightInnerStretch = 0.25f;

	public float leftInnerStretch = 0.25f;

	public Material mat1;

	public Material mat2;

	public Material mat3;

	public new string name = "";

	public void OCQOQCDCQC()
	{
		Clear();
		if (roadTypeInt1 > 0)
		{
			roadType1 = baseScript.roadTypes[roadTypeInt1 - 1].id;
		}
		if (roadTypeInt2 > 0)
		{
			roadType2 = baseScript.roadTypes[roadTypeInt2 - 1].id;
		}
		if (roadTypeInt3 > 0)
		{
			roadType3 = baseScript.roadTypes[roadTypeInt3 - 1].id;
		}
		if (roadTypeInt1 == 0)
		{
			return;
		}
		mat1 = (mat2 = (mat3 = null));
		if (roadTypeInt1 > 0)
		{
			mat1 = baseScript.roadTypes[roadTypeInt1 - 1].roadMaterial;
		}
		if (roadTypeInt2 > 0)
		{
			mat2 = baseScript.roadTypes[roadTypeInt2 - 1].roadMaterial;
		}
		if (roadTypeInt3 > 0)
		{
			mat3 = baseScript.roadTypes[roadTypeInt3 - 1].roadMaterial;
		}
		if (roadTypeInt1 > 0)
		{
			roadWidth1 = baseScript.roadTypes[roadTypeInt1 - 1].roadWidth;
		}
		if (roadTypeInt2 > 0)
		{
			roadWidth2 = baseScript.roadTypes[roadTypeInt2 - 1].roadWidth;
		}
		if (roadTypeInt3 > 0)
		{
			roadWidth3 = baseScript.roadTypes[roadTypeInt3 - 1].roadWidth;
		}
		float faceDistance = baseScript.roadTypes[roadTypeInt1 - 1].faceDistance;
		float num = 1f;
		float num2 = 1f;
		float num3 = 1f;
		if (base.gameObject.GetComponent<MeshFilter>() == null)
		{
			base.gameObject.AddComponent<MeshFilter>();
		}
		if (base.gameObject.GetComponent<MeshRenderer>() == null)
		{
			base.gameObject.AddComponent<MeshRenderer>();
		}
		float num4 = Mathf.Ceil(roadWidth1 / faceDistance);
		float num5 = roadWidth1 / num4;
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		List<Vector3> list3 = new List<Vector3>();
		List<Vector2> list4 = new List<Vector2>();
		float num6 = -0.5f * roadWidth1;
		for (int i = 0; (float)i <= num4; i++)
		{
			list.Add(new Vector3(-0.5f * roadWidth1, 0f, num6 + (float)i * num5));
			list2.Add(new Vector2(0f, (float)i / num4));
			list3.Add(new Vector3(0.5f * roadWidth1, 0f, num6 + (float)i * num5));
			list4.Add(new Vector2(1f, (float)i / num4));
		}
		if (roadTypeInt2 != 0)
		{
			float num7 = (roadWidth1 - roadWidth2) * 0.5f;
			float num8 = (roadWidth1 - roadWidth2 - 2f * rightInnerStretch) * 0.5f;
			bool flag = false;
			bool flag2 = false;
			float x = 1f - indent1 / roadWidth1;
			float num9 = num7 / roadWidth1;
			bottomuvInner2 = num8 / roadWidth1;
			float y = 1f - num9;
			topuvInner2 = 1f - bottomuvInner2;
			innerHeight2 = 0f - num6 - num7 + rightInnerStretch - (num6 + num7 - rightInnerStretch);
			outerHeight2 = 0f - num6 - num7 - (num6 + num7);
			bottom2 = num6 + num7;
			bottom2Inner = num6 + num7 - rightInnerStretch;
			top2 = 0f - num6 - num7;
			top2Inner = 0f - num6 - num7 + rightInnerStretch;
			left2 = 0.5f * roadWidth1 - indent1;
			right2 = 0.5f * roadWidth1;
			int num10 = 0;
			for (int j = 0; (float)j <= num4; j++)
			{
				if (list3[j].z > num6 + num7 && !flag)
				{
					rightOuter1.Add(new Vector3(0.5f * roadWidth1, 0f, num6 + num7));
					if (indent1 > 0f)
					{
						rightOuter1.Add(new Vector3(0.5f * roadWidth1 - indent1, 0f, num6 + num7 - rightInnerStretch));
					}
					rightOuterUV1.Add(new Vector2(1f, num9));
					if (indent1 > 0f)
					{
						rightOuterUV1.Add(new Vector2(x, bottomuvInner2));
					}
					if (indent1 > 0f)
					{
						leftOuter2.Add(new Vector3(0.5f * roadWidth1, 0f, num6 + num7));
					}
					if (indent1 > 0f)
					{
						leftOuter2.Add(new Vector3(0.5f * roadWidth1 - indent1, 0f, num6 + num7 - rightInnerStretch));
					}
					flag = true;
				}
				if (list3[j].z > 0f - num6 - num7 && !flag2)
				{
					if (indent1 > 0f)
					{
						rightOuter1.Add(new Vector3(0.5f * roadWidth1 - indent1, 0f, 0f - num6 - num7 + rightInnerStretch));
					}
					rightOuter1.Add(new Vector3(0.5f * roadWidth1, 0f, 0f - num6 - num7));
					if (indent1 > 0f)
					{
						rightOuterUV1.Add(new Vector2(x, topuvInner2));
					}
					rightOuterUV1.Add(new Vector2(1f, y));
					if (indent1 > 0f)
					{
						rightOuter2.Add(new Vector3(0.5f * roadWidth1, 0f, 0f - num6 - num7));
					}
					if (indent1 > 0f)
					{
						rightOuter2.Add(new Vector3(0.5f * roadWidth1 - indent1, 0f, 0f - num6 - num7 + rightInnerStretch));
					}
					flag2 = true;
				}
				if (flag && !flag2)
				{
					Vector3 value = list3[j];
					value.x -= indent1;
					list3[j] = value;
					Vector2 value2 = list4[j];
					value2.x = x;
					list4[j] = value2;
				}
				if (indent1 > 0f || !flag || (flag && flag2))
				{
					rightOuter1.Add(list3[j]);
					rightOuterUV1.Add(list4[j]);
				}
			}
		}
		if (roadTypeInt3 != 0)
		{
			float num11 = (roadWidth1 - roadWidth3) * 0.5f;
			float num12 = (roadWidth1 - roadWidth3 - 2f * leftInnerStretch) * 0.5f;
			bool flag3 = false;
			bool flag4 = false;
			float x2 = indent2 / roadWidth1;
			float num13 = num11 / roadWidth1;
			bottomuvInner3 = num12 / roadWidth1;
			float y2 = 1f - num13;
			topuvInner3 = 1f - bottomuvInner3;
			innerHeight3 = 0f - num6 - num11 + leftInnerStretch - (num6 + num11 - leftInnerStretch);
			outerHeight3 = 0f - num6 - num11 - (num6 + num11);
			bottom3 = num6 + num11;
			bottom3Inner = num6 + num11 - leftInnerStretch;
			top3 = 0f - num6 - num11;
			top3Inner = 0f - num6 - num11 + leftInnerStretch;
			left3 = -0.5f * roadWidth1;
			right3 = -0.5f * roadWidth1 + indent2;
			int num14 = 0;
			for (int k = 0; (float)k <= num4; k++)
			{
				if (list[k].z > num6 + num11 && !flag3)
				{
					leftOuter1.Add(new Vector3(-0.5f * roadWidth1, 0f, num6 + num11));
					if (indent2 > 0f)
					{
						leftOuter1.Add(new Vector3(-0.5f * roadWidth1 + indent2, 0f, num6 + num11 - leftInnerStretch));
					}
					leftOuterUV1.Add(new Vector2(0f, num13));
					if (indent2 > 0f)
					{
						leftOuterUV1.Add(new Vector2(x2, bottomuvInner3));
					}
					if (indent2 > 0f)
					{
						rightOuter3.Add(new Vector3(-0.5f * roadWidth1, 0f, num6 + num11));
					}
					if (indent2 > 0f)
					{
						rightOuter3.Add(new Vector3(-0.5f * roadWidth1 + indent2, 0f, num6 + num11 - leftInnerStretch));
					}
					flag3 = true;
				}
				if (list[k].z > 0f - num6 - num11 && !flag4)
				{
					if (indent2 > 0f)
					{
						leftOuter1.Add(new Vector3(-0.5f * roadWidth1 + indent2, 0f, 0f - num6 - num11 + leftInnerStretch));
					}
					leftOuter1.Add(new Vector3(-0.5f * roadWidth1, 0f, 0f - num6 - num11));
					if (indent2 > 0f)
					{
						leftOuterUV1.Add(new Vector2(x2, topuvInner3));
					}
					leftOuterUV1.Add(new Vector2(0f, y2));
					if (indent2 > 0f)
					{
						leftOuter3.Add(new Vector3(-0.5f * roadWidth1, 0f, 0f - num6 - num11));
					}
					if (indent2 > 0f)
					{
						leftOuter3.Add(new Vector3(-0.5f * roadWidth1 + indent2, 0f, 0f - num6 - num11 + leftInnerStretch));
					}
					flag4 = true;
				}
				if (flag3 && !flag4)
				{
					Vector3 value3 = list[k];
					value3.x += indent2;
					list[k] = value3;
					Vector2 value4 = list2[k];
					value4.x = x2;
					list2[k] = value4;
				}
				if (indent2 > 0f || !flag3 || (flag3 && flag4))
				{
					leftOuter1.Add(list[k]);
					leftOuterUV1.Add(list2[k]);
				}
			}
		}
		if (roadTypeInt2 == 0)
		{
			rightOuter1 = new List<Vector3>(list3);
			rightOuterUV1 = new List<Vector2>(list4);
		}
		if (roadTypeInt3 == 0)
		{
			leftOuter1 = new List<Vector3>(list);
			leftOuterUV1 = new List<Vector2>(list2);
		}
		List<Vector3> list5 = new List<Vector3>();
		list5.AddRange(leftOuter1);
		list5.Reverse();
		list5.AddRange(rightOuter1);
		List<Vector2> list6 = new List<Vector2>();
		list6.AddRange(leftOuterUV1);
		list6.Reverse();
		list6.AddRange(rightOuterUV1);
		List<int> list7 = Triangulate(list5, list5);
		List<int> list8 = new List<int>();
		List<int> list9 = new List<int>();
		vec2Count = 0;
		vec3Count = 0;
		vec2Count = list5.Count;
		if (indent1 > 0f && roadTypeInt2 != 0)
		{
			leftOuterUV2.Add(new Vector2(0f, 1f));
			leftOuterUV2.Add(new Vector2(0f, 1f + indent1 / roadWidth2));
			rightOuterUV2.Add(new Vector2(1f, 1f));
			rightOuterUV2.Add(new Vector2(1f, 1f + indent1 / roadWidth2));
			list5.AddRange(leftOuter2);
			list5.AddRange(rightOuter2);
			list6.AddRange(leftOuterUV2);
			list6.AddRange(rightOuterUV2);
			list8.Add(vec2Count);
			list8.Add(vec2Count + 1);
			list8.Add(vec2Count + 3);
			list8.Add(vec2Count);
			list8.Add(vec2Count + 3);
			list8.Add(vec2Count + 2);
		}
		vec3Count = list5.Count;
		if (indent2 > 0f)
		{
			leftOuterUV3.Add(new Vector2(0f, 1f));
			leftOuterUV3.Add(new Vector2(0f, 1f + indent2 / roadWidth3));
			rightOuterUV3.Add(new Vector2(1f, 1f));
			rightOuterUV3.Add(new Vector2(1f, 1f + indent2 / roadWidth3));
			list5.AddRange(leftOuter3);
			list5.AddRange(rightOuter3);
			list6.AddRange(leftOuterUV3);
			list6.AddRange(rightOuterUV3);
			list9.Add(vec3Count);
			list9.Add(vec3Count + 1);
			list9.Add(vec3Count + 3);
			list9.Add(vec3Count);
			list9.Add(vec3Count + 3);
			list9.Add(vec3Count + 2);
		}
		Mesh mesh = base.gameObject.GetComponent<MeshFilter>().sharedMesh;
		if (mesh == null)
		{
			mesh = new Mesh();
			base.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
		}
		mesh.Clear();
		if (indent2 > 0f && indent1 > 0f && roadTypeInt2 != 0 && roadTypeInt3 != 0)
		{
			mesh.subMeshCount = 3;
		}
		else if (indent2 > 0f && roadTypeInt3 != 0)
		{
			mesh.subMeshCount = 2;
		}
		else if (indent1 > 0f && roadTypeInt2 != 0)
		{
			mesh.subMeshCount = 2;
		}
		else
		{
			mesh.subMeshCount = 1;
		}
		mesh.vertices = list5.ToArray();
		mesh.uv = list6.ToArray();
		mesh.SetTriangles(list7.ToArray(), 0);
		if (indent1 > 0f && roadTypeInt2 != 0)
		{
			mesh.SetTriangles(list8.ToArray(), 1);
		}
		if (indent2 > 0f && indent1 > 0f && roadTypeInt2 != 0 && roadTypeInt3 != 0)
		{
			mesh.SetTriangles(list9.ToArray(), 2);
		}
		else if (indent2 > 0f && roadTypeInt3 != 0)
		{
			mesh.SetTriangles(list9.ToArray(), 1);
		}
		List<Material> list10 = new List<Material>();
		list10.Add(mat1);
		if (indent1 > 0f && roadTypeInt2 != 0)
		{
			list10.Add(targetMaterial);
		}
		if (indent2 > 0f && roadTypeInt3 != 0)
		{
			list10.Add(targetMaterial);
		}
		base.gameObject.GetComponent<MeshRenderer>().sharedMaterials = list10.ToArray();
		mesh.RecalculateNormals();
		ODCCODOCQQ.OCDCQCOQQO(mesh);
	}

	public void Clear()
	{
		leftOuter1.Clear();
		rightOuter1.Clear();
		leftOuterUV1.Clear();
		rightOuterUV1.Clear();
		leftOuter2.Clear();
		rightOuter2.Clear();
		leftOuterUV2.Clear();
		rightOuterUV2.Clear();
		leftOuter3.Clear();
		rightOuter3.Clear();
		leftOuterUV3.Clear();
		rightOuterUV3.Clear();
	}

	private List<int> Triangulate(List<Vector3> vecs, List<Vector3> edges)
	{
		List<Vector2> list = new List<Vector2>();
		List<PointER> list2 = new List<PointER>();
		for (int i = 0; i < vecs.Count; i++)
		{
			Vector3 vector = vecs[i];
			list2.Add(new PointER(vector.x, vector.z, 0f));
		}
		for (int j = 0; j < edges.Count; j++)
		{
			Vector3 vector = edges[j];
			list.Add(new Vector2(vector.x, vector.z));
		}
		List<int> list3 = new List<int>();
		List<int> list4 = new List<int>();
		List<TriangleER> list5 = delaunayER.Triangulate(list2);
		for (int k = 0; k < list5.Count; k++)
		{
			list3.Add(delaunayER.FindVertice(new Vector3(list5[k].Vertex1.x, list5[k].Vertex1.z, list5[k].Vertex1.y), vecs));
			list3.Add(delaunayER.FindVertice(new Vector3(list5[k].Vertex3.x, list5[k].Vertex3.z, list5[k].Vertex3.y), vecs));
			list3.Add(delaunayER.FindVertice(new Vector3(list5[k].Vertex2.x, list5[k].Vertex2.z, list5[k].Vertex2.y), vecs));
		}
		for (int l = 0; l < list3.Count; l += 3)
		{
			if (list.Count == 0)
			{
				list4.Add(list3[l]);
				list4.Add(list3[l + 1]);
				list4.Add(list3[l + 2]);
				continue;
			}
			Vector3 vector2 = (vecs[list3[l]] + vecs[list3[l + 1]] + vecs[list3[l + 2]]) / 3f;
			if (ODDCQDDCDD.OCCQDQQDCC(list.Count, list, vector2.x, vector2.z))
			{
				list4.Add(list3[l]);
				list4.Add(list3[l + 1]);
				list4.Add(list3[l + 2]);
			}
		}
		return list4;
	}
}
[AddComponentMenu("")]
public class ODDCQDDCDD : MonoBehaviour
{
	public class OOCOCQCQOQ
	{
		public int start;

		public int end;

		public OOCOCQCQOQ(int startV3, int endV3)
		{
			start = startV3;
			end = endV3;
		}
	}

	public static void ODQQCQOODQ(List<ERRoundaboutElement> connections, List<Vector3> mainLeftPoints, ref List<Vector3> meshVecs, ref List<Vector2> meshUVs, ref List<int> fullTris)
	{
		int num = 0;
		int num2 = 10000000;
		int num3 = 10000000;
		bool flag = true;
		if (connections.Count > 0)
		{
			num2 = connections[num].leftOuterInt;
			num3 = connections[num].rightOuterInt;
		}
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		List<int> list3 = new List<int>();
		int count = mainLeftPoints.Count;
		int num4 = 3;
		int num5 = 0;
		int num6 = 1;
		int num7 = 0;
		for (int i = 0; i < count - num6; i += num6)
		{
			flag = ((i != num2 && i != num3 - 1) ? true : false);
			for (int j = 0; j < num4 - 1; j++)
			{
				if (j != 0 || flag)
				{
					fullTris.Add(i * num4 + j);
					fullTris.Add((i + num6) * num4 + j + 1);
					fullTris.Add(i * num4 + j + 1);
					fullTris.Add((i + num6) * num4 + j);
					fullTris.Add((i + num6) * num4 + j + 1);
					fullTris.Add(i * num4 + j);
					num5 += 6;
				}
			}
			num7 = fullTris.Count - 6 * num4;
			if (i == num2)
			{
				Vector3 p = meshVecs[fullTris[num7 + 3]];
				Vector3 p2 = meshVecs[fullTris[num7 + 3] + num4];
				Vector3 vector = connections[num].leftOuterSegments[0];
				Vector2 uv = meshUVs[fullTris[num7 + 3]];
				Vector2 uv2 = meshUVs[fullTris[num7 + 3] + num4];
				Vector2 item = SetUV(p, p2, vector, uv, uv2);
				list.Add(vector);
				list2.Add(item);
				list3.Add(fullTris[num7 + 3]);
				list3.Add(fullTris[num7 + 4]);
				list3.Add(fullTris[num7 + 3] + num4);
				list3.Add(fullTris[num7 + 4] + num4);
			}
			if (i == num3 - 1)
			{
				Vector3 p = meshVecs[fullTris[num7 + 3]];
				Vector3 p2 = meshVecs[fullTris[num7 + 3] + num4];
				Vector3 vector = connections[num].rightOuterSegments[0];
				Vector2 uv = meshUVs[fullTris[num7 + 3]];
				Vector2 uv2 = meshUVs[fullTris[num7 + 3] + num4];
				Vector2 item = SetUV(p, p2, vector, uv, uv2);
				list.Add(vector);
				list2.Add(item);
				list3.Add(fullTris[num7 + 3]);
				list3.Add(fullTris[num7 + 4]);
				list3.Add(fullTris[num7 + 3] + num4);
				list3.Add(fullTris[num7 + 4] + num4);
				num++;
				if (connections.Count > num)
				{
					num2 = connections[num].leftOuterInt;
					num3 = connections[num].rightOuterInt;
				}
				else
				{
					num2 = 10000000;
					num3 = 10000000;
				}
			}
		}
		int num8 = 0;
		for (int k = 0; k < list.Count; k++)
		{
			meshVecs.Add(list[k]);
			meshUVs.Add(list2[k]);
			num8 = meshVecs.Count - 1;
			fullTris.Add(list3[k * 4]);
			fullTris.Add(num8);
			fullTris.Add(list3[k * 4 + 1]);
			fullTris.Add(num8);
			fullTris.Add(list3[k * 4 + 3]);
			fullTris.Add(list3[k * 4 + 1]);
			fullTris.Add(num8);
			fullTris.Add(list3[k * 4 + 2]);
			fullTris.Add(list3[k * 4 + 3]);
		}
	}

	public static void OODQCCOOQC(List<ERRoundaboutElement> connections, List<Vector3> meshVecs, int vecCount, ref List<Vector3> connectionVecs, ref List<Vector2> connectionUVs, ref List<int> connectionTris, ref List<List<int>> triList, ref List<Material> materialList)
	{
		Vector3 vA;
		Vector3 vB;
		Vector3 vector = (vA = (vB = Vector3.zero));
		float num = 0f;
		int index = 0;
		for (int i = 0; i < connections.Count; i++)
		{
			if (!connections[i].leftFlag || !connections[i].rightFlag)
			{
				continue;
			}
			List<Vector3> list = new List<Vector3>();
			List<Vector2> list2 = new List<Vector2>();
			List<PointER> list3 = new List<PointER>();
			List<int> list4 = new List<int>();
			List<Vector3> list5 = new List<Vector3>();
			List<Vector2> list6 = new List<Vector2>();
			List<float> list7 = new List<float>();
			List<float> list8 = new List<float>();
			List<Vector2> list9 = new List<Vector2>();
			List<int> list10 = new List<int>();
			List<Vector2> roadShapeVecs = new List<Vector2>();
			List<float> roadShapeUVY = new List<float>();
			connections[i].blendCornerPointInts.Clear();
			connections[i].blendCornerPointWeights.Clear();
			if (connections[i].blendFlag)
			{
				vector = connections[i].rightOuterSegments[connections[i].rightOuterSegments.Count - 1];
				Vector3 vector2 = connections[i].leftOuterSegments[connections[i].leftOuterSegments.Count - 1];
				vA = connections[i].leftOuterSegments[0];
				vB = connections[i].rightOuterSegments[0];
				Vector3 b = OQQCQOCCOQ(vA, vB, vector2);
				num = Vector3.Distance(vector2, b);
			}
			bool flag = false;
			for (int j = 0; j < materialList.Count; j++)
			{
				if (materialList[j] == connections[i].connectionMaterial)
				{
					index = j;
					flag = true;
				}
			}
			if (!flag)
			{
				materialList.Add(connections[i].connectionMaterial);
				triList.Add(new List<int>());
				index = triList.Count - 1;
			}
			list5.Clear();
			list5.AddRange(connections[i].leftOuterSegments);
			list6.Clear();
			list6.AddRange(connections[i].leftOuterSegmentsUVs);
			for (int k = 0; k < list5.Count; k++)
			{
				Vector3 vector3 = list5[k];
				list.Add(vector3);
				list3.Add(new PointER(vector3.x, vector3.z, 0f));
				list2.Add(list6[k]);
				list7.Add(vector3.x);
				list8.Add(vector3.z);
				list9.Add(new Vector2(vector3.x, vector3.z));
				if (connections[i].blendFlag)
				{
					connections[i].blendCornerPointInts.Add(vecCount + list.Count - 1);
					Vector3 b = OQQCQOCCOQ(vA, vB, vector3);
					connections[i].blendCornerPointWeights.Add(Vector3.Distance(vector3, b) / num);
				}
			}
			list10.Add(vecCount + list.Count - 1);
			list5.Clear();
			list5.AddRange(connections[i].rightOuterSegments);
			list5.Reverse();
			list6.Clear();
			list6.AddRange(connections[i].rightOuterSegmentsUVs);
			list6.Reverse();
			for (int l = 0; l < list5.Count; l++)
			{
				Vector3 vector3 = list5[l];
				list.Add(vector3);
				list3.Add(new PointER(vector3.x, vector3.z, 0f));
				list2.Add(list6[l]);
				list7.Add(vector3.x);
				list8.Add(vector3.z);
				list9.Add(new Vector2(vector3.x, vector3.z));
				if (connections[i].blendFlag)
				{
					connections[i].blendCornerPointInts.Add(vecCount + list.Count - 1);
					Vector3 b = OQQCQOCCOQ(vA, vB, vector3);
					connections[i].blendCornerPointWeights.Add(Vector3.Distance(vector3, b) / num);
				}
			}
			list10.Add(vecCount + list.Count - list5.Count);
			list5.Clear();
			list5.AddRange(connections[i].innerRoundaboutPoints);
			list5.Reverse();
			list6.Clear();
			list6.AddRange(connections[i].innerRoundaboutUVs);
			list6.Reverse();
			for (int m = 0; m < list5.Count; m++)
			{
				Vector3 vector3 = list5[m];
				list.Add(vector3);
				list3.Add(new PointER(vector3.x, vector3.z, 0f));
				list2.Add(list6[m]);
				list7.Add(vector3.x);
				list8.Add(vector3.z);
				list9.Add(new Vector2(vector3.x, vector3.z));
			}
			List<int> list11 = new List<int>();
			List<TriangleER> list12 = delaunayER.Triangulate(list3);
			for (int n = 0; n < list12.Count; n++)
			{
				list11.Add(vecCount + delaunayER.FindVertice(new Vector3(list12[n].Vertex1.x, list12[n].Vertex1.z, list12[n].Vertex1.y), list));
				list11.Add(vecCount + delaunayER.FindVertice(new Vector3(list12[n].Vertex3.x, list12[n].Vertex3.z, list12[n].Vertex3.y), list));
				list11.Add(vecCount + delaunayER.FindVertice(new Vector3(list12[n].Vertex2.x, list12[n].Vertex2.z, list12[n].Vertex2.y), list));
			}
			for (int num2 = 0; num2 < list11.Count; num2 += 3)
			{
				Vector3 vector4 = (list[list11[num2] - vecCount] + list[list11[num2 + 1] - vecCount] + list[list11[num2 + 2] - vecCount]) / 3f;
				if (OCCQDQQDCC(list9.Count, list9, vector4.x, vector4.z))
				{
					list4.Add(list11[num2]);
					list4.Add(list11[num2 + 1]);
					list4.Add(list11[num2 + 2]);
				}
			}
			Vector3 centerPoint = Vector3.Lerp(connections[i].rightOuterSegments[connections[i].rightOuterSegments.Count - 1], connections[i].leftOuterSegments[connections[i].leftOuterSegments.Count - 1], 0.5f);
			list10.Reverse();
			connectionVecs.AddRange(list);
			connectionTris.AddRange(list4);
			triList[index].AddRange(list4);
			connectionUVs.AddRange(list2);
			meshVecs.AddRange(list);
			vecCount += list.Count;
			connections[i].centerPoint = centerPoint;
			connections[i].connectionVecInts.Clear();
			connections[i].connectionVecInts.AddRange(list10);
			connections[i].fullConnectionVecInts.AddRange(list10);
			OCDDOCDDOQ(meshVecs, list10, ref roadShapeVecs, ref roadShapeUVY);
			connections[i].roadShapeVecs.Clear();
			connections[i].roadShapeVecs.AddRange(roadShapeVecs);
			connections[i].roadShapeUVY.Clear();
			connections[i].roadShapeUVY.AddRange(roadShapeUVY);
		}
	}

	public static void OCDDOCDDOQ(List<Vector3> meshVecs, List<int> connectionVecInts, ref List<Vector2> roadShapeVecs, ref List<float> roadShapeUVY)
	{
		Vector3 a = meshVecs[connectionVecInts[0]];
		Vector3 b = meshVecs[connectionVecInts[connectionVecInts.Count - 1]];
		a.y = 0f;
		b.y = 0f;
		Vector3 b2 = Vector3.Lerp(a, b, 0.5f);
		float num = Vector3.Distance(a, b2);
		for (int i = 0; i < connectionVecInts.Count - 1; i++)
		{
		}
		float num2 = 0f;
		Vector2 zero = Vector2.zero;
		for (int j = 0; j < connectionVecInts.Count; j++)
		{
			b = meshVecs[connectionVecInts[j]];
			b.y = 0f;
			zero.x = Vector3.Distance(b, b2);
			if (Vector3.Distance(a, b) < num)
			{
				zero.x *= -1f;
			}
			zero.y = b.y;
			roadShapeVecs.Add(zero);
			if (j < connectionVecInts.Count - 1)
			{
				num2 += Vector3.Distance(meshVecs[connectionVecInts[j]], meshVecs[connectionVecInts[j + 1]]);
			}
		}
		roadShapeUVY.Add(0f);
		float num3 = 0f;
		for (int k = 1; k < connectionVecInts.Count; k++)
		{
			num3 += Vector3.Distance(meshVecs[connectionVecInts[k - 1]], meshVecs[connectionVecInts[k]]);
			roadShapeUVY.Add(num3 / num2);
		}
	}

	public static Vector2 SetUV(Vector3 p1, Vector3 p2, Vector3 p3, Vector2 uv1, Vector2 uv2)
	{
		float t = Vector3.Distance(p1, p3) / Vector3.Distance(p1, p2);
		return new Vector2(0f, Mathf.Lerp(uv1.y, uv2.y, t));
	}

	public static bool OCCQDQQDCC(int nvert, List<Vector2> vert, float testx, float testy)
	{
		int num = 0;
		bool flag = false;
		int num2 = 0;
		int index = nvert - 1;
		while (num2 < nvert)
		{
			if (vert[num2].y > testy != vert[index].y > testy && testx < (vert[index].x - vert[num2].x) * (testy - vert[num2].y) / (vert[index].y - vert[num2].y) + vert[num2].x)
			{
				flag = !flag;
			}
			index = num2++;
		}
		return flag;
	}

	public static bool OCCDQOCQQQ(int nvert, List<float> vertx, List<float> verty, float testx, float testy)
	{
		int num = 0;
		bool flag = false;
		int num2 = 0;
		int index = nvert - 1;
		while (num2 < nvert)
		{
			if (verty[num2] > testy != verty[index] > testy && testx < (vertx[index] - vertx[num2]) * (testy - verty[num2]) / (verty[index] - verty[num2]) + vertx[num2])
			{
				flag = !flag;
			}
			index = num2++;
		}
		return flag;
	}

	public static bool OQOCDCDOQO(List<Vector3> vecs, List<OOCOCQCQOQ> edges, int p1, int p2, int p3)
	{
		bool result = true;
		for (int i = 0; i < edges.Count; i++)
		{
			if (edges[i].start == p1 && edges[i].end == p2)
			{
				if (!ERCrossingPrefabs.OQCDCDOOCD(vecs[p2], vecs[p1], vecs[p3]))
				{
					result = false;
				}
			}
			else if (edges[i].start == p2 && edges[i].end == p1 && !ERCrossingPrefabs.OQCDCDOOCD(vecs[p1], vecs[p2], vecs[p3]))
			{
				result = false;
			}
			if (edges[i].start == p1 && edges[i].end == p3)
			{
				if (!ERCrossingPrefabs.OQCDCDOOCD(vecs[p3], vecs[p1], vecs[p2]))
				{
					result = false;
				}
			}
			else if (edges[i].start == p3 && edges[i].end == p1 && !ERCrossingPrefabs.OQCDCDOOCD(vecs[p1], vecs[p3], vecs[p2]))
			{
				result = false;
			}
			if (edges[i].start == p2 && edges[i].end == p3)
			{
				if (!ERCrossingPrefabs.OQCDCDOOCD(vecs[p3], vecs[p2], vecs[p1]))
				{
					result = false;
				}
			}
			else if (edges[i].start == p3 && edges[i].end == p2 && !ERCrossingPrefabs.OQCDCDOOCD(vecs[p2], vecs[p3], vecs[p1]))
			{
				result = false;
			}
		}
		return result;
	}

	public static Vector3 OQQCQOCCOQ(Vector3 vA, Vector3 vB, Vector3 vPoint)
	{
		Vector3 rhs = vPoint - vA;
		Vector3 normalized = (vB - vA).normalized;
		float num = Vector3.Distance(vA, vB);
		float num2 = Vector3.Dot(normalized, rhs);
		if (num2 <= 0f)
		{
			return vA;
		}
		if (num2 >= num)
		{
			return vB;
		}
		Vector3 vector = normalized * num2;
		return vA + vector;
	}
}
[Serializable]
public class ERConnectionVecs
{
	private List<int> á = new List<int>();

	private List<int> á = new List<int>();
}
[Serializable]
public class SidewalkPresetClass
{
	public string presetName = "";

	public double id;

	public double timestamp;

	public float sidewalkWidth1 = 1.5f;

	public float sidewalkWidth2 = 1.5f;

	public float curbHeight = 0.25f;

	public float curbDepth = 0.25f;

	public bool beveledCurb = false;

	public float beveledHeight = 0f;

	public float beveledDepth = 0f;

	public bool outerCurb = false;

	public bool roadSideCurbUVControl = false;

	public bool outerSideCurbUVControl = false;

	public Material sidewalkMaterial;

	public List<Vector2> shape = new List<Vector2>();

	public List<float> sidewalkUVs = new List<float>();

	public List<float> curbUVs = new List<float>();

	public bool lockUVs = false;

	public SidewalkPresetClass(QDOQDSQOOQDDD corner, string name)
	{
		presetName = name;
		sidewalkWidth1 = corner.sidewalkWidth1;
		sidewalkWidth2 = corner.sidewalkWidth2;
		curbHeight = corner.curbHeight;
		curbDepth = corner.curbDepth;
		beveledCurb = corner.beveledCurb;
		beveledHeight = corner.beveledHeight;
		beveledDepth = corner.beveledDepth;
		outerCurb = corner.outerCurb;
		roadSideCurbUVControl = corner.roadSideCurbUVControl;
		outerSideCurbUVControl = outerSideCurbUVControl;
		sidewalkMaterial = corner.sidewalkMaterial;
		sidewalkUVs.AddRange(corner.sidewalkUVs);
		curbUVs.AddRange(corner.curbUVs);
		lockUVs = corner.lockUVs;
	}
}
[Serializable]
public class CrossingCornerClass
{
	public string presetName = "";

	public double id;

	public double timestamp;

	public float cornerRadius = 1f;

	public int cornerSegments = 5;

	public float innerSegmentDistance = 0.5f;

	public CrossingCornerClass(QDOQDSQOOQDDD sw, string name)
	{
		presetName = name;
		cornerRadius = sw.cornerRadius;
		cornerSegments = sw.cornerSegments;
		innerSegmentDistance = sw.innerSegmentDistance;
	}
}
public class ERConnection
{
	public string name;

	public ERCrossingPrefabs prefabScript;

	public GameObject gameObject;

	public ERConnectionData[] connectionData;

	public static string str = "EasyRoads3Dv3v3 Warning: The free version does not support API calls";

	public ERConnection(GameObject go, string g_name)
	{
		name = g_name;
		gameObject = go;
		prefabScript = go.GetComponent<ERCrossingPrefabs>();
	}

	public static ERConnection Create(GameObject go)
	{
		if (go.GetComponent<ERCrossingPrefabs>() != null)
		{
			return new ERConnection(go, go.name);
		}
		return null;
	}

	public void SetPosition(Vector3 pos)
	{
		if (gameObject != null)
		{
			gameObject.transform.position = pos;
		}
		if (prefabScript != null)
		{
			if (prefabScript.baseScript == null && (bool)prefabScript.transform.parent.parent.gameObject.GetComponent<ERModularBase>())
			{
				prefabScript.baseScript = prefabScript.transform.parent.parent.gameObject.GetComponent<ERModularBase>();
			}
			if (prefabScript.baseScript != null)
			{
				prefabScript.baseScript.UpdateQueue();
			}
			prefabScript.OQOQDDOCDC(ignorePriority: true, null);
		}
	}

	public string GetName()
	{
		if (gameObject != null)
		{
			return gameObject.name;
		}
		return "";
	}

	public void SetName(string name)
	{
		if (gameObject != null)
		{
			gameObject.name = name;
		}
	}

	public void SetRotation(Vector3 euler)
	{
		if (gameObject != null)
		{
			gameObject.transform.eulerAngles = euler;
		}
		if (prefabScript != null)
		{
			if (prefabScript.baseScript == null && (bool)prefabScript.transform.parent.parent.gameObject.GetComponent<ERModularBase>())
			{
				prefabScript.baseScript = prefabScript.transform.parent.parent.gameObject.GetComponent<ERModularBase>();
			}
			if (prefabScript.baseScript != null)
			{
				prefabScript.baseScript.UpdateQueue();
			}
			prefabScript.OQOQDDOCDC(ignorePriority: true, null);
		}
	}

	public void Destroy()
	{
		if (gameObject != null)
		{
			UnityEngine.Object.DestroyImmediate(gameObject);
		}
		if (prefabScript != null)
		{
			prefabScript.OQOQDDOCDC(ignorePriority: true, null);
		}
	}

	public void UnConnect(int connectionIndex)
	{
		if (prefabScript.crossingElements.Count <= connectionIndex)
		{
			return;
		}
		ERModularRoad eRModularRoad = null;
		int num = 0;
		if (prefabScript.crossingElements[connectionIndex].connectedRoad != null)
		{
			eRModularRoad = prefabScript.crossingElements[connectionIndex].connectedRoad;
			if (prefabScript.crossingElements[connectionIndex].connectedMarker == 0)
			{
				OCQOQOOOCO.OOCQODCOOQ(eRModularRoad.baseScript, eRModularRoad, 1, 0, 0);
			}
			else
			{
				OCQOQOOOCO.ODQDQOQQCO(eRModularRoad.baseScript, eRModularRoad, eRModularRoad.markersExt.Count - 2, eRModularRoad.markersExt.Count - 1, eRModularRoad.markersExt.Count - 1);
			}
		}
	}

	public ERConnectionData[] GetConnectionData()
	{
		if (prefabScript != null)
		{
			List<ERConnectionData> list = new List<ERConnectionData>();
			int num = 0;
			foreach (QDOODOQQDQODD crossingElement in prefabScript.crossingElements)
			{
				if (crossingElement.connectedRoad != null)
				{
					if (crossingElement.connectedRoad.road == null)
					{
						crossingElement.connectedRoad.road = new ERRoad(crossingElement.connectedRoad);
					}
					list.Add(new ERConnectionData(crossingElement.connectedRoad.road, crossingElement.connectedMarker, num));
				}
				num++;
			}
			if (list.Count > 0)
			{
				return list.ToArray();
			}
			return null;
		}
		return null;
	}

	public Vector3 GetLocalConnectionPosition(int connectionIndex)
	{
		if (prefabScript.crossingElements.Count > connectionIndex)
		{
			if (prefabScript.crossingElements[connectionIndex] != null)
			{
				if (prefabScript.crossingElements[connectionIndex].tmpCenterPoint != Vector3.zero)
				{
					return prefabScript.crossingElements[connectionIndex].tmpCenterPoint;
				}
				return prefabScript.crossingElements[connectionIndex].centerPoint;
			}
			return Vector3.zero;
		}
		return Vector3.zero;
	}

	public Vector3[] GetLocalConnectionPositions()
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < prefabScript.crossingElements.Count; i++)
		{
			if (prefabScript.crossingElements[i] != null)
			{
				if (prefabScript.crossingElements[i].tmpCenterPoint != Vector3.zero)
				{
					list.Add(prefabScript.crossingElements[i].tmpCenterPoint);
				}
				else
				{
					list.Add(prefabScript.crossingElements[i].centerPoint);
				}
			}
		}
		return list.ToArray();
	}

	public Vector3[] GetConnectionWorldPositions()
	{
		Vector3[] localConnectionPositions = GetLocalConnectionPositions();
		for (int i = 0; i < localConnectionPositions.Length; i++)
		{
			if (localConnectionPositions[i] != Vector3.zero)
			{
				localConnectionPositions[i] = gameObject.transform.TransformPoint(localConnectionPositions[i]);
			}
			else
			{
				localConnectionPositions[i] = new Vector3(1000000f, 0f, 1000000f);
			}
		}
		return localConnectionPositions;
	}

	public Vector3 GetConnectionWorldPosition(int connectionIndex)
	{
		Vector3 vector = GetLocalConnectionPosition(connectionIndex);
		if (vector != Vector3.zero)
		{
			vector = gameObject.transform.TransformPoint(vector);
		}
		return vector;
	}

	public int FindNearestConnectionIndex(Vector3 position)
	{
		Vector3[] connectionWorldPositions = GetConnectionWorldPositions();
		float num = float.PositiveInfinity;
		int result = -1;
		for (int i = 0; i < connectionWorldPositions.Length; i++)
		{
			float num2 = Vector3.Distance(position, connectionWorldPositions[i]);
			if (num2 < num)
			{
				num = num2;
				result = i;
			}
		}
		return result;
	}

	public bool SwapTurn()
	{
		if (prefabScript.crossingsScript != null)
		{
			if (!prefabScript.isSnapConnector && prefabScript.tCrossing && !prefabScript.isFlexConnector)
			{
				if (prefabScript.crossingElements.Count > 3)
				{
					if (prefabScript.crossingElements[2].connectedRoad == null && prefabScript.crossingElements[3].connectedRoad == null)
					{
						if (prefabScript.crossingsScript.tCrossingLeftRight == 0)
						{
							prefabScript.crossingsScript.tCrossingLeftRight = 1;
						}
						else
						{
							prefabScript.crossingsScript.tCrossingLeftRight = 0;
						}
						prefabScript.crossingsScript.Refresh();
						UnityEngine.Debug.Log(prefabScript.crossingsScript.tCrossingLeftRight);
						return true;
					}
					return false;
				}
				return false;
			}
			return false;
		}
		return false;
	}

	public bool RotateConnections()
	{
		int newIndex = -1;
		int oldIndex = -1;
		int index = -1;
		int index2 = -1;
		ERModularRoad road = null;
		ERModularRoad road2 = null;
		OOCQQOOQOD.SwapConnectionInit(prefabScript.baseScript, prefabScript, ref newIndex, ref oldIndex, ref index, ref index2, ref road, ref road2);
		if (newIndex != -1)
		{
			OOCQQOOQOD.OCCDCDQOOD(prefabScript.baseScript, prefabScript, newIndex, oldIndex, index, index2, road, road2);
			prefabScript.baseScript.UpdateSideObjectsInScene();
			return true;
		}
		return false;
	}

	public ERRoad GetConnectedRoad(int index, out ConnectedTo connectedTo)
	{
		connectedTo = ConnectedTo.None;
		if (index < prefabScript.crossingElements.Count)
		{
			if (prefabScript.crossingElements[index].connectedRoad != null)
			{
				if (prefabScript.crossingElements[index].connectedRoad.startPrefabScript == prefabScript && prefabScript.crossingElements[index].connectedRoad.startConnectionSegment == index)
				{
					connectedTo = ConnectedTo.Start;
				}
				else if (prefabScript.crossingElements[index].connectedRoad.endPrefabScript == prefabScript && prefabScript.crossingElements[index].connectedRoad.endConnectionSegment == index)
				{
					connectedTo = ConnectedTo.End;
				}
				if (prefabScript.crossingElements[index].connectedRoad.road == null)
				{
					prefabScript.crossingElements[index].connectedRoad.road = new ERRoad(prefabScript.crossingElements[index].connectedRoad);
				}
				return prefabScript.crossingElements[index].connectedRoad.road;
			}
			return null;
		}
		return null;
	}

	public ERLaneConnector[] GetLaneData(int connectionIndex)
	{
		if (prefabScript.crossingsScript != null)
		{
			if (prefabScript.siblings.Count > connectionIndex)
			{
				return prefabScript.siblings[connectionIndex].laneData.connectors.ToArray();
			}
			return null;
		}
		return null;
	}

	public ERLaneConnector[] GetLaneData(int connectionIndex, int lane)
	{
		if (prefabScript.crossingsScript != null)
		{
			if (prefabScript.siblings.Count > connectionIndex)
			{
				List<ERLaneConnector> list = new List<ERLaneConnector>();
				if (prefabScript.siblings[connectionIndex].roadType != null)
				{
					int num = ((prefabScript.baseScript.rightHandDriving != 1) ? prefabScript.siblings[connectionIndex].roadType.OOOOCQCDDC(lane, ERLaneDirection.Left) : prefabScript.siblings[connectionIndex].roadType.OOOOCQCDDC(lane, ERLaneDirection.Right));
					foreach (ERLaneConnector connector in prefabScript.siblings[connectionIndex].laneData.connectors)
					{
						if (connector.startLaneIndex == num)
						{
							list.Add(connector);
						}
					}
				}
				return list.ToArray();
			}
			return null;
		}
		return null;
	}

	public int GetConnectionCount()
	{
		return prefabScript.crossingElements.Count;
	}

	public void AverageNormals(bool flag)
	{
		prefabScript.averageNormals = flag;
	}

	public bool RecalculateNormals()
	{
		if (gameObject.GetComponent<MeshFilter>() != null)
		{
			Mesh sharedMesh = gameObject.GetComponent<MeshFilter>().sharedMesh;
			if (sharedMesh != null)
			{
				sharedMesh.RecalculateNormals();
				return true;
			}
			return false;
		}
		return false;
	}

	public bool RecalculateTangents()
	{
		if (gameObject.GetComponent<MeshFilter>() != null)
		{
			Mesh sharedMesh = gameObject.GetComponent<MeshFilter>().sharedMesh;
			if (sharedMesh != null)
			{
				sharedMesh.RecalculateTangents();
				return true;
			}
			return false;
		}
		return false;
	}

	public void Refresh()
	{
		if (prefabScript.baseScript != null)
		{
			prefabScript.baseScript.UpdateQueue();
		}
		if (prefabScript.crossingsScript != null && !prefabScript.isFlexConnector)
		{
			prefabScript.crossingsScript.OCQDQODOQD(sidewalkSceneHandleFlag: true, rebuildRoads: true);
		}
		else if (prefabScript.roundaboutScript != null && prefabScript.isRoundabout)
		{
			prefabScript.roundaboutScript.OOCDDOQDDO();
			prefabScript.roundaboutScript.OQQCDOQOOQ();
			if (prefabScript.roundaboutScript.leftFlag && prefabScript.roundaboutScript.rightFlag)
			{
				prefabScript.roundaboutScript.ODDDOCDCQO();
				if (prefabScript.roundaboutScript.connections.Count > 0)
				{
					prefabScript.roundaboutScript.OOQQDCCCCC();
				}
			}
			else
			{
				prefabScript.roundaboutScript.ResetData();
			}
		}
		if (prefabScript.baseScript != null)
		{
			prefabScript.baseScript.UpdateSideObjectsInScene();
		}
	}

	public bool IsFlexConnector()
	{
		if (prefabScript.isFlexConnector)
		{
			return true;
		}
		if (prefabScript.isERCrossing)
		{
			bool flag = true;
			int num = 0;
			for (int i = 0; i < prefabScript.crossingElements.Count; i++)
			{
				if (prefabScript.crossingElements[i].connectedRoad != null)
				{
					num++;
				}
				else if (i < 2)
				{
					flag = false;
				}
			}
			if (flag)
			{
				if (num < 4)
				{
					prefabScript.tCrossing = true;
				}
				prefabScript.isFlexConnector = true;
				prefabScript.InitFlexConnector();
			}
			else
			{
				UnityEngine.Debug.Log("EasyRoads3Dv3 warning: please first attach roads before turning this connection into a Flex Connector");
			}
		}
		return true;
	}
}
[AddComponentMenu("")]
public class ODDDDDCCQQ : MonoBehaviour
{
	public static void OQDCOQDQDO(ERCrossings scr, ref List<Vector3> meshVecs, ref List<Vector2> meshUVs, ref List<List<int>> triList, List<Material> materialList, List<Material> connectionMaterialList)
	{
		int centerPointIndex = 0;
		int centerPointIndex2 = 0;
		int centerPointIndex3 = 0;
		int centerPointIndex4 = 0;
		meshVecs.Add(Vector3.zero);
		meshUVs.Add(new Vector2(0.5f, GetCenterUVY(scr, scr.frontRoadUVTiling, scr.startConnectionV3, 0)));
		if (scr.frontRoadUVTiling == scr.backRoadUVTiling && scr.frontRoadUVTiling != scr.leftRoadUVTiling)
		{
			centerPointIndex3 = (centerPointIndex4 = 1);
			meshVecs.Add(Vector3.zero);
			meshUVs.Add(new Vector2(0.5f, GetCenterUVY(scr, scr.leftRoadUVTiling, scr.leftConnectionV3, 2)));
			if (scr.leftRoadUVTiling != scr.rightRoadUVTiling)
			{
				centerPointIndex4 = 2;
				meshVecs.Add(Vector3.zero);
				meshUVs.Add(new Vector2(0.5f, GetCenterUVY(scr, scr.rightRoadUVTiling, scr.rightConnectionV3, 3)));
			}
		}
		else if (scr.frontRoadUVTiling != scr.backRoadUVTiling)
		{
			centerPointIndex2 = (centerPointIndex3 = (centerPointIndex4 = 1));
			meshVecs.Add(Vector3.zero);
			meshUVs.Add(new Vector2(0.5f, GetCenterUVY(scr, scr.backRoadUVTiling, scr.endConnectionV3, 1)));
			if (scr.leftRoadUVTiling != scr.backRoadUVTiling)
			{
				centerPointIndex3 = (centerPointIndex4 = 2);
				meshVecs.Add(Vector3.zero);
				meshUVs.Add(new Vector2(0.5f, GetCenterUVY(scr, scr.leftRoadUVTiling, scr.leftConnectionV3, 2)));
				if (scr.leftRoadUVTiling != scr.rightRoadUVTiling)
				{
					centerPointIndex4 = 3;
					meshVecs.Add(Vector3.zero);
					meshUVs.Add(new Vector2(0.5f, GetCenterUVY(scr, scr.rightRoadUVTiling, scr.rightConnectionV3, 3)));
				}
			}
		}
		OCODCOCODQ(scr, scr.startConnectionV3, scr.startConnectionUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.startConnectionTris, 1, ODQDQDQDQO.ODOCOCDQCO(materialList, connectionMaterialList[0]), centerPointIndex);
		OCODCOCODQ(scr, scr.endConnectionV3, scr.endConnectionUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.endConnectionTris, 1, ODQDQDQDQO.ODOCOCDQCO(materialList, connectionMaterialList[1]), centerPointIndex2);
		OCODCOCODQ(scr, scr.leftConnectionV3, scr.leftConnectionUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.leftConnectionTris, 1, ODQDQDQDQO.ODOCOCDQCO(materialList, connectionMaterialList[2]), centerPointIndex3);
		OCODCOCODQ(scr, scr.rightConnectionV3, scr.rightConnectionUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.rightConnectionTris, 1, ODQDQDQDQO.ODOCOCDQCO(materialList, connectionMaterialList[3]), centerPointIndex4);
	}

	public static float GetCenterUVY(ERCrossings scr, float uvTiling, List<List<Vector3>> vecArray, int connection)
	{
		float num = 1f;
		float num2 = 5f * uvTiling;
		return connection switch
		{
			0 => (0f - vecArray[0][0].z) / num2, 
			1 => vecArray[0][0].z / num2, 
			2 => (0f - vecArray[0][0].x) / num2, 
			_ => vecArray[0][0].x / num2, 
		};
	}

	public static void OCODCOCODQ(ERCrossings scr, List<List<Vector3>> vecArray, List<List<Vector2>> uvArray, int frontLeft, int topBottom, ref List<Vector3> meshVecs, ref List<Vector2> meshUVs, ref List<List<int>> triList, ref List<List<int>> intArray, int startRow, int triArrayIndex, int centerPointIndex)
	{
		int num = meshVecs.Count;
		for (int i = 0; i < vecArray.Count; i++)
		{
			intArray.Add(new List<int>());
			for (int j = 0; j < vecArray[i].Count; j++)
			{
				meshVecs.Add(vecArray[i][j]);
				meshUVs.Add(uvArray[i][j]);
				intArray[i].Add(num);
				num++;
			}
		}
		if (startRow == 1)
		{
			triList[triArrayIndex].AddRange(OODCODOODC(intArray));
		}
		triList[triArrayIndex].AddRange(OCCQOODCCO(intArray[0], intArray[1], startRow));
		triList[triArrayIndex].AddRange(OCCQOODCCO(intArray[3], intArray[4], startRow));
		if (intArray[1].Count == intArray[2].Count)
		{
			triList[triArrayIndex].AddRange(OCCQOODCCO(intArray[1], intArray[2], startRow));
		}
		else
		{
			triList[triArrayIndex].AddRange(OOQCQQDDQC(intArray[1], intArray[2], vecArray[1], vecArray[2], frontLeft, topBottom, startRow));
		}
		if (intArray[2].Count == intArray[3].Count)
		{
			triList[triArrayIndex].AddRange(OCCQOODCCO(intArray[2], intArray[3], startRow));
		}
		else
		{
			triList[triArrayIndex].AddRange(OOQCQQDDQC(intArray[2], intArray[3], vecArray[2], vecArray[3], frontLeft, topBottom, startRow));
		}
		triList[triArrayIndex].Add(intArray[1][intArray[1].Count - 1]);
		triList[triArrayIndex].Add(centerPointIndex);
		triList[triArrayIndex].Add(intArray[2][intArray[2].Count - 1]);
		triList[triArrayIndex].Add(intArray[2][intArray[2].Count - 1]);
		triList[triArrayIndex].Add(centerPointIndex);
		triList[triArrayIndex].Add(intArray[3][intArray[3].Count - 1]);
	}

	public static List<int> OODCODOODC(List<List<int>> intArray)
	{
		List<int> list = new List<int>();
		list.Add(intArray[0][0]);
		list.Add(intArray[0][1]);
		list.Add(intArray[1][1]);
		list.Add(intArray[0][0]);
		list.Add(intArray[1][1]);
		list.Add(intArray[2][1]);
		list.Add(intArray[0][0]);
		list.Add(intArray[2][1]);
		list.Add(intArray[4][0]);
		list.Add(intArray[4][0]);
		list.Add(intArray[2][1]);
		list.Add(intArray[3][1]);
		list.Add(intArray[4][0]);
		list.Add(intArray[3][1]);
		list.Add(intArray[4][1]);
		return list;
	}

	public static List<int> OCCQOODCCO(List<int> col1, List<int> col2, int startRow)
	{
		List<int> list = new List<int>();
		for (int i = startRow; i < col1.Count - 1; i++)
		{
			list.Add(col1[i]);
			list.Add(col2[i + 1]);
			list.Add(col2[i]);
			list.Add(col1[i + 1]);
			list.Add(col2[i + 1]);
			list.Add(col1[i]);
		}
		return list;
	}

	public static List<int> OOQCQQDDQC(List<int> col1, List<int> col2, List<Vector3> vecs1, List<Vector3> vecs2, int frontLeft, int topBottom, int startRow)
	{
		List<int> list = new List<int>();
		int num = startRow;
		int num2 = startRow;
		int num3 = 0;
		bool flag = false;
		bool flag2 = false;
		int num4 = 0;
		while ((!flag || !flag2) && num3 < 100)
		{
			if (num < col1.Count - 1 && num2 < col2.Count - 1)
			{
				float num5 = Vector3.Distance(vecs1[num], vecs2[num2 + 1]);
				float num6 = Vector3.Distance(vecs1[num + 1], vecs2[num2]);
				num4 = ((num5 < num6) ? 1 : 0);
			}
			else if (num >= col1.Count - 1)
			{
				num4 = 1;
			}
			else if (num2 >= col2.Count - 1)
			{
				num4 = 0;
			}
			if (num4 == 0)
			{
				list.Add(col1[num]);
				list.Add(col1[num + 1]);
				list.Add(col2[num2]);
				num++;
			}
			else
			{
				list.Add(col1[num]);
				list.Add(col2[num2 + 1]);
				list.Add(col2[num2]);
				num2++;
			}
			if (num >= col1.Count - 1)
			{
				flag = true;
			}
			if (num2 >= col2.Count - 1)
			{
				flag2 = true;
			}
			num3++;
		}
		return list;
	}

	public static void InitODCOCQQDDC(ERCrossings scr)
	{
		ODCOCQQDDC(scr, scr.startConnectionV3, ref scr.startConnectionUV, ref scr.uvArrayFront, 0, scr.frontRoadUVTiling);
		ODCOCQQDDC(scr, scr.endConnectionV3, ref scr.endConnectionUV, ref scr.uvArrayBack, 0, scr.backRoadUVTiling);
		ODCOCQQDDC(scr, scr.leftConnectionV3, ref scr.leftConnectionUV, ref scr.uvArrayLeft, 1, scr.leftRoadUVTiling);
		ODCOCQQDDC(scr, scr.rightConnectionV3, ref scr.rightConnectionUV, ref scr.uvArrayRight, 1, scr.rightRoadUVTiling);
	}

	public static void ODCOCQQDDC(ERCrossings scr, List<List<Vector3>> vecArray, ref List<List<Vector2>> uvs, ref List<float> uvArray, int verthorz, float uvTiling)
	{
		ERSideWalkVecs.ODQOQOCCOC(vecArray, ref uvArray);
		Vector3 vA = new Vector3(50f, 0f, 0f);
		Vector3 vB = new Vector3(-50f, 0f, 0f);
		float num = Mathf.Abs(vecArray[0][0].z);
		if (verthorz == 1)
		{
			vA = new Vector3(0f, 0f, 50f);
			vB = new Vector3(0f, 0f, -50f);
			num = Mathf.Abs(vecArray[0][0].x);
		}
		float num2 = 5f * uvTiling;
		float num3 = 0f;
		for (int i = 0; i < vecArray.Count; i++)
		{
			uvs.Add(new List<Vector2>());
			for (int j = 0; j < vecArray[i].Count; j++)
			{
				Vector3 a = ODDCQDDCDD.OQQCQOCCOQ(vA, vB, vecArray[i][j]);
				num3 = Vector3.Distance(a, vecArray[i][j]);
				float num4 = num3 / num;
				uvs[i].Add(new Vector2(uvArray[i], num3 / num2));
			}
		}
	}

	public static Vector3[] OOQOODDQCC(ERCrossings scr, Vector3[] vecs)
	{
		if (!scr.tCrossing)
		{
			vecs[scr.frontLeftRoadInts[0]] = (vecs[scr.leftRightRoadInts[0]] = (vecs[scr.frontLeftRoadInts[0]] + vecs[scr.leftRightRoadInts[0]]) * 0.5f);
			vecs[scr.frontLeftRoadInts[1]] = (vecs[scr.leftRightRoadInts[1]] = (vecs[scr.frontLeftRoadInts[1]] + vecs[scr.leftRightRoadInts[1]]) * 0.5f);
			vecs[scr.frontRightRoadInts[0]] = (vecs[scr.rightLeftRoadInts[0]] = (vecs[scr.frontRightRoadInts[0]] + vecs[scr.rightLeftRoadInts[0]]) * 0.5f);
			vecs[scr.frontRightRoadInts[1]] = (vecs[scr.rightLeftRoadInts[1]] = (vecs[scr.frontRightRoadInts[1]] + vecs[scr.rightLeftRoadInts[1]]) * 0.5f);
			vecs[scr.rightRightRoadInts[0]] = (vecs[scr.backLeftRoadInts[0]] = (vecs[scr.rightRightRoadInts[0]] + vecs[scr.backLeftRoadInts[0]]) * 0.5f);
			vecs[scr.rightRightRoadInts[1]] = (vecs[scr.backLeftRoadInts[1]] = (vecs[scr.rightRightRoadInts[1]] + vecs[scr.backLeftRoadInts[1]]) * 0.5f);
			vecs[scr.leftLeftRoadInts[0]] = (vecs[scr.backRightRoadInts[0]] = (vecs[scr.leftLeftRoadInts[0]] + vecs[scr.backRightRoadInts[0]]) * 0.5f);
			vecs[scr.leftLeftRoadInts[1]] = (vecs[scr.backRightRoadInts[1]] = (vecs[scr.leftLeftRoadInts[1]] + vecs[scr.backRightRoadInts[1]]) * 0.5f);
		}
		else if (scr.tCrossingLeftRight == 0)
		{
			vecs[scr.frontLeftRoadInts[0]] = (vecs[scr.leftRightRoadInts[0]] = (vecs[scr.frontLeftRoadInts[0]] + vecs[scr.leftRightRoadInts[0]]) * 0.5f);
			vecs[scr.frontLeftRoadInts[1]] = (vecs[scr.leftRightRoadInts[1]] = (vecs[scr.frontLeftRoadInts[1]] + vecs[scr.leftRightRoadInts[1]]) * 0.5f);
			vecs[scr.frontRightRoadInts[0]] = (vecs[scr.backLeftRoadInts[0]] = (vecs[scr.frontRightRoadInts[0]] + vecs[scr.backLeftRoadInts[0]]) * 0.5f);
			vecs[scr.frontRightRoadInts[1]] = (vecs[scr.backLeftRoadInts[1]] = (vecs[scr.frontRightRoadInts[1]] + vecs[scr.backLeftRoadInts[1]]) * 0.5f);
			vecs[scr.leftLeftRoadInts[0]] = (vecs[scr.backRightRoadInts[0]] = (vecs[scr.leftLeftRoadInts[0]] + vecs[scr.backRightRoadInts[0]]) * 0.5f);
			vecs[scr.leftLeftRoadInts[1]] = (vecs[scr.backRightRoadInts[1]] = (vecs[scr.leftLeftRoadInts[1]] + vecs[scr.backRightRoadInts[1]]) * 0.5f);
		}
		else if (scr.tCrossingLeftRight == 1)
		{
			vecs[scr.frontLeftRoadInts[0]] = (vecs[scr.backRightRoadInts[0]] = (vecs[scr.frontLeftRoadInts[0]] + vecs[scr.backRightRoadInts[0]]) * 0.5f);
			vecs[scr.frontLeftRoadInts[1]] = (vecs[scr.backRightRoadInts[1]] = (vecs[scr.frontLeftRoadInts[1]] + vecs[scr.backRightRoadInts[1]]) * 0.5f);
			vecs[scr.frontRightRoadInts[0]] = (vecs[scr.rightLeftRoadInts[0]] = (vecs[scr.frontRightRoadInts[0]] + vecs[scr.rightLeftRoadInts[0]]) * 0.5f);
			vecs[scr.frontRightRoadInts[1]] = (vecs[scr.rightLeftRoadInts[1]] = (vecs[scr.frontRightRoadInts[1]] + vecs[scr.rightLeftRoadInts[1]]) * 0.5f);
			vecs[scr.rightRightRoadInts[0]] = (vecs[scr.backLeftRoadInts[0]] = (vecs[scr.rightRightRoadInts[0]] + vecs[scr.backLeftRoadInts[0]]) * 0.5f);
			vecs[scr.rightRightRoadInts[1]] = (vecs[scr.backLeftRoadInts[1]] = (vecs[scr.rightRightRoadInts[1]] + vecs[scr.backLeftRoadInts[1]]) * 0.5f);
		}
		return vecs;
	}
}
[AddComponentMenu("")]
public class ERSideWalkVecs : MonoBehaviour
{
	public static GameObject sidewalk;

	public static void OQOQDODDCD(ERCrossings scr)
	{
		ODCCDOQOOC(scr);
		OODDCODCCQ(scr);
		if (scr.prefabScript.sidewalkControlElements[1].renderFlag)
		{
			OOOQCOQOOQ(scr, scr.leftSidewalkStartV3, scr.rightSidewalkLeftV3, scr.prefabScript.sidewalkControlElements[0], 0, 0, scr.leftStartSidewalkCornerInt);
			OOOQCOQOOQ(scr, scr.rightSidewalkLeftV3, scr.leftSidewalkStartV3, scr.prefabScript.sidewalkControlElements[0], 1, 1, scr.rightLeftSidewalkCornerInt);
			ODDCDODCCQ(ref scr.leftSidewalkStartV3, ref scr.rightSidewalkLeftV3);
			ODQDQQOQCC(scr, scr.leftSidewalkStartV3, ref scr.leftSidewalkStartUV, scr.prefabScript.sidewalkControlElements[0], reverse: true, scr.frontRoadUVTiling);
			ODQDQQOQCC(scr, scr.rightSidewalkLeftV3, ref scr.rightSidewalkLeftUV, scr.prefabScript.sidewalkControlElements[0], reverse: false, scr.rightRoadUVTiling);
		}
		if (scr.prefabScript.sidewalkControlElements[0].renderFlag)
		{
			OOOQCOQOOQ(scr, scr.rightSidewalkStartV3, scr.leftSidewalkRightV3, scr.prefabScript.sidewalkControlElements[1], 1, 0, scr.rightStartSidewalkCornerInt);
			OOOQCOQOOQ(scr, scr.leftSidewalkRightV3, scr.rightSidewalkStartV3, scr.prefabScript.sidewalkControlElements[1], 0, 1, scr.leftRightSidewalkCornerInt);
			ODDCDODCCQ(ref scr.rightSidewalkStartV3, ref scr.leftSidewalkRightV3);
			ODQDQQOQCC(scr, scr.rightSidewalkStartV3, ref scr.rightSidewalkStartUV, scr.prefabScript.sidewalkControlElements[1], reverse: false, scr.frontRoadUVTiling);
			ODQDQQOQCC(scr, scr.leftSidewalkRightV3, ref scr.leftSidewalkRightUV, scr.prefabScript.sidewalkControlElements[1], reverse: true, scr.leftRoadUVTiling);
		}
		if (scr.prefabScript.sidewalkControlElements[3].renderFlag)
		{
			OOOQCOQOOQ(scr, scr.leftSidewalkEndV3, scr.rightSidewalkRightV3, scr.prefabScript.sidewalkControlElements[3], 0, 0, scr.leftEndSidewalkCornerInt);
			OOOQCOQOOQ(scr, scr.rightSidewalkRightV3, scr.leftSidewalkEndV3, scr.prefabScript.sidewalkControlElements[3], 1, 1, scr.rightRightSidewalkCornerInt);
			ODDCDODCCQ(ref scr.leftSidewalkEndV3, ref scr.rightSidewalkRightV3);
			ODQDQQOQCC(scr, scr.leftSidewalkEndV3, ref scr.leftSidewalkEndUV, scr.prefabScript.sidewalkControlElements[3], reverse: true, scr.backRoadUVTiling);
			ODQDQQOQCC(scr, scr.rightSidewalkRightV3, ref scr.rightSidewalkRightUV, scr.prefabScript.sidewalkControlElements[3], reverse: false, scr.rightRoadUVTiling);
		}
		if (scr.prefabScript.sidewalkControlElements[2].renderFlag)
		{
			OOOQCOQOOQ(scr, scr.rightSidewalkEndV3, scr.leftSidewalkLeftV3, scr.prefabScript.sidewalkControlElements[2], 1, 0, scr.rightEndSidewalkCornerInt);
			OOOQCOQOOQ(scr, scr.leftSidewalkLeftV3, scr.rightSidewalkEndV3, scr.prefabScript.sidewalkControlElements[2], 0, 1, scr.leftLeftSidewalkCornerInt);
			ODDCDODCCQ(ref scr.rightSidewalkEndV3, ref scr.leftSidewalkLeftV3);
			ODQDQQOQCC(scr, scr.rightSidewalkEndV3, ref scr.rightSidewalkEndUV, scr.prefabScript.sidewalkControlElements[2], reverse: false, scr.backRoadUVTiling);
			ODQDQQOQCC(scr, scr.leftSidewalkLeftV3, ref scr.leftSidewalkLeftUV, scr.prefabScript.sidewalkControlElements[2], reverse: true, scr.leftRoadUVTiling);
		}
	}

	public static void ODCCDOQOOC(ERCrossings scr)
	{
		if (scr.prefabScript.sidewalkControlElements[1].renderFlag)
		{
			OQOQDOOOQO(scr, scr.startConnectionV3[0], scr.leftConnectionV3[scr.leftConnectionV3.Count - 1][0], scr.prefabScript.sidewalkControlElements[0].sidewalkWidth1, 1, ref scr.leftStartSidewalkCornerInt);
			OQOQDOOOQO(scr, scr.leftConnectionV3[scr.leftConnectionV3.Count - 1], scr.startConnectionV3[0][0], scr.prefabScript.sidewalkControlElements[0].sidewalkWidth1, 0, ref scr.rightLeftSidewalkCornerInt);
		}
		if (scr.prefabScript.sidewalkControlElements[0].renderFlag)
		{
			OQOQDOOOQO(scr, scr.startConnectionV3[scr.startConnectionV3.Count - 1], scr.rightConnectionV3[0][0], scr.prefabScript.sidewalkControlElements[1].sidewalkWidth1, 1, ref scr.rightStartSidewalkCornerInt);
			OQOQDOOOQO(scr, scr.rightConnectionV3[0], scr.startConnectionV3[scr.startConnectionV3.Count - 1][0], scr.prefabScript.sidewalkControlElements[1].sidewalkWidth1, 0, ref scr.leftRightSidewalkCornerInt);
		}
		if (scr.prefabScript.sidewalkControlElements[3].renderFlag)
		{
			OQOQDOOOQO(scr, scr.endConnectionV3[0], scr.rightConnectionV3[scr.rightConnectionV3.Count - 1][0], scr.prefabScript.sidewalkControlElements[3].sidewalkWidth1, 1, ref scr.leftEndSidewalkCornerInt);
			OQOQDOOOQO(scr, scr.rightConnectionV3[scr.rightConnectionV3.Count - 1], scr.endConnectionV3[0][0], scr.prefabScript.sidewalkControlElements[3].sidewalkWidth1, 0, ref scr.rightRightSidewalkCornerInt);
		}
		if (scr.prefabScript.sidewalkControlElements[2].renderFlag)
		{
			OQOQDOOOQO(scr, scr.endConnectionV3[scr.endConnectionV3.Count - 1], scr.leftConnectionV3[0][0], scr.prefabScript.sidewalkControlElements[2].sidewalkWidth1, 1, ref scr.rightEndSidewalkCornerInt);
			OQOQDOOOQO(scr, scr.leftConnectionV3[0], scr.endConnectionV3[scr.endConnectionV3.Count - 1][0], scr.prefabScript.sidewalkControlElements[2].sidewalkWidth1, 0, ref scr.leftLeftSidewalkCornerInt);
		}
	}

	public static void OQOQDOOOQO(ERCrossings scr, List<Vector3> vecArray, Vector3 firstOther, float sidewalkWidth, int xorz, ref int cornerInt)
	{
		if (xorz == 0)
		{
			firstOther.z = vecArray[0].z;
		}
		else
		{
			firstOther.x = vecArray[0].x;
		}
		cornerInt = vecArray.Count - 1;
		for (int i = 0; i < vecArray.Count; i++)
		{
			if (Vector3.Distance(vecArray[i], firstOther) <= sidewalkWidth)
			{
				cornerInt = i + 1;
				break;
			}
		}
	}

	public static void OOOQCOQOOQ(ERCrossings scr, List<List<Vector3>> vecArray, List<List<Vector3>> vecArrayOther, QDOQDSQOOQDDD corner, int startEnd, int mainOrConnected, int outerCornerInt)
	{
		float num = 0f;
		float num2 = 0f;
		List<Vector3> list = new List<Vector3>();
		if (corner.beveledCurb)
		{
			if (corner.beveledHeight > 0f && corner.beveledHeight != corner.curbHeight)
			{
				num2 = corner.beveledHeight;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(OQODQDOQOQ(vecArray[0], num2));
			}
			num2 = corner.curbHeight;
			if (corner.beveledDepth > 0f && corner.beveledDepth != corner.curbDepth)
			{
				num = corner.beveledDepth;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(ODCODDCCOC(vecArray[0], vecArrayOther[0], num, num2, startEnd, mainOrConnected, -1));
			}
			if (corner.beveledDepth != corner.curbDepth)
			{
				num = corner.curbDepth;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(ODCODDCCOC(vecArray[0], vecArrayOther[0], num, num2, startEnd, mainOrConnected, -1));
			}
		}
		else
		{
			num2 = corner.curbHeight;
			vecArray.Add(new List<Vector3>());
			vecArray[vecArray.Count - 1].AddRange(OQODQDOQOQ(vecArray[0], num2));
			num = corner.curbDepth;
			vecArray.Add(new List<Vector3>());
			vecArray[vecArray.Count - 1].AddRange(ODCODDCCOC(vecArray[0], vecArrayOther[0], num, num2, startEnd, mainOrConnected, -1));
		}
		num = corner.curbDepth;
		vecArray.Add(new List<Vector3>());
		vecArray[vecArray.Count - 1].AddRange(OQCDDCOODQ(scr, vecArray[0], vecArrayOther[0], num, num2, corner.sidewalkWidth1, startEnd, mainOrConnected, outerCornerInt));
		if (corner.beveledCurb && corner.outerCurb)
		{
			if (corner.beveledDepth != corner.curbDepth && corner.beveledDepth > 0f)
			{
				num = corner.beveledDepth;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(OQCDDCOODQ(scr, vecArray[0], vecArrayOther[0], num, num2, corner.sidewalkWidth1, startEnd, mainOrConnected, outerCornerInt));
			}
			if (corner.beveledHeight > 0f && corner.beveledHeight != corner.curbHeight && corner.outerCurb)
			{
				num2 = corner.beveledHeight;
				num = 0f;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(OQCDDCOODQ(scr, vecArray[0], vecArrayOther[0], num, num2, corner.sidewalkWidth1, startEnd, mainOrConnected, outerCornerInt));
			}
			num2 = 0f;
			num = 0f;
			vecArray.Add(new List<Vector3>());
			vecArray[vecArray.Count - 1].AddRange(OQCDDCOODQ(scr, vecArray[0], vecArrayOther[0], num, num2, corner.sidewalkWidth1, startEnd, mainOrConnected, outerCornerInt));
		}
		else
		{
			num = 0f;
			num2 = corner.curbHeight;
			vecArray.Add(new List<Vector3>());
			vecArray[vecArray.Count - 1].AddRange(OQCDDCOODQ(scr, vecArray[0], vecArrayOther[0], num, num2, corner.sidewalkWidth1, startEnd, mainOrConnected, outerCornerInt));
			if (corner.outerCurb)
			{
				num2 = 0f;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(OQCDDCOODQ(scr, vecArray[0], vecArrayOther[0], num, num2, corner.sidewalkWidth1, startEnd, mainOrConnected, outerCornerInt));
			}
		}
	}

	public static void OODDCODCCQ(ERCrossings scr)
	{
		scr.leftSidewalkStartV3.Add(new List<Vector3>());
		scr.leftSidewalkStartV3[0].AddRange(scr.startConnectionV3[0]);
		scr.rightSidewalkStartV3.Add(new List<Vector3>());
		scr.rightSidewalkStartV3[0].AddRange(scr.startConnectionV3[scr.startConnectionV3.Count - 1]);
		scr.leftSidewalkEndV3.Add(new List<Vector3>());
		scr.leftSidewalkEndV3[0].AddRange(scr.endConnectionV3[0]);
		scr.rightSidewalkEndV3.Add(new List<Vector3>());
		scr.rightSidewalkEndV3[0].AddRange(scr.endConnectionV3[scr.endConnectionV3.Count - 1]);
		scr.leftSidewalkLeftV3.Add(new List<Vector3>());
		scr.leftSidewalkLeftV3[0].AddRange(scr.leftConnectionV3[0]);
		scr.rightSidewalkLeftV3.Add(new List<Vector3>());
		scr.rightSidewalkLeftV3[0].AddRange(scr.leftConnectionV3[scr.leftConnectionV3.Count - 1]);
		scr.leftSidewalkRightV3.Add(new List<Vector3>());
		scr.leftSidewalkRightV3[0].AddRange(scr.rightConnectionV3[0]);
		scr.rightSidewalkRightV3.Add(new List<Vector3>());
		scr.rightSidewalkRightV3[0].AddRange(scr.rightConnectionV3[scr.rightConnectionV3.Count - 1]);
	}

	public static List<Vector3> ODCODDCCOC(List<Vector3> outer, List<Vector3> outerOther, float dist, float height, int startend, int leftright, int outerCornerInt)
	{
		List<Vector3> list = new List<Vector3>();
		int num = outer.Count;
		if (outerCornerInt != -1)
		{
			num = outerCornerInt;
		}
		for (int i = 0; i < num; i++)
		{
			Vector3 vector = ((i != 0) ? ((i >= outer.Count - 1) ? (outerOther[outerOther.Count - 2] - outer[i - 1]).normalized : (outer[i + 1] - outer[i - 1]).normalized) : (outer[1] - outer[0]).normalized);
			vector = ((startend != 0) ? new Vector3(vector.z, 0f, 0f - vector.x) : new Vector3(0f - vector.z, 0f, vector.x));
			Vector3 item = outer[i] + vector * dist;
			item.y = height;
			list.Add(item);
		}
		return list;
	}

	public static List<Vector3> OQCDDCOODQ(ERCrossings scr, List<Vector3> innerArray, List<Vector3> outerOther, float dist, float height, float sidewalkWidth, int startend, int leftright, int outerCornerInt)
	{
		List<Vector3> list = new List<Vector3>();
		if (sidewalkWidth >= 0.5f)
		{
			Vector3 normalized = (innerArray[1] - innerArray[0]).normalized;
			normalized = ((startend != 0) ? new Vector3(normalized.z, 0f, 0f - normalized.x) : new Vector3(0f - normalized.z, 0f, normalized.x));
			Vector3 vector = innerArray[0] + normalized * sidewalkWidth;
			Vector3 vector2 = innerArray[0];
			Vector3 p = vector;
			if (leftright == 0)
			{
				p.z += 1f;
			}
			else
			{
				p.x += 1f;
			}
			int num = innerArray.Count;
			if (outerCornerInt != -1)
			{
				num = outerCornerInt;
			}
			for (int i = 0; i < num; i++)
			{
				vector2 = innerArray[i];
				if (leftright == 0)
				{
					vector2.x += 1f;
				}
				else
				{
					vector2.z += 1f;
				}
				Vector3 vector3 = ODQDQDQDQO.OODOQDOODO(vector, p, innerArray[i], vector2, flag: false);
				normalized = (innerArray[i] - vector3).normalized;
				vector3 += normalized * dist;
				vector3.y = height;
				list.Add(vector3);
			}
		}
		else
		{
			for (int j = 0; j < innerArray.Count; j++)
			{
				Vector3 normalized = ((j != 0) ? ((j >= innerArray.Count - 1) ? (innerArray[innerArray.Count - 1] - innerArray[innerArray.Count - 2]) : (innerArray[j + 1] - innerArray[j - 1])) : (innerArray[1] - innerArray[0]));
				normalized = (((leftright != 0 || startend != 0) && (leftright != 1 || startend != 0)) ? new Vector3(normalized.z, 0f, 0f - normalized.x).normalized : new Vector3(0f - normalized.z, 0f, normalized.x).normalized);
				Vector3 vector3 = innerArray[j] + normalized * sidewalkWidth;
				vector3.y = height;
				list.Add(vector3);
			}
		}
		return list;
	}

	public static List<Vector3> OQODQDOQOQ(List<Vector3> outer, float height)
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < outer.Count; i++)
		{
			Vector3 item = outer[i];
			item.y = height;
			list.Add(item);
		}
		return list;
	}

	public static void ODQDQQOQCC(ERCrossings scr, List<List<Vector3>> vecArray, ref List<List<Vector2>> uvArray, QDOQDSQOOQDDD corner, bool reverse, float uvTiling)
	{
		if (corner.sidewalkUVs.Count == 0 || !corner.lockUVs)
		{
			ODQOQOCCOC(vecArray, ref corner.sidewalkUVs);
		}
		List<float> list = new List<float>();
		list.AddRange(corner.sidewalkUVs);
		uvArray.Clear();
		float num = 0f;
		float num2 = 5f * uvTiling;
		for (int i = 0; i < vecArray.Count; i++)
		{
			uvArray.Add(new List<Vector2>());
			uvArray[i].Add(new Vector2(list[i], 0f));
			num = 0f;
			for (int j = 1; j < vecArray[i].Count; j++)
			{
				num += Vector3.Distance(vecArray[i][j - 1], vecArray[i][j]);
				uvArray[i].Add(new Vector2(list[i], num / num2));
			}
		}
	}

	public static void ODQOQOCCOC(List<List<Vector3>> vecArray, ref List<float> sidewalkUVs)
	{
		sidewalkUVs.Clear();
		List<float> list = new List<float>();
		list.Add(0f);
		float num = 0f;
		for (int i = 1; i < vecArray.Count; i++)
		{
			num += Vector3.Distance(vecArray[i - 1][0], vecArray[i][0]);
			list.Add(num);
		}
		for (int j = 0; j < list.Count; j++)
		{
			sidewalkUVs.Add(list[j] / num);
		}
	}

	public static void ODDCDODCCQ(ref List<List<Vector3>> outer1, ref List<List<Vector3>> outer2)
	{
		for (int i = 0; i < outer1.Count; i++)
		{
			if (outer1[i][outer1[i].Count - 1] != outer2[i][outer2[i].Count - 1])
			{
				Vector3 vector = ODQDQDQDQO.OODOQDOODO(outer1[i][outer1[i].Count - 1], outer1[i][outer1[i].Count - 2], outer2[i][outer2[i].Count - 1], outer2[i][outer2[i].Count - 2], flag: false);
				List<Vector3> list = outer1[i];
				int index = outer1[i].Count - 1;
				Vector3 value = (outer2[i][outer2[i].Count - 1] = vector);
				list[index] = value;
			}
		}
	}

	public static Vector3[] OODDQOQDCC(ERCrossings scr, Vector3[] normals)
	{
		for (int i = 0; i < scr.OCCODQDOQO.Count; i++)
		{
			normals[scr.OCCODQDOQO[i]] = (normals[scr.ODOQODQODO[i]] = (normals[scr.OCCODQDOQO[i]] + normals[scr.ODOQODQODO[i]]) * 0.5f);
			normals[scr.OCCODQDOQOStart[i]] = normals[scr.OCCODQDOQOStart[i] + 1];
			normals[scr.ODOQODQODOStart[i]] = normals[scr.ODOQODQODOStart[i] + 1];
		}
		for (int j = 0; j < scr.OOQODQDOQC.Count; j++)
		{
			normals[scr.OOQODQDOQC[j]] = (normals[scr.OOOQCQDOCD[j]] = (normals[scr.OOQODQDOQC[j]] + normals[scr.OOOQCQDOCD[j]]) * 0.5f);
			normals[scr.OOQODQDOQCStart[j]] = normals[scr.OOQODQDOQCStart[j] + 1];
			normals[scr.OOOQCQDOCDStart[j]] = normals[scr.OOOQCQDOCDStart[j] + 1];
		}
		if (!scr.tCrossing || scr.tCrossingLeftRight == 0)
		{
			for (int k = 0; k < scr.OQCCQOCQDQ.Count; k++)
			{
				normals[scr.OQCCQOCQDQ[k]] = (normals[scr.ODQDCCQOQD[k]] = (normals[scr.OQCCQOCQDQ[k]] + normals[scr.ODQDCCQOQD[k]]) * 0.5f);
				normals[scr.OQCCQOCQDQStart[k]] = normals[scr.OQCCQOCQDQStart[k] + 1];
				normals[scr.ODQDCCQOQDStart[k]] = normals[scr.ODQDCCQOQDStart[k] + 1];
			}
		}
		if (!scr.tCrossing || scr.tCrossingLeftRight == 1)
		{
			for (int l = 0; l < scr.OQDQOQOCQD.Count; l++)
			{
				normals[scr.OQDQOQOCQD[l]] = (normals[scr.OQCDOOCDCD[l]] = (normals[scr.OQDQOQOCQD[l]] + normals[scr.OQCDOOCDCD[l]]) * 0.5f);
			}
		}
		return normals;
	}

	public static Vector4[] AdjustSidewalkTangents1(ERCrossings scr, Vector4[] tangents)
	{
		for (int i = 0; i < scr.OCCODQDOQO.Count; i++)
		{
			tangents[scr.OCCODQDOQO[i]] = (tangents[scr.ODOQODQODO[i]] = (tangents[scr.OCCODQDOQO[i]] + tangents[scr.ODOQODQODO[i]]) * 0.5f);
			tangents[scr.OCCODQDOQOStart[i]] = tangents[scr.OCCODQDOQOStart[i] + 1];
			tangents[scr.ODOQODQODOStart[i]] = tangents[scr.ODOQODQODOStart[i] + 1];
		}
		for (int j = 0; j < scr.OOQODQDOQC.Count; j++)
		{
			tangents[scr.OOQODQDOQC[j]] = (tangents[scr.OOOQCQDOCD[j]] = (tangents[scr.OOQODQDOQC[j]] + tangents[scr.OOOQCQDOCD[j]]) * 0.5f);
			tangents[scr.OOQODQDOQCStart[j]] = tangents[scr.OOQODQDOQCStart[j] + 1];
			tangents[scr.OOOQCQDOCDStart[j]] = tangents[scr.OOOQCQDOCDStart[j] + 1];
		}
		if (!scr.tCrossing || scr.tCrossingLeftRight == 0)
		{
			for (int k = 0; k < scr.OQCCQOCQDQ.Count; k++)
			{
				tangents[scr.OQCCQOCQDQ[k]] = (tangents[scr.ODQDCCQOQD[k]] = (tangents[scr.OQCCQOCQDQ[k]] + tangents[scr.ODQDCCQOQD[k]]) * 0.5f);
				tangents[scr.OQCCQOCQDQStart[k]] = tangents[scr.OQCCQOCQDQStart[k] + 1];
				tangents[scr.ODQDCCQOQDStart[k]] = tangents[scr.ODQDCCQOQDStart[k] + 1];
			}
		}
		if (!scr.tCrossing || scr.tCrossingLeftRight == 1)
		{
			for (int l = 0; l < scr.OQDQOQOCQD.Count; l++)
			{
				tangents[scr.OQDQOQOCQD[l]] = (tangents[scr.OQCDOOCDCD[l]] = (tangents[scr.OQDQOQOCQD[l]] + tangents[scr.OQCDOOCDCD[l]]) * 0.5f);
			}
		}
		return tangents;
	}

	public static Vector4[] AdjustSidewalkTangents(ERCrossings scr, Vector4[] tangents)
	{
		for (int i = 0; i < tangents.Length; i++)
		{
			tangents[i] = new Vector4(-1f, 0f, 0f, -1f);
		}
		return tangents;
	}

	public static Vector3[] ODDQQCCODD(ERRoundabouts scr, Vector3[] normals)
	{
		for (int i = 0; i < scr.connections.Count; i++)
		{
			List<int> rightSidewalkNormalsStart = scr.connections[i].rightSidewalkNormalsStart;
			List<int> rightSidewalkNormalsEnd = scr.connections[i].rightSidewalkNormalsEnd;
			List<int> leftSidewalkNormalsStart;
			List<int> leftSidewalkNormalsEnd;
			if (scr.connections.Count == 1)
			{
				leftSidewalkNormalsStart = scr.connections[0].leftSidewalkNormalsStart;
				leftSidewalkNormalsEnd = scr.connections[0].leftSidewalkNormalsEnd;
			}
			else if (i == 0)
			{
				leftSidewalkNormalsStart = scr.connections[scr.connections.Count - 1].leftSidewalkNormalsStart;
				leftSidewalkNormalsEnd = scr.connections[scr.connections.Count - 1].leftSidewalkNormalsEnd;
			}
			else
			{
				leftSidewalkNormalsStart = scr.connections[i - 1].leftSidewalkNormalsStart;
				leftSidewalkNormalsEnd = scr.connections[i - 1].leftSidewalkNormalsEnd;
			}
			for (int j = 0; j < rightSidewalkNormalsStart.Count; j++)
			{
				if (rightSidewalkNormalsEnd[j] < normals.Length && leftSidewalkNormalsEnd[j] < normals.Length)
				{
					normals[rightSidewalkNormalsEnd[j]] = (normals[leftSidewalkNormalsEnd[j]] = (normals[rightSidewalkNormalsEnd[j]] + normals[leftSidewalkNormalsEnd[j]]) * 0.5f);
				}
				if (rightSidewalkNormalsStart[j] + 1 < normals.Length)
				{
					normals[rightSidewalkNormalsStart[j]] = normals[rightSidewalkNormalsStart[j] + 1];
				}
				if (leftSidewalkNormalsStart[j] + 1 < normals.Length)
				{
					normals[leftSidewalkNormalsStart[j]] = normals[leftSidewalkNormalsStart[j] + 1];
				}
			}
		}
		for (int k = 0; k < scr.innerRoundaboutSidewalkIntsStart.Count; k++)
		{
			normals[scr.innerRoundaboutSidewalkIntsStart[k]] = (normals[scr.innerRoundaboutSidewalkIntsEnd[k]] = (normals[scr.innerRoundaboutSidewalkIntsStart[k]] + normals[scr.innerRoundaboutSidewalkIntsEnd[k]]) * 0.5f);
		}
		return normals;
	}

	public static Vector3[] SnapSidewalkCornersVecs(ERCrossings scr, Vector3[] vecs)
	{
		for (int i = 0; i < scr.OCCODQDOQO.Count; i++)
		{
			vecs[scr.OCCODQDOQO[i]] = (vecs[scr.ODOQODQODO[i]] = (vecs[scr.OCCODQDOQO[i]] + vecs[scr.ODOQODQODO[i]]) * 0.5f);
		}
		for (int j = 0; j < scr.OOQODQDOQC.Count; j++)
		{
			vecs[scr.OOQODQDOQC[j]] = (vecs[scr.OOOQCQDOCD[j]] = (vecs[scr.OOQODQDOQC[j]] + vecs[scr.OOOQCQDOCD[j]]) * 0.5f);
		}
		if (!scr.tCrossing || scr.tCrossingLeftRight == 0)
		{
			for (int k = 0; k < scr.OQCCQOCQDQ.Count; k++)
			{
				vecs[scr.OQCCQOCQDQ[k]] = (vecs[scr.ODQDCCQOQD[k]] = (vecs[scr.OQCCQOCQDQ[k]] + vecs[scr.ODQDCCQOQD[k]]) * 0.5f);
			}
		}
		if (!scr.tCrossing || scr.tCrossingLeftRight == 1)
		{
			for (int l = 0; l < scr.OQDQOQOCQD.Count; l++)
			{
				vecs[scr.OQDQOQOCQD[l]] = (vecs[scr.OQCDOOCDCD[l]] = (vecs[scr.OQDQOQOCQD[l]] + vecs[scr.OQCDOOCDCD[l]]) * 0.5f);
			}
		}
		return vecs;
	}

	public static void ODCQCQDODC(ERModularBase baseScript, ERSideWalk sw, Vector3 pos)
	{
		Transform transform = null;
		if (baseScript != null)
		{
			transform = baseScript.transform.Find("Temp Sidewalk");
		}
		if (transform == null)
		{
			GameObject gameObject = new GameObject("Temp Sidewalk");
			transform = gameObject.transform;
			transform.parent = baseScript.transform;
		}
		else
		{
			sidewalk = GameObject.Find(sw.name);
		}
		if (sidewalk == null)
		{
			sidewalk = new GameObject(sw.name);
		}
		sidewalk.transform.parent = transform;
		sidewalk.transform.position = pos;
		if (sidewalk.GetComponent<MeshRenderer>() == null)
		{
			sidewalk.AddComponent<MeshRenderer>();
			if (sw.material != null)
			{
				sidewalk.GetComponent<MeshRenderer>().sharedMaterial = sw.material;
			}
		}
		if (sidewalk.GetComponent<MeshFilter>() == null)
		{
			sidewalk.AddComponent<MeshFilter>().sharedMesh = new Mesh();
		}
	}

	public static void OQOOQDCQOC(ERSideWalk sw, GameObject sidewalkGO, List<Vector3> vecs, int leftRight, float offsetX, bool updateMesh)
	{
		int innerIndex = 0;
		List<bool> trisFlag = new List<bool>();
		List<Vector2> list = OCDODCQCCC(sw, ref innerIndex, ref trisFlag);
		List<float> sidewalkUVs = sw.sidewalkUVs;
		float num = 0f;
		if (sidewalkUVs.Count != list.Count)
		{
			sidewalkUVs.Clear();
			num = 0f;
			List<float> list2 = new List<float>();
			list2.Add(0f);
			for (int i = 1; i < list.Count; i++)
			{
				num += Vector2.Distance(list[i - 1], list[i]);
				list2.Add(num);
			}
			for (int j = 0; j < list.Count; j++)
			{
				sidewalkUVs.Add(list2[j] / num);
			}
		}
		if (vecs == null)
		{
			vecs = new List<Vector3>();
			num = 0f;
			for (int k = 0; k < 10; k++)
			{
				vecs.Add(Vector3.forward * num);
				num += 1f;
			}
		}
		sw.shape = list;
		sw.doConnectionTri = trisFlag;
		sw.sidewalkUVs = sidewalkUVs;
		if (updateMesh)
		{
			ODDDOCDCQO(sw, list, trisFlag, sidewalkUVs, vecs, null, leftRight, sidewalkGO, offsetX, closedStart: true, closedEnd: true);
		}
	}

	private static List<Vector2> OCDODCQCCC(ERSideWalk sw, ref int innerIndex, ref List<bool> trisFlag)
	{
		List<Vector2> list = new List<Vector2>();
		Vector2 zero = Vector2.zero;
		list.Add(zero);
		trisFlag.Add(item: false);
		if (sw.beveledCurb)
		{
			if (sw.beveledHeight != 0f || sw.beveledDepth != 0f)
			{
				if (sw.beveledHeight > 0f)
				{
					zero.y = sw.beveledHeight;
					list.Add(zero);
					if (sw.hardEdges)
					{
						trisFlag.Add(item: true);
					}
					else
					{
						trisFlag.Add(item: false);
					}
				}
				if (sw.beveledDepth > 0f)
				{
					zero.y = sw.curbHeight;
					zero.x = sw.beveledDepth;
					list.Add(zero);
					if (sw.hardEdges)
					{
						trisFlag.Add(item: true);
					}
					else
					{
						trisFlag.Add(item: false);
					}
				}
			}
		}
		else
		{
			zero.y = sw.curbHeight;
			list.Add(zero);
			if (sw.hardEdges)
			{
				trisFlag.Add(item: true);
			}
			else
			{
				trisFlag.Add(item: false);
			}
		}
		zero.x = sw.curbDepth;
		zero.y = sw.curbHeight;
		list.Add(zero);
		trisFlag.Add(item: false);
		innerIndex = list.Count;
		zero.x = sw.sidewalkWidth - sw.curbDepth;
		list.Add(zero);
		trisFlag.Add(item: false);
		if (!sw.outerCurb)
		{
			zero.x = sw.sidewalkWidth;
			list.Add(zero);
			if (sw.hardEdges)
			{
				trisFlag.Add(item: true);
			}
			else
			{
				trisFlag.Add(item: false);
			}
		}
		else if (sw.outerCurb)
		{
			if (sw.beveledCurb)
			{
				if (sw.beveledDepth > 0f)
				{
					zero.x = sw.sidewalkWidth - sw.beveledDepth;
					list.Add(zero);
					if (sw.hardEdges)
					{
						trisFlag.Add(item: true);
					}
					else
					{
						trisFlag.Add(item: false);
					}
				}
				if (sw.beveledHeight > 0f)
				{
					zero.x = sw.sidewalkWidth;
					zero.y = sw.beveledHeight;
					list.Add(zero);
					if (sw.hardEdges)
					{
						trisFlag.Add(item: true);
					}
					else
					{
						trisFlag.Add(item: false);
					}
				}
			}
			else
			{
				zero.x = sw.sidewalkWidth;
				list.Add(zero);
				if (sw.hardEdges)
				{
					trisFlag.Add(item: true);
				}
				else
				{
					trisFlag.Add(item: false);
				}
			}
			zero.x = sw.sidewalkWidth;
			zero.y = 0f;
			list.Add(zero);
			trisFlag.Add(item: false);
		}
		return list;
	}

	public static void ODDDOCDCQO(ERSideWalk sw, List<Vector2> shape, List<bool> trisFlag, List<float> uv, List<Vector3> spline, List<Vector3> spline2, int leftright, GameObject sidewalkGO, float offsetX, bool closedStart, bool closedEnd)
	{
		List<List<Vector3>> list = new List<List<Vector3>>();
		List<List<Vector2>> list2 = new List<List<Vector2>>();
		for (int i = 0; i < shape.Count; i++)
		{
			list.Add(new List<Vector3>());
			list2.Add(new List<Vector2>());
		}
		float num = 0f;
		for (int j = 0; j < spline.Count; j++)
		{
			Vector3 normalized;
			if (spline2 == null)
			{
				Vector3 vector = ((j > 0 && j < spline.Count - 1) ? (spline[j + 1] - spline[j - 1]) : ((j != 0) ? (spline[j] - spline[j - 1]) : (spline[j + 1] - spline[0])));
				normalized = new Vector3(vector.z, 0f, 0f - vector.x).normalized;
				normalized *= (float)leftright;
			}
			else
			{
				normalized = (spline[j] - spline2[j]).normalized;
			}
			if (j > 0)
			{
				num += Vector3.Distance(spline[j - 1], spline[j]);
			}
			float y = num / sw.uvRatio * sw.tiling;
			Vector3 vector2 = spline[j];
			for (int k = 0; k < shape.Count; k++)
			{
				Vector3 vector3 = vector2;
				vector3.y += shape[k].y;
				list[k].Add(vector3 + (shape[k].x + offsetX) * normalized);
				list2[k].Add(new Vector2(uv[k], y));
			}
		}
		int num2 = 0;
		List<int> list3 = new List<int>();
		for (int l = 0; l < trisFlag.Count; l++)
		{
			if (trisFlag[l])
			{
				num2++;
			}
			list3.Add(num2);
		}
		List<Vector3> vecs = new List<Vector3>();
		List<Vector2> uvs = new List<Vector2>();
		List<int> tris = new List<int>();
		int count = list.Count;
		int num3 = 0;
		for (int m = 0; m < list[0].Count; m++)
		{
			for (int n = 0; n < count; n++)
			{
				vecs.Add(list[n][m]);
				uvs.Add(list2[n][m]);
				if (trisFlag[n])
				{
					vecs.Add(list[n][m]);
					uvs.Add(list2[n][m]);
				}
				if (n < count - 1 && m < list[0].Count)
				{
					if (leftright == -1)
					{
						tris.Add(num3 + n + list3[n]);
						tris.Add(num3 + n + count + num2 + 1 + list3[n]);
						tris.Add(num3 + n + count + num2 + list3[n]);
						tris.Add(num3 + n + list3[n]);
						tris.Add(num3 + n + list3[n] + 1);
						tris.Add(num3 + n + count + num2 + 1 + list3[n]);
					}
					else
					{
						tris.Add(num3 + n + list3[n]);
						tris.Add(num3 + n + count + num2 + list3[n]);
						tris.Add(num3 + n + count + num2 + 1 + list3[n]);
						tris.Add(num3 + n + list3[n]);
						tris.Add(num3 + n + count + num2 + 1 + list3[n]);
						tris.Add(num3 + n + list3[n] + 1);
					}
				}
			}
			num3 = m * (count + num2);
		}
		int count2 = vecs.Count;
		if (closedStart)
		{
			OQCODDOCCD(sw, list, list2, ref vecs, ref uvs, ref tris, spline.Count, leftright, 0);
		}
		if (closedEnd)
		{
			OQCODDOCCD(sw, list, list2, ref vecs, ref uvs, ref tris, spline.Count, leftright, 1);
		}
		int count3 = vecs.Count;
		OCOCDDODDQ.OQCODQOCQD(sw, ref vecs, Vector3.zero, shape.Count + num2, count2, count3, 0);
		Mesh sharedMesh = sidewalkGO.GetComponent<MeshFilter>().sharedMesh;
		sharedMesh.Clear();
		sharedMesh.vertices = vecs.ToArray();
		sharedMesh.uv = uvs.ToArray();
		sharedMesh.triangles = tris.ToArray();
		sharedMesh.RecalculateNormals();
		sharedMesh.RecalculateBounds();
		sidewalkGO.GetComponent<MeshFilter>().sharedMesh = sharedMesh;
	}

	public static void OQCODDOCCD(ERSideWalk sw, List<List<Vector3>> sourceVecs, List<List<Vector2>> sourceUVs, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<int> tris, int pointsCount, int leftrightroad, int startEnd)
	{
		QDOQDSQOOQDDD qDOQDSQOOQDDD = new QDOQDSQOOQDDD(null);
		qDOQDSQOOQDDD.CopyFromSidewalk(sw);
		int triArrayElement = 0;
		List<List<int>> triList = new List<List<int>>();
		triList.Add(tris);
		List<List<int>> list = new List<List<int>>();
		int num = 0;
		for (int i = 0; i < sourceVecs.Count; i++)
		{
			list.Add(new List<int>());
			list[num].Add(num);
			if (sw.doConnectionTri[i])
			{
				num++;
				list.Add(new List<int>());
				list[num].Add(num);
			}
			num++;
		}
		num = list.Count;
		pointsCount--;
		for (int j = 0; j < list.Count; j++)
		{
			list[j].Add(pointsCount * num + j);
		}
		if (leftrightroad == -1)
		{
			leftrightroad = 0;
		}
		if (qDOQDSQOOQDDD.outerCurb)
		{
			if (!qDOQDSQOOQDDD.beveledCurb)
			{
				OOQOQOODQC.OCDCCCCCCQ(null, qDOQDSQOOQDDD, sourceVecs, sourceUVs, list, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, sw.hardEdges);
			}
			else if (qDOQDSQOOQDDD.beveledHeight > 0f && qDOQDSQOOQDDD.beveledDepth > 0f)
			{
				OOQOQOODQC.ODCQCQQQCQ(null, qDOQDSQOOQDDD, sourceVecs, sourceUVs, list, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, sw.hardEdges);
			}
			else if (qDOQDSQOOQDDD.beveledHeight > 0f)
			{
				OOQOQOODQC.OQDDCCCQQQ(null, qDOQDSQOOQDDD, sourceVecs, sourceUVs, list, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, sw.hardEdges);
			}
			else if (qDOQDSQOOQDDD.beveledDepth > 0f)
			{
				OOQOQOODQC.OODCCQQDOO(null, qDOQDSQOOQDDD, sourceVecs, sourceUVs, list, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, sw.hardEdges);
			}
			else
			{
				OOQOQOODQC.OQCDQQODOD(null, qDOQDSQOOQDDD, sourceVecs, sourceUVs, list, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, sw.hardEdges);
			}
		}
		else if (!qDOQDSQOOQDDD.beveledCurb)
		{
			OOQOQOODQC.OCQDQCQDCC(null, qDOQDSQOOQDDD, sourceVecs, sourceUVs, list, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, startEnd, sw.hardEdges);
		}
		else if (qDOQDSQOOQDDD.beveledHeight > 0f && qDOQDSQOOQDDD.beveledDepth > 0f)
		{
			OOQOQOODQC.ODOODOCDOD(null, qDOQDSQOOQDDD, sourceVecs, sourceUVs, list, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, sw.hardEdges);
		}
		else if (qDOQDSQOOQDDD.beveledHeight > 0f)
		{
			OOQOQOODQC.OODDQQQDDQ(null, qDOQDSQOOQDDD, sourceVecs, sourceUVs, list, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, sw.hardEdges);
		}
		else if (qDOQDSQOOQDDD.beveledDepth > 0f)
		{
			OOQOQOODQC.OCCDCDCODO(null, qDOQDSQOOQDDD, sourceVecs, sourceUVs, list, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, sw.hardEdges);
		}
		else
		{
			OOQOQOODQC.ODOQCDCCOQ(null, qDOQDSQOOQDDD, sourceVecs, sourceUVs, list, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, sw.hardEdges);
		}
	}
}
public class OCQOCDODDQ : MonoBehaviour
{
	public static void ODCOOOQQQD(ERCrossingPrefabs scr, Vector3[] meshVecs, ref Vector3[] surfaceMeshVecs)
	{
		if (scr.baseScript == null && scr.transform.parent != null && scr.transform.parent.parent != null)
		{
			scr.baseScript = scr.transform.parent.parent.GetComponent<ERModularBase>();
		}
		if (scr.baseScript == null)
		{
			return;
		}
		if (scr.surfaceMeshVecs == null)
		{
			scr.surfaceMeshVecs = new Vector3[17];
		}
		if (scr.surfaceMeshVecs.Length != 17)
		{
			scr.surfaceMeshVecs = new Vector3[17];
		}
		int num = 0;
		if (scr.tCrossing)
		{
			num = scr.surfaceInts.Length - 16;
			scr.surfaceMeshVecs = new Vector3[17 + 2 * num];
		}
		Vector2[] array = new Vector2[scr.surfaceMeshVecs.Length];
		scr.surfaceMeshVecs[0] = Vector3.zero;
		array[0] = new Vector2(0f, 1f);
		scr.surfaceSurroundingInts.Clear();
		scr.surfaceSurroundingInts.Add(9);
		scr.surfaceSurroundingInts.Add(10);
		scr.surfaceSurroundingInts.Add(11);
		scr.surfaceSurroundingInts.Add(12);
		scr.surfaceSurroundingInts.Add(13);
		scr.surfaceSurroundingInts.Add(14);
		scr.surfaceSurroundingInts.Add(15);
		scr.surfaceSurroundingInts.Add(16);
		Vector3 connectedSurrounding;
		Vector3 mainSurrounding = (connectedSurrounding = Vector3.zero);
		float angle = 0f;
		scr.mainCorner = scr.meshVecs[scr.surfaceInts[2]];
		scr.connectedCorner = scr.meshVecs[scr.surfaceInts[12]];
		scr.mainVecOuter = scr.meshVecs[scr.surfaceInts[3]];
		scr.connectionVecOuter = scr.meshVecs[scr.surfaceInts[13]];
		if (!scr.tCrossing || scr.tCrossingLeftRight == 1)
		{
			OQCDOQOQDC(scr, angle, 1, leftrightFlag: true);
		}
		else
		{
			OCCCQDODDD(scr, scr.mainVecOuter, scr.meshVecs[scr.surfaceInts[1]], ref mainSurrounding, ref connectedSurrounding);
		}
		scr.surfaceMeshVecs[1] = scr.mainIndent;
		array[1] = new Vector2(0f, 1f);
		scr.surfaceMeshVecs[8] = scr.connectionIndent;
		array[8] = new Vector2(0f, 1f);
		if (!scr.tCrossing || scr.tCrossingLeftRight == 1)
		{
			OQDCOQOCQC(scr, scr.mainCorner, scr.mainIndent, scr.connectionIndent, ref mainSurrounding, ref connectedSurrounding, -1);
		}
		scr.surfaceMeshVecs[9] = mainSurrounding;
		array[9] = new Vector2(0f, 0f);
		scr.surfaceMeshVecs[16] = connectedSurrounding;
		array[16] = new Vector2(0f, 0f);
		scr.mainCorner = scr.meshVecs[scr.surfaceInts[0]];
		scr.connectedCorner = scr.meshVecs[scr.surfaceInts[10]];
		scr.mainVecOuter = scr.meshVecs[scr.surfaceInts[1]];
		scr.connectionVecOuter = scr.meshVecs[scr.surfaceInts[11]];
		if (!scr.tCrossing || scr.tCrossingLeftRight == 0)
		{
			OQCDOQOQDC(scr, 270f + scr.sAngle, -1, leftrightFlag: false);
		}
		else
		{
			OCCCQDODDD(scr, scr.mainVecOuter, scr.meshVecs[scr.surfaceInts[3]], ref mainSurrounding, ref connectedSurrounding);
		}
		scr.surfaceMeshVecs[2] = scr.mainIndent;
		array[2] = new Vector2(0f, 1f);
		scr.surfaceMeshVecs[3] = scr.connectionIndent;
		array[3] = new Vector2(0f, 1f);
		if (!scr.tCrossing || scr.tCrossingLeftRight == 0)
		{
			OQDCOQOCQC(scr, scr.mainCorner, scr.mainIndent, scr.connectionIndent, ref mainSurrounding, ref connectedSurrounding, 1);
		}
		scr.surfaceMeshVecs[10] = mainSurrounding;
		array[10] = new Vector2(0f, 0f);
		scr.surfaceMeshVecs[11] = connectedSurrounding;
		array[11] = new Vector2(0f, 0f);
		scr.mainCorner = scr.meshVecs[scr.surfaceInts[4]];
		scr.connectedCorner = scr.meshVecs[scr.surfaceInts[8]];
		scr.mainVecOuter = scr.meshVecs[scr.surfaceInts[5]];
		scr.connectionVecOuter = scr.meshVecs[scr.surfaceInts[9]];
		if (!scr.tCrossing || scr.tCrossingLeftRight == 0)
		{
			OQCDOQOQDC(scr, 90f - scr.sAngle, 1, leftrightFlag: true);
		}
		else
		{
			OCCCQDODDD(scr, scr.mainVecOuter, scr.meshVecs[scr.surfaceInts[7]], ref mainSurrounding, ref connectedSurrounding);
		}
		scr.surfaceMeshVecs[5] = scr.mainIndent;
		array[5] = new Vector2(0f, 1f);
		scr.surfaceMeshVecs[4] = scr.connectionIndent;
		array[4] = new Vector2(0f, 1f);
		if (!scr.tCrossing || scr.tCrossingLeftRight == 0)
		{
			OQDCOQOCQC(scr, scr.mainCorner, scr.mainIndent, scr.connectionIndent, ref mainSurrounding, ref connectedSurrounding, -1);
		}
		scr.surfaceMeshVecs[12] = mainSurrounding;
		array[12] = new Vector2(0f, 0f);
		scr.surfaceMeshVecs[13] = connectedSurrounding;
		array[13] = new Vector2(0f, 0f);
		scr.mainCorner = scr.meshVecs[scr.surfaceInts[6]];
		scr.connectedCorner = scr.meshVecs[scr.surfaceInts[14]];
		scr.mainVecOuter = scr.meshVecs[scr.surfaceInts[7]];
		scr.connectionVecOuter = scr.meshVecs[scr.surfaceInts[15]];
		if (!scr.tCrossing || scr.tCrossingLeftRight == 1)
		{
			OQCDOQOQDC(scr, 270f + scr.sAngle, -1, leftrightFlag: false);
		}
		else
		{
			OCCCQDODDD(scr, scr.mainVecOuter, scr.meshVecs[scr.surfaceInts[5]], ref mainSurrounding, ref connectedSurrounding);
		}
		scr.surfaceMeshVecs[6] = scr.mainIndent;
		array[6] = new Vector2(0f, 1f);
		scr.surfaceMeshVecs[7] = scr.connectionIndent;
		array[7] = new Vector2(0f, 1f);
		if (!scr.tCrossing || scr.tCrossingLeftRight == 1)
		{
			OQDCOQOCQC(scr, scr.mainCorner, scr.mainIndent, scr.connectionIndent, ref mainSurrounding, ref connectedSurrounding, 1);
		}
		scr.surfaceMeshVecs[14] = mainSurrounding;
		array[14] = new Vector2(0f, 0f);
		scr.surfaceMeshVecs[15] = connectedSurrounding;
		array[15] = new Vector2(0f, 0f);
		bool flag = true;
		ODDDDCCQCD(scr, 0, scr.surfaceMeshVecs[2], scr.surfaceMeshVecs[10], scr.surfaceMeshVecs[1], scr.surfaceMeshVecs[9]);
		OOOOCQCOQO(scr, 0, 2, 10, 1, 9);
		ODDDDCCQCD(scr, 1, scr.surfaceMeshVecs[6], scr.surfaceMeshVecs[14], scr.surfaceMeshVecs[5], scr.surfaceMeshVecs[13]);
		OOOOCQCOQO(scr, 1, 6, 14, 5, 13);
		ODDDDCCQCD(scr, 2, scr.surfaceMeshVecs[4], scr.surfaceMeshVecs[12], scr.surfaceMeshVecs[2], scr.surfaceMeshVecs[10]);
		OOOOCQCOQO(scr, 2, 4, 12, 2, 10);
		ODDDDCCQCD(scr, 3, scr.surfaceMeshVecs[8], scr.surfaceMeshVecs[16], scr.surfaceMeshVecs[7], scr.surfaceMeshVecs[15]);
		OOOOCQCOQO(scr, 3, 8, 16, 7, 15);
		ODQDODQOCC(scr, 0, scr.meshVecs[scr.surfaceInts[3]], scr.meshVecs[scr.surfaceInts[2]]);
		ODQDODQOCC(scr, 1, scr.meshVecs[scr.surfaceInts[5]], scr.meshVecs[scr.surfaceInts[4]]);
		ODQDODQOCC(scr, 2, scr.meshVecs[scr.surfaceInts[9]], scr.meshVecs[scr.surfaceInts[8]]);
		ODQDODQOCC(scr, 3, scr.meshVecs[scr.surfaceInts[13]], scr.meshVecs[scr.surfaceInts[12]]);
		List<int> list = new List<int>();
		list.Add(0);
		list.Add(1);
		list.Add(2);
		if (!scr.tCrossing || scr.tCrossingLeftRight == 0)
		{
			list.Add(0);
			list.Add(2);
			list.Add(3);
			list.Add(0);
			list.Add(3);
			list.Add(4);
			list.Add(0);
			list.Add(4);
			list.Add(5);
		}
		list.Add(0);
		list.Add(5);
		list.Add(6);
		if (!scr.tCrossing || scr.tCrossingLeftRight == 1)
		{
			list.Add(0);
			list.Add(6);
			list.Add(7);
			list.Add(0);
			list.Add(7);
			list.Add(8);
			list.Add(0);
			list.Add(8);
			list.Add(1);
		}
		if (!scr.tCrossing || scr.tCrossingLeftRight == 1)
		{
			list.Add(1);
			list.Add(8);
			list.Add(16);
			list.Add(1);
			list.Add(16);
			list.Add(9);
			list.Add(6);
			list.Add(14);
			list.Add(7);
			list.Add(7);
			list.Add(14);
			list.Add(15);
		}
		if (!scr.tCrossing || scr.tCrossingLeftRight == 0)
		{
			list.Add(2);
			list.Add(10);
			list.Add(11);
			list.Add(2);
			list.Add(11);
			list.Add(3);
			list.Add(4);
			list.Add(12);
			list.Add(13);
			list.Add(4);
			list.Add(13);
			list.Add(5);
		}
		if (scr.tCrossing)
		{
			Vector3 vector = Vector3.left;
			if (scr.tCrossingLeftRight == 0)
			{
				vector = Vector3.right;
			}
			int num2 = 17;
			int num3 = 17 + num;
			for (int i = 0; i < num; i++)
			{
				scr.surfaceMeshVecs[num2 + i] = scr.meshVecs[scr.surfaceInts[num2 + i - 1]] + vector * scr.baseScript.minIndent;
				array[num2 + i] = new Vector2(0f, 1f);
				scr.surfaceMeshVecs[num2 + i].y = 0f;
				Vector3 position = scr.meshVecs[scr.surfaceInts[num2 + i - 1]] + vector * (scr.baseScript.minIndent + scr.baseScript.minSurrounding);
				Vector3 pos = scr.transform.TransformPoint(position);
				scr.baseScript.OCDDQOCDCO(ref pos);
				position = scr.transform.InverseTransformPoint(pos);
				scr.surfaceMeshVecs[num3 + i] = position;
				array[num3 + i] = new Vector2(0f, 0f);
				scr.surfaceSurroundingInts.Add(num3 + i);
				if (i >= 0 && i < num - 1)
				{
					if (scr.tCrossingLeftRight == 1)
					{
						list.Add(num2 + i);
						list.Add(num3 + i);
						list.Add(num2 + i + 1);
						list.Add(num2 + i + 1);
						list.Add(num3 + i);
						list.Add(num3 + i + 1);
						list.Add(0);
						list.Add(num2 + i);
						list.Add(num2 + i + 1);
					}
					else
					{
						list.Add(num2 + i);
						list.Add(num2 + i + 1);
						list.Add(num3 + i);
						list.Add(num2 + i + 1);
						list.Add(num3 + i + 1);
						list.Add(num3 + i);
						list.Add(0);
						list.Add(num2 + i + 1);
						list.Add(num2 + i);
					}
				}
				if (i == num - 1 && scr.tCrossingLeftRight == 1)
				{
					scr.surfaceMeshVecs[13] = (scr.crossingElements[1].rightSurroundingV3 = position);
				}
			}
			scr.tp1 = scr.surfaceMeshVecs[num2];
			scr.tp2 = scr.surfaceMeshVecs[num3];
		}
		if (scr.surfaceObject == null)
		{
			if ((bool)scr.transform.Find("surface"))
			{
				scr.surfaceObject = scr.transform.Find("surface").gameObject;
				scr.surfaceObject.hideFlags = HideFlags.HideInHierarchy;
			}
			else
			{
				scr.surfaceObject = new GameObject("surface");
				scr.surfaceObject.hideFlags = HideFlags.HideInHierarchy;
				scr.surfaceObject.transform.position = scr.transform.position;
				scr.surfaceObject.transform.rotation = scr.transform.rotation;
				scr.surfaceObject.transform.parent = scr.transform;
				scr.surfaceObject.layer = scr.baseScript.sLayer;
				scr.surfaceObject.AddComponent<ERSurfaceScript>();
			}
		}
		if (scr.surfaceObject.GetComponent<MeshFilter>() == null)
		{
			scr.surfaceObject.AddComponent<MeshFilter>();
		}
		if (scr.surfaceObject.GetComponent<MeshRenderer>() == null)
		{
			scr.surfaceObject.AddComponent<MeshRenderer>();
			scr.surfaceObject.GetComponent<MeshRenderer>().sharedMaterial = Resources.Load("Materials/surfaceMaterial") as Material;
		}
		if (scr.surfaceObject.GetComponent<MeshCollider>() == null)
		{
			scr.surfaceObject.AddComponent<MeshCollider>();
		}
		Mesh mesh;
		if (scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh != null)
		{
			mesh = scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh;
		}
		else
		{
			mesh = new Mesh();
			mesh.name = "surface";
			scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh = mesh;
		}
		scr.surfaceObject.layer = scr.baseScript.sLayer;
		mesh.Clear();
		mesh.vertices = scr.surfaceMeshVecs;
		mesh.uv = array;
		mesh.tangents = new Vector4[scr.surfaceMeshVecs.Length];
		mesh.triangles = list.ToArray();
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();
		scr.surfaceObject.GetComponent<MeshCollider>().sharedMesh = null;
		scr.surfaceObject.GetComponent<MeshCollider>().sharedMesh = mesh;
		if (scr.baseScript.hideSurfaces)
		{
			scr.surfaceObject.GetComponent<MeshRenderer>().enabled = false;
			scr.surfaceObject.GetComponent<MeshCollider>().enabled = false;
		}
		scr.tmpSurfaceMeshVecs = new Vector3[scr.surfaceMeshVecs.Length];
		Array.Copy(scr.surfaceMeshVecs, scr.tmpSurfaceMeshVecs, scr.surfaceMeshVecs.Length);
	}

	public static void OQCDOQOQDC(ERCrossingPrefabs scr, float angle, int dirInt, bool leftrightFlag)
	{
		OODCQQDCCD(scr.mainCorner, ref scr.mainVecOuter, scr.baseScript.minIndent);
		OODCQQDCCD(scr.connectedCorner, ref scr.connectionVecOuter, scr.baseScript.minIndent);
		Vector3 mainCorner = scr.mainCorner;
		Vector3 mainVecOuter = scr.mainVecOuter;
		Vector3 connectedCorner = scr.connectedCorner;
		Vector3 connectionVecOuter = scr.connectionVecOuter;
		scr.cornerPos = ODQDQDQDQO.OODOQDOODO(scr.mainCorner, scr.mainVecOuter, scr.connectedCorner, scr.connectionVecOuter, flag: false);
		Vector3 dir = Vector3.zero;
		scr.connectionIndent = ODQODDQDQO(connectedCorner, scr.baseScript.minIndent, scr.connectionVecOuter, ref dir);
		scr.connectionIndent += new Vector3(dir.z, 0f, 0f - dir.x) * dirInt * scr.baseScript.minIndent;
		Vector3 dir2 = Vector3.zero;
		scr.mainIndent = ODQODDQDQO(mainCorner, scr.baseScript.minIndent, scr.mainVecOuter, ref dir2);
		scr.mainIndent += new Vector3(dir2.z, 0f, 0f - dir2.x) * -dirInt * scr.baseScript.minIndent;
		CheckIndentOQCDCDOOCD(dir, dir2, scr.cornerPos, scr.mainVecOuter, ref scr.mainIndent, ref scr.connectionIndent, scr.sAngle, scr.baseScript.minIndent, leftrightFlag);
		scr.connectionIndent.y = -0.02f;
		scr.mainIndent.y = -0.02f;
		if ((double)Vector3.Distance(scr.connectionIndent, scr.mainIndent) < 0.5)
		{
			scr.connectionIndent = scr.mainIndent;
		}
	}

	public static Vector3 ODQODDQDQO(Vector3 cornerPos, float indent, Vector3 outerPos, ref Vector3 dir)
	{
		dir = (outerPos - cornerPos).normalized;
		float num = Vector3.Distance(cornerPos, outerPos);
		if (num < indent)
		{
			return cornerPos + dir * indent;
		}
		return outerPos;
	}

	public static void OCCCQDODDD(ERCrossingPrefabs scr, Vector3 vecOuter1, Vector3 vecOuter2, ref Vector3 mainSurrounding, ref Vector3 connectedSurrounding)
	{
		vecOuter1.y = (vecOuter2.y = 0f);
		Vector3 normalized = (vecOuter1 - vecOuter2).normalized;
		scr.mainIndent = vecOuter1 + normalized * scr.baseScript.minIndent;
		mainSurrounding = vecOuter1 + normalized * (scr.baseScript.minIndent + scr.baseScript.minSurrounding);
		scr.connectionIndent = Vector3.zero;
		connectedSurrounding = Vector3.zero;
	}

	public static void CheckIndentOQCDCDOOCD(Vector3 dir1, Vector3 dir2, Vector3 cornerPos, Vector3 outer2, ref Vector3 indent2, ref Vector3 indent1, float angle, float minIndent, bool leftrightFlag)
	{
		if (ERCrossingPrefabs.OQCDCDOOCD(outer2, indent2, indent1) != leftrightFlag)
		{
			float num = minIndent / Mathf.Sin(angle * 0.5f * ((float)Math.PI / 180f));
			Vector3 normalized = Vector3.Lerp(dir1, dir2, 0.5f).normalized;
			indent1 = (indent2 = cornerPos + normalized * num);
			float num2 = Mathf.Cos(angle * 0.5f * ((float)Math.PI / 180f)) * num;
		}
	}

	public static void OQDCOQOCQC(ERCrossingPrefabs scr, Vector3 corner, Vector3 indentMain, Vector3 indentConnection, ref Vector3 mainSurrounding, ref Vector3 connectedSurrounding, int dirInt)
	{
		if (indentMain != indentConnection)
		{
			Vector3 normalized = (indentMain - indentConnection).normalized;
			Vector3 vector = Vector3.Lerp(indentMain, indentConnection, 0.5f) + new Vector3(normalized.z, 0f, 0f - normalized.x) * dirInt * scr.baseScript.minSurrounding;
			mainSurrounding = (connectedSurrounding = vector);
		}
		else
		{
			Vector3 normalized2 = (indentMain - corner).normalized;
			Vector3 vector2 = indentMain + normalized2 * scr.baseScript.minSurrounding;
			mainSurrounding = (connectedSurrounding = vector2);
		}
		Vector3 pos = scr.transform.TransformPoint(mainSurrounding);
		if (Terrain.activeTerrain != null)
		{
			scr.baseScript.OCDDQOCDCO(ref pos);
			mainSurrounding = (connectedSurrounding = scr.transform.InverseTransformPoint(pos));
		}
		else if (scr.baseScript.meshSurface != null)
		{
			scr.baseScript.OCDDQOCDCO(ref pos);
			mainSurrounding = (connectedSurrounding = scr.transform.InverseTransformPoint(pos));
		}
	}

	public static void ODDDDCCQCD(ERCrossingPrefabs scr, int connection, Vector3 leftIndent, Vector3 leftSurrounding, Vector3 rightIndent, Vector3 rightSurrounding)
	{
		scr.crossingElements[connection].leftIndentV3 = leftIndent;
		scr.crossingElements[connection].leftSurroundingV3 = leftSurrounding;
		scr.crossingElements[connection].rightIndentV3 = rightIndent;
		scr.crossingElements[connection].rightSurroundingV3 = rightSurrounding;
	}

	public static void OOOOCQCOQO(ERCrossingPrefabs scr, int connection, int leftIndent, int leftSurrounding, int rightIndent, int rightSurrounding)
	{
		scr.crossingElements[connection].leftIndent = leftIndent;
		scr.crossingElements[connection].leftSurrounding = leftSurrounding;
		scr.crossingElements[connection].rightIndent = rightIndent;
		scr.crossingElements[connection].rightSurrounding = rightSurrounding;
	}

	public static void ODQDODQOCC(ERCrossingPrefabs scr, int connection, Vector3 outerPoint, Vector3 crosspoint)
	{
		Vector3 a = ODQDQDQDQO.OODOQDOODO(scr.crossingElements[connection].leftIndentV3, scr.crossingElements[connection].rightIndentV3, outerPoint, crosspoint, flag: false);
		float additionalIndentDistance = Vector3.Distance(a, outerPoint);
		scr.crossingElements[connection].additionalIndentDistance = additionalIndentDistance;
	}

	public static float OOCDQCOCQO(Vector3 v11, Vector3 v12, Vector3 v21, Vector3 v22)
	{
		Vector3 normalized = (v11 - v12).normalized;
		Vector3 normalized2 = (v21 - v22).normalized;
		return Vector3.Angle(normalized, normalized2);
	}

	public static void OODCQQDCCD(Vector3 inner, ref Vector3 outer, float minDist)
	{
		if (Vector3.Distance(inner, outer) < minDist)
		{
			outer = inner + (outer - inner).normalized * minDist;
		}
	}

	public static void ODOODODQCO(ERCrossingPrefabs scr, Vector3[] meshVecs)
	{
		if (scr.baseScript == null)
		{
			scr.baseScript = scr.transform.parent.parent.GetComponent<ERModularBase>();
		}
		float num = 8f;
		scr.rightBottomCorner = new Vector3(3f, 0f, -3f);
		scr.bottomVec = new Vector3(3f, 0f, -3f - num);
		scr.rightVec = new Vector3(3f + num, 0f, -3f);
		float y = 90f - scr.sAngle;
		scr.rightVec = ERRoundabouts.OQDDDODCOC(scr.rightVec, scr.rightBottomCorner, Quaternion.Euler(0f, y, 0f));
		Vector3 dir = Vector3.zero;
		scr.rightIndent = ODQODDQDQO(scr.rightBottomCorner, scr.baseScript.minIndent, scr.rightVec, ref dir);
		scr.rightIndent += new Vector3(dir.z, 0f, 0f - dir.x) * scr.baseScript.minIndent;
		Vector3 dir2 = Vector3.zero;
		scr.bottomIndent = ODQODDQDQO(scr.rightBottomCorner, scr.baseScript.minIndent, scr.bottomVec, ref dir2);
		scr.bottomIndent += new Vector3(dir2.z, 0f, 0f - dir2.x) * -1f * scr.baseScript.minIndent;
		CheckIndentOQCDCDOOCD(dir, dir2, scr.rightBottomCorner, scr.bottomVec, ref scr.bottomIndent, ref scr.rightIndent, scr.sAngle, scr.baseScript.minIndent, leftrightFlag: false);
	}

	public static void ODQQQCOCCD(ERCrossingPrefabs scr, int connection)
	{
		if (connection == 0)
		{
			if (scr.tCrossingLeftRight == 0)
			{
				ODCQDDDOOO(scr, scr.crossingElements[0], scr.crossingElements[2], 1);
				scr.crossingElements[1].rightIndentV3 = scr.tmpSurfaceMeshVecs[scr.crossingElements[1].rightIndent];
				scr.crossingElements[1].rightSurroundingV3 = scr.tmpSurfaceMeshVecs[scr.crossingElements[1].rightSurrounding];
			}
			else
			{
				ODCQDDDOOO(scr, scr.crossingElements[3], scr.crossingElements[0], 1);
				scr.crossingElements[1].leftIndentV3 = scr.tmpSurfaceMeshVecs[scr.crossingElements[1].leftIndent];
				scr.crossingElements[1].leftSurroundingV3 = scr.tmpSurfaceMeshVecs[scr.crossingElements[1].leftSurrounding];
			}
		}
		else if (scr.tCrossingLeftRight == 0)
		{
			ODCQDDDOOO(scr, scr.crossingElements[2], scr.crossingElements[1], 0);
			scr.crossingElements[0].rightIndentV3 = scr.tmpSurfaceMeshVecs[scr.crossingElements[0].rightIndent];
			scr.crossingElements[0].rightSurroundingV3 = scr.tmpSurfaceMeshVecs[scr.crossingElements[0].rightSurrounding];
		}
		else
		{
			ODCQDDDOOO(scr, scr.crossingElements[1], scr.crossingElements[3], 0);
			scr.crossingElements[0].leftIndentV3 = scr.tmpSurfaceMeshVecs[scr.crossingElements[0].leftIndent];
			scr.crossingElements[0].leftSurroundingV3 = scr.tmpSurfaceMeshVecs[scr.crossingElements[0].leftSurrounding];
		}
	}

	public static void ODCQDDDOOO(ERCrossingPrefabs scr, QDOODOQQDQODD el1, QDOODOQQDQODD el2, int leftright)
	{
		float minIndent = scr.baseScript.minIndent;
		float minSurrounding = scr.baseScript.minSurrounding;
		Vector3 vector = scr.tmpFullMeshVecs[el1.connectionVecInts[0]];
		Vector3 vector2 = scr.tmpFullMeshVecs[el1.connectionVecInts[el1.connectionVecInts.Count - 1]];
		Vector3 vector3 = scr.tmpFullMeshVecs[el2.connectionVecInts[0]];
		Vector3 vector4 = scr.tmpFullMeshVecs[el2.connectionVecInts[el2.connectionVecInts.Count - 1]];
		vector.y = (vector2.y = (vector3.y = (vector4.y = 0f)));
		Vector3 normalized = (vector - vector2).normalized;
		Vector3 normalized2 = (vector4 - vector3).normalized;
		Vector3 normalized3 = ((normalized + normalized2) * 0.5f).normalized;
		float num = 180f - Vector3.Angle(normalized, normalized2);
		Vector3 b = ODQDQDQDQO.OODOQDOODO(vector, vector2, vector3, vector4, flag: false);
		float num2 = Vector3.Distance(vector, b);
		float num3 = Vector3.Distance(vector4, b);
		if (num2 < minIndent || num3 < minIndent)
		{
			Vector3 vector5 = new Vector3(normalized.z, 0f, 0f - normalized.x);
			Vector3 p = vector + vector5 * 1f;
			vector5 = new Vector3(normalized2.z, 0f, 0f - normalized2.x);
			Vector3 p2 = vector4 + vector5 * 1f;
			Vector3 vector6 = ODQDQDQDQO.OODOQDOODO(vector, p, vector4, p2, flag: false);
			float num4 = minIndent / Mathf.Sin(num * 0.5f * ((float)Math.PI / 180f));
			Vector3 vector7 = vector6 + normalized3 * num4;
			scr.tmpSurfaceMeshVecs[el1.leftIndent] = vector7;
			el1.leftIndentV3 = vector7;
			scr.tmpSurfaceMeshVecs[el2.rightIndent] = vector7;
			el2.rightIndentV3 = vector7;
			vector7 += normalized3 * minSurrounding;
			scr.tmpSurfaceMeshVecs[el1.leftSurrounding] = vector7;
			el1.leftSurroundingV3 = vector7;
			scr.tmpSurfaceMeshVecs[el2.rightSurrounding] = vector7;
			el2.rightSurroundingV3 = vector7;
		}
		else
		{
			Vector3 vector8 = vector + normalized * minIndent;
			scr.tmpSurfaceMeshVecs[el1.leftIndent] = vector8;
			el1.leftIndentV3 = vector8;
			vector8 += normalized3 * minSurrounding;
			scr.tmpSurfaceMeshVecs[el1.leftSurrounding] = vector8;
			el1.leftSurroundingV3 = vector8;
			vector8 = vector4 + normalized2 * minIndent;
			scr.tmpSurfaceMeshVecs[el2.rightIndent] = vector8;
			el2.rightIndentV3 = vector8;
			vector8 += normalized3 * minSurrounding;
			scr.tmpSurfaceMeshVecs[el2.rightSurrounding] = vector8;
			el2.rightSurroundingV3 = vector8;
		}
		if (leftright == 0)
		{
			el1.rightIndentV3 = scr.tmpSurfaceMeshVecs[el1.rightIndent];
			el1.rightSurroundingV3 = scr.tmpSurfaceMeshVecs[el1.rightSurrounding];
		}
		else
		{
			el2.leftIndentV3 = scr.tmpSurfaceMeshVecs[el2.leftIndent];
			el2.leftSurroundingV3 = scr.tmpSurfaceMeshVecs[el2.leftSurrounding];
		}
	}

	public static void OCDOQOOCCC(ERCrossingPrefabs scr)
	{
		if (scr.surfaceObject == null)
		{
			return;
		}
		Mesh sharedMesh;
		if (scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh != null)
		{
			sharedMesh = scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh;
			Vector3[] array = new Vector3[scr.tmpSurfaceMeshVecs.Length];
			Array.Copy(scr.tmpSurfaceMeshVecs, array, scr.tmpSurfaceMeshVecs.Length);
			if (sharedMesh.vertices.Length == 0)
			{
				return;
			}
			int[] triangles = sharedMesh.triangles;
			for (int i = 0; i < scr.surfaceSurroundingInts.Count; i++)
			{
				if (scr.tmpSurfaceMeshVecs.Length > scr.surfaceSurroundingInts[i])
				{
					Vector3 pos = scr.surfaceObject.transform.TransformPoint(scr.tmpSurfaceMeshVecs[scr.surfaceSurroundingInts[i]]);
					scr.baseScript.OCDDQOCDCO(ref pos);
					pos = scr.surfaceObject.transform.InverseTransformPoint(pos);
					array[scr.surfaceSurroundingInts[i]] = pos;
				}
			}
			sharedMesh.vertices = array;
			sharedMesh.RecalculateNormals();
			sharedMesh.RecalculateBounds();
			scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh = sharedMesh;
			scr.surfaceObject.GetComponent<MeshCollider>().sharedMesh = null;
			scr.surfaceObject.GetComponent<MeshCollider>().sharedMesh = sharedMesh;
			if (scr.baseScript.hideSurfaces)
			{
				scr.surfaceObject.GetComponent<MeshCollider>().enabled = false;
				scr.surfaceObject.SetActive(value: false);
				scr.surfaceObject.SetActive(value: true);
			}
			for (int j = 0; j < scr.crossingElements.Count; j++)
			{
				scr.crossingElements[j].leftSurroundingV3 = array[scr.crossingElements[j].leftSurrounding];
				scr.crossingElements[j].rightSurroundingV3 = array[scr.crossingElements[j].rightSurrounding];
			}
			return;
		}
		sharedMesh = new Mesh();
		sharedMesh.name = "surface";
		scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh = sharedMesh;
		if (scr.isRoundabout)
		{
			scr.roundaboutScript.OOCDDOQDDO();
			scr.roundaboutScript.OQQCDOQOOQ();
			scr.roundaboutScript.ODDDOCDCQO();
			return;
		}
		ERCrossings component = scr.gameObject.GetComponent<ERCrossings>();
		if (component != null)
		{
			component.OCQDQODOQD(sidewalkSceneHandleFlag: false, rebuildRoads: true);
		}
	}

	public static Vector3 ODCCDOCDQD(Transform transform, Vector3 pos, ERModularBase scr)
	{
		pos = transform.TransformPoint(pos);
		scr.OCDDQOCDCO(ref pos);
		return transform.InverseTransformPoint(pos);
	}
}
[AddComponentMenu("")]
public class QDDDQODDQDQDQDD : MonoBehaviour
{
	public static Vector3 testPoint;

	public static ERCrossings cScr;

	public static List<Vector3> ll1 = new List<Vector3>();

	public static List<Vector3> ll2 = new List<Vector3>();

	public static List<Vector3> ll3 = new List<Vector3>();

	public static List<Vector3> ll4 = new List<Vector3>();

	public static int crossingStructure = 0;

	public static List<QDQDOOQQDQODD> roadTypesDynamic = new List<QDQDOOQQDQODD>();

	public static ERModularBase baseScript;

	public static List<ERConnectionSibling> siblings = new List<ERConnectionSibling>();

	public static Vector3 crossPointCenter;

	public static ERCrossingPrefabs prefabScript;

	public static ERConnectionSibling primaryPriorityConnection;

	public static ERConnectionSibling secondPriorityConnection;

	private static float á = 0f;

	private static float á = 0f;

	public static List<Vector3> debugEdges = new List<Vector3>();

	public static List<Vector3> debugvecs = new List<Vector3>();

	public static List<QDQDOOQQDQODD> OQQCDQOQCD(List<QDQDOOQQDQODD> roadTypes, bool all)
	{
		List<QDQDOOQQDQODD> list = new List<QDQDOOQQDQODD>();
		QDQDOOQQDQODD qDQDOOQQDQODD = null;
		int num = 0;
		int num2 = 1;
		foreach (QDQDOOQQDQODD roadType in roadTypes)
		{
			if (all)
			{
				list.Add(roadType);
			}
			else if (roadType.roadShape.Count == 2 && !roadType.isSideObject && !roadType.isCustomRoad)
			{
				list.Add(roadType);
			}
			if (roadType.type != ERRoadWayType.Primary || qDQDOOQQDQODD == null)
			{
			}
			if (qDQDOOQQDQODD == null)
			{
				qDQDOOQQDQODD = roadType;
				num = num2;
			}
			num2++;
		}
		return list;
	}

	public static void OQODQQQCOC(ERCrossings scr)
	{
		cScr = scr;
		if (scr == null)
		{
			return;
		}
		if (cScr.baseScript == null)
		{
			if (!(cScr.transform.parent != null))
			{
				return;
			}
			cScr.baseScript = cScr.transform.parent.GetComponent<ERModularBase>();
			if (cScr.baseScript == null)
			{
				if ((bool)cScr.transform.parent.parent)
				{
					cScr.baseScript = cScr.transform.parent.parent.GetComponent<ERModularBase>();
				}
				if (cScr.baseScript == null)
				{
					return;
				}
			}
		}
		if (scr.prefabScript.isFlexConnector)
		{
			cScr.roadTypesDynamic = (roadTypesDynamic = OQQCDQOQCD(cScr.baseScript.roadTypes, all: true));
		}
		else
		{
			cScr.roadTypesDynamic = (roadTypesDynamic = OQQCDQOQCD(cScr.baseScript.roadTypes, all: false));
		}
		crossingStructure = scr.crossingStructure;
		baseScript = scr.baseScript;
		siblings = scr.prefabScript.siblings;
		crossPointCenter = scr.crossPointCenter;
		prefabScript = scr.prefabScript;
		debugEdges = scr.edges;
		primaryPriorityConnection = scr.primaryPriorityConnection;
		secondPriorityConnection = scr.secondPriorityConnection;
		á = scr.leftIntOffset;
		á = scr.rightIntOffset;
	}

	public static void ODODCOOQDO()
	{
	}

	public static bool OCODDQQOCQ(List<ERConnectionSibling> siblings, int thisSibling, int OtherSibling, int startLane)
	{
		if (siblings[OtherSibling].leftRoundingPoints.Count == 0 || siblings[OtherSibling].roadType.roadShapeData.lanes.Count == 0)
		{
			return false;
		}
		Vector3 a = Vector3.Lerp(siblings[OtherSibling].leftRoundingPoints[0], prefabScript.crossingElements[OtherSibling].centerPoint, -1f * siblings[OtherSibling].roadType.roadShapeData.lanes[0].position);
		int index = siblings[OtherSibling].roadType.roadShapeData.lanes.Count - 1;
		Vector3 a2 = Vector3.Lerp(siblings[OtherSibling].leftRoundingPoints[0], prefabScript.crossingElements[OtherSibling].centerPoint, -1f * siblings[OtherSibling].roadType.roadShapeData.lanes[index].position);
		Vector3 b = Vector3.Lerp(siblings[thisSibling].leftRoundingPoints[0], prefabScript.crossingElements[thisSibling].centerPoint, -1f * siblings[thisSibling].roadType.roadShapeData.lanes[startLane].position);
		float num = Vector3.Distance(a, b);
		float num2 = Vector3.Distance(a2, b);
		bool flag = false;
		if (num2 > num)
		{
			flag = true;
		}
		if (!flag)
		{
			int num3 = 0;
			for (int i = 0; i < siblings.Count; i++)
			{
				if (siblings[i].buildPriority == 0)
				{
					num3++;
				}
			}
			if (num3 > 2)
			{
				flag = true;
			}
		}
		return true;
	}

	public static void OQCDQDQOOO(bool hasLaneControlData)
	{
		if (prefabScript == null)
		{
			return;
		}
		if (prefabScript.baseScript == null)
		{
			if ((bool)prefabScript.transform.parent && (bool)prefabScript.transform.parent.parent)
			{
				baseScript = prefabScript.transform.parent.parent.GetComponent<ERModularBase>();
			}
			if (baseScript == null)
			{
				baseScript = UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase;
				if (baseScript == null)
				{
					return;
				}
			}
		}
		if (!prefabScript.baseScript.displayLaneData)
		{
			return;
		}
		if (hasLaneControlData)
		{
			for (int i = 0; i < siblings.Count; i++)
			{
				if (siblings[i].roadType == null)
				{
					return;
				}
				bool flag = false;
				if (siblings[i].aIInit && prefabScript.crossingElements[i].connectedRoad != null && prefabScript.crossingElements[i].connectedRoad.roadType != 0.0 && prefabScript.crossingElements[i].connectedRoad.roadType != siblings[i].roadTypeAIid)
				{
					QDQDOOQQDQODD roadTypeAI = siblings[i].roadTypeAI;
					flag = true;
					siblings[i].roadTypeAI = (prefabScript.crossingElements[i].connectedRoad.rt = QDQDOOQQDQODD.GetRoadTypeElByID(prefabScript.crossingElements[i].connectedRoad.baseScript.roadTypes, prefabScript.crossingElements[i].connectedRoad.roadType));
					siblings[i].roadTypeAIid = siblings[i].roadTypeAI.id;
					if (QDQDOOQQDQODD.ODCDDDQCQQ(roadTypeAI, siblings[i].roadTypeAI))
					{
						siblings[i].laneData.connectors.Clear();
						for (int j = 0; j < siblings.Count; j++)
						{
							ERLaneData laneData = siblings[i].laneData;
							for (int k = 0; k < laneData.connectors.Count; k++)
							{
								if (laneData.connectors[k].endLaneIndex == i)
								{
									laneData.connectors.RemoveAt(k);
									k--;
								}
							}
						}
						siblings[i].aIInit = false;
					}
				}
				if (siblings[i].aIInit)
				{
					continue;
				}
				ERLaneData laneData2 = siblings[i].laneData;
				if (siblings[i].roadTypeAI == null)
				{
					siblings[i].roadTypeAI = siblings[i].roadType;
				}
				for (int l = 0; l < siblings[i].roadTypeAI.roadShapeData.lanes.Count; l++)
				{
					if (siblings[i].roadTypeAI.roadShapeData.lanes[l].direction != ERLaneDirection.Right)
					{
						continue;
					}
					int num = -1;
					if (siblings[i] == primaryPriorityConnection)
					{
						num = 0;
					}
					else if (siblings[i] == secondPriorityConnection)
					{
						num = 1;
					}
					for (int m = 0; m < siblings.Count; m++)
					{
						if (siblings[m].leftRoundingPoints.Count == 0 || siblings[m].rightRoundingPoints.Count == 0)
						{
							return;
						}
						if (m == i)
						{
							continue;
						}
						if (siblings[m].roadTypeAI.roadShapeData.leftLanes == -1)
						{
							siblings[m].roadTypeAI.ODQQQODOQD();
						}
						for (int n = 0; n < siblings[m].roadTypeAI.roadShapeData.leftLanes; n++)
						{
							bool stop = false;
							if (siblings[i].buildPriority == 1)
							{
								stop = true;
							}
							if (siblings[m].buildPriority == 1)
							{
								stop = OCODDQQOCQ(siblings, i, m, l);
							}
							ERLaneConnector eRLaneConnector = OCODCDQQOQ(cScr, i, l, m, n, stop);
							eRLaneConnector.minSpeed = siblings[m].roadTypeAI.minSpeed;
							eRLaneConnector.maxSpeed = siblings[m].roadTypeAI.maxSpeed;
							eRLaneConnector.speedLimit = siblings[m].roadTypeAI.speedLimit;
							if (eRLaneConnector != null)
							{
								laneData2.connectors.Add(eRLaneConnector);
							}
						}
						if (siblings[i].roadTypeAI.roadShapeData.leftLanes == -1)
						{
							siblings[i].roadTypeAI.ODQQQODOQD();
						}
						ERLaneData laneData3 = siblings[m].laneData;
						for (int num2 = 0; num2 < siblings[m].roadTypeAI.roadShapeData.lanes.Count; num2++)
						{
							if (siblings[m].roadTypeAI.roadShapeData.lanes[num2].direction != ERLaneDirection.Right)
							{
								continue;
							}
							num = -1;
							if (siblings[m] == primaryPriorityConnection)
							{
								num = 0;
							}
							else if (siblings[m] == secondPriorityConnection)
							{
								num = 1;
							}
							for (int num3 = 0; num3 < siblings[i].roadTypeAI.roadShapeData.leftLanes; num3++)
							{
								if (!laneData3.Exists(i, num3))
								{
									bool stop2 = false;
									if (siblings[i].buildPriority == 1)
									{
										stop2 = true;
									}
									if (siblings[i].buildPriority == 1)
									{
										stop2 = OCODDQQOCQ(siblings, m, i, num2);
									}
									ERLaneConnector eRLaneConnector2 = OCODCDQQOQ(cScr, m, num2, i, num3, stop2);
									eRLaneConnector2.minSpeed = siblings[i].roadTypeAI.minSpeed;
									eRLaneConnector2.maxSpeed = siblings[i].roadTypeAI.maxSpeed;
									eRLaneConnector2.speedLimit = siblings[i].roadTypeAI.speedLimit;
									if (eRLaneConnector2 != null)
									{
										laneData3.connectors.Add(eRLaneConnector2);
									}
								}
							}
						}
					}
				}
			}
		}
		for (int num4 = 0; num4 < siblings.Count && siblings[num4].leftRoundingPoints.Count != 0 && siblings[num4].rightRoundingPoints.Count != 0; num4++)
		{
			if (!hasLaneControlData)
			{
				siblings[num4].roadTypeAI = siblings[num4].roadType;
				siblings[num4].roadTypeAIid = siblings[num4].roadTypeAI.id;
				if (prefabScript.crossingElements[num4].connectedRoad != null)
				{
					if (prefabScript.crossingElements[num4].connectedRoad.roadType != 0.0 && prefabScript.crossingElements[num4].connectedRoad.roadType != siblings[num4].roadTypeAIid)
					{
						QDQDOOQQDQODD roadTypeAI2 = siblings[num4].roadTypeAI;
						bool flag2 = true;
						siblings[num4].roadTypeAI = (prefabScript.crossingElements[num4].connectedRoad.rt = QDQDOOQQDQODD.GetRoadTypeElByID(prefabScript.crossingElements[num4].connectedRoad.baseScript.roadTypes, prefabScript.crossingElements[num4].connectedRoad.roadType));
						siblings[num4].roadTypeAIid = siblings[num4].roadTypeAI.id;
					}
				}
				else if (prefabScript.baseScript.aiIgnoreConnections)
				{
					continue;
				}
			}
			if (siblings[num4].roadTypeAI == null)
			{
				siblings[num4].roadTypeAI = siblings[num4].roadType;
			}
			if (siblings[num4].roadTypeAI == null)
			{
				break;
			}
			ERLaneData laneData4 = siblings[num4].laneData;
			siblings[num4].aIInit = true;
			if (siblings[num4].road == null)
			{
				siblings[num4].road = prefabScript.crossingElements[num4].connectedRoad;
			}
			if (siblings[num4].roadTypeAI.roadShapeData.leftLanes == -1)
			{
				siblings[num4].roadTypeAI.ODQQQODOQD();
			}
			if (!hasLaneControlData)
			{
				if (laneData4 == null)
				{
					break;
				}
				laneData4.connectors.Clear();
				ERLaneDirection eRLaneDirection = ERLaneDirection.Right;
				if (prefabScript.baseScript.rightHandDriving == 0)
				{
					eRLaneDirection = ERLaneDirection.Left;
				}
				bool flag3 = !prefabScript.baseScript.aiMatchingLanesOnly;
				int num5 = 0;
				int num6 = 0;
				if (!siblings[num4].roadTypeAI.roadShapeData.isset)
				{
					continue;
				}
				for (int num7 = 0; num7 < siblings[num4].roadTypeAI.roadShapeData.lanes.Count; num7++)
				{
					if (siblings[num4].roadTypeAI.roadShapeData.lanes[num7].direction != eRLaneDirection)
					{
						continue;
					}
					if (prefabScript.baseScript.rightHandDriving == 1)
					{
						num6 = siblings[num4].roadTypeAI.roadShapeData.rightLanes - num5 - 1;
						num6 = siblings[num4].roadTypeAI.roadShapeData.lanes[num7].laneIndex;
					}
					else
					{
						num6 = siblings[num4].roadTypeAI.roadShapeData.leftLanes - num5 - 1;
						num6 = siblings[num4].roadTypeAI.roadShapeData.lanes[num7].laneIndex;
					}
					int num8 = -1;
					if (siblings[num4] == primaryPriorityConnection)
					{
						num8 = 0;
					}
					else if (siblings[num4] == secondPriorityConnection)
					{
						num8 = 1;
					}
					for (int num9 = 0; num9 < siblings.Count; num9++)
					{
						if (prefabScript.crossingElements[num9].connectedRoad == null && prefabScript.baseScript.aiIgnoreConnections)
						{
							continue;
						}
						if (siblings[num9].leftRoundingPoints.Count == 0 || siblings[num9].rightRoundingPoints.Count == 0)
						{
							return;
						}
						if (num9 == num4)
						{
							continue;
						}
						if (siblings[num9].roadTypeAI == null)
						{
							siblings[num9].roadTypeAI = siblings[num9].roadType;
						}
						if (siblings[num9].roadTypeAI.roadShapeData.leftLanes == -1)
						{
							siblings[num9].roadTypeAI.ODQQQODOQD();
						}
						int num10 = 0;
						int num11 = 0;
						if (prefabScript.baseScript.rightHandDriving == 1)
						{
							num10 = 0;
							num11 = siblings[num9].roadTypeAI.roadShapeData.leftLanes;
						}
						else
						{
							num10 = siblings[num9].roadTypeAI.roadShapeData.leftLanes;
							num11 = siblings[num9].roadTypeAI.roadShapeData.lanes.Count;
						}
						int num12 = -1;
						if (num6 >= num11 && !flag3 && prefabScript.baseScript.aiconnectNonMatchinglaneCounts)
						{
							num12 = num11 - 1;
						}
						for (int num13 = num10; num13 < num11; num13++)
						{
							if (num6 == num13 - num10 || flag3 || num13 - num10 == num12)
							{
								bool stop3 = false;
								if (siblings[num4].buildPriority == 1)
								{
									stop3 = true;
								}
								if (siblings[num9].buildPriority == 1)
								{
									stop3 = OCODDQQOCQ(siblings, num4, num9, num7);
								}
								ERLaneConnector eRLaneConnector3 = OCODCDQQOQ(cScr, num4, num7, num9, num13, stop3);
								eRLaneConnector3.minSpeed = siblings[num9].roadTypeAI.minSpeed;
								eRLaneConnector3.maxSpeed = siblings[num9].roadTypeAI.maxSpeed;
								eRLaneConnector3.speedLimit = siblings[num9].roadTypeAI.speedLimit;
								if (eRLaneConnector3 != null && eRLaneConnector3.points.Length > 2)
								{
									laneData4.connectors.Add(eRLaneConnector3);
								}
							}
						}
					}
					num5++;
				}
			}
			else
			{
				for (int num14 = 0; num14 < laneData4.connectors.Count; num14++)
				{
					ERLaneConnector conn = laneData4.connectors[num14];
					OQQDCODOQD(cScr.prefabScript, ref conn, num4);
				}
			}
		}
	}

	public static ERLaneConnector OCODCDQQOQ(ERCrossings scr, int startConnectionIndex, int startLaneIndex, int endConnectionIndex, int endLaneIndex, bool stop)
	{
		ERLaneConnector conn = ERLaneConnector.CreateInstance();
		conn.startLaneIndex = startLaneIndex;
		conn.endConnectionIndex = endConnectionIndex;
		conn.endLaneIndex = endLaneIndex;
		conn.stop = stop;
		OQQDCODOQD(scr.prefabScript, ref conn, startConnectionIndex);
		return conn;
	}

	public static void OQQDCODOQD(ERCrossingPrefabs scr, ref ERLaneConnector conn, int startConnectionIndex)
	{
		bool flag = false;
		if (scr.siblings[startConnectionIndex].buildPriority == 0 && scr.siblings[conn.endConnectionIndex].buildPriority == 0 && (scr.siblings[startConnectionIndex] == primaryPriorityConnection || scr.siblings[conn.endConnectionIndex] == primaryPriorityConnection))
		{
			flag = true;
		}
		int num = -1;
		if (scr.siblings[startConnectionIndex] == primaryPriorityConnection && scr.siblings[conn.endConnectionIndex].buildPriority == 0)
		{
			num = 0;
		}
		else if (scr.siblings[conn.endConnectionIndex] == primaryPriorityConnection && scr.siblings[startConnectionIndex].buildPriority == 0)
		{
			num = 1;
		}
		bool mainConnection = false;
		if (num != -1)
		{
			mainConnection = true;
		}
		if (scr.siblings[conn.endConnectionIndex].roadTypeAI.roadShapeData.lanes.Count == 0)
		{
			if (scr.baseScript.debugMode)
			{
				UnityEngine.Debug.Log("EasyRoads3Dv3: road type " + scr.siblings[conn.endConnectionIndex].roadTypeAI.roadTypeName + " does not have lane info set");
			}
			return;
		}
		if (scr.siblings[startConnectionIndex].roadTypeAI.roadShapeData.lanes.Count == 0)
		{
			if (scr.baseScript.debugMode)
			{
				UnityEngine.Debug.Log("EasyRoads3Dv3: road type " + scr.siblings[startConnectionIndex].roadTypeAI.roadTypeName + " does not have lane info set");
			}
			return;
		}
		if (conn.startLaneIndex >= scr.siblings[startConnectionIndex].roadTypeAI.roadShapeData.lanes.Count || conn.endLaneIndex >= scr.siblings[conn.endConnectionIndex].roadTypeAI.roadShapeData.lanes.Count)
		{
			conn = null;
			return;
		}
		if (scr.baseScript.rightHandDriving == 1)
		{
			conn.connectorStartLocal = Vector3.Lerp(scr.crossingElements[startConnectionIndex].centerPoint, scr.siblings[startConnectionIndex].rightRoundingPoints[0], scr.siblings[startConnectionIndex].roadTypeAI.roadShapeData.lanes[conn.startLaneIndex].position);
			conn.connectorEndLocal = Vector3.Lerp(scr.crossingElements[conn.endConnectionIndex].centerPoint, scr.siblings[conn.endConnectionIndex].leftRoundingPoints[0], -1f * scr.siblings[conn.endConnectionIndex].roadTypeAI.roadShapeData.lanes[conn.endLaneIndex].position);
		}
		else
		{
			conn.connectorStartLocal = Vector3.Lerp(scr.crossingElements[startConnectionIndex].centerPoint, scr.siblings[startConnectionIndex].leftRoundingPoints[0], -1f * scr.siblings[startConnectionIndex].roadTypeAI.roadShapeData.lanes[conn.startLaneIndex].position);
			conn.connectorEndLocal = Vector3.Lerp(scr.crossingElements[conn.endConnectionIndex].centerPoint, scr.siblings[conn.endConnectionIndex].rightRoundingPoints[0], scr.siblings[conn.endConnectionIndex].roadTypeAI.roadShapeData.lanes[conn.endLaneIndex].position);
		}
		conn.connectorStart = scr.transform.TransformPoint(conn.connectorStartLocal);
		conn.connectorEnd = scr.transform.TransformPoint(conn.connectorEndLocal);
		conn.mainConnection = mainConnection;
		List<Vector3> list = new List<Vector3>();
		List<Vector3> list2 = new List<Vector3>();
		float num2 = 0f;
		int num3 = 0;
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 0f;
		float num7 = 0f;
		float num8 = 0f;
		float num9 = 0f;
		if (flag)
		{
			if (num == 0)
			{
				if (scr.baseScript.rightHandDriving == 1)
				{
					list2 = new List<Vector3>(scr.siblings[startConnectionIndex].priorityRightPoints);
				}
				else
				{
					list2 = new List<Vector3>(scr.siblings[startConnectionIndex].priorityLeftPoints);
					list2.Reverse();
				}
			}
			else if (scr.baseScript.rightHandDriving == 1)
			{
				list2 = new List<Vector3>(scr.siblings[conn.endConnectionIndex].priorityLeftPoints);
				list2.Reverse();
			}
			else
			{
				list2 = new List<Vector3>(scr.siblings[startConnectionIndex].priorityRightPoints);
			}
			num7 = Vector3.Distance(conn.connectorStartLocal, list2[0]);
			num8 = Vector3.Distance(conn.connectorEndLocal, list2[list2.Count - 1]);
			num9 = num7 - num8;
		}
		if (flag && (double)num9 > -0.5 && (double)num9 < 0.5)
		{
			list = new List<Vector3>(list2);
			list2[0] = conn.connectorStartLocal;
			list2[list2.Count - 1] = conn.connectorEndLocal;
			float num10 = 0f;
			float num11 = (float)(list.Count - 2) * 1f;
			for (int i = 1; i < list.Count - 1; i++)
			{
				Vector3 normalized = (list[i - 1] - list[i + 1]).normalized;
				normalized = new Vector3(normalized.z, 0f, 0f - normalized.x).normalized;
				num10 = Mathf.Lerp(num7, num8, (float)i * 1f / num11);
				list2[i] = list[i] + normalized * num10;
				num2 += Vector3.Distance(list2[i - 1], list2[i]);
			}
			num2 += Vector3.Distance(list2[list2.Count - 2], list2[list2.Count - 1]);
		}
		else
		{
			Vector3 connectorStartLocal = conn.connectorStartLocal;
			Vector3 connectorEndLocal = conn.connectorEndLocal;
			Vector3 vector = connectorStartLocal;
			Vector3 vector2 = connectorEndLocal;
			float num12 = Vector3.Distance(connectorStartLocal, connectorEndLocal);
			Vector3 p = connectorStartLocal + scr.siblings[startConnectionIndex].dir * 1f;
			Vector3 vector3 = connectorEndLocal + scr.siblings[conn.endConnectionIndex].dir * 1f;
			Vector3 vector4 = ODQDQDQDQO.OODOQDOODO(connectorStartLocal, p, connectorEndLocal, vector3, flag: false);
			List<Vector3> leftpoints = new List<Vector3>();
			List<Vector3> rightpoints = new List<Vector3>();
			if (Vector3.Angle(scr.siblings[startConnectionIndex].dir, scr.siblings[conn.endConnectionIndex].dir) > 145f)
			{
				num12 = Vector3.Distance(connectorStartLocal, vector3);
				p = connectorStartLocal + -scr.siblings[startConnectionIndex].dir * num12;
				vector3 = connectorEndLocal + -scr.siblings[conn.endConnectionIndex].dir * num12;
				List<Vector3> points = new List<Vector3> { p, connectorStartLocal, connectorEndLocal, vector3 };
				list2 = ODQDQDQDQO.OOODQCOOCC(points, 0.8f, 1f / num12);
				list2[list2.Count - 1] = connectorEndLocal;
			}
			else
			{
				float num13 = Vector3.Distance(connectorStartLocal, vector4);
				float num14 = Vector3.Distance(connectorEndLocal, vector4);
				if (num13 > num14)
				{
					vector = vector4 + -scr.siblings[startConnectionIndex].dir * num14;
				}
				else
				{
					vector2 = vector4 + -scr.siblings[conn.endConnectionIndex].dir * num13;
				}
				num12 = Vector3.Distance(vector, vector2);
				int cornerSegments = Mathf.RoundToInt(num12);
				float radius = num12 / conn.strength;
				GetOCOCQCDDCD(vector4, radius, cornerSegments, vector, vector2, ref leftpoints, ref rightpoints, flag: true);
				Vector3 pTarget = scr.siblings[startConnectionIndex].leftRoundingPoints[0];
				int num15 = 0;
				while (num15 < leftpoints.Count && !ODQDQDQDQO.OQCDCDOOCD(pTarget, connectorStartLocal, leftpoints[num15]))
				{
					leftpoints.RemoveAt(num15);
					num15--;
					num15++;
				}
				pTarget = scr.siblings[conn.endConnectionIndex].leftRoundingPoints[0];
				int num16 = 0;
				while (num16 < rightpoints.Count && !ODQDQDQDQO.OQCDCDOOCD(pTarget, connectorEndLocal, rightpoints[num16]))
				{
					rightpoints.RemoveAt(num16);
					num16--;
					num16++;
				}
				rightpoints.Reverse();
				if (rightpoints.Count > 0)
				{
					rightpoints.RemoveAt(0);
				}
				list2.AddRange(leftpoints);
				list2.AddRange(rightpoints);
				list2.Insert(0, connectorStartLocal);
				list2.Add(connectorEndLocal);
			}
			for (int j = 1; j < list2.Count; j++)
			{
				num2 += Vector3.Distance(list2[j - 1], list2[j]);
			}
		}
		num3 = Mathf.RoundToInt(num2 / 2f);
		num4 = num2 / ((float)num3 * 1f);
		list.Clear();
		list.Add(scr.transform.TransformPoint(list2[0]));
		num5 = 0f;
		num6 = 0f;
		float num17 = Vector3.Distance(list2[0], list2[1]);
		if (num17 > num4 * 1.5f)
		{
			float num18 = Mathf.RoundToInt(num17 / 2f);
			float num19 = num17 / (num18 * 1f);
			Vector3 normalized = (list2[1] - list2[0]).normalized;
			for (int k = 1; (float)k <= num18; k++)
			{
				list.Add(scr.transform.TransformPoint(list2[0] + normalized * k * num19));
			}
		}
		for (int l = 1; l < list2.Count - 1; l++)
		{
			num6 = Vector3.Distance(list2[l], list2[l + 1]);
			if (num5 + num6 > num4)
			{
				float num20 = num4 - num5;
				Vector3 normalized = (list2[l + 1] - list2[l]).normalized;
				Vector3 item = scr.transform.TransformPoint(list2[l] + normalized * num20);
				list.Add(item);
				num5 = num6 - num20;
			}
			else
			{
				num5 += num6;
			}
		}
		float num21 = Vector3.Distance(list2[list2.Count - 1], list2[list2.Count - 2]);
		if (num21 > num4 * 1.5f)
		{
			float num22 = Mathf.RoundToInt(num21 / 2f);
			float num23 = num21 / (num22 * 1f);
			Vector3 normalized = (list2[list2.Count - 1] - list2[list2.Count - 2]).normalized;
			for (int m = 1; (float)m <= num22 - 1f; m++)
			{
				list.Add(scr.transform.TransformPoint(list2[list2.Count - 2] + normalized * m * num23));
			}
		}
		list.Add(scr.transform.TransformPoint(list2[list2.Count - 1]));
		conn.points = list.ToArray();
	}

	public static bool OQQQQQODQD(Vector3 left, Vector3 rightStart, Vector3 rightEnd, ref float angle1, float prevAngle1, float angle2, bool flag)
	{
		float num = angle1;
		if (num < 0f)
		{
			num += 360f;
		}
		if (angle2 < 0f)
		{
			angle2 += 360f;
		}
		else if (angle2 < angle1 && angle1 > 270f)
		{
			angle2 = 360f - angle2;
		}
		if (angle1 != prevAngle1 && Mathf.Abs(num - angle2) < 45f)
		{
			if (ODQDQDQDQO.OQCDCDOOCD(rightStart, rightEnd, left) == flag)
			{
				angle1 = prevAngle1;
				return false;
			}
			if (Vector3.Distance(left, rightStart) < 2f)
			{
				angle1 = prevAngle1;
				return false;
			}
		}
		return true;
	}

	public static Vector3 OODQQDCDCD(float distance, float angle)
	{
		return ODQDQDQDQO.OQDDDODCOC(new Vector3(0f, 0f, 0f - distance), Vector3.zero, Quaternion.Euler(0f, angle, 0f));
	}

	public static void OQDOCDCQCD(Vector3 cp, float roadWidth, ref Vector3 lStart, ref Vector3 lEnd, ref Vector3 rStart, ref Vector3 rEnd, float largestRadius)
	{
		largestRadius += 5f;
		Vector3 normalized = (Vector3.zero - cp).normalized;
		Vector3 normalized2 = new Vector3(0f - normalized.z, normalized.y, normalized.x).normalized;
		lStart = cp + normalized2 * 0.5f * roadWidth;
		lStart += -normalized * largestRadius;
		lEnd = lStart + normalized * roadWidth * 2f;
		rStart = cp + -normalized2 * 0.5f * roadWidth;
		rStart += -normalized * largestRadius;
		rEnd = rStart + normalized * roadWidth * 2f;
	}

	public static void GetOCOCQCDDCD(Vector3 cp, float radius, int cornerSegments, Vector3 leftPoint, Vector3 rightPoint, ref List<Vector3> leftpoints, ref List<Vector3> rightpoints, bool flag)
	{
		leftpoints.Clear();
		Vector3 normalized = (leftPoint - cp).normalized;
		if (flag)
		{
			leftPoint = cp + normalized * radius;
			normalized = (rightPoint - cp).normalized;
			rightPoint = cp + normalized * radius;
		}
		Vector3 normalized2 = (cp - leftPoint).normalized;
		Vector3 normalized3 = (rightPoint - leftPoint).normalized;
		Vector3 normalized4 = (cp - rightPoint).normalized;
		Vector3 normalized5 = (leftPoint - rightPoint).normalized;
		for (int i = 0; i <= cornerSegments; i++)
		{
			normalized = Vector3.Lerp(normalized2, normalized3, (float)i * 1f / ((float)cornerSegments * 1f));
			Vector3 vector = leftPoint - normalized * 10f;
			Vector3 vector2 = leftPoint + normalized * 10f;
			ll1.Add(vector);
			ll2.Add(vector2);
			normalized = Vector3.Lerp(normalized5, normalized4, (float)i * 1f / ((float)cornerSegments * 1f));
			Vector3 vector3 = rightPoint - normalized * 10f;
			Vector3 vector4 = rightPoint + normalized * 10f;
			ll3.Add(vector3);
			ll4.Add(vector4);
			leftpoints.Add(ODQDQDQDQO.OODOQDOODO(vector, vector2, vector3, vector4, flag: false));
		}
		if (flag)
		{
			rightpoints = new List<Vector3>(leftpoints);
			int num = Mathf.RoundToInt(Mathf.Ceil((float)cornerSegments * 0.5f));
			leftpoints.RemoveRange(num + 1, cornerSegments - num);
			rightpoints.Reverse();
			rightpoints.RemoveRange(num + 1, cornerSegments - num);
		}
	}

	private static void OOCCQCDQQC(List<Vector3> rightPoints1, List<Vector3> leftPoints1, List<Vector3> leftPoints2, List<Vector3> rightPoints2, ref List<Vector3> outerpoints, ref List<Vector3> innerpoints, float dist)
	{
		outerpoints.Clear();
		innerpoints.Clear();
		innerpoints.AddRange(rightPoints1);
		for (int i = 0; i < rightPoints1.Count; i++)
		{
			Vector3 normalized;
			if (i == 0)
			{
				normalized = (leftPoints1[0] - rightPoints1[0]).normalized;
			}
			else if (i < rightPoints1.Count - 1)
			{
				normalized = (rightPoints1[i + 1] - rightPoints1[i - 1]).normalized;
				normalized = new Vector3(0f - normalized.z, 0f, normalized.x).normalized;
			}
			else
			{
				normalized = (rightPoints1[i] - rightPoints1[i - 1]).normalized;
				normalized = new Vector3(0f - normalized.z, 0f, normalized.x).normalized;
			}
			outerpoints.Add(rightPoints1[i] + normalized * dist);
		}
		int num = outerpoints.Count - 1;
		List<Vector3> list = new List<Vector3>();
		for (int j = 0; j < leftPoints2.Count; j++)
		{
			Vector3 normalized;
			if (j == 0)
			{
				normalized = (rightPoints2[0] - leftPoints2[0]).normalized;
			}
			else if (j < leftPoints2.Count - 1)
			{
				normalized = (leftPoints2[j + 1] - leftPoints2[j - 1]).normalized;
				normalized = new Vector3(normalized.z, 0f, 0f - normalized.x).normalized;
			}
			else
			{
				normalized = (leftPoints2[j] - leftPoints2[j - 1]).normalized;
				normalized = new Vector3(normalized.z, 0f, 0f - normalized.x).normalized;
			}
			list.Add(leftPoints2[j] + normalized * dist);
		}
		list.Reverse();
		outerpoints.AddRange(list);
		List<Vector3> list2 = new List<Vector3>(leftPoints2);
		list2.Reverse();
		list2.RemoveAt(0);
		innerpoints.AddRange(list2);
		List<Vector3> obj = outerpoints;
		Vector3 value = (outerpoints[num + 1] = Vector3.Lerp(outerpoints[num], outerpoints[num + 1], 0.5f));
		obj[num] = value;
		outerpoints.RemoveAt(num + 1);
	}

	private void OOOQOQODDD(ref float uvRatio, ref List<Vector3> priorityLeftPoints, ref List<Vector3> priorityRightPoints, ref List<Vector3> rightRoundingPoints, ref List<Vector3> leftRoundingPoints, ref List<Vector3> leftRoundingPointsOther, ref List<Vector3> rightRoundingPointsOther)
	{
		float num = 0f;
		Vector3 a = Vector3.Lerp(priorityLeftPoints[0], priorityRightPoints[0], 0.5f);
		for (int i = 1; i < priorityLeftPoints.Count; i++)
		{
			Vector3 vector = Vector3.Lerp(priorityLeftPoints[i], priorityRightPoints[i], 0.5f);
			num += Vector3.Distance(a, vector);
			a = vector;
		}
		float num2 = Mathf.Floor(num / uvRatio) + 1f;
		float num3 = (num2 * uvRatio - num) * 0.5f;
		Vector3 normalized = (priorityLeftPoints[0] - priorityLeftPoints[1]).normalized;
		Vector3 item = priorityLeftPoints[0] + normalized * num3;
		priorityLeftPoints.Insert(0, item);
		leftRoundingPoints.Insert(0, item);
		item = priorityRightPoints[0] + normalized * num3;
		priorityRightPoints.Insert(0, item);
		rightRoundingPoints.Insert(0, item);
		normalized = (priorityLeftPoints[priorityLeftPoints.Count - 1] - priorityLeftPoints[priorityLeftPoints.Count - 2]).normalized;
		item = priorityLeftPoints[priorityLeftPoints.Count - 1] + normalized * num3;
		priorityLeftPoints.Add(item);
		rightRoundingPointsOther.Insert(0, item);
		item = priorityRightPoints[priorityRightPoints.Count - 1] + normalized * num3;
		priorityRightPoints.Add(item);
		leftRoundingPointsOther.Insert(0, item);
	}

	private static bool OOCOCOCDQD(float radius, int cornerSegments, Vector3 startPoint, Vector3 endPoint, ref List<Vector3> points, ref List<Vector3> priorityPoints, float curvature, bool swapflag, bool priorityIsSingleSection, Vector3 prioritySectionDir, int leftright, bool leftRightCheck, ref int mainIndex, ref bool insertFlag)
	{
		points.Clear();
		Vector3 vector = cScr.transform.InverseTransformPoint(startPoint);
		Vector3 vector2 = cScr.transform.InverseTransformPoint(endPoint);
		vector.y = (vector2.y = 0f);
		Vector3 vector3 = ODQDQDQDQO.OODOQDOODO(startPoint, endPoint, priorityPoints[0], priorityPoints[priorityPoints.Count - 1], flag: false);
		Vector3 zero;
		Vector3 vector4 = (zero = Vector3.zero);
		if ((double)curvature < 0.05)
		{
			curvature = 0.05f;
		}
		float num = radius * curvature;
		float num2 = num * 0.1f;
		int num3 = -1;
		int num4 = -1;
		float num6;
		float num5 = (num6 = 100000f);
		float num7 = 0f;
		if (swapflag)
		{
			bool flag = ODQDQDQDQO.OQCDCDOOCD(startPoint, endPoint, priorityPoints[priorityPoints.Count - 1]);
			for (int num8 = priorityPoints.Count - 1; num8 >= 0; num8--)
			{
				if (ODQDQDQDQO.OQCDCDOOCD(startPoint, endPoint, priorityPoints[num8]) != flag)
				{
					if (num8 == priorityPoints.Count - 1)
					{
						UnityEngine.Debug.Log("EasyRoads3Dv3: crosspoint is outside first priority index");
						Vector3 p = priorityPoints[priorityPoints.Count - 1] + -prioritySectionDir * 2f;
						Vector3 vector5 = ODQDQDQDQO.OODOQDOODO(startPoint, endPoint, priorityPoints[priorityPoints.Count - 1], p, flag: false);
						num3 = priorityPoints.Count - 2;
						num4 = priorityPoints.Count - 1;
					}
					else
					{
						num3 = num8;
						num4 = num3 + 1;
					}
					break;
				}
			}
		}
		else
		{
			bool flag2 = ODQDQDQDQO.OQCDCDOOCD(startPoint, endPoint, priorityPoints[0]);
			for (int i = 0; i < priorityPoints.Count; i++)
			{
				if (ODQDQDQDQO.OQCDCDOOCD(startPoint, endPoint, priorityPoints[i]) != leftRightCheck)
				{
					if (i == 0)
					{
						Vector3 p2 = priorityPoints[0] + -prioritySectionDir * 2f;
						Vector3 vector6 = ODQDQDQDQO.OODOQDOODO(startPoint, endPoint, priorityPoints[0], p2, flag: false);
						num3 = 1;
						num4 = 0;
					}
					else
					{
						num3 = i;
						num4 = i - 1;
					}
					break;
				}
			}
		}
		if (num4 < 0)
		{
			num4 = 0;
			if (num4 == num3)
			{
				num4++;
			}
		}
		else if (num4 >= priorityPoints.Count)
		{
			num4 = priorityPoints.Count - 1;
			if (num4 == num3)
			{
				num4--;
			}
		}
		if (num3 == -1 || num4 == -1)
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3 Error: These angles between connections is not supported for the involved road types");
			return false;
		}
		vector3 = ODQDQDQDQO.OODOQDOODO(startPoint, endPoint, priorityPoints[num3], priorityPoints[num4], flag: false);
		int num9 = -1;
		bool flag3 = false;
		if (swapflag)
		{
			int num10 = num3 + 1;
			if (num4 < num3)
			{
				num10 = num3;
			}
			float num11 = Vector3.Distance(vector3, priorityPoints[num10]);
			if (num11 > num)
			{
				if (num11 < num + num2)
				{
					vector4 = priorityPoints[num10];
					num9 = num10;
				}
				else
				{
					zero = (priorityPoints[num10] - vector3).normalized;
					vector4 = vector3 + zero * num;
					num9 = num10;
					flag3 = true;
				}
			}
			else
			{
				for (int j = num10; j < priorityPoints.Count - 1; j++)
				{
					num7 = Vector3.Distance(priorityPoints[j], priorityPoints[j + 1]);
					if (num7 + num11 > num)
					{
						if (num7 + num11 < num + num2)
						{
							vector4 = priorityPoints[j + 1];
							num9 = j + 1;
							break;
						}
						zero = (priorityPoints[j + 1] - priorityPoints[j]).normalized;
						vector4 = priorityPoints[j] + zero * (num - num11);
						num9 = j + 1;
						flag3 = true;
						break;
					}
					num11 += num7;
					if (num11 + num2 > num)
					{
						vector4 = priorityPoints[j + 1];
						num9 = j + 1;
						break;
					}
				}
			}
			if (num9 == -1)
			{
				vector4 = priorityPoints[priorityPoints.Count - 1];
				zero = (priorityPoints[priorityPoints.Count - 1] - priorityPoints[priorityPoints.Count - 2]).normalized;
				float num12 = num - num11;
				vector4 += zero * num12;
				priorityPoints.Add(vector4);
				priorityPoints.Add(vector4 + zero * 0.5f);
			}
		}
		else
		{
			int num13 = num3;
			if (num4 < num3)
			{
				num13 = num4;
			}
			float num14 = Vector3.Distance(vector3, priorityPoints[num13]);
			if (num14 > num)
			{
				if (num14 < num + num2)
				{
					vector4 = priorityPoints[num13];
					num9 = num13;
				}
				else
				{
					zero = (priorityPoints[num13] - vector3).normalized;
					vector4 = vector3 + zero * num;
					num9 = num13 + 1;
					flag3 = true;
				}
			}
			else
			{
				for (int num15 = num13; num15 > 0; num15--)
				{
					num7 = Vector3.Distance(priorityPoints[num15], priorityPoints[num15 - 1]);
					if (num7 + num14 > num)
					{
						if (num7 + num14 < num + num2)
						{
							vector4 = priorityPoints[num15 - 1];
							num9 = num15 - 1;
							break;
						}
						zero = (priorityPoints[num15 - 1] - priorityPoints[num15]).normalized;
						vector4 = priorityPoints[num15] + zero * (num - num14);
						num9 = num15;
						flag3 = true;
						break;
					}
					num14 += num7;
					if (num14 + num2 > num)
					{
						vector4 = priorityPoints[num15 - 1];
						num9 = num15 - 1;
						break;
					}
				}
			}
			if (num9 == -1)
			{
				vector4 = priorityPoints[0];
				zero = (priorityPoints[0] - priorityPoints[1]).normalized;
				float num16 = num - num14;
				vector4 += zero * num16;
				priorityPoints.Insert(0, vector4);
				priorityPoints.Insert(0, vector4 + zero * 0.5f);
			}
		}
		Vector3 normalized = (vector3 - startPoint).normalized;
		Vector3 vector7 = vector3 + -normalized * radius;
		Vector3 normalized2 = (vector4 - vector7).normalized;
		Vector3 normalized3 = (vector3 - vector4).normalized;
		Vector3 normalized4 = (vector7 - vector4).normalized;
		normalized3 = Vector3.Lerp(normalized4, normalized3, curvature);
		for (int k = 0; k <= cornerSegments; k++)
		{
			Vector3 vector8 = Vector3.Lerp(normalized, normalized2, (float)k * 1f / ((float)cornerSegments * 1f));
			Vector3 p3 = vector7 - vector8 * 10f;
			Vector3 p4 = vector7 + vector8 * 10f;
			vector8 = Vector3.Lerp(normalized4, normalized3, (float)k * 1f / ((float)cornerSegments * 1f));
			Vector3 p5 = vector4 - vector8 * 10f;
			Vector3 p6 = vector4 + vector8 * 10f;
			points.Add(ODQDQDQDQO.OODOQDOODO(p3, p4, p5, p6, flag: false));
		}
		if (flag3)
		{
			if (num9 - 1 >= 0)
			{
				float num17 = Vector3.Distance(vector4, priorityPoints[num9 - 1]);
				float num18 = Vector3.Distance(priorityPoints[num9], priorityPoints[num9 - 1]);
				if (num18 < num17)
				{
					num9++;
				}
			}
			if (priorityPoints.Count > num9 + 1)
			{
				float num19 = Vector3.Distance(vector4, priorityPoints[num9 + 1]);
				float num20 = Vector3.Distance(priorityPoints[num9], priorityPoints[num9 + 1]);
				if (num19 < num20)
				{
					num9++;
				}
			}
			priorityPoints.Insert(num9, vector4);
			insertFlag = flag3;
		}
		mainIndex = num9;
		return true;
	}

	private static void MatchLeftRights(ref List<Vector3> leftRoundingPoints, Vector3 lStart, ref List<Vector3> rightRoundingPoints, Vector3 rStart)
	{
		float num = Vector3.Distance(lStart, leftRoundingPoints[0]);
		float num2 = Vector3.Distance(rStart, rightRoundingPoints[0]);
		float num3 = 1f;
		if (num > num2)
		{
			float num4 = num - num2;
			Vector3 normalized = (lStart - leftRoundingPoints[0]).normalized;
			Vector3 value = leftRoundingPoints[0] + normalized * num4;
			if ((double)num4 > 0.25)
			{
				leftRoundingPoints.Insert(0, leftRoundingPoints[0] + normalized * num4 * num3);
			}
			else
			{
				leftRoundingPoints[0] = value;
			}
		}
		else if (num < num2)
		{
			float num5 = num2 - num;
			Vector3 normalized2 = (rStart - rightRoundingPoints[0]).normalized;
			Vector3 value2 = rightRoundingPoints[0] + normalized2 * num5;
			if ((double)num5 > 0.25)
			{
				rightRoundingPoints.Insert(0, rightRoundingPoints[0] + normalized2 * num5 * num3);
			}
			else
			{
				rightRoundingPoints[0] = value2;
			}
		}
	}

	public static void OOCDCOQDDO(List<Vector3> leftRoundingPoints, List<Vector3> rightRoundingPoints, ref List<List<Vector3>> roadVecs, List<Vector2> roadShape, int leftFixedPoint, int rightFixedPoint, int middleIndex, Vector3 cp, Vector3 cp1, ref List<Vector3> priorityPointsMain, ERConnectionSibling prioritySibling, bool isSecondary)
	{
		int num = 0;
		for (int i = 0; i < leftRoundingPoints.Count; i++)
		{
			Vector3 normalized;
			if (i == 0)
			{
				normalized = (rightRoundingPoints[0] - leftRoundingPoints[0]).normalized;
			}
			else if (i == leftRoundingPoints.Count - 1)
			{
				normalized = (crossPointCenter - leftRoundingPoints[i]).normalized;
			}
			else
			{
				normalized = (leftRoundingPoints[i + 1] - leftRoundingPoints[i - 1]).normalized;
				normalized = new Vector3(normalized.z, 0f, 0f - normalized.x).normalized;
			}
			for (int j = 0; j <= middleIndex; j++)
			{
				if (roadVecs.Count <= j)
				{
					roadVecs.Add(new List<Vector3>());
				}
				Vector3 vector;
				if (j <= leftFixedPoint)
				{
					vector = leftRoundingPoints[i] + normalized * (roadShape[j].x - roadShape[0].x);
					vector.y = roadShape[j].y;
				}
				else
				{
					vector = leftRoundingPoints[i] + normalized * (roadShape[j].x - roadShape[0].x);
					vector.y = roadShape[j].y;
					vector = ODQDQDQDQO.OODOQDOODO(leftRoundingPoints[i], vector, cp, cp1, flag: false);
					vector = Vector3.Lerp(vector, leftRoundingPoints[i], roadShape[j].x / roadShape[0].x);
					vector.y = roadShape[j].y;
				}
				if (!isSecondary || vector != Vector3.zero)
				{
					roadVecs[j].Add(vector);
				}
			}
		}
		for (int k = 0; k < rightRoundingPoints.Count; k++)
		{
			Vector3 normalized;
			if (k == 0)
			{
				normalized = (rightRoundingPoints[k + 1] - rightRoundingPoints[k]).normalized;
				normalized = new Vector3(0f - normalized.z, 0f, normalized.x).normalized;
				normalized = (leftRoundingPoints[0] - rightRoundingPoints[0]).normalized;
			}
			else if (k == rightRoundingPoints.Count - 1)
			{
				normalized = (crossPointCenter - rightRoundingPoints[k]).normalized;
			}
			else
			{
				normalized = (rightRoundingPoints[k + 1] - rightRoundingPoints[k - 1]).normalized;
				normalized = new Vector3(0f - normalized.z, 0f, normalized.x).normalized;
			}
			float x = roadShape[roadShape.Count - 1].x;
			for (int l = middleIndex + 1; l < roadShape.Count; l++)
			{
				if (roadVecs.Count <= l)
				{
					roadVecs.Add(new List<Vector3>());
				}
				Vector3 vector;
				if (l < rightFixedPoint)
				{
					vector = rightRoundingPoints[k] + normalized * (x - roadShape[l].x);
					vector.y = roadShape[l].y;
					vector = ODQDQDQDQO.OODOQDOODO(rightRoundingPoints[k], vector, cp, cp1, flag: false);
					vector = Vector3.Lerp(vector, rightRoundingPoints[k], roadShape[l].x / x);
					vector.y = roadShape[l].y;
				}
				else
				{
					vector = rightRoundingPoints[k] + normalized * (x - roadShape[l].x);
					vector.y = roadShape[l].y;
				}
				if (!isSecondary || vector != Vector3.zero)
				{
					roadVecs[l].Add(vector);
				}
			}
		}
		if (!isSecondary)
		{
			return;
		}
		int num2 = -1;
		int num3 = -1;
		Vector2 vector2 = new Vector2(rightRoundingPoints[rightRoundingPoints.Count - 1].x, rightRoundingPoints[rightRoundingPoints.Count - 1].z);
		Vector2 b = new Vector2(leftRoundingPoints[leftRoundingPoints.Count - 1].x, leftRoundingPoints[leftRoundingPoints.Count - 1].z);
		for (int m = 0; m < priorityPointsMain.Count; m++)
		{
			Vector3 vector3 = cScr.transform.TransformPoint(vector2);
			Vector3 vector4 = cScr.transform.TransformPoint(priorityPointsMain[m]);
			if ((double)Vector2.Distance(new Vector2(priorityPointsMain[m].x, priorityPointsMain[m].z), vector2) < 0.001)
			{
				num2 = m;
			}
			if ((double)Vector2.Distance(new Vector2(priorityPointsMain[m].x, priorityPointsMain[m].z), b) < 0.001)
			{
				num3 = m;
			}
			if (num2 != -1 && num3 != -1)
			{
				break;
			}
		}
		if (num2 > num3)
		{
			int num4 = num2;
			num2 = num3;
			num3 = num4;
		}
		List<Vector2> list = new List<Vector2>();
		List<Vector3> list2 = new List<Vector3>();
		list.Add(new Vector2(leftRoundingPoints[0].x, leftRoundingPoints[0].z));
		float num5 = Vector3.Distance(roadVecs[0][roadVecs[0].Count - 1], priorityPointsMain[0]);
		float num6 = Vector3.Distance(roadVecs[roadVecs.Count - 1][roadVecs[roadVecs.Count - 1].Count - 1], priorityPointsMain[0]);
		if (num5 > num6)
		{
			for (int num7 = num3; num7 >= num2; num7--)
			{
				list.Add(new Vector2(priorityPointsMain[num7].x, priorityPointsMain[num7].z));
				list2.Add(priorityPointsMain[num7]);
			}
		}
		else
		{
			for (int n = num2; n <= num3; n++)
			{
				list.Add(new Vector2(priorityPointsMain[n].x, priorityPointsMain[n].z));
				list2.Add(priorityPointsMain[n]);
			}
		}
		list.Add(new Vector2(rightRoundingPoints[0].x, rightRoundingPoints[0].z));
		int count = roadVecs.Count;
		Vector3 zero = Vector3.zero;
		bool flag = true;
		if (ODQDQDQDQO.OQCDCDOOCD(list2[0], list2[list2.Count - 1], list2[Mathf.RoundToInt((float)list2.Count * 0.5f)]))
		{
			flag = false;
		}
		bool flag2 = true;
		for (int num8 = 1; num8 < roadVecs.Count - 1; num8++)
		{
			int num9 = roadVecs[num8].Count - 1;
			for (int num10 = num9; num10 >= 1; num10--)
			{
				if ((num8 != 0 || num10 != num9) && (num8 != count - 1 || num10 != num9))
				{
					if (!ODDCQDDCDD.OCCQDQQDCC(list.Count, list, roadVecs[num8][num10].x, roadVecs[num8][num10].z))
					{
						roadVecs[num8].RemoveAt(num10);
					}
					else if (num10 != num9)
					{
						zero = Vector3.zero;
						zero = OQOQODOOCD(roadVecs[num8][num10 - 1], roadVecs[num8][num10], roadVecs[num8][num10], priorityPointsMain, 0);
						if (Vector3.Distance(zero, roadVecs[num8][roadVecs[num8].Count - 1]) < 0.5f)
						{
							roadVecs[num8].RemoveAt(roadVecs[num8].Count - 1);
						}
						roadVecs[num8].Add(zero);
						break;
					}
				}
			}
		}
		priorityPointsMain = new List<Vector3>(list2);
		prioritySibling.prioritySectionStart = num2;
		prioritySibling.prioritySectionEnd = num3;
	}

	public static bool OOCOCCQDCQ(Vector3 v, List<Vector3> points, int firstIndex, int lastIndex)
	{
		for (int i = firstIndex; i < lastIndex; i++)
		{
			if (ODQDQDQDQO.OQCDCDOOCD(points[i + 1], points[i], v))
			{
				return false;
			}
		}
		return true;
	}

	public static void OODQCOCOQD(List<Vector3> leftRoundingPoints, List<Vector3> rightRoundingPoints, ref List<List<Vector3>> roadVecs, List<Vector2> roadShape, int leftFixedPoint, int rightFixedPoint, int middleIndex, Vector3 cp, Vector3 cp1)
	{
		int num = 0;
		for (int i = 0; i < leftRoundingPoints.Count; i++)
		{
			Vector3 normalized;
			if (i == 0)
			{
				normalized = (rightRoundingPoints[0] - leftRoundingPoints[0]).normalized;
			}
			else if (i == leftRoundingPoints.Count - 1)
			{
				normalized = (rightRoundingPoints[rightRoundingPoints.Count - 1] - leftRoundingPoints[i]).normalized;
			}
			else
			{
				normalized = (leftRoundingPoints[i + 1] - leftRoundingPoints[i - 1]).normalized;
				normalized = new Vector3(normalized.z, 0f, 0f - normalized.x).normalized;
			}
			for (int j = 0; j <= middleIndex; j++)
			{
				if (roadVecs.Count <= j)
				{
					roadVecs.Add(new List<Vector3>());
				}
				Vector3 item = leftRoundingPoints[i] + normalized * (roadShape[j].x - roadShape[0].x);
				item.y = roadShape[j].y;
				roadVecs[j].Add(item);
			}
		}
		for (int k = 0; k < rightRoundingPoints.Count; k++)
		{
			Vector3 normalized;
			if (k == 0)
			{
				normalized = (leftRoundingPoints[0] - rightRoundingPoints[0]).normalized;
			}
			else if (k == rightRoundingPoints.Count - 1)
			{
				normalized = (leftRoundingPoints[leftRoundingPoints.Count - 1] - rightRoundingPoints[k]).normalized;
			}
			else
			{
				normalized = (rightRoundingPoints[k + 1] - rightRoundingPoints[k - 1]).normalized;
				normalized = new Vector3(0f - normalized.z, 0f, normalized.x).normalized;
			}
			float x = roadShape[roadShape.Count - 1].x;
			for (int l = middleIndex + 1; l < roadShape.Count; l++)
			{
				if (roadVecs.Count <= l)
				{
					roadVecs.Add(new List<Vector3>());
				}
				Vector3 item = rightRoundingPoints[k] + normalized * (x - roadShape[l].x);
				item.y = roadShape[l].y;
				roadVecs[l].Add(item);
			}
		}
	}

	public static void OQQDQCQCDQ(List<Vector3> roundingPoints, ref List<Vector3> pointsIndents, float indent, Vector3 lp, Vector3 rp, bool leftSide)
	{
		pointsIndents.Clear();
		for (int i = 0; i < roundingPoints.Count; i++)
		{
			Vector3 vector;
			if (i == 0)
			{
				vector = (rp - lp).normalized;
			}
			else if (i == roundingPoints.Count - 1)
			{
				vector = (Vector3.zero - roundingPoints[i]).normalized;
			}
			else
			{
				vector = (roundingPoints[i + 1] - roundingPoints[i - 1]).normalized;
				vector = ((!leftSide) ? new Vector3(0f - vector.z, 0f, vector.x).normalized : new Vector3(vector.z, 0f, 0f - vector.x).normalized);
			}
			pointsIndents.Add(roundingPoints[i] + vector * indent);
		}
	}

	public static void OOQQOOOQOO(ref List<Vector3> centerPoints, List<Vector3> leftRoundingPoints, List<Vector3> leftPointsIndents, List<Vector3> rightRoundingPoints, List<Vector3> rightPointsIndents, Vector3 cp)
	{
		List<Vector3> list = leftPointsIndents;
		List<Vector3> list2 = rightPointsIndents;
		if (rightPointsIndents.Count > list.Count)
		{
			list = rightPointsIndents;
			list2 = leftPointsIndents;
		}
		centerPoints.Add(Vector3.Lerp(leftRoundingPoints[0], rightRoundingPoints[0], 0.5f));
		float num = Vector3.Distance(cp, list[1]);
		for (int i = 1; i < list2.Count; i++)
		{
			if (Vector3.Distance(cp, list2[i]) < num)
			{
				centerPoints.Add(ODQDQDQDQO.OQQCQOCCOQ(cp, Vector3.zero, list2[i]));
			}
		}
		for (int j = 1; j < list.Count; j++)
		{
			centerPoints.Add(ODQDQDQDQO.OQQCQOCCOQ(cp, Vector3.zero, list[j]));
		}
	}

	public static void OOCCDOCDDC(ref List<Vector3> centerPoints, List<Vector3> leftRoundingPoints, List<Vector3> leftPointsIndents, List<Vector3> rightRoundingPoints, List<Vector3> rightPointsIndents)
	{
		centerPoints.Clear();
		List<Vector3> list = leftRoundingPoints;
		List<Vector3> list2 = rightRoundingPoints;
		float num = 1f;
		if (rightRoundingPoints.Count > list.Count)
		{
			list = rightRoundingPoints;
			list2 = leftRoundingPoints;
			num = -1f;
		}
		float num2 = Vector3.Distance(leftRoundingPoints[0], rightRoundingPoints[0]) * 0.5f;
		for (int i = 1; i < list.Count - 1; i++)
		{
			Vector3 vector = list[i + 1] - list[i - 1];
			vector = new Vector3(vector.z, 0f, 0f - vector.x).normalized * num;
			centerPoints.Add(list[i + 1] + vector * num2);
		}
	}

	public static void MatchInnerOCOCQCDDCD(ref List<Vector3> innerArray, List<Vector3> startVecs, List<Vector3> endVecs)
	{
		for (int i = 0; i < startVecs.Count && innerArray[i] != startVecs[i]; i++)
		{
			innerArray.Insert(i, startVecs[i]);
		}
		bool flag = false;
		List<Vector3> list = new List<Vector3>(endVecs);
		list.Reverse();
		for (int j = 0; j < list.Count; j++)
		{
			if (flag)
			{
				innerArray.Add(list[j]);
			}
			if (innerArray[innerArray.Count - 1] == list[j])
			{
				flag = true;
			}
		}
	}

	public static void ODDCCDQDCO(ref List<Vector3> targetArray, List<Vector3> otherArray)
	{
		List<Vector3> list = new List<Vector3>(otherArray);
		list.Reverse();
		list.RemoveAt(0);
		targetArray.AddRange(list);
	}

	public static void ERODOCDOOCCC(List<List<Vector3>> roadVecs, List<float> shapeUVs, ref List<List<Vector2>> uvs, List<Vector3> priorityPointsMain, ref List<Vector2> priorityPointsMainUVs, Vector2 cp, float uvRatio, ERConnectionSibling sibling, bool primarySection)
	{
		float num = 0f;
		if (primarySection)
		{
			int middleIndex = sibling.middleIndex;
			for (int i = 1; i < roadVecs[middleIndex].Count; i++)
			{
				num += Vector3.Distance(roadVecs[middleIndex][i - 1], roadVecs[middleIndex][i]);
			}
		}
		List<float> list = new List<float>();
		List<float> list2 = new List<float>();
		list.Add(0f);
		list2.Add(0f);
		for (int j = 0; j < roadVecs.Count; j++)
		{
			uvs.Add(new List<Vector2>());
			float num2 = 0f;
			float num3 = 1f;
			uvs[j].Add(new Vector2(shapeUVs[j], 0f));
			if (primarySection)
			{
				for (int k = 1; k < roadVecs[j].Count; k++)
				{
					num2 += Vector3.Distance(roadVecs[j][k - 1], roadVecs[j][k]);
				}
				num3 = num2 / num;
			}
			num2 = 0f;
			for (int l = 1; l < roadVecs[j].Count; l++)
			{
				num2 += Vector3.Distance(roadVecs[j][l - 1], roadVecs[j][l]);
				if (j == 0)
				{
					list.Add(num2);
				}
				else if (j == roadVecs.Count - 1)
				{
					list2.Add(num2);
				}
				if (primarySection)
				{
					uvs[j].Add(new Vector2(shapeUVs[j], num2 / uvRatio / num3));
				}
				else
				{
					uvs[j].Add(new Vector2(shapeUVs[j], num2 / uvRatio));
				}
			}
		}
		if (priorityPointsMain.Count <= 0)
		{
			return;
		}
		Vector3 vector = Vector3.Lerp(roadVecs[0][0], roadVecs[roadVecs.Count - 1][0], 0.5f);
		Vector3 normalized = (roadVecs[0][0] - roadVecs[roadVecs.Count - 1][0]).normalized;
		normalized = new Vector3(normalized.z, 0f, 0f - normalized.x);
		vector.y = 0f;
		Vector3 vector2 = vector + normalized * 50f;
		int num4 = -1;
		float num5 = 0f;
		float num6 = 0f;
		List<float> list3 = new List<float>();
		list3.Add(0f);
		for (int m = 0; m < priorityPointsMain.Count - 1; m++)
		{
			num5 += Vector3.Distance(priorityPointsMain[m], priorityPointsMain[m + 1]);
			list3.Add(num5);
			if (num4 == -1 && ODQDQDQDQO.OQCDCDOOCD(vector2, vector, priorityPointsMain[m + 1]))
			{
				Vector3 b = ODQDQDQDQO.OODOQDOODO(vector2, vector, priorityPointsMain[m], priorityPointsMain[m + 1], flag: false);
				num6 = num5 - Vector3.Distance(priorityPointsMain[m + 1], b);
				num4 = m + 1;
			}
		}
		bool flag = false;
		Vector3 zero = Vector3.zero;
		int index = 0;
		for (int n = 0; n < priorityPointsMain.Count; n++)
		{
			bool flag2 = false;
			if (n == 0)
			{
				priorityPointsMainUVs.Add(uvs[0][uvs[0].Count - 2]);
				flag2 = true;
			}
			else if (!flag && n < num4)
			{
				zero = ODQQOCDCOC(priorityPointsMain[n], roadVecs[0], ref index, 1);
				float num7 = Vector3.Distance(zero, priorityPointsMain[n]);
				if (num7 < sibling.leftFixedDistance)
				{
					float x = Mathf.Lerp(shapeUVs[0], shapeUVs[sibling.leftFixedIndex], num7 / sibling.leftFixedDistance);
					float y = Mathf.Lerp(uvs[0][uvs[0].Count - 2].y, uvs[sibling.leftFixedIndex][uvs[sibling.leftFixedIndex].Count - 1].y, num7 / sibling.leftFixedDistance);
					priorityPointsMainUVs.Add(new Vector2(x, y));
					flag2 = true;
				}
				else
				{
					flag = true;
				}
			}
			if (n > num4)
			{
				zero = ODQQOCDCOC(priorityPointsMain[n], roadVecs[roadVecs.Count - 1], ref index, 1);
				float num8 = Vector3.Distance(zero, priorityPointsMain[n]);
				if (num8 < sibling.rightFixedDistance)
				{
					float x2 = Mathf.Lerp(shapeUVs[shapeUVs.Count - 1], shapeUVs[sibling.rightFixedIndex], num8 / sibling.rightFixedDistance);
					List<Vector2> list4 = uvs[uvs.Count - 1];
					List<Vector2> list5 = uvs[sibling.rightFixedIndex];
					float y2 = Mathf.Lerp(list4[list4.Count - 1].y, list5[list5.Count - 1].y, num8 / sibling.rightFixedDistance);
					priorityPointsMainUVs.Add(new Vector2(x2, y2));
					flag2 = true;
				}
			}
			if (!flag2)
			{
				Vector3 b2 = ODQDQDQDQO.OQQCQOCCOQ(vector2, vector, priorityPointsMain[n]);
				float num9 = Vector3.Distance(vector, b2);
				if (n <= num4)
				{
					priorityPointsMainUVs.Add(new Vector2(list3[n] / num6 * 0.5f, num9 / uvRatio));
				}
				else
				{
					priorityPointsMainUVs.Add(new Vector2(0.5f + (list3[n] - num6) / (num5 - num6) * 0.5f, num9 / uvRatio));
				}
			}
		}
	}

	public static void OCQODCQDOD(List<Vector3> leftRoundingPoints, List<Vector3> leftPointsIndents, List<Vector3> centerPoints, List<Vector3> rightPointsIndents, List<Vector3> rightRoundingPoints, ref List<Vector2> leftRoundingPointsUV, ref List<Vector2> leftPointsIndentsUV, ref List<Vector2> centerPointsUV, ref List<Vector2> rightPointsIndentsUV, ref List<Vector2> rightRoundingPointsUV, ref Vector2 cp, float leftIndentUVX, float rightIndentUVX)
	{
		centerPointsUV.Clear();
		leftRoundingPointsUV.Clear();
		leftPointsIndentsUV.Clear();
		rightRoundingPointsUV.Clear();
		rightPointsIndentsUV.Clear();
		float num = 0.2f;
		float num2 = 0f;
		centerPointsUV.Add(new Vector2(0.5f, 0f));
		for (int i = 1; i < centerPoints.Count; i++)
		{
			num2 += Vector3.Distance(centerPoints[i - 1], centerPoints[i]);
			centerPointsUV.Add(new Vector2(0.5f, num2 * num));
		}
		num2 += Vector3.Distance(centerPoints[centerPoints.Count - 1], Vector3.zero);
		cp = new Vector2(0.5f, num2 * num);
		num2 = 0f;
		leftRoundingPointsUV.Add(new Vector2(0f, 0f));
		leftPointsIndentsUV.Add(new Vector2(leftIndentUVX, 0f));
		for (int j = 1; j < leftRoundingPoints.Count; j++)
		{
			num2 += Vector3.Distance(leftRoundingPoints[j - 1], leftRoundingPoints[j]);
			leftRoundingPointsUV.Add(new Vector2(0f, num2 * num));
			leftPointsIndentsUV.Add(new Vector2(leftIndentUVX, num2 * num));
		}
		num2 = 0f;
		rightRoundingPointsUV.Add(new Vector2(1f, 0f));
		rightPointsIndentsUV.Add(new Vector2(rightIndentUVX, 0f));
		for (int k = 1; k < rightRoundingPoints.Count; k++)
		{
			num2 += Vector3.Distance(rightRoundingPoints[k - 1], rightRoundingPoints[k]);
			rightRoundingPointsUV.Add(new Vector2(1f, num2 * num));
			rightPointsIndentsUV.Add(new Vector2(rightIndentUVX, num2 * num));
		}
	}

	public static void OCOQCCQCCC(List<Vector3> leftRoundingPoints, List<Vector3> rightRoundingPoints, ref List<Vector2> leftRoundingPointsUV, ref List<Vector2> rightRoundingPointsUV)
	{
		leftRoundingPointsUV.Clear();
		rightRoundingPointsUV.Clear();
		float num = 0.2f;
		float num2 = 0f;
		for (int i = 1; i < leftRoundingPoints.Count; i++)
		{
			num2 += Vector3.Distance(leftRoundingPoints[i - 1], leftRoundingPoints[i]);
		}
		float num3 = 0f;
		for (int j = 1; j < rightRoundingPoints.Count; j++)
		{
			num3 += Vector3.Distance(rightRoundingPoints[j - 1], rightRoundingPoints[j]);
		}
		float num4 = (num2 + num3) * 0.5f;
		float num5 = num4 / num2;
		float num6 = num4 / num3;
		num4 = 0f;
		leftRoundingPointsUV.Add(new Vector2(0f, 0f));
		for (int k = 1; k < leftRoundingPoints.Count; k++)
		{
			num4 += Vector3.Distance(leftRoundingPoints[k - 1], leftRoundingPoints[k]);
			leftRoundingPointsUV.Add(new Vector2(0f, num4 * num5 * num));
		}
		num4 = 0f;
		rightRoundingPointsUV.Add(new Vector2(1f, 0f));
		for (int l = 1; l < rightRoundingPoints.Count; l++)
		{
			num4 += Vector3.Distance(rightRoundingPoints[l - 1], rightRoundingPoints[l]);
			rightRoundingPointsUV.Add(new Vector2(1f, num4 * num6 * num));
		}
	}

	public static void OOCDCQQQCD(ref List<Vector3> leftRoundingPoints, ref List<Vector3> rightRoundingPoints, ref List<Vector3> centerPoints, ref Vector3 cpLeft, ref Vector3 cpRight, List<Vector3> priorityRoad, float cornerRadius, float cornerSegments, Vector3 lStart, Vector3 lEnd, Vector3 rStart, Vector3 rEnd, float leftIndent, float leftIndentUVX, float rightIndent, float rightIndentUVX)
	{
	}

	public static void OOOQCOOQDD(List<Vector3> outerPoints, Vector3 pos, ref float uvX, float indentUVX, float indentdist, int leftright)
	{
		int num = 0;
		for (int i = 0; i < outerPoints.Count - 1; i++)
		{
			Vector3 b = ODQDQDQDQO.OQQCQOCCOQ(outerPoints[i], outerPoints[i + 1], pos);
			float num2 = Vector3.Distance(pos, outerPoints[i]);
			float num3 = Vector3.Distance(pos, outerPoints[i + 1]);
			float num4 = Vector3.Distance(outerPoints[i], outerPoints[i + 1]);
			if (!(num2 < num4) || !(num3 < num4))
			{
				continue;
			}
			float num5 = Vector3.Distance(pos, b);
			if (num5 < indentdist)
			{
				uvX = num5 / indentdist * indentUVX;
				if (leftright == 0)
				{
					á = 1f;
				}
				else
				{
					á = 1f;
				}
			}
			break;
		}
	}

	public static void OCOCCCCDOO(ref List<Vector3> indentPoints, List<Vector3> outerPoints, List<Vector3> priorityConnectionPoints, int leftright)
	{
		Vector3 vector = priorityConnectionPoints[0];
		Vector3 vector2 = priorityConnectionPoints[1];
		bool flag = false;
		if (leftright == 1)
		{
			vector = priorityConnectionPoints[priorityConnectionPoints.Count - 1];
			vector2 = priorityConnectionPoints[priorityConnectionPoints.Count - 2];
			flag = true;
		}
		Vector3 normalized = (vector - vector2).normalized;
		float num = Vector3.Distance(outerPoints[0], indentPoints[0]);
		for (int i = 0; i < indentPoints.Count; i++)
		{
			if (ODQDQDQDQO.OQCDCDOOCD(vector2, vector, indentPoints[i]) == flag)
			{
				Vector3 normalized2 = (outerPoints[i] - indentPoints[i]).normalized;
				float num2 = Vector3.Angle(normalized, normalized2);
				Vector3 vector3 = outerPoints[i];
				if (i != indentPoints.Count - 1)
				{
					vector3 = ODQDQDQDQO.OODOQDOODO(outerPoints[i], indentPoints[i], vector, vector2, flag: false);
					num = Vector3.Distance(vector3, indentPoints[i]);
				}
				num /= Mathf.Cos(num2 * ((float)Math.PI / 180f));
				indentPoints[i] = vector3 + -normalized * num;
			}
		}
	}

	public static void OQDQCQCDQQ(ref List<Vector3> centerPoints, List<Vector3> priorityConnectionPoints)
	{
		int num = Mathf.RoundToInt((float)priorityConnectionPoints.Count * 0.5f) - 1;
		for (int i = 0; i < centerPoints.Count; i++)
		{
			for (int j = num; j < num + 2; j++)
			{
				if (centerPoints.Count > i && !ODQDQDQDQO.OQCDCDOOCD(priorityConnectionPoints[j + 1], priorityConnectionPoints[j], centerPoints[i]))
				{
					centerPoints.RemoveAt(i);
					i--;
					break;
				}
			}
		}
	}

	public static void ODDDOCDCQO(List<ERConnectionSibling> priorityRoads, List<ERConnectionSibling> primaryRoads)
	{
		Mesh mesh = null;
		if (!cScr.gameObject.GetComponent<MeshRenderer>())
		{
			cScr.gameObject.AddComponent<MeshRenderer>();
			if (priorityRoads[0].roadType.castShadow)
			{
				cScr.gameObject.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.On;
			}
			else
			{
				cScr.gameObject.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.Off;
			}
		}
		if (!cScr.gameObject.GetComponent<MeshFilter>())
		{
			cScr.gameObject.AddComponent<MeshFilter>();
		}
		if (!cScr.gameObject.GetComponent<MeshCollider>())
		{
			cScr.gameObject.AddComponent<MeshCollider>();
		}
		if (cScr.gameObject.GetComponent<MeshFilter>().sharedMesh != null)
		{
			mesh = cScr.gameObject.GetComponent<MeshFilter>().sharedMesh;
		}
		else
		{
			mesh = new Mesh();
			cScr.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
			cScr.gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
		}
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		List<Vector2> list3 = new List<Vector2>();
		List<Vector2> list4 = new List<Vector2>();
		List<int> list5 = new List<int>();
		List<Vector3> list6 = new List<Vector3>();
		List<Vector2> list7 = new List<Vector2>();
		List<Vector2> list8 = new List<Vector2>();
		List<Vector2> list9 = new List<Vector2>();
		List<int> list10 = new List<int>();
		List<Color> list11 = new List<Color>();
		List<Color> colors = new List<Color>();
		List<Vector3> vecs = new List<Vector3>();
		List<Vector2> uvs = new List<Vector2>();
		List<Vector2> uvs2 = new List<Vector2>();
		List<Vector2> uvs3 = new List<Vector2>();
		List<List<int>> tris = new List<List<int>>();
		List<Vector3> vecs2 = new List<Vector3>();
		List<Vector2> uvs4 = new List<Vector2>();
		List<Vector2> uvsTmp = new List<Vector2>();
		List<Vector2> uvsTmp2 = new List<Vector2>();
		List<int> tris2 = new List<int>();
		List<Color> colors2 = new List<Color>();
		List<Color> colorsTmp = new List<Color>();
		List<Material> mats = new List<Material>();
		bool weldVecs = false;
		if (crossingStructure == 0)
		{
			List<int> secondPriorityInts = new List<int>();
			List<int> list12 = new List<int>();
			for (int i = 0; i < priorityRoads.Count; i++)
			{
				if (priorityRoads[i] != secondPriorityConnection)
				{
					secondPriorityInts.Clear();
					Material material = priorityRoads[i].roadType.connectionMaterial;
					if (material == null)
					{
						material = priorityRoads[i].roadType.roadMaterial;
					}
					if (priorityRoads[i] == primaryPriorityConnection)
					{
						material = priorityRoads[i].roadType.roadMaterial;
					}
					bool singleSectionFlag = false;
					if (priorityRoads[i] == primaryPriorityConnection)
					{
						singleSectionFlag = true;
					}
					if (priorityRoads[i].buildPriority == 0)
					{
						ODDCQODOCD(ref tris2, ref vecs2, ref uvs4, priorityRoads[i].roadVecs, priorityRoads[i].roadUVs, priorityRoads[i].priorityPointsMain, priorityRoads[i].priorityPointsMainUVs, ref colors, priorityRoads[i].originalShapeVecs, ref priorityRoads[i].connectionVecInts, vecs.Count, ref secondPriorityInts, singleSectionFlag, priorityRoads[i]);
					}
					else if (!priorityRoads[i].shapeSubSegments)
					{
						ODODQCDCOD(ref tris2, ref vecs2, ref uvs4, priorityRoads[i].roadVecs, priorityRoads[i].roadUVs, priorityRoads[i].priorityPointsMain, priorityRoads[i].priorityPointsMainUVs, ref colors, priorityRoads[i].originalShapeVecs, ref priorityRoads[i].connectionVecInts, vecs.Count, ref secondPriorityInts, singleSectionFlag, priorityRoads[i]);
					}
					else
					{
						ODDCQODOCD(ref tris2, ref vecs2, ref uvs4, priorityRoads[i].roadVecs, priorityRoads[i].roadUVs, priorityRoads[i].priorityPointsMain, priorityRoads[i].priorityPointsMainUVs, ref colors, priorityRoads[i].originalShapeVecs, ref priorityRoads[i].connectionVecInts, vecs.Count, ref secondPriorityInts, singleSectionFlag, priorityRoads[i]);
					}
					MergeMeshDataExt(ref tris, ref vecs, ref uvs, ref uvs2, ref uvs3, ref colors2, ref tris2, ref vecs2, ref uvs4, ref uvsTmp, ref uvsTmp2, ref colorsTmp, skipMiddles: false, weldVecs, material, ref mats);
					if (priorityRoads[i] == primaryPriorityConnection)
					{
						list12 = new List<int>(secondPriorityInts);
					}
				}
			}
			if (secondPriorityConnection != null)
			{
				list12.Reverse();
				secondPriorityConnection.connectionVecInts = list12;
			}
		}
		else if (crossingStructure != 1 && crossingStructure != 2 && crossingStructure != 3)
		{
		}
		int num = 0;
		cScr.gameObject.GetComponent<MeshRenderer>().sharedMaterials = mats.ToArray();
		mesh.Clear();
		mesh.vertices = vecs.ToArray();
		mesh.uv = uvs.ToArray();
		mesh.subMeshCount = tris.Count;
		for (int j = 0; j < tris.Count; j++)
		{
			mesh.SetTriangles(tris[j].ToArray(), j);
		}
		mesh.tangents = new Vector4[vecs.Count];
		mesh.RecalculateNormals();
		int count = primaryRoads[0].normalIndexes.Count;
		if (primaryPriorityConnection == null && count > 0)
		{
			int num2 = Mathf.RoundToInt(Mathf.Floor((float)count * 0.5f));
			bool flag = false;
			if ((float)num2 != (float)count * 0.5f)
			{
				flag = true;
			}
			Vector3[] normals = mesh.normals;
			for (int k = 0; k < primaryRoads.Count; k++)
			{
				for (int l = 0; l < num2; l++)
				{
					int num3 = primaryRoads[k].normalIndexes[l];
					int num4 = ((k >= primaryRoads.Count - 1) ? primaryRoads[0].normalIndexes[count - 1 - l] : primaryRoads[k + 1].normalIndexes[count - 1 - l]);
					normals[num3] = (normals[num4] = Vector3.Lerp(normals[num3], normals[num4], 0.5f));
				}
				if (flag)
				{
					int num3 = primaryRoads[k].normalIndexes[num2 + 1];
					int num4 = ((k >= primaryRoads.Count - 1) ? primaryRoads[0].normalIndexes[num2 + 1] : primaryRoads[k + 1].normalIndexes[num2 + 1]);
					normals[num3] = (normals[num4] = Vector3.Lerp(normals[num3], normals[num4], 0.5f));
				}
			}
			mesh.normals = normals;
		}
		mesh.RecalculateBounds();
		mesh.RecalculateTangents();
		cScr.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
		for (int m = 0; m < priorityRoads.Count; m++)
		{
			if (priorityRoads[m].mainConnectionDecalVecs.Count > 0)
			{
				if (priorityRoads[m].mainRoadConnectionEdgeDecal != 0)
				{
					OQOQDQDOOO(cScr.transform, priorityRoads[m], m);
				}
				else if (priorityRoads[m].mainConnectionDecal != null)
				{
					UnityEngine.Object.DestroyImmediate(priorityRoads[m].mainConnectionDecal);
				}
			}
			else if (priorityRoads[m].mainConnectionDecal != null)
			{
				UnityEngine.Object.DestroyImmediate(priorityRoads[m].mainConnectionDecal);
			}
		}
	}

	public static void OQOQDQDOOO(Transform tr, ERConnectionSibling sibling, int index)
	{
		ERDecal eRDecal = null;
		if (sibling.roadType != null)
		{
			eRDecal = ERDecal.OCQCDQDODQ(sibling.mainRoadConnectionEdgeDecal, sibling.roadType.decalPresets);
		}
		if (eRDecal != null)
		{
			List<Vector3> vecs = new List<Vector3>();
			ODCCODOCQQ.OODDDCCOQO(sibling.mainConnectionDecalVecs, eRDecal.xOffset, eRDecal.startOffset, eRDecal.endOffset, eRDecal.distances, 5f, sibling.mainConnectionDecalEndDir, sibling.dir, ref vecs, eRDecal.length, sibling.rightRoundingPoints[0], sibling.uvRatio);
			ODQDQDQDQO.OOQQCCOQOC(tr, ref sibling.mainConnectionDecal, "Main Connection Decal", vecs, eRDecal.material, eRDecal.xOffset, eRDecal.startOffset, eRDecal.endOffset, eRDecal.heightOffset, eRDecal.length, eRDecal.width, eRDecal.uvLeftTop, eRDecal.uvRightBottom, sibling.uvRatio);
		}
	}

	public static void ODODQCDCOD(ref List<int> tris, ref List<Vector3> vecs, ref List<Vector2> uvs, List<List<Vector3>> vecsData, List<List<Vector2>> uvsData, List<Vector3> priorityPointsMain, List<Vector2> priorityPointsMainUVs, ref List<Color> colors, List<bool> originalShapeVecs, ref List<int> connInts, int totalVecs, ref List<int> secondPriorityInts, bool singleSectionFlag, ERConnectionSibling sibling)
	{
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		int num5 = 0;
		int num6 = 0;
		int num7 = 0;
		int num8 = 0;
		float num9 = 0f;
		float num10 = 0f;
		int num11 = -1;
		int count = vecsData.Count;
		num = 0;
		List<int> list = new List<int>();
		List<int> list2 = new List<int>();
		int item = 0;
		int num12 = 0;
		connInts.Add(totalVecs + vecs.Count);
		List<int> list3 = new List<int>();
		vecs.AddRange(vecsData[0]);
		uvs.AddRange(uvsData[0]);
		num12 = totalVecs + vecs.Count - 1;
		if (singleSectionFlag)
		{
			secondPriorityInts.Add(totalVecs + vecs.Count - 1);
		}
		sibling.normalIndexes.Add(totalVecs + vecs.Count - 1);
		num4 = vecs.Count - 1;
		int leftFixedIndex = sibling.leftFixedIndex;
		int rightFixedIndex = sibling.rightFixedIndex;
		for (int i = 1; i < count; i++)
		{
			num = num2;
			num3 = num4;
			if (i == leftFixedIndex + 1 && sibling.buildPriority != 0)
			{
				num3--;
				num7 = num3 + 1;
				list3.Add(num3);
			}
			num2 = vecs.Count;
			if (originalShapeVecs[i])
			{
				connInts.Add(totalVecs + vecs.Count);
				if (singleSectionFlag)
				{
					secondPriorityInts.Add(totalVecs + vecs.Count + vecsData[i].Count - 1);
				}
			}
			if (!originalShapeVecs[i])
			{
				if (list.Count == 0)
				{
					list.Add(item);
					list2.Add(num12);
				}
				list.Add(totalVecs + vecs.Count);
				int num13 = vecsData[i].Count;
				if (singleSectionFlag)
				{
					num13--;
				}
				else if (sibling.buildPriority != 0 && i > leftFixedIndex && i < rightFixedIndex)
				{
					num13--;
				}
				for (int j = 1; j < num13; j++)
				{
					vecs.Add(vecsData[i][j]);
					uvs.Add(uvsData[i][j]);
				}
				if (sibling.buildPriority != 0 && i > leftFixedIndex && i < rightFixedIndex)
				{
					list3.Add(vecs.Count - 1);
				}
				list2.Add(totalVecs + vecs.Count - 1);
			}
			else
			{
				item = vecs.Count;
				if (sibling.buildPriority == 0 || i <= leftFixedIndex + 1 || i >= rightFixedIndex)
				{
					vecs.AddRange(vecsData[i]);
					uvs.AddRange(uvsData[i]);
				}
				else
				{
					int num14 = vecsData[i].Count - 1;
					for (int k = 0; k < num14; k++)
					{
						vecs.Add(vecsData[i][k]);
						uvs.Add(uvsData[i][k]);
					}
					if (sibling.buildPriority != 0 && i > leftFixedIndex && i < rightFixedIndex)
					{
						list3.Add(vecs.Count - 1);
					}
				}
				num12 = totalVecs + vecs.Count - 1;
			}
			sibling.normalIndexes.Add(totalVecs + vecs.Count - 1);
			num4 = vecs.Count - 1;
			int num15 = num4;
			if (i == rightFixedIndex && sibling.buildPriority != 0)
			{
				num15--;
				list3.Add(num15);
				num8 = num4;
			}
			num5 = num;
			num6 = num2;
			num11 = -1;
			int num16 = 0;
			if (sibling.buildPriority != 0)
			{
			}
			OQCDQQOCOC(num5, num3, num6, num15, vecs, ref tris, sibling);
			if (originalShapeVecs[i] && list.Count > 0)
			{
				list.Add(num2);
				list2.Add(num4);
				if (list.Count >= 3)
				{
					tris.Add(list[0]);
					tris.Add(list[1]);
					tris.Add(list[2]);
				}
				if (list.Count == 4)
				{
					tris.Add(list[0]);
					tris.Add(list[2]);
					tris.Add(list[3]);
				}
				else if (list.Count > 4)
				{
					tris.Add(list[2]);
					tris.Add(list[3]);
					tris.Add(list[4]);
					tris.Add(list[0]);
					tris.Add(list[2]);
					tris.Add(list[4]);
				}
				list.Clear();
				if (singleSectionFlag)
				{
					if (list2.Count >= 3)
					{
						tris.Add(list2[0]);
						tris.Add(list2[2]);
						tris.Add(list2[1]);
					}
					if (list2.Count == 4)
					{
						tris.Add(list2[0]);
						tris.Add(list2[3]);
						tris.Add(list2[2]);
					}
					else if (list2.Count > 4)
					{
						tris.Add(list2[2]);
						tris.Add(list2[4]);
						tris.Add(list2[3]);
						tris.Add(list2[0]);
						tris.Add(list2[4]);
						tris.Add(list2[2]);
					}
				}
				list2.Clear();
			}
			if (!sibling.hardEdge[i])
			{
				continue;
			}
			if (!originalShapeVecs[i])
			{
				for (int l = 1; l < vecsData[i].Count; l++)
				{
					vecs.Add(vecsData[i][l]);
					uvs.Add(uvsData[i][l]);
				}
				num2 += vecsData[i].Count - 1;
				num4 += vecsData[i].Count - 1;
			}
			else
			{
				vecs.AddRange(vecsData[i]);
				uvs.AddRange(uvsData[i]);
				num2 += vecsData[i].Count;
				num4 += vecsData[i].Count;
			}
			sibling.normalIndexes.Add(totalVecs + vecs.Count - 1);
		}
		if (sibling.buildPriority == 0)
		{
			return;
		}
		num5 = vecs.Count - 1;
		List<Vector3> list4 = new List<Vector3>();
		List<Vector2> list5 = new List<Vector2>();
		list4.Add(vecs[num7]);
		list5.Add(uvs[num7]);
		float num17 = Vector3.Distance(vecs[num7], priorityPointsMain[0]);
		float num18 = 0f;
		int num19 = 0;
		for (int m = 1; m < priorityPointsMain.Count; m++)
		{
			num18 = Vector3.Distance(priorityPointsMain[m], priorityPointsMain[0]);
			if (num18 > num17)
			{
				num19 = m;
				break;
			}
		}
		int num20 = priorityPointsMain.Count - 1;
		num17 = Vector3.Distance(vecs[num8], priorityPointsMain[num20]);
		num18 = 0f;
		int num21 = 0;
		for (int num22 = num20 - 1; num22 > 0; num22--)
		{
			num18 = Vector3.Distance(priorityPointsMain[num22], priorityPointsMain[num20]);
			if (num18 > num17)
			{
				num21 = num22;
				break;
			}
		}
		int num23 = leftFixedIndex + 1;
		Vector3 a = list4[0];
		num18 = Vector3.Distance(a, vecsData[num23][vecsData[num23].Count - 1]);
		bool flag = false;
		for (int n = num19; n <= num21; n++)
		{
			num17 = Vector3.Distance(a, priorityPointsMain[n]);
			if (num17 < num18 || flag)
			{
				list4.Add(priorityPointsMain[n]);
				list5.Add(priorityPointsMainUVs[n]);
				a = list4[list4.Count - 1];
				num18 = Vector3.Distance(a, vecsData[num23][vecsData[num23].Count - 1]);
				continue;
			}
			list4.Add(vecsData[num23][vecsData[num23].Count - 1]);
			list5.Add(uvsData[num23][uvsData[num23].Count - 1]);
			num23++;
			a = list4[list4.Count - 1];
			if (vecsData.Count > num23)
			{
				num18 = Vector3.Distance(a, vecsData[num23][vecsData[num23].Count - 1]);
			}
			else
			{
				flag = true;
			}
			n--;
		}
		list4.Add(vecs[num8]);
		list5.Add(uvs[num8]);
		vecs.AddRange(list4);
		uvs.AddRange(list5);
		num3 = vecs.Count - 1;
		for (int num24 = 0; num24 < list3.Count; num24++)
		{
		}
		OOOQCQDCDD(num5, num3, num7, num8, list3, vecs, ref tris, sibling);
	}

	public static void ODDCQODOCD(ref List<int> tris, ref List<Vector3> vecs, ref List<Vector2> uvs, List<List<Vector3>> vecsData, List<List<Vector2>> uvsData, List<Vector3> priorityPointsMain, List<Vector2> priorityPointsMainUVs, ref List<Color> colors, List<bool> originalShapeVecs, ref List<int> connInts, int totalVecs, ref List<int> secondPriorityInts, bool singleSectionFlag, ERConnectionSibling sibling)
	{
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		int num5 = 0;
		int curRight = 0;
		float num6 = 0f;
		float num7 = 0f;
		int num8 = -1;
		int count = vecsData.Count;
		num = 0;
		List<int> list = new List<int>();
		List<int> list2 = new List<int>();
		int item = 0;
		int num9 = 0;
		connInts.Add(totalVecs + vecs.Count);
		List<int> list3 = new List<int>();
		vecs.AddRange(vecsData[0]);
		uvs.AddRange(uvsData[0]);
		num9 = vecs.Count - 1;
		list3.Add(vecs.Count - 1);
		if (singleSectionFlag)
		{
			secondPriorityInts.Add(totalVecs + vecs.Count - 1);
		}
		sibling.normalIndexes.Add(totalVecs + vecs.Count - 1);
		num4 = vecs.Count - 1;
		for (int i = 1; i < count; i++)
		{
			num = num2;
			num3 = num4;
			num2 = vecs.Count;
			if (originalShapeVecs[i])
			{
				connInts.Add(totalVecs + vecs.Count);
				if (singleSectionFlag)
				{
					secondPriorityInts.Add(totalVecs + vecs.Count + vecsData[i].Count - 1);
				}
			}
			if (!originalShapeVecs[i])
			{
				if (list.Count == 0)
				{
					list.Add(item);
					list2.Add(num9);
				}
				list.Add(vecs.Count);
				int num10 = vecsData[i].Count;
				if (singleSectionFlag)
				{
					num10--;
				}
				for (int j = 1; j < num10; j++)
				{
					vecs.Add(vecsData[i][j]);
					uvs.Add(uvsData[i][j]);
				}
				list2.Add(vecs.Count - 1);
			}
			else
			{
				item = vecs.Count;
				vecs.AddRange(vecsData[i]);
				uvs.AddRange(uvsData[i]);
				num9 = vecs.Count - 1;
			}
			list3.Add(vecs.Count - 1);
			sibling.normalIndexes.Add(totalVecs + vecs.Count - 1);
			num4 = vecs.Count - 1;
			num5 = num;
			curRight = num2;
			num8 = -1;
			int num11 = 0;
			if (sibling.buildPriority != 0)
			{
			}
			OQCDQQOCOC(num5, num3, curRight, num4, vecs, ref tris, sibling);
			if (originalShapeVecs[i] && list.Count > 0)
			{
				list.Add(num2);
				list2.Add(vecs.Count - 1);
				if (list.Count >= 3)
				{
					tris.Add(list[0]);
					tris.Add(list[1]);
					tris.Add(list[2]);
				}
				if (list.Count == 4)
				{
					tris.Add(list[0]);
					tris.Add(list[2]);
					tris.Add(list[3]);
				}
				else if (list.Count > 4)
				{
					tris.Add(list[2]);
					tris.Add(list[3]);
					tris.Add(list[4]);
					tris.Add(list[0]);
					tris.Add(list[2]);
					tris.Add(list[4]);
				}
				list.Clear();
				if (singleSectionFlag)
				{
					if (list2.Count >= 3)
					{
						tris.Add(list2[0]);
						tris.Add(list2[2]);
						tris.Add(list2[1]);
					}
					if (list2.Count == 4)
					{
						tris.Add(list2[0]);
						tris.Add(list2[3]);
						tris.Add(list2[2]);
					}
					else if (list2.Count > 4)
					{
						tris.Add(list2[2]);
						tris.Add(list2[4]);
						tris.Add(list2[3]);
						tris.Add(list2[0]);
						tris.Add(list2[4]);
						tris.Add(list2[2]);
					}
				}
				list2.Clear();
			}
			if (!sibling.hardEdge[i])
			{
				continue;
			}
			item = vecs.Count;
			if (!originalShapeVecs[i])
			{
				for (int k = 1; k < vecsData[i].Count; k++)
				{
					vecs.Add(vecsData[i][k]);
					uvs.Add(uvsData[i][k]);
				}
				num2 += vecsData[i].Count - 1;
				num4 += vecsData[i].Count - 1;
			}
			else
			{
				vecs.AddRange(vecsData[i]);
				uvs.AddRange(uvsData[i]);
				num2 += vecsData[i].Count;
				num4 += vecsData[i].Count;
			}
			num9 = totalVecs + vecs.Count - 1;
			sibling.normalIndexes.Add(totalVecs + vecs.Count - 1);
		}
		if (sibling.buildPriority != 0)
		{
			num5 = vecs.Count - 1;
			vecs.AddRange(priorityPointsMain);
			uvs.AddRange(priorityPointsMainUVs);
			num3 = vecs.Count - 1;
			OOOQCQDCDD(num5, num3, curRight, num4, list3, vecs, ref tris, sibling);
		}
	}

	private static void OQCDQQOCOC(int curLeft, int endLeft, int curRight, int endRight, List<Vector3> vecs, ref List<int> tris, ERConnectionSibling sibling)
	{
		float num = 0f;
		float num2 = 0f;
		int num3 = -1;
		int num4 = 0;
		while (curLeft < endLeft || curRight < endRight)
		{
			if (curRight > endRight)
			{
				curRight = endRight;
			}
			if (curLeft > endLeft)
			{
				curLeft = endLeft;
			}
			num2 = ((curRight >= endRight) ? 0f : Vector3.Distance(vecs[curLeft], vecs[curRight + 1]));
			num = ((curLeft >= endLeft) ? 0f : Vector3.Distance(vecs[curLeft + 1], vecs[curRight]));
			if ((num < num2 && curLeft < endLeft) || curRight == endRight)
			{
				tris.Add(curLeft);
				tris.Add(curLeft + 1);
				tris.Add(curRight);
				curLeft++;
				num3 = 1;
			}
			else
			{
				tris.Add(curLeft);
				tris.Add(curRight + 1);
				tris.Add(curRight);
				curRight++;
				num3 = 0;
			}
			if (sibling.buildPriority != 0)
			{
			}
			num4++;
			if (num4 > 100)
			{
				break;
			}
		}
	}

	private static void OOOQCQDCDD(int curLeft, int endLeft, int curRight, int endRight, List<int> rightInts, List<Vector3> vecs, ref List<int> tris, ERConnectionSibling sibling)
	{
		float num = 0f;
		float num2 = 0f;
		int num3 = -1;
		int num4 = 0;
		curRight = 0;
		endRight = rightInts.Count - 1;
		curLeft++;
		while (curLeft < endLeft || curRight < endRight)
		{
			num2 = ((curRight >= endRight) ? 0f : Vector3.Distance(vecs[curLeft], vecs[rightInts[curRight + 1]]));
			num = ((curLeft >= endLeft) ? 0f : Vector3.Distance(vecs[curLeft + 1], vecs[rightInts[curRight]]));
			if ((num < num2 && curLeft < endLeft) || curRight == endRight)
			{
				tris.Add(curLeft);
				tris.Add(curLeft + 1);
				tris.Add(rightInts[curRight]);
				curLeft++;
				num3 = 1;
			}
			else
			{
				tris.Add(curLeft);
				tris.Add(rightInts[curRight + 1]);
				tris.Add(rightInts[curRight]);
				curRight++;
				num3 = 0;
			}
			if (sibling == null || sibling.buildPriority != 0)
			{
			}
			num4++;
			if (num4 > 100)
			{
				break;
			}
		}
	}

	public static void OCDOQDDCQC(ref List<int> tris, ref List<Vector3> vecs, ref List<Vector2> uvs, List<List<Vector3>> vecsData, List<List<Vector2>> uvsData, List<Vector3> priorityPointsMain, List<Vector2> priorityPointsMainUVs, ref List<Color> colors, List<bool> originalShapeVecs, ref List<int> connInts, int totalVecs, ref List<int> secondPriorityInts, bool singleSectionFlag, ERConnectionSibling sibling)
	{
		List<List<int>> tris2 = new List<List<int>>();
		Material mat = null;
		List<Material> mats = new List<Material>();
		List<Vector2> uvs2 = new List<Vector2>();
		List<Vector2> uvs3 = new List<Vector2>();
		List<Color> colorsTmp = new List<Color>();
		List<Vector2> uvsTmp = new List<Vector2>();
		List<Vector2> uvsTmp2 = new List<Vector2>();
		List<Vector3> list = new List<Vector3>();
		List<Vector3> list2 = new List<Vector3>();
		List<Vector3> list3 = new List<Vector3>();
		List<Vector3> list4 = new List<Vector3>();
		List<Vector3> list5 = new List<Vector3>();
		List<Vector3> vecsTmp = new List<Vector3>();
		List<Vector2> uvsTmp3 = new List<Vector2>();
		List<Vector3> list6 = new List<Vector3>();
		List<Vector3> list7 = new List<Vector3>();
		List<int> list8 = new List<int>();
		bool flag = false;
		if (sibling.leftFixedIndex == 0)
		{
			flag = true;
		}
		int num = 0;
		int num2 = 1;
		int num3 = 1;
		if (priorityPointsMain.Count > 0)
		{
			for (int i = 0; i < vecsData[0].Count - 1; i++)
			{
				list2.Add(vecsData[0][i]);
			}
		}
		else
		{
			list2.AddRange(vecsData[0]);
		}
		int num4 = 0;
		int num5 = 0;
		for (int j = 0; j < vecsData.Count; j++)
		{
			if (priorityPointsMain.Count == 0)
			{
				if (!singleSectionFlag)
				{
					list3.Add(vecsData[j][vecsData[j].Count - 1]);
				}
				else if (originalShapeVecs[j])
				{
					list3.Add(vecsData[j][vecsData[j].Count - 1]);
				}
			}
			else if (j > 0)
			{
				Vector3 vector = vecsData[j][vecsData[j].Count - 1];
				Vector3 pSource = vector + sibling.dir * 15f;
				for (int k = num; k < priorityPointsMain.Count; k++)
				{
					if (ODQDQDQDQO.OQCDCDOOCD(vector, pSource, priorityPointsMain[k]))
					{
						list3.Add(priorityPointsMain[k]);
						vecsTmp.Add(priorityPointsMain[k]);
						uvsTmp3.Add(priorityPointsMainUVs[k]);
						continue;
					}
					num = k;
					num3 = k;
					break;
				}
			}
			if (originalShapeVecs[j])
			{
				list5.Add(vecsData[j][0]);
			}
			if (originalShapeVecs[j])
			{
				connInts.Add(totalVecs + vecsTmp.Count);
				list6.Add(vecsData[j][0]);
				list8.Add(vecsTmp.Count);
				vecsTmp.AddRange(vecsData[j]);
				uvsTmp3.AddRange(uvsData[j]);
				if (priorityPointsMain.Count == 0)
				{
					sibling.normalIndexes.Add(totalVecs + vecsTmp.Count - 1);
				}
				if (singleSectionFlag)
				{
					secondPriorityInts.Add(totalVecs + vecsTmp.Count - 1);
					list7.Add(vecsData[j][vecsData[j].Count - 1]);
				}
			}
			else
			{
				int num6 = vecsData[j].Count;
				if (singleSectionFlag)
				{
					num6--;
				}
				for (int l = 1; l < num6; l++)
				{
					vecsTmp.Add(vecsData[j][l]);
					uvsTmp3.Add(uvsData[j][l]);
					if (l == num6 - 1 && priorityPointsMain.Count == 0)
					{
						sibling.normalIndexes.Add(totalVecs + vecsTmp.Count - 1);
					}
				}
			}
			if (!sibling.hardEdge[j] && j != sibling.leftFixedIndex && j != sibling.rightFixedIndex && j != vecsData.Count - 1)
			{
				continue;
			}
			if (originalShapeVecs[j])
			{
				list4 = new List<Vector3>(vecsData[j]);
			}
			else if (j == sibling.leftFixedIndex)
			{
				for (int m = 1; m < vecsData[j].Count; m++)
				{
					list4.Add(vecsData[j][m]);
				}
			}
			else
			{
				int index = 0;
				for (int n = j + 1; n < vecsData.Count; n++)
				{
					if (originalShapeVecs[n])
					{
						list4.Add(vecsData[n][0]);
						vecsTmp.Add(vecsData[n][0]);
						uvsTmp3.Add(uvsData[n][0]);
						index = n;
						break;
					}
				}
				int num7 = vecsData[j].Count;
				if (singleSectionFlag)
				{
					num7--;
				}
				for (int num8 = 1; num8 < num7; num8++)
				{
					list4.Add(vecsData[j][num8]);
				}
				if (singleSectionFlag)
				{
					list4.Add(vecsData[index][vecsData[index].Count - 1]);
					vecsTmp.Add(vecsData[index][vecsData[index].Count - 1]);
					uvsTmp3.Add(uvsData[index][vecsData[index].Count - 1]);
				}
			}
			list4.Reverse();
			list5.Reverse();
			list.AddRange(list2);
			list.AddRange(list3);
			list.AddRange(list4);
			list.AddRange(list5);
			List<int> trisTmp = Triangulate(vecsTmp, list);
			if (num4 != 2 || priorityPointsMain.Count > 0)
			{
			}
			if (totalVecs < 25 && num4 == 2)
			{
				debugEdges.AddRange(list);
				debugvecs.AddRange(vecsTmp);
			}
			MergeMeshDataExt(ref tris2, ref vecs, ref uvs, ref uvs2, ref uvs3, ref colors, ref trisTmp, ref vecsTmp, ref uvsTmp3, ref uvsTmp, ref uvsTmp2, ref colorsTmp, skipMiddles: false, weldVecs: true, mat, ref mats);
			vecsTmp.Clear();
			uvsTmp3.Clear();
			list2.Clear();
			list3.Clear();
			list4.Clear();
			list5.Clear();
			list.Clear();
			int index2 = -1;
			if (originalShapeVecs[j])
			{
				list2 = new List<Vector3>(vecsData[j]);
				vecsTmp.AddRange(vecsData[j]);
				uvsTmp3.AddRange(uvsData[j]);
			}
			else
			{
				if (j == sibling.leftFixedIndex)
				{
					if (j == 0)
					{
						list2.Add(vecsData[0][0]);
						vecsTmp.Add(vecsData[0][0]);
						uvsTmp3.Add(uvsData[0][0]);
					}
					else
					{
						for (int num9 = j - 1; num9 >= 0; num9--)
						{
							if (originalShapeVecs[num9])
							{
								list2.Add(vecsData[num9][0]);
								vecsTmp.Add(vecsData[num9][0]);
								uvsTmp3.Add(uvsData[num9][0]);
								index2 = num9;
								break;
							}
						}
					}
				}
				else if (j == vecsData.Count - 1)
				{
					list2.Add(vecsData[vecsData.Count - 1][0]);
				}
				else
				{
					for (int num10 = j + 1; num10 < vecsData.Count; num10++)
					{
						if (originalShapeVecs[num10])
						{
							list2.Add(vecsData[num10][0]);
							index2 = num10;
							break;
						}
					}
				}
				int num11 = vecsData[j].Count;
				if (singleSectionFlag)
				{
					num11--;
				}
				for (int num12 = 1; num12 < num11; num12++)
				{
					list2.Add(vecsData[j][num12]);
					vecsTmp.Add(vecsData[j][num12]);
					uvsTmp3.Add(uvsData[j][num12]);
				}
				if (singleSectionFlag && j != sibling.leftFixedIndex)
				{
				}
			}
			if (singleSectionFlag)
			{
				if (originalShapeVecs[j])
				{
					list3.Add(vecsData[j][vecsData[j].Count - 1]);
					vecsTmp.Add(vecsData[j][vecsData[j].Count - 1]);
					uvsTmp3.Add(uvsData[j][vecsData[j].Count - 1]);
				}
				else
				{
					list3.Add(vecsData[index2][vecsData[index2].Count - 1]);
					vecsTmp.Add(vecsData[index2][vecsData[index2].Count - 1]);
					uvsTmp3.Add(uvsData[index2][vecsData[index2].Count - 1]);
				}
			}
			else if (priorityPointsMain.Count == 0)
			{
				list3.Add(vecsData[j][vecsData[j].Count - 1]);
			}
			else
			{
				list3.Add(priorityPointsMain[num]);
			}
			num4++;
		}
		connInts.Clear();
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		if (singleSectionFlag)
		{
			secondPriorityInts.Clear();
		}
		for (int num13 = 0; num13 < list6.Count; num13++)
		{
			flag3 = (flag4 = false);
			for (int num14 = 0; num14 < vecs.Count; num14++)
			{
				if (list6[num13] == vecs[num14] && !flag3)
				{
					connInts.Add(totalVecs + num14);
					flag3 = true;
					if (!singleSectionFlag || flag4)
					{
						break;
					}
				}
				if (singleSectionFlag && list7[num13] == vecs[num14] && !flag4)
				{
					secondPriorityInts.Add(totalVecs + num14);
					flag4 = true;
					if (flag3)
					{
						break;
					}
				}
			}
		}
		sibling.normalIndexes.Clear();
		int count = vecs.Count;
		int num15 = 0;
		int num16 = 1;
		Vector3 vector2 = Vector3.zero;
		for (int num17 = 0; num17 < vecsData.Count; num17++)
		{
			Vector3 vector3 = vecsData[num17][vecsData[num17].Count - 1];
			if (num17 > 0)
			{
				num16 = ((!(vector3 == vector2)) ? 1 : 2);
				vector2 = vector3;
			}
			num15 = 1;
			for (int num18 = 0; num18 < count; num18++)
			{
				if (vecs[num18] == vector3)
				{
					if (num15 == num16)
					{
						sibling.normalIndexes.Add(totalVecs + num18);
						break;
					}
					num15++;
				}
			}
		}
		List<Color> list9 = new List<Color>();
		tris = tris2[0];
	}

	public static void OOCCQCDDDQ(ref List<int> tris, ref List<Vector3> vecs, ref List<Vector2> uvs, List<List<Vector3>> vecsData, List<List<Vector2>> uvsData, List<Vector3> priorityPointsMain, List<Vector2> priorityPointsMainUVs, ref List<Color> colors, List<bool> originalShapeVecs, ref List<int> connInts, int totalVecs, ref List<int> secondPriorityInts, bool singleSectionFlag, ERConnectionSibling sibling)
	{
		List<Vector3> list = new List<Vector3>();
		list.AddRange(vecsData[0]);
		List<int> list2 = new List<int>();
		if (priorityPointsMain.Count == 0)
		{
			for (int i = 1; i < vecsData.Count - 1; i++)
			{
				if (!singleSectionFlag)
				{
					list.Add(vecsData[i][vecsData[i].Count - 1]);
				}
				else if (originalShapeVecs[i])
				{
					list.Add(vecsData[i][vecsData[i].Count - 1]);
				}
			}
		}
		else
		{
			list.AddRange(priorityPointsMain);
		}
		List<Vector3> list3 = new List<Vector3>(vecsData[vecsData.Count - 1]);
		list3.Reverse();
		list.AddRange(list3);
		list3.Clear();
		for (int j = 1; j < vecsData.Count - 1; j++)
		{
			if (originalShapeVecs[j])
			{
				list3.Add(vecsData[j][0]);
			}
		}
		list3.Reverse();
		for (int k = 0; k < vecsData.Count; k++)
		{
			if (originalShapeVecs[k])
			{
				connInts.Add(totalVecs + vecs.Count);
				list2.Add(vecs.Count);
				vecs.AddRange(vecsData[k]);
				uvs.AddRange(uvsData[k]);
				secondPriorityInts.Add(totalVecs + vecs.Count - 1);
				continue;
			}
			int num = vecsData[k].Count;
			if (singleSectionFlag)
			{
				num--;
			}
			for (int l = 1; l < num; l++)
			{
				vecs.Add(vecsData[k][l]);
				uvs.Add(uvsData[k][l]);
			}
		}
		if (priorityPointsMain.Count > 0)
		{
			for (int m = 1; m < priorityPointsMain.Count - 1; m++)
			{
				vecs.Add(priorityPointsMain[m]);
				uvs.Add(priorityPointsMainUVs[m]);
			}
		}
		tris = Triangulate(vecs, list);
		List<Color> list4 = new List<Color>();
	}

	public static void OQCQQDDDCQ(ref List<int> tris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<Vector2> uvs1, ref List<Vector2> uvs2, ref List<Color> colors, List<Vector3> mleftPoints, List<Vector3> rightPoints, List<Vector3> centerPoints, Vector3 leftPoint, Vector3 rightPoint, List<Vector2> leftRoundingPointsUV, List<Vector2> rightRoundingPointsUV, List<Vector2> centerPointsUV, Vector2 cpUV, List<Vector3> leftPointsIndents, List<Vector2> leftPointsIndentsUV, List<Vector3> rightPointsIndents, List<Vector2> rightPointsIndentsUV)
	{
		vecs.AddRange(mleftPoints);
		vecs.Add(Vector3.zero);
		List<Vector3> list = new List<Vector3>(rightPoints);
		list.Reverse();
		vecs.AddRange(list);
		List<Vector3> edges = new List<Vector3>(vecs);
		List<Vector3> list2 = new List<Vector3>(centerPoints);
		list2.RemoveAt(0);
		vecs.AddRange(list2);
		for (int i = 1; i < leftPointsIndents.Count; i++)
		{
			vecs.Add(leftPointsIndents[i]);
		}
		for (int j = 1; j < rightPointsIndents.Count; j++)
		{
			vecs.Add(rightPointsIndents[j]);
		}
		uvs.AddRange(leftRoundingPointsUV);
		uvs.Add(cpUV);
		List<Vector2> list3 = new List<Vector2>(rightRoundingPointsUV);
		list3.Reverse();
		uvs.AddRange(list3);
		List<Vector2> list4 = new List<Vector2>(centerPointsUV);
		list4.RemoveAt(0);
		uvs.AddRange(list4);
		for (int k = 1; k < leftPointsIndentsUV.Count; k++)
		{
			uvs.Add(leftPointsIndentsUV[k]);
		}
		for (int l = 1; l < rightPointsIndentsUV.Count; l++)
		{
			uvs.Add(rightPointsIndentsUV[l]);
		}
		tris = Triangulate(vecs, edges);
		List<Color> list5 = new List<Color>();
	}

	public static void OCDCQDDDCC(ref List<int> tris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<Vector2> uvs1, ref List<Vector2> uvs2, ref List<Color> colors, List<Vector3> mleftPoints, List<Vector3> rightPoints, List<Vector3> centerPoints, Vector3 leftPoint, Vector3 rightPoint, List<Vector2> leftRoundingPointsUV, List<Vector2> rightRoundingPointsUV, List<Vector2> centerPointsUV, Vector2 cpUV, List<Vector3> leftPointsIndents, List<Vector2> leftPointsIndentsUV, List<Vector3> rightPointsIndents, List<Vector2> rightPointsIndentsUV)
	{
		vecs.AddRange(mleftPoints);
		List<Vector3> list = new List<Vector3>(rightPoints);
		list.Reverse();
		vecs.AddRange(list);
		List<Vector3> edges = new List<Vector3>(vecs);
		uvs.AddRange(leftRoundingPointsUV);
		List<Vector2> list2 = new List<Vector2>(rightRoundingPointsUV);
		list2.Reverse();
		uvs.AddRange(list2);
		tris = Triangulate(vecs, edges);
		List<Color> list3 = new List<Color>();
	}

	public static void ForkPriorityOCODCOCODQ(ref List<int> tris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<Vector2> uvs1, ref List<Vector2> uvs2, ref List<Color> colors, List<Vector3> mleftPoints, List<Vector3> rightPoints, List<Vector3> centerPoints, Vector3 leftPoint, Vector3 rightPoint, List<Vector2> leftRoundingPointsUV, List<Vector2> rightRoundingPointsUV, List<Vector2> centerPointsUV, Vector2 cpUV, List<Vector3> leftPointsIndents, List<Vector2> leftPointsIndentsUV, List<Vector3> rightPointsIndents, List<Vector2> rightPointsIndentsUV, List<Vector3> mainPoints, List<Vector2> mainPointsUV)
	{
		vecs.AddRange(mleftPoints);
		vecs.AddRange(mainPoints);
		List<Vector3> list = new List<Vector3>(rightPoints);
		list.Reverse();
		vecs.AddRange(list);
		List<Vector3> edges = new List<Vector3>(vecs);
		for (int i = 1; (float)i < (float)leftPointsIndents.Count - á; i++)
		{
			vecs.Add(leftPointsIndents[i]);
		}
		for (int j = 1; (float)j < (float)rightPointsIndents.Count - á; j++)
		{
			vecs.Add(rightPointsIndents[j]);
		}
		uvs.AddRange(leftRoundingPointsUV);
		uvs.AddRange(mainPointsUV);
		List<Vector2> list2 = new List<Vector2>(rightRoundingPointsUV);
		list2.Reverse();
		uvs.AddRange(list2);
		for (int k = 1; (float)k < (float)leftPointsIndentsUV.Count - á; k++)
		{
			uvs.Add(leftPointsIndentsUV[k]);
		}
		for (int l = 1; (float)l < (float)rightPointsIndentsUV.Count - á; l++)
		{
			uvs.Add(rightPointsIndentsUV[l]);
		}
		tris = Triangulate(vecs, edges);
		List<Color> list3 = new List<Color>();
	}

	private void OCOQOCDCCQ(ref List<int> tris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<Vector2> uvs1, ref List<Vector2> uvs2, ref List<Color> colors, ref List<int> trisTmp, ref List<Vector3> vecsTmp, ref List<Vector2> uvsTmp, ref List<Vector2> uvsTmp1, ref List<Vector2> uvsTmp2, ref List<Color> colorsTmp, bool skipMiddles, bool weldVecs)
	{
		int count = vecs.Count;
		bool[] array = new bool[trisTmp.Count];
		int num = -1;
		for (int i = 0; i < vecsTmp.Count; i++)
		{
			vecs.Add(vecsTmp[i]);
			uvs.Add(uvsTmp[i]);
			num = vecs.Count - 1;
			for (int j = 0; j < trisTmp.Count; j++)
			{
				if (trisTmp[j] == i && !array[j])
				{
					trisTmp[j] = num;
					array[j] = true;
				}
			}
		}
		tris.AddRange(trisTmp);
		trisTmp.Clear();
		vecsTmp.Clear();
		uvsTmp.Clear();
		uvsTmp1.Clear();
		uvsTmp2.Clear();
		colorsTmp.Clear();
	}

	private static void MergeMeshDataExt(ref List<List<int>> tris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<Vector2> uvs1, ref List<Vector2> uvs2, ref List<Color> colors, ref List<int> trisTmp, ref List<Vector3> vecsTmp, ref List<Vector2> uvsTmp, ref List<Vector2> uvsTmp1, ref List<Vector2> uvsTmp2, ref List<Color> colorsTmp, bool skipMiddles, bool weldVecs, Material mat, ref List<Material> mats)
	{
		int num = -1;
		if (mat == null && mats.Count == 0)
		{
			mats.Add(mat);
			tris.Add(new List<int>());
			num = 0;
		}
		for (int i = 0; i < mats.Count; i++)
		{
			if (mats[i] == mat)
			{
				num = i;
				break;
			}
		}
		if (num == -1)
		{
			mats.Add(mat);
			tris.Add(new List<int>());
			num = mats.Count - 1;
		}
		bool[] array = new bool[trisTmp.Count];
		int num2 = -1;
		for (int j = 0; j < vecsTmp.Count; j++)
		{
			num2 = -1;
			if ((!skipMiddles || vecsTmp[j].x != 0f) && weldVecs)
			{
				for (int k = 0; k < vecs.Count; k++)
				{
					if (vecsTmp[j] == vecs[k])
					{
						num2 = k;
						break;
					}
				}
			}
			if (num2 == -1 || !weldVecs)
			{
				vecs.Add(vecsTmp[j]);
				uvs.Add(uvsTmp[j]);
				num2 = vecs.Count - 1;
			}
			for (int l = 0; l < trisTmp.Count; l++)
			{
				if (trisTmp[l] == j && !array[l])
				{
					trisTmp[l] = num2;
					array[l] = true;
				}
			}
		}
		tris[num].AddRange(trisTmp);
		trisTmp.Clear();
		vecsTmp.Clear();
		uvsTmp.Clear();
		uvsTmp1.Clear();
		uvsTmp2.Clear();
		colorsTmp.Clear();
	}

	private void OCQODCOQDO(ref List<int> tris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<Vector2> uvs1, ref List<Vector2> uvs2, ref List<Color> colors, ref List<int> trisTmp, ref List<Vector3> vecsTmp, ref List<Vector2> uvsTmp, ref List<Vector2> uvsTmp1, ref List<Vector2> uvsTmp2, ref List<Color> colorsTmp, bool skipMiddles, bool weldVecs)
	{
		bool[] array = new bool[trisTmp.Count];
		int num = -1;
		for (int i = 0; i < vecsTmp.Count; i++)
		{
			num = -1;
			if ((!skipMiddles || vecsTmp[i].x != 0f) && weldVecs)
			{
				for (int j = 0; j < vecs.Count; j++)
				{
					if (vecsTmp[i] == vecs[j])
					{
						num = j;
						break;
					}
				}
			}
			if (num == -1 || !weldVecs)
			{
				vecs.Add(vecsTmp[i]);
				uvs.Add(uvsTmp[i]);
				num = vecs.Count - 1;
			}
			for (int k = 0; k < trisTmp.Count; k++)
			{
				if (trisTmp[k] == i && !array[k])
				{
					trisTmp[k] = num;
					array[k] = true;
				}
			}
		}
		tris.AddRange(trisTmp);
		trisTmp.Clear();
		vecsTmp.Clear();
		uvsTmp.Clear();
		uvsTmp1.Clear();
		uvsTmp2.Clear();
		colorsTmp.Clear();
	}

	public static List<int> Triangulate(List<Vector3> vecs, List<Vector3> edges)
	{
		List<Vector2> list = new List<Vector2>();
		List<PointER> list2 = new List<PointER>();
		for (int i = 0; i < vecs.Count; i++)
		{
			Vector3 vector = vecs[i];
			list2.Add(new PointER(vector.x, vector.z, 0f));
		}
		for (int j = 0; j < edges.Count; j++)
		{
			Vector3 vector = edges[j];
			list.Add(new Vector2(vector.x, vector.z));
		}
		List<int> list3 = new List<int>();
		List<int> list4 = new List<int>();
		List<TriangleER> list5 = delaunayER.Triangulate(list2);
		for (int k = 0; k < list5.Count; k++)
		{
			list3.Add(delaunayER.FindVertice(new Vector3(list5[k].Vertex1.x, list5[k].Vertex1.z, list5[k].Vertex1.y), vecs));
			list3.Add(delaunayER.FindVertice(new Vector3(list5[k].Vertex3.x, list5[k].Vertex3.z, list5[k].Vertex3.y), vecs));
			list3.Add(delaunayER.FindVertice(new Vector3(list5[k].Vertex2.x, list5[k].Vertex2.z, list5[k].Vertex2.y), vecs));
		}
		for (int l = 0; l < list3.Count; l += 3)
		{
			if (list.Count == 0)
			{
				list4.Add(list3[l]);
				list4.Add(list3[l + 1]);
				list4.Add(list3[l + 2]);
				continue;
			}
			Vector3 vector2 = (vecs[list3[l]] + vecs[list3[l + 1]] + vecs[list3[l + 2]]) / 3f;
			if (ODDCQDDCDD.OCCQDQQDCC(list.Count, list, vector2.x, vector2.z))
			{
				list4.Add(list3[l]);
				list4.Add(list3[l + 1]);
				list4.Add(list3[l + 2]);
			}
		}
		return list4;
	}

	public static void OCQDDOQCOQ(QDOODOQQDQODD connection, ERConnectionSibling sibling, int index, int total)
	{
		if (sibling != secondPriorityConnection)
		{
			sibling.uvy = sibling.roadUVs[0][0].y;
			sibling.uvy -= Mathf.Floor(sibling.uvy);
		}
		if (sibling == primaryPriorityConnection)
		{
			secondPriorityConnection.uvy = sibling.roadUVs[0][sibling.roadUVs[0].Count - 1].y;
			secondPriorityConnection.uvy -= Mathf.Floor(secondPriorityConnection.uvy);
		}
		connection.centerPoint = (connection.tmpCenterPoint = ODQDQDQDQO.OQQCQOCCOQ(sibling.roadVecs[0][0], sibling.roadVecs[sibling.roadVecs.Count - 1][0], sibling.cp));
		connection.centerPoint.y = (connection.tmpCenterPoint.y = 0f);
		Vector3 normalized = (sibling.roadVecs[0][0] - sibling.roadVecs[sibling.roadVecs.Count - 1][0]).normalized;
		normalized = new Vector3(normalized.z, 0f, 0f - normalized.x).normalized;
		sibling.controlPoint = (connection.controlPointV3 = connection.centerPoint + normalized * 5f);
		connection.controlPointV3 = sibling.controlPoint;
		connection.controlPoint = new Vector3(sibling.controlPoint.x, sibling.controlPoint.z);
		connection.rotationPriority = false;
		normalized = (sibling.controlPoint - connection.centerPoint).normalized;
		connection.alignmentHandleVec = connection.centerPoint + normalized * 2f;
		connection.roadType = sibling.roadType.id;
		connection.connectionVecInts.Clear();
		connection.blendCornerPointInts.Clear();
		connection.blendCornerPointWeights.Clear();
		connection.roadShapeUVY.Clear();
		QDOQDSQOOQDDD qDOQDSQOOQDDD = null;
		QDOQDSQOOQDDD qDOQDSQOOQDDD2 = null;
		qDOQDSQOOQDDD2 = prefabScript.sidewalkControlElements[index];
		qDOQDSQOOQDDD = ((index >= total - 1) ? prefabScript.sidewalkControlElements[0] : prefabScript.sidewalkControlElements[index + 1]);
		connection.sidewalkLeftUVY.Clear();
		connection.sidewalkLeftConnectionVecInts.Clear();
		if (connection.includeLeftSidewalk)
		{
			connection.sidewalkLeftConnectionVecInts.Reverse();
			connection.sidewalkLeftUVY.AddRange(qDOQDSQOOQDDD.sidewalkUVs);
			connection.sidewalkLeftUVY.Reverse();
		}
		connection.connectionVecInts = new List<int>(sibling.connectionVecInts);
		connection.roadShapeUVY.Clear();
		for (int i = 0; i < sibling.roadShape.Count; i++)
		{
			if (sibling.originalShapeVecs[i])
			{
				connection.roadShapeUVY.Add(sibling.roadShapeUVs[i]);
			}
		}
		connection.sidewalkRightUVY.Clear();
		connection.sidewalkRightConnectionVecInts.Clear();
		if (connection.includeRightSidewalk)
		{
		}
		connection.connectionVecInts.InsertRange(0, connection.sidewalkLeftConnectionVecInts);
		connection.connectionVecInts.AddRange(connection.sidewalkRightConnectionVecInts);
		connection.fullConnectionVecInts = new List<int>(connection.connectionVecInts);
		connection.leftInt = 0;
		connection.leftIntFull = 0;
		connection.rightInt = connection.connectionVecInts.Count - 1;
		connection.rightIntFull = connection.fullConnectionVecInts.Count - 1;
		connection.roadShapeVecs.Clear();
		connection.sidewalkLeftVecs.Clear();
		connection.sidewalkRightVecs.Clear();
		if (sibling.leftSidewalkActive && sibling.leftSidewalk != null)
		{
			for (int j = 0; j < sibling.leftSidewalk.shape.Count; j++)
			{
				Vector2 item = sibling.leftSidewalk.shape[j];
				item.x += sibling.roadShape[0].x;
				connection.sidewalkLeftVecs.Add(item);
			}
			connection.sidewalkLeftUVY.AddRange(sibling.leftSidewalk.sidewalkUVs);
		}
		if (sibling.rightSidewalkActive && sibling.rightSidewalk != null)
		{
			for (int k = 0; k < sibling.rightSidewalk.shape.Count; k++)
			{
				Vector2 item2 = sibling.rightSidewalk.shape[k];
				item2.x += sibling.roadShape[0].x;
				connection.sidewalkRightVecs.Add(item2);
			}
			connection.sidewalkRightUVY.AddRange(sibling.rightSidewalk.sidewalkUVs);
		}
		Vector3 zero;
		Vector3 vector = (zero = Vector3.zero);
		Vector3 a = ((sibling.leftSidewalk == null || sibling.leftSidewalkVecs.Count <= 0) ? sibling.roadVecs[0][0] : sibling.leftSidewalkVecs[0][0]);
		Vector3 b = ((sibling.rightSidewalk == null || sibling.rightSidewalkVecs.Count <= 0) ? sibling.roadVecs[sibling.roadVecs.Count - 1][0] : sibling.rightSidewalkVecs[sibling.rightSidewalkVecs.Count - 1][0]);
		Vector3 centerPoint = connection.centerPoint;
		float num = Vector3.Distance(a, b) * 0.5f;
		for (int l = 0; l < connection.connectionVecInts.Count - 1; l++)
		{
		}
		List<Vector2> list = new List<Vector2>();
		if (connection.includeLeftSidewalk && sibling.leftSidewalkVecs.Count > 0)
		{
			list.AddRange(connection.sidewalkLeftVecs);
			UnityEngine.Debug.Log("check if we have to reverse with new sidwalk code!!!");
			connection.roadShapeVecs.AddRange(list);
		}
		list.Clear();
		list.AddRange(sibling.roadType.roadShape);
		if (vector == Vector3.zero)
		{
			vector = list[0];
		}
		zero = list[list.Count - 1];
		connection.roadShapeVecs.AddRange(list);
		if (connection.includeRightSidewalk && sibling.rightSidewalkVecs.Count > 0)
		{
			list.Clear();
			list.AddRange(connection.sidewalkRightVecs);
			connection.roadShapeVecs.AddRange(list);
		}
		vector.y = 0f;
		zero.y = 0f;
		float num2 = Vector3.Distance(vector, zero);
		connection.centerPointPercentage = num / num2;
		connection.roadShapeVecsString = ERCrossings.GetRoadShapeVecString(connection.roadShapeVecs, connection.sidewalkLeftVecs, connection.sidewalkRightVecs, ref connection.roadShapeMatchCount);
		QDOODOQQDQODD qDOODOQQDQODD = prefabScript.crossingElements[index];
		qDOQDSQOOQDDD2 = prefabScript.sidewalkControlElements[index];
		qDOQDSQOOQDDD = null;
		if (index < total - 1)
		{
			qDOQDSQOOQDDD = prefabScript.sidewalkControlElements[index + 1];
		}
		else
		{
			qDOQDSQOOQDDD = prefabScript.sidewalkControlElements[0];
		}
		connection.roadMaterial = sibling.roadType.roadMaterial;
		List<Material> list2 = new List<Material>();
		List<int> list3 = new List<int>();
		list2.Add(sibling.roadType.roadMaterial);
		int count = sibling.leftSidewalkVecs.Count;
		if (connection.includeLeftSidewalk && count > 0)
		{
			if (list2[0] != sibling.leftSidewalk.material)
			{
				list2.Add(sibling.leftSidewalk.material);
				for (int m = 0; m < count; m++)
				{
					list3.Add(1);
				}
			}
			else
			{
				for (int n = 0; n < count; n++)
				{
					list3.Add(0);
				}
			}
		}
		for (int num3 = 0; num3 < sibling.roadType.roadShape.Count; num3++)
		{
			list3.Add(0);
		}
		int count2 = sibling.rightSidewalkVecs.Count;
		if (qDOODOQQDQODD.includeRightSidewalk && count2 > 0)
		{
			if (list2[0] != sibling.rightSidewalk.material && sibling.leftSidewalk.material != sibling.rightSidewalk.material && qDOODOQQDQODD.includeLeftSidewalk && count == 0)
			{
				list2.Add(qDOQDSQOOQDDD2.sidewalkMaterial);
				for (int num4 = 0; num4 < count2; num4++)
				{
					list3.Add(2);
				}
			}
			else if (list2[0] == sibling.rightSidewalk.material)
			{
				for (int num5 = 0; num5 < count2; num5++)
				{
					list3.Add(0);
				}
			}
			else if (sibling.leftSidewalk.material == sibling.rightSidewalk.material || (!qDOODOQQDQODD.includeLeftSidewalk && count == 0))
			{
				if (!qDOODOQQDQODD.includeLeftSidewalk && count == 0)
				{
					list2.Add(sibling.rightSidewalk.material);
				}
				for (int num6 = 0; num6 < count2; num6++)
				{
					list3.Add(1);
				}
			}
		}
		connection.roadMaterials = list2.ToArray();
		connection.roadShapeMaterialInts.Clear();
		connection.roadShapeMaterialInts.AddRange(list3);
		connection.roadMaterial = sibling.roadType.roadMaterial;
		connection.doConnectionTri.Clear();
		connection.doConnectionTri = new List<bool>(sibling.roadType.doConnectionTri);
		connection.hardEdge.Clear();
		connection.hardEdge = new List<bool>(sibling.roadType.hardEdge);
		connection.roadType = sibling.roadType.id;
		connection.roadTypeTimestamp = sibling.roadType.timestamp;
		prefabScript.sidewalkControlElements[index].crossingElementRightIndex = index;
		if (index == 0)
		{
			prefabScript.sidewalkControlElements[index].crossingElementLeftIndex = total - 1;
		}
		else
		{
			prefabScript.sidewalkControlElements[index].crossingElementLeftIndex = index - 1;
		}
	}

	public static void OOCQCOOOOO(List<ERConnectionSibling> siblings, int index)
	{
		if (baseScript == null)
		{
			baseScript = UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase;
		}
		float minIndent = baseScript.minIndent;
		float minSurrounding = baseScript.minSurrounding;
		ERConnectionSibling eRConnectionSibling = siblings[index];
		if (eRConnectionSibling == primaryPriorityConnection || eRConnectionSibling == secondPriorityConnection)
		{
			if (eRConnectionSibling.middleIndentIndexRight == -1)
			{
				eRConnectionSibling.middleIndentIndexRight = Mathf.RoundToInt((float)eRConnectionSibling.rightRoundingPoints.Count * 0.5f + 1f);
			}
			if (eRConnectionSibling.middleIndentIndexLeft == -1)
			{
				eRConnectionSibling.middleIndentIndexLeft = Mathf.RoundToInt((float)eRConnectionSibling.leftRoundingPoints.Count * 0.5f + 1f);
			}
		}
		List<Vector3> leftRoundingPoints = eRConnectionSibling.leftRoundingPoints;
		Vector3 normalized;
		Vector3 vector;
		if (eRConnectionSibling.middleIndentIndexLeft == -1)
		{
			vector = leftRoundingPoints[leftRoundingPoints.Count - 1];
			vector.y = 0f;
			Vector3 vector2 = -eRConnectionSibling.dir;
			Vector3 vector3 = ((index != siblings.Count - 1) ? (-siblings[index + 1].dir) : (-siblings[0].dir));
			normalized = Vector3.Lerp(vector2, vector3, 0.5f).normalized;
			Vector3 vector4 = vector + vector2 * 2f;
			Vector3 vector5 = vector + vector3 * 2f;
			Vector3 vector6 = vector + normalized * 2f;
		}
		else
		{
			vector = leftRoundingPoints[eRConnectionSibling.middleIndentIndexLeft];
			Vector3 vector2 = -eRConnectionSibling.dir;
			Vector3 vector3 = ((index != siblings.Count - 1) ? (-siblings[index + 1].dir) : (-siblings[0].dir));
			normalized = Vector3.Lerp(vector2, vector3, 0.5f).normalized;
		}
		Vector3 vector7 = vector + normalized * minIndent;
		if (ODQDQDQDQO.OQCDCDOOCD(vector, leftRoundingPoints[0], vector7))
		{
			normalized *= -1f;
			vector7 = vector + normalized * minIndent;
		}
		Vector3 vector8 = vector;
		Vector3 vector9 = vector7 + normalized * minSurrounding;
		int num = leftRoundingPoints.Count;
		if (leftRoundingPoints[leftRoundingPoints.Count - 1] == Vector3.zero)
		{
			num--;
		}
		for (int i = 0; i < num; i++)
		{
			vector = leftRoundingPoints[i];
			vector.y = 0f;
			Vector3 vector10;
			if (i == 0)
			{
				vector10 = leftRoundingPoints[1] - leftRoundingPoints[0];
				vector10 = new Vector3(0f - vector10.z, 0f, vector10.x).normalized;
			}
			else if (i < num - 1)
			{
				vector10 = leftRoundingPoints[i + 1] - leftRoundingPoints[i - 1];
				vector10 = new Vector3(0f - vector10.z, 0f, vector10.x).normalized;
			}
			else
			{
				vector10 = normalized;
			}
			Vector3 vector11 = vector + vector10 * minIndent;
			Vector3 vector12 = vector + vector10 * (minIndent + minSurrounding);
			if (ODQDQDQDQO.OQCDCDOOCD(vector, vector11, vector8))
			{
				vector11 = vector7;
				vector12 = vector9;
			}
			else if (ODQDQDQDQO.OQCDCDOOCD(vector7, vector8, vector11))
			{
				vector11 = vector7;
				vector12 = vector9;
			}
			else if (ODQDQDQDQO.OQCDCDOOCD(vector9, vector8, vector12))
			{
				vector12 = vector9;
			}
			eRConnectionSibling.leftIndentvecs.Add(vector11);
			eRConnectionSibling.leftSurroundingvecs.Add(vector12);
		}
		leftRoundingPoints = eRConnectionSibling.rightRoundingPoints;
		if (eRConnectionSibling.middleIndentIndexRight == -1)
		{
			vector = leftRoundingPoints[leftRoundingPoints.Count - 1];
			vector.y = 0f;
			Vector3 vector2 = -eRConnectionSibling.dir;
			Vector3 vector3 = ((index != 0) ? (-siblings[index - 1].dir) : (-siblings[siblings.Count - 1].dir));
			normalized = Vector3.Lerp(vector2, vector3, 0.5f).normalized;
			Vector3 vector13 = vector + vector2 * 2f;
			Vector3 vector14 = vector + vector3 * 2f;
			Vector3 vector15 = vector + normalized * 2f;
		}
		else
		{
			vector = leftRoundingPoints[eRConnectionSibling.middleIndentIndexRight];
			Vector3 vector2 = -eRConnectionSibling.dir;
			Vector3 vector3 = ((index != 0) ? (-siblings[index - 1].dir) : (-siblings[siblings.Count - 1].dir));
			normalized = Vector3.Lerp(vector2, vector3, 0.5f).normalized;
		}
		vector7 = vector + normalized * minIndent;
		if (!ODQDQDQDQO.OQCDCDOOCD(vector, leftRoundingPoints[0], vector7))
		{
			normalized *= -1f;
			vector7 = vector + normalized * minIndent;
		}
		vector8 = vector;
		vector9 = vector + normalized * (minIndent + minSurrounding);
		num = leftRoundingPoints.Count;
		if (leftRoundingPoints[leftRoundingPoints.Count - 1] == Vector3.zero)
		{
			num--;
		}
		for (int j = 0; j < num; j++)
		{
			vector = leftRoundingPoints[j];
			vector.y = 0f;
			Vector3 vector10;
			if (j == 0)
			{
				vector10 = leftRoundingPoints[1] - leftRoundingPoints[0];
				vector10 = new Vector3(vector10.z, 0f, 0f - vector10.x).normalized;
			}
			else if (j < num - 1)
			{
				vector10 = leftRoundingPoints[j + 1] - leftRoundingPoints[j - 1];
				vector10 = new Vector3(vector10.z, 0f, 0f - vector10.x).normalized;
			}
			else
			{
				vector10 = normalized;
			}
			Vector3 vector16 = vector + vector10 * minIndent;
			Vector3 vector17 = vector + vector10 * (minIndent + minSurrounding);
			if (!ODQDQDQDQO.OQCDCDOOCD(vector, vector16, vector8))
			{
				vector16 = vector7;
				vector17 = vector9;
			}
			else if (!ODQDQDQDQO.OQCDCDOOCD(vector7, vector8, vector16))
			{
				vector16 = vector7;
				vector17 = vector9;
			}
			else if (!ODQDQDQDQO.OQCDCDOOCD(vector9, vector8, vector17))
			{
				vector17 = vector9;
			}
			eRConnectionSibling.rightIndentvecs.Add(vector16);
			eRConnectionSibling.rightSurroundingvecs.Add(vector17);
		}
	}

	public static bool OQQQQQQQCD(QDQDOOQQDQODD roadType)
	{
		int num = 0;
		for (int i = 0; i < siblings.Count; i++)
		{
			if (siblings[i].roadType.id == roadType.id)
			{
				num++;
				if (num > 1)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static Vector3 OOQCQDQCOO(int index, Vector3 p0, Vector3 p1, Vector3 p2)
	{
		Vector3 vector = cScr.transform.TransformPoint(Vector3.zero);
		float num = Vector3.Distance(vector, p1);
		float num2 = Vector3.Distance(vector, p0);
		if (num2 == 0f)
		{
			num2 = 5f;
		}
		float t = num2 / num;
		float num3 = Vector3.Distance(p1, p2);
		Vector3 p3 = vector + (vector - p1).normalized * Vector3.Distance(p1, p2);
		Vector3 position = ERModularRoad.OODODQQQCD(p3, vector, p1, p2, t, 0.5f);
		siblings[index].angleControlPoint = cScr.transform.InverseTransformPoint(position);
		ODODCOOQDO();
		return cScr.transform.TransformPoint(prefabScript.crossingElements[index].centerPoint);
	}

	public static void Clear()
	{
		ll1.Clear();
		ll2.Clear();
		ll3.Clear();
		ll4.Clear();
		á = 0f;
		á = 0f;
	}

	public static void OOODDOCOOO()
	{
	}

	public static void OOOQQDDCCQ(ERTexture roadERTexture, ref float roadWidth, ref float leftIndent, ref float rightIndent, ref float leftUVX, ref float rightUVX, ref float leftIndentInner, ref float rightIndentInner, ref float roadOuterUVXInner, float cornerRadius)
	{
		if (roadERTexture != null)
		{
			roadWidth = roadERTexture.roadWidth;
			leftIndent = roadERTexture.roadWidth * roadERTexture.leftOffset;
			leftUVX = roadERTexture.leftOffset;
			leftIndentInner = roadERTexture.roadWidth * roadERTexture.leftInnerOffset;
			roadOuterUVXInner = roadERTexture.leftInnerOffset;
			rightIndent = roadERTexture.roadWidth * roadERTexture.rightOffset;
			rightIndentInner = roadERTexture.roadWidth * roadERTexture.rightInnerOffset;
			rightUVX = 1f - roadERTexture.rightOffset;
			UnityEngine.Debug.Log(roadERTexture.leftOffset + " " + roadERTexture.roadWidth + " " + leftIndent + " " + leftUVX + " " + leftIndentInner + " " + roadOuterUVXInner);
		}
		else
		{
			leftIndent = 0.25f;
			leftUVX = 0.25f / cornerRadius;
			leftIndentInner = 0.1f;
			roadOuterUVXInner = 0.1f / cornerRadius;
			rightIndent = 0.25f;
			rightIndentInner = 0.1f;
			rightUVX = 0.25f / cornerRadius;
			UnityEngine.Debug.Log("EasyRoads3Dv3: No indent texture info found for the selected connection material. The connection material is either null or no texture info has been assigned for the repsective material");
		}
	}

	public static void OQOCODDDDC(int connection, QDQDOOQQDQODD roadType)
	{
		List<Vector2> list = new List<Vector2>(roadType.roadShape);
		List<float> list2 = new List<float>(roadType.roadShapeUVs);
		List<Vector2> list3 = new List<Vector2>(roadType.roadShapeExt);
		List<float> list4 = new List<float>(roadType.roadShapeExtUVs);
	}

	public static float OOCDQCOCQO(Vector3 v1, Vector3 v2, Vector3 n)
	{
		float num = Vector3.Angle(v1, v2);
		float num2 = Mathf.Sign(Vector3.Dot(n, Vector3.Cross(v1, v2)));
		float num3 = num * num2;
		return (num3 + 180f) % 360f;
	}

	public static Vector3 OQOQODOOCD(Vector3 dirPos1, Vector3 dirPos2, Vector3 currentPos, List<Vector3> vecs, int startend)
	{
		Vector3 normalized = (dirPos2 - dirPos1).normalized;
		Vector3 p = currentPos + normalized * 100f;
		int num = vecs.Count - 1;
		if (startend == 0)
		{
			for (int i = 0; i < num; i++)
			{
				Vector3 vector = ODQDQDQDQO.OODOQDOODO(currentPos, p, vecs[i], vecs[i + 1], flag: false);
				if (OQQOCCCOCD(vecs[i], vecs[i + 1], vector))
				{
					return vector;
				}
			}
		}
		else
		{
			for (int num2 = num; num2 > 0; num2--)
			{
				Vector3 vector2 = ODQDQDQDQO.OODOQDOODO(currentPos, p, vecs[num2], vecs[num2 - 1], flag: false);
				if (OQQOCCCOCD(vecs[num2], vecs[num2 - 1], vector2))
				{
					return vector2;
				}
			}
		}
		return Vector3.zero;
	}

	public static Vector3 ODQQOCDCOC(Vector3 currentPos, List<Vector3> vecs, ref int index, int startend)
	{
		index = -1;
		int num = vecs.Count - 1;
		if (startend == 0)
		{
			for (int i = 0; i < num; i++)
			{
				if (vecs[i] != Vector3.zero)
				{
					Vector3 vector = ODQDQDQDQO.OQQCQOCCOQ(vecs[i], vecs[i + 1], currentPos);
					if (OQQOCCCOCD(vecs[i], vecs[i + 1], vector))
					{
						index = i;
						return vector;
					}
				}
			}
		}
		else
		{
			for (int num2 = num; num2 > 0; num2--)
			{
				if (vecs[num2] != Vector3.zero)
				{
					Vector3 vector2 = ODQDQDQDQO.OQQCQOCCOQ(vecs[num2], vecs[num2 - 1], currentPos);
					if (OQQOCCCOCD(vecs[num2], vecs[num2 - 1], vector2))
					{
						index = num2 - 1;
						return vector2;
					}
				}
			}
		}
		return Vector3.zero;
	}

	public static bool OQQOCCCOCD(Vector3 p1, Vector3 p2, Vector3 v)
	{
		float num = Vector3.Distance(p1, p2);
		float num2 = Vector3.Distance(p1, v);
		float num3 = Vector3.Distance(v, p2);
		if (num2 < num && num3 < num)
		{
			return true;
		}
		return false;
	}
}
[Serializable]
public class ERMarkerExt : ScriptableObject
{
	public bool activeSplineNode = true;

	public float leftIndent = 5f;

	public int leftIndentAlignment = 0;

	public float rightIndent = 5f;

	public int rightIndentAlignment = 0;

	public float leftSurrounding = 5f;

	public float rightSurrounding = 5f;

	public float radius = 0f;

	public bool bridgeObject = false;

	public float bridgeStartLevelDistance = 0f;

	public float bridgeEndLevelDistance = 0f;

	public float rotation = 0f;

	public Vector3 position = Vector3.zero;

	public Vector3 oldPosition = Vector3.zero;

	public Vector3 positionTmp = Vector3.zero;

	public int controlType = 0;

	public int controlTypeTmp = 0;

	public int rotations = 0;

	public float circularRadius = 1f;

	public float circularAngle = 90f;

	public int circularSegments = 10;

	public float splineStrength = 0.5f;

	public Vector3 direction;

	public Vector3 direction1;

	public Vector3 rl;

	public Vector3 rr;

	public bool followTerrainContours = false;

	public int startSplinePoint = 0;

	public float startDistance = 0f;

	public float startUVY = 0f;

	public float totalDistance = 0f;

	public string totalDistanceString = "";

	public string angleString = "";

	public string gradeString = "";

	public float rotationCenter = 0.5f;

	public List<ERSOMarkerExt> soData = new List<ERSOMarkerExt>();

	public ERMarkerControlType controllerType;

	public float randomYPosition = 0f;

	public float randomMinYPosition = -0.02f;

	public float randomMaxYPosition = 0.02f;

	public float minRandomYPositionDistance = 15f;

	public float maxRandomYPositionDistance = 35f;

	public float randomMinRotation = -1f;

	public float randomMaxRotation = 1f;

	public float minRandomRotationDistance = 15f;

	public float maxRandomRotationDistance = 35f;

	public float prevLeftIndent = 0f;

	public float prevRightIndent = 0f;

	public float prevLeftSurrounding = 0f;

	public float prevRightSurrounding = 0f;

	public int prevControlType = 0;

	public bool attachExit = false;

	public int exitType = 0;

	public int exitGeometryType;

	public int startExitInt = 0;

	public int endExitInt = 0;

	public float startExitOffset = 0f;

	public float extrusionDistance = 10f;

	public int extrusionType = 0;

	public float fixedDistance = 10f;

	public float connectionAngle = 10f;

	public float connectionRadius = 5f;

	public Material exitMaterial;

	public Material connectionMaterial;

	public int exitRoadType = 0;

	public int connectionRoadType = 0;

	public List<List<Vector3>> exitOuterVerticesExtrusion = new List<List<Vector3>>();

	public List<List<Vector3>> exitOuterVerticesFixed = new List<List<Vector3>>();

	public List<List<Vector3>> exitOuterVerticesCurve = new List<List<Vector3>>();

	public List<Vector3> exitInnerVertices = new List<Vector3>();

	public Color customColor = Color.red;

	public List<Vector2> roadShape = new List<Vector2>();

	public List<Vector3> roadShapeVecsGlobal = new List<Vector3>();

	public float roadShapeDistanceMin = 0f;

	public float roadShapeDistanceMax = 1f;

	public Vector3 perpDir = Vector3.zero;

	public Vector3 perpDirRotated = Vector3.zero;

	public float markerStartUVY = 0f;

	public List<Vector3> customPoints = new List<Vector3>();

	public void Init(Vector3 pos, ERModularRoad scr, int element)
	{
		position = pos;
		splineStrength = 0.5f;
		followTerrainContours = scr.followTerrainContours;
		controlType = scr.defaultControlType;
		leftIndent = scr.indent;
		rightIndent = scr.indent;
		leftSurrounding = scr.surrounding;
		rightSurrounding = scr.surrounding;
		if (scr.markersExt.Count == 0)
		{
			roadShape = new List<Vector2>(scr.roadShape);
		}
		else if (element == 0)
		{
			roadShape = new List<Vector2>(scr.markersExt[0].roadShape);
		}
		else
		{
			roadShape = new List<Vector2>(scr.markersExt[element - 1].roadShape);
		}
		randomMinYPosition = scr.randomMinYPosition;
		randomMaxYPosition = scr.randomMaxYPosition;
		minRandomYPositionDistance = scr.minRandomYPositionDistance;
		maxRandomYPositionDistance = scr.maxRandomYPositionDistance;
		randomMinRotation = scr.randomMinRotation;
		randomMaxRotation = scr.randomMaxRotation;
		minRandomRotationDistance = scr.minRandomRotationDistance;
		maxRandomRotationDistance = scr.maxRandomRotationDistance;
		QDQDOOQQDQODD qDQDOOQQDQODD = null;
		if (scr.markersExt.Count == 0 && scr.roadType != 0.0)
		{
			if (scr.baseScript == null)
			{
				if ((bool)scr.transform.parent.parent.gameObject.GetComponent<ERModularBase>())
				{
					scr.baseScript = scr.transform.parent.parent.gameObject.GetComponent<ERModularBase>();
				}
				else if ((bool)scr.transform.parent.parent.parent.gameObject.GetComponent<ERModularBase>())
				{
					scr.baseScript = scr.transform.parent.parent.parent.gameObject.GetComponent<ERModularBase>();
				}
				else if ((bool)scr.transform.parent.parent.parent.parent.gameObject.GetComponent<ERModularBase>())
				{
					scr.baseScript = scr.transform.parent.parent.parent.parent.gameObject.GetComponent<ERModularBase>();
				}
			}
			if (scr.baseScript != null)
			{
				qDQDOOQQDQODD = QDQDOOQQDQODD.GetRoadTypeElByID(scr.baseScript.roadTypes, scr.roadType);
			}
		}
		soData = new List<ERSOMarkerExt>();
		for (int i = 0; i < scr.soDataExt.Count; i++)
		{
			if (!scr.soDataExt[i].active)
			{
				continue;
			}
			soData.Add(ERSOMarkerExt.CreateInstance(scr.soDataExt[i].sideObject, flag: true));
			if (qDQDOOQQDQODD != null)
			{
				for (int j = 0; j < qDQDOOQQDQODD.soDataExt.Count; j++)
				{
					if (qDQDOOQQDQODD.soDataExt[j].id == soData[soData.Count - 1].id && qDQDOOQQDQODD.soDataExt[j].active)
					{
						soData[soData.Count - 1].active = qDQDOOQQDQODD.soDataExt[j].markerActive;
						soData[soData.Count - 1].xPosition = qDQDOOQQDQODD.soDataExt[j].xPosition;
					}
				}
			}
			if (scr.soDataExt[i].sideObject.dualSided)
			{
				soData[soData.Count - 1].otherSide = ERSOMarkerExt.CreateInstance(scr.soDataExt[i].sideObject, flag: true);
				soData[soData.Count - 1].otherSide.active = soData[soData.Count - 1].active;
				soData[soData.Count - 1].otherSide.splineActive = soData[soData.Count - 1].splineActive;
				soData[soData.Count - 1].otherSide.xPosition = 0f - soData[soData.Count - 1].xPosition;
				soData[soData.Count - 1].otherSide.sidewaysDistance = soData[soData.Count - 1].sidewaysDistance;
				soData[soData.Count - 1].otherSide.startOffset = soData[soData.Count - 1].startOffset;
				soData[soData.Count - 1].otherSide.endOffset = soData[soData.Count - 1].endOffset;
			}
			if (element != 0)
			{
				if (scr.markersExt[element - 1].soData.Count >= soData.Count)
				{
					soData[soData.Count - 1].OODOOOQQCO(scr.markersExt[element - 1].soData[soData.Count - 1]);
				}
			}
			else if (scr.markersExt.Count > 0 && scr.markersExt[soData.Count - 1].soData.Count >= soData.Count)
			{
				soData[soData.Count - 1].OODOOOQQCO(scr.markersExt[0].soData[soData.Count - 1]);
			}
			if (scr.markersExt.Count == 0 && scr.isSideObject)
			{
				soData[soData.Count - 1].active = true;
			}
		}
	}

	public static ERMarkerExt CreateInstance(Vector3 pos, ERModularRoad scr, int element)
	{
		ERMarkerExt eRMarkerExt = ScriptableObject.CreateInstance<ERMarkerExt>();
		eRMarkerExt.Init(pos, scr, element);
		return eRMarkerExt;
	}

	public void SetControlType(ERMarkerControlType type)
	{
		switch (type)
		{
		case ERMarkerControlType.Spline:
			controlType = 0;
			break;
		case ERMarkerControlType.StraightXZ:
			controlType = 1;
			break;
		case ERMarkerControlType.StraightXZY:
			controlType = 2;
			break;
		case ERMarkerControlType.Circular:
			controlType = 3;
			break;
		}
		controllerType = type;
	}

	public string[] SoNames()
	{
		List<string> list = new List<string>();
		if (soData.Count > 0)
		{
			int num = 1;
			for (int i = 0; i < soData.Count; i++)
			{
				if (soData[i] != null)
				{
					list.Add(num + ".  " + soData[i].sideObject.name);
					num++;
				}
				else
				{
					soData.RemoveAt(i);
					i--;
				}
			}
		}
		else
		{
			list.Add("No Side Objects Active");
		}
		return list.ToArray();
	}

	public static void OOQQCOQDQC(ERMarkerExt source, ERMarkerExt target, string name)
	{
		for (int i = 0; i < source.soData.Count; i++)
		{
			if (target.soData.Count < i + 1)
			{
				target.soData.Add(ERSOMarkerExt.CreateInstance(source.soData[i].sideObject, flag: true));
				target.soData[i].OODOOOQQCO(source.soData[i]);
			}
			else if (source.soData[i].sideObject != target.soData[i].sideObject)
			{
				target.soData[i].OODOOOQQCO(source.soData[i]);
			}
		}
		for (int j = source.soData.Count; j < target.soData.Count; j++)
		{
			target.soData.RemoveAt(j);
		}
		UnityEngine.Debug.Log("EasyRoads3Dv3: The side object marker data for road '" + name + "' was out of synch. This has been repaired");
	}
}
[AddComponentMenu("")]
public class OOCQQOOQOD : MonoBehaviour
{
	public static void OOQCQDDOOC(ERModularBase baseScript, ERCrossingPrefabs scr, int connectionSegment, ERModularRoad road, int startend)
	{
		if (scr == null || road == null)
		{
			return;
		}
		ERCrossings component = scr.gameObject.GetComponent<ERCrossings>();
		if (component == null && scr.gameObject.GetComponent<ERRoundabouts>() == null)
		{
			return;
		}
		if (startend == 0)
		{
			if (road.endPrefabScript != null && !road.endPrefabScript.isCustomPrefab && !road.endPrefabScript.isIConnector && !road.endPrefabScript.isFlexConnector && (scr.crossingElements[connectionSegment].includeLeftSidewalk != road.endPrefabScript.crossingElements[road.endConnectionSegment].includeRightSidewalk || scr.crossingElements[connectionSegment].includeRightSidewalk != road.endPrefabScript.crossingElements[road.endConnectionSegment].includeLeftSidewalk))
			{
				OODQQOQDOC(baseScript, scr, connectionSegment, road, road.endPrefabScript, road.endConnectionSegment);
			}
		}
		else if (road.startPrefabScript != null && !road.startPrefabScript.isCustomPrefab && !road.startPrefabScript.isIConnector && !road.startPrefabScript.isFlexConnector && (scr.crossingElements[connectionSegment].includeLeftSidewalk != road.startPrefabScript.crossingElements[road.startConnectionSegment].includeRightSidewalk || scr.crossingElements[connectionSegment].includeRightSidewalk != road.startPrefabScript.crossingElements[road.startConnectionSegment].includeLeftSidewalk))
		{
			OODQQOQDOC(baseScript, scr, connectionSegment, road, road.startPrefabScript, road.startConnectionSegment);
		}
	}

	public static void OCOCOCCDOO(ERModularBase baseScript, ERCrossingPrefabs scr, int connectionSegment, ERModularRoad road, int startend)
	{
		if (scr == null || road == null)
		{
			return;
		}
		ERCrossings component = scr.gameObject.GetComponent<ERCrossings>();
		if (component == null && scr.gameObject.GetComponent<ERRoundabouts>() == null)
		{
			return;
		}
		if (startend == 0)
		{
			if (road.endPrefabScript != null && !road.endPrefabScript.isFlexConnector)
			{
				if (road.endPrefabScript.isIConnector)
				{
					road.endPrefabScript.gameObject.GetComponent<ERIConnector>().OCQOQCDCQC(road);
				}
				else if (scr.crossingElements[connectionSegment].includeLeftSidewalk != road.endPrefabScript.crossingElements[road.endConnectionSegment].includeRightSidewalk || scr.crossingElements[connectionSegment].includeRightSidewalk != road.endPrefabScript.crossingElements[road.endConnectionSegment].includeLeftSidewalk)
				{
					OODQQOQDOC(baseScript, road.endPrefabScript, road.endConnectionSegment, road, scr, connectionSegment);
				}
			}
		}
		else if (road.startPrefabScript != null && !road.startPrefabScript.isFlexConnector)
		{
			if (road.startPrefabScript.isIConnector)
			{
				road.startPrefabScript.gameObject.GetComponent<ERIConnector>().OCQOQCDCQC(road);
			}
			else if (scr.crossingElements[connectionSegment].includeLeftSidewalk != road.startPrefabScript.crossingElements[road.startConnectionSegment].includeRightSidewalk || scr.crossingElements[connectionSegment].includeRightSidewalk != road.startPrefabScript.crossingElements[road.startConnectionSegment].includeLeftSidewalk)
			{
				OODQQOQDOC(baseScript, road.startPrefabScript, road.startConnectionSegment, road, scr, connectionSegment);
			}
		}
	}

	public static void OODQQOQDOC(ERModularBase baseScript, ERCrossingPrefabs scr, int connectionSegment, ERModularRoad road, ERCrossingPrefabs otherPrefabScript, int otherConnection)
	{
		if (scr.isIConnector)
		{
			return;
		}
		scr.crossingElements[connectionSegment].includeRightSidewalk = otherPrefabScript.crossingElements[otherConnection].includeLeftSidewalk;
		scr.crossingElements[connectionSegment].includeLeftSidewalk = otherPrefabScript.crossingElements[otherConnection].includeRightSidewalk;
		if (scr.crossingElements[connectionSegment].includeRightSidewalk || scr.crossingElements[connectionSegment].includeLeftSidewalk)
		{
		}
		if (baseScript.mirrorCrossings)
		{
			bool roadOnNeighbour = false;
			int cornerElement = -1;
			bool centerStatus = true;
			bool roadOnNeighbour2 = false;
			int cornerElement2 = -1;
			bool centerStatus2 = true;
			ODOCQDCDOQ(scr, connectionSegment, ref roadOnNeighbour, ref cornerElement, ref centerStatus);
			OQOOQCDOCD(otherPrefabScript, otherConnection, ref roadOnNeighbour2, ref cornerElement2, ref centerStatus2);
			if (!roadOnNeighbour)
			{
				OQOOQCDOCD(otherPrefabScript, otherConnection, ref roadOnNeighbour2, ref cornerElement2, ref centerStatus2);
				if (!otherPrefabScript.isCustomPrefab)
				{
					scr.sidewalkControlElements[cornerElement].renderFlag = otherPrefabScript.sidewalkControlElements[cornerElement2].renderFlag;
					scr.crossingElements[scr.sidewalkControlElements[cornerElement].crossingElementRightIndex].includeRightSidewalk = otherPrefabScript.crossingElements[otherPrefabScript.sidewalkControlElements[cornerElement2].crossingElementLeftIndex].includeLeftSidewalk;
				}
			}
			else if (!otherPrefabScript.isCustomPrefab && otherPrefabScript.sidewalkControlElements[cornerElement2].renderFlag)
			{
				scr.sidewalkControlElements[cornerElement].renderFlag = true;
			}
			roadOnNeighbour = false;
			cornerElement = -1;
			centerStatus = true;
			roadOnNeighbour2 = false;
			cornerElement2 = -1;
			centerStatus2 = true;
			OQOOQCDOCD(scr, connectionSegment, ref roadOnNeighbour, ref cornerElement, ref centerStatus);
			ODOCQDCDOQ(otherPrefabScript, otherConnection, ref roadOnNeighbour2, ref cornerElement2, ref centerStatus2);
			if (!roadOnNeighbour)
			{
				ODOCQDCDOQ(otherPrefabScript, otherConnection, ref roadOnNeighbour2, ref cornerElement2, ref centerStatus2);
				if (cornerElement >= 0 && cornerElement2 >= 0)
				{
					scr.sidewalkControlElements[cornerElement].renderFlag = otherPrefabScript.sidewalkControlElements[cornerElement2].renderFlag;
					scr.crossingElements[scr.sidewalkControlElements[cornerElement].crossingElementLeftIndex].includeLeftSidewalk = otherPrefabScript.crossingElements[otherPrefabScript.sidewalkControlElements[cornerElement2].crossingElementRightIndex].includeRightSidewalk;
				}
			}
			else if (otherPrefabScript.sidewalkControlElements[cornerElement2].renderFlag)
			{
				scr.sidewalkControlElements[cornerElement].renderFlag = true;
			}
		}
		if ((bool)scr.gameObject.GetComponent<ERCrossings>())
		{
			scr.gameObject.GetComponent<ERCrossings>().OCQDQODOQD(sidewalkSceneHandleFlag: false, rebuildRoads: true);
		}
		else if ((bool)scr.gameObject.GetComponent<ERRoundabouts>())
		{
			ERRoundabouts component = scr.gameObject.GetComponent<ERRoundabouts>();
			component.OOCDDOQDDO();
			component.OQQCDOQOOQ();
			component.ODDDOCDCQO();
			if (component.connections.Count > 0)
			{
				component.OOQQDCCCCC();
			}
		}
	}

	public static void ODOCQDCDOQ(ERCrossingPrefabs scr, int lookUpElement, ref bool roadOnNeighbour, ref int cornerElement, ref bool centerStatus)
	{
		for (int i = 0; i < scr.sidewalkControlElements.Count; i++)
		{
			if (scr.sidewalkControlElements[i].crossingElementLeftIndex == lookUpElement)
			{
				if (scr.crossingElements[scr.sidewalkControlElements[i].crossingElementRightIndex].connectedRoad != null)
				{
					roadOnNeighbour = true;
				}
				cornerElement = i;
				centerStatus = scr.sidewalkControlElements[i].renderFlag;
				break;
			}
		}
	}

	public static void OQOOQCDOCD(ERCrossingPrefabs scr, int lookUpElement, ref bool roadOnNeighbour, ref int cornerElement, ref bool centerStatus)
	{
		for (int i = 0; i < scr.sidewalkControlElements.Count; i++)
		{
			if (scr.sidewalkControlElements[i].crossingElementRightIndex == lookUpElement)
			{
				if (scr.crossingElements[scr.sidewalkControlElements[i].crossingElementLeftIndex].connectedRoad != null)
				{
					roadOnNeighbour = true;
				}
				cornerElement = i;
				centerStatus = scr.sidewalkControlElements[i].renderFlag;
				break;
			}
		}
	}

	public static bool CheckRoadTypeChanges(ERModularBase baseScript, ERCrossingPrefabs prefabScript, bool ercrossing, bool erroundabout)
	{
		if (prefabScript == null)
		{
			return false;
		}
		if (prefabScript.isCustomPrefab)
		{
			return false;
		}
		List<ERModularRoad> updatedRoads = new List<ERModularRoad>();
		if (prefabScript.crossingsScript == null && (bool)prefabScript.gameObject.GetComponent<ERCrossings>())
		{
			prefabScript.crossingsScript = prefabScript.gameObject.GetComponent<ERCrossings>();
		}
		if (prefabScript.roundaboutScript == null && (bool)prefabScript.gameObject.GetComponent<ERRoundabouts>())
		{
			prefabScript.roundaboutScript = prefabScript.gameObject.GetComponent<ERRoundabouts>();
		}
		bool result = false;
		bool flag = false;
		foreach (QDOODOQQDQODD crossingElement in prefabScript.crossingElements)
		{
			foreach (QDQDOOQQDQODD roadType in baseScript.roadTypes)
			{
				if (roadType.id == crossingElement.roadType)
				{
					if (prefabScript.crossingsScript != null && ercrossing)
					{
						flag = prefabScript.crossingsScript.UpdateToRoadType(roadType, ref updatedRoads);
					}
					else if (prefabScript.roundaboutScript != null && erroundabout)
					{
						flag = prefabScript.roundaboutScript.UpdateToRoadType(roadType);
					}
					result = true;
				}
			}
		}
		return result;
	}

	public static void UpdateToRoadType(ERCrossingPrefabs prefabScript, QDQDOOQQDQODD sourcePreset, ref List<ERModularRoad> updatedRoads)
	{
		List<int> list = new List<int>();
		if (0 == 0)
		{
			return;
		}
		for (int i = 0; i < list.Count; i++)
		{
			ERModularRoad connectedRoad = prefabScript.crossingElements[list[i]].connectedRoad;
			if ((bool)connectedRoad.startPrefabScript && (bool)connectedRoad.endPrefabScript)
			{
				connectedRoad.ODDDCDQCCO(prefabScript, list[i], reverse: true, uvReverse: true, UpdateResolutionFlag: false);
				if (connectedRoad.roadShape[0].x < 0f)
				{
					connectedRoad.ODDDCDQCCO(prefabScript, list[i], reverse: false, uvReverse: false, UpdateResolutionFlag: false);
				}
			}
			else if (prefabScript.crossingElements[list[i]].connectedMarker == 0)
			{
				connectedRoad.ODDDCDQCCO(prefabScript, list[i], reverse: true, uvReverse: true, UpdateResolutionFlag: false);
				if (connectedRoad.roadShape[0].x < 0f)
				{
					connectedRoad.ODDDCDQCCO(prefabScript, list[i], reverse: false, uvReverse: false, UpdateResolutionFlag: false);
				}
			}
			else
			{
				connectedRoad.ODDDCDQCCO(prefabScript, list[i], reverse: false, uvReverse: false, UpdateResolutionFlag: false);
				if (connectedRoad.roadShape[0].x < 0f)
				{
					connectedRoad.ODDDCDQCCO(prefabScript, list[i], reverse: true, uvReverse: true, UpdateResolutionFlag: false);
				}
			}
			connectedRoad.OCQOQCDCQC(ignorePrefabAlignment: true, forceAutoRotate: false);
		}
	}

	public static void SwapConnectionInit(ERModularBase scr, ERCrossingPrefabs prefab, ref int newIndex, ref int oldIndex, ref int index1, ref int index2, ref ERModularRoad road1, ref ERModularRoad road2)
	{
		int num = 0;
		foreach (QDOODOQQDQODD crossingElement in prefab.crossingElements)
		{
			if (crossingElement.connectedRoad != null)
			{
				if (index1 == -1)
				{
					index1 = num;
					road1 = crossingElement.connectedRoad;
				}
				else
				{
					index2 = num;
					road2 = crossingElement.connectedRoad;
				}
			}
			num++;
		}
		oldIndex = index1;
		if (index2 == -1)
		{
			OCODDODODQ(prefab, index1, ref newIndex);
		}
		else
		{
			newIndex = index2;
		}
	}

	public static void OCCDCDQOOD(ERModularBase scr, ERCrossingPrefabs prefab, int newIndex, int oldIndex, int index1, int index2, ERModularRoad road1, ERModularRoad road2)
	{
		int num = -1;
		if (road2 != null)
		{
			if (prefab.crossingElements[index2].connectedRoad.startPrefabScript == prefab)
			{
				prefab.crossingElements[index2].connectedRoad.startPrefabScript = null;
				prefab.crossingElements[index2].connectedRoad = null;
				num = 0;
			}
			else
			{
				prefab.crossingElements[index2].connectedRoad.endPrefabScript = null;
				prefab.crossingElements[index2].connectedRoad = null;
				num = road2.markersExt.Count - 1;
			}
		}
		int num2 = 0;
		Vector3 position;
		Vector3 vector;
		Vector3 oOCDQCOOQC;
		if (prefab.crossingElements[oldIndex].connectedRoad.startPrefabScript == prefab)
		{
			prefab.crossingElements[oldIndex].connectedRoad.startPrefabScript = null;
			prefab.crossingElements[oldIndex].connectedRoad.startConnectionSegment = -1;
			num2 = 0;
			road1.nodeWithinRange = 0;
			oOCDQCOOQC = (position = prefab.crossingElements[oldIndex].connectedRoad.markersExt[0].position);
			vector = prefab.crossingElements[oldIndex].connectedRoad.soSplinePoints[1];
			if (position == vector && prefab.crossingElements[oldIndex].connectedRoad.soSplinePoints.Count > 2)
			{
				vector = prefab.crossingElements[oldIndex].connectedRoad.soSplinePoints[2];
			}
		}
		else
		{
			prefab.crossingElements[oldIndex].connectedRoad.endPrefabScript = null;
			prefab.crossingElements[oldIndex].connectedRoad.endConnectionSegment = -1;
			num2 = 1;
			road1.nodeWithinRange = road1.markersExt.Count - 1;
			oOCDQCOOQC = (position = prefab.crossingElements[oldIndex].connectedRoad.markersExt[prefab.crossingElements[oldIndex].connectedRoad.markersExt.Count - 1].position);
			vector = prefab.crossingElements[oldIndex].connectedRoad.soSplinePoints[prefab.crossingElements[oldIndex].connectedRoad.soSplinePoints.Count - 2];
			if (position == vector && prefab.crossingElements[oldIndex].connectedRoad.soSplinePoints.Count > 2)
			{
				vector = prefab.crossingElements[oldIndex].connectedRoad.soSplinePoints[prefab.crossingElements[oldIndex].connectedRoad.soSplinePoints.Count - 3];
			}
		}
		prefab.crossingElements[oldIndex].connectedRoad = null;
		prefab.crossingElements[oldIndex].connectedMarker = -1;
		prefab.crossingElements[oldIndex].connectedRoadGO = null;
		if (road2 != null)
		{
			Vector3 vector2 = position - road2.markersExt[num].position;
			vector = position + vector2;
		}
		prefab.OOCQCCQDOQ(position, vector, newIndex, road1);
		ODQDQDQDQOExt.OCCCQODODQ(prefab, road1, road1.nodeWithinRange, newIndex);
		if (num2 == 0)
		{
			OCQOQOOOCO.ODQDCODODC(road1, oOCDQCOOQC, prefab, newIndex, reverse: true, uvReverse: false, forceAutoRotate: false);
		}
		else
		{
			OCQOQOOOCO.ODQDCODODC(road1, oOCDQCOOQC, prefab, newIndex, reverse: false, uvReverse: false, forceAutoRotate: false);
		}
		if (road2 != null)
		{
			oOCDQCOOQC = prefab.transform.TransformPoint(prefab.crossingElements[index1].tmpCenterPoint);
			ODQDQDQDQOExt.OCCCQODODQ(prefab, road2, road2.nodeWithinRange, index1);
			if (num == 0)
			{
				road2.nodeWithinRange = 0;
				OCQOQOOOCO.ODQDCODODC(road2, oOCDQCOOQC, prefab, index1, reverse: true, uvReverse: false, forceAutoRotate: false);
			}
			else
			{
				road2.nodeWithinRange = num;
				OCQOQOOOCO.ODQDCODODC(road2, oOCDQCOOQC, prefab, index1, reverse: false, uvReverse: false, forceAutoRotate: false);
			}
		}
	}

	public static void OCODDODODQ(ERCrossingPrefabs prefab, int index, ref int newIndex)
	{
		int roadShapeMatchCount = prefab.crossingElements[index].roadShapeMatchCount;
		index++;
		if (index >= prefab.crossingElements.Count)
		{
			index = 0;
		}
		for (int i = index; i < prefab.crossingElements.Count; i++)
		{
			if (prefab.crossingElements[i].roadShapeMatchCount == roadShapeMatchCount)
			{
				newIndex = i;
				break;
			}
		}
		if (newIndex != -1)
		{
			return;
		}
		for (int j = 0; j < index; j++)
		{
			if (prefab.crossingElements[j].roadShapeMatchCount == roadShapeMatchCount)
			{
				newIndex = j;
				break;
			}
		}
	}
}
[AddComponentMenu("")]
public class OQCDCDQCCD : MonoBehaviour
{
	public static void OQQODODQCQ(ERCrossingPrefabs scr, Vector3[] meshVecs, ref Vector3[] surfaceMeshVecs)
	{
		scr.surfaceSurroundingInts.Clear();
		List<int> list = new List<int>();
		List<Vector3> list2 = new List<Vector3>();
		List<Vector2> list3 = new List<Vector2>();
		List<Vector3> list4 = new List<Vector3>();
		List<int> list5 = new List<int>();
		list2.Add(Vector3.zero);
		list3.Add(new Vector2(0f, 1f));
		if (scr.baseScript == null)
		{
			if (scr.transform.parent == null || scr.transform.parent.parent == null)
			{
				return;
			}
			if ((bool)scr.transform.parent.parent.gameObject.GetComponent<ERModularBase>())
			{
				scr.baseScript = scr.transform.parent.parent.gameObject.GetComponent<ERModularBase>();
			}
			else if (scr.baseScript == null)
			{
				scr.baseScript = scr.transform.parent.parent.parent.gameObject.GetComponent<ERModularBase>();
			}
		}
		for (int i = 0; i < scr.roundaboutScript.connections.Count; i++)
		{
			if (i == 0)
			{
				scr.crossingElements[scr.roundaboutScript.connections.Count - 1].leftIndent = list2.Count;
				scr.crossingElements[scr.roundaboutScript.connections.Count - 1].leftIndentV3 = scr.roundaboutScript.connections[scr.roundaboutScript.connections.Count - 1].leftIndentvecs[0];
				list2.AddRange(scr.roundaboutScript.connections[scr.roundaboutScript.connections.Count - 1].leftIndentvecs);
				for (int j = 0; j < scr.roundaboutScript.connections[scr.roundaboutScript.connections.Count - 1].leftIndentvecs.Count; j++)
				{
					list3.Add(new Vector2(0f, 1f));
				}
			}
			else
			{
				scr.crossingElements[i - 1].leftIndent = list2.Count;
				scr.crossingElements[i - 1].leftIndentV3 = scr.roundaboutScript.connections[i - 1].leftIndentvecs[0];
				list2.AddRange(scr.roundaboutScript.connections[i - 1].leftIndentvecs);
				for (int k = 0; k < scr.roundaboutScript.connections[i - 1].leftIndentvecs.Count; k++)
				{
					list3.Add(new Vector2(0f, 1f));
				}
			}
			list4.Clear();
			list4.AddRange(scr.roundaboutScript.connections[i].rightIndentvecs);
			list4.Reverse();
			list2.AddRange(list4);
			for (int l = 0; l < list4.Count; l++)
			{
				list3.Add(new Vector2(0f, 1f));
			}
			scr.crossingElements[i].rightIndent = list2.Count - 1;
			scr.crossingElements[i].rightIndentV3 = list2[list2.Count - 1];
		}
		for (int m = 1; m < list2.Count - 1; m++)
		{
			list.Add(0);
			list.Add(m);
			list.Add(m + 1);
		}
		list.Add(0);
		list.Add(list2.Count - 1);
		list.Add(1);
		int num = 1;
		int num2 = 0;
		for (int n = 0; n < scr.roundaboutScript.connections.Count; n++)
		{
			num2 = list2.Count;
			if (n == 0)
			{
				scr.crossingElements[scr.roundaboutScript.connections.Count - 1].leftSurrounding = list2.Count;
				scr.crossingElements[scr.roundaboutScript.connections.Count - 1].leftSurroundingV3 = scr.roundaboutScript.connections[scr.roundaboutScript.connections.Count - 1].leftSurroundingvecs[0];
				list2.AddRange(scr.roundaboutScript.connections[scr.roundaboutScript.connections.Count - 1].leftSurroundingvecs);
				for (int num3 = 0; num3 < scr.roundaboutScript.connections[scr.roundaboutScript.connections.Count - 1].leftSurroundingvecs.Count; num3++)
				{
					list3.Add(new Vector2(0f, 0f));
				}
			}
			else
			{
				scr.crossingElements[n - 1].leftSurrounding = list2.Count;
				scr.crossingElements[n - 1].leftSurroundingV3 = scr.roundaboutScript.connections[n - 1].leftSurroundingvecs[0];
				list2.AddRange(scr.roundaboutScript.connections[n - 1].leftSurroundingvecs);
				for (int num4 = 0; num4 < scr.roundaboutScript.connections[n - 1].leftSurroundingvecs.Count; num4++)
				{
					list3.Add(new Vector2(0f, 0f));
				}
			}
			list4.Clear();
			list4.AddRange(scr.roundaboutScript.connections[n].rightSurroundingvecs);
			list4.Reverse();
			list2.AddRange(list4);
			for (int num5 = 0; num5 < list4.Count; num5++)
			{
				list3.Add(new Vector2(0f, 0f));
			}
			scr.crossingElements[n].rightSurrounding = list2.Count - 1;
			scr.crossingElements[n].rightSurroundingV3 = list2[list2.Count - 1];
			int num6 = list2.Count - num2;
			for (int num7 = 0; num7 < num6; num7++)
			{
				scr.surfaceSurroundingInts.Add(num2 + num7);
			}
			for (int num8 = 0; num8 < num6 - 1; num8++)
			{
				list.Add(num + num8);
				list.Add(num2 + num8);
				list.Add(num + num8 + 1);
				list.Add(num + num8 + 1);
				list.Add(num2 + num8);
				list.Add(num2 + num8 + 1);
			}
			num += num6;
		}
		scr.surfaceMeshVecs = list2.ToArray();
		if (scr.surfaceObject == null)
		{
			if ((bool)scr.transform.Find("surface"))
			{
				scr.surfaceObject = scr.transform.Find("surface").gameObject;
				scr.surfaceObject.hideFlags = HideFlags.HideInHierarchy;
			}
			else
			{
				scr.surfaceObject = new GameObject("surface");
				scr.surfaceObject.hideFlags = HideFlags.HideInHierarchy;
				scr.surfaceObject.transform.position = scr.transform.position;
				scr.surfaceObject.transform.rotation = scr.transform.rotation;
				scr.surfaceObject.transform.parent = scr.transform;
				if (scr.baseScript != null)
				{
					scr.surfaceObject.layer = scr.baseScript.sLayer;
				}
				scr.surfaceObject.AddComponent<ERSurfaceScript>();
			}
		}
		if (scr.surfaceObject.GetComponent<MeshFilter>() == null)
		{
			scr.surfaceObject.AddComponent<MeshFilter>();
		}
		if (scr.surfaceObject.GetComponent<MeshRenderer>() == null)
		{
			scr.surfaceObject.AddComponent<MeshRenderer>();
			scr.surfaceObject.GetComponent<MeshRenderer>().sharedMaterial = Resources.Load("Materials/surfaceMaterial") as Material;
		}
		if (scr.surfaceObject.GetComponent<MeshCollider>() == null)
		{
			scr.surfaceObject.AddComponent<MeshCollider>();
		}
		if (scr.surfaceObject.GetComponent<ERSurfaceScript>() == null)
		{
			scr.surfaceObject.AddComponent<ERSurfaceScript>();
		}
		Mesh mesh;
		if (scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh != null)
		{
			mesh = scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh;
		}
		else
		{
			mesh = new Mesh();
			mesh.name = "surface";
			scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh = mesh;
		}
		if (scr.baseScript != null)
		{
			scr.surfaceObject.layer = scr.baseScript.sLayer;
		}
		mesh.Clear();
		if (scr.roundaboutScript.connections.Count != 0)
		{
			mesh.vertices = scr.surfaceMeshVecs;
			mesh.uv = list3.ToArray();
			mesh.tangents = new Vector4[scr.surfaceMeshVecs.Length];
			mesh.triangles = list.ToArray();
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			scr.surfaceObject.GetComponent<MeshCollider>().sharedMesh = null;
			scr.surfaceObject.GetComponent<MeshCollider>().sharedMesh = mesh;
			if (scr.baseScript != null && scr.baseScript.hideSurfaces)
			{
				scr.surfaceObject.GetComponent<MeshRenderer>().enabled = false;
				scr.surfaceObject.GetComponent<MeshCollider>().enabled = false;
				scr.surfaceObject.SetActive(value: false);
				scr.surfaceObject.SetActive(value: true);
			}
			scr.tmpSurfaceMeshVecs = new Vector3[scr.surfaceMeshVecs.Length];
			Array.Copy(scr.surfaceMeshVecs, scr.tmpSurfaceMeshVecs, scr.surfaceMeshVecs.Length);
		}
	}

	public static void UpdateYCrossingSurfaces(ERCrossingPrefabs scr, Vector3[] meshVecs, List<ERConnectionSibling> siblings, ref Vector3[] surfaceMeshVecs)
	{
		scr.surfaceSurroundingInts.Clear();
		List<int> list = new List<int>();
		List<Vector3> list2 = new List<Vector3>();
		List<Vector2> list3 = new List<Vector2>();
		List<Vector3> list4 = new List<Vector3>();
		List<int> list5 = new List<int>();
		list2.Add(Vector3.zero);
		list3.Add(new Vector2(0f, 1f));
		for (int i = 0; i < siblings.Count; i++)
		{
			if (siblings[i].roadType == null)
			{
				siblings.RemoveAt(i);
				i--;
			}
		}
		for (int j = 0; j < siblings.Count; j++)
		{
			if (j == 0)
			{
				siblings[siblings.Count - 1].leftIndent = list2.Count;
				siblings[siblings.Count - 1].leftIndentV3 = siblings[siblings.Count - 1].leftIndentvecs[0];
				list2.AddRange(siblings[siblings.Count - 1].leftIndentvecs);
				for (int k = 0; k < siblings[siblings.Count - 1].leftIndentvecs.Count; k++)
				{
					list3.Add(new Vector2(0f, 1f));
				}
			}
			else
			{
				siblings[j - 1].leftIndent = list2.Count;
				siblings[j - 1].leftIndentV3 = siblings[j - 1].leftIndentvecs[0];
				list2.AddRange(siblings[j - 1].leftIndentvecs);
				for (int l = 0; l < siblings[j - 1].leftIndentvecs.Count; l++)
				{
					list3.Add(new Vector2(0f, 1f));
				}
			}
			list4.Clear();
			list4.AddRange(siblings[j].rightIndentvecs);
			list4.Reverse();
			list2.AddRange(list4);
			for (int m = 0; m < list4.Count; m++)
			{
				list3.Add(new Vector2(0f, 1f));
			}
			siblings[j].rightIndent = list2.Count - 1;
			siblings[j].rightIndentV3 = list2[list2.Count - 1];
		}
		for (int n = 1; n < list2.Count - 1; n++)
		{
			list.Add(0);
			list.Add(n);
			list.Add(n + 1);
		}
		list.Add(0);
		list.Add(list2.Count - 1);
		list.Add(1);
		int num = 1;
		int num2 = 0;
		for (int num3 = 0; num3 < siblings.Count; num3++)
		{
			num2 = list2.Count;
			if (num3 == 0)
			{
				siblings[siblings.Count - 1].leftSurrounding = list2.Count;
				siblings[siblings.Count - 1].leftSurroundingV3 = siblings[siblings.Count - 1].leftSurroundingvecs[0];
				list2.AddRange(siblings[siblings.Count - 1].leftSurroundingvecs);
				for (int num4 = 0; num4 < siblings[siblings.Count - 1].leftSurroundingvecs.Count; num4++)
				{
					list3.Add(new Vector2(0f, 0f));
				}
			}
			else
			{
				siblings[num3 - 1].leftSurrounding = list2.Count;
				siblings[num3 - 1].leftSurroundingV3 = siblings[num3 - 1].leftSurroundingvecs[0];
				list2.AddRange(siblings[num3 - 1].leftSurroundingvecs);
				for (int num5 = 0; num5 < siblings[num3 - 1].leftSurroundingvecs.Count; num5++)
				{
					list3.Add(new Vector2(0f, 0f));
				}
			}
			list4.Clear();
			list4.AddRange(siblings[num3].rightSurroundingvecs);
			list4.Reverse();
			list2.AddRange(list4);
			for (int num6 = 0; num6 < list4.Count; num6++)
			{
				list3.Add(new Vector2(0f, 0f));
			}
			siblings[num3].rightSurrounding = list2.Count - 1;
			siblings[num3].rightSurroundingV3 = list2[list2.Count - 1];
			int num7 = list2.Count - num2;
			for (int num8 = 0; num8 < num7; num8++)
			{
				scr.surfaceSurroundingInts.Add(num2 + num8);
			}
			for (int num9 = 0; num9 < num7 - 1; num9++)
			{
				list.Add(num + num9);
				list.Add(num2 + num9);
				list.Add(num + num9 + 1);
				list.Add(num + num9 + 1);
				list.Add(num2 + num9);
				list.Add(num2 + num9 + 1);
			}
			num += num7;
		}
		scr.surfaceMeshVecs = list2.ToArray();
		if (scr.surfaceObject == null)
		{
			if ((bool)scr.transform.Find("surface"))
			{
				scr.surfaceObject = scr.transform.Find("surface").gameObject;
				scr.surfaceObject.hideFlags = HideFlags.HideInHierarchy;
			}
			else
			{
				scr.surfaceObject = new GameObject("surface");
				scr.surfaceObject.hideFlags = HideFlags.HideInHierarchy;
				scr.surfaceObject.transform.position = scr.transform.position;
				scr.surfaceObject.transform.rotation = scr.transform.rotation;
				scr.surfaceObject.transform.parent = scr.transform;
				scr.surfaceObject.layer = scr.baseScript.sLayer;
				scr.surfaceObject.AddComponent<ERSurfaceScript>();
			}
		}
		if (scr.surfaceObject.GetComponent<MeshFilter>() == null)
		{
			scr.surfaceObject.AddComponent<MeshFilter>();
		}
		if (scr.surfaceObject.GetComponent<MeshRenderer>() == null)
		{
			scr.surfaceObject.AddComponent<MeshRenderer>();
			scr.surfaceObject.GetComponent<MeshRenderer>().sharedMaterial = Resources.Load("Materials/surfaceMaterial") as Material;
		}
		if (scr.surfaceObject.GetComponent<MeshCollider>() == null)
		{
			scr.surfaceObject.AddComponent<MeshCollider>();
		}
		if (scr.surfaceObject.GetComponent<ERSurfaceScript>() == null)
		{
			scr.surfaceObject.AddComponent<ERSurfaceScript>();
		}
		Mesh mesh;
		if (scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh != null)
		{
			mesh = scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh;
		}
		else
		{
			mesh = new Mesh();
			mesh.name = "surface";
			scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh = mesh;
		}
		scr.surfaceObject.layer = scr.baseScript.sLayer;
		mesh.Clear();
		if (siblings.Count != 0)
		{
			mesh.vertices = scr.surfaceMeshVecs;
			mesh.uv = list3.ToArray();
			mesh.tangents = new Vector4[scr.surfaceMeshVecs.Length];
			mesh.triangles = list.ToArray();
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			scr.surfaceObject.GetComponent<MeshCollider>().sharedMesh = null;
			scr.surfaceObject.GetComponent<MeshCollider>().sharedMesh = mesh;
			if (scr.baseScript != null && scr.baseScript.hideSurfaces)
			{
				scr.surfaceObject.GetComponent<MeshRenderer>().enabled = false;
				scr.surfaceObject.GetComponent<MeshCollider>().enabled = false;
				scr.surfaceObject.SetActive(value: false);
				scr.surfaceObject.SetActive(value: true);
			}
			scr.tmpSurfaceMeshVecs = new Vector3[scr.surfaceMeshVecs.Length];
			Array.Copy(scr.surfaceMeshVecs, scr.tmpSurfaceMeshVecs, scr.surfaceMeshVecs.Length);
		}
	}
}
[AddComponentMenu("")]
public class OOODCDOCOC : MonoBehaviour
{
	public static void OCCCOOOCDO(ERCrossingPrefabs scr, ERModularBase baseScript)
	{
		List<Vector2> list = new List<Vector2>();
		List<Vector3> list2 = new List<Vector3>();
		List<Vector3> baseVecs = new List<Vector3>();
		List<Vector3> indentVecs = new List<Vector3>();
		List<Vector2> uvs = new List<Vector2>();
		List<bool> doSurroundingTriangle = new List<bool>();
		List<PointER> list3 = new List<PointER>();
		List<float> list4 = new List<float>();
		List<float> list5 = new List<float>();
		int num = 0;
		if (scr.indent == 0f || scr.indent < baseScript.terrainMinIndent)
		{
			scr.indent = baseScript.terrainMinIndent;
		}
		if (scr.surrounding == 0f || scr.indent < baseScript.minSurrounding)
		{
			scr.surrounding = baseScript.minSurrounding;
		}
		for (int i = 0; i < list2.Count; i++)
		{
			uvs.Add(new Vector2(0f, 1f));
		}
		float indent = scr.indent;
		float surrounding = scr.surrounding;
		indentVecs.Clear();
		scr.debugVecs1.Clear();
		scr.debugVecs2.Clear();
		bool lastIndentIsRight = false;
		OQCDCQOQDC(ref indentVecs, ref baseVecs, ref uvs, ref doSurroundingTriangle, scr.surfaceVecs, scr.surfaceVecType, indent, surrounding, scr, ref lastIndentIsRight);
		scr.indentVecs = new List<Vector3>(indentVecs);
		scr.debugVecs1.AddRange(indentVecs);
		for (int j = 0; j < indentVecs.Count; j++)
		{
			Vector3 item = indentVecs[j];
			list2.Add(item);
			list3.Add(new PointER(item.x, item.z, 0f));
			list4.Add(item.x);
			list5.Add(item.z);
			list.Add(new Vector2(item.x, item.z));
		}
		List<int> list6 = new List<int>();
		List<int> list7 = new List<int>();
		List<TriangleER> list8 = delaunayER.Triangulate(list3);
		for (int k = 0; k < list8.Count; k++)
		{
			list6.Add(num + delaunayER.FindVertice(new Vector3(list8[k].Vertex1.x, list8[k].Vertex1.z, list8[k].Vertex1.y), list2));
			list6.Add(num + delaunayER.FindVertice(new Vector3(list8[k].Vertex3.x, list8[k].Vertex3.z, list8[k].Vertex3.y), list2));
			list6.Add(num + delaunayER.FindVertice(new Vector3(list8[k].Vertex2.x, list8[k].Vertex2.z, list8[k].Vertex2.y), list2));
		}
		for (int l = 0; l < list6.Count; l += 3)
		{
			Vector3 vector = (list2[list6[l] - num] + list2[list6[l + 1] - num] + list2[list6[l + 2] - num]) / 3f;
			if (ODDCQDDCDD.OCCQDQQDCC(list4.Count, list, vector.x, vector.z))
			{
				list7.Add(list6[l]);
				list7.Add(list6[l + 1]);
				list7.Add(list6[l + 2]);
			}
		}
		scr.surfaceSurroundingInts.Clear();
		num = list2.Count;
		bool flag = true;
		float num2 = 0f;
		bool flag2 = false;
		for (int m = 0; m < num; m++)
		{
			num2 = scr.surrounding;
			flag2 = false;
			if (!doSurroundingTriangle[m])
			{
				flag2 = true;
			}
			if (m == 0)
			{
				if (!doSurroundingTriangle[num - 1])
				{
					flag2 = true;
				}
			}
			else if (!doSurroundingTriangle[m - 1])
			{
				flag2 = true;
			}
			if (flag2)
			{
				num2 = Mathf.Sqrt(num2 * num2 + num2 * num2);
			}
			Vector3 normalized = (list2[m] - baseVecs[m]).normalized;
			Vector3 item = list2[m] + normalized * num2;
			if (m > 0 && !ODQDQDQDQO.OQCDCDOOCD(list2[list2.Count - 1], list2[list2.Count - 1 - num], item))
			{
				item = list2[list2.Count - 1];
			}
			list2.Add(item);
			uvs.Add(new Vector2(0f, 0f));
			scr.surfaceSurroundingInts.Add(num + m);
			if (doSurroundingTriangle[m] && m < num - 1)
			{
				list7.Add(m);
				list7.Add(m + num);
				list7.Add(m + 1);
				list7.Add(m + num);
				list7.Add(m + num + 1);
				list7.Add(m + 1);
			}
			else if (m == num - 1 && !lastIndentIsRight)
			{
				list7.Add(m);
				list7.Add(m + num);
				list7.Add(0);
				list7.Add(m + num);
				list7.Add(num);
				list7.Add(0);
			}
		}
		for (int n = 0; n < scr.crossingElements.Count; n++)
		{
			int leftIndent = scr.crossingElements[n].leftIndent;
			scr.crossingElements[n].leftSurrounding = leftIndent + num;
			scr.crossingElements[n].leftSurroundingV3 = list2[leftIndent + num];
			leftIndent = scr.crossingElements[n].rightIndent;
			scr.crossingElements[n].rightSurrounding = leftIndent + num;
			scr.crossingElements[n].rightSurroundingV3 = list2[leftIndent + num];
		}
		if (scr.surfaceObject == null)
		{
			if ((bool)scr.transform.Find("surface"))
			{
				scr.surfaceObject = scr.transform.Find("surface").gameObject;
				scr.surfaceObject.hideFlags = HideFlags.HideInHierarchy;
			}
			else
			{
				scr.surfaceObject = new GameObject("surface");
				scr.surfaceObject.hideFlags = HideFlags.HideInHierarchy;
				scr.surfaceObject.transform.position = scr.transform.position;
				scr.surfaceObject.transform.rotation = scr.transform.rotation;
				scr.surfaceObject.transform.parent = scr.transform;
				scr.surfaceObject.layer = baseScript.sLayer;
				scr.surfaceObject.AddComponent<ERSurfaceScript>();
			}
		}
		if (scr.surfaceObject.GetComponent<MeshFilter>() == null)
		{
			scr.surfaceObject.AddComponent<MeshFilter>();
		}
		if (scr.surfaceObject.GetComponent<MeshRenderer>() == null)
		{
			scr.surfaceObject.AddComponent<MeshRenderer>();
			scr.surfaceObject.GetComponent<MeshRenderer>().sharedMaterial = Resources.Load("Materials/surfaceMaterial") as Material;
		}
		if (scr.surfaceObject.GetComponent<MeshCollider>() == null)
		{
			scr.surfaceObject.AddComponent<MeshCollider>();
		}
		Mesh mesh;
		if (scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh != null)
		{
			mesh = scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh;
		}
		else
		{
			mesh = new Mesh();
			mesh.name = "surface";
			scr.surfaceObject.GetComponent<MeshFilter>().sharedMesh = mesh;
		}
		if (list2.Count != uvs.Count)
		{
			uvs.Clear();
			for (int num3 = 0; num3 < list2.Count; num3++)
			{
				uvs.Add(new Vector2(0f, 1f));
			}
		}
		scr.surfaceObject.layer = baseScript.sLayer;
		mesh.Clear();
		mesh.vertices = list2.ToArray();
		mesh.uv = uvs.ToArray();
		mesh.tangents = new Vector4[list2.Count];
		mesh.triangles = list7.ToArray();
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();
		scr.surfaceObject.GetComponent<MeshCollider>().sharedMesh = null;
		scr.surfaceObject.GetComponent<MeshCollider>().sharedMesh = mesh;
		if (baseScript.hideSurfaces)
		{
			scr.surfaceObject.GetComponent<MeshRenderer>().enabled = false;
			scr.surfaceObject.GetComponent<MeshCollider>().enabled = false;
		}
		scr.surfaceMeshVecs = list2.ToArray();
		scr.tmpSurfaceMeshVecs = new Vector3[scr.surfaceMeshVecs.Length];
		Array.Copy(scr.surfaceMeshVecs, scr.tmpSurfaceMeshVecs, scr.surfaceMeshVecs.Length);
	}

	public static void OQCDCQOQDC(ref List<Vector3> indentVecs, ref List<Vector3> baseVecs, ref List<Vector2> uvs, ref List<bool> doSurroundingTriangle, List<Vector3> vecs, List<int> surfaceVecType, float indent, float surrounding, ERCrossingPrefabs scr, ref bool lastIndentIsRight)
	{
		Vector3 localScale = scr.transform.localScale;
		Vector3 rightVec;
		Vector3 indentVec;
		Vector3 vector2;
		Vector3 vector = (vector2 = (rightVec = (indentVec = Vector3.zero)));
		bool flag = true;
		bool flag2 = true;
		bool flag3 = true;
		bool flag4 = false;
		int num = 0;
		Vector3 a = Vector3.zero;
		Vector3 vector4;
		Vector3 vector3 = (vector4 = Vector3.zero);
		indent += scr.extraIndentMargin;
		if (localScale != new Vector3(1f, 1f, 1f))
		{
			for (int i = 0; i < vecs.Count; i++)
			{
				vecs[i] = new Vector3(localScale.x * vecs[i].x, localScale.y * vecs[i].y, localScale.z * vecs[i].z);
			}
			foreach (QDOODOQQDQODD crossingElement in scr.crossingElements)
			{
				crossingElement.rightSurroundingV3 = new Vector3(crossingElement.rightSurroundingV3.x / localScale.x, crossingElement.rightSurroundingV3.y / localScale.y, crossingElement.rightSurroundingV3.z / localScale.z);
				crossingElement.leftSurroundingV3 = new Vector3(crossingElement.leftSurroundingV3.x / localScale.x, crossingElement.leftSurroundingV3.y / localScale.y, crossingElement.leftSurroundingV3.z / localScale.z);
				crossingElement.rightIndentV3 = new Vector3(crossingElement.rightIndentV3.x / localScale.x, crossingElement.rightIndentV3.y / localScale.y, crossingElement.rightIndentV3.z / localScale.z);
				crossingElement.leftIndentV3 = new Vector3(crossingElement.leftIndentV3.x / localScale.x, crossingElement.leftIndentV3.y / localScale.y, crossingElement.leftIndentV3.z / localScale.z);
			}
		}
		for (int j = 0; j < vecs.Count; j++)
		{
			flag3 = true;
			Vector3 nextVec;
			Vector3 vector6;
			Vector3 vector5;
			if (j == 0)
			{
				vector5 = (vecs[1] - vecs[vecs.Count - 1]).normalized;
				nextVec = vecs[1];
				vector6 = vecs[vecs.Count - 1];
			}
			else if (j == vecs.Count - 1)
			{
				vector5 = (vecs[0] - vecs[vecs.Count - 2]).normalized;
				nextVec = vecs[0];
				vector6 = vecs[j - 1];
			}
			else
			{
				float num2 = Vector3.Distance(vecs[j], vecs[j + 1]);
				vector5 = ((surfaceVecType[j + 1] != 0 && !(num2 > 2f * indent)) ? (vecs[j] - vecs[j - 1]).normalized : (vecs[j + 1] - vecs[j - 1]).normalized);
				nextVec = vecs[j + 1];
				vector6 = vecs[j - 1];
			}
			if (surfaceVecType[j] == 1)
			{
				flag4 = false;
				vector5 = ((j <= 0) ? (vecs[j] - vecs[vecs.Count - 1]).normalized : (vecs[j] - vecs[j - 1]).normalized);
				Vector3 leftVec = (vector = vecs[j]);
				vector2 = leftVec + vector5 * indent;
				Vector3 vector7 = new Vector3(0f - vector5.z, 0f, vector5.x);
				vector2 += vector7 * indent;
				ODCCDDODCD(ref vector2, ref vector5, vecs[j], vector6, nextVec, indent, 0);
				Vector3 normalized = (vector2 - vecs[j]).normalized;
				Vector3 vector8 = leftVec + normalized * (indent + surrounding);
				num = j;
				if (scr.crossingElements[scr.surfaceConnectionInt[num]].inwards)
				{
					vector2 = vecs[j];
					flag = true;
				}
				else
				{
					flag = OCQODQCOOC(vecs[j], ref indentVec, ref rightVec, ref vector2, ref leftVec, ref j, vecs, surfaceVecType, indent, vector5, vector2);
				}
				vector7 = vector5;
				vector3 = vector2;
				scr.crossingElements[scr.surfaceConnectionInt[num]].leftIndentV3 = vector3;
				scr.crossingElements[scr.surfaceConnectionInt[num]].leftIndent = indentVecs.Count;
				scr.crossingElements[scr.surfaceConnectionInt[num]].leftSurroundingV3 = vector3;
				scr.crossingElements[scr.surfaceConnectionInt[num]].leftSurrounding = indentVecs.Count;
				vector4 = leftVec;
				if (!flag)
				{
					flag3 = false;
				}
			}
			else if (surfaceVecType[j] == 2)
			{
				vector5 = ((j >= vecs.Count - 1) ? (vecs[j] - vecs[0]).normalized : (vecs[j] - vecs[j + 1]).normalized);
				flag4 = true;
				Vector3 vector7;
				if (indentVec == Vector3.zero)
				{
					rightVec = vecs[j];
					indentVec = rightVec + vector5 * indent;
					vector7 = new Vector3(vector5.z, 0f, 0f - vector5.x);
					indentVec += vector7 * indent;
				}
				ODCCDDODCD(ref indentVec, ref vector5, vecs[j], vector6, nextVec, indent, 1);
				vector4 = rightVec;
				vector7 = vector5;
				vector3 = indentVec;
				ODDDDQDDQC(ref indentVecs, ref baseVecs, ref doSurroundingTriangle, indentVec, vector4);
				try
				{
					scr.crossingElements[scr.surfaceConnectionInt[j]].rightIndentV3 = vector3;
					scr.crossingElements[scr.surfaceConnectionInt[j]].rightIndent = indentVecs.Count;
					scr.crossingElements[scr.surfaceConnectionInt[j]].rightSurroundingV3 = vector3;
					scr.crossingElements[scr.surfaceConnectionInt[j]].rightSurrounding = indentVecs.Count;
				}
				catch
				{
					UnityEngine.Debug.Log(j + " ERROR setting surface surrounding elements: " + scr.surfaceConnectionInt[j] + " " + scr.crossingElements.Count);
				}
				flag3 = false;
			}
			else
			{
				flag4 = false;
				if (Vector3.Distance(a, vecs[j]) < 1f)
				{
					flag2 = false;
				}
				if (flag2)
				{
					Vector3 vector7 = new Vector3(0f - vector5.z, 0f, vector5.x);
					Vector3 normalized2 = (vecs[j] - vector6).normalized;
					float num3 = indent;
					normalized2 = new Vector3(0f - normalized2.z, 0f, normalized2.x);
					float num4 = Vector3.Angle(vector7, normalized2);
					if (num4 > 50f)
					{
						vector7 = Vector3.Lerp(vector7, normalized2, 0.4f).normalized;
						num4 = Vector3.Angle(vector7, normalized2);
					}
					num3 = indent / Mathf.Cos(Vector3.Angle(vector7, normalized2) * ((float)Math.PI / 180f));
					if (num3 > 2f * indent)
					{
						num3 = 2f * indent;
					}
					vector3 = vecs[j] + vector7 * num3;
					vector4 = vecs[j];
					try
					{
						if (indentVecs.Count > 0 && !ODQDQDQDQO.OQCDCDOOCD(indentVecs[indentVecs.Count - 1], baseVecs[indentVecs.Count - 1], vector3))
						{
							flag2 = false;
						}
					}
					catch
					{
						UnityEngine.Debug.Log(baseVecs.Count + " " + (indentVecs.Count - 1));
					}
					if (indentVecs.Count > 0)
					{
						vector5 = (vector3 - indentVecs[indentVecs.Count - 1]).normalized;
						Vector3 vB = indentVecs[indentVecs.Count - 1] + vector5 * 100f;
						Vector3 vector9 = ODQDQDQDQO.OQQCQOCCOQ(indentVecs[indentVecs.Count - 1], vB, vecs[j]);
						if (Vector3.Distance(vecs[j], vector9) < indent * 0.8f)
						{
							vector5 = (vector9 - vecs[j]).normalized;
							vector3 = vecs[j] + vector5 * indent;
						}
						else if (Vector3.Distance(indentVecs[indentVecs.Count - 1], vector3) < 0.2f * indent)
						{
							vector5 = (vector3 - indentVecs[indentVecs.Count - 1]).normalized;
							vector3 = indentVecs[indentVecs.Count - 1] + vector5 * (0.2f * indent);
						}
					}
				}
			}
			if (flag2)
			{
				indentVecs.Add(vector3);
				baseVecs.Add(vector4);
				doSurroundingTriangle.Add(flag3);
				a = vecs[j];
				uvs.Add(new Vector2(0f, 1f));
				lastIndentIsRight = flag4;
			}
			flag2 = true;
		}
	}

	public static void ODCCDDODCD(ref Vector3 indentVec, ref Vector3 dir, Vector3 vec, Vector3 prefVec, Vector3 nextVec, float indent, int leftOrRight)
	{
		if (leftOrRight == 0)
		{
			if (Vector3.Distance(nextVec, indentVec) >= indent)
			{
				return;
			}
		}
		else if (Vector3.Distance(prefVec, indentVec) >= indent)
		{
			return;
		}
		bool flag = false;
		if (leftOrRight == 0)
		{
			if (!ODQDQDQDQO.OQCDCDOOCD(indentVec, vec, nextVec))
			{
				flag = true;
			}
		}
		else if (ODQDQDQDQO.OQCDCDOOCD(indentVec, vec, prefVec))
		{
			flag = true;
		}
		Vector3 vector = vec + dir * 1000f;
		Vector3 vector2 = ((leftOrRight != 0) ? ODQDQDQDQO.OQQCQOCCOQ(vector, nextVec, prefVec) : ODQDQDQDQO.OQQCQOCCOQ(prefVec, vector, nextVec));
		float num = indent;
		float num2 = Vector3.Distance(vec, vector2);
		if (!flag)
		{
			float num3 = ((leftOrRight != 0) ? Vector3.Distance(prefVec, vector2) : Vector3.Distance(nextVec, vector2));
			num = ((!(num2 < num3)) ? (indent - num3) : (indent - num2));
		}
		if (Vector3.Distance(vec, indentVec) > num2)
		{
			float num4 = num / Mathf.Cos((float)Math.PI / 4f);
			Vector3 vector3 = ((leftOrRight != 0) ? new Vector3(dir.z, 0f, 0f - dir.x).normalized : new Vector3(0f - dir.z, 0f, dir.x).normalized);
			vector = vector2 + vector3 * 5f;
			dir = ((vector3 + dir) * 0.5f).normalized;
			Vector3 vector4;
			Vector3 normalized;
			if (flag)
			{
				vector4 = nextVec + dir * num;
				normalized = (vector4 - nextVec).normalized;
			}
			else
			{
				vector4 = vector2 + dir * num;
				normalized = (vector4 - vector2).normalized;
			}
			Vector3 vector5 = ((leftOrRight != 0) ? new Vector3(0f - normalized.z, 0f, normalized.x).normalized : new Vector3(normalized.z, 0f, 0f - normalized.x).normalized);
			Vector3 p = indentVec + vector3 * 5f;
			Vector3 p2 = vector4 + vector5 * 5f;
			vector2 = ODQDQDQDQO.OODOQDOODO(indentVec, p, vector4, p2, flag: false);
			indentVec = vector2;
		}
		else
		{
			Vector3 vector6 = ((leftOrRight != 0) ? new Vector3(dir.z, 0f, 0f - dir.x).normalized : new Vector3(0f - dir.z, 0f, dir.x).normalized);
			indentVec += vector6 * num;
		}
	}

	public static bool OCQODQCOOC(Vector3 vec, ref Vector3 rightIndentVec, ref Vector3 rightVec, ref Vector3 leftIndentVec, ref Vector3 leftVec, ref int startInt, List<Vector3> vecs, List<int> surfaceVecType, float indent, Vector3 leftIndentDir, Vector3 checkVec)
	{
		Vector3 vector = Vector3.zero;
		int num = 0;
		for (int i = startInt; i < vecs.Count; i++)
		{
			if (surfaceVecType[i] == 2)
			{
				rightVec = vecs[i];
				vector = ((i >= vecs.Count - 1) ? vecs[0] : vecs[i + 1]);
				num = i;
				break;
			}
		}
		if (startInt > 0 && num == 0)
		{
			for (int j = 0; j < startInt; j++)
			{
				if (surfaceVecType[j] == 2)
				{
					rightVec = vecs[j];
					vector = ((j >= vecs.Count - 1) ? vecs[0] : vecs[j + 1]);
					num = j;
					break;
				}
			}
		}
		Vector3 normalized = (rightVec - vector).normalized;
		rightIndentVec = rightVec + normalized * indent;
		Vector3 vector2 = new Vector3(normalized.z, 0f, 0f - normalized.x);
		rightIndentVec += vector2 * indent;
		if (Mathf.Abs(leftIndentDir.x) != Mathf.Abs(normalized.x) || Mathf.Abs(leftIndentDir.z) != Mathf.Abs(normalized.z))
		{
			if (ODQDQDQDQO.OQCDCDOOCD(rightIndentVec, rightVec, checkVec) && !ODQDQDQDQO.OQCDCDOOCD(leftIndentVec, vec, rightIndentVec))
			{
				Vector3 vector3 = ODQDQDQDQO.OODOQDOODO(rightVec, rightIndentVec, leftVec, leftIndentVec, flag: false);
				leftVec = (rightVec = vector3);
				float num2 = Vector3.Distance(vector3, leftVec);
				if (num2 < indent)
				{
					Vector3 vector4 = Vector3.Lerp(leftIndentDir, normalized, 0.5f);
					float num3 = Vector3.Angle(new Vector3(0f - leftIndentDir.z, 0f, leftIndentDir.x), vector4);
					float num4 = (indent - num2) / Mathf.Sin(num3 * ((float)Math.PI / 180f));
					leftIndentVec = vector3 + vector4 * num4;
					rightIndentVec = leftIndentVec;
					if (num > startInt)
					{
						startInt = num - 1;
					}
					else
					{
						startInt = vecs.Count - 1;
					}
					return false;
				}
				return true;
			}
			return true;
		}
		return true;
	}

	public static float ERGetInterpolationDistance(Vector3 pos, Vector3 dir, Vector3 vec)
	{
		Vector3 vA = pos + dir * 100f;
		Vector3 vB = pos - dir * 100f;
		Vector3 b = ODQDQDQDQO.OQQCQOCCOQ(vA, vB, vec);
		return Vector3.Distance(vec, b);
	}

	public static Vector3 GetNextRightVec(int startInt, List<Vector3> vecs, List<int> surfaceVecType)
	{
		Vector3 result = Vector3.zero;
		int num = 0;
		for (int i = startInt; i < vecs.Count; i++)
		{
			if (surfaceVecType[i] == 2)
			{
				result = vecs[i];
				num = i;
				break;
			}
		}
		if (startInt > 0 && num == 0)
		{
			for (int j = 0; j < startInt; j++)
			{
				if (surfaceVecType[j] == 2)
				{
					result = vecs[j];
					num = j;
					break;
				}
			}
		}
		return result;
	}

	public static void ODDDDQDDQC(ref List<Vector3> indentVecs, ref List<Vector3> baseVecs, ref List<bool> doSurroundingTriangle, Vector3 rightVec, Vector3 baseVec)
	{
		bool flag = false;
		for (int num = indentVecs.Count - 1; num >= 0; num--)
		{
			Vector3 a = ODQDQDQDQO.OQQCQOCCOQ(rightVec, baseVec, indentVecs[num]);
			if (Vector3.Distance(a, baseVec) < Vector3.Distance(rightVec, baseVec))
			{
				flag = true;
				if (!ODQDQDQDQO.OQCDCDOOCD(rightVec, baseVec, indentVecs[num]))
				{
					break;
				}
				indentVecs.RemoveAt(num);
				baseVecs.RemoveAt(num);
				doSurroundingTriangle.RemoveAt(num);
			}
		}
	}
}
public struct NormalPairs
{
	public int index1;

	public int index2;
}
[AddComponentMenu("")]
public class OQOQQODODO : MonoBehaviour
{
	public static void OQQQQQODDO(ERCrossings scr, ref float firstSegmentDistance)
	{
		List<Vector3> vecs = new List<Vector3>();
		int num = 0;
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0.5f * scr.frontRoadWidth;
		if (scr.tCrossingLeftRight == 0)
		{
			float cornerRadius = scr.prefabScript.sidewalkControlElements[0].cornerRadius;
			float angle = 90f / ((float)(scr.prefabScript.sidewalkControlElements[0].cornerSegments - 1) * 1f);
			float num5 = 0.5f * scr.leftRoadWidth;
			for (int i = 0; i < scr.prefabScript.sidewalkControlElements[0].cornerSegments; i++)
			{
				Vector3 vector = OCCDQDCQCD(i, cornerRadius, angle);
				Vector3 item = new Vector3(0f - vector.x - num4, 0f, vector.z - num5 - cornerRadius);
				vecs.Add(item);
			}
			OODDQCQOQQ(ref vecs, 0f, -1f, -1f, 0f);
		}
		else
		{
			num3 = 0.5f * scr.rightRoadWidth;
			num3 += scr.prefabScript.sidewalkControlElements[1].cornerRadius;
			num = Mathf.RoundToInt(Mathf.Ceil(num3 / scr.resolution));
			num2 = num3 / ((float)num * 1f);
			for (int j = 0; j <= num; j++)
			{
				Vector3 item = new Vector3(0f - num4, 0f, 0f - num3 + (float)j * num2);
				vecs.Add(item);
			}
		}
		scr.startConnectionV3.Add(new List<Vector3>());
		scr.startConnectionV3[0].AddRange(vecs);
		vecs.Clear();
		num4 = 0.5f * scr.frontRoadWidth;
		if (scr.tCrossingLeftRight == 1)
		{
			float cornerRadius = scr.prefabScript.sidewalkControlElements[1].cornerRadius;
			float angle = 90f / ((float)(scr.prefabScript.sidewalkControlElements[1].cornerSegments - 1) * 1f);
			float num5 = 0.5f * scr.rightRoadWidth;
			for (int k = 0; k < scr.prefabScript.sidewalkControlElements[1].cornerSegments; k++)
			{
				Vector3 vector = OCCDQDCQCD(k, cornerRadius, angle);
				Vector3 item = new Vector3(vector.x + num4, 0f, vector.z - num5 - cornerRadius);
				vecs.Add(item);
			}
			OODDQCQOQQ(ref vecs, 0f, -1f, 1f, 0f);
		}
		else
		{
			num3 = 0.5f * scr.leftRoadWidth;
			num3 += scr.prefabScript.sidewalkControlElements[0].cornerRadius;
			num = Mathf.RoundToInt(Mathf.Ceil(num3 / scr.resolution));
			num2 = num3 / ((float)num * 1f);
			for (int l = 0; l <= num; l++)
			{
				Vector3 item = new Vector3(num4, 0f, 0f - num3 + (float)l * num2);
				vecs.Add(item);
			}
		}
		scr.startConnectionV3.Add(new List<Vector3>());
		scr.startConnectionV3[1].AddRange(vecs);
		vecs.Clear();
		num4 = 0.5f * scr.backRoadWidth;
		if (scr.tCrossingLeftRight == 1)
		{
			float cornerRadius = scr.prefabScript.sidewalkControlElements[3].cornerRadius;
			float angle = 90f / ((float)(scr.prefabScript.sidewalkControlElements[3].cornerSegments - 1) * 1f);
			float num5 = 0.5f * scr.rightRoadWidth;
			for (int m = 0; m < scr.prefabScript.sidewalkControlElements[3].cornerSegments; m++)
			{
				Vector3 vector = OCCDQDCQCD(m, cornerRadius, 0f - angle);
				Vector3 item = new Vector3(vector.x + num4, 0f, vector.z + num5 + cornerRadius);
				vecs.Add(item);
			}
			OODDQCQOQQ(ref vecs, 0f, 1f, 1f, 0f);
		}
		else
		{
			num3 = 0.5f * scr.leftRoadWidth;
			num3 += scr.prefabScript.sidewalkControlElements[2].cornerRadius;
			num = Mathf.RoundToInt(Mathf.Ceil(num3 / scr.resolution));
			num2 = num3 / ((float)num * 1f);
			for (int n = 0; n <= num; n++)
			{
				Vector3 item = new Vector3(num4, 0f, num3 - (float)n * num2);
				vecs.Add(item);
			}
		}
		scr.endConnectionV3.Add(new List<Vector3>());
		scr.endConnectionV3[0].AddRange(vecs);
		vecs.Clear();
		num4 = 0.5f * scr.backRoadWidth;
		if (scr.tCrossingLeftRight == 0)
		{
			float cornerRadius = scr.prefabScript.sidewalkControlElements[2].cornerRadius;
			float angle = 90f / ((float)(scr.prefabScript.sidewalkControlElements[2].cornerSegments - 1) * 1f);
			float num5 = 0.5f * scr.leftRoadWidth;
			for (int num6 = 0; num6 < scr.prefabScript.sidewalkControlElements[2].cornerSegments; num6++)
			{
				Vector3 vector = OCCDQDCQCD(num6, cornerRadius, 0f - angle);
				Vector3 item = new Vector3(0f - vector.x - num4, 0f, vector.z + num5 + cornerRadius);
				vecs.Add(item);
			}
			OODDQCQOQQ(ref vecs, 0f, 1f, -1f, 0f);
		}
		else
		{
			num3 = 0.5f * scr.rightRoadWidth;
			num3 += scr.prefabScript.sidewalkControlElements[3].cornerRadius;
			num = Mathf.RoundToInt(Mathf.Ceil(num3 / scr.resolution));
			num2 = num3 / ((float)num * 1f);
			for (int num7 = 0; num7 <= num; num7++)
			{
				Vector3 item = new Vector3(0f - num4, 0f, num3 - (float)num7 * num2);
				vecs.Add(item);
			}
		}
		scr.endConnectionV3.Add(new List<Vector3>());
		scr.endConnectionV3[1].AddRange(vecs);
		vecs.Clear();
		if (scr.tCrossingLeftRight == 0)
		{
			int num8 = Mathf.RoundToInt(Mathf.Ceil((float)scr.endConnectionV3[1].Count * 0.5f));
			vecs.Clear();
			vecs.AddRange(scr.endConnectionV3[1]);
			vecs.RemoveRange(0, num8 - 1);
			scr.leftConnectionV3.Add(new List<Vector3>());
			vecs.Reverse();
			scr.leftConnectionV3[0].AddRange(vecs);
			scr.endConnectionV3[1].RemoveRange(num8, scr.endConnectionV3[1].Count - num8);
			num8 = Mathf.RoundToInt(Mathf.Ceil((float)scr.startConnectionV3[0].Count * 0.5f));
			vecs.Clear();
			vecs.AddRange(scr.startConnectionV3[0]);
			vecs.RemoveRange(0, num8 - 1);
			scr.leftConnectionV3.Add(new List<Vector3>());
			vecs.Reverse();
			scr.leftConnectionV3[1].AddRange(vecs);
			scr.startConnectionV3[0].RemoveRange(num8, scr.startConnectionV3[0].Count - num8);
		}
		if (scr.tCrossingLeftRight == 1)
		{
			int num9 = Mathf.RoundToInt(Mathf.Ceil((float)scr.startConnectionV3[1].Count * 0.5f));
			vecs.Clear();
			vecs.AddRange(scr.startConnectionV3[1]);
			vecs.RemoveRange(0, num9 - 1);
			scr.rightConnectionV3.Add(new List<Vector3>());
			vecs.Reverse();
			scr.rightConnectionV3[0].AddRange(vecs);
			scr.startConnectionV3[1].RemoveRange(num9, scr.startConnectionV3[1].Count - num9);
			num9 = Mathf.RoundToInt(Mathf.Ceil((float)scr.endConnectionV3[0].Count * 0.5f));
			vecs.Clear();
			vecs.AddRange(scr.endConnectionV3[0]);
			vecs.RemoveRange(0, num9 - 1);
			scr.rightConnectionV3.Add(new List<Vector3>());
			vecs.Reverse();
			scr.rightConnectionV3[1].AddRange(vecs);
			scr.endConnectionV3[0].RemoveRange(num9, scr.endConnectionV3[0].Count - num9);
		}
	}

	public static void OODDQCQOQQ(ref List<Vector3> vecs, float firstX, float firstZ, float lastX, float lastZ)
	{
		float num = Vector3.Distance(vecs[0], vecs[1]);
		vecs.Insert(0, vecs[0] + new Vector3(firstX, 0f, firstZ).normalized * num);
		vecs.Add(vecs[vecs.Count - 1] + new Vector3(lastX, 0f, lastZ).normalized * num);
	}

	public static Vector3 OCCDQDCQCD(int i, float radius, float angle)
	{
		return ERRoundabouts.OQDDDODCOC(Vector3.zero, new Vector3(radius, 0f, 0f), Quaternion.Euler(0f, angle * (float)i, 0f));
	}

	public static void OQODOQQCOO(ERCrossings scr)
	{
		if (scr.tCrossingLeftRight == 0)
		{
			float num = scr.prefabScript.sidewalkControlElements[0].cornerRadius + Vector3.Distance(scr.startConnectionV3[0][0], scr.startConnectionV3[0][1]);
			if (scr.prefabScript.sidewalkControlElements[0].sidewalkWidth1 > num)
			{
				ODOODDOQOQ(scr.startConnectionV3[0], 0f, -1f, scr.prefabScript.sidewalkControlElements[0].sidewalkWidth1, 1f, num);
				ODOODDOQOQ(scr.leftConnectionV3[1], -1f, 0f, scr.prefabScript.sidewalkControlElements[0].sidewalkWidth1, 1f, num);
			}
		}
		if (scr.tCrossingLeftRight == 1)
		{
			float num = scr.prefabScript.sidewalkControlElements[1].cornerRadius + Vector3.Distance(scr.startConnectionV3[1][0], scr.startConnectionV3[1][1]);
			if (scr.prefabScript.sidewalkControlElements[1].sidewalkWidth1 > num)
			{
				ODOODDOQOQ(scr.startConnectionV3[1], 0f, -1f, scr.prefabScript.sidewalkControlElements[1].sidewalkWidth1, 1f, num);
				ODOODDOQOQ(scr.rightConnectionV3[0], 1f, 0f, scr.prefabScript.sidewalkControlElements[1].sidewalkWidth1, 1f, num);
			}
		}
		if (scr.tCrossingLeftRight == 1)
		{
			float num = scr.prefabScript.sidewalkControlElements[3].cornerRadius + Vector3.Distance(scr.endConnectionV3[0][0], scr.endConnectionV3[0][1]);
			if (scr.prefabScript.sidewalkControlElements[3].sidewalkWidth1 > num)
			{
				ODOODDOQOQ(scr.endConnectionV3[0], 0f, 1f, scr.prefabScript.sidewalkControlElements[3].sidewalkWidth1, 1f, num);
				ODOODDOQOQ(scr.rightConnectionV3[1], 1f, 0f, scr.prefabScript.sidewalkControlElements[3].sidewalkWidth1, 1f, num);
			}
		}
		if (scr.tCrossingLeftRight == 0)
		{
			float num = scr.prefabScript.sidewalkControlElements[2].cornerRadius + Vector3.Distance(scr.endConnectionV3[1][0], scr.endConnectionV3[1][1]);
			if (scr.prefabScript.sidewalkControlElements[2].sidewalkWidth1 > num)
			{
				ODOODDOQOQ(scr.endConnectionV3[1], 0f, 1f, scr.prefabScript.sidewalkControlElements[2].sidewalkWidth1, 1f, num);
				ODOODDOQOQ(scr.leftConnectionV3[0], -1f, 0f, scr.prefabScript.sidewalkControlElements[2].sidewalkWidth1, 1f, num);
			}
		}
	}

	public static void ODOODDOQOQ(List<Vector3> vecs, float firstX, float firstZ, float sidewalkWidth, float resolution, float currentDist)
	{
		Vector3 normalized = new Vector3(firstX, 0f, firstZ).normalized;
		float num = 0f;
		bool flag = false;
		while (!flag)
		{
			if (currentDist + resolution < sidewalkWidth)
			{
				num = resolution;
			}
			else if (currentDist == sidewalkWidth)
			{
				num = resolution;
				flag = true;
			}
			else if (currentDist + resolution > sidewalkWidth)
			{
				num = sidewalkWidth - currentDist;
			}
			Vector3 vector = vecs[0] + normalized * num;
			if (Vector3.Distance(vector, vecs[0]) < 0.25f * resolution)
			{
				vecs[0] = vector;
			}
			else
			{
				vecs.Insert(0, vector);
			}
			currentDist += num;
		}
	}

	public static void OOOCDOCQQO(ERCrossings scr)
	{
		if (scr.startConnectionV3[0][0].z != scr.startConnectionV3[1][0].z)
		{
			if (scr.startConnectionV3[0][0].z > scr.startConnectionV3[1][0].z)
			{
				OOOCOQODOO(scr.startConnectionV3[0], scr.startConnectionV3[1][0].z, 0f, -1f, scr.resolution, 1);
			}
			else
			{
				OOOCOQODOO(scr.startConnectionV3[1], scr.startConnectionV3[0][0].z, 0f, -1f, scr.resolution, 1);
			}
		}
		if (scr.endConnectionV3[0][0].z != scr.endConnectionV3[1][0].z)
		{
			if (scr.endConnectionV3[0][0].z < scr.endConnectionV3[1][0].z)
			{
				OOOCOQODOO(scr.endConnectionV3[0], scr.endConnectionV3[1][0].z, 0f, 1f, scr.resolution, 1);
			}
			else
			{
				OOOCOQODOO(scr.endConnectionV3[1], scr.endConnectionV3[0][0].z, 0f, 1f, scr.resolution, 1);
			}
		}
		if (scr.tCrossingLeftRight == 0 && scr.leftConnectionV3[0][0].x != scr.leftConnectionV3[1][0].x)
		{
			if (scr.leftConnectionV3[0][0].x > scr.leftConnectionV3[1][0].x)
			{
				OOOCOQODOO(scr.leftConnectionV3[0], scr.leftConnectionV3[1][0].x, -1f, 0f, scr.resolution, 0);
			}
			else
			{
				OOOCOQODOO(scr.leftConnectionV3[1], scr.leftConnectionV3[0][0].x, -1f, 0f, scr.resolution, 0);
			}
		}
		if (scr.tCrossingLeftRight == 1 && scr.rightConnectionV3[0][0].x != scr.rightConnectionV3[1][0].x)
		{
			if (scr.rightConnectionV3[0][0].x < scr.rightConnectionV3[1][0].x)
			{
				OOOCOQODOO(scr.rightConnectionV3[0], scr.rightConnectionV3[1][0].x, 1f, 0f, scr.resolution, 0);
			}
			else
			{
				OOOCOQODOO(scr.rightConnectionV3[1], scr.rightConnectionV3[0][0].x, 1f, 0f, scr.resolution, 0);
			}
		}
	}

	public static void OOOCOQODOO(List<Vector3> targetVecs, float targetValue, float firstX, float firstZ, float resolution, int xorz)
	{
		bool flag = false;
		while (!flag)
		{
			Vector3 item = targetVecs[0];
			if (xorz == 0)
			{
				item.x += resolution * firstX;
				if (firstX < 0f)
				{
					if (item.x <= targetValue)
					{
						item.x = targetValue;
						flag = true;
					}
				}
				else if (item.x >= targetValue)
				{
					item.x = targetValue;
					flag = true;
				}
			}
			else
			{
				item.z += resolution * firstZ;
				if (firstZ < 0f)
				{
					if (item.z <= targetValue)
					{
						item.z = targetValue;
						flag = true;
					}
				}
				else if (item.z >= targetValue)
				{
					item.z = targetValue;
					flag = true;
				}
			}
			targetVecs.Insert(0, item);
		}
	}

	public static void OCOOOQQQQO(ERCrossings scr)
	{
		float innerSegmentDistance = scr.prefabScript.sidewalkControlElements[0].innerSegmentDistance;
		scr.startConnectionV3.Insert(1, OOOCCCCDDQ(scr.startConnectionV3[0], 1f, innerSegmentDistance));
		innerSegmentDistance = scr.prefabScript.sidewalkControlElements[1].innerSegmentDistance;
		scr.startConnectionV3.Insert(2, OOOCCCCDDQ(scr.startConnectionV3[2], -1f, innerSegmentDistance));
		innerSegmentDistance = ((scr.tCrossingLeftRight != 1) ? scr.prefabScript.sidewalkControlElements[1].innerSegmentDistance : scr.prefabScript.sidewalkControlElements[3].innerSegmentDistance);
		scr.endConnectionV3.Insert(1, OOOCCCCDDQ(scr.endConnectionV3[0], 1f, innerSegmentDistance));
		innerSegmentDistance = ((scr.tCrossingLeftRight != 0) ? scr.prefabScript.sidewalkControlElements[0].innerSegmentDistance : scr.prefabScript.sidewalkControlElements[2].innerSegmentDistance);
		scr.endConnectionV3.Insert(2, OOOCCCCDDQ(scr.endConnectionV3[2], -1f, innerSegmentDistance));
		if (scr.tCrossingLeftRight == 0)
		{
			innerSegmentDistance = scr.prefabScript.sidewalkControlElements[2].innerSegmentDistance;
			scr.leftConnectionV3.Insert(1, OOOCCCCDDQ(scr.leftConnectionV3[0], 1f, innerSegmentDistance));
			innerSegmentDistance = scr.prefabScript.sidewalkControlElements[0].innerSegmentDistance;
			scr.leftConnectionV3.Insert(2, OOOCCCCDDQ(scr.leftConnectionV3[2], -1f, innerSegmentDistance));
		}
		if (scr.tCrossingLeftRight == 1)
		{
			innerSegmentDistance = scr.prefabScript.sidewalkControlElements[1].innerSegmentDistance;
			scr.rightConnectionV3.Insert(1, OOOCCCCDDQ(scr.rightConnectionV3[0], 1f, innerSegmentDistance));
			innerSegmentDistance = scr.prefabScript.sidewalkControlElements[3].innerSegmentDistance;
			scr.rightConnectionV3.Insert(2, OOOCCCCDDQ(scr.rightConnectionV3[2], -1f, innerSegmentDistance));
		}
	}

	public static List<Vector3> OOOCCCCDDQ(List<Vector3> sourceVecs, float leftRight, float distance)
	{
		List<Vector3> list = new List<Vector3>();
		Vector3 zero = Vector3.zero;
		for (int i = 0; i < sourceVecs.Count; i++)
		{
			if (i == 0)
			{
				zero = sourceVecs[i + 1] - sourceVecs[i];
				zero = new Vector3(zero.z, 0f, 0f - zero.x).normalized * leftRight;
			}
			else if (i == sourceVecs.Count - 1)
			{
				zero = (Vector3.zero - sourceVecs[i]).normalized;
			}
			else
			{
				zero = sourceVecs[i + 1] - sourceVecs[i - 1];
				zero = new Vector3(zero.z, 0f, 0f - zero.x).normalized * leftRight;
			}
			list.Add(sourceVecs[i] + zero * distance);
		}
		return list;
	}

	public static void OOCCOQQDQQ(ERCrossings scr)
	{
		if (scr.startConnectionV3[0].Count > scr.startConnectionV3[3].Count)
		{
			scr.startConnectionV3.Insert(2, OOOODDQDCC(scr.startConnectionV3[1], 1));
		}
		else
		{
			scr.startConnectionV3.Insert(2, OOOODDQDCC(scr.startConnectionV3[2], 1));
		}
		if (scr.endConnectionV3[0].Count > scr.endConnectionV3[3].Count)
		{
			scr.endConnectionV3.Insert(2, OOOODDQDCC(scr.endConnectionV3[1], 1));
		}
		else
		{
			scr.endConnectionV3.Insert(2, OOOODDQDCC(scr.endConnectionV3[2], 1));
		}
		if (scr.tCrossingLeftRight == 0)
		{
			if (scr.leftConnectionV3[0].Count > scr.leftConnectionV3[3].Count)
			{
				scr.leftConnectionV3.Insert(2, OOOODDQDCC(scr.leftConnectionV3[1], 0));
			}
			else
			{
				scr.leftConnectionV3.Insert(2, OOOODDQDCC(scr.leftConnectionV3[2], 0));
			}
		}
		if (scr.tCrossingLeftRight == 1)
		{
			if (scr.rightConnectionV3[0].Count > scr.rightConnectionV3[3].Count)
			{
				scr.rightConnectionV3.Insert(2, OOOODDQDCC(scr.rightConnectionV3[1], 0));
			}
			else
			{
				scr.rightConnectionV3.Insert(2, OOOODDQDCC(scr.rightConnectionV3[2], 0));
			}
		}
	}

	public static List<Vector3> OOOODDQDCC(List<Vector3> sourceVecs, int xorz)
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < sourceVecs.Count; i++)
		{
			if (xorz == 0)
			{
				list.Add(new Vector3(sourceVecs[i].x, 0f, 0f));
			}
			else
			{
				list.Add(new Vector3(0f, 0f, sourceVecs[i].z));
			}
		}
		return list;
	}
}
[AddComponentMenu("")]
public class OQQDOCQOCO : MonoBehaviour
{
	public static void OQDCOQDQDO(ERCrossings scr, ref List<Vector3> meshVecs, ref List<Vector2> meshUVs, ref List<List<int>> triList, List<Material> materialList, List<Material> connectionMaterialList)
	{
		int centerPointIndex = 0;
		int centerPointIndex2 = 0;
		int centerPointIndex3 = 0;
		meshVecs.Add(Vector3.zero);
		meshUVs.Add(new Vector2(0.5f, ODDDDDCCQQ.GetCenterUVY(scr, scr.frontRoadUVTiling, scr.startConnectionV3, 0)));
		float num = 0f;
		num = ((scr.tCrossingLeftRight != 0) ? scr.rightRoadUVTiling : scr.leftRoadUVTiling);
		if (scr.frontRoadUVTiling == scr.backRoadUVTiling && scr.frontRoadUVTiling != num)
		{
			centerPointIndex3 = 1;
			meshVecs.Add(Vector3.zero);
			if (scr.tCrossingLeftRight == 0)
			{
				meshUVs.Add(new Vector2(0.5f, ODDDDDCCQQ.GetCenterUVY(scr, scr.leftRoadUVTiling, scr.leftConnectionV3, 2)));
			}
			else
			{
				meshUVs.Add(new Vector2(0.5f, ODDDDDCCQQ.GetCenterUVY(scr, scr.rightRoadUVTiling, scr.rightConnectionV3, 3)));
			}
		}
		else if (scr.frontRoadUVTiling != scr.backRoadUVTiling)
		{
			centerPointIndex2 = (centerPointIndex3 = 1);
			meshVecs.Add(Vector3.zero);
			meshUVs.Add(new Vector2(0.5f, ODDDDDCCQQ.GetCenterUVY(scr, scr.backRoadUVTiling, scr.endConnectionV3, 1)));
			if (num != scr.backRoadUVTiling)
			{
				centerPointIndex3 = 2;
				meshVecs.Add(Vector3.zero);
				if (scr.tCrossingLeftRight == 0)
				{
					meshUVs.Add(new Vector2(0.5f, ODDDDDCCQQ.GetCenterUVY(scr, scr.leftRoadUVTiling, scr.leftConnectionV3, 2)));
				}
				else
				{
					meshUVs.Add(new Vector2(0.5f, ODDDDDCCQQ.GetCenterUVY(scr, scr.rightRoadUVTiling, scr.rightConnectionV3, 3)));
				}
			}
		}
		scr.prefabScript.tCrossingBlendData.Add(new ERBlendVecs(scr.prefabScript.tCrossingBlendData.Count, 0, 0f, 0, 0));
		OCODCOCODQ(scr, scr.startConnectionV3, scr.startConnectionUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.startConnectionTris, 1, ODQDQDQDQO.ODOCOCDQCO(materialList, connectionMaterialList[0]), 0, ref scr.frontLeftRoadInts, ref scr.frontRightRoadInts, centerPointIndex);
		if (scr.tCrossing)
		{
			OODODOQDCC.OCQQDDOCCD(scr, 0, 0, 0, scr.startConnectionV3);
		}
		OCODCOCODQ(scr, scr.endConnectionV3, scr.endConnectionUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.endConnectionTris, 1, ODQDQDQDQO.ODOCOCDQCO(materialList, connectionMaterialList[1]), 1, ref scr.backLeftRoadInts, ref scr.backRightRoadInts, centerPointIndex2);
		if (scr.tCrossing)
		{
			OODODOQDCC.OCQQDDOCCD(scr, 1, 0, 0, scr.endConnectionV3);
		}
		if (scr.tCrossingLeftRight == 0)
		{
			OCODCOCODQ(scr, scr.leftConnectionV3, scr.leftConnectionUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.leftConnectionTris, 1, ODQDQDQDQO.ODOCOCDQCO(materialList, connectionMaterialList[2]), 2, ref scr.leftLeftRoadInts, ref scr.leftRightRoadInts, centerPointIndex3);
			if (scr.tCrossing)
			{
				OODODOQDCC.OCQQDDOCCD(scr, 2, 0, 0, scr.leftConnectionV3);
			}
		}
		if (scr.tCrossingLeftRight == 1)
		{
			OCODCOCODQ(scr, scr.rightConnectionV3, scr.rightConnectionUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.rightConnectionTris, 1, ODQDQDQDQO.ODOCOCDQCO(materialList, connectionMaterialList[3]), 2, ref scr.rightLeftRoadInts, ref scr.rightRightRoadInts, centerPointIndex3);
			if (scr.tCrossing)
			{
				OODODOQDCC.OCQQDDOCCD(scr, 3, 0, 0, scr.rightConnectionV3);
			}
		}
	}

	public static void OCODCOCODQ(ERCrossings scr, List<List<Vector3>> vecArray, List<List<Vector2>> uvArray, int frontLeft, int topBottom, ref List<Vector3> meshVecs, ref List<Vector2> meshUVs, ref List<List<int>> triList, ref List<List<int>> intArray, int startRow, int triArrayIndex, int connection, ref List<int> borderIntsLeft, ref List<int> borderIntsRight, int centerPointIndex)
	{
		int num = meshVecs.Count;
		for (int i = 0; i < vecArray.Count; i++)
		{
			intArray.Add(new List<int>());
			for (int j = 0; j < vecArray[i].Count; j++)
			{
				meshVecs.Add(vecArray[i][j]);
				meshUVs.Add(uvArray[i][j]);
				intArray[i].Add(num);
				num++;
			}
			switch (i)
			{
			case 0:
				borderIntsLeft.Add(meshVecs.Count - 1);
				break;
			case 1:
				borderIntsLeft.Add(meshVecs.Count - 1);
				break;
			case 3:
				borderIntsRight.Add(meshVecs.Count - 1);
				break;
			case 4:
				borderIntsRight.Insert(0, meshVecs.Count - 1);
				break;
			}
		}
		if (startRow == 1)
		{
			triList[triArrayIndex].AddRange(OODCODOODC(intArray));
		}
		triList[triArrayIndex].AddRange(OCCQOODCCO(intArray[0], intArray[1], startRow, 0));
		triList[triArrayIndex].AddRange(OCCQOODCCO(intArray[3], intArray[4], startRow, 1));
		if (intArray[1].Count == intArray[2].Count)
		{
			triList[triArrayIndex].AddRange(OCCQOODCCO(intArray[1], intArray[2], startRow, 0));
		}
		else
		{
			triList[triArrayIndex].AddRange(OOQCQQDDQC(intArray[1], intArray[2], vecArray[1], vecArray[2], frontLeft, topBottom, startRow));
		}
		if (intArray[2].Count == intArray[3].Count)
		{
			triList[triArrayIndex].AddRange(OCCQOODCCO(intArray[2], intArray[3], startRow, 1));
		}
		else
		{
			triList[triArrayIndex].AddRange(OOQCQQDDQC(intArray[2], intArray[3], vecArray[2], vecArray[3], frontLeft, topBottom, startRow));
		}
		triList[triArrayIndex].Add(intArray[1][intArray[1].Count - 1]);
		triList[triArrayIndex].Add(centerPointIndex);
		triList[triArrayIndex].Add(intArray[2][intArray[2].Count - 1]);
		triList[triArrayIndex].Add(intArray[2][intArray[2].Count - 1]);
		triList[triArrayIndex].Add(centerPointIndex);
		triList[triArrayIndex].Add(intArray[3][intArray[3].Count - 1]);
	}

	public static List<int> OODCODOODC(List<List<int>> intArray)
	{
		List<int> list = new List<int>();
		list.Add(intArray[0][0]);
		list.Add(intArray[0][1]);
		list.Add(intArray[1][1]);
		list.Add(intArray[0][0]);
		list.Add(intArray[1][1]);
		list.Add(intArray[2][1]);
		list.Add(intArray[0][0]);
		list.Add(intArray[2][1]);
		list.Add(intArray[4][0]);
		list.Add(intArray[4][0]);
		list.Add(intArray[2][1]);
		list.Add(intArray[3][1]);
		list.Add(intArray[4][0]);
		list.Add(intArray[3][1]);
		list.Add(intArray[4][1]);
		return list;
	}

	public static List<int> OCCQOODCCO(List<int> col1, List<int> col2, int startRow, int type)
	{
		List<int> list = new List<int>();
		if (type == 0)
		{
			for (int i = startRow; i < col1.Count - 1; i++)
			{
				list.Add(col1[i]);
				list.Add(col2[i + 1]);
				list.Add(col2[i]);
				list.Add(col1[i + 1]);
				list.Add(col2[i + 1]);
				list.Add(col1[i]);
			}
		}
		else
		{
			for (int j = startRow; j < col1.Count - 1; j++)
			{
				list.Add(col1[j]);
				list.Add(col1[j + 1]);
				list.Add(col2[j]);
				list.Add(col2[j]);
				list.Add(col1[j + 1]);
				list.Add(col2[j + 1]);
			}
		}
		return list;
	}

	public static List<int> OOQCQQDDQC(List<int> col1, List<int> col2, List<Vector3> vecs1, List<Vector3> vecs2, int frontLeft, int topBottom, int startRow)
	{
		List<int> list = new List<int>();
		int num = startRow;
		int num2 = startRow;
		int num3 = 0;
		bool flag = false;
		bool flag2 = false;
		int num4 = 0;
		while ((!flag || !flag2) && num3 < 100)
		{
			if (num < col1.Count - 1 && num2 < col2.Count - 1)
			{
				float num5 = Vector3.Distance(vecs1[num], vecs2[num2 + 1]);
				float num6 = Vector3.Distance(vecs1[num + 1], vecs2[num2]);
				num4 = ((num5 < num6) ? 1 : 0);
			}
			else if (num >= col1.Count - 1)
			{
				num4 = 1;
			}
			else if (num2 >= col2.Count - 1)
			{
				num4 = 0;
			}
			if (num4 == 0)
			{
				list.Add(col1[num]);
				list.Add(col1[num + 1]);
				list.Add(col2[num2]);
				num++;
			}
			else
			{
				list.Add(col1[num]);
				list.Add(col2[num2 + 1]);
				list.Add(col2[num2]);
				num2++;
			}
			if (num >= col1.Count - 1)
			{
				flag = true;
			}
			if (num2 >= col2.Count - 1)
			{
				flag2 = true;
			}
			num3++;
		}
		return list;
	}

	public static void InitODCOCQQDDC(ERCrossings scr)
	{
		ODCOCQQDDC(scr, scr.startConnectionV3, ref scr.startConnectionUV, ref scr.uvArrayFront, 0, scr.frontRoadUVTiling);
		ODCOCQQDDC(scr, scr.endConnectionV3, ref scr.endConnectionUV, ref scr.uvArrayBack, 0, scr.backRoadUVTiling);
		if (scr.tCrossingLeftRight == 0)
		{
			ODCOCQQDDC(scr, scr.leftConnectionV3, ref scr.leftConnectionUV, ref scr.uvArrayLeft, 1, scr.leftRoadUVTiling);
		}
		if (scr.tCrossingLeftRight == 1)
		{
			ODCOCQQDDC(scr, scr.rightConnectionV3, ref scr.rightConnectionUV, ref scr.uvArrayRight, 1, scr.rightRoadUVTiling);
		}
	}

	public static void ODCOCQQDDC(ERCrossings scr, List<List<Vector3>> vecArray, ref List<List<Vector2>> uvs, ref List<float> uvArray, int verthorz, float uvTiling)
	{
		ERSideWalkVecs.ODQOQOCCOC(vecArray, ref uvArray);
		Vector3 vA = new Vector3(50f, 0f, 0f);
		Vector3 vB = new Vector3(-50f, 0f, 0f);
		float num = Mathf.Abs(vecArray[0][0].z);
		if (verthorz == 1)
		{
			vA = new Vector3(0f, 0f, 50f);
			vB = new Vector3(0f, 0f, -50f);
			num = Mathf.Abs(vecArray[0][0].x);
		}
		float num2 = 5f * uvTiling;
		float num3 = 0f;
		for (int i = 0; i < vecArray.Count; i++)
		{
			uvs.Add(new List<Vector2>());
			for (int j = 0; j < vecArray[i].Count; j++)
			{
				Vector3 a = ODDCQDDCDD.OQQCQOCCOQ(vA, vB, vecArray[i][j]);
				num3 = Vector3.Distance(a, vecArray[i][j]);
				float num4 = num3 / num;
				uvs[i].Add(new Vector2(uvArray[i], num3 / num2));
			}
		}
	}
}
[AddComponentMenu("")]
public class ODDCOQCOOO : MonoBehaviour
{
	public static void OQOQDODDCD(ERCrossings scr)
	{
		ODCCDOQOOC(scr);
		OODDCODCCQ(scr);
		if (scr.tCrossingLeftRight == 0)
		{
			OOOQCOQOOQ(scr, scr.leftSidewalkStartV3, scr.rightSidewalkLeftV3, scr.prefabScript.sidewalkControlElements[0], 0, 0, scr.leftStartSidewalkCornerInt, crossingSide: true);
			OOOQCOQOOQ(scr, scr.rightSidewalkLeftV3, scr.leftSidewalkStartV3, scr.prefabScript.sidewalkControlElements[0], 1, 1, scr.rightLeftSidewalkCornerInt, crossingSide: true);
			ODDCDODCCQ(ref scr.leftSidewalkStartV3, ref scr.rightSidewalkLeftV3);
		}
		else
		{
			OOOQCOQOOQ(scr, scr.leftSidewalkStartV3, scr.rightSidewalkLeftV3, scr.prefabScript.sidewalkControlElements[0], 0, 0, scr.leftStartSidewalkCornerInt, crossingSide: false);
		}
		if (scr.tCrossingLeftRight == 1)
		{
			OOOQCOQOOQ(scr, scr.rightSidewalkStartV3, scr.leftSidewalkRightV3, scr.prefabScript.sidewalkControlElements[1], 1, 0, scr.rightStartSidewalkCornerInt, crossingSide: true);
			OOOQCOQOOQ(scr, scr.leftSidewalkRightV3, scr.rightSidewalkStartV3, scr.prefabScript.sidewalkControlElements[1], 0, 1, scr.leftRightSidewalkCornerInt, crossingSide: true);
			ODDCDODCCQ(ref scr.rightSidewalkStartV3, ref scr.leftSidewalkRightV3);
		}
		else
		{
			OOOQCOQOOQ(scr, scr.rightSidewalkStartV3, scr.leftSidewalkRightV3, scr.prefabScript.sidewalkControlElements[1], 1, 0, scr.rightStartSidewalkCornerInt, crossingSide: false);
		}
		if (scr.tCrossingLeftRight == 1)
		{
			OOOQCOQOOQ(scr, scr.leftSidewalkEndV3, scr.rightSidewalkRightV3, scr.prefabScript.sidewalkControlElements[3], 0, 0, scr.leftEndSidewalkCornerInt, crossingSide: true);
			OOOQCOQOOQ(scr, scr.rightSidewalkRightV3, scr.leftSidewalkEndV3, scr.prefabScript.sidewalkControlElements[3], 1, 1, scr.rightRightSidewalkCornerInt, crossingSide: true);
			ODDCDODCCQ(ref scr.leftSidewalkEndV3, ref scr.rightSidewalkRightV3);
		}
		else
		{
			OOOQCOQOOQ(scr, scr.leftSidewalkEndV3, scr.rightSidewalkRightV3, scr.prefabScript.sidewalkControlElements[1], 0, 0, scr.leftEndSidewalkCornerInt, crossingSide: false);
		}
		if (scr.tCrossingLeftRight == 0)
		{
			OOOQCOQOOQ(scr, scr.rightSidewalkEndV3, scr.leftSidewalkLeftV3, scr.prefabScript.sidewalkControlElements[2], 1, 0, scr.rightEndSidewalkCornerInt, crossingSide: true);
			OOOQCOQOOQ(scr, scr.leftSidewalkLeftV3, scr.rightSidewalkEndV3, scr.prefabScript.sidewalkControlElements[2], 0, 1, scr.leftLeftSidewalkCornerInt, crossingSide: true);
			ODDCDODCCQ(ref scr.rightSidewalkEndV3, ref scr.leftSidewalkLeftV3);
		}
		else
		{
			OOOQCOQOOQ(scr, scr.rightSidewalkEndV3, scr.leftSidewalkLeftV3, scr.prefabScript.sidewalkControlElements[0], 1, 0, scr.rightEndSidewalkCornerInt, crossingSide: false);
		}
		ODQDQQOQCC(scr, scr.leftSidewalkStartV3, ref scr.leftSidewalkStartUV, scr.prefabScript.sidewalkControlElements[0], reverse: true, scr.frontRoadUVTiling);
		if (scr.tCrossingLeftRight == 0)
		{
			ODQDQQOQCC(scr, scr.rightSidewalkLeftV3, ref scr.rightSidewalkLeftUV, scr.prefabScript.sidewalkControlElements[0], reverse: false, scr.rightRoadUVTiling);
		}
		ODQDQQOQCC(scr, scr.rightSidewalkStartV3, ref scr.rightSidewalkStartUV, scr.prefabScript.sidewalkControlElements[1], reverse: false, scr.frontRoadUVTiling);
		if (scr.tCrossingLeftRight == 1)
		{
			ODQDQQOQCC(scr, scr.leftSidewalkRightV3, ref scr.leftSidewalkRightUV, scr.prefabScript.sidewalkControlElements[1], reverse: true, scr.leftRoadUVTiling);
		}
		ODQDQQOQCC(scr, scr.leftSidewalkEndV3, ref scr.leftSidewalkEndUV, scr.prefabScript.sidewalkControlElements[3], reverse: true, scr.backRoadUVTiling);
		if (scr.tCrossingLeftRight == 1)
		{
			ODQDQQOQCC(scr, scr.rightSidewalkRightV3, ref scr.rightSidewalkRightUV, scr.prefabScript.sidewalkControlElements[3], reverse: false, scr.rightRoadUVTiling);
		}
		if (!scr.tCrossing || scr.tCrossingLeftRight == 0)
		{
			ODQDQQOQCC(scr, scr.rightSidewalkEndV3, ref scr.rightSidewalkEndUV, scr.prefabScript.sidewalkControlElements[2], reverse: false, scr.backRoadUVTiling);
		}
		else
		{
			ODQDQQOQCC(scr, scr.rightSidewalkEndV3, ref scr.rightSidewalkEndUV, scr.prefabScript.sidewalkControlElements[0], reverse: false, scr.backRoadUVTiling);
		}
		if (scr.tCrossingLeftRight == 0)
		{
			ODQDQQOQCC(scr, scr.leftSidewalkLeftV3, ref scr.leftSidewalkLeftUV, scr.prefabScript.sidewalkControlElements[2], reverse: true, scr.leftRoadUVTiling);
		}
	}

	public static void ODCCDOQOOC(ERCrossings scr)
	{
		if (scr.tCrossingLeftRight == 0)
		{
			OQOQDOOOQO(scr, scr.startConnectionV3[0], scr.leftConnectionV3[scr.leftConnectionV3.Count - 1][0], scr.prefabScript.sidewalkControlElements[0].sidewalkWidth1, 1, ref scr.leftStartSidewalkCornerInt);
			OQOQDOOOQO(scr, scr.leftConnectionV3[scr.leftConnectionV3.Count - 1], scr.startConnectionV3[0][0], scr.prefabScript.sidewalkControlElements[0].sidewalkWidth1, 0, ref scr.rightLeftSidewalkCornerInt);
		}
		else
		{
			scr.leftStartSidewalkCornerInt = scr.startConnectionV3[0].Count;
		}
		if (scr.tCrossingLeftRight == 1)
		{
			OQOQDOOOQO(scr, scr.startConnectionV3[scr.startConnectionV3.Count - 1], scr.rightConnectionV3[0][0], scr.prefabScript.sidewalkControlElements[1].sidewalkWidth1, 1, ref scr.rightStartSidewalkCornerInt);
			OQOQDOOOQO(scr, scr.rightConnectionV3[0], scr.startConnectionV3[scr.startConnectionV3.Count - 1][0], scr.prefabScript.sidewalkControlElements[1].sidewalkWidth1, 0, ref scr.leftRightSidewalkCornerInt);
		}
		else
		{
			scr.rightStartSidewalkCornerInt = scr.startConnectionV3[scr.startConnectionV3.Count - 1].Count;
		}
		if (scr.tCrossingLeftRight == 1)
		{
			OQOQDOOOQO(scr, scr.endConnectionV3[0], scr.rightConnectionV3[scr.rightConnectionV3.Count - 1][0], scr.prefabScript.sidewalkControlElements[3].sidewalkWidth1, 1, ref scr.leftEndSidewalkCornerInt);
			OQOQDOOOQO(scr, scr.rightConnectionV3[scr.rightConnectionV3.Count - 1], scr.endConnectionV3[0][0], scr.prefabScript.sidewalkControlElements[3].sidewalkWidth1, 0, ref scr.rightRightSidewalkCornerInt);
		}
		else
		{
			scr.leftEndSidewalkCornerInt = scr.endConnectionV3[0].Count;
		}
		if (scr.tCrossingLeftRight == 0)
		{
			OQOQDOOOQO(scr, scr.endConnectionV3[scr.endConnectionV3.Count - 1], scr.leftConnectionV3[0][0], scr.prefabScript.sidewalkControlElements[2].sidewalkWidth1, 1, ref scr.rightEndSidewalkCornerInt);
			OQOQDOOOQO(scr, scr.leftConnectionV3[0], scr.endConnectionV3[scr.endConnectionV3.Count - 1][0], scr.prefabScript.sidewalkControlElements[2].sidewalkWidth1, 0, ref scr.leftLeftSidewalkCornerInt);
		}
		else
		{
			scr.rightEndSidewalkCornerInt = scr.endConnectionV3[scr.endConnectionV3.Count - 1].Count;
		}
	}

	public static void OQOQDOOOQO(ERCrossings scr, List<Vector3> vecArray, Vector3 firstOther, float sidewalkWidth, int xorz, ref int cornerInt)
	{
		if (xorz == 0)
		{
			firstOther.z = vecArray[0].z;
		}
		else
		{
			firstOther.x = vecArray[0].x;
		}
		cornerInt = vecArray.Count - 1;
		for (int i = 0; i < vecArray.Count; i++)
		{
			if (Vector3.Distance(vecArray[i], firstOther) <= sidewalkWidth)
			{
				cornerInt = i + 1;
				break;
			}
		}
	}

	public static void OOOQCOQOOQ(ERCrossings scr, List<List<Vector3>> vecArray, List<List<Vector3>> vecArrayOther, QDOQDSQOOQDDD corner, int startEnd, int mainOrConnected, int outerCornerInt, bool crossingSide)
	{
		float num = 0f;
		float num2 = 0f;
		List<Vector3> list = new List<Vector3>();
		if (corner.beveledCurb)
		{
			if (corner.beveledHeight > 0f && corner.beveledHeight != corner.curbHeight)
			{
				num2 = corner.beveledHeight;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(OQODQDOQOQ(vecArray[0], num2));
			}
			num2 = corner.curbHeight;
			if (corner.beveledDepth > 0f && corner.beveledDepth != corner.curbDepth)
			{
				num = corner.beveledDepth;
				vecArray.Add(new List<Vector3>());
				if (crossingSide)
				{
					vecArray[vecArray.Count - 1].AddRange(ODCODDCCOC(vecArray[0], vecArrayOther[0], num, num2, startEnd, mainOrConnected, -1));
				}
				else
				{
					vecArray[vecArray.Count - 1].AddRange(OOQQQQQCOO(vecArray[0], num, num2, startEnd, mainOrConnected, -1));
				}
			}
			if (corner.beveledDepth != corner.curbDepth)
			{
				num = corner.curbDepth;
				vecArray.Add(new List<Vector3>());
				if (crossingSide)
				{
					vecArray[vecArray.Count - 1].AddRange(ODCODDCCOC(vecArray[0], vecArrayOther[0], num, num2, startEnd, mainOrConnected, -1));
				}
				else
				{
					vecArray[vecArray.Count - 1].AddRange(OOQQQQQCOO(vecArray[0], num, num2, startEnd, mainOrConnected, -1));
				}
			}
		}
		else
		{
			num2 = corner.curbHeight;
			vecArray.Add(new List<Vector3>());
			vecArray[vecArray.Count - 1].AddRange(OQODQDOQOQ(vecArray[0], num2));
			num = corner.curbDepth;
			vecArray.Add(new List<Vector3>());
			if (crossingSide)
			{
				vecArray[vecArray.Count - 1].AddRange(ODCODDCCOC(vecArray[0], vecArrayOther[0], num, num2, startEnd, mainOrConnected, -1));
			}
			else
			{
				vecArray[vecArray.Count - 1].AddRange(OOQQQQQCOO(vecArray[0], num, num2, startEnd, mainOrConnected, -1));
			}
		}
		num = corner.curbDepth;
		vecArray.Add(new List<Vector3>());
		vecArray[vecArray.Count - 1].AddRange(OQCDDCOODQ(scr, vecArray[0], num, num2, corner.sidewalkWidth1, startEnd, mainOrConnected, outerCornerInt));
		if (corner.beveledCurb && corner.outerCurb)
		{
			if (corner.beveledDepth != corner.curbDepth && corner.beveledDepth > 0f)
			{
				num = corner.beveledDepth;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(OQCDDCOODQ(scr, vecArray[0], num, num2, corner.sidewalkWidth1, startEnd, mainOrConnected, outerCornerInt));
			}
			if (corner.beveledHeight > 0f && corner.beveledHeight != corner.curbHeight && corner.outerCurb)
			{
				num2 = corner.beveledHeight;
				num = 0f;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(OQCDDCOODQ(scr, vecArray[0], num, num2, corner.sidewalkWidth1, startEnd, mainOrConnected, outerCornerInt));
			}
			num2 = 0f;
			num = 0f;
			vecArray.Add(new List<Vector3>());
			vecArray[vecArray.Count - 1].AddRange(OQCDDCOODQ(scr, vecArray[0], num, num2, corner.sidewalkWidth1, startEnd, mainOrConnected, outerCornerInt));
		}
		else
		{
			num = 0f;
			num2 = corner.curbHeight;
			vecArray.Add(new List<Vector3>());
			vecArray[vecArray.Count - 1].AddRange(OQCDDCOODQ(scr, vecArray[0], num, num2, corner.sidewalkWidth1, startEnd, mainOrConnected, outerCornerInt));
			if (corner.outerCurb)
			{
				num2 = 0f;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(OQCDDCOODQ(scr, vecArray[0], num, num2, corner.sidewalkWidth1, startEnd, mainOrConnected, outerCornerInt));
			}
		}
	}

	public static void OODDCODCCQ(ERCrossings scr)
	{
		scr.leftSidewalkStartV3.Add(new List<Vector3>());
		scr.leftSidewalkStartV3[0].AddRange(scr.startConnectionV3[0]);
		scr.rightSidewalkStartV3.Add(new List<Vector3>());
		scr.rightSidewalkStartV3[0].AddRange(scr.startConnectionV3[scr.startConnectionV3.Count - 1]);
		scr.leftSidewalkEndV3.Add(new List<Vector3>());
		scr.leftSidewalkEndV3[0].AddRange(scr.endConnectionV3[0]);
		scr.rightSidewalkEndV3.Add(new List<Vector3>());
		scr.rightSidewalkEndV3[0].AddRange(scr.endConnectionV3[scr.endConnectionV3.Count - 1]);
		if (scr.tCrossingLeftRight == 0)
		{
			scr.leftSidewalkLeftV3.Add(new List<Vector3>());
			scr.leftSidewalkLeftV3[0].AddRange(scr.leftConnectionV3[0]);
			scr.rightSidewalkLeftV3.Add(new List<Vector3>());
			scr.rightSidewalkLeftV3[0].AddRange(scr.leftConnectionV3[scr.leftConnectionV3.Count - 1]);
		}
		if (scr.tCrossingLeftRight == 1)
		{
			scr.leftSidewalkRightV3.Add(new List<Vector3>());
			scr.leftSidewalkRightV3[0].AddRange(scr.rightConnectionV3[0]);
			scr.rightSidewalkRightV3.Add(new List<Vector3>());
			scr.rightSidewalkRightV3[0].AddRange(scr.rightConnectionV3[scr.rightConnectionV3.Count - 1]);
		}
	}

	public static List<Vector3> ODCODDCCOC(List<Vector3> outer, List<Vector3> outerOther, float dist, float height, int startend, int leftright, int outerCornerInt)
	{
		List<Vector3> list = new List<Vector3>();
		int num = outer.Count;
		if (outerCornerInt != -1)
		{
			num = outerCornerInt;
		}
		for (int i = 0; i < num; i++)
		{
			Vector3 vector = ((i != 0) ? ((i >= outer.Count - 1) ? (outerOther[outerOther.Count - 2] - outer[i - 1]).normalized : (outer[i + 1] - outer[i - 1]).normalized) : (outer[1] - outer[0]).normalized);
			vector = ((startend != 0) ? new Vector3(vector.z, 0f, 0f - vector.x).normalized : new Vector3(0f - vector.z, 0f, vector.x).normalized);
			Vector3 item = outer[i] + vector * dist;
			item.y = height;
			list.Add(item);
		}
		return list;
	}

	public static List<Vector3> OOQQQQQCOO(List<Vector3> outer, float dist, float height, int startend, int leftright, int outerCornerInt)
	{
		List<Vector3> list = new List<Vector3>();
		int num = outer.Count;
		if (outerCornerInt != -1)
		{
			num = outerCornerInt;
		}
		for (int i = 0; i < num; i++)
		{
			Vector3 vector = ((i != 0) ? ((i >= outer.Count - 1) ? (outer[i] - outer[i - 1]).normalized : (outer[i + 1] - outer[i - 1]).normalized) : (outer[1] - outer[0]).normalized);
			vector = ((startend != 0) ? new Vector3(vector.z, 0f, 0f - vector.x) : new Vector3(0f - vector.z, 0f, vector.x));
			Vector3 item = outer[i] + vector * dist;
			item.y = height;
			list.Add(item);
		}
		return list;
	}

	public static List<Vector3> OQCDDCOODQ(ERCrossings scr, List<Vector3> innerArray, float dist, float height, float sidewalkWidth, int startend, int leftright, int outerCornerInt)
	{
		List<Vector3> list = new List<Vector3>();
		if (sidewalkWidth >= 0.5f)
		{
			Vector3 normalized = (innerArray[1] - innerArray[0]).normalized;
			normalized = ((startend != 0) ? new Vector3(normalized.z, 0f, 0f - normalized.x) : new Vector3(0f - normalized.z, 0f, normalized.x));
			Vector3 vector = innerArray[0] + normalized * sidewalkWidth;
			Vector3 vector2 = innerArray[0];
			Vector3 p = vector;
			if (leftright == 0)
			{
				p.z += 1f;
			}
			else
			{
				p.x += 1f;
			}
			int num = innerArray.Count;
			if (outerCornerInt != -1)
			{
				num = outerCornerInt;
			}
			for (int i = 0; i < num; i++)
			{
				vector2 = innerArray[i];
				if (leftright == 0)
				{
					vector2.x += 1f;
				}
				else
				{
					vector2.z += 1f;
				}
				Vector3 vector3 = ODQDQDQDQO.OODOQDOODO(vector, p, innerArray[i], vector2, flag: false);
				normalized = (innerArray[i] - vector3).normalized;
				vector3 += normalized * dist;
				vector3.y = height;
				list.Add(vector3);
			}
		}
		else
		{
			for (int j = 0; j < innerArray.Count; j++)
			{
				Vector3 normalized = ((j != 0) ? ((j >= innerArray.Count - 1) ? (innerArray[innerArray.Count - 1] - innerArray[innerArray.Count - 2]) : (innerArray[j + 1] - innerArray[j - 1])) : (innerArray[1] - innerArray[0]));
				normalized = (((leftright != 0 || startend != 0) && (leftright != 1 || startend != 0)) ? new Vector3(normalized.z, 0f, 0f - normalized.x).normalized : new Vector3(0f - normalized.z, 0f, normalized.x).normalized);
				Vector3 vector3 = innerArray[j] + normalized * sidewalkWidth;
				vector3.y = height;
				list.Add(vector3);
			}
		}
		return list;
	}

	public static List<Vector3> OQODQDOQOQ(List<Vector3> outer, float height)
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < outer.Count; i++)
		{
			Vector3 item = outer[i];
			item.y = height;
			list.Add(item);
		}
		return list;
	}

	public static void ODQDQQOQCC(ERCrossings scr, List<List<Vector3>> vecArray, ref List<List<Vector2>> uvArray, QDOQDSQOOQDDD corner, bool reverse, float uvTiling)
	{
		if (corner.sidewalkUVs.Count == 0 || !corner.lockUVs)
		{
			ODQOQOCCOC(vecArray, ref corner.sidewalkUVs);
		}
		List<float> list = new List<float>();
		list.AddRange(corner.sidewalkUVs);
		uvArray.Clear();
		float num = 0f;
		float num2 = 5f * uvTiling;
		for (int i = 0; i < vecArray.Count; i++)
		{
			uvArray.Add(new List<Vector2>());
			uvArray[i].Add(new Vector2(list[i], 0f));
			num = 0f;
			for (int j = 1; j < vecArray[i].Count; j++)
			{
				num += Vector3.Distance(vecArray[i][j - 1], vecArray[i][j]);
				uvArray[i].Add(new Vector2(list[i], num / num2));
			}
		}
	}

	public static void ODQOQOCCOC(List<List<Vector3>> vecArray, ref List<float> sidewalkUVs)
	{
		sidewalkUVs.Clear();
		List<float> list = new List<float>();
		list.Add(0f);
		float num = 0f;
		for (int i = 1; i < vecArray.Count; i++)
		{
			num += Vector3.Distance(vecArray[i - 1][0], vecArray[i][0]);
			list.Add(num);
		}
		for (int j = 0; j < list.Count; j++)
		{
			sidewalkUVs.Add(list[j] / num);
		}
	}

	public static void ODDCDODCCQ(ref List<List<Vector3>> outer1, ref List<List<Vector3>> outer2)
	{
		for (int i = 0; i < outer1.Count; i++)
		{
			if (outer1[i][outer1[i].Count - 1] != outer2[i][outer2[i].Count - 1])
			{
				Vector3 vector = ODQDQDQDQO.OODOQDOODO(outer1[i][outer1[i].Count - 1], outer1[i][outer1[i].Count - 2], outer2[i][outer2[i].Count - 1], outer2[i][outer2[i].Count - 2], flag: false);
				List<Vector3> list = outer1[i];
				int index = outer1[i].Count - 1;
				Vector3 value = (outer2[i][outer2[i].Count - 1] = vector);
				list[index] = value;
			}
		}
	}
}
[AddComponentMenu("")]
public class OQOQCCCDDQ : MonoBehaviour
{
	public static void OQDCOQDQDO(ERCrossings scr, ref List<Vector3> meshVecs, ref List<Vector2> meshUVs, ref List<List<int>> triList, ref List<Material> materialList)
	{
		List<int> normalInts = new List<int>();
		List<int> normalIntsStart = new List<int>();
		if (scr.prefabScript.sidewalkControlElements[1].renderFlag)
		{
			OQCQDDDOQD(scr, scr.leftSidewalkStartV3, scr.leftSidewalkStartUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.leftSidewalkStartTris, ref materialList, reverse: true, scr.prefabScript.sidewalkControlElements[0], scr.leftStartSidewalkCornerInt, ref normalInts, ref normalIntsStart);
			OODODOQDCC.OQDDOCOOOO(scr, 0, scr.leftSidewalkStartV3, 0);
			scr.OCCODQDOQOStart.AddRange(normalIntsStart);
			scr.OCCODQDOQO.AddRange(normalInts);
			if (!scr.tCrossing || scr.tCrossingLeftRight == 0)
			{
				OQCQDDDOQD(scr, scr.rightSidewalkLeftV3, scr.rightSidewalkLeftUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.rightSidewalkLeftTris, ref materialList, reverse: false, scr.prefabScript.sidewalkControlElements[0], scr.rightLeftSidewalkCornerInt, ref normalInts, ref normalIntsStart);
				OODODOQDCC.OQDDOCOOOO(scr, 2, scr.rightSidewalkLeftV3, 0);
				scr.ODOQODQODOStart.AddRange(normalIntsStart);
				scr.ODOQODQODO.AddRange(normalInts);
			}
			else if (scr.tCrossing)
			{
				OQCQDDDOQD(scr, scr.rightSidewalkEndV3, scr.rightSidewalkEndUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.rightSidewalkEndTris, ref materialList, reverse: false, scr.prefabScript.sidewalkControlElements[0], scr.rightEndSidewalkCornerInt, ref normalInts, ref normalIntsStart);
				OODODOQDCC.OQDDOCOOOO(scr, 1, scr.rightSidewalkEndV3, 1);
				scr.ODOQODQODOStart.AddRange(normalIntsStart);
				scr.ODOQODQODO.AddRange(normalInts);
			}
		}
		if (scr.prefabScript.sidewalkControlElements[0].renderFlag)
		{
			OQCQDDDOQD(scr, scr.rightSidewalkStartV3, scr.rightSidewalkStartUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.rightSidewalkStartTris, ref materialList, reverse: false, scr.prefabScript.sidewalkControlElements[1], scr.rightStartSidewalkCornerInt, ref normalInts, ref normalIntsStart);
			OODODOQDCC.OQDDOCOOOO(scr, 0, scr.rightSidewalkStartV3, 1);
			scr.OOQODQDOQCStart.AddRange(normalIntsStart);
			scr.OOQODQDOQC.AddRange(normalInts);
			if (!scr.tCrossing || scr.tCrossingLeftRight == 1)
			{
				OQCQDDDOQD(scr, scr.leftSidewalkRightV3, scr.leftSidewalkRightUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.leftSidewalkRightTris, ref materialList, reverse: true, scr.prefabScript.sidewalkControlElements[1], scr.leftRightSidewalkCornerInt, ref normalInts, ref normalIntsStart);
				OODODOQDCC.OQDDOCOOOO(scr, 3, scr.leftSidewalkRightV3, 0);
				scr.OOOQCQDOCDStart.AddRange(normalIntsStart);
				scr.OOOQCQDOCD.AddRange(normalInts);
			}
			else if (scr.tCrossing)
			{
				OQCQDDDOQD(scr, scr.leftSidewalkEndV3, scr.leftSidewalkEndUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.leftSidewalkEndTris, ref materialList, reverse: true, scr.prefabScript.sidewalkControlElements[1], scr.leftEndSidewalkCornerInt, ref normalInts, ref normalIntsStart);
				OODODOQDCC.OQDDOCOOOO(scr, 1, scr.leftSidewalkEndV3, 0);
				scr.OOOQCQDOCDStart.AddRange(normalIntsStart);
				scr.OOOQCQDOCD.AddRange(normalInts);
			}
		}
		if ((!scr.tCrossing || scr.tCrossingLeftRight == 1) && scr.prefabScript.sidewalkControlElements[3].renderFlag)
		{
			OQCQDDDOQD(scr, scr.leftSidewalkEndV3, scr.leftSidewalkEndUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.leftSidewalkEndTris, ref materialList, reverse: true, scr.prefabScript.sidewalkControlElements[3], scr.leftEndSidewalkCornerInt, ref normalInts, ref normalIntsStart);
			OODODOQDCC.OQDDOCOOOO(scr, 1, scr.leftSidewalkEndV3, 0);
			scr.OQDQOQOCQDStart.AddRange(normalIntsStart);
			scr.OQDQOQOCQD.AddRange(normalInts);
			if (!scr.tCrossing || scr.tCrossingLeftRight == 1)
			{
				OQCQDDDOQD(scr, scr.rightSidewalkRightV3, scr.rightSidewalkRightUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.rightSidewalkRightTris, ref materialList, reverse: false, scr.prefabScript.sidewalkControlElements[3], scr.rightRightSidewalkCornerInt, ref normalInts, ref normalIntsStart);
				OODODOQDCC.OQDDOCOOOO(scr, 3, scr.rightSidewalkRightV3, 1);
				scr.OQCDOOCDCDStart.AddRange(normalIntsStart);
				scr.OQCDOOCDCD.AddRange(normalInts);
			}
		}
		if ((!scr.tCrossing || scr.tCrossingLeftRight == 0) && scr.prefabScript.sidewalkControlElements[2].renderFlag)
		{
			OQCQDDDOQD(scr, scr.rightSidewalkEndV3, scr.rightSidewalkEndUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.rightSidewalkEndTris, ref materialList, reverse: false, scr.prefabScript.sidewalkControlElements[2], scr.rightEndSidewalkCornerInt, ref normalInts, ref normalIntsStart);
			OODODOQDCC.OQDDOCOOOO(scr, 1, scr.rightSidewalkEndV3, 1);
			scr.OQCCQOCQDQStart.AddRange(normalIntsStart);
			scr.OQCCQOCQDQ.AddRange(normalInts);
			if (!scr.tCrossing || scr.tCrossingLeftRight == 0)
			{
				OQCQDDDOQD(scr, scr.leftSidewalkLeftV3, scr.leftSidewalkLeftUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.leftSidewalkLeftTris, ref materialList, reverse: true, scr.prefabScript.sidewalkControlElements[2], scr.leftLeftSidewalkCornerInt, ref normalInts, ref normalIntsStart);
				OODODOQDCC.OQDDOCOOOO(scr, 2, scr.leftSidewalkLeftV3, 0);
				scr.ODQDCCQOQDStart.AddRange(normalIntsStart);
				scr.ODQDCCQOQD.AddRange(normalInts);
			}
		}
		if (scr.prefabScript.sidewalkControlElements[1].renderFlag && !scr.prefabScript.crossingElements[0].includeLeftSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[0], scr.leftSidewalkStartV3, scr.leftSidewalkStartUV, scr.leftSidewalkStartTris, ref meshVecs, ref meshUVs, ref triList, materialList, 0);
		}
		if (scr.prefabScript.sidewalkControlElements[0].renderFlag && !scr.prefabScript.crossingElements[0].includeRightSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[1], scr.rightSidewalkStartV3, scr.rightSidewalkStartUV, scr.rightSidewalkStartTris, ref meshVecs, ref meshUVs, ref triList, materialList, 1);
		}
		if (!scr.tCrossing || scr.tCrossingLeftRight == 0)
		{
			if (scr.prefabScript.sidewalkControlElements[2].renderFlag && !scr.prefabScript.crossingElements[1].includeRightSidewalk)
			{
				OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[2], scr.rightSidewalkEndV3, scr.rightSidewalkEndUV, scr.rightSidewalkEndTris, ref meshVecs, ref meshUVs, ref triList, materialList, 1);
			}
		}
		else if (scr.prefabScript.sidewalkControlElements[1].renderFlag && !scr.prefabScript.crossingElements[1].includeRightSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[1], scr.rightSidewalkEndV3, scr.rightSidewalkEndUV, scr.rightSidewalkEndTris, ref meshVecs, ref meshUVs, ref triList, materialList, 1);
		}
		if (!scr.tCrossing || scr.tCrossingLeftRight == 1)
		{
			if (scr.prefabScript.sidewalkControlElements[3].renderFlag && !scr.prefabScript.crossingElements[1].includeLeftSidewalk)
			{
				OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[3], scr.leftSidewalkEndV3, scr.leftSidewalkEndUV, scr.leftSidewalkEndTris, ref meshVecs, ref meshUVs, ref triList, materialList, 0);
			}
		}
		else if (scr.prefabScript.sidewalkControlElements[0].renderFlag && !scr.prefabScript.crossingElements[1].includeLeftSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[3], scr.leftSidewalkEndV3, scr.leftSidewalkEndUV, scr.leftSidewalkEndTris, ref meshVecs, ref meshUVs, ref triList, materialList, 0);
		}
		if (scr.prefabScript.sidewalkControlElements[2].renderFlag && (!scr.tCrossing || scr.tCrossingLeftRight == 0) && !scr.prefabScript.crossingElements[2].includeLeftSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[2], scr.leftSidewalkLeftV3, scr.leftSidewalkLeftUV, scr.leftSidewalkLeftTris, ref meshVecs, ref meshUVs, ref triList, materialList, 0);
		}
		if (scr.prefabScript.sidewalkControlElements[1].renderFlag && (!scr.tCrossing || scr.tCrossingLeftRight == 0) && !scr.prefabScript.crossingElements[2].includeRightSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[0], scr.rightSidewalkLeftV3, scr.rightSidewalkLeftUV, scr.rightSidewalkLeftTris, ref meshVecs, ref meshUVs, ref triList, materialList, 1);
		}
		if (scr.prefabScript.sidewalkControlElements[0].renderFlag && (!scr.tCrossing || scr.tCrossingLeftRight == 1) && !scr.prefabScript.crossingElements[3].includeLeftSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[1], scr.leftSidewalkRightV3, scr.leftSidewalkRightUV, scr.leftSidewalkRightTris, ref meshVecs, ref meshUVs, ref triList, materialList, 0);
		}
		if (scr.prefabScript.sidewalkControlElements[3].renderFlag && (!scr.tCrossing || scr.tCrossingLeftRight == 1) && !scr.prefabScript.crossingElements[3].includeRightSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[3], scr.rightSidewalkRightV3, scr.rightSidewalkRightUV, scr.rightSidewalkRightTris, ref meshVecs, ref meshUVs, ref triList, materialList, 1);
		}
	}

	public static void OQCDQOQCOQ(ERRoundabouts scr, ref List<Vector3> meshVecs, ref List<Vector2> meshUVs, ref List<List<int>> triList, ref List<Material> materialList)
	{
		for (int i = 0; i < scr.connections.Count; i++)
		{
			int num = i;
			num = ((scr.connections.Count > i + 1) ? (num + 1) : 0);
			if (scr.prefabScript.sidewalkControlElements[num].renderFlag)
			{
				OQOCDQDDCO(scr, scr.connections[i].leftSidewalkV3, scr.connections[i].leftSidewalkUV, 0, 0, ref meshVecs, ref scr.connections[i].leftSidewalkNormalsStart, ref scr.connections[i].leftSidewalkNormalsEnd, ref meshUVs, ref triList, ref scr.connections[i].leftSidewalkTris, ref materialList, reverse: true, scr.prefabScript.sidewalkControlElements[num], -1);
				if (!scr.prefabScript.crossingElements[i].includeLeftSidewalk)
				{
					OQCODDOCCD(null, scr.prefabScript.sidewalkControlElements[num], scr.connections[i].leftSidewalkV3, scr.connections[i].leftSidewalkUV, scr.connections[i].leftSidewalkTris, ref meshVecs, ref meshUVs, ref triList, materialList, 0);
				}
			}
			num = i;
			if (scr.prefabScript.sidewalkControlElements[i].renderFlag)
			{
				OQOCDQDDCO(scr, scr.connections[i].rightSidewalkV3, scr.connections[i].rightSidewalkUV, 0, 0, ref meshVecs, ref scr.connections[i].rightSidewalkNormalsStart, ref scr.connections[i].rightSidewalkNormalsEnd, ref meshUVs, ref triList, ref scr.connections[i].rightSidewalkTris, ref materialList, reverse: false, scr.prefabScript.sidewalkControlElements[num], -1);
				if (!scr.prefabScript.crossingElements[i].includeRightSidewalk)
				{
					OQCODDOCCD(null, scr.prefabScript.sidewalkControlElements[i], scr.connections[i].rightSidewalkV3, scr.connections[i].rightSidewalkUV, scr.connections[i].rightSidewalkTris, ref meshVecs, ref meshUVs, ref triList, materialList, 1);
				}
			}
		}
	}

	public static void OQCCQQOCCO(ERRoundabouts scr, List<Vector3> vecs, List<Vector2> uvs, List<int> tris, ref List<Vector3> meshVecs, ref List<Vector2> meshUVs, ref List<List<int>> triList, ref List<Material> materialList)
	{
		int index = 0;
		for (int i = 0; i < materialList.Count; i++)
		{
			if (materialList[i] == scr.innerRoundaboutSidewalkMaterial)
			{
				index = i;
			}
		}
		int count = meshVecs.Count;
		for (int j = 0; j < vecs.Count; j++)
		{
			meshVecs.Add(vecs[j]);
			meshUVs.Add(uvs[j]);
			if (j < scr.innerSidewalkSegments)
			{
				scr.innerRoundaboutSidewalkIntsStart.Add(meshVecs.Count - 1);
			}
		}
		for (int k = 0; k < scr.innerSidewalkSegments; k++)
		{
			scr.innerRoundaboutSidewalkIntsEnd.Add(meshVecs.Count - scr.innerSidewalkSegments + k);
		}
		List<int> list = new List<int>();
		for (int l = 0; l < tris.Count; l++)
		{
			list.Add(count + tris[l]);
			if (tris[l] > vecs.Count - 1)
			{
				UnityEngine.Debug.Log(tris[l] + " > " + (vecs.Count - 1));
			}
		}
		triList[index].AddRange(list);
	}

	public static void OQCQDDDOQD(ERCrossings scr, List<List<Vector3>> vecArray, List<List<Vector2>> uvArray, int frontLeft, int topBottom, ref List<Vector3> meshVecs, ref List<Vector2> meshUVs, ref List<List<int>> triList, ref List<List<int>> intArray, ref List<Material> materialList, bool reverse, QDOQDSQOOQDDD corner, int outerCornerInt, ref List<int> normalInts, ref List<int> normalIntsStart)
	{
		normalInts.Clear();
		normalIntsStart.Clear();
		int triArrayElement = 0;
		ODOOOODDOO(ref materialList, ref triList, corner.sidewalkMaterial, ref triArrayElement);
		int num = meshVecs.Count;
		for (int i = 0; i < vecArray.Count; i++)
		{
			intArray.Add(new List<int>());
			for (int j = 0; j < vecArray[i].Count; j++)
			{
				meshVecs.Add(vecArray[i][j]);
				meshUVs.Add(uvArray[i][j]);
				if (j == 0)
				{
					normalIntsStart.Add(num);
				}
				if (j == vecArray[i].Count - 1)
				{
					normalInts.Add(num);
				}
				intArray[i].Add(num);
				num++;
			}
		}
		for (int k = 0; k < intArray.Count - 1; k++)
		{
			if (!reverse)
			{
				triList[triArrayElement].AddRange(OCCQOODCCO(intArray[k], intArray[k + 1]));
			}
			else
			{
				triList[triArrayElement].AddRange(OCCQOODCCO(intArray[k + 1], intArray[k]));
			}
		}
		if (corner.beveledCurb)
		{
			if (corner.beveledHeight == 0f && corner.beveledDepth == 0f)
			{
				triList[triArrayElement].AddRange(OODOODOQOO(intArray[2][outerCornerInt - 1], intArray[1], outerCornerInt - 1, !reverse));
			}
			else if (corner.beveledHeight == 0f || corner.beveledDepth == 0f)
			{
				triList[triArrayElement].AddRange(OODOODOQOO(intArray[3][outerCornerInt - 1], intArray[2], outerCornerInt - 1, !reverse));
			}
			else
			{
				triList[triArrayElement].AddRange(OODOODOQOO(intArray[4][outerCornerInt - 1], intArray[3], outerCornerInt - 1, !reverse));
			}
		}
		else
		{
			triList[triArrayElement].AddRange(OODOODOQOO(intArray[3][outerCornerInt - 1], intArray[2], outerCornerInt - 1, !reverse));
		}
	}

	public static void OQOCDQDDCO(ERRoundabouts scr, List<List<Vector3>> vecArray, List<List<Vector2>> uvArray, int frontLeft, int topBottom, ref List<Vector3> meshVecs, ref List<int> startNormalInts, ref List<int> endNormalInts, ref List<Vector2> meshUVs, ref List<List<int>> triList, ref List<List<int>> intArray, ref List<Material> materialList, bool reverse, QDOQDSQOOQDDD corner, int outerCornerInt)
	{
		int triArrayElement = 0;
		ODOOOODDOO(ref materialList, ref triList, corner.sidewalkMaterial, ref triArrayElement);
		startNormalInts.Clear();
		endNormalInts.Clear();
		int num = meshVecs.Count;
		for (int i = 0; i < vecArray.Count; i++)
		{
			intArray.Add(new List<int>());
			for (int j = 0; j < vecArray[i].Count; j++)
			{
				meshVecs.Add(vecArray[i][j]);
				meshUVs.Add(uvArray[i][j]);
				if (j == 0)
				{
					startNormalInts.Add(num);
				}
				if (j == vecArray[i].Count - 1)
				{
					endNormalInts.Add(num);
				}
				intArray[i].Add(num);
				num++;
			}
		}
		for (int k = 0; k < intArray.Count - 1; k++)
		{
			if (!reverse)
			{
				triList[triArrayElement].AddRange(OCCQOODCCO(intArray[k], intArray[k + 1]));
			}
			else
			{
				triList[triArrayElement].AddRange(OCCQOODCCO(intArray[k + 1], intArray[k]));
			}
		}
	}

	public static List<int> OCCQOODCCO(List<int> col1, List<int> col2)
	{
		List<int> list = new List<int>();
		int count = col1.Count;
		if (col2.Count < col1.Count)
		{
			count = col2.Count;
		}
		for (int i = 0; i < count - 1; i++)
		{
			list.Add(col1[i]);
			list.Add(col2[i + 1]);
			list.Add(col2[i]);
			list.Add(col1[i + 1]);
			list.Add(col2[i + 1]);
			list.Add(col1[i]);
		}
		return list;
	}

	public static List<int> OODOODOQOO(int outerPoint, List<int> innerCol, int startPoint, bool reverse)
	{
		List<int> list = new List<int>();
		for (int i = startPoint; i < innerCol.Count - 1; i++)
		{
			if (!reverse)
			{
				list.Add(outerPoint);
				list.Add(innerCol[i + 1]);
				list.Add(innerCol[i]);
			}
			else
			{
				list.Add(outerPoint);
				list.Add(innerCol[i]);
				list.Add(innerCol[i + 1]);
			}
		}
		return list;
	}

	public static void OQCODDOCCD(ERCrossings scr, QDOQDSQOOQDDD corner, List<List<Vector3>> sourceVecs, List<List<Vector2>> sourceUVs, List<List<int>> sourceTris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<List<int>> triList, List<Material> materialList, int leftrightroad)
	{
		int triArrayElement = 0;
		ODOOOODDOO(ref materialList, ref triList, corner.sidewalkMaterial, ref triArrayElement);
		if (corner.outerCurb)
		{
			if (!corner.beveledCurb)
			{
				OOQOQOODQC.OCDCCCCCCQ(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
			}
			else if (corner.beveledHeight > 0f && corner.beveledDepth > 0f)
			{
				OOQOQOODQC.ODCQCQQQCQ(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
			}
			else if (corner.beveledHeight > 0f)
			{
				OOQOQOODQC.OQDDCCCQQQ(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
			}
			else if (corner.beveledDepth > 0f)
			{
				OOQOQOODQC.OODCCQQDOO(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
			}
			else
			{
				OOQOQOODQC.OQCDQQODOD(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
			}
		}
		else if (!corner.beveledCurb)
		{
			OOQOQOODQC.OCQDQCQDCC(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, 0, hardEdge: false);
		}
		else if (corner.beveledHeight > 0f && corner.beveledDepth > 0f)
		{
			OOQOQOODQC.ODOODOCDOD(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
		}
		else if (corner.beveledHeight > 0f)
		{
			OOQOQOODQC.OODDQQQDDQ(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
		}
		else if (corner.beveledDepth > 0f)
		{
			OOQOQOODQC.OCCDCDCODO(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
		}
		else
		{
			OOQOQOODQC.ODOQCDCCOQ(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
		}
	}

	public static void OOCQCDDQOD()
	{
	}

	public static void ODOOOODDOO(ref List<Material> materialList, ref List<List<int>> triList, Material sidewalkMaterial, ref int triArrayElement)
	{
		for (int i = 0; i < materialList.Count; i++)
		{
			if (materialList[i] == sidewalkMaterial)
			{
				triArrayElement = i;
				return;
			}
		}
		materialList.Add(sidewalkMaterial);
		triList.Add(new List<int>());
		triArrayElement = materialList.Count - 1;
	}
}
[AddComponentMenu("")]
public class OQQCCQCDQQ : MonoBehaviour
{
	[HideInInspector]
	public QDQDOOQQDQODD roadType;

	[HideInInspector]
	public double roadTypeID;

	[HideInInspector]
	public int roadTypeIndex;

	[HideInInspector]
	public int geometryType;

	[HideInInspector]
	public ERExitType exitType = ERExitType.RightExit;

	[HideInInspector]
	public float offset = 0f;

	[HideInInspector]
	public int halfwayIndex = 0;

	[HideInInspector]
	public int startSplineIndex = 0;

	[HideInInspector]
	public int endSplineIndex = 0;

	[HideInInspector]
	public Vector3 endSplinePointRight;

	[HideInInspector]
	public Vector3 endSplinePointLeft;

	[HideInInspector]
	public float startDistance = 0f;

	[HideInInspector]
	public float endDistance = 0f;

	[HideInInspector]
	public int markerIndex = 0;

	[HideInInspector]
	public int extrusionType = 0;

	[HideInInspector]
	public AnimationCurve extrusionCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	[HideInInspector]
	public float extrusionDistance = 10f;

	[HideInInspector]
	public int startDistanceIndex = 0;

	[HideInInspector]
	public float startDecalDistance = 0f;

	[HideInInspector]
	public float fixedDistance = 5f;

	[HideInInspector]
	public int fixedDistanceIndex = 0;

	[HideInInspector]
	public float splitDistance = 5f;

	[HideInInspector]
	public AnimationCurve splitCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	[HideInInspector]
	public float splitEndWidth = 0f;

	[HideInInspector]
	public float connectionAngle = 25f;

	[HideInInspector]
	public float connectionRadius = 10f;

	[HideInInspector]
	public ERModularRoad road;

	[HideInInspector]
	public ERCrossingPrefabs connector;

	[HideInInspector]
	public Vector3 connectionHandlePosition;

	[HideInInspector]
	public Vector3 OCODOQDODQ;

	[HideInInspector]
	public Vector3 handleDirection;

	[HideInInspector]
	public GameObject surfaceMesh;

	[HideInInspector]
	public GameObject exitSignObject;

	[HideInInspector]
	public float exitSignObjectOffset;

	[HideInInspector]
	public GameObject exitSignObjectInstance;

	[HideInInspector]
	public GameObject exitSplitSpawnObject;

	[HideInInspector]
	public int exitSplitSpawnType = 0;

	[HideInInspector]
	public float exitSplitSpawnDistance = 1f;

	[HideInInspector]
	public float exitSplitSpawnStartOffset = 0f;

	[HideInInspector]
	public float exitSplitSpawnOffset = 0f;

	[HideInInspector]
	public float exitSplitSpawnObjectBounds;

	[HideInInspector]
	public List<GameObject> spawnedSplitObjects = new List<GameObject>();

	[HideInInspector]
	public List<Vector3> soPointsRightStart = new List<Vector3>();

	[HideInInspector]
	public int soRightSplitEndIndex = 0;

	[HideInInspector]
	public List<Vector3> soPointsLeftStart = new List<Vector3>();

	[HideInInspector]
	public int startLineMarkingDecal = 0;

	[HideInInspector]
	public bool startDecalFoldout = false;

	[HideInInspector]
	public int splitLineMarkingDecal1 = 0;

	[HideInInspector]
	public bool splitDecal1Foldout = false;

	[HideInInspector]
	public int splitLineMarkingDecal2 = 0;

	[HideInInspector]
	public bool splitDecal2Foldout = false;

	[HideInInspector]
	public List<Vector3> edgeVecs = new List<Vector3>();

	[HideInInspector]
	public List<Vector3> vecs = new List<Vector3>();

	[HideInInspector]
	public List<Vector2> uvsArray = new List<Vector2>();

	[HideInInspector]
	public List<Vector2> uvsArray2 = new List<Vector2>();

	[HideInInspector]
	public List<Color> customColors = new List<Color>();

	[HideInInspector]
	public List<Color> colors = new List<Color>();

	[HideInInspector]
	public List<int> tris = new List<int>();

	[HideInInspector]
	private int á = 0;

	[HideInInspector]
	private int á = 0;

	[HideInInspector]
	private int á = 0;

	[HideInInspector]
	private List<Vector3> 4AAAA = new List<Vector3>();

	[HideInInspector]
	private List<Vector3> 5AAA1 = new List<Vector3>();

	[HideInInspector]
	private List<Vector3> 6AAAA = new List<Vector3>();

	[HideInInspector]
	private List<float> 7AAA1 = new List<float>();

	[HideInInspector]
	private List<Vector3> 8AAAA = new List<Vector3>();

	[HideInInspector]
	private Vector3 9AAA1;

	[HideInInspector]
	private float BAAAA;

	[HideInInspector]
	private float CAAA1;

	[HideInInspector]
	private float 00AAA;

	[HideInInspector]
	private float 10AA1;

	[HideInInspector]
	private int 20AAA = 0;

	[HideInInspector]
	private int 30AA1 = 0;

	[HideInInspector]
	public List<Vector3> treeVecs = new List<Vector3>();

	[HideInInspector]
	public List<Vector3> detailVecs = new List<Vector3>();

	public static void OOOCDQDQDC(List<ERMarkerExt> markers, List<OQQCCQCDQQ> exitRoads, ref List<Vector3> splinePoints, ref List<float> tValues)
	{
		int currentInt = -1;
		for (int i = 0; i < exitRoads.Count; i++)
		{
			if (exitRoads[i] == null)
			{
				exitRoads.RemoveAt(i);
				i--;
				UnityEngine.Debug.Log("EasyRoads3Dv3 Warning: exit road is null, this exit road instance has been removed");
				continue;
			}
			ODOCDDDDDO(markers, exitRoads[i], ref splinePoints, ref tValues, currentInt);
			markers[i].exitInnerVertices.Clear();
			if (exitRoads[i].startSplineIndex != -1)
			{
				currentInt = exitRoads[i].endSplineIndex;
				continue;
			}
			UnityEngine.Debug.LogWarning("An exit road is attached to the preious marker and overlaps the current marker, marker: " + (i + 1));
			exitRoads.RemoveAt(i);
			i--;
		}
	}

	public static void ODOCDDDDDO(List<ERMarkerExt> markers, OQQCCQCDQQ exitRoad, ref List<Vector3> splinePoints, ref List<float> tValues, int currentInt)
	{
		ERMarkerExt eRMarkerExt = markers[exitRoad.markerIndex];
		float num = exitRoad.extrusionDistance + exitRoad.fixedDistance + exitRoad.splitDistance;
		float num2 = exitRoad.extrusionDistance + exitRoad.fixedDistance;
		if (exitRoad.offset < 0f && exitRoad.markerIndex == 0)
		{
			exitRoad.offset = 0.5f;
		}
		float num3 = eRMarkerExt.totalDistance * exitRoad.offset;
		float num4 = num3 - 0.5f * num;
		float num5 = 0f;
		float num6 = 0f;
		bool flag = false;
		if (num4 < 0f)
		{
			num4 *= -1f;
			for (int num7 = eRMarkerExt.startSplinePoint - 2; num7 >= 0; num7--)
			{
				num6 = Vector3.Distance(splinePoints[num7], splinePoints[num7 + 1]);
				if (num5 + num6 > num4)
				{
					float t = (num4 - num5) / num6;
					Vector3 vector = Vector3.Lerp(splinePoints[num7 + 1], splinePoints[num7], t);
					float num8;
					if (tValues[num7 + 1] < tValues[num7])
					{
						num8 = Mathf.Lerp(1f + tValues[num7 + 1], tValues[num7], t);
						if (num8 > 1f)
						{
							num8 -= 1f;
						}
					}
					else
					{
						num8 = Mathf.Lerp(tValues[num7 + 1], tValues[num7], t);
					}
					float num9 = Vector3.Distance(splinePoints[num7], vector);
					if ((double)num9 < 0.25)
					{
						splinePoints[num7] = vector;
						tValues[num7] = num8;
						exitRoad.startSplineIndex = num7;
					}
					else
					{
						num9 = Vector3.Distance(splinePoints[num7 + 1], vector);
						if ((double)num9 < 0.25)
						{
							splinePoints[num7 + 1] = vector;
							tValues[num7 + 1] = num8;
						}
						else
						{
							splinePoints.Insert(num7 + 1, vector);
							tValues.Insert(num7 + 1, num8);
						}
						exitRoad.startSplineIndex = num7 + 1;
					}
					flag = true;
					break;
				}
				if (num7 <= currentInt)
				{
					exitRoad.startSplineIndex = -1;
					UnityEngine.Debug.LogWarning("The start offset overlaps the previous exit lane!");
					return;
				}
				num5 += num6;
			}
			if (!flag)
			{
				exitRoad.startSplineIndex = -1;
			}
		}
		else if (num4 > 0f)
		{
			flag = false;
			int num10 = eRMarkerExt.startSplinePoint - 1;
			if (num10 < 0)
			{
				num10 = 0;
			}
			for (int i = num10; i < splinePoints.Count - 1; i++)
			{
				num6 = Vector3.Distance(splinePoints[i], splinePoints[i + 1]);
				if (num5 + num6 > num4)
				{
					float t2 = (num4 - num5) / num6;
					Vector3 vector = Vector3.Lerp(splinePoints[i], splinePoints[i + 1], t2);
					float num8 = Mathf.Lerp(tValues[i], tValues[i + 1], t2);
					if (tValues[i + 1] < tValues[i])
					{
						num8 = Mathf.Lerp(tValues[i], 1f + tValues[i + 1], t2);
						if (num8 > 1f)
						{
							num8 -= 1f;
						}
					}
					else
					{
						num8 = Mathf.Lerp(tValues[i], tValues[i + 1], t2);
					}
					float num11 = Vector3.Distance(splinePoints[i], vector);
					if ((double)num11 < 0.25)
					{
						splinePoints[i] = vector;
						tValues[i] = num8;
						exitRoad.startSplineIndex = i;
					}
					else
					{
						num11 = Vector3.Distance(splinePoints[i + 1], vector);
						if ((double)num11 < 0.25)
						{
							splinePoints[i + 1] = vector;
							tValues[i + 1] = num8;
						}
						else
						{
							splinePoints.Insert(i + 1, vector);
							tValues.Insert(i + 1, num8);
						}
						exitRoad.startSplineIndex = i + 1;
					}
					flag = true;
					if (exitRoad.startSplineIndex <= currentInt)
					{
						exitRoad.startSplineIndex = 1;
						UnityEngine.Debug.LogWarning("The start offset overlaps the previous exit lane!");
						return;
					}
					break;
				}
				num5 += num6;
			}
		}
		else
		{
			eRMarkerExt.startExitInt = eRMarkerExt.startSplinePoint - 1;
			exitRoad.startSplineIndex = eRMarkerExt.startSplinePoint - 1;
			flag = true;
		}
		if (!flag)
		{
			exitRoad.startSplineIndex = 1;
			UnityEngine.Debug.LogWarning("The start offset extends the road length!");
		}
		num5 = 0f;
		flag = false;
		bool flag2 = false;
		bool flag3 = false;
		int num12 = 0;
		for (int j = exitRoad.startSplineIndex; j < splinePoints.Count - 1; j++)
		{
			num6 = Vector3.Distance(splinePoints[j], splinePoints[j + 1]);
			if (!flag2 && num5 + num6 > exitRoad.extrusionDistance)
			{
				if (num5 + num6 - exitRoad.extrusionDistance > 1f)
				{
					if (exitRoad.extrusionDistance - num5 > 1f)
					{
						Vector3 normalized = (splinePoints[j + 1] - splinePoints[j]).normalized;
						float num13 = exitRoad.extrusionDistance - num5;
						Vector3 vector = splinePoints[j] + normalized * num13;
						splinePoints.Insert(j + 1, splinePoints[j] + normalized * num13);
						float num14 = tValues[j + 1];
						if (num14 < tValues[j])
						{
							num14 += 1f;
						}
						tValues.Insert(j + 1, Mathf.Lerp(tValues[j], num14, num13 / num6));
						exitRoad.startDistanceIndex = j + 1;
					}
					else
					{
						exitRoad.startDistanceIndex = j;
					}
				}
				else
				{
					exitRoad.startDistanceIndex = j + 1;
				}
				if (exitRoad.fixedDistance == 0f)
				{
					exitRoad.fixedDistanceIndex = exitRoad.startDistanceIndex;
					flag3 = true;
				}
				flag2 = true;
				num6 = Vector3.Distance(splinePoints[j], splinePoints[j + 1]);
			}
			if (!flag3 && flag2 && num5 + num6 > num2)
			{
				if (num5 + num6 - num2 > 1f)
				{
					if (num2 - num5 > 1f)
					{
						Vector3 normalized2 = (splinePoints[j + 1] - splinePoints[j]).normalized;
						float num15 = num2 - num5;
						Vector3 vector = splinePoints[j] + normalized2 * num15;
						splinePoints.Insert(j + 1, splinePoints[j] + normalized2 * num15);
						float num16 = tValues[j + 1];
						if (num16 < tValues[j])
						{
							num16 += 1f;
						}
						tValues.Insert(j + 1, Mathf.Lerp(tValues[j], num16, num15 / num6));
						exitRoad.fixedDistanceIndex = j + 1;
					}
					else
					{
						exitRoad.fixedDistanceIndex = j;
					}
				}
				else
				{
					exitRoad.fixedDistanceIndex = j + 1;
				}
				num6 = Vector3.Distance(splinePoints[j], splinePoints[j + 1]);
				flag3 = true;
			}
			num12++;
			if (num5 + num6 > num)
			{
				float t3 = (num - num5) / num6;
				Vector3 vector = Vector3.Lerp(splinePoints[j], splinePoints[j + 1], t3);
				float num8;
				if (tValues[j + 1] < tValues[j])
				{
					num8 = Mathf.Lerp(tValues[j], 1f + tValues[j + 1], t3);
					if (num8 > 1f)
					{
						num8 -= 1f;
					}
				}
				else
				{
					num8 = Mathf.Lerp(tValues[j], tValues[j + 1], t3);
				}
				float num17 = Vector3.Distance(splinePoints[j], vector);
				if ((double)num17 < 0.25)
				{
					splinePoints[j] = vector;
					tValues[j] = num8;
					exitRoad.endSplineIndex = j;
				}
				else
				{
					num17 = Vector3.Distance(splinePoints[j + 1], vector);
					if ((double)num17 < 0.25)
					{
						splinePoints[j + 1] = vector;
						tValues[j + 1] = num8;
					}
					else
					{
						splinePoints.Insert(j + 1, vector);
						tValues.Insert(j + 1, num8);
					}
					exitRoad.endSplineIndex = j + 1;
				}
				flag = true;
				break;
			}
			num5 += num6;
		}
		if (!flag)
		{
			exitRoad.endSplineIndex = splinePoints.Count - 2;
		}
	}

	public static void OQCCQOQDDO(ERModularBase baseScript, ERModularRoad road, List<OQQCCQCDQQ> exitRoads, List<ERMarkerExt> markers, ref List<Vector3> soSplinePointsLeft, ref List<Vector3> soSplinePointsRight, ref bool hasExits, List<float> leftIndentFloats, List<float> rightIndentFloats, List<float> leftSurroundingFloats, List<float> rightSurroundingFloats, ref List<Vector3> surfaceVecs)
	{
		for (int i = 0; i < exitRoads.Count; i++)
		{
			OCCCOOCCQC(baseScript, road, exitRoads[i], ref soSplinePointsLeft, ref soSplinePointsRight, leftIndentFloats, rightIndentFloats, leftSurroundingFloats, rightSurroundingFloats, ref surfaceVecs);
			hasExits = true;
			if (exitRoads[i].connector != null && exitRoads[i].connector.crossingElements.Count > 0 && exitRoads[i].connector.crossingElements[0].connectedRoad != null)
			{
				exitRoads[i].connector.crossingElements[0].connectedRoad.OCQOQCDCQC(ignorePrefabAlignment: true, forceAutoRotate: false);
			}
		}
	}

	public static void OCCCOOCCQC(ERModularBase baseScript, ERModularRoad road, OQQCCQCDQQ exitRoad, ref List<Vector3> soSplinePointsLeft, ref List<Vector3> soSplinePointsRight, List<float> leftIndentFloats, List<float> rightIndentFloats, List<float> leftSurroundingFloats, List<float> rightSurroundingFloats, ref List<Vector3> roadSurfaceVecs)
	{
		UnityEngine.Debug.Log("To Do: optional and necessary for two lane ramps. add vec twice at right outerlane index. instead of calculating uvs from right to left according shape, calculate from left (start value) to right over distance, that way the middle lane will be in the center");
		List<List<Vector3>> list = new List<List<Vector3>>();
		List<List<Vector2>> list2 = new List<List<Vector2>>();
		List<List<Vector2>> list3 = new List<List<Vector2>>();
		exitRoad.4AAAA.Clear();
		List<Vector3> list4 = exitRoad.4AAAA;
		exitRoad.6AAAA.Clear();
		List<Vector3> list5 = exitRoad.6AAAA;
		exitRoad.7AAA1.Clear();
		List<float> list6 = exitRoad.7AAA1;
		List<Vector2> list7 = new List<Vector2>();
		exitRoad.8AAAA.Clear();
		List<Vector3> list8 = exitRoad.8AAAA;
		exitRoad.5AAA1.Clear();
		List<Vector3> list9 = exitRoad.5AAA1;
		List<List<Vector3>> list10 = new List<List<Vector3>>();
		List<List<Vector2>> list11 = new List<List<Vector2>>();
		List<List<Vector2>> list12 = new List<List<Vector2>>();
		List<List<Vector3>> list13 = new List<List<Vector3>>();
		List<List<Vector2>> list14 = new List<List<Vector2>>();
		List<List<Vector2>> list15 = new List<List<Vector2>>();
		List<List<Vector3>> list16 = new List<List<Vector3>>();
		List<List<Vector2>> list17 = new List<List<Vector2>>();
		List<List<Vector2>> list18 = new List<List<Vector2>>();
		exitRoad.vecs.Clear();
		exitRoad.uvsArray.Clear();
		exitRoad.uvsArray2.Clear();
		exitRoad.customColors.Clear();
		exitRoad.colors.Clear();
		exitRoad.tris.Clear();
		exitRoad.treeVecs.Clear();
		exitRoad.detailVecs.Clear();
		List<Vector3> list19 = exitRoad.vecs;
		List<Vector2> list20 = exitRoad.uvsArray;
		List<Vector2> list21 = exitRoad.uvsArray2;
		List<Color> list22 = exitRoad.customColors;
		List<Color> collection = exitRoad.colors;
		List<int> list23 = exitRoad.tris;
		List<Vector3> list24 = new List<Vector3>();
		List<Vector2> list25 = new List<Vector2>();
		int num = 0;
		Material material = null;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		int num5 = 0;
		exitRoad.á = 0;
		exitRoad.á = 0;
		int num6 = 0;
		List<bool> hardEdge = new List<bool>();
		List<Vector2> roadShapeVecs = new List<Vector2>();
		int rightOuterIndex = exitRoad.roadType.roadShapeData.outerLaneMarkingRightIndex;
		exitRoad.BAAAA = 5f;
		float num7 = 5f;
		List<float> roadShapeUVs = new List<float>();
		float num8 = 0f;
		exitRoad.edgeVecs.Clear();
		List<int> list26 = new List<int>();
		List<float> list27 = new List<float>();
		list27.Add(0f);
		List<float> list28 = new List<float>();
		List<Vector3> list29 = new List<Vector3>();
		List<Vector3> list30 = new List<Vector3>(soSplinePointsRight);
		float num9 = 5f;
		float num10 = 0f;
		float num11 = (exitRoad.00AAA = 0f);
		float num12 = (exitRoad.10AA1 = 0f);
		if (exitRoad.roadType != null)
		{
			exitRoad.roadType = QDQDOOQQDQODD.GetRoadTypeElByID(baseScript.roadTypes, exitRoad.roadType.id);
			material = exitRoad.roadType.roadMaterial;
			num9 = exitRoad.roadType.roadWidth;
			ODCCODOCQQ.OOQCCCDODD(exitRoad.roadType, ref roadShapeVecs, ref roadShapeUVs, ref hardEdge, ref rightOuterIndex);
			num7 = (exitRoad.BAAAA = exitRoad.roadType.roadWidth * exitRoad.roadType.uvTiling);
			num8 = roadShapeUVs[exitRoad.roadType.roadShapeData.outerOuterLaneMarkingLeftIndex];
			num11 = (exitRoad.00AAA = roadShapeVecs[exitRoad.roadType.roadShapeData.outerOuterLaneMarkingLeftIndex].y);
			num10 = exitRoad.roadType.roadShapeData.nodes[exitRoad.roadType.roadShapeData.nodes.Count - 1].x - exitRoad.roadType.roadShapeData.nodes[exitRoad.roadType.roadShapeData.outerOuterLaneMarkingLeftIndex].x;
			for (int i = 0; i < roadShapeVecs.Count; i++)
			{
				list.Add(new List<Vector3>());
				list2.Add(new List<Vector2>());
				list3.Add(new List<Vector2>());
				list10.Add(new List<Vector3>());
				list11.Add(new List<Vector2>());
				list12.Add(new List<Vector2>());
				list13.Add(new List<Vector3>());
				list14.Add(new List<Vector2>());
				list15.Add(new List<Vector2>());
				list28.Add(roadShapeVecs[roadShapeVecs.Count - 1].x - roadShapeVecs[i].x);
				if (hardEdge[i])
				{
					num6++;
				}
			}
			int num13 = exitRoad.roadType.roadShapeData.outerOuterLaneMarkingLeftIndex;
			if (num13 == -1)
			{
				num13 = 0;
			}
			List<ERDecal> list31 = ERDecal.FilterByType(exitRoad.roadType.decalPresets, ERDecalType.MotorwayRampLineMarking);
			float num14 = road.rt.roadShapeData.nodes[road.rt.roadShapeData.nodes.Count - 1].x - road.rt.roadShapeData.nodes[road.rt.roadShapeData.outerLaneMarkingRightIndex].x;
			float num15 = num14;
			num14 = 0f;
			float num16 = -1f * (road.rt.roadShapeData.nodes[0].x - road.rt.roadShapeData.nodes[road.rt.roadShapeData.outerLaneMarkingLeftIndex].x) + num14;
			num16 += exitRoad.splitEndWidth;
			float num17 = 0f;
			exitRoad.CAAA1 = 0f;
			if (road.rt.roadShapeData.outerLaneMarkingRightIndex != -1 && road.rt.roadShapeData.outerLaneMarkingRightIndex < road.rt.roadShapeData.nodes.Count)
			{
				exitRoad.CAAA1 = road.rt.roadShapeData.nodes[road.rt.roadShapeData.outerOuterLaneMarkingRightIndex].x - road.rt.roadShapeData.nodes[road.rt.roadShapeData.outerLaneMarkingRightIndex].x;
			}
			float cAAA = exitRoad.CAAA1;
			List<Vector3> list32 = new List<Vector3>();
			List<int> list33 = new List<int>();
			float num18 = 0f;
			float num20;
			float num19 = (num20 = 0f);
			bool flag = false;
			bool flag2 = false;
			if (exitRoad.fixedDistance == 0f)
			{
				flag2 = true;
			}
			Vector3 zero = Vector3.zero;
			Vector3 normalized = (soSplinePointsRight[exitRoad.startSplineIndex + 1] - soSplinePointsRight[exitRoad.startSplineIndex]).normalized;
			Vector3 vector = soSplinePointsRight[exitRoad.startSplineIndex - 1];
			float num21 = 0f;
			float num22 = 1f;
			float num23 = 1f;
			float num24 = 0f;
			if (exitRoad.extrusionType == 0)
			{
				num23 = exitRoad.extrusionDistance / num22;
			}
			Vector3 vector2 = soSplinePointsRight[exitRoad.startSplineIndex - 1];
			Vector3 normalized2 = (soSplinePointsRight[exitRoad.startSplineIndex] - soSplinePointsLeft[exitRoad.startSplineIndex]).normalized;
			list4.Add(soSplinePointsRight[exitRoad.startSplineIndex] - normalized2 * num14);
			list5.Add(list4[0] + normalized2 * cAAA);
			exitRoad.edgeVecs.Add(soSplinePointsRight[exitRoad.startSplineIndex] + normalized2 * num15);
			exitRoad.treeVecs.Add(list4[0]);
			exitRoad.treeVecs.Add(exitRoad.edgeVecs[0] + normalized2 * baseScript.treeDistance);
			exitRoad.detailVecs.Add(list4[0]);
			exitRoad.detailVecs.Add(exitRoad.edgeVecs[0] + normalized2 * baseScript.detailDistance - baseScript.detailOffsetVec);
			list9.Add(list4[0]);
			Vector3 vector3;
			if (exitRoad.road.terrainDeformation)
			{
				int num25 = exitRoad.startSplineIndex;
				if (num25 > 0)
				{
					num25--;
				}
				vector3 = soSplinePointsRight[num25];
				list24.Add(vector3);
				list25.Add(new Vector2(0f, 1f));
				Vector3 pos;
				if (exitRoad.road.doRightSurrounding[exitRoad.startSplineIndex])
				{
					pos = vector3 + normalized2 * rightIndentFloats[num25];
				}
				else
				{
					pos = vector3;
					road.baseScript.OCDDQOCDCO(ref pos);
					if (!(pos.y < vector3.y))
					{
						pos = vector3 + normalized2 * rightIndentFloats[num25];
					}
				}
				list24.Add(pos);
				list25.Add(new Vector2(0f, 1f));
				pos += normalized2 * rightSurroundingFloats[num25];
				road.baseScript.OCDDQOCDCO(ref pos);
				list24.Add(pos);
				list25.Add(new Vector2(0f, 0f));
			}
			float num26 = (exitRoad.extrusionDistance + exitRoad.fixedDistance + exitRoad.splitDistance) * 0.5f;
			float num27 = exitRoad.extrusionDistance + exitRoad.fixedDistance;
			bool flag3 = false;
			exitRoad.endSplinePointRight = exitRoad.road.soSplinePointsRight[exitRoad.endSplineIndex - 1];
			exitRoad.endSplinePointLeft = exitRoad.road.soSplinePointsLeft[exitRoad.endSplineIndex - 1];
			exitRoad.soPointsRightStart.Clear();
			exitRoad.soPointsLeftStart.Clear();
			int num28 = -1;
			bool flag4 = false;
			for (int j = exitRoad.startSplineIndex; j < exitRoad.endSplineIndex; j++)
			{
				flag4 = exitRoad.road.doRightSurrounding[j];
				exitRoad.road.doRightSurrounding[j] = false;
				normalized2 = (soSplinePointsRight[j + 1] - soSplinePointsLeft[j + 1]).normalized;
				num18 += Vector3.Distance(list30[j], list30[j + 1]);
				Vector3 vector4 = soSplinePointsRight[j + 1] - normalized2 * num14;
				list4.Add(vector4);
				if (!flag)
				{
					float num29 = num18 / exitRoad.extrusionDistance;
					if (exitRoad.extrusionType == 0)
					{
						num19 = num29 * (num10 - num14);
						if (num19 > num10 - num14)
						{
							num19 = num10 - num14;
						}
					}
					else
					{
						num19 = Mathf.SmoothStep(0f, num10 - num14 - cAAA, num18 / exitRoad.extrusionDistance);
						if (num19 > num10)
						{
							num19 = num10 - num14;
						}
						num24 += 1f;
					}
					num29 = exitRoad.extrusionCurve.Evaluate(num29);
					num19 = Mathf.Lerp(0f, num10 - num15 + cAAA, num29);
					float num30 = Mathf.Lerp(0f, cAAA, num29);
					float num31 = Mathf.SmoothStep(0f, 1f, num18 / exitRoad.extrusionDistance);
					num20 = Mathf.Lerp(0f, num10, num31 * num31);
					vector3 = soSplinePointsRight[exitRoad.startSplineIndex] + normalized * num31 * num31 * exitRoad.extrusionDistance;
					vector3 += normalized2 * num20;
					list27.Add(num19 + num30);
					vector3 = (zero = soSplinePointsRight[j + 1] + normalized2 * (num19 + num17 + num15));
					exitRoad.edgeVecs.Add(vector3);
					list5.Add(vector4 + normalized2 * (num17 + cAAA));
					list9.Add(Vector3.zero);
					exitRoad.treeVecs.Add(vector4);
					exitRoad.treeVecs.Add(vector3 + normalized2 * baseScript.treeDistance);
					exitRoad.detailVecs.Add(vector4);
					exitRoad.detailVecs.Add(vector3 + normalized2 * baseScript.detailDistance - baseScript.detailOffsetVec);
					Vector3 vector5 = vector3 - vector;
					vector5 = new Vector3(vector5.z, 0f, 0f - vector5.x);
					vector = vector3;
				}
				else if (!flag2)
				{
					vector3 = (zero = soSplinePointsRight[j + 1] + normalized2 * (num10 - num14 + cAAA));
					exitRoad.edgeVecs.Add(vector3);
					list5.Add(vector4 + normalized2 * (num17 + cAAA));
					list9.Add(vector4 + normalized2 * cAAA);
					list26.Add(exitRoad.edgeVecs.Count - 1);
					if (j + 1 == exitRoad.fixedDistanceIndex || num18 > exitRoad.extrusionDistance + exitRoad.fixedDistance)
					{
						flag2 = true;
						exitRoad.road.exitFixedEnd = exitRoad.edgeVecs[exitRoad.edgeVecs.Count - 1];
						num3 = exitRoad.edgeVecs.Count - 1;
						exitRoad.á = list4.Count - 1;
					}
					exitRoad.treeVecs.Add(vector4);
					exitRoad.treeVecs.Add(vector3 + normalized2 * baseScript.treeDistance);
					exitRoad.detailVecs.Add(vector4);
					exitRoad.detailVecs.Add(vector3 + normalized2 * baseScript.detailDistance - baseScript.detailOffsetVec);
				}
				else
				{
					float time = (num18 - exitRoad.fixedDistance - exitRoad.extrusionDistance) / exitRoad.splitDistance;
					time = exitRoad.splitCurve.Evaluate(time);
					num17 = num16 * time;
					vector3 = (zero = soSplinePointsRight[j + 1] + normalized2 * (0f - num14 + num17));
					list5.Add(vector3);
					list9.Add(vector3 + normalized2 * (0f - num17));
					Vector3 vector6 = vector3 - list5[list5.Count - 2];
					vector6 = new Vector3(vector6.z, 0f, 0f - vector6.x).normalized;
					vector3 += vector6 * num10;
					vector3.y = ODQDQDQDQO.OQDDCCCOQD(zero, list5[list5.Count - 2], soSplinePointsLeft[j + 1], vector3);
					exitRoad.edgeVecs.Add(vector3);
					list26.Add(exitRoad.edgeVecs.Count - 1);
					exitRoad.treeVecs.Add(vector4);
					exitRoad.treeVecs.Add(vector3 + normalized2 * baseScript.treeDistance);
					exitRoad.detailVecs.Add(vector4);
					exitRoad.detailVecs.Add(vector3 + normalized2 * baseScript.detailDistance - baseScript.detailOffsetVec);
				}
				num++;
				if (exitRoad.road.terrainDeformation)
				{
					list24.Add(list5[list5.Count - 1]);
					normalized2 = (exitRoad.edgeVecs[exitRoad.edgeVecs.Count - 1] - list5[list5.Count - 1]).normalized;
					list25.Add(new Vector2(0f, 1f));
					Vector3 pos;
					if (flag4)
					{
						pos = vector3 + normalized2 * rightIndentFloats[j];
					}
					else
					{
						pos = vector3;
						road.baseScript.OCDDQOCDCO(ref pos);
						if (!(pos.y < vector3.y))
						{
							pos = vector3 + normalized2 * rightIndentFloats[j];
						}
					}
					list24.Add(pos);
					list25.Add(new Vector2(0f, 1f));
					pos += normalized2 * rightSurroundingFloats[j];
					road.baseScript.OCDDQOCDCO(ref pos);
					list24.Add(pos);
					list25.Add(new Vector2(0f, 0f));
				}
				if ((j + 1 == exitRoad.startDistanceIndex || num18 > exitRoad.extrusionDistance) && !flag)
				{
					flag = true;
					exitRoad.road.exitExtrudeEnd = exitRoad.edgeVecs[exitRoad.edgeVecs.Count - 1];
					num2 = exitRoad.edgeVecs.Count - 1;
					num5 = list4.Count - 1;
					bool flag5 = true;
					float num32 = exitRoad.extrusionCurve.Evaluate(0.25f);
					if ((double)num32 > 0.24 && (double)num32 < 0.26)
					{
						num32 = exitRoad.extrusionCurve.Evaluate(0.75f);
						if ((double)num32 > 0.74 && (double)num32 < 0.76)
						{
							flag5 = false;
						}
					}
					if (flag5)
					{
						List<Vector3> tmpvecs = new List<Vector3>();
						tmpvecs.Add(exitRoad.edgeVecs[0]);
						list26.Add(0);
						float num33 = 1f;
						float angleThreshold = 2f;
						if (num33 == 2f)
						{
							angleThreshold = 6f;
						}
						else if (num33 == 3f)
						{
							angleThreshold = 10f;
						}
						Vector3 normalized3 = (list30[exitRoad.startSplineIndex - 1] - list30[exitRoad.startSplineIndex]).normalized;
						float num34 = Vector3.Distance(list30[exitRoad.startSplineIndex], list30[exitRoad.startSplineIndex + 1]);
						vector2 = list30[exitRoad.startSplineIndex] + normalized3 * num34;
						OQCCDDDOQQ(j, 0, vector2, exitRoad.edgeVecs, soSplinePointsRight, angleThreshold, ref tmpvecs);
						tmpvecs.Add(exitRoad.edgeVecs[1]);
						list26.Add(tmpvecs.Count - 1);
						vector2 = exitRoad.edgeVecs[0];
						for (int k = 1; k < exitRoad.edgeVecs.Count - 1; k++)
						{
							OQCCDDDOQQ(j, k, vector2, exitRoad.edgeVecs, soSplinePointsRight, angleThreshold, ref tmpvecs);
							tmpvecs.Add(exitRoad.edgeVecs[k + 1]);
							list26.Add(tmpvecs.Count - 1);
							vector2 = exitRoad.edgeVecs[k];
						}
						exitRoad.edgeVecs = tmpvecs;
					}
					else
					{
						for (int l = 0; l < exitRoad.edgeVecs.Count - 1; l++)
						{
							list26.Add(l);
						}
					}
					if (exitRoad.fixedDistance == 0f)
					{
						flag2 = true;
						exitRoad.road.exitFixedEnd = exitRoad.edgeVecs[exitRoad.edgeVecs.Count - 1];
						num3 = exitRoad.edgeVecs.Count - 1;
						exitRoad.á = list4.Count - 1;
					}
				}
				if (num18 > num26 && !flag3)
				{
					float num35 = num18 - num26;
					Vector3 normalized4 = (soSplinePointsRight[j + 1] - soSplinePointsRight[j]).normalized;
					exitRoad.OCODOQDODQ = soSplinePointsRight[j + 1] - normalized4 * num35;
					exitRoad.OCODOQDODQ += normalized2 * (0.5f * num19);
					exitRoad.handleDirection = normalized4;
					flag3 = true;
				}
				exitRoad.soPointsRightStart.Add(exitRoad.edgeVecs[exitRoad.edgeVecs.Count - 1]);
			}
			if (exitRoad.fixedDistance == 0f)
			{
			}
			int num36 = exitRoad.edgeVecs.Count - 1;
			float num37 = Vector3.Distance(exitRoad.edgeVecs[num36], exitRoad.edgeVecs[num36 - 1]);
			Vector3 normalized5 = (exitRoad.edgeVecs[num36 - 1] - exitRoad.edgeVecs[num36 - 2]).normalized;
			exitRoad.edgeVecs[exitRoad.edgeVecs.Count - 1] = exitRoad.edgeVecs[num36 - 1] + normalized5 * num37;
			exitRoad.soRightSplitEndIndex = exitRoad.soPointsRightStart.Count - 1;
			exitRoad.road.debugVecs.AddRange(list5);
			exitRoad.road.exitSplitEnd = exitRoad.edgeVecs[exitRoad.edgeVecs.Count - 1];
			num4 = exitRoad.edgeVecs.Count - 1;
			exitRoad.á = list4.Count - 1;
			float num38 = 0f;
			float num39 = 0f;
			float num40 = 0f;
			int num41 = 0;
			Vector3 vector7 = list4[0];
			Vector3 vector8 = list4[1];
			Vector3 vector9 = list4[1];
			float num42 = 0f + num40;
			float num43 = 0f + num40;
			float num44 = Vector3.Distance(vector7, vector8);
			num39 = num44;
			Vector3 normalized6 = (list4[0] - exitRoad.edgeVecs[0]).normalized;
			float num45 = 0f;
			float b = num44 / num7;
			list6.Add(num45);
			if (list4.Count > 1)
			{
				num39 = Vector3.Distance(list4[0], list4[2]);
				b = num18 / num7;
				vector8 = list4[2];
			}
			bool flag6 = false;
			for (int m = 0; m < exitRoad.edgeVecs.Count; m++)
			{
				if (list26[num41 + 1] <= m && list4.Count > num41 + 2)
				{
					num41++;
					vector7 = list5[num41];
					num38 += Vector3.Distance(list5[num41 - 1], list5[num41]);
					num45 = num38 / num7;
					list6.Add(num45);
					vector8 = ((list5.Count <= num41 + 2) ? list5[num41 + 1] : list5[num41 + 2]);
					num18 = Vector3.Distance(vector7, vector8);
					num39 = num18;
					b = (num38 + num39) / num7;
					normalized6 = (vector7 - exitRoad.edgeVecs[m]).normalized;
				}
				if (m == 0)
				{
					normalized2 = (list4[0] - exitRoad.edgeVecs[0]).normalized;
				}
				else if (m == exitRoad.edgeVecs.Count - 1)
				{
					normalized2 = exitRoad.edgeVecs[m] - exitRoad.edgeVecs[m - 1];
					normalized2 = new Vector3(0f - normalized2.z, 0f, normalized2.x).normalized;
				}
				else
				{
					normalized2 = exitRoad.edgeVecs[m + 1] - exitRoad.edgeVecs[m - 1];
					normalized2 = new Vector3(0f - normalized2.z, 0f, normalized2.x).normalized;
				}
				int num46 = list.Count - 1;
				int num47 = -1;
				int num48 = list.Count - 1;
				for (int n = num46; n < list.Count && n >= 0; n += num47)
				{
					if (num41 < list27.Count)
					{
						if (n < rightOuterIndex)
						{
							if ((list28[n] >= list27[num41] && !flag6) || n < num13)
							{
								vector3 = Vector3.zero;
							}
							else
							{
								vector3 = exitRoad.edgeVecs[m] + normalized6 * list28[n];
								if (m != 0)
								{
									vector3.y += num12 + roadShapeVecs[n].y;
								}
							}
						}
						else
						{
							vector3 = exitRoad.edgeVecs[m];
							if (n < num48)
							{
								vector3 = exitRoad.edgeVecs[m] + normalized2 * list28[n];
							}
							if (m != 0)
							{
								vector3.y += num12 + roadShapeVecs[n].y;
							}
							if (n == rightOuterIndex)
							{
								list8.Add(vector3);
							}
						}
						Vector3 b2 = ODQDQDQDQO.OQQCQOCCOQ(vector7, vector8, vector3);
						float num49 = Vector3.Distance(vector7, b2);
						float y = Mathf.Lerp(num45, b, num49 / num18);
						list10[n].Add(vector3);
						list11[n].Add(new Vector2(roadShapeUVs[n], y));
						list12[n].Add(Vector2.zero);
					}
					else
					{
						if ((list28[n] >= num10 && !flag6) || n < num13)
						{
							list10[n].Add(Vector3.zero);
							list11[n].Add(Vector2.zero);
							list12[n].Add(Vector2.zero);
						}
						else
						{
							vector3 = exitRoad.edgeVecs[m] + normalized6 * list28[n];
							vector3.y += num12 + roadShapeVecs[n].y;
							Vector3 b3 = ODQDQDQDQO.OQQCQOCCOQ(vector7, vector8, vector3);
							float num50 = Vector3.Distance(vector7, b3);
							float y2 = Mathf.Lerp(num45, b, num50 / num18);
							list10[n].Add(vector3);
							list11[n].Add(new Vector2(roadShapeUVs[n], y2));
							list12[n].Add(Vector2.zero);
						}
						if (n == num13 && m == exitRoad.edgeVecs.Count - 1)
						{
							vector3 = exitRoad.edgeVecs[m] + normalized6 * list28[n];
							vector3.y += num12 + roadShapeVecs[n].y;
							list5[list5.Count - 1] = vector3;
						}
					}
				}
			}
			if (list6.Count < list5.Count)
			{
				num38 += Vector3.Distance(list5[list5.Count - 1], list5[list5.Count - 2]);
				num45 = num38 / num7;
				list6.Add(num45);
			}
			int count = list10.Count;
			int num51 = 0;
			int num52 = 0;
			int num53 = 0;
			int curLeft = 0;
			int num54 = 0;
			num41 = 0;
			bool flag7 = true;
			bool flag8 = false;
			List<int> list34 = new List<int>();
			for (int num55 = 0; num55 < list10[0].Count; num55++)
			{
				if (list26[num41 + 1] <= num55)
				{
					if (list4.Count > num41 + 1)
					{
						num41++;
						num54 = list19.Count;
						flag7 = true;
					}
				}
				else if (num55 != 0)
				{
					flag7 = false;
				}
				flag8 = false;
				num53 = 0;
				for (int num56 = 0; num56 < count; num56++)
				{
					list19.Add(list10[num56][num55]);
					list20.Add(list11[num56][num55]);
					if (!flag8 && list10[num56][num55] != Vector3.zero)
					{
						list34.Add(list19.Count - 1);
						flag8 = true;
					}
					if (hardEdge.Count > num56 && hardEdge[num56])
					{
						list19.Add(list10[num56][num55]);
						list20.Add(list11[num56][num55]);
						num53++;
					}
					if (num56 < count - 1 && num55 != 0)
					{
						int num57 = num51 + num56 + num53 + num6;
						int num58 = num51 + num56 + num53 + 1 + num6;
						int num59 = num51 + num56 + num53 + count + num6;
						int item = num51 + num56 + num53 + count + 1 + num6;
						if (list19[num57] != Vector3.zero && list19[num58] != Vector3.zero && list19[num59] != Vector3.zero)
						{
							list23.Add(num57);
							list23.Add(num59);
							list23.Add(num58);
							list23.Add(num58);
							list23.Add(num59);
							list23.Add(item);
						}
					}
				}
				num51 = num55 * (count + num6);
				if (flag7)
				{
					vector3 = list5[num41];
					vector3.y += num11;
					list19[num54] = vector3;
					Vector2 value = list20[list20.Count - 1];
					value.x = num8;
					list20[num54] = value;
					OOOQCQDCDD(curLeft, num54, 0, list34.Count - 1, list34, list19, ref list23);
					int num57 = list34[list34.Count - 1];
					list34.Clear();
					list34.Add(num57);
					curLeft = num54;
				}
			}
			exitRoad.á = list19.Count - (count + num6);
			int num60 = count + num6;
			int count2 = list19.Count;
			Vector3 vector10 = list19[list19.Count - num60 + num13];
			int num61 = list19.Count - 1;
			UnityEngine.Debug.Log("Check point in case of triangulation errors at end split!!!!!!!");
			vector3 = list10[list10.Count - 1][list10[list10.Count - 1].Count - 1];
			zero = list10[list10.Count - 1][list10[list10.Count - 1].Count - 2];
			Vector3 vector11 = road.soSplinePointsRight[exitRoad.endSplineIndex];
			if (exitRoad.endSplineIndex + 1 < road.soSplinePointsRight.Count)
			{
				Vector3 vector12 = road.soSplinePointsRight[exitRoad.endSplineIndex + 1];
			}
			else
			{
				Vector3 vector12 = road.soSplinePointsRight[exitRoad.endSplineIndex - 1];
			}
			Vector3 vector13 = road.soSplinePoints[exitRoad.endSplineIndex];
			float num62 = exitRoad.connectionAngle;
			float num63 = exitRoad.connectionRadius;
			int num64 = exitRoad.markerIndex + 1;
			float num65 = Vector3.Distance(road.soSplinePoints[exitRoad.endSplineIndex], road.markersExt[num64].position);
			if (num65 < exitRoad.connectionRadius)
			{
				num64++;
			}
			if (ODQDQDQDQO.OQCDCDOOCD(road.soSplinePoints[exitRoad.endSplineIndex], road.soSplinePoints[exitRoad.endSplineIndex - 1], road.markersExt[num64].position))
			{
				Vector3 vector14 = road.soSplinePoints[exitRoad.endSplineIndex - 1] - road.soSplinePoints[exitRoad.endSplineIndex];
				Vector3 to = road.markersExt[num64].position - road.soSplinePoints[exitRoad.endSplineIndex];
				float num66 = 180f - Vector3.Angle(vector14, to);
				if (num66 > num62)
				{
					float num67 = num62;
					num62 += num66;
					num63 *= num67 / num62;
				}
			}
			if (num63 < num9 + 1f)
			{
				num63 = num9 + 1f;
			}
			normalized2 = (vector3 - zero).normalized;
			normalized2 = new Vector3(normalized2.z, 0f, 0f - normalized2.x).normalized;
			Vector3 vector15 = vector3 + normalized2 * num63;
			float num68 = 2f;
			float num69 = (float)Mathf.RoundToInt(2f * num63 * (float)Math.PI) * (num62 / 360f);
			int num70 = Mathf.RoundToInt(Mathf.Floor(num69 / num68));
			float num71 = num62 / ((float)num70 * 1f);
			float num72 = (float)Mathf.RoundToInt(2f * (num63 + list28[0] * 0.5f) * (float)Math.PI) * (num62 / 360f);
			float num73 = num72 / ((float)num70 * 1f);
			float num74 = num73 / num7;
			float num75 = Mathf.Abs(Vector3.Angle(vector3 - vector15, zero - vector15));
			if (num75 != 0f && !ODQDQDQDQO.OQCDCDOOCD(vector15, vector3, zero))
			{
				num75 *= -1f;
			}
			float num76 = (num62 + num75) / ((float)num70 * 1f);
			Vector3 vector16 = Vector3.zero;
			int cInt = exitRoad.endSplineIndex - 2;
			int match = cInt;
			b = (num38 + num39) / num7;
			roadShapeVecs = exitRoad.roadType.roadShape;
			roadShapeUVs = exitRoad.roadType.roadShapeUVs;
			hardEdge = exitRoad.roadType.hardEdge;
			count = roadShapeVecs.Count;
			num6 = 0;
			for (int num77 = 0; num77 < roadShapeVecs.Count; num77++)
			{
				list28.Add(roadShapeVecs[roadShapeVecs.Count - 1].x - roadShapeVecs[num77].x);
				if (hardEdge[num77])
				{
					num6++;
				}
			}
			list33.Clear();
			num51 += count + num6;
			Vector3 vector17 = Vector3.Lerp(list4[exitRoad.á - 1], list5[exitRoad.á - 1], 0.5f);
			Vector3 prefDirVec = (exitRoad.9AAA1 = Vector3.zero);
			float num78 = 2f * rightIndentFloats[cInt];
			List<bool> list35 = new List<bool>();
			Vector3 vector18;
			for (int num79 = 0; num79 <= num70; num79++)
			{
				vector18 = ODQDQDQDQO.OQDDDODCOC(vector3, vector15, Quaternion.Euler(0f, (float)num79 * num71, 0f));
				vector18.y = OQQDDDDDOC(vector18, soSplinePointsLeft, soSplinePointsRight, ref cInt, flag: true, ref match);
				exitRoad.soPointsRightStart.Add(vector18);
				b += num74;
				normalized2 = (vector18 - vector15).normalized;
				for (int num80 = 0; num80 < roadShapeVecs.Count; num80++)
				{
					Vector3 vector19;
					if (num80 < count - 1)
					{
						vector19 = vector18 + normalized2 * list28[num80];
						vector19.y = OQQDDDDDOC(vector19, soSplinePointsLeft, soSplinePointsRight, ref cInt, flag: false, ref match);
					}
					else
					{
						vector19 = vector18;
					}
					Vector3 vector20 = vector19;
					vector19.y += roadShapeVecs[num80].y;
					if (num80 == 0)
					{
						vector16 = vector19;
						Vector3 vector4 = ODQDQDQDQO.OQQCQOCCOQ(soSplinePointsRight[match - 1], soSplinePointsRight[match], vector19);
						num65 = Vector3.Distance(vector4, vector19);
						Vector3 pos;
						if (num65 > num78)
						{
							pos = vector20 + normalized2 * (baseScript.terrainMinIndent + baseScript.minSurrounding);
							road.baseScript.OCDDQOCDCO(ref pos);
							list24.Add(pos);
							list25.Add(new Vector2(0f, 1f));
							pos = vector20 + normalized2 * baseScript.terrainMinIndent;
							pos.y = OQQDDDDDOC(pos, soSplinePointsLeft, soSplinePointsRight, ref cInt, flag: false, ref match);
							list24.Add(pos);
							list25.Add(new Vector2(0f, 1f));
							list35.Add(item: true);
						}
						else
						{
							exitRoad.road.doRightSurrounding[match - 1] = false;
							exitRoad.road.doRightSurrounding[match] = false;
							list35.Add(item: false);
							pos = vector20 + normalized2 * baseScript.terrainMinIndent;
							Vector3 p = Vector3.Lerp(vector4, vector19, 0.5f);
							pos = ODQDQDQDQO.OODOQDOODO(vector17, p, vector19, pos, flag: false);
							pos.y = OQQDDDDDOC(pos, soSplinePointsLeft, soSplinePointsRight, ref cInt, flag: false, ref match);
							list24.Add(pos);
							list25.Add(new Vector2(0f, 1f));
							list24.Add(pos);
							list25.Add(new Vector2(0f, 1f));
							if (num79 != 0)
							{
								p = Vector3.Lerp(vector4, vector19, 0.6f);
								Vector3 vPoint = ODQDQDQDQO.OODOQDOODO(vector17, p, soSplinePointsRight[match], soSplinePointsLeft[match], flag: false);
								vPoint = ODQDQDQDQO.OQQCQOCCOQ(vector17, p, vPoint);
								roadSurfaceVecs[(match - 1) * 5 + 3] = vPoint;
								roadSurfaceVecs[(match - 1) * 5 + 4] = vPoint;
							}
						}
						pos.y = OQQDDDDDOC(pos, soSplinePointsLeft, soSplinePointsRight, ref cInt, flag: false, ref match);
						pos = Vector3.Lerp(vector20, vector18, 0.5f);
						list24.Add(pos);
						list25.Add(new Vector2(0f, 1f));
						pos = vector18 + -normalized2 * rightIndentFloats[match];
						pos.y = OQQDDDDDOC(pos, soSplinePointsLeft, soSplinePointsRight, ref cInt, flag: false, ref match);
						list24.Add(pos);
						list25.Add(new Vector2(0f, 1f));
						pos += -normalized2 * rightSurroundingFloats[match];
						road.baseScript.OCDDQOCDCO(ref pos);
						list24.Add(pos);
						list25.Add(new Vector2(0f, 1f));
						exitRoad.treeVecs.Add(vector19 + normalized2 * baseScript.treeDistance);
						exitRoad.treeVecs.Add(vector18 - normalized2 * baseScript.treeDistance);
						exitRoad.detailVecs.Add(vector19 + normalized2 * baseScript.detailDistance - baseScript.detailOffsetVec);
						exitRoad.detailVecs.Add(vector18 - normalized2 * baseScript.detailDistance - baseScript.detailOffsetVec);
						exitRoad.soPointsLeftStart.Add(vector19);
					}
					list19.Add(vector19);
					list20.Add(new Vector2(roadShapeUVs[num80], b));
					if (hardEdge.Count > num80 && hardEdge[num80])
					{
						list19.Add(vector19);
						list20.Add(Vector2.zero);
						num53++;
					}
					if (num80 < count - 1 && num79 > 0)
					{
						list23.Add(num51 + num80 + num53);
						list23.Add(num51 + num80 + num53 + count + num6);
						list23.Add(num51 + num80 + num53 + count + 1 + num6);
						list23.Add(num51 + num80 + num53);
						list23.Add(num51 + num80 + num53 + count + 1 + num6);
						list23.Add(num51 + num80 + num53 + 1);
					}
					if (num79 == 0 && num80 == 0)
					{
						exitRoad.9AAA1 = vector19;
					}
				}
				num51 += count + num6;
				if (num79 == num70)
				{
					list32.Add(vector18);
					list32.Add(vector16);
					list33.Add(0);
					list33.Add(1);
					exitRoad.connectionHandlePosition = Vector3.Lerp(vector18, vector16, 0.5f);
				}
				else if (num79 == num70 - 1)
				{
					prefDirVec = vector18;
				}
			}
			int num81 = count2 + count + num6;
			int num82 = count2;
			vector18 = Vector3.zero;
			for (int num83 = exitRoad.á; num83 < exitRoad.á + num60; num83++)
			{
				float num84 = 1000f;
				for (int num85 = num82; num85 < num81 - 1; num85++)
				{
					if (list19[num85] != list19[num85 + 1])
					{
						vector3 = ODQDQDQDQO.OQQCQOCCOQ(list19[num85], list19[num85 + 1], list19[num83]);
						num18 = Vector3.Distance(list19[num83], vector3);
						if (num18 < num84)
						{
							num84 = num18;
							vector18 = vector3;
							num82 = num85;
						}
					}
				}
				list19[num83] = vector18;
			}
			exitRoad.30AA1 = num51;
			List<Vector3> list36 = new List<Vector3>(list19);
			List<Vector2> uvs = new List<Vector2>(list20);
			List<Color> list37 = new List<Color>(collection);
			List<int> list38 = new List<int>(list23);
			exitRoad.BuildMeshInit(exitRoad, list36, uvs, list38, list37, material, exitRoad.road);
			exitRoad.OCQOQQCDOD(list24, list25, num, num70);
			exitRoad.OCCDCQQDOQ(list32, list33, list24, prefDirVec);
			exitRoad.20AAA = exitRoad.á;
			exitRoad.OQDDCODQCD();
			exitRoad.SpawnSplitObjects();
		}
		else
		{
			UnityEngine.Debug.Log("EasyRoads3Dv3 Warning: no road type is assigned to this exit road");
		}
	}

	public void BuildMeshInit(OQQCCQCDQQ exitRoad, List<Vector3> vecs, List<Vector2> uvs, List<int> tris, List<Color> colors, Material mat, ERModularRoad road)
	{
		OOOOOCODQO(exitRoad, 30AA1, vecs, uvs, tris);
		ODQCODOCDO(exitRoad, 30AA1, vecs, uvs, tris, 0);
		ODQCODOCDO(exitRoad, 30AA1, vecs, uvs, tris, exitRoad.startLineMarkingDecal);
		ODDDOCDCQO(vecs, uvs, tris, colors, mat, exitRoad.gameObject, road);
	}

	public void OQDDCODQCD()
	{
		if (exitSignObject != null)
		{
			if (exitSignObjectInstance == null)
			{
				exitSignObjectInstance = UnityEngine.Object.Instantiate(exitSignObject);
				exitSignObjectInstance.name = exitSignObject.name;
			}
			exitSignObjectInstance.transform.parent = base.transform;
			Vector3 position = Vector3.Lerp(4AAAA[20AAA], 6AAAA[20AAA], 0.5f);
			Vector3 normalized = (4AAAA[20AAA - 1] - 4AAAA[20AAA]).normalized;
			if (exitSignObjectOffset != 0f)
			{
				position += normalized * exitSignObjectOffset;
			}
			exitSignObjectInstance.transform.position = position;
			exitSignObjectInstance.transform.forward = normalized;
		}
	}

	public void SpawnSplitObjects()
	{
		if (exitSplitSpawnObject != null)
		{
			int curGo = 0;
			float num = 0f;
			bool flag = false;
			Vector3 vector = Vector3.zero;
			Vector3 vector2 = Vector3.zero;
			float num2 = 0f;
			Vector3 normalized = (6AAAA[á] - 4AAAA[á]).normalized;
			Vector3 a = 4AAAA[á] + normalized * (CAAA1 + exitSplitSpawnOffset);
			Vector3 b = 6AAAA[á] - normalized * exitSplitSpawnOffset;
			float num3 = Vector3.Distance(a, b);
			float num4 = Vector3.Distance(6AAAA[á], 4AAAA[á]);
			float num5 = 0f;
			bool flag2 = false;
			float b2 = 0f;
			float a2 = 0f;
			if (num3 > exitSplitSpawnObjectBounds * 2.1f && num4 > exitSplitSpawnObjectBounds * 2.1f && exitSplitSpawnType == 0)
			{
				flag = true;
			}
			else
			{
				normalized = (6AAAA[á] - 4AAAA[á]).normalized;
				if (exitSplitSpawnType == 0)
				{
					a = 4AAAA[á] + normalized * (CAAA1 + exitSplitSpawnOffset);
					b = 6AAAA[á] - normalized * exitSplitSpawnOffset;
					Vector3 vector3 = Vector3.Lerp(a, b, 0.5f);
				}
				else if (exitSplitSpawnType == 1)
				{
					Vector3 vector3 = 4AAAA[á] + normalized * (CAAA1 + exitSplitSpawnOffset);
				}
				else
				{
					Vector3 vector3 = 6AAAA[á] - normalized * exitSplitSpawnOffset;
				}
			}
			float num6 = 0f;
			float num7 = 0f;
			for (int i = á; i < 20AAA; i++)
			{
				Vector3 normalized2;
				normalized = (normalized2 = (6AAAA[i] - 4AAAA[i]).normalized);
				a = 4AAAA[i] + normalized * (CAAA1 + exitSplitSpawnOffset);
				b = 6AAAA[i] - normalized * exitSplitSpawnOffset;
				if (exitSplitSpawnType == 0)
				{
					num3 = Vector3.Distance(a, b);
					if (num3 > exitSplitSpawnObjectBounds * 2.1f)
					{
						num4 = Vector3.Distance(6AAAA[i], 4AAAA[i]);
						if ((double)num4 > (double)exitSplitSpawnObjectBounds * 2.1)
						{
							flag = true;
						}
					}
					else if (i < 20AAA - 1)
					{
						num5 = Vector3.Distance(4AAAA[i + 1] + normalized * (CAAA1 + exitSplitSpawnOffset), 6AAAA[i + 1] - normalized * exitSplitSpawnOffset);
						if ((double)num5 > (double)exitSplitSpawnObjectBounds * 2.1)
						{
							flag2 = true;
							b2 = num3;
							a2 = num5;
						}
					}
				}
				num6 = (num7 = Vector3.Distance(a, 4AAAA[i + 1]));
				if (num + num6 >= exitSplitSpawnDistance)
				{
					Vector3 vector3;
					if (exitSplitSpawnType == 0 && !flag)
					{
						vector3 = Vector3.Lerp(a, b, 0.5f);
						normalized = (Vector3.Lerp(4AAAA[i + 1], 6AAAA[i + 1], 0.5f) - vector3).normalized;
					}
					else if (exitSplitSpawnType == 1 || flag)
					{
						vector3 = a;
						normalized = (4AAAA[i + 1] - 4AAAA[i]).normalized;
						if (exitSplitSpawnType == 0)
						{
							vector2 = b;
							vector = (6AAAA[i + 1] - 6AAAA[i]).normalized;
						}
					}
					else
					{
						vector3 = b;
						normalized = (6AAAA[i + 1] - 6AAAA[i]).normalized;
					}
					vector3 += normalized * (exitSplitSpawnDistance - num);
					if (exitSplitSpawnType == 0 && flag && num2 >= exitSplitSpawnStartOffset)
					{
						vector2 += vector * (exitSplitSpawnDistance - num);
						OQDDCCQOOO(ref curGo, vector2);
					}
					if (num2 >= exitSplitSpawnStartOffset)
					{
						OQDDCCQOOO(ref curGo, vector3);
					}
					num2 += exitSplitSpawnDistance;
					num6 -= exitSplitSpawnDistance - num;
					num = 0f;
					while (num6 >= exitSplitSpawnDistance)
					{
						vector3 += normalized * exitSplitSpawnDistance;
						if (exitSplitSpawnType == 0 && !flag && flag2)
						{
							float t = num6 / num7;
							float num8 = Mathf.Lerp(a2, b2, t);
							if (num8 > exitSplitSpawnObjectBounds * 2.1f)
							{
								flag = true;
								normalized = (4AAAA[i + 1] - 4AAAA[i]).normalized;
								vector = (6AAAA[i + 1] - 6AAAA[i]).normalized;
								vector3 += -normalized2 * num8 * 0.5f;
								vector2 = vector3 + normalized2 * num8;
								vector2 = ODQDQDQDQO.OODOQDOODO(vector3, vector2, 6AAAA[i + 1], 6AAAA[i], flag: false);
								vector2 += -normalized2 * exitSplitSpawnOffset;
								vector3 = ODQDQDQDQO.OODOQDOODO(vector3, vector2, 4AAAA[i + 1], 4AAAA[i], flag: false);
								vector3 += normalized2 * (CAAA1 + exitSplitSpawnOffset);
								vector2 -= vector * exitSplitSpawnDistance;
							}
						}
						if (num2 >= exitSplitSpawnStartOffset)
						{
							OQDDCCQOOO(ref curGo, vector3);
						}
						if (exitSplitSpawnType == 0 && flag)
						{
							vector2 += vector * exitSplitSpawnDistance;
							if (num2 >= exitSplitSpawnStartOffset)
							{
								OQDDCCQOOO(ref curGo, vector2);
							}
						}
						num6 -= exitSplitSpawnDistance;
						num2 += exitSplitSpawnDistance;
					}
					num = num6;
				}
				else
				{
					num += num6;
				}
			}
			int num9;
			for (num9 = curGo; num9 < spawnedSplitObjects.Count; num9++)
			{
				if (spawnedSplitObjects[num9] != null)
				{
					UnityEngine.Object.DestroyImmediate(spawnedSplitObjects[num9]);
				}
				spawnedSplitObjects.RemoveAt(num9);
				num9--;
			}
		}
		int num10 = 0;
		for (int j = startSplineIndex; j < endSplineIndex; j++)
		{
			num10++;
		}
	}

	public void OQDDCCQOOO(ref int curGo, Vector3 v)
	{
		if (spawnedSplitObjects.Count > curGo)
		{
			if (spawnedSplitObjects[curGo] != null)
			{
				spawnedSplitObjects[curGo].transform.position = v;
			}
			else
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(exitSplitSpawnObject);
				gameObject.transform.parent = base.transform;
				gameObject.transform.position = v;
				spawnedSplitObjects[curGo] = gameObject;
			}
		}
		else
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(exitSplitSpawnObject);
			gameObject.transform.parent = base.transform;
			gameObject.transform.position = v;
			spawnedSplitObjects.Add(gameObject);
		}
		curGo++;
	}

	public static void OOOOOCODQO(OQQCCQCDQQ exitRoad, int vecCount, List<Vector3> vecs, List<Vector2> uvsArray, List<int> tris)
	{
		List<ERDecal> list = ERDecal.FilterByType(exitRoad.roadType.decalPresets, ERDecalType.MotorwayRampLineMarking);
		float num = exitRoad.00AAA;
		float num2 = 0f;
		float num3 = 0f;
		float width = list[0].width;
		float x = list[0].uvLeftTop2.x;
		float num4 = list[0].uvRightBottom2.x - list[0].uvLeftTop2.x;
		vecCount = vecs.Count;
		List<int> list2 = new List<int>();
		Vector3 item;
		for (int i = exitRoad.á; i <= exitRoad.á; i++)
		{
			item = exitRoad.5AAA1[i];
			item.y += num;
			vecs.Add(item);
			item = exitRoad.6AAAA[i];
			if (i == exitRoad.á)
			{
				item = vecs[exitRoad.á];
			}
			item.y += exitRoad.00AAA;
			vecs.Add(item);
			num3 = Vector3.Distance(exitRoad.5AAA1[i], exitRoad.6AAAA[i]);
			num2 = x + num3 / width * num4;
			uvsArray.Add(new Vector2(x, exitRoad.7AAA1[i]));
			uvsArray.Add(new Vector2(num2, exitRoad.7AAA1[i]));
			if (i < exitRoad.á)
			{
				if (vecs[vecCount] != vecs[vecCount + 1])
				{
					tris.Add(vecCount);
					tris.Add(vecCount + 2);
					tris.Add(vecCount + 1);
				}
				tris.Add(vecCount + 1);
				tris.Add(vecCount + 2);
				tris.Add(vecCount + 3);
			}
			vecCount += 2;
		}
		vecs.Add(exitRoad.9AAA1);
		item = ODQDQDQDQO.OQQCQOCCOQ(vecs[vecCount - 2], vecs[vecCount - 1], exitRoad.9AAA1);
		num3 = Vector3.Distance(vecs[vecCount - 2], vecs[vecCount - 1]);
		float num5 = Vector3.Distance(vecs[vecCount - 2], item);
		num2 = Mathf.Lerp(uvsArray[vecCount - 2].x, uvsArray[vecCount - 1].x, num5 / num3);
		float y = uvsArray[vecCount - 2].y + Vector3.Distance(item, exitRoad.9AAA1) / exitRoad.BAAAA;
		uvsArray.Add(new Vector2(num2, y));
		tris.Add(vecCount - 2);
		tris.Add(vecCount);
		tris.Add(vecCount - 1);
	}

	public static void ODQCODOCDO(OQQCCQCDQQ exitRoad, int vecCount, List<Vector3> vecs, List<Vector2> uvsArray, List<int> tris, int decalIndex)
	{
		float num = 0f;
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 0f;
		float num7 = 0f;
		float num8 = 0f;
		float num9 = 0f;
		float num10 = 0f;
		if (decalIndex != 0)
		{
			ERDecal eRDecal = ERDecal.OCQCDQDODQ(decalIndex, exitRoad.roadType.decalPresets);
			if (eRDecal == null)
			{
				return;
			}
			num = eRDecal.width;
			num2 = eRDecal.uvLeftTop2.x;
			num3 = eRDecal.uvRightBottom2.x - eRDecal.uvLeftTop2.x;
			num4 = eRDecal.width;
			num5 = eRDecal.uvLeftTop.x;
			num6 = eRDecal.uvRightBottom.x;
			num7 = eRDecal.xOffset;
			num8 = eRDecal.heightOffset;
			num9 = eRDecal.uvLeftTop1.x;
			num10 = eRDecal.uvRightBottom1.x;
		}
		else
		{
			UnityEngine.Debug.Log("to Do: create 'decal' option for Fill Gap motorway ramps in road types and use this decal here");
			num = 0f;
			num2 = 0f;
			num3 = 0f;
			num4 = 0f;
			num5 = 0f;
			num6 = 0f;
			num7 = 0f;
			num8 = 0f;
			num9 = 0f;
			num10 = 0f;
		}
		float num11 = exitRoad.00AAA;
		float num12 = 0f;
		float num13 = 0f;
		vecCount = vecs.Count;
		List<int> list = new List<int>();
		vecCount = vecs.Count;
		int num14 = 1;
		int num15 = 0;
		float num16 = Vector3.Distance(exitRoad.4AAAA[0], exitRoad.8AAAA[0]);
		float num17 = 2f * exitRoad.CAAA1;
		if (num16 < num17)
		{
			Vector3 zero = Vector3.zero;
			Vector3 zero2 = Vector3.zero;
			Vector3 vector = Vector3.zero;
			bool flag = false;
			int curLeft = 0;
			int num18 = 0;
			list.Clear();
			for (int i = 0; i <= exitRoad.á; i++)
			{
				num15 = i;
				Vector3 vector2 = exitRoad.road.soSplinePointsRight[i + exitRoad.startSplineIndex];
				Vector3 vector3 = exitRoad.road.soSplinePointsLeft[i + exitRoad.startSplineIndex];
				Vector3 normalized = (vector2 - vector3).normalized;
				zero = exitRoad.4AAAA[i] - normalized * num7;
				zero2 = ((decalIndex == 0) ? exitRoad.6AAAA[i] : (zero + normalized * num4));
				bool flag2 = true;
				if (i > 0)
				{
					if (ODQDQDQDQO.OQCDCDOOCD(vector, zero2, exitRoad.8AAAA[num14]))
					{
						flag2 = false;
						Vector3 vector4 = exitRoad.8AAAA[num14];
						vector4.y += num11 + exitRoad.10AA1;
						vecs.Add(vector4);
						Vector3 a = ODQDQDQDQO.OQQCQOCCOQ(vector, zero2, vector4);
						num16 = Vector3.Distance(a, vector4);
						num12 = Mathf.Lerp(num5, num6, (num4 - num16) / num4);
						a = ODQDQDQDQO.OQQCQOCCOQ(vector2, vector3, vector4);
						num16 = Vector3.Distance(a, vector4);
						num17 = Vector3.Distance(vector, zero2);
						float y = Mathf.Lerp(exitRoad.7AAA1[i - 1], exitRoad.7AAA1[i], (num17 - num16) / num17);
						uvsArray.Add(new Vector2(num12, y));
						list.Add(vecs.Count - 1);
						num14++;
					}
					else
					{
						Vector3 vector4 = ODQDQDQDQO.OODOQDOODO(vector, zero2, exitRoad.8AAAA[num14 - 1], exitRoad.8AAAA[num14], flag: false);
						vector4 = ODQDQDQDQO.OQQCQOCCOQ(exitRoad.8AAAA[num14 - 1], exitRoad.8AAAA[num14], vector4);
						vecs.Add(vector4);
						num12 = num6;
						Vector3 a = ODQDQDQDQO.OQQCQOCCOQ(vector2, vector3, vector4);
						num16 = Vector3.Distance(a, vector4);
						num17 = Vector3.Distance(vector, zero2);
						float y2 = Mathf.Lerp(exitRoad.7AAA1[i - 1], exitRoad.7AAA1[i], (num17 - num16) / num17);
						uvsArray.Add(new Vector2(num12, y2));
						list.Add(vecs.Count - 1);
						flag = true;
					}
					if (flag2)
					{
						Vector3 vector4 = ODQDQDQDQO.OODOQDOODO(vector, zero2, exitRoad.8AAAA[num14 - 1], exitRoad.8AAAA[num14], flag: false);
						vector4 = ODQDQDQDQO.OQQCQOCCOQ(exitRoad.8AAAA[num14 - 1], exitRoad.8AAAA[num14], vector4);
						vecs.Add(vector4);
						num12 = num6;
						Vector3 a = ODQDQDQDQO.OQQCQOCCOQ(vector2, vector3, vector4);
						num16 = Vector3.Distance(a, vector4);
						num17 = Vector3.Distance(vector, zero2);
						float y3 = Mathf.Lerp(exitRoad.7AAA1[i - 1], exitRoad.7AAA1[i], (num17 - num16) / num17);
						uvsArray.Add(new Vector2(num12, y3));
						list.Add(vecs.Count - 1);
						flag = true;
					}
					zero.y += num11 + exitRoad.10AA1 + num8;
					num18 = vecs.Count;
					vecs.Add(zero);
					uvsArray.Add(new Vector2(num5, exitRoad.7AAA1[i]));
					if (flag)
					{
						zero2.y += num11 + exitRoad.10AA1 + num8;
						vecs.Add(zero2);
						uvsArray.Add(new Vector2(num6, exitRoad.7AAA1[i]));
						list.Add(vecs.Count - 1);
					}
					OOOQCQDCDD(curLeft, num18, 0, list.Count - 1, list, vecs, ref tris);
					if (list.Count <= 0)
					{
						break;
					}
					int item = list[list.Count - 1];
					list.Clear();
					list.Add(item);
					if (flag)
					{
						break;
					}
				}
				else
				{
					num18 = vecs.Count;
					zero.y += exitRoad.00AAA + exitRoad.10AA1 + num8;
					vecs.Add(zero);
					uvsArray.Add(new Vector2(num5, exitRoad.7AAA1[i]));
					if (decalIndex != 0)
					{
						Vector3 vector4 = exitRoad.4AAAA[i];
						vector4.y += exitRoad.00AAA + exitRoad.10AA1 + num8;
						vecs.Add(vector4);
						num12 = Mathf.Lerp(num5, num6, Vector3.Distance(zero, vector4) / num4);
						uvsArray.Add(new Vector2(num12, exitRoad.7AAA1[i]));
						list.Add(vecs.Count - 1);
					}
				}
				vector = zero2;
				curLeft = num18;
			}
		}
		vecCount = vecs.Count;
		num13 = 0f;
		bool flag3 = false;
		float num19 = exitRoad.startDecalDistance;
		if (num19 == 0f)
		{
			num19 = 0.1f;
		}
		if (num19 == 0f)
		{
			num5 = num9;
			num6 = num10;
			flag3 = true;
		}
		int num20 = exitRoad.á;
		if (decalIndex != 0)
		{
			num20++;
		}
		for (int j = num15; j <= exitRoad.á; j++)
		{
			Vector3 vector2 = exitRoad.road.soSplinePointsRight[j + exitRoad.startSplineIndex];
			Vector3 vector3 = exitRoad.road.soSplinePointsLeft[j + exitRoad.startSplineIndex];
			Vector3 normalized = (vector2 - vector3).normalized;
			Vector3 vector4 = exitRoad.4AAAA[j] - normalized * num7;
			vector4.y += num11 + exitRoad.10AA1 + num8;
			vecs.Add(vector4);
			if (decalIndex != 0)
			{
				vector4 += normalized * num4;
			}
			else
			{
				vector4 = exitRoad.6AAAA[j];
			}
			vecs.Add(vector4);
			num12 = num2 + num13 / num * num3;
			uvsArray.Add(new Vector2(num5, exitRoad.7AAA1[j]));
			uvsArray.Add(new Vector2(num6, exitRoad.7AAA1[j]));
			if (j < num20)
			{
				tris.Add(vecCount);
				tris.Add(vecCount + 2);
				tris.Add(vecCount + 1);
				tris.Add(vecCount + 1);
				tris.Add(vecCount + 2);
				tris.Add(vecCount + 3);
			}
			vecCount += 2;
			if (j > 0 && !flag3 && exitRoad.4AAAA.Count > j + 1)
			{
				num16 = Vector3.Distance(exitRoad.4AAAA[j], exitRoad.4AAAA[j + 1]);
				if (num13 + num16 > num19 && decalIndex != 0)
				{
					num17 = num19 - num13;
					float t = num17 / num16;
					vector2 = exitRoad.road.soSplinePointsRight[j + 1 + exitRoad.startSplineIndex];
					vector3 = exitRoad.road.soSplinePointsLeft[j + 1 + exitRoad.startSplineIndex];
					normalized = (vector2 - vector3).normalized;
					vector4 = exitRoad.4AAAA[j + 1] - normalized * num7;
					vector4.y += num11 + exitRoad.10AA1 + num8;
					vector4 = Vector3.Lerp(vecs[vecs.Count - 2], vector4, t);
					vecs.Add(vector4);
					uvsArray.Add(new Vector2(num5, Mathf.Lerp(exitRoad.7AAA1[j], exitRoad.7AAA1[j + 1], t)));
					vector4 += normalized * num4;
					vecs.Add(vector4);
					uvsArray.Add(new Vector2(num6, Mathf.Lerp(exitRoad.7AAA1[j], exitRoad.7AAA1[j + 1], t)));
					num5 = num9;
					num6 = num10;
					vecs.Add(vecs[vecs.Count - 2]);
					vecs.Add(vecs[vecs.Count - 2]);
					Vector2 item2 = uvsArray[uvsArray.Count - 2];
					item2.x = num5;
					uvsArray.Add(item2);
					item2 = uvsArray[uvsArray.Count - 2];
					item2.x = num6;
					uvsArray.Add(item2);
					flag3 = true;
					vecCount += 2;
				}
				num13 += num16;
			}
		}
	}

	public static void OQCCDDDOQQ(int i, int j, Vector3 prevPos, List<Vector3> edgeVecs, List<Vector3> soSplinePointsRight, float angleThreshold, ref List<Vector3> tmpvecs)
	{
		Vector3 vector = edgeVecs[j] - prevPos;
		Vector3 to = edgeVecs[j] - edgeVecs[j + 1];
		float num = Vector3.Angle(vector, to);
		float num2 = 180f - num - angleThreshold;
		if (!(num2 > 0f))
		{
			return;
		}
		float num3 = Vector3.Distance(edgeVecs[j + 1], edgeVecs[j]);
		float num4 = 0.75f / num3;
		if (num4 > 0f && (double)num4 < 0.5)
		{
			Vector3 p;
			if (j < edgeVecs.Count - 2)
			{
				p = edgeVecs[j + 2];
			}
			else
			{
				num3 = Vector3.Distance(soSplinePointsRight[i + 1], soSplinePointsRight[i]);
				vector = ((soSplinePointsRight.Count <= i + 2) ? (soSplinePointsRight[i + 1] - soSplinePointsRight[i]).normalized.normalized : (soSplinePointsRight[i + 2] - soSplinePointsRight[i + 1]).normalized.normalized);
				p = edgeVecs[j + 1] + vector * num3;
			}
			List<Vector3> list = ODQDQDQDQO.OOODQCOOCC(prevPos, edgeVecs[j], edgeVecs[j + 1], p, num4);
			if ((double)Vector3.Distance(list[list.Count - 1], edgeVecs[j + 1]) < 0.25)
			{
				list.RemoveAt(list.Count - 1);
			}
			tmpvecs.AddRange(list);
		}
	}

	private static void OOOQCQDCDD(int curLeft, int endLeft, int curRight, int endRight, List<int> rightInts, List<Vector3> vecs, ref List<int> tris)
	{
		float num = 0f;
		float num2 = 0f;
		int num3 = -1;
		int num4 = 0;
		if (rightInts.Count <= curRight)
		{
			UnityEngine.Debug.Log("ramp edge tris error, rightInts.Count: " + rightInts.Count);
			return;
		}
		while (curLeft < endLeft || curRight < endRight)
		{
			num2 = ((curRight >= endRight) ? 0f : Vector3.Distance(vecs[curLeft], vecs[rightInts[curRight + 1]]));
			num = ((curLeft >= endLeft) ? 0f : Vector3.Distance(vecs[endLeft], vecs[rightInts[curRight]]));
			if ((num < num2 && curLeft < endLeft) || curRight == endRight)
			{
				tris.Add(curLeft);
				tris.Add(endLeft);
				tris.Add(rightInts[curRight]);
				curLeft = endLeft;
				num3 = 1;
			}
			else
			{
				tris.Add(curLeft);
				tris.Add(rightInts[curRight + 1]);
				tris.Add(rightInts[curRight]);
				curRight++;
				num3 = 0;
			}
			num4++;
			if (num4 > 100)
			{
				break;
			}
		}
	}

	public static void ODCDCQCOCQ(List<Vector3> vecs, ref List<int> tris)
	{
		bool flag = false;
		for (int i = 0; i < tris.Count; i += 3)
		{
			flag = false;
			if (vecs[tris[i]] == Vector3.zero)
			{
				flag = true;
			}
			else if (vecs[tris[i + 1]] == Vector3.zero)
			{
				flag = true;
			}
			else if (vecs[tris[i + 2]] == Vector3.zero)
			{
				flag = true;
			}
			if (flag)
			{
				tris.RemoveRange(i, 3);
				i -= 3;
			}
		}
	}

	public static void ODQDQDCOQD(ERModularBase baseScript, ERModularRoad road, OQQCCQCDQQ exitRoad, ref List<Vector3> soSplinePointsLeft, ref List<Vector3> soSplinePointsRight)
	{
		List<List<Vector3>> list = new List<List<Vector3>>();
		List<List<Vector3>> list2 = new List<List<Vector3>>();
		List<List<Vector3>> list3 = new List<List<Vector3>>();
		List<Vector3> list4 = new List<Vector3>();
		List<Vector3> list5 = new List<Vector3>(soSplinePointsRight);
		float num = 5f;
		float num2 = 0.5f;
		if (exitRoad.roadType != null)
		{
			num = exitRoad.roadType.roadWidth;
			num2 = 0.125f;
			if (num2 == 0f)
			{
				num2 = 0.25f;
			}
			List<Vector3> list6 = new List<Vector3>();
			List<int> list7 = new List<int>();
			list.Add(new List<Vector3>());
			list2.Add(new List<Vector3>());
			list3.Add(new List<Vector3>());
			list.Add(new List<Vector3>());
			list2.Add(new List<Vector3>());
			list3.Add(new List<Vector3>());
			list[0].Add(soSplinePointsRight[exitRoad.startSplineIndex]);
			list[1].Add(soSplinePointsRight[exitRoad.startSplineIndex]);
			list4.Add(soSplinePointsRight[exitRoad.startSplineIndex]);
			float num3 = 0f;
			float num4 = 0f;
			bool flag = false;
			Vector3 normalized = (soSplinePointsRight[exitRoad.startSplineIndex + 1] - soSplinePointsRight[exitRoad.startSplineIndex]).normalized;
			float num5 = 0f;
			Vector3 vector;
			Vector3 value;
			Vector3 normalized2;
			for (int i = exitRoad.startSplineIndex; i < exitRoad.endSplineIndex; i++)
			{
				normalized2 = (soSplinePointsRight[i + 1] - soSplinePointsLeft[i + 1]).normalized;
				num3 += Vector3.Distance(list5[i], list5[i + 1]);
				if (!flag)
				{
					float num6;
					if (exitRoad.extrusionType == 0)
					{
						num6 = num3 / exitRoad.extrusionDistance * num;
						if (num6 > num)
						{
							num6 = num;
						}
					}
					else
					{
						num6 = Mathf.SmoothStep(0f, num, num3 / exitRoad.extrusionDistance);
						if (num6 > num)
						{
							num6 = num;
						}
					}
					float num7 = Mathf.SmoothStep(0f, 1f, num3 / exitRoad.extrusionDistance);
					num4 = Mathf.Lerp(0f, num, num7 * num7);
					vector = soSplinePointsRight[i + 1];
					vector += normalized2 * num4;
					vector = (value = soSplinePointsRight[i + 1] + normalized2 * num6);
					list[0].Add(vector);
					vector += -normalized2 * num2;
					list[1].Add(vector);
				}
				else
				{
					vector = (value = soSplinePointsRight[i + 1] + normalized2 * num);
					list2[0].Add(vector);
				}
				vector = soSplinePointsRight[i + 1] + -normalized2 * 0.25f;
				list4.Add(vector);
				soSplinePointsRight[i + 1] = value;
				if (num3 > exitRoad.extrusionDistance)
				{
					flag = true;
					if (exitRoad.fixedDistance == 0f)
					{
						break;
					}
				}
			}
			if (exitRoad.fixedDistance == 0f)
			{
				float num8 = 0f;
				float num9 = Mathf.Sqrt(exitRoad.extrusionDistance * exitRoad.extrusionDistance - num * num);
				float num10 = Vector3.Distance(list[0][0], list[0][list[0].Count - 1]);
				num8 = num9 / num10;
				for (int j = 1; j < list[0].Count; j++)
				{
					vector = list[0][j];
					vector = Vector3.Lerp(list[0][0], list[0][j], num8);
				}
			}
			if (exitRoad.fixedDistance < 1f)
			{
				vector = list[0][list[0].Count - 1];
				value = list4[list4.Count - 1];
			}
			else
			{
				vector = list2[0][list2[0].Count - 1];
				value = list4[list4.Count - 1];
			}
			float num11 = exitRoad.connectionAngle;
			float num12 = exitRoad.connectionRadius;
			int num13 = exitRoad.markerIndex + 1;
			float num14 = Vector3.Distance(road.soSplinePoints[exitRoad.endSplineIndex], road.markersExt[num13].position);
			if (num14 < exitRoad.connectionRadius)
			{
				num13++;
			}
			if (ODQDQDQDQO.OQCDCDOOCD(road.soSplinePoints[exitRoad.endSplineIndex], road.soSplinePoints[exitRoad.endSplineIndex - 1], road.markersExt[num13].position))
			{
				Vector3 vector2 = road.soSplinePoints[exitRoad.endSplineIndex - 1] - road.soSplinePoints[exitRoad.endSplineIndex];
				Vector3 to = road.markersExt[num13].position - road.soSplinePoints[exitRoad.endSplineIndex];
				float num15 = 180f - Vector3.Angle(vector2, to);
				if (num15 > num11)
				{
					float num16 = num11;
					num11 += num15;
					num12 *= num16 / num11;
				}
			}
			if (num12 < num + 1f)
			{
				num12 = num + 1f;
			}
			normalized2 = ((exitRoad.fixedDistance < 1f || list2[0].Count <= 0) ? (vector - list[0][list[0].Count - 2]) : ((list2[0].Count <= 1) ? (vector - list[0][list[0].Count - 1]) : (vector - list2[0][list2[0].Count - 2])));
			normalized2 = new Vector3(normalized2.z, 0f, 0f - normalized2.x).normalized;
			Vector3 vector3 = vector + normalized2 * num12;
			float num17 = 1f;
			float num18 = (float)Mathf.RoundToInt(2f * num12 * (float)Math.PI) * (num11 / 360f);
			int num19 = Mathf.RoundToInt(Mathf.Floor(num18 / num17));
			float num20 = num11 / ((float)num19 * 1f);
			float num21 = Mathf.Abs(Vector3.Angle(vector - vector3, value - vector3));
			if (num21 != 0f && !ODQDQDQDQO.OQCDCDOOCD(vector3, vector, value))
			{
				num21 *= -1f;
			}
			float num22 = (num11 + num21) / ((float)num19 * 1f);
			int cInt = exitRoad.endSplineIndex;
			int match = 0;
			for (int k = 1; k <= num19; k++)
			{
				Vector3 vector4 = ODQDQDQDQO.OQDDDODCOC(vector, vector3, Quaternion.Euler(0f, (float)k * num20, 0f));
				Vector3 vector5 = ODQDQDQDQO.OQDDDODCOC(value, vector3, Quaternion.Euler(0f, (float)k * num22, 0f));
				vector5.y = OQQDDDDDOC(vector4, soSplinePointsLeft, soSplinePointsRight, ref cInt, flag: false, ref match);
				vector4.y = OQQDDDDDOC(vector4, soSplinePointsLeft, soSplinePointsRight, ref cInt, flag: true, ref match);
				list3[0].Add(vector4);
				list4.Add(vector5);
				if (k == num19)
				{
					list6.Add(vector4);
					list6.Add(vector5);
					list7.Add(0);
					list7.Add(1);
					exitRoad.connectionHandlePosition = Vector3.Lerp(vector4, vector5, 0.5f);
				}
			}
			OQDOQDDCDD(baseScript, road, exitRoad, null, list, list2, list3, list4);
			exitRoad.OCCDCQQDOQ(list6, list7, null, Vector3.zero);
		}
		else
		{
			UnityEngine.Debug.Log("EasyRoads3Dv3 Warning: no road type is assigned to this exit road");
		}
	}

	public static void ODDDDDDQQD(ERModularBase baseScript, ERModularRoad road, ERMarkerExt marker, ref List<Vector3> soSplinePointsLeft, ref List<Vector3> soSplinePointsRight)
	{
		GameObject gameObject = null;
		OQQCCQCDQQ componentInChildren = road.gameObject.GetComponentInChildren<OQQCCQCDQQ>();
		if (componentInChildren != null)
		{
			gameObject = componentInChildren.gameObject;
		}
		else
		{
			gameObject = new GameObject("Exit Road");
			gameObject.AddComponent<OQQCCQCDQQ>();
			gameObject.transform.parent = road.transform;
		}
		float num = 5f;
		float num2 = 0.5f;
		if (marker.exitRoadType != 0)
		{
			num = baseScript.roadTypes[marker.exitRoadType - 1].roadWidth;
			num2 = baseScript.roadTypes[marker.exitRoadType - 1].outerIndent;
			if (num2 == 0f)
			{
				num2 = 0.25f;
			}
		}
		List<Vector3> list = new List<Vector3>();
		List<int> list2 = new List<int>();
		if (marker.exitOuterVerticesExtrusion != null)
		{
			marker.exitOuterVerticesExtrusion.Clear();
		}
		else
		{
			marker.exitOuterVerticesExtrusion = new List<List<Vector3>>();
		}
		if (marker.exitOuterVerticesFixed != null)
		{
			marker.exitOuterVerticesFixed.Clear();
		}
		else
		{
			marker.exitOuterVerticesFixed = new List<List<Vector3>>();
		}
		if (marker.exitOuterVerticesCurve != null)
		{
			marker.exitOuterVerticesCurve.Clear();
		}
		else
		{
			marker.exitOuterVerticesCurve = new List<List<Vector3>>();
		}
		marker.exitOuterVerticesExtrusion.Add(new List<Vector3>());
		marker.exitOuterVerticesFixed.Add(new List<Vector3>());
		marker.exitOuterVerticesCurve.Add(new List<Vector3>());
		marker.exitOuterVerticesExtrusion.Add(new List<Vector3>());
		marker.exitOuterVerticesFixed.Add(new List<Vector3>());
		marker.exitOuterVerticesCurve.Add(new List<Vector3>());
		marker.exitInnerVertices.Clear();
		marker.exitOuterVerticesExtrusion[0].Add(soSplinePointsRight[marker.startExitInt]);
		marker.exitOuterVerticesExtrusion[1].Add(soSplinePointsRight[marker.startExitInt]);
		marker.exitInnerVertices.Add(soSplinePointsRight[marker.startExitInt]);
		float num3 = 0f;
		bool flag = false;
		Vector3 item;
		Vector3 value;
		Vector3 normalized;
		for (int i = marker.startExitInt; i < marker.endExitInt; i++)
		{
			normalized = (soSplinePointsRight[i + 1] - soSplinePointsLeft[i + 1]).normalized;
			num3 += Vector3.Distance(soSplinePointsRight[i], soSplinePointsRight[i + 1]);
			if (!flag)
			{
				float num4;
				if (marker.extrusionType == 0)
				{
					num4 = num3 / marker.extrusionDistance * num;
					if (num4 > num)
					{
						num4 = num;
					}
				}
				else
				{
					num4 = Mathf.Lerp(0f, num, Mathf.SmoothStep(0f, 1f, num3 / marker.extrusionDistance));
					if (num4 > num)
					{
						num4 = num;
					}
				}
				item = (value = soSplinePointsRight[i + 1] + normalized * num4);
				marker.exitOuterVerticesExtrusion[0].Add(item);
				item += -normalized * num2;
				marker.exitOuterVerticesExtrusion[1].Add(item);
			}
			else
			{
				item = (value = soSplinePointsRight[i + 1] + normalized * num);
				marker.exitOuterVerticesFixed[0].Add(item);
			}
			marker.exitInnerVertices.Add(soSplinePointsRight[i + 1]);
			soSplinePointsRight[i + 1] = value;
			if (num3 > marker.extrusionDistance)
			{
				flag = true;
				if (marker.fixedDistance == 0f)
				{
					break;
				}
			}
		}
		if (marker.fixedDistance == 0f)
		{
			float num5 = 0f;
			float num6 = Mathf.Sqrt(marker.extrusionDistance * marker.extrusionDistance - num * num);
			float num7 = Vector3.Distance(marker.exitOuterVerticesExtrusion[0][0], marker.exitOuterVerticesExtrusion[0][marker.exitOuterVerticesExtrusion[0].Count - 1]);
			num5 = num6 / num7;
			for (int j = 1; j < marker.exitOuterVerticesExtrusion[0].Count; j++)
			{
				item = marker.exitOuterVerticesExtrusion[0][j];
				item = Vector3.Lerp(marker.exitOuterVerticesExtrusion[0][0], marker.exitOuterVerticesExtrusion[0][j], num5);
			}
		}
		if (marker.fixedDistance == 0f)
		{
			item = marker.exitOuterVerticesExtrusion[0][marker.exitOuterVerticesExtrusion[0].Count - 1];
			value = marker.exitInnerVertices[marker.exitInnerVertices.Count - 1];
		}
		else
		{
			item = marker.exitOuterVerticesFixed[0][marker.exitOuterVerticesFixed[0].Count - 1];
			value = marker.exitInnerVertices[marker.exitInnerVertices.Count - 1];
		}
		normalized = ((marker.fixedDistance != 0f) ? (item - marker.exitOuterVerticesFixed[0][marker.exitOuterVerticesFixed[0].Count - 2]) : (item - marker.exitOuterVerticesExtrusion[0][marker.exitOuterVerticesExtrusion[0].Count - 2]));
		normalized = new Vector3(normalized.z, 0f, 0f - normalized.x).normalized;
		Vector3 vector = item + normalized * marker.connectionRadius;
		float num8 = 1f;
		float num9 = (float)Mathf.RoundToInt(2f * marker.connectionRadius * (float)Math.PI) * (marker.connectionAngle / 360f);
		int num10 = Mathf.RoundToInt(Mathf.Floor(num9 / num8));
		float num11 = marker.connectionAngle / ((float)num10 * 1f);
		float num12 = Mathf.Abs(Vector3.Angle(item - vector, value - vector));
		if (num12 != 0f && !ODQDQDQDQO.OQCDCDOOCD(vector, item, value))
		{
			num12 *= -1f;
		}
		float num13 = (marker.connectionAngle + num12) / ((float)num10 * 1f);
		int cInt = marker.endExitInt;
		int match = 0;
		for (int k = 1; k <= num10; k++)
		{
			Vector3 vector2 = ODQDQDQDQO.OQDDDODCOC(item, vector, Quaternion.Euler(0f, (float)k * num11, 0f));
			Vector3 vector3 = ODQDQDQDQO.OQDDDODCOC(value, vector, Quaternion.Euler(0f, (float)k * num13, 0f));
			vector3.y = OQQDDDDDOC(vector2, soSplinePointsLeft, soSplinePointsRight, ref cInt, flag: false, ref match);
			vector2.y = OQQDDDDDOC(vector2, soSplinePointsLeft, soSplinePointsRight, ref cInt, flag: true, ref match);
			marker.exitOuterVerticesCurve[0].Add(vector2);
			marker.exitInnerVertices.Add(vector3);
			if (k == num10)
			{
				list.Add(vector2);
				list.Add(vector3);
				list2.Add(0);
				list2.Add(1);
				componentInChildren.connectionHandlePosition = Vector3.Lerp(vector2, vector3, 0.5f);
			}
		}
		componentInChildren.OCCDCQQDOQ(list, list2, null, Vector3.zero);
	}

	public static void OQDOQDDCDD(ERModularBase baseScript, ERModularRoad road, OQQCCQCDQQ exitRoad, List<ERMarkerExt> markers, List<List<Vector3>> exitOuterVerticesExtrusion, List<List<Vector3>> exitOuterVerticesFixed, List<List<Vector3>> exitOuterVerticesCurve, List<Vector3> exitInnerVertices)
	{
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		List<Vector2> list3 = new List<Vector2>();
		List<Color> list4 = new List<Color>();
		List<Color> list5 = new List<Color>();
		List<int> list6 = new List<int>();
		Material roadMaterial = exitRoad.roadType.roadMaterial;
		float x = 0.97f;
		float num = 5f;
		num = exitRoad.roadType.roadWidth;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		float num5 = 0f;
		float num6 = 0f;
		float num7 = 5f;
		for (int i = 0; i < exitOuterVerticesExtrusion[0].Count; i++)
		{
			num4 = list.Count;
			list.Add(exitInnerVertices[i]);
			list.Add(exitOuterVerticesExtrusion[1][i]);
			list.Add(exitOuterVerticesExtrusion[1][i]);
			list.Add(exitOuterVerticesExtrusion[0][i]);
			if (i > 0)
			{
				num6 += Vector3.Distance(exitInnerVertices[i - 1], exitInnerVertices[i]);
				num5 += Vector3.Distance(exitOuterVerticesExtrusion[0][i - 1], exitOuterVerticesExtrusion[0][i]);
			}
			float num8 = Vector3.Distance(exitInnerVertices[i], exitOuterVerticesExtrusion[1][i]);
			list2.Add(new Vector2(0f, num6 / num7));
			list2.Add(new Vector2(num8 / num, num6 / num7));
			list2.Add(new Vector2(x, num5 / num7));
			list2.Add(new Vector2(1f, num5 / num7));
			list3.Add(new Vector2(0f, num6 / num7));
			list3.Add(new Vector2(num8 / num, num6 / num7));
			list3.Add(new Vector2(x, num5 / num7));
			list3.Add(new Vector2(1f, num5 / num7));
			list4.Add(Color.white);
			list4.Add(Color.white);
			list4.Add(Color.white);
			list4.Add(Color.white);
			list5.Add(Color.white);
			list5.Add(Color.white);
			list5.Add(Color.white);
			list5.Add(Color.white);
			if (i < exitOuterVerticesExtrusion[0].Count - 1)
			{
				list6.Add(num4);
				list6.Add(num4 + 4);
				list6.Add(num4 + 1);
				list6.Add(num4 + 1);
				list6.Add(num4 + 4);
				list6.Add(num4 + 5);
				list6.Add(num4 + 2);
				list6.Add(num4 + 6);
				list6.Add(num4 + 3);
				list6.Add(num4 + 3);
				list6.Add(num4 + 6);
				list6.Add(num4 + 7);
			}
			num3++;
		}
		if (exitRoad.fixedDistance >= 1f)
		{
			num6 += Vector3.Distance(exitInnerVertices[num3 - 1], exitInnerVertices[num3]);
			num5 += Vector3.Distance(exitOuterVerticesExtrusion[0][exitOuterVerticesExtrusion[0].Count - 1], exitOuterVerticesFixed[0][0]);
		}
		else
		{
			num6 += Vector3.Distance(exitInnerVertices[num3 - 1], exitInnerVertices[num3]);
			num5 += Vector3.Distance(exitOuterVerticesExtrusion[0][exitOuterVerticesExtrusion[0].Count - 1], exitOuterVerticesCurve[0][0]);
		}
		num4 = list.Count;
		list6.Add(num4 - 4);
		list6.Add(num4);
		list6.Add(num4 - 3);
		list6.Add(num4 - 2);
		list6.Add(num4);
		list6.Add(num4 + 1);
		list6.Add(num4 - 1);
		list6.Add(num4 - 2);
		list6.Add(num4 + 1);
		if (exitRoad.fixedDistance >= 1f)
		{
			for (int j = 0; j < exitOuterVerticesFixed[0].Count; j++)
			{
				num4 = list.Count;
				list.Add(exitInnerVertices[num3 + j]);
				list.Add(exitOuterVerticesFixed[0][j]);
				if (j > 0)
				{
					num6 += Vector3.Distance(exitInnerVertices[num3 + j - 1], exitInnerVertices[num3 + j]);
					num5 += Vector3.Distance(exitOuterVerticesFixed[0][j - 1], exitOuterVerticesFixed[0][j]);
				}
				list2.Add(new Vector2(0f, num6 / num7));
				list2.Add(new Vector2(1f, num5 / num7));
				list3.Add(new Vector2(0f, num6 / num7));
				list3.Add(new Vector2(1f, num5 / num7));
				list4.Add(Color.white);
				list4.Add(Color.white);
				list5.Add(Color.white);
				list5.Add(Color.white);
				if (j < exitOuterVerticesFixed[0].Count - 1)
				{
					list6.Add(num4);
					list6.Add(num4 + 2);
					list6.Add(num4 + 1);
					list6.Add(num4 + 1);
					list6.Add(num4 + 2);
					list6.Add(num4 + 3);
				}
			}
			num3 += exitOuterVerticesFixed[0].Count;
			if (num3 < exitInnerVertices.Count)
			{
				num6 += Vector3.Distance(exitInnerVertices[num3 - 1], exitInnerVertices[num3]);
			}
			if (exitOuterVerticesCurve[0].Count > exitOuterVerticesFixed[0].Count - 1 && exitOuterVerticesCurve[0].Count > 0)
			{
				num5 += Vector3.Distance(exitOuterVerticesFixed[0][exitOuterVerticesFixed[0].Count - 1], exitOuterVerticesCurve[0][0]);
			}
			num4 = list.Count;
			list6.Add(num4 - 2);
			list6.Add(num4);
			list6.Add(num4 - 1);
			list6.Add(num4 - 1);
			list6.Add(num4);
			list6.Add(num4 + 1);
		}
		for (int k = 0; k < exitOuterVerticesCurve[0].Count; k++)
		{
			num4 = list.Count;
			list.Add(exitInnerVertices[num3 + k]);
			list.Add(exitOuterVerticesCurve[0][k]);
			if (k > 0)
			{
				num6 += Vector3.Distance(exitInnerVertices[k - 1], exitInnerVertices[k]);
				num5 += Vector3.Distance(exitInnerVertices[k - 1], exitInnerVertices[k]);
			}
			list2.Add(new Vector2(0f, num6 / num7));
			list2.Add(new Vector2(1f, num5 / num7));
			list3.Add(new Vector2(0f, num6 / num7));
			list3.Add(new Vector2(1f, num5 / num7));
			list4.Add(Color.white);
			list4.Add(Color.white);
			list5.Add(Color.white);
			list5.Add(Color.white);
			if (k < exitOuterVerticesCurve[0].Count - 1)
			{
				list6.Add(num4);
				list6.Add(num4 + 2);
				list6.Add(num4 + 1);
				list6.Add(num4 + 1);
				list6.Add(num4 + 2);
				list6.Add(num4 + 3);
			}
		}
		num3 += exitOuterVerticesCurve[0].Count;
		ODDDOCDCQO(list, list2, list6, list5, roadMaterial, exitRoad.gameObject, road);
	}

	public static void OCDQCQDDOQ(ERModularBase baseScript, ERModularRoad road, List<ERMarkerExt> markers)
	{
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		List<Vector2> list3 = new List<Vector2>();
		List<Color> list4 = new List<Color>();
		List<Color> list5 = new List<Color>();
		List<int> list6 = new List<int>();
		for (int i = 0; i < markers.Count; i++)
		{
			if (!markers[i].attachExit)
			{
				continue;
			}
			GameObject gameObject = null;
			OQQCCQCDQQ componentInChildren = road.gameObject.GetComponentInChildren<OQQCCQCDQQ>();
			if (componentInChildren != null)
			{
				gameObject = componentInChildren.gameObject;
			}
			else
			{
				gameObject = new GameObject("Exit Road");
				gameObject.AddComponent<OQQCCQCDQQ>();
				gameObject.transform.parent = road.transform;
			}
			Material mat = null;
			float x = 0.9f;
			float num = 5f;
			if (markers[i].exitRoadType != 0)
			{
				mat = baseScript.roadTypes[markers[i].exitRoadType - 1].roadMaterial;
				num = baseScript.roadTypes[markers[i].exitRoadType - 1].roadWidth;
			}
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			float num5 = 0f;
			float num6 = 0f;
			float num7 = 5f;
			for (int j = 0; j < markers[i].exitOuterVerticesExtrusion[0].Count; j++)
			{
				num4 = list.Count;
				list.Add(markers[i].exitInnerVertices[j]);
				list.Add(markers[i].exitOuterVerticesExtrusion[1][j]);
				list.Add(markers[i].exitOuterVerticesExtrusion[1][j]);
				list.Add(markers[i].exitOuterVerticesExtrusion[0][j]);
				if (j > 0)
				{
					num6 += Vector3.Distance(markers[i].exitInnerVertices[j - 1], markers[i].exitInnerVertices[j]);
					num5 += Vector3.Distance(markers[i].exitOuterVerticesExtrusion[0][j - 1], markers[i].exitOuterVerticesExtrusion[0][j]);
				}
				float num8 = Vector3.Distance(markers[i].exitInnerVertices[j], markers[i].exitOuterVerticesExtrusion[1][j]);
				list2.Add(new Vector2(0f, num6 / num7));
				list2.Add(new Vector2(num8 / num, num6 / num7));
				list2.Add(new Vector2(x, num5 / num7));
				list2.Add(new Vector2(1f, num5 / num7));
				list3.Add(new Vector2(0f, num6 / num7));
				list3.Add(new Vector2(num8 / num, num6 / num7));
				list3.Add(new Vector2(x, num5 / num7));
				list3.Add(new Vector2(1f, num5 / num7));
				list4.Add(Color.white);
				list4.Add(Color.white);
				list4.Add(Color.white);
				list4.Add(Color.white);
				list5.Add(Color.white);
				list5.Add(Color.white);
				list5.Add(Color.white);
				list5.Add(Color.white);
				if (j < markers[i].exitOuterVerticesExtrusion[0].Count - 1)
				{
					list6.Add(num4);
					list6.Add(num4 + 4);
					list6.Add(num4 + 1);
					list6.Add(num4 + 1);
					list6.Add(num4 + 4);
					list6.Add(num4 + 5);
					list6.Add(num4 + 2);
					list6.Add(num4 + 6);
					list6.Add(num4 + 3);
					list6.Add(num4 + 3);
					list6.Add(num4 + 6);
					list6.Add(num4 + 7);
				}
				num3++;
			}
			if (markers[i].fixedDistance != 0f)
			{
				num6 += Vector3.Distance(markers[i].exitInnerVertices[num3 - 1], markers[i].exitInnerVertices[num3]);
				num5 += Vector3.Distance(markers[i].exitOuterVerticesExtrusion[0][markers[i].exitOuterVerticesExtrusion[0].Count - 1], markers[i].exitOuterVerticesFixed[0][0]);
			}
			else
			{
				num6 += Vector3.Distance(markers[i].exitInnerVertices[num3 - 1], markers[i].exitInnerVertices[num3]);
				num5 += Vector3.Distance(markers[i].exitOuterVerticesExtrusion[0][markers[i].exitOuterVerticesExtrusion[0].Count - 1], markers[i].exitOuterVerticesCurve[0][0]);
			}
			num4 = list.Count;
			list6.Add(num4 - 4);
			list6.Add(num4);
			list6.Add(num4 - 3);
			list6.Add(num4 - 2);
			list6.Add(num4);
			list6.Add(num4 + 1);
			list6.Add(num4 - 1);
			list6.Add(num4 - 2);
			list6.Add(num4 + 1);
			if (markers[i].fixedDistance != 0f)
			{
				for (int k = 0; k < markers[i].exitOuterVerticesFixed[0].Count; k++)
				{
					num4 = list.Count;
					list.Add(markers[i].exitInnerVertices[num3 + k]);
					list.Add(markers[i].exitOuterVerticesFixed[0][k]);
					if (k > 0)
					{
						num6 += Vector3.Distance(markers[i].exitInnerVertices[num3 + k - 1], markers[i].exitInnerVertices[num3 + k]);
						num5 += Vector3.Distance(markers[i].exitOuterVerticesFixed[0][k - 1], markers[i].exitOuterVerticesFixed[0][k]);
					}
					list2.Add(new Vector2(0f, num6 / num7));
					list2.Add(new Vector2(1f, num5 / num7));
					list3.Add(new Vector2(0f, num6 / num7));
					list3.Add(new Vector2(1f, num5 / num7));
					list4.Add(Color.white);
					list4.Add(Color.white);
					list5.Add(Color.white);
					list5.Add(Color.white);
					if (k < markers[i].exitOuterVerticesFixed[0].Count - 1)
					{
						list6.Add(num4);
						list6.Add(num4 + 2);
						list6.Add(num4 + 1);
						list6.Add(num4 + 1);
						list6.Add(num4 + 2);
						list6.Add(num4 + 3);
					}
				}
				num3 += markers[i].exitOuterVerticesFixed[0].Count;
				if (num3 < markers[i].exitInnerVertices.Count)
				{
					num6 += Vector3.Distance(markers[i].exitInnerVertices[num3 - 1], markers[i].exitInnerVertices[num3]);
				}
				if (markers[i].exitOuterVerticesCurve[0].Count > markers[i].exitOuterVerticesFixed[0].Count - 1 && markers[i].exitOuterVerticesCurve[0].Count > 0)
				{
					num5 += Vector3.Distance(markers[i].exitOuterVerticesFixed[0][markers[i].exitOuterVerticesFixed[0].Count - 1], markers[i].exitOuterVerticesCurve[0][0]);
				}
				num4 = list.Count;
				list6.Add(num4 - 2);
				list6.Add(num4);
				list6.Add(num4 - 1);
				list6.Add(num4 - 1);
				list6.Add(num4);
				list6.Add(num4 + 1);
			}
			for (int l = 0; l < markers[i].exitOuterVerticesCurve[0].Count; l++)
			{
				num4 = list.Count;
				list.Add(markers[i].exitInnerVertices[num3 + l]);
				list.Add(markers[i].exitOuterVerticesCurve[0][l]);
				if (l > 0)
				{
					num6 += Vector3.Distance(markers[i].exitInnerVertices[l - 1], markers[i].exitInnerVertices[l]);
					num5 += Vector3.Distance(markers[i].exitInnerVertices[l - 1], markers[i].exitInnerVertices[l]);
				}
				list2.Add(new Vector2(0f, num6 / num7));
				list2.Add(new Vector2(1f, num5 / num7));
				list3.Add(new Vector2(0f, num6 / num7));
				list3.Add(new Vector2(1f, num5 / num7));
				list4.Add(Color.white);
				list4.Add(Color.white);
				list5.Add(Color.white);
				list5.Add(Color.white);
				if (l < markers[i].exitOuterVerticesCurve[0].Count - 1)
				{
					list6.Add(num4);
					list6.Add(num4 + 2);
					list6.Add(num4 + 1);
					list6.Add(num4 + 1);
					list6.Add(num4 + 2);
					list6.Add(num4 + 3);
				}
			}
			num3 += markers[i].exitOuterVerticesCurve[0].Count;
			ODDDOCDCQO(list, list2, list6, list5, mat, gameObject, road);
		}
	}

	public static void OCDDDOQCCO(ERModularBase baseScript, List<ERMarkerExt> markers, ref List<Vector3> vecs, ref List<Vector2> uvsArray, ref List<Vector2> uvsArray2, ref List<Color> customColors, ref List<Color> colors, ref List<List<int>> tris, ref Material[] materialsList)
	{
		for (int i = 0; i < markers.Count; i++)
		{
			if (!markers[i].attachExit)
			{
				continue;
			}
			Material m = null;
			float x = 0.9f;
			float num = 5f;
			if (markers[i].exitRoadType != 0)
			{
				m = baseScript.roadTypes[markers[i].exitRoadType - 1].roadMaterial;
				num = baseScript.roadTypes[markers[i].exitRoadType - 1].roadWidth;
			}
			int triIndex = 0;
			OCDDCCQCCD(ref triIndex, ref tris, ref materialsList, m);
			int num2 = 0;
			int num3 = 0;
			float num4 = 0f;
			float num5 = 0f;
			float num6 = 5f;
			for (int j = 0; j < markers[i].exitOuterVerticesExtrusion[0].Count; j++)
			{
				num3 = vecs.Count;
				vecs.Add(markers[i].exitInnerVertices[j]);
				vecs.Add(markers[i].exitOuterVerticesExtrusion[1][j]);
				vecs.Add(markers[i].exitOuterVerticesExtrusion[1][j]);
				vecs.Add(markers[i].exitOuterVerticesExtrusion[0][j]);
				if (j > 0)
				{
					num5 += Vector3.Distance(markers[i].exitInnerVertices[j - 1], markers[i].exitInnerVertices[j]);
					num4 += Vector3.Distance(markers[i].exitOuterVerticesExtrusion[0][j - 1], markers[i].exitOuterVerticesExtrusion[0][j]);
				}
				float num7 = Vector3.Distance(markers[i].exitInnerVertices[j], markers[i].exitOuterVerticesExtrusion[1][j]);
				uvsArray.Add(new Vector2(0f, num5 / num6));
				uvsArray.Add(new Vector2(num7 / num, num5 / num6));
				uvsArray.Add(new Vector2(x, num4 / num6));
				uvsArray.Add(new Vector2(1f, num4 / num6));
				uvsArray2.Add(new Vector2(0f, num5 / num6));
				uvsArray2.Add(new Vector2(num7 / num, num5 / num6));
				uvsArray2.Add(new Vector2(x, num4 / num6));
				uvsArray2.Add(new Vector2(1f, num4 / num6));
				customColors.Add(Color.white);
				customColors.Add(Color.white);
				customColors.Add(Color.white);
				customColors.Add(Color.white);
				colors.Add(Color.white);
				colors.Add(Color.white);
				colors.Add(Color.white);
				colors.Add(Color.white);
				if (j < markers[i].exitOuterVerticesExtrusion[0].Count - 1)
				{
					tris[triIndex].Add(num3);
					tris[triIndex].Add(num3 + 4);
					tris[triIndex].Add(num3 + 1);
					tris[triIndex].Add(num3 + 1);
					tris[triIndex].Add(num3 + 4);
					tris[triIndex].Add(num3 + 5);
					tris[triIndex].Add(num3 + 2);
					tris[triIndex].Add(num3 + 6);
					tris[triIndex].Add(num3 + 3);
					tris[triIndex].Add(num3 + 3);
					tris[triIndex].Add(num3 + 6);
					tris[triIndex].Add(num3 + 7);
				}
				num2++;
			}
			if (markers[i].fixedDistance != 0f)
			{
				num5 += Vector3.Distance(markers[i].exitInnerVertices[num2 - 1], markers[i].exitInnerVertices[num2]);
				num4 += Vector3.Distance(markers[i].exitOuterVerticesExtrusion[0][markers[i].exitOuterVerticesExtrusion[0].Count - 1], markers[i].exitOuterVerticesFixed[0][0]);
			}
			else
			{
				num5 += Vector3.Distance(markers[i].exitInnerVertices[num2 - 1], markers[i].exitInnerVertices[num2]);
				num4 += Vector3.Distance(markers[i].exitOuterVerticesExtrusion[0][markers[i].exitOuterVerticesExtrusion[0].Count - 1], markers[i].exitOuterVerticesCurve[0][0]);
			}
			num3 = vecs.Count;
			tris[triIndex].Add(num3 - 4);
			tris[triIndex].Add(num3);
			tris[triIndex].Add(num3 - 3);
			tris[triIndex].Add(num3 - 2);
			tris[triIndex].Add(num3);
			tris[triIndex].Add(num3 + 1);
			tris[triIndex].Add(num3 - 1);
			tris[triIndex].Add(num3 - 2);
			tris[triIndex].Add(num3 + 1);
			if (markers[i].fixedDistance >= 1f)
			{
				for (int k = 0; k < markers[i].exitOuterVerticesFixed[0].Count; k++)
				{
					num3 = vecs.Count;
					vecs.Add(markers[i].exitInnerVertices[num2 + k]);
					vecs.Add(markers[i].exitOuterVerticesFixed[0][k]);
					if (k > 0)
					{
						num5 += Vector3.Distance(markers[i].exitInnerVertices[num2 + k - 1], markers[i].exitInnerVertices[num2 + k]);
						num4 += Vector3.Distance(markers[i].exitOuterVerticesFixed[0][k - 1], markers[i].exitOuterVerticesFixed[0][k]);
					}
					uvsArray.Add(new Vector2(0f, num5 / num6));
					uvsArray.Add(new Vector2(1f, num4 / num6));
					uvsArray2.Add(new Vector2(0f, num5 / num6));
					uvsArray2.Add(new Vector2(1f, num4 / num6));
					customColors.Add(Color.white);
					customColors.Add(Color.white);
					colors.Add(Color.white);
					colors.Add(Color.white);
					if (k < markers[i].exitOuterVerticesFixed[0].Count - 1)
					{
						tris[triIndex].Add(num3);
						tris[triIndex].Add(num3 + 2);
						tris[triIndex].Add(num3 + 1);
						tris[triIndex].Add(num3 + 1);
						tris[triIndex].Add(num3 + 2);
						tris[triIndex].Add(num3 + 3);
					}
				}
				num2 += markers[i].exitOuterVerticesFixed[0].Count;
				if (num2 < markers[i].exitInnerVertices.Count)
				{
					num5 += Vector3.Distance(markers[i].exitInnerVertices[num2 - 1], markers[i].exitInnerVertices[num2]);
				}
				if (markers[i].exitOuterVerticesCurve[0].Count > markers[i].exitOuterVerticesFixed[0].Count - 1 && markers[i].exitOuterVerticesCurve[0].Count > 0)
				{
					num4 += Vector3.Distance(markers[i].exitOuterVerticesFixed[0][markers[i].exitOuterVerticesFixed[0].Count - 1], markers[i].exitOuterVerticesCurve[0][0]);
				}
				num3 = vecs.Count;
				tris[triIndex].Add(num3 - 2);
				tris[triIndex].Add(num3);
				tris[triIndex].Add(num3 - 1);
				tris[triIndex].Add(num3 - 1);
				tris[triIndex].Add(num3);
				tris[triIndex].Add(num3 + 1);
			}
			for (int l = 0; l < markers[i].exitOuterVerticesCurve[0].Count; l++)
			{
				num3 = vecs.Count;
				vecs.Add(markers[i].exitInnerVertices[num2 + l]);
				vecs.Add(markers[i].exitOuterVerticesCurve[0][l]);
				if (l > 0)
				{
					num5 += Vector3.Distance(markers[i].exitInnerVertices[l - 1], markers[i].exitInnerVertices[l]);
					num4 += Vector3.Distance(markers[i].exitInnerVertices[l - 1], markers[i].exitInnerVertices[l]);
				}
				uvsArray.Add(new Vector2(0f, num5 / num6));
				uvsArray.Add(new Vector2(1f, num4 / num6));
				uvsArray2.Add(new Vector2(0f, num5 / num6));
				uvsArray2.Add(new Vector2(1f, num4 / num6));
				customColors.Add(Color.white);
				customColors.Add(Color.white);
				colors.Add(Color.white);
				colors.Add(Color.white);
				if (l < markers[i].exitOuterVerticesCurve[0].Count - 1)
				{
					tris[triIndex].Add(num3);
					tris[triIndex].Add(num3 + 2);
					tris[triIndex].Add(num3 + 1);
					tris[triIndex].Add(num3 + 1);
					tris[triIndex].Add(num3 + 2);
					tris[triIndex].Add(num3 + 3);
				}
			}
			num2 += markers[i].exitOuterVerticesCurve[0].Count;
		}
	}

	public static void OCDDCCQCCD(ref int triIndex, ref List<List<int>> tris, ref Material[] materialsList, Material m)
	{
		for (int i = 0; i < materialsList.Length; i++)
		{
			if (materialsList[i] == m)
			{
				triIndex = i;
				return;
			}
		}
		tris.Add(new List<int>());
		triIndex = tris.Count - 1;
		List<Material> list = new List<Material>(materialsList);
		list.Add(m);
		materialsList = list.ToArray();
	}

	public static float OQQDDDDDOC(Vector3 v, List<Vector3> soSplinePointsLeft, List<Vector3> soSplinePointsRight, ref int cInt, bool flag, ref int match)
	{
		for (int i = cInt; i < soSplinePointsLeft.Count; i++)
		{
			if (ODQDQDQDQO.OQCDCDOOCD(soSplinePointsRight[i], soSplinePointsLeft[i], v))
			{
				match = i;
				if (flag)
				{
					cInt = i;
				}
				return ODQDQDQDQO.OQDDCCCOQD(soSplinePointsLeft[i - 1], soSplinePointsLeft[i], soSplinePointsRight[i], v);
			}
		}
		return v.y;
	}

	private static void ODDDOCDCQO(List<Vector3> vecs, List<Vector2> uvs, List<int> tris, List<Color> colors, Material mat, GameObject go, ERModularRoad road)
	{
		if (go == null)
		{
			go = new GameObject("exit");
			go.AddComponent<MeshFilter>();
			go.AddComponent<MeshRenderer>();
			go.AddComponent<MeshCollider>();
			go.GetComponent<MeshRenderer>().material = mat;
			go.transform.parent = road.transform;
			go.layer = road.gameObject.layer;
		}
		if (go.GetComponent<MeshFilter>() == null)
		{
			go.AddComponent<MeshFilter>();
		}
		if (go.GetComponent<MeshRenderer>() == null)
		{
			go.AddComponent<MeshRenderer>();
		}
		go.GetComponent<MeshRenderer>().material = mat;
		Mesh mesh;
		if (go.GetComponent<MeshFilter>().sharedMesh != null)
		{
			mesh = go.GetComponent<MeshFilter>().sharedMesh;
		}
		else
		{
			mesh = new Mesh();
			go.GetComponent<MeshFilter>().sharedMesh = mesh;
			if (go.GetComponent<MeshCollider>() == null)
			{
				go.AddComponent<MeshCollider>();
			}
			go.GetComponent<MeshCollider>().sharedMesh = mesh;
		}
		if (go.GetComponent<MeshCollider>() == null)
		{
			go.AddComponent<MeshCollider>();
			go.GetComponent<MeshCollider>().sharedMesh = mesh;
		}
		mesh.Clear();
		mesh.vertices = vecs.ToArray();
		mesh.uv = uvs.ToArray();
		mesh.colors = colors.ToArray();
		mesh.triangles = tris.ToArray();
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();
		mesh.RecalculateTangents();
		go.GetComponent<MeshCollider>().sharedMesh = null;
		go.GetComponent<MeshCollider>().sharedMesh = mesh;
	}

	private void OCCDCQQDOQ(List<Vector3> vecs, List<int> connectionInts, List<Vector3> surfaceVecs, Vector3 prefDirVec)
	{
		if (connector == null)
		{
			GameObject gameObject = new GameObject("Exit Road Connector");
			ERConnectionParent eRConnectionParent = (ERConnectionParent)UnityEngine.Object.FindObjectOfType(typeof(ERConnectionParent));
			if (eRConnectionParent != null)
			{
				gameObject.transform.parent = eRConnectionParent.transform;
			}
			connector = gameObject.AddComponent<ERCrossingPrefabs>();
			connector.crossingElements.Add(new QDOODOQQDQODD());
			connector.isExitRoadConnector = true;
			connector.isSnapConnector = true;
		}
		if (connector == null)
		{
			UnityEngine.Debug.Log("EasyRooads3D warning: No connector attached to exit road");
			return;
		}
		if (connector.crossingElements.Count == 0)
		{
			connector.crossingElements.Add(new QDOODOQQDQODD());
		}
		connector.meshVecs = vecs.ToArray();
		connector.tmpMeshVecs = new Vector3[connector.meshVecs.Length];
		Array.Copy(connector.meshVecs, connector.tmpMeshVecs, connector.meshVecs.Length);
		connector.tmpFullMeshVecs = new Vector3[connector.meshVecs.Length];
		Array.Copy(connector.meshVecs, connector.tmpFullMeshVecs, connector.meshVecs.Length);
		connector.fullMeshVecs = new Vector3[connector.meshVecs.Length];
		Array.Copy(connector.meshVecs, connector.fullMeshVecs, connector.meshVecs.Length);
		Vector3 normalized = (vecs[0] - vecs[1]).normalized;
		Vector3 normalized2 = (prefDirVec - vecs[0]).normalized;
		Vector3 vector = base.transform.InverseTransformPoint(connectionHandlePosition);
		connector.crossingElements[0].centerPoint = (connector.crossingElements[0].tmpCenterPoint = vector);
		connector.crossingElements[0].controlPointV3 = vector + normalized2 * 15f;
		connector.isExitRoadConnector = true;
		connector.prefabCenterDummy = prefDirVec;
		connector.crossingElements[0].connectionVecInts = new List<int>(connectionInts);
		connector.crossingElements[0].fullConnectionVecInts = new List<int>(connectionInts);
		Vector3 leftSurroundingV = vecs[0] + normalized * 8f;
		connector.crossingElements[0].leftSurroundingV3 = leftSurroundingV;
		leftSurroundingV = vecs[1] + -normalized * 8f;
		connector.crossingElements[0].rightSurroundingV3 = leftSurroundingV;
		leftSurroundingV = vecs[0] + normalized * 3f;
		connector.crossingElements[0].leftIndentV3 = leftSurroundingV;
		leftSurroundingV = vecs[1] + -normalized * 3f;
		connector.crossingElements[0].rightIndentV3 = leftSurroundingV;
		int num = 0;
		int num2 = connectionInts.Count - 1;
		connector.crossingElements[0].leftInt = num;
		connector.crossingElements[0].leftIntFull = num;
		connector.crossingElements[0].rightInt = num2;
		connector.crossingElements[0].rightIntFull = num2;
		connector.crossingElements[0].leftSurroundingV3 = surfaceVecs[surfaceVecs.Count - 1];
		connector.crossingElements[0].leftIndentV3 = surfaceVecs[surfaceVecs.Count - 2];
		connector.crossingElements[0].rightIndentV3 = surfaceVecs[surfaceVecs.Count - 4];
		connector.crossingElements[0].rightSurroundingV3 = surfaceVecs[surfaceVecs.Count - 5];
		connector.crossingElements[0].leftSurrounding = surfaceVecs.Count - 1;
		connector.crossingElements[0].leftIndent = surfaceVecs.Count - 2;
		connector.crossingElements[0].rightIndent = surfaceVecs.Count - 4;
		connector.crossingElements[0].rightSurrounding = surfaceVecs.Count - 5;
		connector.crossingElements[0].roadShapeVecs = new List<Vector2>(roadType.roadShape);
		connector.crossingElements[0].roadShapeUVY = new List<float>(roadType.roadShapeUVs);
		connector.crossingElements[0].roadShapeUVY2 = new List<float>(roadType.roadShapeUVs2);
		connector.surfaceMeshVecs = surfaceVecs.ToArray();
		connector.crossingElements[0].roadType = roadType.id;
		connector.crossingElements[0].roadShapeMatchCount = vecs.Count;
		connector.doTerrainDeformation = road.terrainDeformation;
	}

	public Vector3 ODCCQQDQQQ()
	{
		Vector3 pos = Vector3.zero;
		int num = ODQDQDQDQO.OCOODQDDDO(road.soSplinePoints, offset * road.markersExt[markerIndex].totalDistance, road.markersExt[markerIndex].startSplinePoint, ref pos);
		OCODOQDODQ = ODQDQDQDQO.OQQCQOCCOQ(road.soSplinePointsRight[num], road.soSplinePointsRight[num + 1], pos);
		handleDirection = (road.soSplinePointsRight[num + 1] - road.soSplinePointsRight[num]).normalized;
		if (road != null && roadType == null)
		{
			roadType = QDQDOOQQDQODD.GetRoadTypeElByID(road.baseScript.roadTypes, roadTypeID);
		}
		if (roadType != null)
		{
			Vector3 normalized = (OCODOQDODQ - pos).normalized;
			OCODOQDODQ -= normalized;
		}
		return OCODOQDODQ;
	}

	public void OCQOQQCDOD(List<Vector3> surfaceVecs, List<Vector2> uvs, int firstSection, int secondSection)
	{
		if (surfaceMesh == null)
		{
			ERSurfaceScript componentInChildren = base.gameObject.GetComponentInChildren<ERSurfaceScript>();
			if (componentInChildren != null)
			{
				surfaceMesh = componentInChildren.gameObject;
			}
		}
		if (surfaceMesh == null)
		{
			surfaceMesh = new GameObject("surface");
			surfaceMesh.hideFlags = HideFlags.HideInHierarchy;
			surfaceMesh.AddComponent<MeshFilter>();
			surfaceMesh.AddComponent<MeshRenderer>();
			surfaceMesh.AddComponent<MeshCollider>();
			surfaceMesh.AddComponent<ERSurfaceScript>();
			surfaceMesh.GetComponent<MeshRenderer>().material = Resources.Load("Materials/surfaceMaterial") as Material;
			surfaceMesh.transform.parent = base.transform;
			surfaceMesh.GetComponent<MeshRenderer>().enabled = !road.baseScript.hideSurfaces;
			surfaceMesh.GetComponent<MeshCollider>().enabled = !road.baseScript.hideSurfaces;
			surfaceMesh.layer = road.baseScript.sLayer;
		}
		if (surfaceMesh.GetComponent<MeshFilter>() == null)
		{
			surfaceMesh.AddComponent<MeshFilter>();
		}
		Mesh mesh;
		if (surfaceMesh.GetComponent<MeshFilter>().sharedMesh != null)
		{
			mesh = surfaceMesh.GetComponent<MeshFilter>().sharedMesh;
		}
		else
		{
			mesh = new Mesh();
			surfaceMesh.GetComponent<MeshFilter>().sharedMesh = mesh;
			if (surfaceMesh.GetComponent<MeshCollider>() == null)
			{
				surfaceMesh.AddComponent<MeshCollider>();
			}
			surfaceMesh.GetComponent<MeshCollider>().sharedMesh = mesh;
		}
		if (surfaceMesh.GetComponent<MeshCollider>() == null)
		{
			surfaceMesh.AddComponent<MeshCollider>();
			surfaceMesh.GetComponent<MeshCollider>().sharedMesh = mesh;
		}
		if (!road.terrainDeformation)
		{
			UnityEngine.Object.DestroyImmediate(surfaceMesh);
			return;
		}
		surfaceMesh.hideFlags = HideFlags.None;
		surfaceMesh.layer = road.baseScript.sLayer;
		int num = 0;
		List<int> list = new List<int>();
		int num2 = 3;
		int num3 = 1;
		int num4 = firstSection + 1;
		for (int i = 0; i < num4 - 1; i += num3)
		{
			for (int j = 0; j < num2 - 1; j++)
			{
				list.Add(num + j);
				list.Add(num + num2 + j + 1);
				list.Add(num + j + 1);
				list.Add(num + num2 + j);
				list.Add(num + num2 + j + 1);
				list.Add(num + j);
			}
			num += 3;
		}
		num += 3;
		surfaceVecs[num - 3] = surfaceVecs[num + 1];
		surfaceVecs[num - 2] = surfaceVecs[num + 3];
		surfaceVecs[num - 1] = surfaceVecs[num + 4];
		secondSection += firstSection;
		num2 = 5;
		for (int k = firstSection; k < secondSection; k += num3)
		{
			for (int l = 0; l < num2 - 1; l++)
			{
				list.Add(num + l);
				list.Add(num + num2 + l + 1);
				list.Add(num + l + 1);
				list.Add(num + num2 + l);
				list.Add(num + num2 + l + 1);
				list.Add(num + l);
			}
			num += 5;
		}
		mesh.Clear();
		mesh.vertices = surfaceVecs.ToArray();
		mesh.uv = uvs.ToArray();
		mesh.tangents = new Vector4[surfaceVecs.Count];
		mesh.triangles = list.ToArray();
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();
		surfaceMesh.GetComponent<MeshCollider>().sharedMesh = null;
		surfaceMesh.GetComponent<MeshCollider>().sharedMesh = mesh;
		if (surfaceMesh.GetComponent<MeshCollider>().sharedMesh == null)
		{
			UnityEngine.Object.DestroyImmediate(surfaceMesh.GetComponent<MeshCollider>());
			surfaceMesh.AddComponent<MeshCollider>();
			if (surfaceMesh.GetComponent<MeshCollider>().sharedMesh == null)
			{
				UnityEngine.Debug.LogWarning("EasyRoads3Dv3 Warning: No mesh assigned to the surface mesh Collider");
			}
		}
		if (road.baseScript.hideSurfaces)
		{
			surfaceMesh.GetComponent<MeshCollider>().enabled = false;
			surfaceMesh.SetActive(value: false);
			surfaceMesh.SetActive(value: true);
			return;
		}
		if ((bool)surfaceMesh.GetComponent<MeshRenderer>())
		{
			surfaceMesh.GetComponent<MeshRenderer>().enabled = true;
		}
		if ((bool)surfaceMesh.GetComponent<MeshCollider>())
		{
			surfaceMesh.GetComponent<MeshCollider>().enabled = true;
		}
	}
}
[AddComponentMenu("")]
public class ERMeshUtility : MonoBehaviour
{
	public ERModularBase baseScript;

	public int sourceInt = 0;

	public new string name = "";

	public void OCQOQCDCQC()
	{
	}
}
public class ERRoadNetwork
{
	public delegate void RoadUpdateCallback(ERRoad road);

	public delegate void BuildModeCallback();

	public delegate void EditModeCallback();

	public ERModularBase roadNetwork;

	public bool isInBuildMode = false;

	public string str = "EasyRoads3Dv3 Warning: The free version does not support API calls";

	public static RoadUpdateCallback onRoadUpdate;

	public static BuildModeCallback onBuildModeEnter;

	public static EditModeCallback onEditModeEnter;

	public static void OnBuildModeEnter()
	{
		if (onBuildModeEnter != null)
		{
			onBuildModeEnter();
		}
	}

	public static void OnEditModeEnter()
	{
		if (onEditModeEnter != null)
		{
			onEditModeEnter();
		}
	}

	public static void OnRoadUpdated(ERRoad road)
	{
		if (onRoadUpdate != null)
		{
			onRoadUpdate(road);
		}
	}

	public ERRoadNetwork()
	{
		roadNetwork = UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase;
		if (roadNetwork == null)
		{
			GameObject gameObject = Resources.Load("ERRoadNetwork") as GameObject;
			if (gameObject == null)
			{
				gameObject = Resources.Load("ER Road Network") as GameObject;
			}
			if (gameObject == null)
			{
				return;
			}
			gameObject = UnityEngine.Object.Instantiate(gameObject);
			roadNetwork = gameObject.GetComponent<ERModularBase>();
			gameObject.name = "Road Network";
			gameObject.transform.position = Vector3.zero;
			roadNetwork.RoadNetworkInit();
		}
		bool multTerrainResFlag = false;
		roadNetwork.OODQQODOOC(ref multTerrainResFlag);
		roadNetwork.ODCDQQCQOC();
		if (!ERModularBase.AssembliesSet)
		{
			roadNetwork.OCQODDDCQQ();
		}
	}

	public void GetTerrainData()
	{
		bool multTerrainResFlag = false;
		roadNetwork.OODQQODOOC(ref multTerrainResFlag);
	}

	public ERTrafficDirection GetTrafficDirection()
	{
		if (roadNetwork.rightHandDriving == 0)
		{
			return ERTrafficDirection.LHT;
		}
		return ERTrafficDirection.RHT;
	}

	public void Translate(Vector3 pos)
	{
		ERModularRoad[] componentsInChildren = roadNetwork.gameObject.GetComponentsInChildren<ERModularRoad>();
		ERModularRoad[] array = componentsInChildren;
		foreach (ERModularRoad eRModularRoad in array)
		{
			foreach (ERMarkerExt item in eRModularRoad.markersExt)
			{
				item.position += pos;
			}
		}
		ERCrossingPrefabs[] componentsInChildren2 = roadNetwork.gameObject.GetComponentsInChildren<ERCrossingPrefabs>();
		ERCrossingPrefabs[] array2 = componentsInChildren2;
		foreach (ERCrossingPrefabs eRCrossingPrefabs in array2)
		{
			eRCrossingPrefabs.gameObject.transform.position += pos;
		}
		ODQDQDQDQOExt.OOODCQCQOC(roadNetwork);
	}

	public void CenterPivotPoints()
	{
		ERModularRoad[] componentsInChildren = roadNetwork.gameObject.GetComponentsInChildren<ERModularRoad>();
		ERModularRoad[] array = componentsInChildren;
		foreach (ERModularRoad eRModularRoad in array)
		{
			Vector3 zero = Vector3.zero;
			foreach (ERMarkerExt item in eRModularRoad.markersExt)
			{
				zero += item.position;
			}
			zero /= (float)eRModularRoad.markersExt.Count;
			Mesh mesh = null;
			bool flag = false;
			MeshFilter component = eRModularRoad.GetComponent<MeshFilter>();
			if (component != null && component.sharedMesh != null)
			{
				mesh = component.sharedMesh;
			}
			MeshFilter[] componentsInChildren2 = eRModularRoad.gameObject.GetComponentsInChildren<MeshFilter>();
			MeshFilter[] array2 = componentsInChildren2;
			foreach (MeshFilter meshFilter in array2)
			{
				if (!(meshFilter.sharedMesh != null))
				{
					continue;
				}
				if (meshFilter.transform.position == Vector3.zero)
				{
					Mesh sharedMesh = meshFilter.sharedMesh;
					if (sharedMesh != mesh || !flag)
					{
						Vector3[] vertices = sharedMesh.vertices;
						for (int k = 0; k < vertices.Length; k++)
						{
							vertices[k] -= zero;
						}
						sharedMesh.vertices = vertices;
						if ((bool)meshFilter.gameObject.GetComponent<MeshCollider>())
						{
							meshFilter.gameObject.GetComponent<MeshCollider>().sharedMesh = null;
							meshFilter.gameObject.GetComponent<MeshCollider>().sharedMesh = sharedMesh;
						}
						sharedMesh.RecalculateBounds();
						if (sharedMesh == mesh)
						{
							flag = true;
						}
					}
					else if (sharedMesh == mesh && (bool)meshFilter.gameObject.GetComponent<MeshCollider>())
					{
						meshFilter.gameObject.GetComponent<MeshCollider>().sharedMesh = null;
						meshFilter.gameObject.GetComponent<MeshCollider>().sharedMesh = sharedMesh;
					}
				}
				else if (meshFilter.GetComponent<ERPrefabInstance>() != null)
				{
					if (!meshFilter.GetComponent<ERPrefabInstance>().child)
					{
						meshFilter.transform.position -= zero;
					}
				}
				else if (meshFilter.transform.parent.GetComponent<ERPrefabInstance>() != null && !meshFilter.transform.parent.GetComponent<ERPrefabInstance>().child)
				{
					meshFilter.transform.parent.position -= zero;
				}
			}
			eRModularRoad.transform.position = zero;
			if ((bool)eRModularRoad.GetComponent<LODGroup>())
			{
				eRModularRoad.GetComponent<LODGroup>().RecalculateBounds();
			}
		}
	}

	public ERRoad[] GetRoads()
	{
		ERModularRoad[] componentsInChildren = roadNetwork.gameObject.GetComponentsInChildren<ERModularRoad>();
		List<ERRoad> list = new List<ERRoad>();
		ERModularRoad[] array = componentsInChildren;
		foreach (ERModularRoad eRModularRoad in array)
		{
			if (eRModularRoad.road == null)
			{
				eRModularRoad.road = new ERRoad(eRModularRoad);
			}
			list.Add(eRModularRoad.road);
		}
		return list.ToArray();
	}

	public ERRoad GetRoadByName(string name)
	{
		ERModularRoad[] componentsInChildren = roadNetwork.gameObject.GetComponentsInChildren<ERModularRoad>();
		ERRoad result = null;
		ERModularRoad[] array = componentsInChildren;
		foreach (ERModularRoad eRModularRoad in array)
		{
			if (eRModularRoad.name == name)
			{
				if (eRModularRoad.road == null)
				{
					eRModularRoad.road = new ERRoad(eRModularRoad);
				}
				result = eRModularRoad.road;
				break;
			}
		}
		return result;
	}

	public ERRoad GetRoadByGameObject(GameObject go)
	{
		ERModularRoad component = go.GetComponent<ERModularRoad>();
		ERRoad result = null;
		if (component != null)
		{
			if (component.road == null)
			{
				component.road = new ERRoad(component);
			}
			result = component.road;
		}
		return result;
	}

	public ERRoad CreateRoad(string roadName)
	{
		ERModularRoad eRModularRoad = InitRoad(roadName, null, null);
		eRModularRoad.road = new ERRoad(eRModularRoad);
		return eRModularRoad.road;
	}

	public ERRoad CreateRoad(string roadName, Vector3[] markers)
	{
		ERModularRoad eRModularRoad = InitRoad(roadName, null, null);
		eRModularRoad.road = new ERRoad(eRModularRoad);
		ERRoad road = eRModularRoad.road;
		AddInititialMarkers(road, markers);
		eRModularRoad.OCQOQCDCQC(ignorePrefabAlignment: false, forceAutoRotate: false);
		return road;
	}

	public ERRoad CreateRoad(string roadName, ERRoadType roadType)
	{
		ERModularRoad eRModularRoad = InitRoad(roadName, roadType, null);
		eRModularRoad.road = new ERRoad(eRModularRoad);
		ERRoad road = eRModularRoad.road;
		if (roadType != null)
		{
			road.SetWidth(roadType.roadWidth);
			road.SetMaterial(roadType.roadMaterial);
			road.roadScript.roadShape = new List<Vector2>(roadType.roadShape);
			road.roadScript.doConnectionTri = new List<bool>(roadType.doConnectionTri);
			road.roadScript.roadShapeUVs = new List<float>(roadType.roadShapeUVs);
			road.roadScript.roadShapeUVs2 = new List<float>(roadType.roadShapeUVs2);
			road.roadScript.hardEdge = new List<bool>(roadType.hardEdge);
			road.IsSideObject(roadType.isSideObject);
			if (roadType.isSideObject)
			{
				road.roadScript.snapToTerrain = true;
			}
			UnityEngine.Debug.Log(roadType.roadTypeName);
			road.SetSideObjects(roadType.soDataExt);
			eRModularRoad.gameObject.layer = (eRModularRoad.layer = roadType.layer);
			if (!string.IsNullOrEmpty(roadType.tag))
			{
				eRModularRoad.gameObject.tag = (eRModularRoad.tag = roadType.tag);
			}
			eRModularRoad.hasMeshCollider = roadType.hasMeshCollider;
			eRModularRoad.terrainDeformation = roadType.terrainDeformation;
		}
		else
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3: the passed road type is null");
		}
		return road;
	}

	public ERRoad CreateRoad(string roadName, ERRoadType roadType, Vector3[] markers)
	{
		ERModularRoad eRModularRoad = InitRoad(roadName, roadType, null);
		eRModularRoad.road = new ERRoad(eRModularRoad);
		ERRoad road = eRModularRoad.road;
		if (roadType != null)
		{
			road.SetWidth(roadType.roadWidth);
			road.roadScript.roadShape = new List<Vector2>(roadType.roadShape);
			road.roadScript.doConnectionTri = new List<bool>(roadType.doConnectionTri);
			road.roadScript.roadShapeUVs = new List<float>(roadType.roadShapeUVs);
			road.roadScript.roadShapeUVs2 = new List<float>(roadType.roadShapeUVs2);
			road.roadScript.hardEdge = new List<bool>(roadType.hardEdge);
			road.SetMaterial(roadType.roadMaterial);
			road.IsSideObject(roadType.isSideObject);
			if (roadType.isSideObject)
			{
				road.roadScript.snapToTerrain = true;
			}
			road.SetSideObjects(roadType.soDataExt);
			eRModularRoad.gameObject.layer = (eRModularRoad.layer = roadType.layer);
			if (!string.IsNullOrEmpty(roadType.tag))
			{
				eRModularRoad.gameObject.tag = (eRModularRoad.tag = roadType.tag);
			}
			eRModularRoad.hasMeshCollider = roadType.hasMeshCollider;
			eRModularRoad.terrainDeformation = roadType.terrainDeformation;
			road.SetRoadType(roadType);
		}
		else
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3: the passed road type is null");
		}
		AddInititialMarkers(road, markers);
		road.Refresh();
		return road;
	}

	public ERModularRoad InitRoad(string roadName, ERRoadType roadType, Material roadMaterial)
	{
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(Resources.Load("ERProRoad"));
		if (roadName == "")
		{
			roadName = "road";
		}
		gameObject.name = roadName;
		gameObject.AddComponent<MeshFilter>();
		gameObject.AddComponent<MeshRenderer>();
		if (roadMaterial != null)
		{
			gameObject.GetComponent<MeshRenderer>().sharedMaterial = roadMaterial;
		}
		else
		{
			gameObject.GetComponent<MeshRenderer>().sharedMaterial = Resources.Load("Materials/roads/road material") as Material;
		}
		gameObject.transform.position = Vector3.zero;
		gameObject.transform.parent = roadNetwork.roadObjectsParent;
		ERModularRoad component = gameObject.GetComponent<ERModularRoad>();
		component.roadMaterial = gameObject.GetComponent<MeshRenderer>().sharedMaterial;
		component.roadMaterials = new List<Material>(gameObject.GetComponent<MeshRenderer>().sharedMaterials).ToArray();
		component.roadName = roadName;
		component.roadWidth = 6f;
		component.doSurroundingSurfaces = true;
		if (roadType != null)
		{
			component.roadShape = new List<Vector2>(roadType.roadShape);
			component.doConnectionTri = new List<bool>(roadType.doConnectionTri);
			component.roadShapeUVs = new List<float>(roadType.roadShapeUVs);
			component.roadShapeUVs2 = new List<float>(roadType.roadShapeUVs2);
			component.hardEdge = new List<bool>(roadType.hardEdge);
		}
		component.indent = roadNetwork.minIndent;
		component.surrounding = roadNetwork.minSurrounding;
		int num = -1;
		if (roadType != null)
		{
			component.gameObject.layer = (component.layer = roadType.layer);
			if (!string.IsNullOrEmpty(roadType.tag))
			{
				component.gameObject.tag = (component.tag = roadType.tag);
			}
			component.hasMeshCollider = roadType.hasMeshCollider;
			component.terrainDeformation = roadType.terrainDeformation;
			for (int i = 0; i < roadNetwork.roadTypes.Count; i++)
			{
				if (roadNetwork.roadTypes[i].id == roadType.id)
				{
					num = i;
					break;
				}
			}
		}
		if (num != -1)
		{
			QDQDOOQQDQODD.AssignSideObjects(roadNetwork, num, component);
		}
		else
		{
			ODDQODOOOC.OOCOCOOQCC(roadNetwork.QOQDQOOQDDQOOQ, ref component.soDataExt);
		}
		return component;
	}

	public void AddInititialMarkers(ERRoad road, Vector3[] markers)
	{
		for (int i = 0; i < markers.Length; i++)
		{
			if (road.roadScript.snapToTerrain)
			{
				Vector3 pos = markers[i];
				road.roadScript.baseScript.OCDDQOCDCO(ref pos);
				markers[i] = pos;
			}
			road.AddInititialMarkers(markers[i]);
		}
	}

	public void AddIntersection(ERCrossingPrefabs crossing, GameObject crossingPrefab)
	{
	}

	public void BuildRoadNetwork(bool splatmaps, bool trees, bool detail, ERRoad[] roads)
	{
		roadNetwork.selectedObjects.Clear();
		foreach (ERRoad eRRoad in roads)
		{
			roadNetwork.selectedObjects.Add(SelectedObject.CreateInstance(eRRoad.roadScript, null, 0));
		}
		roadNetwork.selectedRoadsOnly = true;
		roadNetwork.doSplatmaps = splatmaps;
		roadNetwork.doTrees = trees;
		roadNetwork.doDetail = detail;
		DoBuildRoadNetwork();
		roadNetwork.selectedRoadsOnly = false;
		roadNetwork.selectedObjects.Clear();
	}

	public void BuildRoadNetwork(bool splatmaps, bool trees, bool detail)
	{
		roadNetwork.doSplatmaps = splatmaps;
		roadNetwork.doTrees = trees;
		roadNetwork.doDetail = detail;
		DoBuildRoadNetwork();
	}

	public void BuildRoadNetwork()
	{
		roadNetwork.doSplatmaps = false;
		roadNetwork.doTrees = false;
		roadNetwork.doDetail = false;
		DoBuildRoadNetwork();
	}

	public void DoBuildRoadNetwork()
	{
		List<Terrain> list = new List<Terrain>();
		Terrain[] terrainObjects = roadNetwork.terrainObjects;
		foreach (Terrain terrain in terrainObjects)
		{
			if (terrain != null && terrain.terrainData != null)
			{
				list.Add(terrain);
			}
		}
		roadNetwork.surfaceObjects.Clear();
		if (list.Count == 0)
		{
			UnityEngine.Debug.Log("Currently no Unity terrain objects are present!");
			QDQDOOQQOOQDD.OQOQCCCODC(roadNetwork, ref QDQDOOQQOOQDD.minx, ref QDQDOOQQOOQDD.minz, ref QDQDOOQQOOQDD.maxx, ref QDQDOOQQOOQDD.maxz, 0f);
		}
		else
		{
			isInBuildMode = true;
			roadNetwork.terrainDone = true;
			QDQDOOQQOOQDD.minx = (QDQDOOQQOOQDD.minz = 100000f);
			QDQDOOQQOOQDD.maxx = (QDQDOOQQOOQDD.maxz = -100000f);
			QDQDOOQQOOQDD.surfaceObjects.Clear();
			QDQDOOQQOOQDD.treeObjects.Clear();
			QDQDOOQQOOQDD.detailObjects.Clear();
			roadNetwork.soSplatmapObjects.Clear();
			QDQDOOQQOOQDD.OQOQCCCODC(splatmapScale: (!(list[0].terrainData.size.x > list[0].terrainData.size.z)) ? (list[0].terrainData.size.z / (float)list[0].terrainData.alphamapResolution) : (list[0].terrainData.size.x / (float)list[0].terrainData.alphamapResolution), scr: roadNetwork, minx: ref QDQDOOQQOOQDD.minx, minz: ref QDQDOOQQOOQDD.minz, maxx: ref QDQDOOQQOOQDD.maxx, maxz: ref QDQDOOQQOOQDD.maxz);
			ERTerrain[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERTerrain)) as ERTerrain[];
			roadNetwork.surfaceObjects.AddRange(QDQDOOQQOOQDD.surfaceObjects);
			int num = 1;
			foreach (Terrain item in list)
			{
				ERTerrain component = item.gameObject.GetComponent<ERTerrain>();
				if (component != null)
				{
					QDQDOOQQOOQDD.ODCQDDOQCD(roadNetwork, component, item, QDQDOOQQOOQDD.minx, QDQDOOQQOOQDD.maxx, QDQDOOQQOOQDD.minz, QDQDOOQQOOQDD.maxz);
				}
				else
				{
					UnityEngine.Debug.LogWarning("ER terrain script missing on terrain object: " + item);
				}
				num++;
			}
		}
		foreach (GameObject surfaceObject in QDQDOOQQOOQDD.surfaceObjects)
		{
			if (surfaceObject != null)
			{
				surfaceObject.SetActive(value: false);
			}
		}
		foreach (GameObject treeObject in QDQDOOQQOOQDD.treeObjects)
		{
			if (treeObject != null)
			{
				UnityEngine.Object.DestroyImmediate(treeObject);
			}
		}
		foreach (GameObject detailObject in QDQDOOQQOOQDD.detailObjects)
		{
			if (detailObject != null)
			{
				UnityEngine.Object.DestroyImmediate(detailObject);
			}
		}
		foreach (GameObject soSplatmapObject in roadNetwork.soSplatmapObjects)
		{
			if (soSplatmapObject != null)
			{
				UnityEngine.Object.DestroyImmediate(soSplatmapObject);
			}
		}
		roadNetwork.terrainDone = true;
		roadNetwork.baseVector = new Vector3(0f, roadNetwork.raise, 0f);
		Transform transform = roadNetwork.transform.Find("Connection Objects");
		if (transform != null)
		{
			transform.position = roadNetwork.baseVector;
		}
		transform = roadNetwork.transform.Find("Road Objects");
		if (transform != null)
		{
			transform.position = roadNetwork.baseVector;
		}
		roadNetwork.ODODOQOODO();
	}

	public void RestoreRoadNetwork()
	{
		roadNetwork.OQQQDCQOOC(restoreTerrain: true);
		isInBuildMode = (roadNetwork.terrainDone = false);
	}

	public ERRoadType[] GetRoadTypes()
	{
		return roadNetwork.GetRoadTypes();
	}

	public ERRoadType GetRoadTypeByName(string name)
	{
		return roadNetwork.GetRoadTypeByName(name);
	}

	public SideObject GetSideObjectByName(string name)
	{
		return roadNetwork.OQCDCQCDCQ(name);
	}

	public ERRoadType AddRoadType()
	{
		return null;
	}

	public void HideWhiteSurfaces(bool flag)
	{
		roadNetwork.hideSurfaces = flag;
		roadNetwork.OOCDOOCQQC();
	}

	public ERConnection[] GetConnections()
	{
		List<ERConnection> list = new List<ERConnection>();
		ERCrossingPrefabs[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERCrossingPrefabs)) as ERCrossingPrefabs[];
		ERCrossingPrefabs[] array2 = array;
		foreach (ERCrossingPrefabs eRCrossingPrefabs in array2)
		{
			list.Add(ERConnection.Create(eRCrossingPrefabs.gameObject));
		}
		return list.ToArray();
	}

	public ERConnection GetConnectionByName(string name)
	{
		ERCrossingPrefabs[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERCrossingPrefabs)) as ERCrossingPrefabs[];
		ERCrossingPrefabs[] array2 = array;
		foreach (ERCrossingPrefabs eRCrossingPrefabs in array2)
		{
			if (eRCrossingPrefabs.gameObject.name == name)
			{
				return ERConnection.Create(eRCrossingPrefabs.gameObject);
			}
		}
		return null;
	}

	public ERConnection[] LoadConnections()
	{
		List<ERConnection> list = new List<ERConnection>();
		UnityEngine.Object[] array = Resources.LoadAll("custom prefabs", typeof(GameObject));
		UnityEngine.Object[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			GameObject gameObject = (GameObject)array2[i];
			if ((bool)gameObject.GetComponent<ERCrossingPrefabs>())
			{
				list.Add(ERConnection.Create(gameObject));
			}
		}
		array = Resources.LoadAll("dynamic prefabs", typeof(GameObject));
		UnityEngine.Object[] array3 = array;
		for (int j = 0; j < array3.Length; j++)
		{
			GameObject gameObject2 = (GameObject)array3[j];
			if ((bool)gameObject2.GetComponent<ERCrossingPrefabs>())
			{
				list.Add(ERConnection.Create(gameObject2));
			}
		}
		return list.ToArray();
	}

	[Obsolete("obsolete")]
	public ERConnection GetSourceConnectionByName(string name)
	{
		UnityEngine.Object[] array = Resources.LoadAll("custom prefabs", typeof(GameObject));
		ERConnection result = null;
		UnityEngine.Object[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			GameObject gameObject = (GameObject)array2[i];
			if (gameObject.name == name && (bool)gameObject.GetComponent<ERCrossingPrefabs>())
			{
				return ERConnection.Create(gameObject);
			}
		}
		array = Resources.LoadAll("dynamic prefabs", typeof(GameObject));
		UnityEngine.Object[] array3 = array;
		for (int j = 0; j < array3.Length; j++)
		{
			GameObject gameObject2 = (GameObject)array3[j];
			if (gameObject2.name == name && (bool)gameObject2.GetComponent<ERCrossingPrefabs>())
			{
				return ERConnection.Create(gameObject2);
			}
		}
		return result;
	}

	public ERConnection GetConnectionPrefabByName(string name)
	{
		UnityEngine.Object[] array = Resources.LoadAll("custom prefabs", typeof(GameObject));
		ERConnection result = null;
		UnityEngine.Object[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			GameObject gameObject = (GameObject)array2[i];
			if (gameObject.name == name && (bool)gameObject.GetComponent<ERCrossingPrefabs>())
			{
				return ERConnection.Create(gameObject);
			}
		}
		array = Resources.LoadAll("dynamic prefabs", typeof(GameObject));
		UnityEngine.Object[] array3 = array;
		for (int j = 0; j < array3.Length; j++)
		{
			GameObject gameObject2 = (GameObject)array3[j];
			if (gameObject2.name == name && (bool)gameObject2.GetComponent<ERCrossingPrefabs>())
			{
				return ERConnection.Create(gameObject2);
			}
		}
		return result;
	}

	public ERConnection InstantiateConnection(ERConnection OQQCOQOCDO, string name, Vector3 position, Vector3 euler)
	{
		if (OQQCOQOCDO != null)
		{
			GameObject newPrefab = null;
			ERCrossingPrefabs prefabScript = null;
			ERCrossings crossingsScript = null;
			GameObject gameObject = roadNetwork.OOQDQOOQQQ(OQQCOQOCDO.gameObject, position, ref newPrefab, ref prefabScript, ref crossingsScript);
			newPrefab.transform.position = position;
			newPrefab.transform.eulerAngles = euler;
			newPrefab.gameObject.name = name;
			if (prefabScript.crossingsScript != null)
			{
				prefabScript.crossingsScript.isSceneObject = true;
			}
			else if ((bool)gameObject.GetComponent<ERRoundabouts>())
			{
				gameObject.GetComponent<ERRoundabouts>().isSceneObject = true;
			}
			else if (gameObject.GetComponent<ERCrossingPrefabs>().isCustomPrefab)
			{
				gameObject.GetComponent<ERCrossingPrefabs>().isSceneObject = true;
			}
			for (int i = 0; i < prefabScript.crossingElements.Count; i++)
			{
				prefabScript.crossingElements[i].connectedRoad = null;
				prefabScript.crossingElements[i].connectedMarker = -1;
				prefabScript.crossingElements[i].connectedRoadGO = null;
			}
			return new ERConnection(newPrefab, name);
		}
		return null;
	}

	public void SetRaiseOffset(float value)
	{
		roadNetwork.raise = value;
		if (roadNetwork.terrainDone)
		{
			roadNetwork.baseVector = new Vector3(0f, roadNetwork.raise, 0f);
		}
		else
		{
			roadNetwork.baseVector = Vector3.zero;
		}
		if (roadNetwork.terrainDone)
		{
			Transform transform = roadNetwork.transform.Find("Connection Objects");
			if (transform != null)
			{
				transform.position = roadNetwork.baseVector;
			}
			transform = roadNetwork.transform.Find("Road Objects");
			if (transform != null)
			{
				transform.position = roadNetwork.baseVector;
			}
		}
	}

	public ERRoad OODOOOQQCO(ERRoad road)
	{
		ERModularRoad eRModularRoad = OCCQQCCDDD.DuplicateObject(road.roadScript);
		eRModularRoad.road = new ERRoad(eRModularRoad);
		return eRModularRoad.road;
	}

	public float GetRaiseOffset()
	{
		return roadNetwork.raise;
	}

	public void ClampUVs(bool clamp)
	{
		roadNetwork.clampUVs = clamp;
	}

	public ERRoad ConnectRoads(ERRoad road1, ERRoad road2)
	{
		string message = "";
		if (CheckRoads(road1, road2, ref message))
		{
			UnityEngine.Debug.LogError(message);
			return null;
		}
		float num = Vector3.Distance(road1.roadScript.markersExt[0].position, road2.roadScript.markersExt[0].position);
		float num2 = Vector3.Distance(road1.roadScript.markersExt[0].position, road2.roadScript.markersExt[road2.roadScript.markersExt.Count - 1].position);
		float num3 = Vector3.Distance(road1.roadScript.markersExt[road1.roadScript.markersExt.Count - 1].position, road2.roadScript.markersExt[0].position);
		float num4 = Vector3.Distance(road1.roadScript.markersExt[road1.roadScript.markersExt.Count - 1].position, road2.roadScript.markersExt[road2.roadScript.markersExt.Count - 1].position);
		int marker = 0;
		int marker2 = 0;
		if (num2 < num)
		{
			marker2 = road2.roadScript.markersExt.Count - 1;
			num = num2;
		}
		if (num3 < num)
		{
			marker = road1.roadScript.markersExt.Count - 1;
			marker2 = 0;
			num = num3;
		}
		if (num4 < num)
		{
			marker = road1.roadScript.markersExt.Count - 1;
			marker2 = road2.roadScript.markersExt.Count - 1;
			num = num3;
		}
		List<SelectedObject> objects = new List<SelectedObject>();
		objects.Add(SelectedObject.CreateInstance(road1.roadScript, null, marker));
		objects.Add(SelectedObject.CreateInstance(road2.roadScript, null, marker2));
		ERModularRoad road3 = null;
		int marker3 = 0;
		GameObject gameObject = OCQOQOOOCO.JoinRoads(ref objects, ref road3, ref marker3);
		if (road3 == road1.roadScript)
		{
			UnityEngine.Debug.Log("road 1 refresh");
			road1.Refresh();
			if (road2.roadScript.gameObject != null)
			{
				UnityEngine.Object.DestroyImmediate(road2.roadScript.gameObject);
			}
			return road1;
		}
		UnityEngine.Debug.Log("road 2 refresh");
		road2.Refresh();
		if (road1.roadScript.gameObject != null)
		{
			UnityEngine.Object.DestroyImmediate(road1.roadScript.gameObject);
		}
		return road2;
	}

	public ERRoad ConnectRoads(ERRoad road1, int marker1, ERRoad road2, int marker2)
	{
		string message = "";
		if (CheckRoads(road1, road2, ref message))
		{
			UnityEngine.Debug.LogError(message);
			return null;
		}
		if (marker1 > 0 && marker1 < road1.roadScript.markersExt.Count - 1)
		{
			marker1 = road1.roadScript.markersExt.Count - 1;
		}
		if (marker2 > 0 && marker2 < road2.roadScript.markersExt.Count - 1)
		{
			marker2 = road2.roadScript.markersExt.Count - 1;
		}
		List<SelectedObject> objects = new List<SelectedObject>();
		objects.Add(SelectedObject.CreateInstance(road1.roadScript, null, marker1));
		objects.Add(SelectedObject.CreateInstance(road2.roadScript, null, marker2));
		ERModularRoad road3 = null;
		int marker3 = 0;
		GameObject gameObject = OCQOQOOOCO.JoinRoads(ref objects, ref road3, ref marker3);
		if (road3 == road1.roadScript)
		{
			road1.Refresh();
			if (road2.roadScript.gameObject != null)
			{
				UnityEngine.Object.DestroyImmediate(road2.roadScript.gameObject);
			}
			return road1;
		}
		road2.Refresh();
		if (road1.roadScript.gameObject != null)
		{
			UnityEngine.Object.DestroyImmediate(road1.roadScript.gameObject);
		}
		return road2;
	}

	private bool CheckRoads(ERRoad road1, ERRoad road2, ref string str)
	{
		if (road1.roadScript.closedTrack)
		{
			str = "EasyRoads3Dv3 Warning: Road 1 is a closed track";
			return true;
		}
		if (road2.roadScript.closedTrack)
		{
			str = "EasyRoads3Dv3 Warning: Road 2 is a closed track";
			return true;
		}
		if (road1.roadScript.roadType != road2.roadScript.roadType)
		{
			str = "EasyRoads3Dv3 Warning: Road 1 and Road 2 do not share the same road type";
			return true;
		}
		return false;
	}

	public static void SetTerrainNormals(Mesh m, GameObject go)
	{
		Vector3[] normals = go.GetComponent<MeshFilter>().sharedMesh.normals;
		ERModularRoad component = go.GetComponent<ERModularRoad>();
		for (int i = 0; i < normals.Length; i++)
		{
			normals[i] = component.baseScript.OQOODODDQO(m.vertices[i]);
		}
		m.normals = normals;
	}

	public void Refresh()
	{
		ODQDQDQDQOExt.OOODCQCQOC(roadNetwork);
	}

	public void FinalizeObjects()
	{
		ODQDQDQDQO.OOQCCQCCCC(roadNetwork);
		UnityEngine.Object.DestroyImmediate(roadNetwork);
	}
}
[AddComponentMenu("")]
public class ODQDQDQDQOExt : MonoBehaviour
{
	public static void OOODCQCQOC(ERModularBase scr)
	{
		ERCrossings[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERCrossings)) as ERCrossings[];
		int num = 0;
		ERCrossings[] array2 = array;
		foreach (ERCrossings eRCrossings in array2)
		{
			num++;
			try
			{
				if (!OOCQQOOQOD.CheckRoadTypeChanges(scr, eRCrossings.prefabScript, ercrossing: true, erroundabout: false))
				{
					eRCrossings.OCQDQODOQD(sidewalkSceneHandleFlag: false, rebuildRoads: true);
				}
			}
			catch
			{
				UnityEngine.Debug.Log("Refresh failed: " + eRCrossings.gameObject.name);
			}
		}
		ERRoundabouts[] array3 = UnityEngine.Object.FindObjectsOfType(typeof(ERRoundabouts)) as ERRoundabouts[];
		num = 0;
		ERRoundabouts[] array4 = array3;
		foreach (ERRoundabouts eRRoundabouts in array4)
		{
			num++;
			try
			{
				if (OOCQQOOQOD.CheckRoadTypeChanges(scr, eRRoundabouts.prefabScript, ercrossing: false, erroundabout: true))
				{
					continue;
				}
				eRRoundabouts.OOCDDOQDDO();
				eRRoundabouts.OQQCDOQOOQ();
				if (eRRoundabouts.leftFlag && eRRoundabouts.rightFlag)
				{
					eRRoundabouts.ODDDOCDCQO();
					if (eRRoundabouts.connections.Count > 0)
					{
						eRRoundabouts.OOQQDCCCCC();
					}
				}
			}
			catch
			{
				UnityEngine.Debug.Log("Refresh failed: " + eRRoundabouts.gameObject.name);
			}
		}
		ERCrossingPrefabs[] array5 = UnityEngine.Object.FindObjectsOfType(typeof(ERCrossingPrefabs)) as ERCrossingPrefabs[];
		num = 0;
		ERCrossingPrefabs[] array6 = array5;
		foreach (ERCrossingPrefabs eRCrossingPrefabs in array6)
		{
			num++;
			try
			{
				eRCrossingPrefabs.OQQCDODDQQ(forceFlag: true);
			}
			catch
			{
			}
		}
		ERModularRoad[] array7 = UnityEngine.Object.FindObjectsOfType(typeof(ERModularRoad)) as ERModularRoad[];
		num = 0;
		ERModularRoad[] array8 = array7;
		foreach (ERModularRoad eRModularRoad in array8)
		{
			num++;
			try
			{
				if (eRModularRoad.markersExt.Count <= 1)
				{
					UnityEngine.Object.DestroyImmediate(eRModularRoad.gameObject);
					continue;
				}
				eRModularRoad.OCQOQCDCQC(ignorePrefabAlignment: false, forceAutoRotate: false);
				Transform transform = eRModularRoad.transform.Find("treesERMesh");
				while (transform != null)
				{
					UnityEngine.Object.DestroyImmediate(transform.gameObject);
					transform = eRModularRoad.transform.Find("treesERMesh");
				}
				transform = eRModularRoad.transform.Find("detailERMesh");
				while (transform != null)
				{
					UnityEngine.Object.DestroyImmediate(transform.gameObject);
					transform = eRModularRoad.transform.Find("detailERMesh");
				}
			}
			catch
			{
				UnityEngine.Debug.Log("Refresh failed: " + eRModularRoad.gameObject.name);
			}
		}
		ERSideObjectInstance[] array9 = UnityEngine.Object.FindObjectsOfType(typeof(ERSideObjectInstance)) as ERSideObjectInstance[];
		num = 0;
		ERSideObjectInstance[] array10 = array9;
		foreach (ERSideObjectInstance eRSideObjectInstance in array10)
		{
			num++;
			if (!(eRSideObjectInstance.so != null))
			{
				continue;
			}
			ERModularRoad component = eRSideObjectInstance.transform.parent.GetComponent<ERModularRoad>();
			bool flag = false;
			try
			{
				for (int n = 0; n < component.soDataExt.Count; n++)
				{
					if (component.soDataExt[n].sideObject.id == eRSideObjectInstance.so.id && component.soDataExt[n].active)
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					ODDQODOOOC.OODQCDDCQO(scr, component, eRSideObjectInstance.so);
				}
				else
				{
					UnityEngine.Debug.LogWarning("EasyRoads3Dv3 warning: the side object " + eRSideObjectInstance.so.name + " (game object ) exists while this side object is currently not active for this road: road name: " + component.gameObject.name);
				}
			}
			catch
			{
				UnityEngine.Debug.LogWarning("EasyRoads3Dv3 warning: the side object " + eRSideObjectInstance.so.name + " (game object ) exists while this side object currently does not exist in road object: " + component.gameObject.name);
			}
		}
	}

	public static string[] OQDQCCCDQO(ERModularRoad scr, string[] prefabs, ref ERCrossingPrefabs[] prefs, int type)
	{
		if (scr == null)
		{
			return null;
		}
		GameObject gameObject = null;
		List<string> list = new List<string>();
		List<ERCrossingPrefabs> list2 = new List<ERCrossingPrefabs>();
		bool flag = true;
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		if (scr.startPrefabScript != null || scr.endPrefabScript != null)
		{
			flag = false;
			if (scr.startPrefabScript != null && scr.startPrefabScript.crossingElements.Count > scr.startConnectionSegment && scr.startConnectionSegment >= 0)
			{
				num = scr.startPrefabScript.crossingElements[scr.startConnectionSegment].roadShapeMatchCount;
				num2 = scr.startPrefabScript.prefabId;
			}
			if (scr.endPrefabScript != null && scr.endPrefabScript.crossingElements.Count > scr.endConnectionSegment && scr.endConnectionSegment >= 0)
			{
				num = scr.endPrefabScript.crossingElements[scr.endConnectionSegment].roadShapeMatchCount;
				num3 = scr.endPrefabScript.prefabId;
			}
		}
		for (int i = 0; i < prefabs.Length; i++)
		{
			if (type == 1)
			{
				gameObject = Resources.Load("custom prefabs/" + prefabs[i]) as GameObject;
				string text = "custom prefabs/";
			}
			else
			{
				gameObject = Resources.Load("dynamic prefabs/" + prefabs[i]) as GameObject;
				string text = "dynamic prefabs/";
			}
			if (!(gameObject != null))
			{
				continue;
			}
			ERCrossingPrefabs component = gameObject.GetComponent<ERCrossingPrefabs>();
			if (!(component != null) || !(gameObject.GetComponent<ERRoundabouts>() == null))
			{
				continue;
			}
			for (int j = 0; j < component.crossingElements.Count; j++)
			{
				bool flag2 = false;
				if (component.crossingElements[j].roadType == scr.roadType)
				{
					flag2 = true;
					if (num != 0 && num2 != component.prefabId && num3 != component.prefabId && num != component.crossingElements[j].roadShapeMatchCount)
					{
						flag2 = false;
					}
				}
				if (flag2 || scr.roadShapeMatchCount == component.crossingElements[j].roadShapeMatchCount || scr.roadShapeMatchCount == 0 || (component.crossingElements[j].roadShapeMatchCount == 0 && flag))
				{
					list.Add(prefabs[i]);
					list2.Add(component);
					break;
				}
			}
		}
		if (list.Count == 0)
		{
			list.Add("No matches Found");
		}
		prefs = list2.ToArray();
		return list.ToArray();
	}

	public static bool OQDOQQDDOC(ERModularRoad road, ref bool left, ref bool right)
	{
		QDQDOOQQDQODD roadTypeElByID = QDQDOOQQDQODD.GetRoadTypeElByID(road.baseScript.roadTypes, road.roadType);
		if (roadTypeElByID != null)
		{
			if (road.roadShape.Count <= 1 || roadTypeElByID.roadShape.Count <= 1)
			{
				return false;
			}
			if (roadTypeElByID.roadWidth != road.roadWidth)
			{
				if (-1f * road.roadShape[0].x < roadTypeElByID.roadShape[0].x && -1f * road.roadShape[1].x < roadTypeElByID.roadShape[0].x)
				{
					left = true;
				}
				if (-1f * road.roadShape[road.roadShape.Count - 1].x > roadTypeElByID.roadShape[roadTypeElByID.roadShape.Count - 1].x && -1f * road.roadShape[road.roadShape.Count - 2].x > roadTypeElByID.roadShape[roadTypeElByID.roadShape.Count - 1].x)
				{
					right = true;
				}
			}
			return true;
		}
		return false;
	}

	public static bool OCCCQODODQ(ERCrossingPrefabs prefab, ERModularRoad road, int marker, int connection)
	{
		if (prefab.isCustomPrefab || prefab.isIConnector)
		{
			return false;
		}
		if (prefab.sidewalkControlElements.Count != prefab.crossingElements.Count)
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3: Sidewalk data is not valid for the following connection prefab: " + prefab.gameObject.name);
			return false;
		}
		if (marker == 0)
		{
			if (road.endPrefabScript != null && road.endPrefabScript.isCustomPrefab)
			{
				return false;
			}
		}
		else if (road.startPrefabScript != null && road.startPrefabScript.isCustomPrefab)
		{
			return false;
		}
		prefab.OCCDCDDOOQ(flag: false);
		bool left = false;
		bool right = false;
		if (!OQDOQQDDOC(road, ref left, ref right))
		{
			return false;
		}
		if (marker == 0)
		{
			bool flag = left;
			left = right;
			right = flag;
		}
		bool flag2 = false;
		if (left || right)
		{
			flag2 = true;
		}
		bool flag3 = false;
		bool flag4 = false;
		bool flag5 = false;
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		switch (connection)
		{
		case 0:
			num = 1;
			num2 = 2;
			num3 = 3;
			break;
		case 1:
			num = 0;
			num2 = 3;
			num3 = 2;
			break;
		case 2:
			num = 3;
			num2 = 1;
			num3 = 0;
			break;
		case 3:
			num = 2;
			num2 = 0;
			num3 = 1;
			break;
		}
		bool flag6 = left;
		bool flag7 = right;
		for (int i = 0; i < prefab.sidewalkControlElements.Count; i++)
		{
			int crossingElementLeftIndex = prefab.sidewalkControlElements[i].crossingElementLeftIndex;
			int crossingElementRightIndex = prefab.sidewalkControlElements[i].crossingElementRightIndex;
			bool flag8 = false;
			flag8 = ((left == right) ? (flag6 = (flag7 = left)) : ((crossingElementLeftIndex != connection) ? ((crossingElementLeftIndex != num) ? ((crossingElementLeftIndex != num2) ? right : left) : right) : left));
			prefab.sidewalkControlElements[i].renderFlag = flag8;
			prefab.sidewalkControlElements[i].leftConnectionHandle = flag8;
			prefab.crossingElements[prefab.sidewalkControlElements[i].crossingElementLeftIndex].includeLeftSidewalk = flag8;
			prefab.sidewalkControlElements[i].rightConnectionHandle = flag8;
			prefab.crossingElements[prefab.sidewalkControlElements[i].crossingElementRightIndex].includeRightSidewalk = flag8;
		}
		if ((bool)prefab.gameObject.GetComponent<ERCrossings>())
		{
			prefab.gameObject.GetComponent<ERCrossings>().OCQDQODOQD(sidewalkSceneHandleFlag: false, rebuildRoads: true);
		}
		return true;
	}

	public static bool OCQDQQDOOD(ERCrossingPrefabs prefab, ERModularRoad road, int marker, int connection)
	{
		return true;
	}
}
[AddComponentMenu("")]
public class OCQOQOOOCO : MonoBehaviour
{
	public static float OCOCQCDDCD(ref List<Vector3> splinePoints, ERModularRoad scr, int marker, ref List<Vector3> segPoints, ref List<float> tValues, ref float totalDist, int startMarker, ref float xzDistance, bool getDistance, ref float radius, ref List<float> bendAngles)
	{
		segPoints.Clear();
		int num = 1;
		Vector3 dir = Vector3.zero;
		Vector3 dir2 = Vector3.zero;
		List<float> list = new List<float>();
		int num2 = 0;
		Vector3 vector = Vector3.zero;
		if (splinePoints.Count > 2)
		{
			vector = splinePoints[splinePoints.Count - 1];
			if ((double)Vector3.Distance(scr.markersExt[startMarker + marker - 1].position, splinePoints[splinePoints.Count - 1]) < 0.5)
			{
				num = 2;
				vector = splinePoints[splinePoints.Count - 2];
				num2 = 1;
			}
		}
		else if (marker > 1)
		{
			vector = scr.splinePoints[scr.markersExt[startMarker + marker - 1].startSplinePoint];
			if ((double)Vector3.Distance(scr.markersExt[startMarker + marker - 1].position, vector) < 0.5)
			{
				num = 2;
				vector = scr.splinePoints[scr.markersExt[startMarker + marker - 1].startSplinePoint - 1];
				num2 = 1;
			}
		}
		else if (scr.closedTrack)
		{
			vector = scr.markersExt[scr.markersExt.Count - 1].position;
		}
		else if (scr.startPrefabScript != null && scr.startPrefabScript.crossingElements.Count > scr.startConnectionSegment)
		{
			vector = scr.startPrefabScript.transform.TransformPoint(scr.startPrefabScript.crossingElements[scr.startConnectionSegment].controlPointV3);
			if (scr.startPrefabScript.isIConnector)
			{
				ERModularRoad eRModularRoad = null;
				int index = 0;
				if (scr.startConnectionSegment == 0)
				{
					index = 1;
				}
				eRModularRoad = scr.startPrefabScript.crossingElements[index].connectedRoad;
				if (eRModularRoad != null)
				{
					if (scr.startPrefabScript.crossingElements[index].connectedMarker == 0)
					{
						Vector3 normalized = (eRModularRoad.splinePoints[1] - eRModularRoad.splinePoints[0]).normalized;
						vector = eRModularRoad.splinePoints[0] + normalized * 5f;
					}
					else
					{
						Vector3 normalized = (eRModularRoad.splinePoints[eRModularRoad.splinePoints.Count - 2] - eRModularRoad.splinePoints[eRModularRoad.splinePoints.Count - 1]).normalized;
						vector = eRModularRoad.splinePoints[eRModularRoad.splinePoints.Count - 1] + normalized * 5f;
					}
				}
			}
		}
		Vector3 m = scr.markersExt[startMarker + marker - 1].position + new Vector3(0.001f, 0f, 0.001f);
		Vector3 vector2 = vector;
		Vector3 m2 = scr.markersExt[startMarker + marker].position + new Vector3(0.001f, 0f, 0.001f);
		m.y = (vector2.y = m2.y);
		bool flag = ODQDQDQDQO.OQCDCDOOCD(m, vector2, m2);
		Vector3 vector3 = Vector3.zero;
		if (scr.markersExt.Count > startMarker + marker + 1)
		{
			vector3 = scr.markersExt[startMarker + marker + 1].position;
		}
		else if (scr.closedTrack)
		{
			vector3 = scr.markersExt[0].position;
		}
		else if (scr.endPrefabScript != null && scr.endPrefabScript.crossingElements.Count > scr.endConnectionSegment)
		{
			vector3 = scr.endPrefabScript.transform.TransformPoint(scr.endPrefabScript.crossingElements[scr.endConnectionSegment].controlPointV3);
		}
		vector3.y = m2.y;
		bool isAhead = true;
		int firstLastAdjust = 0;
		Vector3 vector4 = m;
		Vector3 vector5 = m2;
		bool isNoAdjust = false;
		Vector3 vector6 = OOODCCODQD(ref m2, ref m, ref dir, ref dir2, vector2, vector3, ref isAhead, ref firstLastAdjust, ref isNoAdjust, scr);
		scr.p1Circle = m;
		scr.p2Circle = m2;
		scr.cp7 = m;
		scr.cp8 = m + dir * 500f;
		scr.cp9 = m + -dir * 500f;
		scr.cp3 = m2 + dir2 * 500f;
		scr.cp4 = m2 + -dir2 * 500f;
		bool flag2 = true;
		if ((ODQDQDQDQO.OQCDCDOOCD(vector4, vector2, vector5) ? (ODQDQDQDQO.OQCDCDOOCD(vector5, vector4, vector3) ? 1 : 0) : ((!ODQDQDQDQO.OQCDCDOOCD(vector5, vector4, vector3)) ? 1 : 0)) == 0)
		{
			segPoints.Add(Vector3.Lerp(vector4, vector5, 0.5f));
			segPoints.Add(vector5);
			tValues.Add(0.5f);
			tValues.Add(1f);
			return Vector3.Distance(vector4, vector5);
		}
		Vector3 normalized2 = (vector6 - m).normalized;
		Vector3 normalized3 = (vector6 - m2).normalized;
		float num3 = Vector3.Angle(dir, dir2);
		if (num3 == 90f || vector6 == Vector3.zero)
		{
			vector6 = Vector3.Lerp(m, m2, 0.5f);
		}
		if (!isAhead)
		{
			num3 = 360f - num3;
		}
		bool flag3 = false;
		radius = Vector3.Distance(vector6, m);
		if (radius > 150f)
		{
			dir = (m - vector6).normalized;
			vector6 = m + dir * 150f;
			radius = Vector3.Distance(vector6, m);
		}
		float num4 = radius * 2f * (float)Math.PI;
		dir = (m - vector6).normalized;
		dir2 = (m2 - vector6).normalized;
		num3 = Vector3.Angle(dir, dir2);
		if (!isAhead)
		{
			num3 = 360f - num3;
		}
		scr.cpradius = Vector3.Distance(vector6, m);
		scr.cpangle = num3;
		scr.cpcenter = vector6;
		totalDist = num4 / 360f * num3;
		if (getDistance)
		{
			return totalDist;
		}
		xzDistance = totalDist;
		float num5 = totalDist / scr.faceDistance;
		float num6 = num3 / scr.angleTreshold;
		if (num5 < num6)
		{
			num5 = num6;
		}
		Vector3 zero = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		if (firstLastAdjust == 0)
		{
			zero = vector4;
			zero2 = m;
		}
		else
		{
			zero = m2;
			zero2 = vector5;
		}
		float num7 = Vector3.Distance(zero, zero2);
		totalDist += num7;
		if (isNoAdjust)
		{
			num7 = 0f;
		}
		float num8 = num3 / totalDist * 5f;
		float num9 = num3 / num5;
		float num10 = 1f / num5;
		float num11 = 0f;
		float num12 = 0f;
		if (firstLastAdjust == 0)
		{
			num11 = num7 / (totalDist + num7);
			num10 = (1f - num11) / (num5 + 1f - (float)num2);
		}
		else
		{
			num12 = totalDist / (totalDist + num7);
			num10 = num12 / (num5 + 1f - (float)num2);
		}
		Vector3 point = m;
		float y = scr.markersExt[startMarker + marker - 1].position.y;
		float num13 = num11;
		if (!flag)
		{
			num9 *= -1f;
		}
		bool flag4 = false;
		for (int i = num2; (float)i < num5; i++)
		{
			Vector3 item = ERRoundabouts.OQDDDODCOC(point, vector6, Quaternion.Euler(0f, (float)i * num9, 0f));
			item.y = y;
			segPoints.Add(item);
			num13 += num10;
			tValues.Add(num13);
			list.Add(num8);
		}
		if (!isNoAdjust)
		{
			float num14 = Mathf.Ceil(num7 / scr.faceDistance);
			float num15 = num7 / num14;
			num10 = num7 / (totalDist + num7) / num14;
			List<Vector3> list2 = new List<Vector3>();
			List<float> list3 = new List<float>();
			dir = (zero2 - zero).normalized;
			num2 = 1;
			if (firstLastAdjust == 1 && segPoints.Count > 0 && Vector3.Distance(segPoints[segPoints.Count - 1], zero) > scr.faceDistance * 0.35f)
			{
				num2 = 0;
			}
			List<float> list4 = new List<float>();
			for (int j = num2; (float)j <= num14; j++)
			{
				Vector3 item2 = zero + dir * num15 * j;
				list2.Add(item2);
				list4.Add(0f);
				list3.Add(num12 + num10 * (float)j);
			}
			if (marker == 1 && scr.startPrefabScript != null)
			{
				list2.RemoveAt(list2.Count - 1);
				list.RemoveAt(list.Count - 1);
				list3.RemoveAt(list3.Count - 1);
			}
			if (firstLastAdjust == 0)
			{
				segPoints.InsertRange(0, list2);
				tValues.InsertRange(0, list3);
				if (list4.Count > 0)
				{
					list4[list4.Count - 1] = num8;
				}
				list.InsertRange(0, list4);
				list[list.Count - 1] = 0f;
			}
			else
			{
				segPoints.AddRange(list2);
				tValues.AddRange(list3);
				list.AddRange(list4);
			}
		}
		if (firstLastAdjust != 0 && bendAngles.Count > 1)
		{
			bendAngles[bendAngles.Count - 1] = num8;
		}
		if (segPoints.Count > 1)
		{
			if (splinePoints.Count > 0)
			{
				Vector3 a = splinePoints[splinePoints.Count - 1];
				a.y = segPoints[0].y;
				if (Vector3.Distance(a, segPoints[0]) < 0.25f)
				{
					segPoints[0] = Vector3.Lerp(a, segPoints[1], 0.5f);
					tValues[0] = Mathf.Lerp(0f, tValues[1], 0.5f);
				}
			}
			if (marker == scr.markersExt.Count - 1 && scr.closedTrack)
			{
				Vector3 a2 = splinePoints[0];
				a2.y = segPoints[segPoints.Count - 1].y;
				if (Vector3.Distance(a2, segPoints[segPoints.Count - 1]) < 0.25f)
				{
					segPoints[segPoints.Count - 1] = Vector3.Lerp(a2, segPoints[segPoints.Count - 2], 0.5f);
					tValues[tValues.Count - 1] = Mathf.Lerp(0f, tValues[tValues.Count - 2], 0.5f);
				}
			}
		}
		bendAngles.AddRange(list);
		return totalDist;
	}

	public static Vector3 OOODCCODQD(ref Vector3 m2, ref Vector3 m1, ref Vector3 dir1, ref Vector3 dir2, Vector3 p1, Vector3 p4, ref bool isAhead, ref int firstLastAdjust, ref bool isNoAdjust, ERModularRoad scr)
	{
		dir1 = (m1 - p1).normalized;
		dir2 = (m2 - p4).normalized;
		Vector3 vector = Vector3.Lerp(dir1, dir2, 0.5f);
		Vector3 vector2 = ODQDQDQDQO.OODOQDOODO(p1, m1, p4, m2, flag: false);
		Vector3 zero = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		Vector3 zero3 = Vector3.zero;
		isAhead = ODQDQDQDQO.OQCDCDOOCD(m1, m2, vector2);
		if (ODQDQDQDQO.OQCDCDOOCD(m2, p4, m1) && ODQDQDQDQO.OQCDCDOOCD(m2, p4, p1))
		{
			isAhead = !isAhead;
		}
		if (vector2 != Vector3.zero)
		{
			zero = vector2 - vector * 500f;
			zero2 = vector2 + vector * 500f;
			scr.cp1 = m1;
			scr.cp2 = p1;
			scr.cp3 = m2;
			scr.cp4 = p4;
			scr.cp5 = zero;
			scr.cp6 = zero2;
			Vector3 normalized = new Vector3(dir1.z, 0f, 0f - dir1.x).normalized;
			Vector3 normalized2 = new Vector3(dir2.z, 0f, 0f - dir2.x).normalized;
			Vector3 vector3 = ODQDQDQDQO.OQQCQOCCOQ(zero, zero2, m1);
			float num = Vector3.Distance(vector3, m1);
			Vector3 a = ODQDQDQDQO.OQQCQOCCOQ(zero, zero2, m2);
			float num2 = Vector3.Distance(a, m2);
			zero3 = vector3;
			if (((num < num2) & isAhead) || (num > num2 && !isAhead))
			{
				Vector3 p5 = m1 + -normalized * 500f;
				Vector3 p6 = m1 + normalized * 500f;
				zero3 = ODQDQDQDQO.OODOQDOODO(p5, p6, zero, zero2, flag: false);
				zero = m2 - dir2 * 500f;
				zero2 = m2 + dir2 * 500f;
				m2 = ODQDQDQDQO.OQQCQOCCOQ(zero, zero2, zero3);
				scr.cp3 = m2;
				firstLastAdjust = 1;
			}
			else if (num != num2)
			{
				Vector3 p7 = m2 + -normalized2 * 500f;
				Vector3 p8 = m2 + normalized2 * 500f;
				zero3 = ODQDQDQDQO.OODOQDOODO(p7, p8, zero, zero2, flag: false);
				zero = m1 - dir1 * 500f;
				zero2 = m1 + dir1 * 500f;
				m1 = ODQDQDQDQO.OQQCQOCCOQ(zero, zero2, zero3);
				scr.cp1 = m1;
				firstLastAdjust = 0;
			}
			else
			{
				isNoAdjust = true;
			}
			scr.cp7 = zero3;
			return zero3;
		}
		zero = m2 - dir2 * 500f;
		zero2 = m2 + dir2 * 500f;
		Vector3 vector4 = ODQDQDQDQO.OQQCQOCCOQ(zero, zero2, m1);
		zero = m1 - dir1 * 500f;
		zero2 = m1 + dir1 * 500f;
		Vector3 vector5 = ODQDQDQDQO.OQQCQOCCOQ(zero, zero2, m2);
		float num3 = Vector3.Distance(vector4, p4);
		float num4 = Vector3.Distance(m2, p4);
		if (num3 < num4)
		{
			m1 = vector5;
			firstLastAdjust = 0;
		}
		else if (num3 > num4)
		{
			m2 = vector4;
			firstLastAdjust = 1;
		}
		else
		{
			isNoAdjust = true;
		}
		return Vector3.Lerp(m1, m2, 0.5f);
	}

	public static float ODOCQOODDO(ref List<Vector3> splinePoints, ERModularRoad scr, int marker, ref List<Vector3> segPoints, ref List<float> tValues, ref float totalDist, int startMarker, ref float xzDistance, bool getDistance, ref List<float> bendAngles)
	{
		segPoints.Clear();
		int num = 1;
		int num2 = 0;
		Vector3 zero = Vector3.zero;
		if (splinePoints.Count > 2)
		{
			zero = splinePoints[splinePoints.Count - 1];
			if ((double)Vector3.Distance(scr.markersExt[startMarker + marker - 1].position, splinePoints[splinePoints.Count - 1]) < 0.5)
			{
				num = 2;
				zero = splinePoints[splinePoints.Count - 2];
				num2 = 1;
			}
		}
		else
		{
			zero = scr.splinePoints[scr.markersExt[startMarker + marker - 1].startSplinePoint];
			if ((double)Vector3.Distance(scr.markersExt[startMarker + marker - 1].position, zero) < 0.5)
			{
				num = 2;
				zero = scr.splinePoints[scr.markersExt[startMarker + marker - 1].startSplinePoint - 1];
				num2 = 1;
			}
		}
		Vector3 position = scr.markersExt[startMarker + marker - 1].position;
		Vector3 pSource = zero;
		Vector3 position2 = scr.markersExt[startMarker + marker].position;
		position.y = (pSource.y = position2.y);
		bool flag = ODQDQDQDQO.OQCDCDOOCD(position, pSource, position2);
		Vector3 normalized = (scr.markersExt[startMarker + marker - 1].position - zero).normalized;
		Vector3 normalized2 = (scr.markersExt[startMarker + marker - 1].position - scr.markersExt[startMarker + marker].position).normalized;
		normalized.y = 0f;
		normalized.Normalize();
		normalized2.y = 0f;
		normalized2.Normalize();
		float num3 = Vector3.Angle(normalized, normalized2);
		scr.pivotp = scr.markersExt[startMarker + marker - 1].position;
		scr.p1 = zero;
		scr.p2 = scr.markersExt[startMarker + marker].position;
		Vector3 position3 = scr.markersExt[startMarker + marker].position;
		position3.y = 0f;
		Vector3 vector = position3 + normalized2 * 2f;
		bool flag2 = false;
		float num4 = -1f;
		float num5 = 1f;
		if (flag)
		{
			if (num3 >= 90f)
			{
				num3 = 180f - num3;
			}
			else
			{
				num4 = 1f;
				num5 = -1f;
				flag2 = true;
			}
		}
		else if (num3 >= 90f)
		{
			num3 = 180f - num3;
			num4 = 1f;
			num5 = -1f;
		}
		else
		{
			num4 = -1f;
			num5 = 1f;
			flag2 = true;
		}
		float num6 = 2f * Mathf.Tan(num3 * ((float)Math.PI / 180f));
		Vector3 normalized3 = new Vector3(num5 * normalized2.z, 0f, num4 * normalized2.x).normalized;
		Vector3 vector2 = vector + normalized3 * num6;
		normalized3 = new Vector3(normalized.z, 0f, 0f - normalized.x);
		Vector3 position4 = scr.markersExt[startMarker + marker - 1].position;
		position4.y = 0f;
		Vector3 p = position4 + normalized3;
		normalized2 = position3 - vector2;
		normalized3 = new Vector3(normalized2.z, 0f, 0f - normalized2.x).normalized;
		Vector3 p2 = position3 + normalized3;
		Vector3 vector3 = (scr.p2 = ODQDQDQDQO.OODOQDOODO(position4, p, position3, p2, flag: false));
		if (num3 == 90f)
		{
			vector3 = Vector3.Lerp(position3, position4, 0.5f);
		}
		float num7 = Vector3.Distance(vector3, position4);
		if (num7 > 150f)
		{
			normalized = (position4 - vector3).normalized;
			vector3 = position4 + normalized * 150f;
			num7 = Vector3.Distance(vector3, position4);
		}
		float num8 = num7 * 2f * (float)Math.PI;
		normalized = (position4 - vector3).normalized;
		normalized2 = (position3 - vector3).normalized;
		num3 = Vector3.Angle(normalized, normalized2);
		if (flag2)
		{
			num3 = 360f - num3;
		}
		totalDist = num8 / 360f * num3;
		if (getDistance)
		{
			return totalDist;
		}
		xzDistance = totalDist;
		float num9 = totalDist / scr.faceDistance;
		float num10 = num3 / scr.angleTreshold;
		if (num9 < num10)
		{
			num9 = num10;
		}
		float item = num3 / totalDist * 5f;
		float num11 = num3 / num9;
		float num12 = 1f / num9;
		Vector3 position5 = scr.markersExt[startMarker + marker - 1].position;
		float num13 = 0f;
		if (!flag)
		{
			num11 *= -1f;
		}
		bool flag3 = false;
		for (int i = num2; (float)i < num9; i++)
		{
			Vector3 item2 = ERRoundabouts.OQDDDODCOC(position5, vector3, Quaternion.Euler(0f, (float)i * num11, 0f));
			segPoints.Add(item2);
			num13 += num12;
			tValues.Add(num13);
			bendAngles.Add(item);
		}
		return totalDist;
	}

	public static Vector3 OCOCQCDDCD(ERModularRoad scr, int marker, ref bool flag)
	{
		int num = 0;
		Vector3 position = scr.markersExt[num + marker - 1].position;
		Vector3 position2 = scr.markersExt[num + marker].position;
		Vector3 vector = scr.markersExt[num + marker + 1].position;
		Vector3 position3 = scr.markersExt[num + marker + 2].position;
		position.y = (position2.y = (position3.y = vector.y));
		float num2 = Vector3.Distance(position2, vector);
		float num3 = Vector3.Distance(vector, position3);
		float num4 = Vector3.Distance(position2, position3);
		Vector3 normalized = (position2 - position).normalized;
		Vector3 normalized2 = (position2 - vector).normalized;
		Vector3 normalized3 = (position3 - vector).normalized;
		float num5 = Vector3.Angle(normalized2, normalized3);
		if (num5 > 160f || num5 < 5f)
		{
			if (num2 < 100f)
			{
				scr.markersExt[num + marker].controlTypeTmp = 3;
				scr.markersExt[num + marker].controlType = 0;
				Vector3 b = (scr.p5 = ODQDQDQDQO.OQQCQOCCOQ(position, position2 + normalized * 2000f, vector));
				float num6 = Vector3.Distance(vector, b);
				vector = (scr.markersExt[num + marker + 1].position = Vector3.Lerp(vector, b, 1f - (180f - num5) / 20f));
				if (Vector3.Distance(position2, vector) < 3f)
				{
					vector = (scr.markersExt[num + marker + 1].position = position2 + normalized * 3f);
				}
				return vector;
			}
			if (num2 > num4)
			{
				vector = position3 + normalized3;
			}
		}
		Vector3 normalized4 = (vector - position3).normalized;
		if (num3 < num2 && num3 < 10f)
		{
			vector += (position2 - vector).normalized * 0.66f;
			normalized4 = (vector - position3).normalized;
		}
		Vector3 vector2 = ODQDQDQDQO.OODOQDOODO(position, position2, vector, position3, flag: false);
		Vector3 vector3 = (normalized + normalized4) * 0.5f;
		Vector3 p = vector2 + -vector3 * 100f;
		Vector3 vector4 = new Vector3(normalized.z, 0f, 0f - normalized.x);
		Vector3 vector5 = new Vector3(0f - normalized4.z, 0f, normalized4.x);
		num5 = Vector3.Angle(vector4, vector5);
		Vector3 vector6 = position2 + vector4 * 20f;
		Vector3 vector7 = ODQDQDQDQO.OODOQDOODO(position2, vector6, vector2, p, flag: false);
		if (ODQDQDQDQO.OQCDCDOOCD(vector7, position2, vector2))
		{
			num5 = 360f - num5;
		}
		if (vector7 == Vector3.zero)
		{
			return scr.markersExt[marker + 1].position;
		}
		Vector3 vector8 = ERRoundabouts.OQDDDODCOC(position2, vector7, Quaternion.Euler(0f, num5, 0f));
		scr.dp1 = position2;
		scr.dp2 = vector6;
		scr.dp3 = vector;
		scr.dp4 = vector + vector5 * 20f;
		float num7 = Vector3.Distance(vector7, vector8);
		if (num7 > Vector3.Distance(position2, position3))
		{
			vector8 = vector;
		}
		scr.markersExt[marker + 1].position = vector8;
		return vector8;
	}

	public static void OOCCQCOOQQ(ref List<Vector3> splinePoints, ERModularRoad scr, int marker, ref Vector3 pivotp, ref Vector3 p1, ref Vector3 p2, ref List<Vector3> segPoints, ref List<float> tValues)
	{
		Vector3 normalized = (splinePoints[splinePoints.Count - 1] - splinePoints[splinePoints.Count - 2]).normalized;
		Vector3 vector = new Vector3(normalized.z, 0f, 0f - normalized.x);
		float num = scr.markersExt[marker].circularAngle / ((float)scr.markersExt[marker].circularSegments * 1f);
		Vector3 vector2 = (pivotp = ((!(scr.markersExt[marker].circularAngle < 0f)) ? (splinePoints[splinePoints.Count - 1] - vector * scr.markersExt[marker].circularRadius * (scr.roadWidth * 0.5f)) : (splinePoints[splinePoints.Count - 1] + vector * scr.markersExt[marker].circularRadius * (scr.roadWidth * 0.5f))));
		p1 = splinePoints[splinePoints.Count - 1];
		segPoints.Clear();
		Vector3 vector3 = splinePoints[splinePoints.Count - 1];
		normalized = (vector2 - vector3).normalized;
		float num2 = Mathf.Atan2(normalized.x, normalized.z) * 57.29578f;
		float num3 = 0f;
		float num4 = 1f / ((float)scr.markersExt[marker].circularSegments * 1f);
		for (int i = 1; i <= 1; i++)
		{
			splinePoints.Add(ERRoundabouts.OQDDDODCOC(vector3, vector2, Quaternion.Euler(0f, (float)i * num, 0f)));
			segPoints.Add(ERRoundabouts.OQDDDODCOC(vector3, vector2, Quaternion.Euler(0f, (float)i * num, 0f)));
			num3 += num4;
			tValues.Add(num3);
		}
	}

	public static void OQCQQDCDQO(ERModularRoad roadScr, ref List<Vector3> tmpNodes, List<float> splineStrength, ERCrossingPrefabs prefabInstance, int connectionSegment, ref Vector3 connectionDir, ref Vector3 lastForward, int startEnd)
	{
		if (roadScr.isSideObject || prefabInstance.tmpMeshVecs.Length == 0)
		{
			float num = 1f;
			if (tmpNodes[0] != tmpNodes[1] && startEnd == 0)
			{
				num = ((tmpNodes.Count != 2) ? Vector3.Distance(tmpNodes[0], tmpNodes[1]) : (100f + Vector3.Distance(tmpNodes[0], tmpNodes[1])));
				tmpNodes.Insert(0, prefabInstance.transform.TransformPoint(new Vector3(0f, 0f, 0f - num)));
			}
			if (tmpNodes[tmpNodes.Count - 1] != tmpNodes[tmpNodes.Count - 2] && startEnd == 1)
			{
				tmpNodes.Add(prefabInstance.transform.TransformPoint(new Vector3(0f, 0f, 0f - Vector3.Distance(tmpNodes[tmpNodes.Count - 1], tmpNodes[tmpNodes.Count - 2]))));
			}
			return;
		}
		Vector3 vector = prefabInstance.transform.TransformPoint(Vector3.zero);
		Vector3 vector2 = prefabInstance.transform.TransformPoint(prefabInstance.crossingElements[connectionSegment].centerPoint);
		Vector3 vector3 = prefabInstance.transform.TransformPoint(prefabInstance.crossingElements[connectionSegment].controlPointV3);
		Vector3 normalized = (vector3 - vector2).normalized;
		if (prefabInstance.isExitRoadConnector)
		{
			vector = vector3;
		}
		Vector3 zero = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		float num2 = 0.5f;
		Vector3 vector4;
		if (startEnd == 0)
		{
			zero = (zero2 = tmpNodes[1]);
			num2 = splineStrength[1];
			if (tmpNodes.Count > 2)
			{
				zero = tmpNodes[2];
			}
			vector4 = ERModularRoad.OODODQQQCD(vector3, vector3, tmpNodes[1], zero, 0.02f, 0.5f);
		}
		else
		{
			zero = (zero2 = tmpNodes[tmpNodes.Count - 2]);
			num2 = splineStrength[splineStrength.Count - 2];
			if (tmpNodes.Count > 2 && splineStrength.Count > 2)
			{
				zero = tmpNodes[tmpNodes.Count - 3];
				num2 = splineStrength[splineStrength.Count - 3];
			}
			vector4 = ERModularRoad.OODODQQQCD(zero, tmpNodes[tmpNodes.Count - 2], vector3, vector3, 0.98f, 0.5f);
		}
		Vector3 normalized2 = (vector3 - vector4).normalized;
		float num3 = Vector3.Angle(normalized, normalized2);
		float num4 = Vector3.Distance(vector2, vector3);
		float num5 = Mathf.Tan(num3 * ((float)Math.PI / 180f)) * num4;
		if (ERCrossingPrefabs.OQCDCDOOCD(vector3, vector2, vector4))
		{
			num5 *= -1f;
			if (startEnd == 0)
			{
				roadScr.startbendLeftRight = -1;
			}
			else
			{
				roadScr.endbendLeftRight = 1;
			}
		}
		else if (startEnd == 0)
		{
			roadScr.startbendLeftRight = 1;
		}
		else
		{
			roadScr.endbendLeftRight = -1;
		}
		if (startEnd == 0)
		{
			roadScr.startAngle = 90f - num3;
		}
		else
		{
			roadScr.endAngle = 90f - num3;
		}
		List<Vector3> controlPoints = new List<Vector3>();
		if (prefabInstance.tCrossing && connectionSegment <= 1 && prefabInstance.tStraightBending && !prefabInstance.isFlexConnector)
		{
			float num6 = Vector3.Distance(vector, vector2);
			float num7 = num6 / Mathf.Cos(num3 * ((float)Math.PI / 180f));
			float totalDistance = 0f;
			roadScr.testPoints2 = OODODOQDCC.OOOOOOODCO(vector, vector2, zero2, zero, ref totalDistance, ref controlPoints);
			prefabInstance.DeformTCossingConnection(connectionSegment, totalDistance, num6, controlPoints, num7 / num6, num3, vector2, num2);
		}
		prefabInstance.OCDOCCODOC(connectionSegment, num5 * 0.75f);
		Vector3 vector5 = prefabInstance.transform.TransformPoint(prefabInstance.crossingElements[connectionSegment].tmpCenterPoint);
		if (startEnd == 0)
		{
			ERMarkerExt eRMarkerExt = roadScr.markersExt[0];
			Vector3 position = (tmpNodes[0] = vector5);
			eRMarkerExt.position = position;
		}
		else
		{
			ERMarkerExt eRMarkerExt2 = roadScr.markersExt[roadScr.markersExt.Count - 1];
			Vector3 position = (tmpNodes[tmpNodes.Count - 1] = vector5);
			eRMarkerExt2.position = position;
		}
		if (startEnd == 0)
		{
			if (prefabInstance.tCrossing && connectionSegment <= 1 && prefabInstance.tStraightBending && !prefabInstance.isFlexConnector)
			{
				Vector3 vector8 = prefabInstance.transform.TransformPoint(prefabInstance.tmpFullMeshVecs[prefabInstance.crossingElements[connectionSegment].fullConnectionVecInts[0]]);
				Vector3 vector9 = prefabInstance.transform.TransformPoint(prefabInstance.tmpFullMeshVecs[prefabInstance.crossingElements[connectionSegment].fullConnectionVecInts[prefabInstance.crossingElements[connectionSegment].fullConnectionVecInts.Count - 1]]);
				Vector3 vector10 = vector8 - vector9;
				vector10 = new Vector3(vector10.z, 0f, 0f - vector10.x).normalized;
				Vector3 item = tmpNodes[0] + vector10 * Vector3.Distance(tmpNodes[0], tmpNodes[1]);
				tmpNodes.Insert(0, item);
				splineStrength.Insert(0, splineStrength[0]);
				tmpNodes[0] = controlPoints[0];
				tmpNodes[1] = controlPoints[1];
				return;
			}
			Vector3 vector11 = prefabInstance.transform.TransformPoint(prefabInstance.tmpMeshVecs[prefabInstance.crossingElements[connectionSegment].connectionVecInts[prefabInstance.crossingElements[connectionSegment].leftInt]]);
			Vector3 vector12 = prefabInstance.transform.TransformPoint(prefabInstance.tmpMeshVecs[prefabInstance.crossingElements[connectionSegment].connectionVecInts[prefabInstance.crossingElements[connectionSegment].rightInt]]);
			roadScr.p6 = vector11;
			roadScr.p7 = vector12;
			Vector3 vector13 = vector11 - vector12;
			Vector3 zero3 = Vector3.zero;
			if (!roadScr.QDDDQODQQDQDQQD)
			{
				vector13 = new Vector3(vector13.x, 0f, vector13.z).normalized;
				zero3 = vector5 + vector13 * 1000f;
				Vector3 vB = vector5 + -vector13 * 1000f;
				zero3 = ODQDQDQDQO.OQQCQOCCOQ(zero3, vB, tmpNodes[1]);
				vector13 = (zero3 - tmpNodes[1]).normalized;
				float num8 = Vector3.Distance(tmpNodes[1], zero3);
				zero3 += vector13 * num8;
			}
			else
			{
				Vector3 vector14 = vector2;
				Vector3 normalized3 = new Vector3(vector13.z, 0f, 0f - vector13.x).normalized;
				zero3 = vector14 + normalized3 * 5f;
				zero = vector;
				normalized = (zero - vector14).normalized;
				zero.y = vector14.y;
				normalized2 = (zero - vector14).normalized;
				num3 = Vector3.Angle(normalized, normalized2);
				if (vector.y > vector14.y)
				{
					num3 *= -1f;
				}
				Vector3 vector15 = new Vector3(vector13.x, 0f, vector13.z);
				Vector3 vA = vector11 + -vector15 * 500f;
				Vector3 vB2 = vector12 + vector15 * 500f;
				vA.y = (vB2.y = vector14.y);
				Vector3 vector16 = ODQDQDQDQO.OQQCQOCCOQ(vA, vB2, tmpNodes[1]);
				Vector3 eulerAngles = GetEulerAngles(vector15);
				zero3 = OQOCQCOCQQ(vector14, new Vector2(5f, 0f), 90f - num3, eulerAngles);
				Vector3 normalized4 = (zero3 - vector14).normalized;
				Vector3 vector17 = vector16 - tmpNodes[1];
				Vector3 item = (-2f * (Vector3.Dot(vector17, normalized4) * normalized4) + vector17).normalized;
				float num9 = Vector3.Distance(tmpNodes[1], vector16);
				zero3 = vector16 + num9 * item;
			}
			tmpNodes.Insert(0, zero3);
			splineStrength.Insert(0, splineStrength[0]);
		}
		else if (prefabInstance.tCrossing && connectionSegment <= 1 && prefabInstance.tStraightBending)
		{
			Vector3 vector18 = prefabInstance.transform.TransformPoint(prefabInstance.tmpFullMeshVecs[prefabInstance.crossingElements[connectionSegment].fullConnectionVecInts[0]]);
			Vector3 vector19 = prefabInstance.transform.TransformPoint(prefabInstance.tmpFullMeshVecs[prefabInstance.crossingElements[connectionSegment].fullConnectionVecInts[prefabInstance.crossingElements[connectionSegment].fullConnectionVecInts.Count - 1]]);
			Vector3 vector20 = vector18 - vector19;
			vector20 = new Vector3(vector20.z, 0f, 0f - vector20.x).normalized;
			Vector3 item = tmpNodes[tmpNodes.Count - 1] + vector20 * Vector3.Distance(tmpNodes[tmpNodes.Count - 1], tmpNodes[tmpNodes.Count - 2]);
			tmpNodes.Add(item);
			splineStrength.Add(splineStrength[splineStrength.Count - 1]);
		}
		else
		{
			Vector3 vector21 = prefabInstance.transform.TransformPoint(prefabInstance.tmpMeshVecs[prefabInstance.crossingElements[connectionSegment].connectionVecInts[prefabInstance.crossingElements[connectionSegment].leftInt]]);
			Vector3 vector22 = prefabInstance.transform.TransformPoint(prefabInstance.tmpMeshVecs[prefabInstance.crossingElements[connectionSegment].connectionVecInts[prefabInstance.crossingElements[connectionSegment].rightInt]]);
			roadScr.p6 = vector21;
			roadScr.p7 = vector22;
			Vector3 vector23 = vector21 - vector22;
			vector23 = new Vector3(vector23.x, 0f, vector23.z).normalized;
			Vector3 vA2 = vector5 + vector23 * 1000f;
			Vector3 vB3 = vector5 + -vector23 * 1000f;
			vA2 = ODQDQDQDQO.OQQCQOCCOQ(vA2, vB3, tmpNodes[tmpNodes.Count - 2]);
			vector23 = (vA2 - tmpNodes[tmpNodes.Count - 2]).normalized;
			float num10 = Vector3.Distance(tmpNodes[tmpNodes.Count - 2], vA2);
			vA2 += vector23 * num10;
			tmpNodes.Add(vA2);
			splineStrength.Add(splineStrength[splineStrength.Count - 1]);
			lastForward = (vector3 - tmpNodes[tmpNodes.Count - 2]).normalized;
		}
	}

	public static int OCCCDCOQCC(ERModularRoad scr, List<Vector3> splinePoints, float minIndent, float outerRoadDistance, Vector3 ODCQDOOOCCIndent, Vector3 startPrefabIndent, int leftright)
	{
		int num = 1;
		float num2 = outerRoadDistance - minIndent;
		if (leftright == -1)
		{
			num2 = outerRoadDistance + minIndent;
		}
		bool flag = false;
		int num3 = 0;
		while (!flag && num3 < splinePoints.Count)
		{
			Vector3 vector = ((num3 == 0) ? (splinePoints[num3 + 1] - splinePoints[num3]).normalized : ((num3 != splinePoints.Count - 1) ? (splinePoints[num3 + 1] - splinePoints[num3 - 1]).normalized : (splinePoints[num3] - splinePoints[num3 - 1]).normalized));
			vector = new Vector3(0f - vector.z, 0f, vector.x);
			Vector3 vector2 = splinePoints[num3] + vector * num2;
			if (num3 == 0)
			{
				scr.prefabIndentLeft = startPrefabIndent;
				scr.prefabIndentRight = ODCQDOOOCCIndent;
				scr.roadIndent1 = vector2;
			}
			if (ODQDQDQDQO.OQCDCDOOCD(ODCQDOOOCCIndent, startPrefabIndent, vector2))
			{
				flag = true;
			}
			else
			{
				num3++;
			}
		}
		return num3;
	}

	public static int OOQQDDDOQC(ERModularRoad scr, List<Vector3> splinePoints, float minIndent, float outerRoadDistance, Vector3 ODCQDOOOCCIndent, Vector3 startPrefabIndent, int leftright, ref int endAdjustInt, ref float endAdjustDistance)
	{
		int num = 1;
		float num2 = outerRoadDistance + minIndent;
		if (leftright == -1)
		{
			num2 = outerRoadDistance - minIndent;
		}
		bool flag = false;
		bool flag2 = false;
		float num3 = 0f;
		int num4 = splinePoints.Count - 1;
		int result = num4;
		endAdjustInt = 0;
		while (!flag && num4 > 0)
		{
			Vector3 vector = ((num4 == splinePoints.Count - 1) ? (splinePoints[num4 - 1] - splinePoints[num4]).normalized : ((num4 != 0) ? (splinePoints[num4 - 1] - splinePoints[num4 + 1]).normalized : (splinePoints[num4] - splinePoints[num4 + 1]).normalized));
			vector = new Vector3(0f - vector.z, 0f, vector.x);
			Vector3 vector2 = splinePoints[num4] + vector * num2;
			if (num4 == splinePoints.Count - 1)
			{
				scr.prefabIndentLeft = startPrefabIndent;
				scr.prefabIndentRight = ODCQDOOOCCIndent;
				scr.roadIndent1 = vector2;
			}
			if (!flag2)
			{
				if (ODQDQDQDQO.OQCDCDOOCD(ODCQDOOOCCIndent, startPrefabIndent, vector2) && !flag2)
				{
					flag2 = true;
					result = num4;
				}
				else
				{
					num4--;
				}
			}
			else if (num3 >= endAdjustDistance)
			{
				flag = true;
			}
			else
			{
				num4--;
				if (flag2)
				{
					num3 += scr.faceDistance;
				}
			}
		}
		if (endAdjustDistance > num3)
		{
			endAdjustDistance = num3;
		}
		endAdjustInt = num4;
		return result;
	}

	public static ERModularRoad OCQDOCOODD(ERModularRoad scr, int marker)
	{
		scr.closedTrack = false;
		OOQQQDOCDD.UnlockSORotation(scr.soDataExt);
		GameObject gameObject = UnityEngine.Object.Instantiate(scr.gameObject);
		gameObject.transform.position = Vector3.zero;
		ERModularRoad component = gameObject.GetComponent<ERModularRoad>();
		component.gameObject.name = (component.roadName = scr.gameObject.name + "_2");
		component.transform.parent = scr.transform.parent;
		component.soDataExt.Clear();
		foreach (ERSORoadExt item in scr.soDataExt)
		{
			component.soDataExt.Add(UnityEngine.Object.Instantiate(item));
		}
		component.markersExt.Clear();
		for (int i = marker; i < scr.markersExt.Count; i++)
		{
			component.markersExt.Add(DuplicateMarker(scr.markersExt[i]));
		}
		scr.markersExt.RemoveRange(marker + 1, scr.markersExt.Count - marker - 1);
		component.startPrefabScript = null;
		component.startConnectionSegment = 0;
		if (scr.endPrefabScript != null)
		{
			scr.endPrefabScript.crossingElements[scr.endConnectionSegment].connectedRoad = component;
			scr.endPrefabScript.crossingElements[scr.endConnectionSegment].connectedMarker = component.markersExt.Count - 1;
			scr.endPrefabScript = null;
			scr.endConnectionSegment = 0;
		}
		component.gameObject.GetComponent<MeshFilter>().sharedMesh = new Mesh();
		component.gameObject.GetComponent<MeshFilter>().sharedMesh.name = component.gameObject.name;
		if (component.hasMeshCollider)
		{
			component.gameObject.GetComponent<MeshCollider>().sharedMesh = null;
			component.gameObject.GetComponent<MeshCollider>().sharedMesh = component.gameObject.GetComponent<MeshFilter>().sharedMesh;
		}
		Transform transform = component.transform.Find("surface");
		if (transform != null)
		{
			transform.gameObject.GetComponent<MeshFilter>().sharedMesh = new Mesh();
			transform.gameObject.GetComponent<MeshFilter>().sharedMesh.name = "surface";
			transform.gameObject.GetComponent<MeshCollider>().sharedMesh = transform.gameObject.GetComponent<MeshFilter>().sharedMesh;
		}
		for (int j = 0; j < scr.transform.childCount; j++)
		{
			GameObject gameObject2 = scr.transform.GetChild(j).gameObject;
			if ((bool)gameObject2.GetComponent<ERSideObjectInstance>())
			{
				UnityEngine.Object.DestroyImmediate(gameObject2);
				j--;
			}
		}
		for (int k = 0; k < component.transform.childCount; k++)
		{
			GameObject gameObject3 = component.transform.GetChild(k).gameObject;
			if ((bool)gameObject3.GetComponent<ERSideObjectInstance>())
			{
				UnityEngine.Object.DestroyImmediate(gameObject3);
				k--;
			}
		}
		Vector3 normalized = (scr.markersExt[scr.markersExt.Count - 2].position - scr.markersExt[scr.markersExt.Count - 1].position).normalized;
		scr.markersExt[scr.markersExt.Count - 1].position += normalized * 2f;
		normalized = (component.markersExt[1].position - component.markersExt[0].position).normalized;
		component.markersExt[0].position += normalized * 2f;
		scr.OCQOQCDCQC(ignorePrefabAlignment: false, forceAutoRotate: false);
		component.OCQOQCDCQC(ignorePrefabAlignment: false, forceAutoRotate: false);
		return component;
	}

	public static ERMarkerExt DuplicateMarker(ERMarkerExt sourceMarker)
	{
		ERMarkerExt eRMarkerExt = UnityEngine.Object.Instantiate(sourceMarker);
		eRMarkerExt.soData.Clear();
		foreach (ERSOMarkerExt soDatum in sourceMarker.soData)
		{
			eRMarkerExt.soData.Add(UnityEngine.Object.Instantiate(soDatum));
		}
		return eRMarkerExt;
	}

	public static GameObject JoinRoads(ref List<SelectedObject> objects, ref ERModularRoad road, ref int marker)
	{
		GameObject gameObject = null;
		ERModularRoad roadScr = objects[0].roadScr;
		ERModularRoad roadScr2 = objects[1].roadScr;
		OOQQQDOCDD.UnlockSORotation(roadScr.soDataExt);
		OOQQQDOCDD.UnlockSORotation(roadScr2.soDataExt);
		if (objects[0].markers[0] == roadScr.markersExt.Count - 1 || objects[1].markers[0] == 0)
		{
			if ((objects[0].markers[0] != 0 || roadScr.markersExt.Count == 1) && objects[1].markers[0] != 0)
			{
				roadScr2.markersExt.Reverse();
				SwapIndentsSurroundings(roadScr2);
				SwapSideObjects(roadScr2);
			}
			if (objects[0].markers[0] == 0 && roadScr.markersExt.Count > 1 && objects[1].markers[0] == 0)
			{
				roadScr2.markersExt.Reverse();
				SwapIndentsSurroundings(roadScr2);
				SwapSideObjects(roadScr2);
			}
			ODDQODOOOC.SynchSideObjects(roadScr, roadScr2);
			bool flag = false;
			if (objects[0].markers[0] == 0 && roadScr.markersExt.Count > 1)
			{
				if (Vector3.Distance(roadScr2.markersExt[roadScr2.markersExt.Count - 1].position, roadScr.markersExt[0].position) < 5f)
				{
					roadScr2.markersExt.RemoveAt(roadScr2.markersExt.Count - 1);
				}
				roadScr.markersExt.InsertRange(0, roadScr2.markersExt);
				flag = true;
			}
			else
			{
				if (roadScr.markersExt.Count == 1 && roadScr.endPrefabScript != null)
				{
					roadScr.startPrefabScript = roadScr.endPrefabScript;
					roadScr.startConnectionSegment = roadScr.endConnectionSegment;
					roadScr.startPrefabScript.crossingElements[roadScr.startConnectionSegment].connectedRoad = roadScr;
					roadScr.startPrefabScript.crossingElements[roadScr.startConnectionSegment].connectedMarker = 0;
					roadScr.startPrefabScript.crossingElements[roadScr.startConnectionSegment].connectedRoadGO = roadScr.gameObject;
				}
				if (Vector3.Distance(roadScr.markersExt[roadScr.markersExt.Count - 1].position, roadScr2.markersExt[0].position) < 5f)
				{
					roadScr2.markersExt.RemoveAt(0);
				}
				roadScr.markersExt.AddRange(roadScr2.markersExt);
			}
			if (flag)
			{
				if (roadScr2.endPrefabScript != null)
				{
					roadScr.startPrefabScript = roadScr2.endPrefabScript;
					roadScr.startConnectionSegment = roadScr2.endConnectionSegment;
				}
				else if (roadScr2.startPrefabScript != null)
				{
					roadScr.startPrefabScript = roadScr2.startPrefabScript;
					roadScr.startConnectionSegment = roadScr2.startConnectionSegment;
				}
				if (roadScr.startPrefabScript != null)
				{
					roadScr.startPrefabScript.crossingElements[roadScr.startConnectionSegment].connectedRoad = roadScr;
					roadScr.startPrefabScript.crossingElements[roadScr.startConnectionSegment].connectedMarker = 0;
					roadScr.startPrefabScript.crossingElements[roadScr.startConnectionSegment].connectedRoadGO = roadScr.gameObject;
				}
			}
			else
			{
				if (roadScr2.endPrefabScript != null)
				{
					roadScr.endPrefabScript = roadScr2.endPrefabScript;
					roadScr.endConnectionSegment = roadScr2.endConnectionSegment;
				}
				else if (roadScr2.startPrefabScript != null)
				{
					roadScr.endPrefabScript = roadScr2.startPrefabScript;
					roadScr.endConnectionSegment = roadScr2.startConnectionSegment;
				}
				if (roadScr.endPrefabScript != null)
				{
					roadScr.endPrefabScript.crossingElements[roadScr.endConnectionSegment].connectedRoad = roadScr;
					roadScr.endPrefabScript.crossingElements[roadScr.endConnectionSegment].connectedMarker = roadScr.markersExt.Count - 1;
					roadScr.endPrefabScript.crossingElements[roadScr.endConnectionSegment].connectedRoadGO = roadScr.gameObject;
				}
			}
			gameObject = roadScr2.gameObject;
			roadScr.OCQOQCDCQC(ignorePrefabAlignment: false, forceAutoRotate: false);
			road = roadScr;
			marker = objects[0].markers[0];
		}
		else
		{
			ODDQODOOOC.SynchSideObjects(roadScr2, roadScr);
			if (Vector3.Distance(roadScr2.markersExt[roadScr2.markersExt.Count - 1].position, roadScr.markersExt[0].position) < 5f)
			{
				roadScr2.markersExt.RemoveAt(roadScr2.markersExt.Count - 1);
			}
			roadScr2.markersExt.AddRange(roadScr.markersExt);
			if (objects[0].markers[0] == 0 && objects[1].markers[0] != 0 && roadScr.endPrefabScript != null)
			{
				roadScr2.endPrefabScript = roadScr.endPrefabScript;
				roadScr2.endConnectionSegment = roadScr.endConnectionSegment;
				roadScr2.endPrefabScript.crossingElements[roadScr.endConnectionSegment].connectedRoad = roadScr2;
				roadScr2.endPrefabScript.crossingElements[roadScr.endConnectionSegment].connectedMarker = roadScr2.markersExt.Count - 1;
				roadScr2.endPrefabScript.crossingElements[roadScr.endConnectionSegment].connectedRoadGO = roadScr2.gameObject;
			}
			gameObject = roadScr.gameObject;
			roadScr2.OCQOQCDCQC(ignorePrefabAlignment: false, forceAutoRotate: false);
			road = roadScr2;
			marker = objects[1].markers[0];
		}
		return gameObject;
	}

	public static void SwapIndentsSurroundings(ERModularRoad scr)
	{
		foreach (ERMarkerExt item in scr.markersExt)
		{
			float leftIndent = item.leftIndent;
			item.leftIndent = item.rightIndent;
			item.rightIndent = leftIndent;
			leftIndent = item.leftSurrounding;
			item.leftSurrounding = item.rightSurrounding;
			item.rightSurrounding = leftIndent;
			item.rotation *= -1f;
			item.rotationCenter = 1f - item.rotationCenter;
			int leftIndentAlignment = item.leftIndentAlignment;
			item.leftIndentAlignment = item.rightIndentAlignment;
			item.rightIndentAlignment = leftIndentAlignment;
		}
		float fadeInDistance = scr.fadeInDistance;
		scr.fadeInDistance = scr.fadeOutDistance;
		scr.fadeOutDistance = fadeInDistance;
	}

	public static void SwapSideObjects(ERModularRoad scr)
	{
		for (int i = 0; i < scr.markersExt.Count - 1; i++)
		{
			for (int j = 0; j < scr.markersExt[i].soData.Count; j++)
			{
				SoIndexMatch(scr.markersExt[i].soData[j], scr.markersExt[i + 1].soData, i + 1);
				if (scr.markersExt[i].soData[j] != null && scr.markersExt[i + 1].soData[j] != null)
				{
					scr.markersExt[i].soData[j].active = scr.markersExt[i + 1].soData[j].active;
					scr.markersExt[i].soData[j].startOffset = -1f * scr.markersExt[i + 1].soData[j].endOffset;
					scr.markersExt[i].soData[j].endOffset = -1f * scr.markersExt[i + 1].soData[j].startOffset;
					scr.markersExt[i].soData[j].splineActive = scr.markersExt[i + 1].soData[j].splineActive;
					scr.markersExt[i].soData[j].sidewaysDistance = scr.markersExt[i + 1].soData[j].sidewaysDistance;
				}
			}
		}
	}

	public static int SoIndexMatch(ERSOMarkerExt markerSO, List<ERSOMarkerExt> Sos, int index)
	{
		for (int i = 0; i < Sos.Count; i++)
		{
		}
		return -1;
	}

	public static bool ODCODDQDCC(List<Vector3> splinePoints, int markers)
	{
		if (splinePoints.Count < 1 || markers != 4)
		{
			return false;
		}
		return true;
	}

	public static void ODQDCODODC(ERModularRoad scr, Vector3 OOCDQCOOQC, ERCrossingPrefabs ODCQDOOOCC, int targetElement, bool reverse, bool uvReverse, bool forceAutoRotate)
	{
		bool flag = true;
		ODCQDOOOCC.crossingElements[targetElement].connectedRoad = scr;
		ODCQDOOOCC.crossingElements[targetElement].connectedMarker = scr.nodeWithinRange;
		if (ODCQDOOOCC.isFlexConnector)
		{
			ODCQDOOOCC.siblings[targetElement].road = scr;
			ODCQDOOOCC.siblings[targetElement].roadTypeIndex = QDQDOOQQDQODD.GetRoadTypeByID(scr.baseScript.roadTypes, scr.roadType);
			ODCQDOOOCC.siblings[targetElement].roadType = QDQDOOQQDQODD.GetRoadTypeElByID(scr.baseScript.roadTypes, scr.roadType);
		}
		int num = 0;
		if (scr.nodeWithinRange == 0)
		{
			scr.startPrefabScript = ODCQDOOOCC;
			scr.startConnectionSegment = targetElement;
			num = 0;
			scr.startConnectionFlag = true;
		}
		else if (scr.nodeWithinRange == scr.markersExt.Count - 1)
		{
			scr.endPrefabScript = ODCQDOOOCC;
			scr.endConnectionSegment = targetElement;
			num = 1;
			scr.endConnectionFlag = true;
		}
		ODCQDOOOCC.crossingElements[targetElement].connectedRoadGO = scr.gameObject;
		if (ODCQDOOOCC.isIConnector)
		{
			return;
		}
		bool flag2 = false;
		if (scr.nodeWithinRange != 0 && scr.startPrefabScript != null)
		{
			flag2 = scr.startPrefabScript.isIConnector;
		}
		if (scr.nodeWithinRange == 0 && scr.endPrefabScript != null)
		{
			flag2 = scr.endPrefabScript.isIConnector;
		}
		if ((scr.nodeWithinRange != 0 && (scr.startPrefabScript == null || flag2)) || (scr.nodeWithinRange == 0 && (scr.endPrefabScript == null || flag2)))
		{
			if (scr.roadType == ODCQDOOOCC.crossingElements[targetElement].roadType && scr.roadType != 0.0 && !ODCQDOOOCC.isCustomPrefab)
			{
				scr.ODDDCDQCCO(ODCQDOOOCC, targetElement, reverse, uvReverse, UpdateResolutionFlag: false);
			}
		}
		else if (reverse)
		{
			ODDCOQQDCO(scr, scr.roadShape, ODCQDOOOCC, targetElement, 0);
		}
		else
		{
			ODDCOQQDCO(scr, scr.roadShape, ODCQDOOOCC, targetElement, 1);
		}
		if (scr.roadType != ODCQDOOOCC.crossingElements[targetElement].roadType && scr.roadType != 0.0 && (ODCQDOOOCC.crossingElements[targetElement].includeLeftSidewalk || ODCQDOOOCC.crossingElements[targetElement].includeRightSidewalk))
		{
			for (int i = 0; i < ODCQDOOOCC.sidewalkControlElements.Count; i++)
			{
				if (ODCQDOOOCC.sidewalkControlElements[i].crossingElementLeftIndex == targetElement)
				{
					ODCQDOOOCC.sidewalkControlElements[i].leftConnectionHandle = false;
				}
				if (ODCQDOOOCC.sidewalkControlElements[i].crossingElementRightIndex == targetElement)
				{
					ODCQDOOOCC.sidewalkControlElements[i].rightConnectionHandle = false;
				}
			}
			ODCQDOOOCC.crossingElements[targetElement].includeLeftSidewalk = false;
			ODCQDOOOCC.crossingElements[targetElement].includeRightSidewalk = false;
			if ((bool)ODCQDOOOCC.gameObject.GetComponent<ERCrossings>())
			{
				ODCQDOOOCC.gameObject.GetComponent<ERCrossings>().OCQDQODOQD(sidewalkSceneHandleFlag: false, rebuildRoads: false);
			}
		}
		Vector3 localScale = ODCQDOOOCC.transform.localScale;
		if ((scr.roadType != ODCQDOOOCC.crossingElements[targetElement].roadType && scr.roadType != 0.0) || localScale != new Vector3(1f, 1f, 1f))
		{
			List<Vector2> list = new List<Vector2>(ODCQDOOOCC.crossingElements[targetElement].roadShapeVecs);
			if (scr.roadShape[0].x > 0f)
			{
				list.Reverse();
			}
			for (int j = 0; j < list.Count; j++)
			{
				list[j] = new Vector2(list[j].x * localScale.x, list[j].y * localScale.y);
			}
			if (num == 0)
			{
				scr.markersExt[0].roadShape = list;
				scr.markersExt[0].roadShapeDistanceMin = 0f;
				scr.markersExt[0].roadShapeDistanceMax = 0.3f;
			}
			else
			{
				scr.markersExt[scr.markersExt.Count - 1].roadShape = list;
				scr.markersExt[scr.markersExt.Count - 1].roadShapeDistanceMin = 0.7f;
				scr.markersExt[scr.markersExt.Count - 1].roadShapeDistanceMax = 1f;
				scr.markersExt[scr.markersExt.Count - 2].roadShapeDistanceMin = 0.7f;
				scr.markersExt[scr.markersExt.Count - 2].roadShapeDistanceMax = 1f;
			}
			flag = false;
		}
		scr.markersExt[scr.nodeWithinRange].position = OOCDQCOOQC;
		bool ignorePrefabAlignment = false;
		if (ODCQDOOOCC.crossingElements[targetElement].rotationPriority)
		{
			for (int k = 0; k < ODCQDOOOCC.crossingElements.Count; k++)
			{
				if (ODCQDOOOCC.crossingElements[k].connectedRoad != null && k != targetElement)
				{
					ignorePrefabAlignment = true;
				}
			}
		}
		OOCQQOOQOD.OOQCQDDOOC(scr.baseScript, ODCQDOOOCC, targetElement, scr, num);
		if (flag)
		{
			for (int l = 0; l < scr.markersExt.Count; l++)
			{
				scr.markersExt[l].roadShape.Clear();
				scr.markersExt[l].roadShape = new List<Vector2>(scr.roadShape);
			}
		}
		scr.OCQOQCDCQC(ignorePrefabAlignment, forceAutoRotate);
	}

	public static void OODCOQOQOD(ERModularRoad scr, ref List<Vector3> surfaceVecs, ERCrossingPrefabs prefabScript, ref bool startSurfacesSafe, float distance, float minIndent)
	{
		startSurfacesSafe = true;
		Transform transform = prefabScript.transform;
		if (prefabScript.surfaceObject != null)
		{
			transform = prefabScript.surfaceObject.transform;
		}
		Vector3 vector = transform.TransformPoint(prefabScript.crossingElements[scr.startConnectionSegment].leftSurroundingV3);
		Vector3 vector2 = transform.TransformPoint(prefabScript.crossingElements[scr.startConnectionSegment].rightSurroundingV3);
		Vector3 vector3 = transform.TransformPoint(prefabScript.crossingElements[scr.startConnectionSegment].leftIndentV3);
		Vector3 vector4 = transform.TransformPoint(prefabScript.crossingElements[scr.startConnectionSegment].rightIndentV3);
		if (ODQDQDQDQO.OQCDCDOOCD(vector, vector2, surfaceVecs[surfaceVecs.Count - 1]))
		{
			scr.vecsBelowTerrain.Add(surfaceVecs[surfaceVecs.Count - 1]);
			surfaceVecs[surfaceVecs.Count - 1] = vector;
			startSurfacesSafe = false;
		}
		if (ODQDQDQDQO.OQCDCDOOCD(vector3, vector4, surfaceVecs[surfaceVecs.Count - 2]))
		{
			if (distance < minIndent)
			{
				surfaceVecs[surfaceVecs.Count - 2] = vector3;
			}
			else
			{
				Vector3 vector5 = ODQDQDQDQO.OODOQDOODO(vector3, vector4, surfaceVecs[surfaceVecs.Count - 2], surfaceVecs[surfaceVecs.Count - 3], flag: false);
				if (Vector3.Distance(vector5, vector3) > Vector3.Distance(surfaceVecs[surfaceVecs.Count - 2], vector3))
				{
					surfaceVecs[surfaceVecs.Count - 2] = vector3;
				}
				else if (OQCODQODCO(vector3, vector4, vector5))
				{
					surfaceVecs[surfaceVecs.Count - 2] = vector3;
				}
				else if ((double)(distance - minIndent) < 0.25)
				{
					surfaceVecs[surfaceVecs.Count - 2] = vector3;
				}
				else
				{
					Vector3 normalized = (surfaceVecs[surfaceVecs.Count - 2] - surfaceVecs[surfaceVecs.Count - 3]).normalized;
					Vector3 p = surfaceVecs[surfaceVecs.Count - 2] + new Vector3(normalized.z, normalized.y, 0f - normalized.x) * 0.01f;
					vector5.y = ODQDQDQDQO.OQDDCCCOQD(surfaceVecs[surfaceVecs.Count - 2], surfaceVecs[surfaceVecs.Count - 3], p, vector5);
					if (Vector3.Distance(vector5, vector3) > Vector3.Distance(surfaceVecs[surfaceVecs.Count - 2], vector3))
					{
						surfaceVecs[surfaceVecs.Count - 2] = vector3;
					}
					else
					{
						surfaceVecs[surfaceVecs.Count - 2] = vector5;
					}
				}
			}
			startSurfacesSafe = false;
		}
		if (!ODQDQDQDQO.OQCDCDOOCD(vector2, vector, surfaceVecs[surfaceVecs.Count - 5]))
		{
			surfaceVecs[surfaceVecs.Count - 5] = vector2;
			startSurfacesSafe = false;
		}
		if (!ODQDQDQDQO.OQCDCDOOCD(vector4, vector3, surfaceVecs[surfaceVecs.Count - 4]))
		{
			if (distance < minIndent)
			{
				surfaceVecs[surfaceVecs.Count - 4] = vector4;
			}
			else
			{
				Vector3 vector5 = ODQDQDQDQO.OODOQDOODO(vector3, vector4, surfaceVecs[surfaceVecs.Count - 2], surfaceVecs[surfaceVecs.Count - 4], flag: false);
				scr.vecsBelowTerrain.Add(surfaceVecs[surfaceVecs.Count - 1]);
				if (Vector3.Distance(vector5, vector4) > Vector3.Distance(surfaceVecs[surfaceVecs.Count - 2], vector4))
				{
					surfaceVecs[surfaceVecs.Count - 4] = vector4;
				}
				else if (OQCODQODCO(vector4, vector3, vector5))
				{
					surfaceVecs[surfaceVecs.Count - 4] = vector4;
				}
				else if ((double)(distance - minIndent) < 0.25)
				{
					surfaceVecs[surfaceVecs.Count - 4] = vector4;
				}
				else
				{
					Vector3 normalized = (surfaceVecs[surfaceVecs.Count - 4] - surfaceVecs[surfaceVecs.Count - 2]).normalized;
					Vector3 p = surfaceVecs[surfaceVecs.Count - 4] + new Vector3(normalized.z, normalized.y, 0f - normalized.x) * 0.01f;
					vector5.y = ODQDQDQDQO.OQDDCCCOQD(surfaceVecs[surfaceVecs.Count - 2], surfaceVecs[surfaceVecs.Count - 4], p, vector5);
					surfaceVecs[surfaceVecs.Count - 4] = vector5;
				}
			}
			startSurfacesSafe = false;
		}
		if (!startSurfacesSafe)
		{
			surfaceVecs[surfaceVecs.Count - 3] = Vector3.Lerp(surfaceVecs[surfaceVecs.Count - 2], surfaceVecs[surfaceVecs.Count - 4], 0.5f);
		}
	}

	public static void ODOCCQDCQO(ERModularRoad scr, ref List<Vector3> surfaceVecs, ERCrossingPrefabs prefabScript, int el, ref bool surfacesSafe, float distance, float minIndent)
	{
		surfacesSafe = true;
		Transform transform = prefabScript.transform;
		if (prefabScript.surfaceObject != null)
		{
			transform = prefabScript.surfaceObject.transform;
		}
		Vector3 vector = transform.TransformPoint(prefabScript.crossingElements[scr.endConnectionSegment].leftSurroundingV3);
		Vector3 vector2 = transform.TransformPoint(prefabScript.crossingElements[scr.endConnectionSegment].rightSurroundingV3);
		Vector3 vector3 = transform.TransformPoint(prefabScript.crossingElements[scr.endConnectionSegment].leftIndentV3);
		Vector3 vector4 = transform.TransformPoint(prefabScript.crossingElements[scr.endConnectionSegment].rightIndentV3);
		if (ODQDQDQDQO.OQCDCDOOCD(vector, vector2, surfaceVecs[surfaceVecs.Count - 1 - el]) || el == 0)
		{
			surfaceVecs[surfaceVecs.Count - el - 1] = vector2;
			surfacesSafe = false;
		}
		if (ODQDQDQDQO.OQCDCDOOCD(vector3, vector4, surfaceVecs[surfaceVecs.Count - el - 2]) || el == 0)
		{
			if (distance < minIndent)
			{
				surfaceVecs[surfaceVecs.Count - el - 2] = vector4;
			}
			else
			{
				Vector3 vector5 = ODQDQDQDQO.OODOQDOODO(vector3, vector4, surfaceVecs[surfaceVecs.Count - el - 2], surfaceVecs[surfaceVecs.Count - el - 3], flag: false);
				if (Vector3.Distance(vector5, vector4) > Vector3.Distance(surfaceVecs[surfaceVecs.Count - 2], vector4))
				{
					surfaceVecs[surfaceVecs.Count - el - 2] = vector4;
				}
				else if (OQCODQODCO(vector4, vector3, vector5))
				{
					surfaceVecs[surfaceVecs.Count - el - 2] = vector4;
				}
				else if ((double)(distance - minIndent) < 0.25)
				{
					surfaceVecs[surfaceVecs.Count - el - 2] = vector4;
				}
				else
				{
					Vector3 normalized = (surfaceVecs[surfaceVecs.Count - el - 2] - surfaceVecs[surfaceVecs.Count - el - 3]).normalized;
					Vector3 p = surfaceVecs[surfaceVecs.Count - 2] + new Vector3(normalized.z, normalized.y, 0f - normalized.x) * 0.01f;
					vector5.y = ODQDQDQDQO.OQDDCCCOQD(surfaceVecs[surfaceVecs.Count - el - 2], surfaceVecs[surfaceVecs.Count - el - 3], p, vector5);
					surfaceVecs[surfaceVecs.Count - el - 2] = vector5;
				}
			}
			surfacesSafe = false;
		}
		if (ODQDQDQDQO.OQCDCDOOCD(vector3, vector4, surfaceVecs[surfaceVecs.Count - el - 4]) || el == 0)
		{
			if (distance < minIndent)
			{
				surfaceVecs[surfaceVecs.Count - el - 4] = vector3;
			}
			else
			{
				Vector3 vector5 = ODQDQDQDQO.OODOQDOODO(vector3, vector4, surfaceVecs[surfaceVecs.Count - el - 4], surfaceVecs[surfaceVecs.Count - el - 2], flag: false);
				if (Vector3.Distance(vector5, vector3) > Vector3.Distance(surfaceVecs[surfaceVecs.Count - 2], vector3))
				{
					surfaceVecs[surfaceVecs.Count - el - 4] = vector3;
				}
				else if (OQCODQODCO(vector3, vector4, vector5))
				{
					surfaceVecs[surfaceVecs.Count - el - 4] = vector3;
				}
				else
				{
					Vector3 normalized = (surfaceVecs[surfaceVecs.Count - el - 4] - surfaceVecs[surfaceVecs.Count - el - 2]).normalized;
					Vector3 p = surfaceVecs[surfaceVecs.Count - 4] + new Vector3(normalized.z, normalized.y, 0f - normalized.x) * 0.01f;
					vector5.y = ODQDQDQDQO.OQDDCCCOQD(surfaceVecs[surfaceVecs.Count - el - 4], surfaceVecs[surfaceVecs.Count - el - 2], p, vector5);
					surfaceVecs[surfaceVecs.Count - el - 4] = vector5;
				}
			}
			surfacesSafe = false;
		}
		if (ODQDQDQDQO.OQCDCDOOCD(vector, vector2, surfaceVecs[surfaceVecs.Count - 5 - el]) || el == 0)
		{
			surfaceVecs[surfaceVecs.Count - el - 5] = vector;
			surfacesSafe = false;
		}
		if (!surfacesSafe)
		{
			surfaceVecs[surfaceVecs.Count - el - 3] = Vector3.Lerp(surfaceVecs[surfaceVecs.Count - el - 4], surfaceVecs[surfaceVecs.Count - el - 2], 0.5f);
		}
	}

	public static void OCDCDQQQDO(ERModularRoad scr, ERCrossingPrefabs ODCQDOOOCC, int targetElement, bool reverse, bool uvReverse, bool UpdateResolutionFlag)
	{
		if (scr.baseScript == null)
		{
			if (scr.transform.parent.parent != null)
			{
				if ((bool)scr.transform.parent.parent.gameObject.GetComponent<ERModularBase>())
				{
					scr.baseScript = scr.transform.parent.parent.gameObject.GetComponent<ERModularBase>();
				}
				else if (scr.baseScript == null && scr.transform.parent.parent.parent != null)
				{
					scr.baseScript = scr.transform.parent.parent.parent.gameObject.GetComponent<ERModularBase>();
				}
			}
			if (scr.baseScript == null)
			{
				scr.baseScript = UnityEngine.Object.FindObjectOfType(typeof(ERModularBase)) as ERModularBase;
			}
		}
		if (scr.isSideObject)
		{
			return;
		}
		if (scr.baseScript != null && UpdateResolutionFlag)
		{
			QDQDOOQQDQODD.UpdateResolution(scr.baseScript.roadTypes, scr.roadType, ref scr.faceDistance, ref scr.angleTreshold);
		}
		List<Vector2> list = new List<Vector2>(scr.roadShape);
		if (reverse)
		{
			scr.geoReversed = 1;
		}
		else
		{
			scr.geoReversed = 0;
		}
		scr.roadShapeUVs.Clear();
		scr.roadShapeUVs2.Clear();
		scr.roadShapeMaterialInts.Clear();
		scr.roadShape.Clear();
		scr.doConnectionTri.Clear();
		scr.hardEdge.Clear();
		if (ODCQDOOOCC.crossingElements[targetElement].roadMaterials != null)
		{
			scr.roadMaterials = new List<Material>(ODCQDOOOCC.crossingElements[targetElement].roadMaterials).ToArray();
			scr.gameObject.GetComponent<MeshRenderer>().sharedMaterials = scr.roadMaterials;
		}
		if (reverse)
		{
			if (ODCQDOOOCC.crossingElements[targetElement].sidewalkRightVecs.Count != 0)
			{
				scr.roadShape = new List<Vector2>(ODCQDOOOCC.crossingElements[targetElement].sidewalkRightVecs);
				scr.roadShape.Reverse();
				scr.roadShapeUVs.AddRange(ODCQDOOOCC.crossingElements[targetElement].sidewalkRightUVY);
				scr.roadShapeUVs.Reverse();
				scr.roadShapeUVs2.AddRange(ODCQDOOOCC.crossingElements[targetElement].sidewalkRightUVY);
				scr.roadShapeUVs2.Reverse();
				scr.roadShapeMaterialInts.AddRange(ODCQDOOOCC.crossingElements[targetElement].sidewalkRightMaterialInts);
			}
		}
		else if (ODCQDOOOCC.crossingElements[targetElement].sidewalkLeftVecs.Count != 0)
		{
			scr.roadShape = new List<Vector2>(ODCQDOOOCC.crossingElements[targetElement].sidewalkLeftVecs);
			scr.roadShapeUVs.AddRange(ODCQDOOOCC.crossingElements[targetElement].sidewalkLeftUVY);
			scr.roadShapeUVs2.AddRange(ODCQDOOOCC.crossingElements[targetElement].sidewalkLeftUVY);
			scr.roadShapeMaterialInts.AddRange(ODCQDOOOCC.crossingElements[targetElement].sidewalkLeftMaterialInts);
		}
		List<Vector2> list2 = new List<Vector2>(ODCQDOOOCC.crossingElements[targetElement].roadShapeVecs);
		List<float> uv = new List<float>(ODCQDOOOCC.crossingElements[targetElement].roadShapeUVY);
		List<float> uv2 = new List<float>(ODCQDOOOCC.crossingElements[targetElement].roadShapeUVY2);
		List<bool> list3 = new List<bool>(ODCQDOOOCC.crossingElements[targetElement].hardEdge);
		scr.doConnectionTri.AddRange(ODCQDOOOCC.crossingElements[targetElement].doConnectionTri);
		scr.hardEdge.AddRange(ODCQDOOOCC.crossingElements[targetElement].hardEdge);
		List<Vector2> list4 = new List<Vector2>(ODCQDOOOCC.crossingElements[targetElement].sidewalkLeftVecs);
		list4.AddRange(ODCQDOOOCC.crossingElements[targetElement].roadShapeVecs);
		list4.AddRange(ODCQDOOOCC.crossingElements[targetElement].sidewalkRightVecs);
		if (reverse)
		{
			list2.Reverse();
			uv.Reverse();
			uv2.Reverse();
			scr.doConnectionTri.Reverse();
			scr.hardEdge.Reverse();
			for (int i = 1; i < scr.doConnectionTri.Count; i++)
			{
				scr.doConnectionTri[i - 1] = scr.doConnectionTri[i];
			}
		}
		if (ODCQDOOOCC.isCustomPrefab && !reverse && !uvReverse)
		{
			for (int j = 0; j < uv.Count; j++)
			{
			}
			ODQOCCDCOC(ref uv, ref uv2);
		}
		scr.roadShape.AddRange(list2);
		scr.roadShapeUVs.AddRange(uv);
		scr.roadShapeUVs2.AddRange(uv2);
		scr.roadShapeMaterialInts.AddRange(ODCQDOOOCC.crossingElements[targetElement].roadShapeMaterialInts);
		if (reverse)
		{
			if (ODCQDOOOCC.crossingElements[targetElement].sidewalkLeftVecs.Count != 0)
			{
				list2 = new List<Vector2>(ODCQDOOOCC.crossingElements[targetElement].sidewalkLeftVecs);
				list2.Reverse();
				scr.roadShape.AddRange(list2);
				uv.Clear();
				uv2.Clear();
				uv.AddRange(ODCQDOOOCC.crossingElements[targetElement].sidewalkLeftUVY);
				uv2.AddRange(ODCQDOOOCC.crossingElements[targetElement].sidewalkLeftUVY);
				uv.Reverse();
				uv2.Reverse();
				scr.roadShapeUVs.AddRange(uv);
				scr.roadShapeUVs2.AddRange(uv2);
				scr.roadShapeMaterialInts.AddRange(ODCQDOOOCC.crossingElements[targetElement].sidewalkLeftMaterialInts);
			}
		}
		else if (ODCQDOOOCC.crossingElements[targetElement].sidewalkRightVecs.Count != 0)
		{
			scr.roadShape.AddRange(ODCQDOOOCC.crossingElements[targetElement].sidewalkRightVecs);
			scr.roadShapeUVs.AddRange(ODCQDOOOCC.crossingElements[targetElement].sidewalkRightUVY);
			scr.roadShapeUVs2.AddRange(ODCQDOOOCC.crossingElements[targetElement].sidewalkRightUVY);
			scr.roadShapeMaterialInts.AddRange(ODCQDOOOCC.crossingElements[targetElement].sidewalkRightMaterialInts);
		}
		if (reverse)
		{
			scr.roadShapeMaterialInts.Reverse();
		}
		if (scr.nodeWithinRange > 0)
		{
			for (int k = 0; k < scr.roadShape.Count; k++)
			{
				Vector3 vector = scr.roadShape[k];
				vector.x *= -1f;
				scr.roadShape[k] = vector;
			}
		}
		else if (ODCQDOOOCC.isCustomPrefab && targetElement == 0)
		{
			for (int l = 0; l < scr.roadShapeUVs.Count; l++)
			{
			}
			ODQOCCDCOC(ref uv, ref uv2);
		}
		scr.roadShapeMatchCount = 0;
		string text = "";
		string text2 = "";
		bool flag = true;
		for (int m = 0; m < list4.Count; m++)
		{
			flag = true;
			if (m > 0 && (double)Vector2.Distance(list4[m - 1], list4[m]) < 0.01)
			{
				flag = false;
			}
			if (flag)
			{
				Vector2 vector2 = list4[m];
				vector2.x = (float)Math.Round(vector2.x, 1, MidpointRounding.AwayFromZero);
				vector2.y = (float)Math.Round(vector2.y, 1, MidpointRounding.AwayFromZero);
				text = text + vector2.x + ", " + vector2.y + ";";
				vector2.x *= -1f;
				text2 = vector2.x + ", " + vector2.y + ";" + text2;
				scr.roadShapeMatchCount++;
			}
		}
		if (reverse)
		{
			scr.roadShapeString = text;
			scr.roadShapeReversedString = text2;
		}
		else
		{
			scr.roadShapeString = text2;
			scr.roadShapeReversedString = text;
		}
		if (reverse)
		{
			OCCCDQCDOC(scr, scr.roadShape, null, 0);
		}
		else
		{
			OCCCDQCDOC(scr, scr.roadShape, null, 1);
		}
		for (int n = 0; n < scr.markersExt.Count; n++)
		{
			bool flag2 = true;
			if (list.Count == scr.roadShape.Count)
			{
				for (int num = 0; num < scr.markersExt[n].roadShape.Count; num++)
				{
					if (scr.markersExt[n].roadShape[num] != list[num])
					{
						flag2 = false;
						break;
					}
				}
			}
			if (flag2)
			{
				scr.markersExt[n].roadShape.Clear();
				scr.markersExt[n].roadShape = new List<Vector2>(scr.roadShape);
			}
		}
	}

	public static void ODQOCCDCOC(ref List<float> uv1, ref List<float> uv2)
	{
		if (uv1.Count != uv2.Count)
		{
			uv2 = new List<float>(uv1);
		}
		string text = "";
		string text2 = "";
		for (int i = 0; i < uv1.Count; i++)
		{
			text = text + uv1[i] + ",";
			text2 = text2 + uv2[i] + ",";
		}
		if (text == text2)
		{
			for (int j = 0; j < uv1.Count; j++)
			{
				uv1[j] = 1f - uv1[j];
				uv2[j] = 1f - uv2[j];
			}
			return;
		}
		List<float> list = new List<float>();
		List<float> list2 = new List<float>();
		List<float> list3 = new List<float>();
		List<float> list4 = new List<float>();
		list = new List<float>(uv2);
		list2 = new List<float>(uv1);
		uv1 = new List<float>(list);
		uv2 = new List<float>(list2);
	}

	public static List<int> OCCCDQCDOC(ERModularRoad scr, List<Vector2> roadShapeVecs, List<Vector2> connectionVecs, int startend)
	{
		List<int> list = new List<int>();
		List<int> list2 = new List<int>();
		int num = 0;
		for (int i = 0; i < roadShapeVecs.Count; i++)
		{
			list.Add(i);
			list2.Add(i + num);
			if (scr.hardEdge.Count > i && scr.hardEdge[i])
			{
				num++;
				list2.Add(i + num);
			}
		}
		if (startend == 0)
		{
			scr.roadShapeIntsStart = new List<int>(list);
		}
		else
		{
			scr.roadShapeIntsEnd = new List<int>(list);
		}
		if (scr.startPrefabScript != null && scr.endPrefabScript != null)
		{
			scr.roadShapeIntsStart = new List<int>(list);
			scr.roadShapeIntsEnd = new List<int>(list);
		}
		return list;
	}

	public static List<int> ODDCOQQDCO(ERModularRoad scr, List<Vector2> roadShapeVecs, ERCrossingPrefabs prefab, int connection, int startend)
	{
		List<int> list = new List<int>();
		List<int> list2 = new List<int>();
		List<Vector2> list3 = new List<Vector2>();
		list3.AddRange(prefab.crossingElements[connection].sidewalkLeftVecs);
		list3.AddRange(prefab.crossingElements[connection].roadShapeVecs);
		list3.AddRange(prefab.crossingElements[connection].sidewalkRightVecs);
		List<Vector2> list4 = new List<Vector2>(list3);
		if (roadShapeVecs.Count == list3.Count)
		{
			for (int i = 0; i < roadShapeVecs.Count; i++)
			{
				list.Add(i);
			}
		}
		else if (roadShapeVecs.Count > list3.Count)
		{
			int num = 0;
			list.Add(0);
			for (int j = 1; j < roadShapeVecs.Count; j++)
			{
				if ((double)Vector2.Distance(roadShapeVecs[j], roadShapeVecs[j - 1]) > 0.01)
				{
					num++;
				}
				list.Add(num);
			}
		}
		else
		{
			int num2 = 0;
			list.Add(0);
			for (int k = 1; k < list3.Count; k++)
			{
				if ((double)Vector2.Distance(list3[k], list3[k - 1]) > 0.01)
				{
					list.Add(k);
				}
			}
		}
		if (startend == 0)
		{
			scr.roadShapeIntsStart = new List<int>(list);
		}
		else
		{
			scr.roadShapeIntsEnd = new List<int>(list);
		}
		return list;
	}

	public static void OOCQODCOOQ(ERModularBase baseScr, ERModularRoad scr, int m1, int m2, int m3)
	{
		if (scr.startPrefabScript == null)
		{
			return;
		}
		GameObject gameObject = scr.startPrefabScript.gameObject;
		scr.startPrefabScript.crossingElements[scr.startConnectionSegment].connectedRoad = null;
		scr.startPrefabScript.crossingElements[scr.startConnectionSegment].connectedMarker = -1;
		scr.startPrefabScript.crossingElements[scr.startConnectionSegment].connectedRoadGO = null;
		scr.startPrefabScript = null;
		scr.startConnectionSegment = -1;
		Vector3 normalized = (scr.markersExt[m1].position - scr.markersExt[m2].position).normalized;
		scr.markersExt[m3].position += 5f * normalized;
		scr.OCQOQCDCQC(ignorePrefabAlignment: false, forceAutoRotate: false);
		if ((bool)gameObject.GetComponent<ERCrossings>())
		{
			ERCrossings component = gameObject.GetComponent<ERCrossings>();
			if (component.tCrossing && component.tStraightBending)
			{
				component.OCQDQODOQD(sidewalkSceneHandleFlag: false, rebuildRoads: true);
			}
		}
	}

	public static void ODQDQOQQCO(ERModularBase baseScr, ERModularRoad scr, int m1, int m2, int m3)
	{
		if (scr.endPrefabScript == null)
		{
			return;
		}
		GameObject gameObject = scr.endPrefabScript.gameObject;
		scr.endPrefabScript.crossingElements[scr.endConnectionSegment].connectedRoad = null;
		scr.endPrefabScript.crossingElements[scr.endConnectionSegment].connectedMarker = -1;
		scr.endPrefabScript.crossingElements[scr.endConnectionSegment].connectedRoadGO = null;
		scr.endPrefabScript = null;
		scr.endConnectionSegment = -1;
		Vector3 normalized = (scr.markersExt[m1].position - scr.markersExt[m2].position).normalized;
		scr.markersExt[m3].position += 5f * normalized;
		scr.OCQOQCDCQC(ignorePrefabAlignment: false, forceAutoRotate: false);
		if ((bool)gameObject.GetComponent<ERCrossings>())
		{
			ERCrossings component = gameObject.GetComponent<ERCrossings>();
			if (component.tCrossing && component.tStraightBending)
			{
				component.OCQDQODOQD(sidewalkSceneHandleFlag: false, rebuildRoads: true);
			}
		}
	}

	public static void OCDDCDDCQC(ERModularBase baseScript, ref List<Vector3> vecs, List<float> tValues, float heigthOffset, ref Vector3 lastHeightAdjustCP, float resolution, float distance, bool nextMarkerContourAdjust, List<Vector3> currentVecs, ref List<Vector3> testPoints, ref List<float> randomRotations)
	{
		if (vecs.Count < 2)
		{
			return;
		}
		Vector3 zero = Vector3.zero;
		Vector3 vector = vecs[0];
		float y = vector.y;
		int num = 0;
		Vector3 vector2 = vecs[0];
		Vector3 vector3 = vecs[0];
		List<float> tmpTValues = new List<float>();
		List<List<float>> list = new List<List<float>>();
		List<Vector3> list2 = new List<Vector3>();
		float num2 = 0f;
		Vector3 vector4 = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		Vector3 zero3 = Vector3.zero;
		float num3 = 0f;
		if (lastHeightAdjustCP == Vector3.zero)
		{
			vector4 = (vecs[0] - vecs[1]).normalized;
			Vector3 pos = vecs[0] + vector4 * 10f;
			baseScript.OCDDQOCDCO(ref pos);
			list2.Add(pos);
		}
		else
		{
			list2.Add(lastHeightAdjustCP);
			num2 = lastHeightAdjustCP.x;
		}
		zero2 = vector4;
		Vector3 vector5 = (zero3 = vector);
		Vector3 pos2 = vecs[vecs.Count - 1] + (vecs[vecs.Count - 1] - vecs[vecs.Count - 2]).normalized * 5f;
		baseScript.OCDDQOCDCO(ref pos2);
		list2.Add(vector);
		float num4 = 8f;
		if (!nextMarkerContourAdjust)
		{
			num4 = 20f;
		}
		int num5 = 0;
		float num6 = (float)vecs.Count * 0.5f;
		float num7 = 0f;
		float num8 = 0f;
		float num9 = 0f;
		bool flag = false;
		for (int i = 0; i < vecs.Count; i++)
		{
			if (i > 0)
			{
				num8 += Vector3.Distance(vecs[i - 1], vecs[i]);
			}
			flag = false;
			vector = vecs[i];
			if (nextMarkerContourAdjust || (float)i < num6)
			{
				baseScript.OCDDQOCDCO(ref vector);
			}
			else
			{
				Vector3 pos3 = vector;
				baseScript.OCDDQOCDCO(ref pos3);
				num7 = pos3.y;
				vector.y = Mathf.Lerp(num7, vector.y, ((float)i - num6) / num6);
			}
			if (Mathf.Abs(vector.y - y) > heigthOffset && num8 > 5f && num8 + num4 < distance)
			{
				flag = true;
			}
			if (!flag && i < vecs.Count - 1)
			{
				vector4 = (vector5 - vector).normalized;
				if (((vector4.y > 0f && zero2.y < 0f) || (vector4.y < 0f && zero2.y > 0f)) && Vector3.Distance(vector, zero3) > 2f * heigthOffset && num8 > 5f && num8 + num4 < distance)
				{
					flag = true;
				}
			}
			zero2 = vector4;
			vector5 = vector;
			if (flag)
			{
				list.Add(new List<float>());
				OQDOQOCDCC(num, i, tValues, ref tmpTValues);
				list[num5].AddRange(tmpTValues);
				list2.Add(vector);
				num5++;
				num = i;
				y = vector.y;
				zero3 = vector;
			}
		}
		if (num != vecs.Count - 1)
		{
			vector = vecs[vecs.Count - 1];
			if (nextMarkerContourAdjust)
			{
				baseScript.OCDDQOCDCO(ref vector);
			}
			list.Add(new List<float>());
			OQDOQOCDCC(num, vecs.Count - 1, tValues, ref tmpTValues);
			list[num5].AddRange(tmpTValues);
			list2.Add(vector);
		}
		list2.Add(pos2);
		num5 = 0;
		for (int j = 1; j < list2.Count - 2; j++)
		{
			for (int k = 0; k < list[j - 1].Count; k++)
			{
				vector = ERModularRoad.OODODQQQCD(list2[j - 1], list2[j], list2[j + 1], list2[j + 2], list[j - 1][k], 0.5f);
				if (num5 < vecs.Count - 1)
				{
					zero = vecs[num5];
					zero.y = vector.y;
					vecs[num5] = zero;
				}
				num5++;
			}
		}
		lastHeightAdjustCP = list2[list2.Count - 3];
	}

	public static void OQDOQOCDCC(int lastInt, int currentInt, List<float> tValues, ref List<float> tmpTValues)
	{
		tmpTValues.Clear();
		float num = tValues[lastInt];
		float num2 = tValues[currentInt];
		float num3 = num2 - num;
		for (int i = lastInt; i < currentInt; i++)
		{
			tmpTValues.Add((tValues[i] - num) / num3);
		}
	}

	public static bool OQCODQODCO(Vector3 ODCQDOOOCCIndent, Vector3 otherPrefabIndent, Vector3 v)
	{
		ODCQDOOOCCIndent.y = (otherPrefabIndent.y = (v.y = 0f));
		if (Vector3.Distance(v, otherPrefabIndent) < Vector3.Distance(ODCQDOOOCCIndent, otherPrefabIndent))
		{
			return true;
		}
		return false;
	}

	public static Vector3 OQOCQCOCQQ(Vector3 position, Vector3 sourceV3, float angle, Vector3 euler)
	{
		Vector3 point = new Vector3(sourceV3.x, 0f - sourceV3.y, 0f);
		return position + ODQDQDQDQO.OQDDDODCOC(point, Vector3.zero, Quaternion.Euler(euler.x, euler.y, angle));
	}

	public static Vector3 ODOQCDQQCC(Vector3 position, Vector3 sourceV3, float angle, Vector3 euler)
	{
		Vector3 point = new Vector3(0f - sourceV3.x, 0f - sourceV3.y, 0f);
		return position + ODQDQDQDQO.OQDDDODCOC(point, Vector3.zero, Quaternion.Euler(euler.x, euler.y, angle));
	}

	public static Vector3 GetEulerAngles(Vector3 v3direction)
	{
		float num = Mathf.Atan2(v3direction.x, v3direction.z) * 57.29578f;
		Quaternion identity = Quaternion.identity;
		if (v3direction != Vector3.zero)
		{
			identity.SetLookRotation(v3direction, Vector3.up);
		}
		return identity.eulerAngles;
	}

	public static void ODCQCQCQDQ(GameObject road, Mesh sourceMesh, int LODCount, int LODLevel, int colCount, List<bool> hardEdge, List<int> roadShapeMaterialIntCounts)
	{
		for (int i = 0; i < hardEdge.Count; i++)
		{
			if (hardEdge[i])
			{
				colCount++;
			}
		}
		Mesh sharedMesh = road.GetComponent<MeshFilter>().sharedMesh;
		Transform transform = road.transform.Find("LOD " + LODCount);
		GameObject gameObject;
		Mesh mesh;
		if (transform == null)
		{
			gameObject = new GameObject("LOD " + LODCount);
			gameObject.AddComponent<MeshFilter>();
			gameObject.AddComponent<MeshRenderer>();
			gameObject.AddComponent<MeshCollider>();
			gameObject.transform.parent = road.transform;
			gameObject.isStatic = true;
			gameObject.layer = road.layer;
			if (!string.IsNullOrEmpty(road.tag))
			{
				gameObject.tag = road.tag;
			}
			gameObject.GetComponent<MeshRenderer>().lightProbeUsage = road.GetComponent<MeshRenderer>().lightProbeUsage;
			gameObject.GetComponent<MeshRenderer>().shadowCastingMode = road.GetComponent<MeshRenderer>().shadowCastingMode;
			mesh = new Mesh();
			gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
			gameObject.GetComponent<MeshCollider>().sharedMesh = sharedMesh;
			gameObject.isStatic = true;
		}
		else
		{
			gameObject = transform.gameObject;
			if (gameObject.GetComponent<MeshFilter>() == null)
			{
				gameObject.AddComponent<MeshFilter>();
			}
			if (gameObject.GetComponent<MeshRenderer>() == null)
			{
				gameObject.AddComponent<MeshRenderer>();
			}
			if (gameObject.GetComponent<MeshCollider>() == null)
			{
				gameObject.AddComponent<MeshCollider>();
			}
			mesh = gameObject.GetComponent<MeshFilter>().sharedMesh;
			gameObject.isStatic = true;
			mesh = new Mesh();
			gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
			gameObject.GetComponent<MeshCollider>().sharedMesh = sharedMesh;
		}
		gameObject.GetComponent<MeshRenderer>().sharedMaterials = road.GetComponent<MeshRenderer>().sharedMaterials;
		if (LODCount == 0)
		{
			gameObject.GetComponent<MeshFilter>().sharedMesh = sharedMesh;
			gameObject.GetComponent<MeshCollider>().sharedMesh = sharedMesh;
			return;
		}
		List<List<int>> list = new List<List<int>>();
		List<int> list2 = new List<int>();
		int num = colCount * LODLevel;
		for (int j = 0; j < sharedMesh.subMeshCount; j++)
		{
			list.Add(new List<int>());
			num = colCount * LODLevel;
			int[] triangles = sharedMesh.GetTriangles(j);
			int num2 = 0;
			bool flag = true;
			if (triangles.Length == 0)
			{
				flag = false;
			}
			int num3 = 1;
			while (flag)
			{
				list[j].Add(triangles[num2]);
				list[j].Add(triangles[num2 + 1] + num);
				list[j].Add(triangles[num2 + 2]);
				list[j].Add(triangles[num2 + 3] + num);
				list[j].Add(triangles[num2 + 4] + num);
				list[j].Add(triangles[num2 + 5]);
				num2 += 6;
				num3++;
				if (roadShapeMaterialIntCounts.Count > j)
				{
					if (num3 > roadShapeMaterialIntCounts[j] - 1)
					{
						num3 = 1;
						num2 += 6 * (roadShapeMaterialIntCounts[j] - 1) * LODLevel;
					}
				}
				else
				{
					UnityEngine.Debug.Log("EasyRoads3Dv3: Error building LODs for road: " + road.name);
				}
				if (num2 + 4 < triangles.Length)
				{
					if (triangles[num2 + 4] + num >= sharedMesh.vertices.Length)
					{
						num = 0;
					}
				}
				else
				{
					flag = false;
				}
			}
			int num4 = 0;
			int num5 = sharedMesh.vertices.Length - colCount;
			int num6 = list[j].Count - 1;
			for (int num7 = triangles.Length - 1; num7 > 0; num7 -= 3)
			{
				bool flag2 = false;
				if (triangles[num7] >= num5)
				{
					list[j][num6 - num4] = triangles[num7];
					flag2 = true;
				}
				num4++;
				if (triangles[num7 - 1] >= num5)
				{
					flag2 = true;
					list[j][num6 - num4] = triangles[num7 - 1];
				}
				num4++;
				if (triangles[num7 - 2] >= num5)
				{
					flag2 = true;
					list[j][num6 - num4] = triangles[num7 - 2];
				}
				num4++;
				if (!flag2)
				{
					break;
				}
			}
		}
		List<Vector3> vecs = new List<Vector3>();
		List<Vector2> uvs = new List<Vector2>();
		List<Vector2> uvs2 = new List<Vector2>();
		List<Color> colors = new List<Color>();
		List<Vector3> normals = new List<Vector3>();
		List<Vector4> tangents = new List<Vector4>();
		List<List<int>> tris = new List<List<int>>();
		ODCCODOCQQ.CleanMeshData(sharedMesh, list, ref vecs, ref uvs, ref uvs2, ref normals, ref tangents, ref colors, ref tris);
		mesh.Clear();
		mesh.vertices = vecs.ToArray();
		mesh.uv = uvs.ToArray();
		mesh.uv4 = uvs2.ToArray();
		mesh.colors = colors.ToArray();
		mesh.tangents = tangents.ToArray();
		mesh.subMeshCount = list.Count;
		for (int k = 0; k < tris.Count; k++)
		{
			mesh.SetTriangles(tris[k].ToArray(), k);
		}
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();
	}

	public static void ODQCQCOOCQ(ERCrossingPrefabs prefab, ERModularRoad road, int connectionIndex, int startEnd)
	{
		Vector3 vector = road.soSplinePoints[0];
		Vector3 vector2 = road.soSplinePoints[1];
		if (startEnd == 0)
		{
			vector = road.soSplinePoints[0];
			vector2 = road.soSplinePoints[1];
		}
		else
		{
			vector = road.soSplinePoints[road.soSplinePoints.Count - 1];
			vector2 = road.soSplinePoints[road.soSplinePoints.Count - 2];
		}
		Vector3 normalized = (vector - vector2).normalized;
		float num = Vector3.Distance(prefab.crossingElements[connectionIndex].centerPoint, Vector3.zero);
		prefab.transform.position = vector + normalized * num;
	}
}
[AddComponentMenu("")]
public class ERTerrain : MonoBehaviour
{
	public List<Vector3> surfacevecs;

	public float[] tdataFloat;

	public TerrainData terrainData;

	public int xStart = 0;

	public int zStart = 0;

	public GameObject roadSurface;

	public Mesh surfaceMesh;

	public MeshCollider surfaceCollider;

	public List<ERTerrainData> terrainDataStored = new List<ERTerrainData>();

	public List<ERTerrainChange> terrainChanges = new List<ERTerrainChange>();

	public List<ERTree> terrainTrees = new List<ERTree>();

	public List<List<tPoint>> detailInstancesOld = new List<List<tPoint>>();

	public List<tPoint> detailInstances = new List<tPoint>();

	public List<int> detailInstanceStarts = new List<int>();

	public List<GameObject> surfaceObjects = new List<GameObject>();

	public List<Vector3> terrainTestPoints = new List<Vector3>();

	public List<ERSplatmap> splatData = new List<ERSplatmap>();

	public List<ERTreeInstance> addedTrees = new List<ERTreeInstance>();

	public List<ERCell> holes = new List<ERCell>();

	public List<ERTerrainData> terrainHeightsBackup = new List<ERTerrainData>();

	public List<ERTree> terrainTreesBackup = new List<ERTree>();

	public List<tPoint> terrainDetailBackup = new List<tPoint>();

	public List<ERSplatmap> terrainSplatBackup = new List<ERSplatmap>();

	public List<int> detailInstanceStartsBackUp = new List<int>();

	public bool heightmapFlag;

	public bool splatmapFlag;

	public bool treeFlag;

	public bool detailFlag;

	public bool holesFlag;

	public bool terrainDone;

	public bool backupFlagNotification = false;

	public bool ignore = false;

	public GameObject backupObject;

	public TerrainData terrain;
}
[AddComponentMenu("")]
public class QDQDOOQQOOQDD : MonoBehaviour
{
	private List<Vector3> á;

	private float[,] á;

	private float[] á;

	private TerrainData 4AAAA;

	public static float minx;

	public static float minz;

	public static float maxx;

	public static float maxz;

	public static Vector2 splatMapScale;

	public static List<GameObject> surfaceObjects = new List<GameObject>();

	public static List<GameObject> tunnelObjects = new List<GameObject>();

	public static int crossingSurfacesStart = 0;

	public static int sideObjectSurfacesStart = 0;

	public static List<GameObject> treeObjects = new List<GameObject>();

	public static List<GameObject> detailObjects = new List<GameObject>();

	public static void ODDCCODOOC(ERModularBase scr, Terrain terrain)
	{
		minx = (minz = 100000f);
		maxx = (maxz = -100000f);
		surfaceObjects.Clear();
		treeObjects.Clear();
		detailObjects.Clear();
		scr.soSplatmapObjects.Clear();
		ERTerrain[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERTerrain)) as ERTerrain[];
		OQOQCCCODC(scr, ref minx, ref minz, ref maxx, ref maxz, 0f);
		ERTerrain[] array2 = array;
		foreach (ERTerrain eRTerrain in array2)
		{
			ODCQDDOQCD(scr, eRTerrain, eRTerrain.gameObject.GetComponent<Terrain>(), minx, maxx, minz, maxz);
			eRTerrain.enabled = false;
		}
		foreach (GameObject surfaceObject in surfaceObjects)
		{
			if (surfaceObject != null)
			{
				surfaceObject.SetActive(value: false);
			}
		}
	}

	public static void ODCQDDOQCD(ERModularBase scr, ERTerrain terrainScr, Terrain terrain, float m_minx, float m_maxx, float m_minz, float m_maxz)
	{
		if (scr.OCCQOOOQQO != null)
		{
			scr.OCCQOOOQQO.debugVecs.Clear();
			scr.OCCQOOOQQO.debugFloats.Clear();
		}
		scr.terrainHits.Clear();
		terrainScr.terrainTrees.Clear();
		terrainScr.detailInstances.Clear();
		terrainScr.splatData.Clear();
		terrainScr.terrainChanges.Clear();
		if (terrainScr.terrainData == null || terrainScr.terrainData != terrain.terrainData)
		{
			terrainScr.terrainData = terrain.terrainData;
		}
		TerrainData terrainData = terrainScr.terrainData;
		float[,] heights = terrainData.GetHeights(0, 0, terrainData.heightmapResolution, terrainData.heightmapResolution);
		int heightmapResolution = terrainData.heightmapResolution;
		int num = 0;
		float num2 = m_minx;
		float num3 = m_maxx;
		float num4 = m_minz;
		float num5 = m_maxz;
		float num6 = terrain.transform.position.x;
		float num7 = terrain.transform.position.z;
		if (terrain.transform.position.x != 0f)
		{
			num2 -= terrain.transform.position.x;
			num3 -= terrain.transform.position.x;
			num6 = 0f;
		}
		if (terrain.transform.position.z != 0f)
		{
			num4 -= terrain.transform.position.z;
			num5 -= terrain.transform.position.z;
			num7 = 0f;
		}
		if (num2 < num6)
		{
			num2 = 0f;
		}
		if (num4 < num7)
		{
			num4 = 0f;
		}
		num3 -= num6;
		if (num3 > terrainData.size.x)
		{
			num3 = terrainData.size.x;
		}
		num5 -= num7;
		if (num5 > terrainData.size.z)
		{
			num5 = terrainData.size.z;
		}
		int num8 = Mathf.RoundToInt(Mathf.Floor(num2 / terrainData.heightmapScale.x));
		int num9 = Mathf.RoundToInt(Mathf.Ceil(num3 / terrainData.heightmapScale.x));
		int num10 = Mathf.RoundToInt(Mathf.Floor(num4 / terrainData.heightmapScale.z));
		int num11 = Mathf.RoundToInt(Mathf.Ceil(num5 / terrainData.heightmapScale.z));
		if (terrainData.heightmapResolution - num9 == 1)
		{
			num9 = terrainData.heightmapResolution;
		}
		if (terrainData.heightmapResolution - num11 == 1)
		{
			num11 = terrainData.heightmapResolution;
		}
		if (num8 < 0 || num8 > terrainData.heightmapResolution || num10 < 0 || num10 > terrainData.heightmapResolution || num9 < 0 || num9 > terrainData.heightmapResolution || num11 < 0 || num11 > terrainData.heightmapResolution)
		{
			return;
		}
		float[,] heights2 = terrainData.GetHeights(num8, num10, num9 - num8, num11 - num10);
		terrainScr.xStart = num8;
		terrainScr.zStart = num10;
		float x = terrain.transform.position.x;
		float z = terrain.transform.position.z;
		float y = terrain.transform.position.y;
		terrainScr.terrainDataStored.Clear();
		foreach (GameObject surfaceObject in surfaceObjects)
		{
			surfaceObject.SetActive(value: true);
		}
		LayerMask layerMask = 1 << scr.sLayer;
		Ray ray = new Ray
		{
			direction = Vector3.down
		};
		float y2 = terrainData.size.y;
		float perc = 0f;
		bool critical = false;
		float num12 = 0f;
		float outerHeight = 0f;
		Vector3 zero = Vector3.zero;
		float y3 = terrain.transform.position.y;
		float preserveTerrainFloat = scr.preserveTerrainFloat;
		try
		{
			if (scr.doHeightmap)
			{
				scr.progressMax = num9 - num8;
				for (int i = 0; i < num9 - num8; i++)
				{
					scr.progressStatus = i;
					for (int j = 0; j < num11 - num10; j++)
					{
						float y4 = y3 + heights2[j, i] * y2 + 100f;
						Vector3 origin = new Vector3(x + (float)(num8 + i) * terrainData.heightmapScale.x, y4, z + (float)(num10 + j) * terrainData.heightmapScale.z);
						if (Physics.Raycast(origin, -Vector3.up, out var hitInfo, 500f, layerMask))
						{
							Vector3 point = hitInfo.point;
							point.y -= y3;
							zero = Vector3.zero;
							OOCQDQCDOD(hitInfo.triangleIndex, hitInfo.collider, point, ref perc, ref critical, ref outerHeight, ref zero, hitInfo);
							float num13 = point.y / terrainData.size.y;
							outerHeight = (outerHeight - y3) / terrainData.size.y;
							ERTerrainData eRTerrainData = new ERTerrainData(j, i, heights2[j, i], num13, critical, perc, outerHeight, point, zero);
							terrainScr.terrainDataStored.Add(eRTerrainData);
							if (critical)
							{
								terrainScr.terrainChanges.Add(new ERTerrainChange((num10 + j) * heightmapResolution + (num8 + i), 2));
							}
							else
							{
								terrainScr.terrainChanges.Add(new ERTerrainChange((num10 + j) * heightmapResolution + (num8 + i), 1));
							}
							if (hitInfo.collider.name == "surface")
							{
								num12 = Mathf.Lerp(1f, perc, preserveTerrainFloat);
								num13 = Mathf.Lerp(heights2[j, i], num13, num12);
							}
							else
							{
								eRTerrainData.ignorePreserveHeights = true;
							}
							heights2[j, i] = num13;
						}
					}
				}
				terrainData.SetHeights(num8, num10, heights2);
				terrainScr.heightmapFlag = true;
			}
		}
		catch
		{
			UnityEngine.Debug.LogError("EasyRoads3Dv3: Updating the heightmap of terrain " + terrain.name + " failed. EasyRoads3Dv3 uses Layer 31 by default (General Settings > Scene Settings > EasyRoads3Dv3 layer). Is this layer also used for other obects? Otherwise, please report with details!");
			UnityEngine.Debug.LogError("Additional info: " + num8 + " " + num9 + " " + num10 + " " + num11 + " " + heights2.Length);
		}
		for (int k = 0; k < crossingSurfacesStart; k++)
		{
			surfaceObjects[k].SetActive(value: false);
		}
		if (scr.doTrees)
		{
			try
			{
				ODQODCQQCQ(scr, terrainScr, terrain, num2, num3, num4, num5);
				terrainScr.treeFlag = true;
			}
			catch
			{
				UnityEngine.Debug.LogError("EasyRoads3Dv3: Removing trees from terrain " + terrain.name + " failed, please report with details!");
			}
		}
		if (scr.doDetail)
		{
			try
			{
				OOCDDQCCDD(scr, terrainScr, terrain, num2, num3, num4, num5);
				terrainScr.detailFlag = true;
			}
			catch
			{
				UnityEngine.Debug.LogError("EasyRoads3Dv3: Removing detail objects from terrain " + terrain.name + " failed, please report with details!");
			}
		}
		foreach (GameObject surfaceObject2 in surfaceObjects)
		{
			surfaceObject2.SetActive(value: false);
		}
		if (scr.doSplatmaps && scr.soSplatmapObjects.Count > 0)
		{
			try
			{
				ODQCOCOQQD(scr, terrainScr, terrain, num2, num3, num4, num5);
				terrainScr.splatmapFlag = true;
			}
			catch
			{
				UnityEngine.Debug.LogError("EasyRoads3Dv3: Adding road shape to terrain " + terrain.name + " failed, please report with details!");
			}
		}
		terrain.Flush();
		terrainScr.terrainDone = true;
	}

	public static void OOCQDQCDOD(int triangleIndex, Collider collider, Vector3 hitPos, ref float perc, ref bool critical, ref float outerHeight, ref Vector3 outerPoint, RaycastHit hit)
	{
		Mesh sharedMesh = collider.gameObject.GetComponent<MeshCollider>().sharedMesh;
		critical = true;
		if (hitPos != Vector3.zero)
		{
			perc = hit.textureCoord.y;
			if (perc != 1f)
			{
				critical = false;
			}
			return;
		}
		UnityEngine.Debug.Log("##############################");
		int num = Mathf.RoundToInt(Mathf.Floor((float)triangleIndex * 0.5f) * 2f);
		float num2 = (float)num * 0.5f;
		float num3 = Mathf.Floor(num2 * 0.25f);
		float num4 = num2 - Mathf.Round(num3 * 4f);
		if (num4 == 0f)
		{
			critical = false;
			try
			{
				Vector3 vA = sharedMesh.vertices[sharedMesh.triangles[num * 3 + 1]];
				Vector3 vB = sharedMesh.vertices[sharedMesh.triangles[num * 3 + 2]];
				num++;
				Vector3 a;
				Vector3 vector = (a = sharedMesh.vertices[sharedMesh.triangles[num * 3]]);
				Vector3 b;
				Vector3 vector2 = (b = sharedMesh.vertices[sharedMesh.triangles[num * 3 + 2]]);
				vector.y = (vector2.y = (vA.y = (vB.y = hitPos.y)));
				Vector3 a2 = ODQDQDQDQO.OQQCQOCCOQ(vA, vB, hitPos);
				Vector3 vector3 = ODQDQDQDQO.OQQCQOCCOQ(vector, vector2, hitPos);
				perc = Vector3.Distance(hitPos, vector3) / Vector3.Distance(a2, vector3);
				float t = Vector3.Distance(vector3, vector) / Vector3.Distance(vector, vector2);
				vector3 = Vector3.Lerp(a, b, t);
				outerHeight = hitPos.y - vector3.y;
				outerPoint = vector3;
				return;
			}
			catch
			{
				perc = 1f;
				return;
			}
		}
		if (num4 == 1f || num4 == 2f)
		{
			critical = true;
			perc = 1f;
			return;
		}
		critical = false;
		try
		{
			Vector3 a;
			Vector3 vector = (a = sharedMesh.vertices[sharedMesh.triangles[num * 3 + 1]]);
			Vector3 b;
			Vector3 vector2 = (b = sharedMesh.vertices[sharedMesh.triangles[num * 3 + 2]]);
			num++;
			Vector3 vA = sharedMesh.vertices[sharedMesh.triangles[num * 3]];
			Vector3 vB = sharedMesh.vertices[sharedMesh.triangles[num * 3 + 2]];
			vector.y = (vector2.y = (vA.y = (vB.y = hitPos.y)));
			Vector3 a2 = ODQDQDQDQO.OQQCQOCCOQ(vA, vB, hitPos);
			Vector3 vector3 = ODQDQDQDQO.OQQCQOCCOQ(vector, vector2, hitPos);
			perc = Vector3.Distance(hitPos, vector3) / Vector3.Distance(a2, vector3);
			float t = Vector3.Distance(vector3, vector) / Vector3.Distance(vector, vector2);
			vector3 = Vector3.Lerp(a, b, t);
			outerHeight = hitPos.y - vector3.y;
			outerPoint = vector3;
		}
		catch
		{
			perc = 1f;
		}
	}

	public static void GetHitPointInfoOld(int triangleIndex, Collider collider, Vector3 hitPos, ref float perc, ref bool critical, ref float outerHeight, ref Vector3 outerPoint)
	{
		Mesh sharedMesh = collider.gameObject.GetComponent<MeshCollider>().sharedMesh;
		int num = Mathf.RoundToInt(Mathf.Floor((float)triangleIndex * 0.5f) * 2f);
		float num2 = (float)num * 0.5f;
		float num3 = Mathf.Floor(num2 * 0.333333f);
		float num4 = num2 - Mathf.Round(num3 * 3f);
		UnityEngine.Debug.Log(triangleIndex + " surface " + num4);
		if (num4 == 0f || num4 == 3f)
		{
			critical = false;
			try
			{
				Vector3 vA = sharedMesh.vertices[sharedMesh.triangles[num * 3 + 1]];
				Vector3 vB = sharedMesh.vertices[sharedMesh.triangles[num * 3 + 2]];
				num++;
				Vector3 a;
				Vector3 vector = (a = sharedMesh.vertices[sharedMesh.triangles[num * 3]]);
				Vector3 b;
				Vector3 vector2 = (b = sharedMesh.vertices[sharedMesh.triangles[num * 3 + 2]]);
				vector.y = (vector2.y = (vA.y = (vB.y = hitPos.y)));
				Vector3 a2 = ODQDQDQDQO.OQQCQOCCOQ(vA, vB, hitPos);
				Vector3 vector3 = ODQDQDQDQO.OQQCQOCCOQ(vector, vector2, hitPos);
				perc = Vector3.Distance(hitPos, vector3) / Vector3.Distance(a2, vector3);
				float t = Vector3.Distance(vector3, vector) / Vector3.Distance(vector, vector2);
				vector3 = Vector3.Lerp(a, b, t);
				outerHeight = hitPos.y - vector3.y;
				outerPoint = vector3;
				return;
			}
			catch
			{
				perc = 1f;
				return;
			}
		}
		if (num4 == 1f)
		{
			critical = true;
			perc = 1f;
			return;
		}
		critical = false;
		try
		{
			Vector3 a;
			Vector3 vector = (a = sharedMesh.vertices[sharedMesh.triangles[num * 3 + 1]]);
			Vector3 b;
			Vector3 vector2 = (b = sharedMesh.vertices[sharedMesh.triangles[num * 3 + 2]]);
			num++;
			Vector3 vA = sharedMesh.vertices[sharedMesh.triangles[num * 3]];
			Vector3 vB = sharedMesh.vertices[sharedMesh.triangles[num * 3 + 2]];
			vector.y = (vector2.y = (vA.y = (vB.y = hitPos.y)));
			Vector3 a2 = ODQDQDQDQO.OQQCQOCCOQ(vA, vB, hitPos);
			Vector3 vector3 = ODQDQDQDQO.OQQCQOCCOQ(vector, vector2, hitPos);
			perc = Vector3.Distance(hitPos, vector3) / Vector3.Distance(a2, vector3);
			float t = Vector3.Distance(vector3, vector) / Vector3.Distance(vector, vector2);
			vector3 = Vector3.Lerp(a, b, t);
			outerHeight = hitPos.y - vector3.y;
			outerPoint = vector3;
		}
		catch
		{
			perc = 1f;
		}
	}

	public static void OQOQCCCODC(ERModularBase scr, ref float minx, ref float minz, ref float maxx, ref float maxz, float splatmapScale)
	{
		minx = 10000000f;
		minz = 10000000f;
		maxx = -10000000f;
		maxz = -10000000f;
		ERModularRoad[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERModularRoad)) as ERModularRoad[];
		Mesh mesh = null;
		ERModularRoad[] array2 = array;
		foreach (ERModularRoad eRModularRoad in array2)
		{
			bool flag = true;
			if (scr.selectedRoadsOnly)
			{
				flag = false;
				for (int j = 0; j < scr.selectedObjects.Count; j++)
				{
					if (scr.selectedObjects[j].roadScr == eRModularRoad)
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				continue;
			}
			Mesh mesh2 = null;
			if ((bool)eRModularRoad.gameObject.GetComponent<MeshFilter>())
			{
				mesh2 = eRModularRoad.gameObject.GetComponent<MeshFilter>().sharedMesh;
			}
			Transform transform = eRModularRoad.transform.Find("surface");
			if (eRModularRoad.isSideObject)
			{
				foreach (ERSORoadExt item in eRModularRoad.soDataExt)
				{
					if (!item.sideObject.deformationObject || !item.active || item.sideObject.objectType != 1)
					{
						continue;
					}
					foreach (Transform item2 in eRModularRoad.transform)
					{
						if ((bool)item2.GetComponent<ERSideObjectInstance>() && item2.GetComponent<ERSideObjectInstance>().so == item.sideObject)
						{
							transform = item2;
							break;
						}
					}
				}
			}
			else
			{
				ERSideObjectInstance[] componentsInChildren = eRModularRoad.gameObject.GetComponentsInChildren<ERSideObjectInstance>();
				ERSideObjectInstance[] array3 = componentsInChildren;
				foreach (ERSideObjectInstance eRSideObjectInstance in array3)
				{
					if (!(eRSideObjectInstance.so != null) || !eRSideObjectInstance.so.tunnelObject)
					{
						continue;
					}
					foreach (Transform item3 in eRSideObjectInstance.transform)
					{
						if (item3.GetComponent<ERSurfaceScript>() != null)
						{
							tunnelObjects.Add(item3.gameObject);
							item3.GetComponent<MeshRenderer>().enabled = true;
							item3.GetComponent<MeshCollider>().enabled = true;
						}
					}
				}
			}
			if ((transform != null || eRModularRoad.snapVertices) && eRModularRoad.markersExt.Count > 1)
			{
				if (transform != null)
				{
					transform.gameObject.layer = scr.sLayer;
					surfaceObjects.Add(transform.gameObject);
					mesh = transform.gameObject.GetComponent<MeshFilter>().sharedMesh;
					if ((bool)transform.gameObject.GetComponent<MeshCollider>() && transform.gameObject.GetComponent<MeshCollider>().sharedMesh == null)
					{
						transform.gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
						if (transform.gameObject.GetComponent<MeshCollider>().sharedMesh == null)
						{
							UnityEngine.Object.DestroyImmediate(transform.gameObject.GetComponent<MeshCollider>());
							transform.gameObject.AddComponent<MeshCollider>();
						}
					}
				}
				else if ((bool)eRModularRoad.gameObject.GetComponent<MeshFilter>())
				{
					mesh = eRModularRoad.gameObject.GetComponent<MeshFilter>().sharedMesh;
				}
				if (mesh != null)
				{
					if (minx > mesh.bounds.min.x)
					{
						minx = mesh.bounds.min.x;
					}
					if (minz > mesh.bounds.min.z)
					{
						minz = mesh.bounds.min.z;
					}
					if (maxx < mesh.bounds.max.x)
					{
						maxx = mesh.bounds.max.x;
					}
					if (maxz < mesh.bounds.max.z)
					{
						maxz = mesh.bounds.max.z;
					}
				}
				if (eRModularRoad.exitRoads.Count > 0)
				{
					foreach (OQQCCQCDQQ exitRoad in eRModularRoad.exitRoads)
					{
						Transform transform4 = exitRoad.transform.Find("surface");
						if (transform4 != null && transform4.GetComponent<MeshCollider>() != null)
						{
							mesh = transform4.GetComponent<MeshFilter>().sharedMesh;
							if (minx > mesh.bounds.min.x)
							{
								minx = mesh.bounds.min.x;
							}
							if (minz > mesh.bounds.min.z)
							{
								minz = mesh.bounds.min.z;
							}
							if (maxx < mesh.bounds.max.x)
							{
								maxx = mesh.bounds.max.x;
							}
							if (maxz < mesh.bounds.max.z)
							{
								maxz = mesh.bounds.max.z;
							}
							surfaceObjects.Add(transform4.gameObject);
							transform4.GetComponent<MeshCollider>().enabled = true;
						}
					}
				}
				ODCCODOCQQ.OCDCQCOQQO(mesh2);
				if (!scr.doLightmapUVs || !eRModularRoad.isUpdated || mesh2 != null)
				{
				}
				if (scr.lodGroups && scr.doLODGroups && !eRModularRoad.isSideObject)
				{
					int num = 0;
					int num2 = 0;
					for (int l = 0; l < scr.LODLevels; l++)
					{
						num = 10 - Mathf.RoundToInt(scr.LODLevelResolution[l] * 10f);
						if (num == 0)
						{
							num = 1;
						}
						if (num <= num2)
						{
							num = num2;
						}
						OCQOQOOOCO.ODCQCQCQDQ(eRModularRoad.gameObject, mesh, l, num, eRModularRoad.roadShape.Count, eRModularRoad.hardEdge, eRModularRoad.roadShapeMaterialIntCounts);
						num2 = num;
					}
					ODCCODOCQQ.OODDQCQQDQ(scr, eRModularRoad);
				}
				if (scr.doSplatmaps && eRModularRoad.splatMapActive && splatmapScale != 0f)
				{
					OCCQQCCDDD.CreateSplatMeshes(eRModularRoad, ref scr.soSplatmapObjects, splatmapScale);
				}
				if (transform != null)
				{
					transform.gameObject.GetComponent<MeshCollider>().enabled = true;
				}
			}
			if (eRModularRoad.markersExt.Count > 1 && (!eRModularRoad.isSideObject || transform != null) && (eRModularRoad.terrainDeformation || eRModularRoad.snapVertices) && splatmapScale != 0f)
			{
				OOQQQQDCCO(scr, eRModularRoad);
				treeObjects.Add(CreateMesh(eRModularRoad.transform, eRModularRoad.treeVecs, eRModularRoad.vegetationTris, scr.sLayer, eRModularRoad, "treesERMesh"));
				detailObjects.Add(CreateMesh(eRModularRoad.transform, eRModularRoad.detailVecs, eRModularRoad.vegetationTris, scr.sLayer, eRModularRoad, "detailERMesh"));
			}
		}
		crossingSurfacesStart = surfaceObjects.Count;
		if (scr.selectedRoadsOnly)
		{
			return;
		}
		ERCrossingPrefabs[] array4 = UnityEngine.Object.FindObjectsOfType(typeof(ERCrossingPrefabs)) as ERCrossingPrefabs[];
		ERCrossingPrefabs[] array5 = array4;
		foreach (ERCrossingPrefabs eRCrossingPrefabs in array5)
		{
			Transform transform;
			if (!(transform = eRCrossingPrefabs.transform.Find("surface")))
			{
				continue;
			}
			transform.gameObject.layer = scr.sLayer;
			surfaceObjects.Add(transform.gameObject);
			mesh = transform.gameObject.GetComponent<MeshFilter>().sharedMesh;
			if (mesh != null)
			{
				if (minx > mesh.bounds.min.x + eRCrossingPrefabs.transform.position.x)
				{
					minx = mesh.bounds.min.x + eRCrossingPrefabs.transform.position.x;
				}
				if (minz > mesh.bounds.min.z + eRCrossingPrefabs.transform.position.z)
				{
					minz = mesh.bounds.min.z + eRCrossingPrefabs.transform.position.z;
				}
				if (maxx < mesh.bounds.max.x + eRCrossingPrefabs.transform.position.x)
				{
					maxx = mesh.bounds.max.x + eRCrossingPrefabs.transform.position.x;
				}
				if (maxz < mesh.bounds.max.z + eRCrossingPrefabs.transform.position.z)
				{
					maxz = mesh.bounds.max.z + eRCrossingPrefabs.transform.position.z;
				}
			}
			if (!transform.gameObject.GetComponent<MeshCollider>())
			{
				continue;
			}
			if (transform.gameObject.GetComponent<MeshCollider>().sharedMesh == null)
			{
				transform.gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
				if (transform.gameObject.GetComponent<MeshCollider>().sharedMesh == null)
				{
					UnityEngine.Object.DestroyImmediate(transform.gameObject.GetComponent<MeshCollider>());
					transform.gameObject.AddComponent<MeshCollider>();
				}
			}
			transform.gameObject.GetComponent<MeshCollider>().enabled = true;
		}
		sideObjectSurfacesStart = surfaceObjects.Count;
		ERSideObjectInstance[] array6 = UnityEngine.Object.FindObjectsOfType(typeof(ERSideObjectInstance)) as ERSideObjectInstance[];
		ERSideObjectInstance[] array7 = array6;
		foreach (ERSideObjectInstance eRSideObjectInstance2 in array7)
		{
			if (eRSideObjectInstance2.so != null)
			{
				if (!eRSideObjectInstance2.so.deformationObject || eRSideObjectInstance2.so.objectType != 1)
				{
					continue;
				}
				mesh = eRSideObjectInstance2.gameObject.GetComponent<MeshFilter>().sharedMesh;
				if (mesh != null)
				{
					if (minx > mesh.bounds.min.x + eRSideObjectInstance2.transform.position.x)
					{
						minx = mesh.bounds.min.x + eRSideObjectInstance2.transform.position.x;
					}
					if (minz > mesh.bounds.min.z + eRSideObjectInstance2.transform.position.z)
					{
						minz = mesh.bounds.min.z + eRSideObjectInstance2.transform.position.z;
					}
					if (maxx < mesh.bounds.max.x + eRSideObjectInstance2.transform.position.x)
					{
						maxx = mesh.bounds.max.x + eRSideObjectInstance2.transform.position.x;
					}
					if (maxz < mesh.bounds.max.z + eRSideObjectInstance2.transform.position.z)
					{
						maxz = mesh.bounds.max.z + eRSideObjectInstance2.transform.position.z;
					}
				}
				eRSideObjectInstance2.gameObject.layer = scr.sLayer;
				surfaceObjects.Add(eRSideObjectInstance2.gameObject);
				if (!eRSideObjectInstance2.gameObject.GetComponent<MeshCollider>())
				{
					continue;
				}
				if (eRSideObjectInstance2.gameObject.GetComponent<MeshCollider>().sharedMesh == null)
				{
					eRSideObjectInstance2.gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
					if (eRSideObjectInstance2.gameObject.GetComponent<MeshCollider>().sharedMesh == null)
					{
						UnityEngine.Object.DestroyImmediate(eRSideObjectInstance2.gameObject.GetComponent<MeshCollider>());
						eRSideObjectInstance2.gameObject.AddComponent<MeshCollider>();
					}
				}
				eRSideObjectInstance2.gameObject.GetComponent<MeshCollider>().enabled = true;
			}
			else
			{
				string text = "";
				if (eRSideObjectInstance2.transform.parent != null)
				{
					text = ", parent object: " + eRSideObjectInstance2.transform.parent.gameObject.name;
				}
				UnityEngine.Debug.LogWarning("Side Object detected with empty Side Object Instance: " + eRSideObjectInstance2.gameObject.name + text);
			}
		}
	}

	public static void ODQODCQQCQ(ERModularBase scr, ERTerrain terrainScr, Terrain terrain, float minx, float maxx, float minz, float maxz)
	{
		foreach (GameObject treeObject in treeObjects)
		{
			treeObject.GetComponent<MeshCollider>().enabled = true;
		}
		List<TreeInstance> list = new List<TreeInstance>(terrain.terrainData.treeInstances);
		Vector3 position = terrain.gameObject.transform.position;
		LayerMask layerMask = 1 << scr.sLayer;
		Ray ray = new Ray
		{
			direction = Vector3.down
		};
		int num = 0;
		minx += position.x;
		maxx += position.x + 10f;
		minz += position.z;
		maxz += position.z + 10f;
		for (int i = 0; i < list.Count; i++)
		{
			Vector3 position2 = list[i].position;
			position2.x *= terrain.terrainData.size.x;
			position2.y *= terrain.terrainData.size.y;
			position2.z *= terrain.terrainData.size.z;
			position2 += position;
			if (position2.x > minx && position2.x < maxx && position2.z > minz && position2.z < maxz)
			{
				position2.y += 100f;
				if (Physics.Raycast(position2, -Vector3.up, out var _, 200f, layerMask))
				{
					terrainScr.terrainTrees.Add(new ERTree(list[i]));
					list.RemoveAt(i);
					i--;
				}
				num++;
			}
		}
		terrain.terrainData.treeInstances = list.ToArray();
		foreach (GameObject treeObject2 in treeObjects)
		{
			treeObject2.GetComponent<MeshCollider>().enabled = false;
		}
	}

	public static void OOCDDQCCDD(ERModularBase scr, ERTerrain terrainScr, Terrain terrain, float minx, float maxx, float minz, float maxz)
	{
		foreach (GameObject detailObject in detailObjects)
		{
			if ((bool)detailObject.GetComponent<MeshCollider>())
			{
				detailObject.GetComponent<MeshCollider>().enabled = true;
			}
		}
		TerrainData terrainData = terrain.terrainData;
		Vector3 position = terrain.gameObject.transform.position;
		minx += position.x;
		maxx += position.x + 10f;
		minz += position.z;
		maxz += position.z + 10f;
		List<tPoint> list = OQODQCQCCQ(scr, terrain, terrain.terrainData, minx, maxx, minz, maxz);
		List<tPoint> list2 = new List<tPoint>();
		for (int i = 0; i < terrainData.detailPrototypes.Length; i++)
		{
			terrainScr.detailInstanceStarts.Add(list2.Count);
			int[,] detailLayer = terrainData.GetDetailLayer(0, 0, terrainData.detailResolution, terrainData.detailResolution, i);
			foreach (tPoint item in list)
			{
				if (detailLayer[item.z, item.x] != 0)
				{
					item.v = detailLayer[item.z, item.x];
					list2.Add(item);
					detailLayer[item.z, item.x] = 0;
				}
			}
			terrainData.SetDetailLayer(0, 0, i, detailLayer);
		}
		terrainScr.detailInstances.AddRange(list2);
		foreach (GameObject detailObject2 in detailObjects)
		{
			if ((bool)detailObject2.GetComponent<MeshCollider>())
			{
				detailObject2.GetComponent<MeshCollider>().enabled = false;
			}
		}
	}

	public static void OOCDDOOCQC(ERModularBase scr, ERTerrain terrainScr, Terrain terrain, float minx, float maxx, float minz, float maxz)
	{
		bool[,] holes = null;
		float[,] heights = null;
		float y = terrain.terrainData.size.y;
		int num = 512;
		if (scr.debugFlag)
		{
			ERDebug.leftTHandles.Clear();
			ERDebug.rightTHandles.Clear();
			UnityEngine.Debug.Log("Reset handles");
		}
		ERSideObjectInstance[] array = UnityEngine.Object.FindObjectsOfType(typeof(ERSideObjectInstance)) as ERSideObjectInstance[];
		Vector3 position = terrain.transform.position;
		float stepx = terrain.terrainData.size.x / ((float)num * 1f);
		float stepy = terrain.terrainData.size.z / ((float)num * 1f);
		ERSideObjectInstance[] array2 = array;
		foreach (ERSideObjectInstance eRSideObjectInstance in array2)
		{
			if (!eRSideObjectInstance.so.tunnelObject)
			{
				continue;
			}
			if (eRSideObjectInstance.so.x1 == 0f || eRSideObjectInstance.so.x2 == 0f)
			{
				eRSideObjectInstance.so.OQDODCOODC();
			}
			if (eRSideObjectInstance.startEndPositions.Count <= 0)
			{
				continue;
			}
			for (int j = 0; j < eRSideObjectInstance.startEndPositions.Count; j += 4)
			{
				float num2 = ODQDQDQDQO.OQQOQODCCC(terrain, eRSideObjectInstance.startEndPositions[j], eRSideObjectInstance.startEndPositions[j + 1]);
				Vector3 normalized = (eRSideObjectInstance.startEndPositions[j + 1] - eRSideObjectInstance.startEndPositions[j]).normalized;
				Vector3 normalized2 = new Vector3(normalized.z, 0f, 0f - normalized.x).normalized;
				Vector3 vector = eRSideObjectInstance.startEndPositions[j] + normalized2 * (eRSideObjectInstance.so.x1 + -1f * num2);
				Vector3 vector2 = eRSideObjectInstance.startEndPositions[j] + normalized2 * (eRSideObjectInstance.so.x2 + 1f * num2);
				vector += -normalized * num2 * 1f;
				vector2 += -normalized * num2 * 1f;
				if (scr.debugFlag)
				{
					ERDebug.leftTHandles.Add(vector);
					ERDebug.rightTHandles.Add(vector2);
				}
				OCCDDODDDD(ref holes, heights, y, ref terrainScr.holes, vector, vector2, position, stepx, stepy, eRSideObjectInstance.so.y1, num);
				float x = terrain.terrainData.heightmapScale.x;
				if (x < 3f)
				{
				}
				vector += normalized * num2 * 1f;
				vector2 += normalized * num2 * 1f;
				if (scr.debugFlag)
				{
					ERDebug.leftTHandles.Add(vector);
					ERDebug.rightTHandles.Add(vector2);
				}
				OCCDDODDDD(ref holes, heights, y, ref terrainScr.holes, vector, vector2, position, stepx, stepy, eRSideObjectInstance.so.y1, num);
				vector += normalized * num2 * 1f;
				vector2 += normalized * num2 * 1f;
				if (scr.debugFlag)
				{
					ERDebug.leftTHandles.Add(vector);
					ERDebug.rightTHandles.Add(vector2);
				}
				OCCDDODDDD(ref holes, heights, y, ref terrainScr.holes, vector, vector2, position, stepx, stepy, eRSideObjectInstance.so.y1, num);
				vector += normalized * num2 * 1f;
				vector2 += normalized * num2 * 1f;
				if (scr.debugFlag)
				{
					ERDebug.leftTHandles.Add(vector);
					ERDebug.rightTHandles.Add(vector2);
				}
				OCCDDODDDD(ref holes, heights, y, ref terrainScr.holes, vector, vector2, position, stepx, stepy, eRSideObjectInstance.so.y1, num);
				normalized = (eRSideObjectInstance.startEndPositions[j + 3] - eRSideObjectInstance.startEndPositions[j + 2]).normalized;
				normalized2 = new Vector3(normalized.z, 0f, 0f - normalized.x).normalized;
				vector = eRSideObjectInstance.startEndPositions[j + 3] + normalized2 * (eRSideObjectInstance.so.x1 + -1f * num2);
				vector2 = eRSideObjectInstance.startEndPositions[j + 3] + normalized2 * (eRSideObjectInstance.so.x2 + 1f * num2);
				num2 = ODQDQDQDQO.OQQOQODCCC(terrain, eRSideObjectInstance.startEndPositions[j + 2], eRSideObjectInstance.startEndPositions[j + 3]);
				vector += normalized * num2 * 1f;
				vector2 += normalized * num2 * 1f;
				if (scr.debugFlag)
				{
					ERDebug.leftTHandles.Add(vector);
					ERDebug.rightTHandles.Add(vector2);
				}
				OCCDDODDDD(ref holes, heights, y, ref terrainScr.holes, vector, vector2, position, stepx, stepy, eRSideObjectInstance.so.y1, num);
				x = terrain.terrainData.heightmapScale.x;
				if (x < 3f)
				{
				}
				vector -= normalized * num2 * 1f;
				vector2 -= normalized * num2 * 1f;
				if (scr.debugFlag)
				{
					ERDebug.leftTHandles.Add(vector);
					ERDebug.rightTHandles.Add(vector2);
				}
				OCCDDODDDD(ref holes, heights, y, ref terrainScr.holes, vector, vector2, position, stepx, stepy, eRSideObjectInstance.so.y1, num);
				vector -= normalized * num2 * 1f;
				vector2 -= normalized * num2 * 1f;
				if (scr.debugFlag)
				{
					ERDebug.leftTHandles.Add(vector);
					ERDebug.rightTHandles.Add(vector2);
				}
				OCCDDODDDD(ref holes, heights, y, ref terrainScr.holes, vector, vector2, position, stepx, stepy, eRSideObjectInstance.so.y1, num);
				vector -= normalized * num2 * 1f;
				vector2 -= normalized * num2 * 1f;
				if (scr.debugFlag)
				{
					ERDebug.leftTHandles.Add(vector);
					ERDebug.rightTHandles.Add(vector2);
				}
				OCCDDODDDD(ref holes, heights, y, ref terrainScr.holes, vector, vector2, position, stepx, stepy, eRSideObjectInstance.so.y1, num);
			}
		}
	}

	public static void OCCDDODDDD(ref bool[,] holes, float[,] heights, float height, ref List<ERCell> terrainScrHoles, Vector3 lp, Vector3 rp, Vector3 terrainPos, float stepx, float stepy, float tHeight, float size)
	{
		if (holes == null)
		{
			return;
		}
		Vector3 vector = lp - terrainPos;
		ERCell eRCell = new ERCell(Mathf.RoundToInt(Mathf.Floor(vector.z / stepy)), Mathf.RoundToInt(Mathf.Floor(vector.x / stepx)));
		vector = rp - terrainPos;
		ERCell eRCell2 = new ERCell(Mathf.RoundToInt(Mathf.Floor(vector.z / stepy)), Mathf.RoundToInt(Mathf.Floor(vector.x / stepx)));
		int num = Mathf.Abs(eRCell.x - eRCell2.x);
		int num2 = Mathf.Abs(eRCell.y - eRCell2.y);
		int num3 = 0;
		float num4;
		float num5;
		float num6;
		if (num > num2)
		{
			num4 = ((eRCell.x >= eRCell2.x) ? (-1f) : 1f);
			num5 = (float)num2 * 1f / ((float)num * 1f);
			if (eRCell.y > eRCell2.y)
			{
				num5 *= -1f;
			}
			num6 = num;
		}
		else
		{
			num5 = ((eRCell.y >= eRCell2.y) ? (-1f) : 1f);
			num4 = (float)num * 1f / ((float)num2 * 1f);
			if (eRCell.x > eRCell2.x)
			{
				num4 *= -1f;
			}
			num6 = num2;
			num3 = 1;
		}
		int x = eRCell.x;
		int y = eRCell.y;
		ERCell item = new ERCell(0, 0);
		int num7 = 0;
		int num8 = 0;
		for (int i = 0; (float)i < num6; i++)
		{
			num7 = Mathf.RoundToInt(Mathf.Floor((float)eRCell.x + num4 * (float)i));
			num8 = Mathf.RoundToInt(Mathf.Floor((float)eRCell.y + num5 * (float)i));
			eRCell2 = new ERCell(Mathf.RoundToInt(Mathf.Floor((float)eRCell.x + num4 * (float)i)), Mathf.RoundToInt(Mathf.Floor((float)eRCell.y + num5 * (float)i)));
			if (ODQODDQCCD(heights, height, num7, num8, lp.y, tHeight, size, terrainPos.y))
			{
				holes[eRCell2.x, eRCell2.y] = false;
				terrainScrHoles.Add(eRCell2);
			}
			if (num3 == 0)
			{
				if (eRCell2.y != y)
				{
					item.x = eRCell2.x;
					item.y = y;
					if (ODQODDQCCD(heights, height, item.x, item.y, lp.y, tHeight, size, terrainPos.y))
					{
						holes[item.x, item.y] = false;
						terrainScrHoles.Add(item);
					}
					item.x = x;
					item.y = eRCell2.y;
					if (ODQODDQCCD(heights, height, item.x, item.y, lp.y, tHeight, size, terrainPos.y))
					{
						holes[item.x, item.y] = false;
						terrainScrHoles.Add(item);
					}
				}
			}
			else if (eRCell2.x != x)
			{
				item.x = eRCell2.x;
				item.y = y;
				if (ODQODDQCCD(heights, height, item.x, item.y, lp.y, tHeight, size, terrainPos.y))
				{
					holes[item.x, item.y] = false;
					terrainScrHoles.Add(item);
				}
				item.x = x;
				item.y = eRCell2.y;
				if (ODQODDQCCD(heights, height, item.x, item.y, lp.y, tHeight, size, terrainPos.y))
				{
					holes[item.x, item.y] = false;
					terrainScrHoles.Add(item);
				}
			}
			x = eRCell2.x;
			y = eRCell2.y;
		}
	}

	public static bool ODQODDQCCD(float[,] heights, float height, int x, int y, float rHeight, float tHeight, float size, float terrainY)
	{
		float num = 0f;
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0f;
		if (x > 0 && y > 0 && (float)x < size && (float)y < size)
		{
			num = heights[x, y] * height + terrainY;
			num2 = heights[x + 1, y] * height + terrainY;
			num3 = heights[x, y + 1] * height + terrainY;
			num4 = heights[x + 1, y + 1] * height + terrainY;
			float num5 = 0.1f;
			bool flag = false;
			float num6 = rHeight + tHeight + num5;
			if (num - num6 > 0f)
			{
				return false;
			}
			if (num2 - num6 > 0f)
			{
				return false;
			}
			if (num3 - num6 > 0f)
			{
				return false;
			}
			if (num4 - num6 > 0f)
			{
				return false;
			}
			if (Mathf.Abs(num - num2) > num5)
			{
				return true;
			}
			if (Mathf.Abs(num2 - num3) > num5)
			{
				return true;
			}
			if (Mathf.Abs(num3 - num4) > num5)
			{
				return true;
			}
			if (num > rHeight + num5)
			{
				return true;
			}
			return false;
		}
		return false;
	}

	public static void ODQCOCOQQD(ERModularBase scr, ERTerrain terrainScr, Terrain terrain, float minx, float maxx, float minz, float maxz)
	{
		for (int i = 0; i < scr.soSplatmapObjects.Count; i++)
		{
			scr.soSplatmapObjects[i].GetComponent<MeshCollider>().enabled = true;
		}
		List<ERSplatmap> instances = new List<ERSplatmap>();
		TerrainData terrainData = terrainScr.terrainData;
		float[,,] alphamaps = terrainData.GetAlphamaps(0, 0, terrainData.alphamapWidth, terrainData.alphamapHeight);
		float x = terrain.transform.position.x;
		float z = terrain.transform.position.z;
		if (terrain.transform.position.x != 0f)
		{
			x = 0f;
		}
		if (terrain.transform.position.z != 0f)
		{
			z = 0f;
		}
		float num = terrainData.size.x / (float)terrainData.alphamapWidth;
		float num2 = terrainData.size.z / (float)terrainData.alphamapHeight;
		float num3 = num * 0.5f;
		float num4 = num2 * 0.5f;
		int num5 = Mathf.RoundToInt(Mathf.Floor(minx / num));
		int num6 = Mathf.RoundToInt(Mathf.Ceil(maxx / num));
		int num7 = Mathf.RoundToInt(Mathf.Floor(minz / num2));
		int num8 = Mathf.RoundToInt(Mathf.Ceil(maxz / num2));
		if (terrainData.alphamapWidth - num6 == 1)
		{
			num6 = terrainData.alphamapWidth;
		}
		if (terrainData.alphamapHeight - num8 == 1)
		{
			num8 = terrainData.alphamapHeight;
		}
		if (num5 < 0 || num5 > terrainData.alphamapWidth || num7 < 0 || num7 > terrainData.alphamapHeight || num6 < 0 || num6 > terrainData.alphamapWidth || num8 < 0 || num8 > terrainData.alphamapHeight)
		{
			return;
		}
		float x2 = terrain.transform.position.x;
		float z2 = terrain.transform.position.z;
		float y = terrain.transform.position.y;
		LayerMask layerMask = 1 << scr.sLayer;
		Ray ray = new Ray
		{
			direction = Vector3.down
		};
		float y2 = terrainData.size.y;
		float num9 = 0f;
		bool flag = false;
		float num10 = 0f;
		float num11 = 0f;
		Vector3 zero = Vector3.zero;
		int alphamapLayers = terrainData.alphamapLayers;
		float y3 = terrain.transform.position.y;
		for (int j = 0; j < num6 - num5; j++)
		{
			for (int k = 0; k < num8 - num7; k++)
			{
				Vector3 origin = new Vector3(num3 + x2 + (float)(num5 + j) * num, 10f, num4 + z2 + (float)(num7 + k) * num2);
				if (Physics.Raycast(origin, -Vector3.up, out var hitInfo, 20f, layerMask))
				{
					string text = hitInfo.collider.gameObject.name;
					OOOCCDQODO(hitInfo.collider.gameObject, num7 + k, num5 + j, ref instances, alphamaps, alphamapLayers, hitInfo.textureCoord);
				}
			}
		}
		terrainScr.splatData.AddRange(instances);
		terrainData.SetAlphamaps(0, 0, OCCODCQOCO(instances, alphamaps, alphamapLayers));
		for (int l = 0; l < scr.soSplatmapObjects.Count; l++)
		{
			scr.soSplatmapObjects[l].GetComponent<MeshCollider>().enabled = false;
		}
	}

	public static float[,,] OCCODCQOCO(List<ERSplatmap> mapData, float[,,] trmap, int layers)
	{
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < mapData.Count; i++)
		{
			num = mapData[i].x;
			num2 = mapData[i].y;
			int index = mapData[i].index;
			float value = mapData[i].value;
			float num3 = 1f - value;
			float num4 = 0f;
			for (int j = 0; j < layers; j++)
			{
				if (j != index - 1)
				{
					num4 += trmap[num, num2, j];
				}
			}
			if (index <= 0 || index > 12)
			{
				continue;
			}
			float num5 = 1f - trmap[num, num2, index - 1];
			float num6 = 0f;
			if (trmap[num, num2, index - 1] >= value)
			{
				continue;
			}
			if (value == 1f)
			{
				if (trmap[num, num2, index - 1] == 1f)
				{
					continue;
				}
				for (int k = 0; k < layers; k++)
				{
					if (k != index - 1)
					{
						trmap[num, num2, k] = 0f;
					}
					else
					{
						trmap[num, num2, k] = 1f;
					}
				}
			}
			else if (index <= 4)
			{
				if (layers >= 1)
				{
					if (index == 1)
					{
						if (trmap[num, num2, 0] < value)
						{
							trmap[num, num2, 0] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 0] / num4;
						trmap[num, num2, 0] = num3 * num6;
					}
				}
				if (layers >= 2)
				{
					if (index == 2)
					{
						if (trmap[num, num2, 1] < value)
						{
							trmap[num, num2, 1] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 1] / num4;
						trmap[num, num2, 1] = num3 * num6;
					}
				}
				if (layers >= 3)
				{
					if (index == 3)
					{
						if (trmap[num, num2, 2] < value)
						{
							trmap[num, num2, 2] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 2] / num4;
						trmap[num, num2, 2] = num3 * num6;
					}
				}
				if (layers >= 4)
				{
					if (index == 4)
					{
						if (trmap[num, num2, 3] < value)
						{
							trmap[num, num2, 3] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 3] / num4;
						trmap[num, num2, 3] = num3 * num6;
					}
				}
				if (layers >= 5)
				{
					if (index == 5)
					{
						if (trmap[num, num2, 4] < value)
						{
							trmap[num, num2, 4] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 4] / num4;
						trmap[num, num2, 4] = num3 * num6;
					}
				}
				if (layers >= 6)
				{
					if (index == 6)
					{
						if (trmap[num, num2, 5] < value)
						{
							trmap[num, num2, 5] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 5] / num4;
						trmap[num, num2, 5] = num3 * num6;
					}
				}
				if (layers >= 7)
				{
					if (index == 7)
					{
						if (trmap[num, num2, 6] < value)
						{
							trmap[num, num2, 6] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 6] / num4;
						trmap[num, num2, 6] = num3 * num6;
					}
				}
				if (layers >= 8)
				{
					if (index == 8)
					{
						if (trmap[num, num2, 7] < value)
						{
							trmap[num, num2, 7] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 7] / num4;
						trmap[num, num2, 7] = num3 * num6;
					}
				}
				if (layers >= 9)
				{
					if (index == 9)
					{
						if (trmap[num, num2, 8] < value)
						{
							trmap[num, num2, 8] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 8] / num4;
						trmap[num, num2, 8] = num3 * num6;
					}
				}
				if (layers >= 10)
				{
					if (index == 10)
					{
						if (trmap[num, num2, 9] < value)
						{
							trmap[num, num2, 9] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 9] / num4;
						trmap[num, num2, 9] = num3 * num6;
					}
				}
				if (layers >= 11)
				{
					if (index == 11)
					{
						if (trmap[num, num2, 10] < value)
						{
							trmap[num, num2, 10] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 10] / num4;
						trmap[num, num2, 10] = num3 * num6;
					}
				}
				if (layers < 12)
				{
					continue;
				}
				if (index == 12)
				{
					if (trmap[num, num2, 11] < value)
					{
						trmap[num, num2, 11] = value;
					}
				}
				else
				{
					num6 = trmap[num, num2, 11] / num4;
					trmap[num, num2, 11] = num3 * num6;
				}
			}
			else if (index <= 8)
			{
				num6 = trmap[num, num2, 0] / num4;
				trmap[num, num2, 0] = num3 * num6;
				num6 = trmap[num, num2, 1] / num4;
				trmap[num, num2, 1] = num3 * num6;
				num6 = trmap[num, num2, 2] / num4;
				trmap[num, num2, 2] = num3 * num6;
				num6 = trmap[num, num2, 3] / num4;
				trmap[num, num2, 3] = num3 * num6;
				if (layers >= 5)
				{
					if (index == 5)
					{
						if (trmap[num, num2, 4] < value)
						{
							trmap[num, num2, 4] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 4] / num4;
						trmap[num, num2, 4] = num3 * num6;
					}
				}
				if (layers >= 6)
				{
					if (index == 6)
					{
						if (trmap[num, num2, 5] < value)
						{
							trmap[num, num2, 5] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 5] / num4;
						trmap[num, num2, 5] = num3 * num6;
					}
				}
				if (layers >= 7)
				{
					if (index == 7)
					{
						if (trmap[num, num2, 6] < value)
						{
							trmap[num, num2, 6] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 6] / num4;
						trmap[num, num2, 6] = num3 * num6;
					}
				}
				if (layers >= 8)
				{
					if (index == 8)
					{
						if (trmap[num, num2, 7] < value)
						{
							trmap[num, num2, 7] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 7] / num4;
						trmap[num, num2, 7] = num3 * num6;
					}
				}
				if (layers >= 9)
				{
					if (index == 9)
					{
						if (trmap[num, num2, 8] < value)
						{
							trmap[num, num2, 8] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 8] / num4;
						trmap[num, num2, 8] = num3 * num6;
					}
				}
				if (layers >= 10)
				{
					if (index == 10)
					{
						if (trmap[num, num2, 9] < value)
						{
							trmap[num, num2, 9] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 9] / num4;
						trmap[num, num2, 9] = num3 * num6;
					}
				}
				if (layers >= 11)
				{
					if (index == 11)
					{
						if (trmap[num, num2, 10] < value)
						{
							trmap[num, num2, 10] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 10] / num4;
						trmap[num, num2, 10] = num3 * num6;
					}
				}
				if (layers < 12)
				{
					continue;
				}
				if (index == 12)
				{
					if (trmap[num, num2, 11] < value)
					{
						trmap[num, num2, 11] = value;
					}
				}
				else
				{
					num6 = trmap[num, num2, 11] / num4;
					trmap[num, num2, 11] = num3 * num6;
				}
			}
			else
			{
				if (index > 12)
				{
					continue;
				}
				num6 = trmap[num, num2, 0] / num4;
				trmap[num, num2, 0] = num3 * num6;
				num6 = trmap[num, num2, 1] / num4;
				trmap[num, num2, 1] = num3 * num6;
				num6 = trmap[num, num2, 2] / num4;
				trmap[num, num2, 2] = num3 * num6;
				num6 = trmap[num, num2, 3] / num4;
				trmap[num, num2, 3] = num3 * num6;
				num6 = trmap[num, num2, 4] / num4;
				trmap[num, num2, 4] = num3 * num6;
				num6 = trmap[num, num2, 5] / num4;
				trmap[num, num2, 5] = num3 * num6;
				num6 = trmap[num, num2, 6] / num4;
				trmap[num, num2, 6] = num3 * num6;
				num6 = trmap[num, num2, 7] / num4;
				trmap[num, num2, 7] = num3 * num6;
				if (layers >= 9)
				{
					if (index == 9)
					{
						if (trmap[num, num2, 8] < value)
						{
							trmap[num, num2, 8] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 8] / num4;
						trmap[num, num2, 8] = num3 * num6;
					}
				}
				if (layers >= 10)
				{
					if (index == 10)
					{
						if (trmap[num, num2, 9] < value)
						{
							trmap[num, num2, 9] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 9] / num4;
						trmap[num, num2, 9] = num3 * num6;
					}
				}
				if (layers >= 11)
				{
					if (index == 11)
					{
						if (trmap[num, num2, 10] < value)
						{
							trmap[num, num2, 10] = value;
						}
					}
					else
					{
						num6 = trmap[num, num2, 10] / num4;
						trmap[num, num2, 10] = num3 * num6;
					}
				}
				if (layers < 12)
				{
					continue;
				}
				if (index == 12)
				{
					if (trmap[num, num2, 11] < value)
					{
						trmap[num, num2, 11] = value;
					}
				}
				else
				{
					num6 = trmap[num, num2, 11] / num4;
					trmap[num, num2, 11] = num3 * num6;
				}
			}
		}
		return trmap;
	}

	public static void ODODDDDCOQ(ERModularBase scr, ERTerrain terrainScr, Terrain terrain)
	{
		if (terrainScr.heightmapFlag)
		{
			try
			{
				terrainScr.terrainTestPoints.Clear();
				float[,] heights = terrainScr.terrainData.GetHeights(0, 0, terrainScr.terrainData.heightmapResolution, terrainScr.terrainData.heightmapResolution);
				foreach (ERTerrainData item in terrainScr.terrainDataStored)
				{
					if (terrainScr.zStart + item.terrainWidth < 0 || terrainScr.zStart + item.terrainWidth > terrainScr.terrainData.heightmapResolution)
					{
						UnityEngine.Debug.Log("z: " + (terrainScr.zStart + item.terrainWidth) + ": " + terrainScr.zStart + " " + item.terrainWidth);
					}
					if (terrainScr.xStart + item.terrainHeight < 0 || terrainScr.xStart + item.terrainHeight > terrainScr.terrainData.heightmapResolution)
					{
						UnityEngine.Debug.Log("x: " + (terrainScr.xStart + item.terrainHeight) + ": " + terrainScr.xStart + " " + item.terrainHeight);
					}
					heights[terrainScr.zStart + item.terrainWidth, terrainScr.xStart + item.terrainHeight] = item.originalHeight;
				}
				terrain.terrainData.SetHeights(0, 0, heights);
				terrainScr.terrainDataStored.Clear();
			}
			catch
			{
				UnityEngine.Debug.LogError("EasyRoads3Dv3: Restoring the heightmap of terrain " + terrain.name + " failed, please report with details!");
			}
		}
		if (scr.doTrees && terrainScr.treeFlag)
		{
			try
			{
				OQQOQOQQQC(terrainScr, terrain);
			}
			catch
			{
				UnityEngine.Debug.LogError("EasyRoads3Dv3: Restoring trees removed from terrain " + terrain.name + " failed, please report with details with details!");
			}
		}
		if (scr.doDetail && terrainScr.detailFlag)
		{
			try
			{
				ODCOOQCCCD(terrainScr, terrain);
			}
			catch
			{
				UnityEngine.Debug.LogError("EasyRoads3Dv3: Restoring detail objects removed from terrain " + terrain.name + " failed, please report with details!");
			}
		}
		terrain.Flush();
		terrainScr.heightmapFlag = false;
		terrainScr.treeFlag = false;
		terrainScr.detailFlag = false;
		terrainScr.terrainDone = false;
	}

	public static void OQQOQOQQQC(ERTerrain terrainScr, Terrain terrain)
	{
		List<TreeInstance> list = new List<TreeInstance>(terrain.terrainData.treeInstances);
		for (int i = 0; i < terrainScr.terrainTrees.Count; i++)
		{
			list.Add(terrainScr.terrainTrees[i].SetERTreeInstance(terrainScr.terrainTrees[i]));
		}
		terrain.terrainData.treeInstances = list.ToArray();
		terrainScr.terrainTrees.Clear();
	}

	public static void ODCOOQCCCD(ERTerrain terrainScr, Terrain terrain)
	{
		TerrainData terrainData = terrain.terrainData;
		List<tPoint> list = new List<tPoint>();
		int[,] detailLayer = terrainData.GetDetailLayer(0, 0, terrainData.detailResolution, terrainData.detailResolution, 0);
		int num = -1;
		int num2 = 0;
		if (num2 + 1 < terrainScr.detailInstanceStarts.Count)
		{
			num = terrainScr.detailInstanceStarts[num2 + 1];
		}
		for (int i = 0; i < terrainScr.detailInstances.Count; i++)
		{
			if (i == num)
			{
				OOQDOQDCOO(terrain.terrainData, num2, list);
				num2++;
				if (num2 + 1 < terrainScr.detailInstanceStarts.Count)
				{
					num = terrainScr.detailInstanceStarts[num2 + 1];
				}
				list.Clear();
			}
			list.Add(terrainScr.detailInstances[i]);
		}
		if (list.Count > 0)
		{
			OOQDOQDCOO(terrain.terrainData, num2, list);
		}
		terrainScr.detailInstances.Clear();
		terrainScr.detailInstanceStarts.Clear();
	}

	public static void OOQDOQDCOO(TerrainData terrainInfo, int layer, List<tPoint> points)
	{
		int[,] detailLayer = terrainInfo.GetDetailLayer(0, 0, terrainInfo.detailResolution, terrainInfo.detailResolution, layer);
		for (int i = 0; i < points.Count; i++)
		{
			detailLayer[points[i].z, points[i].x] = points[i].v;
		}
		terrainInfo.SetDetailLayer(0, 0, layer, detailLayer);
	}

	public static List<tPoint> OQODQCQCCQ(ERModularBase scr, Terrain terrain, TerrainData terrainInfo, float minx, float maxx, float minz, float maxz)
	{
		float num = terrainInfo.size.x / (float)terrainInfo.detailResolution;
		float num2 = terrainInfo.size.z / (float)terrainInfo.detailResolution;
		float x = terrain.transform.position.x;
		float z = terrain.transform.position.z;
		float num3 = (minx + maxx) * 0.5f;
		float num4 = (minz + maxz) * 0.5f;
		float num5 = maxx - minx;
		float num6 = maxz - minz;
		int num7 = (int)((num3 - x) / num);
		int num8 = (int)((num4 - z) / num2);
		int num9 = (int)(num5 / num);
		int num10 = (int)(num6 / num2);
		List<tPoint> list = new List<tPoint>();
		for (int i = 0; i < num10; i++)
		{
			for (int j = 0; j < num9; j++)
			{
				tPoint tPoint2 = new tPoint();
				tPoint2.x = (int)((double)num7 - (double)num9 * 0.5 + (double)j);
				tPoint2.z = (int)((double)num8 - (double)num10 * 0.5 + (double)i);
				if (tPoint2.x >= 0 && tPoint2.z >= 0 && tPoint2.x < terrainInfo.detailResolution && tPoint2.z < terrainInfo.detailResolution)
				{
					list.Add(tPoint2);
				}
			}
		}
		List<tPoint> list2 = new List<tPoint>();
		foreach (tPoint item in list)
		{
			if (item.z < terrainInfo.detailResolution && item.x < terrainInfo.detailResolution)
			{
				Vector3 zero = Vector3.zero;
				zero.x = terrain.gameObject.transform.position.x + (float)item.x * num;
				zero.z = terrain.gameObject.transform.position.z + (float)item.z * num2;
				zero.y = terrain.SampleHeight(zero) + terrain.transform.position.y;
				LayerMask layerMask = 1 << scr.sLayer;
				zero.y += 20f;
				if (Physics.Raycast(zero, -Vector3.up, out var _, 30f, layerMask))
				{
					list2.Add(item);
				}
			}
		}
		return list2;
	}

	public static void OQCQDDOOCQ(ERTerrain tr, Terrain terrain)
	{
		float[,] heights = terrain.terrainData.GetHeights(0, 0, terrain.terrainData.heightmapResolution, terrain.terrainData.heightmapResolution);
		foreach (ERTerrainData item in tr.terrainDataStored)
		{
			if (item.critical)
			{
				heights[tr.zStart + item.terrainWidth, tr.xStart + item.terrainHeight] = item.flattenedHeight;
			}
		}
		terrain.terrainData.SetHeights(0, 0, heights);
	}

	public static void OOODOOOQCC(ERTerrain tr, Terrain terrain, float perc)
	{
		float[,] heights = terrain.terrainData.GetHeights(0, 0, terrain.terrainData.heightmapResolution, terrain.terrainData.heightmapResolution);
		float num = 0f;
		float num2 = terrain.transform.position.y / terrain.terrainData.size.y;
		foreach (ERTerrainData item in tr.terrainDataStored)
		{
			if (!item.critical && !item.ignorePreserveHeights)
			{
				num = Mathf.Lerp(1f, item.perc, perc);
				float num3 = Mathf.Lerp(item.originalHeight, item.flattenedHeight, num);
				heights[tr.zStart + item.terrainWidth, tr.xStart + item.terrainHeight] = num3;
			}
		}
		terrain.terrainData.SetHeights(0, 0, heights);
	}

	public static void OOOCCDQODO(GameObject go, int x, int y, ref List<ERSplatmap> instances, float[,,] trmap, int layers, Vector2 uvy)
	{
		string[] array = go.name.Split(new char[1] { '_' });
		if (go.name.IndexOf("SplatGO") == -1)
		{
			return;
		}
		int index = int.Parse(array[0].Replace("SplatGOcolor", ""));
		float num = float.Parse(array[1]);
		float x2 = uvy.x;
		float tv2;
		float tv3;
		float tv4;
		float tv5;
		float tv6;
		float tv7;
		float tv8;
		float tv9;
		float tv10;
		float tv11;
		float tv12;
		float tv = (tv2 = (tv3 = (tv4 = (tv5 = (tv6 = (tv7 = (tv8 = (tv9 = (tv10 = (tv11 = (tv12 = 0f)))))))))));
		if (layers > 0)
		{
			tv = trmap[x, y, 0];
			if (layers > 1)
			{
				tv2 = trmap[x, y, 1];
				if (layers > 2)
				{
					tv3 = trmap[x, y, 2];
					if (layers > 3)
					{
						tv4 = trmap[x, y, 3];
						if (layers > 4)
						{
							tv5 = trmap[x, y, 4];
							if (layers > 5)
							{
								tv6 = trmap[x, y, 5];
								if (layers > 6)
								{
									tv7 = trmap[x, y, 6];
									if (layers > 7)
									{
										tv8 = trmap[x, y, 7];
										if (layers > 8)
										{
											tv9 = trmap[x, y, 8];
											if (layers > 9)
											{
												tv10 = trmap[x, y, 9];
												if (layers > 10)
												{
													tv11 = trmap[x, y, 10];
													if (layers > 11)
													{
														tv12 = trmap[x, y, 11];
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		instances.Add(new ERSplatmap(x, y, index, layers, x2, go.transform.parent.GetComponent<ERModularRoad>(), tv, tv2, tv3, tv4, tv5, tv6, tv7, tv8, tv9, tv10, tv11, tv12));
	}

	public static void OOQQQQDCCO(ERModularBase baseScript, ERModularRoad scr)
	{
		scr.treeVecs.Clear();
		scr.detailVecs.Clear();
		for (int i = 0; i < scr.soSplinePointsLeft.Count; i++)
		{
			Vector3 normalized = (scr.soSplinePointsLeft[i] - scr.soSplinePointsRight[i]).normalized;
			if (i == 0 || i == scr.soSplinePointsLeft.Count - 1)
			{
				Vector3 vector = scr.soSplinePointsLeft[i];
				Vector3 vector2 = scr.soSplinePointsRight[i];
				Vector3 vector3 = new Vector3(normalized.z, 0f, 0f - normalized.x);
				if (i == 0)
				{
					vector += -vector3 * 1.5f;
					vector2 += -vector3 * 1.5f;
				}
				else
				{
					vector += vector3 * 1.5f;
					vector2 += vector3 * 1.5f;
				}
				scr.treeVecs.Add(vector + normalized * baseScript.treeDistance);
				scr.treeVecs.Add(vector2 + -normalized * baseScript.treeDistance);
				scr.detailVecs.Add(vector + normalized * baseScript.detailDistance - baseScript.detailOffsetVec);
				scr.detailVecs.Add(vector2 + -normalized * baseScript.detailDistance - baseScript.detailOffsetVec);
			}
			else
			{
				scr.treeVecs.Add(scr.soSplinePointsLeft[i] + normalized * baseScript.treeDistance);
				scr.treeVecs.Add(scr.soSplinePointsRight[i] + -normalized * baseScript.treeDistance);
				scr.detailVecs.Add(scr.soSplinePointsLeft[i] + normalized * baseScript.detailDistance - baseScript.detailOffsetVec);
				scr.detailVecs.Add(scr.soSplinePointsRight[i] + -normalized * baseScript.detailDistance - baseScript.detailOffsetVec);
			}
		}
	}

	public static GameObject CreateMesh(Transform parent, List<Vector3> vecs, List<int> tris, int layer, ERModularRoad scr, string name)
	{
		GameObject gameObject = new GameObject(name);
		gameObject.AddComponent<MeshFilter>();
		gameObject.AddComponent<MeshRenderer>();
		gameObject.AddComponent<MeshCollider>();
		gameObject.transform.parent = parent;
		gameObject.layer = layer;
		Mesh mesh = new Mesh();
		gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
		if (scr.exitRoads.Count > 0)
		{
			List<Vector3> list = null;
			foreach (OQQCCQCDQQ exitRoad in scr.exitRoads)
			{
				list = ((!(name == "treesERMesh")) ? exitRoad.detailVecs : exitRoad.treeVecs);
				if (list.Count > 0)
				{
					int count = vecs.Count;
					vecs.AddRange(list);
					float num = list.Count / 2;
					for (int i = 0; (float)i < num - 1f; i++)
					{
						tris.Add(count + i * 2);
						tris.Add(count + (i + 1) * 2 + 1);
						tris.Add(count + i * 2 + 1);
						tris.Add(count + (i + 1) * 2);
						tris.Add(count + (i + 1) * 2 + 1);
						tris.Add(count + i * 2);
					}
				}
			}
		}
		if (vecs.Count > 0)
		{
			mesh.vertices = vecs.ToArray();
			mesh.uv = new Vector2[vecs.Count];
			mesh.tangents = new Vector4[vecs.Count];
			mesh.triangles = tris.ToArray();
			mesh.RecalculateBounds();
		}
		gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
		gameObject.GetComponent<MeshCollider>().enabled = false;
		return gameObject;
	}

	public static void OCCQODOQDD(ERTerrain terrain, string folder)
	{
		Terrain component = terrain.gameObject.GetComponent<Terrain>();
		if (!(component != null))
		{
			return;
		}
		TerrainData terrainData = component.terrainData;
		terrain.terrainHeightsBackup.Clear();
		float[,] heights = component.terrainData.GetHeights(0, 0, terrainData.heightmapResolution, terrainData.heightmapResolution);
		for (int i = 0; i < terrainData.heightmapResolution; i++)
		{
			for (int j = 0; j < terrainData.heightmapResolution; j++)
			{
				terrain.terrainHeightsBackup.Add(new ERTerrainData(j, i, heights[j, i], 0f, m_critical: false, 0f, 0f, Vector3.zero, Vector3.zero));
			}
		}
	}

	public static void OQCOQDDCCC(ERTerrain terrain, string folder)
	{
		Terrain component = terrain.gameObject.GetComponent<Terrain>();
		if (component != null)
		{
			TerrainData terrainData = component.terrainData;
			terrain.terrainTreesBackup.Clear();
			for (int i = 0; i < terrainData.treeInstances.Length; i++)
			{
				terrain.terrainTreesBackup.Add(new ERTree(terrainData.treeInstances[i]));
			}
		}
	}

	public static void OOQQOOOQOO(ERTerrain terrain, string folder)
	{
		Terrain component = terrain.gameObject.GetComponent<Terrain>();
		if (!(component != null))
		{
			return;
		}
		TerrainData terrainData = component.terrainData;
		terrain.terrainDetailBackup.Clear();
		terrain.detailInstanceStartsBackUp.Clear();
		List<tPoint> list = new List<tPoint>();
		for (int i = 0; i < terrainData.detailPrototypes.Length; i++)
		{
			terrain.detailInstanceStartsBackUp.Add(list.Count);
			int[,] detailLayer = terrainData.GetDetailLayer(0, 0, terrainData.detailResolution, terrainData.detailResolution, i);
			for (int j = 0; j < terrainData.detailResolution; j++)
			{
				for (int k = 0; k < terrainData.detailResolution; k++)
				{
					tPoint tPoint2 = new tPoint();
					tPoint2.x = j;
					tPoint2.z = k;
					if (detailLayer[tPoint2.z, tPoint2.x] != 0)
					{
						tPoint2.v = detailLayer[tPoint2.z, tPoint2.x];
						list.Add(tPoint2);
					}
				}
			}
		}
		terrain.terrainDetailBackup.AddRange(list);
	}

	public static void ODCOQQQCCO(ERTerrain terrain, string folder)
	{
		Terrain component = terrain.gameObject.GetComponent<Terrain>();
		if (!(component != null))
		{
			return;
		}
		TerrainData terrainData = component.terrainData;
		terrain.terrainSplatBackup.Clear();
		int alphamapLayers = terrainData.alphamapLayers;
		if (alphamapLayers > 0)
		{
			float[,,] alphamaps = terrainData.GetAlphamaps(0, 0, terrainData.alphamapWidth, terrainData.alphamapHeight);
			for (int i = 0; i < terrainData.alphamapWidth; i++)
			{
				for (int j = 0; j < terrainData.alphamapHeight; j++)
				{
					float tv2;
					float tv3;
					float tv4;
					float tv5;
					float tv6;
					float tv7;
					float tv8;
					float tv9;
					float tv10;
					float tv11;
					float tv12;
					float tv = (tv2 = (tv3 = (tv4 = (tv5 = (tv6 = (tv7 = (tv8 = (tv9 = (tv10 = (tv11 = (tv12 = 0f)))))))))));
					if (alphamapLayers >= 1)
					{
						tv = alphamaps[i, j, 0];
					}
					if (alphamapLayers >= 2)
					{
						tv2 = alphamaps[i, j, 1];
					}
					if (alphamapLayers >= 3)
					{
						tv3 = alphamaps[i, j, 2];
					}
					if (alphamapLayers >= 4)
					{
						tv4 = alphamaps[i, j, 3];
					}
					terrain.terrainSplatBackup.Add(new ERSplatmap(i, j, 0, 0, 0f, null, tv, tv2, tv3, tv4, tv5, tv6, tv7, tv8, tv9, tv10, tv11, tv12));
					if (alphamapLayers >= 5)
					{
						tv = (tv2 = (tv3 = (tv4 = (tv5 = (tv6 = (tv7 = (tv8 = (tv9 = (tv10 = (tv11 = (tv12 = 0f)))))))))));
						if (alphamapLayers >= 4)
						{
							tv = alphamaps[i, j, 4];
						}
						if (alphamapLayers >= 5)
						{
							tv2 = alphamaps[i, j, 5];
						}
						if (alphamapLayers >= 6)
						{
							tv3 = alphamaps[i, j, 6];
						}
						if (alphamapLayers >= 7)
						{
							tv4 = alphamaps[i, j, 7];
						}
						terrain.terrainSplatBackup.Add(new ERSplatmap(i, j, 5, 5, 0f, null, tv, tv2, tv3, tv4, tv5, tv6, tv7, tv8, tv9, tv10, tv11, tv12));
					}
					if (alphamapLayers >= 9)
					{
						tv = (tv2 = (tv3 = (tv4 = (tv5 = (tv6 = (tv7 = (tv8 = (tv9 = (tv10 = (tv11 = (tv12 = 0f)))))))))));
						if (alphamapLayers >= 8)
						{
							tv = alphamaps[i, j, 8];
						}
						if (alphamapLayers >= 9)
						{
							tv2 = alphamaps[i, j, 9];
						}
						if (alphamapLayers >= 10)
						{
							tv3 = alphamaps[i, j, 10];
						}
						if (alphamapLayers >= 11)
						{
							tv4 = alphamaps[i, j, 11];
						}
						terrain.terrainSplatBackup.Add(new ERSplatmap(i, j, 9, 9, 0f, null, tv, tv2, tv3, tv4, tv5, tv6, tv7, tv8, tv9, tv10, tv11, tv12));
					}
				}
			}
		}
		terrain.terrainHeightsBackup.Clear();
	}

	public static void OCCOODODOQ(ERTerrain terrain, string folder)
	{
		Terrain component = terrain.gameObject.GetComponent<Terrain>();
		if (!(component != null))
		{
			return;
		}
		TerrainData terrainData = component.terrainData;
		float[,] heights = terrainData.GetHeights(0, 0, terrainData.heightmapResolution, terrainData.heightmapResolution);
		foreach (ERTerrainData item in terrain.terrainHeightsBackup)
		{
			heights[item.terrainWidth, item.terrainHeight] = item.originalHeight;
		}
		terrainData.SetHeights(0, 0, heights);
		component.Flush();
	}

	public static void OCCDQQCODQ(ERTerrain terrain, string folder)
	{
		Terrain component = terrain.gameObject.GetComponent<Terrain>();
		if (component != null)
		{
			TerrainData terrainData = component.terrainData;
			List<TreeInstance> list = new List<TreeInstance>();
			for (int i = 0; i < terrain.terrainTreesBackup.Count; i++)
			{
				list.Add(terrain.terrainTreesBackup[i].SetERTreeInstance(terrain.terrainTreesBackup[i]));
			}
			terrainData.treeInstances = list.ToArray();
			component.Flush();
		}
	}

	public static void OOOOCQCDQQ(ERTerrain terrain, string folder)
	{
		Terrain component = terrain.gameObject.GetComponent<Terrain>();
		if (!(component != null))
		{
			return;
		}
		TerrainData terrainData = component.terrainData;
		List<tPoint> list = new List<tPoint>();
		int[,] detailLayer = terrainData.GetDetailLayer(0, 0, terrainData.detailResolution, terrainData.detailResolution, 0);
		int num = -1;
		int num2 = 0;
		if (num2 + 1 < terrain.detailInstanceStartsBackUp.Count)
		{
			num = terrain.detailInstanceStartsBackUp[num2 + 1];
		}
		for (int i = 0; i < terrain.terrainDetailBackup.Count; i++)
		{
			if (i == num)
			{
				OOQDOQDCOO(terrainData, num2, list);
				if (num2 + 1 < terrain.detailInstanceStartsBackUp.Count)
				{
					num = terrain.detailInstanceStartsBackUp[num2 + 1];
				}
				num2++;
				list.Clear();
			}
		}
		if (list.Count > 0)
		{
			OOQDOQDCOO(terrainData, num2, list);
		}
		component.Flush();
	}

	public static void OOQOCCCCDD(ERTerrain terrain, string folder)
	{
		Terrain component = terrain.gameObject.GetComponent<Terrain>();
		if (!(component != null))
		{
			return;
		}
		TerrainData terrainData = component.terrainData;
		int alphamapLayers = terrainData.alphamapLayers;
		if (alphamapLayers > 0 && terrain.terrainSplatBackup.Count > 0)
		{
			float[,,] alphamaps = terrainData.GetAlphamaps(0, 0, terrainData.alphamapWidth, terrainData.alphamapHeight);
			foreach (ERSplatmap item in terrain.terrainSplatBackup)
			{
				if (item.index <= 4)
				{
					if (alphamapLayers > 0)
					{
						alphamaps[item.x, item.y, 0] = item.tValue1;
					}
					if (alphamapLayers > 1)
					{
						alphamaps[item.x, item.y, 1] = item.tValue2;
					}
					if (alphamapLayers > 2)
					{
						alphamaps[item.x, item.y, 2] = item.tValue3;
					}
					if (alphamapLayers > 3)
					{
						alphamaps[item.x, item.y, 3] = item.tValue4;
					}
				}
				else if (item.index <= 8)
				{
					if (alphamapLayers > 4)
					{
						alphamaps[item.x, item.y, 4] = item.tValue1;
					}
					if (alphamapLayers > 5)
					{
						alphamaps[item.x, item.y, 5] = item.tValue2;
					}
					if (alphamapLayers > 6)
					{
						alphamaps[item.x, item.y, 6] = item.tValue3;
					}
					if (alphamapLayers > 7)
					{
						alphamaps[item.x, item.y, 7] = item.tValue4;
					}
				}
				else if (item.index <= 12)
				{
					if (alphamapLayers > 8)
					{
						alphamaps[item.x, item.y, 8] = item.tValue1;
					}
					if (alphamapLayers > 9)
					{
						alphamaps[item.x, item.y, 9] = item.tValue2;
					}
					if (alphamapLayers > 10)
					{
						alphamaps[item.x, item.y, 10] = item.tValue3;
					}
					if (alphamapLayers > 11)
					{
						alphamaps[item.x, item.y, 11] = item.tValue4;
					}
				}
			}
			terrainData.SetAlphamaps(0, 0, alphamaps);
		}
		component.Flush();
	}
}
[AddComponentMenu("")]
public class ERSideObjectInstance : MonoBehaviour
{
	[HideInInspector]
	public SideObject so;

	[HideInInspector]
	public double id;

	[HideInInspector]
	public ERModularRoad roadScript;

	[HideInInspector]
	public List<GameObject> childs = new List<GameObject>();

	[HideInInspector]
	public List<Vector3> vecs = new List<Vector3>();

	[HideInInspector]
	public List<bool> terrainIndexes = new List<bool>();

	[HideInInspector]
	public bool buildFlag;

	[HideInInspector]
	public bool postProcess;

	[HideInInspector]
	public bool batches = false;

	[HideInInspector]
	public bool combined = false;

	[HideInInspector]
	public List<GameObject> batchedObjects = new List<GameObject>();

	[HideInInspector]
	public List<Vector3> startEndPositions = new List<Vector3>();
}
[Serializable]
public struct ERSplatmap
{
	public int x;

	public int y;

	public int index;

	public int layer;

	public float value;

	public ERModularRoad script;

	public float tValue1;

	public float tValue2;

	public float tValue3;

	public float tValue4;

	public float tValue5;

	public float tValue6;

	public float tValue7;

	public float tValue8;

	public float tValue9;

	public float tValue10;

	public float tValue11;

	public float tValue12;

	public ERSplatmap(int m_x, int m_y, int m_index, int m_layer, float m_value, ERModularRoad scr, float tv1, float tv2, float tv3, float tv4, float tv5, float tv6, float tv7, float tv8, float tv9, float tv10, float tv11, float tv12)
	{
		x = m_x;
		y = m_y;
		index = m_index;
		layer = m_layer;
		value = m_value;
		script = scr;
		tValue1 = tv1;
		tValue2 = tv2;
		tValue3 = tv3;
		tValue4 = tv4;
		tValue5 = tv5;
		tValue6 = tv6;
		tValue7 = tv7;
		tValue8 = tv8;
		tValue9 = tv9;
		tValue10 = tv10;
		tValue11 = tv11;
		tValue12 = tv12;
	}
}
[Serializable]
public class ERTree
{
	public Color color;

	public float heightScale;

	public Color lightmapColor;

	public Vector3 position;

	public int prototypeIndex;

	public float widthScale;

	public ERTree(TreeInstance instance)
	{
		color = instance.color;
		heightScale = instance.heightScale;
		lightmapColor = instance.lightmapColor;
		position = instance.position;
		prototypeIndex = instance.prototypeIndex;
		widthScale = instance.widthScale;
	}

	public TreeInstance SetERTreeInstance(ERTree eRTreeinstance)
	{
		return new TreeInstance
		{
			color = eRTreeinstance.color,
			heightScale = eRTreeinstance.heightScale,
			lightmapColor = eRTreeinstance.lightmapColor,
			position = eRTreeinstance.position,
			prototypeIndex = eRTreeinstance.prototypeIndex,
			widthScale = eRTreeinstance.widthScale
		};
	}
}
[Serializable]
public class tPoint
{
	public int x;

	public int z;

	public bool done;

	public float dist;

	public int v;
}
[AddComponentMenu("")]
public class OOQQQDOCDD : MonoBehaviour
{
	public static void OCODDOCODQ(ref int startInt, float startOffset, ref List<int> markerInts, ref List<Vector3> vecPositions, ref List<Vector3> soSplinePointLeft, List<Vector3> soSplinePointRight, ref ERSOMarkerExt soMarker, ERModularRoad roadScr, ref List<List<Vector2>> nodeList)
	{
		soMarker.curStartInt = startInt;
		float num = 0f;
		float num2 = 0f;
		if (startOffset >= 0f)
		{
			for (int i = startInt + 1; i < vecPositions.Count; i++)
			{
				num = Vector3.Distance(vecPositions[i - 1], vecPositions[i]);
				if (num2 + num > startOffset)
				{
					float t = (startOffset - num2) / num;
					Vector3 vector = Vector3.Lerp(vecPositions[i - 1], vecPositions[i], t);
					Vector3 item = Vector3.Lerp(soSplinePointLeft[i - 1], soSplinePointLeft[i], t);
					Vector3 item2 = Vector3.Lerp(soSplinePointRight[i - 1], soSplinePointRight[i], t);
					for (int j = 0; j < nodeList.Count; j++)
					{
						Vector2 item3 = Vector2.Lerp(nodeList[j][i - 1], nodeList[j][i], t);
						nodeList[j].Insert(i, item3);
					}
					vecPositions.Insert(i, vector);
					soSplinePointLeft.Insert(i, item);
					soSplinePointRight.Insert(i, item2);
					markerInts.Insert(i, markerInts[i]);
					startInt = i;
					soMarker.startOffsetV3 = vector;
					Vector3 vector2 = vector;
					Vector3 vector3 = vecPositions[i - 1];
					if (vector2 == vector3)
					{
						vector2 = vecPositions[i];
					}
					if (soMarker.sideObject.snapToTerrain || roadScr.snapToTerrain)
					{
						soMarker.startOffsetV3.y = ODQDQDQDQO.OOCQOOCOQC(soMarker.startOffsetV3, roadScr.baseScript);
						vector2.y = ODQDQDQDQO.OOCQOOCOQC(vector2, roadScr.baseScript);
						vector3.y = ODQDQDQDQO.OOCQOOCOQC(vector3, roadScr.baseScript);
					}
					Vector3 startOffsetDir = soMarker.startOffsetDir;
					soMarker.startOffsetDir = (vector2 - vector3).normalized;
					soMarker.startOffsetDir = new Vector3(soMarker.startOffsetDir.x, 0f, soMarker.startOffsetDir.z).normalized;
					if (soMarker.startOffsetDir == Vector3.zero)
					{
						soMarker.startOffsetDir = startOffsetDir;
					}
					soMarker.startOffsetV3nb = soSplinePointLeft[i];
					break;
				}
				num2 += num;
			}
			return;
		}
		startOffset *= -1f;
		int num3 = markerInts[startInt];
		for (int num4 = startInt; num4 > 0; num4--)
		{
			num = Vector3.Distance(vecPositions[num4 - 1], vecPositions[num4]);
			if (num2 + num > startOffset)
			{
				float t = (startOffset - num2) / num;
				Vector3 vector = Vector3.Lerp(vecPositions[num4], vecPositions[num4 - 1], t);
				Vector3 item = Vector3.Lerp(soSplinePointLeft[num4], soSplinePointLeft[num4 - 1], t);
				Vector3 item2 = Vector3.Lerp(soSplinePointRight[num4], soSplinePointRight[num4 - 1], t);
				for (int k = 0; k < nodeList.Count; k++)
				{
					Vector2 item3 = Vector2.Lerp(nodeList[k][num4], nodeList[k][num4 - 1], t);
					nodeList[k].Insert(num4, item3);
				}
				vecPositions.Insert(num4, vector);
				soSplinePointLeft.Insert(num4, item);
				soSplinePointRight.Insert(num4, item2);
				markerInts[num4] = num3;
				markerInts.Insert(num4, num3);
				soMarker.startOffsetV3 = vector;
				Vector3 vector2 = vector;
				Vector3 vector3 = vecPositions[num4 + 1];
				if (soMarker.sideObject.snapToTerrain || roadScr.snapToTerrain)
				{
					soMarker.startOffsetV3.y = ODQDQDQDQO.OOCQOOCOQC(soMarker.startOffsetV3, roadScr.baseScript);
					vector2.y = ODQDQDQDQO.OOCQOOCOQC(vector2, roadScr.baseScript);
					vector3.y = ODQDQDQDQO.OOCQOOCOQC(vector3, roadScr.baseScript);
				}
				soMarker.startOffsetDir = (vector2 - vector3).normalized;
				soMarker.startOffsetDir = new Vector3(soMarker.startOffsetDir.x, 0f, soMarker.startOffsetDir.z).normalized;
				soMarker.startOffsetV3nb = soSplinePointLeft[num4];
				soMarker.curStartInt++;
				startInt = num4;
				break;
			}
			num2 += num;
			markerInts[num4] = num3;
		}
	}

	public static void OCQCDCDCQC(int startInt, float endOffset, ref List<int> markerInts, ref List<Vector3> vecPositions, ref List<Vector3> soSplinePointLeft, List<Vector3> soSplinePointRight, ref ERSOMarkerExt soMarker, ERModularRoad roadScr, ref List<List<Vector2>> nodeList)
	{
		int num = markerInts[startInt];
		int num2 = 0;
		for (int i = startInt + 1; i < vecPositions.Count; i++)
		{
			if (num != markerInts[i])
			{
				num2 = i;
				break;
			}
		}
		if (num2 == 0)
		{
			num2 = vecPositions.Count - 1;
		}
		soMarker.curEndInt = num2;
		float num3 = 0f;
		float num4 = 0f;
		if (endOffset < 0f)
		{
			endOffset *= -1f;
			for (int num5 = num2; num5 > 0; num5--)
			{
				num3 = Vector3.Distance(vecPositions[num5 - 1], vecPositions[num5]);
				if (num4 + num3 > endOffset)
				{
					float t = (endOffset - num4) / num3;
					Vector3 vector = Vector3.Lerp(vecPositions[num5], vecPositions[num5 - 1], t);
					Vector3 item = Vector3.Lerp(soSplinePointLeft[num5], soSplinePointLeft[num5 - 1], t);
					Vector3 item2 = Vector3.Lerp(soSplinePointRight[num5], soSplinePointRight[num5 - 1], t);
					for (int j = 0; j < nodeList.Count; j++)
					{
						Vector2 item3 = Vector2.Lerp(nodeList[j][num5], nodeList[j][num5 - 1], t);
						nodeList[j].Insert(num5, item3);
					}
					vecPositions.Insert(num5, vector);
					soSplinePointLeft.Insert(num5, item);
					soSplinePointRight.Insert(num5, item2);
					markerInts[num5] = num + 1;
					markerInts.Insert(num5, num + 1);
					Vector3 vector2 = vector;
					Vector3 vector3 = vecPositions[num5 - 1];
					soMarker.endOffsetV3 = vector;
					if (soMarker.sideObject.snapToTerrain || roadScr.snapToTerrain)
					{
						soMarker.endOffsetV3.y = ODQDQDQDQO.OOCQOOCOQC(soMarker.endOffsetV3, roadScr.baseScript);
						vector2.y = ODQDQDQDQO.OOCQOOCOQC(vector2, roadScr.baseScript);
						vector3.y = ODQDQDQDQO.OOCQOOCOQC(vector3, roadScr.baseScript);
					}
					soMarker.endOffsetDir = (vector2 - vector3).normalized;
					soMarker.endOffsetV3nb = vecPositions[num5];
					soMarker.curEndInt++;
					break;
				}
				num4 += num3;
				markerInts[num5] = num + 1;
			}
			return;
		}
		for (int k = num2; k < vecPositions.Count - 1; k++)
		{
			num3 = Vector3.Distance(vecPositions[k], vecPositions[k + 1]);
			if (num4 + num3 > endOffset)
			{
				float t = (endOffset - num4) / num3;
				Vector3 vector = Vector3.Lerp(vecPositions[k], vecPositions[k + 1], t);
				Vector3 item = Vector3.Lerp(soSplinePointLeft[k], soSplinePointLeft[k + 1], t);
				Vector3 item2 = Vector3.Lerp(soSplinePointRight[k], soSplinePointRight[k + 1], t);
				for (int l = 0; l < nodeList.Count; l++)
				{
					Vector2 item3 = Vector2.Lerp(nodeList[l][k], nodeList[l][k + 1], t);
					nodeList[l].Insert(k, item3);
				}
				vecPositions.Insert(k + 1, vector);
				soSplinePointLeft.Insert(k + 1, item);
				soSplinePointRight.Insert(k + 1, item2);
				markerInts[k] = num;
				markerInts.Insert(k + 1, num + 1);
				soMarker.endOffsetV3 = vector;
				Vector3 vector2 = vector;
				Vector3 vector3 = vecPositions[k];
				if (soMarker.sideObject.snapToTerrain || roadScr.snapToTerrain)
				{
					soMarker.endOffsetV3.y = ODQDQDQDQO.OOCQOOCOQC(soMarker.endOffsetV3, roadScr.baseScript);
					vector2.y = ODQDQDQDQO.OOCQOOCOQC(vector2, roadScr.baseScript);
					vector3.y = ODQDQDQDQO.OOCQOOCOQC(vector3, roadScr.baseScript);
				}
				soMarker.endOffsetDir = (vector2 - vector3).normalized;
				soMarker.startOffsetV3nb = vecPositions[k];
				break;
			}
			markerInts[k] = num;
			num4 += num3;
		}
	}

	public static bool MoveDirection(ERModularRoad road, ERSOMarkerExt markerSO, Vector3 v)
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < road.soDataExt.Count; i++)
		{
			if (road.soDataExt[i].id == markerSO.id)
			{
				list = road.soDataExt[i].vecPositions;
			}
		}
		bool result = false;
		if (list.Count > 0 && markerSO.curStartInt != -1)
		{
			float num2;
			float num = (num2 = 0f);
			float num3 = Vector3.Distance(list[markerSO.curStartInt], v);
			if (markerSO.curStartInt > 0)
			{
				num = Vector3.Distance(list[markerSO.curStartInt - 1], v);
				if (num3 < num)
				{
					result = true;
				}
			}
			else if (markerSO.curStartInt < list.Count - 1)
			{
				num2 = Vector3.Distance(list[markerSO.curStartInt + 1], v);
				if (num3 >= num2)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static void OQDCCQDCQQ(ERModularRoad road, ERSOMarkerExt markerSO, Vector3 v, Camera cam, ref int xDir, ref int yDir)
	{
		List<Vector3> list = new List<Vector3>();
		float num = 0f;
		float num2 = 0f;
		float num3 = 10000f;
		int num4 = -1;
		float num5 = 10000f;
		for (int i = 0; i < road.soDataExt.Count; i++)
		{
			if (road.soDataExt[i].id != markerSO.id)
			{
				continue;
			}
			list = road.soDataExt[i].vecPositions;
			if (list.Count <= 1)
			{
				continue;
			}
			for (int j = 0; j < list.Count - 1; j++)
			{
				float num6 = Vector3.Distance(list[j], v);
				if (num5 > num6)
				{
					num5 = num6;
					num4 = j;
				}
			}
			Vector3 vector = cam.WorldToScreenPoint(list[num4]);
			Vector3 vector2 = cam.WorldToScreenPoint(list[num4 + 1]);
			if (vector.x > vector2.x)
			{
				xDir = 1;
			}
			else
			{
				xDir = -1;
			}
			if (vector.y > vector2.y)
			{
				yDir = -1;
			}
			else
			{
				yDir = 1;
			}
		}
	}

	public static void ODODODDCCQ(ERModularRoad road, ERSOMarkerExt markerSO, Vector3 v, Vector3 vOld, float movement)
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < road.soDataExt.Count; i++)
		{
			if (road.soDataExt[i].id == markerSO.id)
			{
				list = road.soDataExt[i].vecPositions;
			}
		}
		if (list.Count > 0 && markerSO.curStartInt != -1)
		{
			float num2;
			float num = (num2 = 0f);
			float num3 = Vector3.Distance(list[markerSO.curStartInt], v);
			bool flag = false;
			if (markerSO.curStartInt > 0)
			{
				num = Vector3.Distance(list[markerSO.curStartInt - 1], v);
				if (num3 < num)
				{
					flag = true;
				}
			}
			else if (markerSO.curStartInt < list.Count - 1)
			{
				num2 = Vector3.Distance(list[markerSO.curStartInt + 1], v);
				if (num3 >= num2)
				{
					flag = true;
				}
			}
			float num4 = 0f;
			if (flag)
			{
				if (markerSO.curStartInt < list.Count - 1)
				{
					for (int j = markerSO.curStartInt; j < list.Count - 1; j++)
					{
						float num5 = Vector3.Distance(list[j], v);
						float num6 = Vector3.Distance(list[j], list[j + 1]);
						if (num5 < num6)
						{
							markerSO.startOffset = num4 + num5;
							break;
						}
						num4 += num6;
					}
				}
				else
				{
					markerSO.startOffset = 0f;
				}
			}
			else if (markerSO.curStartInt > 0)
			{
				for (int num7 = markerSO.curStartInt; num7 > 0; num7--)
				{
					float num5 = Vector3.Distance(list[num7], v);
					float num6 = Vector3.Distance(list[num7], list[num7 - 1]);
					if (num5 < num6)
					{
						markerSO.startOffset = (num4 + num5) * -1f;
						break;
					}
					num4 += num6;
				}
			}
			else
			{
				markerSO.startOffset = 0f;
			}
		}
		else
		{
			markerSO.startOffset = -0.01f;
		}
	}

	public static void OODCOCOCCO(ERModularRoad road, ERSOMarkerExt markerSO, Vector3 v)
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < road.soDataExt.Count; i++)
		{
			if (road.soDataExt[i].id == markerSO.id)
			{
				list = road.soDataExt[i].vecPositions;
			}
		}
		if (markerSO.curEndInt >= list.Count)
		{
			markerSO.curEndInt = list.Count - 1;
		}
		if (list.Count > 0 && markerSO.curEndInt != -1)
		{
			float num2;
			float num = (num2 = 0f);
			float num3 = Vector3.Distance(list[markerSO.curEndInt], v);
			bool flag = false;
			if (markerSO.curEndInt > 0)
			{
				num = Vector3.Distance(list[markerSO.curEndInt - 1], v);
				if (num3 < num)
				{
					flag = true;
				}
			}
			else if (markerSO.curEndInt < list.Count - 1)
			{
				num2 = Vector3.Distance(list[markerSO.curEndInt + 1], v);
				if (num3 > num2)
				{
					flag = true;
				}
			}
			float num4 = 0f;
			if (flag)
			{
				if (markerSO.curEndInt < list.Count - 1)
				{
					for (int j = markerSO.curEndInt; j < list.Count - 1; j++)
					{
						float num5 = Vector3.Distance(list[j], v);
						float num6 = Vector3.Distance(list[j], list[j + 1]);
						if (num5 < num6)
						{
							markerSO.endOffset = num4 + num5;
							break;
						}
						num4 += num6;
					}
				}
				else
				{
					markerSO.endOffset = 0f;
				}
			}
			else if (markerSO.curEndInt < list.Count)
			{
				for (int num7 = markerSO.curEndInt; num7 > 0; num7--)
				{
					float num5 = Vector3.Distance(list[num7], v);
					float num6 = Vector3.Distance(list[num7], list[num7 - 1]);
					if (num5 < num6)
					{
						markerSO.endOffset = (num4 + num5) * -1f;
						break;
					}
					num4 += num6;
				}
			}
			else
			{
				markerSO.endOffset = 0f;
			}
		}
		else
		{
			markerSO.endOffset = -0.01f;
		}
	}

	public static void OCQQDCQQCO(int startInt, List<Vector3> vecPositions, List<int> markersInts, ref ERSOMarkerExt soMarker, bool startFlag, ERModularRoad roadScr)
	{
		if (startFlag)
		{
			soMarker.startOffsetV3 = vecPositions[startInt];
			if (soMarker.sideObject.snapToTerrain || roadScr.snapToTerrain)
			{
				soMarker.startOffsetV3.y = ODQDQDQDQO.OOCQOOCOQC(soMarker.startOffsetV3, roadScr.baseScript);
			}
			Vector3 vector;
			Vector3 vector2;
			if (startInt == 0)
			{
				vector = vecPositions[startInt + 1];
				vector2 = vecPositions[startInt];
				if (soMarker.sideObject.snapToTerrain || roadScr.snapToTerrain)
				{
					vector.y = ODQDQDQDQO.OOCQOOCOQC(vector, roadScr.baseScript);
					vector2.y = ODQDQDQDQO.OOCQOOCOQC(vector2, roadScr.baseScript);
				}
			}
			else
			{
				vector = vecPositions[startInt];
				vector2 = vecPositions[startInt - 1];
				if (soMarker.sideObject.snapToTerrain || roadScr.snapToTerrain)
				{
					vector.y = ODQDQDQDQO.OOCQOOCOQC(vector, roadScr.baseScript);
					vector2.y = ODQDQDQDQO.OOCQOOCOQC(vector2, roadScr.baseScript);
				}
			}
			soMarker.startOffsetDir = (vector - vector2).normalized;
			return;
		}
		int num = markersInts[startInt];
		for (int i = startInt + 1; i < vecPositions.Count; i++)
		{
			if (num != markersInts[i] || i == vecPositions.Count - 1)
			{
				soMarker.endOffsetV3 = vecPositions[i];
				Vector3 vector = vecPositions[i];
				Vector3 vector2 = vecPositions[i - 1];
				if (soMarker.sideObject.snapToTerrain || roadScr.snapToTerrain)
				{
					soMarker.endOffsetV3.y = ODQDQDQDQO.OOCQOOCOQC(soMarker.endOffsetV3, roadScr.baseScript);
					vector.y = ODQDQDQDQO.OOCQOOCOQC(vector, roadScr.baseScript);
					vector2.y = ODQDQDQDQO.OOCQOOCOQC(vector2, roadScr.baseScript);
				}
				soMarker.endOffsetDir = (vector - vector2).normalized;
				break;
			}
		}
	}

	public static void SynchSoData(ERSORoadExt soData, bool flag)
	{
		if (!soData.distanceChange || flag)
		{
			soData.m_distance = soData.sideObject.m_distance;
		}
		if (!soData.xPosChange || flag)
		{
			soData.xPosition = soData.sideObject.xPosition;
		}
		if (!soData.randomXPositionChange || flag)
		{
			soData.randomMinXPosition = soData.sideObject.randomMinXPosition;
			soData.randomMaxXPosition = soData.sideObject.randomMaxXPosition;
		}
		if (!soData.xPositionDistanceChange || flag)
		{
			soData.minRandomXPositionDistance = soData.sideObject.minRandomXPositionDistance;
			soData.maxRandomXPositionDistance = soData.sideObject.maxRandomXPositionDistance;
		}
		if (!soData.randomYPositionChange || flag)
		{
			soData.randomMinYPosition = soData.sideObject.randomMinYPosition;
			soData.randomMaxYPosition = soData.sideObject.randomMaxYPosition;
		}
		if (!soData.yPositionDistanceChange || flag)
		{
			soData.minRandomYPositionDistance = soData.sideObject.minRandomYPositionDistance;
			soData.maxRandomYPositionDistance = soData.sideObject.maxRandomYPositionDistance;
		}
		if (!soData.yPosChange || flag)
		{
			soData.yPosition = soData.sideObject.yPosition;
		}
		if (!soData.rotationAngleChange || flag)
		{
			soData.randomMinRotation = soData.sideObject.randomMinRotation;
			soData.randomMaxRotation = soData.sideObject.randomMaxRotation;
		}
		if (!soData.rotationDistanceChange || flag)
		{
			soData.minRandomRotationDistance = soData.sideObject.minRandomRotationDistance;
			soData.maxRandomRotationDistance = soData.sideObject.maxRandomRotationDistance;
		}
		if (flag)
		{
			soData.distanceChange = false;
			soData.xPosChange = false;
			soData.randomXPositionChange = false;
			soData.xPositionDistanceChange = false;
			soData.randomYPositionChange = false;
			soData.yPositionDistanceChange = false;
			soData.yPosChange = false;
			soData.rotationAngleChange = false;
			soData.rotationDistanceChange = false;
			soData.sourceObject = soData.sideObject.sourceObject;
		}
	}

	public static void OOQQCOQDQC(ERSORoadExt soData, ERSORoadExt source)
	{
		soData.autoGenerate = source.autoGenerate;
		soData.markerActive = source.markerActive;
		soData.clampToMarkers = source.clampToMarkers;
		soData.m_distance = source.m_distance;
		soData.xPosition = source.xPosition;
		soData.yPosition = source.yPosition;
		soData.randomMinRotation = source.randomMinRotation;
		soData.randomMaxRotation = source.randomMaxRotation;
		soData.minRandomRotationDistance = source.minRandomRotationDistance;
		soData.maxRandomRotationDistance = source.maxRandomRotationDistance;
		soData.distanceChange = source.distanceChange;
		soData.xPosChange = source.xPosChange;
		soData.randomXPositionChange = source.randomXPositionChange;
		soData.yPosChange = source.yPosChange;
		soData.randomYPositionChange = source.randomYPositionChange;
		soData.rotationAngleChange = source.rotationAngleChange;
		soData.rotationDistanceChange = source.rotationDistanceChange;
		soData.xPositionDistanceChange = source.xPositionDistanceChange;
		soData.randomXPosition = source.randomXPosition;
		soData.randomMinXPosition = source.randomMinXPosition;
		soData.randomMaxXPosition = source.randomMaxXPosition;
		soData.minRandomXPositionDistance = source.minRandomXPositionDistance;
		soData.maxRandomXPositionDistance = source.maxRandomXPositionDistance;
		soData.yPositionDistanceChange = source.yPositionDistanceChange;
		soData.randomYPosition = source.randomYPosition;
		soData.randomMinYPosition = source.randomMinYPosition;
		soData.randomMaxYPosition = source.randomMaxYPosition;
		soData.minRandomYPositionDistance = source.minRandomYPositionDistance;
		soData.maxRandomYPositionDistance = source.maxRandomYPositionDistance;
		soData.sourceObject = source.sourceObject;
	}

	public static void UnlockSORotation(List<ERSORoadExt> soDataList)
	{
		foreach (ERSORoadExt soData in soDataList)
		{
			soData.lockRandomRotations = false;
		}
	}

	public static void CheckMarkerSOData(SideObject so, ERModularRoad road)
	{
	}

	public static void ResetMarkerSOData(ERModularRoad road)
	{
		foreach (ERSORoadExt item in road.soDataExt)
		{
			if (!item.active)
			{
				continue;
			}
			int num = 0;
			foreach (ERMarkerExt item2 in road.markersExt)
			{
				int num2 = -1;
				int num3 = 0;
				bool flag = false;
				foreach (ERSOMarkerExt soDatum in item2.soData)
				{
					if (soDatum == null)
					{
						num2 = num3;
					}
					else if (soDatum.id == item.id)
					{
						flag = true;
						break;
					}
					num3++;
				}
				if (!flag && num2 != -1)
				{
					item2.soData[num2] = ERSOMarkerExt.CreateInstance(item.sideObject, flag: true);
				}
				if (item.sideObject.relativeTo != 0 && item2.soData.Count >= num2 && item2.soData[num2] != null && item2.soData[num2].otherSide == null)
				{
					item2.soData[num2].otherSide = ERSOMarkerExt.CreateInstance(item.sideObject, flag: true);
					item2.soData[num2].otherSide.Copy(item2.soData[num2]);
				}
				num++;
			}
		}
	}

	public static void OQOQCQQCQQ(ERModularRoad road, SideObject so)
	{
		foreach (ERMarkerExt item in road.markersExt)
		{
			foreach (ERSOMarkerExt soDatum in item.soData)
			{
				if (soDatum.id == so.id)
				{
					if (soDatum.otherSide == null)
					{
						soDatum.otherSide = ERSOMarkerExt.CreateInstance(so, flag: true);
						soDatum.otherSide.xPosition = soDatum.xPosition * -1f;
					}
					break;
				}
			}
		}
	}

	public static void OOCDDOOOOQ(ERModularBase scr, SideObject so, GameObject go)
	{
		List<int> list = new List<int>();
		List<int> list2 = new List<int>();
		if ((double)so.snapWeightList[0] > 0.99)
		{
			list.Add(0);
		}
		else if ((double)so.snapWeightList[0] >= 0.95)
		{
			list2.Add(0);
		}
		if ((double)so.snapWeightList[so.snapWeightList.Count - 1] > 0.99)
		{
			list.Add(so.snapWeightList.Count - 1);
		}
		else if ((double)so.snapWeightList[so.snapWeightList.Count - 1] >= 0.95)
		{
			list2.Add(so.snapWeightList.Count - 1);
		}
		if (list.Count == 0 && list2.Count == 0)
		{
			return;
		}
		List<GameObject> list3 = new List<GameObject>();
		list3.Add(go);
		foreach (Transform item in go.transform)
		{
			if (item.name.IndexOf(" Batch ") != -1)
			{
				list3.Add(item.gameObject);
			}
		}
		foreach (GameObject item2 in list3)
		{
			if (!(item2.GetComponent<MeshFilter>() != null))
			{
				continue;
			}
			Mesh sharedMesh = item2.GetComponent<MeshFilter>().sharedMesh;
			int count = so.nodeList.Count;
			Vector3[] vertices = sharedMesh.vertices;
			Vector3[] normals = sharedMesh.normals;
			if ((float)vertices.Length * 1f / ((float)count * 1f) != (float)(vertices.Length / count))
			{
				continue;
			}
			for (int i = 0; i < vertices.Length; i += count)
			{
				for (int j = 0; j < list.Count; j++)
				{
					Vector3 pos = vertices[i + list[j]];
					scr.OCDDQOCDCO(ref pos);
					vertices[i + list[j]] = pos;
					normals[i + list[j]] = scr.OQOODODDQO(pos);
				}
				for (int k = 0; k < list2.Count; k++)
				{
					Vector3 pos = vertices[i + list2[k]];
					normals[i + list2[k]] = scr.OQOODODDQO(pos);
				}
			}
			sharedMesh.vertices = vertices;
			sharedMesh.normals = normals;
			if (item2.GetComponent<MeshCollider>() != null)
			{
				item2.GetComponent<MeshCollider>().sharedMesh = null;
				item2.GetComponent<MeshCollider>().sharedMesh = sharedMesh;
			}
		}
	}

	public static bool IsActiveAsChild(ERModularBase scr, double soid, double targetSOId)
	{
		if (scr != null)
		{
			for (int i = 0; i < scr.QOQDQOOQDDQOOQ.Count; i++)
			{
				if (scr.QOQDQOOQDDQOOQ[i].id != soid)
				{
					continue;
				}
				for (int j = 0; j < scr.QOQDQOOQDDQOOQ[i].buildOtherSideObjects.Count; j++)
				{
					if (scr.QOQDQOOQDDQOOQ[i].buildOtherSideObjects[j] == targetSOId)
					{
						return true;
					}
				}
			}
		}
		return false;
	}
}
[Serializable]
public class ERMarker
{
	public bool activeSplineNode = true;

	public float leftIndent = 5f;

	public int leftIndentAlignment = 0;

	public float rightIndent = 5f;

	public int rightIndentAlignment = 0;

	public float leftSurrounding = 5f;

	public float rightSurrounding = 5f;

	public bool bridgeObject = false;

	public float bridgeStartLevelDistance = 0f;

	public float bridgeEndLevelDistance = 0f;

	public float rotation = 0f;

	public Vector3 position = Vector3.zero;

	public int controlType = 0;

	public int rotations = 0;

	public float circularRadius = 1f;

	public float circularAngle = 90f;

	public int circularSegments = 10;

	public float splineStrength = 0.5f;

	public Vector3 direction;

	public Vector3 direction1;

	public bool followTerrainContours = false;

	public int startSplinePoint = 0;

	public float startDistance = 0f;

	public float startUVY = 0f;

	public float totalDistance = 0f;

	public string totalDistanceString = "";

	public string angleString = "";

	public float rotationCenter = 0.5f;

	public List<ERSOMarker> soData = new List<ERSOMarker>();

	public ERMarkerControlType controllerType;

	public bool attachExit = false;

	public int exitType = 0;

	public int exitGeometryType;

	public int startExitInt = 0;

	public int endExitInt = 0;

	public float startExitOffset = 0f;

	public float extrusionDistance = 10f;

	public int extrusionType = 0;

	public float fixedDistance = 10f;

	public float connectionAngle = 10f;

	public float connectionRadius = 5f;

	public Material exitMaterial;

	public Material connectionMaterial;

	public int exitRoadType = 0;

	public int connectionRoadType = 0;

	public List<List<Vector3>> exitOuterVerticesExtrusion = new List<List<Vector3>>();

	public List<List<Vector3>> exitOuterVerticesFixed = new List<List<Vector3>>();

	public List<List<Vector3>> exitOuterVerticesCurve = new List<List<Vector3>>();

	public List<Vector3> exitInnerVertices = new List<Vector3>();

	public List<Vector2> roadShape = new List<Vector2>();

	public List<Vector3> roadShapeVecsGlobal = new List<Vector3>();

	public float markerStartUVY = 0f;

	public Vector3 perpDir = Vector3.zero;

	public Vector3 perpDirRotated = Vector3.zero;

	public ERMarker(Vector3 pos, ERModularRoad scr, int element)
	{
		position = pos;
		splineStrength = 0.5f;
		followTerrainContours = scr.followTerrainContours;
		leftIndent = scr.indent;
		rightIndent = scr.indent;
		leftSurrounding = scr.surrounding;
		rightSurrounding = scr.surrounding;
		if (scr.markersExt.Count == 0)
		{
			roadShape = new List<Vector2>(scr.roadShape);
		}
		else if (element == 0)
		{
			roadShape = new List<Vector2>(scr.markersExt[0].roadShape);
		}
		else
		{
			roadShape = new List<Vector2>(scr.markersExt[element - 1].roadShape);
		}
		soData = new List<ERSOMarker>();
		for (int i = 0; i < scr.soData.Count; i++)
		{
			if (scr.soData[i].active)
			{
				soData.Add(new ERSOMarker(scr.soData[i].sideObject, flag: true));
				if (element != 0)
				{
					soData[soData.Count - 1].OODOOOQQCO(scr.markersExt[element - 1].soData[soData.Count - 1]);
				}
			}
		}
	}

	public void SetControlType(ERMarkerControlType type)
	{
		switch (type)
		{
		case ERMarkerControlType.Spline:
			controlType = 0;
			break;
		case ERMarkerControlType.StraightXZ:
			controlType = 1;
			break;
		case ERMarkerControlType.StraightXZY:
			controlType = 2;
			break;
		case ERMarkerControlType.Circular:
			controlType = 3;
			break;
		}
		controllerType = type;
	}
}
[AddComponentMenu("")]
public class OCCQQCCDDD : MonoBehaviour
{
	public static List<Vector3> OQDDOOOOQD(ERModularRoad scr, int startMarker, int endMarker, List<ERMarkerExt> markers, float faceDist, bool ignorePrefabAlignment, ref List<float> tValues, ref List<float> markerDistances, ref List<float> bendAngles)
	{
		int num = 0;
		if (startMarker > 0)
		{
			num = scr.markersExt[startMarker].startSplinePoint;
		}
		float num2 = 0f;
		if (startMarker > 0)
		{
			num2 = scr.markersExt[startMarker].startDistance;
		}
		scr.startDir = (scr.endDir = Vector3.zero);
		scr.tmpMarkersExt.Clear();
		scr.tmpMarkersExt.AddRange(markers);
		if (scr.closedTrack && endMarker >= scr.markersExt.Count)
		{
			scr.tmpMarkersExt.Add(markers[0]);
		}
		List<Vector3> tmpNodes = new List<Vector3>();
		List<float> list = new List<float>();
		for (int i = startMarker; i <= endMarker; i++)
		{
			tmpNodes.Add(scr.tmpMarkersExt[i].position);
			if (scr.tmpMarkersExt[i].splineStrength == 0f)
			{
				scr.tmpMarkersExt[i].splineStrength = 0.5f;
			}
			list.Add(scr.tmpMarkersExt[i].splineStrength);
		}
		if (startMarker != 0)
		{
			tmpNodes.Insert(0, scr.tmpMarkersExt[startMarker - 1].position);
			list.Insert(0, scr.tmpMarkersExt[startMarker - 1].splineStrength);
		}
		else if (scr.startPrefabScript == null)
		{
			if (scr.closedTrack && scr.tmpMarkersExt[0].controlType == 0)
			{
				tmpNodes.Insert(0, scr.markersExt[markers.Count - 1].position);
				list.Insert(0, scr.markersExt[markers.Count - 1].splineStrength);
			}
			else
			{
				tmpNodes.Insert(0, tmpNodes[0]);
				list.Insert(0, list[0]);
			}
		}
		else if (!ignorePrefabAlignment && scr.startPrefabScript.crossingElements[scr.startConnectionSegment].rotationPriority)
		{
			tmpNodes.Insert(0, tmpNodes[0]);
			list.Insert(0, list[0]);
			Vector3 p = tmpNodes[2];
			if (tmpNodes.Count >= 4)
			{
				p = tmpNodes[3];
			}
			Vector3 v = ERModularRoad.OODODQQQCD(tmpNodes[0], tmpNodes[1], tmpNodes[2], p, 0.5f, 0.5f);
			scr.startPrefabScript.OOCQCCQDOQ(tmpNodes[0], v, scr.startConnectionSegment, scr);
		}
		else
		{
			Vector3 lastForward = Vector3.zero;
			OCQOQOOOCO.OQCQQDCDQO(scr, ref tmpNodes, list, scr.startPrefabScript, scr.startConnectionSegment, ref scr.startDir, ref lastForward, 0);
		}
		if (endMarker < scr.markersExt.Count - 1)
		{
			tmpNodes.Add(scr.tmpMarkersExt[endMarker + 1].position);
			list.Add(scr.tmpMarkersExt[endMarker + 1].splineStrength);
		}
		else if (scr.endPrefabScript == null)
		{
			if (scr.closedTrack && scr.tmpMarkersExt[0].controlType == 0)
			{
				if (endMarker < markers.Count)
				{
					tmpNodes.Add(scr.tmpMarkersExt[0].position);
					list.Add(scr.tmpMarkersExt[0].splineStrength);
				}
				else
				{
					tmpNodes.Add(scr.tmpMarkersExt[1].position);
					list.Add(scr.tmpMarkersExt[1].splineStrength);
				}
			}
			else if (scr.closedTrack && (scr.tmpMarkersExt[0].controlType == 1 || scr.tmpMarkersExt[0].controlType == 2))
			{
				Vector3 endCP = Vector3.zero;
				scr.OOCCQCCDQC(ref endCP, tmpNodes[tmpNodes.Count - 2], tmpNodes[tmpNodes.Count - 1], tmpNodes[2]);
				tmpNodes.Add(endCP);
				list.Add(list[list.Count - 1]);
			}
			else
			{
				tmpNodes.Add(tmpNodes[tmpNodes.Count - 1]);
				list.Add(list[list.Count - 1]);
			}
		}
		else if (!ignorePrefabAlignment && scr.endPrefabScript.crossingElements[scr.endConnectionSegment].rotationPriority)
		{
			tmpNodes.Add(tmpNodes[tmpNodes.Count - 1]);
			list.Add(list[list.Count - 1]);
			Vector3 p2 = tmpNodes[tmpNodes.Count - 3];
			if (tmpNodes.Count >= 4)
			{
				p2 = tmpNodes[tmpNodes.Count - 4];
			}
			Vector3 v2 = ERModularRoad.OODODQQQCD(p2, tmpNodes[tmpNodes.Count - 3], tmpNodes[tmpNodes.Count - 2], tmpNodes[tmpNodes.Count - 1], 0.5f, 0.5f);
			scr.endPrefabScript.OOCQCCQDOQ(tmpNodes[tmpNodes.Count - 1], v2, scr.endConnectionSegment, scr);
		}
		else
		{
			OCQOQOOOCO.OQCQQDCDQO(scr, ref tmpNodes, list, scr.endPrefabScript, scr.endConnectionSegment, ref scr.endDir, ref scr.lastForward, 1);
		}
		Vector3[] array = tmpNodes.ToArray();
		float num3 = 0f;
		Vector3 a = array[1];
		List<Vector3> splinePoints = new List<Vector3>();
		Vector3 vector = Vector3.zero;
		bool flag = false;
		scr.totalDistance = 0f;
		scr.nodeSplinePoint.Clear();
		scr.nodeSplinePoint.Add(0);
		int num4 = 0;
		Vector3 startCP = array[0];
		Vector3 endCP2 = array[3];
		Vector3 lastHeightAdjustCP = Vector3.zero;
		if (scr.tmpMarkersExt.Count > startMarker + 1 && scr.tmpMarkersExt[startMarker + 1].controlType == 3)
		{
			Vector3 normalized = (array[2] - array[1]).normalized;
			endCP2 = array[2] + normalized * Vector3.Distance(array[2], array[3]);
			endCP2.y = array[3].y;
		}
		markerDistances.Add(0f);
		List<float> tValues2 = new List<float>();
		List<Vector3> segPoints = new List<Vector3>();
		float num5 = 0f;
		scr.p3 = array[1];
		scr.p4 = array[0];
		float xzDistance = 0f;
		for (int j = 1; j < array.Length - 2; j++)
		{
			float totalDist = 0f;
			if (j > 1)
			{
				scr.markersExt[startMarker + j - 1].startSplinePoint = num + splinePoints.Count;
				scr.markersExt[startMarker + j - 1].startDistance = num2 + scr.totalDistance;
			}
			scr.segPoints.Clear();
			tValues2.Clear();
			segPoints.Clear();
			if (scr.tmpMarkersExt[startMarker + j - 1].controlType == 0)
			{
				float num6 = Vector3.Distance(array[j], array[j + 1]);
				float num7 = 0.2f / num6;
				if (num3 > 0f)
				{
					num3 -= 1f;
				}
				num3 = 0f;
				float num8 = 0.5f;
				for (float num9 = num3; num9 < 1f; num9 += num7)
				{
					flag = false;
					Vector3 vector2 = ERModularRoad.OODODQQQCD(startCP, array[j], array[j + 1], endCP2, num9, list[j]);
					if (num9 + num7 > 1f && Vector3.Distance(vector2, array[j + 1]) < 0.25f)
					{
						vector2 = array[j + 1];
						flag = true;
					}
					if (Vector3.Distance(a, vector2) > faceDist || flag || (j == 1 && num9 == 0f))
					{
						num6 = Vector3.Distance(a, vector2);
						scr.totalDistance += num6;
						totalDist += num6;
						a = vector2;
						vector = vector2;
						segPoints.Add(vector);
						tValues2.Add(num9);
						if (flag)
						{
							scr.nodeSplinePoint.Add(num4);
						}
						num4++;
					}
				}
			}
			else if (scr.tmpMarkersExt[startMarker + j - 1].controlType == 1 || scr.tmpMarkersExt[startMarker + j - 1].controlType == 2)
			{
				if (j == 1)
				{
					vector = array[j];
				}
				Vector3 normalized2 = (array[j + 1] - array[j]).normalized;
				totalDist = Vector3.Distance(array[j + 1], array[j]);
				float num6 = faceDist;
				if (j == 1)
				{
					num6 = 0f;
				}
				for (; num6 < totalDist; num6 += faceDist)
				{
					Vector3 a2 = vector + normalized2 * num6;
					if (Vector3.Distance(a2, array[j + 1]) > 0.5f * faceDist)
					{
						segPoints.Add(vector + normalized2 * num6);
						num5 = num6 / totalDist;
						tValues2.Add(num5);
					}
				}
				if (scr.tmpMarkersExt[j - 1].controlType == 1)
				{
					for (int k = 0; k < tValues2.Count; k++)
					{
						Vector3 a2 = ERModularRoad.OODODQQQCD(array[j - 1], array[j], array[j + 1], array[j + 2], tValues2[k], 0.5f);
						Vector3 value = segPoints[k];
						value.y = a2.y;
						segPoints[k] = value;
					}
				}
				num4 += segPoints.Count;
				vector = segPoints[segPoints.Count - 1];
				scr.totalDistance += totalDist;
				scr.nodeSplinePoint.Add(num4);
			}
			else if (scr.tmpMarkersExt[startMarker + j - 1].controlType == 3)
			{
				float radius = 0f;
				OCQOQOOOCO.OCOCQCDDCD(ref splinePoints, scr, j, ref segPoints, ref tValues2, ref totalDist, startMarker, ref xzDistance, getDistance: false, ref radius, ref bendAngles);
				for (int l = 0; l < tValues2.Count; l++)
				{
					Vector3 vector3 = ERModularRoad.OODODQQQCD(array[j - 1], array[j], array[j + 1], array[j + 2], tValues2[l], 0.5f);
					Vector3 value2 = segPoints[l];
					value2.y = vector3.y;
					segPoints[l] = value2;
				}
				scr.segPoints.AddRange(segPoints);
				num4 += segPoints.Count;
				vector = segPoints[segPoints.Count - 1];
				scr.totalDistance += totalDist;
				scr.nodeSplinePoint.Add(num4);
			}
			if (scr.tmpMarkersExt[startMarker + j - 1].followTerrainContours)
			{
				OCQOQOOOCO.OCDDCDDCQC(scr.baseScript, ref segPoints, tValues2, scr.terrainContoursOffset, ref lastHeightAdjustCP, scr.faceDistance, totalDist, scr.tmpMarkersExt[startMarker + j].followTerrainContours, splinePoints, ref scr.testPoints, ref scr.randomRotations);
			}
			splinePoints.AddRange(segPoints);
			tValues.AddRange(tValues2);
			scr.OCQOOCCQDD(scr.tmpMarkersExt, j, array, vector, totalDist, ref startCP, startMarker, splinePoints);
			if (array.Length > j + 3)
			{
				scr.OQDOQOCDDQ(scr.tmpMarkersExt, j, array, ref endCP2, startMarker);
			}
			markerDistances.Add(scr.totalDistance);
			if (scr.markersExt.Count > startMarker + j)
			{
				scr.markersExt[startMarker + j].direction = (splinePoints[splinePoints.Count - 1] - splinePoints[splinePoints.Count - 2]).normalized;
			}
			if (j == 1)
			{
				scr.markersExt[startMarker + j - 1].direction = (splinePoints[1] - splinePoints[0]).normalized;
			}
		}
		if (!scr.closedTrack)
		{
			scr.markersExt[endMarker].startSplinePoint = num + splinePoints.Count;
			scr.markersExt[endMarker].startDistance = num2 + scr.totalDistance;
			scr.markersExt[0].startSplinePoint = 0;
			scr.markersExt[0].startDistance = 0f;
		}
		else if (endMarker == scr.markersExt.Count - 1)
		{
			scr.markersExt[0].startSplinePoint = num + splinePoints.Count;
			scr.markersExt[0].startDistance = num2 + scr.totalDistance;
		}
		return splinePoints;
	}

	public static void OCQOQCDCQC(ERModularRoad scr, bool ignorePrefabAlignment, List<Vector3> splinePoints, List<float> tValues, List<float> markerDistances, int startMarker, int endMarker, int startInt)
	{
		scr.vecsBelowTerrain.Clear();
		if (scr.markersExt.Count < scr.controlPoints.Count)
		{
			scr.markersExt.Clear();
			for (int i = 0; i < scr.controlPoints.Count; i++)
			{
				scr.markersExt.Add(ERMarkerExt.CreateInstance(scr.controlPoints[i], scr, scr.markersExt.Count));
			}
		}
		List<float> OQQOODQCCC = new List<float>();
		List<float> randomRotations = new List<float>();
		List<float> list = scr.OQDOOOQODD(tValues, markerDistances, scr.markersExt, startMarker, endMarker + 1, ref OQQOODQCCC, randomRotations);
		List<Vector3> list2 = new List<Vector3>();
		List<Vector2> list3 = new List<Vector2>();
		List<Vector3> surfaceVecs = new List<Vector3>();
		float minIndent = scr.baseScript.minIndent;
		float minSurrounding = scr.baseScript.minSurrounding;
		UnityEngine.Debug.Log("fffffffff ");
		scr.treeVecs.Clear();
		scr.detailVecs.Clear();
		scr.vegetationTris.Clear();
		List<List<int>> list4 = new List<List<int>>();
		list4.Clear();
		for (int j = 0; j < scr.roadMaterials.Length; j++)
		{
			list4.Add(new List<int>());
		}
		int num = 0;
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 0f;
		float num7 = 5f;
		scr.roadWidth = Vector2.Distance(new Vector2(scr.roadShape[0].x, 0f), new Vector2(scr.roadShape[scr.roadShape.Count - 1].x, 0f));
		scr.nodeDistance.Clear();
		scr.nodeDistance.Add(0f);
		for (int k = 1; k < scr.roadShape.Count; k++)
		{
			scr.nodeDistance.Add(Vector2.Distance(new Vector2(scr.roadShape[0].x, 0f), new Vector2(scr.roadShape[k].x, 0f)) / scr.roadWidth);
		}
		int[] array = new int[scr.roadShape.Count];
		int[] array2 = new int[scr.roadShape.Count];
		bool[] array3 = new bool[scr.roadShape.Count];
		bool[] array4 = new bool[scr.roadShape.Count];
		bool flag = true;
		bool flag2 = false;
		bool startSurfacesSafe = false;
		Vector3 vector = Vector3.zero;
		Vector3 vector2 = Vector3.zero;
		Vector3 vector3 = Vector3.zero;
		Vector3 p = Vector3.zero;
		bool flag3 = false;
		float num8 = 0f;
		int num9 = -1;
		float num10 = 0f;
		Vector3 a = Vector3.zero;
		Vector3 vector4 = Vector3.zero;
		Vector3 vector5 = Vector3.zero;
		Vector3 p2 = Vector3.zero;
		float num11 = 0f;
		int num12 = -1;
		int endAdjustInt = 0;
		float num13 = 0f;
		float num14 = 30f;
		if (scr.totalDistance < num14)
		{
			num14 = scr.totalDistance;
		}
		if (scr.startPrefabScript != null && scr.endPrefabScript != null && scr.totalDistance * 0.5f < num14)
		{
			num14 = scr.totalDistance * 0.5f;
		}
		float num15 = num14;
		float endAdjustDistance = num14;
		if (scr.startPrefabScript != null && startMarker == 0)
		{
			QDOODOQQDQODD qDOODOQQDQODD = scr.startPrefabScript.crossingElements[scr.startConnectionSegment];
			scr.OQOQODDQCC = scr.startPrefabScript.tmpMeshVecs[qDOODOQQDQODD.connectionVecInts[qDOODOQQDQODD.connectionVecInts.Count - 1]];
			scr.OQOQODDQCC = scr.startPrefabScript.transform.TransformPoint(scr.OQOQODDQCC);
			scr.ODQCDQCCOD = scr.startPrefabScript.tmpMeshVecs[qDOODOQQDQODD.connectionVecInts[0]];
			scr.ODQCDQCCOD = scr.startPrefabScript.transform.TransformPoint(scr.ODQCDQCCOD);
			vector2 = scr.startPrefabScript.transform.TransformPoint(scr.startPrefabScript.crossingElements[scr.startConnectionSegment].leftIndentV3);
			vector3 = scr.startPrefabScript.transform.TransformPoint(scr.startPrefabScript.crossingElements[scr.startConnectionSegment].rightIndentV3);
			p = scr.startPrefabScript.transform.TransformPoint(Vector3.zero);
			num8 = scr.startPrefabScript.crossingElements[scr.startConnectionSegment].additionalIndentDistance;
			flag3 = false;
			num9 = ((scr.startbendLeftRight != -1) ? OCQOQOOOCO.OCCCDCOQCC(scr, splinePoints, scr.baseScript.minIndent, scr.roadShape[scr.roadShape.Count - 1].x, vector3, vector2, scr.startbendLeftRight) : OCQOQOOOCO.OCCCDCOQCC(scr, splinePoints, scr.baseScript.minIndent, scr.roadShape[0].x, vector3, vector2, scr.startbendLeftRight));
		}
		else
		{
			flag2 = true;
			startSurfacesSafe = true;
		}
		int num16 = 0;
		bool surfacesSafe = true;
		if (scr.endPrefabScript != null && endMarker == scr.markersExt.Count - 1)
		{
			surfacesSafe = false;
			QDOODOQQDQODD qDOODOQQDQODD2 = scr.endPrefabScript.crossingElements[scr.endConnectionSegment];
			scr.endLeft = scr.endPrefabScript.tmpMeshVecs[qDOODOQQDQODD2.connectionVecInts[0]];
			scr.endLeft = scr.endPrefabScript.transform.TransformPoint(scr.endLeft);
			scr.endRight = scr.endPrefabScript.tmpMeshVecs[qDOODOQQDQODD2.connectionVecInts[qDOODOQQDQODD2.connectionVecInts.Count - 1]];
			scr.endRight = scr.endPrefabScript.transform.TransformPoint(scr.endRight);
			num16 = Mathf.RoundToInt(Mathf.Ceil(scr.roadWidth / (scr.faceDistance * 1f)));
			vector4 = scr.endPrefabScript.transform.TransformPoint(scr.endPrefabScript.crossingElements[scr.endConnectionSegment].leftIndentV3);
			vector5 = scr.endPrefabScript.transform.TransformPoint(scr.endPrefabScript.crossingElements[scr.endConnectionSegment].rightIndentV3);
			p2 = scr.endPrefabScript.transform.TransformPoint(Vector3.zero);
			num11 = scr.endPrefabScript.crossingElements[scr.endConnectionSegment].additionalIndentDistance;
			num12 = ((scr.endbendLeftRight != -1) ? OCQOQOOOCO.OOQQDDDOQC(scr, splinePoints, scr.baseScript.minIndent, scr.roadShape[0].x, vector5, vector4, scr.endbendLeftRight, ref endAdjustInt, ref endAdjustDistance) : OCQOQOOOCO.OOQQDDDOQC(scr, splinePoints, scr.baseScript.minIndent, scr.roadShape[scr.roadShape.Count - 1].x, vector5, vector4, scr.endbendLeftRight, ref endAdjustInt, ref endAdjustDistance));
		}
		bool flag4 = false;
		if (scr.startPrefabScript != null && scr.startPrefabScript.surfaceMeshVecs.Length == 0)
		{
			flag4 = true;
		}
		bool flag5 = false;
		if (scr.endPrefabScript != null && scr.endPrefabScript.surfaceMeshVecs.Length == 0)
		{
			flag5 = true;
		}
		Vector3 zero = Vector3.zero;
		int num17 = 0;
		bool item = false;
		List<bool> list5 = new List<bool>();
		Vector3 zero2 = Vector3.zero;
		Vector3 zero3 = Vector3.zero;
		for (int l = 0; l < splinePoints.Count; l++)
		{
			if (splinePoints[l] == scr.markersExt[num17 + 1].position)
			{
				item = scr.markersExt[num17 + 1].bridgeObject;
				if (scr.markersExt.Count > num17 + 1)
				{
					num17++;
				}
			}
			list5.Add(item);
			if (l > 0)
			{
				num3 = Vector3.Distance(splinePoints[l - 1], splinePoints[l]);
				num2 += num3;
			}
			num6 = num2 / num7;
			Vector3 vector6 = ((l == 0) ? (splinePoints[l + 1] - splinePoints[l]).normalized : ((l != splinePoints.Count - 1) ? (splinePoints[l + 1] - splinePoints[l - 1]).normalized : (splinePoints[l] - splinePoints[l - 1]).normalized));
			if (l == 0)
			{
				zero2 = vector6;
			}
			zero3 = vector6;
			zero = OCQOQOOOCO.GetEulerAngles(vector6);
			vector6 = new Vector3(0f - vector6.z, 0f, vector6.x);
			if (!flag2 && l < splinePoints.Count - 2)
			{
				vector = (splinePoints[l + 1] - splinePoints[l]).normalized;
				vector = new Vector3(0f - vector.z, 0f, vector.x);
			}
			int count = scr.roadShape.Count;
			Vector3 vector8;
			Vector3 vector7 = (vector8 = Vector3.zero);
			Vector3 vector9;
			for (int m = 0; m < scr.roadShape.Count; m++)
			{
				vector9 = ((list[l] == 0f) ? (splinePoints[l] + vector6 * scr.roadShape[m].x) : OCQOQOOOCO.OQOCQCOCQQ(splinePoints[l], scr.roadShape[m], 180f - list[l], zero));
				if (startMarker == 0 && scr.startPrefabScript != null && l < num9 && !flag4)
				{
					vector9.y = ODQDQDQDQO.OQDDCCCOQD(vector2, vector3, p, vector9);
					num10 = num2;
				}
				else if (startMarker == 0 && scr.startPrefabScript != null && num2 - num10 < num15 - num10 && !flag4)
				{
					Vector3 p3 = vector9;
					p3.y = ODQDQDQDQO.OQDDCCCOQD(vector2, vector3, p, p3);
					float t = (num2 - num10) / (num15 - num10);
					vector9.y = Mathf.Lerp(p3.y, vector9.y, Mathf.SmoothStep(0f, 1f, t));
				}
				if (endMarker == scr.markersExt.Count - 1 && scr.endPrefabScript != null && l > num12 && !flag5)
				{
					vector9.y = ODQDQDQDQO.OQDDCCCOQD(vector4, vector5, p2, vector9);
				}
				else if (endMarker == scr.markersExt.Count - 1 && scr.endPrefabScript != null && l >= endAdjustInt && !flag5)
				{
					if (m == 0)
					{
						num4 += num3;
					}
					Vector3 p4 = vector9;
					p4.y = ODQDQDQDQO.OQDDCCCOQD(vector4, vector5, p2, p4);
					float t = num4 / endAdjustDistance;
					vector9.y = Mathf.Lerp(vector9.y, p4.y, Mathf.SmoothStep(0f, 1f, t));
				}
				if (m == 0)
				{
					vector7 = vector9;
					vector7.y -= 0.05f;
				}
				if (m == scr.roadShape.Count - 1)
				{
					vector8 = vector9;
					vector8.y -= scr.roadShape[m].y;
				}
				vector8 = vector9;
				vector8.y -= 0.05f;
				if (list[l] == 0f)
				{
					vector9.y += scr.roadShape[m].y;
				}
				list2.Add(vector9);
				list3.Add(new Vector2(scr.roadShapeUVs[m], num6));
				if (l < splinePoints.Count - 1 && m < scr.roadShape.Count - 1)
				{
					flag = true;
					if (!flag2)
					{
						flag = false;
						if (!array3[m] || !array3[m + 1])
						{
							if (l == 0)
							{
								array[m] = -1;
								array[m + 1] = -1;
							}
							if (!array3[m])
							{
								Vector3 pCheck = splinePoints[l + 1] + vector * scr.roadShape[m].x;
								if (ERCrossingPrefabs.OQCDCDOOCD(scr.OQOQODDQCC, scr.ODQCDQCCOD, pCheck))
								{
									array3[m] = true;
								}
							}
							if (!array3[m + 1])
							{
								Vector3 pCheck = splinePoints[l + 1] + vector * scr.roadShape[m + 1].x;
								if (ERCrossingPrefabs.OQCDCDOOCD(scr.OQOQODDQCC, scr.ODQCDQCCOD, pCheck))
								{
									array3[m + 1] = true;
								}
							}
							if (array3[m] && array3[m + 1])
							{
								flag = true;
								if (array[m] == -1)
								{
									array[m] = l;
								}
								if (array[m + 1] == -1)
								{
									array[m + 1] = l;
								}
							}
						}
						flag = true;
					}
					if (scr.endPrefabScript != null && l > splinePoints.Count - num16)
					{
						flag = true;
						Vector3 pCheck = splinePoints[l] + vector6 * scr.roadShape[m].x;
						if (ERCrossingPrefabs.OQCDCDOOCD(scr.endRight, scr.endLeft, pCheck))
						{
							pCheck = splinePoints[l] + vector6 * scr.roadShape[m + 1].x;
							if (ERCrossingPrefabs.OQCDCDOOCD(scr.endRight, scr.endLeft, pCheck))
							{
								flag = true;
							}
						}
					}
					num = scr.roadShapeMaterialInts[m];
					if (flag)
					{
						list4[num].Add(l * count + m);
						list4[num].Add((l + 1) * count + m + 1);
						list4[num].Add(l * count + m + 1);
						list4[num].Add((l + 1) * count + m);
						list4[num].Add((l + 1) * count + m + 1);
						list4[num].Add(l * count + m);
					}
				}
				if (flag2)
				{
					continue;
				}
				flag2 = true;
				for (int n = 0; n < array3.Length; n++)
				{
					if (!array3[n])
					{
						flag2 = false;
					}
				}
			}
			if (startMarker == 0 && scr.startPrefabScript != null && num5 < num8 * 6f)
			{
				if (scr.startbendLeftRight == -1)
				{
					if (l > 0)
					{
						num5 += Vector3.Distance(a, vector7);
					}
					a = vector7;
				}
				else
				{
					if (l > 0)
					{
						num5 += Vector3.Distance(a, vector8);
					}
					a = vector8;
				}
			}
			Vector3 normalized = (vector7 - vector8).normalized;
			vector9 = vector7 + normalized * (minIndent + minSurrounding);
			scr.baseScript.OCDDQOCDCO(ref vector9);
			surfaceVecs.Add(vector9);
			vector9 = vector7 + normalized * minIndent;
			surfaceVecs.Add(vector9);
			vector9 = vector8 + -normalized * minIndent;
			surfaceVecs.Add(vector9);
			vector9 = vector8 + -normalized * (minIndent + minSurrounding);
			scr.baseScript.OCDDQOCDCO(ref vector9);
			surfaceVecs.Add(vector9);
			if (!startSurfacesSafe && !flag4)
			{
				if (l == 0)
				{
					surfaceVecs[3] = scr.startPrefabScript.transform.TransformPoint(scr.startPrefabScript.crossingElements[scr.startConnectionSegment].leftSurroundingV3);
					surfaceVecs[0] = scr.startPrefabScript.transform.TransformPoint(scr.startPrefabScript.crossingElements[scr.startConnectionSegment].rightSurroundingV3);
					surfaceVecs[2] = scr.startPrefabScript.transform.TransformPoint(scr.startPrefabScript.crossingElements[scr.startConnectionSegment].leftIndentV3);
					surfaceVecs[1] = scr.startPrefabScript.transform.TransformPoint(scr.startPrefabScript.crossingElements[scr.startConnectionSegment].rightIndentV3);
				}
				else
				{
					OCQOQOOOCO.OODCOQOQOD(scr, ref surfaceVecs, scr.startPrefabScript, ref startSurfacesSafe, num2, scr.baseScript.minIndent);
				}
			}
			if (l == 0)
			{
				scr.sv1 = vector7;
				scr.sv2 = vector8;
				scr.sv1 = vector7 + vector6 * minIndent;
				scr.sv2 = vector8 + -vector6 * minIndent;
			}
		}
		Vector2[] array5 = list3.ToArray();
		float num18 = 1f / list3[list3.Count - 1].y * Mathf.Floor(list3[list3.Count - 1].y);
		for (int num19 = 0; num19 < array5.Length - 1; num19 += scr.roadShape.Count)
		{
			for (int num20 = 0; num20 < scr.roadShape.Count; num20++)
			{
				if (num20 == 0)
				{
					array5[num19 + num20].y = array5[num19].y * num18;
				}
				else
				{
					array5[num19 + num20].y = array5[num19].y;
				}
			}
		}
		if (startMarker == 0 && scr.startPrefabScript != null)
		{
			if (scr.startPrefabScript.meshVecs.Length == 0)
			{
			}
			int num21 = list2.Count - 1;
			int count2 = scr.roadShape.Count;
			bool flag6 = false;
			if (ERCrossingPrefabs.OQCDCDOOCD(list2[count2], list2[0], list2[count2 * 2]))
			{
				flag6 = true;
			}
			List<int> connectionVecInts = scr.startPrefabScript.crossingElements[scr.startConnectionSegment].connectionVecInts;
			for (int num22 = 0; num22 < scr.roadShape.Count; num22++)
			{
				if (num22 + array[num22] * scr.roadShape.Count < 0)
				{
					UnityEngine.Debug.LogError("The angle with the crossing is too small");
					break;
				}
				list2[num22 + array[num22] * scr.roadShape.Count] = scr.startPrefabScript.transform.TransformPoint(scr.startPrefabScript.tmpMeshVecs[connectionVecInts[scr.roadShape.Count - num22 - 1]]);
				if (scr.startPrefabScript.crossingElements[scr.startConnectionSegment].rotationPriority)
				{
					continue;
				}
				float num23 = scr.roadWidth / Mathf.Tan(scr.startAngle * ((float)Math.PI / 180f));
				float num24 = (flag6 ? (10f + (1f - scr.nodeDistance[num22]) * num23 * 2f) : (10f + scr.nodeDistance[num22] * num23 * 2f));
				float num25 = 0f;
				int num26 = 1;
				Vector3 a2;
				Vector3 vector10 = (a2 = list2[num22 + array[num22] * scr.roadShape.Count]);
				while (num25 < num24)
				{
					Vector3 vector11 = list2[num22 + (array[num22] + num26) * scr.roadShape.Count];
					num25 += Vector3.Distance(a2, vector11);
					Vector3 normalized2 = (vector11 - vector10).normalized;
					Vector3 vector12 = Vector3.Lerp(-scr.startDir, normalized2, num25 / num24);
					Vector3 a3 = vector10 + vector12 * num25;
					list2[num22 + (array[num22] + num26) * scr.roadShape.Count] = Vector3.Lerp(a3, vector11, Mathf.SmoothStep(0f, 1f, num25 / num24));
					a2 = vector11;
					num26++;
					if (num22 + (array[num22] + num26) * scr.roadShape.Count > list2.Count - 1)
					{
						break;
					}
				}
			}
		}
		if (endMarker == scr.markersExt.Count - 1 && scr.endPrefabScript != null)
		{
			if (scr.endPrefabScript.meshVecs.Length == 0)
			{
				scr.endPrefabScript.OCOODQQDQO();
			}
			int num27 = list2.Count - 1;
			int count3 = scr.roadShape.Count;
			bool flag7 = false;
			if (ERCrossingPrefabs.OQCDCDOOCD(list2[num27], list2[num27 - count3], list2[num27 - count3 * 2]))
			{
				flag7 = true;
			}
			int num28 = list2.Count - scr.roadShape.Count;
			List<int> connectionVecInts2 = scr.endPrefabScript.crossingElements[scr.endConnectionSegment].connectionVecInts;
			for (int num29 = 0; num29 < scr.roadShape.Count; num29++)
			{
				list2[num28 + num29] = scr.endPrefabScript.transform.TransformPoint(scr.endPrefabScript.tmpMeshVecs[connectionVecInts2[num29]]);
				if (scr.endPrefabScript.crossingElements[scr.endConnectionSegment].rotationPriority)
				{
					continue;
				}
				float num30 = scr.roadWidth / Mathf.Tan(scr.endAngle * ((float)Math.PI / 180f));
				float num31 = (flag7 ? (10f + (1f - scr.nodeDistance[num29]) * num30 * 2f) : (3f + scr.nodeDistance[num29] * num30 * 2f));
				float num32 = 0f;
				int num33 = 0;
				Vector3 a4;
				Vector3 vector13 = (a4 = list2[num28 + num29 - num33 * scr.roadShape.Count]);
				num33 = 1;
				while (num32 < num31 && num28 + num29 - num33 * scr.roadShape.Count >= 0)
				{
					Vector3 vector14 = list2[num28 + num29 - num33 * scr.roadShape.Count];
					num32 += Vector3.Distance(a4, vector14);
					Vector3 normalized3 = (vector14 - vector13).normalized;
					Vector3 vector15 = Vector3.Lerp(-scr.endDir, normalized3, num32 / num31);
					Vector3 a5 = vector13 + vector15 * num32;
					list2[num28 + num29 - num33 * scr.roadShape.Count] = Vector3.Lerp(a5, vector14, Mathf.SmoothStep(0f, 1f, num32 / num31));
					a4 = vector14;
					num33++;
					if (num28 + num29 - num33 * scr.roadShape.Count > list2.Count - 1)
					{
						break;
					}
				}
			}
		}
		if (scr.closedTrack)
		{
			for (int num34 = 0; num34 < scr.roadShape.Count; num34++)
			{
				list2[list2.Count - scr.roadShape.Count + num34] = list2[num34];
			}
		}
		scr.meshVecs.InsertRange(startInt * scr.roadShape.Count, list2);
		scr.meshUVs.InsertRange(startInt * scr.roadShape.Count, new List<Vector2>(array5));
		for (int num35 = 0; num35 < scr.tris.Count; num35++)
		{
			scr.tris[num35].InsertRange(startInt * scr.roadShapeMaterialIntCounts[num35] * 3, list4[num35]);
		}
		UnityEngine.Debug.LogError("we have to update existing triangle int values after the affected area!");
		OCQOQCDCQC(scr);
		num2 = 0f;
		if ((bool)scr.endPrefabScript && !flag5)
		{
			for (int num36 = 0; (!surfacesSafe || num36 < surfaceVecs.Count - 4) && surfaceVecs.Count - num36 - 6 >= 0; num36 += 4)
			{
				if (!surfacesSafe)
				{
					OCQOQOOOCO.ODOCCQDCQO(scr, ref surfaceVecs, scr.endPrefabScript, num36, ref surfacesSafe, num2, scr.baseScript.minIndent);
				}
				num2 += Vector3.Distance(surfaceVecs[surfaceVecs.Count - 2 - num36], surfaceVecs[surfaceVecs.Count - 2 - num36 - 4]);
			}
		}
		if (scr.closedTrack)
		{
			surfaceVecs[surfaceVecs.Count - 4] = surfaceVecs[0];
			surfaceVecs[surfaceVecs.Count - 3] = surfaceVecs[1];
			surfaceVecs[surfaceVecs.Count - 2] = surfaceVecs[2];
			surfaceVecs[surfaceVecs.Count - 1] = surfaceVecs[3];
			UnityEngine.Debug.LogError("adjust the above: add surface vecs first to full surface array. Then make sure start and end vecs are the same");
		}
	}

	public static void OCQOQCDCQC(ERModularRoad scr)
	{
		if (scr.gameObject.GetComponent<MeshFilter>() == null)
		{
			scr.gameObject.AddComponent<MeshFilter>();
		}
		if (scr.gameObject.GetComponent<MeshRenderer>() == null)
		{
			scr.gameObject.AddComponent<MeshRenderer>();
		}
		if (scr.gameObject.GetComponent<MeshCollider>() == null)
		{
			scr.gameObject.AddComponent<MeshCollider>();
		}
		Mesh mesh;
		if (scr.gameObject.GetComponent<MeshFilter>().sharedMesh != null)
		{
			mesh = scr.gameObject.GetComponent<MeshFilter>().sharedMesh;
		}
		else
		{
			mesh = new Mesh();
			scr.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
		}
		scr.gameObject.isStatic = true;
		mesh.Clear();
		mesh.vertices = scr.meshVecs.ToArray();
		mesh.uv = scr.meshUVs.ToArray();
		mesh.tangents = new Vector4[scr.meshVecs.Count];
		mesh.subMeshCount = scr.tris.Count;
		for (int i = 0; i < scr.tris.Count; i++)
		{
			mesh.SetTriangles(scr.tris[i].ToArray(), i);
		}
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();
		scr.gameObject.GetComponent<MeshCollider>().sharedMesh = null;
		scr.gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
		scr.testmesh = mesh;
	}

	public static ERModularRoad DuplicateObject(ERModularRoad scr)
	{
		if (scr == null)
		{
			return null;
		}
		GameObject gameObject = UnityEngine.Object.Instantiate(scr.gameObject);
		gameObject.transform.parent = scr.transform.parent;
		List<GameObject> list = new List<GameObject>();
		foreach (Transform item in gameObject.transform)
		{
			list.Add(item.gameObject);
		}
		foreach (GameObject item2 in list)
		{
			UnityEngine.Object.DestroyImmediate(item2);
		}
		if ((bool)gameObject.GetComponent<MeshFilter>())
		{
			gameObject.GetComponent<MeshFilter>().sharedMesh = null;
		}
		if ((bool)gameObject.GetComponent<MeshCollider>())
		{
			gameObject.GetComponent<MeshCollider>().sharedMesh = null;
		}
		ERModularRoad component = gameObject.GetComponent<ERModularRoad>();
		component.road = null;
		component.soDataExt.Clear();
		foreach (ERSORoadExt item3 in scr.soDataExt)
		{
			component.soDataExt.Add(UnityEngine.Object.Instantiate(item3));
		}
		component.markersExt.Clear();
		for (int i = 0; i < scr.markersExt.Count; i++)
		{
			component.markersExt.Add(OCQOQOOOCO.DuplicateMarker(scr.markersExt[i]));
		}
		string text = (gameObject.name = scr.name + "[Duplicate]");
		component.name = text;
		component.OCQOQCDCQC(ignorePrefabAlignment: false, forceAutoRotate: false);
		return component;
	}

	public static GameObject ODOCOCQODQ(ERModularRoad scr, Transform parent, Vector3 p1, Vector3 p2, float x1, float x2, float height, Vector3 heighthmapscale)
	{
		float num = Mathf.Abs(p1.x - p2.x);
		float num2 = Mathf.Abs(p1.z - p2.z);
		float num3;
		float num4;
		if (num > num2)
		{
			float z = heighthmapscale.z;
			num3 = heighthmapscale.x;
			num4 = num2 / num;
		}
		else
		{
			float z = heighthmapscale.x;
			num3 = heighthmapscale.z;
			num4 = num / num2;
		}
		float num5 = ODQDQDQDQO.OQQOQODCCC(scr.baseScript.activeTerrain, p1, p2);
		float num6 = 1f + num4 * 0.5f;
		x1 -= num5;
		x2 += num5;
		Vector3 normalized = (p2 - p1).normalized;
		Vector3 normalized2 = new Vector3(normalized.z, 0f, 0f - normalized.x).normalized;
		float num7 = x2 - x1;
		float f = num7 / num3;
		f = Mathf.Ceil(f);
		float num8 = num7 / f;
		f += 1f;
		Vector3 vector = p1 + normalized2 * x1;
		vector.y += height;
		int num9 = Mathf.RoundToInt(f);
		List<Vector3> list = new List<Vector3>();
		List<int> list2 = new List<int>();
		Vector3 vector2 = Vector3.zero;
		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; (float)j < f; j++)
			{
				Vector3 pos = vector + normalized2 * j * num8;
				if (i == 2)
				{
					Vector3 vector3 = pos;
					scr.baseScript.OCDDQOCDCO(ref pos);
					if (pos.y < vector3.y)
					{
						pos.y = vector3.y;
						pos = ODQDQDQDQO.ODCCDOCDQD(pos, normalized);
					}
					else
					{
						pos = vector2 + normalized2 * j * num8;
						scr.baseScript.OCDDQOCDCO(ref pos);
						if (pos.y < vector3.y)
						{
							pos = vector3;
						}
					}
				}
				list.Add(pos);
			}
			if (i < 2)
			{
				for (int k = 0; k < num9 - 1; k++)
				{
					list2.Add(i * num9 + k);
					list2.Add((i + 1) * num9 + k + 1);
					list2.Add(i * num9 + k + 1);
					list2.Add((i + 1) * num9 + k);
					list2.Add((i + 1) * num9 + k + 1);
					list2.Add(i * num9 + k);
				}
			}
			vector2 = vector;
			float num10 = 2f;
			if ((double)num5 > 1.75)
			{
				num10 = 1f;
			}
			if (i < 1)
			{
				vector += normalized * num5 * num10;
			}
			else
			{
				vector += normalized * num5 * 1f;
			}
		}
		GameObject gameObject = new GameObject("TunnelDeform");
		gameObject.AddComponent<MeshFilter>();
		gameObject.AddComponent<MeshRenderer>();
		gameObject.AddComponent<MeshCollider>();
		gameObject.AddComponent<ERSurfaceScript>();
		gameObject.layer = scr.baseScript.sLayer;
		gameObject.transform.parent = parent;
		gameObject.transform.position = Vector3.zero;
		gameObject.hideFlags = HideFlags.HideInHierarchy;
		Mesh mesh = new Mesh();
		mesh.vertices = list.ToArray();
		mesh.triangles = list2.ToArray();
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();
		gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
		gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
		gameObject.GetComponent<MeshRenderer>().enabled = false;
		gameObject.GetComponent<MeshCollider>().enabled = false;
		return gameObject;
	}

	public static void CreateSplatMeshes(ERModularRoad scr, ref List<GameObject> soSplatmapObjects, float splatSize)
	{
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		List<int> list3 = new List<int>();
		Vector3 zero = Vector3.zero;
		float splatOpacity = scr.splatOpacity;
		bool flag = false;
		int num = -1;
		int num2 = -1;
		int num3 = scr.exitRoads.Count - 1;
		int num4 = 0;
		if (scr.exitRoads.Count > 0)
		{
			num2 = scr.exitRoads[0].startSplineIndex;
			num = scr.exitRoads[0].endSplineIndex;
			flag = true;
		}
		int num5 = 0;
		Vector3 zero2 = Vector3.zero;
		if (scr.soSplinePoints.Count > scr.bridgeElement.Count)
		{
			for (int i = scr.bridgeElement.Count - 1; i < scr.soSplinePoints.Count; i++)
			{
				scr.bridgeElement.Add(item: false);
			}
		}
		float num6 = 0f;
		for (int j = 0; j < scr.soSplinePoints.Count; j++)
		{
			Vector3 vector = scr.soSplinePointsLeft[j] - scr.soSplinePointsRight[j];
			vector = new Vector3(vector.x, 0f, vector.z).normalized;
			zero2 = scr.soSplinePointsRight[j];
			if (j > 1)
			{
				num6 += Vector3.Distance(zero2, scr.soSplinePointsRight[j - 1]);
			}
			if (flag && j >= num2)
			{
				zero2 = scr.exitRoads[num4].soPointsRightStart[j - num2];
				if (j == num)
				{
					num4++;
					if (scr.exitRoads.Count > num4)
					{
						num2 = scr.exitRoads[num4].startSplineIndex;
						num = scr.exitRoads[num4].endSplineIndex;
					}
					else
					{
						flag = false;
					}
				}
			}
			zero = scr.soSplinePointsLeft[j] + vector * splatSize * (scr.smoothLevel + scr.expandLevel);
			zero.y = 0f;
			list.Add(zero);
			list2.Add(new Vector2(0f, num6 + 10f));
			zero = scr.soSplinePointsLeft[j] + vector * splatSize * scr.expandLevel;
			zero.y = 0f;
			list.Add(zero);
			list2.Add(new Vector2(splatOpacity, num6 + 10f));
			zero = zero2 - vector * splatSize * scr.expandLevel;
			zero.y = 0f;
			list.Add(zero);
			list2.Add(new Vector2(splatOpacity, num6));
			zero = zero2 - vector * splatSize * (scr.smoothLevel + scr.expandLevel);
			zero.y = 0f;
			list.Add(zero);
			list2.Add(new Vector2(0f, num6));
			if (j == 0 && !scr.closedTrack)
			{
				float num7 = splatSize * (float)(scr.smoothLevel + scr.expandLevel);
				if (scr.startPrefabScript != null)
				{
					num7 = Vector3.Distance(scr.soSplinePoints[0], scr.startPrefabScript.transform.position);
				}
				else
				{
					Vector2 value = (list2[2] = new Vector2(0f, 0f));
					list2[1] = value;
				}
				vector = (scr.soSplinePoints[0] - scr.soSplinePoints[1]).normalized;
				list[0] += vector * num7;
				list[1] += vector * num7;
				list[2] += vector * num7;
				list[3] += vector * num7;
			}
			else if (j == scr.soSplinePoints.Count - 1 && !scr.closedTrack)
			{
				float num8 = splatSize * (float)(scr.smoothLevel + scr.expandLevel);
				if (scr.endPrefabScript != null)
				{
					num8 = Vector3.Distance(scr.soSplinePoints[j], scr.endPrefabScript.transform.position);
				}
				else
				{
					int index = list2.Count - 3;
					Vector2 value = (list2[list2.Count - 2] = new Vector2(0f, 0f));
					list2[index] = value;
				}
				vector = (scr.soSplinePoints[j] - scr.soSplinePoints[j - 1]).normalized;
				list[list.Count - 4] += vector * num8;
				list[list.Count - 3] += vector * num8;
				list[list.Count - 2] += vector * num8;
				list[list.Count - 1] += vector * num8;
			}
			if (j < scr.soSplinePoints.Count - 1 && !scr.bridgeElement[j])
			{
				int num9 = 4;
				for (int k = 0; k < num9 - 1; k++)
				{
					list3.Add(j * num9 + k);
					list3.Add((j + 1) * num9 + k + 1);
					list3.Add(j * num9 + k + 1);
					list3.Add((j + 1) * num9 + k);
					list3.Add((j + 1) * num9 + k + 1);
					list3.Add(j * num9 + k);
				}
			}
		}
		if (scr.exitRoads.Count > 0)
		{
			for (int l = 0; l < scr.exitRoads.Count; l++)
			{
				int count = list.Count;
				for (int m = 0; m < scr.exitRoads[l].soPointsLeftStart.Count; m++)
				{
					Vector3 vector = scr.exitRoads[l].soPointsLeftStart[m] - scr.exitRoads[l].soPointsRightStart[m + scr.exitRoads[l].soRightSplitEndIndex];
					vector = new Vector3(vector.x, 0f, vector.z).normalized;
					zero = scr.exitRoads[l].soPointsLeftStart[m] + vector * splatSize * (scr.smoothLevel + scr.expandLevel);
					zero.y = 0f;
					list.Add(zero);
					list2.Add(new Vector2(0f, 0f));
					zero = scr.exitRoads[l].soPointsLeftStart[m] + vector * splatSize * scr.expandLevel;
					zero.y = 0f;
					list.Add(zero);
					list2.Add(new Vector2(splatOpacity, splatOpacity));
					zero = scr.exitRoads[l].soPointsRightStart[m + scr.exitRoads[l].soRightSplitEndIndex] - vector * splatSize * scr.expandLevel;
					zero.y = 0f;
					list.Add(zero);
					list2.Add(new Vector2(splatOpacity, splatOpacity));
					zero = scr.exitRoads[l].soPointsRightStart[m + scr.exitRoads[l].soRightSplitEndIndex] - vector * splatSize * (scr.smoothLevel + scr.expandLevel);
					zero.y = 0f;
					list.Add(zero);
					list2.Add(new Vector2(0f, 0f));
					if (m < scr.exitRoads[l].soPointsLeftStart.Count - 1)
					{
						int num10 = 4;
						for (int n = 0; n < num10 - 1; n++)
						{
							list3.Add(count + m * num10 + n);
							list3.Add(count + (m + 1) * num10 + n + 1);
							list3.Add(count + m * num10 + n + 1);
							list3.Add(count + (m + 1) * num10 + n);
							list3.Add(count + (m + 1) * num10 + n + 1);
							list3.Add(count + m * num10 + n);
						}
					}
				}
			}
		}
		string text = "color" + (scr.splatIndex + 1) + "_" + splatOpacity;
		soSplatmapObjects.Add(BuildSplatMesh(scr, list, list2, list3, text, -15));
	}

	public static GameObject BuildSplatMesh(ERModularRoad scr, List<Vector3> vecs, List<Vector2> uvs, List<int> tris, string name, int pos)
	{
		GameObject gameObject = new GameObject("SplatGO" + name);
		gameObject.AddComponent<MeshFilter>();
		gameObject.AddComponent<MeshRenderer>();
		gameObject.AddComponent<MeshCollider>();
		gameObject.transform.parent = scr.transform;
		Vector3 zero = Vector3.zero;
		gameObject.transform.position = zero;
		Mesh mesh = new Mesh();
		mesh.name = scr.gameObject.name + "_splat";
		gameObject.layer = scr.baseScript.sLayer;
		mesh.vertices = vecs.ToArray();
		if (uvs == null)
		{
			mesh.uv = new Vector2[vecs.Count];
		}
		else
		{
			mesh.uv = uvs.ToArray();
		}
		mesh.tangents = new Vector4[vecs.Count];
		mesh.triangles = tris.ToArray();
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();
		gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
		gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
		gameObject.GetComponent<MeshCollider>().enabled = false;
		return gameObject;
	}

	public static void SetMarkerIndentAlignment(ERMarkerExt m, ERModularRoad scr)
	{
		if (!(m == null) && !(scr.baseScript == null))
		{
			Vector3 direction = m.direction;
			Vector3 position = m.position;
			Vector3 normalized = new Vector3(direction.z, 0f, 0f - direction.x).normalized;
			Vector3 pos = position + normalized * -2f;
			Vector3 pos2 = position + normalized * 2f;
			scr.baseScript.OCDDQOCDCO(ref pos);
			scr.baseScript.OCDDQOCDCO(ref pos2);
			if (pos.y < pos2.y)
			{
				m.leftIndentAlignment = 1;
				m.rightIndentAlignment = 0;
			}
			else
			{
				m.leftIndentAlignment = 0;
				m.rightIndentAlignment = 1;
			}
		}
	}

	public static float GetleftToCenterPerc(List<Vector2> nodeList, int left, int right)
	{
		float num = nodeList[right].x - nodeList[left].x;
		return nodeList[left].x * -1f / num;
	}

	public static void OQCDDDDOOQ(ERModularRoad r1, ERModularRoad r2, ERCrossingPrefabs prefab)
	{
		if (prefab.isIConnector)
		{
			ERIConnector component = prefab.gameObject.GetComponent<ERIConnector>();
			if ((!(component.connectorLength1 > 0f) || !(component.connectorLength2 > 0f)) && !(component.connectorLength1 > 0f) && !(component.connectorLength2 > 0f) && !(r1.roadShapeString == r2.roadShapeString) && !(r1.roadShapeString == r2.roadShapeReversedString) && !(r1.roadShapeReversedString == r2.roadShapeString))
			{
			}
		}
	}

	public static void ODOOODOOOQ(ERModularRoad r1, ERModularRoad r2, int road1StartEnd, int road2StartEnd)
	{
	}

	public static void AverageTangentsRoadPrefab(ERModularRoad r1, ERCrossingPrefabs prefab, int road1StartEnd, int prefabStartEnd)
	{
	}
}
[AddComponentMenu("")]
public class ERPrefab : MonoBehaviour
{
	public bool isRoadType;

	public bool isSidewalk;
}
[AddComponentMenu("")]
public class ERPrefabInstance : MonoBehaviour
{
	public SideObject so;

	public GameObject prefab;

	public ERSORoadExt soData;

	public double id;

	public ERModularRoad roadScript;

	public bool buildFlag;

	public bool locked = false;

	public bool child = false;

	public int sectionIndex = -1;

	public void Copy(ERPrefabInstance source)
	{
		if (source != null)
		{
			so = source.so;
			prefab = source.prefab;
			soData = source.soData;
			roadScript = source.roadScript;
			buildFlag = source.buildFlag;
			locked = source.locked;
			child = source.child;
			sectionIndex = source.sectionIndex;
		}
	}
}
public class ERMath
{
	public static Vector3 GetPosition(Vector3[] points, Vector3 position, ref float distance, ref int currentIndex, ref float t)
	{
		if (points == null)
		{
			return Vector3.zero;
		}
		if (currentIndex >= points.Length - 1)
		{
			return position;
		}
		Vector3 a = Vector3.Lerp(points[currentIndex], points[currentIndex + 1], t);
		bool flag = false;
		int num3;
		while (true)
		{
			float num = Vector3.Distance(a, points[currentIndex + 1]);
			if (num > distance)
			{
				float num2 = Vector3.Distance(points[currentIndex], points[currentIndex + 1]);
				t += distance / num2;
				num3 = currentIndex - 1;
				if (num3 < 0)
				{
					num3 = 0;
				}
				break;
			}
			distance -= num;
			t = 0f;
			if (currentIndex + 1 < points.Length - 1)
			{
				distance -= num;
				currentIndex++;
				a = points[currentIndex];
				continue;
			}
			return position;
		}
		int num4 = currentIndex + 2;
		if (num4 >= points.Length)
		{
			num4 = currentIndex + 1;
		}
		return ERModularRoad.OODODQQQCD(points[num3], points[currentIndex], points[currentIndex + 1], points[num4], t, 0.5f);
	}
}
public class ERRoadNetworkObject : MonoBehaviour
{
}
[AddComponentMenu("")]
public class ERRoundaboutsFunctions : MonoBehaviour
{
	public static void ODCCQQODCO(ERRoundabouts scr, int currentIndex)
	{
		float num = scr.prefabScript.sidewalkControlElements[currentIndex].sidewalkWidth1;
		float sidewalkWidth = scr.prefabScript.sidewalkControlElements[currentIndex].sidewalkWidth1;
		sidewalkWidth = ((currentIndex >= scr.connections.Count - 1) ? scr.prefabScript.sidewalkControlElements[0].sidewalkWidth1 : scr.prefabScript.sidewalkControlElements[currentIndex + 1].sidewalkWidth1);
		if (num < sidewalkWidth)
		{
			num = sidewalkWidth;
		}
		float num2 = Vector3.Distance(Vector3.zero, scr.connections[currentIndex].leftOuterSegments[scr.connections[currentIndex].leftOuterSegments.Count - 1]);
		float num3 = scr.roundAboutRadius + 0.5f * scr.roundaboutWidth;
		num2 -= num3;
		Vector3 normalized = (scr.connections[currentIndex].leftOuterSegments[scr.connections[currentIndex].leftOuterSegments.Count - 1] - scr.connections[currentIndex].leftOuterSegments[scr.connections[currentIndex].leftOuterSegments.Count - 2]).normalized;
		while (num > num2)
		{
			scr.connections[currentIndex].leftOuterSegments.Add(scr.connections[currentIndex].leftOuterSegments[scr.connections[currentIndex].leftOuterSegments.Count - 1] + normalized * scr.roundAboutResolution);
			scr.connections[currentIndex].rightOuterSegments.Add(scr.connections[currentIndex].rightOuterSegments[scr.connections[currentIndex].rightOuterSegments.Count - 1] + normalized * scr.roundAboutResolution);
			scr.connections[currentIndex].leftInnerSegments.Add(scr.connections[currentIndex].leftInnerSegments[scr.connections[currentIndex].leftInnerSegments.Count - 1] + normalized * scr.roundAboutResolution);
			scr.connections[currentIndex].rightInnerSegments.Add(scr.connections[currentIndex].rightInnerSegments[scr.connections[currentIndex].rightInnerSegments.Count - 1] + normalized * scr.roundAboutResolution);
			num2 = Vector3.Distance(Vector3.zero, scr.connections[currentIndex].leftOuterSegments[scr.connections[currentIndex].leftOuterSegments.Count - 1]);
			num2 -= num3;
		}
	}

	public static void OQQDDDCCDO(ERRoundabouts scr, int currentIndex)
	{
		OOCCDQCCOQ(scr, currentIndex);
		OOOQCOQOOQ(scr, scr.connections[currentIndex].rightSidewalkV3, null, scr.prefabScript.sidewalkControlElements[currentIndex], 0, 1, -1);
		scr.prefabScript.sidewalkControlElements[currentIndex].rightHandleV3 = scr.connections[currentIndex].rightSidewalkV3[scr.connections[currentIndex].rightSidewalkV3.Count - 1][0];
		scr.prefabScript.sidewalkControlElements[currentIndex].centerHandleV3 = scr.connections[currentIndex].rightSidewalkV3[0][0];
		ODQDQQOQCC(scr, scr.connections[currentIndex].rightSidewalkV3, ref scr.connections[currentIndex].rightSidewalkUV, scr.prefabScript.sidewalkControlElements[currentIndex], reverse: false);
		int index = 0;
		if (scr.connections.Count > currentIndex + 1)
		{
			index = currentIndex + 1;
		}
		OOOQCOQOOQ(scr, scr.connections[currentIndex].leftSidewalkV3, null, scr.prefabScript.sidewalkControlElements[index], 0, 0, -1);
		scr.prefabScript.sidewalkControlElements[index].leftHandleV3 = scr.connections[currentIndex].leftSidewalkV3[scr.connections[currentIndex].leftSidewalkV3.Count - 1][0];
		scr.prefabScript.sidewalkControlElements[index].centerHandleV3_2 = scr.connections[currentIndex].leftSidewalkV3[0][0];
		ODQDQQOQCC(scr, scr.connections[currentIndex].leftSidewalkV3, ref scr.connections[currentIndex].leftSidewalkUV, scr.prefabScript.sidewalkControlElements[index], reverse: true);
	}

	public static void OOCCDQCCOQ(ERRoundabouts scr, int currentIndex)
	{
		int num = 0;
		if (currentIndex == 0)
		{
			num = 0;
		}
		else
		{
			int rightOuterInt = scr.connections[currentIndex - 1].rightOuterInt;
			num = rightOuterInt + Mathf.RoundToInt((float)(scr.connections[currentIndex].leftOuterInt - rightOuterInt) * 1f * 0.5f);
		}
		for (int i = num; i <= scr.connections[currentIndex].leftOuterInt; i++)
		{
			scr.connections[currentIndex].leftSidewalkSourceVecs.Add(scr.mainLeftPoints[i]);
		}
		scr.connections[currentIndex].leftSidewalkSourceVecs.AddRange(scr.connections[currentIndex].leftOuterSegments);
		int num2 = 0;
		if (currentIndex == scr.connections.Count - 1)
		{
			num2 = scr.mainLeftPoints.Count - 1;
		}
		else
		{
			int leftOuterInt = scr.connections[currentIndex + 1].leftOuterInt;
			num2 = scr.connections[currentIndex].rightOuterInt + Mathf.RoundToInt((float)(leftOuterInt - scr.connections[currentIndex].rightOuterInt) * 0.5f);
		}
		scr.connections[currentIndex].rightSidewalkSourceVecs.AddRange(scr.connections[currentIndex].rightOuterSegments);
		scr.connections[currentIndex].rightSidewalkSourceVecs.Reverse();
		num = scr.connections[currentIndex].rightOuterInt;
		for (int j = num; j <= num2; j++)
		{
			scr.connections[currentIndex].rightSidewalkSourceVecs.Add(scr.mainLeftPoints[j]);
		}
		scr.connections[currentIndex].leftSidewalkSourceVecs.Reverse();
		scr.connections[currentIndex].leftSidewalkV3.Add(new List<Vector3>());
		scr.connections[currentIndex].leftSidewalkV3[0].AddRange(scr.connections[currentIndex].rightSidewalkSourceVecs);
		scr.connections[currentIndex].rightSidewalkV3.Add(new List<Vector3>());
		scr.connections[currentIndex].rightSidewalkV3[0].AddRange(scr.connections[currentIndex].leftSidewalkSourceVecs);
		scr.connections[currentIndex].leftSidewalkSourceVecs.Reverse();
		scr.connections[currentIndex].rightSidewalkSourceVecs.Reverse();
	}

	public static void OOOQCOQOOQ(ERRoundabouts scr, List<List<Vector3>> vecArray, List<List<Vector3>> vecArrayOther, QDOQDSQOOQDDD corner, int startEnd, int mainOrConnected, int outerCornerInt)
	{
		float num = 0f;
		float num2 = 0f;
		List<Vector3> list = new List<Vector3>();
		if (corner.beveledCurb)
		{
			if (corner.beveledHeight > 0f && corner.beveledHeight != corner.curbHeight)
			{
				num2 = corner.beveledHeight;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(OQODQDOQOQ(vecArray[0], num2));
			}
			num2 = corner.curbHeight;
			if (corner.beveledDepth > 0f && corner.beveledDepth != corner.curbDepth)
			{
				num = corner.beveledDepth;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(ODCODDCCOC(vecArray[0], null, num, num2, startEnd, mainOrConnected, -1));
			}
			if (corner.beveledDepth != corner.curbDepth)
			{
				num = corner.curbDepth;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(ODCODDCCOC(vecArray[0], null, num, num2, startEnd, mainOrConnected, -1));
			}
		}
		else
		{
			num2 = corner.curbHeight;
			vecArray.Add(new List<Vector3>());
			vecArray[vecArray.Count - 1].AddRange(OQODQDOQOQ(vecArray[0], num2));
			num = corner.curbDepth;
			vecArray.Add(new List<Vector3>());
			vecArray[vecArray.Count - 1].AddRange(ODCODDCCOC(vecArray[0], null, num, num2, startEnd, mainOrConnected, -1));
		}
		num = corner.sidewalkWidth1 - corner.curbDepth;
		vecArray.Add(new List<Vector3>());
		vecArray[vecArray.Count - 1].AddRange(ODCODDCCOC(vecArray[0], null, num, num2, startEnd, mainOrConnected, -1));
		if (corner.beveledCurb && corner.outerCurb)
		{
			if (corner.beveledDepth != corner.curbDepth && corner.beveledDepth > 0f)
			{
				num = corner.sidewalkWidth1 - corner.beveledDepth;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(ODCODDCCOC(vecArray[0], null, num, num2, startEnd, mainOrConnected, -1));
			}
			if (corner.beveledHeight > 0f && corner.beveledHeight != corner.curbHeight && corner.outerCurb)
			{
				num2 = corner.beveledHeight;
				num = corner.sidewalkWidth1;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(ODCODDCCOC(vecArray[0], null, num, num2, startEnd, mainOrConnected, -1));
			}
			num2 = 0f;
			num = corner.sidewalkWidth1;
			vecArray.Add(new List<Vector3>());
			vecArray[vecArray.Count - 1].AddRange(ODCODDCCOC(vecArray[0], null, num, num2, startEnd, mainOrConnected, -1));
		}
		else
		{
			num = corner.sidewalkWidth1;
			num2 = corner.curbHeight;
			vecArray.Add(new List<Vector3>());
			vecArray[vecArray.Count - 1].AddRange(ODCODDCCOC(vecArray[0], null, num, num2, startEnd, mainOrConnected, -1));
			if (corner.outerCurb)
			{
				num2 = 0f;
				vecArray.Add(new List<Vector3>());
				vecArray[vecArray.Count - 1].AddRange(ODCODDCCOC(vecArray[0], null, num, num2, startEnd, mainOrConnected, -1));
			}
		}
	}

	public static List<Vector3> ODCODDCCOC(List<Vector3> outer, List<Vector3> outerOther, float dist, float height, int startend, int leftright, int outerCornerInt)
	{
		List<Vector3> list = new List<Vector3>();
		Vector3 vector = Vector3.zero;
		int num = outer.Count;
		if (outerCornerInt != -1)
		{
			num = outerCornerInt;
		}
		for (int i = 0; i < num; i++)
		{
			Vector3 vector2 = ((i == 0) ? (outer[1] - outer[0]).normalized : ((i >= outer.Count - 1) ? (outer[i] - outer[i - 1]).normalized : (outer[i + 1] - outer[i - 1]).normalized));
			vector2 = ((leftright != 0) ? new Vector3(vector2.z, 0f, 0f - vector2.x) : new Vector3(0f - vector2.z, 0f, vector2.x));
			Vector3 vector3 = outer[i] + vector2 * dist;
			if (i > 0)
			{
				if (leftright == 0)
				{
					if (!ODQDQDQDQO.OQCDCDOOCD(vector, outer[i - 1], vector3))
					{
						vector3 = vector;
					}
				}
				else if (ODQDQDQDQO.OQCDCDOOCD(vector, outer[i - 1], vector3))
				{
					vector3 = vector;
				}
			}
			vector3.y = height;
			list.Add(vector3);
			vector = vector3;
		}
		return list;
	}

	public static List<Vector3> OQCDDCOODQ(ERRoundabouts scr, List<Vector3> innerArray, List<Vector3> outerOther, float dist, float height, float sidewalkWidth, int startend, int leftright, int outerCornerInt)
	{
		List<Vector3> list = new List<Vector3>();
		Vector3 normalized = (innerArray[1] - innerArray[0]).normalized;
		normalized = ((leftright != 0) ? new Vector3(normalized.z, 0f, 0f - normalized.x) : new Vector3(0f - normalized.z, 0f, normalized.x));
		Vector3 vector = innerArray[0] + normalized * sidewalkWidth;
		Vector3 vector2 = innerArray[0];
		Vector3 p = vector;
		if (leftright == 0)
		{
			p.z += 1f;
		}
		else
		{
			p.x += 1f;
		}
		int num = innerArray.Count;
		if (outerCornerInt != -1)
		{
			num = outerCornerInt;
		}
		for (int i = 0; i < num; i++)
		{
			vector2 = innerArray[i];
			if (leftright == 0)
			{
				vector2.x += 1f;
			}
			else
			{
				vector2.z += 1f;
			}
			Vector3 vector3 = ODQDQDQDQO.OODOQDOODO(vector, p, innerArray[i], vector2, flag: false);
			normalized = (innerArray[i] - vector3).normalized;
			vector3 += normalized * dist;
			vector3.y = height;
			list.Add(vector3);
		}
		return list;
	}

	public static List<Vector3> OQODQDOQOQ(List<Vector3> outer, float height)
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < outer.Count; i++)
		{
			Vector3 item = outer[i];
			item.y = height;
			list.Add(item);
		}
		return list;
	}

	public static void ODQDQQOQCC(ERRoundabouts scr, List<List<Vector3>> vecArray, ref List<List<Vector2>> uvArray, QDOQDSQOOQDDD corner, bool reverse)
	{
		if (corner.sidewalkUVs.Count == 0 || !corner.lockUVs)
		{
			ODQOQOCCOC(vecArray, ref corner.sidewalkUVs);
		}
		List<float> list = new List<float>();
		list.AddRange(corner.sidewalkUVs);
		uvArray.Clear();
		float num = 0f;
		List<float> list2 = new List<float>();
		for (int i = 0; i < vecArray.Count; i++)
		{
			uvArray.Add(new List<Vector2>());
			list2.Add(0f);
			uvArray[i].Add(new Vector2(list[i], 0f));
			num = 0f;
			for (int j = 1; j < vecArray[i].Count; j++)
			{
				num += Vector3.Distance(vecArray[i][j - 1], vecArray[i][j]);
				if (i == 0)
				{
					list2.Add(num / 2.5f);
				}
				uvArray[i].Add(new Vector2(list[i], list2[j]));
			}
		}
	}

	public static void ODQOQOCCOC(List<List<Vector3>> vecArray, ref List<float> sidewalkUVs)
	{
		sidewalkUVs.Clear();
		List<float> list = new List<float>();
		list.Add(0f);
		float num = 0f;
		for (int i = 1; i < vecArray.Count; i++)
		{
			num += Vector3.Distance(vecArray[i - 1][0], vecArray[i][0]);
			list.Add(num);
		}
		for (int j = 0; j < list.Count; j++)
		{
			sidewalkUVs.Add(list[j] / num);
		}
	}

	public static void OCCQQQDDDQ(ERRoundabouts scr)
	{
		int num = 0;
		for (int i = 0; i < scr.connections.Count; i++)
		{
			num = ((i != 0) ? (i - 1) : (scr.connections.Count - 1));
			for (int j = 0; j < scr.connections[i].rightSidewalkV3.Count; j++)
			{
				Vector3 a = scr.connections[i].rightSidewalkV3[j][scr.connections[i].rightSidewalkV3[j].Count - 1];
				Vector3 b = scr.connections[num].leftSidewalkV3[j][scr.connections[num].leftSidewalkV3[j].Count - 1];
				Vector3 value = Vector3.Lerp(a, b, 0.5f);
				scr.connections[i].rightSidewalkV3[j][scr.connections[i].rightSidewalkV3[j].Count - 1] = value;
				scr.connections[num].leftSidewalkV3[j][scr.connections[num].leftSidewalkV3[j].Count - 1] = value;
			}
		}
	}

	public static void SetInnerSidewalkVars(ERRoundabouts scr, int preset)
	{
		scr.innerSidewalkWidth1 = scr.baseScript.sidewalkPresets[preset - 1].sidewalkWidth1;
		scr.innerSidewalkWidth2 = scr.baseScript.sidewalkPresets[preset - 1].sidewalkWidth2;
		scr.innerCurbHeight = scr.baseScript.sidewalkPresets[preset - 1].curbHeight;
		scr.innerCurbDepth = scr.baseScript.sidewalkPresets[preset - 1].curbDepth;
		scr.innerBeveledCurb = scr.baseScript.sidewalkPresets[preset - 1].beveledCurb;
		scr.innerBeveledHeight = scr.baseScript.sidewalkPresets[preset - 1].beveledHeight;
		scr.innerBeveledDepth = scr.baseScript.sidewalkPresets[preset - 1].beveledDepth;
		scr.innerOuterCurb = scr.baseScript.sidewalkPresets[preset - 1].outerCurb;
		scr.innerRoadSideCurbUVControl = scr.baseScript.sidewalkPresets[preset - 1].roadSideCurbUVControl;
		scr.innerOuterSideCurbUVControl = scr.baseScript.sidewalkPresets[preset - 1].outerSideCurbUVControl;
		scr.innerSidewalkMaterial = scr.baseScript.sidewalkPresets[preset - 1].sidewalkMaterial;
		scr.innerSidewalkUVs = new List<float>(scr.baseScript.sidewalkPresets[preset - 1].sidewalkUVs);
	}

	public static void BuildInnerRoundaboutSidewalkData(ERRoundabouts scr, ERModularBase baseScr, List<Vector3> mainRightPoints, ref List<Vector3> innerRoundaboutSidewalkV3, ref List<Vector2> innerRoundaboutSidewalUV, ref List<int> innerRoundaboutSidewalTris, ref int innerSidewalkSegments)
	{
		if (baseScr.sidewalkPresets.Count <= scr.innerRoundaboutPreset - 1)
		{
			UnityEngine.Debug.Log("No sidewalk presets available in the scene data, inner sidewalk cannot be generated > Fix!");
		}
		float innerSidewalkWidth = scr.innerSidewalkWidth1;
		float innerSidewalkWidth2 = scr.innerSidewalkWidth2;
		float innerCurbHeight = scr.innerCurbHeight;
		float innerCurbDepth = scr.innerCurbDepth;
		bool innerBeveledCurb = scr.innerBeveledCurb;
		float innerBeveledHeight = scr.innerBeveledHeight;
		float innerBeveledDepth = scr.innerBeveledDepth;
		bool innerOuterCurb = scr.innerOuterCurb;
		bool innerRoadSideCurbUVControl = scr.innerRoadSideCurbUVControl;
		bool innerOuterSideCurbUVControl = scr.innerOuterSideCurbUVControl;
		scr.innerRoundaboutSidewalkMaterial = scr.innerSidewalkMaterial;
		List<float> innerSidewalkUVs = scr.innerSidewalkUVs;
		int num = 1;
		int num2 = 0;
		float num3 = 0f;
		float num4 = 0f;
		for (int i = 0; i < mainRightPoints.Count - 1; i++)
		{
			Vector3 vector = ((i != 0 && i != mainRightPoints.Count - 1) ? (mainRightPoints[i + 1] - mainRightPoints[i - 1]).normalized : (mainRightPoints[1] - mainRightPoints[mainRightPoints.Count - 2]).normalized);
			vector = new Vector3(vector.z, 0f, 0f - vector.x);
			if (i > 0)
			{
				num3 += Vector3.Distance(mainRightPoints[i - 1], mainRightPoints[i]);
			}
			num4 = num3 / 2.5f;
			for (int j = 0; j < innerSidewalkUVs.Count; j++)
			{
				innerRoundaboutSidewalUV.Add(new Vector2(innerSidewalkUVs[j], num4));
			}
			Vector3 item = mainRightPoints[i];
			innerRoundaboutSidewalkV3.Add(item);
			if (innerBeveledCurb)
			{
				if (innerBeveledHeight > 0f)
				{
					item.y += innerBeveledHeight;
					innerRoundaboutSidewalkV3.Add(item);
					if (i == 0)
					{
						num++;
					}
					item.y += innerCurbHeight - innerBeveledHeight;
				}
				else
				{
					item.y += innerCurbHeight;
				}
				if (innerBeveledDepth > 0f)
				{
					item += vector * innerBeveledDepth;
					innerRoundaboutSidewalkV3.Add(item);
					if (i == 0)
					{
						num++;
					}
					item += vector * (innerCurbDepth - innerBeveledDepth);
				}
				else
				{
					item += vector * innerCurbDepth;
				}
			}
			else
			{
				item.y += innerCurbHeight;
				innerRoundaboutSidewalkV3.Add(item);
				if (i == 0)
				{
					num++;
				}
				item += vector * innerCurbDepth;
			}
			innerRoundaboutSidewalkV3.Add(item);
			if (i == 0)
			{
				num++;
			}
			item += vector * (innerSidewalkWidth - 2f * innerCurbDepth);
			innerRoundaboutSidewalkV3.Add(item);
			if (i == 0)
			{
				num++;
			}
			if (innerOuterCurb)
			{
				if (innerBeveledCurb)
				{
					if (innerBeveledDepth > 0f)
					{
						item += vector * (innerCurbDepth - innerBeveledDepth);
						innerRoundaboutSidewalkV3.Add(item);
						if (i == 0)
						{
							num++;
						}
						item += vector * innerBeveledDepth;
					}
					else
					{
						item += vector * innerCurbDepth;
					}
					if (innerBeveledHeight > 0f)
					{
						item.y -= innerCurbHeight - innerBeveledHeight;
						innerRoundaboutSidewalkV3.Add(item);
						if (i == 0)
						{
							num++;
						}
						item.y -= innerBeveledHeight;
					}
					else
					{
						item.y -= innerCurbHeight;
					}
					innerRoundaboutSidewalkV3.Add(item);
					if (i == 0)
					{
						num++;
					}
				}
				else
				{
					item += vector * innerCurbDepth;
					innerRoundaboutSidewalkV3.Add(item);
					if (i == 0)
					{
						num++;
					}
					item.y -= innerCurbHeight;
					innerRoundaboutSidewalkV3.Add(item);
					if (i == 0)
					{
						num++;
					}
				}
			}
			else
			{
				item += vector * innerCurbDepth;
				innerRoundaboutSidewalkV3.Add(item);
				if (i == 0)
				{
					num++;
				}
			}
			num2++;
		}
		int num5 = num;
		for (int k = 0; k < num2 - 1; k++)
		{
			for (int l = 0; l < num5 - 1; l++)
			{
				innerRoundaboutSidewalTris.Add(k * num5 + l);
				innerRoundaboutSidewalTris.Add((k + 1) * num5 + l + 1);
				innerRoundaboutSidewalTris.Add(k * num5 + l + 1);
				innerRoundaboutSidewalTris.Add((k + 1) * num5 + l);
				innerRoundaboutSidewalTris.Add((k + 1) * num5 + l + 1);
				innerRoundaboutSidewalTris.Add(k * num5 + l);
			}
		}
		for (int m = 0; m < num; m++)
		{
			List<Vector3> obj = innerRoundaboutSidewalkV3;
			int index = m;
			Vector3 value = (innerRoundaboutSidewalkV3[innerRoundaboutSidewalkV3.Count - num + m] = Vector3.Lerp(innerRoundaboutSidewalkV3[m], innerRoundaboutSidewalkV3[innerRoundaboutSidewalkV3.Count - num + m], 0.5f));
			obj[index] = value;
		}
		innerSidewalkSegments = num;
	}
}
[AddComponentMenu("")]
public class ERSideObjectSection : MonoBehaviour
{
	public ERModularRoad road;

	public int sectionListIndex = 0;

	public int sectionIndex = 0;

	public double soId = 0.0;

	public int leftright = 0;

	public bool mirrored;

	public void Copy(ERSideObjectSection source)
	{
		road = source.road;
		sectionListIndex = source.sectionListIndex;
		sectionIndex = source.sectionIndex;
		soId = source.soId;
		leftright = source.leftright;
		mirrored = source.mirrored;
	}
}
[AddComponentMenu("")]
public class OCOCDDODDQ : MonoBehaviour
{
	public static void OQCODQOCQD(ERSideWalk sw, ref List<Vector3> vecs, Vector3 startVec, int rows, int closedVecCountStart, int closedVecCountEnd, int startEnd)
	{
		float num = 2f;
		float num2 = UnityEngine.Random.Range(sw.minEnd, sw.maxEnd);
		if (num2 == 1f)
		{
			return;
		}
		if (startEnd == 0)
		{
			for (int i = 0; i < vecs.Count; i += rows)
			{
				float num3 = Vector3.Distance(startVec, vecs[i]);
				if (num3 < 2f)
				{
					float t = num3 / 2f;
					for (int j = 0; j < rows; j++)
					{
						Vector3 value = vecs[i + j];
						value.y = Mathf.Lerp(value.y * num2, value.y, t);
						vecs[i + j] = value;
					}
					continue;
				}
				break;
			}
		}
		for (int k = closedVecCountStart; k < closedVecCountEnd; k++)
		{
			Vector3 value2 = vecs[k];
			value2.y *= num2;
			vecs[k] = value2;
		}
	}
}
[Serializable]
public class ERTerrainData
{
	public int terrainWidth;

	public int terrainHeight;

	public float originalHeight;

	public float flattenedHeight;

	public float outerHeightDifference = 0f;

	public bool critical = false;

	public float perc = 0f;

	public Vector3 hitpos;

	public Vector3 outerPos;

	public bool ignorePreserveHeights = false;

	public ERTerrainData(int m_terrainWidth, int m_terrainHeight, float m_originalHeight, float m_flattenedHeight, bool m_critical, float m_perc, float m_outerHeight, Vector3 m_hitPoint, Vector3 m_outerPoint)
	{
		terrainWidth = m_terrainWidth;
		terrainHeight = m_terrainHeight;
		originalHeight = m_originalHeight;
		outerHeightDifference = m_outerHeight;
		flattenedHeight = m_flattenedHeight;
		critical = m_critical;
		perc = m_perc;
		hitpos = m_hitPoint;
		outerPos = m_outerPoint;
	}
}
[AddComponentMenu("")]
public class ERTSidewalkTriangulation : MonoBehaviour
{
	public static void OQDCOQDQDO(ERCrossings scr, ref List<Vector3> meshVecs, ref List<Vector2> meshUVs, ref List<List<int>> triList, ref List<Material> materialList)
	{
		OQCQDDDOQD(scr, scr.leftSidewalkStartV3, scr.leftSidewalkStartUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.leftSidewalkStartTris, ref materialList, reverse: true, scr.prefabScript.sidewalkControlElements[0], scr.leftStartSidewalkCornerInt);
		OQCQDDDOQD(scr, scr.rightSidewalkLeftV3, scr.rightSidewalkLeftUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.rightSidewalkLeftTris, ref materialList, reverse: false, scr.prefabScript.sidewalkControlElements[0], scr.rightLeftSidewalkCornerInt);
		OQCQDDDOQD(scr, scr.rightSidewalkStartV3, scr.rightSidewalkStartUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.rightSidewalkStartTris, ref materialList, reverse: false, scr.prefabScript.sidewalkControlElements[1], scr.rightStartSidewalkCornerInt);
		OQCQDDDOQD(scr, scr.leftSidewalkRightV3, scr.leftSidewalkRightUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.leftSidewalkRightTris, ref materialList, reverse: true, scr.prefabScript.sidewalkControlElements[1], scr.leftRightSidewalkCornerInt);
		OQCQDDDOQD(scr, scr.leftSidewalkEndV3, scr.leftSidewalkEndUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.leftSidewalkEndTris, ref materialList, reverse: true, scr.prefabScript.sidewalkControlElements[3], scr.leftEndSidewalkCornerInt);
		OQCQDDDOQD(scr, scr.rightSidewalkRightV3, scr.rightSidewalkRightUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.rightSidewalkRightTris, ref materialList, reverse: false, scr.prefabScript.sidewalkControlElements[3], scr.rightRightSidewalkCornerInt);
		OQCQDDDOQD(scr, scr.rightSidewalkEndV3, scr.rightSidewalkEndUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.rightSidewalkEndTris, ref materialList, reverse: false, scr.prefabScript.sidewalkControlElements[2], scr.rightEndSidewalkCornerInt);
		OQCQDDDOQD(scr, scr.leftSidewalkLeftV3, scr.leftSidewalkLeftUV, 0, 0, ref meshVecs, ref meshUVs, ref triList, ref scr.leftSidewalkLeftTris, ref materialList, reverse: true, scr.prefabScript.sidewalkControlElements[2], scr.leftLeftSidewalkCornerInt);
		if (!scr.prefabScript.crossingElements[0].includeLeftSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[0], scr.leftSidewalkStartV3, scr.leftSidewalkStartUV, scr.leftSidewalkStartTris, ref meshVecs, ref meshUVs, ref triList, materialList, 0);
		}
		if (!scr.prefabScript.crossingElements[0].includeRightSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[1], scr.rightSidewalkStartV3, scr.rightSidewalkStartUV, scr.rightSidewalkStartTris, ref meshVecs, ref meshUVs, ref triList, materialList, 1);
		}
		if (!scr.prefabScript.crossingElements[1].includeRightSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[2], scr.rightSidewalkEndV3, scr.rightSidewalkEndUV, scr.rightSidewalkEndTris, ref meshVecs, ref meshUVs, ref triList, materialList, 1);
		}
		if (!scr.prefabScript.crossingElements[1].includeLeftSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[3], scr.leftSidewalkEndV3, scr.leftSidewalkEndUV, scr.leftSidewalkEndTris, ref meshVecs, ref meshUVs, ref triList, materialList, 0);
		}
		if (!scr.prefabScript.crossingElements[2].includeLeftSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[2], scr.leftSidewalkLeftV3, scr.leftSidewalkLeftUV, scr.leftSidewalkLeftTris, ref meshVecs, ref meshUVs, ref triList, materialList, 0);
		}
		if (!scr.prefabScript.crossingElements[2].includeRightSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[0], scr.rightSidewalkLeftV3, scr.rightSidewalkLeftUV, scr.rightSidewalkLeftTris, ref meshVecs, ref meshUVs, ref triList, materialList, 1);
		}
		if (!scr.prefabScript.crossingElements[3].includeLeftSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[1], scr.leftSidewalkRightV3, scr.leftSidewalkRightUV, scr.leftSidewalkRightTris, ref meshVecs, ref meshUVs, ref triList, materialList, 0);
		}
		if (!scr.prefabScript.crossingElements[3].includeRightSidewalk)
		{
			OQCODDOCCD(scr, scr.prefabScript.sidewalkControlElements[3], scr.rightSidewalkRightV3, scr.rightSidewalkRightUV, scr.rightSidewalkRightTris, ref meshVecs, ref meshUVs, ref triList, materialList, 1);
		}
	}

	public static void OQCQDDDOQD(ERCrossings scr, List<List<Vector3>> vecArray, List<List<Vector2>> uvArray, int frontLeft, int topBottom, ref List<Vector3> meshVecs, ref List<Vector2> meshUVs, ref List<List<int>> triList, ref List<List<int>> intArray, ref List<Material> materialList, bool reverse, QDOQDSQOOQDDD corner, int outerCornerInt)
	{
		int triArrayElement = 0;
		ODOOOODDOO(ref materialList, ref triList, corner.sidewalkMaterial, ref triArrayElement);
		int num = meshVecs.Count;
		for (int i = 0; i < vecArray.Count; i++)
		{
			intArray.Add(new List<int>());
			for (int j = 0; j < vecArray[i].Count; j++)
			{
				meshVecs.Add(vecArray[i][j]);
				meshUVs.Add(uvArray[i][j]);
				intArray[i].Add(num);
				num++;
			}
		}
		for (int k = 0; k < intArray.Count - 1; k++)
		{
			if (!reverse)
			{
				triList[triArrayElement].AddRange(OCCQOODCCO(intArray[k], intArray[k + 1]));
			}
			else
			{
				triList[triArrayElement].AddRange(OCCQOODCCO(intArray[k + 1], intArray[k]));
			}
		}
		if (corner.beveledCurb)
		{
			if (corner.beveledHeight == 0f && corner.beveledDepth == 0f)
			{
				triList[triArrayElement].AddRange(OODOODOQOO(intArray[2][outerCornerInt - 1], intArray[1], outerCornerInt - 1, !reverse));
			}
			else if (corner.beveledHeight == 0f || corner.beveledDepth == 0f)
			{
				triList[triArrayElement].AddRange(OODOODOQOO(intArray[3][outerCornerInt - 1], intArray[2], outerCornerInt - 1, !reverse));
			}
			else
			{
				triList[triArrayElement].AddRange(OODOODOQOO(intArray[4][outerCornerInt - 1], intArray[3], outerCornerInt - 1, !reverse));
			}
		}
		else
		{
			triList[triArrayElement].AddRange(OODOODOQOO(intArray[3][outerCornerInt - 1], intArray[2], outerCornerInt - 1, !reverse));
		}
	}

	public static List<int> OCCQOODCCO(List<int> col1, List<int> col2)
	{
		List<int> list = new List<int>();
		int count = col1.Count;
		if (col2.Count < col1.Count)
		{
			count = col2.Count;
		}
		for (int i = 0; i < count - 1; i++)
		{
			list.Add(col1[i]);
			list.Add(col2[i + 1]);
			list.Add(col2[i]);
			list.Add(col1[i + 1]);
			list.Add(col2[i + 1]);
			list.Add(col1[i]);
		}
		return list;
	}

	public static List<int> OODOODOQOO(int outerPoint, List<int> innerCol, int startPoint, bool reverse)
	{
		List<int> list = new List<int>();
		for (int i = startPoint; i < innerCol.Count - 1; i++)
		{
			if (!reverse)
			{
				list.Add(outerPoint);
				list.Add(innerCol[i + 1]);
				list.Add(innerCol[i]);
			}
			else
			{
				list.Add(outerPoint);
				list.Add(innerCol[i]);
				list.Add(innerCol[i + 1]);
			}
		}
		return list;
	}

	public static void OQCODDOCCD(ERCrossings scr, QDOQDSQOOQDDD corner, List<List<Vector3>> sourceVecs, List<List<Vector2>> sourceUVs, List<List<int>> sourceTris, ref List<Vector3> vecs, ref List<Vector2> uvs, ref List<List<int>> triList, List<Material> materialList, int leftrightroad)
	{
		int triArrayElement = 0;
		ODOOOODDOO(ref materialList, ref triList, corner.sidewalkMaterial, ref triArrayElement);
		if (corner.outerCurb)
		{
			if (!corner.beveledCurb)
			{
				OOQOQOODQC.OCDCCCCCCQ(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
			}
			else if (corner.beveledHeight > 0f && corner.beveledDepth > 0f)
			{
				OOQOQOODQC.ODCQCQQQCQ(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
			}
			else if (corner.beveledHeight > 0f)
			{
				OOQOQOODQC.OQDDCCCQQQ(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
			}
			else if (corner.beveledDepth > 0f)
			{
				OOQOQOODQC.OODCCQQDOO(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
			}
			else
			{
				OOQOQOODQC.OQCDQQODOD(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
			}
		}
		else if (!corner.beveledCurb)
		{
			OOQOQOODQC.OCQDQCQDCC(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, 0, hardEdge: false);
		}
		else if (corner.beveledHeight > 0f && corner.beveledDepth > 0f)
		{
			OOQOQOODQC.ODOODOCDOD(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
		}
		else if (corner.beveledHeight > 0f)
		{
			OOQOQOODQC.OODDQQQDDQ(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
		}
		else if (corner.beveledDepth > 0f)
		{
			OOQOQOODQC.OCCDCDCODO(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
		}
		else
		{
			OOQOQOODQC.ODOQCDCCOQ(scr, corner, sourceVecs, sourceUVs, sourceTris, ref vecs, ref uvs, ref triList, triArrayElement, leftrightroad, hardEdge: false);
		}
	}

	public static void OOCQCDDQOD()
	{
	}

	public static void ODOOOODDOO(ref List<Material> materialList, ref List<List<int>> triList, Material sidewalkMaterial, ref int triArrayElement)
	{
		for (int i = 0; i < materialList.Count; i++)
		{
			if (materialList[i] == sidewalkMaterial)
			{
				triArrayElement = i;
				return;
			}
		}
		materialList.Add(sidewalkMaterial);
		triList.Add(new List<int>());
		triArrayElement = materialList.Count - 1;
	}
}
public class BinaryWriterEx : BinaryWriter
{
	public BinaryWriterEx()
	{
	}

	public BinaryWriterEx(string fileName)
	{
	}

	public long Seek(long offset, SeekOrigin origin)
	{
		Flush();
		return BaseStream.Seek(offset, origin);
	}

	public void WriteStruct(object theStruct)
	{
		byte[] array = new byte[Marshal.SizeOf(theStruct.GetType())];
		GCHandle gCHandle = GCHandle.Alloc(array, GCHandleType.Pinned);
		Marshal.StructureToPtr(theStruct, gCHandle.AddrOfPinnedObject(), fDeleteOld: false);
		gCHandle.Free();
		Write(array);
	}

	public void Write(int[] array)
	{
		byte[] array2 = new byte[4 * array.Length];
		int num = 0;
		foreach (int value in array)
		{
			byte[] bytes = BitConverter.GetBytes(value);
			array2[num++] = bytes[0];
			array2[num++] = bytes[1];
			array2[num++] = bytes[2];
			array2[num++] = bytes[3];
		}
		Write(array2);
	}

	public void Write(float[] array)
	{
		byte[] array2 = new byte[4 * array.Length];
		int num = 0;
		foreach (float value in array)
		{
			byte[] bytes = BitConverter.GetBytes(value);
			array2[num++] = bytes[0];
			array2[num++] = bytes[1];
			array2[num++] = bytes[2];
			array2[num++] = bytes[3];
		}
		Write(array2);
	}
}
[AddComponentMenu("")]
public class ODOOCCQDOC : MonoBehaviour
{
	public static void ODCQCQCQDQ(Mesh mesh)
	{
		int num = -1;
		Vector3[] verts = mesh.vertices;
		Vector3[] array = new Vector3[mesh.vertices.Length];
		Array.Copy(mesh.vertices, array, mesh.vertices.Length);
		int[] tris = mesh.triangles;
		int[] array2 = new int[mesh.triangles.Length];
		Array.Copy(mesh.triangles, array2, mesh.triangles.Length);
		for (int i = 0; i < verts.Length - 1; i++)
		{
			if (verts[i] != Vector3.zero)
			{
				num = OQQQCDCOOO(ref verts, i + 1, verts[i]);
				if (num != -1)
				{
					OCDDOQQCDO(ref tris, num, i);
				}
			}
		}
		List<int> list = new List<int>();
		for (int j = 0; j < tris.Length; j += 3)
		{
			if (tris[j] != tris[j + 1] && tris[j] != tris[j + 2] && tris[j + 1] != tris[j + 2])
			{
				list.Add(tris[j]);
				list.Add(tris[j + 1]);
				list.Add(tris[j + 2]);
			}
		}
		mesh.vertices = verts;
		mesh.triangles = list.ToArray();
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();
		Vector3[] array3 = new Vector3[mesh.normals.Length];
		Array.Copy(mesh.normals, array3, mesh.normals.Length);
		for (int k = 0; k < verts.Length; k++)
		{
			if (!(verts[k] == Vector3.zero))
			{
				continue;
			}
			for (int l = 0; l < verts.Length; l++)
			{
				if (array[k] == mesh.vertices[l])
				{
					array3[k] = array3[l];
					break;
				}
			}
		}
		mesh.vertices = array;
		mesh.triangles = array2;
		mesh.normals = array3;
	}

	public static void OptimizeMeshFull(Mesh mesh)
	{
		int num = -1;
		Vector3[] verts = mesh.vertices;
		Vector3[] destinationArray = new Vector3[mesh.vertices.Length];
		Array.Copy(mesh.vertices, destinationArray, mesh.vertices.Length);
		int[] tris = mesh.triangles;
		int[] destinationArray2 = new int[mesh.triangles.Length];
		Array.Copy(mesh.triangles, destinationArray2, mesh.triangles.Length);
		for (int i = 0; i < verts.Length - 1; i++)
		{
			if (verts[i] != Vector3.zero)
			{
				num = OQQQCDCOOO(ref verts, i + 1, verts[i]);
				if (num != -1)
				{
					OCDDOQQCDO(ref tris, num, i);
				}
			}
		}
		List<int> list = new List<int>();
		for (int j = 0; j < tris.Length; j += 3)
		{
			if (tris[j] != tris[j + 1] && tris[j] != tris[j + 2] && tris[j + 1] != tris[j + 2])
			{
				list.Add(tris[j]);
				list.Add(tris[j + 1]);
				list.Add(tris[j + 2]);
			}
		}
		mesh.vertices = verts;
		mesh.triangles = list.ToArray();
	}

	public static void OptimizeVertices(List<Vector3> vecs, List<int> triangles)
	{
		int num = -1;
		Vector3[] verts = vecs.ToArray();
		int[] tris = triangles.ToArray();
		for (int i = 0; i < verts.Length - 1; i++)
		{
			if (verts[i] != Vector3.zero)
			{
				num = OQQQCDCOOO(ref verts, i + 1, verts[i]);
				if (num != -1)
				{
					OCDDOQQCDO(ref tris, num, i);
				}
			}
		}
		List<int> list = new List<int>();
		for (int j = 0; j < tris.Length; j += 3)
		{
			if (tris[j] != tris[j + 1] && tris[j] != tris[j + 2] && tris[j + 1] != tris[j + 2])
			{
				list.Add(tris[j]);
				list.Add(tris[j + 1]);
				list.Add(tris[j + 2]);
			}
		}
		vecs = new List<Vector3>(verts);
		triangles = new List<int>(list);
	}

	public static int OQQQCDCOOO(ref Vector3[] verts, int start, Vector3 v)
	{
		for (int i = start; i < verts.Length; i++)
		{
			if (verts[i] == v)
			{
				verts[i] = Vector3.zero;
				return i;
			}
		}
		return -1;
	}

	public static void OCDDOQQCDO(ref int[] tris, int old, int newInt)
	{
		for (int i = 0; i < tris.Length; i++)
		{
			if (tris[i] == old)
			{
				tris[i] = newInt;
			}
		}
	}
}
public class ERExtension
{
}
public class OQDQODQQCC : MonoBehaviour
{
	public static void OODDQOQCCD(int el, ref List<int> OQCODQQCOO, ref List<Vector3> OOOQOOOODO, ref List<Vector3> OCCDOQDDOD, List<Vector2> OODQOODCOQ, List<Vector2> OCOCQQCDOQ, int[] OCQDQOCDCQ, int[] OCDCODCDQC, int[] ODCQQOQCCC, int[] ODCOCDCQDO, ref Vector3[] OODOOCCDQO, ref Vector2[] OQQOCCDCQO, ref int[] OOOOQOODCD, ref Vector3[] OQCDOCDOQQ, ref Vector3[] OOCOOQQDCO, ref Vector3[] OCCQCDCOCD, ref Vector3[] OCQCCCOOCO, int ODQCCQDCDC, bool OQQOOQCCDD, Vector3 OQCCCODDCD)
	{
		List<Vector2> list = new List<Vector2>();
		List<Vector2> list2 = new List<Vector2>();
		List<Vector2> list3 = new List<Vector2>();
		List<Vector2> list4 = new List<Vector2>();
		List<Vector3> list5 = new List<Vector3>();
		List<Vector3> list6 = new List<Vector3>();
		List<Vector3> list7 = new List<Vector3>();
		List<Vector3> list8 = new List<Vector3>();
		Vector3[] collection = OODOOCCDQO;
		List<Vector3> list9 = new List<Vector3>(collection);
		Vector2[] collection2 = OQQOCCDCQO;
		List<Vector2> list10 = new List<Vector2>(collection2);
		if (ODQCCQDCDC == 0)
		{
			OQCODQQCOO.Add(1);
			OQCODQQCOO.Add(0);
			OQCODQQCOO.Add(3);
			OQCODQQCOO.Add(3);
			OQCODQQCOO.Add(0);
			OQCODQQCOO.Add(4);
			OQCODQQCOO.Add(6);
			OQCODQQCOO.Add(7);
			OQCODQQCOO.Add(8);
			OQCODQQCOO.Add(6);
			OQCODQQCOO.Add(4);
			OQCODQQCOO.Add(7);
			int num = ODCQQOQCCC[el] - OCQDQOCDCQ[el];
			if (num > 1)
			{
				int count = list9.Count;
				list9.Add(OOOQOOOODO[OCQDQOCDCQ[el] + 1]);
				list10.Add(OODQOODCOQ[OCQDQOCDCQ[el] + 1]);
				OQCODQQCOO.Add(0);
				OQCODQQCOO.Add(count);
				OQCODQQCOO.Add(4);
				for (int i = 1; i < num - 1; i++)
				{
					list9.Add(OOOQOOOODO[OCQDQOCDCQ[el] + i + 1]);
					list10.Add(OCOCQQCDOQ[OCQDQOCDCQ[el] + i + 1]);
					OQCODQQCOO.Add(count + i - 1);
					OQCODQQCOO.Add(count + i);
					OQCODQQCOO.Add(4);
				}
				OQCODQQCOO.Add(count + num - 2);
				OQCODQQCOO.Add(7);
				OQCODQQCOO.Add(4);
			}
			else
			{
				OQCODQQCOO.Add(0);
				OQCODQQCOO.Add(7);
				OQCODQQCOO.Add(4);
			}
		}
		else
		{
			OQCODQQCOO.Add(2);
			OQCODQQCOO.Add(1);
			OQCODQQCOO.Add(0);
			OQCODQQCOO.Add(2);
			OQCODQQCOO.Add(4);
			OQCODQQCOO.Add(1);
			OQCODQQCOO.Add(5);
			OQCODQQCOO.Add(7);
			OQCODQQCOO.Add(8);
			OQCODQQCOO.Add(5);
			OQCODQQCOO.Add(8);
			OQCODQQCOO.Add(4);
			int num2 = ODCOCDCQDO[el] - OCDCODCDQC[el];
			if (num2 > 1)
			{
				int count2 = list9.Count;
				list9.Add(OCCDOQDDOD[OCDCODCDQC[el] + 1]);
				list10.Add(OCOCQQCDOQ[OCDCODCDQC[el] + 1]);
				OQCODQQCOO.Add(1);
				OQCODQQCOO.Add(4);
				OQCODQQCOO.Add(count2);
				for (int j = 1; j < num2 - 1; j++)
				{
					list9.Add(OCCDOQDDOD[OCDCODCDQC[el] + j + 1]);
					list10.Add(OCOCQQCDOQ[OCDCODCDQC[el] + j + 1]);
					OQCODQQCOO.Add(count2 + j - 1);
					OQCODQQCOO.Add(4);
					OQCODQQCOO.Add(count2 + j);
				}
				OQCODQQCOO.Add(count2 + num2 - 2);
				OQCODQQCOO.Add(4);
				OQCODQQCOO.Add(8);
			}
			else
			{
				OQCODQQCOO.Add(1);
				OQCODQQCOO.Add(4);
				OQCODQQCOO.Add(8);
			}
		}
		OODOOCCDQO = list9.ToArray();
		OQQOCCDCQO = list10.ToArray();
	}

	public static void OCOOQCQOQO(ref List<Vector3> OOQCOODQDO, ref List<Vector3> OQQQCQQCOC, ref List<Vector3> OCQQOCQQQD, ref List<Vector3> OOOQDCCCQD, List<Vector3> vecs, List<Vector3> OCDQDQQCCC, int start, int end, Vector3 OQCCCODDCD, string OQDQOQDOCO, bool OQQOOQCCDD, Vector3 OCQQCCCQOQ, Vector3 OCDOOQOOCO, ref List<Vector2> ODQOOOCDQO, ref List<Vector2> OCOQQDODOO, List<Vector2> UVs)
	{
	}

	public static void OQCQCDCOQQ(List<Vector2> OCOCQQCDOQ, Vector3 OQCCCODDCD, List<Vector3> OOCCDCODCC, List<Vector3> OQDQQDCOQO, List<Vector2> OCDOCDODOD, List<Vector2> OCODQCCQOD, int el, Vector3[] OQODCDCQDD, Vector3[] OQQOCQOQQO, Vector2[] OCDOQODDCC, Vector2[] OOOQOCCOQO, Vector3 OCCCOQCCQO, Vector3 OOCCOQDQOD, Vector2 OCCOCQCDCQ, Vector2 OOCQDQCQDO)
	{
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		List<int> list3 = new List<int>();
	}

	public static void OCDCOOOCCC(List<Vector2> OODQOODCOQ, Vector3 OQCCCODDCD, List<Vector3> OQODCDCQDD, List<Vector3> OQQOCQOQQO, List<Vector2> OCDOCDODOD, List<Vector2> OCODQCCQOD, int el, Vector3[] OOCCDCODCC, Vector3[] OQDQQDCOQO, Vector2[] ODQDDQDCCD, Vector2[] ODQQOQQODQ, Vector3 OQOQQDODOO, Vector3 OQOCDOQQOD, Vector2 OQOQQDODOOUV, Vector2 OQOCDOQQODUV)
	{
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		List<int> list3 = new List<int>();
	}

	public static void ODDDCOCCQO(int el, Vector3[] OQDOQQCOCQ, Vector2[] ODQOOOCDQO, Vector3[] OQODCDCQDD, Vector3[] OOCCDCODCC, Vector2[] OCDOQODDCC, Vector2[] ODQDDQDCCD, Vector3 OQCCCODDCD)
	{
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		List<int> list3 = new List<int>();
	}

	public static void OQQDCQOCQC(int el, Vector3[] OOQCQCOODD, Vector2[] OCOQQDODOO, Vector3[] OQQOCQOQQO, Vector3[] OQDQQDCOQO, Vector2[] OOOQOCCOQO, Vector2[] ODQQOQQODQ, Vector3 OQCCCODDCD)
	{
		List<Vector3> list = new List<Vector3>();
		List<Vector2> list2 = new List<Vector2>();
		List<int> list3 = new List<int>();
	}
}
public class TerrainsV3
{
	public Terrain terrain;

	public string id;
}
public class PointERV3
{
	public float timeCreated = 0f;

	public Vector3 position;

	public bool lineBreak = false;

	public int curveFlag;

	public float Time;

	public int x;

	public int y;

	public int z;
}
